[
  {
    "language": "Scala",
    "code": "import scala.annotation.tailrec\nimport scala.collection.mutable\n\nobject Main extends App {\n  import scala.io.StdIn._\n\n\n  val Array(n, m) = readLine.trim.split(' ').map(_.toInt)\n  val weights = readLine.trim.split(' ').map(_.toInt)\n  val edges = Array.tabulate(n){_ ⇒ Nil: List[Int]}\n  val dimensions = Array.tabulate(n){_ ⇒ 0}\n  for (_ ← 0 until m){\n    val Array(u, v) = readLine.trim.split(' ').map(_.toInt)\n    edges(u - 1) ::= v - 1\n    dimensions(u - 1) += 1\n    edges(v - 1) ::= u - 1\n    dimensions(v - 1) += 1\n  }\n  val singlePathMemo = Array.tabulate(n){_ ⇒ 0}\n  dimensions.indices.tail.filter(i ⇒ dimensions(i) == 1).foreach(i ⇒ singlePathCost(i))\n  println(singlePathMemo.max + dimensions.indices.filter(i ⇒ i == 0 || dimensions(i) != 1).map(i ⇒ weights(i)).sum)\n  @tailrec\n  def singlePathCost(current: Int, prev: Int = -1, result: Int = 0): Unit = {\n      if (dimensions(current) != 1 || current == 0) {\n        singlePathMemo(current) = math.max(singlePathMemo(current), result)\n      }\n      else {\n        edges(current).filter(i ⇒ i == 0 || dimensions(i) != 1) match {\n          case next::Nil ⇒\n            dimensions(next) -= 1\n            singlePathCost(next, current, math.max(singlePathMemo(current), result) + weights(current))\n          case _ ⇒ ???\n        }\n      }\n  }\n\n\n  case class Cost(any: Int, one: Int)\n  implicit class Extension[T](val value :T) extends AnyVal {\n    @inline\n    def let[A](@inline func: T ⇒ A): A = func(value)\n    @inline\n    def also(@inline func: T ⇒ Unit): T = {func(value); value}\n    @inline\n    def takeIf(@inline predicate: T ⇒ Boolean): Option[T] = Some(value).filter(predicate)\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool dfs1(int v, int prev, vector<vector<int>>& g, vector<bool>& visited, vector<bool>& f) {\n    visited[v] = true;\n    bool res = false;\n    for(auto to : g[v]) {\n        if(to == prev) {\n            continue;\n        }\n        if(visited[to]) {\n            res = true;\n        } else {\n            res |= dfs1(to, v, g, visited, f);\n        }\n    }\n    return f[v] = res;\n}\n\nint dfs2(int v, vector<vector<int>>& g, vector<bool>& f, int sum, vector<int> const& w) {\n    sum += w[v];\n    f[v] = true;\n    int res = sum;\n    for(auto to : g[v]) {\n        if(!f[to]) {\n            res = max(res, dfs2(to, g, f, sum, w));\n        }\n    }\n    return res;\n}\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    vector<int> w(N);\n    for(int i=0; i<N; ++i) {\n        cin >> w[i];\n    }\n    vector<vector<int>> g(N);\n    for(int i=0; i<M; ++i) {\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    vector<bool> visited(N);\n    vector<bool> f(N);\n    dfs1(0, -1, g, visited, f);\n    int res = 0;\n    for(int i=0; i<N; ++i) {\n        if(f[i]) {\n            res += w[i];\n        }\n    }\n    int ma = 0;\n    for(int i=0; i<N; ++i) {\n        if(!f[i]) {\n            ma = max(ma, dfs2(i, g, f, 0, w));\n        }\n    }\n    cout << res + ma << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing Weight=long long;\n\nstruct Edge{\n    int src,dst;\n    Edge(int src,int dst):\n    src(src),dst(dst){}\n};\n\nusing Edges=vector<Edge>;\nusing Graph=vector<Edges>;\n\npair<vector<int>, Edges> bridge(const Graph& g) {\n\tconst int n = g.size();\n\tint idx = 0, s = 0, t = 0, k = 0;\n\tvector<int>ord(n, -1), onS(n), stk(n), roots(n), cmp(n);\n\tEdges brdg;\n\tfunction<void(int, int)> dfs = [&](int v, int u) {\n\t\tord[v] = idx++;\n\t\tstk[s++] = v;\n\t\tonS[v] = true;\n\t\troots[t++] = v;\n\t\tfor (auto& e : g[v]) {\n\t\t\tint w = e.dst;\n\t\t\tif (ord[w] == -1)dfs(w, v);\n\t\t\telse if (u != w && onS[w])\n\t\t\t\twhile (ord[roots[t - 1]]>ord[w])--t;\n\t\t}\n\t\tif (v == roots[t - 1]) {\n\t\t\tbrdg.emplace_back(u, v);\n\t\t\twhile (true) {\n\t\t\t\tint w = stk[--s];\n\t\t\t\tonS[w] = false;\n\t\t\t\tcmp[w] = k;\n\t\t\t\tif (v == w)break;\n\t\t\t}\n\t\t\t--t;\n\t\t\t++k;\n\t\t}\n\t};\n\tfor (int u = 0; u<n; ++u) {\n\t\tif (ord[u] == -1) {\n\t\t\tdfs(u, n);\n\t\t\tbrdg.pop_back();\n\t\t}\n\t}\n\treturn make_pair(cmp, brdg);\n}\n\nint dfs1(const Graph &g,int p,int v,vector<bool> &elect,\nvector<int>&elements,vector<int>&cycle,vector<Weight>&node){\n    int res=0;\n    elect[v]=false;\n    for(auto e:g[v]){\n        if(e.dst!=p && elements[cycle[e.dst]]==1){\n            int t=dfs1(g,v,e.dst,elect,elements,cycle,node);\n            if(res < t)res=t;\n        }\n    }\n    return res+node[v];\n}\n\nint main(){\n    int n,m;\n    cin>>n>>m;\n    Graph g(n);\n    vector<Weight>node(n);\n    for(int i=0;i<n;++i){\n        cin>>node[i];\n    }\n    for(int i=0;i<m;++i){\n        int s,t;\n        cin>>s>>t;\n        --s;--t;\n        g[s].emplace_back(s,t);\n        g[t].emplace_back(t,s);\n    }\n    vector<int>cycle = bridge(g).first;\n    vector<int>elements(n,0);\n    for(int i=0;i<n;++i){\n        elements[cycle[i]]++;\n    }\n    vector<bool>elect(n,true);\n    int buf=0;\n    for(int i=0;i<n;++i){\n        if(g[i].size()==1){\n            buf=max(buf,dfs1(g,-1,g[i][0].src,elect,elements,cycle,node));\n        }\n    }\n    int ans=0;\n    for(int i=0;i<n;++i){\n        if(elect[i]){\n            ans+=node[i];\n        }\n    }\n    ans+=buf;\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_V 100000\nusing namespace std;\nint m,w[100001];\nvector<int> vv[100001];\nunordered_set<int> st[100001];\nint V;\nvector<int> G[MAX_V];\nvector<int> rG[MAX_V];\nvector<int> vs;\nbool used[MAX_V];\nint cmp[MAX_V];\nint C[100001],F[100001],U[100001],ans;\nbool UU[100001];\n\n\nvoid DFS(int p){\n  for(int i=0;i<vv[p].size();i++){\n    int mn=min(vv[p][i],p),mx=max(vv[p][i],p);\n    if(st[mn].find(mx)==st[mn].end()){\n      st[mn].insert(mx);\n      G[p].push_back(vv[p][i]);\n      rG[vv[p][i]].push_back(p);\n      DFS(vv[p][i]);\n    }\n  }\n}\n\nvoid dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++)if(!used[G[v][i]])dfs(G[v][i]);\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v]=true;\n  cmp[v]=k;\n  for(int i=0;i<rG[v].size();i++)if(!used[rG[v][i]])rdfs(rG[v][i],k);\n}\n\nint scc(){\n  memset(used,0,sizeof(used));\n  vs.clear();\n  for(int v=0;v<V;v++)if(!used[v])dfs(v);\n  memset(used,0,sizeof(used));\n  int k=0;\n  for(int i=vs.size()-1;i>=0;i--)if(!used[vs[i]])rdfs(vs[i],k++);\n  return k;\n}\n\nbool DFS1(int p){\n  if(U[p])return 0;\n  U[p]=1;\n  bool f=F[cmp[p]]>=2;\n  for(int i=0;i<G[p].size();i++)\n    f|=DFS1(G[p][i]);\n  ans+=w[p]*f;\n  return UU[p]=f;\n}\nbool UUU[100001];\nint DFS2(int p){\n  if(UUU[p])return 0;\n  UUU[p]=1;\n  int res=0;\n  \n  for(int i=0;i<G[p].size();i++)\n    res=max(res,DFS2(G[p][i]));  \n  return UU[p]?0:res+w[p];\n}\n\nint main(){\n  cin>>V>>m;\n  for(int i=0;i<V;i++)cin>>w[i];\n  for(int j=0,a,b;j<m;j++){\n    cin>>a>>b;a--,b--;\n    vv[a].push_back(b),vv[b].push_back(a);\n  }\n  DFS(0);\n  int t=0;\n  for(int i=0;i<V;i++)t+=w[i];\n  scc();\n  for(int i=0;i<V;i++)F[cmp[i]]++;\n  DFS1(0);\n  cout<<ans+DFS2(0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <algorithm>\nusing namespace std;\ntypedef pair<int,int> P;\n\nclass BECC{\nprivate:\n    int N;\n    vector<vector<int>> G;\n    vector<int> order,inS;\n    stack<int> S,roots;\n    vector<int> cmp;\npublic:\n    vector<P> bridge;\n    vector<vector<int>> bccs;\n    vector<vector<int>> dcmp;//分解後のグラフ\n    BECC(int n,vector<vector<int>> graph){\n        N = n;\n        G = graph;\n        order = inS = cmp = vector<int>(N+1,0);\n    }\n    void dfs(int cur,int prev,int k){\n        order[cur] = ++k; //訪問順に番号付け\n        S.push(cur); inS[cur] = true;//訪問した頂点の集合に追加\n        roots.push(cur);//各bccの根を管理\n        for(auto to:G[cur]){\n            if(order[to]==0) dfs(to,cur,k);\n            else if(to!=prev && inS[to]){//後退辺なら\n                while(order[roots.top()]>order[to]) roots.pop();//(to,cur]を捨てる\n            }\n        }\n        if(cur==roots.top()){\n            if(prev!=-1) bridge.emplace_back(prev,cur);//根でないなら橋になる\n            vector<int> bcc;\n            while(true){\n                int node = S.top(); S.pop(); inS[node] = false;//nodeを捨てる\n                bcc.emplace_back(node);//nodeをbccに追加\n                cmp[node] = bccs.size();\n                if(node==cur) break;\n            }\n            bccs.emplace_back(bcc);\n            roots.pop();\n        }\n    }\n    int find(int n){return cmp[n];}\n    int cmp_size(int n){return bccs[cmp[n]].size();}\n    int size(int n){return bccs[n].size();}\n    void decomposition(){\n        int k = 0;\n        bccs.push_back(vector<int>{});\n        for(int i=1;i<=N;i++) if(order[i]==0) dfs(i,-1,k);\n        dcmp = vector<vector<int>>(bccs.size());\n        for(auto x:bridge){\n            dcmp[cmp[x.first]].push_back(cmp[x.second]);\n            dcmp[cmp[x.second]].push_back(cmp[x.first]);\n        }\n    }\n};\n\nvector<int> dp(100010,0),dp2(100010,0);\nvector<int> ok(100010,0);\nvector<int> W(100010,0);\nvector<int> S(100010,0);\nvoid dfs(int n,int m,BECC& becc){\n    int ma = 0;\n    ok[n] = (becc.size(n)!=1);\n    for(auto x:becc.dcmp[n]){\n        if(x!=m){\n            dfs(x,n,becc);\n            if(ok[x]) dp[n] += dp[x];\n            dp2[n] = max(dp2[n],dp2[x]);\n            ok[n] = (ok[n] | ok[x]);\n        }\n    }\n    if(!ok[n]) dp2[n] += S[n];\n    else dp[n] += S[n];\n}\nint N,M;\nint main(){\n    cin >> N >> M;\n    for(int i=1;i<=N;i++) cin >> W[i];\n    vector<vector<int>> v(N+1);\n    int a,b;\n    for(int i=0;i<M;i++){\n        cin >> a >> b;\n        v[a].push_back(b);\n        v[b].push_back(a);\n    }\n    BECC becc(N,v);\n    becc.decomposition();\n    for(int i=1;i<=N;i++){\n        S[becc.find(i)] += W[i];\n    }\n    dfs(becc.find(1),-1,becc);\n    cout << dp[becc.find(1)]+dp2[becc.find(1)] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// beet hieteruka~~~\n#include <bits/stdc++.h>\n \nusing namespace std;\n \nusing int64 = long long;\nconst int mod = 1e9 + 7;\n \nconst int64 infll = (1LL << 62) - 1;\nconst int inf = (1 << 30) - 1;\n \nstruct IoSetup {\n  IoSetup() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n    cerr << fixed << setprecision(10);\n  }\n} iosetup;\n \n \ntemplate< typename T1, typename T2 >\nostream &operator<<(ostream &os, const pair< T1, T2 > &p) {\n  os << p.first << \" \" << p.second;\n  return os;\n}\n \ntemplate< typename T1, typename T2 >\nistream &operator>>(istream &is, pair< T1, T2 > &p) {\n  is >> p.first >> p.second;\n  return is;\n}\n \ntemplate< typename T >\nostream &operator<<(ostream &os, const vector< T > &v) {\n  for(int i = 0; i < (int) v.size(); i++) {\n    os << v[i] << (i + 1 != v.size() ? \" \" : \"\");\n  }\n  return os;\n}\n \ntemplate< typename T >\nistream &operator>>(istream &is, vector< T > &v) {\n  for(T &in : v) is >> in;\n  return is;\n}\n \ntemplate< typename T1, typename T2 >\ninline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n \ntemplate< typename T1, typename T2 >\ninline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n \ntemplate< typename T = int64 >\nvector< T > make_v(size_t a) {\n  return vector< T >(a);\n}\n \ntemplate< typename T, typename... Ts >\nauto make_v(size_t a, Ts... ts) {\n  return vector< decltype(make_v< T >(ts...)) >(a, make_v< T >(ts...));\n}\n \ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value == 0 >::type fill_v(T &t, const V &v) {\n  t = v;\n}\n \ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value != 0 >::type fill_v(T &t, const V &v) {\n  for(auto &e : t) fill_v(e, v);\n}\n \ntemplate< typename F >\nstruct FixPoint : F {\n  FixPoint(F &&f) : F(forward< F >(f)) {}\n \n  template< typename... Args >\n  decltype(auto) operator()(Args &&... args) const {\n    return F::operator()(*this, forward< Args >(args)...);\n  }\n};\n \ntemplate< typename F >\ninline decltype(auto) MFP(F &&f) {\n  return FixPoint< F >{forward< F >(f)};\n}\n \n \nstruct UnionFind {\n  vector< int > data;\n \n  UnionFind(int sz) {\n    data.assign(sz, -1);\n  }\n \n  bool unite(int x, int y) {\n    x = find(x), y = find(y);\n    if(x == y) return (false);\n    if(data[x] > data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n    return (true);\n  }\n \n  int find(int k) {\n    if(data[k] < 0) return (k);\n    return (data[k] = find(data[k]));\n  }\n \n  int size(int k) {\n    return (-data[find(k)]);\n  }\n};\n \n \n#define int long long\n \nstruct BiConnectedComponents {\n  UnionFind uf;\n  vector< vector< int > > g;\n  vector< pair< int, int > > edges;\n  vector< int > used, ord, low, comp;\n \n  BiConnectedComponents(size_t v) : uf(v), g(v), used(v, 0), comp(v), ord(v), low(v) {\n  }\n \n  void add_edge(int x, int y) {\n    g[x].push_back(y);\n    g[y].push_back(x);\n    edges.push_back(minmax(x, y));\n  }\n \n  void dfs(int idx, int &k, int par = -1) {\n    used[idx] = true;\n    ord[idx] = k++;\n    low[idx] = ord[idx];\n \n    for(auto &to : g[idx]) {\n      if(!used[to]) {\n        dfs(to, k, idx);\n        low[idx] = min(low[idx], low[to]);\n        if(ord[idx] >= low[to]) uf.unite(idx, to);\n      } else if(to != par) {\n        low[idx] = min(low[idx], ord[to]);\n      }\n    }\n  }\n \n  int operator[](int k) {\n    return (comp[k]);\n  }\n \n  size_t size() {\n    return (g.size());\n  }\n \n  void build(vector< vector< int > > &t) {\n    int kk = 0;\n    dfs(0, kk);\n \n    int ptr = 0;\n    vector< int > cc(g.size());\n    for(int i = 0; i < g.size(); i++) {\n      if(i == uf.find(i)) cc[i] = ptr++;\n    }\n \n    t.resize(ptr);\n    for(int i = 0; i < g.size(); i++) {\n      comp[i] = cc[uf.find(i)];\n    }\n    for(auto &e : edges) {\n      int x = comp[e.first], y = comp[e.second];\n      if(x == y) continue;\n      t[x].push_back(y);\n      t[y].push_back(x);\n    }\n  }\n};\nint N, M, W[200000], S;\nvector< vector< int > > g;\nvector< int > weightSum, sz;\nint dp1[200000], dp3[200000];\n \nint rec(int idx, int par = -1) {\n  int ret = 0;\n  for(auto &to : g[idx]) {\n    if(to == par) continue;\n    ret = max(ret, rec(to, idx));\n    dp1[idx] += dp1[to];\n  }\n  ret += weightSum[idx];\n  if(sz[idx] >= 3 || dp1[idx] > 0) dp1[idx] += weightSum[idx];\n  for(auto &to : g[idx]) {\n    if(to == par) continue;\n    else ret = max(ret, dp1[idx] - dp1[to] + dp3[to]);\n  }\n  return (dp3[idx] = ret);\n}\n \nsigned main() {\n  cin >> N >> M;\n  BiConnectedComponents tree(N);\n  for(int i = 0; i < N; i++) {\n    cin >> W[i];\n  }\n  while(M--) {\n    int U, V;\n    cin >> U >> V;\n    tree.add_edge(--U, --V);\n  }\n  tree.build(g);\n  weightSum.assign(g.size(), 0);\n  sz.assign(g.size(), 0);\n  for(int i = 0; i < N; i++) {\n    weightSum[tree[i]] += W[i];\n    sz[tree[i]]++;\n  }\n  printf(\"%lld\\n\", rec(tree[0]));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1e9 + 7;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<class T>\nistream& operator >> (istream& is, vector<T>& v)\n{\n\tfor (auto &i : v) is >> i;\n\treturn is;\n}\ntemplate<class T>\nostream& operator<<(ostream& os, vector<T>& v)\n{\n\tconst string delimiter = \"\\n\";\n\tREP(i, v.size())\n\t{\n\t\tos << v[i];\n\t\tif (i != v.size() - 1) os << delimiter;\n\t}\n\treturn os;\n}\n/*--------------------template--------------------*/\n\ntypedef int Weight;\nstruct Edge\n{\n\tint from, to; Weight cost;\n\tbool operator < (const Edge& e) const { return cost < e.cost; }\n\tbool operator > (const Edge& e) const { return cost > e.cost; }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nvoid add_edge(Graph &g, int from, int to, Weight cost)\n{\n\tg[from].push_back(Edge{ from, to, cost });\n}\n\nvector<vi> g, tree;\nvi w;\nvector<bool> can_back;\nvi mx;\n\nbool get_can_back(int v)\n{\n\tbool res = false;\n\tif (tree[v].size() + 1 < g[v].size()) res = true;\n\tfor (auto u : tree[v])\n\t{\n\t\tif (get_can_back(u)) res = u;\n\t}\n\treturn can_back[v] = res;\n}\n\nint get_max(int v)\n{\n\tif (mx[v] >= 0) return mx[v];\n\tint res = 0;\n\tfor (auto u : tree[v])\n\t{\n\t\tchmax(res, get_max(u));\n\t}\n\treturn mx[v] = res + w[v];\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tint n, m;\n\tcin >> n >> m;\n\tw.resize(n); cin >> w;\n\tg.resize(n); tree.resize(n); can_back.resize(n); mx.resize(n, -1);\n\tREP(i, m)\n\t{\n\t\tint u, v; cin >> u >> v;\n\t\tu--; v--;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\tqueue<int> que;\n\tvector<bool> vis(n);\n\tvis[0] = true;\n\tque.push(0);\n\twhile (!que.empty())\n\t{\n\t\tint v = que.front();\n\t\tque.pop();\n\t\tfor (auto u : g[v])\n\t\t{\n\t\t\tif (vis[u]) continue;\n\t\t\tvis[u] = true;\n\t\t\ttree[v].push_back(u);\n\t\t\tque.push(u);\n\t\t}\n\t}\n\tfor (auto v : tree[0])\n\t{\n\t\tget_can_back(v);\n\t}\n\tint ans = w[0];\n\tint fin = 0;\n\tFOR(i, 1, n)\n\t{\n\t\tif (can_back[i]) ans += w[i];\n\t\telse\n\t\t{\n\t\t\tchmax(fin, get_max(i));\n\t\t}\n\t}\n\tcout << ans + fin << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N, M;\n  cin >> N >> M;\n  VI ws(N);\n  REP(i,N) cin >> ws[i];\n  vector<set<int>> G(N);\n  VI in(N);\n  REP(i,M){\n\tint u, v;\n\tcin >> u >> v;\n\t--u;\n\t--v;\n\tG[u].insert(v);\n\tG[v].insert(u);\n\tin[u]++;\n\tin[v]++;\n  }\n\n  VI dp(N);\n  vector<bool> vis(N);\n  queue<int> q;\n  REP(i,N) if(i && in[i] == 1) q.push(i);\n  while(!q.empty()){\n\tint crt = q.front();\n\tint to = *begin(G[crt]);\n\tq.pop();\n\tG[to].erase(crt);\n\tmaxi(dp[to], dp[crt] + ws[crt]);\n\tvis[crt] = true;\n\tif(to != 0 && SZ(G[to]) == 1)\n\t  q.push(to);\n  }\n\n  int mx = 0;\n  int ans = 0;\n  REP(i,N) if(!vis[i]){\n\tans += ws[i];\n\tmaxi(mx, dp[i]);\n  }\n  cout << ans + mx << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<utility>\n#include<set>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define MP make_pair\n#define PB push_back\nusing namespace std;\n\nint n,m;\n\nvoid bfs(int k,vector<int> &cnt,vector<bool>&b,vector<vector<int> > &g){\n    if(cnt[k]==1||cnt[k]==0){\n        b[k] = 0;\n        for(int i:g[k]){\n            if(b[i]){\n                cnt[i]--;\n                bfs(i,cnt,b,g);\n            }\n        }\n    }   \n}\nint bfs2(int k,int z,vector<int>&w,vector<vector<int> > &g){\n    int s=w[k];\n    int mx = 0;\n    for(int x:g[k]){\n        if(k==n||x!=z){\n            mx = max(mx,bfs2(x,k,w,g));\n        }\n    }\n    return s+mx;\n}\n\n\nint main(){\n    cin >> n >> m;\n    vector<int> w(n+1);\n    vector<vector<int> > g(n);\n    rep(i,n)cin >> w[i];\n    rep(i,m){\n        int u,v;\n        cin >> u >> v;\n        u--;v--;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    vector<int> cnt(n);\n    rep(i,n){\n        cnt[i] = g[i].size();\n    }\n    vector<bool> b(n,1);\n    rep(i,n){\n        bfs(i,cnt,b,g);\n    }\n    vector<int>p;\n    int sm=0;\n    rep(i,n){\n        if(b[i]){\n            p.PB(i);\n            sm+=w[i];\n        }\n    }\n    w[n]=sm;\n    set<int>st;\n    for(int x:p){\n        for(int y:g[x]){\n            st.insert(y);\n        }\n    }\n    vector<vector<int> >g2(n+1);\n    rep(i,n){\n        if(!b[i]){\n            for(int x:g[i]){\n                if(b[x]){\n                    g2[i].PB(n);\n                    g2[n].PB(i);\n                }else{\n                    g2[i].PB(x);\n                }\n            }\n        }\n    }\n    if(b[0]){\n        cout << bfs2(n,n,w,g2) << endl;\n    }else{\n        cout << bfs2(0,0,w,g2) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n#define int long long\nusing namespace std;\n\nvoid visit(vector< vector<int> > &G, int cur, int prev, vector< pair<int, int> > &brg, vector< vector<int> > &each_bcc, stack<int> &roots, stack<int> &S, vector<bool> &inS, vector<int> &order, int &k){\n  order[cur] = ++k;\n  //++k;\n  S.push(cur);\n  inS[cur] = true;\n  roots.push(cur);\n  for(int i = 0; i < G[cur].size(); ++i){\n    int to = G[cur][i];\n    if(!order[to]) visit(G, to, cur, brg, each_bcc, roots, S, inS, order, k);\n    else if(to != prev && inS[to]){\n      while(order[roots.top()] > order[to]) roots.pop();\n    }\n  }\n\n  if(cur == roots.top()){\n    if(prev != -1) brg.push_back(pair<int, int>(prev, cur));\n    vector<int> bcc;\n    while(1){\n      int node = S.top();\n      S.pop();\n      inS[node] = false;\n      bcc.push_back(node);\n      if(node == cur) break;\n    }\n    each_bcc.push_back(bcc);\n    roots.pop();\n  }\n}\n\nvoid bridge(vector< vector<int> > &G, vector< pair<int, int> > &brg, vector< vector<int> > &each_bcc){\n  int V = G.size();\n  vector<int> order(V);\n  vector<bool> inS(V);\n  stack<int> roots, S;\n  int k = 0;\n  for(int i = 0; i < V; ++i){\n    if(!order[i]) visit(G, i, -1, brg, each_bcc, roots, S, inS, order, k);\n  }\n}\n\nint dfs(vector< vector<int> > &G, vector<int> &W, int v){\n  int ret = 0, w = W[v];\n  W[v] = 0;\n  for(int i = 0; i < G[v].size(); ++i){\n    int v_ = G[v][i];\n    if(!W[v_]) continue;\n    ret = max(ret, dfs(G, W, v_));\n  }\n  W[v] = w;\n  return ret + w;\n}\n\n//int main(){\nsigned main(){\n  int N, M;\n  cin >> N >> M;\n  vector<int> W(N);\n  for(int i = 0; i < N; ++i) cin >> W[i];\n  vector< vector<int> > G(N);\n  for(int i = 0; i < M; ++i){\n    int u, v;\n    cin >> u >> v;\n    --u;--v;\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n  vector< vector<int> > each_bcc;\n  vector< pair<int, int> > brg;\n  bridge(G, brg, each_bcc);\n  int V = each_bcc.size();\n  vector<int> W_(V, 0);\n  vector<int> cmp(N);\n  for(int i = 0; i < V; ++i){\n    for(int j = 0; j < each_bcc[i].size(); ++j){\n      cmp[each_bcc[i][j]] = i;\n      W_[i] += W[each_bcc[i][j]];\n    }\n  }\n  vector< vector<int> > G_(V);\n  for(int i = 0; i < brg.size(); ++i){\n    int u = brg[i].first, v = brg[i].second;\n    G_[cmp[u]].push_back(cmp[v]);\n    G_[cmp[v]].push_back(cmp[u]);\n  }\n  //for(int i = 0; i < N; ++i) cout << cmp[i] << \" \";cout << endl;\n  //for(int i = 0; i < V; ++i) cout << W_[i] << \" \"; cout << endl;\n  int s = cmp[0];\n  cout << dfs(G_, W_, s) << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n      \n#define FOR(i,a,b) for( ll i = (a); i < (ll)(b); i++ )\n#define REP(i,n) FOR(i,0,n)\n#define YYS(x,arr) for(auto& x:arr)\n#define ALL(x) (x).begin(),(x).end()\n#define SORT(x) sort( (x).begin(),(x).end() )\n#define REVERSE(x) reverse( (x).begin(),(x).end() )\n#define UNIQUE(x) (x).erase( unique( ALL( (x) ) ) , (x).end() )\n#define PW(x) (1LL<<(x))\n#define SZ(x) ((ll)(x).size())\n#define SHOW(x) cout << #x << \" = \" << x << endl\n#define SHOWA(x,n) for( int yui = 0; yui < n; yui++ ){ cout << x[yui] << \" \"; } cout << endl\n\n#define pb emplace_back\n#define fi first\n#define se second\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef long long int ll;\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<bool> vb;\ntypedef vector<ld> vd;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<vpl> gr;\ntypedef vector<vl> ml;\ntypedef vector<vd> md;\ntypedef vector<vi> mi;\n     \nconst ll INF = (ll)1e9 + 10;\nconst ll INFLL = (ll)1e18 + 10;\nconst ld EPS = 1e-12;\nconst ll MOD = 1e9+7;\n     \ntemplate<class T> T &chmin( T &a , const T &b ){ return a = min(a,b); }\ntemplate<class T> T &chmax( T &a , const T &b ){ return a = max(a,b); }\ntemplate<class T> inline T sq( T a ){ return a * a; }\n\nll in(){ long long int x; scanf( \"%lld\" , &x ); return x; }\nchar yuyushiki[1000010]; string stin(){ scanf( \"%s\" , yuyushiki ); return yuyushiki; }\n\n// head\n\nstruct Bridge{\n  vector<vpi> G;\n  vb used, isbridge;\n  vi ord, low;\n  int cnt;\n  int n, m;\n  void init( int size ){\n    n = size;\n    m = 0;\n    G.assign( n , vpi(0) );\n  }\n  void add_edge( int a, int b ){\n    G[a].pb( b, m );\n    G[b].pb( a, m );\n    m++;\n  }\n  void dfs( int x , int p ){\n    used[x] = true;\n    ord[x] = low[x] = cnt++;\n    YYS( w , G[x] ){\n      if( !used[w.fi] ){\n\tdfs( w.fi , x );\n\tchmin( low[x] , low[w.fi] );\n      } else if( w.fi != p ){\n\tchmin( low[x] , ord[w.fi] );\n      }\n    }\n  }\n  vb bridge(){\n    used = isbridge = vb( n , false );\n    ord = low = vi( n , 0 );\n    cnt = 0;\n    REP( i , n ){\n      if( !used[i] ){\n\tdfs( i , -1 );\n      }\n    }\n    REP( i , n ){\n      YYS( w , G[i] ){\n\tif( ord[i] > ord[w.fi] ) continue;\n\tif( ord[i] < low[w.fi] ) isbridge[w.se] = true;\n      }\n    }\n    return isbridge;\n  }\n};\n\nBridge bridge;\n\nint n, m;\n\nint a[100010];\n\nvpi G[100010];\n\nvb br;\n\nint ans;\n\nbool used[100010];\n\nvoid dfs2( int x , vi &nex , int &cur ){\n  used[x] = true;\n  cur += a[x];\n  YYS( w , G[x] ){\n    if( used[w.fi] ){\n      continue;\n    }\n    if( br[w.se] ){\n      nex.pb( w.fi );\n    } else {\n      dfs2( w.fi , nex , cur );\n    }\n  }\n}\n\nvoid dfs( int x , int cur ){\n  vi nex(0);\n  dfs2( x , nex , cur );\n  chmax( ans , cur );\n  YYS( w , nex ){\n    dfs( w , cur );\n  }\n}\n\nint main(){\n\n  n = in();\n  m = in();\n  bridge.init( n );\n  REP( i , n ){\n    a[i] = in();\n  }\n  REP( i , m ){\n    int x = in() - 1;\n    int y = in() - 1;\n    G[x].pb( y , i );\n    G[y].pb( x , i );\n    bridge.add_edge( x , y );\n  }\n\n  br = bridge.bridge();\n\n  dfs( 0 , 0 );\n\n  printf( \"%d\\n\" , ans );\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n,m;\nvector<int>e[100005];\nvector<int>edge[100005];\nint used[100005];\nint w[100005],k;\nvector<int>E[100005];\nll W[100005];\nint in[100005];\nll dp[100005];\nint cnt[100005],c[100005];\nint par[100005],ran[100005];\nll ans,add;\nvoid init(){ for(int i=0;i<100005;i++) par[i] = i; }\nint find(int x){ if(x == par[x]) return x; else return par[x] = find(par[x]); }\nvoid unite(int x,int y){\n\tx = find(x); y = find(y); if(x==y) return;\n\tif(ran[x] < ran[y]) par[x] = y;\n\telse{\n\t\tpar[y] = x;\n\t\tif(ran[x] == ran[y]) ran[x]++;\n\t}\n}\nbool same(int x,int y){ return find(x)==find(y); }\nvoid dfs(int v,int u,int d){\n\tused[v] = d;//cout << v << endl;\n\tfor(int i=0;i<e[v].size();i++){\n\t\tif(e[v][i] == u) continue;\n\t\tif(used[e[v][i]] && used[e[v][i]] < used[v]){\n\t\t\tcnt[e[v][i]]--;\n\t\t\tcnt[v]++;\n\t\t\tunite(e[v][i],v);\n\t\t\t//cout << v << \" \" << e[v][i] << endl;\n\t\t\tcontinue;\n\t\t}\n\t\telse if(used[e[v][i]]) continue;\n\t\tdfs(e[v][i],v,d+1); edge[v].pb(e[v][i]); //cout << v << \" \" << e[v][i] << endl;\n\t}\n}\nint dfs2(int v,int u){\n\tint sum = 0;\n\tfor(int i=0;i<edge[v].size();i++){\n\t\tint a = dfs2(edge[v][i],v);\n\t\tif(a>0){\n\t\t    //cout << edge[v][i] << \" f\" << v << endl;\n\t\t\tunite(edge[v][i],v);\n\t\t}\n\t\tsum += a;\n\t}\n\tsum += cnt[v];\n\treturn sum;\n}\npair<ll,bool> dfs(int v,int p){\n\tll ret = 0; bool ok = (c[v] >= 3);\n\tfor(int i=0;i<E[v].size();i++){\n\t\tif(E[v][i] == p) continue;\n\t\tpair<ll,bool> t = dfs(E[v][i],v);\n\t\tret = max(ret,t.fi);\n\t\tok |= t.sc;\n\t}\n\tif(ok){\n\t\tret = 0;\n\t\tans += W[v];\n\t}\n\telse ret += W[v];\n\tadd = max(add,ret);\n\treturn mp(ret,ok);\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=0;i<n;i++) scanf(\"%d\",&w[i]);\n\tfor(int i=0;i<m;i++){\n\t\tint a,b; scanf(\"%d%d\",&a,&b); a--; b--;\n\t\te[a].push_back(b);\n\t\te[b].push_back(a);\n\t}\n\tinit(); dfs(0,-1,1); dfs2(0,-1);\n\tfor(int i=0;i<n;i++){\n\t\tW[find(i)] += w[i];\n\t\tc[find(i)] ++;\n\t\tfor(int j=0;j<e[i].size();j++){\n\t\t\tif(find(i) != find(e[i][j])){\n\t\t\t\tE[find(i)].pb(find(e[i][j]));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tSORT(E[i]); ERASE(E[i]);\n\t}\n\tdfs(0,-1);\n\tcout << ans+add << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_V 100000\nusing namespace std;\nint n,m,w[100001];\nvector<int> v[100001],v1[100001];\nunodered_set<int> st[100001];\nint V;\nvector<int> G[MAX_V];\nvector<int> rG[MAX_V];\nvector<int> vs;\nbool used[MAX_V];\nint cmp[MAX_V];\n\nvoid DFS(int p){\n  for(int i=0;i<v[p].size();i++){\n    int mn=min(v[p][i],p),mx=max(v[p][i],p);\n    if(st[mn].find(mx)==st.end()){\n      st[mn].insert(mx);\n      G[p].push_back(v[p][i]);\n      rG[v[p][i]].push_back(p);\n      DFS(v[p][i]);\n    }\n  }\n}\n\nvoid dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++)if(!used[G[v][i]])dfs(G[v][i]);\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v]=true;\n  cmp[v]=k;\n  for(int i=0;i<rG[v].size();i++)if(!used[rG[v][i]])rdfs(rG[v][i],k);\n}\n\nint scc(){\n  memset(used,0,sizeof(used));\n  vs.clear();\n  for(int v=0;v<V;v++)if(!used[v])dfs(v);\n  memset(used,0,sizeof(used));\n  int k=0;\n  for(int i=vs.size()-1;i>=0;i--)if(!used[vs[i]])rdfs(vs[i],k++);\n  return k;\n}\n\nint C[100001],F[100001],U[100001],ans;\nbool UU[100001];\n\nbool DFS1(int p){\n  if(U[p])return 0;\n  U[p]=1;\n  bool f=F[cmp[p]]>=2;\n  for(int i=0;i<G[p].size();i++)\n    f=max(f,DFS1(G[p][i]));\n  ans+=w[p]*f;\n  return UU[p]=f;\n}\n\nint DFS2(int p){\n  if(UU[p])return 0;\n  UU[p]=1;\n  int res=0;\n  for(int i=0;i<v[p].size();i++)\n    res+=DFS2(v[p][i]);\n  return w[p]+res;\n}\n\nint main(){\n  cin>>V>>m;\n  for(int i=0;i<V;i++)cin>>w[i];\n  for(int j=0,a,b;j<m;j++){\n    cin>>a>>b;a--,b--;\n    v[a].push_back(b),v[b].push_back(a);\n  }\n  DFS(0);\n  scc();\n  for(int i=0;i<V;i++)F[cmp[i]]++;\n  DFS1(0);\n  int mx=0;\n  for(int i=0;i<V;i++)\n    if(!UU[i])mx=max(mx,DFS2(i));\n  \n  cout<<ans+mx<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int, int> P;\nconst int M = 1000000007;\n\nvector<vector<int>> edge;\nvector<vector<int>> tecomp;\nvector<set<int>> nedge;\nvector<int> uid, uuid;\nvector<int> nw;\n\n\n\nvoid visit(int v, int u,\n        stack<int>& roots, stack<int>& S, vector<bool>& inS,\n        vector<int>& num, int& tm) {\n    num[v] = ++tm;\n    S.push(v); inS[v] = true;\n    roots.push(v);\n    for (int w : edge[v]) {\n        if (num[w] == 0)\n            visit(w, v, roots, S, inS, num, tm);\n        else if (u != w && inS[w])\n            while (num[roots.top()] > num[w]) roots.pop();\n    }\n    if (v == roots.top()) {\n        tecomp.push_back(vector<int>());\n        while (1) {\n            int w = S.top(); S.pop(); inS[w] = false;\n            tecomp.back().push_back(w);\n            if (v == w) break;\n        }\n        roots.pop();\n    }\n}\n\n\nbool dfs(int now, int par, int zero) {\n    bool ret = false;\n    for (int i : nedge[now]) {\n        if (i == par) continue;\n        if (tecomp[i].size() > 1) {\n            ret = true;\n        }\n        ret |= dfs(i, now, zero);\n    }\n    if (ret) {\n        uuid[now] = zero;\n    }\n    return ret;\n}\nint dfs(int now, int par) {\n    int ret = 0;\n    for (int i : nedge[now]) {\n        if (i == par) continue;\n        ret = max(ret, dfs(i, now));\n    }\n    return ret + nw[now];\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<int> w(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> w[i];\n    }\n    edge.resize(n);\n    for (int i = 0; i < m; ++i) {\n        int a, b;\n        cin >> a >> b;\n        --a;\n        --b;\n        edge[a].push_back(b);\n        edge[b].push_back(a);\n    }\n    vector<int> num(n, 0);\n    vector<bool> inS(n);\n    stack<int> roots, S;\n    int tm = 0;\n    for (int u = 0; u < n; ++u)\n        if (num[u] == 0)\n            visit(u, n, roots, S, inS, num, tm);\n\n    int nn = tecomp.size();\n    uid.resize(n);\n    for (int i = 0; i < nn; ++i) {\n        for (int j : tecomp[i])\n            uid[j] = i;\n    }\n    int zero = uid[0];\n    nedge.resize(nn);\n    for (int i = 0; i < n; ++i) {\n        for (int j : edge[i]) {\n            if (uid[i] != uid[j])\n                nedge[uid[i]].insert(uid[j]);\n        }\n    }\n    uuid.resize(n);\n    for (int i = 0; i < n; ++i) {\n        uuid[i] = i;\n    }\n    dfs(zero, -1, zero);\n    nw.resize(nn, 0);\n    for (int i = 0; i < n; ++i) {\n        nw[uuid[uid[i]]] += w[i];\n    }\n    vector<int> useduid(nn, 0);\n    vector<int> used(nn, 0);\n    int ma = 0;\n    for (int i = 0; i < n; ++i) {\n        if (!useduid[uid[i]] && uuid[uid[i]] == zero) {\n            useduid[uid[i]] = 1;\n            for (int j : nedge[uid[i]]) {\n                if (uuid[j] != zero && !used[j]) {\n                    used[j] = 1;\n                    ma = max(ma, dfs(j, uid[i]));\n                }\n            }\n        }\n    }\n    cout << (nw[zero] + ma) << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\nclass Node{\n\tpublic:\n\t\tint ord; //DFSの訪問の順番\n\t\tint par; //DFS Treeにおける親\n\t\tint low; //min(自分のord, 逆辺がある場合の親のord, すべての子のlow)\n\t\tNode() : ord(-1) { }\n};\n\nclass ArticulationPoints {\n\tprivate:\n\t\tint v, cnt;\n\t\tvector<Node> node;\n\t\tvoid dfs(int cur, int prev){\n\t\t\tnode[cur].ord = node[cur].low = cnt;\n\t\t\tcnt++;\n\n\t\t\tfor(auto to : g[cur]){\n\t\t\t\tif(to == prev) continue;\n\t\t\t\tif(node[to].ord >= 0){\n\t\t\t\t\tnode[cur].low = min(node[cur].low, node[to].ord);\n\t\t\t\t}else{\n\t\t\t\t\tnode[to].par = cur;\n\t\t\t\t\tdfs(to, cur);\n\t\t\t\t\tnode[cur].low = min(node[cur].low, node[to].low);\n\t\t\t\t}\n\t\t\t\tif(node[cur].ord < node[to].low){\n\t\t\t\t\tbridge.emplace_back(min(cur, to), max(cur, to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tpublic:\n\t\tvector<vector<int>> g;\n\t\tvector<pair<int, int>> bridge;\n\t\tset<int> ap; // 関節店\n\t\tArticulationPoints(int n) : v(n), cnt(1), node(n), g(n) { }\n\t\tvoid addEdge(int a, int b){\n\t\t\tg[a].emplace_back(b);\n\t\t\tg[b].emplace_back(a);\n\t\t}\n\t\tbool isBridge(int u, int v){\n\t\t\tif(node[u].ord > node[v].ord) swap(u,v);\n\t\t\treturn node[u].ord < node[v].low;\n\t\t}\n\t\tvoid run(){\n\t\t\tdfs(0, -1); // 0 = root\n\n\t\t\tint np = 0;\n\t\t\trange(i,1,v){\n\t\t\t\tint p = node[i].par;\n\t\t\t\tif(p == 0) np++;\n\t\t\t\telse if(node[p].ord <= node[i].low) ap.emplace(p);\n\t\t\t}\n\t\t\tif(np > 1) ap.emplace(0);\n\t\t\tsort(all(bridge));\n\t\t\t//for(auto it:ap){ cout << it << endl; } //関節点の全列挙\n\t\t\t//for(auto it:bridge){ cout << it.first << ' ' << it.second << endl; } //橋の全列挙\n\t\t}\n};\n\nclass TwoEdgeConnectedComponent : public ArticulationPoints {\n\tprivate:\n\t\tvoid dfs(int c, int pos){\n\t\t\tver[c].emplace_back(pos);\n\t\t\tcomp[pos] = c;\n\t\t\tfor (int to : g[pos]) {\n\t\t\t\tif (comp[to] >= 0) continue;\n\t\t\t\tif (isBridge(pos, to)) continue;\n\t\t\t\tdfs(c, to);\n\t\t\t}\n\t\t}\n\t\tvoid addComp(int pos){\n\t\t\tif(comp[pos] >= 0) return;\n\t\t\tver.emplace_back();\n\t\t\tdfs(ver.size() - 1, pos);\n\t\t}\n\tpublic:\n\t\tvector<int> comp; // 成分分解前の頂点から分解後の頂点への写像？\n\t\tvector<vector<int>> ver; // 分解後の頂点と、その頂点に含まれる分解前の頂点\n\t\tTwoEdgeConnectedComponent(int n) : ArticulationPoints(n), comp(n,-1) {}\n\t\tvoid solve(){\n\t\t\trun();\n\t\t\tfor(auto p : bridge){\n\t\t\t\taddComp(p.first);\n\t\t\t\taddComp(p.second);\n\t\t\t}\n\t\t\taddComp(0);\n\t\t}\n\t\tvector<vector<int>> getTree(){\n\t\t\tvector<vector<int>> res(ver.size());\n\t\t\tfor(auto p : bridge){\n\t\t\t\tint u = comp[p.first], v = comp[p.second];\n\t\t\t\tres[u].emplace_back(v);\n\t\t\t\tres[v].emplace_back(u);\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n};\n\nvoid cut(vector<vector<int>>& g, vector<int>& in, vector<bool>& used, vector<int>& p, int pos){\n\tused[pos] = true;\n\tfor(auto to : g[pos]){\n\t\tif(used[to]) continue;\n\t\tcut(g, in, used, p, to);\n\t}\n\tif(in[pos] == 1){\n\t\tfor(auto to : g[pos]){\n\t\t\tin[to]--;\n\t\t}\n\t\tp.emplace_back(pos);\n\t}\n}\n\nint dfs(vector<vector<int>>& g, vector<int>& w, vector<bool>& used, int pos){\n\tint res = w[pos];\n\tused[pos] = true;\n\tfor(auto to : g[pos]){\n\t\tif(used[to]) continue;\n\t\tres += dfs(g, w, used, to);\n\t}\n\treturn res;\n}\n\nvoid dfs(vector<vector<int>>& g, vector<vector<int>>& ver, vector<bool>& used, int pos){\n\tif(ver[pos].size() != 1) return;\n\tused[pos] = true;\n\tfor(auto to : g[pos]){\n\t\tif(used[pos]) continue;\n\t\tdfs(g, ver, used, to);\n\t}\n}\n\nint dfs(vector<vector<int>>& g, vector<vector<int>>& node, vector<int>& w, vector<bool>& used, int pos){\n\tint res = w[node[pos].at(0)];\n\tused[pos] = false;\n\tfor(auto to : g[pos]){\n\t\tif(not used[to]) continue;\n\t\tres += dfs(g, node, w, used, to);\n\t}\n\treturn res;\n}\n\nint main(){\n\tint n, m;\n\tcin >> n >> m;\n\n\tvector<int> w(n);\n\tcin >> w;\n\n\tTwoEdgeConnectedComponent tecc(n);\n\trep(i,m){\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tu--; v--;\n\t\ttecc.addEdge(u,v);\n\t}\n\ttecc.solve();\n\tvector<vector<int>> g = tecc.getTree();\n\n\tvector<bool> used(g.size(),0);\n\trep(i,g.size()){\n\t\tdfs(g, tecc.ver, used, i);\n\t}\n\n\t//rep(i,tecc.ver.size()){\n\t//\tshow(i)\n\t//\tfor(auto j : tecc.ver[i]) cout << j << endl;\n\t//}\n\n\tint ans = 0;\n\trep(i,g.size()){\n\t\tif(used[i]) continue;\n\t\tfor(auto j : tecc.ver[i]){\n\t\t\tans += w[j];\n\t\t}\n\t}\n\tif(ans == 0) ans = w[0];\n\n\tint res = 0;\n\tused[0] = false;\n\trep(i,g.size()){\n\t\tfor(auto j : g[i]){\n\t\t\tif(not used[i] and used[j]) res = max(res, dfs(g, tecc.ver, w, used, j));\n\t\t}\n\t}\n\n\tcout << ans + res << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<double,int,double> tp;\n//typedef vector<tp> vt;\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nconst int inf=1e9;\nconst ll INF=2e18;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nclass SCC{//cmp(0 - kk-1) is scc's return. Same number is group. The number is no relatoin.\n\tpublic:\n\tint n;\n\tvvi G,rG;\n\tvector<bool>used;\n\tvi vs,cmp;\n\tvoid init(int size){\n\t\tn=size;\n\t\tG=rG=vvi(n);\n\t\tused=vector<bool>(n);\n\t\tcmp=vi(n);\n\t\tvs=vi(0);\n\t}\n\tvoid add_edge(int s,int t){\n\t\tG[s].pb(t);\n\t\trG[t].pb(s);\n\t}\n\tvoid rdfs(int v,int k){\n\t\tused[v]=true;\n\t\tcmp[v]=k;\n\t\trep(i,rG[v].size())if(!used[rG[v][i]])rdfs(rG[v][i],k);\n\t}\n\tvoid dfs(int v){\n\t\tused[v]=true;\n\t\trep(i,G[v].size())if(!used[G[v][i]])dfs(G[v][i]);\n\t\tvs.pb(v);\n\t}\n\tint scc(){\n\t\trep(i,n)used[i]=false;\n\t\trep(v,n)if(!used[v])dfs(v);\n\t\trep(i,n)used[i]=false;\n\t\tint kk=0;\n\t\tfor(int i=vs.size()-1;i>=0;i--)if(!used[vs[i]])rdfs(vs[i],kk++);\n\t\treturn kk;  \n\t}\n};\nSCC scc;\nint n,m,ma;\nvvi G,tG;\nvi used;\nvoid dfs(int a,int pre){\n\tused[a]=true;\n\trep(i,G[a].size()){\n\t\tint to=G[a][i];\n\t\tif(to!=pre)scc.add_edge(a,to);\n\t\tif(used[to])continue;\n\t\tdfs(to,a);\n\t}\n}\nvi to;\nvoid DFS(int a,int sum,int pre){\n\tma=max(ma,sum);\n\trep(i,tG[a].size()){\n\t\tint _to=tG[a][i];\n\t\tif(_to==pre)continue;\n\t\tDFS(_to,sum+to[_to],a);\n\t}\n}\nint main(){\n\tcin>>n>>m;\n\tvi in(n);\n\trep(i,n)cin>>in[i];\n\tscc.init(n);\n\tused=vi(n);\n\tG=vvi(n);\n\twhile(m--){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\ta--;b--;\n//\t\tmca.add_edge(a,b);\n\t\tG[a].pb(b);\n\t\tG[b].pb(a);\n\t}\n\tdfs(0,-1);\n\tint N=scc.scc();\n//\trep(i,n)cout<<\" \"<<scc.cmp[i];cout<<endl;\n\ttG=vvi(N);\n\tto=vi(N);\n\trep(i,n)to[scc.cmp[i]]+=in[i];\n\trep(i,n)rep(j,scc.G[i].size())if(scc.cmp[i]!=scc.cmp[scc.G[i][j]])\n\t\ttG[scc.cmp[i]].pb(scc.cmp[scc.G[i][j]]);\n\n\tma=0;\n\tDFS(0,to[0],-1);\n\tcout<<ma<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\n#define MAX 200000\n\nint N;\nvector<int> G[MAX];\nbool visited[MAX];\nint prenum[MAX],parent[MAX],lowest[MAX],timer;\nvector<P> bridge;\n\nvoid dfs(int v,int prev){\n\tprenum[v]=lowest[v]=timer;\n\ttimer++;\n\tvisited[v]=true;\n\n\tint next;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tnext=G[v][i];\n\t\tif(!visited[next]){\n\t\t\tparent[next]=v;\n\t\t\tdfs(next,v);\n\t\t\tlowest[v]=min(lowest[v],lowest[next]);\n\t\t\tif(prenum[v]<lowest[G[v][i]])bridge.push_back(P(min(v,G[v][i]),max(v,G[v][i])));\n\t\t}else if(next!=prev){\n\t\t\tlowest[v]=min(lowest[v],prenum[next]);\n\t\t}\n\t}\n}\n\n\nset<int> art_points(){\n\tfor(int i=0;i<N;i++){\n\t\tvisited[i]=false;\n\t}\n\ttimer=1;\n\tdfs(0,-1);\n\n\tset<int> ap;\n\tint np=0;\n\tfor(int i=1;i<N;i++){\n\t\tint p=parent[i];\n\t\tif(p==0)np++;\n\t\telse if(prenum[p]<lowest[i])ap.insert(p);\n\t}\n\tif(np>1)ap.insert(0);\n\treturn ap;\n}\n\nint w[MAX];\nvector<P> edge;\nvector<P> n_bridge;\nvector<int> ok_G[MAX];\nint cnt;\nbool used[100001];\nint sum[100001];\nint num[100001];\nint siz[100001];\nvector<int> graph[MAX];\n\nvoid c_dfs(int v){\n\tused[v]=true;\n\tnum[v]=cnt;\n\tsiz[cnt]++;\n\tsum[cnt]+=w[v];\n\tfor(int i=0;i<ok_G[v].size();i++){\n\t\tif(num[ok_G[v][i]]==-1){\n\t\t\tc_dfs(ok_G[v][i]);\n\t\t}\n\t}\n}\n\nint dp[100001];\nint dp2[100001];\n\nint solve2(int v,int p){\n\tif(dp2[v]!=-1)return dp2[v];\n\tint res=sum[v];\n\tint back=-1;\n\tfor(int i=0;i<graph[v].size();i++){\n\t\tif(p!=graph[v][i]){\n\t\t\tint va=solve2(graph[v][i],v);\n\t\t\tif(va!=0){\n\t\t\t\tres+=va;\n\t\t\t\tback=0;\n\t\t\t}\n\t\t}\n\t}\n\tif(siz[v]>=3)back=0;\n\tdp2[v]=(back==0)?res:0;\n\treturn dp2[v];\n}\n\nint solve(int v,int p){\n\tif(dp[v]!=-1)return dp[v];\n\tint res=0;\n\tfor(int i=0;i<graph[v].size();i++){\n\t\tif(p!=graph[v][i]){\n\t\t\tint va=solve2(graph[v][i],v);\n\t\t\tif(va!=0)res+=va;\n\t\t}\n\t}\n\tint diff=0;\n\tfor(int i=0;i<graph[v].size();i++){\n\t\tif(p!=graph[v][i]){\n\t\t\tint va=solve(graph[v][i],v);\n\t\t\tif(va-max(dp2[graph[v][i]],0)>diff){\n\t\t\t\tdiff=va-max(0,dp2[graph[v][i]]);\n\t\t\t}\n\t\t}\n\t}\n\tres+=diff;\n\treturn (dp[v]=(res+sum[v]));\n}\n\nint main(void){\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d\",&w[i]);\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\ta--;\n\t\tb--;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t\tedge.push_back(P(a,b));\n\t}\n\tN=n;\n\tart_points();\n\tsort(bridge.begin(),bridge.end());\n\tfor(int i=0;i<m;i++){\n\t\tint v=lower_bound(bridge.begin(),bridge.end(),edge[i])-bridge.begin();\n\t\tif(!(v<bridge.size() && bridge[v]==edge[i])){\n\t\t\tok_G[edge[i].first].push_back(edge[i].second);\n\t\t\tok_G[edge[i].second].push_back(edge[i].first);\n\t\t}\n\t}\n\tmemset(num,-1,sizeof(num));\n\tfor(int i=0;i<n;i++){\n\t\tif(num[i]==-1){\n\t\t\tc_dfs(i);\n\t\t\tcnt++;\n\t\t}\n\t}\n\tfor(int i=0;i<bridge.size();i++){\n\t\tP p=bridge[i];\n\t\tgraph[num[p.first]].push_back(num[p.second]);\n\t\tgraph[num[p.second]].push_back(num[p.first]);\n\t}\n\tmemset(dp,-1,sizeof(dp));\n\tmemset(dp2,-1,sizeof(dp2));\n\tprintf(\"%d\\n\",solve(num[0],-1));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_V 100000\nusing namespace std;\nint m,w[100001];\nvector<int> vv[100001];\nbool S[100001];\nint V;\nvector<int> G[MAX_V];\nvector<int> rG[MAX_V];\nvector<int> vs;\nbool used[MAX_V];\nint cmp[MAX_V];\nint C[100001],F[100001],U[100001],ans;\nbool UU[100001];\n\nvoid DFS(int p,int pr){\n  if(S[p])return;\n  S[p]=1;\n  for(int i=0;i<vv[p].size();i++){\n    int np=vv[p][i];\n    if(pr!=np){\n      G[p].push_back(np);\n      rG[np].push_back(p);\n    }\n  }\n}\n\nvoid dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++)if(!used[G[v][i]])dfs(G[v][i]);\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v]=true;\n  cmp[v]=k;\n  for(int i=0;i<rG[v].size();i++)if(!used[rG[v][i]])rdfs(rG[v][i],k);\n}\n\nint scc(){\n  for(int v=0;v<V;v++)if(!used[v])dfs(v);\n  memset(used,0,sizeof(used));\n  int k=0;\n  for(int i=vs.size()-1;i>=0;i--)if(!used[vs[i]])rdfs(vs[i],k++);\n  return k;\n}\n\nbool DFS1(int p){\n  if(U[p])return 0;\n  U[p]=1;\n  bool f=F[cmp[p]]>=2;\n  for(int i=0;i<G[p].size();i++)\n    f|=DFS1(G[p][i]);\n  ans+=w[p]*f;\n  return UU[p]=f;\n}\nbool UUU[100001];\nint DFS2(int p){\n  if(UUU[p])return 0;\n  UUU[p]=1;\n  int res=0;\n  \n  for(int i=0;i<G[p].size();i++)\n    res=max(res,DFS2(G[p][i]));  \n  return res+(UU[p]?0:w[p]);\n}\n\nint main(){\n  cin>>V>>m;\n  for(int i=0;i<V;i++)cin>>w[i];\n  for(int j=0,a,b;j<m;j++){\n    cin>>a>>b;a--,b--;\n    vv[a].push_back(b),vv[b].push_back(a);\n  }\n  DFS(0,-1);\n  int t=0;\n  for(int i=0;i<V;i++)t+=w[i];\n  scc();\n  for(int i=0;i<V;i++)F[cmp[i]]++;\n  DFS1(0);\n  cout<<ans+DFS2(0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\ntypedef long long  ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\ntypedef vector<int> vec;\n\nconst int mn = 100000;\nvector<int> G[100000];\nint w[100000];\n\nint c[100000];\nbool non[100000];\n\nint sum, ma;\nbool exi0 = false;\nint dfs(int id, int fr) {\n\tif (id == 0)exi0 = true;\n\tint ret = 0;\n\trep(j, G[id].size()) {\n\t\tint to = G[id][j];\n\t\tif (fr == to)continue;\n\t\tif (!non[to]) {\n\t\t\tret = max(ret, sum + ma);\n\t\t}\n\t\telse {\n\t\t\tret = max(ret, dfs(to, id));\n\t\t}\n\t}\n\treturn ret + w[id];\n}\nint csum;\nbool dfs2(int id, int fr) {\n\trep(j, G[id].size()) {\n\t\tint to = G[id][j];\n\t\tif (fr == to)continue;\n\t\tif (!non[to]) {\n\t\t\tcsum += w[id];\n\t\t\tw[id] = 0;\n\t\t\treturn true;\n\t\t}\n\t\tif (dfs2(to, id)) {\n\t\t\tcsum += w[id];\n\t\t\tw[id] = 0;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nvoid solve() {\n\tint n, m; cin >> n >> m;\n\trep(i, n)cin >> w[i];\n\trep(i, m) {\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t\tc[a]++; c[b]++;\n\t}\n\tqueue<int> q;\n\trep(i, n) {\n\t\tif (c[i] == 1) {\n\t\t\tq.push(i);\n\t\t\tnon[i] = true;\n\t\t}\n\t}\n\twhile (!q.empty()) {\n\t\tint id = q.front(); q.pop();\n\t\trep(j, G[id].size()) {\n\t\t\tint to = G[id][j];\n\t\t\tc[to]--;\n\t\t\tif (c[to] == 1) {\n\t\t\t\tq.push(to);\n\t\t\t\tnon[to] = true;\n\t\t\t}\n\t\t}\n\t}\n\trep(i, n) {\n\t\tif (!non[i])sum += w[i];\n\t}\n\trep(i, n)if (!non[i]) {\n\t\trep(j, G[i].size()) {\n\t\t\tint to = G[i][j];\n\t\t\tif (!non[to])continue;\n\t\t\texi0 = false;\n\t\t\tint z = dfs(to, i);\n\t\t\tif (!exi0) {\n\t\t\t\tma = max(ma, z);\n\t\t\t}\n\t\t}\n\t}\n\tif (!non[0]) {\n\t\tcout << sum + ma << endl;\n\t}\n\telse {\n\t\tint ans = dfs(0, -1);\n\t\tdfs2(0,-1);\n\t\trep(i, n)if (!non[i]) {\n\t\t\trep(j, G[i].size()) {\n\t\t\t\tint to = G[i][j];\n\t\t\t\tif (!non[to])continue;\n\t\t\t\tma = max(ma, dfs(to, i));\n\t\t\t}\n\t\t}\n\t\tans = max(ans, csum + sum + ma);\n\t\tcout << ans << endl;\n\t}\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(5);\n\t//while (cin >> n,n)solve();\n\tsolve();\n\t//stop\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N, M;\n  cin >> N >> M;\n  VI ws(N);\n  REP(i,N) cin >> ws[i];\n  vector<set<int>> G(N);\n  VI in(N);\n  REP(i,M){\n\tint u, v;\n\tcin >> u >> v;\n\t--u;\n\t--v;\n\tG[u].insert(v);\n\tG[v].insert(u);\n\tin[u]++;\n\tin[v]++;\n  }\n\n  int mx = 0;\n  vector<bool> vis(N);\n  REP(i,N){\n\tif(in[i] != 1) continue;\n\tint crt = i, prv = -1, sum = 0;\n\twhile(true){\n\t  if(crt == 0 || in[crt] > 2) break;\n\t  sum += ws[crt];\n\t  vis[crt] = true;\n\t  for(int to: G[crt])\n\t\tif(to == prv) continue;\n\t\telse{\n\t\t  prv = crt;\n\t\t  crt = to;\n\t\t  break;\n\t\t}\n\t}\n\tmaxi(mx, sum);\n  }\n  int ans = 0;\n  REP(i,N) if(!vis[i]) ans += ws[i];\n  cout << ans + mx << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing Edges=vector<int>;\nusing Graph=vector<Edges>;\n\nint main(){\n    int n,m;\n    cin>>n>>m;\n    vector<int> w(n);\n    for(int i=0;i<n;i++) cin>>w[i];\n    Graph g(n);\n    for(int i=0;i<m;i++){\n        int u,v;\n        cin>>u>>v;\n        u--,v--;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    vector<int> leaf(n,false);\n    vector<int> pot(n);\n    pot[0]=1e8;\n    queue<int> que;\n    for(int i=1;i<n;i++){\n        pot[i]=g[i].size();\n        if(pot[i]==1){\n            que.push(i);\n            leaf[i]=true;\n        }\n    }\n    auto givew=w;\n    while(!que.empty()){\n        int v=que.front(); que.pop();\n        for(int i=0;i<g[v].size();i++){\n            if(leaf[g[v][i]]) continue;\n            pot[g[v][i]]--;\n            givew[g[v][i]]+=givew[v];\n            if(pot[g[v][i]]==1){\n                que.push(g[v][i]);\n                leaf[g[v][i]]=true;\n            }\n        }\n    }\n    int res=0;\n    int maxLeaf=0;\n    for(int i=0;i<n;i++){\n        if(leaf[i]){\n            maxLeaf=max(maxLeaf,givew[i]);\n        }\n        else{\n            res+=w[i];\n        }\n    }\n    cout<<res+maxLeaf<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_N 100011\n#define N MAX_N\n#define rank dfasfds\nusing namespace std;\ntypedef long long ll;\ntypedef set<int> S;\nint par[MAX_N],rank[MAX_N];\nll val[MAX_N];\nS G[N];\n\nvoid init(int n){for(int i=0;i<N;i++)par[i]=i,rank[i]=0;}\n\nint find(int x){\n  if(par[x]==x)return x;\n  return par[x]=find(par[x]);\n}\n\nbool same(int x,int y){return find(x)==find(y);}\n\nvoid unite(int x,int y){\n  x=find(x),y=find(y);\n  if(x==y)return;\n  if(rank[x]<rank[y])par[x]=y,val[y]+=val[x];\n  else{\n    par[y]=x;\n    val[x]+=val[y];\n    if(rank[x]==rank[y])rank[x]++;\n  }\n}\n\nint used[N];\nvector<int> path;\nvoid dfs(int pos,int pre){\n  if(used[pos]||pos!=find(pos)) {\n    for(int i=0;i<path.size();i++)unite(pos,path[i]);\n    return;\n  }\n  used[pos]=1;\n  path.push_back(pos);\n  for(S::iterator it=G[pos].begin();it!=G[pos].end();it++)if(*it!=pre)dfs(*it,pos);\n  used[pos]=0;\n  path.pop_back();\n}\n\nvector<int>col[N];\nll get_mx(int pos){\n  pos=find(pos);\n  used[pos]=1;\n  ll res=0;\n  \n  for(int i=0;i<col[pos].size();i++)\n    for(S::iterator it=G[col[pos][i]].begin();it!=G[col[pos][i]].end();it++)\n      if(!used[find(*it)])res=max(res,get_mx(find(*it)));\n  return res+val[find(pos)];\n}\n\nint main(){\n  int n,m;\n  cin>>n>>m;\n  for(int i=0;i<n;i++) cin>>val[i];\n  for(int i=0,a,b;i<m;i++){\n    cin>>a>>b;a--,b--;\n    G[a].insert(b);\n    G[b].insert(a);\n  }\n  init(n);\n  dfs(0,-1);\n  for(int i=0;i<n;i++) col[find(i)].push_back(i);\n  cout <<get_mx(find(0))<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\nusing namespace std;\nconst int INF = 1e9;\n\nvoid visit(vector< vector<int> > &G, int cur, int prev, vector< pair<int, int> > &brg, vector< vector<int> > &each_bcc, stack<int> &roots, stack<int> &S, vector<bool> &inS, vector<int> &order, int &k){\n  order[cur] = ++k;\n  S.push(cur);\n  inS[cur] = true;\n  roots.push(cur);\n  for(int i = 0; i < G[cur].size(); ++i){\n    int to = G[cur][i];\n    if(!order[to]) visit(G, to, cur, brg, each_bcc, roots, S, inS, order, k);\n    else if(to != prev && inS[to]){\n      while(order[roots.top()] > order[to]) roots.pop();\n    }\n  }\n\n  if(cur == roots.top()){\n    if(prev != -1) brg.push_back(pair<int, int>(prev, cur));\n    vector<int> bcc;\n    while(1){\n      int node = S.top();\n      S.pop();\n      inS[node] = false;\n      bcc.push_back(node);\n      if(node == cur) break;\n    }\n    each_bcc.push_back(bcc);\n    roots.pop();\n  }\n}\n\nvoid bridge(vector< vector<int> > &G, vector< pair<int, int> > &brg, vector< vector<int> > &each_bcc){\n  int V = G.size();\n  vector<int> order(V);\n  vector<bool> inS(V);\n  stack<int> roots, S;\n  int k = 0;\n  for(int i = 0; i < V; ++i){\n    if(!order[i]) visit(G, i, -1, brg, each_bcc, roots, S, inS, order, k);\n  }\n}\n\nvoid dfs(vector< vector<int> > &G, vector<int> &D, int s){\n  for(int i = 0; i < G[s].size(); ++i){\n    int v = G[s][i];\n    if(D[v] > D[s] + 1){\n      D[v] = D[s] + 1;\n      dfs(G, D, v);\n    }\n  }\n}\n\nint main(){\n  int N, M;\n  cin >> N >> M;\n  vector<int> W(N);\n  for(int i = 0; i < N; ++i) cin >> W[i];\n  vector< vector<int> > G(N);\n  for(int i = 0; i < M; ++i){\n    int u, v;\n    cin >> u >> v;\n    --u;--v;\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n  vector< vector<int> > each_bcc;\n  vector< pair<int, int> > brg;\n  bridge(G, brg, each_bcc);\n  int V = each_bcc.size();\n  /*\n  for(int i = 0; i < V; ++i){\n    cout << i << endl;\n    for(int j = 0; j < each_bcc[i].size(); ++j) cout << each_bcc[i][j] << \" \";cout << endl;\n    cout << endl;\n  }\n  */\n  vector<int> W_(V, 0), cmp(N);\n\n  for(int i = 0; i < V; ++i){\n    for(int j = 0; j < each_bcc[i].size(); ++j){\n      cmp[each_bcc[i][j]] = i;\n      W_[i] += W[each_bcc[i][j]];\n    }\n  }\n  //for(int i = 0; i < V; ++i) cout << W_[i] << \" \";cout << endl;\n  vector< vector<int> > G_(V);\n  for(int i = 0; i < brg.size(); ++i){\n    int u = brg[i].first, v = brg[i].second;\n    G_[cmp[u]].push_back(cmp[v]);\n    G_[cmp[v]].push_back(cmp[u]);\n  }\n  vector<int> D(V, INF);\n  D[cmp[0]] = 0;\n  dfs(G_, D, cmp[0]);\n  int ans = 0;\n  vector<int> R;\n  for(int i = 0; i < V; ++i){\n    if(G_[i].size() > 1 || i == cmp[0]) continue;\n    int s = 0;\n    int v = i;\n    while(each_bcc[v].size() < 3 && v != cmp[0]){\n      s += W_[v];\n      for(int j = 0; j < G_[v].size(); ++j){\n        int u = G_[v][j];\n        if(D[u] == D[v] - 1){\n          v = u;\n          break;\n        }\n      }\n    }\n    R.push_back(v);\n    ans = max(s, ans);\n  }\n  vector<bool> visited(V, false);\n  for(int i = 0; i < R.size(); ++i){\n    int v = R[i];\n    while(!visited[v]){\n      ans += W_[v];\n      visited[v] = true;\n      for(int j = 0; j < G_[v].size(); ++j){\n        int u = G_[v][j];\n        if(D[u] == D[v] - 1){\n          v = u;\n          break;\n        }\n      }\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct UnionFind\n{\n  vector< int > data;\n\n  UnionFind(int sz)\n  {\n    data.assign(sz, -1);\n  }\n\n  bool unite(int x, int y)\n  {\n    x = find(x), y = find(y);\n    if(x == y) return (false);\n    if(data[x] > data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n    return (true);\n  }\n\n  int find(int k)\n  {\n    if(data[k] < 0) return (k);\n    return (data[k] = find(data[k]));\n  }\n\n  int size(int k)\n  {\n    return (-data[find(k)]);\n  }\n};\n\nstruct BiConnectedComponents\n{\n  UnionFind uf;\n  vector< vector< int > > g;\n  vector< pair< int, int > > edges;\n  vector< int > used, ord, low, comp;\n\n  BiConnectedComponents(size_t v) : uf(v), g(v), used(v, 0), comp(v), ord(v), low(v)\n  {\n  }\n\n  void add_edge(int x, int y)\n  {\n    g[x].push_back(y);\n    g[y].push_back(x);\n    edges.push_back(minmax(x, y));\n  }\n\n  void dfs(int idx, int &k, int par = -1)\n  {\n    used[idx] = true;\n    ord[idx] = k++;\n    low[idx] = ord[idx];\n\n    for(auto &to : g[idx]) {\n      if(!used[to]) {\n        dfs(to, k, idx);\n        low[idx] = min(low[idx], low[to]);\n        if(ord[idx] >= low[to]) uf.unite(idx, to);\n      } else if(to != par) {\n        low[idx] = min(low[idx], ord[to]);\n      }\n    }\n  }\n\n  int operator[](int k)\n  {\n    return (comp[k]);\n  }\n\n  size_t size()\n  {\n    return (g.size());\n  }\n\n  void build(vector< vector< int > > &t)\n  {\n    int kk = 0;\n    dfs(0, kk);\n\n    int ptr = 0;\n    vector< int > cc(g.size());\n    for(int i = 0; i < g.size(); i++) {\n      if(i == uf.find(i)) cc[i] = ptr++;\n    }\n\n    t.resize(ptr);\n    for(int i = 0; i < g.size(); i++) {\n      comp[i] = cc[uf.find(i)];\n    }\n    for(auto &e : edges) {\n      int x = comp[e.first], y = comp[e.second];\n      if(x == y) continue;\n      t[x].push_back(y);\n      t[y].push_back(x);\n    }\n  }\n};\n\nint N, M, W[100000];\nvector< vector< int > > g;\nvector< int > weightSum, sz;\nint dp1[100000], dp2[100000];\n\nint rec(int idx, int par = -1)\n{\n  int ret = 0;\n  for(auto &to : g[idx]) {\n    if(to == par) continue;\n    ret = max(ret, rec(to, idx));\n    dp2[idx] = max(dp2[idx], dp2[to]);\n  }\n  dp2[idx] += weightSum[idx];\n  if(sz[idx] >= 3) {\n    for(auto &to : g[idx]) {\n      if(to == par) continue;\n      dp1[idx] += dp1[to];\n    }\n    dp1[idx] += weightSum[idx];\n    for(auto &to : g[idx]) {\n      if(to == par) continue;\n      ret = max(ret, dp1[idx] - dp1[to] + dp2[to]);\n    }\n  }\n  return (ret);\n}\n\nint main()\n{\n  cin >> N >> M;\n  BiConnectedComponents tree(N);\n  for(int i = 0; i < N; i++) {\n    cin >> W[i];\n  }\n  while(M--) {\n    int U, V;\n    cin >> U >> V;\n    tree.add_edge(--U, --V);\n  }\n  tree.build(g);\n  weightSum.assign(g.size(), 0);\n  sz.assign(g.size(), 0);\n  for(int i = 0; i < N; i++) {\n    weightSum[tree[i]] += W[i];\n    sz[tree[i]]++;\n  }\n  cout << rec(tree[0]) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \n#define int long long\ntypedef pair<int,int>pint;\ntypedef vector<int>vint;\ntypedef vector<pint>vpint;\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\ntemplate<class T,class U>inline void chmin(T &t,U f){if(t>f)t=f;}\ntemplate<class T,class U>inline void chmax(T &t,U f){if(t<f)t=f;}\n \n \nstruct UF{\n    int N;\n    vint par;\n    void init(int n){\n        N=n;\n        par.resize(N);\n        rep(i,N)par[i]=i;\n    }\n    int find(int x){\n        return x==par[x]?x:par[x]=find(par[x]);\n    }\n    void unite(int x,int y){\n        par[find(y)]=find(x);\n    }\n};\n \nconst int SIZE=100000;\nint N,M;\nint w[SIZE],sz[SIZE];\nvint G[SIZE];\n \nbool used[SIZE];\nint ord[SIZE],low[SIZE];\nvpint bridge;\n \nvoid dfs(int v,int p,int &k){\n    used[v]=true;\n    ord[v]=k++;\n    low[v]=ord[v];\n \n    for(auto to:G[v]){\n        if(!used[to]){\n            dfs(to,v,k);\n            low[v]=min(low[v],low[to]);\n            if(ord[v]<low[to])bridge.pb(pint(min(v,to),max(v,to)));\n        }\n        else if(to!=p){\n            low[v]=min(low[v],ord[to]);\n        }\n    }\n}\n    //return   no return\nint dp[SIZE],dp2[SIZE];\nvoid dfs2(int v,int p){\n    for(auto to:G[v]){\n        if(to==p)continue;\n        dfs2(to,v);\n        dp[v]+=dp[to];\n    }\n    int sum=dp[v];\n    if(dp[v]||sz[v]>1)dp[v]+=w[v];\n \n    for(auto to:G[v]){\n        if(to==p)continue;\n        chmax(dp2[v],sum-dp[to]+dp2[to]);\n    }\n    dp2[v]+=w[v];\n}\n \nsigned main(){\n    scanf(\"%lld%lld\",&N,&M);\n    rep(i,N)scanf(\"%lld\",&w[i]);\n    rep(i,M){\n        int a,b;\n        scanf(\"%lld%lld\",&a,&b);\n        a--;b--;\n        G[a].pb(b);G[b].pb(a);\n    }\n    int K;\n    dfs(0,-1,K);\n \n    sort(all(bridge));\n    UF uf;uf.init(N);\n    rep(v,N)for(auto to:G[v])if(v<to){\n        if(binary_search(all(bridge),pint(v,to)))continue;\n        uf.unite(v,to);\n    }\n    vint ps;\n    rep(i,N)if(uf.find(i)==i)ps.pb(i);\n    rep(i,N)G[i].clear();\n    for(auto &p:bridge){\n        int u=lower_bound(all(ps),uf.find(p.fi))-ps.begin();\n        int v=lower_bound(all(ps),uf.find(p.se))-ps.begin();\n        G[u].pb(v);G[v].pb(u);\n    }\n    int ww[SIZE]={0};\n    rep(i,N){\n        int p=lower_bound(all(ps),uf.find(i))-ps.begin();\n        ww[p]+=w[i];\n        sz[p]++;\n    }\n    N=ps.size();\n    rep(i,N)w[i]=ww[i];\n \n    int s=lower_bound(all(ps),uf.find(0))-ps.begin();\n    dfs2(s,-1);\n    cout<<dp2[s]<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<double,int,double> tp;\n//typedef vector<tp> vt;\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nconst int inf=1e9;\nconst ll INF=2e18;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nclass SCC{//cmp(0 - kk-1) is scc's return. Same number is group. The number is no relatoin.\n\tpublic:\n\tint n;\n\tvvi G,rG;\n\tvector<bool>used;\n\tvi vs,cmp;\n\tvoid init(int size){\n\t\tn=size;\n\t\tG=rG=vvi(n);\n\t\tused=vector<bool>(n);\n\t\tcmp=vi(n);\n\t\tvs=vi(0);\n\t}\n\tvoid add_edge(int s,int t){\n\t\tG[s].pb(t);\n\t\trG[t].pb(s);\n\t}\n\tvoid rdfs(int v,int k){\n\t\tused[v]=true;\n\t\tcmp[v]=k;\n\t\trep(i,rG[v].size())if(!used[rG[v][i]])rdfs(rG[v][i],k);\n\t}\n\tvoid dfs(int v){\n\t\tused[v]=true;\n\t\trep(i,G[v].size())if(!used[G[v][i]])dfs(G[v][i]);\n\t\tvs.pb(v);\n\t}\n\tint scc(){\n\t\trep(i,n)used[i]=false;\n\t\trep(v,n)if(!used[v])dfs(v);\n\t\trep(i,n)used[i]=false;\n\t\tint kk=0;\n\t\tfor(int i=vs.size()-1;i>=0;i--)if(!used[vs[i]])rdfs(vs[i],kk++);\n\t\treturn kk;  \n\t}\n};\nSCC scc;\nint n,m,ma;\nvvi G,tG;\nvi used;\nvoid dfs(int a,int pre){\n\tused[a]=true;\n\trep(i,G[a].size()){\n\t\tint to=G[a][i];\n\t\tif(to!=pre)scc.add_edge(a,to);\n\t\tif(used[to])continue;\n\t\tdfs(to,a);\n\t}\n}\nvi to;\nvoid DFS(int a,int sum,int pre){\n\trep(i,tG[a].size()){\n\t\tint _to=tG[a][i];\n\t\tif(_to==pre)continue;\n\t\tma=max(ma,sum+to[_to]);\n\t}\n}\nint main(){\n\tcin>>n>>m;\n\tvi in(n);\n\trep(i,n)cin>>in[i];\n\tscc.init(n);\n\tused=vi(n);\n\tG=vvi(n);\n\twhile(m--){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\ta--;b--;\n//\t\tmca.add_edge(a,b);\n\t\tG[a].pb(b);\n\t\tG[b].pb(a);\n\t}\n\tdfs(0,-1);\n\tint N=scc.scc();\n//\trep(i,n)cout<<\" \"<<scc.cmp[i];cout<<endl;\n\ttG=vvi(N);\n\tto=vi(N);\n\trep(i,n)to[scc.cmp[i]]+=in[i];\n\trep(i,n)rep(j,scc.G[i].size())if(scc.cmp[i]!=scc.cmp[scc.G[i][j]])\n\t\ttG[scc.cmp[i]].pb(scc.cmp[scc.G[i][j]]);\n\n//\trep(i,N)cout<<\" \"<<to[i];cout<<endl;\n\tma=to[0];\n\tDFS(0,to[0],-1);\n\tcout<<ma<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\nusing namespace std;\nconst int INF = 1e9;\n\nvoid visit(vector< vector<int> > &G, int cur, int prev, vector< pair<int, int> > &brg, vector< vector<int> > &each_bcc, stack<int> &roots, stack<int> &S, vector<bool> &inS, vector<int> &order, int &k){\n  order[cur] = ++k;\n  S.push(cur);\n  inS[cur] = true;\n  roots.push(cur);\n  for(int i = 0; i < G[cur].size(); ++i){\n    int to = G[cur][i];\n    if(!order[to]) visit(G, to, cur, brg, each_bcc, roots, S, inS, order, k);\n    else if(to != prev && inS[to]){\n      while(order[roots.top()] > order[to]) roots.pop();\n    }\n  }\n\n  if(cur == roots.top()){\n    if(prev != -1) brg.push_back(pair<int, int>(prev, cur));\n    vector<int> bcc;\n    while(1){\n      int node = S.top();\n      S.pop();\n      inS[node] = false;\n      bcc.push_back(node);\n      if(node == cur) break;\n    }\n    each_bcc.push_back(bcc);\n    roots.pop();\n  }\n}\n\nvoid bridge(vector< vector<int> > &G, vector< pair<int, int> > &brg, vector< vector<int> > &each_bcc){\n  int V = G.size();\n  vector<int> order(V);\n  vector<bool> inS(V);\n  stack<int> roots, S;\n  int k = 0;\n  for(int i = 0; i < V; ++i){\n    if(!order[i]) visit(G, i, -1, brg, each_bcc, roots, S, inS, order, k);\n  }\n}\n\nvoid dfs(vector< vector<int> > &G, vector<int> &D, int s){\n  for(int i = 0; i < G[s].size(); ++i){\n    int v = G[s][i];\n    if(D[v] > D[s] + 1){\n      D[v] = D[s] + 1;\n      dfs(G, D, v);\n    }\n  }\n}\n\nint main(){\n  int N, M;\n  cin >> N >> M;\n  vector<int> W(N);\n  for(int i = 0; i < N; ++i) cin >> W[i];\n  vector< vector<int> > G(N);\n  for(int i = 0; i < M; ++i){\n    int u, v;\n    cin >> u >> v;\n    --u;--v;\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n  vector< vector<int> > each_bcc;\n  vector< pair<int, int> > brg;\n  bridge(G, brg, each_bcc);\n  int V = each_bcc.size();\n  /*\n  for(int i = 0; i < V; ++i){\n    cout << i << endl;\n    for(int j = 0; j < each_bcc[i].size(); ++j) cout << each_bcc[i][j] << \" \";cout << endl;\n    cout << endl;\n  }\n  */\n  vector<int> W_(V, 0), cmp(N);\n\n  for(int i = 0; i < V; ++i){\n    for(int j = 0; j < each_bcc[i].size(); ++j){\n      cmp[each_bcc[i][j]] = i;\n      W_[i] += W[each_bcc[i][j]];\n    }\n  }\n  //for(int i = 0; i < V; ++i) cout << W_[i] << \" \";cout << endl;\n  vector< vector<int> > G_(V);\n  for(int i = 0; i < brg.size(); ++i){\n    int u = brg[i].first, v = brg[i].second;\n    G_[cmp[u]].push_back(cmp[v]);\n    G_[cmp[v]].push_back(cmp[u]);\n  }\n  vector<int> D(V, INF);\n  D[cmp[0]] = 0;\n  dfs(G_, D, cmp[0]);\n  int ans = 0;\n  vector<int> R;\n  for(int i = 0; i < V; ++i){\n    if(G_[i].size() > 1 || i == cmp[0]) continue;\n    int s = 0;\n    int v = i;\n    while(each_bcc[v].size() < 3 && v != cmp[0]){\n      s += W_[v];\n      for(int j = 0; j < G_[v].size(); ++j){\n        int u = G_[v][j];\n        if(D[u] == D[v] - 1){\n          v = u;\n          break;\n        }\n      }\n    }\n    if(v != cmp[0]) R.push_back(v);\n    ans = max(s, ans);\n  }\n  ans += W_[cmp[0]];\n  vector<bool> visited(V, false);\n  visited[cmp[0]] = true;\n  for(int i = 0; i < R.size(); ++i){\n    int v = R[i];\n    while(!visited[v]){\n      ans += W_[v];\n      visited[v] = true;\n      for(int j = 0; j < G_[v].size(); ++j){\n        int u = G_[v][j];\n        if(D[u] == D[v] - 1){\n          v = u;\n          break;\n        }\n      }\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int, int> P;\nconst int M = 1000000007;\n\nvector<vector<int>> edge;\nvector<set<int>> nedge;\nvector<int> uid, uuid;\nvector<int> vis;\nvector<int> cnts;\nvector<int> nw;\nbool dfs(int now, int par, int s) {\n    vis[now] = s;\n    bool ret = false;\n    for (int i : edge[now]) {\n        if (i == par) continue;\n        if (i == s) {\n            ret = true;\n        }\n        else if (vis[i] < s && uid[i] > s) {\n            ret |= dfs(i, now, s);\n        }\n    }\n    if (ret) {\n        uid[now] = s;\n    }\n    return ret;\n}\nbool dfs(int now, int par) {\n    bool ret = false;\n    for (int i : nedge[now]) {\n        if (i == par) continue;\n        if (cnts[i] > 1) {\n            ret = true;\n        }\n        ret |= dfs(i, now);\n    }\n    if (ret) {\n        uuid[now] = 0;\n    }\n    return ret;\n}\nint dfs2(int now, int par) {\n    int ret = 0;\n    for (int i : nedge[now]) {\n        if (i == par) continue;\n        ret = max(ret, dfs2(i, now));\n    }\n    return ret + nw[now];\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<int> w(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> w[i];\n    }\n    edge.resize(n);\n    for (int i = 0; i < m; ++i) {\n        int a, b;\n        cin >> a >> b;\n        --a;\n        --b;\n        edge[a].push_back(b);\n        edge[b].push_back(a);\n    }\n    uid.resize(n);\n    vis.resize(n, -1);\n    for (int i = 0; i < n; ++i) {\n        uid[i] = i;\n    }\n    cnts.resize(n, 0);\n    for (int i = 0; i < n; ++i) {\n        if (uid[i] == i) {\n            dfs(i, -1, i);\n        }\n        ++cnts[uid[i]];\n    }\n    nedge.resize(n);\n    for (int i = 0; i < n; ++i) {\n        for (int j : edge[i]) {\n            if (uid[i] != uid[j]) {\n                nedge[uid[i]].insert(uid[j]);\n            }\n        }\n    }\n    uuid.resize(n);\n    for (int i = 0; i < n; ++i) {\n        uuid[i] = i;\n    }\n    dfs(0, -1);\n    nw.resize(n, 0);\n    for (int i = 0; i < n; ++i) {\n        nw[uuid[uid[i]]] += w[i];\n    }\n    vector<int> used(n, 0);\n    int ma = 0;\n    for (int i = 0; i < n; ++i) {\n        if (i == uid[i] && uuid[i] == 0) {\n            for (int j : nedge[i]) {\n                if (uuid[j] > 0 && !used[j]) {\n                    used[j] = 1;\n                    ma = max(ma, dfs2(j, i));\n                }\n            }\n        }\n    }\n    cout << (nw[0] + ma) << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n#define MAX 100005\n\nint p[MAX];\nint q[MAX];\n\nint find(int x){\n  if(p[x]==x)return x;\n  return p[x]=find(p[x]);\n}\n\nvoid unite(int x,int y){\n  x=find(x);y=find(y);\n  if(x==y)return;\n  p[x]=y;\n  q[y]+=q[x];\n}\n\nbool same(int x,int y){\n  return (find(x)==find(y));\n}\n\nint V,E;\nvector<int> G[MAX];\nvector<int> nG[MAX];\nmap<int,bool> used[MAX];\n\nint s[MAX],t[MAX];\nint depth[MAX];\nint cnt[MAX];\nint visited[MAX];\nbool flg[MAX];\n\n\nvoid dfs(int pos,int prev){\n  visited[pos]=true;\n  for(int i=0;i<(int)G[pos].size();i++){\n    int to=G[pos][i];\n    if(to==prev)continue;\n    if(!visited[to]){\n      depth[to]=depth[pos]+1;\n      dfs(to,pos);\n      cnt[pos]+=cnt[to];\n      if(cnt[to])unite(pos,to);\n    }else if(depth[to]<depth[pos]){\n      unite(pos,to);\n      cnt[pos]++;\n      cnt[to]--;\n    }else{\n      unite(pos,to);\n    }\n  }\n}\n\nP solve(int pos,int prev=-1){\n  int res=-1,res2=0,sum=t[pos];\n  for(int i=0;i<(int)nG[pos].size();i++){\n    int to=nG[pos][i];\n    if(to==prev || to==pos)continue;\n    P pw=solve(to,pos);\n    res=max(res,pw.first);\n    if(pw.first!=-1){\n      sum+=pw.first;\n      res2=max(res2, -pw.first+pw.second);\n    }else{\n      res2=max(res2,pw.second);\n    }\n  }\n  if(q[pos]==1 && res==-1){\n    return P(-1,sum+res2);\n  }\n  return P(sum,sum+res2);\n}\n\nint main(){\n  scanf(\"%d %d\",&V,&E);\n  for(int i=0;i<V;i++){\n    scanf(\"%d\",&s[i]);\n    p[i]=i;\n    q[i]=1;\n  }\n  for(int i=0;i<E;i++){\n    int a,b;\n    scanf(\"%d %d\",&a,&b);\n    a--,b--;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n  dfs(0,-1);\n  for(int pos=0;pos<V;pos++){\n    for(int i=0;i<(int)G[pos].size();i++){\n      int to=find(G[pos][i]);\n      if(used[pos].count(to)>0)continue;\n      used[pos][to]=true;\n      nG[ find(pos) ].push_back( to );\n    }\n    t[ find(pos) ]+=s[pos];\n  }\n  P ans=solve(find(0),-1);\n  printf(\"%d\\n\", ans.second);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_N 100011\n#define N MAX_N\n#define rank dfasfds\nusing namespace std;\ntypedef long long ll;\ntypedef set<int> S;\nint par[MAX_N],rank[MAX_N];\nll val[MAX_N];\nS G[N];\n\nvoid init(int n){for(int i=0;i<N;i++)par[i]=i,rank[i]=0;}\n\nint find(int x){\n  if(par[x]==x)return x;\n  return par[x]=find(par[x]);\n}\n\nbool same(int x,int y){return find(x)==find(y);}\n\nvoid unite(int x,int y){\n  x=find(x),y=find(y);\n  if(x==y)return;\n  if(rank[x]<rank[y])par[x]=y,val[y]+=val[x];\n  else{\n    par[y]=x;\n    val[x]+=val[y];\n    if(rank[x]==rank[y])rank[x]++;\n  }\n}\n\nint used[N];\nvector<int> path;\nvoid dfs(int pos,int pre){\n  if(pos!=find(pos))return;\n  if(used[pos]) {\n    for(int i=0;i<path.size();i++)unite(pos,path[i]);\n    return;\n  }\n  used[pos]=1;\n  path.push_back(pos);\n  for(S::iterator it=G[pos].begin();it!=G[pos].end();it++)if(*it!=pre)dfs(*it,pos);\n  used[pos]=0;\n  path.pop_back();\n}\n\nvector<int>col[N];\nll get_mx(int pos,int pre){\n  if(used[find(pos)])return 0;\n  used[find(pos)]=1;\n  ll res=0;\n  for(int i=0;i<col[find(pos)].size();i++)\n    for(S::iterator it=G[col[pos][i]].begin();it!=G[col[pos][i]].end();it++){\n      if(*it!=pre&&!same(*it,pos))res=max(res,get_mx(*it,pos));\n    }\n  return res+val[find(pos)];\n}\n\nint main(){\n  int n,m;\n  cin>>n>>m;\n  for(int i=0;i<n;i++) cin>>val[i];\n  for(int i=0,a,b;i<m;i++){\n    cin>>a>>b;a--,b--;\n    G[a].insert(b);\n    G[b].insert(a);\n  }\n  init(n);\n  dfs(0,-1);\n  for(int i=0;i<n;i++)col[find(i)].push_back(i);\n  cout <<get_mx(find(0),-1)<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\n\nll N, M, W[100000], cnt[100000];\nvector<ll> E[100000], candidate;\nbool visited[100000], check[100000];\n\nvoid dfs_candidate(ll v) {\n  visited[v] = true;\n  for(ll u : E[v]) if(!visited[u]) {\n    if(!check[v] && check[u]) candidate.push_back(u);\n    else dfs_candidate(u);\n  }\n}\n\nll dfs(ll v) {\n  ll ret = 0;\n  visited[v] = true;\n  for(ll u : E[v]) if(!visited[u]) ret = max(ret, dfs(u));\n  return ret + W[v];\n}\n\nint main(void) {\n  cin >> N >> M;\n  REP(i, 0, N) cin >> W[i];\n  REP(i, 0, M) {\n    ll U, V; cin >> U >> V; U--; V--;\n    E[U].push_back(V);\n    E[V].push_back(U);\n  }\n\n  cout << E[0].size() << endl;\n\n  queue<ll> q;\n  REP(i, 0, N) cnt[i] = E[i].size();\n  REP(i, 1, N) if(cnt[i] == 1) q.push(i);\n  REP(i, 0, N) check[i] = false;\n  while(q.size()) {\n    ll v = q.front();\n    q.pop();\n    if(v == 0) continue;\n    check[v] = true;\n    for(ll u : E[v]) if(--cnt[u] == 1) q.push(u);\n  }\n\n  REP(i, 0, N) visited[i] = false;\n  dfs_candidate(0);\n\n  ll ans = 0;\n  REP(i, 0, N) visited[i] = false;\n  REP(i, 0, N) if(!check[i]) visited[i] = true;\n  for(ll v : candidate) ans = max(ans, dfs(v));\n  REP(i, 0, N) if(!check[i]) ans += W[i];\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define MAX_V 111111\ntypedef pair<int,int> P;\nvector<int> G[MAX_V],C[MAX_V],T[MAX_V],ord,low,belong;\nvector<P> B;\n\nvoid add_edge(int u,int v){\n  G[u].push_back(v);\n  G[v].push_back(u);\n}\n\nbool is_bridge(int u,int v){\n  if(ord[u]>ord[v]) swap(u,v);\n  return ord[u]<low[v];\n}\nvoid dfs(int u,int p,int &k){\n  ord[u]=low[u]=k;\n  k++;\n  for(int i=0;i<(int)G[u].size();i++){\n    int v=G[u][i];\n    if(v==p) continue;\n    if(ord[v]>=0){\n      low[u]=min(low[u],ord[v]);\n    }else{\n      dfs(v,u,k);\n      low[u]=min(low[u],low[v]);\n    }\n    if(is_bridge(u,v)) B.push_back(P(u,v));\n  }\n}\nvoid fill_component(int c,int u){\n  C[c].push_back(u);\n  belong[u]=c;\n  for(int i=0;i<(int)G[u].size();i++){\n    int v=G[u][i];\n    if(belong[v]>=0||is_bridge(u,v)) continue;\n    fill_component(c,v);\n  }\n}\n\nvoid add_component(int u,int &k){\n  if(belong[u]>=0) return;\n  fill_component(k++,u);\n}\n\nvoid biconnectedgrapth(int n){\n  int k=0;\n  ord.resize(n,-1);\n  low.resize(n);\n  belong.resize(n,-1);\n  for(int v=0;v<n;v++){\n    if(ord[v]>=0) continue;\n    dfs(v,-1,k);\n  }\n  k=0;\n  for(int i=0;i<(int)B.size();i++){\n    add_component(B[i].first,k);\n    add_component(B[i].second,k);\n  }\n  add_component(0,k);\n  for(int i=0;i<n;i++) assert(belong[i]>=0);\n  for(int i=0;i<(int)B.size();i++){\n    int u=belong[B[i].first],v=belong[B[i].second];\n    add_edge(u,v);\n  }\n}\n\nint W[MAX_V];\n\nint dfs2(int u,int p){\n  int res=0;\n  for(int i=0;i<(int)T[u].size();i++){\n    int v=T[u][i];\n    if(v==p) continue;\n    res=max(res,dfs2(v,u));\n  }\n  return W[u]+res;\n}\nsigned main(){\n  int n,m;\n  cin>>n>>m;\n  int w[n];\n  for(int i=0;i<n;i++) cin>>w[i];\n  for(int i=0;i<m;i++){\n    int u,v;\n    cin>>u>>v;\n    add_edge(u-1,v-1);\n  }\n  biconnectedgrapth(n);\n  for(int i=0;i<n;i++) W[belong[i]]+=w[i];\n  cout<<dfs2(belong[0],-1)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<(int)(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\nstruct Edge {\n  int src, dest, weight;\n};\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\nvoid add_edge(Graph &g, int src, int dest, int weight = 0) {\n  g[src].push_back((Edge){src,dest,weight});\n  g[dest].push_back((Edge){dest,src,weight});\n}\n\nint dfs1(const Graph& g, vector<int>& vw, const vector<bool>& in_loop, int i, int prev = -1) {\n  if (i == 0) {\n    int tmp = vw[i];\n    vw[i] = 0;\n    return tmp;\n  }\n  int res = 0;\n  for (Edge e : g[i]) {\n    if (e.dest == prev) continue;\n    if (!in_loop[e.dest]) {\n      res = max(res, dfs1(g, vw, in_loop, e.dest, e.src));\n    }\n  }\n  if (res > 0) {\n    int tmp = vw[i];\n    vw[i] = 0;\n    return res + tmp;\n  } else return 0;\n}\n\nint dfs2(const Graph& g, const vector<int>& vw, const vector<bool>& in_loop, int i, int prev = -1) {\n  if (g[i].size() == 1) return vw[i];\n  int res = 0;\n  for (Edge e : g[i]) {\n    if (e.dest == prev) continue;\n    if (!in_loop[e.dest]) {\n      res = max(res, dfs2(g, vw, in_loop, e.dest, e.src));\n    }\n  }\n  return res + vw[i];\n}\n\nint main() {\n  int n,m;\n  cin>>n>>m;\n  vector<int> vw(n);\n  REP(i,n) cin>>vw[i];\n  Graph g(n);\n  REP(i,m) {\n    int u,v;\n    cin>>u>>v;\n    --u; --v;\n    add_edge(g, u, v);\n  }\n  vector<int> nume(n);\n  queue<int> que;\n  REP(i,n) {\n    nume[i] = g[i].size();\n    if (nume[i] == 1) {\n      que.push(i);\n    }\n  }\n  vector<bool> in_loop(n, true);\n  while(!que.empty()) {\n    int i = que.front();\n    que.pop();\n    in_loop[i] = false;\n    //if (nume[i] == 0) continue;\n    for (Edge e : g[i]) {\n      --nume[e.dest];\n      if (nume[e.dest] == 1) {\n        que.push(i);\n      }\n    }\n  }\n  int res = 0;\n  REP(i,n) {\n    if (in_loop[i]) {\n      res += vw[i];\n      vw[i] = 0;\n      res += dfs1(g, vw, in_loop, i);\n    }\n  }\n  if (res > 0) {\n    int edgescore = 0;\n    REP(i,n) {\n      if (in_loop[i]) {\n        edgescore = max(edgescore, dfs2(g, vw, in_loop, i));\n      }\n    }\n    cout << res + edgescore << endl;\n  } else {\n    cout << dfs2(g, vw, in_loop, 0) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing Weight=long long;\n\nstruct Edge{\n    int src,dst;\n    Edge(int src,int dst):\n    src(src),dst(dst){}\n};\n\nusing Edges=vector<Edge>;\nusing Graph=vector<Edges>;\n\nint memo[100001];\n\npair<vector<int>, Edges> bridge(const Graph& g) {\n\tconst int n = g.size();\n\tint idx = 0, s = 0, t = 0, k = 0;\n\tvector<int>ord(n, -1), onS(n), stk(n), roots(n), cmp(n);\n\tEdges brdg;\n\tfunction<void(int, int)> dfs = [&](int v, int u) {\n\t\tord[v] = idx++;\n\t\tstk[s++] = v;\n\t\tonS[v] = true;\n\t\troots[t++] = v;\n\t\tfor (auto& e : g[v]) {\n\t\t\tint w = e.dst;\n\t\t\tif (ord[w] == -1)dfs(w, v);\n\t\t\telse if (u != w && onS[w])\n\t\t\t\twhile (ord[roots[t - 1]]>ord[w])--t;\n\t\t}\n\t\tif (v == roots[t - 1]) {\n\t\t\tbrdg.emplace_back(u, v);\n\t\t\twhile (true) {\n\t\t\t\tint w = stk[--s];\n\t\t\t\tonS[w] = false;\n\t\t\t\tcmp[w] = k;\n\t\t\t\tif (v == w)break;\n\t\t\t}\n\t\t\t--t;\n\t\t\t++k;\n\t\t}\n\t};\n\tfor (int u = 0; u<n; ++u) {\n\t\tif (ord[u] == -1) {\n\t\t\tdfs(u, n);\n\t\t\tbrdg.pop_back();\n\t\t}\n\t}\n\treturn make_pair(cmp, brdg);\n}\n\nint dfs1(const Graph &g,int p,int v,vector<bool> &elect,\nvector<int>&elements,vector<int>&cycle,vector<Weight>&node){\n    if(memo[v])return memo[v];\n    int res=0;\n    elect[v]=false;\n    for(auto e:g[v]){\n        if(elements[cycle[e.dst]]>1 || e.dst==0)return memo[v]=node[v];\n        if(e.dst!=p && elements[cycle[e.dst]]==1){\n            res=dfs1(g,v,e.dst,elect,elements,cycle,node);\n            if(res)return memo[v]=res+node[v];\n        }\n    }\n    return 0;\n}\n\nint main(){\n    int n,m;\n    cin>>n>>m;\n    Graph g(n);\n    vector<Weight>node(n);\n    for(int i=0;i<n;++i){\n        cin>>node[i];\n    }\n    for(int i=0;i<m;++i){\n        int s,t;\n        cin>>s>>t;\n        --s;--t;\n        g[s].emplace_back(s,t);\n        g[t].emplace_back(t,s);\n    }\n    vector<int>cycle = bridge(g).first;\n    vector<int>elements(n,0);\n    for(int i=0;i<n;++i){\n        elements[cycle[i]]++;\n    }\n    vector<bool>elect(n,true);\n    int buf=0;\n    for(int i=1;i<n;++i){\n        if(g[i].size()==1){\n            buf=max(buf,dfs1(g,-1,g[i][0].src,elect,elements,cycle,node));\n        }\n    }\n    int ans=0;\n    for(int i=0;i<n;++i){\n        if(elect[i]){\n            ans+=node[i];\n        }\n    }\n    ans+=buf;\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nint N, M, S = 0;\nvector<long long> w;\nusing Graph = vector<vector<int> >;\nGraph G;\n\nvoid dfs(vector<int> vs, vector<long long> &dist) {\n    for (auto v : vs) {\n        for (auto nv : G[v]) {\n            if (dist[nv] != -1) continue;\n            dist[nv] = dist[v] + w[nv];\n            dfs({nv}, dist);\n        }\n    }\n}\n\nlong long solve() {\n    vector<int> deg(N, 0);\n    for (int v = 0; v < N; ++v) {\n        for (auto nv : G[v]) {\n            ++deg[v];\n            ++deg[nv];\n        }\n    }\n    for (int v = 0; v < N; ++v) deg[v] /= 2;\n\n    queue<int> que;\n    for (int v = 0; v < N; ++v) if (v != S && deg[v] == 1) que.push(v);\n\n    vector<bool> fucked(N, false);\n    while (!que.empty()) {\n        int v = que.front(); que.pop();\n        fucked[v] = true;\n        for (auto nv : G[v]) {\n            --deg[nv];\n            if (nv != S && deg[nv] == 1) que.push(nv);\n        }\n    }\n\n    long long res = 0;\n    vector<int> vs;\n    vector<long long> dist(N, -1);\n    for (int v = 0; v < N; ++v) if (!fucked[v]) {\n            res += w[v];\n            vs.push_back(v);\n            dist[v] = 0;\n        }\n\n    dfs(vs, dist);\n    long long ma = 0;\n    for (int v = 0; v < N; ++v) ma = max(ma, dist[v]);\n    return res + ma;\n}\n\n\nint main() {\n    cin >> N >> M;\n    w.resize(N);\n    for (int i = 0; i < N; ++i) cin >> w[i];\n    G.assign(N, vector<int>());\n    for (int i = 0; i < M; ++i) {\n        int u, v; cin >> u >> v; --u, --v;\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n\n    cout << solve() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int> P;\nstruct BiconectedGraph{\n  int n;\n  vector<vector<int> > G,C,T;\n  vector<int> ord,low,belong;\n  vector<P> B;\n  BiconectedGraph(){}\n  BiconectedGraph(int sz):n(sz),G(sz),C(sz),T(sz){}\n  \n  void add_edge(int u,int v){\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n\n  void input(int m,int offset=0){\n    int a,b;\n    for(int i=0;i<m;i++){\n      cin>>a>>b;\n      add_edge(a+offset,b+offset);\n    }\n  }\n  \n  bool is_bridge(int u,int v){\n    if(ord[u]>ord[v]) swap(u,v);\n    return ord[u]<low[v];\n  }\n  \n  void dfs(int v,int p,int &k){\n    ord[v]=low[v]=k;\n    ++k;\n    for(int u:G[v]){\n      if(u==p) continue;\n      if(ord[u]>=0){\n  low[v]=min(low[v],ord[u]);\n      }else{\n  dfs(u,v,k);\n  low[v]=min(low[v],low[u]);\n      }\n      if(is_bridge(u,v)) B.push_back(P(u,v));\n    }\n  }\n  \n  void fill_component(int c,int v){\n    C[c].push_back(v);\n    belong[v]=c;\n    for(int u:G[v]){\n      if(belong[u]>=0||is_bridge(u,v)) continue;\n      fill_component(c,u);\n    }\n  }\n  \n  void add_component(int v,int &k){\n    if(belong[v]>=0) return;\n    fill_component(k++,v);\n  }\n  \n  int build(){\n    int k=0;\n    ord.resize(n);\n    low.resize(n);\n    belong.resize(n);\n    fill(ord.begin(),ord.end(),-1);\n    fill(belong.begin(),belong.end(),-1);\n    for(int v=0;v<n;v++){\n      if(ord[v]>=0) continue;\n      dfs(v,-1,k);\n    }\n    k=0;\n    for(int i=0;i<(int)B.size();i++){\n      add_component(B[i].first,k);\n      add_component(B[i].second,k);\n    }\n    for(int v=0;v<n;v++) add_component(v,k);\n    for(int i=0;i<(int)B.size();i++){\n      int u=belong[B[i].first],v=belong[B[i].second];\n      T[u].push_back(v);\n      T[v].push_back(u);\n    }\n    return k;\n  }\n};\n//END CUT HERE\n\nint ans=0;\n\nvoid dfs(int x,vector<int>&used,vector<vector<int> >&v,map<int,int>&m,int A){\n  used[x]=1;\n  int res=0;\n  int f=0;\n  int now=m[x];\n  r(i,v[x].size()){\n    if(used[v[x][i]])continue;\n    dfs(v[x][i],used,v,m,A+now);\n    f++;\n  }\n  if(f==0){\n    ans=max(A+now,ans);\n  }\n  return ;\n}\n\nint n,m,w[100009],x[100009],y[1000009];\n\nsigned main(){\n  cin>>n>>m;\n  r(i,n)cin>>w[i];\n  BiconectedGraph bcc(n);\n  set<P>tt;\n  r(i,m){\n    cin>>x[i]>>y[i];\n    x[i]--;y[i]--;\n    if(x[i]==y[i])return 0;\n    bcc.add_edge(x[i],y[i]);\n    if(tt.count(P(x[i],y[i]))||tt.count(P(y[i],x[i])))exit(1);\n    tt.insert(P(x[i],y[i]));\n  }\n  bcc.build();\n  int cnt=0;\n  map<int,int>M,count,wei;\n  set<int>st;\n  r(i,n){\n    if(!st.count(bcc.belong[i])){\n      st.insert(bcc.belong[i]);\n      count[cnt]++;\n      wei[cnt]+=w[i];\n      M[bcc.belong[i]]=cnt++;\n    }\n    else{\n      wei[M[bcc.belong[i]]]+=w[i];\n      count[M[bcc.belong[i]]]++;\n    }\n  }\n  \n  BiconectedGraph B(cnt+1);\n  int root = M[bcc.belong[0]];\n  vector<P>hen;\n  r(i,m){\n    if(bcc.belong[x[i]]==bcc.belong[y[i]])continue;\n    B.add_edge(M[bcc.belong[x[i]]],M[bcc.belong[y[i]]]);\n    hen.push_back(P(M[bcc.belong[x[i]]],M[bcc.belong[y[i]]]));\n\n  }\n  r(i,cnt){\n    if(count[i]>1)if(i!=root){\n      B.add_edge(cnt,i);\n      hen.push_back(P(cnt,i));\n    }\n  }\n  B.add_edge(root,cnt);\n  hen.push_back(P(root,cnt));\n  B.build();\n  st.clear();\n  map<int,int>wei2;\n  M.clear();\n  int cnt2=0;\n  r(i,cnt+1){\n    if(!st.count(B.belong[i])){\n      st.insert(B.belong[i]);\n      wei2[cnt2]+=wei[i];\n      M[B.belong[i]]=cnt2++;\n    }\n    else{\n      wei2[M[B.belong[i]]]+=wei[i];\n    }\n  }\n  int ii=0;\n  vector<vector<int> >v(cnt2);\n  r(i,hen.size()){\n    int x=hen[i].first;\n    int y=hen[i].second;\n    if(B.belong[x]==B.belong[y])continue;\n    x=M[B.belong[x]];\n    y=M[B.belong[y]];\n    v[x].push_back(y);\n    v[y].push_back(x);\n    ii++;\n  }\n  root = M[B.belong[root]];\n  vector<int>used(cnt2,0);\n  dfs(root,used,v,wei2,0);\n  cout<<root+ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n\nclass Graph{\npublic:\n  int n;\n  vector<vector<int> > e;\n  vector<int> w,vdeg,cost;\n\n  Graph(int v){\n    n = v;\n    w = vector<int>(n,0);\n    vdeg = vector<int>(n,0);\n    cost = vector<int>(n,0);\n    e = vector<vector<int> >(n,vector<int>(0));\n  }\n\n  void addEdge(int a, int b){\n    e[a].push_back(b);\n    e[b].push_back(a);\n    vdeg[a]++;\n    vdeg[b]++;\n  }\n\n  int degree(int u){\n    return (int)e[u].size();\n  }\n\n  bool isConnected(int u, int v){\n    auto itr = find(e[u].begin(),e[u].end(),v);\n    if(itr == e[u].end()) return false;\n    return true;\n  }\n\n};\n\nclass Tree{\npublic:\n  int n,mc=0;\n  vector<int> par,w,cost;\n  vector<vector<int> > child;\n\n  Tree(int v){\n    n = v;\n    par = vector<int>(n,-1);\n    w = vector<int>(n,0);\n    cost = vector<int>(n,0);\n    child = vector<vector<int> >(n,vector<int>(0));\n  }\n\n  void setCost(int v, int c){\n    cost[v] = c;\n    mc = max(mc,c);\n  }\n\n  void addCost(int v, int c){\n    cost[v] += c;\n    mc = max(mc,cost[v]);\n  }\n\n  void addEdge(int pr,int chi){\n    child[pr].push_back(chi);\n    par[chi] = pr;\n  }\n\n  int childsize(int u){\n    return (int)child[u].size();\n  }\n};\n\nint main(){\n\n  int n,m;\n  cin >> n >> m;\n  Graph g(n);\n  vector<int> tour(n,1);\n  rep(i,n){\n    int w;\n    cin >> w;\n    g.w[i] = w;;\n  }\n  rep(i,m){\n    int u,v;\n    cin >> u >> v;\n    u--;v--;\n    g.addEdge(u,v);\n  }\n\n  // 次数1の頂点を消していく\n  queue<int> que;\n  rep(i,n){\n    if(g.degree(i)==1)que.push(i);\n  }\n  while(!que.empty()){\n    int i = que.front();\n    que.pop();\n    if(i==0)continue;\n    tour[i] = 0;\n    rep(j,g.e[i].size()){\n      int to = g.e[i][j];\n      if(tour[to]){\n        g.vdeg[to]--;\n        if(g.vdeg[to]==1)que.push(to);\n      }\n    }\n  }\n  \n  int cent = 0;\n  int w = 0;\n  rep(i,n)if(tour[i]==1){cent++;w+=g.w[i];}\n  \n  vector<int> inds(n);\n  int index = 0;\n  rep(i,n){\n    if(tour[i]==0){\n      inds[i] = index;\n      index++;\n    }\n  }\n\n  // gから巡回可能部分を縮約したグラフtを構築する\n  int nt = n-cent+1;\n  Graph t(nt);\n  if (cent>0){\n    t.w[nt-1] = w;\n    //t.setWeight(nt-1,w);\n  }\n  index = 0;\n  rep(i,n){\n    if (tour[i]==0){\n      t.w[inds[i]] = g.w[i];\n      // t.setWeight(inds[i],g.w[i]);\n      rep(j,g.e[i].size()){\n        if(tour[g.e[i][j]]==0&&!t.isConnected(inds[i],inds[g.e[i][j]])){\n          t.addEdge(inds[i],inds[g.e[i][j]]);\n        } else if (tour[g.e[i][j]]==1) {\n          t.addEdge(inds[i],nt-1);\n        }\n      }\n    }\n  }\n  int rt;\n  if (tour[0]==0){rt = inds[0];}\n  else {rt = nt-1;}\n\n  // BFS\n  vector<bool> visited(nt,false);\n  rep(i,nt)t.cost[i] = t.w[i];\n  que.push(rt);\n  int maxcost = 0;\n  while(!que.empty()){\n    int u = que.front();\n    que.pop();\n    visited[u] = true;\n    if (t.cost[u]>maxcost)maxcost = t.cost[u];\n    rep(i,t.e[u].size()){\n      int to = t.e[u][i];\n      if(!visited[to]){\n        que.push(to);\n        t.cost[to] += t.cost[u];\n      }\n    }\n  }\n  cout << maxcost << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_V 100000\nusing namespace std;\nint m,w[100001];\nvector<int> vv[100001];\nunordered_set<int> st[100001];\nint V;\nvector<int> G[MAX_V];\nvector<int> rG[MAX_V];\nvector<int> vs;\nbool used[MAX_V];\nint cmp[MAX_V];\nint C[100001],F[100001],U[100001],ans;\nbool UU[100001];\n\n\nvoid DFS(int p){\n  for(int i=0;i<vv[p].size();i++){\n    int mn=min(vv[p][i],p),mx=max(vv[p][i],p);\n    if(st[mn].find(mx)==st[mn].end()){\n      st[mn].insert(mx);\n      G[p].push_back(vv[p][i]);\n      rG[vv[p][i]].push_back(p);\n      DFS(vv[p][i]);\n    }\n  }\n}\n\nvoid dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++)if(!used[G[v][i]])dfs(G[v][i]);\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v]=true;\n  cmp[v]=k;\n  for(int i=0;i<rG[v].size();i++)if(!used[rG[v][i]])rdfs(rG[v][i],k);\n}\n\nint scc(){\n  for(int v=0;v<V;v++)if(!used[v])dfs(v);\n  memset(used,0,sizeof(used));\n  int k=0;\n  for(int i=vs.size()-1;i>=0;i--)if(!used[vs[i]])rdfs(vs[i],k++);\n  return k;\n}\n\nbool DFS1(int p){\n  if(U[p])return 0;\n  U[p]=1;\n  bool f=F[cmp[p]]>=2;\n  for(int i=0;i<G[p].size();i++)\n    f|=DFS1(G[p][i]);\n  ans+=w[p]*f;\n  return UU[p]=f;\n}\nbool UUU[100001];\nint DFS2(int p){\n  if(UUU[p])return 0;\n  UUU[p]=1;\n  int res=0;\n  \n  for(int i=0;i<G[p].size();i++)\n    res=max(res,DFS2(G[p][i]));  \n  return res+(UU[p]?0:w[p]);\n}\n\nint main(){\n  cin>>V>>m;\n  for(int i=0;i<V;i++)cin>>w[i];\n  for(int j=0,a,b;j<m;j++){\n    cin>>a>>b;a--,b--;\n    vv[a].push_back(b),vv[b].push_back(a);\n  }\n  DFS(0);\n  int t=0;\n  for(int i=0;i<V;i++)t+=w[i];\n  scc();\n  for(int i=0;i<V;i++)F[cmp[i]]++;\n  DFS1(0);\n  cout<<ans+DFS2(0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing Weight=long long;\n\nstruct Edge{\n    int src,dst;\n    Edge(int src,int dst):\n    src(src),dst(dst){}\n};\n\nusing Edges=vector<Edge>;\nusing Graph=vector<Edges>;\n\nint memo[100001];\n\npair<vector<int>, Edges> bridge(const Graph& g) {\n\tconst int n = g.size();\n\tint idx = 0, s = 0, t = 0, k = 0;\n\tvector<int>ord(n, -1), onS(n), stk(n), roots(n), cmp(n);\n\tEdges brdg;\n\tfunction<void(int, int)> dfs = [&](int v, int u) {\n\t\tord[v] = idx++;\n\t\tstk[s++] = v;\n\t\tonS[v] = true;\n\t\troots[t++] = v;\n\t\tfor (auto& e : g[v]) {\n\t\t\tint w = e.dst;\n\t\t\tif (ord[w] == -1)dfs(w, v);\n\t\t\telse if (u != w && onS[w])\n\t\t\t\twhile (ord[roots[t - 1]]>ord[w])--t;\n\t\t}\n\t\tif (v == roots[t - 1]) {\n\t\t\tbrdg.emplace_back(u, v);\n\t\t\twhile (true) {\n\t\t\t\tint w = stk[--s];\n\t\t\t\tonS[w] = false;\n\t\t\t\tcmp[w] = k;\n\t\t\t\tif (v == w)break;\n\t\t\t}\n\t\t\t--t;\n\t\t\t++k;\n\t\t}\n\t};\n\tfor (int u = 0; u<n; ++u) {\n\t\tif (ord[u] == -1) {\n\t\t\tdfs(u, n);\n\t\t\tbrdg.pop_back();\n\t\t}\n\t}\n\treturn make_pair(cmp, brdg);\n}\n\nint dfs1(const Graph &g,int p,int v,vector<bool> &elect,\nvector<int>&elements,vector<int>&cycle,vector<Weight>&node){\n    if(memo[v])return memo[v];\n    int res=0;\n    elect[v]=false;\n    for(auto e:g[v]){\n        if(elements[cycle[e.dst]]>1 || e.dst==0)return memo[v]=node[v];\n        if(e.dst!=p && elements[cycle[e.dst]]==1){\n            res=dfs1(g,v,e.dst,elect,elements,cycle,node);\n        }\n    }\n    if(res)return memo[v]=res+node[v];\n    return 0;\n}\n\nint main(){\n    int n,m;\n    cin>>n>>m;\n    Graph g(n);\n    vector<Weight>node(n);\n    for(int i=0;i<n;++i){\n        cin>>node[i];\n    }\n    for(int i=0;i<m;++i){\n        int s,t;\n        cin>>s>>t;\n        --s;--t;\n        g[s].emplace_back(s,t);\n        g[t].emplace_back(t,s);\n    }\n    vector<int>cycle = bridge(g).first;\n    vector<int>elements(n,0);\n    for(int i=0;i<n;++i){\n        elements[cycle[i]]++;\n    }\n    vector<bool>elect(n,true);\n    int buf=0;\n    for(int i=1;i<n;++i){\n        if(g[i].size()==1){\n            buf=max(buf,dfs1(g,-1,g[i][0].src,elect,elements,cycle,node));\n        }\n    }\n    int ans=0;\n    for(int i=0;i<n;++i){\n        if(elect[i]){\n            ans+=node[i];\n        }\n    }\n    ans+=buf;\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n#define mod 1000000007\n\nint n,m;\nint w[100010];\nvector<int> g[100010];\nint mx[100010];\nbool vis[100010];\n\nint dfs(int v,int pre){\n  bool dame=false;\n  vis[v]=true;\n  mx[v]=0;\n  for(int nv : g[v]){\n    if(nv==pre)continue;\n    if(vis[nv]||dfs(nv,v)==-1)dame=true;\n    maxch(mx[v],mx[nv]);\n  }\n  mx[v]+=w[v];\n  return dame?mx[v]=-1:mx[v];\n}\n\nint main(){\n  cin>>n>>m;\n  rep(i,n)cin>>w[i];\n  rep(i,m){\n    int a,b;\n    cin>>a>>b;\n    a--;b--;\n    g[a].push_back(b);\n    g[b].push_back(a);\n  }\n  memset(mx,-1,sizeof(mx));\n  dfs(0,-1);\n  int add=0,sum=0;\n  rep(i,n){\n    if(mx[i]==-1)sum+=w[i];\n    else maxch(add,mx[i]);\n  }\n  cout<<sum+add<<endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_V 100000\nusing namespace std;\nint m,w[100001];\nvector<int> vv[100001];\nunordered_set<int> st[100001];\nint V;\nvector<int> G[MAX_V];\nvector<int> rG[MAX_V];\nvector<int> vs;\nbool used[MAX_V];\nint cmp[MAX_V];\nint C[100001],F[100001],U[100001],ans;\nbool UU[100001];\n\n\nvoid DFS(int p){\n  for(int i=0;i<vv[p].size();i++){\n    int mn=min(vv[p][i],p),mx=max(vv[p][i],p);\n    if(st[mn].find(mx)==st[mn].end()){\n      st[mn].insert(mx);\n      G[p].push_back(vv[p][i]);\n      rG[vv[p][i]].push_back(p);\n      DFS(vv[p][i]);\n    }\n  }\n}\n\nvoid dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++)if(!used[G[v][i]])dfs(G[v][i]);\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v]=true;\n  cmp[v]=k;\n  for(int i=0;i<rG[v].size();i++)if(!used[rG[v][i]])rdfs(rG[v][i],k);\n}\n\nint scc(){\n  for(int v=0;v<V;v++)if(!used[v])dfs(v);\n  memset(used,0,sizeof(used));\n  int k=0;\n  for(int i=vs.size()-1;i>=0;i--)if(!used[vs[i]])rdfs(vs[i],k++);\n  return k;\n}\n\nbool DFS1(int p){\n  if(U[p])return 0;\n  U[p]=1;\n  bool f=F[cmp[p]]>=2;\n  for(int i=0;i<G[p].size();i++)\n    f|=DFS1(G[p][i]);\n  ans+=w[p]*f;\n  return UU[p]=f;\n}\nbool UUU[100001];\nint DFS2(int p){\n  if(UUU[p])return 0;\n  UUU[p]=1;\n  int res=0;\n  \n  for(int i=0;i<G[p].size();i++)\n    res=max(res,DFS2(G[p][i]));  \n  return res+(UU[p]?0:w[p]);\n}\n\nint main(){\n  cin>>V>>m;\n  for(int i=0;i<V;i++)cin>>w[i];\n  for(int j=0,a,b;j<m;j++){\n    cin>>a>>b;a--,b--;\n    vv[a].push_back(b),vv[b].push_back(a);\n  }\n  DFS(0);\n  int t=0;\n  for(int i=0;i<V;i++)t+=w[i];\n  scc();\n  for(int i=0;i<V;i++)F[cmp[i]]++;\n  DFS1(0);\n  cout<<ans+DFS2(0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\n#define MAX 200000\n\nint N;\nvector<int> G[MAX];\nbool visited[MAX];\nint prenum[MAX],parent[MAX],lowest[MAX],timer;\nvector<P> bridge;\n\nvoid dfs(int v,int prev){\n\tprenum[v]=lowest[v]=timer;\n\ttimer++;\n\tvisited[v]=true;\n\n\tint next;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tnext=G[v][i];\n\t\tif(!visited[next]){\n\t\t\tparent[next]=v;\n\t\t\tdfs(next,v);\n\t\t\tlowest[v]=min(lowest[v],lowest[next]);\n\t\t\tif(prenum[v]<lowest[G[v][i]])bridge.push_back(P(min(v,G[v][i]),max(v,G[v][i])));\n\t\t}else if(next!=prev){\n\t\t\tlowest[v]=min(lowest[v],prenum[next]);\n\t\t}\n\t}\n}\n\n\nset<int> art_points(){\n\tfor(int i=0;i<N;i++){\n\t\tvisited[i]=false;\n\t}\n\ttimer=1;\n\tdfs(0,-1);\n\n\tset<int> ap;\n\tint np=0;\n\tfor(int i=1;i<N;i++){\n\t\tint p=parent[i];\n\t\tif(p==0)np++;\n\t\telse if(prenum[p]<lowest[i])ap.insert(p);\n\t}\n\tif(np>1)ap.insert(0);\n\treturn ap;\n}\n\nint w[MAX];\nvector<P> edge;\nvector<P> n_bridge;\nvector<int> ok_G[MAX];\nint cnt;\nbool used[100001];\nint sum[100001];\nint num[100001];\nint siz[100001];\nvector<int> graph[MAX];\n\nvoid c_dfs(int v){\n\tused[v]=true;\n\tnum[v]=cnt;\n\tsiz[cnt]++;\n\tsum[cnt]+=w[v];\n\tfor(int i=0;i<ok_G[v].size();i++){\n\t\tif(num[ok_G[v][i]]==-1){\n\t\t\tc_dfs(ok_G[v][i]);\n\t\t}\n\t}\n}\n\nint dp[100001];\nint dp2[100001];\n\nint solve2(int v,int p){\n\tif(dp2[v]!=-1)return dp2[v];\n\tint res=w[v];\n\tint back=-1;\n\tfor(int i=0;i<graph[v].size();i++){\n\t\tif(p!=graph[v][i]){\n\t\t\tint va=solve2(graph[v][i],v);\n\t\t\tif(va!=0){\n\t\t\t\tres+=va;\n\t\t\t\tback=0;\n\t\t\t}\n\t\t}\n\t}\n\tif(siz[v]>=3)back=0;\n\tdp2[v]=(back==0)?res:0;\n\treturn dp2[v];\n}\n\nint solve(int v,int p){\n\tif(dp[v]!=-1)return dp[v];\n\tint res=0;\n\tfor(int i=0;i<graph[v].size();i++){\n\t\tif(p!=graph[v][i]){\n\t\t\tint va=solve2(graph[v][i],v);\n\t\t\tif(va!=0)res+=va;\n\t\t}\n\t}\n\tint diff=0;\n\tfor(int i=0;i<graph[v].size();i++){\n\t\tif(p!=graph[v][i]){\n\t\t\tint va=solve(graph[v][i],v);\n\t\t\tif(va-max(dp2[v],0)>diff){\n\t\t\t\tdiff=va-max(0,dp2[v]);\n\t\t\t}\n\t\t}\n\t}\n\tres+=diff;\n\treturn (dp[v]=(res+sum[v]));\n}\n\nint main(void){\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d\",&w[i]);\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\ta--;\n\t\tb--;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t\tedge.push_back(P(a,b));\n\t}\n\tN=n;\n\tart_points();\n\tsort(bridge.begin(),bridge.end());\n\tfor(int i=0;i<m;i++){\n\t\tint v=lower_bound(bridge.begin(),bridge.end(),edge[i])-bridge.begin();\n\t\tif(!(v<bridge.size() && bridge[v]==edge[i])){\n\t\t\tok_G[edge[i].first].push_back(edge[i].second);\n\t\t\tok_G[edge[i].second].push_back(edge[i].first);\n\t\t}\n\t}\n\tmemset(num,-1,sizeof(num));\n\tfor(int i=0;i<n;i++){\n\t\tif(num[i]==-1){\n\t\t\tc_dfs(i);\n\t\t\tcnt++;\n\t\t}\n\t}\n\tfor(int i=0;i<bridge.size();i++){\n\t\tP p=bridge[i];\n\t\tgraph[num[p.first]].push_back(num[p.second]);\n\t\tgraph[num[p.second]].push_back(num[p.first]);\n\t}\n\tmemset(dp,-1,sizeof(dp));\n\tmemset(dp2,-1,sizeof(dp2));\n\tprintf(\"%d\\n\",solve(num[0],-1));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <map>\nusing namespace std;\nusing pii = pair<int, int>;\n\ntemplate <typename T1, typename T2>\nostream& operator<<(ostream& os, const pair<T1, T2>& p)\n{\n    os << \"Pair<\" << p.first << \",\" << p.second << \">\";\n    return os;\n}\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& vec)\n{\n    os << \"Vec{\";\n    for (const T& e : vec) {\n        os << e << \",\";\n    }\n    os << \"}\" << endl;\n    return os;\n}\ntemplate <typename T1, typename T2>\nostream& operator<<(ostream& os, const map<T1, T2>& st)\n{\n    os << \"Set{\\n\";\n    for (const auto& e : st) {\n        os << e.first << \": \" << e.second << endl;\n    }\n    os << \"}\" << endl;\n    return os;\n}\n\nstruct Graph {\n    Graph(const int n)\n    {\n        edge.resize(n);\n        revedge.resize(n);\n    }\n    void addEdge(const int from, const int to)\n    {\n        edge[from].push_back(to);\n        revedge[to].push_back(from);\n    }\n    vector<vector<int>> edge;\n    vector<vector<int>> revedge;\n};\n\nvoid depth_dfs(const Graph& g, Graph& dig, map<pii, int>& diedge, map<pii, int>& resedge, const int s, vector<int>& depth, vector<bool>& used, const int deg)\n{\n    depth[s] = deg;\n    for (const int to : g.edge[s]) {\n        if (not used[to]) {\n            used[to] = true;\n            dig.addEdge(s, to);\n            diedge[make_pair(s, to)] = 0;\n            resedge.erase(make_pair(s, to));\n            resedge.erase(make_pair(to, s));\n            depth_dfs(g, dig, diedge, resedge, to, depth, used, deg + 1);\n        }\n    }\n}\n\nvoid accum(const Graph& dig, const int s, map<pii, int>& diedge)\n{\n    for (const int to : dig.edge[s]) {\n        int sum = 0;\n        accum(dig, to, diedge);\n        for (const int to2 : dig.edge[to]) {\n            sum += diedge[make_pair(to, to2)];\n        }\n        diedge[make_pair(s, to)] += sum;\n    }\n}\n\nvoid cc_dfs(const Graph& newg, const int s, vector<int>& comp, vector<bool>& visited, const int cnum)\n{\n    visited[s] = true;\n    comp[s] = cnum;\n    for (const int to : newg.edge[s]) {\n        cc_dfs(newg, to, comp, visited, cnum);\n    }\n}\n\nvoid decomp(const Graph& dig, Graph& decomped, const int s, const vector<int>& comp, set<pii>& decomped_edge)\n{\n    const int c1 = comp[s];\n    for (const int to : dig.edge[s]) {\n        decomp(dig, decomped, to, comp, decomped_edge);\n        const int c2 = comp[to];\n        if (c1 != c2 and decomped_edge.find(make_pair(c1, c2)) == decomped_edge.end()) {\n            decomped_edge.insert(make_pair(c1, c2));\n            decomped.addEdge(c1, c2);\n        }\n    }\n}\n\nint weight_dfs(const Graph& decomped, const int s, const vector<int>& weight)\n{\n    int maxi = 0;\n    for (const int to : decomped.edge[s]) {\n        maxi = max(maxi, weight_dfs(decomped, to, weight));\n    }\n    return weight[s] + maxi;\n}\n\nint main()\n{\n    int N, M;\n    cin >> N >> M;\n    Graph g(N);\n    vector<int> w(N);\n    for (int i = 0; i < N; i++) {\n        cin >> w[i];\n    }\n    map<pii, int> edges;\n    for (int i = 0; i < M; i++) {\n        int u, v;\n        cin >> u >> v;\n        u--, v--;\n        g.addEdge(u, v);\n        g.addEdge(v, u);\n        edges[make_pair(u, v)] = 0;\n        edges[make_pair(v, u)] = 0;\n    }\n    Graph dig(N);\n    map<pii, int> diedge;\n    map<pii, int> resedge = edges;\n    vector<int> depth(N, 0);\n    vector<bool> used(N, false);\n    used[0] = true;\n    depth_dfs(g, dig, diedge, resedge, 0, depth, used, 0);\n    // cerr << \"depth: \" << depth << endl;\n\n    map<pii, int> resedge_ = resedge;\n    resedge.clear();\n    for (const auto& e : resedge_) {\n        const int u = e.first.first;\n        const int v = e.first.second;\n        if (resedge.find(make_pair(v, u)) == resedge.end()) {\n            resedge[make_pair(u, v)] = 0;\n        }\n    }\n    // cerr << \"diedge: \" << diedge << endl;\n    // cerr << \"resedge: \" << resedge << endl;\n\n\n    for (const auto& e : resedge) {\n        const int u = e.first.first;\n        const int v = e.first.second;\n        int a;\n        int b;\n        if (depth[u] < depth[v]) {\n            b = u;\n            a = v;\n        } else {\n            b = v;\n            a = u;\n        }\n        if (not dig.revedge[b].empty()) {\n            const int par = dig.revedge[b][0];\n            diedge[make_pair(par, b)]--;\n        }\n        const int par = dig.revedge[a][0];\n        diedge[make_pair(par, a)]++;\n    }\n    vector<int> node(N, 0);\n    // cerr << \"diedge: \" << diedge << endl;\n    accum(dig, 0, diedge);\n    // cerr << \"diedge: \" << diedge << endl;\n\n    Graph newg(N);\n    for (const auto& e : diedge) {\n        if (e.second != 0) {\n            const int u = e.first.first;\n            const int v = e.first.second;\n            newg.addEdge(u, v);\n        }\n    }\n    // cerr << \"newg: \" << endl;\n    // for (int i = 0; i < N; i++) {\n    //     cerr << newg.edge[i] << endl;\n    // }\n\n    vector<bool> visited(N, false);\n    vector<int> comp(N, 0);\n    int cnum = 0;\n    for (int i = 0; i < N; i++) {\n        if (not visited[i]) {\n            cc_dfs(newg, i, comp, visited, cnum);\n            cnum++;\n        }\n    }\n    // cerr << \"comp: \" << comp << endl;\n    vector<int> weight(cnum, 0);\n    for (int i = 0; i < N; i++) {\n        const int c = comp[i];\n        weight[c] += w[i];\n    }\n    // cerr << \"weight: \" << weight << endl;\n\n    set<pii> decomped_edge;\n    Graph decomped(cnum);\n    decomp(dig, decomped, 0, comp, decomped_edge);\n    // cerr << \"decomped: \" << endl;\n    // for (int i = 0; i < cnum; i++) {\n    //     cerr << decomped.edge[i] << endl;\n    // }\n\n    cout << weight_dfs(decomped, 0, weight) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(i,v.size())cout<<\" \"<<v[i];cout<<endl<<endl;\n#define show2d(v) rep(i,v.size()){rep(j,v[i].size())cout<<\" \"<<v[i][j];cout<<endl;}cout<<endl;\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<int,int,int> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};//ESWN\nclass BRI{\n\tpublic:\n\tint n,N;\n\tvi order,inS,cmp;\n\tvp brg;\n\tvvi G,each_bcc;\n\t// N : scc後の頂点数\n\t// brg : 橋一覧\n\t// each_bcc : 二重連結成分のリスト\n\t// cmp : ある頂点がどの二重連結成分に含まれているか\n\tstack<int> roots, S;\n\tBRI(int size){\n\t\tn=size;\n\t\tG=vvi(n);\n\t}\n\tvoid add_edge(int s,int t){\n\t\tG[s].pb(t);\n\t\tG[t].pb(s);\n\t}\n\tvoid visit(int cur,int prev,int &k){\n\t\torder[cur]=++k;\n\t\tS.push(cur);\n\t\tinS[cur]=true;\n\t\troots.push(cur);\n\t\t\n\t\trep(i,G[cur].size()){\n\t\t\tint to=G[cur][i];\n\t\t\tif(!order[to])visit(to,cur,k);\n\t\t\telse if(to!=prev&&inS[to])\n\t\t\t\twhile(order[roots.top()]>order[to])roots.pop();\n\t\t}\n\t\t\n\t\tif(cur==roots.top()){\n\t\t\tif(prev!=-1)brg.pb({prev,cur});\n\t\t\tvi bcc;\n\t\t\twhile(1){\n\t\t\t\tint node=S.top();\n\t\t\t\tS.pop();\n\t\t\t\tinS[node]=false;\n\t\t\t\tbcc.pb(node);\n\t\t\t\tcmp[node]=N;\n\t\t\t\tif(node==cur)break;\n\t\t\t}\n\t\t\tN++;\n\t\t\teach_bcc.pb(bcc);\n\t\t\troots.pop();\n\t\t}\n\t}\n\tvoid bri(){\n\t\tN=0;\n\t\torder=inS=cmp=vi(n);\n\t\troots=S=stack<int>();\n\t\tint k=0;\n\t\trep(i,n)if(order[i]==0)\n\t\t\tvisit(i,-1,k);\n\t}\n\tvvi make(){\n\t\tvvi tG(N);\n\t\trep(i,brg.size()){\n\t\t\tint a=brg[i].first,b=brg[i].second;\n\t\t\ttG[cmp[a]].pb(cmp[b]);\n\t\t\ttG[cmp[b]].pb(cmp[a]);\n\t\t}\n\t\treturn tG;\n\t}\n\tvvi f(vi w){\n\t\tvvi out(N,vi(2));\n\t\trep(i,n){\n\t\t\tout[cmp[i]][1]++;\n\t\t\tout[cmp[i]][0]+=w[i];\n\t\t}\n\t\treturn out;\n\t}\n};\nvvi data;\nint n,m;\nvvi G;\nvi used;\npii dfs(int a){\n\tint out1=0,out2=0;\n\tused[a]=true;\n\trep(i,G[a].size())if(used[G[a][i]]==0){\n\t\tpii t=dfs(G[a][i]);\n\t\tout1=max(out1,t.first);\n\t\tout2+=t.second;\n\t}\n\tif(out2||data[a][1]-1)out2+=data[a][0];\n\telse out1+=data[a][0];\n\treturn {out1,out2};\n}\nint main(){\n\tcin>>n>>m;\n\tvi w(n);\n\trep(i,n)cin>>w[i];\n\tBRI bri(n);\n\twhile(m--){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\ta--;b--;\n\t\tbri.add_edge(a,b);\n\t}\n\tbri.bri();\n\tn=bri.N;\n\tG=bri.make();\n\tdata=bri.f(w);\n\tused=vi(n);\n\tpii ans=dfs(0);\n\tcout<<ans.first+ans.second<<endl;\n}\n\n\t\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);++i)\n#define rep2(i,a,b) for (int i=(a);i<(b);++i)\n#define rrep(i,n) for (int i=(n)-1;i>=0;--i)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;--i)\n#define chmin(a,b) (a)=min((a),(b));\n#define chmax(a,b) (a)=max((a),(b));\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) cout<<(#v)<<\":\";for(auto(x):(v)){cout<<\" \"<<(x);}cout<<endl;\n#define printVS(vs) cout<<(#vs)<<\":\"<<endl;for(auto(s):(vs)){cout<<(s)<< endl;}\n#define printVV(vv) cout<<(#vv)<<\":\"<<endl;for(auto(v):(vv)){for(auto(x):(v)){cout<<\" \"<<(x);}cout<<endl;}\n#define printP(p) cout<<(#p)<<(p).first<<\" \"<<(p).second<<endl;\n#define printVP(vp) cout<<(#vp)<<\":\"<<endl;for(auto(p):(vp)){cout<<(p).first<<\" \"<<(p).second<<endl;}\n\ninline void output(){ cout << endl; }\ntemplate<typename First, typename... Rest>\ninline void output(const First& first, const Rest&... rest) {\n    cout << first << \" \"; output(rest...);\n}\n\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing TUPLE = tuple<int, int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\nusing Graph = vector<vector<int>>;\n\ntypedef vector<vector<int>> Graph;\ntypedef pair<int, int> Edge; // (a < b: undirected)\n\nvi w;\nvi wcmp;\n\nclass BICC {\nprivate:\n    const int n;\n\n    Graph G;\n    vector<int> depth;\n    vector<int> par;\n    map<Edge, int> imosEdge;\n    map<Edge, int> EdgeType;\n    enum {UNUSED, USED_DFS, BRIDGE};\n    vector<Edge> bridges;\n\n\tvector<int> cmp;\n\tint num_cc;\n\tvector<int> size_of_vertex;\n\tGraph G_cc;\npublic:\n    BICC(int _n) : n(_n), G(_n), depth(_n, -1), par(_n, -1), cmp(_n, -1), num_cc(0) {}\n    Edge getEdge(int a, int b) {\n        if (a > b) swap(a, b);\n        return Edge(a, b);\n    }\n    void updateEdgeType(int a, int b, int type) {\n        if (a < 0 || b < 0) return;\n        EdgeType[getEdge(a, b)] = type;\n    }\n    void addEdge(int a, int b) {\n        G[a].emplace_back(b);\n        G[b].emplace_back(a);\n        updateEdgeType(a, b, UNUSED);\n    }\n    void dfsTreeConstruct(int v, int pre) {\n        if (depth[v] != -1) return;\n        depth[v] = (pre == -1 ? 0 : depth[pre] + 1);\n        par[v] = pre;\n        updateEdgeType(pre, v, USED_DFS);\n        for (auto&& nxt : G[v]) {\n            if (nxt != pre) dfsTreeConstruct(nxt, v);\n        }\n    }\n    void updateImos(int a, int b) {\n        if (depth[a] < depth[b]) swap(a, b);\n\n        if (par[a] != -1) {\n            imosEdge[getEdge(a, par[a])]++;\n        }\n        if (par[b] != -1) {\n            imosEdge[getEdge(b, par[b])]--;\n        }\n    }\n    int imosFinal(int v, int pre) {\n        int t = 0;\n        for (auto&& nxt : G[v]) {\n            if (nxt != pre && EdgeType[getEdge(nxt, v)] == USED_DFS) {\n                t += imosFinal(nxt, v);\n            }\n        }\n        if (pre != -1) imosEdge[getEdge(v, pre)] += t;\n        return pre == -1 ? 0 : imosEdge[getEdge(v, pre)];\n    }\n    int extractCC(int v, int color) {\n    \tif (cmp[v] != -1) return 0;\n    \tcmp[v] = color;\n    \tint t = 1;\n    \tfor (auto&& nxt : G[v]) {\n    \t\tif (EdgeType[getEdge(v, nxt)] != BRIDGE) {\n    \t\t\tt += extractCC(nxt, color);\n    \t\t}\n    \t}\n    \treturn t;\n    }\n    tuple<Graph, vector<int>, vector<int>> bicc() {\n        dfsTreeConstruct(0, -1);\n        for (auto&& p : EdgeType) {\n            Edge e;\n            int type;\n            tie(e, type) = p;\n            if (type == UNUSED) {\n                updateImos(e.first, e.second);\n            }\n        }\n        imosFinal(0, -1);\n        for (auto&& p : EdgeType) {\n            Edge e;\n            int type;\n            tie(e, type) = p;\n            if (type == USED_DFS) {\n                if (imosEdge[e] == 0) {\n                    EdgeType[e] = BRIDGE;\n                    bridges.emplace_back(e);\n                }\n            }\n        }\n\n\t\trep(i, n) {\n\t\t\tint size_cc = extractCC(i, num_cc);\n\t\t\tif (size_cc > 0) {\n\t\t\t\tsize_of_vertex.emplace_back(size_cc);\n\t\t\t\tnum_cc++;\n\t\t\t}\n\t\t}\n\n        // for this problem\n        wcmp.resize(num_cc);\n        rep(i, n) {\n            wcmp[cmp[i]] += w[i];\n        }\n\n\t \tvector<set<int>> G_cc_st(num_cc);\n\t\tfor (auto&& p : EdgeType) {\n            Edge e;\n            int type;\n            tie(e, type) = p;\n            if (type == BRIDGE) {\n\t\t\t\tG_cc_st[cmp[e.first]].insert(cmp[e.second]);\n\t\t\t\tG_cc_st[cmp[e.second]].insert(cmp[e.first]);\n            }\n        }\n\n\t\trep(i, num_cc) {\n\t\t\tG_cc.emplace_back(vector<int>(all(G_cc_st[i])));\n\t\t}\n\n        return make_tuple(G_cc, size_of_vertex, cmp);\n    }\n    vector<Edge> getBridges() {\n        return bridges;\n    }\n};\n\nGraph G;\nvi sz;\nvi cmp;\nint s;\nvector<int> cand;\nvector<bool> red;\n\nbool dfs(int now, int pre) {\n    bool ch_red = (now == s || sz[now] >= 2);\n    for (auto nxt : G[now]) {\n        if (nxt == pre) continue;\n        ch_red |= dfs(nxt, now);\n    }\n    return red[now] = ch_red;\n}\n\n// bool makeRed(int now, int pre) {\n//     if (red[now]) return true;\n//     for (auto nxt : G[now]) {\n//         if (nxt == pre) continue;\n//         makeRed(nxt, now);\n//     }\n// }\n\nvoid dfs2(int now, int pre, int sm) {\n    if (!red[now]) sm += wcmp[now];\n    if ((int)G[now].size() == 1 && !red[now]) {\n        cand.emplace_back(sm);\n        return;\n    }\n\n    for (auto nxt : G[now]) {\n        if (nxt == pre) continue;\n        dfs2(nxt, now, sm);\n    }\n}\n\nmain() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int n, m;\n    cin >> n >> m;\n    w.resize(n);\n    rep(i, n) cin >> w[i];\n    BICC bicc(n);\n    rep(i, m) {\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        bicc.addEdge(u, v);\n    }\n\n    tie(G, sz, cmp) = bicc.bicc();\n    int s = cmp[0];\n    int num_cc = sz.size();\n    red.resize(num_cc);\n    // int tmp_par = -1;\n    // rep(i, sz.size()) {\n    //     if (sz[i] >= 2) tmp_par = i;\n    // }\n    // isred(tmp_par, -1);\n    dfs(s, -1);\n\n    // path(1 -> red) -> red\n    // makeRed(cmp[s], -1);\n\n    int sm_red = 0;\n    rep(i, n) {\n        if (red[cmp[i]]) {\n            sm_red += w[i];\n        }\n    }\n\n    dfs2(s, -1, 0);\n    int ma_path = (cand.empty() ? 0 : *max_element(all(cand)));\n\n    cout << sm_red + ma_path << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<utility>\n#include<set>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define MP make_pair\n#define PB push_back\nusing namespace std;\n\nint n,m;\n\nvoid bfs(int k,vector<int> &cnt,vector<bool>&b,vector<vector<int> > &g){\n    if(cnt[k]==1||cnt[k]==0){\n        b[k] = 0;\n        for(int i:g[k]){\n            if(b[i]){\n                cnt[i]--;\n                bfs(i,cnt,b,g);\n            }\n        }\n    }   \n}\nint bfs2(int k,int z,vector<int>&w,vector<vector<int> > &g){\n    int s=w[k];\n    int mx = 0;\n    for(int x:g[k]){\n        if(x!=z){\n            mx = max(mx,bfs2(x,k,w,g));\n        }\n    }\n    return s+mx;\n}\n\n\nint main(){\n    cin >> n >> m;\n    vector<int> w(n+1);\n    vector<vector<int> > g(n);\n    rep(i,n)cin >> w[i];\n    rep(i,m){\n        int u,v;\n        cin >> u >> v;\n        u--;v--;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    vector<int> cnt(n);\n    rep(i,n){\n        cnt[i] = g[i].size();\n    }\n    vector<bool> b(n,1);\n    rep(i,n){\n        bfs(i,cnt,b,g);\n    }\n    vector<int>p;\n    int sm=0;\n    rep(i,n){\n        if(b[i]){\n            p.PB(i);\n            sm+=w[i];\n        }\n    }\n    w[n]=sm;\n    set<int>st;\n    for(int x:p){\n        for(int y:g[x]){\n            st.insert(y);\n        }\n    }\n    vector<vector<int> >g2(n+1);\n    rep(i,n){\n        if(!b[i]){\n            for(int x:g[i]){\n                if(b[x]){\n                    g2[i].PB(n);\n                    g2[n].PB(i);\n                }else{\n                    g2[i].PB(x);\n                }\n            }\n        }\n    }\n    if(b[0]){\n        cout << bfs2(n,n,w,g2) << endl;\n    }else{\n        cout << max(bfs2(0,0,w,g2),bfs2(n,n,w,g2)) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n\nint dp[100000];\n\nclass Graph{\npublic:\n  int n;\n  vector<int> e[100000];\n  int w[100000];\n\n  Graph(int v){\n    n = v;\n  }\n\n  void setWeight(int v, int ww){\n    w[v] = ww;\n  }\n\n  void addEdge(int a, int b){\n    e[a].push_back(b);\n    e[b].push_back(a);\n  }\n\n  int degree(int u){\n    return (int)e[u].size();\n  }\n\n  bool isConnected(int u, int v){\n    auto itr = find(e[u].begin(),e[u].end(),v);\n    if(itr == e[u].end()) return false;\n    return true;\n  }\n};\n\nclass Tree{\npublic:\n  int n;\n  // int par[100000];\n  // vector<int> child[100000];\n  // int w[100000];\n  vector<int> par,w;\n  vector<vector<int> > child;\n\n  Tree(int v){\n    n = v;\n    par = vector<int>(n,-1);\n    w = vector<int>(n,0);\n    child = vector<vector<int> >(n,vector<int>(0));\n  }\n\n  void setWeight(int v, int ww){\n    w[v] = ww;\n  }\n\n  void addEdge(int pr,int chi){\n    child[pr].push_back(chi);\n    par[chi] = pr;\n  }\n\n  int childsize(int u){\n    return (int)child[u].size();\n  }\n};\n\nint main(){\n\n  int n,m;\n  cin >> n >> m;\n  Graph g(n);\n  vector<int> tour(n,1);\n  rep(i,n){\n    int w;\n    cin >> w;\n    g.setWeight(i,w);\n  }\n  rep(i,m){\n    int u,v;\n    cin >> u >> v;\n    u--;v--;\n    g.addEdge(u,v);\n  }\n\n  queue<int> que;\n  rep(i,n){\n    if(g.degree(i)==1)que.push(i);\n  }\n  while(!que.empty()){\n    int i = que.front();\n    que.pop();\n    tour[i] = 0;\n    int nn = g.e[i][0];\n    if(g.degree(nn)<=2&&tour[nn]==1)que.push(nn);\n  }\n  \n  int cent = 0;\n  int w = 0;\n  rep(i,n)if(tour[i]==1){cent++;w+=g.w[i];}\n  \n  vector<int> inds(n);\n  int index = 0;\n  rep(i,n){\n    if(tour[i]==0){\n      inds[i] = index;\n      index++;\n    }\n  }\n\n  int nt = n-cent+1;\n  Graph t(nt);\n  if (cent>0){\n    t.setWeight(nt-1,w);\n  }\n  index = 0;\n  rep(i,n){\n    if (tour[i]==0){\n      t.setWeight(inds[i],g.w[i]);\n      rep(j,g.e[i].size()){\n        if(tour[g.e[i][j]]==0&&!t.isConnected(inds[i],inds[g.e[i][j]])){\n          t.addEdge(inds[i],inds[g.e[i][j]]);\n        } else if (tour[g.e[i][j]]==1) {\n          t.addEdge(inds[i],nt-1);\n        }\n      }\n    }\n  }\n  int rt;\n  if (tour[0]==0){rt = inds[0];}\n  else {rt = nt-1;}\n  // 根付き木にする\n  Tree tr(nt);\n  rep(i,nt){\n    tr.setWeight(i,t.w[i]);\n  }\n  vector<bool> visited(nt);\n  que.push(rt);\n  while(!que.empty()){\n    int v = que.front();\n    que.pop();\n    visited[v] = true;\n    rep(i,t.e[v].size()){\n      if(!visited[t.e[v][i]]){\n        que.push(t.e[v][i]);\n        tr.addEdge(v,t.e[v][i]);\n      }\n    }\n  }\n  // 木DP\n  rep(i,nt){\n    if(tr.childsize(i)==0)que.push(i);\n  }\n  rep(i,nt)visited[i]=false;\n  while(!que.empty()){\n    int u = que.front();\n    que.pop();\n    if(visited[u])continue;\n    visited[u]=true;\n    int mi = 0;\n    rep(v,tr.child[u].size()){\n      if(mi<dp[tr.child[u][v]]) mi=dp[tr.child[u][v]];\n    }\n    dp[u] = tr.w[u]+mi;\n    if(tr.par[u]!=-1&&!visited[tr.par[u]]) que.push(tr.par[u]);\n  }\n  cout << dp[rt] << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n\nusing VS = vector<string>;    using LL = long long;\nusing VI = vector<int>;       using VVI = vector<VI>;\nusing PII = pair<int, int>;   using PLL = pair<LL, LL>;\nusing VL = vector<LL>;        using VVL = vector<VL>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n#define FOR(i, s, e) for (int(i) = (s); (i) < (e); (i)++)\n#define FORR(i, s, e) for (int(i) = (s); (i) > (e); (i)--)\n#define debug(x) cerr << #x << \": \" << x << endl\nconst int INF = 1e9;                          const LL LINF = 1e16;\nconst LL MOD = 1000000007;                    const double PI = acos(-1.0);\nint DX[8] = { 0, 0, 1, -1, 1, 1, -1, -1 };    int DY[8] = { 1, -1, 0, 0, 1, -1, 1, -1 };\n\nint N, M, W[100000];\nvector<vector<int>> resG;\nvector<int> weightSum, sz;\nint dp1[100000], dp3[100000];\n\n/*-----------------------------------------------\n 二辺連結成分分解 成分だけ unverified\n -----------------------------------------------*/\nstruct UnionFind {\n    vector<int> data;\n    UnionFind(int n) { data.assign(n, -1); }\n    bool unionSet(int x, int y) {\n        x = root(x); y = root(y);\n        if (x != y) {\n            if (data[y] < data[x]) swap(x, y);\n            data[x] += data[y]; data[y] = x;\n        }\n        return x != y;\n    }\n    bool same(int x, int y) { return root(x) == root(y); }\n    int root(int x) { return data[x] < 0 ? x : data[x] = root(data[x]); }\n    int size(int x) { return -data[root(x)]; }\n};\n\nstruct Lowlink {\n    UnionFind uf;\n    vector<int> low, ord, used, parent;\n    int root, k;\n    Lowlink(int V, int Root) :uf(V), low(V), ord(V), used(V), parent(V), root(Root), k(0) {}\n    \n    void lowlink(int v, int p, int &k, vector<vector<int>>& G) {\n        used[v] = true; //visited\n        low[v] = ord[v] = k; k++;\n        for (int i = 0; i < (int)G[v].size(); i++) {\n            int u = G[v][i];\n            if (used[u] == 0) {\n                parent[u] = v;\n                lowlink(u, v, k, G);\n                low[v] = min(low[v], low[u]);\n                if (ord[v] >= low[u])uf.unionSet(v, u);\n            }\n            else if (u != p) {\n                low[v] = min(low[v], ord[u]);\n            }\n        }\n    }\n};\n\nstruct TwoEdgeConnectedComponent:Lowlink{\n //   UnionFind uf;\n    vector<vector<int>> g;\n    vector<pair<int, int>> edges;\n//    vector<int> used, ord, low\n    vector<int> comp;\n    int v;\n    TwoEdgeConnectedComponent(int v) : g(v),comp(v),v(v),Lowlink(v,0) {}\n    \n    void add_edge(int x, int y) {\n        g[x].push_back(y);\n        g[y].push_back(x);\n        edges.push_back(minmax(x, y));\n    }\n    \n    void dfs(int idx, int& k, int par = -1) {\n        used[idx] = true;\n        ord[idx] = k++;\n        low[idx] = ord[idx];\n        \n        for (auto &to : g[idx]) {\n            if (!used[to]) {\n                dfs(to, k, idx);\n                low[idx] = min(low[idx], low[to]);\n                if (ord[idx] >= low[to]) uf.unionSet(idx, to);\n            }\n            else if (to != par) {\n                low[idx] = min(low[idx], ord[to]);\n            }\n        }\n    }\n    \n    // return origin color\n    int operator[](int k) {\n        return (comp[k]);\n    }\n    \n    int size() {\n        return (g.size());\n    }\n    \n    // build, renew resG(empty -> tree), return color\n    vector<int> get_graph(vector<vector<int>>& resG,VI& resW,int root = 0) {\n        int kk = 0;\n        Lowlink::lowlink(root, -1, kk, g);\n//        dfs(root, kk);\n//        Lowlink Low(v,0);\n//        Low.lowlink(root, -1, kk, g);\n//        auto uf = Low.uf;\n        int ptr = 0;\n        vector<int> color(g.size());\n        for (int i = 0; i < g.size(); i++) {\n            if (i == uf.root(i)) color[i] = ptr++;\n        }\n        \n        resG.resize(ptr);\n        for (int i = 0; i < g.size(); i++) {\n            comp[i] = color[uf.root(i)];\n        }\n        \n        resW.resize(ptr);\n        for (int i = 0; i < (int)g.size(); i++) {\n            comp[i] = color[uf.root(i)];\n            // 頂点番号における写像を作る\n            resW[comp[i]] += W[i];//重みをまとめる\n        }\n        for (auto &e : edges) {\n            int x = comp[e.first], y = comp[e.second];\n            if (x == y) continue;\n            resG[x].push_back(y);\n            resG[y].push_back(x);\n        }\n        return comp;\n    }\n};\n\nint rec(int idx, int par = -1)\n{\n    int ret = 0;\n    for (auto &to : resG[idx]) {\n        if (to == par) continue;\n        ret = max(ret, rec(to, idx));\n        dp1[idx] += dp1[to];\n    }\n    ret += weightSum[idx];\n    if (sz[idx] >= 3 || dp1[idx] > 0) dp1[idx] += weightSum[idx];\n    for (auto &to : resG[idx]) {\n        if (to == par) continue;\n        else ret = max(ret, dp1[idx] - dp1[to] + dp3[to]);\n    }\n    return (dp3[idx] = ret);\n}\n\n// 三点以上集まった頂点ならば、ここを起点にもどることができる。\n// dp1[v]:vから葉まで進むときの最大値\n// dp3[v]:vに戻ってくるときの最大値\nvoid f(int v, int p = -1) {\n    for (int nx : resG[v]) {\n        if (nx == p)continue;\n        f(nx, v);\n        dp1[v] += dp1[nx];\n    }\n    int ret = dp1[v];\n    if (dp1[v] || sz[v] > 1)dp1[v] += weightSum[v];\n    for (int nx : resG[v]) {\n        if (nx == p)continue;\n        dp3[v] = max(dp3[v], ret - dp1[nx] + dp3[nx]);\n    }\n    dp3[v] += weightSum[v];\n}\n\nLL dfs(int v, int p, VVI& G, VL& dp, VI& w) {\n    \n    LL res = 0;\n    FOR(i, 0, SZ(G[v])) {\n        int nx = G[v][i];\n        if (nx == p)continue;\n        res = max(res, dfs(nx, v, G, dp, w));\n    }\n    return dp[v] = res + w[v];\n}\n\nint main() {\n    int N, M; cin >> N >> M;\n    FOR(i, 0, N) {\n        cin >> W[i];\n    }\n    TwoEdgeConnectedComponent gx(N);\n    \n    FOR(i, 0, M) {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        gx.add_edge(a, b);\n    }\n    VI resW;\n    VI vc = gx.get_graph(resG,resW);\n    \n    VL dp(N,0);\n    LL ans = dfs(0,-1,resG,dp,resW);\n//    weightSum.assign(resG.size(), 0);\n//    sz.assign(resG.size(), 0);\n//    for (int i = 0; i < N; i++) {\n//        weightSum[vc[i]] += W[i];\n//        sz[vc[i]]++;\n//    }\n//    f(vc[0]);\n//    LL ans = dp3[vc[0]];\n    cout << ans << endl;\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing Weight=long long;\n\nstruct Edge{\n    int src,dst;\n    Edge(int src,int dst):\n    src(src),dst(dst){}\n};\n\nusing Edges=vector<Edge>;\nusing Graph=vector<Edges>;\n\npair<vector<int>, Edges> bridge(const Graph& g) {\n\tconst int n = g.size();\n\tint idx = 0, s = 0, t = 0, k = 0;\n\tvector<int>ord(n, -1), onS(n), stk(n), roots(n), cmp(n);\n\tEdges brdg;\n\tfunction<void(int, int)> dfs = [&](int v, int u) {\n\t\tord[v] = idx++;\n\t\tstk[s++] = v;\n\t\tonS[v] = true;\n\t\troots[t++] = v;\n\t\tfor (auto& e : g[v]) {\n\t\t\tint w = e.dst;\n\t\t\tif (ord[w] == -1)dfs(w, v);\n\t\t\telse if (u != w && onS[w])\n\t\t\t\twhile (ord[roots[t - 1]]>ord[w])--t;\n\t\t}\n\t\tif (v == roots[t - 1]) {\n\t\t\tbrdg.emplace_back(u, v);\n\t\t\twhile (true) {\n\t\t\t\tint w = stk[--s];\n\t\t\t\tonS[w] = false;\n\t\t\t\tcmp[w] = k;\n\t\t\t\tif (v == w)break;\n\t\t\t}\n\t\t\t--t;\n\t\t\t++k;\n\t\t}\n\t};\n\tfor (int u = 0; u<n; ++u) {\n\t\tif (ord[u] == -1) {\n\t\t\tdfs(u, n);\n\t\t\tbrdg.pop_back();\n\t\t}\n\t}\n\treturn make_pair(cmp, brdg);\n}\n\nint dfs1(const Graph &g,int p,int v,vector<bool> &elect,\nvector<int>&elements,vector<int>&cycle,vector<Weight>&node){\n    int res=0;\n    elect[v]=false;\n    for(auto e:g[v]){\n        if(elements[cycle[e.dst]]>1 || e.dst==0)return node[v];\n        if(e.dst!=p && elements[cycle[e.dst]]==1){\n            int t=dfs1(g,v,e.dst,elect,elements,cycle,node);\n            if(t)res=t;\n        }\n    }\n    if(res)return res+node[v];\n    return 0;\n}\n\nint main(){\n    int n,m;\n    cin>>n>>m;\n    Graph g(n);\n    vector<Weight>node(n);\n    for(int i=0;i<n;++i){\n        cin>>node[i];\n    }\n    for(int i=0;i<m;++i){\n        int s,t;\n        cin>>s>>t;\n        --s;--t;\n        g[s].emplace_back(s,t);\n        g[t].emplace_back(t,s);\n    }\n    vector<int>cycle = bridge(g).first;\n    vector<int>elements(n,0);\n    for(int i=0;i<n;++i){\n        elements[cycle[i]]++;\n    }\n    vector<bool>elect(n,true);\n    int buf=0;\n    for(int i=1;i<n;++i){\n        if(g[i].size()==1){\n            buf=max(buf,dfs1(g,-1,g[i][0].src,elect,elements,cycle,node));\n        }\n    }\n    int ans=0;\n    for(int i=0;i<n;++i){\n        if(elect[i]){\n            ans+=node[i];\n        }\n    }\n    ans+=buf;\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n,m;\nvector<int>e[100005];\nvector<int>edge[100005];\nint used[100005];\nint w[100005],k;\nvector<int>E[100005];\nll W[100005];\nint in[100005];\nll dp[100005];\nint cnt[100005];\nint par[100005],ran[100005];\nvoid init(){ for(int i=0;i<100005;i++) par[i] = i; }\nint find(int x){ if(x == par[x]) return x; else return par[x] = find(par[x]); }\nvoid unite(int x,int y){\n\tx = find(x); y = find(y); if(x==y) return;\n\tif(ran[x] < ran[y]) par[x] = y;\n\telse{\n\t\tpar[y] = x;\n\t\tif(ran[x] == ran[y]) ran[x]++;\n\t}\n}\nbool same(int x,int y){ return find(x)==find(y); }\nvoid dfs(int v,int u,int d){\n\tused[v] = d;//cout << v << endl;\n\tfor(int i=0;i<e[v].size();i++){\n\t\tif(e[v][i] == u) continue;\n\t\tif(used[e[v][i]] && used[e[v][i]] < used[v]){\n\t\t\tcnt[e[v][i]]--;\n\t\t\tcnt[v]++;\n\t\t\tunite(e[v][i],v);\n\t\t\t//cout << v << \" \" << e[v][i] << endl;\n\t\t\tcontinue;\n\t\t}\n\t\telse if(used[e[v][i]]) continue;\n\t\tdfs(e[v][i],v,d+1); edge[v].pb(e[v][i]); //cout << v << \" \" << e[v][i] << endl;\n\t}\n}\nint dfs2(int v,int u){\n\tint sum = 0;\n\tfor(int i=0;i<edge[v].size();i++){\n\t\tint a = dfs2(edge[v][i],v);\n\t\tif(a){\n\t\t    //cout << edge[v][i] << \" f\" << v << endl;\n\t\t\tunite(edge[v][i],v);\n\t\t}\n\t\tsum += a;\n\t}\n\tsum += cnt[v];\n\treturn sum;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=0;i<n;i++) scanf(\"%d\",&w[i]);\n\tfor(int i=0;i<m;i++){\n\t\tint a,b; scanf(\"%d%d\",&a,&b); a--; b--;\n\t\te[a].push_back(b);\n\t\te[b].push_back(a);\n\t}\n\tinit(); dfs(0,-1,1); dfs2(0,-1);\n\tfor(int i=0;i<n;i++){\n\t\tW[find(i)] += w[i];\n\t\tfor(int j=0;j<e[i].size();j++){\n\t\t\tif(find(i) != find(e[i][j])){\n\t\t\t\tE[find(i)].pb(find(e[i][j]));\n\t\t\t\tE[find(e[i][j])].pb(find(i));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tSORT(E[i]); ERASE(E[i]);\n\t\tfor(int j=0;j<E[i].size();j++){\n\t\t\tin[E[i][j]]++;\n\t\t}\n\t}\n\tfill(dp,dp+100005,-1e18);\n\tdp[find(0)] = W[find(0)];\n\tqueue<int>que;\n\tque.push(find(0));\n\tmemset(used,0,sizeof(used));\n\tll ret = 0;\n\twhile(!que.empty()){\n\t\tint Q = que.front(); que.pop();\n\t\tif(used[Q]) continue; ret = max(ret,dp[Q]); used[Q] = 1;\n\t\tfor(int i=0;i<E[Q].size();i++){\n\t\t    if(used[E[Q][i]]) continue;\n\t\t\tdp[E[Q][i]] = max(dp[E[Q][i]],dp[Q]+W[E[Q][i]]);\n\t\t\tque.push(E[Q][i]);\n\t\t}\n\t}\n\tcout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing u32 = uint32_t;\nusing vi = vector<int>;    using vvi = vector<vi>;\nusing vb = vector<bool>;   using vvb = vector<vb>;\nusing vl = vector<ll>;     using vvl = vector<vl>;\nusing vd = vector<double>; using vvd = vector<vd>;\n\n#define MAXC(c, x) (c = max(c, x))\n\n#define REP(i,n) for(auto i = 0 * (n), i##_len = (n); i < i##_len; ++i)\n#define ALL(c) (c).begin(), (c).end()\n#define FOR(i,s,n) for(ll i=s, i##_len=(ll)(n); i<i##_len; ++i)\n#define TEN(x) ((ll)1e##x)\nconst ll mod = TEN(9) + 7;\n\n// ??£??\\???????????¨\nstruct Edge { uint32_t to, id; };\nusing Graph = vector<vector<Edge>>;\n\nstruct Bridge {\n#define PB push_back\n\ttypedef uint32_t T;\n\ttypedef vector<T> vt;\n\texplicit Bridge(const Graph & g) : v2cmp(g.size()) {\n\t\tT n = g.size(), k = 0;\n\t\tvt ord(n, 0), low(n), stk;\n\t\tfunction<void(T, T, T)> f = [&](T c, T p, T id) {\n\t\t\tord[c] = low[c] = ++k;\n\t\t\tstk.PB(c);\n\t\t\tfor (auto e : g[c]) {\n\t\t\t\tif (!ord[e.to]) {\n\t\t\t\t\tf(e.to, c, e.id);\n\t\t\t\t\tlow[c] = min(low[c], low[e.to]);\n\t\t\t\t} else if (e.id != id) {\n\t\t\t\t\tlow[c] = min(low[c], ord[e.to]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (low[c] == ord[c]) {\n\t\t\t\tif (p != n) bridge.PB({ id, min(c, p), max(c, p) });\n\t\t\t\tcomponent.PB({});\n\t\t\t\tT v; do {\n\t\t\t\t\tv2cmp[v = stk.back()] = component.size() - 1;\n\t\t\t\t\tstk.pop_back();\n\t\t\t\t\tcomponent.back().PB(v);\n\t\t\t\t} while (v != c);\n\t\t\t}\n\t\t};\n\t\tfor (T i = 0; i < n; ++i) if (!ord[i]) f(i, n, T(-1));\n\t}\n\t// BridgeEdge : u < v ?????????????????????\n\t// v2cmp[v]   : ?????? v ????±?????????????????????????????????????????????????\n\tstruct BridgeEdge { T id, u, v; };\n\tvt v2cmp;\n\tvector<BridgeEdge> bridge;\n\tvector<vt> component;\n};\n\nint main() {\n#ifdef INPUT_FROM_FILE\n\tifstream cin(\"sample.in\");\n\tofstream cout(\"sample.out\");\n#endif\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\tcout << fixed << setprecision(50);\n\tu32 n, m; cin >> n >> m;\n\tvl w(n); REP(i, n) cin >> w[i];\n\tGraph g(n);\n\tREP(i, m) {\n\t\tu32 u, v;\n\t\tcin >> u >> v;\n\t\tu--; v--;\n\t\tg[u].push_back({ v, i });\n\t\tg[v].push_back({ u, i });\n\t}\n\n\tBridge dcc(g);\n\tauto&& cmp = dcc.component;\n\n\tvl w_cmp(cmp.size(), 0);\n\tREP(i, cmp.size()) {\n\t\tfor (auto&& id : cmp[i]) w_cmp[i] += w[id];\n\t}\n\n\tvb visited(cmp.size(), false);\n\tfunction<array<ll, 2>(u32)> dfs = [&](u32 cur_cmp) {\n\t\tarray<ll, 2> ma = {0, 0};\n\t\tvisited[cur_cmp] = true;\n\t\tfor (auto&& v : cmp[cur_cmp]) for (auto&& next : g[v]) {\n\t\t\tu32 next_cmp = dcc.v2cmp[next.to];\n\t\t\tif (visited[next_cmp]) continue;\n\t\t\tauto ret = dfs(next_cmp);\n\t\t\tma[1] = max(ma[1], ret[1]);\n\t\t\tma[0] += ret[0];\n\t\t}\n\t\tif (ma[0] || cmp[cur_cmp].size() > 1) ma[0] += w_cmp[cur_cmp];\n\t\tif (!ma[0]) ma[1] += w_cmp[cur_cmp];\n\t\treturn ma;\n\t};\n\n\tauto p = dfs(dcc.v2cmp[0]);\n\tcout << p[0] + p[1] << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1e9 + 7;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<class T>\nistream& operator >> (istream& is, vector<T>& v)\n{\n\tfor (auto &i : v) is >> i;\n\treturn is;\n}\ntemplate<class T>\nostream& operator<<(ostream& os, vector<T>& v)\n{\n\tconst string delimiter = \"\\n\";\n\tREP(i, v.size())\n\t{\n\t\tos << v[i];\n\t\tif (i != v.size() - 1) os << delimiter;\n\t}\n\treturn os;\n}\n/*--------------------template--------------------*/\n\ntypedef int Weight;\nstruct Edge\n{\n\tint from, to; Weight cost;\n\tbool operator < (const Edge& e) const { return cost < e.cost; }\n\tbool operator > (const Edge& e) const { return cost > e.cost; }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nvoid add_edge(Graph &g, int from, int to, Weight cost)\n{\n\tg[from].push_back(Edge{ from, to, cost });\n}\n\nvector<vi> g, tree;\nvi w;\nvector<bool> can_back;\nvi sum;\n\nbool get_can_back(int v)\n{\n\tbool res = false;\n\tif (tree[v].size() + 1 < g[v].size()) res = true;\n\tfor (auto u : tree[v])\n\t{\n\t\tif (get_can_back(u)) res = u;\n\t}\n\n\treturn can_back[v] = res;\n}\n\nint get_sum(int v)\n{\n\tint res = w[v];\n\tfor (auto u : tree[v])\n\t{\n\t\tres += get_sum(u);\n\t}\n\treturn sum[v] = res;\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tint n, m;\n\tcin >> n >> m;\n\tw.resize(n); cin >> w;\n\tg.resize(n); tree.resize(n); can_back.resize(n);\n\tREP(i, m)\n\t{\n\t\tint u, v; cin >> u >> v;\n\t\tu--; v--;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\tqueue<int> que;\n\tvector<bool> vis(n);\n\tvis[0] = true;\n\tque.push(0);\n\twhile (!que.empty())\n\t{\n\t\tint v = que.front();\n\t\tque.pop();\n\t\tfor (auto u : g[v])\n\t\t{\n\t\t\tif (vis[u]) continue;\n\t\t\tvis[u] = true;\n\t\t\ttree[v].push_back(u);\n\t\t\tque.push(u);\n\t\t}\n\t}\n\tfor (auto v : tree[0])\n\t{\n\t\tget_can_back(v);\n\t}\n\tsum.resize(n);\n\tget_sum(0);\n\tint ans = w[0];\n\tint fin = 0;\n\tFOR(i, 1, n)\n\t{\n\t\tif (can_back[i]) ans += w[i];\n\t\telse\n\t\t{\n\t\t\tchmax(fin, sum[i]);\n\t\t}\n\t}\n\tcout << ans + fin << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing Edges=vector<int>;\nusing Graph=vector<Edges>;\n\nint main(){\n    int n,m;\n    cin>>n>>m;\n    vector<int> w(n);\n    for(int i=0;i<n;i++) cin>>w[i];\n    Graph g(n);\n    for(int i=0;i<m;i++){\n        int u,v;\n        cin>>u>>v;\n        u--,v--;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    vector<int> leaf(n,false);\n    vector<int> pot(n);\n    pot[0]=1e8;\n    queue<int> que;\n    for(int i=1;i<n;i++){\n        pot[i]=g[i].size();\n        if(pot[i]==1){\n            que.push(i);\n            leaf[i]=true;\n        }\n    }\n    vector<int> givew(n);\n    while(!que.empty()){\n        int v=que.front(); que.pop();\n        for(int i=0;i<g[v].size();i++){\n            if(leaf[g[v][i]]) continue;\n            pot[g[v][i]]--;\n            givew[g[v][i]]=max(w[v]+givew[v],givew[g[v][i]]);\n            if(pot[g[v][i]]==1){\n                que.push(g[v][i]);\n                leaf[g[v][i]]=true;\n            }\n        }\n    }\n    int res=0;\n    int maxLeaf=0;\n    for(int i=0;i<n;i++){\n        if(leaf[i]){\n            maxLeaf=max(maxLeaf,givew[i]+w[i]);\n        }\n        else{\n            res+=w[i];\n        }\n    }\n    cout<<res+maxLeaf<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_V 100000\nusing namespace std;\nint m,w[100001];\nvector<int> vv[100001];\nunordered_set<int> st[100001];\nint V;\nvector<int> G[MAX_V];\nvector<int> rG[MAX_V];\nvector<int> vs;\nbool used[MAX_V];\nint cmp[MAX_V];\nint C[100001],F[100001],U[100001],ans;\nbool UU[100001];\n\n\nvoid DFS(int p){\n  for(int i=0;i<vv[p].size();i++){\n    int mn=min(vv[p][i],p),mx=max(vv[p][i],p);\n    if(st[mn].find(mx)==st[mn].end()){\n      st[mn].insert(mx);\n      G[p].push_back(vv[p][i]);\n      rG[vv[p][i]].push_back(p);\n      DFS(vv[p][i]);\n    }\n  }\n}\n\nvoid dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++)if(!used[G[v][i]])dfs(G[v][i]);\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v]=true;\n  cmp[v]=k;\n  for(int i=0;i<rG[v].size();i++)if(!used[rG[v][i]])rdfs(rG[v][i],k);\n}\n\nint scc(){\n  for(int v=0;v<V;v++)if(!used[v])dfs(v);\n  memset(used,0,sizeof(used));\n  int k=0;\n  for(int i=vs.size()-1;i>=0;i--)if(!used[vs[i]])rdfs(vs[i],k++);\n  return k;\n}\n\nbool DFS1(int p){\n  if(U[p])return 0;\n  U[p]=1;\n  bool f=F[cmp[p]]>=2;\n  for(int i=0;i<G[p].size();i++)\n    f|=DFS1(G[p][i]);\n  ans+=w[p]*f;\n  return UU[p]=f;\n}\nbool UUU[100001];\nint DFS2(int p){\n  if(UUU[p])return 0;\n  UUU[p]=1;\n  int res=0;\n  \n  for(int i=0;i<G[p].size();i++)\n    res=max(res,DFS2(G[p][i]));  \n  return res+(UU[p]?0:w[p]);\n}\n\nint main(){\n  cin>>V>>m;\n  for(int i=0;i<V;i++)cin>>w[i];\n  for(int j=0,a,b;j<m;j++){\n    cin>>a>>b;a--,b--;\n    vv[a].push_back(b),vv[b].push_back(a);\n  }\n  DFS(0);\n  int t=0;\n  for(int i=0;i<V;i++)t+=w[i];\n  scc();\n  for(int i=0;i<V;i++)F[cmp[i]]++;\n  DFS1(0);\n  cout<<ans+DFS2(0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n\nclass Graph{\npublic:\n  int n;\n  vector<int> e[100000];\n  int w[100000];\n\n  Graph(int v){\n    n = v;\n  }\n\n  void setWeight(int v, int ww){\n    w[v] = ww;\n  }\n\n  void addEdge(int a, int b){\n    e[a].push_back(b);\n    e[b].push_back(a);\n  }\n\n  int degree(int u){\n    return (int)e[u].size();\n  }\n\n  bool isConnected(int u, int v){\n    auto itr = find(e[u].begin(),e[u].end(),v);\n    if(itr == e[u].end()) return false;\n    return true;\n  }\n};\n\nclass Tree{\npublic:\n  int n,mc=0;\n  // int par[100000];\n  // vector<int> child[100000];\n  // int w[100000];\n  vector<int> par,w,cost;\n  vector<vector<int> > child;\n\n  Tree(int v){\n    n = v;\n    par = vector<int>(n,-1);\n    w = vector<int>(n,0);\n    cost = vector<int>(n,0);\n    child = vector<vector<int> >(n,vector<int>(0));\n  }\n\n  void setWeight(int v, int ww){\n    w[v] = ww;\n  }\n\n  void setCost(int v, int c){\n    cost[v] = c;\n    mc = max(mc,c);\n  }\n\n  void addCost(int v, int c){\n    cost[v] += c;\n    mc = max(mc,cost[v]);\n  }\n\n  void addEdge(int pr,int chi){\n    child[pr].push_back(chi);\n    par[chi] = pr;\n  }\n\n  int childsize(int u){\n    return (int)child[u].size();\n  }\n};\n\nint main(){\n\n  int n,m;\n  cin >> n >> m;\n  Graph g(n);\n  vector<int> tour(n,1);\n  rep(i,n){\n    int w;\n    cin >> w;\n    g.setWeight(i,w);\n  }\n  rep(i,m){\n    int u,v;\n    cin >> u >> v;\n    u--;v--;\n    g.addEdge(u,v);\n  }\n\n  queue<int> que;\n  rep(i,n){\n    if(g.degree(i)==1)que.push(i);\n  }\n  while(!que.empty()){\n    int i = que.front();\n    que.pop();\n    tour[i] = 0;\n    int nn = g.e[i][0];\n    if(g.degree(nn)<=2&&tour[nn]==1)que.push(nn);\n  }\n  \n  int cent = 0;\n  int w = 0;\n  rep(i,n)if(tour[i]==1){cent++;w+=g.w[i];}\n  \n  vector<int> inds(n);\n  int index = 0;\n  rep(i,n){\n    if(tour[i]==0){\n      inds[i] = index;\n      index++;\n    }\n  }\n\n  int nt = n-cent+1;\n  Graph t(nt);\n  if (cent>0){\n    t.setWeight(nt-1,w);\n  }\n  index = 0;\n  rep(i,n){\n    if (tour[i]==0){\n      t.setWeight(inds[i],g.w[i]);\n      rep(j,g.e[i].size()){\n        if(tour[g.e[i][j]]==0&&!t.isConnected(inds[i],inds[g.e[i][j]])){\n          t.addEdge(inds[i],inds[g.e[i][j]]);\n        } else if (tour[g.e[i][j]]==1) {\n          t.addEdge(inds[i],nt-1);\n        }\n      }\n    }\n  }\n  int rt;\n  if (tour[0]==0){rt = inds[0];}\n  else {rt = nt-1;}\n  // 根付き木にする\n  Tree tr(nt);\n  rep(i,nt){\n    tr.setWeight(i,t.w[i]);\n  }\n  vector<bool> visited(nt);\n  que.push(rt);\n  while(!que.empty()){\n    int v = que.front();\n    que.pop();\n    visited[v] = true;\n    rep(i,t.e[v].size()){\n      if(!visited[t.e[v][i]]){\n        que.push(t.e[v][i]);\n        tr.addEdge(v,t.e[v][i]);\n      }\n    }\n  }\n  // 木DP\n  rep(i,nt)tr.setCost(i,tr.w[i]);\n  que.push(rt);\n  while(!que.empty()){\n    int u = que.front();\n    que.pop();\n    if(tr.par[u]!=-1){\n      tr.addCost(u,tr.cost[tr.par[u]]);\n    }\n    rep(v,tr.child[u].size()){\n      que.push(tr.child[u][v]);\n    }\n  }\n  cout << tr.mc << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n#define MAX 100005\n\nint p[MAX];\nint q[MAX];\n\nint find(int x){\n  if(p[x]==x)return x;\n  return p[x]=find(p[x]);\n}\n\nvoid unite(int x,int y){\n  x=find(x);y=find(y);\n  if(x==y)return;\n  p[x]=y;\n  q[y]+=q[x];\n}\n\nbool same(int x,int y){\n  return (find(x)==find(y));\n}\n\nint V,E;\nvector<int> G[MAX];\nvector<int> nG[MAX];\nmap<int,bool> used[MAX];\n\nint s[MAX],t[MAX];\nint depth[MAX];\nint cnt[MAX];\nint visited[MAX];\n\n\n\nvoid dfs(int pos,int prev){\n  visited[pos]=true;\n  for(int i=0;i<(int)G[pos].size();i++){\n    int to=G[pos][i];\n    if(to==prev)continue;\n    if(!visited[to]){\n      depth[to]=depth[pos]+1;\n      dfs(to,pos);\n      cnt[pos]+=cnt[to];\n      if(cnt[to])unite(pos,to);\n    }else if(depth[to]<depth[pos]){\n      unite(pos,to);\n      cnt[pos]++;\n      cnt[to]--;\n    }else{\n      unite(pos,to);\n    }\n  }\n}\n\nint solve(int pos,int prev=-1){\n  int res=0;\n  for(int i=0;i<(int)nG[pos].size();i++){\n    int to=nG[pos][i];\n    if(to==prev || to==pos)continue;\n    res=max(res,solve(to,pos));\n  }\n  return res+t[pos];\n}\n\nint main(){\n  scanf(\"%d %d\",&V,&E);\n  for(int i=0;i<V;i++){\n    scanf(\"%d\",&s[i]);\n    p[i]=i;\n    q[i]=1;\n  }\n  for(int i=0;i<E;i++){\n    int a,b;\n    scanf(\"%d %d\",&a,&b);\n    a--,b--;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n  dfs(0,-1);\n  for(int pos=0;pos<V;pos++){\n    for(int i=0;i<(int)G[pos].size();i++){\n      int to=G[pos][i];\n      if( q[ find(pos) ] > 1 && q[ find(to) ] > 1 ){\n        unite(pos,to);\n      }\n    }\n  }\n  for(int pos=0;pos<V;pos++){\n    for(int i=0;i<(int)G[pos].size();i++){\n      int to=find(G[pos][i]);\n      if(used[pos].count(to)>0)continue;\n      used[pos][to]=true;\n      nG[ find(pos) ].push_back( to );\n    }\n    t[ find(pos) ]+=s[pos];\n  }\n  \n  printf(\"%d\\n\",solve( find(0) ));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct UnionFind\n{\n  vector< int > data;\n\n  UnionFind(int sz)\n  {\n    data.assign(sz, -1);\n  }\n\n  bool unite(int x, int y)\n  {\n    x = find(x), y = find(y);\n    if(x == y) return (false);\n    if(data[x] > data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n    return (true);\n  }\n\n  int find(int k)\n  {\n    if(data[k] < 0) return (k);\n    return (data[k] = find(data[k]));\n  }\n\n  int size(int k)\n  {\n    return (-data[find(k)]);\n  }\n};\n\nstruct BiConnectedComponents\n{\n  UnionFind uf;\n  vector< vector< int > > g;\n  vector< pair< int, int > > edges;\n  vector< int > used, ord, low, comp;\n\n  BiConnectedComponents(size_t v) : uf(v), g(v), used(v, 0), comp(v), ord(v), low(v)\n  {\n  }\n\n  void add_edge(int x, int y)\n  {\n    g[x].push_back(y);\n    g[y].push_back(x);\n    edges.push_back(minmax(x, y));\n  }\n\n  void dfs(int idx, int &k, int par = -1)\n  {\n    used[idx] = true;\n    ord[idx] = k++;\n    low[idx] = ord[idx];\n\n    for(auto &to : g[idx]) {\n      if(!used[to]) {\n        dfs(to, k, idx);\n        low[idx] = min(low[idx], low[to]);\n        if(ord[idx] >= low[to]) uf.unite(idx, to);\n      } else if(to != par) {\n        low[idx] = min(low[idx], ord[to]);\n      }\n    }\n  }\n\n  int operator[](int k)\n  {\n    return (comp[k]);\n  }\n\n  size_t size()\n  {\n    return (g.size());\n  }\n\n  void build(vector< vector< int > > &t)\n  {\n    int kk = 0;\n    dfs(0, kk);\n\n    int ptr = 0;\n    vector< int > cc(g.size());\n    for(int i = 0; i < g.size(); i++) {\n      if(i == uf.find(i)) cc[i] = ptr++;\n    }\n\n    t.resize(ptr);\n    for(int i = 0; i < g.size(); i++) {\n      comp[i] = cc[uf.find(i)];\n    }\n    for(auto &e : edges) {\n      int x = comp[e.first], y = comp[e.second];\n      if(x == y) continue;\n      t[x].push_back(y);\n      t[y].push_back(x);\n    }\n  }\n};\n\nint N, M, W[100000];\nvector< vector< int > > g;\nvector< int > weightSum, sz;\nint dp1[100000], dp2[100000];\nbool child[100000];\n\nint rec(int idx, int par = -1)\n{\n  int ret = 0;\n\n  for(auto &to : g[idx]) {\n    if(to == par) continue;\n    rec(to, idx);\n    dp2[idx] = max(dp2[idx], dp2[to]);\n    dp1[idx] += dp1[to];\n    child[idx] |= dp1[to] > 0;\n  }\n  dp2[idx] += weightSum[idx];\n  if(sz[idx] >= 3 || dp1[idx] > 0) dp1[idx] += weightSum[idx];\n  for(auto &to : g[idx]) {\n    if(to == par) continue;\n    if(child[to] > 0) ret = max(ret, dp1[idx]);\n    else ret = max(ret, dp1[idx] - dp1[to] + dp2[to]);\n  }\n  return (max(dp2[idx], ret));\n}\n\nint main()\n{\n  cin >> N >> M;\n  BiConnectedComponents tree(N);\n  for(int i = 0; i < N; i++) {\n    cin >> W[i];\n  }\n  while(M--) {\n    int U, V;\n    cin >> U >> V;\n    tree.add_edge(--U, --V);\n  }\n  tree.build(g);\n  weightSum.assign(g.size(), 0);\n  sz.assign(g.size(), 0);\n  for(int i = 0; i < N; i++) {\n    weightSum[tree[i]] += W[i];\n    sz[tree[i]]++;\n  }\n  cout << rec(tree[0]) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct Edge{\n    int src,dst;\n    Edge(int src,int dst):\n    src(src),dst(dst){}\n};\n\nusing Edges=vector<Edge>;\nusing Graph=vector<Edges>;\n\nint memo[100001];\n\npair<vector<int>, Edges> bridge(const Graph& g) {\n\tconst int n = g.size();\n\tint idx = 0, s = 0, t = 0, k = 0;\n\tvector<int>ord(n, -1), onS(n), stk(n), roots(n), cmp(n);\n\tEdges brdg;\n\tfunction<void(int, int)> dfs = [&](int v, int u) {\n\t\tord[v] = idx++;\n\t\tstk[s++] = v;\n\t\tonS[v] = true;\n\t\troots[t++] = v;\n\t\tfor (auto& e : g[v]) {\n\t\t\tint w = e.dst;\n\t\t\tif (ord[w] == -1)dfs(w, v);\n\t\t\telse if (u != w && onS[w])\n\t\t\t\twhile (ord[roots[t - 1]]>ord[w])--t;\n\t\t}\n\t\tif (v == roots[t - 1]) {\n\t\t\tbrdg.emplace_back(u, v);\n\t\t\twhile (true) {\n\t\t\t\tint w = stk[--s];\n\t\t\t\tonS[w] = false;\n\t\t\t\tcmp[w] = k;\n\t\t\t\tif (v == w)break;\n\t\t\t}\n\t\t\t--t;\n\t\t\t++k;\n\t\t}\n\t};\n\tfor (int u = 0; u<n; ++u) {\n\t\tif (ord[u] == -1) {\n\t\t\tdfs(u, n);\n\t\t\tbrdg.pop_back();\n\t\t}\n\t}\n\treturn make_pair(cmp, brdg);\n}\n\nbool dfs0(const Graph &g,int p,int v,vector<bool> &elect,\nvector<int>&elements,vector<int>&cycle){\n    for(auto e:g[v]){\n        if(e.dst==p)continue;\n        if(elements[cycle[e.dst]]>1 || elect[e.dst])return elect[v]=1;\n        if(dfs0(g,v,e.dst,elect,elements,cycle))return elect[v]=1;\n    }\n    return 0;\n}\n\nint dfs1(const Graph &g,int p,int v,vector<bool> &elect,\nvector<int>&elements,vector<int>&cycle,vector<Weight>&node){\n    if(memo[v])return memo[v];\n    int res=0;\n    for(auto e:g[v]){\n        if(elect[e.dst]){\n            return memo[v]=node[v];\n        }\n        if(e.dst!=p && elements[cycle[e.dst]]==1){\n            res=dfs1(g,v,e.dst,elect,elements,cycle,node);\n            if(res){\n                return memo[v]=res+node[v];\n            }\n        }\n    }\n    return 0;\n}\n\nint main(){\n    int n,m;\n    cin>>n>>m;\n    Graph g(n);\n    vector<Weight>node(n);\n    for(int i=0;i<n;++i){\n        cin>>node[i];\n    }\n    for(int i=0;i<m;++i){\n        int s,t;\n        cin>>s>>t;\n        --s;--t;\n        g[s].emplace_back(s,t);\n        g[t].emplace_back(t,s);\n    }\n    vector<int>cycle = bridge(g).first;\n    vector<int>elements(n,0);\n    for(int i=0;i<n;++i){\n        elements[cycle[i]]++;\n    }\n    vector<bool>elect(n,false);\n    elect[0]=true;\n    for(int i=1;i<n;++i){\n        if(elements[cycle[i]]>1){\n            dfs0(g,-1,i,elect,elements,cycle);\n        }\n    }\n    int buf=0;\n    for(int i=1;i<n;++i){\n        if(g[i].size()==1){\n            buf=max(buf,dfs1(g,-1,g[i][0].src,elect,elements,cycle,node));\n        }\n    }\n    int ans=0;\n    for(int i=0;i<n;++i){\n        if(elect[i]){\n            ans+=node[i];\n        }\n    }\n    ans+=buf;\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\nvoid dfs(vector<vector<int>>& g, vector<int>& in, vector<bool>& used, int pos, vector<bool>& p){\n\tused[pos] = true;\n\tfor(auto to : g[pos]){\n\t\tif(used[to]) continue;\n\t\tdfs(g, in, used, to, p);\n\t}\n\tif(in[pos] == 1 and pos != 0){\n\t\tfor(auto i : g[pos]){\n\t\t\tin[i]--;\n\t\t}\n\t\tp[pos] = true;\n\t}\n}\n\nint bfs(vector<vector<int>>& g, vector<bool>& used, vector<int>& w){\n\tint n = g.size();\n\n\tqueue<int> q;\n\trep(i,n){\n\t\tif(not used[i]) q.emplace(i);\n\t}\n\n\tvector<int> dis(n,0);\n\twhile(not q.empty()){\n\t\tint pos = q.front(); q.pop();\n\t\tfor(auto to : g[pos]){\n\t\t\tif(not used[to]) continue;\n\t\t\tused[to] = false;\n\t\t\tdis[to] = dis[pos] + w[to];\n\t\t\tq.emplace(to);\n\t\t}\n\t}\n\n\treturn *max_element(all(dis));\n}\n\nint main(){\n\tint n, m;\n\tcin >> n >> m;\n\n\tvector<int> w(n);\n\tcin >> w;\n\n\tvector<vector<int>> g(n);\n\trep(i,m){\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--; b--;\n\t\tg[a].emplace_back(b);\n\t\tg[b].emplace_back(a);\n\t}\n\n\tvector<int> in(n);\n\trep(i,n) in[i] = g[i].size();\n\n\tvector<bool> p(n,0);\n\tvector<bool> used(n,0);\n\tdfs(g, in, used, 0, p);\n\n\tint res = 0;\n\trep(i,n){\n\t\tif(not p[i]) res += w[i];\n\t}\n\n\tcout << bfs(g, p, w) + res << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct twoEdgeComponents {\n\tint n;\n\tvector<vector<int>> g;\n\tvector<int> cmp;\n\tvector<vector<int>> each_bcc;\n\tvector<pair<int,int>> bridge;\n\tvector<int> order;\n\tvector<bool> inS;\n\tstack<int> roots, S;\n\n\ttwoEdgeComponents() {}\n\ttwoEdgeComponents(vector<vector<int>> g_) : n(g_.size()), g(g_) {}\n\n\tvoid add_edge(int p, int q) {\n\t\tg[p].push_back(q);\n\t\tg[q].push_back(p);\n\t}\n\n\tvoid dfs(int cur, int prev, int &k) {\n\t\torder[cur] = ++k;\n\t\tS.push(cur); inS[cur] = true;\n\t\troots.push(cur);\n\n\t\tfor(auto to: g[cur]) {\n\t\t\tif(order[to]==0) dfs(to, cur, k);\n\t\t\telse if(to!=prev && inS[to]) {\n\t\t\t\twhile(order[roots.top()] > order[to]) roots.pop();\n\t\t\t}\n\t\t}\n\n\t\tif(cur == roots.top()) {\n\t\t\tif(prev!=-1) bridge.push_back({prev, cur});\n\t\t\tvector<int> bcc;\n\t\t\twhile(1) {\n\t\t\t\tint node = S.top(); S.pop(); inS[node] = false;\n\t\t\t\tbcc.push_back(node);\n\t\t\t\tif(node==cur) break;\n\t\t\t}\n\t\t\teach_bcc.push_back(bcc);\n\t\t\troots.pop();\n\t\t}\n\t}\n\n\tvoid bcc() {\n\t\torder.assign(n, 0);\n\t\tinS.assign(n, false);\n\t\tcmp.assign(n, -1);\n\t\tint k = 0;\n\t\tfor(int i=0; i<n; ++i) {\n\t\t\tif(order[i] == 0) {\n\t\t\t\tdfs(i, -1, k);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<(int)each_bcc.size(); ++i) {\n\t\t\tfor(auto j: each_bcc[i]) {\n\t\t\t\tcmp[j] = i;\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<vector<int>> getbcc() {\n\t\tvector<vector<int>> h(each_bcc.size(), vector<int>());\n\t\tfor(auto i: bridge) {\n\t\t\tint a = cmp[i.first], b = cmp[i.second];\n\t\t\th[a].push_back(b);\n\t\t\th[b].push_back(a);\n\t\t}\n\t\treturn h;\n\t}\n};\n\nint main() {\n\tint n, m;\n\tcin >> n >> m;\n\tvector<int> w(n);\n\tfor(int i=0; i<n; ++i) cin >> w[i];\n\tvector<vector<int>> g(n);\n\tfor(int i=0; i<m; ++i) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--, b--;\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\n\ttwoEdgeComponents graph(g);\n\tgraph.bcc();\n\t// for(auto i: graph.bridge) cout << i.first << \",\" << i.second << endl;\n\t// cout << \"-----\" << endl;\n\t// for(auto i: graph.each_bcc) {\n\t// \tfor(auto j: i) {\n\t// \t\tcout << j << \" \";\n\t// \t}\n\t// \tcout << endl;\n\t// }\n\t// cout << \"-----\" << endl;\n\tvector<vector<int>> tree = graph.getbcc();\n\t// for(auto i: tree) {\n\t// \tfor(auto j: i) {\n\t// \t\tcout << j << \" \";\n\t// \t}\n\t// \tcout << endl;\n\t// }\n\n\tvector<int> W(graph.each_bcc.size());\n\tfor(int i=0; i<(int)graph.each_bcc.size(); ++i) {\n\t\tfor(int j=0; j<(int)graph.each_bcc[i].size(); ++j) {\n\t\t\tW[i] += w[graph.each_bcc[i][j]];\n\t\t}\n\t}\n\n\tvector<bool> v(n, false);\n\tfunction<bool(int,int)> dfs = [&](int x, int p) {\n\t\tbool ret = false;\n\t\tif(graph.each_bcc[x].size() >= 2) ret = true;\n\t\tfor(auto i: tree[x]) {\n\t\t\tif(i == p) continue;\n\t\t\tret |= dfs(i, x);\n\t\t}\n\t\t// cout << x << \" \" << ret << endl;\n\t\treturn v[x] = ret;\n\t};\n\n\tdfs(graph.cmp[0], -1);\n\n\tint ans = 0;\n\tfor(int i=0; i<(int)graph.each_bcc.size(); ++i) {\n\t\tif(v[i]) ans += W[i];\n\t}\n\t// cout << ans << endl;\n\n\tint tmp = 0;\n\tvector<int> v2(n, 0);\n\tfunction<void(int,int,int)> dfs2 = [&](int x, int p, int cost) {\n\t\tif(!v[x]) cost += W[x];\n\t\ttmp = max(tmp, cost);\n\t\tfor(auto i: tree[x]) {\n\t\t\tif(i == p) continue;\n\t\t\tdfs2(i, x, cost);\n\t\t}\n\t};\n\n\tdfs2(graph.cmp[0], -1, 0);\n\tans += tmp;\n\tcout << ans << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n,m;\nvector<int>e[100005];\nvector<int>edge[100005];\nint used[100005];\nint w[100005],k;\nvector<int>E[100005];\nll W[100005];\nint in[100005];\nll dp[100005];\nint cnt[100005];\nint par[100005],ran[100005];\nvoid init(){ for(int i=0;i<100005;i++) par[i] = i; }\nint find(int x){ if(x == par[x]) return x; else return par[x] = find(par[x]); }\nvoid unite(int x,int y){\n\tx = find(x); y = find(y); if(x==y) return;\n\tif(ran[x] < ran[y]) par[x] = y;\n\telse{\n\t\tpar[y] = x;\n\t\tif(ran[x] == ran[y]) ran[x]++;\n\t}\n}\nbool same(int x,int y){ return find(x)==find(y); }\nvoid dfs(int v,int u,int d){\n\tused[v] = d;//cout << v << endl;\n\tfor(int i=0;i<e[v].size();i++){\n\t\tif(e[v][i] == u) continue;\n\t\tif(used[e[v][i]] && used[e[v][i]] < used[v]){\n\t\t\tcnt[e[v][i]]--;\n\t\t\tcnt[v]++;\n\t\t\tunite(e[v][i],v);\n\t\t\t//cout << v << \" \" << e[v][i] << endl;\n\t\t\tcontinue;\n\t\t}\n\t\telse if(used[e[v][i]]) continue;\n\t\tdfs(e[v][i],v,d+1); edge[v].pb(e[v][i]); //cout << v << \" \" << e[v][i] << endl;\n\t}\n}\nint dfs2(int v,int u){\n\tint sum = 0;\n\tfor(int i=0;i<edge[v].size();i++){\n\t\tint a = dfs2(edge[v][i],v);\n\t\tif(a>0){\n\t\t    //cout << edge[v][i] << \" f\" << v << endl;\n\t\t\tunite(edge[v][i],v);\n\t\t}\n\t\tsum += a;\n\t}\n\tsum += cnt[v];\n\treturn sum;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=0;i<n;i++) scanf(\"%d\",&w[i]);\n\tfor(int i=0;i<m;i++){\n\t\tint a,b; scanf(\"%d%d\",&a,&b); a--; b--;\n\t\te[a].push_back(b);\n\t\te[b].push_back(a);\n\t}\n\tinit(); dfs(0,-1,1); dfs2(0,-1);\n\tfor(int i=0;i<n;i++){\n\t\tW[find(i)] += w[i];\n\t\tfor(int j=0;j<e[i].size();j++){\n\t\t\tif(find(i) != find(e[i][j])){\n\t\t\t\tE[find(i)].pb(find(e[i][j]));\n\t\t\t\tE[find(e[i][j])].pb(find(i));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tSORT(E[i]); ERASE(E[i]);\n\t}\n\tfill(dp,dp+100005,0);\n\tdp[find(0)] = W[find(0)];\n\tqueue<int>que;\n\tque.push(find(0));\n\tmemset(used,0,sizeof(used));\n\tll ret = 0;\n\twhile(!que.empty()){\n\t\tint Q = que.front(); que.pop();\n\t\tif(used[Q]) continue; ret = max(ret,dp[Q]); used[Q] = 1;\n\t\tfor(int i=0;i<E[Q].size();i++){\n\t\t\tdp[E[Q][i]] = max(dp[E[Q][i]],dp[Q]+W[E[Q][i]]);\n\t\t\tque.push(E[Q][i]);\n\t\t}\n\t}\n\tcout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_V 100000\nusing namespace std;\nint m,w[100001];\nvector<int> vv[100001];\nunordered_set<int> st[100001];\nint V;\nvector<int> G[MAX_V];\nvector<int> rG[MAX_V];\nvector<int> vs;\nbool used[MAX_V];\nint cmp[MAX_V];\nint C[100001],F[100001],U[100001],ans;\nbool UU[100001];\n\n\nvoid DFS(int p){\n  for(int i=0;i<vv[p].size();i++){\n    int mn=min(vv[p][i],p),mx=max(vv[p][i],p);\n    if(st[mn].find(mx)==st[mn].end()){\n      st[mn].insert(mx);\n      G[p].push_back(vv[p][i]);\n      rG[vv[p][i]].push_back(p);\n      DFS(vv[p][i]);\n    }\n  }\n}\n\nvoid dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++)if(!used[G[v][i]])dfs(G[v][i]);\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v]=true;\n  cmp[v]=k;\n  for(int i=0;i<rG[v].size();i++)if(!used[rG[v][i]])rdfs(rG[v][i],k);\n}\n\nint scc(){\n  for(int v=0;v<V;v++)if(!used[v])dfs(v);\n  memset(used,0,sizeof(used));\n  int k=0;\n  for(int i=vs.size()-1;i>=0;i--)if(!used[vs[i]])rdfs(vs[i],k++);\n  return k;\n}\n\nbool DFS1(int p){\n  if(U[p])return 0;\n  U[p]=1;\n  bool f=F[cmp[p]]>=2;\n  for(int i=0;i<G[p].size();i++)\n    f|=DFS1(G[p][i]);\n  ans+=w[p]*f;\n  return UU[p]=f;\n}\nbool UUU[100001];\nint DFS2(int p){\n  if(UUU[p])return 0;\n  UUU[p]=1;\n  int res=0;\n  \n  for(int i=0;i<G[p].size();i++)\n    res=max(res,DFS2(G[p][i]));  \n  return res+(UU[p]?0:w[p]);\n}\n\nint main(){\n  cin>>V>>m;\n  for(int i=0;i<V;i++)cin>>w[i];\n  for(int j=0,a,b;j<m;j++){\n    cin>>a>>b;a--,b--;\n    vv[a].push_back(b),vv[b].push_back(a);\n  }\n  DFS(0);\n  int t=0;\n  for(int i=0;i<V;i++)t+=w[i];\n  scc();\n  for(int i=0;i<V;i++)F[cmp[i]]++;\n  DFS1(0);\n  cout<<ans+DFS2(0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_V 114514\ntypedef pair<int,int> P;\nvector<vector<int> > G,C,T;\n//vector<int> G[MAX_V],C[MAX_V],T[MAX_V];\nvector<int> ord,low,belong;\nvector<P> B;\nint V,K;\nbool is_bridge(int u,int v){\n  if(ord[u]>ord[v]) swap(u,v);\n  return ord[u]<low[v];\n}\ntypedef pair<int,P> PP;\nvoid dfs(int uu,int pp,int d=0){\n  //cout<<u<<\" \"<<p<<\" \"<<d<<endl;\n  stack<PP> s;\n  s.push(PP(0,P(uu,pp)));\n  int u,p,i,v;\n  u=uu;p=pp;\n BEGIN:\n  ord[u]=low[u]=K;\n  K++;\n  for(i=0;i<(int)G[u].size();i++){\n    v=G[u][i];\n    if(v==p) continue;\n    if(ord[v]>=0){\n      low[u]=min(low[u],ord[v]);\n    }else{\n      s.push(PP(i,P(u,p)));\n      p=u;\n      u=v;\n      goto BEGIN;\n    RET:\n      PP pp=s.top();s.pop();\n      i=pp.first;u=pp.second.first;p=pp.second.first;\n      v=G[u][i];\n      low[u]=min(low[u],low[v]);\n    }\n    if(is_bridge(u,v)) B.push_back(P(u,v));\n  }\n  \n  if(!s.empty()){\n    goto RET;\n  }\n  \n}\nvoid fill_component(int c,int u){\n  C[c].push_back(u);\n  belong[u]=c;\n  for(int v:G[u]){\n    if(belong[v]>=0||is_bridge(u,v)) continue;\n    fill_component(c,v);\n  }\n}\nvoid add_component(int u){\n  if(belong[u]>=0) return;\n  C.emplace_back();\n  fill_component(C.size()-1,u);\n}\n\nvoid biconnectedgraph(int n){\n  K=0;\n  ord.clear();\n  ord.resize(n,-1);\n  low.clear();\n  low.resize(n);\n  belong.clear();\n  belong.resize(n,-1);\n  //puts(\"OK2\");\n  for(int v=0;v<n;v++){\n    if(ord[v]>=0) continue;\n    //cout<<v<<endl;\n    dfs(v,-1);\n  }\n  //puts(\"OK3\");\n  C.clear();\n  for(int i=0;i<(int)B.size();i++){\n    add_component(B[i].first);\n    add_component(B[i].second);\n  }\n  add_component(0);\n  V=C.size();\n  T.clear();\n  T.resize(V);\n  for(int i=0;i<(int)B.size();i++){\n    int u=belong[B[i].first],v=belong[B[i].second];\n    T[u].push_back(v);\n    T[v].push_back(u);\n  }\n}\n\nvoid add_edge(int u,int v){\n  G[u].push_back(v);\n  G[v].push_back(u);\n}\n\nstatic int wei[MAX_V],memo[MAX_V];\nstatic bool used[MAX_V],dele[MAX_V];\nbool flag=0;\nint root,xyz;\nvoid dfs2(int v,int p){\n  used[v]=1;\n  if(v!=root&&(int)C[v].size()>1){\n    if(v==xyz) xyz=root;\n    flag=1;\n    dele[v]=1;\n    for(int k:T[v])\n      T[root].push_back(k);\n    wei[root]+=wei[v];\n    return;\n  }\n  for(int i=0;i<(int)T[v].size();i++){\n    int u=T[v][i];\n    if(u==p) continue;\n    if(used[u]) continue;\n    dfs2(u,v);\n    if(flag){\n      if(~p){\n\tif(v==xyz) xyz=root;\n\tdele[v]=1;\n\tfor(int k:T[v])\n\t  T[root].push_back(k);\n\twei[root]+=wei[v];\n\treturn;\n      }else{\n\tflag=0;\n      }\n    }\n  }\n}\n\nint dfs3(int v,int p){\n  int res=wei[v];\n  for(int u:T[v]){\n    if(dele[u]||u==p) continue;\n    res=max(res,wei[v]+dfs3(u,v));\n  }\n  //if(p==xyz) cout<<v<<\" \"<<res<<endl;\n  return res;\n}\npriority_queue<int> tmp;\nint ans=0;\nbool flag2=0;\nint dfs4(int v,int p){\n  //cout<<v<<\" \"<<p<<endl;\n  if(~memo[v]) return memo[v];\n  if(v==root){\n    flag2=1;\n    ans+=wei[v];\n    for(int u:T[v]) if(u!=p) tmp.push(dfs3(u,v));\n    return 0;\n  }\n  int res=wei[v];\n  for(int u:T[v]){\n    if(dele[u]||u==p) continue;\n    res=max(res,wei[v]+dfs4(u,v));\n    if(flag2){\n      ans+=wei[v];\n      for(int k:T[v])\n\tif(u!=k&&k!=p) tmp.push(dfs3(k,v));\n      break;\n    }\n  }\n  return memo[v]=res;\n}\nsigned main(){\n  int n,m;\n  cin>>n>>m;\n  G.clear();\n  G.resize(n);\n  int w[n];\n  for(int i=0;i<n;i++) cin>>w[i];\n  for(int i=0;i<m;i++){\n    int u,v;\n    cin>>u>>v;\n    u--;v--;\n    add_edge(u,v);\n  }\n  //puts(\"OK1\");\n  biconnectedgraph(n);\n  //puts(\"OK\");\n  root=-1;\n  for(int i=0;i<V;i++){\n    for(int j=0;j<(int)C[i].size();j++){\n      wei[i]+=w[C[i][j]];\n      //w[C[i][j]]=0;\n      if(j>0) root=i;\n      if(C[i][j]==0) xyz=i;\n    }\n    //if(C[i].size()>1) cout<<i<<\" \"<<C[i].size()<<\":\"<<wei[i]<<endl; \n    //cout<<i<<\":\"<<wei[i]<<endl;\n  }\n  //for(int i=0;i<n;i++) assert(!w[i]);\n  //cout<<C[xyz].size()<<\":\";for(int i:C[xyz]) cout<<\" \"<<i;cout<<endl;\n  //cout<<wei[xyz]<<endl;\n  if(~root){\n    dfs2(root,-1);\n    for(int i=0;i<V;i++) assert(used[i]);\n  }\n  //cout<<root<<\"-\"<<xyz<<endl;\n  if(root<0||root==xyz) cout<<dfs3(xyz,-1)<<endl;\n  else{\n    memset(memo,-1,sizeof(memo));\n    dfs4(xyz,-1);\n    if(!tmp.empty()) ans+=tmp.top();\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_N 100001\n#define N MAX_N\n#define rank dfasfds\nusing namespace std;\ntypedef long long ll;\ntypedef set<int> S;\nint par[MAX_N],rank[MAX_N];\nll val[MAX_N];\nS G[N];\n\nvoid init(int n){for(int i=0;i<n;i++)par[i]=i,rank[i]=0;}\n\nint find(int x){\n  if(par[x]==x)return x;\n  return par[x]=find(par[x]);\n}\n\nbool same(int x,int y){return find(x)==find(y);}\n\nvoid unite(int x,int y){\n  x=find(x),y=find(y);\n  if(x==y)return;\n  S::iterator it;\n  if(rank[x]<rank[y])par[x]=y,val[y]+=val[x];\n  else{\n    par[y]=x;\n    val[x]+=val[y];\n    if(rank[x]==rank[y])rank[x]++;\n  }\n}\n\n\n\n\nint used[N];\nvector<int> pass;\nvoid dfs(int pos,int pre){\n  if(pos!=find(pos))return;\n  if(used[pos]) {\n    for(int i=pass.size()-1;pass[i]!=pos;i--)unite(pos,pass[i]);\n    return;\n  }\n  used[pos]=1;\n  pass.push_back(pos);\n  for(S::iterator it=G[pos].begin();it!=G[pos].end();it++)if(*it!=pre)dfs(*it,pos);\n  used[pos]=0;\n  pass.pop_back();\n}\n\nvector<int>col[N];\nll get_mx(int pos,int pre){\n  if(used[find(pos)])return 0;\n  used[find(pos)]=1;\n  ll res=0;\n  for(int i=0;i<col[pos].size();i++)\n    for(S::iterator it=G[col[pos][i]].begin();it!=G[col[pos][i]].end();it++){\n      if(*it!=pre&&!same(*it,pos))res=max(res,get_mx(*it,pos));\n    }\n  return res+val[find(pos)];\n}\n\nint main(){\n  int n,m;\n  cin>>n>>m;\n  for(int i=0;i<n;i++) cin>>val[i];\n  for(int i=0,a,b;i<m;i++){\n    cin>>a>>b;a--,b--;\n    G[a].insert(b);\n    G[b].insert(a);\n  }\n  init(n);\n  dfs(0,-1);\n  for(int i=0;i<n;i++)col[find(i)].push_back(i);\n  cout <<get_mx(find(0),-1)<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n\n\n\n#define FOR(i,s,t) for(int (i)=(s);(i)<(t);(i)++)\nusing VI = vector<int>;\n/*-----------------------------------------------\n 二辺連結成分分解 成分だけ unverified\n -----------------------------------------------*/\nstruct UnionFind {\n    vector<int> data;\n    UnionFind(int n) { data.assign(n, -1); }\n    bool unionSet(int x, int y) {\n        x = root(x); y = root(y);\n        if (x != y) {\n            if (data[y] < data[x]) swap(x, y);\n            data[x] += data[y]; data[y] = x;\n        }\n        return x != y;\n    }\n    bool same(int x, int y) { return root(x) == root(y); }\n    int root(int x) { return data[x] < 0 ? x : data[x] = root(data[x]); }\n    int size(int x) { return -data[root(x)]; }\n};\n\n/* ---------------------------------\n Library:     Lowlink dfs\n Complexity:  O(V+E)\n Description: dfs木を作る過程で、巡回順ord,判定lowを更新\n 先にkを宣言して使う(grovalに置かないだけ)\n Art_Points()と一緒に使うことで橋と関節点を列挙可能\n Usege:       k=0, lowlink(0,-1,k,low,ord,used,G)\n Decision:    if(ord[v] < low[u]) (u, v) is a bridge\n if(v == root) if(nG[v].size() > 1) at  is an articulation point 根に2つ以上あれば\n else if(ord[v] <= low[u]) at  is an articulation point\n Variables:   v: nowV, p: preV, k: timer, ord: dfs order, low: lowlink, used: visited?, parent: parent.\n return:      なし\n Memo:        最小全域点カットが2以上とは関節点が存在しないことと同義\n --------------------------------- */\n\nstruct Lowlink {\n    UnionFind uf;\n    vector<int> low, ord, used, parent;\n    int root, k;\n    Lowlink(int V, int Root) :uf(V), low(V), ord(V), used(V), parent(V), root(Root), k(0) {}\n\n    void lowlink(int v, int p, int &k, vector<vector<int>>& G) {\n        used[v] = true; //visited\n        low[v] = ord[v] = k; k++;\n        for (int i = 0; i < (int)G[v].size(); i++) {\n            int u = G[v][i];\n            if (used[u] == 0) {\n                parent[u] = v;\n                lowlink(u, v, k, G);\n                low[v] = min(low[v], low[u]);\n                if (ord[v] >= low[u])uf.unionSet(v, u);\n            }\n            else if (u != p) {\n                low[v] = min(low[v], ord[u]);\n            }\n        }\n    }\n};\n/* ---------------------------------\n Library:     TwoEdgeConnectedComponent\n Complexity:  O(V+E)\n Description: 二辺連結成分分解(2より小さい数の辺を取り除いても連結であるようなグラフ->橋を含まない部分グラフ)\n Usege:       TwoEdgeConnectedComponent(G,points,bridges)\n Decision:    判定はlowlinkを参照\n Variables:   ,\n Memo:        need LowLink\n --------------------------------- */\nusing LL = long long;\nusing PLL = pair<LL, LL>;\nstruct TwoEdgeConnectedComponent{\n    vector<pair<int, int> > edges;\n    vector<int> comp; // components\n    int V,Root;\n    TwoEdgeConnectedComponent(int V, int Root):comp(V),V(V),Root(Root) {}\n\n    void get_graph(vector<vector<int> >& ResGraph, vector<vector<int> >& G, VI& w, VI& compW) {\n        //Lowlink::lowlink(root, -1, k, G);\n//        lowlink(root, -1, k, G);\n        Lowlink Ll(V,Root);\n        int k = 0;\n        Ll.lowlink(Root, -1, k, G);\n        auto uf = Ll.uf;\n        int ptr = 0;\n        vector<int> color((int)G.size());\n        for (int i = 0; i < (int)G.size(); i++) {\n            if (i == uf.root(i))color[i] = ptr++;\n        }\n        ResGraph.resize(ptr);\n        compW.resize(ptr);\n        for (int i = 0; i < (int)G.size(); i++) {\n            comp[i] = color[uf.root(i)];\n            // 頂点番号における写像を作る\n            compW[comp[i]] += w[i];//重みをまとめる\n        }\n        for (int v = 0; v < (int)G.size(); v++) {// O(E)\n            for (int i = 0; i < (int)G[v].size(); i++) {\n                int u = G[v][i];\n                int c1 = comp[v], c2 = comp[u];\n                if (c1 == c2)continue;// 異なる成分に辺をはる\n                ResGraph[c1].push_back(c2);\n                ResGraph[c2].push_back(c1);\n            }\n        }\n    }\n};\n\n#define SZ(a) (int)a.size()\nusing VVI = vector<VI>;\nusing VL = vector<LL>;\nLL dfs(int v, int p, VVI& G, VL& dp, VI& w) {\n\n    LL res = 0;\n    FOR(i, 0, SZ(G[v])) {\n        int nx = G[v][i];\n        if (nx == p)continue;\n        res = max(res, dfs(nx, v, G, dp, w));\n    }\n    return dp[v] = res + w[v];\n}\n\n\nint main() {\n    int N, M; cin >> N >> M;\n    VI w(N);\n    FOR(i, 0, N) {\n        cin >> w[i];\n    }\n\n    vector<VI>G(N);\n    FOR(i, 0, M) {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;;\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n    // 木にする このときに頂点に重みを集結させる\n    TwoEdgeConnectedComponent gx(SZ(G), 0);\n    vector<vector<int>>resG;\n    VI resW;\n    gx.get_graph(resG, G, w, resW); // new Graph id -> w[id]でできる\n    //ここまでCC\n\n    // ここから木DP\n    // pathを選択\n    VL dp(N, 0);\n    LL ans = dfs(0, -1, resG, dp, resW);\n    cout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n,m;\nvector<int>e[100005];\nvector<int>edge[100005];\nint used[100005];\nint w[100005],k;\nvector<int>E[100005];\nll W[100005];\nint in[100005];\nll dp[100005];\nint cnt[100005],c[100005];\nint par[100005],ran[100005];\nll ans,add;\nvoid init(){ for(int i=0;i<100005;i++) par[i] = i; }\nint find(int x){ if(x == par[x]) return x; else return par[x] = find(par[x]); }\nvoid unite(int x,int y){\n\tx = find(x); y = find(y); if(x==y) return;\n\tif(ran[x] < ran[y]) par[x] = y;\n\telse{\n\t\tpar[y] = x;\n\t\tif(ran[x] == ran[y]) ran[x]++;\n\t}\n}\nbool same(int x,int y){ return find(x)==find(y); }\nvoid dfs(int v,int u,int d){\n\tused[v] = d;//cout << v << endl;\n\tfor(int i=0;i<e[v].size();i++){\n\t\tif(e[v][i] == u) continue;\n\t\tif(used[e[v][i]] && used[e[v][i]] < used[v]){\n\t\t\tcnt[e[v][i]]--;\n\t\t\tcnt[v]++;\n\t\t\tunite(e[v][i],v);\n\t\t\t//cout << v << \" \" << e[v][i] << endl;\n\t\t\tcontinue;\n\t\t}\n\t\telse if(used[e[v][i]]) continue;\n\t\tdfs(e[v][i],v,d+1); edge[v].pb(e[v][i]); //cout << v << \" \" << e[v][i] << endl;\n\t}\n}\nint dfs2(int v,int u){\n\tint sum = 0;\n\tfor(int i=0;i<edge[v].size();i++){\n\t\tint a = dfs2(edge[v][i],v);\n\t\tif(a>0){\n\t\t    //cout << edge[v][i] << \" f\" << v << endl;\n\t\t\tunite(edge[v][i],v);\n\t\t}\n\t\tsum += a;\n\t}\n\tsum += cnt[v];\n\treturn sum;\n}\npair<ll,bool> dfs(int v=0,int p=-1){\n\tll ret = 0; bool ok = (c[v] >= 2);\n\tfor(int i=0;i<E[v].size();i++){\n\t\tif(E[v][i] == p) continue;\n\t\tpair<ll,bool> t = dfs(E[v][i],v);\n\t\tret = max(ret,t.fi);\n\t\tok |= t.sc;\n\t}\n\tif(ok){\n\t\tret = 0;\n\t\tans += W[v];\n\t}\n\telse ret += W[v];\n\tadd = max(add,ret);\n\treturn mp(ret,ok);\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=0;i<n;i++) scanf(\"%d\",&w[i]);\n\tfor(int i=0;i<m;i++){\n\t\tint a,b; scanf(\"%d%d\",&a,&b); a--; b--;\n\t\te[a].push_back(b);\n\t\te[b].push_back(a);\n\t}\n\tinit(); dfs(0,-1,1); dfs2(0,-1);\n\tfor(int i=0;i<n;i++){\n\t\tW[find(i)] += w[i];\n\t\tc[find(i)] ++;\n\t\tfor(int j=0;j<e[i].size();j++){\n\t\t\tif(find(i) != find(e[i][j])){\n\t\t\t\tE[find(i)].pb(find(e[i][j]));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tSORT(E[i]); ERASE(E[i]);\n\t}\n\tdfs(0,-1);\n\tcout << ans+add << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_V 100000\nusing namespace std;\ntypedef pair<int,int> P;\nint n,m,w[100001];\nvector<int> v[100001],v1[100001];\nset<P> st;\nint V;\nvector<int> G[MAX_V];\nvector<int> rG[MAX_V];\nvector<int> vs;\nbool used[MAX_V];\nint cmp[MAX_V];\n\nvoid DFS(int p){\n  for(int i=0;i<v[p].size();i++){\n    P pp=P(min(v[p][i],p),max(v[p][i],p));\n    if(st.find(pp)==st.end()){\n      st.insert(pp);\n      G[p].push_back(v[p][i]);\n      rG[v[p][i]].push_back(p);\n      DFS(v[p][i]);\n    }\n  }\n}\n\nvoid dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++)if(!used[G[v][i]])dfs(G[v][i]);\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v]=true;\n  cmp[v]=k;\n  for(int i=0;i<rG[v].size();i++)if(!used[rG[v][i]])rdfs(rG[v][i],k);\n}\n\nint scc(){\n  memset(used,0,sizeof(used));\n  vs.clear();\n  for(int v=0;v<V;v++)if(!used[v])dfs(v);\n  memset(used,0,sizeof(used));\n  int k=0;\n  for(int i=vs.size()-1;i>=0;i--)if(!used[vs[i]])rdfs(vs[i],k++);\n  return k;\n}\n\nint C[100001],F[100001],U[100001],ans;\nbool UU[100001];\n\nbool DFS1(int p){\n  if(U[p])return 0;\n  U[p]=1;\n  bool f=F[cmp[p]]>=2;\n  for(int i=0;i<G[p].size();i++)\n    f=max(f,DFS1(G[p][i]));\n  ans+=w[p]*f;\n  return UU[p]=f;\n}\n\nint DFS2(int p){\n  if(UU[p])return 0;\n  UU[p]=1;\n  int res=0;\n  for(int i=0;i<v[p].size();i++)\n    res+=DFS2(v[p][i]);\n  return w[p]+res;\n}\n\nint main(){\n  cin>>V>>m;\n  for(int i=0;i<V;i++)cin>>w[i];\n  for(int j=0,a,b;j<m;j++){\n    cin>>a>>b;a--,b--;\n    v[a].push_back(b),v[b].push_back(a);\n  }\n  DFS(0);\n  scc();\n  for(int i=0;i<V;i++)F[cmp[i]]++;\n  DFS1(0);\n  int mx=0;\n  for(int i=0;i<V;i++)\n    if(!UU[i])mx=max(mx,DFS2(i));\n  \n  cout<<ans+mx<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);++i)\n#define rep2(i,a,b) for (int i=(a);i<(b);++i)\n#define rrep(i,n) for (int i=(n)-1;i>=0;--i)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;--i)\n#define chmin(a,b) (a)=min((a),(b));\n#define chmax(a,b) (a)=max((a),(b));\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) cout<<(#v)<<\":\";for(auto(x):(v)){cout<<\" \"<<(x);}cout<<endl;\n#define printVS(vs) cout<<(#vs)<<\":\"<<endl;for(auto(s):(vs)){cout<<(s)<< endl;}\n#define printVV(vv) cout<<(#vv)<<\":\"<<endl;for(auto(v):(vv)){for(auto(x):(v)){cout<<\" \"<<(x);}cout<<endl;}\n#define printP(p) cout<<(#p)<<(p).first<<\" \"<<(p).second<<endl;\n#define printVP(vp) cout<<(#vp)<<\":\"<<endl;for(auto(p):(vp)){cout<<(p).first<<\" \"<<(p).second<<endl;}\n\ninline void output(){ cout << endl; }\ntemplate<typename First, typename... Rest>\ninline void output(const First& first, const Rest&... rest) {\n    cout << first << \" \"; output(rest...);\n}\n\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing TUPLE = tuple<int, int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\nusing Graph = vector<vector<int>>;\n\ntypedef vector<vector<int>> Graph;\ntypedef pair<int, int> Edge; // (a < b: undirected)\n\nvi w;\nvi wcmp;\n\nclass BICC {\nprivate:\n    const int n;\n\n    Graph G;\n    vector<int> depth;\n    vector<int> par;\n    map<Edge, int> imosEdge;\n    map<Edge, int> EdgeType;\n    enum {UNUSED, USED_DFS, BRIDGE};\n    vector<Edge> bridges;\n\n\tvector<int> cmp;\n\tint num_cc;\n\tvector<int> size_of_vertex;\n\tGraph G_cc;\npublic:\n    BICC(int _n) : n(_n), G(_n), depth(_n, -1), par(_n, -1), cmp(_n, -1), num_cc(0) {}\n    Edge getEdge(int a, int b) {\n        if (a > b) swap(a, b);\n        return Edge(a, b);\n    }\n    void updateEdgeType(int a, int b, int type) {\n        if (a < 0 || b < 0) return;\n        EdgeType[getEdge(a, b)] = type;\n    }\n    void addEdge(int a, int b) {\n        G[a].emplace_back(b);\n        G[b].emplace_back(a);\n        updateEdgeType(a, b, UNUSED);\n    }\n    void dfsTreeConstruct(int v, int pre) {\n        if (depth[v] != -1) return;\n        depth[v] = (pre == -1 ? 0 : depth[pre] + 1);\n        par[v] = pre;\n        updateEdgeType(pre, v, USED_DFS);\n        for (auto&& nxt : G[v]) {\n            if (nxt != pre) dfsTreeConstruct(nxt, v);\n        }\n    }\n    void updateImos(int a, int b) {\n        if (depth[a] < depth[b]) swap(a, b);\n\n        if (par[a] != -1) {\n            imosEdge[getEdge(a, par[a])]++;\n        }\n        if (par[b] != -1) {\n            imosEdge[getEdge(b, par[b])]--;\n        }\n    }\n    int imosFinal(int v, int pre) {\n        int t = 0;\n        for (auto&& nxt : G[v]) {\n            if (nxt != pre && EdgeType[getEdge(nxt, v)] == USED_DFS) {\n                t += imosFinal(nxt, v);\n            }\n        }\n        if (pre != -1) imosEdge[getEdge(v, pre)] += t;\n        return pre == -1 ? 0 : imosEdge[getEdge(v, pre)];\n    }\n    int extractCC(int v, int color) {\n    \tif (cmp[v] != -1) return 0;\n    \tcmp[v] = color;\n    \tint t = 1;\n    \tfor (auto&& nxt : G[v]) {\n    \t\tif (EdgeType[getEdge(v, nxt)] != BRIDGE) {\n    \t\t\tt += extractCC(nxt, color);\n    \t\t}\n    \t}\n    \treturn t;\n    }\n    tuple<Graph, vector<int>, vector<int>> bicc() {\n        dfsTreeConstruct(0, -1);\n        for (auto&& p : EdgeType) {\n            Edge e;\n            int type;\n            tie(e, type) = p;\n            if (type == UNUSED) {\n                updateImos(e.first, e.second);\n            }\n        }\n        imosFinal(0, -1);\n        for (auto&& p : EdgeType) {\n            Edge e;\n            int type;\n            tie(e, type) = p;\n            if (type == USED_DFS) {\n                if (imosEdge[e] == 0) {\n                    EdgeType[e] = BRIDGE;\n                    bridges.emplace_back(e);\n                }\n            }\n        }\n\n\t\trep(i, n) {\n\t\t\tint size_cc = extractCC(i, num_cc);\n\t\t\tif (size_cc > 0) {\n\t\t\t\tsize_of_vertex.emplace_back(size_cc);\n\t\t\t\tnum_cc++;\n\t\t\t}\n\t\t}\n\n        // for this problem\n        wcmp.resize(num_cc);\n        rep(i, n) {\n            wcmp[cmp[i]] += w[i];\n        }\n\n\t \tvector<set<int>> G_cc_st(num_cc);\n\t\tfor (auto&& p : EdgeType) {\n            Edge e;\n            int type;\n            tie(e, type) = p;\n            if (type == BRIDGE) {\n\t\t\t\tG_cc_st[cmp[e.first]].insert(cmp[e.second]);\n\t\t\t\tG_cc_st[cmp[e.second]].insert(cmp[e.first]);\n            }\n        }\n\n\t\trep(i, num_cc) {\n\t\t\tG_cc.emplace_back(vector<int>(all(G_cc_st[i])));\n\t\t}\n\n        return make_tuple(G_cc, size_of_vertex, cmp);\n    }\n    vector<Edge> getBridges() {\n        return bridges;\n    }\n};\n\nGraph G;\nvi sz;\nvi cmp;\nint s;\nvector<int> cand;\nvector<bool> red;\n\nbool dfs(int now, int pre) {\n    bool ch_red = (now == s || sz[now] >= 2);\n    for (auto nxt : G[now]) {\n        if (nxt == pre) continue;\n        ch_red |= dfs(nxt, now);\n    }\n    return red[now] = ch_red;\n}\n\n// bool makeRed(int now, int pre) {\n//     if (red[now]) return true;\n//     for (auto nxt : G[now]) {\n//         if (nxt == pre) continue;\n//         makeRed(nxt, now);\n//     }\n// }\n\nvoid dfs2(int now, int pre, int sm) {\n    if (!red[now]) sm += wcmp[now];\n    if ((int)G[now].size() == 1 && !red[now]) {\n        cand.emplace_back(sm);\n        return;\n    }\n\n    for (auto nxt : G[now]) {\n        if (nxt == pre) continue;\n        dfs2(nxt, now, sm);\n    }\n}\n\nmain() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int n, m;\n    cin >> n >> m;\n    w.resize(n);\n    rep(i, n) cin >> w[i];\n    BICC bicc(n);\n    rep(i, m) {\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        bicc.addEdge(u, v);\n    }\n\n    tie(G, sz, cmp) = bicc.bicc();\n    int s = cmp[0];\n    int num_cc = sz.size();\n    red.resize(num_cc);\n    // int tmp_par = -1;\n    // rep(i, sz.size()) {\n    //     if (sz[i] >= 2) tmp_par = i;\n    // }\n    // isred(tmp_par, -1);\n    dfs(s, -1);\n\n    // path(1 -> red) -> red\n    // makeRed(cmp[s], -1);\n\n    int sm_red = 0;\n    rep(i, n) {\n        if (red[cmp[i]]) {\n            sm_red += w[i];\n        }\n    }\n\n    dfs2(s, -1, 0);\n    int ma_path = *max_element(all(cand));\n\n    cout << sm_red + ma_path << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,s,t) for(int (i)=(s);(i)<(t);(i)++)\nusing VI = vector<int>;\n/*-----------------------------------------------\n二辺連結成分分解 成分だけ unverified\n-----------------------------------------------*/\nstruct UnionFind {\n\tvector<int> data;\n\tUnionFind(int n) { data.assign(n, -1); }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool same(int x, int y) { return root(x) == root(y); }\n\tint root(int x) { return data[x] < 0 ? x : data[x] = root(data[x]); }\n\tint size(int x) { return -data[root(x)]; }\n};\n\n/* ---------------------------------\nLibrary:     Lowlink dfs\nComplexity:  O(V+E)\nDescription: dfs木を作る過程で、巡回順ord,判定lowを更新\n先にkを宣言して使う(grovalに置かないだけ)\nArt_Points()と一緒に使うことで橋と関節点を列挙可能\nUsege:       k=0, lowlink(0,-1,k,low,ord,used,G)\nDecision:    if(ord[v] < low[u]) (u, v) is a bridge\nif(v == root) if(nG[v].size() > 1) at  is an articulation point 根に2つ以上あれば\nelse if(ord[v] <= low[u]) at  is an articulation point\nVariables:   v: nowV, p: preV, k: timer, ord: dfs order, low: lowlink, used: visited?, parent: parent.\nreturn:      なし\nMemo:        最小全域点カットが2以上とは関節点が存在しないことと同義\n--------------------------------- */\n\nstruct Lowlink {\n\tUnionFind uf;\n\tvector<int> low, ord, used, parent;\n\tint root, k;\n\tLowlink(int V, int Root) :uf(V), low(V), ord(V), used(V), parent(V), root(Root), k(0) {}\n\n\tvoid lowlink(int v, int p, int &k, vector<vector<int>>& G) {\n\t\tused[v] = true; //visited\n\t\tlow[v] = ord[v] = k; k++;\n\t\tfor (int i = 0; i < (int)G[v].size(); i++) {\n\t\t\tint u = G[v][i];\n\t\t\tif (used[u] == 0) {\n\t\t\t\tparent[u] = v;\n\t\t\t\tlowlink(u, v, k, G);\n\t\t\t\tlow[v] = min(low[v], low[u]);\n\t\t\t\tif (ord[v] >= low[u])uf.unionSet(v, u);\n\t\t\t}\n\t\t\telse if (u != p) {\n\t\t\t\tlow[v] = min(low[v], ord[u]);\n\t\t\t}\n\t\t}\n\t}\n};\n/* ---------------------------------\nLibrary:     TwoEdgeConnectedComponent\nComplexity:  O(V+E)\nDescription: 二辺連結成分分解(2より小さい数の辺を取り除いても連結であるようなグラフ->橋を含まない部分グラフ)\nUsege:       TwoEdgeConnectedComponent(G,points,bridges)\nDecision:    判定はlowlinkを参照\nVariables:   ,\nMemo:        need LowLink\n--------------------------------- */\nusing LL = long long;\nusing PLL = pair<LL, LL>;\nstruct TwoEdgeConnectedComponent : Lowlink {\n\tvector<pair<int, int> > edges;\n\tvector<int> comp; // components\n\tTwoEdgeConnectedComponent(int V, int Root) :Lowlink(V, Root), comp(V) {}\n\n\tvoid get_graph(vector<vector<int> >& ResGraph, vector<vector<int> >& G, VI& w, VI& compW) {\n\t\tLowlink::lowlink(root, -1, k, G);\n\t\tint ptr = 0;\n\t\tvector<int> color((int)G.size());\n\t\tfor (int i = 0; i < (int)G.size(); i++) {\n\t\t\tif (i == uf.root(i))color[i] = ptr++;\n\t\t}\n\t\tResGraph.resize(ptr);\n\t\tcompW.resize(ptr);\n\t\tfor (int i = 0; i < (int)G.size(); i++) {\n\t\t\tcomp[i] = color[uf.root(i)];\n\t\t\t// 頂点番号における写像を作る\n\t\t\tcompW[comp[i]] += w[i];//重みをまとめる\n\t\t}\n\t\tfor (int v = 0; v < (int)G.size(); v++) {// O(E)\n\t\t\tfor (int i = 0; i < (int)G[v].size(); i++) {\n\t\t\t\tint u = G[v][i];\n\t\t\t\tint c1 = comp[v], c2 = comp[u];\n\t\t\t\tif (c1 == c2)continue;// 異なる成分に辺をはる\n\t\t\t\tResGraph[c1].push_back(c2);\n\t\t\t\tResGraph[c2].push_back(c1);\n\t\t\t}\n\t\t}\n\t}\n};\n\n#define SZ(a) (int)a.size()\nusing VVI = vector<VI>;\nusing VL = vector<LL>;\nLL dfs(int v, int p, VVI& G, VL& dp, VI& w) {\n\n\tLL res = 0;\n\tFOR(i, 0, SZ(G[v])) {\n\t\tint nx = G[v][i]; \n\t\tif (nx == p)continue;\n\t\tres = max(res, dfs(nx, v, G, dp, w));\n\t}\n\treturn dp[v] = res + w[v];\n}\n\n\nint main() {\n\tint N, M; cin >> N >> M;\n\tVI w(N);\n\tFOR(i, 0, N) {\n\t\tcin >> w[i];\n\t}\n\n\tvector<VI>G(N);\n\tFOR(i, 0, M) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--, b--;;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\t// 木にする このときに頂点に重みを集結させる\n\tTwoEdgeConnectedComponent gx(SZ(G), 0);\n\tvector<vector<int>>resG;\n\tVI resW;\n\tgx.get_graph(resG, G, w, resW); // new Graph id -> w[id]でできる\n\t//ここまでCC\n\n\t// ここから木DP\n\t// pathを選択\n\tVL dp(N, 0);\n\tLL ans = dfs(0, -1, resG, dp, resW);\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_V 100000\nusing namespace std;\nint m,w[100001];\nvector<int> vv[100001];\nint S[100001];\nint V;\nvector<int> G[MAX_V];\nvector<int> rG[MAX_V];\nvector<int> vs;\nbool used[MAX_V];\nint cmp[MAX_V];\nint C[100001],F[100001],U[100001],ans;\nbool UU[100001];\n\nvoid DFS(int p,int pr){\n  if(S[p]++)return;\n  for(int i=0;i<vv[p].size();i++){\n    int np=vv[p][i];\n    if(pr!=np){\n      G[p].push_back(np);\n      rG[np].push_back(p);\n      DFS(np,p);\n    }\n  }\n}\n\nvoid dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++)if(!used[G[v][i]])dfs(G[v][i]);\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v]=true;\n  cmp[v]=k;\n  for(int i=0;i<rG[v].size();i++)if(!used[rG[v][i]])rdfs(rG[v][i],k);\n}\n\nint scc(){\n  for(int v=0;v<V;v++)if(!used[v])dfs(v);\n  memset(used,0,sizeof(used));\n  int k=0;\n  for(int i=vs.size()-1;i>=0;i--)if(!used[vs[i]])rdfs(vs[i],k++);\n  return k;\n}\n\nbool DFS1(int p){\n  if(U[p])return 0;\n  U[p]=1;\n  bool f=F[cmp[p]]>=2;\n  for(int i=0;i<G[p].size();i++)\n    f|=DFS1(G[p][i]);\n  ans+=w[p]*f;\n  return UU[p]=f;\n}\nbool UUU[100001];\nint DFS2(int p){\n  if(UUU[p])return 0;\n  UUU[p]=1;\n  int res=0;\n  \n  for(int i=0;i<G[p].size();i++)\n    res=max(res,DFS2(G[p][i]));  \n  return res+(UU[p]?0:w[p]);\n}\n\nint main(){\n  cin>>V>>m;\n  for(int i=0;i<V;i++)cin>>w[i];\n  for(int j=0,a,b;j<m;j++){\n    cin>>a>>b;a--,b--;\n    vv[a].push_back(b),vv[b].push_back(a);\n  }\n  DFS(0,-1);\n  int t=0;\n  for(int i=0;i<V;i++)t+=w[i];\n  scc();\n  for(int i=0;i<V;i++)F[cmp[i]]++;\n  DFS1(0);\n  cout<<ans+DFS2(0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_N 100011\n#define N MAX_N\n#define rank dfasfds\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> S;\nint par[MAX_N],rank[MAX_N];\nll val[MAX_N];\nS G[N];\n\nvoid init(int n){for(int i=0;i<N;i++)par[i]=i,rank[i]=0;}\n\nint find(int x){\n  if(par[x]==x)return x;\n  return par[x]=find(par[x]);\n}\n\nbool same(int x,int y){return find(x)==find(y);}\n\nvoid unite(int x,int y){\n  x=find(x),y=find(y);\n  if(x==y)return;\n  if(rank[x]<rank[y])par[x]=y,val[y]+=val[x];\n  else{\n    par[y]=x;\n    val[x]+=val[y];\n    if(rank[x]==rank[y])rank[x]++;\n  }\n}\n\nint used[N];\nvector<int> path;\nvoid dfs(int pos,int pre){\n  if(used[pos]||pos!=find(pos)) {\n    while(path.size())unite(0,path.back()),path.pop_back();\n    return;\n  }\n  used[pos]=1;\n  path.push_back(pos);\n\n  for(S::iterator it=G[pos].begin();it!=G[pos].end();it++)if(*it!=pre)dfs(*it,pos);\n  used[pos]=0;\n  if(path.size()&&path.back()==pos) path.pop_back();\n}\n\nvector<int>col[N];\nll get_mx(int pos){\n  pos=find(pos);\n  used[pos]=1;\n  ll res=0;\n  \n  for(int i=0;i<col[pos].size();i++)\n    for(S::iterator it=G[col[pos][i]].begin();it!=G[col[pos][i]].end();it++)\n      if(!used[find(*it)])res=max(res,get_mx(find(*it)));\n  return res+val[find(pos)];\n}\n\nint main(){\n  int n,m;\n  cin>>n>>m;\n  for(int i=0;i<n;i++) cin>>val[i];\n  for(int i=0,a,b;i<m;i++){\n    cin>>a>>b;a--,b--;\n    G[a].push_back(b);\n    G[b].push_back(a);\n\n    //    G[a].insert(b);\n    //  G[b].insert(a);\n  }\n  init(n);\n  dfs(0,-1);\n  for(int i=0;i<n;i++) col[find(i)].push_back(i);\n  cout <<get_mx(find(0))<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_N 100011\n#define N MAX_N\n#define rank dfasfds\nusing namespace std;\ntypedef long long ll;\ntypedef unordered_set<int> S;\nint par[MAX_N],rank[MAX_N];\nll val[MAX_N];\nS G[N];\n\nvoid init(int n){for(int i=0;i<N;i++)par[i]=i,rank[i]=0;}\n\nint find(int x){\n  if(par[x]==x)return x;\n  return par[x]=find(par[x]);\n}\n\nbool same(int x,int y){return find(x)==find(y);}\n\nvoid unite(int x,int y){\n  x=find(x),y=find(y);\n  if(x==y)return;\n  if(rank[x]<rank[y])par[x]=y,val[y]+=val[x];\n  else{\n    par[y]=x;\n    val[x]+=val[y];\n    if(rank[x]==rank[y])rank[x]++;\n  }\n}\n\nint used[N];\nvector<int> path;\nvoid dfs(int pos,int pre){\n  if(used[pos]||pos!=find(pos)) {\n    for(int i=0;i<path.size();i++)unite(pos,path[i]);\n    return;\n  }\n  used[pos]=1;\n  path.push_back(pos);\n  for(S::iterator it=G[pos].begin();it!=G[pos].end();it++)if(*it!=pre)dfs(*it,pos);\n  used[pos]=0;\n  path.pop_back();\n}\n\nvector<int>col[N];\nll get_mx(int pos){\n  pos=find(pos);\n  used[pos]=1;\n  ll res=0;\n  \n  for(int i=0;i<col[pos].size();i++)\n    for(S::iterator it=G[col[pos][i]].begin();it!=G[col[pos][i]].end();it++)\n      if(!used[find(*it)])res=max(res,get_mx(find(*it)));\n  return res+val[find(pos)];\n}\n\nint main(){\n  int n,m;\n  cin>>n>>m;\n  for(int i=0;i<n;i++) cin>>val[i];\n  for(int i=0,a,b;i<m;i++){\n    cin>>a>>b;a--,b--;\n    G[a].insert(b);\n    G[b].insert(a);\n  }\n  init(n);\n  dfs(0,-1);\n  for(int i=0;i<n;i++) col[find(i)].push_back(i);\n  cout <<get_mx(find(0))<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define MAX_V 111111\ntypedef pair<int,int> P;\nvector<int> G[MAX_V],C[MAX_V],T[MAX_V],ord,low,belong;\nvector<P> B;\nbool is_bridge(int u,int v){\n  if(ord[u]>ord[v]) swap(u,v);\n  return ord[u]<low[v];\n}\nvoid dfs(int u,int p,int &k){\n  ord[u]=low[u]=k;\n  ++k;\n  for(int i=0;i<(int)G[u].size();i++){\n    int v=G[u][i];\n    if(v==p) continue;\n    if(ord[v]>=0){\n      low[u]=min(low[u],ord[v]);\n    }else{\n      dfs(v,u,k);\n      low[u]=min(low[u],low[v]);\n    }\n    if(is_bridge(u,v)) B.push_back(P(u,v));\n  }\n}\nvoid fill_component(int c,int u){\n  C[c].push_back(u);\n  belong[u]=c;\n  for(int i=0;i<(int)G[u].size();i++){\n    int v=G[u][i];\n    if(belong[v]>=0||is_bridge(u,v)) continue;\n    fill_component(c,v);\n  }\n}\nvoid add_component(int u,int &k){\n  if(belong[u]>=0) return;\n  fill_component(k++,u);\n}\nvoid biconnectedgrapth(int n){\n  int k=0;\n  ord.resize(n,-1);\n  low.resize(n);\n  belong.resize(n,-1);\n  //cout<<n<<endl;\n  for(int v=0;v<n;v++){\n    if(ord[v]>=0) continue;\n    dfs(v,-1,k);\n  }\n  //cout<<k<<endl;\n  k=0;\n  for(int i=0;i<(int)B.size();i++){\n    add_component(B[i].first,k);\n    add_component(B[i].second,k);\n  }\n  add_component(0,k);\n  //cout<<k<<endl;\n  for(int i=0;i<(int)B.size();i++){\n    int u=belong[B[i].first],v=belong[B[i].second];\n    T[u].push_back(v);\n    T[v].push_back(u);\n  }\n}\nvoid add_edge(int u,int v){\n  G[u].push_back(v);\n  G[v].push_back(u);\n}\n\nint W[MAX_V];\n\nint dfs2(int u,int p){\n  int res=0;\n  for(int i=0;i<(int)T[u].size();i++){\n    int v=T[u][i];\n    if(v==p) continue;\n    res=max(res,dfs2(v,u));\n  }\n  return W[u]+res;\n}\nsigned main(){\n  int n,m;\n  cin>>n>>m;\n  int w[n];\n  for(int i=0;i<n;i++) cin>>w[i];\n  for(int i=0;i<m;i++){\n    int u,v;\n    cin>>u>>v;\n    add_edge(u-1,v-1);\n  }\n  biconnectedgrapth(n);\n  //puts(\"a\");\n  for(int i=0;i<n;i++) W[belong[i]]+=w[i];\n  cout<<dfs2(belong[0],-1)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct UnionFind\n{\n  vector< int > data;\n\n  UnionFind(int sz)\n  {\n    data.assign(sz, -1);\n  }\n\n  bool unite(int x, int y)\n  {\n    x = find(x), y = find(y);\n    if(x == y) return (false);\n    if(data[x] > data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n    return (true);\n  }\n\n  int find(int k)\n  {\n    if(data[k] < 0) return (k);\n    return (data[k] = find(data[k]));\n  }\n\n  int size(int k)\n  {\n    return (-data[find(k)]);\n  }\n};\n\nstruct BiConnectedComponents\n{\n  UnionFind uf;\n  vector< vector< int > > g;\n  vector< pair< int, int > > edges;\n  vector< int > used, ord, low, comp;\n\n  BiConnectedComponents(size_t v) : uf(v), g(v), used(v, 0), comp(v), ord(v), low(v)\n  {\n  }\n\n  void add_edge(int x, int y)\n  {\n    g[x].push_back(y);\n    g[y].push_back(x);\n    edges.push_back(minmax(x, y));\n  }\n\n  void dfs(int idx, int &k, int par = -1)\n  {\n    used[idx] = true;\n    ord[idx] = k++;\n    low[idx] = ord[idx];\n\n    for(auto &to : g[idx]) {\n      if(!used[to]) {\n        dfs(to, k, idx);\n        low[idx] = min(low[idx], low[to]);\n        if(ord[idx] >= low[to]) uf.unite(idx, to);\n      } else if(to != par) {\n        low[idx] = min(low[idx], ord[to]);\n      }\n    }\n  }\n\n  int operator[](int k)\n  {\n    return (comp[k]);\n  }\n\n  size_t size()\n  {\n    return (g.size());\n  }\n\n  void build(vector< vector< int > > &t)\n  {\n    int kk = 0;\n    dfs(0, kk);\n\n    int ptr = 0;\n    vector< int > cc(g.size());\n    for(int i = 0; i < g.size(); i++) {\n      if(i == uf.find(i)) cc[i] = ptr++;\n    }\n\n    t.resize(ptr);\n    for(int i = 0; i < g.size(); i++) {\n      comp[i] = cc[uf.find(i)];\n    }\n    for(auto &e : edges) {\n      int x = comp[e.first], y = comp[e.second];\n      if(x == y) continue;\n      t[x].push_back(y);\n      t[y].push_back(x);\n    }\n  }\n};\n\nint N, M, W[100000];\nvector< vector< int > > g;\nvector< int > weightSum, sz;\nint dp1[100000], dp2[100000];\nbool turn[100000];\n\nint rec(int idx, int par = -1)\n{\n  int ret = 0;\n\n  for(auto &to : g[idx]) {\n    if(to == par) continue;\n    ret = max(ret, rec(to, idx));\n    dp2[idx] = max(dp2[idx], dp2[to]);\n    dp1[idx] += dp1[to];\n  }\n  dp2[idx] += weightSum[idx];\n  if(sz[idx] >= 3 || dp1[idx] > 0) dp1[idx] += weightSum[idx];\n\n  for(auto &to : g[idx]) {\n    if(to == par) continue;\n    ret = max(ret, dp1[idx] - dp1[to] + dp2[to]);\n  }\n  return (max(dp2[idx], ret));\n}\n\nint main()\n{\n  cin >> N >> M;\n  BiConnectedComponents tree(N);\n  for(int i = 0; i < N; i++) {\n    cin >> W[i];\n  }\n  while(M--) {\n    int U, V;\n    cin >> U >> V;\n    tree.add_edge(--U, --V);\n  }\n  tree.build(g);\n  weightSum.assign(g.size(), 0);\n  sz.assign(g.size(), 0);\n  for(int i = 0; i < N; i++) {\n    weightSum[tree[i]] += W[i];\n    sz[tree[i]]++;\n  }\n  cout << rec(tree[0]) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nstruct Edge {\n\tint from, to;\n\tEdge(int f, int t) : from(f), to(t) {}\n};\n\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\n\npair<vector<int>, Edges> bridge(const Graph& g) {\n\tconst int n = g.size();\n\tint idx = 0, s = 0, t = 0, k = 0;\n\tvector<int>ord(n, -1), onS(n), stk(n), roots(n), cmp(n);\n\tEdges brdg;\n\tfunction<void(int, int)> dfs = [&](int v, int u) {\n\t\tord[v] = idx++;\n\t\tstk[s++] = v;\n\t\tonS[v] = true;\n\t\troots[t++] = v;\n\t\tfor (auto& e : g[v]) {\n\t\t\tint w = e.to;\n\t\t\tif (ord[w] == -1)dfs(w, v);\n\t\t\telse if (u != w && onS[w])\n\t\t\t\twhile (ord[roots[t - 1]]>ord[w])--t;\n\t\t}\n\t\tif (v == roots[t - 1]) {\n\t\t\tbrdg.emplace_back(u, v);\n\t\t\twhile (true) {\n\t\t\t\tint w = stk[--s];\n\t\t\t\tonS[w] = false;\n\t\t\t\tcmp[w] = k;\n\t\t\t\tif (v == w)break;\n\t\t\t}\n\t\t\t--t;\n\t\t\t++k;\n\t\t}\n\t};\n\tfor (int u = 0; u<n; ++u) {\n\t\tif (ord[u] == -1) {\n\t\t\tdfs(u, n);\n\t\t\tbrdg.pop_back();\n\t\t}\n\t}\n\treturn make_pair(cmp, brdg);\n}\n\nclass HLDecomposition {\n\tvector<vector<int>> g;\n\tvector<int> vid, head, heavy, parent, depth, inv;\n\tint dfs(int curr, int prev) {\n\t\tparent[curr] = prev;\n\t\tint sub = 1, max_sub = 0;\n\t\tfor (int next : g[curr]) if (next != prev) {\n\t\t\tdepth[next] = depth[curr] + 1;\n\t\t\tint sub_next = dfs(next, curr);\n\t\t\tsub += sub_next;\n\t\t\tif (max_sub < sub_next) max_sub = sub_next, heavy[curr] = next;\n\t\t}\n\t\treturn sub;\n\t}\n\tvoid bfs() {\n\t\tint k = 0;\n\t\tqueue<int> q({ 0 });\n\t\twhile (!q.empty()) {\n\t\t\tint h = q.front(); q.pop();\n\t\t\tfor (int i = h; i != -1; i = heavy[i]) {\n\t\t\t\tvid[i] = k++;\n\t\t\t\tinv[vid[i]] = i;\n\t\t\t\thead[i] = h;\n\t\t\t\tfor (int j : g[i]) if (j != parent[i] && j != heavy[i]) q.push(j);\n\t\t\t}\n\t\t}\n\t}\npublic:\n\tHLDecomposition(int n)\n\t\t: g(n), vid(n, -1), head(n), heavy(n, -1), parent(n), depth(n), inv(n) {}\n\n\tvoid add(int u, int v) {\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\tvoid build() {\n\t\tdfs(0, -1);\n\t\tbfs();\n\t}\n\tvoid for_each(int u, int v, function<void(int, int)> f) {\n\t\tif (vid[u] > vid[v]) swap(u, v);\n\t\tf(max(vid[head[v]], vid[u]), vid[v]);\n\t\tif (head[u] != head[v]) for_each(u, parent[head[v]], f);\n\t}\n};\n\ntemplate <typename T>\nclass LazySegmentTree {\n\tconst int n;\n\tconst T flag;\n\tconst T id;\n\tvector<T> data, data2;\n\tint size(int n) {\n\t\tint res = 1;\n\t\twhile (res < n) res <<= 1;\n\t\treturn res;\n\t}\n\tT sub(int l, int r, int node, int lb, int ub) {\n\t\tif (ub <= l || r <= lb) return id;\n\t\tif (l <= lb && ub <= r) return data[node] != flag ? data[node] : data2[node] * (ub - lb);\n\t\tif (data[node] == flag) {\n\t\t\treturn data2[node] * (min(r, ub) - max(l, lb));\n\t\t}\n\t\treturn sub(l, r, node * 2, lb, (lb + ub) / 2) + sub(l, r, node * 2 + 1, (lb + ub) / 2, ub);\n\t}\n\tvoid suc(int l, int r, int node, int lb, int ub, T val) {\n\t\tif (ub <= l || r <= lb) return;\n\t\tif (l <= lb && ub <= r) {\n\t\t\tdata[node] = flag;\n\t\t\tdata2[node] = val;\n\t\t\treturn;\n\t\t}\n\t\tint left = node * 2, right = node * 2 + 1;\n\t\tif (data[node] == flag) {\n\t\t\tdata[left] = data[right] = flag;\n\t\t\tdata2[left] = data2[right] = data2[node];\n\t\t}\n\t\tint c = (lb + ub) / 2;\n\t\tsuc(l, r, left, lb, c, val);\n\t\tsuc(l, r, right, c, ub, val);\n\t\tdata[node] = (data[left] == flag ? data2[left] * (c - lb) : data[left]) + (data[right] == flag ? data2[right] * (ub - c) : data[right]);\n\t}\npublic:\n\tLazySegmentTree(int n_, T flag_) :\n\t\tn(size(n_)), flag(flag_), id(0), data(n * 2, id), data2(n * 2) {}\n\tvoid update(int l, int r, T val) {\n\t\tsuc(l, r + 1, 1, 0, n, val);\n\t}\n\tT find(int l, int r) {\n\t\treturn sub(l, r + 1, 1, 0, n);\n\t}\n};\n\nsigned main()\n{\n\tcin.sync_with_stdio(false);\n\tcin.tie(0);\n\tint N, M;\n\tcin >> N >> M;\n\tvector<int> w(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> w[i];\n\t}\n\tGraph G(N);\n\tvector<int> u(M), v(M);\n\tfor (int i = 0; i < M; i++) {\n\t\tcin >> u[i] >> v[i]; u[i]--; v[i]--;\n\t\tG[u[i]].emplace_back(u[i], v[i]);\n\t\tG[v[i]].emplace_back(v[i], u[i]);\n\t}\n\tauto br = bridge(G);\n\tint V = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tV = max(V, br.first[i] + 1);\n\t}\n\tHLDecomposition hl(V);\n\tfor (int i = 0; i < M; i++) {\n\t\tif (br.first[u[i]] != br.first[v[i]]) {\n\t\t\thl.add(br.first[u[i]], br.first[v[i]]);\n\t\t}\n\t}\n\thl.build();\n\tLazySegmentTree<int> st(V, -1);\n\tfor (int i = 0; i < N; i++) {\n\t\thl.for_each(br.first[i], br.first[i], [&](int l, int r) {\n\t\t\tst.update(l, r, st.find(l, r) + w[i]);\n\t\t});\n\t}\n\tvector<int> ko(V);\n\tfor (int i = 0; i < N; i++) {\n\t\tko[br.first[i]]++;\n\t}\n\tint res = 0;\n\tfor (int i = 0; i < V; i++) {\n\t\tif (ko[i] > 1) {\n\t\t\thl.for_each(br.first[0], i, [&](int l, int r) {\n\t\t\t\tres += st.find(l, r);\n\t\t\t\tst.update(l, r, 0);\n\t\t\t});\n\t\t}\n\t}\n\tint add = 0;\n\tfor (int i = 0; i < V; i++) {\n\t\tint tmp = 0;\n\t\thl.for_each(br.first[0], i, [&](int l, int r) {\n\t\t\ttmp += st.find(l, r);\n\t\t});\n\t\tadd = max(add, tmp);\n\t}\n\tcout << res + add << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\n\nvector<ll> W;\nvector<vector<ll>> E;\nvector<bool> visited;\n\nvoid dfs_candidate(ll v, vector<ll> &candidate, vector<bool> &check) {\n  visited[v] = true;\n  for(ll u : E[v]) if(!visited[u]) {\n    if(!check[v] && check[u]) candidate.push_back(u);\n    dfs_candidate(u, candidate, check);\n  }\n}\n\nll dfs(ll v) {\n  ll ret = 0;\n  visited[v] = true;\n  for(ll u : E[v]) if(!visited[u]) ret = max(ret, dfs(u));\n  return ret + W[v];\n}\n\nint main(void) {\n  ll N, M;\n  cin >> N >> M;\n  W.resize(N);\n  REP(i, 0, N) cin >> W[i];\n  E.resize(N);\n  REP(i, 0, M) {\n    ll U, V; cin >> U >> V; U--; V--;\n    E[U].push_back(V);\n    E[V].push_back(U);\n  }\n\n  vector<ll> cnt(N, 0);\n  REP(i, 0, N) cnt[i] = E[i].size();\n  queue<ll> q;\n  REP(i, 1, N) if(cnt[i] == 1) q.push(i);\n\n  vector<bool> check(N, false);\n  while(q.size()) {\n    ll v = q.front();\n    q.pop();\n\n    check[v] = true;\n    for(ll u : E[v]) if(--cnt[u] == 1) q.push(u);\n  }\n  check[0] = false;\n\n  vector<ll> candidate;\n  visited.resize(N, false);\n  dfs_candidate(0, candidate, check);\n\n  ll ans = 0;\n  REP(i, 0, N) visited[i] = false;\n  REP(i, 0, N) if(!check[i]) visited[i] = true;\n  for(ll v : candidate) ans = max(ans, dfs(v));\n  REP(i, 0, N) if(!check[i]) ans += W[i];\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\n#define MAX 200000\n\nint N;\nvector<int> G[MAX];\nbool visited[MAX];\nint prenum[MAX],parent[MAX],lowest[MAX],timer;\nvector<P> bridge;\n\nvoid dfs(int v,int prev){\n\tprenum[v]=lowest[v]=timer;\n\ttimer++;\n\tvisited[v]=true;\n\n\tint next;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tnext=G[v][i];\n\t\tif(!visited[next]){\n\t\t\tparent[next]=v;\n\t\t\tdfs(next,v);\n\t\t\tlowest[v]=min(lowest[v],lowest[next]);\n\t\t\tif(prenum[v]<lowest[G[v][i]])bridge.push_back(P(min(v,G[v][i]),max(v,G[v][i])));\n\t\t}else if(next!=prev){\n\t\t\tlowest[v]=min(lowest[v],prenum[next]);\n\t\t}\n\t}\n}\n\n\nset<int> art_points(){\n\tfor(int i=0;i<N;i++){\n\t\tvisited[i]=false;\n\t}\n\ttimer=1;\n\tdfs(0,-1);\n\n\tset<int> ap;\n\tint np=0;\n\tfor(int i=1;i<N;i++){\n\t\tint p=parent[i];\n\t\tif(p==0)np++;\n\t\telse if(prenum[p]<lowest[i])ap.insert(p);\n\t}\n\tif(np>1)ap.insert(0);\n\treturn ap;\n}\n\nint w[MAX];\nvector<P> edge;\nvector<P> n_bridge;\nvector<int> ok_G[MAX];\nint cnt;\nbool used[100001];\nint sum[100001];\nint num[100001];\nvector<int> graph[MAX];\n\nvoid c_dfs(int v){\n\tused[v]=true;\n\tnum[v]=cnt;\n\tsum[cnt]+=w[v];\n\tfor(int i=0;i<ok_G[v].size();i++){\n\t\tif(num[ok_G[v][i]]==-1){\n\t\t\tc_dfs(ok_G[v][i]);\n\t\t}\n\t}\n}\n\nint solve(int v,int p){\n\tint res=0;\n\tfor(int i=0;i<graph[v].size();i++){\n\t\tif(p!=graph[v][i]){\n\t\t\tres=max(res,solve(graph[v][i],v));\n\t\t}\n\t}\n\treturn res+sum[v];\n}\n\nint main(void){\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d\",&w[i]);\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\ta--;\n\t\tb--;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t\tedge.push_back(P(a,b));\n\t}\n\tN=n;\n\tart_points();\n\tsort(bridge.begin(),bridge.end());\n\tfor(int i=0;i<m;i++){\n\t\tint v=lower_bound(bridge.begin(),bridge.end(),edge[i])-bridge.begin();\n\t\tif(!(v<bridge.size() && bridge[v]==edge[i])){\n\t\t\tok_G[edge[i].first].push_back(edge[i].second);\n\t\t\tok_G[edge[i].second].push_back(edge[i].first);\n\t\t}\n\t}\n\tmemset(num,-1,sizeof(num));\n\tfor(int i=0;i<n;i++){\n\t\tif(num[i]==-1){\n\t\t\tc_dfs(i);\n\t\t\tcnt++;\n\t\t}\n\t}\n\tfor(int i=0;i<bridge.size();i++){\n\t\tP p=bridge[i];\n\t\tgraph[num[p.first]].push_back(num[p.second]);\n\t\tgraph[num[p.second]].push_back(num[p.first]);\n\t}\n\tprintf(\"%d\\n\",solve(num[0],-1));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\nint dfs(vector<vector<int>>& g, vector<int>& w, vector<bool>& used, int pos){\n\tused[pos] = true;\n\tint res = w[pos];\n\tfor(auto to : g[pos]){\n\t\tif(used[to]) continue;\n\t\tres += dfs(g, w, used, to);\n\t}\n\treturn res;\n}\n\nvoid cut(vector<vector<int>>& g, vector<int>& in, vector<bool>& used, int pos, vector<int>& p){\n\tused[pos] = true;\n\tfor(auto to : g[pos]){\n\t\tif(used[to]) continue;\n\t\tcut(g, in, used, to, p);\n\t}\n\tif(in[pos] == 1){\n\t\tp.emplace_back(pos);\n\t\tin[pos] = 0;\n\t\tfor(auto i : g[pos]){\n\t\t\tin[i]--;\n\t\t}\n\t}\n}\n\nint main(){\n\tint n, m;\n\tcin >> n >> m;\n\n\tvector<int> w(n);\n\tcin >> w;\n\n\tvector<vector<int>> g(n);\n\tvector<int> in(n,0);\n\trep(i,m){\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tu--; v--;\n\t\tg[u].emplace_back(v);\n\t\tg[v].emplace_back(u);\n\t}\n\trep(i,m){\n\t\tin[i] = g[i].size();\n\t}\n\n\tvector<int> p;\n\tvector<bool> used(n,0);\n\tcut(g, in, used, 0, p);\n\n\tvector<int> cg(n,0);\n\tint ans = accumulate(all(w), 0);\n\trep(i,p.size()){\n\t\tcg[p[i]] = p[i];\n\t\tans -= w[p[i]];\n\t}\n\n\tvector<vector<int>> ng(n);\n\trep(i,n){\n\t\tfor(auto j : g[i]){\n\t\t\tif(cg[i] == 0 and cg[j] == 0) continue;\n\t\t\tng[ cg[i] ].emplace_back( cg[j] );\n\t\t\tng[ cg[j] ].emplace_back( cg[i] );\n\t\t}\n\t}\n\n\tused = vector<bool>(n,0);\n\tused[0] = true;\n\tint maxi = 0;\n\tfor(auto i : ng[0]){\n\t\tmaxi = max(maxi, dfs(ng, w, used, i));\n\t}\n\tcout << ans + maxi << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nstruct edge{ int to,num; };\n\nvector<edge> G[100000];\nvector<int> G2[100000];\nint a[200000],b[200000],ord[100000],low[100000],w[100000],num[100000],sum[100000],ans = 0,cnt = 0;\nbool used[100000],ok[200000];\n\nvoid dfs(int v,int par){\n\tord[v] = cnt++;\n\tlow[v] = ord[v];\n\tused[v] = true;\n\tfor(edge e : G[v]){\n\t\tif(!used[e.to]){\n\t\t\tdfs(e.to,v);\n\t\t\tlow[v] = min(low[v],low[e.to]);\n\t\t}\n\t\telse if(par != e.to) low[v] = min(low[v],ord[e.to]);\n\t}\n}\n\nvoid dfs2(int v,int r){\n\tused[v] = true;\n\tnum[v] = r;\n\tsum[r] += w[v];\n\tfor(edge e : G[v]){\n\t\tif(ok[e.num] && num[e.to] == -1) dfs2(e.to,r);\n\t}\n}\n\nint dfs3(int v,int par){\n\tint ma = 0;\n\tfor(int to : G2[v]){\n\t\tif(par != to) ma = max(ma,dfs3(to,v));\n\t}\n\treturn ma + sum[v];\n}\n\nsigned main(){\n\tint n,m;\n\tcin >> n >> m;\n\tfor(int i = 0;i < n;i++){\n\t\tcin >> w[i];\n\t\tnum[i] = -1;\n\t\tlow[i] = n + 1;\n\t}\n\tfor(int i = 0;i < m;i++){\n\t\tcin >> a[i] >> b[i]; a[i]--;b[i]--;\n\t\tG[a[i]].push_back({b[i],i});\n\t\tG[b[i]].push_back({a[i],i});\n\t}\n\tdfs(0,-1);\n\tfor(int i = 0;i < m;i++){\n\t\tif(ord[a[i]] > ord[b[i]]) swap(a[i],b[i]);\n\t\tif(low[b[i]] <= ord[a[i]]) ok[i] = true;\n\t}\n\tfor(int i = 0;i < n;i++){\n\t\tif(num[i] == -1) dfs2(i,i);\n\t}\n\tfor(int i = 0;i < m;i++){\n\t\tif(!ok[i]){\n\t\t\tG2[num[a[i]]].push_back(num[b[i]]);\n\t\t\tG2[num[b[i]]].push_back(num[a[i]]);\n\t\t}\n\t}\n\tcout << dfs3(0,-1) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_V 100005\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\nint V;\nvector<int> G[MAX_V];\nvector<int> rG[MAX_V];\nvector<int> vs;\nbool used[MAX_V];\nint cmp[MAX_V];\n\nvoid add_edge(int from,int to){\n  G[from].push_back(to);\n  rG[to].push_back(from);\n}\n\nvoid dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++)\n    if(!used[G[v][i]])dfs(G[v][i]);\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v]=true;\n  cmp[v]=k;\n  for(int i=0;i<rG[v].size();i++)\n    if(!used[rG[v][i]])rdfs(rG[v][i],k);\n}\n\nint scc(){\n  memset(used,0,sizeof(used));\n  vs.clear();\n  for(int v=0;v<V;v++)\n    if(!used[v])dfs(v);\n  memset(used,0,sizeof(used));\n  int k=0;\n  for(int i=vs.size()-1;i>=0;i--)\n    if(!used[vs[i]])rdfs(vs[i],k++);\n  return k;\n}\n\nvector<int> G2[MAX_V];\nvector<P> G3[MAX_V];\nint usede[MAX_V];\n\nvoid dfs2(int x){\n  for(int i=0;i<G3[x].size();i++){\n    if(usede[G3[x][i].second])continue;\n    usede[G3[x][i].second]=true;\n    add_edge(x,G3[x][i].first);\n    dfs2(G3[x][i].first);\n  }\n}\n\nint n,m,w[MAX_V],u,v;\nint sum[MAX_V],f[MAX_V];\nint used2[MAX_V],ans;\n\nint dfs3(int x){\n  if(used[x])return 0;\n  used[x]=true;\n  int r=0;\n  for(int i=0;i<G2[x].size();i++)\n    r|=dfs3(G2[x][i]);\n  if(f[cmp[x]])r=1;\n  if(!used2[cmp[x]]&&r){\n    ans+=sum[cmp[x]];\n    used2[cmp[x]]=1;\n  }\n  return r;\n}\n\nint maxs=0;\nvoid dfs4(int x,int s){\n  int flag=0;\n  for(int i=0;i<G2[x].size();i++){\n    if(used[G2[x][i]])continue;\n    used[G2[x][i]]=true;\n    flag=1;\n    if(cmp[x]!=cmp[G2[x][i]]&&!used2[cmp[x]])\n      dfs4(G2[x][i],s+sum[cmp[x]]);\n    else dfs4(G2[x][i],s);\n  }\n  if(!flag&&!used2[cmp[x]])maxs=max(maxs,s+sum[cmp[x]]);\n}\n\nvoid solve(){\n  dfs2(0);\n  int K=scc();\n  for(int i=0;i<V;i++){\n    if(sum[cmp[i]])f[cmp[i]]=1;\n    sum[cmp[i]]+=w[i];\n  }\n  memset(used,0,sizeof(used));\n  dfs3(0);\n  memset(used,0,sizeof(used));\n  used[0]=true;\n  dfs4(0,0);\n  ans+=maxs;\n  cout<<ans<<endl;\n}\n\nint main(){\n  cin>>n>>m;\n  V=n;\n  for(int i=0;i<n;i++)cin>>w[i];\n  for(int i=0;i<m;i++){\n    cin>>u>>v;\n    u--,v--;\n    G2[u].push_back(v);\n    G2[v].push_back(u);\n    G3[u].push_back(P(v,i));\n    G3[v].push_back(P(u,i));\n  }\n  solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define MAX_V 114514\ntypedef pair<int,int> P;\nvector<int> G[MAX_V],C[MAX_V],T[MAX_V],ord,low,belong;\nvector<P> B;\nint V;\nbool is_bridge(int u,int v){\n  if(ord[u]>ord[v]) swap(u,v);\n  return ord[u]<low[v];\n}\nvoid dfs(int u,int p,int &k){\n  ord[u]=low[u]=k;\n  k++;\n  for(int i=0;i<(int)G[u].size();i++){\n    int v=G[u][i];\n    if(v==p) continue;\n    if(ord[v]>=0){\n      low[u]=min(low[u],ord[v]);\n    }else{\n      dfs(v,u,k);\n      low[u]=min(low[u],low[v]);\n    }\n    if(is_bridge(u,v)) B.push_back(P(u,v));\n  }\n}\nvoid fill_component(int c,int u){\n  C[c].push_back(u);\n  belong[u]=c;\n  for(int i=0;i<(int)G[u].size();i++){\n    int v=G[u][i];\n    if(belong[v]>=0||is_bridge(u,v)) continue;\n    fill_component(c,v);\n  }\n}\nvoid add_component(int u,int &k){\n  if(belong[u]>=0) return;\n  fill_component(k++,u);\n}\nvoid biconnectedgrapth(int n){\n  int k=0;\n  ord.resize(n,-1);\n  low.resize(n);\n  belong.resize(n,-1);\n  for(int v=0;v<n;v++){\n    if(ord[v]>=0) continue;\n    dfs(v,-1,k);\n  }\n  k=0;\n  for(int i=0;i<(int)B.size();i++){\n    add_component(B[i].first,k);\n    add_component(B[i].second,k);\n  }\n  add_component(0,k);\n  V=k;\n  for(int i=0;i<(int)B.size();i++){\n    int u=belong[B[i].first],v=belong[B[i].second];\n    T[u].push_back(v);\n    T[v].push_back(u);\n  }\n}\n\nvoid add_edge(int u,int v){\n  G[u].push_back(v);\n  G[v].push_back(u);\n}\nint wei[MAX_V],memo[MAX_V];\nbool used[MAX_V],dele[MAX_V];\nbool flag=0;\nint root;\nint xyz;\nvoid dfs2(int v,int p){\n  used[v]=1;\n  if(~p&&(int)C[v].size()>1){\n    if(v==xyz) xyz=root;\n    flag=1;\n    dele[v]=1;\n    for(int k:T[v])\n      T[root].push_back(k);\n    wei[root]+=wei[v];\n    return;\n  }\n  for(int u:T[v]){\n    if(u==p) continue;\n    if(used[u]) continue;\n    dfs2(u,v);\n    if(flag){\n      if(~p){\n\tif(v==xyz) xyz=root;\n\tdele[v]=1;\n\tfor(int k:T[v])\n\t  T[root].push_back(k);\n\twei[root]+=wei[v];\n\treturn;\n      }else{\n\tflag=0;\n      }\n    }\n  }\n}\n\nint dfs3(int v,int p){\n  int res=wei[v];\n  for(int u:T[v]){\n    if(u==p) continue;\n    res=max(res,wei[v]+dfs3(u,v));\n  }\n  //cout<<v<<\"-\"<<res<<endl;\n  return memo[v]=res;\n}\nint ans;\n/*\nvoid dfs4(int v,int p,int d){\n  //cout<<v<<\" \"<<p<<\" \"<<d<<endl;\n  int res=0;\n  vector<P> vp;\n  for(int u:T[v])\n    if(!dele[u]&&u!=p) vp.push_back(P(memo[u],u));\n  vp.push_back(P(d,-1));\n  sort(vp.rbegin(),vp.rend());\n  for(int i=0;i<2&&i<(int)vp.size();i++)\n    res+=vp[i].first;\n  ans=max(ans,wei[v]+res);\n  for(int u:T[v]){\n    if(dele[u]||u==p) continue;\n    int tmp=0;\n    if(vp.size()>0&&vp[0].second!=u) tmp=vp[0].first;\n    if(vp.size()>1) tmp=max(tmp,vp[1].first);\n    dfs4(u,v,max(d,tmp));\n  }\n}\n*/\nsigned main(){\n  int n,m;\n  cin>>n>>m;\n  int w[n];\n  for(int i=0;i<n;i++) cin>>w[i];\n  for(int i=0;i<m;i++){\n    int u,v;\n    cin>>u>>v;\n    add_edge(u-1,v-1);\n  }\n  biconnectedgrapth(n);\n  root=-1;\n  for(int i=0;i<V;i++){\n    for(int j=0;j<(int)C[i].size();j++){\n      wei[i]+=w[C[i][j]];\n      if(j>0) root=i;\n      if(C[i][j]==0) xyz=i;\n    }\n    //cout<<i<<\":\"<<wei[i]<<endl;\n  }\n  if(~root) dfs2(root,-1);\n  cout<<dfs3(xyz,-1)<<endl;\n  /*\n  //puts(\"dfs3\");\n  ans=0;\n  dfs4(i,-1,0);\n  //puts(\"dfs4\");\n  cout<<ans<<endl;\n  */\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_V 100000\nusing namespace std;\nint m,w[100001];\nvector<int> vv[100001];\nunordered_set<int> st[100001];\nint V;\nvector<int> G[MAX_V];\nvector<int> rG[MAX_V];\nvector<int> vs;\nbool used[MAX_V];\nint cmp[MAX_V];\nint C[100001],F[100001],U[100001],ans;\nbool UU[100001];\n\n\nvoid DFS(int p){\n  for(int i=0;i<vv[p].size();i++){\n    int mn=min(vv[p][i],p),mx=max(vv[p][i],p);\n    if(st[mn].find(mx)==st[mn].end()){\n      st[mn].insert(mx);\n      G[p].push_back(vv[p][i]);\n      rG[vv[p][i]].push_back(p);\n      DFS(vv[p][i]);\n    }\n  }\n}\n\nvoid dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++)if(!used[G[v][i]])dfs(G[v][i]);\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v]=true;\n  cmp[v]=k;\n  for(int i=0;i<rG[v].size();i++)if(!used[rG[v][i]])rdfs(rG[v][i],k);\n}\n\nint scc(){\n  for(int v=0;v<V;v++)if(!used[v])dfs(v);\n  memset(used,0,sizeof(used));\n  int k=0;\n  for(int i=vs.size()-1;i>=0;i--)if(!used[vs[i]])rdfs(vs[i],k++);\n  return k;\n}\n\nbool DFS1(int p){\n  if(U[p])return 0;\n  U[p]=1;\n  bool f=F[cmp[p]]>=2;\n  for(int i=0;i<G[p].size();i++)\n    f|=DFS1(G[p][i]);\n  ans+=w[p]*f;\n  return UU[p]=f;\n}\nbool UUU[100001];\nint DFS2(int p){\n  if(UUU[p])return 0;\n  UUU[p]=1;\n  int res=0;\n  \n  for(int i=0;i<G[p].size();i++)\n    res=max(res,DFS2(G[p][i]));  \n  return res+(UU[p]?0:w[p]);\n}\n\nint main(){\n  cin>>V>>m;\n  for(int i=0;i<V;i++)cin>>w[i];\n  for(int j=0,a,b;j<m;j++){\n    cin>>a>>b;a--,b--;\n    vv[a].push_back(b),vv[b].push_back(a);\n  }\n  DFS(0);\n  int t=0;\n  for(int i=0;i<V;i++)t+=w[i];\n  scc();\n  for(int i=0;i<V;i++)F[cmp[i]]++;\n  DFS1(0);\n  cout<<ans+DFS2(0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing pint = pair<int, int>;\nusing tint = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nstruct UnionFind {\n  vector<int> data;\n  UnionFind(){}\n  UnionFind(int sz):data(sz, -1){}\n  int find(int x) {\n    return data[x] < 0 ? x : data[x] = find(data[x]);\n  }\n  int size(int x) {\n    return -data[find(x)];\n  }\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n  bool unite(int x, int y) {\n    x = find(x), y = find(y);\n    if(x == y) return false;\n    if(data[x] < data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n    return true;\n  }\n};\n\n#define MAX_N 100000\n\nint N, M, num;\nvint w, ord, low, cmp, conn, val, sz;\nvector<vint> graph, tree;\nvector< pair<int, int> > edges;\nvector<bool> vis;\n\nUnionFind uf;\n\nvoid dfs(int u, int p, int &k) {\n  vis[u] = true;\n  ord[u] = low[u] = k++;\n  for(int v : graph[u]) {\n    if(!vis[v]) {\n      dfs(v, u, k);\n      chmin(low[u], low[v]);\n      if(ord[u] >= low[v]) uf.unite(u, v);\n    } else if(v != p) {\n      chmin(low[u], ord[v]);\n    }\n  }\n}\n\nvoid compose() {\n  uf = UnionFind(N);\n  vis.resize(N);\n  ord.resize(N);\n  low.resize(N);\n  cmp.resize(N);\n  int k = 0;\n  dfs(0, -1, k);\n  num = 0;\n  conn.resize(N);\n  rep(u, N) if(u == uf.find(u)) conn[u] = num++;\n  rep(u, N) cmp[u] = conn[uf.find(u)];\n  tree.resize(num);\n  for(auto e : edges) {\n    int x = cmp[e.first], y = cmp[e.second];\n    if(x == y) continue;\n    tree[x].push_back(y);\n    tree[y].push_back(x);\n  }\n}\n\nint dp1[MAX_N]; // modoreru\nint dp2[MAX_N]; // modoranai\n\nint solve(int u, int p) {\n  int res = 0;\n  for(int v : tree[u]) {\n    if(v == p) continue;\n    chmax(res, solve(v, u));\n    dp1[u] += dp1[v];\n  }\n  if(sz[u] >= 3 || dp1[u] > 0) dp1[u] += val[u];\n  res += val[u];\n  for(int v : tree[u]) {\n    if(v == p) continue;\n    chmax(res, dp1[u]-dp1[v]+dp2[v]);\n  }\n  return dp2[u] = res;\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin >> N >> M;\n  w.resize(N);\n  rep(i, N) cin >> w[i];\n  graph.resize(N);\n  rep(i, M) {\n    int u, v;\n    cin >> u >> v; --u, --v;\n    graph[u].push_back(v);\n    graph[v].push_back(u);\n    edges.emplace_back(minmax(u, v));\n  }\n  compose();\n  val.resize(num);\n  sz.resize(num);\n  rep(u, N) {\n    val[cmp[u]] += w[u];\n    sz[cmp[u]] = uf.size(u);\n  }\n  cout << solve(cmp[0], -1) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define MAX_V 111111\ntypedef pair<int,int> P;\nvector<int> G[MAX_V],C[MAX_V],T[MAX_V],ord,low,belong;\nvector<P> B;\nbool is_bridge(int u,int v){\n  if(ord[u]>ord[v]) swap(u,v);\n  return ord[u]<low[v];\n}\nvoid dfs(int u,int p,int &k){\n  ord[u]=low[u]=k;\n  ++k;\n  for(int i=0;i<(int)G[u].size();i++){\n    int v=G[u][i];\n    if(v==p) continue;\n    if(ord[v]>=0){\n      low[u]=min(low[u],ord[v]);\n    }else{\n      dfs(v,u,k);\n      low[u]=min(low[u],low[v]);\n    }\n    if(is_bridge(u,v)) B.push_back(P(u,v));\n  }\n}\nvoid fill_component(int c,int u){\n  C[c].push_back(u);\n  belong[u]=c;\n  for(int i=0;i<(int)G[u].size();i++){\n    int v=G[u][i];\n    if(belong[v]>=0||is_bridge(u,v)) continue;\n    fill_component(c,v);\n  }\n}\nvoid add_component(int u,int &k){\n  if(belong[u]>=0) return;\n  fill_component(k++,u);\n}\nvoid biconnectedgrapth(int n){\n  int k=0;\n  ord.resize(n,-1);\n  low.resize(n);\n  belong.resize(n,-1);\n  //cout<<n<<endl;\n  for(int v=0;v<n;v++){\n    if(ord[v]>=0) continue;\n    dfs(v,-1,k);\n  }\n  //cout<<k<<endl;\n  k=0;\n  for(int i=0;i<(int)B.size();i++){\n    add_component(B[i].first,k);\n    add_component(B[i].second,k);\n  }\n  add_component(0,k);\n  //cout<<k<<endl;\n  for(int i=0;i<(int)B.size();i++){\n    int u=belong[B[i].first],v=belong[B[i].second];\n    T[u].push_back(v);\n    T[v].push_back(u);\n  }\n}\nvoid add_edge(int u,int v){\n  G[u].push_back(v);\n  G[v].push_back(u);\n}\n\nint W[MAX_V];\n\nint dfs2(int u,int p){\n  int res=0;\n  for(int i=0;i<(int)T[u].size();i++){\n    int v=T[u][i];\n    if(v==p) continue;\n    res=max(res,dfs2(v,u));\n  }\n  return W[u]+res;\n}\nint main(){\n  int n,m;\n  cin>>n>>m;\n  int w[n];\n  for(int i=0;i<n;i++) cin>>w[i];\n  for(int i=0;i<m;i++){\n    int u,v;\n    cin>>u>>v;\n    add_edge(u-1,v-1);\n  }\n  biconnectedgrapth(n);\n  //puts(\"a\");\n  for(int i=0;i<n;i++) W[belong[i]]+=w[i];\n  cout<<dfs2(belong[0],-1)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-8)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n#define pb push_back\n#define ALL(x) x.begin(),x.end()\n#define fst first\n#define snd second\n\nusing namespace std;\n\ntypedef long long ll;\n\nbool LT(double a,double b) { return !equals(a,b) && a < b; }\nbool LTE(double a,double b) { return equals(a,b) || a < b; }\n\ntypedef pair<int,int> ii;\nstruct Edge { int src,dst,w; };\nconst int MAX_V = 1000100; //\nint V,E; //\nvector<Edge> G[MAX_V]; // undirected graph\nvector<int> dfs_num,dfs_low,dfs_parent,articulation_vertex;\nint dfsNumberCounter, dfsRoot, rootChildren;\n\nset<ii> bridges;\n#define UNVISITED -1\nvoid articulationPointAndBridge(int u){\n  dfs_low[u] = dfs_num[u] = dfsNumberCounter++;\n  rep(j,(int)G[u].size()){\n    Edge &v = G[u][j];\n    if( dfs_num[v.dst] == UNVISITED ) {\n      dfs_parent[v.dst] = u;\n      if( u == dfsRoot ) rootChildren++;\n\n      articulationPointAndBridge(v.dst);\n\n      if( dfs_low[v.dst] >= dfs_num[u] ) articulation_vertex[u] = true;\n      if( dfs_low[v.dst] >  dfs_num[u] ) {\n        //printf(\"Edge (%d,%d) is a bridge\\n\",u,v.dst);\n\tint s = u, t = v.dst;\n\tif( s > t ) swap(s,t);\n\tbridges.insert(ii(s,t));\n      }\n      dfs_low[u] = min(dfs_low[u],dfs_low[v.dst]);\n    } else if( v.dst != dfs_parent[u] ) {\n      dfs_low[u] = min(dfs_low[u],dfs_num[v.dst]);\n    }\n  }\n}\n\nvoid calculateArticulationPointAndBridge(){\n  dfsNumberCounter = 0;\n  dfs_num.assign(V,UNVISITED);\n  dfs_low.assign(V,0);\n  dfs_parent.assign(V,0);\n  articulation_vertex.assign(V,0);\n  \n  //printf(\"Bridges:\\n\");\n  rep(i,V) {\n    if( dfs_num[i] == UNVISITED ) {\n      dfsRoot = i, rootChildren = 0;\n      articulationPointAndBridge(i);\n      articulation_vertex[dfsRoot] = ( rootChildren > 1 );\n    }\n  }\n  \n  //printf(\"Articulation Points:\\n\");\n  //rep(i,V) if( articulation_vertex[i] ) printf(\"Vertex %d\\n\",i);\n}\n\n\nvector<int> T[MAX_V];\nint par[MAX_V];\nint tdfs(int cur,int id,vector<int> &w) {\n  int score = w[cur];\n  rep(i,(int)G[cur].size()) {\n    int dst = G[cur][i].dst;\n    int s = cur, t = dst;\n    if( s > t ) swap(s,t);\n    if( bridges.count(ii(s,t)) ) continue;\n    if( par[dst] != -1 ) {\n      assert( par[dst] == id );\n      continue;\n    }\n    par[dst] = id;\n    score += tdfs(dst,id,w);\n  }\n  return score;\n}\n\nconst bool debug = 0;\nvector<bool> isLoop;\n/*\nll mdfs(int cur,int prev, vector<int> &w) {\n  ll maxi = w[cur];\n  rep(i,(int)T[cur].size()) {\n    int nex = T[cur][i];\n    if( nex == prev ) continue;\n    ll score = mdfs(nex,cur,w) + (ll)w[cur];\n    maxi = max(maxi,score);\n  }\n  return maxi;\n}\n*/\nii mdfs(int cur,int prev,vector<int> &w) {\n  ii ret = ii(0,0);\n  bool loop = isLoop[cur];\n  rep(i,(int)T[cur].size()) {\n    int nex = T[cur][i];\n    if( nex == prev ) continue;\n    ii tmp = mdfs(nex,cur,w);\n    if( tmp.fst > 0 ) loop = true;\n    ret.fst += tmp.fst;\n    ret.snd = max(ret.snd, tmp.snd);\n  }\n  if( loop ) {\n    ret.fst += w[cur];\n  } else {\n    ret.snd += w[cur];\n  }\n  return ret;\n}\n\nvoid compute(vector<int> &ow) {\n  calculateArticulationPointAndBridge();\n  memset(par,-1,sizeof par);\n  int nV = 0;\n  vector<int> w;\n  rep(i,V) {\n    if( par[i] == -1 ) {\n      par[i] = nV;\n      int cost = tdfs(i,nV++,ow);\n      w.pb(cost);\n    }\n  }\n  map<int,int> mp;\n  rep(i,V)  ++mp[par[i]];\n  rep(i,nV) isLoop.pb(mp[i]>1);\n  \n  if( debug ) {\n    cout << \"nV = \" << nV << endl;\n    rep(i,nV) {\n      cout << i << \"-th: w[\" << i << \"] = \" << w[i]  << endl;\n    }\n    cout << \"--\" << endl;\n    rep(i,V) {\n      cout << i << \"-th: par[\" << i << \"] = \" << par[i] << endl;\n    }\n  }\n\n  set<ii> added;\n  rep(i,V) {\n    int src = par[i];\n    rep(j,(int)G[i].size()) {\n      int dst = par[G[i][j].dst];\n      if( src == dst ) continue;\n      if( added.count(ii(src,dst)) ) continue;\n      added.insert(ii(src,dst));\n      added.insert(ii(dst,src));\n      T[src].pb(dst);\n      T[dst].pb(src);\n    }\n  }\n\n  if( debug ) {\n    cout << \"Tree ---\" << endl;\n    rep(i,nV) {\n      cout << \"* \" << i << \"-th:\" << endl;\n      rep(j,(int)T[i].size()) {\n\tcout << T[i][j] << \" \";\n      } puts(\"\");\n    }\n  }\n  ii tmp = mdfs(par[0],-1,w);\n  cout << tmp.fst + tmp.snd << endl;\n  \n}\n\nint main() {\n  int s, t;\n  cin >> V >> E;\n  vector<int> w(V);\n  rep(i,V) cin >> w[i];\n  rep(i,E) {\n    cin >> s >> t;\n    --s, --t;\n    G[s].pb((Edge){s,t,0});\n    G[t].pb((Edge){t,s,0});\n  }\n  compute(w);\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\nusing namespace std;\n\nconst int INF = 1e9;\n\nvoid visit(vector< vector<int> > &G, int cur, int prev, vector< pair<int, int> > &brg, vector< vector<int> > &each_bcc, stack<int> &roots, stack<int> &S, vector<bool> &inS, vector<int> &order, int &k){\n  order[cur] = ++k;\n  S.push(cur);\n  inS[cur] = true;\n  roots.push(cur);\n  for(int i = 0; i < G[cur].size(); ++i){\n    int to = G[cur][i];\n    if(!order[to]) visit(G, to, cur, brg, each_bcc, roots, S, inS, order, k);\n    else if(to != prev && inS[to]){\n      while(order[roots.top()] > order[to]) roots.pop();\n    }\n  }\n\n  if(cur == roots.top()){\n    if(prev != -1) brg.push_back(pair<int, int>(prev, cur));\n    vector<int> bcc;\n    while(1){\n      int node = S.top();\n      S.pop();\n      inS[node] = false;\n      bcc.push_back(node);\n      if(node == cur) break;\n    }\n    each_bcc.push_back(bcc);\n    roots.pop();\n  }\n}\n\nvoid bridge(vector< vector<int> > &G, vector< pair<int, int> > &brg, vector< vector<int> > &each_bcc){\n  int V = G.size();\n  vector<int> order(V);\n  vector<bool> inS(V);\n  stack<int> roots, S;\n  int k = 0;\n  for(int i = 0; i < V; ++i){\n    if(!order[i]) visit(G, i, -1, brg, each_bcc, roots, S, inS, order, k);\n  }\n}\n\nvoid dfs(vector< vector<int> > &G, vector<int> &D, int s){\n  for(int i = 0; i < G[s].size(); ++i){\n    int v = G[s][i];\n    if(D[v] > D[s] + 1){\n      D[v] = D[s] + 1;\n      dfs(G, D, v);\n    }\n  }\n}\n\nint main(){\n  int N, M;\n  cin >> N >> M;\n  vector<int> W(N);\n  for(int i = 0; i < N; ++i) cin >> W[i];\n  vector< vector<int> > G(N);\n  for(int i = 0; i < M; ++i){\n    int u, v;\n    cin >> u >> v;\n    --u;--v;\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n  vector< vector<int> > each_bcc;\n  vector< pair<int, int> > brg;\n  bridge(G, brg, each_bcc);\n  int V = each_bcc.size();\n  vector<int> W_(V, 0), cmp(N);\n\n  for(int i = 0; i < V; ++i){\n    for(int j = 0; j < each_bcc[i].size(); ++j){\n      cmp[each_bcc[i][j]] = i;\n      W_[i] += W[each_bcc[i][j]];\n    }\n  }\n\n  vector< vector<int> > G_(V);\n  for(int i = 0; i < brg.size(); ++i){\n    int u = brg[i].first, v = brg[i].second;\n    G_[cmp[u]].push_back(cmp[v]);\n    G_[cmp[v]].push_back(cmp[u]);\n  }\n  vector<int> D(V, INF);\n  D[cmp[0]] = 0;\n  dfs(G_, D, cmp[0]);\n  int ans = 0;\n  vector<int> R;\n  for(int i = 0; i < V; ++i){\n    if(G_[i].size() > 1 || i == cmp[0]) continue;\n    int v = i;\n    while(each_bcc[v].size() < 3 && v != cmp[0]){\n      for(int j = 0; j < G_[v].size(); ++j){\n        int u = G_[v][j];\n        if(D[u] == D[v] - 1){\n          v = u;\n          break;\n        }\n      }\n    }\n    if(v != cmp[0]) R.push_back(v);\n  }\n\n  ans += W_[cmp[0]];\n  vector<bool> visited(V, false);\n  visited[cmp[0]] = true;\n  for(int i = 0; i < R.size(); ++i){\n    int v = R[i];\n    while(!visited[v]){\n      ans += W_[v];\n      visited[v] = true;\n      for(int j = 0; j < G_[v].size(); ++j){\n        int u = G_[v][j];\n        if(D[u] == D[v] - 1){\n          v = u;\n          break;\n        }\n      }\n    }\n  }\n  int s = 0;\n  for(int i = 0; i < V; ++i){\n    if(G_[i].size() > 1 || visited[i]) continue;\n    int v = i, t = 0;\n    while(!visited[v]){\n      t += W_[v];\n      for(int j = 0; j < G_[v].size(); ++j){\n        int u = G_[v][j];\n        if(D[u] == D[v] - 1){\n          v = u;\n          break;\n        }\n      }\n    }\n    s = max(s, t);\n  }\n  ans += s;\n  cout << ans << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\nclass Node{\n\tpublic:\n\t\tint ord; //DFSの訪問の順番\n\t\tint par; //DFS Treeにおける親\n\t\tint low; //min(自分のord, 逆辺がある場合の親のord, すべての子のlow)\n\t\tNode() : ord(-1) { }\n};\n\nclass ArticulationPoints {\n\tprivate:\n\t\tint v, cnt;\n\t\tvector<Node> node;\n\t\tvoid dfs(int cur, int prev){\n\t\t\tnode[cur].ord = node[cur].low = cnt;\n\t\t\tcnt++;\n\n\t\t\tfor(auto to : g[cur]){\n\t\t\t\tif(to == prev) continue;\n\t\t\t\tif(node[to].ord >= 0){\n\t\t\t\t\tnode[cur].low = min(node[cur].low, node[to].ord);\n\t\t\t\t}else{\n\t\t\t\t\tnode[to].par = cur;\n\t\t\t\t\tdfs(to, cur);\n\t\t\t\t\tnode[cur].low = min(node[cur].low, node[to].low);\n\t\t\t\t}\n\t\t\t\tif(node[cur].ord < node[to].low){\n\t\t\t\t\tbridge.emplace_back(min(cur, to), max(cur, to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tpublic:\n\t\tvector<vector<int>> g;\n\t\tvector<pair<int, int>> bridge;\n\t\tset<int> ap; // 関節店\n\t\tArticulationPoints(int n) : v(n), cnt(1), node(n), g(n) { }\n\t\tvoid addEdge(int a, int b){\n\t\t\tg[a].emplace_back(b);\n\t\t\tg[b].emplace_back(a);\n\t\t}\n\t\tbool isBridge(int u, int v){\n\t\t\tif(node[u].ord > node[v].ord) swap(u,v);\n\t\t\treturn node[u].ord < node[v].low;\n\t\t}\n\t\tvoid run(){\n\t\t\tdfs(0, -1); // 0 = root\n\n\t\t\tint np = 0;\n\t\t\trange(i,1,v){\n\t\t\t\tint p = node[i].par;\n\t\t\t\tif(p == 0) np++;\n\t\t\t\telse if(node[p].ord <= node[i].low) ap.emplace(p);\n\t\t\t}\n\t\t\tif(np > 1) ap.emplace(0);\n\t\t\tsort(all(bridge));\n\t\t\t//for(auto it:ap){ cout << it << endl; } //関節点の全列挙\n\t\t\t//for(auto it:bridge){ cout << it.first << ' ' << it.second << endl; } //橋の全列挙\n\t\t}\n};\n\nclass TwoEdgeConnectedComponent : public ArticulationPoints {\n\tprivate:\n\t\tvoid dfs(int c, int pos){\n\t\t\tver[c].emplace_back(pos);\n\t\t\tcomp[pos] = c;\n\t\t\tfor (int to : g[pos]) {\n\t\t\t\tif (comp[to] >= 0) continue;\n\t\t\t\tif (isBridge(pos, to)) continue;\n\t\t\t\tdfs(c, to);\n\t\t\t}\n\t\t}\n\t\tvoid addComp(int pos){\n\t\t\tif(comp[pos] >= 0) return;\n\t\t\tver.emplace_back();\n\t\t\tdfs(ver.size() - 1, pos);\n\t\t}\n\tpublic:\n\t\tvector<int> comp; // 成分分解前の頂点から分解後の頂点への写像？\n\t\tvector<vector<int>> ver; // 分解後の頂点と、その頂点に含まれる分解前の頂点\n\t\tTwoEdgeConnectedComponent(int n) : ArticulationPoints(n), comp(n,-1) {}\n\t\tvoid solve(){\n\t\t\trun();\n\t\t\tfor(auto p : bridge){\n\t\t\t\taddComp(p.first);\n\t\t\t\taddComp(p.second);\n\t\t\t}\n\t\t\taddComp(0);\n\t\t}\n\t\tvector<vector<int>> getTree(){\n\t\t\tvector<vector<int>> res(ver.size());\n\t\t\tfor(auto p : bridge){\n\t\t\t\tint u = comp[p.first], v = comp[p.second];\n\t\t\t\tres[u].emplace_back(v);\n\t\t\t\tres[v].emplace_back(u);\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n};\n\nvoid cut(vector<vector<int>>& g, vector<vector<int>>& node, vector<int>& in, vector<bool>& used, vector<int>& p, int pos){\n\tused[pos] = true;\n\tfor(auto to : g[pos]){\n\t\tif(used[to]) continue;\n\t\tcut(g, node, in, used, p, to);\n\t}\n\tif(in[pos] == 1){\n\t\tfor(auto to : g[pos]){\n\t\t\tin[to]--;\n\t\t}\n\t\tp.emplace_back(pos);\n\t}\n}\n\nint dfs(vector<vector<int>>& g, vector<int>& w, vector<bool>& used, int pos){\n\tint res = w[pos];\n\tused[pos] = true;\n\tfor(auto to : g[pos]){\n\t\tif(used[to]) continue;\n\t\tres += dfs(g, w, used, to);\n\t}\n\treturn res;\n}\n\nint main(){\n\tint n, m;\n\tcin >> n >> m;\n\n\tvector<int> w(n);\n\tcin >> w;\n\n\tTwoEdgeConnectedComponent tecc(n);\n\trep(i,m){\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tu--; v--;\n\t\ttecc.addEdge(u,v);\n\t}\n\ttecc.solve();\n\tvector<vector<int>> g = tecc.getTree();\n\tvector<int> in(g.size());\n\trep(i,g.size()) in[i] = g[i].size();\n\n\tvector<int> p;\n\tvector<bool> used(g.size(),0);\n\tcut(g, tecc.ver, in, used, p, 0);\n\n\tvector<int> cg(g.size(),0);\n\tint ans = accumulate(all(w), 0);\n\t//show(ans)\n\t\trep(i,p.size()){\n\t\t\tcg[p[i]] = p[i];\n\t\t\tans -= w[p[i]];\n\t\t}\n\n\tvector<vector<int>> ng(g.size());\n\trep(i,g.size()){\n\t\tfor(auto j : g[i]){\n\t\t\tif(cg[i] == 0 and cg[j] == 0) continue;\n\t\t\tng[ cg[i] ].emplace_back( cg[j] );\n\t\t\tng[ cg[j] ].emplace_back( cg[i] );\n\t\t}\n\t}\n\n\tused = vector<bool>(n,0);\n\tused[0] = true;\n\tint maxi = 0;\n\tfor(auto i : ng[0]){\n\t\tmaxi = max(maxi, dfs(ng, w, used, i));\n\t}\n\tcout << ans + maxi << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2712>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\n\nclass BCC{\nprivate:\n    typedef pair<int,int> pii;\n    vector<vector<int>> G;\n    \n    vector<vector<int>> newG; // BCCのグループの頂点をひとまとめにして新たに作ったグラフ\n    vector<pii> bridges; // 橋の列挙\n    vector<int> group; // 各頂点が含まれるBCCの番号\n    vector<vector<int>> each_bcc; //各BCCでまとまった配列\n    vector<int> order; // 各頂点に訪れた順番\n    stack<int> S; // 既に訪れた頂点のうち、まだどの二重辺連結成分にも割り振られていない頂点の集合\n    vector<int> inS; // 集合Sに各頂点が含まれているかどうかの情報\n    stack<int> roots; // 各二重辺連結成分を、DFS木の部分木として見た時の根の集合\n    \n    int N;\npublic:\n    BCC(int _N){init(_N);}\n    void init(int _N){\n        N = _N;\n        G.clear(); G.resize(N);\n        bridges.clear();\n        group.clear();\n        each_bcc.clear();\n        order.clear();\n        inS.clear();\n    }\n    void add_edge(int u,int v){\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n    void visit(int cur,int prev,int &k){\n        order[cur] = k++;\n        S.push(cur); inS[cur] = true; roots.push(cur);\n        for(int i = 0; i < G[cur].size();i++){\n            int v = G[cur][i];\n            if(order[v] == -1) visit(v,cur,k);\n            else if(v != prev && inS[v]){\n                while(order[roots.top()] > order[v]) roots.pop();\n            }\n        }\n        if(cur == roots.top()){\n            if(prev != -1) bridges.push_back({min(prev,cur),max(prev,cur)});\n            vector<int> bcc;\n            while(true){\n                int node = S.top(); S.pop();\n                inS[node] = false;\n                bcc.push_back(node);\n                group[node] = (int)each_bcc.size();\n                if(node == cur) break;\n            }\n            each_bcc.push_back(bcc);\n            roots.pop();\n        }\n    }\n    void fix(){\n        order.assign(N,-1); inS.assign(N,0); group.assign(N,-1);\n        while(S.size()) S.pop(); while(roots.size()) roots.pop();\n        int k = 0;\n        for(int i = 0; i < N;i++){\n            if(order[i] == -1) visit(i,-1,k);\n        }\n        \n        newG.resize(each_bcc.size());\n        for(int u = 0; u < N;u++){\n            for(int& v:G[u]){\n                if(group[u] == group[v]) continue;\n                newG[group[u]].push_back(group[v]);\n                newG[group[v]].push_back(group[u]);\n            }\n        }\n        for(int u = 0; u < each_bcc.size();u++){\n            sort(newG[u].begin(),newG[u].end());\n            newG[u].erase(unique(newG[u].begin(),newG[u].end()),newG[u].end());\n        }\n    }\n    \n    vector<vector<int>>& Get_each_bcc(){return each_bcc;}\n    vector<int>& Get_group(){return group;}\n    vector<pii>& Get_bridges(){ return bridges; }\n    vector<vector<int>>& Get_Graph(){return newG; }\n};\n\nvoid rec(ll n,ll prev,\n         vector<vector<int>>& G,\n         vector<ll>& Cost,\n         vector<vector<int>>& each_bcc,\n         vector<ll>& dp1,vector<ll>& dp2){\n    for(auto& next:G[n]){\n        if(next == prev) continue;\n        rec(next,n,G,Cost,each_bcc,dp1,dp2);\n        dp1[n] += dp1[next];\n    }\n    ll T = dp1[n];\n    if(dp1[n] || each_bcc[n].size() > 1) dp1[n] += Cost[n];\n    for(auto& next:G[n]){\n        if(next == prev) continue;\n        dp2[n] = max(dp2[n],T-dp1[next]+dp2[next]);\n    }\n    dp2[n] += Cost[n];\n}\nll solve(){\n    int N,M; cin >> N >> M;\n    vector<int> w(N); for(auto& in:w) cin >> in;\n    BCC bcc(N);\n    for(int i = 0; i < M;i++){\n        int u,v; cin >> u >> v; u--; v--;\n        bcc.add_edge(u, v);\n    }\n    bcc.fix();\n    auto group = bcc.Get_group();\n    auto G = bcc.Get_Graph();\n    auto each_bcc = bcc.Get_each_bcc();\n    vector<ll> Cost(G.size(),0);\n    for(int i = 0; i < N;i++){\n        Cost[group[i]] += w[i];\n    }\n    int root = group[0];\n    vector<ll> dp1(G.size(),0),dp2(G.size(),0);\n    rec(root,-1,G,Cost,each_bcc,dp1,dp2);\n    return dp2[root];\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    cout << solve() << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n#define MAX 100005\n\nint p[MAX];\n\nint find(int x){\n  if(p[x]==x)return x;\n  return p[x]=find(p[x]);\n}\n\nvoid unite(int x,int y){\n  x=find(x);y=find(y);\n  if(x==y)return;\n  p[x]=y;\n}\n\nbool same(int x,int y){\n  return (find(x)==find(y));\n}\n\nint V,E;\nvector<int> G[MAX];\nvector<int> nG[MAX];\nmap<int,bool> used[MAX];\n\nint s[MAX],t[MAX];\nint depth[MAX];\nint cnt[MAX];\nint visited[MAX];\n\n\n\nvoid dfs(int pos,int prev){\n  visited[pos]=true;\n  for(int i=0;i<(int)G[pos].size();i++){\n    int to=G[pos][i];\n    if(to==prev)continue;\n    if(!visited[to]){\n      depth[to]=depth[pos]+1;\n      dfs(to,pos);\n      cnt[pos]+=cnt[to];\n      if(cnt[to])unite(pos,to);\n    }else if(depth[to]<depth[pos]){\n      unite(pos,to);\n      cnt[pos]++;\n      cnt[to]--;\n    }\n  }\n}\n\nint solve(int pos,int prev=-1){\n  int res=0;\n  for(int i=0;i<(int)nG[pos].size();i++){\n    int to=nG[pos][i];\n    if(to==prev || to==pos)continue;\n    res=max(res,solve(to,pos));\n  }\n  return res+t[pos];\n}\n\nint main(){\n  scanf(\"%d %d\",&V,&E);\n  for(int i=0;i<V;i++){\n    scanf(\"%d\",&s[i]);\n    p[i]=i;\n  }\n  for(int i=0;i<E;i++){\n    int a,b;\n    scanf(\"%d %d\",&a,&b);\n    a--,b--;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n  dfs(0,-1);\n  for(int pos=0;pos<V;pos++){\n\n    for(int i=0;i<(int)G[pos].size();i++){\n      int to=find(G[pos][i]);\n      if(used[pos].count(to)>0)continue;\n      used[pos][to]=true;\n      nG[ find(pos) ].push_back( to );\n    }\n    t[ find(pos) ]+=s[pos];\n  }\n  \n  printf(\"%d\\n\",solve( find(0) ));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing Weight=long long;\n\nstruct Edge{\n    int src,dst;\n    Edge(int src,int dst):\n    src(src),dst(dst){}\n};\n\nusing Edges=vector<Edge>;\nusing Graph=vector<Edges>;\n\nint memo[100001];\n\npair<vector<int>, Edges> bridge(const Graph& g) {\n\tconst int n = g.size();\n\tint idx = 0, s = 0, t = 0, k = 0;\n\tvector<int>ord(n, -1), onS(n), stk(n), roots(n), cmp(n);\n\tEdges brdg;\n\tfunction<void(int, int)> dfs = [&](int v, int u) {\n\t\tord[v] = idx++;\n\t\tstk[s++] = v;\n\t\tonS[v] = true;\n\t\troots[t++] = v;\n\t\tfor (auto& e : g[v]) {\n\t\t\tint w = e.dst;\n\t\t\tif (ord[w] == -1)dfs(w, v);\n\t\t\telse if (u != w && onS[w])\n\t\t\t\twhile (ord[roots[t - 1]]>ord[w])--t;\n\t\t}\n\t\tif (v == roots[t - 1]) {\n\t\t\tbrdg.emplace_back(u, v);\n\t\t\twhile (true) {\n\t\t\t\tint w = stk[--s];\n\t\t\t\tonS[w] = false;\n\t\t\t\tcmp[w] = k;\n\t\t\t\tif (v == w)break;\n\t\t\t}\n\t\t\t--t;\n\t\t\t++k;\n\t\t}\n\t};\n\tfor (int u = 0; u<n; ++u) {\n\t\tif (ord[u] == -1) {\n\t\t\tdfs(u, n);\n\t\t\tbrdg.pop_back();\n\t\t}\n\t}\n\treturn make_pair(cmp, brdg);\n}\n\nbool dfs0(const Graph &g,int p,int v,vector<bool> &elect,\nvector<int>&elements,vector<int>&cycle){\n    for(auto e:g[v]){\n        if(e.dst==p)continue;\n        if(elements[cycle[e.dst]]>1 || elect[e.dst])return elect[v]=1;\n        if(dfs0(g,v,e.dst,elect,elements,cycle))return elect[v]=1;\n    }\n    return 0;\n}\n\nint dfs1(const Graph &g,int p,int v,vector<bool> &elect,\nvector<int>&elements,vector<int>&cycle,vector<Weight>&node){\n    if(memo[v])return memo[v];\n    int res=0;\n    for(auto e:g[v]){\n        if(elect[e.dst]){\n            return memo[v]=node[v];\n        }\n        if(e.dst!=p && elements[cycle[e.dst]]==1){\n            res=dfs1(g,v,e.dst,elect,elements,cycle,node);\n            if(res){\n                return memo[v]=res+node[v];\n            }\n        }\n    }\n    return 0;\n}\n\nint main(){\n    int n,m;\n    cin>>n>>m;\n    Graph g(n);\n    vector<Weight>node(n);\n    for(int i=0;i<n;++i){\n        cin>>node[i];\n    }\n    for(int i=0;i<m;++i){\n        int s,t;\n        cin>>s>>t;\n        --s;--t;\n        g[s].emplace_back(s,t);\n        g[t].emplace_back(t,s);\n    }\n    vector<int>cycle = bridge(g).first;\n    vector<int>elements(n,0);\n    for(int i=0;i<n;++i){\n        elements[cycle[i]]++;\n    }\n    vector<bool>elect(n,false);\n    elect[0]=true;\n    for(int i=1;i<n;++i){\n        if(elements[cycle[i]]>1){\n            dfs0(g,-1,i,elect,elements,cycle);\n        }\n    }\n    int buf=0;\n    for(int i=1;i<n;++i){\n        if(g[i].size()==1){\n            buf=max(buf,dfs1(g,-1,g[i][0].src,elect,elements,cycle,node));\n        }\n    }\n    int ans=0;\n    for(int i=0;i<n;++i){\n        if(elect[i]){\n            ans+=node[i];\n        }\n    }\n    ans+=buf;\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<utility>\n#include<set>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define MP make_pair\n#define PB push_back\nusing namespace std;\n\nint n,m;\n\nvoid bfs(int k,vector<int> &cnt,vector<bool>&b,vector<vector<int> > &g){\n    if(cnt[k]==1||cnt[k]==0){\n        b[k] = 0;\n        for(int i:g[k]){\n            if(b[i]){\n                cnt[i]--;\n                bfs(i,cnt,b,g);\n            }\n        }\n    }   \n}\nbool bfs3(int k,int z,vector<bool>&b,vector<vector<int> > &g){\n    if(b[k])return true;\n    for(int x:g[k]){\n        if(x!=z){\n            if(bfs3(x,k,b,g))return b[k]=true;\n        }\n    } \n    return false;\n}\nint bfs2(int k,int z,vector<int>&w,vector<vector<int> > &g){\n    int s=w[k];\n    int mx = 0;\n    for(int x:g[k]){\n        if(x!=z){\n            mx = max(mx,bfs2(x,k,w,g));\n        }\n    }\n    return s+mx;\n}\n\n\nint main(){\n    cin >> n >> m;\n    vector<int> w(n+1);\n    vector<vector<int> > g(n);\n    rep(i,n)cin >> w[i];\n    rep(i,m){\n        int u,v;\n        cin >> u >> v;\n        u--;v--;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    vector<int> cnt(n);\n    rep(i,n){\n        cnt[i] = g[i].size();\n    }\n    vector<bool> b(n,1);\n    rep(i,n){\n        bfs(i,cnt,b,g);\n    }\n    if(!b[0]){\n        bfs3(0,0,b,g);\n    }\n    vector<int>p;\n    int sm=0;\n    rep(i,n){\n        if(b[i]){\n            p.PB(i);\n            sm+=w[i];\n        }\n    }\n    w[n]=sm;\n    set<int>st;\n    for(int x:p){\n        for(int y:g[x]){\n            st.insert(y);\n        }\n    }\n    vector<vector<int> >g2(n+1);\n    rep(i,n){\n        if(!b[i]){\n            for(int x:g[i]){\n                if(b[x]){\n                    g2[i].PB(n);\n                    g2[n].PB(i);\n                }else{\n                    g2[i].PB(x);\n                }\n            }\n        }\n    }\n    if(b[0]){\n        cout << bfs2(n,n,w,g2) << endl;\n    }else{\n        cout << bfs2(0,0,w,g2) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_V 114514\ntypedef pair<int,int> P;\nvector<vector<int> > G,C,T;\n//vector<int> G[MAX_V],C[MAX_V],T[MAX_V];\nvector<int> ord,low,belong;\nvector<P> B;\nint V,K;\nbool is_bridge(int u,int v){\n  if(ord[u]>ord[v]) swap(u,v);\n  return ord[u]<low[v];\n}\nvoid dfs(int u,int p,int d=0){\n  //cout<<u<<\" \"<<p<<\" \"<<d<<endl;\n  ord[u]=low[u]=K;\n  K++;\n  for(int v:G[u]){\n    if(v==p) continue;\n    if(ord[v]>=0){\n      low[u]=min(low[u],ord[v]);\n    }else{\n      dfs(v,u,d+1);\n      low[u]=min(low[u],low[v]);\n    }\n    if(is_bridge(u,v)) B.push_back(P(u,v));\n  }\n}\nvoid fill_component(int c,int u){\n  C[c].push_back(u);\n  belong[u]=c;\n  for(int v:G[u]){\n    if(belong[v]>=0||is_bridge(u,v)) continue;\n    fill_component(c,v);\n  }\n}\nvoid add_component(int u){\n  if(belong[u]>=0) return;\n  C.emplace_back();\n  fill_component(C.size()-1,u);\n}\n\nvoid biconnectedgraph(int n){\n  K=0;\n  ord.clear();\n  ord.resize(n,-1);\n  low.clear();\n  low.resize(n);\n  belong.clear();\n  belong.resize(n,-1);\n  //puts(\"OK2\");\n  for(int v=0;v<n;v++){\n    if(ord[v]>=0) continue;\n    //cout<<v<<endl;\n    dfs(v,-1);\n  }\n  //puts(\"OK3\");\n  C.clear();\n  for(int i=0;i<(int)B.size();i++){\n    add_component(B[i].first);\n    add_component(B[i].second);\n  }\n  add_component(0);\n  V=C.size();\n  T.clear();\n  T.resize(V);\n  for(int i=0;i<(int)B.size();i++){\n    int u=belong[B[i].first],v=belong[B[i].second];\n    T[u].push_back(v);\n    T[v].push_back(u);\n  }\n}\n\nvoid add_edge(int u,int v){\n  G[u].push_back(v);\n  G[v].push_back(u);\n}\n\nint wei[MAX_V],memo[MAX_V];\nbool used[MAX_V],dele[MAX_V];\nbool flag=0;\nint root;\nint xyz;\nvoid dfs2(int v,int p){\n  used[v]=1;\n  if(v!=root&&(int)C[v].size()>1){\n    if(v==xyz) xyz=root;\n    flag=1;\n    dele[v]=1;\n    for(int k:T[v])\n      T[root].push_back(k);\n    wei[root]+=wei[v];\n    return;\n  }\n  for(int i=0;i<(int)T[v].size();i++){\n    int u=T[v][i];\n    if(u==p) continue;\n    if(used[u]) continue;\n    dfs2(u,v);\n    if(flag){\n      if(~p){\n\tif(v==xyz) xyz=root;\n\tdele[v]=1;\n\tfor(int k:T[v])\n\t  T[root].push_back(k);\n\twei[root]+=wei[v];\n\treturn;\n      }else{\n\tflag=0;\n      }\n    }\n  }\n}\n\nint dfs3(int v,int p){\n  int res=wei[v];\n  for(int u:T[v]){\n    if(dele[u]||u==p) continue;\n    res=max(res,wei[v]+dfs3(u,v));\n  }\n  //if(p==xyz) cout<<v<<\" \"<<res<<endl;\n  return res;\n}\npriority_queue<int> tmp;\nint ans=0;\nbool flag2=0;\nint dfs4(int v,int p){\n  //cout<<v<<\" \"<<p<<endl;\n  if(~memo[v]) return memo[v];\n  if(v==root){\n    flag2=1;\n    ans+=wei[v];\n    for(int u:T[v]) if(u!=p) tmp.push(dfs3(u,v));\n    return 0;\n  }\n  int res=wei[v];\n  for(int u:T[v]){\n    if(dele[u]||u==p) continue;\n    res=max(res,wei[v]+dfs4(u,v));\n    if(flag2){\n      ans+=wei[v];\n      for(int k:T[v])\n\tif(u!=k&&k!=p) tmp.push(dfs3(k,v));\n      break;\n    }\n  }\n  return memo[v]=res;\n}\nsigned main(){\n  int n,m;\n  cin>>n>>m;\n  G.clear();\n  G.resize(n);\n  int w[n];\n  for(int i=0;i<n;i++) cin>>w[i];\n  for(int i=0;i<m;i++){\n    int u,v;\n    cin>>u>>v;\n    u--;v--;\n    add_edge(u,v);\n  }\n  //puts(\"OK1\");\n  biconnectedgraph(n);\n  //puts(\"OK\");\n  root=-1;\n  for(int i=0;i<V;i++){\n    for(int j=0;j<(int)C[i].size();j++){\n      wei[i]+=w[C[i][j]];\n      //w[C[i][j]]=0;\n      if(j>0) root=i;\n      if(C[i][j]==0) xyz=i;\n    }\n    //if(C[i].size()>1) cout<<i<<\" \"<<C[i].size()<<\":\"<<wei[i]<<endl; \n    //cout<<i<<\":\"<<wei[i]<<endl;\n  }\n  //for(int i=0;i<n;i++) assert(!w[i]);\n  //cout<<C[xyz].size()<<\":\";for(int i:C[xyz]) cout<<\" \"<<i;cout<<endl;\n  //cout<<wei[xyz]<<endl;\n  if(~root) dfs2(root,-1);\n  for(int i=0;i<V;i++) assert(used[i]);\n  //cout<<root<<\"-\"<<xyz<<endl;\n  if(root==xyz) cout<<dfs3(xyz,-1)<<endl;\n  else{\n    memset(memo,-1,sizeof(memo));\n    dfs4(xyz,-1);\n    if(!tmp.empty()) ans+=tmp.top();\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing i64 = int64_t;\n\nconst i64 MOD = 1e9 + 7;\n\n\nstruct UnionFind{\n    vector<int> par;\n    int siz;\n    UnionFind(int n) : par(n, -1), siz(n){}\n    int Find(int x){return par[x] < 0 ? x : Find(par[x]);}\n    bool Unite(int x, int y){\n        x = Find(x);\n        y = Find(y);\n        if(x == y)\n            return false;\n        if(par[x] > par[y])\n            swap(x, y);\n        par[x] += par[y];\n        par[y] = x;\n        return siz--;\n    }\n};\n\nstruct LowLink{\n    vector<vector<int>>& edges;\n    // 関節点\n    vector<int> art;\n    vector<pair<int,int>> bridge;\n\n    vector<int> used, ord, low;\n    int k;\n\n    void dfs(int idx, int par){\n        ord[idx] = k++;\n        low[idx] = ord[idx];\n        bool is_art = false;\n        int cnt = 0;\n        for(auto& to : edges[idx]){\n            if(ord[to] == -1){\n                ++cnt;\n                dfs(to, idx);\n                low[idx] = min(low[idx], low[to]);\n                is_art |= !par && low[to] >= ord[idx];\n                if(ord[idx] < low[to])\n                    bridge.emplace_back(idx, to);\n            }else if(to != par)\n                low[idx] = min(low[idx], ord[to]);\n        }\n        is_art |= (par == -1 && cnt > 1);\n        if(is_art)\n            art.emplace_back(idx);\n    }\n\n    LowLink(vector<vector<int>>& edges) :\n        edges(edges),\n        ord(edges.size(), -1),\n        low(edges.size(), 0),\n        k(0)\n    {\n        for(int i = 0; i < edges.size(); ++i)\n            if(ord[i] == -1)\n                dfs(i, -1);\n        for(auto& b : bridge)\n            b = make_pair(min(b.first, b.second), max(b.first, b.second));\n        sort(art.begin(), art.end());\n        sort(bridge.begin(), bridge.end());\n    }\n};\n\nsigned main(){\n    int n, m;\n    cin >> n >> m;\n    vector<int> a(n);\n    for(auto& x : a)\n        cin >> x;\n    vector<int> u(m), v(m);\n    vector<vector<int>> edges(n);\n    for(int i = 0; i < m; i++){\n        cin >> u[i] >> v[i];\n        --u[i], --v[i];\n        int uu = u[i], vv = v[i];\n        u[i] = min(uu, vv);\n        v[i] = max(uu, vv);\n        edges[u[i]].emplace_back(v[i]);\n        edges[v[i]].emplace_back(u[i]);\n    }\n\n    UnionFind uf(n);\n    auto ll = LowLink(edges);\n    for(int i = 0; i < m; ++i){\n        auto it = lower_bound(ll.bridge.begin(), ll.bridge.end(), make_pair(u[i], v[i]));\n        if(it == ll.bridge.end() || *it != make_pair(u[i], v[i]))\n            uf.Unite(u[i], v[i]);\n    }\n    int siz = 0;\n    map<int,int> tai;\n    for(int i = 0; i < n; ++i)\n        if(tai.find(uf.Find(i)) == tai.end())\n            tai[uf.Find(i)] = siz++;\n    vector<vector<int>> tr(siz), childs(siz);\n    vector<int> score(siz, 0);\n    vector<int> size(siz, 0);\n    for(int i = 0; i < n; ++i){\n        score[tai[uf.Find(i)]] += a[i];\n        ++size[tai[uf.Find(i)]];\n    }\n    for(int i = 0; i < m; ++i){\n        if(uf.Find(u[i]) != uf.Find(v[i])){\n            int uu = tai[uf.Find(u[i])];\n            int vv = tai[uf.Find(v[i])];\n            tr[uu].emplace_back(vv);\n            tr[vv].emplace_back(uu);\n        }\n    }\n\n    vector<int> used(siz, -1);\n    vector<int> value(siz, 0);\n    int ans = 0;\n    int dif = 0;\n    function<void(int)> f = [&](int from){\n        if(used[from] == -1)\n            used[from] = (size[from] >= 2);\n        for(auto& to : tr[from])\n            if(used[to] == -1){\n                f(to);\n                used[from] |= used[to];\n                childs[from].emplace_back(to);\n            }\n        if(used[from])\n            ans += score[from];\n    };\n    used[0] = 1;\n    f(0);\n\n    function<void(int)> g = [&](int from){\n        for(auto& to : childs[from])\n            g(to);\n        if(used[from] == false){\n            value[from] = score[from];\n            int add = 0;\n            for(auto& to : childs[from]){\n                add = max(add, value[to]);\n            }\n            value[from] += add;\n            dif = max(dif, value[from]);\n        }\n    };\n    g(0);\n    cout << ans + dif << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-5L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n#define MOD 998244353LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\n// geometry library\n\n#define int long long\n\ntypedef complex<long double> Point;\ntypedef pair<complex<long double>, complex<long double>> Line;\n\ntypedef struct Circle {\n    complex<long double> center;\n    long double r;\n}Circle;\n\nlong double dot(Point a, Point b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\nlong double cross(Point a, Point b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\nlong double Dist_Line_Point(Line a, Point b) {\n    if (dot(a.second - a.first, b - a.first) < eps) return abs(b - a.first);\n    if (dot(a.first - a.second, b - a.second) < eps) return abs(b - a.second);\n    return abs(cross(a.second - a.first, b - a.first)) / abs(a.second - a.first);\n}\n\nint is_intersected_ls(Line a, Line b) {\n    return (cross(a.second - a.first, b.first - a.first) * cross(a.second - a.first, b.second - a.first) < eps) &&\n        (cross(b.second - b.first, a.first - b.first) * cross(b.second - b.first, a.second - b.first) < eps);\n}\n\nPoint intersection_l(Line a, Line b) {\n    Point da = a.second - a.first;\n    Point db = b.second - b.first;\n    return a.first + da * cross(db, b.first - a.first) / cross(db, da);\n}\n\nlong double Dist_Line_Line(Line a, Line b) {\n    if (is_intersected_ls(a, b) == 1) {\n        return 0;\n    }\n    return min({ Dist_Line_Point(a,b.first), Dist_Line_Point(a,b.second),Dist_Line_Point(b,a.first),Dist_Line_Point(b,a.second) });\n}\n\npair<Point, Point> intersection_Circle_Circle(Circle a, Circle b) {\n    long double dist = abs(a.center - b.center);\n    assert(dist <= eps + a.r + b.r);\n    assert(dist + eps >= abs(a.r - b.r));\n    Point target = b.center - a.center;\n    long double pointer = target.real() * target.real() + target.imag() * target.imag();\n    long double aa = pointer + a.r * a.r - b.r * b.r;\n    aa /= 2.0L;\n    Point l{ (aa * target.real() + target.imag() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer,\n            (aa * target.imag() - target.real() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer };\n    Point r{ (aa * target.real() - target.imag() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer,\n        (aa * target.imag() + target.real() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer };\n    r = r + a.center;\n    l = l + a.center;\n    return mp(l, r);\n}\n\n//end of geometry\n\ntemplate<typename A>\nA pows(A val, ll b) {\n    assert(b >= 1);\n    A ans = val;\n    b--;\n    while (b) {\n        if (b % 2) {\n            ans *= val;\n        }\n        val *= val;\n        b /= 2LL;\n    }\n    return ans;\n}\n\ntemplate<typename A>\nclass Compressor {\npublic:\n    bool is_zipped = false;\n    map<A, ll> zipper;\n    map<ll, A> unzipper;\n    queue<A> fetcher;\n    Compressor() {\n        is_zipped = false;\n        zipper.clear();\n        unzipper.clear();\n    }\n    void add(A now) {\n        assert(is_zipped == false);\n        zipper[now] = 1;\n        fetcher.push(now);\n    }\n    void exec() {\n        assert(is_zipped == false);\n        int cnt = 0;\n        for (auto i = zipper.begin(); i != zipper.end(); ++i) {\n            i->second = cnt;\n            unzipper[cnt] = i->first;\n            cnt++;\n        }\n        is_zipped = true;\n    }\n    ll fetch() {\n        assert(is_zipped == true);\n        A hoge = fetcher.front();\n        fetcher.pop();\n        return zipper[hoge];\n    }\n    ll zip(A now) {\n        assert(is_zipped == true);\n        assert(zipper.find(now) != zipper.end());\n        return zipper[now];\n    }\n    A unzip(ll a) {\n        assert(is_zipped == true);\n        assert(a < unzipper.size());\n        return unzipper[a];\n    }\n    ll next(A now) {\n        auto x = zipper.upper_bound(now);\n        if (x == zipper.end()) return zipper.size();\n        return (ll)((*x).second);\n    }\n    ll back(A now) {\n        auto x = zipper.lower_bound(now);\n        if (x == zipper.begin()) return -1;\n        x--;\n        return (ll)((*x).second);\n    }\n};\n\ntemplate<typename A>\nclass Matrix {\npublic:\n    vector<vector<A>> data;\n    Matrix(vector<vector<A>> a) :data(a) {\n\n    }\n    Matrix operator + (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data.size());\n        assert(obj.data[0].size() == this->data[0].size());\n        REP(i, obj.data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[i].size()) {\n                A hoge = obj.data[i][q] + (this->data[i][q]);\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix operator - (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data.size());\n        assert(obj.data[0].size() == this->data[0].size());\n        REP(i, obj.data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[i].size()) {\n                A hoge = this->data[i][q] - obj.data[i][q];\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix operator * (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data[0].size());\n        REP(i, this -> data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[0].size()) {\n                A hoge = (this->data[i][0]) * (obj.data[0][q]);\n                for (int t = 1; t < obj.data[i].size(); ++t) {\n                    hoge += this->data[i][t] * obj.data[t][q];\n                }\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix& operator *= (const Matrix obj) {\n        *this = (*this * obj);\n        return *this;\n    }\n    Matrix& operator += (const Matrix obj) {\n        *this = (*this + obj);\n        return *this;\n    }\n    Matrix& operator -= (const Matrix obj) {\n        *this = (*this - obj);\n        return *this;\n    }\n};\n\ntemplate <std::uint_fast64_t mod>\nclass modint {\npublic:\n    using u64 = std::uint_fast64_t;\n    u64 value = 0;\n    modint(ll a) : value(((a% mod) + 2 * mod) % mod) {\n\n    }\n\n    constexpr modint operator+(const modint rhs) const {\n        return modint(*this) += rhs;\n    }\n    constexpr modint operator-(const modint rhs) const {\n        return modint(*this) -= rhs;\n    }\n    constexpr modint operator*(const modint rhs) const {\n        return modint(*this) *= rhs;\n    }\n    constexpr modint operator/(const modint rhs) const {\n        return modint(*this) /= rhs;\n    }\n    constexpr modint& operator+=(const modint rhs) {\n        value += rhs.value;\n        if (value >= mod) {\n            value -= mod;\n        }\n        return *this;\n    }\n    constexpr modint& operator-=(const modint rhs) {\n        if (value < rhs.value) {\n            value += mod;\n        }\n        value -= rhs.value;\n        return *this;\n    }\n    constexpr modint& operator*=(const modint rhs) {\n        value = (value * rhs.value) % mod;\n        return *this;\n    }\n    constexpr modint& operator/=(modint rhs) {\n        ll rem = mod - 2;\n        while (rem) {\n            if (rem % 2) {\n                *this *= rhs;\n            }\n            rhs *= rhs;\n            rem /= 2LL;\n        }\n        return *this;\n    }\n    bool operator <(modint rhs) const {\n        return value < rhs.value;\n    }\n    friend ostream& operator<<(ostream& os, modint& p) {\n        os << p.value;\n        return (os);\n    }\n};\n\nclass Dice {\npublic:\n    vector<ll> vertexs;\n    //Up: 0,Left: 1,Center: 2,Right: 3,Adj: 4, Down: 5\n    Dice(vector<ll> init) :vertexs(init) {\n\n    }\n    //Look from Center\n    void RtoL() {\n        for (int q = 1; q < 4; ++q) {\n            swap(vertexs[q], vertexs[q + 1]);\n        }\n    }\n    void LtoR() {\n        for (int q = 3; q >= 1; --q) {\n            swap(vertexs[q], vertexs[q + 1]);\n        }\n    }\n    void UtoD() {\n        swap(vertexs[5], vertexs[4]);\n        swap(vertexs[2], vertexs[5]);\n        swap(vertexs[0], vertexs[2]);\n    }\n    void DtoU() {\n        swap(vertexs[0], vertexs[2]);\n        swap(vertexs[2], vertexs[5]);\n        swap(vertexs[5], vertexs[4]);\n    }\n    bool ReachAble(Dice now) {\n        set<Dice> hoge;\n        queue<Dice> next;\n        next.push(now);\n        hoge.insert(now);\n        while (next.empty() == false) {\n            Dice seeing = next.front();\n            next.pop();\n            if (seeing == *this) return true;\n            seeing.RtoL();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n            seeing.LtoR();\n            seeing.LtoR();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n            seeing.RtoL();\n            seeing.UtoD();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n            seeing.DtoU();\n            seeing.DtoU();\n            if (hoge.count(seeing) == 0) {\n                hoge.insert(seeing);\n                next.push(seeing);\n            }\n        }\n        return false;\n    }\n    bool operator ==(const Dice& a) {\n        for (int q = 0; q < 6; ++q) {\n            if (a.vertexs[q] != (*this).vertexs[q]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    bool operator <(const Dice& a) const {\n        return (*this).vertexs < a.vertexs;\n    }\n};\n\npair<Dice, Dice> TwoDimDice(int center, int up) {\n    int target = 1;\n    while (true) {\n        if (center != target && 7 - center != target && up != target && 7 - up != target) {\n            break;\n        }\n        target++;\n    }\n    return mp(Dice(vector<ll>{up, target, center, 7 - target, 7 - center, 7 - up}), Dice(vector<ll>{up, 7 - target, center, target, 7 - center, 7 - up}));\n}\n\ntuple<Dice, Dice, Dice, Dice> OneDimDice(int center) {\n    int bo = min(center, 7 - center);\n    pair<int, int> goa;\n    if (bo == 1) {\n        goa = mp(2, 3);\n    }\n    else if (bo == 2) {\n        goa = mp(1, 3);\n    }\n    else if (bo == 3) {\n        goa = mp(1, 2);\n    }\n    tuple<Dice, Dice, Dice, Dice> now = make_tuple(Dice(vector<ll>{goa.first, goa.second, center, 7 - goa.second, 7 - center, 7 - goa.first}),\n        Dice(vector<ll>{goa.first, 7 - goa.second, center, goa.second, 7 - center, 7 - goa.first}),\n        Dice(vector<ll>{7 - goa.first, goa.second, center, 7 - goa.second, 7 - center, goa.first}),\n        Dice(vector<ll>{7 - goa.first, 7 - goa.second, center, goa.second, 7 - center, goa.first}));\n    return now;\n}\n\ntemplate<typename A, typename B>\nclass Dijkstra {\npublic:\n    vector<vector<pair<int, A>>> vertexs;\n    B Cost_Function;\n    Dijkstra(int n, B cost) : Cost_Function(cost) {\n        vertexs = vector<vector<pair<int, A>>>(n, vector<pair<int, A>>{});\n    }\n    ~Dijkstra() {\n        vertexs.clear();\n    }\n    void add_edge(int a, int b, A c) {\n        vertexs[a].push_back(mp(b, c));\n    }\n    vector<ll> build_result(int StartPoint) {\n        vector<ll> dist(vertexs.size(), 2e18);\n        dist[StartPoint] = 0;\n        priority_queue<pair<ll, int>, vector<pair<ll, int>>, greater<pair<ll, int>>> next;\n        next.push(make_pair(0, StartPoint));\n        while (next.empty() == false) {\n            pair<ll, int> now = next.top();\n            next.pop();\n            if (dist[now.second] != now.first) continue;\n            for (auto x : vertexs[now.second]) {\n                ll now_cost = now.first + Cost_Function(x.second);\n                if (dist[x.first] > now_cost) {\n                    dist[x.first] = now_cost;\n                    next.push(mp(now_cost, x.first));\n                }\n            }\n        }\n        return dist;\n    }\n};\n\nclass Dinic {\npublic:\n    struct edge {\n        int to;\n        int cap;\n        int rev;\n    };\n    vector<vector<edge>> Graph;\n    vector<int> level;\n    vector<int> itr;\n    Dinic(int n) {\n        Graph = vector<vector<edge>>(n, vector<edge>());\n    }\n    void add_edge(int a, int b, int cap) {\n        Graph[a].push_back(edge{ b, cap ,(int)Graph[b].size() });\n        Graph[b].push_back(edge{ a,0,(int)Graph[a].size() - 1 });\n    }\n    void bfs(int s) {\n        level = vector<int>(Graph.size(), -1);\n        level[s] = 0;\n        queue<int> next;\n        next.push(s);\n        while (next.empty() == false) {\n            int now = next.front();\n            next.pop();\n            for (auto x : Graph[now]) {\n                if (x.cap == 0) continue;\n                if (level[x.to] == -1) {\n                    level[x.to] = level[now] + 1;\n                    next.push(x.to);\n                }\n            }\n        }\n    }\n    int dfs(int now, int goal, int val) {\n        if (goal == now) return val;\n        for (int& i = itr[now]; i < (int)Graph[now].size(); ++i) {\n            edge& target = Graph[now][i];\n            if (target.cap > 0 && level[now] < level[target.to]) {\n                int d = dfs(target.to, goal, min(val, target.cap));\n                if (d > 0) {\n                    target.cap -= d;\n                    Graph[target.to][target.rev].cap += d;\n                    return d;\n                }\n            }\n        }\n        return 0;\n    }\n    int run(int s, int t) {\n        int ans = 0;\n        int f = 0;\n        while (bfs(s), level[t] >= 0) {\n            itr = vector<int>(Graph.size(), 0);\n            while ((f = dfs(s, t, 1e9)) > 0) {\n                ans += f;\n            }\n        }\n        return ans;\n    }\n};\n\n\nclass HLDecomposition {\npublic:\n    vector<vector<int>> vertexs;\n    vector<int> depth;\n    vector<int> backs;\n    vector<int> connections;\n    vector<int> zip, unzip;\n    HLDecomposition(int n) {\n        vertexs = vector<vector<int>>(n, vector<int>());\n        depth = vector<int>(n);\n        zip = vector<int>(n);\n        unzip = zip;\n    }\n    void add_edge(int a,int b) {\n        vertexs[a].push_back(b);\n        vertexs[b].push_back(a);\n    }\n    int depth_dfs(int now, int back) {\n        depth[now] = 0;\n        for (auto x : vertexs[now]) {\n            if (x == back) continue;\n            depth[now] = max(depth[now], 1 + depth_dfs(x, now));\n        }\n        return depth[now];\n    }\n    void dfs(int now,int backing) {\n        zip[now] = backs.size();\n        unzip[backs.size()] = now;\n        backs.push_back(backing);\n        int now_max = -1;\n        int itr = -1;\n        for (auto x : vertexs[now]) {\n            if (depth[x] > depth[now]) continue;\n            if (now_max < depth[x]) {\n                now_max = depth[x];\n                itr = x;\n            }\n        }\n        if (itr == -1) return;\n        connections.push_back(connections.back());\n        dfs(itr,backing);\n        for (auto x : vertexs[now]) {\n            if (depth[x] > depth[now]) continue;\n            if (x == itr) continue;\n            connections.push_back(zip[now]);\n            dfs(x, backs.size());\n        }\n        return;\n    }\n    void build() {\n        depth_dfs(0, -1);\n        connections.push_back(-1);\n        dfs(0, -1);\n    }\n    vector<pair<int,int>> query(int a, int b) {\n        a = zip[a];\n        b = zip[b];\n        vector<pair<int, int>> ans;\n        while (backs[a] != backs[b]) {\n            if (a < b) swap(a, b);\n            ans.push_back(mp(backs[a], a + 1));\n            a = connections[a];\n        }\n        if (a > b) swap(a, b);\n        ans.push_back(mp(a, b + 1));\n        return ans;\n    } \n    int lca(int a, int b) {\n        a = zip[a];\n        b = zip[b];\n        while (backs[a] != backs[b]) {\n            if (a < b) swap(a, b);\n            a = connections[a];\n        }\n        return unzip[min(a, b)];\n    }\n};\n//by ei1333\n//https://ei1333.github.io/luzhiled/snippets/structure/segment-tree.html\ntemplate< typename Monoid >\nstruct SegmentTree {\n    using F = function< Monoid(Monoid, Monoid) >;\n\n    int sz;\n    vector< Monoid > seg;\n\n    const F f;\n    const Monoid M1;\n\n    SegmentTree(int n, const F f, const Monoid& M1) : f(f), M1(M1) {\n        sz = 1;\n        while (sz < n) sz <<= 1;\n        seg.assign(2 * sz + 1, M1);\n    }\n\n    void set(int k, const Monoid& x) {\n        seg[k + sz] = x;\n    }\n\n    void build() {\n        for (int k = sz - 1; k > 0; k--) {\n            seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n        }\n    }\n\n    void update(int k, const Monoid& x) {\n        k += sz;\n        seg[k] = x;\n        while (k >>= 1) {\n            seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n        }\n    }\n\n    Monoid query(int a, int b) {\n        Monoid L = M1, R = M1;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) L = f(L, seg[a++]);\n            if (b & 1) R = f(seg[--b], R);\n        }\n        return f(L, R);\n    }\n\n    Monoid operator[](const int& k) const {\n        return seg[k + sz];\n    }\n\n    template< typename C >\n    int find_subtree(int a, const C& check, Monoid& M, bool type) {\n        while (a < sz) {\n            Monoid nxt = type ? f(seg[2 * a + type], M) : f(M, seg[2 * a + type]);\n            if (check(nxt)) a = 2 * a + type;\n            else M = nxt, a = 2 * a + 1 - type;\n        }\n        return a - sz;\n    }\n\n\n    template< typename C >\n    int find_first(int a, const C& check) {\n        Monoid L = M1;\n        if (a <= 0) {\n            if (check(f(L, seg[1]))) return find_subtree(1, check, L, false);\n            return -1;\n        }\n        int b = sz;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) {\n                Monoid nxt = f(L, seg[a]);\n                if (check(nxt)) return find_subtree(a, check, L, false);\n                L = nxt;\n                ++a;\n            }\n        }\n        return -1;\n    }\n\n    template< typename C >\n    int find_last(int b, const C& check) {\n        Monoid R = M1;\n        if (b >= sz) {\n            if (check(f(seg[1], R))) return find_subtree(1, check, R, true);\n            return -1;\n        }\n        int a = sz;\n        for (b += sz; a < b; a >>= 1, b >>= 1) {\n            if (b & 1) {\n                Monoid nxt = f(seg[--b], R);\n                if (check(nxt)) return find_subtree(b, check, R, true);\n                R = nxt;\n            }\n        }\n        return -1;\n    }\n};\n\ntemplate< typename Monoid, typename OperatorMonoid = Monoid >\nstruct LazySegmentTree {\n    using F = function< Monoid(Monoid, Monoid) >;\n    using G = function< Monoid(Monoid, OperatorMonoid,int) >;\n    using H = function< OperatorMonoid(OperatorMonoid, OperatorMonoid) >;\n\n    int sz, height;\n    vector< Monoid > data;\n    vector< OperatorMonoid > lazy;\n    const F f;\n    const G g;\n    const H h;\n    const Monoid M1;\n    const OperatorMonoid OM0;\n\n\n    LazySegmentTree(int n, const F f, const G g, const H h,\n        const Monoid& M1, const OperatorMonoid OM0)\n        : f(f), g(g), h(h), M1(M1), OM0(OM0) {\n        sz = 1;\n        height = 0;\n        while (sz < n) sz <<= 1, height++;\n        data.assign(2 * sz, M1);\n        lazy.assign(2 * sz, OM0);\n    }\n\n    void set(int k, const Monoid& x) {\n        data[k + sz] = x;\n    }\n\n    void build() {\n        for (int k = sz - 1; k > 0; k--) {\n            data[k] = f(data[2 * k + 0], data[2 * k + 1]);\n        }\n    }\n\n    inline void propagate(int k) {\n        if (lazy[k] != OM0) {\n            lazy[2 * k + 0] = h(lazy[2 * k + 0], lazy[k]);\n            lazy[2 * k + 1] = h(lazy[2 * k + 1], lazy[k]);\n            data[k] = reflect(k);\n            lazy[k] = OM0;\n        }\n    }\n\n    inline Monoid reflect(int k) {\n        if (lazy[k] == OM0) return data[k];\n        for (int q = sz; q >= 0; q /= 2) {\n            if (q & k) {\n                return g(data[k], lazy[k], sz / q);\n            }\n        }\n    }\n\n    inline void recalc(int k) {\n        while (k >>= 1) data[k] = f(reflect(2 * k + 0), reflect(2 * k + 1));\n    }\n\n    inline void thrust(int k) {\n        for (int i = height; i > 0; i--) propagate(k >> i);\n    }\n\n    void update(int a, int b, const OperatorMonoid& x) {\n        thrust(a += sz);\n        thrust(b += sz - 1);\n        for (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {\n            if (l & 1) lazy[l] = h(lazy[l], x), ++l;\n            if (r & 1) --r, lazy[r] = h(lazy[r], x);\n        }\n        recalc(a);\n        recalc(b);\n    }\n\n    Monoid query(int a, int b) {\n        thrust(a += sz);\n        thrust(b += sz - 1);\n        Monoid L = M1, R = M1;\n        for (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {\n            if (l & 1) L = f(L, reflect(l++));\n            if (r & 1) R = f(reflect(--r), R);\n        }\n        return f(L, R);\n    }\n\n    Monoid operator[](const int& k) {\n        return query(k, k + 1);\n    }\n\n    template< typename C >\n    int find_subtree(int a, const C& check, Monoid& M, bool type) {\n        while (a < sz) {\n            propagate(a);\n            Monoid nxt = type ? f(reflect(2 * a + type), M) : f(M, reflect(2 * a + type));\n            if (check(nxt)) a = 2 * a + type;\n            else M = nxt, a = 2 * a + 1 - type;\n        }\n        return a - sz;\n    }\n\n    template< typename C >\n    int find_first(int a, const C& check) {\n        Monoid L = M1;\n        if (a <= 0) {\n            if (check(f(L, reflect(1)))) return find_subtree(1, check, L, false);\n            return -1;\n        }\n        thrust(a + sz);\n        int b = sz;\n        for (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n            if (a & 1) {\n                Monoid nxt = f(L, reflect(a));\n                if (check(nxt)) return find_subtree(a, check, L, false);\n                L = nxt;\n                ++a;\n            }\n        }\n        return -1;\n    }\n\n\n    template< typename C >\n    int find_last(int b, const C& check) {\n        Monoid R = M1;\n        if (b >= sz) {\n            if (check(f(reflect(1), R))) return find_subtree(1, check, R, true);\n            return -1;\n        }\n        thrust(b + sz - 1);\n        int a = sz;\n        for (b += sz; a < b; a >>= 1, b >>= 1) {\n            if (b & 1) {\n                Monoid nxt = f(reflect(--b), R);\n                if (check(nxt)) return find_subtree(b, check, R, true);\n                R = nxt;\n            }\n        }\n        return -1;\n    }\n};\n\n\n\nunsigned long xor128() {\n    static unsigned long x = 123456789, y = 362436069, z = 521288629, w = 88675123;\n    unsigned long t = (x ^ (x << 11));\n    x = y; y = z; z = w;\n    return (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\n\nvoid init() {\n    iostream::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n}\n\nint cnt[200000];\nvector<int> vertexs[200000];\nint scores[200000];\nvector<int> seconds[200000];\nint dfs(int now,int back) {\n    int ans = 0;\n    for (auto x : seconds[now]) {\n        if (x == back) continue;\n        ans = max(ans, dfs(x, now));\n    }\n    return ans + scores[now];\n}\nvoid solve(){\n    int n, m;\n    cin >> n >> m;\n    REP(i, n) {\n        cin >> scores[i];\n    }\n    REP(i, m) {\n        int a, b;\n        cin >> a >> b;\n        a--; b--;\n        cnt[a]++;\n        cnt[b]++;\n        vertexs[a].push_back(b);\n        vertexs[b].push_back(a);\n    }\n    queue<int> next;\n    REP(i, n) {\n        if (cnt[i] == 1) next.push(i);\n    }\n    while (!next.empty()) {\n        int now = next.front();\n        next.pop();\n        if (now == 0) continue;\n        for (auto x : vertexs[now]) {\n            cnt[x]--;\n            if (cnt[x] == 1) {\n                next.push(x);\n            }\n        }\n    }\n    int ans = 0;\n    set<int> nextings;\n    cnt[0] = 2;\n    REP(i, n) {\n        if (cnt[i] > 1) {\n            ans += scores[i];\n            nextings.insert(i);\n        }\n    }\n    set<pair<int, int>> gogo;\n    REP(i, n) {\n        if (cnt[i] > 1) continue;\n        for (auto x : vertexs[i]) {\n            if (nextings.find(x) != nextings.end()) {\n                gogo.insert(mp(i, n));\n            }\n            else {\n                gogo.insert(mp(min(x, i), max(x, i)));\n            }\n        }\n    }\n    for (auto x : gogo) {\n        seconds[x.first].push_back(x.second);\n        seconds[x.second].push_back(x.first);\n    }\n    cout << ans + dfs(n, -1)  << endl;\n}\n\n#undef int\nint main() {\n    init();\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define REP(i, n) for (int i = 0; i < (n); i++)\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n, m;\n    cin >> n >> m;\n    vector<int> ws(n);\n    for (int i = 0; i < n; i++) cin >> ws[i];\n    vector<vector<int>> adj(n);\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    vector<bool> hasi(n);\n    vector<int> deg(n);\n    queue<int> que;\n    for (int i = 0; i < n; i++) {\n        deg[i] = adj[i].size();\n        if (adj[i].size() == 1) {\n            hasi[i] = true;\n            que.push(i);\n        }\n    }\n\n    if (que.empty()) {\n        cout << accumulate(ws.begin(), ws.end(), 0) << endl;\n        return 0;\n    }\n\n    while (!que.empty()) {\n        int v = que.front();\n        que.pop();\n        for (int a : adj[v]) {\n            if (hasi[a]) continue;\n            deg[a]--;\n            if (deg[a] == 1) {\n                hasi[a] = true;\n                que.push(a);\n            }\n        }\n    }\n\n    vector<int> girigiri;\n    for (int i = 0; i < n; i++) {\n        if (!hasi[i]) continue;\n        bool ok = false;\n        for (int a : adj[i]) {\n            if (!hasi[a]) ok = true;\n        }\n        if (ok) {\n            girigiri.push_back(i);\n        }\n    }\n\n    if (girigiri.empty()) {\n        // tree\n        int ans = 0;\n        function<void(int, int, int)> dfs = [&](int v, int p, int acc) {\n            ans = max(ans, acc);\n            for (int s : adj[v]) {\n                if (s != p) {\n                    dfs(s, v, acc + ws[s]);\n                }\n            }\n        };\n        dfs(0, -1, ws[0]);\n        cout << ans << endl;\n        return 0;\n    }\n\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        if (!hasi[i]) {\n            ans += ws[i];\n        }\n    }\n\n    int N = girigiri.size();\n    vector<int> score(N);\n    auto get_max = [&](int u) {\n        int nax = 0;\n        function<void(int, int, int)> dfs = [&](int v, int p, int acc) {\n            nax = max(nax, acc);\n            for (int s : adj[v]) {\n                if (s != p && hasi[s]) {\n                    dfs(s, v, acc + ws[s]);\n                }\n            }\n        };\n        dfs(u, -1, ws[u]);\n        return nax;\n    };\n    for (int i = 0; i < N; i++) {\n        score[i] = get_max(girigiri[i]);\n    }\n\n    if (hasi[0]) {\n        bool nyan = false;\n        for (int i = 0; i < N; i++) {\n            if (girigiri[i] == 0) {\n                ans += ws[0];\n                score[i] -= ws[0];\n                nyan = true;\n                break;\n            }\n        }\n        if (nyan) {\n            ans += *max_element(score.begin(), score.end());\n            cout << ans << endl;\n            return 0;\n        }\n        int giri = -1;\n        int iki = 0;\n        function<void(int, int, int)> dfs = [&](int v, int p, int acc) {\n            bool hoge = false;\n            for (int s : adj[v]) {\n                if (s != p) {\n                    if (!hasi[s]) {\n                        giri = v;\n                        iki = acc;\n                        return;\n                    }\n                    hoge = true;\n                    dfs(s, v, acc + ws[s]);\n                }\n            }\n        };\n        dfs(0, -1, ws[0]);\n        ans += iki;\n        assert(giri != -1);\n        vector<bool> used(n);\n        function<void(int, int)> kek = [&](int v, int p) {\n            if (v == 0) {\n                used[v] = true;\n                return;\n            }\n            for (int s : adj[v]) {\n                if (s != p && hasi[s]) {\n                    kek(s, v);\n                    if (used[s]) {\n                        used[v] = true;\n                        return;\n                    }\n                }\n            }\n        };\n        kek(giri, -1);\n        assert(used[0]);\n        int nax = 0;\n        function<void(int, int, int)> genkai = [&](int v, int p, int acc) {\n            nax = max(nax, acc);\n            for (int s : adj[v]) {\n                if (s != p && hasi[s]) {\n                    int po = acc;\n                    if (!used[s]) {\n                        po += ws[s];\n                    }\n                    genkai(s, v, po);\n                }\n            }\n        };\n        genkai(giri, -1, 0);\n        for (int i = 0; i < N; i++) {\n            if (girigiri[i] == giri) {\n                score[i] = nax;\n                break;\n            }\n        }\n        ans += *max_element(score.begin(), score.end());\n        cout << ans << endl;\n    } else {\n        ans += *max_element(score.begin(), score.end());\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\ntypedef long long  ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\ntypedef vector<int> vec;\n\nconst int mn = 100000;\nvector<int> G[100000];\nint w[100000];\n\nint c[100000];\nbool non[100000];\n\nint sum, ma;\nbool exi0 = false;\nint dfs(int id, int fr) {\n\tif (id == 0)exi0 = true;\n\tint ret = 0;\n\trep(j, G[id].size()) {\n\t\tint to = G[id][j];\n\t\tif (fr == to)continue;\n\t\tif (!non[to]) {\n\t\t\tret = max(ret, sum + ma);\n\t\t}\n\t\telse {\n\t\t\tret = max(ret, dfs(to, id));\n\t\t}\n\t}\n\treturn ret + w[id];\n}\nint csum;\nbool dfs2(int id, int fr) {\n\trep(j, G[id].size()) {\n\t\tint to = G[id][j];\n\t\tif (fr == to)continue;\n\t\tif (!non[to]) {\n\t\t\tcsum += w[id];\n\t\t\tw[id] = 0;\n\t\t\treturn true;\n\t\t}\n\t\tif (dfs2(to, id)) {\n\t\t\tcsum += w[id];\n\t\t\tw[id] = 0;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nvoid solve() {\n\tint n, m; cin >> n >> m;\n\trep(i, n)cin >> w[i];\n\trep(i, m) {\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t\tc[a]++; c[b]++;\n\t}\n\tqueue<int> q;\n\trep(i, n) {\n\t\tif (c[i] == 1) {\n\t\t\tq.push(i);\n\t\t\tnon[i] = true;\n\t\t}\n\t}\n\twhile (!q.empty()) {\n\t\tint id = q.front(); q.pop();\n\t\trep(j, G[id].size()) {\n\t\t\tint to = G[id][j];\n\t\t\tc[to]--;\n\t\t\tif (c[to] == 1) {\n\t\t\t\tq.push(to);\n\t\t\t\tnon[to] = true;\n\t\t\t}\n\t\t}\n\t}\n\trep(i, n) {\n\t\tif (!non[i])sum += w[i];\n\t}\n\trep(i, n)if (!non[i]) {\n\t\trep(j, G[i].size()) {\n\t\t\tint to = G[i][j];\n\t\t\tif (!non[to])continue;\n\t\t\texi0 = false;\n\t\t\tint z = dfs(to, i);\n\t\t\tif (!exi0) {\n\t\t\t\tma = max(ma, z);\n\t\t\t}\n\t\t}\n\t}\n\tif (!non[0]) {\n\t\tcout << sum + ma << endl;\n\t}\n\telse {\n\t\tint ans = dfs(0, -1);\n\t\tint z=dfs2(0,-1);\n\t\trep(i, n)if (!non[i]) {\n\t\t\trep(j, G[i].size()) {\n\t\t\t\tint to = G[i][j];\n\t\t\t\tif (!non[to])continue;\n\t\t\t\tma = max(ma, dfs(to, i));\n\t\t\t}\n\t\t}\n\t\tans = max(ans, z + sum + ma);\n\t\tcout << ans << endl;\n\t}\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(5);\n\t//while (cin >> n,n)solve();\n\tsolve();\n\t//stop\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct UnionFind\n{\n  vector< int > data;\n\n  UnionFind(int sz)\n  {\n    data.assign(sz, -1);\n  }\n\n  bool unite(int x, int y)\n  {\n    x = find(x), y = find(y);\n    if(x == y) return (false);\n    if(data[x] > data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n    return (true);\n  }\n\n  int find(int k)\n  {\n    if(data[k] < 0) return (k);\n    return (data[k] = find(data[k]));\n  }\n\n  int size(int k)\n  {\n    return (-data[find(k)]);\n  }\n};\n\nstruct BiConnectedComponents\n{\n  UnionFind uf;\n  vector< vector< int > > g;\n  vector< pair< int, int > > edges;\n  vector< int > used, ord, low, comp;\n\n  BiConnectedComponents(size_t v) : uf(v), g(v), used(v, 0), comp(v), ord(v), low(v)\n  {\n  }\n\n  void add_edge(int x, int y)\n  {\n    g[x].push_back(y);\n    g[y].push_back(x);\n    edges.push_back(minmax(x, y));\n  }\n\n  void dfs(int idx, int &k, int par = -1)\n  {\n    used[idx] = true;\n    ord[idx] = k++;\n    low[idx] = ord[idx];\n\n    for(auto &to : g[idx]) {\n      if(!used[to]) {\n        dfs(to, k, idx);\n        low[idx] = min(low[idx], low[to]);\n        if(ord[idx] >= low[to]) uf.unite(idx, to);\n      } else if(to != par) {\n        low[idx] = min(low[idx], ord[to]);\n      }\n    }\n  }\n\n  int operator[](int k)\n  {\n    return (comp[k]);\n  }\n\n  size_t size()\n  {\n    return (g.size());\n  }\n\n  void build(vector< vector< int > > &t)\n  {\n    int kk = 0;\n    dfs(0, kk);\n\n    int ptr = 0;\n    vector< int > cc(g.size());\n    for(int i = 0; i < g.size(); i++) {\n      if(i == uf.find(i)) cc[i] = ptr++;\n    }\n\n    t.resize(ptr);\n    for(int i = 0; i < g.size(); i++) {\n      comp[i] = cc[uf.find(i)];\n    }\n    for(auto &e : edges) {\n      int x = comp[e.first], y = comp[e.second];\n      if(x == y) continue;\n      t[x].push_back(y);\n      t[y].push_back(x);\n    }\n  }\n};\n\nint N, M, W[100000];\nvector< vector< int > > g;\nvector< int > weightSum, sz;\nint dp1[100000], dp2[100000];\nbool turn[100000];\n\nint rec(int idx, int par = -1)\n{\n  for(auto &to : g[idx]) {\n    if(to == par) continue;\n    rec(to, idx);\n    dp2[idx] = max(dp2[idx], dp2[to]);\n    dp1[idx] += dp1[to];\n  }\n  dp2[idx] += weightSum[idx];\n  if(sz[idx] >= 3 || dp1[idx] > 0) dp1[idx] += weightSum[idx];\n\n  int ret = 0;\n  for(auto &to : g[idx]) {\n    if(to == par) continue;\n    ret = max(ret, dp1[idx] - dp1[to] + dp2[to]);\n  }\n  return (ret);\n}\n\nint main()\n{\n  cin >> N >> M;\n  BiConnectedComponents tree(N);\n  for(int i = 0; i < N; i++) {\n    cin >> W[i];\n  }\n  while(M--) {\n    int U, V;\n    cin >> U >> V;\n    tree.add_edge(--U, --V);\n  }\n  tree.build(g);\n  weightSum.assign(g.size(), 0);\n  sz.assign(g.size(), 0);\n  for(int i = 0; i < N; i++) {\n    weightSum[tree[i]] += W[i];\n    sz[tree[i]]++;\n  }\n  cout << rec(tree[0]) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define MAX_V 111111\ntypedef pair<int,int> P;\nvector<int> G[MAX_V],C[MAX_V],T[MAX_V],ord,low,belong;\nvector<P> B;\nbool is_bridge(int u,int v){\n  if(ord[u]>ord[v]) swap(u,v);\n  return ord[u]<low[v];\n}\nvoid dfs(int u,int p,int &k){\n  ord[u]=low[u]=k;\n  ++k;\n  for(int i=0;i<(int)G[u].size();i++){\n    int v=G[u][i];\n    if(v==p) continue;\n    if(ord[v]>=0){\n      low[u]=min(low[u],ord[v]);\n    }else{\n      dfs(v,u,k);\n      low[u]=min(low[u],low[v]);\n    }\n    if(is_bridge(u,v)) B.push_back(P(u,v));\n  }\n}\nvoid fill_component(int c,int u){\n  C[c].push_back(u);\n  belong[u]=c;\n  for(int i=0;i<(int)G[u].size();i++){\n    int v=G[u][i];\n    if(belong[v]>=0||is_bridge(u,v)) continue;\n    fill_component(c,v);\n  }\n}\nvoid add_component(int u,int &k){\n  if(belong[u]>=0) return;\n  fill_component(k++,u);\n}\nvoid biconnectedgrapth(int n){\n  int k=0;\n  ord.resize(n,-1);\n  low.resize(n);\n  belong.resize(n,-1);\n  //cout<<n<<endl;\n  for(int v=0;v<n;v++){\n    if(ord[v]>=0) continue;\n    dfs(v,-1,k);\n  }\n  //cout<<k<<endl;\n  k=0;\n  for(int i=0;i<(int)B.size();i++){\n    add_component(B[i].first,k);\n    add_component(B[i].second,k);\n  }\n  if(!B.size()) add_component(0,k);\n  //cout<<k<<endl;\n  for(int i=0;i<(int)B.size();i++){\n    int u=belong[B[i].first],v=belong[B[i].second];\n    T[u].push_back(v);\n    T[v].push_back(u);\n  }\n}\nvoid add_edge(int u,int v){\n  G[u].push_back(v);\n  G[v].push_back(u);\n}\n\nint W[MAX_V];\n\nint dfs2(int u,int p){\n  int res=0;\n  for(int i=0;i<(int)T[u].size();i++){\n    int v=T[u][i];\n    if(v==p) continue;\n    res=max(res,dfs2(v,u));\n  }\n  return W[u]+res;\n}\nsigned main(){\n  int n,m;\n  cin>>n>>m;\n  int w[n];\n  for(int i=0;i<n;i++) cin>>w[i];\n  for(int i=0;i<m;i++){\n    int u,v;\n    cin>>u>>v;\n    add_edge(u-1,v-1);\n  }\n  biconnectedgrapth(n);\n  //puts(\"a\");\n  for(int i=0;i<n;i++) W[belong[i]]+=w[i];\n  cout<<dfs2(belong[0],-1)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\nusing namespace std;\n#pragma warning (disable: 4996)\n\nint N, M, A[1 << 17], P[1 << 17], Q[1 << 17], pre[1 << 17], low[1 << 17], col[1 << 17], R[1 << 17], dp[1 << 17], dp2[1 << 17], cnts, cntw;\nvector<int>X[1 << 17], Y[1 << 17], Z[1 << 17], W[1 << 17];\nmap<pair<int, int>, int>Map;\nbool used[1 << 17];\n\nvoid dfs(int pos, int prevs) {\n\tcnts++; pre[pos] = cnts;\n\tlow[pos] = cnts;\n\n\tfor (int i = 0; i < X[pos].size(); i++) {\n\t\tint to = X[pos][i];\n\t\tif (pre[to] != 0) {\n\t\t\tif (prevs != to) low[pos] = min(low[pos], low[to]);\n\t\t\tcontinue;\n\t\t}\n\n\t\tdfs(to, pos); low[pos] = min(low[pos], low[to]);\n\n\t\tif (low[to] == pre[to]) {\n\t\t\tMap[make_pair(pos, to)] = 1;\n\t\t\tMap[make_pair(to, pos)] = 1;\n\t\t}\n\t}\n}\n\nvoid dfs2(int pos) {\n\tif (col[pos] >= 1) return;\n\tcol[pos] = cntw; if (R[cntw] != 0) used[cntw] = true; R[cntw] += A[pos];\n\tfor (int i = 0; i < Y[pos].size(); i++) {\n\t\tdfs2(Y[pos][i]);\n\t}\n}\n\nvoid dfs3(int pos) {\n\tdp[pos] = 0; int maxn = 0;\n\tfor (int i = 0; i < Z[pos].size(); i++) {\n\t\tint to = Z[pos][i];\n\t\tif (dp[to] != -1) continue;\n\t\tdfs3(to); if (used[to] == true) used[pos] = true;\n\t\tW[pos].push_back(to);\n\t\tmaxn = max(maxn, dp[to]);\n\t}\n\tdp[pos] = maxn;\n\tdp[pos] += R[pos];\n}\nvoid dfs4(int pos) {\n\tdp2[pos] = 0; int maxn = 0;\n\tfor (int i = 0; i < Z[pos].size(); i++) {\n\t\tint to = Z[pos][i];\n\t\tif (dp2[to] != -1 || used[to] == false) continue;\n\t\tdfs4(to);\n\t\tmaxn = max(maxn, dp2[to]);\n\t}\n\tdp2[pos] = maxn;\n\tdp2[pos] += R[pos];\n}\n\nint main() {\n\t//FILE *in = freopen(\"in1.txt\", \"r\", stdin);\n\tcin >> N >> M;\n\tfor (int i = 1; i <= N; i++) { cin >> A[i]; low[i] = (1 << 30); dp[i] = -1; dp2[i] = -1; }\n\tfor (int i = 0; i < M; i++) {\n\t\tcin >> P[i] >> Q[i];\n\t\tX[P[i]].push_back(Q[i]);\n\t\tX[Q[i]].push_back(P[i]);\n\t}\n\tdfs(1, -1);\n\n\tfor (int i = 0; i < M; i++) {\n\t\tif (Map[make_pair(P[i], Q[i])] == 0) {\n\t\t\tY[P[i]].push_back(Q[i]);\n\t\t\tY[Q[i]].push_back(P[i]);\n\t\t}\n\t}\n\tfor (int i = 1; i <= N; i++) {\n\t\tif (col[i] >= 1) continue;\n\t\tcntw++;\n\t\tdfs2(i);\n\t}\n\tfor (int i = 0; i < M; i++) {\n\t\tif (col[P[i]] != col[Q[i]]) {\n\t\t\tZ[col[P[i]]].push_back(col[Q[i]]);\n\t\t\tZ[col[Q[i]]].push_back(col[P[i]]);\n\t\t}\n\t}\n\tdfs3(col[1]);\n\tdfs4(col[1]);\n\n\tint ans = 0, maxn = 0; used[1] = true;\n\tfor (int i = 1; i <= N; i++) { if (used[i] == true) ans += R[i]; }\n\tfor (int i = 1; i <= N; i++) { if (used[i] == false) maxn = max(maxn, dp[i]); }\n\tans += maxn;\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 100005;\n\nset<int> G[MAX_N];\nset<int> nG[MAX_N];\nbool flag[MAX_N];\nint w[MAX_N];\nint n,m,opt;\n\nvoid dfs(int s,int cost)\n{\n    if(nG[s].size() == 0){\n        if(opt < cost){\n            opt = cost;\n        }\n        return;\n    }\n    for(auto it = nG[s].begin(); it != nG[s].end() ;it++){\n        dfs(*it,cost+w[(*it)]);\n    }\n    return;\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\trep(i,n){\n\t\tscanf(\"%d\",&w[i]);\n\t}\n    rep(i,m){\n        int x,y;\n        scanf(\"%d%d\",&x,&y);\n        G[x-1].insert(y-1);\n        G[y-1].insert(x-1);\n    }\n    rep(i,n){\n        flag[i] = false;\n    }\n    queue<P> que;\n    for(int i=1;i<n;i++){\n        if(G[i].size() == 1){\n            flag[i] = true;\n            if(*G[i].begin() == 0){\n                nG[0].insert(i);\n                continue;\n            }\n            G[*G[i].begin()].erase(i);\n            if(G[*G[i].begin()].size() == 1){\n                que.push(P(*G[i].begin(),i));\n                flag[*G[i].begin()] = true;\n                nG[*G[i].begin()].insert(i);\n            }else{\n                nG[*G[i].begin()].insert(i);\n            }\n        }\n    }\n    while(!que.empty()){\n        P p = que.front();\n        int u = p.first;\n        que.pop();\n        if(*G[u].begin() == 0){\n            nG[0].insert(u);\n            continue;\n        }\n        G[*G[u].begin()].erase(u);\n        if(G[*G[u].begin()].size() == 1){\n            que.push(P(*G[u].begin(),u));\n            flag[*G[u].begin()] = true;\n            nG[*G[u].begin()].insert(u);\n        }else{\n            nG[*G[u].begin()].insert(u);\n        }\n    }\n    for(int i=1;i<n;i++){\n        if(!flag[i]){\n            if(nG[i].size() > 0){\n                for(auto it = nG[i].begin(); it != nG[i].end() ;it++){\n                    nG[0].insert(*it);\n                }\n                nG[i].clear();\n            }\n        }\n    }\n    int res = 0;\n    for(int i = 1;i < n;i++){\n        if(!flag[i]){\n            res += w[i];\n        }\n    }\n    dfs(0,w[0]);\n    res += opt;\n    printf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_V 100000\nusing namespace std;\nint m,w[100001];\nvector<int> vv[100001];\nunordered_set<int> st[100001];\nint V;\nvector<int> G[MAX_V];\nvector<int> rG[MAX_V];\nvector<int> vs;\nbool used[MAX_V];\nint cmp[MAX_V];\nint C[100001],F[100001],U[100001],ans;\nbool UU[100001];\n\n\nvoid DFS(int p){\n  for(int i=0;i<vv[p].size();i++){\n    int mn=min(vv[p][i],p),mx=max(vv[p][i],p);\n    if(st[mn].find(mx)==st[mn].end()){\n      st[mn].insert(mx);\n      G[p].push_back(vv[p][i]);\n      rG[vv[p][i]].push_back(p);\n      DFS(vv[p][i]);\n    }\n  }\n}\n\nvoid dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++)if(!used[G[v][i]])dfs(G[v][i]);\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v]=true;\n  cmp[v]=k;\n  for(int i=0;i<rG[v].size();i++)if(!used[rG[v][i]])rdfs(rG[v][i],k);\n}\n\nint scc(){\n  memset(used,0,sizeof(used));\n  vs.clear();\n  for(int v=0;v<V;v++)if(!used[v])dfs(v);\n  memset(used,0,sizeof(used));\n  int k=0;\n  for(int i=vs.size()-1;i>=0;i--)if(!used[vs[i]])rdfs(vs[i],k++);\n  return k;\n}\n\nbool DFS1(int p){\n  if(U[p])return 0;\n  U[p]=1;\n  bool f=F[cmp[p]]>=2;\n  for(int i=0;i<G[p].size();i++)\n    f|=DFS1(G[p][i]);\n  ans+=w[p]*f;\n  return UU[p]=f;\n}\nbool UUU[100001];\nint DFS2(int p){\n  if(UUU[p])return 0;\n  UUU[p]=1;\n  int res=0;\n  \n  for(int i=0;i<G[p].size();i++)\n    res=max(res,DFS2(G[p][i]));  \n  return res+(UU[p]?0:w[p]);\n}\n\nint main(){\n  cin>>V>>m;\n  for(int i=0;i<V;i++)cin>>w[i];\n  for(int j=0,a,b;j<m;j++){\n    cin>>a>>b;a--,b--;\n    vv[a].push_back(b),vv[b].push_back(a);\n  }\n  DFS(0);\n  int t=0;\n  for(int i=0;i<V;i++)t+=w[i];\n  scc();\n  for(int i=0;i<V;i++)F[cmp[i]]++;\n  DFS1(0);\n  cout<<ans+DFS2(0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing Weight=long long;\n\nstruct Edge{\n    int src,dst;\n    Edge(int src,int dst):\n    src(src),dst(dst){}\n};\n\nusing Edges=vector<Edge>;\nusing Graph=vector<Edges>;\n\npair<vector<int>, Edges> bridge(const Graph& g) {\n\tconst int n = g.size();\n\tint idx = 0, s = 0, t = 0, k = 0;\n\tvector<int>ord(n, -1), onS(n), stk(n), roots(n), cmp(n);\n\tEdges brdg;\n\tfunction<void(int, int)> dfs = [&](int v, int u) {\n\t\tord[v] = idx++;\n\t\tstk[s++] = v;\n\t\tonS[v] = true;\n\t\troots[t++] = v;\n\t\tfor (auto& e : g[v]) {\n\t\t\tint w = e.dst;\n\t\t\tif (ord[w] == -1)dfs(w, v);\n\t\t\telse if (u != w && onS[w])\n\t\t\t\twhile (ord[roots[t - 1]]>ord[w])--t;\n\t\t}\n\t\tif (v == roots[t - 1]) {\n\t\t\tbrdg.emplace_back(u, v);\n\t\t\twhile (true) {\n\t\t\t\tint w = stk[--s];\n\t\t\t\tonS[w] = false;\n\t\t\t\tcmp[w] = k;\n\t\t\t\tif (v == w)break;\n\t\t\t}\n\t\t\t--t;\n\t\t\t++k;\n\t\t}\n\t};\n\tfor (int u = 0; u<n; ++u) {\n\t\tif (ord[u] == -1) {\n\t\t\tdfs(u, n);\n\t\t\tbrdg.pop_back();\n\t\t}\n\t}\n\treturn make_pair(cmp, brdg);\n}\n\nint dfs1(const Graph &g,int p,int v,vector<bool> &elect,\nvector<int>&elements,vector<int>&cycle,vector<Weight>&node){\n    int res=0;\n    elect[v]=false;\n    for(auto e:g[v]){\n        if(elements[cycle[e.dst]]>1)return node[v];\n        if(e.dst!=p && elements[cycle[e.dst]]==1){\n            int t=dfs1(g,v,e.dst,elect,elements,cycle,node);\n            if(t)res=t;\n        }\n    }\n    if(res)return res+node[v];\n    return 0;\n}\n\nint main(){\n    int n,m;\n    cin>>n>>m;\n    Graph g(n);\n    vector<Weight>node(n);\n    for(int i=0;i<n;++i){\n        cin>>node[i];\n    }\n    for(int i=0;i<m;++i){\n        int s,t;\n        cin>>s>>t;\n        --s;--t;\n        g[s].emplace_back(s,t);\n        g[t].emplace_back(t,s);\n    }\n    vector<int>cycle = bridge(g).first;\n    vector<int>elements(n,0);\n    for(int i=0;i<n;++i){\n        elements[cycle[i]]++;\n    }\n    vector<bool>elect(n,true);\n    int buf=0;\n    for(int i=0;i<n;++i){\n        if(g[i].size()==1){\n            buf=max(buf,dfs1(g,-1,g[i][0].src,elect,elements,cycle,node));\n        }\n    }\n    int ans=0;\n    for(int i=0;i<n;++i){\n        if(elect[i]){\n            ans+=node[i];\n        }\n    }\n    ans+=buf;\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_N 100011\n#define N MAX_N\n#define rank dfasfds\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int>::iterator V;\nint par[MAX_N],rank[MAX_N];\nll val[MAX_N];\nvector<int> G[N];\n\nvoid init(int n){for(int i=0;i<N;i++)par[i]=i,rank[i]=0;}\n\nint find(int x){\n  if(par[x]==x)return x;\n  return par[x]=find(par[x]);\n}\n\nbool same(int x,int y){return find(x)==find(y);}\n\nvoid unite(int x,int y){\n  x=find(x),y=find(y);\n  if(x==y)return;\n  if(rank[x]<rank[y])par[x]=y,val[y]+=val[x];\n  else{\n    par[y]=x;\n    val[x]+=val[y];\n    if(rank[x]==rank[y])rank[x]++;\n  }\n}\n\nint used[N];\nvector<int> path;\nvoid dfs(int pos,int pre){\n  if(used[pos]||pos!=find(pos)) {\n    while(path.size())unite(0,path.back()),path.pop_back();\n    return;\n  }\n  used[pos]=1;\n  path.push_back(pos);\n  for(V it=G[pos].begin();it!=G[pos].end();it++)if(*it!=pre)dfs(*it,pos);\n  used[pos]=0;\n  if(path.size()&&path.back()==pos) path.pop_back();\n}\n\nvector<int>col[N];\nll get_mx(int pos){\n  used[pos]=1;\n  ll res=0;\n  for(int i=0;i<col[pos].size();i++)\n    for(V it=G[col[pos][i]].begin();it!=G[col[pos][i]].end();it++)\n      if(!used[find(*it)])res=max(res,get_mx(find(*it)));\n  return res+val[find(pos)];\n}\n\nint main(){\n  int n,m;\n  cin>>n>>m;\n  for(int i=0;i<n;i++) cin>>val[i];\n  for(int i=0,a,b;i<m;i++){\n    cin>>a>>b;a--,b--;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n  init(n);\n  dfs(0,-1);\n  for(int i=0;i<n;i++) col[find(i)].push_back(i);\n  cout <<get_mx(find(0))<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct UnionFind\n{\n  vector< int > data;\n\n  UnionFind(int sz)\n  {\n    data.assign(sz, -1);\n  }\n\n  bool unite(int x, int y)\n  {\n    x = find(x), y = find(y);\n    if(x == y) return (false);\n    if(data[x] > data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n    return (true);\n  }\n\n  int find(int k)\n  {\n    if(data[k] < 0) return (k);\n    return (data[k] = find(data[k]));\n  }\n\n  int size(int k)\n  {\n    return (-data[find(k)]);\n  }\n};\n\nstruct BiConnectedComponents\n{\n  UnionFind uf;\n  vector< vector< int > > g;\n  vector< pair< int, int > > edges;\n  vector< int > used, ord, low, comp;\n\n  BiConnectedComponents(size_t v) : uf(v), g(v), used(v, 0), comp(v), ord(v), low(v)\n  {\n  }\n\n  void add_edge(int x, int y)\n  {\n    g[x].push_back(y);\n    g[y].push_back(x);\n    edges.push_back(minmax(x, y));\n  }\n\n  void dfs(int idx, int &k, int par = -1)\n  {\n    used[idx] = true;\n    ord[idx] = k++;\n    low[idx] = ord[idx];\n\n    for(auto &to : g[idx]) {\n      if(!used[to]) {\n        dfs(to, k, idx);\n        low[idx] = min(low[idx], low[to]);\n        if(ord[idx] >= low[to]) uf.unite(idx, to);\n      } else if(to != par) {\n        low[idx] = min(low[idx], ord[to]);\n      }\n    }\n  }\n\n  int operator[](int k)\n  {\n    return (comp[k]);\n  }\n\n  size_t size()\n  {\n    return (g.size());\n  }\n\n  void build(vector< vector< int > > &t)\n  {\n    int kk = 0;\n    dfs(0, kk);\n\n    int ptr = 0;\n    vector< int > cc(g.size());\n    for(int i = 0; i < g.size(); i++) {\n      if(i == uf.find(i)) cc[i] = ptr++;\n    }\n\n    t.resize(ptr);\n    for(int i = 0; i < g.size(); i++) {\n      comp[i] = cc[uf.find(i)];\n    }\n    for(auto &e : edges) {\n      int x = comp[e.first], y = comp[e.second];\n      if(x == y) continue;\n      t[x].push_back(y);\n      t[y].push_back(x);\n    }\n  }\n};\n\nint N, M, W[100000];\nvector< vector< int > > g;\nvector< int > weightSum, sz;\nint dp1[100000], dp2[100000];\n\nint rec(int idx, int par = -1)\n{\n  int ret = 0;\n  for(auto &to : g[idx]) {\n    if(to == par) continue;\n    ret = max(ret, rec(to, idx));\n    dp2[idx] = max(dp2[idx], dp2[to]);\n  }\n  dp2[idx] += weightSum[idx];\n  if(sz[idx] >= 3) {\n    for(auto &to : g[idx]) {\n      if(to == par) continue;\n      dp1[idx] += dp1[to];\n    }\n    dp1[idx] += weightSum[idx];\n    for(auto &to : g[idx]) {\n      if(to == par) continue;\n      ret = max(ret, dp1[idx] - dp1[to] + dp2[to]);\n    }\n  }\n  return (max(ret, dp2[idx]));\n}\n\nint main()\n{\n  cin >> N >> M;\n  BiConnectedComponents tree(N);\n  for(int i = 0; i < N; i++) {\n    cin >> W[i];\n  }\n  while(M--) {\n    int U, V;\n    cin >> U >> V;\n    tree.add_edge(--U, --V);\n  }\n  tree.build(g);\n  weightSum.assign(g.size(), 0);\n  sz.assign(g.size(), 0);\n  for(int i = 0; i < N; i++) {\n    weightSum[tree[i]] += W[i];\n    sz[tree[i]]++;\n  }\n  cout << rec(tree[0]) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <stack>\n#include <set>\n#include <utility>\n#include <iostream>\n#include <queue>\nusing namespace std;\nusing pii = pair<int, int>;\n\n// 移動元と行先と辺のコストを記録する構造体\ntemplate <typename T>\nstruct Edge {\n    int from, to;\n    T cost;\n    Edge(int s, T d) : to(s), cost(d) {}\n    Edge(int f, int s, T d) : from(f), to(s), cost(d) {}\n\n    bool operator<(const Edge &e) const {\n        return cost < e.cost;\n    }\n    bool operator>(const Edge &e) const {\n        return cost > e.cost;\n    }\n};\n\ntemplate <typename T>\nusing Graph = vector< vector< Edge<T> > >;\n\n// 関節点を求める (artPoints)\n// 橋を求める (bridges)\n// 二重辺連結成分分解をする (BICC)\n\n// 関節点は、取り除いたときに連結でなくなってしまうような頂点のこと\n// 橋は、取り除いた時に連結でなくなってしまうような辺のこと\n\ntemplate <typename T>\nstruct graphLink {\n    vector<int> ord, low, parent, cmp;\n    vector< vector< Edge<T> > > G, H;\n\n    // 橋の情報 (first < second となるように格納)\n    vector< pair<int, int> > bridges;\n    int cnt, v;\n\n    // init\n    graphLink(vector< vector< Edge<T> > > &S, int root=0) {\n        int n = S.size();\n        ord.resize(n, -1), low.resize(n, 0),\n        parent.resize(n, -1), cmp.resize(n, -1);\n        cnt = 0, v = n;\n        G = S;\n        dfs(root);\n    }\n\n    // 橋であるかの判定\n    bool is_bridge(int x, int y) {\n        if(ord[x] > ord[y]) swap(x, y);\n        return ord[x] < low[y];\n    }\n\n    // dfs 木の作成と橋の列挙 (初期化と同時にやる)\n    // usage: dfs(root);\n    void dfs(int cur, int prev=-1) {\n        low[cur] = cnt;\n        ord[cur] = cnt++;\n\n        for(auto x : G[cur]) {\n            if(x.to == prev) continue;\n            if(ord[x.to] < 0) {\n                parent[x.to] = cur;\n                dfs(x.to, cur);\n\n                low[cur] = min(low[cur], low[x.to]);\n            }\n            else {\n                low[cur] = min(low[cur], ord[x.to]);\n            }\n            if(is_bridge(cur, x.to)) {\n                int a = min(cur, x.to);\n                int b = max(cur, x.to);\n                bridges.emplace_back(make_pair(a, b));\n            }\n        }\n    }\n\n    // 関節点を求める (root は dfs 木の root と一致させる)\n    // root は子を 2 つ持っていれば関節点になる\n    // それ以外の頂点に関しては ord[parent] <= low[i] のとき関節点になる\n    // (lowlink でも親より深さが低い頂点にたどり着けないため)\n    set<int> artPoints(int root) {\n        set<int> se;\n        int num = 0;\n        for(int i=0; i<v; i++) {\n            if(parent[i] < 0) continue;\n            if(parent[i] == root) num++;\n            else if(ord[parent[i]] <= low[i]) se.insert(parent[i]);\n        }\n        if(num >= 2) se.insert(0);\n        return se;\n    }\n\n    // 二重辺連結成分分解 (橋となる辺を使わないように DFS)\n    // Verified: AtCoder Regular Contest D: 旅行会社高橋君\n    void BICC() {\n        int k = 0;\n        // point, number\n        stack<pii> S;\n        for(int i=0; i<v; i++) {\n            if(cmp[i] >= 0) continue;\n            cmp[i] = k;\n            S.push(make_pair(i, k++));\n            while(!S.empty()) {\n                pii cur = S.top(); S.pop();\n                for(auto x : G[cur.first]) {\n                    if(cmp[x.to] >= 0) continue;\n                    if(is_bridge(cur.first, x.to)) continue;\n                    cmp[x.to] = cur.second;\n                    S.push(make_pair(x.to, cmp[x.to]));\n                }\n            }\n        }\n\n        set< pair<int, int> > edge_set;\n        H.resize(k);\n        for(int i=0; i<v; i++) {\n            for(auto x : G[i]) {\n                int ca = cmp[i], cb = cmp[x.to];\n                if(ca == cb) continue;\n                if(ca > cb) swap(ca, cb);\n                if(edge_set.count(make_pair(ca, cb))) continue;\n                edge_set.insert(make_pair(ca, cb));\n                H[ca].push_back(Edge<T>(cb, 1));\n                H[cb].push_back(Edge<T>(ca, 1));\n            }\n        }\n    }\n};\n\n// par[i] = 頂点 i の親\nvoid construct(Graph<int> &G, int root, vector<int> &par) {\n    vector<int> checked(G.size());\n\n    queue<int> que;\n    que.push(root);\n    checked[root] = true;\n    while(que.size()) {\n        int cur = que.front(); que.pop();\n        for(auto e : G[cur]) {\n            int to = e.to;\n            if(checked[to]) continue;\n            checked[to] = true;\n            par[to] = cur;\n            que.push(to);\n        }\n    }\n}\n\nlong long int ans = 0;\n\nvoid solve_one(int p, vector<int> par, vector<int> &points) {\n    for(; p!=-1 && points[p]>0; p=par[p]) {\n        ans += points[p];\n        // printf(\"add: p = %d, value = %d\\n\", p, points[p]);\n        points[p] = 0;\n    }\n}\n\nlong long int solve_two(int p, Graph<int> &G, vector<int> &points) {\n    vector<long long int> ret(G.size()), checked(G.size());\n    long long int sl = 0;\n\n    queue<int> que;\n    checked[p] = true;\n    ret[p] = points[p];\n    sl = max(sl, ret[p]);\n    que.push(p);\n\n    while(que.size()) {\n        int cur = que.front(); que.pop();\n        for(auto e : G[cur]) {\n            int to = e.to;\n            if(checked[to]) continue;\n            checked[to] = true;\n\n            ret[to] = ret[cur] + points[to];\n            sl = max(sl, ret[to]);\n            que.push(to);\n        }\n    }\n    return sl;\n}\n\nint main() {\n    int N, M; cin >> N >> M;\n    vector<int> value(N);\n\n    for(int i=0; i<N; i++) {\n        cin >> value[i];\n    }\n\n    Graph<int> G(N);\n    for(int i=0; i<M; i++) {\n        int u, v; cin >> u >> v;\n        u--; v--;\n        G[u].push_back(Edge<int>(v, 1));\n        G[v].push_back(Edge<int>(u, 1));\n    }\n\n    graphLink<int> gl(G, 0);\n    gl.BICC();\n\n    int cmpN = gl.H.size();\n\n    // 縮約後の頂点に含まれる元の頂点数\n    vector<int> cmp_vs(cmpN), cmpValue(cmpN);\n    for(int i=0; i<N; i++) {\n        cmp_vs[ gl.cmp[i] ]++;\n        cmpValue[ gl.cmp[i] ] += value[i];\n    }\n\n    // 親の情報を求める\n    vector<int> par(cmpN, -1), is_leaf(cmpN, true);\n    construct(gl.H, gl.cmp[0], par);\n    for(int i=0; i<cmpN; i++) {\n        if(cmp_vs[i] >= 3) {\n            // big vertex\n            solve_one(i, par, cmpValue);\n        }\n        if(par[i] >= 0) is_leaf[ par[i] ] = false;\n    }\n\n    /*\n    for(int i=0; i<cmpN; i++) {\n        printf(\"vertex %d, par = %d, value = %d\\n\", i, par[i], cmpValue[i]);\n    }\n    */\n\n    ans += solve_two(gl.cmp[0], gl.H, cmpValue);\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <map>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<ll, ll>;\n\nstruct Graph {\n    Graph(const ll n)\n    {\n        edge.resize(n);\n        revedge.resize(n);\n    }\n    void addEdge(const ll from, const ll to)\n    {\n        edge[from].push_back(to);\n        revedge[to].push_back(from);\n    }\n    vector<vector<ll>> edge;\n    vector<vector<ll>> revedge;\n};\n\nvoid depth_dfs(const Graph& g, Graph& dig, map<pii, ll>& diedge, map<pii, ll>& resedge, const ll s, vector<ll>& depth, vector<bool>& used, const ll deg)\n{\n    depth[s] = deg;\n    for (const ll to : g.edge[s]) {\n        if (not used[to]) {\n            used[to] = true;\n            dig.addEdge(s, to);\n            diedge[make_pair(s, to)] = 0;\n            resedge.erase(make_pair(s, to));\n            resedge.erase(make_pair(to, s));\n            depth_dfs(g, dig, diedge, resedge, to, depth, used, deg + 1);\n        }\n    }\n}\n\nvoid accum(const Graph& dig, const ll s, map<pii, ll>& diedge)\n{\n    for (const ll to : dig.edge[s]) {\n        ll sum = 0;\n        accum(dig, to, diedge);\n        for (const ll to2 : dig.edge[to]) {\n            sum += diedge[make_pair(to, to2)];\n        }\n        diedge[make_pair(s, to)] += sum;\n    }\n}\n\nvoid cc_dfs(const Graph& newg, const ll s, vector<ll>& comp, vector<bool>& visited, const ll cnum)\n{\n    visited[s] = true;\n    comp[s] = cnum;\n    for (const ll to : newg.edge[s]) {\n        cc_dfs(newg, to, comp, visited, cnum);\n    }\n}\n\nvoid decomp(const Graph& dig, Graph& decomped, const ll s, const vector<ll>& comp, set<pii>& decomped_edge)\n{\n    const ll c1 = comp[s];\n    for (const ll to : dig.edge[s]) {\n        decomp(dig, decomped, to, comp, decomped_edge);\n        const ll c2 = comp[to];\n        if (c1 != c2 and decomped_edge.find(make_pair(c1, c2)) == decomped_edge.end()) {\n            decomped_edge.insert(make_pair(c1, c2));\n            decomped.addEdge(c1, c2);\n        }\n    }\n}\n\nll weight_dfs(const Graph& decomped, const ll s, const vector<ll>& weight)\n{\n    ll maxi = 0;\n    for (const ll to : decomped.edge[s]) {\n        maxi = max(maxi, weight_dfs(decomped, to, weight));\n    }\n    return weight[s] + maxi;\n}\n\nint main()\n{\n    ll N, M;\n    cin >> N >> M;\n    Graph g(N);\n    vector<ll> w(N);\n    for (ll i = 0; i < N; i++) {\n        cin >> w[i];\n    }\n    map<pii, ll> edges;\n    for (ll i = 0; i < M; i++) {\n        ll u, v;\n        cin >> u >> v;\n        u--, v--;\n        g.addEdge(u, v);\n        g.addEdge(v, u);\n        edges[make_pair(u, v)] = 0;\n        edges[make_pair(v, u)] = 0;\n    }\n    Graph dig(N);\n    map<pii, ll> diedge;\n    map<pii, ll> resedge = edges;\n    vector<ll> depth(N, 0);\n    vector<bool> used(N, false);\n    used[0] = true;\n    depth_dfs(g, dig, diedge, resedge, 0, depth, used, 0);\n    map<pii, ll> resedge_ = resedge;\n    resedge.clear();\n    for (const auto& e : resedge_) {\n        const ll u = e.first.first;\n        const ll v = e.first.second;\n        if (resedge.find(make_pair(v, u)) == resedge.end()) {\n            resedge[make_pair(u, v)] = 0;\n        }\n    }\n    for (const auto& e : resedge) {\n        const ll u = e.first.first;\n        const ll v = e.first.second;\n        ll a;\n        ll b;\n        if (depth[u] < depth[v]) {\n            b = u;\n            a = v;\n        } else {\n            b = v;\n            a = u;\n        }\n        if (not dig.revedge[b].empty()) {\n            const ll par = dig.revedge[b][0];\n            diedge[make_pair(par, b)]--;\n        }\n        const ll par = dig.revedge[a][0];\n        diedge[make_pair(par, a)]++;\n    }\n    vector<ll> node(N, 0);\n    accum(dig, 0, diedge);\n    Graph newg(N);\n    for (const auto& e : diedge) {\n        if (e.second != 0) {\n            const ll u = e.first.first;\n            const ll v = e.first.second;\n            newg.addEdge(u, v);\n        }\n    }\n    vector<bool> visited(N, false);\n    vector<ll> comp(N, 0);\n    ll cnum = 0;\n    for (ll i = 0; i < N; i++) {\n        if (not visited[i]) {\n            cc_dfs(newg, i, comp, visited, cnum);\n            cnum++;\n        }\n    }\n    vector<ll> weight(cnum, 0);\n    for (ll i = 0; i < N; i++) {\n        const ll c = comp[i];\n        weight[c] += w[i];\n    }\n    set<pii> decomped_edge;\n    Graph decomped(cnum);\n    decomp(dig, decomped, 0, comp, decomped_edge);\n\n    cout << weight_dfs(decomped, 0, weight) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct data {\n  int p, bf;\n  long long sum;\n};\n\nstruct Unionfind {\n  vector<int> par;\n  vector<int> treerank;\n  Unionfind(int n = 1) { stree(n + 1); }\n  void stree(int n = 1) {\n    par.assign(n, -1);\n    treerank.assign(n, 0);\n  }\n  int root(int x) {\n    if(par[x] < 0) return x;\n    return par[x] = root(par[x]);\n  }\n  bool issame(int x, int y) { return root(x) == root(y); }\n  bool uni(int x, int y) {\n    x = root(x);\n    y = root(y);\n    if(x == y) return 0;\n    if(treerank[x] > treerank[y]) swap(x, y);\n    if(treerank[x] == treerank[y]) ++treerank[y];\n    par[y] -= size(x);\n    par[x] = y;\n    return 1;\n  }\n  int size(int x) { return -par[root(x)]; }\n};\n\nlong long n, m, sum = 0;\nvector<long long> w, edge[100005], memo;\nvector<bool> used, passed;\nUnionfind uf;\nqueue<data> qu;\n\nlong long solve();\nbool dfs(int now, int bf);\n\nint main() {\n  cin >> n >> m;\n  w.resize(n);\n  for(int i = 0; i < n; ++i) cin >> w[i];\n  for(int i = 0; i < m; ++i) {\n    int x, y;\n    cin >> x >> y;\n    edge[--x].push_back(--y);\n    edge[y].push_back(x);\n  }\n  cout << solve() << endl;\n  return 0;\n}\n\nlong long solve() {\n  long long ans = 0;\n  uf = Unionfind(n);\n  sum = w[0];\n  passed.assign(n, 0);\n  used.assign(n, 0);\n  dfs(0, -1);\n  memo.assign(n, 0);\n  for(int i = 0; i < n; ++i)\n    if(uf.issame(i, 0)) {\n      bool ch = 0;\n      for(int j = 0; j < edge[i].size(); ++j)\n        if(!uf.issame(0, edge[i][j])) {\n          ch = 1;\n          break;\n        }\n      if(ch) qu.push({i, -1, 0});\n    }\n  while(!qu.empty()) {\n    data now = qu.front();\n    qu.pop();\n    if(memo[now.p] != now.sum) continue;\n    for(int i = 0; i < edge[now.p].size(); ++i)\n      if(edge[now.p][i] != now.bf &&\n         !uf.issame(0, edge[now.p][i])) {\n        data nextp = now;\n        nextp.p = edge[now.p][i];\n        nextp.bf = now.p;\n        nextp.sum += w[nextp.p];\n        ans = max(ans, nextp.sum);\n        if(memo[nextp.p] < nextp.sum) {\n          memo[nextp.p] = nextp.sum;\n          qu.push(nextp);\n        }\n      }\n  }\n\n  return ans + sum;\n}\n\nbool dfs(int now, int bf) {\n  if(used[now]) return 1;\n  if(passed[now]) return 0;\n  used[now] = 1;\n  passed[now] = 1;\n  bool ans = 0;\n  for(int i = 0; i < edge[now].size(); ++i)\n    if(bf != edge[now][i]) ans |= dfs(edge[now][i], now);\n  used[now] = 0;\n  if(ans) {\n    uf.uni(0, now);\n    if(now != 0) sum += w[now];\n  }\n  return ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\n\nll N, M, W[100000], cnt[100000];\nvector<ll> E[100000], candidate;\nbool visited[100000], check[100000];\n\nvoid dfs_candidate(ll v) {\n  visited[v] = true;\n  for(ll u : E[v]) if(!visited[u]) {\n    if(!check[v] && check[u]) candidate.push_back(u);\n    else dfs_candidate(u);\n  }\n}\n\nll dfs(ll v) {\n  ll ret = 0;\n  visited[v] = true;\n  for(ll u : E[v]) if(!visited[u]) ret = max(ret, dfs(u));\n  return ret + W[v];\n}\n\nint main(void) {\n  cin >> N >> M;\n  REP(i, 0, N) cin >> W[i];\n  REP(i, 0, M) {\n    ll U, V; cin >> U >> V; U--; V--;\n    E[U].push_back(V);\n    E[V].push_back(U);\n  }\n\n  queue<ll> q;\n  REP(i, 0, N) cnt[i] = E[i].size();\n  REP(i, 1, N) if(cnt[i] == 1) q.push(i);\n  REP(i, 0, N) check[i] = false;\n  while(q.size()) {\n    ll v = q.front();\n    q.pop();\n    if(v == 0) continue;\n    check[v] = true;\n    for(ll u : E[v]) if(--cnt[u] == 1) q.push(u);\n  }\n\n  REP(i, 0, N) visited[i] = false;\n  dfs_candidate(0);\n\n  ll ans = 0;\n  REP(i, 0, N) visited[i] = false;\n  REP(i, 0, N) if(!check[i]) visited[i] = true;\n  for(ll v : candidate) ans = max(ans, dfs(v));\n  REP(i, 0, N) if(!check[i]) ans += W[i];\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing Weight=int;\n\nstruct Edge{\n    int src,dst;\n    Edge(int src,int dst):\n    src(src),dst(dst){}\n};\n\nusing Edges=vector<Edge>;\nusing Graph=vector<Edges>;\n\nint memo[100001];\n\npair<vector<int>, Edges> bridge(const Graph& g) {\n\tconst int n = g.size();\n\tint idx = 0, s = 0, t = 0, k = 0;\n\tvector<int>ord(n, -1), onS(n), stk(n), roots(n), cmp(n);\n\tEdges brdg;\n\tfunction<void(int, int)> dfs = [&](int v, int u) {\n\t\tord[v] = idx++;\n\t\tstk[s++] = v;\n\t\tonS[v] = true;\n\t\troots[t++] = v;\n\t\tfor (auto& e : g[v]) {\n\t\t\tint w = e.dst;\n\t\t\tif (ord[w] == -1)dfs(w, v);\n\t\t\telse if (u != w && onS[w])\n\t\t\t\twhile (ord[roots[t - 1]]>ord[w])--t;\n\t\t}\n\t\tif (v == roots[t - 1]) {\n\t\t\tbrdg.emplace_back(u, v);\n\t\t\twhile (true) {\n\t\t\t\tint w = stk[--s];\n\t\t\t\tonS[w] = false;\n\t\t\t\tcmp[w] = k;\n\t\t\t\tif (v == w)break;\n\t\t\t}\n\t\t\t--t;\n\t\t\t++k;\n\t\t}\n\t};\n\tfor (int u = 0; u<n; ++u) {\n\t\tif (ord[u] == -1) {\n\t\t\tdfs(u, n);\n\t\t\tbrdg.pop_back();\n\t\t}\n\t}\n\treturn make_pair(cmp, brdg);\n}\n\nbool dfs0(const Graph &g,int p,int v,vector<bool> &elect,\nvector<int>&elements,vector<int>&cycle){\n    for(auto e:g[v]){\n        if(e.dst==p)continue;\n        if(elements[cycle[e.dst]]>1 || elect[e.dst])return elect[v]=1;\n        if(dfs0(g,v,e.dst,elect,elements,cycle))return elect[v]=1;\n    }\n    return 0;\n}\n\nint dfs1(const Graph &g,int p,int v,vector<bool> &elect,\nvector<int>&elements,vector<int>&cycle,vector<Weight>&node){\n    if(memo[v])return memo[v];\n    int res=0;\n    for(auto e:g[v]){\n        if(elect[e.dst]){\n            return memo[v]=node[v];\n        }\n        if(e.dst!=p && elements[cycle[e.dst]]==1){\n            res=dfs1(g,v,e.dst,elect,elements,cycle,node);\n            if(res){\n                return memo[v]=res+node[v];\n            }\n        }\n    }\n    return 0;\n}\n\nint main(){\n    int n,m;\n    cin>>n>>m;\n    Graph g(n);\n    vector<Weight>node(n);\n    for(int i=0;i<n;++i){\n        cin>>node[i];\n    }\n    for(int i=0;i<m;++i){\n        int s,t;\n        cin>>s>>t;\n        --s;--t;\n        g[s].emplace_back(s,t);\n        g[t].emplace_back(t,s);\n    }\n    vector<int>cycle = bridge(g).first;\n    vector<int>elements(n,0);\n    for(int i=0;i<n;++i){\n        elements[cycle[i]]++;\n    }\n    vector<bool>elect(n,false);\n    elect[0]=true;\n    for(int i=1;i<n;++i){\n        if(elements[cycle[i]]>1){\n            dfs0(g,-1,i,elect,elements,cycle);\n        }\n    }\n    int buf=0;\n    for(int i=1;i<n;++i){\n        if(g[i].size()==1){\n            buf=max(buf,dfs1(g,-1,g[i][0].src,elect,elements,cycle,node));\n        }\n    }\n    int ans=0;\n    for(int i=0;i<n;++i){\n        if(elect[i]){\n            ans+=node[i];\n        }\n    }\n    ans+=buf;\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\ntypedef long long  ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\ntypedef vector<int> vec;\n\nconst int mn = 100000;\nvector<int> G[100000];\nint w[100000];\n\nint c[100000];\nbool non[100000];\n\nint sum, ma;\nbool exi0 = false;\nint dfs(int id, int fr) {\n\tif (id == 0)exi0 = true;\n\tint ret = 0;\n\trep(j, G[id].size()) {\n\t\tint to = G[id][j];\n\t\tif (fr == to)continue;\n\t\tif (!non[to]) {\n\t\t\tret = max(ret, sum + ma);\n\t\t}\n\t\telse {\n\t\t\tret = max(ret, dfs(to, id));\n\t\t}\n\t}\n\treturn ret + w[id];\n}\n\nvoid solve() {\n\tint n, m; cin >> n >> m;\n\trep(i, n)cin >> w[i];\n\trep(i, m) {\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t\tc[a]++; c[b]++;\n\t}\n\tqueue<int> q;\n\trep(i, n) {\n\t\tif (c[i] == 1) {\n\t\t\tq.push(i);\n\t\t\tnon[i] = true;\n\t\t}\n\t}\n\twhile (!q.empty()) {\n\t\tint id = q.front(); q.pop();\n\t\trep(j, G[id].size()) {\n\t\t\tint to = G[id][j];\n\t\t\tc[to]--;\n\t\t\tif (c[to] == 1) {\n\t\t\t\tq.push(to);\n\t\t\t\tnon[to] = true;\n\t\t\t}\n\t\t}\n\t}\n\trep(i, n) {\n\t\tif (!non[i])sum += w[i];\n\t}\n\trep(i, n)if (!non[i]) {\n\t\trep(j, G[i].size()) {\n\t\t\tint to = G[i][j];\n\t\t\tif (!non[to])continue;\n\t\t\texi0 = false;\n\t\t\tint z = dfs(to, i);\n\t\t\tif (!exi0) {\n\t\t\t\tma = max(ma, dfs(to, i));\n\t\t\t}\n\t\t}\n\t}\n\tif (!non[0]) {\n\t\tcout << sum + ma << endl;\n\t}\n\telse {\n\t\tint ans = dfs(0, -1);\n\t\tcout << ans << endl;\n\t}\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(5);\n\t//while (cin >> n,n)solve();\n\tsolve();\n\t//stop\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int, int> P;\nconst int M = 1000000007;\n\nvector<vector<int>> edge;\nvector<vector<int>> tecomp;\nvector<set<int>> nedge;\nvector<int> uid, uuid;\nvector<int> nw;\n\n\n\nvoid visit(int v, int u,\n        stack<int>& roots, stack<int>& S, vector<bool>& inS,\n        vector<int>& num, int& tm) {\n    num[v] = ++tm;\n    S.push(v); inS[v] = true;\n    roots.push(v);\n    for (int w : edge[v]) {\n        if (num[w] == 0)\n            visit(w, v, roots, S, inS, num, tm);\n        else if (u != w && inS[w])\n            while (num[roots.top()] > num[w]) roots.pop();\n    }\n    if (v == roots.top()) {\n        tecomp.push_back(vector<int>());\n        while (1) {\n            int w = S.top(); S.pop(); inS[w] = false;\n            tecomp.back().push_back(w);\n            if (v == w) break;\n        }\n        roots.pop();\n    }\n}\n\n\nbool dfs(int now, int par, int zero) {\n    bool ret = tecomp[now].size() > 1;\n    for (int i : nedge[now]) {\n        if (i == par) continue;\n        ret |= dfs(i, now, zero);\n    }\n    if (ret) {\n        uuid[now] = zero;\n    }\n    return ret;\n}\nint dfs(int now, int par) {\n    int ret = 0;\n    for (int i : nedge[now]) {\n        if (i == par) continue;\n        ret = max(ret, dfs(i, now));\n    }\n    return ret + nw[now];\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<int> w(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> w[i];\n    }\n    edge.resize(n);\n    for (int i = 0; i < m; ++i) {\n        int a, b;\n        cin >> a >> b;\n        --a;\n        --b;\n        edge[a].push_back(b);\n        edge[b].push_back(a);\n    }\n    vector<int> num(n, 0);\n    vector<bool> inS(n);\n    stack<int> roots, S;\n    int tm = 0;\n    for (int u = 0; u < n; ++u)\n        if (num[u] == 0)\n            visit(u, n, roots, S, inS, num, tm);\n\n    int nn = tecomp.size();\n    uid.resize(n);\n    for (int i = 0; i < nn; ++i) {\n        for (int j : tecomp[i])\n            uid[j] = i;\n    }\n    int zero = uid[0];\n    nedge.resize(nn);\n    for (int i = 0; i < n; ++i) {\n        for (int j : edge[i]) {\n            if (uid[i] != uid[j])\n                nedge[uid[i]].insert(uid[j]);\n        }\n    }\n    uuid.resize(n);\n    for (int i = 0; i < n; ++i) {\n        uuid[i] = i;\n    }\n    dfs(zero, -1, zero);\n    nw.resize(nn, 0);\n    for (int i = 0; i < n; ++i) {\n        nw[uuid[uid[i]]] += w[i];\n    }\n    vector<int> useduid(nn, 0);\n    vector<int> used(nn, 0);\n    int ma = 0;\n    for (int i = 0; i < n; ++i) {\n        if (!useduid[uid[i]] && uuid[uid[i]] == zero) {\n            useduid[uid[i]] = 1;\n            for (int j : nedge[uid[i]]) {\n                if (uuid[j] != zero && !used[j]) {\n                    used[j] = 1;\n                    ma = max(ma, dfs(j, uid[i]));\n                }\n            }\n        }\n    }\n    cout << (nw[zero] + ma) << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_V 100000\nusing namespace std;\nint m,w[100001];\nvector<int> vv[100001];\nunordered_set<int> st[100001];\nint V;\nvector<int> G[MAX_V];\nvector<int> rG[MAX_V];\nvector<int> vs;\nbool used[MAX_V];\nint cmp[MAX_V];\nint C[100001],F[100001],U[100001],ans;\nbool UU[100001];\n\n\nvoid DFS(int p){\n  for(int i=0;i<vv[p].size();i++){\n    int mn=min(vv[p][i],p),mx=max(vv[p][i],p);\n    if(st[mn].find(mx)==st[mn].end()){\n      st[mn].insert(mx);\n      G[p].push_back(vv[p][i]);\n      rG[vv[p][i]].push_back(p);\n      DFS(vv[p][i]);\n    }\n  }\n}\n\nvoid dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++)if(!used[G[v][i]])dfs(G[v][i]);\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v]=true;\n  cmp[v]=k;\n  for(int i=0;i<rG[v].size();i++)if(!used[rG[v][i]])rdfs(rG[v][i],k);\n}\n\nint scc(){\n  for(int v=0;v<V;v++)if(!used[v])dfs(v);\n  memset(used,0,sizeof(used));\n  int k=0;\n  for(int i=vs.size()-1;i>=0;i--)if(!used[vs[i]])rdfs(vs[i],k++);\n  return k;\n}\n\nbool DFS1(int p){\n  if(U[p])return 0;\n  U[p]=1;\n  bool f=F[cmp[p]]>=2;\n  for(int i=0;i<G[p].size();i++)\n    f|=DFS1(G[p][i]);\n  ans+=w[p]*f;\n  return UU[p]=f;\n}\nbool UUU[100001];\nint DFS2(int p){\n  if(UUU[p])return 0;\n  UUU[p]=1;\n  int res=0;\n  \n  for(int i=0;i<G[p].size();i++)\n    res=max(res,DFS2(G[p][i]));  \n  return res+(UU[p]?0:w[p]);\n}\n\nint main(){\n  cin>>V>>m;\n  for(int i=0;i<V;i++)cin>>w[i];\n  for(int j=0,a,b;j<m;j++){\n    cin>>a>>b;a--,b--;\n    vv[a].push_back(b),vv[b].push_back(a);\n  }\n  DFS(0);\n  int t=0;\n  for(int i=0;i<V;i++)t+=w[i];\n  scc();\n  for(int i=0;i<V;i++)F[cmp[i]]++;\n  DFS1(0);\n  cout<<ans+DFS2(0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(i,v.size())cout<<\" \"<<v[i];cout<<endl<<endl;\n#define show2d(v) rep(i,v.size()){rep(j,v[i].size())cout<<\" \"<<v[i][j];cout<<endl;}cout<<endl;\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<int,int,int> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};//ESWN\nclass BRI{\n\tpublic:\n\tint n,N;\n\tvi order,inS,cmp;\n\tvp brg;\n\tvvi G,each_bcc;\n\t// N : scc後の頂点数\n\t// brg : 橋一覧\n\t// each_bcc : 二重連結成分のリスト\n\t// cmp : ある頂点がどの二重連結成分に含まれているか\n\tstack<int> roots, S;\n\tBRI(int size){\n\t\tn=size;\n\t\tG=vvi(n);\n\t}\n\tvoid add_edge(int s,int t){\n\t\tG[s].pb(t);\n\t\tG[t].pb(s);\n\t}\n\tvoid visit(int cur,int prev,int &k){\n\t\torder[cur]=++k;\n\t\tS.push(cur);\n\t\tinS[cur]=true;\n\t\troots.push(cur);\n\t\t\n\t\trep(i,G[cur].size()){\n\t\t\tint to=G[cur][i];\n\t\t\tif(!order[to])visit(to,cur,k);\n\t\t\telse if(to!=prev&&inS[to])\n\t\t\t\twhile(order[roots.top()]>order[to])roots.pop();\n\t\t}\n\t\t\n\t\tif(cur==roots.top()){\n\t\t\tif(prev!=-1)brg.pb({prev,cur});\n\t\t\tvi bcc;\n\t\t\twhile(1){\n\t\t\t\tint node=S.top();\n\t\t\t\tS.pop();\n\t\t\t\tinS[node]=false;\n\t\t\t\tbcc.pb(node);\n\t\t\t\tcmp[node]=N;\n\t\t\t\tif(node==cur)break;\n\t\t\t}\n\t\t\tN++;\n\t\t\teach_bcc.pb(bcc);\n\t\t\troots.pop();\n\t\t}\n\t}\n\tvoid bri(){\n\t\tN=0;\n\t\torder=inS=cmp=vi(n);\n\t\troots=S=stack<int>();\n\t\tint k=0;\n\t\trep(i,n)if(order[i]==0)\n\t\t\tvisit(i,-1,k);\n\t}\n\tvvi make(){\n\t\tvvi tG(N);\n\t\trep(i,brg.size()){\n\t\t\tint a=brg[i].first,b=brg[i].second;\n\t\t\ttG[cmp[a]].pb(cmp[b]);\n\t\t\ttG[cmp[b]].pb(cmp[a]);\n\t\t}\n\t\treturn tG;\n\t}\n\tvvi f(vi w){\n\t\tvvi out(N,vi(2));\n\t\trep(i,n){\n\t\t\tout[cmp[i]][1]++;\n\t\t\tout[cmp[i]][0]+=w[i];\n\t\t}\n\t\treturn out;\n\t}\n};\nvvi data;\nint n,m;\nvvi G;\nvi used;\npii dfs(int a){\n\tint out1=0,out2=0;\n\tused[a]=true;\n\trep(i,G[a].size())if(used[G[a][i]]==0){\n\t\tpii t=dfs(G[a][i]);\n\t\tout1=max(out1,t.first);\n\t\tout2+=t.second;\n\t}\n\tif(out2||data[a][1]-1)out2+=data[a][0];\n\telse out1+=data[a][0];\n\treturn {out1,out2};\n}\nint main(){\n\tcin>>n>>m;\n\tvi w(n);\n\trep(i,n)cin>>w[i];\n\tBRI bri(n);\n\twhile(m--){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\ta--;b--;\n\t\tbri.add_edge(a,b);\n\t}\n\tbri.bri();\n\tn=bri.N;\n\tG=bri.make();\n\tdata=bri.f(w);\n\tused=vi(n);\n\tpii ans=dfs(bri.cmp[0]);\n\tcout<<ans.first+ans.second<<endl;\n}\n\n\t\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\nclass Node{\n\tpublic:\n\t\tint ord; //DFSの訪問の順番\n\t\tint par; //DFS Treeにおける親\n\t\tint low; //min(自分のord, 逆辺がある場合の親のord, すべての子のlow)\n\t\tNode() : ord(-1) { }\n};\n\nclass ArticulationPoints {\n\tprivate:\n\t\tint v, cnt;\n\t\tvector<Node> node;\n\t\tvoid dfs(int cur, int prev){\n\t\t\tnode[cur].ord = node[cur].low = cnt;\n\t\t\tcnt++;\n\n\t\t\tfor(auto to : g[cur]){\n\t\t\t\tif(to == prev) continue;\n\t\t\t\tif(node[to].ord >= 0){\n\t\t\t\t\tnode[cur].low = min(node[cur].low, node[to].ord);\n\t\t\t\t}else{\n\t\t\t\t\tnode[to].par = cur;\n\t\t\t\t\tdfs(to, cur);\n\t\t\t\t\tnode[cur].low = min(node[cur].low, node[to].low);\n\t\t\t\t}\n\t\t\t\tif(node[cur].ord < node[to].low){\n\t\t\t\t\tbridge.emplace_back(min(cur, to), max(cur, to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tpublic:\n\t\tvector<vector<int>> g;\n\t\tvector<pair<int, int>> bridge;\n\t\tset<int> ap; // 関節店\n\t\tArticulationPoints(int n) : v(n), cnt(1), node(n), g(n) { }\n\t\tvoid addEdge(int a, int b){\n\t\t\tg[a].emplace_back(b);\n\t\t\tg[b].emplace_back(a);\n\t\t}\n\t\tbool isBridge(int u, int v){\n\t\t\tif(node[u].ord > node[v].ord) swap(u,v);\n\t\t\treturn node[u].ord < node[v].low;\n\t\t}\n\t\tvoid run(){\n\t\t\tdfs(0, -1); // 0 = root\n\n\t\t\tint np = 0;\n\t\t\trange(i,1,v){\n\t\t\t\tint p = node[i].par;\n\t\t\t\tif(p == 0) np++;\n\t\t\t\telse if(node[p].ord <= node[i].low) ap.emplace(p);\n\t\t\t}\n\t\t\tif(np > 1) ap.emplace(0);\n\t\t\tsort(all(bridge));\n\t\t\t//for(auto it:ap){ cout << it << endl; } //関節点の全列挙\n\t\t\t//for(auto it:bridge){ cout << it.first << ' ' << it.second << endl; } //橋の全列挙\n\t\t}\n};\n\nclass TwoEdgeConnectedComponent : public ArticulationPoints {\n\tprivate:\n\t\tvoid dfs(int c, int pos){\n\t\t\tver[c].emplace_back(pos);\n\t\t\tcomp[pos] = c;\n\t\t\tfor (int to : g[pos]) {\n\t\t\t\tif (comp[to] >= 0) continue;\n\t\t\t\tif (isBridge(pos, to)) continue;\n\t\t\t\tdfs(c, to);\n\t\t\t}\n\t\t}\n\t\tvoid addComp(int pos){\n\t\t\tif(comp[pos] >= 0) return;\n\t\t\tver.emplace_back();\n\t\t\tdfs(ver.size() - 1, pos);\n\t\t}\n\tpublic:\n\t\tvector<int> comp; // 成分分解前の頂点から分解後の頂点への写像？\n\t\tvector<vector<int>> ver; // 分解後の頂点と、その頂点に含まれる分解前の頂点\n\t\tTwoEdgeConnectedComponent(int n) : ArticulationPoints(n), comp(n,-1) {}\n\t\tvoid solve(){\n\t\t\trun();\n\t\t\tfor(auto p : bridge){\n\t\t\t\taddComp(p.first);\n\t\t\t\taddComp(p.second);\n\t\t\t}\n\t\t\taddComp(0);\n\t\t}\n\t\tvector<vector<int>> getTree(){\n\t\t\tvector<vector<int>> res(ver.size());\n\t\t\tfor(auto p : bridge){\n\t\t\t\tint u = comp[p.first], v = comp[p.second];\n\t\t\t\tres[u].emplace_back(v);\n\t\t\t\tres[v].emplace_back(u);\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n};\n\nvoid cut(vector<vector<int>>& g, vector<vector<int>>& node, vector<int>& in, vector<bool>& used, vector<int>& p, int pos){\n\tused[pos] = true;\n\tfor(auto to : g[pos]){\n\t\tif(used[to]) continue;\n\t\tcut(g, node, in, used, p, to);\n\t}\n\tif(in[pos] == 1){\n\t\tfor(auto to : g[pos]){\n\t\t\tin[to]--;\n\t\t}\n\t\tp.emplace_back(pos);\n\t}\n}\n\nint dfs(vector<vector<int>>& g, vector<int>& w, vector<bool>& used, int pos){\n\tint res = w[pos];\n\tused[pos] = true;\n\tfor(auto to : g[pos]){\n\t\tif(used[to]) continue;\n\t\tres += dfs(g, w, used, to);\n\t}\n\treturn res;\n}\n\nint main(){\n\tint n, m;\n\tcin >> n >> m;\n\n\tvector<int> w(n);\n\tcin >> w;\n\n\tTwoEdgeConnectedComponent tecc(n);\n\trep(i,m){\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tu--; v--;\n\t\ttecc.addEdge(u,v);\n\t}\n\ttecc.solve();\n\tvector<vector<int>> g = tecc.getTree();\n\tvector<int> in(n);\n\trep(i,n) in[i] = g[i].size();\n\n\tvector<int> p;\n\tvector<bool> used(n,0);\n\tcut(g, tecc.ver, in, used, p, 0);\n\n\tvector<int> cg(g.size(),0);\n\tint ans = accumulate(all(w), 0);\n\tshow(ans)\n\t\trep(i,p.size()){\n\t\t\tcg[p[i]] = p[i];\n\t\t\tans -= w[p[i]];\n\t\t}\n\n\tvector<vector<int>> ng(g.size());\n\trep(i,g.size()){\n\t\tfor(auto j : g[i]){\n\t\t\tif(cg[i] == 0 and cg[j] == 0) continue;\n\t\t\tng[ cg[i] ].emplace_back( cg[j] );\n\t\t\tng[ cg[j] ].emplace_back( cg[i] );\n\t\t}\n\t}\n\n\tused = vector<bool>(n,0);\n\tused[0] = true;\n\tint maxi = 0;\n\tfor(auto i : ng[0]){\n\t\tmaxi = max(maxi, dfs(ng, w, used, i));\n\t}\n\tcout << ans + maxi << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\ntypedef long long  ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\ntypedef double ld;\ntypedef complex<ld> Point;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\ntypedef pair<ld, ld> LDP;\ntypedef pair<ll, ll> LP;\ntypedef vector<int> vec;\n\nconst int mn = 100000;\nvector<int> G[100000];\nint w[100000];\n\nint c[100000];\nbool non[100000];\n\nint sum, ma;\nbool exi0 = false;\nint dfs(int id, int fr) {\n\tif (id == 0)exi0 = true;\n\tint ret = 0;\n\trep(j, G[id].size()) {\n\t\tint to = G[id][j];\n\t\tif (fr == to)continue;\n\t\tif (!non[to]) {\n\t\t\tret = max(ret, sum + ma);\n\t\t}\n\t\telse {\n\t\t\tret = max(ret, dfs(to, id));\n\t\t}\n\t}\n\treturn ret + w[id];\n}\nint csum;\nbool dfs2(int id, int fr) {\n\trep(j, G[id].size()) {\n\t\tint to = G[id][j];\n\t\tif (fr == to)continue;\n\t\tif (!non[to]) {\n\t\t\tcsum += w[id];\n\t\t\tw[id] = 0;\n\t\t\treturn true;\n\t\t}\n\t\tif (dfs2(to, id)) {\n\t\t\tcsum += w[id];\n\t\t\tw[id] = 0;\n\t\t}\n\t}\n\treturn false;\n}\n\nvoid solve() {\n\tint n, m; cin >> n >> m;\n\trep(i, n)cin >> w[i];\n\trep(i, m) {\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t\tc[a]++; c[b]++;\n\t}\n\tqueue<int> q;\n\trep(i, n) {\n\t\tif (c[i] == 1) {\n\t\t\tq.push(i);\n\t\t\tnon[i] = true;\n\t\t}\n\t}\n\twhile (!q.empty()) {\n\t\tint id = q.front(); q.pop();\n\t\trep(j, G[id].size()) {\n\t\t\tint to = G[id][j];\n\t\t\tc[to]--;\n\t\t\tif (c[to] == 1) {\n\t\t\t\tq.push(to);\n\t\t\t\tnon[to] = true;\n\t\t\t}\n\t\t}\n\t}\n\trep(i, n) {\n\t\tif (!non[i])sum += w[i];\n\t}\n\trep(i, n)if (!non[i]) {\n\t\trep(j, G[i].size()) {\n\t\t\tint to = G[i][j];\n\t\t\tif (!non[to])continue;\n\t\t\texi0 = false;\n\t\t\tint z = dfs(to, i);\n\t\t\tif (!exi0) {\n\t\t\t\tma = max(ma, dfs(to, i));\n\t\t\t}\n\t\t}\n\t}\n\tif (!non[0]) {\n\t\tcout << sum + ma << endl;\n\t}\n\telse {\n\t\tint ans = dfs(0, -1);\n\t\tint z=dfs2(0,-1);\n\t\trep(i, n)if (!non[i]) {\n\t\t\trep(j, G[i].size()) {\n\t\t\t\tint to = G[i][j];\n\t\t\t\tif (!non[to])continue;\n\t\t\t\tma = max(ma, dfs(to, i));\n\t\t\t}\n\t\t}\n\t\tans = max(ans, z + sum + ma);\n\t\tcout << ans << endl;\n\t}\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(5);\n\t//while (cin >> n,n)solve();\n\tsolve();\n\t//stop\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\nclass Node{\n\tpublic:\n\t\tint ord; //DFSの訪問の順番\n\t\tint par; //DFS Treeにおける親\n\t\tint low; //min(自分のord, 逆辺がある場合の親のord, すべての子のlow)\n\t\tNode() : ord(-1) { }\n};\n\nclass ArticulationPoints {\n\tprivate:\n\t\tint v, cnt;\n\t\tvector<Node> node;\n\t\tvoid dfs(int cur, int prev){\n\t\t\tnode[cur].ord = node[cur].low = cnt;\n\t\t\tcnt++;\n\n\t\t\tfor(auto to : g[cur]){\n\t\t\t\tif(to == prev) continue;\n\t\t\t\tif(node[to].ord >= 0){\n\t\t\t\t\tnode[cur].low = min(node[cur].low, node[to].ord);\n\t\t\t\t}else{\n\t\t\t\t\tnode[to].par = cur;\n\t\t\t\t\tdfs(to, cur);\n\t\t\t\t\tnode[cur].low = min(node[cur].low, node[to].low);\n\t\t\t\t}\n\t\t\t\tif(node[cur].ord < node[to].low){\n\t\t\t\t\tbridge.emplace_back(min(cur, to), max(cur, to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tpublic:\n\t\tvector<vector<int>> g;\n\t\tvector<pair<int, int>> bridge;\n\t\tset<int> ap; // 関節店\n\t\tArticulationPoints(int n) : v(n), cnt(1), node(n), g(n) { }\n\t\tvoid addEdge(int a, int b){\n\t\t\tg[a].emplace_back(b);\n\t\t\tg[b].emplace_back(a);\n\t\t}\n\t\tbool isBridge(int u, int v){\n\t\t\tif(node[u].ord > node[v].ord) swap(u,v);\n\t\t\treturn node[u].ord < node[v].low;\n\t\t}\n\t\tvoid run(){\n\t\t\tdfs(0, -1); // 0 = root\n\n\t\t\tint np = 0;\n\t\t\trange(i,1,v){\n\t\t\t\tint p = node[i].par;\n\t\t\t\tif(p == 0) np++;\n\t\t\t\telse if(node[p].ord <= node[i].low) ap.emplace(p);\n\t\t\t}\n\t\t\tif(np > 1) ap.emplace(0);\n\t\t\tsort(all(bridge));\n\t\t\t//for(auto it:ap){ cout << it << endl; } //関節点の全列挙\n\t\t\t//for(auto it:bridge){ cout << it.first << ' ' << it.second << endl; } //橋の全列挙\n\t\t}\n};\n\nclass TwoEdgeConnectedComponent : public ArticulationPoints {\n\tprivate:\n\t\tvoid dfs(int c, int pos){\n\t\t\tver[c].emplace_back(pos);\n\t\t\tcomp[pos] = c;\n\t\t\tfor (int to : g[pos]) {\n\t\t\t\tif (comp[to] >= 0) continue;\n\t\t\t\tif (isBridge(pos, to)) continue;\n\t\t\t\tdfs(c, to);\n\t\t\t}\n\t\t}\n\t\tvoid addComp(int pos){\n\t\t\tif(comp[pos] >= 0) return;\n\t\t\tver.emplace_back();\n\t\t\tdfs(ver.size() - 1, pos);\n\t\t}\n\tpublic:\n\t\tvector<int> comp; // 成分分解前の頂点から分解後の頂点への写像？\n\t\tvector<vector<int>> ver; // 分解後の頂点と、その頂点に含まれる分解前の頂点\n\t\tTwoEdgeConnectedComponent(int n) : ArticulationPoints(n), comp(n,-1) {}\n\t\tvoid solve(){\n\t\t\trun();\n\t\t\tfor(auto p : bridge){\n\t\t\t\taddComp(p.first);\n\t\t\t\taddComp(p.second);\n\t\t\t}\n\t\t\taddComp(0);\n\t\t}\n\t\tvector<vector<int>> getTree(){\n\t\t\tvector<vector<int>> res(ver.size());\n\t\t\tfor(auto p : bridge){\n\t\t\t\tint u = comp[p.first], v = comp[p.second];\n\t\t\t\tres[u].emplace_back(v);\n\t\t\t\tres[v].emplace_back(u);\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n};\n\nvoid cut(vector<vector<int>>& g, vector<int>& in, vector<bool>& used, vector<int>& p, int pos){\n\tused[pos] = true;\n\tfor(auto to : g[pos]){\n\t\tif(used[to]) continue;\n\t\tcut(g, in, used, p, to);\n\t}\n\tif(in[pos] == 1){\n\t\tfor(auto to : g[pos]){\n\t\t\tin[to]--;\n\t\t}\n\t\tp.emplace_back(pos);\n\t}\n}\n\nint dfs(vector<vector<int>>& g, vector<int>& w, vector<bool>& used, int pos){\n\tint res = w[pos];\n\tused[pos] = true;\n\tfor(auto to : g[pos]){\n\t\tif(used[to]) continue;\n\t\tres += dfs(g, w, used, to);\n\t}\n\treturn res;\n}\n\nvoid dfs(vector<vector<int>>& g, vector<vector<int>>& ver, vector<bool>& used, int pos){\n\tif(ver[pos].size() != 1) return;\n\tused[pos] = true;\n\tfor(auto to : g[pos]){\n\t\tif(used[pos]) continue;\n\t\tdfs(g, ver, used, to);\n\t}\n}\n\nint dfs(vector<vector<int>>& g, vector<vector<int>>& node, vector<int>& w, vector<bool>& used, int pos){\n\tint res = w[node[pos].at(0)];\n\tused[pos] = false;\n\tfor(auto to : g[pos]){\n\t\tif(not used[to]) continue;\n\t\tres += dfs(g, node, w, used, to);\n\t}\n\treturn res;\n}\n\nint main(){\n\tint n, m;\n\tcin >> n >> m;\n\n\tvector<int> w(n);\n\tcin >> w;\n\n\tTwoEdgeConnectedComponent tecc(n);\n\trep(i,m){\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tu--; v--;\n\t\ttecc.addEdge(u,v);\n\t}\n\ttecc.solve();\n\tvector<vector<int>> g = tecc.getTree();\n\n\tvector<bool> used(g.size(),0);\n\trep(i,g.size()){\n\t\tdfs(g, tecc.ver, used, i);\n\t}\n\n\t//rep(i,tecc.ver.size()){\n\t//\tshow(i)\n\t//\tfor(auto j : tecc.ver[i]) cout << j << endl;\n\t//}\n\n\tint ans = 0;\n\trep(i,g.size()){\n\t\tif(used[i]) continue;\n\t\tfor(auto j : tecc.ver[i]){\n\t\t\tans += w[j];\n\t\t}\n\t}\n\tif(ans == 0){\n\t\tans = w[0];\n\t\tused[0] = false;\n\t}\n\n\tint res = 0;\n\trep(i,g.size()){\n\t\tfor(auto j : g[i]){\n\t\t\tif(not used[i] and used[j]) res = max(res, dfs(g, tecc.ver, w, used, j));\n\t\t}\n\t}\n\n\tcout << ans + res << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct data {\n  int p, bf;\n  long long sum;\n};\n\nstruct Unionfind {\n  vector<int> par;\n  vector<int> treerank;\n  Unionfind(int n = 1) { stree(n + 1); }\n  void stree(int n = 1) {\n    par.assign(n, -1);\n    treerank.assign(n, 0);\n  }\n  int root(int x) {\n    if(par[x] < 0) return x;\n    return par[x] = root(par[x]);\n  }\n  bool issame(int x, int y) { return root(x) == root(y); }\n  bool uni(int x, int y) {\n    x = root(x);\n    y = root(y);\n    if(x == y) return 0;\n    if(treerank[x] > treerank[y]) swap(x, y);\n    if(treerank[x] == treerank[y]) ++treerank[y];\n    par[y] -= size(x);\n    par[x] = y;\n    return 1;\n  }\n  int size(int x) { return -par[root(x)]; }\n};\n\nlong long n, m, sum = 0;\nvector<long long> w, edge[100005], memo;\nvector<bool> used, passed;\nUnionfind uf;\nqueue<data> qu;\n\nlong long solve();\nbool dfs(int now, int bf);\n\nint main() {\n  cin >> n >> m;\n  w.resize(n);\n  for(int i = 0; i < n; ++i) cin >> w[i];\n  for(int i = 0; i < m; ++i) {\n    int x, y;\n    cin >> x >> y;\n    edge[--x].push_back(--y);\n    edge[y].push_back(x);\n  }\n  cout << solve() << endl;\n  return 0;\n}\n\nlong long solve() {\n  long long ans = 0;\n  uf = Unionfind(n);\n  sum = w[0];\n  passed.assign(n, 0);\n  used.assign(n, 0);\n  dfs(0, -1);\n  memo.assign(n, 0);\n  for(int i = 0; i < n; ++i)\n    if(uf.issame(i, 0)) {\n      bool ch = 0;\n      for(int j = 0; j < edge[i].size(); ++j)\n        if(!uf.issame(0, edge[i][j])) {\n          ch = 1;\n          break;\n        }\n      if(ch) qu.push({i, -1, 0});\n    }\n  while(!qu.empty()) {\n    data now = qu.front();\n    qu.pop();\n    if(memo[now.p] != now.sum) continue;\n    for(int i = 0; i < edge[now.p].size(); ++i)\n      if(edge[now.p][i] != now.bf &&\n         !uf.issame(0, edge[now.p][i])) {\n        data nextp = now;\n        nextp.p = edge[now.p][i];\n        nextp.bf = now.p;\n        nextp.sum += w[nextp.p];\n        ans = max(ans, nextp.sum);\n        if(memo[nextp.p] < nextp.sum) {\n          memo[nextp.p] = nextp.sum;\n          qu.push(nextp);\n        }\n      }\n  }\n\n  return ans + sum;\n}\n\nbool dfs(int now, int bf) {\n  if(used[now]) return 1;\n  if(passed[now]) return 0;\n  used[now] = 1;\n  passed[now] = 1;\n  bool ans = 0;\n  for(int i = 0; i < edge[now].size(); ++i)\n    if(bf != edge[now][i]) ans |= dfs(edge[now][i], now);\n  used[now] = 0;\n  if(ans) {\n    uf.uni(0, now);\n    if(now != 0) sum += w[now];\n  }\n  return ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nstruct Edge {\n\tint from, to;\n\tEdge(int f, int t) : from(f), to(t) {}\n};\n\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\n\npair<vector<int>, Edges> bridge(const Graph& g) {\n\tconst int n = g.size();\n\tint idx = 0, s = 0, t = 0, k = 0;\n\tvector<int>ord(n, -1), onS(n), stk(n), roots(n), cmp(n);\n\tEdges brdg;\n\tfunction<void(int, int)> dfs = [&](int v, int u) {\n\t\tord[v] = idx++;\n\t\tstk[s++] = v;\n\t\tonS[v] = true;\n\t\troots[t++] = v;\n\t\tfor (auto& e : g[v]) {\n\t\t\tint w = e.to;\n\t\t\tif (ord[w] == -1)dfs(w, v);\n\t\t\telse if (u != w && onS[w])\n\t\t\t\twhile (ord[roots[t - 1]]>ord[w])--t;\n\t\t}\n\t\tif (v == roots[t - 1]) {\n\t\t\tbrdg.emplace_back(u, v);\n\t\t\twhile (true) {\n\t\t\t\tint w = stk[--s];\n\t\t\t\tonS[w] = false;\n\t\t\t\tcmp[w] = k;\n\t\t\t\tif (v == w)break;\n\t\t\t}\n\t\t\t--t;\n\t\t\t++k;\n\t\t}\n\t};\n\tfor (int u = 0; u<n; ++u) {\n\t\tif (ord[u] == -1) {\n\t\t\tdfs(u, n);\n\t\t\tbrdg.pop_back();\n\t\t}\n\t}\n\treturn make_pair(cmp, brdg);\n}\n\nclass HLDecomposition {\n\tvector<vector<int>> g;\n\tvector<int> vid, head, heavy, parent, depth, inv;\n\tint dfs(int curr, int prev) {\n\t\tparent[curr] = prev;\n\t\tint sub = 1, max_sub = 0;\n\t\tfor (int next : g[curr]) if (next != prev) {\n\t\t\tdepth[next] = depth[curr] + 1;\n\t\t\tint sub_next = dfs(next, curr);\n\t\t\tsub += sub_next;\n\t\t\tif (max_sub < sub_next) max_sub = sub_next, heavy[curr] = next;\n\t\t}\n\t\treturn sub;\n\t}\n\tvoid bfs() {\n\t\tint k = 0;\n\t\tqueue<int> q({ 0 });\n\t\twhile (!q.empty()) {\n\t\t\tint h = q.front(); q.pop();\n\t\t\tfor (int i = h; i != -1; i = heavy[i]) {\n\t\t\t\tvid[i] = k++;\n\t\t\t\tinv[vid[i]] = i;\n\t\t\t\thead[i] = h;\n\t\t\t\tfor (int j : g[i]) if (j != parent[i] && j != heavy[i]) q.push(j);\n\t\t\t}\n\t\t}\n\t}\npublic:\n\tHLDecomposition(int n)\n\t\t: g(n), vid(n, -1), head(n), heavy(n, -1), parent(n), depth(n), inv(n) {}\n\n\tvoid add(int u, int v) {\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\tvoid build() {\n\t\tdfs(0, -1);\n\t\tbfs();\n\t}\n\tvoid for_each(int u, int v, function<void(int, int)> f) {\n\t\tif (vid[u] > vid[v]) swap(u, v);\n\t\tf(max(vid[head[v]], vid[u]), vid[v]);\n\t\tif (head[u] != head[v]) for_each(u, parent[head[v]], f);\n\t}\n\tvoid for_each_directed(int u, int v, function<void(int, int, int)> f) {\n\t\tif (vid[u] > vid[v]) {\n\t\t\tf(max(vid[head[u]], vid[v]), vid[u], 1);\n\t\t\tif (head[u] != head[v]) for_each_directed(parent[head[u]], v, f);\n\t\t}\n\t\telse {\n\t\t\tf(max(vid[head[v]], vid[u]), vid[v], 0);\n\t\t\tif (head[u] != head[v]) for_each_directed(u, parent[head[v]], f);\n\t\t}\n\t}\n\tvoid for_each_edge(int u, int v, function<void(int, int)> f) {\n\t\tif (vid[u] > vid[v]) swap(u, v);\n\t\tif (head[u] != head[v]) {\n\t\t\tf(vid[head[v]], vid[v]);\n\t\t\tfor_each_edge(u, parent[head[v]], f);\n\t\t}\n\t\telse {\n\t\t\tif (u != v) f(vid[u] + 1, vid[v]);\n\t\t}\n\t}\n\tint ancestor(int u, int d) {\n\t\twhile (true) {\n\t\t\tif (depth[head[u]] > depth[u] - d) {\n\t\t\t\td -= depth[u] - depth[head[u]] + 1;\n\t\t\t\tif (head[u] == 0) return 0;\n\t\t\t\tu = parent[head[u]];\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn inv[vid[u] - d];\n\t\t\t}\n\t\t}\n\t}\n\tint lca(int u, int v) {\n\t\tif (vid[u] > vid[v]) swap(u, v);\n\t\tif (head[u] == head[v]) return u;\n\t\treturn lca(u, parent[head[v]]);\n\t}\n\tint distance(int u, int v) {\n\t\treturn depth[u] + depth[v] - 2 * depth[lca(u, v)];\n\t}\n};\n\ntemplate <typename T>\nclass SegmentTree {\n\tusing func_t = function<T(T, T)>;\n\tconst int n;\n\tconst T id;\n\tfunc_t merge;\n\tvector<T> data;\n\tint size(int n) {\n\t\tint res;\n\t\tfor (res = 1; res < n; res <<= 1);\n\t\treturn res;\n\t}\n\tT sub(int l, int r, int node, int lb, int ub) {\n\t\tif (ub <= l || r <= lb) return id;\n\t\tif (l <= lb && ub <= r) return data[node];\n\t\treturn merge(sub(l, r, node * 2, lb, (lb + ub) / 2), sub(l, r, node * 2 + 1, (lb + ub) / 2, ub));\n\t}\npublic:\n\tSegmentTree(int n_, T id_, func_t merge_) :\n\t\tn(size(n_)), id(id_), merge(merge_), data(size(n_) * 2, id_) {}\n\tvoid Init(const vector<T>& data_) {\n\t\tfor (int i = 0; i < (int)data_.size(); i++)\n\t\t\tdata[i + n] = data_[i];\n\t\tfor (int i = n - 1; i >= 0; i--)\n\t\t\tdata[i] = merge(data[i * 2], data[i * 2 + 1]);\n\t}\n\tvoid Update(int p, T val) {\n\t\tp += n;\n\t\tdata[p] = val;\n\t\twhile (p >>= 1) data[p] = merge(data[p * 2], data[p * 2 + 1]);\n\t}\n\tvoid Add(int p, T val) {\n\t\tp += n;\n\t\tdata[p] += val;\n\t\twhile (p >>= 1) data[p] = merge(data[p * 2], data[p * 2 + 1]);\n\t}\n\tT Find(int i) {\n\t\treturn data[i + n];\n\t}\n\tT Find(int l, int r) {\n\t\treturn sub(l, r + 1, 1, 0, n);\n\t}\n};\n\nsigned main()\n{\n\tcin.sync_with_stdio(false);\n\tcin.tie(0);\n\tint N, M;\n\tcin >> N >> M;\n\tvector<int> w(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> w[i];\n\t}\n\tGraph G(N);\n\tfor (int i = 0, u, v; i < M; i++) {\n\t\tcin >> u >> v; u--; v--;\n\t\tG[u].emplace_back(u, v);\n\t\tG[v].emplace_back(v, u);\n\t}\n\tauto br = bridge(G);\n\tint V = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tV = max(V, br.first[i] + 1);\n\t}\n\tHLDecomposition hl(V);\n\tfor (auto e : br.second) {\n\t\thl.add(br.first[e.from], br.first[e.to]);\n\t}\n\thl.build();\n\tSegmentTree<int> st(V, 0, [](int l, int r) { return l + r; });\n\tfor (int i = 0; i < N; i++) {\n\t\thl.for_each(br.first[i], br.first[i], [&](int l, int r) {\n\t\t\tst.Add(l, w[i]);\n\t\t});\n\t}\n\tint res = 0;\n\tfor (int i = 0; i < V; i++) {\n\t\tint tmp = 0;\n\t\thl.for_each(br.first[0], i, [&](int l, int r) {\n\t\t\ttmp += st.Find(l, r);\n\t\t});\n\t\tres = max(res, tmp);\n\t}\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n,m;\nvector<int>e[100005];\nvector<int>edge[100005];\nint used[100005];\nint w[100005],k;\nvector<int>E[100005];\nll W[100005];\nint in[100005];\nll dp[100005];\nint cnt[100005];\nint par[100005],ran[100005];\nvoid init(){ for(int i=0;i<100005;i++) par[i] = i; }\nint find(int x){ if(x == par[x]) return x; else return par[x] = find(par[x]); }\nvoid unite(int x,int y){\n\tx = find(x); y = find(y); if(x==y) return;\n\tif(ran[x] < ran[y]) par[x] = y;\n\telse{\n\t\tpar[y] = x;\n\t\tif(ran[x] == ran[y]) ran[x]++;\n\t}\n}\nbool same(int x,int y){ return find(x)==find(y); }\nvoid dfs(int v,int u,int d){\n\tused[v] = d;//cout << v << endl;\n\tfor(int i=0;i<e[v].size();i++){\n\t\tif(e[v][i] == u) continue;\n\t\tif(used[e[v][i]] && used[e[v][i]] < used[v]){\n\t\t\tcnt[e[v][i]]--;\n\t\t\tcnt[v]++;\n\t\t\tunite(e[v][i],v);\n\t\t\t//cout << v << \" \" << e[v][i] << endl;\n\t\t\tcontinue;\n\t\t}\n\t\telse if(used[e[v][i]]) continue;\n\t\tdfs(e[v][i],v,d+1); edge[v].pb(e[v][i]); //cout << v << \" \" << e[v][i] << endl;\n\t}\n}\nint dfs2(int v,int u){\n\tint sum = 0;\n\tfor(int i=0;i<edge[v].size();i++){\n\t\tint a = dfs2(edge[v][i],v);\n\t\tif(a){\n\t\t    //cout << edge[v][i] << \" f\" << v << endl;\n\t\t\tunite(edge[v][i],v);\n\t\t}\n\t\tsum += a;\n\t}\n\tsum += cnt[v];\n\treturn sum;\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=0;i<n;i++) scanf(\"%d\",&w[i]);\n\tfor(int i=0;i<m;i++){\n\t\tint a,b; scanf(\"%d%d\",&a,&b); a--; b--;\n\t\te[a].push_back(b);\n\t\te[b].push_back(a);\n\t}\n\tinit(); dfs(0,-1,1); dfs2(0,-1);\n\tfor(int i=0;i<n;i++){\n\t\tW[find(i)] += w[i];\n\t\tfor(int j=0;j<e[i].size();j++){\n\t\t\tif(find(i) != find(e[i][j])){\n\t\t\t\tE[find(i)].pb(find(e[i][j]));\n\t\t\t\tE[find(e[i][j])].pb(find(i));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tSORT(E[i]); ERASE(E[i]);\n\t}\n\tfill(dp,dp+100005,0);\n\tdp[find(0)] = W[find(0)];\n\tqueue<int>que;\n\tque.push(find(0));\n\tmemset(used,0,sizeof(used));\n\tll ret = 0;\n\twhile(!que.empty()){\n\t\tint Q = que.front(); que.pop();\n\t\tif(used[Q]) continue; ret = max(ret,dp[Q]); used[Q] = 1;\n\t\tfor(int i=0;i<E[Q].size();i++){\n\t\t\tif(used[E[Q][i]]) continue;\n\t\t\tdp[E[Q][i]] = max(dp[E[Q][i]],dp[Q]+W[E[Q][i]]);\n\t\t\tque.push(E[Q][i]);\n\t\t}\n\t}\n\tcout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\ntypedef long long ll;\n#define int ll\n\n#define range(i, a, n) for(int (i) = (a); (i) < (n); (i)++)\n#define rep(i, n) for(int (i) = 0; (i) < (n); (i)++)\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\nsigned main(void){\n    int n, m; cin >> n >> m;\n\n    vi w(n);\n    for(auto && e : w) cin >> e;\n\n    vector<set<int>> edge(n);\n    rep(loop, m){\n        int u, v; cin >> u >> v;\n        u--, v--;\n\n        edge[u].insert(v);\n        edge[v].insert(u);\n    }\n\n    vi dp(n, 0);\n    queue<int> q;\n    set<int> uncnt;\n    range(u, 1, n){\n        if(edge[u].size() == 1){\n            q.push(u);\n        }\n    }\n\n    while(q.size()){\n        int v = q.front(); q.pop();\n        uncnt.insert(v);\n\n        int u = *edge[v].begin();\n        edge[u].erase(v);\n\n        dp[u] = max(dp[u], dp[v] + w[v]);\n\n        if(u == 0 || edge[u].size() != 1) continue;\n        q.push(u);\n    }\n\n    int res = *max_element(dp.begin(), dp.end());\n    rep(u, n){\n        if(uncnt.count(u) == 0){\n            res += w[u];\n        }\n    }\n\n    cout << res << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nint main()\n{\n\tint N, M;\n\tcin >> N >> M;\n\tvector<int> w(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> w[i];\n\t}\n\tvector<vector<int>> G(N);\n\tfor (int i = 0, u, v; i < M; i++) {\n\t\tcin >> u >> v;\n\t\tG[u - 1].push_back(v - 1);\n\t\tG[v - 1].push_back(u - 1);\n\t}\n\tpriority_queue<int> q;\n\tll res = w[0];\n\tfor (int i = 1; i < N; i++) {\n\t\tif (G[i].size() > 1) {\n\t\t\tres += w[i];\n\t\t}\n\t\telse {\n\t\t\tq.push(w[i]);\n\t\t}\n\t}\n\tcout << res + q.top() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<double,int,double> tp;\n//typedef vector<tp> vt;\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nconst int inf=1e9;\nconst ll INF=2e18;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nclass SCC{//cmp(0 - kk-1) is scc's return. Same number is group. The number is no relatoin.\n\tpublic:\n\tint n;\n\tvvi G,rG,tG;\n\tvector<bool>used;\n\tvi vs,cmp;\n\tvoid init(int size){\n\t\tn=size;\n\t\tG=rG=vvi(n);\n\t\tused=vector<bool>(n);\n\t\tcmp=vi(n);\n\t\tvs=vi(0);\n\t}\n\tvoid add_edge(int s,int t){\n\t\tG[s].pb(t);\n\t\trG[t].pb(s);\n\t}\n\tvoid rdfs(int v,int k){\n\t\tused[v]=true;\n\t\tcmp[v]=k;\n\t\trep(i,rG[v].size())if(!used[rG[v][i]])rdfs(rG[v][i],k);\n\t}\n\tvoid dfs(int v){\n\t\tused[v]=true;\n\t\trep(i,G[v].size())if(!used[G[v][i]])dfs(G[v][i]);\n\t\tvs.pb(v);\n\t}\n\tint scc(){\n\t\trep(i,n)used[i]=false;\n\t\trep(v,n)if(!used[v])dfs(v);\n\t\trep(i,n)used[i]=false;\n\t\tint kk=0;\n\t\tfor(int i=vs.size()-1;i>=0;i--)if(!used[vs[i]])rdfs(vs[i],kk++);\n\t\treturn kk;  \n\t}\n\tvoid make(int size){\n\t\tint N=size;\n\t\ttG=vvi(N);\n\t\trep(i,n)rep(j,G[i].size())if(cmp[i]!=cmp[G[i][j]]){\n\t\t\ttG[cmp[i]].pb(cmp[G[i][j]]);\n\t\t\ttG[cmp[G[i][j]]].pb(cmp[i]);\n\t\t}\n\t}\n};\nSCC scc;\nint n,m,ma;\nvvi G,tG;\nvi used;\nvoid dfs(int a,int pre){\n\tused[a]=true;\n\trep(i,G[a].size()){\n\t\tint to=G[a][i];\n\t\tif(to!=pre)scc.add_edge(a,to);\n\t\tif(used[to])continue;\n\t\tdfs(to,a);\n\t}\n}\nvi to;\nvoid DFS(int a,int sum,int pre){\n\tused[a]=true;\n\tma=max(ma,sum);\n\trep(i,scc.tG[a].size()){\n\t\tint _to=scc.tG[a][i];\n\t\tif(_to==pre)continue;\n\t\tif(used[_to])continue;\n\t\tDFS(_to,sum+to[_to],a);\n\t}\n}\nint main(){\n\tcin>>n>>m;\n\tvi in(n);\n\trep(i,n)cin>>in[i];\n\tscc.init(n);\n\tused=vi(n);\n\tG=vvi(n);\n\twhile(m--){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\ta--;b--;\n//\t\tmca.add_edge(a,b);\n\t\tG[a].pb(b);\n\t\tG[b].pb(a);\n\t}\n\tdfs(0,-1);\n\tint N=scc.scc();\n//\trep(i,n)cout<<\" \"<<scc.cmp[i];cout<<endl;\n\tscc.make(N);\n\tto=vi(N);\n\trep(i,n)to[scc.cmp[i]]+=in[i];\n//\trep(i,N)cout<<\" \"<<to[i];cout<<endl;\n\tma=0;\n\tused=vi(N);\n\tDFS(0,to[0],-1);\n\tcout<<ma<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nint main()\n{\n\tint N, M;\n\tcin >> N >> M;\n\tvector<int> w(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> w[i];\n\t}\n\tvector<vector<int>> G(N);\n\tfor (int i = 0, u, v; i < M; i++) {\n\t\tcin >> u >> v;\n\t\tG[u - 1].push_back(v - 1);\n\t\tG[v - 1].push_back(u - 1);\n\t}\n\tpriority_queue<int> q;\n\tll res = w[0];\n\tfor (int i = 1; i < N; i++) {\n\t\tif (G[i].size() > 1) {\n\t\t\tres += w[i];\n\t\t}\n\t\telse {\n\t\t\tq.push(w[i]);\n\t\t}\n\t}\n\tcout << res + (q.empty() ? 0 : q.top()) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr int MAX_N = 100000;\nconstexpr int INF = (1 << 29);\n\nint N, M, w[MAX_N], point;\nbool visited[MAX_N], used[MAX_N];\nvector<int> G[MAX_N];\n\nbool dfs(int curr, int prev)\n{\n    if (visited[curr]) return 1;\n    visited[curr] = 1;\n    \n    bool reach = 0;\n    for (int next : G[curr]) {\n        if (next == prev) continue;                \n        reach |= dfs(next, curr);\n    }\n\n    if (reach) {\n        used[curr] = 1;\n        point += w[curr];\n    }\n    return reach;\n}\n\nint main()\n{\n    scanf(\"%d %d\", &N, &M);\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &w[i]);\n    }\n\n    for (int i = 0; i < M; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        u--; v--;\n        G[u].emplace_back(v);\n        G[v].emplace_back(u);\n    }\n    \n    dfs(0, -1);\n    \n    using pii = pair<int, int>;\n    priority_queue<pii> pq;\n    pq.push(pii(0, 0));\n    \n    vector<int> d(N, -1);\n    d[0] = 0;\n    \n    while (!pq.empty()) {\n        pii p = pq.top(); pq.pop();\n        int cost, curr;\n        tie(cost, curr) = p;\n\n        if (cost < d[curr]) continue;\n        for (int next : G[curr]) {\n            if (d[next] != -1) continue;\n            \n            d[next] = cost + (used[next] ? 0 : w[next]);\n            pq.push(pii(d[next], next));\n        }\n    }\n    \n    point += *max_element(d.begin(), d.end());\n    printf(\"%d\\n\", point + (!used[0] ? w[0] : 0));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n\nusing VS = vector<string>;    using LL = long long;\nusing VI = vector<int>;       using VVI = vector<VI>;\nusing PII = pair<int, int>;   using PLL = pair<LL, LL>;\nusing VL = vector<LL>;        using VVL = vector<VL>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n#define FOR(i, s, e) for (int(i) = (s); (i) < (e); (i)++)\n#define FORR(i, s, e) for (int(i) = (s); (i) > (e); (i)--)\n#define debug(x) cerr << #x << \": \" << x << endl\nconst int INF = 1e9;                          const LL LINF = 1e16;\nconst LL MOD = 1000000007;                    const double PI = acos(-1.0);\nint DX[8] = { 0, 0, 1, -1, 1, 1, -1, -1 };    int DY[8] = { 1, -1, 0, 0, 1, -1, 1, -1 };\n\nstruct UnionFind {\n    vector<int> data;\n    UnionFind(int n) { data.assign(n, -1); }\n    bool unionSet(int x, int y) {\n        x = root(x); y = root(y);\n        if (x != y) {\n            if (data[y] < data[x]) swap(x, y);\n            data[x] += data[y]; data[y] = x;\n        }\n        return x != y;\n    }\n    bool same(int x, int y) { return root(x) == root(y); }\n    int root(int x) { return data[x] < 0 ? x : data[x] = root(data[x]); }\n    int size(int x) { return -data[root(x)]; }\n};\n\nstruct TwoEdgeConnectedComponent{\n    UnionFind uf;\n    vector<vector<int>> g;\n    vector<pair<int, int>> edges;\n    vector<int> used, ord, low, comp;\n    \n    TwoEdgeConnectedComponent(int v) : uf(v), g(v), used(v, 0), comp(v), ord(v), low(v) {}\n    \n    void add_edge(int x, int y) {\n        g[x].push_back(y);\n        g[y].push_back(x);\n        edges.push_back(minmax(x, y));\n    }\n    \n    void dfs(int idx, int& k, int par = -1) {\n        used[idx] = true;\n        ord[idx] = k++;\n        low[idx] = ord[idx];\n        \n        for (auto &to : g[idx]) {\n            if (!used[to]) {\n                dfs(to, k, idx);\n                low[idx] = min(low[idx], low[to]);\n                if (ord[idx] >= low[to]) uf.unionSet(idx, to);\n            }\n            else if (to != par) {\n                low[idx] = min(low[idx], ord[to]);\n            }\n        }\n    }\n    \n    // return origin color\n    int operator[](int k) {\n        return (comp[k]);\n    }\n    \n    int size() {\n        return (g.size());\n    }\n    \n    // build, renew resG(empty -> tree), return color\n    vector<int> get_graph(vector<vector<int>>& resG, int root = 0) {\n        int kk = 0;\n        dfs(root, kk);\n        \n        int ptr = 0;\n        vector<int> color(g.size());\n        for (int i = 0; i < g.size(); i++) {\n            if (i == uf.root(i)) color[i] = ptr++;\n        }\n        \n        resG.resize(ptr);\n        for (int i = 0; i < g.size(); i++) {\n            comp[i] = color[uf.root(i)];\n        }\n//        for (auto &e : edges) {\n//            int x = comp[e.first], y = comp[e.second];\n//            if (x == y) continue;\n//            resG[x].push_back(y);\n//            resG[y].push_back(x);\n//        }\n         //TLE\n                for (int v = 0; v < (int)g.size(); v++) {\n                    for (int i = 0; i < (int)g[v].size(); i++) {\n                        int u = g[v][i];\n                        int c1 = comp[v], c2 = comp[u];\n                        if (c1 == c2)continue;\n                        resG[c1].push_back(c2);\n                        resG[c2].push_back(c1);\n                    }\n                }\n        return comp;\n    }\n};\n\nint N, M, W[100000];\nvector<vector<int>> resG;\nvector<int> weightSum, sz;\nint dp1[100000], dp3[100000];\n\nint rec(int idx, int par = -1)\n{\n    int ret = 0;\n    for (auto &to : resG[idx]) {\n        if (to == par) continue;\n        ret = max(ret, rec(to, idx));\n        dp1[idx] += dp1[to];\n    }\n    ret += weightSum[idx];\n    if (sz[idx] >= 3 || dp1[idx] > 0) dp1[idx] += weightSum[idx];\n    for (auto &to : resG[idx]) {\n        if (to == par) continue;\n        else ret = max(ret, dp1[idx] - dp1[to] + dp3[to]);\n    }\n    return (dp3[idx] = ret);\n}\n\n// 三点以上集まった頂点ならば、ここを起点にもどることができる。\n// dp1[v]:vから葉まで進むときの最大値\n// dp3[v]:vに戻ってくるときの最大値\nvoid f(int v, int p = -1) {\n    for (int nx : resG[v]) {\n        if (nx == p)continue;\n        f(nx, v);\n        dp1[v] += dp1[nx];\n    }\n    int ret = dp1[v];\n    if (dp1[v] || sz[v] > 1)dp1[v] += weightSum[v];\n    for (int nx : resG[v]) {\n        if (nx == p)continue;\n        dp3[v] = max(dp3[v], ret - dp1[nx] + dp3[nx]);\n    }\n    dp3[v] += weightSum[v];\n}\n\nint main() {\n    int N, M; cin >> N >> M;\n    FOR(i, 0, N) {\n        cin >> W[i];\n    }\n    TwoEdgeConnectedComponent gx(N);\n    \n    FOR(i, 0, M) {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        gx.add_edge(a, b);\n    }\n    VI vc = gx.get_graph(resG);\n    \n    weightSum.assign(resG.size(), 0);\n    sz.assign(resG.size(), 0);\n    for (int i = 0; i < N; i++) {\n        weightSum[vc[i]] += W[i];\n        sz[vc[i]]++;\n    }\n    f(vc[0]);\n    LL ans = dp3[vc[0]];\n    cout << ans << endl;\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_V 100000\nusing namespace std;\nint m,w[100001];\nvector<int> vv[100001];\nunordered_set<int> st[100001];\nint V;\nvector<int> G[MAX_V];\nvector<int> rG[MAX_V];\nvector<int> vs;\nbool used[MAX_V];\nint cmp[MAX_V];\nint C[100001],F[100001],U[100001],ans;\nbool UU[100001];\n\n\nvoid DFS(int p){\n  for(int i=0;i<vv[p].size();i++){\n    int mn=min(vv[p][i],p),mx=max(vv[p][i],p);\n    if(st[mn].find(mx)==st[mn].end()){\n      st[mn].insert(mx);\n      G[p].push_back(vv[p][i]);\n      rG[vv[p][i]].push_back(p);\n      DFS(vv[p][i]);\n    }\n  }\n}\n\nvoid dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++)if(!used[G[v][i]])dfs(G[v][i]);\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v]=true;\n  cmp[v]=k;\n  for(int i=0;i<rG[v].size();i++)if(!used[rG[v][i]])rdfs(rG[v][i],k);\n}\n\nint scc(){\n  memset(used,0,sizeof(used));\n  vs.clear();\n  for(int v=0;v<V;v++)if(!used[v])dfs(v);\n  memset(used,0,sizeof(used));\n  int k=0;\n  for(int i=vs.size()-1;i>=0;i--)if(!used[vs[i]])rdfs(vs[i],k++);\n  return k;\n}\n\nbool DFS1(int p){\n  if(U[p])return 0;\n  U[p]=1;\n  bool f=F[cmp[p]]>=2;\n  for(int i=0;i<G[p].size();i++)\n    f|=DFS1(G[p][i]);\n  ans+=w[p]*f;\n  return UU[p]=f;\n}\nbool UUU[100001];\nint DFS2(int p){\n  if(UUU[p])return 0;\n  UUU[p]=1;\n  int res=0;\n  \n  for(int i=0;i<G[p].size();i++)\n    res=max(res,DFS2(G[p][i]));  \n  return UU[p]?0:res+w[p];\n}\n\nint main(){\n  cin>>V>>m;\n  for(int i=0;i<V;i++)cin>>w[i];\n  for(int j=0,a,b;j<m;j++){\n    cin>>a>>b;a--,b--;\n    vv[a].push_back(b),vv[b].push_back(a);\n  }\n  DFS(0);\n  int t=0;\n  for(int i=0;i<V;i++)t+=w[i];\n  scc();\n  for(int i=0;i<V;i++)F[cmp[i]]++;\n  DFS1(0);\n  cout<<ans+DFS2(0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define F first\n#define S second\n#define all(v) (v).begin(), (v).end()\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, f, n) for(int i = (int)(f); i < (int)(n); i++)\n#define each(a, b) for(auto& a : b)\n\ntypedef pair<int, int> Pi;\n\nconst int inf = 1LL << 55;\n\nstruct UnionFind\n{\n  vector<int> data;\n  UnionFind(int sz):data(sz, -1){};\n  int size(int x) { return -data[find(x)]; }  \n  int find(int x) { return data[x] < 0 ? x : data[x] = find(data[x]); }\n  bool same(int x, int y) { return find(x) == find(y); }  \n  int unite(int x, int y)\n  {\n    x = find(x), y = find(y);\n    if(x != y) {\n      if(data[x] < data[y]) swap(x, y);\n      data[x] += data[y]; data[y] = x;\n    }\n    return -data[x];\n  }\n};\n\n\n// Biconnected Components (lowlink)\nstruct BICC\n{\n  UnionFind uf;\n  vector< vector<int> > graph, tree;\n  vector<Pi> edges;\n  vector<bool> vis;\n  vector<int> ord, low, cmp;\n  vector<int> articulation;\n  vector<Pi> bridge;\n  BICC(int sz):uf(sz), graph(sz), vis(sz, false), ord(sz), low(sz), cmp(sz){}\n  void add_edge(int u, int v)\n  {\n    graph[u].emplace_back(v);\n    graph[v].emplace_back(u);\n    edges.emplace_back(minmax(u, v));\n  }\n  void dfs(int u, int p, int& k)\n  {\n    vis[u] = true;\n    \n    ord[u] = low[u] = k++;\n\n    bool is_articulation = false;\n    int cnt = 0;\n    \n    for(auto v : graph[u]) {\n      if(!vis[v]) {\n\tcnt++;\n\tdfs(v, u, k);\n\tlow[u] = min(low[u], low[v]);\n\tif(~p && ord[u] <= low[v]) is_articulation = true;\n\tif(ord[u] < low[v]) bridge.emplace_back(minmax(u, v));\n\telse uf.unite(u, v);\n      } else if(v != p) {\n\tlow[u] = min(low[u], ord[v]);\n      }\n    }\n    \n    if(p == -1 && cnt > 1) is_articulation = true;\n    if(is_articulation) articulation.push_back(u);\n  }\n  void compose()\n  {\n    int k = 0;\n    dfs(0, -1, k);\n\n    int num = 0;\n    vector<int> conn(graph.size());\n    for(int i = 0; i < graph.size(); i++) {\n      if(i == uf.find(i)) conn[i] = num++;\n    }\n\n    tree.resize(num);\n    for(int i = 0; i < graph.size(); i++) {\n      cmp[i] = conn[uf.find(i)];\n    }\n    for(auto e : edges) {\n      int x = cmp[e.first], y = cmp[e.second];\n      if(x == y) continue;\n      tree[x].emplace_back(y);\n      tree[y].emplace_back(x);\n    }\n  }\n};\n\nsigned main()\n{\n  int N, M;\n  cin >> N >> M;\n  vector<int> w(N);\n  rep(i, N) cin >> w[i];\n  BICC bicc(N);\n  while(M--) {\n    int a, b; cin >> a >> b; a--, b--;\n    bicc.add_edge(a, b);\n  }\n  bicc.compose();\n  vector<int> sum(bicc.tree.size(), 0);\n  rep(i, N) sum[bicc.cmp[i]] += w[i];\n  queue<int> que; que.push(bicc.cmp[0]);\n  vector<int> d(bicc.tree.size(), -1); d[bicc.cmp[0]] = sum[bicc.cmp[0]];\n  int ans = 0;\n  while(!que.empty()) {\n    int now = que.front(); que.pop();\n    ans = max(ans, d[now]);\n    rep(i, bicc.tree[now].size()) {\n      int to = bicc.tree[now][i];\n      if(d[to] == -1) {\n\tque.push(to);\n\td[to] = d[now] + sum[to];\n      }\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> P;\nconstexpr int IINF = INT_MAX;\n\nvector<vector<int> > g, h;\nvector<P> es;\nvector<int> w, ww, deg, id;\nvector<bool> in_cycle;\n\nvoid dfs(int v){\n    in_cycle[v] = false;\n    for(auto u : g[v]){\n        if(!in_cycle[u]) continue;\n        deg[v]--;\n        deg[u]--;\n        if(deg[u]==1){\n            dfs(u);\n        }\n    }\n}\n\nint rec(int v, int p){\n    int res = 0;\n    for(auto u : h[v]){\n        if(u==p) continue;\n        res = max(res, rec(u, v));\n    }\n    return res + ww[v];\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    g.resize(n);\n    w.resize(n);\n    deg.resize(n, 0);\n    id.resize(n);\n    in_cycle.resize(n, true);\n    for(int i=0;i<n;i++){\n        cin >> w[i];\n    }\n    for(int i=0;i<m;i++){\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        g[u].push_back(v);\n        g[v].push_back(u);\n        deg[u]++;\n        deg[v]++;\n        es.push_back(P(u,v));\n    }\n    // 根は葉の頂点としない\n    // 0 -> cycle -> 0 は必ず移動できる\n    deg[0] = IINF;\n    // 次数1の頂点から削る\n    for(int i=1;i<n;i++){\n        if(deg[i]==1){\n            dfs(i);\n        }\n    }\n    // 自由に行き来できる頂点を縮約したグラフを構築\n    int num = 1;\n    ww.push_back(0);\n    for(int i=0;i<n;i++){\n        if(in_cycle[i]){\n            id[i] = 0;\n            ww[0] += w[i];\n        }\n        else{\n            id[i] = num++;\n            ww.push_back(w[i]);\n        }\n    }\n    h.resize(num);\n    for(auto &e : es){\n        int u = e.first, v = e.second;\n        if(id[u]==id[v]) continue;\n        h[id[u]].push_back(id[v]);\n        h[id[v]].push_back(id[u]);\n    }\n    for(int i=0;i<num;i++){\n        sort(h[i].begin(), h[i].end());\n        h[i].erase(unique(h[i].begin(),h[i].end()),h[i].end());\n    }\n    // 構築したグラフは木になるので再帰で解ける\n    cout << rec(id[0], -1) << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define REP(i, n) for (int i = 0; i < n; i++)\n\nsigned main() {\n    int n, m; cin >> n >> m;\n    vector<int> w(n); REP (i, n) cin >> w[i];\n    vector<vector<int>> g(n);\n    REP (i, m) {\n        int u, v; cin >> u >> v;\n        u--, v--;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    vector<int> deg(n);\n    queue<int> q;\n    REP (i, n) {\n        deg[i] = g[i].size();\n        if (deg[i] == 1) q.push(i);\n    }\n    vector<bool> core(n, true);\n    while (!q.empty()) {\n        int v = q.front(); q.pop();\n        core[v] = false;\n        for (int s : g[v]) {\n            if (!core[s]) continue;\n            deg[s]--;\n            if (deg[s] == 1) q.push(s);\n        }\n    }\n\n    function<bool(int, int)> dfs1 = [&](int v, int prev) {\n        if (core[v]) return true;\n        for (int s : g[v]) if (s != prev) {\n            if (dfs1(s, v)) {\n                core[v] = true;\n                return true;\n            }\n        }\n        return false;\n    };\n    dfs1(0, -1);\n    core[0] = true;\n\n    int core_sum = 0;\n    REP (i, n) {\n        if (core[i]) core_sum += w[i];\n    }\n\n    vector<int> from_core;\n    REP (i, n) {\n        if (core[i]) {\n            for (int s : g[i]) from_core.push_back(s);\n        }\n    }\n    function<int(int, int)> dfs2 = [&](int v, int prev) {\n        int ma = 0;\n        for (int s : (v == 0 ? from_core : g[v])) if (s != prev && !core[s]) {\n            ma = max(ma, dfs2(s, v));\n        }\n        return ma + w[v];\n    };\n    cout << core_sum + dfs2(0, -1) - w[0] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\nvoid dfs(vector<vector<int>>& g, vector<int>& in, vector<bool>& used, int pos, vector<bool>& p){\n\tused[pos] = true;\n\tfor(auto to : g[pos]){\n\t\tif(used[to]) continue;\n\t\tdfs(g, in, used, to, p);\n\t}\n\tif(in[pos] == 1){\n\t\tfor(auto i : g[pos]){\n\t\t\tin[i]--;\n\t\t}\n\t\tp[pos] = true;\n\t}\n}\n\nint bfs(vector<vector<int>>& g, vector<bool>& used, vector<int>& w){\n\tint n = g.size();\n\n\tqueue<int> q;\n\trep(i,n){\n\t\tif(not used[i]) q.emplace(i);\n\t}\n\n\tvector<int> dis(n,0);\n\twhile(not q.empty()){\n\t\tint pos = q.front(); q.pop();\n\t\tfor(auto to : g[pos]){\n\t\t\tif(not used[to]) continue;\n\t\t\tused[to] = false;\n\t\t\tdis[to] = dis[pos] + w[to];\n\t\t\tq.emplace(to);\n\t\t}\n\t}\n\n\treturn *max_element(all(dis));\n}\n\nint main(){\n\tint n, m;\n\tcin >> n >> m;\n\n\tvector<int> w(n);\n\tcin >> w;\n\n\tvector<vector<int>> g(n);\n\trep(i,m){\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--; b--;\n\t\tg[a].emplace_back(b);\n\t\tg[b].emplace_back(a);\n\t}\n\n\tvector<int> in(n);\n\trep(i,n) in[i] = g[i].size();\n\n\tvector<bool> p(n,0);\n\tvector<bool> used(n,0);\n\tdfs(g, in, used, 0, p);\n\n\tint res = 0;\n\trep(i,n){\n\t\tif(not p[i]) res += w[i];\n\t}\n\n\tcout << bfs(g, p, w) + res << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n\nusing VS = vector<string>;    using LL = long long;\nusing VI = vector<int>;       using VVI = vector<VI>;\nusing PII = pair<int, int>;   using PLL = pair<LL, LL>;\nusing VL = vector<LL>;        using VVL = vector<VL>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n#define FOR(i, s, e) for (int(i) = (s); (i) < (e); (i)++)\n#define FORR(i, s, e) for (int(i) = (s); (i) > (e); (i)--)\n#define debug(x) cerr << #x << \": \" << x << endl\nconst int INF = 1e9;                          const LL LINF = 1e16;\nconst LL MOD = 1000000007;                    const double PI = acos(-1.0);\nint DX[8] = { 0, 0, 1, -1, 1, 1, -1, -1 };    int DY[8] = { 1, -1, 0, 0, 1, -1, 1, -1 };\n\n/*-----------------------------------------------\n 二辺連結成分分解 成分だけ unverified\n -----------------------------------------------*/\nstruct UnionFind {\n    vector<int> data;\n    UnionFind(int n) { data.assign(n, -1); }\n    bool unionSet(int x, int y) {\n        x = root(x); y = root(y);\n        if (x != y) {\n            if (data[y] < data[x]) swap(x, y);\n            data[x] += data[y]; data[y] = x;\n        }\n        return x != y;\n    }\n    bool same(int x, int y) { return root(x) == root(y); }\n    int root(int x) { return data[x] < 0 ? x : data[x] = root(data[x]); }\n    int size(int x) { return -data[root(x)]; }\n};\n\nstruct Lowlink {\n    UnionFind uf;\n    vector<int> low, ord, used, parent;\n    int root, k;\n    Lowlink(int V, int Root) :uf(V), low(V), ord(V), used(V), parent(V), root(Root), k(0) {}\n    \n    void lowlink(int v, int p, int &k, vector<vector<int>>& G) {\n        used[v] = true; //visited\n        low[v] = ord[v] = k; k++;\n        for (int i = 0; i < (int)G[v].size(); i++) {\n            int u = G[v][i];\n            if (used[u] == 0) {\n                parent[u] = v;\n                lowlink(u, v, k, G);\n                low[v] = min(low[v], low[u]);\n                if (ord[v] >= low[u])uf.unionSet(v, u);\n            }\n            else if (u != p) {\n                low[v] = min(low[v], ord[u]);\n            }\n        }\n    }\n};\n\nstruct TwoEdgeConnectedComponent:Lowlink{\n //   UnionFind uf;\n    vector<vector<int>> g;\n    vector<pair<int, int>> edges;\n//    vector<int> used, ord, low\n    vector<int> comp;\n    int v;\n    TwoEdgeConnectedComponent(int v) : g(v),comp(v),v(v),Lowlink(v,0) {}\n    \n    void add_edge(int x, int y) {\n        g[x].push_back(y);\n        g[y].push_back(x);\n        edges.push_back(minmax(x, y));\n    }\n    \n    void dfs(int idx, int& k, int par = -1) {\n        used[idx] = true;\n        ord[idx] = k++;\n        low[idx] = ord[idx];\n        \n        for (auto &to : g[idx]) {\n            if (!used[to]) {\n                dfs(to, k, idx);\n                low[idx] = min(low[idx], low[to]);\n                if (ord[idx] >= low[to]) uf.unionSet(idx, to);\n            }\n            else if (to != par) {\n                low[idx] = min(low[idx], ord[to]);\n            }\n        }\n    }\n    \n    // return origin color\n    int operator[](int k) {\n        return (comp[k]);\n    }\n    \n    int size() {\n        return (g.size());\n    }\n    \n    // build, renew resG(empty -> tree), return color\n    vector<int> get_graph(vector<vector<int>>& resG, int root = 0) {\n        int kk = 0;\n        Lowlink::lowlink(root, -1, kk, g);\n//        dfs(root, kk);\n//        Lowlink Low(v,0);\n//        Low.lowlink(root, -1, kk, g);\n//        auto uf = Low.uf;\n        int ptr = 0;\n        vector<int> color(g.size());\n        for (int i = 0; i < g.size(); i++) {\n            if (i == uf.root(i)) color[i] = ptr++;\n        }\n        \n        resG.resize(ptr);\n        for (int i = 0; i < g.size(); i++) {\n            comp[i] = color[uf.root(i)];\n        }\n        for (auto &e : edges) {\n            int x = comp[e.first], y = comp[e.second];\n            if (x == y) continue;\n            resG[x].push_back(y);\n            resG[y].push_back(x);\n        }\n        return comp;\n    }\n};\n\nint N, M, W[100000];\nvector<vector<int>> resG;\nvector<int> weightSum, sz;\nint dp1[100000], dp3[100000];\n\nint rec(int idx, int par = -1)\n{\n    int ret = 0;\n    for (auto &to : resG[idx]) {\n        if (to == par) continue;\n        ret = max(ret, rec(to, idx));\n        dp1[idx] += dp1[to];\n    }\n    ret += weightSum[idx];\n    if (sz[idx] >= 3 || dp1[idx] > 0) dp1[idx] += weightSum[idx];\n    for (auto &to : resG[idx]) {\n        if (to == par) continue;\n        else ret = max(ret, dp1[idx] - dp1[to] + dp3[to]);\n    }\n    return (dp3[idx] = ret);\n}\n\n// 三点以上集まった頂点ならば、ここを起点にもどることができる。\n// dp1[v]:vから葉まで進むときの最大値\n// dp3[v]:vに戻ってくるときの最大値\nvoid f(int v, int p = -1) {\n    for (int nx : resG[v]) {\n        if (nx == p)continue;\n        f(nx, v);\n        dp1[v] += dp1[nx];\n    }\n    int ret = dp1[v];\n    if (dp1[v] || sz[v] > 1)dp1[v] += weightSum[v];\n    for (int nx : resG[v]) {\n        if (nx == p)continue;\n        dp3[v] = max(dp3[v], ret - dp1[nx] + dp3[nx]);\n    }\n    dp3[v] += weightSum[v];\n}\n\nint main() {\n    int N, M; cin >> N >> M;\n    FOR(i, 0, N) {\n        cin >> W[i];\n    }\n    TwoEdgeConnectedComponent gx(N);\n    \n    FOR(i, 0, M) {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        gx.add_edge(a, b);\n    }\n    VI vc = gx.get_graph(resG);\n    \n    weightSum.assign(resG.size(), 0);\n    sz.assign(resG.size(), 0);\n    for (int i = 0; i < N; i++) {\n        weightSum[vc[i]] += W[i];\n        sz[vc[i]]++;\n    }\n    f(vc[0]);\n    LL ans = dp3[vc[0]];\n    cout << ans << endl;\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n#define MAX 100005\n \nint p[MAX];\nint q[MAX];\n \nint find(int x){\n  if(p[x]==x)return x;\n  return p[x]=find(p[x]);\n}\n \nvoid unite(int x,int y){\n  x=find(x);y=find(y);\n  if(x==y)return;\n  p[x]=y;\n  q[y]+=q[x];\n}\n \nbool same(int x,int y){\n  return (find(x)==find(y));\n}\n \nint V,E;\nvector<int> G[MAX];\nvector<int> nG[MAX];\nmap<int,bool> used[MAX];\n \nint s[MAX],t[MAX];\nint depth[MAX];\nint cnt[MAX];\nint visited[MAX];\nbool flg[MAX];\n \n \nvoid dfs(int pos,int prev){\n  visited[pos]=true;\n  for(int i=0;i<(int)G[pos].size();i++){\n    int to=G[pos][i];\n    if(to==prev)continue;\n    if(!visited[to]){\n      depth[to]=depth[pos]+1;\n      dfs(to,pos);\n      cnt[pos]+=cnt[to];\n      if(cnt[to])unite(pos,to);\n    }else if(depth[to]<depth[pos]){\n      unite(pos,to);\n      cnt[pos]++;\n      cnt[to]--;\n    }else{\n      unite(pos,to);\n    }\n  }\n}\n \nP solve(int pos,int prev=-1){\n  int res=-1,res2=0,sum=t[pos];\n  for(int i=0;i<(int)nG[pos].size();i++){\n    int to=nG[pos][i];\n    if(to==prev || to==pos)continue;\n    P pw=solve(to,pos);\n    res=max(res,pw.first);\n    if(pw.first!=-1){\n      sum+=pw.first;\n      res2=max(res2, -pw.first+pw.second);\n    }else{\n      res2=max(res2,pw.second);\n    }\n  }\n  if(q[pos]==1 && res==-1){\n    return P(-1,sum+res2);\n  }\n  return P(sum,sum+res2);\n}\n \nint main(){\n  scanf(\"%d %d\",&V,&E);\n  for(int i=0;i<V;i++){\n    scanf(\"%d\",&s[i]);\n    p[i]=i;\n    q[i]=1;\n  }\n  for(int i=0;i<E;i++){\n    int a,b;\n    scanf(\"%d %d\",&a,&b);\n    a--,b--;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n  dfs(0,-1);\n  for(int pos=0;pos<V;pos++){\n    for(int i=0;i<(int)G[pos].size();i++){\n      int to=find(G[pos][i]);\n      if(used[pos].count(to)>0)continue;\n      used[pos][to]=true;\n      nG[ find(pos) ].push_back( to );\n    }\n    t[ find(pos) ]+=s[pos];\n  }\n  P ans=solve(find(0),-1);\n  printf(\"%d\\n\", ans.second);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_V 100000\nusing namespace std;\nint V,m,w[100001],S[100001];\nvector<int> vv[100001];\nvector<int> G[MAX_V];\nvector<int> rG[MAX_V];\nvector<int> vs;\nbool used[MAX_V];\nint cmp[MAX_V];\nint C[100001],F[100001],U[100001],ans,UU[100001],UUU[100001];\n\nvoid DFS(int p,int pr){\n  if(S[p]++)return;\n  for(int i=0;i<vv[p].size();i++){\n    int np=vv[p][i];\n    if(pr!=np){\n      G[p].push_back(np);\n      rG[np].push_back(p);\n      DFS(np,p);\n    }\n  }\n}\n\nvoid dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++)if(!used[G[v][i]])dfs(G[v][i]);\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v]=true;\n  cmp[v]=k;\n  for(int i=0;i<rG[v].size();i++)if(!used[rG[v][i]])rdfs(rG[v][i],k);\n}\n\nint scc(){\n  for(int v=0;v<V;v++)if(!used[v])dfs(v);\n  memset(used,0,sizeof(used));\n  int k=0;\n  for(int i=vs.size()-1;i>=0;i--)if(!used[vs[i]])rdfs(vs[i],k++);\n  return k;\n}\n\nbool DFS1(int p){\n  if(U[p]++)return 0;\n  bool f=F[cmp[p]]>=2;\n  for(int i=0;i<G[p].size();i++)\n    f|=DFS1(G[p][i]);\n  ans+=w[p]*f;\n  return UU[p]=f;\n}\n\nint DFS2(int p){\n  if(UUU[p]++)return 0;\n  int res=0;\n  for(int i=0;i<G[p].size();i++)\n    res=max(res,DFS2(G[p][i]));  \n  return res+(UU[p]?0:w[p]);\n}\n\nint main(){\n  cin>>V>>m;\n  for(int i=0;i<V;i++)cin>>w[i];\n  for(int j=0,a,b;j<m;j++){\n    cin>>a>>b;a--,b--;\n    vv[a].push_back(b),vv[b].push_back(a);\n  }\n  DFS(0,-1);\n  int t=0;\n  for(int i=0;i<V;i++)t+=w[i];\n  scc();\n  for(int i=0;i<V;i++)F[cmp[i]]++;\n  DFS1(0);\n  cout<<ans+DFS2(0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-11;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nint n,m;\nvi a,d;\nvvi g;\n\nint dfs(int v,int p){\n\tint mx=0;\n\tfor(auto u:g[v]) if(u!=p) mx=max(mx,dfs(u,v));\n\treturn mx+a[v];\n}\n\nbool DFS(int v,int p,vi& b){\n\tif(v==0){\n\t\tb[v]=1;\n\t\treturn 1;\n\t}\n\tfor(auto u:g[v]) if(u!=p){\n\t\tif(DFS(u,v,b)){\n\t\t\tb[v]=1;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint main(){\n\tcin>>n>>m;\n\ta=d=vi(n);\n\tg=vvi(n);\n\tfor(int i=0;i<n;i++) cin>>a[i];\n\tfor(int i=0;i<m;i++){\n\t\tint u,v;\n\t\tcin>>u>>v;\n\t\tu--;v--;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t\td[u]++;d[v]++;\n\t}\n\tvi b(n,1);\n\tqueue<int> q;\n\tfor(int i=0;i<n;i++) if(d[i]==1){\n\t\tq.push(i);\n\t\tb[i]=0;\n\t}\n\twhile(!q.empty()){\n\t\tint v=q.front();\n\t\tq.pop();\n\t\tfor(auto u:g[v]) if(b[u]){\n\t\t\td[u]--;\n\t\t\tif(d[u]==1){\n\t\t\t\tq.push(u);\n\t\t\t\tb[u]=0;\n\t\t\t}\n\t\t}\n\t}\n\tint sum=0,cnt=0;\n\tfor(int i=0;i<n;i++) if(b[i]) sum+=a[i],cnt++;\n\tif(sum){\n\t\tint N=n-cnt+1;\n\t\tvvi G(N);\n\t\tvi c(n),A(N);\n\t\tint id=1;\n\t\tfor(int i=0;i<n;i++) if(!b[i]){\n\t\t\tc[i]=id;\n\t\t\tA[id]=a[i];\n\t\t\tid++;\n\t\t}\n\t\tA[0]=sum;\n\t\tfor(int u=0;u<n;u++) for(auto v:g[u]) if(c[u]!=c[v]) G[c[u]].push_back(c[v]);\n\t\tn=N;\n\t\tg=G;\n\t\ta=A;\n\t\tif(c[0]==0) cout<<dfs(0,-1)<<endl;\n\t\telse{\n\t\t\tint res=dfs(c[0],-1);\n\t\t\tb=vi(N);\n\t\t\tDFS(c[0],-1,b);\n\t\t\tsum=0,cnt=0;\n\t\t\tfor(int i=0;i<n;i++) if(b[i]) sum+=a[i],cnt++;\n\t\t\tN=n-cnt+1;\n\t\t\tG=vvi(N);\n\t\t\tc=vi(n),A=vi(N);\n\t\t\tid=1;\n\t\t\tfor(int i=0;i<n;i++) if(!b[i]){\n\t\t\t\tc[i]=id;\n\t\t\t\tA[id]=a[i];\n\t\t\t\tid++;\n\t\t\t}\n\t\t\tA[0]=sum;\n\t\t\tfor(int u=0;u<n;u++) for(auto v:g[u]) if(c[u]!=c[v]) G[c[u]].push_back(c[v]);\n\t\t\tn=N;\n\t\t\tg=G;\n\t\t\ta=A;\n\t\t\tcout<<max(res,dfs(0,-1))<<endl;\n\t\t}\n\t}\n\telse cout<<dfs(0,-1)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define REP(i, n) for (int i = 0; i < (n); i++)\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n, m;\n    cin >> n >> m;\n    vector<int> ws(n);\n    for (int i = 0; i < n; i++) cin >> ws[i];\n    vector<vector<int>> adj(n);\n    for (int i = 0; i < m; i++) {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n    }\n\n    vector<bool> hasi(n);\n    vector<int> deg(n);\n    queue<int> que;\n    for (int i = 0; i < n; i++) {\n        deg[i] = adj[i].size();\n        if (adj[i].size() == 1) {\n            hasi[i] = true;\n            que.push(i);\n        }\n    }\n\n    if (que.empty()) {\n        cout << accumulate(ws.begin(), ws.end(), 0) << endl;\n        return 0;\n    }\n\n    while (!que.empty()) {\n        int v = que.front();\n        que.pop();\n        for (int a : adj[v]) {\n            if (hasi[a]) continue;\n            deg[a]--;\n            if (deg[a] == 1) {\n                hasi[a] = true;\n                que.push(a);\n            }\n        }\n    }\n\n    vector<int> girigiri;\n    for (int i = 0; i < n; i++) {\n        if (!hasi[i]) continue;\n        bool ok = false;\n        for (int a : adj[i]) {\n            if (!hasi[a]) ok = true;\n        }\n        if (ok) {\n            girigiri.push_back(i);\n        }\n    }\n\n    if (girigiri.empty()) {\n        // tree\n        int ans = 0;\n        function<void(int, int, int)> dfs = [&](int v, int p, int acc) {\n            ans = max(ans, acc);\n            for (int s : adj[v]) {\n                if (s != p) {\n                    dfs(s, v, acc + ws[s]);\n                }\n            }\n        };\n        dfs(0, -1, ws[0]);\n        cout << ans << endl;\n        return 0;\n    }\n\n    int ans = 0;\n    for (int i = 0; i < n; i++) {\n        if (!hasi[i]) {\n            ans += ws[i];\n        }\n    }\n\n    int N = girigiri.size();\n    vector<int> score(N);\n    auto get_max = [&](int u) {\n        int nax = 0;\n        function<void(int, int, int)> dfs = [&](int v, int p, int acc) {\n            nax = max(nax, acc);\n            for (int s : adj[v]) {\n                if (s != p && hasi[s]) {\n                    dfs(s, v, acc + ws[s]);\n                }\n            }\n        };\n        dfs(u, -1, ws[u]);\n        return nax;\n    };\n    for (int i = 0; i < N; i++) {\n        score[i] = get_max(girigiri[i]);\n    }\n\n    if (hasi[0]) {\n        bool nyan = false;\n        for (int i = 0; i < N; i++) {\n            if (girigiri[i] == 0) {\n                ans += ws[0];\n                score[i] -= ws[0];\n                nyan = true;\n                break;\n            }\n        }\n        if (nyan) {\n            ans += *max_element(score.begin(), score.end());\n            cout << ans << endl;\n            return 0;\n        }\n        int giri = -1;\n        int iki = 0;\n        function<void(int, int, int)> dfs = [&](int v, int p, int acc) {\n            bool hoge = false;\n            for (int s : adj[v]) {\n                if (s != p) {\n                    if (!hasi[s]) {\n                        giri = v;\n                        iki = acc;\n                        return;\n                    }\n                    hoge = true;\n                    dfs(s, v, acc + ws[s]);\n                }\n            }\n        };\n        dfs(0, -1, ws[0]);\n        ans += iki;\n        assert(giri != -1);\n        vector<bool> used(n);\n        function<void(int, int)> kek = [&](int v, int p) {\n            if (v == 0) {\n                used[v] = true;\n                return;\n            }\n            for (int s : adj[v]) {\n                if (s != p && hasi[s]) {\n                    kek(s, v);\n                    if (used[s]) {\n                        used[v] = true;\n                        return;\n                    }\n                }\n            }\n        };\n        kek(giri, -1);\n        assert(used[0]);\n        int nax = 0;\n        function<void(int, int, int)> genkai = [&](int v, int p, int acc) {\n            nax = max(nax, acc);\n            for (int s : adj[v]) {\n                if (s != p && hasi[s]) {\n                    int po = acc;\n                    if (!used[s]) {\n                        po += ws[s];\n                    }\n                    genkai(s, v, po);\n                }\n            }\n        };\n        genkai(giri, -1, 0);\n        for (int i = 0; i < N; i++) {\n            if (girigiri[i] == giri) {\n                score[i] = nax;\n                break;\n            }\n        }\n        ans += *max_element(score.begin(), score.end());\n        cout << ans << endl;\n    } else {\n        ans += *max_element(score.begin(), score.end());\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nusing VS = vector<string>;    using LL = long long;\nusing VI = vector<int>;       using VVI = vector<VI>;\nusing PII = pair<int, int>;   using PLL = pair<LL, LL>;\nusing VL = vector<LL>;        using VVL = vector<VL>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n#define FOR(i, s, e) for (int(i) = (s); (i) < (e); (i)++)\n#define FORR(i, s, e) for (int(i) = (s); (i) > (e); (i)--)\n#define debug(x) cerr << #x << \": \" << x << endl\nconst int INF = 1e9;                          const LL LINF = 1e16;\nconst LL MOD = 1000000007;                    const double PI = acos(-1.0);\nint DX[8] = { 0, 0, 1, -1, 1, 1, -1, -1 };    int DY[8] = { 1, -1, 0, 0, 1, -1, 1, -1 };\n\n/* -----  2018/05/26  Problem: AOJ 2712 / Link: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2712  ----- */\n/* ------問題------\n \n \n \n -----問題ここまで----- */\n/* -----解説等-----\n \n \n \n ----解説ここまで---- */\n/*-----------------------------------------------\n 二辺連結成分分解 成分だけ unverified\n -----------------------------------------------*/\nstruct UnionFind {\n    vector<int> data;\n    UnionFind(int n) { data.assign(n, -1); }\n    bool unionSet(int x, int y) {\n        x = root(x); y = root(y);\n        if (x != y) {\n            if (data[y] < data[x]) swap(x, y);\n            data[x] += data[y]; data[y] = x;\n        }\n        return x != y;\n    }\n    bool same(int x, int y) { return root(x) == root(y); }\n    int root(int x) { return data[x] < 0 ? x : data[x] = root(data[x]); }\n    int size(int x) { return -data[root(x)]; }\n};\n\nstruct TwoEdgeConnectedComponent{\n    UnionFind uf;\n    vector<vector<int>> g;\n    vector<pair<int, int>> edges;\n    vector<int> used, ord, low, comp;\n    \n    TwoEdgeConnectedComponent(int v) : uf(v), g(v), used(v, 0), comp(v), ord(v), low(v) {}\n    \n    void add_edge(int x, int y) {\n        g[x].push_back(y);\n        g[y].push_back(x);\n        edges.push_back(minmax(x, y));\n    }\n    \n    void dfs(int idx, int& k, int par = -1) {\n        used[idx] = true;\n        ord[idx] = k++;\n        low[idx] = ord[idx];\n        \n        for (auto &to : g[idx]) {\n            if (!used[to]) {\n                dfs(to, k, idx);\n                low[idx] = min(low[idx], low[to]);\n                if (ord[idx] >= low[to]) uf.unionSet(idx, to);\n            }\n            else if (to != par) {\n                low[idx] = min(low[idx], ord[to]);\n            }\n        }\n    }\n    \n    // return origin color\n    int operator[](int k) {\n        return (comp[k]);\n    }\n    \n    int size() {\n        return ((int)g.size());\n    }\n    \n    // build, renew resG(empty -> tree), return color\n    vector<int> get_graph(vector<vector<int>>& resG, int root = 0) {\n        int kk = 0;\n        dfs(root, kk);\n        \n        int ptr = 0;\n        vector<int> color(g.size());\n        for (int i = 0; i < g.size(); i++) {\n            if (i == uf.root(i)) color[i] = ptr++;\n        }\n        \n        resG.resize(ptr);\n        for (int i = 0; i < g.size(); i++) {\n            comp[i] = color[uf.root(i)];\n        }\n        for (auto &e : edges) {\n            int x = comp[e.first], y = comp[e.second];\n            if (x == y) continue;\n            resG[x].push_back(y);\n            resG[y].push_back(x);\n        }\n        return comp;\n    }\n};\n\nint N, M, W[100000];\nvector<vector<int>> resG;\nvector<int> weightSum, sz;\nint dp1[100000], dp3[100000];\n\nint rec(int idx, int par = -1)\n{\n    int ret = 0;\n    for (auto &to : resG[idx]) {\n        if (to == par) continue;\n        ret = max(ret, rec(to, idx));\n        dp1[idx] += dp1[to];\n    }\n    ret += weightSum[idx];\n    if (sz[idx] >= 3 || dp1[idx] > 0) dp1[idx] += weightSum[idx];\n    for (auto &to : resG[idx]) {\n        if (to == par) continue;\n        else ret = max(ret, dp1[idx] - dp1[to] + dp3[to]);\n    }\n    return (dp3[idx] = ret);\n}\n\n// 三点以上集まった頂点ならば、ここを起点にもどることができる。\n// dp1[v]:vから葉まで進むときの最大値\n// dp3[v]:vに戻ってくるときの最大値\nvoid f(int v, int p = -1) {\n    for (int nx : resG[v]) {\n        if (nx == p)continue;\n        f(nx, v);\n        dp1[v] += dp1[nx];\n    }\n    int ret = dp1[v];\n    if (dp1[v] || sz[v] > 1)dp1[v] += weightSum[v];\n    for (int nx : resG[v]) {\n        if (nx == p)continue;\n        dp3[v] = max(dp3[v], ret - dp1[nx] + dp3[nx]);\n    }\n    dp3[v] += weightSum[v];\n}\n\nint main() {\n    int N, M; cin >> N >> M;\n    FOR(i, 0, N) {\n        cin >> W[i];\n    }\n    TwoEdgeConnectedComponent gx(N);\n    \n    FOR(i, 0, M) {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        gx.add_edge(a, b);\n    }\n    VI vc = gx.get_graph(resG);\n    \n    weightSum.assign(resG.size(), 0);\n    sz.assign(resG.size(), 0);\n    for (int i = 0; i < N; i++) {\n        weightSum[vc[i]] += W[i];\n        sz[vc[i]]++;\n    }\n    f(vc[0]);\n    LL ans = dp3[vc[0]];\n    cout << ans << endl;\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nbool used[100009];\nint a,b,X[100009],n,m,sum,ans;\nvector<int>v[100009];\nint dfs(int x){\n\tused[x]=1;\n\tint res=X[x];\n\tr(i,v[x].size()){\n\t\tint next=v[x][i];\n\t\tif(used[next]||!next||v[next].size()>2)continue;\n\t\tres+=dfs(next);\n\t}\n\treturn res;\n}\nint main(){\n\tcin>>n>>m;\n\tr(i,n)cin>>X[i];\n\tr(i,m){\n\t\tcin>>a>>b;\n\t\ta--,b--;\n\t\tv[a].push_back(b);\n\t\tv[b].push_back(a);\n\t}\n\tr(i,n)if(!used[i]&&v[i].size()==1)sum=max(sum,dfs(i));\n\tr(i,n)if(!used[i])ans+=X[i];\n\tcout<<ans+sum<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef int ll;\n\nvector<ll> W;\nvector<vector<ll>> E;\nvector<bool> visited;\n\nll dfs(ll v) {\n  ll ret = 0;\n  visited[v] = true;\n  for(ll u : E[v]) if(!visited[u]) ret = max(ret, dfs(u));\n  return ret + W[v];\n}\n\nint main(void) {\n  ll N, M;\n  cin >> N >> M;\n  W.resize(N);\n  REP(i, 0, N) cin >> W[i];\n  E.resize(N);\n  REP(i, 0, M) {\n    ll U, V; cin >> U >> V; U--; V--;\n    E[U].push_back(V);\n    E[V].push_back(U);\n  }\n\n  vector<ll> cnt(N, 0);\n  REP(i, 0, N) cnt[i] = E[i].size();\n  queue<ll> q;\n  REP(i, 1, N) if(cnt[i] == 1) q.push(i);\n\n  vector<bool> check(N, false), root(N, false);\n  while(q.size()) {\n    ll v = q.front();\n    q.pop();\n\n    check[v] = true;\n    root[v] = true;\n    for(ll u : E[v]) if(--cnt[u] == 1) {\n      q.push(u);\n      root[v] = false;\n    }\n  }\n\n  ll ans = 0;\n  visited.resize(N, false);\n  REP(i, 0, N) if(!check[i]) visited[i] = true;\n  REP(i, 0, N) if(root[i]) ans = max(ans, dfs(i));\n  REP(i, 0, N) if(!check[i]) ans += W[i];\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1e9 + 7;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<class T>\nistream& operator >> (istream& is, vector<T>& v)\n{\n\tfor (auto &i : v) is >> i;\n\treturn is;\n}\ntemplate<class T>\nostream& operator<<(ostream& os, vector<T>& v)\n{\n\tconst string delimiter = \"\\n\";\n\tREP(i, v.size())\n\t{\n\t\tos << v[i];\n\t\tif (i != v.size() - 1) os << delimiter;\n\t}\n\treturn os;\n}\n/*--------------------template--------------------*/\n\ntypedef int Weight;\nstruct Edge\n{\n\tint from, to; Weight cost;\n\tbool operator < (const Edge& e) const { return cost < e.cost; }\n\tbool operator > (const Edge& e) const { return cost > e.cost; }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nvoid add_edge(Graph &g, int from, int to, Weight cost)\n{\n\tg[from].push_back(Edge{ from, to, cost });\n}\n\nvector<vi> g, tree;\nvi w;\nvector<bool> can_back;\nvi mx;\n\nbool get_can_back(int v)\n{\n\tbool res = false;\n\tif (tree[v].size() + 1 < g[v].size()) res = true;\n\tfor (auto u : tree[v])\n\t{\n\t\tif (get_can_back(u)) res = u;\n\t}\n\n\treturn can_back[v] = res;\n}\n\nint get_max(int v)\n{\n\tint res = 0;\n\tfor (auto u : tree[v])\n\t{\n\t\tchmax(res, get_max(u));\n\t}\n\treturn mx[v] = res + w[v];\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tint n, m;\n\tcin >> n >> m;\n\tw.resize(n); cin >> w;\n\tg.resize(n); tree.resize(n); can_back.resize(n); mx.resize(n);\n\tREP(i, m)\n\t{\n\t\tint u, v; cin >> u >> v;\n\t\tu--; v--;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\tqueue<int> que;\n\tvector<bool> vis(n);\n\tvis[0] = true;\n\tque.push(0);\n\twhile (!que.empty())\n\t{\n\t\tint v = que.front();\n\t\tque.pop();\n\t\tfor (auto u : g[v])\n\t\t{\n\t\t\tif (vis[u]) continue;\n\t\t\tvis[u] = true;\n\t\t\ttree[v].push_back(u);\n\t\t\tque.push(u);\n\t\t}\n\t}\n\tfor (auto v : tree[0])\n\t{\n\t\tget_can_back(v);\n\t}\n\tint ans = w[0];\n\tint fin = 0;\n\tFOR(i, 1, n)\n\t{\n\t\tif (can_back[i]) ans += w[i];\n\t\telse\n\t\t{\n\t\t\tchmax(fin, get_max(i));\n\t\t}\n\t}\n\tcout << ans + fin << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n\nusing VS = vector<string>;    using LL = long long;\nusing VI = vector<int>;       using VVI = vector<VI>;\nusing PII = pair<int, int>;   using PLL = pair<LL, LL>;\nusing VL = vector<LL>;        using VVL = vector<VL>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n#define FOR(i, s, e) for (int(i) = (s); (i) < (e); (i)++)\n#define FORR(i, s, e) for (int(i) = (s); (i) > (e); (i)--)\n#define debug(x) cerr << #x << \": \" << x << endl\nconst int INF = 1e9;                          const LL LINF = 1e16;\nconst LL MOD = 1000000007;                    const double PI = acos(-1.0);\nint DX[8] = { 0, 0, 1, -1, 1, 1, -1, -1 };    int DY[8] = { 1, -1, 0, 0, 1, -1, 1, -1 };\n\nstruct UnionFind {\n    vector<int> data;\n    UnionFind(int n) { data.assign(n, -1); }\n    bool unionSet(int x, int y) {\n        x = root(x); y = root(y);\n        if (x != y) {\n            if (data[y] < data[x]) swap(x, y);\n            data[x] += data[y]; data[y] = x;\n        }\n        return x != y;\n    }\n    bool same(int x, int y) { return root(x) == root(y); }\n    int root(int x) { return data[x] < 0 ? x : data[x] = root(data[x]); }\n    int size(int x) { return -data[root(x)]; }\n};\n\nstruct TwoEdgeConnectedComponent{\n    UnionFind uf;\n    vector<vector<int>> g;\n    vector<pair<int, int>> edges;\n    vector<int> used, ord, low, comp;\n    \n    TwoEdgeConnectedComponent(int v) : uf(v), g(v), used(v, 0), comp(v), ord(v), low(v) {}\n    \n    void add_edge(int x, int y) {\n        g[x].push_back(y);\n        g[y].push_back(x);\n        edges.push_back(minmax(x, y));\n    }\n    \n    void dfs(int idx, int& k, int par = -1) {\n        used[idx] = true;\n        ord[idx] = k++;\n        low[idx] = ord[idx];\n        \n        for (auto &to : g[idx]) {\n            if (!used[to]) {\n                dfs(to, k, idx);\n                low[idx] = min(low[idx], low[to]);\n                if (ord[idx] >= low[to]) uf.unionSet(idx, to);\n            }\n            else if (to != par) {\n                low[idx] = min(low[idx], ord[to]);\n            }\n        }\n    }\n    \n    // return origin color\n    int operator[](int k) {\n        return (comp[k]);\n    }\n    \n    int size() {\n        return (g.size());\n    }\n    \n    // build, renew resG(empty -> tree), return color\n    vector<int> get_graph(vector<vector<int>>& resG, int root = 0) {\n        int kk = 0;\n        dfs(root, kk);\n        \n        int ptr = 0;\n        vector<int> color(g.size());\n        for (int i = 0; i < g.size(); i++) {\n            if (i == uf.root(i)) color[i] = ptr++;\n        }\n        \n        resG.resize(ptr);\n        for (int i = 0; i < g.size(); i++) {\n            comp[i] = color[uf.root(i)];\n        }\n                for (auto &e : edges) {\n                    int x = comp[e.first], y = comp[e.second];\n                    if (x == y) continue;\n                    resG[x].push_back(y);\n                    resG[y].push_back(x);\n                }\n        //TLE\n//        for (int v = 0; v < (int)g.size(); v++) {\n//            for (int i = 0; i < (int)g[v].size(); i++) {\n//                int u = g[v][i];\n//                int c1 = comp[v], c2 = comp[u];\n//                if (c1 == c2)continue;\n//                resG[c1].push_back(c2);\n//                resG[c2].push_back(c1);\n//            }\n//        }\n        return comp;\n    }\n};\n\nint N, M, W[100000];\nvector<vector<int>> resG;\nvector<int> weightSum, sz;\nint dp1[100000], dp3[100000];\n\nint rec(int idx, int par = -1)\n{\n    int ret = 0;\n    for (auto &to : resG[idx]) {\n        if (to == par) continue;\n        ret = max(ret, rec(to, idx));\n        dp1[idx] += dp1[to];\n    }\n    ret += weightSum[idx];\n    if (sz[idx] >= 3 || dp1[idx] > 0) dp1[idx] += weightSum[idx];\n    for (auto &to : resG[idx]) {\n        if (to == par) continue;\n        else ret = max(ret, dp1[idx] - dp1[to] + dp3[to]);\n    }\n    return (dp3[idx] = ret);\n}\n\n// 三点以上集まった頂点ならば、ここを起点にもどることができる。\n// dp1[v]:vから葉まで進むときの最大値\n// dp3[v]:vに戻ってくるときの最大値\nvoid f(int v, int p = -1) {\n    for (int nx : resG[v]) {\n        if (nx == p)continue;\n        f(nx, v);\n        dp1[v] += dp1[nx];\n    }\n    int ret = dp1[v];\n    if (dp1[v] || sz[v] > 1)dp1[v] += weightSum[v];\n    for (int nx : resG[v]) {\n        if (nx == p)continue;\n        dp3[v] = max(dp3[v], ret - dp1[nx] + dp3[nx]);\n    }\n    dp3[v] += weightSum[v];\n}\n\nint main() {\n    int N, M; cin >> N >> M;\n    FOR(i, 0, N) {\n        cin >> W[i];\n    }\n    TwoEdgeConnectedComponent gx(N);\n    \n    FOR(i, 0, M) {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        gx.add_edge(a, b);\n    }\n    VI vc = gx.get_graph(resG);\n    \n    weightSum.assign(resG.size(), 0);\n    sz.assign(resG.size(), 0);\n    for (int i = 0; i < N; i++) {\n        weightSum[vc[i]] += W[i];\n        sz[vc[i]]++;\n    }\n    f(vc[0]);\n    LL ans = dp3[vc[0]];\n    cout << ans << endl;\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<set>\nusing namespace std;\ntypedef pair<int, int> P;\n\nvector<int> edge[108000];\nset<P> bridge;\n\nbool come[108000];\nint dp[108000];\nint w[108000];\nint imos[108000];\nint n, m, u, v;\n\nbool dfs(int x, int last = -1){\n\tcome[x] = true;\n\tdp[x] += w[x];\n\tint tmp = 0;\n\tfor(int i = 0;i < edge[x].size();i++){\n\t\tint to = edge[x][i];\n\t\tif(to == last)continue;\n\t\tif(!come[to]){\n\t\t\tif(dfs(to, x)){\n\t\t\t\tdp[x] += dp[to];\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttmp = max(tmp, dp[to]);\n\t\t\t}\n\t\t\timos[x] += imos[to];\n\t\t}\n\t\telse{\n\t\t\timos[to]--;\n\t\t\timos[x]++;\n\t\t}\n\t}\n\tdp[x] += tmp;\n\tif(last != -1 && imos[x] == 0){\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nint main(){\n\tcin >> n >> m;\n\tfor(int i = 1;i <= n;i++)cin >> w[i];\n\tfor(int i = 0;i < m;i++){\n\t\tcin >> u >> v;\n\t\tedge[u].push_back(v);\n\t\tedge[v].push_back(u);\n\t}\n\tdfs(1);\n\tcout << dp[1] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Edge {\n\tint from, to;\n\tEdge(int f, int t) : from(f), to(t) {}\n};\n\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\n\npair<vector<int>, Edges> bridge(const Graph& g) {\n\tconst int n = g.size();\n\tint idx = 0, s = 0, t = 0, k = 0;\n\tvector<int>ord(n, -1), onS(n), stk(n), roots(n), cmp(n);\n\tEdges brdg;\n\tfunction<void(int, int)> dfs = [&](int v, int u) {\n\t\tord[v] = idx++;\n\t\tstk[s++] = v;\n\t\tonS[v] = true;\n\t\troots[t++] = v;\n\t\tfor (auto& e : g[v]) {\n\t\t\tint w = e.to;\n\t\t\tif (ord[w] == -1)dfs(w, v);\n\t\t\telse if (u != w && onS[w])\n\t\t\t\twhile (ord[roots[t - 1]]>ord[w])--t;\n\t\t}\n\t\tif (v == roots[t - 1]) {\n\t\t\tbrdg.emplace_back(u, v);\n\t\t\twhile (true) {\n\t\t\t\tint w = stk[--s];\n\t\t\t\tonS[w] = false;\n\t\t\t\tcmp[w] = k;\n\t\t\t\tif (v == w)break;\n\t\t\t}\n\t\t\t--t;\n\t\t\t++k;\n\t\t}\n\t};\n\tfor (int u = 0; u<n; ++u) {\n\t\tif (ord[u] == -1) {\n\t\t\tdfs(u, n);\n\t\t\tbrdg.pop_back();\n\t\t}\n\t}\n\treturn make_pair(cmp, brdg);\n}\n\nclass HLDecomposition {\n\tvector<vector<int>> g;\n\tvector<int> vid, head, heavy, parent, depth, inv;\n\tint dfs(int curr, int prev) {\n\t\tparent[curr] = prev;\n\t\tint sub = 1, max_sub = 0;\n\t\tfor (int next : g[curr]) if (next != prev) {\n\t\t\tdepth[next] = depth[curr] + 1;\n\t\t\tint sub_next = dfs(next, curr);\n\t\t\tsub += sub_next;\n\t\t\tif (max_sub < sub_next) max_sub = sub_next, heavy[curr] = next;\n\t\t}\n\t\treturn sub;\n\t}\n\tvoid bfs() {\n\t\tint k = 0;\n\t\tqueue<int> q({ 0 });\n\t\twhile (!q.empty()) {\n\t\t\tint h = q.front(); q.pop();\n\t\t\tfor (int i = h; i != -1; i = heavy[i]) {\n\t\t\t\tvid[i] = k++;\n\t\t\t\tinv[vid[i]] = i;\n\t\t\t\thead[i] = h;\n\t\t\t\tfor (int j : g[i]) if (j != parent[i] && j != heavy[i]) q.push(j);\n\t\t\t}\n\t\t}\n\t}\npublic:\n\tHLDecomposition(int n)\n\t\t: g(n), vid(n, -1), head(n), heavy(n, -1), parent(n), depth(n), inv(n) {}\n\n\tvoid add(int u, int v) {\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\tvoid build() {\n\t\tdfs(0, -1);\n\t\tbfs();\n\t}\n\tvoid for_each(int u, int v, function<void(int, int)> f) {\n\t\tif (vid[u] > vid[v]) swap(u, v);\n\t\tf(max(vid[head[v]], vid[u]), vid[v]);\n\t\tif (head[u] != head[v]) for_each(u, parent[head[v]], f);\n\t}\n\tvoid for_each_directed(int u, int v, function<void(int, int, int)> f) {\n\t\tif (vid[u] > vid[v]) {\n\t\t\tf(max(vid[head[u]], vid[v]), vid[u], 1);\n\t\t\tif (head[u] != head[v]) for_each_directed(parent[head[u]], v, f);\n\t\t}\n\t\telse {\n\t\t\tf(max(vid[head[v]], vid[u]), vid[v], 0);\n\t\t\tif (head[u] != head[v]) for_each_directed(u, parent[head[v]], f);\n\t\t}\n\t}\n\tvoid for_each_edge(int u, int v, function<void(int, int)> f) {\n\t\tif (vid[u] > vid[v]) swap(u, v);\n\t\tif (head[u] != head[v]) {\n\t\t\tf(vid[head[v]], vid[v]);\n\t\t\tfor_each_edge(u, parent[head[v]], f);\n\t\t}\n\t\telse {\n\t\t\tif (u != v) f(vid[u] + 1, vid[v]);\n\t\t}\n\t}\n\tint ancestor(int u, int d) {\n\t\twhile (true) {\n\t\t\tif (depth[head[u]] > depth[u] - d) {\n\t\t\t\td -= depth[u] - depth[head[u]] + 1;\n\t\t\t\tif (head[u] == 0) return 0;\n\t\t\t\tu = parent[head[u]];\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn inv[vid[u] - d];\n\t\t\t}\n\t\t}\n\t}\n\tint lca(int u, int v) {\n\t\tif (vid[u] > vid[v]) swap(u, v);\n\t\tif (head[u] == head[v]) return u;\n\t\treturn lca(u, parent[head[v]]);\n\t}\n\tint distance(int u, int v) {\n\t\treturn depth[u] + depth[v] - 2 * depth[lca(u, v)];\n\t}\n};\n\ntemplate <typename T>\nclass SegmentTree {\n\tusing func_t = function<T(T, T)>;\n\tconst int n;\n\tconst T id;\n\tfunc_t merge;\n\tvector<T> data;\n\tint size(int n) {\n\t\tint res;\n\t\tfor (res = 1; res < n; res <<= 1);\n\t\treturn res;\n\t}\n\tT sub(int l, int r, int node, int lb, int ub) {\n\t\tif (ub <= l || r <= lb) return id;\n\t\tif (l <= lb && ub <= r) return data[node];\n\t\treturn merge(sub(l, r, node * 2, lb, (lb + ub) / 2), sub(l, r, node * 2 + 1, (lb + ub) / 2, ub));\n\t}\npublic:\n\tSegmentTree(int n_, T id_, func_t merge_) :\n\t\tn(size(n_)), id(id_), merge(merge_), data(size(n_) * 2, id_) {}\n\tvoid Init(const vector<T>& data_) {\n\t\tfor (int i = 0; i < (int)data_.size(); i++)\n\t\t\tdata[i + n] = data_[i];\n\t\tfor (int i = n - 1; i >= 0; i--)\n\t\t\tdata[i] = merge(data[i * 2], data[i * 2 + 1]);\n\t}\n\tvoid Update(int p, T val) {\n\t\tp += n;\n\t\tdata[p] = val;\n\t\twhile (p >>= 1) data[p] = merge(data[p * 2], data[p * 2 + 1]);\n\t}\n\tvoid Add(int p, T val) {\n\t\tp += n;\n\t\tdata[p] += val;\n\t\twhile (p >>= 1) data[p] = merge(data[p * 2], data[p * 2 + 1]);\n\t}\n\tT Find(int i) {\n\t\treturn data[i + n];\n\t}\n\tT Find(int l, int r) {\n\t\treturn sub(l, r + 1, 1, 0, n);\n\t}\n};\n\nint main()\n{\n\tcin.sync_with_stdio(false);\n\tcin.tie(0);\n\tint N, M;\n\tcin >> N >> M;\n\tvector<int> w(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> w[i];\n\t}\n\tGraph G(N);\n\tfor (int i = 0, u, v; i < M; i++) {\n\t\tcin >> u >> v; u--; v--;\n\t\tG[u].emplace_back(u, v);\n\t\tG[v].emplace_back(v, u);\n\t}\n\tauto br = bridge(G);\n\tint V = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tV = max(V, br.first[i] + 1);\n\t}\n\tHLDecomposition hl(V);\n\tfor (auto e : br.second) {\n\t\thl.add(br.first[e.from], br.first[e.to]);\n\t}\n\thl.build();\n\tSegmentTree<int> st(V, 0, [](int l, int r) { return l + r; });\n\tfor (int i = 0; i < N; i++) {\n\t\thl.for_each(br.first[i], br.first[i], [&](int l, int r) {\n\t\t\tst.Add(l, w[i]);\n\t\t});\n\t}\n\tint res = 0;\n\tfor (int i = 0; i < V; i++) {\n\t\tint tmp = 0;\n\t\thl.for_each(br.first[0], i, [&](int l, int r) {\n\t\t\ttmp += st.Find(l, r);\n\t\t});\n\t\tres = max(res, tmp);\n\t}\n\tcout << res << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_V 100000\nusing namespace std;\nint n,m,w[100001];\nvector<int> v[100001],v1[100001];\nunordered_set<int> st[100001];\nint V;\nvector<int> G[MAX_V];\nvector<int> rG[MAX_V];\nvector<int> vs;\nbool used[MAX_V];\nint cmp[MAX_V];\n\nvoid DFS(int p){\n  for(int i=0;i<v[p].size();i++){\n    int mn=min(v[p][i],p),mx=max(v[p][i],p);\n    if(st[mn].find(mx)==st[mn].end()){\n      st[mn].insert(mx);\n      G[p].push_back(v[p][i]);\n      rG[v[p][i]].push_back(p);\n      DFS(v[p][i]);\n    }\n  }\n}\n\nvoid dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++)if(!used[G[v][i]])dfs(G[v][i]);\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v]=true;\n  cmp[v]=k;\n  for(int i=0;i<rG[v].size();i++)if(!used[rG[v][i]])rdfs(rG[v][i],k);\n}\n\nint scc(){\n  memset(used,0,sizeof(used));\n  vs.clear();\n  for(int v=0;v<V;v++)if(!used[v])dfs(v);\n  memset(used,0,sizeof(used));\n  int k=0;\n  for(int i=vs.size()-1;i>=0;i--)if(!used[vs[i]])rdfs(vs[i],k++);\n  return k;\n}\n\nint C[100001],F[100001],U[100001],ans;\nbool UU[100001];\n\nbool DFS1(int p){\n  if(U[p])return 0;\n  U[p]=1;\n  bool f=F[cmp[p]]>=2;\n  for(int i=0;i<G[p].size();i++)\n    f=max(f,DFS1(G[p][i]));\n  ans+=w[p]*f;\n  return UU[p]=f;\n}\n\nint DFS2(int p){\n  if(UU[p])return 0;\n  UU[p]=1;\n  int res=0;\n  for(int i=0;i<v[p].size();i++)\n    res+=DFS2(v[p][i]);\n  return w[p]+res;\n}\n\nint main(){\n  cin>>V>>m;\n  for(int i=0;i<V;i++)cin>>w[i];\n  for(int j=0,a,b;j<m;j++){\n    cin>>a>>b;a--,b--;\n    v[a].push_back(b),v[b].push_back(a);\n  }\n  DFS(0);\n  scc();\n  for(int i=0;i<V;i++)F[cmp[i]]++;\n  DFS1(0);\n  int mx=0;\n  for(int i=0;i<V;i++)\n    if(!UU[i])mx=max(mx,DFS2(i));\n  cout<<ans+mx<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct UnionFind\n{\n  vector< int > data;\n\n  UnionFind(int sz)\n  {\n    data.assign(sz, -1);\n  }\n\n  bool unite(int x, int y)\n  {\n    x = find(x), y = find(y);\n    if(x == y) return (false);\n    if(data[x] > data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n    return (true);\n  }\n\n  int find(int k)\n  {\n    if(data[k] < 0) return (k);\n    return (data[k] = find(data[k]));\n  }\n\n  int size(int k)\n  {\n    return (-data[find(k)]);\n  }\n};\n\nstruct BiConnectedComponents\n{\n  UnionFind uf;\n  vector< vector< int > > g;\n  vector< pair< int, int > > edges;\n  vector< int > used, ord, low, comp;\n\n  BiConnectedComponents(size_t v) : uf(v), g(v), used(v, 0), comp(v), ord(v), low(v)\n  {\n  }\n\n  void add_edge(int x, int y)\n  {\n    g[x].push_back(y);\n    g[y].push_back(x);\n    edges.push_back(minmax(x, y));\n  }\n\n  void dfs(int idx, int &k, int par = -1)\n  {\n    used[idx] = true;\n    ord[idx] = k++;\n    low[idx] = ord[idx];\n\n    for(auto &to : g[idx]) {\n      if(!used[to]) {\n        dfs(to, k, idx);\n        low[idx] = min(low[idx], low[to]);\n        if(ord[idx] >= low[to]) uf.unite(idx, to);\n      } else if(to != par) {\n        low[idx] = min(low[idx], ord[to]);\n      }\n    }\n  }\n\n  int operator[](int k)\n  {\n    return (comp[k]);\n  }\n\n  size_t size()\n  {\n    return (g.size());\n  }\n\n  void build(vector< vector< int > > &t)\n  {\n    int kk = 0;\n    dfs(0, kk);\n\n    int ptr = 0;\n    vector< int > cc(g.size());\n    for(int i = 0; i < g.size(); i++) {\n      if(i == uf.find(i)) cc[i] = ptr++;\n    }\n\n    t.resize(ptr);\n    for(int i = 0; i < g.size(); i++) {\n      comp[i] = cc[uf.find(i)];\n    }\n    for(auto &e : edges) {\n      int x = comp[e.first], y = comp[e.second];\n      if(x == y) continue;\n      t[x].push_back(y);\n      t[y].push_back(x);\n    }\n  }\n};\n\nint N, M, W[100000];\nvector< vector< int > > g;\nvector< int > weightSum, sz;\nint dp1[100000], dp3[100000];\n\nint rec(int idx, int par = -1)\n{\n  int ret = 0;\n  for(auto &to : g[idx]) {\n    if(to == par) continue;\n    ret = max(ret, rec(to, idx));\n    dp1[idx] += dp1[to];\n  }\n  ret += weightSum[idx];\n  if(sz[idx] >= 3 || dp1[idx] > 0) dp1[idx] += weightSum[idx];\n  for(auto &to : g[idx]) {\n    if(to == par) continue;\n    else ret = max(ret, dp1[idx] - dp1[to] + dp3[to]);\n  }\n  return (dp3[idx] = ret);\n}\n\nint main()\n{\n  cin >> N >> M;\n  BiConnectedComponents tree(N);\n  for(int i = 0; i < N; i++) {\n    cin >> W[i];\n  }\n  while(M--) {\n    int U, V;\n    cin >> U >> V;\n    tree.add_edge(--U, --V);\n  }\n  tree.build(g);\n  weightSum.assign(g.size(), 0);\n  sz.assign(g.size(), 0);\n  for(int i = 0; i < N; i++) {\n    weightSum[tree[i]] += W[i];\n    sz[tree[i]]++;\n  }\n  cout << rec(tree[0]) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct UnionFind\n{\n  vector< int > data;\n\n  UnionFind(int sz)\n  {\n    data.assign(sz, -1);\n  }\n\n  bool unite(int x, int y)\n  {\n    x = find(x), y = find(y);\n    if(x == y) return (false);\n    if(data[x] > data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n    return (true);\n  }\n\n  int find(int k)\n  {\n    if(data[k] < 0) return (k);\n    return (data[k] = find(data[k]));\n  }\n\n  int size(int k)\n  {\n    return (-data[find(k)]);\n  }\n};\n\nstruct BiConnectedComponents\n{\n  UnionFind uf;\n  vector< vector< int > > g;\n  vector< pair< int, int > > edges;\n  vector< int > used, ord, low, comp;\n\n  BiConnectedComponents(size_t v) : uf(v), g(v), used(v, 0), comp(v), ord(v), low(v)\n  {\n  }\n\n  void add_edge(int x, int y)\n  {\n    g[x].push_back(y);\n    g[y].push_back(x);\n    edges.push_back(minmax(x, y));\n  }\n\n  void dfs(int idx, int &k, int par = -1)\n  {\n    used[idx] = true;\n    ord[idx] = k++;\n    low[idx] = ord[idx];\n\n    for(auto &to : g[idx]) {\n      if(!used[to]) {\n        dfs(to, k, idx);\n        low[idx] = min(low[idx], low[to]);\n        if(ord[idx] >= low[to]) uf.unite(idx, to);\n      } else if(to != par) {\n        low[idx] = min(low[idx], ord[to]);\n      }\n    }\n  }\n\n  int operator[](int k)\n  {\n    return (comp[k]);\n  }\n\n  size_t size()\n  {\n    return (g.size());\n  }\n\n  void build(vector< vector< int > > &t)\n  {\n    int kk = 0;\n    dfs(0, kk);\n\n    int ptr = 0;\n    vector< int > cc(g.size());\n    for(int i = 0; i < g.size(); i++) {\n      if(i == uf.find(i)) cc[i] = ptr++;\n    }\n\n    t.resize(ptr);\n    for(int i = 0; i < g.size(); i++) {\n      comp[i] = cc[uf.find(i)];\n    }\n    for(auto &e : edges) {\n      int x = comp[e.first], y = comp[e.second];\n      if(x == y) continue;\n      t[x].push_back(y);\n      t[y].push_back(x);\n    }\n  }\n};\n\nint N, M, W[100000];\nvector< vector< int > > g;\nvector< int > weightSum, sz;\nint dp1[100000], dp3[100000];\n\nint rec(int idx, int par = -1)\n{\n  int ret = 0;\n  for(auto &to : g[idx]) {\n    if(to == par) continue;\n    rec(to, idx);\n    dp1[idx] += dp1[to];\n  }\n  if(sz[idx] >= 3 || dp1[idx] > 0) dp1[idx] += weightSum[idx];\n  for(auto &to : g[idx]) {\n    if(to == par) continue;\n    else ret = max(ret, dp1[idx] - dp1[to] + dp3[to]);\n  }\n  return (dp3[idx] = ret);\n}\n\nint main()\n{\n  cin >> N >> M;\n  BiConnectedComponents tree(N);\n  for(int i = 0; i < N; i++) {\n    cin >> W[i];\n  }\n  while(M--) {\n    int U, V;\n    cin >> U >> V;\n    tree.add_edge(--U, --V);\n  }\n  tree.build(g);\n  weightSum.assign(g.size(), 0);\n  sz.assign(g.size(), 0);\n  for(int i = 0; i < N; i++) {\n    weightSum[tree[i]] += W[i];\n    sz[tree[i]]++;\n  }\n  cout << rec(tree[0]) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int, int> P;\nconst int M = 1000000007;\n\nvector<vector<int>> edge;\nvector<vector<int>> tecomp;\nvector<set<int>> nedge;\nvector<int> uid, uuid;\nvector<int> nw;\n\n\n\nvoid visit(int v, int u,\n        stack<int>& roots, stack<int>& S, vector<bool>& inS,\n        vector<int>& num, int& tm) {\n    num[v] = ++tm;\n    S.push(v); inS[v] = true;\n    roots.push(v);\n    for (int w : edge[v]) {\n        if (num[w] == 0)\n            visit(w, v, roots, S, inS, num, tm);\n        else if (u != w && inS[w])\n            while (num[roots.top()] > num[w]) roots.pop();\n    }\n    if (v == roots.top()) {\n        tecomp.push_back(vector<int>());\n        while (1) {\n            int w = S.top(); S.pop(); inS[w] = false;\n            tecomp.back().push_back(w);\n            if (v == w) break;\n        }\n        roots.pop();\n    }\n}\n\n\nbool dfs(int now, int par, int zero) {\n    bool ret = tecomp[now].size() > 1;\n    for (int i : nedge[now]) {\n        if (i == par) continue;\n        ret |= dfs(i, now, zero);\n    }\n    if (ret) {\n        uuid[now] = zero;\n    }\n    return ret;\n}\nint dfs(int now, int par) {\n    int ret = 0;\n    for (int i : nedge[now]) {\n        if (i == par) continue;\n        ret = max(ret, dfs(i, now));\n    }\n    return ret + nw[now];\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<int> w(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> w[i];\n    }\n    edge.resize(n);\n    for (int i = 0; i < m; ++i) {\n        int a, b;\n        cin >> a >> b;\n        --a;\n        --b;\n        edge[a].push_back(b);\n        edge[b].push_back(a);\n    }\n    vector<int> num(n, 0);\n    vector<bool> inS(n);\n    stack<int> roots, S;\n    int tm = 0;\n    for (int u = 0; u < n; ++u)\n        if (num[u] == 0)\n            visit(u, n, roots, S, inS, num, tm);\n\n    int nn = tecomp.size();\n    uid.resize(n);\n    for (int i = 0; i < nn; ++i) {\n        for (int j : tecomp[i])\n            uid[j] = i;\n    }\n    int zero = uid[0];\n    nedge.resize(nn);\n    for (int i = 0; i < n; ++i) {\n        for (int j : edge[i]) {\n            if (uid[i] != uid[j])\n                nedge[uid[i]].insert(uid[j]);\n        }\n    }\n    uuid.resize(n);\n    for (int i = 0; i < n; ++i) {\n        uuid[i] = i;\n    }\n    dfs(zero, -1, zero);\n    nw.resize(nn, 0);\n    for (int i = 0; i < n; ++i) {\n        nw[uuid[uid[i]]] += w[i];\n    }\n    vector<int> useduid(nn, 0);\n    vector<int> used(nn, 0);\n    int ma = 0;\n    for (int i = 0; i < n; ++i) {\n        if (!useduid[uid[i]] && uuid[uid[i]] == zero) {\n            useduid[uid[i]] = 1;\n            for (int j : nedge[uid[i]]) {\n                if (uuid[j] != zero && !used[j]) {\n                    used[j] = 1;\n                    ma = max(ma, dfs(j, uid[i]));\n                }\n            }\n        }\n    }\n    cout << (nw[zero] + ma) << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nstruct Graph {\n    Graph(const int n)\n    {\n        edge.resize(n);\n    }\n    void addEdge(const int from, const int to)\n    {\n        edge[from].push_back(to);\n        edge[to].push_back(from);\n    }\n    vector<vector<int>> edge;\n};\n\nint dfs(const Graph& g, const int s, vector<bool>& used, vector<bool>& compressed)\n{\n    used[s] = true;\n    int removed = 0;\n    int child = 0;\n    for (const int to : g.edge[s]) {\n        child++;\n        if (used[to]) {\n            continue;\n        }\n        removed += dfs(g, to, used, compressed);\n    }\n    if (s != 0 and removed + 1 == child) {\n        compressed[s] = false;\n        return 1;\n    }\n    return 0;\n}\n\nint weight_dfs(const Graph& g, const int s, const vector<int>& w, vector<bool>& visited)\n{\n    visited[s] = true;\n    int weight = w[s];\n    int maxi = 0;\n    for (const int to : g.edge[s]) {\n        if (visited[to]) {\n            continue;\n        }\n        maxi = max(maxi, weight_dfs(g, to, w, visited));\n    }\n    return weight + maxi;\n}\n\nint main()\n{\n    int N, M;\n    cin >> N >> M;\n    vector<int> w(N);\n    for (int i = 0; i < N; i++) {\n        cin >> w[i];\n    }\n    Graph g(N);\n    vector<int> u(M);\n    vector<int> v(M);\n    for (int i = 0; i < M; i++) {\n        int u_, v_;\n        cin >> u_ >> v_;\n        u_--;\n        v_--;\n        u[i] = u_;\n        v[i] = v_;\n        g.addEdge(u_, v_);\n    }\n\n    vector<bool> used(N, false);\n    vector<bool> compressed(N, true);\n\n    dfs(g, 0, used, compressed);\n    int sum = 0;\n    for (int i = 0; i < N; i++) {\n        if (compressed[i]) {\n            sum += w[i];\n        }\n    }\n    w[0] = sum;\n    Graph dec_g(N);\n    for (int i = 0; i < M; i++) {\n        int u_ = u[i];\n        int v_ = v[i];\n        if (compressed[u_]) {\n            u_ = 0;\n        }\n        if (compressed[v_]) {\n            v_ = 0;\n        }\n        if (u_ == 0 and v_ == 0) {\n            continue;\n        }\n        dec_g.addEdge(u_, v_);\n    }\n    vector<bool> visited(N, false);\n    cout << weight_dfs(dec_g, 0, w, visited) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n\nclass Graph{\npublic:\n  int n;\n  vector<vector<int> > e;\n  vector<int> w,vdeg,cost;\n\n  Graph(int v){\n    n = v;\n    w = vector<int>(n,0);\n    vdeg = vector<int>(n,0);\n    cost = vector<int>(n,0);\n    e = vector<vector<int> >(n,vector<int>(0));\n  }\n\n  void addEdge(int a, int b){\n    e[a].push_back(b);\n    e[b].push_back(a);\n    vdeg[a]++;\n    vdeg[b]++;\n  }\n\n  int degree(int u){\n    return (int)e[u].size();\n  }\n\n  bool isConnected(int u, int v){\n    auto itr = find(e[u].begin(),e[u].end(),v);\n    if(itr == e[u].end()) return false;\n    return true;\n  }\n\n};\n\nclass Tree{\npublic:\n  int n,mc=0;\n  vector<int> par,w,cost;\n  vector<vector<int> > child;\n\n  Tree(int v){\n    n = v;\n    par = vector<int>(n,-1);\n    w = vector<int>(n,0);\n    cost = vector<int>(n,0);\n    child = vector<vector<int> >(n,vector<int>(0));\n  }\n\n  void setCost(int v, int c){\n    cost[v] = c;\n    mc = max(mc,c);\n  }\n\n  void addCost(int v, int c){\n    cost[v] += c;\n    mc = max(mc,cost[v]);\n  }\n\n  void addEdge(int pr,int chi){\n    child[pr].push_back(chi);\n    par[chi] = pr;\n  }\n\n  int childsize(int u){\n    return (int)child[u].size();\n  }\n};\n\nint main(){\n\n  int n,m;\n  cin >> n >> m;\n  Graph g(n);\n  vector<int> tour(n,1);\n  rep(i,n){\n    int w;\n    cin >> w;\n    g.w[i] = w;;\n  }\n  rep(i,m){\n    int u,v;\n    cin >> u >> v;\n    u--;v--;\n    g.addEdge(u,v);\n  }\n\n  // 次数1の頂点を消していく\n  queue<int> que;\n  rep(i,n){\n    if(g.degree(i)==1)que.push(i);\n  }\n  while(!que.empty()){\n    int i = que.front();\n    que.pop();\n    if(i==0)continue;\n    tour[i] = 0;\n    rep(j,g.e[i].size()){\n      int to = g.e[i][j];\n      if(tour[to]){\n        g.vdeg[to]--;\n        if(g.vdeg[to]==1)que.push(to);\n      }\n    }\n  }\n  \n  int cent = 0;\n  int w = 0;\n  rep(i,n)if(tour[i]==1){cent++;w+=g.w[i];}\n  cout << w << endl;\n  \n  vector<int> inds(n);\n  int index = 0;\n  rep(i,n){\n    if(tour[i]==0){\n      inds[i] = index;\n      index++;\n    }\n  }\n\n  // gから巡回可能部分を縮約したグラフtを構築する\n  int nt = n-cent+1;\n  Graph t(nt);\n  if (cent>0){\n    t.w[nt-1] = w;\n    //t.setWeight(nt-1,w);\n  }\n  index = 0;\n  rep(i,n){\n    if (tour[i]==0){\n      t.w[inds[i]] = g.w[i];\n      // t.setWeight(inds[i],g.w[i]);\n      rep(j,g.e[i].size()){\n        if(tour[g.e[i][j]]==0&&!t.isConnected(inds[i],inds[g.e[i][j]])){\n          t.addEdge(inds[i],inds[g.e[i][j]]);\n        } else if (tour[g.e[i][j]]==1) {\n          t.addEdge(inds[i],nt-1);\n        }\n      }\n    }\n  }\n  int rt;\n  if (tour[0]==0){rt = inds[0];}\n  else {rt = nt-1;}\n\n  // BFS\n  vector<bool> visited(nt,false);\n  rep(i,nt)t.cost[i] = t.w[i];\n  que.push(rt);\n  int maxcost = 0;\n  while(!que.empty()){\n    int u = que.front();\n    que.pop();\n    visited[u] = true;\n    if (t.cost[u]>maxcost)maxcost = t.cost[u];\n    rep(i,t.e[u].size()){\n      int to = t.e[u][i];\n      if(!visited[to]){\n        que.push(to);\n        t.cost[to] += t.cost[u];\n      }\n    }\n  }\n  cout << maxcost << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N, M;\n  cin >> N >> M;\n  VI ws(N);\n  REP(i,N) cin >> ws[i];\n  vector<set<int>> G(N);\n  VI in(N);\n  REP(i,M){\n\tint u, v;\n\tcin >> u >> v;\n\t--u;\n\t--v;\n\tG[u].insert(v);\n\tG[v].insert(u);\n\tin[u]++;\n\tin[v]++;\n  }\n\n  VI dp(N);\n  vector<bool> vis(N);\n  queue<int> q;\n  REP(i,N) if(in[i] == 1) q.push(i);\n  while(!q.empty()){\n\tint crt = q.front();\n\tint to = *begin(G[crt]);\n\tq.pop();\n\tG[to].erase(crt);\n\tmaxi(dp[to], dp[crt] + ws[crt]);\n\tvis[crt] = true;\n\tif(to != 0 && SZ(G[to]) == 1)\n\t  q.push(to);\n  }\n\n  int mx = 0;\n  int ans = 0;\n  REP(i,N) if(!vis[i]){\n\tans += ws[i];\n\tmaxi(mx, dp[i]);\n  }\n  cout << ans + mx << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\nclass Node{\n\tpublic:\n\t\tint ord; //DFSの訪問の順番\n\t\tint par; //DFS Treeにおける親\n\t\tint low; //min(自分のord, 逆辺がある場合の親のord, すべての子のlow)\n\t\tNode() : ord(-1) { }\n};\n\nclass ArticulationPoints {\n\tprivate:\n\t\tint v, cnt;\n\t\tvector<Node> node;\n\t\tvoid dfs(int cur, int prev){\n\t\t\tnode[cur].ord = node[cur].low = cnt;\n\t\t\tcnt++;\n\n\t\t\tfor(auto to : g[cur]){\n\t\t\t\tif(to == prev) continue;\n\t\t\t\tif(node[to].ord >= 0){\n\t\t\t\t\tnode[cur].low = min(node[cur].low, node[to].ord);\n\t\t\t\t}else{\n\t\t\t\t\tnode[to].par = cur;\n\t\t\t\t\tdfs(to, cur);\n\t\t\t\t\tnode[cur].low = min(node[cur].low, node[to].low);\n\t\t\t\t}\n\t\t\t\tif(node[cur].ord < node[to].low){\n\t\t\t\t\tbridge.emplace_back(min(cur, to), max(cur, to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tpublic:\n\t\tvector<vector<int>> g;\n\t\tvector<pair<int, int>> bridge;\n\t\tset<int> ap; // 関節店\n\t\tArticulationPoints(int n) : v(n), cnt(1), node(n), g(n) { }\n\t\tvoid addEdge(int a, int b){\n\t\t\tg[a].emplace_back(b);\n\t\t\tg[b].emplace_back(a);\n\t\t}\n\t\tbool isBridge(int u, int v){\n\t\t\tif(node[u].ord > node[v].ord) swap(u,v);\n\t\t\treturn node[u].ord < node[v].low;\n\t\t}\n\t\tvoid run(){\n\t\t\tdfs(0, -1); // 0 = root\n\n\t\t\tint np = 0;\n\t\t\trange(i,1,v){\n\t\t\t\tint p = node[i].par;\n\t\t\t\tif(p == 0) np++;\n\t\t\t\telse if(node[p].ord <= node[i].low) ap.emplace(p);\n\t\t\t}\n\t\t\tif(np > 1) ap.emplace(0);\n\t\t\tsort(all(bridge));\n\t\t\t//for(auto it:ap){ cout << it << endl; } //関節点の全列挙\n\t\t\t//for(auto it:bridge){ cout << it.first << ' ' << it.second << endl; } //橋の全列挙\n\t\t}\n};\n\nclass TwoEdgeConnectedComponent : public ArticulationPoints {\n\tprivate:\n\t\tvoid dfs(int c, int pos){\n\t\t\tver[c].emplace_back(pos);\n\t\t\tcomp[pos] = c;\n\t\t\tfor (int to : g[pos]) {\n\t\t\t\tif (comp[to] >= 0) continue;\n\t\t\t\tif (isBridge(pos, to)) continue;\n\t\t\t\tdfs(c, to);\n\t\t\t}\n\t\t}\n\t\tvoid addComp(int pos){\n\t\t\tif(comp[pos] >= 0) return;\n\t\t\tver.emplace_back();\n\t\t\tdfs(ver.size() - 1, pos);\n\t\t}\n\tpublic:\n\t\tvector<int> comp; // 成分分解前の頂点から分解後の頂点への写像？\n\t\tvector<vector<int>> ver; // 分解後の頂点と、その頂点に含まれる分解前の頂点\n\t\tTwoEdgeConnectedComponent(int n) : ArticulationPoints(n), comp(n,-1) {}\n\t\tvoid solve(){\n\t\t\trun();\n\t\t\tfor(auto p : bridge){\n\t\t\t\taddComp(p.first);\n\t\t\t\taddComp(p.second);\n\t\t\t}\n\t\t\taddComp(0);\n\t\t}\n\t\tvector<vector<int>> getTree(){\n\t\t\tvector<vector<int>> res(ver.size());\n\t\t\tfor(auto p : bridge){\n\t\t\t\tint u = comp[p.first], v = comp[p.second];\n\t\t\t\tres[u].emplace_back(v);\n\t\t\t\tres[v].emplace_back(u);\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n};\n\nvoid cut(vector<vector<int>>& g, vector<int>& in, vector<bool>& used, vector<int>& p, int pos){\n\tused[pos] = true;\n\tfor(auto to : g[pos]){\n\t\tif(used[to]) continue;\n\t\tcut(g, in, used, p, to);\n\t}\n\tif(in[pos] == 1){\n\t\tfor(auto to : g[pos]){\n\t\t\tin[to]--;\n\t\t}\n\t\tp.emplace_back(pos);\n\t}\n}\n\nint dfs(vector<vector<int>>& g, vector<int>& w, vector<bool>& used, int pos){\n\tint res = w[pos];\n\tused[pos] = true;\n\tfor(auto to : g[pos]){\n\t\tif(used[to]) continue;\n\t\tres += dfs(g, w, used, to);\n\t}\n\treturn res;\n}\n\nvoid dfs(vector<vector<int>>& g, vector<vector<int>>& ver, vector<bool>& used, int pos){\n\tif(ver[pos].size() != 1) return;\n\tused[pos] = true;\n\tfor(auto to : g[pos]){\n\t\tif(used[pos]) continue;\n\t\tdfs(g, ver, used, to);\n\t}\n}\n\nint dfs(vector<vector<int>>& g, vector<vector<int>>& node, vector<int>& w, vector<bool>& used, int pos){\n\tint res = w[node[pos].at(0)];\n\tused[pos] = false;\n\tfor(auto to : g[pos]){\n\t\tif(not used[to]) continue;\n\t\tres += dfs(g, node, w, used, to);\n\t}\n\treturn res;\n}\n\nint main(){\n\tint n, m;\n\tcin >> n >> m;\n\n\tvector<int> w(n);\n\tcin >> w;\n\n\tTwoEdgeConnectedComponent tecc(n);\n\trep(i,m){\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tu--; v--;\n\t\ttecc.addEdge(u,v);\n\t}\n\ttecc.solve();\n\tvector<vector<int>> g = tecc.getTree();\n\n\tvector<bool> used(g.size(),0);\n\trep(i,g.size()){\n\t\tdfs(g, tecc.ver, used, i);\n\t}\n\n\t//rep(i,tecc.ver.size()){\n\t//\tshow(i)\n\t//\tfor(auto j : tecc.ver[i]) cout << j << endl;\n\t//}\n\n\tint ans = 0;\n\trep(i,g.size()){\n\t\tif(used[i]) continue;\n\t\tfor(auto j : tecc.ver[i]){\n\t\t\tans += w[j];\n\t\t}\n\t}\n\n\tint res = 0;\n\trep(i,g.size()){\n\t\tfor(auto j : g[i]){\n\t\t\tif(not used[i] and used[j]) res = max(res, dfs(g, tecc.ver, w, used, j));\n\t\t}\n\t}\n\n\tcout << ans + res << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_N 100011\n#define N MAX_N\n#define rank dfasfds\nusing namespace std;\ntypedef long long ll;\ntypedef set<int> S;\nint par[MAX_N],rank[MAX_N];\nll val[MAX_N];\nS G[N];\n\nvoid init(int n){for(int i=0;i<N;i++)par[i]=i,rank[i]=0;}\n\nint find(int x){\n  if(par[x]==x)return x;\n  return par[x]=find(par[x]);\n}\n\nbool same(int x,int y){return find(x)==find(y);}\n\nvoid unite(int x,int y){\n  x=find(x),y=find(y);\n  if(x==y)return;\n  if(rank[x]<rank[y])par[x]=y,val[y]+=val[x];\n  else{\n    par[y]=x;\n    val[x]+=val[y];\n    if(rank[x]==rank[y])rank[x]++;\n  }\n}\n\nint used[N];\nvector<int> path;\nvoid dfs(int pos,int pre){\n  if(used[pos]||pos!=find(pos)) {\n    for(int i=0;i<path.size();i++)unite(pos,path[i]);\n    return;\n  }\n  used[pos]=1;\n  path.push_back(pos);\n  for(S::iterator it=G[pos].begin();it!=G[pos].end();it++)if(*it!=pre)dfs(*it,pos);\n  used[pos]=0;\n  path.pop_back();\n}\n\nvector<int>col[N];\nll get_mx(int pos){\n  pos=find(pos);\n  used[pos]=1;\n  ll res=0;\n  \n  for(int i=0;i<col[pos].size();i++)\n    for(S::iterator it=G[col[pos][i]].begin();it!=G[col[pos][i]].end();it++)\n      if(!used[find(*it)])res=max(res,get_mx(find(*it)));\n  return res+val[find(pos)];\n}\n\nint main(){\n  int n,m;\n  cin>>n>>m;\n  for(int i=0;i<n;i++) cin>>val[i];\n  for(int i=0,a,b;i<m;i++){\n    cin>>a>>b;a--,b--;\n    G[a].insert(b);\n    G[b].insert(a);\n  }\n  init(n);\n  dfs(0,-1);\n  for(int i=0;i<n;i++) col[find(i)].push_back(i);\n  cout <<get_mx(find(0))<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing Edges=vector<int>;\nusing Graph=vector<Edges>;\n\nint main(){\n    int n,m;\n    cin>>n>>m;\n    vector<int> w(n);\n    for(int i=0;i<n;i++) cin>>w[i];\n    Graph g(n);\n    for(int i=0;i<m;i++){\n        int u,v;\n        cin>>u>>v;\n        u--,v--;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    vector<int> leaf(n,false);\n    vector<int> pot(n);\n    pot[0]=1e8;\n    queue<int> que;\n    for(int i=1;i<n;i++){\n        pot[i]=g[i].size();\n        if(pot[i]==1){\n            que.push(i);\n            leaf[i]=true;\n        }\n    }\n    auto givew=w;\n    while(!que.empty()){\n        int v=que.front(); que.pop();\n        for(int i=0;i<g[v].size();i++){\n            if(leaf[g[v][i]]) continue;\n            pot[g[v][i]]--;\n            givew[g[v][i]]+=givew[v];\n            if(pot[g[v][i]]==1){\n                que.push(g[v][i]);\n                leaf[g[v][i]]=true;\n            }\n        }\n    }\n    int res=0;\n    int maxLeaf=0;\n    for(int i=0;i<n;i++){\n        if(leaf[i]){\n            maxLeaf=max(maxLeaf,givew[i]);\n        }\n        else{\n            res+=w[i];\n        }\n    }\n    cout<<res+maxLeaf<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n,m;\nvector<int>e[100005];\nvector<int>edge[100005];\nint used[100005];\nint w[100005],k;\nvector<int>E[100005];\nll W[100005];\nint in[100005];\nll dp[100005];\nint cnt[100005],c[100005];\nint par[100005],ran[100005];\nll ans,add;\nvoid init(){ for(int i=0;i<100005;i++) par[i] = i; }\nint find(int x){ if(x == par[x]) return x; else return par[x] = find(par[x]); }\nvoid unite(int x,int y){\n\tx = find(x); y = find(y); if(x==y) return;\n\tif(ran[x] < ran[y]) par[x] = y;\n\telse{\n\t\tpar[y] = x;\n\t\tif(ran[x] == ran[y]) ran[x]++;\n\t}\n}\nbool same(int x,int y){ return find(x)==find(y); }\nvoid dfs(int v,int u,int d){\n\tused[v] = d;//cout << v << endl;\n\tfor(int i=0;i<e[v].size();i++){\n\t\tif(e[v][i] == u) continue;\n\t\tif(used[e[v][i]] && used[e[v][i]] < used[v]){\n\t\t\tcnt[e[v][i]]--;\n\t\t\tcnt[v]++;\n\t\t\tunite(e[v][i],v);\n\t\t\t//cout << v << \" \" << e[v][i] << endl;\n\t\t\tcontinue;\n\t\t}\n\t\telse if(used[e[v][i]]) continue;\n\t\tdfs(e[v][i],v,d+1); edge[v].pb(e[v][i]);edge[e[v][i]].pb(v); //cout << v << \" \" << e[v][i] << endl;\n\t}\n}\nint dfs2(int v,int u){\n\tint sum = 0;\n\tfor(int i=0;i<edge[v].size();i++){\n\t\tif(edge[v][i] == u) continue;\n\t\tint a = dfs2(edge[v][i],v);\n\t\tif(a>0){\n\t\t    //cout << edge[v][i] << \" f\" << v << endl;\n\t\t\tunite(edge[v][i],v);\n\t\t}\n\t\tsum += a;\n\t}\n\tsum += cnt[v];\n\treturn sum;\n}\npair<ll,bool> dfs3(int v,int p){\n\tll ret = 0; bool ok = (c[v] >= 3);\n\tfor(int i=0;i<E[v].size();i++){\n\t\tif(E[v][i] == p) continue;\n\t\tpair<ll,bool> t = dfs3(E[v][i],v);\n\t\tret = max(ret,t.fi);\n\t\tok |= t.sc;\n\t}\n\tif(ok){\n\t\tret = 0;\n\t\tans += W[v];\n\t\t//cout << v << endl;\n\t}\n\telse ret += W[v];\n\tadd = max(add,ret);\n\treturn mp(ret,ok);\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=0;i<n;i++) scanf(\"%d\",&w[i]);\n\tfor(int i=0;i<m;i++){\n\t\tint a,b; scanf(\"%d%d\",&a,&b); a--; b--;\n\t\te[a].push_back(b);\n\t\te[b].push_back(a);\n\t}\n\tinit(); dfs(0,-1,1); dfs2(0,-1);\n\tfor(int i=0;i<n;i++){\n\t\tW[find(i)] += w[i];\n\t\tc[find(i)] ++;\n\t\tfor(int j=0;j<e[i].size();j++){\n\t\t\tif(find(i) != find(e[i][j])){\n\t\t\t\tE[find(i)].pb(find(e[i][j]));\n\t\t\t\tE[find(e[i][j])].pb(find(i));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tSORT(E[i]); ERASE(E[i]);\n\t}\n\tdfs3(find(0),-1);\n\tcout << ans+add << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_V 100000\nusing namespace std;\nint n,m,w[100001];\nvector<int> v[100001],v1[100001];\nunodered_set<int> st[100001];\nint V;\nvector<int> G[MAX_V];\nvector<int> rG[MAX_V];\nvector<int> vs;\nbool used[MAX_V];\nint cmp[MAX_V];\n\nvoid DFS(int p){\n  for(int i=0;i<v[p].size();i++){\n    int mn=min(v[p][i],p),mx=max(v[p][i],p);\n    if(st[mn].find(mx)==st[mn].end()){\n      st[mn].insert(mx);\n      G[p].push_back(v[p][i]);\n      rG[v[p][i]].push_back(p);\n      DFS(v[p][i]);\n    }\n  }\n}\n\nvoid dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++)if(!used[G[v][i]])dfs(G[v][i]);\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v]=true;\n  cmp[v]=k;\n  for(int i=0;i<rG[v].size();i++)if(!used[rG[v][i]])rdfs(rG[v][i],k);\n}\n\nint scc(){\n  memset(used,0,sizeof(used));\n  vs.clear();\n  for(int v=0;v<V;v++)if(!used[v])dfs(v);\n  memset(used,0,sizeof(used));\n  int k=0;\n  for(int i=vs.size()-1;i>=0;i--)if(!used[vs[i]])rdfs(vs[i],k++);\n  return k;\n}\n\nint C[100001],F[100001],U[100001],ans;\nbool UU[100001];\n\nbool DFS1(int p){\n  if(U[p])return 0;\n  U[p]=1;\n  bool f=F[cmp[p]]>=2;\n  for(int i=0;i<G[p].size();i++)\n    f=max(f,DFS1(G[p][i]));\n  ans+=w[p]*f;\n  return UU[p]=f;\n}\n\nint DFS2(int p){\n  if(UU[p])return 0;\n  UU[p]=1;\n  int res=0;\n  for(int i=0;i<v[p].size();i++)\n    res+=DFS2(v[p][i]);\n  return w[p]+res;\n}\n\nint main(){\n  cin>>V>>m;\n  for(int i=0;i<V;i++)cin>>w[i];\n  for(int j=0,a,b;j<m;j++){\n    cin>>a>>b;a--,b--;\n    v[a].push_back(b),v[b].push_back(a);\n  }\n  DFS(0);\n  scc();\n  for(int i=0;i<V;i++)F[cmp[i]]++;\n  DFS1(0);\n  int mx=0;\n  for(int i=0;i<V;i++)\n    if(!UU[i])mx=max(mx,DFS2(i));\n  cout<<ans+mx<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_V 100000\nusing namespace std;\nint n,m,w[100001];\nvector<int> v[100001],v1[100001];\nunodered_set<int> st[100001];\nint V;\nvector<int> G[MAX_V];\nvector<int> rG[MAX_V];\nvector<int> vs;\nbool used[MAX_V];\nint cmp[MAX_V];\n\nvoid DFS(int p){\n  for(int i=0;i<v[p].size();i++){\n    int mn=min(v[p][i],p),mx=max(v[p][i],p);\n    if(st[mn].find(mx)==st.end()){\n      st[mn].insert(mx);\n      G[p].push_back(v[p][i]);\n      rG[v[p][i]].push_back(p);\n      DFS(v[p][i]);\n    }\n  }\n}\n\nvoid dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++)if(!used[G[v][i]])dfs(G[v][i]);\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v]=true;\n  cmp[v]=k;\n  for(int i=0;i<rG[v].size();i++)if(!used[rG[v][i]])rdfs(rG[v][i],k);\n}\n\nint scc(){\n  memset(used,0,sizeof(used));\n  vs.clear();\n  for(int v=0;v<V;v++)if(!used[v])dfs(v);\n  memset(used,0,sizeof(used));\n  int k=0;\n  for(int i=vs.size()-1;i>=0;i--)if(!used[vs[i]])rdfs(vs[i],k++);\n  return k;\n}\n\nint C[100001],F[100001],U[100001],ans;\nbool UU[100001];\n\nbool DFS1(int p){\n  if(U[p])return 0;\n  U[p]=1;\n  bool f=F[cmp[p]]>=2;\n  for(int i=0;i<G[p].size();i++)\n    f=max(f,DFS1(G[p][i]));\n  ans+=w[p]*f;\n  return UU[p]=f;\n}\n\nint DFS2(int p){\n  if(UU[p])return 0;\n  UU[p]=1;\n  int res=0;\n  for(int i=0;i<v[p].size();i++)\n    res+=DFS2(v[p][i]);\n  return w[p]+res;\n}\n\nint main(){\n  cin>>V>>m;\n  for(int i=0;i<V;i++)cin>>w[i];\n  for(int j=0,a,b;j<m;j++){\n    cin>>a>>b;a--,b--;\n    v[a].push_back(b),v[b].push_back(a);\n  }\n  DFS(0);\n  scc();\n  for(int i=0;i<V;i++)F[cmp[i]]++;\n  DFS1(0);\n  int mx=0;\n  for(int i=0;i<V;i++)\n    if(!UU[i])mx=max(mx,DFS2(i));\n  \n  cout<<ans+mx<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <map>\nusing namespace std;\nusing pii = pair<int, int>;\n\nstruct Graph {\n    Graph(const int n)\n    {\n        edge.resize(n);\n        revedge.resize(n);\n    }\n    void addEdge(const int from, const int to)\n    {\n        edge[from].push_back(to);\n        revedge[to].push_back(from);\n    }\n    vector<vector<int>> edge;\n    vector<vector<int>> revedge;\n};\n\nvoid depth_dfs(const Graph& g, Graph& dig, map<pii, int>& diedge, map<pii, int>& resedge, const int s, vector<int>& depth, vector<bool>& used, const int deg)\n{\n    depth[s] = deg;\n    for (const int to : g.edge[s]) {\n        if (not used[to]) {\n            used[to] = true;\n            dig.addEdge(s, to);\n            diedge[make_pair(s, to)] = 0;\n            resedge.erase(make_pair(s, to));\n            resedge.erase(make_pair(to, s));\n            depth_dfs(g, dig, diedge, resedge, to, depth, used, deg + 1);\n        }\n    }\n}\n\nvoid accum(const Graph& dig, const int s, map<pii, int>& diedge)\n{\n    for (const int to : dig.edge[s]) {\n        int sum = 0;\n        accum(dig, to, diedge);\n        for (const int to2 : dig.edge[to]) {\n            sum += diedge[make_pair(to, to2)];\n        }\n        diedge[make_pair(s, to)] += sum;\n    }\n}\n\nvoid cc_dfs(const Graph& newg, const int s, vector<int>& comp, vector<bool>& visited, const int cnum)\n{\n    visited[s] = true;\n    comp[s] = cnum;\n    for (const int to : newg.edge[s]) {\n        cc_dfs(newg, to, comp, visited, cnum);\n    }\n}\n\nvoid decomp(const Graph& dig, Graph& decomped, const int s, const vector<int>& comp, set<pii>& decomped_edge)\n{\n    const int c1 = comp[s];\n    for (const int to : dig.edge[s]) {\n        decomp(dig, decomped, to, comp, decomped_edge);\n        const int c2 = comp[to];\n        if (c1 != c2 and decomped_edge.find(make_pair(c1, c2)) == decomped_edge.end()) {\n            decomped_edge.insert(make_pair(c1, c2));\n            decomped.addEdge(c1, c2);\n        }\n    }\n}\n\nint weight_dfs(const Graph& decomped, const int s, const vector<int>& weight)\n{\n    int maxi = 0;\n    for (const int to : decomped.edge[s]) {\n        maxi = max(maxi, weight_dfs(decomped, to, weight));\n    }\n    return weight[s] + maxi;\n}\n\nint main()\n{\n    int N, M;\n    cin >> N >> M;\n    Graph g(N);\n    vector<int> w(N);\n    for (int i = 0; i < N; i++) {\n        cin >> w[i];\n    }\n    map<pii, int> edges;\n    for (int i = 0; i < M; i++) {\n        int u, v;\n        cin >> u >> v;\n        u--, v--;\n        g.addEdge(u, v);\n        g.addEdge(v, u);\n        edges[make_pair(u, v)] = 0;\n        edges[make_pair(v, u)] = 0;\n    }\n    Graph dig(N);\n    map<pii, int> diedge;\n    map<pii, int> resedge = edges;\n    vector<int> depth(N, 0);\n    vector<bool> used(N, false);\n    used[0] = true;\n    depth_dfs(g, dig, diedge, resedge, 0, depth, used, 0);\n    map<pii, int> resedge_ = resedge;\n    resedge.clear();\n    for (const auto& e : resedge_) {\n        const int u = e.first.first;\n        const int v = e.first.second;\n        if (resedge.find(make_pair(v, u)) == resedge.end()) {\n            resedge[make_pair(u, v)] = 0;\n        }\n    }\n    for (const auto& e : resedge) {\n        const int u = e.first.first;\n        const int v = e.first.second;\n        int a;\n        int b;\n        if (depth[u] < depth[v]) {\n            b = u;\n            a = v;\n        } else {\n            b = v;\n            a = u;\n        }\n        if (not dig.revedge[b].empty()) {\n            const int par = dig.revedge[b][0];\n            diedge[make_pair(par, b)]--;\n        }\n        const int par = dig.revedge[a][0];\n        diedge[make_pair(par, a)]++;\n    }\n    vector<int> node(N, 0);\n    accum(dig, 0, diedge);\n    Graph newg(N);\n    for (const auto& e : diedge) {\n        if (e.second != 0) {\n            const int u = e.first.first;\n            const int v = e.first.second;\n            newg.addEdge(u, v);\n        }\n    }\n    vector<bool> visited(N, false);\n    vector<int> comp(N, 0);\n    int cnum = 0;\n    for (int i = 0; i < N; i++) {\n        if (not visited[i]) {\n            cc_dfs(newg, i, comp, visited, cnum);\n            cnum++;\n        }\n    }\n    vector<int> weight(cnum, 0);\n    for (int i = 0; i < N; i++) {\n        const int c = comp[i];\n        weight[c] += w[i];\n    }\n    set<pii> decomped_edge;\n    Graph decomped(cnum);\n    decomp(dig, decomped, 0, comp, decomped_edge);\n\n    cout << weight_dfs(decomped, 0, weight) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 100000\n\nstruct Info{\n\tInfo(){\n\t\tnode_id = pre_node = sum_value = 0;\n\t}\n\n\tInfo(int arg_node_id,int arg_pre_node,int arg_sum_value){\n\t\tnode_id = arg_node_id;\n\t\tpre_node = arg_pre_node;\n\t\tsum_value = arg_sum_value;\n\t}\n\tbool operator<(const struct Info &arg) const{\n\t\treturn sum_value < arg.sum_value;\n\t}\n\n\tint node_id,pre_node,sum_value;\n};\n\nint N,M;\nint root;\nint value[NUM],in_num[NUM],max_value[NUM];\nbool is_cicle[NUM];\nvector<int> G[NUM];\n\n\n\nint main(){\n\n\tscanf(\"%d %d\",&N,&M);\n\n\tfor(int i = 0; i < N; i++)scanf(\"%d\",&value[i]);\n\n\tfor(int i = 0; i < N; i++)in_num[i] = 0;\n\n\troot = 0;\n\tint from,to;\n\n\tfor(int loop = 0; loop < M; loop++){\n\t\tscanf(\"%d %d\",&from,&to);\n\t\tfrom--;\n\t\tto--;\n\t\tG[from].push_back(to);\n\t\tG[to].push_back(from);\n\t\tin_num[from]++;\n\t\tin_num[to]++;\n\t}\n\n\tfor(int i = 0; i < N; i++)is_cicle[i] = true;\n\n\tqueue<int> CALC;\n\tfor(int i = 1; i < N; i++){\n\t\tif(in_num[i] == 1){\n\t\t\tis_cicle[i] = false;\n\t\t\tCALC.push(i);\n\t\t}\n\t}\n\n\tint node_id;\n\tint next_node,next_value;\n\n\twhile(!CALC.empty()){\n\t\tnode_id = CALC.front();\n\t\tCALC.pop();\n\n\t\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\t\tnext_node = G[node_id][i];\n\t\t\tif(is_cicle[next_node] == false || next_node == root)continue;\n\n\t\t\tin_num[next_node]--;\n\t\t\tif(in_num[next_node] == 1){\n\t\t\t\tis_cicle[next_node] = false;\n\t\t\t\tCALC.push(next_node);\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = value[root];\n\tfor(int i = 1; i < N; i++){\n\t\tif(is_cicle[i]){\n\t\t\tans += value[i];\n\t\t}\n\t}\n\n\tint maximum = 0;\n\tfor(int i = 0; i < N; i++)max_value[i] = 0;\n\n\tpriority_queue<Info> Q;\n\tfor(int i = 0; i < N; i++){\n\t\tif(!is_cicle[i])continue;\n\n\t\tfor(int k = 0; k < G[i].size(); k++){\n\t\t\tnext_node = G[i][k];\n\t\t\tif(is_cicle[next_node])continue;\n\n\t\t\tnext_value = value[next_node];\n\t\t\tif(max_value[next_node] < next_value){\n\t\t\t\tmax_value[next_node] = next_value;\n\t\t\t\tQ.push(Info(next_node,i,next_value));\n\t\t\t}\n\t\t}\n\t}\n\n\tInfo info;\n\twhile(!Q.empty()){\n\n\t\tinfo = Q.top();\n\t\tQ.pop();\n\n\t\tmaximum = max(maximum,info.sum_value);\n\n\t\tif(info.sum_value < max_value[info.node_id]){\n\t\t\tcontinue;\n\t\t}else{\n\t\t\tfor(int i = 0; i < G[info.node_id].size(); i++){\n\t\t\t\tnext_node = G[info.node_id][i];\n\t\t\t\tif(next_node == info.pre_node || is_cicle[next_node] == true)continue;\n\t\t\t\tnext_value = info.sum_value+value[next_node];\n\n\t\t\t\tif(max_value[next_node] < next_value){\n\t\t\t\t\tmax_value[next_node] = next_value;\n\t\t\t\t\tQ.push(Info(next_node,info.node_id,next_value));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",ans+maximum);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i=((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=((int)(b));i>=((int)(a));i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define pque(type) priority_queue<type,vector<type>,greater<type> >\n#define memst(a,b) memset(a,b,sizeof(a))\n#define iter(v,ite) for(auto ite=(v).begin();ite!=(v).end();ite++)\n#define mimunum(v,x) distance((v).begin(),lower_bound((v).begin(),(v).end(),x))\n\n\nint n,m;\nvector<int> vs[100005];\n\nint gb[100005];\nvector<int> gvs[100005];\n\nint dn=0;\nint gn=0;\nint dang[100005]={};\nint gone[100005]={};\n\nint uni[100005];\n\nint find(int p){\n\tif(p==uni[p])return p;\n\telse return (uni[p]=find(uni[p]));\n}\n\nint mer(int p,int q){\n\tp = find(p); q=find(q);\n\tuni[p]=q;\n}\n\nbool same(int p,int q){\n\tp = find(p); q=find(q);\n\treturn p==q;\n}\n\n\n\n\nvoid dfs(int no,int be){\n\tgone[no]=1;\n\trep(i,vs[no].size()){\n\t\tint to=vs[no][i];\n\t\tif(to==be)continue;\n\t\tif(gone[to]){\n\t\t\tdang[to]++;\n\t\t\tdn++;\n\t\t\tcontinue;\n\t\t}\n\t\tint mdn = dn;\n\t\tdfs(to,no);\n\t\tif(mdn!=dn){\n\t\t\t//printf(\"%d %d :: %d %d\\n\",to,no,mdn,dn);\n\t\t\tmer(to,no);\n\t\t}\n\t\tdn -= dang[no];\n\t\tdang[no]=0;\n\t}\n}\n\nint w[100005];\nint gw[100005]={};\n\n\n//lli ans=-1;\n\nlli sol(int no){\n\tgone[no]=1;\n\tlli ma=0;\n\trep(i,gvs[no].size()){\n\t\tint to=gvs[no][i];\n\t\tif(gone[to])continue;\n\t\tlli nm=sol(to);\n\t\tma = max(ma,nm);\n\t}\n\t//ans=max(ans,ma+mb+gw[no]);\n\t//printf(\"%d %lld\\n\",no,ma);\n\treturn ma+gw[no];\n}\n\nint main(void){\n\tscanf(\"%d%d\",&n,&m);\n\trep(i,n)uni[i]=i;\n\trep(i,n)scanf(\"%d\",&w[i]);\n\trep(i,m){\n\t\tint a,b; \n\t\tscanf(\"%d%d\",&a,&b); a--; b--;\n\t\tvs[a].push_back(b);\n\t\tvs[b].push_back(a);\n\t}\n\t\n\tdfs(0,0);\n\t\n\trep(no,n){\n\t\tint ng = find(no);\n\t\trep(i,vs[no].size()){\n\t\t\tint tg=find(vs[no][i]);\n\t\t\tif(ng!=tg){\n\t\t\t\t//printf(\"%d %d\\n\",no,vs[no][i]);\n\t\t\t\tgvs[ng].push_back(tg);\n\t\t\t}\n\t\t}\n\t\tgw[ng] += w[no];\n\t}\n\t\n\tmemst(gone,0);\n\t\n\t\n\tprintf(\"%lld\\n\",sol(find(0)));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<utility>\n#include<set>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define MP make_pair\n#define PB push_back\nusing namespace std;\n\nint n,m;\n\nvoid bfs(int k,vector<int> &cnt,vector<bool>&b,vector<vector<int> > &g){\n    if(cnt[k]==1||cnt[k]==0){\n        b[k] = 0;\n        for(int i:g[k]){\n            if(b[i]){\n                cnt[i]--;\n                bfs(i,cnt,b,g);\n            }\n        }\n    }   \n}\nbool bfs3(int k,int z,vector<bool>&b,vector<vector<int> > &g){\n    if(b[k])return true;\n    for(int x:g[k]){\n        if(x!=z){\n            if(bfs3(x,k,b,g))return b[k]=true;\n        }\n    } \n    return false;\n}\nint bfs2(int k,int z,vector<int>&w,vector<vector<int> > &g){\n    int s=w[k];\n    int mx = 0;\n    for(int x:g[k]){\n        if(x!=z){\n            mx = max(mx,bfs2(x,k,w,g));\n        }\n    }\n    return s+mx;\n}\n\n\nint main(){\n    cin >> n >> m;\n    vector<int> w(n+1);\n    vector<vector<int> > g(n);\n    rep(i,n)cin >> w[i];\n    rep(i,m){\n        int u,v;\n        cin >> u >> v;\n        u--;v--;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    vector<int> cnt(n);\n    rep(i,n){\n        cnt[i] = g[i].size();\n    }\n    vector<bool> b(n,1);\n    rep(i,n){\n        bfs(i,cnt,b,g);\n    }\n    if(b[0]==0){\n        bfs3(0,0,b,g);\n    }\n    vector<int>p;\n    int sm=0;\n    rep(i,n){\n        if(b[i]){\n            p.PB(i);\n            sm+=w[i];\n        }\n    }\n    w[n]=sm;\n    set<int>st;\n    for(int x:p){\n        for(int y:g[x]){\n            st.insert(y);\n        }\n    }\n    vector<vector<int> >g2(n+1);\n    rep(i,n){\n        if(!b[i]){\n            for(int x:g[i]){\n                if(b[x]){\n                    g2[i].PB(n);\n                    g2[n].PB(i);\n                }else{\n                    g2[i].PB(x);\n                }\n            }\n        }\n    }\n    cout << bfs2(n,n,w,g2) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n\n\n\n#define FOR(i,s,t) for(int (i)=(s);(i)<(t);(i)++)\nusing VI = vector<int>;\n/*-----------------------------------------------\n 二辺連結成分分解 成分だけ unverified\n -----------------------------------------------*/\nstruct UnionFind {\n    vector<int> data;\n    UnionFind(int n) { data.assign(n, -1); }\n    bool unionSet(int x, int y) {\n        x = root(x); y = root(y);\n        if (x != y) {\n            if (data[y] < data[x]) swap(x, y);\n            data[x] += data[y]; data[y] = x;\n        }\n        return x != y;\n    }\n    bool same(int x, int y) { return root(x) == root(y); }\n    int root(int x) { return data[x] < 0 ? x : data[x] = root(data[x]); }\n    int size(int x) { return -data[root(x)]; }\n};\n\n/* ---------------------------------\n Library:     Lowlink dfs\n Complexity:  O(V+E)\n Description: dfs木を作る過程で、巡回順ord,判定lowを更新\n 先にkを宣言して使う(grovalに置かないだけ)\n Art_Points()と一緒に使うことで橋と関節点を列挙可能\n Usege:       k=0, lowlink(0,-1,k,low,ord,used,G)\n Decision:    if(ord[v] < low[u]) (u, v) is a bridge\n if(v == root) if(nG[v].size() > 1) at  is an articulation point 根に2つ以上あれば\n else if(ord[v] <= low[u]) at  is an articulation point\n Variables:   v: nowV, p: preV, k: timer, ord: dfs order, low: lowlink, used: visited?, parent: parent.\n return:      なし\n Memo:        最小全域点カットが2以上とは関節点が存在しないことと同義\n --------------------------------- */\n\nstruct Lowlink {\n    UnionFind uf;\n    vector<int> low, ord, used, parent;\n    int root, k;\n    Lowlink(int V, int Root) :uf(V), low(V), ord(V), used(V), parent(V), root(Root), k(0) {}\n    \n    void lowlink(int v, int p, int &k, vector<vector<int>>& G) {\n        used[v] = true; //visited\n        low[v] = ord[v] = k; k++;\n        for (int i = 0; i < (int)G[v].size(); i++) {\n            int u = G[v][i];\n            if (used[u] == 0) {\n                parent[u] = v;\n                lowlink(u, v, k, G);\n                low[v] = min(low[v], low[u]);\n                if (ord[v] >= low[u])uf.unionSet(v, u);\n            }\n            else if (u != p) {\n                low[v] = min(low[v], ord[u]);\n            }\n        }\n    }\n};\n/* ---------------------------------\n Library:     TwoEdgeConnectedComponent\n Complexity:  O(V+E)\n Description: 二辺連結成分分解(2より小さい数の辺を取り除いても連結であるようなグラフ->橋を含まない部分グラフ)\n Usege:       TwoEdgeConnectedComponent(G,points,bridges)\n Decision:    判定はlowlinkを参照\n Variables:   ,\n Memo:        need LowLink\n --------------------------------- */\nusing LL = long long;\nusing PLL = pair<LL, LL>;\nstruct TwoEdgeConnectedComponent : Lowlink {\n    vector<pair<int, int> > edges;\n    vector<int> comp; // components\n    TwoEdgeConnectedComponent(int V, int Root) :Lowlink(V, Root), comp(V) {}\n    \n    void get_graph(vector<vector<int> >& ResGraph, vector<vector<int> >& G, VI& w, VI& compW) {\n        Lowlink::lowlink(root, -1, k, G);\n        int ptr = 0;\n        vector<int> color((int)G.size());\n        for (int i = 0; i < (int)G.size(); i++) {\n            if (i == uf.root(i))color[i] = ptr++;\n        }\n        ResGraph.resize(ptr);\n        compW.resize(ptr);\n        for (int i = 0; i < (int)G.size(); i++) {\n            comp[i] = color[uf.root(i)];\n            // 頂点番号における写像を作る\n            compW[comp[i]] += w[i];//重みをまとめる\n        }\n        for (int v = 0; v < (int)G.size(); v++) {// O(E)\n            for (int i = 0; i < (int)G[v].size(); i++) {\n                int u = G[v][i];\n                int c1 = comp[v], c2 = comp[u];\n                if (c1 == c2)continue;// 異なる成分に辺をはる\n                ResGraph[c1].push_back(c2);\n                ResGraph[c2].push_back(c1);\n            }\n        }\n    }\n};\n\n#define SZ(a) (int)a.size()\nusing VVI = vector<VI>;\nusing VL = vector<LL>;\nLL dfs(int v, int p, VVI& G, VL& dp, VI& w) {\n    \n    LL res = 0;\n    FOR(i, 0, SZ(G[v])) {\n        int nx = G[v][i];\n        if (nx == p)continue;\n        res = max(res, dfs(nx, v, G, dp, w));\n    }\n    return dp[v] = res + w[v];\n}\n\n\nint main() {\n    int N, M; cin >> N >> M;\n    VI w(N);\n    FOR(i, 0, N) {\n        cin >> w[i];\n    }\n    \n    vector<VI>G(N);\n    FOR(i, 0, M) {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;;\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n    // 木にする このときに頂点に重みを集結させる\n    TwoEdgeConnectedComponent gx(SZ(G), 0);\n    vector<vector<int>>resG;\n    VI resW;\n    gx.get_graph(resG, G, w, resW); // new Graph id -> w[id]でできる\n    //ここまでCC\n    \n    // ここから木DP\n    // pathを選択\n    VL dp(N, 0);\n    LL ans = dfs(0, -1, resG, dp, resW);\n    cout << ans << endl;\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n\nusing VS = vector<string>;    using LL = long long;\nusing VI = vector<int>;       using VVI = vector<VI>;\nusing PII = pair<int, int>;   using PLL = pair<LL, LL>;\nusing VL = vector<LL>;        using VVL = vector<VL>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n#define FOR(i, s, e) for (int(i) = (s); (i) < (e); (i)++)\n#define FORR(i, s, e) for (int(i) = (s); (i) > (e); (i)--)\n#define debug(x) cerr << #x << \": \" << x << endl\nconst int INF = 1e9;                          const LL LINF = 1e16;\nconst LL MOD = 1000000007;                    const double PI = acos(-1.0);\nint DX[8] = { 0, 0, 1, -1, 1, 1, -1, -1 };    int DY[8] = { 1, -1, 0, 0, 1, -1, 1, -1 };\n\n/*-----------------------------------------------\n 二辺連結成分分解 成分だけ unverified\n -----------------------------------------------*/\nstruct UnionFind {\n    vector<int> data;\n    UnionFind(int n) { data.assign(n, -1); }\n    bool unionSet(int x, int y) {\n        x = root(x); y = root(y);\n        if (x != y) {\n            if (data[y] < data[x]) swap(x, y);\n            data[x] += data[y]; data[y] = x;\n        }\n        return x != y;\n    }\n    bool same(int x, int y) { return root(x) == root(y); }\n    int root(int x) { return data[x] < 0 ? x : data[x] = root(data[x]); }\n    int size(int x) { return -data[root(x)]; }\n};\n\nstruct Lowlink {\n    UnionFind uf;\n    vector<int> low, ord, used, parent;\n    int root, k;\n    Lowlink(int V, int Root) :uf(V), low(V), ord(V), used(V), parent(V), root(Root), k(0) {}\n    \n    void lowlink(int v, int p, int &k, vector<vector<int>>& G) {\n        used[v] = true; //visited\n        low[v] = ord[v] = k; k++;\n        for (int i = 0; i < (int)G[v].size(); i++) {\n            int u = G[v][i];\n            if (used[u] == 0) {\n                parent[u] = v;\n                lowlink(u, v, k, G);\n                low[v] = min(low[v], low[u]);\n                if (ord[v] >= low[u])uf.unionSet(v, u);\n            }\n            else if (u != p) {\n                low[v] = min(low[v], ord[u]);\n            }\n        }\n    }\n};\n\nstruct TwoEdgeConnectedComponent{\n    UnionFind uf;\n    vector<vector<int>> g;\n    vector<pair<int, int>> edges;\n    vector<int> used, ord, low, comp;\n    int v;\n    TwoEdgeConnectedComponent(int v) : uf(v), g(v), used(v, 0), comp(v), ord(v), low(v),v(v) {}\n    \n    void add_edge(int x, int y) {\n        g[x].push_back(y);\n        g[y].push_back(x);\n        edges.push_back(minmax(x, y));\n    }\n    \n    void dfs(int idx, int& k, int par = -1) {\n        used[idx] = true;\n        ord[idx] = k++;\n        low[idx] = ord[idx];\n        \n        for (auto &to : g[idx]) {\n            if (!used[to]) {\n                dfs(to, k, idx);\n                low[idx] = min(low[idx], low[to]);\n                if (ord[idx] >= low[to]) uf.unionSet(idx, to);\n            }\n            else if (to != par) {\n                low[idx] = min(low[idx], ord[to]);\n            }\n        }\n    }\n    \n    // return origin color\n    int operator[](int k) {\n        return (comp[k]);\n    }\n    \n    int size() {\n        return (g.size());\n    }\n    \n    // build, renew resG(empty -> tree), return color\n    vector<int> get_graph(vector<vector<int>>& resG, int root = 0) {\n        int kk = 0;\n//        dfs(root, kk);\n        Lowlink Low(v,0);\n        Low.lowlink(root, -1, kk, g);\n        auto uf = Low.uf;\n        int ptr = 0;\n        vector<int> color(g.size());\n        for (int i = 0; i < g.size(); i++) {\n            if (i == uf.root(i)) color[i] = ptr++;\n        }\n        \n        resG.resize(ptr);\n        for (int i = 0; i < g.size(); i++) {\n            comp[i] = color[uf.root(i)];\n        }\n        for (auto &e : edges) {\n            int x = comp[e.first], y = comp[e.second];\n            if (x == y) continue;\n            resG[x].push_back(y);\n            resG[y].push_back(x);\n        }\n        return comp;\n    }\n};\n\nint N, M, W[100000];\nvector<vector<int>> resG;\nvector<int> weightSum, sz;\nint dp1[100000], dp3[100000];\n\nint rec(int idx, int par = -1)\n{\n    int ret = 0;\n    for (auto &to : resG[idx]) {\n        if (to == par) continue;\n        ret = max(ret, rec(to, idx));\n        dp1[idx] += dp1[to];\n    }\n    ret += weightSum[idx];\n    if (sz[idx] >= 3 || dp1[idx] > 0) dp1[idx] += weightSum[idx];\n    for (auto &to : resG[idx]) {\n        if (to == par) continue;\n        else ret = max(ret, dp1[idx] - dp1[to] + dp3[to]);\n    }\n    return (dp3[idx] = ret);\n}\n\n// 三点以上集まった頂点ならば、ここを起点にもどることができる。\n// dp1[v]:vから葉まで進むときの最大値\n// dp3[v]:vに戻ってくるときの最大値\nvoid f(int v, int p = -1) {\n    for (int nx : resG[v]) {\n        if (nx == p)continue;\n        f(nx, v);\n        dp1[v] += dp1[nx];\n    }\n    int ret = dp1[v];\n    if (dp1[v] || sz[v] > 1)dp1[v] += weightSum[v];\n    for (int nx : resG[v]) {\n        if (nx == p)continue;\n        dp3[v] = max(dp3[v], ret - dp1[nx] + dp3[nx]);\n    }\n    dp3[v] += weightSum[v];\n}\n\nint main() {\n    int N, M; cin >> N >> M;\n    FOR(i, 0, N) {\n        cin >> W[i];\n    }\n    TwoEdgeConnectedComponent gx(N);\n    \n    FOR(i, 0, M) {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        gx.add_edge(a, b);\n    }\n    VI vc = gx.get_graph(resG);\n    \n    weightSum.assign(resG.size(), 0);\n    sz.assign(resG.size(), 0);\n    for (int i = 0; i < N; i++) {\n        weightSum[vc[i]] += W[i];\n        sz[vc[i]]++;\n    }\n    f(vc[0]);\n    LL ans = dp3[vc[0]];\n    cout << ans << endl;\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n,m;\nvector<int>e[100005];\nvector<int>edge[100005];\nint used[100005];\nint w[100005],k;\nvector<int>E[100005];\nll W[100005];\nint in[100005];\nll dp[100005];\nint cnt[100005],c[100005];\nint par[100005],ran[100005];\nvoid init(){ for(int i=0;i<100005;i++) par[i] = i; }\nint find(int x){ if(x == par[x]) return x; else return par[x] = find(par[x]); }\nvoid unite(int x,int y){\n\tx = find(x); y = find(y); if(x==y) return;\n\tif(ran[x] < ran[y]) par[x] = y;\n\telse{\n\t\tpar[y] = x;\n\t\tif(ran[x] == ran[y]) ran[x]++;\n\t}\n}\nbool same(int x,int y){ return find(x)==find(y); }\nvoid dfs(int v,int u,int d){\n\tused[v] = d;//cout << v << endl;\n\tfor(int i=0;i<e[v].size();i++){\n\t\tif(e[v][i] == u) continue;\n\t\tif(used[e[v][i]] && used[e[v][i]] < used[v]){\n\t\t\tcnt[e[v][i]]--;\n\t\t\tcnt[v]++;\n\t\t\tunite(e[v][i],v);\n\t\t\t//cout << v << \" \" << e[v][i] << endl;\n\t\t\tcontinue;\n\t\t}\n\t\telse if(used[e[v][i]]) continue;\n\t\tdfs(e[v][i],v,d+1); edge[v].pb(e[v][i]); //cout << v << \" \" << e[v][i] << endl;\n\t}\n}\nint dfs2(int v,int u){\n\tint sum = 0;\n\tfor(int i=0;i<edge[v].size();i++){\n\t\tint a = dfs2(edge[v][i],v);\n\t\tif(a>0){\n\t\t    //cout << edge[v][i] << \" f\" << v << endl;\n\t\t\tunite(edge[v][i],v);\n\t\t}\n\t\tsum += a;\n\t}\n\tsum += cnt[v];\n\treturn sum;\n}\n\nint sum = 0;\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=0;i<n;i++) scanf(\"%d\",&w[i]);\n\tfor(int i=0;i<m;i++){\n\t\tint a,b; scanf(\"%d%d\",&a,&b); a--; b--;\n\t\te[a].push_back(b);\n\t\te[b].push_back(a);\n\t}\n\tinit(); dfs(0,-1,1); dfs2(0,-1);\n\tfor(int i=0;i<n;i++){\n\t\tW[find(i)] += w[i];\n\t\tc[find(i)] ++;\n\t\tsum += w[i];\n\t\tfor(int j=0;j<e[i].size();j++){\n\t\t\tif(find(i) != find(e[i][j])){\n\t\t\t\tE[find(i)].pb(find(e[i][j]));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tSORT(E[i]); ERASE(E[i]);\n\t}\n\tint MX = 0;\n\tfor(int i=0;i<n;i++){\n\t\tif(E[i].size() == 1 && c[i] == 1){\n\t\t\tMX = max(MX,w[i]);\n\t\t\tsum-=w[i];\n\t\t}\n\t}\n\tcout << sum+MX << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_V 100000\nusing namespace std;\nint m,w[100001];\nvector<int> vv[100001];\nunordered_set<int> st[100001];\nint V;\nvector<int> G[MAX_V];\nvector<int> rG[MAX_V];\nvector<int> vs;\nbool used[MAX_V];\nint cmp[MAX_V];\nint C[100001],F[100001],U[100001],ans;\nbool UU[100001];\n\n\nvoid DFS(int p){\n  for(int i=0;i<vv[p].size();i++){\n    int mn=min(vv[p][i],p),mx=max(vv[p][i],p);\n    if(st[mn].find(mx)==st[mn].end()){\n      st[mn].insert(mx);\n      G[p].push_back(vv[p][i]);\n      rG[vv[p][i]].push_back(p);\n      DFS(vv[p][i]);\n    }\n  }\n}\n\nvoid dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++)if(!used[G[v][i]])dfs(G[v][i]);\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v]=true;\n  cmp[v]=k;\n  for(int i=0;i<rG[v].size();i++)if(!used[rG[v][i]])rdfs(rG[v][i],k);\n}\n\nint scc(){\n  memset(used,0,sizeof(used));\n  vs.clear();\n  for(int v=0;v<V;v++)if(!used[v])dfs(v);\n  memset(used,0,sizeof(used));\n  int k=0;\n  for(int i=vs.size()-1;i>=0;i--)if(!used[vs[i]])rdfs(vs[i],k++);\n  return k;\n}\n\nbool DFS1(int p){\n  if(U[p])return 0;\n  U[p]=1;\n  bool f=F[cmp[p]]>=2;\n  for(int i=0;i<G[p].size();i++)\n    f|=DFS1(G[p][i]);\n  ans+=w[p]*f;\n  return UU[p]=f;\n}\nbool UUU[100001];\nint DFS2(int p){\n  if(UUU[p])return 0;\n  UUU[p]=1;\n  int res=0;\n  \n  for(int i=0;i<G[p].size();i++)\n    res=max(res,DFS2(G[p][i]));  \n  return res+(UU[p]?0:w[p]);\n}\n\nint main(){\n  cin>>V>>m;\n  for(int i=0;i<V;i++)cin>>w[i];\n  for(int j=0,a,b;j<m;j++){\n    cin>>a>>b;a--,b--;\n    vv[a].push_back(b),vv[b].push_back(a);\n  }\n  DFS(0);\n  int t=0;\n  for(int i=0;i<V;i++)t+=w[i];\n  scc();\n  for(int i=0;i<V;i++)F[cmp[i]]++;\n  DFS1(0);\n  cout<<ans+DFS2(0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_V 100000\nusing namespace std;\ntypedef pair<int,int> P;\nint n,m,w[100001];\nvector<int> v[100001],v1[100001];\nset<P> st;\nint V;\nvector<int> G[MAX_V];\nvector<int> rG[MAX_V];\nvector<int> vs;\nbool used[MAX_V];\nint cmp[MAX_V];\n\nvoid DFS(int p){\n  for(int i=0;i<v[p].size();i++){\n    P pp=P(min(v[p][i],p),max(v[p][i],p));\n    if(st.find(pp)==st.end()){\n      st.insert(pp);\n      G[p].push_back(v[p][i]);\n      rG[v[p][i]].push_back(p);\n      DFS(v[p][i]);\n    }\n  }\n}\n\nvoid dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++)if(!used[G[v][i]])dfs(G[v][i]);\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v]=true;\n  cmp[v]=k;\n  for(int i=0;i<rG[v].size();i++)if(!used[rG[v][i]])rdfs(rG[v][i],k);\n}\n\nint scc(){\n  memset(used,0,sizeof(used));\n  vs.clear();\n  for(int v=0;v<V;v++)if(!used[v])dfs(v);\n  memset(used,0,sizeof(used));\n  int k=0;\n  for(int i=vs.size()-1;i>=0;i--)if(!used[vs[i]])rdfs(vs[i],k++);\n  return k;\n}\n\nint C[100001],F[100001],U[100001],ans;\nbool UU[100001];\n\nbool DFS1(int p){\n  if(U[p])return 0;\n  U[p]=1;\n  bool f=F[cmp[p]]>=2;\n  for(int i=0;i<G[p].size();i++)\n    f=max(f,DFS1(G[p][i]));\n  ans+=w[p]*f;\n  return UU[p]=f;\n}\n\nint DFS2(int p){\n  if(UU[p])return 0;\n  UU[p]=1;\n  int res=0;\n  for(int i=0;i<v[p].size();i++)\n    res+=DFS2(v[p][i]);\n  return w[p]+res;\n}\n\nint main(){\n  cin>>V>>m;\n  for(int i=0;i<V;i++)cin>>w[i];\n  for(int j=0,a,b;j<m;j++){\n    cin>>a>>b;a--,b--;\n    v[a].push_back(b),v[b].push_back(a);\n  }\n  DFS(0);\n  scc();\n  for(int i=0;i<V;i++)F[cmp[i]]++;\n  DFS1(0);\n  int mx=0;\n  for(int i=0;i<V;i++)\n    if(!UU[i])mx=max(mx,DFS2(i));\n  \n  cout<<ans+mx<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#define INF 200000000\n\nusing namespace std;\nint main(){\n    int N,M;\n    cin >> N >> M;\n    int ans = 0;\n    vector< vector<int> > graph(N);\n    int x,y;\n    vector<int> weight(N);\n    for(int i=0; i< N; i++){\n        cin >> weight[i];\n        ans += weight[i];\n    }\n\n    for(int i=0; i<M ; i++){\n        cin >> x >> y;\n        x--; y--;\n        graph[x].push_back(y);\n        graph[y].push_back(x);\n    }\n    int thePath = 0;\n    bool isChecked = false;\n    int sonoPath = 0;\n    int count = 0;\n    int ssum = 0;\n    int fst=-1,scd=-1;\n    for(int i=0; i<N ; i++){\n        if(graph[i].size()!=1)continue;\n        count++;\n        bool inPath = false;\n        int prev=i;\n        int next = graph[i][0];\n        int now;\n        int sum = weight[i];\n        for(;graph[next].size()==2;){\n            if(prev==0 && !isChecked) inPath = true;\n            if(inPath) thePath += weight[prev];\n            sum += weight[next];\n            if(graph[next][0] == prev){\n                now = next;\n                next = graph[next][1];\n                prev = now;\n            }else{\n                now = next;\n                next = graph[next][1];\n                prev = now;\n            }\n        }\n        if(prev==0 && !isChecked) inPath = true;\n        if(inPath) {\n            isChecked = true;\n            thePath += weight[prev];\n            sonoPath = sum - thePath +weight[i];\n        }\n        ssum += sum;\n        if(inPath) continue;\n        if(count == 1){\n            fst = sum;\n        }else if(count == 2){\n            if(sum > fst){\n                scd = fst; fst= sum;\n            }else{\n                scd = sum;\n            }\n        }else{\n            if(sum > fst){\n                scd = fst; fst = sum;\n            } else if( sum > scd){\n                scd = sum;\n            }\n        }\n    }\n    if(thePath == 0){\n        if(count <= 1 ){\n            cout << ans << endl; \n        }else{\n            cout << ans - ssum + fst << endl;\n        }\n    } else {\n        if(count == 1){\n            cout << max(ans - ssum + thePath,sonoPath) << endl;\n        }else{\n            cout << max(ans - ssum + fst + thePath,sonoPath) << endl;\n        }\n\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define MAX_V 114514\ntypedef pair<int,int> P;\nvector<vector<int> > G,C,T;\nvector<int> ord,low,belong;\nvector<P> B;\nint V;\nbool is_bridge(int u,int v){\n  if(ord[u]>ord[v]) swap(u,v);\n  return ord[u]<low[v];\n}\nvoid dfs(int u,int p,int &k){\n  ord[u]=low[u]=k;\n  ++k;\n  for(int v:G[u]){\n    if(v==p) continue;\n    if(ord[v]>=0){\n      low[u]=min(low[u],ord[v]);\n    }else{\n      dfs(v,u,k);\n      low[u]=min(low[u],low[v]);\n    }\n    if(is_bridge(u,v)) B.push_back(P(u,v));\n  }\n}\nvoid fill_component(int c,int u){\n  C[c].push_back(u);\n  belong[u]=c;\n  for(int v:G[u]){\n    if(belong[v]>=0||is_bridge(u,v)) continue;\n    fill_component(c,v);\n  }\n}\nvoid add_component(int u){\n  if(belong[u]>=0) return;\n  C.emplace_back();\n  fill_component(C.size()-1,u);\n}\n\nvoid biconnectedgraph(int n){\n  int k=0;\n  ord.clear();\n  ord.resize(n,-1);\n  low.clear();\n  low.resize(n);\n  belong.clear();\n  belong.resize(n,-1);\n  for(int u=0;u<n;u++){\n    if(ord[u]>=0) continue;\n    dfs(u,-1,k);\n  }\n  C.clear();\n  for(int i=0;i<(int)B.size();i++){\n    add_component(B[i].first);\n    add_component(B[i].second);\n  }\n  add_component(0);\n  V=C.size();\n  T.clear();\n  T.resize(V);\n  for(int i=0;i<(int)B.size();i++){\n    int u=belong[B[i].first],v=belong[B[i].second];\n    T[u].push_back(v);\n    T[v].push_back(u);\n  }\n}\n\nvoid add_edge(int u,int v){\n  G[u].push_back(v);\n  G[v].push_back(u);\n}\n\nint wei[MAX_V],memo[MAX_V];\nbool used[MAX_V],dele[MAX_V];\nbool flag=0;\nint root;\nint xyz;\nvoid dfs2(int v,int p){\n  used[v]=1;\n  if(v!=root&&(int)C[v].size()>1){\n    if(v==xyz) xyz=root;\n    flag=1;\n    dele[v]=1;\n    for(int k:T[v])\n      T[root].push_back(k);\n    wei[root]+=wei[v];\n    return;\n  }\n  for(int i=0;i<(int)T[v].size();i++){\n    int u=T[v][i];\n    if(u==p) continue;\n    if(used[u]) continue;\n    dfs2(u,v);\n    if(flag){\n      if(~p){\n\tif(v==xyz) xyz=root;\n\tdele[v]=1;\n\tfor(int k:T[v])\n\t  T[root].push_back(k);\n\twei[root]+=wei[v];\n\treturn;\n      }else{\n\tflag=0;\n      }\n    }\n  }\n}\n\nint dfs3(int v,int p){\n  int res=wei[v];\n  for(int u:T[v]){\n    if(dele[u]||u==p) continue;\n    res=max(res,wei[v]+dfs3(u,v));\n  }\n  //if(p==xyz) cout<<v<<\" \"<<res<<endl;\n  return res;\n}\npriority_queue<int> tmp;\nint ans=0;\nbool flag2=0;\nint dfs4(int v,int p){\n  //cout<<v<<\" \"<<p<<endl;\n  if(~memo[v]) return memo[v];\n  if(v==root){\n    flag2=1;\n    ans+=wei[v];\n    for(int u:T[v]) if(u!=p) tmp.push(dfs3(u,v));\n    return 0;\n  }\n  int res=wei[v];\n  for(int u:T[v]){\n    if(dele[u]||u==p) continue;\n    res=max(res,wei[v]+dfs4(u,v));\n    if(flag2){\n      ans+=wei[v];\n      for(int k:T[v])\n\tif(u!=k&&k!=p) tmp.push(dfs3(k,v));\n      break;\n    }\n  }\n  return memo[v]=res;\n}\nsigned main(){\n  int n,m;\n  cin>>n>>m;\n  G.clear();\n  G.resize(n);\n  int w[n];\n  for(int i=0;i<n;i++) cin>>w[i];\n  for(int i=0;i<m;i++){\n    int u,v;\n    cin>>u>>v;\n    u--;v--;\n    add_edge(u,v);\n  }\n  biconnectedgraph(n);\n  root=-1;\n  for(int i=0;i<V;i++){\n    for(int j=0;j<(int)C[i].size();j++){\n      wei[i]+=w[C[i][j]];\n      //w[C[i][j]]=0;\n      if(j>0) root=i;\n      if(C[i][j]==0) xyz=i;\n    }\n    //if(C[i].size()>1) cout<<i<<\" \"<<C[i].size()<<\":\"<<wei[i]<<endl; \n    //cout<<i<<\":\"<<wei[i]<<endl;\n  }\n  //for(int i=0;i<n;i++) assert(!w[i]);\n  //cout<<C[xyz].size()<<\":\";for(int i:C[xyz]) cout<<\" \"<<i;cout<<endl;\n  //cout<<wei[xyz]<<endl;\n  if(~root) dfs2(root,-1);\n  for(int i=0;i<V;i++) assert(used[i]);\n  //cout<<root<<\"-\"<<xyz<<endl;\n  if(root==xyz) cout<<dfs3(xyz,-1)<<endl;\n  else{\n    memset(memo,-1,sizeof(memo));\n    dfs4(xyz,-1);\n    if(!tmp.empty()) ans+=tmp.top();\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n\nusing VS = vector<string>;    using LL = long long;\nusing VI = vector<int>;       using VVI = vector<VI>;\nusing PII = pair<int, int>;   using PLL = pair<LL, LL>;\nusing VL = vector<LL>;        using VVL = vector<VL>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n#define FOR(i, s, e) for (int(i) = (s); (i) < (e); (i)++)\n#define FORR(i, s, e) for (int(i) = (s); (i) > (e); (i)--)\n#define debug(x) cerr << #x << \": \" << x << endl\nconst int INF = 1e9;                          const LL LINF = 1e16;\nconst LL MOD = 1000000007;                    const double PI = acos(-1.0);\nint DX[8] = { 0, 0, 1, -1, 1, 1, -1, -1 };    int DY[8] = { 1, -1, 0, 0, 1, -1, 1, -1 };\n\n/*-----------------------------------------------\n 二辺連結成分分解 成分だけ unverified\n -----------------------------------------------*/\n\n\nstruct UnionFind {\n    vector<int> data;\n    UnionFind(int n) { data.assign(n, -1); }\n    bool unionSet(int x, int y) {\n        x = root(x); y = root(y);\n        if (x != y) {\n            if (data[y] < data[x]) swap(x, y);\n            data[x] += data[y]; data[y] = x;\n        }\n        return x != y;\n    }\n    bool same(int x, int y) { return root(x) == root(y); }\n    int root(int x) { return data[x] < 0 ? x : data[x] = root(data[x]); }\n    int size(int x) { return -data[root(x)]; }\n};\n\nstruct Lowlink {\n    UnionFind uf;\n    vector<int> low, ord, used, parent;\n    int root, k;\n    Lowlink(int V, int Root) :uf(V), low(V), ord(V), used(V), parent(V), root(Root), k(0) {}\n    \n    void lowlink(int v, int p, int &k, vector<vector<int>>& G) {\n        used[v] = true;\n        low[v] = ord[v] = k; k++;\n        for (int i = 0; i < (int)G[v].size(); i++) {\n            int u = G[v][i];\n            if (used[u] == 0) {\n                parent[u] = v;\n                lowlink(u, v, k, G);\n                low[v] = min(low[v], low[u]);\n                if (ord[v] >= low[u])uf.unionSet(v, u);\n            }\n            else if (u != p) {\n                low[v] = min(low[v], ord[u]);\n            }\n        }\n    }\n};\n\nstruct TwoEdgeConnectedComponent:Lowlink{\n //   UnionFind uf;\n    vector<vector<int>> g;\n    vector<pair<int, int>> edges;\n    vector<int> comp;\n    TwoEdgeConnectedComponent(int v) : g(v),comp(v),Lowlink(v,0) {}\n    \n    void add_edge(int x, int y) {\n        g[x].push_back(y);\n        g[y].push_back(x);\n        edges.push_back(minmax(x, y));\n    }\n    // return origin color\n    int operator[](int k) {\n        return (comp[k]);\n    }\n    \n    int size() {\n        return (g.size());\n    }\n    \n    // build, renew resG(empty -> tree), return color\n    vector<int> get_graph(vector<vector<int>>& resG,VI& W,VI& resW,int root = 0) {\n        int kk = 0;\n        Lowlink::lowlink(root, -1, kk, g);\n        int ptr = 0;\n        vector<int> color(g.size());\n        for (int i = 0; i < g.size(); i++) {\n            if (i == uf.root(i)) color[i] = ptr++;\n        }\n        \n        resG.resize(ptr);\n        for (int i = 0; i < g.size(); i++) {\n            comp[i] = color[uf.root(i)];\n        }\n        \n        resW.resize(ptr);\n        for (int i = 0; i < (int)g.size(); i++) {\n            comp[i] = color[uf.root(i)];\n            // 頂点番号における写像を作る\n            resW[comp[i]] += W[i];//重みをまとめる\n        }\n        for (auto &e : edges) {\n            int x = comp[e.first], y = comp[e.second];\n            if (x == y) continue;\n            resG[x].push_back(y);\n            resG[y].push_back(x);\n        }\n        \n//        for (int v = 0; v < (int)g.size(); v++) {\n//            for (int i = 0; i < (int)g[v].size(); i++) {\n//                int u = g[v][i];\n//                int c1 = comp[v], c2 = comp[u];\n//                if (c1 == c2)continue;\n//                resG[c1].push_back(c2);\n//                resG[c2].push_back(c1);\n//            }\n//        }\n        return comp;\n    }\n};\n\nLL dfs(int v, int p, VVI& G, VL& dp, VI& w) {\n    LL res = 0;\n    FOR(i, 0, SZ(G[v])) {\n        int nx = G[v][i];\n        if (nx == p)continue;\n        res = max(res, dfs(nx, v, G, dp, w));\n    }\n    return dp[v] = res + w[v];\n}\n\nint main() {\n    int N, M;\n    vector<vector<int>> resG;\n\n    cin >> N >> M;\n    VI W(N);\n    FOR(i, 0, N) {\n        cin >> W[i];\n    }\n    \n    \n    TwoEdgeConnectedComponent gx(N);\n    FOR(i, 0, M) {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        gx.add_edge(a, b);\n    }\n    VI resW;\n    VI vc = gx.get_graph(resG,W,resW);\n    \n    VL dp(N,0);\n    LL ans = dfs(0,-1,resG,dp,resW);\n    cout << ans << endl;\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_V 100000\nusing namespace std;\ntypedef pair<int,int> P;\nint n,m,w[100001];\nvector<int> v[100001],v1[100001];\nunodered_set<P> st;\nint V;\nvector<int> G[MAX_V];\nvector<int> rG[MAX_V];\nvector<int> vs;\nbool used[MAX_V];\nint cmp[MAX_V];\n\nvoid DFS(int p){\n  for(int i=0;i<v[p].size();i++){\n    P pp=P(min(v[p][i],p),max(v[p][i],p));\n    if(st.find(pp)==st.end()){\n      st.insert(pp);\n      G[p].push_back(v[p][i]);\n      rG[v[p][i]].push_back(p);\n      DFS(v[p][i]);\n    }\n  }\n}\n\nvoid dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++)if(!used[G[v][i]])dfs(G[v][i]);\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v]=true;\n  cmp[v]=k;\n  for(int i=0;i<rG[v].size();i++)if(!used[rG[v][i]])rdfs(rG[v][i],k);\n}\n\nint scc(){\n  memset(used,0,sizeof(used));\n  vs.clear();\n  for(int v=0;v<V;v++)if(!used[v])dfs(v);\n  memset(used,0,sizeof(used));\n  int k=0;\n  for(int i=vs.size()-1;i>=0;i--)if(!used[vs[i]])rdfs(vs[i],k++);\n  return k;\n}\n\nint C[100001],F[100001],U[100001],ans;\nbool UU[100001];\n\nbool DFS1(int p){\n  if(U[p])return 0;\n  U[p]=1;\n  bool f=F[cmp[p]]>=2;\n  for(int i=0;i<G[p].size();i++)\n    f=max(f,DFS1(G[p][i]));\n  ans+=w[p]*f;\n  return UU[p]=f;\n}\n\nint DFS2(int p){\n  if(UU[p])return 0;\n  UU[p]=1;\n  int res=0;\n  for(int i=0;i<v[p].size();i++)\n    res+=DFS2(v[p][i]);\n  return w[p]+res;\n}\n\nint main(){\n  cin>>V>>m;\n  for(int i=0;i<V;i++)cin>>w[i];\n  for(int j=0,a,b;j<m;j++){\n    cin>>a>>b;a--,b--;\n    v[a].push_back(b),v[b].push_back(a);\n  }\n  DFS(0);\n  scc();\n  for(int i=0;i<V;i++)F[cmp[i]]++;\n  DFS1(0);\n  int mx=0;\n  for(int i=0;i<V;i++)\n    if(!UU[i])mx=max(mx,DFS2(i));\n  \n  cout<<ans+mx<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n      \n#define FOR(i,a,b) for( ll i = (a); i < (ll)(b); i++ )\n#define REP(i,n) FOR(i,0,n)\n#define YYS(x,arr) for(auto& x:arr)\n#define ALL(x) (x).begin(),(x).end()\n#define SORT(x) sort( (x).begin(),(x).end() )\n#define REVERSE(x) reverse( (x).begin(),(x).end() )\n#define UNIQUE(x) (x).erase( unique( ALL( (x) ) ) , (x).end() )\n#define PW(x) (1LL<<(x))\n#define SZ(x) ((ll)(x).size())\n#define SHOW(x) cout << #x << \" = \" << x << endl\n#define SHOWA(x,n) for( int yui = 0; yui < n; yui++ ){ cout << x[yui] << \" \"; } cout << endl\n\n#define pb emplace_back\n#define fi first\n#define se second\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef long long int ll;\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<bool> vb;\ntypedef vector<ld> vd;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<vpl> gr;\ntypedef vector<vl> ml;\ntypedef vector<vd> md;\ntypedef vector<vi> mi;\n     \nconst ll INF = (ll)1e9 + 10;\nconst ll INFLL = (ll)1e18 + 10;\nconst ld EPS = 1e-12;\nconst ll MOD = 1e9+7;\n     \ntemplate<class T> T &chmin( T &a , const T &b ){ return a = min(a,b); }\ntemplate<class T> T &chmax( T &a , const T &b ){ return a = max(a,b); }\ntemplate<class T> inline T sq( T a ){ return a * a; }\n\nll in(){ long long int x; scanf( \"%lld\" , &x ); return x; }\nchar yuyushiki[1000010]; string stin(){ scanf( \"%s\" , yuyushiki ); return yuyushiki; }\n\n// head\n\n\nstruct Bridge{\n  vector<vpi> G;\n  vb used, isbridge;\n  vi ord, low;\n  int cnt;\n  int n, m;\n  void init( int size ){\n    n = size;\n    m = 0;\n    G.assign( n , vpi(0) );\n  }\n  void add_edge( int a, int b ){\n    G[a].pb( b, m );\n    G[b].pb( a, m );\n    m++;\n  }\n  void dfs( int x , int p ){\n    used[x] = true;\n    ord[x] = low[x] = cnt++;\n    YYS( w , G[x] ){\n      if( !used[w.fi] ){\n\tdfs( w.fi , x );\n\tchmin( low[x] , low[w.fi] );\n      } else if( w.fi != p ){\n\tchmin( low[x] , ord[w.fi] );\n      }\n    }\n  }\n  vb bridge(){\n    used = vb( n , false );\n    isbridge = vb( m , false );\n    ord = low = vi( n , 0 );\n    cnt = 0;\n    REP( i , n ){\n      if( !used[i] ){\n\tdfs( i , -1 );\n      }\n    }\n    REP( i , n ){\n      YYS( w , G[i] ){\n\tif( ord[i] > ord[w.fi] ){\n          continue;\n        }\n\tif( ord[i] < low[w.fi] ){\n          isbridge[w.se] = true;\n        }\n      }\n    }\n    return isbridge;\n  }\n};\n\nBridge bridge;\n\nint n, m;\n\nint a[100010];\n\nvpi G[100010];\n\nvb br;\n\nint ans;\n\nbool used[100010];\n\nvoid dfs2( int x , vi &nex , int &cur ){\n  used[x] = true;\n  cur += a[x];\n  YYS( w , G[x] ){\n    if( used[w.fi] ){\n      continue;\n    }\n    if( br[w.se] ){\n      nex.pb( w.fi );\n    } else {\n      dfs2( w.fi , nex , cur );\n    }\n  }\n}\n\nvoid dfs( int x , int cur ){\n  vi nex(0);\n  dfs2( x , nex , cur );\n  chmax( ans , cur );\n  YYS( w , nex ){\n    dfs( w , cur );\n  }\n}\n\nint main(){\n\n  n = in();\n  m = in();\n  bridge.init( n );\n  REP( i , n ){\n    a[i] = in();\n  }\n  REP( i , m ){\n    int x = in() - 1;\n    int y = in() - 1;\n    G[x].pb( y , i );\n    G[y].pb( x , i );\n    bridge.add_edge( x , y );\n  }\n\n  br = bridge.bridge();\n\n  dfs( 0 , 0 );\n\n  printf( \"%d\\n\" , ans );\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\nconst int inf = 1e9;\n\nvector<int> decomposition(vector<vector<int> > &adj){\n    int n = adj.size();\n    vector<int> ord(n, inf);\n    for(int i=1; i<n; i++){\n        ord[i] = adj[i].size();\n    }\n    \n    queue<int> wait;\n    for(int i=0; i<n; i++){\n        if(ord[i] == 1) wait.push(i);\n    }    \n    vector<int> rem(n, false);\n    while(!wait.empty()){\n        int cur = wait.front();\n        wait.pop();\n        rem[cur] = true;\n        for(int i: adj[cur]){\n            ord[i]--;\n            if(ord[i] == 1) wait.push(i);\n        }\n    }\n    return rem;\n}\n\nint solve(int node, vector<int> &w, vector<bool> &used, vector<vector<int> > &adj){\n    if(used[node]) return 0;\n    used[node] = true;\n    int res = 0;\n    for(int v: adj[node]){\n        res = max(res, solve(v, w, used, adj));\n    }\n    return res +w[node];\n}\n\nint main(){\n    int n,m;\n    cin >> n >> m;\n    vector<int> w(n);\n    for(int i=0; i<n; i++) cin >> w[i];\n    vector<vector<int> > adj(n);\n    for(int i=0; i<m; i++){\n        int u,v;\n        cin >> u >> v;\n        u--; v--;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    vector<int> rem = decomposition(adj);\n    {\n        vector<vector<int> > newadj(n);\n        for(int i=0; i<n; i++){\n            int nvi = rem[i]? i: 0;\n            if(i!=0 && nvi==0) w[0] += w[i];\n            for(int j: adj[i]){\n                int nvj = rem[j]? j: 0;\n                if(nvi == nvj) continue;\n                newadj[nvi].push_back(nvj);\n            }\n        }\n        for(vector<int> v: newadj){\n            sort(v.begin(), v.end());\n            v.erase(unique(v.begin(), v.end()), v.end());\n        }\n        adj = newadj;\n    }\n\n    vector<bool> used(n, false);\n    cout << solve(0, w, used, adj) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\n// 関節点を求める (artPoints)\n// 橋を求める (bridges)\n// 二重辺連結成分分解をする (BICC)\n\n// 関節点は、取り除いたときに連結でなくなってしまうような頂点のこと\n// 橋は、取り除いた時に連結でなくなってしまうような辺のこと\n\n// 移動元と行先と辺のコストを記録する構造体\ntemplate <typename T>\nstruct Edge {\n    int from, to;\n    T cost;\n    Edge(int s, T d) : to(s), cost(d) {}\n    Edge(int f, int s, T d) : from(f), to(s), cost(d) {}\n\n    bool operator<(const Edge &e) const {\n        return cost < e.cost;\n    }\n    bool operator>(const Edge &e) const {\n        return cost > e.cost;\n    }\n};\n\ntemplate <typename T>\nusing Graph = vector< vector< Edge<T> > >;\n\ntemplate <typename T>\nstruct graphLink {\n    vector<int> ord, low, parent, cmp;\n    vector< vector< Edge<T> > > G, H;\n\n    // 橋の情報 (first < second となるように格納)\n    vector< pair<int, int> > bridges;\n    int cnt, v;\n\n    // init\n    graphLink(vector< vector< Edge<T> > > &S, int root=0) {\n        int n = S.size();\n        ord.resize(n, -1), low.resize(n, 0),\n        parent.resize(n, -1), cmp.resize(n, -1);\n        cnt = 0, v = n;\n        G = S;\n        dfs(root);\n    }\n\n    // 橋であるかの判定\n    bool is_bridge(int x, int y) {\n        if(ord[x] > ord[y]) swap(x, y);\n        return ord[x] < low[y];\n    }\n\n    // dfs 木の作成と橋の列挙 (初期化と同時にやる)\n    // usage: dfs(root);\n    void dfs(int cur, int prev=-1) {\n        low[cur] = cnt;\n        ord[cur] = cnt++;\n\n        for(auto x : G[cur]) {\n            if(x.to == prev) continue;\n            if(ord[x.to] < 0) {\n                parent[x.to] = cur;\n                dfs(x.to, cur);\n\n                low[cur] = min(low[cur], low[x.to]);\n            }\n            else {\n                low[cur] = min(low[cur], ord[x.to]);\n            }\n            if(is_bridge(cur, x.to)) {\n                int a = min(cur, x.to);\n                int b = max(cur, x.to);\n                bridges.emplace_back(make_pair(a, b));\n            }\n        }\n    }\n\n    // 関節点を求める (root は dfs 木の root と一致させる)\n    // root は子を 2 つ持っていれば関節点になる\n    // それ以外の頂点に関しては ord[parent] <= low[i] のとき関節点になる\n    // (lowlink でも親より深さが低い頂点にたどり着けないため)\n    set<int> artPoints(int root) {\n        set<int> se;\n        int num = 0;\n        for(int i=0; i<v; i++) {\n            if(parent[i] < 0) continue;\n            if(parent[i] == root) num++;\n            else if(ord[parent[i]] <= low[i]) se.insert(parent[i]);\n        }\n        if(num >= 2) se.insert(0);\n        return se;\n    }\n\n    // 二重辺連結成分分解 (橋となる辺を使わないように DFS)\n    // Verified: AtCoder Regular Contest D: 旅行会社高橋君\n    void BICC() {\n        int k = 0;\n        // point, number\n        stack<pii> S;\n        for(int i=0; i<v; i++) {\n            if(cmp[i] >= 0) continue;\n            cmp[i] = k;\n            S.push(make_pair(i, k++));\n            while(!S.empty()) {\n                pii cur = S.top(); S.pop();\n                for(auto x : G[cur.first]) {\n                    if(cmp[x.to] >= 0) continue;\n                    if(is_bridge(cur.first, x.to)) continue;\n                    cmp[x.to] = cur.second;\n                    S.push(make_pair(x.to, cmp[x.to]));\n                }\n            }\n        }\n\n        set< pair<int, int> > edge_set;\n        H.resize(k);\n        for(int i=0; i<v; i++) {\n            for(auto x : G[i]) {\n                int ca = cmp[i], cb = cmp[x.to];\n                if(ca == cb) continue;\n                if(ca > cb) swap(ca, cb);\n                if(edge_set.count(make_pair(ca, cb))) continue;\n                edge_set.insert(make_pair(ca, cb));\n                H[ca].push_back(Edge<T>(cb, 1));\n                H[cb].push_back(Edge<T>(ca, 1));\n            }\n        }\n    }\n};\n\nint rec[100010], w[100010], nw[100010];\nint p[100010], depth[100010], checked[100010], sz[100010];\nvoid dfs(Graph<int> &G, int cur, int par=-1) {\n    if(par >= 0) rec[cur] += nw[cur];\n    for(auto e : G[cur]) {\n        int to = e.to;\n        if(to == par) continue;\n        depth[to] = depth[cur] + 1;\n        p[to] = cur;\n        rec[to] += rec[cur];\n        dfs(G, to, cur);\n    }\n}\n\nsigned main() {\n    int N, M; cin >> N >> M;\n    for(int i=0; i<N; i++) {\n        cin >> w[i];\n    }\n    Graph<int> G(N);\n    for(int i=0; i<M; i++) {\n        int u, v; cin >> u >> v;\n        u--; v--;\n        G[u].push_back(Edge<int>(v, 1));\n        G[v].push_back(Edge<int>(u, 1));\n    }\n\n    graphLink<int> gl(G);\n    gl.BICC();\n    int K = gl.H.size();\n    for(int i=0; i<N; i++) {\n        int id = gl.cmp[i];\n        nw[id] += w[i];\n        sz[id]++;\n    }\n\n    int root = gl.cmp[0];\n    p[root] = -1;\n    dfs(gl.H, root, -1);\n\n    vector< tuple<int, int> > info1;\n    for(int i=0; i<K; i++) {\n        if(sz[i] >= 3) {\n            info1.emplace_back(rec[i], i);\n        }\n    }\n    sort(info1.rbegin(), info1.rend());\n\n    int ans = nw[root];\n    for(auto e : info1) {\n        int val, idx; tie(val, idx) = e;\n        if(checked[idx]) continue;\n        ans += val;\n        for(; idx>=0; idx=p[idx]) {\n            checked[idx] = true;\n            nw[idx] = 0;\n        }\n    }\n\n    fill(checked, checked + N, false);\n    queue< pair<int, int> > que;\n    que.emplace(root, 0);\n    checked[root] = true;\n    int ma = 0;\n    while(que.size()) {\n        int idx, val; tie(idx, val) = que.front(); que.pop();\n        for(auto e : gl.H[idx]) {\n            if(checked[e.to]) continue;\n            checked[e.to] = true;\n            ma = max(ma, val + nw[e.to]);\n            que.emplace(e.to, val + nw[e.to]);\n        }\n    }\n    ans += ma;\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 100005;\n\nset<int> G[MAX_N];\nset<int> nG[MAX_N];\nbool flag[MAX_N];\nint w[MAX_N];\nint n,m,opt;\n\nvoid dfs(int s,int cost)\n{\n    if(nG[s].size() == 0){\n        if(opt < cost){\n            opt = cost;\n        }\n        return;\n    }\n    for(auto it = nG[s].begin(); it != nG[s].end() ;it++){\n        dfs(*it,cost+w[(*it)]);\n    }\n    return;\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\trep(i,n){\n\t\tscanf(\"%d\",&w[i]);\n\t}\n    rep(i,m){\n        int x,y;\n        scanf(\"%d%d\",&x,&y);\n        G[x-1].insert(y-1);\n        G[y-1].insert(x-1);\n    }\n    rep(i,n){\n        flag[i] = false;\n    }\n    queue<P> que;\n    for(int i=1;i<n;i++){\n        if(G[i].size() == 1){\n            flag[i] = true;\n            if(*G[i].begin() == 0){\n                nG[0].insert(i);\n                continue;\n            }\n            G[*G[i].begin()].erase(i);\n            if(G[*G[i].begin()].size() == 1){\n                que.push(P(*G[i].begin(),i));\n                flag[*G[i].begin()] = true;\n                nG[*G[i].begin()].insert(i);\n            }else{\n                nG[*G[i].begin()].insert(i);\n            }\n        }\n    }\n    while(!que.empty()){\n        P p = que.front();\n        int u = p.first;\n        que.pop();\n        if(*G[u].begin() == 0){\n            nG[0].insert(u);\n            continue;\n        }\n        G[*G[u].begin()].erase(u);\n        if(G[*G[u].begin()].size() == 1){\n            que.push(P(*G[u].begin(),u));\n            flag[*G[u].begin()] = true;\n            nG[*G[u].begin()].insert(u);\n        }else{\n            nG[*G[u].begin()].insert(u);\n        }\n    }\n    for(int i=1;i<n;i++){\n        if(!flag[i]){\n            if(nG[i].size() > 0){\n                for(auto it = nG[i].begin(); it != nG[i].end() ;it++){\n                    nG[0].insert(*it);\n                }\n                nG[i].clear();\n            }\n        }\n    }\n    int res = 0;\n    for(int i = 1;i < n;i++){\n        if(!flag[i]){\n            res += w[i];\n        }\n    }\n    dfs(0,w[0]);\n    res += opt;\n    printf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\ntypedef vector<int> vi;\ntypedef vector<bool> vb;\ntypedef pair<int,int> edge;\n\nvector<vi> G;\n\nvoid bridge_dfs(int now, int from, vector<edge> &bridge, vector<vi> &bicomp, stack<int> &roots,\n                stack<int> &S, vb &inS, vi &preord, int &pre_ct){\n    preord[now] = pre_ct++;\n    S.push(now); inS[now]=true;\n    roots.push(now);\n    rep(i,G[now].size()){\n        int to = G[now][i];\n        if(preord[to] == -1) bridge_dfs(to,now,bridge,bicomp,roots,S,inS,preord,pre_ct);\n        else if(from != to && inS[to]) while(preord[roots.top()] > preord[to]) roots.pop();\n    }\n    if(now == roots.top()){\n        bridge.pb(edge(now,from));\n        bicomp.pb(vi());\n        while(1){\n            int v=S.top(); S.pop(); inS[v]=false;\n            bicomp.back().pb(v);\n            if(now == v) break;\n        }\n        roots.pop();\n    }\n}\n\nvoid bridge_detect(vector<edge> &bridge, vector<vi> &bicomp){\n    const int n=G.size();\n    vi preord(n,-1);\n    vb inS(n,false);\n    stack<int> roots,S;\n    int pre_ct=0;\n    rep(i,n)if(preord[i] == -1){\n        bridge_dfs(i,n,bridge,bicomp,roots,S,inS,preord,pre_ct);\n        bridge.pop_back();\n    }\n}\n\nvector<vi> T;\nvi par;\nvb leaf;\nvoid dfs(int v, int p){\n    par[v] = p;\n    for(int e:T[v])if(e!=p){\n        dfs(e,v);\n        leaf[v] = false;\n    }\n}\n\nint main(){\n    int n,m;\n    scanf(\" %d %d\", &n, &m);\n    vector<int> w(n);\n    rep(i,n) scanf(\" %d\", &w[i]);\n    vector<int> a(m),b(m);\n    rep(i,m){\n        scanf(\" %d %d\", &a[i], &b[i]);\n        --a[i];\n        --b[i];\n    }\n\n    G = vector<vi>(n);\n    rep(i,m){\n        G[a[i]].pb(b[i]);\n        G[b[i]].pb(a[i]);\n    }\n\n    vector<edge> bridge;\n    vector<vi> bicomp;\n    bridge_detect(bridge, bicomp);\n\n    int sz = bicomp.size();\n\n    vector<int> cmp(n);\n    rep(i,sz){\n        for(int j:bicomp[i]) cmp[j] = i;\n    }\n\n    T = vector<vi>(sz);\n    rep(i,m){\n        int u = cmp[a[i]], v = cmp[b[i]];\n        if(u!=v){\n            T[u].pb(v);\n            T[v].pb(u);\n        }\n    }\n\n    int root = cmp[0];\n    par = vi(sz,-1);\n    leaf = vb(sz,true);\n    dfs(root,-1);\n\n    vector<bool> ok(sz);\n    queue<int> que;\n    rep(i,sz){\n        if(bicomp[i].size()>1){\n            ok[i] = true;\n            que.push(i);\n        }\n    }\n    while(!que.empty()){\n        int now = que.front();\n        que.pop();\n\n        int pp = par[now];\n        if(pp==-1) continue;\n\n        if(!ok[pp]){\n            ok[pp] = true;\n            que.push(pp);\n        }\n    }\n\n    int ans = 0;\n    rep(i,sz){\n        if(!ok[i] && leaf[i]){\n            int tmp = 0;\n            int idx = i;\n            while(idx!=-1 && !ok[idx]){\n                tmp += w[bicomp[idx][0]];\n                idx = par[idx];\n            }\n\n            ans = max(ans, tmp);\n        }\n    }\n\n    rep(i,sz)if(ok[i]){\n        for(int j:bicomp[i]) ans += w[j];\n    }\n\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\n#define MAX 200000\n\nint N;\nvector<int> G[MAX];\nbool visited[MAX];\nint prenum[MAX],parent[MAX],lowest[MAX],timer;\nvector<P> bridge;\n\nvoid dfs(int v,int prev){\n\tprenum[v]=lowest[v]=timer;\n\ttimer++;\n\tvisited[v]=true;\n\n\tint next;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tnext=G[v][i];\n\t\tif(!visited[next]){\n\t\t\tparent[next]=v;\n\t\t\tdfs(next,v);\n\t\t\tlowest[v]=min(lowest[v],lowest[next]);\n\t\t\tif(prenum[v]<lowest[G[v][i]])bridge.push_back(P(min(v,G[v][i]),max(v,G[v][i])));\n\t\t}else if(next!=prev){\n\t\t\tlowest[v]=min(lowest[v],prenum[next]);\n\t\t}\n\t}\n}\n\n\nset<int> art_points(){\n\tfor(int i=0;i<N;i++){\n\t\tvisited[i]=false;\n\t}\n\ttimer=1;\n\tdfs(0,-1);\n\n\tset<int> ap;\n\tint np=0;\n\tfor(int i=1;i<N;i++){\n\t\tint p=parent[i];\n\t\tif(p==0)np++;\n\t\telse if(prenum[p]<lowest[i])ap.insert(p);\n\t}\n\tif(np>1)ap.insert(0);\n\treturn ap;\n}\n\nint w[MAX];\nvector<P> edge;\nvector<P> n_bridge;\nvector<int> ok_G[MAX];\nint cnt;\nbool used[100001];\nint sum[100001];\nint num[100001];\nint siz[100001];\nvector<int> graph[MAX];\n\nvoid c_dfs(int v){\n\tused[v]=true;\n\tnum[v]=cnt;\n\tsiz[cnt]++;\n\tsum[cnt]+=w[v];\n\tfor(int i=0;i<ok_G[v].size();i++){\n\t\tif(num[ok_G[v][i]]==-1){\n\t\t\tc_dfs(ok_G[v][i]);\n\t\t}\n\t}\n}\n\nint dp[100001];\nint dp2[100001];\n\nint solve2(int v,int p){\n\tif(dp2[v]!=-1)return dp2[v];\n\tint res=w[v];\n\tint back=-1;\n\tfor(int i=0;i<graph[v].size();i++){\n\t\tif(p!=graph[v][i]){\n\t\t\tint va=solve2(graph[v][i],v);\n\t\t\tif(va!=-1){\n\t\t\t\tres+=va;\n\t\t\t\tback=0;\n\t\t\t}\n\t\t}\n\t}\n\tif(siz[v]>=3)back=0;\n\tdp2[v]=(back==0)?res:-1;\n\treturn dp2[v];\n}\n\nint solve(int v,int p){\n\tif(dp[v]!=-1)return dp[v];\n\tint res=0;\n\tfor(int i=0;i<graph[v].size();i++){\n\t\tif(p!=graph[v][i]){\n\t\t\tint va=solve2(graph[v][i],v);\n\t\t\tif(va!=-1)res+=va;\n\t\t}\n\t}\n\tint diff=0;\n\tfor(int i=0;i<graph[v].size();i++){\n\t\tif(p!=graph[v][i]){\n\t\t\tint va=solve(graph[v][i],v);\n\t\t\tif(va-max(dp2[v],0)>diff){\n\t\t\t\tdiff=va-max(0,dp2[v]);\n\t\t\t}\n\t\t}\n\t}\n\tres+=diff;\n\treturn (dp[v]=(res+sum[v]));\n}\n\nint main(void){\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d\",&w[i]);\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\ta--;\n\t\tb--;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t\tedge.push_back(P(a,b));\n\t}\n\tN=n;\n\tart_points();\n\tsort(bridge.begin(),bridge.end());\n\tfor(int i=0;i<m;i++){\n\t\tint v=lower_bound(bridge.begin(),bridge.end(),edge[i])-bridge.begin();\n\t\tif(!(v<bridge.size() && bridge[v]==edge[i])){\n\t\t\tok_G[edge[i].first].push_back(edge[i].second);\n\t\t\tok_G[edge[i].second].push_back(edge[i].first);\n\t\t}\n\t}\n\tmemset(num,-1,sizeof(num));\n\tfor(int i=0;i<n;i++){\n\t\tif(num[i]==-1){\n\t\t\tc_dfs(i);\n\t\t\tcnt++;\n\t\t}\n\t}\n\tfor(int i=0;i<bridge.size();i++){\n\t\tP p=bridge[i];\n\t\tgraph[num[p.first]].push_back(num[p.second]);\n\t\tgraph[num[p.second]].push_back(num[p.first]);\n\t}\n\tmemset(dp,-1,sizeof(dp));\n\tmemset(dp2,-1,sizeof(dp2));\n\tprintf(\"%d\\n\",solve(num[0],-1));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int, int> P;\nconst int M = 1000000007;\n\nvector<vector<int>> edge;\nvector<set<int>> nedge;\nvector<int> uid, uuid;\nvector<int> vis;\nvector<int> viscnt;\nvector<int> cnts;\nvector<int> nw;\nbool dfs(int now, int par, int s) {\n    vis[now] = s;\n    bool ret = false;\n    for (int i : edge[now]) {\n        if (i == par) continue;\n        if (s == 0) {\n            ++viscnt[i];\n        }\n        if (i == s) {\n            ret = true;\n        }\n        else if (vis[i] < s && uid[i] > s) {\n            ret |= dfs(i, now, s);\n        }\n    }\n    if (ret) {\n        uid[now] = s;\n    }\n    return ret;\n}\nbool dfs(int now, int par) {\n    bool ret = cnts[now] > 1;\n    for (int i : nedge[now]) {\n        if (i == par) continue;\n        ret |= dfs(i, now);\n    }\n    if (ret) {\n        uuid[now] = 0;\n    }\n    return ret;\n}\nint dfs2(int now, int par) {\n    int ret = 0;\n    for (int i : nedge[now]) {\n        if (i == par) continue;\n        ret = max(ret, dfs2(i, now));\n    }\n    return ret + nw[now];\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<int> w(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> w[i];\n    }\n    edge.resize(n);\n    for (int i = 0; i < m; ++i) {\n        int a, b;\n        cin >> a >> b;\n        --a;\n        --b;\n        edge[a].push_back(b);\n        edge[b].push_back(a);\n    }\n    uid.resize(n);\n    vis.resize(n, -1);\n    for (int i = 0; i < n; ++i) {\n        uid[i] = i;\n    }\n    viscnt.resize(n, 0);\n    cnts.resize(n, 0);\n    for (int i = 0; i < n; ++i) {\n        if (uid[i] == i) {\n            if (i == 0 || viscnt[i] > 1)\n                dfs(i, -1, i);\n        }\n        ++cnts[uid[i]];\n    }\n    nedge.resize(n);\n    for (int i = 0; i < n; ++i) {\n        for (int j : edge[i]) {\n            if (uid[i] != uid[j]) {\n                nedge[uid[i]].insert(uid[j]);\n            }\n        }\n    }\n    uuid.resize(n);\n    for (int i = 0; i < n; ++i) {\n        uuid[i] = i;\n    }\n    dfs(0, -1);\n    nw.resize(n, 0);\n    for (int i = 0; i < n; ++i) {\n        nw[uuid[uid[i]]] += w[i];\n    }\n    vector<int> used(n, 0);\n    int ma = 0;\n    for (int i = 0; i < n; ++i) {\n        if (i == uid[i] && uuid[i] == 0) {\n            for (int j : nedge[i]) {\n                if (uuid[j] > 0 && !used[j]) {\n                    used[j] = 1;\n                    ma = max(ma, dfs2(j, i));\n                }\n            }\n        }\n    }\n    cout << (nw[0] + ma) << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_N 100011\n#define N MAX_N\n#define rank dfasfds\nusing namespace std;\ntypedef long long ll;\ntypedef set<int> S;\nint par[MAX_N],rank[MAX_N];\nll val[MAX_N];\nS G[N];\n\nvoid init(int n){for(int i=0;i<N;i++)par[i]=i,rank[i]=0;}\n\nint find(int x){\n  if(par[x]==x)return x;\n  return par[x]=find(par[x]);\n}\n\nbool same(int x,int y){return find(x)==find(y);}\n\nvoid unite(int x,int y){\n  x=find(x),y=find(y);\n  if(x==y)return;\n  if(rank[x]<rank[y])par[x]=y,val[y]+=val[x];\n  else{\n    par[y]=x;\n    val[x]+=val[y];\n    if(rank[x]==rank[y])rank[x]++;\n  }\n}\n\nint used[N];\nvector<int> pass;\nvoid dfs(int pos,int pre){\n  if(pos!=find(pos))return;\n  if(used[pos]) {\n    for(int i=pass.size()-1;i>=0;i--)unite(pos,pass[i]);\n    return;\n  }\n\n  used[pos]=1;\n  pass.push_back(pos);\n  for(S::iterator it=G[pos].begin();it!=G[pos].end();it++)if(*it!=pre)dfs(*it,pos);\n  used[pos]=0;\n  pass.pop_back();\n}\n\nvector<int>col[N];\nll get_mx(int pos,int pre){\n  if(used[find(pos)])return 0;\n  used[find(pos)]=1;\n  ll res=0;\n  for(int i=0;i<col[pos].size();i++)\n    for(S::iterator it=G[col[pos][i]].begin();it!=G[col[pos][i]].end();it++){\n      if(*it!=pre&&!same(*it,pos))res=max(res,get_mx(*it,pos));\n    }\n  return res+val[find(pos)];\n}\n\nint main(){\n  int n,m;\n  cin>>n>>m;\n  for(int i=0;i<n;i++) cin>>val[i];\n  for(int i=0,a,b;i<m;i++){\n    cin>>a>>b;a--,b--;\n    G[a].insert(b);\n    G[b].insert(a);\n  }\n  init(n);\n  dfs(0,-1);\n  for(int i=0;i<n;i++)col[find(i)].push_back(i);\n  cout <<get_mx(find(0),-1)<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n,m;\nvector<int>e[100005];\nvector<int>edge[100005];\nint used[100005];\nint w[100005],k;\nvector<int>E[100005];\nll W[100005];\nint in[100005];\nll dp[100005];\nint cnt[100005],c[100005];\nint par[100005],ran[100005];\nll ans,add;\nvoid init(){ for(int i=0;i<100005;i++) par[i] = i; }\nint find(int x){ if(x == par[x]) return x; else return par[x] = find(par[x]); }\nvoid unite(int x,int y){\n\tx = find(x); y = find(y); if(x==y) return;\n\tif(ran[x] < ran[y]) par[x] = y;\n\telse{\n\t\tpar[y] = x;\n\t\tif(ran[x] == ran[y]) ran[x]++;\n\t}\n}\nbool same(int x,int y){ return find(x)==find(y); }\nvoid dfs(int v,int u,int d){\n\tused[v] = d;//cout << v << endl;\n\tfor(int i=0;i<e[v].size();i++){\n\t\tif(e[v][i] == u) continue;\n\t\tif(used[e[v][i]] && used[e[v][i]] < used[v]){\n\t\t\tcnt[e[v][i]]--;\n\t\t\tcnt[v]++;\n\t\t\tunite(e[v][i],v);\n\t\t\t//cout << v << \" \" << e[v][i] << endl;\n\t\t\tcontinue;\n\t\t}\n\t\telse if(used[e[v][i]]) continue;\n\t\tdfs(e[v][i],v,d+1); edge[v].pb(e[v][i]); //cout << v << \" \" << e[v][i] << endl;\n\t}\n}\nint dfs2(int v,int u){\n\tint sum = 0;\n\tfor(int i=0;i<edge[v].size();i++){\n\t\tint a = dfs2(edge[v][i],v);\n\t\tif(a>0){\n\t\t    //cout << edge[v][i] << \" f\" << v << endl;\n\t\t\tunite(edge[v][i],v);\n\t\t}\n\t\tsum += a;\n\t}\n\tsum += cnt[v];\n\treturn sum;\n}\npair<ll,bool> dfs(int v,int p){\n\tll ret = 0; bool ok = (c[v] >= 3);\n\tfor(int i=0;i<E[v].size();i++){\n\t\tif(E[v][i] == p) continue;\n\t\tpair<ll,bool> t = dfs(E[v][i],v);\n\t\tret = max(ret,t.fi);\n\t\tok |= t.sc;\n\t}\n\tif(ok){\n\t\tret = 0;\n\t\tans += W[v];\n\t}\n\telse ret += W[v];\n\tadd = max(add,ret);\n\treturn mp(ret,ok);\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=0;i<n;i++) scanf(\"%d\",&w[i]);\n\tfor(int i=0;i<m;i++){\n\t\tint a,b; scanf(\"%d%d\",&a,&b); a--; b--;\n\t\te[a].push_back(b);\n\t\te[b].push_back(a);\n\t}\n\tinit(); dfs(0,-1,1); dfs2(0,-1);\n\tfor(int i=0;i<n;i++){\n\t\tW[find(i)] += w[i];\n\t\tc[find(i)] ++;\n\t\tfor(int j=0;j<e[i].size();j++){\n\t\t\tif(find(i) != find(e[i][j])){\n\t\t\t\tE[find(i)].pb(find(e[i][j]));\n\t\t\t\tE[find(e[i][j])].pb(find(i));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tSORT(E[i]); ERASE(E[i]);\n\t}\n\tdfs(0,-1);\n\tcout << ans+add << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nstruct UnionFind {\n    vector<int> par;\n    vector<int> rank;\n    vector<ll> Size;\n    UnionFind(int n = 1) {\n        init(n);\n    }\n\n    void init(int n = 1) {\n        par.resize(n + 1); rank.resize(n + 1); Size.resize(n + 1);\n        for (int i = 0; i <= n; ++i) par[i] = i, rank[i] = 0, Size[i] = 1;\n    }\n\n    int root(int x) {\n        if (par[x] == x) {\n            return x;\n        }\n        else {\n            int r = root(par[x]);\n            return par[x] = r;\n        }\n    }\n\n    bool issame(int x, int y) {\n        return root(x) == root(y);\n    }\n\n    bool merge(int x, int y) {\n        x = root(x); y = root(y);\n        if (x == y) return false;\n        if (rank[x] < rank[y]) swap(x, y);\n        if (rank[x] == rank[y]) ++rank[x];\n        par[y] = x;\n        Size[x] += Size[y];\n        return true;\n    }\n\n    ll size(int x){\n        return Size[root(x)];\n    }\n};\n\nll N, M;\nset<ll> pathes[200100];\nll w[200100];\nll subscore[200100];\nbool ERASED[200100];\nll s;\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> N >> M;\n    UnionFind uni(N + 1);\n    for(int i = 1; i <= N; i++) cin >> w[i];\n    for(int i = 1; i <= M; i++) {\n        ll a, b;\n        cin >> a >> b;\n        pathes[a].insert(b);\n        pathes[b].insert(a);\n        uni.merge(a, b);\n    }\ns = 1;\n    queue<int> que;\n    for(int i = 1; i <= N; i++) {\n        if(pathes[i].size() == 1) {\n            que.push(i);\n        }\n    }\n    while(!que.empty()) {\n        ll now = que.front();\n        que.pop();\n        if(now == s) continue;\n        if(pathes[now].empty()) continue;\n        ERASED[now] = true;\n        ll nowcost = subscore[now];\n        ll to = *(pathes[now].begin());\n        pathes[now].clear();\n        auto itr = pathes[to].lower_bound(now);\n        pathes[to].erase(itr);\n        chmax(subscore[to], nowcost + w[now]);\n        if(pathes[to].size() == 1) que.push(to);\n    }\n    ll ans = 0;\n    ll subans = 0;\n    for(int i = 1; i <= N; i++) {\n        if(!uni.issame(i, s)) continue;\n        if(ERASED[i]) continue;\n        ans += w[i];\n        chmax(subans, subscore[i]);\n    }\n    cout << ans + subans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate<class T>\nbool chmin(T& a, const T& b) {\n    if (b < a) { a = b; return true; }\n    return false;\n}\n\n// std::vector Declaration\ntemplate<typename T>\nvector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T, typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));\n}\n\n// std::vector Declaration and Initialization\ntemplate<typename T>\nvector<T> make_vector(size_t a, T x) { return vector<T>(a, x); }\ntemplate<typename T, typename U, typename... Ts>\nauto make_vector(size_t a, U b, Ts... ts) {\n    return vector<decltype(make_vector<T>(b,ts...))>(a, make_vector<T>(b, ts...));\n}\n\n// std::vector Input\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& v) {\n    for (auto &e : v) is >> e;\n    return is;\n}\n\n// std::vector Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::array Debug\ntemplate<typename T, size_t n>\nostream& operator<<(ostream& os, const array<T, n>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::deque Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const deque<T>& d) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : d) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::pair Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \" \" << p.second << \")\";\n    return os;\n}\n\n// std::set Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const set<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::multiset Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const multiset<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::map Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const map<T, U>& mp) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : mp) {\n        os << (a ? \"\" : \" \");\n        os << e.first << \":\" << e.second;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::tuple Debug\ntemplate<int N, class Tuple>\nvoid out(ostream& os, const Tuple& t){}\ntemplate<int N, class Tuple, class H, class ...Ts>\nvoid out(ostream& os, const Tuple& t) {\n    if (N) os << \" \";\n    os << get<N>(t);\n    out<N+1,Tuple,Ts...>(os, t);\n}\ntemplate<class ...Ts>\nostream& operator<<(ostream& os, const tuple<Ts...>& t) {\n    os << \"(\";\n    out<0,tuple<Ts...>,Ts...>(os, t);\n    os << \")\";\n    return os;\n}\n\n// Debug\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n\n// Weighted edge\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n\n    edge() {}\n    edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n    edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n    friend ostream& operator<<(ostream& os, const edge& e) {\n        return os << \"(\" << e.src << \"->\" << e.to << \":\" << e.cost << \")\";\n    }\n};\n\nusing LL = int64_t;\n\n#define fs first\n#define sc second\n\nconst int64_t MOD = 1e9+7;\n\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    int n, m; cin >> n >> m;\n    vector<int> w(n); cin >> w;\n    vector<vector<int>> G(n);\n    vector<int> deg(n);\n    for (int i = 0; i < m; ++i) {\n        int u, v; cin >> u >> v; --u, --v;\n        G[u].push_back(v);\n        G[v].push_back(u);\n        ++deg[u], ++deg[v];\n    }\n\n    int S = 0;\n\n    queue<int> que;\n    for (int i = 0; i < n; ++i) {\n        if (i != S and deg[i] == 1) {\n            que.push(i);\n        }\n    }\n    vector<bool> used(n);\n    while (!que.empty()) {\n        int v = que.front(); que.pop();\n        used[v] = true;\n        for (int u : G[v]) {\n            if (u != S and --deg[u] == 1) que.push(u);\n        }\n    }\n\n    int ans = 0;\n    vector<int> vs, dist(n, -1);\n    for (int i = 0; i < n; ++i) {\n        if (!used[i]) {\n            ans += w[i];\n            vs.push_back(i);\n            dist[i] = 0;\n        }\n    }\n\n    function<void(vector<int>)> dfs = [&](vector<int> vs){\n        for (int v : vs) {\n            for (int u : G[v]) {\n                if (dist[u] != -1) continue;\n                dist[u] = dist[v] + w[u];\n                dfs({ u });\n            }\n        }\n    };\n\n    dfs(vs);\n\n    ans += *max_element(dist.begin(), dist.end());\n\n    cout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);++i)\n#define rep2(i,a,b) for (int i=(a);i<(b);++i)\n#define rrep(i,n) for (int i=(n)-1;i>=0;--i)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;--i)\n#define chmin(a,b) (a)=min((a),(b));\n#define chmax(a,b) (a)=max((a),(b));\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) cout<<(#v)<<\":\";for(auto(x):(v)){cout<<\" \"<<(x);}cout<<endl;\n#define printVS(vs) cout<<(#vs)<<\":\"<<endl;for(auto(s):(vs)){cout<<(s)<< endl;}\n#define printVV(vv) cout<<(#vv)<<\":\"<<endl;for(auto(v):(vv)){for(auto(x):(v)){cout<<\" \"<<(x);}cout<<endl;}\n#define printP(p) cout<<(#p)<<(p).first<<\" \"<<(p).second<<endl;\n#define printVP(vp) cout<<(#vp)<<\":\"<<endl;for(auto(p):(vp)){cout<<(p).first<<\" \"<<(p).second<<endl;}\n\ninline void output(){ cout << endl; }\ntemplate<typename First, typename... Rest>\ninline void output(const First& first, const Rest&... rest) {\n    cout << first << \" \"; output(rest...);\n}\n\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing TUPLE = tuple<int, int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\nusing Graph = vector<vector<int>>;\n\ntypedef vector<vector<int>> Graph;\ntypedef pair<int, int> Edge; // (a < b: undirected)\n\nvi w;\nvi wcmp;\n\nclass BICC {\nprivate:\n    const int n;\n\n    Graph G;\n    vector<int> depth;\n    vector<int> par;\n    map<Edge, int> imosEdge;\n    map<Edge, int> EdgeType;\n    enum {UNUSED, USED_DFS, BRIDGE};\n    vector<Edge> bridges;\n\n\tvector<int> cmp;\n\tint num_cc;\n\tvector<int> size_of_vertex;\n\tGraph G_cc;\npublic:\n    BICC(int _n) : n(_n), G(_n), depth(_n, -1), par(_n, -1), cmp(_n, -1), num_cc(0) {}\n    Edge getEdge(int a, int b) {\n        if (a > b) swap(a, b);\n        return Edge(a, b);\n    }\n    void updateEdgeType(int a, int b, int type) {\n        if (a < 0 || b < 0) return;\n        EdgeType[getEdge(a, b)] = type;\n    }\n    void addEdge(int a, int b) {\n        G[a].emplace_back(b);\n        G[b].emplace_back(a);\n        updateEdgeType(a, b, UNUSED);\n    }\n    void dfsTreeConstruct(int v, int pre) {\n        if (depth[v] != -1) return;\n        depth[v] = (pre == -1 ? 0 : depth[pre] + 1);\n        par[v] = pre;\n        updateEdgeType(pre, v, USED_DFS);\n        for (auto&& nxt : G[v]) {\n            if (nxt != pre) dfsTreeConstruct(nxt, v);\n        }\n    }\n    void updateImos(int a, int b) {\n        if (depth[a] < depth[b]) swap(a, b);\n\n        if (par[a] != -1) {\n            imosEdge[getEdge(a, par[a])]++;\n        }\n        if (par[b] != -1) {\n            imosEdge[getEdge(b, par[b])]--;\n        }\n    }\n    int imosFinal(int v, int pre) {\n        int t = 0;\n        for (auto&& nxt : G[v]) {\n            if (nxt != pre && EdgeType[getEdge(nxt, v)] == USED_DFS) {\n                t += imosFinal(nxt, v);\n            }\n        }\n        if (pre != -1) imosEdge[getEdge(v, pre)] += t;\n        return pre == -1 ? 0 : imosEdge[getEdge(v, pre)];\n    }\n    int extractCC(int v, int color) {\n    \tif (cmp[v] != -1) return 0;\n    \tcmp[v] = color;\n    \tint t = 1;\n    \tfor (auto&& nxt : G[v]) {\n    \t\tif (EdgeType[getEdge(v, nxt)] != BRIDGE) {\n    \t\t\tt += extractCC(nxt, color);\n    \t\t}\n    \t}\n    \treturn t;\n    }\n    tuple<Graph, vector<int>, vector<int>> bicc() {\n        dfsTreeConstruct(0, -1);\n        for (auto&& p : EdgeType) {\n            Edge e;\n            int type;\n            tie(e, type) = p;\n            if (type == UNUSED) {\n                updateImos(e.first, e.second);\n            }\n        }\n        imosFinal(0, -1);\n        for (auto&& p : EdgeType) {\n            Edge e;\n            int type;\n            tie(e, type) = p;\n            if (type == USED_DFS) {\n                if (imosEdge[e] == 0) {\n                    EdgeType[e] = BRIDGE;\n                    bridges.emplace_back(e);\n                }\n            }\n        }\n\n\t\trep(i, n) {\n\t\t\tint size_cc = extractCC(i, num_cc);\n\t\t\tif (size_cc > 0) {\n\t\t\t\tsize_of_vertex.emplace_back(size_cc);\n\t\t\t\tnum_cc++;\n\t\t\t}\n\t\t}\n\n        // for this problem\n        wcmp.resize(num_cc);\n        rep(i, n) {\n            wcmp[cmp[i]] += w[i];\n        }\n\n\t \tvector<set<int>> G_cc_st(num_cc);\n\t\tfor (auto&& p : EdgeType) {\n            Edge e;\n            int type;\n            tie(e, type) = p;\n            if (type == BRIDGE) {\n\t\t\t\tG_cc_st[cmp[e.first]].insert(cmp[e.second]);\n\t\t\t\tG_cc_st[cmp[e.second]].insert(cmp[e.first]);\n            }\n        }\n\n\t\trep(i, num_cc) {\n\t\t\tG_cc.emplace_back(vector<int>(all(G_cc_st[i])));\n\t\t}\n\n        return make_tuple(G_cc, size_of_vertex, cmp);\n    }\n    vector<Edge> getBridges() {\n        return bridges;\n    }\n};\n\nGraph G;\nvi sz;\nvi cmp;\nint s;\nvector<int> cand;\nvector<bool> red;\n\nbool dfs(int now, int pre) {\n    bool ch_red = (now == s || sz[now] >= 2);\n    for (auto nxt : G[now]) {\n        if (nxt == pre) continue;\n        ch_red |= dfs(nxt, now);\n    }\n    return red[now] = ch_red;\n}\n\nvoid dfs2(int now, int pre, int sm) {\n    if (!red[now]) sm += wcmp[now];\n    if ((int)G[now].size() == 1 && !red[now]) {\n        cand.emplace_back(sm);\n        return;\n    }\n\n    for (auto nxt : G[now]) {\n        if (nxt == pre) continue;\n        dfs2(nxt, now, sm);\n    }\n}\n\nmain() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int n, m;\n    cin >> n >> m;\n    w.resize(n);\n    rep(i, n) cin >> w[i];\n    BICC bicc(n);\n    rep(i, m) {\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        bicc.addEdge(u, v);\n    }\n\n    tie(G, sz, cmp) = bicc.bicc();\n    int s = cmp[0];\n    int num_cc = sz.size();\n    red.resize(num_cc);\n    dfs(s, -1);\n\n    int sm_red = 0;\n    rep(i, n) {\n        if (red[cmp[i]]) {\n            sm_red += w[i];\n        }\n    }\n\n    dfs2(s, -1, 0);\n    int ma_path = (cand.empty() ? 0 : *max_element(all(cand)));\n\n    cout << sm_red + ma_path << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_V 100000\nusing namespace std;\nint m,w[100001];\nvector<int> vv[100001];\nunordered_set<int> st[100001];\nint V;\nvector<int> G[MAX_V];\nvector<int> rG[MAX_V];\nvector<int> vs;\nbool used[MAX_V];\nint cmp[MAX_V];\nint C[100001],F[100001],U[100001],ans;\nbool UU[100001];\n\n\nvoid DFS(int p){\n  for(int i=0;i<vv[p].size();i++){\n    int mn=min(vv[p][i],p),mx=max(vv[p][i],p);\n    if(st[mn].find(mx)==st[mn].end()){\n      st[mn].insert(mx);\n      G[p].push_back(vv[p][i]);\n      rG[vv[p][i]].push_back(p);\n      DFS(vv[p][i]);\n    }\n  }\n}\n\nvoid dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++)if(!used[G[v][i]])dfs(G[v][i]);\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v]=true;\n  cmp[v]=k;\n  for(int i=0;i<rG[v].size();i++)if(!used[rG[v][i]])rdfs(rG[v][i],k);\n}\n\nint scc(){\n  for(int v=0;v<V;v++)if(!used[v])dfs(v);\n  memset(used,0,sizeof(used));\n  int k=0;\n  for(int i=vs.size()-1;i>=0;i--)if(!used[vs[i]])rdfs(vs[i],k++);\n  return k;\n}\n\nbool DFS1(int p){\n  if(U[p])return 0;\n  U[p]=1;\n  bool f=F[cmp[p]]>=2;\n  for(int i=0;i<G[p].size();i++)\n    f|=DFS1(G[p][i]);\n  ans+=w[p]*f;\n  return UU[p]=f;\n}\nbool UUU[100001];\nint DFS2(int p){\n  if(UUU[p])return 0;\n  UUU[p]=1;\n  int res=0;\n  \n  for(int i=0;i<G[p].size();i++)\n    res=max(res,DFS2(G[p][i]));  \n  return res+(UU[p]?0:w[p]);\n}\n\nint main(){\n  cin>>V>>m;\n  for(int i=0;i<V;i++)cin>>w[i];\n  for(int j=0,a,b;j<m;j++){\n    cin>>a>>b;a--,b--;\n    vv[a].push_back(b),vv[b].push_back(a);\n  }\n  DFS(0);\n  int t=0;\n  for(int i=0;i<V;i++)t+=w[i];\n  scc();\n  for(int i=0;i<V;i++)F[cmp[i]]++;\n  DFS1(0);\n  cout<<ans+DFS2(0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(i,v.size())cout<<\" \"<<v[i];cout<<endl<<endl;\n#define show2d(v) rep(i,v.size()){rep(j,v[i].size())cout<<\" \"<<v[i][j];cout<<endl;}cout<<endl;\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n//#define mt make_tuple\n//typedef tuple<int,int,int> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};//ESWN\nmap<pii,int>ma;\nclass BRI{\n\tpublic:\n\t\tint N;\n\t\tvi used;\n\t\tvvi G;\n\t\tvp bridge;\n\t\tvoid add_edge(int s, int t){\n\t\t\tG[s].pb(t);\n\t\t\tG[t].pb(s);\n\t\t}\n\t\tBRI(int size){\n\t\t\tN=size;\n\t\t\tG=vvi(N);\n\t\t}\n\tint dfs(int i, int prev,int &n){\n\t\tif(used[i])return used[i];\n\t\tint m=n;\n\t\tused[i]=n++;\n\t\trep(j,G[i].size()){\n\t\t\tif(prev==G[i][j])continue;\n\t\t\tif(used[i]<used[G[i][j]])continue;\n\t\t\tint res=dfs(G[i][j],i,n);\n\t\t\tm=min(m,res);\n\t\t\tif(used[i]<res)bridge.pb(pii(min(i,G[i][j]),max(i,G[i][j])));\n\t\t}\n\t\treturn m;\n\t}\n\tvoid bri(){\n\t\tused=vi(N);\n\t\tbridge=vp(0);\n\t\tint n=1;\n\t\tdfs(0,-1,n);\n\t\trep(i,bridge.size()){\n\t\t\tma[bridge[i]]=true;\n\t\t\tma[{bridge[i].second,bridge[i].first}]=true;\n\t\t}\n\t}\t\n};\nvi sum,used,to,w,c;\nvvi G,tG;\nint t;\nvoid dfs(int a){\n\tto[a]=t;\n\tsum[t]+=w[a];\n\tused[a]=true;\n\tc[t]++;\n\trep(i,G[a].size())if(used[G[a][i]]==0){\n\t\tif(ma[{a,G[a][i]}])continue;\n\t\tdfs(G[a][i]);\n\t}\n}\npii dfs1(int a){\n\tused[a]=1;\n\tint out1=0,out2=0;\n\trep(i,tG[a].size())if(used[tG[a][i]]==0){\n\t\tpii t=dfs1(tG[a][i]);\n\t\tout1=max(out1,t.first);\n\t\tout2+=t.second;\n\t}\n\tif(out2||c[a]-1)out2+=sum[a];\n\tif(out2==0)out1+=sum[a];\n\treturn {out1,out2};\n}\nint main(){\n\tint n,m;\n\tcin>>n>>m;\n\tw=vi(n);\n\trep(i,n)cin>>w[i];\n\tBRI bri(n);\n\twhile(m--){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\ta--;b--;\n\t\tbri.add_edge(a,b);\n\t}\n\tbri.bri();\n\t\n\tt=0;\n\tused=to=vi(n);\n\tG=bri.G;\n\trep(i,n)if(used[i]==0){\n\t\tsum.pb(0);\n\t\tc.pb(0);\n\t\tdfs(i);t++;\n\t}\n\ttG=vvi(sum.size());\n\trep(i,bri.bridge.size()){\n\t\tpii a=bri.bridge[i];\n\t\ttG[to[a.first]].pb(to[a.second]);\n\t\ttG[to[a.second]].pb(to[a.first]);\n\t}\n//\tshow2d(tG);\n\tused=vi(tG.size());\n\tpii out=dfs1(0);\n\tcout<<out.first+out.second<<endl;\n}\n\t\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1e9 + 7;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<class T>\nistream& operator >> (istream& is, vector<T>& v)\n{\n\tfor (auto &i : v) is >> i;\n\treturn is;\n}\ntemplate<class T>\nostream& operator<<(ostream& os, vector<T>& v)\n{\n\tconst string delimiter = \"\\n\";\n\tREP(i, v.size())\n\t{\n\t\tos << v[i];\n\t\tif (i != v.size() - 1) os << delimiter;\n\t}\n\treturn os;\n}\n/*--------------------template--------------------*/\n\nint main()\n{\n\tcin.sync_with_stdio(false); cout << fixed << setprecision(10);\n\tint n, m; cin >> n >> m;\n\tvi w(n);\n\tcin >> w;\n\tvector<vi> g(n);\n\tREP(i, m)\n\t{\n\t\tint a, b; cin >> a >> b;\n\t\ta--; b--;\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\tvi v;\n\tll ans = w[0];\n\tFOR(i, 1, n)\n\t{\n\t\tif (g[i].size() == 1) v.push_back(w[i]);\n\t\telse ans += w[i];\n\t}\n\tif(v.size() > 0) ans += *max_element(ALL(v));\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<utility>\n\nusing namespace std;\n\ntypedef pair<int, int> Pii;\n\nvector<int> graph[100001];\nvector<int> dim(100001, 0);\nvector<Pii> nodes(100001);\nvector<bool> used(100001, false);\n\nint dfs(int node, int prev){\n    used[node] = true;\n    int max_cost = 0, not_zero = 0, cost;\n    nodes[node].second = 0;\n    for(int nxt: graph[node]){\n        if(nxt == prev || used[nxt]) continue;\n        cost = dfs(nxt, node);\n        if(cost){\n            not_zero++;\n            dim[node]--;\n        }\n        max_cost = max(max_cost, cost);\n    }\n    nodes[node].second = max_cost;\n\n    if(dim[node] == 1 && node != 0){\n        int total = nodes[node].first + nodes[node].second;\n        nodes[node].first = 0;\n        return total;\n    }\n    return 0;\n}\n\nint main(){\n    int n,m;\n    cin >> n >> m;\n    for(int i=0;i<n;i++) cin >>nodes[i].first;\n\n    int a,b;\n    for(int i=0;i<m;i++){\n        cin >> a >> b;\n        a--; b--;\n        graph[a].push_back(b);\n        graph[b].push_back(a);\n        dim[a]++;\n        dim[b]++;\n    }\n\n    dfs(0, -1);\n\n    int ans = 0, max_second = 0;\n    for(int i=0;i<n;i++){\n        ans += nodes[i].first;\n        if(nodes[i].first != 0) max_second = max(max_second, nodes[i].second);\n    }\n    ans += max_second;\n    cout << ans << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<(int)(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\nstruct Edge {\n  int src, dest, weight;\n};\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\nvoid add_edge(Graph &g, int src, int dest, int weight = 0) {\n  g[src].push_back((Edge){src,dest,weight});\n  g[dest].push_back((Edge){dest,src,weight});\n}\n\nint dfs1(const Graph& g, vector<int>& vw, const vector<bool>& in_loop, int i, int prev = -1) {\n  if (i == 0) {\n    int tmp = vw[i];\n    vw[i] = 0;\n    return tmp;\n  }\n  int res = 0;\n  for (Edge e : g[i]) {\n    if (e.dest == prev) continue;\n    if (!in_loop[e.dest]) {\n      res = max(res, dfs1(g, vw, in_loop, e.dest, e.src));\n    }\n  }\n  if (res > 0) {\n    int tmp = vw[i];\n    vw[i] = 0;\n    return res + tmp;\n  } else return 0;\n}\n\nint dfs2(const Graph& g, const vector<int>& vw, const vector<bool>& in_loop, int i, int prev = -1) {\n  if (g[i].size() == 1) return vw[i];\n  int res = 0;\n  for (Edge e : g[i]) {\n    if (e.dest == prev) continue;\n    if (!in_loop[e.dest]) {\n      res = max(res, dfs2(g, vw, in_loop, e.dest, e.src));\n    }\n  }\n  return res + vw[i];\n}\n\nint main() {\n  int n,m;\n  cin>>n>>m;\n  vector<int> vw(n);\n  REP(i,n) cin>>vw[i];\n  Graph g(n);\n  REP(i,m) {\n    int u,v;\n    cin>>u>>v;\n    --u; --v;\n    add_edge(g, u, v);\n  }\n  vector<int> nume(n);\n  queue<int> que;\n  REP(i,n) {\n    nume[i] = g[i].size();\n    if (nume[i] == 1) {\n      que.push(i);\n    }\n  }\n  vector<bool> in_loop(n, true);\n  while(!que.empty()) {\n    int i = que.front();\n    que.pop();\n    in_loop[i] = false;\n    //if (nume[i] == 0) continue;\n    for (Edge e : g[i]) {\n      --nume[e.dest];\n      if (nume[e.dest] == 1) {\n        que.push(e.dest);\n      }\n    }\n  }\n  int res = 0;\n  REP(i,n) {\n    if (in_loop[i]) {\n      res += vw[i];\n      vw[i] = 0;\n      res += dfs1(g, vw, in_loop, i);\n    }\n  }\n  if (res > 0) {\n    int edgescore = 0;\n    REP(i,n) {\n      if (in_loop[i]) {\n        edgescore = max(edgescore, dfs2(g, vw, in_loop, i));\n      }\n    }\n    cout << res + edgescore << endl;\n  } else {\n    cout << dfs2(g, vw, in_loop, 0) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n\nusing VS = vector<string>;    using LL = long long;\nusing VI = vector<int>;       using VVI = vector<VI>;\nusing PII = pair<int, int>;   using PLL = pair<LL, LL>;\nusing VL = vector<LL>;        using VVL = vector<VL>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n#define FOR(i, s, e) for (int(i) = (s); (i) < (e); (i)++)\n#define FORR(i, s, e) for (int(i) = (s); (i) > (e); (i)--)\n#define debug(x) cerr << #x << \": \" << x << endl\nconst int INF = 1e9;                          const LL LINF = 1e16;\nconst LL MOD = 1000000007;                    const double PI = acos(-1.0);\nint DX[8] = { 0, 0, 1, -1, 1, 1, -1, -1 };    int DY[8] = { 1, -1, 0, 0, 1, -1, 1, -1 };\n\n/*-----------------------------------------------\n 二辺連結成分分解 成分だけ unverified\n -----------------------------------------------*/\nstruct UnionFind {\n    vector<int> data;\n    UnionFind(int n) { data.assign(n, -1); }\n    bool unionSet(int x, int y) {\n        x = root(x); y = root(y);\n        if (x != y) {\n            if (data[y] < data[x]) swap(x, y);\n            data[x] += data[y]; data[y] = x;\n        }\n        return x != y;\n    }\n    bool same(int x, int y) { return root(x) == root(y); }\n    int root(int x) { return data[x] < 0 ? x : data[x] = root(data[x]); }\n    int size(int x) { return -data[root(x)]; }\n};\n\nstruct Lowlink {\n    UnionFind uf;\n    vector<int> low, ord, used, parent;\n    int root, k;\n    Lowlink(int V, int Root) :uf(V), low(V), ord(V), used(V), parent(V), root(Root), k(0) {}\n    \n    void lowlink(int v, int p, int &k, vector<vector<int>>& G) {\n        used[v] = true; //visited\n        low[v] = ord[v] = k; k++;\n        for (int i = 0; i < (int)G[v].size(); i++) {\n            int u = G[v][i];\n            if (used[u] == 0) {\n                parent[u] = v;\n                lowlink(u, v, k, G);\n                low[v] = min(low[v], low[u]);\n                if (ord[v] >= low[u])uf.unionSet(v, u);\n            }\n            else if (u != p) {\n                low[v] = min(low[v], ord[u]);\n            }\n        }\n    }\n};\n\nstruct TwoEdgeConnectedComponent:Lowlink{\n //   UnionFind uf;\n    vector<vector<int>> g;\n    vector<pair<int, int>> edges;\n//    vector<int> used, ord, low\n    vector<int> comp;\n    int v;\n    TwoEdgeConnectedComponent(int v) : g(v),comp(v),v(v),Lowlink(v,0) {}\n    \n    void add_edge(int x, int y) {\n        g[x].push_back(y);\n        g[y].push_back(x);\n        edges.push_back(minmax(x, y));\n    }\n    \n    void dfs(int idx, int& k, int par = -1) {\n        used[idx] = true;\n        ord[idx] = k++;\n        low[idx] = ord[idx];\n        \n        for (auto &to : g[idx]) {\n            if (!used[to]) {\n                dfs(to, k, idx);\n                low[idx] = min(low[idx], low[to]);\n                if (ord[idx] >= low[to]) uf.unionSet(idx, to);\n            }\n            else if (to != par) {\n                low[idx] = min(low[idx], ord[to]);\n            }\n        }\n    }\n    \n    // return origin color\n    int operator[](int k) {\n        return (comp[k]);\n    }\n    \n    int size() {\n        return (g.size());\n    }\n    \n    // build, renew resG(empty -> tree), return color\n    vector<int> get_graph(vector<vector<int>>& resG,VI& W,VI& resW,int root = 0) {\n        int kk = 0;\n        Lowlink::lowlink(root, -1, kk, g);\n//        dfs(root, kk);\n//        Lowlink Low(v,0);\n//        Low.lowlink(root, -1, kk, g);\n//        auto uf = Low.uf;\n        int ptr = 0;\n        vector<int> color(g.size());\n        for (int i = 0; i < g.size(); i++) {\n            if (i == uf.root(i)) color[i] = ptr++;\n        }\n        \n        resG.resize(ptr);\n        for (int i = 0; i < g.size(); i++) {\n            comp[i] = color[uf.root(i)];\n        }\n        \n        resW.resize(ptr);\n        for (int i = 0; i < (int)g.size(); i++) {\n            comp[i] = color[uf.root(i)];\n            // 頂点番号における写像を作る\n            resW[comp[i]] += W[i];//重みをまとめる\n        }\n        for (auto &e : edges) {\n            int x = comp[e.first], y = comp[e.second];\n            if (x == y) continue;\n            resG[x].push_back(y);\n            resG[y].push_back(x);\n        }\n        return comp;\n    }\n};\n\nLL dfs(int v, int p, VVI& G, VL& dp, VI& w) {\n    LL res = 0;\n    FOR(i, 0, SZ(G[v])) {\n        int nx = G[v][i];\n        if (nx == p)continue;\n        res = max(res, dfs(nx, v, G, dp, w));\n    }\n    return dp[v] = res + w[v];\n}\n\nint main() {\n    int N, M;\n    vector<vector<int>> resG;\n\n    cin >> N >> M;\n    VI W(N);\n    FOR(i, 0, N) {\n        cin >> W[i];\n    }\n    \n    \n    TwoEdgeConnectedComponent gx(N);\n    FOR(i, 0, M) {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        gx.add_edge(a, b);\n    }\n    VI resW;\n    VI vc = gx.get_graph(resG,W,resW);\n    \n    VL dp(N,0);\n    LL ans = dfs(0,-1,resG,dp,resW);\n//    weightSum.assign(resG.size(), 0);\n//    sz.assign(resG.size(), 0);\n//    for (int i = 0; i < N; i++) {\n//        weightSum[vc[i]] += W[i];\n//        sz[vc[i]]++;\n//    }\n//    f(vc[0]);\n//    LL ans = dp3[vc[0]];\n    cout << ans << endl;\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <map>\nusing namespace std;\nusing pii = pair<ll, ll>;\n\nstruct Graph {\n    Graph(const ll n)\n    {\n        edge.resize(n);\n        revedge.resize(n);\n    }\n    void addEdge(const ll from, const ll to)\n    {\n        edge[from].push_back(to);\n        revedge[to].push_back(from);\n    }\n    vector<vector<ll>> edge;\n    vector<vector<ll>> revedge;\n};\n\nvoid depth_dfs(const Graph& g, Graph& dig, map<pii, ll>& diedge, map<pii, ll>& resedge, const ll s, vector<ll>& depth, vector<bool>& used, const ll deg)\n{\n    depth[s] = deg;\n    for (const ll to : g.edge[s]) {\n        if (not used[to]) {\n            used[to] = true;\n            dig.addEdge(s, to);\n            diedge[make_pair(s, to)] = 0;\n            resedge.erase(make_pair(s, to));\n            resedge.erase(make_pair(to, s));\n            depth_dfs(g, dig, diedge, resedge, to, depth, used, deg + 1);\n        }\n    }\n}\n\nvoid accum(const Graph& dig, const ll s, map<pii, ll>& diedge)\n{\n    for (const ll to : dig.edge[s]) {\n        ll sum = 0;\n        accum(dig, to, diedge);\n        for (const ll to2 : dig.edge[to]) {\n            sum += diedge[make_pair(to, to2)];\n        }\n        diedge[make_pair(s, to)] += sum;\n    }\n}\n\nvoid cc_dfs(const Graph& newg, const ll s, vector<ll>& comp, vector<bool>& visited, const ll cnum)\n{\n    visited[s] = true;\n    comp[s] = cnum;\n    for (const ll to : newg.edge[s]) {\n        cc_dfs(newg, to, comp, visited, cnum);\n    }\n}\n\nvoid decomp(const Graph& dig, Graph& decomped, const ll s, const vector<ll>& comp, set<pii>& decomped_edge)\n{\n    const ll c1 = comp[s];\n    for (const ll to : dig.edge[s]) {\n        decomp(dig, decomped, to, comp, decomped_edge);\n        const ll c2 = comp[to];\n        if (c1 != c2 and decomped_edge.find(make_pair(c1, c2)) == decomped_edge.end()) {\n            decomped_edge.insert(make_pair(c1, c2));\n            decomped.addEdge(c1, c2);\n        }\n    }\n}\n\nll weight_dfs(const Graph& decomped, const ll s, const vector<ll>& weight)\n{\n    ll maxi = 0;\n    for (const ll to : decomped.edge[s]) {\n        maxi = max(maxi, weight_dfs(decomped, to, weight));\n    }\n    return weight[s] + maxi;\n}\n\nint main()\n{\n    ll N, M;\n    cin >> N >> M;\n    Graph g(N);\n    vector<ll> w(N);\n    for (ll i = 0; i < N; i++) {\n        cin >> w[i];\n    }\n    map<pii, ll> edges;\n    for (ll i = 0; i < M; i++) {\n        ll u, v;\n        cin >> u >> v;\n        u--, v--;\n        g.addEdge(u, v);\n        g.addEdge(v, u);\n        edges[make_pair(u, v)] = 0;\n        edges[make_pair(v, u)] = 0;\n    }\n    Graph dig(N);\n    map<pii, ll> diedge;\n    map<pii, ll> resedge = edges;\n    vector<ll> depth(N, 0);\n    vector<bool> used(N, false);\n    used[0] = true;\n    depth_dfs(g, dig, diedge, resedge, 0, depth, used, 0);\n    map<pii, ll> resedge_ = resedge;\n    resedge.clear();\n    for (const auto& e : resedge_) {\n        const ll u = e.first.first;\n        const ll v = e.first.second;\n        if (resedge.find(make_pair(v, u)) == resedge.end()) {\n            resedge[make_pair(u, v)] = 0;\n        }\n    }\n    for (const auto& e : resedge) {\n        const ll u = e.first.first;\n        const ll v = e.first.second;\n        ll a;\n        ll b;\n        if (depth[u] < depth[v]) {\n            b = u;\n            a = v;\n        } else {\n            b = v;\n            a = u;\n        }\n        if (not dig.revedge[b].empty()) {\n            const ll par = dig.revedge[b][0];\n            diedge[make_pair(par, b)]--;\n        }\n        const ll par = dig.revedge[a][0];\n        diedge[make_pair(par, a)]++;\n    }\n    vector<ll> node(N, 0);\n    accum(dig, 0, diedge);\n    Graph newg(N);\n    for (const auto& e : diedge) {\n        if (e.second != 0) {\n            const ll u = e.first.first;\n            const ll v = e.first.second;\n            newg.addEdge(u, v);\n        }\n    }\n    vector<bool> visited(N, false);\n    vector<ll> comp(N, 0);\n    ll cnum = 0;\n    for (ll i = 0; i < N; i++) {\n        if (not visited[i]) {\n            cc_dfs(newg, i, comp, visited, cnum);\n            cnum++;\n        }\n    }\n    vector<ll> weight(cnum, 0);\n    for (ll i = 0; i < N; i++) {\n        const ll c = comp[i];\n        weight[c] += w[i];\n    }\n    set<pii> decomped_edge;\n    Graph decomped(cnum);\n    decomp(dig, decomped, 0, comp, decomped_edge);\n\n    cout << weight_dfs(decomped, 0, weight) << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) begin(v), end(v)\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, s, n) for(int i = (int)(s); i < (int)(n); i++)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing pint = pair<int, int>;\nusing tint = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nstruct UnionFind {\n  vector<int> data;\n  UnionFind(){}\n  UnionFind(int sz):data(sz, -1){}\n  int find(int x) {\n    return data[x] < 0 ? x : data[x] = find(data[x]);\n  }\n  int size(int x) {\n    return -data[find(x)];\n  }\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n  bool unite(int x, int y) {\n    x = find(x), y = find(y);\n    if(x == y) return false;\n    if(data[x] < data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n    return true;\n  }\n};\n\n#define MAX_N 100000\n\nint N, M;\nint w[MAX_N];\nvector<int> graph[MAX_N];\n\nUnionFind uf;\nvector< pair<int, int> > edges;\nbool vis[MAX_N];\nint ord[MAX_N], low[MAX_N], cmp[MAX_N];\nvector<int> tree[MAX_N];\n\nint val[MAX_N];\nint sz[MAX_N];\n\nvoid dfs(int u, int p, int &k) {\n  vis[u] = true;\n  ord[u] = low[u] = k++;\n  for(int v : graph[u]) {\n    if(!vis[v]) {\n      dfs(v, u, k);\n      chmin(low[u], low[v]);\n      if(ord[u] >= low[v]) uf.unite(u, v);\n    } else if(v != p) {\n      chmin(low[u], ord[v]);\n    }\n  }\n}\n\nvoid compose() {\n  int k = 0;\n  uf = UnionFind(N);\n  dfs(0, -1, k);\n  int num = 0, conn[MAX_N];\n  rep(u, N) if(u == uf.find(u)) conn[u] = num++;\n  rep(u, N) cmp[u] = conn[uf.find(u)];\n  for(auto e : edges) {\n    int x = cmp[e.first], y = cmp[e.second];\n    if(x == y) continue;\n    tree[x].push_back(y);\n    tree[y].push_back(x);\n  }\n}\n\nint dp1[MAX_N]; // modoreru\nint dp2[MAX_N]; // modoranai\n\nint solve(int u, int p) {\n  int res = 0;\n  for(int v : tree[u]) {\n    if(v == p) continue;\n    chmax(res, solve(v, u));\n    dp1[u] += dp1[v];\n  }\n  if(sz[u] >= 3 || dp1[u] > 0) dp1[u] += val[u];\n  res += val[u];\n  for(int v : tree[u]) {\n    if(v == p) continue;\n    chmax(res, dp1[u]-dp1[v]+dp2[v]);\n  }\n  return dp2[u] = res;\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin >> N >> M;\n  rep(i, N) cin >> w[i];\n  rep(i, M) {\n    int u, v;\n    cin >> u >> v; --u, --v;\n    graph[u].push_back(v);\n    graph[v].push_back(u);\n    edges.emplace_back(minmax(u, v));\n  }\n  compose();\n  rep(u, N) {\n    val[cmp[u]] += w[u];\n    sz[cmp[u]] = uf.size(u);\n  }\n  cout << solve(cmp[0], -1) << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\nint dfs(vector<vector<int>>& g, vector<int>& w, vector<bool>& used, int pos){\n\tused[pos] = true;\n\tint res = w[pos];\n\tfor(auto to : g[pos]){\n\t\tif(used[to]) continue;\n\t\tres += dfs(g, w, used, to);\n\t}\n\treturn res;\n}\n\nint main(){\n\tint n, m;\n\tcin >> n >> m;\n\n\tvector<int> w(n);\n\tcin >> w;\n\n\n\tvector<vector<int>> g(n);\n\tvector<int> in(n,0);\n\trep(i,m){\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tu--; v--;\n\t\tg[u].emplace_back(v);\n\t\tg[v].emplace_back(u);\n\t\tin[u]++;\n\t\tin[v]++;\n\t}\n\n\tbool loop = true;\n\tvector<int> cg(n,0);\n\n\tint ans = accumulate(all(w), 0);\n\twhile(loop){\n\t\tloop = false;\n\t\trange(i,1,n){\n\t\t\tif(in[i] == 1){\n\t\t\t\tin[i] = 0;\n\t\t\t\tcg[i] = i;\n\t\t\t\tans -= w[i];\n\t\t\t\tloop = true;\n\t\t\t\tfor(auto j : g[i]){\n\t\t\t\t\tif(j == 0) continue;\n\t\t\t\t\tin[j]--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<vector<int>> ng(n);\n\trep(i,n){\n\t\tfor(auto j : g[i]){\n\t\t\tif(cg[i] == 0 and cg[j] == 0) continue;\n\t\t\tng[ cg[i] ].emplace_back( cg[j] );\n\t\t\tng[ cg[j] ].emplace_back( cg[i] );\n\t\t}\n\t}\n\n\tvector<bool> used(n,0);\n\tused[0] = true;\n\tw[0] = 0;\n\tint maxi = 0;\n\tfor(auto i : ng[0]){\n\t\tmaxi = max(maxi, dfs(ng, w, used, i));\n\t}\n\tcout << ans + maxi << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n\n//int dp[100000];\n\nclass Graph{\npublic:\n  int n;\n  vector<vector<int> > e;\n  vector<int> w,vdeg;\n\n  Graph(int v){\n    n = v;\n    w = vector<int>(n,0);\n    vdeg = vector<int>(n,0);\n    e = vector<vector<int> >(n,vector<int>(0));\n  }\n\n  void setWeight(int v, int ww){\n    w[v] = ww;\n  }\n\n  void addEdge(int a, int b){\n    e[a].push_back(b);\n    e[b].push_back(a);\n    vdeg[a]++;\n    vdeg[b]++;\n  }\n\n  int degree(int u){\n    return (int)e[u].size();\n  }\n\n  bool isConnected(int u, int v){\n    auto itr = find(e[u].begin(),e[u].end(),v);\n    if(itr == e[u].end()) return false;\n    return true;\n  }\n\n};\n\nclass Tree{\npublic:\n  int n,mc=0;\n  // int par[100000];\n  // vector<int> child[100000];\n  // int w[100000];\n  vector<int> par,w,cost;\n  vector<vector<int> > child;\n\n  Tree(int v){\n    n = v;\n    par = vector<int>(n,-1);\n    w = vector<int>(n,0);\n    cost = vector<int>(n,0);\n    child = vector<vector<int> >(n,vector<int>(0));\n  }\n\n  void setWeight(int v, int ww){\n    w[v] = ww;\n  }\n\n  void setCost(int v, int c){\n    cost[v] = c;\n    mc = max(mc,c);\n  }\n\n  void addCost(int v, int c){\n    cost[v] += c;\n    mc = max(mc,cost[v]);\n  }\n\n  void addEdge(int pr,int chi){\n    child[pr].push_back(chi);\n    par[chi] = pr;\n  }\n\n  int childsize(int u){\n    return (int)child[u].size();\n  }\n};\n\nint main(){\n\n  int n,m;\n  cin >> n >> m;\n  Graph g(n);\n  vector<int> tour(n,1);\n  rep(i,n){\n    int w;\n    cin >> w;\n    g.setWeight(i,w);\n  }\n  rep(i,m){\n    int u,v;\n    cin >> u >> v;\n    u--;v--;\n    g.addEdge(u,v);\n  }\n\n  // 次数1の頂点を消していく\n  queue<int> que;\n  rep(i,n){\n    if(g.degree(i)==1)que.push(i);\n  }\n  while(!que.empty()){\n    int i = que.front();\n    que.pop();\n    tour[i] = 0;\n    rep(j,g.e[i].size()){\n      int to = g.e[i][j];\n      if(tour[to]){\n        g.vdeg[to]--;\n        if(g.vdeg[to]==1)que.push(to);\n      }\n    }\n    // int nn = g.e[i][0];\n    // if(g.degree(nn)<=2&&tour[nn]==1)que.push(nn);\n  }\n  \n  int cent = 0;\n  int w = 0;\n  rep(i,n)if(tour[i]==1){cent++;w+=g.w[i];}\n  \n  vector<int> inds(n);\n  int index = 0;\n  rep(i,n){\n    if(tour[i]==0){\n      inds[i] = index;\n      index++;\n    }\n  }\n\n  int nt = n-cent+1;\n  Graph t(nt);\n  if (cent>0){\n    t.setWeight(nt-1,w);\n  }\n  index = 0;\n  rep(i,n){\n    if (tour[i]==0){\n      t.setWeight(inds[i],g.w[i]);\n      rep(j,g.e[i].size()){\n        if(tour[g.e[i][j]]==0&&!t.isConnected(inds[i],inds[g.e[i][j]])){\n          t.addEdge(inds[i],inds[g.e[i][j]]);\n        } else if (tour[g.e[i][j]]==1) {\n          t.addEdge(inds[i],nt-1);\n        }\n      }\n    }\n  }\n  int rt;\n  if (tour[0]==0){rt = inds[0];}\n  else {rt = nt-1;}\n  // 根付き木にする\n  Tree tr(nt);\n  rep(i,nt){\n    tr.setWeight(i,t.w[i]);\n  }\n  vector<bool> visited(nt);\n  que.push(rt);\n  while(!que.empty()){\n    int v = que.front();\n    que.pop();\n    visited[v] = true;\n    rep(i,t.e[v].size()){\n      if(!visited[t.e[v][i]]){\n        que.push(t.e[v][i]);\n        tr.addEdge(v,t.e[v][i]);\n      }\n    }\n  }\n  // BFS\n  rep(i,nt)tr.setCost(i,tr.w[i]);\n  que.push(rt);\n  while(!que.empty()){\n    int u = que.front();\n    que.pop();\n    if(tr.par[u]!=-1){\n      tr.addCost(u,tr.cost[tr.par[u]]);\n    }\n    rep(v,tr.child[u].size()){\n      que.push(tr.child[u][v]);\n    }\n  }\n  cout << tr.mc << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n#define mod 1000000007\n\nint n,m;\nint w[100010];\nvector<P> g[100010];\nvector<int> g2[100010];\nint ord[100010],low[100010],par[100010];\nbool vis[100010];\nint crt=0;\nvector<P> bs;\n\nvoid dfs(int v,int pre){\n  ord[v]=crt++;\n  low[v]=ord[v];\n  for(P& e : g[v]){\n    int nv=e.fi;\n    if(ord[nv]!=-1&&nv!=pre){\n      minch(low[v],ord[nv]);\n      continue;\n    }else if(ord[nv]==-1){\n      dfs(nv,v);\n      minch(low[v],low[nv]);\n      if(ord[v]<low[nv]){\n        bs.push_back(P(v,nv));\n        e.se=1;\n      }\n    }\n  }\n}\n\nvoid dfs2(int v,int f){\n  vis[v]=true;\n  if(f!=v)w[f]+=w[v];\n  par[v]=f;\n  for(P& e : g[v]){\n    int nv=e.fi;\n    if(e.se||vis[nv])continue;\n    dfs2(nv,f);\n  }\n}\n\nint dfs3(int v,int pre){\n  int res=0;\n  for(int nv : g2[v]){\n    if(nv==pre)continue;\n    maxch(res,dfs3(nv,v));\n  }\n  return res+w[v];\n}\n\nint main(){\n  cin>>n>>m;\n  rep(i,n)cin>>w[i];\n  rep(i,m){\n    int a,b;\n    cin>>a>>b;\n    a--;b--;\n    g[a].push_back(P(b,0));\n    g[b].push_back(P(a,0));\n  }\n  memset(ord,-1,sizeof(ord));\n  dfs(0,-1);\n  sort(all(bs));\n  uni(bs);\n  memset(par,-1,sizeof(par));\n  rep(i,n){\n    if(vis[i])continue;\n    dfs2(i,i);\n  }\n  rep(i,bs.size()){\n    int u=bs[i].fi,v=bs[i].se;\n    g2[par[u]].push_back(par[v]);\n    g2[par[v]].push_back(par[u]);\n  }\n  cout<<dfs3(par[0],-1)<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\n\nll dfs(ll v, vector<vector<ll>> &E, vector<ll> &W, vector<bool> &visited) {\n  if(visited[v]) return 0;\n  visited[v] = true;\n\n  ll ret = 0;\n  for(ll u : E[v]) ret = max(ret, dfs(u, E, W, visited));\n  return ret + W[v];\n}\n\nint main(void) {\n  ll N, M;\n  cin >> N >> M;\n  vector<ll> W(N), U(M), V(M);\n  vector<vector<ll>> E(N);\n  REP(i, 0, N) cin >> W[i];\n  REP(i, 0, M) {\n    cin >> U[i] >> V[i]; U[i]--; V[i]--;\n    E[U[i]].push_back(V[i]);\n    E[V[i]].push_back(U[i]);\n  }\n\n  vector<ll> cnt(N, 0);\n  REP(i, 0, N) cnt[i] = E[i].size();\n  queue<ll> q;\n  REP(i, 0, N) if(cnt[i] == 1) q.push(i);\n\n  vector<bool> check(N, false), root(N, false);\n  while(q.size()) {\n    ll v = q.front();\n    q.pop();\n\n    check[v] = true;\n    root[v] = true;\n    for(ll u : E[v]) if(--cnt[u] == 1) {\n      q.push(u);\n      root[v] = false;\n    }\n  }\n\n  ll ans = 0;\n  vector<bool> visited(N, false);\n  REP(i, 0, N) if(!check[i]) visited[i] = true;\n  REP(i, 0, N) if(root[i]) ans = max(ans, dfs(i, E, W, visited));\n  REP(i, 0, N) if(!check[i]) ans += W[i];\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n#define MAX 100005\n\nint p[MAX];\n\nint find(int x){\n  if(p[x]==x)return x;\n  return p[x]=find(p[x]);\n}\n\nvoid unite(int x,int y){\n  x=find(x);y=find(y);\n  if(x==y)return;\n  p[x]=y;\n}\n\nbool same(int x,int y){\n  return (find(x)==find(y));\n}\n\nint V,E;\nvector<int> G[MAX];\nvector<int> nG[MAX];\nmap<int,bool> used[MAX];\n\nint s[MAX],t[MAX];\nint depth[MAX];\nint cnt[MAX];\nint visited[MAX];\n\n\n\nvoid dfs(int pos,int prev){\n  visited[pos]=true;\n  for(int i=0;i<(int)G[pos].size();i++){\n    int to=G[pos][i];\n    if(to==prev)continue;\n    if(!visited[to]){\n      depth[to]=depth[pos]+1;\n      dfs(to,pos);\n      cnt[pos]+=cnt[to];\n      if(cnt[to])unite(pos,to);\n    }else if(depth[to]<depth[pos]){\n      unite(pos,to);\n      cnt[pos]++;\n      cnt[to]--;\n    }else{\n      unite(pos,to);\n    }\n  }\n}\n\nint solve(int pos,int prev=-1){\n  int res=0;\n  for(int i=0;i<(int)nG[pos].size();i++){\n    int to=nG[pos][i];\n    if(to==prev || to==pos)continue;\n    res=max(res,solve(to,pos));\n  }\n  return res+t[pos];\n}\n\nint main(){\n  scanf(\"%d %d\",&V,&E);\n  for(int i=0;i<V;i++){\n    scanf(\"%d\",&s[i]);\n    p[i]=i;\n  }\n  for(int i=0;i<E;i++){\n    int a,b;\n    scanf(\"%d %d\",&a,&b);\n    a--,b--;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n  dfs(0,-1);\n  for(int pos=0;pos<V;pos++){\n\n    for(int i=0;i<(int)G[pos].size();i++){\n      int to=find(G[pos][i]);\n      if(used[pos].count(to)>0)continue;\n      used[pos][to]=true;\n      nG[ find(pos) ].push_back( to );\n    }\n    t[ find(pos) ]+=s[pos];\n  }\n  \n  printf(\"%d\\n\",solve( find(0) ));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 100000\n\nstruct Info{\n\tInfo(){\n\t\tnode_id = pre_node = sum_value = 0;\n\t}\n\n\tInfo(int arg_node_id,int arg_pre_node,int arg_sum_value){\n\t\tnode_id = arg_node_id;\n\t\tpre_node = arg_pre_node;\n\t\tsum_value = arg_sum_value;\n\t}\n\tbool operator<(const struct Info &arg) const{\n\t\treturn sum_value < arg.sum_value;\n\t}\n\n\tint node_id,pre_node,sum_value;\n};\n\nint N,M;\nint root;\nint value[NUM],in_num[NUM],max_value[NUM];\nbool is_cicle[NUM];\nvector<int> G[NUM];\n\nint main(){\n\n\tscanf(\"%d %d\",&N,&M);\n\n\tfor(int i = 0; i < N; i++)scanf(\"%d\",&value[i]);\n\n\tfor(int i = 0; i < N; i++)in_num[i] = 0;\n\n\troot = 0;\n\tint from,to;\n\n\tfor(int loop = 0; loop < M; loop++){\n\t\tscanf(\"%d %d\",&from,&to);\n\t\tfrom--;\n\t\tto--;\n\t\tG[from].push_back(to);\n\t\tG[to].push_back(from);\n\t\tin_num[from]++;\n\t\tin_num[to]++;\n\t}\n\n\tfor(int i = 0; i < N; i++)is_cicle[i] = true;\n\n\tqueue<int> CALC;\n\tfor(int i = 1; i < N; i++){\n\t\tif(in_num[i] == 1){\n\t\t\tis_cicle[i] = false;\n\t\t\tCALC.push(i);\n\t\t}\n\t}\n\n\tint node_id;\n\tint next_node,next_value;\n\n\twhile(!CALC.empty()){\n\t\tnode_id = CALC.front();\n\t\tCALC.pop();\n\n\t\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\t\tnext_node = G[node_id][i];\n\t\t\tif(is_cicle[next_node] == false || next_node == root)continue;\n\n\t\t\tin_num[next_node]--;\n\t\t\tif(in_num[next_node] == 1){\n\t\t\t\tis_cicle[next_node] = false;\n\t\t\t\tCALC.push(next_node);\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = value[root];\n\tfor(int i = 1; i < N; i++){\n\t\tif(is_cicle[i]){\n\t\t\tans += value[i];\n\t\t}\n\t}\n\n\tint maximum = 0;\n\tfor(int i = 0; i < N; i++)max_value[i] = 0;\n\n\tpriority_queue<Info> Q;\n\tfor(int i = 0; i < N; i++){\n\t\tif(!is_cicle[i])continue;\n\n\t\tfor(int k = 0; k < G[i].size(); k++){\n\t\t\tnext_node = G[i][k];\n\t\t\tif(is_cicle[next_node])continue;\n\n\t\t\tnext_value = value[next_node];\n\t\t\tif(max_value[next_node] < next_value){\n\t\t\t\tmax_value[next_node] = next_value;\n\t\t\t\tQ.push(Info(next_node,i,next_value));\n\t\t\t}\n\t\t}\n\t}\n\n\tInfo info;\n\twhile(!Q.empty()){\n\n\t\tinfo = Q.top();\n\t\tQ.pop();\n\n\t\tmaximum = max(maximum,info.sum_value);\n\n\t\tif(Q.top().sum_value < max_value[Q.top().node_id]){\n\t\t\tcontinue;\n\t\t}else{\n\t\t\tfor(int i = 0; i < G[Q.top().node_id].size(); i++){\n\t\t\t\tnext_node = G[Q.top().node_id][i];\n\t\t\t\tif(next_node == Q.top().pre_node || is_cicle[next_node] == true)continue;\n\t\t\t\tnext_value = Q.top().sum_value+value[next_node];\n\n\t\t\t\tif(max_value[next_node] < next_value){\n\t\t\t\t\tmax_value[next_node] = next_value;\n\t\t\t\t\tQ.push(Info(next_node,Q.top().node_id,next_value));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",ans+maximum);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n,m;\nvector<int>e[100005];\nvector<int>edge[100005];\nint used[100005];\nint w[100005],k;\nvector<int>E[100005];\nll W[100005];\nint in[100005];\nll dp[100005];\nint cnt[100005],c[100005];\nint par[100005],ran[100005];\nll ans,add;\nvoid init(){ for(int i=0;i<100005;i++) par[i] = i; }\nint find(int x){ if(x == par[x]) return x; else return par[x] = find(par[x]); }\nvoid unite(int x,int y){\n\tx = find(x); y = find(y); if(x==y) return;\n\tif(ran[x] < ran[y]) par[x] = y;\n\telse{\n\t\tpar[y] = x;\n\t\tif(ran[x] == ran[y]) ran[x]++;\n\t}\n}\nbool same(int x,int y){ return find(x)==find(y); }\nvoid dfs(int v,int u,int d){\n\tused[v] = d;//cout << v << endl;\n\tfor(int i=0;i<e[v].size();i++){\n\t\tif(e[v][i] == u) continue;\n\t\tif(used[e[v][i]] && used[e[v][i]] < used[v]){\n\t\t\tcnt[e[v][i]]--;\n\t\t\tcnt[v]++;\n\t\t\tunite(e[v][i],v);\n\t\t\t//cout << v << \" \" << e[v][i] << endl;\n\t\t\tcontinue;\n\t\t}\n\t\telse if(used[e[v][i]]) continue;\n\t\tdfs(e[v][i],v,d+1); edge[v].pb(e[v][i]);edge[e[v][i]].pb(v); //cout << v << \" \" << e[v][i] << endl;\n\t}\n}\nint dfs2(int v,int u){\n\tint sum = 0;\n\tfor(int i=0;i<edge[v].size();i++){\n\t\tif(edge[v][i] == u) continue;\n\t\tint a = dfs2(edge[v][i],v);\n\t\tif(a>0){\n\t\t    //cout << edge[v][i] << \" f\" << v << endl;\n\t\t\tunite(edge[v][i],v);\n\t\t}\n\t\tsum += a;\n\t}\n\tsum += cnt[v];\n\treturn sum;\n}\npair<ll,bool> dfs(int v,int p){\n\tll ret = 0; bool ok = (c[v] >= 3);\n\tfor(int i=0;i<E[v].size();i++){\n\t\tif(E[v][i] == p) continue;\n\t\tpair<ll,bool> t = dfs(E[v][i],v);\n\t\tret = max(ret,t.fi);\n\t\tok |= t.sc;\n\t}\n\tif(ok){\n\t\tret = 0;\n\t\tans += W[v];\n\t}\n\telse ret += W[v];\n\tadd = max(add,ret);\n\treturn mp(ret,ok);\n}\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\tfor(int i=0;i<n;i++) scanf(\"%d\",&w[i]);\n\tfor(int i=0;i<m;i++){\n\t\tint a,b; scanf(\"%d%d\",&a,&b); a--; b--;\n\t\te[a].push_back(b);\n\t\te[b].push_back(a);\n\t}\n\tinit(); dfs(0,-1,1); dfs2(0,-1);\n\tfor(int i=0;i<n;i++){\n\t\tW[find(i)] += w[i];\n\t\tc[find(i)] ++;\n\t\tfor(int j=0;j<e[i].size();j++){\n\t\t\tif(find(i) != find(e[i][j])){\n\t\t\t\tE[find(i)].pb(find(e[i][j]));\n\t\t\t\tE[find(e[i][j])].pb(find(i));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tSORT(E[i]); ERASE(E[i]);\n\t}\n\tdfs(0,-1);\n\tcout << ans+add << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int, int> P;\nconst int M = 1000000007;\n\nvector<vector<int>> edge;\nvector<set<int>> nedge;\nvector<int> uid, uuid;\nvector<int> vis;\nvector<int> viscnt;\nvector<int> cnts;\nvector<int> nw;\nbool dfs(int now, int par, int s) {\n    vis[now] = s;\n    bool ret = false;\n    for (int i : edge[now]) {\n        if (i == par) continue;\n        if (s == 0) {\n            ++viscnt[i];\n        }\n        if (i == s) {\n            ret = true;\n        }\n        else if (vis[i] < s && uid[i] > s) {\n            ret |= dfs(i, now, s);\n        }\n    }\n    if (ret) {\n        uid[now] = s;\n    }\n    return ret;\n}\nbool dfs(int now, int par) {\n    bool ret = false;\n    for (int i : nedge[now]) {\n        if (i == par) continue;\n        if (cnts[i] > 1) {\n            ret = true;\n        }\n        ret |= dfs(i, now);\n    }\n    if (ret) {\n        uuid[now] = 0;\n    }\n    return ret;\n}\nint dfs2(int now, int par) {\n    int ret = 0;\n    for (int i : nedge[now]) {\n        if (i == par) continue;\n        ret = max(ret, dfs2(i, now));\n    }\n    return ret + nw[now];\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<int> w(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> w[i];\n    }\n    edge.resize(n);\n    for (int i = 0; i < m; ++i) {\n        int a, b;\n        cin >> a >> b;\n        --a;\n        --b;\n        edge[a].push_back(b);\n        edge[b].push_back(a);\n    }\n    uid.resize(n);\n    vis.resize(n, -1);\n    for (int i = 0; i < n; ++i) {\n        uid[i] = i;\n    }\n    viscnt.resize(n, 0);\n    cnts.resize(n, 0);\n    for (int i = 0; i < n; ++i) {\n        if (uid[i] == i) {\n            if (i == 0 || viscnt[i] > 1)\n                dfs(i, -1, i);\n        }\n        ++cnts[uid[i]];\n    }\n    nedge.resize(n);\n    for (int i = 0; i < n; ++i) {\n        for (int j : edge[i]) {\n            if (uid[i] != uid[j]) {\n                nedge[uid[i]].insert(uid[j]);\n            }\n        }\n    }\n    uuid.resize(n);\n    for (int i = 0; i < n; ++i) {\n        uuid[i] = i;\n    }\n    dfs(0, -1);\n    nw.resize(n, 0);\n    for (int i = 0; i < n; ++i) {\n        nw[uuid[uid[i]]] += w[i];\n    }\n    vector<int> used(n, 0);\n    int ma = 0;\n    for (int i = 0; i < n; ++i) {\n        if (i == uid[i] && uuid[i] == 0) {\n            for (int j : nedge[i]) {\n                if (uuid[j] > 0 && !used[j]) {\n                    used[j] = 1;\n                    ma = max(ma, dfs2(j, i));\n                }\n            }\n        }\n    }\n    cout << (nw[0] + ma) << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n\nusing VS = vector<string>;    using LL = long long;\nusing VI = vector<int>;       using VVI = vector<VI>;\nusing PII = pair<int, int>;   using PLL = pair<LL, LL>;\nusing VL = vector<LL>;        using VVL = vector<VL>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n#define FOR(i, s, e) for (int(i) = (s); (i) < (e); (i)++)\n#define FORR(i, s, e) for (int(i) = (s); (i) > (e); (i)--)\n#define debug(x) cerr << #x << \": \" << x << endl\nconst int INF = 1e9;                          const LL LINF = 1e16;\nconst LL MOD = 1000000007;                    const double PI = acos(-1.0);\nint DX[8] = { 0, 0, 1, -1, 1, 1, -1, -1 };    int DY[8] = { 1, -1, 0, 0, 1, -1, 1, -1 };\n\nstruct UnionFind {\n    vector<int> data;\n    UnionFind(int n) { data.assign(n, -1); }\n    bool unionSet(int x, int y) {\n        x = root(x); y = root(y);\n        if (x != y) {\n            if (data[y] < data[x]) swap(x, y);\n            data[x] += data[y]; data[y] = x;\n        }\n        return x != y;\n    }\n    bool same(int x, int y) { return root(x) == root(y); }\n    int root(int x) { return data[x] < 0 ? x : data[x] = root(data[x]); }\n    int size(int x) { return -data[root(x)]; }\n};\n\nstruct TwoEdgeConnectedComponent{\n    UnionFind uf;\n    vector<vector<int>> g;\n    vector<pair<int, int>> edges;\n    vector<int> used, ord, low, comp;\n    \n    TwoEdgeConnectedComponent(int v) : uf(v), g(v), used(v, 0), comp(v), ord(v), low(v) {}\n    \n    void add_edge(int x, int y) {\n        g[x].push_back(y);\n        g[y].push_back(x);\n        edges.push_back(minmax(x, y));\n    }\n    \n    void dfs(int idx, int& k, int par = -1) {\n        used[idx] = true;\n        ord[idx] = k++;\n        low[idx] = ord[idx];\n        \n        for (auto &to : g[idx]) {\n            if (!used[to]) {\n                dfs(to, k, idx);\n                low[idx] = min(low[idx], low[to]);\n                if (ord[idx] >= low[to]) uf.unionSet(idx, to);\n            }\n            else if (to != par) {\n                low[idx] = min(low[idx], ord[to]);\n            }\n        }\n    }\n    \n    // return origin color\n    int operator[](int k) {\n        return (comp[k]);\n    }\n    \n    int size() {\n        return (g.size());\n    }\n    \n    // build, renew resG(empty -> tree), return color\n    vector<int> get_graph(vector<vector<int>>& resG, int root = 0) {\n        int kk = 0;\n        dfs(root, kk);\n        \n        int ptr = 0;\n        vector<int> color(g.size());\n        for (int i = 0; i < g.size(); i++) {\n            if (i == uf.root(i)) color[i] = ptr++;\n        }\n        \n        resG.resize(ptr);\n        for (int i = 0; i < g.size(); i++) {\n            comp[i] = color[uf.root(i)];\n        }\n//        for (auto &e : edges) {\n//            int x = comp[e.first], y = comp[e.second];\n//            if (x == y) continue;\n//            resG[x].push_back(y);\n//            resG[y].push_back(x);\n//        }\n       \n                for (int v = 0; v < (int)g.size(); v++) {\n                    for (int i = 0; i < (int)g[v].size(); i++) {\n                        int u = g[v][i];\n                        int c1 = comp[v], c2 = comp[u];\n                        if (c1 == c2)continue;\n                        resG[c1].push_back(c2);\n                        resG[c2].push_back(c1);\n                    }\n                }\n        for(int v = 0; v < ptr;v++){\n            sort(resG[v].begin(),resG[v].end());\n            resG[v].erase(unique(resG[v].begin(),resG[v].end()),resG[v].end());\n        }\n        return comp;\n    }\n};\n\nint N, M, W[100000];\nvector<vector<int>> resG;\nvector<int> weightSum, sz;\nint dp1[100000], dp3[100000];\n\nint rec(int idx, int par = -1)\n{\n    int ret = 0;\n    for (auto &to : resG[idx]) {\n        if (to == par) continue;\n        ret = max(ret, rec(to, idx));\n        dp1[idx] += dp1[to];\n    }\n    ret += weightSum[idx];\n    if (sz[idx] >= 3 || dp1[idx] > 0) dp1[idx] += weightSum[idx];\n    for (auto &to : resG[idx]) {\n        if (to == par) continue;\n        else ret = max(ret, dp1[idx] - dp1[to] + dp3[to]);\n    }\n    return (dp3[idx] = ret);\n}\n\n// 三点以上集まった頂点ならば、ここを起点にもどることができる。\n// dp1[v]:vから葉まで進むときの最大値\n// dp3[v]:vに戻ってくるときの最大値\nvoid f(int v, int p = -1) {\n    for (int nx : resG[v]) {\n        if (nx == p)continue;\n        f(nx, v);\n        dp1[v] += dp1[nx];\n    }\n    int ret = dp1[v];\n    if (dp1[v] || sz[v] > 1)dp1[v] += weightSum[v];\n    for (int nx : resG[v]) {\n        if (nx == p)continue;\n        dp3[v] = max(dp3[v], ret - dp1[nx] + dp3[nx]);\n    }\n    dp3[v] += weightSum[v];\n}\n\nint main() {\n    int N, M; cin >> N >> M;\n    FOR(i, 0, N) {\n        cin >> W[i];\n    }\n    TwoEdgeConnectedComponent gx(N);\n    \n    FOR(i, 0, M) {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        gx.add_edge(a, b);\n    }\n    VI vc = gx.get_graph(resG);\n    \n    weightSum.assign(resG.size(), 0);\n    sz.assign(resG.size(), 0);\n    for (int i = 0; i < N; i++) {\n        weightSum[vc[i]] += W[i];\n        sz[vc[i]]++;\n    }\n    f(vc[0]);\n    LL ans = dp3[vc[0]];\n    cout << ans << endl;\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\ntemplate <class Cost = int>\nstruct Edge {\n    int src, dst;\n    Cost cost;\n    Edge(int src = -1, int dst = -1, Cost cost = 1)\n        : src(src), dst(dst), cost(cost){};\n\n    bool operator<(const Edge<Cost>& e) const { return this->cost < e.cost; }\n    bool operator>(const Edge<Cost>& e) const { return this->cost > e.cost; }\n};\n\ntemplate <class Cost = int>\nusing Edges = std::vector<Edge<Cost>>;\n\ntemplate <class Cost = int>\nusing Graph = std::vector<std::vector<Edge<Cost>>>;\n\nvoid solvetree(int n) {\n    std::vector<int> ws(n);\n    for (auto& w : ws) std::cin >> w;\n\n    Graph<> graph(n);\n    for (int i = 0; i < n - 1; ++i) {\n        int u, v;\n        std::cin >> u >> v;\n        --u, --v;\n\n        graph[u].emplace_back(u, v);\n        graph[v].emplace_back(v, u);\n    }\n\n    std::vector<int> dist(n, -1);\n    std::queue<int> que;\n\n    dist[0] = ws[0];\n    que.push(0);\n\n    while (!que.empty()) {\n        int v = que.front();\n        que.pop();\n\n        for (auto e : graph[v]) {\n            int u = e.dst;\n            if (dist[u] != -1) continue;\n\n            dist[u] = dist[v] + ws[u];\n            que.push(u);\n        }\n    }\n\n    std::cout << *std::max_element(dist.begin(), dist.end())\n              << std::endl;\n}\n\nvoid solve() {\n    int n, m;\n    std::cin >> n >> m;\n\n    if (m == n - 1) {\n        solvetree(n);\n        return;\n    }\n\n    std::vector<int> ws(n);\n    for (auto& w : ws) std::cin >> w;\n\n    Graph<> graph(n);\n    std::vector<int> deg(n, 0);\n\n    while (m--) {\n        int u, v;\n        std::cin >> u >> v;\n        --u, --v;\n\n        ++deg[u], ++deg[v];\n        graph[u].emplace_back(u, v);\n        graph[v].emplace_back(v, u);\n    }\n\n    int ans = 0;\n\n    std::queue<int> que;\n    for (int v = 0; v < n; ++v) {\n        if (deg[v] == 1) que.push(v);\n    }\n\n    std::vector<bool> onpath(n, false);\n    onpath[0] = true;\n\n    while (!que.empty()) {\n        int v = que.front();\n        que.pop();\n\n        if (onpath[v]) {\n            ans += ws[v];\n            ws[v] = 0;\n        }\n\n        for (auto e : graph[v]) {\n            int u = e.dst;\n            if (--deg[u] == 1) {\n                que.push(u);\n                if (onpath[v]) onpath[u] = true;\n            }\n        }\n    }\n\n    std::vector<int> dist(n, -1);\n    for (int v = 0; v < n; ++v) {\n        if (deg[v] > 1) {\n            ans += ws[v];\n            ws[v] = 0;\n            que.push(v);\n            dist[v] = 0;\n        }\n    }\n\n    while (!que.empty()) {\n        int v = que.front();\n        que.pop();\n\n        for (auto e : graph[v]) {\n            int u = e.dst;\n            if (dist[u] != -1) continue;\n\n            dist[u] = dist[v] + ws[u];\n            que.push(u);\n        }\n    }\n\n    ans += *std::max_element(dist.begin(), dist.end());\n    std::cout << ans << std::endl;\n}\n\nint main() {\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    solve();\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<utility>\n#include<set>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define MP make_pair\n#define PB push_back\nusing namespace std;\n\nint n,m;\n\nvoid bfs(int k,vector<int> &cnt,vector<bool>&b,vector<vector<int> > &g){\n    if(cnt[k]==1||cnt[k]==0){\n        b[k] = 0;\n        for(int i:g[k]){\n            if(b[i]){\n                cnt[i]--;\n                bfs(i,cnt,b,g);\n            }\n        }\n    }   \n}\nint bfs2(int k,int z,vector<int>&w,vector<vector<int> > &g){\n    int s=w[k];\n    int mx = 0;\n    for(int x:g[k]){\n        if(x!=z){\n            mx = max(mx,bfs2(x,k,w,g));\n        }\n    }\n    return s+mx;\n}\n\n\nint main(){\n    cin >> n >> m;\n    vector<int> w(n+1);\n    vector<vector<int> > g(n);\n    rep(i,n)cin >> w[i];\n    rep(i,m){\n        int u,v;\n        cin >> u >> v;\n        u--;v--;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    vector<int> cnt(n);\n    rep(i,n){\n        cnt[i] = g[i].size();\n    }\n    vector<bool> b(n,1);\n    rep(i,n){\n        bfs(i,cnt,b,g);\n    }\n    vector<int>p;\n    int sm=0;\n    rep(i,n){\n        if(b[i]){\n            p.PB(i);\n            sm+=w[i];\n        }\n    }\n    w[n]=sm;\n    set<int>st;\n    for(int x:p){\n        for(int y:g[x]){\n            st.insert(y);\n        }\n    }\n    vector<vector<int> >g2(n+1);\n    rep(i,n){\n        if(!b[i]){\n            for(int x:g[i]){\n                if(b[x]){\n                    g2[i].PB(n);\n                    g2[n].PB(i);\n                }else{\n                    g2[i].PB(x);\n                }\n            }\n        }\n    }\n    if(b[0]){\n        cout << bfs2(n,n,w,g2) << endl;\n    }else{\n        cout << bfs2(0,0,w,g2) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int, int> P;\nconst int M = 1000000007;\n\nvector<vector<int>> edge;\nvector<set<int>> nedge;\nvector<int> uid, uuid;\nvector<int> vis;\nvector<int> viscnt;\nvector<int> cnts;\nvector<int> nw;\nbool dfs(int now, int par, int s) {\n    vis[now] = s;\n    bool ret = false;\n    for (int i : edge[now]) {\n        if (i == par) continue;\n        if (s == 0) {\n            ++viscnt[i];\n        }\n        if (i == s) {\n            ret = true;\n        }\n        else if (vis[i] < s && uid[i] > s) {\n            ret |= dfs(i, now, s);\n        }\n    }\n    if (ret) {\n        uid[now] = s;\n    }\n    return ret;\n}\nbool dfs(int now, int par) {\n    bool ret = cnt[now] > 1;\n    for (int i : nedge[now]) {\n        if (i == par) continue;\n        ret |= dfs(i, now);\n    }\n    if (ret) {\n        uuid[now] = 0;\n    }\n    return ret;\n}\nint dfs2(int now, int par) {\n    int ret = 0;\n    for (int i : nedge[now]) {\n        if (i == par) continue;\n        ret = max(ret, dfs2(i, now));\n    }\n    return ret + nw[now];\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<int> w(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> w[i];\n    }\n    edge.resize(n);\n    for (int i = 0; i < m; ++i) {\n        int a, b;\n        cin >> a >> b;\n        --a;\n        --b;\n        edge[a].push_back(b);\n        edge[b].push_back(a);\n    }\n    uid.resize(n);\n    vis.resize(n, -1);\n    for (int i = 0; i < n; ++i) {\n        uid[i] = i;\n    }\n    viscnt.resize(n, 0);\n    cnts.resize(n, 0);\n    for (int i = 0; i < n; ++i) {\n        if (uid[i] == i) {\n            if (i == 0 || viscnt[i] > 1)\n                dfs(i, -1, i);\n        }\n        ++cnts[uid[i]];\n    }\n    nedge.resize(n);\n    for (int i = 0; i < n; ++i) {\n        for (int j : edge[i]) {\n            if (uid[i] != uid[j]) {\n                nedge[uid[i]].insert(uid[j]);\n            }\n        }\n    }\n    uuid.resize(n);\n    for (int i = 0; i < n; ++i) {\n        uuid[i] = i;\n    }\n    dfs(0, -1);\n    nw.resize(n, 0);\n    for (int i = 0; i < n; ++i) {\n        nw[uuid[uid[i]]] += w[i];\n    }\n    vector<int> used(n, 0);\n    int ma = 0;\n    for (int i = 0; i < n; ++i) {\n        if (i == uid[i] && uuid[i] == 0) {\n            for (int j : nedge[i]) {\n                if (uuid[j] > 0 && !used[j]) {\n                    used[j] = 1;\n                    ma = max(ma, dfs2(j, i));\n                }\n            }\n        }\n    }\n    cout << (nw[0] + ma) << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_N 100001\n#define N MAX_N\n#define rank dfasfds\nusing namespace std;\ntypedef long long ll;\ntypedef set<int> S;\nint par[MAX_N],rank[MAX_N];\nll val[MAX_N];\nS G[N];\n\nvoid init(int n){for(int i=0;i<n;i++)par[i]=i,rank[i]=0;}\n\nint find(int x){\n  if(par[x]==x)return x;\n  return par[x]=find(par[x]);\n}\n\nvoid unite(int x,int y){\n  x=find(x),y=find(y);\n  if(x==y)return;\n  if(rank[x]<rank[y]){\n    par[x]=y;\n    val[y]+=val[x];\n    for(S::iterator it=G[x].begin();it!=G[x].end();it++)G[y].insert(find(*it));\n  }\n  else{\n    par[y]=x;\n    val[x]+=val[y];\n    for(S::iterator it=G[y].begin();it!=G[y].end();it++)G[x].insert(find(*it));\n    if(rank[x]==rank[y])rank[x]++;\n  }\n}\n\nbool same(int x,int y){return find(x)==find(y);}\n\n\n\nint used[N];\nvector<int> pass;\nvoid dfs(int pos,int pre){\n  pos=find(pos);\n  if(used[pos]++) {\n    for(int i=pass.size()-1;pass[i]!=pos;i--)unite(pos,pass[i]);\n    return;\n  }\n  pass.push_back(pos);\n  for(S::iterator it=G[pos].begin();it!=G[pos].end();it++)\n    if(*it!=pre)dfs(*it,pos);\n  pass.pop_back();\n}\n\nint main(){\n  int n,m;\n  cin>>n>>m;\n  for(int i=0;i<n;i++) cin>>val[i];\n  for(int i=0,a,b;i<m;i++){\n    cin>>a>>b;a--,b--;\n    G[a].insert(b);\n    G[b].insert(a);\n  }\n  init(n);\n  dfs(0,-1);\n  ll a=find(0),ans=0;\n  for(S::iterator it=G[a].begin();it!=G[a].end();it++)\n    if(!same(a,*it)) ans=max(ans,val[*it]);\n  cout <<ans+val[a]<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for(ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\n\nll N, M, W[100000], cnt[100000];\nvector<ll> E[100000], candidate;\nbool visited[100000], check[100000];\n\nvoid dfs_candidate(ll v) {\n  visited[v] = true;\n  for(ll u : E[v]) if(!visited[u]) {\n    if(!check[v] && check[u]) candidate.push_back(u);\n    else dfs_candidate(u);\n  }\n}\n\nll dfs(ll v) {\n  ll ret = 0;\n  visited[v] = true;\n  for(ll u : E[v]) if(!visited[u]) ret = max(ret, dfs(u));\n  return ret + W[v];\n}\n\nint main(void) {\n  cin >> N >> M;\n  REP(i, 0, N) cin >> W[i];\n  REP(i, 0, M) {\n    ll U, V; cin >> U >> V; U--; V--;\n    E[U].push_back(V);\n    E[V].push_back(U);\n  }\n\n  queue<ll> q;\n  REP(i, 0, N) cnt[i] = E[i].size();\n  REP(i, 1, N) if(cnt[i] == 1) q.push(i);\n  REP(i, 0, N) check[i] = false;\n  while(q.size()) {\n    ll v = q.front();\n    q.pop();\n    check[v] = true;\n    for(ll u : E[v]) if(--cnt[u] == 1) q.push(u);\n  }\n\n  REP(i, 0, N) visited[i] = false;\n  if(check[0]) candidate.push_back(0);\n  dfs_candidate(0);\n\n  ll ans = 0;\n  REP(i, 0, N) visited[i] = false;\n  REP(i, 0, N) if(!check[i]) visited[i] = true;\n  for(ll v : candidate) ans = max(ans, dfs(v));\n  REP(i, 0, N) if(!check[i]) ans += W[i];\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_V 100000\nusing namespace std;\nint m,w[100001];\nvector<int> vv[100001];\nbool S[100001];\nint V;\nvector<int> G[MAX_V];\nvector<int> rG[MAX_V];\nvector<int> vs;\nbool used[MAX_V];\nint cmp[MAX_V];\nint C[100001],F[100001],U[100001],ans;\nbool UU[100001];\n\nvoid DFS(int p,int pr){\n  if(S[p])return;\n  S[p]=1;\n  for(int i=0;i<vv[p].size();i++){\n    int np=vv[p][i];\n    if(pr!=np){\n      G[p].push_back(np);\n      rG[np].push_back(p);\n      DFS(np,p);\n    }\n  }\n}\n\nvoid dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++)if(!used[G[v][i]])dfs(G[v][i]);\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v]=true;\n  cmp[v]=k;\n  for(int i=0;i<rG[v].size();i++)if(!used[rG[v][i]])rdfs(rG[v][i],k);\n}\n\nint scc(){\n  for(int v=0;v<V;v++)if(!used[v])dfs(v);\n  memset(used,0,sizeof(used));\n  int k=0;\n  for(int i=vs.size()-1;i>=0;i--)if(!used[vs[i]])rdfs(vs[i],k++);\n  return k;\n}\n\nbool DFS1(int p){\n  if(U[p])return 0;\n  U[p]=1;\n  bool f=F[cmp[p]]>=2;\n  for(int i=0;i<G[p].size();i++)\n    f|=DFS1(G[p][i]);\n  ans+=w[p]*f;\n  return UU[p]=f;\n}\nbool UUU[100001];\nint DFS2(int p){\n  if(UUU[p])return 0;\n  UUU[p]=1;\n  int res=0;\n  \n  for(int i=0;i<G[p].size();i++)\n    res=max(res,DFS2(G[p][i]));  \n  return res+(UU[p]?0:w[p]);\n}\n\nint main(){\n  cin>>V>>m;\n  for(int i=0;i<V;i++)cin>>w[i];\n  for(int j=0,a,b;j<m;j++){\n    cin>>a>>b;a--,b--;\n    vv[a].push_back(b),vv[b].push_back(a);\n  }\n  DFS(0,-1);\n  int t=0;\n  for(int i=0;i<V;i++)t+=w[i];\n  scc();\n  for(int i=0;i<V;i++)F[cmp[i]]++;\n  DFS1(0);\n  cout<<ans+DFS2(0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#define INF 200000000\n\nusing namespace std;\nint main(){\n    int N,M;\n    cin >> N >> M;\n    int ans = 0;\n    vector< vector<int> > graph(N);\n    int x,y;\n    vector<int> weight(N);\n    for(int i=0; i< N; i++){\n        cin >> weight[i];\n        ans += weight[i];\n    }\n\n    for(int i=0; i<M ; i++){\n        cin >> x >> y;\n        x--; y--;\n        graph[x].push_back(y);\n        graph[y].push_back(x);\n    }\n    int thePath = 0;\n    int count = 0;\n    int ssum = 0;\n    int fst=-1,scd=-1;\n    for(int i=0; i<N ; i++){\n        if(graph[i].size()!=1)continue;\n        count++;\n        bool inPath = false;\n        int prev=i;\n        int next = graph[i][0];\n        int now;\n        int sum = weight[i];\n        for(;graph[next].size()==2;){\n            if(prev==0) inPath = true;\n            if(inPath) thePath += weight[prev];\n            sum += weight[next];\n            if(graph[next][0] == prev){\n                now = next;\n                next = graph[next][1];\n                prev = now;\n            }else{\n                now = next;\n                next = graph[next][1];\n                prev = now;\n            }\n        }\n        if(prev==0) inPath = true;\n        if(inPath) thePath += weight[prev];\n        ssum += sum;\n        if(inPath) continue;\n        if(count == 1){\n            fst = sum;\n        }else if(count == 2){\n            if(sum > fst){\n                scd = fst; fst= sum;\n            }else{\n                scd = sum;\n            }\n        }else{\n            if(sum > fst){\n                scd = fst; fst = sum;\n            } else if( sum > scd){\n                scd = sum;\n            }\n        }\n    }\n    if(thePath == 0){\n        if(count <= 1 ){\n            cout << ans << endl; \n        }else{\n            cout << ans - ssum + fst << endl;\n        }\n    } else {\n        if(count == 1){\n            cout << ans - ssum + thePath << endl;\n        }else{\n            cout << ans - ssum + fst + thePath << endl;\n        }\n\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct UnionFind\n{\n  vector< int > data;\n\n  UnionFind(int sz)\n  {\n    data.assign(sz, -1);\n  }\n\n  bool unite(int x, int y)\n  {\n    x = find(x), y = find(y);\n    if(x == y) return (false);\n    if(data[x] > data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n    return (true);\n  }\n\n  int find(int k)\n  {\n    if(data[k] < 0) return (k);\n    return (data[k] = find(data[k]));\n  }\n\n  int size(int k)\n  {\n    return (-data[find(k)]);\n  }\n};\n\nstruct BiConnectedComponents\n{\n  UnionFind uf;\n  vector< vector< int > > g;\n  vector< pair< int, int > > edges;\n  vector< int > used, ord, low, comp;\n\n  BiConnectedComponents(size_t v) : uf(v), g(v), used(v, 0), comp(v), ord(v), low(v)\n  {\n  }\n\n  void add_edge(int x, int y)\n  {\n    g[x].push_back(y);\n    g[y].push_back(x);\n    edges.push_back(minmax(x, y));\n  }\n\n  void dfs(int idx, int &k, int par = -1)\n  {\n    used[idx] = true;\n    ord[idx] = k++;\n    low[idx] = ord[idx];\n\n    for(auto &to : g[idx]) {\n      if(!used[to]) {\n        dfs(to, k, idx);\n        low[idx] = min(low[idx], low[to]);\n        if(ord[idx] >= low[to]) uf.unite(idx, to);\n      } else if(to != par) {\n        low[idx] = min(low[idx], ord[to]);\n      }\n    }\n  }\n\n  int operator[](int k)\n  {\n    return (comp[k]);\n  }\n\n  size_t size()\n  {\n    return (g.size());\n  }\n\n  void build(vector< vector< int > > &t)\n  {\n    int kk = 0;\n    dfs(0, kk);\n\n    int ptr = 0;\n    vector< int > cc(g.size());\n    for(int i = 0; i < g.size(); i++) {\n      if(i == uf.find(i)) cc[i] = ptr++;\n    }\n\n    t.resize(ptr);\n    for(int i = 0; i < g.size(); i++) {\n      comp[i] = cc[uf.find(i)];\n    }\n    for(auto &e : edges) {\n      int x = comp[e.first], y = comp[e.second];\n      if(x == y) continue;\n      t[x].push_back(y);\n      t[y].push_back(x);\n    }\n  }\n};\n\nint N, M, W[100000];\nvector< vector< int > > g;\nvector< int > weightSum, sz;\nint dp1[100000], dp2[100000], dp3[100000];\n\nint rec(int idx, int par = -1)\n{\n  int ret = 0;\n  for(auto &to : g[idx]) {\n    if(to == par) continue;\n    rec(to, idx);\n    dp2[idx] = max(dp2[idx], dp2[to]);\n    dp1[idx] += dp1[to];\n  }\n  dp2[idx] += weightSum[idx];\n  if(sz[idx] >= 3 || dp1[idx] > 0) dp1[idx] += weightSum[idx];\n  for(auto &to : g[idx]) {\n    if(to == par) continue;\n    else ret = max(ret, dp1[idx] - dp1[to] + dp3[to]);\n  }\n  return (dp3[idx] = max(dp2[idx], ret));\n}\n\nint main()\n{\n  cin >> N >> M;\n  BiConnectedComponents tree(N);\n  for(int i = 0; i < N; i++) {\n    cin >> W[i];\n  }\n  while(M--) {\n    int U, V;\n    cin >> U >> V;\n    tree.add_edge(--U, --V);\n  }\n  tree.build(g);\n  weightSum.assign(g.size(), 0);\n  sz.assign(g.size(), 0);\n  for(int i = 0; i < N; i++) {\n    weightSum[tree[i]] += W[i];\n    sz[tree[i]]++;\n  }\n  cout << rec(tree[0]) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\nusing namespace std;\n\nvoid visit(vector< vector<int> > &G, int cur, int prev, vector< pair<int, int> > &brg, vector< vector<int> > &each_bcc, stack<int> &roots, stack<int> &S, vector<bool> &inS, vector<int> &order, int &k){\n  order[cur] = ++k;\n  //++k;\n  S.push(cur);\n  inS[cur] = true;\n  roots.push(cur);\n  for(int i = 0; i < G[cur].size(); ++i){\n    int to = G[cur][i];\n    if(!order[to]) visit(G, to, cur, brg, each_bcc, roots, S, inS, order, k);\n    else if(to != prev && inS[to]){\n      while(order[roots.top()] > order[to]) roots.pop();\n    }\n  }\n\n  if(cur == roots.top()){\n    if(prev != -1) brg.push_back(pair<int, int>(prev, cur));\n    vector<int> bcc;\n    while(1){\n      int node = S.top();\n      S.pop();\n      inS[node] = false;\n      bcc.push_back(node);\n      if(node == cur) break;\n    }\n    each_bcc.push_back(bcc);\n    roots.pop();\n  }\n}\n\nvoid bridge(vector< vector<int> > &G, vector< pair<int, int> > &brg, vector< vector<int> > &each_bcc){\n  int V = G.size();\n  vector<int> order(V);\n  vector<bool> inS(V);\n  stack<int> roots, S;\n  int k = 0;\n  for(int i = 0; i < V; ++i){\n    if(!order[i]) visit(G, i, -1, brg, each_bcc, roots, S, inS, order, k);\n  }\n}\n\nint dfs(vector< vector<int> > &G, vector<int> &W, int v){\n  int ret = 0, w = W[v];\n  W[v] = 0;\n  for(int i = 0; i < G[v].size(); ++i){\n    int v_ = G[v][i];\n    if(!W[v_]) continue;\n    ret = max(ret, dfs(G, W, v_));\n  }\n  W[v] = w;\n  return ret + w;\n}\n\nint main(){\n  int N, M;\n  cin >> N >> M;\n  vector<int> W(N);\n  for(int i = 0; i < N; ++i) cin >> W[i];\n  vector< vector<int> > G(N);\n  for(int i = 0; i < M; ++i){\n    int u, v;\n    cin >> u >> v;\n    --u;--v;\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n  vector< vector<int> > each_bcc;\n  vector< pair<int, int> > brg;\n  bridge(G, brg, each_bcc);\n  int V = each_bcc.size();\n  vector<int> W_(V, 0);\n  vector<int> cmp(N);\n  for(int i = 0; i < V; ++i){\n    for(int j = 0; j < each_bcc[i].size(); ++j){\n      cmp[each_bcc[i][j]] = i;\n      W_[i] += W[each_bcc[i][j]];\n    }\n  }\n  vector< vector<int> > G_(V);\n  for(int i = 0; i < brg.size(); ++i){\n    int u = brg[i].first, v = brg[i].second;\n    G_[cmp[u]].push_back(cmp[v]);\n    G_[cmp[v]].push_back(cmp[u]);\n  }\n  //for(int i = 0; i < N; ++i) cout << cmp[i] << \" \";cout << endl;\n  //for(int i = 0; i < V; ++i) cout << W_[i] << \" \"; cout << endl;\n\n  //cout << dfs(G_, W_, s) << endl;\n  int s = cmp[0], ans = 0, t = 0;\n  for(int i = 0; i < V; ++i){\n    if(each_bcc[i].size() > 2 || i == s || G_[i].size() > 1) ans += W_[i];\n    else t = max(t, W_[i]);\n  }\n  cout << ans + t << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\nint dfs(vector<vector<int>>& g, vector<int>& w, vector<bool>& used, int pos){\n\tused[pos] = true;\n\tint res = w[pos];\n\tfor(auto to : g[pos]){\n\t\tif(used[to]) continue;\n\t\tres += dfs(g, w, used, to);\n\t}\n\treturn res;\n}\n\nvoid cut(vector<vector<int>>& g, vector<int>& in, vector<bool>& used, int pos, vector<int>& p){\n\tused[pos] = true;\n\tfor(auto to : g[pos]){\n\t\tif(used[to]) continue;\n\t\tcut(g, in, used, to, p);\n\t}\n\tif(in[pos] == 1){\n\t\tp.emplace_back(pos);\n\t\tin[pos] = 0;\n\t\tfor(auto i : g[pos]){\n\t\t\tin[i]--;\n\t\t}\n\t}\n}\n\nint main(){\n\tint n, m;\n\tcin >> n >> m;\n\n\tvector<int> w(n);\n\tcin >> w;\n\n\n\tvector<vector<int>> g(n);\n\tvector<int> in(n,0);\n\trep(i,m){\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tu--; v--;\n\t\tg[u].emplace_back(v);\n\t\tg[v].emplace_back(u);\n\t\tin[u]++;\n\t\tin[v]++;\n\t}\n\n\tvector<int> p;\n\tvector<bool> used(n,0);\n\tcut(g, in, used, 0, p);\n\n\tvector<int> cg(n,0);\n\tint ans = accumulate(all(w), 0);\n\trep(i,p.size()){\n\t\tcg[p[i]] = p[i];\n\t\tans -= w[p[i]];\n\t}\n\n\tvector<vector<int>> ng(n);\n\trep(i,n){\n\t\tfor(auto j : g[i]){\n\t\t\tif(cg[i] == 0 and cg[j] == 0) continue;\n\t\t\tng[ cg[i] ].emplace_back( cg[j] );\n\t\t\tng[ cg[j] ].emplace_back( cg[i] );\n\t\t}\n\t}\n\n\tused = vector<bool>(n,0);\n\tused[0] = true;\n\tw[0] = 0;\n\tint maxi = 0;\n\tfor(auto i : ng[0]){\n\t\tmaxi = max(maxi, dfs(ng, w, used, i));\n\t}\n\tcout << ans + maxi << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int> P;\nstruct BiconectedGraph{\n  int n;\n  vector<vector<int> > G,C,T;\n  vector<int> ord,low,belong;\n  vector<P> B;\n  BiconectedGraph(){}\n  BiconectedGraph(int sz):n(sz),G(sz),C(sz),T(sz){}\n  \n  void add_edge(int u,int v){\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n\n  void input(int m,int offset=0){\n    int a,b;\n    for(int i=0;i<m;i++){\n      cin>>a>>b;\n      add_edge(a+offset,b+offset);\n    }\n  }\n  \n  bool is_bridge(int u,int v){\n    if(ord[u]>ord[v]) swap(u,v);\n    return ord[u]<low[v];\n  }\n  \n  void dfs(int v,int p,int &k){\n    ord[v]=low[v]=k;\n    ++k;\n    for(int u:G[v]){\n      if(u==p) continue;\n      if(ord[u]>=0){\n  low[v]=min(low[v],ord[u]);\n      }else{\n  dfs(u,v,k);\n  low[v]=min(low[v],low[u]);\n      }\n      if(is_bridge(u,v)) B.push_back(P(u,v));\n    }\n  }\n  \n  void fill_component(int c,int v){\n    C[c].push_back(v);\n    belong[v]=c;\n    for(int u:G[v]){\n      if(belong[u]>=0||is_bridge(u,v)) continue;\n      fill_component(c,u);\n    }\n  }\n  \n  void add_component(int v,int &k){\n    if(belong[v]>=0) return;\n    fill_component(k++,v);\n  }\n  \n  int build(){\n    int k=0;\n    ord.resize(n);\n    low.resize(n);\n    belong.resize(n);\n    fill(ord.begin(),ord.end(),-1);\n    fill(belong.begin(),belong.end(),-1);\n    for(int v=0;v<n;v++){\n      if(ord[v]>=0) continue;\n      dfs(v,-1,k);\n    }\n    k=0;\n    for(int i=0;i<(int)B.size();i++){\n      add_component(B[i].first,k);\n      add_component(B[i].second,k);\n    }\n    for(int v=0;v<n;v++) add_component(v,k);\n    for(int i=0;i<(int)B.size();i++){\n      int u=belong[B[i].first],v=belong[B[i].second];\n      T[u].push_back(v);\n      T[v].push_back(u);\n    }\n    return k;\n  }\n};\n//END CUT HERE\n\nint dfs(int x,vector<int>&used,vector<vector<int> >&v,map<int,int>&m){\n  used[x]=1;\n  int res=0;\n  int now=m[x];\n  r(i,v[x].size()){\n    if(used[v[x][i]])continue;\n    res=max(res,dfs(v[x][i],used,v,m));\n  }\n  return res+now;\n}\n\nint n,m,w[100009],x[100009],y[1000009];\n\nsigned main(){\n  cin>>n>>m;\n  r(i,n)cin>>w[i];\n  BiconectedGraph bcc(n);\n  set<P>tt;\n  r(i,m){\n    cin>>x[i]>>y[i];\n    x[i]--;y[i]--;\n    if(x[i]==y[i])return 0;\n    bcc.add_edge(x[i],y[i]);\n    if(tt.count(P(x[i],y[i]))||tt.count(P(y[i],x[i])))exit(1);\n    tt.insert(P(x[i],y[i]));\n  }\n  bcc.build();\n  int cnt=0;\n  map<int,int>M,count,wei;\n  set<int>st;\n  r(i,n){\n    if(!st.count(bcc.belong[i])){\n      st.insert(bcc.belong[i]);\n      count[cnt]++;\n      wei[cnt]+=w[i];\n      M[bcc.belong[i]]=cnt++;\n    }\n    else{\n      wei[M[bcc.belong[i]]]+=w[i];\n      count[M[bcc.belong[i]]]++;\n    }\n  }\n  \n  BiconectedGraph B(cnt+1);\n  int root = M[bcc.belong[0]];\n  vector<P>hen;\n  r(i,m){\n    if(bcc.belong[x[i]]==bcc.belong[y[i]])continue;\n    B.add_edge(M[bcc.belong[x[i]]],M[bcc.belong[y[i]]]);\n    hen.push_back(P(M[bcc.belong[x[i]]],M[bcc.belong[y[i]]]));\n\n  }\n  r(i,cnt){\n    if(count[i]>1){\n      B.add_edge(cnt,i);\n      hen.push_back(P(cnt,i));\n    }\n  } \n  B.build();\n  st.clear();\n  map<int,int>wei2;\n  M.clear();\n  int cnt2=0;\n  r(i,cnt+1){\n    if(!st.count(B.belong[i])){\n      st.insert(B.belong[i]);\n      wei2[cnt2]+=wei[i];\n      M[B.belong[i]]=cnt2++;\n    }\n    else{\n      wei2[M[B.belong[i]]]+=wei[i];\n    }\n  }\n  vector<vector<int> >v(cnt2);\n  r(i,hen.size()){\n    int x=hen[i].first;\n    int y=hen[i].second;\n    if(B.belong[x]==B.belong[y])continue;\n    v[x].push_back(y);\n    v[y].push_back(x);\n  }\n  vector<int>used(cnt2,0);\n  cout<<dfs(root,used,v,wei2)<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_V 100005\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\nint V;\nvector<int> G[MAX_V];\nvector<int> rG[MAX_V];\nvector<int> vs;\nbool used[MAX_V];\nint cmp[MAX_V];\n\nvoid add_edge(int from,int to){\n  G[from].push_back(to);\n  rG[to].push_back(from);\n}\n\nvoid dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++)\n    if(!used[G[v][i]])dfs(G[v][i]);\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v]=true;\n  cmp[v]=k;\n  for(int i=0;i<rG[v].size();i++)\n    if(!used[rG[v][i]])rdfs(rG[v][i],k);\n}\n\nint scc(){\n  memset(used,0,sizeof(used));\n  vs.clear();\n  for(int v=0;v<V;v++)\n    if(!used[v])dfs(v);\n  memset(used,0,sizeof(used));\n  int k=0;\n  for(int i=vs.size()-1;i>=0;i--)\n    if(!used[vs[i]])rdfs(vs[i],k++);\n  return k;\n}\n\nvector<int> G2[MAX_V];\nset<P> usede;\n\nvoid dfs2(int x){\n  for(int i=0;i<G2[x].size();i++){\n    if(usede.find(P(x,G2[x][i]))!=usede.end())continue;\n    usede.insert(P(x,G2[x][i]));\n    usede.insert(P(G2[x][i],x));\n    add_edge(x,G2[x][i]);\n    dfs2(G2[x][i]);\n  }\n}\n\nint n,m,w[MAX_V],u,v;\nint sum[MAX_V],f[MAX_V];\nint used2[MAX_V],ans;\n\nint dfs3(int x){\n  if(used[x])return 0;\n  used[x]=true;\n  int r=0;\n  for(int i=0;i<G2[x].size();i++)\n    r|=dfs3(G2[x][i]);\n  if(f[cmp[x]])r=1;\n  if(!used2[cmp[x]]&&r){\n    ans+=sum[cmp[x]];\n    used2[cmp[x]]=1;\n  }\n  return r;\n}\n\nint maxs=0;\nvoid dfs4(int x,int s){\n  int flag=0;\n  for(int i=0;i<G2[x].size();i++){\n    if(used[G2[x][i]])continue;\n    used[G2[x][i]]=true;\n    flag=1;\n    if(cmp[x]!=cmp[G2[x][i]]&&!used2[cmp[x]])\n      dfs4(G2[x][i],s+sum[cmp[x]]);\n    else dfs4(G2[x][i],s);\n  }\n  if(!flag&&!used2[cmp[x]])maxs=max(maxs,s+sum[cmp[x]]);\n}\n\nvoid solve(){\n  dfs2(0);\n  int K=scc();\n  for(int i=0;i<V;i++){\n    if(sum[cmp[i]])f[cmp[i]]=1;\n    sum[cmp[i]]+=w[i];\n  }\n  memset(used,0,sizeof(used));\n  dfs3(0);\n  memset(used,0,sizeof(used));\n  used[0]=true;\n  dfs4(0,0);\n  ans+=maxs;\n  cout<<ans<<endl;\n}\n\nint main(){\n  cin>>n>>m;\n  V=n;\n  for(int i=0;i<n;i++)cin>>w[i];\n  for(int i=0;i<m;i++){\n    cin>>u>>v;\n    u--,v--;\n    G2[u].push_back(v);\n    G2[v].push_back(u);\n  }\n  solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct UnionFind\n{\n  vector< int > data;\n\n  UnionFind(int sz)\n  {\n    data.assign(sz, -1);\n  }\n\n  bool unite(int x, int y)\n  {\n    x = find(x), y = find(y);\n    if(x == y) return (false);\n    if(data[x] > data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n    return (true);\n  }\n\n  int find(int k)\n  {\n    if(data[k] < 0) return (k);\n    return (data[k] = find(data[k]));\n  }\n\n  int size(int k)\n  {\n    return (-data[find(k)]);\n  }\n};\n\nstruct BiConnectedComponents\n{\n  UnionFind uf;\n  vector< vector< int > > g;\n  vector< pair< int, int > > edges;\n  vector< int > used, ord, low, comp;\n\n  BiConnectedComponents(size_t v) : uf(v), g(v), used(v, 0), comp(v), ord(v), low(v)\n  {\n  }\n\n  void add_edge(int x, int y)\n  {\n    g[x].push_back(y);\n    g[y].push_back(x);\n    edges.push_back(minmax(x, y));\n  }\n\n  void dfs(int idx, int &k, int par = -1)\n  {\n    used[idx] = true;\n    ord[idx] = k++;\n    low[idx] = ord[idx];\n\n    for(auto &to : g[idx]) {\n      if(!used[to]) {\n        dfs(to, k, idx);\n        low[idx] = min(low[idx], low[to]);\n        if(ord[idx] >= low[to]) uf.unite(idx, to);\n      } else if(to != par) {\n        low[idx] = min(low[idx], ord[to]);\n      }\n    }\n  }\n\n  int operator[](int k)\n  {\n    return (comp[k]);\n  }\n\n  size_t size()\n  {\n    return (g.size());\n  }\n\n  void build(vector< vector< int > > &t)\n  {\n    int kk = 0;\n    dfs(0, kk);\n\n    int ptr = 0;\n    vector< int > cc(g.size());\n    for(int i = 0; i < g.size(); i++) {\n      if(i == uf.find(i)) cc[i] = ptr++;\n    }\n\n    t.resize(ptr);\n    for(int i = 0; i < g.size(); i++) {\n      comp[i] = cc[uf.find(i)];\n    }\n    for(auto &e : edges) {\n      int x = comp[e.first], y = comp[e.second];\n      if(x == y) continue;\n      t[x].push_back(y);\n      t[y].push_back(x);\n    }\n  }\n};\n\nint N, M, W[100000];\nvector< vector< int > > g;\nvector< int > weightSum, sz;\nint dp1[100000], dp3[100000];\n\nint rec(int idx, int par = -1)\n{\n  int ret = 0;\n  for(auto &to : g[idx]) {\n    if(to == par) continue;\n    ret = max(ret, rec(to, idx));\n    dp1[idx] += dp1[to];\n  }\n  ret += weightSum[idx];\n  if(sz[idx] >= 3 || dp1[idx] > 0) dp1[idx] += weightSum[idx];\n  for(auto &to : g[idx]) {\n    if(to == par) continue;\n    else ret = max(ret, dp1[idx] - dp1[to] + dp3[to]);\n  }\n  return (dp3[idx] = ret);\n}\n\nint main()\n{\n  scanf(\"%d %d\", &N, &M);\n  BiConnectedComponents tree(N);\n  for(int i = 0; i < N; i++) {\n    scanf(\"%d\", &W[i]);\n  }\n  while(M--) {\n    int U, V;\n    scanf(\"%d %d\", &U, &V);\n    tree.add_edge(--U, --V);\n  }\n  tree.build(g);\n  weightSum.assign(g.size(), 0);\n  sz.assign(g.size(), 0);\n  for(int i = 0; i < N; i++) {\n    weightSum[tree[i]] += W[i];\n    sz[tree[i]]++;\n  }\n  printf(\"%d\\n\", rec(tree[0]));\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n\nusing VS = vector<string>;    using LL = long long;\nusing VI = vector<int>;       using VVI = vector<VI>;\nusing PII = pair<int, int>;   using PLL = pair<LL, LL>;\nusing VL = vector<LL>;        using VVL = vector<VL>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n#define FOR(i, s, e) for (int(i) = (s); (i) < (e); (i)++)\n#define FORR(i, s, e) for (int(i) = (s); (i) > (e); (i)--)\n#define debug(x) cerr << #x << \": \" << x << endl\nconst int INF = 1e9;                          const LL LINF = 1e16;\nconst LL MOD = 1000000007;                    const double PI = acos(-1.0);\nint DX[8] = { 0, 0, 1, -1, 1, 1, -1, -1 };    int DY[8] = { 1, -1, 0, 0, 1, -1, 1, -1 };\n\n/*-----------------------------------------------\n 二辺連結成分分解 成分だけ unverified\n -----------------------------------------------*/\n\n\nstruct UnionFind {\n    vector<int> data;\n    UnionFind(int n) { data.assign(n, -1); }\n    bool unionSet(int x, int y) {\n        x = root(x); y = root(y);\n        if (x != y) {\n            if (data[y] < data[x]) swap(x, y);\n            data[x] += data[y]; data[y] = x;\n        }\n        return x != y;\n    }\n    bool same(int x, int y) { return root(x) == root(y); }\n    int root(int x) { return data[x] < 0 ? x : data[x] = root(data[x]); }\n    int size(int x) { return -data[root(x)]; }\n};\n\nstruct Lowlink {\n    UnionFind uf;\n    vector<int> low, ord, used, parent;\n    int root, k;\n    Lowlink(int V, int Root) :uf(V), low(V), ord(V), used(V), parent(V), root(Root), k(0) {}\n    \n    void lowlink(int v, int p, int &k, vector<vector<int>>& G) {\n        used[v] = true;\n        low[v] = ord[v] = k; k++;\n        for (int i = 0; i < (int)G[v].size(); i++) {\n            int u = G[v][i];\n            if (used[u] == 0) {\n                parent[u] = v;\n                lowlink(u, v, k, G);\n                low[v] = min(low[v], low[u]);\n                if (ord[v] >= low[u])uf.unionSet(v, u);\n            }\n            else if (u != p) {\n                low[v] = min(low[v], ord[u]);\n            }\n        }\n    }\n};\n\nstruct TwoEdgeConnectedComponent:Lowlink{\n //   UnionFind uf;\n    vector<vector<int>> g;\n    vector<pair<int, int>> edges;\n    vector<int> comp;\n    TwoEdgeConnectedComponent(int v) : g(v),comp(v),Lowlink(v,0) {}\n    \n    void add_edge(int x, int y) {\n        g[x].push_back(y);\n        g[y].push_back(x);\n        edges.push_back(minmax(x, y));\n    }\n    // return origin color\n    int operator[](int k) {\n        return (comp[k]);\n    }\n    \n    int size() {\n        return (g.size());\n    }\n    \n    // build, renew resG(empty -> tree), return color\n    vector<int> get_graph(vector<vector<int>>& resG,VI& W,VI& resW,int root = 0) {\n        int kk = 0;\n        Lowlink::lowlink(root, -1, kk, g);\n        int ptr = 0;\n        vector<int> color(g.size());\n        for (int i = 0; i < g.size(); i++) {\n            if (i == uf.root(i)) color[i] = ptr++;\n        }\n        \n        resG.resize(ptr);\n        for (int i = 0; i < g.size(); i++) {\n            comp[i] = color[uf.root(i)];\n        }\n        \n        resW.resize(ptr);\n        for (int i = 0; i < (int)g.size(); i++) {\n            comp[i] = color[uf.root(i)];\n            // 頂点番号における写像を作る\n            resW[comp[i]] += W[i];//重みをまとめる\n        }\n//        for (auto &e : edges) {\n//            int x = comp[e.first], y = comp[e.second];\n//            if (x == y) continue;\n//            resG[x].push_back(y);\n//            resG[y].push_back(x);\n//        }\n        \n        for (int v = 0; v < (int)g.size(); v++) {\n            for (int i = 0; i < (int)g[v].size(); i++) {\n                int u = g[v][i];\n                int c1 = comp[v], c2 = comp[u];\n                if (c1 == c2)continue;\n                resG[c1].push_back(c2);\n                resG[c2].push_back(c1);\n            }\n        }\n        return comp;\n    }\n};\n\nLL dfs(int v, int p, VVI& G, VL& dp, VI& w) {\n    LL res = 0;\n    FOR(i, 0, SZ(G[v])) {\n        int nx = G[v][i];\n        if (nx == p)continue;\n        res = max(res, dfs(nx, v, G, dp, w));\n    }\n    return dp[v] = res + w[v];\n}\n\nint main() {\n    int N, M;\n    vector<vector<int>> resG;\n\n    cin >> N >> M;\n    VI W(N);\n    FOR(i, 0, N) {\n        cin >> W[i];\n    }\n    \n    \n    TwoEdgeConnectedComponent gx(N);\n    FOR(i, 0, M) {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        gx.add_edge(a, b);\n    }\n    VI resW;\n    VI vc = gx.get_graph(resG,W,resW);\n    \n    VL dp(N,0);\n    LL ans = dfs(0,-1,resG,dp,resW);\n    cout << ans << endl;\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\nint dfs(vector<vector<int>>& g, vector<int>& w, vector<bool>& used, int pos){\n\tused[pos] = true;\n\tint res = w[pos];\n\tfor(auto to : g[pos]){\n\t\tif(used[to]) continue;\n\t\tres += dfs(g, w, used, to);\n\t}\n\treturn res;\n}\n\nvoid cut(vector<vector<int>>& g, vector<int>& in, vector<bool>& used, int pos, vector<int>& p){\n\tused[pos] = true;\n\tfor(auto to : g[pos]){\n\t\tif(used[to]) continue;\n\t\tcut(g, in, used, to, p);\n\t}\n\tif(in[pos] == 1){\n\t\tp.emplace_back(pos);\n\t\tin[pos] = 0;\n\t\tfor(auto i : g[pos]){\n\t\t\tin[i]--;\n\t\t}\n\t}\n}\n\nint main(){\n\tint n, m;\n\tcin >> n >> m;\n\n\tvector<int> w(n);\n\tcin >> w;\n\n\tvector<vector<int>> g(n);\n\tvector<int> in(n,0);\n\trep(i,m){\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tu--; v--;\n\t\tg.at(u).emplace_back(v);\n\t\tg.at(v).emplace_back(u);\n\t}\n\n\trep(i,n){\n\t\tin.at(i) = g.at(i).size();\n\t}\n\n\tvector<int> p;\n\tvector<bool> used(n,0);\n\tcut(g, in, used, 0, p);\n\n\tvector<int> cg(n,0);\n\tint ans = accumulate(all(w), 0);\n\trep(i,p.size()){\n\t\tcg[p[i]] = p[i];\n\t\tans -= w[p[i]];\n\t}\n\n\tvector<vector<int>> ng(n);\n\trep(i,n){\n\t\tfor(auto j : g[i]){\n\t\t\tif(cg[i] == 0 and cg[j] == 0) continue;\n\t\t\tng[ cg[i] ].emplace_back( cg[j] );\n\t\t\tng[ cg[j] ].emplace_back( cg[i] );\n\t\t}\n\t}\n\n\tused = vector<bool>(n,0);\n\tused[0] = true;\n\tint maxi = 0;\n\tfor(auto i : ng[0]){\n\t\tmaxi = max(maxi, dfs(ng, w, used, i));\n\t}\n\tcout << ans + maxi << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_N 100011\n#define N MAX_N\n#define rank dfasfds\nusing namespace std;\ntypedef long long ll;\ntypedef set<int> S;\nint par[MAX_N],rank[MAX_N];\nll val[MAX_N];\nS G[N];\n\nvoid init(int n){for(int i=0;i<N;i++)par[i]=i,rank[i]=0;}\n\nint find(int x){\n  if(par[x]==x)return x;\n  return par[x]=find(par[x]);\n}\n\nbool same(int x,int y){return find(x)==find(y);}\n\nvoid unite(int x,int y){\n  x=find(x),y=find(y);\n  if(x==y)return;\n  if(rank[x]<rank[y])par[x]=y,val[y]+=val[x];\n  else{\n    par[y]=x;\n    val[x]+=val[y];\n    if(rank[x]==rank[y])rank[x]++;\n  }\n}\n\nint used[N];\nvector<int> path;\nvoid dfs(int pos,int pre){\n  if(pos!=find(pos))return;\n  if(used[pos]) {\n    for(int i=0;i<path.size();i++)unite(pos,path[i]);\n    return;\n  }\n  used[pos]=1;\n  path.push_back(pos);\n  for(S::iterator it=G[pos].begin();it!=G[pos].end();it++)if(*it!=pre)dfs(*it,pos);\n  used[pos]=0;\n  path.pop_back();\n}\n\nvector<int>col[N];\nll get_mx(int pos){\n  used[find(pos)]=1;\n  ll res=0;\n  pos=find(pos);\n  for(int i=0;i<col[pos].size();i++)\n    for(S::iterator it=G[col[pos][i]].begin();it!=G[col[pos][i]].end();it++)\n      if(!used[find(*it)])res=max(res,get_mx(find(*it)));\n  return res+val[find(pos)];\n}\n\nint main(){\n  int n,m;\n  cin>>n>>m;\n  for(int i=0;i<n;i++) cin>>val[i];\n  for(int i=0,a,b;i<m;i++){\n    cin>>a>>b;a--,b--;\n    G[a].insert(b);\n    G[b].insert(a);\n  }\n  init(n);\n  dfs(0,-1);\n  for(int i=0;i<n;i++) col[find(i)].push_back(i);\n  cout <<get_mx(find(0))<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define MAX_V 111111\ntypedef pair<int,int> P;\nvector<int> G[MAX_V],C[MAX_V],T[MAX_V],ord,low,belong;\nvector<P> B;\nbool is_bridge(int u,int v){\n  if(ord[u]>ord[v]) swap(u,v);\n  return ord[u]<low[v];\n}\nvoid dfs(int u,int p,int &k){\n  ord[u]=low[u]=k;\n  k++;\n  for(int i=0;i<(int)G[u].size();i++){\n    int v=G[u][i];\n    if(v==p) continue;\n    if(ord[v]>=0){\n      low[u]=min(low[u],ord[v]);\n    }else{\n      dfs(v,u,k);\n      low[u]=min(low[u],low[v]);\n    }\n    if(is_bridge(u,v)) B.push_back(P(u,v));\n  }\n}\nvoid fill_component(int c,int u){\n  C[c].push_back(u);\n  belong[u]=c;\n  for(int i=0;i<(int)G[u].size();i++){\n    int v=G[u][i];\n    if(belong[v]>=0||is_bridge(u,v)) continue;\n    fill_component(c,v);\n  }\n}\nvoid add_component(int u,int &k){\n  if(belong[u]>=0) return;\n  fill_component(k++,u);\n}\nvoid biconnectedgrapth(int n){\n  int k=0;\n  ord.resize(n,-1);\n  low.resize(n);\n  belong.resize(n,-1);\n  for(int v=0;v<n;v++){\n    if(ord[v]>=0) continue;\n    dfs(v,-1,k);\n  }\n  k=0;\n  for(int i=0;i<(int)B.size();i++){\n    add_component(B[i].first,k);\n    add_component(B[i].second,k);\n  }\n  add_component(0,k);\n  \n  for(int i=0;i<n;i++) assert(belong[i]>=0);\n  \n  for(int i=0;i<(int)B.size();i++){\n    int u=belong[B[i].first],v=belong[B[i].second];\n    T[u].push_back(v);\n    T[v].push_back(u);\n  }\n}\n\nvoid add_edge(int u,int v){\n  G[u].push_back(v);\n  G[v].push_back(u);\n}\n\nint W[MAX_V];\n\nint dfs2(int u,int p){\n  int res=0;\n  for(int i=0;i<(int)T[u].size();i++){\n    int v=T[u][i];\n    if(v==p) continue;\n    res=max(res,dfs2(v,u));\n  }\n  return W[u]+res;\n}\nsigned main(){\n  int n,m;\n  cin>>n>>m;\n  int w[n];\n  for(int i=0;i<n;i++) cin>>w[i];\n  for(int i=0;i<m;i++){\n    int u,v;\n    cin>>u>>v;\n    add_edge(u-1,v-1);\n  }\n  biconnectedgrapth(n);\n  for(int i=0;i<n;i++) W[belong[i]]+=w[i];\n  cout<<dfs2(belong[0],-1)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int> P;\nstruct BiconectedGraph{\n  int n;\n  vector<vector<int> > G,C,T;\n  vector<int> ord,low,belong;\n  vector<P> B;\n  BiconectedGraph(){}\n  BiconectedGraph(int sz):n(sz),G(sz),C(sz),T(sz){}\n  \n  void add_edge(int u,int v){\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n\n  void input(int m,int offset=0){\n    int a,b;\n    for(int i=0;i<m;i++){\n      cin>>a>>b;\n      add_edge(a+offset,b+offset);\n    }\n  }\n  \n  bool is_bridge(int u,int v){\n    if(ord[u]>ord[v]) swap(u,v);\n    return ord[u]<low[v];\n  }\n  \n  void dfs(int v,int p,int &k){\n    ord[v]=low[v]=k;\n    ++k;\n    for(int u:G[v]){\n      if(u==p) continue;\n      if(ord[u]>=0){\n  low[v]=min(low[v],ord[u]);\n      }else{\n  dfs(u,v,k);\n  low[v]=min(low[v],low[u]);\n      }\n      if(is_bridge(u,v)) B.push_back(P(u,v));\n    }\n  }\n  \n  void fill_component(int c,int v){\n    C[c].push_back(v);\n    belong[v]=c;\n    for(int u:G[v]){\n      if(belong[u]>=0||is_bridge(u,v)) continue;\n      fill_component(c,u);\n    }\n  }\n  \n  void add_component(int v,int &k){\n    if(belong[v]>=0) return;\n    fill_component(k++,v);\n  }\n  \n  int build(){\n    int k=0;\n    ord.resize(n);\n    low.resize(n);\n    belong.resize(n);\n    fill(ord.begin(),ord.end(),-1);\n    fill(belong.begin(),belong.end(),-1);\n    for(int v=0;v<n;v++){\n      if(ord[v]>=0) continue;\n      dfs(v,-1,k);\n    }\n    k=0;\n    for(int i=0;i<(int)B.size();i++){\n      add_component(B[i].first,k);\n      add_component(B[i].second,k);\n    }\n    for(int v=0;v<n;v++) add_component(v,k);\n    for(int i=0;i<(int)B.size();i++){\n      int u=belong[B[i].first],v=belong[B[i].second];\n      T[u].push_back(v);\n      T[v].push_back(u);\n    }\n    return k;\n  }\n};\n//END CUT HERE\n\nint dfs(int x,vector<int>&used,vector<vector<int> >&v,map<int,int>&m){\n  used[x]=1;\n  int res=0;\n  int now=m[x];\n  r(i,v[x].size()){\n    if(used[v[x][i]])continue;\n    res=max(res,dfs(v[x][i],used,v,m));\n  }\n  return res+now;\n}\n\nint n,m,w[100009],x[100009],y[1000009];\n\nsigned main(){\n  cin>>n>>m;\n  r(i,n)cin>>w[i];\n  BiconectedGraph bcc(n);\n  r(i,m){\n    cin>>x[i]>>y[i];\n    x[i]--;y[i]--;\n    bcc.add_edge(x[i],y[i]);\n  }\n  bcc.build();\n  int cnt=0;\n  map<int,int>M,count,wei;\n  set<int>st;\n  r(i,n){\n    if(!st.count(bcc.belong[i])){\n      st.insert(bcc.belong[i]);\n      count[cnt]++;\n      wei[cnt]+=w[i];\n      M[bcc.belong[i]]=cnt++;\n    }\n    else{\n      wei[M[bcc.belong[i]]]+=w[i];\n      count[M[bcc.belong[i]]]++;\n    }\n  }\n  \n  BiconectedGraph B(cnt+1);\n  int root = M[bcc.belong[0]];\n  vector<P>hen;\n  r(i,m){\n    if(bcc.belong[x[i]]==bcc.belong[y[i]])continue;\n    B.add_edge(M[bcc.belong[x[i]]],M[bcc.belong[y[i]]]);\n    hen.push_back(P(M[bcc.belong[x[i]]],M[bcc.belong[y[i]]]));\n\n  }\n  r(i,cnt){\n    if(count[i]>1){\n      B.add_edge(cnt,i);\n      hen.push_back(P(cnt,i));\n    }\n  } \n  B.build();\n  st.clear();\n  map<int,int>wei2;\n  M.clear();\n  int cnt2=0;\n  r(i,cnt+1){\n    if(!st.count(B.belong[i])){\n      st.insert(B.belong[i]);\n      wei2[cnt2]+=wei[i];\n      M[B.belong[i]]=cnt2++;\n    }\n    else{\n      wei2[M[B.belong[i]]]+=wei[i];\n    }\n  }\n  vector<vector<int> >v(cnt2);\n  r(i,hen.size()){\n    int x=hen[i].first;\n    int y=hen[i].second;\n    if(B.belong[x]==B.belong[y])continue;\n    v[x].push_back(y);\n    v[y].push_back(x);\n  }\n  vector<int>used(cnt2,0);\n  cout<<dfs(root,used,v,wei2)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\nusing namespace std;\ntypedef pair<int, int> P;\n\nvector<int> edge[108000], edge2[108000];\nvector<P> edges;\nbool come[108000];\nint dp[108000];\nint w[108000];\nint imos[108000];\nint sum[108000];\nint n, m, u, v;\n\nint root[108000];\nint r(int x){\n\tif(root[x] == x)return x;\n\treturn root[x] = r(root[x]);\n}\n\nint unite(int x, int y){\n\tx = r(x);\n\ty = r(y);\n\troot[x] = y;\n}\n\nbool dfs(int x, int last = -1){\n\tcome[x] = true;\n\tfor(int i = 0;i < edge[x].size();i++){\n\t\tint to = edge[x][i];\n\t\tif(to == last)continue;\n\t\tif(!come[to]){\n\t\t\tif(dfs(to, x))unite(to, x);\n\t\t\telse edges.push_back(P(x, to));\n\t\t\timos[x] += imos[to];\n\t\t}\n\t\telse{\n\t\t\timos[to]--;\n\t\t\timos[x]++;\n\t\t}\n\t}\n\treturn imos[x] > 0;\n}\n\nint dfs2(int x){\n\tint res = 0;\n\tfor(int i = 0;i < edge2[x].size();i++){\n\t\tint to = edge2[x][i];\n\t\tres = max(res, dfs2(to));\n\t}\n\treturn res + sum[x];\n}\n\nint main(){\n\tcin >> n >> m;\n\tfor(int i = 1;i <= n;i++){\n\t\tcin >> w[i];\n\t\troot[i] = i;\n\t}\n\tfor(int i = 0;i < m;i++){\n\t\tcin >> u >> v;\n\t\tedge[u].push_back(v);\n\t\tedge[v].push_back(u);\n\t}\n\tdfs(1);\n\tfor(int i = 1;i <= n;i++)sum[r(i)] += w[i];\n\tfor(int i = 0;i < edges.size();i++){\n\t\tP e = edges[i];\n\t\tint u = edges[i].first, v = edges[i].second;\n\t\tedge2[r(u)].push_back(r(v));\n\t}\n\tcout << dfs2(r(1)) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 100000\n\nstruct Info{\n\tInfo(){\n\t\tnode_id = pre_node = sum_value = 0;\n\t}\n\n\tInfo(int arg_node_id,int arg_pre_node,int arg_sum_value){\n\t\tnode_id = arg_node_id;\n\t\tpre_node = arg_pre_node;\n\t\tsum_value = arg_sum_value;\n\t}\n\tbool operator<(const struct Info &arg) const{\n\t\treturn sum_value < arg.sum_value;\n\t}\n\n\tint node_id,pre_node,sum_value;\n};\n\nint N,M;\nint root;\nint value[NUM],in_num[NUM],max_value[NUM];\nbool is_cicle[NUM];\nvector<int> G[NUM];\n\nint main(){\n\n\tscanf(\"%d %d\",&N,&M);\n\n\tfor(int i = 0; i < N; i++)scanf(\"%d\",&value[i]);\n\n\tfor(int i = 0; i < N; i++)in_num[i] = 0;\n\n\troot = 0;\n\tint from,to;\n\n\tfor(int loop = 0; loop < M; loop++){\n\t\tscanf(\"%d %d\",&from,&to);\n\t\tfrom--;\n\t\tto--;\n\t\tG[from].push_back(to);\n\t\tG[to].push_back(from);\n\t\tin_num[from]++;\n\t\tin_num[to]++;\n\t}\n\n\tfor(int i = 0; i < N; i++)is_cicle[i] = true;\n\n\tqueue<int> CALC;\n\tfor(int i = 1; i < N; i++){\n\t\tif(in_num[i] == 1){\n\t\t\tis_cicle[i] = false;\n\t\t\tCALC.push(i);\n\t\t}\n\t}\n\n\tint node_id;\n\tint next_node,next_value;\n\n\twhile(!CALC.empty()){\n\t\tnode_id = CALC.front();\n\t\tCALC.pop();\n\n\t\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\t\tnext_node = G[node_id][i];\n\t\t\tif(is_cicle[next_node] == false || next_node == root)continue;\n\n\t\t\tin_num[next_node]--;\n\t\t\tif(in_num[next_node] == 1){\n\t\t\t\tis_cicle[next_node] = false;\n\t\t\t\tCALC.push(next_node);\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = value[root];\n\tfor(int i = 1; i < N; i++){\n\t\tif(is_cicle[i]){\n\t\t\tans += value[i];\n\t\t}\n\t}\n\n\tprintf(\"ans:%d\\n\",ans);\n\n\tint maximum = 0;\n\tfor(int i = 0; i < N; i++)max_value[i] = 0;\n\n\tpriority_queue<Info> Q;\n\tfor(int i = 0; i < N; i++){\n\t\tif(!is_cicle[i])continue;\n\n\t\tfor(int k = 0; k < G[i].size(); k++){\n\t\t\tnext_node = G[i][k];\n\t\t\tif(is_cicle[next_node])continue;\n\n\t\t\tnext_value = value[next_node];\n\t\t\tif(max_value[next_node] < next_value){\n\t\t\t\tmax_value[next_node] = next_value;\n\t\t\t\tQ.push(Info(next_node,i,next_value));\n\t\t\t}\n\t\t}\n\t}\n\n\tInfo info;\n\twhile(!Q.empty()){\n\n\t\tinfo = Q.top();\n\t\tQ.pop();\n\n\t\tmaximum = max(maximum,info.sum_value);\n\n\t\tif(Q.top().sum_value < max_value[Q.top().node_id]){\n\t\t\tcontinue;\n\t\t}else{\n\t\t\tfor(int i = 0; i < G[Q.top().node_id].size(); i++){\n\t\t\t\tnext_node = G[Q.top().node_id][i];\n\t\t\t\tif(next_node == Q.top().pre_node || is_cicle[next_node] == true)continue;\n\t\t\t\tnext_value = Q.top().sum_value+value[next_node];\n\n\t\t\t\tif(max_value[next_node] < next_value){\n\t\t\t\t\tmax_value[next_node] = next_value;\n\t\t\t\t\tQ.push(Info(next_node,Q.top().node_id,next_value));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",ans+maximum);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nstruct edge{ int to,num; };\n\nvector<edge> G[100000];\nvector<int> G2[100000];\nint a[200000],b[200000],ord[100000],low[100000],w[100000],num[100000],sum[100000],ans = 0,cnt = 0;\nbool used[100000],ok[200000];\n\nvoid dfs(int v,int par){\n\tord[v] = cnt++;\n\tlow[v] = ord[v];\n\tused[v] = true;\n\tfor(edge e : G[v]){\n\t\tif(!used[e.to]){\n\t\t\tdfs(e.to,v);\n\t\t\tlow[v] = min(low[v],low[e.to]);\n\t\t}\n\t\telse if(par != e.to) low[v] = min(low[v],ord[e.to]);\n\t}\n}\n\nvoid dfs2(int v,int r){\n\tused[v] = true;\n\tnum[v] = r;\n\tsum[r] += w[v];\n\tfor(edge e : G[v]){\n\t\tif(ok[e.num] && num[e.to] == -1) dfs2(e.to,r);\n\t}\n}\n\nint dfs3(int v,int par){\n\tint ma = 0;\n\tfor(int to : G2[v]){\n\t\tif(par != to) ma = max(ma,dfs3(to,v));\n\t}\n\treturn ma + sum[v];\n}\n\nsigned main(){\n\tint n,m;\n\tcin >> n >> m;\n\tfor(int i = 0;i < n;i++){\n\t\tcin >> w[i];\n\t\tnum[i] = -1;\n\t}\n\tfor(int i = 0;i < m;i++){\n\t\tcin >> a[i] >> b[i]; a[i]--;b[i]--;\n\t\tG[a[i]].push_back({b[i],i});\n\t\tG[b[i]].push_back({a[i],i});\n\t}\n\tdfs(0,-1);\n\tfor(int i = 0;i < m;i++){\n\t\tif(ord[a[i]] > ord[b[i]]) swap(a[i],b[i]);\n\t\tif(low[b[i]] <= ord[a[i]]) ok[i] = true;\n\t}\n\tfor(int i = 0;i < n;i++){\n\t\tif(num[i] == -1) dfs2(i,i);\n\t}\n\tfor(int i = 0;i < m;i++){\n\t\tif(!ok[i]){\n\t\t\tG2[num[a[i]]].push_back(num[b[i]]);\n\t\t\tG2[num[b[i]]].push_back(num[a[i]]);\n\t\t}\n\t}\n\tcout << dfs3(0,-1) << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2712>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\n\nclass BCC{\nprivate:\n    typedef pair<int,int> pii;\n    vector<vector<int>> G;\n    \n    vector<vector<int>> newG; // BCCのグループの頂点をひとまとめにして新たに作ったグラフ\n    vector<pii> bridges; // 橋の列挙\n    vector<int> group; // 各頂点が含まれるBCCの番号\n    vector<vector<int>> each_bcc; //各BCCでまとまった配列\n    vector<int> order; // 各頂点に訪れた順番\n    stack<int> S; // 既に訪れた頂点のうち、まだどの二重辺連結成分にも割り振られていない頂点の集合\n    vector<int> inS; // 集合Sに各頂点が含まれているかどうかの情報\n    stack<int> roots; // 各二重辺連結成分を、DFS木の部分木として見た時の根の集合\n    \n    int N;\npublic:\n    BCC(int _N){init(_N);}\n    void init(int _N){\n        N = _N;\n        G.clear(); G.resize(N);\n        bridges.clear();\n        group.clear();\n        each_bcc.clear();\n        order.clear();\n        inS.clear();\n    }\n    void add_edge(int u,int v){\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n    void visit(int cur,int prev,int &k){\n        order[cur] = k++;\n        S.push(cur); inS[cur] = true; roots.push(cur);\n        for(int i = 0; i < G[cur].size();i++){\n            int v = G[cur][i];\n            if(order[v] == -1) visit(v,cur,k);\n            else if(v != prev && inS[v]){\n                while(order[roots.top()] > order[v]) roots.pop();\n            }\n        }\n        if(cur == roots.top()){\n            if(prev != -1) bridges.push_back({min(prev,cur),max(prev,cur)});\n            vector<int> bcc;\n            while(true){\n                int node = S.top(); S.pop();\n                inS[node] = false;\n                bcc.push_back(node);\n                group[node] = (int)each_bcc.size();\n                if(node == cur) break;\n            }\n            each_bcc.push_back(bcc);\n            roots.pop();\n        }\n    }\n    void fix(){\n        order.assign(N,-1); inS.assign(N,0); group.assign(N,-1);\n        while(S.size()) S.pop(); while(roots.size()) roots.pop();\n        int k = 0;\n        for(int i = 0; i < N;i++){\n            if(order[i] == -1) visit(i,-1,k);\n        }\n        \n        newG.resize(each_bcc.size());\n        for(int u = 0; u < N;u++){\n            for(int& v:G[u]){\n                if(group[u] == group[v]) continue;\n                newG[group[u]].push_back(group[v]);\n                newG[group[v]].push_back(group[u]);\n            }\n        }\n        for(int u = 0; u < each_bcc.size();u++){\n            sort(newG[u].begin(),newG[u].end());\n            newG[u].erase(unique(newG[u].begin(),newG[u].end()),newG[u].end());\n        }\n    }\n    \n    vector<vector<int>>& Get_each_bcc(){return each_bcc;}\n    vector<int>& Get_group(){return group;}\n    vector<pii>& Get_bridges(){ return bridges; }\n    vector<vector<int>>& Get_Graph(){return newG; }\n};\n\nll rec(ll n,ll prev,vector<vector<int>>& G,vector<ll>& Cost){\n    ll ret = 0;\n    ll T = 0;\n    for(auto& next:G[n]){\n        if(next == prev) continue;\n        T = max(T,rec(next,n,G,Cost));\n    }\n    ret += T;\n    ret += Cost[n];\n    return ret;\n}\nll solve(){\n    ll res = 0;\n    int N,M; cin >> N >> M;\n    vector<int> w(N); for(auto& in:w) cin >> in;\n    BCC bcc(N);\n    for(int i = 0; i < M;i++){\n        int u,v; cin >> u >> v; u--; v--;\n        bcc.add_edge(u, v);\n    }\n    bcc.fix();\n    auto group = bcc.Get_group();\n    auto G = bcc.Get_Graph();\n    vector<ll> Cost(G.size(),0);\n    for(int i = 0; i < N;i++){\n        Cost[group[i]] += w[i];\n    }\n    int root = group[0];\n    return res = rec(root,-1,G,Cost);\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    cout << solve() << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\nusing namespace std;\n\nvoid visit(vector< vector<int> > &G, int cur, int prev, vector< pair<int, int> > &brg, vector< vector<int> > &each_bcc, stack<int> &roots, stack<int> &S, vector<bool> &inS, vector<int> &order, int &k){\n  order[cur] = ++k;\n  //++k;\n  S.push(cur);\n  inS[cur] = true;\n  roots.push(cur);\n  for(int i = 0; i < G[cur].size(); ++i){\n    int to = G[cur][i];\n    if(!order[to]) visit(G, to, cur, brg, each_bcc, roots, S, inS, order, k);\n    else if(to != prev && inS[to]){\n      while(order[roots.top()] > order[to]) roots.pop();\n    }\n  }\n\n  if(cur == roots.top()){\n    if(prev != -1) brg.push_back(pair<int, int>(prev, cur));\n    vector<int> bcc;\n    while(1){\n      int node = S.top();\n      S.pop();\n      inS[node] = false;\n      bcc.push_back(node);\n      if(node == cur) break;\n    }\n    each_bcc.push_back(bcc);\n    roots.pop();\n  }\n}\n\nvoid bridge(vector< vector<int> > &G, vector< pair<int, int> > &brg, vector< vector<int> > &each_bcc){\n  int V = G.size();\n  vector<int> order(V);\n  vector<bool> inS(V);\n  stack<int> roots, S;\n  int k = 0;\n  for(int i = 0; i < V; ++i){\n    if(!order[i]) visit(G, i, -1, brg, each_bcc, roots, S, inS, order, k);\n  }\n}\n\nint dfs(vector< vector<int> > &G, vector<int> &W, int v){\n  int ret = 0, w = W[v];\n  W[v] = 0;\n  for(int i = 0; i < G[v].size(); ++i){\n    int v_ = G[v][i];\n    if(!W[v_]) continue;\n    ret = max(ret, dfs(G, W, v_));\n  }\n  W[v] = w;\n  return ret + w;\n}\n\nint main(){\n  int N, M;\n  cin >> N >> M;\n  vector<int> W(N);\n  for(int i = 0; i < N; ++i) cin >> W[i];\n  vector< vector<int> > G(N);\n  for(int i = 0; i < M; ++i){\n    int u, v;\n    cin >> u >> v;\n    --u;--v;\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n  vector< vector<int> > each_bcc;\n  vector< pair<int, int> > brg;\n  bridge(G, brg, each_bcc);\n  int V = each_bcc.size();\n  vector<int> W_(V, 0);\n  vector<int> cmp(N);\n  for(int i = 0; i < V; ++i){\n    for(int j = 0; j < each_bcc[i].size(); ++j){\n      cmp[each_bcc[i][j]] = i;\n      W_[i] += W[each_bcc[i][j]];\n    }\n  }\n  vector< vector<int> > G_(V);\n  for(int i = 0; i < brg.size(); ++i){\n    int u = brg[i].first, v = brg[i].second;\n    G_[cmp[u]].push_back(cmp[v]);\n    G_[cmp[v]].push_back(cmp[u]);\n  }\n  //for(int i = 0; i < N; ++i) cout << cmp[i] << \" \";cout << endl;\n  //for(int i = 0; i < V; ++i) cout << W_[i] << \" \"; cout << endl;\n  int s = cmp[0];\n  cout << dfs(G_, W_, s) << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_V 100000\nusing namespace std;\nint n,m,w[100001];\nvector<int> v[100001],v1[100001];\nunordered_set<int> st[100001];\nint V;\nvector<int> G[MAX_V];\nvector<int> rG[MAX_V];\nvector<int> vs;\nbool used[MAX_V];\nint cmp[MAX_V];\n\nvoid DFS(int p){\n  for(int i=0;i<v[p].size();i++){\n    int mn=min(v[p][i],p),mx=max(v[p][i],p);\n    if(st[mn].find(mx)==st[mn].end()){\n      st[mn].insert(mx);\n      G[p].push_back(v[p][i]);\n      rG[v[p][i]].push_back(p);\n      DFS(v[p][i]);\n    }\n  }\n}\n\nvoid dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++)if(!used[G[v][i]])dfs(G[v][i]);\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v]=true;\n  cmp[v]=k;\n  for(int i=0;i<rG[v].size();i++)if(!used[rG[v][i]])rdfs(rG[v][i],k);\n}\n\nint scc(){\n  memset(used,0,sizeof(used));\n  vs.clear();\n  for(int v=0;v<V;v++)if(!used[v])dfs(v);\n  memset(used,0,sizeof(used));\n  int k=0;\n  for(int i=vs.size()-1;i>=0;i--)if(!used[vs[i]])rdfs(vs[i],k++);\n  return k;\n}\n\nint C[100001],F[100001],U[100001],ans;\nbool UU[100001];\n\nbool DFS1(int p){\n  if(U[p])return 0;\n  U[p]=1;\n  bool f=F[cmp[p]]>=2;\n  for(int i=0;i<G[p].size();i++)\n    f=max(f,DFS1(G[p][i]));\n  ans+=w[p]*f;\n  return UU[p]=f;\n}\n\nint DFS2(int p){\n  if(UU[p])return 0;\n  UU[p]=1;\n  int res=0;\n  for(int i=0;i<v[p].size();i++)\n    res+=DFS2(v[p][i]);\n  return w[p]+res;\n}\n\nint main(){\n  cin>>V>>m;\n  for(int i=0;i<V;i++)cin>>w[i];\n  for(int j=0,a,b;j<m;j++){\n    cin>>a>>b;a--,b--;\n    v[a].push_back(b),v[b].push_back(a);\n  }\n  DFS(0);\n  scc();\n  for(int i=0;i<V;i++)F[cmp[i]]++;\n  DFS1(0);\n  int mx=0;\n  for(int i=0;i<V;i++)\n    if(!UU[i])mx=max(mx,DFS2(i));\n  cout<<ans+mx<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int> P;\nstruct BiconectedGraph{\n  int n;\n  vector<vector<int> > G,C,T;\n  vector<int> ord,low,belong;\n  vector<P> B;\n  BiconectedGraph(){}\n  BiconectedGraph(int sz):n(sz),G(sz),C(sz),T(sz){}\n  \n  void add_edge(int u,int v){\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n\n  void input(int m,int offset=0){\n    int a,b;\n    for(int i=0;i<m;i++){\n      cin>>a>>b;\n      add_edge(a+offset,b+offset);\n    }\n  }\n  \n  bool is_bridge(int u,int v){\n    if(ord[u]>ord[v]) swap(u,v);\n    return ord[u]<low[v];\n  }\n  \n  void dfs(int v,int p,int &k){\n    ord[v]=low[v]=k;\n    ++k;\n    for(int u:G[v]){\n      if(u==p) continue;\n      if(ord[u]>=0){\n  low[v]=min(low[v],ord[u]);\n      }else{\n  dfs(u,v,k);\n  low[v]=min(low[v],low[u]);\n      }\n      if(is_bridge(u,v)) B.push_back(P(u,v));\n    }\n  }\n  \n  void fill_component(int c,int v){\n    C[c].push_back(v);\n    belong[v]=c;\n    for(int u:G[v]){\n      if(belong[u]>=0||is_bridge(u,v)) continue;\n      fill_component(c,u);\n    }\n  }\n  \n  void add_component(int v,int &k){\n    if(belong[v]>=0) return;\n    fill_component(k++,v);\n  }\n  \n  int build(){\n    int k=0;\n    ord.resize(n);\n    low.resize(n);\n    belong.resize(n);\n    fill(ord.begin(),ord.end(),-1);\n    fill(belong.begin(),belong.end(),-1);\n    for(int v=0;v<n;v++){\n      if(ord[v]>=0) continue;\n      dfs(v,-1,k);\n    }\n    k=0;\n    for(int i=0;i<(int)B.size();i++){\n      add_component(B[i].first,k);\n      add_component(B[i].second,k);\n    }\n    for(int v=0;v<n;v++) add_component(v,k);\n    for(int i=0;i<(int)B.size();i++){\n      int u=belong[B[i].first],v=belong[B[i].second];\n      T[u].push_back(v);\n      T[v].push_back(u);\n    }\n    return k;\n  }\n};\n//END CUT HERE\n\nint dfs(int x,vector<int>&used,vector<vector<int> >&v,map<int,int>&m){\n  used[x]=1;\n  int res=0;\n  int now=m[x];\n  r(i,v[x].size()){\n    if(used[v[x][i]])continue;\n    res=max(res,dfs(v[x][i],used,v,m));\n  }\n  return res+now;\n}\n\nint n,m,w[100009],x[100009],y[1000009];\n\nsigned main(){\n  cin>>n>>m;\n  r(i,n)cin>>w[i];\n  BiconectedGraph bcc(n);\n  r(i,m){\n    cin>>x[i]>>y[i];\n    x[i]--;y[i]--;\n    bcc.add_edge(x[i],y[i]);\n  }\n  bcc.build();\n  int cnt=0;\n  map<int,int>M,count,wei;\n  set<int>st;\n  r(i,n){\n    if(!st.count(bcc.belong[i])){\n      st.insert(bcc.belong[i]);\n      count[cnt]++;\n      wei[cnt]+=w[i];\n      M[bcc.belong[i]]=cnt++;\n    }\n    else{\n      wei[M[bcc.belong[i]]]+=w[i];\n      count[M[bcc.belong[i]]]++;\n    }\n  }\n  \n  BiconectedGraph B(cnt+1);\n  int root = M[bcc.belong[0]];\n  vector<P>hen;\n  r(i,m){\n    if(bcc.belong[x[i]]==bcc.belong[y[i]])continue;\n    B.add_edge(M[bcc.belong[x[i]]],M[bcc.belong[y[i]]]);\n    hen.push_back(P(M[bcc.belong[x[i]]],M[bcc.belong[y[i]]]));\n\n  }\n  r(i,cnt){\n    if(count[i]>1){\n      B.add_edge(cnt,i);\n      hen.push_back(P(cnt,i));\n    }\n  } \n  B.build();\n  st.clear();\n  map<int,int>wei2;\n  M.clear();\n  int cnt2=0;\n  r(i,cnt+1){\n    if(!st.count(B.belong[i])){\n      st.insert(B.belong[i]);\n      wei2[cnt2]+=wei[i];\n      M[B.belong[i]]=cnt2++;\n    }\n    else{\n      wei2[M[B.belong[i]]]+=wei[i];\n    }\n  }\n  vector<vector<int> >v(cnt2);\n  r(i,hen.size()){\n    int x=hen[i].first;\n    int y=hen[i].second;\n    if(B.belong[x]==B.belong[y])continue;\n    v[x].push_back(y);\n    v[y].push_back(x);\n  }\n  vector<int>used(cnt2,0);\n  cout<<dfs(root,used,v,wei2)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nvector<int> v[100001],a;\nint u[100001];\n  \nint dfs(int x,int p) {\n  if(u[x])return 1;\n  u[x]=1;\n  int f=0;\n  for(int i=0;i<v[x].size();i++)if(p!=v[x][i])f|=dfs(v[x][i],x);\n  if(f)a.push_back(x);\n  return f;\n}\n  \nint main() {\n  int n,m;\n  cin>>n>>m;\n  int w[n];\n  for(int i=0;i<n;i++)cin>>w[i];\n  for(int i=0,x,y;i<m;i++){\n    cin>>x>>y;\n    x--,y--;\n    v[x].push_back(y);\n    v[y].push_back(x);\n  }\n  dfs(0,-1);\n  int d[n],ans=0,M=0;\n  fill(d,d+n,-1);\n  priority_queue<P,vector<P>,greater<P> >q;\n  for(int i=0;i<a.size();i++){\n    q.push(P(0,a[i]));\n    d[a[i]]=0;\n    ans+=w[a[i]];\n  }\n  if(q.empty())q.push(P(w[0],0)),d[0]=w[0];\n  while(!q.empty()) {\n    P p=q.top();q.pop();\n    int x=p.second,c=p.first;\n    if(d[x]>c)continue;\n    for(int i=0;i<v[x].size();i++) {\n      int y=v[x][i];\n      if(d[y]==-1)d[y]=d[x]+w[y],q.push(P(d[y],y));\n    }\n  }\n  for(int i=0;i<n;i++)M=max(M,d[i]);\n  cout<<ans+M<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<iomanip>\n#include<sstream>\n#include<map>\n#include<queue>\nusing namespace std;\n#define int long long\nvector<vector<int> >g;\nvector<int> v;\nvoid dfs(int a) {\n\tv[a] = 1;\n\tfor (int i = 0; i < g[a].size(); i++) {\n\t\tif (v[g[a][i]] == 0) {\n\t\t\tdfs(g[a][i]);\n\t\t}\n\t}\n}\nsigned main() {\n\tint N;\n\tint M;\n\tcin >> N >> M;\n\tg.resize(N);\n\tv.resize(N, 0);\n\tvector<int> W(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> W[i];\n\t}\n\tint a, b;\n\tfor (int i = 0; i < M; i++) {\n\t\tcin >> a >> b;\n\t\ta--;\n\t\tb--;\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\tdfs(0);\n\tvector<int> deg(N);\n\tint INF = (int)1 << 60;\n\tvector<int> dp(N, 0);\n\tfor (int i = 0; i < N; i++) {\n\t\tdeg[i] = g[i].size();\n\t}\n\tqueue<int> qu;\n\tfor (int i = 1; i < N; i++) {\n\t\tif (v[i] == 1) {\n\t\t\tif (deg[i] == 1) {\n\t\t\t\tqu.push(i);\n\t\t\t\tdp[i] = 0;\n\t\t\t}\n\t\t}\n\t}\n\twhile (!qu.empty()) {\n\t\tint a = qu.front(); qu.pop();\n\t\tfor (int i = 0; i < g[a].size(); i++) {\n\n\t\t\tdeg[g[a][i]]--;\n\t\t\tif (g[a][i] != 0) {\n\t\t\t\tif (deg[g[a][i]] == 1) {\n\t\t\t\t\tqu.push(g[a][i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[g[a][i]] = max(dp[g[a][i]], dp[a] + W[a]);\n\t\t}\n\t}\n\n\tint mx = 0;\n\tint res = 0;\n\tres = W[0];\n\tmx = dp[0];\n\tfor (int i = 1; i < N; i++) {\n\t\tif (v[i] == 1) {\n\t\t\tif (deg[i] >= 2) {\n\t\t\t\tres += W[i];\n\t\t\t\tmx = max(mx, dp[i]);\n\t\t\t}\n\t\t}\n\t}\n\tres += mx;\n\tcout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool dfs1(int v, int prev, vector<vector<int>>& g, vector<bool>& visited, vector<bool>& f) {\n    visited[v] = true;\n    bool res = false;\n    for(auto to : g[v]) {\n        if(to == prev) {\n            continue;\n        }\n        if(visited[to]) {\n            res = true;\n        } else {\n            res |= dfs1(to, v, g, visited, f);\n        }\n    }\n    return f[v] = res;\n}\n\nint dfs2(int v, vector<vector<int>>& g, vector<bool>& f, int sum, vector<int> const& w) {\n    sum += w[v];\n    f[v] = true;\n    int res = sum;\n    for(auto to : g[v]) {\n        if(!f[to]) {\n            res = max(res, dfs2(to, g, f, sum, w));\n        }\n    }\n    return res;\n}\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    vector<int> w(N);\n    for(int i=0; i<N; ++i) {\n        cin >> w[i];\n    }\n    vector<vector<int>> g(N);\n    for(int i=0; i<M; ++i) {\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    vector<bool> visited(N);\n    vector<bool> f(N);\n    dfs1(0, -1, g, visited, f);\n    int res = 0;\n    for(int i=0; i<N; ++i) {\n        if(f[i]) {\n            res += w[i];\n        }\n    }\n    int ma = 0;\n    for(int i=0; i<N; ++i) {\n        if(!f[i]) {\n            ma = max(ma, dfs2(i, g, f, 0, w));\n        }\n    }\n    cout << res + ma << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define srep(i,s,t) for (int i = s; i < t; ++i)\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\n#define dame { puts(\"-1\"); return 0;}\n#define yn {puts(\"Yes\");}else{puts(\"No\");}\n#define MAX_N 200005\n\nvector<int> G[MAX_N];\nll f[MAX_N];\nint x[MAX_N];\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    ll w[n];\n    rep(i,n)cin >> w[i];\n    rep(i,m){\n        int a, b;\n        cin >> a >> b;\n        a--; b--;\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n    int s; s = 1;\n    s--;\n    rep(i,n){\n        x[i] = G[i].size();\n        f[i] = -1;\n    }\n\n\n    rep(i,n){\n        if(i == s)continue;\n        if(x[i] == 1){\n            f[i] = w[i];\n            int t = i;\n            x[i]--;\n            while(true){\n                int y;\n                rep(j, G[t].size()){\n                    if(f[G[t][j]] == -1){\n                        y = G[t][j];\n                        break;\n                    }\n                }\n\n                if(y == s)break;\n\n                if(x[y] == 2){\n                    if(G[y].size() == 2){\n                        x[y]--;\n                        f[y] = f[t] + w[y];\n                        t = y;\n                        x[y]--;\n                    }else{\n                        x[y]--;\n                        rep(j, G[y].size()){\n                            f[y] = max(f[y], f[G[y][j]]);\n                        }\n                        f[y] = f[y] + w[y];\n                        t = y;\n                        x[y]--;\n                    }\n                }else if(x[y] > 2){\n                    x[y]--;\n                    break;\n                }\n            }\n        }\n    }\n\n\n\n\n    ll ans = 0;\n\n    rep(i,n){\n        if(f[i] == -1){\n            ans += w[i];\n        }\n    }\n\n    ll tmp = 0;\n\n    rep(i,n){\n        tmp = max(f[i], tmp);\n    }\n    ans += tmp;\n\n    cout << ans << endl;\n    return 0;\n}\n \n \n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_V 100000\nusing namespace std;\nint V,m,w[100001],S[100001];\nvector<int> vv[100001];\nvector<int> G[MAX_V];\nvector<int> rG[MAX_V];\nvector<int> vs;\nbool used[MAX_V];\nint cmp[MAX_V];\nint C[100001],F[100001],U[100001],ans,UU[100001],UUU[100001];\n\nvoid DFS(int p,int pr){\n  if(S[p]++)return;\n  for(int i=0;i<vv[p].size();i++){\n    int np=vv[p][i];\n    if(pr!=np){\n      G[p].push_back(np);\n      rG[np].push_back(p);\n      DFS(np,p);\n    }\n  }\n}\n\nvoid dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++)if(!used[G[v][i]])dfs(G[v][i]);\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v]=true;\n  cmp[v]=k;\n  for(int i=0;i<rG[v].size();i++)if(!used[rG[v][i]])rdfs(rG[v][i],k);\n}\n\nint scc(){\n  for(int v=0;v<V;v++)if(!used[v])dfs(v);\n  memset(used,0,sizeof(used));\n  int k=0;\n  for(int i=vs.size()-1;i>=0;i--)if(!used[vs[i]])rdfs(vs[i],k++);\n  return k;\n}\n\nbool DFS1(int p){\n  if(U[p]++)return 0;\n  bool f=F[cmp[p]]>=2;\n  for(int i=0;i<G[p].size();i++)\n    f|=DFS1(G[p][i]);\n  ans+=w[p]*f;\n  return UU[p]=f;\n}\n\nint DFS2(int p){\n  if(UUU[p]++)return 0;\n  int res=0;\n  for(int i=0;i<G[p].size();i++)\n    res=max(res,DFS2(G[p][i]));  \n  return res+(UU[p]?0:w[p]);\n}\n\nint main(){\n  cin>>V>>m;\n  for(int i=0;i<V;i++)cin>>w[i];\n  for(int j=0,a,b;j<m;j++){\n    cin>>a>>b;a--,b--;\n    vv[a].push_back(b),vv[b].push_back(a);\n  }\n  DFS(0,-1);\n  scc();\n  for(int i=0;i<V;i++)F[cmp[i]]++;\n  DFS1(0);\n  cout<<ans+DFS2(0)<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define all(x) (x).begin(),(x).end()\n#define YES() printf(\"YES\\n\")\n#define NO() printf(\"NO\\n\")\n#define isYES(x) printf(\"%s\\n\",(x) ? \"YES\" : \"NO\")\n#define Yes() printf(\"Yes\\n\")\n#define No() printf(\"No\\n\")\n#define isYes(x) printf(\"%s\\n\",(x) ? \"Yes\" : \"No\")\n#define isIn(x,y,h,w) (x >= 0 && x < h && y >= 0 && y < w)\n\n#define int long long\n//using ll = long long;\nusing P = pair<int,int>;\n\nostream &operator<<(ostream &os,const P &p){ return os << \"(\" << p.first << \",\" << p.second << \")\"; }\ntemplate<class T>\nostream &operator<<(ostream &os,const vector<T> &v){\n\tfor(int i = 0;i < v.size();i++) os << (i ? \",\" : \"[\") << v[i];\n\tos << \"]\";\n\treturn os;\n}\n\ntemplate<class T> T &chmin(T &a,const T &b){ return a = min(a,b); }\ntemplate<class T> T &chmax(T &a,const T &b){ return a = max(a,b); }\n\nconst int INF=1e+18;\nconst double EPS=1e-9;\nconst int MOD=1000000007;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\ntemplate<class T>\nstruct Edge{\n\tint from,to;\n\tT cost;\n\tEdge(int to,T cost) : to(to),cost(cost){}\n\tEdge(int from,int to,T cost) : from(from),to(to),cost(cost){}\n\toperator int() const noexcept { return to; }\n};\n\ntemplate<class T>\nusing WeightedGraph = vector<vector<Edge<T>>>;\nusing Graph = vector<vector<int>>;\ntemplate<class T>\nusing Matrix = vector<vector<T>>;\n\ntemplate<class T>\nstruct TwoEdgeConnectedComponents{\n\tT G;\n\tGraph nG;\n\tvector<int> cmp,depth,s;\n\tvector<vector<int>> tecc;\n\tstack<int> vs;\n\tvector<pair<int,int>> bridge;\n\n\tint operator[](int i) const{ return cmp[i]; }\n\n\tTwoEdgeConnectedComponents(const T &G) : G(G),cmp(G.size()),depth(G.size(),-1),s(G.size()){}\n\n\tvoid dfs(int v,int par,int d){\n\t\tdepth[v] = d;\n\t\tvs.push(v);\n\t\tfor(const auto &e : G[v]){\n\t\t\tint to = (int)e;\n\t\t\tif(depth[to] == -1){\n\t\t\t\tdfs(to,v,d + 1);\n\t\t\t\ts[v] += s[to];\n\t\t\t}else if(to != par && depth[v] > depth[to]) s[to]--,s[v]++;\n\t\t}\n\t\tif(!s[v]){\n\t\t\tif(par != -1) bridge.push_back(minmax(v,par));\n\t\t\ttecc.emplace_back();\n\t\t\twhile(1){\n\t\t\t\tint u = vs.top(); vs.pop();\n\t\t\t\ttecc.back().push_back(u);\n\t\t\t\tcmp[u] = tecc.size() - 1;\n\t\t\t\tif(u == v) break;\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid build(){\n\t\tfor(int i = 0;i < G.size();i++) if(depth[i] == -1) dfs(i,-1,0);\n\t\tnG.resize(tecc.size());\n\t\tfor(const auto &e : bridge){\n\t\t\tint x = cmp[e.first],y = cmp[e.second];\n\t\t\tnG[x].push_back(y);\n\t\t\tnG[y].push_back(x);\n\t\t}\n\t}\n};\n\nint n,m,w[100010],s[100010],ma = 0;\nbool isMulti[100010];\n\nbool dfs(TwoEdgeConnectedComponents<Graph> &tecc,int v,int par){\n\tisMulti[v] = (tecc.tecc[v].size() >= 2);\n\tfor(int to : tecc.nG[v]){\n\t\tif(to != par){\n\t\t\tisMulti[v] |= dfs(tecc,to,v);\n\t\t\tchmax(s[v],s[to]);\n\t\t}\n\t}\n\ts[v] += w[tecc.tecc[v][0]];\n\tif(!isMulti[v]) chmax(ma,s[v]);\n\treturn isMulti[v];\n}\n\nsigned main(){\n\tcin >> n >> m;\n\tfor(int i = 0;i < n;i++) cin >> w[i];\n\tGraph G(n);\n\tfor(int i = 0;i < m;i++){\n\t\tint u,v;\n\t\tcin >> u >> v; u--;v--;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\tTwoEdgeConnectedComponents<Graph> tecc(G);\n\ttecc.build();\n\tdfs(tecc,tecc[0],-1);\n\tint ans = 0;\n\tfor(int i = 0;i < tecc.tecc.size();i++){\n\t\tif(isMulti[i]){\n\t\t\tfor(int v : tecc.tecc[i]) ans += w[v];\n\t\t}\n\t}\n\tcout << ans + ma << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX_N 100011\n#define N MAX_N\n#define rank dfasfds\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int>::iterator V;\nint par[MAX_N],rank[MAX_N];\nll val[MAX_N];\nvector<int> G[N];\n\nvoid init(int n){for(int i=0;i<N;i++)par[i]=i,rank[i]=0;}\n\nint find(int x){\n  if(par[x]==x)return x;\n  return par[x]=find(par[x]);\n}\n\nbool same(int x,int y){return find(x)==find(y);}\n\nvoid unite(int x,int y){\n  x=find(x),y=find(y);\n  if(x==y)return;\n  if(rank[x]<rank[y])par[x]=y,val[y]+=val[x];\n  else{\n    par[y]=x;\n    val[x]+=val[y];\n    if(rank[x]==rank[y])rank[x]++;\n  }\n}\n\nint used[N];\nvector<int> path;\nvoid dfs(int pos,int pre){\n  if(used[pos]||pos!=find(pos)) {\n    while(path.size())unite(0,path.back()),path.pop_back();\n    return;\n  }\n  used[pos]=1;\n  path.push_back(pos);\n  for(V it=G[pos].begin();it!=G[pos].end();it++)if(*it!=pre)dfs(*it,pos);\n  used[pos]=0;\n  if(path.size()&&path.back()==pos) path.pop_back();\n}\n\nvector<int>col[N];\nll get_mx(int pos){\n  used[pos]=1;\n  ll res=0;\n  for(int i=0;i<col[pos].size();i++)\n    for(V it=G[col[pos][i]].begin();it!=G[col[pos][i]].end();it++)\n      if(!used[find(*it)])res=max(res,get_mx(find(*it)));\n  return res+val[find(pos)];\n}\n\nint main(){\n  int n,m;\n  cin>>n>>m;\n  for(int i=0;i<n;i++) cin>>val[i];\n  for(int i=0,a,b;i<m;i++){\n    cin>>a>>b;a--,b--;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n  init(n);\n  dfs(0,-1);\n  for(int i=0;i<n;i++) col[find(i)].push_back(i);\n  cout <<get_mx(find(0))<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 100000\n\nstruct Info{\n\tInfo(){\n\t\tnode_id = pre_node = sum_value = 0;\n\t}\n\n\tInfo(int arg_node_id,int arg_pre_node,int arg_sum_value){\n\t\tnode_id = arg_node_id;\n\t\tpre_node = arg_pre_node;\n\t\tsum_value = arg_sum_value;\n\t}\n\tbool operator<(const struct Info &arg) const{ //★総価値の降順(PQ)★\n\t\treturn sum_value < arg.sum_value;\n\t}\n\n\tint node_id,pre_node,sum_value;\n};\n\nint N,M;\nint root;\nint value[NUM],in_num[NUM],max_value[NUM];\nbool is_cicle[NUM];\nvector<int> G[NUM];\n\n/*\n * 木なら葉がある→入次数が1のノードがある!!\n * 葉を刈ったら葉になるノードは、木の一部で非サイクル経路\n */\n\n\nint main(){\n\n\tscanf(\"%d %d\",&N,&M);\n\n\tfor(int i = 0; i < N; i++)scanf(\"%d\",&value[i]);\n\n\tfor(int i = 0; i < N; i++)in_num[i] = 0;\n\n\troot = 0;\n\tint from,to;\n\n\tfor(int loop = 0; loop < M; loop++){\n\t\tscanf(\"%d %d\",&from,&to);\n\t\tfrom--;\n\t\tto--;\n\t\tG[from].push_back(to);\n\t\tG[to].push_back(from);\n\t\tin_num[from]++;\n\t\tin_num[to]++;\n\t}\n\n\tfor(int i = 0; i < N; i++)is_cicle[i] = true;\n\n\t//非サイクル部分を計算\n\tqueue<int> CALC;\n\tfor(int i = 1; i < N; i++){\n\t\tif(in_num[i] == 1){\n\t\t\tis_cicle[i] = false;\n\t\t\tCALC.push(i);\n\t\t}\n\t}\n\n\tint node_id;\n\tint next_node,next_value;\n\n\twhile(!CALC.empty()){\n\t\tnode_id = CALC.front();\n\t\tCALC.pop();\n\n\t\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\t\tnext_node = G[node_id][i];\n\t\t\tif(is_cicle[next_node] == false || next_node == root)continue; //既に葉と認定されているならSKIP\n\n\t\t\tin_num[next_node]--;\n\t\t\tif(in_num[next_node] == 1){ //ボトムアップ的（再帰的）に、木の経路上にあるノードを特定する\n\t\t\t\tis_cicle[next_node] = false;\n\t\t\t\tCALC.push(next_node);\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = value[root];\n\tfor(int i = 1; i < N; i++){\n\t\tif(is_cicle[i]){ //サイクル経路上のノードなら、全て訪問可能\n\t\t\tans += value[i];\n\t\t}\n\t}\n\n\tint maximum = 0;\n\tfor(int i = 0; i < N; i++)max_value[i] = 0; //★★木上の頂点は、元来たノードに戻れないとの制約のため、事実上の有向路となるので、到達時の最大コストで切る★★\n\n\t//始点(rootから行き来できるサイクル中のどれか)をPQに突っ込む\n\tpriority_queue<Info> Q;\n\tfor(int i = 0; i < N; i++){\n\t\tif(!is_cicle[i])continue; //サイクル上の点でなければSKIP\n\n\t\tfor(int k = 0; k < G[i].size(); k++){\n\t\t\tnext_node = G[i][k];\n\t\t\tif(is_cicle[next_node])continue; //行先がサイクル上の点ならSKIP\n\n\t\t\tnext_value = value[next_node];\n\t\t\tif(max_value[next_node] < next_value){ //最大値で遷移する場合のみpush\n\t\t\t\tmax_value[next_node] = next_value;\n\t\t\t\tQ.push(Info(next_node,i,next_value));\n\t\t\t}\n\t\t}\n\t}\n\n\tInfo info;\n\twhile(!Q.empty()){\n\n\t\t//★★降順かつ、値の増えるループなので、先にpopしておく★★\n\t\tinfo = Q.top();\n\t\tQ.pop();\n\n\t\tmaximum = max(maximum,info.sum_value);\n\n\t\tif(info.sum_value < max_value[info.node_id]){\n\t\t\tcontinue;\n\t\t}else{\n\t\t\tfor(int i = 0; i < G[info.node_id].size(); i++){\n\t\t\t\tnext_node = G[info.node_id][i];\n\t\t\t\tif(next_node == info.pre_node || is_cicle[next_node] == true)continue;\n\t\t\t\tnext_value = info.sum_value+value[next_node];\n\n\t\t\t\tif(max_value[next_node] < next_value){\n\t\t\t\t\tmax_value[next_node] = next_value;\n\t\t\t\t\tQ.push(Info(next_node,info.node_id,next_value));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",ans+maximum);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define ll long long\n#define rep(i,l,r)for(ll i=(l);i<(r);i++)\n#define max(p,q)((p)>(q)?(p):(q))\n\nint w[100010];\nint deg[100010];\n\n//辺の情報を個別に持つタイプ\ntypedef struct edge{ll s,g;}E;\ntypedef struct graph{\n\tint vcnt,ecnt;\n\tE  e[200010];//適宜変える(ecnt)\n\tint id[100010];//適宜変える(vcnt)\n}G;\nG g;\n\nint esort(const void*a,const void*b){\n\tE*p=(E*)a,*q=(E*)b;\n\tif((*p).s<(*q).s)return -1;\n\tif((*p).s>(*q).s)return  1;\n\tif((*p).g<(*q).g)return -1;\n\treturn 1;\n}\nvoid readgraph(){\n\t//適宜変える\n\tll n,m;\n\tscanf(\"%lld%lld\",&n,&m);\n\trep(i,0,n)scanf(\"%d\",w+i);\n\trep(i,0,m){\n\t\tll x,y;\n\t\tscanf(\"%lld%lld\",&x,&y);\n\t\tx--,y--;\n\t\tg.e[2*i].s=x;\n\t\tg.e[2*i].g=y;\n\t\tg.e[2*i+1].s=y;\n\t\tg.e[2*i+1].g=x;\n\t\tdeg[x]++;\n\t\tdeg[y]++;\n\t}\n\tg.vcnt=n;\n\tg.ecnt=2*m;\n\tqsort(g.e,g.ecnt,sizeof(E),esort);\n\n\tint p=0;\n\trep(i,0,g.vcnt){\n\t\twhile(p<g.ecnt&&g.e[p].s<i)p++;\n\t\tg.id[i]=p;\n\t}\n\tg.id[g.vcnt]=g.ecnt;//番兵\n}\n\nint oya[100010];\n//dfs\nvoid dfs(int v,int pre){\n\toya[v]=pre+1;\n\trep(i,g.id[v],g.id[v+1]){\n\t\tif(!oya[g.e[i].g]){\n\t\t\tdfs(g.e[i].g,v);\n\t\t}\n\t}\n}\n\n\nint d[100010];\n\nint q[100010],qcnt;\nint main(){\n\treadgraph();\n\tdfs(0,-1);\n\trep(i,0,g.vcnt)if(deg[i]==1)q[qcnt++]=i;\n\trep(ii,0,qcnt){\n\t\tint i=q[ii];\n\t\tif(i==0)continue;\n\t\tint v=oya[i]-1;\n\t\td[v]=max(d[v],w[i]+d[i]);\n\t\tdeg[i]--;\n\t\tdeg[v]--;\n\t\tif(deg[v]==1)q[qcnt++]=v;\n\t}\n\tint ans=w[0];\n\trep(i,1,g.vcnt)if(deg[i])ans+=w[i];\n\tint ddd=0;\n\trep(i,0,g.vcnt)ddd=max(ddd,d[i]);\n\tprintf(\"%d\\n\",ans+ddd);\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n\tdouble[][] p = new double[2][6];\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\tlong[] w = new long[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tw[i] = sc.nextLong();\n\t\t}\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tArrayList<Integer>[] g = new ArrayList[n];\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tg[i] = new ArrayList<>();\n\t\tint[] deg = new int[n];\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tint u = sc.nextInt();\n\t\t\tint v = sc.nextInt();\n\t\t\t--u;\n\t\t\t--v;\n\t\t\tg[u].add(v);\n\t\t\tg[v].add(u);\n\t\t\t++deg[u];\n\t\t\t++deg[v];\n\t\t}\n\n\t\tlong[] f = new long[n];\n\n\t\tArrayDeque<Integer> dq = new ArrayDeque<>();\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (deg[i] == 1 && i != 0) {\n\t\t\t\tdq.add(i);\n\t\t\t}\n\t\t}\n\n\t\twhile (!dq.isEmpty()) {\n\t\t\tint v = dq.pollFirst();\n\t\t\tif (deg[v] == 0)\n\t\t\t\tthrow new AssertionError();\n\t\t\tfor (int dst : g[v]) {\n\t\t\t\tif (deg[dst] == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tf[dst] = Math.max(f[dst], f[v] + w[v]);\n\t\t\t\t--deg[dst];\n\t\t\t\t--deg[v];\n\t\t\t\tif (dst != 0 && deg[dst] == 1) {\n\t\t\t\t\tdq.addLast(dst);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlong ans = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (i == 0 || deg[i] > 0)\n\t\t\t\tans += w[i];\n\t\t}\n\t\tArrays.sort(f);\n\t\tans += f[f.length - 1];\n\t\tSystem.out.println(ans);\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n\tdouble[][] p = new double[2][6];\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\tlong[] w = new long[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tw[i] = sc.nextLong();\n\t\t}\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tArrayList<Integer>[] g = new ArrayList[n];\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tg[i] = new ArrayList<>();\n\t\tint[] deg = new int[n];\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tint u = sc.nextInt();\n\t\t\tint v = sc.nextInt();\n\t\t\t--u;\n\t\t\t--v;\n\t\t\tg[u].add(v);\n\t\t\tg[v].add(u);\n\t\t\t++deg[u];\n\t\t\t++deg[v];\n\t\t}\n\n\t\tlong[] f = new long[n];\n\n\t\tArrayDeque<Integer> dq = new ArrayDeque<>();\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (deg[i] == 1) {\n\t\t\t\tdq.add(i);\n\t\t\t}\n\t\t}\n\n\t\twhile (!dq.isEmpty()) {\n\t\t\tint v = dq.pollFirst();\n\t\t\tfor (int dst : g[v]) {\n\t\t\t\tif (deg[dst] == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tf[dst] = Math.max(f[dst], f[v] + w[v]);\n\t\t\t\t--deg[dst];\n\t\t\t\t--deg[v];\n\t\t\t\tif (dst != 0 && deg[dst] == 1) {\n\t\t\t\t\tdq.addLast(dst);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlong ans = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (i == 0 || deg[i] > 0)\n\t\t\t\tans += w[i];\n\t\t}\n\t\tArrays.sort(f);\n\t\tans += f[f.length - 1];\n\t\tSystem.out.println(ans);\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n\tdouble[][] p = new double[2][6];\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\tlong[] w = new long[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tw[i] = sc.nextLong();\n\t\t}\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tArrayList<Integer>[] g = new ArrayList[n];\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tg[i] = new ArrayList<>();\n\t\tint[] deg = new int[n];\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tint u = sc.nextInt();\n\t\t\tint v = sc.nextInt();\n\t\t\t--u;\n\t\t\t--v;\n\t\t\tg[u].add(v);\n\t\t\tg[v].add(u);\n\t\t\t++deg[u];\n\t\t\t++deg[v];\n\t\t}\n\n\t\tlong[] f = new long[n];\n\n\t\tArrayDeque<Integer> dq = new ArrayDeque<>();\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (deg[i] == 1) {\n\t\t\t\tdq.add(i);\n\t\t\t}\n\t\t}\n\n\t\twhile (!dq.isEmpty()) {\n\t\t\tint v = dq.pollFirst();\n\t\t\tif (deg[v] == 0)\n\t\t\t\tthrow new AssertionError();\n\t\t\tfor (int dst : g[v]) {\n\t\t\t\tif (deg[dst] == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tf[dst] = Math.max(f[dst], f[v] + w[v]);\n\t\t\t\t--deg[dst];\n\t\t\t\t--deg[v];\n\t\t\t\tif (dst != 0 && deg[dst] == 1) {\n\t\t\t\t\tdq.addLast(dst);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlong ans = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (i == 0 || deg[i] > 0)\n\t\t\t\tans += w[i];\n\t\t}\n\t\tArrays.sort(f);\n\t\tans += f[f.length - 1];\n\t\tSystem.out.println(ans);\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "package tester;\n\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n\tdouble[][] p = new double[2][6];\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\tlong[] w = new long[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tw[i] = sc.nextLong();\n\t\t}\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tArrayList<Integer>[] g = new ArrayList[n];\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tg[i] = new ArrayList<>();\n\t\tint[] deg = new int[n];\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tint u = sc.nextInt();\n\t\t\tint v = sc.nextInt();\n\t\t\t--u;\n\t\t\t--v;\n\t\t\tg[u].add(v);\n\t\t\tg[v].add(u);\n\t\t\t++deg[u];\n\t\t\t++deg[v];\n\t\t}\n\n\t\tlong[] f = new long[n];\n\n\t\tArrayDeque<Integer> dq = new ArrayDeque<>();\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (deg[i] == 1) {\n\t\t\t\tdq.add(i);\n\t\t\t}\n\t\t}\n\n\t\twhile (!dq.isEmpty()) {\n\t\t\tint v = dq.pollFirst();\n\t\t\tfor (int dst : g[v]) {\n\t\t\t\tif (deg[dst] == 1)\n\t\t\t\t\tcontinue;\n\t\t\t\tf[dst] = Math.max(f[dst], f[v] + w[v]);\n\t\t\t\t--deg[dst];\n\t\t\t\tif (dst != 0 && deg[dst] == 1) {\n\t\t\t\t\tdq.addLast(dst);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlong ans = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (i == 0 || deg[i] > 1)\n\t\t\t\tans += w[i];\n\t\t}\n\t\tArrays.sort(f);\n\t\tans += f[f.length - 1];\n\t\tSystem.out.println(ans);\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n\tdouble[][] p = new double[2][6];\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\tlong[] w = new long[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tw[i] = sc.nextLong();\n\t\t}\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tArrayList<Integer>[] g = new ArrayList[n];\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tg[i] = new ArrayList<>();\n\t\tint[] deg = new int[n];\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tint u = sc.nextInt() - 1;\n\t\t\tint v = sc.nextInt() - 1;\n\t\t\tg[u].add(v);\n\t\t\tg[v].add(u);\n\t\t\t++deg[u];\n\t\t\t++deg[v];\n\t\t}\n\n\t\tlong[] f = new long[n];\n\n\t\tArrayDeque<Integer> dq = new ArrayDeque<>();\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (deg[i] == 1 && i != 0) {\n\t\t\t\tdq.add(i);\n\t\t\t}\n\t\t}\n\n\t\tlong ans = 0;\n\t\twhile (!dq.isEmpty()) {\n\t\t\tint v = dq.pollFirst();\n\t\t\tfor (int dst : g[v]) {\n\t\t\t\tif (deg[dst] == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tf[dst] = Math.max(f[dst], f[v] + w[v]);\n\t\t\t\tans = Math.max(ans, f[dst]);\n\t\t\t\t--deg[dst];\n\t\t\t\t--deg[v];\n\t\t\t\tif (dst != 0 && deg[dst] == 1) {\n\t\t\t\t\tdq.addLast(dst);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (i == 0 || deg[i] > 0)\n\t\t\t\tans += w[i];\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.io.UncheckedIOException;\nimport java.util.List;\nimport java.nio.charset.Charset;\nimport java.util.StringTokenizer;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author mikit\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        LightScanner in = new LightScanner(inputStream);\n        LightWriter out = new LightWriter(outputStream);\n        ETourism solver = new ETourism();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class ETourism {\n        public void solve(int testNumber, LightScanner in, LightWriter out) {\n            WithMoreStack.run(() -> {\n                int n = in.ints(), m = in.ints();\n                ETourism.City[] cities = new ETourism.City[n];\n                for (int i = 0; i < n; i++) {\n                    cities[i] = new ETourism.City(i, in.longs());\n                }\n                for (int i = 0; i < m; i++) {\n                    int x = in.ints() - 1, y = in.ints() - 1;\n                    cities[x].neighbor.add(cities[y]);\n                    cities[y].neighbor.add(cities[x]);\n                }\n                int s = 0;\n                cities[s].dfs(null);\n                long base = 0;\n                for (int i = 0; i < n; i++) {\n                    cities[i].visited = false;\n                    if (cities[i].cyclic) base += cities[i].value;\n                }\n                out.ans(base + cities[s].solve(null)).ln();\n            });\n        }\n\n        private static class City {\n            int index;\n            long value;\n            List<ETourism.City> neighbor = new ArrayList<>();\n            boolean visited;\n            boolean cyclic;\n\n            City(int index, long value) {\n                this.index = index;\n                this.value = value;\n            }\n\n            boolean dfs(ETourism.City from) {\n                visited = true;\n                for (ETourism.City city : neighbor) {\n                    if (city == from) continue;\n                    if (city.visited || city.dfs(this)) cyclic = true;\n                }\n                return cyclic;\n            }\n\n            long solve(ETourism.City from) {\n                long max = 0;\n                visited = true;\n                for (ETourism.City city : neighbor) {\n                    if (city == from || city.visited) continue;\n                    max = Math.max(max, city.solve(this));\n                }\n                if (!cyclic) max += value;\n                return max;\n            }\n\n        }\n\n    }\n\n    static class LightWriter implements AutoCloseable {\n        private final Writer out;\n        private boolean autoflush = false;\n        private boolean breaked = true;\n\n        public LightWriter(Writer out) {\n            this.out = out;\n        }\n\n        public LightWriter(OutputStream out) {\n            this(new BufferedWriter(new OutputStreamWriter(out, Charset.defaultCharset())));\n        }\n\n        public LightWriter print(char c) {\n            try {\n                out.write(c);\n                breaked = false;\n            } catch (IOException ex) {\n                throw new UncheckedIOException(ex);\n            }\n            return this;\n        }\n\n        public LightWriter print(String s) {\n            try {\n                out.write(s, 0, s.length());\n                breaked = false;\n            } catch (IOException ex) {\n                throw new UncheckedIOException(ex);\n            }\n            return this;\n        }\n\n        public LightWriter ans(String s) {\n            if (!breaked) {\n                print(' ');\n            }\n            return print(s);\n        }\n\n        public LightWriter ans(long l) {\n            return ans(Long.toString(l));\n        }\n\n        public LightWriter ln() {\n            print(System.lineSeparator());\n            breaked = true;\n            if (autoflush) {\n                try {\n                    out.flush();\n                } catch (IOException ex) {\n                    throw new UncheckedIOException(ex);\n                }\n            }\n            return this;\n        }\n\n        public void close() {\n            try {\n                out.close();\n            } catch (IOException ex) {\n                throw new UncheckedIOException(ex);\n            }\n        }\n\n    }\n\n    static class LightScanner {\n        private BufferedReader reader = null;\n        private StringTokenizer tokenizer = null;\n\n        public LightScanner(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n        }\n\n        public String string() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new UncheckedIOException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int ints() {\n            return Integer.parseInt(string());\n        }\n\n        public long longs() {\n            return Long.parseLong(string());\n        }\n\n    }\n\n    static class WithMoreStack {\n        private static final long STACK_SIZE = 64L * 1000 * 1000;\n\n        private WithMoreStack() {\n        }\n\n        public static void run(Runnable task) {\n            try {\n                Thread thread = new Thread(null, task, \"run\", STACK_SIZE);\n                thread.start();\n                thread.join();\n            } catch (InterruptedException ignored) {\n            }\n        }\n\n    }\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n\tdouble[][] p = new double[2][6];\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\tlong[] w = new long[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tw[i] = sc.nextLong();\n\t\t}\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tArrayList<Integer>[] g = new ArrayList[n];\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tg[i] = new ArrayList<>();\n\t\tint[] deg = new int[n];\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tint u = sc.nextInt();\n\t\t\tint v = sc.nextInt();\n\t\t\t--u;\n\t\t\t--v;\n\t\t\tg[u].add(v);\n\t\t\tg[v].add(u);\n\t\t\t++deg[u];\n\t\t\t++deg[v];\n\t\t}\n\n\t\tlong[] f = new long[n];\n\n\t\tArrayDeque<Integer> dq = new ArrayDeque<>();\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (deg[i] == 1) {\n\t\t\t\tdq.add(i);\n\t\t\t}\n\t\t}\n\n\t\twhile (!dq.isEmpty()) {\n\t\t\tint v = dq.pollFirst();\n\t\t\tfor (int dst : g[v]) {\n\t\t\t\tif (deg[dst] == 1)\n\t\t\t\t\tcontinue;\n\t\t\t\tf[dst] = Math.max(f[dst], f[v] + w[v]);\n\t\t\t\t--deg[dst];\n\t\t\t\tif (dst != 0 && deg[dst] == 1) {\n\t\t\t\t\tdq.addLast(dst);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlong ans = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (i == 0 || deg[i] > 1)\n\t\t\t\tans += w[i];\n\t\t}\n\t\tArrays.sort(f);\n\t\tans += f[f.length - 1];\n\t\tSystem.out.println(ans);\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "package tester;\n\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n\tdouble[][] p = new double[2][6];\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\tlong[] w = new long[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tw[i] = sc.nextLong();\n\t\t}\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tArrayList<Integer>[] g = new ArrayList[n];\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tg[i] = new ArrayList<>();\n\t\tint[] deg = new int[n];\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tint u = sc.nextInt();\n\t\t\tint v = sc.nextInt();\n\t\t\t--u;\n\t\t\t--v;\n\t\t\tg[u].add(v);\n\t\t\tg[v].add(u);\n\t\t\t++deg[u];\n\t\t\t++deg[v];\n\t\t}\n\n\t\tlong[] f = new long[n];\n\n\t\tArrayDeque<Integer> dq = new ArrayDeque<>();\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (deg[i] == 1) {\n\t\t\t\tdq.add(i);\n\t\t\t}\n\t\t}\n\n\t\twhile (!dq.isEmpty()) {\n\t\t\tint v = dq.pollFirst();\n\t\t\tfor (int dst : g[v]) {\n\t\t\t\tif (deg[dst] == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tf[dst] = Math.max(f[dst], f[v] + w[v]);\n\t\t\t\t--deg[dst];\n\t\t\t\t--deg[v];\n\t\t\t\tif (dst != 0 && deg[dst] == 1) {\n\t\t\t\t\tdq.addLast(dst);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlong ans = 0;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (i == 0 || deg[i] > 0)\n\t\t\t\tans += w[i];\n\t\t}\n\t\tArrays.sort(f);\n\t\tans += f[f.length - 1];\n\t\tSystem.out.println(ans);\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "package tester;\n\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nclass Main {\n\tdouble[][] p = new double[2][6];\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\tlong[] w = new long[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tw[i] = sc.nextLong();\n\t\t}\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tArrayList<Integer>[] g = new ArrayList[n];\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tg[i] = new ArrayList<>();\n\t\tint[] deg = new int[n];\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tint u = sc.nextInt() - 1;\n\t\t\tint v = sc.nextInt() - 1;\n\t\t\tg[u].add(v);\n\t\t\tg[v].add(u);\n\t\t\t++deg[u];\n\t\t\t++deg[v];\n\t\t}\n\n\t\tlong[] f = new long[n];\n\n\t\tArrayDeque<Integer> dq = new ArrayDeque<>();\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (deg[i] == 1 && i != 0) {\n\t\t\t\tdq.add(i);\n\t\t\t}\n\t\t}\n\n\t\tlong ans = 0;\n\t\twhile (!dq.isEmpty()) {\n\t\t\tint v = dq.pollFirst();\n\t\t\tfor (int dst : g[v]) {\n\t\t\t\tif (deg[dst] == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tf[dst] = Math.max(f[dst], f[v] + w[v]);\n\t\t\t\tans = Math.max(ans, f[dst]);\n\t\t\t\t--deg[dst];\n\t\t\t\t--deg[v];\n\t\t\t\tif (dst != 0 && deg[dst] == 1) {\n\t\t\t\t\tdq.addLast(dst);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (i == 0 || deg[i] > 0)\n\t\t\t\tans += w[i];\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Debug;\nusing SB = System.Text.StringBuilder;\nusing System.Numerics;\nusing static System.Math;\nusing Point = System.Numerics.Complex;\nusing Number = System.Int64;\nnamespace Program {\n    public class Solver {\n        Random rnd = new Random(0);\n        public void Solve() {\n            var n = ri;\n            var m = ri;\n            var a = Enumerate(n, x => ri);\n            var ma = new int[n];\n            var G = Enumerate(n, x => new List<int>());\n            var deg = new int[n];\n            deg[0] += 1000000000;\n            for (int i = 0; i < m; i++)\n            {\n                var u = ri - 1; var v = ri - 1;\n                G[u].Add(v);\n                G[v].Add(u);\n                deg[u]++; deg[v]++;\n\n            }\n\n            var q = new Queue<int>();\n            for (int i = 0; i < n; i++)\n                if (deg[i] == 1) q.Enqueue(i);\n            while (q.Any())\n            {\n                var u = q.Dequeue();\n\n                foreach (var t in G[u])\n                {\n                    if (deg[t] <= 1) continue;\n                    deg[t]--;\n                    ma[t] = Max(ma[t], a[u] + ma[u]);\n                    if (deg[t] == 1)\n                        q.Enqueue(t);\n                }\n                ma[u] = a[u] = 0;\n            }\n            Console.WriteLine(a.Sum() + ma.Max());\n\n        }\n        const long INF = 1L << 60;\n        int ri { get { return sc.Integer(); } }\n        long rl { get { return sc.Long(); } }\n        double rd { get { return sc.Double(); } }\n        string rs { get { return sc.Scan(); } }\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n\n        static T[] Enumerate<T>(int n, Func<int, T> f) {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f(i);\n            return a;\n        }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex {\n    static public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") {\n        return string.Join(st, ie);\n    }\n    static public void Main() {\n        Console.SetOut(new Program.IO.Printer(Console.OpenStandardOutput()) { AutoFlush = false });\n        var solver = new Program.Solver();\n        solver.Solve();\n        Console.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO {\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n\n    public class Printer: StreamWriter {\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n    }\n\n    public class StreamScanner {\n        public StreamScanner(Stream stream) { str = stream; }\n\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n\n        private byte read() {\n            if (isEof) return 0;\n            if (ptr >= len)\n            {\n                ptr = 0;\n                if ((len = str.Read(buf, 0, 1024)) <= 0)\n                {\n                    isEof = true;\n                    return 0;\n                }\n            }\n            return buf[ptr++];\n        }\n\n        public char Char() {\n            byte b = 0;\n            do b = read(); while ((b < 33 || 126 < b) && !isEof);\n            return (char)b;\n        }\n        public string Scan() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read()) sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n' && b != 0; b = (char)read()) if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n        public int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n        public double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n    }\n}\n\n#endregion\n\n"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\nn, m = gets.split.map(&:to_i)\nweight = {}\n(gets.split.map(&:to_i)).each.with_index {|w, i| weight[i+1] = w}\ng = {}\n(1..m).each do\n    u, v = gets.split.map(&:to_i)\n    (g[u] ||= Set.new) << v\n    (g[v] ||= Set.new) << u\nend\n\nbuckets = (1..m).map { Set.new }\n(2..n).map do |u|\n    buckets[g[u].size] << u\nend\n\nheaviest_child_weight = {}\nuntil buckets[1].empty?\n    v = buckets[1].to_a[0]\n    buckets[1].delete(v)\n    if w = heaviest_child_weight[v]\n        weight[v] += w\n    end\n    u = g[v].to_a[0]\n    hcw = (heaviest_child_weight[u] ||= 0)\n    heaviest_child_weight[u] = weight[v] if weight[v] > hcw\n    g.delete(v)\n    buckets[g[u].size].delete(u)\n    g[u].delete(v)\n    if u != 1\n        buckets[g[u].size] << u\n    end\n    heaviest_child_weight.delete(v)\n    weight.delete(v)\nend\n\np (weight.values.inject(:+) || 0) + (heaviest_child_weight.values.inject(:+) || 0)"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\nn, m = gets.split.map(&:to_i)\nweight = {}\n(gets.split.map(&:to_i)).each.with_index {|w, i| weight[i+1] = w}\ng = {}\n(1..m).each do\n    u, v = gets.split.map(&:to_i)\n    (g[u] ||= Set.new) << v\n    (g[v] ||= Set.new) << u\nend\n\nheaviest_child_weight = Hash.new(0)\nleafs = (2..n).select {|u| g[u].size == 1}\nuntil leafs.empty?\n    v = leafs.pop\n    if w = heaviest_child_weight[v]\n        weight[v] += w\n    end\n    u = g[v].to_a[0]\n    hcw = heaviest_child_weight[u]\n    heaviest_child_weight[u] = weight[v] if weight[v] > hcw\n    g[u].delete(v)\n    leafs << u if u != 1 && g[u].size == 1\n    heaviest_child_weight.delete(v)\n    weight.delete(v)\nend\n\np (weight.values.inject(:+) || 0) + (heaviest_child_weight.values.max || 0)"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\nn, m = gets.split.map(&:to_i)\nweight = Hash[* (1..n).zip(gets.split.map(&:to_i)).flatten]\ng = {}\n(1..m).each do\n    u, v = gets.split.map(&:to_i)\n    (g[u] ||= Set.new) << v\n    (g[v] ||= Set.new) << u\nend\n\nbuckets = (1..m).map { Set.new }\n(2..n).map do |u|\n    buckets[g[u].size] << u\nend\n\nheaviest_child_weight = {}\nuntil buckets[1].empty?\n    v = buckets[1].to_a[0]\n    buckets[1].delete(v)\n    if w = heaviest_child_weight[v]\n        weight[v] += w\n    end\n    u = g[v].to_a[0]\n    hcw = (heaviest_child_weight[u] ||= 0)\n    heaviest_child_weight[u] = weight[v] if weight[v] > hcw\n    g.delete(v)\n    buckets[g[u].size].delete(u)\n    g[u].delete(v)\n    buckets[g[u].size] << u\n    heaviest_child_weight.delete(v)\n    weight.delete(v)\nend\n\np weight.values.inject(:+) || 0 + heaviest_child_weight.values.inject(:+) || 0"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\nn, m = gets.split.map(&:to_i)\nweight = {}\n(gets.split.map(&:to_i)).each.with_index {|w, i| weight[i+1] = w}\ng = {}\n(1..m).each do\n    u, v = gets.split.map(&:to_i)\n    (g[u] ||= Set.new) << v\n    (g[v] ||= Set.new) << u\nend\n\nbuckets = (1..m).map { Set.new }\n(2..n).map do |u|\n    buckets[g[u].size] << u\nend\n\nheaviest_child_weight = {}\nuntil buckets[1].empty?\n    v = buckets[1].to_a[0]\n    buckets[1].delete(v)\n    if w = heaviest_child_weight[v]\n        weight[v] += w\n    end\n    u = g[v].to_a[0]\n    hcw = (heaviest_child_weight[u] ||= 0)\n    heaviest_child_weight[u] = weight[v] if weight[v] > hcw\n    g.delete(v)\n    buckets[g[u].size].delete(u)\n    g[u].delete(v)\n    buckets[g[u].size] << u\n    heaviest_child_weight.delete(v)\n    weight.delete(v)\nend\n\np (weight.values.inject(:+) || 0) + (heaviest_child_weight.values.inject(:+) || 0)"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\nn, m = gets.split.map(&:to_i)\nweight = Hash[* (1..n).zip(gets.split.map(&:to_i)).flatten]\ng = {}\n(1..m).each do\n    u, v = gets.split.map(&:to_i)\n    (g[u] ||= Set.new) << v\n    (g[v] ||= Set.new) << u\nend\n\nbuckets = (1..m).map { Set.new }\n(2..n).map do |u|\n    buckets[g[u].size] << u\nend\n\nheaviest_child_weight = {}\nuntil buckets[1].empty?\n    v = buckets[1].to_a[0]\n    buckets[1].delete(v)\n    if w = heaviest_child_weight[v]\n        weight[v] += w\n    end\n    u = g[v].to_a[0]\n    hcw = (heaviest_child_weight[u] ||= 0)\n    heaviest_child_weight[u] = weight[v] if weight[v] > hcw\n    g.delete(v)\n    buckets[g[u].size].delete(u)\n    g[u].delete(v)\n    buckets[g[u].size] << u\n    heaviest_child_weight.delete(v)\n    weight.delete(v)\nend\n\np weight.values.inject(:+) + heaviest_child_weight.values.inject(:+)"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\nn, m = gets.split.map(&:to_i)\nweight = {}\n(gets.split.map(&:to_i)).each.with_index {|w, i| weight[i] = w}\ng = {}\n(1..m).each do\n    u, v = gets.split.map(&:to_i)\n    (g[u] ||= Set.new) << v\n    (g[v] ||= Set.new) << u\nend\n\nbuckets = (1..m).map { Set.new }\n(2..n).map do |u|\n    buckets[g[u].size] << u\nend\n\nheaviest_child_weight = {}\nuntil buckets[1].empty?\n    v = buckets[1].to_a[0]\n    buckets[1].delete(v)\n    if w = heaviest_child_weight[v]\n        weight[v] += w\n    end\n    u = g[v].to_a[0]\n    hcw = (heaviest_child_weight[u] ||= 0)\n    heaviest_child_weight[u] = weight[v] if weight[v] > hcw\n    g.delete(v)\n    buckets[g[u].size].delete(u)\n    g[u].delete(v)\n    buckets[g[u].size] << u\n    heaviest_child_weight.delete(v)\n    weight.delete(v)\nend\n\np (weight.values.inject(:+) || 0) + (heaviest_child_weight.values.inject(:+) || 0)"
  },
  {
    "language": "Ruby",
    "code": "n, m = gets.split.map(&:to_i)\nweight = Hash[* (1..n).zip(gets.split.map(&:to_i)).flatten]\ng = {}\n(1..m).each do\n    u, v = gets.split.map(&:to_i)\n    (g[u] ||= Set.new) << v\n    (g[v] ||= Set.new) << u\nend\n\nbuckets = (1..m).map { Set.new }\n(2..n).map do |u|\n    buckets[g[u].size] << u\nend\n\nheaviest_child_weight = {}\nuntil buckets[1].empty?\n    v = buckets[1].to_a[0]\n    buckets[1].delete(v)\n    if w = heaviest_child_weight[v]\n        weight[v] += w\n    end\n    u = g[v].to_a[0]\n    hcw = (heaviest_child_weight[u] ||= 0)\n    heaviest_child_weight[u] = weight[v] if weight[v] > hcw\n    g.delete(v)\n    buckets[g[u].size].delete(u)\n    g[u].delete(v)\n    buckets[g[u].size] << u\n    heaviest_child_weight.delete(v)\n    weight.delete(v)\nend\n\np weight.values.inject(:+) + heaviest_child_weight.values.inject(:+)"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\nn, m = gets.split.map(&:to_i)\nweight = Hash[* (1..n).zip(gets.split.map(&:to_i)).flatten]\ng = {}\n(1..m).each do\n    u, v = gets.split.map(&:to_i)\n    (g[u] ||= Set.new) << v\n    (g[v] ||= Set.new) << u\nend\n\nbuckets = (1..m).map { Set.new }\n(2..n).map do |u|\n    buckets[g[u].size] << u\nend\n\nheaviest_child_weight = {}\nuntil buckets[1].empty?\n    v = buckets[1].to_a[0]\n    buckets[1].delete(v)\n    if w = heaviest_child_weight[v]\n        weight[v] += w\n    end\n    u = g[v].to_a[0]\n    hcw = (heaviest_child_weight[u] ||= 0)\n    heaviest_child_weight[u] = weight[v] if weight[v] > hcw\n    g.delete(v)\n    buckets[g[u].size].delete(u)\n    g[u].delete(v)\n    buckets[g[u].size] << u\n    heaviest_child_weight.delete(v)\n    weight.delete(v)\nend\n\np (weight.values.inject(:+) || 0) + (heaviest_child_weight.values.inject(:+) || 0)"
  },
  {
    "language": "Ruby",
    "code": "require 'set'\nn, m = gets.split.map(&:to_i)\nweight = {}\n(gets.split.map(&:to_i)).each.with_index {|w, i| weight[i] = w}L\ng = {}\n(1..m).each do\n    u, v = gets.split.map(&:to_i)\n    (g[u] ||= Set.new) << v\n    (g[v] ||= Set.new) << u\nend\n\nbuckets = (1..m).map { Set.new }\n(2..n).map do |u|\n    buckets[g[u].size] << u\nend\n\nheaviest_child_weight = {}\nuntil buckets[1].empty?\n    v = buckets[1].to_a[0]\n    buckets[1].delete(v)\n    if w = heaviest_child_weight[v]\n        weight[v] += w\n    end\n    u = g[v].to_a[0]\n    hcw = (heaviest_child_weight[u] ||= 0)\n    heaviest_child_weight[u] = weight[v] if weight[v] > hcw\n    g.delete(v)\n    buckets[g[u].size].delete(u)\n    g[u].delete(v)\n    buckets[g[u].size] << u\n    heaviest_child_weight.delete(v)\n    weight.delete(v)\nend\n\np (weight.values.inject(:+) || 0) + (heaviest_child_weight.values.inject(:+) || 0)"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.container;\nimport std.conv;\nimport std.math;\nimport std.numeric;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nvoid log(A...)(A arg) {\n    stderr.writeln(arg);\n}\nint size(T)(in T s) {\n    return cast(int)s.length;\n}\n\n// graph for bridge finding\nclass Edge {\n    int from, to;\n    bool isBridge;\n    this(int from, int to) {\n        this.from = from;\n        this.to = to;\n    }\n    override string toString() {\n        return [from, to, isBridge].to!string;\n    }\n}\nclass Graph {\n    Edge[][] G;\n    int V;\n    this(int V) {\n        this.V = V;\n        G = new Edge[][V];\n    }\n    void addEdge(int from, int to) {\n        G[from] ~= new Edge(from, to);\n        G[to] ~= new Edge(to, from);\n    }\n    void findBridges() {\n        auto dfs_order = new int[V];\n        auto lowlink = new int[V];\n        dfs_order[] = -1;\n        int c = 0;\n        void dfs(int v, int prev) {\n            dfs_order[v] = c++;\n            lowlink[v] = dfs_order[v];\n            foreach (e; G[v]) {\n                auto next = e.to;\n                if (next == prev) continue;\n                if (dfs_order[next] >= 0) { \n                    // already visited. this 'e' is backedge.\n                    lowlink[v] = min(lowlink[v], dfs_order[next]);\n                } else {\n                    dfs(next, v);\n                    lowlink[v] = min(lowlink[v], lowlink[next]);\n                }\n                e.isBridge = dfs_order[v] < lowlink[next];\n            }\n        }\n        dfs(0, -1);\n    }\n}\n\nimport core.memory;\nconst long STACK_SIZE = (long.sizeof) * (1<<27);\n__gshared void* stack;\n__gshared long org_esp;\n__gshared long esp;\nvoid main() {\n    stack = GC.malloc(STACK_SIZE);\n    esp = cast(long)(stack) + STACK_SIZE - 1L;\n    asm {\n        mov org_esp, RSP;\n        mov RSP, esp;\n    }\n\n    void solve() {\n        int N, M; scanf(\"%d %d\\n\", &N, &M);\n        auto W = stdin.readln.chomp.split(\" \").map!(to!int).array;\n        auto graph = new Graph(N);\n        foreach (i; 0 .. M) {\n            int u, v; scanf(\"%d %d\\n\", &u, &v); u--; v--;\n            graph.addEdge(u, v);\n        }\n        graph.findBridges();\n\n        auto g = graph.G;\n        auto visited = new bool[N];\n        int dfs(int v, int prev) {\n            visited[v] = true;\n            int ans = W[v];\n            int bridge_max = 0;\n            foreach (e; g[v]) {\n                if (e.to == prev) continue;\n                if (visited[e.to]) continue;\n                auto w = dfs(e.to, v);\n                if (e.isBridge) {\n                    bridge_max = max(bridge_max, w);\n                } else {\n                    ans += w;\n                }\n            }\n            return ans + bridge_max;\n        }\n        writeln(dfs(0, -1));\n    }\n    solve();\n\n    asm {\n        mov RSP, org_esp;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.container;\nimport std.conv;\nimport std.math;\nimport std.numeric;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nvoid log(A...)(A arg) {\n    stderr.writeln(arg);\n}\nint size(T)(in T s) {\n    return cast(int)s.length;\n}\n\nclass Edge {\n    int from, to;\n    bool isBridge;\n    this(int from, int to) {\n        this.from = from;\n        this.to = to;\n    }\n    override string toString() {\n        return [from, to, isBridge].to!string;\n    }\n}\nclass Graph {\n    Edge[][] G;\n    int V;\n    this(int V) {\n        this.V = V;\n        G = new Edge[][V];\n    }\n    void addEdge(int from, int to) {\n        G[from] ~= new Edge(from, to);\n        G[to] ~= new Edge(to, from);\n    }\n}\n\nconst int INF = int.max/4;\nvoid solve() {\n    int N, M; scanf(\"%d %d\\n\", &N, &M);\n    auto W = stdin.readln.chomp.split(\" \").map!(to!int).array;\n    auto graph = new Graph(N);\n    foreach (i; 0 .. M) {\n        int u, v; scanf(\"%d %d\\n\", &u, &v); u--; v--;\n        graph.addEdge(u, v);\n    }\n    auto g = graph.G;\n\n    auto visited = new bool[N];\n    Tuple!(bool, int, int) dfs(int v, int prev) {\n        visited[v] = true;\n        int ans = W[v];\n        int diff_max = 0;\n        bool can_ret = false;\n        foreach (e; g[v]) {\n            if (e.to == prev) continue;\n            if (visited[e.to]) {\n                can_ret = true;\n                continue;\n            }\n            auto r = dfs(e.to, v);\n            if (r[0]) can_ret = true;\n            ans += max(0, r[1]);\n            diff_max = max(diff_max, r[2] - max(0, r[1]));\n        }\n        return tuple( can_ret, (can_ret ? ans : -INF), ans + diff_max);\n    }\n    dfs(0, -1)[2].writeln;\n}\n\n\nvoid main() {\n    solve();\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.container;\nimport std.conv;\nimport std.math;\nimport std.numeric;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nvoid log(A...)(A arg) {\n    stderr.writeln(arg);\n}\nint size(T)(in T s) {\n    return cast(int)s.length;\n}\n\n// graph for bridge finding\nclass Edge {\n    int from, to;\n    bool isBridge;\n    this(int from, int to) {\n        this.from = from;\n        this.to = to;\n    }\n    override string toString() {\n        return [from, to, isBridge].to!string;\n    }\n}\nclass Graph {\n    Edge[][] G;\n    int V;\n    this(int V) {\n        this.V = V;\n        G = new Edge[][V];\n    }\n    void addEdge(int from, int to) {\n        G[from] ~= new Edge(from, to);\n        G[to] ~= new Edge(to, from);\n    }\n    void findBridges() {\n        auto dfs_order = new int[V];\n        auto lowlink = new int[V];\n        dfs_order[] = -1;\n        int c = 0;\n        void dfs(int v, int prev) {\n            dfs_order[v] = c++;\n            lowlink[v] = dfs_order[v];\n            foreach (e; G[v]) {\n                auto next = e.to;\n                if (next == prev) continue;\n                if (dfs_order[next] >= 0) { \n                    // already visited. this 'e' is backedge.\n                    lowlink[v] = min(lowlink[v], dfs_order[next]);\n                } else {\n                    dfs(next, v);\n                    lowlink[v] = min(lowlink[v], lowlink[next]);\n                }\n                e.isBridge = dfs_order[v] < lowlink[next];\n            }\n        }\n        dfs(0, -1);\n    }\n}\n\nvoid solve() {\n    int N, M; scanf(\"%d %d\\n\", &N, &M);\n    auto W = stdin.readln.chomp.split(\" \").map!(to!int).array;\n    auto graph = new Graph(N);\n    foreach (i; 0 .. M) {\n        int u, v; scanf(\"%d %d\\n\", &u, &v); u--; v--;\n        graph.addEdge(u, v);\n    }\n    graph.findBridges();\n    auto g = graph.G;\n    auto visited = new bool[N];\n    int dfs(int v, int prev) {\n        visited[v] = true;\n        int ans = W[v];\n        int bridge_max = 0;\n        foreach (e; g[v]) {\n            if (e.to == prev) continue;\n            if (visited[e.to]) continue;\n            auto w = dfs(e.to, v);\n            if (e.isBridge) {\n                bridge_max = max(bridge_max, w);\n            } else {\n                ans += w;\n            }\n        }\n        return ans + bridge_max;\n    }\n    writeln(dfs(0, -1));\n}\n\n\nimport core.memory;\nalias base_t = long;\nconst base_t STACK_SIZE = (base_t.sizeof) * (1<<24);\n__gshared void* stack;\n__gshared base_t org_esp;\n__gshared base_t esp;\nvoid main() {\n    GC.disable();\n    stack = GC.malloc(STACK_SIZE);\n    esp = cast(base_t)(stack) + STACK_SIZE - 1;\n    asm {\n        mov org_esp, RSP;\n        mov RSP, esp;\n    }\n\n    solve();\n\n    asm {\n        mov RSP, org_esp;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.container;\nimport std.conv;\nimport std.math;\nimport std.numeric;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nvoid log(A...)(A arg) {\n    stderr.writeln(arg);\n}\nint size(T)(in T s) {\n    return cast(int)s.length;\n}\n\n// graph for bridge finding\nclass Edge {\n    int from, to;\n    bool isBridge;\n    this(int from, int to) {\n        this.from = from;\n        this.to = to;\n    }\n    override string toString() {\n        return [from, to, isBridge].to!string;\n    }\n}\nclass Graph {\n    Edge[][] G;\n    int V;\n    this(int V) {\n        this.V = V;\n        G = new Edge[][V];\n    }\n    void addEdge(int from, int to) {\n        G[from] ~= new Edge(from, to);\n        G[to] ~= new Edge(to, from);\n    }\n    void findBridges() {\n        auto dfs_order = new int[V];\n        auto lowlink = new int[V];\n        dfs_order[] = -1;\n        int c = 0;\n        void dfs(int v, int prev) {\n            dfs_order[v] = c++;\n            lowlink[v] = dfs_order[v];\n            foreach (e; G[v]) {\n                auto next = e.to;\n                if (next == prev) continue;\n                if (dfs_order[next] >= 0) { \n                    // already visited. this 'e' is backedge.\n                    lowlink[v] = min(lowlink[v], dfs_order[next]);\n                } else {\n                    dfs(next, v);\n                    lowlink[v] = min(lowlink[v], lowlink[next]);\n                }\n                e.isBridge = dfs_order[v] < lowlink[next];\n            }\n        }\n        dfs(0, -1);\n    }\n}\n\nimport core.memory;\nconst long STACK_SIZE = (long.sizeof) * (1<<28);\n__gshared void* stack;\n__gshared long org_esp;\n__gshared long esp;\nvoid main() {\n    stack = GC.malloc(STACK_SIZE);\n    esp = cast(long)(stack) + STACK_SIZE - 1L;\n    asm {\n        mov org_esp, RSP;\n        mov RSP, esp;\n    }\n\n    void solve() {\n        int N, M; scanf(\"%d %d\\n\", &N, &M);\n        auto W = stdin.readln.chomp.split(\" \").map!(to!int).array;\n        auto graph = new Graph(N);\n        foreach (i; 0 .. M) {\n            int u, v; scanf(\"%d %d\\n\", &u, &v); u--; v--;\n            graph.addEdge(u, v);\n        }\n        graph.findBridges();\n\n        auto g = graph.G;\n        auto visited = new bool[N];\n        int dfs(int v, int prev) {\n            visited[v] = true;\n            int ans = W[v];\n            int bridge_max = 0;\n            foreach (e; g[v]) {\n                if (e.to == prev) continue;\n                if (visited[e.to]) continue;\n                auto w = dfs(e.to, v);\n                if (e.isBridge) {\n                    bridge_max = max(bridge_max, w);\n                } else {\n                    ans += w;\n                }\n            }\n            return ans + bridge_max;\n        }\n        writeln(dfs(0, -1));\n    }\n    solve();\n\n    asm {\n        mov RSP, org_esp;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.container;\nimport std.conv;\nimport std.math;\nimport std.numeric;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nvoid log(A...)(A arg) {\n    stderr.writeln(arg);\n}\nint size(T)(in T s) {\n    return cast(int)s.length;\n}\n\nclass Edge {\n    int from, to;\n    bool isBridge;\n    this(int from, int to) {\n        this.from = from;\n        this.to = to;\n    }\n    override string toString() {\n        return [from, to, isBridge].to!string;\n    }\n}\nclass Graph {\n    Edge[][] G;\n    int V;\n    this(int V) {\n        this.V = V;\n        G = new Edge[][V];\n    }\n    void addEdge(int from, int to) {\n        G[from] ~= new Edge(from, to);\n        G[to] ~= new Edge(to, from);\n    }\n}\n\nconst int INF = int.max/4;\nvoid solve() {\n    int N, M; scanf(\"%d %d\\n\", &N, &M);\n    auto W = stdin.readln.chomp.split(\" \").map!(to!int).array;\n    auto graph = new Graph(N);\n    foreach (i; 0 .. M) {\n        int u, v; scanf(\"%d %d\\n\", &u, &v); u--; v--;\n        graph.addEdge(u, v);\n    }\n    auto g = graph.G;\n\n    auto visited = new bool[N];\n    Tuple!(bool, int, int) dfs(int v, int prev) {\n        visited[v] = true;\n        int ans = W[v];\n        int diff_max = 0;\n        bool can_ret = false;\n        foreach (e; g[v]) {\n            if (e.to == prev) continue;\n            if (visited[e.to]) {\n                can_ret = true;\n                continue;\n            }\n            auto r = dfs(e.to, v);\n            if (r[0]) can_ret = true;\n            ans += max(0, r[1]);\n            diff_max = max(diff_max, r[2] - max(0, r[1]));\n        }\n        //log([v, prev, can_ret, can_ret ? ans: -INF, ans + diff_max]);\n        return tuple( can_ret, (can_ret ? ans : -INF), ans + diff_max);\n    }\n    dfs(0, -1)[2].writeln;\n}\n\n\n//import core.memory;\n//alias base_t = long;\n//const base_t STACK_SIZE = (base_t.sizeof) * (1<<24);\n//__gshared void* stack;\n//__gshared base_t org_esp;\n//__gshared base_t esp;\nvoid main() {\n    //GC.disable();\n    //stack = GC.malloc(STACK_SIZE);\n    //esp = cast(base_t)(stack) + STACK_SIZE - 1;\n    //asm {\n    //    mov org_esp, RSP;\n    //    mov RSP, esp;\n    //}\n\n    solve();\n\n    //asm {\n    //    mov RSP, org_esp;\n    //}\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.container;\nimport std.conv;\nimport std.math;\nimport std.numeric;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nvoid log(A...)(A arg) {\n    stderr.writeln(arg);\n}\nint size(T)(in T s) {\n    return cast(int)s.length;\n}\n\n// graph for bridge finding\nclass Edge {\n    int from, to;\n    bool isBridge;\n    this(int from, int to) {\n        this.from = from;\n        this.to = to;\n    }\n    override string toString() {\n        return [from, to, isBridge].to!string;\n    }\n}\nclass Graph {\n    Edge[][] G;\n    int V;\n    this(int V) {\n        this.V = V;\n        G = new Edge[][V];\n    }\n    void addEdge(int from, int to) {\n        G[from] ~= new Edge(from, to);\n        G[to] ~= new Edge(to, from);\n    }\n    void findBridges() {\n        auto dfs_order = new int[V];\n        auto lowlink = new int[V];\n        dfs_order[] = -1;\n        int c = 0;\n        Tuple!(int, int)[] bridges;\n        void dfs(int v, int prev) {\n            dfs_order[v] = c++;\n            lowlink[v] = dfs_order[v];\n            foreach (e; G[v]) {\n                auto next = e.to;\n                if (next == prev) continue;\n                if (dfs_order[next] >= 0) { \n                    // already visited. this 'e' is backedge.\n                    lowlink[v] = min(lowlink[v], dfs_order[next]);\n                } else {\n                    dfs(next, v);\n                    lowlink[v] = min(lowlink[v], lowlink[next]);\n                }\n                e.isBridge = dfs_order[v] < lowlink[next];\n            }\n        }\n        dfs(0, -1);\n    }\n}\n\nvoid main() {\n    int N, M; scanf(\"%d %d\\n\", &N, &M);\n    auto W = readln.chomp.split(\" \").map!(to!int).array;\n    auto graph = new Graph(N);\n    foreach (i; 0 .. M) {\n        int u, v; scanf(\"%d %d\\n\", &u, &v); u--; v--;\n        graph.addEdge(u, v);\n    }\n    graph.findBridges();\n\n    const int INF = 1<<28;\n    auto g = graph.G;\n    auto visited = new bool[N];\n    int dfs(int v, int prev) {\n        visited[v] = true;\n        int ans = W[v];\n        int bridge_max = 0;\n        foreach (e; g[v]) {\n            if (e.to == prev) continue;\n            if (visited[e.to]) continue;\n            auto w = dfs(e.to, v);\n            if (e.isBridge) {\n                bridge_max = max(bridge_max, w);\n            } else {\n                ans += w;\n            }\n        }\n        return ans + bridge_max;\n    }\n    writeln(dfs(0, -1));\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.container;\nimport std.conv;\nimport std.math;\nimport std.numeric;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nvoid log(A...)(A arg) {\n    stderr.writeln(arg);\n}\nint size(T)(in T s) {\n    return cast(int)s.length;\n}\n\n// graph for bridge finding\nclass Edge {\n    int from, to;\n    bool isBridge;\n    this(int from, int to) {\n        this.from = from;\n        this.to = to;\n    }\n    override string toString() {\n        return [from, to, isBridge].to!string;\n    }\n}\nclass Graph {\n    Edge[][] G;\n    int V;\n    this(int V) {\n        this.V = V;\n        G = new Edge[][V];\n    }\n    void addEdge(int from, int to) {\n        G[from] ~= new Edge(from, to);\n        G[to] ~= new Edge(to, from);\n    }\n}\n\nvoid solve() {\n    int N, M; scanf(\"%d %d\\n\", &N, &M);\n    auto W = stdin.readln.chomp.split(\" \").map!(to!int).array;\n    auto graph = new Graph(N);\n    foreach (i; 0 .. M) {\n        int u, v; scanf(\"%d %d\\n\", &u, &v); u--; v--;\n        graph.addEdge(u, v);\n    }\n    auto g = graph.G;\n    auto visited = new bool[N];\n    auto can_return = new bool[N];\n    bool dfs0(int v, int prev) {\n        visited[v] = true;\n        can_return[v] = false;\n        foreach (e; g[v]) {\n            if (e.to == prev) continue;\n            if (visited[e.to]) {\n                can_return[v] = true;\n            } else {\n                can_return[v] |= dfs0(e.to, v);\n            }\n        }\n        return can_return[v];\n    }\n    dfs0(0, -1);\n    visited[] = false;\n    int dfs(int v, int prev) {\n        visited[v] = true;\n        int ans = W[v];\n        int cannot_return_max = 0;\n        foreach (e; g[v]) {\n            if (e.to == prev) continue;\n            if (visited[e.to]) continue;\n            auto w = dfs(e.to, v);\n            if (can_return[e.to]) {\n                ans += w;\n            } else {\n                cannot_return_max = max(cannot_return_max, w);\n            }\n        }\n        //log([v, prev, ans, cannot_return_max, ans + cannot_return_max]);\n        return ans + cannot_return_max;\n    }\n    writeln(dfs(0, -1));\n}\n\n\nimport core.memory;\nalias base_t = int;\nconst base_t STACK_SIZE = (base_t.sizeof) * (1<<24);\n__gshared void* stack;\n__gshared base_t org_esp;\n__gshared base_t esp;\nvoid main() {\n    GC.disable();\n    stack = GC.malloc(STACK_SIZE);\n    esp = cast(base_t)(stack) + STACK_SIZE - 1;\n    asm {\n        mov org_esp, ESP;\n        mov ESP, esp;\n    }\n\n    solve();\n\n    asm {\n        mov ESP, org_esp;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.container;\nimport std.conv;\nimport std.math;\nimport std.numeric;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nvoid log(A...)(A arg) {\n    stderr.writeln(arg);\n}\nint size(T)(in T s) {\n    return cast(int)s.length;\n}\n\n// graph for bridge finding\nclass Edge {\n    int from, to;\n    bool isBridge;\n    this(int from, int to) {\n        this.from = from;\n        this.to = to;\n    }\n    override string toString() {\n        return [from, to, isBridge].to!string;\n    }\n}\nclass Graph {\n    Edge[][] G;\n    int V;\n    this(int V) {\n        this.V = V;\n        G = new Edge[][V];\n    }\n    void addEdge(int from, int to) {\n        G[from] ~= new Edge(from, to);\n        G[to] ~= new Edge(to, from);\n    }\n    void findBridges() {\n        auto dfs_order = new int[V];\n        auto lowlink = new int[V];\n        dfs_order[] = -1;\n        int c = 0;\n        void dfs(int v, int prev) {\n            dfs_order[v] = c++;\n            lowlink[v] = dfs_order[v];\n            foreach (e; G[v]) {\n                auto next = e.to;\n                if (next == prev) continue;\n                if (dfs_order[next] >= 0) { \n                    // already visited. this 'e' is backedge.\n                    lowlink[v] = min(lowlink[v], dfs_order[next]);\n                } else {\n                    dfs(next, v);\n                    lowlink[v] = min(lowlink[v], lowlink[next]);\n                }\n                e.isBridge = dfs_order[v] < lowlink[next];\n            }\n        }\n        dfs(0, -1);\n    }\n}\n\nimport core.memory;\nconst long STACK_SIZE = (long.sizeof) * (1L<<26);\n__gshared void* stack;\n__gshared long org_esp;\n__gshared long esp;\nvoid main() {\n    stack = GC.malloc(STACK_SIZE);\n    esp = cast(long)(stack) + STACK_SIZE - 1L;\n    asm {\n        mov org_esp, RSP;\n        mov RSP, esp;\n    }\n\n    void solve() {\n        int N, M; scanf(\"%d %d\\n\", &N, &M);\n        auto W = stdin.readln.chomp.split(\" \").map!(to!int).array;\n        auto graph = new Graph(N);\n        foreach (i; 0 .. M) {\n            int u, v; scanf(\"%d %d\\n\", &u, &v); u--; v--;\n            graph.addEdge(u, v);\n        }\n        graph.findBridges();\n\n        auto g = graph.G;\n        auto visited = new bool[N];\n        int dfs(int v, int prev) {\n            visited[v] = true;\n            int ans = W[v];\n            int bridge_max = 0;\n            foreach (e; g[v]) {\n                if (e.to == prev) continue;\n                if (visited[e.to]) continue;\n                auto w = dfs(e.to, v);\n                if (e.isBridge) {\n                    bridge_max = max(bridge_max, w);\n                } else {\n                    ans += w;\n                }\n            }\n            return ans + bridge_max;\n        }\n        writeln(dfs(0, -1));\n    }\n    solve();\n\n    asm {\n        mov RSP, org_esp;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.container;\nimport std.conv;\nimport std.math;\nimport std.numeric;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nvoid log(A...)(A arg) {\n    stderr.writeln(arg);\n}\nint size(T)(in T s) {\n    return cast(int)s.length;\n}\n\nclass Edge {\n    int from, to;\n    bool isBridge;\n    this(int from, int to) {\n        this.from = from;\n        this.to = to;\n    }\n    override string toString() {\n        return [from, to, isBridge].to!string;\n    }\n}\nclass Graph {\n    Edge[][] G;\n    int V;\n    this(int V) {\n        this.V = V;\n        G = new Edge[][V];\n    }\n    void addEdge(int from, int to) {\n        G[from] ~= new Edge(from, to);\n        G[to] ~= new Edge(to, from);\n    }\n}\n\nconst int INF = int.max/4;\nvoid solve() {\n    int N, M; scanf(\"%d %d\\n\", &N, &M);\n    auto W = stdin.readln.chomp.split(\" \").map!(to!int).array;\n    auto graph = new Graph(N);\n    foreach (i; 0 .. M) {\n        int u, v; scanf(\"%d %d\\n\", &u, &v); u--; v--;\n        graph.addEdge(u, v);\n    }\n    auto g = graph.G;\n\n    auto visited = new bool[N];\n    Tuple!(bool, int, int) dfs(int v, int prev) {\n        visited[v] = true;\n        int ans = W[v];\n        int diff_max = 0;\n        bool can_ret = false;\n        foreach (e; g[v]) {\n            if (e.to == prev) continue;\n            if (visited[e.to]) {\n                can_ret = true;\n                continue;\n            }\n            auto r = dfs(e.to, v);\n            if (r[0]) can_ret = true;\n            ans += max(0, r[1]);\n            diff_max = max(diff_max, r[2] - max(0, r[1]));\n        }\n        //log([v, prev, can_ret, can_ret ? ans: -INF, ans + diff_max]);\n        return tuple( can_ret, (can_ret ? ans : -INF), ans + diff_max);\n    }\n    dfs(0, -1)[2].writeln;\n}\n\n\nimport core.memory;\nalias base_t = long;\nconst base_t STACK_SIZE = (base_t.sizeof) * (1<<24);\n__gshared void* stack;\n__gshared base_t org_esp;\n__gshared base_t esp;\nvoid main() {\n    GC.disable();\n    stack = GC.malloc(STACK_SIZE);\n    esp = cast(base_t)(stack) + STACK_SIZE - 1;\n    asm {\n        mov org_esp, RSP;\n        mov RSP, esp;\n    }\n\n    solve();\n\n    asm {\n        mov RSP, org_esp;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.container;\nimport std.conv;\nimport std.math;\nimport std.numeric;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nvoid log(A...)(A arg) {\n    stderr.writeln(arg);\n}\nint size(T)(in T s) {\n    return cast(int)s.length;\n}\n\n// graph for bridge finding\nclass Edge {\n    int from, to;\n    bool isBridge;\n    this(int from, int to) {\n        this.from = from;\n        this.to = to;\n    }\n    override string toString() {\n        return [from, to, isBridge].to!string;\n    }\n}\nclass Graph {\n    Edge[][] G;\n    int V;\n    this(int V) {\n        this.V = V;\n        G = new Edge[][V];\n    }\n    void addEdge(int from, int to) {\n        G[from] ~= new Edge(from, to);\n        G[to] ~= new Edge(to, from);\n    }\n}\n\nvoid solve() {\n    int N, M; scanf(\"%d %d\\n\", &N, &M);\n    auto W = stdin.readln.chomp.split(\" \").map!(to!int).array;\n    auto graph = new Graph(N);\n    foreach (i; 0 .. M) {\n        int u, v; scanf(\"%d %d\\n\", &u, &v); u--; v--;\n        graph.addEdge(u, v);\n    }\n    auto g = graph.G;\n    auto visited = new bool[N];\n    auto can_return = new bool[N];\n    bool dfs0(int v, int prev) {\n        visited[v] = true;\n        can_return[v] = false;\n        foreach (e; g[v]) {\n            if (e.to == prev) continue;\n            if (visited[e.to]) {\n                can_return[v] = true;\n            } else {\n                can_return[v] |= dfs0(e.to, v);\n            }\n        }\n        return can_return[v];\n    }\n    dfs0(0, -1);\n    visited[] = false;\n    int dfs(int v, int prev) {\n        visited[v] = true;\n        int ans = W[v];\n        int cannot_return_max = 0;\n        foreach (e; g[v]) {\n            if (e.to == prev) continue;\n            if (visited[e.to]) continue;\n            auto w = dfs(e.to, v);\n            if (can_return[e.to]) {\n                ans += w;\n            } else {\n                cannot_return_max = max(cannot_return_max, w);\n            }\n        }\n        //log([v, prev, ans, cannot_return_max, ans + cannot_return_max]);\n        return ans + cannot_return_max;\n    }\n    writeln(dfs(0, -1));\n}\n\n\nimport core.memory;\nalias base_t = long;\nconst base_t STACK_SIZE = (base_t.sizeof) * (1<<24);\n__gshared void* stack;\n__gshared base_t org_esp;\n__gshared base_t esp;\nvoid main() {\n    GC.disable();\n    stack = GC.malloc(STACK_SIZE);\n    esp = cast(base_t)(stack) + STACK_SIZE - 1;\n    asm {\n        mov org_esp, RSP;\n        mov RSP, esp;\n    }\n\n    solve();\n\n    asm {\n        mov RSP, org_esp;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.container;\nimport std.conv;\nimport std.math;\nimport std.numeric;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nvoid log(A...)(A arg) {\n    stderr.writeln(arg);\n}\nint size(T)(in T s) {\n    return cast(int)s.length;\n}\n\n// graph for bridge finding\nclass Edge {\n    int from, to;\n    bool isBridge;\n    this(int from, int to) {\n        this.from = from;\n        this.to = to;\n    }\n    override string toString() {\n        return [from, to, isBridge].to!string;\n    }\n}\nclass Graph {\n    Edge[][] G;\n    int V;\n    this(int V) {\n        this.V = V;\n        G = new Edge[][V];\n    }\n    void addEdge(int from, int to) {\n        G[from] ~= new Edge(from, to);\n        G[to] ~= new Edge(to, from);\n    }\n    void findBridges() {\n        auto dfs_order = new int[V];\n        auto lowlink = new int[V];\n        dfs_order[] = -1;\n        int c = 0;\n        void dfs(int v, int prev) {\n            dfs_order[v] = c++;\n            lowlink[v] = dfs_order[v];\n            foreach (e; G[v]) {\n                auto next = e.to;\n                if (next == prev) continue;\n                if (dfs_order[next] >= 0) { \n                    // already visited. this 'e' is backedge.\n                    lowlink[v] = min(lowlink[v], dfs_order[next]);\n                } else {\n                    dfs(next, v);\n                    lowlink[v] = min(lowlink[v], lowlink[next]);\n                }\n                e.isBridge = dfs_order[v] < lowlink[next];\n            }\n        }\n        dfs(0, -1);\n    }\n}\n\nimport core.memory;\nconst long STACK_SIZE = (long.sizeof) * (1L<<26);\n__gshared void* stack;\n__gshared long org_esp;\n__gshared long esp;\nvoid main() {\n    stack = GC.malloc(STACK_SIZE);\n    esp = cast(long)(stack) + STACK_SIZE - 1L;\n    asm {\n        mov org_esp, RSP;\n        mov RSP, esp;\n    }\n\n    void solve() {\n        int N, M; scanf(\"%d %d\\n\", &N, &M);\n        auto W = stdin.readln.chomp.split(\" \").map!(to!int).array;\n        auto graph = new Graph(N);\n        foreach (i; 0 .. M) {\n            int u, v; scanf(\"%d %d\\n\", &u, &v); u--; v--;\n            graph.addEdge(u, v);\n        }\n        graph.findBridges();\n\n        auto g = graph.G;\n        auto visited = new bool[N];\n        int dfs(int v, int prev) {\n            visited[v] = true;\n            int ans = W[v];\n            int bridge_max = 0;\n            foreach (e; g[v]) {\n                if (e.to == prev) continue;\n                if (visited[e.to]) continue;\n                auto w = dfs(e.to, v);\n                if (e.isBridge) {\n                    bridge_max = max(bridge_max, w);\n                } else {\n                    ans += w;\n                }\n            }\n            return ans + bridge_max;\n        }\n        writeln(dfs(0, -1));\n    }\n    solve();\n\n    asm {\n        mov RSP, org_esp;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.container;\nimport std.conv;\nimport std.math;\nimport std.numeric;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nvoid log(A...)(A arg) {\n    stderr.writeln(arg);\n}\nint size(T)(in T s) {\n    return cast(int)s.length;\n}\n\n// graph for bridge finding\nclass Edge {\n    int from, to;\n    bool isBridge;\n    this(int from, int to) {\n        this.from = from;\n        this.to = to;\n    }\n    override string toString() {\n        return [from, to, isBridge].to!string;\n    }\n}\nclass Graph {\n    Edge[][] G;\n    int V;\n    this(int V) {\n        this.V = V;\n        G = new Edge[][V];\n    }\n    void addEdge(int from, int to) {\n        G[from] ~= new Edge(from, to);\n        G[to] ~= new Edge(to, from);\n    }\n    void findBridges() {\n        auto dfs_order = new int[V];\n        auto lowlink = new int[V];\n        dfs_order[] = -1;\n        int c = 0;\n        void dfs(int v, int prev) {\n            dfs_order[v] = c++;\n            lowlink[v] = dfs_order[v];\n            foreach (e; G[v]) {\n                auto next = e.to;\n                if (next == prev) continue;\n                if (dfs_order[next] >= 0) { \n                    // already visited. this 'e' is backedge.\n                    lowlink[v] = min(lowlink[v], dfs_order[next]);\n                } else {\n                    dfs(next, v);\n                    lowlink[v] = min(lowlink[v], lowlink[next]);\n                }\n                e.isBridge = dfs_order[v] < lowlink[next];\n            }\n        }\n        dfs(0, -1);\n    }\n}\n\nimport core.memory;\nconst int STACK_SIZE = (int.sizeof) * (1<<28);\n__gshared void* stack;\n__gshared int org_esp;\n__gshared int esp;\nvoid main() {\n    stack = GC.malloc(STACK_SIZE);\n    esp = cast(int)(stack) + STACK_SIZE - int.sizeof;\n    asm {\n        mov org_esp, ESP;\n        mov ESP, esp;\n    }\n\n    void solve() {\n        int N, M; scanf(\"%d %d\\n\", &N, &M);\n        auto W = stdin.readln.chomp.split(\" \").map!(to!int).array;\n        auto graph = new Graph(N);\n        foreach (i; 0 .. M) {\n            int u, v; scanf(\"%d %d\\n\", &u, &v); u--; v--;\n            graph.addEdge(u, v);\n        }\n        graph.findBridges();\n\n        auto g = graph.G;\n        auto visited = new bool[N];\n        int dfs(int v, int prev) {\n            visited[v] = true;\n            int ans = W[v];\n            int bridge_max = 0;\n            foreach (e; g[v]) {\n                if (e.to == prev) continue;\n                if (visited[e.to]) continue;\n                auto w = dfs(e.to, v);\n                if (e.isBridge) {\n                    bridge_max = max(bridge_max, w);\n                } else {\n                    ans += w;\n                }\n            }\n            return ans + bridge_max;\n        }\n        writeln(dfs(0, -1));\n    }\n    solve();\n\n    asm {\n        mov ESP, org_esp;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.container;\nimport std.conv;\nimport std.math;\nimport std.numeric;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nvoid log(A...)(A arg) {\n    stderr.writeln(arg);\n}\nint size(T)(in T s) {\n    return cast(int)s.length;\n}\n\n// graph for bridge finding\nclass Edge {\n    int from, to;\n    bool isBridge;\n    this(int from, int to) {\n        this.from = from;\n        this.to = to;\n    }\n    override string toString() {\n        return [from, to, isBridge].to!string;\n    }\n}\nclass Graph {\n    Edge[][] G;\n    int V;\n    this(int V) {\n        this.V = V;\n        G = new Edge[][V];\n    }\n    void addEdge(int from, int to) {\n        G[from] ~= new Edge(from, to);\n        G[to] ~= new Edge(to, from);\n    }\n    void findBridges() {\n        auto dfs_order = new int[V];\n        auto lowlink = new int[V];\n        dfs_order[] = -1;\n        int c = 0;\n        void dfs(int v, int prev) {\n            dfs_order[v] = c++;\n            lowlink[v] = dfs_order[v];\n            foreach (e; G[v]) {\n                auto next = e.to;\n                if (next == prev) continue;\n                if (dfs_order[next] >= 0) { \n                    // already visited. this 'e' is backedge.\n                    lowlink[v] = min(lowlink[v], dfs_order[next]);\n                } else {\n                    dfs(next, v);\n                    lowlink[v] = min(lowlink[v], lowlink[next]);\n                }\n                e.isBridge = dfs_order[v] < lowlink[next];\n            }\n        }\n        dfs(0, -1);\n    }\n}\n\nvoid solve() {\n    int N, M; scanf(\"%d %d\\n\", &N, &M);\n    auto W = stdin.readln.chomp.split(\" \").map!(to!int).array;\n    auto graph = new Graph(N);\n    foreach (i; 0 .. M) {\n        int u, v; scanf(\"%d %d\\n\", &u, &v); u--; v--;\n        graph.addEdge(u, v);\n    }\n    graph.findBridges();\n    auto g = graph.G;\n    auto visited = new bool[N];\n    int dfs(int v, int prev) {\n        visited[v] = true;\n        int ans = W[v];\n        int bridge_max = 0;\n        foreach (e; g[v]) {\n            if (e.to == prev) continue;\n            if (visited[e.to]) continue;\n            auto w = dfs(e.to, v);\n            if (e.isBridge) {\n                bridge_max = max(bridge_max, w);\n            } else {\n                ans += w;\n            }\n        }\n        return ans + bridge_max;\n    }\n    writeln(dfs(0, -1));\n}\n\n\nimport core.memory;\nalias base_t = long;\nconst base_t STACK_SIZE = (base_t.sizeof) * (1<<24);\n__gshared void* stack;\n__gshared base_t org_esp;\n__gshared base_t esp;\nvoid main() {\n    GC.disable();\n    stack = GC.malloc(STACK_SIZE);\n    esp = cast(base_t)(stack) + STACK_SIZE - 1;\n    asm {\n        mov org_esp, RSP;\n        mov RSP, esp;\n    }\n\n    solve();\n\n    asm {\n        mov RSP, org_esp;\n    }\n}"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(10**6)\ndef solve():\n    readline = sys.stdin.readline\n    write = sys.stdout.write\n    N, M = map(int, readline().split())\n    *W, = map(int, readline().split())\n    G = [[] for i in range(N)]\n    for i in range(M):\n        u, v = map(int, readline().split())\n        G[u-1].append(v-1)\n        G[v-1].append(u-1)\n    U = [0]*N\n    L = [0]*N\n    D = [0]*N\n    R = [0]*N\n\n    U[0] = 1\n    stk = [0]\n    it = [0]*N\n    while stk:\n        v = stk[-1]\n        p = stk[-2] if len(stk) > 1 else -1\n        if it[v] == 0:\n            U[v] = 1\n        else:\n            w = G[v][it[v]-1]\n            D[v] = max(D[v], D[w])\n            if L[w]:\n                L[v] = 1\n\n        while it[v] < len(G[v]):\n            w = G[v][it[v]]; it[v] += 1\n            if U[w]:\n                if w != p:\n                    L[v] = 1\n                continue\n            U[w] = 1\n            stk.append(w)\n            break\n        else:\n            D[v] = D[v] + W[v]\n            stk.pop()\n\n    ans = su = 0\n    for i in range(N):\n        if L[i]:\n            ans += W[i]\n        else:\n            su = max(su, D[i])\n    write(\"%d\\n\" % (ans + su))\nsolve()\n"
  },
  {
    "language": "Python",
    "code": "# 前の提出は1が葉のときまずかったので再提出。\n\nimport sys\ninput = sys.stdin.readline\n\nn,m=map(int,input().split())\nW=[0]+list(map(int,input().split()))\nE=[tuple(map(int,input().split())) for i in range(m)]\nS=1\n\nELIST=[[] for i in range(n+1)]\nEW=[0]*(n+1)\n\nfor x,y in E:\n    ELIST[x].append(y)\n    ELIST[y].append(x)\n\n    EW[x]+=1\n    EW[y]+=1\n\n\nfrom collections import deque\nQ=deque()\nUSED=[0]*(n+1)\n\nfor i in range(1,n+1):\n    if EW[i]==1 and i!=S:\n        USED[i]=1\n        Q.append(i)\n\nEW[S]+=1<<50\nUSED[S]=1\n\nwhile Q:\n    x=Q.pop()\n    EW[x]-=1\n\n    for to in ELIST[x]:\n        if USED[to]==1:\n            continue\n        EW[to]-=1\n\n        if EW[to]==1 and USED[to]==0:\n            Q.append(to)\n            USED[to]=1\n\n#print(EW)\nLOOP=[]\n\nANS=0\nfor i in range(1,n+1):\n    if EW[i]!=0:\n        ANS+=W[i]\n        LOOP.append(i)\n\nSCORE=[0]*(n+1)\nUSED=[0]*(n+1)\n\nfor l in LOOP:\n    SCORE[l]=ANS\n    USED[l]=1\n\nQ=deque(LOOP)\n\nwhile Q:\n    x=Q.pop()\n\n    for to in ELIST[x]:\n        if USED[to]==1:\n            continue\n\n        SCORE[to]=W[to]+SCORE[x]\n        Q.append(to)\n        USED[to]=1\n\nprint(max(SCORE))\n\n"
  },
  {
    "language": "Python",
    "code": "def find(x):\n  if par[x] == x:\n    return x\n  else:\n    par[x] = find(par[x])\n    return par[x]\n\ndef union(x, y):\n  par_x = find(x)\n  par_y = find(y)\n  if rank[par_x] < rank[par_y]:\n    par[par_x] = par_y\n    w[par_y]+=w[par_x]\n  else:\n    par[par_y] = par_x\n    w[par_x]+=w[par_y]\n    if rank[par_x] == rank[par_y]:\n      rank[par_x] += 1\n\ndef same(x, y):\n  return find(x)==find(y)\n\ndef dfs(cur, prev):\n  if visited[cur] or cur!=find(cur):\n    while len(path)>0:\n      union(0, path.pop())\n    return\n  visited[cur] = 1\n  path.append(cur)\n  for to in graph[cur]:\n    if to==prev:\n      continue\n    dfs(to, cur)\n  visited[cur] = 0\n  if len(path)>0 and path[-1]==cur:\n    path.pop()\n\ndef dfs2(cur):\n  visited[cur] = 1\n  ret = 0\n  for i in range(len(graph2[cur])):\n    for ele in graph[graph2[cur][i]]:\n      if visited[find(ele)] == 0:\n        ret = max(ret, dfs2(find(ele)))\n  return ret+w[find(cur)]\n\nimport sys\nfrom collections import defaultdict\nsys.setrecursionlimit(1000000)\nn, m = map(int, input().split())\nw = [0]\nw.extend(list(map(int, input().split())))\ngraph = defaultdict(list)\nfor _ in range(m):\n  u, v = map(int, input().split())\n  graph[u].append(v)\n  graph[v].append(u)\n\npath = []\ngraph2 = [[] for _ in range(n+1)]\nvisited = [0]*(n+1)\npar = [i for i in range(n+1)]\nrank = [0]*(n+1)\n\ndfs(1, -1)\nfor i in range(1, n+1):\n  graph2[find(i)].append(i)\n\nprint(dfs2(find(1)))\n"
  },
  {
    "language": "Rust",
    "code": "use std::io::Read;\n\nfn run() {\n    let mut s = String::new();\n    std::io::stdin().read_to_string(&mut s).unwrap();\n    let mut it = s.trim().split_whitespace();\n    let n: usize = it.next().unwrap().parse().unwrap();\n    let m: usize = it.next().unwrap().parse().unwrap();\n    let w: Vec<u32> = (0..n).map(|_| it.next().unwrap().parse().unwrap()).collect();\n    let mut g = vec![vec![]; n];\n    let mut d = vec![0; n];\n    for _ in 0..m {\n        let a = it.next().unwrap().parse::<usize>().unwrap() - 1;\n        let b = it.next().unwrap().parse::<usize>().unwrap() - 1;\n        g[a].push(b);\n        g[b].push(a);\n        d[a] += 1;\n        d[b] += 1;\n    }\n    d[0] = 1_000_000;\n    let mut dp = vec![0; n];\n    let mut q = std::collections::VecDeque::new();\n    for i in 0..n {\n        if d[i] == 1 {\n            d[i] = 1_000_000;\n            q.push_back(i);\n        }\n    }\n    let mut used = vec![false; n];\n    while let Some(v) = q.pop_front() {\n        used[v] = true;\n        for &u in &g[v] {\n            d[u] -= 1;\n            dp[u] = std::cmp::max(dp[u], dp[v] + w[v]);\n            if d[u] == 1 {\n                d[u] = 1_000_000;\n                q.push_back(u);\n            }\n        }\n    }\n    let mut ans = 0;\n    for i in 0..n {\n        if !used[i] {\n            ans += w[i];\n        }\n    }\n    ans += *dp.iter().max().unwrap();\n    println!(\"{}\", ans);\n}\n\nfn main() {\n    run();\n}\n\n"
  }
]