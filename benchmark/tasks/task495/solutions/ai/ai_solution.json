[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_N 100005\n\nint graph[MAX_N][MAX_N];\nint graph_size[MAX_N];\nint values[MAX_N];\nint visited[MAX_N];\nint max_score = 0;\n\nvoid dfs(int vertex, int prev_vertex, int current_score, int depth) {\n    if (current_score > max_score) {\n        max_score = current_score;\n    }\n\n    visited[vertex] = 1;\n\n    for (int i = 0; i < graph_size[vertex]; i++) {\n        int next_vertex = graph[vertex][i];\n        \n        if (next_vertex != prev_vertex) {\n            int new_score = current_score;\n            \n            if (!visited[next_vertex]) {\n                new_score += values[next_vertex];\n            }\n            \n            dfs(next_vertex, vertex, new_score, depth + 1);\n        }\n    }\n\n    visited[vertex] = 0;\n}\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n\n    for (int i = 1; i <= N; i++) {\n        scanf(\"%d\", &values[i]);\n    }\n\n    for (int i = 0; i < M; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        graph[u][graph_size[u]++] = v;\n        graph[v][graph_size[v]++] = u;\n    }\n\n    max_score = values[1];\n    dfs(1, 0, values[1], 0);\n\n    printf(\"%d\\n\", max_score);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:53:55"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_N 100\n\ntypedef struct {\n    int to;\n    int next;\n} Edge;\n\nEdge edges[2 * MAX_N * MAX_N];\nint head[MAX_N + 1];\nint w[MAX_N + 1];\nint visited[MAX_N + 1];\nint edge_count = 0;\nint max_score = 0;\n\nvoid add_edge(int u, int v) {\n    edges[edge_count].to = v;\n    edges[edge_count].next = head[u];\n    head[u] = edge_count++;\n}\n\nvoid dfs(int u, int prev_edge, int current_score) {\n    if (!visited[u]) {\n        current_score += w[u];\n        visited[u] = 1;\n    }\n\n    if (current_score > max_score) {\n        max_score = current_score;\n    }\n\n    for (int i = head[u]; i != -1; i = edges[i].next) {\n        if (i == (prev_edge ^ 1)) continue;\n        int v = edges[i].to;\n        dfs(v, i, current_score);\n    }\n\n    if (!visited[u]) {\n        visited[u] = 0;\n    }\n}\n\nint main() {\n    int N, M;\n    scanf(\"%d %d\", &N, &M);\n\n    for (int i = 1; i <= N; ++i) {\n        scanf(\"%d\", &w[i]);\n    }\n\n    memset(head, -1, sizeof(head));\n    for (int i = 0; i < M; ++i) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        add_edge(u, v);\n        add_edge(v, u);\n    }\n\n    memset(visited, 0, sizeof(visited));\n    dfs(1, -1, 0);\n\n    printf(\"%d\\n\", max_score);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:54:19"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nusing namespace std;\n\nint dfs(int current, int parent, vector<vector<int>>& graph, vector<int>& w, unordered_map<int, unordered_map<int, int>>& memo) {\n    if (memo[current].count(parent)) {\n        return memo[current][parent];\n    }\n    int max_score = w[current - 1];\n    for (int neighbor : graph[current]) {\n        if (neighbor != parent) {\n            max_score = max(max_score, w[current - 1] + dfs(neighbor, current, graph, w, memo));\n        }\n    }\n    memo[current][parent] = max_score;\n    return max_score;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    vector<int> w(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> w[i];\n    }\n    vector<vector<int>> graph(N + 1);\n    for (int i = 0; i < N - 1; ++i) {\n        int u, v;\n        cin >> u >> v;\n        graph[u].push_back(v);\n        graph[v].push_back(u);\n    }\n    unordered_map<int, unordered_map<int, int>> memo;\n    cout << dfs(1, -1, graph, w, memo) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 21:54:35"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Solution {\n    private int maxScore = 0;\n    private List<List<Integer>> graph;\n    private int[] values;\n    private boolean[] visited;\n\n    public int maxScore(int[][] edges, int[] values) {\n        int n = values.length;\n        this.graph = new ArrayList<>();\n        this.values = values;\n        this.visited = new boolean[n];\n        \n        for (int i = 0; i < n; i++) {\n            graph.add(new ArrayList<>());\n        }\n        \n        for (int[] edge : edges) {\n            int u = edge[0] - 1;\n            int v = edge[1] - 1;\n            graph.get(u).add(v);\n            graph.get(v).add(u);\n        }\n        \n        dfs(0, -1, -1, 0);\n        return maxScore;\n    }\n    \n    private void dfs(int node, int parent, int forbiddenEdge, int currentScore) {\n        if (visited[node]) {\n            return;\n        }\n        \n        visited[node] = true;\n        currentScore += values[node];\n        maxScore = Math.max(maxScore, currentScore);\n        \n        for (int neighbor : graph.get(node)) {\n            if (neighbor == parent || neighbor == forbiddenEdge) {\n                continue;\n            }\n            dfs(neighbor, node, parent, currentScore);\n        }\n        \n        visited[node] = false;\n    }\n}",
    "timestamp": "2025-08-05 21:54:52"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class MaxScoreGraph {\n    public static int findMaxScore(int N, int[] values, List<List<Integer>> graph) {\n        int[][] dp = new int[N + 1][N + 1];\n        boolean[][] visited = new boolean[N + 1][N + 1];\n        \n        return dfs(1, 0, N, values, graph, dp, visited);\n    }\n    \n    private static int dfs(int current, int prev, int N, int[] values, \n                            List<List<Integer>> graph, int[][] dp, boolean[][] visited) {\n        if (current < 1 || current > N) \n            return 0;\n        \n        if (dp[current][prev] != 0)\n            return dp[current][prev];\n        \n        int maxScore = 0;\n        int currentScore = visited[current][prev] ? 0 : values[current - 1];\n        visited[current][prev] = true;\n        \n        for (int neighbor : graph.get(current)) {\n            if (neighbor != prev) {\n                maxScore = Math.max(maxScore, \n                    currentScore + dfs(neighbor, current, N, values, graph, dp, visited));\n            }\n        }\n        \n        dp[current][prev] = maxScore;\n        return maxScore;\n    }\n    \n    public static void main(String[] args) {\n        int N = 5;\n        int[] values = {3, 1, 4, 2, 5};\n        List<List<Integer>> graph = new ArrayList<>();\n        \n        for (int i = 0; i <= N; i++) {\n            graph.add(new ArrayList<>());\n        }\n        \n        // Add edges\n        graph.get(1).add(2);\n        graph.get(2).add(1);\n        graph.get(1).add(3);\n        graph.get(3).add(1);\n        graph.get(2).add(4);\n        graph.get(4).add(2);\n        graph.get(3).add(5);\n        graph.get(5).add(3);\n        \n        System.out.println(findMaxScore(N, values, graph));\n    }\n}",
    "timestamp": "2025-08-05 21:54:59"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int maxScore(int N, vector<int>& values, vector<vector<int>>& edges) {\n        // Create adjacency list representation of graph\n        vector<vector<int>> graph(N + 1);\n        for (const auto& edge : edges) {\n            graph[edge[0]].push_back(edge[1]);\n            graph[edge[1]].push_back(edge[0]);\n        }\n\n        // DP state: dp[node][prev] is max score ending at node \n        // with previous node as prev\n        vector<vector<int>> dp(N + 1, vector<int>(N + 1, 0));\n        vector<bool> visited(N + 1, false);\n\n        // DFS with memoization to explore paths\n        function<int(int, int)> dfs = [&](int node, int prev) {\n            // If already computed, return memoized result\n            if (dp[node][prev] != 0) return dp[node][prev];\n\n            int maxScore = 0;\n            visited[node] = true;\n\n            // Try moving to each neighbor except the previous node\n            for (int neighbor : graph[node]) {\n                if (neighbor != prev) {\n                    int currentScore = (visited[node] ? 0 : values[node-1]);\n                    int nextScore = dfs(neighbor, node);\n                    maxScore = max(maxScore, currentScore + nextScore);\n                }\n            }\n\n            visited[node] = false;\n            return dp[node][prev] = maxScore;\n        };\n\n        // Start DFS from node 1 with no previous node\n        return dfs(1, 0);\n    }\n};\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n\n    vector<int> values(N);\n    for (int i = 0; i < N; i++) {\n        cin >> values[i];\n    }\n\n    vector<vector<int>> edges(M, vector<int>(2));\n    for (int i = 0; i < M; i++) {\n        cin >> edges[i][0] >> edges[i][1];\n    }\n\n    Solution solution;\n    cout << solution.maxScore(N, values, edges) << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:55:08"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict\n\ndef dfs(graph, values, visited, current, current_score):\n    max_score = current_score\n    for neighbor in graph[current]:\n        if not visited[current][neighbor]:\n            visited[current][neighbor] = True\n            visited[neighbor][current] = True\n            max_score = max(max_score, dfs(graph, values, visited, neighbor, current_score + values[neighbor]))\n            visited[current][neighbor] = False\n            visited[neighbor][current] = False\n    return max_score\n\ndef find_max_score(N, edges, values):\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    visited = {i: defaultdict(bool) for i in range(1, N + 1)}\n    return dfs(graph, values, visited, 1, values[1])\n\n# Example of usage:\n# N = number of vertices\n# edges = list of tuples [(u1, v1), (u2, v2), ...] representing the edges\n# values = dictionary {1: w1, 2: w2, ..., N: wN} representing the values at each vertex \n\nN = 5\nedges = [(1, 2), (1, 3), (2, 4), (3, 5)]\nvalues = {1: 10, 2: 20, 3: 30, 4: 40, 5: 50}\n\nmax_score = find_max_score(N, edges, values)\nprint(max_score)",
    "timestamp": "2025-08-13 08:02:58"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class GraphMaxScore {\n\n    static class Graph {\n        int V;\n        List<List<Integer>> adj;\n        int[] values;\n\n        Graph(int V, int[] values) {\n            this.V = V;\n            this.values = values;\n            adj = new ArrayList<>(V + 1);\n            for (int i = 0; i <= V; i++) {\n                adj.add(new ArrayList<>());\n            }\n        }\n\n        void addEdge(int u, int v) {\n            adj.get(u).add(v);\n            adj.get(v).add(u);\n        }\n    }\n\n    public static int findMaxScore(int V, int[] values, List<int[]> edges) {\n        Graph graph = new Graph(V, values);\n        for (int[] edge : edges) {\n            graph.addEdge(edge[0], edge[1]);\n        }\n        return dfs(graph, new boolean[V + 1], 1, -1);\n    }\n\n    private static int dfs(Graph graph, boolean[] visited, int node, int parent) {\n        visited[node] = true;\n        int score = graph.values[node - 1];\n        int maxAdditionalScore = 0;\n\n        for (int neighbor : graph.adj.get(node)) {\n            if (neighbor != parent) {\n                if (!visited[neighbor]) {\n                    int subScore = dfs(graph, visited, neighbor, node);\n                    maxAdditionalScore = Math.max(maxAdditionalScore, subScore);\n                }\n            }\n        }\n\n        visited[node] = false;\n        return score + maxAdditionalScore;\n    }\n\n    public static void main(String[] args) {\n        int[] values = {3, 2, 1, 5, 4};\n        List<int[]> edges = Arrays.asList(\n            new int[]{1, 2},\n            new int[]{1, 3},\n            new int[]{2, 4},\n            new int[]{3, 5}\n        );\n\n        System.out.println(findMaxScore(5, values, edges)); // Output: 15\n    }\n}",
    "timestamp": "2025-08-13 08:03:05"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAXN 1000\n\ntypedef struct {\n    int vertex;\n    int weight;\n} Edge;\n\nint N; // Number of vertices\nint visited[MAXN + 1];\nint vertexValue[MAXN + 1];\nint edgeCount[MAXN + 1];\nEdge edges[MAXN + 1][MAXN]; // Adjacency list representation\n\nint dfs(int vertex, int prev) {\n    int maxScore = vertexValue[vertex];\n    visited[vertex] = 1;\n    \n    for (int i = 0; i < edgeCount[vertex]; i++) {\n        int nextVertex = edges[vertex][i].vertex;\n        if (nextVertex != prev && !visited[nextVertex]) {\n            int score = dfs(nextVertex, vertex);\n            if (score + vertexValue[vertex] > maxScore) {\n                maxScore = score + vertexValue[vertex];\n            }\n        }\n    }\n    \n    visited[vertex] = 0;\n    return maxScore;\n}\n\nint main() {\n    int M; // Number of edges\n\n    scanf(\"%d %d\", &N, &M);\n    for (int i = 1; i <= N; i++) {\n        scanf(\"%d\", &vertexValue[i]);\n    }\n\n    for (int i = 0; i < M; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        edges[u][edgeCount[u]].vertex = v;\n        edges[v][edgeCount[v]].vertex = u;\n        edgeCount[u]++;\n        edgeCount[v]++;\n    }\n\n    int maxScore = dfs(1, -1);\n\n    printf(\"%d\\n\", maxScore);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 08:03:08"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def max_score_path(N, edges, values):\n    graph = [[] for _ in range(N+1)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    def dfs(node, parent, visited):\n        if node in visited:\n            return 0\n        \n        visited.add(node)\n        max_total = values[node-1]\n        \n        for neighbor in graph[node]:\n            if neighbor != parent:\n                max_total = max(max_total, values[node-1] + dfs(neighbor, node, visited.copy()))\n        \n        return max_total\n    \n    return dfs(1, 0, set())",
    "timestamp": "2025-08-13 08:03:15"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef solve():\n    input = sys.stdin.read().split()\n    ptr = 0\n    N = int(input[ptr])\n    ptr += 1\n    w = list(map(int, input[ptr:ptr+N]))\n    ptr += N\n    adj = [[] for _ in range(N+1)]\n    for _ in range(N-1):\n        u, v = map(int, input[ptr:ptr+2])\n        ptr += 2\n        adj[u].append(v)\n        adj[v].append(u)\n    \n    max_score = 0\n    # Each state is (current_node, parent_node, visited_mask)\n    # Since N can be up to 20, we can use a bitmask\n    visited_mask_max = 1 << N\n    # Initialize DP table: dp[node][parent][mask] = max_score\n    # To optimize space, we can use BFS and track the best score for each state\n    # Using a dictionary to keep track of the best score for each state\n    dp = {}\n    initial_mask = 1 << 0  # node 1 is 0-th bit (assuming nodes are 1-based)\n    queue = deque()\n    queue.append((1, 0, initial_mask))\n    dp[(1, 0, initial_mask)] = w[0]  # w is 0-based for the nodes\n    \n    while queue:\n        current, parent, mask = queue.popleft()\n        current_score = dp[(current, parent, mask)]\n        max_score = max(max_score, current_score)\n        for neighbor in adj[current]:\n            if neighbor == parent:\n                continue\n            new_mask = mask\n            node_bit = neighbor - 1\n            if not (mask & (1 << node_bit)):\n                new_mask |= (1 << node_bit)\n                added_score = w[node_bit]\n            else:\n                added_score = 0\n            new_score = current_score + added_score\n            state = (neighbor, current, new_mask)\n            if state not in dp or new_score > dp[state]:\n                dp[state] = new_score\n                queue.append(state)\n    \n    print(max_score)\n\nsolve()",
    "timestamp": "2025-08-13 08:03:30"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <unordered_set>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int maxScore(int N, vector<int>& values, vector<vector<int>>& edges) {\n        // Create a graph representation using adjacency list\n        unordered_map<int, vector<int>> graph;\n        for (const auto& edge : edges) {\n            graph[edge[0]].push_back(edge[1]);\n            graph[edge[1]].push_back(edge[0]);\n        }\n        \n        // Stack holds: vertex, score, visited nodes\n        stack<pair<int, pair<int, unordered_set<int>>>> dfsStack;\n        dfsStack.push({1, {values[0], {1}}});  // start from vertex 1\n        \n        int maxScore = values[0];\n        \n        while (!dfsStack.empty()) {\n            auto [currentVertex, scoreSet] = dfsStack.top();\n            auto [currentScore, visited] = scoreSet;\n            dfsStack.pop();\n\n            maxScore = max(maxScore, currentScore);\n        \n            for (int neighbor : graph[currentVertex]) {\n                if (visited.find(neighbor) == visited.end()) {\n                    unordered_set<int> newVisited = visited;\n                    newVisited.insert(neighbor);\n                    dfsStack.push({neighbor, {currentScore + values[neighbor - 1], newVisited}});\n                }\n            }\n        }\n        \n        return maxScore;\n    }\n};\n\nint main() {\n    int N = 5;\n    vector<int> values = {1, 2, 3, 4, 5};  // values at each vertex 1 to N\n    vector<vector<int>> edges = {\n        {1, 2},\n        {2, 3},\n        {2, 4},\n        {3, 5},\n        {4, 5}\n    };\n\n    Solution solution;\n    cout << solution.maxScore(N, values, edges) << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 11:43:03"
  }
]