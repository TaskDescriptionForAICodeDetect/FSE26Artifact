[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Node {\n    char type;\n    int left_length, right_length;\n    struct Node *left, *right;\n    int weight;\n} Node;\n\nNode* build_mobile() {\n    char input[10];\n    scanf(\"%s\", input);\n    Node* node = (Node*)malloc(sizeof(Node));\n    if (input[0] == 'W') {\n        node->type = 'W';\n        node->weight = atoi(input + 1);\n        node->left = node->right = NULL;\n    } else {\n        node->type = 'R';\n        node->left_length = atoi(input);\n        scanf(\"%d\", &(node->right_length));\n        node->left = build_mobile();\n        node->right = build_mobile();\n    }\n    return node;\n}\n\nlong long gcd(long long a, long long b) {\n    while (b) {\n        long long temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\nlong long lcm(long long a, long long b) {\n    return a / gcd(a, b) * b;\n}\n\nlong long balance_mobile(Node* node, long long* total_weight) {\n    if (node->type == 'W') {\n        *total_weight = node->weight;\n        return 1;\n    } else {\n        long long left_weight, right_weight;\n        long long left_balance = balance_mobile(node->left, &left_weight);\n        long long right_balance = balance_mobile(node->right, &right_weight);\n        \n        long long left_ratio = node->left_length * right_balance;\n        long long right_ratio = node->right_length * left_balance;\n        \n        long long common = lcm(left_ratio, right_ratio);\n        long long left_total = common / left_ratio * left_weight;\n        long long right_total = common / right_ratio * right_weight;\n        \n        *total_weight = left_total + right_total;\n        return common;\n    }\n}\n\nvoid free_mobile(Node* node) {\n    if (node->type == 'R') {\n        free_mobile(node->left);\n        free_mobile(node->right);\n    }\n    free(node);\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    while (N--) {\n        Node* root = build_mobile();\n        long long total_weight;\n        balance_mobile(root, &total_weight);\n        printf(\"%lld\\n\", total_weight);\n        free_mobile(root);\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 18:47:02"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Mobile {\n    static class Node {\n        int weight;\n        int leftLength;\n        int rightLength;\n        Node left;\n        Node right;\n\n        Node(int weight, int leftLength, int rightLength) {\n            this.weight = weight;\n            this.leftLength = leftLength;\n            this.rightLength = rightLength;\n            this.left = null;\n            this.right = null;\n        }\n    }\n\n    static int calculateTotalWeight(Node node) {\n        if (node == null) return 0;\n        if (node.left == null && node.right == null) return node.weight;\n\n        int leftWeight = calculateTotalWeight(node.left);\n        int rightWeight = calculateTotalWeight(node.right);\n\n        if (node.leftLength * leftWeight != node.rightLength * rightWeight) {\n            return Integer.MAX_VALUE;\n        }\n\n        return node.weight + leftWeight + rightWeight;\n    }\n\n    static int minimumWeight(Node root) {\n        int minWeight = calculateTotalWeight(root);\n        return minWeight == Integer.MAX_VALUE ? -1 : minWeight;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int testCases = scanner.nextInt();\n\n        for (int t = 0; t < testCases; t++) {\n            int n = scanner.nextInt();\n            Map<Integer, Node> nodes = new HashMap<>();\n\n            for (int i = 0; i < n; i++) {\n                int id = scanner.nextInt();\n                int weight = scanner.nextInt();\n                int leftLength = scanner.nextInt();\n                int rightLength = scanner.nextInt();\n                nodes.put(id, new Node(weight, leftLength, rightLength));\n            }\n\n            for (int i = 0; i < n; i++) {\n                int id = scanner.nextInt();\n                int leftId = scanner.nextInt();\n                int rightId = scanner.nextInt();\n\n                Node currentNode = nodes.get(id);\n                currentNode.left = nodes.get(leftId);\n                currentNode.right = nodes.get(rightId);\n            }\n\n            int result = Integer.MAX_VALUE;\n            for (Node node : nodes.values()) {\n                int weight = minimumWeight(node);\n                if (weight != -1) {\n                    result = Math.min(result, weight);\n                }\n            }\n\n            System.out.println(result == Integer.MAX_VALUE ? -1 : result);\n        }\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 18:47:11"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <cmath>\n\nusing namespace std;\n\nstruct Node {\n    char type;\n    double left_ratio, right_ratio;\n    Node* left;\n    Node* right;\n    double weight;\n\n    Node(char t, double lr, double rr) : type(t), left_ratio(lr), right_ratio(rr), left(nullptr), right(nullptr), weight(0) {}\n};\n\npair<double, double> calculateWeights(Node* node) {\n    if (node->type == 'W') {\n        return {node->weight, node->weight};\n    } else {\n        auto left_weights = calculateWeights(node->left);\n        auto right_weights = calculateWeights(node->right);\n        double left_total = left_weights.first + left_weights.second;\n        double right_total = right_weights.first + right_weights.second;\n        \n        double left_part = node->left_ratio;\n        double right_part = node->right_ratio;\n        \n        double lcm = (left_part * right_part) / __gcd(static_cast<int>(left_part), static_cast<int>(right_part));\n        double left_multiplier = lcm / left_part;\n        double right_multiplier = lcm / right_part;\n        \n        double left_needed = right_total * right_part;\n        double right_needed = left_total * left_part;\n        \n        double common = max(left_needed, right_needed);\n        \n        double left_weight = common / left_part;\n        double right_weight = common / right_part;\n        \n        node->weight = left_weight + right_weight;\n        \n        return {left_weight, right_weight};\n    }\n}\n\nNode* buildMobile() {\n    char type;\n    cin >> type;\n    if (type == 'W') {\n        double weight;\n        cin >> weight;\n        Node* node = new Node(type, 0, 0);\n        node->weight = weight;\n        return node;\n    } else {\n        double left_ratio, right_ratio;\n        cin >> left_ratio >> right_ratio;\n        Node* node = new Node(type, left_ratio, right_ratio);\n        node->left = buildMobile();\n        node->right = buildMobile();\n        return node;\n    }\n}\n\nvoid freeMobile(Node* node) {\n    if (node == nullptr) return;\n    if (node->type != 'W') {\n        freeMobile(node->left);\n        freeMobile(node->right);\n    }\n    delete node;\n}\n\nint main() {\n    int datasets;\n    cin >> datasets;\n    while (datasets--) {\n        Node* root = buildMobile();\n        calculateWeights(root);\n        cout << (int)round(root->weight) << endl;\n        freeMobile(root);\n        if (datasets > 0) cout << endl;\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 18:47:42"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MAX_RODS 100\n#define MAX_CHILDREN 2\n\ntypedef struct Rod {\n    int left_ratio;\n    int right_ratio;\n    int left_weight;\n    int right_weight;\n    struct Rod* left_child;\n    struct Rod* right_child;\n} Rod;\n\nint min_weight = INT_MAX;\n\nint calculate_weight(Rod* rod) {\n    if (!rod) return 0;\n    \n    int left_w = rod->left_weight;\n    int right_w = rod->right_weight;\n    \n    if (rod->left_child) {\n        left_w += calculate_weight(rod->left_child) * rod->left_ratio;\n    }\n    \n    if (rod->right_child) {\n        right_w += calculate_weight(rod->right_child) * rod->right_ratio;\n    }\n    \n    return left_w + right_w;\n}\n\nint is_balanced(Rod* rod) {\n    if (!rod) return 1;\n    \n    int left_w = rod->left_weight;\n    int right_w = rod->right_weight;\n    \n    if (rod->left_child) {\n        left_w += calculate_weight(rod->left_child) * rod->left_ratio;\n    }\n    \n    if (rod->right_child) {\n        right_w += calculate_weight(rod->right_child) * rod->right_ratio;\n    }\n    \n    return left_w == right_w;\n}\n\nvoid find_minimum_weight(Rod* root) {\n    if (!root) return;\n    \n    if (is_balanced(root)) {\n        int total_weight = calculate_weight(root);\n        min_weight = (total_weight < min_weight) ? total_weight : min_weight;\n    }\n    \n    find_minimum_weight(root->left_child);\n    find_minimum_weight(root->right_child);\n}\n\nint main() {\n    int num_datasets;\n    scanf(\"%d\", &num_datasets);\n    \n    while (num_datasets--) {\n        int num_rods;\n        scanf(\"%d\", &num_rods);\n        \n        Rod* rods = malloc(num_rods * sizeof(Rod));\n        \n        for (int i = 0; i < num_rods; i++) {\n            scanf(\"%d %d %d %d\", \n                &rods[i].left_ratio, \n                &rods[i].right_ratio, \n                &rods[i].left_weight, \n                &rods[i].right_weight);\n            \n            rods[i].left_child = NULL;\n            rods[i].right_child = NULL;\n        }\n        \n        // Build the mobile structure based on input\n        // You'll need additional logic here to construct the rod connections\n        \n        min_weight = INT_MAX;\n        find_minimum_weight(&rods[0]);\n        \n        printf(\"%d\\n\", min_weight);\n        \n        free(rods);\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 18:47:53"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\nconst int MAX_N = 1000;\n\nstruct Node {\n    int type;  // 0 = weight, 1 = rod\n    int weight;\n    double left_ratio;\n    double right_ratio;\n    int left_child;\n    int right_child;\n};\n\nNode mobile[MAX_N];\nint num_nodes;\n\nbool is_balanced(int node_index) {\n    if (mobile[node_index].type == 0) {\n        return true;\n    }\n\n    int left = mobile[node_index].left_child;\n    int right = mobile[node_index].right_child;\n\n    double left_weight = mobile[left].type == 0 ? mobile[left].weight :\n        is_balanced(left) ? calculate_total_weight(left) : -1;\n    double right_weight = mobile[right].type == 0 ? mobile[right].weight :\n        is_balanced(right) ? calculate_total_weight(right) : -1;\n\n    if (left_weight == -1 || right_weight == -1) {\n        return false;\n    }\n\n    return fabs(left_weight * mobile[node_index].left_ratio - \n                right_weight * mobile[node_index].right_ratio) < 1e-9;\n}\n\ndouble calculate_total_weight(int node_index) {\n    if (mobile[node_index].type == 0) {\n        return mobile[node_index].weight;\n    }\n\n    int left = mobile[node_index].left_child;\n    int right = mobile[node_index].right_child;\n\n    return calculate_total_weight(left) + calculate_total_weight(right);\n}\n\nint solve() {\n    int min_total_weight = INT_MAX;\n\n    for (int config = 0; config < (1 << num_nodes); config++) {\n        // Try different weight configurations\n        for (int i = 0; i < num_nodes; i++) {\n            if (mobile[i].type == 0) {\n                mobile[i].weight = (config & (1 << i)) ? 1 : 2;\n            }\n        }\n\n        // Check if mobile is balanced\n        if (is_balanced(num_nodes - 1)) {\n            int total_weight = 0;\n            for (int i = 0; i < num_nodes; i++) {\n                if (mobile[i].type == 0) {\n                    total_weight += mobile[i].weight;\n                }\n            }\n            min_total_weight = min(min_total_weight, total_weight);\n        }\n    }\n\n    return min_total_weight;\n}\n\nint main() {\n    int test_cases;\n    cin >> test_cases;\n\n    while (test_cases--) {\n        cin >> num_nodes;\n\n        for (int i = 0; i < num_nodes; i++) {\n            cin >> mobile[i].type;\n            if (mobile[i].type == 0) {\n                mobile[i].weight = 0;\n            } else {\n                cin >> mobile[i].left_ratio >> mobile[i].right_ratio;\n                cin >> mobile[i].left_child >> mobile[i].right_child;\n            }\n        }\n\n        cout << solve() << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:48:03"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\nclass Mobile {\n    static class Node {\n        double ratioLeft, ratioRight;\n        Node left, right;\n        boolean isWeight;\n        double weight;\n\n        Node(double rl, double rr) {\n            ratioLeft = rl;\n            ratioRight = rr;\n            isWeight = false;\n        }\n\n        Node(double w) {\n            isWeight = true;\n            weight = w;\n        }\n    }\n\n    static Node buildMobile(Scanner sc) {\n        String token = sc.next();\n        if (token.equals(\"W\")) {\n            return new Node(sc.nextDouble());\n        } else if (token.equals(\"R\")) {\n            Node node = new Node(sc.nextDouble(), sc.nextDouble());\n            node.left = buildMobile(sc);\n            node.right = buildMobile(sc);\n            return node;\n        }\n        return null;\n    }\n\n    static double[] computeWeights(Node node) {\n        if (node == null) return new double[]{0, 0};\n        if (node.isWeight) {\n            return new double[]{node.weight, node.weight};\n        }\n        double[] left = computeWeights(node.left);\n        double[] right = computeWeights(node.right);\n        double leftWeight = left[1];\n        double rightWeight = right[1];\n        double leftRatio = node.ratioLeft;\n        double rightRatio = node.ratioRight;\n        double total = Math.max(leftWeight / rightRatio, rightWeight / leftRatio) * (leftRatio + rightRatio);\n        return new double[]{total, total};\n    }\n\n    public static void main(String[] args) throws IOException {\n        Scanner sc = new Scanner(System.in);\n        int cases = sc.nextInt();\n        for (int i = 0; i < cases; i++) {\n            Node root = buildMobile(sc);\n            double[] result = computeWeights(root);\n            System.out.printf(\"%.3f\\n\", result[0]);\n        }\n        sc.close();\n    }\n}",
    "timestamp": "2025-08-05 18:49:00"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict\n\ndef solve_mobile(data_sets):\n    results = []\n\n    def parse_data_set(data_set):\n        rods = defaultdict(list)\n        weights = {}\n        \n        for line in data_set:\n            parts = line.split()\n            if parts[0] == \"ROD\":\n                rod_id, ratio = parts[1], float(parts[2])\n                rods[rod_id] = ratio\n            else:\n                rod_id, end, connected_id = parts[0], parts[1], parts[2]\n                if connected_id.isdigit():\n                    if end == \"RED\":\n                        weights[rod_id] = (float(connected_id), \"RED\")\n                    else:\n                        weights[rod_id] = (float(connected_id), \"BLUE\")\n                else:\n                    rods[connected_id].append((rod_id, end))\n        \n        return rods, weights\n\n    def balance_rod(rod_id, rods, weights):\n        RED_force, BLUE_force = 0, 0\n        \n        for attached_id, end in rods[rod_id]:\n            if attached_id in weights:\n                weight, weight_end = weights[attached_id]\n                attach_ratio = rods[rod_id]\n                if weight_end == \"RED\":\n                    RED_force += weight\n                else:\n                    BLUE_force += weight\n            else:\n                sub_red, sub_blue = balance_rod(attached_id, rods, weights)\n                RED_force += sub_red\n                BLUE_force += sub_blue\n                \n                attach_ratio = rods[rod_id]\n                if end == \"RED\":\n                    RED_force += sub_blue * attach_ratio\n                else:\n                    BLUE_force += sub_red / attach_ratio\n                    \n        return RED_force, BLUE_force\n    \n    for data_set in data_sets:\n        rods, weights = parse_data_set(data_set)\n        top_rod = list(rods.keys())[0]\n        \n        RED_force, BLUE_force = balance_rod(top_rod, rods, weights)\n        total_min_weight = RED_force + BLUE_force\n        results.append(total_min_weight)\n\n    return results\n\n# Example dataset format\ndata_sets = [\n    [\n        \"ROD a 2\",\n        \"a RED 1\",\n        \"a BLUE b\",\n        \"ROD b 1.5\",\n        \"b RED 2\",\n        \"b BLUE 3\"\n    ],\n    [\n        \"ROD x 3\",\n        \"x RED y\",\n        \"x BLUE 10\",\n        \"ROD y 2\",\n        \"y RED 4\",\n        \"y BLUE z\",\n        \"ROD z 1\",\n        \"z RED 2\",\n        \"z BLUE 5\"\n    ]\n]\n\nprint(solve_mobile(data_sets))",
    "timestamp": "2025-08-13 00:56:34"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Scanner;\nimport java.util.List;\nimport java.util.ArrayList;\n\npublic class MobileArt {\n    static class Rod {\n        double redRatio; // Ratio from pivot to red end\n        double blueRatio; // Ratio from pivot to blue end\n        List<Object> redAttachments; // Attachments on the red end\n        List<Object> blueAttachments; // Attachments on the blue end\n        \n        Rod(double redRatio, double blueRatio) {\n            this.redRatio = redRatio;\n            this.blueRatio = blueRatio;\n            this.redAttachments = new ArrayList<>();\n            this.blueAttachments = new ArrayList<>();\n        }\n    }\n\n    public static double calculateWeight(Object attachment) {\n        if (attachment instanceof Double) {\n            return (double) attachment;\n        } else if (attachment instanceof Rod) {\n            Rod rod = (Rod) attachment;\n            double redTotal = 0.0;\n            double blueTotal = 0.0;\n\n            for (Object redAttachment : rod.redAttachments) {\n                redTotal += calculateWeight(redAttachment);\n            }\n            for (Object blueAttachment : rod.blueAttachments) {\n                blueTotal += calculateWeight(blueAttachment);\n            }\n\n            double balanceWeight = (redTotal * rod.redRatio + blueTotal * rod.blueRatio) / \n                                   (rod.redRatio + rod.blueRatio);\n            \n            return balanceWeight * 2;\n        }\n        return 0.0;\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        while (sc.hasNext()) {\n            String line = sc.nextLine().trim();\n            if (line.isEmpty()) {\n                break;\n            }\n            String[] tokens = line.split(\"\\\\s+\");\n            double redRatio = Double.parseDouble(tokens[0]);\n            double blueRatio = Double.parseDouble(tokens[1]);\n\n            Rod rod = new Rod(redRatio, blueRatio);\n\n            for (int i = 2; i < tokens.length; i++) {\n                String token = tokens[i].trim();\n                if (token.equals(\"R\")) {\n                    i++;\n                    Object attachment = tokens[i].matches(\"-?[0-9]+\\\\.?[0-9]*\") ?\n                                        Double.parseDouble(tokens[i]) : new Rod(0, 0); // recursive or weight \n                    rod.redAttachments.add(attachment);\n                } else if (token.equals(\"B\")) {\n                    i++;\n                    Object attachment = tokens[i].matches(\"-?[0-9]+\\\\.?[0-9]*\") ?\n                                        Double.parseDouble(tokens[i]) : new Rod(0, 0); // recursive or weight\n                    rod.blueAttachments.add(attachment);\n                }\n            }\n\n            double result = calculateWeight(rod);\n            System.out.printf(\"%.2f\\n\", result);\n        }\n        sc.close();\n    }\n}",
    "timestamp": "2025-08-13 00:56:40"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Rod {\n    int red_length, blue_length;\n    int attached_red, attached_blue;\n    int red_weight, blue_weight;\n} Rod;\n\nint isLeaf(Rod* rod) {\n    return rod->attached_red == -1 && rod->attached_blue == -1;\n}\n\nint minWeight(Rod* rods, int index) {\n    Rod* rod = &rods[index];\n    if (isLeaf(rod)) {\n        // Calculate weights for leaf nodes\n        rod->red_weight = rod->red_length;\n        rod->blue_weight = rod->blue_length;\n        return rod->red_weight + rod->blue_weight;\n    } else {\n        if (rod->attached_red != -1) {\n            rod->red_weight = minWeight(rods, rod->attached_red);\n        } else {\n            rod->red_weight = rod->red_length;\n        }\n        \n        if (rod->attached_blue != -1) {\n            rod->blue_weight = minWeight(rods, rod->attached_blue);\n        } else {\n            rod->blue_weight = rod->blue_length;\n        }\n\n        int balance_factor_red = rod->red_weight * rod->red_length;\n        int balance_factor_blue = rod->blue_weight * rod->blue_length;\n        \n        if (balance_factor_red == balance_factor_blue) {\n            return rod->red_weight + rod->blue_weight;\n        } else {\n            int weight_needed = abs(balance_factor_red - balance_factor_blue) /\n                                ((balance_factor_red > balance_factor_blue) ? rod->red_length : rod->blue_length);\n            if (balance_factor_red > balance_factor_blue) {\n                rod->blue_weight += weight_needed;\n            } else {\n                rod->red_weight += weight_needed;\n            }\n            return rod->red_weight + rod->blue_weight;\n        }\n    }\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    Rod* rods = (Rod*)malloc(n * sizeof(Rod));\n    \n    for (int i = 0; i < n; ++i) {\n        scanf(\"%d %d %d %d\", \n              &rods[i].red_length, &rods[i].blue_length,\n              &rods[i].attached_red, &rods[i].attached_blue);\n        rods[i].red_weight = 0;\n        rods[i].blue_weight = 0;\n    }\n\n    int total_weight = minWeight(rods, 0);\n    printf(\"%d\\n\", total_weight);\n\n    free(rods);\n    return 0;\n}",
    "timestamp": "2025-08-13 00:56:47"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_mobile(ratios, max_weight):\n    def balance_search(current_weights):\n        min_weight = float('inf')\n        \n        def recursive_balance(level):\n            nonlocal min_weight\n            \n            if level == len(ratios):\n                total_weight = sum(current_weights)\n                min_weight = min(min_weight, total_weight)\n                return\n            \n            red_ratio, blue_ratio = ratios[level]\n            \n            for red_weight in range(1, max_weight + 1):\n                for blue_weight in range(1, max_weight + 1):\n                    if red_weight * blue_ratio == blue_weight * red_ratio:\n                        current_weights[level] = red_weight + blue_weight\n                        recursive_balance(level + 1)\n        \n        recursive_balance(0)\n        return min_weight\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        ratios = []\n        for _ in range(n):\n            red_ratio, blue_ratio = map(int, input().split())\n            ratios.append((red_ratio, blue_ratio))\n        \n        max_weight = 10\n        result = solve_mobile(ratios, max_weight)\n        print(result)\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 00:56:58"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom fractions import Fraction\n\ndef solve():\n    input = sys.stdin.read().split()\n    ptr = 0\n    while ptr < len(input):\n        if input[ptr] == '0':\n            break\n        n = int(input[ptr])\n        ptr += 1\n        children = [[] for _ in range(n+1)]\n        ratios = [None]*(n+1)\n        is_weight = [False]*(n+1)\n        for _ in range(n):\n            parts = input[ptr:ptr+4]\n            ptr +=4\n            node = int(parts[0])\n            a = int(parts[1])\n            b = int(parts[2])\n            c = int(parts[3])\n            ratios[node] = (Fraction(a, b), Fraction(c, b))\n            if c == 0:\n                is_weight[node] = True\n            else:\n                children[node] = [int(parts[3])]\n                if a != 0:\n                    children[node].append(int(parts[1]))\n        # Process from leaves to root\n        weight = [Fraction(0) for _ in range(n+1)]\n        for node in range(n, 0, -1):\n            if is_weight[node]:\n                weight[node] = Fraction(1)\n            else:\n                left_child, right_child = children[node][1], children[node][0]\n                a, c = ratios[node]\n                lcm_denominator = (a * weight[left_child]).denominator * (c * weight[right_child]).denominator\n                left_num = (a * weight[left_child]).numerator * (c * weight[right_child]).denominator\n                right_num = (c * weight[right_child]).numerator * (a * weight[left_child]).denominator\n                lcm_numerator = left_num * right_num // gcd(left_num, right_num)\n                left_mult = lcm_numerator // left_num\n                right_mult = lcm_numerator // right_num\n                weight[left_child] *= left_mult\n                weight[right_child] *= right_mult\n                weight[node] = weight[left_child] + weight[right_child]\n        total = sum(weight[1:n+1])\n        print(total.numerator)\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\nsolve()",
    "timestamp": "2025-08-13 00:57:23"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nstruct Rod {\n    double ratio;\n    vector<Rod> redRods, blueRods;\n    double redWeight, blueWeight;\n};\n\ndouble balance(Rod& rod) {\n    double redSum = 0.0, blueSum = 0.0;\n\n    for (auto& rRod : rod.redRods) {\n        redSum += balance(rRod);\n    }\n    \n    for (auto& bRod : rod.blueRods) {\n        blueSum += balance(bRod);\n    }\n\n    double totalRedWeight = redSum + rod.redWeight;\n    double totalBlueWeight = blueSum + rod.blueWeight;\n\n    double requiredWeightRed = totalBlueWeight * rod.ratio;\n    double requiredWeightBlue = totalRedWeight / rod.ratio;\n\n    if (totalRedWeight < requiredWeightRed) {\n        rod.redWeight = requiredWeightRed - redSum;\n        totalRedWeight = requiredWeightRed;\n    }\n\n    if (totalBlueWeight < requiredWeightBlue) {\n        rod.blueWeight = requiredWeightBlue - blueSum;\n        totalBlueWeight = requiredWeightBlue;\n    }\n\n    return totalRedWeight + totalBlueWeight;\n}\n\nint main() {\n    int t;\n    cin >> t;\n\n    while (t--) {\n        int n;\n        cin >> n;\n        \n        vector<Rod> rods(n);\n\n        for (int i = 0; i < n; ++i) {\n            int redCount, blueCount;\n            cin >> rods[i].ratio >> redCount >> blueCount;\n\n            rods[i].redRods.resize(redCount);\n            rods[i].blueRods.resize(blueCount);\n\n            for (int j = 0; j < redCount; ++j) {\n                int index;\n                cin >> index;\n                rods[i].redRods[j] = rods[index];\n            }\n            for (int j = 0; j < blueCount; ++j) {\n                int index;\n                cin >> index;\n                rods[i].blueRods[j] = rods[index];\n            }\n        }\n\n        double minimumWeight = balance(rods[0]);\n        cout << minimumWeight << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 10:56:54"
  }
]