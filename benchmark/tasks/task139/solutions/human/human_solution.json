[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define err(args...) {}\n#ifdef DEBUG\n#include \"_debug.cpp\"\n#endif\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\ntemplate <typename T> using lim = numeric_limits<T>;\ntemplate <typename T> istream& operator>>(istream& is, vector<T>& a) { for(T& x : a) { is >> x; } return is; }\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    int n;\n    while(cin >> n and n) {\n        vector<ll> p(n + 1), q(n + 1), r(n + 1), b(n + 1), is_root(n + 1, true);\n        for(int i = 1; i <= n; i++) {\n            cin >> p[i] >> q[i] >> r[i] >> b[i];\n            is_root[r[i]] = is_root[b[i]] = false;\n        }\n        function<ll(int)> solve = [&](int i) -> ll {\n            if(i == 0) {\n                return 1;\n            } else {\n                ll rw = solve(r[i]), bw = solve(b[i]), g = __gcd(rw * p[i], bw * q[i]);\n                return rw * bw * p[i] / g + rw * bw * q[i] / g;\n            }\n        };\n        for(int i = 1; i <= n; i++) {\n            if(is_root[i]) {\n                cout << solve(i) << endl;\n            }\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint n;\nint a[100][2],p[100][2];\nbool cal[100];\nint GCD(int x,int y){\n\twhile(true){\n\t\tif(y>x){int t=x;x=y,y=t;}\n\t\tx%=y;\n\t\tif(x<2||!y)break;\n\t}\n\treturn y;\n}\nint DFS(int x){\n\tif(!x)return 1;\n\tcout<<x<<endl;\n\tx--;\n\tint b=DFS(p[x][0]),c=DFS(p[x][1]);\n\tint s=b*a[x][0]*c*a[x][1]/GCD(b*a[x][1],c*a[x][0]);\n\treturn s/a[x][0]+s/a[x][1];\n}\nint main(){\n\twhile(true){\n\tcin>>n;\n\tif(!n)break;\n\tfor(int i=0;i<n;i++)cal[i]=true;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>a[i][0]>>a[i][1];\n\t\tint t=GCD(a[i][0],a[i][1]);\n\t\ta[i][0]/=t,a[i][1]/=t;\n\t\tcin>>p[i][0]>>p[i][1];\n\t\tcal[p[i][0]-1]=false,cal[p[i][1]-1]=false;\n\t}\n\tfor(int i=0;i<n;i++)if(cal[i])cout<<DFS(i+1)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define pb push_back\n#define fi first\n#define se second\ntypedef pair<ll,ll> P;\nusing VP = vector<P>; using VVP = vector<VP>;\nusing VI = vector<ll>; using VVI = vector<VI>; using VVVI = vector<VVI>;\nconst int inf=1e9+7;\nconst ll INF=1LL<<61;\nconst ll mod=1e9+7;\n\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nVI v;\nvector<P> lr;\nvector<P> w;\n\nll gcd(ll a,ll b){\n    if(a<b) swap(a,b);\n    if(a%b==0) return b;\n    else return gcd(a%b,b);\n}\n\nll lcm(ll a,ll b){\n    return a/gcd(a,b)*b;\n}\n\nint calc(int i){\n    if(v[i]>0) return v[i];\n    int a=1,b=1;\n    if(w[i].fi>0){\n        a = calc(w[i].fi);\n    }\n    if(w[i].se>0){\n        b = calc(w[i].se);\n    }\n    ll c = lcm(lr[i].fi,a);\n    ll dd = c/lr[i].fi*lr[i].se;\n    ll d = lcm(dd,b);\n    c = d/dd*c;\n    return v[i]=c+d;\n}\n\nint main(){\n    int i,j;\n    int n;\n    while(1){\n        cin>>n;\n        ll ans=0;\n        if(n==0) break;\n        v = VI(n+1,0);\n        lr.clear();\n        w.clear();\n        lr.pb(P(0,0));\n        w.pb(P(0,0));\n        for(i=1;i<=n;i++){\n            int a,b,c,d;\n            cin>>a>>b>>c>>d;\n            int g=gcd(a,b);\n            a/=g;\n            b/=g;\n            lr.pb(P(b,a));\n            w.pb(P(c,d));\n        }\n        for(i=1;i<=n;i++) calc(i);\n        for(i=1;i<=n;i++) ans=max(ans,v[i]);\n        cout<<ans<<endl;\n    }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "//  Lightest Mobile.cpp\n//  2013/01/03.\n\n#if 1\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nint B[128][4];\n\nint __lcm(int a, int b)\n{\treturn a / __gcd(a, b) * b; }\n\nint rec(int idx)\n{\n\tint a = (B[idx][2] == 0 ? 1 : rec(B[idx][2]-1));\n\tint b = (B[idx][3] == 0 ? 1 : rec(B[idx][3]-1));\n\t\n\tint p = B[idx][0];\n\tint q = B[idx][1];\n\t\n\tint lcm = __lcm(p*a, q*b);\n\t\n\treturn lcm / p + lcm / q;\n}\n\nint main()\n{\n    for(int n; cin >> n && n; )\n\t{\n\t\tvint pflag(n+1, true);\n\t\t\n\t\trep(i, n)\n\t\t{\n\t\t\trep(j, 4) cin >> B[i][j];\n\t\t\t\n\t\t\tpflag[B[i][2]] = false;\n\t\t\tpflag[B[i][3]] = false;\n\t\t}\n\t\t\n\t\trep(i, n) if(pflag[i+1]) cout << rec(i) << endl;\n\t}\n}\n\n#endif"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"math.h\"\n#include \"utility\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"iomanip\"\n#include \"random\"\n\nusing namespace std;\nconst long long int MOD = 1000000007;\n\nint N;\nlist<int>P;\nlist<long long int>ans;\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin >> N;\n\tP.push_back(2);\n\tfor (int i = 3; i < pow(2,16); i += 2) {\n\t\tbool flag = true;\n\t\tfor (auto j : P) {\n\t\t\tif (i%j == 0) {\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (j*j > i)break;\n\t\t}\n\t\tif (flag)P.push_back(i);\n\t}\n\twhile (N) {\n\t\tvector<long long int>l(N);\n\t\tvector<long long int>r(N);\n\t\tvector<int>lx(N);\n\t\tvector<int>rx(N);\n\t\tvector<long long int>lw(N);\n\t\tvector<long long int>rw(N);\n\t\tvector<bool>flag(N, true);\n\t\tstack<int>node;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tint a, b, c, d;\n\t\t\tcin >> a >> b >> c >> d;\n\t\t\tc--;\n\t\t\td--;\n\t\t\tl[i] = a;\n\t\t\tr[i] = b;\n\t\t\tlx[i] = c;\n\t\t\trx[i] = d;\n\t\t\tif (c == -1 && d == -1) {\n\t\t\t\tlw[i] = r[i];\n\t\t\t\trw[i] = l[i];\n\t\t\t}\n\t\t\telse if (c == -1)lw[i] = 1;\n\t\t\telse if (d == -1)rw[i] = 1;\n\t\t\tif (c >= 0)flag[c] = false;\n\t\t\tif (d >= 0)flag[d] = false;\n\t\t}\n\t//\tcout << \"hijiki\";\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (flag[i]) {\n\t\t\t\tnode.push(i);\n\t\t\t}\n\t\t}\n\t\twhile (!node.empty()) {\n\t\t\tint current = node.top();\n\t\t\tbool con = false;\n\t\t\tif (lx[current] >= 0) {\n\t\t\t\tif (lw[lx[current]] && rw[lx[current]])lw[current] = lw[lx[current]] + rw[lx[current]];\n\t\t\t\telse {\n\t\t\t\t\tnode.push(lx[current]);\n\t\t\t\t\tcon = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rx[current] >= 0) {\n\t\t\t\tif (lw[rx[current]] && rw[rx[current]])rw[current] = lw[rx[current]] + rw[rx[current]];\n\t\t\t\telse {\n\t\t\t\t\tnode.push(rx[current]);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (con)continue;\n\t\t\tif (l[current] * lw[current] != r[current] * rw[current]) {\n\t\t\t\tlong long int a = r[current] * rw[current];\n\t\t\t\tlong long int b = l[current] * lw[current];\n\t\t\t\tfor (auto i : P) {\n\t\t\t\t\twhile(a%i==0&&b%i==0){\n\t\t\t\t\t\ta /= i;\n\t\t\t\t\t\tb /= i;\n\t\t\t\t\t}\n\t\t\t\t\tif (min(a, b) < i)break;\n\t\t\t\t}\n\t\t\t\tlw[current] *= a;\n\t\t\t\trw[current] *= b;\n\t\t\t}\n\t\t//\tcout << current << \" \" << lw[current] << \" \" << rw[current] << endl;\n\t\t\tnode.pop();\n\t\t}\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (flag[i]) {\n\t\t\t\tans.push_back(lw[i] + rw[i]);\n\t\t\t\t//cout << lw[i] + rw[i] << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcin >> N;\n\t}\n\tfor (auto i : ans)cout << i << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n\ntemplate <class T>\nint __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\nll gcd(ll a, ll b)\n{\n\tif (a < b)\n\t\tswap(a, b);\n\tif (b == 0)\n\t\treturn a;\n\treturn gcd(b, a%b);\n}\nll lcm(ll a, ll b)\n{\n\treturn a*b/gcd(a, b);\n}\nint p[1024], q[1024], r[1024], b[1024];\nint w[1024];\nint dfs(int s)\n{\n\tif (s == 0)\n\t\treturn 1;\n\telse if (w[s] != -1)\n\t\treturn w[s];\n\n\tll red = dfs(r[s]), blue = dfs(b[s]);\n\tll t = lcm(red*q[s], blue*p[s]);\n\tw[s] = (int)(t/p[s] + t/q[s]);\n\treturn w[s];\n}\nint main()\n{\n\tint n;\n\twhile (~scanf(\"%d\", &n) && n)\n\t{\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t{\n\t\t\tscanf(\"%d%d%d%d\", p+i, q+i, r+i, b+i);\n\t\t\tll g = gcd(p[i], q[i]);\n\t\t\tp[i] /= g, q[i] /= g;\n\t\t}\n\t\tmemset(w, -1, sizeof(w));\n\t\tint res = 0;\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t\tres = max(res, dfs(i));\n\t\tprintf(\"%d\\n\", res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//???????????¢????????§?????°????????¢?????????????§????\n//??????????????¨?????¢????????????????????????????°??????¢?????????????§???????????????????????????¨???????????????\n//???2 3??§?????£??????????????????????????????4 6??§?????£?????????????????????????????????????????´?????????\n//???????????????????????¨??????????????????????§??????????????????\\?????¨????????????\n//?§£?±??????????????????¢?????????????????? = ????°??????¢????????? * ??´??°(>=1)???\n//??????????????§?????£????????????????????§?????????????????????????¢?????????????????????????\n\n#include<iostream>\n#define int long long\nusing namespace std;\n\nstruct Bou{\n\tint childl;\n\tint childr;\n\tint lengthl;\n\tint lengthr;\n\t\n\tvoid setBou( int p, int q, int r, int s ){\n\t\tlengthl = p;\n\t\tlengthr = q;\n\t\tchildl = r;\n\t\tchildr = s;\n\t}\n}bou[101];\n\nint gcd( int a, int b ){\n\treturn ((b > 0) ? gcd( b, a % b ) : a);\n}\nint lcm( int a, int b ){\n\treturn a * b / gcd(a, b);\n}\n\nint dfs( int ind ){\n\t//?????????\n\tif( ind == 0 ){\n\t\treturn 1;\n\t}\n\t//???\n\tint lw = dfs(bou[ind].childl);\n\t//???\n\tint rw = dfs(bou[ind].childr);\n\t\n\tint moment = lcm(lw * bou[ind].lengthr, rw * bou[ind].lengthl);\n\tint ret = moment / bou[ind].lengthr + moment / bou[ind].lengthl;\n\treturn ret;\n}\n\nsigned main()\n{\n\tint n;\n\tbool isRoot[101];\n\t\n\twhile( cin >> n ){\n\t\tif( !n ) break;\n\t\tfor( int i = 1; i <= n; i++ ){ isRoot[i] = true; }\n\t\t\n\t\tfor( int i = 0; i < n; i++ ){\n\t\t\tint p, q, r, s;\n\t\t\tcin >> p >> q >> r >> s;\n\t\t\tbou[i+1].setBou(p, q, r, s);\n\t\t\tisRoot[r] = (isRoot[s] = false);\n\t\t}\n\t\t\n\t\tfor( int i = 1; i <= n; i++ ){\n\t\t\tif( isRoot[i] ){\n\t\t\t\tcout << dfs(i) << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n\nusing namespace std;\n\nstruct Stick {\n  int p, q, r, b, w;\n  bool operator<(Stick& other) {\n    return w < other.w;\n  }\n};\n\nStick sticks[101];\n\nvoid simplify_ratio(int& x, int& y) {\n  int i = x, j = y;\n  if (i < j) swap(i, j);\n  while (j) {\n    int t = j;\n    j = i % j;\n    i = t;\n  }\n  x /= i;\n  y /= i;\n}\n\nint rec(int i) {\n  Stick s = sticks[i];\n  if (s.w) return s.w;\n  int r = s.r ? rec(s.r) : 1, b = s.b ? rec(s.b) : 1, x = s.q * b, y = s.p * r;\n  simplify_ratio(x, y);\n  return sticks[i].w = r * x + b * y;\n}\n\nint main() {\n  for (;;) {\n    int n;\n    cin >> n;\n    if (!n) return 0;\n    for (int i = 1; i <= n; i++) {\n      Stick s;\n      cin >> s.p >> s.q >> s.r >> s.b;\n      s.w = 0;\n      simplify_ratio(s.p, s.q);\n      sticks[i] = s;\n    }\n    for (int i = 1; i <= n; i++)\n      rec(i);\n    cout << max_element(sticks+1, sticks+n+1)->w << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nlong long gcd(long long a, long long b){ // Ååöñ\n    if(a == 0 || b == 0)\n        return 0;\n    if(b > a)\n        swap(a, b);\n    long long tmp;\n    while((tmp = a % b) != 0){\n        a = b;\n        b = tmp;\n    }\n    return b;\n}\n\nlong long lcm(long long a, long long b){ // Å¬ö{\n    return a / gcd(a, b) * b;\n}\n\nint solve(vector<vector<int> >& stick, int i)\n{\n    if(i == 0)\n        return 1;\n\n    int p = stick[i][0];\n    int q = stick[i][1];\n    int tmp = gcd(p, q);\n    p /= tmp;\n    q /= tmp;\n\n    int a = solve(stick, stick[i][2]);\n    int b = solve(stick, stick[i][3]);\n    tmp = lcm(q*a, p*b);\n    int x = tmp / (q*a);\n    int y = tmp / (p*b);\n\n    return a*x + b*y;\n}\n\nint main()\n{\n    for(;;){\n        int n;\n        cin >> n;\n        if(n == 0)\n            return 0;\n\n        vector<vector<int> > stick(n+1, vector<int>(4));\n        vector<bool> check(n+1, false);\n        for(int i=1; i<=n; ++i){\n            for(int j=0; j<4; ++j){\n                cin >> stick[i][j];\n            }\n            check[stick[i][2]] = check[stick[i][3]] = true;\n        }\n\n        int ret = 0;\n        for(int i=1; i<=n; ++i){\n            if(!check[i])\n                ret += solve(stick, i);\n        }\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\n#define ll long long\nusing namespace std;\n\nvector<vector<ll>> sticks;\nvector<ll> ans;\n\nll gcd(ll a, ll b) {\n    if (a < b)swap(a, b);\n    if (a % b == 0)return b;\n    return gcd(b, a % b);\n}\n\nll solve(int x) {\n    if (x == 0) return 1;\n    x--;\n    ll l = solve(sticks[x][2]);\n    ll r = solve(sticks[x][3]);\n    ll GCD = gcd(l * sticks[x][0], r * sticks[x][1]);\n    ll min_power = l * sticks[x][0] * r * sticks[x][1] / GCD;\n    ans[x] = min_power / sticks[x][0] + min_power / sticks[x][1];\n    return min_power / sticks[x][0] + min_power / sticks[x][1];\n}\n\nint main() {\n    while(true){\n        int n;\n        cin >> n;\n        if(n == 0) break;\n        \n        vector<bool> hanged(n + 1);\n        sticks = vector<vector<ll>>(n, vector<ll>(4));\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < 4; j++)cin >> sticks[i][j];\n            hanged[sticks[i][2]] = true;\n            hanged[sticks[i][3]] = true;\n        }\n    \n        ans = vector<ll>(n);\n        for (int i = 1; i <= n; i++) {\n           if (!hanged[i])cout << solve(i) << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define X real()\n#define Y imag()\nusing namespace std;\ntypedef complex<int> cld;\ntypedef vector<cld> vcl;\ntypedef vector<int> vi; \ntypedef long long ll;\nll lcs(ll p, ll q){\n\tif(max(p,q) % min(p,q) ==0)\n\treturn min(p,q);\n\telse\n\treturn lcs(max(p,q)-min(p,q),min(p,q));\n}\nll gcd(ll p,ll q){\n\treturn p*q/lcs(p,q);\n}\nint main() {\n\tint n;\n\twhile(cin >> n && n){\n\tbool fin[101]={1,0};\n\tll mobil[101][4]={};\n\tll grav[101]={1,0};\n\tll p,q,r,b;\n\tFOR(i,1,n+1){\n\t\tcin >> p >> q >> r >>b;\n\t\tll d=lcs(p,q);\n\t\tmobil[i][0]=p/d;\n\t\tmobil[i][1]=q/d;\n\t\tmobil[i][2]=r;\n\t\tmobil[i][3]=b;\n\t}\n\tint finishes=0;\n\tREP(j,101){\n\t\tFOR(i,1,n+1)\n\t\t\tif(fin[mobil[i][2]] && fin[mobil[i][3]] && !fin[i]){\n\t\t\t\t\tgrav[i]=gcd(grav[mobil[i][2]],grav[mobil[i][3]])*(mobil[i][0]+mobil[i][1]);\n\t\t\t\t\tfin[i]=true;\n\t\t\t\t\tfinishes++;\n\t\t\t}\n\t}\n\tll sum=0;\n\tFOR(i,1,n+1)\n\tsum=max(sum,grav[i]);\n\tcout << sum << endl;\n\t}\n\t// your code goes here\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint poles[101][4];\n\nint gcd(int a, int b)\n{\n  return b == 0 ? a : gcd(b, a % b);\n}\n\nint lcm(int a, int b)\n{\n  return a * b / gcd(a, b);\n}\n\nint dfs(int n)\n{\n  int a = 1, b = 1;\n  if(poles[n][2])\n    a = dfs(poles[n][2]);\n  if(poles[n][3])\n    b = dfs(poles[n][3]);\n  int l = lcm(poles[n][0] * a, poles[n][1] * b);\n  return l / poles[n][0] + l / poles[n][1];\n}\n\n\nbool notRoot[101];\nint main()\n{\nloop:\n  fill(notRoot, notRoot + 101, false);\n  int n;\n  cin >> n;\n  if(!n)\n    return 0;\n\n  for(int i = 1; i <= n; i++)\n  {\n    cin >> poles[i][0] >> poles[i][1] >> poles[i][2] >> poles[i][3];\n    notRoot[poles[i][2]] = notRoot[poles[i][3]] = true;\n  }\n  for(int i = 1; i <= n; i++)\n  {\n    if(!notRoot[i])\n    {\n      cout << dfs(i) << endl;\n      goto loop;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\ntypedef unsigned long long ull;\null gcd(ull x, ull y) {\n\tif (y == 0) return x;\n\treturn gcd(y, x % y);\n}\null lcm(ull x, ull y) {\n\treturn x / gcd(x, y) * y;\n}\nint n, a[111], b[111], vis[111]; ull x[111], y[111];\null solve(int pos) {\n\tif (pos == -1) return 1;\n\tull l = solve(a[pos]) * y[pos];\n\tull r = solve(b[pos]) * x[pos];\n\tull t = gcd(l, r);\n\tl /= t, r /= t;\n\treturn l + r;\n}\nint main() {\n\twhile (cin >> n, n) {\n\t\tfill(vis, vis + n, 0);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> x[i] >> y[i] >> a[i] >> b[i]; a[i]--, b[i]--;\n\t\t\tif (a[i] != -1) vis[a[i]] = 1;\n\t\t\tif (b[i] != -1) vis[b[i]] = 1;\n\t\t\tull r = gcd(x[i], y[i]);\n\t\t\tx[i] /= r, y[i] /= r;\n\t\t}\n\t\tint root = find(vis, vis + n, 0) - vis;\n\t\tcout << solve(root) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint edge[100][4];\n\nint gcd(int m, int n){\n    int temp;\n    if(m > n){\n        temp = m;\n        m = n;\n        n = temp;\n    }\n    while(m){\n        temp = m;\n        m = n % m;\n        n = temp;\n    }\n    return n;\n}\n\nint lcm(int m, int n){\n    return m / gcd(m, n) * n;\n}\n\nint binary(int i){\n    int bin1, bin2, l;\n    bin1 = 1;\n    bin2 = 1;\n    if(edge[i][2]){\n        bin1 = binary(edge[i][2]-1);\n    }\n    if(edge[i][3]){\n        bin2 = binary(edge[i][3]-1);\n    }\n    l = lcm(bin1*edge[i][0], bin2*edge[i][1]);\n    return l/edge[i][0] + l/edge[i][1];\n}\n\nint main(){\n    int n;\n    int i;\n    int g;\n    bool data[101];\n    int top;\n    cin >> n;\n    while(n){\n        for(i=1;i<=n;i++){\n            data[i] = false;\n        }\n        for(i=0;i<n;i++){\n            cin >> edge[i][0] >> edge[i][1] >> edge[i][2] >> edge[i][3];\n            data[edge[i][2]] = true;\n            data[edge[i][3]] = true;\n        }\n        for(i=1;i<=n;i++){\n            if(!data[i]){\n                top = i-1;\n                break;\n            }\n        }\n        cout << binary(top) << endl;\n        cin >> n;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstring>\nusing namespace std;\nint gcd(int a,int b) {\n    return b?gcd(b,a%b):a;\n}\nint lcm(int a,int b) {\n    return a/gcd(a,b)*b;\n}\nstruct Bar {\n    int p,q,r,b;\n    Bar (int _p,int _q,int _r,int _b) {\n        p=_p,q=_q,r=_r,b=_b;\n    }\n};\nstruct Fraction {\n    int bunbo,bunshi;\n    Fraction (int _bunbo,int _bunshi) {\n        int G=gcd(_bunbo,_bunshi);\n\t\tbunbo=_bunbo/G,bunshi=_bunshi/G;\n    }\n};\nint n;\nvector<Bar> Bars;\nvector<Fraction> Fractions;\nbool child[100];\nvoid solve(int X,Fraction C) {\n    if(Bars[X].r>0) solve(Bars[X].r-1,Fraction(C.bunbo*(Bars[X].p+Bars[X].q),C.bunshi*Bars[X].q));\n    else Fractions.push_back(Fraction(C.bunbo*(Bars[X].p+Bars[X].q),C.bunshi*Bars[X].q));\n    if(Bars[X].b>0) solve(Bars[X].b-1,Fraction(C.bunbo*(Bars[X].p+Bars[X].q),C.bunshi*Bars[X].p));\n    else Fractions.push_back(Fraction(C.bunbo*(Bars[X].p+Bars[X].q),C.bunshi*Bars[X].p));\n}\nint main() {\n    while(scanf(\"%d\",&n),n) {\n        Bars.clear();\n        Fractions.clear();\n        memset(child,0,sizeof(child));\n        for(int i=0;i<n;i++) {\n            int p,q,r,b;\n            scanf(\"%d %d %d %d\",&p,&q,&r,&b);\n            if(r>0) child[r-1]=true;\n            if(b>0) child[b-1]=true;\n            Bars.push_back(Bar(p,q,r,b));\n        }\n        int par=0;\n        for(int i=0;i<n;i++) {\n            if(!child[i]) {par=i;break;}\n        }\n        solve(par,Fraction(1,1));\n        int L=1;\n        for(int i=0;i<Fractions.size();i++) {\n            L=lcm(L,Fractions[i].bunbo);\n        }\n        printf(\"%d\\n\",L);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\nusing namespace std;\ntypedef long long int ll;\nstruct edge{\n\tll to;\n\tll cost;\n};\nint N;\nint ccc;\nll num;\nll X[100][4];\nvector<edge> G[500];\nll gcd(ll a,ll b){\n\tif(b==0)return a;\n\treturn gcd(b,a%b);\n}\nll solve(int s){\n\tll a,b;\n\tif(G[s][0].to>=N)a=-1;\n\telse a=solve(G[s][0].to);\n\tif(G[s][1].to>=N)b=-1;\n\telse b=solve(G[s][1].to);\n\tif(a==-1&&b==-1)return G[s][0].cost+G[s][1].cost;\n\tif(a==-1){\n\t\tll kkk=b*G[s][0].cost/gcd(b,G[s][0].cost);\n\t\tll lll=kkk*G[s][1].cost/G[s][0].cost;\n\t\treturn kkk+lll;\n\t}\n\tif(b==-1){\n\t\tll kkk=b*G[s][1].cost/gcd(b,G[s][1].cost);\n\t\tll lll=kkk*G[s][0].cost/G[s][1].cost;\n\t\treturn kkk+lll;\n\t}\n\tll kkk=a*G[s][0].cost;ll lll=b*G[s][1].cost;\n\tll mmm=kkk*lll/gcd(kkk,lll);\n\treturn mmm/G[s][0].cost+mmm/G[s][1].cost;\n}\nint main()\n{\nwhile(true){\n\tscanf(\"%d\",&N);\n\tif(N==0)break;\n\tnum=N;\n\tccc=N*(N+1)/2;\n\tfor(int i=0;i<N;i++){\n\t\tG[i].clear();\n\t\tfor(int j=0;j<4;j++)scanf(\"%lld\",&X[i][j]);\n\t\tll GCD=gcd(X[i][0],X[i][1]);\n\t\tX[i][0]/=GCD;X[i][1]/=GCD;\n\t\tif(X[i][2]==0)X[i][2]=num++;\n\t\telse {ccc-=X[i][2];X[i][2]--;}\n\t\tif(X[i][3]==0)X[i][3]=num++;\n\t\telse {ccc-=X[i][3];X[i][3]--;}\n\t\tedge e;\n\t\te.to=X[i][2];e.cost=X[i][0];\n\t\tG[i].push_back(e);\n\t\te.to=X[i][3];e.cost=X[i][1];\n\t\tG[i].push_back(e);\n\t}\n\tccc--;\n\tprintf(\"%lld\\n\",solve(ccc));\n}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define REP(i, a, n) for(int i = a; i < n; i++)\nusing namespace std;\n\n\nint n;\nint p[101];\nint q[101];\nint r[101];\nint b[101];\nint u[101];\nint v;\n\nint gcd(int a, int b) {\n  if(b > a) swap(a, b);\n  int r = a % b;\n  if(r == 0) return b;\n  return gcd(b, r);\n}\n\nint dfs(int i) {\n  int g = gcd(p[i], q[i]);\n  int pg = p[i] / g;\n  int qg = q[i] / g;\n\n  if(r[i] == 0 && b[i] == 0) {\n    return pg + qg;\n  }\n\n  else {\n    int rr = 0, bb = 0;\n    if(r[i] != 0) rr = dfs(r[i]);\n    if(b[i] != 0) bb = dfs(b[i]);\n\n    if(rr != 0 && bb != 0) {\n      return rr * bb / gcd(rr, bb) * (pg + qg);\n    } else if(rr != 0 && bb == 0) {\n      int k = rr * qg / gcd(rr, qg);\n      return k + k * pg / qg;\n    } else if(rr == 0 && bb != 0) {\n      int k = bb * pg / gcd(bb, pg);\n      return k + k * qg / pg;\n    }\n  }\n\n  return 0;\n}\n\nint main(void) {\n  while(cin >> n, n != 0) {\n    REP(i, 1, n + 1) u[i] = 0;\n    REP(i, 1, n + 1) {\n      cin >> p[i] >> q[i] >> r[i] >> b[i];\n      u[r[i]] = 1;\n      u[b[i]] = 1;\n    }\n    REP(i, 1, n + 1) {\n      if(u[i] == 0) {\n        v = i;\n        break;\n      }\n    }\n\n    cout << dfs(v) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\ntypedef struct Node {\n  int p, q;\n  int r,b;\n  Node() {}\n  Node(int p, int q, int r, int b)\n    : p(p), q(q), r(r), b(b) {}\n} node;\n\nnode nd[101];\n\ntypedef long long Int;\nInt gcd(Int a, Int b) {\n  return (b != 0) ? gcd(b, a%b) : a;\n}\nInt lcm(Int a, Int b) {\n  return a / gcd(a,b) * b;\n}\n\nInt solve(Int id, Int nest) {\n  // cout << string(nest, ' ');\n  // cout << id << endl;\n  if (id == 0) return 1;\n  Int r = solve(nd[id].r, nest+1);\n  Int b = solve(nd[id].b, nest+1);\n\n  Int p = nd[id].p;\n  Int q = nd[id].q;\n  Int g = gcd(p,q);\n  p /= g; q /= g;\n  g = gcd(p*b, q*r);\n  Int aa = p*b*r/g;\n  Int bb = q*b*r/g;\n  //printf(\"%d %d : %d, %d\\n\",b,r, aa,bb);\n  return aa+bb;\n}\n\nint main() {\n  int n;\n  while(cin >> n, n) {\n    vector<bool> hoge(n+1);\n    REP(i,n) {\n      int p, q, r, b;\n      cin >> p >> q >> r >> b;\n      nd[i+1] = Node(p,q,r,b);\n      hoge[r] = 1;\n      hoge[b] = 1;\n    }\n    int a;\n    for (int i=1; i<=n; ++i)\n      if (!hoge[i])\n        a = i;\n    cout << solve(a,0) << endl; \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<typename T1,typename T2> void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  while(cin>>n,n){\n    vector<Int> p(n),q(n),r(n),s(n);\n    for(Int i=0;i<n;i++) cin>>p[i]>>q[i]>>r[i]>>s[i];\n    \n    for(Int i=0;i<n;i++){\n      Int k=__gcd(p[i],q[i]);\n      p[i]/=k;q[i]/=k;\n      r[i]--;s[i]--;\n    }\n\n    vector<Int> dp(n,-1);\n    function<Int(Int)> dfs=[&](Int x){\n      Int &res=dp[x];\n      if(~res) return res;\n      Int a=(~r[x]?dfs(r[x]):Int(1))*p[x];\n      Int b=(~s[x]?dfs(s[x]):Int(1))*q[x];\n      Int k=a/__gcd(a,b)*b;\n      return res=k/p[x]+k/q[x];\n    };\n    \n    Int ans=0;\n    for(Int i=0;i<n;i++) chmax(ans,dfs(i));\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_N 100\ntypedef long long ll;\n\nvector<ll> p, q, r, b;\n\nbool dfs(int v, ll val)\n{\n  ll l = p[v] + q[v];\n  if (val * p[v] % l != 0) {\n    return 0;\n  }\n  if (val * q[v] % l != 0) {\n    return 0;\n  }\n  bool can = 1;\n  if (r[v] >= 0) {\n    can &= dfs(r[v], val*p[v]/l); \n  }\n  if (b[v] >= 0) {\n    can &= dfs(b[v], val*q[v]/l); \n  }\n  return can;\n}\n\nvoid init(int N)\n{\n  p.clear(); q.clear();\n  r.clear(); b.clear();\n  p.resize(N); q.resize(N);\n  r.resize(N); b.resize(N);\n}\n\nint main()\n{\n  int N;\n  while (cin >> N, N) {\n    init(N);\n    bool used[MAX_N] = {};\n    for (int i = 0; i < N; i++) {\n      cin >> p[i] >> q[i] >> r[i] >> b[i];\n      r[i]--; b[i]--;\n      if (r[i] >= 0) used[r[i]] = 1;\n      if (b[i] >= 0) used[b[i]] = 1;\n      int gcd = __gcd(p[i], q[i]);\n      p[i] /= gcd;\n      q[i] /= gcd;\n    }\n    int par = -1;\n    for (int i = 0; i < N; i++) {\n      if (!used[i]) {\n\tpar = i;\n\tbreak;\n      }\n    }\n    \n    for (int i = 1; i <= 1000000; i++) {\n      if (dfs(par, i)) {\n\tcout << i << endl;\n\tbreak;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\n#define\trep(i,n)\tfor(int i=0;i<n;i++)\n\nusing namespace std;\n\ntypedef\tunsigned long long\tull;\n\null gcd(ull a,ull b){ return b?gcd(b,a%b):a; }\n\nstruct Node{\n\tint p,q,l,r;\n\tNode(){}\n\tNode(int P,int Q,int L,int R):p(P),q(Q),l(L),r(R){}\n} node[100];\n\null dfs(int u){\n\tif(u==-1)\treturn 1;\n\n\tint p=node[u].p,q=node[u].q,l=node[u].l,r=node[u].r;\n\tull wl=dfs(l),wr=dfs(r);\n\tull g=gcd(q*wl,p*wr);\n\tull m=p*wr/g,n=q*wl/g;\n\n\treturn m*wl+n*wr;\n}\n\nint main(){\n\tfor(int n;scanf(\"%d\",&n),n;){\t\n\t\trep(i,n){\n\t\t\tint p,q,l,r;\tscanf(\"%d%d%d%d\",&p,&q,&l,&r);\n\t\t\tint g=gcd(p,q);\n\t\t\tnode[i]=Node(p/g,q/g,l-1,r-1);\n\t\t}\n\n\t\tint root;\n\t\tbool b[100]={};\n\t\trep(i,n){\n\t\t\tif(~node[i].l)\tb[node[i].l]=true;\n\t\t\tif(~node[i].r)\tb[node[i].r]=true;\n\t\t}\n\t\trep(i,n)if(!b[i]){ root=i; break; }\n\n\t\tprintf(\"%llu\\n\",dfs(root));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<fstream>\n#include<string>\nusing namespace std;\n\nstruct tBar{\n\tunsigned int rdis, bdis, r, b;\n\tunsigned int w;\n};\ntBar bar[101];\nint N;\n\nunsigned int euclid( int a, int b ){\n\twhile( a != b ){\n\t\tif( a>b )\ta -= b;\n\t\telse\t\tb -= a;\n\t}\n\treturn a;\n}\n\nunsigned int calcWeight( int n ){\n\ttBar &bn = bar[n];\n\tunsigned int rw=0, bw=0;\n\tif( bn.r==0 && bn.b==0 ){\n\t\trw = bn.bdis;\n\t\tbw = bn.rdis;\n\t}else if( bn.r!=0 && bn.b==0 ){\n\t\t\trw = calcWeight( bn.r );\n\t\t\tif( bn.rdis*rw % bn.bdis == 0 ){\n\t\t\t\tbw = bn.rdis * rw / bn.bdis;\n\t\t\t}else{\n\t\t\t\tunsigned int e = euclid( bn.rdis*rw, bn.bdis );\n\t\t\t\tbw = bn.rdis*rw / e;\n\t\t\t\trw *= bn.bdis / e;\n\t\t\t}\n\t}else if( bn.r==0 && bn.b!=0 ){\n\t\t\tbw = calcWeight( bn.b );\n\t\t\tif( bn.bdis*bw % bn.rdis == 0 ){\n\t\t\t\trw = bn.bdis * bw / bn.rdis;\n\t\t\t}else{\n\t\t\t\tunsigned int e = euclid( bn.bdis*bw, bn.rdis );\n\t\t\t\trw = bn.bdis*bw / e;\n\t\t\t\tbw *= bn.rdis / e;\n\t\t\t}\n\t}else{\n\t\trw = calcWeight( bn.r );\n\t\tbw = calcWeight( bn.b );\n\t}\n\t\n\twhile( rw*bn.rdis != bw*bn.bdis ){\n\t\tif( rw*bn.rdis > bw*bn.bdis ){\n\t\t\tbw += bn.b==0 ? bn.rdis : bar[bn.b].w;\n\t\t}else{\n\t\t\trw += bn.r==0 ? bn.bdis : bar[bn.r].w;\n\t\t}\n\t}\n\tbn.w = rw+bw;\n\treturn bn.w;\n}\n\nint findRoot( int n ){\n\tfor( int i=1; i<=N; i++ ){\n\t\tif( bar[i].r==n || bar[i].b==n ){\n\t\t\tn = i;\n\t\t\ti = 0;\n\t\t}\n\t}\n\treturn n;\n}\n\nint main(){\n\tint n;\n\tstring str;\n\twhile(1){\n\t\tgetline( cin, str );\n\t\tsscanf( str.c_str(), \"%d\", &n );\n\t\tif( n == 0 )\tbreak;\n\t\tN = n;\n\t\tfor( int i=1; i<=n; i++ ){\n\t\t\tgetline( cin, str );\n\t\t\tint p,q,r,b;\n\t\t\tsscanf(str.c_str(), \"%d %d %d %d\", &p, &q, &r, &b);\n\t\t\tint e = euclid( p, q );\n\t\t\tbar[i].rdis = p / e;\n\t\t\tbar[i].bdis = q / e;\n\t\t\tbar[i].r = r;\n\t\t\tbar[i].b = b;\n\t\t\tbar[i].w = 0;\n\t\t}\n\t\tint root = findRoot(1);\n\t\tint sum = calcWeight(root);\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(ll i=(b) - 1;i>=(a);i--)\n#define REP(i,n) for(ll i=0;i<(n);i++)\n#define RREP(i,n) for(ll i=n-1;i>=0;i--)\n\n#define PB push_back\n#define INF (1<<29)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define CLR(a) memset(a,0,sizeof(a))\n\ntypedef long long int ll;\n\nusing namespace std;\nstruct mobile{\n    ll rc;\n    ll lc;\n    ll l;\n    ll r;\n    ll w; \n};\n\nll gcd(ll a, ll b){\n    return a%b==0 ? b : gcd(b,a%b);\n}\n\nint main(){\n    while(true){\n\tll n;\n\tcin >> n;\n\tif(n == 0) break;\n\tll ans =0 ;\n\tvector< struct mobile > v(n);\n\tREP(i,n){\n\t    ll l,r,lc,rc;\n\t    cin >> l >> r >> lc >> rc;\n\t    v[i].l = l;\n\t    v[i].r = r;\n\t    v[i].lc = lc;\n\t    v[i].rc = rc;\n\t    v[i].w = 0;\n\t}\n\tbool flg = true;\n\twhile(flg){\n\t    flg = false;\n\t    REP(i,n){\n\t\tif(v[i].w == 0 && v[i].rc == 0 && v[i].lc == 0){\n\t\t    ll r = v[i].r;\n\t\t    ll l = v[i].l;\n\t\t    v[i].r /= gcd(r,l);\n\t\t    v[i].l /= gcd(r,l);\n\t\t    v[i].w = v[i].r + v[i].l;\n\t\t    flg = true;\n\t\t}else{\n\t\t    ll lw,rw;\n\t\t    if(v[i].w > 0) continue;\n\t\t    if(v[i].lc == 0){\n\t\t\tlw = 1;\n\t\t    }else if(v[v[i].lc-1].w > 0){\n\t\t\tlw = v[v[i].lc-1].w;\n\t\t    }else continue;\n\n\t\t    if(v[i].rc == 0){\n\t\t\trw = 1;\n\t\t    }else if(v[v[i].rc-1].w > 0){\n\t\t\trw = v[v[i].rc-1].w;\n\t\t    }else continue;\n\t\t    ll r,l;\n\t\t    r = v[i].r;\n\t\t    l = v[i].l;\n\t\t    v[i].r /= gcd(r,l);\n\t\t    v[i].l /= gcd(r,l);\n\t\t    ll w = 1000000000000000;\n\t\t    FOR(k,1,10000000){\n\t\t\tFOR(j,1,100000000){\n\t\t\t    if(rw*k * v[i].r == lw * j * v[i].l){\n\t\t\t\tw = min ( w, rw*k+lw*j);\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    v[i].w = w;\n\t\t    flg = true;\n\t\t}\n\t\tans = max(ans,v[i].w);\n\t    }\n\t}\n\tcout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n#define pb push_back\n#define INF 1e15\nint n;\nint main(){\n\twhile(1){\n\t\tll lcm[105]={};\n\tvector<ll> son[105];\n\tP stick[105];\n\tbool decide[105]={};\n\tbool beleft[105]={},beright[105]={};\n\tscanf(\"%d\",&n);\n\tif(!n) break;\n\tfor(int q=1;q<=n;q++){\n\t\tll a,b,c,d;\n\t\tscanf(\"%lld %lld %lld %lld\",&a,&b,&c,&d);\n\t\tif(c){\n\t\t\tson[q].pb(c);\n\t\t\tbeleft[q]=true;\n\t\t}\n\t\tif(d){\n\t\t\tson[q].pb(d);\n\t\t\tberight[q]=true;\n\t\t}\n\t\tll rp;\n\t\tfor(int i=min(a,b);i>=1;i--){\n\t\t\tif(a%i==0 && b%i==0){\n\t\t\t\trp=((a/i)+(b/i));\n\t\t\t\tstick[q]=make_pair(a/i,b/i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tlcm[q]=rp;\n\t\tif(son[q].size()==0){\n\t\t\tdecide[q]=true;\n\t\t}\n\t}\n\tint last=1;\n\twhile(1){\n\t\tbool p=false;\n\tfor(int i=1;i<=n;i++){\n\t\tif(son[i].size()!=0 && !decide[i]){\n\t\t\tint cou=0;\n\t\t\tfor(int j=0;j<son[i].size();j++){\n\t\t\t\tif(decide[son[i][j]]){\n\t\t\t\t\tcou++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(cou==son[i].size()){\n\t\t\t\t\tll maxi1=0,maxi2=0;\n\t\t\t\t\tif(beleft[i]){\n\t\t\t\t\t\tfor(int g=min(stick[i].second,lcm[son[i][0]]);g>=1;g--){\n\t\t\t\t\t\t\tif(stick[i].second%g==0 && lcm[son[i][0]]%g==0){\n\t\t\t\t\t\t\t\tmaxi1=(lcm[son[i][0]]/g*(stick[i].first+stick[i].second));\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(beright[i]){\n\t\t\t\t\t\tfor(int g=min(stick[i].first,lcm[son[i][son[i].size()-1]]);g>=1;g--){\n\t\t\t\t\t\t\tif(stick[i].first%g==0 && lcm[son[i][son[i].size()-1]]%g==0){\n\t\t\t\t\t\t\t\tmaxi2=lcm[son[i][son[i].size()-1]]/g*(stick[i].first+stick[i].second);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(maxi1 && !maxi2){\n\t\t\t\t\t\tlcm[i]=maxi1;\n\t\t\t\t\t}else if(!maxi1 && maxi2){\n\t\t\t\t\t\tlcm[i]=maxi2;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfor(int q=min(maxi1,maxi2);q>=1;q--){\n\t\t\t\t\t\t\tif(maxi1%q==0 && maxi2%q==0){\n\t\t\t\t\t\t\t\tlcm[i]=maxi1*maxi2/q;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdecide[i]=true;\n\t\t\t\t\tlast=i;\n\t\t\t\t\tp=true;\n\t\t\t}\n\t\t}\n\t}\n\tif(!p){\n\t\tbreak;\n\t}\n\t}\n\tprintf(\"%lld\\n\",lcm[last]);\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nlong long int p[101], q[101], r[101], b[101];\nlong long int w[101];\nlong long int ans;\n\nlong long int gcd(long long int m, long long int n){\n\tif(n == 0) return m;\n\t return gcd(n, m%n);\n}\n\nlong long int lcm(long long int m, long long int n){\n\tlong long int g = gcd(m, n);\n\tm /= g;\n\tn /= g;\n\treturn g * m * n;\n}\n\nlong long int f(int x){\n\tif(w[x] != 0) return w[x];\n/*\tlong long int g = gcd(p[x], q[x]);\n\tp[x] /= g;\n\tq[x] /= g;\n\treturn w[x] = (p[x] + q[x]) * lcm(f(r[x]), f(b[x]));\n*/\n\tlong long int l = lcm(p[x] * f(r[x]), q[x] * f(b[x]));\n\treturn w[x] = l / p[x] + l / q[x];\n\n}\n\nint main(){\n\twhile(1){\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\t\tif(n == 0) break;\n\n\t\tmemset(w, 0, sizeof(w));\n\t\tw[0] = 1;\n\t\tans = 0;\n\t\tfor(int i=1; i<n+1; ++i) scanf(\"%lld %lld %lld %lld\", &p[i], &q[i], &r[i], &b[i]);\n\t\tfor(int i=1; i<n+1; ++i){\n\t\t\tw[i] = f(i);\n\t\t\tans = max(ans, w[i]);\n\t\t}\n\n\t\tprintf(\"%lld\\n\", ans);\n\n/*\t\tfor(int i=0; i<n+1; i++){\n\t\t\tprintf(\"%d %lld\\n\", i, w[i]);\n\t\t}\n*/\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_N 100\ntypedef long long ll;\n\nvector<ll> p, q, r, b;\n\nbool dfs(int v, ll val)\n{\n  if (val == 0) {\n    if (r[v] != -1 || b[v] != -1) {\n      return 0;\n    }\n    return 1;\n  }\n  ll l = p[v] + q[v];\n  if (val * p[v] % l != 0) {\n    return 0;\n  }\n  if (val * q[v] % l != 0) {\n    return 0;\n  }\n  bool can = 1;\n  if (r[v] >= 0) {\n    can &= dfs(r[v], val*p[v]/l); \n  }\n  if (b[v] >= 0) {\n    can &= dfs(b[v], val*q[v]/l); \n  }\n  return can;\n}\n\nvoid init(int N)\n{\n  p.clear(); q.clear();\n  r.clear(); b.clear();\n  p.resize(N); q.resize(N);\n  r.resize(N); b.resize(N);\n}\n\nint main()\n{\n  int N;\n  while (cin >> N, N) {\n    init(N);\n    bool used[MAX_N] = {};\n    for (int i = 0; i < N; i++) {\n      cin >> p[i] >> q[i] >> r[i] >> b[i];\n      r[i]--; b[i]--;\n      if (r[i] >= 0) used[r[i]] = 1;\n      if (b[i] >= 0) used[b[i]] = 1;\n      int gcd = __gcd(p[i], q[i]);\n      // p[i] /= gcd;\n      //q[i] /= gcd;\n    }\n    int par = -1;\n    for (int i = 0; i < N; i++) {\n      if (!used[i]) {\n\tpar = i;\n\tbreak;\n      }\n    }\n    \n    for (int i = 1; i <= 1000000; i++) {\n      if (dfs(par, i)) {\n\tcout << i << endl;\n\tbreak;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nll gcd(ll a, ll b) {\n  return b != 0 ? gcd(b, a % b) : a;\n}\n\nconst ll WEIGHT=-1;\nstruct stick{\n\tll r,b,p,q;\n\tstick(ll r,ll b,ll p,ll q):r(r),b(b){\n\t\tll g=gcd(p,q);\n\t\tthis->p=p/g;\n\t\tthis->q=q/g;\n\t}\n\tll getroot(ll index,vector<stick> &sticks){\n\t\tREP(i,sticks.size()){\n\t\t\tif(sticks[i].r==index||sticks[i].b==index){\n\t\t\t\treturn sticks[i].getroot(i,sticks);\n\t\t\t}\n\t\t}\n\t\treturn index;\n\t}\n\tint go(vector<stick> &sticks){\n\t\tll rw=0,bw=0;\n\t\tif(r!=WEIGHT){\n\t\t\trw=sticks[r].go(sticks);\n\t\t}\n\t\tif(b!=WEIGHT){\n\t\t\tbw=sticks[b].go(sticks);\n\t\t}\n\t\tif(r==WEIGHT&&b==WEIGHT){\n\t\t\trw=q;\n\t\t\tbw=p;\n\t\t}else if(r==WEIGHT){\n\t\t\tif(p*bw%q){\n\t\t\t\trw=bw*p;\n\t\t\t\tbw*=q;\n\t\t\t}else{\n\t\t\t\trw=bw*p/q;\n\t\t\t}\n\t\t}else if(b==WEIGHT){\n\t\t\tif(q*rw%p){\n\t\t\t\tbw=rw*q;\n\t\t\t\trw*=p;\n\t\t\t}else{\n\t\t\t\tbw=rw*q/p;\n\t\t\t}\n\t\t}else{\n\t\t\tll trw=rw,tbw=bw;\n\t\t\tll gr=gcd(rw,q);\n\t\t\tll gb=gcd(bw,p);\n\t\t\trw=trw*tbw*q/gr;\n\t\t\tbw=tbw*trw*p/gb;\n\t\t}\n\t\tassert(rw&&bw);\n\t\treturn rw+bw;\n\t}\n};\n\n\nint main(){\n\tll n;\n\twhile(cin>>n,n){\n\t\tvector<stick> sticks;\n\t\tREP(i,n){\n\t\t\tll p,q,r,b;\n\t\t\tcin>>p>>q>>r>>b;\n\t\t\tr--;b--;\n\t\t\tsticks.push_back(stick(r,b,p,q));\n\t\t}\n\t\tll root=sticks[0].getroot(0,sticks);\n\t\tcout<<sticks[root].go(sticks)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i = (a); i < (b); i++)\n#define REP(i,n) FOR(i,0,n)\n\ntypedef long long ll;\n\nstruct Node {\n\tint a, b, ma, mb;\n\t\n\tNode() {}\n\tNode(int a, int b, int ma, int mb) : a(a), b(b), ma(ma), mb(mb) {}\n};\n\nint n;\nNode node[100];\nbool istop[100];\n\nint gcd(int a, int b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a % b);\n}\n\nll dfs(int pos) {\n\tNode &now = node[pos];\n\t\n\tll a = now.a, b = now.b, ma = now.ma, mb = now.mb;\n\t\n\tif (ma != 0) ma = dfs(ma - 1);\n\tif (mb != 0) mb = dfs(mb - 1);\n\t\n\tif (ma == 0 && mb == 0) {\n\t\treturn a + b;\n\t\n\t} else if (ma == 0 || mb == 0) {\n\t\tif (ma == 0) swap(ma, mb);\n\t\treturn ma * (a + b);\n\t\t\n\t}\n\telse {\n\t\tint x = gcd(a * ma, b * mb);\n\t\tll res1 = mb * (a * ma / x);\n\t\tll res2 = ma * (b * mb / x);\n\t\treturn res1 + res2;\n\t}\n}\n\nint main() {\n\twhile (cin >> n, n) {\n\t\t\n\t\tfill(istop, istop + n, false);\n\t\tREP(i, n) {\n\t\t\tint a, b, ma, mb;\n\t\t\tscanf(\"%d %d %d %d\", &a, &b, &ma, &mb);\n\t\t\tint g = gcd(a, b);\n\t\t\ta /= g; b /= g;\n\t\t\tnode[i] = Node(a, b, ma, mb);\n\t\t\t\n\t\t\tif (ma != 0) istop[ma - 1] = true;\n\t\t\tif (mb != 0) istop[mb - 1] = true;\n\t\t}\n\t\t\n\t\tint st = 0;\n\t\twhile (istop[st]) st++;\n\t\tcout << dfs(st) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint gcd(unsigned long a,unsigned long b){\n\tunsigned long c;\n\twhile(b!=0){\n\t\tc=a%b;\n\t\ta=b;\n\t\tb=c;\n\t}\n\treturn a;\n}\n\nunsigned long p[101]={};\nunsigned long q[101]={};\nint r[101]={};\nint b[101]={};\nunsigned long long w[101]={};\n\nint det_w(int i){\n\tif(w[r[i]]==0){\n\t\tdet_w(r[i]);\n\t}\n\tif(w[b[i]]==0){\n\t\tdet_w(b[i]);\n\t}\n\tw[i]=w[r[i]]*w[b[i]]*(p[i]+q[i])/gcd(w[r[i]]*p[i],w[b[i]]*q[i]);\n\treturn 0;\n}\n\t\nint main() {\n\tint n;\n\tint m[101]={};\n\twhile(1){\n\t\tcin >> n;\n\t\tif(n==0){return 0;}\n\t\tw[0]=1;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tm[i]=0;\n\t\t}\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tcin >> p[i] >> q[i] >> r[i] >> b[i];\n\t\t\tw[i]=0;\n\t\t\tm[r[i]]=i;\n\t\t\tm[b[i]]=i;\n\t\t}\n\t\tint i=1;\n\t\twhile(m[i]!=0){\n\t\t\ti=m[i];\n\t\t}\n\t\tint ro=i;\n\t\tdet_w(ro);\n\t\tcout << w[ro] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nlong long gcd(long long a, long long b){ // Ååöñ\n    if(a == 0 || b == 0)\n        return 0;\n    if(b > a)\n        swap(a, b);\n    long long tmp;\n    while((tmp = a % b) != 0){\n        a = b;\n        b = tmp;\n    }\n    return b;\n}\n\nlong long lcm(long long a, long long b){ // Å¬ö{\n    return a / gcd(a, b) * b;\n}\n\nlong long solve(vector<vector<int> >& stick, int i)\n{\n    if(i == 0)\n        return 1;\n\n    long long p = stick[i][0];\n    long long q = stick[i][1];\n    long long tmp = gcd(p, q);\n    p /= tmp;\n    q /= tmp;\n\n    long long a = solve(stick, stick[i][2]);\n    long long b = solve(stick, stick[i][3]);\n    tmp = lcm(q*a, p*b);\n    long long x = tmp / (q*a);\n    long long y = tmp / (p*b);\n\n    return a*x + b*y;\n}\n\nint main()\n{\n    for(;;){\n        int n;\n        cin >> n;\n        if(n == 0)\n            return 0;\n\n        vector<vector<int> > stick(n+1, vector<int>(4));\n        vector<bool> check(n+1, false);\n        for(int i=1; i<=n; ++i){\n            for(int j=0; j<4; ++j){\n                cin >> stick[i][j];\n            }\n            check[stick[i][2]] = check[stick[i][3]] = true;\n        }\n\n        long long ret = 0;\n        for(int i=1; i<=n; ++i){\n            if(!check[i])\n                ret += solve(stick, i);\n        }\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint n;\nint a[100][2],p[100][2];\nbool cal[100];\nint GCD(int x,int y){\n\twhile(true){\n\t\tif(y>x){int t=x;x=y,y=t;}\n\t\tx%=y;\n\t\tif(x<2==!y)break;\n\t}\n\treturn y;\n}\nint DFS(int x){\n\tif(!x)return 1;\n\tcout<<x<<endl;\n\tx--;\n\tint b=DFS(p[x][0]),c=DFS(p[x][1]);\n\tint s=b*a[x][0]*c*a[x][1]/GCD(b*a[x][1],c*a[x][0]);\n\treturn s/a[x][0]+s/a[x][1];\n}\nint main(){\n\twhile(true){\n\tcin>>n;\n\tif(!n)break;\n\tfor(int i=0;i<n;i++)cal[i]=true;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>a[i][0]>>a[i][1];\n\t\tint t=GCD(a[i][0],a[i][1]);\n\t\ta[i][0]/=t,a[i][1]/=t;\n\t\tcin>>p[i][0]>>p[i][1];\n\t\tcal[p[i][0]-1]=false,cal[p[i][1]-1]=false;\n\t}\n\tfor(int i=0;i<n;i++)if(cal[i])cout<<DFS(i+1)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nlong long int gcd(const long long int a, const long long int b) {\n\tswitch (a % b) {\n\tcase 0: return b;\n\tdefault: return gcd(b, a % b);\n\t}\n}\nlong long int lcd(const long long int a, const long long int b) {\n\treturn a * b / gcd(a, b);\n}\nclass Mobile {\n\tlong long int _left_length{ 0 }, _right_length{ 0 };\n\tMobile *_left_mobile{ nullptr }, *_right_mobile{ nullptr };\n\tlong long int _whole_weight{ 0 };\n\tbool is_balanced() {\n\t\treturn _whole_weight != 0;\n\t}\n\tvoid balance() {\n\t\tif (is_balanced()) return;\n\t\tlong long int l;\n\t\tif (_left_mobile == nullptr && _right_mobile == nullptr) {\n\t\t\tl = lcd(_left_length, _right_length);\n\t\t}\n\t\telse if (_left_mobile == nullptr) {\n\t\t\t_right_mobile->balance();\n\t\t\tl = lcd(_left_length, _right_length * _right_mobile->_whole_weight);\n\t\t}\n\t\telse if (_right_mobile == nullptr) {\n\t\t\t_left_mobile->balance();\n\t\t\tl = lcd(_right_length, _left_length * _left_mobile->_whole_weight);\n\t\t}\n\t\telse {\n\t\t\t_left_mobile->balance();\n\t\t\t_right_mobile->balance();\n\t\t\tl = lcd(_right_mobile->_whole_weight * _right_length, _left_mobile->_whole_weight * _left_length);\n\t\t}\n\t\t_whole_weight = l / _left_length + l / _right_length;\n\t}\npublic:\n\tMobile() {}\n\tvoid set_infomation(long long int left, long long int right, Mobile *left_mobile, Mobile *right_mobile) {\n\t\t_left_length = left / gcd(left, right);\n\t\t_right_length = right / gcd(left, right);\n\t\t_left_mobile = left_mobile;\n\t\t_right_mobile = right_mobile;\n\t}\n\tlong long int whole_weight() {\n\t\tif (!is_balanced()) balance();\n\t\treturn _whole_weight;\n\t}\n};\nvoid solve() {\n\tint n;\n\tstd::cin >> n;\n\twhile (n != 0) {\n\t\tstd::vector<Mobile> mobiles(n);\n\t\t{\n\t\t\tint p, q, r, b;\n\t\t\tfor (auto &mobile : mobiles) {\n\t\t\t\tstd::cin >> p >> q >> r >> b;\n\t\t\t\tmobile.set_infomation(p, q, (r == 0) ? nullptr : &mobiles[r - 1], (b == 0) ? nullptr : &mobiles[b - 1]);\n\t\t\t}\n\t\t\tlong long int max{ 0 };\n\t\t\tfor (auto &mobile : mobiles) if (max < mobile.whole_weight()) max = mobile.whole_weight();\n\t\t\tstd::cout << max << std::endl;\n\t\t}\n\t\tstd::cin >> n;\n\t}\n}\nint main() {\n\tsolve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n\ntemplate <class T>\nint __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\nint gcd(int a, int b)\n{\n\tif (a < b)\n\t\tswap(a, b);\n\tif (b == 0)\n\t\treturn a;\n\treturn gcd(b, a%b);\n}\nint lcm(int a, int b)\n{\n\treturn a/gcd(a, b) * b;\n}\nint p[101], q[101], r[101], b[101];\nint dfs(int s)\n{\n\tif (s == 0)\n\t\treturn 1;\n\n\tint red = dfs(r[s]), blue = dfs(b[s]);\n\tint t = lcm(red*q[s], blue*p[s]);\n\treturn t/p[s] + t/q[s];\n}\nint main()\n{\n\tint n;\n\twhile (~scanf(\"%d\", &n) && n)\n\t{\n\t\tbool root[101];\n\t\tfill(root, root+101, true);\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t{\n\t\t\tscanf(\"%d%d%d%d\", p+i, q+i, r+i, b+i);\n\t\t\troot[r[i]] = root[b[i]] = false;\n\t\t}\n\n\t\tint res = 0;\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t\tif (root[i])\n\t\t\t\tres = dfs(i);\n\t\tprintf(\"%d\\n\", res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\n#define REP(i,a,b) for(i=a; i<b; ++i)\n#define rep(i,n) REP(i,0,n)\n\nstruct mobile {\n  long long lm,rm;\n  long long lc,rc,ll,rl;\n  mobile(long long lc,long long rc,long long ll,long long rl)\n  : lc(lc), rc(rc), ll(ll), rl(rl) {\n    lm = rm = -1;\n  }\n};\n\nint gcd(int a,int b) {\n  return b != 0 ? gcd(b, a%b) : a;\n}\n\nlong long lcm(long long a,long long b) {\n  return a/gcd(a,b)*b;\n}\n\nint dfs(int pos,vector<mobile> &vm) {\n  mobile now = vm[pos];\n  now.lm = (now.lc == -1) ? 1 : dfs(now.lc,vm);\n  now.rm = (now.rc == -1) ? 1 : dfs(now.rc,vm);\n  int g = lcm(now.ll*now.lm, now.rl*now.rm);\n  now.rm = g / now.rl;\n  now.lm = g / now.ll;\n  return now.rm+now.lm;\n}\n\nint main() {\n  int n,i,p,q,r,b,root;\n  while(cin>>n, n) {\n    vector<mobile> vm;\n    vector<bool> isroot(n+1,true);\n    root = -1;\n    rep(i,n) {\n      cin>>p>>q>>r>>b;\n      r--,b--;\n      if(r >= 0) isroot[r] = false;\n      if(b >= 0) isroot[b] = false;\n      vm.push_back(mobile(r,b,p,q));\n    }\n\n    rep(i,n) if(isroot[i] == true) root = i;\n    cout<<dfs(root,vm)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cstdio>\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> P;\ntypedef pair<LL, LL> PLL;\n\nLL gcd(LL x, LL y) {\n    if (x < y) { swap(x, y); }\n    if (y == 0) { return x; }\n    return gcd(y, x % y);\n}\n\nstruct mobile {\n    int lb;\n    int rb;\n    LL lm;\n    LL rm;\n};\n\nint N;\nmobile ms[110];\n\nint get_root() {\n    for (int j = 0; j < N; ++j) {\n        bool found = false;\n        for (int k = 0; k < N; ++k) {\n            if (ms[k].lm == j || ms[k].rm == j) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            return j;\n        }\n    }\n    return -1;\n}\n\nLL rec(int x) {\n    mobile& m = ms[x];\n\n    LL t = gcd(m.lb, m.rb);\n\n    if (m.lm == -1 && m.rm == -1) {\n        return (m.lb + m.rb) / t;\n    }\n\n    LL lw, rw;\n    if (m.lm != -1 && m.rm == -1) {\n        lw = rec(m.lm) * (m.rb / t);\n        rw = (lw * m.lb) / m.rb;\n    } else if (m.lm == -1 && m.rm != -1) {\n        rw = rec(m.rm) * (m.lb / t);\n        lw = (rw * m.rb) / m.lb;\n    } else {\n        lw = rec(m.lm) * (m.rb / t);\n        rw = rec(m.rm) * (m.lb / t);\n        int u = gcd(lw * m.lb, rw * m.rb);\n        int tmp = lw;\n        lw *= (rw * m.rb) / u;\n        rw *= (tmp * m.lb) / u;\n    }\n\n    return lw + rw;\n}\n\nbool solve() {\n\n    cin >> N;\n    if (N == 0) {\n        return false;\n    }\n    for (int j = 0; j < N; ++j) {\n        cin >> ms[j].lb >> ms[j].rb >> ms[j].lm >> ms[j].rm;\n        --ms[j].lm; --ms[j].rm;\n    }\n\n    int root = get_root();\n\n    cout << rec(root) << endl;\n\n    return true;\n}\n\nint main() {\n    while(solve());\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint x[100][2],w[100][2],n;\nbool cal[110];\nint COU(int a,int b){\n\twhile(true){\n\t\tif(a<2||b<2)return 1;\n\t\tif(a<b){int t=a;a=b,b=t;}\n\t\ta%=b;\n\t\tif(!a)return b;\n\t}\n}\nlong long DFS(int q){\n\tif(!q)return 1;\n\tq--;\n\tlong long a=DFS(w[q][0]),b=DFS(w[q][1]);\n\treturn (a*b*(x[q][0]+x[q][1]))/COU(a*x[q][0],b*x[q][1]);\n}\nint main(){\n\twhile(true){\n\t\tcin>>n;\n\t\tif(!n)break\n\t\tfor(int i=0;i<n;i++)cal[i]=false;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>x[i][0]>>x[i][1]>>w[i][0]>>w[i][1];\n\t\t\tcal[w[i][0]-1]=true,cal[w[i][1]-1]=true;\n\t\t}\n\t\tfor(int i=0;i<n;i++)if(!cal[i])cout<<DFS(i+1)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<fstream>\n#include<string>\nusing namespace std;\n\nstruct tBar{\n\tunsigned int rdis, bdis, r, b;\n\tunsigned int w;\n};\ntBar bar[101];\nint N;\n\nunsigned int euclid( int a, int b ){\n\twhile( a != b ){\n\t\tif( a>b )\ta -= b;\n\t\telse\t\tb -= a;\n\t}\n\treturn a;\n}\n\nunsigned int calcWeight( int n ){\n\ttBar &bn = bar[n];\n\tunsigned int rw=0, bw=0;\n\tif( bn.r==0 && bn.b==0 ){\n\t\trw = bn.bdis;\n\t\tbw = bn.rdis;\n\t}else if( bn.r!=0 && bn.b==0 ){\n\t\t\trw = calcWeight( bn.r );\n\t\t\tbw = bn.rdis * rw / bn.bdis;\n\t}else if( bn.r==0 && bn.b!=0 ){\n\t\t\tbw = calcWeight( bn.b );\n\t\t\trw = bn.bdis * bw / bn.rdis;\n\t}else{\n\t\trw = calcWeight( bn.r );\n\t\tbw = calcWeight( bn.b );\n\t}\n\t\n\twhile( rw*bn.rdis != bw*bn.bdis ){\n\t\tif( rw*bn.rdis > bw*bn.bdis ){\n\t\t\tbw += bn.b==0 ? bn.rdis : bar[bn.b].w;\n\t\t}else{\n\t\t\trw += bn.r==0 ? bn.bdis : bar[bn.r].w;\n\t\t}\n\t}\n\tbn.w = rw+bw;\n\treturn bn.w;\n}\n\nint findRoot( int n ){\n\tfor( int i=1; i<=N; i++ ){\n\t\tif( bar[i].r==n || bar[i].b==n ){\n\t\t\tn = i;\n\t\t\ti = 0;\n\t\t}\n\t}\n\treturn n;\n}\n\nint main(){\n\tint n;\n\tstring str;\n//\tifstream in(\"input.txt\");\n//\tofstream out(\"output.txt\");\n\twhile(1){\n\t\tgetline( cin, str );\n\t\tsscanf( str.c_str(), \"%d\", &n );\n\t\tif( n == 0 )\tbreak;\n\t\tN = n;\n\t\tfor( int i=1; i<=n; i++ ){\n\t\t\tgetline( cin, str );\n\t\t\tint p,q,r,b;\n\t\t\tsscanf(str.c_str(), \"%d %d %d %d\", &p, &q, &r, &b);\n\t\t\tint e = euclid( p, q );\n\t\t\tbar[i].rdis = p / e;\n\t\t\tbar[i].bdis = q / e;\n\t\t\tbar[i].r = r;\n\t\t\tbar[i].b = b;\n\t\t\tbar[i].w = 0;\n\t\t}\n\t\tint root = findRoot(1);\n\t\tint sum = calcWeight(root);\n//\t\tout << sum << endl;\n\t\tcout << sum << endl;\n\t}\n//\tin.close();\n//\tout.close();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <list>\n#include <stdio.h>\n#include <string.h>\n#include <cstdlib>\n#include <math.h>\n#include <bitset>\n#include <iterator>\n#include <iomanip>\n#include <sstream>\n#include <numeric>\n#include <cassert>\nusing namespace std;\nint dx[5]={1,0,-1,0,0},dy[5]={0,1,0,-1,0};\nlong long gcd(long long a,long long b){if(a%b==0){return b;}else return gcd(b,a%b);}\nlong long lcm(long long a,long long b){if(a==0){return b;} return a/gcd(a,b)*b;}\n#define INF 2000000000\n#define MOD 1000000007\n#define sym cout<<\"---------\"<<endl;\n#define ll long long\n#define mk make_pair\n#define en endl\n#define RE return 0\n#define int ll\n#define P pair<int,int>\n\n#define MAX 105\n\nint called[MAX];\nsigned main(){\n\tvector<int> ve;\n\tint n;\n\twhile(cin>>n&&n){\n\t\tve.clear();\n\t\tmemset(called, 0, sizeof(called));\n\t\tP ratio[MAX];\n\t\tP have[MAX];\n\t\tfor(int i=1; i<=n; i++){\n\t\t\tint a,b,c,d; cin>>a>>b>>c>>d;\n\t\t\tcalled[c]=called[d]=1;\n\t\t\tratio[i].first=a; ratio[i].second=b;\n\t\t\thave[i].first=c; have[i].second=d;\n\t\t}\n\t\tint root;\n\t\tfor(int i=1; i<=n; i++) if(called[i]==0) root=i;\n\t\tstack<P> sta;\n\t\tsta.push(mk(root,1));\n\t\twhile(!sta.empty()){\n\t\t\tint now=sta.top().first,num=sta.top().second;\n\t\t\tsta.pop();\n\t\t\tint r=ratio[now].second/gcd(ratio[now].first, ratio[now].second)+ratio[now].first/gcd(ratio[now].first, ratio[now].second);\n\t\t\tif(have[now].first==0&&have[now].second==0){ \n\t\t\t\tve.push_back(r*num);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(have[now].first) sta.push(mk(have[now].first,r*num));\n\t\t\tif(have[now].second) sta.push(mk(have[now].second,r*num));\n\t\t}\n\t\twhile(ve.size()>1){\n\t\t\tint t=ve[ve.size()-1]; ve.pop_back();\n\t\t\tint tt=ve[ve.size()-1]; ve.pop_back();\n\t\t\tve.push_back(lcm(t, tt));\n\t\t}\n\t\tcout<<ve[0]<<en;\n\t}\n}\n\t\n\t\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\ntypedef long long ll;\n\nll n, p[100], q[100], r[100], b[100];\nbool isTop[100];\n\nll gcd(ll a, ll b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\n\nll check(ll num) {\n  ll left = 1, right = 1;\n  if (r[num] != -1) left = check(r[num]);\n  if (b[num] != -1) right = check(b[num]);\n  ll g = gcd(p[num], q[num]);\n  p[num] /= g;\n  q[num] /= g;\n  ll g1 = gcd(p[num], right);\n  ll g2 = gcd(q[num], left);\n  ll temp = left * right / gcd(left, right);\n  return (p[num] + q[num]) * temp / (g1 * g2);\n}\n\nint main() {\n  while (1) {\n    scanf(\"%lld\", &n);\n    if (n == 0) break;\n    for (ll i = 0; i < n; i++) isTop[i] = true;\n    for (ll i = 0; i < n; i++) {\n      scanf(\"%lld%lld%lld%lld\", &p[i], &q[i], &r[i], &b[i]);\n      r[i]--, b[i]--;\n      if (r[i] != -1) isTop[r[i]] = false;\n      if (b[i] != -1) isTop[b[i]] = false;\n    }\n    ll top;\n    for (ll i = 0; i < n; i++) if (isTop[i]) { top = i; break; }\n    printf(\"%lld\\n\", check(top));\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//???????????¢????????§?????°????????¢?????????????§????\n//??????????????¨?????¢????????????????????????????°??????¢?????????????§???????????????????????????¨???????????????\n//???2 3??§?????£??????????????????????????????4 6??§?????£?????????????????????????????????????????´?????????\n//???????????????????????¨??????????????????????§??????????????????\\?????¨????????????\n//?§£?±??????????????????¢?????????????????? = ????°??????¢????????? * ??´??°(>=1)???\n//??????????????§?????£????????????????????§?????????????????????????¢?????????????????????????\n\n#include<iostream>\n#define int long long\nusing namespace std;\n\nstruct Bou{\n\tint childl;\n\tint childr;\n\tint lengthl;\n\tint lengthr;\n\t\n\tvoid setBou( int p, int q, int r, int s ){\n\t\tlengthl = p;\n\t\tlengthr = q;\n\t\tchildl = r;\n\t\tchildr = s;\n\t}\n}bou[101];\n\nint gcd( int a, int b ){\n\treturn ((b > 0) ? gcd( b, a % b ) : a);\n}\nint lcm( int a, int b ){\n\treturn a * b / gcd(a, b);\n}\n\nint dfs( int ind ){\n\t//?????????\n\tif( ind == 0 ){\n\t\treturn 1;\n\t}\n\t//???\n\tint lw = dfs(bou[ind].childl);\n\t//???\n\tint rw = dfs(bou[ind].childr);\n\t\n\tint moment = lcm(lw * bou[ind].lengthl, rw * bou[ind].lengthr);\n\tint ret = moment / bou[ind].lengthr + moment / bou[ind].lengthl;\n\treturn ret;\n}\n\nsigned main()\n{\n\tint n;\n\tbool isRoot[101];\n\t\n\twhile( cin >> n ){\n\t\tif( !n ) break;\n\t\tfor( int i = 1; i <= n; i++ ){ isRoot[i] = true; }\n\t\t\n\t\tfor( int i = 0; i < n; i++ ){\n\t\t\tint p, q, r, s;\n\t\t\tcin >> p >> q >> r >> s;\n\t\t\tbou[i+1].setBou(p, q, r, s);\n\t\t\tisRoot[r] = (isRoot[s] = false);\n\t\t}\n\t\t\n\t\tfor( int i = 1; i <= n; i++ ){\n\t\t\tif( isRoot[i] ){\n\t\t\t\tcout << dfs(i) << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n\nconstexpr int MAX_N=300;\n\nint n;\n\nstruct Node {\n\n    int par,left,right;\n\n    int p,q,m;\n\n    Node() {\n\n        par=left=right=-1;\n\n        m=1;\n    }\n\n    void set(int _p,int _q,int _l,int _r) {\n        p=_p;\n        q=_q;\n        left=_l;\n        right=_r;\n    }\n};\n\nint gcd(int x,int y) {\n\n    if(x<y)\n        std::swap(x,y);\n\n    return y==0 ? x : gcd(y,x%y);\n}\n\nint lcm(int x,int y){\n\n    int g=gcd(x,y);\n\n    return x*y/g;\n}\n\nNode nodes[MAX_N];\n\nint findRoot(int m){\n    return (nodes[m].par==-1) ? m : findRoot(nodes[m].par);\n}\n\nvoid init(int m){\n\n    if(m==-1)\n        return;\n\n    int n=1;\n\n    if(nodes[m].par!=-1)\n        n=nodes[nodes[m].par].m;\n\n    nodes[m].m=lcm(n,nodes[m].m);\n\n    init(nodes[m].left);\n    init(nodes[m].right);\n}\n\nint solve(int m) {\n\n    int l,r;\n\n    int p=nodes[m].p,q=nodes[m].q;\n\n    if(nodes[m].left==-1)\n        l=lcm(nodes[m].m,q);\n    else\n        l=solve(nodes[m].left);\n\n    if(nodes[m].right==-1)\n        r=lcm(nodes[m].m,p);\n    else\n        r=solve(nodes[m].right);\n\n    int tmp=lcm(l*p,r*q);\n\n    int res=tmp/p+tmp/q;\n\n    return res;\n}\n\nint main() {\n\n    while(std::cin>>n,n){\n\n        int p,q,l,r;\n\n        for(int i=0;i<n;++i)\n            nodes[i]=Node();\n\n        for(int i=0;i<n;++i){\n            std::cin>>p>>q>>l>>r;\n            --l;\n            --r;\n            int g=gcd(p,q);\n            p/=g;\n            q/=g;\n            nodes[i].set(p,q,l,r);\n            if(l!=-1){\n                nodes[l].par=i;\n                nodes[l].m=q;    \n            }\n            if(r!=-1){\n                nodes[r].par=i;\n                nodes[r].m=p;\n            }\n        }\n\n        int root=findRoot(0);\n\n        init(root);\n\n        int ans=solve(root);\n\n        std::cout<<ans<<std::endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nlong long gcd(long long a, long long b){ // Ååöñ\n    if(a == 0 || b == 0)\n        return 0;\n    if(b > a)\n        swap(a, b);\n    long long tmp;\n    while((tmp = a % b) != 0){\n        a = b;\n        b = tmp;\n    }\n    return b;\n}\n\nlong long lcm(long long a, long long b){ // Å¬ö{\n    return a / gcd(a, b) * b;\n}\n\nlong long solve(vector<vector<int> >& stick, int i)\n{\n    if(i == 0)\n        return 1;\n\n    long long p = stick[i][0];\n    long long q = stick[i][1];\n\n    long long a = solve(stick, stick[i][2]);\n    long long b = solve(stick, stick[i][3]);\n    long long tmp = lcm(p*a, q*b);\n    a = tmp / p;\n    b = tmp / q;\n\n    return a + b;\n}\n\nint main()\n{\n    for(;;){\n        int n;\n        cin >> n;\n        if(n == 0)\n            return 0;\n\n        vector<vector<int> > stick(n+1, vector<int>(4));\n        vector<bool> check(n+1, false);\n        for(int i=1; i<=n; ++i){\n            for(int j=0; j<4; ++j){\n                cin >> stick[i][j];\n            }\n            check[stick[i][2]] = check[stick[i][3]] = true;\n        }\n\n        long long ret = 0;\n        for(int i=1; i<=n; ++i){\n            if(!check[i])\n                ret += solve(stick, i);\n        }\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef double db;\n\n#define fr first\n#define sc second\n#define pb push_back\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define rep1(i,x) for(ll i=1;i<=x;i++)\n#define rrep(i,x) for(ll i=x-1;i>=0;i--)\n#define rrep1(i,x) for(ll i=x;i>0;i--)\n\nll n;\nll bar[101][4];\n\nll gcd(ll a,ll b){\n\tif(b==0) return a;\n\treturn gcd(b,a%b);\n}\nll dp[101];\nll rec(ll x){\n\tif(dp[x]) return dp[x];\n\tll lef=1,rig=1;\n\tif(bar[x][2]!=0) lef=rec(bar[x][2]);\n\tif(bar[x][3]!=0) rig=rec(bar[x][3]);\n\tll div=gcd(bar[x][0],bar[x][1]);\n\tbar[x][0]/=div;\n\tbar[x][1]/=div;\n\tdiv=gcd(lef,rig);\n\tll a=bar[x][1]*(rig/div);\n\tll b=bar[x][0]*(lef/div);\n\tdiv=gcd(a,b);\n\ta/=div;\n\tb/=div;\n\treturn dp[x]=a*lef+b*rig;\n}\n\nint main()\n{while(1){\n\tmemset(dp,0,sizeof(dp));\n\tll ans=0;\n\tcin>>n;\n\tif(!n) return 0;\n\trep1(i,n){\n\t\trep(j,4) cin>>bar[i][j];\n\t}\n\trep1(i,n){\n\t\tans=max(ans,rec(i));\n\t}\n\tcout<<ans<<endl;\n}}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N;\nint p[100],q[100],r[100],b[100];\n\nint gcd(int x,int y){\n    return y?gcd(y,x%y):x;\n}\nint lcm(int x,int y){\n    return x/gcd(x,y)*y;\n}\n\nint dfs(int pos){\n    if(!~pos)return 1;\n    int x=dfs(r[pos])*p[pos],y=dfs(b[pos])*q[pos];\n    int l=lcm(x,y);\n    return l/p[pos]+l/q[pos];\n}\n\nvoid solve(){\n    int D[100]={0};\n    for(int i=0;i<N;i++){\n        scanf(\"%d%d%d%d\",&p[i],&q[i],&r[i],&b[i]);\n        r[i]--;b[i]--;\n        if(~r[i])D[r[i]]++;\n        if(~b[i])D[b[i]]++;\n    }\n\n    for(int i=0;i<N;i++){\n        if(!D[i]){\n            printf(\"%d\\n\",dfs(i));\n            return;\n        }\n    }\n\n}\n\nint main(){\n    while(scanf(\"%d\",&N),N)solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint GCD(int a,int b){\n    if(b>a)swap(a,b);\n    return (b==0)?a:GCD(b,a%b);\n}\nint LCM(int a,int b){\n    return a/GCD(a,b)*b;\n}\nint l[101],r[101],w1[101],w2[101];\nint memo[101];\nint dfs(int x){\n    if(x==0)return 1;\n    if(memo[x]!=-1)return memo[x];\n    int red=l[x]*dfs(w1[x]);\n    int blue=r[x]*dfs(w2[x]);\n    int lcm=LCM(red,blue);\n    return memo[x]=lcm/l[x]+lcm/r[x];\n}\nint main(){\n    int n;\n    while(scanf(\"%d\",&n),n){\n        bool flag[101];fill(flag,flag+n+1,true);\n        fill(memo,memo+n+1,-1);\n        for(int i=1;i<=n;i++){\n            scanf(\"%d%d%d%d\",&l[i],&r[i],&w1[i],&w2[i]);\n            flag[w1[i]]=flag[w2[i]]=false;\n        }\n        for(int i=1;i<=n;i++){\n            if(flag[i]){\n                printf(\"%d\\n\",dfs(i));\n                break;\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint poles[101][4];\n\nint gcd(int a, int b)\n{\n  return b == 0 ? a : gcd(b, a % b);\n}\n\nint lcm(int a, int b)\n{\n  return a / gcd(a, b) * b;\n}\n\nint dfs(int n)\n{\n  int a = 1, b = 1;\n  if(poles[n][2])\n    a = dfs(poles[n][2]);\n  if(poles[n][3])\n    b = dfs(poles[n][3]);\n  int l = lcm(poles[n][0] * a, poles[n][1] * b);\n  return l / poles[n][0] + l / poles[n][1];\n}\n\n\nbool notRoot[101];\nint main()\n{\nloop:\n  fill(notRoot, notRoot + 101, false);\n  int n;\n  cin >> n;\n  if(!n)\n    return 0;\n\n  for(int i = 1; i <= n; i++)\n  {\n    cin >> poles[i][0] >> poles[i][1] >> poles[i][2] >> poles[i][3];\n    notRoot[poles[i][2]] = notRoot[poles[i][3]] = true;\n  }\n  for(int i = 1; i <= n; i++)\n  {\n    if(!notRoot[i])\n    {\n      cout << dfs(i) << endl;\n      goto loop;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<n;++i)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 102;\n\nbool flag[MAX_N];\nP rt[MAX_N];\nP ch[MAX_N];\nint pr[MAX_N];\nint n;\n\nll gcd(ll a,ll b)\n{\n\tif(b==0LL){\n\t\treturn a;\n\t}\n\treturn gcd(b,a%b);\n}\n\nll mobile(int a,int b,ll c,ll d)\n{\n\tll res = gcd(a*c,b*d);\n\treturn b*c*d/res+a*c*d/res;\n}\t\n\nll dfs(int u)\n{\n\tif(ch[u].first==-1&&ch[u].second==-1){\n\t\treturn mobile(rt[u].first,rt[u].second,1LL,1LL);\n\t}else if(ch[u].first == -1){\n\t\treturn mobile(rt[u].first,rt[u].second,1LL,dfs(ch[u].second));\n\t}else if(ch[u].second == -1){\n\t\treturn mobile(rt[u].first,rt[u].second,dfs(ch[u].first),1LL);\n\t}else{\n\t\treturn mobile(rt[u].first,rt[u].second,dfs(ch[u].first),dfs(ch[u].second));\n\t}\n}\nint main()\n{\n\twhile(1){\n\tscanf(\"%d\",&n);\n\tif(n==0){\n\t\tbreak;\n\t}\n\tfill(pr,pr+n,-1);\n\trep(i,n){\n\t\tscanf(\"%d%d%d%d\",&rt[i].first,&rt[i].second,&ch[i].first,&ch[i].second);\n\t\tch[i].first--,ch[i].second--;\n\t\tif(ch[i].first != -1){\n\t\t\tpr[ch[i].first] = i;\n\t\t}\n\t\tif(ch[i].second != -1){\n\t\t\tpr[ch[i].second] = i;\n\t\t}\n\t}\n\tint id=0;\n\twhile(pr[id]!=-1){\n\t\tid = pr[id];\n\t}\n\tll ans = dfs(id);\n\tprintf(\"%lld\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nint gcd(int a, int b) {\n\tif (!b)return a;\n\treturn gcd(b, a%b);\n}\nint lcm(int a, int b) {\n\tint g = gcd(max(a, b), min(a, b));\n\treturn (a / g)*(b / g)*g;\n}\nstruct node {\n\tint p, q, left, right, parent;\n};\nint n;\nnode T[100];\nint w[100];\nvector<int>d[100];\n\nvoid bfs(int u, int i) {\n\tif (!~u)return;\n\td[i].push_back(u);\n\tbfs(T[u].left, i + 1);\n\tbfs(T[u].right, i + 1);\n}\nint main() {\n\twhile (scanf(\"%d\", &n), n) {\n\t\trep(i, n)d[i].clear();\n\t\trep(i, n) {\n\t\t\tint p, q, r, b; scanf(\"%d%d%d%d\", &p, &q, &r, &b);\n\t\t\tint g = gcd(max(p, q), min(p, q));\n\t\t\tT[i] = { p / g,q / g,--r,--b,-1 };\n\t\t}\n\t\trep(i, n) {\n\t\t\tif (~T[i].left)T[T[i].left].parent = i;\n\t\t\tif (~T[i].right)T[T[i].right].parent = i;\n\t\t}\n\t\tint root;\n\t\trep(i, n) {\n\t\t\tif (!~T[i].parent)root = i;\n\t\t}\n\t\tbfs(root, 0);\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tfor (int u : d[i]) {\n\t\t\t\tif (!~T[u].left && !~T[u].right)w[u] = T[u].p + T[u].q;\n\t\t\t\telse if (!~T[u].left) {\n\t\t\t\t\tint e = lcm(T[u].p, w[T[u].right]);\n\t\t\t\t\tw[u] = (e / T[u].p)*(T[u].p + T[u].q);\n\t\t\t\t}\n\t\t\t\telse if (!~T[u].right) {\n\t\t\t\t\tint d = lcm(T[u].q, w[T[u].left]);\n\t\t\t\t\tw[u] = (d / T[u].q)*(T[u].p + T[u].q);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint e = lcm(T[u].q, w[T[u].left]);\n\t\t\t\t\tfor (int i = e;; i += e) {\n\t\t\t\t\t\tif ((i / T[u].q*T[u].p) % w[T[u].right] == 0) {\n\t\t\t\t\t\t\tw[u] = i / T[u].q*(T[u].p + T[u].q);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", w[root]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nint n;\nll red[100];\nll blue[100];\nll le[100];\nll ri[100];\n\nll gcd(ll a,ll b){\n\tif(b>a){\ta^=b;\tb^=a;\ta^=b;\t}\n\twhile(1){\n\t\tint temp=a%b;\n\t\tif(temp==0)\tbreak;\n\t\ta=b;\tb=temp;\n\t}\n\treturn b;\n}\n\nll dfs(int now){\n\tll l=1,r=1;\n\tif(le[now]!=0)\tl*=dfs(le[now]-1);\n\tif(ri[now]!=0)\tr*=dfs(ri[now]-1);\n\tll g=gcd(blue[now]*r,red[now]*l);\n\tl\n\tl ans=blue[now]*r*red[now]*l/g;\n\treturn ans/blue[now]+ans/red[now];\t\n}\n\t\nint main(){\n\twhile(true){\n\t\tcin>>n;\n\t\tif(n==0)\treturn 0;\n\t\tvector<int> parent(n,-1);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>red[i]>>blue[i]>>le[i]>>ri[i];\n\t\t\tif(le[i]!=0)\tparent[le[i]-1]=i;\t\n\t\t\tif(ri[i]!=0)\tparent[ri[i]-1]=i;\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(parent[i]==-1){\n\t\t\t\tcout<<dfs(i)<<endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <cstring>\nusing namespace std;\n\nint dp[110],K[110],O[110],L[110],R[110];\n\nint gcd(int a,int b){\n\tint tmp;\n\tif(a<b) swap(a,b);\n\twhile((tmp=a%b)!=0){\n\t\ta=b;\n\t\tb=tmp;\n\t}\n\treturn b;\n}\n\n\nint mobi(int bou){\n\tif(bou==0) return 1;\n\tif(dp[bou]!=0) return dp[bou];\n\tint l,r,li,ri,gc2,a,b;\n\tl=mobi(L[bou]);\n\tr=mobi(R[bou]);\n\tri=K[bou];li=O[bou];\n\tgc2=gcd(li*l,ri*r);\n\tif(gc2==0) while(true);//\n\tb=li*l/gc2;\n\ta=ri*r/gc2;\n\tdp[bou]=(a*l+b*r);\n\treturn dp[bou];\n}\n\nint main(){\n\tint N,k,o,g;\n\tint res;\n\twhile(1){\n\t\tcin>>N;\n\t\tif(N==0) break;\n\t\tmemset(dp,0,sizeof(dp));\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tcin>>k>>o>>L[i]>>R[i];\n\t\t\tg=gcd(k,o);\n\t\t\tK[i]=k/g;\n\t\t\tO[i]=o/g;\n\t\t}\n\t\tres=0;\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tres=max(res,mobi(i));\n\t\t}\n\t\t/*\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tcout<<i<<\" \"<<dp[i]<<endl;//\n\t\t}\n\t\t*/\n\t\tcout<<res<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\n#define\trep(i,n)\tfor(int i=0;i<n;i++)\n\nusing namespace std;\n\ntypedef\tunsigned long long\tull;\n\null gcd(ull a,ull b){ return b?gcd(b,a%b):a; }\n\nstruct Node{\n\tint p,q,l,r;\n\tNode(){}\n\tNode(int P,int Q,int L,int R):p(P),q(Q),l(L),r(R){}\n};\n\nNode node[100];\n\nint dfs(int u){\n\tif(u==-1)\treturn 1;\n\n\tint p=node[u].p,q=node[u].q,l=node[u].l,r=node[u].r;\n\tint wl=dfs(l),wr=dfs(r);\n\tint g=gcd(q*wl,p*wr);\n\tint m=p*wr/g,n=q*wl/g;\n\n\treturn m*wl+n*wr;\n}\n\nint main(){\n\tfor(int n;scanf(\"%d\",&n),n;){\t\n\t\trep(i,n){\n\t\t\tint p,q,l,r;\tscanf(\"%d%d%d%d\",&p,&q,&l,&r);\n\t\t\tint g=gcd(p,q);\n\t\t\tnode[i]=Node(p/g,q/g,l-1,r-1);\n\t\t}\n\n\t\tint root;\n\t\tbool b[100]={};\n\t\trep(i,n){\n\t\t\tif(~node[i].l)\tb[node[i].l]=true;\n\t\t\tif(~node[i].r)\tb[node[i].r]=true;\n\t\t}\n\t\trep(i,n)if(!b[i]){ root=i; break; }\n\n\t\tprintf(\"%d\\n\",dfs(root));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<list>\n#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nlong long gcd(long long p,long long q){\n  while(q){\n    p%=q;\n    swap(p,q);\n  }\n  return p;\n}\nlong long f(long long a[],long long b[],long long c[],long long d[],int p){\n  long long tm,tp;\n  if(p==0)\n    return 1;\n  tm=f(a,b,c,d,c[p]);\n  tp=f(a,b,c,d,d[p]);\n  return (a[p]+b[p])*tm*tp/gcd(tm*a[p],tp*b[p]);\n}\nint main(){\n  int i;\n  int e[101],n;\n  long long a[101],b[101],c[101],d[101];\n  while(cin>>n&&n){\n    memset(e,0,sizeof(e));\n    for(i=1;i<n+1;i++){\n      cin>>a[i]>>b[i]>>c[i]>>d[i];\n      e[c[i]]=1;\n      e[d[i]]=1;\n    }\n    for(i=0;e[i];i++);\n    cout<<f(a,b,c,d,i)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nint red[100];\nint blue[100];\nint le[100];\nint ri[100];\n\nint gcd(int a,int b){\n\tif(b>a){\ta^=b;\tb^=a;\ta^=b;\t}\n\twhile(1){\n\t\tint temp=a%b;\n\t\tif(temp==0)\tbreak;\n\t\ta=b;\tb=temp;\n\t}\n\treturn b;\n}\n\nint dfs(int now){\n\tint g=gcd(blue[now],red[now]);\tblue[now]/=g;\tred[now]/=g;\n\tint l=blue[now],r=red[now];\n\tif(le[now]!=0)\tl*=dfs(le[now]-1);\n\tif(ri[now]!=0)\tr*=dfs(ri[now]-1);\n\tif(l*red[now]<r*blue[now])\tl*=r/gcd(l,r)*blue[now]/red[now];\n\tif(l*red[now]>r*blue[now])\tr*=l/gcd(l,r)*red[now]/blue[now];\n\treturn l+r;\n}\n\t\nint main(){\n\twhile(true){\n\t\tcin>>n;\n\t\tif(n==0)\treturn 0;\n\t\tvector<int> parent(n,-1);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>red[i]>>blue[i]>>le[i]>>ri[i];\n\t\t\tif(le[i]!=0)\tparent[le[i]-1]=i;\t\n\t\t\tif(ri[i]!=0)\tparent[ri[i]-1]=i;\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(parent[i]==-1){\n\t\t\t\tcout<<dfs(i)<<endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define REP(i, a, n) for(int i = a; i < n; i++)\nusing namespace std;\n\n\nint n;\nint p[101];\nint q[101];\nint r[101];\nint b[101];\nint u[101];\nint v;\n\nint gcd(int a, int b) {\n  if(b > a) swap(a, b);\n\n  int r = a % b;\n\n  if(r == 0) return b;\n  return gcd(b, r);\n}\n\nint dfs(int i) {\n  int g = gcd(p[i], q[i]);\n  int pg = p[i] / g;\n  int qg = q[i] / g;\n\n  if(r[i] == 0 && b[i] == 0) {\n    return pg + qg;\n  }\n\n  else {\n    int rr = 0, bb = 0;\n    if(r[i] != 0) rr = dfs(r[i]);\n    if(b[i] != 0) bb = dfs(b[i]);\n\n    if(rr != 0 && bb != 0) {\n      return rr * bb / gcd(rr, bb) * (pg + qg);\n    } else if(rr != 0 && bb == 0) {\n      int k = rr * qg / gcd(bb, qg);\n      return k + k * pg / qg;\n    } else if(rr == 0 && bb != 0) {\n      int k = bb * pg / gcd(bb, pg);\n      return k + k * qg / pg;\n    }\n  }\n\n  return 0;\n}\n\nint main(void) {\n  while(cin >> n, n != 0) {\n    REP(i, 1, n + 1) u[i] = 0;\n    REP(i, 1, n + 1) {\n      cin >> p[i] >> q[i] >> r[i] >> b[i];\n      u[r[i]] = 1;\n      u[b[i]] = 1;\n    }\n    REP(i, 1, n + 1) {\n      if(u[i] == 0) {\n        v = i;\n        break;\n      }\n    }\n\n    cout << dfs(v) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <cstring>\nusing namespace std;\n\nint dp[110],K[110],O[110],L[110],R[110];\n\nint gcd(int a,int b){\n\tint tmp;\n\tif(a<b) swap(a,b);\n\twhile((tmp=a%b)!=0){\n\t\ta=b;\n\t\tb=tmp;\n\t}\n\treturn b;\n}\n\n\nint mobi(int bou){\n\tif(bou==0) return 1;\n\tif(dp[bou]!=0) return dp[bou];\n\tint l,r,li,ri,gc2,a,b;\n\tl=mobi(L[bou]);\n\tr=mobi(R[bou]);\n\tri=K[bou];li=O[bou];\n\tgc2=gcd(li*l,ri*r);\n\tb=li*l/gc2;\n\ta=ri*r/gc2;\n\tdp[bou]=(a*l+b*r);\n\twhile(true);//\n\treturn dp[bou];\n}\n\nint main(){\n\tint N,k,o,g;\n\tint res;\n\twhile(1){\n\t\tcin>>N;\n\t\tif(N==0) break;\n\t\tmemset(dp,0,sizeof(dp));\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tcin>>k>>o>>L[i]>>R[i];\n\t\t\tg=gcd(k,o);\n\t\t\tK[i]=k/g;\n\t\t\tO[i]=o/g;\n\t\t}\n\t\tres=0;\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tres=max(res,mobi(i));\n\t\t}\n\t\t/*\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tcout<<i<<\" \"<<dp[i]<<endl;//\n\t\t}\n\t\t*/\n\t\tcout<<res<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nll gcd(ll a, ll b) {\n  return b != 0 ? gcd(b, a % b) : a;\n}\nll lcm(ll a,ll b){\n  return a / gcd(a,b) * b;\n}\n\nconst ll WEIGHT=-1;\nstruct stick{\n\tll r,b,p,q;\n\tstick(ll r,ll b,ll p,ll q):r(r),b(b){\n\t\tll g=gcd(p,q);\n\t\tthis->p=p/g;\n\t\tthis->q=q/g;\n\t}\n\tll getroot(ll index,vector<stick> &sticks){\n\t\tREP(i,sticks.size()){\n\t\t\tif(sticks[i].r==index||sticks[i].b==index){\n\t\t\t\treturn sticks[i].getroot(i,sticks);\n\t\t\t}\n\t\t}\n\t\treturn index;\n\t}\n\tll go(vector<stick> &sticks){\n\t\tll rw=0,bw=0;\n\t\tif(r!=WEIGHT){\n\t\t\trw=sticks[r].go(sticks);\n\t\t}else{\n\t\t\trw=1;\n\t\t}\n\t\tif(b!=WEIGHT){\n\t\t\tbw=sticks[b].go(sticks);\n\t\t}else{\n\t\t\tbw=1;\n\t\t}\n\n\t\tll l = lcm(p * rw, q * bw);\n\t\trw=l/p;\n\t\tbw=l/q;\n\t\tassert(rw);\n\t\tassert(bw);\n\n\t\treturn rw+bw;\n\t}\n};\n\n\nint main(){\n\tll n;\n\twhile(cin>>n,n){\n\t\tvector<stick> sticks;\n\t\tREP(i,n){\n\t\t\tll p,q,r,b;\n\t\t\tcin>>p>>q>>r>>b;\n\t\t\tr--;b--;\n\t\t\tsticks.push_back(stick(r,b,p,q));\n\t\t}\n\t\tll root=sticks[0].getroot(0,sticks);\n\t\tcout<<sticks[root].go(sticks)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps = 1e-9;\n\nlong long int gcd(long long int l, long long int r) {\n\tassert(l > 0 && r > 0);\n\tif (l > r)return gcd(r, l);\n\telse {\n\t\tconst long long int num = r%l;\n\t\tif (num) {\n\t\t\treturn gcd(l, num);\n\t\t}\n\t\telse {\n\t\t\treturn l;\n\t\t}\n\t}\n}\nlong long int lca(long long int l, long long int r) {\n\treturn l / gcd(l, r)*r;\n}\n\nstruct mobi {\n\tlong long int a;\n\tlong long int b;\n\tint lid;\n\tint rid;\n\n};\n\nlong long int getans(const int id,const vector<mobi>&ms) {\n\tlong long int lw=0, rw=0;\n\tif (ms[id].lid!=-1) {\n\t\tlw = getans(ms[id].lid, ms);\n\t}\n\telse {\n\t\tlw = 1;\n\t}\n\tif (ms[id].rid != -1) {\n\t\trw = getans(ms[id].rid, ms);\n\t}\n\telse {\n\t\trw = 1;\n\t}\n\tlong long int al = lw*ms[id].b;\n\tlong long int ar = rw*ms[id].a;\n\tlong long int alca = lca(al, ar);\n\treturn alca / al*lw + alca / ar*rw;\n}\n\nint main() {\n\twhile (1) {\n\t\tint N; cin >> N;\n\t\tif (!N)break;\n\t\tvector<mobi>ms;\n\t\tvector<int>pas(N);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tlong long int a, b;int lid, rid; cin >> a >> b >> lid >> rid;\n\t\t\tlid--; rid--;\n\t\t\tif (lid != -1)pas[lid] = true;\n\t\t\tif (rid != -1)pas[rid] = true;\n\t\t\tconst long long int agcd = gcd(a, b);\n\t\t\ta /= agcd; b /= agcd;\n\t\t\tms.push_back(mobi{ a,b,lid,rid });\n\t\t}\n\t\tint nopa = find(pas.begin(), pas.end(), 0) - pas.begin();\n\t\tlong long int ans = getans(nopa, ms);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nll gcd(ll a, ll b) {\n  return b != 0 ? gcd(b, a % b) : a;\n}\n\nconst ll WEIGHT=-1;\nstruct stick{\n\tll r,b,p,q;\n\tstick(ll r,ll b,ll p,ll q):r(r),b(b){\n\t\tll g=gcd(p,q);\n\t\tthis->p=p/g;\n\t\tthis->q=q/g;\n\t}\n\tll getroot(ll index,vector<stick> &sticks){\n\t\tREP(i,sticks.size()){\n\t\t\tif(sticks[i].r==index||sticks[i].b==index){\n\t\t\t\treturn sticks[i].getroot(i,sticks);\n\t\t\t}\n\t\t}\n\t\treturn index;\n\t}\n\tint go(vector<stick> &sticks){\n\t\tll rw=0,bw=0;\n\t\tif(r!=WEIGHT){\n\t\t\trw=sticks[r].go(sticks);\n\t\t}\n\t\tif(b!=WEIGHT){\n\t\t\tbw=sticks[b].go(sticks);\n\t\t}\n\t\tif(r==WEIGHT&&b==WEIGHT){\n\t\t\trw=q;\n\t\t\tbw=p;\n\t\t}else if(r==WEIGHT){\n\t\t\tif(p*bw%q){\n\t\t\t\trw=bw*p;\n\t\t\t\tbw*=q;\n\t\t\t}else{\n\t\t\t\trw=bw*p/q;\n\t\t\t}\n\t\t}else if(b==WEIGHT){\n\t\t\tif(q*rw%p){\n\t\t\t\tbw=rw*q;\n\t\t\t\trw*=p;\n\t\t\t}else{\n\t\t\t\tbw=rw*q/p;\n\t\t\t}\n\t\t}else{\n\t\t\tll trw=rw,tbw=bw;\n\t\t\tll gr=gcd(rw,q);\n\t\t\tll gb=gcd(bw,p);\n\t\t\trw=trw*tbw*q/gr;\n\t\t\tbw=tbw*trw*p/gb;\n\t\t}\n\t\t//assert(rw&&bw);\n\t\treturn rw+bw;\n\t}\n};\n\n\nint main(){\n\tll n;\n\twhile(cin>>n,n){\n\t\tvector<stick> sticks;\n\t\tREP(i,n){\n\t\t\tll p,q,r,b;\n\t\t\tcin>>p>>q>>r>>b;\n\t\t\tr--;b--;\n\t\t\tsticks.push_back(stick(r,b,p,q));\n\t\t}\n\t\tll root=sticks[0].getroot(0,sticks);\n\t\tcout<<sticks[root].go(sticks)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nconstexpr int mod=1e9+7;\nint n,p[100],q[100],r[100],b[100];\nint dp[100];\nint func(int v){\n    if(v==-1)\n        return 1;\n    if(dp[v]!=0)\n        return dp[v];\n    int r_=func(r[v]-1),b_=func(b[v]-1);\n    return dp[v]=(p[v]+q[v])*r_*b_/__gcd(p[v]*r_,q[v]*b_);\n}\nsigned main(){\n    while(cin>>n,n){\n    for(int i=0;i<n;i++){\n        cin>>p[i]>>q[i]>>r[i]>>b[i];\n        dp[i]=0;\n    }\n    int ans=0;\n    for(int i=0;i<n;i++)\n        ans=max(ans,func(i));\n    cout<<ans<<endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint lenL[100];\nint lenR[100];\nint L[100];\nint R[100];\nint c[100];\nint d[100];\nlong long wL[100];\nlong long wR[100];\nint parent[100];\nbool visited[100];\nint gcd(long long int a,long long int b){\n\twhile(b){\n\t\ta%=b;\n\t\tlong long int val=b;\n\t\tb=a;\n\t\ta=val;\n\t}\n\treturn a;\n}\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tfor(int i=0;i<a;i++){\n\t\t\tscanf(\"%d%d%d%d\",lenL+i,lenR+i,L+i,R+i);\n\t\t}\n\t\tlong long total=1;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tc[i]=lenL[i]/gcd(lenL[i],lenR[i]);\n\t\t\td[i]=lenR[i]/gcd(lenR[i],lenL[i]);\n\t\t\ttotal*=(c[i]+d[i]);\n\t\t}\n\t\tfor(int i=0;i<a;i++)parent[i]=-1;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tif(L[i])\n\t\t\t\tparent[L[i]-1]=i;\n\t\t\tif(R[i])\n\t\t\t\tparent[R[i]-1]=i;\n\t\t}\n\t\tfor(int i=0;i<a;i++)visited[i]=false;\n\t\tfor(int j=0;j<a;j++){\n\t\t\tfor(int i=0;i<a;i++){\n\t\t\t\tif(parent[i]==-1&&visited[i]==false){\n\t\t\t\t\twL[i]=total/(c[i]+d[i])*d[i];\n\t\t\t\t\twR[i]=total/(c[i]+d[i])*c[i];\n\t\t\t\t\tvisited[i]=true;\n\t\t\t\t}else if(visited[i]==false&&visited[parent[i]]==true){\n\t\t\t\t\tvisited[i]=true;\n\t\t\t\t\twL[i]=(L[parent[i]]==i+1?wL[parent[i]]:wR[parent[i]])/(c[i]+d[i])*d[i];\n\t\t\t\t\twR[i]=(L[parent[i]]==i+1?wL[parent[i]]:wR[parent[i]])/(c[i]+d[i])*c[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(1){\n\t\t\tint val=total;\n\t\t\tfor(int i=0;i<a;i++){\n\t\t\t\tval=gcd(val,gcd(wL[i],wR[i]));\n\t\t\t}\n\t\t\tif(val==1)break;\n\t\t\ttotal/=val;\n\t\t\tfor(int i=0;i<a;i++){\n\t\t\t\twL[i]/=val;\n\t\t\t\twR[i]/=val;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",total);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nll gcd(ll a, ll b) {\n  return b != 0 ? gcd(b, a % b) : a;\n}\nll lcm(ll a,ll b){\n  return a / gcd(a,b) * b;\n}\n\nconst ll WEIGHT=-1;\nstruct stick{\n\tll r,b,p,q;\n\tstick(ll r,ll b,ll p,ll q):r(r),b(b){\n\t\tll g=gcd(p,q);\n\t\tthis->p=p/g;\n\t\tthis->q=q/g;\n\t}\n\tll getroot(ll index,vector<stick> &sticks){\n\t\tREP(i,sticks.size()){\n\t\t\tif(sticks[i].r==index||sticks[i].b==index){\n\t\t\t\treturn sticks[i].getroot(i,sticks);\n\t\t\t}\n\t\t}\n\t\treturn index;\n\t}\n\tll go(vector<stick> &sticks){\n\t\tll rw=0,bw=0;\n\t\tif(r!=WEIGHT){\n\t\t\trw=sticks[r].go(sticks);\n\t\t}\n\t\tif(b!=WEIGHT){\n\t\t\tbw=sticks[b].go(sticks);\n\t\t}\n\t\tif(r==WEIGHT&&b==WEIGHT){\n\t\t\trw=q;\n\t\t\tbw=p;\n\t\t}else if(r==WEIGHT){\n\t\t\tif(p*bw%q){\n\t\t\t\trw=bw*p;\n\t\t\t\tbw*=q;\n\t\t\t}else{\n\t\t\t\trw=bw*p/q;\n\t\t\t\tassert(bw);\n\t\t\t}\n\t\t}else if(b==WEIGHT){\n\t\t\tif(q*rw%p){\n\t\t\t\tbw=rw*q;\n\t\t\t\trw*=p;\n\t\t\t}else{\n\t\t\t\tbw=rw*q/p;\n\t\t\t\tassert(rw);\n\t\t\t}\n\t\t}else{\n\t\t\tll l = lcm(p * rw, q * bw);\n\t\t\trw=l/p;\n\t\t\tbw=l/q;\n\t\t}\n\t\tassert(rw&&bw);\n\t\treturn rw+bw;\n\t}\n};\n\n\nint main(){\n\tll n;\n\twhile(cin>>n,n){\n\t\tvector<stick> sticks;\n\t\tREP(i,n){\n\t\t\tll p,q,r,b;\n\t\t\tcin>>p>>q>>r>>b;\n\t\t\tr--;b--;\n\t\t\tsticks.push_back(stick(r,b,p,q));\n\t\t}\n\t\tll root=sticks[0].getroot(0,sticks);\n\t\tcout<<sticks[root].go(sticks)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define MAX_N 101\n\ntypedef long long int int64;\n\ntypedef struct\n{\n\tint64 rt_r;\n\tint64 rt_b;\n\tint64 con_r;\n\tint64 con_b;\n} bar;\n\nbar btemp;\nbar* makebar(const int64 rt_r,const int64 rt_b,const int64 con_r,const int64 con_b)\n{\n\tbtemp.rt_r = rt_r;\n\tbtemp.rt_b = rt_b;\n\tbtemp.con_r = con_r;\n\tbtemp.con_b = con_b;\n\treturn &btemp;\n}\n\nint64 gcd(int64 a,int64 b)\n{\n\tint64 tmp;\n\tif(a < b)\n\t{\n\t\ttmp = a;\n\t\ta = b;\n\t\tb = tmp;\n\t}\n\twhile(b != 0)\n\t{\n\t\ttmp = a % b;\n\t\ta = b;\n\t\tb = tmp;\n\t}\n\treturn a;\n}\n\nint64 lcm(int64 a,int64 b)\n{\n\treturn a*b / gcd(a,b);\n}\n\nint64 N;\nvector<bar> B;\nvector<bool> T;\nvector<int64> A;\n\nvoid dfs(int64 _b,int64 _u,int64 _d)\n{\n\tint64 u = _u / gcd(_u,_d);\n\tint64 d = _d / gcd(_u,_d);\n\tint64 b = _b - 1;\n\tif(B[b].con_r != 0)\n\t{\n\t\tdfs(B[b].con_r,u * B[b].rt_b,d * (B[b].rt_b + B[b].rt_r));\n\t}\n\telse\n\t{\n\t\tA.push_back((d * (B[b].rt_b + B[b].rt_r)) / gcd((u * B[b].rt_b),(d * (B[b].rt_b + B[b].rt_r))));\n\t}\n\tif(B[b].con_b != 0)\n\t{\n\t\tdfs(B[b].con_b,u * B[b].rt_r,d * (B[b].rt_b + B[b].rt_r));\n\t}\n\telse\n\t{\n\t\tA.push_back((d * (B[b].rt_b + B[b].rt_r)) / gcd((u * B[b].rt_r),(d * (B[b].rt_b + B[b].rt_r))));\n\t}\n}\n\nint main(void)\n{\n\twhile(true)\n\t{\n\t\tcin >> N;\n\t\tA.clear();\n\t\tB.clear();\n\t\tT.clear();\n\t\tif(N == 0)\n\t\t\texit(0);\n\t\tint64 p,q,r,b;\n\t\tfor(int64 i = 0;i < N;i++)\n\t\t{\n\t\t\tcin >> p >> q >> r >> b;\n\t\t\tB.push_back(*makebar(p / gcd(p,q),q / gcd(p,q),r,b));\n\t\t\tT.push_back(true);\n\t\t}\n\t\tfor(auto itr = B.begin();itr < B.end();itr++)\n\t\t{\n\t\t\tif(itr->con_r != 0)\n\t\t\t\tT[itr->con_r-1] = false;\n\t\t\tif(itr->con_b != 0)\n\t\t\t\tT[itr->con_b-1] = false;\n\t\t}\n\t\tint64 top = -1;\n\t\tfor(auto itr = T.begin();itr < T.end();itr++)\n\t\t{\n\t\t\tif(*itr)\n\t\t\t\ttop = itr - T.begin();\n\t\t}\n\t\tif(top == -1)\n\t\t\texit(-1);\n\t\tdfs(top+1,1,1);\n\t\tint64 result = 1;\n\t\tfor(auto itr = A.begin();itr < A.end();itr++)\n\t\t{\n\t\t\tresult = lcm(result,*itr);\n\t\t}\n\t\tcout << result << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nlong long int gcd( long long int a, long long int b ) {\n  return b ? gcd( b, a % b ) : a ;\n}\nlong long int lcm( long long int m, long long int n ) {\n  if ( m == 0 || n == 0 ) return 0;\n  return ( ( m / gcd( m, n ) ) * n );\n}\n\nint main() {\n\n  while( true ) {\n\n    long long int n;\n    cin >> n;\n    if ( n == 0 ) break;\n\n    vector< long long int > p, q, r, b;\n    for ( long long int i = 0; i < n; i++ ) {\n      long long int in_p, in_q, in_r, in_b;\n      cin >> in_p >> in_q >> in_r >> in_b;\n      p.push_back( in_p );\n      q.push_back( in_q );\n      r.push_back( in_r );\n      b.push_back( in_b );\n    }\n\n    for ( long long int i = 0; i < n; i++ ) {\n      for ( long long int j = 0; j < n; j++ ) {\n\n\tif ( r[j] <= 0 && b[j] <= 0 ) {\n\n\t  if ( r[j] == 0 ) {\n\t    r[j] = 1;\n\t  }else {\n\t    r[j] = -r[j];\n\t  }\n\t  long long int r2 = r[j] * q[j];\n\t  if ( b[j] == 0 ) {\n\t    b[j] = 1;\n\t  }else {\n\t    b[j] = -b[j];\n\t  }\n\t  long long int b2 = b[j] * p[j];\n\t  long long int h = lcm( r2, b2 ) / p[j] + lcm( r2, b2 ) / q[j];\n\n\t  r[j] = n + 2;\n\t  b[j] = n + 2;\n\n\t  for ( long long int k = 0; k < n; k++ ) {\n\t    if ( i == n - 1 ) {\n\t      cout << h << endl;\n\t      break;\n\t    }\n\t    if ( r[k] == j + 1 ) {\n\t      r[k] = -h;\n\t      break;\n\t    }\n\t    if ( b[k] == j + 1 ) {\n\t      b[k] = -h;\n\t      break;\n\t    }\n\t  }\n\t  break;\n\n\t}\n\n      }\n    }\n\n  }\n\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i = (a); i < (b); i++)\n#define REP(i,n) FOR(i,0,n)\n\nstruct Node {\n\tint a, b, ma, mb;\n\t\n\tNode() {}\n\tNode(int a, int b, int ma, int mb) : a(a), b(b), ma(ma), mb(mb) {}\n};\n\nint n;\nNode node[100];\nbool istop[100];\n\nint gcd(int a, int b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a % b);\n}\n\nint dfs(int pos) {\n\tNode &now = node[pos];\n\t\n\tint a = now.a, b = now.b, ma = now.ma, mb = now.mb;\n\t\n\tif (ma != 0) ma = dfs(ma - 1);\n\tif (mb != 0) mb = dfs(mb - 1);\n\t\n\tif (ma == 0 && mb == 0) {\n\t\treturn a + b;\n\t\n\t} else if (ma == 0 || mb == 0) {\n\t\tif (ma == 0) swap(ma, mb);\n\t\treturn ma * (a + b);\n\t\t\n\t}\n\telse {\n\t\tint x = gcd(a * ma, b * mb);\n\t\tint res1 = mb * (a * ma / x);\n\t\tint res2 = ma * (b * mb / x);\n\t\treturn res1 + res2;\n\t}\n}\n\nint main() {\n\twhile (cin >> n, n) {\n\t\t\n\t\tfill(istop, istop + n, false);\n\t\tREP(i, n) {\n\t\t\tint a, b, ma, mb;\n\t\t\tscanf(\"%d %d %d %d\", &a, &b, &ma, &mb);\n\t\t\tint g = gcd(a, b);\n\t\t\ta /= g; b /= g;\n\t\t\tnode[i] = Node(a, b, ma, mb);\n\t\t\t\n\t\t\tif (ma != 0) istop[ma - 1] = true;\n\t\t\tif (mb != 0) istop[mb - 1] = true;\n\t\t}\n\t\t\n\t\tint st = 0;\n\t\twhile (istop[st]) st++;\n\t\tcout << dfs(st) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//???????????¢????????§?????°????????¢?????????????§????\n//??????????????¨?????¢????????????????????????????°??????¢?????????????§???????????????????????????¨???????????????\n//???2 3??§?????£??????????????????????????????4 6??§?????£?????????????????????????????????????????´?????????\n//???????????????????????¨??????????????????????§??????????????????\\?????¨????????????\n//?§£?±??????????????????¢?????????????????? = ????°??????¢????????? * ??´??°(>=1)???\n//??????????????§?????£????????????????????§?????????????????????????¢?????????????????????????\n\n#include<iostream>\nusing namespace std;\n\nstruct Bou{\n\tint childl;\n\tint childr;\n\tint lengthl;\n\tint lengthr;\n\t\n\tvoid setBou( int p, int q, int r, int s ){\n\t\tlengthl = p;\n\t\tlengthr = q;\n\t\tchildl = r;\n\t\tchildr = s;\n\t}\n}bou[101];\n\nint gcd( int a, int b ){\n\treturn ((b > 0) ? gcd( b, a % b ) : a);\n}\nint lcm( int a, int b ){\n\treturn a * b / gcd(a, b);\n}\n\nint dfs( int ind ){\n\t//?????????\n\tif( ind == 0 ){\n\t\treturn 1;\n\t}\n\t//???\n\tint lw = dfs(bou[ind].childl);\n\t//???\n\tint rw = dfs(bou[ind].childr);\n\t\n\tint moment = lcm(lw * bou[ind].lengthr, rw * bou[ind].lengthl);\n\tint ret = moment / bou[ind].lengthr + moment / bou[ind].lengthl;\n\treturn ret;\n}\n\nint main()\n{\n\tint n;\n\tbool isRoot[101];\n\t\n\twhile( cin >> n ){\n\t\tif( !n ) break;\n\t\tfor( int i = 1; i <= n; i++ ){ isRoot[i] = true; }\n\t\t\n\t\tfor( int i = 0; i < n; i++ ){\n\t\t\tint p, q, r, s;\n\t\t\tcin >> p >> q >> r >> s;\n\t\t\tbou[i+1].setBou(p, q, r, s);\n\t\t\tisRoot[r] = (isRoot[s] = false);\n\t\t}\n\t\t\n\t\tfor( int i = 1; i <= n; i++ ){\n\t\t\tif( isRoot[i] ){\n\t\t\t\tcout << dfs(i) << endl;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 101\nusing namespace std;\ntypedef long long ll;\nll n,p[N],q[N],r[N],b[N];\nbool s[N];\n \nll func(int x){\n  ll R=1,B=1;\n  if(r[x]) R=func(r[x]);\n  if(b[x]) B=func(b[x]);\n  ll k=__gcd(R*p[x],B*q[x]);\n  ll a=(R*p[x])/k,e=(B*q[x])/k;\n  return (R*e)+(B*a);\n}\n \nint main(){\n  while(cin>>n,n){\n    memset(s,0,sizeof(s));\n    for(int i=1;i<=n;i++){\n      cin>>p[i]>>q[i]>>r[i]>>b[i];\n      ll res=__gcd(p[i],q[i]);\n      p[i]/=res,q[i]/=res;\n      s[r[i]]=s[b[i]]=true;\n    }\n    for(int i=1;i<=n;i++)\n      if(!s[i])cout<<func(i)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<queue>\nusing namespace std;\n\nstruct Stick{\n\tint p,q,r,b;\n};\nStick s[101];\n\nint tsurami(int a,int b){\n\tif(b==0) return a;\n\telse return tsurami(b,a%b);\n}\n\nint solve(int n){\n\tif(n==0) return 1;\n\tint pq_gcd = tsurami(s[n].p,s[n].q);\n\ts[n].p /= pq_gcd;\n\ts[n].q /= pq_gcd;\n\n\tint a = solve(s[n].r),\n\t\tb = solve(s[n].b);\n\tint ab_gcd = tsurami(a,b);\n\treturn (a*b/ab_gcd)*(s[n].p+s[n].q);\n}\n\nint main(){\n\tint N;\n\twhile(cin>>N,N){\n\t\tint par;\n\t\tbool cnt[101]={};\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tcin>>s[i].p>>s[i].q>>s[i].r>>s[i].b;\n\t\t\tcnt[s[i].r]=cnt[s[i].b]=true;\n\t\t}\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tif(cnt[i]==false){\n\t\t\t\tpar = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",solve(par));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n\ntypedef long long ll;\n\nint n;\n\nstruct stick\n{\n    ll p;\n    ll q;\n    int r;\n    int b;\n};\n\nvector<stick> ss;\n\nll node[110];\n\nll gcd(ll a, ll b)\n{\n    if (b == 0)\n        return a;\n    return gcd(b, a % b);\n}\n\nll rec(int in)\n{\n    int p = ss[in].p;\n    int q = ss[in].q;\n    int r = ss[in].r;\n    int b = ss[in].b;\n\n    if (r == 0 && b == 0)\n    {\n        ll g = gcd(p, q);\n        node[in] = p / g + q / g;\n    }\n    if (r == 0 && b > 0)\n    {\n        swap(p, q);\n        swap(r, b);\n    }\n\n    if (r > 0 && b == 0)\n    {\n        ll rt = rec(r);\n        ll g = gcd(rt, q);\n        rt = rt * q / g;\n        ll bt = rt * p / q;\n        node[in] = rt + bt;\n    }\n\n    if (r > 0 && b > 0)\n    {\n        ll rt = rec(r);\n        ll bt = rec(b);\n        ll rt2 = rt * p;\n        ll bt2 = bt * q;\n        ll g = gcd(rt2, bt2);\n        node[in] = rt2 / g * bt + bt2 / g * rt;\n    }\n    return node[in];\n}\n\nint main()\n{\n    while (1)\n    {\n        cin >> n;\n        if (n == 0)\n            break;\n        ss.resize(110);\n        set<int> memo;\n        for(int i = 1;i <=n;i++)\n        {\n            memo.insert(i);\n        }\n        for (int i = 1; i <= n; ++i)\n        {\n            cin >> ss[i].p >> ss[i].q >> ss[i].r >> ss[i].b;\n            if(ss[i].r != 0)\n            {\n                memo.erase(ss[i].r);\n            }\n            if(ss[i].b != 0)\n            {\n                memo.erase(ss[i].b);\n            }\n        }\n        cout << rec(*(memo.begin())) << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\n\nint gcd(int a, int b){\n\twhile(b){\n\t\tint r = a % b;\n\t\ta = b;\n\t\tb = r;\n\t}\n\treturn a;\n}\n\nint p[101], q[101], r[101], b[101];\n\nint func(int x){\n\tif( x == 0 ) return 1;\n\n\tint t = func(r[x]) * q[x];\n\tint u = func(b[x]) * p[x];\n\tint g = gcd(t, u);\n\tint lcm = t / g * u;\n\n\treturn lcm / q[x] + lcm / p[x];\n}\n\nint main(){\n\tint n;\n\twhile( scanf(\"%d\", &n), n != 0 ){\n\t\tbool ref[101] = {};\n\n\t\tfor(int i = 1; i <= n; ++i){\n\t\t\tscanf(\"%d%d%d%d\", &q[i], &p[i], &r[i], &b[i]);\n\t\t\tref[r[i]] = ref[b[i]] = true;\n\t\t}\n\t\t\n\t\tfor(int i = 1; i <= n; ++i){\n\t\t\tif( !ref[i] ){\n\t\t\t\tprintf(\"%d\\n\", func(i));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i = (a); i < (b); i++)\n#define REP(i,n) FOR(i,0,n)\n\nstruct Node {\n\tint a, b, ma, mb;\n\t\n\tNode() {}\n\tNode(int a, int b, int ma, int mb) : a(a), b(b), ma(ma), mb(mb) {}\n};\n\nint n;\nNode node[100];\nbool istop[100];\n\nint gcd(int a, int b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a % b);\n}\n\nint lcm(int a, int b) {\n\treturn a / gcd(a, b) * b;\n}\n\nint dfs(int pos) {\n\tNode &now = node[pos];\n\t\n\tint a = now.a, b = now.b, ma = now.ma, mb = now.mb;\n\t\n\tma = ma ? dfs(ma - 1) : 1;\n\tmb = mb ? dfs(mb - 1) : 1;\n\t\n\tint l = lcm(a * ma, b * mb);\n\treturn l / a + l / b;\n}\n\nint main() {\n\twhile (cin >> n, n) {\n\t\tfill(istop, istop + n, false);\n\t\t\n\t\tREP(i, n) {\n\t\t\tint a, b, ma, mb;\n\t\t\tscanf(\"%d %d %d %d\", &a, &b, &ma, &mb);\n\t\t\tint g = gcd(a, b);\n\t\t\ta /= g; b /= g;\n\t\t\tnode[i] = Node(a, b, ma, mb);\n\t\t\t\n\t\t\tif (ma != 0) istop[ma - 1] = true;\n\t\t\tif (mb != 0) istop[mb - 1] = true;\n\t\t}\n\t\t\n\t\tint st = 0;\n\t\twhile (istop[st]) st++;\n\t\tcout << dfs(st) << endl;\n\t}\n\treturn 0;\n}\n\n// 2:00"
  },
  {
    "language": "C++",
    "code": "//  Lightest Mobile.cpp\n//  2013/01/03.\n\n#if 1\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nint B[128][4];\n\nint __lcm(int a, int b)\n{\treturn a * b / __gcd(a, b); }\n\nint rec(int idx)\n{\n\tint a = (B[idx][2] == 0 ? 1 : rec(B[idx][2]-1));\n\tint b = (B[idx][3] == 0 ? 1 : rec(B[idx][3]-1));\n\t\n\tint p = B[idx][0] / __gcd(B[idx][0], B[idx][1]);\n\tint q = B[idx][1] / __gcd(B[idx][0], B[idx][1]);\n\t\n\tint lcm = __lcm(q*a, p*b);\n\t\n\treturn lcm / q + lcm / p;\n}\n\nint main()\n{\n    for(int n; cin >> n && n; )\n\t{\n\t\tvint pflag(n+1, true);\n\t\t\n\t\trep(i, n)\n\t\t{\n\t\t\trep(j, 4) cin >> B[i][j];\n\t\t\t\n\t\t\tpflag[B[i][2]] = false;\n\t\t\tpflag[B[i][3]] = false;\n\t\t}\n\t\t\n\t\trep(i, n) if(pflag[i+1]) cout << rec(i) << endl;\n\t}\n}\n\n#endif"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<algorithm>\nusing namespace std;\n\nint p[100],q[100],r[100],s[100];\n\nint gcd(int x,int y){\n  if(y==0) return x;\n  return gcd(y,x%y);\n}\n\nint dfs(int v){\n  if(v==-1){\n    return 1;\n  }else{\n    long long int right = dfs(r[v]);\n    long long int left = dfs(s[v]);\n    int g = gcd(p[v],q[v]);\n    p[v] /= g; q[v] /= g;\n    left *= q[v]; right *= p[v];\n    g = gcd(left,right);\n    int moment = left*right/g;\n    right = moment/p[v]; left = moment/q[v];\n    return right + left;\n  }\n}\n\nint solve(){\n  int n,V;\n  bool flag[100];\n  scanf(\"%d\",&n);\n  if(n==0) return -1;\n  fill(flag,flag+n,false);\n  for(int i=0;i<n;i++){\n    scanf(\"%d %d %d %d\",p+i,q+i,r+i,s+i);\n    r[i]--; s[i]--;\n    if(r[i]>=0) flag[r[i]] = true;\n    if(s[i]>=0) flag[s[i]] = true;\n  }\n  for(int i=0;i<n;i++) if(!flag[i]) V = i;\n  int ans = dfs(V);\n  printf(\"%d\\n\",ans);\n  return ans;\n}\n\nint main(){\n  while(true){\n    if(solve()<0) break;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <climits>\n#include <vector>\nusing namespace std;\n\nlong long gcd(long long x, long long y) {\n    while(y) {\n        long long t=x%y;x=y;y=t;\n    }\n    return x;\n}\n\nint rs[100],bs[100];\nlong long ps[100],qs[100], memo[100];\nbool changed;\n\nlong long calc(int i) {\n    if(i==-1) return 1;\n    if(memo[i]>=0) return memo[i];\n    changed = true;\n    long long r = calc(rs[i]);\n    long long b = calc(bs[i]);\n    long long p = ps[i];\n    long long q = qs[i];\n    long long left_factor = r*p; // b*left_factor\n    long long right_factor = b*q; // r*right_factor\n    long long fgcd = gcd(left_factor, right_factor);\n    left_factor /= fgcd;\n    right_factor /= fgcd;\n    memo[i] = b*left_factor + r*right_factor;\n    return memo[i];\n}\n\nint main() {\n    while(true) {\n        int n; scanf(\"%d\", &n);\n        if(n==0) break;\n        fill(memo, memo+n, -1);\n        for(int i = 0; i < n; i++) {\n            scanf(\"%lld%lld%d%d\", ps+i, qs+i, rs+i, bs+i);\n            rs[i]--; bs[i]--;\n        }\n        long long max_val = 0;\n        for(int i = 0; i < n; i++) {\n            changed = false;\n            long long val = calc(i);\n            if(changed) max_val = val;\n        }\n        printf(\"%lld\\n\", max_val);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<iostream>\n#include<map>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<int(n);i++)\n#define reps(i,n) for(int i=1;i<=int(n);i++)\n\nclass T{\npublic:\n  int f;\n  int s;\n  int r;\n  int l;\n};\n\nT tree[101];\n\nint sk(int a,int b){\n  int nx,nm;\n  nx=a;\n  nm=b;\n  if(a<b){\n    swap(a,b);\n  }\n  while(1){\n    if(a%b==0)break;\n    int temp;\n    temp=b;\n    b=a%b;\n    a=temp;\n  }\n  return nx*nm/b;\n}\nint saiki(int num){\n  int a=1,b=1;\n  if(tree[num].f!=0){\n    a=saiki(tree[num].f);\n  }\n  if(tree[num].s!=0){\n    b=saiki(tree[num].s);\n  }\n\n  int nn=sk(tree[num].r*b,tree[num].l*a);\n  return nn/tree[num].r + nn/tree[num].l;\n}\nint main(){\n  while(1){\n  int n;\n  scanf(\"%d\",&n);\n  if(n==0)break;\n  int get[111];\n  reps(i,n){\n    get[i]=0;\n  }\n  reps(i,n){\n    int a,b,c,d;\n    scanf(\"%d%d%d%d\",&a,&b,&c,&d);\n    tree[i].r=a;\n    tree[i].l=b;\n    tree[i].f=c;\n    tree[i].s=d;\n    get[c]=get[d]=1;\n  }\n  int st=-1;\n  reps(i,n){\n    if(get[i]==0){\n      st=i;\n    }\n  }\n  int ans=saiki(st);\n  printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\nstruct mob {\n    int l, r, a, b;\n    mob () {}\n    mob (int l, int r, int a, int b) : l(l),r(r),a(a),b(b) {}\n};\nll gcd(ll a, ll b) { return b?gcd(b,a%b):a; }\nll lcm(ll a, ll b) { return a*b/gcd(a,b); }\n\nvector<int> to[101];\nmob mobs[101];\nint n;\n\nll dfs(int id) {\n    ll a=1, b=1;\n    if (mobs[id].a) a=dfs(mobs[id].a);\n    if (mobs[id].b) b=dfs(mobs[id].b);\n    ll x=lcm(a*mobs[id].l, b*mobs[id].r);\n    return x/mobs[id].r+x/mobs[id].l;\n}\n\nint main() {\n    while (scanf(\"%d\",&n)) {\n        if (!n) break;\n        for (int i=0; i<101; i++) {\n            to[i].clear();\n        }\n        for (int i=1; i<=n; i++) {\n            int l, r, a, b; scanf(\"%d%d%d%d\",&l,&r,&a,&b);\n            mobs[i]=mob(l,r,a,b);\n            if (a) to[a].push_back(i);\n            if (b) to[b].push_back(i);\n        }\n        ll res=0;\n        for (int i=1; i<=n; i++) {\n            if (to[i].size()==0) {\n                res=dfs(i);\n                break;\n            }\n        }\n        printf(\"%lld\\n\",res);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Mobil{\n  int p,q,r,b;\n  Mobil(){}\n  Mobil(int p, int q, int r, int b):p(p),q(q),r(r),b(b){}\n};\n\ntypedef long long ll;\n\nint N;\nint in[128];\nMobil mb[128];\n\nll rec(int v){\n  ll res = 0, r=0,b=0,rw=1,bw=1;\n  Mobil m = mb[v];\n  if(m.r){ rw = rec(m.r); r = m.p*rw; }\n  else r = m.p;\n  if(m.b){ bw = rec(m.b); b = m.q*bw;}\n  else b = m.q;\n  ll lcm = r*b/__gcd(r,b);\n  //  printf(\"%d\\n\", v);\n  ///  printf(\"%lld\\n\", lcm);\n  //  printf(\"%lld %lld %lld %lld\\n\", rw, r, bw, b);\n  res += rw*lcm/r;\n  res += bw*lcm/b;\n  return res;\n}\n\nint main(){\n  while(scanf(\"%d\", &N) && N){\n    memset(in, 0, sizeof in);\n    for(int i=1;i<=N;i++){\n      int p,q,r,b; scanf(\"%d%d%d%d\",&p,&q,&r,&b);\n      mb[i] = Mobil(p,q,r,b);\n      in[r] = in[b] = 1;\n    }\n\n    int s = -1;\n    for(int i=1;i<=N;i++) if(!in[i]) s = i;\n    printf(\"%d\\n\", rec(s));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(ll i=(b) - 1;i>=(a);i--)\n#define REP(i,n) for(ll i=0;i<(n);i++)\n#define RREP(i,n) for(ll i=n-1;i>=0;i--)\n\n#define PB push_back\n#define INF (1<<29)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define CLR(a) memset(a,0,sizeof(a))\n\ntypedef long long int ll;\n\nusing namespace std;\nstruct mobile{\n    ll rc;\n    ll lc;\n    ll l;\n    ll r;\n    ll w; \n};\n\nll gcd(ll a, ll b){\n    return a%b==0 ? b : gcd(b,a%b);\n}\n\nint main(){\n    while(true){\n\tll n;\n\tcin >> n;\n\tif(n == 0) break;\n\tll ans =0 ;\n\tvector< struct mobile > v(n);\n\tREP(i,n){\n\t    ll l,r,lc,rc;\n\t    cin >> l >> r >> lc >> rc;\n\t    v[i].l = l;\n\t    v[i].r = r;\n\t    v[i].lc = lc;\n\t    v[i].rc = rc;\n\t    v[i].w = 0;\n\t}\n\tbool flg = true;\n\twhile(flg){\n\t    flg = false;\n\t    REP(i,n){\n\t\tif(v[i].w == 0 && v[i].rc == 0 && v[i].lc == 0){\n\t\t    ll r = v[i].r;\n\t\t    ll l = v[i].l;\n\t\t    v[i].r /= gcd(r,l);\n\t\t    v[i].l /= gcd(r,l);\n\t\t    v[i].w = v[i].r + v[i].l;\n\t\t    flg = true;\n\t\t}else{\n\t\t    ll lw,rw;\n\t\t    if(v[i].w > 0) continue;\n\t\t    if(v[i].lc == 0){\n\t\t\tlw = 1;\n\t\t    }else if(v[v[i].lc-1].w > 0){\n\t\t\tlw = v[v[i].lc-1].w;\n\t\t    }else continue;\n\n\t\t    if(v[i].rc == 0){\n\t\t\trw = 1;\n\t\t    }else if(v[v[i].rc-1].w > 0){\n\t\t\trw = v[v[i].rc-1].w;\n\t\t    }else continue;\n\t\t    ll r,l;\n\t\t    r = v[i].r;\n\t\t    l = v[i].l;\n\t\t    v[i].r /= gcd(r,l);\n\t\t    v[i].l /= gcd(r,l);\n\t\t    ll w = 1000000000000000;\n\t\t    FOR(k,1,100){\n\t\t\tFOR(j,1,100){\n\t\t\t    if(rw*k * v[i].r == lw * j * v[i].l){\n\t\t\t\tw = min ( w, rw*k+lw*j);\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    v[i].w = w;\n\t\t    flg = true;\n\t\t}\n\t\tans = max(ans,v[i].w);\n\t    }\n\t}\n\tcout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n\ntemplate <class T>\nint __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\nll gcd(ll a, ll b)\n{\n\tif (a < b)\n\t\tswap(a, b);\n\tif (b == 0)\n\t\treturn a;\n\treturn gcd(b, a%b);\n}\nll lcm(ll a, ll b)\n{\n\treturn a*b/gcd(a, b);\n}\nint p[101], q[101], r[101], b[101];\nint w[101];\nint dfs(int s)\n{\n\tif (s == 0)\n\t\treturn 1;\n\telse if (w[s] != -1)\n\t\treturn w[s];\n\n\tll red = dfs(r[s]), blue = dfs(b[s]);\n\tll t = lcm(red*q[s], blue*p[s]);\n\tw[s] = (int)(t/p[s] + t/q[s]);\n\treturn w[s];\n}\nint main()\n{\n\tint n;\n\twhile (~scanf(\"%d\", &n) && n)\n\t{\n\t\tbool root[101];\n\t\tfill(root, root+101, true);\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t{\n\t\t\tscanf(\"%d%d%d%d\", p+i, q+i, r+i, b+i);\n\t\t\tll g = gcd(p[i], q[i]);\n\t\t\tp[i] /= g, q[i] /= g;\n\t\t\troot[r[i]] = root[b[i]] = false;\n\t\t}\n\t\tmemset(w, -1, sizeof(w));\n\t\tint res = 0;\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t\tif (root[i])\n\t\t\t\tres = dfs(i);\n\t\tprintf(\"%d\\n\", res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\nusing namespace std;\ntypedef long long ll;\nint N,cnt[110] = {};\nll p[110],q[110],r[110],b[110],dp[110] = {};\n\nll gcd(ll n,ll m){\n    assert(m!=0);\n    if(n%m==0) return m;\n    else return gcd(m,n%m);\n}\n\nvoid dfs(int n){\n    if(n==0){\n        dp[0] = 1;\n    }else{\n        dfs(r[n]); dfs(b[n]);\n        assert(dp[r[n]]*p[n]!=0 && dp[b[n]]*q[n]!=0);\n        ll g = gcd(dp[r[n]]*p[n],dp[b[n]]*q[n]);\n        dp[n] = (dp[r[n]]*p[n])/g*dp[b[n]]+(dp[b[n]]*q[n])/g*dp[r[n]];\n    }\n}\n\nint main(){\n    while(cin >> N && N>0){\n        int par;\n        for(int i=0;i<=N;i++) cnt[i] = 0;\n        for(int i=1;i<=N;i++){\n            cin >> p[i] >> q[i] >> r[i] >> b[i];\n            cnt[r[i]]++; cnt[b[i]]++;\n        }\n        for(int i=1;i<=N;i++) if(cnt[i]==0) par = i;\n        dfs(par);\n        cout << dp[par] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nint n;\nll red[100];\nll blue[100];\nll le[100];\nll ri[100];\n\nll gcd(ll a,ll b){\n\tif(b>a){\ta^=b;\tb^=a;\ta^=b;\t}\n\twhile(1){\n\t\tint temp=a%b;\n\t\tif(temp==0)\tbreak;\n\t\ta=b;\tb=temp;\n\t}\n\treturn b;\n}\n\nll dfs(int now){\n\tll l=1,r=1;\n\tif(le[now]!=0)\tl*=dfs(le[now]-1);\n\tif(ri[now]!=0)\tr*=dfs(ri[now]-1);\n\tll g=gcd(blue[now]*r,red[now]*l);\n\tll ans=blue[now]*r*red[now]*l/g;\n\treturn ans/blue[now]+ans/red[now];\t\n}\n\t\nint main(){\n\twhile(true){\n\t\tcin>>n;\n\t\tif(n==0)\treturn 0;\n\t\tvector<int> parent(n,-1);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>red[i]>>blue[i]>>le[i]>>ri[i];\n\t\t\tif(le[i]!=0)\tparent[le[i]-1]=i;\t\n\t\t\tif(ri[i]!=0)\tparent[ri[i]-1]=i;\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(parent[i]==-1){\n\t\t\t\tcout<<dfs(i)<<endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<queue>\nusing namespace std;\nstruct Stick{\n    int p,q,r,b;\n};\nStick s[101];\nint tsurami(int a,int b){\n    if(b==0) return a;\n    else return tsurami(b,a%b);\n}\nint solve(int n){\n    if(n==0) return 1;\n    int pq_gcd = tsurami(s[n].p,s[n].q);\n    s[n].p /= pq_gcd;\n    s[n].q /= pq_gcd;\n    int a = solve(s[n].r),\n        b = solve(s[n].b);\n    int ab_gcd = tsurami(a,b);\n    for(int i=1;;i++){\n        if(s[n].p*ab_gcd*i%b==0 && s[n].q*ab_gcd*i%a==0){\n            return (s[n].p+s[n].q)*ab_gcd*i;\n        }\n    }\n}\nint main(){\n    int N;\n    while(cin>>N,N){\n        int par;\n        bool cnt[101]={};\n        for(int i=1;i<=N;i++){\n            cin>>s[i].p>>s[i].q>>s[i].r>>s[i].b;\n            cnt[s[i].r]=cnt[s[i].b]=true;\n        }\n        for(int i=1;i<=N;i++){\n            if(cnt[i]==false){\n                par = i;\n                break;\n            }\n        }\n        printf(\"%d\\n\",solve(par));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_N 100\ntypedef long long ll;\n\nvector<ll> p, q, r, b;\n\nbool dfs(int v, ll val)\n{\n  if (val == 0) {\n    if (r[v] != -1 || b[v] != -1) {\n      return 0;\n    }\n    return 1;\n  }\n  ll l = p[v] + q[v];\n  if (val * p[v] % l != 0) {\n    return 0;\n  }\n  if (val * q[v] % l != 0) {\n    return 0;\n  }\n  bool can = 1;\n  if (r[v] >= 0) {\n    can &= dfs(r[v], val*p[v]/l); \n  }\n  if (b[v] >= 0) {\n    can &= dfs(b[v], val*q[v]/l); \n  }\n  return can;\n}\n\nvoid init(int N)\n{\n  p.clear(); q.clear();\n  r.clear(); b.clear();\n  p.resize(N); q.resize(N);\n  r.resize(N); b.resize(N);\n}\n\nint main()\n{\n  int N;\n  while (cin >> N, N) {\n    init(N);\n    bool used[MAX_N];\n    for (int i = 0; i < N; i++) {\n      cin >> p[i] >> q[i] >> r[i] >> b[i];\n      r[i]--; b[i]--;\n      if (r[i] >= 0) used[r[i]] = 1;\n      if (b[i] >= 0) used[b[i]] = 1;\n      int gcd = __gcd(p[i], q[i]);\n      p[i] /= gcd;\n      q[i] /= gcd;\n    }\n    int par = -1;\n    for (int i = 0; i < N; i++) {\n      if (!used[i]) {\n\tpar = i;\n\tbreak;\n      }\n    }\n    \n    for (int i = 1; i <= 1000000; i++) {\n      if (dfs(par, i)) {\n\tcout << i << endl;\n\tbreak;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\ntypedef struct _node{\n\tlong long int p;\n\tlong long int q;\n\tlong long int r;\n\tlong long int b;\n\tlong long int left;\t//p-side mass\n\tlong long int right;\t//q-side mass\n} Node;\nlong long int calc_mass(int trgt);\nlong long int calc_gcd( long long int a, long long int b);\nNode MOB[102];\n\nint main(){\n\n\tint n;\n\tlong long int chk[102];\n\tint i;\n\tlong long int p;\n\tlong long int q;\n\tlong long int r;\n\tlong long int b;\n\tint Top;\n\tlong long int Total;\n\tlong long int gcd;\n\n\twhile(1){\n\t\tscanf(\"%d\\n\",&n);\n\t\tif(n==0)break;\n\n\t\tfor(i=1;i<=n;i++){\n\t\t\tscanf(\"%lld %lld %lld %lld\\n\",&p,&q,&r,&b);\n\t\t\tgcd=calc_gcd(p,q);\n\t\t\tMOB[i].p=p/gcd;\n\t\t\tMOB[i].q=q/gcd;\n\t\t\tMOB[i].r=r;\n\t\t\tMOB[i].b=b;\n\t\t\tMOB[i].left=0;\n\t\t\tMOB[i].right=0;\n\t\t\t\n\t\t}\n\t\t\n\t\t// search TOP;\n\t\tfor(i=1;i<=n;i++)chk[i]=0;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tif(MOB[i].r!=0)chk[MOB[i].r]=1;\n\t\t\tif(MOB[i].b!=0)chk[MOB[i].b]=1;\n\t\t}\n\t\tfor(i=1;i<=n;i++){\n\t\t\tif(chk[i]==0)Top=i;\n\t\t}\n\t\tTotal=calc_mass(Top);\n\t\tprintf(\"%lld\\n\",Total);\n\n\t}\n\treturn 0;\n}\n\n\nlong long int calc_gcd( long long int a, long long int b){\n\t long long int c=1;\n\t long long int gcd;\n\n//\tif(a==0 || b==0)return 0;\n//\tif(a==1 || b==1)return 1;\n\n//\tif(a<b){\n//\t\tc=a,a=b,b=c;\n//\t}\n\n        gcd=1;\n\t\n\twhile(a%b!=0){\n\t\tc=b;\n\t\tb=a%b;\n\t\ta=c;\n\t}\n\tgcd=b;\n\n\treturn gcd;\n\n}\n\n\n\nlong long int calc_mass(int trgt){\n//printf(\"trgt=%d\\n\",trgt);\n\tlong long int gcd;\n\tlong long int left,right;\n\tlong long int left2,right2;\n\tlong long int ratio;\n\n//\tif(MOB[trgt].r==0 && MOB[trgt].b==0){\n//\t\tgcd=calc_gcd(MOB[trgt].p,MOB[trgt].q);\n//\t\tMOB[trgt].left=MOB[trgt].q/gcd;\n//\t\tMOB[trgt].right=MOB[trgt].p/gcd;\n//\t\treturn MOB[trgt].left+MOB[trgt].right;\n//\t}\n\t\n\tif(MOB[trgt].left==0){\n\t\tif(MOB[trgt].r==0)left=1;\n\t\tif(MOB[trgt].r!=0)left=calc_mass(MOB[trgt].r);\n\t}\n\tif(MOB[trgt].right==0){\n\t\tif(MOB[trgt].b==0)right=1;\n\t\tif(MOB[trgt].b!=0)right=calc_mass(MOB[trgt].b);\n\t}\n\t\n\n\n\tgcd=calc_gcd(right,left);\n\tleft2=left/gcd,right2=right/gcd;\n\tgcd=calc_gcd(left2*MOB[trgt].q,right2*MOB[trgt].p);\n\tratio=(right2*MOB[trgt].p)/gcd;\n\tMOB[trgt].left=left*ratio;\n\t\n\tratio=(left2*MOB[trgt].q)/gcd;\n\tMOB[trgt].right=right*ratio;\n\t\n\treturn MOB[trgt].left+MOB[trgt].right;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nstruct DATA{\n  int l_l, l_r;\n  int n_l, n_r;\n};\n\nvector<DATA> data;\n\nint gcd(int a, int b){\n  if(b == 0) return a;\n  return gcd(b, a%b);\n}\n\nint search_miss_num(vector<int>& num){\n  sort(num.begin(), num.end());\n  for(int i=0; i<num.size(); ++i){\n    if(num[i] != i+1) return i;\n  }\n  return num.size();\n}\n\nint solve(int n){\n  //  cout << n << endl;\n  int GCD, g_l, g_r;\n\n  if(data[n].n_l == 0) g_l = 1;\n  else g_l = solve(data[n].n_l -1);\n\n  if(data[n].n_r == 0) g_r = 1;\n  else g_r = solve(data[n].n_r -1);\n\n  GCD = gcd(g_l * data[n].l_l, g_r * data[n].l_r);\n  return g_l * ((g_r * data[n].l_r)/GCD) + g_r * ((g_l * data[n].l_l)/GCD);\n}\n\nint main(){\n  int n, GCD;\n  DATA data_;\n  vector<int> num;\n  cin >> n;\n  for(int i=0; i<n; ++i){\n    cin >> data_.l_l >> data_.l_r >> data_.n_l >> data_.n_r;\n    GCD = gcd(data_.l_l, data_.l_r);\n    data_.l_l /= GCD;\n    data_.l_r /= GCD;\n    if(data_.n_l != 0) num.push_back(data_.n_l);\n    if(data_.n_r != 0) num.push_back(data_.n_r);\n    data.push_back(data_);\n  }\n  cout << solve(search_miss_num(num)) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <valarray>\n#include <vector>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(auto it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define mt make_tuple\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)(x).size())\n\nusing namespace std;\n\nstruct timer{\n\ttime_t start;\n\ttimer(){start=clock();}\n\t~timer(){cerr<<1.*(clock()-start)/CLOCKS_PER_SEC<<\" secs\"<<endl;}\n};\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<ll,ll> pi;\ntypedef stringstream sst;\ntypedef vector<ll> vi;\n\nint n,p[111],q[111],r[111],b[111];\n\nint gcd(int a,int b){\n\treturn b?gcd(b,a%b):a;\n}\n\nint f(int cur){\n\tif(cur==-1)return 1;\n\tint left=f(r[cur]),right=f(b[cur]);\n\tint g=gcd(left*p[cur],right*q[cur]);\n\treturn right*q[cur]/g*left+left*p[cur]/g*right;\n}\n\nint main2(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\t\n\tcin>>n;\n\tif(n==0)return 1;\n\tint appear[111]={};\n\trep(i,n){\n\t\tcin>>p[i]>>q[i]>>r[i]>>b[i];\n\t\tint g=gcd(p[i],q[i]);\n\t\tp[i]/=g,q[i]/=g;\n\t\tr[i]--,b[i]--;\n\t\tif(r[i]!=-1)appear[r[i]]=1;\n\t\tif(b[i]!=-1)appear[b[i]]=1;\n\t}\n\tint par;\n\trep(i,n)if(!appear[i])par=i;\n\tcout<<f(par)<<endl;\n\treturn 0;\n}\n\nint main(){\n\twhile(!main2());\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\nusing namespace std;\ntypedef long long ll;\n\nll gcd(ll a, ll b){\n    return b == 0 ? a : gcd(b, a%b);\n}\n\nll lcm(ll a, ll b){\n    return a / gcd(a,b) * b;\n}\n\nint n;\nll p[101], q[101], r[101], b[101];\n\nll dfs(int pos){\n    ll ret;\n    if(r[pos] == 0){\n        if(b[pos] == 0){\n            ret = p[pos] + q[pos];\n        }else{\n            ll y = dfs(b[pos]);\n            ll l = lcm(p[pos], q[pos]*y);\n            ret = l/p[pos] + l/q[pos];\n        }\n    }else if(b[pos] == 0){\n        ll x = dfs(r[pos]);\n        ll l = lcm(p[pos]*x, q[pos]);\n        ret = l/p[pos] + l/q[pos];\n    }else{\n        ll x = dfs(r[pos]), y = dfs(b[pos]);\n        ll l = lcm(p[pos]*x, q[pos]*y);\n        ret = l/p[pos] + l/q[pos];\n    }\n    return ret;\n}\n\nint main(){\n    while(cin >> n, n){\n        memset(p, 0, sizeof(p));\n        memset(q, 0, sizeof(q));\n        memset(r, 0, sizeof(r));\n        memset(b, 0, sizeof(b));\n        int indeg[101] = {};\n        for(int i = 1; i <= n; i++){\n            cin >> p[i] >> q[i] >> r[i] >> b[i];\n            indeg[r[i]]++, indeg[b[i]]++;\n            ll g = gcd(p[i], q[i]);\n            p[i] /= g, q[i] /= g;\n        }\n        int root;\n        for(root = 1; root <= n; root++)    if(indeg[root] == 0)    break;\n        cout << dfs(root) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n\nstruct stick{\n\tint left;\n\tint right;\n\tint lnode;\n\tint rnode;\n};\n\ntypedef long long ll;\nvector<stick> sticks;\n\nll gcd(ll a,ll b){\n\tif(b==0)\n\t\treturn a;\n\telse\n\t\treturn gcd(b,a%b);\n}\n\nll lcm(ll a,ll b){\n\treturn a*b/gcd(a,b);\n}\n\nll isBalanced(int idx){\n\t\n\tll lw,rw;\n\tif(sticks[idx].lnode==-1){\n\t\tlw=1;\n\t}\n\telse{\n\t\tlw=isBalanced(sticks[idx].lnode);\n\t}\n\n\tif(sticks[idx].rnode==-1){\n\t\trw=1;\n\t}\n\telse{\n\t\trw=isBalanced(sticks[idx].rnode);\n\t}\n\n\tll l=lcm(lw*sticks[idx].left,rw*sticks[idx].right);\n\treturn (l/(sticks[idx].left))+(l/(sticks[idx].right));\n}\n\nint main(){\n\n\tint n;\n\tbool ff[200];\n\twhile(cin>>n&&n!=0){\n\t\tstick s;\n\t\tfill(ff,ff+200,false);\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin>>s.left>>s.right>>s.lnode>>s.rnode;\n\t\t\ts.lnode--;\n\t\t\ts.rnode--;\n\t\t\tsticks.push_back(s);\n\t\t\tif(s.lnode!=-1)\n\t\t\t\tff[s.lnode]=true;\n\t\t\tif(s.rnode!=-1)\n\t\t\t\tff[s.rnode]=true;\n\t\t}\n\t\tint start;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(!ff[i]){\n\t\t\t\tstart=i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout<<isBalanced(start)<<endl;\n\t\tsticks.clear();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n\nstruct stick{\n\tint left;\n\tint right;\n\tint lnode;\n\tint rnode;\n};\n\ntypedef long long ll;\nvector<stick> sticks;\n\nll gcd(int a,int b){\n\tif(b==0)\n\t\treturn a;\n\telse\n\t\treturn gcd(b,a%b);\n}\n\nll lcm(int a,int b){\n\treturn a*b/gcd(a,b);\n}\n\nll isBalanced(int idx){\n\t\n\tll lw,rw;\n\tif(sticks[idx].lnode==-1){\n\t\tlw=1;\n\t}\n\telse{\n\t\tlw=isBalanced(sticks[idx].lnode);\n\t}\n\n\tif(sticks[idx].rnode==-1){\n\t\trw=1;\n\t}\n\telse{\n\t\trw=isBalanced(sticks[idx].rnode);\n\t}\n\n\tll l=lcm(lw*sticks[idx].left,rw*sticks[idx].right);\n\treturn (l/(sticks[idx].left))+(l/(sticks[idx].right));\n}\n\nint main(){\n\n\tint n;\n\tbool ff[200];\n\twhile(cin>>n&&n!=0){\n\t\tstick s;\n\t\tfill(ff,ff+200,false);\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin>>s.left>>s.right>>s.lnode>>s.rnode;\n\t\t\ts.lnode--;\n\t\t\ts.rnode--;\n\t\t\tsticks.push_back(s);\n\t\t\tif(s.lnode!=-1)\n\t\t\t\tff[s.lnode]=true;\n\t\t\tif(s.rnode!=-1)\n\t\t\t\tff[s.rnode]=true;\n\t\t}\n\t\tint start;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(!ff[i]){\n\t\t\t\tstart=i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout<<isBalanced(start)<<endl;\n\t\tsticks.clear();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <memory>\n#include <memory.h>\n#include <fstream>\n#include <cmath>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <sstream>\n#include <cstdlib>\n#include <cassert>\n#include <cstdio>\n#include <map>\n#include <iomanip>\n#include <list>\n#include <cctype>\n#include <algorithm>\n#include <complex>\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, m, n) for(int i = m; i < n; i++)\nusing namespace std;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<double, double> Pd;\ntypedef pair<int, P> PP;\ntypedef pair<int, PP> PPP;\nconst int INF = 1 << 29;\nconst double EPS = 1E-10;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n\nint par[100];\nint chl[100];\nint chr[100];\nP data[100];\n\nll gcd(ll u, ll v){\n\twhile(u > 0){\n\t\tif(u < v) swap(u, v);\n\t\tu %= v;\n\t}\n\treturn v;\n}\n\nll lcm(ll u, ll v){\n\treturn u / gcd(u, v) * v;\n}\n\nll calc(int v){\n\tll lw, rw;\n\tif(chr[v] == -1 && chl[v] == -1){\n\t\treturn data[v].first + data[v].second;\n\t}else if(chr[v] == -1){\n\t\treturn lcm(calc(chl[v]), data[v].second) /\n\t\t\tdata[v].second * (data[v].first + data[v].second);\n\t}else if(chl[v] == -1){\n\t\treturn lcm(calc(chr[v]), data[v].first) / \n\t\t\tdata[v].first * (data[v].first + data[v].second);\n\t}else{\n\t\tlw = calc(chl[v]);\n\t\trw = calc(chr[v]);\n\t\tll c = lcm(lw * data[v].first, rw * data[v].second);\n\t\treturn c / data[v].first + c / data[v].second;\n\t}\n}\n\nint main(){\n\tint n, root;\n\twhile(cin >> n && n){\n\t\tmemset(par, -1, sizeof(par));\n\t\tmemset(chl, -1, sizeof(chl));\n\t\tmemset(chr, -1, sizeof(chr));\n\t\trep(i, n){\n\t\t\tcin >> data[i].first >> data[i].second >> chl[i] >> chr[i];\n\t\t\tchl[i]--, chr[i]--;\n\t\t\tif(chl[i] != -1) par[chl[i]] = i;\n\t\t\tif(chr[i] != -1) par[chr[i]] = i;\n\n\t\t\tint a = gcd(data[i].first, data[i].second);\n\t\t\tdata[i].first /= a;\n\t\t\tdata[i].second /= a;\n\t\t}\n\t\trep(i, n) if(par[i] == -1){\n\t\t\troot = i;\n\t\t\tbreak;\n\t\t}\n\n\t\tcout << calc(root) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\n#define MAX 101\nusing namespace std;\n\ntypedef long long int Integer;\n\nInteger GCD(Integer a, Integer b){return b==0?a:GCD(b,a%b);}\n\nstruct Mobile{\n  Mobile *parent,*pr,*pb;\n  Integer p,q,gcdpq;\n  Mobile(){parent=NULL;pr=NULL;pb=NULL;}\n  bool realizable(Integer W){\n    if( W<=1 ) return false;\n    if( (W*gcdpq)%(p+q) != 0 ) return false;\n    Integer k = (W*gcdpq)/(p+q);\n    if( k<=0 ) return false;\n    bool br=true,bb=true;\n    if(pr){br=pr->realizable(k*(q/gcdpq));}\n    if(pb){bb=pb->realizable(k*(p/gcdpq));}\n    return br&&bb;\n  }\n};\n\nint main()\n{\n  while(true){\n    int n;\n    Integer ans=-1;\n    cin >> n;\n    if( n == 0 )break;\n    Mobile *ms[MAX];\n    for(int i = 0; i < n; ++i){\n      ms[i+1] = new Mobile();\n    }\n    for(int i = 0; i < n; ++i){\n      Integer p,q,r,b;\n      cin >> p >> q >> r >> b;\n      ms[i+1]->p = p;\n      ms[i+1]->q = q;\n      ms[i+1]->gcdpq = GCD(p,q);\n      if(r>0){\n\tms[r]->parent=ms[i+1];ms[i+1]->pr=ms[r];\n      }else{\n\tms[i+1]->pr=NULL;\n      }\n      if(b>0){\n\tms[b]->parent=ms[i+1];ms[i+1]->pb=ms[b];\n      }else{\n\tms[i+1]->pb=NULL;\n      }\n    }\n    for(int i = 1; i <= n; ++i){\n      if( ms[i]->parent == NULL ){\n\tfor(Integer k = 0; ; ++k){\n\t  Integer P=ms[i]->p;\n\t  Integer Q=ms[i]->q;\n\t  Integer gcdPQ=ms[i]->gcdpq;\n\t  Integer W=(k*(P+Q))/gcdPQ;\n\t  if( (k*(P+Q))%gcdPQ==0 ){\n\t    if( ms[i]->realizable( W ) ){\n\t      ans = W;\n\t      break;\n\t    }\t    \n\t  }\n\t}\n\tbreak;\n      }\n    }\n\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef double db;\n\n#define fr first\n#define sc second\n#define pb push_back\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define rep1(i,x) for(ll i=1;i<=x;i++)\n#define rrep(i,x) for(ll i=x-1;i>=0;i--)\n#define rrep1(i,x) for(ll i=x;i>0;i--)\n\nll n;\nll cnt=0;\nll bar[101][4];\n\nll gcd(ll a,ll b){\n\tif(b==0) return a;\n\treturn gcd(b,a%b);\n}\n\nll lcm(ll a,ll b){\n\treturn (a/gcd(a,b))*b;\n}\n\nll dp[101];\nll rec(ll x){\n\tif(dp[x]!=-1) return dp[x];\n\tll l=rec(bar[x][2]);\n\tll r=rec(bar[x][3]);\n\tdp[x]=((l*bar[x][0])/gcd(l*bar[x][0],r*bar[x][1]))*r+((r*bar[x][1])/gcd(r*bar[x][1],l*bar[x][0]))*l;\n\t//ll tmp = lcm(l*bar[x][0],r*bar[x][1]);\n\t//dp[x] = tmp / bar[x][0] + tmp / bar[x][1];\n\treturn dp[x];\n}\n\nint main()\n{while(1){\n\tll ans=0;\n\tcnt=0;\n\trep(i,101) dp[i]=-1;\n\tdp[0]=1;\n\tcin>>n;\n\tif(!n) return 0;\n\trep1(i,n){\n\t\trep(j,4) cin>>bar[i][j];\n\t\tll div=gcd(bar[i][0],bar[i][1]);\n\t\tbar[i][0]/=div;\n\t\tbar[i][1]/=div;\n\t}\n\trep1(i,n){\n\t\tans=max(ans,rec(i));\n\t}\n\tprintf(\"%lld\\n\",ans);\n}}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n\ntemplate <class T>\nint __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\nll gcd(ll a, ll b)\n{\n\tif (a < b)\n\t\tswap(a, b);\n\tif (b == 0)\n\t\treturn a;\n\treturn gcd(b, a%b);\n}\nll lcm(ll a, ll b)\n{\n\treturn a*b/gcd(a, b);\n}\nint p[128], q[128], r[128], b[128];\nint w[128];\nint dfs(int s)\n{\n\tif (s == 0)\n\t\treturn 1;\n\telse if (w[s] != -1)\n\t\treturn w[s];\n\t//printf(\"%d\\n\", s);\n\n\tll red = dfs(r[s]), blue = dfs(b[s]);\n\tll t = lcm(red*q[s], blue*p[s]);\n\treturn w[s] = (int)(t/p[s] + t/q[s]);\n}\nint main()\n{\n\tint n;\n\twhile (scanf(\"%d\", &n), n)\n\t{\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t{\n\t\t\tscanf(\"%d%d%d%d\", p+i, q+i, r+i, b+i);\n\t\t\tll g = gcd(p[i], q[i]);\n\t\t\tp[i] /= g, q[i] /= g;\n\t\t}\n\t\tmemset(w, -1, sizeof(w));\n\t\tint res = 0;\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t\tres = max(res, dfs(i));\n\t\tprintf(\"%d\\n\", res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nint gcd(int a,int b){\n\tint tmp;\n\twhile(b != 0){\n\t\ta -= b * (int)(a / b);\n\t\ttmp = a;\n\t\ta = b;\n\t\tb = tmp;\n\t}\n\treturn a;\n}\n\nint lcm(int a,int b){\n\treturn a / gcd(a,b) * b;\n}\n\nstruct bou{\n\tint left,right;\n\tint lbou,rbou;\n};\n\nint main(){\n\tint n,res = 1;\n\tvector<bou> tree;\n\tint si[100],bo[100],par[100];\n\twhile(cin >> n,n){\n\ttree.clear();\n\tfor(int i = 0;i < n;i++) par[i] = -1;\n\tfor(int i = 0;i < n;i++){\n\t\tint a,b,c,d;\n\t\tcin >> a >> b >> c >> d;\n\t\ttree.push_back({a / gcd(a,b),b / gcd(a,b),c - 1,d - 1});\n\t\tif(c >= 1) par[c - 1] = i;\n\t\tif(d >= 1) par[d - 1] = i;\n\t}\n\tqueue<int> que;\n\tfor(int i = 0;i < n;i++) if(par[i] == -1) que.push(i);\n\tsi[que.front()] = 1;\n\tbo[que.front()] = 1;\n\twhile(!que.empty()){\n\t\tint q = que.front();que.pop();\n\t\tbou now = tree[q];\n\t\tint bun[4];\n\t\tbun[0] = si[q] * now.left;\n\t\tbun[1] = bo[q] * (now.left + now.right);\n\t\tbun[2] = si[q] * now.right;\n\t\tbun[3] = bun[1];\n\t\tbun[0] /= gcd(bun[0],bun[1]);\n\t\tbun[1] /= gcd(bun[0],bun[1]);\n\t\tbun[2] /= gcd(bun[2],bun[3]);\n\t\tbun[3] /= gcd(bun[2],bun[3]);\n\t\tif(now.lbou != -1){\n\t\t\tsi[now.lbou] = bun[0];\n\t\t\tbo[now.lbou] = bun[1];\n\t\t\tque.push(now.lbou);\n\t\t}else{\n\t\t\tres = lcm(res,bun[1]);\n\t\t}\n\t\tif(now.rbou != -1){\n\t\t\tsi[now.rbou] = bun[2];\n\t\t\tbo[now.rbou] = bun[3];\n\t\t\tque.push(now.rbou);\n\t\t}else{\n\t\t\tres = lcm(res,bun[3]);\n\t\t}\n\t}\n\tcout << res << endl;\n\t}\n\treturn 0;\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nint gcd(int x, int y)\n{    return y ? gcd(y, x % y) : x;\t}\n\nint lcm(int x, int y)\n{\treturn x * y / gcd(x, y);\t}\n\nint poles[128][4];\n\nint weight(int id)\n{\n\tint r = (poles[id][2] == 0 ? 1 : weight(poles[id][2]));\n\tint l = (poles[id][3] == 0 ? 1 : weight(poles[id][3]));\n\t\n\tint p = poles[id][0];\n\tint q = poles[id][1];\n\t\n\tint a = lcm(r*p, l*q) / q;\n\tint b = lcm(r*p, l*q) / p;\n\t\n\treturn a + b;\n}\n\nint main()\n{\n\tfor(int n; cin >> n && n;)\n\t{\n\t\tvint top(128, true);\n\t\t\n\t\tfor(int i = 1; i <= n; i++)\n\t\t{\n\t\t\trep(j, 4) cin >> poles[i][j];\n\n\t\t\ttop[poles[i][2]] = top[poles[i][3]] = false;\n\t\t}\n\t\t\n\t\tfor(int i = 1; i <= n; i++) if(top[i]) cout << weight(i) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#define max(a,b) (a>b?a:b)\nlong long int a[101],b[101],c[101],d[101],memo[101],res=0;\n\nlong long int gcd(long long int x,long long int y){\n\tif(x==0)return y;\n\telse return gcd(y%x,x);\n}\nlong long int solve(int x){\n\tif(memo[x]!=0)return memo[x];\n\tint left=a[x]*solve(c[x]),right=b[x]*solve(d[x]),gc;\n\tgc=gcd(left,right);\n\treturn memo[x]=right/gc*solve(c[x])+left/gc*solve(d[x]);\n}\n\nint main(){\n\tmemo[0]=1;\n\tint n;\n\tfor(;scanf(\"%d\",&n),n!=0;){\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tscanf(\"%lld%lld%lld%lld\",a+i,b+i,c+i,d+i);\n\t\t}\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tres=max(res,solve(i));\n\t\t}\n\t\tprintf(\"%lld\\n\",res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct bou{\n    int p,q,r,b;\n    bou(){}\n    bou(int pp,int qq,int rr,int bb){\n        p=pp;q=qq;r=rr;b=bb;\n    }\n};\nvector<bou> ins;\nint solve(int at){\n    if(at==0) return 1;\n    else{\n        at--;\n        int rm=solve(ins[at].r),bm=solve(ins[at].b);\n        int gcd=__gcd(rm,bm);\n        int lcm=rm/gcd*bm;\n        gcd=__gcd(ins[at].p,ins[at].q);\n        ins[at].p/=gcd;\n        ins[at].q/=gcd;\n        return (ins[at].p+ins[at].q)*lcm;\n    }\n}\nint main(){\n    int n;\n    for(;;){\n        scanf(\"%d\",&n);\n        if(n==0) break;\n        ins=vector<bou>(n);\n        vector<bool> isroot(n,true);\n        for(int i=0;i<n;i++){\n            int p,q,r,b;\n            scanf(\"%d%d%d%d\",&p,&q,&r,&b);\n            int gcd=__gcd(p,q);\n            p=p/gcd;\n            q=q/gcd;\n            ins[i]=bou(p,q,r,b);\n            if(r!=0) isroot[r-1]=false;\n            if(b!=0) isroot[b-1]=false;\n        }\n        for(int i=0;i<n;i++){\n            if(isroot[i]){\n                printf(\"%d\\n\",solve(i+1));\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\n#define REP(i,a,b) for(i=a; i<b; ++i)\n#define rep(i,n) REP(i,0,n)\n\nstruct mobile {\n  int lm,rm;\n  int lc,rc,ll,rl;\n  mobile(int lc,int rc,int ll,int rl)\n  : lc(lc), rc(rc), ll(ll), rl(rl) {\n    lm = rm = -1;\n  }\n};\n\nint gcd(int a,int b) {\n  return b != 0 ? gcd(b, a%b) : a;\n}\n\nint lcm(int a,int b) {\n  return a/gcd(a,b)*b;\n}\n\nint dfs(int pos,vector<mobile> &vm) {\n  mobile now = vm[pos];\n  now.lm = (now.lc == -1) ? 1 : dfs(now.lc,vm);\n  now.rm = (now.rc == -1) ? 1 : dfs(now.rc,vm);\n  int g = lcm(now.ll*now.lm,now.rl*now.rm);\n  now.rm = g / now.rl;\n  now.lm = g / now.ll;\n  return now.rm+now.lm;\n}\n\nint main() {\n  int n,i,p,q,r,b,root;\n  while(cin>>n, n) {\n    vector<mobile> vm;\n    vector<bool> isroot(n+1,true);\n    root = -1;\n    rep(i,n) {\n      cin>>p>>q>>r>>b;\n      isroot[r] = isroot[b] = false;\n      r--,b--;\n      vm.push_back(mobile(r,b,p,q));\n    }\n\n    rep(i,n) if(isroot[i] == true) cout<<dfs(i-1,vm)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <tuple>\n# include <unordered_map>\n# include <numeric>\n# include <complex>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconstexpr int INF = 2000000000;\nconstexpr int HINF = INF / 2;\nconstexpr double DINF = 100000000000000000.0;\nconstexpr long long LINF = 9223372036854775807;\nconstexpr long long HLINF = 4500000000000000000;\nconst double PI = acos(-1);\nint dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\n# define ALL(x)     (x).begin(),(x).end()\n# define UNIQ(c)    (c).erase(unique(ALL((c))), end((c)))\n# define mp         make_pair\n# define eb         emplace_back\n# define FOR(i,a,b) for(int i=(a);i<(b);++i)\n# define REP(i,n)   FOR(i,0,n)\n# define INIT       std::ios::sync_with_stdio(false);std::cin.tie(0);\n\nint n, p[101], q[101], r[101], b[101];\n\nlong long gcd(long long a, long long b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a%b);\n}\n\nlong long lcm(long long a, long long b) {\n\tlong long g = gcd(a, b);\n\treturn a / g * b;\n}\n\nint check[200];\n\nint calc(int i) {\n\tint rc = r[i] ? calc(r[i]) : 1;\n\tint bc = b[i] ? calc(b[i]) : 1;\n\tint num = lcm(p[i] * rc, q[i] * bc);\n\treturn num / p[i] + num / q[i];\n}\n\nint main() {\n\twhile (cin >> n&&n) {\n\t\tfor (int i = 0; i < 200; i++)check[i] = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tcin >> p[i] >> q[i] >> r[i] >> b[i];\n\t\t\tcheck[r[i]] = check[b[i]] = true;\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (!check[i]) {\n\t\t\t\tcout << calc(i) << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nll gcd(ll a, ll b) {\n  return b != 0 ? gcd(b, a % b) : a;\n}\n\nconst ll WEIGHT=-1;\nstruct stick{\n\tll r,b,p,q;\n\tstick(ll r,ll b,ll p,ll q):r(r),b(b){\n\t\tll g=gcd(p,q);\n\t\tthis->p=p/g;\n\t\tthis->q=q/g;\n\t}\n\tll getroot(ll index,vector<stick> &sticks){\n\t\tREP(i,sticks.size()){\n\t\t\tif(sticks[i].r==index||sticks[i].b==index){\n\t\t\t\treturn sticks[i].getroot(i,sticks);\n\t\t\t}\n\t\t}\n\t\treturn index;\n\t}\n\tll go(vector<stick> &sticks){\n\t\tll rw=0,bw=0;\n\t\tif(r!=WEIGHT){\n\t\t\trw=sticks[r].go(sticks);\n\t\t}\n\t\tif(b!=WEIGHT){\n\t\t\tbw=sticks[b].go(sticks);\n\t\t}\n\t\tif(r==WEIGHT&&b==WEIGHT){\n\t\t\trw=q;\n\t\t\tbw=p;\n\t\t}else if(r==WEIGHT){\n\t\t\tif(p*bw%q){\n\t\t\t\trw=bw*p;\n\t\t\t\tbw*=q;\n\t\t\t}else{\n\t\t\t\trw=bw*p/q;\n\t\t\t\tassert(bw);\n\t\t\t}\n\t\t}else if(b==WEIGHT){\n\t\t\tif(q*rw%p){\n\t\t\t\tbw=rw*q;\n\t\t\t\trw*=p;\n\t\t\t}else{\n\t\t\t\tbw=rw*q/p;\n\t\t\t\tassert(rw);\n\t\t\t}\n\t\t}else{\n\t\t\tll trw=rw,tbw=bw;\n\t\t\trw*=q;\n\t\t\tbw*=p;\n\t\t\tll g=gcd(rw,bw);\n\t\t\trw=trw*tbw/g/q;\n\t\t\tbw=tbw*trw/g/p;\n\t\t}\n\t\tassert(rw&&bw);\n\t\treturn rw+bw;\n\t}\n};\n\n\nint main(){\n\tll n;\n\twhile(cin>>n,n){\n\t\tvector<stick> sticks;\n\t\tREP(i,n){\n\t\t\tll p,q,r,b;\n\t\t\tcin>>p>>q>>r>>b;\n\t\t\tr--;b--;\n\t\t\tsticks.push_back(stick(r,b,p,q));\n\t\t}\n\t\tll root=sticks[0].getroot(0,sticks);\n\t\tcout<<sticks[root].go(sticks)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define all(x) x.begin(),x.end()\n#define rep(i,N) for(int i=0;i<(int)N;++i)\nusing namespace std;\nusing ll = long long;\nusing vint = vector<int>;\nusing vll = vector<ll>;\nusing vll2 = vector<vector<ll>>;\nconst ll INF = (1LL << 30);\nconst ll LINF = (1LL << 60);\nconst ll MOD = 1e9 + 7;\n\nll gcd(ll a, ll b) {\n   return b == 0 ? a : gcd(b, a % b);\n}\n\nll lcm(ll a, ll b) {\n   return a / gcd(a, b) * b;\n}\n\nstruct Node {\n   ll p, q;\n   int r, b;\n   ll w = 0;\n};\n\nNode node[101];\nbool used[101];\n\nll dfs(int idx) {\n   if (used[idx]) return node[idx].w;\n   ll x = 1, y = 1;\n   if (node[idx].b != -1) y = dfs(node[idx].b);\n   if (node[idx].r != -1) x = dfs(node[idx].r);\n\n   ll L = lcm(x * node[idx].p, y * node[idx].q);\n   node[idx].w = L / node[idx].p + L / node[idx].q;\n\n   used[idx] = true;\n   return node[idx].w;\n}\n\nint main() {\n   cin.tie(0);\n   ios::sync_with_stdio(false);\n\n   while (true) {\n      int n; cin >> n;\n      if (n == 0) break;\n      rep(i, n) used[i] = false;\n      rep(i, n) {\n         ll p, q;\n         int r, b;\n         cin >> p >> q >> r >> b;\n         r--, b--;\n         ll g = gcd(p, q);\n         p /= g, q /= g;\n         node[i] = Node{ p, q, r, b };\n      }\n\n      ll ans = 0;\n      rep(i, n) {\n         ans = max(ans, dfs(i));\n      }\n\n      cout << ans << endl;\n   }\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma warning(disable: 4996)\n#include<cstdio>\n#include<math.h>\n#include<algorithm>\n#include<string.h>\n#include<vector>\n#include<queue>\n#include<vector>\n\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\nconst int INF=1001001001;\n\nconst int mod=100000;\n\n#define MAX_N 110\nint N;\npair<int,int> pq[MAX_N];\nint rod[MAX_N][2];\nvector<int> edge[MAX_N];\nint redge[MAX_N][2];\npriority_queue<pair<int,int> > dist;//second ??????top??????????????¢???first\nbool iftop[MAX_N];//top??????false\n\nint gcd(int a, int b){\n\tif(b==0) return a;\n\treturn gcd(b,a%b);\n}\n\nint main(){\n\twhile(1){\n\t\tscanf(\"%d\",&N);\n\t\tif(N==0)break;\n\t\tmemset(rod,0,sizeof(rod));\n\t\tmemset(redge,-1,sizeof(redge));\n\t\tmemset(iftop,false,sizeof(iftop));\n\t\trep(i,N){\n\t\t\t\n\t\t\tint p,q,r,b;\n\t\t\tscanf(\"%d %d %d %d\",&p,&q,&r,&b);\n\t\t\tpq[i]= make_pair(p,q);\n\t\t\tif(r>0){iftop[r-1]=true;edge[i].push_back(r-1);redge[r-1][0]=i;}\n\t\t\tif(b>0){iftop[b-1]=true;edge[i].push_back(b-1);redge[b-1][1]=i;}\n\n\t\t}\n\t\tint top=find(iftop,iftop+N,false)-iftop;\n\t\tqueue<int> q1;q1.push(top);\n\t\tint dister=0;\n\t\twhile(q1.size()){\n\t\t\tqueue<int> q2;\n\t\t\twhile(q1.size()){\n\t\t\t\tint a=q1.front();q1.pop();\n\t\t\t\tdist.push(make_pair(dister,a) );\n\t\t\t\trep(i,edge[a].size() ){\n\t\t\t\t\tq2.push(edge[a][i]);\n\t\t\t\t\tif(i>0)break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tq1=q2;dister++;\n\t\t}\n\n\t\tint ans=0;\n\t\twhile(dist.size()){\n\t\t\tpair<int,int> a=dist.top();dist.pop();\n\t\t\tint n=a.second;\n\t\t\tint gc=gcd(pq[n].first,pq[n].second);\n\t\t\tint p=pq[n].first/gc;int q= pq[n].second/gc;\n\t\t\tint sans=0;\n\t\t\tif(rod[n][0]==0&&rod[n][1]==0){\n\t\t\t\tsans=p+q;\n\t\t\t}else{\n\t\t\t\tif(rod[n][0]==0)rod[n][0]=1;if(rod[n][1]==0)rod[n][1]=1;\n\t\t\t\tint power=(rod[n][0]*p)*(rod[n][1]*q)/gcd( (rod[n][0]*p),(rod[n][1]*q) );\n\t\t\t\tsans=power/p+power/q;\n\t\t\t}\n\t\t\trep(i,2)if(redge[n][i]>-1){\n\t\t\t\t\trod[redge[n][i]][i]+=sans;\n\t\t\t\t}\n\t\t\tif(!dist.size()){\n\t\t\t\tans=sans;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t\trep(i,N){\n\t\t\tedge[i].clear();\n\t\tpq[i]=make_pair(0,0);\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <map>\n#include <sstream>\n#include <string>\n#include <cstdio>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cstring>\n#include <tuple>\n#include <utility>\n#include <list>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> Array;\ntypedef pair<int, int> P;\n\nconst int INF = 1 << 29;\nconst LL MOD = 100000;\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define all(c) (c).begin(), (c).end()\n\nstruct edge{ int to, cost; edge(int t, int c) :to(t), cost(c){} };\n\nint dxk[] = { 1, 1, 1, 0, -1, 0 };\nint dxg[] = { 0, 1, 0, -1, -1, -1 };\nint dy[] = { -1, 0, 1, 1, 0, -1 };\n\n//Shopping in JOI Kingdom\nint main()\n{\n\tint n;\n\twhile (cin >> n && n)\n\t{\n\t\tint m, k; cin >> m >> k;\n\t\tvector<vector<edge>> graph(n);\n\t\trep(i, m)\n\t\t{\n\t\t\tint f, t, d; cin >> f >> t >> d;\n\t\t\tf--; t--;\n\t\t\tgraph[f].push_back(edge(t, d));\n\t\t\tgraph[t].push_back(edge(f, d));\n\t\t}\n\n\t\tvector<int> dists(n, INF);\n\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\trep(i, k)\n\t\t{\n\t\t\tint x; cin >> x;\n\t\t\tx--;\n\t\t\tdists[x] = 0;\n\t\t\tque.emplace(0, x);\n\t\t}\n\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tP p = que.top(); que.pop();\n\t\t\tint d = p.first, node = p.second;\n\t\t\tif (d > dists[node]) continue;\n\t\t\tfor (auto& e : graph[node]) if (d + e.cost < dists[e.to])\n\t\t\t{\n\t\t\t\tdists[e.to] = d + e.cost;\n\t\t\t\tque.emplace(d + e.cost, e.to);\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\n\t\trep(i, graph.size()) for (auto& e : graph[i]) ans = max(ans, (dists[i] + dists[e.to] + e.cost + 1) / 2);\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define REP(i,n) for(int i=1;i<=n;i++)\nstruct S {int p,q,r,b;};\nint n;\nS a[102];\nbool is_top[102];\n\nint gcd(int a,int b){\n  while(a%=b)swap(a,b);\n  return b;\n}\n\nint lcm(int a,int b){\n  return a/gcd(a,b)*b;\n}\n\nint w(int i){\n  if(i==0)return 1;\n  int p=a[i].p, q=a[i].q,\n      r=a[i].r, b=a[i].b;\n  int l=lcm(w(r)*p,w(b)*q);\n  return l/p+l/q;\n}\n\nsigned main(){\n  while(cin>>n,n){\n    int p,q,r,b;\n    REP(i,n)is_top[i]=1;\n    REP(i,n){\n      cin>>p>>q>>r>>b;\n      a[i]={p,q,r,b};\n      is_top[r]=0;\n      is_top[b]=0;\n    }\n    int top=1;\n    while(!is_top[top])top++;\n    cout<<w(top)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\n#define REP(i,a,b) for(i=a; i<b; ++i)\n#define rep(i,n) REP(i,0,n)\n\nstruct mobile {\n  int lm,rm;\n  int lc,rc,ll,rl;\n  mobile() {;}\n  mobile(int lc,int rc,int ll,int rl) : lc(lc), rc(rc), ll(ll), rl(rl) {\n    lm = rm = -1;\n  }\n};\n\nint gcd(int a,int b) {\n  return b != 0 ? gcd(b, a%b) : a;\n}\n\nint lcm(int a,int b) {\n  return a/gcd(a,b)*b;\n}\n\nint dfs(int pos,vector<mobile> &vm) {\n  //cout<<\"now \"<<pos<<endl;\n  mobile now = vm[pos];\n  //cout<<\"    \"<<now.lc<<\" : \"<<now.rc<<endl;\n\n  if(now.lc < 0 && now.rc < 0) {\n    //cout<<\"lets calc\"<<endl;\n    int g = lcm(now.ll,now.rl);\n    now.lm = g/now.ll;\n    now.rm = g/now.rl;\n    //cout<<pos<<\" : \"<<now.ll<<\" \"<<now.rl<<\" -> \"<<g<<\" \"<<now.lm+now.rm<<endl;\n    return now.lm+now.rm;\n  }\n  if(now.lc != -1) now.lm = dfs(now.lc,vm);\n  if(now.rc != -1) now.rm = dfs(now.rc,vm);\n  if(now.lm == -1) now.lm = now.rm*now.rl/now.ll;\n  if(now.rm == -1) now.rm = now.lm*now.ll/now.rl;\n  if(now.lm*now.ll != now.rm*now.rl) {\n    //cout<<\"unbalance!!\"<<endl;\n    int g = lcm(now.lm*now.ll,now.rm*now.rl);\n    now.lm *= g/(now.lm*now.ll);\n    now.rm *= g/(now.rm*now.rl);\n    //if(now.lm*now.ll != now.rm*now.rl) cout<<\"Nooooooooooooooooooooo\"<<endl;\n  }\n  //cout<<pos<<\" \"<<now.lm<<\" \"<<now.rm<<endl;\n  return now.rm+now.lm;\n}\n\nint main() {\n  int n,i,p,q,r,b;\n  while(cin>>n, n) {\n    vector<mobile> vm;\n    vector<bool> isroot(n,true);\n    rep(i,n) {\n      cin>>p>>q>>r>>b;\n      r--,b--;\n      if(r >= 0) isroot[r] = false;\n      if(b >= 0) isroot[b] = false;\n      vm.push_back(mobile(r,b,p,q));\n    }\n\n    int root = -1;\n    rep(i,n) if(isroot[i] == true) root = i;\n\n    cout<<dfs(root,vm)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps = 1e-9;\n\nlong long int gcd(long long int l, long long int r) {\n\tassert(l > 0 && r > 0);\n\tif (l > r)return gcd(r, l);\n\telse {\n\t\tconst long long int num = r%l;\n\t\tif (num) {\n\t\t\treturn gcd(l, num);\n\t\t}\n\t\telse {\n\t\t\treturn l;\n\t\t}\n\t}\n}\nlong long int lca(long long int l, long long int r) {\n\treturn l / gcd(l, r)*r;\n}\n\nstruct mobi {\n\tlong long int a;\n\tlong long int b;\n\tint lid;\n\tint rid;\n\n};\n\nlong long int getans(const int id,const vector<mobi>&ms) {\n\tlong long int lw=0, rw=0;\n\tif (ms[id].lid!=-1) {\n\t\tlw = getans(ms[id].lid, ms);\n\t}\n\telse {\n\t\tlw = 1;\n\t}\n\tif (ms[id].rid != -1) {\n\t\trw = getans(ms[id].rid, ms);\n\t}\n\telse {\n\t\trw = 1;\n\t}\n\tlong long int al = lw*ms[id].b;\n\tlong long int ar = rw*ms[id].a;\n\tlong long int alca = lca(al, ar);\n\treturn alca / al*lw + alca / ar*rw;\n}\n\nint main() {\n\twhile (1) {\n\t\tint N; cin >> N;\n\t\tif (!N)break;\n\t\tvector<mobi>ms;\n\t\tvector<int>pas(N);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint a, b, lid, rid; cin >> a >> b >> lid >> rid;\n\t\t\tlid--; rid--;\n\t\t\tif (lid != -1)pas[lid] = true;\n\t\t\tif (rid != -1)pas[rid] = true;\n\t\t\tconst long long int agcd = gcd(a, b);\n\t\t\ta /= agcd; b /= agcd;\n\t\t\tms.push_back(mobi{ a,b,lid,rid });\n\t\t}\n\t\tint nopa = find(pas.begin(), pas.end(), 0) - pas.begin();\n\t\tlong long int ans = getans(nopa, ms);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nll gcd(ll a, ll b) {\n  return b != 0 ? gcd(b, a % b) : a;\n}\nll lcm(ll a,ll b){\n  return a / gcd(a,b) * b;\n}\n\nconst ll WEIGHT=-1;\nstruct stick{\n\tll r,b,p,q;\n\tstick(ll r,ll b,ll p,ll q):r(r),b(b){\n\t\tll g=gcd(p,q);\n\t\tthis->p=p/g;\n\t\tthis->q=q/g;\n\t}\n\tll getroot(ll index,vector<stick> &sticks){\n\t\tREP(i,sticks.size()){\n\t\t\tif(sticks[i].r==index||sticks[i].b==index){\n\t\t\t\treturn sticks[i].getroot(i,sticks);\n\t\t\t}\n\t\t}\n\t\treturn index;\n\t}\n\tll go(vector<stick> &sticks){\n\t\tll rw=0,bw=0;\n\t\tif(r!=WEIGHT){\n\t\t\trw=sticks[r].go(sticks);\n\t\t}\n\t\tif(b!=WEIGHT){\n\t\t\tbw=sticks[b].go(sticks);\n\t\t}\n\t\tif(r==WEIGHT&&b==WEIGHT){\n\t\t\trw=q;\n\t\t\tbw=p;\n\t\t\tassert(rw);\n\t\t\tassert(bw);\n\t\t}else if(r==WEIGHT){\n\t\t\tif(p*bw%q){\n\t\t\t\trw=bw*p;\n\t\t\t\tbw*=q;\n\t\t\tassert(rw);\n\t\t\t}else{\n\t\t\t\trw=bw*p/q;\n\t\t\t\tassert(bw);\n\t\t\t\tcerr<<bw<<\",\"<<p<<\",\"<<q<<endl;\n\t\t\tassert(rw);\n\t\t\t}\n\t\t\tassert(rw);\n\t\t\tassert(bw);\n\t\t}else if(b==WEIGHT){\n\t\t\tif(q*rw%p){\n\t\t\t\tbw=rw*q;\n\t\t\t\trw*=p;\n\t\t\t}else{\n\t\t\t\tbw=rw*q/p;\n\t\t\t\tassert(rw);\n\t\t\t}\n\t\t\tassert(rw);\n\t\t\tassert(bw);\n\t\t}else{\n\t\t\tll l = lcm(p * rw, q * bw);\n\t\t\trw=l/p;\n\t\t\tbw=l/q;\n\t\t\tassert(rw);\n\t\t\tassert(bw);\n\t\t}\n\t\tassert(rw&&bw);\n\t\treturn rw+bw;\n\t}\n};\n\n\nint main(){\n\tll n;\n\twhile(cin>>n,n){\n\t\tvector<stick> sticks;\n\t\tREP(i,n){\n\t\t\tll p,q,r,b;\n\t\t\tcin>>p>>q>>r>>b;\n\t\t\tr--;b--;\n\t\t\tsticks.push_back(stick(r,b,p,q));\n\t\t}\n\t\tll root=sticks[0].getroot(0,sticks);\n\t\tcout<<sticks[root].go(sticks)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint n;\nint a[100][2],p[100][2];\nbool cal[100];\nint GCD(int x,int y){\n\tif(x<2||y<2)return 1;\n\twhile(true){\n\t\tif(y>x){int t=x;x=y,y=t;}\n\t\tx%=y;\n\t\tif(!x)break;\n\t}\n\treturn y;\n}\nint DFS(int x){\n\tif(!x)return 1;\n\tx--;\n\tint b=DFS(p[x][0]),c=DFS(p[x][1]);\n\tint s=b*a[x][0]*c*a[x][1]/GCD(b*a[x][1],c*a[x][0]);\n\tint ret=0;\n\tif(a[x][0])ret+=s/a[x][0];\n\tif(a[x][0])ret+=s/a[x][1];\n\t//ret=s/a[x][0]+s/a[x][1];\n\treturn ret;\n}\nint main(){\n\twhile(true){\n\tcin>>n;\n\tif(!n)break;\n\tfor(int i=0;i<n;i++)cal[i]=true;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>a[i][0]>>a[i][1];\n\t\tint t=GCD(a[i][0],a[i][1]);\n\t\ta[i][0]/=t,a[i][1]/=t;\n\t\tcin>>p[i][0]>>p[i][1];\n\t\tcal[p[i][0]-1]=false,cal[p[i][1]-1]=false;\n\t}\n\tfor(int i=0;i<n;i++)if(cal[i])cout<<DFS(i+1)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint dp[110],K[110],O[110],L[110],R[110];\n\nint gcd(int a,int b){\n\tint tmp;\n\twhile((tmp=a%b)!=0){\n\t\ta=b;\n\t\tb=tmp;\n\t}\n\treturn b;\n}\n\n\nint mobi(int bou){\n\tif(bou==0) return 1;\n\tif(dp[bou]!=0) return dp[bou];\n\tint l,r,li,ri,gc,gc2,a,b;\n\tl=mobi(L[bou]);\n\tr=mobi(R[bou]);\n\tri=K[bou];li=O[bou];\n\tgc=gcd(li,ri);\n\tli/=gc;ri/=gc;\n\tgc2=gcd(li*l,ri*r);\n\tb=li*l/gc2;\n\ta=ri*r/gc2;\n\treturn dp[bou]=(a*l+b*r);\n}\n\nint main(){\n\tint N,res;\n\twhile(1){\n\t\tcin>>N;\n\t\tmemset(dp,0,sizeof(dp));\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tcin>>K[i]>>O[i]>>L[i]>>R[i];\n\t\t}\n\t\tres=0;\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tres=max(res,mobi(i));\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\n#define MAX 101\nusing namespace std;\n\ntypedef int Integer;\n\nInteger GCD(Integer a, Integer b){return b==0?a:GCD(b,a%b);}\n\nstruct Mobile{\n  Mobile *parent,*pr,*pb;\n  Integer p,q,gcdpq,dp,dq;\n  Mobile(){parent=NULL;pr=NULL;pb=NULL;}\n  bool realizable(Integer W){\n    if( W<=1 ) return false;\n    if( (W*gcdpq)%(p+q) != 0 ) return false;\n    Integer k = (W*gcdpq)/(p+q);\n    if( k<=0 ) return false;\n    bool br=true,bb=true;\n    if(dq<dp){\n      if(pr){br=pr->realizable(k*dq);}\n      if(!br)return false;\n      if(pb){bb=pb->realizable(k*dp);}\n      if(!bb)return false;\n    }else{\n      if(pb){bb=pb->realizable(k*dp);}\n      if(!bb)return false;\n      if(pr){br=pr->realizable(k*dq);}\n      if(!br)return false;\n    }\n    return br&&bb;\n  }\n};\n\nint main()\n{\n  while(true){\n    int n;\n    Integer ans=-1;\n    cin >> n;\n    if( n == 0 )break;\n    Mobile *ms[MAX];\n    for(int i = 0; i < n; ++i){\n      ms[i+1] = new Mobile();\n    }\n    for(int i = 0; i < n; ++i){\n      Integer p,q,r,b;\n      cin >> p >> q >> r >> b;\n      ms[i+1]->p = p;\n      ms[i+1]->q = q;\n      ms[i+1]->gcdpq = GCD(p,q);\n      ms[i+1]->dp = p/ms[i+1]->gcdpq;\n      ms[i+1]->dq = q/ms[i+1]->gcdpq;\n      if(r>0){\n\tms[r]->parent=ms[i+1];ms[i+1]->pr=ms[r];\n      }else{\n\tms[i+1]->pr=NULL;\n      }\n      if(b>0){\n\tms[b]->parent=ms[i+1];ms[i+1]->pb=ms[b];\n      }else{\n\tms[i+1]->pb=NULL;\n      }\n    }\n    for(int i = 1; i <= n; ++i){\n      if( ms[i]->parent == NULL ){\n\tfor(Integer k = 1; ; ++k){\n\t  Integer P=ms[i]->p;\n\t  Integer Q=ms[i]->q;\n\t  Integer gcdPQ=ms[i]->gcdpq;\n\t  Integer W=(k*(P+Q))/gcdPQ;\n\t  if( (k*(P+Q))%gcdPQ==0 ){\n\t    if( ms[i]->realizable( W ) ){\n\t      ans = W;\n\t      break;\n\t    }\t    \n\t  }\n\t}\n\tbreak;\n      }\n    }\n\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long lli;\n\nconst int N = 100;\n\nint n, p[N+1], q[N+1], r[N+1], b[N+1];\nbool vis[N+1];\n\nlli gcd(lli x, lli y){\n  return x%y ? gcd(y, x%y) : y;\n}\n\nlli lcm(lli x, lli y){\n  return x * y / gcd(x, y);\n}\n\nlli solve(int pos){\n  lli t1 = 1, t2 = 1;\n  if(r[pos]) t1 = solve(r[pos]);\n  if(b[pos]) t2 = solve(b[pos]);\n  lli tmp1 = p[pos];\n  lli tmp2 = q[pos];\n  if(r[pos] && b[pos]){\n    tmp1 = t1 * (lli)p[pos];\n    tmp2 = t2 * (lli)q[pos];\n    tmp1 = lcm(tmp1, tmp2);\n    tmp2 = tmp1;\n  }else if(r[pos]){\n    tmp1 = lcm(t1, (lli)p[pos]);\n    tmp2 = (lli)q[pos] * (tmp1 / t1);\n  }else if(b[pos]){\n    tmp2 = lcm(t2, (lli)q[pos]);\n    tmp1 = (lli)p[pos] * (tmp2 / t2);\n  }\n  //cout << pos << ' ' << tmp1 << ' ' << tmp2 << endl;\n  return tmp1 + tmp2;\n}\n\nmain(){\n  while(cin >> n && n){\n    fill(vis, vis+N+1, false);\n    for(int i=1;i<=n;i++){\n      cin >> p[i] >> q[i] >> r[i] >> b[i];\n      lli tmp = gcd(p[i], q[i]);\n      p[i] /= tmp;\n      q[i] /= tmp;\n      vis[r[i]] = vis[b[i]] = true;\n    }\n    for(int i=1;i<=n;i++) if(!vis[i]) cout << solve(i) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint b[100],c[100],d[100],e[100],f[100];\nint gcd(int a,int b){\n\twhile(b){\n\t\ta%=b;\n\t\tint t=a;\n\t\ta=b;\n\t\tb=t;\n\t}\n\treturn a;\n}\nint lcm(int a,int b){return a*b/gcd(a,b);}\nint dfs(int a){\n\tif(a==-1)return 1;\n\tint L=dfs(d[a]-1)*c[a];\n\tint R=dfs(e[a]-1)*b[a];\n\tint t=lcm(L,R);\n\treturn t/c[a]+t/b[a];\n}\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tfor(int i=0;i<a;i++)scanf(\"%d%d%d%d\",b+i,c+i,d+i,e+i);\n\t\tfor(int i=0;i<a;i++)f[i]=-1;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tif(d[i]>0)f[d[i]-1]=i;\n\t\t\tif(e[i]>0)f[e[i]-1]=i;\n\t\t}\n\t\tint parent=0;\n\t\tfor(int i=0;i<a;i++)if(f[i]==-1)parent=i;\n\t\tprintf(\"%d\\n\",dfs(parent));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\ntypedef long long ll;\n\nll n, p[100], q[100], r[100], b[100];\nbool isTop[100];\n\nll gcd(ll a, ll b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\n\nll check(ll num) {\n  ll left = 1, right = 1;\n  if (r[num] != -1) left = check(r[num]);\n  if (b[num] != -1) right = check(b[num]);\n  ll g = gcd(p[num], q[num]);\n  p[num] /= g;\n  q[num] /= g;\n  ll temp = (ll)left * right / gcd(left, right);\n  return (p[num] + q[num]) * temp;\n}\n\nint main() {\n  while (1) {\n    scanf(\"%lld\", &n);\n    if (n == 0) break;\n    for (ll i = 0; i < n; i++) isTop[i] = true;\n    for (ll i = 0; i < n; i++) {\n      scanf(\"%lld%lld%lld%lld\", &p[i], &q[i], &r[i], &b[i]);\n      r[i]--, b[i]--;\n      if (r[i] != -1) isTop[r[i]] = false;\n      if (b[i] != -1) isTop[b[i]] = false;\n    }\n    ll top;\n    for (ll i = 0; i < n; i++) if (isTop[i]) { top = i; break; }\n    printf(\"%lld\\n\", check(top));\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nstruct Bar{\n\tint llen,rlen,lbar,rbar,lwei,rwei;\n\tBar():lwei(0),rwei(0){}\n\tBar(int ll,int rl,int lb,int rb,int lw=0,int rw=0):llen(ll),rlen(rl),lbar(lb),rbar(rb),lwei(lw),rwei(rw){}\n};\n\nint gcd(int a,int b){return b?gcd(b,a%b):a;}\nint lcm(int a,int b){return a/gcd(a,b)*b;}\n\nvoid mul(vector<Bar>& bars,int root,int n)\n{\n\tif(root==-1) return;\n\tbars[root].lwei*=n;\n\tbars[root].rwei*=n;\n\tmul(bars,bars[root].lbar,n);\n\tmul(bars,bars[root].rbar,n);\n}\n\nint getweight(vector<Bar>& bars,int root)\n{\n\tBar& bar=bars[root];\n\tif(bar.lwei>0 && bar.rwei>0)\n\t\treturn bar.lwei+bar.rwei;\n\t\n\tint lwei=bar.lbar==-1?1:getweight(bars,bar.lbar);\n\tint rwei=bar.rbar==-1?1:getweight(bars,bar.rbar);\n\t\n\tint x=lcm(bar.llen*lwei,bar.rlen*rwei);\n\tbar.lwei=x/bar.llen;\n\tbar.rwei=x/bar.rlen;\n\t\n\tif(bar.lwei!=lwei)\n\t\tmul(bars,bar.lbar,bar.lwei/lwei);\n\tif(bar.rwei!=rwei)\n\t\tmul(bars,bar.rbar,bar.rwei/rwei);\n\t\n\treturn bar.lwei+bar.rwei;\n}\n\nint main()\n{\n\tfor(int n;cin>>n,n;){\n\t\tvector<Bar> bars(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>bars[i].llen>>bars[i].rlen>>bars[i].lbar>>bars[i].rbar;\n\t\t\tbars[i].lbar--; bars[i].rbar--;\n\t\t}\n\t\t\n\t\tint root=-1;\n\t\t{\n\t\t\tvector<int> ischild(n);\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(bars[i].lbar!=-1)\n\t\t\t\t\tischild[bars[i].lbar]=1;\n\t\t\t\tif(bars[i].rbar!=-1)\n\t\t\t\t\tischild[bars[i].rbar]=1;\n\t\t\t}\n\t\t\troot=find(ischild.begin(),ischild.end(),0)-ischild.begin();\n\t\t}\n\t\tcout<<getweight(bars,root)<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX_N 100\ntypedef long long ll;\n\nvector<int> p, q, r, b;\n\nint lcm(ll a, ll b)\n{\n    return a / __gcd(a, b) * b;\n}\n\nint dfs(int v)\n{\n    if (v == -1) return 1;    \n    int lw = dfs(r[v]), rw = dfs(b[v]);\n    int l = lcm(p[v] * lw, q[v] * rw);\n    return l / p[v] + l / q[v];\n}\n \nvoid init(int N)\n{\n    p.resize(N); q.resize(N);\n    r.resize(N); b.resize(N);\n}\n\nint main()\n{\n    int N;\n    while (cin >> N, N) {\n        init(N);\n        bool used[MAX_N] = {};\n        for (int i = 0; i < N; i++) {\n            cin >> p[i] >> q[i] >> r[i] >> b[i];\n            r[i]--; b[i]--;\n            if (r[i] >= 0) used[r[i]] = 1;\n            if (b[i] >= 0) used[b[i]] = 1;\n            int gcd = __gcd(p[i], q[i]);\n            p[i] /= gcd;\n            q[i] /= gcd;\n        }\n        for (int i = 0; i < N; i++) {\n            if (!used[i]) {\n                cout << dfs(i) << endl;\n                break;\n            }            \n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define rep(i,x) for(int i=0;i<x;++i)\n\nstruct node {\n    int p, q, r, b;\n};\n\nvector<node> sticks;\nint par[105];\n\nint n;\n\nint gcd(int a, int b)\n{\n    int tmp;\n    while (b != 0) {\n        tmp = b;\n        b = a % b;\n        a = tmp;\n    }\n\n    return a;\n}\n\nint lcm(int a, int b)\n{\n    return a / gcd(a, b) * b;\n}\n\nint dfs(int cur)\n{\n    if (cur == -1) return 1;\n\n    node& s = sticks[cur];\n\n    int rch = dfs(s.r), bch = dfs(s.b);\n    int a = lcm(rch * s.p, bch * s.q);\n\n    return a / s.p + a / s.q;\n}\n\nsigned main()\n{\n    while (cin >> n, n) {\n        sticks.resize(n);\n        memset(par, -1, sizeof(par));\n\n        rep(i, n) {\n            int p, q, r, b;\n            cin >> p >> q >> r >> b;\n            r--, b--;\n            sticks[i] = node{p, q, r, b};\n\n            if (r >= 0) par[r] = i;\n            if (b >= 0) par[b] = i;\n        }\n\n        int root;\n\n        {\n            int cur = 0;\n            do {\n                root = cur;\n                cur = par[cur];\n            } while (cur != -1);\n        }\n\n        cout << dfs(root) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint dp[110],K[110],O[110],L[110],R[110];\n\nint gcd(int a,int b){\n\tint tmp;\n\twhile((tmp=a%b)!=0){\n\t\ta=b;\n\t\tb=tmp;\n\t}\n\treturn b;\n}\n\n\nint mobi(int bou){\n\tif(bou==0) return 1;\n\tif(dp[bou]!=0) return dp[bou];\n\tint l,r,li,ri,gc,gc2,a,b;\n\tl=mobi(L[bou]);\n\tr=mobi(R[bou]);\n\tri=K[bou];li=O[bou];\n\tgc=gcd(li,ri);\n\tli/=gc;ri/=gc;\n\tgc2=gcd(li*l,ri*r);\n\tb=li*l/gc2;\n\ta=ri*r/gc2;\n\treturn (dp[bou]=(a*l+b*r));\n}\n\nint main(){\n\tint N,res;\n\twhile(1){\n\t\tcin>>N;\n\t\tif(N==0) break;\n\t\tmemset(dp,0,sizeof(dp));\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tcin>>K[i]>>O[i]>>L[i]>>R[i];\n\t\t}\n\t\tres=0;\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tres=max(res,mobi(i));\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nint gcd(int a,int b){\n    if(b==0)return a;\n    return gcd(b,a%b);\n    }  \n    int lcm(int a,int b){return a*b/gcd(a,b);}\nstruct bou{\n    int l,r,x,y;\n    };\n    int n[100];bou m[101];\nint mincost(int a){\n    if(n[a-1]!=-1)return n[a-1];\n    int b=1,c=1;\n    if(m[a].x)b=mincost(m[a].x);\n    if(m[a].y)c=mincost(m[a].y);\n    b/=gcd(b,m[a].r);c/=gcd(c,m[a].l);\n    n[a-1]=lcm(b,c)*(m[a].l+m[a].r);\n    return lcm(b,c)*(m[a].l+m[a].r);\n    }\nsigned main(){\n   int a;\n   while(cin>>a,a){\n       memset(n,-1,sizeof(n));\n       bou g;\n       for(int b=1;b<=a;b++){\n\t   int c,d;\n\t  scanf(\"%lld%lld%lld%lld\",&c,&d,&g.x,&g.y);\n\t  g.l=c/gcd(c,d);g.r=d/gcd(c,d);\n\t  m[b]=g;\n\t   }\n\t for(int i=0;i<a;i++){\n\t     if(n[i]==-1)mincost(i+1);\n\t     }  \n\t     int MAX=0;\n\tfor(int i=0;i<a;i++){\n\t     MAX=max(MAX,n[i]);\n\t    }  \n\t    cout<<MAX<<endl;\n       }\n    }"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint n;\nint a[200][2],p[200][2];\nbool cal[200];\nlong long GCD(long long x,long long y){\n\twhile(true){\n\t\tif(x<2||!y)break;\n\t\tif(y>x){long long t=x;x=y,y=t;}\n\t\tx%=y;\n\t}\n\tif(!y)y=1;\n\treturn y;\n}\nlong long DFS(int x){\n\tif(!x)return 1;\n\tcout<<x<<endl;\n\tx--;\n\tlong long b=DFS(p[x][0]),c=DFS(p[x][1]);\n\tlong long s=b*a[x][0]*c*a[x][1]/GCD(b*a[x][1],c*a[x][0]);\n\tint ret=0;\n\tif(a[x][0])ret+=s/a[x][0];\n\tif(a[x][0])ret+=s/a[x][1];\n\treturn ret;\n}\nint main(){\n\twhile(true){\n\tcin>>n;\n\tif(!n)break;\n\tfor(int i=0;i<n;i++)cal[i]=true;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>a[i][0]>>a[i][1];\n\t\tint t=GCD(a[i][0],a[i][1]);\n\t\ta[i][0]/=t,a[i][1]/=t;\n\t\tcin>>p[i][0]>>p[i][1];\n\t\tcal[p[i][0]-1]=false,cal[p[i][1]-1]=false;\n\t}\n\tfor(int i=0;i<n;i++)if(cal[i])cout<<DFS(i+1)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int64;\n\nint n;\nint64 p[100], q[100], r[100], b[100];\nint64 dp[100];\n\nint64 lcm(int64 a, int64 b){\n  return a / __gcd( a, b) * b;\n}\n\nint64 rec(int idx){\n  if(dp[idx]) return dp[idx];\n  int64 left = 1, right = 1;\n  if(r[idx] != -1) left = rec(r[idx]);\n  if(b[idx] != -1) right = rec(b[idx]);\n  int64 ret = lcm( left * p[idx], right * q[idx]);\n  return dp[idx] = ret / p[idx] + ret / q[idx];\n}\n\nint main(){\n  while(cin >> n, n){\n    fill_n( dp, 100, 0);\n\n    for(int i = 0; i < n; i++){\n      cin >> p[i] >> q[i] >> r[i] >> b[i];\n      r[i]--, b[i]--;\n    }\n    int64 ret = 0;\n    for(int i = 0; i < n; i++){\n      ret = max( ret, rec(i));\n    }\n    cout << ret << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nstruct node{ll lv,rv,lc,rc;};\n#define MAX_N 101\nll gcd(ll x,ll y){return __gcd(x,y);}\nll lcm(ll x,ll y){return x/gcd(x,y)*y;}\n\nint n;\nnode g[MAX_N];\nint t[MAX_N];\n\nll rec(int pos){\n  if(pos==0)return 1;\n  node m=g[pos];\n  ll a=rec(m.lc);\n  ll b=rec(m.rc);\n  ll c=lcm(a,b);\n  return c*(m.rv+m.lv);\n}\n\nvoid solve(){\n  int root;\n  for(root=1;t[root]>0;root++);\n  cout<<rec(root)<<endl;\n}\n\nvoid init(){\n  for(int i=0;i<MAX_N;i++)t[i]=0;\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    init(); \n    for(int i=1;i<=n;i++){\n      int p,q,r,b,x;\n      cin>>p>>q>>r>>b;\n      x=gcd(p,q);\n      p/=x,q/=x;\n      g[i]=(node){p,q,r,b};\n      t[r]=t[b]=i;\n    }\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint n,p[101],q[101],r[101],b[101];\nbool flg[101];\n\nint gcd(int a,int b){\n\treturn b == 0 ? a : gcd(b,a%b);\n}\n\nint lcm(int a,int b){\n\treturn a / gcd(a,b) * b;\n}\n\nint solve(int idx){\n\tint res = 0;\n\n\tint rcost = r[idx] ? solve(r[idx]) : 1;\n\tint bcost = b[idx] ? solve(b[idx]) : 1;\n\tint l = lcm(p[idx] * rcost, q[idx] * bcost);\n\n\treturn l / p[idx] + l / q[idx];\n}\n\nint main(void){\n\twhile(cin>>n, n){\n\t\tmemset(flg,0,sizeof(flg));\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tcin>>p[i]>>q[i]>>r[i]>>b[i];\n\t\t\tflg[r[i]] = flg[b[i]] = true; //ã©çÂé³êÄ¢é_ðtrueÉ·é\n\t\t}\n\n\t\tfor(int i=1;i<=n;i++){\n\t\t\t//ã©çÂé³êÄ¢È¢_ÈçÎ, [gm[h\n\t\t\tif(!flg[i]){\n\t\t\t\tcout<<solve(i)<<endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define int long long\n\nvector<vector<int>> g;\nvector<pair<int, int>> len;\n\nint dfs(int now) {\n    if (now == -1) return 1;\n\tint a = dfs(g[now][0]);\n\tint b = dfs(g[now][1]);\n\tint p, q;\n\ttie(p, q) = len[now];\n\tint gcd = __gcd(a*p, b*q);\n    return (p + q) * (a * b / gcd);\n}\n\nsigned main() {\n\tint n;\n\twhile (cin >> n&&n) {\n\t\tg.clear();\n\t\tg.resize(n);\n\t\tlen.clear();\n\t\tlen.resize(n);\n\t\tvector<bool> root(n, true);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint p, q, r, b;\n\t\t\tcin >> p >> q >> r >> b;\n\t\t\tr--; b--;\n\t\t\tint gcd = __gcd(p, q);\n\t\t\tp = p / gcd;\n\t\t\tq = q / gcd;\n\t\t\tif (~r) root[r] = false;\n\t\t\tif (~b) root[b] = false;\n\t\t\tg[i].push_back(r);\n\t\t\tg[i].push_back(b);\n\t\t\tlen[i] = {p, q};\n\t\t}\n\t\tint idx = find(root.begin(), root.end(), true) - root.begin();\n\t\tcout << dfs(idx) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n\ntemplate <class T>\nint __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\nint gcd(int a, int b)\n{\n\tif (a < b)\n\t\tswap(a, b);\n\tif (b == 0)\n\t\treturn a;\n\treturn gcd(b, a%b);\n}\nint lcm(int a, int b)\n{\n\treturn a/gcd(a, b) * b;\n}\nint p[101], q[101], r[101], b[101];\nint dfs(int s)\n{\n\tif (s == 0)\n\t\treturn 1;\n\n\tint red = dfs(r[s]), blue = dfs(b[s]);\n\tint t = lcm(red*q[s], blue*p[s]);\n\treturn t/p[s] + t/q[s];\n}\nint main()\n{\n\tint n;\n\t//while (~scanf(\"%d\", &n) && n)\n\twhile (cin >> n, n)\n\t{\n\t\tbool root[101];\n\t\tfill(root, root+101, true);\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t{\n\t\t\t//scanf(\"%d%d%d%d\", p+i, q+i, r+i, b+i);\n\t\t\tcin >> p[i] >> q[i] >> r[i] >> b[i];\n\t\t\troot[r[i]] = root[b[i]] = false;\n\t\t}\n\n\t\tint res = 0;\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t\tif (root[i])\n\t\t\t\tres = dfs(i);\n\t\tprintf(\"%d\\n\", res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n \nlong long int gcd( long long int a, long long int b ) {\n  return b ? gcd( b, a % b ) : a ;\n}\nlong long int lcm( long long int m, long long int n ) {\n  if ( m == 0 || n == 0 ) return 0;\n  return ( ( m / gcd( m, n ) ) * n );\n}\n \nint main() {\n\n  while( true ) {\n    long long int n;\n    cin >> n;\n    if ( n == 0 ) break;\n    \n    vector< long long int > p, q, r, b;\n    for ( long long int i = 0; i < n; i++ ) {\n      long long int in_p, in_q, in_r, in_b;\n      cin >> in_p >> in_q >> in_r >> in_b;\n      p.push_back( in_p );\n      q.push_back( in_q );\n      r.push_back( in_r );\n      b.push_back( in_b );\n    }\n    \n    for ( long long int i = 0; i < n; i++ ) {\n      for ( long long int j = 0; j < n; j++ ) {\n\t\n\tif ( r[j] <= 0 && b[j] <= 0 ) {\n\t  \n\t  if ( r[j] == 0 ) {\n\t    r[j] = 1;\n\t  }else {\n\t    r[j] = -r[j];\n\t  }\n\t  long long int r2 = r[j] * p[j];\n\t  if ( b[j] == 0 ) {\n\t    b[j] = 1;\n\t  }else {\n\t    b[j] = -b[j];\n\t  }\n\t  long long int b2 = b[j] * q[j];\n\t  long long int h = lcm( r2, b2 ) / p[j] + lcm( r2, b2 ) / q[j];\n\t  \n\t  r[j] = n + 2;\n\t  b[j] = n + 2;\n\t  \n\t  for ( long long int k = 0; k < n; k++ ) {\n\t    if ( i == n - 1 ) {\n\t      cout << h << endl;\n\t      break;\n\t    }\n\t    if ( r[k] == j + 1 ) {\n\t      r[k] = -h;\n\t      break;\n\t    }\n\t    if ( b[k] == j + 1 ) {\n\t      b[k] = -h;\n\t      break;\n\t    }\n\t  }\n\t  break;\n\t  \n\t}\n\t\n      }\n    }\n    \n  }\n \n  return 0;\n \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <cstring>\nusing namespace std;\n\nint dp[110],K[110],O[110],L[110],R[110];\n\nint gcd(int a,int b){\n\tint tmp;\n\tif(a<b) swap(a,b);\n\twhile((tmp=a%b)!=0){\n\t\ta=b;\n\t\tb=tmp;\n\t}\n\treturn b;\n}\n\n\nint mobi(int bou){\n\tif(bou==0) return 1;\n\tif(dp[bou]!=0) return dp[bou];\n\tint l,r,li,ri,gc2,a,b;\n\tl=mobi(L[bou]);\n\tr=mobi(R[bou]);\n\tri=K[bou];li=O[bou];\n\tgc2=gcd(li*l,ri*r);\n\tb=li*l/gc2;\n\ta=ri*r/gc2;\n\tdp[bou]=(a*l+b*r);\n\treturn dp[bou];\n}\n\nint main(){\n\tint N,k,o,g;\n\tint res;\n\twhile(1){\n\t\tcin>>N;\n\t\tif(N==0) break;\n\t\tmemset(dp,0,sizeof(dp));\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tcin>>k>>o>>L[i]>>R[i];\n\t\t\tg=gcd(k,o);\n\t\t\tK[i]=k/g;\n\t\t\tO[i]=o/g;\n\t\t}\n\t\twhile(true);//\n\t\tres=0;\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tres=max(res,mobi(i));\n\t\t}\n\t\t/*\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tcout<<i<<\" \"<<dp[i]<<endl;//\n\t\t}\n\t\t*/\n\t\tcout<<res<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Bokan ga bokka--nn!!\n//Daily Lunch Special Tanoshii !!\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\ntypedef long long ll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 2000000000\n#define s(x) scanf(\"%d\",&x)\n#define rep(i,x) for(int i=0;i<x;i++)\nint dp[105];\nint m[105]={};\nint u[105][2]={};\nint v[105][2]={};\nint a[105]={};\nint gcd(int a,int b)\n{\n\tif(a%b==0) return b;\n\treturn gcd(b,a%b);\n}\nint main()\n{\n\t\n\twhile(1)\n\t{\n\t\tscanf(\"%d\",&n);\n\t\tif(!n) return 0;\n\t\tqueue<int>que;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tint a,b,c,d;\n\t\t\tscanf(\"%d %d %d %d\",&a,&b,&c,&d);\n\t\t\tu[i][0]=c;\n\t\t\tu[i][1]=d;\n\t\t\tif(c)a[i]++;\n\t\t\tif(d)a[i]++;\n\t\t\tint di=gcd(a,b);\n\t\t\tv[i][0]=a/di;\n\t\t\tv[i][1]=b/di;\n\t\t\tif(!a[i]) que.push(i);\n\t\t}\n\t\tfill(dp,dp+105,1);\n\t\tint ret;\n\t\twhile(!que.empty())\n\t\t{\n\t\t\tint r=que.front(); que.pop();\n\t\t\tint bas=1;\n\t\t\tfor(int i=0;i<2;i++)\n\t\t\t{\n\t\t\t\tif(u[r][i])\n\t\t\t\t{\n\t\t\t\t\tint f=dp[u[r][i]]/gcd(dp[u[r][i]],v[r][1-i]);\n\t\t\t\t\tbas=bas/gcd(bas,f)*f;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[r]=bas*(v[r][0]+v[r][1]); ret=dp[r];\n\t\t\tfor(int i=1;i<=n;i++)\n\t\t\t{\n\t\t\t\tif(u[i][0]==r || u[i][1]==r)\n\t\t\t\t{\n\t\t\t\t\ta[i]--;\n\t\t\t\t\tif(!a[i]) que.push(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0520\n#include <iostream>\n#include <vector>\nusing namespace std;\n#define ll long long\ninline ll gcd(ll a, ll b) { if (b > a)swap(a, b); return b ? gcd(b, a%b) : a; }\ninline ll lcm(ll a, ll b) { return a / gcd(a, b)*b; }\n\nstruct mobile {\n\tll lb, rb, ln, rn;\n\tmobile() {}\n\tmobile(ll lb, ll rb, ll ln, ll rn) :lb(lb), rb(rb), ln(ln), rn(rn) {}\n\tmobile& operator=(const mobile& o) {\n\t\tthis->lb = o.lb;\n\t\tthis->rb = o.rb;\n\t\tthis->ln = o.ln;\n\t\tthis->rn = o.rn;\n\t\treturn *this;\n\t}\n};\n\nll dfs_mobile(int n,vector<mobile>& Mobile) {\n\tll lM = Mobile[n].ln == 0 ? 1 : dfs_mobile(Mobile[n].ln, Mobile);\n\tll rM = Mobile[n].rn == 0 ? 1 : dfs_mobile(Mobile[n].rn, Mobile);\n\tll LCM = lcm(lM*Mobile[n].lb, rM*Mobile[n].rb);\n\n\treturn LCM / Mobile[n].lb + LCM / Mobile[n].rb;\n}\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\twhile (true) {\n\t\tint n; cin >> n;\n\t\tif (n == 0) break;\n\t\tvector<ll> rev(n + 1, -1);\n\t\tvector<mobile> Mobile(n + 1);\n\n\t\t/* initialize */\n\t\tfor (int i = 1; i <= n;i++) {\n\t\t\tll lb, rb, ln, rn; cin >> lb >> rb >> ln >> rn;\n\t\t\tll GCD = gcd(lb, rb);\n\t\t\tlb /= GCD; rb /= GCD;\n\t\t\tMobile[i] = mobile(lb, rb, ln, rn);\n\t\t\tif (ln != 0) rev[ln] = i;\n\t\t\tif (rn != 0) rev[rn] = i;\n\t\t}\n\n\t\t/*????????¢?´¢*/\n\t\tll root = 1;\n\t\twhile (rev[root] != -1) root = rev[root];\n\n\t\tcout << dfs_mobile(root,Mobile) << endl;\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint field[5000][5000] = {0};\nint n,mem[100][5],sum;\nint F(int n1,int n2)\n{\n    if(n1 == 0)return n2;\n    return F(n2 % n1,n1);\n}\nint min_w(int n_mobile)\n{\n    int n1,n2,lim,longth;\n    if(mem[n_mobile][2] == 0)n1 = 1;\n    else n1 = min_w(mem[n_mobile][2] - 1);\n    if(mem[n_mobile][3] == 0)n2 = 1;\n    else n2 = min_w(mem[n_mobile][3] - 1);\n    lim = F(min(n1,n2),max(n1,n2));\n    longth = F(min(mem[n_mobile][0],mem[n_mobile][1]),max(mem[n_mobile][0],mem[n_mobile][1]));\n    //printf(\"%d %d %d\\n\",n_mobile,lim,longth);\n    return ((n1 * n2) / lim) * ((mem[n_mobile][0] / longth) + (mem[n_mobile][1] / longth));\n}\nint main()\n{\n    while(scanf(\"%d\",&n),n)\n    {\n        sum = 0;\n        for(int i = 0; i < n; i++)\n        {\n            for(int j = 0; j < 4; j++)\n            {\n                scanf(\"%d\",&mem[i][j]);\n            }\n            sum += mem[i][2] + mem[i][3];\n        }\n        printf(\"%d\\n\",min_w((n * (n + 1)) / 2 - sum - 1));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nll gcd(ll a, ll b) {\n  return b != 0 ? gcd(b, a % b) : a;\n}\n\nconst ll WEIGHT=-1;\nstruct stick{\n\tll r,b,p,q;\n\tstick(ll r,ll b,ll p,ll q):r(r),b(b){\n\t\tll g=gcd(p,q);\n\t\tthis->p=p/g;\n\t\tthis->q=q/g;\n\t}\n\tll getroot(ll index,vector<stick> &sticks){\n\t\tREP(i,sticks.size()){\n\t\t\tif(sticks[i].r==index||sticks[i].b==index){\n\t\t\t\treturn sticks[i].getroot(i,sticks);\n\t\t\t}\n\t\t}\n\t\treturn index;\n\t}\n\tll go(vector<stick> &sticks){\n\t\tll rw=0,bw=0;\n\t\tif(r!=WEIGHT){\n\t\t\trw=sticks[r].go(sticks);\n\t\t}\n\t\tif(b!=WEIGHT){\n\t\t\tbw=sticks[b].go(sticks);\n\t\t}\n\t\tif(r==WEIGHT&&b==WEIGHT){\n\t\t\trw=q;\n\t\t\tbw=p;\n\t\t}else if(r==WEIGHT){\n\t\t\tif(p*bw%q){\n\t\t\t\trw=bw*p;\n\t\t\t\tbw*=q;\n\t\t\t}else{\n\t\t\t\trw=bw*p/q;\n\t\t\t\tassert(bw);\n\t\t\t}\n\t\t}else if(b==WEIGHT){\n\t\t\tif(q*rw%p){\n\t\t\t\tbw=rw*q;\n\t\t\t\trw*=p;\n\t\t\t}else{\n\t\t\t\tbw=rw*q/p;\n\t\t\t\tassert(rw);\n\t\t\t}\n\t\t}else{\n\t\t\tassert(bw);\n\t\t\tassert(rw);\n\t\t\tll trw=rw,tbw=bw;\n\t\t\tll gr=gcd(rw,q);\n\t\t\tll gb=gcd(bw,p);\n\t\t\trw=trw*tbw*q/gr;\n\t\t\tbw=tbw*trw*p/gb;\n\t\t\tassert(bw);\n\t\t\tassert(rw);\n\t\t}\n\t\tassert(rw&&bw);\n\t\treturn rw+bw;\n\t}\n};\n\n\nint main(){\n\tll n;\n\twhile(cin>>n,n){\n\t\tvector<stick> sticks;\n\t\tREP(i,n){\n\t\t\tll p,q,r,b;\n\t\t\tcin>>p>>q>>r>>b;\n\t\t\tr--;b--;\n\t\t\tsticks.push_back(stick(r,b,p,q));\n\t\t}\n\t\tll root=sticks[0].getroot(0,sticks);\n\t\tcout<<sticks[root].go(sticks)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<n;++i)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 102;\n\nbool flag[MAX_N];\nP rt[MAX_N];\nP ch[MAX_N];\nint pr[MAX_N];\nint n;\n\nll gcd(ll a,ll b)\n{\n\tif(b==0LL){\n\t\treturn a;\n\t}\n\treturn gcd(b,a%b);\n}\n\nll mobile(int a,int b,ll c,ll d)\n{\n\tll res = gcd(a*c,b*d);\n\treturn b*c*(d/res)+a*c*(d/res);\n}\t\n\nll dfs(int u)\n{\n\tif(ch[u].first==-1&&ch[u].second==-1){\n\t\treturn mobile(rt[u].first,rt[u].second,1LL,1LL);\n\t}else if(ch[u].first == -1){\n\t\treturn mobile(rt[u].first,rt[u].second,1LL,dfs(ch[u].second));\n\t}else if(ch[u].second == -1){\n\t\treturn mobile(rt[u].first,rt[u].second,dfs(ch[u].first),1LL);\n\t}else{\n\t\treturn mobile(rt[u].first,rt[u].second,dfs(ch[u].first),dfs(ch[u].second));\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfill(pr,pr+n,-1);\n\trep(i,n){\n\t\tscanf(\"%d%d%d%d\",&rt[i].first,&rt[i].second,&ch[i].first,&ch[i].second);\n\t\tch[i].first--,ch[i].second--;\n\t\tif(ch[i].first != -1){\n\t\t\tpr[ch[i].first] = i;\n\t\t}\n\t\tif(ch[i].second != -1){\n\t\t\tpr[ch[i].second] = i;\n\t\t}\n\t}\n\tint id=0;\n\twhile(pr[id]!=-1){\n\t\tid = pr[id];\n\t}\n\tll ans = dfs(id);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint poles[101][4];\n\nint gcd(int a, int b)\n{\n  return b == 0 ? a : gcd(b, a % b);\n}\n\nint lcm(int a, int b)\n{\n  return a * b / gcd(a, b);\n}\n\nint dfs(int n)\n{\n  int a = 1, b = 1;\n  if(poles[n][2])\n    a = dfs(poles[n][2]);\n  if(poles[n][3])\n    b = dfs(poles[n][3]);\n  int l = lcm(poles[n][0] * a, poles[n][1] * b);\n  return l / poles[n][0] + l / poles[n][1];\n}\n\n\nbool isRoot[101];\nint main()\n{\nloop:\n  fill(isRoot, isRoot + 101, true);\n  isRoot[0] = false;\n  int n;\n  cin >> n;\n  if(!n)\n    return 0;\n\n  for(int i = 1; i <= n; i++)\n  {\n    cin >> poles[i][0] >> poles[i][1] >> poles[i][2] >> poles[i][3];\n    isRoot[poles[i][2]] = isRoot[poles[i][3]] = false;\n  }\n  for(int i = 1; i <= n; i++)\n  {\n    if(isRoot[i])\n    {\n      cout << dfs(i) << endl;\n      goto loop;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#pragma warning(disable: 4996)\n#include<cstdio>\n#include<math.h>\n#include<algorithm>\n#include<string.h>\n#include<vector>\n#include<queue>\n#include<vector>\n\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\nconst int INF=1001001001;\n\nconst int mod=100000;\n\n#define MAX_N 100\nint N;\npair<int,int> pq[MAX_N];\nint rod[MAX_N][2];\nvector<int> edge[MAX_N];\nint redge[MAX_N][2];\npriority_queue<pair<int,int> > dist;//second ??????top??????????????¢???first\nbool iftop[MAX_N];//top??????false\n\nint gcd(int a, int b){\n\tif(b==0) return a;\n\treturn gcd(b,a%b);\n}\n\nint main(){\n\twhile(1){\n\t\tscanf(\"%d\",&N);\n\t\tif(N==0)break;\n\t\tmemset(redge,-1,sizeof(redge));\n\t\tmemset(iftop,false,sizeof(iftop));\n\t\trep(i,N){\n\t\t\tint p,q,r,b;\n\t\t\tscanf(\"%d %d %d %d\",&p,&q,&r,&b);\n\t\t\tpq[i]= make_pair(p,q);\n\t\t\tif(r>0){iftop[r-1]=true;edge[i].push_back(r-1);redge[r-1][0]=i;}\n\t\t\tif(b>0){iftop[b-1]=true;edge[i].push_back(b-1);redge[b-1][1]=i;}\n\n\t\t}\n\t\tint top=find(iftop,iftop+N,false)-iftop;\n\t\tqueue<int> q1;q1.push(top);\n\t\tint dister=0;\n\t\twhile(q1.size()){\n\t\t\tqueue<int> q2;\n\t\t\twhile(q1.size()){\n\t\t\t\tint a=q1.front();q1.pop();\n\t\t\t\tdist.push(make_pair(dister,a) );\n\t\t\t\trep(i,edge[a].size() ){\n\t\t\t\t\tq2.push(edge[a][i]);\n\t\t\t\t\tif(i>0)break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tq1=q2;dister++;\n\t\t}\n\n\t\tint ans=0;\n\t\twhile(dist.size()){\n\t\t\tpair<int,int> a=dist.top();dist.pop();\n\t\t\tint n=a.second;\n\t\t\tint gc=gcd(pq[n].first,pq[n].second);\n\t\t\tint p=pq[n].first/gc;int q= pq[n].second/gc;\n\t\t\tint sans=0;\n\t\t\tif(rod[n][0]==0&&rod[n][1]==0){\n\t\t\t\tsans=p+q;\n\t\t\t}else{\n\t\t\t\tif(rod[n][0]==0)rod[n][0]=1;if(rod[n][1]==0)rod[n][1]=1;\n\t\t\t\tint power=(rod[n][0]*p)*(rod[n][1]*q)/gcd( (rod[n][0]*p),(rod[n][1]*q) );\n\t\t\t\tsans=power/p+power/q;\n\t\t\t}\n\t\t\trep(i,2)if(redge[n][i]>-1){\n\t\t\t\t\trod[redge[n][i]][i]+=sans;\n\t\t\t\t}\n\t\t\tif(!dist.size()){\n\t\t\t\tans=sans;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\n#define REP(i,a,b) for(i=a; i<b; ++i)\n#define rep(i,n) REP(i,0,n)\n\nstruct mobile {\n  long long lm,rm;\n  long long lc,rc,ll,rl;\n  mobile(long long lc,long long rc,long long ll,long long rl)\n  : lc(lc), rc(rc), ll(ll), rl(rl) {\n    lm = rm = -1;\n  }\n};\n\nlong long gcd(long long a,long long b) {\n  return b != 0 ? gcd(b, a%b) : a;\n}\n\nlong long lcm(long long a,long long b) {\n  return a/gcd(a,b)*b;\n}\n\nint dfs(int pos,vector<mobile> &vm) {\n  mobile now = vm[pos];\n  now.lm = (now.lc == -1) ? 1 : dfs(now.lc,vm);\n  now.rm = (now.rc == -1) ? 1 : dfs(now.rc,vm);\n  int g = lcm(now.ll*now.lm,now.rl*now.rm);\n  now.rm = g / now.rl;\n  now.lm = g / now.ll;\n  return now.rm+now.lm;\n}\n\nint main() {\n  int n,i,p,q,r,b;\n  while(cin>>n, n) {\n    vector<mobile> vm;\n    vector<bool> isroot(n,true);\n    rep(i,n) {\n      cin>>p>>q>>r>>b;\n      r--,b--;\n      if(r >= 0) isroot[r] = false;\n      if(b >= 0) isroot[b] = false;\n      vm.push_back(mobile(r,b,p,q));\n    }\n\n    int root = -1;\n    rep(i,n) if(isroot[i] == true) root = i;\n\n    cout<<dfs(root,vm)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Node {\n\tint index;\n\tint total;    // total weight\n\tint p, q;\n\tNode *r, *l;  // right, left child\n\tNode *parent; // parent\n};\n\nint __lcm(int a, int b) {\n\treturn a * b / __gcd(a, b);\n}\n\nvoid traverse(Node *root) {\n\n\tif (root->r == NULL && root->l == NULL) {\n\t\troot->total = root->p + root->q;\n\t} else if (root->r == NULL) {\n\t\ttraverse(root->l);\n\t\tint r_moment = root->l->total * root->q;\n\t\tif (r_moment % root->p != 0) root->l->total *= root->p;\n\t\troot->total = root->l->total + root->l->total * root->q / root->p;\n\t} else if (root->l == NULL) {\n\t\ttraverse(root->r);\n\t\tint l_moment = root->r->total * root->q;\n\t\tif (l_moment % root->q != 0) root->r->total *= root->q;\n\t\troot->total = root->r->total + root->r->total * root->p / root->q;\n\t} else {\n\t\ttraverse(root->r);\n\t\ttraverse(root->l);\n\t\tint lcm_rl = __lcm(root->r->total*root->p, root->l->total*root->q);\n\t\troot->r->total = lcm_rl / root->p;\n\t\troot->l->total = lcm_rl / root->q;\n\t\troot->total = root->r->total + root->l->total;\n\t}\n}\n\nvoid print_tree(Node *root) {\n\tcout << \"node: \" << root->index << endl;\n\tcout << \"p: \" << root->p << ' ' << \"q: \" << root->q << endl;\n\tcout << root->total << endl;\n\tif (root->r != NULL) \n\t\tcout << \"r: \" << root->r->total << endl;\n\tif (root->l != NULL)\n\t   \tcout << \"l: \" << root->l->total << endl;\n\n\tif (root->r != NULL) print_tree(root->r);\n\tif (root->l != NULL) print_tree(root->l);\n}\n\nint main() {\n\tint n;\n    while (cin >> n, n) {\n\t\tNode *mobile[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tmobile[i] = new Node;\n\t\t\tmobile[i]->index = i;\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint p, q, r, l;\n\t\t\tcin >> p >> q >> r >> l;\n\t\t\tint gcd_pq = __gcd(p, q);\n\t\t\tp = p / gcd_pq;\n\t\t\tq = q / gcd_pq;\n\t\t\tmobile[i]->p = p, mobile[i]->q = q;\n\n\t\t\tif (r != 0) {\n\t\t\t\tmobile[i]->r = mobile[r-1];\n\t\t\t\tmobile[r-1]->parent = mobile[i];\n\t\t\t} else {\n\t\t\t\tmobile[i]->r = NULL;\n\t\t\t}\n\n\t\t\tif (l != 0) {\n\t\t\t\tmobile[i]->l = mobile[l-1];\n\t\t\t\tmobile[l-1]->parent = mobile[i];\n\t\t\t} else {\n\t\t\t\tmobile[i]->l = NULL;\n\t\t\t}\n\n\t\t}\n\t\t\n\t\t// find root\n\t\tNode *root = mobile[0];\n\t\twhile (root->parent != NULL) root = root->parent;\n\n\t\ttraverse(root);\n\n\t\tcout << root->total << endl;\n\n//\t\tcout << \"case: n = \" << n << endl;\n//\t\tprint_tree(root);\n\n\t\tfor (int i = 0; i < n; i++) delete(mobile[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nint memo[110];\n\nint a[110];\nint b[110];\nint l[110];\nint r[110];\n\nint gcd(int a,int b){\n\tif(b==0)\n\t\treturn a;\n\telse\n\t\treturn gcd(b,a%b);\n}\n\nint lcm(int a,int b){\n\tint g=gcd(a,b);\n\treturn a/g*b;\n}\n\nint rec(int i){\n\tif(memo[i]>=0)\n\t\treturn memo[i];\n\tint gg=gcd(a[i],b[i]);\n\tint aa=a[i]/gg;\n\tint bb=b[i]/gg;\n\tint kk=lcm(memo[l[i]],memo[r[i]]);\n\tif(kk%aa==0) kk/=aa;\n\tif(kk%bb==0) kk/=bb;\n\treturn memo[i]=(aa+bb)*kk;\n}\n\nint main(void){\n\tint n;\n\twhile(cin >> n,n){\n\t\tfor(int i=1;i<=n;++i) cin >> a[i] >> b[i] >> l[i] >> r[i];\n\t\tmemo[0]=1;\n\t\tfor(int i=1;i<=n;++i) memo[i]=-1;\n\n\t\tint ans=0;\n\t\tfor(int i=1;i<=n;++i) ans=max(ans,rec(i));\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\ntypedef struct Node {\n\tint p, q, r, b;\n} Node;\n\nlong long gcd(long long a, long long b){\n\tif(a < b){ return gcd(b, a); }\n\tif(b > 0){ return gcd(b, a % b); }\n\treturn a;\n}\nlong long lcm(long long a, long long b){\n\tlong long tmp = a;\n\ttmp *= b;\n\treturn tmp / gcd(a, b);\n}\n\nNode nodes[101];\n\nlong long calculate(int n){\n\tlong long d = gcd(nodes[n].p, nodes[n].q);\n\tlong long op = nodes[n].p / d, oq = nodes[n].q / d, answer;\n\tif(nodes[n].r == 0 && nodes[n].b == 0){\n\t\tanswer = op + oq;\n\t}else if(nodes[n].r == 0){\n\t\tlong long t = lcm(oq, calculate(nodes[n].b) * op);\n\t\tanswer = t / op + t / oq;\n\t}else if(nodes[n].b == 0){\n\t\tlong long t = lcm(op, calculate(nodes[n].r) * oq);\n\t\tanswer = t / op + t / oq;\n\t}else{\n\t\tlong long t = lcm(op * calculate(nodes[n].b), oq * calculate(nodes[n].r));\n\t\tanswer = t / op + t / oq;\n\t}\n\treturn answer;\n}\n\nint main(){\n\twhile(true){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n == 0){ break; }\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tcin >> nodes[i].p >> nodes[i].q >> nodes[i].r >> nodes[i].b;\n\t\t}\n\t\tbool flags[101] = { false };\n\t\tint remains = n;\n\t\twhile(remains > 1){\n\t\t\tbool tmpflg[101] = { false };\n\t\t\tfor(int i = 1; i <= n; i++){\n\t\t\t\tif(flags[i]){ continue; }\n\t\t\t\tif(\n\t\t\t\t\t(nodes[i].r == 0 && nodes[i].b == 0) ||\n\t\t\t\t\t(nodes[i].r == 0 && flags[nodes[i].b]) ||\n\t\t\t\t\t(flags[nodes[i].r] && nodes[i].b == 0) ||\n\t\t\t\t\t(flags[nodes[i].r] && flags[nodes[i].b])\n\t\t\t\t){\n\t\t\t\t\ttmpflg[i] = true;\n\t\t\t\t\tremains--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 1; i <= n; i++){\n\t\t\t\tflags[i] |= tmpflg[i];\n\t\t\t}\n\t\t}\n\t\tint root;\n\t\tfor(root = 1; root <= n; root++){\n\t\t\tif(!flags[root]){ break; }\n\t\t}\n\t\tprintf(\"%d\\n\", calculate(root));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define REP(i,n) for(int i=1;i<=n;i++)\nstruct S {int p,q,r,b;};\nint n;\nS a[102];\nbool is_top[102];\n\nint gcd(int a,int b){\n  while(a%=b)swap(a,b);\n  return b;\n}\n\nint lcm(int a,int b){\n  return a*b/gcd(a,b);\n}\n\nint w(int i){\n  if(i==0)return 1;\n  int p=a[i].p, q=a[i].q,\n      r=a[i].r, b=a[i].b;\n  int l=lcm(w(r)*q,w(b)*p);\n  return l/q+l/p;\n}\n\nint main(){\n  while(cin>>n,n){\n    int p,q,r,b;\n    REP(i,n)is_top[i]=1;\n    REP(i,n){\n      cin>>p>>q>>r>>b;\n      a[i]={p,q,r,b};\n      is_top[r]=0;\n      is_top[b]=0;\n    }\n    int top=1;\n    while(!is_top[top])top++;\n    cout<<w(top)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cstdio>\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> P;\ntypedef pair<LL, LL> PLL;\n\nLL gcd(LL x, LL y) {\n    if (x < y) { swap(x, y); }\n    if (y == 0) { return x; }\n    return gcd(y, x % y);\n}\n\nstruct mobile {\n    int lb;\n    int rb;\n    LL lm;\n    LL rm;\n};\n\nint N;\nmobile ms[110];\n\nint get_root() {\n    for (int j = 0; j < N; ++j) {\n        bool found = false;\n        for (int k = 0; k < N; ++k) {\n            if (ms[k].lm == j || ms[k].rm == j) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            return j;\n        }\n    }\n    return -1;\n}\n\nLL rec(int x) {\n    mobile& m = ms[x];\n\n    LL t = gcd(m.lb, m.rb);\n\n    if (m.lm == -1 && m.rm == -1) {\n        return (m.lb + m.rb) / t;\n    }\n\n    LL lw, rw, z;\n    if (m.lm != -1 && m.rm == -1) {\n        lw = rec(m.lm);\n        z = (lw * m.lb * m.rb) / gcd(lw * m.lb, m.rb);\n        lw *= z / (lw * m.lb);\n        rw = lw * m.lb / m.rb;\n    } else if (m.lm == -1 && m.rm != -1) {\n        rw = rec(m.rm);\n        z = (rw * m.rb * m.lb) / gcd(rw * m.rb, m.lb);\n        rw *= z / (rw * m.rb);\n        lw = rw * m.rb / m.lb;\n    } else {\n        lw = rec(m.lm);\n        rw = rec(m.rm);\n        LL z = lw * m.lb / gcd(lw * m.lb, rw * m.rb) * rw * m.rb;\n        lw *= z / (lw * m.lb);\n        rw *= z / (rw * m.rb);\n    }\n\n    assert(lw * m.lb == rw * m.rb);\n    return lw + rw;\n}\n\nbool solve() {\n    cin >> N;\n    if (N == 0) {\n        return false;\n    }\n    for (int j = 0; j < N; ++j) {\n        cin >> ms[j].lb >> ms[j].rb >> ms[j].lm >> ms[j].rm;\n        --ms[j].lm; --ms[j].rm;\n    }\n\n    LL root = get_root();\n    assert(root != -1);\n\n    cout << rec(root) << endl;\n\n    return true;\n}\n\nint main() {\n    while(solve());\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\nlong long int l[100];\nlong long int r[100];\n\nlong long int ln[100];\nlong long int rn[100];\n\nbool use[100];\n\nlong long int ko(long long int a,long long int b)\n{\n\twhile(1)\n\t{\n\t\tlong long int w = a % b;\n\t\tif(w == 0)\n\t\t{\n\t\t\treturn b;\n\t\t}\n\t\ta = b;\n\t\tb = w;\n\t}\n}\n\nlong long int ju(int b)\n{\n\tlong long int ld,rd;\n\tif(l[b] >= 0)\n\t{\n\t\tld = ju(l[b]);\n\t}\n\telse\n\t{\n\t\tld = 1;\n\t}\n\tif(r[b] >= 0)\n\t{\n\t\trd = ju(l[b]);\n\t}\n\telse\n\t{\n\t\trd = 1;\n\t}\n\tlong long int lk = ld * ln[b];\n\tlong long int rk = rd * rn[b];\n\tlong long int w = ko(lk,rk);\n\tlong long int sai = lk * rk / w;\n\treturn sai / ln[b] + sai / rn[b];\n}\n\nint main()\n{\n\twhile(1)\n\t{\n\t\tint n;\n\t\tscanf(\"%d\",&n);\n\t\tif(n == 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tint lw,rw;\n\t\t\tscanf(\"%d %d\",&lw,&rw);\n\t\t\tl[i] = lw - 1;\n\t\t\tr[i] = rw - 1;\n\t\t}\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tuse[i] = true;\n\t\t}\n\t\tfor(int i = 0; i < 100; i++)\n\t\t{\n\t\t\tif(l[i] >= 0)\n\t\t\t{\n\t\t\t\tuse[l[i]] = false;\n\t\t\t}\n\t\t\tif(r[i] >= 0)\n\t\t\t{\n\t\t\t\tuse[r[i]] = false;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tlong long int lw,rw;\n\t\t\tscanf(\"%lld %lld\",&lw,&rw);\n\t\t\tlong long int w = ko(lw,rw);\n\t\t\tln[i] = lw / w;\n\t\t\trn[i] = rw / w;\n\t\t}\n\t\tint oya;\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tif(use[i])\n\t\t\t{\n\t\t\t\toya = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",ju(oya));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 100000005\n#define MAX 5001\nusing namespace std;\n//__gcd(a,b), __builtin_popcount(a);\n\nint lcm(int n, int m){\n\tif(!n || !m)return 0;\n\treturn n/__gcd(n, m)*m;\n}\nint a[101][4];\n\nint solve(int k){\n\tint l = -1, r = -1, ans = 0, t1 = 0;\n\tint x = a[k][0], y = a[k][1];\n\tif(a[k][2] != 0)l = solve(a[k][2]);\n\tif(a[k][3] != 0)r = solve(a[k][3]);\n\tif(l == -1 && r == -1)ans = (lcm(x, y)*(x+y))/(x*y);\n\telse if(l != -1 && r != -1){\n\t\tt1 = lcm(x*l, y*r);\n\t\tans = t1/x+t1/y;\n\t}else{\n\t\tif(l == -1){\n\t\t\tr *= x/__gcd(x, r*y);\n\t\t\tl = (r*y)/x;\n\t\t}\n\t\tif(r == -1){\n\t\t\tl *= y/__gcd(y, l*x);\n\t\t\tr = (l*x)/y;\n\t\t}\n\t\tans = l+r;\n\t}\n\t//cout << k << \" \" << ans << endl;\n\treturn ans;\n}\n\nint used[101];\nint main(){\n\tint n, st = 0;\n\twhile(cin >> n, n){\n\t\tfill(used, used+101, 0);\n\t\tfor(int i = 1;i <= n;i++){\n\t\t\tfor(int j = 0;j < 4;j++){\n\t\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t\t\tif(2<=j)used[a[i][j]] = 1;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 1;i <= n;i++)if(!used[i])st = i;\n\t\tint ans = solve(st);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <cstring>\nusing namespace std;\n\nint dp[110],K[110],O[110],L[110],R[110];\n\nint gcd(int a,int b){\n\tint tmp;\n\tif(a<b) swap(a,b);\n\twhile((tmp=a%b)!=0){\n\t\ta=b;\n\t\tb=tmp;\n\t}\n\treturn b;\n}\n\n\nint mobi(int bou){\n\tif(bou==0) return 1;\n\tif(dp[bou]!=0) return dp[bou];\n\tint l,r,li,ri,gc2,a,b;\n\tl=mobi(L[bou]);\n\tr=mobi(R[bou]);\n\tri=K[bou];li=O[bou];\n\tgc2=gcd(li*l,ri*r);\n\tb=li*l/gc2;\n\ta=ri*r/gc2;\n\tdp[bou]=(a*l+b*r);\n\treturn dp[bou];\n}\n\nint main(){\n\tint N,k,o,g;\n\tint res;\n\twhile(1){\n\t\tcin>>N;\n\t\tif(N==0) break;\n\t\tmemset(dp,0,sizeof(dp));\n\t\tK[0]=O[0]=L[0]=R[0]=0;\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tcin>>k>>o>>L[i]>>R[i];\n\t\t\tg=gcd(k,o);\n\t\t\tK[i]=k/g;\n\t\t\tO[i]=o/g;\n\t\t}\n\t\tres=0;\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tres=max(res,mobi(i));\n\t\t}\n\t\t/*\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tcout<<i<<\" \"<<dp[i]<<endl;//\n\t\t}\n\t\t*/\n\t\tcout<<res<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nstruct DATA{\n  int l_l, l_r;\n  int n_l, n_r;\n};\n\nvector<DATA> data;\n\nint gcd(int a, int b){\n  if(b == 0) return a;\n  return gcd(b, a%b);\n}\n\nint search_miss_num(vector<int>& num){\n  sort(num.begin(), num.end());\n  for(int i=0; i<num.size(); ++i){\n    if(num[i] != i+1) return i;\n  }\n  return num.size();\n}\n\nint solve(int n){\n  //  cout << n << endl;\n  int GCD, g_l, g_r;\n\n  if(data[n].n_l == 0) g_l = 1;\n  else g_l = solve(data[n].n_l -1);\n\n  if(data[n].n_r == 0) g_r = 1;\n  else g_r = solve(data[n].n_r -1);\n\n  GCD = gcd(g_l * data[n].l_l, g_r * data[n].l_r);\n  return g_l * ((g_r * data[n].l_r)/GCD) + g_r * ((g_l * data[n].l_l)/GCD);\n}\n\nint main(){\n  int n, GCD;\n  DATA data_;\n  vector<int> num;\n\n  while(1){\n    cin >> n;\n    if(n == 0) break;\n\n    num.clear();\n    data.clear();\n\n    for(int i=0; i<n; ++i){\n      cin >> data_.l_l >> data_.l_r >> data_.n_l >> data_.n_r;\n      GCD = gcd(data_.l_l, data_.l_r);\n      data_.l_l /= GCD;\n      data_.l_r /= GCD;\n      if(data_.n_l != 0) num.push_back(data_.n_l);\n      if(data_.n_r != 0) num.push_back(data_.n_r);\n      data.push_back(data_);\n    }\n    cout << solve(search_miss_num(num)) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <cstring>\nusing namespace std;\n\nunsigned int dp[110],K[110],O[110],L[110],R[110];\n\nunsigned int gcd(unsigned int a,unsigned int b){\n\tunsigned int tmp;\n\twhile((a%b)!=0){\n\t\ttmp=a%b;\n\t\ta=b;\n\t\tb=tmp;\n\t}\n\treturn b;\n}\n\n\nunsigned int mobi(unsigned int bou){\n\tif(bou==0) return 1;\n\tif(dp[bou]!=0) return dp[bou];\n\tunsigned int l,r,li,ri,gc,gc2,a,b;\n\tl=mobi(L[bou]);\n\tr=mobi(R[bou]);\n\tri=K[bou];li=O[bou];\n\tgc=gcd(li,ri);\n\tli/=gc;ri/=gc;\n\tgc2=gcd(li*l,ri*r);\n\tb=li*l/gc2;\n\ta=ri*r/gc2;\n\tdp[bou]=(a*l+b*r);\n\treturn dp[bou];\n}\n\nint main(){\n\tint N;\n\tunsigned int res;\n\twhile(1){\n\t\tcin>>N;\n\t\tif(N==0) break;\n\t\tmemset(dp,0,sizeof(dp));\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tcin>>K[i]>>O[i]>>L[i]>>R[i];\n\t\t}\n\t\tres=0;\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tres=max(res,mobi(i));\n\t\t}\n\t\t/*\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tcout<<i<<\" \"<<dp[i]<<endl;//\n\t\t}\n\t\t*/\n\t\tcout<<res<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nstruct S{int p,q,r,b;}a[101];\ntypedef long long L;\nL GCD(L x,L y)\n{\n\tif(!y)return x;\n\treturn GCD(y,x%y);\n}\nL LCM(L x,L y)\n{\n\treturn x/GCD(x,y)*y;\n}\nL F(int i)\n{\n\tif(!i)return 1;\n\tS&s=a[i];\n\tL r=F(s.r),b=F(s.b);\n\tL l=LCM(s.p*r,s.q*b);\n\treturn l/s.p+l/s.q;\n}\nint main()\n{\n\tint n,i,g;\n\tS s;\n\twhile(scanf(\"%d\",&n),n)\n\t{\n\t\tint f[101]={1};\n\t\tfor(i=0;i<n;++i)\n\t\t{\n\t\t\tscanf(\"%d%d%d%d\",&s.p,&s.q,&s.r,&s.b);\n\t\t\tf[s.r]=1;\n\t\t\tf[s.b]=1;\n\t\t\tg=GCD(s.p,s.q);\n\t\t\ts.p/=g;\n\t\t\ts.q/=g;\n\t\t\ta[i+1]=s;\n\t\t}\n\t\tprintf(\"%lld\\n\",F(std::find(f,f+n,0)-f));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nint red[100];\nint blue[100];\nint le[100];\nint ri[100];\n\nint gcd(int a,int b){\n\tif(b>a){\ta^=b;\tb^=a;\ta^=b;\t}\n\twhile(1){\n\t\tint temp=a%b;\n\t\tif(temp==0)\tbreak;\n\t\ta=b;\tb=temp;\n\t}\n\treturn b;\n}\n\nint dfs(int now){\n\tint l=1,r=1;\n\tif(le[now]!=0)\tl*=dfs(le[now]-1);\n\tif(ri[now]!=0)\tr*=dfs(ri[now]-1);\n\tint g=gcd(blue[now]*r,red[now]*l);\n\tint ans=blue[now]*r*red[now]*l/g;\n\treturn ans/blue[now]+ans/red[now];\t\n}\n\t\nint main(){\n\twhile(true){\n\t\tcin>>n;\n\t\tif(n==0)\treturn 0;\n\t\tvector<int> parent(n,-1);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>red[i]>>blue[i]>>le[i]>>ri[i];\n\t\t\tif(le[i]!=0)\tparent[le[i]-1]=i;\t\n\t\t\tif(ri[i]!=0)\tparent[ri[i]-1]=i;\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(parent[i]==-1){\n\t\t\t\tcout<<dfs(i)<<endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\n\nusing namespace std;\ntypedef long long ll;\n\n#define INF 2000000000\n#define LLINF 4000000000000000000\n#define SIZE 100\n\nint mo[5] = {0,1,0,-1,0};\n\nstruct STICK{\n    int l_l,l_r,s_l,s_r;\n};\n\nSTICK stick[SIZE+10];\n\nint gcd(int a,int b){\n    if(a==0)\n        return b;\n    return gcd(b%a,a);\n}\n\nint lcm(int a,int b){\n    return a/gcd(a,b)*b;\n}\n\nint dfs(int s_num){\n    int v_l,v_r,af_l,af_r,times;\n    \n    if(stick[s_num].s_l == 0 && stick[s_num].s_r == 0) return stick[s_num].l_l + stick[s_num].l_r;\n    \n    if(stick[s_num].s_l > 0){\n        v_l = dfs(stick[s_num].s_l);\n    }else{\n        v_l = 1;\n    }\n    \n    if(stick[s_num].s_r > 0){\n        v_r = dfs(stick[s_num].s_r);\n    }else{\n        v_r = 1;\n    }\n    \n    \n    af_r=lcm(stick[s_num].l_l,v_r);\n    af_l=lcm(stick[s_num].l_r,v_l);\n    \n    times = lcm(af_r/stick[s_num].l_l,af_l/stick[s_num].l_r);\n    \n    return (stick[s_num].l_l+stick[s_num].l_r) * times;\n}\n\nvoid calc(int n){\n    bool top[SIZE+1]={0};\n    \n    \n    for(int i=1;i<=n;i++){\n        scanf(\"%d%d%d%d\",&stick[i].l_l,&stick[i].l_r,&stick[i].s_l,&stick[i].s_r);\n        \n        int G = gcd(stick[i].l_l,stick[i].l_r);\n        \n        stick[i].l_l/=G;\n        stick[i].l_r/=G;\n        \n        top[stick[i].s_l] =true;\n        top[stick[i].s_r] =true;\n    }\n    \n    for(int i=1;i<=n;i++){\n        if(top[i]==false){\n            printf(\"%d\\n\",dfs(i));\n            return;\n        }\n    }\n    \n}\n\nint main(){\n    int n;\n    \n    while(1){\n        scanf(\"%d\",&n);\n        if(n==0) break;\n        calc(n);\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint n;\nint i,j;\nint ans;\nint order;\ntypedef struct{\n\tint wl,wr,tl,tr,le,ri;\n\tbool flag;\n}t_stick;\nt_stick st[100];\n\nint max(int a,int b){\n\tif(a>=b)return a;\n\telse return b;\n}\n\nint min(int a,int b){\n\tif(a<=b)return a;\n\telse return b;\n}\n\nint gcd(int a,int b){\n\tint x,y;\n\tx=max(a,b);\n\ty=min(a,b);\n\tif(a%b==0)return b;\n\telse return gcd(b,a%b);\n}\n\nint main(){\n\tint n,m;\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)return 0;\n\t\tans=0;\n\t\torder=0;\n\t\tfor(i=0;i<n;i++){\n\t\t\tint p,q,r,s;\n\t\t\tscanf(\"%d %d %d %d\",&p,&q,&r,&s);\n\t\t\tst[i].tl=p;\n\t\t\tst[i].tr=q;\n\t\t\tst[i].le=r-1;\n\t\t\tst[i].ri=s-1;\n\t\t}\n\t\tfor(i=0;i<n;i++){\n\t\t\tst[i].wl=0;\n\t\t\tst[i].wr=0;\n\t\t\tst[i].flag=false;\t\n\t\t}\n\t\twhile(1){\n\t\t\tfor(i=0;i<n;i++){\n\t\t\t\tif(st[i].le!=-1&&st[st[i].le].flag){\n\t\t\t\t\tst[i].wl=st[st[i].le].wl+st[st[i].le].wr;\n\t\t\t\t\tst[i].le=-1;\n\t\t\t\t}\n\t\t\t\tif(st[i].ri!=-1&&st[st[i].ri].flag){\n\t\t\t\t\tst[i].wr=st[st[i].ri].wl+st[st[i].ri].wr;\n\t\t\t\t\tst[i].ri=-1;\n\t\t\t\t}\n\t\t\t\tif(!st[i].flag&&st[i].le==-1&&st[i].ri==-1){\n\t\t\t\t\tif(st[i].wl==0&&st[i].wr==0){\n\t\t\t\t\t\tst[i].wl=st[i].tr/gcd(st[i].tl,st[i].tr);\n\t\t\t\t\t\tst[i].wr=st[i].tl/gcd(st[i].tl,st[i].tr);\n\t\t\t\t\t}\n\t\t\t\t\telse if(st[i].wl==0){\n\t\t\t\t\t\tint x=st[i].tl/gcd(st[i].tl,st[i].tr);\n\t\t\t\t\t\tst[i].wr*=x/gcd(st[i].wr,x);\n\t\t\t\t\t\tst[i].wl=st[i].wr*st[i].tr/st[i].tl;\n\t\t\t\t\t}\n\t\t\t\t\telse if(st[i].wr==0){\n\t\t\t\t\t\tint x=st[i].tr/gcd(st[i].tl,st[i].tr);\n\t\t\t\t\t\tst[i].wl*=x/gcd(st[i].wl,x);\n\t\t\t\t\t\tst[i].wr=st[i].wl*st[i].tl/st[i].tr;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tint x=st[i].tr*st[i].wr/gcd(st[i].tr*st[i].wr,st[i].tl);\n\t\t\t\t\t\tst[i].wl*=x/gcd(st[i].wl,x);\n\t\t\t\t\t\tst[i].wr=st[i].wl*st[i].tl/st[i].tr;\n\t\t\t\t\t}\n\t\t\t\t\tst[i].flag=true;\n\t\t\t\t\tif(order==n-1)ans=st[i].wl+st[i].wr;\n\t\t\t\t\torder++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(order==n)break;\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#define F first\n#define S second\n\nusing namespace std;\n\nclass Pox\n{\npublic:\n  int rlen,llen,rnext,lnext;\n  Pox(int rlen = 0,int llen = 0,int rnext = 0,int lnext = 0):rlen(rlen),llen(llen),rnext(rnext),lnext(lnext){}\n};\n\nint lcm(int a,int b)\n{\n  return a/__gcd(a,b)*b;\n}\n\nint rec(vector<Pox>& G,int p)\n{\n\n  int rcost = !G[p].rnext?1:rec(G,G[p].rnext);\n  int lcost = !G[p].lnext?1:rec(G,G[p].lnext);\n\n  int lc = lcm(rcost*G[p].rlen,lcost*G[p].llen);\n\n  return lc/G[p].rlen + lc/G[p].llen;\n\n}\n\nint main()\n{\n  int n;\n  while(cin >> n,n)\n    {\n      vector<Pox> G;\n      G.resize(n+1);\n      bool TPO[n+1];\n      for(int i=0;i<n+1;i++)\n\tTPO[i] = false;\n      for(int i=1;i<=n;i++)\n\t{\n\t  int a,b,c,d;\n\t  scanf(\"%d %d %d %d\",&a,&b,&c,&d);\n\t  G[i] = Pox(a,b,c,d);\n\t  TPO[c] = TPO[d] = true;\n\t}\n\n      int st = -1;\n      for(int i=1;i<=n;i++)\n\tif(!TPO[i])\n\t  {\n\t    st = i;\n\t    break;\n\t  }\n\t\n      cout << rec(G,st) << endl;\n\n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nll gcd(ll a, ll b) {\n  return b != 0 ? gcd(b, a % b) : a;\n}\nll lcm(ll a,ll b){\n  return a / gcd(a,b) * b;\n}\n\nconst ll WEIGHT=-1;\nstruct stick{\n\tll r,b,p,q;\n\tstick(ll r,ll b,ll p,ll q):r(r),b(b){\n\t\tll g=gcd(p,q);\n\t\tthis->p=p/g;\n\t\tthis->q=q/g;\n\t}\n\tll getroot(ll index,vector<stick> &sticks){\n\t\tREP(i,sticks.size()){\n\t\t\tif(sticks[i].r==index||sticks[i].b==index){\n\t\t\t\treturn sticks[i].getroot(i,sticks);\n\t\t\t}\n\t\t}\n\t\treturn index;\n\t}\n\tll go(vector<stick> &sticks){\n\t\tll rw=0,bw=0;\n\t\tif(r!=WEIGHT){\n\t\t\trw=sticks[r].go(sticks);\n\t\t}\n\t\tif(b!=WEIGHT){\n\t\t\tbw=sticks[b].go(sticks);\n\t\t}\n\t\tif(r==WEIGHT&&b==WEIGHT){\n\t\t\trw=q;\n\t\t\tbw=p;\n\t\t\tassert(rw);\n\t\t\tassert(bw);\n\t\t}else if(r==WEIGHT){\n\t\t\tif(p*bw%q){\n\t\t\t\trw=bw*p;\n\t\t\t\tbw*=q;\n\t\t\t}else{\n\t\t\t\trw=bw*p/q;\n\t\t\t\tassert(bw);\n\t\t\t}\n\t\t\tassert(rw);\n\t\t\tassert(bw);\n\t\t}else if(b==WEIGHT){\n\t\t\tif(q*rw%p){\n\t\t\t\tbw=rw*q;\n\t\t\t\trw*=p;\n\t\t\t}else{\n\t\t\t\tbw=rw*q/p;\n\t\t\t\tassert(rw);\n\t\t\t}\n\t\t\tassert(rw);\n\t\t\tassert(bw);\n\t\t}else{\n\t\t\tll l = lcm(p * rw, q * bw);\n\t\t\trw=l/p;\n\t\t\tbw=l/q;\n\t\t\tassert(rw);\n\t\t\tassert(bw);\n\t\t}\n\t\tassert(rw&&bw);\n\t\treturn rw+bw;\n\t}\n};\n\n\nint main(){\n\tll n;\n\twhile(cin>>n,n){\n\t\tvector<stick> sticks;\n\t\tREP(i,n){\n\t\t\tll p,q,r,b;\n\t\t\tcin>>p>>q>>r>>b;\n\t\t\tr--;b--;\n\t\t\tsticks.push_back(stick(r,b,p,q));\n\t\t}\n\t\tll root=sticks[0].getroot(0,sticks);\n\t\tcout<<sticks[root].go(sticks)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\nconst int INF = (1LL<<30);\nconst ll LLINF = (1LL<<60);\nconst double PI = 3.14159265359;\nconst double EPS = 1e-12;\nconst int MOD = 1000000007;\n//#define int ll\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\n/*??????????????¢?????????*/\nint p[105], q[105], r[105], b[105];\nint dp[105];\nbool root[105];\nint dfs(int num) {\n  if(num == -1) return 1;\n  if(dp[num] != -1) return dp[num];\n  // dfs(r) * const : dfs(b) * const = q[i] : p[i]\n  int left = dfs(r[num]), right = dfs(b[num]);\n  // right * q[i] * ?????°(lv) = left * p[i] * ?????°(rv) ??¨???????????????????°?????????°?????????????????????\n  // lv : rv = l*p : r*q\n  int lv = right*q[num], rv = left*p[num], g = __gcd(lv, rv);\n  lv /= g, rv /= g;\n  return dp[num] = right * rv + left * lv;\n}\n\nsigned main(void)\n{\n  while(true) {\n    int n;\n    cin >> n;\n    if(!n) break;\n    // cout << \"n:\" << n << endl;\n    REP(i, n) cin >> p[i] >> q[i] >> r[i] >> b[i],r[i]--,b[i]--;\n\n    memset(root, true, sizeof(root));\n    REP(i, n) root[r[i]] = root[b[i]] = false;\n    int rt = -1;\n    REP(i, n) if(root[i]) rt = i;\n    if(rt == -1) assert(false);\n\n    memset(dp, -1, sizeof(dp));\n    REP(i, n) if(dp[i] == -1) dfs(i);\n    // REP(i, n) cout << dp[i] << \",\"; cout << endl;\n    cout << dp[rt] << endl;\n  }\n  // cout << \"b\" << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nll gcd(ll a, ll b) {\n  return b != 0 ? gcd(b, a % b) : a;\n}\nll lcm(ll a,ll b){\n  return a / gcd(a,b) * b;\n}\n\nconst ll WEIGHT=-1;\nstruct stick{\n\tll r,b,p,q;\n\tstick(ll r,ll b,ll p,ll q):r(r),b(b){\n\t\tll g=gcd(p,q);\n\t\tthis->p=p/g;\n\t\tthis->q=q/g;\n\t}\n\tll getroot(ll index,vector<stick> &sticks){\n\t\tREP(i,sticks.size()){\n\t\t\tif(sticks[i].r==index||sticks[i].b==index){\n\t\t\t\treturn sticks[i].getroot(i,sticks);\n\t\t\t}\n\t\t}\n\t\treturn index;\n\t}\n\tll go(vector<stick> &sticks){\n\t\tll rw=0,bw=0;\n\t\tif(r!=WEIGHT){\n\t\t\trw=sticks[r].go(sticks);\n\t\t}\n\t\tif(b!=WEIGHT){\n\t\t\tbw=sticks[b].go(sticks);\n\t\t}\n\t\tif(r==WEIGHT&&b==WEIGHT){\n\t\t\trw=q;\n\t\t\tbw=p;\n\t\t}else if(r==WEIGHT){\n\t\t\tif(p*bw%q){\n\t\t\t\trw=bw*p;\n\t\t\t\tbw*=q;\n\t\t\t}else{\n\t\t\t\trw=bw*p/q;\n\t\t\t\tassert(bw);\n\t\t\t}\n\t\t}else if(b==WEIGHT){\n\t\t\tif(q*rw%p){\n\t\t\t\tbw=rw*q;\n\t\t\t\trw*=p;\n\t\t\t}else{\n\t\t\t\tbw=rw*q/p;\n\t\t\t\tassert(rw);\n\t\t\t}\n\t\t}else{\n\t\t\tll l = lcm(p * rw, q * bw);\n\t\t\tcerr<<l<<\",\"<<p<<\",\"<<q<<endl;\n\t\t\trw=l/p;\n\t\t\tbw=l/q;\n\t\t\tassert(rw);\n\t\t\tassert(bw);\n\t\t}\n\t\tassert(rw&&bw);\n\t\treturn rw+bw;\n\t}\n};\n\n\nint main(){\n\tll n;\n\twhile(cin>>n,n){\n\t\tvector<stick> sticks;\n\t\tREP(i,n){\n\t\t\tll p,q,r,b;\n\t\t\tcin>>p>>q>>r>>b;\n\t\t\tr--;b--;\n\t\t\tsticks.push_back(stick(r,b,p,q));\n\t\t}\n\t\tll root=sticks[0].getroot(0,sticks);\n\t\tcout<<sticks[root].go(sticks)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\nint p[100],q[100],r[100],s[100];\n\nint gcd(int x,int y){\n  while(x>0){\n    y %= x;\n    int t = x;\n    x = y;\n    y = t;\n  }\n  return y;\n}\n\nint dfs(int v){\n  if(v==-1){\n    return 1;\n  }else{\n    int right = dfs(r[v]);\n    int left = dfs(s[v]);\n    int g = gcd(p[v],q[v]);\n    p[v]/=g; q[v]/=g;\n    p[v] *= left; q[v] *= right;\n    g = gcd(p[v],q[v]);\n    p[v]/=g; q[v]/=g;\n    right *= p[v]; left *= q[v];\n    return right + left;\n  }\n}\n\nint solve(){\n  int n,V;\n  bool flag[100];\n  scanf(\"%d\",&n);\n  if(n==0) return -1;\n  fill(flag,flag+n,false);\n  for(int i=0;i<n;i++){\n    scanf(\"%d %d %d %d\",p+i,q+i,r+i,s+i);\n    r[i]--; s[i]--;\n    if(r[i]>=0) flag[r[i]] = true;\n    if(s[i]>=0) flag[s[i]] = true;\n  }\n  for(int i=0;i<n;i++) if(!flag[i]) V = i;\n  int ans = dfs(V);\n  printf(\"%d\\n\",ans);\n  return ans;\n}\n\nint main(){\n  while(true){\n    if(solve()<0) break;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint a[100+2],b[100+2],c[100+2],d[100+2],w[100+2],n;\n\nint s(int x){\n\tint ans;\n\tif(w[x]!=-1)return w[x];\n\telse {\n\t\tint e=a[x]*s(c[x]),f=b[x]*s(d[x]);\n\t\tint g=e,h=f,gcd;\n\t\twhile(1){\n\t\t\tg%=h;\n\t\t\tif(g==0)break;\n\t\t\th%=g;\n\t\t\tif(h==0)break;\n\t\t}\n\t\tgcd=e*f/max(g,h);\n\t\tans=gcd/a[x]+gcd/b[x];\n\t}\n\tw[x]=ans;\n\treturn ans;\n}\n\nint main(){\nwhile(1){\n\tint an=0;\n\tscanf(\"%d\",&n);\n\tif(n==0)break;\n\tw[0]=1;\n\tfor(int i=1;i<=n;i++){scanf(\"%d%d%d%d\",&a[i],&b[i],&c[i],&d[i]); w[i]=-1;}\n\tfor(int i=1;i<=n;i++){\n\t\tif(w[i]==-1)a[101]=s(i);\n\t\tif(an<w[i])an=w[i];\n\t}\n\tprintf(\"%d\\n\",an);\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\nint d[101][4];\nlong gcd(long a,long b){\n  long c;\n  while(b){\n    c=a;a=b;b=c%b;\n  }\n  return a;\n}\nlong f(long m){\n  long w,r,l;\n  if(!m) w=1;\n  else{\n    r=f(d[m][2]);l=f(d[m][3]);\n    w=r*l*d[m][0]*d[m][1]/(gcd(r*d[m][0],l*d[m][1]));\n    w=w/d[m][0]+w/d[m][1];\n  }\n  return w;\n}\nint main(){\n  int n,t;\n  bool fl[101];\n  while(cin>>n,n){\n    memset(fl,0,sizeof(fl));\n    for(int i=1;i<=n;++i){\n      cin>>d[i][0]>>d[i][1]>>d[i][2]>>d[i][3];\n      fl[d[i][2]]=fl[d[i][3]]=true;\n    }\n    for(int i=1;i<=n;++i){\n      if(!fl[i]){\n\tt=i;break;\n      }\n    }\n    cout<<f(t)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint dp[110],K[110],O[110],L[110],R[110];\n\nint gcd(int a,int b){\n\tint tmp;\n\twhile((a%b)!=0){\n\t\ttmp=a%b;\n\t\ta=b;\n\t\tb=tmp;\n\t}\n\treturn b;\n}\n\n\nunsigned int mobi(unsigned int bou){\n\tif(bou==0) return 1;\n\tif(dp[bou]!=0) return dp[bou];\n\tunsigned int l,r,li,ri,gc,gc2,a,b;\n\tl=mobi(L[bou]);\n\tr=mobi(R[bou]);\n\tri=K[bou];li=O[bou];\n\tgc=gcd(li,ri);\n\tli/=gc;ri/=gc;\n\tgc2=gcd(li*l,ri*r);\n\tb=li*l/gc2;\n\ta=ri*r/gc2;\n\tdp[bou]=(a*l+b*r);\n\treturn dp[bou];\n}\n\nint main(){\n\tint N;\n\tunsigned int res;\n\twhile(1){\n\t\tcin>>N;\n\t\tif(N==0) break;\n\t\tmemset(dp,0,sizeof(dp));\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tcin>>K[i]>>O[i]>>L[i]>>R[i];\n\t\t}\n\t\tres=0;\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tres=max(res,mobi(i));\n\t\t}\n\t\t/*\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tcout<<i<<\" \"<<dp[i]<<endl;//\n\t\t}\n\t\t*/\n\t\tcout<<res<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint x[100][2],w[100][2],n;\nbool cal[110];\nint COU(int a,int b){\n??while(true){\n????if(a<2||b<2)return 1;\n????if(a<b){int t=a;a=b,b=t;}\n????a%=b;\n????if(!a)return b;\n??}\n}\nlong long DFS(int q){\n????????if(!q)return 1;\n????????q--;\n????????long long a=DFS(w[q][0]),b=DFS(w[q][1]);\n????????return (a*b*(x[q][0]+x[q][1]))/COU(a*x[q][0],b*x[q][1]);\n}\nint main(){\n??while(true){\n??cin>>n;\n??if(!n)break;\n??for(int i=0;i<n;i++)cal[i]=false;\n??for(int i=0;i<n;i++){\n????cin>>x[i][0]>>x[i][1]>>w[i][0]>>w[i][1];\n????cal[w[i][0]-1]=true,cal[w[i][1]-1]=true;\n??}\n??for(int i=0;i<n;i++)if(!cal[i])cout<<DFS(i+1)<<endl;\n??}\n??return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\nstruct Bar {\n\tint p,q,r,b;\n\tBar (int _p,int _q,int _r,int _b) {\n\t\tp=_p,q=_q,r=_r,b=_b;\n\t}\n};\nstruct Fraction {\n\tint bunbo,bunshi;\n\tFraction (int _bunbo,int _bunshi) {\n\t\tbunbo=_bunbo,bunshi=_bunshi;\n\t}\n};\nint n;\nvector<Bar> Bars;\nvector<Fraction> Fractions;\nbool child[100];\nvoid solve(int X,Fraction C) {\n\tif(Bars[X].r>0) solve(Bars[X].r-1,Fraction(C.bunbo*(Bars[X].p+Bars[X].q),C.bunshi*Bars[X].q));\n\telse Fractions.push_back(Fraction(C.bunbo*(Bars[X].p+Bars[X].q),C.bunshi*Bars[X].q));\n\tif(Bars[X].b>0) solve(Bars[X].b-1,Fraction(C.bunbo*(Bars[X].p+Bars[X].q),C.bunshi*Bars[X].p));\n\telse Fractions.push_back(Fraction(C.bunbo*(Bars[X].p+Bars[X].q),C.bunshi*Bars[X].p));\n}\nint gcd(int a,int b) {\n\treturn b?gcd(b,a%b):a;\n}\nint lcm(int a,int b) {\n\treturn a/gcd(a,b)*b;\n}\nint main() {\n\twhile(scanf(\"%d\",&n),n) {\n\t\tBars.clear();\n\t\tFractions.clear();\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tint p,q,r,b;\n\t\t\tscanf(\"%d %d %d %d\",&p,&q,&r,&b);\n\t\t\tif(r>0) child[r-1]=true;\n\t\t\tif(b>0) child[b-1]=true;\n\t\t\tBars.push_back(Bar(p,q,r,b));\n\t\t}\n\t\tint par=0;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tif(!child[i]) {par=i;break;}\n\t\t}\n\t\tsolve(par,Fraction(1,1));\n\t\tint L=1;\n\t\tfor(int i=0;i<Fractions.size();i++) {\n\t\t\tint G=gcd(Fractions[i].bunbo,Fractions[i].bunshi);\n\t\t\tFractions[i].bunbo/=G;\n\t\t\tL=lcm(L,Fractions[i].bunbo);\n\t\t}\n\t\tprintf(\"%d\\n\",L);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\ntypedef struct Node {\n\tint p, q, r, b;\n} Node;\n\nint gcd(int a, int b){\n\tif(a < b){ return gcd(b, a); }\n\tif(b > 0){ return gcd(b, a % b); }\n\treturn a;\n}\nint lcm(int a, int b){\n\tlong long tmp = a;\n\ttmp *= b;\n\treturn (int)(tmp / gcd(a, b));\n}\n\nNode nodes[101];\n\nint calculate(int n){\n\tint d = gcd(nodes[n].p, nodes[n].q);\n\tint op = nodes[n].p / d, oq = nodes[n].q / d, answer;\n\tif(nodes[n].r == 0 && nodes[n].b == 0){\n\t\tanswer = op + oq;\n\t}else if(nodes[n].r == 0){\n\t\tint t = lcm(oq, calculate(nodes[n].b) * op);\n\t\tanswer = t / op + t / oq;\n\t}else if(nodes[n].b == 0){\n\t\tint t = lcm(op, calculate(nodes[n].r) * oq);\n\t\tanswer = t / op + t / oq;\n\t}else{\n\t\tint t = lcm(op * calculate(nodes[n].b), oq * calculate(nodes[n].r));\n\t\tanswer = t / op + t / oq;\n\t}\n\treturn answer;\n}\n\nint main(){\n\twhile(true){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n == 0){ break; }\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tcin >> nodes[i].p >> nodes[i].q >> nodes[i].r >> nodes[i].b;\n\t\t}\n\t\tbool flags[101] = { false };\n\t\tint remains = n;\n\t\twhile(remains > 1){\n\t\t\tbool tmpflg[101] = { false };\n\t\t\tfor(int i = 1; i <= n; i++){\n\t\t\t\tif(flags[i]){ continue; }\n\t\t\t\tif(\n\t\t\t\t\t(nodes[i].r == 0 && nodes[i].b == 0) ||\n\t\t\t\t\t(nodes[i].r == 0 && flags[nodes[i].b]) ||\n\t\t\t\t\t(flags[nodes[i].r] && nodes[i].b == 0) ||\n\t\t\t\t\t(flags[nodes[i].r] && flags[nodes[i].b])\n\t\t\t\t){\n\t\t\t\t\ttmpflg[i] = true;\n\t\t\t\t\tremains--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 1; i <= n; i++){\n\t\t\t\tflags[i] |= tmpflg[i];\n\t\t\t}\n\t\t}\n\t\tint root;\n\t\tfor(root = 1; root <= n; root++){\n\t\t\tif(!flags[root]){ break; }\n\t\t}\n\t\tprintf(\"%d\\n\", calculate(root));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#define max(a,b) (a>b?a:b)\nlong long int a[101],b[101],c[101],d[101],memo[101],res=0;\n\nlong long int gcd(long long int x,long long int y){\n\tif(x==0)return y;\n\telse return gcd(y%x,x);\n}\nlong long int solve(int x){\n\tif(memo[x]!=0)return memo[x];\n\tint left=a[x]*solve(c[x]),right=b[x]*solve(d[x]),gc;\n\tgc=gcd(left,right);\n\treturn memo[x]=right/gc*solve(c[x])+left/gc*solve(d[x]);\n}\n\nint main(){\n\tmemo[0]=1;\n\tint n;\n\tfor(;scanf(\"%d\",&n),n;){\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tscanf(\"%lld%lld%lld%lld\",a+i,b+i,c+i,d+i);\n\t\t}\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tres=max(res,solve(i));\n\t\t}\n\t\tprintf(\"%lld\\n\",res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps = 1e-9;\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.txt\"\n\nlong long int gcd(long long int l, long long int r) {\n\tassert(l > 0 && r > 0);\n\tif (l > r)return gcd(r, l);\n\telse {\n\t\tconst long long int num = r%l;\n\t\tif (num) {\n\t\t\treturn gcd(l, num);\n\t\t}\n\t\telse {\n\t\t\treturn l;\n\t\t}\n\t}\n}\nlong long int lca(long long int l, long long int r) {\n\treturn l / gcd(l, r)*r;\n}\n\nstruct mobi {\n\tlong long int a;\n\tlong long int b;\n\tint lid;\n\tint rid;\n\n};\n\nlong long int getans(const int id,const vector<mobi>&ms) {\n\tlong long int lw=0, rw=0;\n\tif (ms[id].lid!=-1) {\n\t\tlw = getans(ms[id].lid, ms);\n\t}\n\telse {\n\t\tlw = 1;\n\t}\n\tif (ms[id].rid != -1) {\n\t\trw = getans(ms[id].rid, ms);\n\t}\n\telse {\n\t\trw = 1;\n\t}\n\tlong long int al = lw*ms[id].b;\n\tlong long int ar = rw*ms[id].a;\n\tlong long int alca = lca(al, ar);\n\treturn alca / al*lw + alca / ar*rw;\n}\n\nint main() {\n\twhile (1) {\n\t\tint N; cin >> N;\n\t\tif (!N)break;\n\t\tvector<mobi>ms;\n\t\tvector<int>pas(N);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tlong long int a, b;int lid, rid; cin >> a >> b >> lid >> rid;\n\t\t\tlid--; rid--;\n\t\t\tif (lid != -1)pas[lid] = true;\n\t\t\tif (rid != -1)pas[rid] = true;\n\t\t\tconst long long int agcd = gcd(a, b);\n\t\t\ta /= agcd; b /= agcd;\n\t\t\tms.push_back(mobi{ a,b,lid,rid });\n\t\t}\n\t\tint nopa = find(pas.begin(), pas.end(), 0) - pas.begin();\n\t\tlong long int ans = getans(nopa, ms);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nlong long int n,mem[110][5],sum;\nlong long int F(int n1,int n2)\n{\n    long long int s1,s2;\n    s1 = min(n1,n2);\n    s2 = max(n1,n2);\n    if(s1 == 0)return s2;\n    return F(s2 % s1,s1);\n}\nlong long int min_w(int n_mobile)\n{\n    long long int n1,n2,lim,longth,s1,s2;\n    if(mem[n_mobile][2] == 0)n1 = 1;\n    else n1 = min_w(mem[n_mobile][2] - 1);\n    if(mem[n_mobile][3] == 0)n2 = 1;\n    else n2 = min_w(mem[n_mobile][3] - 1);\n    longth = F(mem[n_mobile][0],mem[n_mobile][1]);\n    //printf(\"%d %d %d\\n\",n_mobile,lim,longth);\n    s1 = n1 / F(n1,mem[n_mobile][1] / longth);\n    s2 = n2 / F(n2,mem[n_mobile][0] / longth);\n    lim = F(min(s1,s2),max(s1,s2));\n    return ((s1 * s2) / lim) * ((mem[n_mobile][0] / longth) + (mem[n_mobile][1] / longth));\n}\nint main()\n{\n    while(scanf(\"%d\",&n),n)\n    {\n        sum = 0;\n        for(int i = 0; i < n; i++)\n        {\n            for(int j = 0; j < 4; j++)\n            {\n                scanf(\"%d\",&mem[i][j]);\n            }\n            sum += mem[i][2] + mem[i][3];\n        }\n        printf(\"%lld\\n\",min_w((n * (n + 1)) / 2 - sum - 1));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long int L;\n\nL gcd(L a, L b){\n    if(a<b) swap(a,b);\n    while(a%b){\n        L t = b;\n        b = a%b;\n        a = t;\n    }\n    return b;\n}\n\nstruct B{\n    L ral;\n    L rar;\n    B* left;\n    B* right; B* parent; B(){ ral = -1;\n        rar = -1;\n        left = NULL;\n        right = NULL;\n        parent = NULL;\n    }\n};\n\nvoid rec(B* p, L*& l,L n){\n    if( p->left ){\n        rec(p->left, l, n*(p->ral)/(p->ral+p->rar));\n    }else{\n        *l = n*(p->ral)/(p->ral+p->rar);\n        l++;\n    }\n    if( p->right ){\n        rec(p->right, l, n*(p->rar)/(p->ral+p->rar));\n    }else{\n        *l = n*(p->rar)/(p->ral+p->rar);\n        l++;\n    }\n\n}\n\nint main(){\n    L n,i,a,b,c,d,t,m,g,s;\n    for(;cin>>n,n;){\n        B v[100];\n        m=1;\n        for(i=0;i<n;i++){\n            cin>>a>>b>>c>>d;\n            t = gcd(a,b);\n            v[i].ral = b/t;\n            v[i].rar = a/t;\n            m *= b/t+a/t;\n            if( c ){\n                v[i].left = &v[--c];\n                v[c].parent = &v[i];\n            }\n            if( d ){\n                v[i].right = &v[--d];\n                v[d].parent = &v[i];\n            }\n        }\n        B* rt = v;\n        while( rt->parent ) rt = rt->parent;\n        L leaf[101];\n        L* ptr = leaf;\n        rec(rt, ptr, m);\n        g = leaf[0];\n        for(i=1;leaf[i]&&i<n+1;i++){\n            g = gcd(g,leaf[i]);\n        }\n        s=0;\n        for(i=0;i<n+1;i++){\n            s += leaf[i]/g;\n        }\n        cout << s << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\n#define\trep(i,n)\tfor(int i=0;i<n;i++)\n\nusing namespace std;\n\ntypedef\tunsigned long long\tull;\n\null gcd(ull a,ull b){ return b?gcd(b,a%b):a; }\n\nstruct Node{\n\tint p,q,l,r;\n\tNode(){}\n\tNode(int P,int Q,int L,int R):p(P),q(Q),l(L),r(R){}\n} node[100];\n\null dfs(int u){\n\tif(u==-1)\treturn 1;\n\n\tint p=node[u].p,q=node[u].q,l=node[u].l,r=node[u].r;\n\tull wl=dfs(l),wr=dfs(r);\n\tull g=gcd(p*wl,q*wr);\n\tull m=q*wr/g,n=p*wl/g;\n\n\treturn m*wl+n*wr;\n}\n\nint main(){\n\tfor(int n;scanf(\"%d\",&n),n;){\t\n\t\trep(i,n){\n\t\t\tint p,q,l,r;\tscanf(\"%d%d%d%d\",&p,&q,&l,&r);\n\t\t\tint g=gcd(p,q);\n\t\t\tnode[i]=Node(p/g,q/g,l-1,r-1);\n\t\t}\n\n\t\tint root;\n\t\tbool b[100]={};\n\t\trep(i,n){\n\t\t\tif(~node[i].l)\tb[node[i].l]=true;\n\t\t\tif(~node[i].r)\tb[node[i].r]=true;\n\t\t}\n\t\trep(i,n)if(!b[i]){ root=i; break; }\n\n\t\tprintf(\"%llu\\n\",dfs(root));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_N 100\ntypedef long long ll;\n\nvector<ll> p, q, r, b;\n\nbool dfs(int v, ll val)\n{\n  if (val == 0) {\n    if (r[v] != -1 || b[v] != -1) {\n      return 0;\n    }\n    return 1;\n  }\n  ll l = p[v] + q[v];\n  if (val * p[v] % l != 0) {\n    return 0;\n  }\n  if (val * q[v] % l != 0) {\n    return 0;\n  }\n  bool can = 1;\n  if (r[v] >= 0) {\n    can &= dfs(r[v], val*p[v]/l); \n  }\n  if (b[v] >= 0) {\n    can &= dfs(b[v], val*q[v]/l); \n  }\n  return can;\n}\n\nvoid init(int N)\n{\n  p.clear(); q.clear();\n  r.clear(); b.clear();\n  p.resize(N); q.resize(N);\n  r.resize(N); b.resize(N);\n}\n\nint main()\n{\n  int N;\n  while (cin >> N, N) {\n    init(N);\n    bool used[MAX_N] = {};\n    for (int i = 0; i < N; i++) {\n      cin >> p[i] >> q[i] >> r[i] >> b[i];\n      r[i]--; b[i]--;\n      if (r[i] >= 0) used[r[i]] = 1;\n      if (b[i] >= 0) used[b[i]] = 1;\n      int gcd = __gcd(p[i], q[i]);\n      p[i] /= gcd;\n      q[i] /= gcd;\n    }\n    int par = -1;\n    for (int i = 0; i < N; i++) {\n      if (!used[i]) {\n\tpar = i;\n\tbreak;\n      }\n    }\n    \n    for (int i = 1; i <= 1000000; i++) {\n      if (dfs(par, i)) {\n\tcout << i << endl;\n\tbreak;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n#define INF (int32)1e9\n#define REP(i, n) for(int64 i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int64 i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\nconst double eps = 1e-10;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value!=0>::type\nfill_v(U &u,const V... v){u=U(v...);}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_v(U &u,const V... v){\n  for(auto &e:u) fill_v<T>(e,v...);\n}\n\nvector<PLL> G;\nvector<PLL> vs;\n\nint64 lcm(int64 a, int64 b) {\n\treturn a / __gcd(a, b) * b;\n}\n\nint64 dfs(int64 v) {\n\tif (v == -1) return 1;\n\tint64 lw = dfs(G[v].fs), rw = dfs(G[v].sc);\n\tint64 g = __gcd(vs[v].fs*lw, vs[v].sc*rw);\n\tint64 lc = vs[v].sc*rw / g, rc = vs[v].fs*lw/g;\n\treturn lc*lw+rc*rw;\n}\n\nint main(void){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint64 n;\n\twhile (cin >> n && n) {\n\t\tG = vector<PLL>(n);\n\t\tvs = vector<PLL>(n);\n\t\tvector<int> cnt(n, 0);\n\t\tREP(i, n) {\n\t\t\tint64 p, q, r, b;\n\t\t\tcin >> p >> q >> r >> b; r--; b--;\n\t\t\tG[i] = PLL(r, b);\n\t\t\tif (r >= 0) cnt[r]++;\n\t\t\tif (b >= 0) cnt[b]++;\n\t\t\tvs[i] = PLL(p, q);\n\t\t}\n\t\tint root = -1;\n\t\tREP(i, n) {\n\t\t\tif (cnt[i] == 0) root = i;\n\t\t}\n\t\tcout << dfs(root) << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nint gcd(int a, int b) {\n  return b != 0 ? gcd(b, a % b) : a;\n}\n\nconst int WEIGHT=-1;\nstruct stick{\n\tint r,b,p,q;\n\tstick(int r,int b,int p,int q):r(r),b(b){\n\t\tint g=gcd(p,q);\n\t\tthis->p=p/g;\n\t\tthis->q=q/g;\n\t}\n\tint getroot(int index,vector<stick> &sticks){\n\t\tREP(i,sticks.size()){\n\t\t\tif(sticks[i].r==index||sticks[i].b==index){\n\t\t\t\treturn sticks[i].getroot(i,sticks);\n\t\t\t}\n\t\t}\n\t\treturn index;\n\t}\n\tint go(vector<stick> &sticks){\n\t\tll rw=0,bw=0;\n\t\tif(r!=WEIGHT){\n\t\t\trw=sticks[r].go(sticks);\n\t\t}\n\t\tif(b!=WEIGHT){\n\t\t\tbw=sticks[b].go(sticks);\n\t\t}\n\t\tif(r==WEIGHT&&b==WEIGHT){\n\t\t\trw=q;\n\t\t\tbw=p;\n\t\t}else if(r==WEIGHT){\n\t\t\tif(p*bw%q){\n\t\t\t\trw=bw*p;\n\t\t\t\tbw*=q;\n\t\t\t}else{\n\t\t\t\trw=bw*p/q;\n\t\t\t}\n\t\t}else if(b==WEIGHT){\n\t\t\tif(q*rw%p){\n\t\t\t\tbw=rw*q;\n\t\t\t\trw*=p;\n\t\t\t}else{\n\t\t\t\tbw=rw*q/p;\n\t\t\t}\n\t\t}else{\n\t\t\tll trw=rw,tbw=bw;\n\t\t\tll gr=gcd(rw,q);\n\t\t\tll gb=gcd(bw,p);\n\t\t\trw*=tbw*q/gr;\n\t\t\tbw*=trw*p/gb;\n\t\t}\n\t\tassert(rw&&bw);\n\t\treturn rw+bw;\n\t}\n};\n\n\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvector<stick> sticks;\n\t\tREP(i,n){\n\t\t\tint p,q,r,b;\n\t\t\tcin>>p>>q>>r>>b;\n\t\t\tr--;b--;\n\t\t\tsticks.push_back(stick(r,b,p,q));\n\t\t}\n\t\tint root=sticks[0].getroot(0,sticks);\n\t\tcout<<sticks[root].go(sticks)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nint gcd(int a,int b){\n    if(b==0)return a;\n    return gcd(b,a%b);\n    }  \n    int lcm(int a,int b){return a*b/gcd(a,b);}\nstruct bou{\n    int l,r,x,y;\n    };\n    int n[100];bou m[101];\nint mincost(int a){\n    if(n[a-1]!=-1)return n[a-1];\n    int b=1,c=1;\n    if(m[a].x)b=mincost(m[a].x);\n    if(m[a].y)c=mincost(m[a].y);\n    n[a-1]=lcm(b,c)*(m[a].l+m[a].r);\n    return lcm(b,c)*(m[a].l+m[a].r);\n    }\nsigned main(){\n   int a;\n   while(cin>>a,a){\n       memset(n,-1,sizeof(n));\n       bou g;\n       for(int b=1;b<=a;b++){\n\t   int c,d;\n\t  scanf(\"%d%d%d%d\",&c,&d,&g.x,&g.y);\n\t  g.l=c/gcd(c,d);g.r=d/gcd(c,d);\n\t  m[b]=g;\n\t   }\n\t for(int i=0;i<a;i++){\n\t     if(n[i]==-1)mincost(i+1);\n\t     }  \n\t     int MAX=0;\n\tfor(int i=0;i<a;i++){\n\t     MAX=max(MAX,n[i]);\n\t    }  \n\t    cout<<MAX<<endl;\n       }\n    }"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <cassert>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define vi vector<int>\n#define pb push_back\n#define INF 999999999\n//#define INF (1LL<<59)\nll gcd (ll a,ll b){\n\tif(a<b)swap(a,b);\n\tif(a%b==0)return b;\n\treturn gcd(b,a%b);\n}\n\nll lcm(ll a,ll b){\n\treturn a/gcd(a,b)*b;\n}\n\nstruct stick{\n\tint ld,rd,left,right;\n};\n\n\nvector<stick> data;\n\nint solve(int stick_num){\n\tstick now = data[stick_num];\n\tint left=0,right=0;\n\tif(now.left !=0)left = solve(now.left);\n\tif(now.right!=0)right= solve(now.right);\n\t\n\tif(left==0&&right==0) return (now.rd+now.ld)/gcd(now.ld,now.rd);\n\n\telse if(left==0 && right!=0){\n\t\tint rw = lcm(right,now.rd);\n\t\tint lw = now.ld*(rw/now.rd);\n\t\treturn rw+lw;\n\t}\n\t\n\telse if(left!=0 && right==0){\n\t\tint lw = lcm(left,now.ld);\n\t\tint rw = now.rd*(lw/now.ld);\n\t\treturn rw+lw;\n\t}\n\t\n\telse{\n\t\tint a = left *now.rd/lcm(now.rd,now.ld);\n\t\tint b = right*now.ld/lcm(now.rd,now.ld);\n\t\treturn lcm(a,b)*2;\n\t}\n}\n\n\nint getParent(int n){\n\tint par[200];\n\trep(i,200)par[i]=-1;\n\t\n\tfor(int i=1;i<=n;i++){\n\t\tif(data[i].left !=0) par[data[i].left ] = i;\n\t\tif(data[i].right!=0) par[data[i].right] = i;\n\t}\n\t\n\tfor(int i=1;i<=n;i++){\n\t\tif(par[i]==-1)return i;\n\t}\n\treturn -1;\n}\n\n\nint main(){\n\tint n;\n\twhile(cin>>n&&n){\n\t\tdata.clear();\n\t\tdata.pb(stick{-1,-1,-1,-1});\n\t\trep(i,n){\n\t\t\tint a,b,c,d;\n\t\t\tcin>>a>>b>>c>>d;\n\t\t\tdata.pb(stick{a,b,c,d});\n\t\t}\n\t\n\t\tint root = getParent(n);\n\t\t\n\t\tcout<<solve(root)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\ntypedef struct Node {\n  int p, q;\n  int r,b;\n  Node() {}\n  Node(int p, int q, int r, int b)\n    : p(p), q(q), r(r), b(b) {}\n} node;\n\nnode nd[101];\n\ntypedef long long Int;\nInt gcd(Int a, Int b) {\n  return (b != 0) ? gcd(b, a%b) : a;\n}\nInt lcm(Int a, Int b) {\n  return a / gcd(a,b) * b;\n}\n\nInt solve(Int id, Int nest) {\n  // cout << string(nest, ' ');\n  // cout << id << endl;\n  if (id == 0) return 1;\n  Int r = solve(nd[id].r, nest+1);\n  Int b = solve(nd[id].b, nest+1);\n\n  Int p = nd[id].p;\n  Int q = nd[id].q;\n\n  Int l = lcm(r*p, b*q);\n  return l/p + l/q;\n}\n\nint main() {\n  int n;\n  while(cin >> n, n) {\n    vector<bool> hoge(n+1);\n    REP(i,n) {\n      int p, q, r, b;\n      cin >> p >> q >> r >> b;\n      nd[i+1] = Node(p,q,r,b);\n      hoge[r] = 1;\n      hoge[b] = 1;\n    }\n    int a;\n    for (int i=1; i<=n; ++i)\n      if (!hoge[i])\n        a = i;\n    cout << solve(a,0) << endl; \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nconst long long int NIL = -1;\n\nstruct Mobile {\n    long long int weight;\n    int left, right;\n    int left_child, right_child;\n    Mobile(int l, int r, int lc, int rc) :weight(NIL), left(l), right(r), left_child(lc), right_child(rc) {}\n};\n\nlong long int gcd(long long int a, long long int b) {\n    return b ? gcd(b, a % b) : a;\n}\n\nlong long int lcm(long long int a, long long int b) {\n    return a * b / gcd(a, b);\n}\n\nlong long int weight(vector<Mobile>& mobile, int n) {\n    if(n == NIL) return 1;\n    if(mobile[n].weight != NIL) return mobile[n].weight;\n    int left_weight = weight(mobile, mobile[n].left_child);\n    int right_weight = weight(mobile, mobile[n].right_child);\n    if(left_weight * mobile[n].right != right_weight * mobile[n].left) {\n        long long int d = lcm(left_weight * mobile[n].left, right_weight * mobile[n].right);\n        left_weight = d / mobile[n].left;\n        right_weight = d / mobile[n].right;\n    }\n    return mobile[n].weight = left_weight + right_weight;\n}\n\nint main() {\n    int n;\n    while(cin >> n, n) {\n        vector<Mobile> mobile;\n        for(int i = 0; i < n; ++i) {\n            int p, q, r, b;\n            cin >> p >> q >> r >> b;\n            int d = gcd(p, q);\n            p /= d;\n            q /= d;\n            --r;\n            --b;\n            mobile.push_back(Mobile(p, q, r, b));\n        }\n        long long int answer = 0;\n        for(int i = 0; i < n; ++i) answer = max(answer, weight(mobile, i));\n        cout << answer << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <utility>\n#include <iomanip>\n\n#define ll long long int\n#define pb push_back\n#define mk make_pair\n#define pq priority_queue\n\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<ll, int> Pl;\nconst int inf = 1e9;\nconst ll linf = 1LL << 50;\n\ntypedef struct stick_ {\n\t\tint l, r, lt, rt;\n\t\tstick_(int l, int r, int lt, int rt): l(l), r(r), lt(lt), rt(rt){};\n} stick;\n\nint gcd(int x, int y){\n\t\tif(y == 0)return x;\n\t\telse return gcd(y, x % y);\n}\n\nvector<stick> vec;\nbool fi[101];\n\nll gg(ll x, ll y){\n\t\treturn x / gcd(x, y) * y;\n}\n\nll calc(int x){\n\t\tstick s = vec[x];\n\t\tint lw, rw;\n\t\tif(s.lt != 0)lw = calc(s.lt -1);\n\t\telse lw = 1;\n\t\tif(s.rt != 0)rw = calc(s.rt - 1);\n\t\telse rw = 1;\n\t\tll tmp = gg(lw*s.l, rw*s.r);\n\t\treturn tmp / s.l + tmp / s.r;\n}\n\nint main(int argc, char const* argv[])\n{\n\tint n;\n\twhile(true){\n\t\t\tvec.erase(vec.begin(), vec.end());\n\t\t\tcin >> n;\n\t\t\tfill(fi, fi + n, false);\n\t\t\tif(n == 0)break;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\tint p, q, r, s;\n\t\t\t\t\tcin >> p >> q >> r >> s;\n\t\t\t\t\tvec.pb(stick(p, q, r, s));\n\t\t\t\t\tif(r != 0)fi[r-1] = true;\n\t\t\t\t\tif(s != 0)fi[s-1] = true;\n\t\t\t}\n\t\t\tint start = -1;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\tif(!fi[i]){\n\t\t\t\t\t\t\tstart = i;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tcout << calc(start) << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i, x) for(ll i = 0; i < x; i++)\n#define rep2(i, x) for(ll i = 1; i <= x; i++)\n#define all(a) (a).begin(),(a).end()\nusing ll = long long;\nusing ld = long double;\nusing namespace std;\nconst ll INF = 1000000000000000000;\nconst ll mod = 1000000007;\nconst ld pi = 3.141592653589793238;\n\nll gcd(ll a, ll b) {\n\tif (a < b)swap(a, b);\n\tif (a % b == 0)return b;\n\treturn gcd(b, a % b);\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b) * b;\n}\n\nll hi[1234567][2], omori[1234567][2];\nll par1[1234567], par2[1234567];//parと左右\nll ok[12345678];//2ならok\n\nll notfind[12345678];\nsigned main() {\n\twhile (true) {\n\t\tll n; cin >> n;\n\t\tif (n == 0) { break; }\n\n\t\trep(i, 123456) { \n\t\t\thi[i][0] = 0; hi[i][1] = 0; omori[i][0] = 0; omori[i][1] = 0;\n\t\t\tpar1[i] = 0; par2[i] = 0; ok[i] = 0; notfind[i] = 0;\n\t\t}\n\n\t\tqueue<ll> que;\n\t\trep2(i, n) {\n\t\t\tll a, b, c, d; cin >> a >> b >> c >> d;\n\t\t\tnotfind[c]++; notfind[d]++;\n\t\t\t//a,b\n\t\t\tll k = gcd(a, b); a /= k; b /= k;\n\t\t\thi[i][0] = b; hi[i][1] = a;\n\t\t\t//end\n\n\t\t\t//c,d\n\t\t\tif (c == 0) { ok[i]++; omori[i][0] = 1; }\n\t\t\telse { par1[c] = i; par2[c] = 0; }\n\t\t\tif (d == 0) { ok[i]++; omori[i][1] = 1; }\n\t\t\telse { par1[d] = i; par2[d] = 1; }\n\t\t\t//end\n\t\t\tif (ok[i] == 2) { que.push(i); }\n\t\t}\n\t\tll ans = 0;\n\t\twhile (que.size()) {\n\t\t\tll a = que.front(); que.pop();\n\t\t\tll cnt = 0;\n\n\t\t\t//cout << omori[a][0] << ' ' << omori[a][1] << endl;\n\t\t\tif (gcd(omori[a][0], hi[a][0]) != 1) { omori[a][0] /= gcd(omori[a][0], hi[a][0]); }\n\t\t\tif (gcd(omori[a][1], hi[a][1]) != 1) { omori[a][1] /= gcd(omori[a][1], hi[a][1]); }\n\t\t\t//cout << omori[a][0] << ' ' << omori[a][1] << endl;\n\t\t\tcnt = lcm(omori[a][0], omori[a][1]) * (hi[a][0] + hi[a][1]);\n\n\t\t\tif (notfind[a] == 0) { ans = cnt; break; }\n\n\t\t\tok[par1[a]]++; omori[par1[a]][par2[a]] = cnt;\n\t\t\tif (ok[par1[a]] == 2) { que.push(par1[a]); }\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint a[100+2],b[100+2],c[100+2],d[100+2],w[100+2],n;\n\nint s(int x){\n\tint ans;\n\tif(w[x]!=-1)return w[x];\n\telse {\n\t\tint e=a[x]*s(c[x]),f=b[x]*s(d[x]);\n\t\tint g=e,h=f,gcd;\n\t\twhile(1){\n\t\t\tg%=h;\n\t\t\tif(g==0)break;\n\t\t\th%=g;\n\t\t\tif(h==0)break;\n\t\t}\n\t\tgcd=e*f/max(g,h);\n\t\tans=gcd/a[x]+gcd/b[x];\n\t}\n\tw[x]=ans;\n\treturn ans;\n}\n\nint main(){\nwhile(1){\n\tint an=0,aaa;\n\tscanf(\"%d\",&n);\n\tif(n==0)break;\n\tw[0]=1;\n\tfor(int i=1;i<=n;i++){scanf(\"%d%d%d%d\",&a[i],&b[i],&c[i],&d[i]); w[i]=-1;}\n\tfor(int i=1;i<=n;i++){\n\t\tif(w[i]==-1)aaa=s(i);\n\t\tif(an<w[i])an=w[i];\n\t}\n\tprintf(\"%d\\n\",an);\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nint n;\nint p[101], q[101], r[101], b[101];\nlong long int w[101];\nlong long int ans;\n\nlong long int gcd(long long int m, long long int n){\n\tif(n == 0) return m;\n\telse return gcd(n, m%n);\n}\n\nlong long int lcm(long long int m, long long int n){\n\tlong long int g = gcd(m, n);\n\tm /= g;\n\tn /= g;\n\treturn g * m * n;\n}\n\nlong long int f(int x){\n\tif(w[x] != 0) return w[x];\n\tlong long int g = gcd(p[x], q[x]);\n\tp[x] /= g;\n\tq[x] /= g;\n\treturn (p[x] + q[x]) * lcm(f(r[x]), f(b[x]));\n}\n\nint main(){\n\twhile(1){\n\t\tscanf(\"%d\", &n);\n\t\tif(n == 0) break;\n\n\t\tmemset(w, 0, sizeof(w));\n\t\tw[0] = 1;\n\t\tans = 0;\n\t\tfor(int i=1; i<n+1; ++i) scanf(\"%d %d %d %d\", &p[i], &q[i], &r[i], &b[i]);\n\t\tfor(int i=1; i<n+1; ++i){\n\t\t\tw[i] = f(i);\n\t\t\tans = max(ans, w[i]);\n\t\t}\n\n\t\tprintf(\"%lld\\n\", ans);\n/*\n\t\tfor(int i=0; i<n+1; i++){\n\t\t\tprintf(\"%d %lld\\n\", i, w[i]);\n\t\t}\n*/\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint GCD(int a,int b){\n    if(b>a)swap(a,b);\n    return (b==0)?a:GCD(b,a%b);\n}\nint LCM(int a,int b){\n    return a/gcd(a,b)*b;\n}\nint l[101],r[101],w1[101],w2[101];\nint memo[101];\nint dfs(int x){\n    if(x==0)return 1;\n    if(memo[x]!=-1)return memo[x];\n    int red=l[x]*dfs(w1[x]);\n    int blue=r[x]*dfs(w2[x]);\n    int lcm=LCM(red,blue);\n    return memo[x]=lcm/l[x]+lcm/r[x];\n}\nint main(){\n    int n;\n    while(scanf(\"%d\",&n),n){\n        bool flag[101];fill(flag,flag+n+1,true);\n        fill(memo,memo+n+1,-1);\n        for(int i=1;i<=n;i++){\n            scanf(\"%d%d%d%d\",&l[i],&r[i],&w1[i],&w2[i]);\n            flag[w1[i]]=flag[w2[i]]=false;\n        }\n        for(int i=1;i<=n;i++){\n            if(flag[i]){\n                printf(\"%d\\n\",dfs(i));\n                break;\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nll gcd(ll x, ll y)\n{    return y ? gcd(y, x % y) : x;\t}\n\nll lcm(ll x, ll y)\n{\treturn x * y / gcd(x, y);\t}\n\nclass Q\n{\npublic:\n\tll d, n;\n\t\n\tQ() : d(0), n(0) { }\n\tQ(int d, int n) : d(d), n(n) { }\n\t\n\tQ operator + (Q x)\n\t{\n\t\tif(d == 0 || n == 0) return x;\n\t\tif(x.d == 0 || x.n == 0) return *this;\n\t\treturn Q(d * x.n + n * x.d, n * x.n).reduce();\n\t}\n\t\n\tQ operator - (Q x)\n\t{\n\t\tif(d == 0 || n == 0) return x;\n\t\tif(x.d == 0 || x.n == 0) return *this;\n\t\treturn Q(d * x.n - n * x.d, n * x.n).reduce();\n\t}\n\n\tQ operator * (int x)\n\t{\treturn Q(d * x, n).reduce();\t}\n\t\n\tQ operator / (int x)\n\t{\treturn Q(d, n * x).reduce();\t}\n\t\n\tQ operator += (Q x)\n\t{\treturn (*this) = (*this) + x;\t}\n\t\n\tQ operator -= (Q x)\n\t{\treturn (*this) = (*this) - x;\t}\n\t\n\tQ reduce()\n\t{\n\t\tif(d == 0 || n == 0) return Q(0, 0);\n\t\t\n\t\tll gd = gcd(d, n);\n\t\t\n\t\treturn Q(d / gd, n / gd);\n\t}\n\t\n\tQ reciprocal()\n\t{\treturn Q(n, d);\t}\n};\n\nint lm = 0;\nstruct Mobile\n{\n\tint p, q, r, b;\n\t\n\tQ divid(vector<Mobile>& mobiles, Q x)\n\t{\n\t\tQ rw = x * p / (p + q), bw = x * q / (p + q);\n\t\tQ res;\n\t\t\n\t\tif(r == 0)\tres += rw, lm = (lm ? lcm(lm, rw.n) : rw.n);\n\t\telse\t\tres += mobiles[r - 1].divid(mobiles, rw);\n\t\t\n\t\tif(b == 0)\tres += bw, lm = (lm ? lcm(lm, bw.n) : bw.n);\n\t\telse\t\tres += mobiles[b - 1].divid(mobiles, bw);\n\t\t\n\t\treturn res;\n\t}\n};\n\nint main()\n{\n    int n;\n\twhile( cin >> n && n )\n\t{\n\t\tvector<Mobile> mobiles(n);\n\t\tvector<bool> flags(n, false);\n\n\t\trep(i, n)\n\t\t{\n\t\t\tcin >> mobiles[i].p >> mobiles[i].q >> mobiles[i].r >> mobiles[i].b;\n\t\t\t\n\t\t\tif(mobiles[i].r != 0) flags[mobiles[i].r - 1] = true;\n\t\t\tif(mobiles[i].b != 0) flags[mobiles[i].b - 1] = true;\n\t\t}\n\t\t\n\t\tQ res = mobiles[min_element(ALL(flags)) - flags.begin()].divid(mobiles, Q(1, 1));\n\t\t\n\t\tcout << (res * lm).d << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef double db;\n\n#define fr first\n#define sc second\n#define pb push_back\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define rep1(i,x) for(ll i=1;i<=x;i++)\n#define rrep(i,x) for(ll i=x-1;i>=0;i--)\n#define rrep1(i,x) for(ll i=x;i>0;i--)\n\nll n;\nll bar[101][4];\n\nll gcd(ll a,ll b){\n\tif(b==0) return a;\n\treturn gcd(b,a%b);\n}\nll dp[101];\nll rec(ll x){\n\tif(dp[x]) return dp[x];\n\tll lef=1,rig=1;\n\tif(bar[x][2]!=0) lef=rec(bar[x][2]);\n\tif(bar[x][3]!=0) rig=rec(bar[x][3]);\n\tll div=gcd(bar[x][0],bar[x][1]);\n\tbar[x][0]/=div;\n\tbar[x][1]/=div;\n\tll a=bar[x][1]*lef;\n\tll b=bar[x][0]*rig;\n\tdiv=gcd(a,b);\n\ta/=div;\n\tb/=div;\n\treturn dp[x]=a*rig+b*lef;\n}\n\nint main()\n{while(1){\n\tll ans=0;\n\tmemset(dp,0,sizeof(dp));\n\tcin>>n;\n\tif(!n) return 0;\n\trep1(i,n){\n\t\trep(j,4) cin>>bar[i][j];\n\t}\n\trep1(i,n){\n\t\tans=max(ans,rec(i));\n\t}\n\tcout<<ans<<endl;\n}}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint n;\nint a[100][2],p[100][2];\nbool cal[100];\nint GCD(int x,int y){\n\twhile(true){\n\t\tif(y>x){int t=x;x=y,y=t;}\n\t\tx%=y;\n\t\tif(!x)break;\n\t}\n\treturn y;\n}\nint DFS(int x){\n\tif(!x)return 1;\n\tx--;\n\tint b=DFS(p[x][0]),c=DFS(p[x][1]);\n\tint s=b*a[x][0]*c*a[x][1]/GCD(b*a[x][1],c*a[x][0]);\n\tint ret=0;\n\tif(a[x][0])ret+=s/a[x][0];\n\tif(a[x][0])ret+=s/a[x][1];\n\t//ret=s/a[x][0]+s/a[x][1];\n\treturn ret;\n}\nint main(){\n\twhile(true){\n\tcin>>n;\n\tif(!n)break;\n\tfor(int i=0;i<n;i++)cal[i]=true;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>a[i][0]>>a[i][1];\n\t\tint t=GCD(a[i][0],a[i][1]);\n\t\ta[i][0]/=t,a[i][1]/=t;\n\t\tcin>>p[i][0]>>p[i][1];\n\t\tcal[p[i][0]-1]=false,cal[p[i][1]-1]=false;\n\t}\n\tfor(int i=0;i<n;i++)if(cal[i])cout<<DFS(i+1)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\nusing namespace std;\nint a[100+2],b[100+2],c[100+2],d[100+2],w[100+2],n;\n\nint s(int x){\n\tint ans;\n\tif(w[x]!=NULL)return w[x];\n\telse {\n\t\tint e=a[x]*s(c[x]),f=b[x]*s(d[x]);\n\t\tint g=e,h=f,gcd;\n\t\twhile(1){\n\t\t\tg%=h;\n\t\t\tif(g==0)break;\n\t\t\th%=g;\n\t\t\tif(h==0)break;\n\t\t}\n\t\tgcd=e*f/max(g,h);\n\t\tans=gcd/a[x]+gcd/b[x];\n\t}\n\tw[x]=ans;\n\treturn ans;\n}\n\nint main(){\nwhile(1){\n\tint ans=0;\n\tscanf(\"%d\",&n);\n\tif(n==0)break;\n\tw[0]=1;\n\tfor(int i=1;i<=n;i++){scanf(\"%d%d%d%d\",&a[i],&b[i],&c[i],&d[i]); w[i]=NULL;}\n\tfor(int i=1;i<=n;i++){\n\t\tif(w[i]==NULL)a[101]=s(i);\n\t\tif(ans<w[i])ans=w[i];\n\t}\n\tprintf(\"%d\\n\",ans);\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i = (a); i < (b); i++)\n#define REP(i,n) FOR(i,0,n)\n\nstruct Node {\n\tint a, b, ma, mb;\n\t\n\tNode() {}\n\tNode(int a, int b, int ma, int mb) : a(a), b(b), ma(ma), mb(mb) {}\n};\n\nint n;\nNode node[100];\nbool istop[100];\n\nint gcd(int a, int b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a % b);\n}\n\nint lcm(int a, int b) {\n\treturn a / gcd(a, b) * b;\n}\n\nint dfs(int pos) {\n\tNode &now = node[pos];\n\t\n\tint a = now.a, b = now.b, ma = now.ma, mb = now.mb;\n\t\n\tma = ma ? dfs(ma - 1) : 1;\n\tmb = mb ? dfs(mb - 1) : 1;\n\t\n\tint l = lcm(a * ma, b * mb);\n\treturn l / a + l / b;\n}\n\nint main() {\n\twhile (cin >> n, n) {\n\t\tfill(istop, istop + n, false);\n\t\t\n\t\tREP(i, n) {\n\t\t\tint a, b, ma, mb;\n\t\t\tscanf(\"%d %d %d %d\", &a, &b, &ma, &mb);\n\t\t\tint g = gcd(a, b);\n\t\t\t//a /= g; b /= g;\n\t\t\tnode[i] = Node(a, b, ma, mb);\n\t\t\t\n\t\t\tif (ma != 0) istop[ma - 1] = true;\n\t\t\tif (mb != 0) istop[mb - 1] = true;\n\t\t}\n\t\t\n\t\tint st = 0;\n\t\twhile (istop[st]) st++;\n\t\tcout << dfs(st) << endl;\n\t}\n\treturn 0;\n}\n\n// 2:00"
  },
  {
    "language": "C++",
    "code": "//\n//\n//  Codeforces: ganariya\n//  AtCoder: ganariya2525\n//  MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n//  MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n//  MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n//  MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMHBYYYWMMMM#BYYTTTYWMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n//  MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMB9O1==?????zzCC111>>;;;;;;;;;;;<?TMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n//  MMMMMMMMMMMMMMMMMMMMMMMMMMMMMM9Olll=l======??????????>>>>>>;;;;;;;;;:;?TMMMMMMMMMMMMMMMMMMMMMMMMMMMM\n//  MMMMMMMMMMMMMMMMMMMMMMMMMMM9ttlllllllll=l=======?????????>>>>>>;;;;;;;;;;?TMMMMMMMMMMMMMMMMMMMMMMMMM\n//  MMMMMMMMMMMMMMMMMMMMMMMMBOttOtttttltlllllllll=======??????????>>>>>>>;;;;;;?TMMMMMMMMMMMMMMMMMMMMMMM\n//  MMMMMMMMMMMMMMMMMMMMMMBttwOtttttttttttttlllllllll========?????????>>>>>>;;;;;<TMMMMMMMMMMMMMMMMMMMMM\n//  MMMMMMMMMMMMMMMMMMMMBrwZrttttttttttttttttttlllllllllll======???????????>>>>>>;;?HMMMMMMMMMMMMMMMMMMM\n//  MMMMMMMMMMMMMMMMMMMSw0trtrrtrtrttrtttttttttttttlllOllllll========????<<zz??>>>>>>ZMMMMMMMMMMMMMMMMMM\n//  MMMMMMMMMMMMMMMMMMX0ttrtrOOttrttrttOOttttttttttttltwllllllllll========??wy?????>>>vZMMMMMMMMMMMMMMMM\n//  MMMMMMMMMMMMMMMMM0ttrI+wV1rtttttttwZtttttttltttOwylOXOllllllllllll=l====1dkz???????vZdMMMMMMMMMMMMMM\n//  MMMMMMMMMMMMMMMSrrwrtwZCjttttttttwSttOlllltllllwtXOlZkOlllllllllllllll==z+dk===?????X2JMMMMMMMMMMMMM\n//  MMMMMMMMMMMMMBrtwwtrw0<jttttttttOXllOttltllttllOZwHOtXkyltlllllllllllllll<+XZ======?dk?JMMMMMMMMMMMM\n//  MMMMMMMMMMMMStwdZtwXC<+ttttttOOOd6ltZlltllllttllStWWOOHWytttttltltOllltllz:zHllll===zX=?dMMMMMMMMMMM\n//  MMMMMMMMMMBrwdKOtwW3;;zrttttwZwXRlldOllltltlltttwlXvktdXWytltttttttOttlttl<<dklllllllZ===dMMMMMMMMMM\n//  MMMMMMMMM8tQM#ttwW3;;;1trttwSwfUOlORltllltlllllldtX>dktDOWOtlttltttOOttltO<;+WOllllllXlllzMMMMMMMMMM\n//  MMMMMMMM9OdM#Ottd$;;;;;<?1z0OKjRltd0llltOllllllldZX>?WOw_WWOtttttttttOttI<;;<dkttttllllllldMMMMMMMMM\n//  MMMMMMM9wMMMSttwS<;;;;>;;;J<j>(I<?U111zltllllllld0X>~dkwl(WkttlttlOOwWk<;;:;;zHttttttwOllllMMMMMMMMM\n//  MMMMMMBdMMM8tttdI+zttttttdSXt~dlzXwlllzzOzzzzzlldkW<~?kOk~?sx++++jdHmH6+++<;;jdZtttttdkOtlldMMMMMMMM\n//  MMMMM#dMMM#tttw0+tttttttdKdf((RsdfRllllldZllltlldWK~~_W0w_~OWOlOdgg9ZtOWOtttz+wktttttdpktttwMMMMMMMM\n//  MMMMMWMMMMSlttdIttttttOdWHH>~(IzWDRll=llzRlllzlldk$>++dkd<~_XkdgH9tttttdktttt+OkrttrtdfpkttOMMMMMMMM\n//  MMMMNWMMM#Zttlk=tttttOXWWd$_.(IdW1R=llll=SlllzOldK<_._(kd6+-(MM9lltttttrWktttztWZttrwXppWttrMMMMMMMM\n//  MMMMNMMMM#lltwDzttllOXyW0X:..(OXk<Rl=ll=lwOlllOld3<``.(Rd>~?CdklllltttttXdXttzOWktrwwWpfpkrtMMMMMMMM\n//  MMMMMMMMM@ltldIzlttOXyW$w$```(OyD(Rl==llldZ=llIlw;~```-Xd:~~~~UkylltttAyHdgSrzObRtOXwpfppWrrMMMMMMMM\n//  MMMMMMMMM@llldtlllldVyW+d>```.wZ$ wl==lI=wRl=ll=w<```` dd_..~~(RZXOQdggHH9ZwrzwHWrdXXppfppkrMMMMMMMM\n//  MMMMMMMMM#llldlltlwyyyD(S-...,Wk] zI=l=llzWzl=l=P~```` jZ``...~zQkH@MBUtrZtrtldHRdSdpfpffpkwMMMMMMMM\n//  MMMMNMMMMNZllXtllldVyW3(Mf=<ONMHP~(k===l=zdk=lld3```...(C````..(M96lttttrrtrrtdHWHXpfpppfpRwMMMMMMMM\n//  MMMMMMMMMMNzzWZllzyyyy(W@`  =~MWK6 jz=lzlzvRz=lZ`.I+JgkWm&-. `..(ZltlttttrtttrWWHppfppfpppSdMMMMMMMM\n//  MMMMMMMMMMMkAWRllzVyyS_(b    .MNHU-(Uz=lI={XkzO>.dVT7<TMHMNHHx-.(kwZyltttrtrrdHHpfppfpffpp0dMMMMMMMM\n//  MMMMMMMMMMMMKyWzOzyyyk.`<!  hdWMH]``(S==t=l(kX2 ?_`    WMMHH#HH+.XwkwOttttrwrZ~(HfpfpppfpWwXMMMMMMMM\n//  MMMMMMMMMMMMMHWROOyyyW;` `. (WVM#b```(0=zzz wX!```  a.dM#NM@N(4WhXkXkWtttttwd3O_(HpffpfpfWwSMMMMMMMM\n//  MMMMMMMMMMMMNZvWzXXyyXP```-_ ?o+?!````.4=Z=`(:````  HpbNNMHHH (C=XXyWZWttrdwf:(>.dfppffppSXSMMMMMMMM\n//  MMMMMMMMMMMMMRzuHzXyZXH.``````````````` ?zz ``````` ZKvTHHbWt `` XZyyHZWOdSZ<::~`(fpfpfffXp0WMMMMMMM\n//  MMMMMMMMMMMMMKzyyHvyZZW____.`````````````.I_```````` ?nJzX7^````.WXWyyHyWKZ<:::_`Jffpfpfpfp0WMMMMMMM\n//  MMMMMMMMMMMMM@zZyZWwWyXo-_~(~ ```````````` `````````````` _`````.WXkyyVWmWc::<~ .HffppfffffkXMMMMMMM\n//  MMMMMMMMMMMMMKzZZZZXkUXr~....```````....```````````` ...  ````..JXWWyyW83vXx~..WfffVfWVffffkdMMMMMMM\n//  MMMMMMMMMMMMMRzZZZZZZZZb````````````<````````````./<~._<_.____`(WfdyW3<:~~(XWkVVVVVVVHVVVVV0dMMMMMMM\n//  MMMMMMMMMMMMMSzZZZZZZZWX-```````````````````````````.......~~._j9jX=_~~_(XZyVHHkyyyyWHyyykykOMMMMMMM\n//  MMMMMMMMMMMMMSzuuuuuZXWZW,```````````````````````````````.``..(3<! ...JWyyXWyyyWHkyyWHyyyHyklMMMMMMM\n//  MMMMMMMMMMMMNXzuuuXXuXSuuXh,```````` .... ```````````````````_~ .JWyyyyZyy0HyyZyyZyZXWZZZWHZIdMMMMMM\n//  MMMMMMMMMMMMNwtuuuXkuXXuuuuXh,``````(:::~<?71(,``````````````.(UMNUkZZZZZZZHZZ0ZZZZZWWZZZWNXIdMMMMMM\n//  MMMMMMMMMMMMNKOzuzXkuXuuuuuXuXW, ```` _~~~:~~(}```````````.(YC;::<kCfZZZZXO#ZZVZZZZZMZZuuMMNXzMMMMMM\n//  MMMMMMMMMMMMHKOzzuXkzdzzzzuXXzuuU&.``````````````````` .JY>::::;;J=:dZuZuZd#uuruuuud#uuuXMMMNXdMMMMM\n//  MMMMMMMMMMMMMNOvzzXkvMRzzzzXKzuzzzXh, `````````````..JC<;:;;:;;+7<:~(HHuXIdNuuzuuuXMSuuuWMMMMROMMMMM\n//  MMMMMMMMMMMMMNvvvrdkvM#vzzzzHzzzzzuzzUG. ``` ...JdY<:;:;:::;;+v<~~~:(HpHmzMNXZzuzzd#zzzdMMMMMMRdMMMM\n//  MMMMMMMMMMMMMNwrrvdRrMNwvvvvdRvvvzwkzzzzXWWHY=~~O+::::::::<+<~~~~~~~dppppWMMkZzzzwM#zzdMMMMMMMMNMMMM\n//  MMMMMMMMMMMMMM#rrrwRrMMbOrrOZNkrvvvXwvvvvvwX;.~._W_:::::(?!~~~~~~~~(HpppppppHWdvwM#XwdMMMMMMMMMMNMMM\n//  MMMMMMMMMMMMMMNyrrrRrWMMmzOrzdNyrrrZNvrwQWWfb....(r~~_J>_.....~.~~-dpfpffpfpppWHHMNdMMMMMMMMMMMMMMMM\n//  MMMMMMMMMMMMMMMNrtrStdMMMNxzrzMNmrrrdNWfVfffP._-.(~_J!............JpfpffpfpfffpppWNppppHMMMMMMMMMMMM\n//  MMMMMMMMMMMMMMMMNOtXtdMMMMMNxzZMMNmgHyVVVVVW%..?/(.,(x-..........(HfffpffpffpffWHHffpffppfVyyWMMMMMM\n\n\n//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <unordered_map>\n#include <climits>\n#include <set>\n#include <unordered_set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <queue>\n#include <random>\n#include <complex>\n#include <regex>\n#include <locale>\n#include <random>\n#include <type_traits>\n\nusing namespace std;\n\n#define SHOW_VECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOW_MAP(v){std::cerr << #v << endl; for(const auto& xxx: v){std::cerr << xxx.first << \" \" << xxx.second << \"\\n\";}}\n\nusing LL = long long;\n\n//~~~~~~~~~~~~~~~~~~~~~_(＾～＾ ｣ ∠)_~~~~~~~~~~~~~~~~~~~~~\n\nLL gcd(LL x, LL y) {\n    return y == 0 ? x : gcd(y, x % y);\n}\n\nLL lcm(LL x, LL y) {\n    return x / gcd(x, y) * y;\n}\n\nLL dfs(int v, vector<LL> &p, vector<LL> &q, vector<LL> &l, vector<LL> &r) {\n\n    LL left = l[v];\n    LL right = r[v];\n\n    LL lv = (left == -1) ? 1 : dfs(left, p, q, l, r);\n    LL rv = (right == -1) ? 1 : dfs(right, p, q, l, r);\n\n    LL L = lcm(p[v] * lv, q[v] * rv);\n\n    return L / p[v] + L / q[v];\n}\n\nint main() {\n\n    while (true) {\n\n        int n;\n        cin >> n;\n\n        if (n == 0) break;\n\n        vector<LL> p(n), q(n), l(n), r(n);\n        vector<LL> root(n);\n        iota(root.begin(), root.end(), 0);\n\n        for (int i = 0; i < n; i++) {\n            cin >> p[i] >> q[i] >> l[i] >> r[i];\n            l[i]--, r[i]--;\n            if (l[i] != -1) root.erase(find(root.begin(), root.end(), l[i]));\n            if (r[i] != -1) root.erase(find(root.begin(), root.end(), r[i]));\n        }\n\n        LL ans = dfs(root[0], p, q, l, r);\n        cout << ans << endl;\n\n    }\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nll gcd(ll x, ll y)\n{    return y ? gcd(y, x % y) : x;\t}\n\nll lcm(ll x, ll y)\n{\treturn x * y / gcd(x, y);\t}\n\nclass Q\n{\npublic:\n\tint d, n;\n\t\n\tQ() : d(0), n(0) { }\n\tQ(int d, int n) : d(d), n(n) { }\n\t\n\tQ operator + (Q x)\n\t{\n\t\tif(d == 0 || n == 0) return x;\n\t\tif(x.d == 0 || x.n == 0) return *this;\n\t\treturn Q(d * x.n + n * x.d, n * x.n).reduce();\n\t}\n\t\n\tQ operator - (Q x)\n\t{\n\t\tif(d == 0 || n == 0) return x;\n\t\tif(x.d == 0 || x.n == 0) return *this;\n\t\treturn Q(d * x.n - n * x.d, n * x.n).reduce();\n\t}\n\n\tQ operator * (int x)\n\t{\treturn Q(d * x, n).reduce();\t}\n\t\n\tQ operator / (int x)\n\t{\treturn Q(d, n * x).reduce();\t}\n\t\n\tQ operator += (Q x)\n\t{\treturn (*this) = (*this) + x;\t}\n\t\n\tQ operator -= (Q x)\n\t{\treturn (*this) = (*this) - x;\t}\n\t\n\tQ reduce()\n\t{\n\t\tif(d == 0 || n == 0) return Q(0, 0);\n\t\t\n\t\tll gd = gcd(d, n);\n\t\t\n\t\treturn Q(d / gd, n / gd);\n\t}\n\t\n\tQ reciprocal()\n\t{\treturn Q(n, d);\t}\n};\n\nstruct Mobile\n{\n\tint p, q, r, b;\n\t\n\tvoid divid(vector<Mobile>& mobiles, vector<Q>& qs, Q x)\n\t{\n\t\tQ rw = x * p / (p + q), bw = x * q / (p + q);\n\t\t\n\t\tif(r == 0)\tqs.push_back(rw);\n\t\telse\t\tmobiles[r - 1].divid(mobiles, qs, rw);\n\t\t\n\t\tif(b == 0)\tqs.push_back(bw);\n\t\telse\t\tmobiles[b - 1].divid(mobiles, qs, bw);\n\t}\n};\n\nint main()\n{\n    int n;\n\twhile( cin >> n && n )\n\t{\t\t\n\t\tvector<Mobile> mobiles(n);\n\t\tvector<bool> flags(n, false);\n\n\t\trep(i, n)\n\t\t{\n\t\t\tcin >> mobiles[i].p >> mobiles[i].q >> mobiles[i].r >> mobiles[i].b;\n\t\t\t\n\t\t\tif(mobiles[i].r != 0) flags[mobiles[i].r - 1] = true;\n\t\t\tif(mobiles[i].b != 0) flags[mobiles[i].b - 1] = true;\n\t\t}\n\t\t\n\t\tvector<Q> qs;\n\t\tmobiles[min_element(ALL(flags)) - flags.begin()].divid(mobiles, qs, Q(1, 1));\n\t\t\n\t\tint lm = qs[0].n, res = 0;\n\t\t\n\t\tREP(i, 1, qs.size()) lm = lcm(lm, qs[i].n);\n\t\t\n\t\trep(i, qs.size()) res += (qs[i] * lm).d;\n\t\t\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint n;\nint p[111];\nint q[111];\nint r[111];\nint b[111];\nint m[111];\n\nint GCD(int x,int y){\n  if(x < y) x^=y^=x^=y;\n  int r = x % y;\n  if(r) return GCD(y,r);\n  else return y;\n}\n\nint solve(int k){\n  if(k == 0) return 1;\n  if(m[k]) return m[k];\n  int rm = solve(r[k]) * p[k];\n  int bm = solve(b[k]) * q[k];\n  int l = rm * bm / GCD(rm,bm);\n  //cout << \"k = \" << k << \" : \" << l/p[k] << \" + \" << l/q[k] << endl;\n  return m[k] = l/p[k] + l/q[k];\n}\n\nint main(void){\n  while(cin >> n && n){\n    memset(p,0,sizeof(p));\n    memset(q,0,sizeof(q));\n    memset(r,0,sizeof(r));\n    memset(b,0,sizeof(b));\n    memset(m,0,sizeof(m));\n    for(int i = 1; i <= n; i++){\n      cin >> p[i] >> q[i] >> r[i] >> b[i];\n      int g = GCD(p[i],q[i]);\n      p[i] /= g;\n      q[i] /= g;\n    }\n    int res = 0;\n    for(int i = 1; i <= n; i++){\n      res = max(res,solve(i));\n    }\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define ALL(a) (a).begin(),(a).end()\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\nconst int INF=1e9;\nint gcd(int a,int b){\n  if(b==0)return a;\n  return gcd(b,a%b);\n}\nint main(){\n  int n;\n  while(cin>>n&&n){\n    vector<int>G[110];\n    int w[110],p[110],q[110],r[110],b[110];\n    memset(w,-1,sizeof(w));\n    for(int i=1;i<=n;i++){\n      cin>>p[i]>>q[i]>>r[i]>>b[i];\n      int g=gcd(p[i],q[i]);\n      p[i]/=g;q[i]/=g;\n      if(r[i]==0&&b[i]==0){\n        w[i]=p[i]+q[i];\n      }else{\n        G[r[i]].PB(i);\n        G[b[i]].PB(i);\n      }\n    }\n    bool update=true;\n    while(update){\n      update=false;\n      for(int i=1;i<=n;i++){\n        if(w[i]!=-1)continue;\n        if((r[i]==0||w[r[i]]!=-1)&&(b[i]==0||w[b[i]]!=-1)){\n          if(r[i]==0||b[i]==0){\n            if(r[i]==0)w[i]=w[b[i]]*(p[i]+q[i]);\n            else w[i]=w[r[i]]*(p[i]+q[i]);\n          }else{\n            int g=gcd(w[r[i]],w[b[i]]);\n            w[i]=w[r[i]]*w[b[i]]/g*p[i]*q[i]*2;\n            //w[i]=w[r[i]]*q[i]/gcd(w[r[i]]*q[i],w[b[i]]*p[i])*w[b[i]]*p[i]*2;\n          }\n          update=true;\n        }\n      }\n    }\n    int ans=0;\n    for(int i=1;i<=n;i++)ans=max(w[i],ans);\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \ntemplate<typename T1, typename T2> istream& operator>>(istream& is, pair<T1,T2>& a){ return is >> a.first >> a.second; }\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& os, pair<T1,T2>& a){ return os << a.first << \" \" << a.second; }\ntemplate<typename T> istream& operator>>(istream& is, vector< T >& vc){ for(int i = 0; i < vc.size(); i++) is >> vc[i]; return is; }\ntemplate<typename T> ostream& operator<<(ostream& os, vector< T >& vc){ for(int i = 0; i < vc.size(); i++) os << vc[i] << endl; return os; }\n \n#define ForEach(it,c) for(__typeof (c).begin() it = (c).begin(); it != (c).end(); it++)\n#define ALL(v) (v).begin(), (v).end()\n#define UNQ(s) { sort(ALL(s)); (s).erase( unique( ALL(s)), (s).end());}\n\ntypedef pair< int , int > Pi;\ntypedef pair< int , Pi > Pii;\ntypedef long long int64;\n\nint nextright[100];\nint nextleft[100];\nint java[100];\nint emacs[100];\nint dp[100];\n\n\nint64 lcm(int64 a, int64 b){ // 最小公倍数\n  int64 gcd = __gcd( a, b);\n  return a * b / gcd;\n}\n\nint64 dfs(int idx){\n  if(dp[idx]) return dp[idx];\n  int64 left = 1, right = 1;\n  if(nextright[idx] != -1) right = dfs(nextright[idx]);\n  if(nextleft[idx] != -1) left = dfs(nextleft[idx]);\n  int ret = lcm( right * java[idx], left * emacs[idx]);\n  return dp[idx] = ret / java[idx] + ret / emacs[idx];\n}\n\nint main(){\n  int n;\n  while(cin >> n, n){\n    fill_n( dp, 100, 0);\n    for(int i = 0; i < n; i++){\n      int p, q, r, b;\n      cin >> p >> q >> r >> b;\n      r--, b--;\n      nextright[i] = r;\n      java[i] = p;\n      nextleft[i] = b;\n      emacs[i] = q;\n    }\n    int64 ret = 0;\n    for(int i = 0; i < n; i++){\n      ret = max( ret, dfs(i));\n    }\n    cout << ret << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include<queue>\n#include<cmath>\nusing namespace std;\n#define int long long\n#define rep(i,n) for(int i=0;i<n;i++)\n\nstruct stick{\n    int red;\n    int blue;\n    int rnext;\n    int bnext;\n    int rm;\n    int bm;\n    int bef;\n};\n\nint labs(int a, int b){\n\tif(a>b)return a-b;\n\telse return b-a;\n}\n\nstick sticks[102];\nint GCM(int a,int b){\n    if(a==b||a%b==0){return b;}\n    return GCM(min(a,b),labs(a,b) );\n}\n\nsigned main(void){\n    while(1){\n        int N;\n        scanf(\"%lld\",&N);\n        if(N==0)break;\n        queue<int> que;\n        rep(i,N){//initialize\n            sticks[i].bnext=-1;\n            sticks[i].rnext=-1;\n            sticks[i].bef=-1;\n            sticks[i].bm=1;sticks[i].rm=1;\n        }\n        rep(i,N){\n            int p,q,r,b;\n            scanf(\"%lld %lld %lld %lld\",&p,&q,&r,&b);\n            r--;b--;\n            sticks[i].red=p/GCM(p,q);\n            sticks[i].blue=q/GCM(p,q);\n            if(r>-1){sticks[i].rnext=r;sticks[r].bef=i;}\n            if(b>-1){sticks[i].bnext=b;sticks[b].bef=i;}\n            if(r==-1&&b==-1){que.push(i);}\n        }\n        //rep(i,N){printf(\"%lld %lld %lld %lld\\n\",i,sticks[i].bef,sticks[i].rnext,sticks[i].bnext);}\n        int ans=0;\n        while(que.size()){\n            int n=que.front();que.pop();\n            int be=sticks[n].bef;\n            int A,B;\n            A=sticks[n].bm*sticks[n].red/GCM(sticks[n].bm,sticks[n].red);\n            B=sticks[n].rm*sticks[n].blue/GCM(sticks[n].rm,sticks[n].blue);\n            int alpha=(A/sticks[n].red)*(B/sticks[n].blue)/GCM(A/sticks[n].red, B/sticks[n].blue);\n            if(be==-1){\n                ans=alpha*(sticks[n].blue+sticks[n].red);\n               // printf(\"[[%lld]] %lld %lld %lld %lld %lld/\",n,A,B,sticks[n].blue,sticks[n].red,alpha);\n                //break;\n            }else{\n                if(sticks[be].rnext==n){\n                    sticks[be].rnext=-1;sticks[be].rm=alpha*(sticks[n].blue+sticks[n].red);\n                }else{\n                    sticks[be].bnext=-1;sticks[be].bm=alpha*(sticks[n].blue+sticks[n].red);\n                }\n            }\n                //printf(\"[%lld] %lld %lld %lld %lld %lld/\",n,A,B,sticks[n].blue,sticks[n].red,alpha);\n            \n            if(be>-1&&sticks[be].bnext==-1&&sticks[be].rnext==-1){\n                que.push(be);\n                //printf(\"(%lld)\",be);\n                //break;\n            }\n        }\n        printf(\"%lld\\n\",ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nbool FLG;\nint max_depth;\n\nstruct Node{\n\tNode(){\n\t\tp = q = 0;\n\t\tleft = right = left_child = right_child = parent = -1;\n\t}\n\tlong long int p,q,left_child,right_child,parent,left,right;\n};\n\nlong long int getCommon(long long int x,long long int y){\n\tif(y == 0){\n\t\treturn x;\n\t}else{\n\t\treturn getCommon(y,x%y);\n\t}\n}\n\nvoid calc(Node nodes[],int id){\n\n\tlong long int common,tmp;\n\n\tif(nodes[id].left_child > 0){\n\t\tcalc(nodes,nodes[id].left_child);\n\t}\n\tif(nodes[id].right_child > 0){\n\t\tcalc(nodes,nodes[id].right_child);\n\t}\n\n\tif(nodes[id].left*nodes[id].p > nodes[id].right*nodes[id].q){\n\t\tcommon = getCommon(nodes[id].left*nodes[id].p,nodes[id].right*nodes[id].q);\n\t}else{\n\t\tcommon = getCommon(nodes[id].right*nodes[id].q,nodes[id].left*nodes[id].p);\n\t}\n\n\ttmp = ((nodes[id].right*nodes[id].q)/common)*nodes[id].left*nodes[id].p;\n\n\tnodes[id].left = tmp/nodes[id].p;\n\tnodes[id].right = tmp/nodes[id].q;\n\n\tif(nodes[id].parent == -1)return;\n\n\tif(nodes[nodes[id].parent].left_child == id){\n\t\tnodes[nodes[id].parent].left = nodes[id].left + nodes[id].right;\n\t}else{\n\t\tnodes[nodes[id].parent].right = nodes[id].left + nodes[id].right;\n\t}\n}\n\nvoid func(int num_of_bar){\n\tlong long int root,left,right;\n\tlong long int common;\n\tNode nodes[num_of_bar+1];\n\n\tfor(int i = 1; i <= num_of_bar; i++){\n\t\tscanf(\"%lld %lld %lld %lld\",&left,&right,&nodes[i].left_child,&nodes[i].right_child);\n\t\tif(left > right){\n\t\t\tcommon = getCommon(left,right);\n\t\t}else{\n\t\t\tcommon = getCommon(right,left);\n\t\t}\n\n\t\tnodes[i].p = left/common;\n\t\tnodes[i].q = right/common;\n\t\tnodes[i].left = 1;\n\t\tnodes[i].right = 1;\n\n\t\tnodes[nodes[i].left_child].parent = i;\n\t\tnodes[nodes[i].right_child].parent = i;\n\t}\n\n\tfor(int i = 1; i <= num_of_bar;i++){\n\t\tif(nodes[i].parent == -1){\n\t\t\troot = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tcalc(nodes,root);\n\n\tlong long int ans = nodes[root].left + nodes[root].right;\n\n\tprintf(\"%lld\\n\",ans);\n\n}\n\nint main(){\n\n\tint num_of_bar;\n\n\twhile(true){\n\t\tscanf(\"%d\",&num_of_bar);\n\t\tif(num_of_bar == 0)break;\n\n\t\tfunc(num_of_bar);\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\ntemplate<class T>\nT gcd(T a, T b){\n  if(a > b) swap(a,b);\n  if(a == 0) return b;\n  return gcd(a, b%a);\n}\n\nint main(){\n  int n;\n  while(scanf(\"%d\",&n),n){\n    vector<pair<int,int> > bar(n+1);\n    vector<pair<int,int> > rat(n+1);\n\n    vector<int> w(n+1);\n    vector<bool> flag(n+1,false); flag[0] = true;\n    vector<bool> dep(n+1, false);\n    REP(i,n){\n      int p,q,r,b;\n      scanf(\"%d%d%d%d\",&p,&q,&r,&b);\n      int g = gcd(p, q); p/=g; q/=g;\n      bar[i+1].f = r;\n      bar[i+1].s = b;\n      rat[i+1].f = p;\n      rat[i+1].s = q;\n      if(r == 0 && b == 0){\n        flag[i+1] = true;\n        w[i+1] = p+q;\n      }\n    }\n\n    bool f = true;\n    while(f){\n      f = false;\n      for(int i=1; i<n+1; i++){\n        if(!flag[i] && flag[bar[i].f] && flag[bar[i].s]){\n          int idx1 = bar[i].f;\n          int idx2 = bar[i].s;\n\n          int p = rat[i].f, q = rat[i].s;\n\n          f = true;\n          dep[idx1] = dep[idx2] = true;\n          flag[i] = true;\n\n          if(idx1 == 0){\n            w[i] = w[idx2]*(p+q);\n          }else if(idx2 == 0){\n            w[i] = w[idx1]*(p+q);\n          }else{\n            int a = w[idx1];\n            int b = w[idx2];\n            int g = gcd(a,b);\n            w[i] = a*b/g*q + b*a/g*p;\n          }\n        }\n      }\n    }\n    int ans = 0;\n    for(int i=1; i<n+1; i++)\n      if(!dep[i]) ans += w[i];\n    printf(\"%d\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<cmath>\n#include<queue>\n#include<utility>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<numeric>\n#include<functional>\n#include<string>\n#include<iostream>\n\nusing namespace std;\nconst int one = 1;\nconst int big = (one<<20);\ntypedef long long int llint;\nconst int Llong=0;\nconst int Rlong=1;\nconst int Lbow=2;\nconst int Rbow=3;\n vector<tuple<llint,llint,llint,llint>> bow;//??????????????????????£????????£?\ninline llint GCDme(llint n,llint m){\n\tif(n<m){swap(n,m);}\n\tif(n==0||m==0){\n\t\treturn n+m;\n\t}\n\treturn GCDme(m,n%m);\n}\ninline llint LCMme(llint n,llint m){\n\treturn (n*m)/GCDme(n,m);\n}\nllint make_bow(llint ter){\n\tllint Llcm,Rlcm,Smom;//??????????°????????????????????????¢????????????\n\tif(get<Lbow>(bow[ter])==0){ Llcm=1; } else{Llcm=make_bow(get<Lbow>(bow[ter]));}\n\tif(get<Rbow>(bow[ter])==0){ Rlcm=1; } else{Rlcm=make_bow(get<Rbow>(bow[ter]));}\n\tSmom=LCMme( Llcm*get<Llong>(bow[ter]) , Rlcm*get<Rlong>(bow[ter]) );\n\treturn (Smom/get<Llong>(bow[ter])) + (Smom/get<Rlong>(bow[ter]));\n}\nbool solve(void){\n\tllint i,n,a,b,c,d,e,ans;\n\tbow.clear();//?£????????????????\n\tllint used_bow[101]={0};\n\tllint top_bow=0;\n\tscanf(\"%lld\",&n);\n\tif(n==0){ return false; }\n\tbow.push_back(make_tuple(1,1,0,0));//1???????£?????§??????????\n\tfor(i=1;i<=n;i++){\n\t\tscanf(\"%lld %lld %lld %lld\",&a,&b,&c,&d);\n\t\tbow.push_back(make_tuple(a,b,c,d));\n\t\tused_bow[c]=1;\n\t\tused_bow[d]=1;\n\t}\n\tfor(i=1;i<=n;i++){\n\t\tif(used_bow[i]==0){top_bow=i;break;}\n\t}\n\tans=make_bow(top_bow);\n\tprintf(\"%lld\\n\",ans);\n\treturn true;\n}\nint main(void){\n\twhile(solve()){}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nll gcd(ll a, ll b) {\n  return b != 0 ? gcd(b, a % b) : a;\n}\n\nconst ll WEIGHT=-1;\nstruct stick{\n\tll r,b,p,q;\n\tstick(ll r,ll b,ll p,ll q):r(r),b(b){\n\t\tll g=gcd(p,q);\n\t\tthis->p=p/g;\n\t\tthis->q=q/g;\n\t}\n\tll getroot(ll index,vector<stick> &sticks){\n\t\tREP(i,sticks.size()){\n\t\t\tif(sticks[i].r==index||sticks[i].b==index){\n\t\t\t\treturn sticks[i].getroot(i,sticks);\n\t\t\t}\n\t\t}\n\t\treturn index;\n\t}\n\tll go(vector<stick> &sticks){\n\t\tll rw=0,bw=0;\n\t\tif(r!=WEIGHT){\n\t\t\trw=sticks[r].go(sticks);\n\t\t}\n\t\tif(b!=WEIGHT){\n\t\t\tbw=sticks[b].go(sticks);\n\t\t}\n\t\tif(r==WEIGHT&&b==WEIGHT){\n\t\t\trw=q;\n\t\t\tbw=p;\n\t\t}else if(r==WEIGHT){\n\t\t\tif(p*bw%q){\n\t\t\t\trw=bw*p;\n\t\t\t\tbw*=q;\n\t\t\t}else{\n\t\t\t\trw=bw*p/q;\n\t\t\t\tassert(bw);\n\t\t\t}\n\t\t}else if(b==WEIGHT){\n\t\t\tif(q*rw%p){\n\t\t\t\tbw=rw*q;\n\t\t\t\trw*=p;\n\t\t\t}else{\n\t\t\t\tbw=rw*q/p;\n\t\t\t\tassert(rw);\n\t\t\t}\n\t\t}else{\n\t\t\tassert(bw);\n\t\t\tassert(rw);\n\t\t\tll trw=rw,tbw=bw;\n\t\t\tll gr=gcd(rw,q);\n\t\t\tll gb=gcd(bw,p);\n\t\t\trw=trw*tbw*q/gr/gb;\n\t\t\tassert(tbw);\n\t\t\tassert(trw);\n\t\t\tassert(p);\n\t\t\t//cerr<<tbw<<\",\"<<trw<<\",\"<<p<<\",\"<<gb<<endl;\n\t\t\tassert(gb);\n\t\t\tbw=tbw*trw*p/gb/gr;\n\t\t\tassert(bw);\n\t\t\tassert(rw);\n\t\t}\n\t\tassert(rw&&bw);\n\t\treturn rw+bw;\n\t}\n};\n\n\nint main(){\n\tll n;\n\twhile(cin>>n,n){\n\t\tvector<stick> sticks;\n\t\tREP(i,n){\n\t\t\tll p,q,r,b;\n\t\t\tcin>>p>>q>>r>>b;\n\t\t\tr--;b--;\n\t\t\tsticks.push_back(stick(r,b,p,q));\n\t\t}\n\t\tll root=sticks[0].getroot(0,sticks);\n\t\tcout<<sticks[root].go(sticks)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#define LL long long\nusing namespace std;\nLL n;\nLL p[111];\nLL q[111];\nLL r[111];\nLL b[111];\nLL m[111];\n\nLL GCD(LL x,LL y){\n  if(x < y) x^=y^=x^=y;\n  LL r = x % y;\n  if(r) return GCD(y,r);\n  else return y;\n}\n\nLL solve(int k){\n  if(k == 0) return 1;\n  if(m[k]) return m[k];\n  LL rm = solve(r[k]) * p[k];\n  LL bm = solve(b[k]) * q[k];\n  LL l = rm * bm / GCD(rm,bm);\n  //cout << \"k = \" << k << \" : \" << l/p[k] << \" + \" << l/q[k] << endl;\n  return m[k] = l/p[k] + l/q[k];\n}\n\nint main(void){\n  while(cin >> n && n){\n    memset(p,0,sizeof(p));\n    memset(q,0,sizeof(q));\n    memset(r,0,sizeof(r));\n    memset(b,0,sizeof(b));\n    memset(m,0,sizeof(m));\n    for(int i = 1; i <= n; i++){\n      cin >> p[i] >> q[i] >> r[i] >> b[i];\n      LL g = GCD(p[i],q[i]);\n      p[i] /= g;\n      q[i] /= g;\n    }\n    LL res = 0;\n    for(int i = 1; i <= n; i++){\n      res = max(res,solve(i));\n    }\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <cstring>\nusing namespace std;\n\nint dp[110],K[110],O[110],L[110],R[110];\n\nint gcd(int a,int b){\n\tint tmp;\n\tif(a<b) swap(a,b);\n\twhile((tmp=a%b)!=0){\n\t\ta=b;\n\t\tb=tmp;\n\t}\n\treturn b;\n}\n\n\nint mobi(int bou){\n\tif(bou==0) return 1;\n\tif(dp[bou]!=0) return dp[bou];\n\tint l,r,li,ri,gc2,a,b;\n\tl=mobi(L[bou]);\n\tr=mobi(R[bou]);\n\tri=K[bou];li=O[bou];\n\tgc2=gcd(li*l,ri*r);\n\tb=li*l/gc2;\n\ta=ri*r/gc2;\n\tdp[bou]=(a*l+b*r);\n\treturn dp[bou];\n}\n\nint main(){\n\tint N,k,o,g;\n\tint res;\n\twhile(1){\n\t\tcin>>N;\n\t\tif(N==0) break;\n\t\tmemset(dp+1,0,sizeof(int)*N);\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tcin>>k>>o>>L[i]>>R[i];\n\t\t\tg=gcd(k,o);\n\t\t\tK[i]=k/g;\n\t\t\tO[i]=o/g;\n\t\t}\n\t\tres=0;\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tres=max(res,mobi(i));\n\t\t}\n\t\t/*\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tcout<<i<<\" \"<<dp[i]<<endl;//\n\t\t}\n\t\t*/\n\t\tcout<<res<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\nusing namespace std;\nstatic const int INF = 1ll<<60;\ntypedef pair<int,int> pii;\n\nstruct P{\n    int p;\n    int q;\n    int r;\n    int b;\n    P(){}\n    P(int p1,int p2,int p3,int p4){\n        p=p1;\n        q=p2;\n        r=p3;\n        b=p4;\n    }\n};\n\nint N;\ndouble R,B;\nvector<P> S;\nbool cone[110];\n\nint GCD(int a,int b){\n    return b?GCD(b,a%b):a;\n}\n\nint LCM(int a,int b){\n    return a*b/GCD(max(a,b),min(a,b));\n}\n\nint dfs(int n){\n    if(n==-1)return 1;\n    int R = dfs(S[n].r)*S[n].p;\n    int B = dfs(S[n].b)*S[n].q;\n    int lcm = LCM(R,B);\n    return lcm/S[n].p+lcm/S[n].q;\n}\n\nsigned main(){\n    while(1){\n        cin>>N;\n        if(N==0)break;\n        for(int i=0;i<N;++i){\n            int p,q,r,b;\n            cin>>p>>q>>r>>b;\n            r--;\n            b--;\n            cone[r]=true;\n            cone[b]=true;\n            S.PB(P(p,q,r,b));\n        }\n        for(int i=0;i<N;++i){\n            if(!cone[i]){\n                cout<<dfs(i)<<endl;\n                break;\n            }\n        }\n        S.clear();\n        memset(cone,0,sizeof(cone));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"math.h\"\n#include \"utility\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"iomanip\"\n#include \"random\"\n\nusing namespace std;\nconst long long int MOD = 1000000007;\n\nint N;\nlist<int>P;\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin >> N;\n\tP.push_back(2);\n\tfor (int i = 3; i < pow(2, 16); i += 2) {\n\t\tbool flag = true;\n\t\tfor (auto j : P) {\n\t\t\tif (i%j == 0) {\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (j*j > i)break;\n\t\t}\n\t\tif (flag)P.push_back(i);\n\t}\n\twhile (N) {\n\t\tvector<long long int>l(N);\n\t\tvector<long long int>r(N);\n\t\tvector<int>lx(N);\n\t\tvector<int>rx(N);\n\t\tvector<long long int>lw(N);\n\t\tvector<long long int>rw(N);\n\t\tvector<bool>flag(N, true);\n\t\tstack<int>node;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tint a, b, c, d;\n\t\t\tcin >> a >> b >> c >> d;\n\t\t\tc--;\n\t\t\td--;\n\t\t\tl[i] = a;\n\t\t\tr[i] = b;\n\t\t\tlx[i] = c;\n\t\t\trx[i] = d;\n\t\t\tif (c == -1)lw[i] = 1;\n\t\t\tif (d == -1)rw[i] = 1;\n\t\t\tif (c >= 0)flag[c] = false;\n\t\t\tif (d >= 0)flag[d] = false;\n\t\t}\n\t//\tcout << \"hijiki\";\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (flag[i]) {\n\t\t\t\tnode.push(i);\n\t\t\t}\n\t\t}\n\t\twhile (!node.empty()) {\n\t\t\tint current = node.top();\n\t\t\tif (lx[current] >= 0) {\n\t\t\t\tif (lw[lx[current]] && rw[lx[current]])lw[current] = lw[lx[current]] + rw[lx[current]];\n\t\t\t\telse {\n\t\t\t\t\tnode.push(lx[current]);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rx[current] >= 0) {\n\t\t\t\tif (lw[rx[current]] && rw[rx[current]])rw[current] = lw[rx[current]] + rw[rx[current]];\n\t\t\t\telse {\n\t\t\t\t\tnode.push(rx[current]);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (l[current] * lw[current] != r[current] * rw[current]) {\n\t\t\t\tlong long int a = r[current] * rw[current];\n\t\t\t\tlong long int b = l[current] * lw[current];\n\t\t\t\tfor (auto i : P) {\n\t\t\t\t\twhile(a%i==0&&b%i==0){\n\t\t\t\t\t\ta /= i;\n\t\t\t\t\t\tb /= i;\n\t\t\t\t\t}\n\t\t\t\t\tif (min(a, b) < i)break;\n\t\t\t\t}\n\t\t\t\tlw[current] *= a;\n\t\t\t\trw[current] *= b;\n\t\t\t}\n\t\t\tnode.pop();\n\t\t}\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (flag[i]) {\n\t\t\t\tcout << lw[i] + rw[i] << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcin >> N;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <vector>\nusing namespace std;\n\nint gcd(int x, int y) {\n    while(y) {\n        int t=x%y;x=y;y=t;\n    }\n    return x;\n}\n\nint ps[100],qs[100],rs[100],bs[100], memo[100];\n\nint calc(int i) {\n    if(i==-1) return 1;\n    if(memo[i]>=0) return memo[i];\n    int r = calc(rs[i]);\n    int b = calc(bs[i]);\n    int p = ps[i];\n    int q = qs[i];\n    return (memo[i] = (p+q)*r*b/gcd(r*p, b*q));\n}\n\nint main() {\n    while(true) {\n        int n; scanf(\"%d\", &n);\n        if(n==0) break;\n        fill(memo, memo+n, -1);\n        for(int i = 0; i < n; i++) {\n            scanf(\"%d%d%d%d\", ps+i, qs+i, rs+i, bs+i);\n            rs[i]--; bs[i]--;\n        }\n        int max_val = 0;\n        for(int i = 0; i < n; i++) {\n            max_val = max(max_val, calc(i));\n        }\n        printf(\"%d\\n\", max_val);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint p[101],q[101],r[101],b[101],used[102];\n\nint saiki(int ima){\n  int A=1,B=1;\n  if(r[ima])A=saiki(r[ima]);\n  if(b[ima])B=saiki(b[ima]);\n  int res=__gcd(A*p[ima],B*q[ima]);\n  int resA=(A*p[ima])/res,resB=(B*q[ima])/res;\n  return (A*resB)+(B*resA);\n}\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    memset(used,0,sizeof(used));\n    for(int i=1;i<=n;i++){\n      cin>>p[i]>>q[i]>>r[i]>>b[i];\n      int res=__gcd(p[i],q[i]);\n      p[i]/=res,q[i]/=res;\n      used[r[i]]=used[b[i]]=1;\n    }\n    for(int i=1;i<=n;i++)if(!used[i]) cout<<saiki(i)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> rings;\nvector<int> neib[101];\nint used[101];\nint onceused[101];\nint minds[101];\n\nint dfs(int x){\n  used[x] = 1;\n  onceused[x] = 1;\n  int res = 1;\n  for(int i = 0;i < neib[x].size();i++){\n    if(used[neib[x][i]] == 0){\n      res = max(res, 1 + dfs(neib[x][i]));\n    }\n  }\n  used[x] = 0;\n  return res;\n}\n\nint mindfs(int x){\n  int res = neib[x].size();\n  onceused[x] = 1;\n  for(int i = 0;i < neib[x].size();i++){\n    if(onceused[neib[x][i]] == 1)continue;\n    res = min(res, mindfs(neib[x][i]));\n  }\n  return res;\n}\n\nint main(){\n  while(1){\n    int n, ans = 0, mind = 10000;\n    rings.clear();\n    for(int i = 0;i < 101;i++)neib[i].clear();\n    scanf(\"%d\", &n);\n    if(n == 0)return 0;\n    for(int i = 0;i < n;i++){\n      int a, b; \n      scanf(\"%d%d\", &a, &b);\n      rings.push_back(a);\n      rings.push_back(b);\n      neib[a].push_back(b);\n      neib[b].push_back(a);\n    }\n    memset(used, 0, sizeof(used));\n    for(int i = 0;i < rings.size();i++){\n      minds[rings[i]] = mindfs(rings[i]);\n    }\n    for(int i = 0;i < rings.size();i++){\n      memset(onceused, 0, sizeof(used));\n      if(neib[rings[i]].size() == minds[rings[i]]){\n\tans = max(ans, dfs(rings[i]));\n      }\n    }\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long lld;\n\nint n;\nlld p[111],q[111],r[111],t[111];\nlld dp[111];\n\nlld lcm(int a,int b){\n  return a / __gcd(a,b)*b;\n}\n\nlld solve(int n){\n  if(dp[n] != -1) return dp[n];\n  lld left = 1,right = 1;\n  if(r[n] != -1) left = solve(r[n]);\n  if(t[n] != -1) right = solve(t[n]);\n  lld ret = lcm(left * p[n],right * q[n]);\n  return dp[n] = ret / p[n] + ret / q[n];\n}\n\nint main(){\n  while(cin >> n ,n){\n    memset(dp,-1,sizeof(dp));\n    for(int i=0;i<n;i++){\n      cin >> p[i] >> q[i] >> r[i] >> t[i];\n      r[i]--; t[i]--;\n    }\n    lld ret = 0;\n    for(int i=0;i<n;i++){\n      ret = max(ret,solve(i));\n    }\n    cout << ret << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n\nint n;\nint bodate[101][5];//右ロン、左ロン、右子、左子、親。\nint roots;\n\nint gcd(int a,int b){\n  if(a>b){\n    if(a%b==0) return b;\n    else return gcd(a%b,b);\n  }\n  else{\n    if(b%a==0) return a;\n    else return gcd(b%a,a);\n  }\n}\n\n\n\nint chains(int now){\n  int mim=0;\n  if(bodate[now][2]!=0) mim=chains(bodate[now][2]);\n  else mim=1;\n  int sam=0;\n  if(bodate[now][3]!=0) sam=chains(bodate[now][3]);\n  else sam=1;\n  int p=0;\n  int mihi,sahi;\n  p=gcd(bodate[now][0],bodate[now][1]);\n  mihi=bodate[now][1]/p;\n  sahi=bodate[now][0]/p;\n  int mip,sap;\n  p=gcd(mim*sahi,sam*mihi);\n  mip=sam*mihi/p;\n  sap=mim*sahi/p;\n  return mim*mip+sam*sap;\n}\n\nint main(void){\n  scanf(\"%d\",&n);\n  while(n!=0){\n    int i;\n    roots=0;\n    memset(bodate,0,sizeof(bodate));\n    for(i=1;i<=n;i++){\n      scanf(\"%d%d%d%d\",&(bodate[i][0]),&(bodate[i][1]),&(bodate[i][2]),&(bodate[i][3]));\n      if(bodate[i][2]!=0)bodate[bodate[i][2]][4]=i;\n      if(bodate[i][3]!=0)bodate[bodate[i][3]][4]=i;\n    }\n    i=1;\n    while(bodate[i][4]!=0){\n      i=bodate[i][4];\n    }\n    roots=i;\n    int ans=chains(roots);\n\n    printf(\"%d\\n\",ans);\n    scanf(\"%d\",&n);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\n#define swap(a,b) do {\\\n    a ^= b;\\\n    b ^= a;\\\n    a ^= b;\\\n} while(0)\n\ntypedef struct _Mobile {\n    struct _Mobile *parent;\n    struct _Mobile *left_vertex;\n    struct _Mobile *right_vertex;\n    int weight;\n    int left_length;\n    int right_length;\n} Mobile;\n\n\nint gcd(int a, int b) {\n    int c;\n\n    if (a < b) swap(a,b);\n\n    c = a % b;\n    while (c) {\n        a = b;\n        b = c;\n        c = a % b;\n    }\n\n    return b;\n}\n\nvoid dive(Mobile *vertex) {\n    int left_weight;\n    int right_weight;\n    int gcm;\n    int new_left_weight;\n    int new_right_weight;\n\n    if (vertex->left_vertex) {\n        dive(vertex->left_vertex);\n        left_weight = vertex->left_vertex->weight;\n    } else {\n        left_weight = 0;\n    }\n\n    if (vertex->right_vertex) {\n        dive(vertex->right_vertex);\n        right_weight = vertex->right_vertex->weight;\n    } else {\n        right_weight = 0;\n    }\n\n    gcm = gcd(vertex->left_length, vertex->right_length);\n    new_left_weight = vertex->right_length/gcm;\n    new_right_weight = vertex->left_length/gcm;\n\n    if (right_weight) {\n            int factor = right_weight/gcd(right_weight, new_right_weight);\n            new_right_weight *= factor;\n            new_left_weight *= factor;\n    } \n\n    if (left_weight) {\n            int factor = left_weight/gcd(left_weight, new_left_weight);\n            new_left_weight *= factor;\n            new_right_weight *= factor;\n    }\n\n    vertex->weight = new_left_weight + new_right_weight;\n    return;\n}\n\nint main() {\n    while (1) {\n        int i;\n        int n;\n        Mobile *most_parent;\n\n        scanf(\"%d\", &n);\n        if (!n) return 0;\n\n        Mobile vertexes[100];\n\n        for (i=0;i<n;i++) {\n            vertexes[i].parent = NULL;\n            vertexes[i].weight = 0;\n        }\n\n        for (i=0;i<n;i++) {\n            int p, q, r, b;\n            scanf(\"%d %d %d %d\", &p, &q, &r, &b);\n            vertexes[i].left_length = p;\n            vertexes[i].right_length = q;\n            vertexes[i].left_vertex = (Mobile*)(r==0)?NULL:&vertexes[r-1];\n            vertexes[i].right_vertex = (Mobile*)(b==0)?NULL:&vertexes[b-1];\n\n            if (r) {\n                vertexes[r-1].parent = &vertexes[i];\n            }\n\n            if (b) {\n                vertexes[b-1].parent = &vertexes[i];\n            }\n\n        }\n\n        Mobile *tmp = &vertexes[0];\n        while (tmp->parent) {\n            tmp = tmp->parent;\n        }\n        most_parent = tmp;\n\n        dive(most_parent);\n\n        printf(\"%d\\n\", most_parent->weight);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, a, b) for(int i=(a); i<(b); i++)\n#define REP(i, n) FOR(i, 0, n)\n#define all(x) (x).begin(), (x).end()\n#define bit(x) (1L << (x))\nusing ll = long long;\nusing namespace std;\n\ntemplate<typename T>\nvector<T> make_v(size_t a,T b){return vector<T>(a,b);}\n \ntemplate<typename... Ts>\nauto make_v(size_t a,Ts... ts){\n    return vector<decltype(make_v(ts...))>(a,make_v(ts...));\n}\n\nstruct poll {\n    int p, q, r, b;\n};\n\nint gcd(int x, int y) {\n    return (y == 0) ? x : gcd(y, x % y); \n}\n\nint lcm(int x, int y) {\n    return x / gcd(x, y) * y;\n}\n\nint solve(const vector<poll>& polls, int i) {\n    if (i == -1) return 1;\n\n    int r_w = solve(polls, polls[i].r);\n    int b_w = solve(polls, polls[i].b);\n\n    int l = lcm(polls[i].p * r_w, polls[i].q * b_w);\n\n    return l / polls[i].p + l / polls[i].q;\n}\n\nint main() {\n    int n;\n    \n    while (cin >> n, n) {\n        vector<poll> polls(n);\n        vector<bool> child(n, false);\n\n        int s = -1;\n        REP(i, n) {\n            int p, q, r, b; cin >> p >> q >> r >> b;\n            --r; --b;\n            polls[i] = {p, q, r, b};\n\n            if (r != -1 && b != -1) s = i;\n            if (r != -1) child[r] = true;\n            if (b != -1) child[b] = true;\n        }\n\n        cout << solve(polls, find(child.begin(), child.end(), false) - child.begin()) << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint edge[100][6];\n\nint gcd(int m, int n){\n    int temp;\n    if(m > n){\n        temp = m;\n        m = n;\n        n = temp;\n    }\n    while(m){\n        temp = m;\n        m = n % m;\n        n = temp;\n    }\n    return n;\n}\n\nint binary(int i){\n    int bin1, bin2, l;\n    bin1 = 1;\n    bin2 = 1;\n    if(edge[i][2]){\n        bin1 = binary(edge[i][2]-1);\n    }\n    if(edge[i][3]){\n        bin2 = binary(edge[i][3]-1);\n    }\n    l = bin1/gcd(bin1, bin2) * bin2;\n    return l*(edge[i][4] + edge[i][5]);\n}\n\nint main(){\n    int n;\n    int i;\n    int g;\n    bool data[101];\n    int top;\n    cin >> n;\n    while(n){\n        for(i=1;i<=n;i++){\n            data[i] = false;\n        }\n        for(i=0;i<n;i++){\n            cin >> edge[i][0] >> edge[i][1] >> edge[i][2] >> edge[i][3];\n            g = gcd(edge[i][0], edge[i][1]);\n            edge[i][4] = edge[i][1]/g;\n            edge[i][5] = edge[i][0]/g;\n            data[edge[i][2]] = true;\n            data[edge[i][3]] = true;\n        }\n        for(i=1;i<=n;i++){\n            if(!data[i]){\n                top = i-1;\n                break;\n            }\n        }\n        cout << binary(top) << endl;\n        cin >> n;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i = (a); i < (b); i++)\n#define REP(i,n) FOR(i,0,n)\n\nstruct Node {\n\tint a, b, ma, mb;\n\t\n\tNode() {}\n\tNode(int a, int b, int ma, int mb) : a(a), b(b), ma(ma), mb(mb) {}\n};\n\nint n;\nNode node[100];\nbool istop[100];\n\nint gcd(int a, int b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a % b);\n}\n\nint dfs(int pos) {\n\tNode &now = node[pos];\n\t\n\tint a = now.a, b = now.b, ma = now.ma, mb = now.mb;\n\t\n\tif (ma != 0) ma = dfs(ma - 1);\n\tif (mb != 0) mb = dfs(mb - 1);\n\t\n\tif (ma == 0 && mb == 0) {\n\t\treturn a + b;\n\t\n\t} else if (ma == 0 || mb == 0) {\n\t\tif (ma == 0) swap(ma, mb);\n\t\treturn ma * (a + b);\n\t\t\n\t}\n\telse {\n\t\tint x = gcd(a * ma, b * mb);\n\t\tint res1 = mb * (a * ma / x);\n\t\tint res2 = ma * (b * mb / x);\n\t\treturn res1 + res2;\n\t}\n}\n\nint main() {\n\twhile (cin >> n, n) {\n\t\tfill(node, node + n, Node());\n\t\tfill(istop, istop + n, false);\n\t\t\n\t\tREP(i, n) {\n\t\t\tint a, b, ma, mb;\n\t\t\tscanf(\"%d %d %d %d\", &a, &b, &ma, &mb);\n\t\t\tint g = gcd(a, b);\n\t\t\ta /= g; b /= g;\n\t\t\tnode[i] = Node(a, b, ma, mb);\n\t\t\t\n\t\t\tif (ma != 0) istop[ma - 1] = true;\n\t\t\tif (mb != 0) istop[mb - 1] = true;\n\t\t}\n\t\t\n\t\tint st = 0;\n\t\twhile (istop[st]) st++;\n\t\tcout << dfs(st) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstring>\n#include <iostream>\n\nusing namespace std;\n\nstruct Stick {\n  int p, q, r, b;\n};\n\nStick sticks[101];\n\nvoid simplify_ratio(int& x, int& y) {\n  int i = x, j = y;\n  if (i < j) swap(i, j);\n  while (j) {\n    int t = j;\n    j = i % j;\n    i = t;\n  }\n  x /= i;\n  y /= i;\n}\n\nint rec(int i) {\n  Stick s = sticks[i];\n  int r = s.r ? rec(s.r) : 1, b = s.b ? rec(s.b) : 1, x = s.q * b, y = s.p * r;\n  simplify_ratio(x, y);\n  return r * x + b * y;\n}\n\nint main() {\n  for (;;) {\n    int n;\n    cin >> n;\n    if (!n) return 0;\n    int top = 1;\n    memset(sticks, 0, sizeof sticks);\n    for (int i = 1; i <= n; i++) {\n      Stick s;\n      cin >> s.p >> s.q >> s.r >> s.b;\n      simplify_ratio(s.p, s.q);\n      if (top == s.r || top == s.b)\n        top = i;\n      sticks[i] = s;\n    }\n    cout << rec(top) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cstdio>\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> P;\ntypedef pair<LL, LL> PLL;\n\nLL gcd(LL x, LL y) {\n    if (x < y) { swap(x, y); }\n    if (y == 0) { return x; }\n    return gcd(y, x % y);\n}\n\nstruct mobile {\n    int lb;\n    int rb;\n    LL lm;\n    LL rm;\n};\n\nint N;\nmobile ms[110];\n\nint get_root() {\n    for (int j = 0; j < N; ++j) {\n        bool found = false;\n        for (int k = 0; k < N; ++k) {\n            if (ms[k].lm == j || ms[k].rm == j) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            return j;\n        }\n    }\n    return -1;\n}\n\nLL rec(int x) {\n    mobile& m = ms[x];\n\n    LL t = gcd(m.lb, m.rb);\n\n    if (m.lm == -1 && m.rm == -1) {\n        return (m.lb + m.rb) / t;\n    }\n\n    LL lw, rw;\n    if (m.lm != -1 && m.rm == -1) {\n        lw = rec(m.lm) * (m.rb / t);\n        rw = (lw * m.lb) / m.rb;\n    } else if (m.lm == -1 && m.rm != -1) {\n        rw = rec(m.rm) * (m.lb / t);\n        lw = (rw * m.rb) / m.lb;\n    } else {\n        lw = rec(m.lm) * (m.rb / t);\n        rw = rec(m.rm) * (m.lb / t);\n        int u = gcd(lw * m.lb, rw * m.rb);\n        int tmp = lw;\n        lw *= (rw * m.rb) / u;\n        rw *= (tmp * m.lb) / u;\n    }\n\n    assert(lw * m.lb == rw * m.rb);\n    return lw + rw;\n}\n\nbool solve() {\n\n    cin >> N;\n    if (N == 0) {\n        return false;\n    }\n    for (int j = 0; j < N; ++j) {\n        cin >> ms[j].lb >> ms[j].rb >> ms[j].lm >> ms[j].rm;\n        --ms[j].lm; --ms[j].rm;\n    }\n\n    int root = get_root();\n\n    cout << rec(root) << endl;\n\n    return true;\n}\n\nint main() {\n    while(solve());\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> plli;\ntypedef pair<int,pii> pipii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n);i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a);i>b;i--)\n#define pb push_back\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n\nconst ll mod = 1e9 + 7;\nconst ll INF = 1<<30;\nconst int dx4[4] = {1, 0, -1, 0};\nconst int dy4[4] = {0, 1, 0, -1};\nconst int dx8[8] = {1, 1, 1, 0, 0, -1, -1, -1};\nconst int dy8[8] = {0, 1, -1, 1, -1, 0, 1, -1};\nconst double pi = 3.141592653589793;\n\nint n;\nstruct stick {int pr, qb, ri, bi;};\n\nlong long  gcd(long long a, long long b) {\n    if (b == 0) return a;\n    return gcd(b, a % b);\n}\n\nlong long lcm(long long a, long long b) {\n    long long g = gcd(a, b);\n    return a / g * b;\n}\n\nint dfs(int now, vector<vector<stick>>& st) {\n    int p = st[now][0].pr;\n    int q = st[now][0].qb;\n    int r = st[now][0].ri;\n    int b = st[now][0].bi;\n    int wr = 1;\n    int wb = 1;\n    if (r == 0 && b == 0) return p + q;\n    if (r != 0) wr = dfs(r, st);\n    if (b != 0) wb = dfs(b, st);\n    int l = lcm(wr * p, wb * q);\n    return l / p + l / q;\n}\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> n;\n    while (n != 0) {\n        vector<vector<stick>> st(105);\n        int cnt[105] = {};\n        rep(i, n) {\n            int p, q, r, b;\n            cin >> p >> q >> r >> b;\n            int g = gcd(p, q);\n            p /= g;\n            q /= g;\n            st[i + 1].pb(stick{p, q, r, b});\n            cnt[r] += 1;\n            cnt[b] += 1;\n        }\n        int s = 0;\n        rep(i, n + 1) if (cnt[i] == 0) {s = i; break;}\n        int ans = dfs(s, st);\n        cout << ans << endl;\n        cin >> n;\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps = 1e-9;\n\nlong long int gcd(long long int l, long long int r) {\n\tassert(l > 0 && r > 0);\n\tif (l > r)return gcd(r, l);\n\telse {\n\t\tconst long long int num = r%l;\n\t\tif (num) {\n\t\t\treturn gcd(l, num);\n\t\t}\n\t\telse {\n\t\t\treturn l;\n\t\t}\n\t}\n}\nlong long int lca(long long int l, long long int r) {\n\treturn l / gcd(l, r)*r;\n}\n\nstruct mobi {\n\tlong long int a;\n\tlong long int b;\n\tint lid;\n\tint rid;\n\n};\n\nlong long int getans(const int id,const vector<mobi>&ms) {\n\tlong long int lw=0, rw=0;\n\tif (ms[id].lid!=-1) {\n\t\tlw = getans(ms[id].lid, ms);\n\t}\n\telse {\n\t\tlw = 1;\n\t}\n\tif (ms[id].rid != -1) {\n\t\trw = getans(ms[id].rid, ms);\n\t}\n\telse {\n\t\trw = 1;\n\t}\n\tlong long int al = lw*ms[id].b;\n\tlong long int ar = rw*ms[id].a;\n\tlong long int alca = lca(al, ar);\n\treturn alca / al*lw + alca / ar*rw;\n}\n\nint main() {\n\twhile (1) {\n\t\tint N; cin >> N;\n\t\tif (!N)break;\n\t\tvector<mobi>ms;\n\t\tvector<int>pas(N);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint a, b, lid, rid; cin >> a >> b >> lid >> rid;\n\t\t\tlid--; rid--;\n\t\t\tif (lid != -1)pas[lid] = true;\n\t\t\tif (rid != -1)pas[rid] = true;\n\t\t\tconst long long int agcd = gcd(a, b);\n\t\t\ta /= agcd; b /= agcd;\n\t\t\tms.push_back(mobi{ a,b,lid,rid });\n\t\t}\n\t\tint nopa = find(pas.begin(), pas.end(), false) - pas.begin();\n\t\tlong long int ans = getans(nopa, ms);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nint gcd(int a, int b) {\n\tif (a % b == 0)return b;\n\treturn gcd(b, a % b);\n}\n\nint lcm(int a, int b) {\n\treturn a / gcd(a, b) * b;\n}\n\nstruct Mobile {\n\tint l, r, left, right, parent;\n};\n\nint n;\nMobile m[100];\n\nint solve(int x) {\n\tint Left, Right;\n\n\tif (m[x].left == 0)Left = 1;\n\telse Left = solve(m[x].left - 1);\n\tif (m[x].right == 0)Right = 1;\n\telse Right = solve(m[x].right - 1);\n\treturn lcm(Left * m[x].l, Right * m[x].r) / m[x].r + lcm(Left * m[x].l, Right * m[x].r) / m[x].l;\n}\n\nint main() {\n\twhile (cin >> n, n) {\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tm[i].l = 0, m[i].r = 0, m[i].left = 0, m[i].right = 0;\n\t\t\tm[i].parent = -1;\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> m[i].l >> m[i].r >> m[i].left >> m[i].right;\n\t\t\tif (m[i].left != 0)m[m[i].left - 1].parent = i;\n\t\t\tif (m[i].right != 0)m[m[i].right - 1].parent = i;\n\t\t\t{\n\t\t\t\tint l = m[i].l, r = m[i].r;\n\t\t\t\tm[i].l = m[i].l / gcd(l, r), m[i].r = m[i].r / gcd(l, r);\n\t\t\t}\n\t\t}\n\t\tint x = 0;\n\t\twhile (1) {\n\t\t\tif (m[x].parent == -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tx = m[x].parent;\n\t\t}\n\t\tcout << solve(x) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<map>\n#include<vector>\n#include<cmath>\nusing namespace std;\nint N;\nstruct edge{\n  int p,q,r,b;\n  edge(){}\n  edge(int p,int q,int r,int b) : p(p),q(q),r(r),b(b) {}\n};\nedge E[102];\nint yukuri(int n,int m){\n  int tmp = max(n,m);\n  n = min(n,m);\n  m = tmp;\n  while( n > 0 ){\n    tmp = n;\n    n = m%n;\n    m = tmp;\n  }\n  return m;\n}\nint solve(int id){\n  int r,b;\n  if(E[id].r == 0)\n    r=1;\n  else\n    r=solve(E[id].r);\n  if(E[id].b == 0)\n    b=1;\n  else\n    b=solve(E[id].b);\n  int tp = E[id].p * r * b;\n  int tq = E[id].q * r * b;\n  tp /= b;\n  tq /= r;\n  int n = yukuri(tp,tq);\n  tp/=n; tq/=n;\n  b*=tp; r*=tq;\n  return b+r;\n}\nint main(){\n  while(scanf(\"%d\",&N),N){\n    bool f[102];\n    memset(f,0,sizeof(f));\n    for(int i=1;i<=N;i++){\n      int p,q,r,b;\n      scanf(\"%d %d %d %d\",&p,&q,&r,&b);\n      int n = yukuri(p,q);\n      //      printf(\"%d %d %d\\n\",p,q,n);\n      p/=n;\n      q/=n;\n      E[i].p = p; E[i].q = q;\n      E[i].r = r; E[i].b = b;\n      f[r] = true; f[b] = true;\n    }\n    int id;\n    //    puts(\"ok\");\n    for(int i=1;i<=N;i++)\n      if(!f[i]) id = i;\n    printf(\"%d\\n\",solve(id));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint N;\nint P[105], Q[105], R[105], B[105];\nint dfs(int v)\n{\n    int a = 1, b = 1, x, y, div;\n    if(~R[v]) a = dfs(R[v]);\n    if(~B[v]) b = dfs(B[v]);\n    x = b * Q[v], y = a * P[v];\n    div = __gcd(x, y);\n    return (x / div * a + y / div * b);\n}\nint main()\n{\n    while(cin >> N, N) {\n        int cnt[105] = {};\n        for(int i = 0; i < N; i++) {\n            int div;\n            cin >> P[i] >> Q[i] >> R[i] >> B[i]; R[i]--, B[i]--;\n            if(~R[i]) cnt[R[i]]++;\n            if(~B[i]) cnt[B[i]]++;\n        }\n        for(int i = 0; i < N; i++) {\n            if(cnt[i] <= 0) cout << dfs(i) << endl;\n        }\n    }\n    return (0);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n\nstruct Pole{\n\tint red_ratio,blue_ratio,red_topole,blue_topole;\n\tint sum_ball;\n\tPole(){sum_ball=-1;}\n};\n\nbool ask_ball(const Pole &a,const Pole &b){\n\tif(a.sum_ball>b.sum_ball)return true;\n\treturn false;\n}\n\nint gcd(int a,int b){\n\tint c;\n\tif(b>a)c=a,a=b,b=c;\n\twhile(b!=0)c=b,b=a%b,a=c;\n\treturn a;\n}\n\n\nint main(){\n\tint n;\n\twhile(std::cin>>n){\n\t\tPole pole[101];\n\t\tif(n==0)break;\n\t\tfor(int i=0;i<n;i++)std::cin>>pole[i].red_ratio>>pole[i].blue_ratio>>pole[i].red_topole>>pole[i].blue_topole;\n\t\tfor(int k=0;k<n;k++){\t\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(pole[i].sum_ball==-1){\n\t\t\t\t\tint ball=gcd(pole[i].red_ratio,pole[i].blue_ratio);\n\t\t\t\t\tif(pole[i].red_topole==0&&pole[i].blue_topole==0)pole[i].sum_ball=(pole[i].red_ratio/ball)+(pole[i].blue_ratio/ball);\n\t\t\t\t\telse if(pole[i].red_topole==0&&pole[pole[i].blue_topole-1].sum_ball!=-1){\n\t\t\t\t\t\tfor(int j=pole[pole[i].blue_topole-1].sum_ball;;j+=pole[pole[i].blue_topole-1].sum_ball){\n\t\t\t\t\t\t\tdouble red=(double)(pole[i].blue_ratio*j)/pole[i].red_ratio;\n\t\t\t\t\t\t\tif(ceil(red)==floor(red)){\n\t\t\t\t\t\t\t\tpole[i].sum_ball=red+j;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if(pole[i].blue_topole==0&&pole[pole[i].red_topole-1].sum_ball!=-1){\n\t\t\t\t\t\tfor(int j=pole[pole[i].red_topole-1].sum_ball;;j+=pole[pole[i].red_topole-1].sum_ball){\n\t\t\t\t\t\t\tdouble blue=(double)(pole[i].red_ratio*j)/pole[i].blue_ratio;\n\t\t\t\t\t\t\tif(ceil(blue)==floor(blue)){\n\t\t\t\t\t\t\t\tpole[i].sum_ball=blue+j;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if(pole[pole[i].red_topole-1].sum_ball!=-1&&pole[pole[i].blue_topole-1].sum_ball!=-1){\n\t\t\t\t\t\tint red=pole[pole[i].red_topole-1].sum_ball,blue=pole[pole[i].blue_topole-1].sum_ball;\n\t\t\t\t\t\twhile(1){\n\t\t\t\t\t\t\tif(red*pole[i].red_ratio<blue*pole[i].blue_ratio)red+=pole[pole[i].red_topole-1].sum_ball;\n\t\t\t\t\t\t\telse if(red*pole[i].red_ratio>blue*pole[i].blue_ratio)blue+=pole[pole[i].blue_topole-1].sum_ball;\n\t\t\t\t\t\t\telse break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpole[i].sum_ball=red+blue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstd::sort(pole+0,pole+n,ask_ball);\n\t\tstd::cout<<pole[0].sum_ball<<std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint x[110][2],w[110][2],n;\nbool cal[110];\nint COU(int a,int b){\n while(true){\n  if(a<2||b<2)return 1;\n  if(a<b){int t=a;a=b,b=t;}\n  a%=b;\n  if(!a)return b;\n }\n}\nlong long DFS(int q){\n    if(!q)return 1;\n    q--;\n    long long a=DFS(w[q][0]),b=DFS(w[q][1]);\n    return (a*b*(x[q][0]+x[q][1]))/COU(a*x[q][0],b*x[q][1]);\n}\nint main(){\n while(true){\n cin>>n;\n if(!n)break;\n for(int i=0;i<n;i++)cal[i]=false;\n for(int i=0;i<n;i++){\n  cin>>x[i][0]>>x[i][1]>>w[i][0]>>w[i][1];\n  cal[w[i][0]-1]=true,cal[w[i][1]-1]=true;\n }\n for(int i=0;i<n;i++){\n  if(!cal[i])cout<<DFS(i+1)<<endl;\n }\n }\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\ntypedef long long ll;\n\nll gcd(ll a,ll b){\n  return b == 0 ? a : gcd(b,a%b);\n}\nll lcm(ll a,ll b){\n  return a/gcd(a,b) * b;\n}\n/*\n */\nll compute(ll a,ll b,ll x,ll y){\n  ll l = lcm(a*x,b*y);\n  return l/a + l/b;\n}\n\nconst int N = 110;\nint node[N][2];\nint p[N][2];\nint w[N];\n\nll solve(int now){\n  \n  ll t[2];\n  rep(i,2){\n    if (node[now][i] != 0)t[i]=solve(node[now][i]-1);\n    else t[i] = 1;\n  }\n  w[now] = compute(p[now][0],p[now][1],t[0],t[1]);\n  return w[now];\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    rep(i,n){\n      w[i] = -1;\n      cin>>p[i][0]>>p[i][1];\n      cin>>node[i][0]>>node[i][1];\n    }\n    rep(i,n){\n      if (w[i] == -1)solve(i);\n    }\n    cout << *max_element(w,w+n) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nlong int a[100+2],b[100+2],c[100+2],d[100+2],w[100+2],n;\n\nint s(int x){\n\tint ans;\n\tif(w[x]!=-1)return w[x];\n\telse {\n\t\tint e=a[x]*s(c[x]),f=b[x]*s(d[x]);\n\t\tint g=e,h=f,gcd;\n\t\twhile(1){\n\t\t\tg%=h;\n\t\t\tif(g==0)break;\n\t\t\th%=g;\n\t\t\tif(h==0)break;\n\t\t}\n\t\tgcd=e*f/max(g,h);\n\t\tans=gcd/a[x]+gcd/b[x];\n\t}\n\tw[x]=ans;\n\treturn ans;\n}\n\nint main(){\nwhile(1){\n\tint an=0,aaa;\n\tscanf(\"%d\",&n);\n\tif(n==0)break;\n\tw[0]=1;\n\tfor(int i=1;i<=n;i++){scanf(\"%d%d%d%d\",&a[i],&b[i],&c[i],&d[i]); w[i]=-1;}\n\tfor(int i=1;i<=n;i++){\n\t\tif(w[i]==-1)aaa=s(i);\n\t\tif(an<w[i])an=w[i];\n\t}\n\tprintf(\"%d\\n\",an);\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\ntypedef long long LL;\n#define MAX(a,b) ((a)>=(b)?(a):(b))\nint p[100],q[100],r[100],b[100];\nLL memo[100];\nLL gcd(LL a,LL b) {\n\treturn b?gcd(b,a%b):a;\n}\nLL lcm(LL a,LL b) {\n\treturn a/gcd(a,b)*b;\n}\nLL solve(int n) {\n\tif(memo[n]!=-1) return memo[n];\n\tLL L,R;\n\tif(r[n]==-1) L=1; else L=solve(r[n]);\n\tif(b[n]==-1) R=1; else R=solve(b[n]);\n\tLL tmp=lcm(L*p[n],R*q[n]);\n\treturn memo[n]=(tmp/p[n]+tmp/q[n]);\n}\nint main() {\n\tint n;\n\twhile(scanf(\"%d\",&n),n) {\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tscanf(\"%d %d %d %d\",&p[i],&q[i],&r[i],&b[i]);r[i]--;b[i]--;\n\t\t}\n\t\tmemset(memo,-1,sizeof(memo));\n\t\tLL ans=0;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tans=MAX(ans,solve(i));\n\t\t}\n\t\tprintf(\"%lld\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"math.h\"\n#include \"utility\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"iomanip\"\n#include \"random\"\n\nusing namespace std;\nconst long long int MOD = 1000000007;\n\nint N;\nlist<int>P;\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin >> N;\n\tP.push_back(2);\n\tfor (int i = 3; i < pow(2, 24); i += 2) {\n\t\tbool flag = true;\n\t\tfor (auto j : P) {\n\t\t\tif (i%j == 0) {\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (j*j > i)break;\n\t\t}\n\t\tif (flag)P.push_back(i);\n\t}\n\twhile (N) {\n\t\tvector<long long int>l(N);\n\t\tvector<long long int>r(N);\n\t\tvector<int>lx(N);\n\t\tvector<int>rx(N);\n\t\tvector<long long int>lw(N);\n\t\tvector<long long int>rw(N);\n\t\tvector<bool>flag(N, true);\n\t\tstack<int>node;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tint a, b, c, d;\n\t\t\tcin >> a >> b >> c >> d;\n\t\t\tc--;\n\t\t\td--;\n\t\t\tl[i] = a;\n\t\t\tr[i] = b;\n\t\t\tlx[i] = c;\n\t\t\trx[i] = d;\n\t\t\tif (c == -1)lw[i] = 1;\n\t\t\tif (d == -1)rw[i] = 1;\n\t\t\tif (c >= 0)flag[c] = false;\n\t\t\tif (d >= 0)flag[d] = false;\n\t\t}\n\t//\tcout << \"hijiki\";\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (flag[i]) {\n\t\t\t\tnode.push(i);\n\t\t\t}\n\t\t}\n\t\twhile (!node.empty()) {\n\t\t\tint current = node.top();\n\t\t\tif (lx[current] >= 0) {\n\t\t\t\tif (lw[lx[current]] && rw[lx[current]])lw[current] = lw[lx[current]] + rw[lx[current]];\n\t\t\t\telse {\n\t\t\t\t\tnode.push(lx[current]);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rx[current] >= 0) {\n\t\t\t\tif (lw[rx[current]] && rw[rx[current]])rw[current] = lw[rx[current]] + rw[rx[current]];\n\t\t\t\telse {\n\t\t\t\t\tnode.push(rx[current]);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (l[current] * lw[current] != r[current] * rw[current]) {\n\t\t\t\tlong long int a = r[current] * rw[current];\n\t\t\t\tlong long int b = l[current] * lw[current];\n\t\t\t\tfor (auto i : P) {\n\t\t\t\t\twhile(a%i==0&&b%i==0){\n\t\t\t\t\t\ta /= i;\n\t\t\t\t\t\tb /= i;\n\t\t\t\t\t}\n\t\t\t\t\tif (min(a, b) < i)break;\n\t\t\t\t}\n\t\t\t\tlw[current] *= a;\n\t\t\t\trw[current] *= b;\n\t\t\t}\n\t\t\tnode.pop();\n\t\t}\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (flag[i]) {\n\t\t\t\tcout << lw[i] + rw[i] << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcin >> N;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nint gcd(int a,int b){\n    if(b==0)return a;\n    return gcd(b,a%b);\n    }  \n    int lcm(int a,int b){return a*b/gcd(a,b);}\nstruct bou{\n    int l,r,x,y;\n    };\n    int n[105];bou m[105];\nint mincost(int a){\n    if(n[a-1]!=-1)return n[a-1];\n    int b=1,c=1;\n    if(m[a].x)b=mincost(m[a].x/gcd(m[a].x,m[a].r));\n    if(m[a].y)c=mincost(m[a].y/gcd(m[a].y,m[a].l));\n    n[a-1]=lcm(b,c)*(m[a].l+m[a].r);\n    return lcm(b,c)*(m[a].l+m[a].r);\n    }\nsigned main(){\n   int a;\n   while(cin>>a,a){\n       memset(n,-1,sizeof(n));\n       bou g;\n       for(int b=1;b<=a;b++){\n\t   int c,d;\n\t  scanf(\"%lld%lld%lld%lld\",&c,&d,&g.x,&g.y);\n\t  g.l=c/gcd(c,d);g.r=d/gcd(c,d);\n\t  m[b]=g;\n\t   }\n\t for(int i=0;i<a;i++){\n\t     if(n[i]==-1)mincost(i+1);\n\t     }  \n\t     int MAX=0;\n\tfor(int i=0;i<a;i++){\n\t     MAX=max(MAX,n[i]);\n\t    }  \n\t    cout<<MAX<<endl;\n       }\n    }"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\nusing namespace std;\nint a[100+2],b[100+2],c[100+2],d[100+2],w[100+2],n;\n\nint s(int x){\n\tint ans;\n\tif(w[x]!=NULL)return w[x];\n\telse {\n\t\tint e=a[x]*s(c[x]),f=b[x]*s(d[x]);\n\t\tint g=e,h=f,gcd;\n\t\twhile(1){\n\t\t\tg%=h;\n\t\t\tif(g==0)break;\n\t\t\th%=g;\n\t\t\tif(h==0)break;\n\t\t}\n\t\tgcd=e*f/max(g,h);\n\t\tans=gcd/a[x]+gcd/b[x];\n\t}\n\tw[x]=ans;\n\treturn ans;\n}\n\nint main(){\n\tint ans=0;\n\tscanf(\"%d\",&n);\n\tw[0]=1;\n\tfor(int i=1;i<=n;i++)scanf(\"%d%d%d%d\",&a[i],&b[i],&c[i],&d[i]);\n\tfor(int i=1;i<=n;i++){\n\t\tif(w[i]==NULL)a[101]=s(i);\n\t\tif(ans<w[i])ans=w[i];\n\t}\n\tprintf(\"%d\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n#define REP(i,n) for(int i=1;i<=n;i++)\nstruct S {int p,q,r,b;};\nint n;\nS a[102];\nbool is_top[102];\n\nint gcd(int a,int b){\n  while(a%=b)swap(a,b);\n  return b;\n}\n\nint lcm(int a,int b){\n  return a*b/gcd(a,b);\n}\n\nint w(int i){\n  if(i==0)return 1;\n  int p=a[i].p, q=a[i].q,\n      r=a[i].r, b=a[i].b;\n  int l=lcm(w(r)*q,w(b)*p);\n  return l/q+l/p;\n}\n\nsigned main(){\n  while(cin>>n,n){\n    int p,q,r,b;\n    REP(i,n)is_top[i]=1;\n    REP(i,n){\n      cin>>p>>q>>r>>b;\n      a[i]={p,q,r,b};\n      is_top[r]=0;\n      is_top[b]=0;\n    }\n    int top=1;\n    while(!is_top[top])top++;\n    cout<<w(top)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint poles[100][4];\n\nint gcd(int a, int b)\n{\n  int tmp;\n  if(a < b)\n  {\n    tmp = a;\n    a = b;\n    b = tmp;\n  }\n  while(1)\n  {\n    tmp = b;\n    b = a % b;\n    a = tmp;\n    if(!b)\n      return a;\n  }\n}\n\nint lcm(int a, int b)\n{\n  return a * b / gcd(a, b);\n}\n\nint dfs(int n)\n{\n  int a = 1, b = 1;\n  if(poles[n][2])\n    a = dfs(poles[n][2]);\n  if(poles[n][3])\n    b = dfs(poles[n][3]);\n  int l = lcm(poles[n][0] * a, poles[n][1] * b);\n  return l / poles[n][0] + l / poles[n][1];\n}\n\n\nbool isRoot[101];\nint main()\n{\nloop:\n  fill(isRoot, isRoot + 101, true);\n  isRoot[0] = false;\n  int n;\n  cin >> n;\n  if(!n)\n    return 0;\n\n  for(int i = 1; i <= n; i++)\n  {\n    cin >> poles[i][0] >> poles[i][1] >> poles[i][2] >> poles[i][3];\n    isRoot[poles[i][2]] = isRoot[poles[i][3]] = false;\n  }\n  for(int i = 1; i <= n; i++)\n  {\n    if(isRoot[i])\n    {\n      cout << dfs(i) << endl;\n      goto loop;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <map>\n#include <sstream>\n#include <string>\n#include <cstdio>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cstring>\n#include <tuple>\n#include <utility>\n#include <list>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> Array;\ntypedef pair<int, int> P;\n\nconst int INF = 1 << 29;\nconst LL MOD = 100000;\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define all(c) (c).begin(), (c).end()\n\nstruct edge{ int to, cost; edge(int t, int c) :to(t), cost(c){} };\n\nint dxk[] = { 1, 1, 1, 0, -1, 0 };\nint dxg[] = { 0, 1, 0, -1, -1, -1 };\nint dy[] = { -1, 0, 1, 1, 0, -1 };\n\nstruct node\n{\n\tLL value, lw, rw, left, right;\n};\n\nLL gcd(LL a, LL b)\n{\n\tif (a < b) swap(a, b);\n\treturn a % b == 0 ? b : gcd(b, a % b);\n}\nLL sks(LL a, LL b)\n{\n\tLL g = gcd(a, b);\n\treturn a / g * b;\n}\n\nLL dfs(int idx, vector<node>& bars)\n{\n\tif (idx == -1) return 1LL;\n\tnode& node = bars[idx];\n\tif (node.value != 0) return node.value;\n\n\tLL r = dfs(node.right, bars), l = dfs(node.left, bars);\n\n\tint m = 1;\n\twhile ((r * node.rw * m) % (l * node.lw) != 0) m++;\n\tint lm = r * node.rw * m / (l * node.lw);\n\t//r*lの最小公倍数を基礎値としてm:nにする\n\t//LL s = sks(r * node.rw, l * node.lw);\n\t//return node.value = s / node.rw + s / node.lw;\n\treturn node.value = m * r + lm * l;\n}\n\nint main()\n{\n\tint n;\n\twhile (cin >> n && n)\n\t{\n\t\tvector<node> bars(n);\n\t\trep(i, n)\n\t\t{\n\t\t\tint p, q, r, b;\n\t\t\tcin >> p >> q >> r >> b;\n\t\t\tint g = gcd(p, q);\n\t\t\tbars[i].rw = q / g;\n\t\t\tbars[i].lw = p / g;\n\t\t\tbars[i].left = r - 1;\n\t\t\tbars[i].right = b - 1;\n\t\t}\n\n\t\tLL ans = 0;\n\t\trep(i, n) ans = max(dfs(i, bars), ans);\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nll gcd(ll a, ll b) {\n  return b != 0 ? gcd(b, a % b) : a;\n}\n\nconst ll WEIGHT=-1;\nstruct stick{\n\tll r,b,p,q;\n\tstick(ll r,ll b,ll p,ll q):r(r),b(b){\n\t\tll g=gcd(p,q);\n\t\tthis->p=p/g;\n\t\tthis->q=q/g;\n\t}\n\tll getroot(ll index,vector<stick> &sticks){\n\t\tREP(i,sticks.size()){\n\t\t\tif(sticks[i].r==index||sticks[i].b==index){\n\t\t\t\treturn sticks[i].getroot(i,sticks);\n\t\t\t}\n\t\t}\n\t\treturn index;\n\t}\n\tll go(vector<stick> &sticks){\n\t\tll rw=0,bw=0;\n\t\tif(r!=WEIGHT){\n\t\t\trw=sticks[r].go(sticks);\n\t\t}\n\t\tif(b!=WEIGHT){\n\t\t\tbw=sticks[b].go(sticks);\n\t\t}\n\t\tif(r==WEIGHT&&b==WEIGHT){\n\t\t\trw=q;\n\t\t\tbw=p;\n\t\t}else if(r==WEIGHT){\n\t\t\tif(p*bw%q){\n\t\t\t\trw=bw*p;\n\t\t\t\tbw*=q;\n\t\t\t}else{\n\t\t\t\trw=bw*p/q;\n\t\t\t\tassert(bw);\n\t\t\t}\n\t\t}else if(b==WEIGHT){\n\t\t\tif(q*rw%p){\n\t\t\t\tbw=rw*q;\n\t\t\t\trw*=p;\n\t\t\t}else{\n\t\t\t\tbw=rw*q/p;\n\t\t\t\tassert(rw);\n\t\t\t}\n\t\t}else{\n\t\t\tassert(bw);\n\t\t\tassert(rw);\n\t\t\tll trw=rw,tbw=bw;\n\t\t\tll gr=gcd(rw,q);\n\t\t\tll gb=gcd(bw,p);\n\t\t\trw=trw*tbw*q/gr;\n\t\t\tassert(tbw);\n\t\t\tassert(trw);\n\t\t\tassert(p);\n\t\t\tcerr<<tbw<<\",\"<<trw<<\",\"<<p<<\",\"<<gb<<endl;\n\t\t\tassert(gb);\n\t\t\tbw=tbw*trw*p/gb;\n\t\t\tassert(bw);\n\t\t\tassert(rw);\n\t\t}\n\t\tassert(rw&&bw);\n\t\treturn rw+bw;\n\t}\n};\n\n\nint main(){\n\tll n;\n\twhile(cin>>n,n){\n\t\tvector<stick> sticks;\n\t\tREP(i,n){\n\t\t\tll p,q,r,b;\n\t\t\tcin>>p>>q>>r>>b;\n\t\t\tr--;b--;\n\t\t\tsticks.push_back(stick(r,b,p,q));\n\t\t}\n\t\tll root=sticks[0].getroot(0,sticks);\n\t\tcout<<sticks[root].go(sticks)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define MAX_N 101\n\ntypedef struct\n{\n\tint rt_r;\n\tint rt_b;\n\tint con_r;\n\tint con_b;\n} bar;\n\nbar btemp;\nbar* makebar(const int rt_r,const int rt_b,const int con_r,const int con_b)\n{\n\tbtemp.rt_r = rt_r;\n\tbtemp.rt_b = rt_b;\n\tbtemp.con_r = con_r;\n\tbtemp.con_b = con_b;\n\treturn &btemp;\n}\n\nint gcd(int a,int b)\n{\n\tint tmp;\n\tif(a < b)\n\t{\n\t\ttmp = a;\n\t\ta = b;\n\t\tb = tmp;\n\t}\n\twhile(b != 0)\n\t{\n\t\ttmp = a % b;\n\t\ta = b;\n\t\tb = tmp;\n\t}\n\treturn a;\n}\n\nint lcm(int a,int b)\n{\n\treturn a*b / gcd(a,b);\n}\n\nint N;\nvector<bar> B;\nvector<bool> T;\nvector<int> A;\n\nvoid dfs(int _b,int _u,int _d)\n{\n\tint u = _u / gcd(_u,_d);\n\tint d = _d / gcd(_u,_d);\n\tint b = _b - 1;\n\tif(B[b].con_r != 0)\n\t{\n\t\tdfs(B[b].con_r,u * B[b].rt_b,d * (B[b].rt_b + B[b].rt_r));\n\t}\n\telse\n\t{\n\t\tA.push_back((d * (B[b].rt_b + B[b].rt_r)) / gcd((u * B[b].rt_b),(d * (B[b].rt_b + B[b].rt_r))));\n\t}\n\tif(B[b].con_b != 0)\n\t{\n\t\tdfs(B[b].con_b,u * B[b].rt_r,d * (B[b].rt_b + B[b].rt_r));\n\t}\n\telse\n\t{\n\t\tA.push_back((d * (B[b].rt_b + B[b].rt_r)) / gcd((u * B[b].rt_r),(d * (B[b].rt_b + B[b].rt_r))));\n\t}\n}\n\nint main(void)\n{\n\twhile(true)\n\t{\n\t\tcin >> N;\n\t\tA.clear();\n\t\tB.clear();\n\t\tT.clear();\n\t\tif(N == 0)\n\t\t\texit(0);\n\t\tint p,q,r,b;\n\t\tfor(int i = 0;i < N;i++)\n\t\t{\n\t\t\tcin >> p >> q >> r >> b;\n\t\t\tB.push_back(*makebar(p / gcd(p,q),q / gcd(p,q),r,b));\n\t\t\tT.push_back(true);\n\t\t}\n\t\tfor(auto itr = B.begin();itr < B.end();itr++)\n\t\t{\n\t\t\tif(itr->con_r != 0)\n\t\t\t\tT[itr->con_r-1] = false;\n\t\t\tif(itr->con_b != 0)\n\t\t\t\tT[itr->con_b-1] = false;\n\t\t}\n\t\tint top = -1;\n\t\tfor(auto itr = T.begin();itr < T.end();itr++)\n\t\t{\n\t\t\tif(*itr)\n\t\t\t\ttop = itr - T.begin();\n\t\t}\n\t\tif(top == -1)\n\t\t\texit(-1);\n\t\tdfs(top+1,1,1);\n\t\tint result = 1;\n\t\tfor(auto itr = A.begin();itr < A.end();itr++)\n\t\t{\n\t\t\tresult = lcm(result,*itr);\n\t\t}\n\t\tcout << result << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#pragma warning(disable : 4996)\nint n, lp[109], rp[109], l[109], r[109];\nint gcd(int x, int y) {\n\tif (y == 0) return x;\n\treturn gcd(y, x % y);\n}\nint solve(int pos) {\n\tif (pos == -1) return 1;\n\tint lret = solve(l[pos]) * lp[pos];\n\tint rret = solve(r[pos]) * rp[pos];\n\tint p = lret / gcd(lret, rret) * rret;\n\treturn p / lp[pos] + p / rp[pos];\n}\nint main() {\n\twhile (scanf(\"%d\", &n), n) {\n\t\tfor (int i = 0; i < n; i++) scanf(\"%d%d%d%d\", &lp[i], &rp[i], &l[i], &r[i]), l[i]--, r[i]--;\n\t\tint ret = 0;\n\t\tfor (int i = 0; i < n; i++) ret = std::max(ret, solve(i));\n\t\tprintf(\"%d\\n\", ret);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define ALL(a) (a).begin(),(a).end()\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\nconst int INF=1e9;\nint gcd(int a,int b){\n  if(b==0)return a;\n  return gcd(b,a%b);\n}\nint main(){\n  int n;\n  while(cin>>n&&n){\n    vector<int>G[110];\n    int w[110],p[110],q[110],r[110],b[110];\n    memset(w,-1,sizeof(w));\n    for(int i=1;i<=n;i++){\n      cin>>p[i]>>q[i]>>r[i]>>b[i];\n      int g=gcd(p[i],q[i]);\n      p[i]/=g;q[i]/=g;\n      if(r[i]==0&&b[i]==0){\n        w[i]=p[i]+q[i];\n      }else{\n        G[r[i]].PB(i);\n        G[b[i]].PB(i);\n      }\n    }\n    bool update=true;\n    while(update){\n      update=false;\n      for(int i=1;i<=n;i++){\n        if(w[i]!=-1)continue;\n        if((r[i]==0||w[r[i]]!=-1)&&(b[i]==0||w[b[i]]!=-1)){\n          if(r[i]==0||b[i]==0){\n            if(r[i]==0)w[i]=w[b[i]]*q[i]*2;\n            else w[i]=w[r[i]]*p[i]*2;\n          }else{\n            int g=gcd(w[r[i]]*q[i],w[b[i]]*p[i]);\n            w[i]=w[r[i]]*w[b[i]]*p[i]*q[i]/g*2;\n          }\n          update=true;\n        }\n      }\n    }\n    int ans=0;\n    for(int i=1;i<=n;i++)ans=max(w[i],ans);\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <array>\n#include <functional>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string>\n#include <vector>\n\n#define INF 1000000000\n#define MOD 1000000007\n#define ll long long\n#define rep(i,a,b) for(i = (a); i < (b); i++)\n#define bitget(a,b) (((a) >> (b)) & 1)\n#define vint vector<int>\n#define vvint vector<vector<int>>\n#define vsort(x) sort(x.begin(),x.end())\n\nusing int64 = uint64_t;\n\nusing namespace std;\ntemplate<typename T>\nT gcd(T m, T n)\n{\n\t// ?????°???0???????????´??????0?????????\n\tif ((0 == m) || (0 == n))\n\t\treturn 0;\n\n\twhile (m != n)\n\t{\n\t\tif (m > n) m = m - n;\n\t\telse         n = n - m;\n\t}\n\treturn m;\n}\nint a[101][4] = {};\nint w[101] = {};\nint64 cal(int n) {\n\tint64 ret;\n\tif (n == 0) {\n\t\treturn 1;\n\t}\n\telse if (w[n] != 0) {\n\t\treturn w[n];\n\t}\n\tint64 x, y;\n\tx = cal(a[n][2]);\n\ty = cal(a[n][3]);\n\tint64 temp = gcd(x*a[n][0], y*a[n][1]);\n\tret = x*y*a[n][1] / temp + y*x*a[n][0] / temp;\n\tw[n] = ret;\n\treturn ret;\n}\nint64 solve(int n){\n\tint64 ret;\n\tint now = 1;\n\tint64 temp;\n\twhile (now<=n) {\n\t\tif (w[now] == 0) {\n\t\t\ttemp = cal(now);\n\t\t}\n\t\telse {\n\t\t\tnow++;\n\t\t}\n\t}\n\tret = temp;\n\treturn ret;\n}\n\nint main() {\n\tint temp;\n\tint i, j, k;\n\tint n;\n\tcin >> n;\n\tlong long int ans;\n\twhile (n != 0) {\n\t\trep(i, 0, n) {\n\t\t\tcin >> a[i + 1][0] >> a[i + 1][1] >> a[i + 1][2] >> a[i + 1][3];\n\t\t\tif (temp=gcd<int>(a[i + 1][0], a[i + 1][1]) != 1) {\n\t\t\t\ta[i + 1][0] /= temp;\n\t\t\t\ta[i + 1][1] /= temp;\n\t\t\t}\n\t\t\tw[i] = 0;\n\t\t}\n\t\tw[n] = 0;\n\t\tans = solve(n);\n\t\tcout << ans << endl;\n\t\tcin >> n;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nint gcd(int a, int b){\n\tif(b == 0)return a;\n\treturn gcd(b, a%b);\n}\n\nstruct Pole{\n\tint left, right;\n\tPole *red, *blue, *rred, *rblue;\n};\n\n// 中和をとった時の重さを返す\nint trace(Pole pole){\n\tint red_w, blue_w;\n\tif(pole.red == nullptr && pole.blue == nullptr){\n\t\tred_w = pole.right;\n\t\tblue_w = pole.left;\n\t}else if(pole.red != nullptr && pole.blue != nullptr){\n\t\tred_w = trace(*pole.red);\n\t\tblue_w = trace(*pole.blue);\n\n\t\tint g = gcd(pole.left * red_w, pole.right * blue_w),\n\t\t\t_red_w = red_w;\n\t\tred_w = pole.right * blue_w / g * _red_w;\n\t\tblue_w = pole.left * _red_w / g * blue_w;\n\t}else{\n\t\tif(pole.red == nullptr){\n\t\t\tstd::swap(pole.red, pole.blue);\n\t\t\tstd::swap(pole.left, pole.right);\n\t\t}\n\n\t\tint _red_w = trace(*pole.red),\n\t\t\tg = gcd(pole.left * _red_w, pole.right);\n\t\t\t\n\t\tred_w = pole.right / g * _red_w;\n\t\tblue_w = pole.left * _red_w / g;\n\t}\n\n\treturn red_w + blue_w;\n}\n\nint main(){\n\tint n;\n\twhile(std::cin >> n, n){\n\t\tPole ps[100];\n\n\t\tfor(int i=0;i<100;i++){\n\t\t\tps[i].red = nullptr;\n\t\t\tps[i].blue = nullptr;\n\t\t\tps[i].rred = nullptr;\n\t\t\tps[i].rblue = nullptr;\n\t\t\tps[i].left = 0;\n\t\t\tps[i].right = 0;\n\t\t}\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint p, q, r, b;\n\t\t\tstd::cin >> p >> q >> r >> b;\n\t\t\tr--;b--;\n\n\t\t\tint g = gcd(p, q);\n\t\t\tps[i].left = p / g;\n\t\t\tps[i].right = q / g;\n\n\t\t\tif(r != -1){\n\t\t\t\tps[i].red = &ps[r];\n\t\t\t\tps[r].rred = &ps[i];\n\t\t\t}\n\t\t\n\t\t\tif(b != -1){\n\t\t\t\tps[i].blue = &ps[b];\n\t\t\t\tps[b].rblue = &ps[i];\n\t\t\t}\n\t\t}\n\t\n\t\tint parent = 0;\n\t\t{\n\t\t\tPole *p = &ps[0];\n\t\t\twhile(p->rred != nullptr || p->rblue != nullptr){\n\t\t\t\tif(p->rred != nullptr){//実は一意(普通)\n\t\t\t\t\tp = p->rred;\n\t\t\t\t}else{\n\t\t\t\t\tp = p->rblue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tparent = p - &ps[0];\n\t\t}\n\n\t\tstd::cout << trace(ps[parent]) << std::endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(ll i=(b) - 1;i>=(a);i--)\n#define REP(i,n) for(ll i=0;i<(n);i++)\n#define RREP(i,n) for(ll i=n-1;i>=0;i--)\n\n#define PB push_back\n#define INF (1<<29)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define CLR(a) memset(a,0,sizeof(a))\n\ntypedef long long int ll;\n\nusing namespace std;\nstruct mobile{\n    ll rc;\n    ll lc;\n    ll l;\n    ll r;\n    ll w; \n};\n\nll gcd(ll a, ll b){\n    return a%b==0 ? b : gcd(b,a%b);\n}\n\nint main(){\n    while(true){\n\tll n;\n\tcin >> n;\n\tif(n == 0) break;\n\tll ans =0 ;\n\tvector< struct mobile > v(n);\n\tREP(i,n){\n\t    ll l,r,lc,rc;\n\t    cin >> l >> r >> lc >> rc;\n\t    v[i].l = l;\n\t    v[i].r = r;\n\t    v[i].lc = lc;\n\t    v[i].rc = rc;\n\t    v[i].w = 0;\n\t}\n\tbool flg = true;\n\twhile(flg){\n\t    flg = false;\n\t    REP(i,n){\n\t\tif(v[i].w == 0 && v[i].rc == 0 && v[i].lc == 0){\n\t\t    ll r = v[i].r;\n\t\t    ll l = v[i].l;\n\t\t    v[i].r /= gcd(r,l);\n\t\t    v[i].l /= gcd(r,l);\n\t\t    v[i].w = v[i].r + v[i].l;\n\t\t    flg = true;\n\t\t}else{\n\t\t    ll lw,rw;\n\t\t    if(v[i].w > 0) continue;\n\t\t    if(v[i].lc == 0){\n\t\t\tlw = 1;\n\t\t    }else if(v[v[i].lc-1].w > 0){\n\t\t\tlw = v[v[i].lc-1].w;\n\t\t    }else continue;\n\n\t\t    if(v[i].rc == 0){\n\t\t\trw = 1;\n\t\t    }else if(v[v[i].rc-1].w > 0){\n\t\t\trw = v[v[i].rc-1].w;\n\t\t    }else continue;\n\t\t    ll r,l;\n\t\t    r = v[i].r;\n\t\t    l = v[i].l;\n\t\t    v[i].r /= gcd(r,l);\n\t\t    v[i].l /= gcd(r,l);\n\t\t    ll w = 1000000000000000;\n\t\t    FOR(j,1,1000){\n\t\t\tFOR(k,1,1000){\n\t\t\t    if(lw*j*v[i].l == rw*k*v[i].r){\n\t\t\t\tw = min ( w,lw*j + rw*k);\n\t\t\t    break;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    v[i].w = w;\n\t\t    flg = true;\n\t\t}\n\t\tans = max(ans,v[i].w);\n\t    }\n\t}\n\tcout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i = (a); i < (b); i++)\n#define REP(i,n) FOR(i,0,n)\n\nstruct Node {\n\tint a, b, ma, mb;\n\t\n\tNode() {}\n\tNode(int a, int b, int ma, int mb) : a(a), b(b), ma(ma), mb(mb) {}\n};\n\nint n;\nNode node[100];\nbool istop[100];\n\nint gcd(int a, int b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a % b);\n}\n\nint lcm(int a, int b) {\n\treturn a / gcd(a, b) * b;\n}\n\nint dfs(int pos) {\n\tNode &now = node[pos];\n\t\n\tint a = now.a, b = now.b, ma = now.ma, mb = now.mb;\n\t\n\tma = ma ? dfs(ma - 1) : 1;\n\tmb = mb ? dfs(mb - 1) : 1;\n\t\n\tint l = lcm(a * ma, b * mb);\n\treturn l / a + l / b;\n}\n\nint main() {\n\twhile (cin >> n, n) {\n\t\tfill(istop, istop + n, false);\n\t\t\n\t\tREP(i, n) {\n\t\t\tint a, b, ma, mb;\n\t\t\tscanf(\"%d %d %d %d\", &a, &b, &ma, &mb);\n\t\t\tnode[i] = Node(a, b, ma, mb);\n\t\t\t\n\t\t\tif (ma != 0) istop[ma - 1] = true;\n\t\t\tif (mb != 0) istop[mb - 1] = true;\n\t\t}\n\t\t\n\t\tint st = 0;\n\t\twhile (istop[st]) st++;\n\t\tcout << dfs(st) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long lli;\n\nconst lli N = 100LL;\n\nlli n, p[N+1], q[N+1], r[N+1], b[N+1];\nbool vis[N+1];\n\nlli lcm(lli x, lli y){\n  return x * y / __gcd(x, y);\n}\n\nlli solve(lli pos){\n  lli t1 = 1, t2 = 1;\n  if(r[pos]) t1 = solve(r[pos]);\n  if(b[pos]) t2 = solve(b[pos]);\n  lli tmp = lcm(t1 * p[pos], t2 * q[pos]);\n  return tmp / p[pos] + tmp / q[pos];\n}\n\nmain(){\n  while(cin >> n && n){\n    fill(vis, vis+N+1, false);\n    for(lli i=1;i<=n;i++){\n      cin >> p[i] >> q[i] >> r[i] >> b[i];\n      lli tmp = __gcd(p[i], q[i]);\n      p[i] /= tmp;\n      q[i] /= tmp;\n      vis[r[i]] = vis[b[i]] = true;\n    }\n    for(lli i=1;i<=n;i++) if(!vis[i]) cout << solve(i) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\n#define REP(i,a,b) for(i=a; i<b; ++i)\n#define rep(i,n) REP(i,0,n)\n\nstruct mobile {\n  int lm,rm,lc,rc,ll,rl;\n  mobile(int lc,int rc,int ll,int rl)\n  : lc(lc), rc(rc), ll(ll), rl(rl) {\n    lm = rm = -1;\n  }\n};\n\nint gcd(int a,int b) {\n  return b != 0 ? gcd(b, a%b) : a;\n}\n\nint lcm(int a,int b) {\n  return a/gcd(a,b)*b;\n}\n\nint dfs(int pos,vector<mobile> &vm) {\n  mobile now = vm[pos];\n  now.lm = (now.lc == -1) ? 1 : dfs(now.lc,vm);\n  now.rm = (now.rc == -1) ? 1 : dfs(now.rc,vm);\n  int g = lcm(now.ll*now.lm, now.rl*now.rm);\n  now.rm = g / now.rl;\n  now.lm = g / now.ll;\n  return now.rm+now.lm;\n}\n\nint main() {\n  int n,i,p,q,r,b,root;\n  while(cin>>n, n) {\n    vector<mobile> vm;\n    vector<bool> isroot(n+1,true);\n    root = -1;\n    rep(i,n) {\n      cin>>p>>q>>r>>b;\n      r--,b--;\n      if(r >= 0) isroot[r] = false;\n      if(b >= 0) isroot[b] = false;\n      vm.push_back(mobile(r,b,p,q));\n    }\n\n    rep(i,n) if(isroot[i] == true) cout<<dfs(i,vm)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define int long long\n\n#define CHOOSE(a) CHOOSE2 a\n#define CHOOSE2(a0,a1,a2,a3,x,...) x\n#define REP1(i, s, cond, cal) for (signed i = signed(s); i cond; i cal)\n#define REP2(i, s, n) REP1(i, s, < signed(n), ++)\n#define REP3(i, n) REP2(i, 0, n)\n#define rep(...) CHOOSE((__VA_ARGS__,REP1,REP2,REP3))(__VA_ARGS__)\n\nusing VV = vector<vector<int>>;\nusing V = vector<int>;\nusing P = pair<int, int>;\n\nVV g;\nvector<P> len;\n\nint dfs(int now) {\n\tint a = g[now][0] >= 0 ? dfs(g[now][0]) : 1;\n\tint b = g[now][1] >= 0 ? dfs(g[now][1]) : 1;\n\tint p, q;\n\ttie(p, q) = len[now];\n\tint gcd = __gcd(a*p, b*q);\n\tint x = b*q / gcd;\n\tint y = a*p / gcd;\n\treturn a*x + b*y;\n}\n\nsigned main() {\n\tint n;\n\twhile (cin >> n&&n) {\n\t\tg.clear();\n\t\tg.resize(n);\n\t\tlen.clear();\n\t\tlen.resize(n);\n\t\tV root(n, true);\n\t\trep(i, n) {\n\t\t\tint p, q, r, b;\n\t\t\tcin >> p >> q >> r >> b;\n\t\t\tr--; b--;\n\t\t\tint gcd = __gcd(p, q);\n\t\t\tp = p / gcd;\n\t\t\tq = q / gcd;\n\t\t\tif (~r) root[r] = false;\n\t\t\tif (~b) root[b] = false;\n\t\t\tg[i].push_back(r);\n\t\t\tg[i].push_back(b);\n\t\t\tlen[i] = P(p, q);\n\t\t}\n\t\tint idx = find(all(root), true) - root.begin();\n\t\tcout << dfs(idx) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\nlong long depth[500];\nlong long w[500][2];\nlong long x[500][2];\nlong long n, root, v[500], a, A, B, C;\npair<long long, long long>DEPTH[500];\nlong long mobile[500][2];\n\nlong long gcd(long long p, long long q) {\n\tint P = p, Q = q;\n\twhile (true) {\n\t\tif (P%Q == 0) { return Q; }\n\t\tif (Q%P == 0) { return P; }\n\t\tif (P > Q) { P = P%Q; }\n\t\telse { Q = Q%P; }\n\t}\n}\n\nint main() {\n\twhile (true) {\n\t\tmemset(depth, 0, sizeof(depth));\n\t\tmemset(w, 0, sizeof(w));\n\t\tmemset(x, 0, sizeof(x));\n\t\tmemset(v, 0, sizeof(v));\n\t\tmemset(DEPTH, 0, sizeof(DEPTH));\n\t\tmemset(mobile, 0, sizeof(mobile));\n\t\troot = 0; n = 0; A = 0; B = 0; C = 0; a = 0;\n\t\tcin >> n;\n\t\tif (n == 0) { break; }\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tv[i] = 0;\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tcin >> w[i][0] >> w[i][1] >> x[i][0] >> x[i][1];\n\t\t\tv[x[i][0]] = 1; v[x[i][1]] = 1;\n\t\t\ta = gcd(w[i][0], w[i][1]);\n\t\t\tw[i][0] /= a; w[i][1] /= a;\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (v[i] == 0) {\n\t\t\t\troot = i;\n\t\t\t}\n\t\t}\n\t\t//depth.\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tdepth[i] = 1000;\n\t\t}\n\t\tdepth[root] = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tif (depth[j] != 1000) {\n\t\t\t\t\tdepth[x[j][0]] = min(depth[x[j][0]], depth[j] + 1);\n\t\t\t\t\tdepth[x[j][1]] = min(depth[x[j][1]], depth[j] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tDEPTH[i - 1].first = depth[i];\n\t\t\tDEPTH[i - 1].second = i;\n\t\t}\n\t\tsort(DEPTH, DEPTH + n);\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tA = DEPTH[i].first;\n\t\t\tB = DEPTH[i].second;\n\t\t\tif (x[B][0] == 0 && x[B][1] == 0) {\n\t\t\t\tmobile[B][0] = w[B][1];\n\t\t\t\tmobile[B][1] = w[B][0];\n\t\t\t}\n\t\t\tif (x[B][0] == 0 && x[B][1] >= 1) {\n\t\t\t\tmobile[B][1] = mobile[x[B][1]][0] + mobile[x[B][1]][1];\n\t\t\t\tmobile[B][1] = mobile[B][1] * w[B][0] / gcd(mobile[B][1], w[B][0]);\n\t\t\t\tmobile[B][0] = mobile[B][1] * w[B][1] / w[B][0];\n\t\t\t}\n\t\t\tif (x[B][0] >= 1 && x[B][1] == 0) {\n\t\t\t\tmobile[B][0] = mobile[x[B][0]][0] + mobile[x[B][0]][1];\n\t\t\t\tmobile[B][0] = mobile[B][0] * w[B][1] / gcd(mobile[B][0], w[B][1]);\n\t\t\t\tmobile[B][1] = mobile[B][0] * w[B][0] / w[B][1];\n\t\t\t}\n\t\t\tif (x[B][0] >= 1 && x[B][1] >= 1) {\n\t\t\t\tmobile[B][0] = mobile[x[B][0]][0] + mobile[x[B][0]][1];\n\t\t\t\tmobile[B][1] = mobile[x[B][1]][0] + mobile[x[B][1]][1];\n\t\t\t\tC = mobile[B][0] * w[B][0] * mobile[B][1] * w[B][1] / gcd(mobile[B][0] * w[B][0], mobile[B][1] * w[B][1]);\n\t\t\t\tmobile[B][0] = C / w[B][0];\n\t\t\t\tmobile[B][1] = C / w[B][0];\n\t\t\t}\n\t\t}\n\t\tcout << mobile[root][0] + mobile[root][1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nstruct mobile {\n    int p;\n    int q;\n    int r;\n    int b;\n};\n\nint gcd(int a, int b) {\n    if(b==0) return a;\n    else return gcd(b,a%b);\n}\n\nint lcm(int a, int b) {\n    return (a/gcd(a,b))*b;\n}\n\nint bestmob(vector<mobile> mobs, int index) {\n    mobile mobtemp = mobs[index];\n    int g=gcd(mobtemp.p,mobtemp.q);\n    int rlen=mobtemp.p/g;\n    int blen=mobtemp.q/g;\n    int rw,bw;\n\n    rw=(mobtemp.r==-1?blen:bestmob(mobs,mobtemp.r));\n    bw=(mobtemp.b==-1?rlen:bestmob(mobs,mobtemp.b));\n\n    int l=lcm(rw*rlen,bw*blen);\n\n    return l/rlen+l/blen;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    while(n!=0) {\n        vector<mobile> mobs;\n        vector<int> deg(n,0);\n\n        for(int i=0; i<n; ++i) {\n            mobile mobtemp;\n            cin >> mobtemp.p >> mobtemp.q >> mobtemp.r >> mobtemp.b;\n            --mobtemp.r;\n            --mobtemp.b;\n            mobs.push_back(mobtemp);\n            if(mobtemp.r!=-1) ++deg[mobtemp.r];\n            if(mobtemp.b!=-1) ++deg[mobtemp.b];\n        }\n\n        int start;\n\n        for(int i=0; i<n; ++i) {\n            if(deg[i]==0) {\n                start=i;\n                break;\n            }\n        }\n\n\n        cout << bestmob(mobs,start) << endl;\n        mobs.clear();\n        cin >> n;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\ntypedef long long ll;\n\nll gcd(ll a, ll b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\n\nll n, p[100], q[100], r[100], b[100], used[100];\n\nll search(ll i) {\n  ll right = 1, left = 1;\n  if (r[i] != 0) right = search(r[i]-1);\n  if (b[i] != 0) left = search(b[i]-1);\n  ll g = gcd(p[i], q[i]);\n  ll rt = q[i] / g;\n  ll lt = p[i] / g;\n  ll r2 = (right / gcd(right, rt));\n  ll l2 = (left / gcd(left, lt));\n  ll g2 = (r2 / gcd(r2, l2)) * l2;\n  return rt * g2 + lt * g2;\n}\n\nint main() {\n  while (scanf(\"%lld\", &n), n) {\n    for (ll i = 0; i < n; i++) used[i] = 0;\n    for (ll i = 0; i < n; i++) {\n      scanf(\"%lld%lld%lld%lld\", &p[i], &q[i], &r[i], &b[i]);\n      if (r[i] != 0) used[r[i]-1] = 1;\n      if (b[i] != 0) used[b[i]-1] = 1;\n    }\n    ll ans = 0;\n    for (ll i = 0; i < n; i++) if (used[i] == 0) ans = i;\n    printf(\"%lld\\n\", search(ans));\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//Bokan ga bokka--nn!!\n//Daily Lunch Special Tanoshii !!\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\ntypedef long long ll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 2000000000\n#define f first\n#define s second\n#define rep(i,x) for(int i=0;i<x;i++)\nstruct bar\n{\n\tint le,ri;\n\tint lev,riv;\n\tbar(){}\n\tbar(int le,int ri,int lev,int riv):\n\tle(le),ri(ri),lev(lev),riv(riv){}\n}s[105];\nint rec(int cur)\n{\n\tif(!cur) return 1;\n\tint lef,rig;\n\tlef=rec(s[cur].lev);\n\trig=rec(s[cur].riv);\n\tint a=lef/__gcd(lef,s[cur].ri);\n\tint b=rig/__gcd(rig,s[cur].le);\n\tint c=a*b/__gcd(a,b);\n\treturn c*(s[cur].le+s[cur].ri);\n}\nint main()\n{\n\tsrand((unsigned int)time(NULL));\nwhile(1)\n{\n\tint n; scanf(\"%d\",&n); if(!n) return 0;\n\tbool used[105]={};\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint a,b,c,d;\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\tint v=__gcd(a,b);\n\t\ta/=v; b/=v;\n\t\ts[i]=bar(a,b,c,d);\n\t\tused[c]=used[d]=true;\n\t}\n\tint ret;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(!used[i])\n\t\t{\n\t\t\tret=rec(i);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ret);\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define rep(i,x) for(int i=0;i<x;++i)\n\nstruct node {\n    int p, q, r, b;\n};\n\nvector<node> sticks;\nint par[105];\n\nint n;\n\nint gcd(int a, int b)\n{\n    int tmp;\n    while (b != 0) {\n        tmp = b;\n        b = a % b;\n        a = tmp;\n    }\n\n    return a;\n}\n\nint lcm(int a, int b)\n{\n    return a / gcd(a, b) * b;\n}\n\nint dfs(int cur)\n{\n    node& s = sticks[cur];\n\n    if (s.r == -1 && s.b == -1) {\n        int g = gcd(s.p, s.q);\n        return s.p / g + s.q / g;\n    }\n\n    if (s.r == -1) {\n        int bch = dfs(s.b);\n        int a = lcm(s.p, bch * s.q);\n        return a / s.p + bch * (a / (bch * s.q));\n    }\n\n    if (s.b == -1) {\n        int rch = dfs(s.r);\n        int a = lcm(rch * s.p, s.q);\n        return rch * (a / (rch * s.p)) + a / s.q;\n    }\n\n    int rch = dfs(s.r), bch = dfs(s.b);\n    int a = lcm(rch * s.p, bch * s.q);\n\n    return rch * (a / (rch * s.p)) + bch * (a / (bch * s.q));\n}\n\nsigned main()\n{\n    while (cin >> n, n) {\n        sticks.resize(n);\n        memset(par, -1, sizeof(par));\n\n        rep(i, n) {\n            int p, q, r, b;\n            cin >> p >> q >> r >> b;\n            r--, b--;\n            sticks[i] = node{p, q, r, b};\n\n            if (r >= 0) par[r] = i;\n            if (b >= 0) par[b] = i;\n        }\n\n        int root;\n\n        {\n            int cur = 0;\n            do {\n                root = cur;\n                cur = par[cur];\n            } while (cur != -1);\n        }\n\n        cout << dfs(root) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <cstring>\nusing namespace std;\n\nint dp[110],K[110],O[110],L[110],R[110];\n\nint gcd(int a,int b){\n\tint tmp;\n\tif(a<b) swap(a,b);\n\twhile((tmp=a%b)!=0){\n\t\ta=b;\n\t\tb=tmp;\n\t}\n\treturn b;\n}\n\n\nint mobi(int bou){\n\tif(bou==0) return 1;\n\tif(dp[bou]!=0) return dp[bou];\n\tint l,r,li,ri,gc2,a,b;\n\tl=mobi(L[bou]);\n\tr=mobi(R[bou]);\n\tli=K[bou];ri=O[bou];\n\tgc2=gcd(li*l,ri*r);\n\tb=(li*l)/gc2;\n\ta=(ri*r)/gc2;\n\tdp[bou]=(a*l+b*r);\n\treturn dp[bou];\n}\n\nint main(){\n\tint N,k,o,g;\n\tint res;\n\twhile(1){\n\t\tcin>>N;\n\t\tif(N==0) break;\n\t\tmemset(dp,0,sizeof(dp));\n\t\tK[0]=O[0]=L[0]=R[0]=0;\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tcin>>k>>o>>L[i]>>R[i];\n\t\t\tg=gcd(k,o);\n\t\t\tK[i]=k/g;\n\t\t\tO[i]=o/g;\n\t\t}\n\t\tres=0;\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tres=max(res,mobi(i));\n\t\t}\n\t\t/*\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tcout<<i<<\" \"<<dp[i]<<endl;//\n\t\t}\n\t\t*/\n\t\tcout<<res<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n\nint gcd(int a_, int b_)\n{\n\tif (b_ == 0)return a_;\n\treturn gcd(b_, a_% b_);\n}\n\nconst int MAX_N = 100;\nint memo[MAX_N + 1];\nint p[MAX_N + 1], q[MAX_N + 1];\nint r[MAX_N + 1], b[MAX_N + 1];\nint n;\nint dp(int x_)\n{\n\tif (memo[x_] > 0)return memo[x_];\n\tdp(r[x_]); dp(b[x_]);\n\tint a_ = memo[r[x_]]; int b_ = memo[b[x_]];\n\tint c_ = p[x_] / gcd(p[x_], q[x_]);\n\tint d_ = q[x_] / gcd(p[x_], q[x_]);\n\treturn memo[x_] = a_ * b_ * (c_ + d_) / gcd(a_*c_, b_*d_);\n}\n\nint main()\n{\n\tfor (;;)\n\t{\n\t\tscanf(\"%d\",&n);\n\t\tif (n == 0)break;\n\t\tfor (int i = 1; i <= n; ++i)scanf(\"%d %d %d %d\",p + i,q + i,r + i,b + i);\n\t\tmemset(memo, 0, sizeof(memo));\n\t\tmemo[0] = 1;\n\t\tint ans = 0;\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t{\n\t\t\tans = std::max(dp(i),ans);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint n;\nint a[100][2],p[100][2];\nbool cal[100];\nint GCD(int x,int y){\n\twhile(true){\n\t\tif(x<2||!y)break;\n\t\tif(y>x){int t=x;x=y,y=t;}\n\t\tx%=y;\n\t}\n\tif(!y)y=1;\n\treturn y;\n}\nint DFS(int x){\n\tif(!x)return 1;\n\tcout<<x<<endl;\n\tx--;\n\tint b=DFS(p[x][0]),c=DFS(p[x][1]);\n\tint s=b*a[x][0]*c*a[x][1]/GCD(b*a[x][1],c*a[x][0]);\n\treturn s/a[x][0]+s/a[x][1];\n}\nint main(){\n\twhile(true){\n\tcin>>n;\n\tif(!n)break;\n\tfor(int i=0;i<n;i++)cal[i]=true;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>a[i][0]>>a[i][1];\n\t\tint t=GCD(a[i][0],a[i][1]);\n\t\ta[i][0]/=t,a[i][1]/=t;\n\t\tcin>>p[i][0]>>p[i][1];\n\t\tcal[p[i][0]-1]=false,cal[p[i][1]-1]=false;\n\t}\n\tfor(int i=0;i<n;i++)if(cal[i])cout<<DFS(i+1)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint a[100+2],b[100+2],c[100+2],d[100+2],w[100+2],n;\n\nint s(int x){\n\tint ans;\n\tif(w[x]!=-1)return w[x];\n\telse {\n\t\tint e=a[x]*s(c[x]),f=b[x]*s(d[x]);\n\t\tint g=e,h=f,gcd;\n\t\twhile(1){\n\t\t\tg%=h;\n\t\t\tif(g==0)break;\n\t\t\th%=g;\n\t\t\tif(h==0)break;\n\t\t}\n\t\tgcd=e*f/max(g,h);\n\t\tans=gcd/a[x]+gcd/b[x];\n\t}\n\tw[x]=ans;\n\treturn ans;\n}\n\nint main(){\nwhile(1){\n\tint an=0,aaa;\n\tscanf(\"%d\",&n);\nif(n==0)break;\n\tw[0]=1;\n\tfor(int i=1;i<=n;i++){scanf(\"%d%d%d%d\",&a[i],&b[i],&c[i],&d[i]); w[i]=-1;}\n\tfor(int i=1;i<=n;i++){\n\t\tif(w[i]==-1)aaa=s(i);\n\t\tif(an<w[i])an=w[i];\n\t}\n\tprintf(\"%d\\n\",an);\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define MP make_pair\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef pair<int, int> P;\n\nint gcd(int n, int m){\n\treturn m==0?n:gcd(m, n%m);\n}\n\nint lcm(int n, int m){\n\tint g = gcd(n, m);\n\treturn n/g*m;\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n, n){\n\t\tvector<vi> v(n+1);\n\t\tvector<P> k(n+1);\n\t\tvi w(n+1), cnt(n+1);\n\t\tw[0] = cnt[0] = 1;\n\t\tvi red(n+1), blue(n+1);\n\t\trep(i, n){\n\t\t\tint p, q, r, s;\n\t\t\tcin >> p >> q >> r >> s;\n\t\t\tint g = gcd(p, q);\n\t\t\tk[i+1] = MP(p/g, q/g);\n\t\t\tred[i+1] = r;\n\t\t\tblue[i+1] = s;\n\t\t\tv[r].push_back(i+1);\n\t\t\tv[s].push_back(i+1);\n\t\t\tcnt[i+1] += !!r+!!s;\n\t\t}\n\t\tqueue<int> q;\n\t\tfor(int i = 1; i <= n; i++) if(!cnt[i]) q.push(i);\n\t\tint last = -1;\n\t\twhile(!q.empty()){\n\t\t\tint m = q.front();\n\t\t\tq.pop();\n\t\t\tlast = m;\n\n\t\t\tint l = lcm(k[m].first*w[red[m]], k[m].second*w[blue[m]]);\n\t\t\tw[m] = l/k[m].first + l/k[m].second;\n\n\t\t\trep(i, v[m].size()){\n\t\t\t\tcnt[v[m][i]]--;\n\t\t\t\tif(!cnt[v[m][i]]) q.push(v[m][i]);\n\t\t\t}\n\t\t}\n\t\tcout << w[last] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 100000005\n#define MAX 5001\nusing namespace std;\n//__gcd(a,b), __builtin_popcount(a);\n\nll lcm(ll n, ll m){\n\tif(!n || !m)return 0;\n\treturn n/__gcd(n, m)*m;\n}\nll a[101][4];\n\nll solve(ll k){\n\tll l = -1, r = -1, ans = 0, t1 = 0;\n\tll x = a[k][0], y = a[k][1];\n\tif(a[k][2] != 0)l = solve(a[k][2]);\n\tif(a[k][3] != 0)r = solve(a[k][3]);\n\tif(l == -1 && r == -1)ans = (lcm(x, y)*(x+y))/(x*y);\n\telse if(l != -1 && r != -1){\n\t\tt1 = lcm(x*l, y*r);\n\t\tans = t1/x+t1/y;\n\t}else{\n\t\tif(l == -1){\n\t\t\tr *= x/__gcd(x, r*y);\n\t\t\tl = (r*y)/x;\n\t\t}\n\t\tif(r == -1){\n\t\t\tl *= y/__gcd(y, l*x);\n\t\t\tr = (l*x)/y;\n\t\t}\n\t\tans = l+r;\n\t}\n\t//cout << k << \" \" << ans << endl;\n\treturn ans;\n}\n\nint used[101];\nint main(){\n\tint n;\n\tll st;\n\twhile(cin >> n, n){\n\t\tfill(used, used+101, 0);\n\t\tfor(int i = 1;i <= n;i++){\n\t\t\tfor(int j = 0;j < 4;j++){\n\t\t\t\tscanf(\"%d\", &a[i][j]);\n\t\t\t\tif(2<=j)used[a[i][j]] = 1;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 1;i <= n;i++)if(!used[i])st = i;\n\t\tint ans = solve(st);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n\ntemplate <class T>\nint __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\nint gcd(int a, int b)\n{\n\tif (a < b)\n\t\tswap(a, b);\n\tif (b == 0)\n\t\treturn a;\n\treturn gcd(b, a%b);\n}\nint lcm(int a, int b)\n{\n\treturn a/gcd(a, b) * b;\n}\nint p[101], q[101], r[101], b[101];\nint dfs(int s)\n{\n\tif (s == 0)\n\t\treturn 1;\n\n\tint red = dfs(r[s]), blue = dfs(b[s]);\n\tint t = lcm(red*q[s], blue*p[s]);\n\treturn t/p[s] + t/q[s];\n}\nint main()\n{\n\tint n;\n\twhile (~scanf(\"%d\", &n) && n)\n\t{\n\t\tbool root[101];\n\t\tfill(root, root+101, true);\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t{\n\t\t\tscanf(\"%d%d%d%d\", p+i, q+i, r+i, b+i);\n\t\t\tll g = gcd(p[i], q[i]);\n\t\t\tp[i] /= g, q[i] /= g;\n\t\t\troot[r[i]] = root[b[i]] = false;\n\t\t}\n\n\t\tint res = 0;\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t\tif (root[i])\n\t\t\t\tres = dfs(i);\n\t\tprintf(\"%d\\n\", res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#define max(a,b) (a>b?a:b)\nint a[101],b[101],c[101],d[101],memo[101],res=0;\n\nint gcd(int x,int y){\n\tif(x==0)return y;\n\telse return gcd(y%x,x);\n}\nint solve(int x){\n\tif(memo[x]!=0)return memo[x];\n\tint left=a[x]*solve(c[x]),right=b[x]*solve(d[x]),gc;\n\tgc=gcd(left,right);\n\treturn memo[x]=right/gc*solve(c[x])+left/gc*solve(d[x]);\n}\n\nint main(){\n\tint n;\n\tmemo[0]=1;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d%d%d%d\",a+i,b+i,c+i,d+i);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tres=max(res,solve(i));\n\t}\n\tprintf(\"%d\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nll gcd(ll x, ll y)\n{    return y ? gcd(y, x % y) : x;\t}\n\nll lcm(ll x, ll y)\n{\treturn x * y / gcd(x, y);\t}\n\nclass Q\n{\npublic:\n\tll d, n;\n\t\n\tQ() : d(0), n(0) { }\n\tQ(int d, int n) : d(d), n(n) { }\n\t\n\tQ operator + (Q x)\n\t{\n\t\tif(d == 0 || n == 0) return x;\n\t\tif(x.d == 0 || x.n == 0) return *this;\n\t\treturn Q(d * x.n + n * x.d, n * x.n).reduce();\n\t}\n\t\n\tQ operator - (Q x)\n\t{\n\t\tif(d == 0 || n == 0) return x;\n\t\tif(x.d == 0 || x.n == 0) return *this;\n\t\treturn Q(d * x.n - n * x.d, n * x.n).reduce();\n\t}\n\n\tQ operator * (int x)\n\t{\treturn Q(d * x, n).reduce();\t}\n\t\n\tQ operator / (int x)\n\t{\treturn Q(d, n * x).reduce();\t}\n\t\n\tQ operator += (Q x)\n\t{\treturn (*this) = (*this) + x;\t}\n\t\n\tQ operator -= (Q x)\n\t{\treturn (*this) = (*this) - x;\t}\n\t\n\tQ reduce()\n\t{\n\t\tif(d == 0 || n == 0) return Q(0, 0);\n\t\t\n\t\tll gd = gcd(d, n);\n\t\t\n\t\treturn Q(d / gd, n / gd);\n\t}\n\t\n\tQ reciprocal()\n\t{\treturn Q(n, d);\t}\n};\n\nvector<Q> ans;\nstruct Mobile\n{\n\tint p, q, r, b;\n\t\n\tvoid divid(vector<Mobile>& mobiles, Q x)\n\t{\n\t\tQ rw = x * p / (p + q), bw = x * q / (p + q);\n\t\t\n\t\tif(r == 0)\tans.push_back(rw);\n\t\telse\t\tmobiles[r - 1].divid(mobiles, rw);\n\t\t\n\t\tif(b == 0)\tans.push_back(bw);\n\t\telse\t\tmobiles[b - 1].divid(mobiles, bw);\n\t}\n};\n\nint main()\n{\n    int n;\n\twhile( cin >> n && n )\n\t{\n\t\tvector<Mobile> mobiles(n);\n\t\tvector<bool> flags(n, false);\n\n\t\trep(i, n)\n\t\t{\n\t\t\tcin >> mobiles[i].p >> mobiles[i].q >> mobiles[i].r >> mobiles[i].b;\n\t\t\t\n\t\t\tif(mobiles[i].r != 0) flags[mobiles[i].r - 1] = true;\n\t\t\tif(mobiles[i].b != 0) flags[mobiles[i].b - 1] = true;\n\t\t}\n\t\t\n\t\tans.clear();\n\t\tmobiles[min_element(ALL(flags)) - flags.begin()].divid(mobiles, Q(1, 1));\n\t\t\n\t\tll lm = ans[0].n, res = 0;\n\t\t\n\t\tREP(i, 1, ans.size()) lm = lcm(lm, ans[i].n);\n\t\t\n\t\trep(i, ans.size()) res += (ans[i] * lm).d;\n\t\t\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <map>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define REP(type,i,n) for(type i=0;i<(n);++i)\n#define MP(a,b) make_pair((a),(b))\n\ntypedef long long int lli;\ntypedef pair<int,int> P;\n\nconst int INF=100000000;\nconst long long int INF_=1000000000000000000;\n\nlli Gcd(lli a,lli b){\n\tif(b==0) return a;\n\treturn Gcd(b,a%b);\n}\n\nlli Lcm(lli a,lli b){\n\treturn a/Gcd(a,b)*b;\n}\n\nint N;\n\nclass Bar{\n\tpublic:\n\tint p,q,r,b,parent;\n\tbool exists,is_leaf;\n\tBar():parent(-1),exists(false),is_leaf(false){}\n\tvoid Init(int a,int b,int c,int d,bool e);\n};\n\nvoid Bar::Init(int a,int bb,int c,int d,bool e){\n\tp=a; q=bb; r=c; b=d; exists=e;\n\t//cout << r << ' ' << b << endl;\n}\n\nint Find(vector<Bar> &m,int n){\n\t//cout << n << endl;\n\tif(m[n].parent==-1) return n;\n\treturn Find(m,m[n].parent);\n}\n\nvoid Pre(vector<Bar> &m,int n){\n\t//cout << n << ' ' << d << endl;\n\tif(m[n].r==-1&&m[n].b==-1){\n\t\tm[n].is_leaf=true;\n\t\treturn;\n\t}\n\tif(m[n].r!=-1) Pre(m,m[n].r);\n\tif(m[n].b!=-1) Pre(m,m[n].b);\n}\n\nlli DFS(const vector<Bar> &m,int n){\n\tif(m[n].is_leaf){\n\t\t//if(n+1==2) cout << n+1 << ' ' << m[n].p << ' ' << m[n].q << ' ' << Lcm(m[n].p,m[n].q)/m[n].p+Lcm(m[n].p,m[n].q)/m[n].q << endl;\n\t\t//else cout << n+1 << ' ' << Lcm(m[n].p,m[n].q)/m[n].p+Lcm(m[n].p,m[n].q)/m[n].q << endl;\n\t\treturn Lcm(m[n].p,m[n].q)/m[n].p+Lcm(m[n].p,m[n].q)/m[n].q;\n\t}\n\tlli a,b;\n\tif(m[n].r==-1) a=Lcm(m[n].p,m[n].q)/m[n].p;\n\telse a=DFS(m,m[n].r);\n\tif(m[n].b==-1) b=Lcm(m[n].p,m[n].q)/m[n].q;\n\telse b=DFS(m,m[n].b);\n\t//cout << n+1 << ' ' << a*Lcm(a*m[n].p,b*m[n].q)/m[n].p+b*Lcm(a*m[n].p,b*m[n].q)/m[n].q << endl;\n\treturn a*Lcm(a*m[n].p,b*m[n].q)/(m[n].p*a)+b*Lcm(a*m[n].p,b*m[n].q)/(m[n].q*b);\n}\n\nint main(){\n\twhile(cin >> N&&N){\n\t\tvector<Bar> mobile(100);\n\t\tREP(int,i,N){\n\t\t\tint p,q,r,b;\n\t\t\tcin >> p >> q >> r >> b;//p:q,左の棒の番号、右の棒の番号\n\t\t\t--r;\n\t\t\t--b;\n\t\t\tmobile[i].Init(p,q,r,b,true);\n\t\t\tif(r!=-1) mobile[r].parent=i;\n\t\t\tif(b!=-1) mobile[b].parent=i;\n\t\t}\n\t\tint parent=-1;\n\t\tREP(int,i,100){\n\t\t\tif(mobile[i].exists){\n\t\t\t\tparent=Find(mobile,i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tPre(mobile,parent);\n\t\tlli ans=DFS(mobile,parent);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(ll i=(b) - 1;i>=(a);i--)\n#define REP(i,n) for(ll i=0;i<(n);i++)\n#define RREP(i,n) for(ll i=n-1;i>=0;i--)\n\n#define PB push_back\n#define INF (1<<29)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define CLR(a) memset(a,0,sizeof(a))\n\ntypedef long long int ll;\n\nusing namespace std;\nstruct mobile{\n    ll rc;\n    ll lc;\n    ll l;\n    ll r;\n    ll w; \n};\n\nll gcd(ll a, ll b){\n    return a%b==0 ? b : gcd(b,a%b);\n}\n\nint main(){\n    while(true){\n\tll n;\n\tcin >> n;\n\tif(n == 0) break;\n\tll ans =0 ;\n\tvector< struct mobile > v(n);\n\tREP(i,n){\n\t    ll l,r,lc,rc;\n\t    cin >> l >> r >> lc >> rc;\n\t    v[i].l = l;\n\t    v[i].r = r;\n\t    v[i].lc = lc;\n\t    v[i].rc = rc;\n\t    v[i].w = 0;\n\t}\n\tbool flg = true;\n\twhile(flg){\n\t    flg = false;\n\t    REP(i,n){\n\t\tif(v[i].w == 0 && v[i].rc == 0 && v[i].lc == 0){\n\t\t    ll r = v[i].r;\n\t\t    ll l = v[i].l;\n\t\t    v[i].r /= gcd(r,l);\n\t\t    v[i].l /= gcd(r,l);\n\t\t    v[i].w = v[i].r + v[i].l;\n\t\t    flg = true;\n\t\t}else{\n\t\t    ll lw,rw;\n\t\t    if(v[i].w > 0) continue;\n\t\t    if(v[i].lc == 0){\n\t\t\tlw = 1;\n\t\t    }else if(v[v[i].lc-1].w > 0){\n\t\t\tlw = v[v[i].lc-1].w;\n\t\t    }else continue;\n\n\t\t    if(v[i].rc == 0){\n\t\t\trw = 1;\n\t\t    }else if(v[v[i].rc-1].w > 0){\n\t\t\trw = v[v[i].rc-1].w;\n\t\t    }else continue;\n\t\t    ll r,l;\n\t\t    r = v[i].r;\n\t\t    l = v[i].l;\n\t\t    v[i].r /= gcd(r,l);\n\t\t    v[i].l /= gcd(r,l);\n\t\t    ll w = 1000000000000000;\n\t\t    \n\t\t    FOR(j,1,10000){\n\t\t\tif((lw*v[i].l*j) % v[i].r == 0){\n\t\t\t    if(((lw*v[i].l*j)/v[i].r ) % rw == 0){\n\t\t\t\tw =  lw*j + (lw*v[i].l*j)/v[i].r;\n\t\t\t\t/*\n\t\t\t\tprintf(\"l = %d r = %d\\n\",v[i].l,v[i].r);\n\t\t\t\tprintf(\"lw = %d rw = %d\\n\",lw*j,(lw*v[i].l*j)/v[i].r);\n\t\t\t\tprintf(\"w = %d j = %d\\n\",w,j);\n\t\t\t\t*/\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    v[i].w = w;\n\t\t    flg = true;\n\t\t}\n\t\tans = max(ans,v[i].w);\n\t    }\n\t}\n\tcout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <cmath>\n#include <map>\n#include <set>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n\n#define INF_LL 1e18\n#define INF 1e9\n\n#define REP(i, n) for(int i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n\n#define fst first\n#define snd second\n\nusing namespace std;\n\nusing ll = long long;\nusing PII = pair<int, int>;\n\nstruct stick{\n\tint l_d, r_d;\n\tint par, l, r;\n};\n\nstick s[101];\n\nint gcd(int x, int y){\n\tif(y == 0) return x;\n\treturn gcd(y, x%y);\n}\n\nint dfs(int st){\n\tif(st == 0) return 1;\n\tint l_w = dfs(s[st].l);\n\tint r_w = dfs(s[st].r);\n\t//int res = l_w*r_w*(s[st].l_d+s[st].r_d)/gcd(l_w, s[st].l_d)/gcd(r_w, s[st].r_d);\n\tint res = 0;\n\tint cnt = 1;\n\twhile(s[st].l_d*cnt%l_w != 0  || s[st].r_d*cnt%r_w != 0)\n\t\tcnt++;\n\treturn s[st].l_d*cnt+s[st].r_d*cnt;\n}\n\nint main(void){\n\tint n;\n\n\twhile(cin >> n && n){\n\t\tmemset(s, 0, sizeof s);\n\t\tFOR(i, 1, n+1){\n\t\t\ts[i].par = i;\n\t\t}\n\t\tFOR(i, 1, n+1){\n\t\t\tint a;\n\t\t\tcin >> s[i].l_d >> s[i].r_d >> s[i].l >> s[i].r;\n\t\t\ta = gcd(s[i].l_d, s[i].r_d);\n\t\t\ts[i].l_d /= a;\n\t\t\ts[i].r_d /= a;\n\t\t\ts[s[i].l].par = i;\n\t\t\ts[s[i].r].par = i;\n\t\t}\n\t\tint start = 1;\n\t\twhile(s[start].par != start){\n\t\t\tstart = s[start].par;\n\t\t}\n\t\tcout << dfs(start) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nll gcd(ll x, ll y)\n{    return y ? gcd(y, x % y) : x;\t}\n\nll lcm(ll x, ll y)\n{\treturn x * y / gcd(x, y);\t}\n\nclass Q\n{\npublic:\n\tll d, n;\n\t\n\tQ() : d(0), n(0) { }\n\tQ(int d, int n) : d(d), n(n) { }\n\t\n\tQ operator + (Q x)\n\t{\n\t\tif(d == 0 || n == 0) return x;\n\t\tif(x.d == 0 || x.n == 0) return *this;\n\t\treturn Q(d * x.n + n * x.d, n * x.n).reduce();\n\t}\n\t\n\tQ operator - (Q x)\n\t{\n\t\tif(d == 0 || n == 0) return x;\n\t\tif(x.d == 0 || x.n == 0) return *this;\n\t\treturn Q(d * x.n - n * x.d, n * x.n).reduce();\n\t}\n\n\tQ operator * (int x)\n\t{\treturn Q(d * x, n).reduce();\t}\n\t\n\tQ operator / (int x)\n\t{\treturn Q(d, n * x).reduce();\t}\n\t\n\tQ operator += (Q x)\n\t{\treturn (*this) = (*this) + x;\t}\n\t\n\tQ operator -= (Q x)\n\t{\treturn (*this) = (*this) - x;\t}\n\t\n\tQ reduce()\n\t{\n\t\tif(d == 0 || n == 0) return Q(0, 0);\n\t\t\n\t\tll gd = gcd(d, n);\n\t\t\n\t\treturn Q(d / gd, n / gd);\n\t}\n\t\n\tQ reciprocal()\n\t{\treturn Q(n, d);\t}\n};\n\nint lm = 0;\nstruct Mobile\n{\n\tint p, q, r, b;\n\t\n\tQ divid(vector<Mobile>& mobiles, Q x)\n\t{\n\t\tQ rw = x * p / (p + q), bw = x * q / (p + q);\n\t\tQ res;\n\t\t\n\t\tif(r == 0)\tres += rw, lm = (lm ? lcm(lm, rw.n) : rw.n);\n\t\telse\t\tres += mobiles[r - 1].divid(mobiles, rw);\n\t\t\n\t\tif(b == 0)\tres += bw, lm = (lm ? lcm(lm, bw.n) : bw.n);\n\t\telse\t\tres += mobiles[b - 1].divid(mobiles, bw);\n\t\t\n\t\tcout << res.d << \" \" << res.n << endl;\n\t\treturn res;\n\t}\n};\n\nint main()\n{\n    int n;\n\twhile( cin >> n && n )\n\t{\n\t\tvector<Mobile> mobiles(n);\n\t\tvector<bool> flags(n, false);\n\n\t\trep(i, n)\n\t\t{\n\t\t\tcin >> mobiles[i].p >> mobiles[i].q >> mobiles[i].r >> mobiles[i].b;\n\t\t\t\n\t\t\tif(mobiles[i].r != 0) flags[mobiles[i].r - 1] = true;\n\t\t\tif(mobiles[i].b != 0) flags[mobiles[i].b - 1] = true;\n\t\t}\n\t\t\n\t\tQ res = mobiles[min_element(ALL(flags)) - flags.begin()].divid(mobiles, Q(1, 1));\n\t\t\n\t\tcout << (res * lm).d << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint gcd(int a, int b) {\n\treturn b ? gcd(b, a % b) : a;\n}\n\nint n;\nint p[100];\nint q[100];\nint r[100];\nint b[100];\nint used[100];\nint res[100];\n\nvoid dfs(int v) {\n\tif (used[v]) {\n\t\treturn;\n\t}\n\tused[v] = 1;\n\tif (r[v] != -1) {\n\t\tdfs(r[v]);\n\t}\n\tif (b[v] != -1) {\n\t\tdfs(b[v]);\n\t}\n\tint al = r[v] != -1 ? res[r[v]] : 1;\n\tint ar = b[v] != -1 ? res[b[v]] : 1;\n\tal /= gcd(q[v], al);\n\tar /= gcd(p[v], ar);\n\tint lcm = ar / gcd(ar, al) * al;\n\tres[v] = lcm * (p[v] + q[v]);\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false);\n\twhile (cin >> n, n) {\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> p[i] >> q[i] >> r[i] >> b[i];\n\t\t\tint g = gcd(p[i], q[i]);\n\t\t\tp[i] /= g;\n\t\t\tq[i] /= g;\n\t\t\tr[i]--; b[i]--;\n\t\t}\n\t\tfill(used, used + n, 0);\n\t\tfill(res, res + n, 0);\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdfs(i);\n\t\t\tans = max(ans, res[i]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 101\nusing namespace std;\nint n,p[N],q[N],r[N],b[N];\nbool s[N];\n\nint func(int x){\n  int R=1,B=1;\n  if(r[x]<b[x]) swap(r[x],b[x]);\n  if(r[x]) R=func(r[x]);\n  if(b[x]) B=func(b[x]);\n  int k=__gcd(R*p[x],B*q[x]);\n  int a=(R*p[x])/k,b=(B*q[x])/k;\n  return (R*b)+(B*a);\n}\n\nint main(){\n  while(cin>>n,n){\n    memset(s,0,sizeof(s));\n    for(int i=1;i<=n;i++){\n      cin>>p[i]>>q[i]>>r[i]>>b[i];\n      int res=__gcd(p[i],q[i]);\n      p[i]/=res,q[i]/=res;\n      s[r[i]]=s[b[i]]=true;\n    }\n    for(int i=1;i<=n;i++)\n      if(!s[i])cout<<func(i)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint GCD(int a,int b){\n    if(b>a)swap(a,b);\n    return (b==0)?a:GCD(b,a%b);\n}\nint LCM(int a,int b){\n    return a*b/GCD(a,b);\n}\nint l[101],r[101],w1[101],w2[101];\nint dfs(int x){\n    if(x==0)return 1;\n    int red=l[x]*dfs(w1[x]);\n    int blue=r[x]*dfs(w2[x]);\n    int lcm=LCM(red,blue);\n    return lcm/l[x]+lcm/r[x];\n}\nint main(){\n    int n;\n    while(scanf(\"%d\",&n),n){\n        bool flag[101];fill(flag,flag+n+1,true);\n        for(int i=1;i<=n;i++){\n            scanf(\"%d%d%d%d\",&l[i],&r[i],&w1[i],&w2[i]);\n            flag[w1[i]]=flag[w2[i]]=false;\n        }\n        for(int i=1;i<=n;i++){\n            if(flag[i]){\n                printf(\"%d\\n\",dfs(i));\n                break;\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\n#define mp make_pair\n\ntemplate<class T> void pv(T a, T b) { for (T i = a; i != b; ++i) cout << *i << \" \"; cout << endl; }\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\nstruct Stick{\n\tint p,q,r,b;\n};\n\nvector<Stick> sticks;\nvector<int> weight;\n\nint gcd(int a,int b){\n\tif(a>b)return gcd(b,a); \n\telse if(a==0)return b;\n\telse return gcd(b%a,a);\n}\n\nint main() {\n\tint n;\n\twhile(n=in()){\n\t\tsticks.clear();\n\t\tweight.clear();\n\t\tint i;\n\t\tStick buf;\n\t\tfor(i=0;i<n;i++){\n\t\t\tcin>>buf.p>>buf.q>>buf.r>>buf.b;\n\t\t\tbuf.r--;buf.b--;\n\t\t\tsticks.push_back(buf);\n\t\t\tweight.push_back(0);\n\t\t}\n//for(i=0;i<n;i++)cout<<i<<\" \"<<sticks[i].p<<\" \"<<sticks[i].q<<\" \"<<sticks[i].r<<\" \"<<sticks[i].b<<endl;\n\t\tbool update=true;\n\t\twhile(update){\n\t\t\tupdate=false;\n\t\t\tfor(i=0;i<n;i++){\n\t\t\t\tif(weight[i]>0)continue;\n\t\t\t\tif(sticks[i].r==-1&&sticks[i].b==-1){\n\t\t\t\t\tweight[i]=(sticks[i].p+sticks[i].q)/gcd(sticks[i].p,sticks[i].q);\n\t\t\t\t\tupdate=true;\n\t\t\t\t}else if(sticks[i].r==-1&&weight[sticks[i].b]>0){\n\t\t\t\t\tint r,b;\n\t\t\t\t\tb=weight[sticks[i].b]*sticks[i].p;\n\t\t\t\t\tr=b*sticks[i].q/sticks[i].p;\n\t\t\t\t\tweight[i]=(b+r)/gcd(r,sticks[i].p);\n\t\t\t\t\tupdate=true;\n\t\t\t\t}else if(sticks[i].b==-1&&weight[sticks[i].r]>0){\n\t\t\t\t\tint r,b;\n\t\t\t\t\tr=weight[sticks[i].r]*sticks[i].q;\n\t\t\t\t\tb=r*sticks[i].p/sticks[i].q;\n\t\t\t\t\tweight[i]=(b+r)/gcd(b,sticks[i].q);\n\t\t\t\t\tupdate=true;\n\t\t\t\t}else if(weight[sticks[i].r]>0&&weight[sticks[i].b]>0){\n\t\t\t\t\tint r,b;\n\t\t\t\t\tb=weight[sticks[i].b]*weight[sticks[i].r]*sticks[i].p;\n\t\t\t\t\tr=b*sticks[i].q/sticks[i].p;\n\t\t\t\t\tweight[i]=(b+r)/gcd(weight[sticks[i].b]*sticks[i].q,weight[sticks[i].r]*sticks[i].p);\n\t\t\t\t\tupdate=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//for(i=0;i<n;i++)cout<<i<<\" \"<<weight[i]<<endl;\n\t\tint res=0;\n\t\tfor(i=0;i<n;i++){\n\t\t\tchmax(res,weight[i]);\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint n;\nint p[111];\nint q[111];\nint r[111];\nint b[111];\nint m[111];\n\nint GCD(int x,int y){\n  if(x < y) x^=y^=x^=y;\n  int r = x % y;\n  if(r) return GCD(y,r);\n  else return y;\n}\n\nint solve(int k){\n  if(k == 0) return 1;\n  int rm = solve(r[k]) * p[k];\n  int bm = solve(b[k]) * q[k];\n  int l = rm * bm / GCD(rm,bm);\n  //cout << \"k = \" << k << \" : \" << l/p[k] << \" + \" << l/q[k] << endl;\n  return m[k] = l/p[k] + l/q[k];\n}\n\nint main(void){\n  while(cin >> n && n){\n    memset(p,0,sizeof(p));\n    memset(q,0,sizeof(q));\n    memset(r,0,sizeof(r));\n    memset(b,0,sizeof(b));\n    memset(m,0,sizeof(m));\n    for(int i = 1; i <= n; i++){\n      cin >> p[i] >> q[i] >> r[i] >> b[i];\n      int g = GCD(p[i],q[i]);\n      p[i] /= g;\n      q[i] /= g;\n    }\n    int res = 0;\n    for(int i = 1; i <= n; i++){\n      res = max(res,solve(i));\n    }\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX_N 100\n \nvector<int> p, q, r, b;\n\nbool dfs(int v, int val)\n{\n    int l = p[v] + q[v];\n    if (val % l != 0) {\n        return 0;\n    }\n    bool can = 1;\n    if (r[v] >= 0) {\n        can &= dfs(r[v], val/l*q[v]); \n    } \n        \n    if (b[v] >= 0) {\n        can &= dfs(b[v], val/l*p[v]); \n    }       \n    return can;\n}\n \nvoid init(int N)\n{\n    p.resize(N); q.resize(N);\n    r.resize(N); b.resize(N);\n}\n\nint main()\n{\n    int N;\n    while (cin >> N, N) {\n        init(N);\n        int mx = 0;\n        bool used[MAX_N] = {};\n        for (int i = 0; i < N; i++) {\n            cin >> p[i] >> q[i] >> r[i] >> b[i];\n            r[i]--; b[i]--;\n            if (r[i] >= 0) used[r[i]] = 1;\n            if (b[i] >= 0) used[b[i]] = 1;\n            int gcd = __gcd(p[i], q[i]);\n            p[i] /= gcd; q[i] /= gcd;\n            mx = max(mx, p[i] + q[i]);\n        }\n        int par = -1;\n        for (int i = 0; i < N; i++) {\n            if (!used[i]) {\n                par = i;\n                break;\n            }\n        }\n        for (int i = mx; ; i += mx) {\n            if (dfs(par, i)) {\n                cout << i << endl;\n                break;\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint x[110][2],w[110][2],n;\nbool cal[110];\nint COU(int a,int b){\n while(true){\n  if(a<2||b<2)return 1;\n  if(a<b){int t=a;a=b,b=t;}\n  a%=b;\n  if(!a)return b;\n }\n}\nint DFS(int q){\n    if(!q)return 1;\n    q--;\n    int a=DFS(w[q][0]),b=DFS(w[q][1]);\n    return (a*b*(x[q][0]+x[q][1]))/COU(a*x[q][0],b*x[q][1]);\n}\nint main(){\n while(true){\n cin>>n;\n if(!n)break;\n for(int i=0;i<n;i++)cal[i]=false;\n for(int i=0;i<n;i++){\n  cin>>x[i][0]>>x[i][1]>>w[i][0]>>w[i][1];\n  cal[w[i][0]-1]=true,cal[w[i][1]-1]=true;\n }\n for(int i=0;i<n;i++){\n  if(!cal[i])cout<<DFS(i+1)<<endl;\n }\n }\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <cmath>\n#include <map>\n#include <set>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n\n#define INF_LL 1e18\n#define INF 1e9\n\n#define REP(i, n) for(int i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n\n#define fst first\n#define snd second\n\nusing namespace std;\n\nusing ll = long long;\nusing PII = pair<int, int>;\n\nstruct stick{\n\tint l_d, r_d;\n\tint par, l, r;\n};\n\nstick s[101];\n\nint gcd(int x, int y){\n\tif(y == 0) return x;\n\treturn gcd(y, x%y);\n}\n\nint dfs(int st){\n\tif(st == 0) return 1;\n\tint l_w = dfs(s[st].l);\n\tint r_w = dfs(s[st].r);\n\t//int res = l_w*r_w*(s[st].l_d+s[st].r_d)/gcd(l_w, s[st].l_d)/gcd(r_w, s[st].r_d);\n\tint res = (l_w*r_w*s[st].l_d*s[st].r_d)/gcd(l_w*s[st].l_d, r_w*s[st].r_d);\n\tres = res/s[st].l_d + res/s[st].r_d;\n\treturn res;\n}\n\nint main(void){\n\tint n;\n\n\twhile(cin >> n && n){\n\t\tmemset(s, 0, sizeof s);\n\t\tFOR(i, 1, n+1){\n\t\t\ts[i].par = i;\n\t\t}\n\t\tFOR(i, 1, n+1){\n\t\t\tint a;\n\t\t\tcin >> s[i].l_d >> s[i].r_d >> s[i].l >> s[i].r;\n\t\t\ta = gcd(s[i].l_d, s[i].r_d);\n\t\t\ts[i].l_d /= a;\n\t\t\ts[i].r_d /= a;\n\t\t\ts[s[i].l].par = i;\n\t\t\ts[s[i].r].par = i;\n\t\t}\n\t\tint start = 1;\n\t\twhile(s[start].par != start){\n\t\t\tstart = s[start].par;\n\t\t}\n\t\tcout << dfs(start) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\nint d[101][4];\nint gcd(int a,int b){\n  int c;\n  while(b){\n    c=a;a=b;b=c%b;\n  }\n  return a;\n}\nint f(int m){\n  int w,r,l;\n  if(!m) w=1;\n  else{\n    r=f(d[m][2]);l=f(d[m][3]);\n    w=r*l*d[m][0]*d[m][1]/(gcd(r*d[m][0],l*d[m][1]));\n    w=w/d[m][0]+w/d[m][1];\n  }\n  return w;\n}\nint main(){\n  int n,t;\n  bool fl[101];\n  while(cin>>n,n){\n    memset(fl,0,sizeof(fl));\n    for(int i=1;i<=n;++i){\n      cin>>d[i][0]>>d[i][1]>>d[i][2]>>d[i][3];\n      fl[d[i][2]]=fl[d[i][3]]=true;\n    }\n    for(int i=1;i<=n;++i){\n      if(!fl[i]){\n\tt=i;break;\n      }\n    }\n    cout<<f(t)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define X real()\n#define Y imag()\nusing namespace std;\ntypedef complex<int> cld;\ntypedef vector<cld> vcl;\ntypedef vector<int> vi; \ntypedef long long ll;\nll lcs(ll p, ll q){\n\tll s=min(p,q),b=max(p,q);\n\tif(b%s ==0)\n\treturn s;\n\telse\n\treturn lcs(b%s,s);\n}\nll gcd(ll p,ll q){\n\treturn p*q/lcs(p,q);\n}\nint main() {\n\tint n;\n\twhile(cin >> n && n){\n\tbool fin[101]={1,0};\n\tll mobil[101][4]={};\n\tll grav[101]={1,0};\n\tll p,q,r,b;\n\tFOR(i,1,n+1){\n\t\tcin >> p >> q >> r >>b;\n\t\tll d=lcs(p,q);\n\t\tmobil[i][0]=q/d;\n\t\tmobil[i][1]=p/d;\n\t\tmobil[i][2]=r;\n\t\tmobil[i][3]=b;\n\t}\n\tREP(j,101){\n\t\tFOR(i,1,n+1)\n\t\t\tif(fin[mobil[i][2]] && fin[mobil[i][3]] && !fin[i]){\n\t\t\t\tll full=(mobil[i][0]+mobil[i][1]);\n\t\t\t\tll needA=grav[mobil[i][2]]/lcs(grav[mobil[i][2]],mobil[i][0]);\n\t\t\t\tll needB=grav[mobil[i][3]]/lcs(grav[mobil[i][3]],mobil[i][1]);\n\t\t\t\tgrav[i]=full*(gcd(needA,needB));\n\t\t\t\t\tfin[i]=true;\n\t\t\t}\n\t}\n\tll maxim=0;\n\tFOR(i,1,n+1)\n\tmaxim=max(maxim,grav[i]);\n\tcout << maxim << endl;\n\t}\n\t// your code goes here\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint dp[110],K[110],O[110],L[110],R[110];\n\nint gcd(int a,int b){\n\tint tmp;\n\twhile((tmp=a%b)!=0){\n\t\ta=b;\n\t\tb=tmp;\n\t}\n\treturn b;\n}\n\n\nint mobi(int bou){\n\tif(bou==0) return 1;\n\tif(dp[bou]!=0) return dp[bou];\n\tint l,r,li,ri,gc,gc2,a,b;\n\tl=mobi(L[bou]);\n\tr=mobi(R[bou]);\n\tri=K[bou];li=O[bou];\n\tgc=gcd(li,ri);\n\tli/=gc;ri/=gc;\n\tgc2=gcd(li*l,ri*r);\n\tb=li*l/gc2;\n\ta=ri*r/gc2;\n\treturn dp[bou]=(a*l+b*r);\n}\n\nint main(){\n\tint N,res;\n\twhile(1){\n\t\tcin>>N;\n\t\tmemset(dp,0,sizeof(dp));\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tcin>>K[i]>>O[i]>>L[i]>>R[i];\n\t\t}\n\t\tres=0;\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tres=max(res,mobi(i));\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nlong long b[100],c[100],d[100],e[100],f[100];\nlong long gcd(long long a,long long b){\n\twhile(b){\n\t\ta%=b;\n\t\tlong long t=a;\n\t\ta=b;\n\t\tb=t;\n\t}\n\treturn a;\n}\nlong long lcm(long long a,long long b){return a*b/gcd(a,b);}\nlong long dfs(long long a){\n\tif(a==-1)return 1;\n\tlong long L=dfs(d[a]-1)*c[a];\n\tlong long R=dfs(e[a]-1)*b[a];\n\tlong long t=lcm(L,R);\n\treturn t/c[a]+t/b[a];\n}\nint main(){\n\tlong long a;\n\twhile(scanf(\"%lld\",&a),a){\n\t\tfor(long long i=0;i<a;i++)scanf(\"%lld%lld%lld%lld\",b+i,c+i,d+i,e+i);\n\t\tfor(long long i=0;i<a;i++)f[i]=-1;\n\t\tfor(long long i=0;i<a;i++){\n\t\t\tif(d[i]>0)f[d[i]-1]=i;\n\t\t\tif(e[i]>0)f[e[i]-1]=i;\n\t\t}\n\t\tlong long parent=0;\n\t\tfor(long long i=0;i<a;i++)if(f[i]==-1)parent=i;\n\t\tprintf(\"%lld\\n\",dfs(parent));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <valarray>\n#include <vector>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(auto it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define mt make_tuple\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)(x).size())\n\nusing namespace std;\n\nstruct timer{\n\ttime_t start;\n\ttimer(){start=clock();}\n\t~timer(){cerr<<1.*(clock()-start)/CLOCKS_PER_SEC<<\" secs\"<<endl;}\n};\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<ll,ll> pi;\ntypedef stringstream sst;\ntypedef vector<ll> vi;\n\nint n,p[111],q[111],r[111],b[111];\n\nint gcd(int a,int b){\n\treturn b?gcd(b,a%b):a;\n}\n\nint f(int cur){\n\tif(cur==-1)return 1;\n\tint left=f(r[cur]),right=f(b[cur]);\n\tint g=gcd(left*p[cur],right*q[cur]);\n\treturn right*q[cur]/g*left+left*p[cur]/g*right;\n}\n\nint main2(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\t\n\tcin>>n;\n\tif(n==0)return 1;\n\tint appear[111]={};\n\trep(i,n){\n\t\tcin>>p[i]>>q[i]>>r[i]>>b[i];\n\t\t//int g=gcd(p[i],q[i]);\n\t\t//p[i]/=g,q[i]/=g;\n\t\tr[i]--,b[i]--;\n\t\tif(r[i]!=-1)appear[r[i]]=1;\n\t\tif(b[i]!=-1)appear[b[i]]=1;\n\t}\n\tint par;\n\trep(i,n)if(!appear[i])par=i;\n\tcout<<f(par)<<endl;\n\treturn 0;\n}\n\nint main(){\n\twhile(!main2());\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nlong long int gcd(const long long int a, const long long int b) {\n\tswitch (a % b) {\n\tcase 0: return b;\n\tdefault: return gcd(b, a % b);\n\t}\n}\nlong long int lcd(const long long int a, const long long int b) {\n\treturn a * b / gcd(a, b);\n}\nclass Mobile {\n\tlong long int _left_length{ 0 }, _right_length{ 0 };\n\tMobile *_left_mobile{ nullptr }, *_right_mobile{ nullptr };\n\tlong long int _whole_weight{ 0 };\n\tbool is_balanced() {\n\t\treturn _whole_weight != 0;\n\t}\n\tvoid balance() {\n\t\tlong long int l;\n\t\tif (_left_mobile == nullptr && _right_mobile == nullptr) {\n\t\t\tl = lcd(_left_length, _right_length);\n\t\t}\n\t\telse if (_left_mobile == nullptr) {\n\t\t\tif (!_right_mobile->is_balanced()) _right_mobile->balance();\n\t\t\tl = lcd(_left_length, _right_length * _right_mobile->_whole_weight);\n\t\t}\n\t\telse if (_right_mobile == nullptr) {\n\t\t\tif (!_left_mobile->is_balanced()) _left_mobile->balance();\n\t\t\tl = lcd(_right_length, _left_length * _left_mobile->_whole_weight);\n\t\t}\n\t\telse l = lcd(_right_mobile->_whole_weight * _right_length, _left_mobile->_whole_weight * _left_length);\n\t\t_whole_weight = l / _left_length + l / _right_length;\n\t}\npublic:\n\tMobile() {}\n\tvoid set_infomation(long long int left, long long int right, Mobile *left_mobile, Mobile *right_mobile) {\n\t\t_left_length = left / gcd(left, right);\n\t\t_right_length = right / gcd(left, right);\n\t\t_left_mobile = left_mobile;\n\t\t_right_mobile = right_mobile;\n\t}\n\tlong long int whole_weight() {\n\t\tif (!is_balanced()) balance();\n\t\treturn _whole_weight;\n\t}\n};\nvoid solve() {\n\tint n;\n\tstd::cin >> n;\n\twhile (n != 0) {\n\t\tstd::vector<Mobile> mobiles(n);\n\t\t{\n\t\t\tint p, q, r, b;\n\t\t\tfor (auto &mobile : mobiles) {\n\t\t\t\tstd::cin >> p >> q >> r >> b;\n\t\t\t\tmobile.set_infomation(p, q, (r == 0) ? nullptr : &mobiles[r - 1], (b == 0) ? nullptr : &mobiles[b - 1]);\n\t\t\t}\n\t\t\tlong long int max{ 0 };\n\t\t\tfor (auto &mobile : mobiles) if (max < mobile.whole_weight()) max = mobile.whole_weight();\n\t\t\tstd::cout << max << std::endl;\n\t\t}\n\t\tstd::cin >> n;\n\t}\n}\nint main() {\n\tsolve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long lli;\n\nconst int N = 100;\n\nint n, p[N+1], q[N+1], r[N+1], b[N+1];\nbool vis[N+1];\n\nlli gcd(lli x, lli y){\n  return x%y ? gcd(y, x%y) : y;\n}\n\nlli lcm(lli x, lli y){\n  return x * y / gcd(x, y);\n}\n\nlli solve(int pos){\n  lli t1 = 1, t2 = 1;\n  if(r[pos]) t1 = solve(r[pos]);\n  if(b[pos]) t2 = solve(b[pos]);\n  lli tmp1 = p[pos];\n  lli tmp2 = q[pos];\n  if(r[pos] && b[pos]){\n    tmp1 = lcm(t1, (lli)p[pos]);\n    tmp2 = lcm(t2, (lli)q[pos]);\n    tmp1 = lcm(tmp1, tmp2);\n    tmp2 = tmp1;\n  }else if(r[pos]){\n    tmp1 = lcm(t1, (lli)p[pos]);\n    tmp2 = (lli)q[pos] * (tmp1 / t1);\n  }else if(b[pos]){\n    tmp2 = lcm(t2, (lli)q[pos]);\n    tmp1 = (lli)p[pos] * (tmp2 / t2);\n  }\n  //cout << pos << ' ' << tmp1 << ' ' << tmp2 << endl;\n  return tmp1 + tmp2;\n}\n\nmain(){\n  while(cin >> n && n){\n    fill(vis, vis+N+1, false);\n    for(int i=1;i<=n;i++){\n      cin >> p[i] >> q[i] >> r[i] >> b[i];\n      lli tmp = gcd(p[i], q[i]);\n      p[i] /= tmp;\n      q[i] /= tmp;\n      vis[r[i]] = vis[b[i]] = true;\n    }\n    for(int i=1;i<=n;i++) if(!vis[i]) cout << solve(i) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\n#define REP(i,a,b) for(i=a; i<b; ++i)\n#define rep(i,n) REP(i,0,n)\n\nstruct mobile {\n  int lm,rm,lc,rc,ll,rl;\n  mobile(int lc,int rc,int ll,int rl)\n  : lc(lc), rc(rc), ll(ll), rl(rl) {\n    lm = rm = -1;\n  }\n};\n\nint gcd(int a,int b) {\n  return b != 0 ? gcd(b, a%b) : a;\n}\n\nint lcm(int a,int b) {\n  return a/gcd(a,b)*b;\n}\n\nint dfs(int pos,vector<mobile> &vm) {\n  mobile now = vm[pos];\n  now.lm = (now.lc == -1) ? 1 : dfs(now.lc,vm);\n  now.rm = (now.rc == -1) ? 1 : dfs(now.rc,vm);\n  int g = lcm(now.ll*now.lm, now.rl*now.rm);\n  now.rm = g / now.rl;\n  now.lm = g / now.ll;\n  return now.rm+now.lm;\n}\n\nint main() {\n  int n,i,p,q,r,b,root;\n  while(cin>>n, n) {\n    vector<mobile> vm;\n    vector<bool> isroot(n+1,true);\n    root = -1;\n    rep(i,n) {\n      cin>>p>>q>>r>>b;\n      r--,b--;\n      if(r >= 0) isroot[r] = false;\n      if(b >= 0) isroot[b] = false;\n      vm.push_back(mobile(r,b,p,q));\n    }\n\n    rep(i,n) if(isroot[i] == true) root = i;\n    cout<<dfs(root,vm)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define MAX_N 101\n\ntypedef struct\n{\n\tint rt_r;\n\tint rt_b;\n\tint con_r;\n\tint con_b;\n} bar;\n\nbar btemp;\nbar* makebar(const int rt_r,const int rt_b,const int con_r,const int con_b)\n{\n\tbtemp.rt_r = rt_r;\n\tbtemp.rt_b = rt_b;\n\tbtemp.con_r = con_r;\n\tbtemp.con_b = con_b;\n\treturn &btemp;\n}\n\nint gcd(int a,int b)\n{\n\tint tmp;\n\tif(a < b)\n\t{\n\t\ttmp = a;\n\t\ta = b;\n\t\tb = tmp;\n\t}\n\twhile(b != 0)\n\t{\n\t\ttmp = a % b;\n\t\ta = b;\n\t\tb = tmp;\n\t}\n\treturn a;\n}\n\nint lcm(int a,int b)\n{\n\treturn a*b / gcd(a,b);\n}\n\nint N;\nvector<bar> B;\nvector<bool> T;\nvector<int> A;\n\nvoid dfs(int _b,int _u,int _d)\n{\n\tint u = _u / gcd(_u,_d);\n\tint d = _d / gcd(_u,_d);\n\tint b = _b - 1;\n\tif(B[b].con_r != 0)\n\t{\n\t\tdfs(B[b].con_r,u * B[b].rt_b,d * (B[b].rt_b + B[b].rt_r));\n\t}\n\telse\n\t{\n\t\tA.push_back((d * (B[b].rt_b + B[b].rt_r)) / gcd((u * B[b].rt_b),(d * (B[b].rt_b + B[b].rt_r))));\n\t}\n\tif(B[b].con_b != 0)\n\t{\n\t\tdfs(B[b].con_b,u * B[b].rt_r,d * (B[b].rt_b + B[b].rt_r));\n\t}\n\telse\n\t{\n\t\tA.push_back((d * (B[b].rt_b + B[b].rt_r)) / gcd((u * B[b].rt_r),(d * (B[b].rt_b + B[b].rt_r))));\n\t}\n}\n\nint main(void)\n{\n\tcin >> N;\n\tint p,q,r,b;\n\tfor(int i = 0;i < N;i++)\n\t{\n\t\tcin >> p >> q >> r >> b;\n\t\tB.push_back(*makebar(p / gcd(p,q),q / gcd(p,q),r,b));\n\t\tT.push_back(true);\n\t}\n\tfor(auto itr = B.begin();itr < B.end();itr++)\n\t{\n\t\tif(itr->con_r != 0)\n\t\t\tT[itr->con_r-1] = false;\n\t\tif(itr->con_b != 0)\n\t\t\tT[itr->con_b-1] = false;\n\t}\n\tint top = -1;\n\tfor(auto itr = T.begin();itr < T.end();itr++)\n\t{\n\t\tif(*itr)\n\t\t\ttop = itr - T.begin();\n\t}\n\tif(top == -1)\n\t\texit(-1);\n\tdfs(top+1,1,1);\n\tint result = 1;\n\tfor(auto itr = A.begin();itr < A.end();itr++)\n\t{\n\t\tresult = lcm(result,*itr);\n\t}\n\tcout << result << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<map>\n#include<cassert>\n#define F first\n#define S second\n#define PPins(a,b,c,d) PP(P(a,b),P(c,d))\n#define PPPins(a,b,c,d,e) PPP(a,PP(P(b,c),P(d,e)))\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\ntypedef pair<int,PP> PPP;\n\nmap<int,PP> tree;\nint top;\n\nint lcm(int a,int b)\n{\n  return a/__gcd(a,b)*b;\n}\n\nint rec(int n)\n{\n \n  int gcd = __gcd(tree[n].F.F,tree[n].F.S);\n  if(!tree[n].S.F && !tree[n].S.S)\n       return tree[n].F.F/gcd + tree[n].F.S/gcd;\n\n  if(tree[n].S.F && tree[n].S.S)\n    {\n      int Left = rec(tree[n].S.F);\n      int Right = rec(tree[n].S.S);\n   \n      return 2*lcm(tree[n].F.F/gcd*Left,tree[n].F.S/gcd*Right);\n\n    }\n\n  if(!tree[n].S.F && tree[n].S.S)\n    {      \n      int Right = rec(tree[n].S.S);\n      //int rig   = tree[n].F.F/gcd*Right;\n      //int Left = rig*(tree[n].F.S/gcd)/(tree[n].F.F/gcd);\n      int x = lcm((Right*(tree[n].F.S/gcd)),tree[n].F.F/gcd)/tree[n].F.F;\n      //cout << \"In \" << n << \" x = \" << x << \" return = \" << (x*(tree[n].F.F/gcd))/(tree[n].F.S/gcd) + x << endl;\n      return (x*(tree[n].F.F/gcd))/(tree[n].F.S/gcd) + x;\n    }\n\n  if(tree[n].S.F && !tree[n].S.S)\n    {\n      int Left = rec(tree[n].S.F);\n      //int lef   = tree[n].F.S/gcd*Left;\n      //int Right = lef*(tree[n].F.F/gcd)/(tree[n].F.S/gcd);\n      int x = lcm((Left*(tree[n].F.F/gcd)),tree[n].F.S/gcd)/tree[n].F.S;\n      //cout << \"In \" << n << \" x = \" << x << \" return = \" << (x*(tree[n].F.S/gcd))/(tree[n].F.F/gcd) + x << endl;\n      return (x*(tree[n].F.S/gcd))/(tree[n].F.F/gcd) + x;\n    }\n\n  assert(false);\n  return 0;\n}\n\nint main()\n{\n  int n;\n  while(true)\n    {\n      scanf(\"%d\",&n);\n      if(!n)\n\tbreak;\n      tree.clear();      \n      bool *who = new bool[n+1];\n      for(int i=0;i<n+1;i++)\n\twho[i] = false;\n      who[0] = true;\n      for(int i=0;i<n;i++)\n\t{\n\t  int p,q,r,b;\n\t  scanf(\"%d %d %d %d\",&p,&q,&r,&b);\n\t  tree[i+1] = PPins(p,q,r,b);\n\t  who[r] = who[b] = true;\n\t}\n\n      top = -1;\n      for(int i=1;i<n+1;i++)\n\tif(!who[i])\n\t  {\n\t    top = i;\n\t    break;\n\t  }\n      delete [] who;\n      assert(top != -1);\n      \n      printf(\"%d\\n\",rec(top));    \n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint depth[500];\nint w[500][2];\nint x[500][2];\nint n, root, v[500], a, A, B, C;\npair<int, int>DEPTH[500];\nint mobile[500][2];\n\nint gcd(int p, int q) {\n\tint P = p, Q = q;\n\twhile (true) {\n\t\tif (P%Q == 0) { return Q; }\n\t\tif (Q%P == 0) { return P; }\n\t\tif (P > Q) { P = P%Q; }\n\t\telse { Q = Q%P; }\n\t}\n}\n\nint main() {\n\twhile (true) {\n\t\tcin >> n;\n\t\tif (n == 0) { break; }\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tv[i] = 0;\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tcin >> w[i][0] >> w[i][1] >> x[i][0] >> x[i][1];\n\t\t\tv[x[i][0]] = 1; v[x[i][1]] = 1;\n\t\t\ta = gcd(w[i][0], w[i][1]);\n\t\t\tw[i][0] /= a; w[i][1] /= a;\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (v[i] == 0) {\n\t\t\t\troot = i;\n\t\t\t}\n\t\t}\n\t\t//depth.\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tdepth[i] = 1000;\n\t\t}\n\t\tdepth[root] = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tif (depth[j] != 1000) {\n\t\t\t\t\tdepth[x[j][0]] = min(depth[x[j][0]], depth[j] + 1);\n\t\t\t\t\tdepth[x[j][1]] = min(depth[x[j][1]], depth[j] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tDEPTH[i - 1].first = depth[i];\n\t\t\tDEPTH[i - 1].second = i;\n\t\t}\n\t\tsort(DEPTH, DEPTH + n);\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tA = DEPTH[i].first;\n\t\t\tB = DEPTH[i].second;\n\t\t\tif (x[B][0] == 0 && x[B][1] == 0) {\n\t\t\t\tmobile[B][0] = w[B][1];\n\t\t\t\tmobile[B][1] = w[B][0];\n\t\t\t}\n\t\t\tif (x[B][0] == 0 && x[B][1] >= 1) {\n\t\t\t\tmobile[B][1] = mobile[x[B][1]][0] + mobile[x[B][1]][1];\n\t\t\t\tmobile[B][1] = mobile[B][1] * w[B][0] / gcd(mobile[B][1], w[B][0]);\n\t\t\t\tmobile[B][0] = mobile[B][1] * w[B][1] / w[B][0];\n\t\t\t}\n\t\t\tif (x[B][0] >= 1 && x[B][1] == 0) {\n\t\t\t\tmobile[B][0] = mobile[x[B][0]][0] + mobile[x[B][0]][1];\n\t\t\t\tmobile[B][0] = mobile[B][0] * w[B][1] / gcd(mobile[B][0], w[B][1]);\n\t\t\t\tmobile[B][1] = mobile[B][0] * w[B][0] / w[B][1];\n\t\t\t}\n\t\t\tif (x[B][0] >= 1 && x[B][1] >= 1) {\n\t\t\t\tmobile[B][0] = mobile[x[B][0]][0] + mobile[x[B][0]][1];\n\t\t\t\tmobile[B][1] = mobile[x[B][1]][0] + mobile[x[B][1]][1];\n\t\t\t\tC = mobile[B][0] * w[B][0] * mobile[B][1] * w[B][1] / gcd(mobile[B][0] * w[B][0], mobile[B][1] * w[B][1]);\n\t\t\t\tmobile[B][0] = C / w[B][0];\n\t\t\t\tmobile[B][1] = C / w[B][0];\n\t\t\t}\n\t\t}\n\t\tcout << mobile[root][0] + mobile[root][1] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nusing namespace std;\nint n,d[102][4];\nbool ch[102];\n\nint gcd(int a,int b){\n  if(b == 0) return a;\n  return gcd(b,a % b);\n}\n\n\nint dfs(int x){\n  int p = d[x][0];\n  int q = d[x][1];\n  int w = gcd(p,q);\n  \n  p /= w;\n  q /= w;\n  \n  if(d[x][2] == 0 && d[x][3] == 0){\n    return (p+q);\n  }\n  \n  int red=1,blue=1;\n  \n  if(d[x][2] != 0) red = dfs(d[x][2]);\n  if(d[x][3] != 0) blue = dfs(d[x][3]);\n  \n  int k = p * red;\n  int h = q * blue;\n  int i = 0;\n  int j = 0;\n  while(1){\n    i++;\n    if(k * i % h == 0){\n      j = k * i / h;\n      break;\n    }\n  }\n  \n  return (i*red+j*blue);\n}\n  \n\nint main(){\n  \nwhile(1){\n  \n  scanf(\"%d\",&n);\n  if(n == 0)break;\n  \n  for(int i = 1;i <= n;i++){\n    ch[i] = false;\n  }\n  \n  for(int i = 1;i <= n;i++){\n    for(int j = 0;j < 4;j++){\n      scanf(\"%d\",&d[i][j]);\n      if(j == 2 || j == 3){\n\tch[d[i][j]] = true;\n      }\n    }\n  }\n  int ans;\n  for(int i = 1;i <= n;i++){\n    if(ch[i] == false){\n      ans = i;\n    }\n  }\n  \n  printf(\"%d\\n\",dfs(ans));\n  \n}\n  \n  return 0;\n  \n}\n  \n  \n \n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nlong long int gcd( long long int a, long long int b ) {\n  return b ? gcd( b, a % b ) : a ;\n}\nlong long int lcm( long long int m, long long int n ) {\n  if ( m == 0 || n == 0 ) return 0;\n  return ( ( m / gcd( m, n ) ) * n );\n}\n\nint main() {\n\n  while( true ) {\n\n    long long int n;\n    cin >> n;\n    if ( n == 0 ) break;\n\n    vector< long long int > p, q, r, b;\n    for ( long long int i = 0; i < n; i++ ) {\n      long long int in_p, in_q, in_r, in_b;\n      cin >> in_p >> in_q >> in_r >> in_b;\n      p.push_back( in_p );\n      q.push_back( in_q );\n      r.push_back( in_r );\n      b.push_back( in_b );\n    }\n\n    for ( long long int i = 0; i < n; i++ ) {\n      for ( long long int j = 0; j < n; j++ ) {\n\n\tif ( r[j] <= 0 && b[j] <= 0 ) {\n\n\t  if ( r[j] == 0 ) {\n\t    r[j] = 1;\n\t  }else {\n\t    r[j] = -r[j];\n\t  }\n\t  long long int r2 = r[j] * p[j];\n\t  if ( b[j] == 0 ) {\n\t    b[j] = 1;\n\t  }else {\n\t    b[j] = -b[j];\n\t  }\n\t  long long int b2 = b[j] * q[j];\n\t  long long int h = lcm( r2, b2 ) / p[j] + lcm( r2, b2 ) / q[j];\n\n\t  r[j] = n + 2;\n\t  b[j] = n + 2;\n\n\t  for ( long long int k = 0; k < n; k++ ) {\n\t    if ( i == n - 1 ) {\n\t      cout << h << endl;\n\t      break;\n\t    }\n\t    if ( r[k] == j + 1 ) {\n\t      r[k] = -h;\n\t      break;\n\t    }\n\t    if ( b[k] == j + 1 ) {\n\t      b[k] = -h;\n\t      break;\n\t    }\n\t  }\n\t  break;\n\n\t}\n\n      }\n    }\n\n  }\n\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define MP make_pair\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef pair<int, int> P;\n\nint gcd(int n, int m){\n\treturn m==0?n:gcd(m, n%m);\n}\n\nint lcm(int n, int m){\n\tint g = gcd(n, m);\n\treturn n/g*m;\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n, n){\n\t\tvector<vi> v(n+1);\n\t\tvector<P> k(n+1);\n\t\tvi w(n+1), cnt(n+1);\n\t\tw[0] = cnt[0] = 1;\n\t\tvi red(n+1), blue(n+1);\n\t\trep(i, n){\n\t\t\tint p, q, r, s;\n\t\t\tcin >> p >> q >> r >> s;\n\t\t\tint g = gcd(p, q);\n\t\t\tk[i+1] = MP(p/g, q/g);\n\t\t\tred[i+1] = r;\n\t\t\tblue[i+1] = s;\n\t\t\tv[r].push_back(i+1);\n\t\t\tv[s].push_back(i+1);\n\t\t\tcnt[i+1] += !!r+!!s;\n\t\t}\n\t\tqueue<int> q;\n\t\tfor(int i = 1; i <= n; i++) if(!cnt[i]) q.push(i);\n\t\tint last = -1;\n\t\twhile(!q.empty()){\n\t\t\tint m = q.front();\n\t\t\tq.pop();\n\t\t\tlast = m;\n\n\t\t\tint l = lcm(k[m].first*w[blue[m]], k[m].second*w[red[m]]);\n\t\t\tw[m] = l/k[m].first + l/k[m].second;\n\n\t\t\trep(i, v[m].size()){\n\t\t\t\tcnt[v[m][i]]--;\n\t\t\t\tif(!cnt[v[m][i]]) q.push(v[m][i]);\n\t\t\t}\n\t\t}\n\t\tcout << w[last] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint p[101],q[101],r[101],b[101],used[102];\n\nint saiki(int ima){\n  int A=1,B=1;\n  if(r[ima])A=saiki(r[ima]);\n  if(b[ima])B=saiki(b[ima]);\n  int res=__gcd(A*p[ima],B*q[ima]);\n  int resA=(A*p[ima])/res,resB=(B*q[ima])/res;\n  return (A*resB)+(B*resA);\n}\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    memset(used,0,sizeof(used));\n    for(int i=1;i<=n;i++){\n      cin>>p[i]>>q[i]>>r[i]>>b[i];\n      int res=__gcd(p[i],q[i]);\n      p[i]/=res,q[i]/=res;\n      used[r[i]]=used[b[i]]=1;\n    }\n    for(int i=1;i<=n;i++)if(!used[i]) cout<<saiki(i)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nll gcd(ll a, ll b) {\n  return b != 0 ? gcd(b, a % b) : a;\n}\n\nconst ll WEIGHT=-1;\nstruct stick{\n\tll r,b,p,q;\n\tstick(ll r,ll b,ll p,ll q):r(r),b(b){\n\t\tll g=gcd(p,q);\n\t\tthis->p=p/g;\n\t\tthis->q=q/g;\n\t}\n\tll getroot(ll index,vector<stick> &sticks){\n\t\tREP(i,sticks.size()){\n\t\t\tif(sticks[i].r==index||sticks[i].b==index){\n\t\t\t\treturn sticks[i].getroot(i,sticks);\n\t\t\t}\n\t\t}\n\t\treturn index;\n\t}\n\tll go(vector<stick> &sticks){\n\t\tll rw=0,bw=0;\n\t\tif(r!=WEIGHT){\n\t\t\trw=sticks[r].go(sticks);\n\t\t}\n\t\tif(b!=WEIGHT){\n\t\t\tbw=sticks[b].go(sticks);\n\t\t}\n\t\tif(r==WEIGHT&&b==WEIGHT){\n\t\t\trw=q;\n\t\t\tbw=p;\n\t\t}else if(r==WEIGHT){\n\t\t\tif(p*bw%q){\n\t\t\t\trw=bw*p;\n\t\t\t\tbw*=q;\n\t\t\t}else{\n\t\t\t\trw=bw*p/q;\n\t\t\t\tassert(bw);\n\t\t\t}\n\t\t}else if(b==WEIGHT){\n\t\t\tif(q*rw%p){\n\t\t\t\tbw=rw*q;\n\t\t\t\trw*=p;\n\t\t\t}else{\n\t\t\t\tbw=rw*q/p;\n\t\t\t\tassert(rw);\n\t\t\t}\n\t\t}else{\n\t\t\tassert(bw);\n\t\t\tassert(rw);\n\t\t\tll trw=rw,tbw=bw;\n\t\t\tll gr=gcd(rw,q);\n\t\t\tll gb=gcd(bw,p);\n\t\t\trw=trw*tbw*q/gr;\n\t\t\tassert(tbw);\n\t\t\tassert(trw);\n\t\t\tassert(p);\n\t\t\tcerr<<gb<<endl;\n\t\t\tassert(gb);\n\t\t\tbw=tbw*trw*p/gb;\n\t\t\tassert(bw);\n\t\t\tassert(rw);\n\t\t}\n\t\tassert(rw&&bw);\n\t\treturn rw+bw;\n\t}\n};\n\n\nint main(){\n\tll n;\n\twhile(cin>>n,n){\n\t\tvector<stick> sticks;\n\t\tREP(i,n){\n\t\t\tll p,q,r,b;\n\t\t\tcin>>p>>q>>r>>b;\n\t\t\tr--;b--;\n\t\t\tsticks.push_back(stick(r,b,p,q));\n\t\t}\n\t\tll root=sticks[0].getroot(0,sticks);\n\t\tcout<<sticks[root].go(sticks)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint lenL[100];\nint lenR[100];\nint L[100];\nint R[100];\nlong long int c[100];\nlong long int d[100];\nlong long wL[100];\nlong long wR[100];\nint parent[100];\nbool visited[100];\nlong long int gcd(long long int a,long long int b){\n\twhile(b){\n\t\ta%=b;\n\t\tlong long int val=b;\n\t\tb=a;\n\t\ta=val;\n\t}\n\treturn a;\n}\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tfor(int i=0;i<a;i++){\n\t\t\tscanf(\"%d%d%d%d\",lenL+i,lenR+i,L+i,R+i);\n\t\t}\n\t\tlong long total=1;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tc[i]=lenL[i]/gcd(lenL[i],lenR[i]);\n\t\t\td[i]=lenR[i]/gcd(lenR[i],lenL[i]);\n\t\t\ttotal*=(c[i]+d[i]);\n\t\t}\n\t\tfor(int i=0;i<a;i++)parent[i]=-1;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tif(L[i])\n\t\t\t\tparent[L[i]-1]=i;\n\t\t\tif(R[i])\n\t\t\t\tparent[R[i]-1]=i;\n\t\t}\n\t\tfor(int i=0;i<a;i++)visited[i]=false;\n\t\tfor(int j=0;j<a;j++){\n\t\t\tfor(int i=0;i<a;i++){\n\t\t\t\tif(parent[i]==-1&&visited[i]==false){\n\t\t\t\t\twL[i]=total/(c[i]+d[i])*d[i];\n\t\t\t\t\twR[i]=total/(c[i]+d[i])*c[i];\n\t\t\t\t\tvisited[i]=true;\n\t\t\t\t}else if(parent[i]!=-1&&visited[i]==false&&visited[parent[i]]==true){\n\t\t\t\t\tvisited[i]=true;\n\t\t\t\t\twL[i]=(L[parent[i]]==i+1?wL[parent[i]]:wR[parent[i]])/(c[i]+d[i])*d[i];\n\t\t\t\t\twR[i]=(L[parent[i]]==i+1?wL[parent[i]]:wR[parent[i]])/(c[i]+d[i])*c[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(1){\n\t\t\tlong long  val=total;\n\t\t\tfor(int i=0;i<a;i++){\n\t\t\t\tval=gcd(val,gcd(wL[i],wR[i]));\n\t\t\t}\n\t\t\tif(val==1)break;\n\t\t\ttotal/=val;\n\t\t\tfor(int i=0;i<a;i++){\n\t\t\t\twL[i]/=val;\n\t\t\t\twR[i]/=val;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",total);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n\ntemplate <class T>\nint __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\nll gcd(ll a, ll b)\n{\n\tif (a < b)\n\t\tswap(a, b);\n\tif (b == 0)\n\t\treturn a;\n\treturn gcd(b, a%b);\n}\nll lcm(ll a, ll b)\n{\n\treturn a*b/gcd(a, b);\n}\nint p[101], q[101], r[101], b[101];\nint w[101];\nint dfs(int s)\n{\n\tif (w[s] != -1)\n\t\treturn w[s];\n\n\tif (s == 0)\n\t\treturn 1;\n\n\tll red = dfs(r[s]), blue = dfs(b[s]);\n\tll t = lcm(red*q[s], blue*p[s]);\n\treturn w[s] = (int)(t/p[s] + t/q[s]);\n}\nint main()\n{\n\tint n;\n\twhile (scanf(\"%d\", &n), n)\n\t{\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t{\n\t\t\tscanf(\"%d%d%d%d\", p+i, q+i, r+i, b+i);\n\t\t\tll g = gcd(p[i], q[i]);\n\t\t\tp[i] /= g, q[i] /= g;\n\t\t}\n\t\tmemset(w, -1, sizeof(w));\n\t\tint res = 0;\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t\tres = max(res, dfs(i));\n\t\tprintf(\"%d\\n\", res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define ALL(a) (a).begin(),(a).end()\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\nconst int INF=1e9;\nint gcd(int a,int b){\n  if(b==0)return a;\n  return gcd(b,a%b);\n}\nint main(){\n  int n;\n  while(cin>>n&&n){\n    vector<int>G[110];\n    int w[110],p[110],q[110],r[110],b[110];\n    memset(w,-1,sizeof(w));\n    for(int i=1;i<=n;i++){\n      cin>>p[i]>>q[i]>>r[i]>>b[i];\n      int g=gcd(p[i],q[i]);\n      p[i]/=g;q[i]/=g;\n      if(r[i]==0&&b[i]==0){\n        w[i]=p[i]+q[i];\n      }else{\n        G[r[i]].PB(i);\n        G[b[i]].PB(i);\n      }\n    }\n    bool update=true;\n    while(update){\n      update=false;\n      for(int i=1;i<=n;i++){\n        if(w[i]!=-1)continue;\n        if((r[i]==0||w[r[i]]!=-1)&&(b[i]==0||w[b[i]]!=-1)){\n          if(r[i]==0||b[i]==0){\n            if(r[i]==0)w[i]=w[b[i]]*(p[i]+q[i]);\n            else w[i]=w[r[i]]*(p[i]+q[i]);\n          }else{\n            int g=gcd(w[r[i]]*q[i],w[b[i]]*p[i]);\n            w[i]=w[r[i]]*q[i]/gcd(w[r[i]]*q[i],w[b[i]]*p[i])*w[b[i]]*p[i]*2;\n          }\n          update=true;\n        }\n      }\n    }\n    int ans=0;\n    for(int i=1;i<=n;i++)ans=max(w[i],ans);\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(b) - 1;i>=(a);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n\n#define PB push_back\n#define INF (1<<29)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define CLR(a) memset(a,0,sizeof(a))\nconst int dx[] = {-1,0,0,1},dy[] = {0,1,-1,0};\n\ntypedef long long int ll;\n\nusing namespace std;\nstruct mobile{\n    int rc;\n    int lc;\n    int l;\n    int r;\n    int w; \n};\n\nint gcd(int a, int b){\n    return a%b==0 ? b : gcd(b,a%b);\n}\n\nvoid q(int i){\n\n}\n\nint main(){\n    while(true){\n\tint n;\n\tcin >> n;\n\tif(n == 0) break;\n\tint ans =0 ;\n\tvector< struct mobile > v(n);\n\tREP(i,n){\n\t    int l,r,lc,rc;\n\t    cin >> l >> r >> lc >> rc;\n\t    v[i].l = l;\n\t    v[i].r = r;\n\t    v[i].lc = lc;\n\t    v[i].rc = rc;\n\t    v[i].w = 0;\n\t}\n\tbool flg = true;\n\twhile(flg){\n\t    flg = false;\n\t    REP(i,n){\n\t\tif(v[i].w == 0 && v[i].rc == 0 && v[i].lc == 0){\n\t\t    int r = v[i].r;\n\t\t    int l = v[i].l;\n\t\t    v[i].r /= gcd(r,l);\n\t\t    v[i].l /= gcd(r,l);\n\t\t    v[i].w = v[i].r + v[i].l;\n\t\t    flg = true;\n\t\t}else{\n\t\t    int lw,rw;\n\t\t    if(v[i].w > 0) continue;\n\t\t    if(v[i].lc == 0){\n\t\t\tlw = 1;\n\t\t    }else if(v[v[i].lc-1].w > 0){\n\t\t\tlw = v[v[i].lc-1].w;\n\t\t    }else continue;\n\n\t\t    if(v[i].rc == 0){\n\t\t\trw = 1;\n\t\t    }else if(v[v[i].rc-1].w > 0){\n\t\t\trw = v[v[i].rc-1].w;\n\t\t    }else continue;\n\t\t    int r,l;\n\t\t    r = v[i].r;\n\t\t    l = v[i].l;\n\t\t    v[i].r /= gcd(r,l);\n\t\t    v[i].l /= gcd(r,l);\n\t\t    int w = 10000000;\n\t\t    FOR(k,1,100){\n\t\t\tFOR(j,1,100){\n\t\t\t    if(rw*k * v[i].r == lw * j * v[i].l){\n\t\t\t\tw = min ( w, rw*k+lw*j);\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    v[i].w = w;\n\t\t    flg = true;\n\t\t}\n\t\tans = max(ans,v[i].w);\n\t    }\n\t}\n\tcout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint n,mem[110][5],sum;\nint F(int n1,int n2)\n{\n    if(n1 == 0)return n2;\n    return F(n2 % n1,n1);\n}\nint min_w(int n_mobile)\n{\n    int n1,n2,lim,longth,s1,s2;\n    if(mem[n_mobile][2] == 0)n1 = 1;\n    else n1 = min_w(mem[n_mobile][2] - 1);\n    if(mem[n_mobile][3] == 0)n2 = 1;\n    else n2 = min_w(mem[n_mobile][3] - 1);\n    longth = F(min(mem[n_mobile][0],mem[n_mobile][1]),max(mem[n_mobile][0],mem[n_mobile][1]));\n    //printf(\"%d %d %d\\n\",n_mobile,lim,longth);\n    s1 = n1 / F(n2,mem[n_mobile][0] / longth);\n    s2 = n2 / F(n1,mem[n_mobile][1] / longth);\n    lim = F(min(s1,s2),max(s1,s2));\n    return ((s1 * s2) / lim) * ((mem[n_mobile][0] / longth) + (mem[n_mobile][1] / longth));\n}\nint main()\n{\n    while(scanf(\"%d\",&n),n)\n    {\n        sum = 0;\n        for(int i = 0; i < n; i++)\n        {\n            for(int j = 0; j < 4; j++)\n            {\n                scanf(\"%d\",&mem[i][j]);\n            }\n            sum += mem[i][2] + mem[i][3];\n        }\n        printf(\"%d\\n\",min_w((n * (n + 1)) / 2 - sum - 1));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint N;\nint P[100], Q[100], R[100], B[100];\nint T[100];\n\nlong long gcd(long long a, long long b) {\n  if (a > b) swap(a, b);\n  if (a == 0) return b;\n  return gcd(b%a, a);\n}\n\nlong long lcm(long long a, long long b) {\n  long long g = gcd(a, b);\n  if (g == 0) return max(a, b);\n  cout << \"lcm(\"<<a<<\", \"<<b<<\") = \" << a/g*b<<\"\\n\";\n  return a / g * b;\n}\n\nlong long f(int x) {\n  if (x == -1) return 1;\n  long long l = f(R[x]), r = f(B[x]);\n  long long g = gcd(l*P[x], r*Q[x]);\n  return l * r * (P[x] + Q[x]) / g;\n}\n\nint main() {\n  while (cin >> N) {\n    if (N == 0) break;\n    for (int i=0; i<N; i++) T[i] = 0;\n    for (int i=0; i<N; i++) {\n      int r, b;\n      cin >> P[i] >> Q[i] >> R[i] >> B[i];\n      int g = gcd(P[i], Q[i]);\n      P[i] /= g, Q[i] /= g;\n      R[i]--, B[i]--;\n      if (R[i] >= 0) T[R[i]]++;\n      if (B[i] >= 0) T[B[i]]++;\n    }\n    int root = -1;\n    for (int i=0; i<N; i++) {\n      if (T[i] == 0) root = i;\n    }\n    cout << f(root) << \"\\n\";\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nunsigned int dp[110],K[110],O[110],L[110],R[110];\n\nunsigned int gcd(unsigned int a,unsigned int b){\n\tunsigned int tmp;\n\twhile((a%b)!=0){\n\t\ttmp=a%b;\n\t\ta=b;\n\t\tb=tmp;\n\t}\n\treturn b;\n}\n\n\nunsigned int mobi(unsigned int bou){\n\tif(bou==0) return 1;\n\tif(dp[bou]!=0) return dp[bou];\n\tunsigned int l,r,li,ri,gc,gc2,a,b;\n\tl=mobi(L[bou]);\n\tr=mobi(R[bou]);\n\tri=K[bou];li=O[bou];\n\tgc=gcd(li,ri);\n\tli/=gc;ri/=gc;\n\tgc2=gcd(li*l,ri*r);\n\tb=li*l/gc2;\n\ta=ri*r/gc2;\n\tdp[bou]=(a*l+b*r);\n\treturn dp[bou];\n}\n\nint main(){\n\tint N;\n\tunsigned int res;\n\twhile(1){\n\t\tcin>>N;\n\t\tif(N==0) break;\n\t\tmemset(dp,0,sizeof(dp));\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tcin>>K[i]>>O[i]>>L[i]>>R[i];\n\t\t}\n\t\tres=0;\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tres=max(res,mobi(i));\n\t\t}\n\t\t/*\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tcout<<i<<\" \"<<dp[i]<<endl;//\n\t\t}\n\t\t*/\n\t\tcout<<res<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<cmath>\n#include<queue>\n#include<utility>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<numeric>\n#include<functional>\n#include<string>\n#include<iostream>\n\nusing namespace std;\nconst int one = 1;\nconst int big = (one<<20);\ntypedef long long int llint;\nconst int Llong=0;\nconst int Rlong=1;\nconst int Lbow=2;\nconst int Rbow=3;\nvector<tuple<int,int,int,int>> bow;//??????????????????????£????????£?\ninline int GCDme(int n,int m){\n\tif(n<m){swap(n,m);}\n\tif(n==0||m==0){\n\t\treturn n+m;\n\t}\n\treturn GCDme(m,n%m);\n}\ninline int LCMme(int n,int m){\n\treturn (n*m)/GCDme(n,m);\n}\nint make_bow(int ter){\n\tint Llcm,Rlcm,Smom;//??????????°????????????????????????¢????????????\n\tif(get<Lbow>(bow[ter])==0){ Llcm=1; } else{Llcm=make_bow(get<Lbow>(bow[ter]));}\n\tif(get<Rbow>(bow[ter])==0){ Rlcm=1; } else{Rlcm=make_bow(get<Rbow>(bow[ter]));}\n\tSmom=LCMme( Llcm*get<Llong>(bow[ter]) , Rlcm*get<Rlong>(bow[ter]) );\n\treturn (Smom/get<Llong>(bow[ter])) + (Smom/get<Rlong>(bow[ter]));\n}\nbool solve(void){\n\tint i,n,a,b,c,d,e,ans;\n\tbow.clear();//?£????????????????\n\tint used_bow[101]={0};\n\tint top_bow=0;\n\tscanf(\"%d\",&n);\n\tif(n==0){ return false; }\n\tbow.push_back(make_tuple(1,1,0,0));//1???????£?????§??????????\n\tfor(i=1;i<=n;i++){\n\t\tscanf(\"%d %d %d %d\",&a,&b,&c,&d);\n\t\tbow.push_back(make_tuple(a,b,c,d));\n\t\tused_bow[c]=1;\n\t\tused_bow[d]=1;\n\t}\n\tfor(i=1;i<=n;i++){\n\t\tif(used_bow[i]==0){top_bow=i;break;}\n\t}\n\tans=make_bow(top_bow);\n\tprintf(\"%d\\n\",ans);\n\treturn true;\n}\nint main(void){\n\twhile(solve()){}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<functional>\n#include<cmath>\n#include<set>\n#include<random>\n#include<map>\nusing namespace std;\n#define int long long\n#define rep(i,n) for(int i=0;i<n;i++)\nconst long long mod = 1000000007;\nconst long long inf = 11451419198109130;\ntypedef pair<int, int> P;\ntypedef pair<P, P> PP;\nstruct edge {int to, cost;};\nint p[114], q[114], b[114], r[114];\nint h[114];\nint gcd(int a, int b) {\n\tif (!b)return a; return gcd(b, a%b);\n}\n\nint heavy(int i) {\n\tif (r[i]>=0 && !h[r[i]]) heavy(r[i]);\n\tif (b[i]>=0 && !h[b[i]])heavy(b[i]);\n\n\tif (r[i]==-1&& b[i]==-1) {\n\t\tint P = p[i], Q = q[i];\n\t\tint G = gcd(P, Q);\n\t\tP /= G; Q /= G;\n\t\treturn h[i] = P + Q;\n\t}\n\telse if(r[i]==-1){\n\t\tint P=p[i], Q = q[i];\n\t\tint G = gcd(P, Q*h[b[i]]);\n\t\tG = p[i] / G;\n\t\th[b[i]] *= G;\n\t\treturn h[i] = h[b[i]] + h[b[i]] * q[i] / p[i];\n\t}\n\telse if (b[i] == -1) {\n\t\tint P = p[i], Q = q[i];\n\t\tint G = gcd(P*h[r[i]], Q);\n\t\tG = Q / G;\n\t\th[r[i]] *= G;\n\t\treturn h[i] = h[r[i]] + h[r[i]] * p[i] / q[i];\n\t}\n\telse {\n\t\tint P = p[i] * h[r[i]], Q = q[i] * h[b[i]];\n\t\tint G = gcd(P, Q);\n\t\th[r[i]] *= Q / G;\n\t\th[b[i]] *= P / G;\n\t\treturn h[i] = h[r[i]] + h[b[i]];\n\t}\n}\n\nsigned main() {\n\tint n;\n\twhile (cin >> n,n) {\n\t\trep(i, n)h[i] = 0;\n\t\trep(i, n) {\n\t\t\tcin >> p[i] >> q[i] >> r[i] >> b[i];\n\t\t\tr[i]--; b[i]--;\n\t\t}\n\t\trep(i, n) {\n\t\t\tif (!h[i])heavy(i);\n\t\t}\n\t\tint ans = 0;\n\t\trep(i, n)ans = max(ans, h[i]);\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\ntemplate<class T>\nT gcd(T a, T b){\n  if(a > b) swap(a,b);\n  if(a == 0) return b;\n  return gcd(a, b%a);\n}\n\nint main(){\n  int n;\n  while(scanf(\"%d\",&n),n){\n    vector<pair<int,int> > bar(n+1);\n    vector<pair<int,int> > rat(n+1);\n\n    vector<ll> w(n+1);\n    vector<bool> flag(n+1,false); flag[0] = true;\n    vector<bool> dep(n+1, false);\n    REP(i,n){\n      int p,q,r,b;\n      scanf(\"%d%d%d%d\",&p,&q,&r,&b);\n      int g = gcd(p, q); p/=g; q/=g;\n      bar[i+1].f = r;\n      bar[i+1].s = b;\n      rat[i+1].f = p;\n      rat[i+1].s = q;\n      if(r == 0 && b == 0){\n        flag[i+1] = true;\n        w[i+1] = p+q;\n      }\n    }\n\n    bool f = true;\n    while(f){\n      f = false;\n      for(int i=1; i<n+1; i++){\n        if(!flag[i] && flag[bar[i].f] && flag[bar[i].s]){\n          int idx1 = bar[i].f;\n          int idx2 = bar[i].s;\n\n          int p = rat[i].f, q = rat[i].s;\n\n          f = true;\n          dep[idx1] = dep[idx2] = true;\n          flag[i] = true;\n\n          if(idx1 == 0){\n            w[i] = w[idx2]*(p+q);\n          }else if(idx2 == 0){\n            w[i] = w[idx1]*(p+q);\n          }else{\n            ll a = w[idx1];\n            ll b = w[idx2];\n            ll g = gcd(a,b);\n            w[i] = a*b/g*q + b*a/g*p;\n          }\n        }\n      }\n    }\n    ll ans = 0;\n    for(int i=1; i<n+1; i++)\n      if(!dep[i]) ans += w[i];\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<map>\n#include<vector>\n#include<cmath>\nusing namespace std;\ntypedef long long ll;\nint N;\nstruct edge{\n  ll p,q,r,b;\n  edge(){}\n  edge(ll p,ll q,ll r,ll b) : p(p),q(q),r(r),b(b) {}\n};\nedge E[102];\nint yukuri(ll n,ll m){\n  int tmp = max(n,m);\n  n = min(n,m);\n  m = tmp;\n  while( n > 0 ){\n    tmp = n;\n    n = m%n;\n    m = tmp;\n  }\n  return m;\n}\nll solve(ll id){\n  ll r,b;\n  if(E[id].r == 0)\n    r=1;\n  else\n    r=solve(E[id].r);\n  if(E[id].b == 0)\n    b=1;\n  else\n    b=solve(E[id].b);\n  ll tp = E[id].p * r * b;\n  ll tq = E[id].q * r * b;\n  tp /= b;\n  tq /= r;\n  ll n = yukuri(tp,tq);\n  tp/=n; tq/=n;\n  b*=tp; r*=tq;\n  return b+r;\n}\nint main(){\n  while(scanf(\"%d\",&N),N){\n    bool f[102];\n    memset(f,0,sizeof(f));\n    for(int i=1;i<=N;i++){\n      ll p,q,r,b;\n      scanf(\"%lld %lld %lld %lld\",&p,&q,&r,&b);\n      ll n = yukuri(p,q);\n      //      printf(\"%d %d %d\\n\",p,q,n);\n      p/=n;\n      q/=n;\n      E[i].p = p; E[i].q = q;\n      E[i].r = r; E[i].b = b;\n      f[r] = true; f[b] = true;\n    }\n    int id;\n    //    puts(\"ok\");\n    for(int i=1;i<=N;i++)\n      if(!f[i]) id = i;\n    printf(\"%lld\\n\",solve(id));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nlong long gcd(long long a, long long b){\n    while(b != 0){\n        long long tmp = a % b;\n        a = b;\n        b = tmp;\n    }\n    return a;\n}\n\nvector<int> p, q, a, b;\n\nlong long solve(int curr)\n{\n    if(curr == -1)\n        return 1;\n\n    long long x = solve(a[curr]);\n    long long y = solve(b[curr]);\n\n    long long g = gcd(x * p[curr], y * q[curr]);\n    return x * y * p[curr] / g + y * x * q[curr] / g;\n}\n\nint main()\n{\n    for(;;){\n        int n;\n        cin >> n;\n        if(n == 0)\n            return 0;\n\n        vector<bool> top(n, true);\n        p = q = a = b = vector<int>(n);\n        for(int i=0; i<n; ++i){\n            cin >> p[i] >> q[i] >> a[i] >> b[i];\n            -- a[i];\n            -- b[i];\n            if(a[i] >= 0)\n                top[a[i]] = false;\n            if(b[i] >= 0)\n                top[b[i]] = false;\n        }\n\n        long long ret = 0;\n        for(int i=0; i<n; ++i){\n            if(top[i])\n                ret += solve(i);\n        }\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint n, r[200], s[200], t[200], u[200], dp[200];\nlong long gcd(int a, int b) { if (b == 0)return a; return gcd(b, a%b); }\nlong long dfs(int p) {\n\tif (dp[p] >= 0)return dp[p];\n\tif (p == 0)return 1;\n\tlong long J1 = dfs(t[p]), J2 = dfs(u[p]);\n\tlong long m1 = s[p] * J1, m2 = r[p] * J2;\n\tlong long minx = 1LL << 62;\n\tfor (long long i = 1; i <= 200; i++) {\n\t\tfor (long long j = 1; j <= 200; j++) {\n\t\t\tlong long n1 = m1*i, n2 = m2*j;\n\t\t\tif (n1 == n2) { minx = min(minx, J1*i + J2*j); }\n\t\t}\n\t}\n\tdp[p] = minx;\n\treturn minx;\n}\nint main() {\n\twhile (cin >> n, n) {\n\t\tfor (int i = 0; i <= n; i++)dp[i] = -1;\n\t\tfor (int i = 1; i <= n; i++) { cin >> r[i] >> s[i] >> t[i] >> u[i]; int H = gcd(r[i], s[i]); r[i] /= H; s[i] /= H; }\n\t\tlong long maxn = 0; for (int i = 1; i <= n; i++)maxn = max(maxn, dfs(i));\n\t\tcout << maxn << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\nint gcd(int a, int b) {\n\tif (b == 0) {\n\t\treturn a;\n\t}\n\tint r = a % b;\n\treturn gcd(b, r);\n}\nint we(int wl, int wr, int lel, int ler) {\n\tint ml = wl * lel;\n\tint mr = wr * ler;\n\tint bil = mr / gcd(ml, mr);\n\tint bir = ml / gcd(ml, mr);\n\treturn (wl * bil)+(wr*bir);\n}\nint main(){\n\tint n;\n\tcin >> n;\n\twhile(n!=0){\n\tvector<int> w(n);\n\tvector<int> lel(n);\n\tvector<int> ler(n);\n\tvector<int> nul(n);\n\tvector<int> nur(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tint l, r;\n\t\tcin >> lel[i] >> ler[i] >> l >> r;\n\t\tl--; r--;\n\t\tnul[i] = l; nur[i] = r;\n\t}\n\tvector<int> d(n,n);\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tint x, y;\n\t\t\tif (nul[j] == -1) {\n\t\t\t\tx = -1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx = d[nul[j]];\n\t\t\t}\n\t\t\tif (nur[j] == -1) {\n\t\t\t\ty = -1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ty = d[nur[j]];\n\t\t\t}\n\t\t\td[j]=min(d[j], max(x, y)+1);\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (d[j] == i) {\n\t\t\t\tint wl, wr;\n\t\t\t\tint l = nul[j];\n\t\t\t\tint r = nur[j];\n\t\t\t\tif (l == -1) {\n\t\t\t\t\twl = 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\twl = w[l];\n\t\t\t\t}\n\t\t\t\tif (r == -1) {\n\t\t\t\t\twr = 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\twr = w[r];\n\t\t\t\t}\n\t\t\t\tw[j] = we(wl, wr, lel[j], ler[j]);\n\t\t\t\tans = max(ans, w[j]);\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\tcin >> n;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nll gcd(ll x, ll y)\n{    return y ? gcd(y, x % y) : x;\t}\n\nll lcm(ll x, ll y)\n{\treturn x * y / gcd(x, y);\t}\n\nint poles[128][4];\n\nint weight(int id)\n{\n\tint r = (poles[id][2] == 0 ? 1 : weight(poles[id][2]-1));\n\tint l = (poles[id][3] == 0 ? 1 : weight(poles[id][3]-1));\n\t\n\tint p = poles[id][0];\n\tint q = poles[id][1];\n\t\n\tint a = lcm(r*q, l*p) / q;\n\tint b = lcm(r*q, l*p) / p;\n\t\n\treturn a + b;\n}\n\nint main()\n{\n\tfor(int n; cin >> n && n;)\n\t{\n\t\tvint top(128, true);\n\t\t\n\t\trep(i, n)\n\t\t{\n\t\t\trep(j, 4) cin >> poles[i][j];\n\n\t\t\tif(poles[i][2])\ttop[poles[i][2]-1] = false;\n\t\t\tif(poles[i][3]) top[poles[i][3]-1] = false;\n\t\t}\n\t\t\n\t\trep(i, n) if(top[i]) cout << weight(i) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <cassert>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define vi vector<int>\n#define pb push_back\n#define INF 999999999\n#define int ll\n\nll gcd (ll a,ll b){\n\tif(a<b)swap(a,b);\n\tif(a%b==0)return b;\n\treturn gcd(b,a%b);\n}\n\nll lcm(ll a,ll b){\n\treturn a/gcd(a,b)*b;\n}\n\nstruct stick{\n\tint ld,rd,left,right;\n};\n\n\nvector<stick> data;\n\nint solve(int num){\n\t\n\tint lweight = 1,rweight = 1;\n\tif(data[num].left !=0) lweight = solve(data[num].left );\n\tif(data[num].right!=0) rweight = solve(data[num].right);\n\t\n\tint ledge = data[num].ld/gcd(data[num].ld,data[num].rd);\n\tint redge = data[num].rd/gcd(data[num].ld,data[num].rd);\n\t\n\tif(lweight==1 && rweight==1){\n\t\treturn ledge+redge;\n\t}\n\telse{\n\t\tint res = lcm(lweight*ledge,rweight*redge);\n\t\treturn res/ledge + res/redge;\n\t}\n}\n\n\nint getParent(int n){\n\tint par[200];\n\trep(i,200)par[i]=-1;\n\t\n\tfor(int i=1;i<=n;i++){\n\t\tif(data[i].left !=0) par[data[i].left ] = i;\n\t\tif(data[i].right!=0) par[data[i].right] = i;\n\t}\n\t\n\tfor(int i=1;i<=n;i++){\n\t\tif(par[i]==-1)return i;\n\t}\n\treturn -1;\n}\n\n\nsigned main(){\n\tint n;\n\twhile(cin>>n&&n){\n\t\tdata.clear();\n\t\tdata.pb(stick{-1,-1,-1,-1});\n\t\trep(i,n){\n\t\t\tint a,b,c,d;\n\t\t\tcin>>a>>b>>c>>d;\n\t\t\tdata.pb(stick{a,b,c,d});\n\t\t}\n\t\tint root = getParent(n);\n\t\t\n\t\tcout<<solve(root)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint n, r[200], s[200], t[200], u[200], dp[200];\nlong long gcd(int a, int b) { if (b == 0)return a; return gcd(b, a%b); }\nlong long dfs(int p) {\n\tif (dp[p] >= 0)return dp[p];\n\tif (p == 0)return 1;\n\tlong long J1 = dfs(t[p]), J2 = dfs(u[p]);\n\tlong long m1 = r[p] * J1, m2 = s[p] * J2;\n\tlong long r1 = m2 / gcd(m1, m2), r2 = m1 / gcd(m1, m2);\n\tlong long r3 = gcd(r1, r2); r1 /= r3; r2 /= r3;\n\tlong long minx = J1*r1 + J2*r2;\n\tdp[p] = minx;\n\treturn minx;\n}\nint main() {\n\twhile (cin >> n, n) {\n\t\tfor (int i = 0; i <= n; i++)dp[i] = -1;\n\t\tfor (int i = 1; i <= n; i++) { cin >> r[i] >> s[i] >> t[i] >> u[i]; int H = gcd(r[i], s[i]); r[i] /= H; s[i] /= H; }\n\t\tlong long maxn = 0; for (int i = 1; i <= n; i++)maxn = max(maxn, dfs(i));\n\t\tcout << maxn << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nll gcd(ll a, ll b) {\n  return b != 0 ? gcd(b, a % b) : a;\n}\nll lcm(ll a,ll b){\n  return a / gcd(a,b) * b;\n}\n\nconst ll WEIGHT=-1;\nstruct stick{\n\tll r,b,p,q;\n\tstick(ll r,ll b,ll p,ll q):r(r),b(b){\n\t\tll g=gcd(p,q);\n\t\tthis->p=p/g;\n\t\tthis->q=q/g;\n\t}\n\tll getroot(ll index,vector<stick> &sticks){\n\t\tREP(i,sticks.size()){\n\t\t\tif(sticks[i].r==index||sticks[i].b==index){\n\t\t\t\treturn sticks[i].getroot(i,sticks);\n\t\t\t}\n\t\t}\n\t\treturn index;\n\t}\n\tll go(vector<stick> &sticks){\n\t\tll rw=0,bw=0;\n\t\tif(r!=WEIGHT){\n\t\t\trw=sticks[r].go(sticks);\n\t\t}\n\t\tif(b!=WEIGHT){\n\t\t\tbw=sticks[b].go(sticks);\n\t\t}\n\t\tif(r==WEIGHT&&b==WEIGHT){\n\t\t\trw=q;\n\t\t\tbw=p;\n\t\t}else if(r==WEIGHT){\n\t\t\tif(p*bw%q){\n\t\t\t\trw=bw*p;\n\t\t\t\tbw*=q;\n\t\t\t\tcerr<<rw<<\",\"<<bw<<endl;\n\t\t\t}else{\n\t\t\t\trw=bw*p/q;\n\t\t\t\tassert(bw);\n\t\t\t}\n\t\t}else if(b==WEIGHT){\n\t\t\tif(q*rw%p){\n\t\t\t\tbw=rw*q;\n\t\t\t\trw*=p;\n\t\t\t\tcerr<<rw<<\",\"<<bw<<endl;\n\t\t\t}else{\n\t\t\t\tbw=rw*q/p;\n\t\t\t\tassert(rw);\n\t\t\t}\n\t\t}else{\n\t\t\tll l = lcm(p * rw, q * bw);\n\t\t\trw=l/p;\n\t\t\tbw=l/q;\n\t\t\tassert(rw);\n\t\t\tassert(bw);\n\t\t}\n\t\tassert(rw&&bw);\n\t\treturn rw+bw;\n\t}\n};\n\n\nint main(){\n\tll n;\n\twhile(cin>>n,n){\n\t\tvector<stick> sticks;\n\t\tREP(i,n){\n\t\t\tll p,q,r,b;\n\t\t\tcin>>p>>q>>r>>b;\n\t\t\tr--;b--;\n\t\t\tsticks.push_back(stick(r,b,p,q));\n\t\t}\n\t\tll root=sticks[0].getroot(0,sticks);\n\t\tcout<<sticks[root].go(sticks)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nlong long gcd(long long a, long long b){ // Ååöñ\n    if(a == 0 || b == 0)\n        return 0;\n    if(b > a)\n        swap(a, b);\n    long long tmp;\n    while((tmp = a % b) != 0){\n        a = b;\n        b = tmp;\n    }\n    return b;\n}\n\nlong long lcm(long long a, long long b){ // Å¬ö{\n    return a / gcd(a, b) * b;\n}\n\nlong long solve(vector<vector<int> >& stick, int i)\n{\n    if(i == 0)\n        return 1;\n\n    long long p = stick[i][0];\n    long long q = stick[i][1];\n\n    long long a = solve(stick, stick[i][2]);\n    long long b = solve(stick, stick[i][3]);\n    long long tmp = lcm(q*a, p*b);\n    a = tmp / q;\n    b = tmp / p;\n\n    return a + b;\n}\n\nint main()\n{\n    for(;;){\n        int n;\n        cin >> n;\n        if(n == 0)\n            return 0;\n\n        vector<vector<int> > stick(n+1, vector<int>(4));\n        vector<bool> check(n+1, false);\n        for(int i=1; i<=n; ++i){\n            for(int j=0; j<4; ++j){\n                cin >> stick[i][j];\n            }\n            check[stick[i][2]] = check[stick[i][3]] = true;\n        }\n\n        long long ret = 0;\n        for(int i=1; i<=n; ++i){\n            if(!check[i])\n                ret += solve(stick, i);\n        }\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <climits>\n#include <vector>\nusing namespace std;\n\nint gcd(int x, int y) {\n    while(y) {\n        int t=x%y;x=y;y=t;\n    }\n    return x;\n}\n\nint ps[100],qs[100],rs[100],bs[100], memo[100];\n\nint calc(int i) {\n    if(i==-1) return 1;\n    if(memo[i]>=0) return memo[i];\n    int r = calc(rs[i]);\n    int b = calc(bs[i]);\n    int p = ps[i];\n    int q = qs[i];\n    int left_factor = r*q; // b*left_factor\n    int right_factor = b*p; // r*right_factor\n    int fgcd = gcd(left_factor, right_factor);\n    left_factor /= fgcd;\n    right_factor /= fgcd;\n    memo[i] = b*left_factor + r*right_factor;\n    return memo[i];\n}\n\nint main() {\n    while(true) {\n        int n; scanf(\"%d\", &n);\n        if(n==0) break;\n        fill(memo, memo+n, -1);\n        for(int i = 0; i < n; i++) {\n            scanf(\"%d%d%d%d\", ps+i, qs+i, rs+i, bs+i);\n            rs[i]--; bs[i]--;\n        }\n        int max_val = 0;\n        for(int i = 0; i < n; i++) {\n            max_val = max(max_val, calc(i));\n        }\n        printf(\"%d\\n\", max_val);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\n\ntypedef long long ll;\ntypedef struct stick{\n ll lren, rren, sl, sr, weight; \n} STICK;\n\nll n, tmp, top;\nll depth[101];\nSTICK st[101];\n\nvoid init(ll k){\n for(ll i = 0; i <= k; i++){\n  depth[i] = 0;\n  st[i].weight = 0;\n }\n}\n\nll gcd(ll a, ll b){\n if(b == 0) return a;\n return gcd(b, a % b);\n}\n\nll lcm(ll a, ll b){\n return a * b / gcd(a, b);\n}\n\nll solve(ll k){\n if(st[k].weight > 0) return st[k].weight;\n if(st[k].sl == 0 && st[k].sr == 0){\n  return st[k].weight = st[k].lren + st[k].rren;\n }else if(st[k].sl == 0){\n  return st[k].weight = solve(st[k].sr) * (st[k].lren + st[k].rren) / gcd(solve(st[k].sr), st[k].lren);\n }else if(st[k]. sr == 0){\n  return st[k].weight = solve(st[k].sl) * (st[k].lren + st[k].rren) / gcd(solve(st[k].sl), st[k].rren);\n }else {\n  tmp = lcm(solve(st[k].sl) * st[k].lren, solve(st[k].sr) * st[k].rren);\n  return st[k].weight = tmp / st[k].lren + tmp / st[k].rren;\n }\n}\n\nint main(){\n while(scanf(\"%d\", &n)){\n  if(n == 0) break;\n  init(n);\n  for(ll i = 1; i <= n; i++){\n   scanf(\"%d %d %d %d\", &st[i].lren, &st[i].rren, &st[i].sl, &st[i].sr);\n   tmp = gcd(st[i].lren, st[i].rren);\n   st[i].lren /= tmp;\n   st[i].rren /= tmp;\n  }\n  for(ll i = 1; i <= n; i++){\n   depth[st[i].sl]++;\n   depth[st[i].sr]++;\n  }\n  for(ll i = 1; i<= n; i++){\n   if(depth[i] == 0){\n    top = i;\n    break;\n   }\n  }\n  printf(\"%d\\n\", solve(top));\n }\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<cstring>\n#define max(a,b) (a>b?a:b)\nlong long int a[101],b[101],c[101],d[101],memo[101],res=0;\n\nlong long int gcd(long long int x,long long int y){\n\tif(x==0)return y;\n\telse return gcd(y%x,x);\n}\nlong long int solve(int x){\n\tif(memo[x]!=0)return memo[x];\n\tint left=a[x]*solve(c[x]),right=b[x]*solve(d[x]),gc;\n\tgc=gcd(left,right);\n\treturn memo[x]=right/gc*solve(c[x])+left/gc*solve(d[x]);\n}\n\nint main(){\n\tint n;\n\tfor(;scanf(\"%d\",&n),n!=0;memset(memo,0,sizeof(memo))){\n\t\tmemo[0]=1;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tscanf(\"%lld%lld%lld%lld\",a+i,b+i,c+i,d+i);\n\t\t}\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tres=max(res,solve(i));\n\t\t}\n\t\tprintf(\"%lld\\n\",res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint n, r[200], s[200], t[200], u[200], dp[200];\nlong long gcd(int a, int b) { if (b == 0)return a; return gcd(b, a%b); }\nlong long dfs(int p) {\n\tif (dp[p] >= 0)return dp[p];\n\tif (p == 0)return 1;\n\tlong long J1 = dfs(t[p]), J2 = dfs(u[p]);\n\tlong long m1 = s[p] * J1, m2 = r[p] * J2;\n\tlong long r1 = m2 / gcd(m1, m2), r2 = m1 / gcd(m1, m2);\n\tlong long r3 = gcd(r1, r2); r1 /= r3; r2 /= r3;\n\tlong long minx = J1*r1 + J2*r2;\n\tdp[p] = minx;\n\treturn minx;\n}\nint main() {\n\twhile (cin >> n, n) {\n\t\tfor (int i = 0; i <= n; i++)dp[i] = -1;\n\t\tfor (int i = 1; i <= n; i++) { cin >> r[i] >> s[i] >> t[i] >> u[i]; int H = gcd(r[i], s[i]); r[i] /= H; s[i] /= H; }\n\t\tlong long maxn = 0; for (int i = 1; i <= n; i++)maxn = max(maxn, dfs(i));\n\t\tcout << maxn << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nint N;\nint P[128],Q[128],R[128],B[128];\n\nint rec(int v){\n  int p = P[v], q = Q[v], r = R[v], b = B[v];\n  int rw=1, bw=1;\n  if(r) rw = rec(r);\n  if(b) bw = rec(b);\n  int rx = p*rw, bx = q*bw;\n  int lcm = rx/__gcd(rx,bx)*bx;\n  return lcm/rx*rw+lcm/bx*bw;\n}\n\nint main(){\n  while(scanf(\"%d\", &N) && N){\n    int par[128]={};\n    for(int i=1;i<=N;i++){\n      scanf(\"%d%d%d%d\",&P[i], &Q[i], &R[i], &B[i]);\n      par[R[i]] = 1;\n      par[B[i]] = 1;\n    }\n    int s;\n    for(int i=1;i<=N;i++) if(!par[i]) s = i;\n    printf(\"%d\\n\", rec(s));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\n#define REP(i,a,b) for(i=a; i<b; ++i)\n#define rep(i,n) REP(i,0,n)\n\nstruct mobile {\n  int lm,rm;\n  int lc,rc,ll,rl;\n  mobile() {;}\n  mobile(int lc,int rc,int ll,int rl) : lc(lc), rc(rc), ll(ll), rl(rl) {\n    lm = rm = -1;\n  }\n};\n\nint gcd(int a,int b) {\n  return b != 0 ? gcd(b, a%b) : a;\n}\n\nint lcm(int a,int b) {\n  return a*b/gcd(a,b);\n}\n\nint dfs(int pos,vector<mobile> &vm) {\n  //cout<<\"now \"<<pos<<endl;\n  mobile now = vm[pos];\n  //cout<<\"    \"<<now.lc<<\" : \"<<now.rc<<endl;\n\n  if(now.lc < 0 && now.rc < 0) {\n    //cout<<\"lets calc\"<<endl;\n    int g = lcm(now.ll,now.rl);\n    now.lm = g/now.ll;\n    now.rm = g/now.rl;\n    //cout<<pos<<\" : \"<<now.ll<<\" \"<<now.rl<<\" -> \"<<g<<\" \"<<now.lm+now.rm<<endl;\n    return now.lm+now.rm;\n  }\n  if(now.lc != -1) now.lm = dfs(now.lc,vm);\n  if(now.rc != -1) now.rm = dfs(now.rc,vm);\n  if(now.lm == -1) now.lm = now.rm*now.rl/now.ll;\n  if(now.rm == -1) now.rm = now.lm*now.ll/now.rl;\n  if(now.lm*now.ll != now.rm*now.rl) {\n    //cout<<\"unbalance!!\"<<endl;\n    int g = lcm(now.lm*now.ll,now.rm*now.rl);\n    now.lm *= g/(now.lm*now.ll);\n    now.rm *= g/(now.rm*now.rl);\n    //if(now.lm*now.ll != now.rm*now.rl) cout<<\"Nooooooooooooooooooooo\"<<endl;\n  }\n  //cout<<pos<<\" \"<<now.lm<<\" \"<<now.rm<<endl;\n  return now.rm+now.lm;\n}\n\nint main() {\n  int n,i,p,q,r,b;\n  while(cin>>n, n) {\n    vector<mobile> vm;\n    vector<bool> isroot(n,true);\n    rep(i,n) {\n      cin>>p>>q>>r>>b;\n      r--,b--;\n      if(r >= 0) isroot[r] = false;\n      if(b >= 0) isroot[b] = false;\n      vm.push_back(mobile(r,b,p,q));\n    }\n\n    int root = -1;\n    rep(i,n) if(isroot[i] == true) root = i;\n\n    cout<<dfs(root,vm)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef pair<int,int> P;\n#define pb push_back\n#define INF 1e9\nint n;\nint main(){\n\twhile(1){\n\t\tint lcm[105]={};\n\tvector<int> son[105];\n\tP stick[105];\n\tbool decide[105]={};\n\tbool beleft[105]={},beright[105]={};\n\tscanf(\"%d\",&n);\n\tif(!n) break;\n\tfor(int q=1;q<=n;q++){\n\t\tint a,b,c,d;\n\t\tscanf(\"%d %d %d %d\",&a,&b,&c,&d);\n\t\tif(c){\n\t\t\tson[q].pb(c);\n\t\t\tbeleft[q]=true;\n\t\t}\n\t\tif(d){\n\t\t\tson[q].pb(d);\n\t\t\tberight[q]=true;\n\t\t}\n\t\tint rp;\n\t\tfor(int i=min(a,b);i>=1;i--){\n\t\t\tif(a%i==0 && b%i==0){\n\t\t\t\trp=((a/i)+(b/i));\n\t\t\t\tstick[q]=make_pair(a/i,b/i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tlcm[q]=rp;\n\t\tif(son[q].size()==0){\n\t\t\tdecide[q]=true;\n\t\t}\n\t}\n\tint last=1;\n\twhile(1){\n\t\tbool p=false;\n\tfor(int i=1;i<=n;i++){\n\t\tif(son[i].size()!=0 && !decide[i]){\n\t\t\tint cou=0;\n\t\t\tfor(int j=0;j<son[i].size();j++){\n\t\t\t\tif(decide[son[i][j]]){\n\t\t\t\t\tcou++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(cou==son[i].size()){\n\t\t\t\t\tint maxi1=0,maxi2=0;\n\t\t\t\t\tif(beleft[i]){\n\t\t\t\t\t\tfor(int g=min(stick[i].second,lcm[son[i][0]]);g>=1;g--){\n\t\t\t\t\t\t\tif(stick[i].second%g==0 && lcm[son[i][0]]%g==0){\n\t\t\t\t\t\t\t\tmaxi1=(lcm[son[i][0]]/g*(stick[i].first+stick[i].second));\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(beright[i]){\n\t\t\t\t\t\tfor(int g=min(stick[i].first,lcm[son[i][son[i].size()-1]]);g>=1;g--){\n\t\t\t\t\t\t\tif(stick[i].first%g==0 && lcm[son[i][son[i].size()-1]]%g==0){\n\t\t\t\t\t\t\t\tmaxi2=lcm[son[i][son[i].size()-1]]/g*(stick[i].first+stick[i].second);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(maxi1 && !maxi2){\n\t\t\t\t\t\tlcm[i]=maxi1;\n\t\t\t\t\t}else if(!maxi1 && maxi2){\n\t\t\t\t\t\tlcm[i]=maxi2;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfor(int q=min(maxi1,maxi2);q>=1;q--){\n\t\t\t\t\t\t\tif(maxi1%q==0 && maxi2%q==0){\n\t\t\t\t\t\t\t\tlcm[i]=maxi1*maxi2/q;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tdecide[i]=true;\n\t\t\t\t\tlast=i;\n\t\t\t\t\tp=true;\n\t\t\t}\n\t\t}\n\t}\n\tif(!p){\n\t\tbreak;\n\t}\n\t}\n\tprintf(\"%d\\n\",lcm[last]);\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nint memo[110];\n\nint a[110];\nint b[110];\nint l[110];\nint r[110];\n\nint gcd(int a,int b){\n\tif(b==0)\n\t\treturn a;\n\telse\n\t\treturn gcd(b,a%b);\n}\n\nint lcm(int a,int b){\n\tint g=gcd(a,b);\n\treturn a/g*b;\n}\n\nint rec(int i){\n\tif(memo[i]>=0)\n\t\treturn memo[i];\n\tint aa=a[i]*rec(l[i]);\n\tint bb=b[i]*rec(r[i]);\n\tint gg=gcd(aa,bb);\n\taa/=gg;\n\tbb/=gg;\n\treturn memo[i]=rec(l[i])*bb+rec(r[i])*aa;\n}\n\nint main(void){\n\tint n;\n\twhile(cin >> n,n){\n\t\tfor(int i=1;i<=n;++i) cin >> a[i] >> b[i] >> l[i] >> r[i];\n\t\tmemo[0]=1;\n\t\tfor(int i=1;i<=n;++i) memo[i]=-1;\n\n\t\tint ans=0;\n\t\tfor(int i=1;i<=n;++i) ans=max(ans,rec(i));\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <cstring>\nusing namespace std;\n\nint dp[110],K[110],O[110],L[110],R[110];\n\nint gcd(int a,int b){\n\tint tmp;\n\tif(a<b) swap(a,b);\n\twhile((tmp=a%b)!=0){\n\t\ta=b;\n\t\tb=tmp;\n\t}\n\treturn b;\n}\n\n\nint mobi(int bou){\n\tif(bou==0) return 1;\n\tif(dp[bou]!=0) return dp[bou];\n\tint l,r,li,ri,gc2,a,b;\n\tl=mobi(L[bou]);\n\tr=mobi(R[bou]);\n\tri=K[bou];li=O[bou];\n\tgc2=gcd(li*l,ri*r);\n\tb=li*l/gc2;\n\ta=ri*r/gc2;\n\tdp[bou]=(a*l+b*r);\n\treturn dp[bou];\n}\n\nint main(){\n\tint N,k,o,g;\n\tint res;\n\twhile(1){\n\t\tcin>>N;\n\t\tif(N==0) break;\n\t\tmemset(dp,0,sizeof(dp));\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tcin>>k>>o>>L[i]>>R[i];\n\t\t\tg=gcd(k,o);\n\t\t\tK[i]=k/g;\n\t\t\tO[i]=o/g;\n\t\t}\n\t\tres=0;\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tres=max(res,mobi(i));\n\t\t}\n\t\twhile(true);//\n\t\t/*\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tcout<<i<<\" \"<<dp[i]<<endl;//\n\t\t}\n\t\t*/\n\t\tcout<<res<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int long long\nint n;\nint p[128], q[128], r[128], b[128];\n\nint m[128];\n\nint re(int i)\n{\n  if (m[i] != -1) return m[i];\n  if (i == 0) {\n    return 1;\n  }\n\n  int x = re(r[i]);\n  int y = re(b[i]);\n\n  int red = x * p[i];\n  int blu = y * q[i];\n\n  int gcd = __gcd(red, blu);\n  int lcm = red * blu / gcd;\n\n  m[i] = (lcm / p[i]) + (lcm / q[i]);\n  return m[i];\n}\n\nsigned main()\n{\n  while (cin >> n, n){\n    for (int i = 1; i <= n; i++){\n      cin >> p[i] >> q[i] >> r[i] >> b[i];\n    }\n\n    memset(m, -1, sizeof(m));\n\n    int max_ = -1;\n    for (int i = 1; i <= n; i++){\n      max_ = max(max_, re(i));\n    }\n\n    cout << max_ << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\nusing namespace std;\nstatic const int INF = 1ll<<60;\ntypedef pair<int,int> pii;\n\nstruct P{\n    double p;\n    double q;\n    int r;\n    int b;\n    P(){}\n    P(double p1,double p2,int p3,int p4){\n        p=p1;\n        q=p2;\n        r=p3;\n        b=p4;\n    }\n};\n\nint N;\ndouble R,B;\nvector<P> S;\nbool cone[110];\n\nint GCD(int a,int b){\n    return b?GCD(b,a%b):a;\n}\n\nint LCM(int a,int b){\n    return a*b/GCD(max(a,b),min(a,b));\n}\n\nint dfs(int n){\n    if(n==-1)return 1;\n    int R = dfs(S[n].r)*S[n].p;\n    int B = dfs(S[n].b)*S[n].q;\n    int lcm = LCM(R,B);\n    return lcm/S[n].p+lcm/S[n].q;\n}\n\nsigned main(){\n    while(1){\n        cin>>N;\n        if(N==0)break;\n        for(int i=0;i<N;++i){\n            int p,q,r,b;\n            cin>>p>>q>>r>>b;\n            r--;\n            b--;\n            cone[r]=true;\n            cone[b]=true;\n            S.PB(P(p,q,r,b));\n        }\n        for(int i=0;i<N;++i){\n            if(!cone[i]){\n                cout<<dfs(i)<<endl;\n                break;\n            }\n        }\n        S.clear();\n        memset(cone,0,sizeof(cone));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<typename T1,typename T2> void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  while(cin>>n,n){\n    vector<Int> p(n),q(n),r(n),s(n);\n    for(Int i=0;i<n;i++) cin>>p[i]>>q[i]>>r[i]>>s[i];\n    for(Int i=0;i<n;i++) r[i]--,s[i]--;\n\n    vector<Int> dp(n,-1);\n    function<Int(Int)> dfs=[&](Int x){\n      Int &res=dp[x];\n      if(~res) return res;\n      Int a=(~r[x]?dfs(r[x]):Int(1))*q[x];\n      Int b=(~s[x]?dfs(s[x]):Int(1))*p[x];\n      Int k=a/__gcd(a,b)*b;\n      return res=k/q[x]+k/p[x];\n    };\n    \n    Int ans=0;\n    for(Int i=0;i<n;i++) chmax(ans,dfs(i));\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nlong long gcd(long long a, long long b){\n    while(b != 0){\n        long long tmp = a % b;\n        a = b;\n        b = tmp;\n    }\n    return a;\n}\n\nvector<int> p, q, a, b;\n\nlong long solve(int curr)\n{\n    if(curr == -1)\n        return 1;\n\n    long long x = solve(a[curr]);\n    long long y = solve(b[curr]);\n\n    long long g = gcd(x * p[curr], y * q[curr]);\n    return x * y * p[curr] / g + y * x * q[curr] / g;\n}\n\nint main()\n{\n    for(;;){\n        int n;\n        cin >> n;\n        if(n == 0)\n            return 0;\n\n        vector<bool> top(n, true);\n        p = q = a = b = vector<int>(n);\n        for(int i=0; i<n; ++i){\n            cin >> p[i] >> q[i] >> a[i] >> b[i];\n            -- a[i];\n            -- b[i];\n            if(a[i] >= 0)\n                top[a[i]] = false;\n            if(b[i] >= 0)\n                top[b[i]] = false;\n        }\n\n        long long ret = 0;\n        for(int i=0; i<n; ++i){\n            if(top[i])\n                ret += solve(i);\n        }\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nll gcd(ll x, ll y)\n{    return y ? gcd(y, x % y) : x;\t}\n\nll lcm(ll x, ll y)\n{\treturn x * y / gcd(x, y);\t}\n\nclass Q\n{\npublic:\n\tint d, n;\n\t\n\tQ() : d(0), n(0) { }\n\tQ(int d, int n) : d(d), n(n) { }\n\t\n\tQ operator + (Q x)\n\t{\n\t\tif(d == 0 || n == 0) return x;\n\t\tif(x.d == 0 || x.n == 0) return *this;\n\t\treturn Q(d * x.n + n * x.d, n * x.n).reduce();\n\t}\n\t\n\tQ operator - (Q x)\n\t{\n\t\tif(d == 0 || n == 0) return x;\n\t\tif(x.d == 0 || x.n == 0) return *this;\n\t\treturn Q(d * x.n - n * x.d, n * x.n).reduce();\n\t}\n\n\tQ operator * (int x)\n\t{\treturn Q(d * x, n).reduce();\t}\n\t\n\tQ operator / (int x)\n\t{\treturn Q(d, n * x).reduce();\t}\n\t\n\tQ operator += (Q x)\n\t{\treturn (*this) = (*this) + x;\t}\n\t\n\tQ operator -= (Q x)\n\t{\treturn (*this) = (*this) - x;\t}\n\t\n\tQ reduce()\n\t{\n\t\tll gd = gcd(d, n);\n\t\t\n\t\treturn d == 0 || n == 0 ? Q(0, 0) : Q(d / gd, n / gd);\n\t}\n\t\n\tQ reciprocal()\n\t{\treturn Q(n, d);\t}\n};\n\nstruct Mobile\n{\n\tint p, q, r, b;\n\t\n\tvoid divid(vector<Mobile>& mobiles, vector<Q>& qs, Q x)\n\t{\n\t\tQ rw = x * p / (p + q), bw = x * q / (p + q);\n\t\t\n\t\tif(r == 0)\tqs.push_back(rw);\n\t\telse\t\tmobiles[r - 1].divid(mobiles, qs, rw);\n\t\t\n\t\tif(b == 0)\tqs.push_back(bw);\n\t\telse\t\tmobiles[b - 1].divid(mobiles, qs, bw);\n\t}\n};\n\nint main()\n{\n    int n;\n\twhile( cin >> n && n )\n\t{\t\t\n\t\tvector<Mobile> mobiles(n);\n\t\tvector<bool> flags(n, false);\n\n\t\trep(i, n)\n\t\t{\n\t\t\tcin >> mobiles[i].p >> mobiles[i].q >> mobiles[i].r >> mobiles[i].b;\n\t\t\t\n\t\t\tif(mobiles[i].r != 0) flags[mobiles[i].r - 1] = true;\n\t\t\tif(mobiles[i].b != 0) flags[mobiles[i].b - 1] = true;\n\t\t}\n\t\t\n\t\tvector<Q> qs;\n\t\tmobiles[min_element(ALL(flags)) - flags.begin()].divid(mobiles, qs, Q(1, 1));\n\t\t\n\t\tint lm = qs[0].n, res = 0;\n\t\t\n\t\tREP(i, 1, qs.size()) lm = lcm(lm, qs[i].n);\n\t\t\n\t\trep(i, qs.size()) res += (qs[i] * lm).d;\n\t\t\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nll p[100], q[100], r[100], b[100];\nll memo[100];\nll dfs(int k){\n  if(k == 0) return 1;\n  k --;\n  if(memo[k] != -1) return memo[k];\n  ll A = dfs(r[k]);\n  ll B = dfs(b[k]);\n  A *= p[k];\n  B *= q[k];\n  ll G = __gcd(A, B);\n  ll L = A * B / G;\n  return memo[k] = L / p[k] + L / q[k];\n}\n\nint main(){\n  int n;\n  while(cin >> n && n){\n    REP(i, n) cin >> p[i] >> q[i] >> r[i] >> b[i];\n    ll ans = 0;\n    memset(memo, -1, sizeof memo);\n    REP(i, n){\n      ans = max(ans, dfs(i + 1));\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\nlong long depth[500];\nlong long w[500][2];\nlong long x[500][2];\nlong long n, root, v[500], a, A, B, C;\npair<long long, long long>DEPTH[500];\nlong long mobile[500][2];\n\nlong long gcd(long long p, long long q) {\n\tlong long P = p, Q = q;\n\twhile (true) {\n\t\tif (P%Q == 0) { return Q; }\n\t\tif (Q%P == 0) { return P; }\n\t\tif (P > Q) { P = P%Q; }\n\t\telse { Q = Q%P; }\n\t}\n}\n\nint main() {\n\twhile (true) {\n\t\tmemset(depth, 0, sizeof(depth));\n\t\tmemset(w, 0, sizeof(w));\n\t\tmemset(x, 0, sizeof(x));\n\t\tmemset(v, 0, sizeof(v));\n\t\tmemset(DEPTH, 0, sizeof(DEPTH));\n\t\tmemset(mobile, 0, sizeof(mobile));\n\t\troot = 0; n = 0; A = 0; B = 0; C = 0; a = 0;\n\t\tcin >> n;\n\t\tif (n == 0) { break; }\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tv[i] = 0;\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tcin >> w[i][0] >> w[i][1] >> x[i][0] >> x[i][1];\n\t\t\tv[x[i][0]] = 1; v[x[i][1]] = 1;\n\t\t\ta = gcd(w[i][0], w[i][1]);\n\t\t\tw[i][0] /= a; w[i][1] /= a;\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (v[i] == 0) {\n\t\t\t\troot = i;\n\t\t\t}\n\t\t}\n\t\t//depth.\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tdepth[i] = 1000;\n\t\t}\n\t\tdepth[root] = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tif (depth[j] != 1000) {\n\t\t\t\t\tdepth[x[j][0]] = min(depth[x[j][0]], depth[j] + 1);\n\t\t\t\t\tdepth[x[j][1]] = min(depth[x[j][1]], depth[j] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tDEPTH[i - 1].first = depth[i];\n\t\t\tDEPTH[i - 1].second = i;\n\t\t}\n\t\tsort(DEPTH, DEPTH + n);\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tA = DEPTH[i].first;\n\t\t\tB = DEPTH[i].second;\n\t\t\tif (x[B][0] == 0 && x[B][1] == 0) {\n\t\t\t\tmobile[B][0] = w[B][1];\n\t\t\t\tmobile[B][1] = w[B][0];\n\t\t\t}\n\t\t\tif (x[B][0] == 0 && x[B][1] >= 1) {\n\t\t\t\tmobile[B][1] = mobile[x[B][1]][0] + mobile[x[B][1]][1];\n\t\t\t\tmobile[B][1] = mobile[B][1] * w[B][0] / gcd(mobile[B][1], w[B][0]);\n\t\t\t\tmobile[B][0] = mobile[B][1] * w[B][1] / w[B][0];\n\t\t\t}\n\t\t\tif (x[B][0] >= 1 && x[B][1] == 0) {\n\t\t\t\tmobile[B][0] = mobile[x[B][0]][0] + mobile[x[B][0]][1];\n\t\t\t\tmobile[B][0] = mobile[B][0] * w[B][1] / gcd(mobile[B][0], w[B][1]);\n\t\t\t\tmobile[B][1] = mobile[B][0] * w[B][0] / w[B][1];\n\t\t\t}\n\t\t\tif (x[B][0] >= 1 && x[B][1] >= 1) {\n\t\t\t\tmobile[B][0] = mobile[x[B][0]][0] + mobile[x[B][0]][1];\n\t\t\t\tmobile[B][1] = mobile[x[B][1]][0] + mobile[x[B][1]][1];\n\t\t\t\tC = mobile[B][0] * w[B][0] * mobile[B][1] * w[B][1] / gcd(mobile[B][0] * w[B][0], mobile[B][1] * w[B][1]);\n\t\t\t\tmobile[B][0] = C / w[B][0];\n\t\t\t\tmobile[B][1] = C / w[B][0];\n\t\t\t}\n\t\t}\n\t\tcout << mobile[root][0] + mobile[root][1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\n#define REP(i,a,b) for(i=a; i<b; ++i)\n#define rep(i,n) REP(i,0,n)\n\nstruct mobile {\n  long long lm,rm;\n  long long lc,rc,ll,rl;\n  mobile(long long lc,long long rc,long long ll,long long rl)\n  : lc(lc), rc(rc), ll(ll), rl(rl) {\n    lm = rm = -1;\n  }\n};\n\nint gcd(int a,int b) {\n  return b != 0 ? gcd(b, a%b) : a;\n}\n\nlong long lcm(long long a,long long b) {\n  return a/gcd(a,b)*b;\n}\n\nint dfs(int pos,vector<mobile> &vm) {\n  mobile now = vm[pos];\n  now.lm = (now.lc == -1) ? 1 : dfs(now.lc,vm);\n  now.rm = (now.rc == -1) ? 1 : dfs(now.rc,vm);\n  int g = lcm(now.ll*now.lm, now.rl*now.rm);\n  now.rm = g / now.rl;\n  now.lm = g / now.ll;\n  return now.rm+now.lm;\n}\n\nint main() {\n  int n,i,p,q,r,b,root;\n  while(cin>>n, n) {\n    vector<mobile> vm;\n    vector<bool> isroot(n+1,true);\n    root = -1;\n    rep(i,n) {\n      cin>>p>>q>>r>>b;\n      isroot[r] = isroot[b] = false;\n      r--,b--;\n      vm.push_back(mobile(r,b,p,q));\n    }\n\n    rep(i,n) if(isroot[i] == true) root = i-1;\n    cout<<dfs(root,vm)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nint gcd(int a, int b){\n\tif(b == 0)return a;\n\treturn gcd(b, a%b);\n}\n\nstruct Pole{\n\tint left, right;\n\tPole *red, *blue, *rred, *rblue;\n};\n\n// 中和をとった時の重さを返す\nint trace(Pole pole){\n\tint red_w, blue_w;\n\tif(pole.red == nullptr && pole.blue == nullptr){\n\t\tred_w = pole.right;\n\t\tblue_w = pole.left;\n\t}else if(pole.red != nullptr && pole.blue != nullptr){\n\t\tred_w = trace(*pole.red);\n\t\tblue_w = trace(*pole.blue);\n\n\t\tint g = gcd(pole.left * red_w, pole.right * blue_w),\n\t\t\t_red_w = red_w;\n\t\tred_w = pole.right * blue_w / g * _red_w;\n\t\tblue_w = pole.left * _red_w / g * blue_w;\n\t}else{\n\t\tif(pole.red == nullptr){\n\t\t\tstd::swap(pole.red, pole.blue);\n\t\t\tstd::swap(pole.left, pole.right);\n\t\t}\n\n\t\tint _red_w = trace(*pole.red),\n\t\t\tg = gcd(pole.left * _red_w, pole.right);\n\t\t\t\n\t\tred_w = pole.right / g * _red_w;\n\t\tblue_w = pole.left * _red_w / g;\n\t}\n\n\t//std::cout << pole.left << \",\" << pole.right << \":\" << red_w << \",\" << blue_w << std::endl;\n\treturn red_w + blue_w;\n}\n\nint main(){\n\tint n;\n\tstd::cin >> n;\n\t\tPole ps[100];\n\n\t\tfor(int i=0;i<100;i++){\n\t\t\tps[i].red = nullptr;\n\t\t\tps[i].blue = nullptr;\n\t\t\tps[i].rred = nullptr;\n\t\t\tps[i].rblue = nullptr;\n\t\t\tps[i].left = 0;\n\t\t\tps[i].right = 0;\n\t\t}\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint p, q, r, b;\n\t\t\tstd::cin >> p >> q >> r >> b;\n\t\t\tr--;b--;\n\n\t\t\tint g = gcd(p, q);\n\t\t\tps[i].left = p / g;\n\t\t\tps[i].right = q / g;\n\n\t\t\tif(r != -1){\n\t\t\t\tps[i].red = &ps[r];\n\t\t\t\tps[r].rred = &ps[i];\n\t\t\t}\n\t\t\n\t\t\tif(b != -1){\n\t\t\t\tps[i].blue = &ps[b];\n\t\t\t\tps[b].rblue = &ps[i];\n\t\t\t}\n\t\t}\n\t\n\t\tint parent = 0;\n\t\t{\n\t\t\tPole *p = &ps[0];\n\t\t\twhile(p->rred != nullptr || p->rblue != nullptr){\n\t\t\t\tif(p->rred != nullptr){//実は一意(普通)\n\t\t\t\t\tp = p->rred;\n\t\t\t\t}else{\n\t\t\t\t\tp = p->rblue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tparent = p - &ps[0];\n\t\t}\n\n\t\tstd::cout << trace(ps[parent]) << std::endl;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nint p[128], q[128], r[128], b[128];\n\nint m[128];\n\nint re(int i)\n{\n  if (m[i] != -1) return m[i];\n  if (i == 0) {\n    return 1;\n  }\n\n  int x = re(r[i]);\n  int y = re(b[i]);\n\n  int red = x * p[i];\n  int blu = y * q[i];\n\n  int gcd = __gcd(red, blu);\n  int lcm = red * blu / gcd;\n\n  m[i] = (lcm / p[i]) + (lcm / q[i]);\n  return m[i];\n}\n\nint main()\n{\n  while (cin >> n, n){\n    for (int i = 1; i <= n; i++){\n      cin >> p[i] >> q[i] >> r[i] >> b[i];\n    }\n\n    memset(m, -1, sizeof(m));\n\n    int max_ = -1;\n    for (int i = 1; i <= n; i++){\n      max_ = max(max_, re(i));\n    }\n\n    cout << max_ << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n\ntemplate <class T>\nint __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\nint gcd(int a, int b)\n{\n\tif (a < b)\n\t\tswap(a, b);\n\tif (b == 0)\n\t\treturn a;\n\treturn gcd(b, a%b);\n}\nint lcm(int a, int b)\n{\n\treturn a/gcd(a, b) * b;\n}\nint p[101], q[101], r[101], b[101];\nint dfs(int s)\n{\n\tif (s == 0)\n\t\treturn 1;\n\n\tint red = dfs(r[s]), blue = dfs(b[s]);\n\tint t = lcm(red*p[s], blue*q[s]);\n\treturn t/p[s] + t/q[s];\n}\nint main()\n{\n\tint n;\n\twhile (~scanf(\"%d\", &n) && n)\n\t{\n\t\tbool root[101];\n\t\tfill(root, root+101, true);\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t{\n\t\t\tscanf(\"%d%d%d%d\", p+i, q+i, r+i, b+i);\n\t\t\troot[r[i]] = root[b[i]] = false;\n\t\t}\n\n\t\tint res = 0;\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t\tif (root[i])\n\t\t\t\tres = dfs(i);\n\t\tprintf(\"%d\\n\", res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nll gcd(ll x, ll y)\n{    return y ? gcd(y, x % y) : x;\t}\n\nll lcm(ll x, ll y)\n{\treturn x * y / gcd(x, y);\t}\n\nint poles[128][4];\n\nint weight(int id)\n{\n\tint r = (poles[id][2] == 0 ? 1 : weight(poles[id][2]));\n\tint l = (poles[id][3] == 0 ? 1 : weight(poles[id][3]));\n\t\n\tint p = poles[id][0];\n\tint q = poles[id][1];\n\t\n\tint a = lcm(r*q, l*p) / q;\n\tint b = lcm(r*q, l*p) / p;\n\t\n\treturn a + b;\n}\n\nint main()\n{\n\tfor(int n; cin >> n && n;)\n\t{\n\t\tvint top(128, true);\n\t\t\n\t\tfor(int i = 1; i <= n; i++)\n\t\t{\n\t\t\trep(j, 4) cin >> poles[i][j];\n\n\t\t\ttop[poles[i][2]] = top[poles[i][3]] = false;\n\t\t}\n\t\t\n\t\tfor(int i = 1; i <= n; i++) if(top[i]) cout << weight(i) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nvector<int> rings;\nvector<int> neib[101];\nint used[101];\nint onceused[101];\nint minds[101];\n\nint dfs(int x){\n  used[x] = 1;\n  onceused[x] = 1;\n  int res = 1;\n  for(int i = 0;i < neib[x].size();i++){\n    if(used[neib[x][i]] == 0){\n      res = max(res, 1 + dfs(neib[x][i]));\n    }\n  }\n  used[x] = 0;\n  return res;\n}\n\nint mindfs(int x){\n  int res = neib[x].size();\n  onceused[x] = 1;\n  for(int i = 0;i < neib[x].size();i++){\n    if(onceused[neib[x][i]] == 1)continue;\n    res = min(res, mindfs(neib[x][i]));\n  }\n  return res;\n}\n\nint main(){\n  while(1){\n    int n, ans = 0, mind = 10000;\n    rings.clear();\n    for(int i = 0;i < 101;i++)neib[i].clear();\n    scanf(\"%d\", &n);\n    if(n == 0)return 0;\n    for(int i = 0;i < n;i++){\n      int a, b; \n      scanf(\"%d%d\", &a, &b);\n      rings.push_back(a);\n      rings.push_back(b);\n      neib[a].push_back(b);\n      neib[b].push_back(a);\n    }\n    memset(used, 0, sizeof(used));\n    for(int i = 0;i < rings.size();i++){\n      memset(onceused, 0, sizeof(used));\n      minds[rings[i]] = mindfs(rings[i]);\n    }\n    for(int i = 0;i < rings.size();i++){\n      if(neib[rings[i]].size() == minds[rings[i]]){\n\tans = max(ans, dfs(rings[i]));\n      }\n    }\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nll gcd(ll a, ll b) {\n  return b != 0 ? gcd(b, a % b) : a;\n}\nll lcm(ll a,ll b){\n  return a / gcd(a,b) * b;\n}\n\nconst ll WEIGHT=-1;\nstruct stick{\n\tll r,b,p,q;\n\tstick(ll r,ll b,ll p,ll q):r(r),b(b){\n\t\tll g=gcd(p,q);\n\t\tthis->p=p/g;\n\t\tthis->q=q/g;\n\t}\n\tll getroot(ll index,vector<stick> &sticks){\n\t\tREP(i,sticks.size()){\n\t\t\tif(sticks[i].r==index||sticks[i].b==index){\n\t\t\t\treturn sticks[i].getroot(i,sticks);\n\t\t\t}\n\t\t}\n\t\treturn index;\n\t}\n\tll go(vector<stick> &sticks){\n\t\tll rw=0,bw=0;\n\t\tif(r!=WEIGHT){\n\t\t\trw=sticks[r].go(sticks);\n\t\t}\n\t\tif(b!=WEIGHT){\n\t\t\tbw=sticks[b].go(sticks);\n\t\t}\n\t\tif(r==WEIGHT&&b==WEIGHT){\n\t\t\trw=q;\n\t\t\tbw=p;\n\t\t\tassert(rw);\n\t\t\tassert(bw);\n\t\t}else if(r==WEIGHT){\n\t\t\tif(p*bw%q){\n\t\t\t\trw=bw*p;\n\t\t\t\tbw*=q;\n\t\t\tassert(rw);\n\t\t\t}else{\n\t\t\t\trw=bw*p/q;\n\t\t\t\tassert(bw);\n\t\t\tassert(rw);\n\t\t\t}\n\t\t\tassert(rw);\n\t\t\tassert(bw);\n\t\t}else if(b==WEIGHT){\n\t\t\tif(q*rw%p){\n\t\t\t\tbw=rw*q;\n\t\t\t\trw*=p;\n\t\t\t}else{\n\t\t\t\tbw=rw*q/p;\n\t\t\t\tassert(rw);\n\t\t\t}\n\t\t\tassert(rw);\n\t\t\tassert(bw);\n\t\t}else{\n\t\t\tll l = lcm(p * rw, q * bw);\n\t\t\trw=l/p;\n\t\t\tbw=l/q;\n\t\t\tassert(rw);\n\t\t\tassert(bw);\n\t\t}\n\t\tassert(rw&&bw);\n\t\treturn rw+bw;\n\t}\n};\n\n\nint main(){\n\tll n;\n\twhile(cin>>n,n){\n\t\tvector<stick> sticks;\n\t\tREP(i,n){\n\t\t\tll p,q,r,b;\n\t\t\tcin>>p>>q>>r>>b;\n\t\t\tr--;b--;\n\t\t\tsticks.push_back(stick(r,b,p,q));\n\t\t}\n\t\tll root=sticks[0].getroot(0,sticks);\n\t\tcout<<sticks[root].go(sticks)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\ntypedef unsigned long long ull;\null gcd(ull x, ull y) {\n\tif (y == 0) return x;\n\treturn gcd(y, x % y);\n}\null lcm(ull x, ull y) {\n\treturn x / gcd(x, y) * y;\n}\nint n, a[111], b[111], vis[111]; ull x[111], y[111];\null solve(int pos) {\n\tif (pos == -1) return 1;\n\tull l = solve(a[pos]);\n\tull r = solve(b[pos]);\n\treturn lcm(l, r) * (x[pos] + y[pos]);\n}\nint main() {\n\twhile (cin >> n, n) {\n\t\tfill(vis, vis + n, 0);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> x[i] >> y[i] >> a[i] >> b[i]; a[i]--, b[i]--;\n\t\t\tif (a[i] != -1) vis[a[i]] = 1;\n\t\t\tif (b[i] != -1) vis[b[i]] = 1;\n\t\t\tull r = gcd(x[i], y[i]);\n\t\t\tx[i] /= r, y[i] /= r;\n\t\t}\n\t\tint root = find(vis, vis + n, 0) - vis;\n\t\tcout << solve(root) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n \nusing namespace std;\n \nstruct DATA{\n  int l_l, l_r;\n  int n_l, n_r;\n};\n \nvector<DATA> data;\n\nint MissingNumber(vector<int>&);\nint Recursion(int);\n \nint main(){\n  int n, gcd;\n  DATA data_;\n  vector<int> num;\n \n  while(1){\n    cin >> n;\n    if(n == 0) break;\n \n    for(int i=0; i<n; ++i){\n      cin >> data_.l_l >> data_.l_r >> data_.n_l >> data_.n_r;\n      gcd = __gcd(data_.l_l, data_.l_r);\n      data_.l_l /= gcd;\n      data_.l_r /= gcd;\n      if(data_.n_l != 0) num.push_back(data_.n_l);\n      if(data_.n_r != 0) num.push_back(data_.n_r);\n      data.push_back(data_);\n    }\n\n    cout << Recursion(MissingNumber(num)) << endl;\n    num.clear();\n    data.clear();\n  }\n  return 0;\n}\n\nint MissingNumber(vector<int>& data){\n  sort(data.begin(), data.end());\n  for(int i=0; i<data.size(); ++i){\n    if(data[i] != i+1) return i;\n  }\n  return data.size();\n}\n \nint Recursion(int n){\n  int g_l, g_r, gcd;\n \n  if(data[n].n_l == 0) g_l = 1;\n  else g_l = Recursion(data[n].n_l -1);\n \n  if(data[n].n_r == 0) g_r = 1;\n  else g_r = Recursion(data[n].n_r -1);\n\n  gcd = __gcd(g_l * data[n].l_l, g_r * data[n].l_r);\n  return g_l * ((g_r * data[n].l_r)/gcd) + g_r * ((g_l * data[n].l_l)/gcd);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nint a[100], b[100], l[100], r[100];\nint search(int v) {\n\tint wl = 1, wr = 1;\n\tif(l[v] >= 0) wl = search(l[v]);\n\tif(r[v] >= 0) wr = search(r[v]);\n\n\tint p = 1, q = 1;\n\n\twhile(wl * a[v] * p != wr * b[v] * q) {\n\t\tif(wl * a[v] * p > wr * b[v] * q)\n\t\t\t++q;\n\t\telse\n\t\t\t++p;\n\t}\n\n\treturn wl * p + wr * q;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tfor(int n; cin >> n, n;) {\n\t\tvector<int> in(n, 0);\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tcin >> a[i] >> b[i] >> l[i] >> r[i];\n\t\t\t--l[i];\n\t\t\t--r[i];\n\t\t\tif(l[i] >= 0) ++in[l[i]];\n\t\t\tif(r[i] >= 0) ++in[r[i]];\n\t\t}\n\t\t\n\t\tint ans;\n\t\tfor(int i = 0; i < n; ++i)\n\t\t\tif(!in[i])\n\t\t\t\tans = search(i);\n\t\t\n\t\tcout << ans << endl;\t\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\nusing namespace std;\n\nstruct mob{ int le[101], ri[101], ll[101], rr[101]; };\n\nint n;\nmob mm;\nbool flg[101]; \n\nint gcd(int a,int b){\n\tif(b==0)return a;\n\treturn gcd(b,a%b);\n}\nint lcm(int x,int y){\n    return (x*y/gcd(x,y));\n}\n\nint minc(int x){\n\tint w,lef,rig;\n\tif(mm.ll[x]==0)lef=1;\n\telse lef=minc(mm.ll[x]);\n\tif(mm.rr[x]==0)rig=1;\n\telse rig=minc(mm.rr[x]);\n\tw=lcm(lef*mm.le[x],rig*mm.ri[x]);\n\treturn w/mm.le[x]+w/mm.ri[x];\n}\n\n\nint main(void){\n\tlong long int ans;\n\twhile(1){\n\t\tcin >> n;\n\t\tif(n==0)break;\n\t\tmemset(flg,0,sizeof(flg));\n\t\tfor(int a=1;a<=n;a++){\n\t\t\tscanf(\"%d%d%d%d\",&mm.le[a],&mm.ri[a],&mm.ll[a],&mm.rr[a]);\n\t\t\tflg[mm.ll[a]]=1;\n\t\t\tflg[mm.rr[a]]=1;\n\t\t}\n\t\tfor(int a=1;a<=n;a++){\n\t\t\tif(flg[a]==0)ans=minc(a);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX_N 100\ntypedef long long ll;\n \nvector<ll> p, q, r, b;\n \nbool dfs(int v, ll val)\n{\n    ll l = p[v] + q[v];\n    if (val * p[v] % l != 0) {\n        return 0;\n    }\n    if (val * q[v] % l != 0) {\n        return 0;\n    }\n    bool can = 1;\n    if (r[v] >= 0) {\n        can &= dfs(r[v], val*p[v]/l); \n    }\n    if (b[v] >= 0) {\n        can &= dfs(b[v], val*q[v]/l); \n    }\n    return can;\n}\n \nvoid init(int N)\n{\n    p.resize(N); q.resize(N);\n    r.resize(N); b.resize(N);\n}\n\nll lcm(ll a, ll b)\n{\n    return a / __gcd(a, b) * b;\n}\n \nint main()\n{\n    int N;\n    while (cin >> N, N) {\n        init(N);\n        bool used[MAX_N] = {};\n        ll lm = 1;\n        for (int i = 0; i < N; i++) {\n            cin >> p[i] >> q[i] >> r[i] >> b[i];\n            r[i]--; b[i]--;\n            if (r[i] >= 0) used[r[i]] = 1;\n            if (b[i] >= 0) used[b[i]] = 1;\n            int gcd = __gcd(p[i], q[i]);\n            p[i] /= gcd;\n            q[i] /= gcd;\n            lm = lcm(lm, p[i]+q[i]);\n        }\n        int par = -1;\n        for (int i = 0; i < N; i++) {\n            if (!used[i]) {\n                par = i;\n                break;\n            }\n        }\n        for (int i = lm; ; i += lm) {\n            if (dfs(par, i)) {\n                cout << i << endl;\n                break;\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <stdio.h>\n#include <math.h>\n#include <time.h>\n#include <string>\n#include <tuple>\n#include <vector>\n#include <map>\n#include <list>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstdlib>\n#include <algorithm>\n#include <random>\n#include <cassert>\nusing namespace std;\n#define LL long long\n#undef INT_MIN\n#undef INT_MAX\n#define INT_MIN -2147483648\n#define INT_MAX 2147483647\n#define LL_MIN -9223372036854775808\n#define LL_MAX 9223372036854775807\n\n#define int long long\nint gcd(int a, int b){\n    if(b > a) swap(a, b);\n    int tmp;\n    while(b != 0){\n        tmp = a % b;\n        a = b;\n        b = tmp;\n    }\n    return a;\n}\n\nint p[100], q[100], r[100], s[100];\nint dp[100] = {};\nint solve(int now){\n    if(dp[now] != 0) return dp[now];\n    if(r[now] != -1 && s[now] != -1){//両端が棒と繋がっていた場合\n        int a1 = solve(r[now]);\n        int b1 = solve(s[now]);\n        int a2 = a1;\n        int b2 = b1;\n        while(a2*p[now] != b2*q[now]){\n            if(a2*p[now] < b2*q[now]) a2 += a1;\n            if(a2*p[now] > b2*q[now]) b2 += b1;\n        }\n        return dp[now] = a2 + b2;\n    }\n    if(r[now] == -1 && s[now] == -1){//両端がおもりの場合\n        return dp[now] = p[now] + q[now];\n    }\n    if(r[now] != -1 && s[now] == -1){//左は棒、右はおもり\n        int a1 = solve(r[now]);\n        int b1 = 1;\n        int a2 = a1;\n        int b2 = b1;\n        while(a2*p[now] != b2*q[now]){\n            if(a2*p[now] < b2*q[now]) a2 += a1;\n            if(a2*p[now] > b2*q[now]) b2 += b1;\n        }\n        return dp[now] = a2 + b2;\n    }\n    if(r[now] == -1 && s[now] != -1){//左はおもり、右は棒\n        int a1 = 1;\n        int b1 = solve(s[now]);\n        int a2 = a1;\n        int b2 = b1;\n        while(a2*p[now] != b2*q[now]){\n            if(a2*p[now] < b2*q[now]) a2 += a1;\n            if(a2*p[now] > b2*q[now]) b2 += b1;\n        }\n        return dp[now] = a2 + b2;\n    }\n}\n\n#undef int\nint main(){\n    #define int long long\n    iostream::sync_with_stdio(false);\n    \n    while(true){\n        int n;\n        cin >> n;\n        if(n == 0) return 0;\n\n        for(int i=0; i<n; i++){\n            cin >> p[i] >> q[i] >> r[i] >> s[i];\n            int g = gcd(p[i], q[i]);\n            p[i] /= g;\n            q[i] /= g;\n            r[i]--;\n            s[i]--;\n            dp[i] = 0;\n        }\n\n        int ans = 0;\n        for(int i=0; i<n; i++){\n            ans = max(ans, solve(i));\n        }\n        cout << ans << endl;\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstring>\nusing namespace std;\nstruct Bar {\n\tint p,q,r,b;\n\tBar (int _p,int _q,int _r,int _b) {\n\t\tp=_p,q=_q,r=_r,b=_b;\n\t}\n};\nstruct Fraction {\n\tint bunbo,bunshi;\n\tFraction (int _bunbo,int _bunshi) {\n\t\tbunbo=_bunbo,bunshi=_bunshi;\n\t}\n};\nint n;\nvector<Bar> Bars;\nvector<Fraction> Fractions;\nbool child[100];\nvoid solve(int X,Fraction C) {\n\tif(Bars[X].r>0) solve(Bars[X].r-1,Fraction(C.bunbo*(Bars[X].p+Bars[X].q),C.bunshi*Bars[X].q));\n\telse Fractions.push_back(Fraction(C.bunbo*(Bars[X].p+Bars[X].q),C.bunshi*Bars[X].q));\n\tif(Bars[X].b>0) solve(Bars[X].b-1,Fraction(C.bunbo*(Bars[X].p+Bars[X].q),C.bunshi*Bars[X].p));\n\telse Fractions.push_back(Fraction(C.bunbo*(Bars[X].p+Bars[X].q),C.bunshi*Bars[X].p));\n}\nint gcd(int a,int b) {\n\treturn b?gcd(b,a%b):a;\n}\nint lcm(int a,int b) {\n\treturn a/gcd(a,b)*b;\n}\nint main() {\n\twhile(scanf(\"%d\",&n),n) {\n\t\tBars.clear();\n\t\tFractions.clear();\n\t\tmemset(child,0,sizeof(child));\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tint p,q,r,b;\n\t\t\tscanf(\"%d %d %d %d\",&p,&q,&r,&b);\n\t\t\tif(r>0) child[r-1]=true;\n\t\t\tif(b>0) child[b-1]=true;\n\t\t\tBars.push_back(Bar(p,q,r,b));\n\t\t}\n\t\tint par=0;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tif(!child[i]) {par=i;break;}\n\t\t}\n\t\tsolve(par,Fraction(1,1));\n\t\tint L=1;\n\t\tfor(int i=0;i<Fractions.size();i++) {\n\t\t\tint G=gcd(Fractions[i].bunbo,Fractions[i].bunshi);\n\t\t\tFractions[i].bunbo/=G;\n\t\t\tL=lcm(L,Fractions[i].bunbo);\n\t\t}\n\t\tprintf(\"%d\\n\",L);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\nusing namespace std;\n\nstruct mob{ int le[101], ri[101], ll[101], rr[101]; };\n\nint n;\nmob mm;\nbool flg[101]; \n\nint gcd(int a,int b){\n\tif(b==0)return a;\n\treturn gcd(b,a%b);\n}\nint lcm(int x,int y){\n    return (x*y/gcd(x,y));\n}\n\nint minc(int x){\n\tint w,lef,rig;\n\tif(mm.ll[x]==0)lef=1;\n\telse lef=minc(mm.ll[x]);\n\tif(mm.rr[x]==0)rig=1;\n\telse rig=minc(mm.rr[x]);\n\tw=lcm(lef*mm.le[x],rig*mm.ri[x]);\n\treturn w/mm.le[x]+w/mm.ri[x];\n}\n\n\nint main(void){\n\tint ans;\n\twhile(1){\n\t\tcin >> n;\n\t\tif(n==0)break;\n\t\tmemset(flg,0,sizeof(flg));\n\t\tfor(int a=1;a<=n;a++){\n\t\t\tscanf(\"%d%d%d%d\",&mm.le[a],&mm.ri[a],&mm.ll[a],&mm.rr[a]);\n\t\t\tflg[mm.ll[a]]=1;\n\t\t\tflg[mm.rr[a]]=1;\n\t\t}\n\t\tfor(int a=1;a<=n;a++){\n\t\t\tif(flg[a]==0)ans=minc(a);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nstruct mobile\n{\n\tint p, q, r, b;\n\tint par;\n\t\n\tvoid init(){\n\t\tp = q = r = b = 0;\n\t\tpar = -1;\n\t}\n};\n\nll gcd(ll a, ll b)\n{\n\tif (b == 0) return a;\n\treturn gcd(b, a % b);\n}\n\nll lcm(ll a, ll b)\n{\n\treturn (a / gcd(a, b) * b);\n}\n\n/*\n2 3 \n2 3\n\n4 9\n\n36 36\n\n18 12\n*/\n\nmobile M[100];\n\nll weight(int now)\n{\n\tll R, B;\n\t\n\tif (M[now].r == -1) R = 1;\n\telse R = weight(M[now].r);\n\tif (M[now].b == -1) B = 1;\n\telse B = weight(M[now].b);\n\t\n\tll P, Q;\n\tP = R * M[now].p;\n\tQ = B * M[now].q;\n\t\n\tll l = lcm(P, Q);\n\t\n\treturn (l / M[now].p) + (l / M[now].q);\n}\n\nint main()\n{\n\tint n;\n\twhile (scanf(\"%d\", &n), n){\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tM[i].init();\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tscanf(\"%d %d %d %d\", &M[i].p, &M[i].q, &M[i].r, &M[i].b);\n\t\t\tint g = gcd(M[i].p, M[i].q);\n\t\t\tM[i].p /= g;\n\t\t\tM[i].q /= g;\n\t\t\tM[i].r--; M[i].b--;\n\t\t\t\n\t\t\tif (M[i].r != -1) M[M[i].r].par = i;\n\t\t\tif (M[i].b != -1) M[M[i].b].par = i;\n\t\t}\n\t\t\n\t\tint top = 0;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tif (M[i].par == -1){\n\t\t\t\ttop = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%lld\\n\", weight(top));\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i = (a); i < (b); i++)\n#define REP(i,n) FOR(i,0,n)\n\ntypedef long long ll;\n\nstruct Node {\n\tint a, b, ma, mb;\n\t\n\tNode() {}\n\tNode(int a, int b, int ma, int mb) : a(a), b(b), ma(ma), mb(mb) {}\n};\n\nint n;\nNode node[100];\nbool istop[100];\n\nint gcd(int a, int b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a % b);\n}\n\nll dfs(int pos) {\n\tNode &now = node[pos];\n\t\n\tint a = now.a, b = now.b, ma = now.ma, mb = now.mb;\n\t\n\tif (ma != 0) ma = dfs(ma - 1);\n\tif (mb != 0) mb = dfs(mb - 1);\n\t\n\tif (ma == 0 && mb == 0) {\n\t\treturn a + b;\n\t\n\t} else if (ma == 0 || mb == 0) {\n\t\tif (ma == 0) swap(ma, mb);\n\t\treturn (ll)ma * (a + b);\n\t\t\n\t}\n\telse {\n\t\tcout << a << \" \" << b << \" \" << ma << \" \" << mb << endl;\n\t\tint x = gcd(a * ma, b * mb);\n\t\tll res1 = (ll)mb * (a * ma / x);\n\t\tll res2 = (ll)ma * (b * mb / x);\n\t\treturn res1 + res2;\n\t}\n}\n\nint main() {\n\twhile (cin >> n, n) {\n\t\t\n\t\tfill(istop, istop + n, false);\n\t\tREP(i, n) {\n\t\t\tint a, b, ma, mb;\n\t\t\tscanf(\"%d %d %d %d\", &a, &b, &ma, &mb);\n\t\t\tint g = gcd(a, b);\n\t\t\ta /= g; b /= g;\n\t\t\tnode[i] = Node(a, b, ma, mb);\n\t\t\t\n\t\t\tif (ma != 0) istop[ma - 1] = true;\n\t\t\tif (mb != 0) istop[mb - 1] = true;\n\t\t}\n\t\t\n\t\tint st = 0;\n\t\twhile (istop[st]) st++;\n\t\tcout << dfs(st) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\nint gcd(int a, int b) {\n\tif (b == 0) {\n\t\treturn a;\n\t}\n\tint r = a % b;\n\treturn gcd(b, r);\n}\nint we(int wl, int wr, int lel, int ler) {\n\tint ml = wl * lel;\n\tint mr = wr * ler;\n\tint bil = mr / gcd(ml, mr);\n\tint bir = ml / gcd(ml, mr);\n\treturn (wl * bil)+(wr*bir);\n}\nint main(){\n\tint n;\n\tcin >> n;\n\tvector<int> w(n);\n\tvector<int> lel(n);\n\tvector<int> ler(n);\n\tvector<int> nul(n);\n\tvector<int> nur(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tint l, r;\n\t\tcin >> lel[i] >> ler[i] >> l >> r;\n\t\tl--; r--;\n\t\tnul[i] = l; nur[i] = r;\n\t}\n\tvector<int> d(n,n);\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tint x, y;\n\t\t\tif (nul[j] == -1) {\n\t\t\t\tx = -1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx = d[nul[j]];\n\t\t\t}\n\t\t\tif (nur[j] == -1) {\n\t\t\t\ty = -1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ty = d[nur[j]];\n\t\t\t}\n\t\t\td[j]=min(d[j], max(x, y)+1);\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (d[j] == i) {\n\t\t\t\tint wl, wr;\n\t\t\t\tint l = nul[j];\n\t\t\t\tint r = nur[j];\n\t\t\t\tif (l == -1) {\n\t\t\t\t\twl = 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\twl = w[l];\n\t\t\t\t}\n\t\t\t\tif (r == -1) {\n\t\t\t\t\twr = 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\twr = w[r];\n\t\t\t\t}\n\t\t\t\tw[j] = we(wl, wr, lel[j], ler[j]);\n\t\t\t\tans = max(ans, w[j]);\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint n;\nint a[100][2],p[100][2];\nbool cal[100];\nint GCD(int x,int y){\n\twhile(true){\n\t\tif(y>x){int t=x;x=y,y=t;}\n\t\tx%=y;\n\t\tif(x<2)break;\n\t}\n\treturn min(x,y);\n}\nint DFS(int x){\n\tif(!x)return 1;\n\tx--;\n\tint b=DFS(p[x][0]),c=DFS(p[x][1]);\n\tint s=b*a[x][0]*c*a[x][1]/GCD(b*a[x][1],c*a[x][0]);\n\tint ret=0;\n\tif(a[x][0])ret+=s/a[x][0];\n\tif(a[x][0])ret+=s/a[x][1];\n\t//ret=s/a[x][0]+s/a[x][1];\n\treturn ret;\n}\nint main(){\n\twhile(true){\n\tcin>>n;\n\tif(!n)break;\n\tfor(int i=0;i<n;i++)cal[i]=true;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>a[i][0]>>a[i][1];\n\t\tint t=GCD(a[i][0],a[i][1]);\n\t\ta[i][0]/=t,a[i][1]/=t;\n\t\tcin>>p[i][0]>>p[i][1];\n\t\tcal[p[i][0]-1]=false,cal[p[i][1]-1]=false;\n\t}\n\tfor(int i=0;i<n;i++)if(cal[i])cout<<DFS(i+1)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\n\nint n, p[100], q[100], r[100], b[100];\nbool isTop[100];\n\nint gcd(int a, int b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\n\nint check(int num) {\n  int left = 1, right = 1;\n  if (r[num] != -1) left = check(r[num]);\n  if (b[num] != -1) right = check(b[num]);\n  int g = gcd(p[num], q[num]);\n  p[num] /= g;\n  q[num] /= g;\n  int temp = left * right / gcd(left, right);\n  return (p[num] + q[num]) * temp;\n}\n\nint main() {\n  while (1) {\n    scanf(\"%d\", &n);\n    if (n == 0) break;\n    for (int i = 0; i < n; i++) isTop[i] = true;\n    for (int i = 0; i < n; i++) {\n      scanf(\"%d%d%d%d\", &p[i], &q[i], &r[i], &b[i]);\n      r[i]--, b[i]--;\n      if (r[i] != -1) isTop[r[i]] = false;\n      if (b[i] != -1) isTop[b[i]] = false;\n    }\n    int top;\n    for (int i = 0; i < n; i++) if (isTop[i]) { top = i; break; }\n    printf(\"%d\\n\", check(top));\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define min_3(a,b,c) min(a,min(b,c))\n#define max_3(a,b,c) max(a,max(b,c))\n#define mp1(a,b,c) P1(a,P(b,c))\n#define pque(a) priority_queue<a>\n#define rpque(a) priority_queue<a,vector<a>,greater<a>>\n\nconst int INF=1000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\nconst int kaijou[10]={1,1,2,6,24,120,720,5040,40320,362880};\n\nll gcd(ll x,ll y){\n\tif(y == 0)return x;\n\treturn gcd(y,x%y);\n}\n\nll lcm(ll x,ll y){\n\treturn x/gcd(x,y)*y;\n}\n\nint n;\nll p[102],q[102],r[102],b[102];\nll w[102];\n\nll dfs(int v){\n\tif(v == 0)return 1;\n\tif(w[v] != NULL)return w[v];\n\tll x = dfs(r[v]);\n\tll y = dfs(b[v]);\n\tll l = lcm(p[v]*x,q[v]*y);\n\treturn l/p[v] + l/q[v];\n}\n\nvoid init(){\n\trep(i,102){\n\t\tw[i] = 0;\n\t}\n}\n\nint main(){\n\twhile(1){\n\t\tinit();\n\t\tscanf(\"%d\",&n); if(n == 0)break;\n\t\trep1(i,n){\n\t\t\tscanf(\"%lld%lld%lld%lld\",&p[i],&q[i],&r[i],&b[i]);\n\t\t}\n\t\t\n\t\tll ret = 0;\n\t\trep1(i,n){\n\t\t\tret = max ( ret , dfs(i) );\n\t\t}\n\t\t\n\t\tprintf(\"%lld\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nint lenL[100];\nint lenR[100];\nint L[100];\nint R[100];\nint c[100];\nint d[100];\nlong long wL[100];\nlong long wR[100];\nint parent[100];\nbool visited[100];\nlong long int gcd(long long int a,long long int b){\n\twhile(b){\n\t\ta%=b;\n\t\tlong long int val=b;\n\t\tb=a;\n\t\ta=val;\n\t}\n\treturn a;\n}\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tfor(int i=0;i<a;i++){\n\t\t\tscanf(\"%d%d%d%d\",lenL+i,lenR+i,L+i,R+i);\n\t\t}\n\t\tlong long total=1;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tc[i]=lenL[i]/gcd(lenL[i],lenR[i]);\n\t\t\td[i]=lenR[i]/gcd(lenR[i],lenL[i]);\n\t\t\ttotal*=(c[i]+d[i]);\n\t\t}\n\t\tfor(int i=0;i<a;i++)parent[i]=-1;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tif(L[i])\n\t\t\t\tparent[L[i]-1]=i;\n\t\t\tif(R[i])\n\t\t\t\tparent[R[i]-1]=i;\n\t\t}\n\t\tfor(int i=0;i<a;i++)visited[i]=false;\n\t\tfor(int j=0;j<a;j++){\n\t\t\tfor(int i=0;i<a;i++){\n\t\t\t\tif(parent[i]==-1&&visited[i]==false){\n\t\t\t\t\twL[i]=total/(c[i]+d[i])*d[i];\n\t\t\t\t\twR[i]=total/(c[i]+d[i])*c[i];\n\t\t\t\t\tvisited[i]=true;\n\t\t\t\t}else if(parent[i]!=-1&&visited[i]==false&&visited[parent[i]]==true){\n\t\t\t\t\tvisited[i]=true;\n\t\t\t\t\twL[i]=(L[parent[i]]==i+1?wL[parent[i]]:wR[parent[i]])/(c[i]+d[i])*d[i];\n\t\t\t\t\twR[i]=(L[parent[i]]==i+1?wL[parent[i]]:wR[parent[i]])/(c[i]+d[i])*c[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(1){\n\t\t\tint val=total;\n\t\t\tfor(int i=0;i<a;i++){\n\t\t\t\tval=gcd(val,gcd(wL[i],wR[i]));\n\t\t\t}\n\t\t\tif(val==1)break;\n\t\t\ttotal/=val;\n\t\t\tfor(int i=0;i<a;i++){\n\t\t\t\twL[i]/=val;\n\t\t\t\twR[i]/=val;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",total);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<cstring>\n#define max(a,b) (a>b?a:b)\nlong long int a[101],b[101],c[101],d[101],memo[101],res=0;\n\nlong long int gcd(long long int x,long long int y){\n\tif(x==0)return y;\n\telse return gcd(y%x,x);\n}\nlong long int solve(int x){\n\tif(memo[x]!=0)return memo[x];\n\tint left=a[x]*solve(c[x]),right=b[x]*solve(d[x]),gc;\n\tgc=gcd(left,right);\n\treturn memo[x]=right/gc*solve(c[x])+left/gc*solve(d[x]);\n}\n\nint main(){\n\tmemo[0]=1;\n\tint n;\n\tfor(;scanf(\"%d\",&n),n!=0;memset(memo,0,sizeof(memo))){\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tscanf(\"%lld%lld%lld%lld\",a+i,b+i,c+i,d+i);\n\t\t}\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tres=max(res,solve(i));\n\t\t}\n\t\tprintf(\"%lld\\n\",res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nint gcd(int a,int b){\n\tint tmp;\n\twhile(b != 0){\n\t\ta -= b * (int)(a / b);\n\t\ttmp = a;\n\t\ta = b;\n\t\tb = tmp;\n\t}\n\treturn a;\n}\n\nint lcm(int a,int b){\n\treturn a / gcd(a,b) * b;\n}\n\nstruct bou{\n\tint left,right;\n\tint lbou,rbou;\n};\n\nint main(){\n\tint n,res = 1;\n\tvector<bou> tree;\n\tint si[100],bo[100],par[100];\n\twhile(cin >> n,n){\n\ttree.clear();\n\tres = 1;\n\tfor(int i = 0;i < n;i++) par[i] = -1;\n\tfor(int i = 0;i < n;i++){\n\t\tint a,b,c,d;\n\t\tcin >> a >> b >> c >> d;\n\t\ttree.push_back({a / gcd(a,b),b / gcd(a,b),c - 1,d - 1});\n\t\tif(c >= 1) par[c - 1] = i;\n\t\tif(d >= 1) par[d - 1] = i;\n\t}\n\tqueue<int> que;\n\tfor(int i = 0;i < n;i++) if(par[i] == -1) que.push(i);\n\tsi[que.front()] = 1;\n\tbo[que.front()] = 1;\n\twhile(!que.empty()){\n\t\tint q = que.front();que.pop();\n\t\tbou now = tree[q];\n\t\tint bun[4];\n\t\tbun[0] = si[q] * now.left;\n\t\tbun[1] = bo[q] * (now.left + now.right);\n\t\tbun[2] = si[q] * now.right;\n\t\tbun[3] = bun[1];\n\t\tbun[0] /= gcd(bun[0],bun[1]);\n\t\tbun[1] /= gcd(bun[0],bun[1]);\n\t\tbun[2] /= gcd(bun[2],bun[3]);\n\t\tbun[3] /= gcd(bun[2],bun[3]);\n\t\tif(now.lbou != -1){\n\t\t\tsi[now.lbou] = bun[0];\n\t\t\tbo[now.lbou] = bun[1];\n\t\t\tque.push(now.lbou);\n\t\t}else{\n\t\t\tres = lcm(res,bun[1]);\n\t\t}\n\t\tif(now.rbou != -1){\n\t\t\tsi[now.rbou] = bun[2];\n\t\t\tbo[now.rbou] = bun[3];\n\t\t\tque.push(now.rbou);\n\t\t}else{\n\t\t\tres = lcm(res,bun[3]);\n\t\t}\n\t}\n\tcout << res << endl;\n\t}\n\treturn 0;\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nint gcd(int a, int b){\n\tif(b == 0)return a;\n\treturn gcd(b, a%b);\n}\n\nstruct Pole{\n\tint left, right;\n\tPole *red, *blue, *rred, *rblue;\n};\n\n// 中和をとった時の重さを返す\nint trace(Pole pole){\n\tint red_w, blue_w;\n\tif(pole.red == nullptr && pole.blue == nullptr){\n\t\tred_w = pole.right;\n\t\tblue_w = pole.left;\n\t}else if(pole.red != nullptr && pole.blue != nullptr){\n\t\tred_w = trace(*pole.red);\n\t\tblue_w = trace(*pole.blue);\n\n\t\tint g = gcd(pole.left * red_w, pole.right * blue_w),\n\t\t\tl = pole.left * red_w * pole.right * blue_w / g;\n\n\t\tred_w = l / pole.left;\n\t\tblue_w = l / pole.right;\n\t}else{\n\t\tif(pole.red == nullptr){\n\t\t\tstd::swap(pole.red, pole.blue);\n\t\t\tstd::swap(pole.left, pole.right);\n\t\t}\n\n\t\tint _red_w = trace(*pole.red),\n\t\t\tg = gcd(pole.left * _red_w, pole.right),\n\t\t\tl = pole.left * _red_w * pole.right / g;\n\t\t\t\n\t\tred_w = l / pole.left;\n\t\tblue_w = l / pole.right;\n\t}\n\n\treturn red_w + blue_w;\n}\n\nint main(){\n\tint n;\n\twhile(std::cin >> n, n){\n\t\tPole ps[100];\n\n\t\tfor(int i=0;i<100;i++){\n\t\t\tps[i].red = nullptr;\n\t\t\tps[i].blue = nullptr;\n\t\t\tps[i].rred = nullptr;\n\t\t\tps[i].rblue = nullptr;\n\t\t\tps[i].left = 0;\n\t\t\tps[i].right = 0;\n\t\t}\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint p, q, r, b;\n\t\t\tstd::cin >> p >> q >> r >> b;\n\t\t\tr--;b--;\n\n\t\t\tint g = gcd(p, q);\n\t\t\tps[i].left = p / g;\n\t\t\tps[i].right = q / g;\n\n\t\t\tif(r != -1){\n\t\t\t\tps[i].red = &ps[r];\n\t\t\t\tps[r].rred = &ps[i];\n\t\t\t}\n\t\t\n\t\t\tif(b != -1){\n\t\t\t\tps[i].blue = &ps[b];\n\t\t\t\tps[b].rblue = &ps[i];\n\t\t\t}\n\t\t}\n\t\n\t\tint parent = 0;\n\t\t{\n\t\t\tPole *p = &ps[0];\n\t\t\twhile(p->rred != nullptr || p->rblue != nullptr){\n\t\t\t\tif(p->rred != nullptr){//実は一意(普通)\n\t\t\t\t\tp = p->rred;\n\t\t\t\t}else{\n\t\t\t\t\tp = p->rblue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tparent = p - &ps[0];\n\t\t}\n\n\t\tstd::cout << trace(ps[parent]) << std::endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nll n;\nvector<ll> G[105];\nll depth[105];\n\nll p[105],q[105],r[105],b[105];\nll cnt[105];\nll sum[105];\n\nvector<ll> lis_d[105];\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    cin >> n;\n    while(n){\n    memset(depth,0,sizeof(depth));\n    memset(cnt,0,sizeof(cnt));\n    memset(sum,0,sizeof(sum));\n    for (int i = 0;i < 105;i++){\n        G[i] =  lis_d[i] = vector<ll>(0);\n    }\n    for (int i = 1;i <= n;i++){\n        cin >> p[i] >> q[i] >> r[i] >> b[i];\n        if(r[i]) G[i].push_back(r[i]);\n        if(b[i]) G[i].push_back(b[i]);\n        cnt[r[i]]++;\n        cnt[b[i]]++;\n    }\n\n    int st;\n\n    for (int i = 1;i <= n;i++){\n        if(cnt[i] == 0){\n            st = i;\n            break;\n        }\n    }\n\n    //cout << st << endl;\n\n    queue<P> que;\n    que.push(P(st,0));\n    depth[st] = 0;\n    lis_d[0].push_back(st);\n\n    while(que.size()){\n        P p = que.front(); que.pop();\n        ll from = p.first;\n        ll dep = p.second;\n        for (int i = 0;i < G[from].size();i++){\n            ll to = G[from][i];\n            depth[to] = dep+1;\n            //cout << to << \" \" << depth[to] << endl;\n            lis_d[depth[to]].push_back(to);\n            que.push(P(to,depth[to]));\n        }\n    }\n\n    for (int i = 103;i >= 0;i--){\n        for (int j = 0;j < lis_d[i].size();j++){\n            ll now = lis_d[i][j];\n            //cout << now << endl;\n            if(G[now].size() == 0){\n                sum[now] = (p[now]+q[now])/__gcd(p[now],q[now]);\n            }else if(G[now].size() == 1){\n                ll p_ = p[now], q_ = q[now];\n                ll ch = G[now][0];\n                if(G[now][0] == b[now]) swap(p_,q_);\n                ll sig = q_/__gcd(p_*sum[ch],q_);\n                ll w = p_*sum[ch]/__gcd(p_*sum[ch],q_);\n                sum[now] = w+sig*sum[ch];\n            }else{\n                ll p_ = p[now], q_ = q[now];\n                ll w1 = sum[G[now][0]], w2 = sum[G[now][1]];\n                //cout << w1 << \" \" << w2 << \"sdfsd\" << endl;\n                //if(G[now][0] == b[now]){ swap(p_,q_); cout << \"fsdfas\" << endl;}\n                //ll lcm = w1*p_/__gcd(w1*p_,w2*q_)*w2*q_;\n                sum[now] = w1*w2*q_/__gcd(w1*p_,w2*q_) + w1*p_*w2/__gcd(w1*p_,w2*q_);\n            }\n            //cout << sum[now] << \" \" << now << \" \" << i << endl;\n        }\n    }\n\n    //cout << st << endl;\n\n    cout << sum[st] << endl;\n    cin >> n;\n    }\n\n    return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nlong long b[100],c[100],d[100],e[100],f[100];\nlong long gcd(long long a,long long b){\n\twhile(b){\n\t\ta%=b;\n\t\tlong long t=a;\n\t\ta=b;\n\t\tb=t;\n\t}\n\treturn a;\n}\nlong long lcm(long long a,long long b){return a*b/gcd(a,b);}\nlong long dfs(long long a){\n\tif(a==-1)return 1;\n\tlong long L=dfs(d[a]-1);\n\tlong long R=dfs(e[a]-1);\n\tlong long s=gcd(c[a],b[a]);\n\tc[a]/=s;\n\tb[a]/=s;\n\t//printf(\"%lld,%lld\\n\",L*c[a],R*b[a]);\n\tlong long u=lcm(L*b[a],R*c[a]);\n\treturn u/c[a]+u/b[a];\n}\nint main(){\n\tlong long a;\n\twhile(scanf(\"%lld\",&a),a){\n\t\tfor(long long i=0;i<a;i++)scanf(\"%lld%lld%lld%lld\",b+i,c+i,d+i,e+i);\n\t\tfor(long long i=0;i<a;i++)f[i]=-1;\n\t\tfor(long long i=0;i<a;i++){\n\t\t\tif(d[i]>0)f[d[i]-1]=i;\n\t\t\tif(e[i]>0)f[e[i]-1]=i;\n\t\t}\n\t\tlong long parent=0;\n\t\tfor(long long i=0;i<a;i++)if(f[i]==-1)parent=i;\n\t\tprintf(\"%lld\\n\",dfs(parent));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,p[101],q[101],r[101],b[101];\nint memo[101];\nint dp(int a){\n  if(memo[a] != -1) return memo[a];\n  int ret,red,blue;\n  if(r[a] == 0 && b[a] == 0){\n    ret = p[a] + q[a];\n  } else if(r[a] == 0 && b[a] != 0){\n    blue = dp(b[a]);\n    if(blue % p[a] != 0) blue *= p[a];\n    red = (q[a]*blue)/p[a];\n    ret = blue + red;\n  } else if(r[a] != 0 && b[a] == 0){\n    red = dp(r[a]);\n    if(red % q[a] != 0) red *= q[a];\n    blue = (p[a]*red)/q[a];\n    ret = blue + red;\n  } else {\n    red = dp(r[a]);\n    blue = dp(b[a]);\n    if(blue % p[a] != 0) blue *= p[a];\n    if(red % q[a] != 0) red *= q[a];\n    int m = __gcd(blue,red);\n    int mb = (blue/m)/p[a];\n    int mr = (red/m)/q[a];\n    blue *= mr;\n    red *= mb;\n    ret = blue + red;\n  }\n  return memo[a] = ret;\n}\nint main(){\n  while(scanf(\"%d\",&n),n!=0){\n    fill(memo,memo+101,-1);\n    for(int i=1;i<=n;i++){\n      scanf(\"%d %d %d %d\",&p[i],&q[i],&r[i],&b[i]);\n      int m = __gcd(p[i],q[i]);\n      p[i] /= m;\n      q[i] /= m;\n    }\n    int ans = 0;\n    for(int i=1;i<=n;i++){\n      ans = max(ans,dp(i));\n    }\n    printf(\"%d\\n\",ans);\n  }\n  return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#include <random>\n#include <complex>\n#include <unordered_map>\n#define rep(i,s,n) for(int i = (s); (n) > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define RANGE(x,a,b) ((a) <= (x) && (x) <= (b))\n#define DUPLE(a,b,c,d) (RANGE(a,c,d) || RANGE(b,c,d) || RANGE(c,a,b) || RANGE(d,a,b))\n#define INCLU(a,b,c,d) (RANGE(a,c,d) && (b,c,d))\n#define PW(x) ((x)*(x))\n#define ALL(x) (x).begin(), (x).end()\n#define RALL(x) (x).rbegin(), (x).rend()\n#define MODU 1000000007\n#define bitcheck(a,b)   ((a >> b) & 1)\n#define bitset(a,b)      ( a |= (1 << b))\n#define bitunset(a,b)    (a &= ~(1 << b))\n#define MP(a,b) make_pair((a),(b))\n#define Manh(a,b) (abs((a).first-(b).first) + abs((a).second - ((b).second))\n#define pritnf printf\n#define scnaf scanf\n#define itn int\n#define PI 3.141592653589\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll gcd(ll a, ll b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a%b);\n}\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N], const T &val) {\n\tstd::fill((T*) array, (T*) (array + N), val);\n}\npii Dir [] = {\n\t{ 1,0 },{ 0,1 }\n};\n\nll lcm(ll m, ll n)\n{\n\treturn m * n / gcd(m, n);\n}\nsigned main() {\n\tint n;\n\n\twhile (scanf(\"%d\", &n) != EOF) {\n\t\tif (!n)\n\t\t\tbreak;\n\t\tvector<int> pa(n,-1);\n\t\tvector<pair<pii,pii>> mob(n);\n\t\tREP(i, n) {\n\t\t\tint a, b, c, d;\n\n\t\t\tscnaf(\"%d %d %d %d\", &a, &b, &c, &d);\n\t\t\tc--; d--;\n\t\t\tif (c >= 0) {\n\t\t\t\tpa[c] = i;\n\t\t\t}\n\t\t\tif (d >= 0) {\n\t\t\t\tpa[d] = i;\n\t\t\t}\n\t\t\tmob[i] = { {a,b},{c,d} };\n\t\t}\n\t\twhile (1) {\n\t\t\tbool f = 0;\n\t\t\tREP(i, mob.size()) {\n\t\t\t\tif (mob[i].second.first < 0 && mob[i].second.second < 0) {\n\t\t\t\t\tif (pa[i] < 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (mob[pa[i]].second.first >= 0 || mob[pa[i]].second.second >= 0) {\n\t\t\t\t\t\tint lc = lcm(mob[i].first.first*-mob[i].second.first, mob[i].first.second*-mob[i].second.second);\n\t\t\t\t\t\tint sum = lc / mob[i].first.first + lc / mob[i].first.second;\n\t\t\t\t\t\tif (mob[pa[i]].second.first == i) {\n\t\t\t\t\t\t\tmob[pa[i]].second.first = -sum;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (mob[pa[i]].second.second == i) {\n\t\t\t\t\t\t\tmob[pa[i]].second.second = -sum;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tf = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!f) {\n\t\t\t\tREP(i, n) {\n\t\t\t\t\tif (pa[i] == -1) {\n\t\t\t\t\t\tint lc = lcm(mob[i].first.first*-mob[i].second.first, mob[i].first.second*-mob[i].second.second);\n\t\t\t\t\t\tint sum = lc / mob[i].first.first + lc / mob[i].first.second;\n\t\t\t\t\t\tpritnf(\"%d\\n\", sum);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <array>\n#include <functional>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stdlib.h>\n#include <string>\n#include <vector>\n\n#define INF 1000000000\n#define MOD 1000000007\n#define ll long long\n#define rep(i,a,b) for(i = (a); i < (b); i++)\n#define bitget(a,b) (((a) >> (b)) & 1)\n#define vint vector<int>\n#define vvint vector<vector<int>>\n#define vsort(x) sort(x.begin(),x.end())\n\nusing int64 = uint64_t;\n\nusing namespace std;\ntemplate<typename T>\nT gcd(T m, T n)\n{\n\t// ?????°???0???????????´??????0?????????\n\tif ((0 == m) || (0 == n))\n\t\treturn 0;\n\n\twhile (m != n)\n\t{\n\t\tif (m > n) m = m - n;\n\t\telse         n = n - m;\n\t}\n\treturn m;\n}\nint a[101][4] = {};\nint w[101] = {};\nint64 cal(int n) {\n\tint64 ret;\n\tif (n == 0) {\n\t\treturn 1;\n\t}\n\telse if (w[n] != 0) {\n\t\treturn w[n];\n\t}\n\tint64 x, y;\n\tx = cal(a[n][2]);\n\ty = cal(a[n][3]);\n\tint64 temp = gcd(x*a[n][0], y*a[n][1]);\n\tret = x*y*a[n][1] / temp + y*x*a[n][0] / temp;\n\tw[n] = ret;\n\treturn ret;\n}\nint64 solve(int n){\n\tint64 ret;\n\tint now = 1;\n\tint64 temp;\n\twhile (now<=n) {\n\t\tif (w[now] == 0) {\n\t\t\ttemp = cal(now);\n\t\t}\n\t\telse {\n\t\t\tnow++;\n\t\t}\n\t}\n\tret = temp;\n\treturn ret;\n}\n\nint main() {\n\tint temp;\n\tint i, j, k;\n\tint n;\n\tcin >> n;\n\tlong long int ans;\n\twhile (n != 0) {\n\t\trep(i, 0, n) {\n\t\t\tcin >> a[i + 1][0] >> a[i + 1][1] >> a[i + 1][2] >> a[i + 1][3];\n\t\t\tif (temp=gcd<int>(a[i + 1][0], a[i + 1][1]) != 1) {\n\t\t\t\ta[i + 1][0] /= temp;\n\t\t\t\ta[i + 1][1] /= temp;\n\t\t\t}\n\t\t\tw[i] = 0;\n\t\t}\n\t\tans = solve(n);\n\t\tcout << ans << endl;\n\t\tcin >> n;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n\nll p[110], q[110], r[110], b[110];\nint par[110];\n\nll gcd(ll a, ll b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\n\nll lcm(ll a, ll b) {\n  return a / gcd(a, b) * b;\n}\n\nll rec(int s) {\n  if (s == 0) return 1;\n  ll LCM = lcm(p[s] * rec(r[s]), q[s] * rec(b[s]));\n  return LCM / p[s] + LCM / q[s];\n}\n\nint main(void) {\n  int n;\n  while (cin >> n, n) {\n    fill(par, par + 110, -1);\n    for (int i = 1; i <= n; i++) {\n      cin >> p[i] >> q[i] >> r[i] >> b[i];\n      if (r[i]) par[r[i]] = i;\n      if (b[i]) par[b[i]] = i;\n    }\n\n    for (int i = 1; i <= n; i++) {\n      if (par[i] > 0) continue;\n      cout << rec(i) << endl;\n    }\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nll gcd(ll x, ll y)\n{    return y ? gcd(y, x % y) : x;\t}\n\nll lcm(ll x, ll y)\n{\treturn x * y / gcd(x, y);\t}\n\nclass Q\n{\npublic:\n\tint d, n;\n\t\n\tQ() : d(0), n(0) { }\n\tQ(int d, int n) : d(d), n(n) { }\n\t\n\tQ operator + (Q x)\n\t{\n\t\tif(d == 0 || n == 0) return x;\n\t\tif(x.d == 0 || x.n == 0) return *this;\n\t\treturn Q(d * x.n + n * x.d, n * x.n).reduce();\n\t}\n\t\n\tQ operator - (Q x)\n\t{\n\t\tif(d == 0 || n == 0) return x;\n\t\tif(x.d == 0 || x.n == 0) return *this;\n\t\treturn Q(d * x.n - n * x.d, n * x.n).reduce();\n\t}\n\n\tQ operator * (int x)\n\t{\treturn Q(d * x, n).reduce();\t}\n\t\n\tQ operator / (int x)\n\t{\treturn Q(d, n * x).reduce();\t}\n\t\n\tQ operator += (Q x)\n\t{\treturn (*this) = (*this) + x;\t}\n\t\n\tQ operator -= (Q x)\n\t{\treturn (*this) = (*this) - x;\t}\n\t\n\tQ reduce()\n\t{\n\t\tif(d == 0 || n == 0) return Q(0, 0);\n\t\t\n\t\tll gd = gcd(d, n);\n\t\t\n\t\treturn Q(d / gd, n / gd);\n\t}\n\t\n\tQ reciprocal()\n\t{\treturn Q(n, d);\t}\n};\n\nstruct Mobile\n{\n\tint p, q, r, b;\n\t\n\tvoid divid(vector<Mobile>& mobiles, vector<Q>& qs, Q x)\n\t{\n\t\tQ rw = x * p / (p + q), bw = x * q / (p + q);\n\t\t\n\t\tif(r == 0)\tqs.push_back(rw);\n\t\telse\t\tmobiles[r - 1].divid(mobiles, qs, rw);\n\t\t\n\t\tif(b == 0)\tqs.push_back(bw);\n\t\telse\t\tmobiles[b - 1].divid(mobiles, qs, bw);\n\t}\n};\n\nint main()\n{\n    int n;\n\twhile( cin >> n && n )\n\t{\n\t\tvector<Q> qs;\n\t\tvector<Mobile> mobiles(n);\n\t\tvector<bool> flags(n, false);\n\n\t\trep(i, n)\n\t\t{\n\t\t\tcin >> mobiles[i].p >> mobiles[i].q >> mobiles[i].r >> mobiles[i].b;\n\t\t\t\n\t\t\tif(mobiles[i].r != 0) flags[mobiles[i].r - 1] = true;\n\t\t\tif(mobiles[i].b != 0) flags[mobiles[i].b - 1] = true;\n\t\t}\n\t\t\t\tmobiles[min_element(ALL(flags)) - flags.begin()].divid(mobiles, qs, Q(1, 1));\n\t\t\n\t\tint lm = qs[0].n, res = 0;\n\t\t\n\t\tREP(i, 1, qs.size()) lm = lcm(lm, qs[i].n);\n\t\t\n\t\trep(i, qs.size()) res += (qs[i] * lm).d;\n\t\t\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<map>\n#include<cassert>\n#define F first\n#define S second\n#define PPins(a,b,c,d) PP(P(a,b),P(c,d))\n#define PPPins(a,b,c,d,e) PPP(a,PP(P(b,c),P(d,e)))\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\ntypedef pair<int,PP> PPP;\n\nmap<int,PP> tree;\nint top;\n\nint lcm(int a,int b)\n{\n  return a/__gcd(a,b)*b;\n}\n\nint rec(int n)\n{\n \n  int gcd = __gcd(tree[n].F.F,tree[n].F.S);\n  if(!tree[n].S.F && !tree[n].S.S)\n       return tree[n].F.F/gcd + tree[n].F.S/gcd;\n\n  if(tree[n].S.F && tree[n].S.S)\n    {\n      int Left = rec(tree[n].S.F);\n      int Right = rec(tree[n].S.S);\n   \n      return 2*lcm(tree[n].F.F/gcd*Left,tree[n].F.S/gcd*Right);\n\n    }\n\n  if(!tree[n].S.F && tree[n].S.S)\n    {      \n      int Right = rec(tree[n].S.S);\n      int rig   = tree[n].F.F/gcd*Right;\n      int Left = rig*(tree[n].F.S/gcd)/(tree[n].F.F/gcd);\n      return rig + Left;\n    }\n\n  if(tree[n].S.F && !tree[n].S.S)\n    {\n      int Left = rec(tree[n].S.F);\n      int lef   = tree[n].F.S/gcd*Left;\n      int Right = lef*(tree[n].F.F/gcd)/(tree[n].F.S/gcd);\n      return lef + Right;\n    }\n\n  assert(false);\n  return 0;\n}\n\nint main()\n{\n  int n;\n  while(true)\n    {\n      scanf(\"%d\",&n);\n      if(!n)\n\tbreak;\n      tree.clear();      \n      bool *who = new bool[n+1];\n      for(int i=0;i<n+1;i++)\n\twho[i] = false;\n      who[0] = true;\n      for(int i=0;i<n;i++)\n\t{\n\t  int p,q,r,b;\n\t  scanf(\"%d %d %d %d\",&p,&q,&r,&b);\n\t  tree[i+1] = PPins(p,q,r,b);\n\t  who[r] = who[b] = true;\n\t}\n\n      top = -1;\n      for(int i=1;i<n+1;i++)\n\tif(!who[i])\n\t  {\n\t    top = i;\n\t    break;\n\t  }\n      delete [] who;\n      assert(top != -1);\n      \n      printf(\"%d\\n\",rec(top));    \n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nstruct Bar{\n\tint llen,rlen,lbar,rbar,lwei,rwei;\n\tBar():lwei(0),rwei(0){}\n\tBar(int ll,int rl,int lb,int rb,int lw=0,int rw=0):llen(ll),rlen(rl),lbar(lb),rbar(rb),lwei(lw),rwei(rw){}\n};\n\nint gcd(int a,int b){return b?gcd(b,a%b):a;}\nint lcm(int a,int b){return a/gcd(a,b)*b;}\n\nvoid mul(vector<Bar>& bars,int root,int n)\n{\n\tBar& bar=bars[root];\n\tbar.lwei*=n;\n\tbar.rwei*=n;\n\tif(bar.lbar!=-1)\n\t\tmul(bars,bar.lbar,n);\n\tif(bar.rbar!=-1)\n\t\tmul(bars,bar.rbar,n);\n}\n\nint getweight(vector<Bar>& bars,int root)\n{\n\tBar& bar=bars[root];\n\tif(bar.lwei>0 && bar.rwei>0){\n\t\treturn bar.lwei+bar.rwei;\n\t}\n\telse if(bar.lbar==-1 && bar.rbar==-1){\n\t\tint x=lcm(bar.llen,bar.rlen);\n\t\tbar.lwei=x/bar.llen;\n\t\tbar.rwei=x/bar.rlen;\n\t}\n\telse if(bar.lbar==-1){\n\t\tint rwei=getweight(bars,bar.rbar);\n\t\tint x=lcm(bar.llen,bar.rlen*rwei);\n\t\tbar.lwei=x/bar.llen;\n\t\tbar.rwei=x/bar.rlen;\n\t\tmul(bars,bar.rbar,bar.rwei/rwei);\n\t}\n\telse if(bar.rbar==-1){\n\t\tint lwei=getweight(bars,bar.lbar);\n\t\tint x=lcm(bar.llen*lwei,bar.llen);\n\t\tbar.lwei=x/bar.llen;\n\t\tbar.rwei=x/bar.rlen;\n\t\tmul(bars,bar.lbar,bar.lwei/lwei);\n\t}\n\telse{\n\t\tint lwei=getweight(bars,bar.lbar);\n\t\tint rwei=getweight(bars,bar.rbar);\n\t\tint x=lcm(bar.llen*lwei,bar.rlen*rwei);\n\t\tbar.lwei=x/bar.llen;\n\t\tbar.rwei=x/bar.rlen;\n\t\tmul(bars,bar.lbar,bar.lwei/lwei);\n\t\tmul(bars,bar.rbar,bar.rwei/rwei);\n\t}\n\treturn bar.lwei+bar.rwei;\n}\n\nint main()\n{\n\tfor(int n;cin>>n,n;){\n\t\tvector<Bar> bars(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>bars[i].llen>>bars[i].rlen>>bars[i].lbar>>bars[i].rbar;\n\t\t\tbars[i].lbar--; bars[i].rbar--;\n\t\t}\n\t\tint root=-1;\n\t\t{\n\t\t\tvector<int> ischild(n);\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(bars[i].lbar!=-1)\n\t\t\t\t\tischild[bars[i].lbar]=1;\n\t\t\t\tif(bars[i].rbar!=-1)\n\t\t\t\t\tischild[bars[i].rbar]=1;\n\t\t\t}\n\t\t\tassert(find(ischild.begin(),ischild.end(),0)!=ischild.end());\n\t\t\troot=find(ischild.begin(),ischild.end(),0)-ischild.begin();\n\t\t}\n\t\t\n\t\tcout<<getweight(bars,root)<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nlong long int gcd(long long int a,long long int b){\n\tlong long int tmp;\n\twhile(b != 0ll){\n\t\ta -= b * (long long int)(a / b);\n\t\ttmp = a;\n\t\ta = b;\n\t\tb = tmp;\n\t}\n\treturn a;\n}\n\nint lcm(int a,int b){\n\tlong long int la = (long long int)a,lb = (long long int)b;\n\treturn la / gcd(la,lb) * lb;\n}\n\nstruct bou{\n\tint left,right;\n\tint lbou,rbou;\n};\n\nint main(){\n\tint n,res = 1;\n\tvector<bou> tree;\n\tint si[100],bo[100],par[100];\n\twhile(cin >> n,n){\n\ttree.clear();\n\tres = 1;\n\tfor(int i = 0;i < n;i++) {\n\t\tpar[i] = -1;\n\t\tsi[i] = 1;\n\t\tbo[i] = 1;\n\t}\n\tfor(int i = 0;i < n;i++){\n\t\tlong long int a,b;\n\t\tint c,d;\n\t\tcin >> a >> b >> c >> d;\n\t\ttree.push_back({a / gcd(a,b),b / gcd(a,b),c - 1,d - 1});\n\t\tif(c >= 1) par[c - 1] = i;\n\t\tif(d >= 1) par[d - 1] = i;\n\t}\n\tqueue<int> que;\n\tfor(int i = 0;i < n;i++) if(par[i] == -1) que.push(i);\n\twhile(!que.empty()){\n\t\tint q = que.front();que.pop();\n\t\t//cout << q;\n\t\tbou now = tree[q];\n\t\tlong long int bun[4];\n\t\tbun[0] = si[q] * now.right;\n\t\tbun[1] = bo[q] * (now.left + now.right);\n\t\tbun[2] = si[q] * now.left;\n\t\tbun[3] = bun[1];\n\t\tint g1 = gcd(bun[0],bun[1]),g2 = gcd(bun[2],bun[3]);\n\t\tbun[0] /= g1;\n\t\tbun[1] /= g1;\n\t\tbun[2] /= g2;\n\t\tbun[3] /= g2;\n\t\tif(now.lbou != -1){\n\t\t\tsi[now.lbou] = (int)bun[0];\n\t\t\tbo[now.lbou] = (int)bun[1];\n\t\t\tque.push(now.lbou);\n\t\t}else{\n\t\t\tres = lcm(res,(int)bun[1]);\n\t\t}\n\t\t//cout << \"k\" << endl;\n\t\tif(now.rbou != -1){\n\t\t\tsi[now.rbou] = (int)bun[2];\n\t\t\tbo[now.rbou] = (int)bun[3];\n\t\t\tque.push(now.rbou);\n\t\t}else{\n\t\t\tres = lcm(res,(int)bun[3]);\n\t\t}\n\t}\n\tcout << res << endl;\n\t}\n\treturn 0;\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define X real()\n#define Y imag()\nusing namespace std;\ntypedef complex<int> cld;\ntypedef vector<cld> vcl;\ntypedef vector<int> vi; \ntypedef long long ll;\nll lcs(ll p, ll q){\n\tif(max(p,q) % min(p,q) ==0)\n\treturn min(p,q);\n\telse\n\treturn lcs(max(p,q)-min(p,q),min(p,q));\n}\nll gcd(ll p,ll q){\n\treturn p*q/lcs(p,q);\n}\nint main() {\n\tint n;\n\twhile(cin >> n && n){\n\tbool fin[101]={1,0};\n\tll mobil[101][4]={};\n\tll grav[101]={1,0};\n\tll p,q,r,b;\n\tFOR(i,1,n+1){\n\t\tcin >> p >> q >> r >>b;\n\t\tll d=lcs(p,q);\n\t\tmobil[i][0]=p/d;\n\t\tmobil[i][1]=q/d;\n\t\tmobil[i][2]=r;\n\t\tmobil[i][3]=b;\n\t}\n\tint finishes=0;\n\twhile(finishes!=n){\n\t\tFOR(i,1,n+1)\n\t\t\tif(fin[mobil[i][2]] && fin[mobil[i][3]] && !fin[i]){\n\t\t\t\t\tgrav[i]=gcd(grav[mobil[i][2]],grav[mobil[i][3]])*(mobil[i][0]+mobil[i][1]);\n\t\t\t\t\tfin[i]=true;\n\t\t\t\t\tfinishes++;\n\t\t\t}\n\t}\n\tll sum=0;\n\tFOR(i,1,n+1)\n\tsum=max(sum,grav[i]);\n\tcout << sum << endl;\n\t}\n\t// your code goes here\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define int long long\n\n#define CHOOSE(a) CHOOSE2 a\n#define CHOOSE2(a0,a1,a2,a3,x,...) x\n#define REP1(i, s, cond, cal) for (signed i = signed(s); i cond; i cal)\n#define REP2(i, s, n) REP1(i, s, < signed(n), ++)\n#define REP3(i, n) REP2(i, 0, n)\n#define rep(...) CHOOSE((__VA_ARGS__,REP1,REP2,REP3))(__VA_ARGS__)\n#define rrep(i, s) rep(i, s, >= 0, --)\n\n#define all(c) begin(c), end(c)\ntemplate<typename T>bool maxup(T& a, const T&& b) { if (a < b) { a = b; return true; }; }\ntemplate<typename T>bool maxup(T& a, const T& b) { if (a < b) { a = b; return true; }; }\ntemplate<typename T>bool minup(T& a, const T&& b) { if (a > b) { a = b; return true; }; }\ntemplate<typename T>bool minup(T& a, const T& b) { if (a > b) { a = b; return true; }; }\n\n#define X first\n#define Y second\n\nusing VV = vector<vector<int>>;\nusing V = vector<int>;\nusing P = pair<int, int>;\nusing IP = pair<int, P>;\n\ntemplate<typename T>\ninline void input(vector<T>& v) { for (auto& x : v) cin >> x; }\n\n\nVV g;\nvector<P> len;\n\nint dfs(int now) {\n\tint a = g[now][0] >= 0 ? dfs(g[now][0]) : 1;\n\tint b = g[now][1] >= 0 ? dfs(g[now][1]) : 1;\n\tint p, q;\n\ttie(p, q) = len[now];\n\tint gcd = __gcd(a*p, b*q);\n\tint x = b*q / gcd;\n\tint y = a*p / gcd;\n\treturn a*x + b*y;\n}\n\nsigned main() {\n\tint n;\n\twhile (cin >> n&&n) {\n\t\tg.clear();\n\t\tg.resize(n);\n\t\tlen.clear();\n\t\tlen.resize(n);\n\t\tV root(n, true);\n\t\trep(i, n) {\n\t\t\tint p, q, r, b;\n\t\t\tcin >> p >> q >> r >> b;\n\t\t\tr--; b--;\n\t\t\tint gcd = __gcd(p, q);\n\t\t\tp = p / gcd;\n\t\t\tq = q / gcd;\n\t\t\tif (~r) root[r] = false;\n\t\t\tif (~b) root[b] = false;\n\t\t\tg[i].push_back(r);\n\t\t\tg[i].push_back(b);\n\t\t\tlen[i] = P(p, q);\n\t\t}\n\t\tint idx = find(all(root), true) - root.begin();\n\t\tcout << dfs(idx) << endl;\n\t}\n\n\tsystem(\"pause\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = uint32_t;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\nint lcm(int i, int j){\n    return i/__gcd(i, j)*j;\n}\n\nint main() {\n    int n;\n    while(cin >> n, n){\n        vector<int> L(n), R(n), S(n), T(n);\n        vector<vector<int>> G(n);\n        vector<int> dp(n), indeg(n);\n        for (int i = 0; i < n; ++i) {\n            int p, q, r, b;\n            scanf(\"%d %d %d %d\", &p, &q, &r, &b);\n            r--; b--;\n            L[i] = p, R[i] = q, S[i] = r, T[i] = b;\n            if(r < 0 && b < 0){\n                dp[i] = (p+q)/__gcd(p, q);\n            } else {\n                if(r >= 0) G[i].emplace_back(r), indeg[r]++;\n                if(b >= 0) G[i].emplace_back(b), indeg[b]++;\n            }\n        }\n        deque<int> Q;\n        stack<int> s;\n        int cnt = 0;\n        int x = min_element(indeg.begin(),indeg.end()) - indeg.begin();\n        vector<int> visited(n, 0), num(n);\n        s.emplace(x);\n        while(!s.empty()){\n            int a = s.top(); s.pop();\n            visited[a]++;\n            num[a] = cnt++;\n            if(!dp[a]) Q.emplace_front(a);\n            for (auto &&i : G[a]) {\n                if(!visited[i]) s.emplace(i);\n            }\n        }\n        while(!Q.empty()){\n            int i = Q.front(); Q.pop_front();\n            if(S[i] < 0){\n                int j = T[i];\n                dp[i] = lcm(dp[j]*R[i], L[i])/L[i]+ lcm(dp[j]*R[i], L[i])/R[i];\n            }else if(T[i] < 0){\n                int j = S[i];\n                dp[i] = lcm(dp[j]*L[i], R[i])/L[i]+ lcm(dp[j]*L[i], R[i])/R[i];\n            }else {\n                dp[i] = lcm(dp[S[i]]*L[i], dp[T[i]]*R[i])/L[i]+lcm(dp[S[i]]*L[i], dp[T[i]]*R[i])/R[i];\n            }\n        }\n        cout << dp[x] << \"\\n\";\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nlong long int gcd( long long int a, long long int b ) {\n  return b ? gcd( b, a % b ) : a ;\n}\nlong long int lcm( long long int m, long long int n ) {\n  if ( m == 0 || n == 0 ) return 0;\n  return ( ( m / gcd( m, n ) ) * n );\n}\n\nint main() {\n\n  while( true ) {\n\n    long long int n;\n    cin >> n;\n    if ( n == 0 ) break;\n\n    vector< long long int > p, q, r, b;\n    for ( long long int i = 0; i < n; i++ ) {\n      long long int in_p, in_q, in_r, in_b;\n      cin >> in_p >> in_q >> in_r >> in_b;\n      p.push_back( in_p );\n      q.push_back( in_q );\n      r.push_back( in_r );\n      b.push_back( in_b );\n    }\n\n    for ( long long int i = 0; i < n; i++ ) {\n      for ( long long int j = 0; j < n; j++ ) {\n\n\tif ( r[j] <= 0 && b[j] <= 0 ) {\n\n\t  if ( r[j] == 0 ) {\n\t    r[j] = 1;\n\t  }else {\n\t    r[j] = -r[j];\n\t  }\n\t  long long int r2 = r[j] * p[j];\n\t  if ( b[j] == 0 ) {\n\t    b[j] = 1;\n\t  }else {\n\t    b[j] = -b[j];\n\t  }\n\t  long long int b2 = b[j] * q[j];\n\t  long long int h = lcm( r2, b2 ) / p[j] + lcm( r2, b2 ) / q[j];\n\n\t  r[j] = n + 2;\n\t  b[j] = n + 2;\n\n\t  cout << i << \" \" << j << \" \" << h << endl;\n\n\t  for ( long long int k = 0; k < n; k++ ) {\n\t    if ( i == n - 1 ) {\n\t      cout << h << endl;\n\t      break;\n\t    }\n\t    if ( r[k] == j + 1 ) {\n\t      r[k] = -h;\n\t      break;\n\t    }\n\t    if ( b[k] == j + 1 ) {\n\t      b[k] = -h;\n\t      break;\n\t    }\n\t  }\n\t  break;\n\n\t}\n\n      }\n    }\n\n  }\n\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nll gcd(ll a, ll b) {\n  return b != 0 ? gcd(b, a % b) : a;\n}\n\nconst ll WEIGHT=-1;\nstruct stick{\n\tll r,b,p,q;\n\tstick(ll r,ll b,ll p,ll q):r(r),b(b){\n\t\tll g=gcd(p,q);\n\t\tthis->p=p/g;\n\t\tthis->q=q/g;\n\t}\n\tll getroot(ll index,vector<stick> &sticks){\n\t\tREP(i,sticks.size()){\n\t\t\tif(sticks[i].r==index||sticks[i].b==index){\n\t\t\t\treturn sticks[i].getroot(i,sticks);\n\t\t\t}\n\t\t}\n\t\treturn index;\n\t}\n\tll go(vector<stick> &sticks){\n\t\tll rw=0,bw=0;\n\t\tif(r!=WEIGHT){\n\t\t\trw=sticks[r].go(sticks);\n\t\t}\n\t\tif(b!=WEIGHT){\n\t\t\tbw=sticks[b].go(sticks);\n\t\t}\n\t\tif(r==WEIGHT&&b==WEIGHT){\n\t\t\trw=q;\n\t\t\tbw=p;\n\t\t}else if(r==WEIGHT){\n\t\t\tif(p*bw%q){\n\t\t\t\trw=bw*p;\n\t\t\t\tbw*=q;\n\t\t\t}else{\n\t\t\t\trw=bw*p/q;\n\t\t\t\tassert(bw);\n\t\t\t}\n\t\t}else if(b==WEIGHT){\n\t\t\tif(q*rw%p){\n\t\t\t\tbw=rw*q;\n\t\t\t\trw*=p;\n\t\t\t}else{\n\t\t\t\tbw=rw*q/p;\n\t\t\t\tassert(rw);\n\t\t\t}\n\t\t}else{\n\t\t\tll trw=rw,tbw=bw;\n\t\t\trw*=p;\n\t\t\tbw*=q;\n\t\t\tll g=gcd(rw,bw);\n\t\t\trw=trw*tbw/g/p;\n\t\t\tbw=tbw*trw/g/q;\n\t\t}\n\t\tassert(rw&&bw);\n\t\treturn rw+bw;\n\t}\n};\n\n\nint main(){\n\tll n;\n\twhile(cin>>n,n){\n\t\tvector<stick> sticks;\n\t\tREP(i,n){\n\t\t\tll p,q,r,b;\n\t\t\tcin>>p>>q>>r>>b;\n\t\t\tr--;b--;\n\t\t\tsticks.push_back(stick(r,b,p,q));\n\t\t}\n\t\tll root=sticks[0].getroot(0,sticks);\n\t\tcout<<sticks[root].go(sticks)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<cstdio>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<iostream>\n#include<map>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<int(n);i++)\n#define reps(i,n) for(int i=1;i<=int(n);i++)\n\ntypedef long long ll;\nclass T{\npublic:\n  int f;\n  int s;\n  int r;\n  int l;\n};\n\nT tree[101];\n\nll sk(ll a,ll b){\n  ll nx,nm;\n  nx=a;\n  nm=b;\n  if(a<b){\n    swap(a,b);\n  }\n  while(1){\n    if(a%b==0)break;\n    ll temp;\n    temp=b;\n    b=a%b;\n    a=temp;\n  }\n  return nx/b*nm;\n}\nll saiki(ll num){\n  ll a=1,b=1;\n  if(tree[num].f!=0){\n    a=saiki(tree[num].f);\n  }\n  if(tree[num].s!=0){\n    b=saiki(tree[num].s);\n  }\n\n  ll nn=sk(tree[num].r*a,tree[num].l*b);\n  return nn/tree[num].r + nn/tree[num].l;\n}\nint main(){\n  while(1){\n  int n;\n  scanf(\"%d\",&n);\n  if(n==0)break;\n  int get[111];\n  reps(i,n){\n    get[i]=0;\n  }\n  reps(i,n){\n    int a,b,c,d;\n    scanf(\"%d%d%d%d\",&a,&b,&c,&d);\n    tree[i].r=a;\n    tree[i].l=b;\n    tree[i].f=c;\n    tree[i].s=d;\n    get[c]=get[d]=1;\n  }\n  int st=-1;\n  reps(i,n){\n    if(get[i]==0){\n      st=i;\n    }\n  }\n  ll ans=saiki(st);\n  printf(\"%lld\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint n;\nint a[100][2],p[100][2];\nbool cal[100];\nint GCD(int x,int y){\n\twhile(true){\n\t\tif(y>x){int t=x;x=y,y=t;}\n\t\tx%=y;\n\t\tif(!x)break;\n\t}\n\treturn y;\n}\nint DFS(int x){\n\tif(!x)return 1;\n\tx--;\n\tint b=DFS(p[x][0]),c=DFS(p[x][1]);\n\tint s=b*a[x][0]*c*a[x][1]/GCD(b*a[x][1],c*a[x][0]);\n\treturn s/a[x][0]+s/a[x][1];\n}\nint main(){\n\twhile(true){\n\tcin>>n;\n\tif(!n)break;\n\tfor(int i=0;i<n;i++)cal[i]=true;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>a[i][0]>>a[i][1];\n\t\tint t=GCD(a[i][0],a[i][1]);\n\t\ta[i][0]/=t,a[i][1]/=t;\n\t\tcin>>p[i][0]>>p[i][1];\n\t\tcal[p[i][0]-1]=false,cal[p[i][1]-1]=false;\n\t}\n\tfor(int i=0;i<n;i++)if(cal[i])cout<<DFS(i+1)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps = 1e-9;\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.txt\"\n\nlong long int gcd(long long int l, long long int r) {\n\tassert(l > 0 && r > 0);\n\tif (l > r)return gcd(r, l);\n\telse {\n\t\tconst long long int num = r%l;\n\t\tif (num) {\n\t\t\treturn gcd(l, num);\n\t\t}\n\t\telse {\n\t\t\treturn l;\n\t\t}\n\t}\n}\nlong long int lca(long long int l, long long int r) {\n\treturn l / gcd(l, r)*r;\n}\n\nstruct mobi {\n\tlong long int a;\n\tlong long int b;\n\tint lid;\n\tint rid;\n\n};\n\nlong long int getans(const int id,const vector<mobi>&ms) {\n\tlong long int lw=0, rw=0;\n\tif (ms[id].lid!=-1) {\n\t\tlw = getans(ms[id].lid, ms);\n\t}\n\telse {\n\t\tlw = 1;\n\t}\n\tif (ms[id].rid != -1) {\n\t\trw = getans(ms[id].rid, ms);\n\t}\n\telse {\n\t\trw = 1;\n\t}\n\tlong long int al = lw*ms[id].a;\n\tlong long int ar = rw*ms[id].b;\n\tlong long int alca = lca(al, ar);\n\treturn alca / al*lw + alca / ar*rw;\n}\n\nint main() {\n\twhile (1) {\n\t\tint N; cin >> N;\n\t\tif (!N)break;\n\t\tvector<mobi>ms;\n\t\tvector<int>pas(N);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tlong long int a, b;int lid, rid; cin >> a >> b >> lid >> rid;\n\t\t\tlid--; rid--;\n\t\t\tif (lid != -1)pas[lid] = true;\n\t\t\tif (rid != -1)pas[rid] = true;\n\t\t\tconst long long int agcd = gcd(a, b);\n\t\t\ta /= agcd; b /= agcd;\n\t\t\tms.push_back(mobi{ a,b,lid,rid });\n\t\t}\n\t\tint nopa = find(pas.begin(), pas.end(), 0) - pas.begin();\n\t\tlong long int ans = getans(nopa, ms);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,p[101],q[101],r[101],b[101];\nint memo[101];\nint dp(int a){\n  if(memo[a] != -1) return memo[a];\n  if(r[a] == 0 && b[a] == 0) return memo[a] = p[a] + q[a];\n  int red,blue;\n  if(r[a] == 0){\n    red = q[a];\n    blue = dp(b[a]);\n  } else if(b[a] == 0){\n    blue = p[a];\n    red = dp(r[a]);\n  } else {\n    red = dp(r[a]);\n    blue = dp(b[a]);\n  }\n  red *= (q[a] / __gcd(red,q[a]));\n  blue *= (p[a] / __gcd(blue,p[a]));\n  int m = (blue/p[a])*(red/q[a])/__gcd(blue/p[a],red/q[a]);\n  return memo[a] = m*(p[a]+q[a]);\n}\nint main(){\n  while(scanf(\"%d\",&n),n!=0){\n    fill(memo,memo+101,-1);\n    for(int i=1;i<=n;i++){\n      scanf(\"%d %d %d %d\",&p[i],&q[i],&r[i],&b[i]);\n      int m = __gcd(p[i],q[i]);\n      p[i] /= m;\n      q[i] /= m;\n    }\n    int ans = 0;\n    for(int i=1;i<=n;i++){\n      ans = max(ans,dp(i));\n    }\n    printf(\"%d\\n\",ans);\n  }\n  return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint dp[110],K[110],O[110],L[110],R[110];\n\nint gcd(int a,int b){\n\tint tmp;\n\twhile((a%b)!=0){\n\t\ttmp=a%b;\n\t\ta=b;\n\t\tb=tmp;\n\t}\n\treturn b;\n}\n\n\nint mobi(int bou){\n\tif(bou==0) return 1;\n\tif(dp[bou]!=0) return dp[bou];\n\tint l,r,li,ri,gc,gc2,a,b;\n\tl=mobi(L[bou]);\n\tr=mobi(R[bou]);\n\tri=K[bou];li=O[bou];\n\tgc=gcd(li,ri);\n\tli/=gc;ri/=gc;\n\tgc2=gcd(li*l,ri*r);\n\tb=li*l/gc2;\n\ta=ri*r/gc2;\n\tdp[bou]=(a*l+b*r);\n\treturn dp[bou];\n}\n\nint main(){\n\tint N,res;\n\twhile(1){\n\t\tcin>>N;\n\t\tif(N==0) break;\n\t\tmemset(dp,0,sizeof(dp));\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tcin>>K[i]>>O[i]>>L[i]>>R[i];\n\t\t}\n\t\tres=0;\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tres=max(res,mobi(i));\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef double db;\n\n#define fr first\n#define sc second\n#define pb push_back\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define rep1(i,x) for(ll i=1;i<=x;i++)\n#define rrep(i,x) for(ll i=x-1;i>=0;i--)\n#define rrep1(i,x) for(ll i=x;i>0;i--)\n\nll n;\nll bar[101][4];\n\nll gcd(ll a,ll b){\n\tif(b==0) return a;\n\treturn gcd(b,a%b);\n}\nll dp[101];\nll rec(ll x){\n\tif(dp[x]) return dp[x];\n\tll lef=1,rig=1;\n\tif(bar[x][2]!=0) lef=rec(bar[x][2]);\n\tif(bar[x][3]!=0) rig=rec(bar[x][3]);\n\tll a=bar[x][1]*lef;\n\tll b=bar[x][0]*rig;\n\tll div=gcd(a,b);\n\ta/=div;\n\tb/=div;\n\treturn dp[x]=a*rig+b*lef;\n}\n\nint main()\n{while(1){\n\tll ans=0;\n\tmemset(dp,0,sizeof(dp));\n\tcin>>n;\n\tif(!n) return 0;\n\trep1(i,n){\n\t\trep(j,4) cin>>bar[i][j];\n\t}\n\trep1(i,n){\n\t\tans=max(ans,rec(i));\n\t}\n\tcout<<ans<<endl;\n}}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <cstring>\nusing namespace std;\n\nunsigned int dp[110],K[110],O[110],L[110],R[110];\n\nunsigned int gcd(unsigned int a,unsigned int b){\n\tif(a<b) swap(a,b);\n\tunsigned int tmp;\n\twhile((a%b)!=0){\n\t\ttmp=a%b;\n\t\ta=b;\n\t\tb=tmp;\n\t}\n\treturn b;\n}\n\n\nunsigned int mobi(unsigned int bou){\n\tif(bou==0) return 1;\n\tif(dp[bou]!=0) return dp[bou];\n\tunsigned int l,r,li,ri,gc,gc2,a,b;\n\tl=mobi(L[bou]);\n\tr=mobi(R[bou]);\n\tri=K[bou];li=O[bou];\n\tgc=gcd(li,ri);\n\tli/=gc;ri/=gc;\n\tgc2=gcd(li*l,ri*r);\n\tb=li*l/gc2;\n\ta=ri*r/gc2;\n\tdp[bou]=(a*l+b*r);\n\treturn dp[bou];\n}\n\nint main(){\n\tint N;\n\tunsigned int res;\n\twhile(1){\n\t\tcin>>N;\n\t\tif(N==0) break;\n\t\tmemset(dp,0,sizeof(dp));\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tcin>>K[i]>>O[i]>>L[i]>>R[i];\n\t\t}\n\t\tres=0;\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tres=max(res,mobi(i));\n\t\t}\n\t\t/*\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tcout<<i<<\" \"<<dp[i]<<endl;//\n\t\t}\n\t\t*/\n\t\tcout<<res<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define EQ(a,b) (abs((a)-(b))<EPS)\nint n;\nint r[101],b[101];\nint memo[101];\nP h[101];\nint ans;\nint rec(int s)\n{\n    if(memo[s]>0)return memo[s];\n    if(r[s]==0&&b[s]==0)\n    {\n        memo[s]=h[s].fi+h[s].sec;\n        return memo[s];\n    }\n    else if(r[s]==0&&b[s]!=0)\n    {\n        memo[s]=rec(b[s])/__gcd(h[s].fi,rec(b[s]))*(h[s].fi+h[s].sec);\n        return memo[s];\n    }\n    else if(r[s]!=0&&b[s]==0)\n    {\n        memo[s]=rec(r[s])/__gcd(h[s].sec,rec(r[s]))*(h[s].fi+h[s].sec);\n        return memo[s];\n    }\n    else\n    {\n        int tp,tq;\n        tp=h[s].fi;tq=h[s].sec;\n        int k=rec(b[s])/__gcd(rec(b[s]),tp);\n        tp*=k;tq*=k;\n        k=rec(r[s])/__gcd(rec(r[s]),tq);\n        tp*=k;\n        tq*=k;\n        memo[s]=tp+tq;\n        return memo[s];\n    }\n}\nint main()\n{\n    while(1)\n    {\n        memset(r,0,sizeof(r));\n        memset(b,0,sizeof(b));\n        memset(memo,0,sizeof(memo));\n        ans=0;\n        for(int i=0;i<101;i++)\n        {\n            h[i].fi=0;\n            h[i].sec=0;\n        }\n        cin >> n;\n        if(n==0)break;\n        for(int i=1;i<=n;i++)\n        {\n            int p,q,re,bl;\n            cin >> p >> q >> re >> bl;\n            int k=__gcd(p,q);\n            p/=k;\n            q/=k;\n            h[i]=mp(p,q);\n            r[i]=re;\n            b[i]=bl;\n        }\n        for(int i=1;i<=n;i++)\n        {\n            ans=max(ans,rec(i));\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\nstruct mob {\n    int l, r, a, b;\n    mob () {}\n    mob (int l, int r, int a, int b) : l(l),r(r),a(a),b(b) {}\n};\nll gcd(ll a, ll b) { return b?gcd(b,a%b):a; }\nll lcm(ll a, ll b) { return a*b/gcd(a,b); }\n\nvector<int> to[100];\nmob mobs[100];\nint n;\n\nll dfs(int id) {\n    ll a=1, b=1;\n    if (mobs[id].a!=-1) a=dfs(mobs[id].a);\n    if (mobs[id].b!=-1) b=dfs(mobs[id].b);\n    a*=mobs[id].r; b*=mobs[id].l;\n//    printf(\"%lld %lld\\n\",a,b);\n    ll x=lcm(a,b);\n    return x/mobs[id].r+x/mobs[id].l;\n}\n\nint main() {\n    while (scanf(\"%d\",&n)) {\n        if (!n) break;\n        for (int i=0; i<101; i++) {\n            to[i].clear();\n        }\n        for (int i=0; i<n; i++) {\n            int l, r, a, b; scanf(\"%d%d%d%d\",&l,&r,&a,&b);\n            ll g=gcd(l,r); l/=g; r/=g;\n            mobs[i]=mob(l,r,a-1,b-1);\n            if (a) to[a-1].push_back(i);\n            if (b) to[b-1].push_back(i);\n        }\n        ll res=0;\n        for (int i=0; i<n; i++) {\n            if (to[i].size()==0) {\n                res=dfs(i);\n                break;\n            }\n        }\n        printf(\"%lld\\n\",res);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long int L;\n\nL gcd(L a, L b){\n    if(a<b) swap(a,b);\n    while(a%b){\n        L t = b;\n        b = a%b;\n        a = t;\n    }\n    return b;\n}\n\nstruct B{\n    L ral;\n    L rar;\n    B* left;\n    B* right; B* parent; B(){ ral = -1;\n        rar = -1;\n        left = NULL;\n        right = NULL;\n        parent = NULL;\n    }\n};\n\nvoid rec(B* p, L*& l,L n){\n    if( p->left ){\n        rec(p->left, l, n*(p->ral)/(p->ral+p->rar));\n    }else{\n        *l = n*(p->ral)/(p->ral+p->rar);\n        l++;\n    }\n    if( p->right ){\n        rec(p->right, l, n*(p->rar)/(p->ral+p->rar));\n    }else{\n        *l = n*(p->rar)/(p->ral+p->rar);\n        l++;\n    }\n\n}\n\nint main(){\n    L n,i,a,b,c,d,t,m,g,s;\n    for(;cin>>n,n;){\n        B v[110];\n        m=1;\n        for(i=0;i<n;i++){\n            cin>>a>>b>>c>>d;\n            t = gcd(a,b);\n            v[i].ral = b/t;\n            v[i].rar = a/t;\n            m *= b/t+a/t;\n            if( c ){\n                v[i].left = &v[--c];\n                v[c].parent = &v[i];\n            }\n            if( d ){\n                v[i].right = &v[--d];\n                v[d].parent = &v[i];\n            }\n        }\n        B* rt = v;\n        while( rt->parent ) rt = rt->parent;\n        L leaf[110];\n        L* ptr = leaf;\n        rec(rt, ptr, m);\n        g = leaf[0];\n        for(i=1;leaf[i]&&i<n+1;i++){\n            g = gcd(g,leaf[i]);\n        }\n        s=0;\n        for(i=0;i<n+1;i++){\n            s += leaf[i]/g;\n        }\n        cout << s << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nint gcd(int a,int b){\n    if(b==0)return a;\n    return gcd(b,a%b);\n    }  \n    int lcm(int a,int b){return a*b/gcd(a,b);}\nstruct bou{\n    int l,r,x,y;\n    };\n    int n[100];bou m[101];\nint mincost(int a){\n    if(n[a-1]!=-1)return n[a-1];\n    int b=1,c=1;\n    if(m[a].x)b=mincost(m[a].x);\n    if(m[a].y)c=mincost(m[a].y);\n    n[a-1]=lcm(b,c)*(m[a].l+m[a].r);\n    return lcm(b,c)*(m[a].l+m[a].r);\n    }\nsigned main(){\n   int a;\n   while(cin>>a,a){\n       memset(n,-1,sizeof(n));\n       bou g;\n       for(int b=1;b<=a;b++){\n\t   int c,d;\n\t  scanf(\"%lld%lld%lld%lld\",&c,&d,&g.x,&g.y);\n\t  g.l=c/gcd(c,d);g.r=d/gcd(c,d);\n\t  m[b]=g;\n\t   }\n\t for(int i=0;i<a;i++){\n\t     if(n[i]==-1)mincost(i+1);\n\t     }  \n\t     int MAX=0;\n\tfor(int i=0;i<a;i++){\n\t     MAX=max(MAX,n[i]);\n\t    }  \n\t    cout<<MAX<<endl;\n       }\n    }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i = (a); i < (b); i++)\n#define REP(i,n) FOR(i,0,n)\n\ntypedef long long ll;\n\nstruct Node {\n\tint a, b, ma, mb;\n\t\n\tNode() {}\n\tNode(int a, int b, int ma, int mb) : a(a), b(b), ma(ma), mb(mb) {}\n};\n\nint n;\nNode node[100];\nbool istop[100];\n\nint gcd(int a, int b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a % b);\n}\n\nint dfs(int pos) {\n\tNode &now = node[pos];\n\t\n\tint a = now.a, b = now.b, ma = now.ma, mb = now.mb;\n\t\n\tif (ma != 0) ma = dfs(ma - 1);\n\tif (mb != 0) mb = dfs(mb - 1);\n\t\n\tif (ma == 0 && mb == 0) {\n\t\treturn a + b;\n\t\n\t} else if (ma == 0 || mb == 0) {\n\t\tif (ma == 0) swap(ma, mb);\n\t\treturn ma * (a + b);\n\t\t\n\t}\n\telse {\n\t\tcout << a << \" \" << b << \" \" << ma << \" \" << mb << endl;\n\t\tint x = gcd(a * ma, b * mb);\n\t\tint res1 = mb * (a * ma / x);\n\t\tint res2 = ma * (b * mb / x);\n\t\treturn res1 + res2;\n\t}\n}\n\nint main() {\n\twhile (cin >> n, n) {\n\t\t\n\t\tfill(istop, istop + n, false);\n\t\tREP(i, n) {\n\t\t\tint a, b, ma, mb;\n\t\t\tscanf(\"%d %d %d %d\", &a, &b, &ma, &mb);\n\t\t\tint g = gcd(a, b);\n\t\t\ta /= g; b /= g;\n\t\t\tnode[i] = Node(a, b, ma, mb);\n\t\t\t\n\t\t\tif (ma != 0) istop[ma - 1] = true;\n\t\t\tif (mb != 0) istop[mb - 1] = true;\n\t\t}\n\t\t\n\t\tint st = 0;\n\t\twhile (istop[st]) st++;\n\t\tcout << dfs(st) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<queue>\nusing namespace std;\nstruct Stick{\n    int p,q,r,b;\n};\nStick s[101];\nint tsurami(int a,int b){\n    if(b==0) return a;\n    else return tsurami(b,a%b);\n}\nint solve(int n){\n    if(n==0) return 1;\n    int pq_gcd = tsurami(s[n].p,s[n].q);\n    s[n].p /= pq_gcd;\n    s[n].q /= pq_gcd;\n    int a = solve(s[n].r),\n        b = solve(s[n].b);\n    if(s[n].p*a==s[n].q*b) return a+b;\n    int ab_gcd = tsurami(a,b);\n    return (a*b/ab_gcd)*(s[n].p+s[n].q);\n}\nint main(){\n    int N;\n    while(cin>>N,N){\n        int par;\n        bool cnt[101]={};\n        for(int i=1;i<=N;i++){\n        cin>>s[i].p>>s[i].q>>s[i].r>>s[i].b;\n        cnt[s[i].r]=cnt[s[i].b]=true;\n        }\n        for(int i=1;i<=N;i++){\n            if(cnt[i]==false){\n                par = i;\n                break;\n            }\n        }\n        printf(\"%d\\n\",solve(par));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <map>\n#include <stack>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define ALL(c) c.begin(),c.end()\n#define RALL(c) c.rbegin(),c.rend()\n#define REP(type,i,n) for(type i=0;i<(n);++i)\n#define MP(a,b) make_pair((a),(b))\n\ntypedef long long int lli;\ntypedef pair<int,int> P;\n\nconst int INF=100000000;\nconst long long int INF_=1000000000000000000;\n\nlli Gcd(lli a,lli b){\n\tif(b==0) return a;\n\treturn Gcd(b,a%b);\n}\n\nlli Lcm(lli a,lli b){\n\treturn a/Gcd(a,b)*b;\n}\n\nclass Bar{\n\tpublic:\n\tint p,q,r,b,parent;\n\tbool exists,is_leaf;\n\tBar():parent(-1),exists(false),is_leaf(false){}\n\tvoid Init(int a,int b,int c,int d,bool e);\n};\n\nvoid Bar::Init(int a,int bb,int c,int d,bool e){\n\tp=a; q=bb; r=c; b=d; exists=e;\n}\n\nint Find(vector<Bar> &m,int n){\n\tif(m[n].parent==-1) return n;\n\treturn Find(m,m[n].parent);\n}\n\nvoid Pre(vector<Bar> &m,int n){\n\tif(m[n].r==-1&&m[n].b==-1){\n\t\tm[n].is_leaf=true;\n\t\treturn;\n\t}\n\tif(m[n].r!=-1) Pre(m,m[n].r);\n\tif(m[n].b!=-1) Pre(m,m[n].b);\n}\n\nlli DFS(const vector<Bar> &m,int n){\n\tif(m[n].is_leaf) return Lcm(m[n].p,m[n].q)/m[n].p+Lcm(m[n].p,m[n].q)/m[n].q;\n\tlli a,b;\n\tif(m[n].r==-1) a=Lcm(m[n].p,m[n].q)/m[n].p;\n\telse a=DFS(m,m[n].r);\n\tif(m[n].b==-1) b=Lcm(m[n].p,m[n].q)/m[n].q;\n\telse b=DFS(m,m[n].b);\n\treturn a*Lcm(a*m[n].p,b*m[n].q)/(m[n].p*a)+b*Lcm(a*m[n].p,b*m[n].q)/(m[n].q*b);\n}\n\nint main(){\n\tint N;\n\twhile(cin >> N&&N){\n\t\tvector<Bar> mobile(100);\n\t\tREP(int,i,N){\n\t\t\tint p,q,r,b;\n\t\t\tcin >> p >> q >> r >> b; //p:q,左の棒の番号、右の棒の番号\n\t\t\t--r;\n\t\t\t--b;\n\t\t\tmobile[i].Init(p,q,r,b,true);\n\t\t\tif(r!=-1) mobile[r].parent=i;\n\t\t\tif(b!=-1) mobile[b].parent=i;\n\t\t}\n\t\tint parent=-1;\n\t\tREP(int,i,100){\n\t\t\tif(mobile[i].exists){\n\t\t\t\tparent=Find(mobile,i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tPre(mobile,parent);\n\t\tlli ans=DFS(mobile,parent);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint n;\nint a[100][2],p[100][2];\nbool cal[100];\nint GCD(int x,int y){\n\twhile(true){\n\t\tif(y>x){int t=x;x=y,y=t;}\n\t\tx%=y;\n\t\tif(x<2)break;\n\t}\n\treturn y;\n}\nint DFS(int x){\n\tif(!x)return 1;\n\tcout<<x<<endl;\n\tx--;\n\tint b=DFS(p[x][0]),c=DFS(p[x][1]);\n\tint s=b*a[x][0]*c*a[x][1]/GCD(b*a[x][1],c*a[x][0]);\n\treturn s/a[x][0]+s/a[x][1];\n}\nint main(){\n\twhile(true){\n\tcin>>n;\n\tif(!n)break;\n\tfor(int i=0;i<n;i++)cal[i]=true;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>a[i][0]>>a[i][1];\n\t\tint t=GCD(a[i][0],a[i][1]);\n\t\ta[i][0]/=t,a[i][1]/=t;\n\t\tcin>>p[i][0]>>p[i][1];\n\t\tcal[p[i][0]-1]=false,cal[p[i][1]-1]=false;\n\t}\n\tfor(int i=0;i<n;i++)if(cal[i])cout<<DFS(i+1)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\ntypedef unsigned long long ull;\null gcd(ull x, ull y) {\n\tif (y == 0) return x;\n\treturn gcd(y, x % y);\n}\null lcm(ull x, ull y) {\n\treturn x / gcd(x, y) * y;\n}\nint n, a[111], b[111], vis[111]; ull x[111], y[111];\null solve(int pos) {\n\tif (pos == -1) return 1;\n\tull l = solve(a[pos]) * x[pos];\n\tull r = solve(b[pos]) * y[pos];\n\tull t = lcm(l, r);\n\treturn t / x[pos] + t / y[pos];\n}\nint main() {\n\twhile (cin >> n, n) {\n\t\tfill(vis, vis + n, 0);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> x[i] >> y[i] >> a[i] >> b[i]; a[i]--, b[i]--;\n\t\t\tif (a[i] != -1) vis[a[i]] = 1;\n\t\t\tif (b[i] != -1) vis[b[i]] = 1;\n\t\t\tull r = gcd(x[i], y[i]);\n\t\t\tx[i] /= r, y[i] /= r;\n\t\t}\n\t\tint root = find(vis, vis + n, 0) - vis;\n\t\tcout << solve(root) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <iomanip>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> P;\n\nint p[101]={};\nint q[101]={};\nint r[101]={};\nint s[101]={};\nint gcd(int a, int b){\n\twhile(b){\n\t\tint r=a%b;\n\t\ta=b;\n\t\tb=r;\n\t}\n\treturn a;\n}\nint cal(int i){\n\tif(i==0){\n\t\treturn 1;\n\t}\n\tint a=cal(r[i]);\n\tint b=cal(s[i]);\n\tint g=gcd(a*q[i],b*p[i]);\n\tint v=a*q[i]/g*b+b*p[i]/g*a;\n\t//cout << i << \", \" << v << endl;\n\treturn v;\n}\nint main() {\nwhile(1){\n\tint n;\n\tcin >> n;\n\tif(n==0)return 0;\n\tint hasParent[101]={};\n\tfor(int i=1;i<=n;i++){\n\t\tcin >> p[i] >> q[i] >> r[i] >> s[i];\n\t\thasParent[r[i]]=true;\n\t\thasParent[s[i]]=true;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tif(!hasParent[i]){\n\t\t\tcout << cal(i) << endl;\n\t\t}\n\t}\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 101\nusing namespace std;\ntypedef long long ll;\nll n,p[N],q[N],r[N],b[N];\nbool s[N];\n\nll func(int x){\n  ll R=1,B=1;\n  if(r[x]) R=func(r[x]);\n  if(b[x]) B=func(b[x]);\n  ll k=__gcd(R*p[x],B*q[x]);\n  ll a=(R*p[x])/k,e=(B*q[x])/k;\n  return (R*e)+(B*a);\n}\n\nint main(){\n  while(cin>>n,n){\n    memset(s,0,sizeof(s));\n    for(int i=1;i<=n;i++){\n      cin>>p[i]>>q[i]>>r[i]>>b[i];\n      ll res=__gcd(p[i],q[i]);\n      p[i]/=res,q[i]/=res;\n      s[r[i]]=s[b[i]]=true;\n    }\n    for(int i=1;i<=n;i++)\n      if(!s[i])cout<<func(i)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\ntypedef long long ll;\n\nll n, p[100], q[100], r[100], b[100];\nbool isTop[100];\n\nll gcd(ll a, ll b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\n\nll check(ll num) {\n  ll left = 1, right = 1;\n  if (r[num] != -1) left = check(r[num]);\n  if (b[num] != -1) right = check(b[num]);\n  ll g = gcd(p[num], q[num]);\n  p[num] /= g;\n  q[num] /= g;\n  left /= gcd(q[num], left);\n  right /= gcd(p[num], right);\n  ll temp = left * right / gcd(left, right);\n  return (p[num] + q[num]) * temp;\n}\n\nint main() {\n  while (1) {\n    scanf(\"%lld\", &n);\n    if (n == 0) break;\n    for (ll i = 0; i < n; i++) isTop[i] = true;\n    for (ll i = 0; i < n; i++) {\n      scanf(\"%lld%lld%lld%lld\", &p[i], &q[i], &r[i], &b[i]);\n      r[i]--, b[i]--;\n      if (r[i] != -1) isTop[r[i]] = false;\n      if (b[i] != -1) isTop[b[i]] = false;\n    }\n    ll top;\n    for (ll i = 0; i < n; i++) if (isTop[i]) { top = i; break; }\n    printf(\"%lld\\n\", check(top));\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nstruct node{ll lv,rv,lc,rc;};\n#define MAX_N 101\nll gcd(ll x,ll y){return __gcd(x,y);}\nll lcm(ll x,ll y){return x/gcd(x,y)*y;}\n\nint n;\nnode g[MAX_N];\nint t[MAX_N];\n\nll rec(int pos){\n  if(pos==0)return 1;\n  node m=g[pos];\n  ll a=rec(m.lc);\n  ll b=rec(m.rc);\n  ll c=gcd(a*m.lv,b*m.rv);\n  return a*(b*m.rv/c)+b*(a*m.lv/c);\n}\n\nvoid solve(){\n  int root;\n  for(root=1;t[root]>0;root++);\n  cout<<rec(root)<<endl;\n}\n\nvoid init(){\n  for(int i=0;i<MAX_N;i++)t[i]=0;\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    init(); \n    for(int i=1;i<=n;i++){\n      ll p,q,r,b,x;\n      cin>>p>>q>>r>>b;\n      x=gcd(p,q);\n      p/=x,q/=x;\n      g[i]=(node){p,q,r,b};\n      t[r]=t[b]=i;\n    }\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n\ntemplate <class T>\nint __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\nint gcd(int a, int b)\n{\n\tif (a < b)\n\t\tswap(a, b);\n\tif (b == 0)\n\t\treturn a;\n\treturn gcd(b, a%b);\n}\nint lcm(int a, int b)\n{\n\treturn a/gcd(a, b) * b;\n}\nint p[101], q[101], r[101], b[101];\nint dfs(int s)\n{\n\tif (s == 0)\n\t\treturn 1;\n\n\tint red = dfs(r[s]), blue = dfs(b[s]);\n\tint t = lcm(red*p[s], blue*q[s]);\n\treturn t/p[s] + t/q[s];\n}\nint main()\n{\n\tint n;\n\twhile (~scanf(\"%d\", &n) && n)\n\t{\n\t\tbool root[101];\n\t\tfill(root, root+101, true);\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t{\n\t\t\tscanf(\"%d%d%d%d\", p+i, q+i, r+i, b+i);\n\t\t\troot[r[i]] = root[b[i]] = false;\n\t\t}\n\n\t\tint res = 0;\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t\tif (root[i])\n\t\t\t\tres = dfs(i);\n\t\tprintf(\"%lld\\n\", res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\n\nint p[101], q[101], r[101], b[101];\n\nll gcd(ll a, ll b){\n    return (b == 0)? a : gcd(b, a % b);\n}\n\nll lcm(ll a, ll b){\n    return a / gcd(a, b) * b;\n}\n\nll solve(int M){\n\tll w;\n\tif( M == 0 ){\n\t\tw = 1;\n\t}else{\n\t\tll rw = solve(r[M]);\n\t\tll bw = solve(b[M]);\n\t\tll l = lcm(rw * p[M], bw * q[M]);\n\t\tw = (l / p[M]) + (l / q[M]);\n\t}\n\treturn w;\n}\n\nint main(){\n\tint n;\n\twhile( cin >> n, n ){\n\t\tvector<bool> used(n+1, false);\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tcin >> p[i] >> q[i] >> r[i] >> b[i];\n\t\t\tused[r[i]] = used[b[i]] = true;\n\t\t}\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tif( !used[i] ) cout << solve(i) << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//  Lightest Mobile.cpp\n//  2013/01/03.\n\n#if 1\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nint B[128][4];\n\nint __lcm(int a, int b)\n{\treturn a * b / __gcd(a, b); }\n\nint rec(int idx)\n{\n\tint a = (B[idx][2] == 0 ? 1 : rec(B[idx][2]-1));\n\tint b = (B[idx][3] == 0 ? 1 : rec(B[idx][3]-1));\n\t\n\tint p = B[idx][0];\n\tint q = B[idx][1];\n\t\n\tint lcm = __lcm(q*a, p*b);\n\t\n\treturn lcm / q + lcm / p;\n}\n\nint main()\n{\n    for(int n; cin >> n && n; )\n\t{\n\t\tvint pflag(n+1, true);\n\t\t\n\t\trep(i, n)\n\t\t{\n\t\t\trep(j, 4) cin >> B[i][j];\n\t\t\t\n\t\t\tpflag[B[i][2]] = false;\n\t\t\tpflag[B[i][3]] = false;\n\t\t}\n\t\t\n\t\trep(i, n) if(pflag[i+1]) cout << rec(i) << endl;\n\t}\n}\n\n#endif"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define rep(i,x) for(int i=0;i<x;++i)\n\nstruct node {\n    int p, q, r, b;\n};\n\nvector<node> sticks;\nint par[105];\n\nint n;\n\nint gcd(int a, int b)\n{\n    int tmp;\n    while (b != 0) {\n        tmp = b;\n        b = a % b;\n        a = tmp;\n    }\n\n    return a;\n}\n\nint lcm(int a, int b)\n{\n    return a / gcd(a, b) * b;\n}\n\nint dfs(int cur)\n{\n    node& s = sticks[cur];\n\n    if (s.r == -1 && s.b == -1) {\n        int g = gcd(s.p, s.q);\n        return s.p / g + s.q / g;\n    }\n\n    if (s.r == -1) {\n        int bch = dfs(s.b);\n        int a = lcm(s.p, bch * s.q);\n        return a / s.p + bch * (a / (bch * s.q));\n    }\n\n    if (s.b == -1) {\n        int rch = dfs(s.r);\n        int a = lcm(rch * s.p, s.q);\n        return rch * (a / rch * s.p) + a / s.q;\n    }\n\n    int rch = dfs(s.r), bch = dfs(s.b);\n    int a = lcm(rch * s.p, bch * s.q);\n\n    return rch * (a / (rch * s.p)) + bch * (a / (bch * s.q));\n}\n\nsigned main()\n{\n    cin >> n;    \n\n    sticks.resize(n);\n\n    memset(par, -1, sizeof(par));\n\n    rep(i, n) {\n        int p, q, r, b;\n        cin >> p >> q >> r >> b;\n        r--, b--;\n        sticks[i] = node{p, q, r, b};\n\n        if (r >= 0) par[r] = i;\n        if (b >= 0) par[b] = i;\n    }\n\n    int root;\n\n    {\n        int cur = 0;\n        do {\n            root = cur;\n            cur = par[cur];\n        } while (cur != -1);\n    }\n\n    cout << dfs(root) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\nusing namespace std;\n\nstruct mob{ long long int le[101], ri[101], ll[101], rr[101]; };\n\nint n;\nmob mm;\nbool flg[101]; \n\nint gcd(long long int a,long long int b){\n\tif(b==0)return a;\n\treturn gcd(b,a%b);\n}\nint lcm(long long int x,long long int y){\n    return (x*y/gcd(x,y));\n}\n\nint minc(long long int x){\n\tlong long int w,lef,rig;\n\tif(mm.ll[x]==0)lef=1;\n\telse lef=minc(mm.ll[x]);\n\tif(mm.rr[x]==0)rig=1;\n\telse rig=minc(mm.rr[x]);\n\tw=lcm(lef*mm.le[x],rig*mm.ri[x]);\n\treturn w/mm.le[x]+w/mm.ri[x];\n}\n\n\nint main(void){\n\tlong long int ans;\n\twhile(1){\n\t\tcin >> n;\n\t\tans=0;\n\t\tif(n==0)break;\n\t\tmemset(flg,0,sizeof(flg));\n\t\tfor(int a=1;a<=n;a++){\n\t\t\tscanf(\"%d%d%d%d\",&mm.le[a],&mm.ri[a],&mm.ll[a],&mm.rr[a]);\n\t\t\tflg[mm.ll[a]]=1;\n\t\t\tflg[mm.rr[a]]=1;\n\t\t}\n\t\tfor(int a=1;a<=n;a++){\n\t\t\tif(flg[a]==0)ans=minc(a);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,p[101],q[101],r[101],b[101];\nint memo[101];\nint dp(int a){\n  if(memo[a] != -1) return memo[a];\n  if(r[a] == 0 && b[a] == 0) return memo[a] = p[a] + q[a];\n  int red,blue;\n  if(r[a] == 0){\n    red = q[a];\n    blue = dp(b[a]);\n  } else if(b[a] == 0){\n    blue = p[a];\n    red = dp(r[a]);\n  } else {\n    red = dp(r[a]);\n    blue = dp(b[a]);\n  }\n  red *= (p[a] / __gcd(red,p[a]));\n  blue *= (q[a] / __gcd(blue,q[a]));\n  int m = (blue/q[a])*(red/p[a])/__gcd(blue/q[a],red/p[a]);\n  return memo[a] = m*(p[a]+q[a]);\n}\nint main(){\n  while(scanf(\"%d\",&n),n!=0){\n    fill(memo,memo+101,-1);\n    for(int i=1;i<=n;i++){\n      scanf(\"%d %d %d %d\",&p[i],&q[i],&r[i],&b[i]);\n      int m = __gcd(p[i],q[i]);\n      p[i] /= m;\n      q[i] /= m;\n    }\n    int ans = 0;\n    for(int i=1;i<=n;i++){\n      ans = max(ans,dp(i));\n    }\n    printf(\"%d\\n\",ans);\n  }\n  return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\ntypedef long long int ll;\nstatic const int MAX_N = 100;\n\nint n;\nll p[MAX_N + 1], q[MAX_N + 1]; int r[MAX_N + 1], b[MAX_N + 1];\nbool is_root[MAX_N + 1];\n\nll GCD(ll a, ll b){\n\tif(b == 0) return a;\n\telse return GCD(b, a % b);\n}\nll LCM(ll a, ll b){\n\treturn a / GCD(a, b) * b;\n}\n\nll rec(int parent, bool is_red){\n\tif(is_red && parent == 0) return 1LL;\n\tif(!is_red && parent == 0) return 1LL;\n\treturn LCM(rec(r[parent], true) * p[parent], rec(b[parent], false) * q[parent]) / p[parent] + LCM(rec(r[parent], true) * p[parent], rec(b[parent], false) * q[parent]) / q[parent];\n}\n\nint main(){\n\tfor(;;){\n\t\tscanf(\"%d\", &n);\n\t\tif(n == 0) break;\n\t\tfill(is_root, is_root + n + 1, true);\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tscanf(\"%lld %lld %d %d\", &p[i], &q[i], &r[i], &b[i]);\n\t\t\tis_root[r[i]] = false;\n\t\t\tis_root[b[i]] = false;\n\t\t}\n\t\tint root;\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tif(is_root[i]) root = i;\n\t\t}\n\t\tprintf(\"%lld\\n\", LCM(rec(r[root], true) * p[root], rec(b[root], false) * q[root]) / p[root] + LCM(rec(r[root], true) * p[root], rec(b[root], false) * q[root]) / q[root]);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint n;\nint a[200][2],p[200][2];\nbool cal[200];\nint GCD(long long x,long long y){\n\twhile(true){\n\t\tif(x<2||!y)break;\n\t\tif(y>x){int t=x;x=y,y=t;}\n\t\tx%=y;\n\t}\n\tif(!y)y=1;\n\treturn y;\n}\nlong long DFS(int x){\n\tif(!x)return 1;\n\tcout<<x<<endl;\n\tx--;\n\tlong long b=DFS(p[x][0]),c=DFS(p[x][1]);\n\tlong long s=b*a[x][0]*c*a[x][1]/GCD(b*a[x][1],c*a[x][0]);\n\treturn s/a[x][0]+s/a[x][1];\n}\nint main(){\n\twhile(true){\n\tcin>>n;\n\tif(!n)break;\n\tfor(int i=0;i<n;i++)cal[i]=true;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>a[i][0]>>a[i][1];\n\t\tint t=GCD(a[i][0],a[i][1]);\n\t\ta[i][0]/=t,a[i][1]/=t;\n\t\tcin>>p[i][0]>>p[i][1];\n\t\tcal[p[i][0]-1]=false,cal[p[i][1]-1]=false;\n\t}\n\tfor(int i=0;i<n;i++)if(cal[i])cout<<DFS(i+1)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\ntypedef struct _node{\n\tint p;\n\tint q;\n\tint r;\n\tint b;\n\tint left;\t//p-side mass\n\tint right;\t//q-side mass\n} Node;\nint calc_mass(int trgt);\nint calc_gcd( int a, int b);\nNode MOB[101];\n\nint main(){\n\n\tint n;\n\tint chk[101];\n\tint i;\n\tint p;\n\tint q;\n\tint r;\n\tint b;\n\tint Top;\n\tint Total;\n\tint gcd;\n\n\twhile(1){\n\t\tscanf(\"%d\\n\",&n);\n\t\tif(n==0)break;\n\n\t\tfor(i=1;i<=n;i++){\n\t\t\tscanf(\"%d %d %d %d\\n\",&p,&q,&r,&b);\n\t\t\tgcd=calc_gcd(p,q);\n\t\t\tMOB[i].p=p/gcd;\n\t\t\tMOB[i].q=q/gcd;\n\t\t\tMOB[i].r=r;\n\t\t\tMOB[i].b=b;\n\t\t\tMOB[i].left=0;\n\t\t\tMOB[i].right=0;\n\t\t\t\n\t\t}\n\t\t\n\t\t// search TOP;\n\t\tfor(i=1;i<=n;i++)chk[i]=0;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tif(MOB[i].r!=0)chk[MOB[i].r]=1;\n\t\t\tif(MOB[i].b!=0)chk[MOB[i].b]=1;\n\t\t}\n\t\tfor(i=1;i<=n;i++){\n\t\t\tif(chk[i]==0)Top=i;\n\t\t}\n\t\tTotal=calc_mass(Top);\n\t\tprintf(\"%d\\n\",Total);\n\n\t}\n\treturn 0;\n}\n\n\nint calc_gcd( int a, int b){\n\t int c=1;\n\t int gcd;\n\n        if(a==0 || b==0)return 0;\n        if(a==1 || b==1)return 1;\n\n        if(a<b){\n            c=a,a=b,b=c;\n        }\n\n        gcd=1;\n\t\n\twhile(a%b!=0){\n\t\tc=b;\n\t\tb=a%b;\n\t\ta=c;\n\t}\n\tgcd=b;\n\n\treturn gcd;\n\n}\n\n\n\nint calc_mass(int trgt){\n\tint gcd;\n\tint left,right;\n\n\tif(MOB[trgt].r==0 && MOB[trgt].b==0){\n\t\tgcd=calc_gcd(MOB[trgt].p,MOB[trgt].q);\n\t\tMOB[trgt].left=MOB[trgt].q/gcd;\n\t\tMOB[trgt].right=MOB[trgt].p/gcd;\n\t\treturn MOB[trgt].left+MOB[trgt].right;\n\t}\n\t\n\tif(MOB[trgt].left==0){\n\t\tif(MOB[trgt].r==0)left=1;\n\t\tif(MOB[trgt].r!=0)left=calc_mass(MOB[trgt].r);\n\t}\n\tif(MOB[trgt].right==0){\n\t\tif(MOB[trgt].b==0)right=1;\n\t\tif(MOB[trgt].b!=0)right=calc_mass(MOB[trgt].b);\n\t}\n\t\n\tgcd=calc_gcd(left*MOB[trgt].q,right*MOB[trgt].p);\n\tMOB[trgt].left=left*right*MOB[trgt].p/gcd;\n\tMOB[trgt].right=right*left*MOB[trgt].q/gcd;\n\treturn MOB[trgt].left+MOB[trgt].right;\n\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define int long long\n\n#define CHOOSE(a) CHOOSE2 a\n#define CHOOSE2(a0,a1,a2,a3,x,...) x\n#define REP1(i, s, cond, cal) for (signed i = signed(s); i cond; i cal)\n#define REP2(i, s, n) REP1(i, s, < signed(n), ++)\n#define REP3(i, n) REP2(i, 0, n)\n#define rep(...) CHOOSE((__VA_ARGS__,REP1,REP2,REP3))(__VA_ARGS__)\n#define rrep(i, s) rep(i, s, >= 0, --)\n\n#define all(c) begin(c), end(c)\ntemplate<typename T>bool maxup(T& a, const T&& b) { if (a < b) { a = b; return true; }; }\ntemplate<typename T>bool maxup(T& a, const T& b) { if (a < b) { a = b; return true; }; }\ntemplate<typename T>bool minup(T& a, const T&& b) { if (a > b) { a = b; return true; }; }\ntemplate<typename T>bool minup(T& a, const T& b) { if (a > b) { a = b; return true; }; }\n\n#define X first\n#define Y second\n\nusing VV = vector<vector<int>>;\nusing V = vector<int>;\nusing P = pair<int, int>;\nusing IP = pair<int, P>;\n\ntemplate<typename T>\ninline void input(vector<T>& v) { for (auto& x : v) cin >> x; }\n\n\nVV g;\nvector<P> len;\nvector<P> w;\n\nint dfs(int now) {\n\tint a = g[now][0] >= 0 ? dfs(g[now][0]) : 1;\n\tint b = g[now][1] >= 0 ? dfs(g[now][1]) : 1;\n\tint p, q;\n\ttie(p, q) = len[now];\n\tint gcd = __gcd(a*p, b*q);\n\tint x = b*q / gcd;\n\tint y = a*p / gcd;\n\treturn a*x + b*y;\n}\n\nsigned main() {\n\tint n;\n\twhile (cin >> n&&n) {\n\n\t\tg.resize(n);\n\t\tw.resize(n, P(1, 1));\n\t\tlen.resize(n);\n\t\tV root(n, true);\n\t\trep(i, n) {\n\t\t\tint p, q, r, b;\n\t\t\tcin >> p >> q >> r >> b;\n\t\t\tr--; b--;\n\t\t\tint gcd = __gcd(p, q);\n\t\t\tp = p / gcd;\n\t\t\tq = q / gcd;\n\t\t\tif (~r) root[r] = false;\n\t\t\tif (~b) root[b] = false;\n\t\t\tg[i].push_back(r);\n\t\t\tg[i].push_back(b);\n\t\t\tlen[i] = P(p, q);\n\t\t}\n\t\tint idx = find(all(root), true) - root.begin();\n\t\tcout << dfs(idx) << endl;\n\t}\n\n\t//system(\"pause\");\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * AOJ用\n */\n\n// header {{{\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define CPP_STR(x) CPP_STR_I(x)\n#define CPP_CAT(x,y) CPP_CAT_I(x,y)\n#define CPP_STR_I(args...) #args\n#define CPP_CAT_I(x,y) x ## y\n\n#define SFINAE(pred...) std::enable_if_t<(pred), std::nullptr_t> = nullptr\n\n#define ASSERT(expr...) assert((expr))\n\nusing i8  = int8_t;\nusing u8  = uint8_t;\nusing i16 = int16_t;\nusing u16 = uint16_t;\nusing i32 = int32_t;\nusing u32 = uint32_t;\nusing i64 = int64_t;\nusing u64 = uint64_t;\n\nusing f32 = float;\nusing f64 = double;\nusing f80 = __float80;\n// }}}\n\nconstexpr i64 INF  = INT64_C(1'010'000'000'000'000'017);\nconstexpr f64 FINF = 1e100;\n\nconstexpr i64 MOD = INT64_C(1'000'000'007);\n\nconstexpr f64 EPS = 1e-12;\n\nconstexpr f64 PI = 3.14159265358979323846;\n\n// util {{{\n#define FOR(i, start, end) for(i64 i = (start), CPP_CAT(i,xxxx_end)=(end); i < CPP_CAT(i,xxxx_end); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define ALL(f,c,...) (([&](decltype((c)) cccc) { return (f)(std::begin(cccc), std::end(cccc), ## __VA_ARGS__); })(c))\n\n#define LIFT(f) ([](auto&&... args) -> decltype(auto) { return (f)(std::forward<decltype(args)>(args)...); })\n\ntemplate<typename C>\nconstexpr i64 SIZE(const C& c) noexcept { return static_cast<i64>(c.size()); }\n\ntemplate<typename T, size_t N>\nconstexpr i64 SIZE(const T (&)[N]) noexcept { return static_cast<i64>(N); }\n\ntemplate<typename T, typename U, typename Comp=less<>>\nconstexpr bool chmax(T& xmax, const U& x, Comp comp={}) noexcept {\n    if(comp(xmax, x)) {\n        xmax = x;\n        return true;\n    }\n    return false;\n}\n\ntemplate<typename T, typename U, typename Comp=less<>>\nconstexpr bool chmin(T& xmin, const U& x, Comp comp={}) noexcept {\n    if(comp(x, xmin)) {\n        xmin = x;\n        return true;\n    }\n    return false;\n}\n\ntemplate<typename BinaryFunc, typename UnaryFunc>\nauto ON(BinaryFunc&& bf, UnaryFunc&& uf) {\n    return [bf=forward<BinaryFunc>(bf),uf=forward<UnaryFunc>(uf)](const auto& x, const auto& y) {\n        return bf(uf(x), uf(y));\n    };\n}\n\ntemplate<typename F>\nauto LT_ON(F&& f) {\n    return ON(less<>{}, forward<F>(f));\n}\n\ntemplate<typename F>\nauto GT_ON(F&& f) {\n    return ON(greater<>{}, forward<F>(f));\n}\n\ntemplate<typename F>\nauto EQ_ON(F&& f) {\n    return ON(equal_to<>{}, forward<F>(f));\n}\n\ntemplate<typename F>\nauto NE_ON(F&& f) {\n    return ON(not_equal_to<>{}, forward<F>(f));\n}\n\n// tuple {{{\ntemplate<i64 I=0, typename F, typename... TS, SFINAE(sizeof...(TS) == I)>\nvoid tuple_enumerate(tuple<TS...>&, F&&) {}\n\ntemplate<i64 I=0, typename F, typename... TS, SFINAE(sizeof...(TS) > I)>\nvoid tuple_enumerate(tuple<TS...>& t, F&& f) {\n    f(I, get<I>(t));\n    tuple_enumerate<I+1>(t, forward<F>(f));\n}\n\ntemplate<i64 I=0, typename F, typename... TS, SFINAE(sizeof...(TS) == I)>\nvoid tuple_enumerate(const tuple<TS...>&, F&&) {}\n\ntemplate<i64 I=0, typename F, typename... TS, SFINAE(sizeof...(TS) > I)>\nvoid tuple_enumerate(const tuple<TS...>& t, F&& f) {\n    f(I, get<I>(t));\n    tuple_enumerate<I+1>(t, forward<F>(f));\n}\n// }}}\n\n// container {{{\ntemplate<typename T> struct is_container : false_type {};\ntemplate<typename T, size_t N> struct is_container<array<T,N>> : true_type {};\ntemplate<typename... Args> struct is_container<vector<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<deque<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<list<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<forward_list<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<set<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<multiset<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<unordered_set<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<unordered_multiset<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<map<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<multimap<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<unordered_map<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<unordered_multimap<Args...>> : true_type {};\n\ntemplate<typename T, typename Enable=void>\nstruct ProconHash {\n    size_t operator()(const T& x) const noexcept {\n        return hash<T>{}(x);\n    }\n};\n\ntemplate<typename T>\nsize_t procon_hash_value(const T& x) noexcept {\n    return ProconHash<T>{}(x);\n}\n\nsize_t procon_hash_combine(size_t h1, size_t h2) noexcept {\n    constexpr size_t M = UINT64_C(0xc6a4a7935bd1e995);\n    constexpr int    R = 47;\n\n    h2 *= M;\n    h2 ^= h2 >> R;\n    h2 *= M;\n\n    h1 ^= h2;\n    h1 *= M;\n\n    h1 += 0xe6546b64;\n\n    return h1;\n}\n\ntemplate<typename T1, typename T2>\nstruct ProconHash<pair<T1,T2>> {\n    size_t operator()(const pair<T1,T2>& p) const noexcept {\n        size_t h1 = procon_hash_value(p.first);\n        size_t h2 = procon_hash_value(p.second);\n        return procon_hash_combine(h1, h2);\n    }\n};\n\ntemplate<typename... TS>\nstruct ProconHash<tuple<TS...>> {\n    size_t operator()(const tuple<TS...>& t) const noexcept {\n        size_t h = 0;\n        tuple_enumerate(t, [&h](const auto& e) {\n            h = procon_hash_combine(h, procon_hash_value(e));\n        });\n        return h;\n    }\n};\n\ntemplate<typename C>\nstruct ProconHash<C,enable_if_t<is_container<C>::value>> {\n    size_t operator()(const C& c) const noexcept {\n        size_t h = 0;\n        for(const auto& e : c)\n            h = procon_hash_combine(h, procon_hash_value(e));\n        return h;\n    }\n};\n\ntemplate<typename T, typename Hash=ProconHash<T>, typename Eq=equal_to<T>>\nusing HashSet = unordered_set<T,Hash,Eq>;\ntemplate<typename K, typename V, typename Hash=ProconHash<K>, typename Eq=equal_to<K>>\nusing HashMap = unordered_map<K,V,Hash,Eq>;\ntemplate<typename T, typename Hash=ProconHash<T>, typename Eq=equal_to<T>>\nusing HashMultiset = unordered_multiset<T,Hash,Eq>;\ntemplate<typename K, typename V, typename Hash=ProconHash<K>, typename Eq=equal_to<K>>\nusing HashMultimap = unordered_multimap<K,V,Hash,Eq>;\n\ntemplate<typename T>\nusing MaxHeap = priority_queue<T, vector<T>, less<T>>;\ntemplate<typename T>\nusing MinHeap = priority_queue<T, vector<T>, greater<T>>;\n\ntemplate<typename T>\nauto vec_make(i64 n, T x) {\n    return vector<T>(n, x);\n}\n\ntemplate<typename T, typename... Args, SFINAE(sizeof...(Args) >= 2)>\nauto vec_make(i64 n, Args... args) {\n    auto inner = vec_make<T>(args...);\n    return vector<decltype(inner)>(n, inner);\n}\n\ntemplate<typename T, size_t N, size_t... NS>\nstruct ArrayType {\n    using type = array<typename ArrayType<T,NS...>::type,N>;\n};\n\ntemplate<typename T, size_t N>\nstruct ArrayType<T,N> {\n    using type = array<T,N>;\n};\n\ntemplate<typename T, size_t... NS>\nusing Array = typename ArrayType<T,NS...>::type;\n\ntemplate<typename T, size_t N>\nT& array_at(Array<T,N>& ary, i64 i) {\n    return ary[i];\n}\n\ntemplate<typename T, size_t N, size_t... NS, typename... Args>\nT& array_at(Array<T,N,NS...>& ary, i64 i, Args... args) {\n    return array_at<T,NS...>(ary[i], args...);\n}\n\ntemplate<typename T, size_t N>\nconst T& array_at(const Array<T,N>& ary, i64 i) {\n    return ary[i];\n}\n\ntemplate<typename T, size_t N, size_t... NS, typename... Args>\nconst T& array_at(const Array<T,N,NS...>& ary, i64 i, Args... args) {\n    return array_at<T,NS...>(ary[i], args...);\n}\n\ntemplate<typename T>\nauto reserve_vec(i64 cap) {\n    vector<T> res;\n    res.reserve(cap);\n    return res;\n}\n\ntemplate<typename T, typename Hash=ProconHash<T>, typename Eq=equal_to<T>>\nauto reserve_hash_set(i64 cap, f32 load_max=0.25) {\n    HashSet<T,Hash,Eq> res;\n    res.max_load_factor(load_max);\n    res.reserve(cap);\n    return res;\n}\n\ntemplate<typename K, typename V, typename Hash=ProconHash<K>, typename Eq=equal_to<K>>\nauto reserve_hash_map(i64 cap, f32 load_max=0.25) {\n    HashMap<K,V,Hash,Eq> res;\n    res.max_load_factor(load_max);\n    res.reserve(cap);\n    return res;\n}\n\ntemplate<typename T, typename Hash=ProconHash<T>, typename Eq=equal_to<T>>\nauto reserve_hash_multiset(i64 cap, f32 load_max=0.25) {\n    HashMultiset<T,Hash,Eq> res;\n    res.max_load_factor(load_max);\n    res.reserve(cap);\n    return res;\n}\n\ntemplate<typename K, typename V, typename Hash=ProconHash<K>, typename Eq=equal_to<K>>\nauto reserve_hash_multimap(i64 cap, f32 load_max=0.25) {\n    HashMultimap<K,V,Hash,Eq> res;\n    res.max_load_factor(load_max);\n    res.reserve(cap);\n    return res;\n}\n\ntemplate<typename T, typename C>\nT POP(stack<T,C>& stk) {\n    T x = stk.top(); stk.pop();\n    return x;\n}\n\ntemplate<typename T, typename C>\nT POP(queue<T,C>& que) {\n    T x = que.front(); que.pop();\n    return x;\n}\n\ntemplate<typename T, typename C, typename Comp>\nT POP(priority_queue<T,C,Comp>& que) {\n    T x = que.top(); que.pop();\n    return x;\n}\n// }}}\n\n// fixpoint {{{\ntemplate<typename F>\nclass FixPoint {\npublic:\n    explicit constexpr FixPoint(F&& f) : f_(forward<F>(f)) {}\n\n    template<typename... Args>\n    constexpr decltype(auto) operator()(Args&&... args) const {\n        return f_(*this, forward<Args>(args)...);\n    }\n\nprivate:\n    F f_;\n};\n\ntemplate<typename F>\nconstexpr decltype(auto) FIX(F&& f) {\n    return FixPoint<F>(forward<F>(f));\n}\n\ntemplate<typename F, size_t... NS>\nclass FixPointMemo {\npublic:\n    explicit FixPointMemo(F&& f) : f_(forward<F>(f)) {}\n\n    template<typename... Args>\n    decltype(auto) operator()(Args... args) const {\n        using R = decltype(f_(*this,args...));\n        static Array<bool,NS...> done {};\n        static Array<R,NS...>    memo;\n\n        if(!array_at<bool,NS...>(done,args...)) {\n            array_at<R,NS...>(memo,args...) = f_(*this,args...);\n            array_at<bool,NS...>(done,args...) = true;\n        }\n        return array_at<R,NS...>(memo,args...);\n    }\n\nprivate:\n    F f_;\n};\n\ntemplate<size_t... NS, typename F>\ndecltype(auto) FIXMEMO(F&& f) {\n    return FixPointMemo<F,NS...>(forward<F>(f));\n}\n// }}}\n\n// input {{{\ntemplate<typename T, typename Enable=void>\nstruct Scan {\n    static T scan(istream& in) {\n        T res;\n        in >> res;\n        return res;\n    }\n};\n\ntemplate<typename T, typename Enable=void>\nstruct Scan1;\n\ntemplate<typename T>\nstruct Scan1<T,enable_if_t<is_integral<T>::value && !is_same<T,bool>::value>> {\n    static T scan1(istream& in) {\n        return Scan<T>::scan(in) - 1;\n    }\n};\n\ntemplate<typename T=i64>\nT RD() {\n    return Scan<T>::scan(cin);\n}\n\ntemplate<typename T=i64>\nT RD1() {\n    return Scan1<T>::scan1(cin);\n}\n\ntemplate<typename T=i64>\nauto RD_VEC(i64 n) {\n    auto res = reserve_vec<T>(n);\n    REP(_, n) {\n        res.emplace_back(RD<T>());\n    }\n    return res;\n}\n\ntemplate<typename T=i64>\nauto RD1_VEC(i64 n) {\n    auto res = reserve_vec<T>(n);\n    REP(_, n) {\n        res.emplace_back(RD1<T>());\n    }\n    return res;\n}\n// }}}\n\n// output {{{\ntemplate<typename T, typename Enable=void>\nstruct Fmt {\n    static void fmt(ostream& out, const T& x) { out << x; }\n};\n\ntemplate<typename T>\nvoid fmt_write(ostream& out, const T& x) {\n    Fmt<T>::fmt(out, x);\n}\n\ntemplate<typename... TS>\nstruct Fmt<tuple<TS...>> {\n    static void fmt(ostream& out, const tuple<TS...>& t) {\n        tuple_enumerate(t, [&out](i64 i, const auto& e) {\n            if(i != 0) out << ' ';\n            fmt_write(out, e);\n        });\n    }\n};\n\ntemplate<typename T1, typename T2>\nstruct Fmt<pair<T1,T2>> {\n    static void fmt(ostream& out, const pair<T1,T2>& p) {\n        return fmt_write(out, make_tuple(p.first,p.second));\n    }\n};\n\ntemplate<typename C>\nstruct Fmt<C,enable_if_t<is_container<C>::value>> {\n    static void fmt(ostream& out, const C& c) {\n        for(auto it = begin(c); it != end(c); ++it) {\n            if(it != begin(c)) out << ' ';\n            fmt_write(out, *it);\n        }\n    }\n};\n\nvoid PRINT() {}\n\ntemplate<typename T, typename... TS>\nvoid PRINT(const T& x, const TS&... args) {\n    fmt_write(cout, x);\n    if(sizeof...(args) > 0) {\n        cout << ' ';\n        PRINT(args...);\n    }\n}\n\ntemplate<typename... TS>\nvoid PRINTLN(const TS&... args) {\n    PRINT(args...);\n    cout << '\\n';\n}\n// }}}\n\n// debug {{{\ntemplate<typename T, typename Enable=void>\nstruct Dbg {\n    static void dbg(ostream& out, const T& x) { out << x; }\n};\n\ntemplate<typename T>\nvoid dbg_write(ostream& out, const T& x) {\n    return Dbg<T>::dbg(out, x);\n}\n\ntemplate<>\nstruct Dbg<i64> {\n    static void dbg(ostream& out, i64 x) {\n        if(x == INF)\n            out << \"INF\";\n        else if(x == -INF)\n            out << \"-INF\";\n        else\n            out << x;\n    }\n};\n\ntemplate<>\nstruct Dbg<f64> {\n    static void dbg(ostream& out, f64 x) {\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wfloat-equal\"\n        if(x == FINF)\n            out << \"FINF\";\n        else if(x == -FINF)\n            out << \"-FINF\";\n        else\n            out << x;\n#pragma GCC diagnostic pop\n    }\n};\n\ntemplate<typename T, size_t N>\nstruct Dbg<T[N]> {\n    static void dbg(ostream& out, const T (&ary)[N]) {\n        out << \"[\";\n        REP(i, N) {\n            if(i != 0) out << \",\";\n            dbg_write(out, ary[i]);\n        }\n        out << \"]\";\n    }\n};\n\ntemplate<typename... TS>\nstruct Dbg<tuple<TS...>> {\n    static void dbg(ostream& out, const tuple<TS...>& t) {\n        out << \"(\";\n        tuple_enumerate(t, [&out](i64 i, const auto& e) {\n            if(i != 0) out << \",\";\n            dbg_write(out, e);\n        });\n        out << \")\";\n    }\n};\n\ntemplate<typename T1, typename T2>\nstruct Dbg<pair<T1,T2>> {\n    static void dbg(ostream& out, const pair<T1,T2>& p) {\n        return dbg_write(out, make_tuple(p.first,p.second));\n    }\n};\n\ntemplate<typename C>\nstruct Dbg<C,enable_if_t<is_container<C>::value>> {\n    static void dbg(ostream& out, const C& c) {\n        out << \"[\";\n        for(auto it = begin(c); it != end(c); ++it) {\n            if(it != begin(c)) out << \",\";\n            dbg_write(out, *it);\n        }\n        out << \"]\";\n    }\n};\n\ntemplate<typename T>\nvoid DBG_IMPL(i64 line, const char* expr, const T& value) {\n    cerr << \"[L \" << line << \"]: \";\n    cerr << expr << \" = \";\n    dbg_write(cerr, value);\n    cerr << \"\\n\";\n}\n\ntemplate<typename... TS>\nvoid DBG_IMPL(i64 line, const char* expr, const TS&... value) {\n    cerr << \"[L \" << line << \"]: \";\n    cerr << \"(\" << expr << \") = \";\n    dbg_write(cerr, make_tuple(value...));\n    cerr << \"\\n\";\n}\n\ntemplate<size_t N, typename T, SFINAE(rank<T>::value == 0)>\nvoid DBG_DP_IMPL_HELPER(ostream& out, const T& x, const array<i64,N>&, const array<i64,N>&) {\n    dbg_write(out, x);\n}\n\ntemplate<size_t N, typename T, SFINAE(rank<T>::value > 0)>\nvoid DBG_DP_IMPL_HELPER(ostream& out, const T& x, const array<i64,N>& sizes, const array<i64,N>& offs) {\n    i64 k   = N - rank<T>::value;\n    i64 off = offs[k];\n    i64 siz = sizes[k];\n    if(siz == 0) siz = extent<T>::value - off;\n\n    out << \"[\";\n    FOR(i, off, off+siz) {\n        if(i != off) out << \",\";\n        DBG_DP_IMPL_HELPER(out, x[i], sizes, offs);\n    }\n    out << \"]\";\n}\n\ntemplate<typename T, SFINAE(rank<T>::value > 0)>\nvoid DBG_DP_IMPL(i64 line, const char* expr, const T& dp,\n                 const array<i64,rank<T>::value>& sizes={},\n                 const array<i64,rank<T>::value>& offs={})\n{\n    cerr << \"[L \" << line << \"]: \";\n    cerr << expr << \" = \";\n    DBG_DP_IMPL_HELPER<rank<T>::value>(cerr, dp, sizes, offs);\n    cerr << \"\\n\";\n}\n\n#ifdef PROCON_LOCAL\n    #define DBG(args...) DBG_IMPL(__LINE__, CPP_STR_I(args), args)\n    #define DBG_DP(args...) DBG_DP_IMPL(__LINE__, CPP_STR_I(args), args)\n#else\n    #define DBG(args...)\n    #define DBG_DP(args...)\n#endif\n// }}}\n\n// modint {{{\ntemplate<i64 P>\nstruct ModPT {\n    static_assert(P >= 2, \"P must be a prime\");\n    i64 v_;  // [0,P)\n\n    ModPT() : v_(0) {}\n    ModPT(i64 v) {\n        i64 r = v % P;\n        v_ = r >= 0 ? r : r+P;\n    }\n\n    ModPT operator-() const {\n        return ModPT(-v_);\n    }\n    ModPT& operator+=(ModPT rhs) {\n        v_ += rhs.v_;\n        v_ %= P;\n        return *this;\n    }\n    ModPT& operator-=(ModPT rhs) {\n        v_ += P;\n        v_ -= rhs.v_;\n        v_ %= P;\n        return *this;\n    }\n    ModPT& operator*=(ModPT rhs) {\n        v_ *= rhs.v_;\n        v_ %= P;\n        return *this;\n    }\n\n    ModPT& operator++() {\n        return *this += 1;\n    }\n    ModPT& operator--() {\n        return *this -= 1;\n    }\n    ModPT operator++(int) {\n        return exchange(*this, *this+1);\n    }\n    ModPT operator--(int) {\n        return exchange(*this, *this-1);\n    }\n\n    explicit operator i64() const { return v_; }\n};\n\ntemplate<i64 P>\nModPT<P> operator+(ModPT<P> lhs, ModPT<P> rhs) { return ModPT<P>(lhs) += rhs; }\ntemplate<i64 P>\nModPT<P> operator+(ModPT<P> lhs, i64 rhs) { return ModPT<P>(lhs) += rhs; }\ntemplate<i64 P>\nModPT<P> operator+(i64 lhs, ModPT<P> rhs) { return ModPT<P>(rhs) += lhs; }\ntemplate<i64 P>\nModPT<P> operator-(ModPT<P> lhs, ModPT<P> rhs) { return ModPT<P>(lhs) -= rhs; }\ntemplate<i64 P>\nModPT<P> operator-(ModPT<P> lhs, i64 rhs) { return ModPT<P>(lhs) -= rhs; }\ntemplate<i64 P>\nModPT<P> operator-(i64 lhs, ModPT<P> rhs) { return ModPT<P>(rhs) -= lhs; }\ntemplate<i64 P>\nModPT<P> operator*(ModPT<P> lhs, ModPT<P> rhs) { return ModPT<P>(lhs) *= rhs; }\ntemplate<i64 P>\nModPT<P> operator*(ModPT<P> lhs, i64 rhs) { return ModPT<P>(lhs) *= rhs; }\ntemplate<i64 P>\nModPT<P> operator*(i64 lhs, ModPT<P> rhs) { return ModPT<P>(rhs) *= lhs; }\n\ntemplate<i64 P>\nbool operator==(ModPT<P> lhs, ModPT<P> rhs) { return lhs.v_ == rhs.v_; }\ntemplate<i64 P>\nbool operator==(ModPT<P> lhs, i64 rhs) { return lhs == ModPT<P>(rhs); }\ntemplate<i64 P>\nbool operator==(i64 lhs, ModPT<P> rhs) { return ModPT<P>(lhs) == rhs; }\ntemplate<i64 P>\nbool operator!=(ModPT<P> lhs, ModPT<P> rhs) { return !(lhs == rhs); }\ntemplate<i64 P>\nbool operator!=(ModPT<P> lhs, i64 rhs) { return !(lhs == rhs); }\ntemplate<i64 P>\nbool operator!=(i64 lhs, ModPT<P> rhs) { return !(lhs == rhs); }\n\ntemplate<i64 P>\nstruct Scan<ModPT<P>> {\n    static ModPT<P> scan(istream& in) {\n        return Scan<i64>::scan(in);\n    }\n};\n\ntemplate<i64 P>\nstruct Fmt<ModPT<P>> {\n    static void fmt(ostream& out, ModPT<P> x) {\n        fmt_write(out, x.v_);\n    }\n};\n\ntemplate<i64 P>\nstruct Dbg<ModPT<P>> {\n    static void dbg(ostream& out, ModPT<P> x) {\n        dbg_write(out, x.v_);\n    }\n};\n\nusing ModP = ModPT<MOD>;\n// }}}\n// }}}\n\n// init {{{\nstruct ProconInit {\n    static constexpr int IOS_PREC = 15;\n    static constexpr bool AUTOFLUSH = false;\n\n    ProconInit() {\n        cin.tie(nullptr);\n        ios::sync_with_stdio(false);\n        cout << fixed << setprecision(IOS_PREC);\n#ifdef PROCON_LOCAL\n        cin.exceptions(ios::failbit | ios::badbit);\n        cerr << fixed << setprecision(IOS_PREC);\n#endif\n        if(AUTOFLUSH)\n            cout << unitbuf;\n    }\n} PROCON_INIT;\n// }}}\n\n//--------------------------------------------------------------------\n\ni64 gcd(i64 a, i64 b) {\n    if(b == 0) return a;\n    return gcd(b, a%b);\n}\n\nvoid solve(const vector<tuple<i64,i64,i64,i64>>& A, i64 root) {\n    auto f = FIX([&A](auto&& self, i64 i) -> i64 {\n        i64 p,q,l,r; tie(p,q,l,r) = A[i];\n\n        i64 x = l == -1 ? 1 : self(l);\n        i64 y = r == -1 ? 1 : self(r);\n\n        i64 g = gcd(p*x, q*y);\n\n        i64 k1 = q*y / g;\n        i64 k2 = p*x / g;\n\n        return k1*x + k2*y;\n    });\n    REP(i, SIZE(A)) { DBG(i,f(i)); }\n\n    i64 ans = f(root);\n\n    PRINTLN(ans);\n}\n\nsigned main() {\n    for(;;) {\n        i64 N = RD();\n        if(N == 0) break;\n\n        auto A = reserve_vec<tuple<i64,i64,i64,i64>>(N);\n        vector<i64> parent(N, -1);\n        REP(i, N) {\n            i64 p = RD();\n            i64 q = RD();\n            i64 l = RD1();\n            i64 r = RD1();\n            A.emplace_back(p, q, l, r);\n            if(l >= 0) parent[l] = i;\n            if(r >= 0) parent[r] = i;\n        }\n        i64 root = distance(begin(parent), ALL(find,parent,-1));\n\n        solve(A, root);\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long lli;\n\nconst lli N = 100LL;\n\nlli n, p[N+1], q[N+1], r[N+1], b[N+1];\nbool vis[N+1];\n\nlli lcm(lli x, lli y){\n  return x * y / __gcd(x, y);\n}\n\nlli solve(lli pos){\n  lli t1 = 1, t2 = 1;\n  if(r[pos]) t1 = solve(r[pos]);\n  if(b[pos]) t2 = solve(b[pos]);\n  lli tmp = lcm(t1 * p[pos], t2 * q[pos]);\n  return tmp / p[pos] + tmp / q[pos];\n  /*lli tmp1 = p[pos];\n  lli tmp2 = q[pos];\n  if(r[pos] && b[pos]){\n    tmp1 = lcm(t1, (lli)p[pos]);\n    tmp2 = lcm(t2, (lli)q[pos]);\n    tmp1 = lcm(tmp1, tmp2);\n    tmp2 = tmp1;\n  }else if(r[pos]){\n    tmp1 = lcm(t1, (lli)p[pos]);\n    tmp2 = (lli)q[pos] * (tmp1 / t1);\n  }else if(b[pos]){\n    tmp2 = lcm(t2, (lli)q[pos]);\n    tmp1 = (lli)p[pos] * (tmp2 / t2);\n  }\n  //cout << pos << ' ' << tmp1 << ' ' << tmp2 << endl;\n  return tmp1 + tmp2;*/\n}\n\nmain(){\n  while(cin >> n && n){\n    fill(vis, vis+N+1, false);\n    for(lli i=1;i<=n;i++){\n      cin >> p[i] >> q[i] >> r[i] >> b[i];\n      lli tmp = __gcd(p[i], q[i]);\n      p[i] /= tmp;\n      q[i] /= tmp;\n      vis[r[i]] = vis[b[i]] = true;\n    }\n    for(lli i=1;i<=n;i++) if(!vis[i]) cout << solve(i) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define it ::iterator\n#define gcd(a,b) __gcd(a,b)\n#define lcm(a,b) a*b/(gcd(a,b))\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double ESP=1e-10;\nusing namespace std;\nint main(){\n  int n;\n  while(cin>>n,n){\n    map<int,vector<int> >in;\n    vector<int>out(n);\n    int co=0;\n    int ans=0;\n    rep(i,n){\n      int a,b,c,d;\n      cin>>a>>b>>c>>d;\n      if((!c)&&(!d)){\n\tint tmp=lcm(a,b);\n\tans=out[i]=tmp/a+tmp/b;\n\tco++;\n      }\n      in[i+1].pb(a);\n      in[i+1].pb(b);\n      in[i+1].pb(c);\n      in[i+1].pb(d);\n    }\n    while(n!=co){\n      rep(i,n){\n\tif(out[i])continue;\n\tint c=in[i+1][2];\n\tint d=in[i+1][3];\n\tif((c!=0&&d!=0&&out[c-1]!=0&&out[d-1]!=0)||\n\t   (c==0&&d!=0&&out[d-1]!=0)||\n\t   (d==0&&c!=0&&out[c-1]!=0)){\n\t  int a=in[i+1][0];\n\t  int b=in[i+1][1];\n\t  //10 4 40 2\n\t  //20 20\n\t  co++;\n\t  if(c==0||d==0){\n\t    if(c==0)d=out[d-1];\n\t    else c=out[c-1];\n\t    int tmp=max(c,d);\n\t    int tmp1=lcm(a,b);\n\t    ans=out[i]=tmp*(tmp1/a+tmp1/b);\n\t  }else{\n\t    c=out[c-1];\n\t    d=out[d-1];\n\t    int tmp=lcm(a,b);\n\t    int tmp1=lcm(c,d);\n\t    ans=out[i]=tmp1*(tmp/a+tmp/b);\n\t  }\n\t}\n      }\n    }\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint gcd(int a,int b){return b?gcd(b,a%b):a;}\nint lcm(int a,int b){return a/gcd(a,b)*b;}\n\nint main(){\n  int n;\n  int par[100],left[100],right[100],p[100],q[100],r[100],b[100];\n  bool use[100];\n\n  while(cin >> n && n){\n    for(int i=0;i<n;i++)par[i] = -1;\n    for(int i=0;i<n;i++){\n      cin >> p[i] >> q[i] >> r[i] >> b[i];\n      int tmp = gcd(p[i],q[i]);\n      p[i]/=tmp;\n      q[i]/=tmp;\n      if(r[i]){\n\tleft[i] = 0;\n\tpar[r[i]-1] = i;\n      }else left[i] = 1;\n      if(b[i]){\n\tright[i] = 0;\n\tpar[b[i]-1] = i;\n      }else right[i] = 1;\n      use[i] = false;\n    }\n\n    int num = 0;\n    int ans;\n    while(num<n){\n      for(int i=0;i<n;i++){\n\tif(!use[i] && left[i] && right[i]){\n\t  int tmp = lcm(right[i],left[i]);\n\t  right[i] = tmp*p[i];\n\t  left[i] = tmp*q[i];\n\t  ans = right[i] + left[i];\n\t  //cout << right[i] << \" \" << left[i] << \" \" << ans << endl;\n\t  if(0<=par[i]){\n\t    if(r[par[i]]==i+1)left[par[i]] = ans;\n\t    else right[par[i]] = ans;\n\t  }\n\t  use[i] = true;\n\t  num++;\n\t  break;\n\t}\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef long long ll;\nll n,m[100][4],r,cld[100];\nll w(int c){\n\tif(c<0)return 1;\n\tll l=m[c][0],r=m[c][1],wl=w(m[c][2]),wr=w(m[c][3]),nl=wr*r,nr=wl*l;\n\treturn (wl*nl+wr*nr)/__gcd(nl,nr);\n}\nint dfs(int c){\n\tif(c<0)return 0;\n\treturn cld[c]?cld[c]:(cld[c]=dfs(m[c][2])+dfs(m[c][3])+1);\n}\nint main(){\n\twhile(cin>>n,n){\n\t\trep(i,n)rep(j,4){\n\t\t\tcin>>m[i][j];if(j>1)m[i][j]--;\n\t\t}\n\t\tfill(cld,cld+n,0);\n\t\trep(i,n)if(dfs(r=i)==n)break;\n\t\tcout<<w(r)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i = (a); i < (b); i++)\n#define REP(i,n) FOR(i,0,n)\n\nstruct Node {\n\tint a, b, ma, mb;\n\t\n\tNode() {}\n\tNode(int a, int b, int ma, int mb) : a(a), b(b), ma(ma), mb(mb) {}\n};\n\nint n;\nNode node[100];\nbool istop[100];\n\nint gcd(int a, int b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a % b);\n}\n\nint lcm(int a, int b) {\n\treturn a / gcd(a, b) * b;\n}\n\nint dfs(int pos) {\n\tNode &now = node[pos];\n\t\n\tint a = now.a, b = now.b, ma = now.ma, mb = now.mb;\n\t\n\tif (ma != 0) ma = dfs(ma - 1);\n\tif (mb != 0) mb = dfs(mb - 1);\n\t\n\tif (ma == 0 && mb == 0) {\n\t\treturn a + b;\n\t\n\t} else if (ma == 0 || mb == 0) {\n\t\tif (ma == 0) swap(ma, mb);\n\t\tint l = lcm(a, b);\n\t\treturn l * ma / a + l * ma / b;\n\t}\n\telse {\n\t\tint x = gcd(a * ma, b * mb);\n\t\tint res1 = mb * (a * ma / x);\n\t\tint res2 = ma * (b * mb / x);\n\t\treturn res1 + res2;\n\t}\n}\n\nint main() {\n\twhile (cin >> n, n) {\n\t\tfill(istop, istop + n, false);\n\t\t\n\t\tREP(i, n) {\n\t\t\tint a, b, ma, mb;\n\t\t\tscanf(\"%d %d %d %d\", &a, &b, &ma, &mb);\n\t\t\tint g = gcd(a, b);\n\t\t\t//a /= g; b /= g;\n\t\t\tnode[i] = Node(a, b, ma, mb);\n\t\t\t\n\t\t\tif (ma != 0) istop[ma - 1] = true;\n\t\t\tif (mb != 0) istop[mb - 1] = true;\n\t\t}\n\t\t\n\t\tint st = 0;\n\t\twhile (istop[st]) st++;\n\t\tcout << dfs(st) << endl;\n\t}\n\treturn 0;\n}\n\n// 1:45"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint depth[500];\nint w[500][2];\nint x[500][2];\nint n, root, v[500], a, A, B, C;\npair<int, int>DEPTH[500];\nint mobile[500][2];\n\nint gcd(int p, int q) {\n\tint P = p, Q = q;\n\twhile (true) {\n\t\tif (P%Q == 0) { return Q; }\n\t\tif (Q%P == 0) { return P; }\n\t\tif (P > Q) { P = P%Q; }\n\t\telse { Q = Q%P; }\n\t}\n}\n\nint main() {\n\twhile (true) {\n\t\tcin >> n;\n\t\tif (n == 0) { break; }\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tv[i] = 0;\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tcin >> w[i][0] >> w[i][1] >> x[i][0] >> x[i][1];\n\t\t\tv[x[i][0]] = 1; v[x[i][1]] = 1;\n\t\t\ta = gcd(w[i][0], w[i][1]);\n\t\t\tw[i][0] /= a; w[i][1] /= a;\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (v[i] == 0) {\n\t\t\t\troot = i;\n\t\t\t}\n\t\t}\n\t\t//depth.\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tdepth[i] = 1000;\n\t\t}\n\t\tdepth[root] = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tif (depth[j] != 1000) {\n\t\t\t\t\tdepth[x[j][0]] = min(depth[x[j][0]], depth[j] + 1);\n\t\t\t\t\tdepth[x[j][1]] = min(depth[x[j][1]], depth[j] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tDEPTH[i - 1].first = depth[i];\n\t\t\tDEPTH[i - 1].second = i;\n\t\t}\n\t\tsort(DEPTH, DEPTH + n);\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tA = DEPTH[i].first;\n\t\t\tB = DEPTH[i].second;\n\t\t\tif (x[B][0] == 0 && x[B][1] == 0) {\n\t\t\t\tmobile[B][0] = w[B][1];\n\t\t\t\tmobile[B][1] = w[B][0];\n\t\t\t}\n\t\t\tif (x[B][0] == 0 && x[B][1] >= 1) {\n\t\t\t\tmobile[B][1] = mobile[x[B][1]][0] + mobile[x[B][1]][1];\n\t\t\t\tmobile[B][1] = mobile[B][1] * w[B][0] / gcd(mobile[B][1], w[B][0]);\n\t\t\t\tmobile[B][0] = mobile[B][1] * w[B][1] / w[B][0];\n\t\t\t}\n\t\t\tif (x[B][0] >= 1 && x[B][1] == 0) {\n\t\t\t\tmobile[B][0] = mobile[x[B][0]][0] + mobile[x[B][0]][1];\n\t\t\t\tmobile[B][0] = mobile[B][0] * w[B][1] / gcd(mobile[B][0], w[B][1]);\n\t\t\t\tmobile[B][1] = mobile[B][0] * w[B][0] / w[B][1];\n\t\t\t}\n\t\t\tif (x[B][0] >= 1 && x[B][1] >= 1) {\n\t\t\t\tmobile[B][0] = mobile[x[B][0]][0] + mobile[x[B][0]][1];\n\t\t\t\tmobile[B][1] = mobile[x[B][1]][0] + mobile[x[B][1]][1];\n\t\t\t\tC = mobile[B][0] * w[B][0] * mobile[B][1] * w[B][1] / gcd(mobile[B][0] * w[B][0], mobile[B][1] * w[B][1]);\n\t\t\t\tmobile[B][0] = C / w[B][0];\n\t\t\t\tmobile[B][1] = C / w[B][0];\n\t\t\t}\n\t\t}\n\t\tcout << mobile[root][0] + mobile[root][1] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\ntypedef struct{\n\tint lch,rch,par,ll,rl;\n}N;\nN node[100];\nvoid swap(int& a,int& b){int p=a;a=b;b=p;}\nint gcd(int a,int b){\n\tif(a<b)swap(a,b);\n\tif(b==0)return a;\n\treturn gcd(b,a%b);\n}\nint dfs(int v){\n\tint lw=1,rw=1;\n\tN nd=node[v];\n\tif(nd.lch!=-1)lw=dfs(nd.lch);\n\tif(nd.rch!=-1)rw=dfs(nd.rch);\n\tint l=nd.ll;\n\tint r=nd.rl;\n\tint mom=r*rw;\n\trw*=l/gcd(mom,l);\n\tmom=r*rw/l;\n\tint d=gcd(lw,mom);\n\trw*=lw/d;\n\tlw*=mom/d;\n\treturn rw+lw;\n}\n\t\nint main(){\n\tint n;\n\tint i,j;\n\twhile(1){\n\tscanf(\"%d\",&n);\n\tif(n==0)return 0;\n\tfor(i=0;i<n;i++){\n\t\tN nd={-1,-1,-1,-1,-1};\n\t\tnode[i]=nd;\n\t}\n\tfor(i=0;i<n;i++){\n\t\tint ll,rl,lch,rch;\n\t\tscanf(\"%d %d %d %d\",&ll,&rl,&lch,&rch);\n\t\tif(lch!=0)node[lch-1].par=i;\n\t\tif(rch!=0)node[rch-1].par=i;\n\t\tnode[i].lch=lch-1;\n\t\tnode[i].rch=rch-1;\n\t\tnode[i].ll=ll;\n\t\tnode[i].rl=rl;\n\t}\n\tint p=0;\n\twhile(node[p].par!=-1)p=node[p].par;\n\tprintf(\"%d\\n\",dfs(p));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<cstring>\n#define max(a,b) (a>b?a:b)\nlong long int a[999],b[999],c[999],d[999],memo[999],res=0;\n\nlong long int gcd(long long int x,long long int y){\n\tif(x==0)return y;\n\telse return gcd(y%x,x);\n}\nlong long int solve(int x){\n\tif(memo[x]!=0)return memo[x];\n\tint left=a[x]*solve(c[x]),right=b[x]*solve(d[x]),gc;\ngc=gcd(left,right);\n\treturn memo[x]=right/gc*solve(c[x])+left/gc*solve(d[x]);\n}\n\nint main(){\n\tint n;\n\tfor(;scanf(\"%d\",&n),n!=0;memset(memo,0,sizeof(memo))){\n\t\tmemo[0]=1;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tscanf(\"%lld%lld%lld%lld\",a+i,b+i,c+i,d+i);\n\t\t}\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tres=max(res,solve(i));\n\t\t}\n\t\tprintf(\"%lld\\n\",res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <cmath>\n#include <map>\n#include <set>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n\n#define INF_LL 1e18\n#define INF 1e9\n\n#define REP(i, n) for(int i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n\n#define fst first\n#define snd second\n\nusing namespace std;\n\nusing ll = long long;\nusing PII = pair<int, int>;\n\nstruct stick{\n\tint l_d, r_d;\n\tint par, l, r;\n};\n\nstick s[101];\n\nll gcd(ll x, ll y){\n\tif(y == 0) return x;\n\treturn gcd(y, x%y);\n}\n\nll dfs(ll st){\n\tif(st == 0) return 1;\n\tll l_w = dfs(s[st].l);\n\tll r_w = dfs(s[st].r);\n\tll res = (l_w*r_w*s[st].l_d*s[st].r_d)/gcd(l_w*s[st].l_d, r_w*s[st].r_d);\n\tres = res/s[st].l_d + res/s[st].r_d;\n\treturn res;\n}\n\nint main(void){\n\tint n;\n\n\twhile(cin >> n && n){\n\t\tmemset(s, 0, sizeof s);\n\t\tFOR(i, 1, n+1){\n\t\t\ts[i].par = i;\n\t\t}\n\t\tFOR(i, 1, n+1){\n\t\t\tint a;\n\t\t\tcin >> s[i].l_d >> s[i].r_d >> s[i].l >> s[i].r;\n\t\t\ta = gcd(s[i].l_d, s[i].r_d);\n\t\t\ts[i].l_d /= a;\n\t\t\ts[i].r_d /= a;\n\t\t\ts[s[i].l].par = i;\n\t\t\ts[s[i].r].par = i;\n\t\t}\n\t\tint start = 1;\n\t\twhile(s[start].par != start){\n\t\t\tstart = s[start].par;\n\t\t}\n\t\tcout << dfs(start) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint gcd(int a,int b){return b?gcd(b,a%b):a;}\nint lcm(int a,int b){return a/gcd(a,b)*b;}\n\nint main(){\n  int n;\n  int par[100],left[100],right[100],p[100],q[100],r[100],b[100];\n  bool use[100];\n\n  while(cin >> n && n){\n    for(int i=0;i<n;i++)par[i] = -1;\n    for(int i=0;i<n;i++){\n      cin >> p[i] >> q[i] >> r[i] >> b[i];\n      int tmp = gcd(p[i],q[i]);\n      p[i]/=tmp;\n      q[i]/=tmp;\n      if(r[i]){\n\tleft[i] = 0;\n\tpar[r[i]-1] = i;\n      }else left[i] = 1;\n      if(b[i]){\n\tright[i] = 0;\n\tpar[b[i]-1] = i;\n      }else right[i] = 1;\n      use[i] = false;\n    }\n\n    int ans;\n    for(int j=0;j<n;j++){\n      for(int i=0;i<n;i++){\n\tif(!use[i] && left[i] && right[i]){\n\t  int tmp = lcm(right[i]*p[i],left[i]*q[i]);\n\t  right[i] = tmp/q[i];\n\t  left[i] = tmp/p[i];\n\t  ans = right[i] + left[i];\n\t  if(0<=par[i]){\n\t    if(r[par[i]]==i+1)left[par[i]] = ans;\n\t    else right[par[i]] = ans;\n\t  }\n\t  use[i] = true;\n\t  break;\n\t}\n      }\n    }\n    for(int i=0;i<n;i++)\n      if(par[i]<0)cout << right[i]+left[i] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n\nconstexpr int MAX_N=300;\n\nint n;\n\nusing ll=long long int;\n\nstruct Node {\n\n    int par,left,right;\n\n    int p,q;\n    \n    ll m;\n\n    Node() {\n\n        par=left=right=-1;\n\n        m=1;\n    }\n\n    void set(int _p,int _q,int _l,int _r) {\n        p=_p;\n        q=_q;\n        left=_l;\n        right=_r;\n    }\n};\n\nll gcd(ll x,ll y) {\n\n    if(x<y)\n        std::swap(x,y);\n\n    return y==0 ? x : gcd(y,x%y);\n}\n\nll lcm(ll x,ll y){\n\n    ll g=gcd(x,y);\n\n    return x*y/g;\n}\n\nNode nodes[MAX_N];\n\nint findRoot(int m){\n    return (nodes[m].par==-1) ? m : findRoot(nodes[m].par);\n}\n\nvoid init(int m){\n\n    if(m==-1)\n        return;\n\n    ll n=1;\n\n    if(nodes[m].par!=-1)\n        n=nodes[nodes[m].par].m;\n\n    nodes[m].m=lcm(n,nodes[m].m);\n\n    init(nodes[m].left);\n    init(nodes[m].right);\n}\n\nint solve(int m) {\n\n    ll l,r;\n\n    int p=nodes[m].p,q=nodes[m].q;\n\n    if(nodes[m].left==-1)\n        l=lcm(nodes[m].m,q);\n    else\n        l=solve(nodes[m].left);\n\n    if(nodes[m].right==-1)\n        r=lcm(nodes[m].m,p);\n    else\n        r=solve(nodes[m].right);\n\n    ll tmp=lcm(l*p,r*q);\n\n    int res=tmp/p+tmp/q;\n\n    return res;\n}\n\nint main() {\n\n    while(std::cin>>n,n){\n\n        int p,q,l,r;\n\n        for(int i=0;i<n;++i)\n            nodes[i]=Node();\n\n        for(int i=0;i<n;++i){\n            std::cin>>p>>q>>l>>r;\n            --l;\n            --r;\n            int g=gcd(p,q);\n            p/=g;\n            q/=g;\n            nodes[i].set(p,q,l,r);\n            if(l!=-1){\n                nodes[l].par=i;\n                nodes[l].m=q;    \n            }\n            if(r!=-1){\n                nodes[r].par=i;\n                nodes[r].m=p;\n            }\n        }\n\n        int root=findRoot(0);\n\n        init(root);\n\n        int ans=solve(root);\n\n        std::cout<<ans<<std::endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\nusing namespace std;\ntypedef long long ll;\n\nll n, p[100], q[100], r[100], b[100];\nbool isTop[100];\n\nll gcd(ll a, ll b) {\n  if (b == 0) return a;\n  return gcd(b, a % b);\n}\n\nll check(ll num) {\n  ll left = 1, right = 1;\n  if (r[num] != -1) left = check(r[num]);\n  if (b[num] != -1) right = check(b[num]);\n  ll g = gcd(p[num], q[num]);\n  p[num] /= g;\n  q[num] /= g;\n  ll temp = left * right / gcd(left, right);\n  ll g1 = gcd(p[num], temp);\n  ll g2 = gcd(q[num], temp);\n  return (p[num] + q[num]) * temp / (g1 * g2);\n}\n\nint main() {\n  while (1) {\n    scanf(\"%lld\", &n);\n    if (n == 0) break;\n    for (ll i = 0; i < n; i++) isTop[i] = true;\n    for (ll i = 0; i < n; i++) {\n      scanf(\"%lld%lld%lld%lld\", &p[i], &q[i], &r[i], &b[i]);\n      r[i]--, b[i]--;\n      if (r[i] != -1) isTop[r[i]] = false;\n      if (b[i] != -1) isTop[b[i]] = false;\n    }\n    ll top;\n    for (ll i = 0; i < n; i++) if (isTop[i]) { top = i; break; }\n    printf(\"%lld\\n\", check(top));\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nconst int NIL = -1;\n\nstruct Mobile {\n    int weight = NIL;\n    int left, right;\n    int left_child, right_child;\n    Mobile(int l, int r, int lc, int rc) :left(l), right(r), left_child(lc), right_child(rc) {}\n};\n\nint gcd(int a, int b) {\n    return b ? gcd(b, a % b) : a;\n}\n\nint lcm(int a, int b) {\n    return a * b / gcd(a, b);\n}\n\nint weight(vector<Mobile>& mobile, int n) {\n    if(n == NIL) return 1;\n    if(mobile[n].weight != NIL) return mobile[n].weight;\n    int left_weight = weight(mobile, mobile[n].left_child);\n    int right_weight = weight(mobile, mobile[n].right_child);\n    if(left_weight * mobile[n].right != right_weight * mobile[n].left) {\n        int d = lcm(left_weight * mobile[n].left, right_weight * mobile[n].right);\n        left_weight = d / mobile[n].left;\n        right_weight = d / mobile[n].right;\n    }\n    return mobile[n].weight = left_weight + right_weight;\n}\n\nint main() {\n    int n;\n    while(cin >> n, n) {\n        vector<Mobile> mobile;\n        for(int i = 0; i < n; ++i) {\n            int p, q, r, b;\n            cin >> p >> q >> r >> b;\n            int d = gcd(p, q);\n            p /= d;\n            q /= d;\n            --r;\n            --b;\n            mobile.push_back(Mobile(p, q, r, b));\n        }\n        int answer = 0;\n        for(int i = 0; i < n; ++i) answer = max(answer, weight(mobile, i));\n        cout << answer << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <map>\n#include <sstream>\n#include <string>\n#include <cstdio>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cstring>\n#include <tuple>\n#include <utility>\n#include <list>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> Array;\ntypedef pair<int, int> P;\n\nconst int INF = 1 << 29;\nconst LL MOD = 100000;\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define all(c) (c).begin(), (c).end()\n\nstruct edge{ int to, cost; edge(int t, int c) :to(t), cost(c){} };\n\nint dxk[] = { 1, 1, 1, 0, -1, 0 };\nint dxg[] = { 0, 1, 0, -1, -1, -1 };\nint dy[] = { -1, 0, 1, 1, 0, -1 };\n\nstruct node\n{\n\tLL value, lw, rw, left, right;\n};\n\nLL gcd(LL a, LL b)\n{\n\tif (a < b) swap(a, b);\n\treturn a % b == 0 ? b : gcd(b, a % b);\n}\nLL sks(LL a, LL b)\n{\n\tLL g = gcd(a, b);\n\treturn a / g * b;\n}\n\nLL dfs(int idx, vector<node>& bars)\n{\n\tif (idx == -1) return 1LL;\n\tnode& node = bars[idx];\n\tif (node.value != 0) return node.value;\n\n\tLL r = dfs(node.right, bars), l = dfs(node.left, bars);\n\n\tint m = 1;\n\twhile ((r * node.rw * m) % (l * node.lw) != 0) m++;\n\tint lm = r * node.rw * m / (l * node.lw);\n\t//r*lの最小公倍数を基礎値としてm:nにする\n\t//LL s = sks(r * node.rw, l * node.lw);\n\t//return node.value = s / node.rw + s / node.lw;\n\treturn node.value = m * r + lm * l;\n}\n\nint main()\n{\n\tint n;\n\twhile (cin >> n && n)\n\t{\n\t\tvector<node> bars(n);\n\t\trep(i, n)\n\t\t{\n\t\t\tint p, q, r, b;\n\t\t\tcin >> p >> q >> r >> b;\n\t\t\tint g = gcd(p, q);\n\t\t\tbars[i].rw = p / g;\n\t\t\tbars[i].lw = q / g;\n\t\t\tbars[i].left = r - 1;\n\t\t\tbars[i].right = b - 1;\n\t\t}\n\n\t\tLL ans = 0;\n\t\trep(i, n) ans = max(dfs(i, bars), ans);\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n\ntemplate <class T>\nint __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\nll gcd(ll a, ll b)\n{\n\tif (a < b)\n\t\tswap(a, b);\n\tif (b == 0)\n\t\treturn a;\n\treturn gcd(b, a%b);\n}\nll lcm(ll a, ll b)\n{\n\treturn a*b/gcd(a, b);\n}\nint p[101], q[101], r[101], b[101];\nll w[101];\nint dfs(int s)\n{\n\tif (w[s] != -1)\n\t\treturn w[s];\n\n\tif (s == 0)\n\t\treturn 1;\n\n\tll red = dfs(r[s]), blue = dfs(b[s]);\n\tll t = lcm(red*q[s], blue*p[s]);\n\treturn (int)(t/p[s] + t/q[s]);\n}\nint main()\n{\n\tint n;\n\twhile (scanf(\"%d\", &n), n)\n\t{\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t{\n\t\t\tscanf(\"%d%d%d%d\", p+i, q+i, r+i, b+i);\n\t\t\tll g = gcd(p[i], q[i]);\n\t\t\tp[i] /= g, q[i] /= g;\n\t\t}\n\t\tmemset(w, -1, sizeof(w));\n\t\tint res = 0;\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t\tres = max(res, dfs(i));\n\t\tprintf(\"%d\\n\", res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#define max(a,b) (a>b?a:b)\nlong long int a[101],b[101],c[101],d[101],memo[101],res=0;\n\nlong long int gcd(long long int x,long long int y){\n\tif(x==0)return y;\n\telse return gcd(y%x,x);\n}\nlong long int solve(int x){\n\tif(memo[x]!=0)return memo[x];\n\tint left=a[x]*solve(c[x]),right=b[x]*solve(d[x]),gc;\n\tgc=gcd(left,right);\n\treturn memo[x]=right/gc*solve(c[x])+left/gc*solve(d[x]);\n}\n\nint main(){\n\tint n;\n\tmemo[0]=1;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%lld%lld%lld%lld\",a+i,b+i,c+i,d+i);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tres=max(res,solve(i));\n\t}\n\tprintf(\"%lld\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i = (a); i < (b); i++)\n#define REP(i,n) FOR(i,0,n)\n\ntypedef long long ll;\n\nstruct Node {\n\tint a, b, ma, mb;\n\t\n\tNode() {}\n\tNode(int a, int b, int ma, int mb) : a(a), b(b), ma(ma), mb(mb) {}\n};\n\nint n;\nNode node[100];\nbool istop[100];\n\nint gcd(int a, int b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a % b);\n}\n\nint dfs(int pos) {\n\tNode &now = node[pos];\n\t\n\tint a = now.a, b = now.b, ma = now.ma, mb = now.mb;\n\t\n\tif (ma != 0) ma = dfs(ma - 1);\n\tif (mb != 0) mb = dfs(mb - 1);\n\t\n\tif (ma == 0 && mb == 0) {\n\t\treturn a + b;\n\t\n\t} else if (ma == 0 || mb == 0) {\n\t\tif (ma == 0) swap(ma, mb);\n\t\treturn ma * (a + b);\n\t\t\n\t}\n\telse {\n\t\tcout << a << \" \" << b << \" \" << ma << \" \" << mb << endl;\n\t\tint x = gcd(a * ma, b * mb);\n\t\tint res1 = mb * (a * ma / x);\n\t\tint res2 = ma * (b * mb / x);\n\t\treturn res1 + res2;\n\t}\n}\n\nint main() {\n\tcin >> n;\n\tREP(i, n) {\n\t\tint a, b, ma, mb;\n\t\tscanf(\"%d %d %d %d\", &a, &b, &ma, &mb);\n\t\tint g = gcd(a, b);\n\t\ta /= g; b /= g;\n\t\tnode[i] = Node(a, b, ma, mb);\n\t\t\n\t\tif (ma != 0) istop[ma - 1] = true;\n\t\tif (mb != 0) istop[mb - 1] = true;\n\t}\n\t\n\tint st = 0;\n\twhile (istop[st]) st++;\n\tcout << dfs(st) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\n\nstruct bar{\n\tint w;\n\tint pro[2];\n\tint ch[2];\n};\n\nbar b[101];\nint n;\n\nint gcd(int a, int b){\n\tif(a % b != 0){\n\t\treturn gcd(b,a%b);\n\t}\n\treturn b;\n}\nint lcm(int a,int b){\n\treturn a*b/gcd(a,b);\n}\n\nint gl(int a, int b){\n\treturn lcm(a,b)/gcd(a,b);\n}\n\nint main(){\n\twhile(scanf(\"%d\",&n),n != 0){\n\t\tfor(int i = 0; i < 101; i++){\n\t\t\tb[i].w = b[i].pro[0] = b[i].pro[1] = b[i].ch[0] = b[i].ch[1] = -1;\n\t\t}\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tint p,q,r,s;\n\t\t\tscanf(\"%d%d%d%d\",&p,&q,&r,&s);\n\t\t\tint g = gcd(p,q);\n\t\t\tb[i].pro[0] = p/g;\n\t\t\tb[i].pro[1] = q/g;\n\t\t\tb[i].ch[0] = r;\n\t\t\tb[i].ch[1] = s;\n\t\t}\n\t\tb[0].w = 0;\n\t\tint last = -1;\n\t\twhile(true){\n\t\t\tbool exist = false;\n\t\t\t\n\t\t\tfor(int i = 1; i <= n; i++){\n\t\t\t\tif(b[i].w == -1 && b[b[i].ch[0]].w >= 0 && b[b[i].ch[1]].w >= 0){\n\t\t\t\t\texist = true;\n\t\t\t\t\tif(b[b[i].ch[0]].w == 0){\n\t\t\t\t\t\tif(b[b[i].ch[1]].w == 0){\n\t\t\t\t\t\t\tb[i].w = b[i].pro[0] + b[i].pro[1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tb[i].w = lcm(b[i].pro[0],b[b[i].ch[1]].w)/b[i].pro[0]*(b[i].pro[0]+b[i].pro[1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tif(b[b[i].ch[1]].w == 0){\n\t\t\t\t\t\t\tb[i].w = lcm(b[i].pro[1],b[b[i].ch[0]].w)/b[i].pro[1]*(b[i].pro[1]+b[i].pro[0]);\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tint psum = b[i].pro[0] + b[i].pro[1];\n\t\t\t\t\t\t\tint gl0 = gl(b[b[i].ch[0]].w * psum, b[i].pro[1]);\n\t\t\t\t\t\t\tint gl1 = gl(b[b[i].ch[1]].w * psum, b[i].pro[0]);\n\t\t\t\t\t\t\tb[i].w = lcm(gl0,gl1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlast = b[i].w;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(!exist){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",last);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef vector<long long> vll;\ntypedef pair<int,int> pint;\ntypedef pair<long long, long long> pll;\n\n#define MP make_pair\n#define PB push_back\n#define ALL(s) (s).begin(),(s).end()\n#define EACH(i, s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P) \n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P) \n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P) \n{ EACH(it, P) { s << \"<\" << it->first << \"->\" << it->second << \"> \"; } return s; }\n\n\n\nlong long gcd(long long a, long long b) {\n    if (b == 0) return a;\n    if (a < 0) a = -a; if (b < 0) b = -b;\n    return gcd(b, a % b);\n}\nlong long lcm(long long a, long long b) {\n    long long g = gcd(a, b);\n    return a * b / g;\n}\nstruct frac {\n    long long first, second;\n    \n    frac normalize() {\n        if (second < 0) {first = -first; second = -second;}\n        long long d = gcd(first, second);\n        if (d == 0) {first = 0; second = 1;}\n        else {first /= d; second /= d;}\n        return *this;\n    }\n    frac(long long f = 0, long long s = 1) : first(f), second(s) { normalize(); }\n    inline frac operator - () { (*this).first *= -1; return (*this); }\n    inline const frac& operator = (long long a) { *this = frac(a, 1); return *this; }\n    inline const frac& operator += (const frac& a);\n    inline const frac& operator += (long long a);\n    inline const frac& operator -= (const frac& a);\n    inline const frac& operator -= (long long a);\n    inline const frac& operator *= (const frac& a);\n    inline const frac& operator *= (long long a);\n    inline const frac& operator /= (const frac& a);\n    inline const frac& operator /= (long long a);\n    friend ostream& operator << (ostream& s, const frac& f) { \n        s << f.first; if (f.second != 1) s << \"/\" << f.second; return s;\n    }\n};\nbool operator < (const frac& a, const frac& b) {\n    return (long double)(a.first) * b.second < (long double)(a.second) * b.first;\n}\nbool operator > (const frac& a, const frac& b) { return b < a; }\nbool operator <= (const frac& a, const frac& b) { return !(b < a); }\nbool operator >= (const frac& a, const frac& b) { return !(a < b); }\nbool operator != (const frac& a, const frac& b) { return a < b || b < a; }\nbool operator == (const frac& a, const frac& b) { return !(a < b) && !(b < a); }\nfrac operator + (const frac& a, const frac& b) {\n    frac res;\n    res.first = a.first * b.second + a.second * b.first;\n    res.second = a.second * b.second;\n    res.normalize();\n    return res;\n}\nfrac operator - (const frac& a, const frac& b) {\n    frac res;\n    res.first = a.first * b.second - a.second * b.first;\n    res.second = a.second * b.second;\n    res.normalize();\n    return res;\n}\nfrac operator * (const frac& a, const frac& b) {\n    frac res;\n    res.first = a.first * b.first;\n    res.second = a.second * b.second;\n    res.normalize();\n    return res;\n}\nfrac operator / (const frac& a, const frac& b) {\n    frac res;\n    res.first = a.first * b.second;\n    res.second = a.second * b.first;\n    res.normalize();\n    return res;\n}\nfrac abs(const frac& a) {\n    frac res; res = a; res.normalize(); \n    if (res.first < 0) res.first = res.first * (-1);\n    return res;\n}\ninline const frac& frac::operator += (const frac& x) {*this = *this + x; return *this;}\ninline const frac& frac::operator += (long long x) {*this = *this + x; return *this;}\ninline const frac& frac::operator -= (const frac& x) {*this = *this - x; return *this;}\ninline const frac& frac::operator -= (long long x) {*this = *this + x; return *this;}\ninline const frac& frac::operator *= (const frac& x) {*this = *this * x; return *this;}\ninline const frac& frac::operator *= (long long x) {*this = *this * x; return *this;}\ninline const frac& frac::operator /= (const frac& x) {*this = *this / x; return *this;}\ninline const frac& frac::operator /= (long long x) {*this = *this / x; return *this;}\n\n\n\nconst int MAX = 2100;\nint a[MAX], b[MAX];\nint L[MAX], R[MAX];\n\nint P[MAX];\n\nvector<frac> omori;\n\n\nint n;\n\nvoid rec(int v, frac f) {\n    frac left = f * frac(b[v], a[v]+b[v]);\n    frac right = f * frac(a[v], a[v]+b[v]);\n    \n    if (L[v] == -1) omori.PB(left);\n    else rec(L[v], left);\n    \n    if (R[v] == -1) omori.PB(right);\n    else rec(R[v], right);\n}\n\n\nint main() {\n    while (cin >> n) {\n        if (n == 0) break;\n        omori.clear();\n        \n        memset(P, -1, sizeof(P));\n        for (int i = 0; i < n; ++i) {\n            cin >> a[i] >> b[i] >> L[i] >> R[i];\n            ll g = gcd(a[i], b[i]);\n            a[i] /= g; b[i] /= g;\n            --L[i]; --R[i];\n            \n            P[L[i]] = i; P[R[i]] = i;\n        }\n        \n        int root = 0;\n        while (P[root] != -1) root = P[root];\n        \n        rec(root, frac(1,1));\n        \n//        COUT(root);\n//        COUT(omori);\n        \n        long long res = 1;\n        for (int i = 0; i < omori.size(); ++i) {\n            res = lcm(res, omori[i].second);\n        }\n        \n        cout << res << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\n#define MAX 101\nusing namespace std;\n\ntypedef long long int Integer;\n\nInteger GCD(Integer a, Integer b){return b==0?a:GCD(b,a%b);}\n\nstruct Mobile{\n  Mobile *parent,*pr,*pb;\n  Integer p,q,gcdpq,dp,dq;\n  Mobile(){parent=NULL;pr=NULL;pb=NULL;}\n  bool realizable(Integer W){\n    if( W<=1 ) return false;\n    if( (W*gcdpq)%(p+q) != 0 ) return false;\n    Integer k = (W*gcdpq)/(p+q);\n    if( k<=0 ) return false;\n    bool br=true,bb=true;\n    if(dq<dp){\n      if(pr){br=pr->realizable(k*dq);}\n      if(!br)return false;\n      if(pb){bb=pb->realizable(k*dp);}\n      if(!bb)return false;\n    }else{\n      if(pb){bb=pb->realizable(k*dp);}\n      if(!bb)return false;\n      if(pr){br=pr->realizable(k*dq);}\n      if(!br)return false;\n    }\n    return br&&bb;\n  }\n};\n\nint main()\n{\n  while(true){\n    int n;\n    Integer ans=-1;\n    cin >> n;\n    if( n == 0 )break;\n    Mobile *ms[MAX];\n    for(int i = 0; i < n; ++i){\n      ms[i+1] = new Mobile();\n    }\n    for(int i = 0; i < n; ++i){\n      Integer p,q,r,b;\n      cin >> p >> q >> r >> b;\n      ms[i+1]->p = p;\n      ms[i+1]->q = q;\n      ms[i+1]->gcdpq = GCD(p,q);\n      ms[i+1]->dp = p/ms[i+1]->gcdpq;\n      ms[i+1]->dq = q/ms[i+1]->gcdpq;\n      if(r>0){\n\tms[r]->parent=ms[i+1];ms[i+1]->pr=ms[r];\n      }else{\n\tms[i+1]->pr=NULL;\n      }\n      if(b>0){\n\tms[b]->parent=ms[i+1];ms[i+1]->pb=ms[b];\n      }else{\n\tms[i+1]->pb=NULL;\n      }\n    }\n    for(int i = 1; i <= n; ++i){\n      if( ms[i]->parent == NULL ){\n\tfor(Integer k = 0; ; ++k){\n\t  Integer P=ms[i]->p;\n\t  Integer Q=ms[i]->q;\n\t  Integer gcdPQ=ms[i]->gcdpq;\n\t  Integer W=(k*(P+Q))/gcdPQ;\n\t  if( (k*(P+Q))%gcdPQ==0 ){\n\t    if( ms[i]->realizable( W ) ){\n\t      ans = W;\n\t      break;\n\t    }\t    \n\t  }\n\t}\n\tbreak;\n      }\n    }\n\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//03\n#include<iostream>\n\nusing namespace std;\n\nint p[100],q[100],r[100],b[100];\n\nint gcd(int a,int b){\n  return b?gcd(b,a%b):a;\n}\n\nint dfs(int s){\n  if(s==0)return 1;\n  int x=dfs(r[s])*p[s],y=dfs(b[s])*q[s];\n  int z=x/gcd(x,y)*y;\n  return z/p[s]+z/q[s];\n}\n\nint main(){\n  for(int n;cin>>n,n;){\n    int fs=n*(n+1)/2;\n    for(int i=1;i<=n;i++){\n      cin>>p[i]>>q[i]>>r[i]>>b[i];\n      fs-=r[i]+b[i];\n    }\n    cout<<dfs(fs)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define X real()\n#define Y imag()\nusing namespace std;\ntypedef complex<int> cld;\ntypedef vector<cld> vcl;\ntypedef vector<int> vi; \ntypedef long long ll;\nll lcs(ll p, ll q){\n\tif(max(p,q) % min(p,q) ==0)\n\treturn min(p,q);\n\telse\n\treturn lcs(max(p,q)-min(p,q),min(p,q));\n}\nll gcd(ll p,ll q){\n\treturn p*q/lcs(p,q);\n}\nint main() {\n\tint n;\n\tcin >> n;\n\tbool fin[101]={1,0};\n\tll mobil[101][4]={};\n\tll grav[101]={1,0};\n\tll p,q,r,b;\n\tFOR(i,1,n+1){\n\t\tcin >> p >> q >> r >>b;\n\t\tll d=lcs(p,q);\n\t\tmobil[i][0]=p/d;\n\t\tmobil[i][1]=q/d;\n\t\tmobil[i][2]=r;\n\t\tmobil[i][3]=b;\n\t}\n\tint finishes=0;\n\twhile(finishes!=n){\n\t\tFOR(i,1,n+1)\n\t\t\tif(fin[mobil[i][2]] && fin[mobil[i][3]] && !fin[i]){\n\t\t\t\t\tgrav[i]=gcd(grav[mobil[i][2]],grav[mobil[i][3]])*(mobil[i][0]+mobil[i][1]);\n\t\t\t\t\tfin[i]=true;\n\t\t\t\t\tfinishes++;\n\t\t\t}\n\t}\n\tll sum=0;\n\tFOR(i,1,n+1)\n\tsum=max(sum,grav[i]);\n\tcout << sum << endl;\n\t// your code goes here\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<map>\n#include<cassert>\n#define F first\n#define S second\n#define PPins(a,b,c,d) PP(P(a,b),P(c,d))\n#define PPPins(a,b,c,d,e) PPP(a,PP(P(b,c),P(d,e)))\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\ntypedef pair<int,PP> PPP;\n\nmap<int,PP> tree;\nint top;\n\nint lcm(int a,int b)\n{\n  return a/__gcd(a,b)*b;\n}\n\nint rec(int n)\n{\n \n  int gcd = __gcd(tree[n].F.F,tree[n].F.S);\n  if(!tree[n].S.F && !tree[n].S.S)\n       return tree[n].F.F/gcd + tree[n].F.S/gcd;\n\n  if(tree[n].S.F && tree[n].S.S)\n    {\n      int Left = rec(tree[n].S.F);\n      int Right = rec(tree[n].S.S);\n   \n      return 2*lcm(tree[n].F.F/gcd*Left,tree[n].F.S/gcd*Right);\n\n    }\n\n  if(!tree[n].S.F && tree[n].S.S)\n    {      \n      int Right = rec(tree[n].S.S);\n      int x = lcm((Right*(tree[n].F.S/gcd)),tree[n].F.F/gcd)/tree[n].F.F;\n      //cout << \"In \" << n << \" x = \" << x << \" return = \" << (x*(tree[n].F.F/gcd))/(tree[n].F.S/gcd) + x << endl;\n      return (x*(tree[n].F.F/gcd))/(tree[n].F.S/gcd) + x;\n    }\n\n  if(tree[n].S.F && !tree[n].S.S)\n    {\n      int Left = rec(tree[n].S.F);\n      int x = lcm((Left*(tree[n].F.F/gcd)),tree[n].F.S/gcd)/tree[n].F.S;\n      //cout << \"In \" << n << \" x = \" << x << \" return = \" << (x*(tree[n].F.S/gcd))/(tree[n].F.F/gcd) + x << endl;\n      return (x*(tree[n].F.S/gcd))/(tree[n].F.F/gcd) + x;\n    }\n\n  assert(false);\n  return 0;\n}\n\nint main()\n{\n  int n;\n  while(true)\n    {\n      scanf(\"%d\",&n);\n      cerr << n << endl;\n      if(!n)\n\tbreak;\n      tree.clear();      \n      bool *who = new bool[n+1];\n      for(int i=0;i<n+1;i++)\n\twho[i] = false;\n      who[0] = true;\n      for(int i=0;i<n;i++)\n\t{\n\t  int p,q,r,b;\n\t  scanf(\"%d %d %d %d\",&p,&q,&r,&b);\n\t  tree[i+1] = PPins(p,q,r,b);\n\t  who[r] = who[b] = true;\n\t  cerr << p << q << r << b << endl;\n\t}\n\n      top = -1;\n      for(int i=1;i<n+1;i++)\n\tif(!who[i])\n\t  {\n\t    top = i;\n\t    break;\n\t  }\n      delete [] who;\n      assert(top != -1);\n      \n      cout << \"ans << \" ;\n      printf(\"%d\\n\",rec(top));    \n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\n#define mp make_pair\n\ntemplate<class T> void pv(T a, T b) { for (T i = a; i != b; ++i) cout << *i << \" \"; cout << endl; }\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\nstruct Stick{\n\tInt p,q,r,b;\n};\n\nvector<Stick> sticks;\nvector<Int> weight;\n\nInt gcd(Int a,Int b){\n\tif(a>b)return gcd(b,a); \n\telse if(a==0)return b;\n\telse return gcd(b%a,a);\n}\n\nint main() {\n\tint n;\n\twhile(n=in()){\n\t\tsticks.clear();\n\t\tweight.clear();\n\t\tint i;\n\t\tStick buf;\n\t\tfor(i=0;i<n;i++){\n\t\t\tcin>>buf.p>>buf.q>>buf.r>>buf.b;\n\t\t\tbuf.r--;buf.b--;\n\t\t\tsticks.push_back(buf);\n\t\t\tweight.push_back(0);\n\t\t}\n//for(i=0;i<n;i++)cout<<i<<\" \"<<sticks[i].p<<\" \"<<sticks[i].q<<\" \"<<sticks[i].r<<\" \"<<sticks[i].b<<endl;\n\t\tbool update=true;\n\t\twhile(update){\n\t\t\tupdate=false;\n\t\t\tfor(i=0;i<n;i++){\n\t\t\t\tif(weight[i]>0)continue;\n\t\t\t\tif(sticks[i].r==-1&&sticks[i].b==-1){\n\t\t\t\t\tweight[i]=(sticks[i].p+sticks[i].q)/gcd(sticks[i].p,sticks[i].q);\n\t\t\t\t\tupdate=true;\n\t\t\t\t}else if(sticks[i].r==-1&&weight[sticks[i].b]>0){\n\t\t\t\t\tInt r,b;\n\t\t\t\t\tb=weight[sticks[i].b]*sticks[i].p;\n\t\t\t\t\tr=b*sticks[i].q/sticks[i].p;\n\t\t\t\t\tweight[i]=(b+r)/gcd(r,sticks[i].p);\n\t\t\t\t\tupdate=true;\n\t\t\t\t}else if(sticks[i].b==-1&&weight[sticks[i].r]>0){\n\t\t\t\t\tInt r,b;\n\t\t\t\t\tr=weight[sticks[i].r]*sticks[i].q;\n\t\t\t\t\tb=r*sticks[i].p/sticks[i].q;\n\t\t\t\t\tweight[i]=(b+r)/gcd(b,sticks[i].q);\n\t\t\t\t\tupdate=true;\n\t\t\t\t}else if(weight[sticks[i].r]>0&&weight[sticks[i].b]>0){\n\t\t\t\t\tInt r,b;\n\t\t\t\t\tb=weight[sticks[i].b]*weight[sticks[i].r]*sticks[i].p;\n\t\t\t\t\tr=b*sticks[i].q/sticks[i].p;\n\t\t\t\t\tweight[i]=(b+r)/gcd(weight[sticks[i].b]*sticks[i].q,weight[sticks[i].r]*sticks[i].p);\n\t\t\t\t\tupdate=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//for(i=0;i<n;i++)cout<<i<<\" \"<<weight[i]<<endl;\n\t\tInt res=0;\n\t\tfor(i=0;i<n;i++){\n\t\t\tchmax(res,weight[i]);\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\ninline ll lcm(ll x, ll y)\n{\n    return x/__gcd(x,y)*y;\n}\n\ntypedef pair<ll,ll> F;\n\ninline F mul(const F& a, const F& b)\n{\n    ll p=a.fi*b.fi;\n    ll q=a.se*b.se;\n\n    ll g=__gcd(p,q);\n    p/=g;\n    q/=g;\n    return F(p,q);\n}\n\nvector<int> tlist;\nvector<int> G[100];\nvector<bool> vis;\n\nvoid dfs(int v)\n{\n    if(vis[v]) return;\n    vis[v]=true;\n    rep(i,G[v].size()) dfs(G[v][i]);\n    tlist.pb(v);\n}\n\nvoid tsort(int n)\n{\n    vis=vector<bool>(n,false);\n    rep(i,n) dfs(i);\n    reverse(all(tlist));\n}\n\ninline void init()\n{\n    tlist.clear();\n    rep(i,100) G[i].clear();\n}\n\nint main()\n{\n    int n;\n    while(scanf(\" %d\", &n),n)\n    {\n        init();\n\n        vector<ll> p(n),q(n);\n        vector<int> r(n),b(n);\n\n        rep(i,n)\n        {\n            scanf(\" %lld %lld %d %d\", &p[i], &q[i], &r[i], &b[i]);\n\n            ll g=__gcd(p[i],q[i]);\n            p[i]/=g;\n            q[i]/=g;\n\n            --r[i];\n            --b[i];\n\n            if(r[i]>=0) G[i].pb(r[i]);\n            if(b[i]>=0) G[i].pb(b[i]);\n        }\n\n        tsort(n);\n\n        vector<F> dat(n);\n        vector<F> w;\n\n        dat[tlist[0]] = F(1,1);\n        rep(i,n)\n        {\n            int idx = tlist[i];\n\n            ll D=p[idx]+q[idx];\n\n            F nr = mul(dat[idx],F(q[idx],D));\n            F nb = mul(dat[idx],F(p[idx],D));\n            if(r[idx]==-1) w.pb(nr);\n            else dat[r[idx]]=nr;\n            if(b[idx]==-1) w.pb(nb);\n            else dat[b[idx]]=nb;\n        }\n\n        ll M=1;\n        rep(i,w.size()) M = lcm(M,w[i].se);\n\n        ll ans=0;\n        rep(i,w.size())\n        {\n            F t = mul(w[i],F(M,1));\n            ans += t.fi;\n        }\n\n        printf(\"%lld\\n\", ans);\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nint gcd(int a, int b) {\n\tif (!b)return a;\n\treturn gcd(b, a%b);\n}\nint lcm(int a, int b) {\n\tint g = gcd(max(a, b), min(a, b));\n\treturn (a / g)*(b / g)*g;\n}\nstruct node {\n\tint p, q, left, right, parent;\n};\nint n;\nnode T[100];\nint w[100];\nvector<int>d[100];\n\nvoid bfs(int u, int i) {\n\tif (!~u)return;\n\td[i].push_back(u);\n\tbfs(T[u].left, i + 1);\n\tbfs(T[u].right, i + 1);\n}\nint main() {\n\twhile (scanf(\"%d\", &n), n) {\n\t\trep(i, n)d[i].clear();\n\t\trep(i, n) {\n\t\t\tint p, q, r, b; scanf(\"%d%d%d%d\", &p, &q, &r, &b);\n\t\t\tint g = gcd(max(p, q), min(p, q));\n\t\t\tT[i] = { p / g,q / g,--r,--b,-1 };\n\t\t}\n\t\trep(i, n) {\n\t\t\tif (~T[i].left)T[T[i].left].parent = i;\n\t\t\tif (~T[i].right)T[T[i].right].parent = i;\n\t\t}\n\t\tint root;\n\t\trep(i, n) {\n\t\t\tif (!~T[i].parent)root = i;\n\t\t}\n\t\tbfs(root, 0);\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tfor (int u : d[i]) {\n\t\t\t\tif (!~T[u].left && !~T[u].right)w[u] = T[u].p + T[u].q;\n\t\t\t\telse if (!~T[u].left) {\n\t\t\t\t\tint d = lcm(T[u].p, w[T[u].right]), e = lcm(T[u].q, w[T[u].right]);\n\t\t\t\t\tw[u] = d / T[u].p < e / T[u].q ? (d / T[u].p)*(T[u].p + T[u].q) : (e / T[u].q)*(T[u].p + T[u].q);\n\t\t\t\t}\n\t\t\t\telse if (!~T[u].right) {\n\t\t\t\t\tint d = lcm(T[u].p, w[T[u].left]), e = lcm(T[u].q, w[T[u].left]);\n\t\t\t\t\tw[u] = d / T[u].p < e / T[u].q ? (d / T[u].p)*(T[u].p + T[u].q) : (e / T[u].q)*(T[u].p + T[u].q);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint d = max(w[T[u].left], w[T[u].right]);\n\t\t\t\t\tint e = lcm(d, T[u].p);\n\t\t\t\t\tfor (int i = e;; i += e) {\n\t\t\t\t\t\tif (d == w[T[u].left]) {\n\t\t\t\t\t\t\tif ((i / T[u].p*T[u].q) % w[T[u].right] == 0) {\n\t\t\t\t\t\t\t\tw[u] = i / T[u].p*(T[u].p + T[u].q);\n\t\t\t\t\t\t\t\tgoto p;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif ((i / T[u].p*T[u].q) % w[T[u].left] == 0) {\n\t\t\t\t\t\t\t\tw[u] = i / T[u].p*(T[u].p + T[u].q);\n\t\t\t\t\t\t\t\tgoto p;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\te = lcm(d, T[u].q);\n\t\t\t\t\tfor (int i = e;; i += e) {\n\t\t\t\t\t\tif (d == w[T[u].left]) {\n\t\t\t\t\t\t\tif ((i / T[u].q*T[u].p) % w[T[u].right] == 0) {\n\t\t\t\t\t\t\t\tw[u] = i / T[u].q*(T[u].p + T[u].q);\n\t\t\t\t\t\t\t\tgoto p;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif ((i / T[u].q*T[u].p) % w[T[u].left] == 0) {\n\t\t\t\t\t\t\t\tw[u] = i / T[u].q*(T[u].p + T[u].q);\n\t\t\t\t\t\t\t\tgoto p;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tp:;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", w[root]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nint n, lp[109], rp[109], l[109], r[109];\nint gcd(int x, int y) {\n\tif (y == 0) return x;\n\treturn gcd(y, x % y);\n}\nint solve(int pos) {\n\tif (pos == -1) return 1;\n\tint ls = solve(l[pos]) * lp[pos];\n\tint rs = solve(r[pos]) * rp[pos];\n\tint p = ls / gcd(ls, rs) * rs;\n\treturn p / lp[pos] + p / rp[pos];\n}\nint main() {\n\twhile (scanf(\"%d\", &n), n) {\n\t\tfor (int i = 0; i < n; i++) scanf(\"%d%d%d%d\", &lp[i], &rp[i], &l[i], &r[i]), l[i]--, r[i]--;\n\t\tint ret = 0;\n\t\tfor (int i = 0; i < n; i++) ret = std::max(ret, solve(i));\n\t\tprintf(\"%d\\n\", ret);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint a[100+2],b[100+2],c[100+2],d[100+2],w[100+2],n;\n\nint s(int x){\n\tint ans;\n\tif(w[x]!=-1)return w[x];\n\telse {\n\t\tint e=a[x]*s(c[x]),f=b[x]*s(d[x]);\n\t\tint g=e,h=f,gcd;\n\t\twhile(1){\n\t\t\tg%=h;\n\t\t\tif(g==0)break;\n\t\t\th%=g;\n\t\t\tif(h==0)break;\n\t\t}\n\t\tgcd=e*f/max(g,h);\n\t\tans=gcd/a[x]+gcd/b[x];\n\t}\n\tw[x]=ans;\n\treturn ans;\n}\n\nint main(){\nwhile(1){\n\tint an=0;\n\tscanf(\"%d\",&n);\n\tif(n==0)break;\n\tw[0]=1;\n\tfor(int i=1;i<=n;i++){scanf(\"%d%d%d%d\",&a[i],&b[i],&c[i],&d[i]); w[i]=-1;}\n\tfor(int i=1;i<=n;i++){\n\t\tif(w[i]==-1)a[101]=s(i);\n\t\tif(an<w[i])an=w[i];\n\t}\n\tprintf(\"%d\\n\",an);\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint x[110][2],w[110][2],n;bool cal[110];int COU(int a,int b){while(true){if(a<2||b<2)return 1;if(a<b){int t=a;a=b,b=t;}a%=b;if(!a)return b;}}long long DFS(int q){if(!q)return 1;q--;long long a=DFS(w[q][0]),b=DFS(w[q][1]);return (a*b*(x[q][0]+x[q][1]))/COU(a*x[q][0],b*x[q][1]);}int main(){while(true){cin>>n;if(!n)break;for(int i=0;i<n;i++)cal[i]=false;for(int i=0;i<n;i++){cin>>x[i][0]>>x[i][1]>>w[i][0]>>w[i][1];cal[w[i][0]-1]=true,cal[w[i][1]-1]=true;}for(int i=0;i<n;i++)if(!cal[i])cout<<DFS(i+1)<<endl;}return 0;}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\n\n#pragma warning(disable : 4996)\n\nusing namespace std;\n\nint main()\n{\n\tint n; scanf(\"%d\", &n);\n\n\tvector<int> r(n);\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &r[i]);\n\t}\n\n\tint ret = 0, psum = 1;\n\n\tfor (int i = 1; i < n; i++)\n\t{\n\t\tif (r[i - 1] == r[i])\n\t\t{\n\t\t\tpsum = 1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpsum++;\n\t\t}\n\n\t\tret = max(ret, psum);\n\t}\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (int j = i + 1; j < n + 1; j++)\n\t\t{\n\t\t\tvector<int> c(r.begin(), r.end());\n\n\t\t\tfor (int k = i; k < j; k++)\n\t\t\t{\n\t\t\t\tc[k] ^= 1;\n\t\t\t}\n\n\t\t\tint sum = 1;\n\n\t\t\tfor (int k = 1; k < n; k++)\n\t\t\t{\n\t\t\t\tif (c[k - 1] == c[k])\n\t\t\t\t{\n\t\t\t\t\tsum = 1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tsum++;\n\t\t\t\t}\n\n\t\t\t\tret = max(sum, ret);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ret);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nstruct Stick {\n    int p, q, r, b;\n    Stick() {}\n    Stick(int pp, int qq, int rr, int bb) : p(pp), q(qq), r(rr), b(bb) {}\n};\n\nint gcd(int a, int b) {\n    if(a < b) return gcd(b, a);\n    while(true) {\n        int tmp = a % b;\n        a = b;\n        b = tmp;\n        if(b == 0) break;\n    }\n    return a;\n}\n\nint dfs(vector<Stick> &sticks, int pos) {\n    int wr = 1, wb = 1;\n    if(sticks[pos].r != 0) wr = dfs(sticks, sticks[pos].r);\n    if(sticks[pos].b != 0) wb = dfs(sticks, sticks[pos].b);\n\n    int mr = wr*sticks[pos].p;\n    int mb = wb*sticks[pos].q;\n    int g = gcd(mr, mb);\n    return wr*(mb/g) + wb*(mr/g);\n}\n\nint main() {\n    while(true) {\n        int n;\n        cin >> n;\n        if(!n) break;\n\n        vector<Stick> sticks(n+1);\n        vector<bool> is_child(n+1, false);\n        for(int i = 0; i < n; ++i) {\n            int p, q, r, b;\n            cin >> p >> q >> r >> b;\n            sticks[i+1] = Stick(p, q, r, b);\n            is_child[r] = is_child[b] = true;\n        }\n\n        int start = 1;\n        while(is_child[start]) ++start;\n        cout << dfs(sticks, start) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\nusing namespace std;\ntypedef long long ll;\nint N,cnt[110] = {};\nll p[110],q[110],r[110],b[110],dp[110] = {};\n\nll gcd(ll n,ll m){\n    assert(n!=0);\n    assert(m!=0);\n    if(n%m==0) return m;\n    else return gcd(m,n%m);\n}\n\nvoid dfs(int n){\n    if(n==0){\n        dp[0] = 1;\n    }else{\n        dfs(r[n]); dfs(b[n]);\n        assert(dp[r[n]] != 0);\n        assert(dp[b[n]] != 0);\n        assert(p[n] != 0);\n        assert(q[n] != 0);\n        ll g = gcd(dp[r[n]]*p[n],dp[b[n]]*q[n]);\n        assert(g!=0);\n        dp[n] = (dp[r[n]]*p[n])/g*dp[b[n]]+(dp[b[n]]*q[n])/g*dp[r[n]];\n    }\n    assert(dp[n]!=0);\n}\n\nint main(){\n    while((cin >> N) && (N>0)){\n        int par;\n        for(int i=0;i<=N;i++) cnt[i] = 0;\n        for(int i=1;i<=N;i++){\n            cin >> p[i] >> q[i] >> r[i] >> b[i];\n            cnt[r[i]]++; cnt[b[i]]++;\n        }\n        for(int i=1;i<=N;i++) if(cnt[i]==0) par = i;\n        dfs(par);\n        cout << dp[par] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n\nusing namespace std;\n\ntypedef vector<int> vi;\n\nint gcd(int n, int m){\n\treturn m==0?n:gcd(m, n%m);\n}\n\nint lcm(int n, int m){\n\tint g = gcd(n, m);\n\treturn n/g*m;\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n, n){\n\t\tvector<vi> v(n+1);\n\t\tvi k(n+1), w(n+1), cnt(n+1);\n\t\tw[0] = cnt[0] = 1;\n\t\tvi red(n+1), blue(n+1);\n\t\trep(i, n){\n\t\t\tint p, q, r, s;\n\t\t\tcin >> p >> q >> r >> s;\n\t\t\tint g = gcd(p,q);\n\t\t\tk[i+1] = p/g+q/g;\n\t\t\tred[i+1] = r;\n\t\t\tblue[i+1] = s;\n\t\t\tv[r].push_back(i+1);\n\t\t\tv[s].push_back(i+1);\n\t\t\tcnt[i+1] += !!r+!!s;\n\t\t}\n\t\tqueue<int> q;\n\t\tfor(int i = 1; i <= n; i++) if(!cnt[i]) q.push(i);\n\t\tint last = -1;\n\t\twhile(!q.empty()){\n\t\t\tint m = q.front();\n\t\t\tq.pop();\n\t\t\tlast = m;\n\n\t\t\tw[m] = k[m]*lcm(w[red[m]], w[blue[m]]);\n\n\t\t\trep(i, v[m].size()){\n\t\t\t\tcnt[v[m][i]]--;\n\t\t\t\tif(!cnt[v[m][i]]) q.push(v[m][i]);\n\t\t\t}\n\t\t}\n\t\tcout << w[last] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nunsigned int dp[110],K[110],O[110],L[110],R[110];\n\nint gcd(int a,int b){\n\tint tmp;\n\twhile((a%b)!=0){\n\t\ttmp=a%b;\n\t\ta=b;\n\t\tb=tmp;\n\t}\n\treturn b;\n}\n\n\nunsigned int mobi(unsigned int bou){\n\tif(bou==0) return 1;\n\tif(dp[bou]!=0) return dp[bou];\n\tunsigned int l,r,li,ri,gc,gc2,a,b;\n\tl=mobi(L[bou]);\n\tr=mobi(R[bou]);\n\tri=K[bou];li=O[bou];\n\tgc=gcd(li,ri);\n\tli/=gc;ri/=gc;\n\tgc2=gcd(li*l,ri*r);\n\tb=li*l/gc2;\n\ta=ri*r/gc2;\n\tdp[bou]=(a*l+b*r);\n\treturn dp[bou];\n}\n\nint main(){\n\tint N;\n\tunsigned int res;\n\twhile(1){\n\t\tcin>>N;\n\t\tif(N==0) break;\n\t\tmemset(dp,0,sizeof(dp));\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tcin>>K[i]>>O[i]>>L[i]>>R[i];\n\t\t}\n\t\tres=0;\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tres=max(res,mobi(i));\n\t\t}\n\t\t/*\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tcout<<i<<\" \"<<dp[i]<<endl;//\n\t\t}\n\t\t*/\n\t\tcout<<res<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<map>\n#include<cassert>\n#define F first\n#define S second\n#define PPins(a,b,c,d) PP(P(a,b),P(c,d))\n#define PPPins(a,b,c,d,e) PPP(a,PP(P(b,c),P(d,e)))\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\ntypedef pair<int,PP> PPP;\n\nmap<int,PP> tree;\nint top;\n\nint lcm(int a,int b)\n{\n  return a/__gcd(a,b)*b;\n}\n\nint rec(int n)\n{\n \n  int gcd = __gcd(tree[n].F.F,tree[n].F.S);\n  if(!tree[n].S.F && !tree[n].S.S)\n       return tree[n].F.F/gcd + tree[n].F.S/gcd;\n\n  if(tree[n].S.F && tree[n].S.S)\n    {\n      int Left = rec(tree[n].S.F);\n      int Right = rec(tree[n].S.S);\n   \n      return 2*lcm(tree[n].F.F/gcd*Left,tree[n].F.S/gcd*Right);\n\n    }\n\n  if(!tree[n].S.F && tree[n].S.S)\n    {      \n      int Right = rec(tree[n].S.S);\n      int rig   = tree[n].F.F/gcd*Right;\n      int Left = rig*(tree[n].F.S/gcd)/(tree[n].F.F/gcd);\n      return rig + Left;\n    }\n\n  if(!tree[n].S.F && tree[n].S.S)\n    {\n      int Left = rec(tree[n].S.F);\n      int lef   = tree[n].F.S/gcd*Left;\n      int Right = lef*(tree[n].F.F/gcd)/(tree[n].F.S/gcd);\n      return lef + Right;\n    }\n\n  assert(false);\n  return 0;\n}\n\nint main()\n{\n  int n;\n  while(true)\n    {\n      scanf(\"%d\",&n);\n      if(!n)\n\tbreak;\n      tree.clear();      \n      bool *who = new bool[n+1];\n      for(int i=0;i<n+1;i++)\n\twho[i] = false;\n      who[0] = true;\n      for(int i=0;i<n;i++)\n\t{\n\t  int p,q,r,b;\n\t  scanf(\"%d %d %d %d\",&p,&q,&r,&b);\n\t  tree[i+1] = PPins(p,q,r,b);\n\t  who[r] = who[b] = true;\n\t}\n\n      top = -1;\n      for(int i=1;i<n+1;i++)\n\tif(!who[i])\n\t  {\n\t    top = i;\n\t    break;\n\t  }\n      delete [] who;\n      assert(top != -1);\n      \n      printf(\"%d\\n\",rec(top));    \n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n#define int long long\n\nusing namespace std;\n\ntypedef struct Node {\n\tint p, q, r, b;\n} Node;\n\nint gcd(int a, int b){\n\tif(a < b){ return gcd(b, a); }\n\tif(b > 0){ return gcd(b, a % b); }\n\treturn a;\n}\nint lcm(int a, int b){\n\tlong long tmp = a;\n\ttmp *= b;\n\treturn (int)(tmp / gcd(a, b));\n}\n\nNode nodes[101];\n\nint calculate(int n){\n\tint d = gcd(nodes[n].p, nodes[n].q);\n\tint op = nodes[n].p / d, oq = nodes[n].q / d, answer;\n\tif(nodes[n].r == 0 && nodes[n].b == 0){\n\t\tanswer = op + oq;\n\t}else if(nodes[n].r == 0){\n\t\tint t = lcm(oq, calculate(nodes[n].b) * op);\n\t\tanswer = t / op + t / oq;\n\t}else if(nodes[n].b == 0){\n\t\tint t = lcm(op, calculate(nodes[n].r) * oq);\n\t\tanswer = t / op + t / oq;\n\t}else{\n\t\tint t = lcm(op * calculate(nodes[n].b), oq * calculate(nodes[n].r));\n\t\tanswer = t / op + t / oq;\n\t}\n\treturn answer;\n}\n\nint main(){\n\twhile(true){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n == 0){ break; }\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tcin >> nodes[i].p >> nodes[i].q >> nodes[i].r >> nodes[i].b;\n\t\t}\n\t\tbool flags[101] = { false };\n\t\tint remains = n;\n\t\twhile(remains > 1){\n\t\t\tbool tmpflg[101] = { false };\n\t\t\tfor(int i = 1; i <= n; i++){\n\t\t\t\tif(flags[i]){ continue; }\n\t\t\t\tif(\n\t\t\t\t\t(nodes[i].r == 0 && nodes[i].b == 0) ||\n\t\t\t\t\t(nodes[i].r == 0 && flags[nodes[i].b]) ||\n\t\t\t\t\t(flags[nodes[i].r] && nodes[i].b == 0) ||\n\t\t\t\t\t(flags[nodes[i].r] && flags[nodes[i].b])\n\t\t\t\t){\n\t\t\t\t\ttmpflg[i] = true;\n\t\t\t\t\tremains--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 1; i <= n; i++){\n\t\t\t\tflags[i] |= tmpflg[i];\n\t\t\t}\n\t\t}\n\t\tint root;\n\t\tfor(root = 1; root <= n; root++){\n\t\t\tif(!flags[root]){ break; }\n\t\t}\n\t\tprintf(\"%d\\n\", calculate(root));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\n#define MAX 101\nusing namespace std;\n\ntypedef long long int Integer;\n\nInteger GCD(Integer a, Integer b){return b==0?a:GCD(b,a%b);}\n\nstruct Mobile{\n  Mobile *parent,*pr,*pb;\n  Integer p,q,gcdpq;\n  Mobile(){parent=NULL;pr=NULL;pb=NULL;}\n  bool realizable(Integer W, bool R){\n    if( W<=1 ) return false;\n    if( (W*gcdpq)%(p+q) != 0 ) return false;\n    Integer k = (W*gcdpq)/(p+q);\n    if( k<=0 ) return false;\n    bool br=true,bb=true;\n    if(R){\n      if(pr){br=pr->realizable(k*(q/gcdpq),!R);}\n      if(!br)return false;\n      if(pb){bb=pb->realizable(k*(p/gcdpq),R);}\n      if(!bb)return false;\n    }else{\n      if(pb){bb=pb->realizable(k*(p/gcdpq),R);}\n      if(!bb)return false;\n      if(pr){br=pr->realizable(k*(q/gcdpq),!R);}\n      if(!br)return false;\n    }\n    return br&&bb;\n  }\n};\n\nint main()\n{\n  while(true){\n    int n;\n    Integer ans=-1;\n    cin >> n;\n    if( n == 0 )break;\n    Mobile *ms[MAX];\n    for(int i = 0; i < n; ++i){\n      ms[i+1] = new Mobile();\n    }\n    for(int i = 0; i < n; ++i){\n      Integer p,q,r,b;\n      cin >> p >> q >> r >> b;\n      ms[i+1]->p = p;\n      ms[i+1]->q = q;\n      ms[i+1]->gcdpq = GCD(p,q);\n      if(r>0){\n\tms[r]->parent=ms[i+1];ms[i+1]->pr=ms[r];\n      }else{\n\tms[i+1]->pr=NULL;\n      }\n      if(b>0){\n\tms[b]->parent=ms[i+1];ms[i+1]->pb=ms[b];\n      }else{\n\tms[i+1]->pb=NULL;\n      }\n    }\n    for(int i = 1; i <= n; ++i){\n      if( ms[i]->parent == NULL ){\n\tfor(Integer k = 0; ; ++k){\n\t  Integer P=ms[i]->p;\n\t  Integer Q=ms[i]->q;\n\t  Integer gcdPQ=ms[i]->gcdpq;\n\t  Integer W=(k*(P+Q))/gcdPQ;\n\t  if( (k*(P+Q))%gcdPQ==0 ){\n\t    if( ms[i]->realizable( W,true ) ){\n\t      ans = W;\n\t      break;\n\t    }\t    \n\t  }\n\t}\n\tbreak;\n      }\n    }\n\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint dp[110],K[110],O[110],L[110],R[110];\n\nint gcd(int a,int b){\n\tint tmp;\n\twhile((tmp=a%b)!=0){\n\t\ta=b;\n\t\tb=tmp;\n\t}\n\treturn b;\n}\n\n\nint mobi(int bou){\n\tif(bou==0) return 1;\n\tif(dp[bou]!=0) return dp[bou];\n\tint l,r,li,ri,gc,gc2,a,b;\n\tl=mobi(L[bou]);\n\tr=mobi(R[bou]);\n\tri=K[bou];li=O[bou];\n\tgc=gcd(li,ri);\n\tli/=gc;ri/=gc;\n\tgc2=gcd(li*l,ri*r);\n\tb=li*l/gc2;\n\ta=ri*r/gc2;\n\treturn (dp[bou]=(a*l+b*r));\n}\n\nint main(){\n\tint N,res;\n\twhile(1){\n\t\tcin>>N;\n\t\tif(N==0) break;\n\t\tmemset(dp,0,sizeof(dp));\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tcin>>K[i]>>O[i]>>L[i]>>R[i];\n\t\t}\n\t\tres=0;\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tres=max(res,mobi(i));\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nlong long gcd(long long a, long long b){ // 最大公約数\n    if(a == 0 || b == 0)\n        return 0;\n    if(b > a)\n        swap(a, b);\n    long long tmp;\n    while((tmp = a % b) != 0){\n        a = b;\n        b = tmp;\n    }\n    return b;\n}\n\nlong long lcm(long long a, long long b){ // 最小公倍数\n    return a / gcd(a, b) * b;\n}\n\nlong long solve(vector<vector<int> >& stick, int i)\n{\n    if(i == 0)\n        return 1;\n\n    long long p = stick[i][0];\n    long long q = stick[i][1];\n\n    long long a = solve(stick, stick[i][2]);\n    long long b = solve(stick, stick[i][3]);\n    long long tmp = lcm(p*a, q*b);\n    a = tmp / p;\n    b = tmp / q;\n\n    return a + b;\n}\n\nint main()\n{\n    for(;;){\n        int n;\n        cin >> n;\n        if(n == 0)\n            return 0;\n\n        vector<vector<int> > stick(n+1, vector<int>(4));\n        vector<bool> check(n+1, false);\n        for(int i=1; i<=n; ++i){\n            for(int j=0; j<4; ++j){\n                cin >> stick[i][j];\n            }\n            check[stick[i][2]] = check[stick[i][3]] = true;\n        }\n\n        long long ret = 0;\n        for(int i=1; i<=n; ++i){\n            if(!check[i])\n                ret += solve(stick, i);\n        }\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nint red[100];\nint blue[100];\nint le[100];\nint ri[100];\n\nint gcd(int a,int b){\n\tif(b>a){\ta^=b;\tb^=a;\ta^=b;\t}\n\twhile(1){\n\t\tint temp=a%b;\n\t\tif(temp==0)\tbreak;\n\t\ta=b;\tb=temp;\n\t}\n\treturn b;\n}\n\nint dfs(int now){\n\tint g=gcd(blue[now],red[now]);\tblue[now]/=g;\tred[now]/=g;\n\tint l=blue[now],r=red[now];\n\tif(le[now]!=0)\tl*=dfs(le[now]-1);\n\tif(ri[now]!=0)\tr*=dfs(ri[now]-1);\n\tif(l*red[now]<r*blue[now])\tl*=r/gcd(l,r)*blue[now]/red[now];\n\tif(l*red[now]>r*blue[now])\tr*=l/gcd(l,r)*red[now]/blue[now];\n\treturn l+r;\n}\n\t\nint main(){\n\twhile(true){\n\t\tcin>>n;\n\t\tif(n==0)\treturn 0;\n\t\tvector<int> parent(n,-1);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>red[i]>>blue[i]>>le[i]>>ri[i];\n\t\t\tif(le[i]!=0)\tparent[le[i]-1]=i;\t\n\t\t\tif(ri[i]!=0)\tparent[ri[i]-1]=i;\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(parent[i]==-1){\n\t\t\t\tcout<<dfs(i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint dp[110],K[110],O[110],L[110],R[110];\n\nint gcd(int a,int b){\n\tint tmp;\n\twhile((tmp=a%b)!=0){\n\t\ta=b;\n\t\tb=tmp;\n\t}\n\treturn b;\n}\n\n\nint mobi(int bou){\n\tif(bou==0) return 1;\n\tif(dp[bou]!=0) return dp[bou];\n\tint l,r,li,ri,gc,gc2,a,b;\n\tl=mobi(L[bou]);\n\tr=mobi(R[bou]);\n\tri=K[bou];li=O[bou];\n\tgc=gcd(li,ri);\n\tli/=gc;ri/=gc;\n\tgc2=gcd(li*l,ri*r);\n\tb=li*l/gc2;\n\ta=ri*r/gc2;\n\treturn dp[bou]=(a*l+b*r);\n}\n\nint main(){\n\tint N,res;\n\twhile(1){\n\t\tcin>>N;\n\t\tif(N==0) break;\n\t\tmemset(dp,0,sizeof(dp));\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tcin>>K[i]>>O[i]>>L[i]>>R[i];\n\t\t}\n\t\tres=0;\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tres=max(res,mobi(i));\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <cmath>\n#include <map>\n#include <set>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n\n#define INF_LL 1e18\n#define INF 1e9\n\n#define REP(i, n) for(int i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n\n#define fst first\n#define snd second\n\nusing namespace std;\n\nusing ll = long long;\nusing PII = pair<int, int>;\n\nstruct stick{\n\tint l_d, r_d;\n\tint par, l, r;\n};\n\nstick s[101];\n\nint gcd(int x, int y){\n\tif(y == 0) return x;\n\treturn gcd(y, x%y);\n}\n\nint dfs(int st){\n\tif(st == 0) return 1;\n\tint l_w = dfs(s[st].l);\n\tint r_w = dfs(s[st].r);\n\treturn l_w*r_w*(s[st].l_d+s[st].r_d)/gcd(l_w, s[st].l_d)/gcd(r_w, s[st].r_d);\n}\n\nint main(void){\n\tint n;\n\n\twhile(cin >> n && n){\n\t\tmemset(s, 0, sizeof s);\n\t\tFOR(i, 1, n+1){\n\t\t\ts[i].par = i;\n\t\t}\n\t\tFOR(i, 1, n+1){\n\t\t\tint a;\n\t\t\tcin >> s[i].l_d >> s[i].r_d >> s[i].l >> s[i].r;\n\t\t\ta = gcd(s[i].l_d, s[i].r_d);\n\t\t\ts[i].l_d /= a;\n\t\t\ts[i].r_d /= a;\n\t\t\ts[s[i].l].par = i;\n\t\t\ts[s[i].r].par = i;\n\t\t}\n\t\tint start = 1;\n\t\twhile(s[start].par != start){\n\t\t\tstart = s[start].par;\n\t\t}\n\t\tcout << dfs(start) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"math.h\"\n#include \"utility\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"iomanip\"\n#include \"random\"\n\nusing namespace std;\nconst long long int MOD = 1000000007;\n\nint N;\nlist<int>P;\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin >> N;\n\tP.push_back(2);\n\tfor (int i = 3; i < pow(2, 32); i += 2) {\n\t\tbool flag = true;\n\t\tfor (auto j : P) {\n\t\t\tif (i%j == 0) {\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (j*j > i)break;\n\t\t}\n\t\tif (flag)P.push_back(i);\n\t}\n\twhile (N) {\n\t\tvector<long long int>l(N);\n\t\tvector<long long int>r(N);\n\t\tvector<int>lx(N);\n\t\tvector<int>rx(N);\n\t\tvector<long long int>lw(N);\n\t\tvector<long long int>rw(N);\n\t\tvector<bool>flag(N, true);\n\t\tstack<int>node;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tint a, b, c, d;\n\t\t\tcin >> a >> b >> c >> d;\n\t\t\tc--;\n\t\t\td--;\n\t\t\tl[i] = a;\n\t\t\tr[i] = b;\n\t\t\tlx[i] = c;\n\t\t\trx[i] = d;\n\t\t\tif (c == -1)lw[i] = 1;\n\t\t\tif (d == -1)rw[i] = 1;\n\t\t\tif (c >= 0)flag[c] = false;\n\t\t\tif (d >= 0)flag[d] = false;\n\t\t}\n\t//\tcout << \"hijiki\";\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (flag[i]) {\n\t\t\t\tnode.push(i);\n\t\t\t}\n\t\t}\n\t\twhile (!node.empty()) {\n\t\t\tint current = node.top();\n\t\t\tif (lx[current] >= 0) {\n\t\t\t\tif (lw[lx[current]] && rw[lx[current]])lw[current] = lw[lx[current]] + rw[lx[current]];\n\t\t\t\telse {\n\t\t\t\t\tnode.push(lx[current]);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rx[current] >= 0) {\n\t\t\t\tif (lw[rx[current]] && rw[rx[current]])rw[current] = lw[rx[current]] + rw[rx[current]];\n\t\t\t\telse {\n\t\t\t\t\tnode.push(rx[current]);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (l[current] * lw[current] != r[current] * rw[current]) {\n\t\t\t\tlong long int a = r[current] * rw[current];\n\t\t\t\tlong long int b = l[current] * lw[current];\n\t\t\t\tfor (auto i : P) {\n\t\t\t\t\twhile(a%i==0&&b%i==0){\n\t\t\t\t\t\ta /= i;\n\t\t\t\t\t\tb /= i;\n\t\t\t\t\t}\n\t\t\t\t\tif (min(a, b) < i)break;\n\t\t\t\t}\n\t\t\t\tlw[current] *= a;\n\t\t\t\trw[current] *= b;\n\t\t\t}\n\t\t\tnode.pop();\n\t\t}\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (flag[i]) {\n\t\t\t\tcout << lw[i] + rw[i] << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcin >> N;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nint n;\nint p[101], q[101], r[101], b[101];\nlong long int w[101];\nlong long int ans;\n\nlong long int gcd(long long int m, long long int n){\n\tif(n == 0) return m;\n\telse return gcd(n, m%n);\n}\n\nlong long int lcm(long long int m, long long int n){\n\tlong long int g = gcd(m, n);\n\tm /= g;\n\tn /= g;\n\treturn g * m * n;\n}\n\nlong long int f(int x){\n\tif(w[x] != 0) return w[x];\n\tlong long int g = gcd(p[x], q[x]);\n\tp[x] /= g;\n\tq[x] /= g;\n\treturn (p[x] + q[x]) * lcm(f(r[x]), f(b[x]));\n}\n\nint main(){\n\twhile(1){\n\t\tscanf(\"%d\", &n);\n\t\tif(n == 0) break;\n\n\t\tmemset(w, 0, sizeof(w));\n\t\tw[0] = 1;\n\t\tans = 0;\n\t\tfor(int i=1; i<n+1; ++i) scanf(\"%d %d %d %d\", &p[i], &q[i], &r[i], &b[i]);\n\t\tfor(int i=1; i<n+1; ++i){\n\t\t\tw[i] = f(i);\n\t\t\tans = max(ans, w[i]);\n\t\t}\n\n\t\tprintf(\"%lld\\n\", ans);\n/*\n\t\tfor(int i=0; i<n+1; i++){\n\t\t\tprintf(\"%d %lld\\n\", i, w[i]);\n\t\t}\n*/\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n\nusing namespace std;\n\nstruct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nstruct tree {\n  ll p = -1, q = -1, r = -1, b = -1;\n};\n\ntree t[111];\n\nll dfs(int idx) {\n  ll left = 0, right = 0;\n  left  = (t[idx].r ? dfs(t[idx].r - 1) : 1) * t[idx].p;\n  right = (t[idx].b ? dfs(t[idx].b - 1) : 1) * t[idx].q;\n  ll k = left * right  / __gcd(left, right) / t[idx].p;\n  ll l = left * right / __gcd(left, right) / t[idx].q;\n  return k + l;\n}\n\nint main() {\n\n  for(int N; cin >> N && N;) {\n    rep(i, N) t[i] = {-1,-1,-1,-1};\n    set<int> st;\n    rep(i, N) {\n      int p, q, r, b; cin >> p >> q >> r >> b;\n      t[i] = {p, q, r, b};\n      if(r > 0) st.insert(r-1);\n      if(b > 0) st.insert(b-1);\n    }\n    rep(i, N) {\n      if(!st.count(i)) {\n        cout << dfs(i) << endl;\n        break;\n      }\n    }\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint gcd(int a,int b){return b?gcd(b,a%b):a;}\nint lcm(int a,int b){return a/gcd(a,b)*b;}\n\nint main(){\n  int n;\n  int par[100],left[100],right[100],p[100],q[100],r[100],b[100];\n  bool use[100];\n\n  while(cin >> n && n){\n    for(int i=0;i<n;i++)par[i] = -1;\n    for(int i=0;i<n;i++){\n      cin >> p[i] >> q[i] >> r[i] >> b[i];\n      int tmp = gcd(p[i],q[i]);\n      p[i]/=tmp;\n      q[i]/=tmp;\n      if(r[i]){\n\tleft[i] = 0;\n\tpar[r[i]-1] = i;\n      }else left[i] = 1;\n      if(b[i]){\n\tright[i] = 0;\n\tpar[b[i]-1] = i;\n      }else right[i] = 1;\n      use[i] = false;\n    }\n\n    int num = 0;\n    int ans;\n    while(num<n){\n      for(int i=0;i<n;i++){\n\tif(!use[i] && left[i] && right[i]){\n\t  int tmp = lcm(right[i],left[i]);\n\t  right[i] = tmp*p[i];\n\t  left[i] = tmp*q[i];\n\t  ans = right[i] + left[i];\n\t  if(0<=par[i]){\n\t    if(r[par[i]]==i+1)left[par[i]] = ans;\n\t    else right[par[i]] = ans;\n\t  }\n\t  use[i] = true;\n\t  break;\n\t}\n      }\n      num++;\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint a[100+2],b[100+2],c[100+2],d[100+2],w[100+2],n;\n\nint s(int x){\n\tint ans;\n\tif(w[x]!=-1)return w[x];\n\telse {\n\t\tint e=a[x]*s(c[x]),f=b[x]*s(d[x]);\n\t\tint g=e,h=f,gcd;\n\t\twhile(1){\n\t\t\tg%=h;\n\t\t\tif(g==0)break;\n\t\t\th%=g;\n\t\t\tif(h==0)break;\n\t\t}\n\t\tgcd=e*f/max(g,h);\n\t\tans=gcd/a[x]+gcd/b[x];\n\t}\n\tw[x]=ans;\n\treturn ans;\n}\n\nint main(){\n\tint an=0,aaa;\n\tscanf(\"%d\",&n);\n\tif(n==0)break;\n\tw[0]=1;\n\tfor(int i=1;i<=n;i++){scanf(\"%d%d%d%d\",&a[i],&b[i],&c[i],&d[i]); w[i]=-1;}\n\tfor(int i=1;i<=n;i++){\n\t\tif(w[i]==-1)aaa=s(i);\n\t\tif(an<w[i])an=w[i];\n\t}\n\tprintf(\"%d\\n\",an);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint gcd(int a,int b){return b?gcd(b,a%b):a;}\nint lcm(int a,int b){return a/gcd(a,b)*b;}\n\nint main(){\n  int n;\n  int par[100],left[100],right[100],p[100],q[100],r[100],b[100];\n  bool use[100];\n\n  while(cin >> n && n){\n    for(int i=0;i<n;i++)par[i] = -1;\n    for(int i=0;i<n;i++){\n      cin >> p[i] >> q[i] >> r[i] >> b[i];\n      int tmp = gcd(p[i],q[i]);\n      p[i]/=tmp;\n      q[i]/=tmp;\n      if(r[i]){\n\tleft[i] = 0;\n\tpar[r[i]-1] = i;\n      }else left[i] = 1;\n      if(b[i]){\n\tright[i] = 0;\n\tpar[b[i]-1] = i;\n      }else right[i] = 1;\n      use[i] = false;\n    }\n\n    int ans;\n    for(int j=0;j<n;j++){\n      for(int i=0;i<n;i++){\n\tif(!use[i] && left[i] && right[i]){\n\t  int tmp = lcm(right[i],left[i]);\n\t  right[i] = tmp*p[i];\n\t  left[i] = tmp*q[i];\n\t  ans = right[i] + left[i];\n\t  if(0<=par[i]){\n\t    if(r[par[i]]==i+1)left[par[i]] = ans;\n\t    else right[par[i]] = ans;\n\t  }\n\t  use[i] = true;\n\t  break;\n\t}\n      }\n    }\n    for(int i=0;i<n;i++)\n      if(par[i]<0)cout << right[i]+left[i] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"math.h\"\n#include \"utility\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"iomanip\"\n#include \"random\"\n\nusing namespace std;\nconst long long int MOD = 1000000007;\n\nint N;\nlist<int>P;\nlist<long long int>ans;\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin >> N;\n\tP.push_back(2);\n\tfor (int i = 3; i < pow(2,16); i += 2) {\n\t\tbool flag = true;\n\t\tfor (auto j : P) {\n\t\t\tif (i%j == 0) {\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (j*j > i)break;\n\t\t}\n\t\tif (flag)P.push_back(i);\n\t}\n\twhile (N) {\n\t\tvector<long long int>l(N);\n\t\tvector<long long int>r(N);\n\t\tvector<int>lx(N);\n\t\tvector<int>rx(N);\n\t\tvector<long long int>lw(N);\n\t\tvector<long long int>rw(N);\n\t\tvector<bool>flag(N, true);\n\t\tstack<int>node;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tint a, b, c, d;\n\t\t\tcin >> a >> b >> c >> d;\n\t\t\tc--;\n\t\t\td--;\n\t\t\tfor (auto i : P) {\n\t\t\t\twhile (a%i == 0 && b%i == 0) {\n\t\t\t\t\ta /= i;\n\t\t\t\t\tb /= i;\n\t\t\t\t}\n\t\t\t\tif (min(a, b) < i)break;\n\t\t\t}\n\t\t\tl[i] = a;\n\t\t\tr[i] = b;\n\t\t\tlx[i] = c;\n\t\t\trx[i] = d;\n\t\t\tif (c == -1 && d == -1) {\n\n\t\t\t\tlw[i] = r[i];\n\t\t\t\trw[i] = l[i];\n\t\t\t}\n\t\t\telse if (c == -1)lw[i] = 1;\n\t\t\telse if (d == -1)rw[i] = 1;\n\t\t\tif (c >= 0)flag[c] = false;\n\t\t\tif (d >= 0)flag[d] = false;\n\t\t}\n\t//\tcout << \"hijiki\";\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (flag[i]) {\n\t\t\t\tnode.push(i);\n\t\t\t}\n\t\t}\n\t\twhile (!node.empty()) {\n\t\t\tint current = node.top();\n\t\t\tbool con = false;\n\t\t\tif (lx[current] >= 0) {\n\t\t\t\tif (lw[lx[current]] && rw[lx[current]])lw[current] = lw[lx[current]] + rw[lx[current]];\n\t\t\t\telse {\n\t\t\t\t\tnode.push(lx[current]);\n\t\t\t\t\tcon = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rx[current] >= 0) {\n\t\t\t\tif (lw[rx[current]] && rw[rx[current]])rw[current] = lw[rx[current]] + rw[rx[current]];\n\t\t\t\telse {\n\t\t\t\t\tnode.push(rx[current]);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (con)continue;\n\t\t\tif (l[current] * lw[current] != r[current] * rw[current]) {\n\t\t\t\tlong long int a = r[current] * rw[current];\n\t\t\t\tlong long int b = l[current] * lw[current];\n\t\t\t\tfor (auto i : P) {\n\t\t\t\t\twhile(a%i==0&&b%i==0){\n\t\t\t\t\t\ta /= i;\n\t\t\t\t\t\tb /= i;\n\t\t\t\t\t}\n\t\t\t\t\tif (min(a, b) < i)break;\n\t\t\t\t}\n\t\t\t\tlw[current] *= a;\n\t\t\t\trw[current] *= b;\n\t\t\t}\n\t\t//\tcout << current << \" \" << lw[current] << \" \" << rw[current] << endl;\n\t\t\tnode.pop();\n\t\t}\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (flag[i]) {\n\t\t\t\tans.push_back(lw[i] + rw[i]);\n\t\t\t\t//cout << lw[i] + rw[i] << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcin >> N;\n\t}\n\tfor (auto i : ans)cout << i << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define ALL(a) (a).begin(),(a).end()\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\nconst int INF=1e9;\nint gcd(int a,int b){\n  if(b==0)return a;\n  return gcd(b,a%b);\n}\nint main(){\n  int n;\n  while(cin>>n&&n){\n    vector<int>G[110];\n    int w[110],p[110],q[110],r[110],b[110];\n    memset(w,-1,sizeof(w));\n    for(int i=1;i<=n;i++){\n      cin>>p[i]>>q[i]>>r[i]>>b[i];\n      int g=gcd(p[i],q[i]);\n      p[i]/=g;q[i]/=g;\n      if(r[i]==0&&b[i]==0){\n        w[i]=p[i]+q[i];\n      }else{\n        G[r[i]].PB(i);\n        G[b[i]].PB(i);\n      }\n    }\n    bool update=true;\n    while(update){\n      update=false;\n      for(int i=1;i<=n;i++){\n        if(w[i]!=-1)continue;\n        if((r[i]==0||w[r[i]]!=-1)&&(b[i]==0||w[b[i]]!=-1)){\n          if(r[i]==0||b[i]==0){\n            if(r[i]==0)w[i]=w[b[i]]*(p[i]+q[i]);\n            else w[i]=w[r[i]]*(p[i]+q[i]);\n          }else{\n            int g=gcd(w[r[i]]*q[i],w[b[i]]*p[i]);\n            w[i]=w[r[i]]*w[b[i]]*p[i]*q[i]/g*2;\n          }\n          update=true;\n        }\n      }\n    }\n    int ans=0;\n    for(int i=1;i<=n;i++)ans=max(w[i],ans);\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nint p[128], q[128], r[128], b[128];\n\nint m[128];\n\nint re(int i)\n{\n  if (m[i] != -1) return m[i];\n  if (i == 0) {\n    return 1;\n  }\n\n  int x = re(r[i]);\n  int y = re(b[i]);\n\n  int red = x * p[i];\n  int blu = y * q[i];\n\n  int gcd = __gcd(red, blu);\n  int lcm = red * blu / gcd;\n\n  m[i] = (lcm / p[i]) + (lcm / q[i]);\n  return m[i];\n}\n\nint main()\n{\n  cin >> n;\n  for (int i = 1; i <= n; i++){\n    cin >> p[i] >> q[i] >> r[i] >> b[i];\n  }\n\n  memset(m, -1, sizeof(m));\n\n  int max_ = -1;\n  for (int i = 1; i <= n; i++){\n    max_ = max(max_, re(i));\n  }\n\n  cout << max_ << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <cstring>\nusing namespace std;\n\nint dp[110],K[110],O[110],L[110],R[110];\n\nint gcd(int a,int b){\n\tint tmp;\n\tif(a<b) swap(a,b);\n\twhile((tmp=a%b)!=0){\n\t\ta=b;\n\t\tb=tmp;\n\t}\n\treturn b;\n}\n\n\nint mobi(int bou){\n\tif(bou==0) return 1;\n\tif(dp[bou]!=0) return dp[bou];\n\tint l,r,li,ri,gc,gc2,a,b;\n\tl=mobi(L[bou]);\n\tr=mobi(R[bou]);\n\tri=K[bou];li=O[bou];\n\tgc=gcd(li,ri);\n\tli/=gc;ri/=gc;\n\tgc2=gcd(li*l,ri*r);\n\tb=li*l/gc2;\n\ta=ri*r/gc2;\n\tdp[bou]=(a*l+b*r);\n\treturn dp[bou];\n}\n\nint main(){\n\tint N;\n\tint res;\n\twhile(1){\n\t\tcin>>N;\n\t\tif(N==0) break;\n\t\tmemset(dp,0,sizeof(dp));\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tcin>>K[i]>>O[i]>>L[i]>>R[i];\n\t\t}\n\t\tres=0;\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tres=max(res,mobi(i));\n\t\t}\n\t\t/*\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tcout<<i<<\" \"<<dp[i]<<endl;//\n\t\t}\n\t\t*/\n\t\tcout<<res<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long lli;\n\nconst int N = 100;\n\nint n, p[N+1], q[N+1], r[N+1], b[N+1];\nbool vis[N+1];\n\nlli lcm(lli x, lli y){\n  return x * y / __gcd(x, y);\n}\n\nlli solve(int pos){\n  lli t1, t2;\n  if(r[pos]) t1 = solve(r[pos]);\n  if(b[pos]) t2 = solve(b[pos]);\n  lli tmp1 = p[pos];\n  lli tmp2 = q[pos];\n  if(r[pos] && b[pos]){\n    tmp1 = lcm(t1, (lli)p[pos]);\n    tmp2 = lcm(t2, (lli)q[pos]);\n    tmp1 = lcm(tmp1, tmp2);\n    tmp2 = tmp1;\n  }else if(r[pos]){\n    tmp1 = lcm(t1, (lli)p[pos]);\n    tmp2 = (lli)q[pos] * (tmp1 / t1);\n  }else if(b[pos]){\n    tmp2 = lcm(t2, (lli)q[pos]);\n    tmp1 = (lli)p[pos] * (tmp2 / t2);\n  }\n  //cout << pos << ' ' << tmp1 << ' ' << tmp2 << endl;\n  return tmp1 + tmp2;\n}\n\nmain(){\n  while(cin >> n && n){\n    fill(vis, vis+N+1, false);\n    for(int i=1;i<=n;i++){\n      cin >> p[i] >> q[i] >> r[i] >> b[i];\n      lli tmp = __gcd(p[i], q[i]);\n      p[i] /= tmp;\n      q[i] /= tmp;\n      vis[r[i]] = vis[b[i]] = true;\n    }\n    for(int i=1;i<=n;i++) if(!vis[i]) cout << solve(i) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <set>\n#include <map>\n#include <list>\n#include <iterator>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <string>\n#include <cmath>\n#include <complex>\n#include <functional>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cassert>\n#include <cstdlib>\n#include <cctype>\n\n#define REP(i,m,n) for(int i=m;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rp(i,c) rep(i,(int)c.size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define mp make_pair\n#define pb push_back\n#define all(c) (c).begin(),(c).end()\n#define rall(u) (u).rbegin(),(u).rend()\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define v_delete(a,b) (a).erase(remove((a).begin(), (a).end(), b), (a).end())\n#define v_unique(a) (a).erase(unique((a).begin(), (a).end()), (a).end())\n#define VV(T) vector<vector< T > >\n#define init(a,b) memset((a), (b), sizeof((a)))\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf=1<<28;\nconst double INF=1e10,EPS=1e-9;\n\n\ntemplate<class T>int SIZE(T a){return a.size();}\ntemplate<class T>string IntToString(T num){string res;stringstream ss;ss<<num;return ss.str();}\ntemplate<class T>T StringToInt(string str){T res=0;for(int i=0;i<SIZE(str);i++)res=(res*10+str[i]-'0');return res;}\ntemplate<class T>T gcd(T a,T b){if(b==0)return a;return gcd(b,a%b);}\ntemplate<class T>T lcm(T a,T b){return a/gcd(a,b)*b;}\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntypedef pair<int,int> pii;\n\nint N;\n\nvector<pii> L;\nvector<pii> W;\nint memo[101];\n\nint rec(int n){\n\tif(memo[n])\n\t\treturn memo[n];\n\tif(W[n].first == -1 && W[n].second == -1){\n\t\tint l=L[n].second;\n\t\tint r=L[n].first;\n\t\tint gcd_ = gcd(l, r);\n\t\tl /= gcd_;\n\t\tr /= gcd_;\n\t\treturn memo[n]=l+r;\n\t}else if(W[n].first == -1){\n\t\tint l, r;\n\t\tr = rec(W[n].second);\n\t\tint lcm_ = lcm(r*L[n].second, L[n].first);\n\t\tr= lcm_/L[n].second;\n\t\tl = lcm_/L[n].first;\n\t\treturn memo[n]=l+r;\n\t}else if(W[n].second == -1){\n\t\tint l, r;\n\t\tl = rec(W[n].first);\n\t\tint lcm_ = lcm(l*L[n].first, L[n].second);\n\t\tr = lcm_/L[n].second;\n\t\tl=lcm_/L[n].first;\n\t\treturn memo[n]=l+r;\n\t}else{\n\t\tint l, r;\n\t\tl = rec(W[n].first);\n\t\tr = rec(W[n].second);\n\t\tint lcm_ = lcm(l*L[n].first, r*L[n].second);\n\t\tl = lcm_/L[n].first;\n\t\tr = lcm_/L[n].second;\n\t\treturn memo[n]=l+r;\n\t}\n\n\treturn 0;\n}\n\nint main() {\n\twhile(cin >> N, N){\n\t\tL.clear();\n\t\tW.clear();\n\t\tmemset(memo, 0, sizeof(memo));\n\t\trep(i, N){\n\t\t\tint p,q,r,b;\n\t\t\tcin >> p >> q >> r >> b;\n\t\t\tL.pb(mp(p, q));\n\t\t\tW.pb(mp(r - 1 ,b - 1));\n\t\t}\n\t\tint m=0;\n\t\trep(i, N){\n\t\t\tm=max(m,rec(i));\n\t\t}\n\t\tcout << m << endl;\n\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int, int>;\nusing vi = vector<int>;\nusing ll = long long;\n\nint solve(vector<pii> const& g, vector<pii> const& p, int v) {\n    int l = 1, r = 1;\n    if(g[v].first != -1) {\n        l = solve(g, p, g[v].first);\n    }\n    if(g[v].second != -1) {\n        r = solve(g, p, g[v].second);\n    }\n    int G = __gcd(l * p[v].first, r * p[v].second);\n    int L = l * (r * p[v].second / G);\n    int R = r * (l * p[v].first / G);\n    return L + R;\n}\n\nint main() {\n    int n;\n    while(cin >> n, n) {\n        vector<pii> g(n), p(n);\n        vector<bool> is_root(n, true);\n        for(int i = 0; i < n; ++i) {\n            cin >> p[i].first >> p[i].second >> g[i].first >> g[i].second;\n            g[i].first--; g[i].second--;\n            if(g[i].first >= 0) {\n                is_root[g[i].first] = false;\n            }\n            if(g[i].second >= 0) {\n                is_root[g[i].second] = false;\n            }\n        }\n        int r = find(begin(is_root), end(is_root), true) - begin(is_root);\n        cout << solve(g, p, r) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\ntypedef long long ll;\nint n;\nstruct P {\n\tll p, q, r, l;\n};\nP a[101];\nint o[101];\nint s(ll a, ll b) {\n\tif (a > b)\n\t\tswap(a, b);\n\twhile (a > 0) {\n\t\tll c = a;\n\t\ta = b%a;\n\t\tb = c;\n\t}\n\treturn b;\n}\nll solve(ll i) {\n\tif (a[i].r == 0 && a[i].l == 0) {\n\t\treturn a[i].p + a[i].q;\n\t}\n\tll d, e, f, g, h;\n\tif (a[i].r == 0)\n\t\td = a[i].q;\n\telse\n\t\td = solve(a[i].r);\n\te = s(d, a[i].q);\n\te = (e*(d / e)*(a[i].q / e));\n\tf = (e / a[i].q*a[i].p);\n\tif (a[i].l == 0)\n\t\td = a[i].p;\n\telse\n\t\td = solve(a[i].l);\n\tg = s(d, f);\n\tg = (g*(f / g)*(d / g));\n\th = (g / f)*e + g;\n\treturn h;\n}\nint main() {\n\twhile (cin >> n&&n != 0) {\n\t\tfor (int i = 0; i <= n; i++)\n\t\t\to[i] = -1;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tcin >> a[i].p >> a[i].q >> a[i].r >> a[i].l;\n\t\t\tll u = s(a[i].p, a[i].q);\n\t\t\ta[i].p = (a[i].p / u);\n\t\t\ta[i].q = (a[i].q / u);\n\t\t\to[a[i].r] = i;\n\t\t\to[a[i].l] = i;\n\t\t}\n\t\tll ans = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (o[i] == -1) {\n\t\t\t\tcout << solve(i) << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i = (a); i < (b); i++)\n#define REP(i,n) FOR(i,0,n)\n\nstruct Node {\n\tint a, b, ma, mb;\n\t\n\tNode() {}\n\tNode(int a, int b, int ma, int mb) : a(a), b(b), ma(ma), mb(mb) {}\n};\n\nint n;\nNode node[100];\nbool istop[100];\n\nint gcd(int a, int b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a % b);\n}\n\nint dfs(int pos) {\n\tNode &now = node[pos];\n\t\n\tint a = now.a, b = now.b, ma = now.ma, mb = now.mb;\n\t\n\tif (ma != 0) ma = dfs(ma - 1);\n\tif (mb != 0) mb = dfs(mb - 1);\n\t\n\tif (ma == 0 && mb == 0) {\n\t\treturn a + b;\n\t\n\t} else if (ma == 0 || mb == 0) {\n\t\tif (ma == 0) swap(ma, mb);\n\t\treturn ma * (a + b);\n\t\t\n\t}\n\telse {\n\t\tint x = gcd(a * ma, b * mb);\n\t\tint res1 = mb * (a * ma / x);\n\t\tint res2 = ma * (b * mb / x);\n\t\treturn res1 + res2;\n\t}\n}\n\nint main() {\n\twhile (cin >> n, n) {\n\t\tfill(istop, istop + n, false);\n\t\t\n\t\tREP(i, n) {\n\t\t\tint a, b, ma, mb;\n\t\t\tscanf(\"%d %d %d %d\", &a, &b, &ma, &mb);\n\t\t\tnode[i] = Node(a, b, ma, mb);\n\t\t\t\n\t\t\tif (ma != 0) istop[ma - 1] = true;\n\t\t\tif (mb != 0) istop[mb - 1] = true;\n\t\t}\n\t\t\n\t\tint st = 0;\n\t\twhile (istop[st]) st++;\n\t\tcout << dfs(st) << endl;\n\t}\n\treturn 0;\n}\n\n// 1:45"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\n#define REP(i,a,b) for(i=a; i<b; ++i)\n#define rep(i,n) REP(i,0,n)\n\nstruct mobile {\n  long long lm,rm;\n  long long lc,rc,ll,rl;\n  mobile(long long lc,long long rc,long long ll,long long rl)\n  : lc(lc), rc(rc), ll(ll), rl(rl) {\n    lm = rm = -1;\n  }\n};\n\nint gcd(int a,int b) {\n  return b != 0 ? gcd(b, a%b) : a;\n}\n\nlong long lcm(long long a,long long b) {\n  return a/gcd(a,b)*b;\n}\n\nint dfs(int pos,vector<mobile> &vm) {\n  mobile now = vm[pos];\n  now.lm = (now.lc == -1) ? 1 : dfs(now.lc,vm);\n  now.rm = (now.rc == -1) ? 1 : dfs(now.rc,vm);\n  int g = lcm(now.ll*now.lm, now.rl*now.rm);\n  now.rm = g / now.rl;\n  now.lm = g / now.ll;\n  return now.rm+now.lm;\n}\n\nint main() {\n  int n,i,p,q,r,b,root;\n  while(cin>>n, n) {\n    vector<mobile> vm;\n    vector<bool> isroot(n+1,true);\n    root = -1;\n    rep(i,n) {\n      cin>>p>>q>>r>>b;\n      isroot[r] = isroot[b] = false;\n      r--,b--;\n      vm.push_back(mobile(r,b,p,q));\n    }\n\n    rep(i,n) if(isroot[i] == true) cout<<dfs(i-1,vm)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint a[100+2],b[100+2],c[100+2],d[100+2],w[100+2],n;\n\nint s(int x){\n\tint ans;\n\tif(w[x]!=-1)return w[x];\n\telse {\n\t\tint e=a[x]*s(c[x]),f=b[x]*s(d[x]);\n\t\tint g=e,h=f,gcd;\n\t\twhile(1){\n\t\t\tg%=h;\n\t\t\tif(g==0)break;\n\t\t\th%=g;\n\t\t\tif(h==0)break;\n\t\t}\n\t\tgcd=e*f/max(g,h);\n\t\tans=gcd/a[x]+gcd/b[x];\n\t}\n\tw[x]=ans;\n\treturn ans;\n}\n\nint main(){\n\tint an=0,aaa;\n\tscanf(\"%d\",&n);\n\tw[0]=1;\n\tfor(int i=1;i<=n;i++){scanf(\"%d%d%d%d\",&a[i],&b[i],&c[i],&d[i]); w[i]=-1;}\n\tfor(int i=1;i<=n;i++){\n\t\tif(w[i]==-1)aaa=s(i);\n\t\tif(an<w[i])an=w[i];\n\t}\n\tprintf(\"%d\\n\",an);\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nll gcd(ll a, ll b) {\n  return b != 0 ? gcd(b, a % b) : a;\n}\n\nconst ll WEIGHT=-1;\nstruct stick{\n\tll r,b,p,q;\n\tstick(ll r,ll b,ll p,ll q):r(r),b(b){\n\t\tll g=gcd(p,q);\n\t\tthis->p=p/g;\n\t\tthis->q=q/g;\n\t}\n\tll getroot(ll index,vector<stick> &sticks){\n\t\tREP(i,sticks.size()){\n\t\t\tif(sticks[i].r==index||sticks[i].b==index){\n\t\t\t\treturn sticks[i].getroot(i,sticks);\n\t\t\t}\n\t\t}\n\t\treturn index;\n\t}\n\tll go(vector<stick> &sticks){\n\t\tll rw=0,bw=0;\n\t\tif(r!=WEIGHT){\n\t\t\trw=sticks[r].go(sticks);\n\t\t}\n\t\tif(b!=WEIGHT){\n\t\t\tbw=sticks[b].go(sticks);\n\t\t}\n\t\tif(r==WEIGHT&&b==WEIGHT){\n\t\t\trw=q;\n\t\t\tbw=p;\n\t\t}else if(r==WEIGHT){\n\t\t\tif(p*bw%q){\n\t\t\t\trw=bw*p;\n\t\t\t\tbw*=q;\n\t\t\t}else{\n\t\t\t\trw=bw*p/q;\n\t\t\t\tassert(bw);\n\t\t\t}\n\t\t}else if(b==WEIGHT){\n\t\t\tif(q*rw%p){\n\t\t\t\tbw=rw*q;\n\t\t\t\trw*=p;\n\t\t\t}else{\n\t\t\t\tbw=rw*q/p;\n\t\t\t\tassert(rw);\n\t\t\t}\n\t\t}else{\n\t\t\tll trw=rw,tbw=bw;\n\t\t\tll gr=gcd(rw,q);\n\t\t\tll gb=gcd(bw,p);\n\t\t\trw=trw*tbw*q/gr;\n\t\t\tbw=tbw*trw*p/gb;\n\t\t\tassert(bw);\n\t\t\tassert(rw);\n\t\t}\n\t\tassert(rw&&bw);\n\t\treturn rw+bw;\n\t}\n};\n\n\nint main(){\n\tll n;\n\twhile(cin>>n,n){\n\t\tvector<stick> sticks;\n\t\tREP(i,n){\n\t\t\tll p,q,r,b;\n\t\t\tcin>>p>>q>>r>>b;\n\t\t\tr--;b--;\n\t\t\tsticks.push_back(stick(r,b,p,q));\n\t\t}\n\t\tll root=sticks[0].getroot(0,sticks);\n\t\tcout<<sticks[root].go(sticks)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nint gcd(int a, int b) {\n\tif (a % b == 0)return b;\n\treturn gcd(b, a % b);\n}\n\nint lcm(int a, int b) {\n\treturn a / gcd(a, b) * b;\n}\n\nstruct Mobile {\n\tint l, r, left, right, parent;\n};\n\nint n;\nMobile m[100];\n\nint solve(int x) {\n\n\tif (m[x].left == 0 && m[x].right == 0) {\n\t\treturn m[x].l + m[x].r;\n\t}\n\tif (m[x].left == 0) {\n\t\tint Right = solve(m[x].right - 1);\n\t\tint magni = lcm(Right, m[x].l);\n\t\tRight = lcm(Right, m[x].l);\n\t\treturn Right + magni / m[x].l * m[x].r;\n\t}\n\n\tif (m[x].right == 0) {\n\t\tint Left = solve(m[x].left - 1);\n\t\tint magni = lcm(Left, m[x].r);\n\t\tLeft = lcm(Left, m[x].r);\n\t\treturn Left + magni / m[x].r * m[x].l;\n\t}\n\n\tint Left = solve(m[x].left - 1), Right = solve(m[x].right - 1);\n\treturn lcm(Left * m[x].r, Right) + lcm(Right * m[x].l, Left);\n}\n\nint main() {\n\twhile (cin >> n, n) {\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tm[i].l = 0, m[i].r = 0, m[i].left = 0, m[i].right = 0;\n\t\t\tm[i].parent = -1;\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> m[i].l >> m[i].r >> m[i].left >> m[i].right;\n\t\t\tif (m[i].left != 0)m[m[i].left - 1].parent = i;\n\t\t\tif (m[i].right != 0)m[m[i].right - 1].parent = i;\n\n\t\t\t{\n\t\t\t\tint l = m[i].l, r = m[i].r;\n\t\t\t\tm[i].l /= gcd(l, r), m[i].r /= gcd(l, r);\n\t\t\t}\n\t\t}\n\n\n\t\tint x = 0;\n\t\twhile (1) {\n\t\t\tif (m[x].parent == -1) break;\n\t\t\tx = m[x].parent;\n\t\t}\n\n\t\tcout << solve(x) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//  Lightest Mobile.cpp\n//  2013/01/03.\n\n#if 1\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nint B[128][4];\n\nint __lcm(int a, int b)\n{\treturn a * b / __gcd(a, b); }\n\nint rec(int idx)\n{\n\tint a = (B[idx][2] == 0 ? 1 : rec(B[idx][2]-1));\n\tint b = (B[idx][3] == 0 ? 1 : rec(B[idx][3]-1));\n\t\n\tint p = B[idx][0];\n\tint q = B[idx][1];\n\t\n\tint lcm = __lcm(p*a, q*b);\n\t\n\treturn lcm / q + lcm / p;\n}\n\nint main()\n{\n    for(int n; cin >> n && n; )\n\t{\n\t\tvint pflag(n+1, true);\n\t\t\n\t\trep(i, n)\n\t\t{\n\t\t\trep(j, 4) cin >> B[i][j];\n\t\t\t\n\t\t\tpflag[B[i][2]] = false;\n\t\t\tpflag[B[i][3]] = false;\n\t\t}\n\t\t\n\t\trep(i, n) if(pflag[i+1]) cout << rec(i) << endl;\n\t}\n}\n\n#endif"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define int long long\n\n#define CHOOSE(a) CHOOSE2 a\n#define CHOOSE2(a0,a1,a2,a3,x,...) x\n#define REP1(i, s, cond, cal) for (signed i = signed(s); i cond; i cal)\n#define REP2(i, s, n) REP1(i, s, < signed(n), ++)\n#define REP3(i, n) REP2(i, 0, n)\n#define rep(...) CHOOSE((__VA_ARGS__,REP1,REP2,REP3))(__VA_ARGS__)\n#define rrep(i, s) rep(i, s, >= 0, --)\n\n#define all(c) begin(c), end(c)\ntemplate<typename T>bool maxup(T& a, const T&& b) { if (a < b) { a = b; return true; }; }\ntemplate<typename T>bool maxup(T& a, const T& b) { if (a < b) { a = b; return true; }; }\ntemplate<typename T>bool minup(T& a, const T&& b) { if (a > b) { a = b; return true; }; }\ntemplate<typename T>bool minup(T& a, const T& b) { if (a > b) { a = b; return true; }; }\n\n#define X first\n#define Y second\n\nusing VV = vector<vector<int>>;\nusing V = vector<int>;\nusing P = pair<int, int>;\nusing IP = pair<int, P>;\n\ntemplate<typename T>\ninline void input(vector<T>& v) { for (auto& x : v) cin >> x; }\n\n\nVV g;\nvector<P> len;\nvector<P> w;\n\nint dfs(int now) {\n\tint a = g[now][0] >= 0 ? dfs(g[now][0]) : 1;\n\tint b = g[now][1] >= 0 ? dfs(g[now][1]) : 1;\n\tint p, q;\n\ttie(p, q) = len[now];\n\tint gcd = __gcd(a*p, b*q);\n\tint x = b*q / gcd;\n\tint y = a*p / gcd;\n\treturn a*x + b*y;\n}\n\nsigned main() {\n\tint n; cin >> n;\n\tg.resize(n);\n\tw.resize(n, P(1, 1));\n\tlen.resize(n);\n\tV root(n, true);\n\trep(i, n) {\n\t\tint p, q, r, b;\n\t\tcin >> p >> q >> r >> b;\n\t\tr--; b--;\n\t\tint gcd = __gcd(p, q);\n\t\tp = p / gcd;\n\t\tq = q / gcd;\n\t\tif (~r) root[r] = false;\n\t\tif (~b) root[b] = false;\n\t\tg[i].push_back(r);\n\t\tg[i].push_back(b);\n\t\tlen[i] = P(p, q);\n\t}\n\tint idx = find(all(root), true) - root.begin();\n\tcout << dfs(idx) << endl;\n\n\t//system(\"pause\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint solve(int idx, const vector<int>& p, const vector<int>& q, const vector<int>& r, const vector<int>& b)\n{\n  int left = 1, right = 1;\n  if (r[idx] != 0)\n    left = solve(r[idx], p, q, r, b);\n  if (b[idx] != 0)\n    right = solve(b[idx], p, q, r, b);\n\n  int left_p = left * p[idx];\n  int right_p = right * q[idx];\n  int lcm = left_p / __gcd(left_p, right_p) * right_p;  \n  return lcm / p[idx] + lcm / q[idx];\n}\n\nint main()\n{\n  int n;\n  while (cin >> n) {\n    if (n == 0)\n      break;\n\n    vector<int> p(n+1), q(n+1), r(n+1), b(n+1), d(n+1, 0);\n    for (int i = 1; i <= n; ++i) {\n      cin >> p[i] >> q[i] >> r[i] >> b[i];\n      d[r[i]] = d[b[i]] = 1;\n    }\n\n    int top = 0;\n    for (int i = 1; i < n+1; ++i) {\n      if (!d[i])\n\ttop = i;\n    }\n \n    cout << solve(top, p, q, r, b) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nll gcd(ll a, ll b) {\n  return b != 0 ? gcd(b, a % b) : a;\n}\nll lcm(ll a,ll b){\n  return a / gcd(a,b) * b;\n}\n\nconst ll WEIGHT=-1;\nstruct stick{\n\tll r,b,p,q;\n\tstick(ll r,ll b,ll p,ll q):r(r),b(b){\n\t\tll g=gcd(p,q);\n\t\tthis->p=p/g;\n\t\tthis->q=q/g;\n\t}\n\tll getroot(ll index,vector<stick> &sticks){\n\t\tREP(i,sticks.size()){\n\t\t\tif(sticks[i].r==index||sticks[i].b==index){\n\t\t\t\treturn sticks[i].getroot(i,sticks);\n\t\t\t}\n\t\t}\n\t\treturn index;\n\t}\n\tll go(vector<stick> &sticks){\n\t\tll rw=0,bw=0;\n\t\tif(r!=WEIGHT){\n\t\t\trw=sticks[r].go(sticks);\n\t\t}\n\t\tif(b!=WEIGHT){\n\t\t\tbw=sticks[b].go(sticks);\n\t\t}\n\t\tif(r==WEIGHT&&b==WEIGHT){\n\t\t\trw=q;\n\t\t\tbw=p;\n\t\t}else if(r==WEIGHT){\n\t\t\tif(p*bw%q){\n\t\t\t\trw=bw*p;\n\t\t\t\tbw*=q;\n\t\t\t}else{\n\t\t\t\trw=bw*p/q;\n\t\t\t\tassert(bw);\n\t\t\t}\n\t\t}else if(b==WEIGHT){\n\t\t\tif(q*rw%p){\n\t\t\t\tbw=rw*q;\n\t\t\t\trw*=p;\n\t\t\t}else{\n\t\t\t\tbw=rw*q/p;\n\t\t\t\tassert(rw);\n\t\t\t}\n\t\t}else{\n\t\t\tll l = lcm(p * rw, q * bw);\n\t\t\tcerr<<l<<\",\"<<p<<\",\"<<q<<endl;\n\t\t\trw=l/p;\n\t\t\tbw=l/q;\n\t\t}\n\t\tassert(rw&&bw);\n\t\treturn rw+bw;\n\t}\n};\n\n\nint main(){\n\tll n;\n\twhile(cin>>n,n){\n\t\tvector<stick> sticks;\n\t\tREP(i,n){\n\t\t\tll p,q,r,b;\n\t\t\tcin>>p>>q>>r>>b;\n\t\t\tr--;b--;\n\t\t\tsticks.push_back(stick(r,b,p,q));\n\t\t}\n\t\tll root=sticks[0].getroot(0,sticks);\n\t\tcout<<sticks[root].go(sticks)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nint gcd(int a, int b) {\n\tif (a % b == 0)return b;\n\treturn gcd(b, a % b);\n}\n\nint lcm(int a, int b) {\n\treturn a / gcd(a, b) * b;\n}\n\nstruct Mobile {\n\tint l, r, left, right, parent;\n};\n\nint n;\nMobile m[100];\n\nint solve(int x) {\n\tint Left, Right;\n\n\tif (m[x].left == 0)Left = 1;\n\telse Left = solve(m[x].left - 1);\n\tif (m[x].right == 0)Right = 1;\n\telse Right = solve(m[x].right - 1);\n\n\tcout << x << \" \" << lcm(Left * m[x].r, Right * m[x].l) / m[x].r + lcm(Left * m[x].r, Right * m[x].l) / m[x].l << endl;\n\treturn lcm(Left * m[x].l, Right * m[x].r) / m[x].r + lcm(Left * m[x].l, Right * m[x].r) / m[x].l;\n}\n\nint main() {\n\twhile (cin >> n, n) {\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tm[i].l = 0, m[i].r = 0, m[i].left = 0, m[i].right = 0;\n\t\t\tm[i].parent = -1;\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> m[i].l >> m[i].r >> m[i].left >> m[i].right;\n\t\t\tif (m[i].left != 0)m[m[i].left - 1].parent = i;\n\t\t\tif (m[i].right != 0)m[m[i].right - 1].parent = i;\n\t\t\t{\n\t\t\t\tint l = m[i].l, r = m[i].r;\n\t\t\t\tm[i].l = m[i].l / gcd(l, r), m[i].r = m[i].r / gcd(l, r);\n\t\t\t}\n\t\t}\n\t\tint x = 0;\n\t\twhile (1) {\n\t\t\tif (m[x].parent == -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tx = m[x].parent;\n\t\t}\n\t\tcout << solve(x) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <cstring>\nusing namespace std;\n\nint dp[110],K[110],O[110],L[110],R[110];\n\nint gcd(int a,int b){\n\tint tmp;\n\tif(a<b) swap(a,b);\n\twhile((tmp=a%b)!=0){\n\t\ta=b;\n\t\tb=tmp;\n\t}\n\treturn b;\n}\n\n\nint mobi(int bou){\n\tif(bou==0) return 1;\n\tif(dp[bou]!=0) return dp[bou];\n\tint l,r,li,ri,gc2,a,b;\n\tl=mobi(L[bou]);\n\tr=mobi(R[bou]);\n\tri=K[bou];li=O[bou];\n\tgc2=gcd(li*l,ri*r);\n\tb=li*l/gc2;\n\ta=ri*r/gc2;\n\tdp[bou]=(a*l+b*r);\n\tif(dp[bou]==0) while(true);//\n\treturn dp[bou];\n}\n\nint main(){\n\tint N,k,o,g;\n\tint res;\n\twhile(1){\n\t\tcin>>N;\n\t\tif(N==0) break;\n\t\tmemset(dp,0,sizeof(dp));\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tcin>>k>>o>>L[i]>>R[i];\n\t\t\tg=gcd(k,o);\n\t\t\tK[i]=k/g;\n\t\t\tO[i]=o/g;\n\t\t}\n\t\tres=0;\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tres=max(res,mobi(i));\n\t\t}\n\t\t/*\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tcout<<i<<\" \"<<dp[i]<<endl;//\n\t\t}\n\t\t*/\n\t\tcout<<res<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n\nstruct stick{\n\tint left;\n\tint right;\n\tint lnode;\n\tint rnode;\n};\n\n\nvector<stick> sticks;\n\nint gcd(int a,int b){\n\tif(b==0)\n\t\treturn a;\n\telse\n\t\treturn gcd(b,a%b);\n}\n\nint lcm(int a,int b){\n\treturn a*b/gcd(a,b);\n}\n\nint isBalanced(int idx){\n\t\n\tint lw,rw;\n\tif(sticks[idx].lnode==-1){\n\t\tlw=1;\n\t}\n\telse{\n\t\tlw=isBalanced(sticks[idx].lnode);\n\t}\n\n\tif(sticks[idx].rnode==-1){\n\t\trw=1;\n\t}\n\telse{\n\t\trw=isBalanced(sticks[idx].rnode);\n\t}\n\n\tint l=lcm(lw*sticks[idx].left,rw*sticks[idx].right);\n\treturn (l/(sticks[idx].left))+(l/(sticks[idx].right));\n}\n\nint main(){\n\n\tint n;\n\tbool ff[200];\n\twhile(cin>>n&&n!=0){\n\t\tstick s;\n\t\tfill(ff,ff+200,false);\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin>>s.left>>s.right>>s.lnode>>s.rnode;\n\t\t\ts.lnode--;\n\t\t\ts.rnode--;\n\t\t\tsticks.push_back(s);\n\t\t\tif(s.lnode!=-1)\n\t\t\t\tff[s.lnode]=true;\n\t\t\tif(s.rnode!=-1)\n\t\t\t\tff[s.rnode]=true;\n\t\t}\n\t\tint start;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(!ff[i]){\n\t\t\t\tstart=i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcout<<isBalanced(start)<<endl;\n\t\tsticks.clear();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\nusing namespace std;\n\nint N;\n\ntypedef long long int ll;\ntypedef pair<ll,ll>P;\n\nconst int LEAF = 0;\nvector<P>pv;\n\nclass T{\npublic:\n  int p,q,r,b;\n  int par;\n  T(){par = -1;}\n};\n\nvector<T>vec;\n\nvoid init(){\n  vec.clear();\n  pv.clear();\n}\n\nvoid input(){\n\n  for(int i = 0 ; i <= N ; i++){\n    T t;\n    vec.push_back(t);\n  }\n\n  for(int i = 1 ; i <= N ; i++){\n    cin >> vec[i].p >> vec[i].q >> vec[i].r >> vec[i].b;\n    ll gcd = __gcd(vec[i].p,vec[i].q);\n    vec[i].p /= gcd;\n    vec[i].q /= gcd;\n\n    vec[vec[i].r].par = i;\n    vec[vec[i].b].par = i;\n  }\n}\n\nvoid dfs(int now,P p){\n\n  if(now == LEAF){\n    pv.push_back(p);\n    return;\n  }\n\n\n  P np = P(p.first * vec[now].p,p.second * (vec[now].p + vec[now].q));\n  ll gcd = __gcd(np.first,np.second);\n  np.first /= gcd;\n  np.second /= gcd;\n  dfs(vec[now].b,np);\n\n  np = P(p.first * vec[now].q,p.second * (vec[now].p + vec[now].q));\n  gcd = __gcd(np.first,np.second);\n  np.first /= gcd;\n  np.second /= gcd;\n  dfs(vec[now].r,np);\n}\n\nll LCM(ll a,ll b){\n  return a/__gcd(a,b)*b;\n}\n\nvoid solve(){\n  init();\n  input();\n  int root;\n  for(int i = 1 ; i <= N ; i++){\n    if(vec[i].par == -1)root = i;\n  }\n\n  dfs(root,P(1,1));\n\n  vector<ll>av;\n\n  for(int i = 0 ; i < pv.size() ; i++){\n    av.push_back(LCM(pv[i].first,pv[i].second)/pv[i].first);\n  }\n\n  ll res = 1;\n  sort(av.begin(),av.end());\n  for(int i = 0 ; i < av.size(); i++){\n    res = LCM(res,av[i]);\n  }\n  cout << res << endl;\n}\n\nint main(){\n  while(cin >> N,N)solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\nusing namespace std;\n\nint N;\n\ntypedef long long int ll;\ntypedef pair<ll,ll>P;\n\nconst int LEAF = 0;\nvector<P>pv;\n\nclass T{\npublic:\n  int p,q,r,b;\n  int par;\n  T(){par = -1;}\n};\n\nvector<T>vec;\n\nvoid init(){\n  vec.clear();\n  pv.clear();\n}\n\nvoid input(){\n\n  for(int i = 0 ; i <= N ; i++){\n    T t;\n    vec.push_back(t);\n  }\n\n  for(int i = 1 ; i <= N ; i++){\n    cin >> vec[i].p >> vec[i].q >> vec[i].r >> vec[i].b;\n    vec[vec[i].r].par = i;\n    vec[vec[i].b].par = i;\n  }\n}\n\nvoid dfs(int now,P p){\n\n  if(now == LEAF){\n    pv.push_back(p);\n    return;\n  }\n  \n  dfs(vec[now].r,P(p.first * vec[now].p,p.second * (vec[now].p + vec[now].q)));\n  dfs(vec[now].b,P(p.first * vec[now].q,p.second * (vec[now].p + vec[now].q)));\n}\n\nll LCM(ll a,ll b){\n  return a*b/__gcd(a,b);\n}\n\nvoid solve(){\n  init();\n  input();\n  int root;\n  for(int i = 1 ; i <= N ; i++){\n    if(vec[i].par == -1)root = i;\n  }\n\n  dfs(root,P(1,1));\n\n  vector<ll>av;\n\n  for(int i = 0 ; i < pv.size() ; i++){\n    av.push_back(LCM(pv[i].first,pv[i].second)/pv[i].first);\n  }\n\n  ll res = 1;\n  for(int i = 0 ; i < av.size(); i++){\n    res = LCM(res,av[i]);\n  }\n  cout << res << endl;\n}\n\nint main(){\n  while(cin >> N,N)solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma warning(disable: 4996)\n#include<cstdio>\n#include<math.h>\n#include<algorithm>\n#include<string.h>\n#include<vector>\n#include<queue>\n#include<vector>\n\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\nconst int INF=1001001001;\n\nconst int mod=100000;\n\n#define MAX_N 110\nint N;\npair<int,int> pq[MAX_N];\nint rod[MAX_N][2];\nvector<int> edge[MAX_N];\nint redge[MAX_N][2];\npriority_queue<pair<int,int> > dist;//second ??????top??????????????¢???first\nbool iftop[MAX_N];//top??????false\n\nint gcd(int a, int b){\n\tif(b==0) return a;\n\treturn gcd(b,a%b);\n}\n\nint main(){\nR:\n\t\tscanf(\"%d\",&N);\n\t\tif(N==0)return 0;\n\t\tmemset(redge,-1,sizeof(redge));\n\t\tmemset(iftop,false,sizeof(iftop));\n\t\trep(i,N){\n\t\t\t\n\t\t\tint p,q,r,b;\n\t\t\tscanf(\"%d %d %d %d\",&p,&q,&r,&b);\n\t\t\tpq[i]= make_pair(p,q);\n\t\t\tif(r>0){iftop[r-1]=true;edge[i].push_back(r-1);redge[r-1][0]=i;}\n\t\t\tif(b>0){iftop[b-1]=true;edge[i].push_back(b-1);redge[b-1][1]=i;}\n\n\t\t}\n\t\tint top=find(iftop,iftop+N,false)-iftop;\n\t\tqueue<int> q1;q1.push(top);\n\t\tint dister=0;\n\t\twhile(q1.size()){\n\t\t\tqueue<int> q2;\n\t\t\twhile(q1.size()){\n\t\t\t\tint a=q1.front();q1.pop();\n\t\t\t\tdist.push(make_pair(dister,a) );\n\t\t\t\trep(i,edge[a].size() ){\n\t\t\t\t\tq2.push(edge[a][i]);\n\t\t\t\t\tif(i>0)break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tq1=q2;dister++;\n\t\t}\n\n\t\tint ans=0;\n\t\twhile(dist.size()){\n\t\t\tpair<int,int> a=dist.top();dist.pop();\n\t\t\tint n=a.second;\n\t\t\tint gc=gcd(pq[n].first,pq[n].second);\n\t\t\tint p=pq[n].first/gc;int q= pq[n].second/gc;\n\t\t\tint sans=0;\n\t\t\tif(rod[n][0]==0&&rod[n][1]==0){\n\t\t\t\tsans=p+q;\n\t\t\t}else{\n\t\t\t\tif(rod[n][0]==0)rod[n][0]=1;if(rod[n][1]==0)rod[n][1]=1;\n\t\t\t\tint power=(rod[n][0]*p)*(rod[n][1]*q)/gcd( (rod[n][0]*p),(rod[n][1]*q) );\n\t\t\t\tsans=power/p+power/q;\n\t\t\t}\n\t\t\trep(i,2)if(redge[n][i]>-1){\n\t\t\t\t\trod[redge[n][i]][i]+=sans;\n\t\t\t\t}\n\t\t\tif(!dist.size()){\n\t\t\t\tans=sans;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t\trep(i,100){\n\t\t\tedge[i].clear();\n\t\t\tpq[i]=make_pair(0,0);\n\t\t}\n\t\tgoto R;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<map>\n#include<cassert>\n#define F first\n#define S second\n#define PPins(a,b,c,d) PP(P(a,b),P(c,d))\n#define PPPins(a,b,c,d,e) PPP(a,PP(P(b,c),P(d,e)))\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\ntypedef pair<int,PP> PPP;\n\nmap<int,PP> tree;\nint top;\n\nint lcm(int a,int b)\n{\n  return a/__gcd(a,b)*b;\n}\n\nint rec(int n)\n{\n \n  int gcd = __gcd(tree[n].F.F,tree[n].F.S);\n  if(!tree[n].S.F && !tree[n].S.S)\n       return tree[n].F.F/gcd + tree[n].F.S/gcd;\n\n  if(tree[n].S.F && tree[n].S.S)\n    {\n      int Left = rec(tree[n].S.F);\n      int Right = rec(tree[n].S.S);\n   \n      return 2*lcm(tree[n].F.F/gcd*Left,tree[n].F.S/gcd*Right);\n\n    }\n\n  if(!tree[n].S.F && tree[n].S.S)\n    {      \n      int Right = rec(tree[n].S.S);\n      int x = lcm((Right*(tree[n].F.S/gcd)),tree[n].F.F/gcd)/tree[n].F.F;\n      //cout << \"In \" << n << \" x = \" << x << \" return = \" << (x*(tree[n].F.F/gcd))/(tree[n].F.S/gcd) + x << endl;\n      return (x*(tree[n].F.F/gcd))/(tree[n].F.S/gcd) + x;\n    }\n\n  if(tree[n].S.F && !tree[n].S.S)\n    {\n      int Left = rec(tree[n].S.F);\n      int x = lcm((Left*(tree[n].F.F/gcd)),tree[n].F.S/gcd)/tree[n].F.S;\n      //cout << \"In \" << n << \" x = \" << x << \" return = \" << (x*(tree[n].F.S/gcd))/(tree[n].F.F/gcd) + x << endl;\n      return (x*(tree[n].F.S/gcd))/(tree[n].F.F/gcd) + x;\n    }\n\n  assert(false);\n  return 0;\n}\n\nint main()\n{\n  int n;\n  while(scanf(\"%d\",&n),n)\n    {\n    \n     \n      if(!n)\n\tbreak;\n      tree.clear();      \n      bool *who = new bool[n+1];\n      for(int i=0;i<n+1;i++)\n\twho[i] = false;\n      who[0] = true;\n      for(int i=0;i<n;i++)\n\t{\n\t  int p,q,r,b;\n\t  scanf(\"%d %d %d %d\",&p,&q,&r,&b);\n\t  tree[i+1] = PPins(p,q,r,b);\n\t  who[r] = who[b] = true;\n\t}\n\n      top = -1;\n      for(int i=1;i<n+1;i++)\n\tif(!who[i])\n\t  {\n\t    top = i;\n\t    break;\n\t  }\n      delete [] who;\n      assert(top != -1);\n      \n      printf(\"%d\\n\",rec(top));    \n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n\ntemplate <class T>\nint __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\nll gcd(ll a, ll b)\n{\n\tif (a < b)\n\t\tswap(a, b);\n\tif (b == 0)\n\t\treturn a;\n\treturn gcd(b, a%b);\n}\nll lcm(ll a, ll b)\n{\n\treturn a*b/gcd(a, b);\n}\nint p[128], q[128], r[128], b[128];\nint w[128];\nint dfs(int s)\n{\n\tif (s == 0)\n\t\treturn 1;\n\telse if (w[s] != -1)\n\t\treturn w[s];\n\n\tll red = dfs(r[s]), blue = dfs(b[s]);\n\tll t = lcm(red*q[s], blue*p[s]);\n\treturn w[s] = (int)(t/p[s] + t/q[s]);\n}\nint main()\n{\n\tint n;\n\twhile (~scanf(\"%d\", &n) && n)\n\t{\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t{\n\t\t\tscanf(\"%d%d%d%d\", p+i, q+i, r+i, b+i);\n\t\t\tll g = gcd(p[i], q[i]);\n\t\t\tp[i] /= g, q[i] /= g;\n\t\t}\n\t\tmemset(w, -1, sizeof(w));\n\t\tint res = 0;\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t\tres = max(res, dfs(i));\n\t\tprintf(\"%d\\n\", res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\nusing namespace std;\nint gcd(int a, int b) {\n\tif (b == 0) {\n\t\treturn a;\n\t}\n\tint r = a % b;\n\treturn gcd(b, r);\n\nint we(int wl, int wr, int lel, int ler) {\n\tint ml = wl * lel;\n\tint mr = wr * ler;\n\tint bil = mr / gcd(ml, mr);\n\tint bir = ml / gcd(ml, mr);\n\treturn (wl * bil)+(wr*bir);\n}\nint main(){\n\tint n;\n\tcin >> n;\n\twhile(n!=0){\n\tvector<int> w(n);\n\tvector<int> lel(n);\n\tvector<int> ler(n);\n\tvector<int> nul(n);\n\tvector<int> nur(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tint l, r;\n\t\tcin >> lel[i] >> ler[i] >> l >> r;\n\t\tl--; r--;\n\t\tnul[i] = l; nur[i] = r;\n\t}\n\tvector<int> d(n,n);\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tint x, y;\n\t\t\tif (nul[j] == -1) {\n\t\t\t\tx = -1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx = d[nul[j]];\n\t\t\t}\n\t\t\tif (nur[j] == -1) {\n\t\t\t\ty = -1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ty = d[nur[j]];\n\t\t\t}\n\t\t\td[j]=min(d[j], max(x, y)+1);\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (d[j] == i) {\n\t\t\t\tint wl, wr;\n\t\t\t\tint l = nul[j];\n\t\t\t\tint r = nur[j];\n\t\t\t\tif (l == -1) {\n\t\t\t\t\twl = 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\twl = w[l];\n\t\t\t\t}\n\t\t\t\tif (r == -1) {\n\t\t\t\t\twr = 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\twr = w[r];\n\t\t\t\t}\n\t\t\t\tw[j] = we(wl, wr, lel[j], ler[j]);\n\t\t\t\tans = max(ans, w[j]);\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\tcin >> n;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <valarray>\n#include <vector>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(auto it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define mt make_tuple\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)(x).size())\n\nusing namespace std;\n\nstruct timer{\n\ttime_t start;\n\ttimer(){start=clock();}\n\t~timer(){cerr<<1.*(clock()-start)/CLOCKS_PER_SEC<<\" secs\"<<endl;}\n};\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<ll,ll> pi;\ntypedef stringstream sst;\ntypedef vector<ll> vi;\n\nint n,p[111],q[111],r[111],b[111];\n\nint gcd(int a,int b){\n\treturn b?gcd(b,a%b):a;\n}\n\nint f(int cur){\n\tif(cur==-1)return 1;\n\tint left=f(r[cur]),right=f(b[cur]);\n\tint g=gcd(left*p[cur],right*q[cur]);\n\treturn right*q[cur]/g*left+left*p[cur]/g*right;\n}\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\t\n\tcin>>n;\n\tint appear[111]={};\n\trep(i,n){\n\t\tcin>>p[i]>>q[i]>>r[i]>>b[i];\n\t\tint g=gcd(p[i],q[i]);\n\t\tp[i]/=g,q[i]/=g;\n\t\tr[i]--,b[i]--;\n\t\tif(r[i]!=-1)appear[r[i]]=1;\n\t\tif(b[i]!=-1)appear[b[i]]=1;\n\t}\n\tint par;\n\trep(i,n)if(!appear[i])par=i;\n\tcout<<f(par)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> plli;\ntypedef pair<int,pii> pipii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n);i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a);i>b;i--)\n#define pb push_back\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n\nconst ll mod = 1e9 + 7;\nconst ll INF = 1<<30;\nconst int dx4[4] = {1, 0, -1, 0};\nconst int dy4[4] = {0, 1, 0, -1};\nconst int dx8[8] = {1, 1, 1, 0, 0, -1, -1, -1};\nconst int dy8[8] = {0, 1, -1, 1, -1, 0, 1, -1};\nconst double pi = 3.141592653589793;\n\nint n;\nstruct stick {int pr, qb, ri, bi;};\n\nlong long  gcd(long long a, long long b) {\n    if (b == 0) return a;\n    return gcd(b, a % b);\n}\n\nlong long lcm(long long a, long long b) {\n    long long g = gcd(a, b);\n    return a / g * b;\n}\n\nint dfs(int now, vector<vector<stick>>& st) {\n    int p = st[now][0].pr;\n    int q = st[now][0].qb;\n    int r = st[now][0].ri;\n    int b = st[now][0].bi;\n    int wr = 1;\n    int wb = 1;\n    if (r == 0 && b == 0) return p + q;\n    if (r != 0) wr = dfs(r, st);\n    if (b != 0) wb = dfs(b, st);\n    int l = lcm(wr * q, wb * p);\n    return l / p + l / q;\n}\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> n;\n    while (n != 0) {\n        vector<vector<stick>> st(105);\n        int cnt[105] = {};\n        rep(i, n) {\n            int p, q, r, b;\n            cin >> p >> q >> r >> b;\n            int g = gcd(p, q);\n            p /= g;\n            q /= g;\n            st[i + 1].pb(stick{p, q, r, b});\n            cnt[r] += 1;\n            cnt[b] += 1;\n        }\n        int s = 0;\n        //rep(i, 10) cout << cnt[i] << endl;\n        rep(i, n + 1) if (cnt[i] == 0) {s = i; break;}\n        int ans = dfs(s, st);\n        cout << ans << endl;\n        cin >> n;\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n\nusing namespace std;\n\nint dp[110];\n\nstruct bar{\n\tint blen,rlen;\n\tint blue,red;\n\tbar(){}\n\tbar(int p,int q,int a,int b):rlen(p),blen(q),red(a),blue(b){}\n};\n\nbar bars[110];\n\nint gcd(int a,int b)\n{\n\tif(a<b) return gcd(b,a);\n\tif(b==0) return a;\n\treturn gcd(b,a%b);\n}\n\nint rec(int v)\n{\n\tif(dp[v]!=-1) return dp[v];\n\tint p=bars[v].rlen,q=bars[v].blen;\n\tint r=bars[v].red,b=bars[v].blue;\n\tif(r==-1&&b==-1)\n\t{\n\t\tdp[v]=p+q;\n\t\treturn dp[v];\n\t}\n\tif(r==-1)\n\t{\n\t\tint mb=rec(b);\n\t\tint d=gcd(p,mb);\n\t\tint a=mb/d;\n\t\tdp[v]=(p+q)*a;\n\t\treturn dp[v];\n\t}\n\telse if(b==-1)\n\t{\n\t\tint mr=rec(r);\n\t\tint d=gcd(q,mr);\n\t\tint a=mr/d;\n\t\tdp[v]=(p+q)*a;\n\t\treturn dp[v];\n\t}\n\tint mb=rec(b),mr=rec(r);\n\tint d=gcd(mb,p);\n\tint a=mb/d;\n\tint mb1=p*a,mr1=q*a;\n\tint d1=gcd(mr,mr1);\n\tint A=mr/d1;\n\tdp[v]=A*(mb1+mr1);\n\treturn dp[v];\n}\n\nint main()\n{\n\tint N;\n\twhile(1)\n\t{\n\tscanf(\"%d\",&N);\n\tif(N==0) break;\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tint p,q,a,b;\n\t\tscanf(\"%d%d%d%d\",&p,&q,&a,&b);\n\t\ta--;b--;\n\t\tint d=gcd(p,q);\n\t\tp/=d;q/=d;\n\t\tbars[i]=bar(p,q,a,b);\n\t}\n\tmemset(dp,-1,sizeof(dp));\n\tint ans=0;\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tans=max(ans,rec(i));\n\t}\n\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long int;\n\nint n;\nll s[100], t[100], l[100], r[100];\n\nll gcd(ll p, ll q){\n    if(q==0) return p;\n    else return gcd(q, p%q);\n}\n\nll lcm(ll p, ll q){\n    return p/gcd(p,q)*q;\n}\n\nll rec(int id){\n    if(id == -1) return 1;\n    ll wl = rec(l[id]), wr = rec(r[id]);\n    ll m = lcm(wl*s[id], wr*t[id]);\n    return m/s[id]+m/t[id];\n}\n\nbool solve(){\n    cin >> n;\n    if(n == 0) return false;\n    int cnt[100]{};\n    for(int i=0;i<n;i++){\n        cin >> s[i] >> t[i] >> l[i] >> r[i];\n        l[i]--; r[i]--;\n        if(l[i]>=0) cnt[l[i]]++;\n        if(r[i]>=0) cnt[r[i]]++;\n    }\n    for(int i=0;i<n;i++){\n        if(cnt[i]==0){\n            cout << rec(i) << endl;\n            break;\n        }\n    }\n    return true;\n}\n\nint main(){\n    while(solve());\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cstdio>\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> P;\ntypedef pair<LL, LL> PLL;\n\nint gcd(int x, int y) {\n    if (x < y) { swap(x, y); }\n    if (y == 0) { return x; }\n    return gcd(y, x % y);\n}\n\nstruct mobile {\n    int lb;\n    int rb;\n    int lm;\n    int rm;\n};\n\nint N;\nmobile ms[110];\n\nint get_root() {\n    for (int j = 0; j < N; ++j) {\n        bool found = false;\n        for (int k = 0; k < N; ++k) {\n            if (ms[k].lm == j || ms[k].rm == j) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            return j;\n        }\n    }\n    return -1;\n}\n\nint rec(int x) {\n    mobile& m = ms[x];\n\n    int t = gcd(m.lb, m.rb);\n\n    if (m.lm == -1 && m.rm == -1) {\n        return (m.lb + m.rb) / t;\n    }\n\n    int lw, rw;\n    if (m.lm != -1 && m.rm == -1) {\n        lw = rec(m.lm) * (m.rb / t);\n        rw = (lw * m.lb) / m.rb;\n    } else if (m.lm == -1 && m.rm != -1) {\n        rw = rec(m.rm) * (m.lb / t);\n        lw = (rw * m.rb) / m.lb;\n    } else {\n        lw = rec(m.lm) * (m.rb / t);\n        rw = rec(m.rm) * (m.lb / t);\n        int u = gcd(lw * m.lb, rw * m.rb);\n        int tmp = lw;\n        lw *= (rw * m.rb) / u;\n        rw *= (tmp * m.lb) / u;\n    }\n\n    assert(lw * m.lb == rw * m.rb);\n    return lw + rw;\n}\n\nbool solve() {\n\n    cin >> N;\n    if (N == 0) {\n        return false;\n    }\n    for (int j = 0; j < N; ++j) {\n        cin >> ms[j].lb >> ms[j].rb >> ms[j].lm >> ms[j].rm;\n        --ms[j].lm; --ms[j].rm;\n    }\n\n    int root = get_root();\n\n    cout << rec(root) << endl;\n\n    return true;\n}\n\nint main() {\n    while(solve());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef long long lli;\n\nconst lli N = 100LL;\n\nlli n, p[N+1], q[N+1], r[N+1], b[N+1];\nbool vis[N+1];\n\nlli lcm(lli x, lli y){\n  return x * y / __gcd(x, y);\n}\n\nlli solve(lli pos){\n  lli t1, t2;\n  if(r[pos]) t1 = solve(r[pos]);\n  if(b[pos]) t2 = solve(b[pos]);\n  lli tmp1 = p[pos];\n  lli tmp2 = q[pos];\n  if(r[pos] && b[pos]){\n    tmp1 = lcm(t1, (lli)p[pos]);\n    tmp2 = lcm(t2, (lli)q[pos]);\n    tmp1 = lcm(tmp1, tmp2);\n    tmp2 = tmp1;\n  }else if(r[pos]){\n    tmp1 = lcm(t1, (lli)p[pos]);\n    tmp2 = (lli)q[pos] * (tmp1 / t1);\n  }else if(b[pos]){\n    tmp2 = lcm(t2, (lli)q[pos]);\n    tmp1 = (lli)p[pos] * (tmp2 / t2);\n  }\n  //cout << pos << ' ' << tmp1 << ' ' << tmp2 << endl;\n  return tmp1 + tmp2;\n}\n\nmain(){\n  while(cin >> n && n){\n    fill(vis, vis+N+1, false);\n    for(lli i=1;i<=n;i++){\n      cin >> p[i] >> q[i] >> r[i] >> b[i];\n      lli tmp = __gcd(p[i], q[i]);\n      p[i] /= tmp;\n      q[i] /= tmp;\n      vis[r[i]] = vis[b[i]] = true;\n    }\n    for(lli i=1;i<=n;i++) if(!vis[i]) cout << solve(i) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nint gcd(int a,int b){\n    if(b==0)return a;\n    return gcd(b,a%b);\n    }  \n    int lcm(int a,int b){return a*b/gcd(a,b);}\nstruct bou{\n    int l,r,x,y;\n    };\n    int n[105];bou m[105];\nint mincost(int a){\n    if(n[a-1]!=-1)return n[a-1];\n    int b=1,c=1;\n    if(m[a].x)b=mincost(mincost(m[a].x)/gcd(mincost(m[a].x),m[a].r));\n    if(m[a].y)c=mincost(mincost(m[a].y)/gcd(mincost(m[a].y),m[a].l));\n    n[a-1]=lcm(b,c)*(m[a].l+m[a].r);\n    return lcm(b,c)*(m[a].l+m[a].r);\n    }\nsigned main(){\n   int a;\n   while(cin>>a,a){\n       memset(n,-1,sizeof(n));\n       bou g;\n       for(int b=1;b<=a;b++){\n\t   int c,d;\n\t  scanf(\"%lld%lld%lld%lld\",&c,&d,&g.x,&g.y);\n\t  g.l=c/gcd(c,d);g.r=d/gcd(c,d);\n\t  m[b]=g;\n\t   }\n\t for(int i=0;i<a;i++){\n\t     if(n[i]==-1)mincost(i+1);\n\t     }  \n\t     int MAX=0;\n\tfor(int i=0;i<a;i++){\n\t     MAX=max(MAX,n[i]);\n\t    }  \n\t    cout<<MAX<<endl;\n       }\n    }"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\nusing namespace std;\ntypedef long long int ll;\nstruct edge{\n\tll to;\n\tll cost;\n};\nint N;\nint ccc;\nll num;\nll X[100][4];\nvector<edge> G[500];\nll mincost[500];\nll gcd(ll a,ll b){\n\tif(b==0)return a;\n\treturn gcd(b,a%b);\n}\nll solve(int s){\n\tll a,b;\n\tif(G[s][0].to>=N)a=-1;\n\telse a=solve(G[s][0].to);\n\tif(G[s][1].to>=N)b=-1;\n\telse b=solve(G[s][1].to);\n\tif(a==-1&&b==-1)return mincost[s]=G[s][0].cost+G[s][1].cost;\n\tif(a==-1){\n\t\tll kkk=b*G[s][0].cost/gcd(b,G[s][0].cost);\n\t\tll lll=kkk*G[s][1].cost/G[s][0].cost;\n\t\treturn mincost[s]=kkk+lll;\n\t}\n\tif(b==-1){\n\t\tll kkk=a*G[s][1].cost/gcd(a,G[s][1].cost);\n\t\tll lll=kkk*G[s][0].cost/G[s][1].cost;\n\t\treturn mincost[s]= kkk+lll;\n\t}\n\tll kkk=a*G[s][0].cost;ll lll=b*G[s][1].cost;\n\tll mmm=kkk*lll/gcd(kkk,lll);\n\treturn mincost[s]=mmm/G[s][0].cost+mmm/G[s][1].cost;\n}\nint main()\n{\nwhile(true){\n\tscanf(\"%d\",&N);\n\tif(N==0)break;\n\tnum=N;\n\tccc=N*(N+1)/2;\n\tfor(int i=0;i<N;i++){\n\t\tG[i].clear();\n\t\tfor(int j=0;j<4;j++)scanf(\"%lld\",&X[i][j]);\n\t\tll GCD=gcd(X[i][0],X[i][1]);\n\t\tX[i][0]/=GCD;X[i][1]/=GCD;\n\t\tif(X[i][2]==0)X[i][2]=num++;\n\t\telse {ccc-=X[i][2];X[i][2]--;}\n\t\tif(X[i][3]==0)X[i][3]=num++;\n\t\telse {ccc-=X[i][3];X[i][3]--;}\n\t\tedge e;\n\t\te.to=X[i][2];e.cost=X[i][0];\n\t\tG[i].push_back(e);\n\t\te.to=X[i][3];e.cost=X[i][1];\n\t\tG[i].push_back(e);\n\t}\n\tccc--;\n\tprintf(\"%lld\\n\",solve(ccc));\n\t//for(int i=0;i<N;i++)printf(\"%d:%lld\\n\",i,mincost[i]);\n}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(ll i=(b) - 1;i>=(a);i--)\n#define REP(i,n) for(ll i=0;i<(n);i++)\n#define RREP(i,n) for(ll i=n-1;i>=0;i--)\n\n#define PB push_back\n#define INF (1<<29)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define CLR(a) memset(a,0,sizeof(a))\n\ntypedef long long int ll;\n\nusing namespace std;\nstruct mobile{\n    ll rc;\n    ll lc;\n    ll l;\n    ll r;\n    ll w; \n};\n\nll gcd(ll a, ll b){\n    return a%b==0 ? b : gcd(b,a%b);\n}\n\nint main(){\n    while(true){\n\tll n;\n\tcin >> n;\n\tif(n == 0) break;\n\tll ans =0 ;\n\tvector< struct mobile > v(n);\n\tREP(i,n){\n\t    ll l,r,lc,rc;\n\t    cin >> l >> r >> lc >> rc;\n\t    v[i].l = l;\n\t    v[i].r = r;\n\t    v[i].lc = lc;\n\t    v[i].rc = rc;\n\t    v[i].w = 0;\n\t}\n\tbool flg = true;\n\twhile(flg){\n\t    flg = false;\n\t    REP(i,n){\n\t\tif(v[i].w == 0 && v[i].rc == 0 && v[i].lc == 0){\n\t\t    ll r = v[i].r;\n\t\t    ll l = v[i].l;\n\t\t    v[i].r /= gcd(r,l);\n\t\t    v[i].l /= gcd(r,l);\n\t\t    v[i].w = v[i].r + v[i].l;\n\t\t    flg = true;\n\t\t}else{\n\t\t    ll lw,rw;\n\t\t    if(v[i].w > 0) continue;\n\t\t    if(v[i].lc == 0){\n\t\t\tlw = 1;\n\t\t    }else if(v[v[i].lc-1].w > 0){\n\t\t\tlw = v[v[i].lc-1].w;\n\t\t    }else continue;\n\n\t\t    if(v[i].rc == 0){\n\t\t\trw = 1;\n\t\t    }else if(v[v[i].rc-1].w > 0){\n\t\t\trw = v[v[i].rc-1].w;\n\t\t    }else continue;\n\t\t    ll r,l;\n\t\t    r = v[i].r;\n\t\t    l = v[i].l;\n\t\t    v[i].r /= gcd(r,l);\n\t\t    v[i].l /= gcd(r,l);\n\t\t    ll w = 1000000000000000;\n\t\t    \n\t\t    FOR(j,1,1000000){\n\t\t\tif((lw*v[i].l*j) % v[i].r == 0){\n\t\t\t    if(((lw*v[i].l*j)/v[i].r ) % rw == 0){\n\t\t\t\tw =  lw*j + (lw*v[i].l*j)/v[i].r;\n\t\t\t\t/*\n\t\t\t\tprintf(\"l = %d r = %d\\n\",v[i].l,v[i].r);\n\t\t\t\tprintf(\"lw = %d rw = %d\\n\",lw*j,(lw*v[i].l*j)/v[i].r);\n\t\t\t\tprintf(\"w = %d j = %d\\n\",w,j);\n\t\t\t\t*/\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\t\t\tif(w < (1<<31)) break;\n\t\t    }\n\t\t    v[i].w = w;\n\t\t    flg = true;\n\t\t}\n\t\tans = max(ans,v[i].w);\n\t    }\n\t}\n\tcout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<math.h>\n#include<queue>\n#include<set>\n#include<map>\n#include<random>\n#include<functional>\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define pb push_back\n#define pint pair<int, int>\n#define mp make_pair\n\nusing namespace std;\n\ntypedef long long ll;\n\n\n\n\nll gcb(ll a, ll b) {\n\tif (b == 0) return a;\n\treturn gcb(b, a%b);\n}\n\nvoid cop(ll &a, ll &b) {\n\tll g = gcb(a, b);\n\ta /= g;\n\tb /= g;\n}\n\nll lcm(ll a, ll b){\n\treturn a * b / gcb(a, b);\n}\n\nll dfs(int now, vector<vector<ll>> &to, vector<vector<ll>> &co) {\n\tif (now == -1) return 1;\n\n\tll tmp1 = co[now][0] * dfs(to[now][0], to, co);\n\tll tmp2 = co[now][1] * dfs(to[now][1], to, co);\n\n\tll l = lcm(tmp1, tmp2);\n\n\ttmp1 = l / co[now][0];\n\ttmp2 = l / co[now][1];\n\n\treturn tmp1 + tmp2;\n}\n\n\nint main() {\n\tint n;\n\n\twhile (cin >> n, n)\n\t{\n\t\tvector<vector<ll>> to(n), co(n);\n\t\tint root;\n\t\tvector<bool> isroot(n, true);\n\n\t\trep(i, n) {\n\t\t\tll p, q;\n\t\t\tint r, b;\n\t\t\tcin >> p >> q >> r >> b;\n\n\t\t\tcop(p, q);\n\t\t\tr--; b--;\n\n\t\t\tto[i].push_back(r);\n\t\t\tto[i].push_back(b);\n\n\t\t\tco[i].push_back(p);\n\t\t\tco[i].push_back(q);\n\n\t\t\tif(r >= 0 ) isroot[r] = false;\n\t\t\tif (b >= 0) isroot[b] = false;\n\t\t}\n\n\t\trep(i, n) {\n\t\t\tif (isroot[i]) {\n\t\t\t\troot = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tcout << dfs(root, to, co) << endl;\n\n\t}\n\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nlong long int gcd( long long int m, long long int n ) {\n  if ( m == 0 || n == 0 ) return 0;\n  while( m != n ) {\n    if ( m > n ) {\n      m -= n;\n    }else {\n      n -= m;\n    }\n  }\n  return m;\n}\nlong long int lcm( long long int m, long long int n ) {\n  if ( m == 0 || n == 0 ) return 0;\n  return ( ( m / gcd( m, n ) ) * n );\n}\n\nint main() {\n\n  while( true ) {\n\n    long long int n;\n    cin >> n;\n    if ( n == 0 ) break;\n\n    vector< long long int > p, q, r, b;\n    for ( long long int i = 0; i < n; i++ ) {\n      long long int in_p, in_q, in_r, in_b;\n      cin >> in_p >> in_q >> in_r >> in_b;\n      p.push_back( in_p );\n      q.push_back( in_q );\n      r.push_back( in_r );\n      b.push_back( in_b );\n    }\n\n    for ( long long int i = 0; i < n; i++ ) {\n      for ( long long int j = 0; j < n; j++ ) {\n\n\tif ( r[j] <= 0 && b[j] <= 0 ) {\n\n\t  if ( r[j] == 0 ) {\n\t    r[j] = 1;\n\t  }else {\n\t    r[j] = -r[j];\n\t  }\n\t  long long int r2 = r[j] * q[j];\n\t  if ( b[j] == 0 ) {\n\t    b[j] = 1;\n\t  }else {\n\t    b[j] = -b[j];\n\t  }\n\t  long long int b2 = b[j] * p[j];\n\t  long long int h = lcm( r2, b2 ) / p[j] + lcm( r2, b2 ) / q[j];\n\n\t  r[j] = n + 2;\n\t  b[j] = n + 2;\n\n\t  for ( long long int k = 0; k < n; k++ ) {\n\t    if ( r[k] == j + 1 ) {\n\t      r[k] = -h;\n\t      break;\n\t    }\n\t    if ( b[k] == j + 1 ) {\n\t      b[k] = -h;\n\t      break;\n\t    }\n\t    if ( k == n - 1 ) {\n\t      cout << h << endl;\n\t      break;\n\t    }\n\t  }\n\n\t}\n\n      }\n    }\n\n  }\n\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nint gcd(int a,int b){\n    if(b==0)return a;\n    return gcd(b,a%b);\n    }  \n    int lcm(int a,int b){return a*b/gcd(a,b);}\nstruct bou{\n    int l,r,x,y;\n    };\n    int n[100];bou m[101];\nint mincost(int a){\n    if(n[a-1]!=-1)return n[a-1];\n    int b=1,c=1;\n    if(m[a].x)b=mincost(m[a].x);\n    if(m[a].y)c=mincost(m[a].y);\n    n[a-1]=lcm(b,c)*(m[a].l+m[a].r);\n    return lcm(b,c)*(m[a].l+m[a].r);\n    }\nint main(){\n   int a;\n   while(cin>>a,a){\n       memset(n,-1,sizeof(n));\n       bou g;\n       for(int b=1;b<=a;b++){\n\t   int c,d;\n\t  scanf(\"%d%d%d%d\",&c,&d,&g.x,&g.y);\n\t  g.l=c/gcd(c,d);g.r=d/gcd(c,d);\n\t  m[b]=g;\n\t   }\n\t for(int i=0;i<a;i++){\n\t     if(n[i]==-1)mincost(i+1);\n\t     }  \n\t     int MAX=0;\n\tfor(int i=0;i<a;i++){\n\t     MAX=max(MAX,n[i]);\n\t    }  \n\t    cout<<MAX<<endl;\n       }\n    }"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef pair<int,int> P;\n#define pb push_back\n#define INF 1e9\nint n;\nint main(){\n\twhile(1){\n\tint lcm[105];\n\tvector<int> son[105];\n\tP stick[105];\n\tbool decide[105]={};\n\tbool beleft[105]={},beright[105]={};\n\tscanf(\"%d\",&n);\n\tif(!n) break;\n\tfor(int q=1;q<=n;q++){\n\t\tint a,b,c,d;\n\t\tscanf(\"%d %d %d %d\",&a,&b,&c,&d);\n\t\tif(c){\n\t\t\tson[q].pb(c);\n\t\t\tbeleft[q]=true;\n\t\t}\n\t\tif(d){\n\t\t\tson[q].pb(d);\n\t\t\tberight[q]=true;\n\t\t}\n\t\tint rp;\n\t\tfor(int i=min(a,b);i>=1;i--){\n\t\t\tif(a%i==0 && b%i==0){\n\t\t\t\trp=((a/i)+(b/i));\n\t\t\t\tstick[q]=make_pair(a,b);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tlcm[q]=rp;\n\t\tif(son[q].size()==0){\n\t\t\tdecide[q]=true;\n\t\t}\n\t}\n\tint last;\n\twhile(1){\n\t\tbool p=false;\n\tfor(int i=1;i<=n;i++){\n\t\tif(son[i].size()!=0 && !decide[i]){\n\t\t\tint cou=0;\n\t\t\tfor(int j=0;j<son[i].size();j++){\n\t\t\t\tif(decide[son[i][j]]){\n\t\t\t\t\tcou++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(cou==son[i].size()){\n\t\t\t\t\tint maxi=0;\n\t\t\t\t\tif(beleft[i]){\n\t\t\t\t\t\tfor(int g=min(stick[i].second,lcm[son[i][0]]);g>=1;g--){\n\t\t\t\t\t\t\tif(stick[i].second%g==0 && lcm[son[i][0]]%g==0){\n\t\t\t\t\t\t\t\tmaxi=(lcm[son[i][0]]/g*(stick[i].first+stick[i].second));\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(beright[i]){\n\t\t\t\t\t\tfor(int g=min(stick[i].first,lcm[son[i][son[i].size()-1]]);g>=1;g--){\n\t\t\t\t\t\t\tif(stick[i].first%g==0 && lcm[son[i][son[i].size()-1]]%g==0){\n\t\t\t\t\t\t\t\tmaxi=max(maxi,(lcm[son[i][son[i].size()-1]]/g*(stick[i].first+stick[i].second)));\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlcm[i]=maxi;\n\t\t\t\t\tdecide[i]=true;\n\t\t\t\t\tlast=i;\n\t\t\t\t\tp=true;\n\t\t\t}\n\t\t}\n\t}\n\tif(!p){\n\t\tbreak;\n\t}\n\t}\n\tprintf(\"%d\\n\",lcm[last]);\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i = (a); i < (b); i++)\n#define REP(i,n) FOR(i,0,n)\n\nstruct Node {\n\tint a, b, ma, mb;\n\t\n\tNode() {}\n\tNode(int a, int b, int ma, int mb) : a(a), b(b), ma(ma), mb(mb) {}\n};\n\nint n;\nNode node[100];\nbool istop[100];\n\nint gcd(int a, int b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a % b);\n}\n\nint lcm(int a, int b) {\n\treturn a / gcd(a, b) * b;\n}\n\nint dfs(int pos) {\n\tNode &now = node[pos];\n\t\n\tint a = now.a, b = now.b, ma = now.ma, mb = now.mb;\n\t\n\tif (ma != 0) ma = dfs(ma - 1);\n\tif (mb != 0) mb = dfs(mb - 1);\n\t\n\tif (ma == 0 && mb == 0) {\n\t\treturn a + b;\n\t\n\t} else if (ma == 0 || mb == 0) {\n\t\tif (ma == 0) swap(ma, mb);\n\t\tint l = lcm(a, b);\n\t\treturn l * ma / a + l * ma / b;\n\t}\n\telse {\n\t\tint x = gcd(a * ma, b * mb);\n\t\tint res1 = mb * (a * ma / x);\n\t\tint res2 = ma * (b * mb / x);\n\t\treturn res1 + res2;\n\t}\n}\n\nint main() {\n\twhile (cin >> n, n) {\n\t\tfill(istop, istop + n, false);\n\t\t\n\t\tREP(i, n) {\n\t\t\tint a, b, ma, mb;\n\t\t\tscanf(\"%d %d %d %d\", &a, &b, &ma, &mb);\n\t\t\tint g = gcd(a, b);\n\t\t\ta /= g; b /= g;\n\t\t\tnode[i] = Node(a, b, ma, mb);\n\t\t\t\n\t\t\tif (ma != 0) istop[ma - 1] = true;\n\t\t\tif (mb != 0) istop[mb - 1] = true;\n\t\t}\n\t\t\n\t\tint st = 0;\n\t\twhile (istop[st]) st++;\n\t\tcout << dfs(st) << endl;\n\t}\n\treturn 0;\n}\n\n// 1:45"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nconst int NIL = -1;\n\nstruct Mobile {\n    int weight;\n    int left, right;\n    int left_child, right_child;\n    Mobile(int l, int r, int lc, int rc) :weight(NIL), left(l), right(r), left_child(lc), right_child(rc) {}\n};\n\nint gcd(int a, int b) {\n    return b ? gcd(b, a % b) : a;\n}\n\nint lcm(int a, int b) {\n    return a * b / gcd(a, b);\n}\n\nint weight(vector<Mobile>& mobile, int n) {\n    if(n == NIL) return 1;\n    if(mobile[n].weight != NIL) return mobile[n].weight;\n    int left_weight = weight(mobile, mobile[n].left_child);\n    int right_weight = weight(mobile, mobile[n].right_child);\n    if(left_weight * mobile[n].right != right_weight * mobile[n].left) {\n        int d = lcm(left_weight * mobile[n].left, right_weight * mobile[n].right);\n        left_weight = d / mobile[n].left;\n        right_weight = d / mobile[n].right;\n    }\n    return mobile[n].weight = left_weight + right_weight;\n}\n\nint main() {\n    int n;\n    while(cin >> n, n) {\n        vector<Mobile> mobile;\n        for(int i = 0; i < n; ++i) {\n            int p, q, r, b;\n            cin >> p >> q >> r >> b;\n            int d = gcd(p, q);\n            p /= d;\n            q /= d;\n            --r;\n            --b;\n            mobile.push_back(Mobile(p, q, r, b));\n        }\n        int answer = 0;\n        for(int i = 0; i < n; ++i) answer = max(answer, weight(mobile, i));\n        cout << answer << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <map>\n#include <sstream>\n#include <string>\n#include <cstdio>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cstring>\n#include <tuple>\n#include <utility>\n#include <list>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> Array;\ntypedef pair<int, int> P;\n\nconst int INF = 1 << 29;\nconst LL MOD = 100000;\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define all(c) (c).begin(), (c).end()\n\nstruct edge{ int to, cost; edge(int t, int c) :to(t), cost(c){} };\n\nint dxk[] = { 1, 1, 1, 0, -1, 0 };\nint dxg[] = { 0, 1, 0, -1, -1, -1 };\nint dy[] = { -1, 0, 1, 1, 0, -1 };\n\nstruct node\n{\n\tLL value, lw, rw, left, right;\n};\n\nLL gcd(LL a, LL b)\n{\n\tif (a < b) swap(a, b);\n\treturn a % b == 0 ? b : gcd(b, a % b);\n}\nLL sks(LL a, LL b)\n{\n\tLL g = gcd(a, b);\n\treturn a / g * b;\n}\n\nLL dfs(int idx, vector<node>& bars)\n{\n\tif (idx == -1) return 1LL;\n\tnode& node = bars[idx];\n\tif (node.value != 0) return node.value;\n\n\tLL r = dfs(node.right, bars), l = dfs(node.left, bars);\n\n\t//r*lの最小公倍数を基礎値としてm:nにする\n\tLL s = sks(r * node.rw, l * node.lw);\n\treturn node.value = s / node.rw + s / node.lw;\n}\n\nint main()\n{\n\tint n;\n\twhile (cin >> n && n)\n\t{\n\t\tvector<node> bars(n);\n\t\trep(i, n)\n\t\t{\n\t\t\tint p, q, r, b;\n\t\t\tcin >> p >> q >> r >> b;\n\t\t\tint g = gcd(p, q);\n\t\t\tbars[i].rw = p / g;\n\t\t\tbars[i].lw = q / g;\n\t\t\tbars[i].left = r - 1;\n\t\t\tbars[i].right = b - 1;\n\t\t}\n\n\t\tLL ans = 0;\n\t\trep(i, n) ans = max(dfs(i, bars), ans);\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i = (a); i < (b); i++)\n#define REP(i,n) FOR(i,0,n)\n\nstruct Node {\n\tint a, b, ma, mb;\n\t\n\tNode() {}\n\tNode(int a, int b, int ma, int mb) : a(a), b(b), ma(ma), mb(mb) {}\n};\n\nint n;\nNode node[100];\nbool istop[100];\n\nint gcd(int a, int b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a % b);\n}\n\nint lcm(int a, int b) {\n\treturn a / gcd(a, b) * b;\n}\n\nint dfs(int pos) {\n\tNode &now = node[pos];\n\t\n\tint a = now.a, b = now.b, ma = now.ma, mb = now.mb;\n\t\n\tma = ma ? dfs(ma - 1) : 1;\n\tmb = mb ? dfs(mb - 1) : 1;\n\t\n\tint l = lcm(a * ma, b * mb);\n\treturn l / (a + b);\n}\n\nint main() {\n\twhile (cin >> n, n) {\n\t\tfill(istop, istop + n, false);\n\t\t\n\t\tREP(i, n) {\n\t\t\tint a, b, ma, mb;\n\t\t\tscanf(\"%d %d %d %d\", &a, &b, &ma, &mb);\n\t\t\tnode[i] = Node(a, b, ma, mb);\n\t\t\t\n\t\t\tif (ma != 0) istop[ma - 1] = true;\n\t\t\tif (mb != 0) istop[mb - 1] = true;\n\t\t}\n\t\t\n\t\tint st = 0;\n\t\twhile (istop[st]) st++;\n\t\tcout << dfs(st) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Mobil{\n  int p,q,r,b;\n  Mobil(){}\n  Mobil(int p, int q, int r, int b):p(p),q(q),r(r),b(b){}\n};\n\ntypedef long long ll;\n\nint N;\nint in[128];\nMobil mb[128];\n\nll rec(int v){\n  ll res = 0, r=0,b=0,rw=1,bw=1;\n  Mobil m = mb[v];\n  if(m.r){ rw = rec(m.r); r = m.p*rw; }\n  else r = m.p;\n  if(m.b){ bw = rec(m.b); b = m.q*bw;}\n  else b = m.q;\n  ll lcm = r*b/__gcd(r,b);\n  //  printf(\"%lld\\n\", lcm);\n  //  printf(\"%lld %lld %lld %lld\\n\", rw, r, bw, b);\n  res += rw*lcm/r;\n  res += bw*lcm/b;\n  return res;\n}\n\nint main(){\n  while(scanf(\"%d\", &N) && N){\n    for(int i=1;i<=N;i++){\n      int p,q,r,b; scanf(\"%d%d%d%d\",&p,&q,&r,&b);\n      mb[i] = Mobil(p,q,r,b);\n      in[r] = in[b] = 1;\n    }\n\n    int s = -1;\n    for(int i=1;i<=N;i++) if(!in[i]) s = i;\n    printf(\"%d\\n\", rec(s));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint gcd(int a,int b){\n    if(b==0)return a;\n    return gcd(b,a%b);\n    }  \n    int lcm(int a,int b){return a*b/gcd(a,b);}\nstruct bou{\n    int l,r,x,y;\n    };\n    int n[100];bou m[101];\nint mincost(int a){\n    if(n[a-1]!=-1)return n[a-1];\n    int b=1,c=1;\n    if(m[a].x)b=mincost(m[a].x);\n    if(m[a].y)c=mincost(m[a].y);\n    n[a-1]=lcm(b,c)*(m[a].l+m[a].r);\n    return lcm(b,c)*(m[a].l+m[a].r);\n    }\nint main(){\n   int a;\n   while(cin>>a,a){\n       memset(n,-1,sizeof(n));\n       bou g;\n       for(int b=1;b<=a;b++){\n\t   int c,d;\n\t  scanf(\"%d%d%d%d\",&c,&d,&g.x,&g.y);\n\t  g.l=c/gcd(c,d);g.r=d/gcd(c,d);\n\t  m[b]=g;\n\t   }\n\t for(int i=0;i<a;i++){\n\t     if(n[i]==-1)mincost(i+1);\n\t     }  \n\t     int MAX=0;\n\tfor(int i=0;i<a;i++){\n\t     MAX=max(MAX,n[i]);\n\t    }  \n\t    cout<<MAX<<endl;\n       }\n    }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint n,p[101],q[101],r[101],b[101];\nbool flg[101]; //上からつるされているかのフラグ\n\n//最大公約数\nint gcd(int a,int b){\n  return b == 0 ? a : gcd(b,a%b);\n}\n\n//最小公倍数\nint lcm(int a,int b){\n  return a / gcd(a,b) * b;\n}\n\nint solve(int idx){\n  int res = 0;\n\n  int rcost = r[idx] ? solve(r[idx]) : 1;\n  int bcost = b[idx] ? solve(b[idx]) : 1;\n  int l = lcm(p[idx] * rcost, q[idx] * bcost);\n\n  return l / p[idx] + l / q[idx];\n}\n\nint main(void){\n  while(cin>>n, n){\n    memset(flg,0,sizeof(flg));\n    for(int i=1;i<=n;i++){\n      cin>>p[i]>>q[i]>>r[i]>>b[i];\n      flg[r[i]] = flg[b[i]] = true; //上からつるされている棒をtrueにする\n    }\n\n    for(int i=1;i<=n;i++){\n      //上からつるされていない棒ならば, ルートノード\n      if(!flg[i]){\n        cout<<solve(i)<<endl;\n        break;\n      }\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint n, r[200], s[200], t[200], u[200], dp[200];\nlong long gcd(int a, int b) { if (b == 0)return a; return gcd(b, a%b); }\nlong long dfs(int p) {\n\tif (dp[p] >= 0)return dp[p];\n\tif (p == 0)return 1;\n\tlong long J1 = dfs(t[p]), J2 = dfs(u[p]);\n\tlong long m1 = s[p] * J1, m2 = r[p] * J2;\n\tlong long r1 = m2 / gcd(m1, m2), r2 = m1 / gcd(m1, m2);\n\tlong long minx = J1*r1 + J2*r2;\n\tdp[p] = minx;\n\treturn minx;\n}\nint main() {\n\twhile (cin >> n, n) {\n\t\tfor (int i = 0; i <= n; i++)dp[i] = -1;\n\t\tfor (int i = 1; i <= n; i++) { cin >> r[i] >> s[i] >> t[i] >> u[i]; int H = gcd(r[i], s[i]); r[i] /= H; s[i] /= H; }\n\t\tlong long maxn = 0; for (int i = 1; i <= n; i++)maxn = max(maxn, dfs(i));\n\t\tcout << maxn << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define ALL(a) (a).begin(),(a).end()\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\nconst int INF=1e9;\nll gcd(ll a,ll b){\n  if(b==0)return a;\n  return gcd(b,a%b);\n}\nint main(){\n  int n;\n  while(cin>>n&&n){\n    ll w[110],p[110],q[110],r[110],b[110];\n    memset(w,-1,sizeof(w));\n    for(int i=1;i<=n;i++){\n      cin>>p[i]>>q[i]>>r[i]>>b[i];\n      ll g=gcd(p[i],q[i]);\n      p[i]/=g;q[i]/=g;\n      if(r[i]==0&&b[i]==0){\n        w[i]=p[i]+q[i];\n      }\n    }\n    bool update=true;\n    while(update){\n      update=false;\n      for(int i=1;i<=n;i++){\n        if(w[i]!=-1)continue;\n        if((r[i]==0||w[r[i]]!=-1)&&(b[i]==0||w[b[i]]!=-1)){\n          if(r[i]==0||b[i]==0){\n            if(r[i]==0){\n              ll y=w[b[i]]*q[i],x=p[i];\n              ll g=gcd(x,y);\n              x/=g;y/=g;\n              w[i]=y+w[b[i]]*x;\n            }else{\n              ll y=q[i],x=w[r[i]]*p[i];\n              ll g=gcd(x,y);\n              x/=g;y/=g;\n              w[i]=w[r[i]]*y+x;\n            }\n          }else{\n            ll y=w[b[i]]*q[i],x=w[r[i]]*p[i];\n            ll g=gcd(x,y);\n            x/=g;y/=g;\n            w[i]=w[r[i]]*y+w[b[i]]*x;\n          }\n          update=true;\n        }\n      }\n    }\n    ll ans=0;\n    for(int i=1;i<=n;i++)ans=max(w[i],ans);\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <list>\n#include <stdio.h>\n#include <string.h>\n#include <cstdlib>\n#include <math.h>\n#include <bitset>\n#include <iterator>\n#include <iomanip>\n#include <sstream>\n#include <numeric>\n#include <cassert>\n#define INF 200000000000000\n#define MOD 1000000007\n#define sym cout<<\"---------\"<<endl;\n#define ll long long\n#define mk make_pair\n#define en endl\n#define RE return 0\n#define int ll\n#define P pair<int,int>\nusing namespace std;\nint dx[5]={1,0,-1,0,0},dy[5]={0,1,0,-1,0};\nint gcd(int a,int b){if(a%b==0){return b;}else return gcd(b,a%b);}\nint lcm(int a,int b){if(a==0){return b;} return a/gcd(a,b)*b;}\n\nP mobi[105];\nP pr[105];\nint n;\nint used[105];\n\nint saiki(int m){\n\t// first\n\tint right=0,left=0;\n\tif(mobi[m].first){\n\t\tleft=saiki(mobi[m].first);\n\t}\n\tif(mobi[m].second){\n\t\tright=saiki(mobi[m].second);\n\t}\n\tint ret=0;\n\tint s=pr[m].second+pr[m].first;\n\tif(left==0 && right==0){\n\t\tret=s;\n\t}else if(right==0){\n\t\tint l=lcm(pr[m].second, left*pr[m].first);\n\t\tret=l/pr[m].first+l/pr[m].second;\n\t}else if(left==0){\n\t\tint l=lcm(pr[m].second*right, pr[m].first);\n\t\tret=l/pr[m].first+l/pr[m].second;\n\t}else{\n\t\tint l=lcm(right*pr[m].second, left*pr[m].first);\n\t\tret=l/pr[m].first+l/pr[m].second;\n\t}\n//\tcout<<m<<\"  \"<<ret<<en;\n\treturn ret;\n}\n\nsigned main(){\n\twhile(cin>>n&&n){\n\t\tmemset(used, 0, sizeof(used));\n\t\tmemset(mobi, 0, sizeof(mobi));\n\t\tmemset(pr, 0, sizeof(pr));\n\t\tfor(int i=1; i<=n; i++){\n\t\t\tcin>>pr[i].first>>pr[i].second;\n\t\t\tint g=gcd(pr[i].first, pr[i].second);\n\t\t\tpr[i].first/=g; pr[i].second/=g;\n\t\t\tcin>>mobi[i].first>>mobi[i].second;\n\t\t\tused[mobi[i].first]=used[mobi[i].second]=1; \n\t\t}\n\t\tint root=0;\n\t\tfor(int i=1; i<=n; i++){\n\t\t\tif(used[i]==0) root=i;\n\t\t}\n//\t\tsym\n\t\tcout<<saiki(root)<<en;\n\t}\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <cstring>\nusing namespace std;\n\nint dp[110],K[110],O[110],L[110],R[110];\n\nint gcd(int a,int b){\n\tint tmp;\n\tif(a<b) swap(a,b);\n\twhile((tmp=a%b)!=0){\n\t\ta=b;\n\t\tb=tmp;\n\t}\n\tif(b==0) while(true);//\n\treturn b;\n}\n\n\nint mobi(int bou){\n\tif(bou==0) return 1;\n\tif(dp[bou]!=0) return dp[bou];\n\tint l,r,li,ri,gc2,a,b;\n\tl=mobi(L[bou]);\n\tr=mobi(R[bou]);\n\tri=K[bou];li=O[bou];\n\tgc2=gcd(li*l,ri*r);\n\tb=li*l/gc2;\n\ta=ri*r/gc2;\n\tdp[bou]=(a*l+b*r);\n\treturn dp[bou];\n}\n\nint main(){\n\tint N,k,o,g;\n\tint res;\n\twhile(1){\n\t\tcin>>N;\n\t\tif(N==0) break;\n\t\tmemset(dp,0,sizeof(dp));\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tcin>>k>>o>>L[i]>>R[i];\n\t\t\tg=gcd(k,o);\n\t\t\tK[i]=k/g;\n\t\t\tO[i]=o/g;\n\t\t}\n\t\tres=0;\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tres=max(res,mobi(i));\n\t\t}\n\t\t/*\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tcout<<i<<\" \"<<dp[i]<<endl;//\n\t\t}\n\t\t*/\n\t\tcout<<res<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nll gcd(ll a, ll b) {\n  return b != 0 ? gcd(b, a % b) : a;\n}\n\nconst ll WEIGHT=-1;\nstruct stick{\n\tll r,b,p,q;\n\tstick(ll r,ll b,ll p,ll q):r(r),b(b){\n\t\tll g=gcd(p,q);\n\t\tthis->p=p/g;\n\t\tthis->q=q/g;\n\t}\n\tll getroot(ll index,vector<stick> &sticks){\n\t\tREP(i,sticks.size()){\n\t\t\tif(sticks[i].r==index||sticks[i].b==index){\n\t\t\t\treturn sticks[i].getroot(i,sticks);\n\t\t\t}\n\t\t}\n\t\treturn index;\n\t}\n\tll go(vector<stick> &sticks){\n\t\tll rw=0,bw=0;\n\t\tif(r!=WEIGHT){\n\t\t\trw=sticks[r].go(sticks);\n\t\t}\n\t\tif(b!=WEIGHT){\n\t\t\tbw=sticks[b].go(sticks);\n\t\t}\n\t\tif(r==WEIGHT&&b==WEIGHT){\n\t\t\trw=q;\n\t\t\tbw=p;\n\t\t}else if(r==WEIGHT){\n\t\t\tif(p*bw%q){\n\t\t\t\trw=bw*p;\n\t\t\t\tbw*=q;\n\t\t\t}else{\n\t\t\t\trw=bw*p/q;\n\t\t\t\tassert(bw);\n\t\t\t}\n\t\t}else if(b==WEIGHT){\n\t\t\tif(q*rw%p){\n\t\t\t\tbw=rw*q;\n\t\t\t\trw*=p;\n\t\t\t}else{\n\t\t\t\tbw=rw*q/p;\n\t\t\t\tassert(rw);\n\t\t\t}\n\t\t}else{\n\t\t\tassert(bw);\n\t\t\tassert(rw);\n\t\t\tll trw=rw,tbw=bw;\n\t\t\tll gr=gcd(rw,q);\n\t\t\tll gb=gcd(bw,p);\n\t\t\trw=trw*tbw*q/gr;\n\t\t\tassert(tbw);\n\t\t\tassert(trw);\n\t\t\tassert(p);\n\t\t\tassert(gb);\n\t\t\tbw=tbw*trw*p/gb;\n\t\t\tassert(bw);\n\t\t\tassert(rw);\n\t\t}\n\t\tassert(rw&&bw);\n\t\treturn rw+bw;\n\t}\n};\n\n\nint main(){\n\tll n;\n\twhile(cin>>n,n){\n\t\tvector<stick> sticks;\n\t\tREP(i,n){\n\t\t\tll p,q,r,b;\n\t\t\tcin>>p>>q>>r>>b;\n\t\t\tr--;b--;\n\t\t\tsticks.push_back(stick(r,b,p,q));\n\t\t}\n\t\tll root=sticks[0].getroot(0,sticks);\n\t\tcout<<sticks[root].go(sticks)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <climits>\n#include <vector>\nusing namespace std;\n\nlong long gcd(long long x, long long y) {\n    while(y) {\n        long long t=x%y;x=y;y=t;\n    }\n    return x;\n}\n\nlong long ps[100],qs[100],rs[100],bs[100], memo[100];\n\nlong long calc(long long i) {\n    if(i==-1) return 1;\n    if(memo[i]>=0) return memo[i];\n    long long r = calc(rs[i]);\n    long long b = calc(bs[i]);\n    long long p = ps[i];\n    long long q = qs[i];\n    long long left_factor = r*q; // b*left_factor\n    long long right_factor = b*p; // r*right_factor\n    long long fgcd = gcd(left_factor, right_factor);\n    left_factor /= fgcd;\n    right_factor /= fgcd;\n    memo[i] = b*left_factor + r*right_factor;\n    return memo[i];\n}\n\nint main() {\n    while(true) {\n        int n; scanf(\"%d\", &n);\n        if(n==0) break;\n        fill(memo, memo+n, -1);\n        for(int i = 0; i < n; i++) {\n            scanf(\"%lld%lld%lld%lld\", ps+i, qs+i, rs+i, bs+i);\n            rs[i]--; bs[i]--;\n        }\n        long long max_val = 0;\n        for(int i = 0; i < n; i++) {\n            max_val = max(max_val, calc(i));\n        }\n        printf(\"%lld\\n\", max_val);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include <cassert>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define vi vector<int>\n#define pb push_back\n#define INF 999999999\n//#define INF (1LL<<59)\nll gcd (ll a,ll b){\n\tif(a<b)swap(a,b);\n\tif(a%b==0)return b;\n\treturn gcd(b,a%b);\n}\n\nll lcm(ll a,ll b){\n\treturn a/gcd(a,b)*b;\n}\n\nstruct stick{\n\tint ld,rd,left,right;\n};\n\n\nvector<stick> data;\n\nint solve(int stick_num){\n\tstick now = data[stick_num];\n\tint left=0,right=0;\n\tif(now.left !=0)left = solve(now.left);\n\tif(now.right!=0)right= solve(now.right);\n\tcout<<stick_num<<\" \"<<left<<\" \"<<right<<endl;\n\t\n\tif(left==0&&right==0) return (now.rd+now.ld)/gcd(now.ld,now.rd);\n\n\telse if(left==0 && right!=0){\n\t\tint rw = lcm(right,now.rd);\n\t\tint lw = now.ld*(rw/now.rd);\n\t\treturn rw+lw;\n\t}\n\t\n\telse if(left!=0 && right==0){\n\t\tint lw = lcm(left,now.ld);\n\t\tint rw = now.rd*(lw/now.ld);\n\t\treturn rw+lw;\n\t}\n\t\n\telse{\n\t\tint a = left *now.rd/lcm(now.rd,now.ld);\n\t\tint b = right*now.ld/lcm(now.rd,now.ld);\n\t\treturn lcm(a,b)*2;\n\t}\n}\n\n\nint getParent(int n){\n\tint par[200];\n\trep(i,200)par[i]=-1;\n\t\n\tfor(int i=1;i<=n;i++){\n\t\tif(data[i].left !=0) par[data[i].left ] = i;\n\t\tif(data[i].right!=0) par[data[i].right] = i;\n\t}\n\t\n\tfor(int i=1;i<=n;i++){\n\t\tif(par[i]==-1)return i;\n\t}\n\treturn -1;\n}\n\n\nint main(){\n\tint n;\n\twhile(cin>>n&&n){\n\t\tdata.clear();\n\t\tdata.pb(stick{-1,-1,-1,-1});\n\t\trep(i,n){\n\t\t\tint a,b,c,d;\n\t\t\tcin>>a>>b>>c>>d;\n\t\t\tdata.pb(stick{a,b,c,d});\n\t\t}\n\t\n\t\tint par = getParent(n);\n\t\tassert(par!=-1);\n\t\t\n\t\tcout<<solve(par)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps = 1e-9;\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.txt\"\n\nlong long int gcd(long long int l, long long int r) {\n\tassert(l > 0 && r > 0);\n\tif (l > r)return gcd(r, l);\n\telse {\n\t\tconst long long int num = r%l;\n\t\tif (num) {\n\t\t\treturn gcd(l, num);\n\t\t}\n\t\telse {\n\t\t\treturn l;\n\t\t}\n\t}\n}\nlong long int lca(long long int l, long long int r) {\n\treturn l / gcd(l, r)*r;\n}\n\nstruct mobi {\n\tlong long int a;\n\tlong long int b;\n\tint lid;\n\tint rid;\n\n};\n\nlong long int getans(const int id,const vector<mobi>&ms) {\n\tlong long int lw=0, rw=0;\n\tif (ms[id].lid!=-1) {\n\t\tlw = getans(ms[id].lid, ms);\n\t}\n\telse {\n\t\tlw = 1;\n\t}\n\tif (ms[id].rid != -1) {\n\t\trw = getans(ms[id].rid, ms);\n\t}\n\telse {\n\t\trw = 1;\n\t}\n\tlong long int al = lw*ms[id].b;\n\tlong long int ar = rw*ms[id].a;\n\tlong long int alca = lca(al, ar);\n\treturn alca / al*lw + alca / ar*rw;\n}\n\nint main() {\n\twhile (1) {\n\t\tint N; cin >> N;\n\t\tif (!N)break;\n\t\tvector<mobi>ms;\n\t\tvector<int>pas(N);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tlong long int a, b;int lid, rid; cin >> a >> b >> lid >> rid;\n\t\t\tlid--; rid--;\n\t\t\tif (lid != -1)pas[lid] = true;\n\t\t\tif (rid != -1)pas[rid] = true;\n\t\t\tconst long long int agcd = gcd(a, b);\n\t\t\ta /= agcd; b /= agcd;\n\t\t\tms.push_back(mobi{ a,b,lid,rid });\n\t\t}\n\t\tint nopa = find(pas.begin(), pas.end(), 0) - pas.begin();\n\t\tlong long int ans = getans(nopa, ms);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nint gcd(int x, int y)\n{    return y ? gcd(y, x % y) : x;\t}\n\nint lcm(int x, int y)\n{\treturn x * y / gcd(x, y);\t}\n\nint poles[128][4];\n\nint weight(int id)\n{\n\tint r = (poles[id][2] == 0 ? 1 : weight(poles[id][2]));\n\tint l = (poles[id][3] == 0 ? 1 : weight(poles[id][3]));\n\t\n\tint p = poles[id][0];\n\tint q = poles[id][1];\n\t\n\tint a = lcm(r*q, l*p) / q;\n\tint b = lcm(r*q, l*p) / p;\n\t\n\treturn a + b;\n}\n\nint main()\n{\n\tfor(int n; cin >> n && n;)\n\t{\n\t\tvint top(128, true);\n\t\t\n\t\tfor(int i = 1; i <= n; i++)\n\t\t{\n\t\t\trep(j, 4) cin >> poles[i][j];\n\n\t\t\ttop[poles[i][2]] = top[poles[i][3]] = false;\n\t\t}\n\t\t\n\t\tfor(int i = 1; i <= n; i++) if(top[i]) cout << weight(i) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <map>\n#include <set>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <bitset>\nusing namespace std;\n#define INF\t100000000\n#define MOD 1000000007\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define sec second\n#define lb lower_bound\n#define ub upper_bound\n#define SS stringstream\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define SORT(x) sort((x).begin(), (x).end())\n#define clr(a,b) memset((a),(b),sizeof(a))\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<ll,ll> LP;\ntypedef pair<LP,P> PP;\ntypedef vector<int> Vi;\ntypedef vector<ll> Vll;\ntypedef vector<P> Vp;\ntypedef priority_queue<P, vector<P>, greater<P> > PQ;\n\nint n;\nint par[100];\nll ans;\nll tmp;\nPP x[100];\n\nvoid B(int y){\n\ttmp *= x[y].fi.fi;\n\tif(x[y].sec.fi >= 0) B(x[y].sec.fi);\n\telse ans += tmp;\n\ttmp /= x[y].fi.fi;\n\ttmp *= x[y].fi.sec;\n\tif(x[y].sec.sec >= 0) B(x[y].sec.sec);\n\telse ans += tmp;\n\ttmp /= x[y].fi.sec;\n}\n\nll A(int y){\n\tll a, b, p, q;\n\tif(x[y].sec.fi >= 0) a = A(x[y].sec.fi);\n\telse a = 1;\n\tif(x[y].sec.sec >= 0) b = A(x[y].sec.sec);\n\telse b = 1;\n\ta *= x[y].fi.fi; b *= x[y].fi.sec;\n\tp = a; q = b;\n\twhile(true){\n\t\tif(p < q) swap(p,q);\n\t\tp %= q;\n\t\tif(p == 0) break;\n\t}\n\tll z = a*b/q;\n\ta = z/a;\n\tb = z/b;\n\tll ret = z/x[y].fi.fi+z/x[y].fi.sec;\n\tx[y].fi.fi = a;\n\tx[y].fi.sec = b;\n\t//cout << y << \" \" << z << \" \" << a << \" \" << b << endl;\n\treturn ret;\n}\n\nvoid solve(){\n\trep(i,100) par[i] = i;\n\ttmp = 1; ans = 0;\n\trep(i,n){\n\t\tscanf(\"%lld%lld%d%d\", &x[i].fi.fi, &x[i].fi.sec, &x[i].sec.fi, &x[i].sec.sec);\n\t\tx[i].sec.fi--; x[i].sec.sec--;\n\t\tif(x[i].sec.fi >= 0) par[x[i].sec.fi] = i; \n\t\tif(x[i].sec.sec >= 0) par[x[i].sec.sec] = i;\n\t\tll p = x[i].fi.fi, q = x[i].fi.sec;\n\t\twhile(true){\n\t\t\tif(p < q) swap(p,q);\n\t\t\tp %= q;\n\t\t\tif(p == 0) break;\n\t\t}\n\t\tx[i].fi.fi /= q; x[i].fi.sec /= q;\n\t}\n\tint s;\n\trep(i,n){\n\t\tif(par[i] == i) s = i;\n\t}\n\tll trash = A(s);\n\tB(s);\n\tprintf(\"%lld\\n\", ans);\n}\n\nint main(){\n\twhile(scanf(\"%d\", &n), n){\n\t\tsolve();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cmath>\n\nstruct Pole{\n\tint red_ratio,blue_ratio,red_topole,blue_topole;\n\tint sum_ball;\n\tPole(){sum_ball=-1;}\n};\n\nbool ask_ball(const Pole &a,const Pole &b){\n\tif(a.sum_ball>b.sum_ball)return true;\n\treturn false;\n}\n\nint gcd(int a,int b){\n\tint c;\n\tif(b>a)c=a,a=b,b=c;\n\twhile(b!=0)c=b,b=a%b,a=c;\n\treturn a;\n}\n\n\nint main(){\n\tPole pole[101];\n\tint n;\n\tstd::cin>>n;\n\tfor(int i=0;i<n;i++)std::cin>>pole[i].red_ratio>>pole[i].blue_ratio>>pole[i].red_topole>>pole[i].blue_topole;\n\tfor(int k=0;k<n;k++){\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(pole[i].sum_ball==-1){\n\t\t\t\tint ball=gcd(pole[i].red_ratio,pole[i].blue_ratio);\n\t\t\t\tif(pole[i].red_topole==0&&pole[i].blue_topole==0)pole[i].sum_ball=(pole[i].red_ratio/ball)+(pole[i].blue_ratio/ball);\n\t\t\t\telse if(pole[i].red_topole==0&&pole[pole[i].blue_topole-1].sum_ball!=-1){\n\t\t\t\t\tfor(int j=pole[pole[i].blue_topole-1].sum_ball;;j+=pole[pole[i].blue_topole-1].sum_ball){\n\t\t\t\t\t\tdouble red=(double)(pole[i].blue_ratio*j)/pole[i].red_ratio;\n\t\t\t\t\t\tif(ceil(red)==floor(red)){\n\t\t\t\t\t\t\tpole[i].sum_ball=red+j;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(pole[i].blue_topole==0&&pole[pole[i].red_topole-1].sum_ball!=-1){\n\t\t\t\t\tfor(int j=pole[pole[i].red_topole-1].sum_ball;;j+=pole[pole[i].red_topole-1].sum_ball){\n\t\t\t\t\t\tdouble blue=(double)(pole[i].red_ratio*j)/pole[i].blue_ratio;\n\t\t\t\t\t\tif(ceil(blue)==floor(blue)){\n\t\t\t\t\t\t\tpole[i].sum_ball=blue+j;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(pole[pole[i].red_topole-1].sum_ball!=-1&&pole[pole[i].blue_topole-1].sum_ball!=-1){\n\t\t\t\t\tint red=pole[pole[i].red_topole-1].sum_ball,blue=pole[pole[i].blue_topole-1].sum_ball;\n\t\t\t\t\twhile(1){\n\t\t\t\t\t\tif(red*pole[i].red_ratio<blue*pole[i].blue_ratio)red+=pole[pole[i].red_topole-1].sum_ball;\n\t\t\t\t\t\telse if(red*pole[i].red_ratio>blue*pole[i].blue_ratio)blue+=pole[pole[i].blue_topole-1].sum_ball;\n\t\t\t\t\t\telse break;\n\t\t\t\t\t}\n\t\t\t\t\tpole[i].sum_ball=red+blue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tstd::sort(pole+0,pole+n,ask_ball);\n\tstd::cout<<pole[0].sum_ball<<std::endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n;\nlong long p[101],q[101],r[101],b[101];\nlong long memo[101];\nlong long dp(int a){\n  if(memo[a] != -1) return memo[a];\n  if(r[a] == 0 && b[a] == 0) return memo[a] = p[a] + q[a];\n  long long red,blue;\n  if(r[a] == 0){\n    red = q[a];\n    blue = dp(b[a]);\n  } else if(b[a] == 0){\n    blue = p[a];\n    red = dp(r[a]);\n  } else {\n    red = dp(r[a]);\n    blue = dp(b[a]);\n  }\n  red *= (q[a] / __gcd(red,q[a]));\n  blue *= (p[a] / __gcd(blue,p[a]));\n  long long m = (blue/p[a])*(red/q[a])/__gcd(blue/p[a],red/q[a]);\n  return memo[a] = m*(p[a]+q[a]);\n}\nint main(){\n  while(scanf(\"%d\",&n),n!=0){\n    fill(memo,memo+101,-1);\n    for(int i=1;i<=n;i++){\n      scanf(\"%lld %lld %lld %lld\",&p[i],&q[i],&r[i],&b[i]);\n      long long m = __gcd(p[i],q[i]);\n      p[i] /= m;\n      q[i] /= m;\n    }\n    long long ans = 0;\n    for(int i=1;i<=n;i++){\n      ans = max(ans,dp(i));\n    }\n    printf(\"%lld\\n\",ans);\n  }\n  return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <map>\n#include <sstream>\n#include <string>\n#include <cstdio>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cstring>\n#include <tuple>\n#include <utility>\n#include <list>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> Array;\ntypedef pair<int, int> P;\n\nconst int INF = 1 << 29;\nconst LL MOD = 100000;\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define all(c) (c).begin(), (c).end()\n\nstruct edge{ int to, cost; edge(int t, int c) :to(t), cost(c){} };\n\nint dxk[] = { 1, 1, 1, 0, -1, 0 };\nint dxg[] = { 0, 1, 0, -1, -1, -1 };\nint dy[] = { -1, 0, 1, 1, 0, -1 };\n\nstruct node\n{\n\tLL value, lw, rw, left, right;\n};\n\nLL gcd(LL a, LL b)\n{\n\tif (a < b) swap(a, b);\n\treturn a % b == 0 ? b : gcd(b, a % b);\n}\nLL sks(LL a, LL b)\n{\n\tLL g = gcd(a, b);\n\treturn a / g * b;\n}\n\n//The Lightest Mobile\nint main()\n{\n\tint n;\n\twhile (cin >> n && n)\n\t{\n\t\tvector<node> bars(n);\n\t\trep(i, n)\n\t\t{\n\t\t\tint p, q, r, b;\n\t\t\tcin >> p >> q >> r >> b;\n\t\t\tint g = gcd(p, q);\n\t\t\tbars[i].rw = p / g;\n\t\t\tbars[i].lw = q / g;\n\t\t\tbars[i].left = r - 1;\n\t\t\tbars[i].right = b - 1;\n\t\t}\n\n\t\tfunction<void(node&)> dfs = [&](node& node)\n\t\t{\n\t\t\tif (node.value != 0) return;\n\t\t\tif (node.right == -1 && node.right == node.left)\n\t\t\t{\n\t\t\t\tint g = gcd(node.rw, node.lw);\n\t\t\t\tint nr = node.rw / g , nl = node.lw / g;\n\t\t\t\tnode.value = nr + nl;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (node.right == -1)\n\t\t\t{\n\t\t\t\tdfs(bars[node.left]);\n\t\t\t\tLL left = bars[node.left].value;\n\t\t\t\tLL leftgcd = left / gcd(left, node.lw);\n\t\t\t\tLL right = leftgcd * node.rw;\n\t\t\t\tLL nlw = leftgcd * node.lw;\n\t\t\t\tnode.value = nlw + right;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (node.left == -1)\n\t\t\t{\n\t\t\t\tdfs(bars[node.right]);\n\t\t\t\tLL right = bars[node.right].value;\n\t\t\t\tLL rightgcd = right / gcd(right, node.rw);\n\t\t\t\tLL left = rightgcd * node.lw;\n\t\t\t\tLL nrw = rightgcd * node.rw ;\n\t\t\t\tnode.value = nrw + left;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tdfs(bars[node.right]);\n\t\t\tdfs(bars[node.left]);\n\t\t\t//最小公倍数とったりして整数倍の値にできるようにごにょる\n\t\t\tLL r = bars[node.right].value, l = bars[node.left].value;\n\t\t\tLL m = node.lw, n = node.rw;\n\t\t\tLL rm = r * m, lm = l * m,\n\t\t\t\trn = r * n, ln = l * n;\n\t\t\tLL rsv = sks(rm, lm);//rを基準にした比から\n\t\t\tLL lsv = sks(rn, ln);//lを基準にした比から\n\t\t\tnode.value = rsv + lsv;\n\t\t\treturn;\n\t\t};\n\n\t\tLL ans = 0;\n\t\trep(i, n)\n\t\t{\n\t\t\tdfs(bars[i]);\n\t\t\tans = max(bars[i].value, ans);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma warning(disable: 4996)\n#include<cstdio>\n#include<math.h>\n#include<algorithm>\n#include<string.h>\n#include<vector>\n#include<queue>\n#include<vector>\n\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\nconst int INF=1001001001;\n\nconst int mod=100000;\n\n#define MAX_N 100\nint N;\npair<int,int> pq[MAX_N];\nint rod[MAX_N][2];\nvector<int> edge[MAX_N];\nint redge[MAX_N][2];\npriority_queue<pair<int,int> > dist;//second ??????top??????????????¢???first\nbool iftop[MAX_N];//top??????false\n\nint gcd(int a, int b){\n\tif(b==0) return a;\n\treturn gcd(b,a%b);\n}\n\nint main(){\n\twhile(1){\n\t\tscanf(\"%d\",&N);\n\t\tif(N==0)break;\n\t\tmemset(redge,-1,sizeof(redge));\n\t\trep(i,N){\n\t\t\tint p,q,r,b;\n\t\t\tscanf(\"%d %d %d %d\",&p,&q,&r,&b);\n\t\t\tpq[i]= make_pair(p,q);\n\t\t\tif(r>0){iftop[r-1]=true;edge[i].push_back(r-1);redge[r-1][0]=i;}\n\t\t\tif(b>0){iftop[b-1]=true;edge[i].push_back(b-1);redge[b-1][1]=i;}\n\n\t\t}\n\t\tint top=find(iftop,iftop+N,false)-iftop;\n\t\tqueue<int> q1;q1.push(top);\n\t\tint dister=0;\n\t\twhile(q1.size()){\n\t\t\tqueue<int> q2;\n\t\t\tdister++;\n\t\t\twhile(q1.size()){\n\t\t\t\tint a=q1.front();q1.pop();\n\t\t\t\tdist.push(make_pair(dister,a) );\n\t\t\t\trep(i,edge[a].size()){\n\t\t\t\t\tq2.push(edge[a][i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tq1=q2;\n\t\t}\n\n\t\tint ans=0;\n\t\twhile(dist.size()){\n\t\t\tpair<int,int> a=dist.top();dist.pop();\n\t\t\tint n=a.second;\n\t\t\tint gc=gcd(pq[n].first,pq[n].second);\n\t\t\tint p=pq[n].first/gc;int q= pq[n].second/gc;\n\t\t\tint sans=0;\n\t\t\tif(rod[n][0]==0&&rod[n][1]==0){\n\t\t\t\tsans=p+q;\n\t\t\t}else{\n\t\t\t\tif(rod[n][0]==0)rod[n][0]=1;if(rod[n][1]==0)rod[n][1]=1;\n\t\t\t\tint power=(rod[n][0]*p)*(rod[n][1]*q)/gcd( (rod[n][0]*p),(rod[n][1]*q) );\n\t\t\t\tsans=power/p+power/q;\n\t\t\t}\n\t\t\trep(i,2)if(redge[n][i]>-1){\n\t\t\t\t\trod[redge[n][i]][i]+=sans;\n\t\t\t\t}\n\t\t\tif(!dist.size()){\n\t\t\t\tans=sans;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint n,mem[110][5],sum;\nint F(int n1,int n2)\n{\n    int s1,s2;\n    s1 = min(n1,n2);\n    s2 = max(n1,n2);\n    if(s1 == 0)return s2;\n    return F(s2 % s1,s1);\n}\nint min_w(int n_mobile)\n{\n    int n1,n2,lim,longth,s1,s2;\n    if(mem[n_mobile][2] == 0)n1 = 1;\n    else n1 = min_w(mem[n_mobile][2] - 1);\n    if(mem[n_mobile][3] == 0)n2 = 1;\n    else n2 = min_w(mem[n_mobile][3] - 1);\n    longth = F(min(mem[n_mobile][0],mem[n_mobile][1]),max(mem[n_mobile][0],mem[n_mobile][1]));\n    //printf(\"%d %d %d\\n\",n_mobile,lim,longth);\n    s1 = n1 / F(n1,mem[n_mobile][1] / longth);\n    s2 = n2 / F(n2,mem[n_mobile][0] / longth);\n    lim = F(min(s1,s2),max(s1,s2));\n    return ((s1 * s2) / lim) * ((mem[n_mobile][0] / longth) + (mem[n_mobile][1] / longth));\n}\nint main()\n{\n    while(scanf(\"%d\",&n),n)\n    {\n        sum = 0;\n        for(int i = 0; i < n; i++)\n        {\n            for(int j = 0; j < 4; j++)\n            {\n                scanf(\"%d\",&mem[i][j]);\n            }\n            sum += mem[i][2] + mem[i][3];\n        }\n        printf(\"%d\\n\",min_w((n * (n + 1)) / 2 - sum - 1));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint gcd(int x,int y){\n\tif(y==0)return x;\n\treturn gcd(y,x%y);\n}\n\nint s(int p,int q,int r,int b){\n\tint x=p*r,y=q*b;\n\tint g=gcd(x,y);\n\treturn x/g*y/p+x/g*y/q;\n}\n\nint main(){\nwhile(1){\n\tint n,p[102],q[102],r[102],b[102],ret[102];\n\tbool top[102],flag[102];\n\tscanf(\"%d\",&n);\n\tif(n==0)break;\n\tfor(int i=0;i<102;i++){top[i]=true; flag[i]=true;}\n\tret[0]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d%d%d%d\",&p[i],&q[i],&r[i],&b[i]);\n\t\ttop[r[i]]=false;\n\t\ttop[b[i]]=false;\n\t\tret[i]=-1;\n\t}\n\tbool updata=true;\n\twhile(updata){\n\t\tupdata=false;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tif(flag[i]&&ret[r[i]]!=-1&&ret[b[i]]!=-1){\n\t\t\t\tret[i]=s(p[i],q[i],ret[r[i]],ret[b[i]]);\n\t\t\t\tupdata=true;\n\t\t\t\tflag[i]=false;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tif(top[i])printf(\"%d\\n\",ret[i]);\n\t}\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n\nint n;\nint bodate[101][5];//右ロン、左ロン、右子、左子、親。\nint heavy[101];\nint roots;\n\nint gcd(int a,int b){\n  if(a>b){\n    if(a%b==0) return b;\n    else return gcd(a%b,b);\n  }\n  else{\n    if(b%a==0) return a;\n    else return gcd(b%a,b);\n  }\n}\n\n\n\nint chains(int now){\n  int mim=0;\n  if(bodate[now][2]!=0) mim=chains(bodate[now][2]);\n  else mim=1;\n  int sam=0;\n  if(bodate[now][3]!=0) sam=chains(bodate[now][3]);\n  else sam=1;\n  int p=0;\n  int mihi,sahi;\n  p=gcd(bodate[now][0],bodate[now][1]);\n  mihi=bodate[now][1]/p;\n  sahi=bodate[now][0]/p;\n  int mip,sap;\n  p=gcd(mim*sahi,sam*mihi);\n  mip=sam*mihi/p;\n  sap=mim*sahi/p;\n  return mim*mip+sam*sap;\n}\n\nint main(void){\n  scanf(\"%d\",&n);\n  while(n!=0){\n    int i;\n    roots=0;\n    memset(bodate,0,sizeof(bodate));\n    memset(heavy,0,sizeof(heavy));\n    for(i=1;i<=n;i++){\n      scanf(\"%d%d%d%d\",&(bodate[i][0]),&(bodate[i][1]),&(bodate[i][2]),&(bodate[i][3]));\n      if(bodate[i][2]!=0)bodate[bodate[i][2]][4]=i;\n      if(bodate[i][3]!=0)bodate[bodate[i][3]][4]=i;\n    }\n    i=1;\n    while(bodate[i][4]!=0){\n      i=bodate[i][4];\n    }\n    roots=i;\n    int ans=chains(roots);\n\n    printf(\"%d\\n\",ans);\n    scanf(\"%d\",&n);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps = 1e-9;\n\nlong long int gcd(long long int l, long long int r) {\n\tassert(l > 0 && r > 0);\n\tif (l > r)return gcd(r, l);\n\telse {\n\t\tconst long long int num = r%l;\n\t\tif (num) {\n\t\t\treturn gcd(l, num);\n\t\t}\n\t\telse {\n\t\t\treturn l;\n\t\t}\n\t}\n}\nlong long int lca(long long int l, long long int r) {\n\treturn l / gcd(l, r)*r;\n}\n\nstruct mobi {\n\tlong long int a;\n\tlong long int b;\n\tint lid;\n\tint rid;\n\n};\n\nlong long int getans(const int id,const vector<mobi>&ms) {\n\tlong long int lw=0, rw=0;\n\tif (ms[id].lid!=-1) {\n\t\tlw = getans(ms[id].lid, ms);\n\t}\n\telse {\n\t\tlw = 1;\n\t}\n\tif (ms[id].rid != -1) {\n\t\trw = getans(ms[id].rid, ms);\n\t}\n\telse {\n\t\trw = 1;\n\t}\n\tlong long int al = lw*ms[id].b;\n\tlong long int ar = rw*ms[id].a;\n\tlong long int alca = lca(al, ar);\n\treturn alca / al*lw + alca / ar*rw;\n}\n\nint main() {\n\twhile (1) {\n\t\tint N; cin >> N;\n\t\tif (!N)break;\n\t\tvector<mobi>ms;\n\t\tvector<int>pas(N);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tlong long int a, b, lid, rid; cin >> a >> b >> lid >> rid;\n\t\t\tlid--; rid--;\n\t\t\tif (lid != -1)pas[lid] = true;\n\t\t\tif (rid != -1)pas[rid] = true;\n\t\t\tconst long long int agcd = gcd(a, b);\n\t\t\ta /= agcd; b /= agcd;\n\t\t\tms.push_back(mobi{ a,b,lid,rid });\n\t\t}\n\t\tint nopa = find(pas.begin(), pas.end(), 0) - pas.begin();\n\t\tlong long int ans = getans(nopa, ms);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\nusing namespace std;\n\nstruct bar\n{\n  int p, q, r, b;\n  void in(int _p, int _q, int _r, int _b)\n  {\n    p = _p;\n    q = _q;\n    r = _r;\n    b = _b;\n    return;\n  }\n};\n\nint n;\nbar mobile[101];\nbool parent_check[101];\nint parent;\n\nint gcd(int a, int b)\n{\n  if(a % b)\n    return gcd(b, a % b);\n  return b;\n}\n\nint solve(bar br)\n{\n  int heavy_r = br.r ? solve(mobile[br.r]) : 1;\n  int heavy_b = br.b ? solve(mobile[br.b]) : 1;\n\n  int moment_r = heavy_r * br.p;\n  int moment_b = heavy_b * br.q;\n  \n  int gcd_moment = gcd(moment_r, moment_b);\n  moment_r /= gcd_moment;\n  moment_b /= gcd_moment;\n\n  heavy_r *= moment_b;\n  heavy_b *= moment_r;\n\n  return heavy_r + heavy_b;\n}\n\nvoid main_b()\n{\n  memset(parent_check, false, sizeof parent_check);\n  \n  for(int i = 1; i <= n; i++){\n    int p, q, r, b;\n    cin >> p >> q >> r >> b;\n    \n    int gcd_long = gcd(p, q);\n    p /= gcd_long;\n    q /= gcd_long;\n    \n    mobile[i].in(p, q, r, b);\n    parent_check[r] = parent_check[b] = true;\n  }\n\n  for(int i = 1; i <= n; i++)\n    if(!parent_check[i])\n      parent = i;\n\n  cout << solve(mobile[parent]) << endl;\n  return;\n}\n\nint main()\n{\n  while(cin >> n && n)\n    main_b();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Bokan ga bokka--nn!!\n//Daily Lunch Special Tanoshii !!\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\ntypedef long long ll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 2000000000\n#define f first\n#define s second\n#define rep(i,x) for(int i=0;i<x;i++)\nstruct bar\n{\n\tint le,ri;\n\tint lev,riv;\n\tbar(){}\n\tbar(int le,int ri,int lev,int riv):\n\tle(le),ri(ri),lev(lev),riv(riv){}\n}s[105];\nll rec(int cur)\n{\n\tif(!cur) return 1ll;\n\tint lef,rig;\n\tlef=rec(s[cur].lev);\n\trig=rec(s[cur].riv);\n\tll a=1LL*lef/__gcd(lef,s[cur].ri);\n\tll b=1LL*rig/__gcd(rig,s[cur].le);\n\tll c=1LL*a*b/__gcd(a,b);\n\treturn c*(s[cur].le+s[cur].ri);\n}\nint main()\n{\n\tsrand((unsigned int)time(NULL));\nwhile(1)\n{\n\tint n; scanf(\"%d\",&n); if(!n) return 0;\n\tbool used[105]={};\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint a,b,c,d;\n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\tint v=__gcd(a,b);\n\t\ta/=v; b/=v;\n\t\ts[i]=bar(a,b,c,d);\n\t\tused[c]=used[d]=true;\n\t}\n\tll ret;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(!used[i])\n\t\t{\n\t\t\tret=rec(i);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ret);\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint gcd(int a,int b){return b?gcd(b,a%b):a;}\nint lcm(int a,int b){return a/gcd(a,b)*b;}\n\nint main(){\n  int n;\n  int par[100],left[100],right[100],p[100],q[100],r[100],b[100];\n  bool use[100];\n\n  while(cin >> n && n){\n    for(int i=0;i<n;i++)par[i] = -1;\n    for(int i=0;i<n;i++){\n      cin >> p[i] >> q[i] >> r[i] >> b[i];\n      int tmp = gcd(p[i],q[i]);\n      p[i]/=tmp;\n      q[i]/=tmp;\n      if(r[i]){\n\tleft[i] = 0;\n\tpar[r[i]-1] = i;\n      }else left[i] = 1;\n      if(b[i]){\n\tright[i] = 0;\n\tpar[b[i]-1] = i;\n      }else right[i] = 1;\n      use[i] = false;\n    }\n\n    int ans;\n    for(int j=0;j<n;j++){\n      for(int i=0;i<n;i++){\n\tif(!use[i] && left[i] && right[i]){\n\t  int x = 1;\n\t  while( (p[i]*x)%right[i] || (q[i]*x)%left[i])x++;\n\t  right[i] = p[i]*x;\n\t  left[i] = q[i]*x;\n\t  ans = right[i] + left[i];\n\t  //cout << left[i] << \" \" << right[i] << endl;\n\t  if(0<=par[i]){\n\t    if(r[par[i]]==i+1)left[par[i]] = ans;\n\t    else right[par[i]] = ans;\n\t  }\n\t  use[i] = true;\n\t  break;\n\t}\n      }\n    }\n    for(int i=0;i<n;i++)\n      if(par[i]<0)cout << right[i]+left[i] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nint gcd(int a,int b){\n    if(b==0)return a;\n    return gcd(b,a%b);\n    }  \n    int lcm(int a,int b){return a*b/gcd(a,b);}\nstruct bou{\n    int l,r,x,y;\n    };\n    int n[100];bou m[101];\nint mincost(int a){\n    if(n[a-1]!=-1)return n[a-1];\n    int b=1,c=1;\n    if(m[a].x)b=mincost(m[a].x/gcd(m[a].x,m[a].r));\n    if(m[a].y)c=mincost(m[a].y/gcd(m[a].y,m[a].l));\n    n[a-1]=lcm(b,c)*(m[a].l+m[a].r);\n    return lcm(b,c)*(m[a].l+m[a].r);\n    }\nsigned main(){\n   int a;\n   while(cin>>a,a){\n       memset(n,-1,sizeof(n));\n       bou g;\n       for(int b=1;b<=a;b++){\n\t   int c,d;\n\t  scanf(\"%lld%lld%lld%lld\",&c,&d,&g.x,&g.y);\n\t  g.l=c/gcd(c,d);g.r=d/gcd(c,d);\n\t  m[b]=g;\n\t   }\n\t for(int i=0;i<a;i++){\n\t     if(n[i]==-1)mincost(i+1);\n\t     }  \n\t     int MAX=0;\n\tfor(int i=0;i<a;i++){\n\t     MAX=max(MAX,n[i]);\n\t    }  \n\t    cout<<MAX<<endl;\n       }\n    }"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX_N 100\ntypedef long long ll;\n\nvector<ll> p, q, r, b;\n\nbool dfs(int v, ll val)\n{\n  ll l = p[v] + q[v];\n  if (val * p[v] % l != 0) {\n    return 0;\n  }\n  if (val * q[v] % l != 0) {\n    return 0;\n  }\n  bool can = 1;\n  if (r[v] >= 0) {\n    can &= dfs(r[v], val*p[v]/l); \n  }\n  if (b[v] >= 0) {\n    can &= dfs(b[v], val*q[v]/l); \n  }\n  return can;\n}\n\nvoid init(int N)\n{\n  p.clear(); q.clear();\n  r.clear(); b.clear();\n  p.resize(N); q.resize(N);\n  r.resize(N); b.resize(N);\n}\n\nint main()\n{\n  int N;\n  while (cin >> N, N) {\n    init(N);\n    bool used[MAX_N] = {};\n    for (int i = 0; i < N; i++) {\n      cin >> p[i] >> q[i] >> r[i] >> b[i];\n      r[i]--; b[i]--;\n      if (r[i] >= 0) used[r[i]] = 1;\n      if (b[i] >= 0) used[b[i]] = 1;\n      int gcd = __gcd(p[i], q[i]);\n      p[i] /= gcd;\n      q[i] /= gcd;\n    }\n    int par = -1;\n    for (int i = 0; i < N; i++) {\n      if (!used[i]) {\n\tpar = i;\n\tbreak;\n      }\n    }\n    \n    for (int i = 1; ; i++) {\n      if (dfs(par, i)) {\n\tcout << i << endl;\n\tbreak;\n      }\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\nlong long depth[500];\nlong long w[500][2];\nlong long x[500][2];\nlong long n, root, v[500], a, A, B, C;\npair<long long, long long>DEPTH[500];\nlong long mobile[500][2];\n\nlong long gcd(long long p, long long q) {\n\tlong long P = p, Q = q;\n\twhile (true) {\n\t\tif (P%Q == 0) { return Q; }\n\t\tif (Q%P == 0) { return P; }\n\t\tif (P > Q) { P = P%Q; }\n\t\telse { Q = Q%P; }\n\t}\n}\n\nint main() {\n\twhile (true) {\n\t\tmemset(depth, 0, sizeof(depth));\n\t\tmemset(w, 0, sizeof(w));\n\t\tmemset(x, 0, sizeof(x));\n\t\tmemset(v, 0, sizeof(v));\n\t\tmemset(DEPTH, 0, sizeof(DEPTH));\n\t\tmemset(mobile, 0, sizeof(mobile));\n\t\troot = 0; n = 0; A = 0; B = 0; C = 0; a = 0;\n\t\tcin >> n;\n\t\tif (n == 0) { break; }\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tv[i] = 0;\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tcin >> w[i][0] >> w[i][1] >> x[i][0] >> x[i][1];\n\t\t\tv[x[i][0]] = 1; v[x[i][1]] = 1;\n\t\t\ta = gcd(w[i][0], w[i][1]);\n\t\t\tw[i][0] /= a; w[i][1] /= a;\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (v[i] == 0) {\n\t\t\t\troot = i;\n\t\t\t}\n\t\t}\n\t\t//depth.\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tdepth[i] = 1000;\n\t\t}\n\t\tdepth[root] = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tif (depth[j] != 1000) {\n\t\t\t\t\tdepth[x[j][0]] = min(depth[x[j][0]], depth[j] + 1);\n\t\t\t\t\tdepth[x[j][1]] = min(depth[x[j][1]], depth[j] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tDEPTH[i - 1].first = depth[i];\n\t\t\tDEPTH[i - 1].second = i;\n\t\t}\n\t\tsort(DEPTH, DEPTH + n);\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tA = DEPTH[i].first;\n\t\t\tB = DEPTH[i].second;\n\t\t\tif (x[B][0] == 0 && x[B][1] == 0) {\n\t\t\t\tmobile[B][0] = w[B][1];\n\t\t\t\tmobile[B][1] = w[B][0];\n\t\t\t}\n\t\t\tif (x[B][0] == 0 && x[B][1] >= 1) {\n\t\t\t\tmobile[B][1] = mobile[x[B][1]][0] + mobile[x[B][1]][1];\n\t\t\t\tmobile[B][1] = mobile[B][1] * w[B][0] / gcd(mobile[B][1], w[B][0]);\n\t\t\t\tmobile[B][0] = mobile[B][1] * w[B][1] / w[B][0];\n\t\t\t}\n\t\t\tif (x[B][0] >= 1 && x[B][1] == 0) {\n\t\t\t\tmobile[B][0] = mobile[x[B][0]][0] + mobile[x[B][0]][1];\n\t\t\t\tmobile[B][0] = mobile[B][0] * w[B][1] / gcd(mobile[B][0], w[B][1]);\n\t\t\t\tmobile[B][1] = mobile[B][0] * w[B][0] / w[B][1];\n\t\t\t}\n\t\t\tif (x[B][0] >= 1 && x[B][1] >= 1) {\n\t\t\t\tmobile[B][0] = mobile[x[B][0]][0] + mobile[x[B][0]][1];\n\t\t\t\tmobile[B][1] = mobile[x[B][1]][0] + mobile[x[B][1]][1];\n\t\t\t\tC = mobile[B][0] * w[B][0] * mobile[B][1] * w[B][1] / gcd(mobile[B][0] * w[B][0], mobile[B][1] * w[B][1]);\n\t\t\t\tmobile[B][0] = C / w[B][0];\n\t\t\t\tmobile[B][1] = C / w[B][1];\n\t\t\t}\n\t\t}\n\t\tcout << mobile[root][0] + mobile[root][1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(b) - 1;i>=(a);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n\n#define PB push_back\n#define INF (1<<29)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define CLR(a) memset(a,0,sizeof(a))\nconst int dx[] = {-1,0,0,1},dy[] = {0,1,-1,0};\n\ntypedef long long int ll;\n\nusing namespace std;\nstruct mobile{\n    int rc = 0;\n    int lc = 0;\n    int l = 0;\n    int r = 0;\n    int w = 0;\n};\n\nint gcd(int a, int b){\n    return a%b==0 ? b : gcd(b,a%b);\n}\n\nvoid q(int i){\n\n}\n\nint main(){\n    while(true){\n\tint n;\n\tcin >> n;\n\tif(n == 0) break;\n\tint ans =0 ;\n\tvector< struct mobile > v(n);\n\tREP(i,n){\n\t    int l,r,lc,rc;\n\t    cin >> l >> r >> lc >> rc;\n\t    v[i].l = l;\n\t    v[i].r = r;\n\t    v[i].lc = lc;\n\t    v[i].rc = rc;\n\t    v[i].w = 0;\n\t}\n\tbool flg = true;\n\twhile(flg){\n\t    flg = false;\n\t    REP(i,n){\n\t\tif(v[i].w == 0 && v[i].rc == 0 && v[i].lc == 0){\n\t\t    int r = v[i].r;\n\t\t    int l = v[i].l;\n\t\t    v[i].r /= gcd(r,l);\n\t\t    v[i].l /= gcd(r,l);\n\t\t    v[i].w = v[i].r + v[i].l;\n\t\t    flg = true;\n\t\t}else{\n\t\t    int lw,rw;\n\t\t    if(v[i].w > 0) continue;\n\t\t    if(v[i].lc == 0){\n\t\t\tlw = 1;\n\t\t    }else if(v[v[i].lc-1].w > 0){\n\t\t\tlw = v[v[i].lc-1].w;\n\t\t    }else continue;\n\n\t\t    if(v[i].rc == 0){\n\t\t\trw = 1;\n\t\t    }else if(v[v[i].rc-1].w > 0){\n\t\t\trw = v[v[i].rc-1].w;\n\t\t    }else continue;\n\t\t    int r,l;\n\t\t    r = v[i].r;\n\t\t    l = v[i].l;\n\t\t    v[i].r /= gcd(r,l);\n\t\t    v[i].l /= gcd(r,l);\n\t\t    int w = 10000000;\n\t\t    FOR(k,1,100){\n\t\t\tFOR(j,1,100){\n\t\t\t    if(rw*k * v[i].r == lw * j * v[i].l){\n\t\t\t\tw = min ( w, rw*k+lw*j);\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t    v[i].w = w;\n\t\t    flg = true;\n\t\t}\n\t\tans = max(ans,v[i].w);\n\t    }\n\t}\n\tcout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nll gcd(ll x, ll y)\n{    return y ? gcd(y, x % y) : x;\t}\n\nll lcm(ll x, ll y)\n{\treturn x * y / gcd(x, y);\t}\n\nint poles[128][4];\n\nint weight(int id)\n{\n\tint r = (poles[id][2] == 0 ? 1 : weight(poles[id][2]-1));\n\tint l = (poles[id][3] == 0 ? 1 : weight(poles[id][3]-1));\n\t\n\tint p = poles[id][0];\n\tint q = poles[id][1];\n\t\n\tint a = lcm(r*q, l*p) / q;\n\tint b = lcm(r*q, l*p) / p;\n\t\n\treturn a + b;\n}\n\nint main()\n{\n\tfor(int n; cin >> n && n;)\n\t{\n\t\tvint top(128, true);\n\t\t\n\t\trep(i, n)\n\t\t{\n\t\t\trep(j, 4) cin >> poles[i][j];\n\n\t\t\ttop[poles[i][2]] = top[poles[i][3]] = false;\n\t\t}\n\t\t\n\t\tREP(i, 1, n+1) if(top[i]){ cout << weight(i-1) << endl; break; }\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = int_fast64_t;\nusing ui64 = uint_fast64_t;\n#define REP(i, n) for (ll (i) = 0; (i) < (n); ++(i))\n#define FOR(i, a, b) for (ll (i) = (a); (i) < (b); ++(i))\ninline ll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\n\nint f(int h1, int h2, int x, int y) {\n    int xb = x * h2;\n    int ya = y * h1;\n    int g = gcd(xb, ya);\n    int alpha = ya / g;\n    int beta = xb / g;\n    return x * alpha + y * beta;\n}\n\nvoid solve(int N) {\n\n    vector<pair<int, int>> hi(N, make_pair(-1, -1));\n    vector<pair<int, int>> graph(N, make_pair(-1, -1));\n    \n    REP(i, N) {\n        int p, q, r, b;\n        cin >> p >> q >> r >> b;\n        --r, --b;\n        graph[i] = make_pair(r, b);\n        hi[i] = make_pair(p, q);\n    }\n\n    vector<int> dp(N, -1);\n    function<int(int)> dfs = [&](int cur) {\n        if (dp[cur] != -1) return dp[cur];\n        int l_wei = graph[cur].first;\n        int r_wei = graph[cur].second;\n        if (l_wei == -1 and r_wei == -1) {\n            return dp[cur] = (hi[cur].first + hi[cur].second) / gcd(hi[cur].first, hi[cur].second);\n        } else if (l_wei == -1) {\n            int r = dfs(r_wei);\n            int y = hi[cur].first;\n            int x = hi[cur].second;\n            return dp[cur] = f(x, y, 1, r);\n        } else if (r_wei == -1) {\n            int l = dfs(l_wei);\n            int y = hi[cur].first;\n            int x = hi[cur].second;\n            return dp[cur] = f(x, y, l, 1);\n        } else {\n            int y = dfs(l_wei);\n            int x = dfs(r_wei);\n            return dp[cur] = f(hi[cur].first, hi[cur].second, x, y);\n        }\n    };\n\n    REP(i, N) dfs(i);\n    cout << *max_element(dp.begin(), dp.end()) << endl;\n}\n\nsigned main() {\n\n    int N;\n    while (cin >> N, N) solve(N);\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<ll> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1<<30;\nvvi in;\nvi dp;\nll gcd(ll a,ll b){\n\tif(b==0)return a;\n\treturn gcd(b,a%b);\n}\nll lcm(ll a,ll b){\n\treturn a/gcd(a,b)*b;\n}\nll f(int a){\n\tif(dp[a])return dp[a];\n\tll s=(in[a][2]?f(in[a][2]-1):1);\n\tll t=(in[a][3]?f(in[a][3]-1):1);\n\tll w=lcm(s*in[a][0],t*in[a][1]);\n\tdp[a]=w/in[a][0]+w/in[a][1];\n\treturn dp[a];\n}\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tin=vvi(n,vi(4));\n\t\trep(i,n)rep(j,4)cin>>in[i][j];\n\t\tdp=vi(n);\n\t\trep(i,n)f(i);\n\t\tll out=0;\n\t\trep(i,n)out=max(out,dp[i]);\n\t\tcout<<out<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nlong long int a[100+2],b[100+2],c[100+2],d[100+2],w[100+2],n;\n\nlong long int s(int x){\n\tlong long int ans;\n\tif(w[x]!=-1)return w[x];\n\telse {\n\t\tlong long int e=a[x]*s(c[x]),f=b[x]*s(d[x]);\n\t\tlong long int g=e,h=f,gcd;\n\t\twhile(1){\n\t\t\tg%=h;\n\t\t\tif(g==0)break;\n\t\t\th%=g;\n\t\t\tif(h==0)break;\n\t\t}\n\t\tgcd=e*f/max(g,h);\n\t\tans=gcd/a[x]+gcd/b[x];\n\t}\n\tw[x]=ans;\n\treturn ans;\n}\n\nint main(){\nwhile(1){\n\tlong long int an=0,aaa;\n\tscanf(\"%lld\",&n);\nif(n==0)break;\n\tw[0]=1;\n\tfor(int i=1;i<=n;i++){scanf(\"%lld%lld%lld%lld\",&a[i],&b[i],&c[i],&d[i]); w[i]=-1;}\n\tfor(int i=1;i<=n;i++){\n\t\tif(w[i]==-1)aaa=s(i);\n\t\tif(an<w[i])an=w[i];\n\t}\n\tprintf(\"%lld\\n\",an);\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define MAX_N 101\n\nint gcd(int x,int y){return __gcd(x,y);}\nint lcm(int x,int y){return x/gcd(x,y)*y;}\n\nstruct node{int lv,rv,lc,rc;};\n\nint n;\nnode g[MAX_N];\nint t[MAX_N];\n\nint rec(int pos){\n  if(pos==0)return 1;\n  node m=g[pos];\n  int a=rec(m.lc);\n  int b=rec(m.rc);\n  int c=lcm(a,b);\n  return c*(m.rv+m.lv);\n}\n\nvoid solve(){\n  int root;\n  for(root=1;t[root]>0;root++);\n  cout<<rec(root)<<endl;\n}\n\nvoid init(){\n  for(int i=0;i<MAX_N;i++)t[i]=0;\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    init(); \n    for(int i=1;i<=n;i++){\n      int p,q,r,b,x;\n      cin>>p>>q>>r>>b;\n      x=gcd(p,q);\n      p/=x,q/=x;\n      g[i]=(node){p,q,r,b};\n      t[r]=t[b]=i;\n    }\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\n\ntypedef struct stick{\n int lren, rren, sl, sr, weight; \n} STICK;\n\nint n, tmp, top;\nint depth[101];\nSTICK st[101];\n\nvoid init(int k){\n for(int i = 0; i <= k; i++){\n  depth[i] = 0;\n  st[i].weight = 0;\n }\n}\n\nint gcd(int a, int b){\n if(b == 0) return a;\n return gcd(b, a % b);\n}\n\nint lcm(int a, int b){\n return a / gcd(a, b) * b;\n}\n\nint solve(int k){\n if(st[k].weight > 0) return st[k].weight;\n if(st[k].sl == 0 && st[k].sr == 0){\n  return st[k].weight = st[k].lren + st[k].rren;\n }else if(st[k].sl == 0){\n  return st[k].weight = solve(st[k].sr) * (st[k].lren + st[k].rren) / gcd(solve(st[k].sr), st[k].lren);\n }else if(st[k]. sr == 0){\n  return st[k].weight = solve(st[k].sl) * (st[k].lren + st[k].rren) / gcd(solve(st[k].sl), st[k].rren);\n }else {\n  tmp = lcm(solve(st[k].sl) * st[k].lren, solve(st[k].sr) * st[k].rren);\n  return st[k].weight = tmp / st[k].lren + tmp / st[k].rren;\n }\n}\n\nint main(){\n while(scanf(\"%d\", &n)){\n  if(n == 0) break;\n  init(n);\n  for(int i = 1; i <= n; i++){\n   scanf(\"%d %d %d %d\", &st[i].lren, &st[i].rren, &st[i].sl, &st[i].sr);\n   tmp = gcd(st[i].lren, st[i].rren);\n   st[i].lren /= tmp;\n   st[i].rren /= tmp;\n  }\n  for(int i = 1; i <= n; i++){\n   depth[st[i].sl]++;\n   depth[st[i].sr]++;\n  }\n  for(int i = 1; i<= n; i++){\n   if(depth[i] == 0){\n    top = i;\n    break;\n   }\n  }\n  printf(\"%d\\n\", solve(top));\n }\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <cmath>\n#include <map>\n#include <set>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n\n#define INF_LL 1e18\n#define INF 1e9\n\n#define REP(i, n) for(int i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n\n#define fst first\n#define snd second\n\nusing namespace std;\n\nusing ll = long long;\nusing PII = pair<int, int>;\n\nstruct stick{\n\tint l_d, r_d;\n\tint par, l, r;\n};\n\nstick s[101];\n\nint gcd(int x, int y){\n\tif(y == 0) return x;\n\treturn gcd(y, x%y);\n}\n\nint dfs(int st, int wei){\n\tif(wei % (s[st].l_d+s[st].r_d) != 0) return 0;\n\tint tani = wei / (s[st].l_d+s[st].r_d);\n\tif((s[st].l == 0 || dfs(s[st].l, tani*s[st].l_d)) && (s[st].r == 0 || dfs(s[st].r, tani*s[st].r_d)))\n\t\treturn 1;\n\treturn 0;\n}\n\nint main(void){\n\tint n;\n\n\twhile(cin >> n && n){\n\t\tmemset(s, 0, sizeof s);\n\t\tFOR(i, 1, n+1){\n\t\t\ts[i].par = i;\n\t\t}\n\t\tFOR(i, 1, n+1){\n\t\t\tint a;\n\t\t\tcin >> s[i].l_d >> s[i].r_d >> s[i].l >> s[i].r;\n\t\t\ta = gcd(s[i].l_d, s[i].r_d);\n\t\t\ts[i].l_d /= a;\n\t\t\ts[i].r_d /= a;\n\t\t\ts[s[i].l].par = i;\n\t\t\ts[s[i].r].par = i;\n\t\t}\n\t\tint start = 1;\n\t\twhile(s[start].par != start){\n\t\t\tstart = s[start].par;\n\t\t}\n\t\tint wei = s[start].l_d+s[start].r_d;\n\t\tint cnt = 1;\n\t\twhile(!dfs(start, wei*cnt)){\n\t\t\tcnt++;\n\t\t}\n\t\tcout << wei*cnt << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<cstring>\n#define max(a,b) (a>b?a:b)\nlong long int a[101],b[101],c[101],d[101],memo[101],res=0;\n\nlong long int gcd(long long int x,long long int y){\n\tif(x==0)return y;\n\telse return gcd(y%x,x);\n}\nlong long int solve(int x){\n\tif(memo[x]!=0)return memo[x];\n\tint left=a[x]*solve(c[x]),right=b[x]*solve(d[x]),gc;\n\tgc=gcd(left,right);\n\treturn memo[x]=right/gc*solve(c[x])+left/gc*solve(d[x]);\n}\n\nint main(){\n\tmemo[0]=1;\n\tint n;\n\tfor(;scanf(\"%d\",&n),n!=0;memset(memo,0,sizeof(memo)){\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tscanf(\"%lld%lld%lld%lld\",a+i,b+i,c+i,d+i);\n\t\t}\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tres=max(res,solve(i));\n\t\t}\n\t\tprintf(\"%lld\\n\",res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cstdio>\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> P;\ntypedef pair<LL, LL> PLL;\n\nint gcd(int x, int y) {\n    if (x < y) { swap(x, y); }\n    if (y == 0) { return x; }\n    return gcd(y, x % y);\n}\n\nstruct mobile {\n    int lb;\n    int rb;\n    int lm;\n    int rm;\n};\n\nint N;\nmobile ms[110];\n\nint get_root() {\n    for (int j = 0; j < N; ++j) {\n        bool found = false;\n        for (int k = 0; k < N; ++k) {\n            if (ms[k].lm == j || ms[k].rm == j) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            return j;\n        }\n    }\n    return -1;\n}\n\nint rec(int x) {\n    mobile& m = ms[x];\n\n    int t = gcd(m.lb, m.rb);\n\n    if (m.lm == -1 && m.rm == -1) {\n        return (m.lb + m.rb) / t;\n    }\n\n    int lw, rw;\n    if (m.lm != -1 && m.rm == -1) {\n        lw = rec(m.lm) * (m.rb / t);\n        rw = (lw * m.lb) / m.rb;\n    } else if (m.lm == -1 && m.rm != -1) {\n        rw = rec(m.rm) * (m.lb / t);\n        lw = (rw * m.rb) / m.lb;\n    } else {\n        lw = rec(m.lm) * (m.rb / t);\n        rw = rec(m.rm) * (m.lb / t);\n        int u = gcd(lw * m.lb, rw * m.rb);\n        int tmp = lw;\n        lw *= (rw * m.rb) / u;\n        rw *= (tmp * m.lb) / u;\n    }\n\n    assert(lw * m.lb == rw * m.rb);\n    return lw + rw;\n}\n\nbool solve() {\n\n    cin >> N;\n    if (N == 0) {\n        return false;\n    }\n    for (int j = 0; j < N; ++j) {\n        cin >> ms[j].lb >> ms[j].rb >> ms[j].lm >> ms[j].rm;\n        --ms[j].lm; --ms[j].rm;\n    }\n\n    int root = get_root();\n\n    cout << rec(root) << endl;\n\n    return true;\n}\n\nint main() {\n    while(solve());\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint gcd(int a,int b){\n\tint c;\n\twhile(b!=0){\n\t\tc=a%b;\n\t\ta=b;\n\t\tb=c;\n\t}\n\treturn a;\n}\n\nint p[101]={};\nint q[101]={};\nint r[101]={};\nint b[101]={};\nint w[101]={};\n\nint det_w(int i){\n\tif(w[r[i]]==0){\n\t\tdet_w(r[i]);\n\t}\n\tif(w[b[i]]==0){\n\t\tdet_w(b[i]);\n\t}\n\tw[i]=w[r[i]]*w[b[i]]*(p[i]+q[i])/gcd(w[r[i]]*p[i],w[b[i]]*q[i]);\n\treturn 0;\n}\n\t\nint main() {\n\tint n;\n\tint m[101]={};\n\twhile(1){\n\t\tcin >> n;\n\t\tif(n==0){return 0;}\n\t\tw[0]=1;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tm[i]=0;\n\t\t}\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tcin >> p[i] >> q[i] >> r[i] >> b[i];\n\t\t\tw[i]=0;\n\t\t\tm[r[i]]=i;\n\t\t\tm[b[i]]=i;\n\t\t}\n\t\tint i=1;\n\t\twhile(m[i]!=0){\n\t\t\ti=m[i];\n\t\t}\n\t\tint ro=i;\n\t\tdet_w(ro);\n\t\tcout << w[ro] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\nusing namespace std;\n\nint n;\nint p[101], q[101], r[101], b[101];\nbool parent_check[101];\nint parent;\n\nint gcd(int x, int y)\n{\n  if(x % y)\n    return gcd(y, x % y);\n  return y;\n}\n\nint solve(int bar)\n{\n  int heavy_r = r[bar] ? solve(r[bar]) : 1;\n  int heavy_b = b[bar] ? solve(b[bar]) : 1;\n\n  int moment_r = heavy_r * p[bar];\n  int moment_b = heavy_b * q[bar];\n  \n  int gcd_moment = gcd(moment_r, moment_b);\n  moment_r /= gcd_moment;\n  moment_b /= gcd_moment;\n\n  heavy_r *= moment_b;\n  heavy_b *= moment_r;\n\n  return heavy_r + heavy_b;\n}\n\nvoid main_b()\n{\n  memset(parent_check, false, sizeof parent_check);\n  \n  for(int i = 1; i <= n; i++){\n    int _p, _q, _r, _b;\n    cin >> _p >> _q >> _r >> _b;\n    \n    int gcd_long = gcd(_p, _q);\n    p[i] = _p / gcd_long;\n    q[i] = _q / gcd_long;\n    r[i] = _r;\n    b[i] = _b;\n    \n    parent_check[_r] = parent_check[_b] = true;\n  }\n\n  for(int i = 1; i <= n; i++)\n    if(!parent_check[i])\n      parent = i;\n\n  cout << solve(parent) << endl;\n  return;\n}\n\nint main()\n{\n  while(cin >> n && n)\n    main_b();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define EQ(a,b) (abs((a)-(b))<EPS)\nint n;\nint r[101],b[101];\nint memo[101];\nP h[101];\nint ans;\nint rec(int s)\n{\n\tif(memo[s]>0)return memo[s];\n\tif(r[s]==0&&b[s]==0)\n\t{\n\t\tmemo[s]=h[s].fi+h[s].sec;\n\t\treturn memo[s];\n\t}\n\telse if(r[s]==0&&b[s]!=0)\n\t{\n\t\tmemo[s]=rec(b[s])/__gcd(h[s].fi,rec(b[s]))*(h[s].fi+h[s].sec);\n\t\treturn memo[s];\n\t}\n\telse if(r[s]!=0&&b[s]==0)\n\t{\n\t\tmemo[s]=rec(r[s])/__gcd(h[s].sec,rec(r[s]))*(h[s].fi+h[s].sec);\n\t\treturn memo[s];\n\t}\n\telse\n\t{\n\t\tint tp,tq;\n\t\ttp=h[s].fi;tq=h[s].sec;\n\t\tint k=rec(b[s])/__gcd(rec(b[s]),tp);\n\t\ttp*=k;tq*=k;\n\t\tk=rec(r[s])/__gcd(rec(r[s]),tq);\n\t\ttp*=k;\n\t\ttq*=k;\n\t\tmemo[s]=tp+tq;\n\t\treturn memo[s];\n\t}\n}\nint main()\n{\n\twhile(1)\n\t{\n\t\tmemset(r,0,sizeof(r));\n\t\tmemset(b,0,sizeof(b));\n\t\tmemset(memo,0,sizeof(memo));\n\t\tans=0;\n\t\tfor(int i=0;i<101;i++)\n\t\t{\n\t\t\th[i].fi=0;\n\t\t\th[i].sec=0;\n\t\t}\n\t\tcin >> n;\n\t\tif(n==0)break;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tint p,q,re,bl;\n\t\t\tcin >> p >> q >> re >> bl;\n\t\t\tint k=__gcd(p,q);\n\t\t\tp/=k;\n\t\t\tq/=k;\n\t\t\th[i]=mp(p,q);\n\t\t\tr[i]=re;\n\t\t\tb[i]=bl;\n\t\t}\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tans=max(ans,rec(i));\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<queue>\nusing namespace std;\n#define int long long\n\nstruct Stick{\n\tint p,q,r,b;\n};\nStick s[101];\n\nint tsurami(int a,int b){\n\tif(b==0) return a;\n\telse return tsurami(b,a%b);\n}\n\nint solve(int n){\n\tif(n==0) return 1;\n\tint pq_gcd = tsurami(s[n].p,s[n].q);\n\ts[n].p /= pq_gcd;\n\ts[n].q /= pq_gcd;\n\n\tint a = solve(s[n].r),\n\t\tb = solve(s[n].b);\n\tint ab_gcd = tsurami(a,b);\n\treturn (a*b/ab_gcd)*(s[n].p+s[n].q);\n}\n\nsigned main(){\n\tint N;\n\twhile(cin>>N,N){\n\t\tint par;\n\t\tbool cnt[101]={};\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tcin>>s[i].p>>s[i].q>>s[i].r>>s[i].b;\n\t\t\tcnt[s[i].r]=cnt[s[i].b]=true;\n\t\t}\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tif(cnt[i]==false){\n\t\t\t\tpar = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",solve(par));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nconst int N=100;\nint GCD(int a,int b){\n    if(b>a)swap(a,b);\n    return (b==0)?a:GCD(b,a%b);\n}\nint LCM(int a,int b){\n    return a*b/GCD(a,b);\n}\nint l[N+1],r[N+1],w1[N+1],w2[N+1];\nint memo[N+1];\nint dfs(int x){\n    if(memo[x]!=-1)return memo[x];\n    int red=l[x]*dfs(w1[x]);\n    int blue=r[x]*dfs(w2[x]);\n    int lcm=LCM(red,blue);\n    return memo[x]=lcm/l[x]+lcm/r[x];\n}\nint main(){\n    int n;\n    while(scanf(\"%d\",&n),n){\n        bool flag[N+1];fill_n(flag,n+1,true);\n        fill_n(memo,n+1,-1);\n        for(int i=1;i<=n;i++){\n            scanf(\"%d%d%d%d\",&l[i],&r[i],&w1[i],&w2[i]);\n            flag[w1[i]]=flag[w2[i]]=false;\n        }\n        memo[0]=1;\n        for(int i=1;i<=n;i++){\n            if(flag[i]){\n                printf(\"%d\\n\",dfs(i));\n                break;\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint a[100+2],b[100+2],c[100+2],d[100+2],w[100+2],n;\n\nint s(int x){\n\tint ans;\n\tif(w[x]!=-1)return w[x];\n\telse {\n\t\tint e=a[x]*s(c[x]),f=b[x]*s(d[x]);\n\t\tint g=e,h=f,gcd;\n\t\twhile(1){\n\t\t\tg%=h;\n\t\t\tif(g==0)break;\n\t\t\th%=g;\n\t\t\tif(h==0)break;\n\t\t}\n\t\tgcd=e*f/max(g,h);\n\t\tans=gcd/a[x]+gcd/b[x];\n\t}\n\tw[x]=ans;\n\treturn ans;\n}\n\nint main(){\nwhile(1){\n\tint an=0,aaa;\n\tscanf(\"%d\",&n);\n\tif(n==0)break;\n\tw[0]=1;\n\tfor(int i=1;i<=n;i++){scanf(\"%d%d%d%d\",&a[i],&b[i],&c[i],&d[i]); w[i]=-1;}\n\tfor(int i=1;i<=n;i++){\n\t\tif(w[i]==-1)aaa=s(i);\n\t\tif(an<w[i])an=w[i];\n\t}\n\tprintf(\"%d\\n\",an);\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\n\nstruct bou{\n    ll p,q,r,b;\n    bou(){}\n    bou(ll pp,ll qq,ll rr,ll bb){\n        p=pp;q=qq;r=rr;b=bb;\n    }\n};\nvector<bou> ins;\nll solve(int at){\n    if(at==0) return 1;\n    else{\n        at--;\n        ll rm=solve(ins[at].r),bm=solve(ins[at].b);\n        ll gcd=__gcd(rm,bm);\n        ll lcm=rm/gcd*bm;\n        gcd=__gcd(ins[at].p,ins[at].q);\n        ins[at].p/=gcd;\n        ins[at].q/=gcd;\n        return (ins[at].p+ins[at].q)*lcm;\n    }\n}\nint main(){\n    int n;\n    for(;;){\n        scanf(\"%d\",&n);\n        if(n==0) break;\n        ins=vector<bou>(n);\n        vector<bool> isroot(n,true);\n        for(int i=0;i<n;i++){\n            int p,q,r,b;\n            scanf(\"%d%d%d%d\",&p,&q,&r,&b);\n            int gcd=__gcd(p,q);\n            p=p/gcd;\n            q=q/gcd;\n            ins[i]=bou(p,q,r,b);\n            if(r!=0) isroot[r-1]=false;\n            if(b!=0) isroot[b-1]=false;\n        }\n        for(int i=0;i<n;i++){\n            if(isroot[i]){\n                printf(\"%lld\\n\",solve(i+1));\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define ALL(a) (a).begin(),(a).end()\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\nconst int INF=1e9;\nll gcd(ll a,ll b){\n  if(b==0)return a;\n  return gcd(b,a%b);\n}\nint main(){\n  int n;\n  while(cin>>n&&n){\n    ll w[110],p[110],q[110],r[110],b[110];\n    memset(w,-1,sizeof(w));\n    for(int i=1;i<=n;i++){\n      cin>>p[i]>>q[i]>>r[i]>>b[i];\n      ll g=gcd(p[i],q[i]);\n      p[i]/=g;q[i]/=g;\n      if(r[i]==0&&b[i]==0){\n        w[i]=p[i]+q[i];\n      }\n    }\n    bool update=true;\n    while(update){\n      update=false;\n      for(int i=1;i<=n;i++){\n        if(w[i]!=-1)continue;\n        if((r[i]==0||w[r[i]]!=-1)&&(b[i]==0||w[b[i]]!=-1)){\n          if(r[i]==0||b[i]==0){\n            if(r[i]==0)w[i]=w[b[i]]*(q[i]+p[i]);\n            else w[i]=w[r[i]]*(q[i]+p[i]);\n          }else{\n            ll y=w[b[i]]*q[i],x=w[r[i]]*p[i];\n            ll g=gcd(x,y);\n            x/=g;y/=g;\n            w[i]=w[r[i]]*y+w[b[i]]*x;\n          }\n          update=true;\n        }\n      }\n    }\n    ll ans=0;\n    for(int i=1;i<=n;i++)ans=max(w[i],ans);\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define int long long\n\n#define CHOOSE(a) CHOOSE2 a\n#define CHOOSE2(a0,a1,a2,a3,x,...) x\n#define REP1(i, s, cond, cal) for (signed i = signed(s); i cond; i cal)\n#define REP2(i, s, n) REP1(i, s, < signed(n), ++)\n#define REP3(i, n) REP2(i, 0, n)\n#define rep(...) CHOOSE((__VA_ARGS__,REP1,REP2,REP3))(__VA_ARGS__)\n#define rrep(i, s) rep(i, s, >= 0, --)\n\n#define all(c) begin(c), end(c)\ntemplate<typename T>bool maxup(T& a, const T&& b) { if (a < b) { a = b; return true; }; }\ntemplate<typename T>bool maxup(T& a, const T& b) { if (a < b) { a = b; return true; }; }\ntemplate<typename T>bool minup(T& a, const T&& b) { if (a > b) { a = b; return true; }; }\ntemplate<typename T>bool minup(T& a, const T& b) { if (a > b) { a = b; return true; }; }\n\n#define X first\n#define Y second\n\nusing VV = vector<vector<int>>;\nusing V = vector<int>;\nusing P = pair<int, int>;\nusing IP = pair<int, P>;\n\ntemplate<typename T>\ninline void input(vector<T>& v) { for (auto& x : v) cin >> x; }\n\n\nVV g;\nvector<P> len;\n\nint dfs(int now) {\n\tint a = g[now][0] >= 0 ? dfs(g[now][0]) : 1;\n\tint b = g[now][1] >= 0 ? dfs(g[now][1]) : 1;\n\tint p, q;\n\ttie(p, q) = len[now];\n\tint gcd = __gcd(a*p, b*q);\n\tint x = b*q / gcd;\n\tint y = a*p / gcd;\n\treturn a*x + b*y;\n}\n\nsigned main() {\n\tint n;\n\twhile (cin >> n&&n) {\n\t\tg.clear();\n\t\tg.resize(n);\n\t\tlen.clear();\n\t\tlen.resize(n);\n\t\tV root(n, true);\n\t\trep(i, n) {\n\t\t\tint p, q, r, b;\n\t\t\tcin >> p >> q >> r >> b;\n\t\t\tr--; b--;\n\t\t\tint gcd = __gcd(p, q);\n\t\t\tp = p / gcd;\n\t\t\tq = q / gcd;\n\t\t\tif (~r) root[r] = false;\n\t\t\tif (~b) root[b] = false;\n\t\t\tg[i].push_back(r);\n\t\t\tg[i].push_back(b);\n\t\t\tlen[i] = P(p, q);\n\t\t}\n\t\tint idx = find(all(root), true) - root.begin();\n\t\tcout << dfs(idx) << endl;\n\t}\n\n\t//system(\"pause\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <map>\n#include <sstream>\n#include <string>\n#include <cstdio>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cstring>\n#include <tuple>\n#include <utility>\n#include <list>\n#include <cmath>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> Array;\ntypedef pair<int, int> P;\n\nconst int INF = 1 << 29;\nconst LL MOD = 100000;\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define all(c) (c).begin(), (c).end()\n\nstruct edge{ int to, cost; edge(int t, int c) :to(t), cost(c){} };\n\nint dxk[] = { 1, 1, 1, 0, -1, 0 };\nint dxg[] = { 0, 1, 0, -1, -1, -1 };\nint dy[] = { -1, 0, 1, 1, 0, -1 };\n\nstruct node\n{\n\tLL value, lw, rw, left, right;\n};\n\nLL gcd(LL a, LL b)\n{\n\tif (a < b) swap(a, b);\n\treturn a % b == 0 ? b : gcd(b, a % b);\n}\nLL sks(LL a, LL b)\n{\n\tLL g = gcd(a, b);\n\treturn a / g * b;\n}\n\nint main()\n{\n\tint n;\n\twhile (cin >> n && n)\n\t{\n\t\tvector<node> bars(n);\n\t\trep(i, n)\n\t\t{\n\t\t\tint p, q, r, b;\n\t\t\tcin >> p >> q >> r >> b;\n\t\t\tint g = gcd(p, q);\n\t\t\tbars[i].rw = p / g;\n\t\t\tbars[i].lw = q / g;\n\t\t\tbars[i].left = r - 1;\n\t\t\tbars[i].right = b - 1;\n\t\t}\n\n\t\tfunction<LL(int)> dfs = [&](int idx)\n\t\t{\n\t\t\tif (idx == -1) return 1LL;\n\t\t\tnode& node = bars[idx];\n\t\t\tif (node.value != 0) return node.value;\n\n\t\t\tLL r = dfs(node.right), l = dfs(node.left);\n\t\t\t//r*lの最小公倍数を基礎値としてm:nにする\n\t\t\tLL s = sks(r, l);\n\t\t\treturn node.value = s * node.rw + s * node.lw;\n\t\t};\n\n\t\tLL ans = 0;\n\t\trep(i, n) ans = max(dfs(i), ans);\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint n,mem[110][5],sum;\nint F(int n1,int n2)\n{\n    if(n1 == 0)return n2;\n    return F(n2 % n1,n1);\n}\nint min_w(int n_mobile)\n{\n    int n1,n2,lim,longth,s1,s2;\n    if(mem[n_mobile][2] == 0)n1 = 1;\n    else n1 = min_w(mem[n_mobile][2] - 1);\n    if(mem[n_mobile][3] == 0)n2 = 1;\n    else n2 = min_w(mem[n_mobile][3] - 1);\n\n    longth = F(min(mem[n_mobile][0],mem[n_mobile][1]),max(mem[n_mobile][0],mem[n_mobile][1]));\n    //printf(\"%d %d %d\\n\",n_mobile,lim,longth);\n    s1 = n1 / F(n1,mem[n_mobile][0] / longth);s2 = n2 / F(n2,mem[n_mobile][1] / longth);\n    lim = F(min(s1,s2),max(s1,s2));\n    return ((s1 * s2) / lim) * ((mem[n_mobile][0] / longth) + (mem[n_mobile][1] / longth));\n}\nint main()\n{\n    while(scanf(\"%d\",&n),n)\n    {\n        sum = 0;\n        for(int i = 0; i < n; i++)\n        {\n            for(int j = 0; j < 4; j++)\n            {\n                scanf(\"%d\",&mem[i][j]);\n            }\n            sum += mem[i][2] + mem[i][3];\n        }\n        printf(\"%d\\n\",min_w((n * (n + 1)) / 2 - sum - 1));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n \nusing namespace std;\n \n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define rep(i,n) REP(i, 0, n)\n#define pb push_back\n#define mp make_pair\n#define all(r) (r).begin(),(r).end()\n#define rall(r) (r).rbegin(),(r).rend()\n#define fi first\n#define se second\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<double, int> pdi;\ntypedef pair<ll, ll> pll;\n \n\n \nconst int INF = 1000000;\nconst double EPS = 1e-8;\nconst int mod = 1e9 + 7;\nconst ll LINF = 1e18;\nconst double PI = acos(-1);\n\nstruct Input\n{\n\tint n;\n\tchar c;\n\tchar str[1024];\n\tstring s;\n\tll l;\n\tint nextInt(){\n\t\tscanf(\"%d\", &n);\n\t\treturn n;\n\t}\n\tll nextLong(){\n\t\tscanf(\"%lld\", &l);\n\t\treturn l;\n\t}\n\tchar nextChar(){\n\t\tscanf(\"%c\", &c);\n\t\treturn c;\n\t}\n\tstring next(){\n\t\tscanf(\"%s\", str);\n\t\treturn string(str);\n\t}\n\tstring nextLine(){\n\t\tgetline(cin, s);\n\t\treturn s;\n\t}\n};\nInput in;\n\nll gcd(ll a, ll b){\n\treturn b == 0 ? a : gcd(b, a % b);\n}\n\nll lcm(ll a, ll b){\n\treturn a / gcd(a, b) * b;\n}\nvi p, q, r, b;\n\nvl d;\n\nll calc(int n){\n\tif(d[n]>0) return d[n];\n\tll l = 1ll, h = 1ll, ret;\n\n\tif(r[n] >= 0) l = calc(r[n]);\n\tif(b[n] >= 0) h = calc(b[n]);\n\n\tret = lcm(p[n] * l, q[n] * h) / p[n] + lcm(p[n] * l, q[n] * h) / q[n];\n\n\treturn d[n] = ret;\n}\n\nint main(){\n\twhile(1){\n\t\tint n = in.nextInt();\n\t\tif(n == 0) return 0;\n\t\tp.resize(n);\n\t\tq.resize(n);\n\t\tr.resize(n);\n\t\tb.resize(n);\n\t\td = vl(n, 0LL);\n\n\t\trep(i, n){\n\t\t\tp[i] = in.nextInt();\n\t\t\tq[i] = in.nextInt();\n\t\t\tr[i] = in.nextInt() - 1;\n\t\t\tb[i] = in.nextInt() - 1;\n\t\t}\n\t\tll ans = 0LL;\n\t\trep(i, n){\n\t\t\tans = max(ans, calc(i));\n\t\t}\n\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n \n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n \n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n \n \nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n \nstruct E{\n  int l, r;\n  LL ld, rd, w;\n \n  E(){}\n  E(int l, int r, LL ld, LL rd) :\n\tl(l), r(r), ld(ld), rd(rd), w(0)\n  {\n  }\n};\n \nLL gcd(LL x, LL y){\n  return (y==0? x: gcd(y, x%y));\n}\nLL lcm(LL x, LL y){\n  return x / gcd(x, y) * y;\n}\n \nvoid dfs(vector<E>& G, int u){\n  if(G[u].l != -1) dfs(G, G[u].l);\n  if(G[u].r != -1) dfs(G, G[u].r);\n \n  LL wl = (G[u].l == -1? 1: G[G[u].l].w);\n  LL wr = (G[u].r == -1? 1: G[G[u].r].w);\n  LL lm = lcm(G[u].ld * wl, G[u].rd * wr);\n  G[u].w = lm / G[u].ld + lm / G[u].rd;\n}\n \nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n \n  int N;\nwhile(\n  cin >> N,N){\n  vector<E> G;\n  REP(i,N){\n\tint c, d;\n\tLL a, b;\n\tcin >> a >> b >> c >> d;\n\tLL g = gcd(a, b);\n\t--c;\n\t--d;\n\tG.EB(c,d,a/g,b/g);\n  }\n \n  vector<bool> used(N);\n  REP(i,N){\n\tif(G[i].l != -1) used[G[i].l] = true;\n\tif(G[i].r != -1) used[G[i].r] = true;\n  }\n  int rt = -1;\n  REP(i,N) if(!used[i]) rt = i;\n \n  dfs(G, rt);\n  cout << G[rt].w << endl;\n }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\ntypedef long long ll;\n\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){return a/gcd(a,b)*b;}\n\nint main(){\n  int n;\n  ll par[100],left[100],right[100],p[100],q[100],r[100],b[100];\n  bool use[100];\n\n  while(cin >> n && n){\n    for(int i=0;i<n;i++)par[i] = -1;\n    for(int i=0;i<n;i++){\n      cin >> p[i] >> q[i] >> r[i] >> b[i];\n      ll tmp = gcd(p[i],q[i]);\n      p[i]/=tmp;\n      q[i]/=tmp;\n      if(r[i]){\n\tleft[i] = 0;\n\tpar[r[i]-1] = i;\n      }else left[i] = 1;\n      if(b[i]){\n\tright[i] = 0;\n\tpar[b[i]-1] = i;\n      }else right[i] = 1;\n      use[i] = false;\n    }\n\n    bool f = true;\n    ll ans;\n    while(f){\n      for(int i=0;i<n;i++){\n\tif(!use[i] && left[i] && right[i]){\n\t  ll tmp = lcm(right[i],left[i]);\n\t  right[i] = tmp*p[i];\n\t  left[i] = tmp*q[i];\n\t  ans = right[i] + left[i];\n\t  if(0<=par[i]){\n\t    if(r[par[i]]==i+1)left[par[i]] = ans;\n\t    else right[par[i]] = ans;\n\t  }else{\n\t    cout << ans << endl;\n\t    f = false;\n\t    break;\n\t  }\n\t  use[i] = true;\n\t}\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint x[100][2],w[100][2],n;\nbool cal[110];\nint COU(int a,int b){\n\twhile(true){\n\t\tif(a<2||b<2)return 1;\n\t\tif(a<b){int t=a;a=b,b=t;}\n\t\ta%=b;\n\t\tif(!a)return b;\n\t}\n}\nlong long DFS(int q){\n\tif(!q)return 1;\n\tq--;\n\tlong long a=DFS(w[q][0]),b=DFS(w[q][1]);\n\treturn (a*b*(x[q][0]+x[q][1]))/COU(a*x[q][0],b*x[q][1]);\n}\nint main(){\n\twhile(true){\n\t\tcin>>n;\n\t\tif(!n)break;\n\t\tfor(int i=0;i<n;i++)cal[i]=false;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>x[i][0]>>x[i][1]>>w[i][0]>>w[i][1];\n\t\t\tcal[w[i][0]-1]=true,cal[w[i][1]-1]=true;\n\t\t}\n\t\tfor(int i=0;i<n;i++)if(!cal[i])cout<<DFS(i+1)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "require 'rational'\n\nclass AOJ0520\n  def initialize(n)\n    @n = n\n    @poles = []\n  end\n\n  def solve\n    @n.times{ @poles << gets.split.map(&:to_i) }\n\n    top = ((1..@n).to_a - @poles.map{ |p| [p[2], p[3]] }.flatten)[0]\n\n    weight(top-1)\n  end\n\n  def weight(id)\n    r = (@poles[id][2] == 0 ? 1 : weight(@poles[id][2]-1))\n    l = (@poles[id][3] == 0 ? 1 : weight(@poles[id][3]-1))\n\n    p = @poles[id][0]\n    q = @poles[id][1]\n\n    a = (r*p).lcm(l*q) / q\n    b = (r*p).lcm(l*q) / p\n\n    a+b\n  end\nend\n\nwhile (n = gets.chomp.to_i) != 0\n  puts AOJ0520.new(n).solve\nend"
  },
  {
    "language": "C++",
    "code": "//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0520\n#include <iostream>\n#include <vector>\nusing namespace std;\n#define ll long long\ninline ll gcd(ll a, ll b) { if (b > a)swap(a, b); return b ? gcd(b, a%b) : a; }\ninline ll lcm(ll a, ll b) { return a / gcd(a, b)*b; }\n\nstruct mobile {\n\tll lb, rb, ln, rn;\n\tmobile() {}\n\tmobile(ll lb, ll rb, ll ln, ll rn) :lb(lb), rb(rb), ln(ln), rn(rn) {}\n\tmobile& operator=(const mobile& o) {\n\t\tthis->lb = o.lb;\n\t\tthis->rb = o.rb;\n\t\tthis->ln = o.ln;\n\t\tthis->rn = o.rn;\n\t\treturn *this;\n\t}\n};\n\nll dfs_mobile(int n,vector<mobile>& Mobile) {\n\tif (n == 0) return 1;\n\n\tll lM = dfs_mobile(Mobile[n].ln, Mobile);\n\tll rM = dfs_mobile(Mobile[n].rn, Mobile);\n\n\tll LCM = lcm(lM*Mobile[n].lb, rM*Mobile[n].rb);\n\treturn LCM / Mobile[n].lb + LCM / Mobile[n].rb;\n}\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\twhile (true) {\n\t\tint n; cin >> n;\n\t\tif (n == 0) break;\n\t\tvector<ll> rev(n + 1, -1);\n\t\tvector<mobile> Mobile(n + 1);\n\n\t\t/* initialize */\n\t\tfor (int i = 1; i <= n;i++) {\n\t\t\tll lb, rb, ln, rn; cin >> lb >> rb >> rn >> ln;\n\t\t\tll GCD = gcd(lb, rb);\n\t\t\tlb /= GCD; rb /= GCD;\n\t\t\tMobile[i] = mobile(lb, rb, ln, rn);\n\t\t\tif (ln != 0) rev[ln] = i;\n\t\t\tif (rn != 0) rev[rn] = i;\n\t\t}\n\n\t\t/*????????¢?´¢*/\n\t\tll root = 1;\n\t\twhile (rev[root] != -1) root = rev[root];\n\n\t\tcout << dfs_mobile(root,Mobile) << endl;\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#pragma warning(disable: 4996)\n#include<cstdio>\n#include<math.h>\n#include<algorithm>\n#include<string.h>\n#include<vector>\n#include<queue>\n#include<vector>\n\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\nconst int INF=1001001001;\n\nconst int mod=100000;\n\n#define MAX_N 100\nint N;\npair<int,int> pq[MAX_N];\nint rod[MAX_N][2];\nvector<int> edge[MAX_N];\nint redge[MAX_N][2];\npriority_queue<pair<int,int> > dist;//second ??????top??????????????¢???first\nbool iftop[MAX_N];//top??????false\n\nint gcd(int a, int b){\n\tif(b==0) return a;\n\treturn gcd(b,a%b);\n}\n\nint main(){\n\twhile(1){\n\t\tscanf(\"%d\",&N);\n\t\tif(N==0)break;\n\t\tmemset(redge,-1,sizeof(redge));\n\t\tmemset(iftop,false,sizeof(iftop));\n\t\trep(i,N){\n\t\t\tint p,q,r,b;\n\t\t\tscanf(\"%d %d %d %d\",&p,&q,&r,&b);\n\t\t\tpq[i]= make_pair(p,q);\n\t\t\tif(r>0){iftop[r-1]=true;edge[i].push_back(r-1);redge[r-1][0]=i;}\n\t\t\tif(b>0){iftop[b-1]=true;edge[i].push_back(b-1);redge[b-1][1]=i;}\n\n\t\t}\n\t\tint top=find(iftop,iftop+N,false)-iftop;\n\t\tqueue<int> q1;q1.push(top);\n\t\tint dister=0;\n\t\twhile(q1.size()){\n\t\t\tqueue<int> q2;\n\t\t\twhile(q1.size()){\n\t\t\t\tint a=q1.front();q1.pop();\n\t\t\t\tdist.push(make_pair(dister,a) );\n\t\t\t\trep(i,edge[a].size()){\n\t\t\t\t\tq2.push(edge[a][i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tq1=q2;dister++;\n\t\t}\n\n\t\tint ans=0;\n\t\twhile(dist.size()){\n\t\t\tpair<int,int> a=dist.top();dist.pop();\n\t\t\tint n=a.second;\n\t\t\tint gc=gcd(pq[n].first,pq[n].second);\n\t\t\tint p=pq[n].first/gc;int q= pq[n].second/gc;\n\t\t\tint sans=0;\n\t\t\tif(rod[n][0]==0&&rod[n][1]==0){\n\t\t\t\tsans=p+q;\n\t\t\t}else{\n\t\t\t\tif(rod[n][0]==0)rod[n][0]=1;if(rod[n][1]==0)rod[n][1]=1;\n\t\t\t\tint power=(rod[n][0]*p)*(rod[n][1]*q)/gcd( (rod[n][0]*p),(rod[n][1]*q) );\n\t\t\t\tsans=power/p+power/q;\n\t\t\t}\n\t\t\trep(i,2)if(redge[n][i]>-1){\n\t\t\t\t\trod[redge[n][i]][i]+=sans;\n\t\t\t\t}\n\t\t\tif(!dist.size()){\n\t\t\t\tans=sans;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<list>\n#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nlong long gcd(long long p,long long q){\n  while(q){\n    p%=q;\n    swap(p,q);\n  }\n  return p;\n}\nlong long f(long long a[],long long b[],long long c[],long long d[],long long p){\n  if(p==0)\n    return 1;\n  return f(a,b,c,d,c[p])*b[p]*f(a,b,c,d,d[p])/gcd(a[p]*f(a,b,c,d,c[p]),b[p]*f(a,b,c,d,d[p]))+a[p]*f(a,b,c,d,c[p])*f(a,b,c,d,d[p])/gcd(a[p]*f(a,b,c,d,c[p]),b[p]*f(a,b,c,d,d[p]));\n  return 0;\n}\nint main(){\n  int i;\n  long long a[101],b[101],c[101],d[101],e[101],n;\n  while(cin>>n&&n){\n    memset(e,0,sizeof(e));\n    for(i=1;i<n+1;i++){\n      cin>>a[i]>>b[i]>>c[i]>>d[i];\n      e[c[i]]=1;\n      e[d[i]]=1;\n    }\n    for(i=0;e[i];i++);\n    cout<<f(a,b,c,d,i)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nll gcd(ll a, ll b) {\n  return b != 0 ? gcd(b, a % b) : a;\n}\n\nconst ll WEIGHT=-1;\nstruct stick{\n\tll r,b,p,q;\n\tstick(ll r,ll b,ll p,ll q):r(r),b(b){\n\t\tll g=gcd(p,q);\n\t\tthis->p=p/g;\n\t\tthis->q=q/g;\n\t}\n\tll getroot(ll index,vector<stick> &sticks){\n\t\tREP(i,sticks.size()){\n\t\t\tif(sticks[i].r==index||sticks[i].b==index){\n\t\t\t\treturn sticks[i].getroot(i,sticks);\n\t\t\t}\n\t\t}\n\t\treturn index;\n\t}\n\tll go(vector<stick> &sticks){\n\t\tll rw=0,bw=0;\n\t\tif(r!=WEIGHT){\n\t\t\trw=sticks[r].go(sticks);\n\t\t}\n\t\tif(b!=WEIGHT){\n\t\t\tbw=sticks[b].go(sticks);\n\t\t}\n\t\tif(r==WEIGHT&&b==WEIGHT){\n\t\t\trw=q;\n\t\t\tbw=p;\n\t\t}else if(r==WEIGHT){\n\t\t\tif(p*bw%q){\n\t\t\t\trw=bw*p;\n\t\t\t\tbw*=q;\n\t\t\t}else{\n\t\t\t\trw=bw*p/q;\n\t\t\t}\n\t\t}else if(b==WEIGHT){\n\t\t\tif(q*rw%p){\n\t\t\t\tbw=rw*q;\n\t\t\t\trw*=p;\n\t\t\t}else{\n\t\t\t\tbw=rw*q/p;\n\t\t\t}\n\t\t}else{\n\t\t\tll trw=rw,tbw=bw;\n\t\t\tll gr=gcd(rw,q);\n\t\t\tll gb=gcd(bw,p);\n\t\t\trw=trw*tbw*q/gr;\n\t\t\tbw=tbw*trw*p/gb;\n\t\t}\n\t\tassert(rw&&bw);\n\t\treturn rw+bw;\n\t}\n};\n\n\nint main(){\n\tll n;\n\twhile(cin>>n,n){\n\t\tvector<stick> sticks;\n\t\tREP(i,n){\n\t\t\tll p,q,r,b;\n\t\t\tcin>>p>>q>>r>>b;\n\t\t\tr--;b--;\n\t\t\tsticks.push_back(stick(r,b,p,q));\n\t\t}\n\t\tll root=sticks[0].getroot(0,sticks);\n\t\tcout<<sticks[root].go(sticks)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n\n#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n\nusing ll = long long int;\n\nll gcd(ll a_, ll b_)\n{\n\tif (b_ == 0)return a_;\n\treturn gcd(b_, a_% b_);\n}\n\nconst ll MAX_N = 100;\nll memo[MAX_N + 1];\nll p[MAX_N + 1], q[MAX_N + 1];\nll r[MAX_N + 1], b[MAX_N + 1];\nll n;\nll dp(int x_)\n{\n\tif (memo[x_] > 0)return memo[x_];\n\tdp(r[x_]); dp(b[x_]);\n\tll a_ = memo[r[x_]]; ll b_ = memo[b[x_]];\n\tll c_ = p[x_] / gcd(p[x_], q[x_]);\n\tll d_ = q[x_] / gcd(p[x_], q[x_]);\n\treturn memo[x_] = a_ * b_ * (c_ + d_) / gcd(a_*c_, b_*d_);\n}\n\nint main()\n{\n\tfor (;;)\n\t{\n\t\tscanf(\"%lld\",&n);\n\t\tif (n == 0)break;\n\t\tfor (int i = 1; i <= n; ++i)scanf(\"%lld %lld %lld %lld\",p + i,q + i,r + i,b + i);\n\t\tmemset(memo, 0, sizeof(memo));\n\t\tmemo[0] = 1;\n\t\tll ans = 0;\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t{\n\t\t\tans = std::max(dp(i),ans);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n//#include<fstream>\n#include<string>\nusing namespace std;\n\nstruct tBar{\n\tunsigned int rdis, bdis, r, b;\n\tunsigned int w;\n};\ntBar bar[101];\nint N;\n\nunsigned int euclid( int a, int b ){\n\twhile( a != b ){\n\t\tif( a>b )\ta -= b;\n\t\telse\t\tb -= a;\n\t}\n\treturn a;\n}\n\nunsigned int calcWeight( int n ){\n\ttBar &bn = bar[n];\n\tunsigned int rw=0, bw=0;\n\tif( bn.r==0 && bn.b==0 ){\n\t\trw = bn.bdis;\n\t\tbw = bn.rdis;\n\t}else if( bn.r!=0 && bn.b==0 ){\n\t\t\trw = calcWeight( bn.r );\n\t\t\tbw = bn.rdis * rw / bn.bdis;\n\t}else if( bn.r==0 && bn.b!=0 ){\n\t\t\tbw = calcWeight( bn.b );\n\t}else{\n\t\trw = calcWeight( bn.r );\n\t\tbw = calcWeight( bn.b );\n\t}\n\t\n\twhile( rw*bn.rdis != bw*bn.bdis ){\n\t\tif( rw*bn.rdis > bw*bn.bdis ){\n\t\t\tbw += bn.b==0 ? bn.rdis : bar[bn.b].w;\n\t\t}else{\n\t\t\trw += bn.r==0 ? bn.bdis : bar[bn.r].w;\n\t\t}\n\t}\n\tbn.w = rw+bw;\n\treturn bn.w;\n}\n\nint findRoot( int n ){\n\tfor( int i=1; i<=N; i++ ){\n\t\tif( bar[i].r==n || bar[i].b==n ){\n\t\t\tn = i;\n\t\t\ti = 0;\n\t\t}\n\t}\n\treturn n;\n}\n\nint main(){\n\tint n;\n\tstring str;\n//\tifstream in(\"input.txt\");\n//\tofstream out(\"output.txt\");\n\twhile(1){\n\t\tgetline( cin, str );\n\t\tsscanf( str.c_str(), \"%d\", &n );\n\t\tif( n == 0 )\tbreak;\n\t\tN = n;\n\t\tfor( int i=1; i<=n; i++ ){\n\t\t\tgetline( cin, str );\n\t\t\tint p,q,r,b;\n\t\t\tsscanf(str.c_str(), \"%d %d %d %d\", &p, &q, &r, &b);\n\t\t\tint e = euclid( p, q );\n\t\t\tbar[i].rdis = p / e;\n\t\t\tbar[i].bdis = q / e;\n\t\t\tbar[i].r = r;\n\t\t\tbar[i].b = b;\n\t\t\tbar[i].w = 0;\n\t\t}\n\t\tint root = findRoot(1);\n\t\tint sum = calcWeight(root);\n//\t\tout << sum << endl;\n\t\tcout << sum << endl;\n\t}\n//\tin.close();\n//\tout.close();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <climits>\n#include <vector>\nusing namespace std;\n\nlong long gcd(long long x, long long y) {\n    while(y) {\n        long long t=x%y;x=y;y=t;\n    }\n    return x;\n}\n\nint rs[100],bs[100];\nlong long ps[100],qs[100], memo[100];\nbool changed;\n\nlong long calc(int i) {\n    if(i==-1) return 1;\n    if(memo[i]>=0) return memo[i];\n    changed = true;\n    long long r = calc(rs[i]);\n    long long b = calc(bs[i]);\n    long long p = ps[i];\n    long long q = qs[i];\n    long long left_factor = r*q; // b*left_factor\n    long long right_factor = b*p; // r*right_factor\n    long long fgcd = gcd(left_factor, right_factor);\n    left_factor /= fgcd;\n    right_factor /= fgcd;\n    memo[i] = b*left_factor + r*right_factor;\n    return memo[i];\n}\n\nint main() {\n    while(true) {\n        int n; scanf(\"%d\", &n);\n        if(n==0) break;\n        fill(memo, memo+n, -1);\n        for(int i = 0; i < n; i++) {\n            scanf(\"%lld%lld%d%d\", ps+i, qs+i, rs+i, bs+i);\n            rs[i]--; bs[i]--;\n        }\n        long long max_val = 0;\n        for(int i = 0; i < n; i++) {\n            changed = false;\n            long long val = calc(i);\n            if(changed) max_val = val;\n        }\n        printf(\"%lld\\n\", max_val);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nlong long gcd(long long a, long long b){ // Ååöñ\n    if(a == 0 || b == 0)\n        return 0;\n    if(b > a)\n        swap(a, b);\n    long long tmp;\n    while((tmp = a % b) != 0){\n        a = b;\n        b = tmp;\n    }\n    return b;\n}\n\nlong long lcm(long long a, long long b){ // Å¬ö{\n    return a / gcd(a, b) * b;\n}\n\nint solve(vector<vector<int> >& stick, int i)\n{\n    if(i == 0)\n        return 1;\n\n    int p = stick[i][0];\n    int q = stick[i][1];\n    int tmp = gcd(p, q);\n    p /= tmp;\n    q /= tmp;\n\n    int a = solve(stick, stick[i][2]);\n    int b = solve(stick, stick[i][3]);\n    tmp = lcm(q*a, p*b);\n    a = tmp / q;\n    b = tmp / p;\n\n    return a + b;\n}\n\nint main()\n{\n    for(;;){\n        int n;\n        cin >> n;\n        if(n == 0)\n            return 0;\n\n        vector<vector<int> > stick(n+1, vector<int>(4));\n        vector<bool> check(n+1, false);\n        for(int i=1; i<=n; ++i){\n            for(int j=0; j<4; ++j){\n                cin >> stick[i][j];\n            }\n            check[stick[i][2]] = check[stick[i][3]] = true;\n        }\n\n        int ret = 0;\n        for(int i=1; i<=n; ++i){\n            if(!check[i])\n                ret += solve(stick, i);\n        }\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <iomanip>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> P;\n\nint p[101]={};\nint q[101]={};\nint r[101]={};\nint s[101]={};\nint gcd(int a, int b){\n\twhile(b){\n\t\tint r=a%b;\n\t\ta=b;\n\t\tb=r;\n\t}\n\treturn a;\n}\nint cal(int i){\n\tif(i==0){\n\t\treturn 1;\n\t}\n\tint a=cal(r[i]);\n\tint b=cal(s[i]);\n\tint g=gcd(a*p[i],b*q[i]);\n\tint v=a*p[i]/g*b+b*q[i]/g*a;\n\t//cout << i << \", \" << v << endl;\n\treturn v;\n}\nint main() {\nwhile(1){\n\tint n;\n\tcin >> n;\n\tif(n==0)return 0;\n\tint hasParent[101]={};\n\tfor(int i=1;i<=n;i++){\n\t\tcin >> p[i] >> q[i] >> r[i] >> s[i];\n\t\thasParent[r[i]]=true;\n\t\thasParent[s[i]]=true;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tif(!hasParent[i]){\n\t\t\tcout << cal(i) << endl;\n\t\t}\n\t}\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint GCD(int a,int b){\n    if(b>a)swap(a,b);\n    return (b==0)?a:GCD(b,a%b);\n}\nint LCM(int a,int b){\n    return a*b/GCD(a,b);\n}\nint l[101],r[101],w1[101],w2[101];\nint dfs(int x){\n    if(x==0)return 1;\n    int red=l[x]*dfs(w1[x]);\n    int blue=r[x]*dfs(w2[x]);\n    int lcm=LCM(red,blue);\n    return memo[x]=lcm/l[x]+lcm/r[x];\n}\nint main(){\n    int n;\n    while(scanf(\"%d\",&n),n){\n        bool flag[N+1];fill(flag,flag+n+1,true);\n        for(int i=1;i<=n;i++){\n            scanf(\"%d%d%d%d\",&l[i],&r[i],&w1[i],&w2[i]);\n            flag[w1[i]]=flag[w2[i]]=false;\n        }\n        for(int i=1;i<=n;i++){\n            if(flag[i]){\n                printf(\"%d\\n\",dfs(i));\n                break;\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\nstruct node{ll lv,rv,lc,rc;};\n#define MAX_N 101\nll gcd(ll x,ll y){return __gcd(x,y);}\nll lcm(ll x,ll y){return x/gcd(x,y)*y;}\n\nint n;\nnode g[MAX_N];\nint t[MAX_N];\n\nll rec(int pos){\n  if(pos==0)return 1;\n  node m=g[pos];\n  ll a=rec(m.lc);\n  ll b=rec(m.rc);\n  ll c=gcd(a*m.lv,b*m.rv);\n  return a*(b*m.rv/c)+b*(a*m.lv/c);\n}\n\nvoid solve(){\n  int root;\n  for(root=1;t[root]>0;root++);\n  cout<<rec(root)<<endl;\n}\n\nvoid init(){\n  for(int i=0;i<MAX_N;i++)t[i]=0;\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    init(); \n    for(int i=1;i<=n;i++){\n      ll p,q,r,b,x;\n      cin>>p>>q>>r>>b;\n      x=gcd(p,q);\n      p/=x,q/=x;\n      g[i]=(node){p,q,r,b};\n      t[r]=t[b]=i;\n    }\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0520>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\n\ninline ll gcd(ll a, ll b) { return b ? gcd(b, a%b) : a; }\ninline ll lcm(ll a, ll b) { return a / gcd(a, b)*b; }\n\nll rec(ll n,vector<ll>& p,vector<ll>& q,vector<ll>& r,vector<ll>& b){\n    ll ret = 0;\n    \n    ll sumr = (r[n] == 0?1:rec(r[n],p,q,r,b));\n    ll sumb = (b[n] == 0?1:rec(b[n],p,q,r,b));\n    ll Tr = sumr*p[n];\n    ll Tb = sumb*q[n];\n    ll LCM = lcm(Tr,Tb);\n    ret = sumr*(LCM/Tr) + sumb*(LCM/Tb);\n    return ret;\n}\nll solve(ll n){\n    ll res = 0;\n    vector<ll> p(n+1),q(n+1),r(n+1),b(n+1);\n    for(int i = 1; i <= n;i++){\n        cin >> p[i] >> q[i] >> r[i] >> b[i];\n        ll GCD = gcd(p[i],q[i]);\n        p[i] /= GCD;\n        q[i] /= GCD;\n    }\n    vector<vector<ll>> G(n+1);\n    for(int i = 1; i <= n;i++){\n        if(r[i] != 0) G[r[i]].push_back(i);\n        if(b[i] != 0) G[b[i]].push_back(i);\n    }\n    ll root = -1;\n    for(int i = 1; i <= n;i++){\n        if(G[i].empty()) root = i;\n    }\n    res = rec(root,p,q,r,b);\n    return res;\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    ll n;\n    while(cin >> n,n){\n        cout << solve(n) << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//Bokan ga bokka--nn!!\n//Daily Lunch Special Tanoshii !!\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\ntypedef long long ll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 2000000000\n#define s(x) scanf(\"%d\",&x)\n#define rep(i,x) for(int i=0;i<x;i++)\nint dp[105];\nint m[105]={};\nint u[105][2]={};\nint v[105][2]={};\nint a[105]={};\nint gcd(int a,int b)\n{\n\tif(a%b==0) return b;\n\treturn gcd(b,a%b);\n}\nint main()\n{\n\t\n\twhile(1)\n\t{\n\t\tint n;\n\t\tscanf(\"%d\",&n);\n\t\tif(!n) return 0;\n\t\tqueue<int>que;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tint aa,b,c,d;\n\t\t\tscanf(\"%d %d %d %d\",&aa,&b,&c,&d);\n\t\t\tu[i][0]=c;\n\t\t\tu[i][1]=d;\n\t\t\tif(c)a[i]++;\n\t\t\tif(d)a[i]++;\n\t\t\tint di=gcd(aa,b);\n\t\t\tv[i][0]=aa/di;\n\t\t\tv[i][1]=b/di;\n\t\t\tif(!a[i]) que.push(i);\n\t\t}\n\t\tfill(dp,dp+105,1);\n\t\tint ret;\n\t\twhile(!que.empty())\n\t\t{\n\t\t\tint r=que.front(); que.pop();\n\t\t\tint bas=1;\n\t\t\tfor(int i=0;i<2;i++)\n\t\t\t{\n\t\t\t\tif(u[r][i])\n\t\t\t\t{\n\t\t\t\t\tint f=dp[u[r][i]]/gcd(dp[u[r][i]],v[r][1-i]);\n\t\t\t\t\tbas=bas/gcd(bas,f)*f;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[r]=bas*(v[r][0]+v[r][1]); ret=dp[r];\n\t\t\tfor(int i=1;i<=n;i++)\n\t\t\t{\n\t\t\t\tif(u[i][0]==r || u[i][1]==r)\n\t\t\t\t{\n\t\t\t\t\ta[i]--;\n\t\t\t\t\tif(!a[i]) que.push(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint gcd(int a, int b)\n{\n\tif(a < b)\n\t\tswap(a, b);\n\t\t\n\tif(b == 0)\n\t\treturn a;\n\t\t\n\treturn gcd(b, a % b);\n}\n\nint lcm(int a, int b)\n{\n\tint div = gcd(a, b);\n\t\n\treturn a / div * b;\n}\n\nstruct mobile {\n\n\tint p, q, r, b;\n\tmobile() {}\n\tmobile(int p, int q, int r, int b) : p(p), q(q), r(r), b(b) {}\n};\n\nint calc(int k, vector<mobile> &m) {\n\n\tif(k == -1)\n\t\treturn 1;\n\n\tmobile x = m[k];\n\t\n\tint lw, rw;\n\t\n\tlw = calc(x.r - 1, m);\n\trw = calc(x.b - 1, m);\n\t\n\tint div = gcd(x.p, x.q);\n\tx.p = x.p / div;\n\tx.q = x.q / div;\n\t\n\t//x.p * lw * a = x.q * rw * b\n\tint sum = lcm(x.p * lw, x.q * rw);\n\tint ans = sum / x.p + sum / x.q;\n\t\n\t//printf(\"[debug] %d -> %d\\n\", k, ans);\n\t\n\treturn ans;\n}\n\nint main()\n{\n\twhile(true) {\n\t\n\t\tint n;\n\t\t\n\t\tscanf(\"%d\", &n);\n\t\tif(n == 0)\n\t\t\tbreak;\n\t\t\t\n\t\tvector<mobile> m;\n\t\t\n\t\tm.resize(n);\n\t\t\n\t\tfor(int i = 0; i < n; ++i)\n\t\t\tscanf(\"%d%d%d%d\", &m[i].p, &m[i].q, &m[i].r, &m[i].b);\n\t\t\n\t\tbool middle[128] = {false};\n\t\tint top = -1;\n\t\t\n\t\tfor(int i = 0; i < n; ++i)\n\t\t\tmiddle[m[i].r] = middle[m[i].b] = true;\n\t\tmiddle[0] = true;\n\t\tfor(int i = 0; i <= n; ++i) {\n\t\t\tif(!middle[i]) {\n\t\t\t\ttop = i - 1;\n\t\t\t\tbreak;\n\t\t\t}\t\n\t\t}\n\t\t\n\t\tint ans = calc(top, m);\n\t\t\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nint gcd(int a, int b) {\n\tif (a % b == 0)return b;\n\treturn gcd(b, a % b);\n}\n\nint lcm(int a, int b) {\n\treturn a / gcd(a, b) * b;\n}\n\nstruct Mobile {\n\tint l, r, left, right, parent;\n};\n\nint n;\nMobile m[100];\n\nint solve(int x) {\n\tint Left, Right;\n\tif (m[x].left == 0)Left = 1;\n\telse Left = solve(m[x].left - 1);\n\tif (m[x].right == 0)Right = 1;\n\telse Right = solve(m[x].right - 1);\n\treturn lcm(Left * m[x].r, Right * m[x].l) / m[x].r + lcm(Left * m[x].r, Right * m[x].l) / m[x].l;\n}\n\nint main() {\n\twhile (cin >> n, n) {\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tm[i].l = 0, m[i].r = 0, m[i].left = 0, m[i].right = 0;\n\t\t\tm[i].parent = -1;\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> m[i].l >> m[i].r >> m[i].left >> m[i].right;\n\t\t\tif (m[i].left != 0)m[m[i].left - 1].parent = i;\n\t\t\tif (m[i].right != 0)m[m[i].right - 1].parent = i;\n\t\t\t{\n\t\t\t\tint l = m[i].l, r = m[i].r;\n\t\t\t\tm[i].l = m[i].l / gcd(l, r), m[i].r = m[i].r / gcd(l, r);\n\t\t\t}\n\t\t}\n\t\tint x = 0;\n\t\twhile (1) {\n\t\t\tif (m[x].parent == -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tx = m[x].parent;\n\t\t}\n\t\tcout << solve(x) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint x[100][2],w[100][2],n;\nbool cal[100];\nint COU(int a,int b){\n while(true){\n  if(a<2||b<2)return 1;\n  if(a<b){int t=a;a=b,b=t;}\n  a%=b;\n  if(!a)return b;\n }\n}\nint DFS(int q){\n    if(!q)return 1;\n    q--;\n    int a=DFS(w[q][0]),b=DFS(w[q][1]);\n    return (a*b*(x[q][0]+x[q][1]))/COU(a*x[q][0],b*x[q][1]);\n}\nint main(){\n while(true){\n cin>>n;\n if(!n)break;\n for(int i=0;i<n;i++)cal[i]=false;\n for(int i=0;i<n;i++){\n  cin>>x[i][0]>>x[i][1]>>w[i][0]>>w[i][1];\n  cal[w[i][0]-1]=true,cal[w[i][1]-1]=true;\n }\n for(int i=0;i<n;i++){\n  if(!cal[i])cout<<DFS(i+1)<<endl;\n }\n }\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nint red[100];\nint blue[100];\nint le[100];\nint ri[100];\n\nint gcd(int a,int b){\n\tif(b>a){\ta^=b;\tb^=a;\ta^=b;\t}\n\twhile(1){\n\t\tint temp=a%b;\n\t\tif(temp==0)\tbreak;\n\t\ta=b;\tb=temp;\n\t}\n\treturn b;\n}\n\nint dfs(int now){\n\tint l=1,r=1;\n\tif(le[now]!=0)\tl*=dfs(le[now]-1);\n\tif(ri[now]!=0)\tr*=dfs(ri[now]-1);\n\tint g=gcd(blue[now]*r,red[now]*l);\n\tint ans=blue[now]*r*red[now]*l/g;\n\treturn ans/blue[now]+ans/red[now];\t\n}\n\t\nint main(){\n\twhile(true){\n\t\tcin>>n;\n\t\tif(n==0)\treturn 0;\n\t\tvector<int> parent(n,-1);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>red[i]>>blue[i]>>le[i]>>ri[i];\n\t\t\tif(le[i]!=0)\tparent[le[i]-1]=i;\t\n\t\t\tif(ri[i]!=0)\tparent[ri[i]-1]=i;\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(parent[i]==-1){\n\t\t\t\tcout<<dfs(i)<<endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nint red[100];\nint blue[100];\nint le[100];\nint ri[100];\n\nint gcd(int a,int b){\n\tif(b>a){\ta^=b;\tb^=a;\ta^=b;\t}\n\twhile(1){\n\t\tint temp=a%b;\n\t\tif(temp==0)\tbreak;\n\t\ta=b;\tb=temp;\n\t}\n\treturn b;\n}\n\nint dfs(int now){\n\tint g=gcd(blue[now],red[now]);\tblue[now]/=g;\tred[now]/=g;\n\tint l=blue[now],r=red[now];\n\tif(le[now]!=0)\tl*=dfs(le[now]-1);\n\tif(ri[now]!=0)\tr*=dfs(ri[now]-1);\n\tif(l*red[now]<r*blue[now])\tl*=r/gcd(l,r)*blue[now]/red[now];\n\tif(l*red[now]>r*blue[now])\tr*=l/gcd(l,r)*red[now]/blue[now];\n\treturn l+r;\n}\n\t\nint main(){\n\tcin>>n;\n\tvector<int> parent(n,-1);\n\tfor(int i=0;i<n;i++){\n\t\tcin>>red[i]>>blue[i]>>le[i]>>ri[i];\n\t\tif(le[i]!=0)\tparent[le[i]-1]=i;\t\n\t\tif(ri[i]!=0)\tparent[ri[i]-1]=i;\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tif(parent[i]==-1){\n\t\t\tcout<<dfs(i);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n\nusing namespace std;\n\nstruct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nstruct tree {\n  ll p = -1, q = -1, r = -1, b = -1;\n  tree() = default;\n  tree(int p, int q, int r, int b) : p(p), q(q), r(r), b(b) {}\n};\n\ntree t[111];\n\nll dfs(int idx) {\n  ll left = 0, right = 0;\n  left  = (t[idx].r ? dfs(t[idx].r - 1) : 1) * t[idx].p;\n  right = (t[idx].b ? dfs(t[idx].b - 1) : 1) * t[idx].q;\n  ll k = left * right  / __gcd(left, right) / t[idx].p;\n  ll l = left * right / __gcd(left, right) / t[idx].q;\n  return k + l;\n}\n\nint main() {\n\n  for(int N; cin >> N && N;) {\n    rep(i, N) t[i] = tree(-1,-1,-1,-1);\n    set<int> st;\n    rep(i, N) {\n      int p, q, r, b; cin >> p >> q >> r >> b;\n      t[i] = {p, q, r, b};\n      if(r > 0) st.insert(r-1);\n      if(b > 0) st.insert(b-1);\n    }\n    rep(i, N) {\n      if(!st.count(i)) {\n        cout << dfs(i) << endl;\n        break;\n      }\n    }\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct bou{\n    int p,q,r,b;\n    bou(){}\n    bou(int pp,int qq,int rr,int bb){\n        p=pp;q=qq;r=rr;b=bb;\n    }\n};\nvector<bou> ins;\nint solve(int at){\n    if(at==0) return 1;\n    else{\n        at--;\n        int rm=solve(ins[at].r),bm=solve(ins[at].b);\n        int lcm=ins[at].p*rm/__gcd(ins[at].p*rm,ins[at].q*bm)*ins[at].q*bm;\n        return lcm/ins[at].p+lcm/ins[at].q;\n    }\n}\nint main(){\n    int n;\n    for(;;){\n        scanf(\"%d\",&n);\n        if(n==0) break;\n        ins=vector<bou>(n);\n        vector<bool> isroot(n,true);\n        for(int i=0;i<n;i++){\n            int p,q,r,b;\n            scanf(\"%d%d%d%d\",&p,&q,&r,&b);\n            int gcd=__gcd(p,q);\n            p=p/gcd;\n            q=q/gcd;\n            ins[i]=bou(p,q,r,b);\n            if(r!=0) isroot[r-1]=false;\n            if(b!=0) isroot[b-1]=false;\n        }\n        for(int i=0;i<n;i++){\n            if(isroot[i]){\n                printf(\"%d\\n\",solve(i+1));\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint X[100],Y[100];\nint W[1024];\nint L[100],R[100];\nint n;\n\nint getWeight(int pos){\n\tif(pos > n){ return W[pos]; }\n\treturn getWeight(L[pos]) + getWeight(R[pos]);\n}\nvoid refleshTree(int pos , int mult){\n\tif(pos > n) { W[pos] *= mult; return; }\n\trefleshTree(L[pos],mult);\n\trefleshTree(R[pos],mult);\n}\nvoid dfs(int pos){\n\tif(pos > n){\n\t\treturn;\n\t}\n\tdfs(L[pos]);\n\tdfs(R[pos]);\n\t\n\tint S = getWeight(L[pos]) * X[pos]; \n\tint T = getWeight(R[pos]) * Y[pos];\n\tint g = S / __gcd(S,T) * T;\n\trefleshTree(L[pos],g / S);\n\trefleshTree(R[pos],g / T);\n}\n\nint main(){\n\twhile(cin >> n && n){\n\t\tint K = 512;\n\t\tint used[100]={};\n\t\tfor(int i = 0 ;  i < n ; i++){\n\t\t\tint a,b,c,d;\n\t\t\tcin >> a >> b >> c >> d;\n\t\t\tc--,d--;\n\t\t\tX[i] = a , Y[i] = b;\n\t\t\tint g = __gcd(a,b);\n\t\t\tX[i] /= g;\n\t\t\tY[i] /= g;\n\t\t\tif(c == -1) c = K++; else used[c] = true;\n\t\t\tif(d == -1) d = K++; else used[d] = true;\n\t\t\tL[i] = c;\n\t\t\tR[i] = d;\n\t\t}\n\t\t\n\t\tfor(int i = 0 ; i < K ; i++) W[i] = 1;\n\t\t\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tif(!used[i]){\n\t\t\t\tdfs(i);\n\t\t\t\tcout << getWeight(i) << endl;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\ntemplate<class T>\nT gcd(T a, T b){\n  if(a > b) swap(a, b);\n  if(a == 0) return b;\n  return gcd(a, b%a);\n}\n\nint barL[100];\nint barR[100];\n\nint barRatioL[100];\nint barRatioR[100];\n\nint which(int n){\n  vector<bool> f(n+1, false);\n  REP(i,n+1) f[barL[i]] = f[barR[i]] = true;\n  REP(i,n+1) if(!f[i]) return i;\n  return -1;\n}\n\nlong long weight(int i){\n  int l = barL[i-1];\n  int r = barR[i-1];\n\n  long long wl = l == 0 ? 1 : weight(l);\n  long long wr = r == 0 ? 1 : weight(r);\n\n  int rl = barRatioL[i-1];\n  int rr = barRatioR[i-1];\n\n  long long R = wr * rr;\n  long long L = wl * rl;\n  long long g = gcd(R, L);\n  long long lcm = R*L/g;\n\n  return (lcm/rl + lcm/rr);\n}\n\nint main(){\n  int n;\n  while(n = getInt()){\n    REP(i,n){\n      int a = getInt();\n      int b = getInt();\n      int g = gcd(a, b);\n\n      barL[i] = getInt();\n      barR[i] = getInt();\n\n      barRatioL[i] = a / g;\n      barRatioR[i] = b / g;\n    }\n\n    printf(\"%lld\\n\", weight(which(n)));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 101\nusing namespace std;\ntypedef long long ll;\nll n,p[N],q[N],r[N],b[N];\nbool s[N];\n\nll func(int x){\n  ll R=1,B=1;\n  if(r[x]<b[x]) swap(r[x],b[x]);\n  if(r[x]) R=func(r[x]);\n  if(b[x]) B=func(b[x]);\n  ll k=__gcd(R*p[x],B*q[x]);\n  ll a=(R*p[x])/k,b=(B*q[x])/k;\n  return (R*b)+(B*a);\n}\n\nint main(){\n  while(cin>>n,n){\n    memset(s,0,sizeof(s));\n    for(int i=1;i<=n;i++){\n      cin>>p[i]>>q[i]>>r[i]>>b[i];\n      ll res=__gcd(p[i],q[i]);\n      p[i]/=res,q[i]/=res;\n      s[r[i]]=s[b[i]]=true;\n    }\n    for(int i=1;i<=n;i++)\n      if(!s[i])cout<<func(i)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define min_3(a,b,c) min(a,min(b,c))\n#define max_3(a,b,c) max(a,max(b,c))\n#define mp1(a,b,c) P1(a,P(b,c))\n#define pque(a) priority_queue<a>\n#define rpque(a) priority_queue<a,vector<a>,greater<a>>\n\nconst int INF=1000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\nconst int kaijou[10]={1,1,2,6,24,120,720,5040,40320,362880};\n\nll gcd(ll x,ll y){\n\tif(y == 0)return x;\n\treturn gcd(y,x%y);\n}\n\nll lcm(ll x,ll y){\n\treturn x/gcd(x,y)*y;\n}\n\nint n;\nll p[102],q[102],r[102],b[102];\nll w[102];\n\nll dfs(int v){\n\tif(v == 0)return 1;\n\tif(w[v] != 0)return w[v];\n\tll x = dfs(r[v]);\n\tll y = dfs(b[v]);\n\tll l = lcm(p[v]*x,q[v]*y);\n\treturn l/p[v] + l/q[v];\n}\n\nvoid init(){\n\trep(i,102){\n\t\tw[i] = 0;\n\t}\n}\n\nint main(){\n\twhile(1){\n\t\tinit();\n\t\tscanf(\"%d\",&n); if(n == 0)break;\n\t\trep1(i,n){\n\t\t\tscanf(\"%lld%lld%lld%lld\",&p[i],&q[i],&r[i],&b[i]);\n\t\t}\n\t\t\n\t\tll ret = 0;\n\t\trep1(i,n){\n\t\t\tret = max ( ret , dfs(i) );\n\t\t}\n\t\t\n\t\tprintf(\"%lld\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <cstring>\nusing namespace std;\n\nlong long int dp[110],K[110],O[110],L[110],R[110];\n\nlong long int gcd(long long int a,long long int b){\n\tlong long int tmp;\n\tif(a<b) swap(a,b);\n\twhile((tmp=a%b)!=0){\n\t\ta=b;\n\t\tb=tmp;\n\t}\n\treturn b;\n}\n\n\nlong long int mobi(long long int bou){\n\tif(bou==0) return 1;\n\tif(dp[bou]!=0) return dp[bou];\n\tlong long int l,r,li,ri,gc,gc2,a,b;\n\tl=mobi(L[bou]);\n\tr=mobi(R[bou]);\n\tri=K[bou];li=O[bou];\n\tgc=gcd(li,ri);\n\tli/=gc;ri/=gc;\n\tgc2=gcd(li*l,ri*r);\n\tb=li*l/gc2;\n\ta=ri*r/gc2;\n\tdp[bou]=(a*l+b*r);\n\treturn dp[bou];\n}\n\nint main(){\n\tint N;\n\tlong long int res;\n\twhile(1){\n\t\tcin>>N;\n\t\tif(N==0) break;\n\t\tmemset(dp,0,sizeof(dp));\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tcin>>K[i]>>O[i]>>L[i]>>R[i];\n\t\t}\n\t\tres=0;\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tres=max(res,mobi(i));\n\t\t}\n\t\t/*\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tcout<<i<<\" \"<<dp[i]<<endl;//\n\t\t}\n\t\t*/\n\t\tcout<<res<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<map>\n#include<cassert>\n#define F first\n#define S second\n#define PPins(a,b,c,d) PP(P(a,b),P(c,d))\n#define PPPins(a,b,c,d,e) PPP(a,PP(P(b,c),P(d,e)))\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\ntypedef pair<int,PP> PPP;\n\nmap<int,PP> tree;\nint top;\n\nint lcm(int a,int b)\n{\n  return a/__gcd(a,b)*b;\n}\n\nint rec(int n)\n{\n \n  int gcd = __gcd(tree[n].F.F,tree[n].F.S);\n  if(!tree[n].S.F && !tree[n].S.S)\n       return tree[n].F.F/gcd + tree[n].F.S/gcd;\n\n  if(tree[n].S.F && tree[n].S.S)\n    {\n      int Left = rec(tree[n].S.F);\n      int Right = rec(tree[n].S.S);\n   \n      return 2*lcm(tree[n].F.F/gcd*Left,tree[n].F.S/gcd*Right);\n\n    }\n\n  if(!tree[n].S.F && tree[n].S.S)\n    {      \n      int Right = rec(tree[n].S.S);\n      int x = lcm((Right*(tree[n].F.S/gcd)),tree[n].F.F/gcd)/tree[n].F.F;\n      //cout << \"In \" << n << \" x = \" << x << \" return = \" << (x*(tree[n].F.F/gcd))/(tree[n].F.S/gcd) + x << endl;\n      return (x*(tree[n].F.F/gcd))/(tree[n].F.S/gcd) + x;\n    }\n\n  if(tree[n].S.F && !tree[n].S.S)\n    {\n      int Left = rec(tree[n].S.F);\n      int x = lcm((Left*(tree[n].F.F/gcd)),tree[n].F.S/gcd)/tree[n].F.S;\n      //cout << \"In \" << n << \" x = \" << x << \" return = \" << (x*(tree[n].F.S/gcd))/(tree[n].F.F/gcd) + x << endl;\n      return (x*(tree[n].F.S/gcd))/(tree[n].F.F/gcd) + x;\n    }\n\n  assert(false);\n  return 0;\n}\n\nint main()\n{\n  int n;\n  while(true)\n    {\n      scanf(\"%d\",&n);\n      cerr << n << endl;\n      if(!n)\n\tbreak;\n      tree.clear();      \n      bool *who = new bool[n+1];\n      for(int i=0;i<n+1;i++)\n\twho[i] = false;\n      who[0] = true;\n      for(int i=0;i<n;i++)\n\t{\n\t  int p,q,r,b;\n\t  scanf(\"%d %d %d %d\",&p,&q,&r,&b);\n\t  tree[i+1] = PPins(p,q,r,b);\n\t  who[r] = who[b] = true;\n\t  cerr << p << \" \" << q << \" \" << r << \" \" << b << endl;\n\t}\n\n      top = -1;\n      for(int i=1;i<n+1;i++)\n\tif(!who[i])\n\t  {\n\t    top = i;\n\t    break;\n\t  }\n      delete [] who;\n      assert(top != -1);\n      \n      cout << \"ans ; \";\n      printf(\"%d\\n\",rec(top));    \n\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\nlong long int l[100];\nlong long int r[100];\n\nlong long int ln[100];\nlong long int rn[100];\n\nbool use[100];\n\nlong long int ko(long long int a,long long int b)\n{\n\twhile(1)\n\t{\n\t\tlong long int w = a % b;\n\t\tif(w == 0)\n\t\t{\n\t\t\treturn b;\n\t\t}\n\t\ta = b;\n\t\tb = w;\n\t}\n}\n\nlong long int ju(int b)\n{\n\tlong long int ld,rd;\n\tif(l[b] >= 0)\n\t{\n\t\tld = ju(l[b]);\n\t}\n\telse\n\t{\n\t\tld = 1;\n\t}\n\tif(r[b] >= 0)\n\t{\n\t\trd = ju(r[b]);\n\t}\n\telse\n\t{\n\t\trd = 1;\n\t}\n\tlong long int lk = ld * ln[b];\n\tlong long int rk = rd * rn[b];\n\tlong long int ww = ko(ld,rd);\n\tlong long int w = ko(lk,rk);\n\tlong long int sai = lk * rk / w;\n\treturn sai / ln[b] + sai / rn[b];\n}\n\nint main()\n{\n\twhile(1)\n\t{\n\t\tint n;\n\t\tscanf(\"%d\",&n);\n\t\tif(n == 0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tint lne,rne;\n\t\t\tlong long int lw,rw;\n\t\t\tscanf(\"%lld %lld %d %d\",&lw,&rw,&lne,&rne);\n\t\t\tl[i] = lne - 1;\n\t\t\tr[i] = rne - 1;\n\t\t\tlong long int w = ko(lw,rw);\n\t\t\tln[i] = lw / w;\n\t\t\trn[i] = rw / w;\n\t\t}\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tuse[i] = true;\n\t\t}\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tif(l[i] >= 0)\n\t\t\t{\n\t\t\t\tuse[l[i]] = false;\n\t\t\t}\n\t\t\tif(r[i] >= 0)\n\t\t\t{\n\t\t\t\tuse[r[i]] = false;\n\t\t\t}\n\t\t}\n\t\tint oya;\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tif(use[i])\n\t\t\t{\n\t\t\t\toya = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",ju(oya));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<fstream>\n#include<string>\nusing namespace std;\n\nstruct tBar{\n\tunsigned int rdis, bdis, r, b;\n\tunsigned int w;\n};\ntBar bar[101];\nint N;\n\nunsigned int euclid( int a, int b ){\n\twhile( a != b ){\n\t\tif( a>b )\ta -= b;\n\t\telse\t\tb -= a;\n\t}\n\treturn a;\n}\n\nunsigned int calcWeight( int n ){\n\ttBar &bn = bar[n];\n\tunsigned int rw=0, bw=0;\n\tif( bn.r==0 && bn.b==0 ){\n\t\trw = bn.bdis;\n\t\tbw = bn.rdis;\n\t}else if( bn.r!=0 && bn.b==0 ){\n\t\t\trw = calcWeight( bn.r );\n\t\t\tbw = bn.rdis * rw / bn.bdis;\n\t}else if( bn.r==0 && bn.b!=0 ){\n\t\t\tbw = calcWeight( bn.b );\n\t}else{\n\t\trw = calcWeight( bn.r );\n\t\tbw = calcWeight( bn.b );\n\t}\n\t\n\twhile( rw*bn.rdis != bw*bn.bdis ){\n\t\tif( rw*bn.rdis > bw*bn.bdis ){\n\t\t\tbw += bn.b==0 ? bn.rdis : bar[bn.b].w;\n\t\t}else{\n\t\t\trw += bn.r==0 ? bn.bdis : bar[bn.r].w;\n\t\t}\n\t}\n\tbn.w = rw+bw;\n\treturn bn.w;\n}\n\nint findRoot( int n ){\n\tfor( int i=1; i<=N; i++ ){\n\t\tif( bar[i].r==n || bar[i].b==n ){\n\t\t\tn = i;\n\t\t\ti = 0;\n\t\t}\n\t}\n\treturn n;\n}\n\nint main(){\n\tint n;\n\tstring str;\n\tifstream in(\"input.txt\");\n\tofstream out(\"output.txt\");\n\twhile(1){\n\t\tgetline( in, str );\n\t\tsscanf( str.c_str(), \"%d\", &n );\n\t\tif( n == 0 )\tbreak;\n\t\tN = n;\n\t\tfor( int i=1; i<=n; i++ ){\n\t\t\tgetline( in, str );\n\t\t\tint p,q,r,b;\n\t\t\tsscanf(str.c_str(), \"%d %d %d %d\", &p, &q, &r, &b);\n\t\t\tint e = euclid( p, q );\n\t\t\tbar[i].rdis = p / e;\n\t\t\tbar[i].bdis = q / e;\n\t\t\tbar[i].r = r;\n\t\t\tbar[i].b = b;\n\t\t\tbar[i].w = 0;\n\t\t}\n\t\tint root = findRoot(1);\n\t\tint sum = calcWeight(root);\n\t\tout << sum << endl;\n\t}\n\tin.close();\n\tout.close();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint a[100+2],b[100+2],c[100+2],d[100+2],w[100+2],n;\n\nint s(int x){\n\tint ans;\n\tif(w[x]!=-1)return w[x];\n\telse {\n\t\tint e=a[x]*s(c[x]),f=b[x]*s(d[x]);\n\t\tint g=e,h=f,gcd;\n\t\twhile(1){\n\t\t\tg%=h;\n\t\t\tif(g==0)break;\n\t\t\th%=g;\n\t\t\tif(h==0)break;\n\t\t}\n\t\tgcd=e*f/max(g,h);\n\t\tans=gcd/a[x]+gcd/b[x];\n\t}\n\tw[x]=ans;\n\treturn ans;\n}\n\nint main(){\nwhile(1){\n\tint ans=0;\n\tscanf(\"%d\",&n);\n\tif(n==0)break;\n\tw[0]=1;\n\tfor(int i=1;i<=n;i++){scanf(\"%d%d%d%d\",&a[i],&b[i],&c[i],&d[i]); w[i]=-1;}\n\tfor(int i=1;i<=n;i++){\n\t\tif(w[i]==-1)a[101]=s(i);\n\t\tif(ans<w[i])ans=w[i];\n\t}\n\tprintf(\"%d\\n\",ans);\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n\ntemplate <class T>\nint __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n\nconst double EPS = 1e-10;\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\n\nll gcd(ll a, ll b)\n{\n\tif (a < b)\n\t\tswap(a, b);\n\tif (b == 0)\n\t\treturn a;\n\treturn gcd(b, a%b);\n}\nll lcm(ll a, ll b)\n{\n\treturn a*b/gcd(a, b);\n}\nint p[128], q[128], r[128], b[128];\nint w[128];\nint dfs(int s)\n{\n\tif (s == 0)\n\t\treturn 1;\n\telse if (w[s] != -1)\n\t\treturn w[s];\n\n\tll red = dfs(r[s]), blue = dfs(b[s]);\n\tll t = lcm(red*q[s], blue*p[s]);\n\tw[s] = (int)(t/p[s] + t/q[s]);\n\treturn w[s];\n}\nint main()\n{\n\tint n;\n\twhile (~scanf(\"%d\", &n) && n)\n\t{\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t{\n\t\t\tscanf(\"%d%d%d%d\", p+i, q+i, r+i, b+i);\n\t\t\tll g = gcd(p[i], q[i]);\n\t\t\tp[i] /= g, q[i] /= g;\n\t\t}\n\t\tmemset(w, -1, sizeof(w));\n\t\tint res = 0;\n\t\tfor (int i = 1; i <= n; ++i)\n\t\t\tres = max(res, dfs(i));\n\t\tprintf(\"%d\\n\", res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <cmath>\n#include <map>\n#include <set>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n\n#define INF_LL 1e18\n#define INF 1e9\n\n#define REP(i, n) for(int i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n\n#define fst first\n#define snd second\n\nusing namespace std;\n\nusing ll = long long;\nusing PII = pair<int, int>;\n\nstruct stick{\n\tint l_d, r_d;\n\tint par, l, r;\n};\n\nstick s[101];\n\nint gcd(int x, int y){\n\tif(y == 0) return x;\n\treturn gcd(y, x%y);\n}\n\nint dfs(int st, int wei){\n\tif(wei % (s[st].l_d+s[st].r_d) != 0) return 0;\n\tint tani = wei / (s[st].l_d+s[st].r_d);\n\tif((s[st].l == 0 || dfs(s[st].l, tani*s[st].l_d)) && (s[st].r == 0 || dfs(s[st].r, tani*s[st].r_d)))\n\t\treturn 1;\n\treturn 0;\n}\n\nint main(void){\n\tint n;\n\n\tcin >> n;\n\tFOR(i, 1, n+1){\n\t\ts[i].par = i;\n\t}\n\tFOR(i, 1, n+1){\n\t\tint a;\n\t\tcin >> s[i].l_d >> s[i].r_d >> s[i].l >> s[i].r;\n\t\ta = gcd(s[i].l_d, s[i].r_d);\n\t\ts[i].l_d /= a;\n\t\ts[i].r_d /= a;\n\t\ts[s[i].l].par = i;\n\t\ts[s[i].r].par = i;\n\t}\n\tint start = 1;\n\twhile(s[start].par != start){\n\t\tstart = s[start].par;\n\t}\n\tint wei = s[start].l_d+s[start].r_d;\n\tint cnt = 1;\n\twhile(!dfs(start, wei*cnt)){\n\t\tcnt++;\n\t}\n\tcout << wei*cnt << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\nlong long depth[500];\nlong long w[500][2];\nlong long x[500][2];\nlong long n, root, v[500], a, A, B, C;\npair<long long, long long>DEPTH[500];\nlong long mobile[500][2];\n\nlong long gcd(long long p, long long q) {\n\tlong long P = p, Q = q;\n\twhile (true) {\n\t\tif (P%Q == 0) { return Q; }\n\t\tif (Q%P == 0) { return P; }\n\t\tif (P > Q) { P = P%Q; }\n\t\telse { Q = Q%P; }\n\t}\n}\n\nint main() {\n\twhile (true) {\n\t\tmemset(depth, 0, sizeof(depth));\n\t\tmemset(w, 0, sizeof(w));\n\t\tmemset(x, 0, sizeof(x));\n\t\tmemset(v, 0, sizeof(v));\n\t\tmemset(DEPTH, 0, sizeof(DEPTH));\n\t\tmemset(mobile, 0, sizeof(mobile));\n\t\troot = 0; n = 0; A = 0; B = 0; C = 0; a = 0;\n\t\tcin >> n;\n\t\tif (n == 0) { break; }\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tv[i] = 0;\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tcin >> w[i][0] >> w[i][1] >> x[i][0] >> x[i][1];\n\t\t\tv[x[i][0]] = 1; v[x[i][1]] = 1;\n\t\t\ta = gcd(w[i][0], w[i][1]);\n\t\t\tw[i][0] /= a; w[i][1] /= a;\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (v[i] == 0) {\n\t\t\t\troot = i;\n\t\t\t}\n\t\t}\n\t\t//depth.\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tdepth[i] = 1000;\n\t\t}\n\t\tdepth[root] = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfor (int j = 1; j <= n; j++) {\n\t\t\t\tif (depth[j] != 1000) {\n\t\t\t\t\tdepth[x[j][0]] = min(depth[x[j][0]], depth[j] + 1);\n\t\t\t\t\tdepth[x[j][1]] = min(depth[x[j][1]], depth[j] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tDEPTH[i - 1].first = depth[i];\n\t\t\tDEPTH[i - 1].second = i;\n\t\t}\n\t\tsort(DEPTH, DEPTH + n);\n\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\tA = DEPTH[i].first;\n\t\t\tB = DEPTH[i].second;\n\t\t\tif (x[B][0] == 0 && x[B][1] == 0) {\n\t\t\t\tmobile[B][0] = w[B][1];\n\t\t\t\tmobile[B][1] = w[B][0];\n\t\t\t}\n\t\t\tif (x[B][0] == 0 && x[B][1] >= 1) {\n\t\t\t\tmobile[B][1] = mobile[x[B][1]][0] + mobile[x[B][1]][1];\n\t\t\t\tmobile[B][1] = mobile[B][1] * w[B][0] / gcd(mobile[B][1], w[B][0]);\n\t\t\t\tmobile[B][0] = mobile[B][1] * w[B][1] / w[B][0];\n\t\t\t}\n\t\t\tif (x[B][0] >= 1 && x[B][1] == 0) {\n\t\t\t\tmobile[B][0] = mobile[x[B][0]][0] + mobile[x[B][0]][1];\n\t\t\t\tmobile[B][0] = mobile[B][0] * w[B][1] / gcd(mobile[B][0], w[B][1]);\n\t\t\t\tmobile[B][1] = mobile[B][0] * w[B][0] / w[B][1];\n\t\t\t}\n\t\t\tif (x[B][0] >= 1 && x[B][1] >= 1) {\n\t\t\t\tmobile[B][0] = mobile[x[B][0]][0] + mobile[x[B][0]][1];\n\t\t\t\tmobile[B][1] = mobile[x[B][1]][0] + mobile[x[B][1]][1];\n\t\t\t\tC = mobile[B][0] * w[B][0] * mobile[B][1] * w[B][1] / gcd(mobile[B][0] * w[B][0], mobile[B][1] * w[B][1]);\n\t\t\t\tmobile[B][0] = C / w[B][0];\n\t\t\t\tmobile[B][1] = C / w[B][1];\n\t\t\t}\n\t\t}\n\t\tcout << mobile[root][0] + mobile[root][1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define rep(i,x) for(int i=0;i<x;++i)\n\nstruct node {\n    int p, q, r, b;\n};\n\nvector<node> sticks;\nint par[105];\n\nint n;\n\nint gcd(int a, int b)\n{\n    int tmp;\n    while (b != 0) {\n        tmp = b;\n        b = a % b;\n        a = tmp;\n    }\n\n    return a;\n}\n\nint lcm(int a, int b)\n{\n    return a / gcd(a, b) * b;\n}\n\nint dfs(int cur)\n{\n    node& s = sticks[cur];\n\n    if (s.r == -1 && s.b == -1) {\n        int g = gcd(s.p, s.q);\n        return s.p / g + s.q / g;\n    }\n\n    if (s.r == -1) {\n        int bch = dfs(s.b);\n        int a = lcm(s.p, bch * s.q);\n        return a / s.p + bch * (a / (bch * s.q));\n    }\n\n    if (s.b == -1) {\n        int rch = dfs(s.r);\n        int a = lcm(rch * s.p, s.q);\n        return rch * (a / rch * s.p) + a / s.q;\n    }\n\n    int rch = dfs(s.r), bch = dfs(s.b);\n    int a = lcm(rch * s.p, bch * s.q);\n\n    return rch * (a / (rch * s.p)) + bch * (a / (bch * s.q));\n}\n\nsigned main()\n{\n    while (cin >> n, n) {\n        sticks.resize(n);\n        memset(par, -1, sizeof(par));\n\n        rep(i, n) {\n            int p, q, r, b;\n            cin >> p >> q >> r >> b;\n            r--, b--;\n            sticks[i] = node{p, q, r, b};\n\n            if (r >= 0) par[r] = i;\n            if (b >= 0) par[b] = i;\n        }\n\n        int root;\n\n        {\n            int cur = 0;\n            do {\n                root = cur;\n                cur = par[cur];\n            } while (cur != -1);\n        }\n\n        cout << dfs(root) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//Bokan ga bokka--nn!!\n//Daily Lunch Special Tanoshii !!\n//これは、頭が悪く競プロが世界で一番できないHIR180が\n//IOI2014日本代表になるまでのN日間の記録である。\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\ntypedef long long ll;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 2000000000\n#define f first\n#define s second\n#define rep(i,x) for(int i=0;i<x;i++)\nint l[105],r[105],n;\nint c[105],d[105];\nll dfs(int cur)\n{\n\tll le=1,ri=1;\n\tif(c[cur]) le=dfs(c[cur]);\n\tif(d[cur]) ri=dfs(d[cur]);\n\tll x=le/__gcd(le,1LL*r[cur]);\n\tll y=ri/__gcd(ri,1LL*l[cur]);\n\tll base=1LL*x/__gcd(x,y)*y;\n\treturn base*(l[cur]+r[cur]);\n}\nint main()\n{\n\tsrand((unsigned int)time(NULL));\n\twhile(1)\n\t{\n\t\tscanf(\"%d\",&n); if(!n) return 0;\n\t\tbool sub[105]={};\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tint a,b;\n\t\t\tscanf(\"%d %d %d %d\",&a,&b,&c[i],&d[i]);\n\t\t\tsub[c[i]]=sub[d[i]]=true;\n\t\t\tint x=__gcd(a,b);\n\t\t\tl[i]=a/x;\n\t\t\tr[i]=b/x;\n\t\t}\n\t\tll ret=0;\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tif(!sub[i]) ret+=dfs(i);\n\t\t}\n\t\tprintf(\"%lld\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n\n#define REP(i,n) for(long long i = 0; i < (n); i++)\n#define FOR(i, m, n) for(long long i = (m);i < (n); ++i)\n#define ALL(obj) (obj).begin(),(obj).end()\n#define SPEED cin.tie(0);ios::sync_with_stdio(false);\n\ntemplate<class T> using V = vector<T>;\ntemplate<class T, class U> using P = pair<T, U>;\n\nconst ll MOD = (ll)1e9 + 7;\nconst ll MOD2 = 998244353;\nconst ll HIGHINF = (ll)1e18;\nconst ll LOWINF = (ll)1e15;\nconst long double PI = 3.1415926535897932384626433;\n\ntemplate <class T> void corner(bool flg, T hoge) {if (flg) {cout << hoge << endl; exit(0);}}\ntemplate <class T, class U>ostream &operator<<(ostream &o, const map<T, U>&obj) {o << \"{\"; for (auto &x : obj) o << \" {\" << x.first << \" : \" << x.second << \"}\" << \",\"; o << \" }\"; return o;}\ntemplate <class T>ostream &operator<<(ostream &o, const set<T>&obj) {o << \"{\"; for (auto itr = obj.begin(); itr != obj.end(); ++itr) o << (itr != obj.begin() ? \", \" : \"\") << *itr; o << \"}\"; return o;}\ntemplate <class T>ostream &operator<<(ostream &o, const multiset<T>&obj) {o << \"{\"; for (auto itr = obj.begin(); itr != obj.end(); ++itr) o << (itr != obj.begin() ? \", \" : \"\") << *itr; o << \"}\"; return o;}\ntemplate <class T>ostream &operator<<(ostream &o, const vector<T>&obj) {o << \"{\"; for (int i = 0; i < (int)obj.size(); ++i)o << (i > 0 ? \", \" : \"\") << obj[i]; o << \"}\"; return o;}\ntemplate <class T, class U>ostream &operator<<(ostream &o, const pair<T, U>&obj) {o << \"{\" << obj.first << \", \" << obj.second << \"}\"; return o;}\ntemplate <template <class tmp>  class T, class U> ostream &operator<<(ostream &o, const T<U> &obj) {o << \"{\"; for (auto itr = obj.begin(); itr != obj.end(); ++itr)o << (itr != obj.begin() ? \", \" : \"\") << *itr; o << \"}\"; return o;}\nvoid print(void) {cout << endl;}\ntemplate <class Head> void print(Head&& head) {cout << head;print();}\ntemplate <class Head, class... Tail> void print(Head&& head, Tail&&... tail) {cout << head << \" \";print(forward<Tail>(tail)...);}\ntemplate <class T> void chmax(T& a, const T b){a=max<T>(a,b);}\ntemplate <class T> void chmin(T& a, const T b){a=min<T>(a,b);}\nvoid YN(bool flg) {cout << ((flg) ? \"YES\" : \"NO\") << endl;}\nvoid Yn(bool flg) {cout << ((flg) ? \"Yes\" : \"No\") << endl;}\nvoid yn(bool flg) {cout << ((flg) ? \"yes\" : \"no\") << endl;}\n\n\nclass Lowest_Common_Ancestor {\npublic:\n\tint N, MAX_bit;\n\tvector<vector<int>> edge;\n\tvector<int> depth;\n\tvector<vector<int>> parent;\n\tvector<vector<int>> child;\n\tvector<vector<int>> descendant;\n\n\tLowest_Common_Ancestor(int N, int MAX_bit = 20) :N(N), MAX_bit(MAX_bit), edge(N), depth(N, -1), parent(N, vector<int>(MAX_bit)), child(N), descendant(N){\n\t\t//do nothing\n\t}\n\n\t//O(1)\n\tvoid make_edge(int from, int to) {\n\t\tedge[from].push_back(to);\n\t}\n\n\t//O(N)\n\tvoid make_depth(int root) {\n\t\tqueue<int> q;\n\t\tdepth[root] = 0;\n\t\tq.push(root);\n\t\twhile (q.size()) {\n\t\t\tint from = q.front();\n\t\t\tq.pop();\n\t\t\tfor (auto to : edge[from]) {\n\t\t\t\tif (depth[to] != -1) continue;\n\t\t\t\tdepth[to] = depth[from] + 1;\n\t\t\t\tq.push(to);\n\t\t\t}\n\t\t}\n\t}\n\n\t//O(MAX_bit*N)\n\tvoid make_parent() {\n\t\tfor (int i = 0; i < N; ++i) parent[i][0] = i;\n\t\tfor (int i = 0; i < N; ++i) for (auto j : edge[i]) if (depth[i] > depth[j]) parent[i][0] = j;\n\t\tfor (int bit = 1; bit < MAX_bit; ++bit) for (int i = 0; i < N; ++i) parent[i][bit] = parent[parent[i][bit - 1]][bit - 1];\n\t}\n\n\t//O(N)\n\tvoid make_child() {\n\t\tfor (int i = 0; i < N; ++i) for (auto j : edge[i]) if (depth[i] < depth[j]) child[i].push_back(j);\n\t}\n\n\t//O(N^2)\n\tvoid make_descendant() {\n\t\tvector<pair<int,int>> ord(N);\n\t\tfor (int i = 0; i < N; ++i) ord[i] = {depth[i],i};\n\t\tsort(ord.begin(),ord.end(),greater<>());\n\t\tfor (int i = 0; i < N; ++i) descendant[i].push_back(i);\n\t\tfor (int i = 0; i < N; ++i) for (auto j : edge[ord[i].second]) if (depth[ord[i].second] < depth[j]) for(auto k: descendant[j]) descendant[ord[i].second].push_back(k);\n\t}\n\n\t//O(MAX_bit*logN)\n\tint lca(int l, int r) {\n\t\tif (depth[l] < depth[r]) swap(l, r);\n\t\tint diff = depth[l] - depth[r];\n\t\tfor (int bit = 0; bit < MAX_bit; ++bit) if (diff & (1 << bit)) l = parent[l][bit];\n\t\tint ok = (1 << MAX_bit), ng = -1, md;\n\t\twhile (ok - ng>1) {\n\t\t\tmd = (ok + ng) / 2;\n\t\t\tint x = l, y = r;\n\t\t\tfor (int bit = 0; bit < MAX_bit; ++bit) if (md & (1 << bit)) x = parent[x][bit];\n\t\t\tfor (int bit = 0; bit < MAX_bit; ++bit) if (md & (1 << bit)) y = parent[y][bit];\n\t\t\t(x == y ? ok : ng) = md;\n\t\t}\n\t\tfor (int bit = 0; bit < MAX_bit; ++bit) if (ok & (1 << bit)) l = parent[l][bit];\n\t\treturn l;\n\t}\n\n\tvoid print() {\n\t\tcout << \" depth { \" << depth[0];\n\t\tfor (int i = 1; i < N; ++i) cout << \", \" << depth[i];\n\t\tcout << \" }\" << endl;\n\n\t\tcout << \"parent { \" << parent[0][0];\n\t\tfor (int i = 1; i < N; ++i) cout << \", \" << parent[i][0];\n\t\tcout << \" }\" << endl;\n\n\t\tcout << \" child { \" << child[0];\n\t\tfor (int i = 1; i < N; ++i) cout << \", \" << child[i];\n\t\tcout << \" }\" << endl;\n\n\t\tcout << \"descen { \" << descendant[0];\n\t\tfor (int i = 1; i < N; ++i) cout << \", \" << descendant[i];\n\t\tcout << \" }\" << endl;\n\t}\n\n};\n\nvector<long long> Prime_Factorization(long long N) {\n    vector<long long> ret;\n    if (N == 1) ret.push_back(1);\n    for (long long i = 2,M = N; i*i <= M; ++i) {\n        if (N%i == 0) ret.push_back(i);\n        while (N%i == 0) N /= i;\n    }\n    if (N != 1) ret.push_back(N);\n    return ret;\n}\n\n//Greatest Common Divisor\nlong long GCD(long long a, long long b) {\n    return ((b == 0) ? a : GCD(b, a % b));\n}\n\nint main() {\n    while(1){\n        int N; cin >> N;\n        if(N==0) return 0;\n        V<int> p(N),q(N),l(N),r(N), vst(N,0), dp(N,1);\n        for(int i = 0; i < N; ++i) cin >> p[i] >> q[i] >> l[i] >> r[i];\n        Lowest_Common_Ancestor tree(N);\n        for(int i = 0; i < N; ++i){\n            l[i]--,r[i]--;\n            if(l[i]!=-1) tree.make_edge(i,l[i]);\n            if(l[i]!=-1) vst[l[i]]++;\n            if(r[i]!=-1) tree.make_edge(i,r[i]);\n            if(r[i]!=-1) vst[r[i]]++;\n        }\n        int root = min_element(ALL(vst)) - vst.begin();\n        tree.make_depth(root);\n        V<P<int,int>> ord(N);\n        for(int i = 0; i < N; ++i) ord[i] = {-tree.depth[i],i};\n        sort(ALL(ord));\n        for(int i = 0; i < N; ++i){\n            int idx = ord[i].second;\n            ll g = GCD(p[idx],q[idx]);\n            p[idx] /= g;\n            q[idx] /= g;\n            ll s = p[idx], t = q[idx];\n            if(l[idx]!=-1) p[idx] *= dp[l[idx]];\n            if(r[idx]!=-1) q[idx] *= dp[r[idx]];\n            auto pl = Prime_Factorization(p[idx]);\n            auto pr = Prime_Factorization(q[idx]);\n            map<ll,ll> mpl,mpr,mp;\n            for(auto e: pl){\n                while(e!=1&&p[idx]%e==0){\n                    mpl[e]++;\n                    p[idx]/=e;\n                }\n                mp[e];\n            }\n            for(auto e: pr){\n                while(e!=1&&q[idx]%e==0){\n                    mpr[e]++;\n                    q[idx]/=e;\n                }\n                mp[e];\n            }\n\n            ll cnt = 1;\n            for(auto e:mp){\n                ll k = max(mpl[e.first],mpr[e.first]);\n                for(int j = 0; j < k; ++j) cnt *= e.first;\n            }\n            dp[idx] = cnt/s + cnt/t;\n        }\n        cout << dp[root] << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nconst int N=100;\nint GCD(int a,int b){\n    if(b>a)swap(a,b);\n    return (b==0)?a:GCD(b,a%b);\n}\nint LCM(int a,int b){\n    return a*b/GCD(a,b);\n}\nint l[N+1],r[N+1],w1[N+1],w2[N+1];\nint memo[N+1];\nint dfs(int x){\n    if(memo[x]!=-1)return memo[x];\n    int red=l[x]*dfs(w1[x]);\n    int blue=r[x]*dfs(w2[x]);\n    int lcm=LCM(red,blue);\n    return memo[x]=lcm/l[x]+lcm/r[x];\n}\nint main(){\n    int n;\n    scanf(\"%d\",&n);\n    bool flag[N+1];fill_n(flag,n+1,true);\n    fill_n(memo,n+1,-1);\n    for(int i=1;i<=n;i++){\n        scanf(\"%d%d%d%d\",&l[i],&r[i],&w1[i],&w2[i]);\n        flag[w1[i]]=flag[w2[i]]=false;\n    }\n    memo[0]=1;\n    for(int i=1;i<=n;i++){\n        if(flag[i]){\n            printf(\"%d\\n\",dfs(i));\n            break;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nint memo[110];\n\nint a[110];\nint b[110];\nint l[110];\nint r[110];\n\nint gcd(int a,int b){\n\tif(b==0)\n\t\treturn a;\n\telse\n\t\treturn gcd(b,a%b);\n}\n\nint lcm(int a,int b){\n\tint g=gcd(a,b);\n\treturn a/g*b;\n}\n\nint rec(int i){\n\tif(memo[i]>=0)\n\t\treturn memo[i];\n\tint gg=gcd(a[i],b[i]);\n\tint aa=a[i]/gg;\n\tint bb=b[i]/gg;\n\tint kk=lcm(rec(l[i]),rec(r[i]));\n\tif(kk%aa==0) kk/=aa;\n\tif(kk%bb==0) kk/=bb;\n\treturn memo[i]=(aa+bb)*kk;\n}\n\nint main(void){\n\tint n;\n\twhile(cin >> n,n){\n\t\tfor(int i=1;i<=n;++i) cin >> a[i] >> b[i] >> l[i] >> r[i];\n\t\tmemo[0]=1;\n\t\tfor(int i=1;i<=n;++i) memo[i]=-1;\n\n\t\tint ans=0;\n\t\tfor(int i=1;i<=n;++i) ans=max(ans,rec(i));\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\n\ntypedef long long ll;\ntypedef struct stick{\n ll lren, rren, sl, sr, weight; \n} STICK;\n\nll n, tmp, top;\nll depth[101];\nSTICK st[101];\n\nvoid init(ll k){\n for(ll i = 0; i <= k; i++){\n  depth[i] = 0;\n  st[i].weight = 0;\n }\n}\n\nll gcd(ll a, ll b){\n if(b == 0) return a;\n return gcd(b, a % b);\n}\n\nll lcm(ll a, ll b){\n return a * b / gcd(a, b);\n}\n\nll solve(ll k){\n if(st[k].weight > 0) return st[k].weight;\n if(st[k].sl == 0 && st[k].sr == 0){\n  return st[k].weight = st[k].lren + st[k].rren;\n }else if(st[k].sl == 0){\n  return st[k].weight = solve(st[k].sr) * (st[k].lren + st[k].rren) / gcd(solve(st[k].sr), st[k].lren);\n }else if(st[k]. sr == 0){\n  return st[k].weight = solve(st[k].sl) * (st[k].lren + st[k].rren) / gcd(solve(st[k].sl), st[k].rren);\n }else {\n  tmp = lcm(solve(st[k].sl) * st[k].lren, solve(st[k].sr) * st[k].rren);\n  return st[k].weight = tmp / st[k].lren + tmp / st[k].rren;\n }\n}\n\nll main(){\n while(scanf(\"%d\", &n)){\n  if(n == 0) break;\n  init(n);\n  for(ll i = 1; i <= n; i++){\n   scanf(\"%d %d %d %d\", &st[i].lren, &st[i].rren, &st[i].sl, &st[i].sr);\n   tmp = gcd(st[i].lren, st[i].rren);\n   st[i].lren /= tmp;\n   st[i].rren /= tmp;\n  }\n  for(ll i = 1; i <= n; i++){\n   depth[st[i].sl]++;\n   depth[st[i].sr]++;\n  }\n  for(ll i = 1; i<= n; i++){\n   if(depth[i] == 0){\n    top = i;\n    break;\n   }\n  }\n  printf(\"%d\\n\", solve(top));\n }\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define REP(i,a,n) for(int i = a;i < n;i++)\n#define rep(i,n) REP(i,0,n)\nusing namespace std;\nint dfs(int bar_num);\nclass data{\npublic:\n   int left,right,red,blue;\n   data(){}\n   data(int _left,int _right,int _red,int _blue){\n      left = _left; right = _right; red = _red; blue = _blue;\n   }\n};\n\ndata bar[101];\n\nint in(){int x; scanf(\"%d\",&x); return x;}\nint main(void){\n   int n;\n   while(scanf(\"%d\",&n),n){\n      int flag[101] = {0};\n      REP(i,1,n+1){\n         scanf(\"%d%d%d%d\",&bar[i].left,&bar[i].right,&bar[i].red,&bar[i].blue);\n         flag[bar[i].red] = 1; flag[bar[i].blue] = 1;\n\n      }\n      int start;\n      REP(i,1,n+1){\n         if(flag[i] == 0) start = i;\n      }\n      printf(\"%d\\n\",dfs(start));\n   }\n}\n\nint dfs(int bar_num){\n   if(bar_num == 0){\n      return 1;\n   }\n   int red = dfs(bar[bar_num].red),blue = dfs(bar[bar_num].blue);\n   int left = bar[bar_num].left,right = bar[bar_num].right;\n   int lcm = (red*left)/__gcd(red*left,blue*right)*(blue*right);\n   return lcm/left+lcm/right;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<cstring>\n#define max(a,b) (a>b?a:b)\nlong long int a[999],b[999],c[999],d[999],memo[999],res=0;\n\nlong long int gcd(long long int x,long long int y){\n\tif(x==0)return y;\n\telse return gcd(y%x,x);\n}\nlong long int solve(int x){\n\tif(memo[x]!=0)return memo[x];\n\tint left=a[x]*solve(c[x]),right=b[x]*solve(d[x]),gc;\n\tgc=gcd(left,right);\n\treturn memo[x]=right/gc*solve(c[x])+left/gc*solve(d[x]);\n}\n\nint main(){\n\tint n;\n\tfor(;scanf(\"%d\",&n),n!=0;memset(memo,0,sizeof(memo))){\n\t\tmemo[0]=1;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tscanf(\"%lld%lld%lld%lld\",a+i,b+i,c+i,d+i);\n\t\t}\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tres=max(res,solve(i));\n\t\t}\n\t\tprintf(\"%lld\\n\",res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <tuple>\n# include <unordered_map>\n# include <numeric>\n# include <complex>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconstexpr int INF = 2000000000;\nconstexpr int HINF = INF / 2;\nconstexpr double DINF = 100000000000000000.0;\nconstexpr long long LINF = 9223372036854775807;\nconstexpr long long HLINF = 4500000000000000000;\nconst double PI = acos(-1);\nint dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\n# define ALL(x)     (x).begin(),(x).end()\n# define UNIQ(c)    (c).erase(unique(ALL((c))), end((c)))\n# define mp         make_pair\n# define eb         emplace_back\n# define FOR(i,a,b) for(int i=(a);i<(b);++i)\n# define REP(i,n)   FOR(i,0,n)\n# define INIT       std::ios::sync_with_stdio(false);std::cin.tie(0);\n\nint n, p[101], q[101], r[101], b[101];\n\nlong long gcd(long long a, long long b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a%b);\n}\n\nlong long lcm(long long a, long long b) {\n\tlong long g = gcd(a, b);\n\treturn a / g * b;\n}\n\nint check[200];\n\nint calc(int i) {\n\tint rc = r[i] ? calc(r[i]) : 1;\n\tint bc = b[i] ? calc(b[i]) : 1;\n\tint num = lcm(p[i] * rc, q[i] * bc);\n\treturn num / p[i] + num / q[i];\n}\n\nint main() {\n\twhile (cin >> n&&n) {\n\t\tfor (int i = 0; i < 200; i++)check[i] = 0;\n\t\tfor (int i = 0; i < 101; i++)p[i] = q[i] = r[i] = b[i] = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tcin >> p[i] >> q[i] >> r[i] >> b[i];\n\t\t\tcheck[r[i]] = check[b[i]] = true;\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (!check[i]) {\n\t\t\t\tcout << calc(i) << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX_N 100\ntypedef long long ll;\n\nvector<int> p, q, r, b;\n\nint lcm(ll a, ll b)\n{\n    return a / __gcd(a, b) * b;\n}\n\nint dfs(int v)\n{\n    if (v == -1) return 1;    \n    int lw = dfs(r[v]), rw = dfs(b[v]);\n    int l = lcm(p[v] * lw, q[v] * rw);\n    return l / p[v] + l / q[v];\n}\n \nvoid init(int N)\n{\n    p.resize(N); q.resize(N);\n    r.resize(N); b.resize(N);\n}\n\nint main()\n{\n    int N;\n    while (cin >> N, N) {\n        init(N);\n        bool used[MAX_N] = {};\n        for (int i = 0; i < N; i++) {\n            cin >> p[i] >> q[i] >> r[i] >> b[i];\n            r[i]--; b[i]--;\n            if (r[i] >= 0) used[r[i]] = 1;\n            if (b[i] >= 0) used[b[i]] = 1;\n            int gcd = __gcd(p[i], q[i]);\n            p[i] /= gcd;\n            q[i] /= gcd;\n        }\n        for (int i = 0; i < N; i++) {\n            if (!used[i]) {\n                cout << dfs(i) << endl;\n                break;\n            }            \n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "Haskell",
    "code": "import Control.Monad (replicateM)\nimport Data.Array (listArray,(!))\n\ntype StickInfo = (Int,Int,Int,Int)\ndata Mobile = Stick Integer Integer Mobile Mobile\n            | Weight\n\nmain = do\n    n <- readLn\n    if n == 0 then return () else do\n        ss <- replicateM n (getLine >>= return . stickInfo . map read . words)\n        print $ minWeight $ mobile n ss\n        main\n\n    where\n    stickInfo [a,b,c,d] = (a,b,c,d)\n\nmobile :: Int -> [StickInfo] -> Mobile\nmobile n ss = mobile' root\n    where\n    root = head $ filter (not . (`elem` sub)) [1..n]\n    sub = (map (\\(_,_,a,_)->a) ss) ++ (map (\\(_,_,_,b)->b) ss)\n    sa = listArray (1,n) ss\n\n    mobile' 0 = Weight\n    mobile' n = Stick (fromIntegral a) (fromIntegral b) (mobile' c) (mobile' d)\n        where\n        (a,b,c,d) = sa ! n\n\nminWeight :: Mobile -> Integer\nminWeight Weight = 1\nminWeight (Stick l1 l2 m1 m2) = lcm' `seq` (lcm' `div` l1) + (lcm' `div` l2)\n    where\n    lcm' = lcm (l1 * w1) (l2 * w2)\n    w1 = minWeight m1\n    w2 = minWeight m2"
  },
  {
    "language": "Haskell",
    "code": "import Control.Monad (replicateM)\nimport Data.Array (listArray,(!))\n\ntype StickInfo = (Int,Int,Int,Int)\ndata Mobile = Stick Integer Integer Mobile Mobile\n            | Weight\n\nmain = do\n    n <- readLn\n    if n == 0 then return () else do\n        ss <- replicateM n (getLine >>= return . stickInfo . map read . words)\n        print $ minWeight $ mobile n ss\n        main\n\n    where\n    stickInfo [a,b,c,d] = (a,b,c,d)\n\nmobile :: Int -> [StickInfo] -> Mobile\nmobile n ss = mobile' root\n    where\n    root = head $ filter (not . (`elem` sub)) [1..n]\n    sub = (map (\\(_,_,a,_)->a) ss) ++ (map (\\(_,_,_,b)->b) ss)\n    sa = listArray (1,n) ss\n\n    mobile' 0 = Weight\n    mobile' n = Stick (fromIntegral a) (fromIntegral b) (mobile' c) (mobile' d)\n        where\n        (a,b,c,d) = sa ! n\n\nminWeight :: Mobile -> Integer\nminWeight Weight = 1\nminWeight (Stick l1 l2 m1 m2) = lcm' `seq` (lcm' `div` l2) + (lcm' `div` l1)\n    where\n    lcm' = lcm (l2 * w1) (l1 * w2)\n    w1 = minWeight m1\n    w2 = minWeight m2"
  },
  {
    "language": "Haskell",
    "code": "import Control.Applicative ((<$>))\nimport Control.Monad (replicateM, unless, forM_)\nimport Data.Vector (Vector, (!))\nimport qualified Data.Vector as V\nimport qualified Data.Vector.Mutable as VM\n\nmain :: IO ()\nmain = do\n  n <- readLn\n  unless (n == 0) $ do\n    solve n <$> replicateM n (map read <$> words <$> getLine) >>= print\n    main\n\nsolve :: Int -> [[Int]] -> Int\nsolve n xs = f v rt\n  where v = V.create $ do\n          v <- VM.replicate n (Node (-1) (-1) (-1) (-1) (-1))\n          forM_ (zip [0 .. ] xs) $ \\(i, [p, q, r, b]) -> do\n            (Node _ _ pt _ _) <- VM.read v i\n            let g = gcd p q\n            VM.write v i (Node (p `div` g) (q `div` g) pt (r-1) (b-1))\n            unless (r == 0) $ do\n              (Node p q _ lc rc) <- VM.read v (r-1)\n              VM.write v (r-1) (Node p q i lc rc)\n            unless (b == 0) $ do\n              (Node p q _ lc rc) <- VM.read v (b-1)\n              VM.write v (b-1) (Node p q i lc rc)\n          return v\n        Just rt = V.findIndex (\\nd -> pt nd == (-1)) v\n        f v i | i == (-1) = 1\n              | otherwise = l `div` p + l `div` q\n          where (Node p q _ lc rc) = v ! i\n                lw = f v lc\n                rw = f v rc\n                l = lcm (p * lw) (q * rw)\n\ndata Node = Node {p :: Int, q :: Int, pt :: Int, lc :: Int, rc :: Int } deriving Show\n\n"
  },
  {
    "language": "Haskell",
    "code": "import Control.Applicative\nimport Control.Monad\nimport Control.Monad.ST\nimport Data.Functor\nimport Data.Function\nimport Data.Monoid\nimport Data.Maybe\nimport Data.List\nimport qualified Data.Foldable as Foldable\nimport qualified Data.Set as Set\nimport Data.List.Split\nimport Data.Bits\nimport Data.Char\nimport Data.Ix\nimport Data.Ratio\nimport Data.Ord\nimport Data.Tuple\nimport Data.Array\n--import Data.Array.Unboxed\nimport Data.Array.IO\nimport Data.Array.ST\nimport Data.IORef\nimport Data.STRef\n-- import System.IO.Unsafe\n \nreadInt = read :: String -> Int\nreadDouble = read :: String -> Double\ngetInt = readLn :: IO Int\ngetInts = map readInt . words <$> getLine\ngetDouble = readLn :: IO Double\nsjoin :: (Show a) => [a] -> String\nsjoin = unwords . map show\ncond :: a -> a -> Bool -> a\ncond t f c = if c then t else f\napply2 :: (a -> a -> b) -> [a] -> b\napply2 f [x,y] = f x y\napply3 :: (a -> a -> a -> b) -> [a] -> b\napply3 f [x,y,z] = f x y z\napply4 :: (a -> a -> a -> a -> b) -> [a] -> b\napply4 f [x,y,z,w] = f x y z w\nfnBin :: (b -> c -> d) -> (a -> b) -> (a -> c) -> a -> d\nfnBin op f g x = op (f x) $ g x\nfnTuple :: (a -> b, a -> c) -> a -> (b, c)\nfnTuple (f,g) a = (f a, g a)\nreplace :: (Eq a) => a -> a -> [a] -> [a]\nreplace x y = map (\\z -> if z==x then y else z)\nmodifyArray :: (Ix i, MArray a e m) => a i e -> i -> (e -> e) -> m ()\nmodifyArray arr ix f = readArray arr ix >>= writeArray arr ix . f\n-- end of templete\n\nf arr 0 = 1\nf arr k = wl + wr\n  where\n    (ll, lr, kl, kr) = arr!k\n    fl = f arr kl\n    fr = f arr kr\n    lgcd = gcd ll lr\n    rl = ll `div` lgcd\n    rr = lr `div` lgcd\n    wb = lcm (fl * rl) (fr * rr)\n    wl = wb `div` rl\n    wr = wb `div` rr\n\nfindRoot n xs = fst $ head $ dropWhile (uncurry (==)) $ zip [1..n] $ xs ++ [-1]\n\nmain = do\n    n <- getInt\n    when (n/=0) $ do\n        ds <- map (apply4 (,,,)) <$> replicateM n getInts\n        let arr = listArray (1,n) ds :: Array Int (Int,Int,Int,Int)\n        let notRoot = sort $ [x | (_,_,x,_) <- ds, x/=0] ++ [y | (_,_,_,y) <- ds, y/=0]\n        print $ f arr $ findRoot n notRoot\n        main"
  },
  {
    "language": "Haskell",
    "code": "import Control.Applicative\nimport Control.Monad\nimport Control.Monad.ST\nimport Data.Functor\nimport Data.Function\nimport Data.Monoid\nimport Data.Maybe\nimport Data.List\nimport qualified Data.Foldable as Foldable\nimport qualified Data.Set as Set\nimport Data.List.Split\nimport Data.Bits\nimport Data.Char\nimport Data.Ix\nimport Data.Ratio\nimport Data.Ord\nimport Data.Tuple\nimport Data.Array\n--import Data.Array.Unboxed\nimport Data.Array.IO\nimport Data.Array.ST\nimport Data.IORef\nimport Data.STRef\n-- import System.IO.Unsafe\n \nreadInt = read :: String -> Int\nreadDouble = read :: String -> Double\ngetInt = readLn :: IO Int\ngetInts = map readInt . words <$> getLine\ngetDouble = readLn :: IO Double\nsjoin :: (Show a) => [a] -> String\nsjoin = unwords . map show\ncond :: a -> a -> Bool -> a\ncond t f c = if c then t else f\napply2 :: (a -> a -> b) -> [a] -> b\napply2 f [x,y] = f x y\napply3 :: (a -> a -> a -> b) -> [a] -> b\napply3 f [x,y,z] = f x y z\napply4 :: (a -> a -> a -> a -> b) -> [a] -> b\napply4 f [x,y,z,w] = f x y z w\nfnBin :: (b -> c -> d) -> (a -> b) -> (a -> c) -> a -> d\nfnBin op f g x = op (f x) $ g x\nfnTuple :: (a -> b, a -> c) -> a -> (b, c)\nfnTuple (f,g) a = (f a, g a)\nreplace :: (Eq a) => a -> a -> [a] -> [a]\nreplace x y = map (\\z -> if z==x then y else z)\nmodifyArray :: (Ix i, MArray a e m) => a i e -> i -> (e -> e) -> m ()\nmodifyArray arr ix f = readArray arr ix >>= writeArray arr ix . f\n-- end of templete\n\nf arr 0 = 1\nf arr k = wl + wr\n  where\n    (ll, lr, kl, kr) = arr!k\n    rl = f arr kl\n    rr = f arr kr\n    prd = lcm (rl*lr) (rr*ll)\n    wl = prd `div` ll\n    wr = prd `div` lr\n\nfindRoot n xs = fst $ head $ dropWhile (uncurry (==)) $ zip [1..n] $ xs ++ [-1]\n\nmain = do\n    n <- getInt\n    when (n/=0) $ do\n        ds <- map (apply4 (,,,)) <$> replicateM n getInts\n        let arr = listArray (1,n) ds :: Array Int (Int,Int,Int,Int)\n        let notRoot = sort $ [x | (_,_,x,_) <- ds, x/=0] ++ [y | (_,_,_,y) <- ds, y/=0]\n        print $ f arr $ findRoot n notRoot\n        main"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint gcm(int a,int b){\n\tint c;\n\tif(b>a)c=a,a=b,b=c;\n\twhile(1){\n\t\tc=a%b;\n\t\ta=b,b=c;\n\t\tif(c==0)return a;\n\t}\n}\nint p[105],q[105],r[105],b[105],w[105];\nint func(int m){\n\tint s,t;\n\ts=gcm(p[m],q[m]);\n\tif(w[m]>0)return w[m];\n\tif(r[m]==0 && b[m]>0){\n\t\tt=gcm(q[m]/s,func(b[m]));\n\t\tw[m]=(q[m]/s)*func(b[m])/t*(p[m]/s+q[m]/s)/(q[m]/s);\n\t}else if(r[m]>0 && b[m]==0){\n\t\tt=gcm(p[m]/s,func(r[m]));\n\t\tw[m]=(p[m]/s)*func(r[m])/t*(p[m]/s+q[m]/s)/(p[m]/s);\n\t}else if(r[m]>0 && b[m]>0){\n\t\tt=gcm(p[m]/s*func(b[m]),q[m]/s*func(r[m]));\n\t\tw[m]=func(r[m])*p[m]/s*func(b[m])/t+func(b[m])*q[m]/s*func(r[m])/t;\n\t}\n\treturn w[m];\n}\nint main(){\n\tint n,i,j,f,x,y,ans;\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tmemset(w,-1,sizeof(w));\n\t\tfor(i=1;i<=n;i++){\n\t\t\tscanf(\"%d%d%d%d\",&p[i],&q[i],&r[i],&b[i]);\n\t\t\tif(r[i]==0 && b[i]==0){\n\t\t\t\tx=gcm(p[i],q[i]);\n\t\t\t\tw[i]=p[i]/x+q[i]/x;\n\t\t\t}\n\t\t}\n\t\tans=0;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tif(func(i)>ans)ans=func(i);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\ntypedef struct mobile {\n  int ll;\n  int lr;\n  int il;\n  int ir;\n  int w;\n} mb;\nmb a[101];\nint gcd(int a,int b)\n{\n  int r = a % b;\n  if (r == 0) return b;\n  return gcd(b,r);\n}\nint lcm(int a,int b)\n{\n  int g = a > b ? gcd(a,b) : gcd(b,a);\n  return a / g * b;\n}\nint weight(int i)\n{\n  mb *p = &a[i];\n  int lw,rw,g;\n  if (i == 0) return 1;\n  if (p->w != 0) return p->w;\n  lw = weight(p->il);\n  rw = weight(p->ir);\n  lw /= (lw > p->lr) ? gcd(lw,p->lr) : gcd(p->lr,lw);\n  rw /= (rw > p->ll) ? gcd(rw,p->ll) : gcd(p->ll,rw);\n  p->w = (p->ll + p->lr) * lcm(lw,rw);\n  return p->w;\n}\nint main()\n{\n  int n,i,j,w,mw;\n  for(;;){\n    scanf(\"%d\",&n);\n    if(n == 0) break;\n    memset(a,0,sizeof(a));\n    for(i=1;i<=n;i++){\n      scanf(\"%d%d%d%d\",&a[i].ll,&a[i].lr,&a[i].il,&a[i].ir);\n      j = a[i].ll > a[i].lr ? gcd(a[i].ll,a[i].lr) : gcd(a[i].lr,a[i].ll);\n      if(j != 0){\n\ta[i].ll /= j;\n\ta[i].lr /= j;\n      }\n    }\n    mw = 0;\n    for(i=1;i<=n;i++){\n      w = weight(i);\n      if(mw<w) mw = w;\n    }\n    printf(\"%d\\n\",mw);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A0520\nLightest Mobile\n*/\n#include <stdio.h>\n\n\nstruct MOB\n{\n  int leftlen   ;int rightlen;\n  int leftnode  ;int rightnode;\n} ;\nstruct MOB mobiles[100];\n/*\nstruct MOB mobiles1[]=   {{1, 2, 0, 0},{1, 2, 0, 0},{1, 2, 1, 2},{1, 2, 3, 0}};\nstruct MOB mobiles2[]=   {{3, 2, 0, 4},{1, 3, 0, 0},{4, 4, 2, 1},{2, 2, 0, 0}};\nstruct MOB mobiles3[]=   {{1, 2, 0, 0},{1, 2, 0, 0},{1, 2, 1, 2},{1, 2, 3, 0},{1,2,4,0}};\n*/\n\nlong int gcd(long int x,long int y)\n{ long int w,r;\n  if(x < y)\n    {\n      w = x;\n      x = y;\n      y=  w;\n    }\n  if((r = x % y) ==0)\n    return(y);\n  return(gcd (y, r));\n}\n\nlong int lcm(long int x,long int y)\n{\n  return(x/gcd(x,y)*y);\n}\n\nlong int calc_total_weight1(int leftlen, int rightlen,long int leftweight , long int rightweight)\n{\n/*\n  long int l;\n\n  l=lcm((leftlen *rightweight),(rightlen * leftweight));\n  return(l/leftlen+l/rightlen);\n*/\n  long int g;\n  g = gcd(leftlen *rightweight,rightlen * leftweight);\n  return(leftweight*rightweight*(leftlen+rightlen)/g);\n}\n\nlong int calc_total_weight(struct MOB *m,int node_no)\n{ long int w1,w2,tw;\n  struct MOB * bar;\n  bar = m + (node_no - 1);\n\n/*Dprintf(\"%d L=%d R=%d\\n\",node_no,bar->leftnode,bar->rightnode);  */\n  if(bar -> leftnode != 0)\n    w1 = calc_total_weight(m,(bar->leftnode));\n  else\n    w1 = 1;\n  if(bar -> rightnode != 0)\n    w2 = calc_total_weight(m,(bar->rightnode));\n  else\n    w2 = 1;\n\n  tw = calc_total_weight1(bar->leftlen,bar->rightlen,w1,w2);\n/*Dprintf(\"tw=%ld\\n\",tw);*/\n  return(tw);\n    \n}\n\nint search_root(struct MOB * m,int siz)\n{\n  int i,j;\n  for(i=1;i<=siz;i++)\n    {  for(j=0;j<siz;j++)\n      {\n        if(m[j].leftnode == i ||m[j].rightnode == i)\n          goto AAA;\n      }\n      return(i);\n    AAA:\n      ;\n    }\n   return(-1);\n\n}\n\n\nmain()\n{\nint i;\nlong int total_weight;\nint  root;\nint  cnt;\n  \n  while(EOF != scanf(\"%d\",&cnt))\n    {     \n      for(i=0;i<cnt;i++)\n         scanf(\" %d %d %d %d\",\n               &(mobiles[i].leftlen),\n               &(mobiles[i].rightlen),\n               &(mobiles[i].leftnode),\n               &(mobiles[i].rightnode));\n    \n\n/*\n  for(i=0;i<4;i++)\n    {\n         printf(\" %d %d %d %d\\n\",\n               (mobiles[i].leftlen),\n               (mobiles[i].rightlen),\n               (mobiles[i].leftnode),\n               (mobiles[i].rightnode));\n    }\n*/\n  \n  root = search_root(mobiles,cnt);    \n  total_weight = calc_total_weight(mobiles,root);\n\n  printf(\"%ld\\n\",total_weight);\n    }\nreturn(0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#define min(a,b) (a<b?a:b)\nstruct x{int p,q,r,b;}B[105];\nint N,i,j,h[105],r,t;\n\nint gcd(int a,int b)\n{\n\tint c;\n\tfor(;b!=0;)\n\t{\n\t\tc=a%b;a=b;b=c;\n\t}\n\treturn a;\n}\n\nint dfs(int p)\n{\n\tint r,b,i,j,ta,tb,ri,rj,t1,t2;\n\tif(p==-1)return 1;\n\tif(h[p]>=0)return h[p];\n\tr=dfs(B[p].r);\n\tb=dfs(B[p].b);\n\tt1=10000000/(r*B[p].p),t2=10000000/(b*B[p].q);\n\ti=j=-1;\n\tri=t1;\n\trj=t2;\n\tfor(i=1;i<=min(t1,t2);i++)\n\t{\n\t\tif((r*i*B[p].p)%(b*B[p].q))continue;\n\t\tj=(r*i*B[p].p)/(b*B[p].q);\n\t\tta=r*i/B[p].q;\n\t\ttb=b*j/B[p].p;\n\t\tif(ta&&tb&&ta==tb)\n\t\t{\n\t\t\tif(ri*r+rj*b>i*r+j*b)\n\t\t\t{\n\t\t\t\tri=i;\n\t\t\t\trj=j;\n\t\t\t}\n\t\t}\n\t}\n\tif(j==-1)ri=rj=(r*b)/gcd(r,b);\n\t//printf(\"%d %d:%d %d:%d %d:%d\\n\",p,r,b,B[p].p,B[p].q,r*ri,b*rj);\n\treturn h[p]=r*ri+b*rj;\n}\n\nint main()\n{\n\tfor(;scanf(\"%d\",&N),N;)\n\t{\n\t\tmemset(h,-1,sizeof(h));\n\t\tfor(i=0;i<N;i++)\n\t\t{\n\t\t\tscanf(\"%d%d%d%d\",&B[i].p,&B[i].q,&B[i].r,&B[i].b);\n\t\t\tt=gcd(B[i].p,B[i].q);\n\t\t\tB[i].p/=t;B[i].q/=t;\n\t\t\tB[i].r--;B[i].b--;\n\t\t}\n\t\tfor(i=r=0;i<N;i++)\n\t\t{\n\t\t\tt=dfs(i);\n\t\t\tr=r>t?r:t;\n\t\t}\n\t\tprintf(\"%d\\n\",r);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\ntypedef struct _node{\n\tint p;\n\tint q;\n\tint r;\n\tint b;\n\tint left;\t//p-side mass\n\tint right;\t//q-side mass\n} Node;\nint calc_mass(int trgt);\nint calc_gcd( int a, int b);\nNode MOB[101];\n\nint main(){\n\n\tint n;\n\tint chk[101];\n\tint i;\n\tint p;\n\tint q;\n\tint r;\n\tint b;\n\tint Top;\n\tint Total;\n\tint gcd;\n\n\twhile(1){\n\t\tscanf(\"%d\\n\",&n);\n\t\tif(n==0)break;\n\n\t\tfor(i=1;i<=n;i++){\n\t\t\tscanf(\"%d %d %d %d\\n\",&p,&q,&r,&b);\n\t\t\tgcd=calc_gcd(p,q);\n\t\t\tMOB[i].p=p/gcd;\n\t\t\tMOB[i].q=q/gcd;\n\t\t\tMOB[i].r=r;\n\t\t\tMOB[i].b=b;\n\t\t\tMOB[i].left=0;\n\t\t\tMOB[i].right=0;\n\t\t\t\n\t\t}\n\t\t\n\t\t// search TOP;\n\t\tfor(i=1;i<=n;i++)chk[i]=0;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tif(MOB[i].r!=0)chk[MOB[i].r]=1;\n\t\t\tif(MOB[i].b!=0)chk[MOB[i].b]=1;\n\t\t}\n\t\tfor(i=1;i<=n;i++){\n\t\t\tif(chk[i]==0)Top=i;\n\t\t}\n\t\tTotal=calc_mass(Top);\n\t\tprintf(\"%d\\n\",Total);\n\n\t}\n\treturn 0;\n}\n\n\nint calc_gcd( int a, int b){\n\t int c=1;\n\t int gcd;\n\n        if(a==0 || b==0)return 0;\n\n        if(a<b){\n            c=a,a=b,b=c;\n        }\n\n        gcd=1;\n\t\n\twhile(a%b!=0){\n\t\tc=b;\n\t\tb=a%b;\n\t\ta=c;\n\t}\n\tgcd=b;\n\n\treturn gcd;\n\n}\n\n\n\nint calc_mass(int trgt){\n\tint gcd;\n\tint left,right;\n\n\tif(MOB[trgt].r==0 && MOB[trgt].b==0){\n\t\tgcd=calc_gcd(MOB[trgt].p,MOB[trgt].q);\n\t\tMOB[trgt].left=MOB[trgt].q/gcd;\n\t\tMOB[trgt].right=MOB[trgt].p/gcd;\n\t\treturn MOB[trgt].left+MOB[trgt].right;\n\t}\n\t\n\tif(MOB[trgt].left==0){\n\t\tif(MOB[trgt].r==0)left=1;\n\t\tif(MOB[trgt].r!=0)left=calc_mass(MOB[trgt].r);\n\t}\n\tif(MOB[trgt].right==0){\n\t\tif(MOB[trgt].b==0)right=1;\n\t\tif(MOB[trgt].b!=0)right=calc_mass(MOB[trgt].b);\n\t}\n\t\n\tgcd=calc_gcd(left*MOB[trgt].q,right*MOB[trgt].p);\n\tMOB[trgt].left=left*right*MOB[trgt].p/gcd;\n\tMOB[trgt].right=right*left*MOB[trgt].q/gcd;\n\treturn MOB[trgt].left+MOB[trgt].right;\n\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#define min(a,b) (a<b?a:b)\nstruct x{int p,q,r,b;}B[105];\nint N,i,j,h[105],r,t;\n\nint gcd(int a,int b)\n{\n\tint c;\n\tfor(;b!=0;)\n\t{\n\t\tc=a%b;a=b;b=c;\n\t}\n\treturn a;\n}\n\nint dfs(int p)\n{\n\tint r,b,i,j,ta,tb,ri,rj,t1,t2;\n\tif(p==-1)return 1;\n\tif(h[p]>=0)return h[p];\n\tr=dfs(B[p].r);\n\tb=dfs(B[p].b);\n\tfor(i=1,ri=rj=-1;i<=100000;i++)\n\t{\n\t\tif((r*i*B[p].p)%(b*B[p].q))continue;\n\t\tj=(r*i*B[p].p)/(b*B[p].q);\n\t\tta=r*i/B[p].q;\n\t\ttb=b*j/B[p].p;\n\t\tif(ta&&tb&&ta==tb)\n\t\t{\n\t\t\tif(ri==-1||ri*r+rj*b>i*r+j*b)\n\t\t\t{\n\t\t\t\tri=i;\n\t\t\t\trj=j;\n\t\t\t\tgoto e;\n\t\t\t}\n\t\t}\n\t}\n\te:\n\tif(rj==-1)ri=rj=(r*b)/gcd(r,b);\n\treturn h[p]=r*ri+b*rj;\n}\n\nint main()\n{\n\tfor(;scanf(\"%d\",&N),N;)\n\t{\n\t\tmemset(h,-1,sizeof(h));\n\t\tfor(i=0;i<N;i++)\n\t\t{\n\t\t\tscanf(\"%d%d%d%d\",&B[i].p,&B[i].q,&B[i].r,&B[i].b);\n\t\t\tt=gcd(B[i].p,B[i].q);\n\t\t\tB[i].p/=t;B[i].q/=t;\n\t\t\tB[i].r--;B[i].b--;\n\t\t}\n\t\tfor(i=r=0;i<N;i++)\n\t\t{\n\t\t\tt=dfs(i);\n\t\t\tr=r>t?r:t;\n\t\t}\n\t\tprintf(\"%d\\n\",r);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\ntypedef struct _node{\n\tlong long int p;\n\tlong long int q;\n\tint r;\n\tint b;\n\tlong long int left;\t//p-side mass\n\tlong long int right;\t//q-side mass\n} Node;\nlong long int calc_mass(int trgt);\nlong long int calc_gcd( long long int a,long long int b);\nNode MOB[101];\n\nint main(){\n\n\tint n;\n\tint chk[101];\n\tint i;\n\tlong long int p;\n\tlong long int q;\n\tint r;\n\tint b;\n\tint Top;\n\tlong long int Total;\n\tlong long int gcd;\n\n\twhile(1){\n\t\tscanf(\"%d\\n\",&n);\n\t\tif(n==0)break;\n\n\t\tfor(i=1;i<=n;i++){\n\t\t\tscanf(\"%lld %lld %d %d\\n\",&p,&q,&r,&b);\n\t\t\tgcd=calc_gcd(p,q);\n\t\t\tMOB[i].p=p/gcd;\n\t\t\tMOB[i].q=q/gcd;\n\t\t\tMOB[i].r=r;\n\t\t\tMOB[i].b=b;\n\t\t\tMOB[i].left=0;\n\t\t\tMOB[i].right=0;\n\t\t\t\n\t\t}\n\t\t\n\t\t// search TOP;\n\t\tfor(i=1;i<=n;i++)chk[i]=0;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tif(MOB[i].r!=0)chk[MOB[i].r]=1;\n\t\t\tif(MOB[i].b!=0)chk[MOB[i].b]=1;\n\t\t}\n\t\tfor(i=1;i<=n;i++){\n\t\t\tif(chk[i]==0){\n\t\t\t\tTop=i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tTotal=calc_mass(Top);\n\t\tprintf(\"%lld\\n\",Total);\n\n\t}\n\treturn 0;\n}\n\n\nlong long int calc_gcd( long long int a, long long int b){\n\tlong long int c=1;\n\tlong long int gcd;\n\n//\tif(a==0 || b==0)return 0;\n//\tif(a==1 || b==1)return 1;\n\n//\tif(a<b){\n//\t\tc=a,a=b,b=c;\n//\t}\n\n        gcd=1;\n\t\n\twhile(a%b!=0){\n\t\tc=b;\n\t\tb=a%b;\n\t\ta=c;\n\t}\n\tgcd=b;\n\n\treturn gcd;\n\n}\n\n\n\nlong long int calc_mass(int trgt){\n\tlong long int gcd;\n\tlong long int left,right;\n\n\tif(MOB[trgt].r==0 && MOB[trgt].b==0){\n\t\tgcd=calc_gcd(MOB[trgt].p,MOB[trgt].q);\n\t\tMOB[trgt].left=MOB[trgt].q/gcd;\n\t\tMOB[trgt].right=MOB[trgt].p/gcd;\n\t\treturn MOB[trgt].left+MOB[trgt].right;\n\t}\n\t\n\tif(MOB[trgt].left==0){\n\t\tif(MOB[trgt].r==0)left=1;\n\t\tif(MOB[trgt].r!=0)left=calc_mass(MOB[trgt].r);\n\t}\n\tif(MOB[trgt].right==0){\n\t\tif(MOB[trgt].b==0)right=1;\n\t\tif(MOB[trgt].b!=0)right=calc_mass(MOB[trgt].b);\n\t}\n\t\n\tgcd=calc_gcd(left*MOB[trgt].q,right*MOB[trgt].p);\n\tMOB[trgt].left=left*right*MOB[trgt].p/gcd;\n\tMOB[trgt].right=right*left*MOB[trgt].q/gcd;\n\treturn MOB[trgt].left+MOB[trgt].right;\n\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\ntypedef struct mobile {\n  int ll;\n  int lr;\n  int il;\n  int ir;\n  int w;\n} mb;\nmb a[101];\nint gcd(int a,int b)\n{\n  int r = a % b;\n  if (r == 0) return b;\n  return gcd(b,r);\n}\nint lcm(int a,int b)\n{\n  int g = a > b ? gcd(a,b) : gcd(b,a);\n  return a * b / g;\n}\nint weight(int i)\n{\n  mb *p = &a[i];\n  if (i == 0) return 1;\n  if (p->w != 0) return p->w;\n  p->w = (p->ll + p->lr) * lcm(weight(p->il),weight(p->ir));\n  return p->w;\n}\nint main()\n{\n  int n,i,j,w,mw;\n  for(;;){\n    scanf(\"%d\",&n);\n    if(n == 0) break;\n    memset(a,0,sizeof(a));\n    for(i=1;i<=n;i++){\n      scanf(\"%d%d%d%d\",&a[i].ll,&a[i].lr,&a[i].il,&a[i].ir);\n      j = a[i].ll > a[i].lr ? gcd(a[i].ll,a[i].lr) : gcd(a[i].lr,a[i].ll);\n      a[i].ll /= j;\n      a[i].lr /= j;\n    }\n    mw = 0;\n    for(i=1;i<=n;i++){\n      w = weight(i);\n      if(mw<w) mw = w;\n    }\n    printf(\"%d\\n\",mw);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "/* \nAizuOnline A0520\nLightest Mobile\n2013/1/17 TE->WA\n*/\n#include <stdio.h>\n\n\nstruct MOB\n{\n        int leftlen;\n        int rightlen;\n        int leftnode  ;\n        int rightnode;\n} ;\n\nstruct MOB mobiles[100];\nint gcd(int x, int y){\n\treturn y == 0 ? x: gcd(y, x%y);\n}\n\n\nlong int lcm(long int x,long int y)\n{\n  return(x/gcd(x,y)*y);\n}\n\nint calc_total_weight1(int leftlen,int rightlen,int leftweight,int rightweight)\n{\n        int l;\n  // printf(\"%d %d %ld %ld\\n\",leftlen,rightlen,leftweight,rightweight);\n        l=lcm((leftlen *rightweight),(rightlen * leftweight));\n        return(l/leftlen+l/rightlen);\n}\n\nint calc_total_weight(struct MOB *m,int node_no)\n{ \n        int w1,w2,tw;\n        struct MOB * bar;\n        bar = m + (node_no - 1);\n\n\n        if(bar -> leftnode != 0)\n                w1 = calc_total_weight(m,(bar->leftnode));\n        else\n                w1 = 1;\n        if(bar -> rightnode != 0)\n                w2 = calc_total_weight(m,(bar->rightnode));\n        else\n                w2 = 1;\n\n        tw = calc_total_weight1(bar->leftlen,bar->rightlen,w1,w2);\n\n        return(tw);\n    \n}\n\nint search_root(struct MOB * m,int siz)\n{\n        int i,j;\n        for(i=1;i<=siz;i++)\n        {  \n                for(j=0;j<siz;j++)\n                {\n                        if(m[j].leftnode == i ||m[j].rightnode == i)\n                                goto AAA;\n                }\n                return(i);\n        AAA:\n                ;\n        }\n        return(-1);\n}\n\n\nmain()\n{\n        int i;\n        int total_weight;\n        int  root;\n        int  cnt;\n  \n        while(EOF != scanf(\"%d\",&cnt) && cnt)\n        {     \n                for(i=0;i<cnt;i++)\n                        scanf(\" %d %d %d %d\",\n                              &(mobiles[i].leftlen),\n                              &(mobiles[i].rightlen),\n                              &(mobiles[i].leftnode),\n                              &(mobiles[i].rightnode));\n    \n  \n                root = search_root(mobiles,cnt);    \n                total_weight = calc_total_weight(mobiles,root);\n\n                printf(\"%d\\n\",total_weight);\n        }\n        return(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\ntypedef struct _node{\n\tunsigned int p;\n\tunsigned int q;\n\tunsigned int r;\n\tunsigned int b;\n\tunsigned int left;\t//p-side mass\n\tunsigned int right;\t//q-side mass\n} Node;\nunsigned int calc_mass(unsigned int trgt);\nunsigned int calc_gcd( unsigned int a, unsigned int b);\nNode MOB[101];\n\nint main(){\n\n\tunsigned int n;\n\tunsigned int chk[101];\n\tunsigned int i;\n\tunsigned int p;\n\tunsigned int q;\n\tunsigned int r;\n\tunsigned int b;\n\tunsigned int Top;\n\tunsigned int Total;\n\tunsigned int gcd;\n\n\twhile(1){\n\t\tscanf(\"%u\\n\",&n);\n\t\tif(n==0)break;\n\n\t\tfor(i=1;i<=n;i++){\n\t\t\tscanf(\"%u %u %u %u\\n\",&p,&q,&r,&b);\n\t\t\tgcd=calc_gcd(p,q);\n\t\t\tMOB[i].p=p/gcd;\n\t\t\tMOB[i].q=q/gcd;\n\t\t\tMOB[i].r=r;\n\t\t\tMOB[i].b=b;\n\t\t\tMOB[i].left=0;\n\t\t\tMOB[i].right=0;\n\t\t\t\n\t\t}\n\t\t\n\t\t// search TOP;\n\t\tfor(i=1;i<=n;i++)chk[i]=0;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tif(MOB[i].r!=0)chk[MOB[i].r]=1;\n\t\t\tif(MOB[i].b!=0)chk[MOB[i].b]=1;\n\t\t}\n\t\tfor(i=1;i<=n;i++){\n\t\t\tif(chk[i]==0)Top=i;\n\t\t}\n\t\tTotal=calc_mass(Top);\n\t\tprintf(\"%u\\n\",Total);\n\n\t}\n\treturn 0;\n}\n\n\nunsigned int calc_gcd( unsigned int a, unsigned int b){\n\t unsigned int c=1;\n\t unsigned int gcd;\n\n        if(a==0 || b==0)return 0;\n        if(a==1 || b==1)return 1;\n\n        if(a<b){\n            c=a,a=b,b=c;\n        }\n\n        gcd=1;\n\t\n\twhile(a%b!=0){\n\t\tc=b;\n\t\tb=a%b;\n\t\ta=c;\n\t}\n\tgcd=b;\n\n\treturn gcd;\n\n}\n\n\n\nunsigned int calc_mass(unsigned int trgt){\n\tunsigned int gcd;\n\tunsigned int left,right;\n\tunsigned int left2,right2;\n\tunsigned int ratio;\n\n//\tif(MOB[trgt].r==0 && MOB[trgt].b==0){\n//\t\tgcd=calc_gcd(MOB[trgt].p,MOB[trgt].q);\n//\t\tMOB[trgt].left=MOB[trgt].q/gcd;\n//\t\tMOB[trgt].right=MOB[trgt].p/gcd;\n//\t\treturn MOB[trgt].left+MOB[trgt].right;\n//\t}\n\t\n\tif(MOB[trgt].left==0){\n\t\tif(MOB[trgt].r==0)left=1;\n\t\tif(MOB[trgt].r!=0)left=calc_mass(MOB[trgt].r);\n\t}\n\tif(MOB[trgt].right==0){\n\t\tif(MOB[trgt].b==0)right=1;\n\t\tif(MOB[trgt].b!=0)right=calc_mass(MOB[trgt].b);\n\t}\n\t\n\n\n\tgcd=calc_gcd(right,left);\n\tleft2=left/gcd,right2=right/gcd;\n\tgcd=calc_gcd(left2*MOB[trgt].q,right2*MOB[trgt].p);\n\tratio=(right2*MOB[trgt].p)/gcd;\n\tMOB[trgt].left=left*ratio;\n\t\n\tratio=(left2*MOB[trgt].q)/gcd;\n\tMOB[trgt].right=right*ratio;\n\t\n\treturn MOB[trgt].left+MOB[trgt].right;\n\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\ntypedef struct {\n\tlong long p,q,r,b;\n} mobile;\n\nmobile bar[100];\nlong long data[100];\n\nlong long kbs(long long a, long long b){\n\tif(a>b){\n\t\tif(a%b==0) return b;\n\t\telse return kbs(a%b,b);\n\t}else{\n\t\tif(b%a==0) return a;\n\t\telse return kbs(a,b%a);\n\t}\n}\n\nlong long weight(int i){\n\tif(data[i-1]>0) return data[i-1];\n\tlong long j;\n\tif(bar[i-1].r==0 && bar[i-1].b==0){\n\t\tj=kbs(bar[i-1].p,bar[i-1].q);\n\t\treturn data[i-1]=bar[i-1].p/j+bar[i-1].q/j;\n\t}else if(bar[i-1].r==0){\n\t\tb=bar[i-1].q*weight(bar[i-1].b);\n\t\tj=kbs(bar[i-1].p,b);\n\t\treturn data[i-1]=weight(bar[i-1].b)*bar[i-1].p/j+b/j;\n\t}else if(bar[i-1].b==0){\n\t\ta=bar[i-1].p*weight(bar[i-1].r);\n\t\tj=kbs(bar[i-1].q,a);\n\t\treturn data[i-1]=weight(bar[i-1].r)*bar[i-1].q/j+a/j;\n\t}else{\n\t\ta=bar[i-1].q*weight(bar[i-1].b);\n\t\tb=bar[i-1].p*weight(bar[i-1].r);\n\t\tj=kbs(a,b);\n\t\treturn data[i-1]=weight(bar[i-1].r)*b/j+weight(bar[i-1].b)*a/j;\n\t}\n}\n\nint main(){\n\tint n,i;\n\tlong long heavy,max;\n\tscanf(\"%d\",&n);\n\twhile(n!=0){\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%lld %lld %lld %lld\",&bar[i].p,&bar[i].q,&bar[i].r,&bar[i].b);\n\t\t}\n\t\tfor(i=0;i<n;i++){\n\t\t\tdata[i]=0;\n\t\t}\n\t\theavy=0;\n\t\tmax=0;\n\t\tfor(i=1;i<=n;i++){\n\t\t\theavy=weight(i);\n\t\t\tmax=max<heavy?heavy:max;\n\t\t}\n\t\tprintf(\"%lld\\n\",max);\n\t\tscanf(\"%d\",&n);\n\t}\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\ntypedef struct _node{\n\tunsigned int p;\n\tunsigned int q;\n\tunsigned int r;\n\tunsigned int b;\n\tunsigned int left;\t//p-side mass\n\tunsigned int right;\t//q-side mass\n} Node;\nunsigned int calc_mass(unsigned int trgt);\nunsigned int calc_gcd( unsigned int a, unsigned int b);\nNode MOB[101];\n\nunsigned int main(){\n\n\tunsigned int n;\n\tunsigned int chk[101];\n\tunsigned int i;\n\tunsigned int p;\n\tunsigned int q;\n\tunsigned int r;\n\tunsigned int b;\n\tunsigned int Top;\n\tunsigned int Total;\n\tunsigned int gcd;\n\n\twhile(1){\n\t\tscanf(\"%u\\n\",&n);\n\t\tif(n==0)break;\n\n\t\tfor(i=1;i<=n;i++){\n\t\t\tscanf(\"%u %u %u %u\\n\",&p,&q,&r,&b);\n\t\t\tgcd=calc_gcd(p,q);\n\t\t\tMOB[i].p=p/gcd;\n\t\t\tMOB[i].q=q/gcd;\n\t\t\tMOB[i].r=r;\n\t\t\tMOB[i].b=b;\n\t\t\tMOB[i].left=0;\n\t\t\tMOB[i].right=0;\n\t\t\t\n\t\t}\n\t\t\n\t\t// search TOP;\n\t\tfor(i=1;i<=n;i++)chk[i]=0;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tif(MOB[i].r!=0)chk[MOB[i].r]=1;\n\t\t\tif(MOB[i].b!=0)chk[MOB[i].b]=1;\n\t\t}\n\t\tfor(i=1;i<=n;i++){\n\t\t\tif(chk[i]==0)Top=i;\n\t\t}\n\t\tTotal=calc_mass(Top);\n\t\tprintf(\"%u\\n\",Total);\n\n\t}\n\treturn 0;\n}\n\n\nunsigned int calc_gcd( unsigned int a, unsigned int b){\n\t unsigned int c=1;\n\t unsigned int gcd;\n\n        if(a==0 || b==0)return 0;\n        if(a==1 || b==1)return 1;\n\n        if(a<b){\n            c=a,a=b,b=c;\n        }\n\n        gcd=1;\n\t\n\twhile(a%b!=0){\n\t\tc=b;\n\t\tb=a%b;\n\t\ta=c;\n\t}\n\tgcd=b;\n\n\treturn gcd;\n\n}\n\n\n\nunsigned int calc_mass(unsigned int trgt){\n\tunsigned int gcd;\n\tunsigned int left,right;\n\n\tif(MOB[trgt].r==0 && MOB[trgt].b==0){\n\t\tgcd=calc_gcd(MOB[trgt].p,MOB[trgt].q);\n\t\tMOB[trgt].left=MOB[trgt].q/gcd;\n\t\tMOB[trgt].right=MOB[trgt].p/gcd;\n\t\treturn MOB[trgt].left+MOB[trgt].right;\n\t}\n\t\n\tif(MOB[trgt].left==0){\n\t\tif(MOB[trgt].r==0)left=1;\n\t\tif(MOB[trgt].r!=0)left=calc_mass(MOB[trgt].r);\n\t}\n\tif(MOB[trgt].right==0){\n\t\tif(MOB[trgt].b==0)right=1;\n\t\tif(MOB[trgt].b!=0)right=calc_mass(MOB[trgt].b);\n\t}\n\t\n\tgcd=calc_gcd(left*MOB[trgt].q,right*MOB[trgt].p);\n\tMOB[trgt].left=left*right*MOB[trgt].p/gcd;\n\tMOB[trgt].right=right*left*MOB[trgt].q/gcd;\n\treturn MOB[trgt].left+MOB[trgt].right;\n\n}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A0520\nLightest Mobile\n*/\n#include <stdio.h>\n\n\nstruct MOB\n{\n  int leftlen   ;int rightlen;\n  int leftnode  ;int rightnode;\n} ;\nstruct MOB mobiles[100];\nint prime[10]={2,3,5,7,11,13,17,19,23,29};\nlong int gcd(long int x,long int y)\n{ long int w,r;\n  int i,pr;\n  for(i=0;i<10;i++)\n    {\n      pr=prime[i];\n      if(x % pr == 0 && y % pr == 0)\n\treturn(pr*gcd(x/pr,y/pr));\n    }\n  if(x < y)\n    {\n      w = x;\n      x = y;\n      y=  w;\n    }\n  if((r = x % y) ==0)\n    return(y);\n  return(gcd (y, r));\n}\n\nlong int lcm(long int x,long int y)\n{\n  return(x/gcd(x,y)*y);\n}\n\nlong int calc_total_weight1(int leftlen, int rightlen,long int leftweight , long int rightweight)\n{\n  long int l;\n  // printf(\"%d %d %ld %ld\\n\",leftlen,rightlen,leftweight,rightweight);\n  l=lcm((leftlen *rightweight),(rightlen * leftweight));\n  return(l/leftlen+l/rightlen);\n}\n\nlong int calc_total_weight(struct MOB *m,int node_no)\n{ long int w1,w2,tw;\n  struct MOB * bar;\n  bar = m + (node_no - 1);\n\n\n  if(bar -> leftnode != 0)\n    w1 = calc_total_weight(m,(bar->leftnode));\n  else\n    w1 = 1;\n  if(bar -> rightnode != 0)\n    w2 = calc_total_weight(m,(bar->rightnode));\n  else\n    w2 = 1;\n\n  tw = calc_total_weight1(bar->leftlen,bar->rightlen,w1,w2);\n\n  return(tw);\n    \n}\n\nint search_root(struct MOB * m,int siz)\n{\n  int i,j;\n  for(i=1;i<=siz;i++)\n    {  for(j=0;j<siz;j++)\n      {\n        if(m[j].leftnode == i ||m[j].rightnode == i)\n          goto AAA;\n      }\n      return(i);\n    AAA:\n      ;\n    }\n   return(-1);\n\n}\n\n\nmain()\n{\nint i;\nlong int total_weight;\nint  root;\nint  cnt;\n  \n  while(EOF != scanf(\"%d\",&cnt) && cnt)\n    {     \n      for(i=0;i<cnt;i++)\n         scanf(\" %d %d %d %d\",\n               &(mobiles[i].leftlen),\n               &(mobiles[i].rightlen),\n               &(mobiles[i].leftnode),\n               &(mobiles[i].rightnode));\n    \n  \n  root = search_root(mobiles,cnt);    \n  total_weight = calc_total_weight(mobiles,root);\n\n  printf(\"%ld\\n\",total_weight);\n    }\nreturn(0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n\nlong long int mob[101][4];\n\nlong long int gcd(long long int x, long long int y){\n  if(x == 0)return y;\n  else return gcd(y % x, x);\n}\n\nlong long int lcf(long long int x, long long int y){\n  return (x * y) / gcd(x, y);\n}\n\nlong long int dfs(int x){\n  if(x == 0)return 1;\n  long long int r = mob[x][0] * dfs(mob[x][2]);\n  long long int b = mob[x][1] * dfs(mob[x][3]);\n  long long int m = lcf(r, b);\n  return m / mob[x][0] +  m / mob[x][1];\n  \n}\n\nint main(){\n  while(1){\n    int n, i, notTop[101], top;\n    memset(notTop, 0, sizeof(notTop));\n    memset(mob, 0, sizeof(mob));\n    scanf(\"%d\", &n);\n    if(n == 0)return 0;\n    for(i = 1;i <= n;i++){\n      int p, q, r, b;\n      scanf(\"%d%d%d%d\", &p, &q, &r, &b);\n      notTop[r] = notTop[b] = 1;\n      mob[i][0] = p;\n      mob[i][1] = q;\n      mob[i][2] = r;\n      mob[i][3] = b;\n    }\n    for(i = 1;i <= n;i++){\n      if(notTop[i] == 0){\n\ttop = i;\n\tbreak;\n      }\n    }\n    printf(\"%lld\\n\", dfs(top));\n  }\n}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A0520\nLightest Mobile\n*/\n#include <stdio.h>\n\n\nstruct MOB\n{\n  int leftlen   ;int rightlen;\n  int leftnode  ;int rightnode;\n} ;\nstruct MOB mobiles[1000];\nint    used_flag[1000];\n/*\nstruct MOB mobiles1[]=   {{1, 2, 0, 0},{1, 2, 0, 0},{1, 2, 1, 2},{1, 2, 3, 0}};\nstruct MOB mobiles2[]=   {{3, 2, 0, 4},{1, 3, 0, 0},{4, 4, 2, 1},{2, 2, 0, 0}};\nstruct MOB mobiles3[]=   {{1, 2, 0, 0},{1, 2, 0, 0},{1, 2, 1, 2},{1, 2, 3, 0},{1,2,4,0}};\n*/\n\nlong int gcd(long int x,long int y)\n{ long int w,r;\n  if(x < y)\n    {\n      w = x;\n      x = y;\n      y=  w;\n    }\n  if((r = x % y) ==0)\n    return(y);\n  return(gcd (y, r));\n}\n\nlong int lcm(long int x,long int y)\n{\n  return(x/gcd(x,y)*y);\n}\n\nlong int calc_total_weight1(int leftlen, int rightlen,long int leftweight , long int rightweight)\n{\n/*\n  long int l;\n\n  l=lcm((leftlen *rightweight),(rightlen * leftweight));\n  return(l/leftlen+l/rightlen);\n*/\n  long int g;\n  g = gcd(leftlen *rightweight,rightlen * leftweight);\n  return(leftweight*rightweight*(leftlen+rightlen)/g);\n}\n\nlong int calc_total_weight(struct MOB *m,int node_no)\n{ long int w1,w2,tw;\n  struct MOB * bar;\n  bar = m + (node_no - 1);\n\n/*Dprintf(\"%d L=%d R=%d\\n\",node_no,bar->leftnode,bar->rightnode);  */\n  if(bar -> leftnode != 0)\n    w1 = calc_total_weight(m,(bar->leftnode));\n  else\n    w1 = 1;\n  if(bar -> rightnode != 0)\n    w2 = calc_total_weight(m,(bar->rightnode));\n  else\n    w2 = 1;\n\n  tw = calc_total_weight1(bar->leftlen,bar->rightlen,w1,w2);\n/*Dprintf(\"tw=%ld\\n\",tw);*/\n  return(tw);\n    \n}\n/*\nint search_root(struct MOB * m,int siz)\n{\n  int i,j;\n  for(i=1;i<=siz;i++)\n    {  for(j=0;j<siz;j++)\n      {\n        if(m[j].leftnode == i ||m[j].rightnode == i)\n          goto AAA;\n      }\n      return(i);\n    AAA:\n      ;\n    }\n   return(-1);\n\n}\n*/\nint search_root(struct MOB * m,int siz)\n{\n  int i;\n\n  for(i=1;i<=siz;i++)\n    if(used_flag[i] == 0)\n      return(i);\n  return(0);\n}\n\nmain()\n{\nint i;\nlong int total_weight;\nint  root;\nint  cnt;\n  \n  while(EOF != scanf(\"%d\",&cnt))\n    {\n      for(i=0;i<1000;i++)\n        used_flag[i] = 0;\n\n      \n      for(i=0;i<cnt;i++)\n        {\n          scanf(\" %d %d %d %d\",\n                &(mobiles[i].leftlen),\n                &(mobiles[i].rightlen),\n                &(mobiles[i].leftnode),\n                &(mobiles[i].rightnode));\n\n          used_flag[mobiles[i].leftnode]=used_flag[mobiles[i].leftnode]=1;\n        }\n/*\n  for(i=0;i<4;i++)\n    {\n         printf(\" %d %d %d %d\\n\",\n               (mobiles[i].leftlen),\n               (mobiles[i].rightlen),\n               (mobiles[i].leftnode),\n               (mobiles[i].rightnode));\n    }\n*/\n  \n  root = search_root(mobiles,cnt);\n/*printf(\"RT=%d\\n\",root);*/\n  total_weight = calc_total_weight(mobiles,root);\n\n  printf(\"%ld\\n\",total_weight);\n    }\nreturn(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\ntypedef struct _node{\n\tlong long int p;\n\tlong long int q;\n\tint r;\n\tint b;\n\tlong long int left;\t//p-side mass\n\tlong long int right;\t//q-side mass\n} Node;\nlong long int calc_mass(int trgt);\nlong long int calc_gcd( long long int a,long long int b);\nNode MOB[101];\n\nint main(){\n\n\tint n;\n\tint chk[101];\n\tint i;\n\tlong long int p;\n\tlong long int q;\n\tint r;\n\tint b;\n\tint Top;\n\tlong long int Total;\n\tlong long int gcd;\n\n\twhile(1){\n\t\tscanf(\"%d\\n\",&n);\n\t\tif(n==0)break;\n\n\t\tfor(i=1;i<=n;i++){\n\t\t\tscanf(\"%lld %lld %d %d\\n\",&p,&q,&r,&b);\n\t\t\tgcd=calc_gcd(p,q);\n\t\t\tMOB[i].p=p/gcd;\n\t\t\tMOB[i].q=q/gcd;\n\t\t\tMOB[i].r=r;\n\t\t\tMOB[i].b=b;\n\t\t\tMOB[i].left=0;\n\t\t\tMOB[i].right=0;\n\t\t\t\n\t\t}\n\t\t\n\t\t// search TOP;\n\t\tfor(i=1;i<=n;i++)chk[i]=0;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tif(MOB[i].r!=0)chk[MOB[i].r]=1;\n\t\t\tif(MOB[i].b!=0)chk[MOB[i].b]=1;\n\t\t}\n\t\tfor(i=1;i<=n;i++){\n\t\t\tif(chk[i]==0){\n\t\t\t\tTop=i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tTotal=calc_mass(Top);\n\t\tprintf(\"%lld\\n\",Total);\n\n\t}\n\treturn 0;\n}\n\n\nlong long int calc_gcd( long long int a, long long int b){\n\tlong long int c=1;\n\tlong long int gcd;\n\n//\tif(a==0 || b==0)return 0;\n//\tif(a==1 || b==1)return 1;\n\n//\tif(a<b){\n//\t\tc=a,a=b,b=c;\n//\t}\n\n        gcd=1;\n//\tif(b==0)return a;\n\twhile(a%b!=0){\n\t\tc=b;\n\t\tb=a%b;\n\t\ta=c;\n\t}\n\tgcd=b;\n\n\treturn gcd;\n\n}\n\n\n\nlong long int calc_mass(int trgt){\n\tlong long int gcd;\n\tlong long int left,right;\n\n\tif(MOB[trgt].r==0 && MOB[trgt].b==0){\n\t\tgcd=calc_gcd(MOB[trgt].p,MOB[trgt].q);\n\t\tMOB[trgt].left=(MOB[trgt].q)/gcd;\n\t\tMOB[trgt].right=(MOB[trgt].p)/gcd;\n\t\treturn MOB[trgt].left+MOB[trgt].right;\n\t}\n\t\n//\tif(MOB[trgt].left==0){\n\t\tif(MOB[trgt].r==0)left=1;\n\t\tif(MOB[trgt].r!=0)left=calc_mass(MOB[trgt].r);\n//\t}\n//\tif(MOB[trgt].right==0){\n\t\tif(MOB[trgt].b==0)right=1;\n\t\tif(MOB[trgt].b!=0)right=calc_mass(MOB[trgt].b);\n//\t}\n\t\n\tgcd=calc_gcd(left*MOB[trgt].q,right*MOB[trgt].p);\n\tMOB[trgt].left=left*right*MOB[trgt].p/gcd;\n\tMOB[trgt].right=right*left*MOB[trgt].q/gcd;\n\treturn MOB[trgt].left+MOB[trgt].right;\n\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\ntypedef struct _node{\n\tlong long int p;\n\tlong long int q;\n\tint r;\n\tint b;\n\tlong long int left;\t//p-side mass\n\tlong long int right;\t//q-side mass\n} Node;\nlong long int calc_mass(int trgt);\nlong long int calc_gcd( long long int a,long long int b);\nNode MOB[101];\n\nint main(){\n\n\tint n;\n\tint chk[101];\n\tint i;\n\tlong long int p;\n\tlong long int q;\n\tint r;\n\tint b;\n\tint Top;\n\tlong long int Total;\n\tlong long int gcd;\n\n\twhile(1){\n\t\tscanf(\"%d\\n\",&n);\n\t\tif(n==0)break;\n\n\t\tfor(i=1;i<=n;i++){\n\t\t\tscanf(\"%lld %lld %d %d\\n\",&p,&q,&r,&b);\n\t\t\tgcd=calc_gcd(p,q);\n\t\t\tMOB[i].p=p/gcd;\n\t\t\tMOB[i].q=q/gcd;\n\t\t\tMOB[i].r=r;\n\t\t\tMOB[i].b=b;\n\t\t\tMOB[i].left=0;\n\t\t\tMOB[i].right=0;\n\t\t\t\n\t\t}\n\t\t\n\t\t// search TOP;\n\t\tfor(i=1;i<=n;i++)chk[i]=0;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tif(MOB[i].r!=0)chk[MOB[i].r]=1;\n\t\t\tif(MOB[i].b!=0)chk[MOB[i].b]=1;\n\t\t}\n\t\tfor(i=1;i<=n;i++){\n\t\t\tif(chk[i]==0){\n\t\t\t\tTop=i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tTotal=calc_mass(Top);\n\t\tprintf(\"%lld\\n\",Total);\n\n\t}\n\treturn 0;\n}\n\n\nlong long int calc_gcd( long long int a, long long int b){\n\tlong long int c=1;\n\tlong long int gcd;\n\n//\tif(a==0 || b==0)return 0;\n//\tif(a==1 || b==1)return 1;\n\n//\tif(a<b){\n//\t\tc=a,a=b,b=c;\n//\t}\n\n        gcd=1;\n//\tif(b==0)return a;\n\twhile(a%b!=0){\n\t\tc=b;\n\t\tb=a%b;\n\t\ta=c;\n\t}\n\tgcd=b;\n\n\treturn gcd;\n\n}\n\n\n\nlong long int calc_mass(int trgt){\n\tlong long int gcd;\n\tlong long int left,right;\n\n\tif(MOB[trgt].r==0 && MOB[trgt].b==0){\n\t\tgcd=calc_gcd(MOB[trgt].p,MOB[trgt].q);\n\t\tMOB[trgt].left=MOB[trgt].q/gcd;\n\t\tMOB[trgt].right=MOB[trgt].p/gcd;\n\t\treturn MOB[trgt].left+MOB[trgt].right;\n\t}\n\t\n//\tif(MOB[trgt].left==0){\n\t\tif(MOB[trgt].r==0)left=1;\n\t\tif(MOB[trgt].r!=0)left=calc_mass(MOB[trgt].r);\n//\t}\n//\tif(MOB[trgt].right==0){\n\t\tif(MOB[trgt].b==0)right=1;\n\t\tif(MOB[trgt].b!=0)right=calc_mass(MOB[trgt].b);\n//\t}\n\t\n\tgcd=calc_gcd(left*MOB[trgt].q,right*MOB[trgt].p);\n\tMOB[trgt].left=left*right*MOB[trgt].p/gcd;\n\tMOB[trgt].right=right*left*MOB[trgt].q/gcd;\n\treturn MOB[trgt].left+MOB[trgt].right;\n\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint gcd(int x,int y)\n{\n\twhile(1)\n\t{\n\t\tx %= y;\n\t\tif(x == 0)\n\t\t\treturn y;\n\t\ty %= x;\n\t\tif(y == 0)\n\t\t\treturn x;\n\t}\n}\n\ntypedef struct mb\n{\n\tstruct mb* red;\n\tstruct mb* blue;\n\tstruct mb* parent;\n\tlong long int weight_r;\n\tlong long int weight_b;\n\tint ratio_r;\n\tint ratio_b;\n\tint flug;\n} mobile;\n\nint main()\n{\n\tint n;\n\tint i,j;\n\tmobile* list;\n\twhile(scanf(\"%d\",&n),n)\n\t{\n\t\tlist = (mobile*)malloc(sizeof(mobile)*n);\n\t\tfor(i = 0;i < n;i++)\n\t\t{\n\t\t\tlist[i].parent = NULL;\n\t\t\tlist[i].flug = 1;\n\t\t}\n\t\tfor(i = 0;i < n;i++)\n\t\t{\n\t\t\tint p,q,r,b;\n\t\t\tscanf(\"%d %d %d %d\",&p,&q,&r,&b);\n\t\t\tlist[i].ratio_r = p;\n\t\t\tlist[i].ratio_b = q;\n\t\t\tlist[i].weight_r = 0;\n\t\t\tlist[i].weight_b = 0;\n\t\t\tif(r)\n\t\t\t{\n\t\t\t\tlist[i].red = &list[r-1];\n\t\t\t\tlist[r-1].parent = &list[i];\n\t\t\t}\n\t\t\telse\n\t\t\t\tlist[i].red = NULL;\n\t\t\tif(b)\n\t\t\t{\n\t\t\t\tlist[i].blue = &list[b-1];\n\t\t\t\tlist[b-1].parent = &list[i];\n\t\t\t}\n\t\t\telse\n\t\t\t\tlist[i].blue = NULL;\n\t\t}\n\t\twhile(1)\n\t\t{\n\t\t\tfor(j = 0;j < n;j++)\n\t\t\t{\n\t\t\t\tif(list[j].red == NULL && list[j].blue == NULL && list[j].flug)\n\t\t\t\t{\n\t\t\t\t\tif(list[j].weight_r == 0 && list[j].weight_b == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tlist[j].weight_r = list[j].ratio_b/gcd(list[j].ratio_r,list[j].ratio_b);\n\t\t\t\t\t\tlist[j].weight_b = list[j].ratio_r/gcd(list[j].ratio_r,list[j].ratio_b);\n\t\t\t\t\t}\n\t\t\t\t\telse if(list[j].weight_r == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tlist[j].weight_r = list[j].ratio_b*list[j].weight_b/gcd(list[j].ratio_r,list[j].ratio_b*list[j].weight_b);\n\t\t\t\t\t\tlist[j].weight_b = list[j].ratio_r*list[j].weight_b/gcd(list[j].ratio_r,list[j].ratio_b*list[j].weight_b);\n\t\t\t\t\t}\n\t\t\t\t\telse if(list[j].weight_b == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tlist[j].weight_r = list[j].ratio_b*list[j].weight_r/gcd(list[j].ratio_r*list[j].weight_r,list[j].ratio_b);\n\t\t\t\t\t\tlist[j].weight_b = list[j].ratio_r*list[j].weight_r/gcd(list[j].ratio_r*list[j].weight_r,list[j].ratio_b);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tlist[j].weight_r = list[j].weight_r*list[j].weight_b*list[j].ratio_b/gcd(list[j].ratio_r*list[j].weight_r,list[j].ratio_b*list[j].weight_b);\n\t\t\t\t\t\tlist[j].weight_b = list[j].weight_b*list[j].weight_r*list[j].ratio_r/gcd(list[j].ratio_r*list[j].weight_r,list[j].ratio_b*list[j].weight_b);\n\t\t\t\t\t}\n\t\t\t\t\tif(list[j].parent == NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%lld\\n\",list[j].weight_r+list[j].weight_b);\n\t\t\t\t\t\tgoto hell;\n\t\t\t\t\t}\n\t\t\t\t\telse if(list[j].parent->red == &list[j])\n\t\t\t\t\t{\n\t\t\t\t\t\tlist[j].parent->red = NULL;\n\t\t\t\t\t\tlist[j].parent->weight_r = list[j].weight_r+list[j].weight_b;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tlist[j].parent->blue = NULL;\n\t\t\t\t\t\tlist[j].parent->weight_b = list[j].weight_r+list[j].weight_b;\n\t\t\t\t\t}\n\t\t\t\t\tlist[j].flug = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\thell:;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\ntypedef struct _node{\n\tunsigned int p;\n\tunsigned int q;\n\tunsigned int r;\n\tunsigned int b;\n\tunsigned int left;\t//p-side mass\n\tunsigned int right;\t//q-side mass\n} Node;\nunsigned int calc_mass(unsigned int trgt);\nunsigned int calc_gcd( unsigned int a, unsigned int b);\nNode MOB[101];\n\nunsigned int main(){\n\n\tunsigned int n;\n\tunsigned int chk[101];\n\tunsigned int i;\n\tunsigned int p;\n\tunsigned int q;\n\tunsigned int r;\n\tunsigned int b;\n\tunsigned int Top;\n\tunsigned int Total;\n\tunsigned int gcd;\n\n\twhile(1){\n\t\tscanf(\"%d\\n\",&n);\n\t\tif(n==0)break;\n\n\t\tfor(i=1;i<=n;i++){\n\t\t\tscanf(\"%d %d %d %d\\n\",&p,&q,&r,&b);\n\t\t\tgcd=calc_gcd(p,q);\n\t\t\tMOB[i].p=p/gcd;\n\t\t\tMOB[i].q=q/gcd;\n\t\t\tMOB[i].r=r;\n\t\t\tMOB[i].b=b;\n\t\t\tMOB[i].left=0;\n\t\t\tMOB[i].right=0;\n\t\t\t\n\t\t}\n\t\t\n\t\t// search TOP;\n\t\tfor(i=1;i<=n;i++)chk[i]=0;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tif(MOB[i].r!=0)chk[MOB[i].r]=1;\n\t\t\tif(MOB[i].b!=0)chk[MOB[i].b]=1;\n\t\t}\n\t\tfor(i=1;i<=n;i++){\n\t\t\tif(chk[i]==0)Top=i;\n\t\t}\n\t\tTotal=calc_mass(Top);\n\t\tprunsigned intf(\"%d\\n\",Total);\n\n\t}\n\treturn 0;\n}\n\n\nunsigned int calc_gcd( unsigned int a, unsigned int b){\n\t unsigned int c=1;\n\t unsigned int gcd;\n\n        if(a==0 || b==0)return 0;\n\n        if(a<b){\n            c=a,a=b,b=c;\n        }\n\n        gcd=1;\n\t\n\twhile(a%b!=0){\n\t\tc=b;\n\t\tb=a%b;\n\t\ta=c;\n\t}\n\tgcd=b;\n\n\treturn gcd;\n\n}\n\n\n\nunsigned int calc_mass(unsigned int trgt){\n\tunsigned int gcd;\n\tunsigned int left,right;\n\n\tif(MOB[trgt].r==0 && MOB[trgt].b==0){\n\t\tgcd=calc_gcd(MOB[trgt].p,MOB[trgt].q);\n\t\tMOB[trgt].left=MOB[trgt].q/gcd;\n\t\tMOB[trgt].right=MOB[trgt].p/gcd;\n\t\treturn MOB[trgt].left+MOB[trgt].right;\n\t}\n\t\n\tif(MOB[trgt].left==0){\n\t\tif(MOB[trgt].r==0)left=1;\n\t\tif(MOB[trgt].r!=0)left=calc_mass(MOB[trgt].r);\n\t}\n\tif(MOB[trgt].right==0){\n\t\tif(MOB[trgt].b==0)right=1;\n\t\tif(MOB[trgt].b!=0)right=calc_mass(MOB[trgt].b);\n\t}\n\t\n\tgcd=calc_gcd(left*MOB[trgt].q,right*MOB[trgt].p);\n\tMOB[trgt].left=left*right*MOB[trgt].p/gcd;\n\tMOB[trgt].right=right*left*MOB[trgt].q/gcd;\n\treturn MOB[trgt].left+MOB[trgt].right;\n\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\ntypedef struct _node{\n\tlong long int p;\n\tlong long int q;\n\tint r;\n\tint b;\n\tlong long int left;\t//p-side mass\n\tlong long int right;\t//q-side mass\n} Node;\nlong long int calc_mass(int trgt);\nlong long int calc_gcd( long long int a,long long int b);\nNode MOB[101];\n\nint main(){\n\n\tint n;\n\tint chk[101];\n\tint i;\n\tlong long int p;\n\tlong long int q;\n\tint r;\n\tint b;\n\tint Top;\n\tlong long int Total;\n\tlong long int gcd;\n\n\twhile(1){\n\t\tscanf(\"%d\\n\",&n);\n\t\tif(n==0)break;\n\n\t\tfor(i=1;i<=n;i++){\n\t\t\tscanf(\"%lld %lld %d %d\\n\",&p,&q,&r,&b);\n\t\t\tgcd=calc_gcd(p,q);\n\t\t\tMOB[i].p=p/gcd;\n\t\t\tMOB[i].q=q/gcd;\n\t\t\tMOB[i].r=r;\n\t\t\tMOB[i].b=b;\n\t\t\tMOB[i].left=0;\n\t\t\tMOB[i].right=0;\n\t\t\t\n\t\t}\n\t\t\n\t\t// search TOP;\n\t\tfor(i=1;i<=n;i++)chk[i]=0;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tif(MOB[i].r!=0)chk[MOB[i].r]=1;\n\t\t\tif(MOB[i].b!=0)chk[MOB[i].b]=1;\n\t\t}\n\t\tfor(i=1;i<=n;i++){\n\t\t\tif(chk[i]==0){\n\t\t\t\tTop=i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tTotal=calc_mass(Top);\n\t\tprintf(\"%lld\\n\",Total);\n\n\t}\n\treturn 0;\n}\n\n\nlong long int calc_gcd( long long int a, long long int b){\n\tlong long int c=1;\n\tlong long int gcd;\n\n//\tif(a==0 || b==0)return 0;\n//\tif(a==1 || b==1)return 1;\n\n//\tif(a<b){\n//\t\tc=a,a=b,b=c;\n//\t}\n\n        gcd=1;\n\t\n\twhile(a%b!=0){\n\t\tc=b;\n\t\tb=a%b;\n\t\ta=c;\n\t}\n\tgcd=b;\n\n\treturn gcd;\n\n}\n\n\n\nlong long int calc_mass(int trgt){\n\tlong long int gcd;\n\tlong long int left,right;\n\n\tif(MOB[trgt].r==0 && MOB[trgt].b==0){\n\t\tgcd=calc_gcd(MOB[trgt].p,MOB[trgt].q);\n\t\tMOB[trgt].left=MOB[trgt].q/gcd;\n\t\tMOB[trgt].right=MOB[trgt].p/gcd;\n\t\treturn MOB[trgt].left+MOB[trgt].right;\n\t}\n\t\n\tif(MOB[trgt].left==0){\n\t\tif(MOB[trgt].r==0)left=1;\n\t\tif(MOB[trgt].r!=0)left=calc_mass(MOB[trgt].r);\n\t}\n\tif(MOB[trgt].right==0){\n\t\tif(MOB[trgt].b==0)right=1;\n\t\tif(MOB[trgt].b!=0)right=calc_mass(MOB[trgt].b);\n\t}\n\t\n\tgcd=calc_gcd(left*MOB[trgt].q,right*MOB[trgt].p);\n\tMOB[trgt].left=left*right*MOB[trgt].p/gcd;\n\tMOB[trgt].right=right*left*MOB[trgt].q/gcd;\n\treturn MOB[trgt].left+MOB[trgt].right;\n\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\ntypedef struct _node{\n\tunsigned long long p;\n\tunsigned long long q;\n\tunsigned long long r;\n\tunsigned long long b;\n\tunsigned long long left;\t//p-side mass\n\tunsigned long long right;\t//q-side mass\n} Node;\nunsigned long long calc_mass(int trgt);\nunsigned long long calc_gcd( unsigned long long a, unsigned long long b);\nNode MOB[101];\n\nint main(){\n\n\tunsigned long long n;\n\tunsigned long long chk[101];\n\tint i;\n\tunsigned long long p;\n\tunsigned long long q;\n\tunsigned long long r;\n\tunsigned long long b;\n\tint Top;\n\tunsigned long long Total;\n\tunsigned long long gcd;\n\n\twhile(1){\n\t\tscanf(\"%llu\\n\",&n);\n\t\tif(n==0)break;\n\n\t\tfor(i=1;i<=n;i++){\n\t\t\tscanf(\"%llu %llu %llu %llu\\n\",&p,&q,&r,&b);\n\t\t\tgcd=calc_gcd(p,q);\n\t\t\tMOB[i].p=p/gcd;\n\t\t\tMOB[i].q=q/gcd;\n\t\t\tMOB[i].r=r;\n\t\t\tMOB[i].b=b;\n\t\t\tMOB[i].left=0;\n\t\t\tMOB[i].right=0;\n\t\t\t\n\t\t}\n\t\t\n\t\t// search TOP;\n\t\tfor(i=1;i<=n;i++)chk[i]=0;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tif(MOB[i].r!=0)chk[MOB[i].r]=1;\n\t\t\tif(MOB[i].b!=0)chk[MOB[i].b]=1;\n\t\t}\n\t\tfor(i=1;i<=n;i++){\n\t\t\tif(chk[i]==0)Top=i;\n\t\t}\n\t\tTotal=calc_mass(Top);\n\t\tprintf(\"%llu\\n\",Total);\n\n\t}\n\treturn 0;\n}\n\n\nunsigned long long calc_gcd( unsigned long long a, unsigned long long b){\n\t unsigned long long c=1;\n\t unsigned long long gcd;\n\n//        if(a==0 || b==0)return 0;\n//        if(a==1 || b==1)return 1;\n\n        if(a<b){\n            c=a,a=b,b=c;\n        }\n\n        gcd=1;\n\t\n\twhile(a%b!=0){\n\t\tc=b;\n\t\tb=a%b;\n\t\ta=c;\n\t}\n\tgcd=b;\n\n\treturn gcd;\n\n}\n\n\n\nunsigned long long calc_mass(int trgt){\n//printf(\"trgt=%d\\n\",trgt);\n\tunsigned long long gcd;\n\tunsigned long long left,right;\n\tunsigned long long left2,right2;\n\tunsigned long long ratio;\n\n//\tif(MOB[trgt].r==0 && MOB[trgt].b==0){\n//\t\tgcd=calc_gcd(MOB[trgt].p,MOB[trgt].q);\n//\t\tMOB[trgt].left=MOB[trgt].q/gcd;\n//\t\tMOB[trgt].right=MOB[trgt].p/gcd;\n//\t\treturn MOB[trgt].left+MOB[trgt].right;\n//\t}\n\t\n\tif(MOB[trgt].left==0){\n\t\tif(MOB[trgt].r==0)left=1;\n\t\tif(MOB[trgt].r!=0)left=calc_mass(MOB[trgt].r);\n\t}\n\tif(MOB[trgt].right==0){\n\t\tif(MOB[trgt].b==0)right=1;\n\t\tif(MOB[trgt].b!=0)right=calc_mass(MOB[trgt].b);\n\t}\n\t\n\n\n\tgcd=calc_gcd(right,left);\n\tleft2=left/gcd,right2=right/gcd;\n\tgcd=calc_gcd(left2*MOB[trgt].q,right2*MOB[trgt].p);\n\tratio=(right2*MOB[trgt].p)/gcd;\n\tMOB[trgt].left=left*ratio;\n\t\n\tratio=(left2*MOB[trgt].q)/gcd;\n\tMOB[trgt].right=right*ratio;\n\t\n\treturn MOB[trgt].left+MOB[trgt].right;\n\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define N 100\n#define MAX(A,B) \\\n  ( (B) > (A) ? (B) : (A) )\n\nstatic struct\n{\n  int a, b;\n  int p, q;\n} d[ N + 1 ];\nstatic int dp[ N + 1 ];\nstatic int n;\n\nstatic int\ngcd (\n  const int a,\n  const int b\n  )\n{\n  if ( a == 0 )\n    return ( b );\n\n  return\n  gcd ( b % a, a );\n}\n\nstatic int\nlcm (\n  const int a,\n  const int b\n  )\n{\n  return ( a * b / gcd ( a, b ) );\n}\n\nstatic int\ndfs (\n  const int p\n  )\n{\n  if ( p == 0 )\n    return ( 1 );\n\n  if ( ~dp[ p ] ) ;\n  else dp[ p ] = d[ p ].a * lcm ( dfs ( d[ p ].p ), dfs ( d[ p ].q ) )\n               + d[ p ].b * lcm ( dfs ( d[ p ].p ), dfs ( d[ p ].q ) );\n\n  return ( dp[ p ] );\n}\n\nint\nmain (\n  int   argc,\n  char *argv[ ]\n  )\n{\n  int i;\n\n  for ( ; ; )\n  {\n    int res = 0;\n\n    scanf ( \"%d\", &n );\n    if ( n == 0 ) break ;\n    for ( i = 1; i <= n; ++i )\n    {\n      int cd;\n\n      scanf ( \"%d%d%d%d\", &d[ i ].a, &d[ i ].b\n                        , &d[ i ].p, &d[ i ].q );\n      cd = gcd ( d[ i ].a, d[ i ].b );\n      d[ i ].a /= cd; d[ i ].b /= cd;\n    }\n\n    memset ( dp, -1, sizeof ( dp ) );\n    for ( i = 1; i <= n; ++i )\n      res = MAX( res, dfs ( i ) );\n    printf ( \"%d\\n\", res );\n  }\n\n  return ( EXIT_SUCCESS );\n}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A0520\nLightest Mobile\n2013/1/17 TE->WA\n*/\n#include <stdio.h>\n\n\nstruct MOB\n{\n  long int leftlen   ;long int rightlen;\n  long int leftnode  ;long int rightnode;\n} ;\n\nstruct MOB mobiles[100];\nint gcd(int x, int y){\n\treturn y == 0 ? x: gcd(y, x%y);\n}\n\n\nlong int lcm(long int x,long int y)\n{\n  return(x/gcd(x,y)*y);\n}\n\nlong int calc_total_weight1(long int leftlen, long int rightlen,long int leftweight , long int rightweight)\n{\n  long int l;\n  // printf(\"%d %d %ld %ld\\n\",leftlen,rightlen,leftweight,rightweight);\n  l=lcm((leftlen *rightweight),(rightlen * leftweight));\n  return(l/leftlen+l/rightlen);\n}\n\nlong int calc_total_weight(struct MOB *m,int node_no)\n{ long int w1,w2,tw;\n  struct MOB * bar;\n  bar = m + (node_no - 1);\n\n\n  if(bar -> leftnode != 0)\n    w1 = calc_total_weight(m,(bar->leftnode));\n  else\n    w1 = 1;\n  if(bar -> rightnode != 0)\n    w2 = calc_total_weight(m,(bar->rightnode));\n  else\n    w2 = 1;\n\n  tw = calc_total_weight1(bar->leftlen,bar->rightlen,w1,w2);\n\n  return(tw);\n    \n}\n\nint search_root(struct MOB * m,int siz)\n{\n  int i,j;\n  for(i=1;i<=siz;i++)\n    {  for(j=0;j<siz;j++)\n      {\n        if(m[j].leftnode == i ||m[j].rightnode == i)\n          goto AAA;\n      }\n      return(i);\n    AAA:\n      ;\n    }\n   return(-1);\n}\n\n\nmain()\n{\nint i;\nlong int total_weight;\nint  root;\nint  cnt;\n  \n  while(EOF != scanf(\"%d\",&cnt) && cnt)\n    {     \n      for(i=0;i<cnt;i++)\n         scanf(\" %ld %ld %ld %ld\",\n               &(mobiles[i].leftlen),\n               &(mobiles[i].rightlen),\n               &(mobiles[i].leftnode),\n               &(mobiles[i].rightnode));\n    \n  \n  root = search_root(mobiles,cnt);    \n  total_weight = calc_total_weight(mobiles,root);\n\n  printf(\"%ld\\n\",total_weight);\n    }\nreturn(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\ntypedef struct _node{\n\tlong long int p;\n\tlong long int q;\n\tint r;\n\tint b;\n\tlong long int left;\t//p-side mass\n\tlong long int right;\t//q-side mass\n} Node;\nlong long int calc_mass(int trgt);\nlong long int calc_gcd( long long int a,long long int b);\nNode MOB[101];\n\nint main(){\n\n\tint n;\n\tint chk[101];\n\tint i;\n\tlong long int p;\n\tlong long int q;\n\tint r;\n\tint b;\n\tint Top;\n\tlong long int Total;\n\tlong long int gcd;\n\n\twhile(1){\n\t\tscanf(\"%d\\n\",&n);\n\t\tif(n==0)break;\n\n\t\tfor(i=1;i<=n;i++){\n\t\t\tscanf(\"%lld %lld %d %d\\n\",&p,&q,&r,&b);\n\t\t\tgcd=calc_gcd(p,q);\n\t\t\tMOB[i].p=p/gcd;\n\t\t\tMOB[i].q=q/gcd;\n\t\t\tMOB[i].r=r;\n\t\t\tMOB[i].b=b;\n\t\t\tMOB[i].left=0;\n\t\t\tMOB[i].right=0;\n\t\t\t\n\t\t}\n\t\t\n\t\t// search TOP;\n\t\tfor(i=1;i<=n;i++)chk[i]=0;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tif(MOB[i].r!=0)chk[MOB[i].r]=1;\n\t\t\tif(MOB[i].b!=0)chk[MOB[i].b]=1;\n\t\t}\n\t\tfor(i=1;i<=n;i++){\n\t\t\tif(chk[i]==0){\n\t\t\t\tTop=i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tTotal=calc_mass(Top);\n\t\tprintf(\"%lld\\n\",Total);\n\n\t}\n\treturn 0;\n}\n\n\nlong long int calc_gcd( long long int a, long long int b){\n\tlong long int c=1;\n\tlong long int gcd;\n\n//\tif(a==0 || b==0)return 0;\n//\tif(a==1 || b==1)return 1;\n\n//\tif(a<b){\n//\t\tc=a,a=b,b=c;\n//\t}\n\n        gcd=1;\n\tif(b==0)return a;\n\twhile(a%b!=0){\n\t\tc=b;\n\t\tb=a%b;\n\t\ta=c;\n\t}\n\tgcd=b;\n\n\treturn gcd;\n\n}\n\n\n\nlong long int calc_mass(int trgt){\n\tlong long int gcd;\n\tlong long int left,right;\n\n\tif(MOB[trgt].r==0 && MOB[trgt].b==0){\n\t\tgcd=calc_gcd(MOB[trgt].p,MOB[trgt].q);\n\t\tMOB[trgt].left=MOB[trgt].q/gcd;\n\t\tMOB[trgt].right=MOB[trgt].p/gcd;\n\t\treturn MOB[trgt].left+MOB[trgt].right;\n\t}\n\t\n\tif(MOB[trgt].left==0){\n\t\tif(MOB[trgt].r==0)left=1;\n\t\tif(MOB[trgt].r!=0)left=calc_mass(MOB[trgt].r);\n\t}\n\tif(MOB[trgt].right==0){\n\t\tif(MOB[trgt].b==0)right=1;\n\t\tif(MOB[trgt].b!=0)right=calc_mass(MOB[trgt].b);\n\t}\n\t\n\tgcd=calc_gcd(left*MOB[trgt].q,right*MOB[trgt].p);\n\tMOB[trgt].left=left*right*MOB[trgt].p/gcd;\n\tMOB[trgt].right=right*left*MOB[trgt].q/gcd;\n\treturn MOB[trgt].left+MOB[trgt].right;\n\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\ntypedef struct _node{\n\tunsigned long p;\n\tunsigned long q;\n\tunsigned long r;\n\tunsigned long b;\n\tunsigned long left;\t//p-side mass\n\tunsigned long right;\t//q-side mass\n} Node;\nunsigned long calc_mass(int trgt);\nunsigned long calc_gcd( unsigned long a, unsigned long b);\nNode MOB[101];\n\nint main(){\n\n\tunsigned long n;\n\tunsigned long chk[101];\n\tint i;\n\tunsigned long p;\n\tunsigned long q;\n\tunsigned long r;\n\tunsigned long b;\n\tint Top;\n\tunsigned long Total;\n\tunsigned long gcd;\n\n\twhile(1){\n\t\tscanf(\"%lu\\n\",&n);\n\t\tif(n==0)break;\n\n\t\tfor(i=1;i<=n;i++){\n\t\t\tscanf(\"%lu %lu %lu %lu\\n\",&p,&q,&r,&b);\n\t\t\tgcd=calc_gcd(p,q);\n\t\t\tMOB[i].p=p/gcd;\n\t\t\tMOB[i].q=q/gcd;\n\t\t\tMOB[i].r=r;\n\t\t\tMOB[i].b=b;\n\t\t\tMOB[i].left=0;\n\t\t\tMOB[i].right=0;\n\t\t\t\n\t\t}\n\t\t\n\t\t// search TOP;\n\t\tfor(i=1;i<=n;i++)chk[i]=0;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tif(MOB[i].r!=0)chk[MOB[i].r]=1;\n\t\t\tif(MOB[i].b!=0)chk[MOB[i].b]=1;\n\t\t}\n\t\tfor(i=1;i<=n;i++){\n\t\t\tif(chk[i]==0)Top=i;\n\t\t}\n\t\tTotal=calc_mass(Top);\n\t\tprintf(\"%lu\\n\",Total);\n\n\t}\n\treturn 0;\n}\n\n\nunsigned long calc_gcd( unsigned long a, unsigned long b){\n\t unsigned long c=1;\n\t unsigned long gcd;\n\n        //if(a==0 || b==0)return 0;\n        if(a==1 || b==1)return 1;\n\n        if(a<b){\n            c=a,a=b,b=c;\n        }\n\n        gcd=1;\n\t\n\twhile(a%b!=0){\n\t\tc=b;\n\t\tb=a%b;\n\t\ta=c;\n\t}\n\tgcd=b;\n\n\treturn gcd;\n\n}\n\n\n\nunsigned long calc_mass(int trgt){\n\tunsigned long gcd;\n\tunsigned long left,right;\n\tunsigned long left2,right2;\n\tunsigned long ratio;\n\n//\tif(MOB[trgt].r==0 && MOB[trgt].b==0){\n//\t\tgcd=calc_gcd(MOB[trgt].p,MOB[trgt].q);\n//\t\tMOB[trgt].left=MOB[trgt].q/gcd;\n//\t\tMOB[trgt].right=MOB[trgt].p/gcd;\n//\t\treturn MOB[trgt].left+MOB[trgt].right;\n//\t}\n\t\n\tif(MOB[trgt].left==0){\n\t\tif(MOB[trgt].r==0)left=1;\n\t\tif(MOB[trgt].r!=0)left=calc_mass(MOB[trgt].r);\n\t}\n\tif(MOB[trgt].right==0){\n\t\tif(MOB[trgt].b==0)right=1;\n\t\tif(MOB[trgt].b!=0)right=calc_mass(MOB[trgt].b);\n\t}\n\t\n\n\n\tgcd=calc_gcd(right,left);\n\tleft2=left/gcd,right2=right/gcd;\n\tgcd=calc_gcd(left2*MOB[trgt].q,right2*MOB[trgt].p);\n\n\tratio=(right2*MOB[trgt].p)/gcd;\n\tMOB[trgt].left=left*ratio;\n\t\n\tratio=(left2*MOB[trgt].q)/gcd;\n\tMOB[trgt].right=right*ratio;\n\t\n\treturn MOB[trgt].left+MOB[trgt].right;\n\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\ntypedef struct {\n\tlong long p,q,r,b;\n} mobile;\n\nmobile bar[100];\nlong long data[100];\n\nlong long kbs(long long a, long long b){\n\tif(a>b){\n\t\tif(a%b==0) return b;\n\t\telse return kbs(a%b,b);\n\t}else{\n\t\tif(b%a==0) return a;\n\t\telse return kbs(a,b%a);\n\t}\n}\n\nlong long weight(int i){\n\tif(data[i-1]>0) return data[i-1];\n\tlong long j;\n\tif(bar[i-1].r==0 && bar[i-1].b==0){\n\t\tj=kbs(bar[i-1].p,bar[i-1].q);\n\t\treturn data[i-1]=bar[i-1].p/j+bar[i-1].q/j;\n\t}else if(bar[i-1].r==0){\n\t\tj=kbs(bar[i-1].p,bar[i-1].q*weight(bar[i-1].b));\n\t\treturn data[i-1]=weight(bar[i-1].b)*bar[i-1].p/j+bar[i-1].q*weight(bar[i-1].b)/j;\n\t}else if(bar[i-1].b==0){\n\t\tj=kbs(bar[i-1].q,bar[i-1].p*weight(bar[i-1].r));\n\t\treturn data[i-1]=weight(bar[i-1].r)*bar[i-1].q/j+bar[i-1].r*weight(bar[i-1].r)/j;\n\t}else{\n\t\tj=kbs(bar[i-1].q*weight(bar[i-1].b),bar[i-1].p*weight(bar[i-1].r));\n\t\treturn data[i-1]=weight(bar[i-1].r)*bar[i-1].q*weight(bar[i-1].b)/j+weight(bar[i-1].b)*bar[i-1].p*weight(bar[i-1].r)/j;\n\t}\n}\n\nint main(){\n\tint n,i;\n\tlong long heavy,max;\n\tscanf(\"%d\",&n);\n\twhile(n!=0){\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%lld %lld %lld %lld\",&bar[i].p,&bar[i].q,&bar[i].r,&bar[i].b);\n\t\t}\n\t\tfor(i=0;i<n;i++){\n\t\t\tdata[i]=0;\n\t\t}\n\t\theavy=0;\n\t\tmax=0;\n\t\tfor(i=1;i<=n;i++){\n\t\t\theavy=weight(i);\n\t\t\tmax=max<heavy?heavy:max;\n\t\t}\n\t\tprintf(\"%lld\\n\",max);\n\t\tscanf(\"%d\",&n);\n\t}\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nstruct x{int p,q,r,b;}B[105];\nint N,i,j,h[105],r,t;\n\nint gcd(int a,int b)\n{\n\tint c;\n\tfor(;b!=0;)\n\t{\n\t\tc=a%b;a=b;b=c;\n\t}\n\treturn a;\n}\n\nint dfs(int p)\n{\n\tint r,b,g;\n\tif(p==-1)return 1;\n\tif(h[p]>=0)return h[p];\n\tr=dfs(B[p].r);\n\tb=dfs(B[p].b);\n\tg=r*b/gcd(r,b);\n\treturn h[p]=g*(B[p].p+B[p].q);\n}\n\nint main()\n{\n\tfor(;scanf(\"%d\",&N),N;)\n\t{\n\t\tmemset(h,-1,sizeof(h));\n\t\tfor(i=0;i<N;i++)\n\t\t{\n\t\t\tscanf(\"%d%d%d%d\",&B[i].p,&B[i].q,&B[i].r,&B[i].b);\n\t\t\tt=gcd(B[i].p,B[i].q);\n\t\t\tB[i].p/=t;B[i].q/=t;\n\t\t\tB[i].r--;B[i].b--;\n\t\t}\n\t\tfor(i=r=0;i<N;i++)\n\t\t{\n\t\t\tt=dfs(i);\n\t\t\tr=r>t?r:t;\n\t\t}\n\t\tprintf(\"%d\\n\",r);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\ntypedef struct _node{\n\tunsigned int p;\n\tunsigned int q;\n\tunsigned int r;\n\tunsigned int b;\n\tunsigned int left;\t//p-side mass\n\tunsigned int right;\t//q-side mass\n} Node;\nunsigned int calc_mass(unsigned int trgt);\nunsigned int calc_gcd( unsigned int a, unsigned int b);\nNode MOB[101];\n\nunsigned int main(){\n\n\tunsigned int n;\n\tunsigned int chk[101];\n\tunsigned int i;\n\tunsigned int p;\n\tunsigned int q;\n\tunsigned int r;\n\tunsigned int b;\n\tunsigned int Top;\n\tunsigned int Total;\n\tunsigned int gcd;\n\n\twhile(1){\n\t\tscanf(\"%u\\n\",&n);\n\t\tif(n==0)break;\n\n\t\tfor(i=1;i<=n;i++){\n\t\t\tscanf(\"%u %u %u %u\\n\",&p,&q,&r,&b);\n\t\t\tgcd=calc_gcd(p,q);\n\t\t\tMOB[i].p=p/gcd;\n\t\t\tMOB[i].q=q/gcd;\n\t\t\tMOB[i].r=r;\n\t\t\tMOB[i].b=b;\n\t\t\tMOB[i].left=0;\n\t\t\tMOB[i].right=0;\n\t\t\t\n\t\t}\n\t\t\n\t\t// search TOP;\n\t\tfor(i=1;i<=n;i++)chk[i]=0;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tif(MOB[i].r!=0)chk[MOB[i].r]=1;\n\t\t\tif(MOB[i].b!=0)chk[MOB[i].b]=1;\n\t\t}\n\t\tfor(i=1;i<=n;i++){\n\t\t\tif(chk[i]==0)Top=i;\n\t\t}\n\t\tTotal=calc_mass(Top);\n\t\tprintf(\"%u\\n\",Total);\n\n\t}\n\treturn 0;\n}\n\n\nunsigned int calc_gcd( unsigned int a, unsigned int b){\n\t unsigned int c=1;\n\t unsigned int gcd;\n\n        if(a==0 || b==0)return 0;\n        if(a==1 || b==1)return 1;\n\n        if(a<b){\n            c=a,a=b,b=c;\n        }\n\n        gcd=1;\n\t\n\twhile(a%b!=0){\n\t\tc=b;\n\t\tb=a%b;\n\t\ta=c;\n\t}\n\tgcd=b;\n\n\treturn gcd;\n\n}\n\n\n\nunsigned int calc_mass(unsigned int trgt){\n\tunsigned int gcd;\n\tunsigned int left,right;\n\tunsigned int ratio;\n\n\tif(MOB[trgt].r==0 && MOB[trgt].b==0){\n\t\tgcd=calc_gcd(MOB[trgt].p,MOB[trgt].q);\n\t\tMOB[trgt].left=MOB[trgt].q/gcd;\n\t\tMOB[trgt].right=MOB[trgt].p/gcd;\n\t\treturn MOB[trgt].left+MOB[trgt].right;\n\t}\n\t\n\tif(MOB[trgt].left==0){\n\t\tif(MOB[trgt].r==0)left=1;\n\t\tif(MOB[trgt].r!=0)left=calc_mass(MOB[trgt].r);\n\t}\n\tif(MOB[trgt].right==0){\n\t\tif(MOB[trgt].b==0)right=1;\n\t\tif(MOB[trgt].b!=0)right=calc_mass(MOB[trgt].b);\n\t}\n\t\n\tgcd=calc_gcd(left*MOB[trgt].q,right*MOB[trgt].p);\n\tratio=right*MOB[trgt].p/gcd;\n\tMOB[trgt].left=left*ratio;\n\t\n\tratio=left*MOB[trgt].q/gcd;\n\tMOB[trgt].right=right*ratio;\n\t\n\treturn MOB[trgt].left+MOB[trgt].right;\n\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint gcm(int a,int b){\n\tint c;\n\tif(b>a)c=a,a=b,b=c;\n\twhile(1){\n\t\tc=a%b;\n\t\ta=b,b=c;\n\t\tif(c==0)return a;\n\t}\n}\nint main(){\n\tint n,i,j,f,x,y,ans;\n\tint p[105],q[105],r[105],b[105],w[105];\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tmemset(w,-1,sizeof(w));\n\t\tfor(i=1;i<=n;i++){\n\t\t\tscanf(\"%d%d%d%d\",&p[i],&q[i],&r[i],&b[i]);\n\t\t\tif(r[i]==0 && b[i]==0){\n\t\t\t\tx=gcm(p[i],q[i]);\n\t\t\t\tw[i]=p[i]/x+q[i]/x;\n\t\t\t}\n\t\t}\n\t\twhile(1){\n\t\t\tf=0;\n\t\t\tfor(i=1;i<=n;i++){\n\t\t\t\tif(w[i]<0 && (r[i]==0 || w[r[i]]>0) && (b[i]==0 || w[b[i]]>0)){\n\t\t\t\t\tf=1;\n\t\t\t\t\tif(r[i]==0 && b[i]>0){\n\t\t\t\t\t\tx=gcm(p[i],q[i]);\n\t\t\t\t\t\ty=gcm(q[i]/x,w[b[i]]);\n\t\t\t\t\t\tw[i]=w[b[i]]*(q[i]/x)/y*(p[i]/x+q[i]/x)/(q[i]/x);\n\t\t\t\t\t}else if(r[i]>0 && b[i]==0){\n\t\t\t\t\t\tx=gcm(p[i],q[i]);\n\t\t\t\t\t\ty=gcm(p[i]/x,w[r[i]]);\n\t\t\t\t\t\tw[i]=w[r[i]]*(p[i]/x)/y*(p[i]/x+q[i]/x)/(p[i]/x);\n\t\t\t\t\t}else if(w[r[i]]>0 && w[b[i]]>0){\n\t\t\t\t\t\tx=gcm(p[i],q[i]);\n\t\t\t\t\t\ty=gcm(p[i]/x*w[b[i]],q[i]/x*w[r[i]]);\n\t\t\t\t\t\tw[i]=w[r[i]]*p[i]/x*w[b[i]]/y+w[b[i]]*q[i]/x*w[r[i]]/y;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f==0)break;\n\t\t}\n\t\tans=0;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tprintf(\"%d:%d\\n\",i,w[i]);\n\t\t\tif(w[i]>ans)ans=w[i];\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint gcd(int x,int y)\n{\n\twhile(1)\n\t{\n\t\tx %= y;\n\t\tif(x == 0)\n\t\t\treturn y;\n\t\ty %= x;\n\t\tif(y == 0)\n\t\t\treturn x;\n\t}\n}\n\ntypedef struct mb\n{\n\tstruct mb* red;\n\tstruct mb* blue;\n\tstruct mb* parent;\n\tint weight_r;\n\tint weight_b;\n\tint ratio_r;\n\tint ratio_b;\n\tint flug;\n} mobile;\n\nint main()\n{\n\tint n;\n\tint i,j;\n\tmobile* list;\n\twhile(scanf(\"%d\",&n),n)\n\t{\n\t\tlist = (mobile*)malloc(sizeof(mobile)*n);\n\t\tfor(i = 0;i < n;i++)\n\t\t{\n\t\t\tlist[i].parent = NULL;\n\t\t\tlist[i].flug = 1;\n\t\t}\n\t\tfor(i = 0;i < n;i++)\n\t\t{\n\t\t\tint p,q,r,b;\n\t\t\tscanf(\"%d %d %d %d\",&p,&q,&r,&b);\n\t\t\tlist[i].ratio_r = p;\n\t\t\tlist[i].ratio_b = q;\n\t\t\tlist[i].weight_r = 0;\n\t\t\tlist[i].weight_b = 0;\n\t\t\tif(r)\n\t\t\t{\n\t\t\t\tlist[i].red = &list[r-1];\n\t\t\t\tlist[r-1].parent = &list[i];\n\t\t\t}\n\t\t\telse\n\t\t\t\tlist[i].red = NULL;\n\t\t\tif(b)\n\t\t\t{\n\t\t\t\tlist[i].blue = &list[b-1];\n\t\t\t\tlist[b-1].parent = &list[i];\n\t\t\t}\n\t\t\telse\n\t\t\t\tlist[i].blue = NULL;\n\t\t}\n\t\twhile(1)\n\t\t{\n\t\t\tfor(j = 0;j < n;j++)\n\t\t\t{\n\t\t\t\tif(list[j].red == NULL && list[j].blue == NULL && list[j].flug)\n\t\t\t\t{\n\t\t\t\t\tif(list[j].weight_r == 0 && list[j].weight_b == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tlist[j].weight_r = list[j].ratio_b/gcd(list[j].ratio_r,list[j].ratio_b);\n\t\t\t\t\t\tlist[j].weight_b = list[j].ratio_r/gcd(list[j].ratio_r,list[j].ratio_b);\n\t\t\t\t\t}\n\t\t\t\t\telse if(list[j].weight_r == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tlist[j].weight_r = list[j].ratio_b/gcd(list[j].ratio_r,list[j].ratio_b)*list[j].weight_b;\n\t\t\t\t\t\tlist[j].weight_b = list[j].ratio_r/gcd(list[j].ratio_r,list[j].ratio_b)*list[j].weight_b;\n\t\t\t\t\t}\n\t\t\t\t\telse if(list[j].weight_b == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tlist[j].weight_r = list[j].ratio_b/gcd(list[j].ratio_r,list[j].ratio_b)*list[j].weight_r;\n\t\t\t\t\t\tlist[j].weight_b = list[j].ratio_r/gcd(list[j].ratio_r,list[j].ratio_b)*list[j].weight_r;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tlist[j].weight_r = list[j].ratio_b/gcd(list[j].ratio_r,list[j].ratio_b)*list[j].weight_r*list[j].weight_b/gcd(list[j].weight_r,list[j].weight_b);\n\t\t\t\t\t\tlist[j].weight_b = list[j].ratio_r/gcd(list[j].ratio_r,list[j].ratio_b)*list[j].weight_r*list[j].weight_b/gcd(list[j].weight_r,list[j].weight_b);\n\t\t\t\t\t}\n\t\t\t\t\tif(list[j].parent == NULL)\n\t\t\t\t\t{\n\t\t\t\t\t\tprintf(\"%d\\n\",list[j].weight_r+list[j].weight_b);\n\t\t\t\t\t\tgoto hell;\n\t\t\t\t\t}\n\t\t\t\t\telse if(list[j].parent->red == &list[j])\n\t\t\t\t\t{\n\t\t\t\t\t\tlist[j].parent->red = NULL;\n\t\t\t\t\t\tlist[j].parent->weight_r = list[j].weight_r+list[j].weight_b;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tlist[j].parent->blue = NULL;\n\t\t\t\t\t\tlist[j].parent->weight_b = list[j].weight_r+list[j].weight_b;\n\t\t\t\t\t}\n\t\t\t\t\tlist[j].flug = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\thell:;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\ntypedef struct _node{\n\tunsigned int p;\n\tunsigned int q;\n\tunsigned int r;\n\tunsigned int b;\n\tunsigned int left;\t//p-side mass\n\tunsigned int right;\t//q-side mass\n} Node;\nunsigned int calc_mass(unsigned int trgt);\nunsigned int calc_gcd( unsigned int a, unsigned int b);\nNode MOB[101];\n\nunsigned int main(){\n\n\tunsigned int n;\n\tunsigned int chk[101];\n\tunsigned int i;\n\tunsigned int p;\n\tunsigned int q;\n\tunsigned int r;\n\tunsigned int b;\n\tunsigned int Top;\n\tunsigned int Total;\n\tunsigned int gcd;\n\n\twhile(1){\n\t\tscanf(\"%d\\n\",&n);\n\t\tif(n==0)break;\n\n\t\tfor(i=1;i<=n;i++){\n\t\t\tscanf(\"%d %d %d %d\\n\",&p,&q,&r,&b);\n\t\t\tgcd=calc_gcd(p,q);\n\t\t\tMOB[i].p=p/gcd;\n\t\t\tMOB[i].q=q/gcd;\n\t\t\tMOB[i].r=r;\n\t\t\tMOB[i].b=b;\n\t\t\tMOB[i].left=0;\n\t\t\tMOB[i].right=0;\n\t\t\t\n\t\t}\n\t\t\n\t\t// search TOP;\n\t\tfor(i=1;i<=n;i++)chk[i]=0;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tif(MOB[i].r!=0)chk[MOB[i].r]=1;\n\t\t\tif(MOB[i].b!=0)chk[MOB[i].b]=1;\n\t\t}\n\t\tfor(i=1;i<=n;i++){\n\t\t\tif(chk[i]==0)Top=i;\n\t\t}\n\t\tTotal=calc_mass(Top);\n\t\tprintf(\"%d\\n\",Total);\n\n\t}\n\treturn 0;\n}\n\n\nunsigned int calc_gcd( unsigned int a, unsigned int b){\n\t unsigned int c=1;\n\t unsigned int gcd;\n\n        if(a==0 || b==0)return 0;\n        if(a==1 || b==1)return 1;\n\n        if(a<b){\n            c=a,a=b,b=c;\n        }\n\n        gcd=1;\n\t\n\twhile(a%b!=0){\n\t\tc=b;\n\t\tb=a%b;\n\t\ta=c;\n\t}\n\tgcd=b;\n\n\treturn gcd;\n\n}\n\n\n\nunsigned int calc_mass(unsigned int trgt){\n\tunsigned int gcd;\n\tunsigned int left,right;\n\n\tif(MOB[trgt].r==0 && MOB[trgt].b==0){\n\t\tgcd=calc_gcd(MOB[trgt].p,MOB[trgt].q);\n\t\tMOB[trgt].left=MOB[trgt].q/gcd;\n\t\tMOB[trgt].right=MOB[trgt].p/gcd;\n\t\treturn MOB[trgt].left+MOB[trgt].right;\n\t}\n\t\n\tif(MOB[trgt].left==0){\n\t\tif(MOB[trgt].r==0)left=1;\n\t\tif(MOB[trgt].r!=0)left=calc_mass(MOB[trgt].r);\n\t}\n\tif(MOB[trgt].right==0){\n\t\tif(MOB[trgt].b==0)right=1;\n\t\tif(MOB[trgt].b!=0)right=calc_mass(MOB[trgt].b);\n\t}\n\t\n\tgcd=calc_gcd(left*MOB[trgt].q,right*MOB[trgt].p);\n\tMOB[trgt].left=left*right*MOB[trgt].p/gcd;\n\tMOB[trgt].right=right*left*MOB[trgt].q/gcd;\n\treturn MOB[trgt].left+MOB[trgt].right;\n\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n\ntypedef struct{\n  char left;\n  char right;\n  char pa;\n  int lw;\n  int rw;\n}leaf;\n\nleaf mbs[100];\n\nint gcd ( int a, int b ){\n  if(b>a) return gcd(b,a);\n  int c;\n  while ( a != 0 ) {\n     c = a; a = b%a;  b = c;\n  }\n  return b;\n}\nint solve(int n){\n  int r,l;\n  r=mbs[n].right?solve(mbs[n].right-1):1;\n  l=mbs[n].left?solve(mbs[n].left-1):1;\n  return r*l/gcd(r,l)*(mbs[n].rw+mbs[n].lw)/gcd(mbs[n].rw,mbs[n].lw);\n}\nint main(){\n  int i,n,l,r;\n  do{\n    scanf(\"%d\",&n);\n    if(!n) break;\n    for(i=0;i<n;i++){\n      scanf(\"%d %d %d %d\",&(mbs[i].lw),&(mbs[i].rw),&l,&r);\n      if(r) mbs[i].right=(char)r;\n      if(l) mbs[i].left=(char)l;\n      if(l) mbs[l-1].pa=(char)i+1;\n      if(r) mbs[r-1].pa=(char)i+1;\n    }\n    for(i=0;i<n;i++) if(!mbs[i].pa) break;\n    printf(\"%d\\n\",solve(i));\n  }while(1);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\ntypedef struct _node{\n\tlong long int p;\n\tlong long int q;\n\tint r;\n\tint b;\n\tlong long int left;\t//p-side mass\n\tlong long int right;\t//q-side mass\n} Node;\nlong long int calc_mass(int trgt);\nlong long int calc_gcd( int a, int b);\nNode MOB[101];\n\nint main(){\n\n\tint n;\n\tint chk[101];\n\tint i;\n\tlong long int p;\n\tlong long int q;\n\tint r;\n\tint b;\n\tint Top;\n\tlong long int Total;\n\tlong long int gcd;\n\n\twhile(1){\n\t\tscanf(\"%d\\n\",&n);\n\t\tif(n==0)break;\n\n\t\tfor(i=1;i<=n;i++){\n\t\t\tscanf(\"%lld %lld %d %d\\n\",&p,&q,&r,&b);\n\t\t\tgcd=calc_gcd(p,q);\n\t\t\tMOB[i].p=p/gcd;\n\t\t\tMOB[i].q=q/gcd;\n\t\t\tMOB[i].r=r;\n\t\t\tMOB[i].b=b;\n\t\t\tMOB[i].left=0;\n\t\t\tMOB[i].right=0;\n\t\t\t\n\t\t}\n\t\t\n\t\t// search TOP;\n\t\tfor(i=1;i<=n;i++)chk[i]=0;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tif(MOB[i].r!=0)chk[MOB[i].r]=1;\n\t\t\tif(MOB[i].b!=0)chk[MOB[i].b]=1;\n\t\t}\n\t\tfor(i=1;i<=n;i++){\n\t\t\tif(chk[i]==0){\n\t\t\t\tTop=i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tTotal=calc_mass(Top);\n\t\tprintf(\"%lld\\n\",Total);\n\n\t}\n\treturn 0;\n}\n\n\nlong long int calc_gcd( int a, int b){\n\tlong long int c=1;\n\tlong long int gcd;\n\n//\tif(a==0 || b==0)return 0;\n//\tif(a==1 || b==1)return 1;\n\n//\tif(a<b){\n//\t\tc=a,a=b,b=c;\n//\t}\n\n        gcd=1;\n\t\n\twhile(a%b!=0){\n\t\tc=b;\n\t\tb=a%b;\n\t\ta=c;\n\t}\n\tgcd=b;\n\n\treturn gcd;\n\n}\n\n\n\nlong long int calc_mass(int trgt){\n\tlong long int gcd;\n\tlong long int left,right;\n\n\tif(MOB[trgt].r==0 && MOB[trgt].b==0){\n\t\tgcd=calc_gcd(MOB[trgt].p,MOB[trgt].q);\n\t\tMOB[trgt].left=MOB[trgt].q/gcd;\n\t\tMOB[trgt].right=MOB[trgt].p/gcd;\n\t\treturn MOB[trgt].left+MOB[trgt].right;\n\t}\n\t\n\tif(MOB[trgt].left==0){\n\t\tif(MOB[trgt].r==0)left=1;\n\t\tif(MOB[trgt].r!=0)left=calc_mass(MOB[trgt].r);\n\t}\n\tif(MOB[trgt].right==0){\n\t\tif(MOB[trgt].b==0)right=1;\n\t\tif(MOB[trgt].b!=0)right=calc_mass(MOB[trgt].b);\n\t}\n\t\n\tgcd=calc_gcd(left*MOB[trgt].q,right*MOB[trgt].p);\n\tMOB[trgt].left=left*right*MOB[trgt].p/gcd;\n\tMOB[trgt].right=right*left*MOB[trgt].q/gcd;\n\treturn MOB[trgt].left+MOB[trgt].right;\n\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    int ldata, rdata;\n    int left, right;\n    int parent;\n} BINARY;\n\nBINARY tree[101];\n\nint gcd(int a, int b)\n{\n    if (a < b){\n        a ^= b;\n        b ^= a;\n        a ^= b;\n    }\n    return (b == 0 ? a : gcd(b, a % b));\n}\n\nint lcm(int a, int b)\n{\n    return ((a / gcd(a, b)) * b);\n}\n\nint postorder(int root)\n{\n    int l, r, x, y;\n    int cd;\n    \n    if (tree[root].left){\n        l = postorder(tree[root].left);\n    }\n    else {\n        l = 1;\n    }\n    \n    if (tree[root].right){\n        r = postorder(tree[root].right);\n    }\n    else {\n        r = 1;\n    }\n    \n    if (tree[root].right + tree[root].left == 0){\n        cd = gcd(tree[root].ldata, tree[root].rdata);\n        return (tree[root].ldata / cd + tree[root].rdata / cd);\n    }\n    \n    l *= tree[root].ldata;\n    r *= tree[root].rdata;\n    cd = gcd(l, r);\n    x = r / cd;\n    y = l / cd;\n    l *= x;\n    r *= y;\n    return (l / tree[root].ldata + r / tree[root].rdata);\n}\n\nint main(void)\n{\n    int i;\n    int n;\n    int p, q, r, b;\n    int root;\n    \n    while (1){\n        \n        scanf(\"%d\", &n);\n        \n        if (n == 0){\n            break;\n        }\n        \n        memset(tree, 0, sizeof(tree));\n        for (i = 1; i <= n; i++){\n            scanf(\"%d%d%d%d\", &p, &q, &r, &b);\n            tree[i].ldata = p;\n            tree[i].rdata = q;\n            tree[i].left = r;\n            tree[i].right = b;\n            tree[r].parent = tree[b].parent = i;\n        }\n        \n        for (i = 1; i <= n; i++){\n            if (tree[i].parent == 0){\n                root = i;\n            }\n            \n        }\n        printf(\"%d\\n\", postorder(root));\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\ntypedef struct _node{\n\tlong long int p;\n\tlong long int q;\n\tlong long int r;\n\tlong long int b;\n\tlong long int left;\t//p-side mass\n\tlong long int right;\t//q-side mass\n} Node;\nlong long int calc_mass(int trgt);\nlong long int calc_gcd( long long int a, long long int b);\nNode MOB[102];\n\nint main(){\n\n\tint n;\n\tlong long int chk[102];\n\tint i;\n\tlong long int p;\n\tlong long int q;\n\tlong long int r;\n\tlong long int b;\n\tint Top;\n\tlong long int Total;\n\tlong long int gcd;\n\n\twhile(1){\n\t\tscanf(\"%d\\n\",&n);\n\t\tif(n==0)break;\n\n\t\tfor(i=1;i<=n;i++){\n\t\t\tscanf(\"%lld %lld %lld %lld\\n\",&p,&q,&r,&b);\n\t\t\tgcd=calc_gcd(p,q);\n\t\t\tMOB[i].p=p/gcd;\n\t\t\tMOB[i].q=q/gcd;\n\t\t\tMOB[i].r=r;\n\t\t\tMOB[i].b=b;\n\t\t\tMOB[i].left=0;\n\t\t\tMOB[i].right=0;\n\t\t\t\n\t\t}\n\t\t\n\t\t// search TOP;\n\t\tfor(i=1;i<=n;i++)chk[i]=0;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tif(MOB[i].r!=0)chk[MOB[i].r]=1;\n\t\t\tif(MOB[i].b!=0)chk[MOB[i].b]=1;\n\t\t}\n\t\tfor(i=1;i<=n;i++){\n\t\t\tif(chk[i]==0)Top=i;\n\t\t}\n\t\tTotal=calc_mass(Top);\n\t\tprintf(\"%lld\\n\",Total);\n\n\t}\n\treturn 0;\n}\n\n\nlong long int calc_gcd( long long int a, long long int b){\n\t long long int c=1;\n\t long long int gcd;\n\n//\tif(a==0 || b==0)return 0;\n//\tif(a==1 || b==1)return 1;\n\n//\tif(a<b){\n//\t\tc=a,a=b,b=c;\n//\t}\n\n        gcd=1;\n\t\n\twhile(a%b!=0){\n\t\tc=b;\n\t\tb=a%b;\n\t\ta=c;\n\t}\n\tgcd=b;\n\n\treturn gcd;\n\n}\n\n\n\nlong long int calc_mass(int trgt){\n//printf(\"trgt=%d\\n\",trgt);\n\tlong long int gcd;\n\tlong long int left,right;\n\tlong long int left2,right2;\n\tlong long int ratio;\n\n//\tif(MOB[trgt].r==0 && MOB[trgt].b==0){\n//\t\tgcd=calc_gcd(MOB[trgt].p,MOB[trgt].q);\n//\t\tMOB[trgt].left=MOB[trgt].q/gcd;\n//\t\tMOB[trgt].right=MOB[trgt].p/gcd;\n//\t\treturn MOB[trgt].left+MOB[trgt].right;\n//\t}\n\t\n\tif(MOB[trgt].left==0){\n\t\tif(MOB[trgt].r==0)left=1;\n\t\tif(MOB[trgt].r!=0)left=calc_mass(MOB[trgt].r);\n\t}\n\tif(MOB[trgt].right==0){\n\t\tif(MOB[trgt].b==0)right=1;\n\t\tif(MOB[trgt].b!=0)right=calc_mass(MOB[trgt].b);\n\t}\n\t\n\n\n\tgcd=calc_gcd(right,left);\n\tleft2=left/gcd,right2=right/gcd;\n\tgcd=calc_gcd(left2*MOB[trgt].q,right2*MOB[trgt].p);\n\tratio=(right2*MOB[trgt].p)/gcd;\n\tMOB[trgt].left=left*ratio;\n\t\n\tratio=(left2*MOB[trgt].q)/gcd;\n\tMOB[trgt].right=right*ratio;\n\t\n\treturn MOB[trgt].left+MOB[trgt].right;\n\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#define min(a,b) (a<b?a:b)\nstruct x{int p,q,r,b;}B[105];\nint N,i,j,h[105],r,t;\n\nint gcd(int a,int b)\n{\n\tint c;\n\tfor(;b!=0;)\n\t{\n\t\tc=a%b;a=b;b=c;\n\t}\n\treturn a;\n}\n\nint dfs(int p)\n{\n\tint r,b,i,j,ta,tb,ri,rj,t1,t2;\n\tif(p==-1)return 1;\n\tif(h[p]>=0)return h[p];\n\tr=dfs(B[p].r);\n\tb=dfs(B[p].b);\n\tfor(i=1,ri=rj=-1;i<=10000000;i++)\n\t{\n\t\tif((r*i*B[p].p)%(b*B[p].q))continue;\n\t\tj=(r*i*B[p].p)/(b*B[p].q);\n\t\tta=r*i/B[p].q;\n\t\ttb=b*j/B[p].p;\n\t\tif(ta&&tb&&ta==tb)\n\t\t{\n\t\t\tif(ri==-1||ri*r+rj*b>i*r+j*b)\n\t\t\t{\n\t\t\t\tri=i;\n\t\t\t\trj=j;\n\t\t\t\tgoto e;\n\t\t\t}\n\t\t}\n\t}\n\te:\n\tif(rj==-1)ri=rj=(r*b)/gcd(r,b);\n\treturn h[p]=r*ri+b*rj;\n}\n\nint main()\n{\n\tfor(;scanf(\"%d\",&N),N;)\n\t{\n\t\tmemset(h,-1,sizeof(h));\n\t\tfor(i=0;i<N;i++)\n\t\t{\n\t\t\tscanf(\"%d%d%d%d\",&B[i].p,&B[i].q,&B[i].r,&B[i].b);\n\t\t\tt=gcd(B[i].p,B[i].q);\n\t\t\tB[i].p/=t;B[i].q/=t;\n\t\t\tB[i].r--;B[i].b--;\n\t\t}\n\t\tfor(i=r=0;i<N;i++)\n\t\t{\n\t\t\tt=dfs(i);\n\t\t\tr=r>t?r:t;\n\t\t}\n\t\tprintf(\"%d\\n\",r);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nstruct x{int p,q,r,b;}B[105];\nint N,i,j,t,h[105],r,b,g;\n\nint gcd(int a,int b)\n{\n\tint c;\n\tfor(;b!=0;)\n\t{\n\t\tc=a%b;a=b;b=c;\n\t}\n\treturn a;\n}\n\nint LCM(int x,int y)\n{\n\tint i;\n\tfor(i=1;i<=y;i++)\n\t{\n\t\tif((x*i)%y==0)\n\t\t\treturn x*i;\n\t}\n\treturn x*y;\n}\n\nint wg(int b)\n{\n\tif(b==-1)return 1;\n\treturn h[b];\n}\n\nint main()\n{\n\tfor(;scanf(\"%d\",&N),N;)\n\t{\n\t\tmemset(h,-1,sizeof(h));\n\t\tfor(i=0;i<N;i++)\n\t\t{\n\t\t\tscanf(\"%d%d%d%d\",&B[i].p,&B[i].q,&B[i].r,&B[i].b);\n\t\t\tt=gcd(B[i].p,B[i].q);\n\t\t\tB[i].p/=t;B[i].q/=t;\n\t\t\tB[i].r--;B[i].b--;\n\t\t}\n\t\tfor(i=0;i<N;i++)\n\t\t\tfor(j=0;j<N;j++)\n\t\t\t{\n\t\t\t\tif(h[j]==-1&&wg(B[j].r)>=0&&wg(B[j].b)>=0)\n\t\t\t\t{\n\t\t\t\t\tg=LCM(wg(B[j].r),wg(B[j].b));\n\t\t\t\t\th[j]=g*(B[j].p+B[j].q);\n\t\t\t\t}\n\t\t\t}\n\t\tfor(i=r=0;i<N;i++)\n\t\t\tr=r<h[i]?h[i]:r;\n\t\tprintf(\"%d\\n\",r);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A0520\nLightest Mobile\n*/\n#include <stdio.h>\n\n\nstruct MOB\n{\n  int leftlen   ;int rightlen;\n  int leftnode  ;int rightnode;\n} ;\nstruct MOB mobiles[100];\nint prime[10]={2,3,5,7,11,13,17,19,23,29};\nlong int gcd(long int x,long int y)\n{ long int w,r;\n  int i,pr;\n  for(i=0;i<10;i++)\n    {\n      pr=prime[i];\n      if(x % pr == 0 && y % pr == 0)\n\treturn(pr*gcd(x/pr,y/pr));\n    }\n  if(x < y)\n    {\n      w = x;\n      x = y;\n      y=  w;\n    }\n  if((r = x % y) ==0)\n    return(y);\n  return(gcd (y, r));\n}\n\nlong int lcm(long int x,long int y)\n{\n  return(x/gcd(x,y)*y);\n}\n\nlong int calc_total_weight1(int leftlen, int rightlen,long int leftweight , long int rightweight)\n{\n  long int l;\n\n  l=lcm((leftlen *rightweight),(rightlen * leftweight));\n  return(l/leftlen+l/rightlen);\n}\n\nlong int calc_total_weight(struct MOB *m,int node_no)\n{ long int w1,w2,tw;\n  struct MOB * bar;\n  bar = m + (node_no - 1);\n\n\n  if(bar -> leftnode != 0)\n    w1 = calc_total_weight(m,(bar->leftnode));\n  else\n    w1 = 1;\n  if(bar -> rightnode != 0)\n    w2 = calc_total_weight(m,(bar->rightnode));\n  else\n    w2 = 1;\n\n  tw = calc_total_weight1(bar->leftlen,bar->rightlen,w1,w2);\n\n  return(tw);\n    \n}\n\nint search_root(struct MOB * m,int siz)\n{\n  int i,j;\n  for(i=1;i<=siz;i++)\n    {  for(j=0;j<siz;j++)\n      {\n        if(m[j].leftnode == i ||m[j].rightnode == i)\n          goto AAA;\n      }\n      return(i);\n    AAA:\n      ;\n    }\n   return(-1);\n\n}\n\n\nmain()\n{\nint i;\nlong int total_weight;\nint  root;\nint  cnt;\n  \n  while(EOF != scanf(\"%d\",&cnt) && cnt)\n    {     \n      for(i=0;i<cnt;i++)\n         scanf(\" %d %d %d %d\",\n               &(mobiles[i].leftlen),\n               &(mobiles[i].rightlen),\n               &(mobiles[i].leftnode),\n               &(mobiles[i].rightnode));\n    \n  \n  root = search_root(mobiles,cnt);    \n  total_weight = calc_total_weight(mobiles,root);\n\n  printf(\"%ld\\n\",total_weight);\n    }\nreturn(0);\n}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A0520\nLightest Mobile\n*/\n#include <stdio.h>\n\n\nstruct MOB\n{\n  int leftlen   ;int rightlen;\n  int leftnode  ;int rightnode;\n} ;\nstruct MOB mobiles[100];\n/*\nstruct MOB mobiles1[]=   {{1, 2, 0, 0},{1, 2, 0, 0},{1, 2, 1, 2},{1, 2, 3, 0}};\nstruct MOB mobiles2[]=   {{3, 2, 0, 4},{1, 3, 0, 0},{4, 4, 2, 1},{2, 2, 0, 0}};\nstruct MOB mobiles3[]=   {{1, 2, 0, 0},{1, 2, 0, 0},{1, 2, 1, 2},{1, 2, 3, 0},{1,2,4,0}};\n*/\n\nlong int gcd(long int x,long int y)\n{ long int w,r;\n  if(x < y)\n    {\n      w = x;\n      x = y;\n      y=  w;\n    }\n  if((r = x % y) ==0)\n    return(y);\n  return(gcd (y, r));\n}\n\nlong int lcm(long int x,long int y)\n{\n  return(x*y/gcd(x,y));\n}\n\nlong int calc_total_weight1(int leftlen, int rightlen,long int leftweight , long int rightweight)\n{\n  long int l;\n\n/*Dprintf(\"%d %d %d %d \\n\",leftlen ,rightlen,leftweight , rightweight);*/\n\n  l=lcm((leftlen *rightweight),(rightlen * leftweight));\n  return(l/leftlen+l/rightlen);\n}\n\nlong int calc_total_weight(struct MOB *m,int node_no)\n{ long int w1,w2,tw;\n  struct MOB * bar;\n  bar = m + (node_no - 1);\n\n/*Dprintf(\"%d L=%d R=%d\\n\",node_no,bar->leftnode,bar->rightnode);  */\n  if(bar -> leftnode != 0)\n    w1 = calc_total_weight(m,(bar->leftnode));\n  else\n    w1 = 1;\n  if(bar -> rightnode != 0)\n    w2 = calc_total_weight(m,(bar->rightnode));\n  else\n    w2 = 1;\n\n  tw = calc_total_weight1(bar->leftlen,bar->rightlen,w1,w2);\n/*Dprintf(\"tw=%ld\\n\",tw);*/\n  return(tw);\n    \n}\n\nint search_root(struct MOB * m,int siz)\n{\n  int i,j;\n  for(i=1;i<=siz;i++)\n    {  for(j=0;j<siz;j++)\n      {\n        if(m[j].leftnode == i ||m[j].rightnode == i)\n          goto AAA;\n      }\n      return(i);\n    AAA:\n      ;\n    }\n   return(-1);\n\n}\n\n\nmain()\n{\nint i;\nlong int total_weight;\nint  root;\nint  cnt;\n  \n  while(EOF != scanf(\"%d\",&cnt))\n    {     \n      for(i=0;i<cnt;i++)\n         scanf(\" %d %d %d %d\",\n               &(mobiles[i].leftlen),\n               &(mobiles[i].rightlen),\n               &(mobiles[i].leftnode),\n               &(mobiles[i].rightnode));\n    \n\n/*\n  for(i=0;i<4;i++)\n    {\n         printf(\" %d %d %d %d\\n\",\n               (mobiles[i].leftlen),\n               (mobiles[i].rightlen),\n               (mobiles[i].leftnode),\n               (mobiles[i].rightnode));\n    }\n*/\n  \n  root = search_root(mobiles,cnt);    \n  total_weight = calc_total_weight(mobiles,root);\n\n  printf(\"%ld\\n\",total_weight);\n    }\nreturn(0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\ntypedef struct {\n\tlong long p,q,r,b;\n} mobile;\n\nmobile bar[100];\nlong long data[100];\n\nlong long kbs(long long a, long long b){\n\tif(a>b){\n\t\tif(a%b==0) return b;\n\t\telse return kbs(a%b,b);\n\t}else{\n\t\tif(b%a==0) return a;\n\t\telse return kbs(a,b%a);\n\t}\n}\n\nlong long weight(int i){\n\tif(data[i-1]>0) return data[i-1];\n\tlong long j,a,b;\n\tif(bar[i-1].r==0 && bar[i-1].b==0){\n\t\tj=kbs(bar[i-1].p,bar[i-1].q);\n\t\treturn data[i-1]=bar[i-1].p/j+bar[i-1].q/j;\n\t}else if(bar[i-1].r==0){\n\t\tb=bar[i-1].q*weight(bar[i-1].b);\n\t\tj=kbs(bar[i-1].p,b);\n\t\treturn data[i-1]=weight(bar[i-1].b)*bar[i-1].p/j+b/j;\n\t}else if(bar[i-1].b==0){\n\t\ta=bar[i-1].p*weight(bar[i-1].r);\n\t\tj=kbs(bar[i-1].q,a);\n\t\treturn data[i-1]=weight(bar[i-1].r)*bar[i-1].q/j+a/j;\n\t}else{\n\t\ta=bar[i-1].q*weight(bar[i-1].b);\n\t\tb=bar[i-1].p*weight(bar[i-1].r);\n\t\tj=kbs(a,b);\n\t\treturn data[i-1]=weight(bar[i-1].r)*b/j+weight(bar[i-1].b)*a/j;\n\t}\n}\n\nint main(){\n\tint n,i;\n\tlong long heavy,max;\n\tscanf(\"%d\",&n);\n\twhile(n!=0){\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%lld %lld %lld %lld\",&bar[i].p,&bar[i].q,&bar[i].r,&bar[i].b);\n\t\t}\n\t\tfor(i=0;i<n;i++){\n\t\t\tdata[i]=0;\n\t\t}\n\t\theavy=0;\n\t\tmax=0;\n\t\tfor(i=1;i<=n;i++){\n\t\t\theavy=weight(i);\n\t\t\tmax=max<heavy?heavy:max;\n\t\t}\n\t\tprintf(\"%lld\\n\",max);\n\t\tscanf(\"%d\",&n);\n\t}\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\ntypedef struct _node{\n\tunsigned long long p;\n\tunsigned long long q;\n\tunsigned long long r;\n\tunsigned long long b;\n\tunsigned long long left;\t//p-side mass\n\tunsigned long long right;\t//q-side mass\n} Node;\nunsigned long long calc_mass(unsigned long long trgt);\nunsigned long long calc_gcd( unsigned long long a, unsigned long long b);\nNode MOB[101];\n\nint main(){\n\n\tunsigned long long n;\n\tunsigned long long chk[101];\n\tunsigned long long i;\n\tunsigned long long p;\n\tunsigned long long q;\n\tunsigned long long r;\n\tunsigned long long b;\n\tunsigned long long Top;\n\tunsigned long long Total;\n\tunsigned long long gcd;\n\n\twhile(1){\n\t\tscanf(\"%llu\\n\",&n);\n\t\tif(n==0)break;\n\n\t\tfor(i=1;i<=n;i++){\n\t\t\tscanf(\"%llu %llu %llu %llu\\n\",&p,&q,&r,&b);\n\t\t\tgcd=calc_gcd(p,q);\n\t\t\tMOB[i].p=p/gcd;\n\t\t\tMOB[i].q=q/gcd;\n\t\t\tMOB[i].r=r;\n\t\t\tMOB[i].b=b;\n\t\t\tMOB[i].left=0;\n\t\t\tMOB[i].right=0;\n\t\t\t\n\t\t}\n\t\t\n\t\t// search TOP;\n\t\tfor(i=1;i<=n;i++)chk[i]=0;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tif(MOB[i].r!=0)chk[MOB[i].r]=1;\n\t\t\tif(MOB[i].b!=0)chk[MOB[i].b]=1;\n\t\t}\n\t\tfor(i=1;i<=n;i++){\n\t\t\tif(chk[i]==0)Top=i;\n\t\t}\n\t\tTotal=calc_mass(Top);\n\t\tprintf(\"%llu\\n\",Total);\n\n\t}\n\treturn 0;\n}\n\n\nunsigned long long calc_gcd( unsigned long long a, unsigned long long b){\n\t unsigned long long c=1;\n\t unsigned long long gcd;\n\n        if(a==0 || b==0)return 0;\n        if(a==1 || b==1)return 1;\n\n        if(a<b){\n            c=a,a=b,b=c;\n        }\n\n        gcd=1;\n\t\n\twhile(a%b!=0){\n\t\tc=b;\n\t\tb=a%b;\n\t\ta=c;\n\t}\n\tgcd=b;\n\n\treturn gcd;\n\n}\n\n\n\nunsigned long long calc_mass(unsigned long long trgt){\n\tunsigned long long gcd;\n\tunsigned long long left,right;\n\tunsigned long long left2,right2;\n\tunsigned long long ratio;\n\n//\tif(MOB[trgt].r==0 && MOB[trgt].b==0){\n//\t\tgcd=calc_gcd(MOB[trgt].p,MOB[trgt].q);\n//\t\tMOB[trgt].left=MOB[trgt].q/gcd;\n//\t\tMOB[trgt].right=MOB[trgt].p/gcd;\n//\t\treturn MOB[trgt].left+MOB[trgt].right;\n//\t}\n\t\n\tif(MOB[trgt].left==0){\n\t\tif(MOB[trgt].r==0)left=1;\n\t\tif(MOB[trgt].r!=0)left=calc_mass(MOB[trgt].r);\n\t}\n\tif(MOB[trgt].right==0){\n\t\tif(MOB[trgt].b==0)right=1;\n\t\tif(MOB[trgt].b!=0)right=calc_mass(MOB[trgt].b);\n\t}\n\t\n\n\n\tgcd=calc_gcd(right,left);\n\tleft2=left/gcd,right2=right/gcd;\n\tgcd=calc_gcd(left2*MOB[trgt].q,right2*MOB[trgt].p);\n\tratio=(right2*MOB[trgt].p)/gcd;\n\tMOB[trgt].left=left*ratio;\n\t\n\tratio=(left2*MOB[trgt].q)/gcd;\n\tMOB[trgt].right=right*ratio;\n\t\n\treturn MOB[trgt].left+MOB[trgt].right;\n\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 0520: Lightest Mobile\n// 2017.10.28 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\ntypedef struct { int p, q, r, b; } T;\nT t[102];\nchar f[102];\n\nint gcd(int a, int b)\n{\n\tint r;\n\twhile (b != 0) r = a % b, a = b, b = r;\n\treturn a;\n}\n\nint lcm(int a, int b)\n{\n\treturn a / gcd(a, b) * b;\n}\n\nint calc(int i)\n{\n\tint w, wr, wb;\n\twr = (t[i].r > 0) ? calc(t[i].r) : 1;\n\twb = (t[i].b > 0) ? calc(t[i].b) : 1;\n\tw = lcm(t[i].p * wr, t[i].q * wb);\n\treturn w/t[i].p + w/t[i].q;\n}\n\nint main()\n{\n\tint n, i;\n\n\twhile (scanf(\"%d\", &n) && n > 0) {\n\t\tmemset(f, 0, sizeof(f));\n\t\tfor (i = 1; i <= n; i++) {\n\t\t\tscanf(\"%d%d%d%d\", &t[i].p, &t[i].q, &t[i].r, &t[i].b);\n\t\t\tif (t[i].r > 0) f[t[i].r] = i;\n\t\t\tif (t[i].b > 0) f[t[i].b] = i;\n\t\t}\n\t\tfor (i = 1; f[i]; i++);\n\t\tprintf(\"%d\\n\", calc(i));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <cstdio>\nusing namespace std;\n\ntypedef struct stick{\n int lren, rren, sl, sr, weight; \n} STICK;\n\nint n, tmp, top;\nint depth[101];\nSTICK st[101];\n\nvoid init(int k){\n for(int i = 0; i <= k; i++){\n  depth[i] = 0;\n  st[i].weight = 0;\n }\n}\n\nint gcd(int a, int b){\n if(b == 0) return a;\n return gcd(b, a % b);\n}\n\nint lcm(int a, int b){\n return a / gcd(a, b) * b;\n}\n\nint solve(int k){\n if(st[k].weight > 0) return st[k].weight;\n if(st[k].sl == 0 && st[k].sr == 0){\n  return st[k].weight = st[k].lren + st[k].rren;\n }else if(st[k].sl == 0){\n  return st[k].weight = solve(st[k].sr) * (st[k].lren + st[k].rren) / gcd(solve(st[k].sr), st[k].lren);\n }else if(st[k]. sr == 0){\n  return st[k].weight = solve(st[k].sl) * (st[k].lren + st[k].rren) / gcd(solve(st[k].sl), st[k].rren);\n }else {\n  tmp = lcm(solve(st[k].sl) * st[k].lren, solve(st[k].sr) * st[k].rren);\n  return st[k].weight = tmp / st[k].lren + tmp / st[k].rren;\n }\n}\n\nint main(){\n while(scanf(\"%d\", &n)){\n  if(n == 0) break;\n  init(n);\n  for(int i = 1; i <= n; i++){\n   scanf(\"%d %d %d %d\", &st[i].lren, &st[i].rren, &st[i].sl, &st[i].sr);\n   tmp = gcd(st[i].lren, st[i].rren);\n   st[i].lren /= tmp;\n   st[i].rren /= tmp;\n  }\n  for(int i = 1; i <= n; i++){\n   depth[st[i].sl]++;\n   depth[st[i].sr]++;\n  }\n  for(int i = 1; i<= n; i++){\n   if(depth[i] == 0){\n    top = i;\n    break;\n   }\n  }\n  printf(\"%d\\n\", solve(top));\n }\n return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\ntypedef struct _node{\n\tlong long int p;\n\tlong long int q;\n\tint r;\n\tint b;\n\tlong long int left;\t//p-side mass\n\tlong long int right;\t//q-side mass\n} Node;\nlong long int calc_mass(int trgt);\nlong long int calc_gcd( int a, int b);\nNode MOB[101];\n\nint main(){\n\n\tint n;\n\tint chk[101];\n\tint i;\n\tlong long int p;\n\tlong long int q;\n\tint r;\n\tint b;\n\tint Top;\n\tlong long int Total;\n\tlong long int gcd;\n\n\twhile(1){\n\t\tscanf(\"%d\\n\",&n);\n\t\tif(n==0)break;\n\n\t\tfor(i=1;i<=n;i++){\n\t\t\tscanf(\"%lld %lld %d %d\\n\",&p,&q,&r,&b);\n\t\t\tgcd=calc_gcd(p,q);\n\t\t\tMOB[i].p=p/gcd;\n\t\t\tMOB[i].q=q/gcd;\n\t\t\tMOB[i].r=r;\n\t\t\tMOB[i].b=b;\n\t\t\tMOB[i].left=0;\n\t\t\tMOB[i].right=0;\n\t\t\t\n\t\t}\n\t\t\n\t\t// search TOP;\n\t\tfor(i=1;i<=n;i++)chk[i]=0;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tif(MOB[i].r!=0)chk[MOB[i].r]=1;\n\t\t\tif(MOB[i].b!=0)chk[MOB[i].b]=1;\n\t\t}\n\t\tfor(i=1;i<=n;i++){\n\t\t\tif(chk[i]==0){\n\t\t\t\tTop=i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tTotal=calc_mass(Top);\n\t\tprintf(\"%lld\\n\",Total);\n\n\t}\n\treturn 0;\n}\n\n\nlong long int calc_gcd( long long int a, long long int b){\n\tlong long int c=1;\n\tlong long int gcd;\n\n//\tif(a==0 || b==0)return 0;\n//\tif(a==1 || b==1)return 1;\n\n//\tif(a<b){\n//\t\tc=a,a=b,b=c;\n//\t}\n\n        gcd=1;\n\t\n\twhile(a%b!=0){\n\t\tc=b;\n\t\tb=a%b;\n\t\ta=c;\n\t}\n\tgcd=b;\n\n\treturn gcd;\n\n}\n\n\n\nlong long int calc_mass(int trgt){\n\tlong long int gcd;\n\tlong long int left,right;\n\n\tif(MOB[trgt].r==0 && MOB[trgt].b==0){\n\t\tgcd=calc_gcd(MOB[trgt].p,MOB[trgt].q);\n\t\tMOB[trgt].left=MOB[trgt].q/gcd;\n\t\tMOB[trgt].right=MOB[trgt].p/gcd;\n\t\treturn MOB[trgt].left+MOB[trgt].right;\n\t}\n\t\n\tif(MOB[trgt].left==0){\n\t\tif(MOB[trgt].r==0)left=1;\n\t\tif(MOB[trgt].r!=0)left=calc_mass(MOB[trgt].r);\n\t}\n\tif(MOB[trgt].right==0){\n\t\tif(MOB[trgt].b==0)right=1;\n\t\tif(MOB[trgt].b!=0)right=calc_mass(MOB[trgt].b);\n\t}\n\t\n\tgcd=calc_gcd(left*MOB[trgt].q,right*MOB[trgt].p);\n\tMOB[trgt].left=left*right*MOB[trgt].p/gcd;\n\tMOB[trgt].right=right*left*MOB[trgt].q/gcd;\n\treturn MOB[trgt].left+MOB[trgt].right;\n\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint gcm(int a,int b){\n\tint c;\n\tif(b>a)c=a,a=b,b=c;\n\twhile(1){\n\t\tc=a%b;\n\t\ta=b,b=c;\n\t\tif(c==0)return a;\n\t}\n}\nint main(){\n\tint n,i,j,f,x,y,ans;\n\tint p[105],q[105],r[105],b[105],w[105];\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tmemset(w,-1,sizeof(w));\n\t\tfor(i=1;i<=n;i++){\n\t\t\tscanf(\"%d%d%d%d\",&p[i],&q[i],&r[i],&b[i]);\n\t\t\tif(r[i]==0 && b[i]==0){\n\t\t\t\tx=gcm(p[i],q[i]);\n\t\t\t\tw[i]=p[i]/x+q[i]/x;\n\t\t\t}\n\t\t}\n\t\twhile(1){\n\t\t\tf=0;\n\t\t\tfor(i=1;i<=n;i++){\n\t\t\t\tif(w[i]<0 && (r[i]==0 || w[r[i]]>0) && (b[i]==0 || w[b[i]]>0)){\n\t\t\t\t\tf=1;\n\t\t\t\t\tif(r[i]==0 && b[i]>0){\n\t\t\t\t\t\tx=gcm(p[i],q[i]);\n\t\t\t\t\t\ty=gcm(q[i]/x,w[b[i]]);\n\t\t\t\t\t\tw[i]=w[b[i]]*q[i]/y*(p[i]/x+q[i]/x);\n\t\t\t\t\t}else if(r[i]>0 && b[i]==0){\n\t\t\t\t\t\tx=gcm(p[i],q[i]);\n\t\t\t\t\t\ty=gcm(p[i]/x,w[r[i]]);\n\t\t\t\t\t\tw[i]=w[r[i]]*p[i]/y*(p[i]/x+q[i]/x);\n\t\t\t\t\t}else if(w[r[i]]>0 && w[b[i]]>0){\n\t\t\t\t\t\tx=gcm(p[i],q[i]);\n\t\t\t\t\t\ty=gcm(p[i]*w[b[i]],q[i]*w[r[i]]);\n\t\t\t\t\t\tw[i]=w[r[i]]*p[i]*w[b[i]]/y+w[b[i]]*q[i]*w[r[i]]/y;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f==0)break;\n\t\t}\n\t\tans=0;\n\t\tfor(i=1;i<=n;i++)if(w[i]>ans)ans=w[i];//printf(\"%d:%d\\n\",i,w[i]);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\ntypedef struct _node{\n\tunsigned int p;\n\tunsigned int q;\n\tunsigned int r;\n\tunsigned int b;\n\tunsigned int left;\t//p-side mass\n\tunsigned int right;\t//q-side mass\n} Node;\nunsigned int calc_mass(unsigned int trgt);\nunsigned int calc_gcd( unsigned int a, unsigned int b);\nNode MOB[101];\n\nunsigned int main(){\n\n\tunsigned int n;\n\tunsigned int chk[101];\n\tunsigned int i;\n\tunsigned int p;\n\tunsigned int q;\n\tunsigned int r;\n\tunsigned int b;\n\tunsigned int Top;\n\tunsigned int Total;\n\tunsigned int gcd;\n\n\twhile(1){\n\t\tscanf(\"%u\\n\",&n);\n\t\tif(n==0)break;\n\n\t\tfor(i=1;i<=n;i++){\n\t\t\tscanf(\"%u %u %u %u\\n\",&p,&q,&r,&b);\n\t\t\tgcd=calc_gcd(p,q);\n\t\t\tMOB[i].p=p/gcd;\n\t\t\tMOB[i].q=q/gcd;\n\t\t\tMOB[i].r=r;\n\t\t\tMOB[i].b=b;\n\t\t\tMOB[i].left=0;\n\t\t\tMOB[i].right=0;\n\t\t\t\n\t\t}\n\t\t\n\t\t// search TOP;\n\t\tfor(i=1;i<=n;i++)chk[i]=0;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tif(MOB[i].r!=0)chk[MOB[i].r]=1;\n\t\t\tif(MOB[i].b!=0)chk[MOB[i].b]=1;\n\t\t}\n\t\tfor(i=1;i<=n;i++){\n\t\t\tif(chk[i]==0)Top=i;\n\t\t}\n\t\tTotal=calc_mass(Top);\n\t\tprintf(\"%u\\n\",Total);\n\n\t}\n\treturn 0;\n}\n\n\nunsigned int calc_gcd( unsigned int a, unsigned int b){\n\t unsigned int c=1;\n\t unsigned int gcd;\n\n        if(a==0 || b==0)return 0;\n        if(a==1 || b==1)return 1;\n\n        if(a<b){\n            c=a,a=b,b=c;\n        }\n\n        gcd=1;\n\t\n\twhile(a%b!=0){\n\t\tc=b;\n\t\tb=a%b;\n\t\ta=c;\n\t}\n\tgcd=b;\n\n\treturn gcd;\n\n}\n\n\n\nunsigned int calc_mass(unsigned int trgt){\n\tunsigned int gcd;\n\tunsigned int left,right;\n\tunsigned int left2,right2;\n\tunsigned int ratio;\n\n\tif(MOB[trgt].r==0 && MOB[trgt].b==0){\n\t\tgcd=calc_gcd(MOB[trgt].p,MOB[trgt].q);\n\t\tMOB[trgt].left=MOB[trgt].q/gcd;\n\t\tMOB[trgt].right=MOB[trgt].p/gcd;\n\t\treturn MOB[trgt].left+MOB[trgt].right;\n\t}\n\t\n\tif(MOB[trgt].left==0){\n\t\tif(MOB[trgt].r==0)left=1;\n\t\tif(MOB[trgt].r!=0)left=calc_mass(MOB[trgt].r);\n\t}\n\tif(MOB[trgt].right==0){\n\t\tif(MOB[trgt].b==0)right=1;\n\t\tif(MOB[trgt].b!=0)right=calc_mass(MOB[trgt].b);\n\t}\n\t\n\n\n\tgcd=calc_gcd(right,left)\n\tleft2=left/gcd,right2=right/gcd;\n\tgcd=calc_gcd(left2*MOB[trgt].q,right2*MOB[trgt].p);\n\tratio=(right2*MOB[trgt].p)/gcd;\n\tMOB[trgt].left=left*ratio;\n\t\n\tratio=(left2*MOB[trgt].q)/gcd;\n\tMOB[trgt].right=right*ratio;\n\t\n\treturn MOB[trgt].left+MOB[trgt].right;\n\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint bar_num;\nint bar_info[101][4];\n\nint get_gcd(int a,int b) {\n\tif(a<b)return get_gcd(b,a);\n\tif(b<=0)return a;\n\treturn get_gcd(b,a%b);\n}\n\nint get_weight(int id) {\n\tint a,b,gcd,force;\n\tif(id==0)return 1;\n\ta=get_weight(bar_info[id][2])*bar_info[id][0];\n\tb=get_weight(bar_info[id][3])*bar_info[id][1];\n\tgcd=get_gcd(a,b);\n\tforce=a/gcd*b;\n\treturn force/bar_info[id][0]+force/bar_info[id][1];\n}\n\nint main(void) {\n\tint i;\n\tint current;\n\tint found;\n\twhile(1) {\n\t\tscanf(\"%d\",&bar_num);\n\t\tif(bar_num==0)break;\n\t\tfor(i=1;i<=bar_num;i++) {\n\t\t\tscanf(\"%d%d%d%df\",\n\t\t\t\t&bar_info[i][0],&bar_info[i][1],\n\t\t\t\t&bar_info[i][2],&bar_info[i][3]);\n\t\t}\n\t\tcurrent=-1;\n\t\tfor(i=1;i<=bar_num;i++) {\n\t\t\tif(bar_info[i][2]==0 && bar_info[i][3]==0) {\n\t\t\t\tcurrent=i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(current<0)return 1;\n\t\tfound=1;\n\t\twhile(found) {\n\t\t\tfound=0;\n\t\t\tfor(i=1;i<=bar_num;i++) {\n\t\t\t\tif(bar_info[i][2]==current || bar_info[i][3]==current) {\n\t\t\t\t\tcurrent=i;\n\t\t\t\t\tfound=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",get_weight(current));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\ntypedef struct _node{\n\tint p;\n\tint q;\n\tint r;\n\tint b;\n\tint left;\t//p-side mass\n\tint right;\t//q-side mass\n} Node;\nint calc_mass(int trgt);\nint calc_gcd( int a, int b);\nNode MOB[101];\n\nint main(){\n\n\tint n;\n\tint chk[101];\n\tint i;\n\tint p;\n\tint q;\n\tint r;\n\tint b;\n\tint Top;\n\tint Total;\n\tint gcd;\n\n\twhile(1){\n\t\tscanf(\"%d\\n\",&n);\n\t\tif(n==0)break;\n\n\t\tfor(i=1;i<=n;i++){\n\t\t\tscanf(\"%d %d %d %d\\n\",&p,&q,&r,&b);\n\t\t\tgcd=calc_gcd(p,q);\n\t\t\tMOB[i].p=p/gcd;\n\t\t\tMOB[i].q=q/gcd;\n\t\t\tMOB[i].r=r;\n\t\t\tMOB[i].b=b;\n\t\t\tMOB[i].left=0;\n\t\t\tMOB[i].right=0;\n\t\t\t\n\t\t}\n\t\t\n\t\t// search TOP;\n\t\tfor(i=1;i<=n;i++)chk[i]=0;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tif(MOB[i].r!=0)chk[MOB[i].r]=1;\n\t\t\tif(MOB[i].b!=0)chk[MOB[i].b]=1;\n\t\t}\n\t\tfor(i=1;i<=n;i++){\n\t\t\tif(chk[i]==0){\n\t\t\t\tTop=i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tTotal=calc_mass(Top);\n\t\tprintf(\"%d\\n\",Total);\n\n\t}\n\treturn 0;\n}\n\n\nint calc_gcd( int a, int b){\n\t int c=1;\n\t int gcd;\n\n        if(a==0 || b==0)return 0;\n        if(a==1 || b==1)return 1;\n\n        if(a<b){\n            c=a,a=b,b=c;\n        }\n\n        gcd=1;\n\t\n\twhile(a%b!=0){\n\t\tc=b;\n\t\tb=a%b;\n\t\ta=c;\n\t}\n\tgcd=b;\n\n\treturn gcd;\n\n}\n\n\n\nint calc_mass(int trgt){\n\tint gcd;\n\tint left,right;\n\n\tif(MOB[trgt].r==0 && MOB[trgt].b==0){\n\t\tgcd=calc_gcd(MOB[trgt].p,MOB[trgt].q);\n\t\tMOB[trgt].left=MOB[trgt].q/gcd;\n\t\tMOB[trgt].right=MOB[trgt].p/gcd;\n\t\treturn MOB[trgt].left+MOB[trgt].right;\n\t}\n\t\n\tif(MOB[trgt].left==0){\n\t\tif(MOB[trgt].r==0)left=1;\n\t\tif(MOB[trgt].r!=0)left=calc_mass(MOB[trgt].r);\n\t}\n\tif(MOB[trgt].right==0){\n\t\tif(MOB[trgt].b==0)right=1;\n\t\tif(MOB[trgt].b!=0)right=calc_mass(MOB[trgt].b);\n\t}\n\t\n\tgcd=calc_gcd(left*MOB[trgt].q,right*MOB[trgt].p);\n\tMOB[trgt].left=left*right*MOB[trgt].p/gcd;\n\tMOB[trgt].right=right*left*MOB[trgt].q/gcd;\n\treturn MOB[trgt].left+MOB[trgt].right;\n\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\ntypedef struct _node{\n\tunsigned long p;\n\tunsigned long q;\n\tunsigned long r;\n\tunsigned long b;\n\tunsigned long left;\t//p-side mass\n\tunsigned long right;\t//q-side mass\n} Node;\nunsigned long calc_mass(unsigned long trgt);\nunsigned long calc_gcd( unsigned long a, unsigned long b);\nNode MOB[101];\n\nint main(){\n\n\tunsigned long n;\n\tunsigned long chk[101];\n\tunsigned long i;\n\tunsigned long p;\n\tunsigned long q;\n\tunsigned long r;\n\tunsigned long b;\n\tunsigned long Top;\n\tunsigned long Total;\n\tunsigned long gcd;\n\n\twhile(1){\n\t\tscanf(\"%lu\\n\",&n);\n\t\tif(n==0)break;\n\n\t\tfor(i=1;i<=n;i++){\n\t\t\tscanf(\"%lu %lu %lu %lu\\n\",&p,&q,&r,&b);\n\t\t\tgcd=calc_gcd(p,q);\n\t\t\tMOB[i].p=p/gcd;\n\t\t\tMOB[i].q=q/gcd;\n\t\t\tMOB[i].r=r;\n\t\t\tMOB[i].b=b;\n\t\t\tMOB[i].left=0;\n\t\t\tMOB[i].right=0;\n\t\t\t\n\t\t}\n\t\t\n\t\t// search TOP;\n\t\tfor(i=1;i<=n;i++)chk[i]=0;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tif(MOB[i].r!=0)chk[MOB[i].r]=1;\n\t\t\tif(MOB[i].b!=0)chk[MOB[i].b]=1;\n\t\t}\n\t\tfor(i=1;i<=n;i++){\n\t\t\tif(chk[i]==0)Top=i;\n\t\t}\n\t\tTotal=calc_mass(Top);\n\t\tprintf(\"%lu\\n\",Total);\n\n\t}\n\treturn 0;\n}\n\n\nunsigned long calc_gcd( unsigned long a, unsigned long b){\n\t unsigned long c=1;\n\t unsigned long gcd;\n\n        if(a==0 || b==0)return 0;\n        if(a==1 || b==1)return 1;\n\n        if(a<b){\n            c=a,a=b,b=c;\n        }\n\n        gcd=1;\n\t\n\twhile(a%b!=0){\n\t\tc=b;\n\t\tb=a%b;\n\t\ta=c;\n\t}\n\tgcd=b;\n\n\treturn gcd;\n\n}\n\n\n\nunsigned long calc_mass(unsigned long trgt){\n\tunsigned long gcd;\n\tunsigned long left,right;\n\tunsigned long left2,right2;\n\tunsigned long ratio;\n\n//\tif(MOB[trgt].r==0 && MOB[trgt].b==0){\n//\t\tgcd=calc_gcd(MOB[trgt].p,MOB[trgt].q);\n//\t\tMOB[trgt].left=MOB[trgt].q/gcd;\n//\t\tMOB[trgt].right=MOB[trgt].p/gcd;\n//\t\treturn MOB[trgt].left+MOB[trgt].right;\n//\t}\n\t\n\tif(MOB[trgt].left==0){\n\t\tif(MOB[trgt].r==0)left=1;\n\t\tif(MOB[trgt].r!=0)left=calc_mass(MOB[trgt].r);\n\t}\n\tif(MOB[trgt].right==0){\n\t\tif(MOB[trgt].b==0)right=1;\n\t\tif(MOB[trgt].b!=0)right=calc_mass(MOB[trgt].b);\n\t}\n\t\n\n\n\tgcd=calc_gcd(right,left);\n\tleft2=left/gcd,right2=right/gcd;\n\tgcd=calc_gcd(left2*MOB[trgt].q,right2*MOB[trgt].p);\n\tratio=(right2*MOB[trgt].p)/gcd;\n\tMOB[trgt].left=left*ratio;\n\t\n\tratio=(left2*MOB[trgt].q)/gcd;\n\tMOB[trgt].right=right*ratio;\n\t\n\treturn MOB[trgt].left+MOB[trgt].right;\n\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\ntypedef struct _node{\n\tunsigned int p;\n\tunsigned int q;\n\tunsigned int r;\n\tunsigned int b;\n\tunsigned int left;\t//p-side mass\n\tunsigned int right;\t//q-side mass\n} Node;\nunsigned int calc_mass(unsigned int trgt);\nunsigned int calc_gcd( unsigned int a, unsigned int b);\nNode MOB[101];\n\nunsigned int main(){\n\n\tunsigned int n;\n\tunsigned int chk[101];\n\tunsigned int i;\n\tunsigned int p;\n\tunsigned int q;\n\tunsigned int r;\n\tunsigned int b;\n\tunsigned int Top;\n\tunsigned int Total;\n\tunsigned int gcd;\n\n\twhile(1){\n\t\tscanf(\"%u\\n\",&n);\n\t\tif(n==0)break;\n\n\t\tfor(i=1;i<=n;i++){\n\t\t\tscanf(\"%u %u %u %u\\n\",&p,&q,&r,&b);\n\t\t\tgcd=calc_gcd(p,q);\n\t\t\tMOB[i].p=p/gcd;\n\t\t\tMOB[i].q=q/gcd;\n\t\t\tMOB[i].r=r;\n\t\t\tMOB[i].b=b;\n\t\t\tMOB[i].left=0;\n\t\t\tMOB[i].right=0;\n\t\t\t\n\t\t}\n\t\t\n\t\t// search TOP;\n\t\tfor(i=1;i<=n;i++)chk[i]=0;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tif(MOB[i].r!=0)chk[MOB[i].r]=1;\n\t\t\tif(MOB[i].b!=0)chk[MOB[i].b]=1;\n\t\t}\n\t\tfor(i=1;i<=n;i++){\n\t\t\tif(chk[i]==0)Top=i;\n\t\t}\n\t\tTotal=calc_mass(Top);\n\t\tprintf(\"%u\\n\",Total);\n\n\t}\n\treturn 0;\n}\n\n\nunsigned int calc_gcd( unsigned int a, unsigned int b){\n\t unsigned int c=1;\n\t unsigned int gcd;\n\n        if(a==0 || b==0)return 0;\n        if(a==1 || b==1)return 1;\n\n        if(a<b){\n            c=a,a=b,b=c;\n        }\n\n        gcd=1;\n\t\n\twhile(a%b!=0){\n\t\tc=b;\n\t\tb=a%b;\n\t\ta=c;\n\t}\n\tgcd=b;\n\n\treturn gcd;\n\n}\n\n\n\nunsigned int calc_mass(unsigned int trgt){\n\tunsigned int gcd;\n\tunsigned int left,right;\n\tunsigned int ratio;\n\n\tif(MOB[trgt].r==0 && MOB[trgt].b==0){\n\t\tgcd=calc_gcd(MOB[trgt].p,MOB[trgt].q);\n\t\tMOB[trgt].left=MOB[trgt].q/gcd;\n\t\tMOB[trgt].right=MOB[trgt].p/gcd;\n\t\treturn MOB[trgt].left+MOB[trgt].right;\n\t}\n\t\n\tif(MOB[trgt].left==0){\n\t\tif(MOB[trgt].r==0)left=1;\n\t\tif(MOB[trgt].r!=0)left=calc_mass(MOB[trgt].r);\n\t}\n\tif(MOB[trgt].right==0){\n\t\tif(MOB[trgt].b==0)right=1;\n\t\tif(MOB[trgt].b!=0)right=calc_mass(MOB[trgt].b);\n\t}\n\t\n\tgcd=calc_gcd(left*MOB[trgt].q,right*MOB[trgt].p);\n\tratio=(right*MOB[trgt].p)/gcd;\n\tMOB[trgt].left=left*ratio;\n\t\n\tratio=(left*MOB[trgt].q)/gcd;\n\tMOB[trgt].right=right*ratio;\n\t\n\treturn MOB[trgt].left+MOB[trgt].right;\n\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\ntypedef __int64 ll;\n\ntypedef struct {\n    int ldata, rdata;\n    int left, right;\n    int parent;\n} BINARY;\n\nBINARY tree[101];\n\nint gcd(int a, int b)\n{\n    if (a < b){\n        a ^= b;\n        b ^= a;\n        a ^= b;\n    }\n    return (b == 0 ? a : gcd(b, a % b));\n}\n\nint lcm(int a, int b)\n{\n    return ((a / gcd(a, b)) * b);\n}\n\nint postorder(int root)\n{\n    int l, r, x, y;\n    int cd;\n    \n    if (tree[root].left){\n        l = postorder(tree[root].left);\n    }\n    else {\n        l = 1;\n    }\n    \n    if (tree[root].right){\n        r = postorder(tree[root].right);\n    }\n    else {\n        r = 1;\n    }\n    \n    if (tree[root].right + tree[root].left == 0){\n        cd = gcd(tree[root].ldata, tree[root].rdata);\n        return (tree[root].ldata / cd + tree[root].rdata / cd);\n    }\n    \n    l *= tree[root].ldata;\n    r *= tree[root].rdata;\n    cd = gcd(l, r);\n    x = r / cd;\n    y = l / cd;\n    l *= x;\n    r *= y;\n    return (l / tree[root].ldata + r / tree[root].rdata);\n}\n\nint main(void)\n{\n    int i;\n    int n;\n    int p, q, r, b;\n    int root;\n    \n    while (1){\n        \n        scanf(\"%d\", &n);\n        \n        if (n == 0){\n            break;\n        }\n        \n        memset(tree, 0, sizeof(tree));\n        for (i = 1; i <= n; i++){\n            scanf(\"%d%d%d%d\", &p, &q, &r, &b);\n            tree[i].ldata = p;\n            tree[i].rdata = q;\n            tree[i].left = r;\n            tree[i].right = b;\n            tree[r].parent = tree[b].parent = i;\n        }\n        \n        for (i = 1; i <= n; i++){\n            if (tree[i].parent == 0){\n                root = i;\n            }\n            \n        }\n        printf(\"%d\\n\", postorder(root));\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nstruct x{int p,q,r,b;}B[105];\nint N,i,j,h[105],r,t;\n\nint gcd(int a,int b)\n{\n\tint c;\n\tfor(;b!=0;)\n\t{\n\t\tc=a%b;a=b;b=c;\n\t}\n\treturn a;\n}\n\nint LCM(int x,int y)\n{\n\tint i;\n\tfor(i=1;i<=y;i++)\n\t{\n\t\tif((x*i)%y==0)\n\t\t\treturn x*i;\n\t}\n\treturn x*y;\n}\n\nint dfs(int p)\n{\n\tint r,b,g;\n\tif(p==-1)return 1;\n\tif(h[p]>=0)return h[p];\n\tr=dfs(B[p].r);\n\tb=dfs(B[p].b);\n\tg=LCM(r,b);\n\treturn h[p]=g*(B[p].p+B[p].q);\n}\n\nint main()\n{\n\tfor(;scanf(\"%d\",&N),N;)\n\t{\n\t\tmemset(h,-1,sizeof(h));\n\t\tfor(i=0;i<N;i++)\n\t\t{\n\t\t\tscanf(\"%d%d%d%d\",&B[i].p,&B[i].q,&B[i].r,&B[i].b);\n\t\t\tt=gcd(B[i].p,B[i].q);\n\t\t\tB[i].p/=t;B[i].q/=t;\n\t\t\tB[i].r--;B[i].b--;\n\t\t}\n\t\tfor(i=r=0;i<N;i++)\n\t\t{\n\t\t\tt=dfs(i);\n\t\t\tr=r>t?r:t;\n\t\t}\n\t\tprintf(\"%d\\n\",r);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n\nint mob[101][4];\n\nint gcd(int x, int y){\n  if(x == 0)return y;\n  else return gcd(y % x, x);\n}\n\nint lcf(int x, int y){\n  return (x * y) / gcd(x, y);\n}\n\nint dfs(int x){\n  if(x == 0)return 1;\n  int r = mob[x][0] * dfs(mob[x][2]);\n  int b = mob[x][1] * dfs(mob[x][3]);\n  int m = lcf(r, b);\n  return m / mob[x][0] +  m / mob[x][1];\n  \n}\n\nint main(){\n  while(1){\n    int n, i, notTop[101], top;\n    memset(notTop, 0, sizeof(notTop));\n    memset(mob, 0, sizeof(mob));\n    scanf(\"%d\", &n);\n    if(n == 0)return 0;\n    for(i = 1;i <= n;i++){\n      int p, q, r, b;\n      scanf(\"%d%d%d%d\", &p, &q, &r, &b);\n      notTop[r] = notTop[b] = 1;\n      mob[i][0] = p;\n      mob[i][1] = q;\n      mob[i][2] = r;\n      mob[i][3] = b;\n    }\n    for(i = 1;i <= n;i++){\n      if(notTop[i] == 0){\n\ttop = i;\n\tbreak;\n      }\n    }\n    printf(\"%d\\n\", dfs(top));\n  }\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\ntypedef struct mobile {\n  int ll;\n  int lr;\n  int il;\n  int ir;\n  long long w;\n} mb;\nmb a[101];\nlong long gcd(long long a,long long b)\n{\n  int r = a % b;\n  if (r == 0) return b;\n  return gcd(b,r);\n}\nlong long lcm(long long a,long long b)\n{\n  int g = a > b ? gcd(a,b) : gcd(b,a);\n  return a * b / g;\n}\nlong long weight(int i)\n{\n  mb *p = &a[i];\n  if (i == 0) return 1;\n  if (p->w != 0) return p->w;\n  p->w = (p->ll + p->lr) * lcm(weight(p->il),weight(p->ir));\n  return p->w;\n}\nint main()\n{\n  int n,i,j;\n  long long w,mw;\n  for(;;){\n    scanf(\"%d\",&n);\n    if(n == 0) break;\n    memset(a,0,sizeof(a));\n    for(i=1;i<=n;i++){\n      scanf(\"%d%d%d%d\",&a[i].ll,&a[i].lr,&a[i].il,&a[i].ir);\n      j = a[i].ll > a[i].lr ? gcd(a[i].ll,a[i].lr) : gcd(a[i].lr,a[i].ll);\n      a[i].ll /= j;\n      a[i].lr /= j;\n    }\n    mw = 0;\n    for(i=1;i<=n;i++){\n      w = weight(i);\n      if(mw<w) mw = w;\n    }\n    printf(\"%lld\\n\",mw);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\ntypedef struct _node{\n\tlong long int p;\n\tlong long int q;\n\tint r;\n\tint b;\n\tlong long int left;\t//p-side mass\n\tlong long int right;\t//q-side mass\n} Node;\nlong long int calc_mass(int trgt);\nlong long int calc_gcd( long long int a,long long int b);\nNode MOB[101];\n\nint main(){\n\n\tint n;\n\tint chk[101];\n\tint i;\n\tlong long int p;\n\tlong long int q;\n\tint r;\n\tint b;\n\tint Top;\n\tlong long int Total;\n\tlong long int gcd;\n\n\twhile(1){\n\t\tscanf(\"%d\\n\",&n);\n\t\tif(n==0)break;\n\n\t\tfor(i=1;i<=n;i++){\n\t\t\tscanf(\"%lld %lld %d %d\\n\",&p,&q,&r,&b);\n\t\t\tgcd=calc_gcd(p,q);\n\t\t\tMOB[i].p=p/gcd;\n\t\t\tMOB[i].q=q/gcd;\n\t\t\tMOB[i].r=r;\n\t\t\tMOB[i].b=b;\n\t\t\tMOB[i].left=0;\n\t\t\tMOB[i].right=0;\n\t\t\t\n\t\t}\n\t\t\n\t\t// search TOP;\n\t\tfor(i=1;i<=n;i++)chk[i]=0;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tif(MOB[i].r!=0)chk[MOB[i].r]=1;\n\t\t\tif(MOB[i].b!=0)chk[MOB[i].b]=1;\n\t\t}\n\t\tfor(i=1;i<=n;i++){\n\t\t\tif(chk[i]==0){\n\t\t\t\tTop=i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tTotal=calc_mass(Top);\n\t\tprintf(\"%lld\\n\",Total);\n\n\t}\n\treturn 0;\n}\n\n\nlong long int calc_gcd( long long int a, long long int b){\n\tlong long int c=1;\n\tlong long int gcd;\n\n//\tif(a==0 || b==0)return 0;\n//\tif(a==1 || b==1)return 1;\n\n//\tif(a<b){\n//\t\tc=a,a=b,b=c;\n//\t}\n\n        gcd=1;\n\tif(b==0)return a;\n\twhile(a%b!=0){\n\t\tc=b;\n\t\tb=a%b;\n\t\ta=c;\n\t}\n\tgcd=b;\n\n\treturn gcd;\n\n}\n\n\n\nlong long int calc_mass(int trgt){\n\tlong long int gcd;\n\tlong long int left,right;\n\n\tif(MOB[trgt].r==0 && MOB[trgt].b==0){\n\t\tgcd=calc_gcd(MOB[trgt].p,MOB[trgt].q);\n\t\tMOB[trgt].left=MOB[trgt].q/gcd;\n\t\tMOB[trgt].right=MOB[trgt].p/gcd;\n\t\treturn MOB[trgt].left+MOB[trgt].right;\n\t}\n\t\n//\tif(MOB[trgt].left==0){\n\t\tif(MOB[trgt].r==0)left=1;\n\t\tif(MOB[trgt].r!=0)left=calc_mass(MOB[trgt].r);\n//\t}\n//\tif(MOB[trgt].right==0){\n\t\tif(MOB[trgt].b==0)right=1;\n\t\tif(MOB[trgt].b!=0)right=calc_mass(MOB[trgt].b);\n//\t}\n\t\n\tgcd=calc_gcd(left*MOB[trgt].q,right*MOB[trgt].p);\n\tMOB[trgt].left=left*right*MOB[trgt].p/gcd;\n\tMOB[trgt].right=right*left*MOB[trgt].q/gcd;\n\treturn MOB[trgt].left+MOB[trgt].right;\n\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\ntypedef struct {\n\tlong long p,q,r,b;\n} mobile;\n\nmobile bar[100];\n\nlong long kbs(long long a, long long b){\n\tif(a<b) return kbs(b,a);\n\t\tif(b<=0) return a;\n\t\treturn kbs(b,a%b);\n}\n\nlong long weight(int i){\n\tif(i==0) return 1;\n\tlong long j,a,b;\n\ta=bar[i-1].q*weight(bar[i-1].b);\n\tb=bar[i-1].p*weight(bar[i-1].r);\n\tj=kbs(a,b);\n\tj=a/j*b;\n\treturn j/bar[i-1].p+j/bar[i-1].q;\n}\n\nint main(){\n\tint n,i,f,current;\n\tlong long heavy,max;\n\tscanf(\"%d\",&n);\n\twhile(n!=0){\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%lld %lld %lld %lld\",&bar[i].p,&bar[i].q,&bar[i].r,&bar[i].b);\n\t\t}\n\t\tf=1;\n\t\tcurrent=1;\n\t\twhile(f){\n\t\t\tfor(i=0;i<n;i++){\n\t\t\t\tif(bar[i].r==current || bar[i].b==current){\n\t\t\t\t\tcurrent=i+1;\n\t\t\t\t\tf=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\",weight(current));\n\t\tscanf(\"%d\",&n);\n\t}\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A0520\nLightest Mobile\n*/\n#include <stdio.h>\n\n\nstruct MOB\n{\n  int leftlen   ;int rightlen;\n  int leftnode  ;int rightnode;\n} ;\nstruct MOB mobiles[100];\nint prime[10]={2,3,5,7,11,13,17,19,23,29};\nlong int gcd(long int x,long int y)\n{ long int w,r;\n  int i,pr;\n  for(i=0;i<10;i++)\n    {\n      pr=prime[i];\n      if(x % pr == 0 && y % pr == 0)\n\treturn(pr*gcd(x/pr,y/pr));\n    }\n  if(x < y)\n    {\n      w = x;\n      x = y;\n      y=  w;\n    }\n  if((r = x % y) ==0)\n    return(y);\n  return(gcd (y, r));\n}\n\nlong int lcm(long int x,long int y)\n{\n  return(x/gcd(x,y)*y);\n}\n\nlong int calc_total_weight1(int leftlen, int rightlen,long int leftweight , long int rightweight)\n{\n  long int l;\n\n  l=lcm((leftlen *rightweight),(rightlen * leftweight));\n  return(l/leftlen+l/rightlen);\n}\n\nlong int calc_total_weight(struct MOB *m,int node_no)\n{ long int w1,w2,tw;\n  struct MOB * bar;\n  bar = m + (node_no - 1);\n\n\n  if(bar -> leftnode != 0)\n    w1 = calc_total_weight(m,(bar->leftnode));\n  else\n    w1 = 1;\n  if(bar -> rightnode != 0)\n    w2 = calc_total_weight(m,(bar->rightnode));\n  else\n    w2 = 1;\n\n  tw = calc_total_weight1(bar->leftlen,bar->rightlen,w1,w2);\n\n  return(tw);\n    \n}\n\nint search_root(struct MOB * m,int siz)\n{\n  int i,j;\n  for(i=1;i<=siz;i++)\n    {  for(j=0;j<siz;j++)\n      {\n        if(m[j].leftnode == i ||m[j].rightnode == i)\n          goto AAA;\n      }\n      return(i);\n    AAA:\n      ;\n    }\n   return(-1);\n\n}\n\n\nmain()\n{\nint i;\nlong int total_weight;\nint  root;\nint  cnt;\n  \n  while(EOF != scanf(\"%d\",&cnt) && cnt)\n    {     \n      for(i=0;i<cnt;i++)\n         scanf(\" %d %d %d %d\",\n               &(mobiles[i].leftlen),\n               &(mobiles[i].rightlen),\n               &(mobiles[i].leftnode),\n               &(mobiles[i].rightnode));\n    \n  \n  root = search_root(mobiles,cnt);    \n  total_weight = calc_total_weight(mobiles,root);\n\n  printf(\"%ld\\n\",total_weight);\n    }\nreturn(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define N 100\n#define MAX(A,B) \\\n  ( (B) > (A) ? (B) : (A) )\n\nstatic struct\n{\n  int a, b;\n  int p, q;\n} d[ N + 1 ];\nstatic int dp[ N + 1 ];\nstatic int n;\n\nstatic int\ngcd (\n  const int a,\n  const int b\n  )\n{\n  if ( a == 0 )\n    return ( b );\n\n  return\n  gcd ( b % a, a );\n}\n\nstatic int\nlcm (\n  const int a,\n  const int b\n  )\n{\n  return ( a * b / gcd ( a, b ) );\n}\n\nstatic int\ndfs (\n  const int p\n  )\n{\n  if ( p == 0 )\n    return ( 1 );\n\n  if ( ~dp[ p ] ) ;\n  else dp[ p ] = d[ p ].a * lcm ( dfs ( d[ p ].p ), dfs ( d[ p ].q ) )\n               + d[ p ].b * lcm ( dfs ( d[ p ].p ), dfs ( d[ p ].q ) );\n\n  return ( dp[ p ] );\n}\n\nint\nmain (\n  int   argc,\n  char *argv[ ]\n  )\n{\n  int i;\n\n  for ( ; ; )\n  {\n    int res = 0;\n\n    scanf ( \"%d\", &n );\n    if ( n == 0 ) break ;\n    for ( i = 1; i <= n; ++i )\n    {\n      int cd;\n\n      scanf ( \"%d%d%d%d\", &d[ i ].a, &d[ i ].b\n                        , &d[ i ].p, &d[ i ].q );\n      cd = gcd ( d[ i ].a, d[ i ].b );\n      d[ i ].a /= cd; d[ i ].b /= cd;\n    }\n\n    for ( i = 1; i <= n; ++i )\n    {\n      memset ( dp, -1, sizeof ( dp ) );\n      res = MAX( res, dfs ( i ) );\n    }\n    printf ( \"%d\\n\", res );\n  }\n\n  return ( EXIT_SUCCESS );\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\ntypedef long long ll;\ntypedef struct {\n    int ldata, rdata;\n    int left, right;\n    int parent;\n    int weight;\n} BINARY;\n\nBINARY tree[101];\n\nll gcd(ll a, ll b)\n{\n    if (a < b){\n        a ^= b;\n        b ^= a;\n        a ^= b;\n    }\n    return (b == 0 ? a : gcd(b, a % b));\n}\n\nint postOrder(int root)\n{\n    ll l, r, x;\n    ll cd;\n    \n    if (tree[root].left){\n        l = postOrder(tree[root].left);\n    }\n    else {\n        l = 1;\n    }\n    \n    if (tree[root].right){\n        r = postOrder(tree[root].right);\n    }\n    else {\n        r = 1;\n    }\n    \n    if (tree[root].right + tree[root].left == 0){\n        cd = gcd(tree[root].ldata, tree[root].rdata);\n        return (tree[root].ldata / cd + tree[root].rdata / cd);\n    }\n    \n    l *= tree[root].ldata;\n    r *= tree[root].rdata;\n    cd = gcd(l, r);\n    x = l / cd * r;\n    return (x / tree[root].ldata + x / tree[root].rdata);\n}\n\nint main(void)\n{\n    int i;\n    int n;\n    int p, q, r, b;\n    int root;\n    \n    while (1){\n        \n        scanf(\"%d\", &n);\n        \n        if (n == 0){\n            break;\n        }\n        \n        memset(tree, 0, sizeof(tree));\n        for (i = 1; i <= n; i++){\n            scanf(\"%d%d%d%d\", &p, &q, &r, &b);\n            tree[i].ldata = p;\n            tree[i].rdata = q;\n            tree[i].left = r;\n            tree[i].right = b;\n            tree[r].parent = tree[b].parent = i;\n        }\n        \n        for (i = 1; i <= n; i++){\n            tree[i].weight = 0;\n            if (tree[i].parent == 0){\n                root = i;\n            }\n            \n        }\n        printf(\"%d\\n\", postOrder(root));\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nstruct x{int p,q,r,b;}B[105];\nint N,i,j,h[105],r,t;\n\nint gcd(int a,int b)\n{\n\tint c;\n\tfor(;b!=0;)\n\t{\n\t\tc=a%b;a=b;b=c;\n\t}\n\treturn a;\n}\n\nint dfs(int p)\n{\n\tint r,b,g,i,j,ta,tb,m;\n\tif(p==-1)return 1;\n\tif(h[p]>=0)return h[p];\n\tr=dfs(B[p].r);\n\tb=dfs(B[p].b);\n\tg=r*b/gcd(r,b);\n\tfor(i=1;i<=1000;i++)\n\t\tfor(j=1;j<=1000;j++)\n\t\t{\n\t\t\tta=r*i;\n\t\t\ttb=b*j;\n\t\t\tm=gcd(ta,tb);\n\t\t\tif(ta/m==B[p].p&&tb/m==B[p].q)\n\t\t\t\tgoto e;\n\t\t\t\n\t\t}\ne:\n\treturn h[p]=r*i+b*j;\n}\n\nint main()\n{\n\tfor(;scanf(\"%d\",&N),N;)\n\t{\n\t\tmemset(h,-1,sizeof(h));\n\t\tfor(i=0;i<N;i++)\n\t\t{\n\t\t\tscanf(\"%d%d%d%d\",&B[i].p,&B[i].q,&B[i].r,&B[i].b);\n\t\t\tt=gcd(B[i].p,B[i].q);\n\t\t\tB[i].p/=t;B[i].q/=t;\n\t\t\tB[i].r--;B[i].b--;\n\t\t}\n\t\tfor(i=r=0;i<N;i++)\n\t\t{\n\t\t\tt=dfs(i);\n\t\t\tr=r>t?r:t;\n\t\t}\n\t\tprintf(\"%d\\n\",r);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\ntypedef struct _node{\n\tlong long int p;\n\tlong long int q;\n\tlong long int r;\n\tlong long int b;\n\tlong long int left;\t//p-side mass\n\tlong long int right;\t//q-side mass\n} Node;\nlong long int calc_mass(int trgt);\nlong long int calc_gcd( long long int a, long long int b);\nNode MOB[102];\nlong long int memo[102];\n\nint main(){\n\n\tint n;\n\tlong long int chk[102];\n\tint i;\n\tlong long int p;\n\tlong long int q;\n\tlong long int r;\n\tlong long int b;\n\tint Top;\n\tlong long int Total;\n\tlong long int gcd;\n\t\n\tfor(i=0;i<102;i++)memo[i]=0;\n\t\n\twhile(1){\n\t\tscanf(\"%d\\n\",&n);\n\t\tif(n==0)break;\n\n\t\tfor(i=1;i<=n;i++){\n\t\t\tscanf(\"%lld %lld %lld %lld\\n\",&p,&q,&r,&b);\n\t\t\tgcd=calc_gcd(p,q);\n\t\t\tMOB[i].p=p/gcd;\n\t\t\tMOB[i].q=q/gcd;\n\t\t\tMOB[i].r=r;\n\t\t\tMOB[i].b=b;\n\t\t\tMOB[i].left=0;\n\t\t\tMOB[i].right=0;\n\t\t\t\n\t\t}\n\t\t\n\t\t// search TOP;\n\t\tfor(i=1;i<=n;i++)chk[i]=0;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tif(MOB[i].r!=0)chk[MOB[i].r]=1;\n\t\t\tif(MOB[i].b!=0)chk[MOB[i].b]=1;\n\t\t}\n\t\tfor(i=1;i<=n;i++){\n\t\t\tif(chk[i]==0)Top=i;\n\t\t}\n\t\tTotal=calc_mass(Top);\n\t\tprintf(\"%lld\\n\",Total);\n\n\t}\n\treturn 0;\n}\n\n\nlong long int calc_gcd( long long int a, long long int b){\n\t long long int c=1;\n\t long long int gcd;\n\n//\tif(a==0 || b==0)return 0;\n//\tif(a==1 || b==1)return 1;\n\n//\tif(a<b){\n//\t\tc=a,a=b,b=c;\n//\t}\n\n        gcd=1;\n\t\n\twhile(a%b!=0){\n\t\tc=b;\n\t\tb=a%b;\n\t\ta=c;\n\t}\n\tgcd=b;\n\n\treturn gcd;\n\n}\n\n\n\nlong long int calc_mass(int trgt){\n//printf(\"trgt=%d\\n\",trgt);\n\tlong long int gcd;\n\tlong long int left,right;\n\tlong long int left2,right2;\n\tlong long int ratio;\n\tif(memo[trgt]!=0)return memo[trgt];\n//\tif(MOB[trgt].r==0 && MOB[trgt].b==0){\n//\t\tgcd=calc_gcd(MOB[trgt].p,MOB[trgt].q);\n//\t\tMOB[trgt].left=MOB[trgt].q/gcd;\n//\t\tMOB[trgt].right=MOB[trgt].p/gcd;\n//\t\treturn MOB[trgt].left+MOB[trgt].right;\n//\t}\n\t\n\tif(MOB[trgt].left==0){\n\t\tif(MOB[trgt].r==0)left=1;\n\t\tif(MOB[trgt].r!=0)left=calc_mass(MOB[trgt].r);\n\t}\n\tif(MOB[trgt].right==0){\n\t\tif(MOB[trgt].b==0)right=1;\n\t\tif(MOB[trgt].b!=0)right=calc_mass(MOB[trgt].b);\n\t}\n\t\n\n\n\tgcd=calc_gcd(right,left);\n\tleft2=left/gcd,right2=right/gcd;\n\tgcd=calc_gcd(left2*MOB[trgt].q,right2*MOB[trgt].p);\n\tratio=(right2*MOB[trgt].p)/gcd;\n\tMOB[trgt].left=left*ratio;\n\t\n\tratio=(left2*MOB[trgt].q)/gcd;\n\tMOB[trgt].right=right*ratio;\n\t\n\tmemo[trgt]=MOB[trgt].left+MOB[trgt].right;\n\treturn memo[trgt];\n\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nstruct x{int p,q,r,b;}B[105];\nint N,i,j,t,h[105],c,r,g;\n\nint gcd(int a,int b)\n{\n\tint c;\n\tfor(;b!=0;)\n\t{\n\t\tc=a%b;a=b;b=c;\n\t}\n\treturn a;\n}\n\nint LCM(int x,int y)\n{\n\tint i;\n\tfor(i=1;i<=y;i++)\n\t{\n\t\tif((x*i)%y==0)\n\t\t\treturn x*i;\n\t}\n\treturn x*y;\n}\n\nint wg(int b)\n{\n\tif(b==-1)return 1;\n\treturn h[b];\n}\n\nint main()\n{\n\tfor(;scanf(\"%d\",&N),N;)\n\t{\n\t\tmemset(h,-1,sizeof(h));\n\t\tfor(i=0;i<N;i++)\n\t\t{\n\t\t\tscanf(\"%d%d%d%d\",&B[i].p,&B[i].q,&B[i].r,&B[i].b);\n\t\t\tt=gcd(B[i].p,B[i].q);\n\t\t\tB[i].p/=t;B[i].q/=t;\n\t\t\tB[i].r--;B[i].b--;\n\t\t}\n\t\tfor(c=N;c>0;)\n\t\t\tfor(j=0;j<N;j++)\n\t\t\t{\n\t\t\t\tif(h[j]==-1&&wg(B[j].r)>=0&&wg(B[j].b)>=0)\n\t\t\t\t{\n\t\t\t\t\tg=LCM(wg(B[j].r),wg(B[j].b));\n\t\t\t\t\th[j]=g*(B[j].p+B[j].q);\n\t\t\t\t\tc--;\n\t\t\t\t}\n\t\t\t\tif(!c)break;\n\t\t\t}\n\t\tfor(i=r=0;i<N;i++)\n\t\t\tr=r<h[i]?h[i]:r;\n\t\tprintf(\"%d\\n\",r);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\ntypedef struct bar{\n\tint p,q,r,b,w;\n}BAR;\nBAR a[105];\nint gcm(int x,int y){\n\tif(x%y==0)return y;\n\treturn gcm(y,x%y);\n}\nint lcm(int x,int y){\n\treturn x*y/gcm(x,y);\n}\nint func(int x){\n\tif(a[x].w!=0)return a[x].w;\n\tint aa,b,c,d;\n\taa=gcm( a[x].p , a[x].q );\n\tb=lcm( func(a[x].r) , func(a[x].b) );\n\tc=b*a[x].q/aa;\n\td=b*a[x].p/aa;\n\ta[x].w=c+d;\n\treturn a[x].w;\n}\nint main(){\n\tint i,j,n,ans;\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\ta[0].w=1;\n\t\tfor(i=1;i<=n;i++){\n\t\t\ta[i].w=0;\n\t\t\tscanf(\"%d%d%d%d\",&a[i].p,&a[i].q,&a[i].r,&a[i].b);\n\t\t\tif(a[i].r==0 && a[i].b==0){\n\t\t\t\ta[i].w=(a[i].p+a[i].q)/gcm(a[i].p,a[i].q);\n\t\t\t}\n\t\t}\n\t\tans=0;\n\t\tfor(i=1;i<=n;i++){\n\t\t\t//printf(\"%d\\n\",func(i));\n\t\t\tfunc(i);\n\t\t\tif(a[i].w>ans)ans=a[i].w;\n\t\t}\n\t\t//scanf(\"%d%d\",&i,&j);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#define Max(x,y) ((x>y)?x:y)\nint a[105],b[105],c[105],d[105],w[105];\nint gcm(int x,int y){\n\tif(x%y==0)return y;\n\treturn gcm(y,x%y);\n}\nint func(int n){\n\tif(w[n]>0)return w[n];\n\tint x=gcm(func(c[n])*a[n],func(d[n])*b[n]);\n\tw[n]=func(c[n])*func(d[n])*(a[n]+b[n])/x;\n\treturn w[n];\n}\nint main(){\n\tint i,j,n,ans=0;\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tmemset(w,-1,sizeof(w));\n\t\tw[0]=1;\n\t\tfor(i=1;i<=n;i++)\n\t\t\tscanf(\"%d%d%d%d\",&a[i],&b[i],&c[i],&d[i]);\n\t\tans=0;\n\t\tfor(i=1;i<=n;i++)ans=Max(ans,func(i));\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A0520\nLightest Mobile\n*/\n#include <stdio.h>\n\n\nstruct MOB\n{\n  int leftlen   ;int rightlen;\n  int leftnode  ;int rightnode;\n} ;\nstruct MOB mobiles[100];\nint prime[10]={2,3,5,7,11,13,17,19,23,29};\nlong int gcd(long int x,long int y)\n{ long int w,r;\n  int i,pr;\n  for(i=0;i<10;i++)\n    {\n      pr=prime[i];\n      if(x % pr == 0 && y % pr == 0)\n\treturn(pr*gcd(x/pr,y/pr));\n    }\n  if(x < y)\n    {\n      w = x;\n      x = y;\n      y=  w;\n    }\n  if((r = x % y) ==0)\n    return(y);\n  return(gcd (y, r));\n}\n\nlong int lcm(long int x,long int y)\n{\n  return(x/gcd(x,y)*y);1\n}\n\nlong int calc_total_weight1(int leftlen, int rightlen,long int leftweight , long int rightweight)\n{\n  long int l;\n  // printf(\"%d %d %ld %ld\\n\",leftlen,rightlen,leftweight,rightweight);\n  l=lcm((leftlen *rightweight),(rightlen * leftweight));\n  return(l/leftlen+l/rightlen);\n}\n\nlong int calc_total_weight(struct MOB *m,int node_no)\n{ long int w1,w2,tw;\n  struct MOB * bar;\n  bar = m + (node_no - 1);\n\n\n  if(bar -> leftnode != 0)\n    w1 = calc_total_weight(m,(bar->leftnode));\n  else\n    w1 = 1;\n  if(bar -> rightnode != 0)\n    w2 = calc_total_weight(m,(bar->rightnode));\n  else\n    w2 = 1;\n\n  tw = calc_total_weight1(bar->leftlen,bar->rightlen,w1,w2);\n\n  return(tw);\n    \n}\n\nint search_root(struct MOB * m,int siz)\n{\n  int i,j;\n  for(i=1;i<=siz;i++)\n    {  for(j=0;j<siz;j++)\n      {\n        if(m[j].leftnode == i ||m[j].rightnode == i)\n          goto AAA;\n      }\n      return(i);\n    AAA:\n      ;\n    }\n   return(-1);\n\n}\n\n\nmain()\n{\nint i;\nlong int total_weight;\nint  root;\nint  cnt;\n  \n  while(EOF != scanf(\"%d\",&cnt) && cnt)\n    {     \n      for(i=0;i<cnt;i++)\n         scanf(\" %d %d %d %d\",\n               &(mobiles[i].leftlen),\n               &(mobiles[i].rightlen),\n               &(mobiles[i].leftnode),\n               &(mobiles[i].rightnode));\n    \n  \n  root = search_root(mobiles,cnt);    \n  total_weight = calc_total_weight(mobiles,root);\n\n  printf(\"%ld\\n\",total_weight);\n    }\nreturn(0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<climits>\n#define min(a,b) (a<b?a:b)\nstruct x{int p,q,r,b;}B[105];\nint N,i,j,h[105],r,t;\n\nint gcd(int a,int b)\n{\n\tint c;\n\tfor(;b!=0;)\n\t{\n\t\tc=a%b;a=b;b=c;\n\t}\n\treturn a;\n}\n\nint dfs(int p)\n{\n\tint r,b,i,j,ta,tb,ri,rj,t1,t2;\n\tif(p==-1)return 1;\n\tif(h[p]>=0)return h[p];\n\tr=dfs(B[p].r);\n\tb=dfs(B[p].b);\n\tt1=10000000/(r*B[p].p),t2=10000000/(b*B[p].q);\n\ti=j=-1;\n\tri=t1;\n\trj=t2;\n\tfor(i=1;i<=min(t1,t2);i++)\n\t{\n\t\tif((r*i*B[p].p)%(b*B[p].q))continue;\n\t\tj=(r*i*B[p].p)/(b*B[p].q);\n\t\tta=r*i/B[p].q;\n\t\ttb=b*j/B[p].p;\n\t\tif(ta&&tb&&ta==tb)\n\t\t{\n\t\t\tif(ri*r+rj*b>i*r+j*b)\n\t\t\t{\n\t\t\t\tri=i;\n\t\t\t\trj=j;\n\t\t\t}\n\t\t}\n\t}\n\tif(j==-1)ri=rj=(r*b)/gcd(r,b);\n\t//printf(\"%d %d:%d %d:%d %d:%d\\n\",p,r,b,B[p].p,B[p].q,r*ri,b*rj);\n\treturn h[p]=r*ri+b*rj;\n}\n\nint main()\n{\n\tfor(;scanf(\"%d\",&N),N;)\n\t{\n\t\tmemset(h,-1,sizeof(h));\n\t\tfor(i=0;i<N;i++)\n\t\t{\n\t\t\tscanf(\"%d%d%d%d\",&B[i].p,&B[i].q,&B[i].r,&B[i].b);\n\t\t\tt=gcd(B[i].p,B[i].q);\n\t\t\tB[i].p/=t;B[i].q/=t;\n\t\t\tB[i].r--;B[i].b--;\n\t\t}\n\t\tfor(i=r=0;i<N;i++)\n\t\t{\n\t\t\tt=dfs(i);\n\t\t\tr=r>t?r:t;\n\t\t}\n\t\tprintf(\"%d\\n\",r);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define N 100\n#define MAX(A,B) \\\n  ( (B) > (A) ? (B) : (A) )\n\nstatic struct\n{\n  int a, b;\n  int p, q;\n} d[ N + 1 ];\nstatic int dp[ N + 1 ];\nstatic int n;\n\nstatic int\ngcd (\n  const int a,\n  const int b\n  )\n{\n  if ( a == 0 )\n    return ( b );\n\n  return\n  gcd ( b % a, a );\n}\n\nstatic int\nlcm (\n  const int a,\n  const int b\n  )\n{\n  return ( a / gcd ( a, b ) * b );\n}\n\nstatic int\ndfs (\n  const int p\n  )\n{\n  if ( p == 0 )\n    return ( 1 );\n\n  if ( ~dp[ p ] ) ;\n  else dp[ p ] = d[ p ].a * lcm ( dfs ( d[ p ].p ), dfs ( d[ p ].q ) )\n               + d[ p ].b * lcm ( dfs ( d[ p ].p ), dfs ( d[ p ].q ) );\n\n  return ( dp[ p ] );\n}\n\nint\nmain (\n  int   argc,\n  char *argv[ ]\n  )\n{\n  int i;\n\n  for ( ; ; )\n  {\n    int res = 0;\n\n    scanf ( \"%d\", &n );\n    if ( n == 0 ) break ;\n    for ( i = 1; i <= n; ++i )\n    {\n      int cd;\n\n      scanf ( \"%d%d%d%d\", &d[ i ].a, &d[ i ].b\n                        , &d[ i ].p, &d[ i ].q );\n      cd = gcd ( d[ i ].a, d[ i ].b );\n      d[ i ].a /= cd; d[ i ].b /= cd;\n    }\n\n    for ( i = 1; i <= n; ++i )\n    {\n      memset ( dp, -1, sizeof ( dp ) );\n      res = MAX( res, dfs ( i ) );\n    }\n    printf ( \"%d\\n\", res );\n  }\n\n  return ( EXIT_SUCCESS );\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<climits>\n#define min(a,b) (a<b?a:b)\nstruct x{int p,q,r,b;}B[105];\nint N,i,j,h[105],r,t;\n\nint gcd(int a,int b)\n{\n\tint c;\n\tfor(;b!=0;)\n\t{\n\t\tc=a%b;a=b;b=c;\n\t}\n\treturn a;\n}\n\nint dfs(int p)\n{\n\tint r,b,i,j,ta,tb,i,rj,t1,t2;\n\tif(p==-1)return 1;\n\tif(h[p]>=0)return h[p];\n\tr=dfs(B[p].r);\n\tb=dfs(B[p].b);\n\tt1=10000000/(r*B[p].p),t2=10000000/(b*B[p].q);\n\ti=j=-1;\n\tri=t1;\n\trj=t2;\n\tfor(i=1;i<=min(t1,t2);i++)\n\t{\n\t\tif((r*i*B[p].p)%(b*B[p].q))continue;\n\t\tj=(r*i*B[p].p)/(b*B[p].q);\n\t\tta=r*i/B[p].q;\n\t\ttb=b*j/B[p].p;\n\t\tif(ta&&tb&&ta==tb)\n\t\t{\n\t\t\tif(ri*r+rj*b>i*r+j*b)\n\t\t\t{\n\t\t\t\tri=i;\n\t\t\t\trj=j;\n\t\t\t}\n\t\t}\n\t}\n\tif(j==-1)ri=rj=(r*b)/gcd(r,b);\n\t//printf(\"%d %d:%d %d:%d %d:%d\\n\",p,r,b,B[p].p,B[p].q,r*ri,b*rj);\n\treturn h[p]=r*ri+b*rj;\n}\n\nint main()\n{\n\tfor(;scanf(\"%d\",&N),N;)\n\t{\n\t\tmemset(h,-1,sizeof(h));\n\t\tfor(i=0;i<N;i++)\n\t\t{\n\t\t\tscanf(\"%d%d%d%d\",&B[i].p,&B[i].q,&B[i].r,&B[i].b);\n\t\t\tt=gcd(B[i].p,B[i].q);\n\t\t\tB[i].p/=t;B[i].q/=t;\n\t\t\tB[i].r--;B[i].b--;\n\t\t}\n\t\tfor(i=r=0;i<N;i++)\n\t\t{\n\t\t\tt=dfs(i);\n\t\t\tr=r>t?r:t;\n\t\t}\n\t\tprintf(\"%d\\n\",r);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A0520\nLightest Mobile\n*/\n#include <stdio.h>\n\n\nstruct MOB\n{\n  int leftlen   ;int rightlen;\n  int leftnode  ;int rightnode;\n} ;\nstruct MOB mobiles[100];\n\nlong int gcd(long int x,long int y)\n{ long int w,r;\n  if(x < y)\n    {\n      w = x;\n      x = y;\n      y=  w;\n    }\n  if((r = x % y) ==0)\n    return(y);\n  return(gcd (y, r));\n}\n\nlong int lcm(long int x,long int y)\n{\n  return(x/gcd(x,y)*y);\n}\n\nlong int calc_total_weight1(int leftlen, int rightlen,long int leftweight , long int rightweight)\n{\n  long int l;\n\n  l=lcm((leftlen *rightweight),(rightlen * leftweight));\n  return(l/leftlen+l/rightlen);\n}\n\nlong int calc_total_weight(struct MOB *m,int node_no)\n{ long int w1,w2,tw;\n  struct MOB * bar;\n  bar = m + (node_no - 1);\n\n\n  if(bar -> leftnode != 0)\n    w1 = calc_total_weight(m,(bar->leftnode));\n  else\n    w1 = 1;\n  if(bar -> rightnode != 0)\n    w2 = calc_total_weight(m,(bar->rightnode));\n  else\n    w2 = 1;\n\n  tw = calc_total_weight1(bar->leftlen,bar->rightlen,w1,w2);\n\n  return(tw);\n    \n}\n\nint search_root(struct MOB * m,int siz)\n{\n  int i,j;\n  for(i=1;i<=siz;i++)\n    {  for(j=0;j<siz;j++)\n      {\n        if(m[j].leftnode == i ||m[j].rightnode == i)\n          goto AAA;\n      }\n      return(i);\n    AAA:\n      ;\n    }\n   return(-1);\n\n}\n\n\nmain()\n{\nint i;\nlong int total_weight;\nint  root;\nint  cnt;\n  \n  while(EOF != scanf(\"%d\",&cnt) && cnt)\n    {     \n      for(i=0;i<cnt;i++)\n         scanf(\" %d %d %d %d\",\n               &(mobiles[i].leftlen),\n               &(mobiles[i].rightlen),\n               &(mobiles[i].leftnode),\n               &(mobiles[i].rightnode));\n    \n  \n  root = search_root(mobiles,cnt);    \n  total_weight = calc_total_weight(mobiles,root);\n\n  printf(\"%ld\\n\",total_weight);\n    }\nreturn(0);\n}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A0520\nLightest Mobile\n*/\n#include <stdio.h>\n\n\nstruct MOB\n{\n  int leftlen   ;int rightlen;\n  int leftnode  ;int rightnode;\n} ;\nstruct MOB mobiles[100];\n/*\nstruct MOB mobiles1[]=   {{1, 2, 0, 0},{1, 2, 0, 0},{1, 2, 1, 2},{1, 2, 3, 0}};\nstruct MOB mobiles2[]=   {{3, 2, 0, 4},{1, 3, 0, 0},{4, 4, 2, 1},{2, 2, 0, 0}};\nstruct MOB mobiles3[]=   {{1, 2, 0, 0},{1, 2, 0, 0},{1, 2, 1, 2},{1, 2, 3, 0},{1,2,4,0}};\n*/\n\nlong int gcd(long int x,long int y)\n{ long int w,r;\n  if(x < y)\n    {\n      w = x;\n      x = y;\n      y=  w;\n    }\n  if((r = x % y) ==0)\n    return(y);\n  return(gcd (y, r));\n}\n\nlong int lcm(long int x,long int y)\n{\n  return(x/gcd(x,y)*y);\n}\n\nlong int calc_total_weight1(int leftlen, int rightlen,long int leftweight , long int rightweight)\n{\n  long int l;\n\n/*Dprintf(\"%d %d %d %d \\n\",leftlen ,rightlen,leftweight , rightweight);*/\n\n  l=lcm((leftlen *rightweight),(rightlen * leftweight));\n  return(l/leftlen+l/rightlen);\n}\n\nlong int calc_total_weight(struct MOB *m,int node_no)\n{ long int w1,w2,tw;\n  struct MOB * bar;\n  bar = m + (node_no - 1);\n\n/*Dprintf(\"%d L=%d R=%d\\n\",node_no,bar->leftnode,bar->rightnode);  */\n  if(bar -> leftnode != 0)\n    w1 = calc_total_weight(m,(bar->leftnode));\n  else\n    w1 = 1;\n  if(bar -> rightnode != 0)\n    w2 = calc_total_weight(m,(bar->rightnode));\n  else\n    w2 = 1;\n\n  tw = calc_total_weight1(bar->leftlen,bar->rightlen,w1,w2);\n/*Dprintf(\"tw=%ld\\n\",tw);*/\n  return(tw);\n    \n}\n\nint search_root(struct MOB * m,int siz)\n{\n  int i,j;\n  for(i=1;i<=siz;i++)\n    {  for(j=0;j<siz;j++)\n      {\n        if(m[j].leftnode == i ||m[j].rightnode == i)\n          goto AAA;\n      }\n      return(i);\n    AAA:\n      ;\n    }\n   return(-1);\n\n}\n\n\nmain()\n{\nint i;\nlong int total_weight;\nint  root;\nint  cnt;\n  \n  while(EOF != scanf(\"%d\",&cnt))\n    {     \n      for(i=0;i<cnt;i++)\n         scanf(\" %d %d %d %d\",\n               &(mobiles[i].leftlen),\n               &(mobiles[i].rightlen),\n               &(mobiles[i].leftnode),\n               &(mobiles[i].rightnode));\n    \n\n/*\n  for(i=0;i<4;i++)\n    {\n         printf(\" %d %d %d %d\\n\",\n               (mobiles[i].leftlen),\n               (mobiles[i].rightlen),\n               (mobiles[i].leftnode),\n               (mobiles[i].rightnode));\n    }\n*/\n  \n  root = search_root(mobiles,cnt);    \n  total_weight = calc_total_weight(mobiles,root);\n\n  printf(\"%ld\\n\",total_weight);\n    }\nreturn(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\ntypedef struct _node{\n\tunsigned int p;\n\tunsigned int q;\n\tunsigned int r;\n\tunsigned int b;\n\tunsigned int left;\t//p-side mass\n\tunsigned int right;\t//q-side mass\n} Node;\nunsigned int calc_mass(unsigned int trgt);\nunsigned int calc_gcd( unsigned int a, unsigned int b);\nNode MOB[101];\n\nunsigned int main(){\n\n\tunsigned int n;\n\tunsigned int chk[101];\n\tunsigned int i;\n\tunsigned int p;\n\tunsigned int q;\n\tunsigned int r;\n\tunsigned int b;\n\tunsigned int Top;\n\tunsigned int Total;\n\tunsigned int gcd;\n\n\twhile(1){\n\t\tscanf(\"%u\\n\",&n);\n\t\tif(n==0)break;\n\n\t\tfor(i=1;i<=n;i++){\n\t\t\tscanf(\"%u %u %u %u\\n\",&p,&q,&r,&b);\n\t\t\tgcd=calc_gcd(p,q);\n\t\t\tMOB[i].p=p/gcd;\n\t\t\tMOB[i].q=q/gcd;\n\t\t\tMOB[i].r=r;\n\t\t\tMOB[i].b=b;\n\t\t\tMOB[i].left=0;\n\t\t\tMOB[i].right=0;\n\t\t\t\n\t\t}\n\t\t\n\t\t// search TOP;\n\t\tfor(i=1;i<=n;i++)chk[i]=0;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tif(MOB[i].r!=0)chk[MOB[i].r]=1;\n\t\t\tif(MOB[i].b!=0)chk[MOB[i].b]=1;\n\t\t}\n\t\tfor(i=1;i<=n;i++){\n\t\t\tif(chk[i]==0)Top=i;\n\t\t}\n\t\tTotal=calc_mass(Top);\n\t\tprintf(\"%u\\n\",Total);\n\n\t}\n\treturn 0;\n}\n\n\nunsigned int calc_gcd( unsigned int a, unsigned int b){\n\t unsigned int c=1;\n\t unsigned int gcd;\n\n        if(a==0 || b==0)return 0;\n        if(a==1 || b==1)return 1;\n\n        if(a<b){\n            c=a,a=b,b=c;\n        }\n\n        gcd=1;\n\t\n\twhile(a%b!=0){\n\t\tc=b;\n\t\tb=a%b;\n\t\ta=c;\n\t}\n\tgcd=b;\n\n\treturn gcd;\n\n}\n\n\n\nunsigned int calc_mass(unsigned int trgt){\n\tunsigned int gcd;\n\tunsigned int left,right;\n\tunsigned int left2,right2;\n\tunsigned int ratio;\n\n\tif(MOB[trgt].r==0 && MOB[trgt].b==0){\n\t\tgcd=calc_gcd(MOB[trgt].p,MOB[trgt].q);\n\t\tMOB[trgt].left=MOB[trgt].q/gcd;\n\t\tMOB[trgt].right=MOB[trgt].p/gcd;\n\t\treturn MOB[trgt].left+MOB[trgt].right;\n\t}\n\t\n\tif(MOB[trgt].left==0){\n\t\tif(MOB[trgt].r==0)left=1;\n\t\tif(MOB[trgt].r!=0)left=calc_mass(MOB[trgt].r);\n\t}\n\tif(MOB[trgt].right==0){\n\t\tif(MOB[trgt].b==0)right=1;\n\t\tif(MOB[trgt].b!=0)right=calc_mass(MOB[trgt].b);\n\t}\n\t\n\n\n\tgcd=calc_gcd(right,left);\n\tleft2=left/gcd,right2=right/gcd;\n\tgcd=calc_gcd(left2*MOB[trgt].q,right2*MOB[trgt].p);\n\tratio=(right2*MOB[trgt].p)/gcd;\n\tMOB[trgt].left=left*ratio;\n\t\n\tratio=(left2*MOB[trgt].q)/gcd;\n\tMOB[trgt].right=right*ratio;\n\t\n\treturn MOB[trgt].left+MOB[trgt].right;\n\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#define Max(x,y) ((x>y)?x:y)\nint a[105],b[105],c[105],d[105],w[105];\n\nint gcd(int x,int y){\n\treturn (y==0)?(x):(gcd(y,x%y));\n}\nint lcm(int x,int y){\n\treturn x/gcd(x,y)*y;\n}\n\nint func(int n){\n\tif(w[n]>0)return w[n];\n\t//int x=gcd(func(c[n])*a[n],func(d[n])*b[n]);\n\t//w[n]=func(c[n])*func(d[n])*(a[n]+b[n])/x;\n\t\n\tint x=lcm(func(c[n])*a[n],func(d[n])*b[n]);\n\t//w[n]=func(c[n])*func(d[n])*a[n]/x+func(c[n])*func(d[n])*b[n]/x;\n\tw[n]=x/a[n]+x/b[n];\n\t\n\treturn w[n];\n}\nint main(){\n\tint i,j,n,ans=0;\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tmemset(w,-1,sizeof(w));\n\t\tw[0]=1;\n\t\tfor(i=1;i<=n;i++)\n\t\t\tscanf(\"%d%d%d%d\",&a[i],&b[i],&c[i],&d[i]);\n\t\tans=0;\n\t\tfor(i=1;i<=n;i++)ans=Max(ans,func(i));\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\ntypedef struct _node{\n\tunsigned int p;\n\tunsigned int q;\n\tunsigned int r;\n\tunsigned int b;\n\tunsigned int left;\t//p-side mass\n\tunsigned int right;\t//q-side mass\n} Node;\nunsigned int calc_mass(unsigned int trgt);\nunsigned int calc_gcd( unsigned int a, unsigned int b);\nNode MOB[101];\n\nint main(){\n\n\tunsigned int n;\n\tunsigned int chk[101];\n\tunsigned int i;\n\tunsigned int p;\n\tunsigned int q;\n\tunsigned int r;\n\tunsigned int b;\n\tunsigned int Top;\n\tunsigned int Total;\n\tunsigned int gcd;\n\n\twhile(1){\n\t\tscanf(\"%u\\n\",&n);\n\t\tif(n==0)break;\n\n\t\tfor(i=1;i<=n;i++){\n\t\t\tscanf(\"%u %u %u %u\\n\",&p,&q,&r,&b);\n\t\t\tgcd=calc_gcd(p,q);\n\t\t\tMOB[i].p=p/gcd;\n\t\t\tMOB[i].q=q/gcd;\n\t\t\tMOB[i].r=r;\n\t\t\tMOB[i].b=b;\n\t\t\tMOB[i].left=0;\n\t\t\tMOB[i].right=0;\n\t\t\t\n\t\t}\n\t\t\n\t\t// search TOP;\n\t\tfor(i=1;i<=n;i++)chk[i]=0;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tif(MOB[i].r!=0)chk[MOB[i].r]=1;\n\t\t\tif(MOB[i].b!=0)chk[MOB[i].b]=1;\n\t\t}\n\t\tfor(i=1;i<=n;i++){\n\t\t\tif(chk[i]==0)Top=i;\n\t\t}\n\t\tTotal=calc_mass(Top);\n\t\tprintf(\"%u\\n\",Total);\n\n\t}\n\treturn 0;\n}\n\n\nunsigned int calc_gcd( unsigned int a, unsigned int b){\n\t unsigned int c=1;\n\t unsigned int gcd;\n\n        if(a==0 || b==0)return 0;\n        if(a==1 || b==1)return 1;\n\n        if(a<b){\n            c=a,a=b,b=c;\n        }\n\n        gcd=1;\n\t\n\twhile(a%b!=0){\n\t\tc=b;\n\t\tb=a%b;\n\t\ta=c;\n\t}\n\tgcd=b;\n\n\treturn gcd;\n\n}\n\n\n\nunsigned int calc_mass(unsigned int trgt){\n\tunsigned int gcd;\n\tunsigned int left,right;\n\tunsigned int left2,right2;\n\tunsigned int ratio;\n\n\tif(MOB[trgt].r==0 && MOB[trgt].b==0){\n\t\tgcd=calc_gcd(MOB[trgt].p,MOB[trgt].q);\n\t\tMOB[trgt].left=MOB[trgt].q/gcd;\n\t\tMOB[trgt].right=MOB[trgt].p/gcd;\n\t\treturn MOB[trgt].left+MOB[trgt].right;\n\t}\n\t\n\tif(MOB[trgt].left==0){\n\t\tif(MOB[trgt].r==0)left=1;\n\t\tif(MOB[trgt].r!=0)left=calc_mass(MOB[trgt].r);\n\t}\n\tif(MOB[trgt].right==0){\n\t\tif(MOB[trgt].b==0)right=1;\n\t\tif(MOB[trgt].b!=0)right=calc_mass(MOB[trgt].b);\n\t}\n\t\n\n\n\tgcd=calc_gcd(right,left);\n\tleft2=left/gcd,right2=right/gcd;\n\tgcd=calc_gcd(left2*MOB[trgt].q,right2*MOB[trgt].p);\n\tratio=(right2*MOB[trgt].p)/gcd;\n\tMOB[trgt].left=left*ratio;\n\t\n\tratio=(left2*MOB[trgt].q)/gcd;\n\tMOB[trgt].right=right*ratio;\n\t\n\treturn MOB[trgt].left+MOB[trgt].right;\n\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\ntypedef struct _node{\n\tint p;\n\tint q;\n\tint r;\n\tint b;\n\tint left;\t//p-side mass\n\tint right;\t//q-side mass\n} Node;\nint calc_mass(int trgt);\nint calc_gcd( int a, int b);\nNode MOB[101];\n\nint main(){\n\n\tint n;\n\tint chk[101];\n\tint i;\n\tint p;\n\tint q;\n\tint r;\n\tint b;\n\tint Top;\n\tint Total;\n\n\twhile(1){\n\t\tscanf(\"%d\\n\",&n);\n\t\tif(n==0)break;\n\n\t\tfor(i=1;i<=n;i++){\n\t\t\tscanf(\"%d %d %d %d\\n\",&p,&q,&r,&b);\n\t\t\tMOB[i].p=p;\n\t\t\tMOB[i].q=q;\n\t\t\tMOB[i].r=r;\n\t\t\tMOB[i].b=b;\n\t\t\tMOB[i].left=0;\n\t\t\tMOB[i].right=0;\n\t\t\t\n\t\t}\n\t\t\n\t\t// search TOP;\n\t\tfor(i=1;i<=n;i++)chk[i]=0;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tif(MOB[i].r!=0)chk[MOB[i].r]=1;\n\t\t\tif(MOB[i].b!=0)chk[MOB[i].b]=1;\n\t\t}\n\t\tfor(i=1;i<=n;i++){\n\t\t\tif(chk[i]==0)Top=i;\n\t\t}\n\t\tTotal=calc_mass(Top);\n\t\tprintf(\"%d\\n\",Total);\n\n\t}\n\treturn 0;\n}\n\n\nint calc_gcd( int a, int b){\n\t int c=1;\n\t int gcd;\n\n        if(a==0 || b==0)return 0;\n\n        if(a<b){\n            c=a,a=b,b=c;\n        }\n\n        gcd=1;\n\t\n\twhile(a%b!=0){\n\t\tc=b;\n\t\tb=a%b;\n\t\ta=c;\n\t}\n\tgcd=b;\n\n\treturn gcd;\n\n}\n\n\n\nint calc_mass(int trgt){\n\tint gcd;\n\tint left,right;\n\n\tif(MOB[trgt].r==0 && MOB[trgt].b==0){\n\t\tgcd=calc_gcd(MOB[trgt].p,MOB[trgt].q);\n\t\tMOB[trgt].left=MOB[trgt].q/gcd;\n\t\tMOB[trgt].right=MOB[trgt].p/gcd;\n\t\treturn MOB[trgt].left+MOB[trgt].right;\n\t}\n\t\n\tif(MOB[trgt].left==0){\n\t\tif(MOB[trgt].r==0)left=1;\n\t\tif(MOB[trgt].r!=0)left=calc_mass(MOB[trgt].r);\n\t}\n\tif(MOB[trgt].right==0){\n\t\tif(MOB[trgt].b==0)right=1;\n\t\tif(MOB[trgt].b!=0)right=calc_mass(MOB[trgt].b);\n\t}\n\t\n\tgcd=calc_gcd(left*MOB[trgt].q,right*MOB[trgt].p);\n\tMOB[trgt].left=left*right*MOB[trgt].p/gcd;\n\tMOB[trgt].right=right*left*MOB[trgt].q/gcd;\n\treturn MOB[trgt].left+MOB[trgt].right;\n\n}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A0520\nLightest Mobile\n2013/1/17 TE\n*/\n#include <stdio.h>\n\n\nstruct MOB\n{\n  int leftlen   ;int rightlen;\n  int leftnode  ;int rightnode;\n} ;\n\nstruct MOB mobiles[100];\nint gcd(int x, int y){\n\treturn y == 0 ? x: gcd(y, x%y);\n}\n\n\nlong int lcm(long int x,long int y)\n{\n  return(x/gcd(x,y)*y);\n}\n\nlong int calc_total_weight1(int leftlen, int rightlen,long int leftweight , long int rightweight)\n{\n  long int l;\n  // printf(\"%d %d %ld %ld\\n\",leftlen,rightlen,leftweight,rightweight);\n  l=lcm((leftlen *rightweight),(rightlen * leftweight));\n  return(l/leftlen+l/rightlen);\n}\n\nlong int calc_total_weight(struct MOB *m,int node_no)\n{ long int w1,w2,tw;\n  struct MOB * bar;\n  bar = m + (node_no - 1);\n\n\n  if(bar -> leftnode != 0)\n    w1 = calc_total_weight(m,(bar->leftnode));\n  else\n    w1 = 1;\n  if(bar -> rightnode != 0)\n    w2 = calc_total_weight(m,(bar->rightnode));\n  else\n    w2 = 1;\n\n  tw = calc_total_weight1(bar->leftlen,bar->rightlen,w1,w2);\n\n  return(tw);\n    \n}\n\nint search_root(struct MOB * m,int siz)\n{\n  int i,j;\n  for(i=1;i<=siz;i++)\n    {  for(j=0;j<siz;j++)\n      {\n        if(m[j].leftnode == i ||m[j].rightnode == i)\n          goto AAA;\n      }\n      return(i);\n    AAA:\n      ;\n    }\n   return(-1);\n\n}\n\n\nmain()\n{\nint i;\nlong int total_weight;\nint  root;\nint  cnt;\n  \n  while(EOF != scanf(\"%d\",&cnt) && cnt)\n    {     \n      for(i=0;i<cnt;i++)\n         scanf(\" %d %d %d %d\",\n               &(mobiles[i].leftlen),\n               &(mobiles[i].rightlen),\n               &(mobiles[i].leftnode),\n               &(mobiles[i].rightnode));\n    \n  \n  root = search_root(mobiles,cnt);    \n  total_weight = calc_total_weight(mobiles,root);\n\n  printf(\"%ld\\n\",total_weight);\n    }\nreturn(0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\ntypedef struct bar{\n\tint p,q,r,b,w;\n}BAR;\nBAR a[105];\nint gcm(int x,int y){\n\tif(x%y==0)return y;\n\treturn gcm(y,x%y);\n}\nint lcm(int x,int y){\n\treturn x*y/gcm(x,y);\n}\nint func(int x){\n\tif(a[x].w!=0)return a[x].w;\n\tint aa,b,c,d;\n\taa=gcm( a[x].p , a[x].q );\n\tb=lcm( func(a[x].r) , func(a[x].b) );\n\tc=b*a[x].q/aa;\n\td=b*a[x].p/aa;\n\ta[x].w=c+d;\n\treturn a[x].w;\n}\nint main(){\n\tint i,j,n,ans;\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\ta[0].w=1;\n\t\tfor(i=1;i<=n;i++){\n\t\t\ta[i].w=0;\n\t\t\tscanf(\"%d%d%d%d\",&a[i].p,&a[i].q,&a[i].r,&a[i].b);\n\t\t\tif(a[i].r==0 && a[i].b==0){\n\t\t\t\ta[i].w=(a[i].p+a[i].q)/gcm(a[i].p,a[i].q);\n\t\t\t}\n\t\t}\n\t\tans=0;\n\t\tfor(i=1;i<=n;i++){\n\t\t\t//printf(\"%d\\n\",func(i));\n\t\t\tfunc(i);\n\t\t\tif(a[i].w>ans)ans=a[i].w;\n\t\t}\n\t\t//scanf(\"%d%d\",&i,&j);\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\ntypedef struct {\n\tlong p,q,r,b;\n} mobile;\n\nmobile bar[100];\n\nlong kbs(long a, long b){\n\tif(a<b) return kbs(b,a);\n\t\tif(b<=0) return a;\n\t\treturn kbs(b,a%b);\n}\n\nlong weight(int i){\n\tif(i==0) return 1;\n\tlong j,a,b;\n\ta=bar[i-1].q*weight(bar[i-1].b);\n\tb=bar[i-1].p*weight(bar[i-1].r);\n\tj=kbs(a,b);\n\tj=a/j*b;\n\treturn j/bar[i-1].p+j/bar[i-1].q;\n}\n\nint main(){\n\tint n,i,f,current;\n\tlong heavy,max;\n\tscanf(\"%d\",&n);\n\twhile(n!=0){\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%ld %ld %ld %ld\",&bar[i].p,&bar[i].q,&bar[i].r,&bar[i].b);\n\t\t}\n\t\tf=1;\n\t\tcurrent=1;\n\t\twhile(f){\n\t\t\tf=0;\n\t\t\tfor(i=0;i<n;i++){\n\t\t\t\tif(bar[i].r==current || bar[i].b==current){\n\t\t\t\t\tcurrent=i+1;\n\t\t\t\t\tf=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%ld\\n\",weight(current));\n\t\tscanf(\"%d\",&n);\n\t}\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\ntypedef struct _node{\n\tunsigned int p;\n\tunsigned int q;\n\tunsigned int r;\n\tunsigned int b;\n\tunsigned int left;\t//p-side mass\n\tunsigned int right;\t//q-side mass\n} Node;\nunsigned int calc_mass(unsigned int trgt);\nunsigned int calc_gcd( unsigned int a, unsigned int b);\nNode MOB[101];\n\nunsigned int main(){\n\n\tunsigned int n;\n\tunsigned int chk[101];\n\tunsigned int i;\n\tunsigned int p;\n\tunsigned int q;\n\tunsigned int r;\n\tunsigned int b;\n\tunsigned int Top;\n\tunsigned int Total;\n\tunsigned int gcd;\n\n\twhile(1){\n\t\tscanf(\"%d\\n\",&n);\n\t\tif(n==0)break;\n\n\t\tfor(i=1;i<=n;i++){\n\t\t\tscanf(\"%d %d %d %d\\n\",&p,&q,&r,&b);\n\t\t\tgcd=calc_gcd(p,q);\n\t\t\tMOB[i].p=p/gcd;\n\t\t\tMOB[i].q=q/gcd;\n\t\t\tMOB[i].r=r;\n\t\t\tMOB[i].b=b;\n\t\t\tMOB[i].left=0;\n\t\t\tMOB[i].right=0;\n\t\t\t\n\t\t}\n\t\t\n\t\t// search TOP;\n\t\tfor(i=1;i<=n;i++)chk[i]=0;\n\t\tfor(i=1;i<=n;i++){\n\t\t\tif(MOB[i].r!=0)chk[MOB[i].r]=1;\n\t\t\tif(MOB[i].b!=0)chk[MOB[i].b]=1;\n\t\t}\n\t\tfor(i=1;i<=n;i++){\n\t\t\tif(chk[i]==0)Top=i;\n\t\t}\n\t\tTotal=calc_mass(Top);\n\t\tprintf(\"%d\\n\",Total);\n\n\t}\n\treturn 0;\n}\n\n\nunsigned int calc_gcd( unsigned int a, unsigned int b){\n\t unsigned int c=1;\n\t unsigned int gcd;\n\n        if(a==0 || b==0)return 0;\n\n        if(a<b){\n            c=a,a=b,b=c;\n        }\n\n        gcd=1;\n\t\n\twhile(a%b!=0){\n\t\tc=b;\n\t\tb=a%b;\n\t\ta=c;\n\t}\n\tgcd=b;\n\n\treturn gcd;\n\n}\n\n\n\nunsigned int calc_mass(unsigned int trgt){\n\tunsigned int gcd;\n\tunsigned int left,right;\n\n\tif(MOB[trgt].r==0 && MOB[trgt].b==0){\n\t\tgcd=calc_gcd(MOB[trgt].p,MOB[trgt].q);\n\t\tMOB[trgt].left=MOB[trgt].q/gcd;\n\t\tMOB[trgt].right=MOB[trgt].p/gcd;\n\t\treturn MOB[trgt].left+MOB[trgt].right;\n\t}\n\t\n\tif(MOB[trgt].left==0){\n\t\tif(MOB[trgt].r==0)left=1;\n\t\tif(MOB[trgt].r!=0)left=calc_mass(MOB[trgt].r);\n\t}\n\tif(MOB[trgt].right==0){\n\t\tif(MOB[trgt].b==0)right=1;\n\t\tif(MOB[trgt].b!=0)right=calc_mass(MOB[trgt].b);\n\t}\n\t\n\tgcd=calc_gcd(left*MOB[trgt].q,right*MOB[trgt].p);\n\tMOB[trgt].left=left*right*MOB[trgt].p/gcd;\n\tMOB[trgt].right=right*left*MOB[trgt].q/gcd;\n\treturn MOB[trgt].left+MOB[trgt].right;\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.StringTokenizer;\n\n/**\n * Lightest Mobile\n */\npublic class Main {\n\n\tstatic Main main = new Main();\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line = \"\";\n\n\t\tMobile mobile = null;\n\t\twhile (!(line = br.readLine()).equals(\"0\")) {\n\t\t\tint n = Integer.parseInt(line);\n\n\t\t\tmobile = main.new Mobile();\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tmobile.add(i, br.readLine());\n\t\t\t}\n\t\t\tlong result = mobile.calc();\n\t\t\tSystem.err.println(result);\n\t\t\tSystem.out.println(result);\n\t\t}\n\t}\n\n\tclass Mobile {\n\t\tArrayList<Bar> mobile = new ArrayList<Bar>();\n\n\t\t// 棒をモービルに追加\n\t\tvoid add(int id, String info) {\n\t\t\tHangableImpr parent, left, right;\n\t\t\tint lid, rid;\n\t\t\tint rateL, rateR;\n\n\t\t\tStringTokenizer st = new StringTokenizer(info);\n\t\t\trateL = Integer.parseInt(st.nextToken());\n\t\t\trateR = Integer.parseInt(st.nextToken());\n\n\t\t\t// 親の棒\n\t\t\tif ((parent = find(id)) == null) {\n\t\t\t\tparent = new Bar(id, null);\n\t\t\t}\n\t\t\t((Bar) parent).lengthL = rateL;\n\t\t\t((Bar) parent).lengthR = rateR;\n\n\t\t\tlid = Integer.parseInt(st.nextToken());\n\t\t\trid = Integer.parseInt(st.nextToken());\n\n\t\t\t// 左の棒\n\t\t\tif (lid == 0) {\n\t\t\t\tleft = new Spindle();\n\t\t\t\tleft.parent = parent;\n\t\t\t} else {\n\t\t\t\tif ((left = find(lid)) == null) {\n\t\t\t\t\tleft = new Bar(lid, (Bar) parent);\n\t\t\t\t} else {\n\t\t\t\t\t((Bar) left).parent = (Bar) parent;\n\t\t\t\t\tmobile.remove(left);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// 右の棒\n\t\t\tif (rid == 0) {\n\t\t\t\tright = new Spindle();\n\t\t\t\tright.parent = parent;\n\t\t\t} else {\n\t\t\t\tif ((right = find(rid)) == null) {\n\t\t\t\t\tright = new Bar(rid, (Bar) parent);\n\t\t\t\t} else {\n\t\t\t\t\t((Bar) right).parent = (Bar) parent;\n\t\t\t\t\tmobile.remove(right);\n\t\t\t\t}\n\t\t\t}\n\t\t\t((Bar) parent).left = left;\n\t\t\t((Bar) parent).right = right;\n\t\t\tif (((Bar) parent).parent == null) {\n\t\t\t\tmobile.add((Bar) parent);\n\t\t\t}\n\t\t}\n\n\t\t// 指定した id の棒を検索\n\t\tBar find(int id) {\n\t\t\tBar result = null;\n\t\t\tfor (Bar b : mobile) {\n\t\t\t\tresult = b.find(id);\n\t\t\t\tif (result != null)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tlong calc() {\n\t\t\tlong result = 0;\n\t\t\tfor (Bar b : mobile) {\n\t\t\t\tb.calc();\n\t\t\t\tresult = b.weight;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t//\n\tinterface Hangable {\n\t\tHangable find(int id);\n\t}\n\n\tabstract class HangableImpr implements Hangable {\n\t\tHangableImpr parent;\n\t\tlong weight = 0;\n\t}\n\n\tclass Spindle extends HangableImpr {\n\t\t// int weight = 0;\n\t\t// Bar parent;\n\n\t\tSpindle() {\n\t\t\tthis.weight = 0;\n\t\t}\n\n\t\tSpindle(int weight) {\n\t\t\tthis.weight = weight;\n\t\t}\n\n\t\tpublic Spindle find(int id) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tclass Bar extends HangableImpr {\n\t\tint id;\n\t\tint lengthL, lengthR;\n\t\t// Bar parent;\n\t\tHangableImpr parent, left, right;\n\n\t\tBar(int id, Bar parent) {\n\t\t\tthis.id = id;\n\t\t\tthis.parent = parent;\n\t\t}\n\n\t\tpublic Bar find(int id) {\n\t\t\tBar result = null;\n\t\t\tif (this.id == id)\n\t\t\t\tresult = this;\n\t\t\tif (result == null && left != null)\n\t\t\t\tresult = (Bar) left.find(id);\n\t\t\tif (result == null && right != null)\n\t\t\t\tresult = (Bar) right.find(id);\n\t\t\treturn result;\n\t\t}\n\n\t\tvoid calc() {\n\t\t\tif (left instanceof Bar) {\n\t\t\t\t((Bar) left).calc();\n\t\t\t}\n\t\t\tif (right instanceof Bar) {\n\t\t\t\t((Bar) right).calc();\n\t\t\t}\n\n\t\t\tlong gcd = gcd(lengthL, lengthR);\n\t\t\tlong tempL, tempR;\n\t\t\tlong weightL, weightR;\n\n\t\t\ttempL = lengthL / gcd;\n\t\t\ttempR = lengthR / gcd;\n\t\t\tweightL = left.weight;\n\t\t\tweightR = right.weight;\n\n\t\t\tif (weightL == 0 && weightR == 0) {\n\t\t\t\tleft.weight = tempR;\n\t\t\t\tright.weight = tempL;\n\t\t\t} else if (weightL != 0 && weightR == 0) {\n\t\t\t\tlong lcm = lcm(tempR, lcm(tempL, weightL));\n\t\t\t\tright.weight = lcm / tempL;\n\t\t\t} else if (weightL == 0 && weightR != 0) {\n\t\t\t\tlong lcm = lcm(tempL, lcm(tempR, weightR));\n\t\t\t\tleft.weight = lcm / tempR;\n\t\t\t} else {\n\t\t\t\tlong lcm = lcm(lcm(tempL, weightL), lcm(tempR, weightR));\n\t\t\t\tleft.weight = lcm / tempR;\n\t\t\t\tright.weight = lcm / tempL;\n\t\t\t}\n\t\t\tweight = left.weight + right.weight;\n\t\t}\n\t}\n\n\t// 最大公約数\n\tstatic long lcm(long l, long r) {\n\t\treturn l * (r / gcd(l, r));\n\t}\n\n\tstatic long lcm(long l, long r, long gcd) {\n\t\treturn l * (r / gcd);\n\t}\n\n\t// 最小公倍数\n\tstatic long gcd(long l, long r) {\n\t\tlong mod;\n\t\tlong gt = l > r ? l : r;\n\t\tlong lt = l < r ? l : r;\n\n\t\tdo {\n\t\t\tmod = gt % lt;\n\t\t\tgt = lt;\n\t\t\tlt = mod;\n\t\t} while (mod != 0);\n\n\t\treturn gt;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n \npublic class Main{\n \nstatic PrintWriter out;\nstatic InputReader ir;\nstatic int[] p=new int[101],q=new int[101],r=new int[101],b=new int[101],par=new int[101];\n \nstatic void solve(){\n int n;\n while((n=ir.nextInt())!=0){\n  Arrays.fill(par,-1);\n  for(int i=0;i<n;i++){\n   p[i]=ir.nextInt();\n   q[i]=ir.nextInt();\n   r[i]=ir.nextInt();\n   b[i]=ir.nextInt();\n   par[r[i]]=par[b[i]]=i+1;\n   long g=gcd(p[i],q[i]);\n   p[i]/=(int)g;\n   q[i]/=(int)g;\n  }\n  int pp=-1;\n  for(int i=1;i<=n;i++) if(par[i]==-1) pp=i;\n  out.println(dfs(pp));\n }\n}\n \npublic static long dfs(int m){\n int now=m-1;\n if(r[now]==0&&b[now]==0) return (long)p[now]+(long)q[now];\n if(r[now]==0){\n  long bb=dfs(b[now]);\n  return bb/gcd(q[now],bb)*(p[now]+q[now]);\n }\n if(b[now]==0){\n  long rr=dfs(r[now]);\n  return rr/gcd(p[now],rr)*(p[now]+q[now]);\n }\n long bb=dfs(b[now]),rr=dfs(r[now]);\n long l=lcm(bb*p[now],rr*q[now]);\n return l/p[now]+l/q[now];\n}\n \npublic static long gcd(long a,long b){\n if(b==0) return a;\n return gcd(b,a%b);\n}\n\npublic static long lcm(long a,long b){\n return a*b/gcd(a,b);\n}\n \npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n \nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n \n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n  \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n \n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n  \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n  \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n  \n public boolean hasNext(){skip(); return hasNextByte();}\n  \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n  \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n  \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public double nextDouble(){return Double.parseDouble(next());}\n \n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n \n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n \n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n\npublic class Main{\n\nstatic PrintWriter out;\nstatic InputReader ir;\nstatic int[] p=new int[101],q=new int[101],r=new int[101],b=new int[101],par=new int[101];\n\nstatic void solve(){\n int n;\n while((n=ir.nextInt())!=0){\n  for(int i=0;i<n;i++){\n   p[i]=ir.nextInt();\n   q[i]=ir.nextInt();\n   r[i]=ir.nextInt();\n   b[i]=ir.nextInt();\n   par[r[i]]=par[b[i]]=i+1;\n   int g=gcd(p[i],q[i]);\n   p[i]/=g;\n   q[i]/=g;\n  }\n  int now=1;\n  while(par[now]!=0) now=par[now];\n  out.println(dfs(now));\n  Arrays.fill(par,0);\n }\n}\n\npublic static int dfs(int m){\n int now=m-1;\n if(r[now]==0&&b[now]==0) return p[now]+q[now];\n if(r[now]==0){\n  int bb=dfs(b[now]);\n  return bb*q[now]/gcd(q[now],bb)*(p[now]+q[now]);\n }\n if(b[now]==0){\n  int rr=dfs(r[now]);\n  return rr*p[now]/gcd(p[now],rr)*(p[now]+q[now]);\n }\n int bb=dfs(b[now]),rr=dfs(r[now]);\n int t=bb*p[now]/gcd(bb*p[now],rr*q[now])*rr*q[now];\n return t/p[now]+t/q[now];\n}\n\npublic static int gcd(int a,int b){\n if(b==0) return a;\n return gcd(b,a%b);\n}\n\npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n\nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n\n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n\n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n \n public boolean hasNext(){skip(); return hasNextByte();}\n \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n\n public double nextDouble(){return Double.parseDouble(next());}\n\n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n\n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n\n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n\npublic class Main{\n\nstatic PrintWriter out;\nstatic InputReader ir;\nstatic int[] p=new int[101],q=new int[101],r=new int[101],b=new int[101],par=new int[101];\n\nstatic void solve(){\n int n;\n while((n=ir.nextInt())!=0){\n  for(int i=0;i<n;i++){\n   p[i]=ir.nextInt();\n   q[i]=ir.nextInt();\n   r[i]=ir.nextInt();\n   b[i]=ir.nextInt();\n   par[r[i]]=p[b[i]]=i+1;\n   int g=gcd(p[i],q[i]);\n   p[i]/=g;\n   q[i]/=g;\n  }\n  int now=1;\n  while(par[now]!=0) now=par[now];\n  out.println(dfs(now));\n  Arrays.fill(par,0);\n }\n}\n\npublic static int dfs(int m){\n int now=m-1;\n if(r[now]==0&&b[now]==0) return p[now]+q[now];\n if(r[now]==0){\n  int bb=dfs(b[now]);\n  return bb/gcd(p[now],bb)*(p[now]+q[now]);\n }\n if(b[now]==0){\n  int rr=dfs(r[now]);\n  return rr/gcd(q[now],rr)*(p[now]+q[now]);\n }\n int bb=dfs(b[now]),rr=dfs(r[now]);\n int t=bb*p[now]/gcd(bb*p[now],rr*q[now])*rr*q[now];\n return t/p[now]+t/q[now];\n}\n\npublic static int gcd(int a,int b){\n if(b==0) return a;\n return gcd(b,a%b);\n}\n\npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n\nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n\n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n\n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n \n public boolean hasNext(){skip(); return hasNextByte();}\n \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n\n public double nextDouble(){return Double.parseDouble(next());}\n\n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n\n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n\n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n \npublic class Main{\n \nstatic PrintWriter out;\nstatic InputReader ir;\nstatic int[] p=new int[101],q=new int[101],r=new int[101],b=new int[101],par=new int[101];\n \nstatic void solve(){\n int n;\n while((n=ir.nextInt())!=0){\n  for(int i=1;i<=n;i++){\n   p[i]=ir.nextInt();\n   q[i]=ir.nextInt();\n   r[i]=ir.nextInt();\n   b[i]=ir.nextInt();\n   par[r[i]]=par[b[i]]=i;\n   long g=gcd(p[i],q[i]);\n   p[i]/=(int)g;\n   q[i]/=(int)g;\n  }\n  int pp=1;\n  while(par[pp]!=0) pp=par[pp];\n  out.println(dfs(pp));\n  Arrays.fill(par,0);\n }\n}\n \npublic static long dfs(int now){\n if(r[now]==0&&b[now]==0) return (long)p[now]+(long)q[now];\n if(r[now]==0){\n  long bb=dfs(b[now]);\n  return bb/gcd(p[now],bb)*(p[now]+q[now]);\n }\n if(b[now]==0){\n  long rr=dfs(r[now]);\n  return rr/gcd(q[now],rr)*(p[now]+q[now]);\n }\n long bb=dfs(b[now]),rr=dfs(r[now]);\n long l=lcm(bb*q[now],rr*p[now]);\n return l/p[now]+l/q[now];\n}\n \npublic static long gcd(long a,long b){\n if(b==0) return a;\n return gcd(b,a%b);\n}\n\npublic static long lcm(long a,long b){\n return a*b/gcd(a,b);\n}\n \npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n \nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n \n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n  \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n \n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n  \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n  \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n  \n public boolean hasNext(){skip(); return hasNextByte();}\n  \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n  \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n  \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public double nextDouble(){return Double.parseDouble(next());}\n \n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n \n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n \n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic long allLcm;\n\n\tpublic static void main(String[] args) {\n\t\twhile (true) {\n\t\t\tint N = sc.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\tallLcm = 1;\n\t\t\tStick[] nodes = new Stick[N];\n\t\t\tboolean[] hasParent = new boolean[N];\n\t\t\tint[] l = new int[N];\n\t\t\tint[] r = new int[N];\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tint p = sc.nextInt();\n\t\t\t\tint q = sc.nextInt();\n\t\t\t\tnodes[i] = new Stick(p, q);\n\t\t\t\tl[i] = sc.nextInt() - 1;\n\t\t\t\tr[i] = sc.nextInt() - 1;\n\t\t\t\tif (l[i] != -1) hasParent[l[i]] = true;\n\t\t\t\tif (r[i] != -1) hasParent[r[i]] = true;\n\t\t\t}\n\t\t\tint root = -1;\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tif (l[i] != -1) {\n\t\t\t\t\tnodes[i].left = nodes[l[i]];\n\t\t\t\t} else {\n\t\t\t\t\tnodes[i].left = new Weight();\n\t\t\t\t}\n\t\t\t\tif (r[i] != -1) {\n\t\t\t\t\tnodes[i].right = nodes[r[i]];\n\t\t\t\t} else {\n\t\t\t\t\tnodes[i].right = new Weight();\n\t\t\t\t}\n\t\t\t\tif (!hasParent[i]) root = i;\n\t\t\t}\n\t\t\tnodes[root].set(new Rational(1, 1));\n\t\t\tSystem.out.println(nodes[root].sum());\n\t\t}\n\t}\n\n\tstatic abstract class Node {\n\t\tabstract long sum();\n\n\t\tabstract void set(Rational v);\n\t}\n\n\tstatic class Stick extends Node {\n\t\tNode left, right;\n\t\tint p, q;\n\n\t\tStick(int p, int q) {\n\t\t\tthis.p = p;\n\t\t\tthis.q = q;\n\t\t}\n\n\t\tlong sum() {\n\t\t\treturn left.sum() + right.sum();\n\t\t}\n\n\t\tvoid set(Rational v) {\n\t\t\tthis.left.set(v.mul(new Rational(q, p + q)));\n\t\t\tthis.right.set(v.mul(new Rational(p, p + q)));\n\t\t}\n\t}\n\n\tstatic class Weight extends Node {\n\t\tRational w;\n\n\t\tlong sum() {\n\t\t\treturn w.num * (allLcm / w.den);\n\t\t}\n\n\t\tvoid set(Rational v) {\n\t\t\tthis.w = v;\n\t\t\tallLcm = lcm(allLcm, v.den);\n\t\t}\n\t}\n\n\tstatic long lcm(long a, long b) {\n\t\treturn a / gcd(a, b) * b;\n\t}\n\n\tstatic long gcd(long a, long b) {\n\t\treturn b == 0 ? a : gcd(b, a % b);\n\t}\n\n\tstatic class Rational {\n\t\tlong num, den;\n\n\t\tRational(long n, long d) {\n\t\t\tlong gcd = gcd(n, d);\n\t\t\tthis.num = n / gcd;\n\t\t\tthis.den = d / gcd;\n\t\t}\n\n\t\tRational add(Rational o) {\n\t\t\treturn new Rational(this.num * o.den + this.den * o.num, this.den * o.den);\n\t\t}\n\n\t\tRational mul(Rational o) {\n\t\t\treturn new Rational(this.num * o.num, this.den * o.den);\n\t\t}\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\nclass Node {\n    public int p, q, r, b, parent;\n    Node(int p, int q, int r, int b) {\n        this.p = p;\n        this.q = q;\n        this.r = r;\n        this.b = b;\n        this.parent = -1;\n    }\n}\n\npublic class Main {\n    Scanner sc;\n    int n;\n    int root;\n    Node[] tree;\n\n    long gcd(long a, long b) {\n        if (a > b) {\n            long tmp = a;\n            a = b;\n            b = tmp;\n        }\n        if (a == 0) return b;\n        return gcd(b % a, a);\n    }\n\n    long lcm(long a, long b) {\n        return a / gcd(a, b) * b;\n    }\n\n    Main() {\n        sc = new Scanner(System.in);\n    }\n\n    long lightest(int index) {\n        int p = tree[index].p;\n        int q = tree[index].q;\n        int r = tree[index].r;\n        int b = tree[index].b;\n        if (r == -1 && b == -1) {\n            return (p + q) / gcd(p, q);\n        } else if (r == -1) {\n            long b_weight = lcm(lightest(b), p);\n            long r_weight = b_weight * q / p;\n            return r_weight + b_weight;\n        } else if (b == -1) {\n            long r_weight = lcm(lightest(r), q);\n            long b_weight = r_weight * p / q;\n            return r_weight + b_weight;\n        }\n        long lcm_rb = lcm(lightest(r)*p, lightest(b)*q);\n        long r_weight = lcm_rb / p;\n        long b_weight = lcm_rb / q;\n        return r_weight + b_weight;\n    }\n\n    boolean init() {\n        n = sc.nextInt();\n        if (n == 0) return false;\n\n        tree = new Node[n];\n        for (int i = 0; i < n; i++) {\n            int p = sc.nextInt();\n            int q = sc.nextInt();\n            int r = sc.nextInt();\n            int b = sc.nextInt();\n            long gcd_pq = gcd(p, q);\n            p /= gcd_pq;\n            q /= gcd_pq;\n            tree[i] = new Node(p, q, r-1, b-1);  // 0-originに\n        }\n\n        // 親を探す\n        for (int i = 0; i < n; i++) {\n            if (tree[i].r >= 0) tree[tree[i].r].parent = i;\n            if (tree[i].b >= 0) tree[tree[i].b].parent = i;\n        }\n\n        // rootを探す\n        for (int i = 0; i < n; i++) \n            if (tree[i].parent == -1) {\n                root = i;\n                break;\n            }\n\n        return true;\n    }\n\n    void debug() {\n        for (int i = 0; i < n; i++) {\n            System.out.printf(\"%d %d %d %d %d\\n\", tree[i].p, tree[i].q, tree[i].r, tree[i].b, tree[i].parent);\n        }\n    }\n\n    void run() {\n        while (init()) {\n            System.out.printf(\"%d\\n\", lightest(root));\n        }\n    }\n\n    public static void main(String[] args) {\n        new Main().run();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Lightest Mobile\npublic class Main{\n\n\tstatic long gcd(long a, long b){\n\t\tif(a < b){\n\t\t\tlong tmp = a;\n\t\t\ta = b;\n\t\t\tb = tmp;\n\t\t}\n\t\twhile(b!=0){\n\t\t\tlong r = a%b;\n\t\t\ta = b;\n\t\t\tb = r;\n\t\t}\n\t\treturn a;\n\t}\n\n\tclass R{\n\t\tlong p, q;\n\t\tR l, r, parent;\n\t\tpublic R() {\n\t\t\tl = r = parent = null;\n\t\t}\n\t\tlong get(){\n\t\t\tif(p==0)return 1;\n\t\t\tlong lg = l.get();\n\t\t\tlong rg = r.get();\n\t\t\tlong g = gcd(lg, rg);\n\t\t\tlong rate = lg/g*rg;\n\t\t\tlong s = p+q;\n\t\t\treturn s*rate;\n\t\t}\n\t}\n\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tR[] s = new R[n+1];\n\t\t\tfor(int i=0;i<=n;i++)s[i]=new R();\n\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\ts[i].p = sc.nextLong();\n\t\t\t\ts[i].q = sc.nextLong();\n\t\t\t\tlong g = gcd(s[i].p, s[i].q);\n\t\t\t\ts[i].p/=g;\n\t\t\t\ts[i].q/=g;\n\t\t\t\tint l = sc.nextInt();\n\t\t\t\tint r = sc.nextInt();\n\t\t\t\ts[i].l = s[l];\n\t\t\t\ts[i].r = s[r];\n\t\t\t\ts[l].parent = s[i];\n\t\t\t\ts[r].parent = s[i];\n\t\t\t}\n\t\t\tR root = null;\n\t\t\tfor(int i=1;i<=n;i++)if(s[i].parent==null)root = s[i];\n\t\t\tSystem.out.println(root.get());\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Lightest Mobile\npublic class Main{\n\n\tstatic long gcd(long a, long b){\n\t\tif(a < b){\n\t\t\tlong tmp = a;\n\t\t\ta = b;\n\t\t\tb = tmp;\n\t\t}\n\t\twhile(b!=0){\n\t\t\tlong r = a%b;\n\t\t\ta = b;\n\t\t\tb = r;\n\t\t}\n\t\treturn a;\n\t}\n\n\tclass R{\n\t\tlong p, q;\n\t\tR l, r, parent;\n\t\tpublic R() {\n\t\t\tl = r = parent = null;\n\t\t}\n//\t\tlong solve(){\n//\n//\t\t}\n\t\tlong get(){\n\t\t\tif(p==0)return 1;\n\t\t\tlong rate = l.get()*r.get();\n\t\t\tlong s = p+q;\n\t\t\tlong g = gcd(rate, s);\n\t\t\treturn s*rate/g;\n\t\t}\n\t}\n\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tR[] s = new R[n+1];\n\t\t\tfor(int i=0;i<=n;i++)s[i]=new R();\n\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\ts[i].p = sc.nextLong();\n\t\t\t\ts[i].q = sc.nextLong();\n\t\t\t\tlong g = gcd(s[i].p, s[i].q);\n\t\t\t\ts[i].p/=g;\n\t\t\t\ts[i].q/=g;\n\t\t\t\tint l = sc.nextInt();\n\t\t\t\tint r = sc.nextInt();\n\t\t\t\ts[i].l = s[l];\n\t\t\t\ts[i].r = s[r];\n\t\t\t\ts[l].parent = s[i];\n\t\t\t\ts[r].parent = s[i];\n\t\t\t}\n\t\t\tR root = null;\n\t\t\tfor(int i=1;i<=n;i++)if(s[i].parent==null)root = s[i];\n\t\t\tSystem.out.println(root.get());\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\t/**\n\t * TODO : ただの再帰ではなく、バランスを取らなければならない\n\t *　これは手戻りが発生する \n\t * \n\t * @author Taichiro\n\t *\n\t */\n\tpublic static class Node{\n\t\tNode left, right;\n\t\tlong l_dist, r_dist;\n\t\tlong weight;\n\t\t\n\t\tpublic Node(long l_dist, long r_dist) {\n\t\t\tsuper();\n\t\t\tthis.l_dist = l_dist;\n\t\t\tthis.r_dist = r_dist;\n\t\t\tthis.weight = 0;\n\t\t}\n\t\t\n\t\tpublic long solve(){\n\t\t\tif(this.weight != 0){\n\t\t\t\treturn this.weight;\n\t\t\t}\n\t\t\t\n\t\t\tif(this.left == null && this.right == null){\n\t\t\t\tfinal long moment  = lcm(this.l_dist, this.r_dist);\n\t\t\t\tfinal long left_w  = moment / l_dist;\n\t\t\t\tfinal long right_w = moment / r_dist;\n\t\t\t\t\n\t\t\t\treturn this.weight = (left_w + right_w);\n\t\t\t}else{\n\t\t\t\tfinal long left_ch_w  = left  != null ? left.solve()  : 1;\n\t\t\t\tfinal long right_ch_w = right != null ? right.solve() : 1;\n\t\t\t\t\n\t\t\t\tfinal long moment = lcm(left_ch_w * l_dist, right_ch_w * r_dist);\n\t\t\t\t\n\t\t\t\tfinal long left_w  = moment / l_dist;\n\t\t\t\tfinal long right_w = moment / r_dist;\n\t\t\t\t\n\t\t\t\treturn this.weight = (left_w + right_w);\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic String toString(){\n\t\t\treturn \"[\" + this.weight + \" : \" + (this.left == null ? \"\" : this.left.toString()) + \", \" + (this.right == null ? \"\" : this.right.toString()) + \"]\";\n\t\t}\n\t}\n\t\n\tpublic static long gcd(long x, long y){\n\t\tif(x == 0){\n\t\t\treturn y;\n\t\t}else{\n\t\t\treturn gcd(y % x, x);\n\t\t}\n\t}\n\t\n\tpublic static long lcm(long x, long y){\n\t\treturn  x * y / gcd(x, y);\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile (true) {\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint[][] data = new int[n][4];\n\t\t\tNode[] nodes = new Node[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\t\tdata[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = n - 1; i >= 0; i--){\n\t\t\t\t//System.out.println(i);\n\t\t\t\tnodes[i] = new Node(data[i][0], data[i][1]);\n\t\t\t}\n\t\t\tfor(int i = n - 1; i >= 0; i--){\n\t\t\t\tif(data[i][2] != 0){\n\t\t\t\t\tnodes[i].left  = nodes[data[i][2] - 1];\n\t\t\t\t}\n\t\t\t\tif(data[i][3] != 0){\n\t\t\t\t\tnodes[i].right = nodes[data[i][3] - 1];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tlong max = 0;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tmax = Math.max(max, nodes[i].solve());\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Lightest Mobile\npublic class Main{\n\n\tstatic long gcd(long a, long b){\n\t\tif(a < b){\n\t\t\tlong tmp = a;\n\t\t\ta = b;\n\t\t\tb = tmp;\n\t\t}\n\t\twhile(b!=0){\n\t\t\tlong r = a%b;\n\t\t\ta = b;\n\t\t\tb = r;\n\t\t}\n\t\treturn a;\n\t}\n\n\tclass R{\n\t\tlong p, q;\n\t\tR l, r, parent;\n\t\tlong get;\n\t\tpublic R() {\n\t\t\tget = -1;\n\t\t\tl = r = parent = null;\n\t\t}\n\t\tlong solve(){\n\t\t\tlong val = get();\n\t\t\tlong x = val;\n\t\t\twhile(true){\n\t\t\t\tlong s = x/(p+q);\n\t\t\t\tif(l.f(s*q)&&r.f(s*p))break;\n\t\t\t\tx+=val;\n\t\t\t}\n\t\t\treturn x;\n\t\t}\n\t\tlong get(){\n\t\t\tif(get!=-1)return get;\n\t\t\tif(p==0)return 1;\n\t\t\tlong lg = l.get();\n\t\t\tlong rg = r.get();\n\t\t\tlong g = gcd(lg, rg);\n\t\t\tlong rate = lg/g*rg;\n\t\t\tlong s = p+q;\n\t\t\treturn get = s*rate;\n\t\t}\n\t\tboolean f(long x){\n\t\t\tif(p==0)return true;\n\t\t\tif(x%(p+q)!=0)return false;\n\t\t\tlong s = x/(p+q);\n\t\t\treturn l.f(s*q)&&r.f(s*p);\n\t\t}\n\t}\n\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tR[] s = new R[n+1];\n\t\t\tfor(int i=0;i<=n;i++)s[i]=new R();\n\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\ts[i].p = sc.nextLong();\n\t\t\t\ts[i].q = sc.nextLong();\n\t\t\t\tlong g = gcd(s[i].p, s[i].q);\n\t\t\t\ts[i].p/=g;\n\t\t\t\ts[i].q/=g;\n\t\t\t\tint l = sc.nextInt();\n\t\t\t\tint r = sc.nextInt();\n\t\t\t\ts[i].l = s[l];\n\t\t\t\ts[i].r = s[r];\n\t\t\t\ts[l].parent = s[i];\n\t\t\t\ts[r].parent = s[i];\n\t\t\t}\n\t\t\tR root = null;\n\t\t\tfor(int i=1;i<=n;i++)if(s[i].parent==null)root = s[i];\n\t\t\tSystem.out.println(root.solve());\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int mobile[][];\n\tstatic int n;\n\tstatic long weight[];\n\n\tpublic static long f(int id) {\n\t\tif (0 < weight[id]) {\n\t\t\treturn weight[id];\n\t\t}\n\n\t\tlong le = 1;\n\t\tlong ri = 1;\n\t\tif (mobile[id][2] != 0) {\n\t\t\tle = f(mobile[id][2] - 1);\n\t\t}\n\t\tif (mobile[id][3] != 0) {\n\t\t\tri = f(mobile[id][3] - 1);\n\t\t}\n\t\t\n\t\tlong kle = 1;\n\t\tlong kri = 1;\n\t\twhile (true) {\n\t\t\tif (le * kle * mobile[id][0] == ri * kri * mobile[id][1]) {\n\t\t\t\tbreak;\n\t\t\t} else if (le * kle * mobile[id][0] < ri * kri * mobile[id][1]) {\n\t\t\t\tkle++;\n\t\t\t} else {\n\t\t\t\tkri++;\n\t\t\t}\n\t\t}\n\n\t\treturn weight[id] = le * kle + ri * kri;\n\t}\n\n\tpublic static int gcd(int x, int y) {\n\t\tif (x < y) {\n\t\t\tint swap = x;\n\t\t\tx = y;\n\t\t\ty  =swap;\n\t\t}\n\t\tif (y == 0) {\n\t\t\treturn x;\n\t\t}\n\n\t\treturn gcd(y, x % y);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tn = sc.nextInt();\n\t\tmobile = new int[n][4];\n\t\tweight = new long[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint p = sc.nextInt();\n\t\t\tint q = sc.nextInt();\n\t\t\tint r = sc.nextInt();\n\t\t\tint s = sc.nextInt();\n\t\t\tint gcd = gcd(p, q);\n\t\t\tmobile[i][0] = p / gcd;\n\t\t\tmobile[i][1] = q / gcd;\n\t\t\tmobile[i][2] = r;\n\t\t\tmobile[i][3] = s;\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tf(i);\n\t\t}\n\n\t\tArrays.sort(weight);\n\t\tSystem.out.println(weight[n - 1]);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.File;\nimport java.io.FileNotFoundException;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\n\t\tScanner scan = new Scanner(System.in);\n\t\t// Scanner scan = new Scanner(new File(\"c:\\\\0520-input.txt\"));\n\n\t\twhile (scan.hasNext()) {\n\t\t\tint n = scan.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\n\t\t\tMobile mobile = new Mobile(n);\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tmobile.add(i + 1, scan.nextInt(), scan.nextInt(), scan.nextInt(), scan.nextInt());\n\t\t\t// mobile.print();\n\t\t\tSystem.out.println(mobile.getWeight(mobile.getTop()));\n\t\t}\n\n\t\tscan.close();\n\t\tSystem.exit(0);\n\t}\n\n}\n\nclass Mobile {\n\tclass Bar {\n\t\tpublic Bar(int _p, int _q, int _r, int _b) {\n\t\t\tp = _p;\n\t\t\tq = _q;\n\t\t\tr = _r;\n\t\t\tb = _b;\n\t\t}\n\n\t\tint p, q;\n\t\tint r, b;\n\t}\n\n\tBar[] bar;\n\n\tpublic Mobile(int n) {\n\t\tbar = new Bar[n + 1];\n\t}\n\n\tpublic long getWeight(int me) {\n\t\tif (me == 0)\n\t\t\treturn 1;\n\t\tlong m = this.lcm(bar[me].p * this.getWeight(bar[me].r), bar[me].q * this.getWeight(bar[me].b));\n\t\treturn (m / bar[me].p + m / bar[me].q);\n\t}\n\n\tpublic int getTop() {\n\t\treturn (this.top(1));\n\t}\n\n\tprivate int top(int c) {\n\t\tint p = getParent(c);\n\t\tif (p == -1)\n\t\t\treturn (c);\n\t\telse\n\t\t\treturn (this.top(p));\n\t}\n\n\tprivate int getParent(int c) {\n\t\tfor (int i = 1; i < bar.length; i++)\n\t\t\tif (bar[i].r == c || bar[i].b == c)\n\t\t\t\treturn i;\n\t\treturn (-1);\n\t}\n\n\tpublic void print() {\n\t\tfor (int i = 1; i < bar.length; i++)\n\t\t\tSystem.out.println(i + \":\" + bar[i].p + \" \" + bar[i].q + \" \" + bar[i].r + \" \" + bar[i].b);\n\n\t}\n\n\tpublic void add(int i, int p, int q, int r, int b) {\n\t\tint g = (int) this.gcd(p, q);\n\t\tbar[i] = new Bar((p / g), (q / g), r, b);\n\t}\n\n\tprivate long gcd(long a, long b) {\n\t\twhile (true) {\n\t\t\tif (a > b) {\n\t\t\t\tlong tmp = a;\n\t\t\t\ta = b;\n\t\t\t\tb = tmp;\n\t\t\t}\n\n\t\t\tlong r = b % a;\n\t\t\tif (r == 0)\n\t\t\t\treturn (a);\n\t\t\telse if (r == 1)\n\t\t\t\treturn 1;\n\t\t\telse\n\t\t\t\tb = r;\n\t\t}\n\t}\n\n\tprivate long lcm(long a, long b) {\n\t\treturn (a * b / gcd(a, b));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n\npublic class Main{\n\nstatic PrintWriter out;\nstatic InputReader ir;\nstatic int[] p=new int[101],q=new int[101],r=new int[101],b=new int[101],par=new int[101];\n\nstatic void solve(){\n int n;\n while((n=ir.nextInt())!=0){\n  for(int i=0;i<n;i++){\n   p[i]=ir.nextInt();\n   q[i]=ir.nextInt();\n   r[i]=ir.nextInt();\n   b[i]=ir.nextInt();\n   par[r[i]]=par[b[i]]=i+1;\n   int g=gcd(p[i],q[i]);\n   p[i]/=g;\n   q[i]/=g;\n  }\n  int now=1;\n  while(par[now]!=0) now=par[now];\n  out.println(dfs(now));\n  Arrays.fill(par,0);\n }\n}\n\npublic static int dfs(int m){\n int now=m-1;\n if(r[now]==0&&b[now]==0) return p[now]+q[now];\n if(r[now]==0){\n  int bb=dfs(b[now]);\n  return bb*q[now]/gcd(q[now],bb)*(p[now]+q[now]);\n }\n if(b[now]==0){\n  int rr=dfs(r[now]);\n  return rr*p[now]/gcd(p[now],rr)*(p[now]+q[now]);\n }\n int bb=dfs(b[now]),rr=dfs(r[now]);\n int g=gcd(bb*p[now],rr*q[now]);\n return rr*q[now]/g*bb+bb*p[now]/g*rr;\n}\n\npublic static int gcd(int a,int b){\n if(b==0) return a;\n return gcd(b,a%b);\n}\n\npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n\nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n\n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n\n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n \n public boolean hasNext(){skip(); return hasNextByte();}\n \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n\n public double nextDouble(){return Double.parseDouble(next());}\n\n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n\n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n\n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n\npublic class Main{\n\nstatic PrintWriter out;\nstatic InputReader ir;\nstatic int[] p=new int[101],q=new int[101],r=new int[101],b=new int[101],par=new int[101];\n\nstatic void solve(){\n int n;\n while(true){\n  n=ir.nextInt();\n  if(n==0) break;\n  for(int i=0;i<n;i++){\n   p[i+1]=ir.nextInt();\n   q[i+1]=ir.nextInt();\n   r[i+1]=ir.nextInt();\n   b[i+1]=ir.nextInt();\n   par[r[i+1]]=par[b[i+1]]=i+1;\n   long g=gcd(p[i+1],q[i+1]);\n   p[i+1]/=(int)g;\n   q[i+1]/=(int)g;\n  }\n  int now;\n  now=1;\n  while(par[now]!=0) now=par[now];\n  out.println(dfs(now));\n  Arrays.fill(par,0);\n }\n}\n\npublic static long dfs(int now){\n if(r[now]==0&&b[now]==0) return (long)p[now]+(long)q[now];\n if(r[now]==0){\n  long bb=dfs(b[now]);\n  return bb/gcd(p[now],bb)*(p[now]+q[now]);\n }\n if(b[now]==0){\n  long rr=dfs(r[now]);\n  return rr/gcd(q[now],rr)*(p[now]+q[now]);\n }\n long bb=dfs(b[now]),rr=dfs(r[now]);\n long g=gcd(bb*p[now],rr*q[now]);\n return rr*(long)q[now]/g*bb+bb*(long)p[now]/g*rr;\n}\n\npublic static long gcd(long a,long b){\n if(b==0) return a;\n return gcd(b,a%b);\n}\n\npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n\nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n\n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n\n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n \n public boolean hasNext(){skip(); return hasNextByte();}\n \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n\n public double nextDouble(){return Double.parseDouble(next());}\n\n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n\n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n\n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Lightest Mobile\npublic class Main{\n\n\tstatic long gcd(long a, long b){\n\t\tif(a < b){\n\t\t\tlong tmp = a;\n\t\t\ta = b;\n\t\t\tb = tmp;\n\t\t}\n\t\twhile(b!=0){\n\t\t\tlong r = a%b;\n\t\t\ta = b;\n\t\t\tb = r;\n\t\t}\n\t\treturn a;\n\t}\n\n\tclass R{\n\t\tlong p, q;\n\t\tR l, r, parent;\n\t\tlong get;\n\t\tpublic R() {\n\t\t\tget = -1;\n\t\t\tl = r = parent = null;\n\t\t}\n\t\tlong solve(){\n\t\t\tlong val = get();\n\t\t\tlong x = val;\n\t\t\twhile(true){\n\t\t\t\tlong s = x/(p+q);\n\t\t\t\tif(l.f(s*q)&&r.f(s*p))break;\n\t\t\t\tx+=val;\n\t\t\t}\n\t\t\treturn x;\n\t\t}\n\t\tlong get(){\n\t\t\tif(get!=-1)return get;\n\t\t\tif(p==0)return 1;\n\t\t\tlong lg = l.get();\n\t\t\tlong rg = r.get();\n\t\t\tlong g = gcd(lg, rg);\n\t\t\tlong rate = lg/g*rg;\n\t\t\tlong s = p+q;\n\t\t\tg = gcd(s,rate);\n\t\t\treturn get = s/g*rate;\n\t\t}\n\t\tboolean f(long x){\n\t\t\tif(p==0)return true;\n\t\t\tif(x%(p+q)!=0)return false;\n\t\t\tlong s = x/(p+q);\n\t\t\treturn l.f(s*q)&&r.f(s*p);\n\t\t}\n\t}\n\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tR[] s = new R[n+1];\n\t\t\tfor(int i=0;i<=n;i++)s[i]=new R();\n\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\ts[i].p = sc.nextLong();\n\t\t\t\ts[i].q = sc.nextLong();\n\t\t\t\tlong g = gcd(s[i].p, s[i].q);\n\t\t\t\ts[i].p/=g;\n\t\t\t\ts[i].q/=g;\n\t\t\t\tint l = sc.nextInt();\n\t\t\t\tint r = sc.nextInt();\n\t\t\t\ts[i].l = s[l];\n\t\t\t\ts[i].r = s[r];\n\t\t\t\ts[l].parent = s[i];\n\t\t\t\ts[r].parent = s[i];\n\t\t\t}\n\t\t\tR root = null;\n\t\t\tfor(int i=1;i<=n;i++)if(s[i].parent==null)root = s[i];\n\t\t\tSystem.out.println(root.solve());\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n \npublic class Main{\n \nstatic PrintWriter out;\nstatic InputReader ir;\nstatic int[] p=new int[101],q=new int[101],r=new int[101],b=new int[101],par=new int[101];\n \nstatic void solve(){\n int n;\n while((n=ir.nextInt())!=0){\n  for(int i=0;i<n;i++){\n   p[i]=ir.nextInt();\n   q[i]=ir.nextInt();\n   r[i]=ir.nextInt();\n   b[i]=ir.nextInt();\n   par[r[i]]=par[b[i]]=i+1;\n   long g=gcd(p[i],q[i]);\n   p[i]/=(int)g;\n   q[i]/=(int)g;\n  }\n  int pp=-1;\n  for(int i=1;i<=n;i++) if(par[i]==0) pp=i;\n  out.println(dfs(pp));\n  Arrays.fill(par,0);\n }\n}\n \npublic static long dfs(int m){\n int now=m-1;\n if(r[now]==0&&b[now]==0) return (long)p[now]+(long)q[now];\n if(r[now]==0){\n  long bb=dfs(b[now]);\n  return bb/gcd(q[now],bb)*(p[now]+q[now]);\n }\n if(b[now]==0){\n  long rr=dfs(r[now]);\n  return rr/gcd(p[now],rr)*(p[now]+q[now]);\n }\n long bb=dfs(b[now]),rr=dfs(r[now]);\n long g=gcd(bb*p[now],rr*q[now]);\n return rr*(long)q[now]/g*bb+bb*(long)p[now]/g*rr;\n}\n \npublic static long gcd(long a,long b){\n if(b==0) return a;\n return gcd(b,a%b);\n}\n \npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n \nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n \n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n  \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n \n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n  \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n  \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n  \n public boolean hasNext(){skip(); return hasNextByte();}\n  \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n  \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n  \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public double nextDouble(){return Double.parseDouble(next());}\n \n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n \n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n \n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n\npublic class Main{\n\nstatic PrintWriter out;\nstatic InputReader ir;\nstatic int[] p=new int[101],q=new int[101],r=new int[101],b=new int[101],par=new int[101];\n\nstatic void solve(){\n int n;\n while((n=ir.nextInt())!=0){\n  for(int i=0;i<n;i++){\n   p[i]=ir.nextInt();\n   q[i]=ir.nextInt();\n   r[i]=ir.nextInt();\n   b[i]=ir.nextInt();\n   par[r[i]]=par[b[i]]=i+1;\n   long g=gcd(p[i],q[i]);\n   p[i]/=(int)g;\n   q[i]/=(int)g;\n  }\n  int now=1;\n  while(par[now]!=0) now=par[now];\n  out.println(dfs(now));\n  Arrays.fill(par,0);\n }\n}\n\npublic static long dfs(int m){\n int now=m-1;\n if(r[now]==0&&b[now]==0) return (long)p[now]+(long)q[now];\n if(r[now]==0){\n  long bb=dfs(b[now]);\n  return bb/gcd(q[now],bb)*(p[now]+q[now]);\n }\n if(b[now]==0){\n  long rr=dfs(r[now]);\n  return rr/gcd(p[now],rr)*(p[now]+q[now]);\n }\n long bb=dfs(b[now]),rr=dfs(r[now]);\n long g=gcd(bb*p[now],rr*q[now]);\n return rr*(long)q[now]/g*bb+bb*(long)p[now]/g*rr;\n}\n\npublic static long gcd(long a,long b){\n if(b==0) return a;\n return gcd(b,a%b);\n}\n\npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n\nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n\n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n\n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n \n public boolean hasNext(){skip(); return hasNextByte();}\n \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n\n public double nextDouble(){return Double.parseDouble(next());}\n\n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n\n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n\n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int mobile[][];\n\tstatic int n;\n\tstatic int weight[];\n\n\tpublic static int f(int id) {\n\t\tif (0 < weight[id]) {\n\t\t\treturn weight[id];\n\t\t}\n\n\t\tint le = 1;\n\t\tint ri = 1;\n\t\tif (mobile[id][2] != 0) {\n\t\t\tle = f(mobile[id][2] - 1);\n\t\t}\n\t\tif (mobile[id][3] != 0) {\n\t\t\tri = f(mobile[id][3] - 1);\n\t\t}\n\t\tle *= mobile[id][1];\n\t\tri *= mobile[id][0];\n\t\t\n\t\tint kle = 1;\n\t\tint kri = 1;\n\t\twhile (true) {\n\t\t\tif (le * kle * mobile[id][0] == ri * kri * mobile[id][1]) {\n\t\t\t\tbreak;\n\t\t\t} else if (le * kle * mobile[id][0] < ri * kri * mobile[id][1]) {\n\t\t\t\tkle++;\n\t\t\t} else {\n\t\t\t\tkri++;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn weight[id] = le * kle + ri * kri;\n\t}\n\n\tpublic static int gcd(int x, int y) {\n\t\tif (x < y) {\n\t\t\tint swap = x;\n\t\t\tx = y;\n\t\t\ty  =swap;\n\t\t}\n\t\tif (y == 0) {\n\t\t\treturn x;\n\t\t}\n\n\t\treturn gcd(y, x % y);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tn = sc.nextInt();\n\t\tmobile = new int[n][4];\n\t\tweight = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\tmobile[i][j] = sc.nextInt();\n\t\t\t}\n\t\t\tint gcd = gcd(mobile[i][0], mobile[i][1]);\n\t\t\tmobile[i][0] /= gcd;\n\t\t\tmobile[i][1] /= gcd;\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tf(i);\n\t\t}\n\t\t\n\t\tArrays.sort(weight);\n\t\tSystem.out.println(weight[n - 1]);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n\npublic class Main{\n\nstatic PrintWriter out;\nstatic InputReader ir;\nstatic int[] p=new int[101],q=new int[101],r=new int[101],b=new int[101],par=new int[101];\n\nstatic void solve(){\n int n;\n while((n=ir.nextInt())!=0){\n  for(int i=0;i<n;i++){\n   p[i]=ir.nextInt();\n   q[i]=ir.nextInt();\n   r[i]=ir.nextInt();\n   b[i]=ir.nextInt();\n   par[r[i]]=par[b[i]]=i+1;\n   int g=gcd(p[i],q[i]);\n   p[i]/=g;\n   q[i]/=g;\n  }\n  int now=1;\n  while(par[now]!=0) now=par[now];\n  out.println(dfs(now));\n  Arrays.fill(par,0);\n }\n}\n\npublic static int dfs(int m){\n int now=m-1;\n if(r[now]==0&&b[now]==0) return p[now]+q[now];\n if(r[now]==0){\n  int bb=dfs(b[now]);\n  return bb/gcd(q[now],bb)*(p[now]+q[now]);\n }\n if(b[now]==0){\n  int rr=dfs(r[now]);\n  return rr/gcd(p[now],rr)*(p[now]+q[now]);\n }\n int bb=dfs(b[now]),rr=dfs(r[now]);\n int g=gcd(bb*p[now],rr*q[now]);\n return rr*q[now]/g*bb+bb*p[now]/g*rr;\n}\n\npublic static int gcd(int a,int b){\n if(b==0) return a;\n return gcd(b,a%b);\n}\n\npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n\nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n\n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n\n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n \n public boolean hasNext(){skip(); return hasNextByte();}\n \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n\n public double nextDouble(){return Double.parseDouble(next());}\n\n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n\n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n\n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n\npublic class Main{\n\nstatic PrintWriter out;\nstatic InputReader ir;\nstatic int[] p=new int[101],q=new int[101],r=new int[101],b=new int[101],par=new int[101];\nstatic boolean[] done =new boolean[101];\n\nstatic void solve(){\n int n;\n while(true){\n  n=ir.nextInt();\n  if(n==0) break;\n  for(int i=0;i<n;i++){\n   p[i]=ir.nextInt();\n   q[i]=ir.nextInt();\n   r[i]=ir.nextInt();\n   b[i]=ir.nextInt();\n   par[r[i]]=par[b[i]]=i+1;\n   long g=gcd(p[i],q[i]);\n   p[i]/=(int)g;\n   q[i]/=(int)g;\n  }\n  int now;\n  long ans=0;\n  for(int i=0;i<n;i++){\n   if(done[i]) continue;\n   now=i+1;\n   while(par[now]!=0) now=par[now];\n   ans+=dfs(now);\n  }\n  out.println(ans);\n  Arrays.fill(par,0);\n  Arrays.fill(done,false);\n }\n}\n\npublic static long dfs(int m){\n int now=m-1;\n done[now]=true;\n if(r[now]==0&&b[now]==0) return (long)p[now]+(long)q[now];\n if(r[now]==0){\n  long bb=dfs(b[now]);\n  return bb/gcd(q[now],bb)*(p[now]+q[now]);\n }\n if(b[now]==0){\n  long rr=dfs(r[now]);\n  return rr/gcd(p[now],rr)*(p[now]+q[now]);\n }\n long bb=dfs(b[now]),rr=dfs(r[now]);\n long g=gcd(bb*p[now],rr*q[now]);\n return rr*(long)q[now]/g*bb+bb*(long)p[now]/g*rr;\n}\n\npublic static long gcd(long a,long b){\n if(b==0) return a;\n return gcd(b,a%b);\n}\n\npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n\nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n\n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n\n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n \n public boolean hasNext(){skip(); return hasNextByte();}\n \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n\n public double nextDouble(){return Double.parseDouble(next());}\n\n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n\n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n\n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.File;\nimport java.io.FileNotFoundException;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\n\t\tScanner scan = new Scanner(System.in);\n\t\t// Scanner scan = new Scanner(new File(\"c:\\\\0519-in7.txt\"));\n\n\t\twhile (scan.hasNext()) {\n\t\t\tint n = scan.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\n\t\t\tMobile mobile = new Mobile(n);\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tmobile.add(i + 1, scan.nextInt(), scan.nextInt(), scan.nextInt(), scan.nextInt());\n\t\t\t// mobile.print();\n\t\t\tSystem.out.println(mobile.getWeight(mobile.getTop()));\n\t\t}\n\n\t\tscan.close();\n\t\tSystem.exit(0);\n\t}\n\n}\n\nclass Mobile {\n\tclass Bar {\n\t\tpublic Bar(int _p, int _q, int _r, int _b) {\n\t\t\tp = _p;\n\t\t\tq = _q;\n\t\t\tr = _r;\n\t\t\tb = _b;\n\t\t}\n\n\t\tint p, q;\n\t\tint r, b;\n\t}\n\n\tBar[] bar;\n\n\tpublic Mobile(int n) {\n\t\tbar = new Bar[n + 1];\n\t}\n\n\tpublic int getWeight(int me) {\n\t\tif (me == 0)\n\t\t\treturn 1;\n\t\tint m = this.lcm(bar[me].q * this.getWeight(bar[me].r), bar[me].p * this.getWeight(bar[me].b));\n\t\treturn (m / bar[me].p + m / bar[me].q);\n\t}\n\n\tpublic int getTop() {\n\t\treturn (this.top(1));\n\t}\n\n\tprivate int top(int c) {\n\t\tint p = getParent(c);\n\t\tif (p == -1)\n\t\t\treturn (c);\n\t\telse\n\t\t\treturn (this.top(p));\n\t}\n\n\tprivate int getParent(int c) {\n\t\tfor (int i = 1; i < bar.length; i++)\n\t\t\tif (bar[i].r == c || bar[i].b == c)\n\t\t\t\treturn i;\n\t\treturn (-1);\n\t}\n\n\tpublic void print() {\n\t\tfor (int i = 1; i < bar.length; i++)\n\t\t\tSystem.out.println(i + \":\" + bar[i].p + \" \" + bar[i].q + \" \" + bar[i].r + \" \" + bar[i].b);\n\n\t}\n\n\tpublic void add(int i, int p, int q, int r, int b) {\n\t\tint g = this.gcd(p, q);\n\t\tbar[i] = new Bar(p / g, q / g, r, b);\n\t}\n\n\tprivate int gcd(int a, int b) {\n\t\tif (a > b) {\n\t\t\tint tmp = a;\n\t\t\ta = b;\n\t\t\tb = tmp;\n\t\t}\n\t\tint r = b % a;\n\t\tif (r == 0)\n\t\t\treturn (a);\n\t\telse if (r == 1)\n\t\t\treturn 1;\n\t\telse\n\t\t\treturn this.gcd(r, a);\n\t}\n\n\tprivate int lcm(int a, int b) {\n\t\treturn (a * b / gcd(a, b));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.StringTokenizer;\n\n/**\n * Lightest Mobile\n */\npublic class Main {\n\n\tstatic Main main = new Main();\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line = \"\";\n\n\t\tMobile mobile = null;\n\t\twhile (!(line = br.readLine()).equals(\"0\")) {\n\t\t\tint n = Integer.parseInt(line);\n\n\t\t\tmobile = main.new Mobile();\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tmobile.add(i, br.readLine());\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(mobile.calc());\n\t}\n\n\tclass Mobile {\n\t\tArrayList<Bar> mobile = new ArrayList<Bar>();\n\n\t\t// 指定 id の棒をモービルに追加\n\t\tvoid add(int id, String info) {\n\t\t\tHangableImpr parent, left, right;\n\t\t\tint lid, rid;\n\t\t\tint rateL, rateR;\n\n\t\t\tStringTokenizer st = new StringTokenizer(info);\n\t\t\trateL = Integer.parseInt(st.nextToken());\n\t\t\trateR = Integer.parseInt(st.nextToken());\n\n\t\t\t// 親の棒\n\t\t\tif ((parent = find(id)) == null) {\n\t\t\t\tparent = new Bar(id, null);\n\t\t\t}\n\t\t\t((Bar) parent).lengthL = rateL;\n\t\t\t((Bar) parent).lengthR = rateR;\n\n\t\t\tlid = Integer.parseInt(st.nextToken());\n\t\t\trid = Integer.parseInt(st.nextToken());\n\n\t\t\t// 左の棒\n\t\t\tif (lid == 0) {\n\t\t\t\tleft = new Spindle();\n\t\t\t\tleft.parent = parent;\n\t\t\t} else {\n\t\t\t\tif ((left = find(lid)) == null) {\n\t\t\t\t\tleft = new Bar(lid, (Bar) parent);\n\t\t\t\t} else {\n\t\t\t\t\t((Bar) left).parent = (Bar) parent;\n\t\t\t\t\tmobile.remove(left);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// 右の棒\n\t\t\tif (rid == 0) {\n\t\t\t\tright = new Spindle();\n\t\t\t\tright.parent = parent;\n\t\t\t} else {\n\t\t\t\tif ((right = find(rid)) == null) {\n\t\t\t\t\tright = new Bar(rid, (Bar) parent);\n\t\t\t\t} else {\n\t\t\t\t\t((Bar) right).parent = (Bar) parent;\n\t\t\t\t\tmobile.remove(right);\n\t\t\t\t}\n\t\t\t}\n\t\t\t((Bar) parent).left = left;\n\t\t\t((Bar) parent).right = right;\n\t\t\tif (((Bar) parent).parent == null) {\n\t\t\t\tmobile.add((Bar) parent);\n\t\t\t}\n\t\t}\n\n\t\t// 指定 id の棒を検索\n\t\tBar find(int id) {\n\t\t\tBar result = null;\n\t\t\tfor (Bar b : mobile) {\n\t\t\t\tresult = b.find(id);\n\t\t\t\tif (result != null)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tint calc() {\n\t\t\tint result = 0;\n\t\t\tfor (Bar b : mobile) {\n\t\t\t\tb.calc();\n\t\t\t\tresult = b.weight;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t//\n\tinterface Hangable {\n\t\tHangable find(int id);\n\t}\n\n\tabstract class HangableImpr implements Hangable {\n\t\tHangableImpr parent;\n\t\tint weight = 0;\n\t}\n\n\tclass Spindle extends HangableImpr {\n\t\t// int weight = 0;\n\t\t// Bar parent;\n\n\t\tSpindle() {\n\t\t\tthis.weight = 0;\n\t\t}\n\n\t\tSpindle(int weight) {\n\t\t\tthis.weight = weight;\n\t\t}\n\n\t\tpublic Spindle find(int id) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tclass Bar extends HangableImpr {\n\t\tint id;\n\t\tint lengthL, lengthR;\n\t\t// Bar parent;\n\t\tHangableImpr parent, left, right;\n\n\t\tBar(int id, Bar parent) {\n\t\t\tthis.id = id;\n\t\t\tthis.parent = parent;\n\t\t}\n\n\t\tpublic Bar find(int id) {\n\t\t\tBar result = null;\n\t\t\tif (this.id == id)\n\t\t\t\tresult = this;\n\t\t\tif (result == null && left != null)\n\t\t\t\tresult = (Bar) left.find(id);\n\t\t\tif (result == null && right != null)\n\t\t\t\tresult = (Bar) right.find(id);\n\t\t\treturn result;\n\t\t}\n\n\t\tvoid calc() {\n\t\t\tif (left instanceof Bar) {\n\t\t\t\t((Bar) left).calc();\n\t\t\t}\n\t\t\tif (right instanceof Bar) {\n\t\t\t\t((Bar) right).calc();\n\t\t\t}\n\n\t\t\tint gcd = gcd(lengthL, lengthR);\n\t\t\tint tempL, tempR;\n\t\t\tint weightL, weightR;\n\t\t\ttempL = lengthL / gcd;\n\t\t\ttempR = lengthR / gcd;\n\t\t\tweightL = left.weight;\n\t\t\tweightR = right.weight;\n\n\t\t\tif (weightL == 0 && weightR == 0) {\n\t\t\t\tleft.weight = tempR;\n\t\t\t\tright.weight = tempL;\n\t\t\t} else if (weightL != 0 && weightR == 0) {\n\t\t\t\tint lcm = lcm(tempR, lcm(tempL, weightL));\n\t\t\t\tright.weight = lcm / tempL;\n\t\t\t} else if (weightL == 0 && weightR != 0) {\n\t\t\t\tint lcm = lcm(tempL, lcm(tempR, weightR));\n\t\t\t\tleft.weight = lcm / tempR;\n\t\t\t} else {\n\t\t\t\tint lcm = lcm(lcm(tempL, weightL), lcm(tempR, weightR));\n\t\t\t\tleft.weight = lcm / tempR;\n\t\t\t\tright.weight = lcm / tempL;\n\t\t\t}\n\t\t\tweight = left.weight + right.weight;\n\t\t}\n\t}\n\n\t// 最大公約数\n\tstatic int lcm(int l, int r) {\n\t\treturn l * r / gcd(l, r);\n\t}\n\n\tstatic int lcm(int l, int r, int gcd) {\n\t\treturn l * r / gcd;\n\t}\n\n\t// 最小公倍数\n\tstatic int gcd(int l, int r) {\n\t\tint mod;\n\t\tint gt = l > r ? l : r;\n\t\tint lt = l < r ? l : r;\n\n\t\tdo {\n\t\t\tmod = gt % lt;\n\t\t\tgt = lt;\n\t\t\tlt = mod;\n\t\t} while (mod != 0);\n\n\t\treturn gt;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.math.*;\npublic class Main{\n\n\tstatic int INF = 2 << 27;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tint a[] = new int[n];\n\t\t\tint b[] = new int[n];\n\t\t\tint c[] = new int[n];\n\t\t\tint d[] = new int[n];\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\ta[i] = sc.nextInt();\n\t\t\t\tb[i] = sc.nextInt();\n\t\t\t\tc[i] = sc.nextInt()-1;\n\t\t\t\td[i] = sc.nextInt()-1;\n\t\t\t}\n\t\t\tData[] data = new Data[n];\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tdata[i] = new Data(a[i],b[i],c[i],d[i]);\n\t\t\t}\n\t\t\tint  start = 0;\n\t\t\tboolean[] use = new boolean[n];\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tif(data[i].nextDataA != -1)\n\t\t\t\tuse[data[i].nextDataA] = true;\n\t\t\t\tif(data[i].nextDataB != -1)\n\t\t\t\tuse[data[i].nextDataB] = true;\n\t\t\t}\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tif(!use[i]) {\n\t\t\t\t\tstart = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans = DFS(start,data);\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\tstatic int DFS(int now, Data[] data) {\n\t\tint ACost = data[now].nextDataA == -1 ?1:DFS(data[now].nextDataA,data);\n\t\tint BCost = data[now].nextDataB == -1 ?1:DFS(data[now].nextDataB,data);\n\t\tint l = lcm(data[now].lenA * ACost, data[now].lenB * BCost);\n\t\treturn l / data[now].lenA + l / data[now].lenB;\n\t}\n\tstatic class Data {\n\t\tint lenA;\n\t\tint lenB;\n\t\tint nextDataA;\n\t\tint nextDataB;\n\t\tData(int a, int b, int c, int d) {\n\t\t\tlenA = a;\n\t\t\tlenB = b;\n\t\t\tnextDataA = c;\n\t\t\tnextDataB = d;\n\t\t}\n\t}\n\tstatic int gcd(int a, int b) {\n\t\tif(b == 0) return a;\n\t\tif(a < b) return gcd(b,a);\n\t\treturn gcd(b,a % b);\n\t\t\n\t}\n\tstatic int lcm(int a,int b){\n\t\t  return a / gcd(a,b) * b;\n\t\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n \npublic class Main{\n \nstatic PrintWriter out;\nstatic InputReader ir;\nstatic int[] p=new int[101],q=new int[101],r=new int[101],b=new int[101],par=new int[101];\n \nstatic void solve(){\n int n;\n while((n=ir.nextInt())!=0){\n  Arrays.fill(par,-1);\n  for(int i=1;i<=n;i++){\n   p[i]=ir.nextInt();\n   q[i]=ir.nextInt();\n   r[i]=ir.nextInt();\n   b[i]=ir.nextInt();\n   par[r[i]]=par[b[i]]=i;\n   long g=gcd(p[i],q[i]);\n   p[i]/=(int)g;\n   q[i]/=(int)g;\n  }\n  int pp=-1;\n  for(int i=1;i<=n;i++) if(par[i]==-1) pp=i;\n  out.println(dfs(pp));\n }\n}\n \npublic static long dfs(int now){\n if(r[now]==0&&b[now]==0) return (long)p[now]+(long)q[now];\n if(r[now]==0){\n  long bb=dfs(b[now]);\n  return bb/gcd(p[now],bb)*(p[now]+q[now]);\n }\n if(b[now]==0){\n  long rr=dfs(r[now]);\n  return rr/gcd(q[now],rr)*(p[now]+q[now]);\n }\n long bb=dfs(b[now]),rr=dfs(r[now]);\n long l=lcm(bb*q[now],rr*p[now]);\n return l/p[now]+l/q[now];\n}\n \npublic static long gcd(long a,long b){\n if(b==0) return a;\n return gcd(b,a%b);\n}\n\npublic static long lcm(long a,long b){\n return a*b/gcd(a,b);\n}\n \npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n \nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n \n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n  \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n \n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n  \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n  \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n  \n public boolean hasNext(){skip(); return hasNextByte();}\n  \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n  \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n  \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public double nextDouble(){return Double.parseDouble(next());}\n \n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n \n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n \n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main{\n\n\tint INF = 1 << 28;\n\tint n;\n\tint map[][];\n\tint w[];\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tn = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tmap =  new int[n][4];\n\t\t\tfor(int i=0;i<n;i++) for(int j=0;j<4;j++){\n\t\t\t\tmap[i][j] = sc.nextInt();\n\t\t\t}\n\t\t\tw = new int[n+1];\n\t\t\tfill(w, -1);\n\t\t\tint max = 0;\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tmax = max(max, solve(i) );\n\t\t\t}\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n\t\n\tint solve(int i) {\n//\t\tdebug(i);\n\t\tif( w[i] >= 0 ) return w[i];\n\t\tint l = map[i][2] != 0? solve(map[i][2]-1): 1;\n\t\tint r = map[i][3] != 0? solve(map[i][3]-1): 1;\n\t\tint wait = 0;\n\t\twait = lcm(l * map[i][0], r * map[i][1]);\n//\t\tdebug(l, r, l*map[i][0], r*map[i][1], wait);\n\t\twait = wait / map[i][0] + wait / map[i][1];\n\t\treturn w[i] = wait;\n\t\t\n\t}\n\t\n\tint lcm(int x, int y) {\n\t\tint x_ = x;\n\t\tint y_ = y;\n\t\tint z = x_ % y_;\n\t\twhile(z != 0) {\n\t\t\tx_ = y_;\n\t\t\ty_ = z;\n\t\t\tz = x_ % y_;\n\t\t}\n\t\treturn x * y / y_;\n\t\t\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.StringTokenizer;\n\n/**\n * Lightest Mobile\n */\npublic class Main {\n\n\tstatic Main main = new Main();\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line = \"\";\n\n\t\tMobile mobile = null;\n\t\twhile (!(line = br.readLine()).equals(\"0\")) {\n\t\t\tint n = Integer.parseInt(line);\n\n\t\t\tmobile = main.new Mobile();\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tmobile.add(i, br.readLine());\n\t\t\t}\n\t\t\tlong result = mobile.calc();\n\t\t\tSystem.err.println(result);\n\t\t\tSystem.out.println(result);\n\t\t}\n\t}\n\n\tclass Mobile {\n\t\tArrayList<Bar> mobile = new ArrayList<Bar>();\n\n\t\t// 棒をモービルに追加\n\t\tvoid add(int id, String info) {\n\t\t\tHangableImpr parent, left, right;\n\t\t\tint lid, rid;\n\t\t\tint lengthL, lengthR;\n\n\t\t\tStringTokenizer st = new StringTokenizer(info);\n\t\t\tlengthL = Integer.parseInt(st.nextToken());\n\t\t\tlengthR = Integer.parseInt(st.nextToken());\n\n\t\t\t// 親の棒\n\t\t\tif ((parent = find(id)) == null) {\n\t\t\t\tparent = new Bar(id, null);\n\t\t\t}\n\t\t\t((Bar) parent).lengthL = lengthL;\n\t\t\t((Bar) parent).lengthR = lengthR;\n\n\t\t\tlid = Integer.parseInt(st.nextToken());\n\t\t\trid = Integer.parseInt(st.nextToken());\n\n\t\t\t// 左の棒\n\t\t\tif (lid == 0) {\n\t\t\t\tleft = new Spindle();\n\t\t\t\tleft.parent = parent;\n\t\t\t} else {\n\t\t\t\tif ((left = find(lid)) == null) {\n\t\t\t\t\tleft = new Bar(lid, (Bar) parent);\n\t\t\t\t} else {\n\t\t\t\t\t((Bar) left).parent = (Bar) parent;\n\t\t\t\t\tmobile.remove(left);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// 右の棒\n\t\t\tif (rid == 0) {\n\t\t\t\tright = new Spindle();\n\t\t\t\tright.parent = parent;\n\t\t\t} else {\n\t\t\t\tif ((right = find(rid)) == null) {\n\t\t\t\t\tright = new Bar(rid, (Bar) parent);\n\t\t\t\t} else {\n\t\t\t\t\t((Bar) right).parent = (Bar) parent;\n\t\t\t\t\tmobile.remove(right);\n\t\t\t\t}\n\t\t\t}\n\t\t\t((Bar) parent).left = left;\n\t\t\t((Bar) parent).right = right;\n\t\t\tif (((Bar) parent).parent == null) {\n\t\t\t\tmobile.add((Bar) parent);\n\t\t\t}\n\t\t}\n\n\t\t// 指定した id の棒を検索\n\t\tBar find(int id) {\n\t\t\tBar result = null;\n\t\t\tfor (Bar b : mobile) {\n\t\t\t\tresult = b.find(id);\n\t\t\t\tif (result != null)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tlong calc() {\n\t\t\tlong result = 0;\n\t\t\tfor (Bar b : mobile) {\n\t\t\t\tb.calc();\n\t\t\t\tresult = b.weight;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t//\n\tinterface Hangable {\n\t\tHangable find(int id);\n\t}\n\n\tabstract class HangableImpr implements Hangable {\n\t\tHangableImpr parent;\n\t\tlong weight = 0;\n\t}\n\n\tclass Spindle extends HangableImpr {\n\t\t// int weight = 0;\n\t\t// Bar parent;\n\n\t\tSpindle() {\n\t\t\tthis.weight = 0;\n\t\t}\n\n\t\tSpindle(int weight) {\n\t\t\tthis.weight = weight;\n\t\t}\n\n\t\tpublic Spindle find(int id) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tclass Bar extends HangableImpr {\n\t\tint id;\n\t\tint lengthL, lengthR;\n\t\t// Bar parent;\n\t\tHangableImpr parent, left, right;\n\n\t\tBar(int id, Bar parent) {\n\t\t\tthis.id = id;\n\t\t\tthis.parent = parent;\n\t\t}\n\n\t\tpublic Bar find(int id) {\n\t\t\tBar result = null;\n\t\t\tif (this.id == id)\n\t\t\t\tresult = this;\n\t\t\tif (result == null && left != null)\n\t\t\t\tresult = (Bar) left.find(id);\n\t\t\tif (result == null && right != null)\n\t\t\t\tresult = (Bar) right.find(id);\n\t\t\treturn result;\n\t\t}\n\n\t\tvoid calc() {\n\t\t\tif (left instanceof Bar) {\n\t\t\t\t((Bar) left).calc();\n\t\t\t}\n\t\t\tif (right instanceof Bar) {\n\t\t\t\t((Bar) right).calc();\n\t\t\t}\n\n\t\t\tlong gcd = gcd(lengthL, lengthR);\n\t\t\tlong tempL, tempR;\n\t\t\tlong weightL, weightR;\n\n\t\t\ttempL = lengthL / gcd;\n\t\t\ttempR = lengthR / gcd;\n\t\t\tweightL = left.weight;\n\t\t\tweightR = right.weight;\n\n\t\t\tif (weightL == 0 && weightR == 0) {\n\t\t\t\tleft.weight = tempR;\n\t\t\t\tright.weight = tempL;\n\t\t\t} else if (weightL != 0 && weightR == 0) {\n\t\t\t\tlong lcm = lcm(tempR, lcm(tempL, weightL));\n\t\t\t\tright.weight = lcm / tempL;\n\t\t\t} else if (weightL == 0 && weightR != 0) {\n\t\t\t\tlong lcm = lcm(tempL, lcm(tempR, weightR));\n\t\t\t\tleft.weight = lcm / tempR;\n\t\t\t} else {\n\t\t\t\tlong lcm = lcm(lcm(tempL, weightL), lcm(tempR, weightR));\n\t\t\t\tleft.weight = lcm / tempR;\n\t\t\t\tright.weight = lcm / tempL;\n\t\t\t}\n\t\t\tweight = left.weight + right.weight;\n\t\t}\n\t}\n\n\t// 最小公倍数\n\tstatic long lcm(long l, long r) {\n\t\tlong gt = l > r ? l : r;\n\t\tlong lt = l < r ? l : r;\n\t\treturn lt * (gt / gcd(l, r));\n\t}\n\n\tstatic long lcm(long l, long r, long gcd) {\n\t\tlong gt = l > r ? l : r;\n\t\tlong lt = l < r ? l : r;\n\t\treturn lt * (gt / gcd);\n\t}\n\n\t// 最大公約数\n\tstatic long gcd(long l, long r) {\n\t\tlong mod;\n\t\tlong gt = l > r ? l : r;\n\t\tlong lt = l < r ? l : r;\n\n\t\tdo {\n\t\t\tmod = gt % lt;\n\t\t\tgt = lt;\n\t\t\tlt = mod;\n\t\t} while (mod != 0);\n\n\t\treturn gt;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int mobile[][];\n\tstatic int n;\n\tstatic long weight[];\n\n\tpublic static long f(int id) {\n\t\tif (0 < weight[id]) {\n\t\t\treturn weight[id];\n\t\t}\n\n\t\tlong le = 1;\n\t\tlong ri = 1;\n\t\tif (mobile[id][2] != 0) {\n\t\t\tle = f(mobile[id][2] - 1);\n\t\t}\n\t\tif (mobile[id][3] != 0) {\n\t\t\tri = f(mobile[id][3] - 1);\n\t\t}\n\n\t\tlong kle = 1;\n\t\tlong kri = 1;\n\t\twhile (true) {\n\t\t\tif (le * kle * mobile[id][0] == ri * kri * mobile[id][1]) {\n\t\t\t\tbreak;\n\t\t\t} else if (le * kle * mobile[id][0] < ri * kri * mobile[id][1]) {\n\t\t\t\tkle++;\n\t\t\t} else {\n\t\t\t\tkri++;\n\t\t\t}\n\t\t}\n\n\t\treturn weight[id] = le * kle + ri * kri;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile (true) {\n\t\t\tn = sc.nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmobile = new int[n][4];\n\t\t\tweight = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmobile[i][0] = sc.nextInt();\n\t\t\t\tmobile[i][1] = sc.nextInt();\n\t\t\t\tmobile[i][2] = sc.nextInt();\n\t\t\t\tmobile[i][3] = sc.nextInt();\n\t\t\t}\n\t\t\tArrays.fill(weight, -1);\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tf(i);\n\t\t\t}\n\n\t\t\tArrays.sort(weight);\n\t\t\tSystem.out.println(weight[n - 1]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n \npublic class Main{\n \nstatic PrintWriter out;\nstatic InputReader ir;\nstatic int[] p=new int[101],q=new int[101],r=new int[101],b=new int[101],par=new int[101];\n \nstatic void solve(){\n int n;\n while((n=ir.nextInt())!=0){\n  Arrays.fill(par,-1);\n  for(int i=1;i<=n;i++){\n   p[i]=ir.nextInt();\n   q[i]=ir.nextInt();\n   r[i]=ir.nextInt();\n   b[i]=ir.nextInt();\n   par[r[i]]=par[b[i]]=i;\n   long g=gcd(p[i],q[i]);\n   p[i]/=(int)g;\n   q[i]/=(int)g;\n  }\n  int pp=-1;\n  for(int i=1;i<=n;i++) if(par[i]==-1) pp=i;\n  out.println(dfs(pp));\n }\n}\n \npublic static long dfs(int now){\n if(r[now]==0&&b[now]==0) return (long)p[now]+(long)q[now];\n if(r[now]==0){\n  long bb=dfs(b[now]);\n  return bb/gcd(q[now],bb)*(p[now]+q[now]);\n }\n if(b[now]==0){\n  long rr=dfs(r[now]);\n  return rr/gcd(p[now],rr)*(p[now]+q[now]);\n }\n long bb=dfs(b[now]),rr=dfs(r[now]);\n long l=lcm(bb*p[now],rr*q[now]);\n return l/p[now]+l/q[now];\n}\n \npublic static long gcd(long a,long b){\n if(b==0) return a;\n return gcd(b,a%b);\n}\n\npublic static long lcm(long a,long b){\n return a*b/gcd(a,b);\n}\n \npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n \nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n \n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n  \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n \n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n  \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n  \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n  \n public boolean hasNext(){skip(); return hasNextByte();}\n  \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n  \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n  \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public double nextDouble(){return Double.parseDouble(next());}\n \n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n \n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n \n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Lightest Mobile\npublic class Main{\n\n\tstatic long gcd(long a, long b){\n\t\tif(a < b){\n\t\t\tlong tmp = a;\n\t\t\ta = b;\n\t\t\tb = tmp;\n\t\t}\n\t\twhile(b!=0){\n\t\t\tlong r = a%b;\n\t\t\ta = b;\n\t\t\tb = r;\n\t\t}\n\t\treturn a;\n\t}\n\n\tclass R{\n\t\tlong p, q;\n\t\tR l, r, parent;\n\t\tlong get;\n\t\tpublic R() {\n\t\t\tget = -1;\n\t\t\tl = r = parent = null;\n\t\t}\n\t\tlong solve(){\n\t\t\tlong val = get();\n\t\t\tlong x = val;\n\t\t\twhile(true){\n\t\t\t\tlong s = x/(p+q);\n\t\t\t\tif(l.f(s*q)&&r.f(s*p))break;\n\t\t\t\tx+=val;\n\t\t\t}\n\t\t\treturn x;\n\t\t}\n\t\tlong get(){\n\t\t\tif(p==0)return 1;\n\t\t\tint k = 1;\n\t\t\tlong w1 = l.get();\n\t\t\tlong w2 = r.get();\n\t\t\twhile(true){\n\t\t\t\tif((k*q)%w1==0&&(k*p)%w2==0)break;\n\t\t\t\tk++;\n\t\t\t}\n\t\t\treturn k*(p+q);\n\t\t}\n\t\tboolean f(long x){\n\t\t\tif(p==0)return true;\n\t\t\tif(x%(p+q)!=0)return false;\n\t\t\tlong s = x/(p+q);\n\t\t\treturn l.f(s*q)&&r.f(s*p);\n\t\t}\n\t}\n\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tR[] s = new R[n+1];\n\t\t\tfor(int i=0;i<=n;i++)s[i]=new R();\n\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\ts[i].p = sc.nextLong();\n\t\t\t\ts[i].q = sc.nextLong();\n\t\t\t\tlong g = gcd(s[i].p, s[i].q);\n\t\t\t\ts[i].p/=g;\n\t\t\t\ts[i].q/=g;\n\t\t\t\tint l = sc.nextInt();\n\t\t\t\tint r = sc.nextInt();\n\t\t\t\ts[i].l = s[l];\n\t\t\t\ts[i].r = s[r];\n\t\t\t\ts[l].parent = s[i];\n\t\t\t\ts[r].parent = s[i];\n\t\t\t}\n\t\t\tR root = null;\n\t\t\tfor(int i=1;i<=n;i++)if(s[i].parent==null)root = s[i];\n\t\t\tSystem.out.println(root.get());\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\nclass Node {\n    public int p, q, r, b, parent;\n    Node(int p, int q, int r, int b) {\n        this.p = p;\n        this.q = q;\n        this.r = r;\n        this.b = b;\n        this.parent = -1;\n    }\n}\n\npublic class Main {\n    Scanner sc;\n    int n;\n    int root;\n    Node[] tree;\n\n    long gcd(long a, long b) {\n        if (a > b) {\n            long tmp = a;\n            a = b;\n            b = tmp;\n        }\n        if (a == 0) return b;\n        return gcd(b % a, a);\n    }\n\n    long lcm(long a, long b) {\n        return a / gcd(a, b) * b;\n    }\n\n    Main() {\n        sc = new Scanner(System.in);\n    }\n\n    long lightest(int index) {\n        int p = tree[index].p;\n        int q = tree[index].q;\n        int r = tree[index].r;\n        int b = tree[index].b;\n        if (r == -1 && b == -1) {\n            return (p + q) / gcd(p, q);\n        } else if (r == -1) {\n            long b_weight = lcm(lightest(b), p);\n            long r_weight = b_weight * q / p;\n            return r_weight + b_weight;\n        } else if (b == -1) {\n            long r_weight = lcm(lightest(r), q);\n            long b_weight = r_weight * p / q;\n            return r_weight + b_weight;\n        }\n        long r_weight = lcm(lightest(r), q);\n        long b_weight = lcm(lightest(b), p);\n        long lcm_rb = lcm(r_weight, b_weight);\n        r_weight = lcm_rb / p;\n        b_weight = lcm_rb / q;\n        return r_weight + b_weight;\n    }\n\n    boolean init() {\n        n = sc.nextInt();\n        if (n == 0) return false;\n\n        tree = new Node[n];\n        for (int i = 0; i < n; i++) {\n            int p = sc.nextInt();\n            int q = sc.nextInt();\n            int r = sc.nextInt();\n            int b = sc.nextInt();\n            long gcd_pq = gcd(p, q);\n            p /= gcd_pq;\n            q /= gcd_pq;\n            tree[i] = new Node(p, q, r-1, b-1);  // 0-originに\n        }\n\n        // 親を探す\n        for (int i = 0; i < n; i++) {\n            if (tree[i].r >= 0) tree[tree[i].r].parent = i;\n            if (tree[i].b >= 0) tree[tree[i].b].parent = i;\n        }\n\n        // rootを探す\n        for (int i = 0; i < n; i++) \n            if (tree[i].parent == -1) {\n                root = i;\n                break;\n            }\n\n        return true;\n    }\n\n    void debug() {\n        for (int i = 0; i < n; i++) {\n            System.out.printf(\"%d %d %d %d %d\\n\", tree[i].p, tree[i].q, tree[i].r, tree[i].b, tree[i].parent);\n        }\n    }\n\n    void run() {\n        while (init()) {\n            System.out.printf(\"%d\\n\", lightest(root));\n        }\n    }\n\n    public static void main(String[] args) {\n        new Main().run();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n\npublic class Main{\n\nstatic PrintWriter out;\nstatic InputReader ir;\nstatic int[] p=new int[101],q=new int[101],r=new int[101],b=new int[101],par=new int[101];\n\nstatic void solve(){\n int n;\n while((n=ir.nextInt())!=0){\n  for(int i=0;i<n;i++){\n   p[i]=ir.nextInt();\n   q[i]=ir.nextInt();\n   r[i]=ir.nextInt();\n   b[i]=ir.nextInt();\n   par[r[i]]=p[b[i]]=i+1;\n   int g=gcd(p[i],q[i]);\n   p[i]/=g;\n   q[i]/=g;\n  }\n  int now=1;\n  while(par[now]!=0) now=par[now];\n  out.println(dfs(now));\n  Arrays.fill(par,0);\n }\n}\n\npublic static int dfs(int now){\n if(r[now]==0&&b[now]==0) return p[now]+q[now];\n if(r[now]==0){\n  int bb=dfs(b[now]);\n  return bb/gcd(p[now],bb)*(p[now]+q[now]);\n }\n if(b[now]==0){\n  int rr=dfs(r[now]);\n  return rr/gcd(q[now],rr)*(p[now]+q[now]);\n }\n int bb=dfs(b[now]),rr=dfs(r[now]);\n return bb*p[now]/gcd(bb*p[now],rr*q[now])*rr*q[now];\n}\n\npublic static int gcd(int a,int b){\n if(b==0) return a;\n return gcd(b,a%b);\n}\n\npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n\nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n\n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n\n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n \n public boolean hasNext(){skip(); return hasNextByte();}\n \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n\n public double nextDouble(){return Double.parseDouble(next());}\n\n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n\n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n\n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.StringTokenizer;\n\n/**\n * Lightest Mobile\n */\npublic class Main {\n\n\tstatic Main main = new Main();\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line = \"\";\n\n\t\tMobile mobile = null;\n\t\twhile (!(line = br.readLine()).equals(\"0\")) {\n\t\t\tint n = Integer.parseInt(line);\n\n\t\t\tmobile = main.new Mobile();\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tmobile.add(i, br.readLine());\n\t\t\t}\n\t\t\tlong result = mobile.calc();\n\t\t\tSystem.err.println(result);\n\t\t\tSystem.out.println(result);\n\t\t}\n\t}\n\n\tclass Mobile {\n\t\tArrayList<Bar> mobile = new ArrayList<Bar>();\n\n\t\t// 棒をモービルに追加\n\t\tvoid add(int id, String info) {\n\t\t\tHangableImpr parent, left, right;\n\t\t\tint lid, rid;\n\t\t\tint rateL, rateR;\n\n\t\t\tStringTokenizer st = new StringTokenizer(info);\n\t\t\trateL = Integer.parseInt(st.nextToken());\n\t\t\trateR = Integer.parseInt(st.nextToken());\n\n\t\t\t// 親の棒\n\t\t\tif ((parent = find(id)) == null) {\n\t\t\t\tparent = new Bar(id, null);\n\t\t\t}\n\t\t\t((Bar) parent).lengthL = rateL;\n\t\t\t((Bar) parent).lengthR = rateR;\n\n\t\t\tlid = Integer.parseInt(st.nextToken());\n\t\t\trid = Integer.parseInt(st.nextToken());\n\n\t\t\t// 左の棒\n\t\t\tif (lid == 0) {\n\t\t\t\tleft = new Spindle();\n\t\t\t\tleft.parent = parent;\n\t\t\t} else {\n\t\t\t\tif ((left = find(lid)) == null) {\n\t\t\t\t\tleft = new Bar(lid, (Bar) parent);\n\t\t\t\t} else {\n\t\t\t\t\t((Bar) left).parent = (Bar) parent;\n\t\t\t\t\tmobile.remove(left);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// 右の棒\n\t\t\tif (rid == 0) {\n\t\t\t\tright = new Spindle();\n\t\t\t\tright.parent = parent;\n\t\t\t} else {\n\t\t\t\tif ((right = find(rid)) == null) {\n\t\t\t\t\tright = new Bar(rid, (Bar) parent);\n\t\t\t\t} else {\n\t\t\t\t\t((Bar) right).parent = (Bar) parent;\n\t\t\t\t\tmobile.remove(right);\n\t\t\t\t}\n\t\t\t}\n\t\t\t((Bar) parent).left = left;\n\t\t\t((Bar) parent).right = right;\n\t\t\tif (((Bar) parent).parent == null) {\n\t\t\t\tmobile.add((Bar) parent);\n\t\t\t}\n\t\t}\n\n\t\t// 指定した id の棒を検索\n\t\tBar find(int id) {\n\t\t\tBar result = null;\n\t\t\tfor (Bar b : mobile) {\n\t\t\t\tresult = b.find(id);\n\t\t\t\tif (result != null)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tlong calc() {\n\t\t\tlong result = 0;\n\t\t\tfor (Bar b : mobile) {\n\t\t\t\tb.calc();\n\t\t\t\tresult = b.weight;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t//\n\tinterface Hangable {\n\t\tHangable find(int id);\n\t}\n\n\tabstract class HangableImpr implements Hangable {\n\t\tHangableImpr parent;\n\t\tlong weight = 0;\n\t}\n\n\tclass Spindle extends HangableImpr {\n\t\t// int weight = 0;\n\t\t// Bar parent;\n\n\t\tSpindle() {\n\t\t\tthis.weight = 0;\n\t\t}\n\n\t\tSpindle(int weight) {\n\t\t\tthis.weight = weight;\n\t\t}\n\n\t\tpublic Spindle find(int id) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tclass Bar extends HangableImpr {\n\t\tint id;\n\t\tint lengthL, lengthR;\n\t\t// Bar parent;\n\t\tHangableImpr parent, left, right;\n\n\t\tBar(int id, Bar parent) {\n\t\t\tthis.id = id;\n\t\t\tthis.parent = parent;\n\t\t}\n\n\t\tpublic Bar find(int id) {\n\t\t\tBar result = null;\n\t\t\tif (this.id == id)\n\t\t\t\tresult = this;\n\t\t\tif (result == null && left != null)\n\t\t\t\tresult = (Bar) left.find(id);\n\t\t\tif (result == null && right != null)\n\t\t\t\tresult = (Bar) right.find(id);\n\t\t\treturn result;\n\t\t}\n\n\t\tvoid calc() {\n\t\t\tif (left instanceof Bar) {\n\t\t\t\t((Bar) left).calc();\n\t\t\t}\n\t\t\tif (right instanceof Bar) {\n\t\t\t\t((Bar) right).calc();\n\t\t\t}\n\n\t\t\tlong gcd = gcd(lengthL, lengthR);\n\t\t\tlong tempL, tempR;\n\t\t\tlong weightL, weightR;\n\n\t\t\ttempL = lengthL / gcd;\n\t\t\ttempR = lengthR / gcd;\n\t\t\tweightL = left.weight;\n\t\t\tweightR = right.weight;\n\n\t\t\tif (weightL == 0 && weightR == 0) {\n\t\t\t\tleft.weight = tempR;\n\t\t\t\tright.weight = tempL;\n\t\t\t} else if (weightL != 0 && weightR == 0) {\n\t\t\t\tlong lcm = lcm(tempR, lcm(tempL, weightL));\n\t\t\t\tright.weight = lcm / tempL;\n\t\t\t} else if (weightL == 0 && weightR != 0) {\n\t\t\t\tlong lcm = lcm(tempL, lcm(tempR, weightR));\n\t\t\t\tleft.weight = lcm / tempR;\n\t\t\t} else {\n\t\t\t\tlong lcm = lcm(lcm(tempL, weightL), lcm(tempR, weightR));\n\t\t\t\tleft.weight = lcm / tempR;\n\t\t\t\tright.weight = lcm / tempL;\n\t\t\t}\n\t\t\tweight = left.weight + right.weight;\n\t\t}\n\t}\n\n\t// 最大公約数\n\tstatic long lcm(long l, long r) {\n\t\treturn l * r / gcd(l, r);\n\t}\n\n\tstatic long lcm(long l, long r, long gcd) {\n\t\treturn l * r / gcd;\n\t}\n\n\t// 最小公倍数\n\tstatic long gcd(long l, long r) {\n\t\tlong mod;\n\t\tlong gt = l > r ? l : r;\n\t\tlong lt = l < r ? l : r;\n\n\t\tdo {\n\t\t\tmod = gt % lt;\n\t\t\tgt = lt;\n\t\t\tlt = mod;\n\t\t} while (mod != 0);\n\n\t\treturn gt;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.StringTokenizer;\n\n/**\n * Lightest Mobile\n */\npublic class Main {\n\n\tstatic Main main = new Main();\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line = \"\";\n\n\t\tint d = 0;\n\t\tMobile mobile = null;\n\t\twhile (!(line = br.readLine()).equals(\"0\")) {\n\t\t\tint n = Integer.parseInt(line);\n\t\t\td++;\n\n\t\t\tmobile = main.new Mobile();\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tline = br.readLine();\n\t\t\t\tmobile.add(i, line);\n\t\t\t\tif (d == 11)\n\t\t\t\t\tSystem.err.println(line);\n\t\t\t}\n\t\t\tSystem.out.println(mobile.calc());\n\t\t}\n\t}\n\n\tclass Mobile {\n\t\tArrayList<Bar> mobile = new ArrayList<Bar>();\n\n\t\t// 棒をモービルに追加\n\t\tvoid add(int id, String info) {\n\t\t\tHangableImpr parent, left, right;\n\t\t\tint lid, rid;\n\t\t\tint lengthL, lengthR;\n\n\t\t\tStringTokenizer st = new StringTokenizer(info);\n\t\t\tlengthL = Integer.parseInt(st.nextToken());\n\t\t\tlengthR = Integer.parseInt(st.nextToken());\n\n\t\t\t// 親の棒\n\t\t\tif ((parent = find(id)) == null) {\n\t\t\t\tparent = new Bar(id, null);\n\t\t\t}\n\t\t\t((Bar) parent).lengthL = lengthL;\n\t\t\t((Bar) parent).lengthR = lengthR;\n\n\t\t\tlid = Integer.parseInt(st.nextToken());\n\t\t\trid = Integer.parseInt(st.nextToken());\n\n\t\t\t// 左の棒\n\t\t\tif (lid == 0) {\n\t\t\t\tleft = new Spindle();\n\t\t\t\tleft.parent = parent;\n\t\t\t} else {\n\t\t\t\tif ((left = find(lid)) == null) {\n\t\t\t\t\tleft = new Bar(lid, (Bar) parent);\n\t\t\t\t} else {\n\t\t\t\t\t((Bar) left).parent = (Bar) parent;\n\t\t\t\t\tmobile.remove(left);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// 右の棒\n\t\t\tif (rid == 0) {\n\t\t\t\tright = new Spindle();\n\t\t\t\tright.parent = parent;\n\t\t\t} else {\n\t\t\t\tif ((right = find(rid)) == null) {\n\t\t\t\t\tright = new Bar(rid, (Bar) parent);\n\t\t\t\t} else {\n\t\t\t\t\t((Bar) right).parent = (Bar) parent;\n\t\t\t\t\tmobile.remove(right);\n\t\t\t\t}\n\t\t\t}\n\t\t\t((Bar) parent).left = left;\n\t\t\t((Bar) parent).right = right;\n\t\t\tif (((Bar) parent).parent == null) {\n\t\t\t\tmobile.add((Bar) parent);\n\t\t\t}\n\t\t}\n\n\t\t// 指定した id の棒を検索\n\t\tBar find(int id) {\n\t\t\tBar result = null;\n\t\t\tfor (Bar b : mobile) {\n\t\t\t\tresult = b.find(id);\n\t\t\t\tif (result != null)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tlong calc() {\n\t\t\tlong result = 0;\n\t\t\tfor (Bar b : mobile) {\n\t\t\t\tb.calc();\n\t\t\t\tresult = b.weight;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t//\n\tinterface Hangable {\n\t\tHangable find(int id);\n\t}\n\n\tabstract class HangableImpr implements Hangable {\n\t\tHangableImpr parent;\n\t\tlong weight = 0;\n\t}\n\n\tclass Spindle extends HangableImpr {\n\t\t// int weight = 0;\n\t\t// Bar parent;\n\n\t\tSpindle() {\n\t\t\tthis.weight = 0;\n\t\t}\n\n\t\tSpindle(int weight) {\n\t\t\tthis.weight = weight;\n\t\t}\n\n\t\tpublic Spindle find(int id) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tclass Bar extends HangableImpr {\n\t\tint id;\n\t\tint lengthL, lengthR;\n\t\t// Bar parent;\n\t\tHangableImpr parent, left, right;\n\n\t\tBar(int id, Bar parent) {\n\t\t\tthis.id = id;\n\t\t\tthis.parent = parent;\n\t\t}\n\n\t\tpublic Bar find(int id) {\n\t\t\tBar result = null;\n\t\t\tif (this.id == id)\n\t\t\t\tresult = this;\n\t\t\tif (result == null && left != null)\n\t\t\t\tresult = (Bar) left.find(id);\n\t\t\tif (result == null && right != null)\n\t\t\t\tresult = (Bar) right.find(id);\n\t\t\treturn result;\n\t\t}\n\n\t\tvoid calc() {\n\t\t\tif (left instanceof Bar) {\n\t\t\t\t((Bar) left).calc();\n\t\t\t}\n\t\t\tif (right instanceof Bar) {\n\t\t\t\t((Bar) right).calc();\n\t\t\t}\n\n\t\t\tlong gcd = gcd(lengthL, lengthR);\n\t\t\tlong tempL, tempR;\n\t\t\tlong weightL, weightR;\n\n\t\t\ttempL = lengthL / gcd;\n\t\t\ttempR = lengthR / gcd;\n\t\t\tweightL = left.weight;\n\t\t\tweightR = right.weight;\n\n\t\t\tif (weightL == 0 && weightR == 0) {\n\t\t\t\tleft.weight = tempR;\n\t\t\t\tright.weight = tempL;\n\t\t\t} else if (weightL != 0 && weightR == 0) {\n\t\t\t\tlong lcm = lcm(tempR, lcm(tempL, weightL));\n\t\t\t\tright.weight = lcm / tempL;\n\t\t\t} else if (weightL == 0 && weightR != 0) {\n\t\t\t\tlong lcm = lcm(tempL, lcm(tempR, weightR));\n\t\t\t\tleft.weight = lcm / tempR;\n\t\t\t} else {\n\t\t\t\tlong lcm = lcm(lcm(tempL, weightL), lcm(tempR, weightR));\n\t\t\t\tleft.weight = lcm / tempR;\n\t\t\t\tright.weight = lcm / tempL;\n\t\t\t}\n\t\t\tweight = left.weight + right.weight;\n\t\t}\n\t}\n\n\t// 最小公倍数\n\tstatic long lcm(long l, long r) {\n\t\tlong gt = l > r ? l : r;\n\t\tlong lt = l < r ? l : r;\n\t\treturn lt * (gt / gcd(l, r));\n\t}\n\n\tstatic long lcm(long l, long r, long gcd) {\n\t\tlong gt = l > r ? l : r;\n\t\tlong lt = l < r ? l : r;\n\t\treturn lt * (gt / gcd);\n\t}\n\n\t// 最大公約数\n\tstatic long gcd(long l, long r) {\n\t\tlong mod;\n\t\tlong gt = l > r ? l : r;\n\t\tlong lt = l < r ? l : r;\n\n\t\tdo {\n\t\t\tmod = gt % lt;\n\t\t\tgt = lt;\n\t\t\tlt = mod;\n\t\t} while (mod != 0);\n\n\t\treturn gt;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.StringTokenizer;\n\n/**\n * Lightest Mobile\n */\npublic class Main {\n\n\tstatic Main main = new Main();\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line = \"\";\n\n\t\tint d = 0;\n\t\tMobile mobile = null;\n\t\twhile (!(line = br.readLine()).equals(\"0\")) {\n\t\t\tint n = Integer.parseInt(line);\n\t\t\td++;\n\n\t\t\tmobile = main.new Mobile();\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tline = br.readLine();\n\t\t\t\tmobile.add(i, line);\n\t\t\t}\n\t\t\tif (d == 11)\n\t\t\t\tSystem.err.println(mobile.mobile.size());\n\t\t\tSystem.out.println(mobile.calc());\n\t\t}\n\t}\n\n\tclass Mobile {\n\t\tArrayList<Bar> mobile = new ArrayList<Bar>();\n\n\t\t// 棒をモービルに追加\n\t\tvoid add(int id, String info) {\n\t\t\tHangableImpr parent, left, right;\n\t\t\tint lid, rid;\n\t\t\tint lengthL, lengthR;\n\n\t\t\tStringTokenizer st = new StringTokenizer(info);\n\t\t\tlengthL = Integer.parseInt(st.nextToken());\n\t\t\tlengthR = Integer.parseInt(st.nextToken());\n\n\t\t\t// 親の棒\n\t\t\tif ((parent = find(id)) == null) {\n\t\t\t\tparent = new Bar(id, null);\n\t\t\t}\n\t\t\t((Bar) parent).lengthL = lengthL;\n\t\t\t((Bar) parent).lengthR = lengthR;\n\n\t\t\tlid = Integer.parseInt(st.nextToken());\n\t\t\trid = Integer.parseInt(st.nextToken());\n\n\t\t\t// 左の棒\n\t\t\tif (lid == 0) {\n\t\t\t\tleft = new Spindle();\n\t\t\t\tleft.parent = parent;\n\t\t\t} else {\n\t\t\t\tif ((left = find(lid)) == null) {\n\t\t\t\t\tleft = new Bar(lid, (Bar) parent);\n\t\t\t\t} else {\n\t\t\t\t\t((Bar) left).parent = (Bar) parent;\n\t\t\t\t\tmobile.remove(left);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// 右の棒\n\t\t\tif (rid == 0) {\n\t\t\t\tright = new Spindle();\n\t\t\t\tright.parent = parent;\n\t\t\t} else {\n\t\t\t\tif ((right = find(rid)) == null) {\n\t\t\t\t\tright = new Bar(rid, (Bar) parent);\n\t\t\t\t} else {\n\t\t\t\t\t((Bar) right).parent = (Bar) parent;\n\t\t\t\t\tmobile.remove(right);\n\t\t\t\t}\n\t\t\t}\n\t\t\t((Bar) parent).left = left;\n\t\t\t((Bar) parent).right = right;\n\t\t\tif (((Bar) parent).parent == null) {\n\t\t\t\tmobile.add((Bar) parent);\n\t\t\t}\n\t\t}\n\n\t\t// 指定した id の棒を検索\n\t\tBar find(int id) {\n\t\t\tBar result = null;\n\t\t\tfor (Bar b : mobile) {\n\t\t\t\tresult = b.find(id);\n\t\t\t\tif (result != null)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tlong calc() {\n\t\t\tlong result = 0;\n\t\t\tfor (Bar b : mobile) {\n\t\t\t\tb.calc();\n\t\t\t\tresult = b.weight;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t//\n\tinterface Hangable {\n\t\tHangable find(int id);\n\t}\n\n\tabstract class HangableImpr implements Hangable {\n\t\tHangableImpr parent;\n\t\tlong weight = 0;\n\t}\n\n\tclass Spindle extends HangableImpr {\n\t\t// int weight = 0;\n\t\t// Bar parent;\n\n\t\tSpindle() {\n\t\t\tthis.weight = 0;\n\t\t}\n\n\t\tSpindle(int weight) {\n\t\t\tthis.weight = weight;\n\t\t}\n\n\t\tpublic Spindle find(int id) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tclass Bar extends HangableImpr {\n\t\tint id;\n\t\tint lengthL, lengthR;\n\t\t// Bar parent;\n\t\tHangableImpr parent, left, right;\n\n\t\tBar(int id, Bar parent) {\n\t\t\tthis.id = id;\n\t\t\tthis.parent = parent;\n\t\t}\n\n\t\tpublic Bar find(int id) {\n\t\t\tBar result = null;\n\t\t\tif (this.id == id)\n\t\t\t\tresult = this;\n\t\t\tif (result == null && left != null)\n\t\t\t\tresult = (Bar) left.find(id);\n\t\t\tif (result == null && right != null)\n\t\t\t\tresult = (Bar) right.find(id);\n\t\t\treturn result;\n\t\t}\n\n\t\tvoid calc() {\n\t\t\tif (left instanceof Bar) {\n\t\t\t\t((Bar) left).calc();\n\t\t\t}\n\t\t\tif (right instanceof Bar) {\n\t\t\t\t((Bar) right).calc();\n\t\t\t}\n\n\t\t\tlong gcd = gcd(lengthL, lengthR);\n\t\t\tlong tempL, tempR;\n\t\t\tlong weightL, weightR;\n\n\t\t\ttempL = lengthL / gcd;\n\t\t\ttempR = lengthR / gcd;\n\t\t\tweightL = left.weight;\n\t\t\tweightR = right.weight;\n\n\t\t\tif (weightL == 0 && weightR == 0) {\n\t\t\t\tleft.weight = tempR;\n\t\t\t\tright.weight = tempL;\n\t\t\t} else if (weightL != 0 && weightR == 0) {\n\t\t\t\tlong lcm = lcm(tempR, lcm(tempL, weightL));\n\t\t\t\tright.weight = lcm / tempL;\n\t\t\t} else if (weightL == 0 && weightR != 0) {\n\t\t\t\tlong lcm = lcm(tempL, lcm(tempR, weightR));\n\t\t\t\tleft.weight = lcm / tempR;\n\t\t\t} else {\n\t\t\t\tlong lcm = lcm(lcm(tempL, weightL), lcm(tempR, weightR));\n\t\t\t\tleft.weight = lcm / tempR;\n\t\t\t\tright.weight = lcm / tempL;\n\t\t\t}\n\t\t\tweight = left.weight + right.weight;\n\t\t}\n\t}\n\n\t// 最小公倍数\n\tstatic long lcm(long l, long r) {\n\t\tlong gt = l > r ? l : r;\n\t\tlong lt = l < r ? l : r;\n\t\treturn lt * (gt / gcd(l, r));\n\t}\n\n\tstatic long lcm(long l, long r, long gcd) {\n\t\tlong gt = l > r ? l : r;\n\t\tlong lt = l < r ? l : r;\n\t\treturn lt * (gt / gcd);\n\t}\n\n\t// 最大公約数\n\tstatic long gcd(long l, long r) {\n\t\tlong mod;\n\t\tlong gt = l > r ? l : r;\n\t\tlong lt = l < r ? l : r;\n\n\t\tdo {\n\t\t\tmod = gt % lt;\n\t\t\tgt = lt;\n\t\t\tlt = mod;\n\t\t} while (mod != 0);\n\n\t\treturn gt;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.StringTokenizer;\n\n/**\n * Lightest Mobile\n */\npublic class Main {\n\n\tstatic Main main = new Main();\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line = \"\";\n\n\t\tMobile mobile = null;\n\t\twhile (!(line = br.readLine()).equals(\"0\")) {\n\t\t\tint n = Integer.parseInt(line);\n\n\t\t\tmobile = main.new Mobile();\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tline = br.readLine();\n\t\t\t\tmobile.add(i, line);\n\t\t\t}\n\t\t\tSystem.out.println(mobile.calc());\n\t\t}\n\t}\n\n\tclass Mobile {\n\t\tArrayList<Bar> mobile = new ArrayList<Bar>();\n\n\t\t// 棒をモービルに追加\n\t\tvoid add(int id, String info) {\n\t\t\tHangableImpr parent, left, right;\n\t\t\tint lid, rid;\n\t\t\tint lengthL, lengthR;\n\n\t\t\tStringTokenizer st = new StringTokenizer(info);\n\t\t\tlengthL = Integer.parseInt(st.nextToken());\n\t\t\tlengthR = Integer.parseInt(st.nextToken());\n\n\t\t\t// 親の棒\n\t\t\tif ((parent = find(id)) == null) {\n\t\t\t\tparent = new Bar(id, null);\n\t\t\t}\n\t\t\t((Bar) parent).lengthL = lengthL;\n\t\t\t((Bar) parent).lengthR = lengthR;\n\n\t\t\tlid = Integer.parseInt(st.nextToken());\n\t\t\trid = Integer.parseInt(st.nextToken());\n\n\t\t\t// 左の棒\n\t\t\tif (lid == 0) {\n\t\t\t\tleft = new Spindle();\n\t\t\t\tleft.parent = parent;\n\t\t\t} else {\n\t\t\t\tif ((left = find(lid)) == null) {\n\t\t\t\t\tleft = new Bar(lid, (Bar) parent);\n\t\t\t\t} else {\n\t\t\t\t\t((Bar) left).parent = (Bar) parent;\n\t\t\t\t\tmobile.remove(left);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// 右の棒\n\t\t\tif (rid == 0) {\n\t\t\t\tright = new Spindle();\n\t\t\t\tright.parent = parent;\n\t\t\t} else {\n\t\t\t\tif ((right = find(rid)) == null) {\n\t\t\t\t\tright = new Bar(rid, (Bar) parent);\n\t\t\t\t} else {\n\t\t\t\t\t((Bar) right).parent = (Bar) parent;\n\t\t\t\t\tmobile.remove(right);\n\t\t\t\t}\n\t\t\t}\n\t\t\t((Bar) parent).left = left;\n\t\t\t((Bar) parent).right = right;\n\t\t\tif (((Bar) parent).parent == null) {\n\t\t\t\tmobile.add((Bar) parent);\n\t\t\t}\n\t\t}\n\n\t\t// 指定した id の棒を検索\n\t\tBar find(int id) {\n\t\t\tBar result = null;\n\t\t\tfor (Bar b : mobile) {\n\t\t\t\tresult = b.find(id);\n\t\t\t\tif (result != null)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tlong calc() {\n\t\t\tlong result = 0;\n\t\t\tfor (Bar b : mobile) {\n\t\t\t\tb.calc();\n\t\t\t\tresult = b.weight;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t//\n\tinterface Hangable {\n\t\tHangable find(int id);\n\t}\n\n\tabstract class HangableImpr implements Hangable {\n\t\tHangableImpr parent;\n\t\tlong weight = 0;\n\t}\n\n\tclass Spindle extends HangableImpr {\n\t\t// int weight = 0;\n\t\t// Bar parent;\n\n\t\tSpindle() {\n\t\t\tthis.weight = 0;\n\t\t}\n\n\t\tSpindle(int weight) {\n\t\t\tthis.weight = weight;\n\t\t}\n\n\t\tpublic Spindle find(int id) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tclass Bar extends HangableImpr {\n\t\tint id;\n\t\tint lengthL, lengthR;\n\t\t// Bar parent;\n\t\tHangableImpr parent, left, right;\n\n\t\tBar(int id, Bar parent) {\n\t\t\tthis.id = id;\n\t\t\tthis.parent = parent;\n\t\t}\n\n\t\tpublic Bar find(int id) {\n\t\t\tBar result = null;\n\t\t\tif (this.id == id)\n\t\t\t\tresult = this;\n\t\t\tif (result == null && left != null)\n\t\t\t\tresult = (Bar) left.find(id);\n\t\t\tif (result == null && right != null)\n\t\t\t\tresult = (Bar) right.find(id);\n\t\t\treturn result;\n\t\t}\n\n\t\tvoid calc() {\n\t\t\tif (left instanceof Bar) {\n\t\t\t\t((Bar) left).calc();\n\t\t\t}\n\t\t\tif (right instanceof Bar) {\n\t\t\t\t((Bar) right).calc();\n\t\t\t}\n\n\t\t\tlong gcd = gcd(lengthL, lengthR);\n\t\t\tlong tempL, tempR;\n\t\t\tlong weightL, weightR;\n\n\t\t\ttempL = lengthL / gcd;\n\t\t\ttempR = lengthR / gcd;\n\t\t\tweightL = left.weight;\n\t\t\tweightR = right.weight;\n\n\t\t\tif (weightL == 0 && weightR == 0) {\n\t\t\t\tleft.weight = tempR;\n\t\t\t\tright.weight = tempL;\n\t\t\t} else if (weightL != 0 && weightR == 0) {\n\t\t\t\tlong lcm = lcm(tempR, lcm(tempL, weightL));\n\t\t\t\tleft.weight = lcm / tempL;\n\t\t\t\tright.weight = lcm / tempR;\n\t\t\t} else if (weightL == 0 && weightR != 0) {\n\t\t\t\tlong lcm = lcm(tempL, lcm(tempR, weightR));\n\t\t\t\tleft.weight = lcm / tempL;\n\t\t\t\tright.weight = lcm / tempR;\n\t\t\t} else {\n\t\t\t\tlong lcm = lcm(lcm(tempL, weightL), lcm(tempR, weightR));\n\t\t\t\tleft.weight = lcm / tempL;\n\t\t\t\tright.weight = lcm / tempR;\n\t\t\t}\n\t\t\tweight = left.weight + right.weight;\n\t\t}\n\t}\n\n\t// 最小公倍数\n\tstatic long lcm(long l, long r) {\n\t\tlong gt = l > r ? l : r;\n\t\tlong lt = l < r ? l : r;\n\t\treturn lt * gt / gcd(l, r);\n\t}\n\n\tstatic long lcm(long l, long r, long gcd) {\n\t\tlong gt = l > r ? l : r;\n\t\tlong lt = l < r ? l : r;\n\t\treturn lt * gt / gcd;\n\t}\n\n\t// 最大公約数\n\tstatic long gcd(long l, long r) {\n\t\tlong mod;\n\t\tlong gt = l > r ? l : r;\n\t\tlong lt = l < r ? l : r;\n\n\t\tdo {\n\t\t\tmod = gt % lt;\n\t\t\tgt = lt;\n\t\t\tlt = mod;\n\t\t} while (mod != 0);\n\n\t\treturn gt;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n\npublic class Main{\n\nstatic PrintWriter out;\nstatic InputReader ir;\nstatic int[] p=new int[101],q=new int[101],r=new int[101],b=new int[101],par=new int[101];\n\nstatic void solve(){\n int n;\n while((n=ir.nextInt())!=0){\n  for(int i=0;i<n;i++){\n   p[i]=ir.nextInt();\n   q[i]=ir.nextInt();\n   r[i]=ir.nextInt();\n   b[i]=ir.nextInt();\n   par[r[i]]=par[b[i]]=i+1;\n   long g=gcd(p[i],q[i]);\n   p[i]/=(int)g;\n   q[i]/=(int)g;\n  }\n  int now=1;\n  while(par[now]!=0) now=par[now];\n  out.println(dfs(now));\n  Arrays.fill(par,0);\n }\n}\n\npublic static long dfs(int m){\n int now=m-1;\n if(r[now]==0&&b[now]==0) return (long)p[now]+(long)q[now];\n if(r[now]==0){\n  long bb=dfs(b[now]);\n  return bb/gcd(q[now],bb)*(p[now]+q[now]);\n }\n if(b[now]==0){\n  long rr=dfs(r[now]);\n  return rr/gcd(p[now],rr)*(p[now]+q[now]);\n }\n long bb=dfs(b[now]),rr=dfs(r[now]);\n int g=gcd(bb*p[now],rr*q[now]);\n return rr*(long)q[now]/g*bb+bb*(long)p[now]/g*rr;\n}\n\npublic static long gcd(long a,long b){\n if(b==0) return a;\n return gcd(b,a%b);\n}\n\npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n\nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n\n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n\n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n \n public boolean hasNext(){skip(); return hasNextByte();}\n \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n\n public double nextDouble(){return Double.parseDouble(next());}\n\n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n\n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n\n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Lightest Mobile\npublic class Main{\n\n\tstatic long gcd(long a, long b){\n\t\tif(a < b){\n\t\t\tlong tmp = a;\n\t\t\ta = b;\n\t\t\tb = tmp;\n\t\t}\n\t\twhile(b!=0){\n\t\t\tlong r = a%b;\n\t\t\ta = b;\n\t\t\tb = r;\n\t\t}\n\t\treturn a;\n\t}\n\n\tclass R{\n\t\tlong p, q;\n\t\tR l, r, parent;\n\t\tpublic R() {\n\t\t\tl = r = parent = null;\n\t\t}\n\t\tlong get(){\n\t\t\tif(p==0)return 1;\n\t\t\tint k = 1;\n\t\t\tlong w1 = l.get();\n\t\t\tlong w2 = r.get();\n\t\t\twhile(true){\n\t\t\t\tif((k*q)%w1==0&&(k*p)%w2==0)break;\n\t\t\t\tk++;\n\t\t\t}\n\t\t\treturn k*(p+q);\n\t\t}\n\t}\n\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tR[] s = new R[n+1];\n\t\t\tfor(int i=0;i<=n;i++)s[i]=new R();\n\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\ts[i].p = sc.nextLong();\n\t\t\t\ts[i].q = sc.nextLong();\n\t\t\t\tlong g = gcd(s[i].p, s[i].q);\n\t\t\t\ts[i].p/=g;\n\t\t\t\ts[i].q/=g;\n\t\t\t\tint l = sc.nextInt();\n\t\t\t\tint r = sc.nextInt();\n\t\t\t\ts[i].l = s[l];\n\t\t\t\ts[i].r = s[r];\n\t\t\t\ts[l].parent = s[i];\n\t\t\t\ts[r].parent = s[i];\n\t\t\t}\n\t\t\tR root = null;\n\t\t\tfor(int i=1;i<=n;i++)if(s[i].parent==null)root = s[i];\n\t\t\tSystem.out.println(root.get());\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.StringTokenizer;\n\n/**\n * Lightest Mobile\n */\npublic class Main {\n\n\tstatic Main main = new Main();\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line = \"\";\n\n\t\tMobile mobile = null;\n\t\twhile (!(line = br.readLine()).equals(\"0\")) {\n\t\t\tint n = Integer.parseInt(line);\n\n\t\t\tmobile = main.new Mobile();\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tmobile.add(i, br.readLine());\n\t\t\t}\n\t\t\tint result = mobile.calc();\n\t\t\tSystem.err.println(result);\n\t\t\tSystem.out.println(result);\n\t\t}\n\t}\n\n\tclass Mobile {\n\t\tArrayList<Bar> mobile = new ArrayList<Bar>();\n\n\t\t// 指定 id の棒をモービルに追加\n\t\tvoid add(int id, String info) {\n\t\t\tHangableImpr parent, left, right;\n\t\t\tint lid, rid;\n\t\t\tint rateL, rateR;\n\n\t\t\tStringTokenizer st = new StringTokenizer(info);\n\t\t\trateL = Integer.parseInt(st.nextToken());\n\t\t\trateR = Integer.parseInt(st.nextToken());\n\n\t\t\t// 親の棒\n\t\t\tif ((parent = find(id)) == null) {\n\t\t\t\tparent = new Bar(id, null);\n\t\t\t}\n\t\t\t((Bar) parent).lengthL = rateL;\n\t\t\t((Bar) parent).lengthR = rateR;\n\n\t\t\tlid = Integer.parseInt(st.nextToken());\n\t\t\trid = Integer.parseInt(st.nextToken());\n\n\t\t\t// 左の棒\n\t\t\tif (lid == 0) {\n\t\t\t\tleft = new Spindle();\n\t\t\t\tleft.parent = parent;\n\t\t\t} else {\n\t\t\t\tif ((left = find(lid)) == null) {\n\t\t\t\t\tleft = new Bar(lid, (Bar) parent);\n\t\t\t\t} else {\n\t\t\t\t\t((Bar) left).parent = (Bar) parent;\n\t\t\t\t\tmobile.remove(left);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// 右の棒\n\t\t\tif (rid == 0) {\n\t\t\t\tright = new Spindle();\n\t\t\t\tright.parent = parent;\n\t\t\t} else {\n\t\t\t\tif ((right = find(rid)) == null) {\n\t\t\t\t\tright = new Bar(rid, (Bar) parent);\n\t\t\t\t} else {\n\t\t\t\t\t((Bar) right).parent = (Bar) parent;\n\t\t\t\t\tmobile.remove(right);\n\t\t\t\t}\n\t\t\t}\n\t\t\t((Bar) parent).left = left;\n\t\t\t((Bar) parent).right = right;\n\t\t\tif (((Bar) parent).parent == null) {\n\t\t\t\tmobile.add((Bar) parent);\n\t\t\t}\n\t\t}\n\n\t\t// 指定 id の棒を検索\n\t\tBar find(int id) {\n\t\t\tBar result = null;\n\t\t\tfor (Bar b : mobile) {\n\t\t\t\tresult = b.find(id);\n\t\t\t\tif (result != null)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tint calc() {\n\t\t\tint result = 0;\n\t\t\tfor (Bar b : mobile) {\n\t\t\t\tb.calc();\n\t\t\t\tresult = b.weight;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t//\n\tinterface Hangable {\n\t\tHangable find(int id);\n\t}\n\n\tabstract class HangableImpr implements Hangable {\n\t\tHangableImpr parent;\n\t\tint weight = 0;\n\t}\n\n\tclass Spindle extends HangableImpr {\n\t\t// int weight = 0;\n\t\t// Bar parent;\n\n\t\tSpindle() {\n\t\t\tthis.weight = 0;\n\t\t}\n\n\t\tSpindle(int weight) {\n\t\t\tthis.weight = weight;\n\t\t}\n\n\t\tpublic Spindle find(int id) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tclass Bar extends HangableImpr {\n\t\tint id;\n\t\tint lengthL, lengthR;\n\t\t// Bar parent;\n\t\tHangableImpr parent, left, right;\n\n\t\tBar(int id, Bar parent) {\n\t\t\tthis.id = id;\n\t\t\tthis.parent = parent;\n\t\t}\n\n\t\tpublic Bar find(int id) {\n\t\t\tBar result = null;\n\t\t\tif (this.id == id)\n\t\t\t\tresult = this;\n\t\t\tif (result == null && left != null)\n\t\t\t\tresult = (Bar) left.find(id);\n\t\t\tif (result == null && right != null)\n\t\t\t\tresult = (Bar) right.find(id);\n\t\t\treturn result;\n\t\t}\n\n\t\tvoid calc() {\n\t\t\tif (left instanceof Bar) {\n\t\t\t\t((Bar) left).calc();\n\t\t\t}\n\t\t\tif (right instanceof Bar) {\n\t\t\t\t((Bar) right).calc();\n\t\t\t}\n\n\t\t\tint gcd = gcd(lengthL, lengthR);\n\t\t\tint tempL, tempR;\n\t\t\tint weightL, weightR;\n\n\t\t\ttempL = lengthL / gcd;\n\t\t\ttempR = lengthR / gcd;\n\t\t\tweightL = left.weight;\n\t\t\tweightR = right.weight;\n\n\t\t\tif (weightL == 0 && weightR == 0) {\n\t\t\t\tleft.weight = tempR;\n\t\t\t\tright.weight = tempL;\n\t\t\t} else if (weightL != 0 && weightR == 0) {\n\t\t\t\tint lcm = lcm(tempR, lcm(tempL, weightL));\n\t\t\t\tright.weight = lcm / tempL;\n\t\t\t} else if (weightL == 0 && weightR != 0) {\n\t\t\t\tint lcm = lcm(tempL, lcm(tempR, weightR));\n\t\t\t\tleft.weight = lcm / tempR;\n\t\t\t} else {\n\t\t\t\tint lcm = lcm(lcm(tempL, weightL), lcm(tempR, weightR));\n\t\t\t\tleft.weight = lcm / tempR;\n\t\t\t\tright.weight = lcm / tempL;\n\t\t\t}\n\t\t\tweight = left.weight + right.weight;\n\t\t}\n\t}\n\n\t// 最大公約数\n\tstatic int lcm(int l, int r) {\n\t\treturn l * r / gcd(l, r);\n\t}\n\n\tstatic int lcm(int l, int r, int gcd) {\n\t\treturn l * r / gcd;\n\t}\n\n\t// 最小公倍数\n\tstatic int gcd(int l, int r) {\n\t\tint mod;\n\t\tint gt = l > r ? l : r;\n\t\tint lt = l < r ? l : r;\n\n\t\tdo {\n\t\t\tmod = gt % lt;\n\t\t\tgt = lt;\n\t\t\tlt = mod;\n\t\t} while (mod != 0);\n\n\t\treturn gt;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Lightest Mobile\npublic class Main{\n\n\tstatic long gcd(long a, long b){\n\t\tif(a < b){\n\t\t\tlong tmp = a;\n\t\t\ta = b;\n\t\t\tb = tmp;\n\t\t}\n\t\twhile(b!=0){\n\t\t\tlong r = a%b;\n\t\t\ta = b;\n\t\t\tb = r;\n\t\t}\n\t\treturn a;\n\t}\n\n\tclass R{\n\t\tlong p, q;\n\t\tR l, r, parent;\n\t\tpublic R() {\n\t\t\tl = r = parent = null;\n\t\t}\n//\t\tlong solve(){\n//\n//\t\t}\n\t\tlong get(){\n\t\t\tif(p==0)return 1;\n\t\t\tlong rate = l.get()*r.get();\n\t\t\tlong s = p+q;\n\t\t\tlong g = gcd(rate, s);\n\t\t\treturn s/g*rate;\n\t\t}\n\t}\n\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tR[] s = new R[n+1];\n\t\t\tfor(int i=0;i<=n;i++)s[i]=new R();\n\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\ts[i].p = sc.nextLong();\n\t\t\t\ts[i].q = sc.nextLong();\n\t\t\t\tlong g = gcd(s[i].p, s[i].q);\n\t\t\t\ts[i].p/=g;\n\t\t\t\ts[i].q/=g;\n\t\t\t\tint l = sc.nextInt();\n\t\t\t\tint r = sc.nextInt();\n\t\t\t\ts[i].l = s[l];\n\t\t\t\ts[i].r = s[r];\n\t\t\t\ts[l].parent = s[i];\n\t\t\t\ts[r].parent = s[i];\n\t\t\t}\n\t\t\tR root = null;\n\t\t\tfor(int i=1;i<=n;i++)if(s[i].parent==null)root = s[i];\n\t\t\tSystem.out.println(root.get());\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.StringTokenizer;\n\n/**\n * Lightest Mobile\n */\npublic class Main {\n\n\tstatic Main main = new Main();\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line = \"\";\n\n\t\tMobile mobile = null;\n\t\twhile (!(line = br.readLine()).equals(\"0\")) {\n\t\t\tint n = Integer.parseInt(line);\n\n\t\t\tmobile = main.new Mobile();\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tmobile.add(i, br.readLine());\n\t\t\t}\n\t\t\tSystem.out.println(mobile.calc());\n\t\t}\n\t}\n\n\tclass Mobile {\n\t\tArrayList<Bar> mobile = new ArrayList<Bar>();\n\n\t\t// 指定 id の棒をモービルに追加\n\t\tvoid add(int id, String info) {\n\t\t\tHangableImpr parent, left, right;\n\t\t\tint lid, rid;\n\t\t\tint rateL, rateR;\n\n\t\t\tStringTokenizer st = new StringTokenizer(info);\n\t\t\trateL = Integer.parseInt(st.nextToken());\n\t\t\trateR = Integer.parseInt(st.nextToken());\n\n\t\t\t// 親の棒\n\t\t\tif ((parent = find(id)) == null) {\n\t\t\t\tparent = new Bar(id, null);\n\t\t\t}\n\t\t\t((Bar) parent).lengthL = rateL;\n\t\t\t((Bar) parent).lengthR = rateR;\n\n\t\t\tlid = Integer.parseInt(st.nextToken());\n\t\t\trid = Integer.parseInt(st.nextToken());\n\n\t\t\t// 左の棒\n\t\t\tif (lid == 0) {\n\t\t\t\tleft = new Spindle();\n\t\t\t\tleft.parent = parent;\n\t\t\t} else {\n\t\t\t\tif ((left = find(lid)) == null) {\n\t\t\t\t\tleft = new Bar(lid, (Bar) parent);\n\t\t\t\t} else {\n\t\t\t\t\t((Bar) left).parent = (Bar) parent;\n\t\t\t\t\tmobile.remove(left);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// 右の棒\n\t\t\tif (rid == 0) {\n\t\t\t\tright = new Spindle();\n\t\t\t\tright.parent = parent;\n\t\t\t} else {\n\t\t\t\tif ((right = find(rid)) == null) {\n\t\t\t\t\tright = new Bar(rid, (Bar) parent);\n\t\t\t\t} else {\n\t\t\t\t\t((Bar) right).parent = (Bar) parent;\n\t\t\t\t\tmobile.remove(right);\n\t\t\t\t}\n\t\t\t}\n\t\t\t((Bar) parent).left = left;\n\t\t\t((Bar) parent).right = right;\n\t\t\tif (((Bar) parent).parent == null) {\n\t\t\t\tmobile.add((Bar) parent);\n\t\t\t}\n\t\t}\n\n\t\t// 指定 id の棒を検索\n\t\tBar find(int id) {\n\t\t\tBar result = null;\n\t\t\tfor (Bar b : mobile) {\n\t\t\t\tresult = b.find(id);\n\t\t\t\tif (result != null)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tint calc() {\n\t\t\tint result = 0;\n\t\t\tfor (Bar b : mobile) {\n\t\t\t\tb.calc();\n\t\t\t\tresult = b.weight;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t//\n\tinterface Hangable {\n\t\tHangable find(int id);\n\t}\n\n\tabstract class HangableImpr implements Hangable {\n\t\tHangableImpr parent;\n\t\tint weight = 0;\n\t}\n\n\tclass Spindle extends HangableImpr {\n\t\t// int weight = 0;\n\t\t// Bar parent;\n\n\t\tSpindle() {\n\t\t\tthis.weight = 0;\n\t\t}\n\n\t\tSpindle(int weight) {\n\t\t\tthis.weight = weight;\n\t\t}\n\n\t\tpublic Spindle find(int id) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tclass Bar extends HangableImpr {\n\t\tint id;\n\t\tint lengthL, lengthR;\n\t\t// Bar parent;\n\t\tHangableImpr parent, left, right;\n\n\t\tBar(int id, Bar parent) {\n\t\t\tthis.id = id;\n\t\t\tthis.parent = parent;\n\t\t}\n\n\t\tpublic Bar find(int id) {\n\t\t\tBar result = null;\n\t\t\tif (this.id == id)\n\t\t\t\tresult = this;\n\t\t\tif (result == null && left != null)\n\t\t\t\tresult = (Bar) left.find(id);\n\t\t\tif (result == null && right != null)\n\t\t\t\tresult = (Bar) right.find(id);\n\t\t\treturn result;\n\t\t}\n\n\t\tvoid calc() {\n\t\t\tif (left instanceof Bar) {\n\t\t\t\t((Bar) left).calc();\n\t\t\t}\n\t\t\tif (right instanceof Bar) {\n\t\t\t\t((Bar) right).calc();\n\t\t\t}\n\n\t\t\tint gcd = gcd(lengthL, lengthR);\n\t\t\tint tempL, tempR;\n\t\t\tint weightL, weightR;\n\t\t\t\n\t\t\ttempL = lengthL / gcd;\n\t\t\ttempR = lengthR / gcd;\n\t\t\tweightL = left.weight;\n\t\t\tweightR = right.weight;\n\n\t\t\tif (weightL == 0 && weightR == 0) {\n\t\t\t\tleft.weight = tempR;\n\t\t\t\tright.weight = tempL;\n\t\t\t} else if (weightL != 0 && weightR == 0) {\n\t\t\t\tint lcm = lcm(tempR, lcm(tempL, weightL));\n\t\t\t\tright.weight = lcm / tempL;\n\t\t\t} else if (weightL == 0 && weightR != 0) {\n\t\t\t\tint lcm = lcm(tempL, lcm(tempR, weightR));\n\t\t\t\tleft.weight = lcm / tempR;\n\t\t\t} else {\n\t\t\t\tint lcm = lcm(lcm(tempL, weightL), lcm(tempR, weightR));\n\t\t\t\tleft.weight = lcm / tempR;\n\t\t\t\tright.weight = lcm / tempL;\n\t\t\t}\n\t\t\tweight = left.weight + right.weight;\n\t\t}\n\t}\n\n\t// 最大公約数\n\tstatic int lcm(int l, int r) {\n\t\treturn l * r / gcd(l, r);\n\t}\n\n\tstatic int lcm(int l, int r, int gcd) {\n\t\treturn l * r / gcd;\n\t}\n\n\t// 最小公倍数\n\tstatic int gcd(int l, int r) {\n\t\tint mod;\n\t\tint gt = l > r ? l : r;\n\t\tint lt = l < r ? l : r;\n\n\t\tdo {\n\t\t\tmod = gt % lt;\n\t\t\tgt = lt;\n\t\t\tlt = mod;\n\t\t} while (mod != 0);\n\n\t\treturn gt;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\t/**\n\t * TODO : ただの再帰ではなく、バランスを取らなければならない\n\t *　これは手戻りが発生する \n\t * \n\t * @author Taichiro\n\t *\n\t */\n\tpublic static class Node{\n\t\tNode left, right;\n\t\tint l_dist, r_dist;\n\t\tint weight;\n\t\t\n\t\tpublic Node(int l_dist, int r_dist) {\n\t\t\tsuper();\n\t\t\tthis.l_dist = l_dist;\n\t\t\tthis.r_dist = r_dist;\n\t\t\tthis.weight = 0;\n\t\t}\n\t\t\n\t\tpublic int solve(){\n\t\t\tif(this.weight != 0){\n\t\t\t\treturn this.weight;\n\t\t\t}\n\t\t\t\n\t\t\tif(this.left == null && this.right == null){\n\t\t\t\tfinal int moment  = lcm(this.l_dist, this.r_dist);\n\t\t\t\tfinal int left_w  = moment / l_dist;\n\t\t\t\tfinal int right_w = moment / r_dist;\n\t\t\t\t\n\t\t\t\treturn this.weight = (left_w + right_w);\n\t\t\t}else{\n\t\t\t\tfinal int left_ch_w  = left  != null ? left.solve()  : 1;\n\t\t\t\tfinal int right_ch_w = right != null ? right.solve() : 1;\n\t\t\t\t\n\t\t\t\tfinal int moment = lcm(left_ch_w * l_dist, right_ch_w * r_dist);\n\t\t\t\t\n\t\t\t\tfinal int left_w  = moment / l_dist;\n\t\t\t\tfinal int right_w = moment / r_dist;\n\t\t\t\t\n\t\t\t\treturn this.weight = (left_w + right_w);\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic String toString(){\n\t\t\treturn \"[\" + this.weight + \" : \" + (this.left == null ? \"\" : this.left.toString()) + \", \" + (this.right == null ? \"\" : this.right.toString()) + \"]\";\n\t\t}\n\t}\n\t\n\tpublic static int gcd(int x, int y){\n\t\tif(x == 0){\n\t\t\treturn y;\n\t\t}else{\n\t\t\treturn gcd(y % x, x);\n\t\t}\n\t}\n\t\n\tpublic static int lcm(int x, int y){\n\t\treturn  x * y / gcd(x, y);\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile (true) {\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint[][] data = new int[n][4];\n\t\t\tNode[] nodes = new Node[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfor(int j = 0; j < 4; j++){\n\t\t\t\t\tdata[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = n - 1; i >= 0; i--){\n\t\t\t\t//System.out.println(i);\n\t\t\t\tnodes[i] = new Node(data[i][0], data[i][1]);\n\t\t\t}\n\t\t\tfor(int i = n - 1; i >= 0; i--){\n\t\t\t\tif(data[i][2] != 0){\n\t\t\t\t\tnodes[i].left  = nodes[data[i][2] - 1];\n\t\t\t\t}\n\t\t\t\tif(data[i][3] != 0){\n\t\t\t\t\tnodes[i].right = nodes[data[i][3] - 1];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint max = 0;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tmax = Math.max(max, nodes[i].solve());\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n \npublic class Main{\n \nstatic PrintWriter out;\nstatic InputReader ir;\nstatic int[] p=new int[101],q=new int[101],r=new int[101],b=new int[101],par=new int[101];\n \nstatic void solve(){\n int n;\n while((n=ir.nextInt())!=0){\n  for(int i=0;i<n;i++){\n   p[i]=ir.nextInt();\n   q[i]=ir.nextInt();\n   r[i]=ir.nextInt();\n   b[i]=ir.nextInt();\n   par[r[i]]=par[b[i]]=i+1;\n   long g=gcd(p[i],q[i]);\n   p[i]/=(int)g;\n   q[i]/=(int)g;\n  }\n  int pp=-1;\n  for(int i=1;i<=n;i++) if(par[i]==-1) pp=i;\n  out.println(dfs(pp));\n  Arrays.fill(par,-1);\n }\n}\n \npublic static long dfs(int m){\n int now=m-1;\n if(r[now]==0&&b[now]==0) return (long)p[now]+(long)q[now];\n if(r[now]==0){\n  long bb=dfs(b[now]);\n  return bb/gcd(q[now],bb)*(p[now]+q[now]);\n }\n if(b[now]==0){\n  long rr=dfs(r[now]);\n  return rr/gcd(p[now],rr)*(p[now]+q[now]);\n }\n long bb=dfs(b[now]),rr=dfs(r[now]);\n long l=lcm(bb*p[now],rr*q[now]);\n return l/p[now]+l/q[now];\n}\n \npublic static long gcd(long a,long b){\n if(b==0) return a;\n return gcd(b,a%b);\n}\n\npublic static long lcm(long a,long b){\n return a*b/gcd(a,b);\n}\n \npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n \nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n \n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n  \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n \n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n  \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n  \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n  \n public boolean hasNext(){skip(); return hasNextByte();}\n  \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n  \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n  \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public double nextDouble(){return Double.parseDouble(next());}\n \n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n \n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n \n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.StringTokenizer;\n\n/**\n * Lightest Mobile\n */\npublic class Main {\n\n\tstatic Main main = new Main();\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line = \"\";\n\n\t\tMobile mobile = null;\n\t\twhile (!(line = br.readLine()).equals(\"0\")) {\n\t\t\tint n = Integer.parseInt(line);\n\t\t\tSystem.err.println(n);\n\n\t\t\tmobile = main.new Mobile();\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tmobile.add(i, br.readLine());\n\t\t\t}\n\t\t\tlong result = mobile.calc();\n\t\t\tSystem.err.println(result);\n\t\t\tSystem.out.println(result);\n\t\t}\n\t}\n\n\tclass Mobile {\n\t\tArrayList<Bar> mobile = new ArrayList<Bar>();\n\n\t\t// 棒をモービルに追加\n\t\tvoid add(int id, String info) {\n\t\t\tHangableImpr parent, left, right;\n\t\t\tint lid, rid;\n\t\t\tint lengthL, lengthR;\n\n\t\t\tStringTokenizer st = new StringTokenizer(info);\n\t\t\tlengthL = Integer.parseInt(st.nextToken());\n\t\t\tlengthR = Integer.parseInt(st.nextToken());\n\n\t\t\t// 親の棒\n\t\t\tif ((parent = find(id)) == null) {\n\t\t\t\tparent = new Bar(id, null);\n\t\t\t}\n\t\t\t((Bar) parent).lengthL = lengthL;\n\t\t\t((Bar) parent).lengthR = lengthR;\n\n\t\t\tlid = Integer.parseInt(st.nextToken());\n\t\t\trid = Integer.parseInt(st.nextToken());\n\n\t\t\t// 左の棒\n\t\t\tif (lid == 0) {\n\t\t\t\tleft = new Spindle();\n\t\t\t\tleft.parent = parent;\n\t\t\t} else {\n\t\t\t\tif ((left = find(lid)) == null) {\n\t\t\t\t\tleft = new Bar(lid, (Bar) parent);\n\t\t\t\t} else {\n\t\t\t\t\t((Bar) left).parent = (Bar) parent;\n\t\t\t\t\tmobile.remove(left);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// 右の棒\n\t\t\tif (rid == 0) {\n\t\t\t\tright = new Spindle();\n\t\t\t\tright.parent = parent;\n\t\t\t} else {\n\t\t\t\tif ((right = find(rid)) == null) {\n\t\t\t\t\tright = new Bar(rid, (Bar) parent);\n\t\t\t\t} else {\n\t\t\t\t\t((Bar) right).parent = (Bar) parent;\n\t\t\t\t\tmobile.remove(right);\n\t\t\t\t}\n\t\t\t}\n\t\t\t((Bar) parent).left = left;\n\t\t\t((Bar) parent).right = right;\n\t\t\tif (((Bar) parent).parent == null) {\n\t\t\t\tmobile.add((Bar) parent);\n\t\t\t}\n\t\t}\n\n\t\t// 指定した id の棒を検索\n\t\tBar find(int id) {\n\t\t\tBar result = null;\n\t\t\tfor (Bar b : mobile) {\n\t\t\t\tresult = b.find(id);\n\t\t\t\tif (result != null)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tlong calc() {\n\t\t\tlong result = 0;\n\t\t\tfor (Bar b : mobile) {\n\t\t\t\tb.calc();\n\t\t\t\tresult = b.weight;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t//\n\tinterface Hangable {\n\t\tHangable find(int id);\n\t}\n\n\tabstract class HangableImpr implements Hangable {\n\t\tHangableImpr parent;\n\t\tlong weight = 0;\n\t}\n\n\tclass Spindle extends HangableImpr {\n\t\t// int weight = 0;\n\t\t// Bar parent;\n\n\t\tSpindle() {\n\t\t\tthis.weight = 0;\n\t\t}\n\n\t\tSpindle(int weight) {\n\t\t\tthis.weight = weight;\n\t\t}\n\n\t\tpublic Spindle find(int id) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tclass Bar extends HangableImpr {\n\t\tint id;\n\t\tint lengthL, lengthR;\n\t\t// Bar parent;\n\t\tHangableImpr parent, left, right;\n\n\t\tBar(int id, Bar parent) {\n\t\t\tthis.id = id;\n\t\t\tthis.parent = parent;\n\t\t}\n\n\t\tpublic Bar find(int id) {\n\t\t\tBar result = null;\n\t\t\tif (this.id == id)\n\t\t\t\tresult = this;\n\t\t\tif (result == null && left != null)\n\t\t\t\tresult = (Bar) left.find(id);\n\t\t\tif (result == null && right != null)\n\t\t\t\tresult = (Bar) right.find(id);\n\t\t\treturn result;\n\t\t}\n\n\t\tvoid calc() {\n\t\t\tif (left instanceof Bar) {\n\t\t\t\t((Bar) left).calc();\n\t\t\t}\n\t\t\tif (right instanceof Bar) {\n\t\t\t\t((Bar) right).calc();\n\t\t\t}\n\n\t\t\tlong gcd = gcd(lengthL, lengthR);\n\t\t\tlong tempL, tempR;\n\t\t\tlong weightL, weightR;\n\n\t\t\ttempL = lengthL / gcd;\n\t\t\ttempR = lengthR / gcd;\n\t\t\tweightL = left.weight;\n\t\t\tweightR = right.weight;\n\n\t\t\tif (weightL == 0 && weightR == 0) {\n\t\t\t\tleft.weight = tempR;\n\t\t\t\tright.weight = tempL;\n\t\t\t} else if (weightL != 0 && weightR == 0) {\n\t\t\t\tlong lcm = lcm(tempR, lcm(tempL, weightL));\n\t\t\t\tright.weight = lcm / tempL;\n\t\t\t} else if (weightL == 0 && weightR != 0) {\n\t\t\t\tlong lcm = lcm(tempL, lcm(tempR, weightR));\n\t\t\t\tleft.weight = lcm / tempR;\n\t\t\t} else {\n\t\t\t\tlong lcm = lcm(lcm(tempL, weightL), lcm(tempR, weightR));\n\t\t\t\tleft.weight = lcm / tempR;\n\t\t\t\tright.weight = lcm / tempL;\n\t\t\t}\n\t\t\tweight = left.weight + right.weight;\n\t\t}\n\t}\n\n\t// 最小公倍数\n\tstatic long lcm(long l, long r) {\n\t\tlong gt = l > r ? l : r;\n\t\tlong lt = l < r ? l : r;\n\t\treturn lt * (gt / gcd(l, r));\n\t}\n\n\tstatic long lcm(long l, long r, long gcd) {\n\t\tlong gt = l > r ? l : r;\n\t\tlong lt = l < r ? l : r;\n\t\treturn lt * (gt / gcd);\n\t}\n\n\t// 最大公約数\n\tstatic long gcd(long l, long r) {\n\t\tlong mod;\n\t\tlong gt = l > r ? l : r;\n\t\tlong lt = l < r ? l : r;\n\n\t\tdo {\n\t\t\tmod = gt % lt;\n\t\t\tgt = lt;\n\t\t\tlt = mod;\n\t\t} while (mod != 0);\n\n\t\treturn gt;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n\npublic class Main{\n\nstatic PrintWriter out;\nstatic InputReader ir;\nstatic int[] p=new int[101],q=new int[101],r=new int[101],b=new int[101],par=new int[101];\n\nstatic void solve(){\n int n;\n while((n=ir.nextInt())!=0){\n  for(int i=0;i<n;i++){\n   p[i]=ir.nextInt();\n   q[i]=ir.nextInt();\n   r[i]=ir.nextInt();\n   b[i]=ir.nextInt();\n   par[r[i]]=p[b[i]]=i+1;\n   int g=gcd(p[i],q[i]);\n   p[i]/=g;\n   q[i]/=g;\n  }\n  int now=1;\n  while(par[now]!=0) now=par[now];\n  out.println(dfs(now));\n }\n}\n\npublic static int dfs(int now){\n if(r[now]==0&&b[now]==0) return p[now]+q[now];\n if(r[now]==0){\n  int bb=dfs(b[now]);\n  return bb/gcd(p[now],bb)*(p[now]+q[now]);\n }\n if(b[now]==0){\n  int rr=dfs(r[now]);\n  return rr/gcd(q[now],rr)*(p[now]+q[now]);\n }\n int bb=dfs(b[now]),rr=dfs(r[now]);\n return bb*p[now]/gcd(bb*p[now],rr*q[now])*rr*q[now];\n}\n\npublic static int gcd(int a,int b){\n if(b==0) return a;\n return gcd(b,a%b);\n}\n\npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n\nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n\n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n\n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n \n public boolean hasNext(){skip(); return hasNextByte();}\n \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n\n public double nextDouble(){return Double.parseDouble(next());}\n\n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n\n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n\n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.StringTokenizer;\n\n/**\n * Lightest Mobile\n */\npublic class Main {\n\n\tstatic Main main = new Main();\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line = \"\";\n\n\t\t// int d = 0;\n\t\tMobile mobile = null;\n\t\twhile (!(line = br.readLine()).equals(\"0\")) {\n\t\t\tint n = Integer.parseInt(line);\n\t\t\t// d++;\n\n\t\t\tmobile = main.new Mobile();\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tline = br.readLine();\n\t\t\t\tmobile.add(i, line);\n\t\t\t}\n\t\t\t// if (d == 11)\n\t\t\t// System.err.println(mobile.mobile.size());\n\t\t\tSystem.err.println(mobile.calc());\n\t\t}\n\t}\n\n\tclass Mobile {\n\t\tArrayList<Bar> mobile = new ArrayList<Bar>();\n\n\t\t// 棒をモービルに追加\n\t\tvoid add(int id, String info) {\n\t\t\tHangableImpr parent, left, right;\n\t\t\tint lid, rid;\n\t\t\tint lengthL, lengthR;\n\n\t\t\tStringTokenizer st = new StringTokenizer(info);\n\t\t\tlengthL = Integer.parseInt(st.nextToken());\n\t\t\tlengthR = Integer.parseInt(st.nextToken());\n\n\t\t\t// 親の棒\n\t\t\tif ((parent = find(id)) == null) {\n\t\t\t\tparent = new Bar(id, null);\n\t\t\t}\n\t\t\t((Bar) parent).lengthL = lengthL;\n\t\t\t((Bar) parent).lengthR = lengthR;\n\n\t\t\tlid = Integer.parseInt(st.nextToken());\n\t\t\trid = Integer.parseInt(st.nextToken());\n\n\t\t\t// 左の棒\n\t\t\tif (lid == 0) {\n\t\t\t\tleft = new Spindle();\n\t\t\t\tleft.parent = parent;\n\t\t\t} else {\n\t\t\t\tif ((left = find(lid)) == null) {\n\t\t\t\t\tleft = new Bar(lid, (Bar) parent);\n\t\t\t\t} else {\n\t\t\t\t\t((Bar) left).parent = (Bar) parent;\n\t\t\t\t\tmobile.remove(left);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// 右の棒\n\t\t\tif (rid == 0) {\n\t\t\t\tright = new Spindle();\n\t\t\t\tright.parent = parent;\n\t\t\t} else {\n\t\t\t\tif ((right = find(rid)) == null) {\n\t\t\t\t\tright = new Bar(rid, (Bar) parent);\n\t\t\t\t} else {\n\t\t\t\t\t((Bar) right).parent = (Bar) parent;\n\t\t\t\t\tmobile.remove(right);\n\t\t\t\t}\n\t\t\t}\n\t\t\t((Bar) parent).left = left;\n\t\t\t((Bar) parent).right = right;\n\t\t\tif (((Bar) parent).parent == null) {\n\t\t\t\tmobile.add((Bar) parent);\n\t\t\t}\n\t\t}\n\n\t\t// 指定した id の棒を検索\n\t\tBar find(int id) {\n\t\t\tBar result = null;\n\t\t\tfor (Bar b : mobile) {\n\t\t\t\tresult = b.find(id);\n\t\t\t\tif (result != null)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tlong calc() {\n\t\t\tlong result = 0;\n\t\t\tfor (Bar b : mobile) {\n\t\t\t\tb.calc();\n\t\t\t\tresult = b.weight;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t//\n\tinterface Hangable {\n\t\tHangable find(int id);\n\t}\n\n\tabstract class HangableImpr implements Hangable {\n\t\tHangableImpr parent;\n\t\tlong weight = 0;\n\t}\n\n\tclass Spindle extends HangableImpr {\n\t\t// int weight = 0;\n\t\t// Bar parent;\n\n\t\tSpindle() {\n\t\t\tthis.weight = 0;\n\t\t}\n\n\t\tSpindle(int weight) {\n\t\t\tthis.weight = weight;\n\t\t}\n\n\t\tpublic Spindle find(int id) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tclass Bar extends HangableImpr {\n\t\tint id;\n\t\tint lengthL, lengthR;\n\t\t// Bar parent;\n\t\tHangableImpr parent, left, right;\n\n\t\tBar(int id, Bar parent) {\n\t\t\tthis.id = id;\n\t\t\tthis.parent = parent;\n\t\t}\n\n\t\tpublic Bar find(int id) {\n\t\t\tBar result = null;\n\t\t\tif (this.id == id)\n\t\t\t\tresult = this;\n\t\t\tif (result == null && left != null)\n\t\t\t\tresult = (Bar) left.find(id);\n\t\t\tif (result == null && right != null)\n\t\t\t\tresult = (Bar) right.find(id);\n\t\t\treturn result;\n\t\t}\n\n\t\tvoid calc() {\n\t\t\tif (left instanceof Bar) {\n\t\t\t\t((Bar) left).calc();\n\t\t\t}\n\t\t\tif (right instanceof Bar) {\n\t\t\t\t((Bar) right).calc();\n\t\t\t}\n\n\t\t\tlong gcd = gcd(lengthL, lengthR);\n\t\t\tlong tempL, tempR;\n\t\t\tlong weightL, weightR;\n\n\t\t\ttempL = lengthL / gcd;\n\t\t\ttempR = lengthR / gcd;\n\t\t\tweightL = left.weight;\n\t\t\tweightR = right.weight;\n\n\t\t\tif (weightL == 0 && weightR == 0) {\n\t\t\t\tleft.weight = tempR;\n\t\t\t\tright.weight = tempL;\n\t\t\t} else if (weightL != 0 && weightR == 0) {\n\t\t\t\tlong lcm = lcm(tempR, lcm(tempL, weightL));\n\t\t\t\tleft.weight = lcm / tempL;\n\t\t\t\tright.weight = lcm / tempR;\n\t\t\t} else if (weightL == 0 && weightR != 0) {\n\t\t\t\tlong lcm = lcm(tempL, lcm(tempR, weightR));\n\t\t\t\tleft.weight = lcm / tempL;\n\t\t\t\tright.weight = lcm / tempR;\n\t\t\t} else {\n\t\t\t\tlong lcm = lcm(lcm(tempL, weightL), lcm(tempR, weightR));\n\t\t\t\tleft.weight = lcm / tempL;\n\t\t\t\tright.weight = lcm / tempR;\n\t\t\t}\n\t\t\tweight = left.weight + right.weight;\n\t\t}\n\t}\n\n\t// 最小公倍数\n\tstatic long lcm(long l, long r) {\n\t\tlong gt = l > r ? l : r;\n\t\tlong lt = l < r ? l : r;\n\t\treturn lt * (gt / gcd(l, r));\n\t}\n\n\tstatic long lcm(long l, long r, long gcd) {\n\t\tlong gt = l > r ? l : r;\n\t\tlong lt = l < r ? l : r;\n\t\treturn lt * (gt / gcd);\n\t}\n\n\t// 最大公約数\n\tstatic long gcd(long l, long r) {\n\t\tlong mod;\n\t\tlong gt = l > r ? l : r;\n\t\tlong lt = l < r ? l : r;\n\n\t\tdo {\n\t\t\tmod = gt % lt;\n\t\t\tgt = lt;\n\t\t\tlt = mod;\n\t\t} while (mod != 0);\n\n\t\treturn gt;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "gimport java.io.*;\nimport java.util.*;\n\nclass Node {\n    public int p, q, r, b, parent;\n    Node(int p, int q, int r, int b) {\n        this.p = p;\n        this.q = q;\n        this.r = r;\n        this.b = b;\n        this.parent = -1;\n    }\n}\n\npublic class Main {\n    Scanner sc;\n    int n;\n    int root;\n    Node[] tree;\n\n    long gcd(long a, long b) {\n        if (a > b) {\n            long tmp = a;\n            a = b;\n            b = tmp;\n        }\n        if (a == 0) return b;\n        return gcd(b % a, a);\n    }\n\n    long lcm(long a, long b) {\n        return a / gcd(a, b) * b;\n    }\n\n    Main() {\n        sc = new Scanner(System.in);\n    }\n\n    long lightest(int index) {\n        int p = tree[index].p;\n        int q = tree[index].q;\n        int r = tree[index].r;\n        int b = tree[index].b;\n        if (r == -1 && b == -1) {\n            return (p + q) / gcd(p, q);\n        } else if (r == -1) {\n            long b_weight = lcm(lightest(b), p);\n            long r_weight = b_weight * q / p;\n            return r_weight + b_weight;\n        } else if (b == -1) {\n            long r_weight = lcm(lightest(r), q);\n            long b_weight = r_weight * p / q;\n            return r_weight + b_weight;\n        }\n        long lcm_rb = lcm(lightest(r)*p, lightest(b)*q);\n        long r_weight = lcm_rb / p;\n        long b_weight = lcm_rb / q;\n        return r_weight + b_weight;\n    }\n\n    boolean init() {\n        n = sc.nextInt();\n        if (n == 0) return false;\n\n        tree = new Node[n];\n        for (int i = 0; i < n; i++) {\n            int p = sc.nextInt();\n            int q = sc.nextInt();\n            int r = sc.nextInt();\n            int b = sc.nextInt();\n            long gcd_pq = gcd(p, q);\n            p /= gcd_pq;\n            q /= gcd_pq;\n            tree[i] = new Node(p, q, r-1, b-1);  // 0-originに\n        }\n\n        // 親を探す\n        for (int i = 0; i < n; i++) {\n            if (tree[i].r >= 0) tree[tree[i].r].parent = i;\n            if (tree[i].b >= 0) tree[tree[i].b].parent = i;\n        }\n\n        // rootを探す\n        for (int i = 0; i < n; i++) \n            if (tree[i].parent == -1) {\n                root = i;\n                break;\n            }\n\n        return true;\n    }\n\n    void debug() {\n        for (int i = 0; i < n; i++) {\n            System.out.printf(\"%d %d %d %d %d\\n\", tree[i].p, tree[i].q, tree[i].r, tree[i].b, tree[i].parent);\n        }\n    }\n\n    void run() {\n        while (init()) {\n            System.out.printf(\"%d\\n\", lightest(root));\n        }\n    }\n\n    public static void main(String[] args) {\n        new Main().run();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n\npublic class Main{\n\nstatic PrintWriter out;\nstatic InputReader ir;\nstatic int[] p=new int[101],q=new int[101],r=new int[101],b=new int[101],par=new int[101];\n\nstatic void solve(){\n int n;\n while((n=ir.nextInt())!=0){\n  for(int i=0;i<n;i++){\n   p[i]=ir.nextInt();\n   q[i]=ir.nextInt();\n   r[i]=ir.nextInt();\n   b[i]=ir.nextInt();\n   par[r[i]]=par[b[i]]=i+1;\n   long g=gcd(p[i],q[i]);\n   p[i]/=(int)g;\n   q[i]/=(int)g;\n  }\n  int now=1;\n  while(par[now]!=0) now=par[now];\n  out.println(dfs(now));\n  Arrays.fill(par,0);\n }\n}\n\npublic static int dfs(int m){\n int now=m-1;\n if(r[now]==0&&b[now]==0) return (long)p[now]+(long)q[now];\n if(r[now]==0){\n  long bb=dfs(b[now]);\n  return bb/gcd(q[now],bb)*(p[now]+q[now]);\n }\n if(b[now]==0){\n  long rr=dfs(r[now]);\n  return rr/gcd(p[now],rr)*(p[now]+q[now]);\n }\n long bb=dfs(b[now]),rr=dfs(r[now]);\n int g=gcd(bb*p[now],rr*q[now]);\n return rr*(long)q[now]/g*bb+bb*(long)p[now]/g*rr;\n}\n\npublic static long gcd(long a,long b){\n if(b==0) return a;\n return gcd(b,a%b);\n}\n\npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n\nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n\n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n\n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n \n public boolean hasNext(){skip(); return hasNextByte();}\n \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n\n public double nextDouble(){return Double.parseDouble(next());}\n\n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n\n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n\n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Lightest Mobile\npublic class Main{\n\n\tstatic long gcd(long a, long b){\n\t\tif(a < b){\n\t\t\tlong tmp = a;\n\t\t\ta = b;\n\t\t\tb = tmp;\n\t\t}\n\t\twhile(b!=0){\n\t\t\tlong r = a%b;\n\t\t\ta = b;\n\t\t\tb = r;\n\t\t}\n\t\treturn a;\n\t}\n\n\tclass R{\n\t\tint p, q;\n\t\tR l, r, parent;\n\t\tpublic R() {\n\t\t\tl = r = parent = null;\n\t\t}\n\t\tlong solve(){\n\t\t\tlong left = l.p==0?1:(l.p+l.q);\n\t\t\tlong right = r.p==0?1:(r.p+r.q);\n\t\t\tlong g = gcd(left, right);\n\t\t\tlong x = left*right/g;\n//\t\t\tSystem.out.println(\"Left:\" + left + \" Right:\" + right + \" GCD:\" + g + \" X:\" + x);\n//\t\t\tSystem.out.println(\"P:\" + p + \" Q:\" + q);\n\t\t\tlong val = x;\n\t\t\twhile(true){\n//\t\t\t\tSystem.out.println(\"val:\" + val);\n\t\t\t\tif(val%(p+q)==0){\n\t\t\t\t\tlong s = val/(p+q);\n\t\t\t\t\tif(l.f(s*q)&&r.f(s*p))break;\n\t\t\t\t}\n\t\t\t\tval+=x;\n\t\t\t}\n\t\t\treturn val;\n\t\t}\n\t\tboolean f(long x){\n\t\t\tif(p==0)return true;\n\t\t\tif(x%(p+q)!=0)return false;\n\t\t\tlong s = x/(p+q);\n\t\t\treturn l.f(s*q)&&r.f(s*p);\n\t\t}\n\t}\n\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tR[] s = new R[n+1];\n\t\t\tfor(int i=0;i<=n;i++)s[i]=new R();\n\t\t\tfor(int i=1;i<=n;i++){\n\t\t\t\ts[i].p = sc.nextInt();\n\t\t\t\ts[i].q = sc.nextInt();\n\t\t\t\tlong g = gcd(s[i].p, s[i].q);\n\t\t\t\ts[i].p/=g;\n\t\t\t\ts[i].q/=g;\n\t\t\t\tint l = sc.nextInt();\n\t\t\t\tint r = sc.nextInt();\n\t\t\t\ts[i].l = s[l];\n\t\t\t\ts[i].r = s[r];\n\t\t\t\ts[l].parent = s[i];\n\t\t\t\ts[r].parent = s[i];\n\t\t\t}\n\t\t\tR root = null;\n\t\t\tfor(int i=1;i<=n;i++)if(s[i].parent==null)root = s[i];\n\t\t\tSystem.out.println(root.solve());\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n\npublic class Main{\n\nstatic PrintWriter out;\nstatic InputReader ir;\nstatic int[] p=new int[101],q=new int[101],r=new int[101],b=new int[101],par=new int[101];\nstatic boolean[] done =new boolean[101];\n\nstatic void solve(){\n int n;\n while((n=ir.nextInt())!=0){\n  for(int i=0;i<n;i++){\n   p[i]=ir.nextInt();\n   q[i]=ir.nextInt();\n   r[i]=ir.nextInt();\n   b[i]=ir.nextInt();\n   par[r[i]]=par[b[i]]=i+1;\n   long g=gcd(p[i],q[i]);\n   p[i]/=(int)g;\n   q[i]/=(int)g;\n  }\n  int now;\n  long ans=0;\n  for(int i=0;i<n;i++){\n   if(done[i]) continue;\n   now=i+1;\n   while(par[now]!=0) now=par[now];\n   ans+=dfs(now);\n  }\n  out.println(ans);\n  Arrays.fill(par,0);\n  Arrays.fill(done,false);\n }\n}\n\npublic static long dfs(int m){\n int now=m-1;\n done[now]=true;\n if(r[now]==0&&b[now]==0) return (long)p[now]+(long)q[now];\n if(r[now]==0){\n  long bb=dfs(b[now]);\n  return bb/gcd(q[now],bb)*(p[now]+q[now]);\n }\n if(b[now]==0){\n  long rr=dfs(r[now]);\n  return rr/gcd(p[now],rr)*(p[now]+q[now]);\n }\n long bb=dfs(b[now]),rr=dfs(r[now]);\n long g=gcd(bb*p[now],rr*q[now]);\n return rr*(long)q[now]/g*bb+bb*(long)p[now]/g*rr;\n}\n\npublic static long gcd(long a,long b){\n if(b==0) return a;\n return gcd(b,a%b);\n}\n\npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n\nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n\n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n\n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n \n public boolean hasNext(){skip(); return hasNextByte();}\n \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n\n public double nextDouble(){return Double.parseDouble(next());}\n\n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n\n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n\n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.StringTokenizer;\n\n/**\n * Lightest Mobile\n */\npublic class Main {\n\n\tstatic Main main = new Main();\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line = \"\";\n\n\t\tMobile mobile = null;\n\t\twhile (!(line = br.readLine()).equals(\"0\")) {\n\t\t\tint n = Integer.parseInt(line);\n\n\t\t\tmobile = main.new Mobile();\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tline = br.readLine();\n\t\t\t\tmobile.add(i, line);\n\t\t\t}\n\t\t\tSystem.err.println(mobile.calc());\n\t\t}\n\t}\n\n\tclass Mobile {\n\t\tArrayList<Bar> mobile = new ArrayList<Bar>();\n\n\t\t// 棒をモービルに追加\n\t\tvoid add(int id, String info) {\n\t\t\tHangableImpr parent, left, right;\n\t\t\tint lid, rid;\n\t\t\tint lengthL, lengthR;\n\n\t\t\tStringTokenizer st = new StringTokenizer(info);\n\t\t\tlengthL = Integer.parseInt(st.nextToken());\n\t\t\tlengthR = Integer.parseInt(st.nextToken());\n\n\t\t\t// 親の棒\n\t\t\tif ((parent = find(id)) == null) {\n\t\t\t\tparent = new Bar(id, null);\n\t\t\t}\n\t\t\t((Bar) parent).lengthL = lengthL;\n\t\t\t((Bar) parent).lengthR = lengthR;\n\n\t\t\tlid = Integer.parseInt(st.nextToken());\n\t\t\trid = Integer.parseInt(st.nextToken());\n\n\t\t\t// 左の棒\n\t\t\tif (lid == 0) {\n\t\t\t\tleft = new Spindle();\n\t\t\t\tleft.parent = parent;\n\t\t\t} else {\n\t\t\t\tif ((left = find(lid)) == null) {\n\t\t\t\t\tleft = new Bar(lid, (Bar) parent);\n\t\t\t\t} else {\n\t\t\t\t\t((Bar) left).parent = (Bar) parent;\n\t\t\t\t\tmobile.remove(left);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// 右の棒\n\t\t\tif (rid == 0) {\n\t\t\t\tright = new Spindle();\n\t\t\t\tright.parent = parent;\n\t\t\t} else {\n\t\t\t\tif ((right = find(rid)) == null) {\n\t\t\t\t\tright = new Bar(rid, (Bar) parent);\n\t\t\t\t} else {\n\t\t\t\t\t((Bar) right).parent = (Bar) parent;\n\t\t\t\t\tmobile.remove(right);\n\t\t\t\t}\n\t\t\t}\n\t\t\t((Bar) parent).left = left;\n\t\t\t((Bar) parent).right = right;\n\t\t\tif (((Bar) parent).parent == null) {\n\t\t\t\tmobile.add((Bar) parent);\n\t\t\t}\n\t\t}\n\n\t\t// 指定した id の棒を検索\n\t\tBar find(int id) {\n\t\t\tBar result = null;\n\t\t\tfor (Bar b : mobile) {\n\t\t\t\tresult = b.find(id);\n\t\t\t\tif (result != null)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tlong calc() {\n\t\t\tlong result = 0;\n\t\t\tfor (Bar b : mobile) {\n\t\t\t\tb.calc();\n\t\t\t\tresult = b.weight;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t//\n\tinterface Hangable {\n\t\tHangable find(int id);\n\t}\n\n\tabstract class HangableImpr implements Hangable {\n\t\tHangableImpr parent;\n\t\tlong weight = 0;\n\t}\n\n\tclass Spindle extends HangableImpr {\n\t\t// int weight = 0;\n\t\t// Bar parent;\n\n\t\tSpindle() {\n\t\t\tthis.weight = 0;\n\t\t}\n\n\t\tSpindle(int weight) {\n\t\t\tthis.weight = weight;\n\t\t}\n\n\t\tpublic Spindle find(int id) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tclass Bar extends HangableImpr {\n\t\tint id;\n\t\tint lengthL, lengthR;\n\t\t// Bar parent;\n\t\tHangableImpr parent, left, right;\n\n\t\tBar(int id, Bar parent) {\n\t\t\tthis.id = id;\n\t\t\tthis.parent = parent;\n\t\t}\n\n\t\tpublic Bar find(int id) {\n\t\t\tBar result = null;\n\t\t\tif (this.id == id)\n\t\t\t\tresult = this;\n\t\t\tif (result == null && left != null)\n\t\t\t\tresult = (Bar) left.find(id);\n\t\t\tif (result == null && right != null)\n\t\t\t\tresult = (Bar) right.find(id);\n\t\t\treturn result;\n\t\t}\n\n\t\tvoid calc() {\n\t\t\tif (left instanceof Bar) {\n\t\t\t\t((Bar) left).calc();\n\t\t\t}\n\t\t\tif (right instanceof Bar) {\n\t\t\t\t((Bar) right).calc();\n\t\t\t}\n\n\t\t\tlong gcd = gcd(lengthL, lengthR);\n\t\t\tlong tempL, tempR;\n\t\t\tlong weightL, weightR;\n\n\t\t\ttempL = lengthL / gcd;\n\t\t\ttempR = lengthR / gcd;\n\t\t\tweightL = left.weight;\n\t\t\tweightR = right.weight;\n\n\t\t\tif (weightL == 0 && weightR == 0) {\n\t\t\t\tleft.weight = tempR;\n\t\t\t\tright.weight = tempL;\n\t\t\t} else if (weightL != 0 && weightR == 0) {\n\t\t\t\tlong lcm = lcm(tempR, lcm(tempL, weightL));\n\t\t\t\tleft.weight = lcm / tempL;\n\t\t\t\tright.weight = lcm / tempR;\n\t\t\t} else if (weightL == 0 && weightR != 0) {\n\t\t\t\tlong lcm = lcm(tempL, lcm(tempR, weightR));\n\t\t\t\tleft.weight = lcm / tempL;\n\t\t\t\tright.weight = lcm / tempR;\n\t\t\t} else {\n\t\t\t\tlong lcm = lcm(lcm(tempL, weightL), lcm(tempR, weightR));\n\t\t\t\tleft.weight = lcm / tempL;\n\t\t\t\tright.weight = lcm / tempR;\n\t\t\t}\n\t\t\tweight = left.weight + right.weight;\n\t\t}\n\t}\n\n\t// 最小公倍数\n\tstatic long lcm(long l, long r) {\n\t\tlong gt = l > r ? l : r;\n\t\tlong lt = l < r ? l : r;\n\t\treturn lt * gt / gcd(l, r);\n\t}\n\n\tstatic long lcm(long l, long r, long gcd) {\n\t\tlong gt = l > r ? l : r;\n\t\tlong lt = l < r ? l : r;\n\t\treturn lt * gt / gcd;\n\t}\n\n\t// 最大公約数\n\tstatic long gcd(long l, long r) {\n\t\tlong mod;\n\t\tlong gt = l > r ? l : r;\n\t\tlong lt = l < r ? l : r;\n\n\t\tdo {\n\t\t\tmod = gt % lt;\n\t\t\tgt = lt;\n\t\t\tlt = mod;\n\t\t} while (mod != 0);\n\n\t\treturn gt;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n\npublic class Main{\n\nstatic PrintWriter out;\nstatic InputReader ir;\nstatic int[] p=new int[101],q=new int[101],r=new int[101],b=new int[101],par=new int[101];\n\nstatic void solve(){\n int n;\n while((n=ir.nextInt())!=0){\n  for(int i=0;i<n;i++){\n   p[i]=ir.nextInt();\n   q[i]=ir.nextInt();\n   r[i]=ir.nextInt();\n   b[i]=ir.nextInt();\n   par[r[i]]=par[b[i]]=i+1;\n   int g=gcd(p[i],q[i]);\n   p[i]/=g;\n   q[i]/=g;\n  }\n  int now=1;\n  while(par[now]!=0) now=par[now];\n  out.println(dfs(now));\n  Arrays.fill(par,0);\n }\n}\n\npublic static int dfs(int m){\n int now=m-1;\n if(r[now]==0&&b[now]==0) return p[now]+q[now];\n if(r[now]==0){\n  int bb=dfs(b[now]);\n  return bb/gcd(p[now],bb)*(p[now]+q[now]);\n }\n if(b[now]==0){\n  int rr=dfs(r[now]);\n  return rr/gcd(q[now],rr)*(p[now]+q[now]);\n }\n int bb=dfs(b[now]),rr=dfs(r[now]);\n int t=bb*p[now]/gcd(bb*p[now],rr*q[now])*rr*q[now];\n return t/p[now]+t/q[now];\n}\n\npublic static int gcd(int a,int b){\n if(b==0) return a;\n return gcd(b,a%b);\n}\n\npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n\nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n\n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n\n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n \n public boolean hasNext(){skip(); return hasNextByte();}\n \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n\n public double nextDouble(){return Double.parseDouble(next());}\n\n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n\n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n\n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n\npublic class Main{\n\nstatic PrintWriter out;\nstatic InputReader ir;\nstatic int[] p=new int[101],q=new int[101],r=new int[101],b=new int[101],par=new int[101];\n\nstatic void solve(){\n int n;\n while(true){\n  n=ir.nextInt();\n  if(n==0) break;\n  for(int i=0;i<n;i++){\n   p[i+1]=ir.nextInt();\n   q[i+1]=ir.nextInt();\n   r[i+1]=ir.nextInt();\n   b[i+1]=ir.nextInt();\n   par[r[i+1]]=par[b[i+1]]=i+1;\n   long g=gcd(p[i+1],q[i+1]);\n   p[i+1]/=(int)g;\n   q[i+1]/=(int)g;\n  }\n  int now=1;\n  while(par[now]!=0) now=par[now];\n  out.println(dfs(now));\n  Arrays.fill(par,0);\n }\n}\n\npublic static long dfs(int now){\n if(now==0) return 1;\n long bb=dfs(b[now]),rr=dfs(r[now]);\n long g=gcd(bb*p[now],rr*q[now]);\n return rr*(long)q[now]/g*bb+bb*(long)p[now]/g*rr;\n}\n\npublic static long gcd(long a,long b){\n if(b==0) return a;\n return gcd(b,a%b);\n}\n\npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n\nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n\n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n\n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n \n public boolean hasNext(){skip(); return hasNextByte();}\n \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n\n public double nextDouble(){return Double.parseDouble(next());}\n\n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n\n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n\n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.StringTokenizer;\n\n/**\n * Lightest Mobile\n */\npublic class Main {\n\n\tstatic Main main = new Main();\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line = \"\";\n\n\t\t// int d = 0;\n\t\tMobile mobile = null;\n\t\twhile (!(line = br.readLine()).equals(\"0\")) {\n\t\t\tint n = Integer.parseInt(line);\n\t\t\t// d++;\n\n\t\t\tmobile = main.new Mobile();\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tline = br.readLine();\n\t\t\t\tmobile.add(i, line);\n\t\t\t}\n\t\t\t// if (d == 11)\n\t\t\t// System.err.println(mobile.mobile.size());\n\t\t\tSystem.out.println(mobile.calc());\n\t\t}\n\t}\n\n\tclass Mobile {\n\t\tArrayList<Bar> mobile = new ArrayList<Bar>();\n\n\t\t// 棒をモービルに追加\n\t\tvoid add(int id, String info) {\n\t\t\tHangableImpr parent, left, right;\n\t\t\tint lid, rid;\n\t\t\tint lengthL, lengthR;\n\n\t\t\tStringTokenizer st = new StringTokenizer(info);\n\t\t\tlengthL = Integer.parseInt(st.nextToken());\n\t\t\tlengthR = Integer.parseInt(st.nextToken());\n\n\t\t\t// 親の棒\n\t\t\tif ((parent = find(id)) == null) {\n\t\t\t\tparent = new Bar(id, null);\n\t\t\t}\n\t\t\t((Bar) parent).lengthL = lengthL;\n\t\t\t((Bar) parent).lengthR = lengthR;\n\n\t\t\tlid = Integer.parseInt(st.nextToken());\n\t\t\trid = Integer.parseInt(st.nextToken());\n\n\t\t\t// 左の棒\n\t\t\tif (lid == 0) {\n\t\t\t\tleft = new Spindle();\n\t\t\t\tleft.parent = parent;\n\t\t\t} else {\n\t\t\t\tif ((left = find(lid)) == null) {\n\t\t\t\t\tleft = new Bar(lid, (Bar) parent);\n\t\t\t\t} else {\n\t\t\t\t\t((Bar) left).parent = (Bar) parent;\n\t\t\t\t\tmobile.remove(left);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// 右の棒\n\t\t\tif (rid == 0) {\n\t\t\t\tright = new Spindle();\n\t\t\t\tright.parent = parent;\n\t\t\t} else {\n\t\t\t\tif ((right = find(rid)) == null) {\n\t\t\t\t\tright = new Bar(rid, (Bar) parent);\n\t\t\t\t} else {\n\t\t\t\t\t((Bar) right).parent = (Bar) parent;\n\t\t\t\t\tmobile.remove(right);\n\t\t\t\t}\n\t\t\t}\n\t\t\t((Bar) parent).left = left;\n\t\t\t((Bar) parent).right = right;\n\t\t\tif (((Bar) parent).parent == null) {\n\t\t\t\tmobile.add((Bar) parent);\n\t\t\t}\n\t\t}\n\n\t\t// 指定した id の棒を検索\n\t\tBar find(int id) {\n\t\t\tBar result = null;\n\t\t\tfor (Bar b : mobile) {\n\t\t\t\tresult = b.find(id);\n\t\t\t\tif (result != null)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tlong calc() {\n\t\t\tlong result = 0;\n\t\t\tfor (Bar b : mobile) {\n\t\t\t\tb.calc();\n\t\t\t\tresult = b.weight;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t//\n\tinterface Hangable {\n\t\tHangable find(int id);\n\t}\n\n\tabstract class HangableImpr implements Hangable {\n\t\tHangableImpr parent;\n\t\tlong weight = 0;\n\t}\n\n\tclass Spindle extends HangableImpr {\n\t\t// int weight = 0;\n\t\t// Bar parent;\n\n\t\tSpindle() {\n\t\t\tthis.weight = 0;\n\t\t}\n\n\t\tSpindle(int weight) {\n\t\t\tthis.weight = weight;\n\t\t}\n\n\t\tpublic Spindle find(int id) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tclass Bar extends HangableImpr {\n\t\tint id;\n\t\tint lengthL, lengthR;\n\t\t// Bar parent;\n\t\tHangableImpr parent, left, right;\n\n\t\tBar(int id, Bar parent) {\n\t\t\tthis.id = id;\n\t\t\tthis.parent = parent;\n\t\t}\n\n\t\tpublic Bar find(int id) {\n\t\t\tBar result = null;\n\t\t\tif (this.id == id)\n\t\t\t\tresult = this;\n\t\t\tif (result == null && left != null)\n\t\t\t\tresult = (Bar) left.find(id);\n\t\t\tif (result == null && right != null)\n\t\t\t\tresult = (Bar) right.find(id);\n\t\t\treturn result;\n\t\t}\n\n\t\tvoid calc() {\n\t\t\tif (left instanceof Bar) {\n\t\t\t\t((Bar) left).calc();\n\t\t\t}\n\t\t\tif (right instanceof Bar) {\n\t\t\t\t((Bar) right).calc();\n\t\t\t}\n\n\t\t\tlong gcd = gcd(lengthL, lengthR);\n\t\t\tlong tempL, tempR;\n\t\t\tlong weightL, weightR;\n\n\t\t\ttempL = lengthL / gcd;\n\t\t\ttempR = lengthR / gcd;\n\t\t\tweightL = left.weight;\n\t\t\tweightR = right.weight;\n\n\t\t\tif (weightL == 0 && weightR == 0) {\n\t\t\t\tleft.weight = tempR;\n\t\t\t\tright.weight = tempL;\n\t\t\t} else if (weightL != 0 && weightR == 0) {\n\t\t\t\tlong lcm = lcm(tempR, lcm(tempL, weightL));\n\t\t\t\tleft.weight = lcm / tempL;\n\t\t\t\tright.weight = lcm / tempR;\n\t\t\t} else if (weightL == 0 && weightR != 0) {\n\t\t\t\tlong lcm = lcm(tempL, lcm(tempR, weightR));\n\t\t\t\tleft.weight = lcm / tempL;\n\t\t\t\tright.weight = lcm / tempR;\n\t\t\t} else {\n\t\t\t\tlong lcm = lcm(lcm(tempL, weightL), lcm(tempR, weightR));\n\t\t\t\tleft.weight = lcm / tempL;\n\t\t\t\tright.weight = lcm / tempR;\n\t\t\t}\n\t\t\tweight = left.weight + right.weight;\n\t\t}\n\t}\n\n\t// 最小公倍数\n\tstatic long lcm(long l, long r) {\n\t\tlong gt = l > r ? l : r;\n\t\tlong lt = l < r ? l : r;\n\t\treturn lt * (gt / gcd(l, r));\n\t}\n\n\tstatic long lcm(long l, long r, long gcd) {\n\t\tlong gt = l > r ? l : r;\n\t\tlong lt = l < r ? l : r;\n\t\treturn lt * (gt / gcd);\n\t}\n\n\t// 最大公約数\n\tstatic long gcd(long l, long r) {\n\t\tlong mod;\n\t\tlong gt = l > r ? l : r;\n\t\tlong lt = l < r ? l : r;\n\n\t\tdo {\n\t\t\tmod = gt % lt;\n\t\t\tgt = lt;\n\t\t\tlt = mod;\n\t\t} while (mod != 0);\n\n\t\treturn gt;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n\npublic class Main{\n\nstatic PrintWriter out;\nstatic InputReader ir;\nstatic int[] p=new int[101],q=new int[101],r=new int[101],b=new int[101],par=new int[101];\n\nstatic void solve(){\n int n;\n while((n=ir.nextInt())!=0){\n  for(int i=0;i<n;i++){\n   p[i]=ir.nextInt();\n   q[i]=ir.nextInt();\n   r[i]=ir.nextInt();\n   b[i]=ir.nextInt();\n   par[r[i]]=par[b[i]]=i+1;\n   int g=gcd(p[i],q[i]);\n   p[i]/=g;\n   q[i]/=g;\n  }\n  int now=1;\n  while(par[now]!=0) now=par[now];\n  out.println(dfs(now));\n  Arrays.fill(par,0);\n }\n}\n\npublic static int dfs(int m){\n int now=m-1;\n if(r[now]==0&&b[now]==0) return p[now]+q[now];\n if(r[now]==0){\n  int bb=dfs(b[now]);\n  return bb/gcd(q[now],bb)*(p[now]+q[now]);\n }\n if(b[now]==0){\n  int rr=dfs(r[now]);\n  return rr/gcd(p[now],rr)*(p[now]+q[now]);\n }\n int bb=dfs(b[now]),rr=dfs(r[now]);\n int t=bb*p[now]/gcd(bb*p[now],rr*q[now])*rr*q[now];\n return t/p[now]+t/q[now];\n}\n\npublic static int gcd(int a,int b){\n if(b==0) return a;\n return gcd(b,a%b);\n}\n\npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n\nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n\n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n\n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n \n public boolean hasNext(){skip(); return hasNextByte();}\n \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n\n public double nextDouble(){return Double.parseDouble(next());}\n\n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n\n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n\n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.StringTokenizer;\n\n/**\n * Lightest Mobile\n */\npublic class Main {\n\n\tstatic Main main = new Main();\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line = \"\";\n\n\t\t// int d = 0;\n\t\tMobile mobile = null;\n\t\twhile (!(line = br.readLine()).equals(\"0\")) {\n\t\t\tint n = Integer.parseInt(line);\n\t\t\t// d++;\n\n\t\t\tmobile = main.new Mobile();\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tline = br.readLine();\n\t\t\t\tmobile.add(i, line);\n\t\t\t}\n\t\t\t// if (d == 11)\n\t\t\t// System.err.println(mobile.mobile.size());\n\t\t\tSystem.out.println(mobile.calc());\n\t\t}\n\t}\n\n\tclass Mobile {\n\t\tArrayList<Bar> mobile = new ArrayList<Bar>();\n\n\t\t// 棒をモービルに追加\n\t\tvoid add(int id, String info) {\n\t\t\tHangableImpr parent, left, right;\n\t\t\tint lid, rid;\n\t\t\tint lengthL, lengthR;\n\n\t\t\tStringTokenizer st = new StringTokenizer(info);\n\t\t\tlengthL = Integer.parseInt(st.nextToken());\n\t\t\tlengthR = Integer.parseInt(st.nextToken());\n\n\t\t\t// 親の棒\n\t\t\tif ((parent = find(id)) == null) {\n\t\t\t\tparent = new Bar(id, null);\n\t\t\t}\n\t\t\t((Bar) parent).lengthL = lengthL;\n\t\t\t((Bar) parent).lengthR = lengthR;\n\n\t\t\tlid = Integer.parseInt(st.nextToken());\n\t\t\trid = Integer.parseInt(st.nextToken());\n\n\t\t\t// 左の棒\n\t\t\tif (lid == 0) {\n\t\t\t\tleft = new Spindle();\n\t\t\t\tleft.parent = parent;\n\t\t\t} else {\n\t\t\t\tif ((left = find(lid)) == null) {\n\t\t\t\t\tleft = new Bar(lid, (Bar) parent);\n\t\t\t\t} else {\n\t\t\t\t\t((Bar) left).parent = (Bar) parent;\n\t\t\t\t\tmobile.remove(left);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// 右の棒\n\t\t\tif (rid == 0) {\n\t\t\t\tright = new Spindle();\n\t\t\t\tright.parent = parent;\n\t\t\t} else {\n\t\t\t\tif ((right = find(rid)) == null) {\n\t\t\t\t\tright = new Bar(rid, (Bar) parent);\n\t\t\t\t} else {\n\t\t\t\t\t((Bar) right).parent = (Bar) parent;\n\t\t\t\t\tmobile.remove(right);\n\t\t\t\t}\n\t\t\t}\n\t\t\t((Bar) parent).left = left;\n\t\t\t((Bar) parent).right = right;\n\t\t\tif (((Bar) parent).parent == null) {\n\t\t\t\tmobile.add((Bar) parent);\n\t\t\t}\n\t\t}\n\n\t\t// 指定した id の棒を検索\n\t\tBar find(int id) {\n\t\t\tBar result = null;\n\t\t\tfor (Bar b : mobile) {\n\t\t\t\tresult = b.find(id);\n\t\t\t\tif (result != null)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tlong calc() {\n\t\t\tlong result = 0;\n\t\t\tfor (Bar b : mobile) {\n\t\t\t\tb.calc();\n\t\t\t\tresult = b.weight;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t//\n\tinterface Hangable {\n\t\tHangable find(int id);\n\t}\n\n\tabstract class HangableImpr implements Hangable {\n\t\tHangableImpr parent;\n\t\tlong weight = 0;\n\t}\n\n\tclass Spindle extends HangableImpr {\n\t\t// int weight = 0;\n\t\t// Bar parent;\n\n\t\tSpindle() {\n\t\t\tthis.weight = 0;\n\t\t}\n\n\t\tSpindle(int weight) {\n\t\t\tthis.weight = weight;\n\t\t}\n\n\t\tpublic Spindle find(int id) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tclass Bar extends HangableImpr {\n\t\tint id;\n\t\tint lengthL, lengthR;\n\t\t// Bar parent;\n\t\tHangableImpr parent, left, right;\n\n\t\tBar(int id, Bar parent) {\n\t\t\tthis.id = id;\n\t\t\tthis.parent = parent;\n\t\t}\n\n\t\tpublic Bar find(int id) {\n\t\t\tBar result = null;\n\t\t\tif (this.id == id)\n\t\t\t\tresult = this;\n\t\t\tif (result == null && left != null)\n\t\t\t\tresult = (Bar) left.find(id);\n\t\t\tif (result == null && right != null)\n\t\t\t\tresult = (Bar) right.find(id);\n\t\t\treturn result;\n\t\t}\n\n\t\tvoid calc() {\n\t\t\tif (left instanceof Bar) {\n\t\t\t\t((Bar) left).calc();\n\t\t\t}\n\t\t\tif (right instanceof Bar) {\n\t\t\t\t((Bar) right).calc();\n\t\t\t}\n\n\t\t\tlong gcd = gcd(lengthL, lengthR);\n\t\t\tlong tempL, tempR;\n\t\t\tlong weightL, weightR;\n\n\t\t\ttempL = lengthL / gcd;\n\t\t\ttempR = lengthR / gcd;\n\t\t\tweightL = left.weight;\n\t\t\tweightR = right.weight;\n\n\t\t\tif (weightL == 0 && weightR == 0) {\n\t\t\t\tleft.weight = tempR;\n\t\t\t\tright.weight = tempL;\n\t\t\t} else if (weightL != 0 && weightR == 0) {\n\t\t\t\tlong lcm = lcm(tempR, lcm(tempL, weightL));\n\t\t\t\tleft.weight = lcm / tempR;\n\t\t\t\tright.weight = lcm / tempL;\n\t\t\t} else if (weightL == 0 && weightR != 0) {\n\t\t\t\tlong lcm = lcm(tempL, lcm(tempR, weightR));\n\t\t\t\tleft.weight = lcm / tempR;\n\t\t\t\tright.weight = lcm / tempL;\n\t\t\t} else {\n\t\t\t\tlong lcm = lcm(lcm(tempL, weightL), lcm(tempR, weightR));\n\t\t\t\tleft.weight = lcm / tempR;\n\t\t\t\tright.weight = lcm / tempL;\n\t\t\t}\n\t\t\tweight = left.weight + right.weight;\n\t\t}\n\t}\n\n\t// 最小公倍数\n\tstatic long lcm(long l, long r) {\n\t\tlong gt = l > r ? l : r;\n\t\tlong lt = l < r ? l : r;\n\t\treturn lt * (gt / gcd(l, r));\n\t}\n\n\tstatic long lcm(long l, long r, long gcd) {\n\t\tlong gt = l > r ? l : r;\n\t\tlong lt = l < r ? l : r;\n\t\treturn lt * (gt / gcd);\n\t}\n\n\t// 最大公約数\n\tstatic long gcd(long l, long r) {\n\t\tlong mod;\n\t\tlong gt = l > r ? l : r;\n\t\tlong lt = l < r ? l : r;\n\n\t\tdo {\n\t\t\tmod = gt % lt;\n\t\t\tgt = lt;\n\t\t\tlt = mod;\n\t\t} while (mod != 0);\n\n\t\treturn gt;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Lightest Mobile\n */\npublic class Main {\n\n\tstatic int[][] bars;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\tString[] words;\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tint n = parseInt(line);\n\t\t\tif (n == 0) break;\n\n\t\t\tbars = new int[n + 1][4];\n\t\t\tint top = n * (n + 1) / 2;\n\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\t\t\tfor (int j = 0; j < 4; j++) {\n\t\t\t\t\tbars[i][j] = parseInt(st.nextToken());\n\t\t\t\t}\n\t\t\t\ttop -= bars[i][2];\n\t\t\t\ttop -= bars[i][3];\n\t\t\t}\n\n\t\t\tSystem.out.println(solve(bars[top]));\n\n\t\t}\n\t}\n\n\tstatic long solve(int[] bar) {\n\n\t\tint p, q, r, b;\n\t\tp = bar[0];\n\t\tq = bar[1];\n\t\tr = bar[2];\n\t\tb = bar[3];\n\n\t\tlong lcm, _r, _b;\n\n\t\tif (r == 0 && b == 0) {\n\t\t\treturn (p + q) / gcd(p, q);\n\t\t} else if (r != 0) {\n\t\t\tlcm = lcm(p, lcm(p, solve(bars[r])));\n\t\t} else {\n\t\t\tlcm = lcm(p, lcm(p, solve(bars[b])));\n\t\t}\n\n\t\t_r = (lcm / p + q) * q;\n\t\t_b = (lcm / p + q) * p;\n\n\t\treturn _r + _b;\n\t}\n\n\tstatic long gcd(long a, long b) {\n\t\tif (b == 0) return a;\n\t\treturn gcd(b, a % b);\n\t}\n\n\tstatic long lcm(long a, long b) {\n\t\treturn a * (b / gcd(a, b));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Lightest Mobile\n */\npublic class Main {\n\n\tstatic Bar[] bars;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\tString[] words;\n\n\t\tMain main = new Main();\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tint n = parseInt(line);\n\t\t\tif (n == 0) break;\n\n\t\t\tbars = new Bar[n + 1];\n\t\t\tfor (int i = 0; i <= n; i++) {\n\t\t\t\tbars[i] = main.new Bar();\n\t\t\t}\n\n\t\t\tStringTokenizer st;\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\tint p, q, r, b;\n\t\t\t\tp = parseInt(st.nextToken());\n\t\t\t\tq = parseInt(st.nextToken());\n\t\t\t\tr = parseInt(st.nextToken());\n\t\t\t\tb = parseInt(st.nextToken());\n\t\t\t\tbars[i].p = p;\n\t\t\t\tbars[i].q = q;\n\t\t\t\tif (r != 0) {\n\t\t\t\t\tbars[i].r = bars[r];\n\t\t\t\t\tbars[r].parent = bars[i];\n\t\t\t\t}\n\t\t\t\tif (b != 0) {\n\t\t\t\t\tbars[i].b = bars[b];\n\t\t\t\t\tbars[b].parent = bars[i];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = 1; i <= n; i++) {\n\t\t\t\tif (bars[i].parent == null) {\n\t\t\t\t\tSystem.out.println(bars[i].weight());\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\tstatic long gcd(long a, long b) {\n\t\tif (b == 0) return a;\n\t\treturn gcd(b, a % b);\n\t}\n\n\tstatic long lcm(long a, long b) {\n\t\treturn a * (b / gcd(a, b));\n\t}\n\n\tclass Bar {\n\t\tlong p, q;\n\t\tBar parent, r, b;\n\n\t\tBar() {\n\t\t}\n\n\t\tlong weight() {\n\n\t\t\tlong _p, _q, gcd = 1;\n\t\t\tgcd = gcd(p, q);\n\t\t\t_p = p / gcd;\n\t\t\t_q = q / gcd;\n\n\t\t\tif (r == null && b == null) return (_p + _q) / gcd(_p, _q);\n\n\t\t\tlong _r = 1, _b = 1, lcm = 1;\n\t\t\tif (r != null) _r = r.weight();\n\t\t\tif (b != null) _b = b.weight();\n\t\t\tlcm = lcm(lcm(_p, _q), lcm(_r, _b));\n\t\t\t_r = lcm / _p;\n\t\t\t_b = lcm / _q;\n\t\t\treturn _r + _b;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n\npublic class Main{\n\nstatic PrintWriter out;\nstatic InputReader ir;\nstatic int[] p=new int[101],q=new int[101],r=new int[101],b=new int[101],par=new int[101];\n\nstatic void solve(){\n int n;\n while((n=ir.nextInt())!=0){\n  for(int i=0;i<n;i++){\n   p[i]=ir.nextInt();\n   q[i]=ir.nextInt();\n   r[i]=ir.nextInt();\n   b[i]=ir.nextInt();\n   par[r[i]]=par[b[i]]=i+1;\n   long g=gcd(p[i],q[i]);\n   p[i]/=(int)g;\n   q[i]/=(int)g;\n  }\n  int now=1;\n  while(par[now]!=0) now=par[now];\n  out.println(dfs(now));\n  Arrays.fill(par,0);\n }\n}\n\npublic static int dfs(int m){\n int now=m-1;\n if(r[now]==0&&b[now]==0) return (long)p[now]+q[now];\n if(r[now]==0){\n  long bb=dfs(b[now]);\n  return bb/gcd(q[now],bb)*(p[now]+q[now]);\n }\n if(b[now]==0){\n  long rr=dfs(r[now]);\n  return rr/gcd(p[now],rr)*(p[now]+q[now]);\n }\n long bb=dfs(b[now]),rr=dfs(r[now]);\n int g=gcd(bb*p[now],rr*q[now]);\n return rr*q[now]/g*bb+bb*p[now]/g*rr;\n}\n\npublic static long gcd(long a,long b){\n if(b==0) return a;\n return gcd(b,a%b);\n}\n\npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n\nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n\n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n\n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n \n public boolean hasNext(){skip(); return hasNextByte();}\n \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n\n public double nextDouble(){return Double.parseDouble(next());}\n\n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n\n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n\n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main{\n\n\tint INF = 1 << 28;\n\tint n;\n\tint map[][];\n\tint w[];\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tn = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tmap =  new int[n][4];\n\t\t\tfor(int i=0;i<n;i++) for(int j=0;j<4;j++){\n\t\t\t\tmap[i][j] = sc.nextInt();\n\t\t\t}\n\t\t\tw = new int[n+1];\n\t\t\tfill(w, -1);\n\t\t\tint max = 0;\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tmax = max(max, solve(i) );\n\t\t\t}\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n\t\n\tint solve(int i) {\n//\t\tdebug(i);\n\t\tif( w[i] >= 0 ) return w[i];\n\t\tint l = map[i][2] != 0? solve(map[i][2]-1): 1;\n\t\tint r = map[i][3] != 0? solve(map[i][3]-1): 1;\n\t\tint wait = 0;\n\t\twait = lcm(l * map[i][0], r * map[i][1]);\n//\t\tdebug(l, r, l*map[i][0], r*map[i][1], wait);\n\t\twait = wait / map[i][0] + wait / map[i][1];\n\t\treturn w[i] = wait;\n\t\t\n\t}\n\t\n\tint lcm(int x, int y) {\n\t\tint x_ = x;\n\t\tint y_ = y;\n\t\tint z = x_ % y_;\n\t\twhile(z != 0) {\n\t\t\tx_ = y_;\n\t\t\ty_ = z;\n\t\t\tz = x_ % y_;\n\t\t}\n\t\treturn x / y_ * y;\n\t\t\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n\npublic class Main{\n\nstatic PrintWriter out;\nstatic InputReader ir;\nstatic int[] p=new int[101],q=new int[101],r=new int[101],b=new int[101],par=new int[101];\n\nstatic void solve(){\n int n;\n while((n=ir.nextInt())!=0){\n  for(int i=0;i<n;i++){\n   p[i]=ir.nextInt();\n   q[i]=ir.nextInt();\n   r[i]=ir.nextInt();\n   b[i]=ir.nextInt();\n   par[r[i]]=p[b[i]]=i+1;\n   int g=gcd(p[i],q[i]);\n   p[i]/=g;\n   q[i]/=g;\n  }\n  int now=1;\n  while(par[now]!=0) now=par[now];\n  out.println(dfs(now));\n  Arrays.fill(par,0);\n }\n}\n\npublic static int dfs(int m){\n int now=m-1;\n if(r[now]==0&&b[now]==0) return p[now]+q[now];\n if(r[now]==0){\n  int bb=dfs(b[now]);\n  return bb/gcd(p[now],bb)*(p[now]+q[now]);\n }\n if(b[now]==0){\n  int rr=dfs(r[now]);\n  return rr/gcd(q[now],rr)*(p[now]+q[now]);\n }\n int bb=dfs(b[now]),rr=dfs(r[now]);\n return bb*p[now]/gcd(bb*p[now],rr*q[now])*rr*q[now];\n}\n\npublic static int gcd(int a,int b){\n if(b==0) return a;\n return gcd(b,a%b);\n}\n\npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n\nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n\n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n\n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n \n public boolean hasNext(){skip(); return hasNextByte();}\n \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n\n public double nextDouble(){return Double.parseDouble(next());}\n\n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n\n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n\n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\n\npublic class P\n{\n    public int min { get; set; }\n    public int L { get; set; }\n    public int r { get; set; }\n    public int Ln { get; set; }\n    public int rn { get; set; }\n}\n\npublic class hello\n{\n    public static void Main()\n    {\n        while (true)\n        {\n            var n = int.Parse(Console.ReadLine().Trim());\n            if (n == 0) break;\n            var ps = new P[n];\n            var child = new bool[n];\n            for (int i = 0; i < n; i++)\n            {\n                string[] line = Console.ReadLine().Trim().Split(' ');\n                var a = int.Parse(line[0]);\n                var b = int.Parse(line[1]);\n                var c = int.Parse(line[2]);\n                var d = int.Parse(line[3]);\n                var abgcd = Gcd(a, b);\n                a /= abgcd;\n                b /= abgcd;\n                if (c == 0 && d == 0)\n                    ps[i] = new P { min = a + b };\n                else\n                {\n                    ps[i] = new P { L = a, r = b, Ln = c - 1, rn = d - 1 };\n                    if (c != 0) child[c - 1] = true;\n                    if (d != 0) child[d - 1] = true;\n                }\n            }\n            var parent = 0;\n            for (int i = 0; i < n; i++)\n                if (!child[i]) { parent = i; break; }\n            var ans = getAns(ps, parent);\n            Console.WriteLine(ans);\n        }\n    }\n    static int getAns(P[] ps, int t)\n    {\n        var w = ps[t];\n        if (w.min > 0) return w.min;\n        if (w.Ln != -1 && w.rn != -1)\n        {\n            var a1 = getAns(ps, w.Ln);\n            var a2 = getAns(ps, w.rn);\n            var x = w.r * a2;\n            var y = w.L * a1;\n            var ww = Gcd(x, y);\n            x /= ww;\n            y /= ww;\n            return x * a1 + y * a2;\n        }\n        if (w.rn != -1)\n        {\n            var tww = getAns(ps, w.rn);\n            var a = w.r * tww;\n            var y = w.L;\n            var ww = Gcd(a, y);\n            a /= ww;\n            y /= ww;\n            return a + y * tww;\n        }\n        if (w.Ln != -1)\n        {\n            var tww = getAns(ps, w.Ln);\n            var a = w.L * tww;\n            var y = w.r;\n            var ww = Gcd(a, y);\n            a /= ww;\n            y /= ww;\n            return a + y * tww;\n        }\n        return 0;\n    }\n    static int Gcd(int a, int b)\n    {\n        if (a < b) return Gcd(b, a);\n        while (b != 0)\n        {\n            var w = a % b;\n            a = b;\n            b = w;\n        }\n        return a;\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\n \nclass TEST{\n\tstatic void Main(){\n\t\twhile(true){\n\t\t\tint n=int.Parse(Console.ReadLine());\n\t\t\tif(n==0)break;\n\t\t\tSol mySol =new Sol(n);\n\t\t\tmySol.Solve();\n\t\t}\n\t}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\t\n\t\tlong[] Weight=new long[N];\n\t\tfor(int i=0;i<N;i++)Weight[i]=0;\n\t\t\n\t\t\n\t\tfor(int i=0;i<N;i++){\n\t\t\tlong g=gcd(Mob[i][0],Mob[i][1]);\n\t\t\tMob[i][0]/=g;\n\t\t\tMob[i][1]/=g;\n\t\t\tif(Mob[i][2]==0 && Mob[i][3]==0)Weight[i]=Mob[i][0]+Mob[i][1];\n\t\t}\n\t\tbool chk=true;\n\t\twhile(chk){\n\n\t\t\tchk=false;\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tif(Weight[i]!=0)continue;\n\t\t\t\tif(Mob[i][2]!=0 && Weight[Mob[i][2]-1]==0){\n\t\t\t\t\tchk=true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(Mob[i][3]!=0 && Weight[Mob[i][3]-1]==0){\n\t\t\t\t\tchk=true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tlong wl=1;\n\t\t\t\tif(Mob[i][2]!=0 && Weight[Mob[i][2]-1]!=0)wl=Weight[Mob[i][2]-1];\n\t\t\t\tlong wr=1;\n\t\t\t\tif(Mob[i][3]!=0 && Weight[Mob[i][3]-1]!=0)wr=Weight[Mob[i][3]-1];\n\t\t\t\t\n\t\t\t\tlong lcm=wl*wr*Mob[i][0]*Mob[i][1]/gcd(wl*Mob[i][0],wr*Mob[i][1]);\n\t\t\t\tlong rl=lcm/(wl*Mob[i][0]);\n\t\t\t\tlong rr=lcm/(wr*Mob[i][1]);\n\t\t\t\tWeight[i]=rl*wl+rr*wr;\n\t\t\t}\n\t\t}\n\t\t\n\t\tlong Max=0;\n\t\tfor(int i=0;i<N;i++)if(Max<Weight[i])Max=Weight[i];\n\t\t\n\t\tConsole.WriteLine(\"{0}\",Max);\n\t\t\n\t}\n\n\tint N;\n\tlong[][] Mob;\n\tpublic Sol(int n){\n\t\tN=n;\n\t\tMob=new long[N][];\n\t\tfor(int i=0;i<N;i++)Mob[i]=rla();\n\t}\n\n\tlong gcd(long a,long b){\n\t\tif(b==0)return a;\n\t\treturn gcd(b,a%b);\n\t}\n\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(){return Console.ReadLine().Split(' ');}\n\tstatic int[] ria(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));}\n\tstatic long[] rla(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>long.Parse(e));}\n\tstatic double[] rda(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>double.Parse(e));}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\n \nclass TEST{\n\tstatic void Main(){\n\t\twhile(true){\n\t\t\tint n=int.Parse(Console.ReadLine());\n\t\t\tif(n==0)break;\n\t\t\tSol mySol =new Sol(n);\n\t\t\tmySol.Solve();\n\t\t}\n\t}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\t\n\t\tlong[] Weight=new long[N];\n\t\tfor(int i=0;i<N;i++)Weight[i]=0;\n\t\t\n\t\t\n\t\tfor(int i=0;i<N;i++){\n\t\t\tlong g=gcd(Mob[i][0],Mob[i][1]);\n\t\t\tMob[i][0]/=g;\n\t\t\tMob[i][1]/=g;\n\t\t\tif(Mob[i][2]==0 && Mob[i][3]==0)Weight[i]=Mob[i][0]+Mob[i][1];\n\t\t}\n\t\tbool chk=true;\n\t\twhile(chk){\n\t\t\tchk=false;\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tif(Weight[i]!=0)continue;\n\t\t\t\tif(Weight[i]==0){\n\t\t\t\t\tif(Mob[i][2]!=0 && Mob[i][3]!=0){\n\t\t\t\t\tif(Weight[Mob[i][2]-1]==0 &&Weight[Mob[i][3]-1]==0){\n\t\t\t\t\t\tchk=true;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tlong wl=1;\n\t\t\t\tif(Mob[i][2]!=0 && Weight[Mob[i][2]-1]!=0)wl=Weight[Mob[i][2]-1];\n\t\t\t\tlong wr=1;\n\t\t\t\tif(Mob[i][3]!=0 && Weight[Mob[i][3]-1]!=0)wr=Weight[Mob[i][3]-1];\n\t\t\t\t\n\t\t\t\tlong lcm=wl*wr*Mob[i][0]*Mob[i][1]/gcd(wl*Mob[i][0],wr*Mob[i][1]);\n\t\t\t\tlong rl=lcm/(wl*Mob[i][0]);\n\t\t\t\tlong rr=lcm/(wr*Mob[i][1]);\n\t\t\t\tWeight[i]=rl*wl+rr*wr;\n\t\t\t}\n\t\t}\n\t\t\n\t\tlong Max=0;\n\t\tfor(int i=0;i<N;i++)if(Max<Weight[i])Max=Weight[i];\n\t\t\n\t\tConsole.WriteLine(\"{0}\",Max);\n\t\t\n\t}\n\n\tint N;\n\tlong[][] Mob;\n\tpublic Sol(int n){\n\t\tN=n;\n\t\tMob=new long[N][];\n\t\tfor(int i=0;i<N;i++)Mob[i]=rla();\n\t}\n\n\tlong gcd(long a,long b){\n\t\tif(b==0)return a;\n\t\treturn gcd(b,a%b);\n\t}\n\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(){return Console.ReadLine().Split(' ');}\n\tstatic int[] ria(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));}\n\tstatic long[] rla(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>long.Parse(e));}\n\tstatic double[] rda(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>double.Parse(e));}\n}"
  },
  {
    "language": "JavaScript",
    "code": "var n;\nvar t = [];\n\nfunction gcd(a, b){\n\treturn b > 0 ? gcd(b, a % b) : a;\n}\n\nfunction solve(i){\n\tif(i == -1){\n\t\treturn 1;\n\t}\n\n\tvar a = solve(t[i][2]);\n\tvar b = solve(t[i][3]);\n\tvar c = gcd(a, t[i][0]);\n\tvar d = gcd(b, t[i][1]);\n\tvar p = a / c;\n\tvar q = b / d;\n\tvar g = gcd(p, q);\n\treturn (p * q / g) * (t[i][0] + t[i][1]);\n}\n\nfunction main(){\n\twhile(n = scan()){\n\t\trep(n, function(i){\n\t\t\tvar a = scan();\n\t\t\tvar b = scan();\n\t\t\tvar g = gcd(a, b);\n\t\t\tt[i] = [b / g, a / g, scan() - 1, scan() - 1];\n\t\t});\n\t\tvar c = [];\n\t\trep(n, function(i){\n\t\t\tc[t[i][2]] = c[t[i][3]] = true;\n\t\t});\n\t\tvar p;\n\t\trep(n, function(i){\n\t\t\tif(!c[i]){\n\t\t\t\tp = i;\n\t\t\t}\n\t\t});\n\t\tprint(solve(p));\n\t}\n}\n \nfunction rep(a, b, c){\n\tif(c === undefined){\n\t\tc = b;\n\t\tb = a;\n\t\ta = 0;\n\t}\n\tfor(var i = a; i < b; ++i){\n\t\tif(c(i) === false){\n\t\t\tbreak;\n\t\t}\n\t}\n}\n \nprocess.stdin.resume();\nprocess.stdin.setEncoding('utf8');\n \nvar input = '';\nvar input_index = 0;\n \nfunction scan(type){\n\tif(type === 'string'){\n\t\treturn input[input_index++];\n\t}\n\telse{\n\t\treturn +input[input_index++];\n\t}\n}\n \nfunction print(val){\n\tconsole.log(val);\n}\n \nprocess.stdin.on('data', function(chunk){\n\tinput += chunk;\n});\nprocess.stdin.on('end', function(){\n\tinput = input.trim().split(/\\s+/);\n\tmain();\n});"
  },
  {
    "language": "Ruby",
    "code": "class Integer\n  def gcd(other)\n    min = self.abs\n    max = other.abs\n    while min > 0\n      tmp = min\n      min = max % min\n      max = tmp\n    end\n    max\n  end\nend\n\nclass AOJ0520\n  def initialize(n)\n    @n = n\n    @poles = []\n  end\n\n  def solve\n    @n.times{ @poles << gets.split.map(&:to_i) }\n\n    top = ((1..@n).to_a - @poles.map{ |p| [p[2], p[3]] }.flatten)[0]\n\n    weight(top-1)\n  end\n\n  def weight(id)\n    r = (@poles[id][2] == 0 ? 1 : weight(@poles[id][2]-1))\n    l = (@poles[id][3] == 0 ? 1 : weight(@poles[id][3]-1))\n\n    p = @poles[id][0]\n    q = @poles[id][1]\n\n    a = r*l*p / (l*p).gcd(r*q)\n    b = r*l*q / (l*p).gcd(r*q)\n\n    a+b\n  end\nend\n\nn = 0\n\nputs AOJ0520.new(n).solve while (n = gets.chomp.to_i) != 0"
  },
  {
    "language": "Ruby",
    "code": "class Bar\n  def initialize p, q, r, b\n    @p = p\n    @q = q\n    @r = r\n    @b = b\n    @ref_count = 0\n    @left = nil\n    @right = nil\n  end\n\n  def w\n    l = @left.w * @p\n    r = @right.w * @q\n    lcm = (l * r) / euclid(l, r)\n    lcm / @p + lcm / @q\n  end\n\n  attr_accessor :left, :right, :ref_count\n  attr_reader :p, :q, :r, :b\nend\n\nclass Weight\n  def initialize\n    @w = 1\n  end\n  attr_reader :w\nend\n\ndef main\n  loop do\n    n = gets.chomp.to_i\n    break if n == 0\n    bars = Array.new(n+1, nil)\n    (1..n).each do |i|\n      p,q,r,b = gets.chomp.split.map(&:to_i)\n      bars[i] = Bar.new(p, q, r, b)\n    end\n\n    weight = Weight.new\n    (1..n).each do |i|\n      if bars[i].r == 0\n        bars[i].left = weight\n      else\n        bars[i].left = bars[bars[i].r]\n        bars[i].left.ref_count += 1\n      end\n\n      if bars[i].b == 0\n        bars[i].right = weight\n      else\n        bars[i].right = bars[bars[i].b]\n        bars[i].right.ref_count += 1\n      end\n    end\n\n    root = nil\n    (1..n).each do |i|\n      if bars[i].ref_count == 0\n        root = bars[i]\n        break\n      end\n    end\n\n    puts root.w\n  end\nend\n\ndef euclid a, b\n  m = (a > b ? a : b)\n  n = (a <= b ? a : b)\n  loop do\n    r = m % n\n    m = n\n    n = r\n    break if n == 0\n  end\n  m\nend\n\nmain"
  },
  {
    "language": "Ruby",
    "code": "### main\n\nloop do\n  n = gets.strip.to_i\n  break if n == 0\n\n  poles = []\n  parents = n.times.map{[]}\n  fixed = n.times.map{0}\n\n  for i in (0...n)\n    p, q, r, b = gets.strip.split(' ').map{|s| s.to_i}\n    g = p.gcd(q)\n    r -= 1\n    b -= 1\n    poles << [p / g, q / g, r, b]\n\n    if r >= 0\n      parents[r] << i\n    else\n      fixed[i] += 1\n    end\n\n    if b >= 0\n      parents[b] << i\n    else\n      fixed[i] += 1\n    end\n  end\n  #p poles\n  #p parents\n  #p fixed\n\n  min_w = nil\n  min_ws = []\n  queue = (0...n).select{|i| fixed[i] == 2}.to_a\n\n  while ! queue.empty?\n    i = queue.shift\n    p, q, r, b = poles[i]\n\n    if r < 0\n      if b < 0\n        min_ws[i] = p + q\n      else\n        ## p * wr == q * wb (wr = nr * mwr, wb = nb * mwb)\n        ## l = lcm(p, q * mwb) ->\n        ## wr = l / p, wb = l / q\n        ## wr + wq = l/p + l/q\n        l = p.lcm(q * min_ws[b])\n        min_ws[i] = l / p + l / q\n      end\n    else\n      if b < 0\n        l = q.lcm(p * min_ws[r])\n        min_ws[i] = l / p + l / q\n      else\n        l = (p * min_ws[r]).lcm(q * min_ws[b])\n        min_ws[i] = l / p + l / q\n      end\n    end\n    #puts \"#{i} -> #{min_ws[i]}\"\n\n    min_w = min_ws[i]\n\n    for j in parents[i]\n      fixed[j] += 1\n      if fixed[j] == 2\n        queue << j\n      end\n    end\n  end\n  #p min_ws\n\n  puts min_w\nend"
  },
  {
    "language": "Ruby",
    "code": "# ユークリッドの互除法で最大公約数を求める\ndef d(n,m)\n  if m == 0\n    n\n  else\n    d(m, n % m)\n  end\nend\n\n# 棒の左右の最小重量から棒以下のモビールの重量を求める\ndef weight(bo)\n  # boが錘である\n  if bo[0] == 0\n    return 1\n  else\n    w_red  = weight($boes[bo[2]])\n    w_blue = weight($boes[bo[3]])\n    l_red  = bo[0]\n    l_blue = bo[1]\n    m_min = l_red * l_blue * w_red * w_blue / d(l_red * w_red, l_blue * w_blue)\n    return m_min/l_red + m_min/l_blue\n  end\nend\n\n# main\nloop do\n  n = gets.to_i\n  break if n == 0\n  $boes = []*(n+1)\n  $boes[0] = [0,0,0,0]\n  for i in 1..n do\n    $boes[i] = gets.split(\" \").map(&:to_i)\n  end\n\n  # 一番上の棒を探す\n  is_child = Array.new(n+1) {false}\n  for i in 1..n do\n    is_child[$boes[i][2]] = true\n    is_child[$boes[i][3]] = true\n  end\n  top = is_child.index(false)\n\n  # 一番上から再帰的にモビールの重量を求める\n  res = weight($boes[top])\n  puts res\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'rational'\n\nclass AOJ0520\n  def initialize(n)\n    @n = n\n    @poles = []\n  end\n\n  def solve\n    @n.times{ @poles << gets.split.map(&:to_i) }\n\n    top = ((1..@n).to_a - @poles.map{ |p| [p[2], p[3]] }.flatten)[0]\n\n    weight(top-1)\n  end\n\n  def weight(id)\n    r = (@poles[id][2] == 0 ? 1 : weight(@poles[id][2]-1))\n    l = (@poles[id][3] == 0 ? 1 : weight(@poles[id][3]-1))\n\n    p = @poles[id][0]\n    q = @poles[id][1]\n\n    a = (r*q).lcm(l*p) / q\n    b = (r*q).lcm(l*p) / p\n\n    a+b\n  end\nend\n\nn = 0\n\nputs AOJ0520.new(n).solve while (n = gets.chomp.to_i) != 0"
  },
  {
    "language": "Ruby",
    "code": "require 'rational'\n\nclass AOJ0520\n  def initialize(n)\n    @n = n\n    @poles = []\n  end\n\n  def solve\n    @n.times{ @poles << gets.split.map(&:to_i) }\n\n    top = ((1..@n).to_a - @poles.map{ |p| [p[2], p[3]] }.flatten)[0]\n\n    weight(top-1)\n  end\n\n  def weight(id)\n    r = (@poles[id][2] == 0 ? 1 : weight(@poles[id][2]-1))\n    l = (@poles[id][3] == 0 ? 1 : weight(@poles[id][3]-1))\n\n    p = @poles[id][0]\n    q = @poles[id][1]\n\n    a = (r*p).lcm(l*q) / q\n    b = (r*p).lcm(l*q) / p\n\n    a+b\n  end\nend\n\nwhile (n = gets.chomp.to_i) != 0\n  puts AOJ0520.new(n).solve\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'rational'\n\nclass AOJ0520\n  def initialize(n)\n    @n = n\n    @poles = []\n  end\n\n  def solve\n    @n.times{ @poles << gets.split.map(&:to_i) }\n\n    top = ((1..@n).to_a - @poles.map{ |p| [p[2], p[3]] }.flatten)[0]\n\n    weight(top-1)\n  end\n\n  def weight(id)\n    r = (@poles[id][2] == 0 ? 1 : weight(@poles[id][2]-1))\n    l = (@poles[id][3] == 0 ? 1 : weight(@poles[id][3]-1))\n\n    p = @poles[id][0]\n    q = @poles[id][1]\n\n    a = (r*q).lcm(l*p) / q\n    b = (r*q).lcm(l*p) / p\n\n    a+b\n  end\nend\n\nwhile (n = gets.chomp.to_i) != 0\n  puts AOJ0520.new(n).solve\nend"
  },
  {
    "language": "Ruby",
    "code": "class AOJ0520\n  def initialize(n)\n    @n = n\n    @poles = []\n  end\n\n  def solve\n    @n.times{ @poles << gets.split.map(&:to_i) }\n\n    top = ((1..@n).to_a - @poles.map{ |p| [p[2], p[3]] }.flatten)[0]\n\n    weight(top-1)\n  end\n\n  def weight(id)\n    r = (@poles[id][2] == 0 ? 1 : weight(@poles[id][2]-1))\n    l = (@poles[id][3] == 0 ? 1 : weight(@poles[id][3]-1))\n\n    p = @poles[id][0]\n    q = @poles[id][1]\n\n    a = r*l*p / (l*p).gcd(r*q)\n    b = r*l*q / (l*p).gcd(r*q)\n\n    a+b\n  end\nend\n\nn = 0\n\nputs AOJ0520.new(n).solve while (n = gets.chomp.to_i) != 0"
  },
  {
    "language": "D",
    "code": "import core.stdc.stdio;\n\nlong gcd(long a,long b){\n\treturn b?gcd(b,a%b):a;\n}\n\nlong lcd(long a,long b){\n\treturn a/gcd(a,b)*b;\n}\n\nvoid main(){\n\twhile(1){\n\t\n\tint n;\n\tscanf(\"%d\",&n);\n\tif(!n)\n\t\tbreak;\n\tauto p=new long[n],q=new long[n];\n\tauto r=new int[n],b=new int[n],ic=new int[n];\n\tforeach(i;0..n){\n\t\tscanf(\"%lld%lld%d%d\",&p[i],&q[i],&r[i],&b[i]);\n\t\tif(--r[i]>=0)\n\t\t\tic[r[i]]++;\n\t\tif(--b[i]>=0)\n\t\t\tic[b[i]]++;\n\t}\n\tint root;\n\tforeach(int i,c;ic)\n\t\tif(!c)\n\t\t\troot=i;\n\tlong dfs(int i){\n\t\tif(i<0)\n\t\t\treturn 1;\n\t\tlong s=dfs(r[i]),t=dfs(b[i]);\n\t\t//s*p[i]=t*q[i]\n\t\tlong l=lcd(s*p[i],t*q[i]);\n\t\ts=l/p[i];\n\t\tt=l/q[i];\n\t\treturn s+t;\n\t}\n\tprintf(\"%lld\\n\",dfs(root));\n\t\n\t}\n}"
  },
  {
    "language": "Python",
    "code": "import math\nclass Mobile:\n    def __init__(self,leftratio=0,rightratio=0,left=-1,right=-1):\n        self.weight = 0\n        self.leftratio = leftratio\n        self.rightratio = rightratio\n        self.left = left\n        self.leftweight = 0\n        self.right = right\n        self.rightweight = 0\n\n    def calc(self):\n        if self.weight != 0 : return self.weight\n\n        if self.left == -1:\n            self.leftweight = 1\n        else:\n            self.leftweight = Mobile.calc(self.left)\n        if self.right == -1:\n            self.rightweight = 1\n        else:\n            self.rightweight = Mobile.calc(self.right)\n\n        lmoment = self.leftratio*self.leftweight\n        rmoment = self.rightratio*self.rightweight\n        lcs = lmoment * rmoment // math.gcd(lmoment,rmoment)\n        self.weight = (lcs//self.leftratio) + (lcs//self.rightratio)\n\n        return self.weight\n\n    def stdout(self):\n        print(self.left, self.right)\n\nn = int(input())\nbarlist = [Mobile() for i in range(n)]\nfor i in range(n):\n    p,q,r,b = map(int, input().split())\n    barlist[i].leftratio = p\n    barlist[i].rightratio = q\n    if r != 0 : barlist[i].left = barlist[r-1]\n    if b != 0 : barlist[i].right = barlist[b-1]\n\nmaxi = 0\nfor i in range(n):\n    maxi = max(barlist[i].calc(),maxi)\n\nprint(maxi)"
  },
  {
    "language": "Python",
    "code": "def gcd(a, b):\n    r = a % b\n    if r:\n        return gcd(b, r)\n    return b\n\n\ndef lcm(a, b):\n    if a < b:\n        a, b = b, a\n    return a * b // gcd(a, b)\n\n\ndef min_weight(m):\n    p, q, r, b = bars[m - 1]\n    red = q * (min_weight(r) if r else 1)\n    blue = p * (min_weight(b) if b else 1)\n    equilibrium = lcm(red, blue)\n    return equilibrium // p + equilibrium // q\n\n\nwhile True:\n    n = int(input())\n    if not n:\n        break\n\n    bars = [tuple(map(int, input().split())) for _ in range(n)]\n\n    root_bar = set(range(1, n + 1))\n    for _, _, r, b in bars:\n        if r: root_bar.remove(r)\n        if b: root_bar.remove(b)\n\n    print(min_weight(root_bar.pop()))"
  },
  {
    "language": "Python",
    "code": "# AOJ0520\n\nimport sys\n\ndef gcd(x, y):\n    if x < y:\n        x, y = y, x\n    while x % y != 0:\n        x, y = y, x % y\n    return y\n    \nclass frac:\n    def __init__(self, n, d):\n        self.num = n\n        self.den = d\n    \n    def mul(self, yn, yd):\n        xn, xd = self.num, self.den\n        xn *= yn\n        xd *= yd\n        if xn != 0 and xd != 0:\n            g = gcd(xn, xd)\n            xn /= g\n            xd /= g\n        return frac(xn, xd)\n    \n    def is_zero(self):\n        return self.num == 0\n    \n    def output(self):\n        return \"{}/{}\".format(self.num, self.den)      \n            \nclass LightestMobile:\n    def __init__(self, n):\n        self.n = n + 1\n        self.mobile = [[0,0,0,0]]\n        self.weight = [[frac(0,1), frac(0,1)]]\n        self.denom = []\n\n    def read(self, p, q, r, b):\n        self.mobile.append([p, q, r, b])\n        self.weight.append([frac(0,1), frac(0,1)])\n    \n    \n    def root(self):\n        for i in range(1, self.n):\n            m = self.mobile[i]\n            if m[2] == 0 and m[3] == 0:\n                return self.parent(i)\n    \n    def parent(self, c):\n        for i in range(1, self.n):\n            m = self.mobile[i]\n            if i != c and (m[2] == c or m[3] == c):\n                return self.parent(i)\n        return c\n    \n    def solve(self, i):\n        self.solve2(i, frac(0,1))\n        lcm = 1\n        for d in self.denom:\n            lcm = lcm * d / gcd(lcm, d)\n        answer = self.weight[i][0].mul(lcm, 1).num + self.weight[i][1].mul(lcm, 1).num\n        return int(answer)\n    \n    def solve2(self, i, wlr):\n        p, q, r, b = self.mobile[i]\n#        print(\"p,q,r,b=\", self.mobile[i])\n#        print(\"i, wlr=\", i, wlr.output())\n        if wlr.is_zero():\n            g = gcd(p, q)\n            p /= g\n            q /= g\n            self.weight[i] = [frac(q, 1), frac(p, 1)]\n        else:\n            self.weight[i] = [wlr.mul(q, p + q), wlr.mul(p, p + q)]\n        if r != 0:\n            self.solve2(r, self.weight[i][0])\n        if b != 0:\n            self.solve2(b, self.weight[i][1])\n        if r == 0 and b == 0:\n            if not self.weight[i][0].is_zero() and not self.weight[i][1].is_zero():\n                self.denom.append(self.weight[i][0].den)\n                self.denom.append(self.weight[i][1].den)\n        return\n\nif __name__ == '__main__':\n    while True:\n        line = input()\n        n = int(line)\n        if n == 0:\n            break\n        lm = LightestMobile(n)\n        for _ in range(0, n):\n            p, q, r, b = map(int, list(input().split()))\n            lm.read(p, q, r, b)\n        rt = lm.root()\n        print(lm.solve(rt))\n        del lm\n"
  },
  {
    "language": "Python",
    "code": "from math import gcd\nwhile True:\n  try:\n    n = int(input())\n    if not n: break\n    lst = [[]]\n    weight = [-1 for i in range(n + 1)]\n    def setWeight(n):\n      p,q,r,b = lst[n]\n      if weight[n] != -1:pass\n      elif r == 0 and b == 0:\n        weight[n] = (p + q) // gcd(p,q)\n      elif r == 0:\n        setWeight(b)\n        wb = weight[b]\n        g = gcd(wb * q, p)\n        lcm = wb * q * p // g\n        weight[n] = lcm // q + lcm // p\n        print(\"wr:\",str(lcm//p),\"wb:\",str(wb),\"g:\",g,\"p:\",p,\"lcm\",lcm)\n      elif b == 0:\n        setWeight(r)\n        wr = weight[r]\n        g = gcd(wr * p, q)\n        lcm = wr * p * q // g\n        weight[n] = lcm // p + lcm // q\n      else:\n        if weight[r] == -1: setWeight(r)\n        if weight[b] == -1: setWeight(b)\n        wr = weight[r]\n        wb = weight[b]\n        g = gcd(wr * p, wb * q)\n        lcm = wr * p * wb  * q // g\n        weight[n] = lcm // p + lcm // q\n    for i in range(n):\n      lst.append(list(map(int,input().split())))\n    for i in range(0,n):\n      if weight[i + 1] == -1:\n        setWeight(i+1)\n    print(max(weight))\n    print(weight)\n  except EOFError:\n    break\n\n\n"
  },
  {
    "language": "Python",
    "code": "\nfrom math import gcd\ndef lcm(i, j):\n  return i * j // gcd(i, j)\ndef main():\n  while True:\n    n = int(input())\n    if not n: break\n    lst = [[]]\n    weight = [-1 for i in range(n + 1)]\n    def setWeight(n):\n      p, q, r, b = lst[n]\n      if weight[n] != -1: pass\n      elif r == 0 and b == 0:\n        weight[n] = (p + q) // gcd(p, q)\n      elif r == 0:\n        setWeight(b)\n        l = lcm(weight[b] * q, p)\n        weight[n] = l // q + l // p\n      elif b == 0:\n        setWeight(r)\n        l = lcm(weight[r] * p, q)\n        weight[n] = l // p + l // q\n      else:\n        if weight[r] == -1: setWeight(r)\n        if weight[b] == -1: setWeight(b)\n        l = lcm(weight[r] * p, weight[b]  * q)\n        weight[n] = l // p + l // q\n    for i in range(n):\n      lst.append(list(map(int,input().split())))\n    for i in range(0, n):\n      if weight[i + 1] == -1:\n        setWeight(i + 1)\n    print(max(weight))\n\nif __name__ == '__main__':\n  main()\n"
  },
  {
    "language": "Python",
    "code": "\ndef gcd(x,y):\n    if x<y:\n        tmp = x\n        x = y\n        y = tmp\n    if x%y == 0:\n        return y\n    else:\n        gcd(y,x%y)\n\nclass Mobile:\n    def __init__(self,leftratio=0,rightratio=0,left=-1,right=-1):\n        self.weight = 0\n        self.leftratio = leftratio\n        self.rightratio = rightratio\n        self.left = left\n        self.leftweight = 0\n        self.right = right\n        self.rightweight = 0\n\n    def calc(self):\n        if self.weight != 0 : return self.weight\n\n        if self.left == -1:\n            self.leftweight = 1\n        else:\n            self.leftweight = Mobile.calc(self.left)\n        if self.right == -1:\n            self.rightweight = 1\n        else:\n            self.rightweight = Mobile.calc(self.right)\n\n        lmoment = self.leftratio*self.leftweight\n        rmoment = self.rightratio*self.rightweight\n        lcs = lmoment * rmoment // gcd(lmoment,rmoment)\n        self.weight = (lcs//self.leftratio) + (lcs//self.rightratio)\n\n        return self.weight\n\n    def stdout(self):\n        print(self.left, self.right)\n\nwhile True:\n    n = int(input())\n    if n==0: break\n    barlist = [Mobile() for i in range(n)]\n    for i in range(n):\n        p,q,r,b = map(int, input().split())\n        barlist[i].leftratio = p\n        barlist[i].rightratio = q\n        if r != 0 : barlist[i].left = barlist[r-1]\n        if b != 0 : barlist[i].right = barlist[b-1]\n\n    maxi = 0\n    for i in range(n):\n        maxi = max(barlist[i].calc(),maxi)\n\n    print(maxi)"
  },
  {
    "language": "Python",
    "code": "from math import gcd\ndef lcm(i,j):\n  return i * j // gcd(i,j)\ndef main():\n  while True:\n    n = int(input())\n    if not n: break\n    lst = [[]]\n    weight = [-1 for i in range(n + 1)]\n    def setWeight(n):\n      p,q,r,b = lst[n]\n      if weight[n] != -1:pass\n      elif r == 0 and b == 0:\n        weight[n] = (p + q) // gcd(p,q)\n      elif r == 0:\n        setWeight(b)\n        l = lcm(weight[b] * q, p)\n        weight[n] = l // q + l // p\n      elif b == 0:\n        setWeight(r)\n        l = lcm(weight(r) * p, q)\n        weight[n] = l // p + l // q\n      else:\n        if weight[r] == -1: setWeight(r)\n        if weight[b] == -1: setWeight(b)\n        l = lcm(weight[r] * p, weight[b]  * q)\n        weight[n] = l // p + l // q\n    for i in range(n):\n      lst.append(list(map(int,input().split())))\n    for i in range(0,n):\n      if weight[i + 1] == -1:\n        setWeight(i+1)\n    print(max(weight))\nif __name__ == '__main__':\n  main()\n\n"
  },
  {
    "language": "Python",
    "code": "\nfrom math import gcd\ndef lcm(i, j):\n  return i * j // gcd(i, j)\ndef main():\n  while True:\n    n = int(input())\n    if not n: break\n    lst = [[]]\n    weight = [-1 for i in range(n + 1)]\n    def setWeight(n):\n      p, q, r, b = lst[n]\n      if weight[n] != -1: pass\n      elif r == 0 and b == 0:\n        weight[n] = (p + q) // gcd(p, q)\n      elif r == 0:\n        setWeight(b)\n        l = lcm(weight[b] * q, p)\n        weight[n] = l // q + l // p\n      elif b == 0:\n        setWeight(r)\n        l = lcm(weight(r) * p, q)\n        weight[n] = l // p + l // q\n      else:\n        if weight[r] == -1: setWeight(r)\n        if weight[b] == -1: setWeight(b)\n        l = lcm(weight[r] * p, weight[b]  * q)\n        weight[n] = l // p + l // q\n    for i in range(n):\n      lst.append(list(map(int,input().split())))\n    for i in range(0, n):\n      if weight[i + 1] == -1:\n        setWeight(i + 1)\n    print(max(weight))\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "def solve():\n    from math import gcd\n    \n    # Post-order tree traversal\n    def traversal(bar_id):\n        if bar_id == 0:\n            return 1\n        p, q, r, b = nodes[bar_id]\n        r_w = traversal(r)\n        b_w = traversal(b)\n        cf = gcd(p * r_w, q * b_w)\n        \n        return r_w * b_w * (p + q) // cf\n    \n    from sys import stdin\n    file_input = stdin\n    \n    while True:\n        n = int(file_input.readline())\n        if n == 0:\n            break\n        \n        root_id = n * (n + 1) // 2\n        nodes = [None]\n        for i in range(1, n + 1):\n            p, q, r, b = map(int, file_input.readline().split())\n            g = gcd(p, q)\n            nodes.append((p // g, q // g, r, b))\n            root_id -= (r + b)\n        \n        print(traversal(root_id))\n\nsolve()\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n\ndef GCD(a, b):\n\tdummy1 = max(a, b)\n\tdummy2 = min(a, b)\n\twhile True:\n\t\tdummy = dummy1 % dummy2\n\t\tdummy1 = dummy2\n\t\tdummy2 = dummy\n\t\tif(dummy == 0):\n\t\t\tbreak\n\n\treturn dummy1\n\nwhile True:\n\tN = input()\n\tif not N:\n\t\tbreak\n\tcost = []\n\tE = []\n\troot = N * (N - 1) / 2\n\tfor i in range(N):\n\t\tS = raw_input().split()\n\t\tc1, c2, e1, e2 = list(map(int,S))\n\t\tcost.append((c1, c2))\n\t\troot -= e1 + e2\n\t\te1 -= 1\n\t\te2 -= 1\n\t\tE.append((e1, e2))\n\tdef nums(e):\n\t\tN_lst1 = []\n\t\tN_lst2 = []\n\t\tval_lst1 = []\n\t\tval_lst2 = []\n\t\tif E[e][0] != -1:\n\t\t\tN_lst1, val_lst1 = nums(E[e][0])\n\t\telse:\n\t\t\tN_lst1 = [1]\n\t\t\tval_lst1 = []\n\t\t\n\t\tif E[e][1] != -1:\n\t\t\tN_lst2, val_lst2 = nums(E[e][1])\n\t\telse:\n\t\t\tN_lst2 = [1]\n\t\t\tval_lst2 = []\n\t\t\n\t\tmul1 = cost[e][0]\n\t\tfor num in val_lst1:\n\t\t\tmul1 *= num\n\t\tmul2 = cost[e][1]\n\t\tfor num in val_lst2:\n\t\t\tmul2 *= num\n\t\tfor i in range(len(N_lst1)):\n\t\t\tN_lst1[i] *= mul2\n\t\tfor i in range(len(N_lst2)):\n\t\t\tN_lst2[i] *= mul1\n\t\t\n\t\treturn N_lst1 + N_lst2, val_lst1 + val_lst2 + [cost[e][0] + cost[e][1]]\n\tN_lst, v_lst = nums(root - 1)\n\t#print N_lst\n\tnum_GCD = N_lst[0]\n\tfor num in N_lst:\n\t\tnum_GCD = GCD(num, num_GCD)\n\t\n\tfor i in range(len(N_lst)):\n\t\tN_lst[i] //= num_GCD\n\t#print N_lst\n\tprint sum(N_lst)\n\t\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\n#fp = open(\"input.txt\", \"r\")\nfp = sys.stdin\n\ndef gcd(a, b):\n    return a if b == 0 else gcd(b, a%b)\n\nclass Mobile:\n    def __init__(self):\n        self.len_l = 0\n        self.len_r = 0\n        self.mob_l = None\n        self.mob_r = None\n        self.parent = None\n\n    def getWeight(self):\n        weight_l = 1 if self.mob_l == None else self.mob_l.getWeight()\n        weight_r = 1 if self.mob_r == None else self.mob_r.getWeight()\n\n        moment_l = self.len_l * weight_l\n        moment_r = self.len_r * weight_r\n\n        g = gcd(moment_l, moment_r)\n\n        n_l = moment_r / g\n        n_r = moment_l / g\n        \n        return weight_l * n_l + weight_r * n_r\n\n    def getRoot(self):\n        if self.parent == None:\n            return self\n        else:\n            return self.parent.getRoot()\n\n    def printTest(self):\n        print self.len_l,\n        print \", \",\n        print self.len_r\n\nwhile True:\n    n = int(fp.readline()[:-1])\n    if n == 0:\n        break\n\n    li = [Mobile() for i in xrange(n)]\n\n    for i in xrange(n):\n        ele = map(int, fp.readline()[:-1].split(\" \"))\n        li[i].num = i+1\n        li[i].len_l = ele[0]\n        li[i].len_r = ele[1]\n        if ele[2] != 0:\n            child = li[ele[2]-1]\n            li[i].mob_l = child\n            child.parent = li[i]\n        if ele[3] != 0:\n            child = li[ele[3]-1]\n            li[i].mob_r = child\n            child.parent = li[i]\n\n    print li[0].getRoot().getWeight()"
  },
  {
    "language": "Python",
    "code": "'''\nCreated on 2017/03/09\n\n@author: 03key\n'''\n\ndef gcd(x,y):\n    if x<y:\n        tmp = x\n        x = y\n        y = tmp\n    ans = y\n    if x%y != 0:\n        ans = gcd(y,x%y)\n    return ans\n\nclass Mobile:\n    def __init__(self,leftratio=0,rightratio=0,left=-1,right=-1):\n        self.weight = 0\n        self.leftratio = leftratio\n        self.rightratio = rightratio\n        self.left = left\n        self.leftweight = 0\n        self.right = right\n        self.rightweight = 0\n\n    def calc(self):\n        if self.weight != 0 : return self.weight\n\n        if self.left == -1:\n            self.leftweight = 1\n        else:\n            self.leftweight = Mobile.calc(self.left)\n        if self.right == -1:\n            self.rightweight = 1\n        else:\n            self.rightweight = Mobile.calc(self.right)\n\n        lmoment = self.leftratio*self.leftweight\n        rmoment = self.rightratio*self.rightweight\n        lcs = lmoment * rmoment // gcd(lmoment,rmoment)\n        self.weight = (lcs//self.leftratio) + (lcs//self.rightratio)\n\n        return self.weight\n\n    def stdout(self):\n        print(self.left, self.right)\n\nwhile True:\n    n = int(input())\n    if n==0: break\n    barlist = [Mobile() for i in range(n)]\n    for i in range(n):\n        p,q,r,b = map(int, input().split())\n        barlist[i].leftratio = p\n        barlist[i].rightratio = q\n        if r != 0 : barlist[i].left = barlist[r-1]\n        if b != 0 : barlist[i].right = barlist[b-1]\n\n    maxi = 0\n    for i in range(n):\n        maxi = max(barlist[i].calc(),maxi)\n\n    print(maxi)"
  },
  {
    "language": "Python",
    "code": "from math import gcd\nwhile True:\n  try:\n    n = int(input())\n    if not n: break\n    lst = [[]]\n    weight = [-1 for i in range(n + 1)]\n    def setWeight(n):\n      p,q,r,b = lst[n]\n      if weight[n] != -1:pass\n      elif r == 0 and b == 0:\n        weight[n] = (p + q) // gcd(p,q)\n      elif r == 0:\n        setWeight(b)\n        wb = weight[b]\n        g = gcd(wb * q, p)\n        lcm = wb * q * p // g\n        weight[n] = lcm // q + lcm // p\n#        print(\"wr:\",str(lcm//p),\"wb:\",str(wb),\"g:\",g,\"p:\",p,\"lcm\",lcm)\n      elif b == 0:\n        setWeight(r)\n        wr = weight[r]\n        g = gcd(wr * p, q)\n        lcm = wr * p * q // g\n        weight[n] = lcm // p + lcm // q\n      else:\n        if weight[r] == -1: setWeight(r)\n        if weight[b] == -1: setWeight(b)\n        wr = weight[r]\n        wb = weight[b]\n        g = gcd(wr * p, wb * q)\n        lcm = wr * p * wb  * q // g\n        weight[n] = lcm // p + lcm // q\n    for i in range(n):\n      lst.append(list(map(int,input().split())))\n    for i in range(0,n):\n      if weight[i + 1] == -1:\n        setWeight(i+1)\n    print(max(weight))\n#    print(weight)\n  except EOFError:\n    break\n\n\n"
  },
  {
    "language": "Python",
    "code": "\nfrom math import gcd\ndef lcm(i, j):\n  return i * j // gcd(i, j)\ndef main():\n  while True:\n    n = int(input())\n    if not n: break\n    lst = [[]]\n    weight = [-1 for i in range(n + 1)]\n    def setWeight(n):\n      p, q, r, b = lst[n]\n      if weight[n] != -1: pass\n      elif r == 0 and b == 0:\n        weight[n] = (p + q) // gcd(p, q)\n      elif r == 0:\n        setWeight(b)\n        l = lcm(weight[b] * q, p)\n        weight[n] = l // q + l // p\n      elif b == 0:\n        setWeight(r)\n        l = lcm(weight(r) * p, q)\n        weight[n] = l // p + l // q\n      else:\n        if weight[r] == -1: setWeight(r)\n        if weight[b] == -1: setWeight(b)\n        l = lcm(weight[r] * p, weight[b]  * q)\n        weight[n] = l // p + l // q\n    for i in range(n):\n      lst.append(list(map(int,input().split())))\n    for i in range(0, n):\n      if weight[i + 1] == -1:\n        setWeight(i + 1)\n    print(max(weight))\n\nif __name__ == '__main__':\n  main()\n\n"
  },
  {
    "language": "Python",
    "code": "from math import gcd\ndef lcm(i,j):\n  return i * j // gcd(i,j)\ndef main():\n  while True:\n    n = int(input())\n    if not n: break\n    lst = [[]]\n    weight = [-1 for i in range(n + 1)]\n    def setWeight(n):\n      p,q,r,b = lst[n]\n      if weight[n] != -1:pass\n      elif r == 0 and b == 0:\n        weight[n] = (p + q) // gcd(p,q)\n      elif r == 0:\n        setWeight(b)\n        l = lcm(weight[b] * q, p)\n        weight[n] = l // q + l // p\n      elif b == 0:\n        setWeight(r)\n        l = lcm(weight(r) * p, q)\n        weight[n] = l // p + l // q\n      else:\n        if weight[r] == -1: setWeight(r)\n        if weight[b] == -1: setWeight(b)\n        l = lcm(weight[r] * p, weight[b]  * q)\n        weight[n] = l // p + l // q\n    for i in range(n):\n      lst.append(list(map(int,input().split())))\n    for i in range(0,n):\n      if weight[i + 1] == -1:\n        setWeight(i+1)\n    print(max(weight))\nif __name__ == '__main__':\n  main()\n\n"
  },
  {
    "language": "Python",
    "code": "def gcd(a, b):\n    r = a % b\n    if r:\n        return gcd(b, r)\n    return b\n\n\ndef lcm(a, b):\n    if a < b:\n        a, b = b, a\n    return a * b // gcd(a, b)\n\n\ndef min_weight(m):\n    p, q, r, b = bars[m - 1]\n    red = p * (min_weight(r) if r else 1)\n    blue = q * (min_weight(b) if b else 1)\n    equilibrium = lcm(red, blue)\n    return equilibrium // p + equilibrium // q\n\n\nwhile True:\n    n = int(input())\n    if not n:\n        break\n\n    bars = [tuple(map(int, input().split())) for _ in range(n)]\n\n    root_bar = set(range(1, n + 1))\n    for _, _, r, b in bars:\n        if r: root_bar.remove(r)\n        if b: root_bar.remove(b)\n\n    print(min_weight(root_bar.pop()))"
  },
  {
    "language": "Python",
    "code": "from fractions import gcd\ndef dfs(p, q, r, b, s):\n    if s == 0: return 1\n    x = dfs(p, q, r, b, r[s]) * p[s]\n    y = dfs(p, q, r, b, b[s]) * q[s]\n    z = x / gcd(x, y) * y\n    return z / p[s] + z / q[s]\nwhile 1:\n    n = input()\n    if n == 0: break\n    ret = n*(n+1) / 2\n    p = [0]*(n+1); q = [0]*(n+1); r = [0]*(n+1); b = [0]*(n+1)\n    for i in range(1, n+1):\n        p[i],q[i],r[i],b[i] = map(int, raw_input().split())\n        ret -= r[i] + b[i]\n    print dfs(p, q, r, b, ret)"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n\nimport numpy as np\n\ndef GCD(a, b):\n\tdummy1 = max(a, b)\n\tdummy2 = min(a, b)\n\twhile True:\n\t\tdummy = dummy1 % dummy2\n\t\tdummy1 = dummy2\n\t\tdummy2 = dummy\n\t\tif(dummy == 0):\n\t\t\tbreak\n\n\treturn dummy1\n\nwhile True:\n\tN = input()\n\tif not N:\n\t\tbreak\n\tcost = []\n\tE = []\n\troot = N * (N - 1) / 2\n\tfor i in range(N):\n\t\tS = raw_input().split()\n\t\tc1, c2, e1, e2 = list(map(int,S))\n\t\tcost.append((c1, c2))\n\t\troot -= e1 + e2\n\t\te1 -= 1\n\t\te2 -= 1\n\t\tE.append((e1, e2))\n\tdef nums(e):\n\t\tN_lst1 = []\n\t\tN_lst2 = []\n\t\tval_lst1 = []\n\t\tval_lst2 = []\n\t\tif E[e][0] != -1:\n\t\t\tN_lst1, val_lst1 = nums(E[e][0])\n\t\telse:\n\t\t\tN_lst1 = [1]\n\t\t\tval_lst1 = []\n\t\t\n\t\tif E[e][1] != -1:\n\t\t\tN_lst2, val_lst2 = nums(E[e][1])\n\t\telse:\n\t\t\tN_lst2 = [1]\n\t\t\tval_lst2 = []\n\t\t\n\t\tmul1 = cost[e][0]\n\t\tfor num in val_lst1:\n\t\t\tmul1 *= num\n\t\tmul2 = cost[e][1]\n\t\tfor num in val_lst2:\n\t\t\tmul2 *= num\n\t\tfor i in range(len(N_lst1)):\n\t\t\tN_lst1[i] *= mul2\n\t\tfor i in range(len(N_lst2)):\n\t\t\tN_lst2[i] *= mul1\n\t\t\n\t\treturn N_lst1 + N_lst2, val_lst1 + val_lst2 + [cost[e][0] + cost[e][1]]\n\tN_lst, v_lst = nums(root - 1)\n\t#print N_lst\n\tnum_GCD = N_lst[0]\n\tfor num in N_lst:\n\t\tnum_GCD = GCD(num, num_GCD)\n\t\n\tfor i in range(len(N_lst)):\n\t\tN_lst[i] //= num_GCD\n\t#print N_lst\n\tprint sum(N_lst)\n\t\n"
  },
  {
    "language": "Python",
    "code": "# AOJ 0520: Lightest Mobile\n# Python3 2018.6.30 bal4u\n\ndef lcm(a, b):\n\treturn a // gcd(a, b) * b\n\ndef gcd(a, b):\n\twhile b != 0:\n\t\tr = a % b\n\t\ta, b = b, r\n\treturn a\n\ndef calc(i):\n\twr = calc(t[i][2]) if t[i][2] > 0 else 1\n\twb = calc(t[i][3]) if t[i][3] > 0 else 1\n\tw = lcm(t[i][0] * wr, t[i][1] * wb)\n\treturn w//t[i][0] + w//t[i][1]\n\nwhile True:\n\tn = int(input())\n\tif n == 0: break\n\tf = [0]*(n+1)\n\tt = [(0,0,0,0)]\n\tfor i in range(1, n+1):\n\t\tp, q, r, b = map(int, input().split())\n\t\tt.append((p, q, r, b))\n\t\tif r > 0: f[r] = i\n\t\tif b > 0: f[b] = i\n\tfor i in range(1, n+1):\n\t\tif f[i] == 0: break\n\tprint(calc(i))\n"
  },
  {
    "language": "Python",
    "code": "import math\nclass Mobile:\n    def __init__(self,leftratio=0,rightratio=0,left=-1,right=-1):\n        self.weight = 0\n        self.leftratio = leftratio\n        self.rightratio = rightratio\n        self.left = left\n        self.leftweight = 0\n        self.right = right\n        self.rightweight = 0\n\n    def calc(self):\n        if self.weight != 0 : return self.weight\n\n        if self.left == -1:\n            self.leftweight = 1\n        else:\n            self.leftweight = Mobile.calc(self.left)\n        if self.right == -1:\n            self.rightweight = 1\n        else:\n            self.rightweight = Mobile.calc(self.right)\n\n        lmoment = self.leftratio*self.leftweight\n        rmoment = self.rightratio*self.rightweight\n        lcs = lmoment * rmoment // math.gcd(lmoment,rmoment)\n        self.weight = (lcs//self.leftratio) + (lcs//self.rightratio)\n\n        return self.weight\n\n    def stdout(self):\n        print(self.left, self.right)\nwhile True:\n    n = int(input())\n    if n==0: break\n    barlist = [Mobile() for i in range(n)]\n    for i in range(n):\n        p,q,r,b = map(int, input().split())\n        barlist[i].leftratio = p\n        barlist[i].rightratio = q\n        if r != 0 : barlist[i].left = barlist[r-1]\n        if b != 0 : barlist[i].right = barlist[b-1]\n\n    maxi = 0\n    for i in range(n):\n        maxi = max(barlist[i].calc(),maxi)\n\n    print(maxi)"
  },
  {
    "language": "Python",
    "code": "def gcd(x, y):\n    while y > 0:\n        x, y = y, x%y\n    return x\n\nwhile True:\n    N = int(input())\n    if not N:\n        break\n    a = [list(map(int, input().split())) for _ in [0]*N]\n    root = (set(range(1, N+1)) - set(n for bar in a for n in bar[2:])).pop()\n\n    def solve(ratio_r, ratio_l, left, right):\n        d = gcd(ratio_r, ratio_l)\n        ratio_r //= d\n        ratio_l //= d\n\n        w_left = solve(*a[left-1]) if left else 0\n        w_right = solve(*a[right-1]) if right else 0\n\n        if w_left == w_right == 0:\n            w_left, w_right = ratio_l, ratio_r\n        elif w_left == 0:\n            w_right = (w_right * ratio_r) // gcd(w_right, ratio_r)\n            w_left = ratio_l * (w_right // ratio_r)\n        elif w_right == 0:\n            w_left = (w_left * ratio_l) // gcd(w_left, ratio_l)\n            w_right = ratio_r * (w_left // ratio_l)\n        else:\n            _r, _l = w_left*ratio_r, w_right*ratio_l\n            d = gcd(_l, _r)\n            w_right, w_left = w_right*(_r // d), w_left*(_l // d)\n\n        return w_right + w_left\n\n    print(solve(*a[root-1]))\n"
  }
]