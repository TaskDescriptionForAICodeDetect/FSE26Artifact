[
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nint W, H;\n\nconst int MAX_H = 50;\nconst int MAX_W = 50;\nbool isblack[MAX_H][MAX_W];\nbool iswhite[MAX_H][MAX_W];\nchar field[MAX_H][MAX_W];\n\nconst int dx[4] = { 1, 0, -1, 0 };\nconst int dy[4] = { 0, 1, 0, -1 };\n\nvoid get(int x, int y, bool black) {\n    if(!(0 <= x && x < W && 0 <= y && y < H)) return;\n    if(field[y][x] != '.') return;\n\n    if(black) {\n        if(isblack[y][x]) return;\n        isblack[y][x] = true;\n    }\n    else {\n        if(iswhite[y][x]) return;\n        iswhite[y][x] = true;\n    }\n\n    for(int i = 0; i < 4; i++) {\n        get(x + dx[i], y + dy[i], black);\n    }\n}\n\nint main() {\n    for(; scanf(\"%d%d\", &W, &H), W || H; ) {\n        memset(isblack, 0, sizeof(isblack));\n        memset(iswhite, 0, sizeof(iswhite));\n\n        for(int i = 0; i < H; i++) scanf(\" %s\", field[i]);\n\n\n        for(int y = 0; y < H; y++) {\n            for(int x = 0; x < W; x++) {\n                if(field[y][x] == 'B') {\n                    for(int i = 0; i < 4; i++) {\n                        get(x + dx[i], y + dy[i], true);\n                    }\n                }\n\n                if(field[y][x] == 'W') {\n                    for(int i = 0; i < 4; i++) {\n                        get(x + dx[i], y + dy[i], false);\n                    }\n                }\n            }\n        }\n\n        int b = 0;\n        int w = 0;\n        for(int y = 0; y < H; y++) {\n            for(int x = 0; x < W; x++) {\n                if(isblack[y][x] && !iswhite[y][x]) b++;\n                if(!isblack[y][x] && iswhite[y][x]) w++;\n            }\n        }\n\n        printf(\"%d %d\\n\", b, w);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define ALL(a) (a).begin(),(a).end()\nconst int INF = INT_MAX/3;\nconst double EPS = 1e-14;\n\ntemplate<typename U, typename T>\nvoid chmin(U &x, T y) { x = min(x, y); }\n\ntemplate<typename U, typename T>\nvoid chmax(U &x, T y) { x = max(x, y); }\n\ntypedef long long int lli;\ntypedef long double ld;\ntypedef pair<int,int> P;\n\nint W, H;\nconst int HMAX = 58, WMAX = 58;\nchar field[HMAX][WMAX];\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\nostringstream debug;\n\nbool outof_range(int y, int x) {\n  return y < 0 || H <= y || x < 0 || W <= x;\n}\n\nvoid dfs(int y, int x, char c, char target) {\n  stack<P> st;\n  st.push(P(y, x));\n  while (!st.empty()) {\n    P top = st.top(); st.pop();\n    int y = top.first, x = top.second;\n    if (outof_range(y, x) || field[y][x] != target) continue;\n    field[y][x] = c;\n    REP(i, 4) {\n      st.push(P(y + dy[i], x + dx[i]));\n    }\n  }\n}\n\nint main() {\n  cout << fixed << setprecision(10);\n  while (cin >> W >> H and W) {\n    REP(y, HMAX) REP(x, WMAX) {\n      field[y][x] = '#';\n    }\n    REP(y, H) {\n      string row; cin >> row;\n      REP(x, W) {\n        field[y][x] = row[x];\n      }\n    }\n    REP(y, H) REP(x, W) {\n      if (field[y][x] == 'W') {\n        REP(i, 4) {\n          dfs(y + dy[i], x + dx[i], 'w', '.');\n        }\n      }\n      if (field[y][x] == 'B') {\n        REP(i, 4) {\n          dfs(y + dy[i], x + dx[i], 'b', '.');\n        }\n      }\n    }\n    REP(y, H) REP(x, W) {\n      if (field[y][x] == 'W') {\n        REP(i, 4) {\n          dfs(y + dy[i], x + dx[i], 'x', 'b');\n        }\n      }\n      if (field[y][x] == 'B') {\n        REP(i, 4) {\n          dfs(y + dy[i], x + dx[i], 'x', 'w');\n        }\n      }\n      if (field[y][x] == 'x') {\n        REP(i, 4) {\n          dfs(y + dy[i], x + dx[i], 'x', 'w');\n          dfs(y + dy[i], x + dx[i], 'x', 'b');\n        }\n      }\n    }\n    int white = 0, black = 0;\n    REP(y, H) REP(x, W) {\n      char c = field[y][x];\n      if (c == 'w') { white++; }\n      if (c == 'b') { black++; }\n    }\n    cout << black << \" \" << white << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define N 51\nusing namespace std;\nchar map[N][N],clr[N][N];\nint w,h;\nvoid renew(int x,int y){\n  int dx[4]={1,0,-1,0},dy[4]={0,1,0,-1},newx,newy;\n  for(int u=0;u<4;u++){\n    newx=x+dx[u],newy=y+dy[u];\n    if(newx>=0 && newx<w && newy>=0 && newy<h){\n         if(clr[newy][newx]=='.' && map[newy][newx]=='.') map[newy][newx]=map[y][x],renew(newx,newy);\n      else if(clr[newy][newx]=='.' && map[y][x]!=map[newy][newx])map[newy][newx]='F',renew(newx,newy);\n    }\n  }\n}\n \nint main(){\n  while(1){\n    int wcnt=0,bcnt=0;\n    cin>>w>>h;\n    if(w+h==0) break;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n    cin>>map[i][j];\n    clr[i][j]=map[i][j];\n      }\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n    if(clr[i][j]=='W') wcnt--;\n    if(clr[i][j]=='B')bcnt--;\n    if(clr[i][j]!='.') renew(j,i);\n      }\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n    if(map[i][j]=='B')bcnt++;\n    else if(map[i][j]=='W')wcnt++;\n       }\n     \n    cout<<bcnt<<\" \"<<wcnt<<endl;\n  }\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\n#define stlice(from, to) substr(from, (to) - (from) + 1)\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\nusing namespace std;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\nusing vd = vector<double>;\nusing vc = vector<char>;\nusing vb = vector<bool>;\nusing vs = vector<string>;\nusing vpii = vector<pii>;\nusing vvi = vector<vi>;\nusing vvb = vector<vb>;\nusing vvpii = vector<vpii>;\ntemplate<typename A> using fn = function<A>;\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = acos(-1);\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nconstexpr bool odd(const int &n) { return n & 1; }\nconstexpr bool even(const int &n) { return !odd(n); }\nvoid solve();\nmain { solve(); return 0; }\n// clang-format on\n\nvoid solve() {\n  int W, H;\n  while (cin >> W >> H, W) {\n    vs v(H);\n    rep(i, H) cin >> v[i];\n    vvi dp(H, vi(W));\n    int b = 0, w = 0;\n    rep(i, H) rep(j, W) {\n      dp[i][j] = 2 * (v[i][j] == 'B') + (v[i][j] == 'W');\n      b -= v[i][j] == 'B';\n      w -= v[i][j] == 'W';\n    }\n    rep(_, W * H) rep(i, H) rep(j, W) {\n      if (v[i][j] != '.') continue;\n      if (i > 0) dp[i][j] |= dp[i - 1][j];\n      if (j > 0) dp[i][j] |= dp[i][j - 1];\n      if (i < H - 1) dp[i][j] |= dp[i + 1][j];\n      if (j < W - 1) dp[i][j] |= dp[i][j + 1];\n    }\n    rep(i, H) rep(j, W) {\n      b += dp[i][j] == 2;\n      w += dp[i][j] == 1;\n    }\n    cout << b << ' ' << w << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr, __VA_ARGS__)\n// #define LOG(...)\n#define FOR(i, a, b) for(int i = (int)(a); i < (int)(b); ++i)\n#define REP(i, n) for(int i = 0; i < (int)(n); ++i)\n#define RREP(i, n) for(int i = (int)(n - 1); i >= 0; --i)\n#define RFOR(i, a, b) for(int i = (int)(b - 1); i >= (int)(a); --i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EXIST(s, e) ((s).find(e) != (s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SQ(n) (n) * (n)\n#define BIT(x, i) (((x) >> (i)) & 1)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<char> vc;\ntypedef vector<pii> vpi;\ntypedef vector<pll> vpl;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vc> vvc;\ntypedef vector<vll> vvll;\n\nint dx[] = {-1, 0, 1, 0};\nint dy[] = {0, -1, 0, 1};\n\nint w, h;\nchar field[50][50];\n\nint dfs(int x, int y, int &state) {\n  field[y][x] = '*';\n\n  int cnt = 1;\n  REP(i, 4){\n    int sx = x + dx[i];\n    int sy = y + dy[i];\n    if (sx < 0 || sx >= w || sy < 0 || sy >= h) continue;\n    if (field[sy][sx] == 'B') state |= 1;\n    else if (field[sy][sx] == 'W') state |= 2;\n    else if (field[sy][sx] == '.') {\n      cnt += dfs(sx, sy, state);\n    }\n  }\n  if (state == 3)\n    return 0;\n  else\n    return cnt;\n}\n\nint main() {\n  while(cin >> w >> h, w) {\n    fill_n((char *)field, 50 * 50, '.');\n    REP(y, h) REP(x, w) {\n      cin >> field[y][x];\n    }\n\n    int cb = 0, cw = 0;\n    REP(y, h) REP(x, w) {\n      if (field[y][x] == '.') {\n        int state = 0;\n        int v = dfs(x, y, state);\n        if (state == 1) {\n          cb += v;\n        } else if (state == 2) {\n          cw += v;\n        }\n      }\n    }\n\n    printf(\"%d %d\\n\", cb, cw);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <cmath>\n#include <algorithm>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <vector>\n#include <string>\n#define REP(i,n) for(int i=0;i<n;i++)\ntypedef long long ll;\nusing namespace std;\ntypedef vector<ll> vl;\ntypedef pair<ll,ll> pll;\ntypedef vector<pll> vpll;\ntypedef vector<string> vs;\n\nint X[4]={0,0,-1,1};\nint Y[4]={-1,1,0,0};\nint w,h;\nint ans[50][50];\nint bl[50][50];\nint wh[50][50];\n\nvoid black(int x,int y){\n\tbl[x][y]=1;\n\tfor(int i=0;i<4;i++){\n\t\tif(x+X[i]>-1&&x+X[i]<w&&y+Y[i]>-1&&y+Y[i]<h){\n\t\t\tif(ans[x+X[i]][y+Y[i]]==0&&bl[x+X[i]][y+Y[i]]==0){black(x+X[i],y+Y[i]);}\n\t\t}\n\t}\n}\n\nint a(0);\n\nvoid white(int x,int y){\n\twh[x][y]=1;\n\tfor(int i=0;i<4;i++){\n\t\tif(x+X[i]>-1&&x+X[i]<w&&y+Y[i]>-1&&y+Y[i]<h){\n\t\t\tif(ans[x+X[i]][y+Y[i]]==0&&wh[x+X[i]][y+Y[i]]==0){white(x+X[i],y+Y[i]);}\n\t\t}\n\t}\n}\n\n\nint main() \n{\n\twhile(cin>>w>>h&&!(w==0&&h==0)){\n\t\tREP(i,51){REP(j,51){ans[j][i]=0;bl[j][i]=0;wh[j][i]=0;}}\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tchar tmp;\n\t\t\t\tcin>>tmp;\n\t\t\t\tswitch(tmp){\n\t\t\t\t  case 'B':ans[j][i]=1;break;\n\t\t\t\t  case 'W':ans[j][i]=2;break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tint tmp1(false),tmp2(false);\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tif(j+X[k]>-1&&j+X[k]<w&&i+Y[k]>-1&&i+Y[k]<h){\n\t\t\t\t\t\tif(ans[j+X[k]][i+Y[k]]==1){tmp1=true;}\n\t\t\t\t\t\tif(ans[j+X[k]][i+Y[k]]==2){tmp2=true;}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(tmp1&&bl[j][i]!=1&&ans[j][i]==0){black(j,i);}\n\t\t\t\tif(tmp2&&wh[j][i]!=1&&ans[j][i]==0){white(j,i);}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans1(0),ans2(0);\n\t\tREP(i,h){REP(j,w){\n\t\t\t\tif(bl[j][i]+wh[j][i]==2){;}\n\t\t\t\telse if(wh[j][i]==1){ans2++;}\n\t\t\t\telse if(bl[j][i]==1){ans1++;}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout<<ans1<<\" \"<<ans2<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cassert>\nnamespace boost {template <class T>struct integer_iterator {T a;bool operator != (integer_iterator const & it) const { return a != it.a; }T operator * () const { return a; }integer_iterator & operator ++ () { ++ a; return *this; }integer_iterator operator ++ (int) { return { a ++ }; }};template <class T>struct integer_range {T l, r;typedef integer_iterator<T> iterator;iterator begin() const { return { l }; }iterator end  () const { return { r }; }};template <class T>integer_range<T> irange(T l, T r) { assert (l <= r); return { l, r }; }template <class T>struct integer_iterator_with_step {T a, d, i;bool operator != (integer_iterator_with_step const & it) const { return a != it.a or d != it.d or i != it.i; }T operator * () const { return a+d*i; }integer_iterator_with_step & operator ++ () { ++ i; return *this; }integer_iterator_with_step operator ++ (int) { return { a, d, i ++ }; }};template <class T>struct strided_integer_range {T l, r, s;typedef integer_iterator_with_step<T> iterator;iterator begin() const { return { l, s, 0 }; }iterator end  () const { return { l, s, (r - l) / s }; }};template <class T>strided_integer_range<T> irange(T l, T r, T s) { assert (s > 0 ? l <= r : s < 0 ? l >= r : false); return { l, r, s }; }}\ntypedef long long ll;\nusing namespace std;\nusing namespace boost;\nbool on_board(int y, int x, int h, int w) {\n    return 0 <= y and y < h and 0 <= x and x < w;\n}\nint dx[] = {  0, 0, 1, -1 };\nint dy[] = { -1, 1, 0,  0 };\nint grouping(int y, int x, int k, vector<vector<int> > & group, vector<vector<char> > const & a) {\n    assert (a[y][x] == '.' and not group[y][x]);\n    int h = a.size();\n    int w = a.front().size();\n    group[y][x] = k;\n    int s = 1;\n    for (int i : irange(0,4)) {\n        int ny = y + dy[i];\n        int nx = x + dx[i];\n        if (not on_board(ny, nx, h, w)) continue;\n        if (a[ny][nx] == '.' and not group[ny][nx]) {\n            s += grouping(ny, nx, k, group, a);\n        }\n    }\n    return s;\n}\nint main() {\n    while (true) {\n        int w, h; cin >> w >> h;\n        if (w == 0 and h == 0) break;\n        vector<vector<char> > a(h, vector<char>(w));\n        for (int y : irange(0,h)) {\n            for (int x : irange(0,w)) {\n                cin >> a[y][x];\n            }\n        }\n        vector<vector<int> > group(h, vector<int>(w));\n        int group_num = 0;\n        vector<int> group_size;\n        group_size.push_back(-1); // dummy, to make 1-origin\n        for (int y : irange(0,h)) {\n            for (int x : irange(0,w)) {\n                if (a[y][x] == '.' and not group[y][x]) {\n                    group_num += 1;\n                    int s = grouping(y, x, group_num, group, a);\n                    group_size.push_back(s);\n                }\n            }\n        }\n        vector<pair<bool,bool> > connected(group_num + 1); // 0 is dummy, to make 1-origin\n        for (int y : irange(0,h)) {\n            for (int x : irange(0,w)) {\n                int k = group[y][x];\n                if (k) {\n                    for (int i : irange(0,4)) {\n                        int ny = y + dy[i];\n                        int nx = x + dx[i];\n                        if (not on_board(ny, nx, h, w)) continue;\n                        if (a[ny][nx] == 'B') connected[k].first  = true;\n                        if (a[ny][nx] == 'W') connected[k].second = true;\n                    }\n                }\n            }\n        }\n        int black = 0, white = 0;\n        for (int k : irange(1,group_num+1)) { // 1-origin\n            if (connected[k].first and not connected[k].second) {\n                black += group_size[k];\n            } else if (not connected[k].first and connected[k].second) {\n                white += group_size[k];\n            }\n        }\n        cout << black << \" \" << white << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <string.h>\n\n#define W_MAX 52\n#define H_MAX 52\n\nint f[H_MAX][W_MAX];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\n\nvoid dfs1(int x,int y);\nvoid dfs2(int x,int y);\n\nusing namespace std;\n\nint main(void)\n{\n\tint w,h;\n\tchar c;\n\tint i1,i2;\n\tint count1,count2;\n\n\twhile(1){\n\t\tcin >> w >> h;\n\t\tif(w+h==0) break;\n\n\t\tmemset(f,-1,sizeof(f));\n\n\t\tfor(i1=1;i1<=h;i1++){\n\t\t\tfor(i2=1;i2<=w;i2++){\n\t\t\t\tcin >> c;\n\t\t\t\tif(c=='.') f[i1][i2]=0;\n\t\t\t\telse if(c=='B') f[i1][i2]=1;\n\t\t\t\telse if(c=='W') f[i1][i2]=2;\n\t\t\t}\n\t\t}\n\n\t\tfor(i1=1;i1<=h;i1++){\n\t\t\tfor(i2=1;i2<=w;i2++){\n\t\t\t\tif(f[i1][i2]==1) {\n\t\t\t\t\tf[i1][i2]=-1;\n\t\t\t\t\tdfs1(i2,i1);\n\t\t\t\t}\n\t\t\t\telse if(f[i1][i2]==2){\n\t\t\t\t\tf[i1][i2]=-1;\n\t\t\t\t\tdfs2(i2,i1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcount1=0;\n\t\tcount2=0;\n\t\tfor(i1=1;i1<=h;i1++){\n\t\t\tfor(i2=1;i2<=w;i2++){\n\t\t\t\tif(f[i1][i2]==3) count1++;\n\t\t\t\telse if(f[i1][i2]==4) count2++;\n\t\t\t}\n\t\t}\n\t\tcout << count1 << \" \" << count2 << endl;\n\t}\n\n\treturn 0;\n\n\n}\n\nvoid dfs1(int x,int y)\n{\n\tint i1;\n\tint xx,yy;\n\n\tfor(i1=0;i1<4;i1++){\n\t\txx=x+dx[i1];\n\t\tyy=y+dy[i1];\n\n\t\tif(f[yy][xx]==0 || f[yy][xx]==4){\n\t\t\tf[yy][xx]+=3;\n\t\t\tdfs1(xx,yy);\n\t\t}\n\t}\n}\n\nvoid dfs2(int x,int y)\n{\n\tint i1;\n\tint xx,yy;\n\n\tfor(i1=0;i1<4;i1++){\n\t\txx=x+dx[i1];\n\t\tyy=y+dy[i1];\n\n\t\tif(f[yy][xx]==0 || f[yy][xx]==3){\n\t\t\tf[yy][xx]+=4;\n\t\t\tdfs2(xx,yy);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nint dy[]={0,1,0,-1};\nint dx[]={1,0,-1,0};\nchar m[50][51];\nint w,h;\n\nbool visit[50][50];\nint flag;\nint dfs(int y,int x){\n\tif(y<0||h<=y||x<0||w<=x || visit[y][x])return 0;\n\tif(m[y][x]=='B'){\n\t\tflag|=1;\n\t\treturn 0;\n\t}\n\tif(m[y][x]=='W'){\n\t\tflag|=2;\n\t\treturn 0;\n\t}\n\tvisit[y][x]=true;\n\tint res=1;\n\tfor(int i=0;i<4;i++){\n\t\tres += dfs(y+dy[i],x+dx[i]);\n\t}\n\treturn res;\n}\nint main(){\n\twhile(cin>>w>>h,w|h){\n\t\tint black=0,white=0;\n\t\tfor(int i=0;i<h;i++)cin>>m[i];\n\t\tmemset(visit,false,sizeof(visit));\n\t\tfor(int y=0;y<h;y++){\n\t\t\tfor(int x=0;x<w;x++){\n\t\t\t\tif(visit[y][x]||m[y][x]!='.')continue;\n\t\t\t\tflag=0;\n\t\t\t\tint s=dfs(y,x);\n\t\t\t\tif(flag==1)black+=s;\n\t\t\t\telse if(flag==2)white+=s;\n\t\t\t}\n\t\t}\n\t\tcout<<black<<' '<<white<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr, __VA_ARGS__)\n//#define LOG(...)\n#define FOR(i, a, b) for (int i = (int)(a); i < (int)(b); ++i)\n#define RFOR(i, a, b) for (int i = (int)(b - 1); i >= (int)(a); --i)\n#define REP(i, n) for (int i = 0; i < (int)(n); ++i)\n#define RREP(i, n) for (int i = (int)(n - 1); i >= 0; --i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EXIST(s, e) ((s).find(e) != (s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SZ(a) ((int)(a).size())\n#define BIT(x, i) (((x) >> (i)) & 1)\n#define SQ(x) ((x) * (x))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = {-1,0,1,0}, dy[] = {0,1,0,-1};\n\nint W, H;\n\npair<bool, int> dfs_count(vvc& field, int x, int y, char c) {\n    field[y][x] = c;\n    int cnt = 0;\n    REP(i, 4) {\n        int sx = x + dx[i], sy = y + dy[i];\n        if (0 <= sx && sx < W && 0 <= sy && sy < H) {\n            if (field[sy][sx] == '.') {\n                auto retval = dfs_count(field, sx, sy, c);\n                if (!retval.first) {\n                    return {false, 0};\n                }\n                cnt += retval.second + 1;\n            } else if (field[sy][sx] != c) {\n                return {false, 0};\n            }\n        }\n    }\n    return {true, cnt};\n}\n\nint main() {\n    while (cin >> W >> H, W|H) {\n        vvc field(H, vc(W));\n        REP(y, H) REP(x, W) cin >> field[y][x];\n        int b = 0, w = 0;\n        REP(y, H) REP(x, W) {\n            if (field[y][x] == '.') continue;\n            REP(i, 4) {\n                vvc copy = field;\n                int sx = x + dx[i], sy = y + dy[i];\n                if (0 <= sx && sx < W && 0 <= sy && sy < H && field[sy][sx] == '.') {\n                    if (field[y][x] == 'B') {\n                        auto retval = dfs_count(field, sx, sy, 'B');\n                        if (retval.first) {\n                            b += retval.second + 1;\n                        } else {\n                            field = copy;\n                        }\n                    } else if (field[y][x] == 'W') {\n                        auto retval = dfs_count(field, sx, sy, 'W');\n                        if (retval.first) {\n                            w += retval.second + 1;\n                        } else {\n                            field = copy;\n                        }\n                    }\n                }\n            }\n        }\n//        REP(y, H) { REP(x, W) { LOG(\"%c\", field[y][x]); } LOG(\"\\n\"); }\n\n        cout << b << \" \" << w << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint w,h;\nstring f[51];\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,1,0,-1};\n\nvoid solve(int x,int y,char c){\n\tchar c_ , r ;\n\tif( c == 'W' ){\n\t\tc_ = 'w';\n\t\tr = 'B';\n\t}\n\tif( c == 'B'){\n\t\tc_ = 'b';\n\t\tr = 'W';\n\t}\n\t\n\tfor(int i=0 ; i<4 ; ++i ){\n\t\tint mx = x + dx[i];\n\t\tint my = y + dy[i];\n\t\t\n\t\tif( mx < 0 || my < 0 || mx >= w || my >= h ) continue;\n\t\t\n\t\tif( c == 'W' || c == 'B'){\n\t\t\tif( f[my][mx] == '.' ){\n\t\t\t\tf[my][mx] = c_ ;\n\t\t\t\tsolve( mx , my , c );\n\t\t\t}\n\t\t\tif( f[my][mx] == r ){\n\t\t\t\tf[my][mx] = 'x' ;\n\t\t\t\tsolve( mx , my , 'x' );\n\t\t\t}\n\t\t}else if( c == 'x' ){\n\t\t\tif( f[my][mx] == 'w' || f[my][mx] == 'b' || f[my][mx] == '.' ){\n\t\t\t\tf[my][mx] = 'x';\n\t\t\t\tsolve( mx , my , 'x' );\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid debug(){\n\tcout << endl;\n\tfor(int y=0 ; y<h ; ++y ){\n\t\tcout << f[y] << endl;\n\t}\n\tcout << endl;\n}\n\nint main(){\n\n\twhile( cin >> w >> h , w|h ){\n\t\tfor(int y=0 ; y<h ; ++y ){\n\t\t\tcin >> f[y];\n\t\t}\n\t\tfor(int y=0 ; y<h ; ++y ){\n\t\t\tfor(int x=0 ; x<w ; ++x ){\n\t\t\t\tif( f[y][x] == 'W' ){\n\t\t\t\t\tsolve( x , y , 'W' );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int y=0 ; y<h ; ++y ){\n\t\t\tfor(int x=0 ; x<w ; ++x ){\n\t\t\t\tif( f[y][x] == 'B' ){\n\t\t\t\t\tsolve( x , y , 'B' );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//debug();\n\t\tint black = 0 , white = 0;\n\t\tfor(int y=0 ; y<h ; ++y ){\n\t\t\tfor(int x=0 ; x<w ; ++x ){\n\t\t\t\tif( f[y][x] == 'w' )\n\t\t\t\t\twhite++;\n\t\t\t\tif( f[y][x] == 'b' )\n\t\t\t\t\tblack++;\n\t\t\t}\n\t\t}\n\t\tcout << black << \" \" << white << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n\nusing namespace std;\n\n#define INF 1010001000\n#define EPS 1e-10\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define pb push_back\n\ntypedef pair<int, int> i_i;\ntypedef long long int llong;\ntypedef pair<llong, llong> ll_ll;\ntypedef struct edge {int f, t;}Edge;\n\nvector<vector<bool> > check, cont;\nvector<vector<char> > board;\nint dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\nint w, h;\n\nbool bfs(int i, int j, char t);\nint cnt(int i, int j);\n\nint main()\n{\n    while (cin >> w >> h, w) {\n        board.assign(h, vector<char>(w));\n        check.assign(h, vector<bool>(w, false));\n        cont.assign(h, vector<bool>(w, false));\n        getchar();\n        bool bl = false, wh = false;\n        rep(i, h) {\n            rep(j, w) {\n                cin >> board[i][j];\n                if (board[i][j] == 'W') {\n                    wh = true;\n                } else if (board[i][j] == 'B') {\n                    bl = true;\n                }\n            }\n            getchar();\n        }\n        if (!bl && ! wh) {\n            cout << 0 << \" \" << 0 << endl;\n            continue;\n        }\n        int white = 0, black = 0;\n        rep(i, h) {\n            rep(j, w) {\n                if (!check[i][j] && board[i][j] == '.') {\n                    if (bfs(i, j, 'W')) {\n                        white += cnt(i, j);\n                    }  \n                }\n            }\n        }\n        check.assign(h, vector<bool>(w, false));\n        rep(i, h) {\n            rep(j, w) {\n                if (!check[i][j] && board[i][j] == '.') {\n                    if (bfs(i, j, 'B')) {\n                        black += cnt(i, j);\n                    }  \n                }\n            }\n        }\n        cout << black << \" \" << white << endl;\n    }\n    return 0;\n}\n\n\nint cnt(int i, int j)\n{\n    int ret = 1;\n    cont[i][j] = true;\n    rep(k, 4) {\n        int ni = i + dx[k], nj = j + dy[k];\n        if (0 <= ni && ni < h && 0 <= nj && nj < w) {\n            if (!cont[ni][nj] && board[ni][nj] == '.') {\n                ret += cnt(ni, nj);\n            }\n        }\n    }\n    return ret;\n}\n\nbool bfs(int i, int j, char t)\n{\n    bool ret = true;\n    check[i][j] = true;\n    //cout << \"(\" << i << \",\" << j << \")\" << \" \";\n    rep(k, 4) {\n        int ni = i + dx[k], nj = j + dy[k];\n        if (0 <= ni && ni < h && 0 <= nj && nj < w) {\n            if (!check[ni][nj]) {\n                if (board[ni][nj] == t) {\n                    ret &= true;\n                } else if (board[ni][nj] == '.') {\n                    ret &= bfs(ni, nj, t);\n                } else {\n                    ret = false;\n                }\n            }\n        }\n    }\n    return ret;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <complex>\n#include <utility>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <bitset>\n#include <ctime>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <cassert>\n#include <cstddef>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <sstream>\n#include <fstream>\n\nusing namespace std;\n#define REP(i, n) for (int (i) = 0; (i) < (n); (i)++)\n#define FOR(i, a, b) for (int (i) = (a); (i) < (b); (i)++)\n#define RREP(i, a) for(int (i) = (a) - 1; (i) >= 0; (i)--)\n#define FORR(i, a, b) for(int (i) = (a) - 1; (i) >= (b); (i)--)\n#define DEBUG(C) cerr << #C << \" = \" << C << endl;\nusing LL = long long;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing VD = vector<double>;\nusing VVD = vector<VD>;\nusing PII = pair<int, int>;\nusing PDD = pair<double, double>;\nusing PLL = pair<LL, LL>;\nusing VPII = vector<PII>;\n#define ALL(a) begin((a)), end((a))\n#define RALL(a) rbegin((a)), rend((a))\n#define SORT(a) sort(ALL((a)))\n#define RSORT(a) sort(RALL((a)))\n#define REVERSE(a) reverse(ALL((a)))\n#define MP make_pair\n#define FORE(a, b) for (auto &&a : (b))\n#define FIND(s, e) ((s).find(e) != (s).end())\n#define EB emplace_back\n\nconst int INF = 1e9;\nconst int MOD = INF + 7;\nconst LL LLINF = 1e18;\n\nint MW, MH;\nvector<string> a;\nvector<vector<bool>> used;\nbool inside(int nh, int nw) {\n    return 0 <= nw && nw < MW && 0 <= nh && nh < MH;\n}\nint dh[] = {-1, 0, 0, 1};\nint dw[] = {0, -1, 1, 0};\nbool white, black;\nint dfs(PII now, PII back) {\n    int w, h; tie(h, w) = now;\n    if (a[h][w] == 'W') {\n        white = true;\n        return 0;\n    }\n    if (a[h][w] == 'B') {\n        black = true;\n        return 0;\n    }\n    int res = 0;\n    REP(i, 4) {\n        int nh = h + dh[i], nw = w + dw[i];\n        if (!inside(nh, nw) || used[nh][nw]) continue;\n        if (back == MP(nh, nw)) continue;\n        if (a[nh][nw] == '.') used[nh][nw] = true;\n        res += dfs(MP(nh, nw), now);\n    }\n    return res + 1;\n}\n\nvoid solve(int W, int H) {\n    MW = W;MH = H;\n    a.resize(H);used.resize(H, vector<bool>(W, false));\n    for_each(ALL(a), [](string &e){cin >> e;});\n    PII ans = MP(0, 0);\n    REP(i, H)REP(j, W) if (!used[i][j] && a[i][j] == '.') {\n        used[i][j] = true;\n        white = false;\n        black = false;\n        int buf = dfs(MP(i, j), MP(-1, -1));\n        //DEBUG(buf)\n        if (white == black) {\n            buf = 0;\n        }\n        if (black && !white) ans.first += buf;\n        else if (!black && white) ans.second += buf;\n    }\n    cout << ans.first << \" \" << ans.second << endl;\n    a.clear();used.clear();\n    return;\n}\n\nsigned main(void) {\n    int n, m, p, a, b, c, x, y, z, q;\n    string s;\n    bool f = false;\n    while (cin >> n >> m, n) {\n        solve(n, m);\n        //return 0;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <queue>\n\nusing namespace std;\n\nint main(void){\n\tint black[50][50], white[50][50], h, w, i, j, k, x, y, bc, wc;\n\tchar field[50][51];\n\tconst int dx[4] = {1,0,-1,0},dy[4] = {0,1,0,-1};\n\tqueue<int> qx,qy;\n\tscanf(\"%d%d%*c\",&w,&h);\n\twhile(w != 0 || h != 0){\n\t\tmemset(black,0,sizeof(black));\n\t\tmemset(white,0,sizeof(white));\n\t\tfor(i = 0;i < h;i++){\n\t\t\tfor(j = 0;j < w;j++)\n\t\t\t\tfield[i][j] = getchar();\n\t\t\tgetchar();\n\t\t}\n\t\tfor(i = 0;i < h;i++){\n\t\t\tfor(j = 0;j < w;j++){\n\t\t\t\tif(field[i][j] == 'B'){\n\t\t\t\t\tqx.push(j);\n\t\t\t\t\tqy.push(i);\n\t\t\t\t\twhile(qx.size()){\n\t\t\t\t\t\tx = qx.front();\n\t\t\t\t\t\ty = qy.front();\n\t\t\t\t\t\tqx.pop();\n\t\t\t\t\t\tqy.pop();\n\t\t\t\t\t\tif(field[y][x] == '.')\n\t\t\t\t\t\t\tblack[y][x] = 1;\n\t\t\t\t\t\tfor(k = 0;k < 4;k++){\n\t\t\t\t\t\t\tif(x + dx[k] >= 0 && x + dx[k] < w && y + dy[k] >= 0 && y + dy[k] < h && field[y + dy[k]][x + dx[k]] == '.' && !black[y + dy[k]][x + dx[k]]){\n\t\t\t\t\t\t\t\tqx.push(x + dx[k]);\n\t\t\t\t\t\t\t\tqy.push(y + dy[k]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(field[i][j] == 'W'){\n\t\t\t\t\tqx.push(j);\n\t\t\t\t\tqy.push(i);\n\t\t\t\t\twhile(qx.size()){\n\t\t\t\t\t\tx = qx.front();\n\t\t\t\t\t\ty = qy.front();\n\t\t\t\t\t\tqx.pop();\n\t\t\t\t\t\tqy.pop();\n\t\t\t\t\t\tif(field[y][x] == '.')\n\t\t\t\t\t\t\twhite[y][x] = 1;\n\t\t\t\t\t\tfor(k = 0;k < 4;k++){\n\t\t\t\t\t\t\tif(x + dx[k] >= 0 && x + dx[k] < w && y + dy[k] >= 0 && y + dy[k] < h && field[y + dy[k]][x + dx[k]] == '.' && !white[y + dy[k]][x + dx[k]]){\n\t\t\t\t\t\t\t\tqx.push(x + dx[k]);\n\t\t\t\t\t\t\t\tqy.push(y + dy[k]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbc = wc = 0;\n\t\tfor(i = 0;i < h;i++)\n\t\t\tfor(j = 0;j < w;j++) if(white[i][j] && !black[i][j]) wc++;\n\t\tfor(i = 0;i < h;i++)\n\t\t\tfor(j = 0;j < w;j++) if(black[i][j] && !white[i][j]) bc++;\n\t\tprintf(\"%d %d\\n\",wc,bc);\n\t\tscanf(\"%d%d\",&w,&h);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n   \nusing namespace std;\n\nint w, h;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nbool iswhite(char c)\n{\n    return (c == 'W' || c == 'w');\n}\n\nbool isblack(char c)\n{\n    return (c == 'B' || c == 'b');\n}\n\nvoid expand(char a[51][51])\n{\n    bool ischanged = false;\n    for(int i = 0; i < h; i++){\n        for(int j = 0; j < w; j++){\n            if(a[i][j] == '.') continue;\n            for(int k = 0; k < 4; k++){\n                int nx = i + dx[k], ny = j + dy[k];\n                if(nx < 0 || nx >= h || ny < 0 || ny >= w || a[nx][ny] == 'B' || a[nx][ny] == 'W') continue;\n                if(iswhite(a[i][j])){\n                    if(a[nx][ny] == '.') a[nx][ny] = 'w';\n                    else if(isblack(a[nx][ny])) a[nx][ny] = 'X';\n                    else continue;\n                } else if(isblack(a[i][j])){\n                    if(a[nx][ny] == '.') a[nx][ny] = 'b';\n                    else if(iswhite(a[nx][ny])) a[nx][ny] = 'X';\n                    else continue;\n                } else {\n                    if(a[nx][ny] == '.' || a[nx][ny] == 'w' || a[nx][ny] == 'b') a[nx][ny] = 'X';\n                    else continue;\n                }\n                ischanged = true;\n            }\n        }\n    }\n    if(ischanged) expand(a);\n    else return;\n}\n\nvoid solve(char a[51][51])\n{\n    expand(a);\n    int wnum = 0, bnum = 0;\n    for(int i = 0; i < h; i++){\n        for(int j = 0; j < w; j++){\n            if(a[i][j] == 'w') wnum++;\n            else if(a[i][j] == 'b') bnum++;\n            // cout << a[i][j];\n        }\n        // cout << endl;\n    }\n    cout << bnum << \" \" << wnum << endl;\n    return;\n}\n\nint main()\n{\n    while(1){\n        cin >> w >> h;\n        if(w == 0 && h == 0) break;\n        char a[51][51];\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                cin >> a[i][j];\n            }\n        }\n        solve(a);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\n#define W 100\n#define B 200\n\nusing namespace std;\n\nclass PointQueue{\n\tpublic:\n\t\tqueue<int> x;\n\t\tqueue<int> y;\n\n\t\tvoid push(int px,int py);\n\t\tint frontX();\n\t\tint frontY();\n\t\tvoid pop();\n\t\tint size();\n};\n\nvoid PointQueue::push(int px,int py){\n\tx.push(px);\n\ty.push(py);\n}\n\nint PointQueue::frontX(){\n\treturn x.front();\n}\nint PointQueue::frontY(){\n\treturn y.front();\n}\n\nvoid PointQueue::pop(){\n\tx.pop();\n\ty.pop();\n}\n\nint PointQueue::size(){\n\treturn x.size();\n}\n\nint max(int a,int b){\n\tif(a>=b)return a;\n\telse return b;\n}\n\nint data[52][52];\nint flag[52][52];\n\n\n\nint main(){\n\n\tPointQueue q;\n\n\tint w,h;\n\twhile(cin>>w>>h){\n\t\tif(w==0&&h==0)break;\n\n\tint dx[4]={0,1,0,-1};\n\tint dy[4]={1,0,-1,0};\n\tint ansB=0,ansW=0;\n\n\tfor(int i=0;i<=h+1;i++){\n\t\tfor(int j=0;j<=w+1;j++){\n\t\t\tchar tmp;\n\n\t\t\tif(i==0 || i==h+1 || j==0 || j==w+1){\n\t\t\t\tdata[i][j]=-1;\n\t\t\t\tflag[i][j]=1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tcin>>tmp;\n\t\t\t\tif(tmp=='.'){\n\t\t\t\t\tflag[i][j]=0;\n\t\t\t\t\tdata[i][j]=0;\n\t\t\t\t}\n\t\t\t\telse if(tmp=='W'){\n\t\t\t\t\tdata[i][j]=W;\n\t\t\t\t\tflag[i][j]=1;\n\t\t\t\t}\n\t\t\t\telse if(tmp=='B'){\n\t\t\t\t\tdata[i][j]=B;\n\t\t\t\t\tflag[i][j]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i=1;i<=h;i++){\n\t\tfor(int j=1;j<=w;j++){\n\t\t\tint state=0;\n\t\t\tint space=0;\n\t\t\tif(flag[i][j]==0){\n\t\t\t\tq.push(j,i);\n\t\t\t\tflag[i][j]=1;\n\t\t\t\twhile(q.size()!=0){\n\t\t\t\t\tspace++;\n\t\t\t\t\tint topX=q.frontX();\n\t\t\t\t\tint topY=q.frontY();\n\t\t\t\t\tq.pop();\n\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tint nextX=dx[k]+topX;\n\t\t\t\t\t\tint nextY=dy[k]+topY;\n\n\t\t\t\t\t\tif(flag[nextY][nextX]==0){\n\t\t\t\t\t\t\tq.push(nextX,nextY);\n\t\t\t\t\t\t\tflag[nextY][nextX]=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(data[nextY][nextX]==W){\n\t\t\t\t\t\t\tif(state==B){\n\t\t\t\t\t\t\t\tspace=-10000000;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\tstate=W;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(data[nextY][nextX]==B){\n\t\t\t\t\t\t\tif(state==W){\n\t\t\t\t\t\t\t\tspace=-10000000;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\tstate=B;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(state==W) ansW += max(0,space);\n\t\t\t\telse if(state==B) ansB += max(0,space);\n\t\t\t}\n\t\t}\n\t}\n\n\tcout<<ansB<<\" \"<<ansW<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <utility>\n#include <ctime>\n#define INF 999999999\n#define mod 1000000007\n\n#define rep(i,n) for(int i=0;i<int(n);i++)\n#define rrep(i,n) for(int i=(n);i>=0;i--)\n#define REP(i,a,b) for(int i=(a);i<int(b);i++)\n#define all(x) (x).begin(),x.end()\n#define pb push_back\n#define MOD(x) (x%(mod))\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\n\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nbool debug=false;\n/*---------------------------------------------------*/\n\nvoid solve(string s){\n  set<string>se;\n  string ss,rs;\n  rs=s;\n  reverse(all(rs));\n  se.insert(s);\n  se.insert(rs);\n  \n  while(s.size()){\n    ss+=s[0];\n    s.erase(s.begin());\n    se.insert(s+ss);\n    se.insert(ss+s);\n    \n    reverse(all(s));\n    se.insert(ss+s);\n    se.insert(s+ss);\n\n    reverse(all(ss));\n    se.insert(ss+s);\n    se.insert(s+ss);\n\n    reverse(all(s));\n    se.insert(ss+s);\n    se.insert(s+ss);\n\n    reverse(all(ss));\n  }\n  cout<<se.size()<<endl;\n}\n\nint main(){\n  int n;\n  string s;\n  cin>>n;\n  rep(i,n){\n    cin>>s;\n    solve(s);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint w,h,dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};\nstring a[51];\nbool used[51][51];\n\nint dfs(int y,int x){\n  if(y==-1||y==h||x==-1||x==w)return 0;\n  if(a[y][x]=='B')return 1;\n  if(a[y][x]=='W')return 2;\n  if(used[y][x])return 0;\n  used[y][x]=1;\n  int pr=0;\n  for(int t,i=0;i<4;i++){\n    t=dfs(y+dy[i],x+dx[i]);\n    if(!pr)pr=t;\n    else if(t&&pr!=t)pr=3;\n  }\n  return pr;\n}\n\nint main(){\n  while(cin>>w>>h,w){\n    for(int i=0;i<h;i++)cin>>a[i];\n    int ans[5]={};\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){  \n\tmemset(used,0,sizeof(used));\n\tif(a[i][j]=='.')ans[dfs(i,j)]++;\n      }\n    cout<<ans[1]<<\" \"<<ans[2]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// region template\n#define rep(i, a, b) for (int i = (a); i < (b); ++i)\n#define trav(a, x) for (auto &a : x)\n#define all(x) begin(x), end(x)\n#define sz(x) (ll)(x).size()\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nll gcd(ll a, ll b) { return __gcd(a, b); }\n\nll euclid(ll a, ll b, ll &x, ll &y) {\n    if (b) {\n        ll d = euclid(b, a % b, y, x);\n        return y -= a / b * x, d;\n    }\n    return x = 1, y = 0, a;\n}\n\ntypedef unsigned long long ull;\ntypedef long double ld;\null mod_mul(ull a, ull b, ull M) {\n    ll ret = a * b - M * ull(ld(a) * ld(b) / ld(M));\n    return ret + M * (ret < 0) - M * (ret >= (ll)M);\n}\null mod_pow(ull b, ull e, ull mod) {\n    ull ans = 1;\n    for (; e; b = mod_mul(b, b, mod), e /= 2)\n        if (e & 1)\n            ans = mod_mul(ans, b, mod);\n    return ans;\n}\n\nconst ll mod = 1000000007;\nstruct Mod {\n    ll x;\n    Mod(ll xx) : x(xx) {}\n    Mod operator+(Mod b) { return Mod((x + b.x) % mod); }\n    Mod operator-(Mod b) { return Mod((x - b.x) % mod); }\n    Mod operator*(Mod b) { return Mod((x * b.x) % mod); }\n    Mod operator/(Mod b) { return *this * invert(b); }\n    Mod invert(Mod a) {\n        ll x, y, g = euclid(a.x, mod, x, y);\n        assert(g == 1);\n        return Mod((x + mod) % mod);\n    }\n    Mod operator^(ll e) {\n        if (!e)\n            return Mod(1);\n        Mod r = *this ^ (e / 2);\n        r = r * r;\n        return e & 1 ? *this * r : r;\n    }\n};\n// endregion\n\nint isprime(int n) {\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0 && (i % 7 == 1 || i % 7 == 6) && (n / i % 7 == 1 || n / i % 7 == 6)) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint toint(string s) {\n    string b;\n    copy_if(all(s), back_inserter(b), [](char c) { return c != ':'; });\n    return stoi(b);\n}\n\nint main() {\n    cin.sync_with_stdio(0);\n    cin.tie(0);\n    cin.exceptions(cin.failbit);\n\n    const int dir[4][2] = {{0, -1}, {1, 0}, {0, 1}, {-1, 0}};\n\n    for (;;) {\n        int n, m; cin >> n >> m;\n        if (!n) break;\n\n        vector<string> mp(m);\n        rep(i, 0, m) cin >> mp[i];\n\n        vector<vi> vis(m, vi(n, 0));\n\n        int w = 0, b = 0;\n\n        rep(i, 0, m) rep(j, 0, n) if (!vis[i][j] && mp[i][j] == '.') {\n            int color = 0;\n            \n            queue<pair<int, int>> q;\n            q.push({i, j});\n            vis[i][j] = 1;\n\n            int cells = 0;\n            cells++;\n\n            while (!q.empty()) {\n                int x, y;\n                tie(x, y) = q.front(); q.pop();\n\n                rep(i, 0, 4) {\n                    int nx = x + dir[i][0], ny = y + dir[i][1];\n                    if (0 <= nx && nx < m && 0 <= ny && ny < n) {\n                        if (mp[nx][ny] == '.' && !vis[nx][ny]) {\n                            vis[nx][ny] = 1;\n                            q.push({nx, ny});\n                            cells++;\n                        } else if (mp[nx][ny] == 'W') {\n                            color |= 1;\n                        } else if (mp[nx][ny] == 'B') {\n                            color |= 2;\n                        }\n                    }\n                }\n            }\n\n            if (color == 1) {\n                w += cells;\n            } else if (color == 2) {\n                b += cells;\n            }\n        }\n\n        cout << b << \" \" << w << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define o(a) cout << a << endl\n// #define int long long\n#define fi first\n#define se second\nusing namespace std;\ntypedef pair<int, int> P;\n\nint w, h;\nchar c[51][51];\nint dy[4] = {1, -1, 0, 0};\nint dx[4] = {0, 0, 1, -1};\nbool contain(int y, int x){\n    return (0 <= y && y < h && 0 <= x && x < w);\n}\n\nsigned main(){\n    while(1){\n        cin >> w >> h;\n        if(w + h == 0) break;\n        int wsum = 0, bsum = 0;\n        rep(i, 0, h){\n            rep(j, 0, w){\n                cin >> c[i][j];\n                if(c[i][j] == 'W') wsum++;\n                if(c[i][j] == 'B') bsum++;\n            }\n        }\n        int data[51][51] = {};\n        rep(i, 0, h){\n            rep(j, 0, w){\n                if(c[i][j] != '.'){\n                    int id = (c[i][j] == 'W' ? 1 : 2);\n                    string str = \"?BW\";\n                    if(data[i][j] & id) continue;\n                    queue<P> q;\n                    q.push(P(i, j));\n                    data[i][j] |= id;\n                    while(!q.empty()){\n                        P p = q.front(); q.pop();\n                        int y = p.first;\n                        int x = p.second;\n                        rep(k, 0, 4){\n                            int ny = y + dy[k];\n                            int nx = x + dx[k];\n                            if(!contain(ny, nx)) continue;\n                            if(c[ny][nx] == str[id]) continue;\n                            if(data[ny][nx] & id) continue;\n                            data[ny][nx] |= id;\n                            q.push(P(ny, nx));\n                        }\n                    }\n                }\n            }\n        }\n        int wc = 0, bc = 0;\n        rep(i, 0, h){\n            rep(j, 0, w){\n                if(data[i][j] == 1) wc++;\n                if(data[i][j] == 2) bc++;\n                // cout << data[i][j];\n            }\n            // cout << endl;\n        }\n        cout << bc - bsum << \" \" << wc - wsum << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define ALL(a) (a).begin(),(a).end()\nconst int INF = INT_MAX/3;\nconst double EPS = 1e-14;\n\ntemplate<typename U, typename T>\nvoid chmin(U &x, T y) { x = min(x, y); }\n\ntemplate<typename U, typename T>\nvoid chmax(U &x, T y) { x = max(x, y); }\n\ntypedef long long int lli;\ntypedef long double ld;\n\nint W, H;\nconst int HMAX = 58, WMAX = 58;\nchar field[HMAX][WMAX];\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\nbool outof_range(int h, int w) {\n  return h < 0 || W <= h || w < 0 || W <= w;\n}\n\nvoid dfs(int h, int w, char c, char target) {\n  if (outof_range(h, w) or field[h][w] != target) {\n    return;\n  }\n  field[h][w] = c;\n  REP(dir, 4) {\n    dfs(h + dy[dir], w + dx[dir], c, target);\n  }\n}\n\nint main() {\n  cout << fixed << setprecision(10);\n  while (cin >> W >> H and W) {\n    REP(y, HMAX) REP(x, WMAX) {\n      field[y][x] = '#';\n    }\n    REP(y, H) {\n      string row; cin >> row;\n      REP(x, W) {\n        field[y][x] = row[x];\n      }\n    }\n    REP(y, H) REP(x, W) {\n      if (field[y][x] == 'W') {\n        REP(i, 4) {\n          dfs(y + dy[i], x + dx[i], 'w', '.');\n        }\n      }\n      if (field[y][x] == 'B') {\n        REP(i, 4) {\n          dfs(y + dy[i], x + dx[i], 'b', '.');\n        }\n      }\n    }\n    REP(y, H) REP(x, W) {\n      if (field[y][x] == 'W') {\n        REP(i, 4) {\n          dfs(y + dy[i], x + dx[i], 'x', 'b');\n        }\n      }\n      if (field[y][x] == 'B') {\n        REP(i, 4) {\n          dfs(y + dy[i], x + dx[i], 'x', 'w');\n        }\n      }\n      if (field[y][x] == 'x') {\n        REP(i, 4) {\n          dfs(y + dy[i], x + dx[i], 'x', 'w');\n          dfs(y + dy[i], x + dx[i], 'x', 'b');\n        }\n      }\n    }\n    int white = 0, black = 0;\n    REP(y, H) REP(x, W) {\n      char c = field[y][x];\n      if (c == 'w') { white++; }\n      if (c == 'b') { black++; }\n    }\n    cout << black << \" \" << white << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i, a) for (int (i) = 0; (i) < (a); (i)++)\n#define reps(i, a, b) for (int (i) = (a); (i) < (b); (i)++)\n#define MP(a, b) make_pair((a), (b))\n#define pb(a) push_back((a))\n#define all(v) (v).begin(), (v).end()\n\nint minit[50][50];\nint m[50][50];\nint w, h;\nconst int W = 1;\nconst int B = 2;\n\nvoid reset()\n{\n\trep(i, 50) rep(j, 50) {\n\t\tminit[i][j] = 0;\n\t\tm[i][j] = 0;\n\t}\n}\n\nvoid saiki(int r, int c, int x)\n{\n\tif (!(r < h && r >= 0 && c < w && c >= 0)) return;\n\tif (minit[r][c] != 0 || (m[r][c] & x) != 0) return;\n\tm[r][c] += x;\n\tint dr[] = {-1,  0, 0, 1};\n\tint dc[] = { 0, -1, 1, 0};\n\trep(i, 4) saiki(r+dr[i], c+dc[i], x);\n}\n\n\nint main()\n{\n\tcin >> w >> h;\n\twhile (w) {\n\t\trep(i, h) rep(j, w) {\n\t\t\tchar c;\n\t\t\tcin >> c;\n\t\t\tif (c == 'W') minit[i][j] = W;\n\t\t\tif (c == 'B') minit[i][j] = B;\n\t\t\tif (c == '.') minit[i][j] = 0;\n\t\t}\n\t\trep(i, h) rep(j, w) {\n\t\t\tif (minit[i][j]) {\n\t\t\t\tint dr[] = {-1,  0, 0, 1};\n\t\t\t\tint dc[] = { 0, -1, 1, 0};\n\t\t\t\trep (k, 4) saiki(i+dr[k], j+dc[k], minit[i][j]);\n\t\t\t}\n\t\t}\n\t\tint wn = 0, bn = 0;\n\t\trep(i, h) rep(j, w) {\n\t\t\tif (m[i][j] == W) wn++;\n\t\t\tif (m[i][j] == B) bn++;\n\t\t}\n\t\tcout << bn << \" \" << wn << endl;\n\t\tcin >> w >> h;\n\t\treset();\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdio>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <cmath>\n#include <complex>\n#include <map>\n#include <climits>\n#include <sstream>\nusing namespace std;\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define EPS 1e-8\n#define F first\n#define S second\n#define mkp make_pair\n\nstatic const double PI=6*asin(0.5);\ntypedef long long ll;\ntypedef complex<double> CP;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vint;\nstatic const int INF=1<<24;\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v,int a,int b, const T  &t = T()){\n\tv.assign(a,vector<T>(b,t));\n}\n\n//v.erase(unique(v.begin(),v.end()),v.end());\n\nvector<vint> vv;\nvector<vint> vis;\nint B,W;\nint x,y;\nbool f1,f2;\nint foo(int a,int b){\n\tint ret=0;\n\t// cout<<a<<\" \"<<b<<endl;\n\tif(vv[a][b]==1) f1=true;\n\tif(vv[a][b]==2) f2=true;\n\tif(vis[a][b]) return 0;\n\tvis[a][b]=1;\n\tret++;\n\tif(a>0){\n\t\tret+=foo(a-1,b);\n\t}\n\tif(a<x-1){\n\t\tret+=foo(a+1,b);\n\t}\n\tif(b>0){\n\t\tret+=foo(a,b-1);\n\t}\n\tif(b<y-1){\n\t\tret+=foo(a,b+1);\n\t}\n\n\treturn ret;\n}\n\nint main(){\n\t// int x,y;\n\twhile(cin>>x>>y,x||y){\n\t\tinitvv(vv,x,y);\n\t\tinitvv(vis,x,y);\n\t\tB=0;\n\t\tW=0;\n\t\trep(i,x){\n\t\t\trep(j,y){\n\t\t\t\tvis[i][j]=0;\n\t\t\t\tchar t;\n\t\t\t\tcin>>t;\n\t\t\t\tif(t=='B'){\n\t\t\t\t\tvv[i][j]=1;\n\t\t\t\t\tvis[i][j]=1;\n\t\t\t\t}\n\t\t\t\telse if(t=='.'){\n\t\t\t\t\tvv[i][j]=0;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tvv[i][j]=2;\n\t\t\t\t\tvis[i][j]=1;\n\t\t\t\t}\n\t\t\t\t// cout<<vv[i][j];\n\t\t\t}\n\t\t\t// cout<<endl;\n\t\t}\n\t\t// initvv(vis,x,y);\n\t\trep(i,x){\n\t\t\trep(j,y){\n\t\t\t\tif(vis[i][j]==0){\n\t\t\t\t\tf1=false;\n\t\t\t\t\tf2=false;\n\t\t\t\t\tint tt=foo(i,j);\n\t\t\t\t\tif(f1&&!f2){\n\t\t\t\t\t\tB+=tt;\n\t\t\t\t\t}\n\t\t\t\t\tif(!f1&&f2){\n\t\t\t\t\t\tW+=tt;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<B<<\" \"<<W<<endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string.h>\n#include <iostream>\n#include <queue>\n#include <complex>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\nusing namespace std;\n\ntypedef complex<double> P;\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define EQV(a,b) ( EQ( a.real(), b.real() ) && EQ( a.imag(), b.imag() ) )\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define FOR(i,a,n) for(int i=a;i<=n;i++)\n\n//---------------------------------------------------------------------\nvector<string> f(10);\n\nint dx[] = { 1,0,-1,0 };\nint dy[] = { 0,1,0,-1 };\nint w, h;\n\nvoid rec(int x, int y, char c) {\n\trep(i, 4) {\n\t\tint nx = x + dx[i]; int ny = y + dy[i];\n\t\tif (nx < 0 || w <= nx || ny < 0 || h <= ny) continue;\n\t\t\n\t\tif (f[ny][nx] == '.') {\n\t\t\tf[ny][nx] = (c == 'B' ? 'b' : 'w');\n\t\t\trec(nx, ny, c);\n\t\t}\n\t\telse if ((f[ny][nx] == 'b' && c == 'W') || (f[ny][nx] == 'w' || c == 'B')) {\n\t\t\tf[ny][nx] = 'o';\n\t\t\trec(nx, ny, c);\n\t\t}\n\t}\n}\n\nint main() {\n\twhile (cin >> w >> h, (w || h)) {\n\t\tf.clear();\n\t\trep(y, h) {\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tf.push_back(s);\n\t\t}\n\t\trep(y, h) {\n\t\t\trep(x, w) {\n\t\t\t\tif (f[y][x] == 'W' || f[y][x] == 'B') rec(x, y,  f[y][x]);\n\t\t\t}\n\t\t}\n\t\tint blacks = 0, whites = 0;\n\t\trep(y, h) {\n\t\t\trep(x, w) {\n\t\t\t\tif (f[y][x] == 'b') blacks++;\n\t\t\t\telse if (f[y][x] == 'w') whites++;\n\t\t\t}\n\t\t}\n\t\tcout << blacks << \" \" << whites << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Surrounding Area\n#include<bits/stdc++.h>\nusing namespace std;\n#define TMP 9999\n#define INF 1000\n\nint n, m;\nvector<vector<int> > board;\n\n//4\nint dir[4][2]={{-1,0}, {0,1}, {1,0}, {0,-1}};\n\nvoid print(){\n  for(int i=0; i<n; i++){\n    for(int j=0; j<m; j++)\n      printf(\"%5d\", board[i][j]);\n    puts(\"\");\n  }\n}\n\nbool solve(int x, int y, int c){\n  if(!(0<=x && x<n && 0<=y && y<m))return true;//\n  if(board[x][y]==TMP)return true;//\n  if(board[x][y]==INF)return false;//\n  if(board[x][y]==c)return true;\n  if(board[x][y]==-c)return false;\n  if(board[x][y]==2*c)return true;\n  if(board[x][y]==-2*c)return false;\n  board[x][y]=TMP;\n  bool flag=true;\n  for(int i=0; i<4; i++){\n    if(!solve(x+dir[i][0], y+dir[i][1], c)){\n      flag=false;\n      break;\n    }\n  }\n  if(flag){\n    board[x][y]=c*2;\n    return true;\n  }\n  else{\n    board[x][y]=INF;\n    return false;\n  }\n}\n\nint main(){\n  while(true){\n    cin>>m>>n;\n    board.clear();\n    if(n==0 && m==0)break;\n    for(int i=0; i<n; i++){\n      vector<int> tmp;\n      for(int j=0; j<m; j++){\n        char c;\n        cin>>c;\n        int t;\n        if(c=='.')t=0;\n        if(c=='W')t=1;\n        if(c=='B')t=-1;\n        tmp.push_back(t);\n      }\n      board.push_back(tmp);\n    }\n\n    for(int i=0; i<n; i++){\n      for(int j=0; j<m; j++){\n        if(board[i][j]==1){\n          for(int k=0; k<4; k++)solve(i+dir[k][0], j+dir[k][1], 1);\n        }\n        if(board[i][j]==-1){\n          for(int k=0; k<4; k++)solve(i+dir[k][0], j+dir[k][1], -1);\n        }\n      }\n    }\n    /*\n    puts(\"\");\n    print();\n    puts(\"\");\n    */\n    int nw=0, nb=0;\n    for(int i=0; i<n; i++)\n      for(int j=0; j<m; j++)\n        if(board[i][j]==2)nw++;\n        else if(board[i][j]==-2)nb++;\n    printf(\"%d %d\\n\", nb, nw);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector> \n#include <utility>\n#include <string>\n\nusing namespace std;\nint map[2500];\nint adj[2500];\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n/*\nbool tonari(int pos,int color,int w,int h){\n  int x=pos???w;\n  int y=pos/w;\n  for(int dir=0;dir<4;dir++){\n    int npos = pos + dx[dir]+dy[dir]*w;\n    int nx = x + dx[dir];\n    int ny = y + dy[dir];\n    if (ny>=0 && ny <= h-1 && dx>=0 && dx<= w-1){\n      if (map[npos]==color) return true;\n    }\n  }\n  return false;\n}*/\n\nvoid adja(int pos,int color,int w,int h){\n  int x=pos%w;\n  int y=pos/w;\n  for (int dir=0;dir<4;dir++){\n    int npos = pos + dx[dir]+dy[dir]*w;\n    int nx = x + dx[dir];\n    int ny = y + dy[dir];\n    if (ny>=0 && ny <= h-1 && nx>=0 && nx<= w-1){\n      if (map[npos]==0){\n        if ((adj[npos]>>(color-1))%2==0) {\n          adj[npos]+=color;\n          adja(npos,color,w,h);\n        }\n      }\n    }\n  }\n  \n}\n\nint doo()\n{\n  for (int i=0;i<2500;i++){\n    map[i]=0;\n    adj[i]=0;\n  }\n  int w,h,pos;\n  cin >> w >> h;\n  if (w==0 && h==0) return 0;\n  //vector<pair<int,int>> adj(w*h,make_pair(0,0));\n  string buf;\n  for(int y=0;y<h;y++){\n    cin >> buf;\n    for(int x=0;x<w;x++){\n      pos=y*w+x;\n      if (buf[x]=='.') map[pos]=0;\n      else if (buf[x]=='B') map[pos]=1;\n      else map[pos]=2;\n    }\n  }\n  for (int pos=0;pos<w*h;pos++){\n    if (map[pos]!=0) {\n    adja(pos,map[pos],w,h);\n    }\n  }\n  int black=0,white=0;\n  for (int pos=0;pos<w*h;pos++){\n    if (adj[pos]==2) white++;\n    else if (adj[pos]==1) black++;\n  }\n  cout << black << ' ' << white << endl;\n  return 1;\n}\n\nint main(){\n  while (1){\n    int k=doo();\n    if (k==0) break;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint dxy[4] = {-1, 1, 0, 0};\nint W, H;\nchar a[60][60];\nint temp[4][60][60];\n\nvoid huga(int y, int x, int Z){//cout<<y<<\" \"<<x<<endl;\n\tqueue <P> Q;\n\t\n\tQ.push(P(y,x));\n\t\n\twhile(!Q.empty()){\n\t\tP p = Q.front();Q.pop();\n\t\tint yy = p.first, xx = p.second;//cout<<yy<<\" \"<<xx<<endl;\n\t\tfor(int i = 0; i <= 3; i++){\n\t\t\tint nx = xx+dxy[i], ny = yy+dxy[3-i];//cout<<\" \"<<ny<<\" \"<<nx<<endl;\n\t\t\tif(a[ny][nx] == '.' && !temp[Z+2][ny][nx]) {\n\t\t\t\ttemp[Z+2][ny][nx] = temp[Z][ny][nx] = 1;\n\t\t\t\tQ.push(P(ny,nx));\n\t\t\t\t//cout<<temp[2][ny][nx]<<\" \"<<temp[Z][ny][nx]<<\" AA\"<<endl;\n\t\t\t}\n\t\t\t//int fds; cin>>fds;\n\t\t}\n\t}\n}\n\nint main(){\n\t\n\twhile(1){\n\t\tint cw=0, cb=0;\n\t\tcin>>W>>H;\n\t\t\n\t\tif(!W&&!H)break;\n\t\t\n\t\tfor(int i = 0; i <= H+1; i++)\n\t\t\tfor(int j = 0; j <= W+1; j++)\n\t\t\t\ttemp[0][i][j] = temp[1][i][j] = temp[2][i][j] = 0;\n\t\t\t\t\n\t\tfor(int i = 0; i < 60; i++){\n\t\t\ta[0][i] = a[H+1][i] = 0;\n\t\t\ta[i][0] = a[i][W+1] = 0;\n\t\t}\n\t\t\t\n\t\tfor(int i = 1; i <= H; i++)\n\t\t\tfor(int j = 1; j <= W; j++)\n\t\t\t\tcin>>a[i][j];\n\t\t\n\t\tfor(int i = 1; i <= H; i++){\n\t\t\tfor(int j = 1; j <= W; j++){\n\t\t\t\t//if(temp[2][i][j])continue;\n\t\t\t\tif(a[i][j] == 'B') huga(i,j,0);\n\t\t\t\telse if(a[i][j] == 'W') huga(i,j,1);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 1; i <= H; i++){\n\t\t\tfor(int j = 1; j <= W; j++){\n\t\t\t\tif(a[i][j] == '.'){\n\t\t\t\t\tif(temp[0][i][j] && !temp[1][i][j])cb++;\n\t\t\t\t\telse if(!temp[0][i][j] && temp[1][i][j])cw++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout<<cb<<\" \"<<cw<<endl;\n\t}\n\t\n\t\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\n#define stlice(from, to) substr(from, (to) - (from) + 1)\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\nusing namespace std;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\nusing vd = vector<double>;\nusing vc = vector<char>;\nusing vb = vector<bool>;\nusing vs = vector<string>;\nusing vpii = vector<pii>;\nusing vvi = vector<vi>;\nusing vvb = vector<vb>;\nusing vvpii = vector<vpii>;\ntemplate<typename A> using fn = function<A>;\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = acos(-1);\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nconstexpr bool odd(const int &n) { return n & 1; }\nconstexpr bool even(const int &n) { return !odd(n); }\nvoid solve();\nmain { solve(); return 0; }\n// clang-format on\n\nvoid solve() {\n  int W, H;\n  while (cin >> W >> H, W) {\n    vs v(H);\n    rep(i, H) cin >> v[i];\n    vvi dp(H, vi(W));\n    int b = 0, w = 0;\n    rep(i, H) rep(j, W) {\n      dp[i][j] = 2 * (v[i][j] == 'B') + (v[i][j] == 'W');\n      b -= v[i][j] == 'B';\n      w -= v[i][j] == 'W';\n    }\n    rep(_, W * H) rep(i, H) rep(j, W) {\n      if (v[i][j] != '.') continue;\n      if (i > 0) dp[i][j] |= dp[i - 1][j];\n      if (j > 0) dp[i][j] |= dp[i][j - 1];\n      if (i < H - 1) dp[i][j] |= dp[i + 1][j];\n      if (j < W - 1) dp[i][j] |= dp[i][j + 1];\n    }\n    rep(i, H) rep(j, W) {\n      b += dp[i][j] == 2;\n      w += dp[i][j] == 1;\n    }\n    cout << b << ' ' << w << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef struct{\n\tint w = 0;\n\tint b = 0;\n} Grid;\n\nint main(){\n\tint w, h;\n\tint dw[] = {1,0,-1,0};\n\tint dh[] = {0,1,0,-1};\n\twhile(cin >> w >> h, w+h){\n\t\tvector<string> x(h+2);\n\t\tfor(int i = 1; i <= h; ++i){\n\t\t\tcin >> x[i];\n\t\t\tx[i] = \"#\" + x[i] + \"#\";\n\t\t}\n\t\tfor(int i = 0; i < w+2; ++i){\n\t\t\tx[0] += '#';\n\t\t\tx[h+1] += '#';\n\t\t}\n\t\tGrid a[h+2][w+2];\n\t\tfor(int i = 0; i < h+2; ++i){\n\t\t\tfor(int j = 0; j < w+2; ++j){\n\t\t\t\tif(x[i][j]=='#' || x[i][j]=='.') continue;\n\t\t\t\tif(x[i][j]=='W'){\n\t\t\t\t\tqueue<pair<int,int> > q;\n\t\t\t\t\tq.push(make_pair(i,j));\n\t\t\t\t\twhile(!q.empty()){\n\t\t\t\t\t\tint bh = q.front().first;\n\t\t\t\t\t\tint bw = q.front().second;\n\t\t\t\t\t\tq.pop();\n\t\t\t\t\t\tfor(int dir = 0; dir < 4; ++dir){\n\t\t\t\t\t\t\tint nh = bh + dh[dir];\n\t\t\t\t\t\t\tint nw = bw + dw[dir];\n\t\t\t\t\t\t\tif(x[nh][nw]=='#' || x[nh][nw]=='B' || x[nh][nw]=='W') continue;\n\t\t\t\t\t\t\tif(a[nh][nw].w==1) continue;\n\t\t\t\t\t\t\tq.push(make_pair(nh,nw));\n\t\t\t\t\t\t\ta[nh][nw].w = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tqueue<pair<int,int> > q;\n\t\t\t\t\tq.push(make_pair(i,j));\n\t\t\t\t\twhile(!q.empty()){\n\t\t\t\t\t\tint bh = q.front().first;\n\t\t\t\t\t\tint bw = q.front().second;\n\t\t\t\t\t\tq.pop();\n\t\t\t\t\t\tfor(int dir = 0; dir < 4; ++dir){\n\t\t\t\t\t\t\tint nh = bh + dh[dir];\n\t\t\t\t\t\t\tint nw = bw + dw[dir];\n\t\t\t\t\t\t\tif(x[nh][nw]=='#' || x[nh][nw]=='B' || x[nh][nw]=='W') continue;\n\t\t\t\t\t\t\tif(a[nh][nw].b==1) continue;\n\t\t\t\t\t\t\tq.push(make_pair(nh,nw));\n\t\t\t\t\t\t\ta[nh][nw].b = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans_w = 0, ans_b = 0;\n\t\tfor(int i = 1; i < h+1; ++i){\n\t\t\tfor(int j = 1; j < w+1; ++j){\n\t\t\t\tif(a[i][j].w == 1 && a[i][j].b != 1){\n\t\t\t\t\tans_w++;\n\t\t\t\t}\n\t\t\t\tif(a[i][j].w != 1 && a[i][j].b == 1){\n\t\t\t\t\tans_b++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// for(int i = 0; i < h+2; ++i){\n\t\t// \tfor(int j = 0; j < w+2; ++j){\n\t\t// \t\tcout << a[i][j].b;\n\t\t// \t}\n\t\t// \tcout << endl;\n\t\t// }\n\t\tcout << ans_b << \" \" << ans_w << endl;\n\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\nusing namespace std;\n\nint w, h;\nchar mas[50][50];\nint vb[50][50], vw[50][50];\n\nmap< char, int > c;\n\nstatic int dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\n\nvoid rec(int y, int x, int color) {\n    if(!(0 <= x && x < w && 0 <= y && y < h)) return;\n    if(color != c[mas[y][x]] && mas[y][x] != '.') return;\n    if((!color && vb[y][x]) || (color && vw[y][x])) return;\n    if(color) vw[y][x] = 1;\n    else vb[y][x] = 1;\n\n    for(int i = 0; i < 4; i++) {\n        rec(y + dy[i], x + dx[i], color);\n    }\n}\n\nint main() {\n\n    c['B'] = 0, c['W'] = 1, c['.'] = -1;\n\n    while(cin >> w >> h, w) {\n        memset(vb, 0, sizeof(vb));\n        memset(vw, 0, sizeof(vw));\n        for(int i = 0; i < h; i++) {\n            for(int j = 0; j < w; j++) {\n                cin >> mas[i][j];\n            }\n        }\n\n        for(int i = 0; i < h; i++) {\n            for(int j = 0; j < w; j++) {\n                if(mas[i][j] == 'B' && !vb[i][j]) rec(i, j, 0);\n                if(mas[i][j] == 'W' && !vw[i][j]) rec(i, j, 1);\n            }\n        }\n\n        int sumb = 0, sumw = 0;\n        for(int i = 0; i < h; i++) {\n            for(int j = 0; j < w; j++) {\n                if(vb[i][j] ^ vw[i][j] && mas[i][j] == '.') {\n                    if(vb[i][j]) sumb++;\n                    else sumw++;\n                }\n            }\n        }\n\n        cout << sumb << \" \" << sumw << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint main() {\n\tint w, h;\n\twhile (cin >> w >> h) {\n\t\tif (w == 0 && h == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tvector< vector<char> > hyou(h, vector<char>(w));\n\t\tvector< vector<char> > hyou2(h, vector<char>(w));\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tcin >> hyou[i][j];\n\t\t\t\thyou2[i][j] = hyou[i][j];\n\t\t\t}\n\t\t}\n\t\tqueue<P> q;\n\t\tqueue<P> q2;\n\t\tqueue<P> q3;\n\t\tqueue<P> q4;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (hyou[i][j] == 'B') {\n\t\t\t\t\tP p;\n\t\t\t\t\tp.first = i;\n\t\t\t\t\tp.second = j;\n\t\t\t\t\tq.push(p);\n\t\t\t\t\tq4.push(p);\n\t\t\t\t}\n\t\t\t\tif (hyou[i][j] == 'W') {\n\t\t\t\t\tP p;\n\t\t\t\t\tp.first = i;\n\t\t\t\t\tp.second = j;\n\t\t\t\t\tq2.push(p);\n\t\t\t\t\tq3.push(p);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint di[] = {1, 0, -1, 0};\n\t\tint dj[] = {0, 1, 0, -1};\n\t\twhile (!q.empty()) {\n\t\t\tP pp = q.front();\n\t\t\tq.pop();\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tif (pp.first+di[i] >= 0 && pp.first+di[i] < h && pp.second+dj[i] >= 0 && pp.second+dj[i] < w && hyou[pp.first+di[i]][pp.second+dj[i]] == '.') {\n\t\t\t\t\thyou[pp.first+di[i]][pp.second+dj[i]] = 'B';\n\t\t\t\t\tpp.first += di[i];\n\t\t\t\t\tpp.second += dj[i];\n\t\t\t\t\tq.push(pp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile (!q2.empty()) {\n\t\t\tP pp = q2.front();\n\t\t\tq2.pop();\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tif (pp.first+di[i] >= 0 && pp.first+di[i] < h && pp.second+dj[i] >= 0 && pp.second+dj[i] < w && hyou2[pp.first+di[i]][pp.second+dj[i]] == '.') {\n\t\t\t\t\thyou2[pp.first+di[i]][pp.second+dj[i]] = 'W';\n\t\t\t\t\tpp.first += di[i];\n\t\t\t\t\tpp.second += dj[i];\n\t\t\t\t\tq2.push(pp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint counter = 0;\n\t\twhile (!q3.empty()) {\n\t\t\tP pp = q3.front();\n\t\t\tq3.pop();\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tif (pp.first+di[i] >= 0 && pp.first+di[i] < h && pp.second+dj[i] >= 0 && pp.second+dj[i] < w && hyou[pp.first+di[i]][pp.second+dj[i]] == '.') {\n\t\t\t\t\thyou[pp.first+di[i]][pp.second+dj[i]] = 'W';\n\t\t\t\t\tpp.first += di[i];\n\t\t\t\t\tpp.second += dj[i];\n\t\t\t\t\tcounter++;\n\t\t\t\t\tq3.push(pp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint counter2 = 0;\n\t\twhile (!q4.empty()) {\n\t\t\tP pp = q4.front();\n\t\t\tq4.pop();\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tif (pp.first+di[i] >= 0 && pp.first+di[i] < h && pp.second+dj[i] >= 0 && pp.second+dj[i] < w && hyou2[pp.first+di[i]][pp.second+dj[i]] == '.') {\n\t\t\t\t\thyou2[pp.first+di[i]][pp.second+dj[i]] = 'B';\n\t\t\t\t\tpp.first += di[i];\n\t\t\t\t\tpp.second += dj[i];\n\t\t\t\t\tcounter2++;\n\t\t\t\t\tq4.push(pp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << counter2 << ' ' << counter << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) begin(r),end(r)\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init))\n#define mp(a,b) make_pair(a,b)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\n\ntemplate<typename T>\nvoid O(T t){\n  cout << t << endl;\n}\n\nconst ll mod = 1e9+7;\nconstexpr ll inf = ((1<<30)-1)*2+1 ;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\nconst int dy[] = {-1,0,1,0,1,-1,1,-1};\nconst int dx[] = {0,-1,0,1,1,-1,-1,1};\n\ninline bool value(int x,int y,int w,int h){\n  return (x >= 0 && x < w && y >= 0 && y < h);\n}\n\nll W,h;\nvoid solve(vector<vector<int>> &m,int x,int y,int b){\n  rep(i,4){\n    int nx = dx[i] + x,ny = dy[i] + y;\n    if(value(nx,ny,W,h) && !(m[nx][ny] & b)){\n      m[nx][ny] += b;\n      solve(m,nx,ny,b);\n    }\n  }\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  while(cin >> W >> h,W+h){\n    vector<vector<char>> w(51,vector<char>(51));\n    vector<vector<int>> v(51,vector<int>(51));\n    rep(j,h){\n      rep(i,W){\n        cin >> w[i][j];\n        if(w[i][j] == '.'){\n          v[i][j] = 0;\n        }\n        if(w[i][j] == 'W'){\n          v[i][j] = 11;\n        }\n        if(w[i][j] == 'B'){\n          v[i][j] = 7;\n        }\n      } }\n    rep(i,W){\n      rep(j,h){\n        if(v[i][j] == 11)\n        solve(v,i,j,1);\n        if(v[i][j] == 7)\n        solve(v,i,j,2);\n      }\n    }\n    /* rep(j,h){                 */\n    /*   rep(i,W){               */\n    /*     cout << v[i][j] ;     */\n    /*   }                       */\n    /*   std::cout << std::endl; */\n    /* }                         */\n    ll bc = 0,wc = 0;\n    rep(i,W){\n      rep(j,h){\n        if(v[i][j] == 1){\n          wc += 1;\n        }\n      }\n    }\n    rep(i,W){\n      rep(j,h){\n        if(v[i][j] == 2){\n          bc += 1;\n        }\n      }\n    }\n    cout << bc << ' ' << wc << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string.h>\n#include <iostream>\n#include <queue>\n#include <complex>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\nusing namespace std;\n\ntypedef complex<double> P;\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define EQV(a,b) ( EQ( a.real(), b.real() ) && EQ( a.imag(), b.imag() ) )\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define FOR(i,a,n) for(int i=a;i<=n;i++)\n\n//---------------------------------------------------------------------\nvector<string> f(10);\n\nint DX[] = { 1,0,-1,0 };\nint DY[] = { 0,1,0,-1 };\nint w, h;\n\nvoid rec(int x, int y, char c) {\n\trep(i, 4) {\n\t\tint nx = x + DX[i]; int ny = y + DY[i];\n\t\tif (nx < 0 || w <= nx || ny < 0 || h <= ny) continue;\n\t\t\n\t\tif (f[ny][nx] == '.') {\n\t\t\tf[ny][nx] = (c == 'B' ? 'b' : 'w');\n\t\t\trec(nx, ny, c);\n\t\t}\n\t\telse if ((f[ny][nx] == 'b' && c == 'W') || (f[ny][nx] == 'w' && c == 'B')) {;\n\t\t\tf[ny][nx] = 'o';\n\t\t\trec(nx, ny, c);\n\t\t}\n\t}\n}\n\nint main() {\n\twhile (cin >> w >> h, (w || h)) {\n\t\tf.clear();\n\t\trep(y, h) {\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tf.push_back(s);\n\t\t}\n\t\trep(y, h) {\n\t\t\trep(x, w) {\n\t\t\t\tif (f[y][x] == 'W' || f[y][x] == 'B') rec(x, y,  f[y][x]);\n\t\t\t}\n\t\t}\n\t\tint blacks = 0, whites = 0;\n\t\trep(y, h) {\n\t\t\trep(x, w) {\n\t\t\t\tif (f[y][x] == 'b') blacks++;\n\t\t\t\telse if (f[y][x] == 'w') whites++;\n\t\t\t}\n\t\t}\n\t\tcout << blacks << \" \" << whites << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <map>\n#include <list>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <ctype.h>\n#include <ctime>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <bitset>\n#include <cctype>\n#include <cstdlib>\n#include <cstring>\n#include <utility>\n#include <numeric>\n#include <complex>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n#include <iostream>\n#include <iterator>\n#include <algorithm>\n#include <unistd.h>\nusing namespace std;\n\n#define REP(i, x, n) for(int i = x; i < n; i++)\n#define rep(i, n) REP(i, 1, n)\n#define lengthof(x) (sizeof(x) / sizeof(*(x)))\n#define FILL(ptr, value) FILL_((ptr), sizeof(ptr)/sizeof(value), (value))\ntemplate <typename T>\nvoid FILL_(void * ptr, size_t size, T value){\n  std::fill((T*)ptr, (T*)ptr+size, value);\n}\n//4\nconst int dx[] ={1,0,-1,0};\nconst int dy[] ={0,-1,0,1};\nint w,h;\nchar board[55][55];\nint WS,BS;\nbool white[55][55];\nbool black[55][55];\nvoid dfsw(int y,int x){\n  if(white[y][x]||board[y][x] != '.')\n    return;\n  white[y][x] =true;\n  for(int k = 0;k < 4;k++){\n    int nx = x +dx[k];\n    int ny = y +dy[k];\n    if(nx <=0||nx >w||ny <=0||ny >h)\n      continue;\n    else\n      dfsw(ny,nx); \n  }\n}\nvoid dfsb(int y,int x){\n  if(black[y][x]||board[y][x] != '.')\n    return;\n  black[y][x] =true;\n  for(int k = 0;k < 4;k++){\n    int nx = x +dx[k];\n    int ny = y +dy[k];\n    if(nx <=0||nx >w||ny <=0||ny >h)\n      continue;\n    else\n      dfsb(ny,nx); \n  }\n}\nint main()\n{\n  while(cin>>w>>h,w||h){\n    for(int i = 1;i <=h;i++){\n      for(int j = 1;j <=w;j++){\n\tcin>>board[i][j];\n\twhite[i][j] = false;\n\tblack[i][j] = false;\n      }\n    }\n    for(int i = 1;i <=h;i++){\n      for(int j = 1;j <=w;j++){\n\tif(board[i][j] =='W'){\n\t  for(int k = 0;k < 4;k++){\n\t    int nx = j +dx[k];\n\t    int ny = i +dy[k];\n\t    if(nx <=0||nx >w||ny <=0||ny >h)\n\t      continue;\n\t    else\n\t      dfsw(ny,nx);\n\t}\n      }\n\tif(board[i][j] =='B'){\n\t  for(int k = 0;k < 4;k++){\n\t    int nx = j +dx[k];\n\t    int ny = i +dy[k];\n\t    if(nx <=0||nx >w||ny <=0||ny >h)\n\t      continue;\n\t    else\n\t      dfsb(ny,nx);\n\t  }\n\t}\n      }\n    }\n    WS = 0;\n    BS = 0;\n    for(int i = 1;i <=h;i++){\n      for(int j = 1;j <=w;j++){\n\tif(board[i][j] !='.'||(white[i][j]&&black[i][j])||\n\t   (!white[i][j]&&!black[i][j]))\n\t  continue;\n\tif(white[i][j])\n\t  WS++;\n\telse\n\t  BS++;\n      }\n    }\n    cout <<BS<<\" \"<<WS<<endl;\n  }\n  usleep(500000);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "# define _CRT_SECURE_NO_WARNINGS 1\n# include <iostream>\n# include <numeric>\n# include <string>\n# include <bitset>\n# include <vector>\n# include <algorithm>\n# include <cstdlib>\n# include <cstdio>\n# include <cstring>\n# include <cstdlib>\n# include <iomanip>\n# include <queue>\n# include <sstream>\n# include <climits>\n# include <cmath>\n# include <list>\n# include <functional>\n# include <string>\n# include <ctime>\n# include <set>\n# include <map>\n# include <stack>\nusing namespace std;\n//# define M_PI 3.141592\n# define INF ((int)(1<<30))\n# define FOR(i,n) for(int i=0;i<(int)n;i++)\n# define FORI(i,k,n) for(int i=k;i<(int)n;i++)\n# define toRad 2.0*M_PI/360.0\n# define inin(x) int x;cin>>x;\n# define all(x) x.begin(),x.end()\n# define debug(x) cout<<#x<<\" :\"<<x<<endl;\n# define rep(i,n) for(int i=0;i<(int)n;i++)\n# define EPS 1e-12\n# define CHECK(i,a) FOR(i,a.size())cout<<#a<<\"[\"<<i<<\"] : \"<<a[i]<<endl; \ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> piii;\nint dx[4] = { 0,-1,1,0 }, dy[4] = { 1,0,0,-1 };\n\n\nint main()\n{\n\tint w, h;\n\twhile (cin >> w >> h&&w)\n\t{\n\t\tint a[60][60] = {};\n\t\tqueue<pii> bb,ww;\n\t\tfor (int i = 1; i <= h; i++)\n\t\t{\n\t\t\tfor (int j = 1; j <= w; j++)\n\t\t\t{\n\t\t\t\tchar c; cin >> c;\n\t\t\t\tif (c == 'B')\n\t\t\t\t{\n\t\t\t\t\ta[i][j] = 1;\n\t\t\t\t\tbb.push(pii(i, j));\n\t\t\t\t}\n\t\t\t\telse if (c == 'W')\n\t\t\t\t{\n\t\t\t\t\ta[i][j] = -1;\n\t\t\t\t\tww.push(pii(i, j));\n\t\t\t\t}\n\t\t\t\telse a[i][j] = 2;\n\t\t\t}\n\t\t}\n\t\tint B[60][60] = {}, W[60][60] = {};\n\n\t\twhile (!bb.empty())\n\t\t{\n\t\t\tpii now = bb.front(); bb.pop();\n\t\t\tif (a[now.first][now.second] == -1||a[now.first][now.second]==0||B[now.first][now.second])\n\t\t\t\tcontinue;\n\t\t\tB[now.first][now.second] = 1;\n\n\t\t\tfor (int i = 0; i < 4; i++)\n\t\t\t{\n\t\t\t\tpii next = now;\n\t\t\t\tnext.first += dx[i];\n\t\t\t\tnext.second += dy[i];\n\t\t\t\tbb.push(next);\n\t\t\t}\n\t\t}\n\n\t\twhile (!ww.empty())\n\t\t{\n\t\t\tpii now = ww.front(); ww.pop();\n\t\t\tif (a[now.first][now.second] == 1 || a[now.first][now.second] == 0 || W[now.first][now.second])\n\t\t\t\tcontinue;\n\t\t\tW[now.first][now.second] = 1;\n\n\t\t\tfor (int i = 0; i < 4; i++)\n\t\t\t{\n\t\t\t\tpii next = now;\n\t\t\t\tnext.first += dx[i];\n\t\t\t\tnext.second += dy[i];\n\t\t\t\tww.push(next);\n\t\t\t}\n\t\t}\n\t\tint ansb=0, answ=0;\n\t\tfor (int i = 1; i <= h; i++)\n\t\t{\n\t\t\tfor (int j = 1; j <= w; j++)\n\t\t\t{\n\t\t\t\tif (B[i][j] == 1 && W[i][j] == 0&&a[i][j]==2)ansb++;\n\t\t\t\tif (B[i][j] == 0 && W[i][j] == 1&&a[i][j]==2)answ++;\n\t\t\t}\n\t\t}\n\t\tcout << ansb<<\" \"<<answ << endl;\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint w,h,dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};\nstring a[51];\nbool used[51][51];\nint dfs(int y,int x){\n  if(y==-1||y==h||x==-1||x==w)return 0;\n  if(a[y][x]=='B')return 1;\n  if(a[y][x]=='W')return 2;\n  if(used[y][x])return 0;\n  used[y][x]=1;\n  int pr=0;\n  for(int t,i=0;i<4;i++){\n    t=dfs(y+dy[i],x+dx[i]);\n    if(!pr)pr=t;\n    else if(t!=0&&pr!=t)pr=3;\n  }\n  return pr;\n}\n\nint main(){\n  while(cin>>w>>h,w){\n    for(int i=0;i<h;i++)cin>>a[i];\n    int usedd[51][51]={};\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\t\n\tmemset(used,0,sizeof(used));\n\tif(a[i][j]=='.')usedd[i][j]=dfs(i,j);\n      }\n    int ans[5]={};\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++)\n\tcout<<usedd[i][j],ans[usedd[i][j]]++;\n      cout<<endl;\n    }\n    cout<<ans[1]<<\" \"<<ans[2]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int WWW = 0;WWW < (n);WWW++)cerr << v[WWW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nchar mp[55][55];\nint n,m,bb,ww;\nint dx[] = {1,0,-1,0};\nint dy[] = {0,1,0,-1};\nvoid hoge(int h,int w){\n\tqueue<pair<int,int>> q;\n\tbool isb = false,isw = false;\n\tq.push(MP(h,w));\n\tint ret = 0;\n\twhile(!q.empty()){\n\t\tauto now = q.front();q.pop();\n\t\tmp[now.FI][now.SE] = '#';\n\t\tret++;\n\t\tREP(i,4){\n\t\t\tint yy = now.FI + dy[i];\n\t\t\tint xx = now.SE + dx[i];\n\t\t\tif(xx < 0 || yy < 0 || xx >= m|| yy >= n)continue;\n\t\t\tif(mp[yy][xx] == '.')q.push(MP(yy,xx));\n\t\t\tif(mp[yy][xx] == 'B')isb = true;\n\t\t\tif(mp[yy][xx] == 'W')isw = true;\n\t\t}\n\t}\n\tif((isb & isw) || !(isb | isw))return;\n\tif(isb)bb += ret;\n\telse ww += ret;\n}\n\t\t\t\n\nint main(){\n\twhile(cin >> n >> m,n|m){\n\t\tbb = 0,ww = 0;\n\t\tREP(i,n)REP(j,m)cin >> mp[i][j];\n\t\tREP(i,n)REP(j,m){\n\t\t\tif(mp[i][j] == '.')hoge(i,j);\n\t\t}\n\t\tcout << bb << ' ' << ww << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nenum{NONE,BLA,WHI};\n\nint kui[50][50]={};\nbool rin[50][50][WHI+1]={};\nint W,H;\nint dx[4]={1,-1,0,0};\nint dy[4]={0,0,1,-1};\nvoid clear(){\n     for(int i=0;i<50;i++){\n\t  for(int j=0;j<50;j++){\n\t       kui[i][j]=0;\n\t       rin[i][j][BLA]=false;rin[i][j][WHI]=false;\n\t  }\n     }\n}\nvoid rec(int x,int y,int color){\n     if(x>=W||x<0||y>=H||y<0) return;\n     if(kui[x][y]>0||rin[x][y][color])return;\n     rin[x][y][color]=true;\n     for(int i=0;i<4;i++){\n\t  rec(x+dx[i],y+dy[i],color);\n     }\n}\n\nint main(){\n     while(cin>>W>>H,W||H){\n\t  clear();\n\t  for(int i=0;i<H;i++){\n\t       for(int j=0;j<W;j++){\n\t\t    char t;\n\t\t    cin>>t;\n\t\t    switch(t){\n\t\t    case '.':\n\t\t\t break;\n\t\t    case 'B':\n\t\t\t kui[j][i]=BLA;\n\t\t\t break;\n\t\t    case 'W':\n\t\t\t kui[j][i]=WHI;\n\t\t\t break;\n\t\t    }\n\t       }\n\t  }\n\t  for(int i=0;i<W;i++){\n\t       for(int j=0;j<H;j++){\n\t\t    switch(kui[i][j]){\n\t\t    case BLA:\n\t\t\t for(int k=0;k<4;k++) rec(i+dx[k],j+dy[k],BLA);\n\t\t\t break;\n\t\t    case WHI:\n\t\t\t for(int k=0;k<4;k++) rec(i+dx[k],j+dy[k],WHI);\n\t\t\t break;\n\t\t    }\n\t       }\n\t  }\n\t  /*for(int i=0;i<W;i++){\n\t       for(int j=0;j<H;j++){\n\t\t    cout<<kui[i][j];\n\t       }\n\t       cout<<endl;\n\t       }*/\n\t  int sumw=0,sumb=0;\n\t  for(int i=0;i<W;i++){\n\t       for(int j=0;j<H;j++){\n\t\t    if(rin[i][j][BLA]&&(!rin[i][j][WHI]))sumb++;\n\t\t    if(rin[i][j][WHI]&&(!rin[i][j][BLA]))sumw++;\n\t       }\n\t  }\n\t  cout<<sumb<<\" \"<<sumw<<endl;\n     }\n     return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> P;\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nint w, h;\nbool visited[64][64];\nvector<string> maze;\n\nbool check(int x, int y){\n\treturn x >= 0 && x < w && y >= 0 && y < h;\t\n}\n\nint dfs(int x, int y){\n\tif(maze[y][x] == 'B')\n\t\treturn 1;\n\telse if(maze[y][x] == 'W')\n\t\treturn 2;\n\t\n\tint res = 0;\n\tfor(int i = 0; i < 4; ++i){\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\t\tif(!check(nx, ny) || visited[ny][nx])\n\t\t\tcontinue;\n\t\tvisited[ny][nx] = true;\n\t\tres |= dfs(nx, ny);\n\t}\n\treturn res;\n}\nint main() {\n\twhile(cin >> w >> h && (w || h)){\n\t\tstring a;\n\t\tmaze.clear();\n\t\tint cntB = 0, cntW = 0;\n\t\tfor(int i = 0; i < h; ++i){\n\t\t\tcin >> a;\n\t\t\tmaze.push_back(a);\n\t\t}\n\t\tfor(int y = 0; y < h; ++y){\n\t\t\tfor(int x = 0; x < w; ++x){\n\t\t\t\tif(maze[y][x] != '.')\n\t\t\t\t\tcontinue;\n\t\t\t\tmemset(visited, 0, sizeof(visited));\n\t\t\t\tvisited[y][x] = true;\n\t\t\t\tint res = dfs(x, y);\n\t\t\t\tif(res == 2)\n\t\t\t\t\tcntB++;\n\t\t\t\telse if(res == 1)\n\t\t\t\t\tcntW++;\n\t\t\t}\n\t\t}\n\t\tcout << cntB << \" \" << cntW << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n \nint width,height;\nint map[50][50];\nchar input_map[50][51];\n \nint main(void) {\n    int i,j,k;\n    int black,white;\n    while(1) {\n        scanf(\"%d%d\",&width,&height);\n        if(width==0 && height==0)break;\n        memset(map,0,sizeof(map));\n        for(i=0;i<height;i++) {\n            scanf(\"%s\",input_map[i]);\n            for(j=0;j<width;j++) {\n                if(input_map[i][j]=='B')map[i][j]=5;\n                else if(input_map[i][j]=='W')map[i][j]=6;\n            }\n        }\n        for(k=0;k<width*height;k++) {\n            for(i=0;i<height;i++) {\n                for(j=0;j<width;j++) {\n                    if((map[i][j] & 4)==0) {\n                        if(i>0)map[i][j]|=map[i-1][j]&3;\n                        if(j>0)map[i][j]|=map[i][j-1]&3;\n                        if(i<height-1)map[i][j]|=map[i+1][j]&3;\n                        if(j<width-1)map[i][j]|=map[i][j+1]&3;\n                    }\n                }\n            }\n        }\n        black=white=0;\n        for(i=0;i<height;i++) {\n            for(j=0;j<width;j++) {\n                if(map[i][j]==1)black++;\n                else if(map[i][j]==2)white++;\n            }\n        }\n        printf(\"%d %d\\n\",black,white);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> mypair;\nint dx[]={1,-1,0,0};\nint dy[]={0,0,1,-1};\nvoid dfs(vector<vector<bool> > &map,set<mypair> &ans,mypair now){\n\tint x = now.first;\n\tint y = now.second;\n\tmap[x][y] = false;\n\tfor(int i=0;i<4;i++){\n\tint nx = x+dx[i];\n\tint ny = y+dy[i];\n\tif(map[nx][ny]){\n\t\tmypair next = mypair(nx,ny);\n\t\tans.insert(next);\n\t\tdfs(map,ans,next);\n\t}\n\t}\n\treturn ;\n}\n\nint main(){\n\twhile(1){\n\tint w,h;\n\tcin>>w>>h;\n\tif(w==0)break;\n\tvector<vector<bool> > mapb(h+2,vector<bool>(w+2,false) ) ,mapw(h+2,vector<bool>(w+2,false) );\n\tvector<mypair> brack,white;\n\tfor(int i=1;i<=h;i++)\n\t\tfor(int j=1;j<=w;j++)\n\t\t{\n\t\t\tchar a;\n\t\t\tcin>>a;\n\t\t\tif(a=='.'){\n\t\t\t\tmapb[i][j] = true;\n\t\t\t\tmapw[i][j] = true;\n\t\t\t}else if(a=='W')white.push_back(mypair(i,j) );\n\t\t\telse brack.push_back(mypair(i,j) );\n\t\t}\n\tset<mypair> ansb,answ;\n\tfor(int i=0;i<brack.size();i++)dfs(mapb,ansb,brack[i]);\n\tfor(int i=0;i<white.size();i++)dfs(mapw,answ,white[i]);\n\tint cntb=0,cntw=0;\n\tfor(auto i:ansb){\n\t\tauto it = answ.find(i);\n\t\tif(it==answ.end())cntb++;\n\t}\n\tfor(auto i:answ){\n\t\tauto it = ansb.find(i);\n\t\tif(it==ansb.end())cntw++;\n\t}\n\tcout<<cntb<<' '<<cntw<<endl;\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\nstring a[50];\nbool isw[50][50],isb[50][50],visited[50][50];\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1},h,w;\nvoid dfsw(int x,int y){\n\tvisited[x][y]=1;\n\tisw[x][y]=1;\n\trep(i,4){\n\t\tint nx=x+dx[i],ny=y+dy[i];\n\t\tif(0<=nx && nx<h && 0<=ny && ny<w && !visited[nx][ny] && a[nx][ny]=='.') dfsw(nx,ny);\n\t}\n}\nvoid dfsb(int x,int y){\n\tvisited[x][y]=1;\n\tisb[x][y]=1;\n\trep(i,4){\n\t\tint nx=x+dx[i],ny=y+dy[i];\n\t\tif(0<=nx && nx<h && 0<=ny && ny<w && !visited[nx][ny] && a[nx][ny]=='.') dfsb(nx,ny);\n\t}\n}\nint main(){\n\twhile(true){\n\t\tcin>>w>>h;\n\t\tif(w==0)break;\n\t\trep(i,h) rep(j,w) isw[i][j]=0,isb[i][j]=0;\n\t\trep(i,h) cin >> a[i];\n\t\trep(i,h) rep(j,w){\n\t\t\tif(a[i][j]=='W'){\n\t\t\t\trep(ii,h) rep(jj,w) visited[ii][jj]=0;\n\t\t\t\tdfsw(i,j);\n\t\t\t}\n\t\t\tif(a[i][j]=='B'){\n\t\t\t\trep(ii,h) rep(jj,w) visited[ii][jj]=0;\n\t\t\t\tdfsb(i,j);\n\t\t\t}\n\t\t}\n\t\tint cntb=0,cntw=0;\n\t\trep(i,h) rep(j,w) if(a[i][j]=='.') {\n\t\t\tif(isw[i][j] && !isb[i][j]) cntw++;\n\t\t\tif(!isw[i][j] && isb[i][j]) cntb++;\n\t\t}\n\t\tcout << cntb << \" \" << cntw << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\n#define stlice(from, to) substr(from, (to) - (from) + 1)\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\nusing namespace std;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\nusing vd = vector<double>;\nusing vc = vector<char>;\nusing vb = vector<bool>;\nusing vs = vector<string>;\nusing vpii = vector<pii>;\nusing vvi = vector<vi>;\nusing vvb = vector<vb>;\nusing vvpii = vector<vpii>;\ntemplate<typename A> using fn = function<A>;\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = acos(-1);\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nconstexpr bool odd(const int &n) { return n & 1; }\nconstexpr bool even(const int &n) { return !odd(n); }\nvoid solve();\nmain { solve(); return 0; }\n// clang-format on\n\nvoid solve() {\n  int W, H;\n  while (cin >> W >> H, W) {\n    vs v(H);\n    rep(i, H) cin >> v[i];\n    vvi dp(H, vi(W));\n    int b = 0, w = 0;\n    rep(i, H) rep(j, W) {\n      dp[i][j] = 2 * (v[i][j] == 'B') + (v[i][j] == 'W');\n      b -= v[i][j] == 'B';\n      w -= v[i][j] == 'W';\n    }\n    rep(_, W * H) rep(i, H) rep(j, W) {\n      if (v[i][j] != '.') continue;\n      if (i > 0) dp[i][j] |= dp[i - 1][j];\n      if (j > 0) dp[i][j] |= dp[i][j - 1];\n      if (i < H - 1) dp[i][j] |= dp[i + 1][j];\n      if (j < W - 1) dp[i][j] |= dp[i][j + 1];\n    }\n    rep(i, H) rep(j, W) {\n      b += dp[i][j] == 2;\n      w += dp[i][j] == 1;\n    }\n    cout << b << ' ' << w << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 2014\n\n#include <iostream>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nint dy[] = {0, 0, 1, -1}, dx[] = {1, -1, 0, 0};\nstring field[60];\nint h, w;\nint type, cnt;\nbool done[60][60];\n\ntypedef pair <int, int> P;\n\nvoid dfs(int y, int x)\n{\n\tcnt++;\n\tfor (int i = 0; i < 4; i++){\n\t\tint ny = y + dy[i], nx = x + dx[i];\n\t\tif (ny < 0 || nx < 0 || h <= ny || w <= nx) continue;\n\t\t// puts(\"*\");\n\t\tif (!done[ny][nx] && field[ny][nx] == '.'){\n\t\t\tdone[ny][nx] = true;\n\t\t\t// puts(\"*\");\n\t\t\tdfs(ny, nx);\n\t\t}\n\t\tif (field[ny][nx] == 'B'){\n\t\t\ttype |= 1;\n\t\t}\n\t\tif (field[ny][nx] == 'W'){\n\t\t\ttype |= 2;\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\twhile (cin >> w >> h, w && h){\n\t\tfor (int i = 0; i < 60; i++){\n\t\t\tfield[i].clear();\n\t\t}\n\t\tfor (int i = 0; i < 60; i++){\n\t\t\tfor (int j = 0; j < 60; j++){\n\t\t\t\tdone[i][j] = false;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < h; i++){\n\t\t\tcin >> field[i];\n\t\t}\n\n\t\tint ret[128] = {0};\n\t\tfor (int i = 0; i < h; i++){\n\t\t\tfor (int j = 0; j < w; j++){\n\t\t\t\tif (!done[i][j] && field[i][j] == '.') {\n\t\t\t\t\tdone[i][j] = true;\n\t\t\t\t\ttype = cnt = 0;\n\t\t\t\t\tdfs(i, j);\n\t\t\t\t\t// cout << cnt << \" \";\n\t\t\t\t\tret[type] += cnt;\n\t\t\t\t\t/*\n\t\t\t\t\tif (type == 1) cout << 'w';\n\t\t\t\t\tif (type == 0) cout << 'b';\n\t\t\t\t\t*/\n\t\t\t\t}\n\t\t\t\t// else cout << field[i][j];\n\t\t\t}\n\t\t\t// puts(\"\");\n\t\t}\n\t\t// puts(\"\");\n/*\n\t\tfor (int i = 0; i < 20; i++){\n\t\t\tcout << ret[i] << \" \";\n\t\t}\n\t\tputs(\"\");\n*/\n\t\tcout << ret[1] << \" \" << ret[2] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\nusing namespace std;\n\nvoid dfs(int y, int x, vector<string> const& v, vector<vector<bool>>& v2) {\n    int dx[4] = {0, -1, 0, 1}, dy[4] = {1, 0, -1, 0};\n    \n    for(int i=0; i<4; ++i) {\n        int nx = x + dx[i], ny = y + dy[i];\n        if(0 <= nx && nx < v[0].size() && 0 <= ny && ny < v.size() && v[ny][nx] == '.' && !v2[ny][nx]) {\n            v2[ny][nx] = true;\n            dfs(ny, nx, v, v2);\n        } \n    }\n}\n\nint main() {\n    int w, h;\n    while(cin >> w >> h, w) {\n        vector<string> v(h);\n        vector<vector<bool>> B(h, vector<bool>(w, false));\n        vector<vector<bool>> W(h, vector<bool>(w, false));\n        for(int i=0; i<v.size(); ++i) {\n            cin >> v[i];\n        }\n\n        for(int i=0; i<v.size(); ++i) {\n            for(int j=0; j<v[i].size(); ++j) {\n                if(v[i][j] == 'W') {\n                    dfs(i, j, v, W);\n                } else if(v[i][j] == 'B') {\n                    dfs(i, j, v, B);\n                }\n            }\n        }\n\n        int ans_w = 0, ans_b = 0;\n        for(int i=0; i<h; ++i) {\n            for(int j=0; j<w; ++j) {\n                if(!B[i][j] && W[i][j]) {\n                    ans_w++;\n                }\n                if(B[i][j] && !W[i][j]) {\n                    ans_b++;\n                }\n            }\n        }\n        cout << ans_b << \" \" << ans_w << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <cstring>\n#include <cstdio>\n#include <vector>\nusing namespace std;\n\ntypedef vector<pair<int,int> >vpii;\nchar m[99][99];\n\nchar dfs(int i, int j, vpii&v){\n\tif(m[i][j]=='B')return 1;\n\tif(m[i][j]=='W')return 2;\n\tif(m[i][j]=='X')return 0;\n\tint ret=0;\n\tv.push_back(make_pair(i,j));\n\tif(find(v.begin(),v.end(),make_pair(i-1,j))==v.end())ret|=dfs(i-1,j,v);\n\tif(find(v.begin(),v.end(),make_pair(i+1,j))==v.end())ret|=dfs(i+1,j,v);\n\tif(find(v.begin(),v.end(),make_pair(i,j-1))==v.end())ret|=dfs(i,j-1,v);\n\tif(find(v.begin(),v.end(),make_pair(i,j+1))==v.end())ret|=dfs(i,j+1,v);\n\treturn ret;\n}\n\nmain(){\n\tint w,h,i,j,k,r,s;\n\tfor(;scanf(\"%d%d\",&w,&h),w;printf(\"%d %d\\n\",r,s)){\n\t\tfor(memset(m,'X',sizeof(m)),r=s=0,i=1;i<=h;i++)scanf(\"%s\",m[i]+1),m[i][w+1]='X';\n\t\tfor(i=1;i<=h;i++)for(j=1;j<=w;j++)if(m[i][j]=='.'){\n\t\t\tvpii v;\n\t\t\tchar x=dfs(i,j,v);\n\t\t\tfor(k=0;k<v.size();k++)\n\t\t\t\tm[v[k].first][v[k].second]=x;\n\t\t}\n\t\tfor(i=1;i<=h;i++)for(j=1;j<=w;j++)\n\t\t\tif(m[i][j]==1)r++;\n\t\t\telse if(m[i][j]==2)s++;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef struct{\n\tint w = 0;\n\tint b = 0;\n} Grid;\n\nint main(){\n\tint w, h;\n\tint dw[] = {1,0,-1,0};\n\tint dh[] = {0,1,0,-1};\n\twhile(cin >> w >> h, w+h){\n\t\tvector<string> x(h+2);\n\t\tfor(int i = 1; i <= h; ++i){\n\t\t\tcin >> x[i];\n\t\t\tx[i] = \"#\" + x[i] + \"#\";\n\t\t}\n\t\tfor(int i = 0; i < w+2; ++i){\n\t\t\tx[0] += '#';\n\t\t\tx[h+1] += '#';\n\t\t}\n\t\tGrid a[h+2][w+2];\n\t\tfor(int i = 0; i < h+2; ++i){\n\t\t\tfor(int j = 0; j < w+2; ++j){\n\t\t\t\tif(x[i][j]=='#' || x[i][j]=='.') continue;\n\t\t\t\tif(x[i][j]=='W'){\n\t\t\t\t\tqueue<pair<int,int> > q;\n\t\t\t\t\tq.push(make_pair(i,j));\n\t\t\t\t\twhile(!q.empty()){\n\t\t\t\t\t\tint bh = q.front().first;\n\t\t\t\t\t\tint bw = q.front().second;\n\t\t\t\t\t\tq.pop();\n\t\t\t\t\t\tfor(int dir = 0; dir < 4; ++dir){\n\t\t\t\t\t\t\tint nh = bh + dh[dir];\n\t\t\t\t\t\t\tint nw = bw + dw[dir];\n\t\t\t\t\t\t\tif(x[nh][nw]=='#' || x[nh][nw]=='B' || x[nh][nw]=='W') continue;\n\t\t\t\t\t\t\tif(a[nh][nw].w==1) continue;\n\t\t\t\t\t\t\tq.push(make_pair(nh,nw));\n\t\t\t\t\t\t\ta[nh][nw].w = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tqueue<pair<int,int> > q;\n\t\t\t\t\tq.push(make_pair(i,j));\n\t\t\t\t\twhile(!q.empty()){\n\t\t\t\t\t\tint bh = q.front().first;\n\t\t\t\t\t\tint bw = q.front().second;\n\t\t\t\t\t\tq.pop();\n\t\t\t\t\t\tfor(int dir = 0; dir < 4; ++dir){\n\t\t\t\t\t\t\tint nh = bh + dh[dir];\n\t\t\t\t\t\t\tint nw = bw + dw[dir];\n\t\t\t\t\t\t\tif(x[nh][nw]=='#' || x[nh][nw]=='B' || x[nh][nw]=='W') continue;\n\t\t\t\t\t\t\tif(a[nh][nw].b==1) continue;\n\t\t\t\t\t\t\tq.push(make_pair(nh,nw));\n\t\t\t\t\t\t\ta[nh][nw].b = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans_w = 0, ans_b = 0;\n\t\tfor(int i = 1; i < h+1; ++i){\n\t\t\tfor(int j = 1; j < w+1; ++j){\n\t\t\t\tif(a[i][j].w == 1 && a[i][j].b != 1){\n\t\t\t\t\tans_w++;\n\t\t\t\t}\n\t\t\t\tif(a[i][j].w != 1 && a[i][j].b == 1){\n\t\t\t\t\tans_b++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// for(int i = 0; i < h+2; ++i){\n\t\t// \tfor(int j = 0; j < w+2; ++j){\n\t\t// \t\tcout << a[i][j].b;\n\t\t// \t}\n\t\t// \tcout << endl;\n\t\t// }\n\t\tcout << ans_b << \" \" << ans_w << endl;\n\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint w = 0, b = 0;\nint n, m;\nchar d[50][50];\nconst int dx[] = {0,1,0,-1}, dy[] = {1,0,-1,0};\n\nvoid bfs (int x, int y, char s, char t, char u) {\n    queue<P> q;\n    q.push(P(x,y));\n\n    while (q.size()) {\n        P p = q.front();\n        q.pop();\n        for (int i = 0; i < 4; i++) {\n            int x = p.first + dx[i], y = p.second + dy[i];\n            if (0 <= x && x < m && 0 <= y && y < n) {\n                if (d[x][y] == '.') {\n                    if (s == 'W') w++;\n                    else b++;\n                    q.push(P(x,y));\n                    d[x][y] = t;\n                } else if (d[x][y] == u) {\n                    if (s == 'W') b--;\n                    else w--;\n                    q.push(P(x,y));\n                    d[x][y] = t;\n                }\n            }\n        }\n    }\n}\n\nint main ()\n{\n    while (cin >> n >> m, (n || m)) {\n        for (int i = 0; i < m; i++) {\n            cin >> d[i];\n        }\n\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (d[i][j] == 'W') {\n                    bfs(i, j, 'W', '*', '@');\n                }\n            }\n        }\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (d[i][j] == 'B') {\n                    bfs(i, j, 'B', '@', '*');\n                }\n            }\n        }\n        cout << b << \"/\" << w << endl;\n        w = b = 0;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint W,H;\nchar table[60][60] ;\nchar d[] = { '+' , '-' };\nint dx[] = {-1,0,1,0};\nint dy[] = {0,-1,0,1};\n\nvoid search( int x ,int y ,int c ){\n\t\n\tif( table[y][x] == 'W' || table[y][x] == 'B' ) return ;\n\tif( table[y][x] == '*' || table[y][x] == d[c]) return ;\n\t\n\tif( table[y][x] == d[(c+1)%2] ){\n\t\ttable[y][x] = '*' ;\n\t}else {\n\t\ttable[y][x] = d[c] ;\n\t}\n\t\n\tfor( int k=0 ; k<4 ; k++ ){\n\t\tsearch( x+dx[k] , y+dy[k] , c );\n\t}\n}\n\nint main(){\n\t\n\twhile( cin >> W >> H ){\n\t\tif( !W && !H ) break ;\n\t\t\n\t\tfor( int i=0 ; i<=H+1 ; i++ ){\n\t\t\tfor( int j=0 ; j<=W+1 ; j++ ){\n\t\t\t\tif( !i || !j || i==H+1 || j==W+1 ) table[i][j] = '*' ;\n\t\t\t\telse cin >> table[i][j] ;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor( int i=1 ; i<=H ; i++ ){\n\t\t\tfor( int j=1 ; j<=W ; j++ ){\n\t\t\t\tif( table[i][j] == 'W' || table[i][j] == 'B' ){\n\t\t\t\t\tfor( int k=0 ; k<4 ; k++ ){\n\t\t\t\t\t\tsearch( j+dx[k] , i+dy[k] , (table[i][j]=='W')?0:1 );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ansW=0,ansB=0;\n\t\tfor( int i=1 ; i<=H ; i++ ){\n\t\t\tfor( int j=1 ; j<=W ; j++ ){\n\t\t\t\tif( table[i][j] == '+' ) ansW++;\n\t\t\t\tif( table[i][j] == '-' ) ansB++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << ansB << \" \" ;\n\t\tcout << ansW << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nvoid dfs(vector<vector<char>>& v, int y, int x, bool w, bool b) {\n    for (int i = 0; i < 4; i++) {\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n        if (v[ny][nx] == 'W') w = true;\n        if (v[ny][nx] == 'B') b = true;\n        if (!w & !b)\n            v[y][x] = '0';\n        else if (w & !b)\n            v[y][x] = '1';\n        else if (!w & b)\n            v[y][x] = '2';\n        else\n            v[y][x] = '3';\n        if (v[ny][nx] == '.') {\n            dfs(v, ny, nx, w, b);\n        }\n    }\n}\n\nint solve(vector<vector<char>>& v, int y, int x, int& c) {\n    c++;\n    int m   = v[y][x] - '0';\n    v[y][x] = '.';\n    for (int i = 0; i < 4; i++) {\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n        if (v[ny][nx] == '0' || v[ny][nx] == '1' ||\n            v[ny][nx] == '2' || v[ny][nx] == '3') {\n            m = max(solve(v, ny, nx, c), m);\n        }\n    }\n    return m;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while (1) {\n        int w, h;\n        cin >> w >> h;\n        if (!w & !h) break;\n        vector<vector<char>> field;\n        field.push_back(vector<char>(w + 2, '#'));\n        for (int i = 0; i < h; i++) {\n            vector<char> res;\n            string tmp;\n            cin >> tmp;\n            res.push_back('#');\n            for (int j = 0; j < w; j++) {\n                res.push_back(tmp[j]);\n            }\n            res.push_back('#');\n            field.push_back(res);\n        }\n        field.push_back(vector<char>(w + 2, '#'));\n        int wCount = 0, bCount = 0, tmp;\n        for (int i = 1; i <= h; i++) {\n            for (int j = 1; j <= w; j++) {\n                if (field[i][j] == '.') {\n                    dfs(field, i, j, false, false);\n                }\n            }\n        }\n        for (int i = 1; i <= h; i++) {\n            for (int j = 1; j <= w; j++) {\n                if (field[i][j] == '0' || field[i][j] == '1' ||\n                    field[i][j] == '2' || field[i][j] == '3') {\n                    int c = 0;\n                    int m = solve(field, i, j, c);\n                    if (m == 2) bCount += c;\n                    if (m == 1) wCount += c;\n                }\n            }\n        }\n        cout << bCount << \" \" << wCount << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define ll long long\n#define endl '\\n'\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define rep2(i,a,b) for(int i=int(a);i<int(b);i++)\n#define pb emplace_back\n#define all(x) (x).begin(),(x).end()\nint mod=1e9+7;\nint mod2=998244353;\nconst int INF=1e9;\n\nsigned main(){\n    ll h,w;\n    while(1){\n        cin>>w>>h;\n        if(!h&&!w)break;\n        vector<string> hw(h);\n        rep(i,h)cin>>hw[i];\n\n        ll px[]={0,1,0,-1};\n        ll py[]={1,0,-1,0};\n        ll ansb=0;\n        ll answ=0;\n        \n\n        rep(i,h){\n            rep(j,w){\n                if(hw[i][j]=='W'||hw[i][j]=='B'){\n                    char clo=hw[i][j];\n                    rep(p,4){\n                        bool f=true;\n                        ll nx=j+px[p];\n                        ll ny=i+py[p];\n                        if(nx<0||nx>=w||ny<0||ny>=h||hw[ny][nx]!='.')continue;\n                        queue<pair<ll,ll> > qxy;\n                        qxy.push(make_pair(nx,ny));\n                        hw[ny][nx]='N';\n                        while(!qxy.empty()){\n                            ll nnx=qxy.front().first;\n                            ll nny=qxy.front().second;\n                            qxy.pop();\n                            rep(q,4){\n                                ll tx=nnx+px[q];\n                                ll ty=nny+py[q];\n                                if(tx<0||tx>=w||ty<0||ty>=h)continue;\n                                else if(hw[ty][tx]=='W'||hw[ty][tx]=='B'){\n                                    if(hw[ty][tx]!=clo)f=false;\n                                }else if(hw[ty][tx]=='.'){\n                                    hw[ty][tx]='N';\n                                    qxy.push(make_pair(tx,ty));\n                                }\n                            }\n                        }\n                        if(f){\n                            ll tmp=1;\n                            queue<pair<ll,ll> > qnp;\n                            qnp.push(make_pair(nx,ny));\n                            hw[ny][nx]='E';\n                            while(!qnp.empty()){\n                                ll nnx=qnp.front().first;\n                                ll nny=qnp.front().second;\n                                qnp.pop();\n                                rep(p,4){\n                                    ll tx=nnx+px[p];\n                                    ll ty=nny+py[p];\n                                    if(tx<0||tx>=w||ty<0||ty>=h||hw[ty][tx]!='N')continue;\n                                    hw[ty][tx]='E';\n                                    tmp++;\n                                    qnp.push(make_pair(tx,ty));\n                                }\n                            }\n                            if(clo=='W')answ+=tmp;\n                            else ansb+=tmp;\n                        }\n                    }\n                }\n            }\n        }\n        cout<<ansb<<\" \"<<answ<<endl;\n    }\n}\n\n// `.`..`(WNNNNNNMNWWWH9rttwgHM8OtttwwVtttrrtrttrw0rtrtwrrrtrZUAOOrrrXWppHMHyZHpWHMHMkWWVHMNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN\n// `.`.`..`(WMNMHfWH9ZtrtAdNM8ttttOwVtrrtrrtrrrrrdrrttrZkOrrrrrrXWyrtrrZWWWWMmwXWppWHHMmWHkWMMNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN\n// .`.```_..(HMfWH9OtttwXWHBrttrOw0rttrOvrrrtrZrrRrtrrrtZHwrrrrrwwZHyrrrrZWWpWMmwWppkWHHMkHNkVWMNNNNN#NN#NN#NN#NN#NN#NN#NN#NN#NN#NNNN\n// .``.. ..HNfWW9wtrrOdWHM0trttOdSrtrtwwrtrtrw0twSrtOrrrrZHwtrrrrrXwdWwrrrrXHppWNkXWpkvWH@MkHMHkWMMNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN\n// `.`. -jMWWXXwtrttO0d@BrtrttwXVrtrrwVrrrtrtXrrd0rrXrrrrrZWyrrrrrrZXwWyZOrrvWWpWMkZHbkwrdHMMKMMNHkHMNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN\n// `.`. v8Xdk9ttttrOwXM0tttrtwXwwrtrw0rrtrrtwKrrd0rrXrtrrrrZHkwrrrrrrXkVkrrrvrZHWpHHkWkwrwvVHHNWMMMMkWMNNNNNNN#NN#NN#NN#NN#NN#NN#NNNN\n// .. JHZdbKOrrrtrtwWWOOttrOwSzVrOrw0rrttrrrdRrrdZrrdOrtrtrrZHkXwrrrrrZWXHwwrrrvWWWWNkWkvrrrwWM@RMMMNNmWMNNNNNNNNNNNNNNNNNNNNNNNNNNNN\n// . .JGXHStttttrtwW9OrtrrrdSX0rtrdStrtrtrrwHVrrdkrrtSrrrrrrrdMyXrrrrrvXWXWmwvrrvdHWWNkWyvvvvvT@MNWM#N#MNWMMNNNNNNNNNNNNNNNNNNNNNNNNN\n// (.zqHXZtrttrrOwU0trttrOdWX0OtOdRrrtrrrrrdNrrrdkrrrXOwrrrrrrdNySrrrrrwXXkUmvvwvrZHWfNkUkvwvvvdMMMRM#MMNNNkMMNNNNNN#NN#NN#NN#NN#NNNN\n// (wdS0OttrtOOrwSrtttrrtwKukrrrwKrrrrrtrrwW@rrrXKrrrZkr0OrrrrrWNwkrvvrrvzXkXHwvvrvwWVVHkUyrvvvvZHMMNWMMNNNNNkWMNNNNNNNNNNNNNNNNNNNNN\n// wWtrrttrrOwrwStrttrtrwWZXOrtwX0rrrttrrrXMSrrrXWrrrrXrwvrrrrvZHHXkrrrrvrzWkXNyvrvvvWWWHHWwvvvvvwHNMHRM#NNNNNMmWMMNNNNNNNNNNNNNNNNNN\n// 8OtttrwZwwtwSrrttrrrwdyXwtrrdWrrtrrrrrdWH0rrrXWOrrrwRz0rrvrrrdMHWwvvrrvvXWkWHyrvvvrWWWHkHvvvvvvwWMMMNWMMNNNNNMHWMMNMNNNN#NN#NNNNNN\n// wttrrdVrZrwWwtOrrrrwdWX0rrtdH0rrrtrrtwWHHrrrrXWRrrvrXXXrrvrrrvXHkSwvvrvrrXWkVHyvvvvwHVWHWRvvvvvvdHdMMMKMNNNNNNNMNkWMNNNNNNNNNNNNNM\n// ttrrd0rwrOX0rrtrrtwXHXSrwrwHKrtrtrrtrdWH#rrrrdpkrrrrvHwkwvrrvrZWHXkzzvvvvwUWkpNwvrvvZHfVNHwvvvvvzXHWMNMNMNNNNNNNN#NkWMNNNNNNNNNM3>\n// rrrdSrwwtXSrrtrrrwXWWKwrrrdHXrrrrrrrwWWH#vrrrvWpvrrvrdRXwvrvrvvXHWWwkvvrvvwWWKWHzwvvvXHVWWHvzzzzvzWRHMMMNHMNNNNNNNNMNkMMNNNNNN@<<>\n// OOd9rw0rdKOtrtrrruXHW0rrrdH#rrrrrrrrdpWp#rrrrrXWkvrvvrWwkrvrrvwwWHpKdvvrrvvXHHfWmdwvzwWHVHWkzzzzzzwWXHMHHNWMNNNNNNNNNMNkMNNNN#z>>>\n// OdSOwSwwW0rrrrtrwXNW8rrtrWWSrtrrrrrrXpHWHvrrrrXpHrrrvwZHdyvvvvvvXHpHwkvvvvvrXHHfNwXvzzwWWWKHzzzzzzzWSWHHHMMKMNNNNNNNNNNMNKMNN#>>;>\n// wWwOXrwX8rtrrrrwWWpHrrrrdNNrrrrrrrrwppNWHrvrvrypWwvvrrvXKWvrvrvvZXHHkXzvvvvvwWWWWNdkvvzXHfHWkXzzzzzwWXHHHHNMHMNNNNNNNNNNNNNWMN+>>>\n// R0rd0rdKrrtrtrrdWHWSrrrwWWDrrrrrrrrXpWHqWvrrrvdWbRvvrvvwWZkvvvrvvXHbHzRvvvvvvdHHpHkWwvzXWHWHHzuzzzzzXXWHHHMHMNHMNNNNNNNNNNNMNWh<>>\n// wOwSrwXSrtrtrrwHWWMwrrrdNWSrrrrrrrvppWpHprrvrvddWHwvvrrvXHXwvvvrvzXWHkXzvvvvvzWWKWNdRvzzXWWHHXzzzzzzzudWHbH@HNNWMNNNNNNNNNNNNNkHe>\n// rOXwwwKrrrrrrrXWHHDrrwrdHHXwrrrrrrwpWWbHWvvvrvwHHpHrvvvrXWHWwvvrwwXHkHdkvzvvvvZHHpHKWzzzwWHWHRzzzzuzzzzWHHkHHMMNWMNNNNNNNNNNNNNNKm\n// rdX0OXSrrtrrrdHHWMXrrrwHWHrrrrrrrrXppqWHWkrrvvwWMHHXwwvvvZWKRvvvvrWHWHwWvzvzzzzXWKWNXRzzwXWWNHzzzzzzzzzXUHkHWMMHNWMNNNNNNNNNNNNNNN\n// wSwww#rrrrrrwWWHM#vrrrd#WKvrrrrrvvXppmWMWkvvvvwXNNpNvSXzzvdHkkvvzvdWWWRXwzzzzzzdNNpMkHzzzWVHHpXzzzzzzzzdkHkHHHNMHNkMNNNNNNNNNNNNNN\n// XwSwWwrrrrrrdHWWMKrvrvWHWSrvrvvvvwpppHW#HRwUUUWWMMMMMHHHHmmXHWwvvzwWHbNwRzzzzzzzWWWWHWkzzdXWWWRzzzzzzzuzWWbHHWMNMMNkMNNNNNNNNNNNNN\n// 8drd#rrrrrrwWWkHMmXmywMfWXrvrrrvrwppWNWMNWvrvvwvW#MNHmdkrvvXHMMmmwzdWpM0WzzzzzzzdHHWNUHzzzWWmHHzzuzzuzuzWXbbNkHMqMHNkHNNNNNNNNNNNN\n// dSwWSrrrrrrdHHHMHrrrwWMfWvvvrvrrrdppWNW#WWRvvrvvdM?WNHkXkzvvdWMHXHNmHHHkfwzzzzzzXHHpMWHkzuXWHNWXzzuzzuzzXXkkHbHMHMMMMkMNNNNNNNNNNN\n// Xrd#wrrrrrrXpHWH#rrrvdMWWvrrvrvvrdppWHW#(NWwvvvvwMr~TNHmdkvzvXWMKzzzWMHKXXzzzzzzuWHbHkWKuzdWWHWkzzzuzzuuXXHkHkgHk@H@HHkMNNNNNNNNNN\n// RvWDrrrrrrwHWkMW#rvvrMMfWwrvrrvvrdppWHW@~?HHuvvrvdb_~?NWkdkzzzUWMkzuuWWHWXuzwzzuzXHHHKWHuzzWW@WRuzuzzzzzduWbHHgMH@HHHMMHMNNNNNNNNN\n// rdHwrrrrrrXHHWNW#vvvdMMHWkvrvrrvrdppWbWD~~?XKkrrrwMc~~~THHZHwzzWHNkvzwMRdHHzuzzzzXHHWHXNkuzdWHkWuzzuzuzzXzWkHHHMHHHkH@MMNWMNNNNNNN\n// rdHvrrrrrrWkHHHW#rrrd#dNWKrvrvvrvwbpWWW$...vVkkOrtXb~~~~(WHkWkvwWWMkzzWRXkSWXzzzuwmNWHXHRuuwHMKWzzuzzzuzXzWHWHHMHHHkkMMMHHWNNNNNNN\n// wW#rrvrrrwHWHMpWNrvrd@(NWWvrrrrrvvWpWXH$..._?dkkttOWl~~~~~?HHdHXXbWMkzUHXWkzzzzzzuHNk#XHHzzukHHXzuzzzuzuXuXqkMHMHMbbkHHH@HNWMNNNNN\n// dH#rrrvrrdNWWNpHHwrrd@_WHWkrvvrrrrZpWXWr...__?WkWyOvN~~~~~__7HkWkbbkNkzXHZkzzzuzzzWHW#ugbXuzWWHXXuzzuzuuuzXkkHHH@MbkHMHMHMMNWMNNNN\n// X@KrrvrvrXNHWHpHHHrrdb~(NWHrrrrrrrrXWXWr..`...-7HZkzvn~~~~~~~_TNyHHkHMyzXkXuzzzzuuWHW#uHkkzzWHHXuzzzzuzzuuXHkHHHMNbkHHHHHHMMNWMNNN\n// WHKvvrvrvXHNMbpHmHkOwb..?HWRrwOrtrtrWKWr`.`.`..._?6dkJn~~~~~~-_~7NHMHbNkuUkzzuzzzuWHW#uHbRzuXHHXzzuuuuzuuzXHkHHMMbkkHkMkkkMMMNUMMN\n// WHKrrvrrvXqHMpfHHHWkrb...vkHyOrtttttdNXr.`.J>~-((J+ggQkHXHHHmaJz7&JWHMMWkuHXzuuuzzWgHHwHkKuzXMKXuzuuzuzzuzdkHHHHHkHWMHHbkWHMMMNXM#\n// Wg#rvrvrrXmHNpfHHHMMRd-.._4kfyttttllOHWr`` <udT\"\"\"7\"\"\"\"\"TMHHMNHHMNgv4HMRXHXHwuzzzuWHHKXHkHzzXMSWzuzzuzuuzudbkHHHHkkHqHuWkWHHMMMNWM\n// WHNrvrvvvXHmNppgg@MMMHr..` UkWOlllllldW$..?!     `     ` ?@MMHHMM#NMMmMkXXWkHuzuzuWNHSXHHHuuXNSWuzuuzuzuzuWkHNgMkkkMHSuWkqmqHHMNNK\n// WHMkvvrvrXHHMppHHHMNMTN_``` 4kWOz====vXP` `   `        ``.HggmgM@MH###NKkkuXWHzzuXHHMzdMHHuzWNXKzuuzuzuzuuHkHHNMkkHHBuzWkHHHHuHMMM\n// WHHNzvvrvwHMMppHMMMM>.#L`````?kyy====?0S``  `     ` ``...dmqqqmmHHHMMM#WRSzuzWHuzXHq#uWHHHzuWHXKzuzzuzuzuXHkHWMNkWM#uzuWHHHHSuuWM#\n// WM@MkwvvrzXMMHpgHMMM[.MN.`````(HXy1???zd.``  `  `   ` dHkkqkkqkHHHHHHMMWWXzzuzwWwXHHKXMkHHuXMRXSuuuzuuzuzXHkHdHHWHHXuuwWHqHHuXzXWM\n// XHHMNyrvvwdW@HpHWMHML MM[`  ` `.4kGz<<>Or```  `      `dWpbbbbbHMMbbbHHMXXuzzuzuzXWHHSXMkHHuXMSXuzzuzzuzuzWkkHWMHMSwuzzXHkHHXuzuWd#\n// dHHH@NyzwwwWHMHHWMMMR dW]`` ` ```(HZx<<<4.```` `` ``  OZppfppppWfpWpK9NKXuuzuuzuXWHHudMqNHXWNuHuzzuzuzuzuHkHXMMBuuuzuuWkHHUuuuXSMS\n// wWHMMMMkwwvdNpHHHM#MH-jWP``` `` ```7kI<:<h.``````` `` ,2OWVVyVVyWWWWIdMKWzuuuzzuXHHSwHHHHKXHHXSuuzuuzuzuXHHHXMXuuuuuuXHHHuzuuXSX#X\n// wdWHMMMMmwXwHbpMNHMM@b.hb``````````` 7x1_(>_```````````(x7UUUV0XwvCI1dMWKXuzzuzuWHHudMkgkWbMSXuzzzuzzuzuWkHSW#zXwXuXXWHHuuXXuWXWSX\n// vvXWHMMHWNkvWHbbMWMMMN_JF.```` `` `````?1_(_.`.`........(<777=<<<><<+dMXUuzuuuuWWMRwMHWMkWHHXSuuzuzuzzuXqHHXMHUXuXXHHHSuuwuXWud8uH\n// mzzXWH#zHbHkXNbbWMMMMD~(_``````````````` .~_`.``.`.`.....___(<~(<<(<<dHkkuuuuuXkHHuWMkHkkkHSXXzuuzuuuuzXHHSd#uuXXWHHXuuuZuXSuqHudS\n// UHzzXWSXXWbbHHHbWHMH#<~...```` ``````````````.```.` -_____<~~_<_<~~(jMWSuzuzuXWHMHXMHHHkkH#XSuzzuzuzuzuKkHXMQkWHHWUXuXXUuXUuXHuXBu\n// .(Smd8wSvXbbbbHHHWHW3___.``````` `` ``````.```.```.`...._.._~~..~_~~(#WuzuuzXXkHMqMMHMkkkMUXuXzuuwuuzuXkHSWMWUUuuuXXUUuXHXXWSuXHXu\n// .. JKwSvwzWkkkkHHHH5~~..```````````````````.```.````````.` .........dWSuuzzzdkHMW@MHMkkkHHXXuzuuXSuzuuWWHd#uuuXXkWSuXXWUXXHUXWHuuu\n// .`(HXSzzzzwWbkWHNHr_...``````````````````.```````.```````.`.`..`.-.(HKuzzuuwHHMNMHHMkkkHHuZuuzuuXuuuuXkHWMHHHUUuXXXWHXXHHUuXW8uuuu\n// .-MXWwzzzuzXkHHMHHN-.`````````` ````````````.`.````.``.```.`.`....-dXUXuzuXHWHMMHHBWHMMMSZuzuuzXXzuuXHHMHMHkHHHHHHHWHHSuXkHWSuuuuX\n// (#XKzzzzzuzuWHHkWHHp ``.````````````````````````.````````.....-((-(NSXuzzXHW@D:~`(/1- .kXuzuuzXSuuzXXkHWMHHHHHHHHMWuuuQXUXWuuuXuXH\n// MXWzuzzzzzuXHHbHNMMMt`.```````````````````````````.`.` ..-J7\"!``  XKuzzuXHHM9;/<-.J-u!JXXuuzuXWuuuuXHHH#WMNHmkkkuXXkWUXXWXXuuuXqHH\n// XWzzzzuzzwXHHHH#\"````<.````````````````````.``.`...-c\"7``` ` `  `(BzuuuXmHH8<!(- ?_!`jWUuzuuuWuuuzXWHNH> ..7WHHqHmQkWWXXuuuuuXWqHH\n// SwuzzzXuwXHNHY``  ``  <,`.`````````````` `` ..J7=``` ` ` `` ````.#zuzXXHHH$~`` ```(_(HSuuuzuXSuzuuXHHWCi(` ._ ?WggHHHHWkkkkWHHHHMH\n// zzzuzuzwWHMY!`  `   ` `(&.```````````` ..J7^ `` `  `  `   ` `. .HXuuXWHW#!` ` ```` (WUuzzuXXSzuuudHHXY$. : (..``.THHkqkHHHgHHMHkkk\n// zzzzzzXHWK``  ` `` ` ` ` TJ.``````..J7=````    ` `  ` ` `` ` `.8zuXXHHW=`   ``  ..(XSuuuuuXWuuuuXHWH5~~` .`_?_,-``.TMMMMMMHkkqqHHH\n// zzuuzdHHkN ` ` `  ``  ` ``(Wm,.(J7!```  `  ``` `` `` ` ` ``` .SzuXWHHY `` .._~<~~(dSuuuzzXHuuuuXHWHD::?C._.( -`(!_1 ,WHqHHHmqHHHHN\n// zuzXXHHkHM;`  ` ` ` ``  ` .;jY= ` .``_``  `  `  `  ` `` ` `.dXuXWm@^ .._~_.~~~~~(d0uuzuuXHUuuuXHWH5:::::::_.<&._4r?_.;WMMM@MMY\"<!`\n// zzXHHHHMHMb`` `` ` `` `` .J!  ` ..`_~  ` ` ` `` `   `  ``.JXXXHY! .__.....~.~~~-d0wuzuXXHSuuuXWWH$::::;:::;:+- ~`(.i +HqHHkkHL..`.\n// XWHHHMMHMHM; `  ` `   ` ._`` ...(:.=_` `  ` `  ` ```` .-dVT7^``````......~~~~~_jWuuuuuXHSuzuXHHH3<;:::::;;j<+z ``` -dHNkkMqkkN..``\n// HHHMMHHHHNMN.``  ` `  `!`z(. ~..~ ! . ` ``  ` ` ` ..gHr``````````........~~~~_jWuuuuuXkSuuuXHWHC:;::;;:::+v>:((J<!(WHHMkkHNqkM;`..\n// HMMkkHHHHM9?b ``  ` `  ``     .``. `  ` ` `  ``` 4HkkkH,  ``````.`......~~~~_+KuuuzuXHSuuuXHHK<(::::::<;<J+g9>::;<  .4NkkqMHqH]..`\n// MHkHHHMM$<<:?L` `` ` `  ` ``.` `  !``  ` ` ` `  ` ?HbkkHx``````.`..`...~~~~_jKuuuuuXHSuuuqMHD<:<;:<++ddNMB3:;::;:<` `,HkkqH@HH].``\n// kkHHkHY``` (;?h`` ` ` ``  ````  ` ` ` ` ` ` ` ` ```.4XWbHx```..`......~~~~_gKuuuuXWH0uuuXHH3:;++1z<jgMB3<::::::::~` `jMkqkHMHHF.`.\n// kHHHH=` . ` _<?L  ` `  ` `    `  ` ` ` ` ` ` `  ` `  ?kwWHp .`.......~_~~(dKuuuuXWHUuuXWH9++z1<;+jWB3::::;;;::;:;_`` MNkqkqMNMF..`\n// HHk@!.  ` ` ` ~?L  ` ` `` ` `` `` ` ` ` `  ` ` `   `  -WuXHh..`.....~~~~(dWuuuXXkHUuuXHH9>:<:++YY<:;::::;:::::;:::+.``?HHkHHHM>`.`\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n\nusing namespace std;\n\nvoid dfs(vector<string>& m,int i,int j,int w,int h,bool isb){\n  int di[]={1,0,-1,0};\n  int dj[]={0,1,0,-1};\n  for(int k=0;k<4;++k){\n    int ni=i+di[k];\n    int nj=j+dj[k];\n    if(ni<0||ni>=h||nj<0||nj>=w)continue;\n    if(m[ni][nj] == '.'){\n      if(isb){\n        m[ni][nj] = 'b';\n      }else{\n        m[ni][nj] = 'w';\n      }\n      dfs(m,ni,nj,w,h,isb);\n    }else if(isb && m[ni][nj] == 'w'){\n      m[ni][nj] = '*';\n      dfs(m,ni,nj,w,h,isb);\n    }else if(!isb && m[ni][nj] == 'b'){\n      m[ni][nj] = '*';\n      dfs(m,ni,nj,w,h,isb);\n    }\n  }\n}\n\nint main() {\n  while(1){\n    int w,h;\n    cin>>w>>h;\n    if(w==0)break;\n    vector<string> m(h);\n    for(int i=0;i<h;++i)\n      cin>>m[i];\n    for(int i=0;i<h;++i)\n      for(int j=0;j<w;++j)\n        if(m[i][j]=='W' || m[i][j]=='B')\n          dfs(m,i,j,w,h,m[i][j]=='B');\n    int bn=0,wn=0;\n    for(int i=0;i<h;++i)\n      for(int j=0;j<w;++j){\n        if(m[i][j]=='b')\n          ++bn;\n        else if(m[i][j]=='w')\n          ++wn;\n      }\n    cout<<bn<<' '<<wn<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nchar a[51][51];\nint w,h,bcount,wcount;\n//?????????????????????????????????????????????????????????????????????????????????????????????????????????????\nvoid white(int i,int j){\n\tif(a[i-1][j] == 'B' && i-1 >= 0){\n\t\ta[i][j] = 'n';\n\t\treturn;\n\t}\n\telse if(a[i+1][j] == 'B' && i+1 < h){\n\t\ta[i][j] = 'n';\n\t\treturn;\n\t}\n\telse if(a[i][j-1] == 'B' && j-1 >= 0){\n\t\ta[i][j] = 'n';\n\t\treturn;\n\t}\n\telse if(a[i][j+1] == 'B' && j+1 < w){\n\t\ta[i][j] = 'n';\n\t\treturn;\n\t}\n\tif(a[i-1][j] == '.' && i-1 >= 0){\n\t\ta[i-1][j] = 'w';\n\t\twhite(i-1,j);\n\t}\n\tif(a[i+1][j] == '.' && i+1 < h){\n\t\ta[i+1][j] = 'w';\n\t\twhite(i+1,j);\n\t}\n\tif(a[i][j-1] == '.' && j-1 >= 0){\n\t\ta[i][j-1] = 'w';\n\t\twhite(i,j-1);\n\t}\n\tif(a[i][j+1] == '.' && j+1 < w){\n\t\ta[i][j+1] = 'w';\n\t\twhite(i,j+1);\n\t}\n}\n\nvoid black(int i,int j){\n\tif(a[i-1][j] == 'W' && i-1 >= 0){\n\t\ta[i][j] = 'n';\n\t\treturn;\n\t}\n\telse if(a[i+1][j] == 'W' && i+1 < h){\n\t\ta[i][j] = 'n';\n\t\treturn;\n\t}\n\telse if(a[i][j-1] == 'W' && j-1 >= 0){\n\t\ta[i][j] = 'n';\n\t\treturn;\n\t}\n\telse if(a[i][j+1] == 'W' && j+1 < w){\n\t\ta[i][j] = 'n';\n\t\treturn;\n\t}\n\tif(a[i-1][j] == '.' && i-1 >= 0){\n\t\ta[i-1][j] = 'b';\n\t\tblack(i-1,j);\n\t}\n\tif(a[i+1][j] == '.' && i+1 < h){\n\t\ta[i+1][j] = 'b';\n\t\tblack(i+1,j);\n\t}\n\tif(a[i][j-1] == '.' && j-1 >= 0){\n\t\ta[i][j-1] = 'b';\n\t\tblack(i,j-1);\n\t}\n\tif(a[i][j+1] == '.' && j+1 < w){\n\t\ta[i][j+1] = 'b';\n\t\tblack(i,j+1);\n\t}\n}\n\nvoid none(int i,int j){\n\tif(a[i-1][j] == 'w' && i-1 >= 0){\n\t\ta[i-1][j] = 'n';\n\t\tnone(i-1,j);\n\t}\n\tif(a[i+1][j] == 'w' && i+1 < h){\n\t\ta[i+1][j] = 'n';\n\t\tnone(i+1,j);\n\t}\n\tif(a[i][j-1] == 'w' && j-1 >= 0){\n\t\ta[i][j-1] = 'n';\n\t\tnone(i,j-1);\n\t}\n\tif(a[i][j+1] == 'w' && j+1 < w){\n\t\ta[i][j+1] = 'n';\n\t\tnone(i,j+1);\n\t}\n\tif(a[i-1][j] == 'b' && i-1 >= 0){\n\t\ta[i-1][j] = 'n';\n\t\tnone(i-1,j);\n\t}\n\tif(a[i+1][j] == 'b' && i+1 < h){\n\t\ta[i+1][j] = 'n';\n\t\tnone(i+1,j);\n\t}\n\tif(a[i][j-1] == 'b' && j-1 >= 0){\n\t\ta[i][j-1] = 'n';\n\t\tnone(i,j-1);\n\t}\n\tif(a[i][j+1] == 'b' && j+1 < w){\n\t\ta[i][j+1] = 'n';\n\t\tnone(i,j+1);\n\t}\n}\n\n\nvoid check(){\n\tfor(int i = 0;i < h;i++){\n\t\tfor(int j = 0;j < w;j++){\n\t\t\tif(a[i][j] == 'W'){\n\t\t\t\tif(a[i-1][j] == '.' && i-1 >= 0){\n\t\t\t\t\ta[i-1][j] = 'w';\n\t\t\t\t\twhite(i-1,j);\n\t\t\t\t}\n\t\t\t\tif(a[i+1][j] == '.' && i+1 < h){\n\t\t\t\t\ta[i+1][j] = 'w';\n\t\t\t\t\twhite(i+1,j);\n\t\t\t\t}\n\t\t\t\tif(a[i][j-1] == '.' && j-1 >= 0){\n\t\t\t\t\ta[i][j-1] = 'w';\n\t\t\t\t\twhite(i,j-1);\n\t\t\t\t}\n\t\t\t\tif(a[i][j+1] == '.' && j+1 < w){\n\t\t\t\t\ta[i][j+1] = 'w';\n\t\t\t\t\twhite(i,j+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(a[i][j] == 'B'){\n\t\t\t\tif(a[i-1][j] == '.' && i-1 >= 0){\n\t\t\t\t\ta[i-1][j] = 'b';\n\t\t\t\t\tblack(i-1,j);\n\t\t\t\t}\n\t\t\t\tif(a[i+1][j] == '.' && i+1 < h){\n\t\t\t\t\ta[i+1][j] = 'b';\n\t\t\t\t\tblack(i+1,j);\n\t\t\t\t}\n\t\t\t\tif(a[i][j-1] == '.' && j-1 >= 0){\n\t\t\t\t\ta[i][j-1] = 'b';\n\t\t\t\t\tblack(i,j-1);\n\t\t\t\t}\n\t\t\t\tif(a[i][j+1] == '.' && j+1 < w){\n\t\t\t\t\ta[i][j+1] = 'b';\n\t\t\t\t\tblack(i,j+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0;i < h;i++){\n\t\tfor(int j = 0;j < w;j++){\n\t\t\tif(a[i][j] == 'n'){\n\t\t\t\tnone(i,j);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(1){\n\t\tcin >> h >> w;\n\t\tif(h == 0)break;\n\t\tbcount = wcount = 0;\n\t\tfor(int i = 0;i < h;i++){\n\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\tcin >> a[i][j];\n\t\t\t}\n\t\t}\n\tcheck();\n\n\tfor(int i = 0;i < h;i++){\n\t\tfor(int j = 0;j < w;j++){\n\t\t\tif(a[i][j] == 'w')wcount++;\n\t\t\tif(a[i][j] == 'b')bcount++;\n\t\t\tcout << a[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << bcount << \" \" << wcount <<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cstdio>\n#include<cstring>\n#include<string>\n\n#define REP(i,n) for(int i=0;i<(n);i++)\n\nint di[4] = {1, 0, -1, 0};\nint dj[4] = {0, 1, 0, -1};\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\nconst ll INF = 1e18;\n\nint w, h;\nchar field[51][51];\nbool visited[51][51];\nbool white_flg;\nbool black_flg;\n\nint dfs(int i, int j){\n    if(i<0 || h<=i || j<0 || j>=w || visited[i][j]) return 0;\n    if(field[i][j] == 'B'){\n        black_flg = true;\n        return 0;\n    }\n    if(field[i][j] == 'W'){\n        white_flg = true;\n        return 0;\n    }\n    visited[i][j] = true;\n    int res = 1;\n    REP(k,4){\n        res += dfs(i+di[k], j+dj[k]);\n    }\n    return res;\n}\n\nint main(){\n    while(cin >> w >> h){\n        if(w+h==0) break;\n        int white = 0;\n        int black = 0;\n        memset(visited, false, sizeof(visited));\n        REP(i,h) cin >> field[i];\n\n        REP(i,h){\n            REP(j,w){\n                if(!visited[i][j] && field[i][j] == '.'){\n                    white_flg = false;\n                    black_flg = false;\n                    int s = dfs(i,j);\n                    if(white_flg && !black_flg) white += s;\n                    else if(black_flg && !white_flg) black += s;\n                }\n            }\n        }\n        cout << black << ' ' << white << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint w = 0, b = 0;\nint n, m;\nchar d[50][50];\nconst int dx[] = {0,1,0,-1}, dy[] = {1,0,-1,0};\n\nvoid bfs (int x, int y, char s, char t, char u) {\n    queue<P> q;\n    q.push(P(x,y));\n\n    while (q.size()) {\n        P p = q.front();\n        q.pop();\n        for (int i = 0; i < 4; i++) {\n            int x = p.first + dx[i], y = p.second + dy[i];\n            if (0 <= x && x < m && 0 <= y && y < n) {\n                if (d[x][y] == '.') {\n                    if (s == 'W') w++;\n                    else b++;\n                    q.push(P(x,y));\n                    d[x][y] = t;\n                } else if (d[x][y] == u) {\n                    if (s == 'W') b--;\n                    else w--;\n                    q.push(P(x,y));\n                    d[x][y] = t;\n                }\n            }\n        }\n    }\n}\n\nint main ()\n{\n    while (cin >> n >> m, (n || m)) {\n        for (int i = 0; i < m; i++) {\n            cin >> d[i];\n        }\n\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (d[i][j] == 'W') {\n                    bfs(i, j, 'W', '*', '@');\n                }\n            }\n        }\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (d[i][j] == 'B') {\n                    bfs(i, j, 'B', '@', '*');\n                }\n            }\n        }\n        cout << b << \" \" << w << endl;\n        w = b = 0;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint main() {\n\tint w, h;\n\twhile (cin >> w >> h) {\n\t\tif (w == 0 && h == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tvector< vector<char> > hyou(h, vector<char>(w));\n\t\tvector< vector<char> > hyou2(h, vector<char>(w));\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tcin >> hyou[i][j];\n\t\t\t\thyou2[i][j] = hyou[i][j];\n\t\t\t}\n\t\t}\n\t\tqueue<P> q;\n\t\tqueue<P> q2;\n\t\tqueue<P> q3;\n\t\tqueue<P> q4;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (hyou[i][j] == 'B') {\n\t\t\t\t\tP p;\n\t\t\t\t\tp.first = i;\n\t\t\t\t\tp.second = j;\n\t\t\t\t\tq.push(p);\n\t\t\t\t\tq4.push(p);\n\t\t\t\t}\n\t\t\t\tif (hyou[i][j] == 'W') {\n\t\t\t\t\tP p;\n\t\t\t\t\tp.first = i;\n\t\t\t\t\tp.second = j;\n\t\t\t\t\tq2.push(p);\n\t\t\t\t\tq3.push(p);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint di[] = {1, 0, -1, 0};\n\t\tint dj[] = {0, 1, 0, -1};\n\t\twhile (!q.empty()) {\n\t\t\tP pp = q.front();\n\t\t\tq.pop();\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tif (pp.first+di[i] >= 0 && pp.first+di[i] < h && pp.second+dj[i] >= 0 && pp.second+dj[i] < w && hyou[pp.first+di[i]][pp.second+dj[i]] == '.') {\n\t\t\t\t\thyou[pp.first+di[i]][pp.second+dj[i]] = 'B';\n\t\t\t\t\tP ppp;\n\t\t\t\t\tppp.first = pp.first+di[i];\n\t\t\t\t\tppp.second = pp.second+dj[i];\n\t\t\t\t\tq.push(ppp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile (!q2.empty()) {\n\t\t\tP pp = q2.front();\n\t\t\tq2.pop();\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tif (pp.first+di[i] >= 0 && pp.first+di[i] < h && pp.second+dj[i] >= 0 && pp.second+dj[i] < w && hyou2[pp.first+di[i]][pp.second+dj[i]] == '.') {\n\t\t\t\t\thyou2[pp.first+di[i]][pp.second+dj[i]] = 'W';\n\t\t\t\t\tP ppp;\n\t\t\t\t\tppp.first = pp.first+di[i];\n\t\t\t\t\tppp.second = pp.second+dj[i];\n\t\t\t\t\tq2.push(ppp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint counter = 0;\n\t\twhile (!q3.empty()) {\n\t\t\tP pp = q3.front();\n\t\t\tq3.pop();\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tif (pp.first+di[i] >= 0 && pp.first+di[i] < h && pp.second+dj[i] >= 0 && pp.second+dj[i] < w && hyou[pp.first+di[i]][pp.second+dj[i]] == '.') {\n\t\t\t\t\thyou[pp.first+di[i]][pp.second+dj[i]] = 'W';\n\t\t\t\t\tP ppp;\n\t\t\t\t\tppp.first = pp.first+di[i];\n\t\t\t\t\tppp.second = pp.second+dj[i];\n\t\t\t\t\tcounter++;\n\t\t\t\t\tq3.push(ppp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint counter2 = 0;\n\t\twhile (!q4.empty()) {\n\t\t\tP pp = q4.front();\n\t\t\tq4.pop();\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tif (pp.first+di[i] >= 0 && pp.first+di[i] < h && pp.second+dj[i] >= 0 && pp.second+dj[i] < w && hyou2[pp.first+di[i]][pp.second+dj[i]] == '.') {\n\t\t\t\t\thyou2[pp.first+di[i]][pp.second+dj[i]] = 'B';\n\t\t\t\t\tP ppp;\n\t\t\t\t\tppp.first = pp.first+di[i];\n\t\t\t\t\tppp.second = pp.second+dj[i];\n\t\t\t\t\tcounter2++;\n\t\t\t\t\tq4.push(ppp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << counter2 << ' ' << counter << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nconst int MAX = 51;\nint H,W,cnt;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nstring str[MAX];\nbool BW[2];\n \nvoid dfs(int x,int y){  \n    if(x < 0 || x >= W || y < 0 || y >= H) return;\n    if(str[x][y] == 'B'){\n\tBW[0] = true;\n\treturn;\n    }\n    else if(str[x][y] == 'W'){\n\tBW[1] = true;\n\treturn;\n    }\n    if(str[x][y] == '.'){\n\tcnt++;  \n\tstr[x][y] = '#';\n    }\n \n    for(int i = 0 ; i < 4 ; i++){\n\tint nx = dx[i]+x;\n\tint ny = dy[i]+y;\n \n\tif(0 <= nx && nx < W && 0 <= ny && ny < H&&str[nx][ny] != '#'){\n\t    dfs(nx,ny);\n\t}\n    }\n}\n \nint main(){\n    while(cin >> H >> W ,H + W){  \n\tfor(int i = 0 ; i < W ; i++){\n\t    cin >> str[i];\n\t}\n\tint BB = 0,WW = 0;\n\tfor(int i = 0 ; i < W ; i++){\n\t    for(int j = 0 ; j < H ; j++){\n\t\tcnt = 0;\n\t\tmemset(BW,false,sizeof(BW));\n\t\tdfs(i,j);\n\t\tif(BW[0]&&!BW[1]) BB += cnt;\n\t\telse if(!BW[0]&&BW[1]) WW += cnt;\n\t    }\n\t}    \n\tcout << BB << ' ' << WW << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nvoid look(int,int,char);\nvoid zen(int ,int ,char);\nint w,h;\nvector<vector <char> >a;\nint cb;\nint cw;\nint cou;\nint main(){\n  while(1){\n    cb=0;\n    cw=0;\n    cin >> w >> h;\n    if(w==0&&h==0)break;\n    a=vector<vector<char> >(h,vector<char>(w));\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin >> a[i][j];\n      }\n    }\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tif(a[i][j]=='W'){\n\t  look(i,j,'W');\n\t}\n\telse if(a[i][j]=='B'){\n\t  look(i,j,'B');\n\t}\n      }\n    }\n    cout << cb << \" \" << cw << endl;\n  }\n  return 0;\n\n}\nvoid look(int I,int J,char cl){\n  int lx[4]={-1,0,1,0};\n  int ly[4]={0,-1,0,1};\n  for(int i=0;i<4;i++){\n    if(I+lx[i]<0||I+lx[i]>=h||J+ly[i]<0||J+ly[i]>=w)continue;\n    if(a[I+lx[i]][J+ly[i]]=='.'){\n      cou=0;\n      zen(I+lx[i],J+ly[i],cl);\n      if(cou!=-1){\n\tif(cl=='B')cb+=cou;\n\telse cw+=cou;\n      }\n    }\n  }\n}\nvoid zen(int I,int J,char cl){\n  if(a[I][J]=='.'){\n    a[I][J]='l';\n    if(cou>=0)cou++;\n  }\n  else if(a[I][J]==cl||a[I][J]=='l')return;\n  else{\n    cou = -1;\n    return;\n  }\n  int lx[4]={-1,0,1,0};\n  int ly[4]={0,-1,0,1};\n  for(int i=0;i<4;i++){\n    if(I+lx[i]<0||I+lx[i]>=h||J+ly[i]<0||J+ly[i]>=w)continue;\n    zen(I+lx[i],J+ly[i],cl);\n  }\n}\n\n    "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nbool between(int a, int b, int c){\n\treturn a <= b && b < c;\n}\n\nvoid paint(\n\tint x, int y, const vector<string> &field,\n\tvector< vector<int> > &canvas)\n{\n\tconst int W = field[0].size(), H = field.size();\n\tif(!between(0, x, W) || !between(0, y, H)){ return; }\n\tif(field[y][x] != '.' || canvas[y][x]){ return; }\n\tcanvas[y][x] = 1;\n\tfor(int i = 0; i < 4; ++i){\n\t\tpaint(x + dx[i], y + dy[i], field, canvas);\n\t}\n}\n\nint main(){\n\twhile(true){\n\t\tint w, h;\n\t\tcin >> w >> h;\n\t\tif(w == 0 && h == 0){ break; }\n\t\tvector<string> field(h);\n\t\tfor(int i = 0; i < h; ++i){ cin >> field[i]; }\n\t\tvector< vector<int> > white(h, vector<int>(w));\n\t\tvector< vector<int> > black(h, vector<int>(w));\n\t\tfor(int y = 0; y < h; ++y){\n\t\t\tfor(int x = 0; x < w; ++x){\n\t\t\t\tfor(int i = 0; i < 4; ++i){\n\t\t\t\t\tif(field[y][x] == 'W'){\n\t\t\t\t\t\tpaint(x + dx[i], y + dy[i], field, white);\n\t\t\t\t\t}else if(field[y][x] == 'B'){\n\t\t\t\t\t\tpaint(x + dx[i], y + dy[i], field, black);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint wsum = 0, bsum = 0;\n\t\tfor(int y = 0; y < h; ++y){\n\t\t\tfor(int x = 0; x < w; ++x){\n\t\t\t\tif(white[y][x] == black[y][x]){ continue; }\n\t\t\t\tif(white[y][x]){ ++wsum; }\n\t\t\t\tif(black[y][x]){ ++bsum; }\n\t\t\t}\n\t\t}\n\t\tcout << bsum << \" \" << wsum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nvoid dfs(vector<vector<char>>& v, int y, int x, bool w, bool b) {\n    for (int i = 0; i < 4; i++) {\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n        if (v[ny][nx] == 'W') w = true;\n        if (v[ny][nx] == 'B') b = true;\n        if (!w & !b)\n            v[y][x] = '0';\n        else if (w & !b)\n            v[y][x] = '1';\n        else if (!w & b)\n            v[y][x] = '2';\n        else if (w & b)\n            v[y][x] = '3';\n    }\n    for (int i = 0; i < 4; i++) {\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n        if (v[ny][nx] == '.') {\n            dfs(v, ny, nx, w, b);\n        }\n    }\n}\n\nint solve(vector<vector<char>>& v, int y, int x, int& c) {\n    c++;\n    int m   = v[y][x] - '0';\n    v[y][x] = '.';\n    for (int i = 0; i < 4; i++) {\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n        if (v[ny][nx] == '0' || v[ny][nx] == '1' ||\n            v[ny][nx] == '2' || v[ny][nx] == '3') {\n            m = max(solve(v, ny, nx, c), m);\n        }\n    }\n    return m;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while (1) {\n        int w, h;\n        cin >> w >> h;\n        if (!w & !h) break;\n        vector<vector<char>> field;\n        field.push_back(vector<char>(w + 2, '#'));\n        for (int i = 0; i < h; i++) {\n            vector<char> res;\n            string tmp;\n            cin >> tmp;\n            res.push_back('#');\n            for (int j = 0; j < w; j++) {\n                res.push_back(tmp[j]);\n            }\n            res.push_back('#');\n            field.push_back(res);\n        }\n        field.push_back(vector<char>(w + 2, '#'));\n        int wCount = 0, bCount = 0, tmp;\n        for (int i = 1; i <= h; i++) {\n            for (int j = 1; j <= w; j++) {\n                if (field[i][j] == '.') {\n                    dfs(field, i, j, false, false);\n                }\n            }\n        }\n        for (int i = 1; i <= h; i++) {\n            for (int j = 1; j <= w; j++) {\n                if (field[i][j] == '0' || field[i][j] == '1' ||\n                    field[i][j] == '2' || field[i][j] == '3') {\n                    int c = 0;\n                    int m = solve(field, i, j, c);\n                    if (m == 2) bCount += c;\n                    if (m == 1) wCount += c;\n                }\n            }\n        }\n        cout << bCount << \" \" << wCount << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nchar map[50][51];\nint w,h,table[50][50],d_row[4] = {-1,0,0,1},d_col[4] = {0,-1,1,0};\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= h-1 && col >= 0 && col <= w-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\nvoid paint(int row,int col){\n\tif(table[row][col] == 2 || table[row][col] == 1){\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tif((rangeCheck(row+d_row[i],col+d_col[i]) == true) && (table[row+d_row[i]][col+d_col[i]] == 0 || table[row+d_row[i]][col+d_col[i]] == 10)){\n\t\t\t\ttable[row+d_row[i]][col+d_col[i]] += 1;\n\t\t\t\tpaint(row+d_row[i],col+d_col[i]);\n\t\t\t}\n\t\t}\n\n\t}else if(table[row][col] == 4 || table[row][col] == 10){\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tif((rangeCheck(row+d_row[i],col+d_col[i]) == true) && (table[row+d_row[i]][col+d_col[i]] == 0 || table[row+d_row[i]][col+d_col[i]] == 1)){\n\t\t\t\ttable[row+d_row[i]][col+d_col[i]] += 10;\n\t\t\t\tpaint(row+d_row[i],col+d_col[i]);\n\t\t\t}\n\t\t}\n\t}else if(table[row][col] == 11){\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tif((rangeCheck(row+d_row[i],col+d_col[i]) == true) && (table[row+d_row[i]][col+d_col[i]] == 0 || table[row+d_row[i]][col+d_col[i]] == 1 || table[row+d_row[i]][col+d_col[i]] == 10)){\n\t\t\t\ttable[row+d_row[i]][col+d_col[i]] = 11;\n\t\t\t\tpaint(row+d_row[i],col+d_col[i]);\n\t\t\t}\n\t\t}\n\t}\n\n}\n\n\nvoid func(){\n\n\tfor(int i = 0; i < h; i++){\n\t\tfor(int k = 0; k < w; k++)table[i][k] = 0;\n\t}\n\n\tfor(int i = 0; i < h; i++){\n\t\tscanf(\"%s\",map[i]);\n\t}\n\n\tfor(int i = 0; i < h; i++){\n\t\tfor(int k = 0; k < w; k++){\n\t\t\tif(map[i][k] == 'B'){\n\t\t\t\ttable[i][k] = 2;\n\t\t\t}else if(map[i][k] == 'W'){\n\t\t\t\ttable[i][k] = 4;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < h; i++){\n\t\tfor(int k = 0; k < w; k++){\n\t\t\tif(table[i][k] == 2 || table[i][k] == 4){\n\t\t\t\tpaint(i,k);\n\t\t\t}\n\t\t}\n\t}\n\n\tint black = 0,white = 0;\n\n\tfor(int i = 0; i < h; i++){\n\t\tfor(int k = 0; k < w; k++){\n\t\t\tif(table[i][k] == 1){\n\t\t\t\tblack++;\n\t\t\t}else if(table[i][k] == 10){\n\t\t\t\twhite++;\n\t\t\t}\n\n\t\t}\n\t}\n\n\tprintf(\"%d %d\\n\",black,white);\n\n}\n\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w == 0 && h == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nchar m[55][55];\nbool used[55][55];\nint w,h;\nint dx[] = {0,0,1,-1};\nint dy[] = {1,-1,0,0};\nchar c,c_;\nbool f;\n\nint solve(int x,int y){\n  int ret = 1;\n  used[x][y] = false;\n  for(int i = 0; i < 4; i++){\n    int nx = x + dx[i];\n    int ny = y + dy[i];\n    if(m[nx][ny] == c){\n      f = true;\n    }\n    if(m[nx][ny] == c_){\n      return -1000000;\n    }\n    if(m[nx][ny] == '.' && used[nx][ny]){\n      ret += solve(nx,ny);\n    }\n  }\n  return ret;\n}\n\nint main(void){\n  while(1){\n    scanf(\"%d%d\",&w,&h);\n    if(!w && !h) break;\n    memset(m,0,sizeof(m));\n    for(int i = 1; i <= h; i++){\n      for(int j = 1; j <= w; j++){\n\tscanf(\" %c\",&m[i][j]);\n      }\n    }\n    for(int k = 0; k < 2; k++){\n      int ans = 0;\n      memset(used,true,sizeof(used));\n      c_ = (k)?'B':'W';\n      c = (!k)?'B':'W';\n      for(int i = 1; i <= h; i++){\n\tfor(int j = 1; j <= w; j++){\n\t  if(m[i][j] == '.' && used[i][j]){\n\t    f = false;\n\t    int ret = max(0,solve(i,j));\n\t    if(f){\n\t      ans += ret;\n\t    }\n\t  }\n\t}\n      }\n      printf(\"%d%c\",ans,(k)?'\\n':' ');\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <numeric>\n\nusing namespace std;\n\ntypedef unsigned int UI;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int,int> PII;\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define EACH( v, c ) for ( auto &v : c )\n\n#define ITER( c ) __typeof( (c).begin() )\n#define IREP( c, it ) for ( ITER(c) it = c.begin(); it != c.end(); ++it )\n#define ALL( c ) (c).begin(), (c).end()\n\n#define PB( n ) push_back( n )\n#define MP( a, b ) make_pair( ( a ), ( b ) )\n#define EXIST( c, e ) ( (c).find( e ) != (c).end() )\n\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define DEBUG( x ) cerr << __FILE__ << \":\" << __LINE__ << \": \" << #x << \" = \" << ( x ) << endl\n\nconst int dir[][2] = {\n\t1, 0,\n\t0, 1,\n\t-1, 0,\n\t0, -1\n};\n\nvoid dfs( VS &board, set<char> &chars, int &count, int y, int x )\n{\n\tif ( !( 0 <= y && y < board.size() && 0 <= x && x < board[0].size() ) )\n\t{\n\t\treturn;\n\t}\n\n\tif ( board[y][x] == '#' )\n\t{\n\t\treturn;\n\t}\n\n\tif ( board[y][x] != '.' )\n\t{\n\t\tchars.insert( board[y][x] );\n\t\treturn;\n\t}\n\n\tboard[y][x] = '#';\n\tcount++;\n\n\tREP( d, 0, 4 )\n\t{\n\t\tdfs( board, chars, count, y + dir[d][0], x + dir[d][1] );\n\t}\n\n\treturn;\n}\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\twhile ( true )\n\t{\n\t\tint w, h;\n\t\tcin >> w >> h;\n\n\t\tif ( !( w | h ) )\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tVS board( h );\n\n\t\tEACH( line, board )\n\t\t{\n\t\t\tcin >> line;\n\t\t}\n\n\t\tmap<char,int> res;\n\n\t\tREP( i, 0, h )\n\t\t{\n\t\t\tREP( j, 0, w )\n\t\t\t{\n\t\t\t\tset<char> chars;\n\t\t\t\tint count = 0;\n\n\t\t\t\tdfs( board, chars, count, i, j );\n\n\t\t\t\tif ( chars.size() == 1 )\n\t\t\t\t{\n\t\t\t\t\tres[ *chars.begin() ] += count;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << res['B'] << ' ' << res['W'] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nconst int INF=5;\nint state[50][50];\nchar fld[50][51];\nint h,w;\nconst int dx[]={0,-1,0,1};\nconst int dy[]={-1,0,1,0};\nvoid dfs(int y,int x,int clr){\n    if(y<0||y>=h||x<0||x>=w)return;\n    if(state[y][x]==INF)return;\n    if(fld[y][x]!='.')return;\n    if(state[y][x]==clr)return;\n    if(-state[y][x]==clr)state[y][x]=INF;\n    else state[y][x]=clr;\n    for(int i=0;i<4;i++)dfs(y+dy[i],x+dx[i],clr);\n}\nvoid debug(){\n    puts(\"---debug---\");\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++)printf(\"%2d \",state[i][j]);\n        puts(\"\");\n    }\n}\nint main(){\n    while(scanf(\"%d%d\",&w,&h),w||h){\n        for(int i=0;i<h;i++)scanf(\"%s\",fld[i]);\n        fill_n(*state,50*50,0);\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                if(fld[i][j]=='.')continue;\n                int clr=(fld[i][j]=='B'?1:-1);\n                for(int k=0;k<4;k++)dfs(i+dy[k],j+dx[k],clr);\n            }\n        }\n        //debug();\n        int B=0,W=0;\n        for(int i=0;i<h;i++){\n            B+=count(state[i],state[i]+w,1);\n            W+=count(state[i],state[i]+w,-1);\n        }\n        printf(\"%d %d\\n\",B,W);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <cstdio>\n\nusing namespace std;\n\n/*\nBB\nWW\nG\n*/\n\nchar map[52][52];\nbool flag[52][52];\nint xv[]={0,1,0,-1};\nint yv[]={1,0,-1,0};\nint Bf,Wf,cnt;\n\n\nvoid dfs(int X,int Y){\n\tflag[X][Y]=1;\n\tcnt++;\n\t\n\tfor(int i=0;i<4;i++){\n\t\tif(map[X+xv[i]][Y+yv[i]]=='B')Bf=1;\n\t\telse if(map[X+xv[i]][Y+yv[i]]=='W')Wf=1;\n\t\telse if(map[X+xv[i]][Y+yv[i]]=='.'&&flag[X+xv[i]][Y+yv[i]]==0){\n\t\t\tdfs(X+xv[i],Y+yv[i]);\n\t\t}\n\t}\n\t\n}\n\nint main(){\n\tint W,H;\n\twhile(cin>>W>>H,W){\n\t\t\n\t\tint BB=0,WW=0;\n\t\tfor(int i=0;i<=W+1;i++)map[i][0]=map[i][H+1]='#';\n\t\tfor(int i=0;i<=H+1;i++)map[0][i]=map[W+1][i]='#';\n\t\tfor(int i=1;i<=H;i++){\n\t\t\tfor(int j=1;j<=W;j++){\n\t\t\t\tcin>>map[j][i];\n\t\t\t}\n\t\t}\n\t\tmemset(flag,0,sizeof(flag));\n\t\t\n\t\tfor(int i=1;i<=H;i++){\n\t\t\tfor(int j=1;j<=W;j++){\n\t\t\t\tif(!flag[j][i]&&map[j][i]=='.'){\n\t\t\t\t\tBf=Wf=cnt=0;\n\t\t\t\t\tdfs(j,i);\n\t\t\t\t\tif(Bf&&!Wf)BB+=cnt;\n\t\t\t\t\tif(!Bf&&Wf)WW+=cnt;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<BB<<\" \"<<WW<<endl;\n\t}\n\t\n\t\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define repp(i, l, r) for(int i = (l); i < (r); i++)\n#define per(i, n) for(int i = ((n)-1); i >= 0; i--)\n#define perr(i, l, r) for(int i = ((r)-1); i >= (l); i--)\n#define all(x) (x).begin(),(x).end()\n#define MOD 1000000007\n#define IINF 1000000000\n#define LINF 1000000000000000000\n#define SP <<\" \"<<\n#define CYES cout<<\"Yes\"<<endl\n#define CNO cout<<\"No\"<<endl\n#define CFS cin.tie(0);ios::sync_with_stdio(false)\n\ntypedef long long LL;\ntypedef long double LD;\n\nint main(){\n  while(1){\n    int h,w;\n    cin >> w >> h;\n    if(h==0) return 0;\n    vector<string> f(h);\n    vector<vector<int>> c(h,vector<int>(w,0));\n    rep(i,h){\n      cin >> f[i];\n    }\n    int v[5]={0,1,0,-1,0};\n    queue<pair<int,int>> q;\n    rep(i,h){\n      rep(j,w){\n        if(f[i][j]=='B'){\n          q.push({i,j});\n        }\n      }\n    }\n    while(!q.empty()){\n      auto now=q.front();\n      q.pop();\n      rep(i,4){\n        int nx = now.second+v[i];\n        int ny = now.first+v[i+1];\n        if(0<=nx&&nx<w&&0<=ny&&ny<h){\n          if(f[ny][nx]=='.'&&((c[ny][nx]&1)==0)){\n            c[ny][nx]++;\n            q.push({ny,nx});\n          }\n        }\n      }\n    }\n    rep(i,h){\n      rep(j,w){\n        if(f[i][j]=='W'){\n          q.push({i,j});\n        }\n      }\n    }\n    while(!q.empty()){\n      auto now=q.front();\n      q.pop();\n      rep(i,4){\n        int nx = now.second+v[i];\n        int ny = now.first+v[i+1];\n        if(0<=nx&&nx<w&&0<=ny&&ny<h){\n          if(f[ny][nx]=='.'&&((c[ny][nx]&2)==0)){\n            c[ny][nx]+=2;\n            q.push({ny,nx});\n          }\n        }\n      }\n    }\n    int b=0,ww=0;\n    rep(i,h){\n      rep(j,w){\n        if(c[i][j]==1) b++;\n        else if(c[i][j]==2) ww++;\n      }\n    }\n    cout << b SP ww << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<ctime>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y-1);(X) >=0;--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nint used[60][60],dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\npii dfs(vector<string> &mp,int y,int x){\n  if(mp[y][x]=='#')\n    return pii(0,0);\n  if(mp[y][x]=='B')\n    return pii(0,2);\n  if(mp[y][x]=='W')\n    return pii(0,1);\n  if(used[y][x])\n    return pii(0,0);\n  used[y][x]=1;\n  pii re=pii(1,0),tmp;\n  rep(i,4){\n    tmp=dfs(mp,y+dy[i],x+dx[i]);\n    re.X+=tmp.X;\n    re.Y|=tmp.Y;\n  }\n  return re;\n}\n\nint main(){\n  clock_t St,Et;\n  St=clock();\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n  int i,j,k;\n  while(1){\n    int w,h;\n    cin>>w>>h;\n    if(w==0)break;\n    vector<string> mp(h+2,string(w+2,'#'));\n    rep(i,h){\n      cin>>mp[i+1];\n      mp[i+1]=\"#\"+mp[i+1]+\"#\";\n    }\n    //   rep(i,h+2)cout<<mp[i]<<endl;\n    fill(used[0],used[0]+60*60,0);\n    int rew=0,reb=0;\n    for(int i=1;i<=h;i++)\n      for(int j=1;j<=w;j++)\n\tif(!used[i][j]&&mp[i][j]=='.'){\n\t  pii tmp=dfs(mp,i,j);\n\t  if(tmp.Y==1){\n\t    rew+=tmp.X;\n\t  }else if(tmp.Y==2){\n\t    reb+=tmp.X;\n\t  }\n\t}\n    //   rep(i,h+2){rep(j,2+w)cout<<used[i][j];cout<<endl;}\n    cout<<reb<<\" \"<<rew<<endl;\n  }\n  double hoge=2;\n  while((clock()-St)/CLOCKS_PER_SEC<5.0){\n    hoge*=1.0001;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nchar a[51][51];\nint w,h,bcount,wcount;\n\nvoid white(int i,int j){\n\tif(a[i-1][j] == 'B' && i-1 >= 0){\n\t\ta[i][j] = 'n';\n\t\treturn;\n\t}\n\telse if(a[i+1][j] == 'B' && i+1 < h){\n\t\ta[i][j] = 'n';\n\t\treturn;\n\t}\n\telse if(a[i][j-1] == 'B' && j-1 >= 0){\n\t\ta[i][j] = 'n';\n\t\treturn;\n\t}\n\telse if(a[i][j+1] == 'B' && j+1 < w){\n\t\ta[i][j] = 'n';\n\t\treturn;\n\t}\n\tif(a[i-1][j] == '.' && i-1 >= 0){\n\t\ta[i-1][j] = 'w';\n\t\twhite(i-1,j);\n\t}\n\tif(a[i+1][j] == '.' && i+1 < h){\n\t\ta[i+1][j] = 'w';\n\t\twhite(i+1,j);\n\t}\n\tif(a[i][j-1] == '.' && j-1 >= 0){\n\t\ta[i][j-1] = 'w';\n\t\twhite(i,j-1);\n\t}\n\tif(a[i][j+1] == '.' && j+1 < w){\n\t\ta[i][j+1] = 'w';\n\t\twhite(i,j+1);\n\t}\n}\n\nvoid black(int i,int j){\n\tif(a[i-1][j] == 'W' && i-1 >= 0){\n\t\ta[i][j] = 'n';\n\t\treturn;\n\t}\n\telse if(a[i+1][j] == 'W' && i+1 < h){\n\t\ta[i][j] = 'n';\n\t\treturn;\n\t}\n\telse if(a[i][j-1] == 'W' && j-1 >= 0){\n\t\ta[i][j] = 'n';\n\t\treturn;\n\t}\n\telse if(a[i][j+1] == 'W' && j+1 < w){\n\t\ta[i][j] = 'n';\n\t\treturn;\n\t}\n\tif(a[i-1][j] == '.' && i-1 >= 0){\n\t\ta[i-1][j] = 'b';\n\t\tblack(i-1,j);\n\t}\n\tif(a[i+1][j] == '.' && i+1 < h){\n\t\ta[i+1][j] = 'b';\n\t\tblack(i+1,j);\n\t}\n\tif(a[i][j-1] == '.' && j-1 >= 0){\n\t\ta[i][j-1] = 'b';\n\t\tblack(i,j-1);\n\t}\n\tif(a[i][j+1] == '.' && j+1 < w){\n\t\ta[i][j+1] = 'b';\n\t\tblack(i,j+1);\n\t}\n}\n\nvoid none(int i,int j){\n\tif(a[i-1][j] == 'w' && i-1 >= 0){\n\t\ta[i-1][j] = 'n';\n\t\tnone(i-1,j);\n\t}\n\tif(a[i+1][j] == 'w' && i+1 < h){\n\t\ta[i+1][j] = 'n';\n\t\tnone(i+1,j);\n\t}\n\tif(a[i][j-1] == 'w' && j-1 >= 0){\n\t\ta[i][j-1] = 'n';\n\t\tnone(i,j-1);\n\t}\n\tif(a[i][j+1] == 'w' && j+1 < w){\n\t\ta[i][j+1] = 'n';\n\t\tnone(i,j+1);\n\t}\n\tif(a[i-1][j] == 'b' && i-1 >= 0){\n\t\ta[i-1][j] = 'n';\n\t\tnone(i-1,j);\n\t}\n\tif(a[i+1][j] == 'b' && i+1 < h){\n\t\ta[i+1][j] = 'n';\n\t\tnone(i+1,j);\n\t}\n\tif(a[i][j-1] == 'b' && j-1 >= 0){\n\t\ta[i][j-1] = 'n';\n\t\tnone(i,j-1);\n\t}\n\tif(a[i][j+1] == 'b' && j+1 < w){\n\t\ta[i][j+1] = 'n';\n\t\tnone(i,j+1);\n\t}\n}\n\n\nvoid check(){\n\tfor(int i = 0;i < h;i++){\n\t\tfor(int j = 0;j < w;j++){\n\t\t\tif(a[i][j] == 'W'){\n\t\t\t\tif(a[i-1][j] == '.' && i-1 >= 0){\n\t\t\t\t\ta[i-1][j] = 'w';\n\t\t\t\t\twhite(i-1,j);\n\t\t\t\t}\n\t\t\t\tif(a[i+1][j] == '.' && i+1 < h){\n\t\t\t\t\ta[i+1][j] = 'w';\n\t\t\t\t\twhite(i+1,j);\n\t\t\t\t}\n\t\t\t\tif(a[i][j-1] == '.' && j-1 >= 0){\n\t\t\t\t\ta[i][j-1] = 'w';\n\t\t\t\t\twhite(i,j-1);\n\t\t\t\t}\n\t\t\t\tif(a[i][j+1] == '.' && j+1 < w){\n\t\t\t\t\ta[i][j+1] = 'w';\n\t\t\t\t\twhite(i,j+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(a[i][j] == 'B'){\n\t\t\t\tif(a[i-1][j] == '.' && i-1 >= 0){\n\t\t\t\t\ta[i-1][j] = 'b';\n\t\t\t\t\tblack(i-1,j);\n\t\t\t\t}\n\t\t\t\tif(a[i+1][j] == '.' && i+1 < h){\n\t\t\t\t\ta[i+1][j] = 'b';\n\t\t\t\t\tblack(i+1,j);\n\t\t\t\t}\n\t\t\t\tif(a[i][j-1] == '.' && j-1 >= 0){\n\t\t\t\t\ta[i][j-1] = 'b';\n\t\t\t\t\tblack(i,j-1);\n\t\t\t\t}\n\t\t\t\tif(a[i][j+1] == '.' && j+1 < w){\n\t\t\t\t\ta[i][j+1] = 'b';\n\t\t\t\t\tblack(i,j+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0;i < h;i++){\n\t\tfor(int j = 0;j < w;j++){\n\t\t\tif(a[i][j] == 'n'){\n\t\t\t\tnone(i,j);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(1){\n\t\tcin >> h >> w;\n\t\tif(h == 0)break;\n\t\tbcount = wcount = 0;\n\t\tfor(int i = 0;i < h;i++){\n\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\tcin >> a[i][j];\n\t\t\t}\n\t\t}\n\tcheck();\n\n\tfor(int i = 0;i < h;i++){\n\t\tfor(int j = 0;j < w;j++){\n\t\t\tif(a[i][j] == 'w')wcount++;\n\t\t\tif(a[i][j] == 'b')bcount++;\n\t\t\t//cout << a[i][j];\n\t\t}\n\t//\tcout << endl;\n\t}\n\tcout << bcount << \" \" << wcount <<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <string>\nusing namespace std;\n\nvoid search_dfs(char map[3][50][50], int xpos, int ypos, int w, int h, int color){\n\n\tif( xpos < 0 || xpos >= w ) return;\n\tif( ypos < 0 || ypos >= h ) return;\n\tif( color == 0 && map[color][xpos][ypos] == 'W' ) return;\n\tif( color == 1 && map[color][xpos][ypos] == 'B' ) return;\n\tif( map[color][xpos][ypos] == '#' ) return;\n\tmap[color][xpos][ypos] = '#';\n\tsearch_dfs( map, xpos + 1, ypos, w, h, color);\n\tsearch_dfs( map, xpos - 1, ypos, w, h, color);\n\tsearch_dfs( map, xpos, ypos - 1, w, h, color);\n\tsearch_dfs( map, xpos, ypos + 1, w, h, color);\n\n}\n\n\nint main(void){\n\t//FILE* fp_in = freopen(\"data.txt\", \"r\", stdin);\n\n\twhile(1){\n\t\tint w, h;\n\n\t\tcin >> w >> h;\n\n\t\tif( w == 0 && h == 0 )\n\t\t\tbreak;\n\n\t\tchar map[4][50][50];\n\n\t\tfor(int i = 0; i < h; i++) {\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\tmap[0][j][i] = s[j];\n\t\t\t\tmap[1][j][i] = s[j];\n\t\t\t\tmap[2][j][i] = s[j];\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < h; i++) {\n\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\tif( map[2][j][i] == 'B' )\n\t\t\t\t\tsearch_dfs(map, j,i,w,h,0);\n\t\t\t\tif( map[2][j][i] == 'W' )\n\t\t\t\t\tsearch_dfs(map, j,i,w,h,1);\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < h; i++) {\n\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\tmap[3][j][i] = ' ';\n\t\t\t\tif( map[0][j][i] == '#' && map[1][j][i] == '.' ) {\n\t\t\t\t\tmap[3][j][i] = 'B';\n\t\t\t\t} else if( map[1][j][i] == '#' && map[0][j][i] == '.' ) {\n\t\t\t\t\tmap[3][j][i] = 'W';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans[] = {0,0};\n\n\t\tfor(int i = 0; i < h; i++) {\n\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\tif( map[3][j][i] == 'B' ) ans[0] ++;\n\t\t\t\tif( map[3][j][i] == 'W' ) ans[1] ++;\n\t\t\t}\n\t\t}\n\n\t\tcout << ans[0] << \" \" << ans[1] << endl;\n\t}\n\n\t//while(1){}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing std::cin;\nusing std::cout;\nusing std::endl;\nusing std::vector;\nusing std::queue;\n\nint main(void) {\n\tint w,h;\n\tcin >> w >> h;\n\n\tchar c;\n\twhile ( w != 0 || h != 0 ) {\n\t\tvector< vector<int> > area(h+2, vector<int>(w+2));\n\t\tqueue<int> checkx,checky;\n\t\t\n\t\tfor (int i = 0; i < h+2; i++) {\n\t\t\tfor (int j = 0; j < w+2; j++) {\n\t\t\t\tif (i==0||i==h+1||j==0||j==w+1) {\n\t\t\t\t\tarea[i][j] = -1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcin >> c;\n\t\t\t\t\tif ( c == 'W' ) {\n\t\t\t\t\t\tarea[i][j] = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse if ( c == 'B' ) {\n\t\t\t\t\t\tarea[i][j] = 2;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tarea[i][j] = 0;\n\t\t\t\t\t\tchecky.push(i);\n\t\t\t\t\t\tcheckx.push(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint count_b = 0;\n\t\tint count_w = 0;\n\t\tint count = 0;\n\t\tint mode = 0;\n\t\tint xn,yn;\n\t\tqueue<int> sx,sy;\n\t\twhile (!checkx.empty()) {\n\t\t\txn = checkx.front();\n\t\t\tyn = checky.front();\n\t\t\tcheckx.pop();\n\t\t\tchecky.pop();\n\t\t\tcount = 0;\n\t\t\tmode = 0;\n\t\t\tif (area[yn][xn] == 0) {\n\t\t\t\tcount++;\n\t\t\t\tsx.push(xn);\n\t\t\t\tsy.push(yn);\n\t\t\t\twhile (!sx.empty()) {\n\t\t\t\t\txn = sx.front();\n\t\t\t\t\tyn = sy.front();\n\t\t\t\t\tarea[yn][xn] = -1;\n\t\t\t\t\tsx.pop();\n\t\t\t\t\tsy.pop();\n\t\t\t\t\tif (area[yn+1][xn] == 0) {\n\t\t\t\t\t\tsx.push(xn);\n\t\t\t\t\t\tsy.push(yn+1);\n\t\t\t\t\t\tarea[yn+1][xn] = -1;\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t\tif (area[yn-1][xn] == 0) {\n\t\t\t\t\t\tsx.push(xn);\n\t\t\t\t\t\tsy.push(yn-1);\n\t\t\t\t\t\tarea[yn-1][xn] = -1;\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t\tif (area[yn][xn+1] == 0) {\n\t\t\t\t\t\tsx.push(xn+1);\n\t\t\t\t\t\tsy.push(yn);\n\t\t\t\t\t\tarea[yn][xn+1] = -1;\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t\tif (area[yn][xn-1] == 0) {\n\t\t\t\t\t\tsx.push(xn-1);\n\t\t\t\t\t\tsy.push(yn);\n\t\t\t\t\t\tarea[yn][xn-1] = -1;\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t\tif (area[yn+1][xn] > 0) {\n\t\t\t\t\t\tif (mode == 0) {\n\t\t\t\t\t\t\tmode = area[yn+1][xn];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (mode != area[yn+1][xn]) {\n\t\t\t\t\t\t\tmode = -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (area[yn-1][xn] > 0) {\n\t\t\t\t\t\tif (mode == 0) {\n\t\t\t\t\t\t\tmode = area[yn-1][xn];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (mode != area[yn-1][xn]) {\n\t\t\t\t\t\t\tmode = -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (area[yn][xn+1] > 0) {\n\t\t\t\t\t\tif (mode == 0) {\n\t\t\t\t\t\t\tmode = area[yn][xn+1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (mode != area[yn][xn+1]) {\n\t\t\t\t\t\t\tmode = -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (area[yn][xn-1] > 0) {\n\t\t\t\t\t\tif (mode == 0) {\n\t\t\t\t\t\t\tmode = area[yn][xn-1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (mode != area[yn][xn-1]) {\n\t\t\t\t\t\t\tmode = -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (mode > 0) {\n\t\t\t\t\tif (mode == 1) {\n\t\t\t\t\t\tcount_w += count;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tcount_b += count;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << count_b << \" \" << count_w << endl;\n\n\t\tcin >> w >> h;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define RREP(i,n) for(ll i=n-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<n;++i)\n#define RFOR(i,m,n) for(ll i=n-1;i>=m;--i)\n#define ALL(v) (v).begin(),(v).end()\n#define PB(a) push_back(a)\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define DUMP(v) REP(aa, (v).size()) { cout << v[a]; if (a != v.size() - 1)cout << \" \"; else cout << endl; }\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconst int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconst int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nll max(ll a, int b) { return max(a, ll(b)); }\nll max(int a, ll b) { return max(ll(a), b); }\nll min(ll a, int b) { return min(a, ll(b)); }\nll min(int a, ll b) { return min(ll(a), b); }\n///(?????????`)(?????????`)(?????????`)(?????????`)(?????????`)(?????????`)///\nvoid bfs(vector<string> &v, vector<vector<pii>> &b, int x, int y) {\n\n}\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile (1) {\n\t\tint w, h;\n\t\tcin >> w >> h;\n\t\tif (!w)break;\n\t\tvector<string> v(h);\n\t\tREP(i, h)cin >> v[i];\n\t\tvector<vector<pii>> b(h, vector<pii>(w, pii(0, 0)));\n\t\tREP(i, h) {\n\t\t\tREP(j, w) {\n\t\t\t\tif (v[i][j] == 'W') {\n\t\t\t\t\tqueue<pii> q;\n\t\t\t\t\tq.push(make_pair(i, j));\n\t\t\t\t\twhile (!q.empty()) {\n\t\t\t\t\t\tpii p = q.front(); q.pop();\n\t\t\t\t\t\tint s = p.first, t = p.second;\n\t\t\t\t\t\tREP(k, 4) {\n\t\t\t\t\t\t\tint ni = s + dy[2 * k];\n\t\t\t\t\t\t\tint nj = t + dx[2 * k];\n\t\t\t\t\t\t\tif (ni >= 0 && nj >= 0 && ni < h&&nj < w&&b[ni][nj].first == 0 && v[ni][nj] == '.') {\n\t\t\t\t\t\t\t\tq.push(make_pair(ni, nj));\n\t\t\t\t\t\t\t\tb[ni][nj].first = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (v[i][j] == 'B') {\n\t\t\t\t\tqueue<pii> q;\n\t\t\t\t\tq.push(make_pair(i, j));\n\t\t\t\t\twhile (!q.empty()) {\n\t\t\t\t\t\tpii p = q.front(); q.pop();\n\t\t\t\t\t\tint s = p.first, t = p.second;\n\t\t\t\t\t\tREP(k, 4) {\n\t\t\t\t\t\t\tint ni = s + dy[2 * k];\n\t\t\t\t\t\t\tint nj = t + dx[2 * k];\n\t\t\t\t\t\t\tif (ni>=0&& nj >= 0 && ni < h&&nj < w&&b[ni][nj].second == 0 && v[ni][nj] == '.') {\n\t\t\t\t\t\t\t\tq.push(make_pair(ni, nj));\n\t\t\t\t\t\t\t\tb[ni][nj].second = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint cntb = 0, cntw = 0;\n\t\tREP(i, h) {\n\t\t\tREP(j, w) {\n\t\t\t\tif (v[i][j] == '.') {\n\t\t\t\t\tif (b[i][j] == make_pair(0, 1))cntb++;\n\t\t\t\t\telse if (b[i][j] == make_pair(1, 0))cntw++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << cntb << \" \" << cntw << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <limits.h>\n#include <math.h>\n#include <set>\n#include <stack>\n#include <stdlib.h>\n#include <string>\n#include <vector>\n\n#define el endl\n#define fd fixed\n#define INF INT_MAX/2-1\n#define pb push_back\n\nusing namespace std;\n\nchar map[50][50];\nbool memoB[50][50];\nbool memoW[50][50];\n\nvoid search(int x, int y, int w, int h, char color) {\n  if (color == 'B') {\n    memoB[x][y] = true;\n  } else {\n    memoW[x][y] = true;\n  }\n  if (x > 0 && map[x-1][y] == '.') {\n    if ((color == 'B' && !memoB[x-1][y]) || (color == 'W' && !memoW[x-1][y])) {\n      search(x-1, y, w, h, color);\n    }\n  }\n  if (y > 0 && map[x][y-1] == '.') {\n    if ((color == 'B' && !memoB[x][y-1]) || (color == 'W' && !memoW[x][y-1])) {\n      search(x, y-1, w, h, color);\n    }\n  }\n  if (x < w-1 && map[x+1][y] == '.') {\n    if ((color == 'B' && !memoB[x+1][y]) || (color == 'W' && !memoW[x+1][y])) {\n      search(x+1, y, w, h, color);\n    }\n  }\n  if (y < h-1 && map[x][y+1] == '.') {\n    if ((color == 'B' && !memoB[x][y+1]) || (color == 'W' && !memoW[x][y+1])) {\n      search(x, y+1, w, h, color);\n    }\n  }\n}\n\nint main() {\n  int w, h, cntB, cntW, resB, resW;\n  char tmp;\n  while (cin >> w >> h, w | h) {\n    cntB = cntW = 0;\n    for (int i = 0; i < w; i++) {\n      for (int j = 0; j < h; j++) {\n        cin >> tmp;\n        map[i][j] = tmp;\n        if (tmp == '.') memoB[i][j] = false; memoW[i][j] = false;\n        if (tmp == 'B') memoB[i][j] = true, memoW[i][j] = false, cntB++;\n        if (tmp == 'W') memoB[i][j] = false, memoW[i][j] = true, cntW++;\n      }\n    }\n    for (int i = 0; i < w; i++) {\n      for (int j = 0; j < h; j++) {\n        if (map[i][j] == 'B') search(i, j, w, h, 'B');\n        if (map[i][j] == 'W') search(i, j, w, h, 'W');\n      }\n    }\n    resB = 0;\n    resW = 0;\n    for (int i = 0; i < w; i++) {\n      for (int j = 0; j < h; j++) {\n        if (memoB[i][j] && !memoW[i][j]) resB++;\n        if (!memoB[i][j] && memoW[i][j]) resW++;\n      }\n    }\n    cout << resB-cntB << \" \" << resW-cntW << el;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <utility>\n#include <ctime>\n#define INF 999999999\n#define mod 1000000007\n\n#define rep(i,n) for(int i=0;i<int(n);i++)\n#define rrep(i,n) for(int i=(n);i>=0;i--)\n#define REP(i,a,b) for(int i=(a);i<int(b);i++)\n#define all(x) (x).begin(),x.end()\n#define pb push_back\n#define MOD(x) (x%(mod))\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\n\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nbool debug=false;\n/*---------------------------------------------------*/\n\nchar d[55][55];\nint black,white;\nint w,h;\n\nvoid init(){\n  rep(i,55){\n    rep(j,55){\n      d[i][j]='.';\n    }\n  }\n  black=white=0;\n}\n\nvoid bfs(int sy,int sx){\n  d[sy][sx]='#';\n  if(debug)cout<<\"start\"<<endl;\n  if(debug)rep(i,h){rep(j,w)cout<<d[i][j]<<\" \";cout<<endl;}\n  int cnt=1;\n  bool bb=false,ww=false;\n  queue<int>q;\n  q.push(sx);q.push(sy);\n  while(!q.empty()){\n    int x,y;\n    x=q.front();q.pop();\n    y=q.front();q.pop();\n    rep(i,4){\n      if(0<=x+dx[i]&&x+dx[i]<w&&0<=y+dy[i]&&y+dy[i]<h&&d[y+dy[i]][x+dx[i]]!='#'){\n\tif(d[y+dy[i]][x+dx[i]]=='W'){\n\t  ww=true;\n\t}else if(d[y+dy[i]][x+dx[i]]=='B'){\n\t  bb=true;\n\t}else{\n\t  cnt++;\n\t  q.push(x+dx[i]);q.push(y+dy[i]);\n\t  d[y+dy[i]][x+dx[i]]='#';\n\t}\n      }\n    }\n  }\n  if(!bb&&ww)white+=cnt;\n  else if(bb&&!ww)black+=cnt;\n}\n\nint main(){\n  while(cin>>w>>h){\n    if(w==0&&h==0)break;\n    init();\n    rep(i,h)rep(j,w)cin>>d[i][j];\n    rep(i,h)rep(j,w)if(d[i][j]=='.')bfs(i,j);\n    cout<<black<<\" \"<<white<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint borw, counter;\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {1, 0, -1, 0};\n\nvoid dfs(vector<vector<int> >& canGo, int i, int j){\n  canGo[i][j] = 3;\n  counter++;\n\n  for(int k = 0; k < 4; k++){\n    if(canGo[i + dx[k]][j + dy[k]] == 0) dfs(canGo, i + dx[k], j + dy[k]);\n    if(canGo[i + dx[k]][j + dy[k]] == 1){\n      if(borw == 0 || borw == 1)  borw = 1;\n      else borw = 3;\n    }\n\n    if(canGo[i + dx[k]][j + dy[k]] == 2){\n      if(borw == 0 || borw == 2)  borw = 2;\n      else borw = 3;\n    }\n  }\n}\n\n\nint main(void)\n{\n  int w, h;\n  while(1){\n    cin >> w >> h; if(w == 0 && h == 0) break;\n\n    int B = 0, W = 0;\n    vector<vector<int> > canGo(h + 2, vector<int>(w + 2, 3));\n\n    for(int i = 1; i <= h; i++){\n      for(int j = 1; j <= w; j++){\n\tchar input; cin >> input;\n\tif(input == '.') canGo[i][j] = 0;\n\tif(input == 'B') canGo[i][j] = 1;\n\tif(input == 'W') canGo[i][j] = 2;\n      }\n    }\n   \n    for(int i = 1; i <= h; i++){\n      for(int j = 1; j <= w; j++){\n\tborw = 0;\n\tcounter = 0;\n       if(canGo[i][j] == 0){\n\t  dfs(canGo, i, j);\n\t  if(borw == 1) B += counter;\n\t  if(borw == 2) W += counter;\n        }\n      }\n    }\n\n    cout << B << \" \" << W << endl;\n\n  }\n  return 0;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nint W, H; vector<string> M;\n\nconst vector<int> dx = { 0, 1, 0, -1 };\nconst vector<int> dy = { -1, 0, 1, 0 };\n\nint rec(int x, int y, vector<vector<bool> > ok)\n{\n\tif (M[y][x] == 'W')\n\t{\n\t\treturn 2;\n\t}\n\n\tif (M[y][x] == 'B')\n\t{\n\t\treturn 1;\n\t}\n\n\tint ret = 3;\n\n\tfor (int dir = 0; dir < 4; dir++)\n\t{\n\t\tint tx = x + dx[dir];\n\t\tint ty = y + dy[dir];\n\n\t\tif (0 <= tx && tx < W && 0 <= ty && ty < H && ok[ty][tx] == false)\n\t\t{\n\t\t\tvector<vector<bool> > ok2 = ok; ok2[ty][tx] = true;\n\n\t\t\tret = ret & rec(tx, ty, ok2);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint main()\n{\n\tint H, W;\n\n\twhile (true)\n\t{\n\t\tcin >> W >> H;\n\n\t\tif (W == 0 && H == 0) { break; }\n\n\t\tint b = 0, w = 0;\n\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tint c = rec(j, i, vector<vector<bool> >(H, vector<bool>(W, false)));\n\n\t\t\t\tb += c & 1;\n\t\t\t\tw += (c & 2) / 2;\n\t\t\t}\n\t\t}\n\n\t\tcout << b << ' ' << w << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\n//clear memory\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\nusing namespace std;\nint wlands[100][100];\nvoid wfill(int i,int j,int w,int h)\n{\n  if(0<=i && i<w && 0<= j && j<h && wlands[j][i] == '.'){\n    wlands[j][i]='W';\n    wfill(i-1,j,w,h);\n    wfill(i+1,j,w,h);\n    wfill(i,j-1,w,h);\n    wfill(i,j+1,w,h);\n  }\n}\nint blands[100][100];\nvoid bfill(int i,int j,int w,int h)\n{\n  if(0<=i && i<w && 0<= j && j<h && blands[j][i] == '.'){\n    blands[j][i]='B';\n    bfill(i-1,j,w,h);\n    bfill(i+1,j,w,h);\n    bfill(i,j-1,w,h);\n    bfill(i,j+1,w,h);\n  }\n}\nint main(void)\n{\n  for(;;){\n    string line;\n    int w,h,answer=0,white=0,black=0;\n    cin >> w >> h;\n    if(!w&&!h) return 0;\n    REP(j,h){\n      cin >> line;\n      REP(i,w){\n\twlands[j][i]=line[i];\n\tblands[j][i]=line[i];\n\tif(line[i] == 'W') white--;\n\tif(line[i] == 'B') black--;\n      }\n    }\n    REP(j,h){\n      REP(i,w){\n\tif(wlands[j][i]=='W'){\n\t  wfill(i-1,j,w,h);\n\t  wfill(i+1,j,w,h);\n\t  wfill(i,j-1,w,h);\n\t  wfill(i,j+1,w,h);\n\t}\n\tif(blands[j][i]=='B'){\n\t  bfill(i-1,j,w,h);\n\t  bfill(i+1,j,w,h);\n\t  bfill(i,j-1,w,h);\n\t  bfill(i,j+1,w,h);\n\t}\n      }\n    }\n    REP(j,h){\n      REP(i,w){\n\tif(wlands[j][i]=='W' && blands[j][i]!='B') white++;\n\tif(wlands[j][i]!='W' && blands[j][i]=='B') black++;\n      }\n    }\n    cout << black << ' ' << white << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\nconst double PI = acos(-1);\nconst double EPS = 1e-9;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\nvector<vector<int>>v_w, v_b;\nvector<string>field;\nint dx[] = { 1,0,-1,0 }, dy[] = { 0, 1, 0, -1 };\nbool within(int x, int y) {\n\treturn 0 <= x&&x < field.size() && 0 <= y&&y < field[0].size();\n}\nvoid color(int x, int y, char c, vector<vector<int>>&a) {\n\tif (a[x][y] != 0)return;\n\ta[x][y] = (c == 'W' ? 1 : -1);\n\trep(i, 0, 4) {\n\t\tint X = x + dx[i], Y = y + dy[i];\n\t\tif (within(X, Y) && field[X][Y] == '.')color(X, Y, c, a);\n\t}\n\n\n}\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint w, h;\n\twhile (cin >> w >> h, w&&h) {\n\t\tfield = vector<string>(h);\n\t\trep(i, 0, h)cin >> field[i];\n\t\tint cnt_w(0), cnt_b(0);\n\t\trep(i, 0, h)rep(j, 0, w) {\n\t\t\tif (field[i][j] == 'W')cnt_w++;\n\t\t\telse if (field[i][j] == 'B')cnt_b++;\n\n\t\t}\n\t\tv_w = v_b = vector<vector<int>>(h, vector<int>(w, 0));\n\t\tdump(cnt_w, cnt_b);\n\t\trep(i, 0, h)rep(j, 0, w) {\n\t\t\tif (field[i][j] == 'W') {\n\t\t\t\trep(k, 0, 4) {\n\t\t\t\t\tint a = i + dx[k], b = j + dy[k];\n\t\t\t\t\tif (within(a, b)&&field[a][b]=='.')color(a, b, 'W', v_w);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (field[i][j] == 'B') {\n\t\t\t\trep(k, 0, 4) {\n\t\t\t\t\tint a = i + dx[k], b = j + dy[k];\n\t\t\t\t\tif (within(a, b)&&field[a][b]=='.')color(a, b, 'B', v_b);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint result_w(0), result_b(0);\n\t\trep(i, 0, h)rep(j, 0, w) {\n\t\t\tif (v_w[i][j] == 1 && v_b[i][j] == -1)continue;\n\t\t\telse if (v_w[i][j] == 1)result_w++;\n\t\t\telse if (v_b[i][j] == -1)result_b++;\n\t\t}\n\t\tcout << result_b << \" \" << result_w << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <queue>\n\nusing namespace std;\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n\n#define all(v) v.begin(),v.end()\n#define INF 1<<30\n#define mp make_pair\n#define pb push_back\n\n#define fi first\n#define se second\n\n#define each(it,c) for(auto it=(c).begin();it!=(c).end();it++)\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\ntypedef vector<pair<int, int> > vp;\n\ntypedef long long ll;\n\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1}; \n\nint main(){\n  while(1){\n    int w,h;\n    int aa=0;\n    int bb=0;\n    string a[55];\n    string b[55];\n    cin >> w >> h;\n    if(w==0)break;\n    rep(i,h){\n      cin >> a[i];\n      b[i] = a[i];\n    }\n    bool f = true;\n    rep(y,h){\n      rep(x,w){\n        if(a[y][x]=='W'||a[y][x]=='B') f = false;\n      }\n    }\n    if(f){\n      cout << 0 << \" \" << 0 << endl;\n      continue;\n    }\n    rep(y,h){\n      rep(x,w){\n        if(a[y][x]=='W'){\n          \n          queue<pii> que;\n          que.push(mp(x,y));\n          \n          while(!que.empty()){\n            int yy = que.front().se;\n            int xx = que.front().fi;\n            a[yy][xx]='w';\n            que.pop();\n            rep(i,4){\n              if(yy+dy[i]>=0 &&\n                 xx+dx[i]>=0 &&\n                 yy+dy[i]<h &&\n                 xx+dx[i]<w &&\n                 \n                a[yy+dy[i]][xx+dx[i]]=='.'){\n                que.push(mp(xx+dx[i],yy+dy[i]));\n              }\n            }\n          }\n        }\n      }\n    }\n    rep(y,h){\n      rep(x,w){\n        if(a[y][x]=='.'){\n          bb++;\n        }\n      }\n    }\n    rep(y,h){\n      rep(x,w){\n        if(b[y][x]=='B'){\n          \n          queue<pii> que;\n          que.push(mp(x,y));\n          \n          while(!que.empty()){\n            int yy = que.front().se;\n            int xx = que.front().fi;\n            b[yy][xx]='b';\n            que.pop();\n            rep(i,4){\n              if(yy+dy[i]>=0 &&\n                 xx+dx[i]>=0 &&\n                 yy+dy[i]<h &&\n                 xx+dx[i]<w &&\n                 \n                b[yy+dy[i]][xx+dx[i]]=='.'){\n                que.push(mp(xx+dx[i],yy+dy[i]));\n              }\n            }\n          }\n        }\n      }\n    }\n    rep(y,h){\n      rep(x,w){\n        if(b[y][x]=='.'){\n          aa++;\n        }\n      }\n    }\n    cout<<bb << \" \"<<aa<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include <set>\n#include <cctype>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\nusing namespace std;\n#define INF 100000000\n#define MAXH 64\n#define MAXW 64\n\ntypedef long long ll;\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\nchar a[MAXH][MAXW];\nint w, h;\n\nint main(void) {\n    while (1) {\n        cin >> w >> h;\n        if (w == 0 && h == 0) break;\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                cin >> a[i][j];\n            }\n        }\n        int white = 0, black = 0;\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                if (a[i][j] != '.') continue;\n                bool used[MAXH][MAXW];\n                for (int k = 0; k < h; k++) {\n                    for (int l = 0; l < w; l++) {\n                        used[k][l] = false;\n                    }\n                }\n                queue<int> X, Y;\n                X.push(j); Y.push(i);\n                bool white_flag = false, black_flag = false;\n                while (!X.empty()) {\n                    int x = X.front(); X.pop();\n                    int y = Y.front(); Y.pop();\n                    used[y][x] = true;\n                    for (int k = 0; k < 4; k++) {\n                        int nx = x + dx[k];\n                        int ny = y + dy[k];\n                        if (0 <= nx && nx < w && 0 <= ny && ny < h) {\n                            if (a[ny][nx] == 'W') white_flag = true;\n                            else if (a[ny][nx] == 'B') black_flag = true;\n                            else if (!used[ny][nx]) {\n                                X.push(nx);\n                                Y.push(ny);\n                            }\n                        }\n                    }\n                }\n                if (white_flag && !black_flag) white++;\n                if (!white_flag && black_flag) black++;\n            }\n        }\n        cout << black << \" \" << white << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-11;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nvs a;\nint h,w;\nbool b1,b2;\n\nvoid dfs(int i,int j,int &t){\n\tt++;\n\ta[i][j]='#';\n\tfor(int k=0;k<4;k++){\n\t\tint x=i+dx[k],y=j+dy[k];\n\t\tif(x>=0&&x<h&&y>=0&&y<w){\n\t\t\tif(a[x][y]=='B') b1=1;\n\t\t\tif(a[x][y]=='W') b2=1;\n\t\t\tif(a[x][y]=='.') dfs(x,y,t);\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(1){\n\t\tcin>>w>>h;\n\t\tif(h==0) break;\n\t\ta=vs(h);\n\t\tfor(int i=0;i<h;i++) cin>>a[i];\n\t\tint x=0,y=0;\n\t\tfor(int i=0;i<h;i++) for(int j=0;j<w;j++) if(a[i][j]=='.'){\n\t\t\tb1=0,b2=0;\n\t\t\tint t=0;\n\t\t\tdfs(i,j,t);\n\t\t\tif(b1&&!b2) x+=t;\n\t\t\tif(!b1&&b2) y+=t;\n\t\t}\n\t\tcout<<x<<' '<<y<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nstruct data\n{\n\tint x;\n\tint y;\n};\nstruct mapData\n{\n\tint black = 0;\n\tint white = 0;\n};\nint main()\n{\n\tint w, h;\n\tint dx[4] = {1,0,-1,0};\n\tint dy[4] = {0,1,0,-1};\n\twhile (cin >> w >> h && w != 0 || h != 0)\n\t{\n\t\tchar map[50][50];\n\t\tfor (int i = 0; i < h; i++)\n\t\t{\n\t\t\tcin >> map[i];\n\t\t}\n\n\t\tmapData whiteBlack[50][50];\n\t\tfor (int i = 0; i < h; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t{\n\t\t\t\twhiteBlack[i][j].black = 0;\n\t\t\t\twhiteBlack[i][j].white = 0;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < h; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t{\n\t\t\t\tif (map[i][j] == '.')continue;\n\t\t\t\tint color = (map[i][j] == 'B' ? 1 : 2);\n\t\t\t\tqueue<data> q;\n\t\t\t\tdata first;\n\t\t\t\tfirst.x = j;\n\t\t\t\tfirst.y = i;\n\t\t\t\tq.push(first);\n\t\t\t\twhile (q.size() > 0)\n\t\t\t\t{\n\t\t\t\t\tdata d = q.front(); q.pop();\n\t\t\t\t\tif (map[d.y][d.x] == '.')\n\t\t\t\t\t{\n\t\t\t\t\t\tif (color == 1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\twhiteBlack[d.y][d.x].black = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\twhiteBlack[d.y][d.x].white = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (int k = 0; k < 4; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tint nx = dx[k] + d.x;\n\t\t\t\t\t\tint ny = dy[k] + d.y;\n\t\t\t\t\t\tif (nx >= w || ny >= h || nx < 0 || ny < 0)continue;\n\t\t\t\t\t\tif (map[ny][nx] == 'W' || map[ny][nx] == 'B')continue;\n\t\t\t\t\t\tif (color == 1 && whiteBlack[ny][nx].black == 1)continue;\n\t\t\t\t\t\tif (color == 2 && whiteBlack[ny][nx].white == 1)continue;\n\t\t\t\t\t\tdata add;\n\t\t\t\t\t\tadd.x = nx;\n\t\t\t\t\t\tadd.y = ny;\n\t\t\t\t\t\tq.push(add);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint white = 0;\n\t\tint black = 0;\n\t\tfor (int i = 0; i < h; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t{\n\t\t\t\tif (whiteBlack[i][j].black == 1 && whiteBlack[i][j].white == 0)\n\t\t\t\t{\n\t\t\t\t\tblack++;\n\t\t\t\t}\n\t\t\t\telse if (whiteBlack[i][j].white == 1 && whiteBlack[i][j].black == 0)\n\t\t\t\t{\n\t\t\t\t\twhite++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << black << \" \" << white << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef pair <int,int> pii;\n#define FST first\n#define SEC second\n\nint w,h;\nint dd[8]={0,1,0,-1,0};\n\nvoid bfs(char map[50][50]){\n  int bc=0,wc=0;\n  rep(i,h){\n    rep(j,w){\n      if(map[j][i]=='.'){\n\tqueue <pii> q;\n\tq.push(pii(j,i));\n\tint count=0;\n\tpii state=pii(0,0);\n\twhile(!q.empty()){\n\t  int cx=q.front().FST,cy=q.front().SEC;\n\t  q.pop();\n\t  if(map[cx][cy]=='.')\n\t    count++;\n\t  map[cx][cy]='#';\n\t  rep(r,4){\n\t    int nx=cx+dd[r],ny=cy+dd[r+1];\n\t    if(nx<0 || ny<0 || nx>=w || ny>=h || map[nx][ny]=='#')\n\t      continue;\n\t    if(map[nx][ny]=='B'){\n\t      state.FST=1;\n\t      continue;\n\t    }\n\t    if(map[nx][ny]=='W'){\n\t      state.SEC=1;\n\t      continue;\n\t    }\n\t    q.push(pii(nx,ny));\n\t  }\n\t}\n\tif(state==pii(1,0))\n\t  bc+=count;\n\tif(state==pii(0,1))\n\t  wc+=count;\n      } \n    }\n  }\n  printf(\"%d %d\\n\",bc,wc);\n}\n\nint main(){\n  for(;;){\n    cin >> w >> h;\n    if(!(w+h)) break;\n    char map[50][50];\n    rep(i,h){\n      rep(j,w){\n        cin >> map[j][i];\n      }\n    }\n    bfs(map);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n\n#define W_MAX 50\n#define H_MAX 50\n\n\nusing namespace std;\n\nint map[H_MAX][W_MAX];\nint zyo[H_MAX][W_MAX];\nint w,h;\nint flag;\n\nvoid solve(int H,int W){\n\tint dx[4]={-1,1,0, 0};\n\tint dy[4]={ 0,0,1,-1};\n\t/*cout<<H<<\",\"<<W<<\",\"<<map[H][W]<<\",\"<<zyo[H][W]<<\",\"<<flag<<endl;*/\n\tfor(int a=0;a<4;a++){\n\t\t\tif(H+dx[a]<0||H+dx[a]>=h) continue;\n\t\t\tif(W+dy[a]<0||W+dy[a]>=w) continue;\n\t\t\tif(zyo[H+dx[a]][W+dy[a]]==-1&&map[H+dx[a]][W+dy[a]]==0){\n\t\t\t\tzyo[H+dx[a]][W+dy[a]]=3;\n\t\t\t\tsolve(H+dx[a],W+dy[a]);\n\t\t\t}\n\t\t\telse if(map[H+dx[a]][W+dy[a]]==1){\n\t\t\t\tif(flag==-1) flag=1;\n\t\t\t\tif(flag==2) flag=0;\n\t\t\t}\n\t\t\telse if(map[H+dx[a]][W+dy[a]]==2){\n\t\t\t\tif(flag==-1) flag=2;\n\t\t\t\tif(flag==1) flag=0;\n\t\t}\n\t}\n\treturn;\n}\n\nint main(void){\n\n\tchar tmp;\n\tint bc,wc;\n\n\twhile(1){\n\t\t\tmemset(map,-1,sizeof(map));\n\t\t\tmemset(zyo,-1,sizeof(zyo));\n\t\t\tbc=0,wc=0;\n\n\t\t\tcin>>w>>h;\n\t\t\tif(w==0&&h==0) break;\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tcin>>tmp;\n\t\t\t\t\tswitch(tmp){\n\t\t\t\t\tcase '.':\n\t\t\t\t\t\tmap[i][j]=0;\n\t\t\t\t\t\tzyo[i][j]=-1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'B':\n\t\t\t\t\t\tmap[i][j]=1;\n\t\t\t\t\t\tzyo[i][j]=0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'W':\n\t\t\t\t\t\tmap[i][j]=2;\n\t\t\t\t\t\tzyo[i][j]=0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(zyo[i][j]==-1){\n\t\t\t\t\tzyo[i][j]=3;\n\t\t\t\t\tflag=-1;\n\t\t\t\t\tsolve(i,j);\n\t\t\t\t\tfor(int k=0;k<h;k++){\n\t\t\t\t\t\tfor(int l=0;l<w;l++){\n\t\t\t\t\t\t\tif(zyo[k][l]==3) zyo[k][l]=flag;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t//cout<<zyo[i][j];\n\t\t\t\tif(zyo[i][j]==1) bc++;\n\t\t\t\telse if(zyo[i][j]==2) wc++;\n\t\t\t}\n\t\t\t//cout<<endl;\n\t\t}\n\t\tcout<<bc<<\" \"<<wc<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define N 51\nusing namespace std;\nchar map[N][N],clr[N][N];\nint w,h;\nvoid renew(int x,int y){\n  int dx[4]={1,0,-1,0},dy[4]={0,1,0,-1},newx,newy;\n  for(int u=0;u<4;u++){\n    newx=x+dx[u],newy=y+dy[u];\n    if(newx>=0 && newx<w && newy>=0 && newy<h){\n         if(clr[newx][newy]=='.' && map[newx][newy]=='.') map[newx][newy]=map[x][y],renew(newx,newy);\n      else if(clr[newx][newy]=='.' && map[x][y]!=map[newx][newy])map[newx][newy]='F',renew(newx,newy);\n    }\n  }\n}\n\nint main(){\n  while(1){\n    int wcnt=0,bcnt=0;\n    cin>>w>>h;\n    if(w+h==0) break;\n    for(int i=0;i<w;i++)\n      for(int j=0;j<h;j++){\n\tcin>>map[i][j];\n\tclr[i][j]=map[i][j];\n      }\n    for(int i=0;i<w;i++)\n      for(int j=0;j<h;j++){\n\tif(clr[i][j]=='W') wcnt--;\n\tif(clr[i][j]=='B')bcnt--;\n\tif(clr[i][j]!='.') renew(i,j);\n      }\n   \n    for(int i=0;i<w;i++)\n      for(int j=0;j<h;j++){\n\tif(map[i][j]=='B')bcnt++;\n\telse if(map[i][j]=='W')wcnt++;\n      }\n    cout<<bcnt<<\" \"<<wcnt<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n \nusing namespace std;\n \nint w,h;\nchar g[50][51];\n \nint res(int y,int x){\n  if(y<0||h<=y||x<0||w<=x){\n    return 0;\n  }else if(g[y][x]=='.'){\n    g[y][x]='t';\n    int a=0;\n    for(int i=0;i<4;i++){\n      int d[]={0,1,0,-1,0};\n      a|=res(y+d[i],x+d[i+1]);\n    }\n    return a;\n  }else{\n    return g[y][x]=='B'|(g[y][x]=='W')<<1;\n  }\n}\n \nvoid ff(int y,int x,int v){\n  if(y<0||h<=y||x<0||w<=x){\n    return;\n  }else if(g[y][x]=='t'){\n    const char *w=\"nbwn\";\n    g[y][x]=w[v];\n    for(int i=0;i<4;i++){\n      int d[]={0,1,0,-1,0};\n      ff(y+d[i],x+d[i+1],v);\n    }\n  } \n}\n \nint main(){\n  while(cin>>w>>h,w|h){\n    fill(g[0],g[50],0);\n    for(int y=0;y<h;y++){\n      cin>>g[y];\n    }\n    for(int y=0;y<h;y++){\n      for(int x=0;x<w;x++){\n    ff(y,x,res(y,x));\n      }\n    }\n    cout<<count(g[0],g[50],'b')<<' '<<count(g[0],g[50],'w')<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <limits.h>\n#include <math.h>\n#include <set>\n#include <stack>\n#include <stdlib.h>\n#include <string>\n#include <vector>\n\n#define el endl\n#define fd fixed\n#define INF INT_MAX/2-1\n#define pb push_back\n\nusing namespace std;\n\nchar map[50][50];\nbool memoB[50][50];\nbool memoW[50][50];\n\nvoid search(int x, int y, int w, int h, char color) {\n  if (color == 'B') {\n    memoB[x][y] = true;\n  } else {\n    memoW[x][y] = true;\n  }\n  if (x > 0 && map[x-1][y] == '.') {\n    if ((color == 'B' && !memoB[x-1][y]) || (color == 'W' && !memoW[x-1][y])) {\n      search(x-1, y, w, h, color);\n    }\n  }\n  if (y > 0 && map[x][y-1] == '.') {\n    if ((color == 'B' && !memoB[x][y-1]) || (color == 'W' && !memoW[x][y-1])) {\n      search(x, y-1, w, h, color);\n    }\n  }\n  if (x < w-1 && map[x+1][y] == '.') {\n    if ((color == 'B' && !memoB[x+1][y]) || (color == 'W' && !memoW[x+1][y])) {\n      search(x+1, y, w, h, color);\n    }\n  }\n  if (y < h-1 && map[x][y+1] == '.') {\n    if ((color == 'B' && !memoB[x][y+1]) || (color == 'W' && !memoW[x][y+1])) {\n      search(x, y+1, w, h, color);\n    }\n  }\n}\n\nint main() {\n  int w, h, cntB, cntW, resB, resW;\n  char tmp;\n  while (cin >> w >> h, w | h) {\n    cntB = cntW = 0;\n    for (int i = 0; i < w; i++) {\n      for (int j = 0; j < h; j++) {\n        cin >> tmp;\n        map[i][j] = tmp;\n        if (tmp == '.') memoB[i][j] = memoW[i][j] = false;\n        if (tmp == 'B') memoB[i][j] = true, memoW[i][j] = false, cntB++;\n        if (tmp == 'W') memoB[i][j] = false, memoW[i][j] = true, cntW++;\n      }\n    }\n    for (int i = 0; i < w; i++) {\n      for (int j = 0; j < h; j++) {\n        if (map[i][j] != '.') search(i, j, w, h, map[i][j]);\n      }\n    }\n    resB = resW = 0;\n    for (int i = 0; i < w; i++) {\n      for (int j = 0; j < h; j++) {\n        if (memoB[i][j] && !memoW[i][j]) resB++;\n        if (!memoB[i][j] && memoW[i][j]) resW++;\n      }\n    }\n    cout << resB-cntB << \" \" << resW-cntW << el;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nenum{NONE,BLA,WHI};\n\nint kui[50][50]={};\nbool rin[50][50][WHI+1]={};\nint W,H;\nint dx[4]={1,-1,0,0};\nint dy[4]={0,0,1,-1};\nvoid clear(){\n     for(int i=0;i<50;i++){\n\t  for(int j=0;j<50;j++){\n\t       kui[i][j]=0;\n\t       rin[i][j][BLA]=false;rin[i][j][WHI]=false;\n\t  }\n     }\n}\nvoid rec(int x,int y,int color){\n     if(x>=W||x<0||y>=H||y<0) return;\n     if(kui[x][y]>0||rin[x][y][color])return;\n     rin[x][y][color]=true;\n     for(int i=0;i<4;i++){\n\t  rec(x+dx[i],y+dy[i],color);\n     }\n}\n\nint main(){\n     while(cin>>W>>H,W||H){\n\t  clear();\n\t  for(int i=0;i<H;i++){\n\t       for(int j=0;j<W;j++){\n\t\t    char t;\n\t\t    cin>>t;\n\t\t    switch(t){\n\t\t    case '.':\n\t\t\t break;\n\t\t    case 'B':\n\t\t\t kui[j][i]=BLA;\n\t\t\t break;\n\t\t    case 'W':\n\t\t\t kui[j][i]=WHI;\n\t\t\t break;\n\t\t    }\n\t       }\n\t  }\n\t  for(int i=0;i<W;i++){\n\t       for(int j=0;j<H;j++){\n\t\t    switch(kui[i][j]){\n\t\t    case BLA:\n\t\t\t for(int k=0;k<4;k++) rec(i+dx[k],j+dy[k],BLA);\n\t\t\t break;\n\t\t    case WHI:\n\t\t\t for(int k=0;k<4;k++) rec(i+dx[k],j+dy[k],WHI);\n\t\t\t break;\n\t\t    }\n\t       }\n\t  }\n\t  for(int i=0;i<W;i++){\n\t       for(int j=0;j<H;j++){\n\t\t    cout<<kui[i][j];\n\t       }\n\t       cout<<endl;\n\t  }\n\t  int sumw=0,sumb=0;\n\t  for(int i=0;i<W;i++){\n\t       for(int j=0;j<H;j++){\n\t\t    if(rin[i][j][BLA]&&(!rin[i][j][WHI]))sumb++;\n\t\t    if(rin[i][j][WHI]&&(!rin[i][j][BLA]))sumw++;\n\t       }\n\t  }\n\t  cout<<sumb<<\" \"<<sumw<<endl;\n     }\n     return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  int w, h;\n  cin >> w >> h;\n  vector<string> in(h);\n  for (int i = 0; i < h; i++) {\n    cin >> in[i];\n  }\n  int ans_w = 0, ans_b = 0;\n  vector<vector<int>> vis(h, vector<int>(w));\n  int dx[] = {1, -1, 0, 0}, dy[] = {0, 0, 1, -1};\n  for (int i = 0; i < h; i++) {\n    for (int j = 0; j < w; j++) {\n      if (vis[i][j] || in[i][j] != '.') continue;\n      //cerr << i << \" \" << j << endl;\n      vis[i][j] = 1;\n      int siz = 1;\n      queue<pair<int, int>> que;\n      que.push({i, j});\n      int col[2] = {};\n      while (que.size()) {\n        auto cur = que.front();\n        que.pop();\n        for (int k = 0; k < 4; k++) {\n          int x = cur.first + dx[k];\n          int y = cur.second + dy[k];\n          if (x < 0 || x >= h || y < 0 || y >= w || vis[x][y]) continue;\n          if (in[x][y] == 'W') {col[0] = 1; continue;}\n          if (in[x][y] == 'B') {col[1] = 1; continue;}\n          vis[x][y]++;\n          que.push({x, y});\n          siz++;\n        }\n      }\n      if (col[0] + col[1] == 2) continue;\n      if (col[0] == 1) ans_w += siz;\n      if (col[1] == 1) ans_b += siz;\n    }\n  }\n  cout << ans_b << \" \" << ans_w << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <limits.h>\n#include <math.h>\n#include <set>\n#include <stack>\n#include <stdlib.h>\n#include <string>\n#include <vector>\n\n#define el endl\n#define fd fixed\n#define INF INT_MAX/2-1\n#define pb push_back\n\nusing namespace std;\n\nchar map[50][50];\nbool memoB[50][50];\nbool memoW[50][50];\n\nvoid search(int x, int y, int w, int h, char color) {\n  if (color == 'B') {\n    memoB[x][y] = true;\n  } else {\n    memoW[x][y] = true;\n  }\n  if (x > 0 && map[x-1][y] == '.') {\n    if ((color == 'B' && !memoB[x-1][y]) || (color == 'W' && !memoW[x-1][y])) {\n      search(x-1, y, w, h, color);\n    }\n  }\n  if (y > 0 && map[x][y-1] == '.') {\n    if ((color == 'B' && !memoB[x][y-1]) || (color == 'W' && !memoW[x][y-1])) {\n      search(x, y-1, w, h, color);\n    }\n  }\n  if (x < w-1 && map[x+1][y] == '.') {\n    if ((color == 'B' && !memoB[x+1][y]) || (color == 'W' && !memoW[x+1][y])) {\n      search(x+1, y, w, h, color);\n    }\n  }\n  if (y < h-1 && map[x][y+1] == '.') {\n    if ((color == 'B' && !memoB[x][y+1]) || (color == 'W' && !memoW[x][y+1])) {\n      search(x, y+1, w, h, color);\n    }\n  }\n}\n\nint main() {\n  int w, h, cntB, cntW, resB, resW;\n  char tmp;\n  while (cin >> w >> h, w | h) {\n    cntB = cntW = 0;\n    for (int i = 0; i < w; i++) {\n      for (int j = 0; j < h; j++) {\n        cin >> tmp;\n        map[i][j] = tmp;\n        if (tmp == '.') memoB[i][j] = memoW[i][j] = false;\n        if (tmp == 'B') memoB[i][j] = true, memoW[i][j] = false, cntB++;\n        if (tmp == 'W') memoB[i][j] = false, memoW[i][j] = true, cntW++;\n      }\n    }\n    for (int i = 0; i < w; i++) {\n      for (int j = 0; j < h; j++) {\n        if (map[i][j] == 'B') search(i, j, w, h, 'B');\n        if (map[i][j] == 'W') search(i, j, w, h, 'W');\n      }\n    }\n    resB = resW = 0;\n    for (int i = 0; i < w; i++) {\n      for (int j = 0; j < h; j++) {\n        if (memoB[i][j] && !memoW[i][j]) resB++;\n        if (!memoB[i][j] && memoW[i][j]) resW++;\n      }\n    }\n    cout << resB-cntB << \" \" << resW-cntW << el;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n\nusing namespace std;\n\nint w,h;\nchar F[52][52][2];\nint check(int x, int y, char a, int wb)\n{\n    if(F[x-1][y][wb] == '.')\n    {\n        F[x-1][y][wb] = a;\n        check(x-1,y,a,wb);\n    }\n    if(F[x+1][y][wb] == '.')\n    {\n        F[x+1][y][wb] = a;\n        check(x+1,y,a,wb);\n    }\n    if(F[x][y-1][wb] == '.')\n    {\n        F[x][y-1][wb] = a;\n        check(x,y-1,a,wb);\n    }\n    if(F[x][y+1][wb] == '.')\n    {\n        F[x][y+1][wb] = a;\n        check(x,y+1,a,wb);\n    }\n}\nint main()\n{\n    int flag;\n    int nw, nb;\n    char a, b;\n    while(cin >> w >> h && w && h)\n    {\n        nw = 0; nb = 0;\n        for(int j=1;j<=h;++j){\n            F[0][j][0]='A';\n            F[0][j][1]='A';\n            F[w+1][j][0]='A';\n            F[w+1][j][1]='A';\n            for(int i=1;i<=w;++i){\n                F[i][0][0]='A';\n                F[i][0][1]='A';\n                F[i][h+1][0]='A';\n                F[i][h+1][1]='A';\n                cin >> F[i][j][0];\n                F[i][j][1] = F[i][j][0];\n            }\n        }\n        for(int k=0;k<2;++k){\n            if(k==0) a='w', b='W';\n            if(k==1) a='b', b='B';\n            for(int j=1;j<=h;++j){\n                for(int i=1;i<=w;++i){\n                    if(F[i][j][k] == b) check(i,j,a,k);\n                }\n            }\n        }\n        for(int j=1;j<=h;++j){\n            for(int i=1;i<=w;++i){\n                if(F[i][j][0] == 'w' && F[i][j][1]== '.') ++nw;\n                else if(F[i][j][1] == 'b' && F[i][j][0] == '.')++nb;\n            }\n        }\n        cout << nb << \" \" << nw << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f; i<int(n); ++i)\n#define rep(i,n) reps(i,0,n)\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\n\nconst int INF = 1001001001;\nconst double EPS = 1e-10;\n\nint w, h;\nchar field[60][60];\nint color[60][60];\nvoid dfs(int y, int x, int col)\n{\n\tconst int dy[] = {-1, 0, 1, 0};\n\tconst int dx[] = {0, -1, 0, 1};\n\t\n\trep(i, 4){\n\t\tint py = y + dy[i];\n\t\tint px = x + dx[i];\n\t\tif(py<0 || h<=py || px<0 || w<=px)\n\t\t\tcontinue;\n\t\tif(color[py][px] & col)\n\t\t\tcontinue;\n\t\tif(field[py][px] != '.')\n\t\t\tcontinue;\n\t\t\n\t\tcolor[py][px] |= col;\n\t\tdfs(py, px, col);\n\t}\n}\n\nint main()\n{\n\twhile(scanf(\"%d%d\", &w, &h), w){\n\t\trep(i, h) rep(j, w)\n\t\t\tcolor[i][j] = 0;\n\t\t\n\t\trep(i, h)\n\t\t\tscanf(\"%s\", field[i]);\n\t\t\n\t\trep(i, h) rep(j, w){\n\t\t\tif(field[i][j] != '.'){\n\t\t\t\tdfs(i, j, field[i][j]=='W' ? 1 : 2);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint a=0, b=0;\n\t\trep(i, h) rep(j, w){\n\t\t\ta += color[i][j] == 1;\n\t\t\tb += color[i][j] == 2;\n\t\t}\n\t\tprintf(\"%d %d\\n\", b, a);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint w, h;\nint a[50][50];\nbool b[2][50][50];\n\nvoid f(int c, int i, int j) {\n\tb[c][i][j] = true;\n\tfor (int k = 0; k < 4; k++) {\n\t\tif (a[i + dy[k]][j + dx[k]] == -1 && !b[c][i + dy[k]][j + dx[k]]) {\n\t\t\tf(c, i + dy[k], j + dx[k]);\n\t\t}\n\t}\n}\n\nint main() {\n\twhile (cin >> w >> h, w) {\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (s[j] == 'B') {\n\t\t\t\t\ta[i][j] = 0;\n\t\t\t\t} else if (s[j] == 'W') {\n\t\t\t\t\ta[i][j] = 1;\n\t\t\t\t} else {\n\t\t\t\t\ta[i][j] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int c = 0; c < 2; c++) {\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tb[c][i][j] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (a[i][j] != -1) {\n\t\t\t\t\tf(a[i][j], i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint p = 0, q = 0;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (a[i][j] == -1) {\n\t\t\t\t\tif (b[0][i][j] && !b[1][i][j]) {\n\t\t\t\t\t\tp++;\n\t\t\t\t\t} else if (!b[0][i][j] && b[1][i][j]) {\n\t\t\t\t\t\tq++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << p << ' ' << q << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint dxy[4] = {-1, 1, 0, 0};\nint W, H;\nchar a[60][60];\nint temp[4][60][60];\n\nvoid huga(int y, int x, int Z){//cout<<y<<\" \"<<x<<endl;\n\tint w = 0, b = 0, s = 0, ans=-3, t;\n\tqueue <P> Q;\n\t\n\tQ.push(P(y,x));\n\t\n\twhile(!Q.empty()){\n\t\tP p = Q.front();Q.pop();\n\t\tint yy = p.first, xx = p.second;//cout<<yy<<\" \"<<xx<<endl;\n\t\tfor(int i = 0; i <= 3; i++){\n\t\t\tint nx = xx+dxy[i], ny = yy+dxy[3-i];//cout<<\" \"<<ny<<\" \"<<nx<<endl;\n\t\t\tif(a[ny][nx] == '.' && !temp[Z+2][ny][nx]) {\n\t\t\t\ttemp[Z+2][ny][nx] = temp[Z][ny][nx] = 1;\n\t\t\t\tQ.push(P(ny,nx));\n\t\t\t\t//cout<<temp[2][ny][nx]<<\" \"<<temp[Z][ny][nx]<<\" AA\"<<endl;\n\t\t\t}\n\t\t\t//int fds; cin>>fds;\n\t\t}\n\t}\n}\n\nint main(){\n\t\n\twhile(1){\n\t\tint cw=0, cb=0;\n\t\tcin>>W>>H;\n\t\t\n\t\tif(!W&&!H)break;\n\t\t\n\t\tfor(int i = 0; i <= H+1; i++)\n\t\t\tfor(int j = 0; j <= W+1; j++)\n\t\t\t\ttemp[0][i][j] = temp[1][i][j] = temp[2][i][j] = temp[3][i][j] = s0;\n\t\t\t\t\n\t\tfor(int i = 0; i < 60; i++){\n\t\t\ta[0][i] = a[H+1][i] = 0;\n\t\t\ta[i][0] = a[i][W+1] = 0;\n\t\t}\n\t\t\t\n\t\tfor(int i = 1; i <= H; i++)\n\t\t\tfor(int j = 1; j <= W; j++)\n\t\t\t\tcin>>a[i][j];\n\t\t\n\t\tfor(int i = 1; i <= H; i++){\n\t\t\tfor(int j = 1; j <= W; j++){\n\t\t\t\t//if(temp[2][i][j])continue;\n\t\t\t\tif(a[i][j] == 'B') huga(i,j,0);\n\t\t\t\telse if(a[i][j] == 'W') huga(i,j,1);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 1; i <= H; i++){\n\t\t\tfor(int j = 1; j <= W; j++){\n\t\t\t\tif(a[i][j] == '.'){\n\t\t\t\t\tif(temp[0][i][j] && !temp[1][i][j])cb++;\n\t\t\t\t\telse if(!temp[0][i][j] && temp[1][i][j])cw++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout<<cb<<\" \"<<cw<<endl;\n\t}\n\t\n\t\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define INF 1e8\n\nint W, H;\nvector<string> m;\nint check(int x, int y, char c) {\n\tint ret = 0;\n\tif (x < 0 || x >= W || y < 0 || y >= H) return 0;\n\tswitch (m[y][x]) {\n\t\tcase '.':\n\t\t\tm[y][x] = '#';\n\t\t\tfor (int dx = -1; dx <= 1; ++dx) {\n\t\t\t\tfor (int dy = -1; dy <= 1; ++dy) {\n\t\t\t\t\tif (dx && dy) continue;\n\n\t\t\t\t\tret += check(x+dx, y+dy, c);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret < 0 ? -INF : ret;\n\n\t\tcase '#':\n\t\t\treturn 0;\n\n\t\tcase 'B':\n\t\tcase 'W':\n\t\t\tif (c != m[y][x]) return -INF;\n\t\t\telse return 1;\n\t}\n\treturn true;\n}\nvoid fill(int x, int y, char from, char to) {\n\tif (x < 0 || x >= W || y < 0 || y >= H) return;\n\tif (m[y][x] == from) {\n\t\tm[y][x] = to;\n\t\tfor (int dx = -1; dx <= 1; ++dx) {\n\t\t\tfor (int dy = -1; dy <= 1; ++dy) {\n\t\t\t\tif (dx && dy) continue;\n\t\t\t\tfill(x+dx, y+dy, from, to);\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\nint paint(int x, int y) {\n\tif (x < 0 || x >= W || y < 0 || y >= H) return 0;\n\tswitch (m[y][x]) {\n\t\tcase '.':\n\t\t{\n\t\t\tint ret = 1;\n\t\t\tm[y][x] = '#';\n\t\t\tfor (int dx = -1; dx <= 1; ++dx) {\n\t\t\t\tfor (int dy = -1; dy <= 1; ++dy) {\n\t\t\t\t\tif (dx && dy) continue;\n\t\t\t\t\tret += paint(x+dx, y+dy);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\tcase '#':\n\t\tcase 'B':\n\t\tcase 'W':\n\t\t\treturn 0;\n\t}\n\treturn 0;\n}\n\nint main() {\n\twhile ( cin >> W >> H, W || H ) {\n\t\tm.clear(); m.resize(H);\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tcin >> m[y];\n\t\t}\n\t\tint aw = 0, ab = 0;\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tif (m[y][x] == '.') {\n\t\t\t\t\tif ( check(x, y, 'B') >= 1 ) {\n\t\t\t\t\t\tfill(x, y, '#', '.');\n\t\t\t\t\t\tab += paint(x, y);\n\t\t\t\t\t}\n\t\t\t\t\tfill(x, y, '#', '.');\n\t\t\t\t\tif ( check(x, y, 'W') >= 1 ) {\n\t\t\t\t\t\tfill(x, y, '#', '.');\n\t\t\t\t\t\taw += paint(x, y);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ab << \" \" << aw << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n\nusing namespace std;\n\nconst int MAX = 51;\nconst int BLACK = 100;\nconst int WHITE = 200;\nint cnt[MAX][MAX],w,h;\nchar map[MAX][MAX];\nint dx[] = {0,0,1,-1};\nint dy[] = {1,-1,0,0};\n\nvoid init(){\n  memset(cnt,0,sizeof(cnt));\n}\n\nbool inside(int x, int y){\n  return 0<=x&&x<w&&0<=y&&y<h;\n}\nvoid solve(int y,int x, int c){\n\n  if(cnt[y][x] == BLACK+WHITE) return;\n  if(c == BLACK && cnt[y][x] == BLACK) return;\n  if(c == WHITE && cnt[y][x] == WHITE) return;\n\n  cnt[y][x]+=c;\n\n  for(int i = 0; i < 4; i++){\n    int nx = x+dx[i];\n    int ny = y+dy[i];\n    if(inside(nx,ny)){\n      if(map[ny][nx] == '.')solve(ny,nx,c);\n    }\n  }\n}\n\nint main(){\n\n  while(cin >> w >> h && w+h){\n\n    init();\n    for(int i = 0; i < h; i++)\n      for(int j = 0; j < w; j++)\n\tcin >> map[i][j];\n\n    for(int i = 0; i < h; i++)\n      for(int j = 0; j < w; j++){\n\tif(map[i][j] == 'W') solve(i,j,WHITE);\n\tif(map[i][j] == 'B') solve(i,j,BLACK);\n      }\n    int bb = 0,ww = 0;\n\n    for(int i = 0; i < h; i++)\n      for(int j = 0; j < w; j++){\n\tif(map[i][j] == '.' && cnt[i][j] == BLACK) bb++;\n\tif(map[i][j] == '.' && cnt[i][j] == WHITE) ww++;\n      }\n\n    cout << bb << \" \" << ww << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <queue>\n#include <map>\nusing namespace std;\ntypedef pair<int, int> P;\nint w,h,wnum, bnum;\nstring field[50];\nbool isin(int x, int y) { return x>=0&&x<h&&y>=0&&y<w; }\nint dx[4]={0,0,-1,1};\nint dy[4]={-1,1,0,0};\nint main() {\n    while (scanf(\"%d%d\",&w,&h)) {\n        if (!w&&!h) break;\n        wnum=bnum=0;\n        for (int i=0; i<h; i++) cin>>field[i];\n        for (int i=0; i<h; i++) {\n            for (int j=0; j<w; j++) {\n                if (field[i][j]=='.') {\n                    int cnt=1;\n                    char flag='0';\n                    field[i][j]='-';\n                    queue<P> que;\n                    que.push(P(i,j));\n                    while (!que.empty()) {\n                        P p=que.front(); que.pop();\n                        for (int k=0; k<4; k++) {\n                            int nx=p.first+dx[k], ny=p.second+dy[k];\n                            if (!isin(nx,ny)) continue;\n                            if (field[nx][ny]=='.') {\n                                que.push(P(nx,ny));\n                                field[nx][ny]='-';\n                                cnt++;\n                            }\n                            if (flag=='0') {\n                                if (field[nx][ny]=='W') {\n                                    flag='W';\n                                } else if (field[nx][ny]=='B') {\n                                    flag='B';\n                                }\n                            } else if (field[nx][ny]=='W'&&flag=='B') {\n                                flag='X';\n                            } else if (field[nx][ny]=='B'&&flag=='W') {\n                                flag='X';\n                            }\n                        }\n                    }\n                    if (flag=='W') wnum+=cnt;\n                    if (flag=='B') bnum+=cnt;\n                }\n            }\n        }\n        // for (int i=0; i<h; i++) cout<<field[i]<<endl;\n        printf(\"%d %d\\n\",bnum,wnum);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n\nusing namespace std;\n\n//debug\n#define DUMP(x)  cerr << #x << \" = \" << (x) << endl;\n#define DEBUG(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nint w, h;\n\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,1,0,-1};\n\nbool B[50][50], W[50][50];\nchar field[50][50];\n\nvoid dfs(int y, int x, bool color){\n\tfor(int k=0; k<4; k++){\n\t\tif(x+dx[k]<0 || x+dx[k]>=w || y+dy[k]<0 || y+dy[k]>=h) continue;\n\t\tif(field[y+dy[k]][x+dx[k]]=='.'){\n\t\t\tif(color){\n\t\t\t\tif(!W[y+dy[k]][x+dx[k]]){\n\t\t\t\t\tW[y+dy[k]][x+dx[k]] = true;\n\t\t\t\t\tdfs(y+dy[k],x+dx[k],1);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(!B[y+dy[k]][x+dx[k]]){\n\t\t\t\t\tB[y+dy[k]][x+dx[k]] = true;\n\t\t\t\t\tdfs(y+dy[k],x+dx[k],0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\tint b_count, w_count;\n\twhile(cin >> w >> h){\n\t\tif(!(w||h)) break;\n\t\tb_count = 0;\n\t\tw_count = 0;\n\t\tfor(int i=0; i<h; i++){\n\t\t\tfor(int j=0; j<w; j++){\n\t\t\t\tcin >> field[i][j];\n\t\t\t\tB[i][j] = false;\n\t\t\t\tW[i][j] = false;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<h; i++){\n\t\t\tfor(int j=0; j<w; j++){\n\t\t\t\tif(field[i][j] == 'B') dfs(i,j,0);\n\t\t\t\tif(field[i][j] == 'W') dfs(i,j,1);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<h; i++){\n\t\t\tfor(int j=0; j<w; j++){\n\t\t\t\tif( B[i][j] && !W[i][j]) b_count++;\n\t\t\t\tif(!B[i][j] &&  W[i][j]) w_count++;\n\t\t\t}\n\t\t}\n\t\tcout << b_count << \" \" << w_count << endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define show(x) cerr<<#x<<\"=\"<<x<<\"\\n\"\ntypedef long long ll;\nusing namespace std;\n//const ll MOD=(ll)1e9+7;\n//const ll inf=(ll)1e14;\nconst int dy[]={1,0,-1,0};\nconst int dx[]={0,1,0,-1};\nint n,m,h,w;\nchar a[51][51],b[51][51],c[51][51];\n\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.precision(10);\n  cout<<fixed;\n#ifdef LOCAL_DEFINE\n  FILE *stream1;\n  //FILE *stream2;\n  stream1=freopen(\"in\",\"r\",stdin);\n  //stream2=freopen(\"out\",\"w\",stdout);\n  if(stream1==NULL)return 0;\n  //if(stream2==NULL)return 0;\n#endif\n  while(cin>>w>>h,h){\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        cin>>a[i][j];\n        b[i][j]=a[i][j];\n        c[i][j]=a[i][j];\n      } \n    }\n    while(1){\n      bool flag=0;\n      for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n          if(a[i][j]=='W'){\n            for(int d=0;d<4;d++){\n              if(i+dy[d]<0 || i+dy[d]>=h)continue;\n              if(j+dx[d]<0 || j+dx[d]>=w)continue;\n              if(a[i+dy[d]][j+dx[d]]=='B')continue;\n              if(a[i+dy[d]][j+dx[d]]=='W')continue;\n              a[i+dy[d]][j+dx[d]]='W';\n              flag=1;\n            }\n          }\n        }\n      }\n      if(!flag)break;\n    }\n    /*for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        cout<<a[i][j];\n      }\n      cout<<\"\\n\";\n    }\n    cout<<\"\\n\";*/\n    while(1){\n      bool flag=0;\n      for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n          if(b[i][j]=='B'){\n            for(int d=0;d<4;d++){\n              if(i+dy[d]<0 || i+dy[d]>=h)continue;\n              if(j+dx[d]<0 || j+dx[d]>=w)continue;\n              if(b[i+dy[d]][j+dx[d]]=='B')continue;\n              if(b[i+dy[d]][j+dx[d]]=='W')continue;\n              b[i+dy[d]][j+dx[d]]='B';\n              flag=1;\n            }\n          }\n        }\n      }\n      if(!flag)break;\n    }\n    /*for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        cout<<b[i][j];\n      }\n      cout<<\"\\n\";\n    }*/\n    int bl=0,wh=0;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        if(c[i][j]!='.')continue;\n        if(a[i][j]=='W' && b[i][j]=='.')wh++;\n        if(a[i][j]=='.' && b[i][j]=='B')bl++;\n      }\n    }\n    cout<<bl<<\" \"<<wh<<endl;\n  }\n#ifdef LOCAL_DEFINE\n  cerr<<\"Time elapsed: \"<<1.0*clock()/CLOCKS_PER_SEC<<\"s.\\n\";\n  fclose(stream1);\n  //fclose(stream2);\n#endif\n  return 0;\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <cctype>\n#include <complex>\n#include <vector>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <cassert>\n#include <iomanip>\n\ntypedef long long ll;\nusing namespace std;\n\nint dx[] = {1, 0 ,-1, 0};\nint dy[] = {0, 1, 0, -1};\nbool dfs(char c, int i, int j, int h, int w, vector<vector<char> > &a){\n\tif(a[i][j] == c) return true;\n\tif(a[i][j] != '.') return false;\n\ta[i][j] = 'Z';\n\t\n\tbool res = false;\n\tfor(int k=0;k<4;k++){\n\t\tint ny = i+dy[k], nx = j+dx[k];\n\t\tif(0 <= nx && nx < w && 0 <= ny && ny < h){\n\t\t\tif(a[ny][nx] != 'Z') res |= dfs(c, ny, nx, h, w, a);\n\t\t}\n\t}\n\treturn res;\n}\n\nbool solve(){\n\tint w, h;\n\tcin>> w>> h;\n\tif(w==0 && h==0) return false;\n\t\n\tvector<vector<char> > in(h, vector<char>(w));\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tcin>> in[i][j];\n\t\t}\n\t}\n\t\n\tint ansb = 0, answ = 0;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(in[i][j] == '.'){\n\t\t\t\tvector<vector<char> > a;\n\t\t\t\ta = in;\n\t\t\t\tbool bb = dfs('B', i, j, h, w, a);\n\t\t\t\ta = in;\n\t\t\t\tbool ww = dfs('W', i, j, h, w, a);\n\t\t\t\tif(bb && !ww) ansb++;\n\t\t\t\tif(!bb && ww) answ++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout<< ansb<< \" \"<< answ<< endl;\n\treturn true;\n}\n\nint main(){\n\tcout.setf(ios::fixed);\n\tcout.precision(10);\n\n\twhile(solve());\n\n\treturn 0;\n}\n\n "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint w, h;\nchar cc,a[50][50];\nbool flag[50][50];\nint dd[5]={0,-1,0,1,0};\nint dfs(int x,int y,char c){\n\tif (x<0||x>=w||y<0||y>= h||flag[x][y])return 0;\n\tif(a[x][y]==c)return (cc=c,0);\n\tif(a[x][y]!='.')return -1;\n\tflag[x][y]=1;\n\tint ret=1;\n\tfor(int i=0;i<4;i++){\n\t\tint cs=dfs(x+dd[i],y+dd[i+1],c);\n\t\tif(cs==-1)ret=-1;\n\t\tif(ret>0)ret+=cs;\n\t}\n\treturn ret;\n}\nint main(){\n\twhile(cin>>w>>h,w){\n\t\tfor(int i=0;i<h*w;i++){\n\t\t\tflag[i%w][i/w]=false;\n\t\t\tcin>>a[i%w][i/w];\n\t\t}\n\t\tchar c[3]=\"BW\";\n\t\tfor(int k=0;k<2;k++){\n\t\t\tint r=0;\n\t\t\tfor(int i=w*h;i--;)flag[i%w][i/w]=0;\n\t\t\tfor(int i=0;i<w*h;i++){\n\t\t\t\tcc='N';\n\t\t\t\tint a=dfs(i%w,i/w,c[k]);\n\t\t\t\tr+=(a>0&&cc==c[k])?a:0;\n\t\t\t}\n\t\t\tcout<<r<<(k?\"\":\" \");\n\t\t}\n\t\tcout<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-11L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n\n#define MOD 998244353LL\n#define seg_size 262144*2LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\nunsigned long xor128() {\n\tstatic unsigned long x = 123456789, y = 362436069, z = 521288629, w = time(NULL);\n\tunsigned long t = (x ^ (x << 11));\n\tx = y; y = z; z = w;\n\treturn (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\n\nvoid init() {\n\t//iostream::sync_with_stdio(false);\n\tcout << fixed << setprecision(20);\n}\n\n#define int ll\nvoid solve() {\n\twhile (true) {\n\t\tint w, h;\n\t\tcin >> w >> h;\n\t\tif (w == 0) return;\n\t\tvector<string> inputs;\n\t\tREP(i, h) {\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tinputs.push_back(s);\n\t\t}\n\t\tint visited[50][50] = {};\n\t\tint answer[2] = {};\n\t\tREP(i, h) {\n\t\t\tREP(q, w) {\n\t\t\t\tif (visited[i][q]) continue;\n\t\t\t\tif (inputs[i][q] != '.') continue;\n\t\t\t\tint cnt[2] = {};\n\t\t\t\tvisited[i][q] = 1;\n\t\t\t\tqueue<pair<int, int>> next;\n\t\t\t\tnext.push(mp(i,q));\n\t\t\t\tint ans = 1;\n\t\t\t\twhile (next.empty() == false) {\n\t\t\t\t\tpair<int, int> now = next.front();\n\t\t\t\t\tnext.pop();\n\t\t\t\t\tint dx[4] = { 1,-1,0,0 };\n\t\t\t\t\tREP(t, 4) {\n\t\t\t\t\t\tint x = dx[t] + now.first;\n\t\t\t\t\t\tint y = dx[3 - t] + now.second;\n\t\t\t\t\t\tif (x >= 0 && x < h && y >= 0 && y < w) {\n\t\t\t\t\t\t\tif (visited[x][y]) continue;\n\t\t\t\t\t\t\tif (inputs[x][y] == '.') {\n\t\t\t\t\t\t\t\tans++;\n\t\t\t\t\t\t\t\tvisited[x][y] = 1;\n\t\t\t\t\t\t\t\tnext.push(mp(x, y));\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (inputs[x][y] == 'W') {\n\t\t\t\t\t\t\t\tcnt[0]++;\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (inputs[x][y] == 'B') {\n\t\t\t\t\t\t\t\tcnt[1]++;\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (cnt[0] != 0 && cnt[1] != 0) continue;\n\t\t\t\tif (cnt[0] != 0) {\n\t\t\t\t\tanswer[0] += ans;\n\t\t\t\t}\n\t\t\t\telse  if(cnt[1] != 0){\n\t\t\t\t\tanswer[1] += ans;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << answer[1] << \" \" << answer[0] << endl;\n\t}\n}\n#undef int\nint main() {\n\tinit();\n\tsolve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nbool used[51][51];\nchar field[51][51];\n\nusing namespace std;\n\nconst int dy[]={-1,0,0,1};\nconst int dx[]={0,1,-1,0};\n\nint h,w;\nbool wok,bok;\nint bfs(int x,int y){\n\t\n\tqueue<pair<int,int> > *prv=new queue<pair<int,int> >();\n\tqueue<pair<int,int> > *nxt=new queue<pair<int,int> >();\n\t\n\tbool white=false;\n\tbool black=false;\n\n\tint cnt=0;\n\tprv->push(make_pair(y,x));\n\twhile(prv->size()){\n\t\twhile(prv->size()){\n\t\t\tpair<int,int> cp = prv->front();prv->pop();\n\t\t\tif(used[cp.first][cp.second]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tused[cp.first][cp.second]=true;\n\t\t\tcnt++;\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tpair<int,int> np=cp;\n\t\t\t\tnp.first+=dy[i];\n\t\t\t\tnp.second+=dx[i];\n\t\t\t\tif(np.first >= 0 && np.second >= 0 && np.first < h && np.second < w){\n\t\t\t\t\tif(field[np.first][np.second]=='W'){\n\t\t\t\t\t\twhite=true;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\telse if(field[np.first][np.second]=='B'){\n\t\t\t\t\t\tblack=true;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(!used[np.first][np.second]){\n\t\t\t\t\t\tnxt->push(np);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tswap(prv,nxt);\n\t}\n\tdelete prv,nxt;\n\n\tif(white && black)\n\t\treturn 0;\n\telse if(white){\n\t\twok=true;\n\t\treturn cnt;\n\t}\n\telse if(black){\n\t\tbok=true;\n\t\treturn cnt;\n\t}\n\telse\n\t\treturn 0;\n}\n\n\n\nint main(){\n\n\twhile(cin>>w>>h&&!(w==0&&h==0)){\n\t\tfor(int i = 0; i < h; i++)\n\t\t\tfill(used[i],used[i]+w,false);\n\n\t\tint wcnt=0;\n\t\tint bcnt=0;\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin>>field[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tif(i==0&&j==4){\n//\t\t\t\t\tcout<<endl;\n\t\t\t\t}\n\t\t\t\twok=false;\n\t\t\t\tbok=false;\n\t\t\t\tif(used[i][j]||field[i][j]!='.')\n\t\t\t\t\tcontinue;\n\t\t\t\tint ccc = bfs(j,i);\n\t\t\t\tif(wok)\n\t\t\t\t\twcnt+=ccc;\n\t\t\t\telse if(bok)\n\t\t\t\t\tbcnt+=ccc;\n\t\t\t}\n\t\t}\n\t\tcout << bcnt << \" \" << wcnt << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <vector>\n#include <string>\n#include <queue>\n#include <deque>\n#include <list>\n#include <stack>\n#include <set>\n#include <map>\n#include <algorithm>\n\n#define int long long\n#define MOD7 1000000007\n#define MOD9 1000000009\n\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define REP(i, a, n) for (int i = (a); i <= (n); i++)\n#define all(a) (a).begin(), (a).end()\n\nusing namespace std;\n\nint dx[4] = { 1, 0, -1, 0 };\nint dy[4] = { 0, -1, 0, 1 };\n\nint nextInt() {int a; cin >> a; return a;}\nchar nextChar() {char a; cin >> a; return a;}\ndouble nextDouble() {double a; cin >> a; return a;}\nstring nextString() {string a; cin >> a; return a;}\n\nvoid inputVector(vector<int> &v, int &n) {rep(i,n){v.push_back(nextInt());}}\nvoid inputVector(vector<double> &v, int &n) {rep(i,n){v.push_back(nextDouble());}}\nvoid inputVector(vector<string> &v, int &n) {rep(i,n){v.push_back(nextString());}}\n\nint w, h;\nbool vw, vb;\nvector<string> board;\nbool visited[60][60];\n\nbool inBoard(int x, int y) {\n    return x >= 0 && x < w && y >= 0 && y < h;\n}\n\nvoid dfs(int x, int y) {\n    visited[y][x] = true;\n    rep(dir, 4) {\n\tint nx = x + dx[dir];\n\tint ny = y + dy[dir];\n\tif (visited[ny][nx]) continue;\n\tif (!inBoard(nx, ny)) continue;\n\tif (board[ny][nx] == 'W') vw = true;\n\telse if (board[ny][nx] == 'B') vb = true;\n\telse dfs(nx, ny);\n    }\n}\n\nsigned main() {\n    while (cin >> w >> h) {\n\tif (!w) break;\n\n\tboard.clear();\n\tinputVector(board, h);\n\n\tvector<string> which = board;\n\trep(y, h) {\n\t    rep(x, w) {\n\t\tif (which[y][x] != '.') continue;\n\t\tmemset(visited, false, sizeof(visited));\n\t\tvw = false; vb = false;\n\t\tdfs(x, y);\n\t\trep(ty, h) {\n\t\t    rep(tx, w) {\n\t\t\tif (!visited[ty][tx]) continue;\n\t\t\tif (vw && !vb) which[ty][tx] = 'w';\n\t\t\telse if (!vw && vb) which[ty][tx] = 'b';\n\t\t\telse which[ty][tx] = ' ';\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n\tint retb = 0, retw = 0;\n\trep(y, h) {\n\t    rep(x, w) {\n\t\tif (which[y][x] == 'b') retb++;\n\t\telse if (which[y][x] == 'w') retw++;\n\t    }\n\t}\n\tcout << retb << ' ' << retw << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\n\nusing namespace std;\n#define int long long int\nconst int INF = 1001001001001001LL;\nconst int MOD = 1000000007;\n\nint di[4] = {1, 0, -1, 0};\nint dj[4] = {0, 1, 0, -1};\n\nvoid dfs(int i, int j, int &s, int &cnt, vector<vector<int> > &g){\n    \n    cnt++;\n    //cerr << cnt << endl;\n    g[i][j] = 0;\n    for(int h = 0; h < 4; h++){\n        int ni = i + di[h];\n        int nj = j + dj[h];\n        if(s == 3){}\n        else if(g[ni][nj] == 1){\n            if(s == 1 || s == 0) s = 1;\n            else s = 3;\n        }else if(g[ni][nj] == 2){\n            if(s == 2 || s == 0) s = 2;\n            else s = 3;\n        }\n        \n    }\n\n    for(int h = 0; h < 4; h++){\n        int ni = i + di[h];\n        int nj = j + dj[h];\n\n        if(g[ni][nj] == 3){\n            dfs(ni, nj, s, cnt, g);\n        }\n    }\n\n    return;\n\n}\n\nsigned main(){\n\n    while(1){\n        int h, w; cin >> h >> w;\n\n        swap(h, w);\n        if(!h) break;\n        vector<vector<int> > g(h + 2, vector<int> (w + 2, 0));\n        for(int i = 1; i <= h; i++){\n            for(int j = 1; j <= w; j++){\n                char c; cin >> c;\n                if(c == '.') g[i][j] = 3;\n                else if(c == 'B') g[i][j] = 1;\n                else if(c == 'W') g[i][j] = 2;\n                else assert(false);\n            }\n        }\n\n        int B = 0;\n        int W = 0;\n\n        for(int i = 1; i <= h; i++){\n            for(int j = 1; j <= w; j++){\n                if(g[i][j] != 3) continue;\n\n                int s = 0;\n                int cnt = 0;\n                dfs(i, j, s, cnt, g);\n                if(s == 1) B += cnt;\n                else if(s == 2) W += cnt;\n            }\n        }\n\n        cout << B << \" \" << W << endl;\n\n        /*\n        for(int i = 0; i <= h + 1; i++){\n            for(int j = 0; j <= w + 1; j++){\n                cout << g[i][j] << \" \";\n                if(j == w + 1) cout << endl;\n            }\n        }*/\n    }\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nint W, H; vector<string> M;\n\nconst vector<int> dx = { 0, 1, 0, -1 };\nconst vector<int> dy = { -1, 0, 1, 0 };\n\nvector<vector<bool> > ok;\n\nvoid rec(int x, int y)\n{\n\tok[y][x] = true;\n\n\tif (M[y][x] != '.')\n\t{\n\t\treturn;\n\t}\n\n\tfor (int dir = 0; dir < 4; dir++)\n\t{\n\t\tint tx = x + dx[dir];\n\t\tint ty = y + dy[dir];\n\n\t\tif (0 <= tx && tx < W && 0 <= ty && ty < H && ok[ty][tx] == false)\n\t\t{\n\t\t\trec(tx, ty);\n\t\t}\n\t}\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tcin >> W >> H;\n\n\t\tif (W == 0 && H == 0) { break; }\n\n\t\tM = vector<string>(H);\n\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tcin >> M[i];\n\t\t}\n\n\t\tint b = 0, w = 0;\n\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tif (M[i][j] == '.')\n\t\t\t\t{\n\t\t\t\t\tok = vector<vector<bool> >(H, vector<bool>(W, false));\n\n\t\t\t\t\trec(j, i);\n\n\t\t\t\t\tint br = 0, wr = 0;\n\n\t\t\t\t\tfor (int k = 0; k < H; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (int l = 0; l < W; l++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (M[k][l] == 'W' && ok[k][l] == true)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\twr++;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (M[k][l] == 'B' && ok[k][l] == true)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tbr++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (wr != 0 && br == 0) { w++; }\n\t\t\t\t\tif (br != 0 && wr == 0) { b++; }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << b << ' ' << w << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n\nint w,h;\nchar map[70][70], wmap[70][70], bmap[70][70];\n\nvoid wdfs(int x, int y) {\n    if(x<0 || x>=w || y<0 || y>=h) return;\n    if(map[y][x] != '.') return;\n    if(wmap[y][x]) return;\n    wmap[y][x] = 1;\n    wdfs(x-1,y);\n    wdfs(x,y-1);\n    wdfs(x+1,y);\n    wdfs(x,y+1);\n}\nvoid bdfs(int x, int y) {\n    if(x<0 || x>=w || y<0 || y>=h) return;\n    if(map[y][x] != '.') return;\n    if(bmap[y][x]) return;\n    bmap[y][x] = 1;\n    bdfs(x-1,y);\n    bdfs(x,y-1);\n    bdfs(x+1,y);\n    bdfs(x,y+1);\n}\n\nint main(void) {\n    while(true) {\n        scanf(\"%d%d\",&w,&h);\n\n        if(!w) break;\n        memset(map, 0, sizeof(map));\n        memset(wmap, 0, sizeof(wmap));\n        memset(bmap, 0, sizeof(bmap));\n\n        for(int j=0; j<h; j++)\n            scanf(\"%s\", map[j]);\n        for(int j=0; j<h; j++)\n            for(int i=0; i<w; i++)\n                switch(map[j][i]) {\n                    case 'W':\n                        wdfs(i-1,j);\n                        wdfs(i,j-1);\n                        wdfs(i+1,j);\n                        wdfs(i,j+1);\n                        break;\n                    case 'B':\n                        bdfs(i-1,j);\n                        bdfs(i,j-1);\n                        bdfs(i+1,j);\n                        bdfs(i,j+1);\n                        break;\n                }\n        int bres=0,wres=0;\n        for(int j=0; j<h; j++)\n            for(int i=0; i<w; i++)\n                if(wmap[j][i] && !bmap[j][i]) wres++;\n                else if(bmap[j][i] && !wmap[j][i]) bres++;\n\n        printf(\"%d %d\\n\", bres, wres);\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\n#define stlice(from, to) substr(from, (to) - (from) + 1)\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\nusing namespace std;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\nusing vd = vector<double>;\nusing vc = vector<char>;\nusing vb = vector<bool>;\nusing vs = vector<string>;\nusing vpii = vector<pii>;\nusing vvi = vector<vi>;\nusing vvb = vector<vb>;\nusing vvpii = vector<vpii>;\ntemplate<typename A> using fn = function<A>;\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = acos(-1);\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nconstexpr bool odd(const int &n) { return n & 1; }\nconstexpr bool even(const int &n) { return !odd(n); }\nvoid solve();\nmain { solve(); return 0; }\n// clang-format on\n\nvoid solve() {\n  int W, H;\n  while (cin >> W >> H, W) {\n    vs v(H);\n    rep(i, H) cin >> v[i];\n    vvi dp(H, vi(W));\n    int b = 0, w = 0;\n    rep(i, H) rep(j, W) {\n      dp[i][j] = 2 * (v[i][j] == 'B') + (v[i][j] == 'W');\n      b -= v[i][j] == 'B';\n      w -= v[i][j] == 'W';\n    }\n    rep(_, W * H) rep(i, H) rep(j, W) {\n      if (v[i][j] != '.') continue;\n      if (i > 0) dp[i][j] |= dp[i - 1][j];\n      if (j > 0) dp[i][j] |= dp[i][j - 1];\n      if (i < H - 1) dp[i][j] |= dp[i + 1][j];\n      if (j < W - 1) dp[i][j] |= dp[i][j + 1];\n    }\n    rep(i, H) rep(j, W) {\n      b += dp[i][j] == 2;\n      w += dp[i][j] == 1;\n    }\n    cout << b << ' ' << w << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <cstring>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n#define I(n,m) if(find(v.begin(),v.end(),make_pair(n,m))==v.end())ret|=D(n,m,v);\ntypedef vector<pair<int,int> >V;\nchar m[99][99];\n\nint D(int i,int j,V&v){\n\tif(m[i][j]=='B')return 1;\n\tif(m[i][j]=='W')return 2;\n\tif(m[i][j]=='X')return 0;\n\tint ret=0;\n\tv.push_back(make_pair(i,j));\n\tI(i-1,j)I(i+1,j)I(i,j-1)I(i,j+1)\n\treturn ret;\n}\n\nmain(){\n\tint w,h,i,j,r,s;\n\tfor(;scanf(\"%d%d\",&w,&h),w;printf(\"%d %d\\n\",r,s)){\n\t\tfor(memset(m,'X',sizeof(m)),r=s=0,i=1;i<=h;i++)scanf(\"%s\",m[i]+1),m[i][w+1]='X';\n\t\tfor(i=1;i<=h;i++)for(j=1;j<=w;j++)if(m[i][j]=='.'){\n\t\t\tV v;for(int x=D(i,j,v),k=0;k<v.size();k++)\n\t\t\t\tm[v[k].first][v[k].second]=x;\n\t\t}\n\t\tfor(i=1;i<=h;i++)for(j=1;j<=w;j++)\n\t\t\tif(m[i][j]==1)r++;\n\t\t\telse if(m[i][j]==2)s++;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\n\tint w,h;\nint dy[]={-1,0,1,0},dx[]={0,-1,0,1};\nint dfs(vs &f,vvi &used,pii cur,char color){\n\tif(f[cur.first][cur.second]=='.')used[cur.first][cur.second]=1;\n\tbool flag=false;\n\tif(f[cur.first][cur.second]!=color&&f[cur.first][cur.second]!='.'){\n\t\treturn -1;\n\t}else if(f[cur.first][cur.second]==color){\n\t\treturn 0;\n\t}\n\tint ret=1;\n\tREP(d,4){\n\t\tint y=cur.first+dy[d];\n\t\tint x=cur.second+dx[d];\n\t\tif(y>=0&&x>=0&&y<h&&x<w&&!used[y][x]){\n\t\t\tint v=dfs(f,used,make_pair(y,x),color);\n\t\t\tif(v==-1){\n\t\t\t\tflag=true;\n\t\t\t}else{\n\t\t\t\tret+=v;\n\t\t\t}\n\t\t}\n\t}\n\tif(flag){\n\t\treturn -1;\n\t}else{\n\t\treturn ret;\n\t}\n}\nint main(){\n\twhile(cin>>w>>h,w|h){\n\t\tvs f(h);\n\t\tbool flag=false;\n\t\tREP(i,h){\n\t\t\tcin>>f[i];\n\t\t\tREP(j,w){\n\t\t\t\tif(f[i][j]!='.')flag=true;\n\t\t\t}\n\t\t}\n\t\tif(!flag){\n\t\t\tcout<<\"0 0\"<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tvi areas(2);\n\t\tREP(c,2){\n\t\t\tvvi used(h,vi(w));\n\t\t\tREP(i,h){\n\t\t\t\tREP(j,w){\n\t\t\t\t\tif(!used[i][j]&&f[i][j]=='.'){\n\t\t\t\t\t\tchar color=!c?'B':'W';\n\t\t\t\t\t\tint v=dfs(f,used,make_pair(i,j),color);\n\t\t\t\t\t\tif(v!=-1){\n\t\t\t\t\t\t\tareas[c]+=v;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<areas[0]<<\" \"<<areas[1]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n\nusing namespace std;\n\nint a[51][51];\nint color[51][51];\nbool checked[51][51];\nint w, h;\n\nint dfs(int y, int x) {\n  if (y < 0 || y >= h) {\n    return 0b100;\n  }\n  if (x < 0 || x >= w) {\n    return 0b100;\n  }\n  if (a[y][x] == 1) {\n    return 0b001;\n  } else if (a[y][x] == 2) {\n    return 0b010;\n  }\n  if (checked[y][x]) {\n    return 0;\n  }\n\n  int dy[] = { -1, 0, 1, 0 };\n  int dx[] = { 0, 1, 0, -1 };\n\n  checked[y][x] = true;\n  int ret = 0;\n  for (int i = 0; i < 4; i++) {\n    ret |= dfs(y + dy[i], x + dx[i]);\n  }\n\n  return ret;\n}\n\nint main() {\n  while (true) {\n    for (int i = 0; i < 51; i++) {\n      for (int j = 0; j < 51; j++) {\n        a[i][j] = 0;\n        color[i][j] = 0;\n        checked[i][j] = false;\n      }\n    }\n\n    cin >> w >> h;\n    if (w + h == 0) {\n      break;\n    }\n    for (int i = 0; i < h; i++) {\n      string str;\n      cin >> str;\n      for (int j = 0; j < w; j++) {\n        if (str[j] == '.') {\n          a[i][j] = 0;\n        } else if (str[j] == 'B') {\n          a[i][j] = 1;\n        } else {\n          a[i][j] = 2;\n        }\n      }\n    }\n    int black = 0, white = 0;\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        if (a[i][j] != 0) {\n          continue;\n        }\n        for (int k = 0; k < h; k++) {\n          for (int l = 0; l < w; l++) {\n            checked[k][l] = false;\n          }\n        }\n        int d = dfs(i, j);\n        if (d == 0b001 || d == 0b101) {\n          black++;\n        }\n        if (d == 0b010 || d == 0b110) {\n          white++;\n        }\n      }\n    }\n    cout << black << \" \" << white << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nvoid fill(char map[55][55], int x, int y, char c){\n\tif(map[x][y] == '.'){\n\t\tmap[x][y] = c;\n\t\tfill(map, x+1, y,c);\n\t\tfill(map, x-1, y,c);\n\t\tfill(map, x, y+1,c);\n\t\tfill(map, x, y-1,c);\n\t}\n}\n\nint main(){\n\tint w,h;\n\tcin >> w >> h;\n\twhile(w&&h){\n\t\tchar mapb[55][55];\n\t\tmemset(mapb, -1, sizeof mapb);\n\t\tfor(int i = 0 ; i < h; ++i){\n\t\t\tfor(int j = 0; j < w; ++j){\n\t\t\t\tcin >> mapb[i+1][j+1];\n\t\t\t}\n\t\t}\n\t\tchar mapw[55][55];\n\t\tmemcpy(mapw, mapb, sizeof mapb);\n\t\tfor(int i = 1; i <= h; ++i){\n\t\t\tfor(int j = 1; j <= w; ++j){\n\t\t\t\tif(mapb[i][j] == 'B'){\n\t\t\t\t\tfill(mapb, i+1, j,'b');\n\t\t\t\t\tfill(mapb, i-1, j,'b');\n\t\t\t\t\tfill(mapb, i, j+1,'b');\n\t\t\t\t\tfill(mapb, i, j-1,'b');\n\t\t\t\t}\n\t\t\t\tif(mapw[i][j] == 'W'){\n\t\t\t\t\tfill(mapw, i+1, j,'w');\n\t\t\t\t\tfill(mapw, i-1, j,'w');\n\t\t\t\t\tfill(mapw, i, j+1,'w');\n\t\t\t\t\tfill(mapw, i, j-1,'w');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint nb,nw;\n\t\tnw = nb = 0;\n\t\tfor(int i = 0; i < 55; ++i){\n\t\t\tfor(int j = 0; j < 55; ++j){\n\t\t\t\tif(mapb[i][j] == 'b' && mapw[i][j] == '.'){\n\t\t\t\t\tnb++;\n\t\t\t\t}\n\t\t\t\tif(mapw[i][j] == 'w' && mapb[i][j] == '.'){\n\t\t\t\t\tnw++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << nb << \" \" << nw << endl;\n\t\tcin >> w >> h;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\n\nint w, h, cnt;\nchar cmp;\nchar field[50][50];\nint dx[] = { -1, 0, 1, 0 };\nint dy[] = { 0, -1, 0, 1 };\n\nint main(){\n    while( cin >> w >> h && w ){\n        for( int i = 0; i < h; i++ ){\n            for( int j = 0; j < w; j++ ){\n                cin >> field[i][j];\n            }\n        }\n        int cnt_b = 0, cnt_w = 0;\n        queue< pair<int, int> > Q;\n        for( int i = 0; i < h; i++ ){\n            for( int j = 0; j < w; j++ ){\n                if( field[i][j] == '.' ){\n                    field[i][j] = '#';\n                    Q.push( pair<int,int>(j, i) );\n                    cnt = 0;\n                    cmp = '.';\n                    bool ans = true;\n                    while( !Q.empty() ){\n                        cnt++;\n                        for( int k = 0; k < 4; k++ ){\n                            int x = Q.front().first + dx[k];\n                            int y = Q.front().second + dy[k];\n                            if( 0 <= x && x < w && 0 <= y && y < h && field[y][x] != '#' ){\n                                if( field[y][x] == 'B' || field[y][x] == 'W' ){\n                                    if( cmp == '.' ) cmp = field[y][x];\n                                    else if( cmp != field[y][x] ) ans =  false;\n                                }else if( field[y][x] == '.' ){\n                                    field[y][x] = '#';\n                                    Q.push( pair<int,int>(x, y) );\n                                }\n                            }\n                        }\n                        Q.pop();\n                    }\n                    if( ans ){\n                        if( cmp == 'B' ){\n                            cnt_b += cnt;\n                        }\n                        else if( cmp == 'W' ){\n                            cnt_w += cnt;\n                        }\n                    }\n                }\n            }\n        }\n        cout << cnt_b << ' ' << cnt_w << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint w, h;\nint dx[] = {0,0,1,-1};\nint dy[] = {1,-1,0,0};\nstring f[51];\n\nvoid solve(int x , int y , char c ){\n\tfor(int i=0 ; i<4 ; i++ ){\n\t\tint mx = x + dx[i];\n\t\tint my = y + dy[i];\n\t\tif( mx < 0 || mx >= w || my < 0 || my >= h ) continue;\n\t\t\n\t\tif( f[my][mx] == '.' ){\n\t\t\tf[my][mx] = ( c == 'W' )? 'w' : 'b' ;\n\t\t\tsolve( mx , my , c );\n\t\t}else if( (c == 'B' && f[my][mx] == 'w') || (c == 'W' && f[my][mx] == 'b') ){\n\t\t\tf[my][mx] = '?';\n\t\t\tsolve( mx , my , c );\n\t\t}\n\t}\n}\n\nvoid debug(){\n\tcout << \"debug : \" << endl;\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\tcout << f[y][x];\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\n\nint main(){\n\twhile( cin >> w >> h , w || h ){\n\t\tint white=0, black=0;\n\t\tfor(int i=0 ; i < h ; i++ ){\n\t\t\tcin >> f[i];\n\t\t}\n\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\t\tif( f[y][x] == 'W' || f[y][x] == 'B' ){\n\t\t\t\t\tsolve( x , y , f[y][x] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//debug();\n\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\t\tif( f[y][x] == 'b' ){\n\t\t\t\t\tblack++;\n\t\t\t\t}else if( f[y][x] == 'w' ){\n\t\t\t\t\twhite++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << black << \" \" << white << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int WWW = 0;WWW < (n);WWW++)cerr << v[WWW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nchar mp[55][55];\nint n,m,bb,ww;\nint dx[] = {1,0,-1,0};\nint dy[] = {0,1,0,-1};\nvoid hoge(int h,int w){\n\tqueue<pair<int,int>> q;\n\tbool isb = false,isw = false;\n\tq.push(MP(h,w));\n\tint ret = 0;\n\twhile(!q.empty()){\n\t\tauto now = q.front();q.pop();\n\t\tif(mp[now.FI][now.SE] == '#')continue;\n\t\tmp[now.FI][now.SE] = '#';\n\t\tret++;\n\t\tREP(i,4){\n\t\t\tint yy = now.FI + dy[i];\n\t\t\tint xx = now.SE + dx[i];\n\t\t\tif(xx < 0 || yy < 0 || xx >= m|| yy >= n)continue;\n\t\t\tif(mp[yy][xx] == '.')q.push(MP(yy,xx));\n\t\t\tif(mp[yy][xx] == 'B')isb = true;\n\t\t\tif(mp[yy][xx] == 'W')isw = true;\n\t\t}\n\t}\n\tif((isb & isw) || !(isb | isw))return;\n\tif(isb)bb += ret;\n\telse ww += ret;\n}\n\t\t\t\n\nint main(){\n\twhile(cin >> m >> n,n|m){\n\t\tbb = 0,ww = 0;\n\t\tREP(i,n)REP(j,m)cin >> mp[i][j];\n\t\tREP(i,n)REP(j,m){\n\t\t\tif(mp[i][j] == '.')hoge(i,j);\n\t\t}\n\t\tcout << bb << ' ' << ww << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,N) for(int (i)=0;(i) < (N); (i)++)\nusing i64 = int64_t;\nusing P = pair<i64,i64>;\n\nint main(){\n    int W,H;\n    while(cin >> W >> H, W != 0){\n        vector<vector<char>> island(H,vector<char>(W));\n        vector<vector<int>> terr(H,vector<int>(W,0));\n\n        stack<P> bPile, wPile;\n        rep(h, H) rep(w ,W){\n            cin >> island[h][w];\n            if(island[h][w] == 'B'){\n                terr[h][w] = -2;\n                bPile.push({h,w});\n            } else if (island[h][w] == 'W') {\n                terr[h][w] = 2;\n                wPile.push({h,w});\n            }\n        } \n\n        auto f = [&](stack<P>& pile, int c){\n            vector<vector<bool>> visited(H,vector<bool>(W,false));\n\n            int d[4] = {1, -1, 0, 0};\n            while(!pile.empty()){\n                P p = pile.top();\n                pile.pop();\n\n                int h = p.first;\n                int w = p.second;\n                rep(i,4){\n                    int nh = h + d[i];\n                    int nw = w + d[i^2];\n                    if(nh < 0 || nh >= H || nw < 0 || nw >= W) continue;\n                    if(visited[nh][nw] == true) continue;\n                    if(terr[nh][nw] == 2 || terr[nh][nw] == -2) continue;\n\n                    terr[nh][nw] += c;\n                    visited[nh][nw] =true;\n                    pile.push({nh,nw});\n                }\n            }\n        };\n\n        f(bPile, -1);\n        f(wPile, 1);\n\n        int black = 0;\n        int white = 0;\n        rep(h,H){\n            rep(w,W){\n                if(terr[h][w] == 1) white++;\n                if(terr[h][w] == -1) black++;\n            }\n        }\n\n        cout << black << \" \" << white << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vbb;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n\n#define loop(i,a,b) for(int i=(a);i<ull(b);++i)\n#define rep(i,n) loop(i,0,n)\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst double inf = (int)1e8;\n\nint w, h;\nstring field[50];\n    int dx[4] = {1, 0, -1, 0};\n    int dy[4] = {0, 1, 0, -1};\n\nbool isIn(int x, int y){\n     return 0 <= x && x < h && 0 <= y && y < w;\n}\n\nint check(int x, int y){\n    bool used[50][50];\n    for(int i=0; i < w; i++) for(int j=0; j< h; j++) used[i][j] = false;\n    int result = 0;\n\n    queue<pair<int, int> > q;\n    q.push(make_pair(x, y));\n    while(!q.empty()){\n        pair<int, int> p = q.front(); q.pop();\n        if(used[p.first][p.second]) continue;\n        used[p.first][p.second] = true;\n        for(int i=0; i< 4; i++){\n            int nx = p.first+dx[i], ny = p.second+dy[i];\n            if(!isIn(nx, ny) || used[nx][ny]) continue;\n            if(field[nx][ny] != '.'){\n                if(result == 0){\n                    if(field[nx][ny] == 'W') result = 1;\n                    else result = 2;\n                }\n                else {\n                    if(result == 2 && field[nx][ny] == 'W') return -1;\n                    else if(result == 1 && field[nx][ny] == 'B') return -1;\n                }\n            } else {\n                q.push(make_pair(nx, ny));\n            }\n        }\n    }\n    return result;\n}\n\nint main(){\n    while(cin >> w >> h, w+h){\n        for(int i=0; i< h; i++) cin >> field[i];\n\n        int a = 0, b = 0;\n        bool is[50][50];\n        for(int i=0; i < 50; i++)for(int j=0; j< 50; j++) is[i][j] = false;\n        for(int i=0; i < h; i++){\n            for(int j=0; j < w; j++){\n                if(field[i][j] == '.' && !is[i][j]){\n                    int r = check(i, j);\n                    int count = 0;\n                    queue<pair<int, int> > q;\n                    q.push(make_pair(i, j));\n                    while(!q.empty()){\n                        pair<int, int> p = q.front(); q.pop();\n                        if(is[p.first][p.second]) continue;\n                        is[p.first][p.second] = true; count++;\n                        for(int i=0; i < 4; i++){\n                            int nx = p.first+dx[i], ny = p.second+dy[i];\n                            if(!isIn(nx, ny) || is[nx][ny]) continue;\n                            if(field[nx][ny] == '.') q.push(make_pair(nx, ny));\n                        }\n                    }\n                    if(r == 1){a+=count; field[i][j] = 'W';}\n                    else if(r == 2){b+=count; field[i][j] = 'B';}\n                }\n            }\n        }\n        cout << b << \" \" << a << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cstdio>\n#include<cstring>\n#include<string>\n\n#define REP(i,n) for(int i=0;i<(n);i++)\n\nint di[4] = {1, 0, -1, 0};\nint dj[4] = {0, 1, 0, -1};\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\nconst ll INF = 1e18;\n\nint w, h;\nchar field[50][50];\nbool visited[50][50];\nbool white_flg;\nbool black_flg;\n\nint dfs(int i, int j){\n    if(i<0 || h<=i || j<0 || j>=w || visited[i][j]) return 0;\n    if(field[i][j] == 'B'){\n        black_flg = true;\n        return 0;\n    }\n    if(field[i][j] == 'W'){\n        white_flg = true;\n        return 0;\n    }\n    visited[i][j] = true;\n    int res = 1;\n    REP(k,4){\n        res += dfs(i+di[k], j+dj[k]);\n    }\n    return res;\n}\n\nint main(){\n    while(cin >> w >> h){\n        if(w+h==0) break;\n        int white = 0;\n        int black = 0;\n        memset(visited, false, sizeof(visited));\n        REP(i,h) cin >> field[i];\n\n        REP(i,h){\n            REP(j,w){\n                if(!visited[i][j] && field[i][j] == '.'){\n                    white_flg = false;\n                    black_flg = false;\n                    int s = dfs(i,j);\n                    if(white_flg && !black_flg) white += s;\n                    else if(black_flg && !white_flg) black += s;\n                }\n            }\n        }\n        cout << black << \" \" << white << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\nusing namespace std;\n\nint dx[] = { 1,0,-1,0 };\nint dy[] = { 0,1,0,-1 };\n\nstruct Grid {\n\tchar c;\n\tbool black;\n\tbool white;\n};\n\nint main()\n{\n\twhile (true) {\n\t\tint w, h;\n\t\tcin >> w >> h;\n\n\t\tif (w == 0 && h == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tvector<vector<Grid>> grid(h, vector<Grid>(w));\n\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tstring str;\n\t\t\tcin >> str;\n\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tgrid[i][j].c = str[j];\n\t\t\t\tgrid[i][j].black = false;\n\t\t\t\tgrid[i][j].white = false;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (grid[i][j].c == 'B') {\n\t\t\t\t\tqueue<pair<int, int>> q;\n\t\t\t\t\tq.push({ i,j });\n\n\t\t\t\t\twhile (q.empty() == false) {\n\t\t\t\t\t\tpair<int, int> temp = q.front();\n\t\t\t\t\t\tq.pop();\n\n\t\t\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\t\t\tint ny = temp.first + dy[k];\n\t\t\t\t\t\t\tint nx = temp.second + dx[k];\n\n\t\t\t\t\t\t\tif (ny < h&&ny >= 0 && nx < w&&nx >= 0 && grid[ny][nx].c == '.'&&grid[ny][nx].black == false) {\n\t\t\t\t\t\t\t\tq.push({ ny,nx });\n\t\t\t\t\t\t\t\tgrid[ny][nx].black = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (grid[i][j].c == 'W') {\n\t\t\t\t\tqueue<pair<int, int>> q;\n\t\t\t\t\tq.push({ i,j });\n\n\t\t\t\t\twhile (q.empty() == false) {\n\t\t\t\t\t\tpair<int, int> temp = q.front();\n\t\t\t\t\t\tq.pop();\n\n\t\t\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\t\t\tint ny = temp.first + dy[k];\n\t\t\t\t\t\t\tint nx = temp.second + dx[k];\n\n\t\t\t\t\t\t\tif (ny < h&&ny >= 0 && nx < w&&nx >= 0 && grid[ny][nx].c == '.'&&grid[ny][nx].white == false) {\n\t\t\t\t\t\t\t\tq.push({ ny,nx });\n\t\t\t\t\t\t\t\tgrid[ny][nx].white = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint blackcount = 0;\n\t\tint whitecount = 0;\n\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (grid[i][j].c == '.') {\n\t\t\t\t\tif (grid[i][j].black == true && grid[i][j].white == false) {\n\t\t\t\t\t\tblackcount++;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (grid[i][j].white == true && grid[i][j].black == false) {\n\t\t\t\t\t\twhitecount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << blackcount << \" \" << whitecount << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include <set>\n#include <cctype>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\nusing namespace std;\n#define INF 100000000\n#define MAXH 64\n#define MAXW 64\n\ntypedef long long ll;\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\nchar a[MAXH][MAXW];\nint w, h;\n\nint main(void) {\n    while (1) {\n        cin >> w >> h;\n        if (w == 0 && h == 0) break;\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                cin >> a[i][j];\n            }\n        }\n        int white = 0, black = 0;\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                if (a[i][j] != '.') continue;\n                bool used[MAXH][MAXW];\n                for (int k = 0; k < h; k++) {\n                    for (int l = 0; l < w; l++) {\n                        used[k][l] = false;\n                    }\n                }\n                queue<int> X, Y;\n                X.push(j); Y.push(i);\n                bool white_flag = false, black_flag = false;\n                while (!X.empty()) {\n                    int x = X.front(); X.pop();\n                    int y = Y.front(); Y.pop();\n                    used[y][x] = true;\n                    for (int k = 0; k < 4; k++) {\n                        int nx = x + dx[k];\n                        int ny = y + dy[k];\n                        if (0 <= nx && nx < w && 0 <= ny && ny < h) {\n                            if (a[ny][nx] == 'W') white_flag = true;\n                            else if (a[ny][nx] == 'B') black_flag = true;\n                            else if (!used[ny][nx]) {\n                                X.push(nx);\n                                Y.push(ny);\n                            }\n                        }\n                    }\n                }\n                if (white_flag && !black_flag) white++;\n                if (!white_flag && black_flag) black++;\n            }\n        }\n        cout << black << \" \" << white << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define loop(i, x, n) for (int i = (x); i < (n); i++)\n#define all(v) (v).begin(), (v).end()\n#define int long long\nusing namespace std;\nconst int MOD = 1e9 + 7;\nconst int INF = 1e10;\ntemplate<typename T> void cmax(T &a, T b) { a = max(a, b); }\ntemplate<typename T> void cmin(T &a, T b) { a = min(a, b); }\nint dy[4] = {0, 1, 0, -1};\nint dx[4] = {1, 0, -1, 0};\nint w, h;\nvoid f(char mp[100][100], int y, int x, char a) {\n  rep(i, 4) {\n    int ny = y + dy[i];\n    int nx = x + dx[i];\n    if (0 <= ny && ny < h && 0 <= nx && nx < w && mp) {\n      if (mp[ny][nx] == '.') {\n        mp[ny][nx] = a;\n        f(mp, ny, nx, a);\n      } else if (mp[ny][nx] == 'w' && a == 'b' || mp[ny][nx] == 'b' && a == 'w') {\n        mp[ny][nx] = '#';\n        f(mp, ny, nx, a);\n      }\n    }\n  }\n}\n\nsigned main() {\n\n  while (cin >> w >> h) {\n    if (w == 0 && w == 0) break;\n    char mp[100][100];\n    rep(i, h) rep(j, w) cin >> mp[i][j];\n\n    rep(i, h) {\n      rep(j, w) {\n        if (mp[i][j] == 'W') {\n          f(mp, i, j, 'w');\n        } else if (mp[i][j] == 'B') {\n          f(mp, i, j, 'b');\n        }\n      }\n    }\n    // rep(i, h) {\n    //   rep(j, w) cout << mp[i][j];\n    //   cout << endl;\n    // }\n    int white = 0, black = 0;\n    rep(i, h) rep(j, w) {\n      if (mp[i][j] == 'w')\n        white++;\n      else if (mp[i][j] == 'b')\n        black++;\n    }\n    cout << black << ' ' << white << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//#define _GRIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\n\n// ??????????????????????\n#pragma region MACRO\n#define P(x) cout << (x) << endl\n#define p(x) cout << (x)\n#define PED cout << \"\\n\"\n#define rep(i,n) for(int i=0; i<(int)n; ++i)\n#define REP(i,x,n) for(int i=x; i<(int)n; ++i)\n#define repi(i,n) for(int i=0; i<=(int)n; ++i)\n#define REPI(i,x,n) for(int i=x; i<=(int)n; ++i)\n#define ILP while(true)\n#define FOR(i,c) for(__typeof((c).begin())!=(c).begin(); i!=(c).end(); ++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp make_pair\n#pragma endregion\n\n// ???\n#pragma region TYPE_DEF\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<string, string> pss;\ntypedef pair<string, int> psi;\ntypedef pair<int, string> pis;\ntypedef vector<int> vi;\ntypedef vector<double> vd;\ntypedef vector<long double> vld;\ntypedef vector<long> vl;\ntypedef vector<long long> vll;\ntypedef vector<string> vs;\n#pragma endregion\n\n// Effective std\n#pragma region ESTD\ntemplate<typename C, typename T> int count(C& c, T t) { return count(ALL(c), t); }\ntemplate<typename C, typename F> int count_if(C& c, F f) { return count_if(ALL(c), f); }\ntemplate<typename C, typename T> void erase(C& c, T t) { remove(ALL(c), t), c.end(); }\ntemplate<typename C> void remove(vector<C>& c, unsigned int index) { c.erase(c.begin()+index); }\ntemplate<typename C, typename T, typename U> void replace(C& c, T t, U u) { replace(ALL(c), t, u); }\ntemplate<typename C, typename F, typename U> void replace_if(C& c, F f, U u) { (ALL(c), f, u); }\ntemplate<typename C> void reverse(C& c) { reverse(ALL(c)); }\ntemplate<typename C> void sort(C& c) { sort(ALL(c)); }\ntemplate<typename C, typename Pred> void sort(C& c, Pred p) { sort(ALL(c), p); }\n#pragma endregion\n\n// ?????\n#pragma region CONST_VAL\nconstexpr int PI = (2*acos(0.0));\nconstexpr int EPS = (1e-9);\nconstexpr int MOD = (int)(1e9+7);\nconstexpr int INF = 100000000;\n#pragma endregion\n\n#define int long long\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nint w, h, res;\nstring a[55];\nbool is_while = false;\nbool is_black = false;\n\nint dfs(int y, int x) {\n    a[y][x] = '#';\n    res++;\n    for(int i=0; i<4; ++i) {\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n        if(nx>=0&&nx<w&&ny>=0&&ny<h) {\n            if(a[ny][nx]=='.') dfs(ny, nx);\n            if(a[ny][nx]=='W') is_while = true;\n            if(a[ny][nx]=='B') is_black = true;\n        }\n    }\n\n    return res;\n}\n\nsigned main()\n{\n    while(cin>>w>>h, w) {\n        for(int i=0; i<h; ++i) cin >> a[i];\n        int nw = 0;\n        int nb = 0;\n        for(int i=0; i<h; ++i) {\n            for(int j=0; j<w; ++j) {\n                if(a[i][j]=='.') {\n                    is_while = false;\n                    is_black = false;\n                    res = 0;\n                    dfs(i, j);\n                    if(is_while&&!is_black) nw += res;\n                    else if(!is_while&&is_black) nb += res;\n                }\n            }\n        }\n        cout << nb << \" \" << nw << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nint W, H; vector<string> M;\n\nconst vector<int> dx = { 0, 1, 0, -1 };\nconst vector<int> dy = { -1, 0, 1, 0 };\n\nint rec(int x, int y, vector<vector<bool> > ok)\n{\n\tif (M[y][x] == 'W')\n\t{\n\t\treturn 2;\n\t}\n\n\tif (M[y][x] == 'B')\n\t{\n\t\treturn 1;\n\t}\n\n\tint ret = 3;\n\n\tfor (int dir = 0; dir < 4; dir++)\n\t{\n\t\tint tx = x + dx[dir];\n\t\tint ty = y + dy[dir];\n\n\t\tif (0 <= tx && tx < W && 0 <= ty && ty < H && ok[ty][tx] == false)\n\t\t{\n\t\t\tvector<vector<bool> > ok2 = ok; ok2[ty][tx] = true;\n\n\t\t\tret = ret & rec(tx, ty, ok2);\n\n\t\t\tif (ret == 0)\n\t\t\t{\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tcin >> W >> H;\n\n\t\tif (W == 0 && H == 0) { break; }\n\n\t\tM = vector<string>(H);\n\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tcin >> M[i];\n\t\t}\n\n\t\tint b = 0, w = 0;\n\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tif (M[i][j] == '.')\n\t\t\t\t{\n\t\t\t\t\tint c = rec(j, i, vector<vector<bool> >(H, vector<bool>(W, false)));\n\n\t\t\t\t\tif (c == 1) { b++; }\n\t\t\t\t\tif (c == 2) { w++; }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << b << ' ' << w << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<queue>\nusing namespace std;\nstruct Point {int x,y;};\nint main(){\n  int w,h;\n  cin >> w >> h;\n  while(w!=0||h!=0){\n    int bw[55][55]={{}};\n    string str;\n    int i,j,k;\n    vector <Point> bs;\n    vector <Point> ws;\n    Point p,b;\n    for(i=0;i<h;i++){\n      cin >> str;\n      for(j=0;j<w;j++){\n\tif(str[j]=='W') {\n\t  bw[j][i]=1;\n\t  p.x=j;p.y=i;\n\t  ws.push_back(p);\n\t}\n\tif(str[j]=='B') {\n\t  bw[j][i]=2;\n\t  p.x=j;p.y=i;\n\t  bs.push_back(p);\n\t}\n      }\n    }\n    queue <Point> q;\n    for(i=0;i<ws.size();i++){\n      p.x = ws[i].x;p.y = ws[i].y;\n      q.push(p);\n      while(!q.empty()){\n\tp=q.front();\n\tq.pop();\n\tint xs[]={1,-1,0,0},ys[]={0,0,1,-1};\n\tfor(j=0;j<4;j++){\n\t  b.x=p.x+xs[j];b.y=p.y+ys[j];\n\t  if(b.x<0||w<=b.x||b.y<0||h<=b.y){\n\t  }else{\n\t    if(bw[b.x][b.y]==0){\n\t      bw[b.x][b.y]=3;\n\t      q.push(b);\n\t    }\n\t  }\n\t}\n      }\n    }\n    for(i=0;i<bs.size();i++){\n      p.x = bs[i].x;p.y = bs[i].y;\n      q.push(p);\n      while(!q.empty()){\n\tp=q.front();\n\tq.pop();\n\tint xs[]={1,-1,0,0},ys[]={0,0,1,-1};\n\tfor(j=0;j<4;j++){\n\t  b.x=p.x+xs[j];b.y=p.y+ys[j];\n\t  if(b.x<0||w<=b.x||b.y<0||h<=b.y) {\n\t  }else{\n\t    if(bw[b.x][b.y]==0){\n\t      bw[b.x][b.y]=4;\n\t      q.push(b);\n\t    }\n\t    if(bw[b.x][b.y]==3){\n\t      bw[b.x][b.y]=5;\n\t      q.push(b);\n\t    }\n\t  }\n\t}\n      }\n    }\n    int wn=0,bn=0;\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tif(bw[j][i]==3) wn++;\n\tif(bw[j][i]==4) bn++;\n      }\n    }\n    cout << bn << \" \" << wn <<  endl;\n    cin >> w >> h;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n  \nint main(){\n\tint w,h,i,j,k,s_b,s_w,b[51][51],wh[51][51];\n\tchar a[51][51];\n\twhile(1){\n\t\ts_b=0;s_w=0;\n\t\tfor(i=0;i<51;i++){\n\t\t\tfor(j=0;j<51;j++){\n\t\t\t\ta[i][j]='\\0';\n\t\t\t\tb[i][j]=0;\n\t\t\t\twh[i][j]=0;\n\t\t\t}\n\t\t}\n\t\t/*0123*/\n\t\tcin>>w>>h;\n\t\tif(w==0&&h==0){break;}\n\t\tfor(i=1;i<h+1;i++){\n\t\t\tfor(j=1;j<w+1;j++){\n\t\t\t\tcin>>a[i][j];\n\t\t\t\tif(a[i][j]=='B'){\n\t\t\t\t\tb[i][j]=2;\n\t\t\t\t\twh[i][j]=1;\n\t\t\t\t}else if(a[i][j]=='W'){\n\t\t\t\t\twh[i][j]=2;\n\t\t\t\t\tb[i][j]=1;\n\t\t\t\t}else{\n\t\t\t\t\tb[i][j]=1;\n\t\t\t\t\twh[i][j]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(k=0;k<w*h;k++){\n\t\t\tfor(i=1;i<h+1;i++){\n\t\t\t\tfor(j=1;j<w+1;j++){\n\t\t\t\t\tif(b[i][j]==1&&wh[i][j]!=2){\n\t\t\t\t\t\tif(b[i+1][j]==2||b[i-1][j]==2||b[i][j+1]==2||b[i][j-1]==2){\n\t\t\t\t\t\t\tb[i][j]=3;\n\t\t\t\t\t\t}\t\t\t\t\t\t\t\n\t\t\t\t\t\tif(b[i+1][j]==3||b[i-1][j]==3||b[i][j+1]==3||b[i][j-1]==3){\n\t\t\t\t\t\t\tb[i][j]=3;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(wh[i][j]==1&&b[i][j]!=2){\n\t\t\t\t\t\tif(wh[i+1][j]==2||wh[i-1][j]==2||wh[i][j+1]==2||wh[i][j-1]==2){\n\t\t\t\t\t\t\twh[i][j]=3;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(wh[i+1][j]==3||wh[i-1][j]==3||wh[i][j+1]==3||wh[i][j-1]==3){\n\t\t\t\t\t\t\twh[i][j]=3;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<h+1;i++){\n\t\t\tfor(j=1;j<w+1;j++){\n\t\t\t\tif(b[i][j]==3&&wh[i][j]!=3){\n\t\t\t\t\ts_b++;\n\t\t\t\t}\n\t\t\t\tif(b[i][j]!=3&&wh[i][j]==3){\n\t\t\t\t\ts_w++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<s_b<<' '<<s_w<<endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\n#define stlice(from, to) substr(from, (to) - (from) + 1)\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\nusing namespace std;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\nusing vd = vector<double>;\nusing vc = vector<char>;\nusing vb = vector<bool>;\nusing vs = vector<string>;\nusing vpii = vector<pii>;\nusing vvi = vector<vi>;\nusing vvb = vector<vb>;\nusing vvpii = vector<vpii>;\ntemplate<typename A> using fn = function<A>;\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = acos(-1);\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nconstexpr bool odd(const int &n) { return n & 1; }\nconstexpr bool even(const int &n) { return !odd(n); }\nvoid solve();\nmain { solve(); return 0; }\n// clang-format on\n\nvoid solve() {\n  int W, H;\n  while (cin >> W >> H, W) {\n    vs v(H);\n    rep(i, H) cin >> v[i];\n    vvi dp(H, vi(W));\n    int b = 0, w = 0;\n    rep(i, H) rep(j, W) {\n      dp[i][j] = 2 * (v[i][j] == 'B') + (v[i][j] == 'W');\n      b -= v[i][j] == 'B';\n      w -= v[i][j] == 'W';\n    }\n    rep(_, W * H) rep(i, H) rep(j, W) {\n      if (v[i][j] != '.') continue;\n      if (i > 0) dp[i][j] |= dp[i - 1][j];\n      if (j > 0) dp[i][j] |= dp[i][j - 1];\n      if (i < H - 1) dp[i][j] |= dp[i + 1][j];\n      if (j < W - 1) dp[i][j] |= dp[i][j + 1];\n    }\n    rep(i, H) rep(j, W) {\n      b += dp[i][j] == 2;\n      w += dp[i][j] == 1;\n    }\n    cout << b << ' ' << w << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\n#define stlice(from, to) substr(from, (to) - (from) + 1)\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\nusing namespace std;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\nusing vd = vector<double>;\nusing vc = vector<char>;\nusing vb = vector<bool>;\nusing vs = vector<string>;\nusing vpii = vector<pii>;\nusing vvi = vector<vi>;\nusing vvb = vector<vb>;\nusing vvpii = vector<vpii>;\ntemplate<typename A> using fn = function<A>;\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = acos(-1);\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nconstexpr bool odd(const int &n) { return n & 1; }\nconstexpr bool even(const int &n) { return !odd(n); }\nvoid solve();\nmain { solve(); return 0; }\n// clang-format on\n\nvoid solve() {\n  int W, H;\n  while (cin >> W >> H, W) {\n    vs v(H);\n    rep(i, H) cin >> v[i];\n    vvi dp(H, vi(W));\n    int b = 0, w = 0;\n    rep(i, H) rep(j, W) {\n      dp[i][j] = 2 * (v[i][j] == 'B') + (v[i][j] == 'W');\n      b -= v[i][j] == 'B';\n      w -= v[i][j] == 'W';\n    }\n    rep(_, W * H) rep(i, H) rep(j, W) {\n      if (v[i][j] != '.') continue;\n      if (i > 0) dp[i][j] |= dp[i - 1][j];\n      if (j > 0) dp[i][j] |= dp[i][j - 1];\n      if (i < H - 1) dp[i][j] |= dp[i + 1][j];\n      if (j < W - 1) dp[i][j] |= dp[i][j + 1];\n    }\n    rep(i, H) rep(j, W) {\n      b += dp[i][j] == 2;\n      w += dp[i][j] == 1;\n    }\n    cout << b << ' ' << w << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define loop(n, i) for(int i=0;i<n;i++)\n#define all(v) v.begin(),v.end()\n#define HERE cout << \"HERE: \" << __LINE__ << endl;\n#define INSP(v) cout << v << \" at \" << __LINE__ << endl;\n\nusing namespace std;\ntypedef long long ll;\n\nint f[50][50];\n\nint dfs(vector<vector<int>> &m, int h, int w, vector<vector<char>> as) {\n    if (h < 0 || w < 0 || h >= m.size() || w >= m[h].size()) {\n        return 0;\n    }\n    if (as[h][w] == 'B') return 1;\n    if (as[h][w] == 'W') return 2;\n    if (f[h][w]) return m[h][w];\n    f[h][w] = 1;\n    int t=0;\n    t |= dfs(m, h-1, w, as);\n    t |= dfs(m, h+1, w, as);\n    t |= dfs(m, h, w+1, as);\n    t |= dfs(m, h, w-1, as);\n    m[h][w] = t;\n    return t;\n}\n\nint siage(vector<vector<int>> &m, int h, int w, vector<vector<char>> as, int max_num) {\n    if (h < 0 || w < 0 || h >= m.size() || w >= m[h].size()) {\n        return 0;\n    }\n    if (as[h][w] == 'B') return 0;\n    if (as[h][w] == 'W') return 0;\n    if (f[h][w]) return m[h][w];\n    f[h][w] = 1;\n    int t=0;\n    max_num = max(max_num, m[h][w]);\n    max_num = max(max_num, siage(m, h-1, w, as, max_num));\n    max_num = max(max_num, siage(m, h+1, w, as, max_num));\n    max_num = max(max_num, siage(m, h, w-1, as, max_num));\n    max_num = max(max_num, siage(m, h, w+1, as, max_num));\n    m[h][w] = max_num;\n    return max_num;\n}\n\nint main()\n{\n    int w, h;\n    while (cin >> w >> h, w) {\n        loop(50,i) loop(50,j) f[i][j] = 0;\n        vector<vector<char>> as;\n        as.resize(h);\n        loop(h,i) {\n            string s;\n            cin >> s;\n            for (char c:s) as[i].push_back(c);\n        }\n       // for(auto mm:as) {\n       //     for (auto m:mm) cout << m << ' ';\n       //     cout << endl;\n       // }\n\n        vector<vector<int>> mat(h, vector<int>(w,0));\n        loop(h,i){\n            loop(w,j){\n                if (as[i][j] == '.') {\n                    dfs(mat, i, j, as);\n                }\n            }\n        }\n        loop(50,i) loop(50,j) f[i][j] = 0;\n\n        loop(h,i){\n            loop(w,j){\n                if (as[i][j] == '.') {\n                    siage(mat, i, j, as, 0);\n                }\n            }\n        }\n        int ans_w = 0, ans_b = 0;\n        for(auto mm:mat) {\n            for (auto m:mm) {\n                if (m == 1) ans_b++;\n                if (m == 2) ans_w++;\n                //cout << m << ' ';\n            }\n            //cout << endl;\n        }\n        cout << ans_b << ' ' << ans_w << endl;\n\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define ALL(a) (a).begin(),(a).end()\nconst int INF = INT_MAX/3;\nconst double EPS = 1e-14;\n\ntemplate<typename U, typename T>\nvoid chmin(U &x, T y) { x = min(x, y); }\n\ntemplate<typename U, typename T>\nvoid chmax(U &x, T y) { x = max(x, y); }\n\ntypedef long long int lli;\ntypedef long double ld;\n\nint W, H;\nconst int HMAX = 58, WMAX = 58;\nchar field[HMAX][WMAX];\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\nbool outof_range(int h, int w) {\n  return h < 0 || W <= h || w < 0 || W <= w;\n}\n\nvoid dfs(int h, int w, char c, char target) {\n  if (outof_range(h, w) or field[h][w] != target) {\n    return;\n  }\n  field[h][w] = c;\n  REP(dir, 4) {\n    dfs(h + dy[dir], w + dx[dir], c, target);\n  }\n}\n\nint main() {\n  cout << fixed << setprecision(10);\n  while (cin >> W >> H and W) {\n    REP(y, HMAX) REP(x, WMAX) {\n      field[y][x] = '#';\n    }\n    REP(y, H) {\n      string row; cin >> row;\n      REP(x, W) {\n        field[y][x] = row[x];\n      }\n    }\n    REP(y, H) REP(x, W) {\n      if (field[y][x] == 'W') {\n        REP(i, 4) {\n          dfs(y + dy[i], x + dx[i], 'w', '.');\n        }\n      }\n      if (field[y][x] == 'B') {\n        REP(i, 4) {\n          dfs(y + dy[i], x + dx[i], 'b', '.');\n        }\n      }\n    }\n    REP(y, H) REP(x, W) {\n      if (field[y][x] == 'W') {\n        REP(i, 4) {\n          dfs(y + dy[i], x + dx[i], 'x', 'b');\n        }\n      }\n      if (field[y][x] == 'B') {\n        REP(i, 4) {\n          dfs(y + dy[i], x + dx[i], 'x', 'w');\n        }\n      }\n    }\n    int white = 0, black = 0;\n    REP(y, H) REP(x, W) {\n      char c = field[y][x];\n      if (c == 'w') { white++; }\n      if (c == 'b') { black++; }\n    }\n    cout << black << \" \" << white << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint w, h;\nvector<string> feeld;\n\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {1, 0, -1, 0};\n\nint add, id;\nvoid rec(int x, int y) {\n\tif (feeld[y][x] == 'B') {\n\t\tid |= 1;\n\t\treturn;\n\t}\n\t\n\tif (feeld[y][x] == 'W') {\n\t\tid |= 2;\n\t\treturn;\n\t}\n\t\n\tfeeld[y][x] = '-';\n\tadd++;\n\t\n\tfor (int i = 0; i < 4; i++) {\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\tif (!(0 <= nx && nx < w && 0 <= ny && ny < h)) continue;\n\t\tif (feeld[ny][nx] == '-') continue;\n\t\trec(nx, ny);\n\t}\n}\n\nvoid solve() {\n\tint ansb = 0, answ = 0;\n\t\n\tfor (int i = 0; i < h; i++) {\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tif (feeld[i][j] == '.') {\n\t\t\t\tadd = 0; id = 0;\n\t\t\t\trec(j, i);\n\t\t\t\tif (id == 1) ansb += add;\n\t\t\t\tif (id == 2) answ += add;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << ansb << \" \" << answ << endl;\n}\n\nint main() {\n\twhile (1) {\n\t\tcin >> w >> h; if (w == 0 && h == 0) break;\n\t\tfeeld.assign(h, \"\");\n\t\tfor (int i = 0; i < h; i++) cin >> feeld[i];\n\t\t\n\t\tsolve();\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <algorithm>\n\n#define CH(N,A,B) (A<=N&&N<B)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define RREP(i,a,b) for(int i=(b-1);a<=i;i--)\n\nusing namespace std;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nint w, h;\nint grand[55][55];\nstring s[55];\nbool flag[55][55];\n\nvoid dfs(int y, int x){\n  if(s[y][x] != '.' || !flag[y][x]) return;\n  flag[y][x] = false;\n  for(int k=0; k<4; k++){\n    if(!CH(x + dx[k],0,w) || !CH(y + dy[k],0,h)) continue;\n    if(s[y + dy[k]][x + dx[k]] != '.') continue;\n    if(grand[y + dy[k]][x + dx[k]] != 3) grand[y + dy[k]][x + dx[k]] = grand[y][x];\n  }\n  for(int k=0; k<4; k++){\n    if(!CH(x + dx[k],0,w) || !CH(y + dy[k],0,h)) continue;\n    if(s[y + dy[k]][x + dx[k]] != '.') continue;\n    dfs(y + dy[k], x + dx[k]);\n  }\n}\n\nint main() {\n\n  while(1){\n    cin>>w>>h;\n    if(w==0 && h==0) break;\n    for(int i=0; i<h; i++){\n      cin>>s[i];\n    }\n    memset(grand, 0, sizeof(grand));\n\n    for(int i=0; i<h; i++){\n      for(int j=0; j<w; j++){\n        if(s[i][j] == '.'){\n          for(int k = 0; k<4; k++){\n            if(!CH(j + dx[k],0,w) || !CH(i + dy[k],0,h)) continue;\n            int posx = j + dx[k], posy = i + dy[k];\n            while(1){\n              if(!CH(posx,0,w) || !CH(posy,0,h)){\n                break;\n              }else if(s[posy][posx] == 'W'){\n                int tx = posx - dx[k], ty = posy - dy[k];\n                while(1){\n                  if(grand[ty][tx] == 0 || grand[ty][tx] == 1) grand[ty][tx] = 1;\n                  else grand[ty][tx] = 3;\n                  if(tx == j && ty == i ) break;\n                  tx -= dx[k];\n                  ty -= dy[k];\n                }\n                break;\n              }else if(s[posy][posx] == 'B'){\n                int tx = posx - dx[k], ty = posy - dy[k];\n                while(1){\n                  if(grand[ty][tx] == 0 || grand[ty][tx] == 2) grand[ty][tx] = 2;\n                  else grand[ty][tx] = 3;\n                  if(tx == j && ty == i ) break;\n                  tx -= dx[k];\n                  ty -= dy[k];\n                }\n                break;\n              }\n              posx += dx[k];\n              posy += dy[k];\n            }\n          }\n        }\n      }\n    }\n\n    for(int i=0; i<h; i++){\n      for(int j=0; j<w; j++){\n        memset(flag, true, sizeof(flag));\n        dfs(i, j);\n      }\n    }\n\n    int wcnt=0, bcnt=0;\n    for(int i=0; i<h; i++){\n      for(int j=0; j<w; j++){\n        if(grand[i][j] == 1) wcnt++;\n        if(grand[i][j] == 2) bcnt++;\n      }\n    }\n\n    cout<<bcnt<<\" \"<<wcnt<<endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\nusing namespace std;\ntypedef pair<int ,int> P;\nchar grid[50][50];\nint W,H;\nint dx[] = {0,0,1,-1},dy[] = {1,-1,0,0};\nchar c[2] = {'B','W'};\n/*void p(){\n  for(int i = 0 ; i < H ; i++ ){\n    for(int j = 0 ; j < W ; j++ ){\n      cout << grid[j][i];\n    }\n    cout << endl;\n  }\n  }*/\nint bfs(int sx,int sy,int k){\n  queue<P> que;\n  int res[2] = {0};\n  bool flag = true;\n  que.push(P(sx,sy));\n  while(!que.empty()){\n    P p = que.front();\n    que.pop(); \n\n    if(grid[p.first][p.second] == '.'){\n      grid[p.first][p.second] = c[k];\n      res[k]++;\n    } else continue;\n\n    for(int i = 0 ; i < 4 ; i++ ){\n      int nx = p.first + dx[i],ny = p.second + dy[i];\n      if(0 <= nx && nx < W && 0 <= ny && ny < H && grid[nx][ny] == '.'){\n\tque.push(P(nx,ny));\n\tif((nx+1 < W && grid[nx+1][ny] == c[!k])||\n\t   (nx-1 >= 0 && grid[nx-1][ny] == c[!k])||\n\t   (ny+1 < H && grid[nx][ny+1] == c[!k])||\n\t   (ny-1 >= 0 && grid[nx][ny-1] == c[!k]))flag = false;\n      }\n    }\n  }\n  if(flag == true)return res[k];\n  else return 0; \n}\n\nint main(){\n  while( cin >> W >> H , W+H ){\n\n    for(int i = 0 ; i < H ; i++ ){\n      for(int j = 0 ; j < W ; j++ ){\n\tcin >> grid[j][i];\n      }\n    }\n    int ans[2] = {0};\n    for(int k = 0 ; k < 2 ; k++ ){\n      for(int i = 0 ; i < H ; i++ ){\n\tfor(int j = 0 ; j < W ; j++ ){\n\t  if(grid[j][i] == '.'){\n\t    if((j+1 < W && grid[j+1][i] == c[k])||\n\t       (j-1 >= 0 && grid[j-1][i] == c[k])||\n\t       (i+1 < H && grid[j][i+1] == c[k])||\n\t       (i-1 >= 0 && grid[j][i-1] == c[k]))ans[k]+=bfs(j,i,k);//p();\n\t  }\n\t}\n      }\n    }\n    cout << ans[0] <<\" \"<< ans[1] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint p,q,sum;\nint x[4]={-1,0,0,1},y[4]={0,-1,1,0};\nstring c[50];\nbool n,m;\nvoid kazoeru(int a,int b){\n    sum++;\n    c[a][b]=0;\n    for(int i=0;i<4;i++){\n\tint dx=a+x[i],dy=b+y[i];\n\tif(dx>=0&&dx<p&&dy>=0&&dy<q){\n\t    if(c[dx][dy]=='.'){kazoeru(dx,dy);}\n\t    else if(c[dx][dy]=='B')n=true;\n\t    else if(c[dx][dy]=='W')m=true;}\n\t}\n    }\nint main(){\n    while(cin>>q>>p,p|q){\n\tfor(int f=0;f<p;f++){\n\t   cin>>c[f];\n\t}\n\tint N=0,M=0;\n\tfor(int f=0;f<p;f++){\n\t   for(int g=0;g<q;g++){\n\t       if(c[f][g]=='.'){sum=0;n=m=false;kazoeru(f,g);\n\t\t  if(!m&&n)M+=sum;\n\t\t  else if(m&&!n)N+=sum;\n\t\t   }}}\n\t\t   cout<<M<<\" \"<<N<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nconst int BL = 5;\nconst int WH = 6;\n\nint dx[] = {-1,1,0,0};\nint dy[] = {0,0,-1,1};\nint tab[52][52];\n\nvoid dfs(int x, int y, int C){\n  REP(i,4){\n\tint tx = x + dx[i], ty = y + dy[i];\n\tif(tab[ty][tx] & C) continue;\n\ttab[ty][tx] |= (C & 3);\n\tdfs(tx, ty, C);\n  }\n}\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int W, H;\n  while(cin >> W >> H, W){\n\tfill((int*)tab, (int*)tab+52*52, 3);\n\tREP(y,H){\n\t  string line; cin >> line;\n\t  REP(x,W){\n\t\tif(line[x] == 'B')\n\t\t  tab[y+1][x+1] = BL;\n\t\telse if(line[x] == 'W')\n\t\t  tab[y+1][x+1] = WH;\n\t\telse\n\t\t  tab[y+1][x+1] = 0;\n\t  }\n\t}\n\tfor(int y=1;y<=H;++y) for(int x=1;x<=W;++x){\n\t  if(tab[y][x] == BL)\n\t\tdfs(x,y,BL);\n\t  else if(tab[y][x] == WH)\n\t\tdfs(x,y,WH);\n\t}\n\t/*\n\tfor(int y=1;y<=H;++y){\n\t  for(int x=1;x<=W;++x)\n\t\tcout << tab[y][x] << \" \";\n\t  cout << endl;\n\t}\n\t*/\n\tint cntB = 0, cntW = 0;\n\tfor(int y=1;y<=H;++y) for(int x=1;x<=W;++x){\n\t  if(tab[y][x] == 1) ++cntB;\n\t  else if(tab[y][x] == 2) ++cntW;\n\t}\n\tcout << cntB << \" \" << cntW << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define all(a) (a).begin(),(a).end()\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> V;\ntypedef vector<V> VV;\ntypedef vector<VV> VVV;\n\nint H, W;\nstring s[100];\nbool done[100][100];\nbool adj1, adj2;\n\nbool inside(int x, int y) {\n    return 0 <= x && x < H && 0 <= y && y < W;\n}\n\nvoid dfs(int x, int y) {\n    if (!inside(x, y)) return;\n    if (done[x][y]) return;\n    if (s[x][y] == 'W') {\n        adj1 = true;\n        return;\n    }\n    if (s[x][y] == 'B') {\n        adj2 = true;\n        return;\n    }\n\n    done[x][y] = true;\n    dfs(x + 1, y);\n    dfs(x - 1, y);\n    dfs(x, y + 1);\n    dfs(x, y - 1);\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    while (cin >> W >> H, W) {\n        int n1 = 0, n2 = 0;\n        rep(i, H) cin >> s[i];\n\n        rep(i, H) {\n            rep(j, W) {\n                if (s[i][j] == '.') {\n                    adj1 = false, adj2 = false;\n                    rep(k, H) rep(l, W) done[k][l] = false;\n                    dfs(i, j);\n                    if (adj1 && !adj2) n1++;\n                    if (!adj1 && adj2) n2++;\n                }\n            }\n        }\n\n        cout << n2 << \" \" << n1 << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\n#define stlice(from, to) substr(from, (to) - (from) + 1)\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\nusing namespace std;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\nusing vd = vector<double>;\nusing vc = vector<char>;\nusing vb = vector<bool>;\nusing vs = vector<string>;\nusing vpii = vector<pii>;\nusing vvi = vector<vi>;\nusing vvb = vector<vb>;\nusing vvpii = vector<vpii>;\ntemplate<typename A> using fn = function<A>;\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = acos(-1);\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nconstexpr bool odd(const int &n) { return n & 1; }\nconstexpr bool even(const int &n) { return !odd(n); }\nvoid solve();\nmain { solve(); return 0; }\n// clang-format on\n\nvoid solve() {\n  int W, H;\n  while (cin >> W >> H, W) {\n    vs v(H);\n    rep(i, H) cin >> v[i];\n    vvi dp(H, vi(W));\n    int b = 0, w = 0;\n    rep(i, H) rep(j, W) {\n      dp[i][j] = 2 * (v[i][j] == 'B') + (v[i][j] == 'W');\n      b -= v[i][j] == 'B';\n      w -= v[i][j] == 'W';\n    }\n    rep(_, W + H) rep(i, H) rep(j, W) {\n      if (v[i][j] != '.') continue;\n      if (i > 0) dp[i][j] |= dp[i - 1][j];\n      if (j > 0) dp[i][j] |= dp[i][j - 1];\n      if (i < H - 1) dp[i][j] |= dp[i + 1][j];\n      if (j < W - 1) dp[i][j] |= dp[i][j + 1];\n    }\n    rep(i, H) rep(j, W) {\n      b += dp[i][j] == 2;\n      w += dp[i][j] == 1;\n    }\n    cout << b << ' ' << w << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing vb=vector<bool>;\nusing vvb=vector<vb>;\nusing vd=vector<double>;\nusing vvd=vector<vd>;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vl=vector<ll>;\nusing vvl=vector<vl>;\nusing pii=pair<int,int>;\nusing pll=pair<ll,ll>;\nusing tll=tuple<ll,ll>;\nusing tlll=tuple<ll,ll,ll>;\nusing vs=vector<string>;\n\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define rep(i,n) range(i,0,n)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define range(i,a,n) for(int i=(a);i<(n);i++)\n\n#define LINF ((ll)1ll<<60)\n#define INF ((int)1<<30)\n#define EPS (1e-9)\n#define MOD (1000000007ll)\n#define fcout(a) cout<<setprecision(a)<<fixed\n#define fs first\n#define sc second\n#define PI 3.1415926535897932384\n\nint dx[]={1,0,-1,0,1,-1,-1,1},dy[]={0,1,0,-1,1,1,-1,-1};\n\ntemplate<class T>bool chmax(T&a,T b){if(a<b){a=b; return true;}return false;}\ntemplate<class T>bool chmin(T&a,T b){if(a>b){a=b; return true;}return false;}\ntemplate<class S>S acm(vector<S>&a){return accumulate(all(a),S());}\ntemplate<class S>S max(vector<S>&a){return *max_element(all(a));}\ntemplate<class S>S min(vector<S>&a){return *min_element(all(a));}\nvoid YN(bool b){cout<<(b?\"YES\":\"NO\")<<\"\\n\";}\nvoid Yn(bool b){cout<<(b?\"Yes\":\"No\")<<\"\\n\";}\nvoid yn(bool b){cout<<(b?\"yes\":\"no\")<<\"\\n\";}\n\nll max(int a,ll b){return max((ll)a,b);} ll max(ll a,int b){return max(a,(ll)b);}\ntemplate<class T>void puta(T&&t){cout<<t<<\"\\n\";}\ntemplate<class H,class...T>void puta(H&&h,T&&...t){cout<<h<<' ';puta(t...);}\ntemplate<class S,class T>ostream&operator<<(ostream&os,pair<S,T>p){os<<\"[\"<<p.first<<\", \"<<p.second<<\"]\";return os;};\ntemplate<class S>auto&operator<<(ostream&os,vector<S>t){bool a=1; for(auto s:t){os<<(a?\"\":\" \")<<s;a=0;} return os;}\n\nvoid solve(int W,int h){\n\tvvi vv(h+2,vi(W+2));\n\tvvb w(h+2,vb(W+2,true)),b(h+2,vb(W+2,true));\n\tqueue<pii> bl,wh;\n\tchar ch;\n\trep(i,h)rep(j,W){\n\t\tb[i+1][j+1]=0;\n\t\tw[i+1][j+1]=0;\n\t\tw[i+1][j+1]=false;\n\t\tb[i+1][j+1]=false;\n\t\tcin>>ch;\n\t\tif(ch=='W'){\n\t\t\tvv[i+1][j+1]=1;\n\t\t\tw[i+1][j+1]=true;\n\t\t\twh.push(pii(i+1,j+1));\n\t\t}\n\t\tif(ch=='B'){\n\t\t\tvv[i+1][j+1]=-1;\n\t\t\tb[i+1][j+1]=true;\n\t\t\tbl.push(pii(i+1,j+1));\n\t\t}\n\t}\n\twhile(!wh.empty()){\n\t\tint x,y;\n\t\ttie(x,y)=wh.front();wh.pop();\n\t\trep(i,4){\n\t\t\tint tx=x+dx[i];\n\t\t\tint ty=y+dy[i];\n\t\t\tif(!w[tx][ty]&&vv[tx][ty]!=-1){\n\t\t\t\twh.push(pii(tx,ty));\n\t\t\t\tw[tx][ty]=true;\n\t\t\t}\n\t\t}\n\t}\n\twhile(!bl.empty()){\n\t\tint x,y;\n\t\ttie(x,y)=bl.front();bl.pop();\n\t\trep(i,4){\n\t\t\tint tx=x+dx[i];\n\t\t\tint ty=y+dy[i];\n\t\t\tif(!b[tx][ty]&&vv[tx][ty]!=1){\n\t\t\t\tbl.push(pii(tx,ty));\n\t\t\t\tb[tx][ty]=true;\n\t\t\t}\n\t\t}\n\t}\n\tint answ=0,ansb=0;\n\trep(i,h){\n\t\trep(j,W){\n\t\t\tif(!w[i+1][j+1]&&b[i+1][j+1])ansb++;\n\t\t\tif(vv[i+1][j+1]==-1)ansb--;\n\t\t\tif(!b[i+1][j+1]&&w[i+1][j+1])answ++;\n\t\t\tif(vv[i+1][j+1]==1)answ--;\n\t\t}\n\t}\n\tcout<<ansb<<\" \"<<answ<<endl;\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint h,w;\n\twhile(cin>>w>>h,h)solve(w,h);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<string>\nusing namespace std;\nint main(){\n\nint W,H;\nwhile(1){\n\tcin>>W>>H;if(W==0&&H==0)break;\n\tint n[53][53]={};int c=0;\n\tstring str;\n\tfor(int i=1;i<H+1;i++){\n\t\tcin>>str;\n\t\tc++;\n\t\tfor(int j=1;j<W+1;j++)\n\t\t{\n\t\t\t\n\t\t\tif(str[j-1]=='.'){n[i][j]=c;}\n\t\t\tif(str[j-1]=='W'){n[i][j]=7001;c++;}\n\t\tif(str[j-1]=='B'){n[i][j]=7002;c++;}\n\t\t}\n\t}\n\n\t\n\n\tfor(int i=1;i<=H;i++)\n\t\tfor(int j=1;j<=W;j++)\n\t\t{if(n[i][j]<7000){int g[]={n[i-1][j],n[i+1][j],n[i][j-1],n[i][j+1]};\n\tint Q=n[i][j];\n\tif(n[i-1][j]>0&&n[i-1][j]<Q)Q=n[i-1][j];\n\tif(n[i+1][j]>0&&n[i+1][j]<Q)Q=n[i+1][j];\n\tif(n[i][j-1]>0&&n[i][j-1]<Q)Q=n[i][j-1];\n\tif(n[i][j+1]>0&&n[i][j+1]<Q)Q=n[i][j+1];\n\tfor(int I=1;I<=H;I++)\n\t\tfor(int J=1;J<=W;J++)\n\t\t\tfor(int K=0;K<=4;K++)\n\t\t\t\tif(n[I][J]==g[K]&&g[K]<7000)n[I][J]=Q;}\n\t}\n\n\n\tint map[7000]={};\n\tfor(int i=1;i<=H;i++)\n\t\tfor(int j=1;j<=W;j++)\n\t\t\t{if(n[i][j]==7001){\n\t\t\t\tint G[]={n[i-1][j],n[i+1][j],n[i][j-1],n[i][j+1]};\n\t\t\t\tfor(int k=0;k<4;k++)\n\t\t\t\t\tif(map[G[k]]==0||map[G[k]]==2)map[G[k]]+=1;\n\t\t\t\t}\n\n\t\t\tif(n[i][j]==7002){\n\t\t\t\tint G[]={n[i-1][j],n[i+1][j],n[i][j-1],n[i][j+1]};\n\t\t\t\tfor(int k=0;k<4;k++)\n\t\t\t\t\tif(map[G[k]]==0||map[G[k]]==1)map[G[k]]+=2;\n\t\t\t}}\n\t\tint cnt[5540]={};\n\t\tfor(int i=1;i<=H;i++)\n\t\tfor(int j=1;j<=W;j++)\n\t\t\tcnt[n[i][j]]++;\n\n\t\t\tint J=0,JJ=0;\n\t\tfor(int i=0;i<W*H*2;i++)\n\t\t{if(map[i]==1)JJ+=cnt[i];else if(map[i]==2)J+=cnt[i];}\n\t\t\n\t\t\n\n\t\tcout<<J<<\" \"<<JJ<<endl;\n}\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <iomanip>\n#include <complex>\nusing namespace std;\n\n#define ll long long\n#define vvi vector< vector<int> >\n#define vi vector<int>\n#define All(X) X.begin(),X.end()\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define pb push_back\n#define pii pair<int,int>\n#define mp make_pair\n#define pi 3.14159265359\n#define shosu(X) fixed << setprecision(X)\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){return a/gcd(a,b)*b;}\n\nint h,w;\nchar grid[51][51];\nbool iswhite[51][51];\nbool isblack[51][51];\nbool issearched[51][51];\nint dx[4] = {-1,0,1,0};\nint dy[4] = {0,-1,0,1};\n\nbool dfs(int px, int py,char c,char c2,bool issearched[51][51]){\n\t//cout << px << \" \" << py << endl;\n\tint res = 1;\n\tREP(i,4){\n\t\tint nx = px + dx[i]; \n\t\tint ny = py + dy[i];\n\t\tif(nx < 0 || ny <0 || nx > h-1 || ny > w-1) return false;\n\t\tif(issearched[nx][ny]) continue;\n\t\tissearched[nx][ny] = true;\n\t\tif(grid[nx][ny] == c) return true;\n\t\telse if(grid[nx][ny] == '.') return dfs(nx,ny,c,c2,issearched);\n\t\telse if(grid[nx][ny] == c2) return false;\n\t}\n\treturn false;\n}\nint main(){\n\twhile(1){\n\t\tcin >> w >> h;\n\t\tif(w==0&&h==0) break;\n\t\tREP(i,h) REP(j,w) cin >> grid[i][j];\n\t\tREP(i,h) REP(j,w) {\n\t\t\tREP(k,h) REP(l,w) issearched[k][l] = false;\n\t\t\tiswhite[i][j] = dfs(i,j,'W','B',issearched);\n\t\t}\n\t\tREP(i,h) REP(j,w) {\n\t\t\tREP(k,h) REP(l,w) issearched[k][l] = false;\n\t\t\tisblack[i][j] = dfs(i,j,'B','W',issearched);\n\t\t}\n\t\tint white = 0; int black = 0;\n\t\tREP(i,h) REP(j,w){\n\t\t\tif(iswhite[i][j] == true && isblack[i][j] == false) white++;\n\t\t\telse if(iswhite[i][j] == false && isblack[i][j] == true) black++;\n\t\t}\n\t\tcout << black << \" \" << white << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <string>\n#include <cstring>\n#include <queue>\n#include <map>\nusing namespace std;\n\nstring land[51];\nint black[51][51],white[51][51],w,h,visited[51][51];\nint dx[4] = {0, 0, 1, -1};\nint dy[4] = {1, -1, 0, 0};\n\nvoid bfs() {\n\n    memset(visited, 0, sizeof(visited));\n    memset(black, 0, sizeof(black));\n    memset(white, 0, sizeof(white));\n\n    queue<pair<int,int> > q;\n    //black\n    for(int i=0; i<h; ++i)\n        for(int j=0; j<w; ++j)\n            if(land[i][j] == 'B')\n                q.push(make_pair(i,j));\n\n\n    while(!q.empty()) {\n        int y = q.front().first,x = q.front().second; q.pop();\n        if(visited[y][x] != 0) continue;\n        visited[y][x] = 1;\n        for(int k=0; k<4; ++k) {\n            int nx = x + dx[k],ny = y + dy[k];\n            if(nx < 0 || nx > w-1 || ny < 0 || ny > h-1) continue;\n            if(land[ny][nx] != '.') continue;\n            black[ny][nx] = 1;\n            q.push(make_pair(ny,nx));\n        }\n    }\n\n    memset(visited, 0, sizeof(visited));\n    for(int i=0; i<h; ++i)\n        for(int j=0; j<w; ++j)\n            if(land[i][j] == 'W')\n                q.push(make_pair(i,j));\n\n\n    while(!q.empty()) {\n        int y = q.front().first,x = q.front().second; q.pop();\n        if(visited[y][x] != 0) continue;\n        visited[y][x] = 1;\n        for(int k=0; k<4; ++k) {\n            int nx = x + dx[k],ny = y + dy[k];\n            if(nx < 0 || nx > w-1 || ny < 0 || ny > h-1) continue;\n            if(land[ny][nx] != '.') continue;\n            white[ny][nx] = 1;\n            q.push(make_pair(ny,nx));\n        }\n    }\n\n}\n\nint main() {\n\n    while(cin>>w>>h, w|h) {\n        for(int i=0; i<h; ++i)\n            cin>>land[i];\n        bfs();\n        int wh=0,bl=0;\n\n        for(int i=0; i<h; ++i) {\n            for(int j=0; j<w; ++j) {\n                if(black[i][j] == 1 && white[i][j] == 0)\n                    bl++;\n\n                if(white[i][j] == 1 && black[i][j] == 0)\n                    wh++;\n            }\n        }\n\n        cout<<bl<<\" \"<<wh<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n#include <cctype>\n#define REP(i,n) for(int i=0;i<(n);i++)\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nint main()\n{\n  while(1){\n    int w, h;\n    cin >> w >> h;\n    if(w == 0 && h == 0) break;\n    char map[h][w];\n    REP(i,h){\n      REP(j,w){\n        cin >> map[i][j];\n      }\n    }\n    queue<pii> a;\n    REP(i,h){\n      REP(j,w){\n        if(map[i][j] == 'B' || map[i][j] == 'W'){\n          if(i > 0){\n            if(map[i-1][j] == '.'){\n              map[i-1][j] = tolower(map[i][j]);\n              a.push(pii(i-1,j));\n            }else if(map[i-1][j] != 'W' && map[i-1][j] != 'B' && map[i-1][j] != 'x' && map[i-1][j] != tolower(map[i][j])){\n              map[i-1][j] = 'x';\n              a.push(pii(i-1,j));\n            }\n          }\n          if(i < h - 1){\n            if(map[i+1][j] == '.'){\n              map[i+1][j] = tolower(map[i][j]);\n              a.push(pii(i+1,j));\n            }else if(map[i+1][j] != 'W' && map[i+1][j] != 'B' && map[i+1][j] != 'x' && map[i+1][j] != tolower(map[i][j])){\n              map[i+1][j] = 'x';\n              a.push(pii(i+1,j));\n            }\n          }\n          if(j > 0){\n            if(map[i][j-1] == '.'){\n              map[i][j-1] = tolower(map[i][j]);\n              a.push(pii(i,j-1));\n            }else if(map[i][j-1] != 'W' && map[i][j-1] != 'B' && map[i][j-1] != 'x' && map[i][j-1] != tolower(map[i][j])){\n              map[i][j-1] = 'x';\n              a.push(pii(i,j-1));\n            }\n          }\n          if(j < w - 1){\n            if(map[i][j+1] == '.'){\n              map[i][j+1] = tolower(map[i][j]);\n              a.push(pii(i,j+1));\n            }else if(map[i][j+1] != 'W' && map[i][j+1] != 'B' && map[i][j+1] != 'x' && map[i][j+1] != tolower(map[i][j])){\n              map[i][j+1] = 'x';\n              a.push(pii(i,j+1));\n            }\n          }\n        }\n      }\n    }\n    while(!a.empty()){\n      int x, y;\n      x = a.front().first;\n      y = a.front().second;\n      a.pop();\n      if(x > 0){\n        if(map[x][y] == 'b'){\n          if(map[x-1][y] == 'w' || map[x-1][y] == 'x'){\n            map[x][y] = map[x-1][y] = 'x';\n            a.push(pii(x,y));\n            a.push(pii(x-1,y));\n          }else if(map[x-1][y] == '.'){\n            map[x-1][y] = 'b';\n            a.push(pii(x-1,y));\n          }else if(map[x-1][y] == 'W'){\n            map[x][y] = x;\n            a.push(pii(x,y));\n          }\n        }else if(map[x][y] == 'w'){\n          if(map[x-1][y] == 'b' || map[x-1][y] == 'x'){\n            map[x][y] = map[x-1][y] = 'x';\n            a.push(pii(x,y));\n            a.push(pii(x-1,y));\n          }else if(map[x-1][y] == '.'){\n            map[x-1][y] = 'w';\n            a.push(pii(x-1,y));\n          }else if(map[x-1][y] == 'B'){\n            map[x][y] = x;\n            a.push(pii(x,y));\n          }\n        }else{\n          if(map[x-1][y] != 'B' && map[x-1][y] != 'W' && map[x-1][y] != 'x'){\n            map[x-1][y] = 'x';\n            a.push(pii(x-1,y));\n          }\n        }\n      }\n      if(x < h - 1){\n        if(map[x][y] == 'b'){\n          if(map[x+1][y] == 'w' || map[x+1][y] == 'x'){\n            map[x][y] = map[x+1][y] = 'x';\n            a.push(pii(x,y));\n            a.push(pii(x+1,y));\n          }else if(map[x+1][y] == '.'){\n            map[x+1][y] = 'b';\n            a.push(pii(x+1,y));\n          }else if(map[x-1][y] == 'W'){\n            map[x][y] = x;\n            a.push(pii(x,y));\n          }\n        }else if(map[x][y] == 'w'){\n          if(map[x+1][y] == 'b' || map[x+1][y] == 'x'){\n            map[x][y] = map[x+1][y] = 'x';\n            a.push(pii(x,y));\n            a.push(pii(x+1,y));\n          }else if(map[x+1][y] == '.'){\n            map[x+1][y] = 'w';\n            a.push(pii(x+1,y));\n          }else if(map[x-1][y] == 'B'){\n            map[x][y] = x;\n            a.push(pii(x,y));\n          }\n        }else{\n          if(map[x+1][y] != 'B' && map[x+1][y] != 'W' && map[x+1][y] != 'x'){\n            map[x+1][y] = 'x';\n            a.push(pii(x+1,y));\n          }\n        }\n      }\n      if(y > 0){\n        if(map[x][y] == 'b'){\n          if(map[x][y-1] == 'w' || map[x][y-1] == 'x'){\n            map[x][y] = map[x][y-1] = 'x';\n            a.push(pii(x,y));\n            a.push(pii(x,y-1));\n          }else if(map[x][y-1] == '.'){\n            map[x][y-1] = 'b';\n            a.push(pii(x,y-1));\n          }else if(map[x-1][y] == 'W'){\n            map[x][y] = x;\n            a.push(pii(x,y));\n          }\n        }else if(map[x][y] == 'w'){\n          if(map[x][y-1] == 'b' || map[x][y-1] == 'x'){\n            map[x][y] = map[x][y-1] = 'x';\n            a.push(pii(x,y));\n            a.push(pii(x,y-1));\n          }else if(map[x][y-1] == '.'){\n            map[x][y-1] = 'w';\n            a.push(pii(x,y-1));\n          }else if(map[x-1][y] == 'B'){\n            map[x][y] = x;\n            a.push(pii(x,y));\n          }\n        }else{\n          if(map[x][y-1] != 'B' && map[x][y-1] != 'W' && map[x][y-1] != 'x'){\n            map[x][y-1] = 'x';\n            a.push(pii(x,y-1));\n          }\n        }\n      }\n      if(y < w - 1){\n        if(map[x][y] == 'b'){\n          if(map[x][y+1] == 'w' || map[x][y+1] == 'x'){\n            map[x][y] = map[x][y+1] = 'x';\n            a.push(pii(x,y));\n            a.push(pii(x,y+1));\n          }else if(map[x][y+1] == '.'){\n            map[x][y+1] = 'b';\n            a.push(pii(x,y+1));\n          }else if(map[x-1][y] == 'W'){\n            map[x][y] = x;\n            a.push(pii(x,y));\n          }\n        }else if(map[x][y] == 'w'){\n          if(map[x][y+1] == 'b' || map[x][y+1] == 'x'){\n            map[x][y] = map[x][y+1] = 'x';\n            a.push(pii(x,y));\n            a.push(pii(x,y+1));\n          }else if(map[x][y+1] == '.'){\n            map[x][y+1] = 'w';\n            a.push(pii(x,y+1));\n          }else if(map[x-1][y] == 'B'){\n            map[x][y] = x;\n            a.push(pii(x,y));\n          }\n        }else{\n          if(map[x][y+1] != 'B' && map[x][y+1] != 'W' && map[x][y+1] != 'x'){\n            map[x][y+1] = 'x';\n            a.push(pii(x,y+1));\n          }\n        }\n      }\n    }\n    pii ans;\n    ans.first = ans.second = 0;\n    REP(i,h){\n      REP(j,w){\n        cout << map[i][j];\n          if(map[i][j] == 'b')\n          ans.first++;\n        else if(map[i][j] == 'w')\n          ans.second++;\n      }\n      cout << endl;\n    }\n    cout << ans.first << \" \" << ans.second << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint w, h;\nchar a[50][50];\nbool flag[50][50];\nint dd[5] = { 0, -1, 0, 1, 0 };\n\nint dfs(int x, int y, char color){\n\tif (x < 0 || x >= w || y < 0 || y >= h || flag[x][y] || a[x][y] == color) return 0;\n\tif (a[x][y] != '.') return -1;\n\tflag[x][y] = true;\n\tint ret = 1;\n\tfor (int i = 0; i < 4; i++){\n\t\tint cs = dfs(x + dd[i], y + dd[i+1], color);\n\t\tif (cs == -1) ret = -1;\n\t\tif(ret>0) ret += cs;\n\t}\n\treturn ret;\n}\n\nint main(){\n\twhile (cin >> w >> h, w){\n\t\tfor (int i = 0; i < h * w; i++){\n\t\t\tflag[i%w][i/w] = false;\n\t\t\tcin >> a[i%w][i/w];\n\t\t}\n\t\tint r[2] = { 0, 0 };\n\t\tchar c[2] = { 'B', 'W' };\n\t\tfor (int k = 0; k < 2; k++){\n\t\t\tfor (int i = 0; i < w*h; i++) flag[i%w][i/w] = false;\n\t\t\tfor (int i = 0; i < w*h; i++){\n\t\t\t\tint a = dfs(i%w, i/w, c[k]);\n\t\t\t\tr[k] += (a >= 0) ? a : 0;\n\t\t\t}\n\t\t}\n\t\tcout << r[0] << \" \" << r[1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <unordered_map> \n#include <algorithm>\n\n/*\n * http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2331&lang=jp\n * test of c++\n */\n\n\nclass Field {\n    public:\n        std::vector<std::vector<int>> field;\n        int height;\n        int width;\n\n        Field(std::vector<std::vector<int>>& input_vec) {\n            height = input_vec.size();\n            width = input_vec.at(0).size();\n            field = input_vec;\n        }\n\n        void flip_bw() {\n            for (int raw = 0; raw < height; raw++) {\n                for (int col = 0; col < width; col++) {\n                    field.at(raw).at(col) = -field.at(raw).at(col);\n                }\n            }\n        }\n\n        std::vector<std::vector<bool>> neighboring() {\n            // adjacency for 1.\n            std::vector<std::vector<bool>> adjacency;\n            std::vector<std::vector<bool>> checked;\n            adjacency = std::vector<std::vector<bool>>(height, std::vector<bool>(width, false));\n            for (int raw = 0; raw < height; raw++) {\n                for (int col = 0; col < width; col++) {\n                    if (field.at(raw).at(col) != 0) {\n                        continue;\n                    }\n                    // to avoid loop\n                    checked = std::vector<std::vector<bool>>(height, std::vector<bool>(width, false));\n                    isNeighboring(raw, col, adjacency, checked);\n                }\n            }\n            return adjacency;\n        }\n\n        bool isNeighboring(int raw, int col, std::vector<std::vector<bool>>& adjacency, std::vector<std::vector<bool>>& checked) {\n            // catch Out of Bounds here.\n            if (raw < 0 || col < 0 || raw >= height || col >= width) {\n                return false;\n            }\n\n            if (checked.at(raw).at(col)) {\n                return adjacency.at(raw).at(col);\n            }\n\n            checked.at(raw).at(col) = true;\n            if (field.at(raw).at(col) != 0) {\n                adjacency.at(raw).at(col) = false;\n                return false;\n            }\n            if (getField(raw, col-1) == 1 || getField(raw, col+1) == 1 || getField(raw-1, col) == 1 || getField(raw+1, col) == 1) {\n                adjacency.at(raw).at(col) = true;\n                return true;\n            }\n\n            if (isNeighboring(raw, col-1, adjacency, checked) || isNeighboring(raw, col+1, adjacency, checked)) {\n                adjacency.at(raw).at(col) = true;\n                return true;\n            }\n            if (isNeighboring(raw-1, col, adjacency, checked) || isNeighboring(raw+1, col, adjacency, checked)) {\n                adjacency.at(raw).at(col) = true;\n                return true;                \n            }\n            adjacency.at(raw).at(col) = false;\n            return false;\n        }\n\n        int getField(int raw, int col) {\n            if (raw < 0 || col < 0 || raw >= height || col >= width) {\n                return -2;\n            }\n            return field.at(raw).at(col);\n        }\n};\n\n\ntemplate <typename T>\nvoid printVector2d(std::vector<std::vector<T>>& matrix) {\n    int h = matrix.size();\n    int w = matrix.at(0).size();\n\n    for (int i = 0; i < h; i++) {\n        for (int j = 0; j < w; j++) {\n            std::cout << matrix.at(i).at(j);\n        }\n        std::cout << std::endl;\n    }\n}\n\n\ntemplate <typename T>\nstd::vector<std::vector<T>> read_input() {\n    std::string input_str;\n\n    std::getline(std::cin, input_str);\n    std::istringstream iss(input_str);\n    T width, height;\n    iss >> width >> height;\n\n    std::vector<std::vector<T>> input_vec(height, std::vector<int>(width, 0));\n\n    for (size_t i = 0; i < height; i++) {\n        std::getline(std::cin, input_str);\n        for (size_t j = 0; j < width; j++) {\n            if (input_str.at(j) == 'W') {\n                input_vec.at(i).at(j) = 1;\n            }\n            else if (input_str.at(j) == 'B') {\n                input_vec.at(i).at(j) = -1;\n            }\n        }\n    }\n    return input_vec;\n}\n\n\nint main(int argc, char const *argv[]) {\n    while (true) {\n        std::vector<std::vector<int>> input_vec = read_input<int>();\n        if (input_vec.size() == 0) {\n            break;\n        }\n        Field field = Field(input_vec);\n        std::vector<std::vector<bool>> white_adjacency = field.neighboring();\n        // std::cout << \"white adjacency\" << std::endl;\n        // printVector2d<bool>(white_adjacency);\n\n        field.flip_bw();\n        std::vector<std::vector<bool>> black_adjacency = field.neighboring();\n        // std::cout << \"black adjacency\" << std::endl;\n        // printVector2d<bool>(black_adjacency);\n\n        int white = 0;\n        int black = 0;\n        for (int raw = 0; raw < field.height; raw++) {\n            for (int col = 0; col < field.width; col++) {\n                if (white_adjacency.at(raw).at(col) && !black_adjacency.at(raw).at(col)) {\n                    white++;\n                }\n                else if (!white_adjacency.at(raw).at(col) && black_adjacency.at(raw).at(col)) {\n                    black++;\n                }\n            }\n        }\n        std::cout << black << \" \" << white << std::endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring s[51];\nbool done[51][51];\n\nint dx[] = {-1, 0, 0, 1};\nint dy[] = {0, 1, -1, 0};\n\nint main() {\n\tint w,h;\n\twhile(1) {\n\t\tcin >> w >> h;\n\t\tmemset(done, 0, sizeof(done));\n\t\tif(w==0 and h==0) break;\n\t\tfor(int i=0;i<h;i++) {\n\t\t\tcin >> s[i];\n\t\t}\n\t\tint bcnt = 0, wcnt = 0;\n\t\tfor(int y=0;y<h;y++) {\n\t\t\tfor(int x=0;x<w;x++) {\n\t\t\t\tif(done[y][x] || s[y][x]=='W' || s[y][x]=='B') continue;\n\t\t\t\tbool bwith = false, wwith = false;\n\t\t\t\tqueue<pair<int,int> > que;\n\t\t\t\tque.push({y,x});\n\t\t\t\tdone[y][x] = true;\n\t\t\t\tint cnt = 1;\n\t\t\t\twhile(!que.empty()) {\n\t\t\t\t\tauto tmp = que.front();\n\t\t\t\t\tque.pop();\n\t\t\t\t\tfor(int k=0;k<4;k++) {\n\t\t\t\t\t\tint ny = tmp.first + dy[k];\n\t\t\t\t\t\tint nx = tmp.second + dx[k];\n\t\t\t\t\t\tif(0<=nx && nx<w && 0<=ny && ny<h) {\n\t\t\t\t\t\t\tif(s[ny][nx]=='.' && !done[ny][nx]) {\n\t\t\t\t\t\t\t\tdone[ny][nx] = true;\n\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t\tque.push({ny,nx});\n\t\t\t\t\t\t\t} else if(s[ny][nx]=='W') {\n\t\t\t\t\t\t\t\twwith = true;\n\t\t\t\t\t\t\t}else if(s[ny][nx]=='B') {\n\t\t\t\t\t\t\t\tbwith = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(bwith && !wwith) bcnt += cnt;\n\t\t\t\tif(!bwith && wwith) wcnt += cnt;\n\t\t\t}\n\t\t}\n\t\tcout << bcnt << \" \" << wcnt << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nchar m[55][55];\nbool used[55][55];\nint w,h;\nint dx[] = {0,0,1,-1};\nint dy[] = {1,-1,0,0};\nchar c,c_;\nbool f;\n\nint solve(int x,int y){\n  int ret = 1;\n  used[x][y] = false;\n  for(int i = 0; i < 4; i++){\n    int nx = x + dx[i];\n    int ny = y + dy[i];\n    if(m[nx][ny] == c){\n      f = true;\n    }\n    if(m[nx][ny] == c_){\n      ret -= 10000;\n    }\n    if(m[nx][ny] == '.' && used[nx][ny]){\n      ret += solve(nx,ny);\n    }\n  }\n  return ret;\n}\n\nint main(void){\n  while(1){\n    scanf(\"%d%d\",&w,&h);\n    if(!w && !h) break;\n    memset(m,0,sizeof(m));\n    for(int i = 1; i <= h; i++){\n      for(int j = 1; j <= w; j++){\n\tscanf(\" %c\",&m[i][j]);\n      }\n    }\n    for(int k = 0; k < 2; k++){\n      int ans = 0;\n      memset(used,true,sizeof(used));\n      c_ = (k)?'B':'W';\n      c = (!k)?'B':'W';\n      for(int i = 1; i <= h; i++){\n\tfor(int j = 1; j <= w; j++){\n\t  if(m[i][j] == '.' && used[i][j]){\n\t    f = false;\n\t    int ret = max(0,solve(i,j));\n\t    if(f){\n\t      //printf(\"%d:%d %d\\n\",i,j,ret);\n\t      ans += ret;\n\t    }\n\t  }\n\t}\n      }\n      printf(\"%d%c\",ans,(k)?'\\n':' ');\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint W,H;\nint used[100][100];\nchar fie[100][100];\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint solve(int x,int y,int &c){\n  if( used[x][y] ) return 0;\n  used[x][y] = 1;\n  c++;\n  int st = 0;\n  for(int i=0;i<4;i++){\n    int nx = x + dx[i], ny = y + dy[i];\n    if( nx < 0 || ny < 0 || nx > W-1 || ny > H-1 ) continue;\n    if( fie[nx][ny] == 'W' ) st |= 2;\n    if( fie[nx][ny] == 'B' ) st |= 1;\n    if( fie[nx][ny] == '.' ) st |= solve(nx,ny,c);\n  }\n  return st;\n}\n\nint main(){\n  while ( cin >> W >> H ){\n    if( !W & !H ) break;\n    for(int i=0;i<H;i++)\n      for(int j=0;j<W;j++) cin >> fie[j][i];\n    int kc = 0;\n    int wc = 0;\n    memset(used,0,sizeof(used));\n    for(int i=0;i<H;i++){\n      for(int j=0;j<W;j++){\n\tif( fie[j][i] == '.' ){\n\t  int c = 0;\n\t  int st = solve(j,i,c);\n\t  if( st == 1 ) kc+=c;\n\t  else if ( st == 2 ) wc+=c;\n\t}\n      }\n    }\n    cout << kc << \" \" << wc << endl;\n\t\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> mypair;\nint dx[]={1,-1,0,0};\nint dy[]={0,0,1,-1};\nvoid dfs(vector<vector<bool> > &map,set<mypair> &ans,mypair now){\n\tint x = now.first;\n\tint y = now.second;\n\tmap[x][y] = false;\n\tfor(int i=0;i<4;i++){\n\tint nx = x+dx[i];\n\tint ny = y+dy[i];\n\tif(map[nx][ny]){\n\t\tmypair next = mypair(nx,ny);\n\t\tans.insert(next);\n\t\tdfs(map,ans,next);\n\t}\n\t}\n\treturn ;\n}\n\nint main(){\n\twhile(1){\n\tint w,h;\n\tcin>>w>>h;\n\tif(w==0)break;\n\tvector<vector<bool> > mapb(h+2,vector<bool>(w+2,false) ) ,mapw(h+2,vector<bool>(w+2,false) );\n\tvector<mypair> brack,white;\n\tfor(int i=1;i<=h;i++)\n\t\tfor(int j=1;j<=w;j++)\n\t\t{\n\t\t\tchar a;\n\t\t\tcin>>a;\n\t\t\tif(a=='.'){\n\t\t\t\tmapb[i][j] = true;\n\t\t\t\tmapw[i][j] = true;\n\t\t\t}else if(a=='W')white.push_back(mypair(i,j) );\n\t\t\telse brack.push_back(mypair(i,j) );\n\t\t}\n\tset<mypair> ansb,answ;\n\tfor(int i=0;i<brack.size();i++)dfs(mapb,ansb,brack[i]);\n\tfor(int i=0;i<white.size();i++)dfs(mapw,answ,white[i]);\n\tint cntb=0,cntw=0;\n\tfor(auto i:ansb){\n\t\tauto it = answ.find(i);\n\t\tif(it==answ.end())cntb++;\n\t}\n\tfor(auto i:answ){\n\t\tauto it = ansb.find(i);\n\t\tif(it==ansb.end())cntw++;\n\t}\n\tcout<<cntb<<' '<<cntw<<endl;\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef pair <int,int> pii;\n#define FST first\n#define SEC second\n\nint w,h;\nint dd[8]={0,1,0,-1,0};\n\nvoid bfs(char map[50][50]){\n  queue <pii> q;\n  int bc=0,wc=0;\n  rep(i,h){\n    rep(j,w){\n      if(map[j][i]=='.'){\n\tq.push(pii(j,i));\n\tint count=0;\n\tpii state=pii(0,0);\n\twhile(!q.empty()){\n\t  int cx=q.front().FST,cy=q.front().SEC;\n\t  q.pop();\n\t  if(map[cx][cy]=='.')\n\t    count++;\n\t  map[cx][cy]='#';\n\t  rep(r,4){\n\t    int nx=cx+dd[r],ny=cy+dd[r+1];\n\t    if(nx<0 || ny<0 || nx>=w || ny>=h || map[nx][ny]=='#')\n\t      continue;\n\t    if(map[nx][ny]=='B'){\n\t      state.FST=1;\n\t      continue;\n\t    }\n\t    if(map[nx][ny]=='W'){\n\t      state.SEC=1;\n\t      continue;\n\t    }\n\t    q.push(pii(nx,ny));\n\t  }\n\t}\n\tif(state==pii(1,0))\n\t  bc+=count;\n\tif(state==pii(0,1))\n\t  wc+=count;\n      } \n    }\n  }\n  printf(\"%d %d\\n\",bc,wc);\n}\n\nint main(){\n  for(;;){\n    cin >> w >> h;\n    if(!(w+h)) break;\n    char map[50][50];\n    rep(i,h){\n      rep(j,w){\n        cin >> map[j][i];\n      }\n    }\n    bfs(map);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<cstring>\n#include<map>\nusing namespace std;\ntypedef pair<int ,int > P;\nint xs[] = {-1, 0, 1, 0}, ys[] = {0, 1, 0, -1};\nchar a[55][55];\nint w, h;\nbool b[55][55], wh[55][55];\n\nint main(){\n\twhile(cin >> w >> h, w | h){\n\t\tmemset(b, 0, sizeof(b));\n\t\tmemset(wh, 0, sizeof(wh));\n\t\tqueue<P> black, white;\n\t\tfor(int i = 0;i < h;i++){\n\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\tcin >> a[i][j];\n\t\t\t\tif(a[i][j] == 'B')black.push(P(i, j));\n\t\t\t\tif(a[i][j] == 'W')white.push(P(i, j));\n\t\t\t}\n\t\t}\n\t\twhile(!black.empty()){\n\t\t\tfor(int t = black.size() - 1;t >= 0;t--){\n\t\t\t\tP tmp = black.front();black.pop();\n\t\t\t\tfor(int i = 0;i < 4;i++){\n\t\t\t\t\tint nx = tmp.first + xs[i], ny = tmp.second + ys[i];\n\t\t\t\t\tif(nx < 0 || nx >= h || ny < 0 || ny >= w || a[nx][ny] != '.')continue;\n\t\t\t\t\tif(b[nx][ny])continue;\n\t\t\t\t\tb[nx][ny] = true;\n\t\t\t\t\tblack.push(P(nx, ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(!white.empty()){\n\t\t\tfor(int t = white.size() - 1;t >= 0;t--){\n\t\t\t\tP tmp = white.front();white.pop();\n\t\t\t\tfor(int i = 0;i < 4;i++){\n\t\t\t\t\tint nx = tmp.first + xs[i], ny = tmp.second + ys[i];\n\t\t\t\t\tif(nx < 0 || nx > h || ny < 0 || ny > w || a[nx][ny] != '.')continue;\n\t\t\t\t\tif(wh[nx][ny])continue;\n\t\t\t\t\twh[nx][ny] = true;\n\t\t\t\t\twhite.push(P(nx, ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint bc = 0, wc = 0;\n\t\tfor(int i = 0;i < h;i++){\n\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\tif(b[i][j] && !wh[i][j])bc++;\n\t\t\t\tif(!b[i][j] && wh[i][j])wc++;\n\t\t\t}\n\t\t}\n\t\tcout << bc << \" \" << wc << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n,N) for(int i=n;i<N;i++)\n#define p(S) cout<<S<<endl\nusing namespace std;\nint SAdx[4]={1,-1,0,0};\nint SAdy[4]={0,0,-1,1};\nint SAw,SAh;\nchar SAmap[51][51];\nvoid SArec(int x,int y,char c){\n\tfor(int i=0;i<4;i++){\n\t\tint nextx=x+SAdx[i],nexty=y+SAdy[i];\n\t\tif(nextx>=0 && nextx<SAw && nexty>=0 &&nexty<SAh){\n\t\t\tif(SAmap[nexty][nextx]=='.'){\n\t\t\t\tSAmap[nexty][nextx]=(c == 'B' ? 'b' : 'w');\n\t\t\t\tSArec(nextx,nexty,c);\n\t\t\t}else if( (SAmap[nexty][nextx]=='b'&&c=='W')||(SAmap[nexty][nextx]=='w'&&c=='B')){\n\t\t\t\tSAmap[nexty][nextx]='e';\n\t\t\t\tSArec(nextx,nexty,c);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(cin>>SAw>>SAh,SAw){\n\t\tint b=0,w=0;\n\t\tREP(i,0,SAh){\n\t\t\tREP(j,0,SAw){\n\t\t\t\tcin>>SAmap[i][j];\n\t\t\t}\n\t\t}\n\t\tREP(i,0,SAh){\n\t\t\tREP(j,0,SAw){\n\t\t\t\tif(SAmap[i][j]=='B'||SAmap[i][j]=='W'){\n\t\t\t\t\tSArec(j,i,SAmap[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tREP(i,0,SAh){\n\t\t\tREP(j,0,SAw){\n\t\t\t\tif(SAmap[i][j]=='b'){\n\t\t\t\t\tb++;\n\t\t\t\t}else if(SAmap[i][j]=='w'){\n\t\t\t\t\tw++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<b<<\" \"<<w<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <limits.h>\n#include <math.h>\n#include <set>\n#include <stack>\n#include <stdlib.h>\n#include <string>\n#include <vector>\n\n#define el endl\n#define fd fixed\n#define INF INT_MAX/2-1\n#define pb push_back\n\nusing namespace std;\n\nchar map[50][50];\nbool memoB[50][50];\nbool memoW[50][50];\n\nvoid search(int x, int y, int w, int h, char color) {\n  if (color == 'B') {\n    memoB[x][y] = true;\n  } else if (color == 'W') {\n    memoW[x][y] = true;\n  }\n  if (x > 0 && map[x-1][y] == '.') {\n    if ((color == 'B' && !memoB[x-1][y]) || (color == 'W' && !memoW[x-1][y])) {\n      search(x-1, y, w, h, color);\n    }\n  }\n  if (y > 0 && map[x][y-1] == '.') {\n    if ((color == 'B' && !memoB[x][y-1]) || (color == 'W' && !memoW[x][y-1])) {\n      search(x, y-1, w, h, color);\n    }\n  }\n  if (x < w-1 && map[x+1][y] == '.') {\n    if ((color == 'B' && !memoB[x+1][y]) || (color == 'W' && !memoW[x+1][y])) {\n      search(x+1, y, w, h, color);\n    }\n  }\n  if (y < h-1 && map[x][y+1] == '.') {\n    if ((color == 'B' && !memoB[x][y+1]) || (color == 'W' && !memoW[x][y+1])) {\n      search(x, y+1, w, h, color);\n    }\n  }\n}\n\nint main() {\n  int w, h, cntB, cntW, resB, resW;\n  char tmp;\n  string s;\n  while (cin >> w >> h, w | h) {\n    cntB = cntW = 0;\n    for (int j = 0; j < h; j++) {\n      cin >> s;\n      for (int i = 0; i < w; i++) {\n        tmp = s[i];\n        map[i][j] = tmp;\n        if (tmp == '.') memoB[i][j] = memoW[i][j] = false;\n        if (tmp == 'B') memoB[i][j] = true, memoW[i][j] = false, cntB++;\n        if (tmp == 'W') memoB[i][j] = false, memoW[i][j] = true, cntW++;\n      }\n    }\n    for (int i = 0; i < w; i++) {\n      for (int j = 0; j < h; j++) {\n        search(i, j, w, h, map[i][j]);\n      }\n    }\n    resB = resW = 0;\n    for (int i = 0; i < w; i++) {\n      for (int j = 0; j < h; j++) {\n        if (memoB[i][j] && !memoW[i][j]) resB++;\n        if (!memoB[i][j] && memoW[i][j]) resW++;\n      }\n    }\n    cout << resB-cntB << \" \" << resW-cntW << el;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\n#define stlice(from, to) substr(from, (to) - (from) + 1)\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\nusing namespace std;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\nusing vd = vector<double>;\nusing vc = vector<char>;\nusing vb = vector<bool>;\nusing vs = vector<string>;\nusing vpii = vector<pii>;\nusing vvi = vector<vi>;\nusing vvb = vector<vb>;\nusing vvpii = vector<vpii>;\ntemplate<typename A> using fn = function<A>;\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = acos(-1);\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nconstexpr bool odd(const int &n) { return n & 1; }\nconstexpr bool even(const int &n) { return !odd(n); }\nvoid solve();\nmain { solve(); return 0; }\n// clang-format on\n\nvoid solve() {\n  int W, H;\n  while (cin >> W >> H, W) {\n    vs v(H);\n    rep(i, H) cin >> v[i];\n    vvi dp(H, vi(W));\n    int b = 0, w = 0;\n    rep(i, H) rep(j, W) {\n      dp[i][j] = 2 * (v[i][j] == 'B') + (v[i][j] == 'W');\n      b -= v[i][j] == 'B';\n      w -= v[i][j] == 'W';\n    }\n    rep(_, W * H) rep(i, H) rep(j, W) {\n      if (v[i][j] != '.') continue;\n      if (i > 0) dp[i][j] |= dp[i - 1][j];\n      if (j > 0) dp[i][j] |= dp[i][j - 1];\n      if (i < H - 1) dp[i][j] |= dp[i + 1][j];\n      if (j < W - 1) dp[i][j] |= dp[i][j + 1];\n    }\n    rep(i, H) rep(j, W) {\n      b += dp[i][j] == 2;\n      w += dp[i][j] == 1;\n    }\n    cout << b << ' ' << w << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "///\n// File:  2014.cpp\n// Author: ymiyamoto\n//\n// Created on Sun Nov 19 01:33:04 2017\n//\n\n#include <cstdint>\n#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nenum color_t {\n  NONE = 0,\n  WHITE = 0x01,\n  BLACK = 0x02,\n  BLACK_AND_WHITE = 0x03,\n};\n\ncolor_t dfs(vector<string> &arr, vector<vector<bool>> &visited, int32_t i, int32_t j)\n{\n  visited[i][j] = true;\n  if (arr[i][j] == 'W') {\n    return WHITE;\n  } else if (arr[i][j] == 'B') {\n    return BLACK;\n  } else {\n    color_t u = NONE, d = NONE, r = NONE, l = NONE;\n    if (i > 0 && !visited[i - 1][j]) {\n      d = dfs(arr, visited, i - 1, j);\n    }\n    if (i + 1 < arr.size() && !visited[i + 1][j]) {\n      u = dfs(arr, visited, i + 1, j);\n    }\n    if (j + 1 < arr[0].size() && !visited[i][j + 1]) {\n      r = dfs(arr, visited, i, j + 1);\n    }\n    if (j > 0 && !visited[i][j - 1]) {\n      l = dfs(arr, visited, i, j - 1);\n    }\n    return (color_t)(u | d | r | l);\n  }\n}\n\nint32_t main()\n{\n  while (true) {\n    uint32_t w, h;\n    cin >> w >> h;\n    if (w == 0 && h == 0) break;\n\n    vector<string> arr;\n    for (uint32_t _ = 0; _ < h; _++) {\n      string str;\n      cin >> str;\n      arr.push_back(str);\n    }\n\n    vector<vector<color_t>> colors(h);\n    vector<vector<bool>> visited(h);\n    for (uint32_t i = 0; i < visited.size(); i++) {\n      colors[i].resize(w, NONE);\n      visited[i].resize(w);\n    }\n    for (uint32_t i = 0; i < h; i++) {\n      for (uint32_t j = 0; j < w; j++) {\n        for (auto iter = visited.begin(); iter < visited.end(); iter++) {\n          for (auto it = iter->begin(); it < iter->end(); it++) {\n            *it = false;\n          }\n        }\n        colors[i][j] = dfs(arr, visited, i, j);\n      }\n    }\n\n    uint32_t whites = 0, blacks = 0;\n    for (uint32_t i = 0; i < h; i++) {\n      for (uint32_t j = 0; j < w; j++) {\n        if (arr[i][j] == '.') {\n          if (colors[i][j] == WHITE) {\n            whites++;\n          } else if (colors[i][j] == BLACK) {\n            blacks++;\n          }\n        }\n      }\n    }\n    cout << blacks << \" \" << whites << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) begin(r),end(r)\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init))\n#define mp(a,b) make_pair(a,b)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\n\ntemplate<typename T>\nvoid O(T t){\n  cout << t << endl;\n}\n\nconst ll mod = 1e9+7;\nconstexpr ll inf = ((1<<30)-1)*2+1 ;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\nconst int dy[] = {-1,0,1,0,1,-1,1,-1};\nconst int dx[] = {0,-1,0,1,1,-1,-1,1};\n\ninline bool value(int x,int y,int w,int h){\n  return (x >= 0 && x < w && y >= 0 && y < h);\n}\n\nll W,h;\nvoid fill(vector<vector<char>> &m,int b){\n  char c,C;\n  if(b == 0){\n    c = 'b';\n    C = 'B';\n  }\n  else{\n    c = 'w';\n    C = 'W';\n  }\n  rep(x,W){\n    rep(y,h){\n      if(m[x][y] == '.'){\n        rep(i,4){\n          int nx = dx[i] + x,ny = dy[i] + y;\n          if(value(nx,ny,W,h) && (m[nx][ny] == C)){\n            m[x][y] = c;\n          }\n        }\n      }\n    }\n  }\n}\nvoid solve(vector<vector<char>> &m,int x,int y,int b){\n  char c,C;\n  if(b == 0){\n    c = 'b';\n    C = 'B';\n  }\n  else{\n    c = 'w';\n    C = 'W';\n  }\n  if(m[x][y] == c){\n    rep(i,4){\n      int nx = dx[i] + x,ny = dy[i] + y;\n      if(value(nx,ny,W,h) && (m[nx][ny] == '.')){\n        m[nx][ny] = c;\n        solve(m,nx,ny,b);\n      }\n    }\n  }\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  while(cin >> W >> h,W+h){\n    vector<vector<char>> w(51,vector<char>(51)),b;\n    rep(i,W){\n      rep(j,h){\n        cin >> w[i][j];\n      }\n    }\n    b = w;\n    fill(w,1);\n    fill(b,0);\n    rep(i,W){\n      rep(j,h){\n        solve(w,i,j,1);\n        solve(b,i,j,0);\n      }\n    }\n    /* rep(i,W){                 */\n    /*   rep(j,h){               */\n    /*     cout << w[i][j] ;     */\n    /*   }                       */\n    /*   std::cout << std::endl; */\n    /* }                         */\n    /* rep(i,W){                 */\n    /*   rep(j,h){               */\n    /*     cout << b[i][j] ;     */\n    /*   }                       */\n    /*   std::cout << std::endl; */\n    /* }                         */\n    ll bc = 0,wc = 0;\n    rep(i,W){\n      rep(j,h){\n        if(w[i][j] == 'w' && b[i][j] != 'b'){\n          int c = 1;\n          /* rep(k,4){                                   */\n          /*   int nx = dx[k] + i,ny = dy[k] + j;        */\n          /*   if(value(nx,ny,W,h) && w[nx][ny] == 'B'){ */\n          /*     c = 0;                                  */\n          /*   }                                         */\n          /* }                                           */\n          /* if(c) w[i][j] = '0';                        */\n          wc += c;\n        }\n      }\n    }\n    rep(i,W){\n      rep(j,h){\n        if(b[i][j] == 'b' && w[i][j] != 'w'){\n          int c = 1;\n          /* rep(k,4){                                     */\n          /*   int nx = dx[k] + i,ny = dy[k] + j;          */\n          /*   if(value(nx,ny,W,h) && (b[nx][ny] == 'W')){ */\n          /*     c = 0;                                    */\n          /*   }                                           */\n          /* }                                             */\n          bc += c;\n        }\n      }\n    }\n    /* rep(i,W){               */\n    /* rep(j,h){               */\n    /* cout << w[i][j] ;       */\n    /* }                       */\n    /* std::cout << std::endl; */\n    /* }                       */\n    cout << bc << ' ' << wc << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint dxy[4] = {-1, 1, 0, 0};\nint W, H;\nchar a[60][60];\nint temp[4][60][60];\n\nvoid huga(int y, int x, int Z){//cout<<y<<\" \"<<x<<endl;\n\tint w = 0, b = 0, s = 0, ans=-3, t;\n\tqueue <P> Q;\n\t\n\tQ.push(P(y,x));\n\t\n\twhile(!Q.empty()){\n\t\tP p = Q.front();Q.pop();\n\t\tint yy = p.first, xx = p.second;//cout<<yy<<\" \"<<xx<<endl;\n\t\tfor(int i = 0; i <= 3; i++){\n\t\t\tint nx = xx+dxy[i], ny = yy+dxy[3-i];//cout<<\" \"<<ny<<\" \"<<nx<<endl;\n\t\t\tif(a[ny][nx] == '.' && !temp[Z+2][ny][nx]) {\n\t\t\t\ttemp[Z+2][ny][nx] = temp[Z][ny][nx] = 1;\n\t\t\t\tQ.push(P(ny,nx));\n\t\t\t\t//cout<<temp[2][ny][nx]<<\" \"<<temp[Z][ny][nx]<<\" AA\"<<endl;\n\t\t\t}\n\t\t\t//int fds; cin>>fds;\n\t\t}\n\t}\n}\n\nint main(){\n\t\n\twhile(1){\n\t\tint cw=0, cb=0;\n\t\tcin>>W>>H;\n\t\t\n\t\tif(!W&&!H)break;\n\t\t\n\t\tfor(int i = 0; i <= H+1; i++)\n\t\t\tfor(int j = 0; j <= W+1; j++)\n\t\t\t\ttemp[0][i][j] = temp[1][i][j] = temp[2][i][j] = temp[3][i][j] = 0;\n\t\t\t\t\n\t\tfor(int i = 0; i < 60; i++){\n\t\t\ta[0][i] = a[H+1][i] = 0;\n\t\t\ta[i][0] = a[i][W+1] = 0;\n\t\t}\n\t\t\t\n\t\tfor(int i = 1; i <= H; i++)\n\t\t\tfor(int j = 1; j <= W; j++)\n\t\t\t\tcin>>a[i][j];\n\t\t\n\t\tfor(int i = 1; i <= H; i++){\n\t\t\tfor(int j = 1; j <= W; j++){\n\t\t\t\t//if(temp[2][i][j])continue;\n\t\t\t\tif(a[i][j] == 'B') huga(i,j,0);\n\t\t\t\telse if(a[i][j] == 'W') huga(i,j,1);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 1; i <= H; i++){\n\t\t\tfor(int j = 1; j <= W; j++){\n\t\t\t\tif(a[i][j] == '.'){\n\t\t\t\t\tif(temp[0][i][j] && !temp[1][i][j])cb++;\n\t\t\t\t\telse if(!temp[0][i][j] && temp[1][i][j])cw++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout<<cb<<\" \"<<cw<<endl;\n\t}\n\t\n\t\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include<bits/stdc++.h> \nusing namespace std;\nusing ll=long long;\nusing P=pair<ll,ll>;\ntemplate<class T> using V=vector<T>; \n#define fi first\n#define se second\n#define all(v) (v).begin(),(v).end()\nconst ll inf=(1e18);\nconst ll mod=998244353;\n//const ll mod=1000000007;\nll GCD(ll a,ll b) {return b ? GCD(b,a%b):a;}\nll LCM(ll c,ll d){return c/GCD(c,d)*d;}\nstruct __INIT{__INIT(){cin.tie(0);ios::sync_with_stdio(false);cout<<fixed<<setprecision(15);}} __init;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\nint h,w;\nV<int> dy={0,-1,0,1},dx={-1,0,1,0};\nbool b_ok[55][55],w_ok[55][55];\nV<string> s;\nvoid dfs(int y,int x,char c){\n     for(int i=0;i<4;i++){\n         int ny=dy[i]+y,nx=dx[i]+x;\n         if(ny<0||ny>=h||nx<0||nx>=w)continue;\n         if(s[ny][nx]!='.')continue;\n         if(c=='W'&&w_ok[ny][nx])continue;\n         if(c=='B'&&b_ok[ny][nx])continue;\n         if(c=='W')w_ok[ny][nx]=true;\n         if(c=='B')b_ok[ny][nx]=true;\n         dfs(ny,nx,c);\n     }\n}\nint main(){\n    while(1){\n        cin>>w>>h;\n        if(h==0||w==0)return 0;\n        s=V<string>(h);\n        for(int i=0;i<h;i++)cin>>s[i];\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                w_ok[i][j]=false;\n                b_ok[i][j]=false;\n            }\n        }\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                if(s[i][j]=='B'){\n                    dfs(i,j,'B');\n                }\n                if(s[i][j]=='W'){\n                  dfs(i,j,'W');\n                }\n            }\n        }\n        int B=0,W=0;\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                if(s[i][j]!='.')continue;\n                if(w_ok[i][j]&&b_ok[i][j])continue;\n                if(w_ok[i][j])W++;\n                if(b_ok[i][j])B++;\n            }\n        }\n        cout<<B<<\" \"<<W<<\"\\n\";\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*** ??????????? ***/\n\n#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i, n) for(int i=0; i<n; ++i)\nint dx[4]={1, 0, -1, 0};\nint dy[4]={0, -1, 0, 1};\n\nvoid check(int x, int y, int w, int h, char lattice[][50], bool lat[][50]){\n\tREP(i, 4){\n\t\tint xx=x+dx[i], yy=y+dy[i];\n\t\tif(xx>=0 && xx<w && yy>=0 && yy<h && lattice[yy][xx]=='.' && !lat[yy][xx]){\n\t\t\tlat[yy][xx]=true;\n\t\t\tcheck(xx, yy, w, h, lattice, lat);\n\t\t}\n\t}\n}\n\nint main(){\n\tint w, h;\n\tint i, j;\n\t\n\tcin >> w >> h;\n\twhile(w || h){\n\t\tchar lattice[50][50]={};\n\t\tbool lat_b[50][50]={};\n\t\tbool lat_w[50][50]={};\n\t\t\n\t\tREP(j, h){\n\t\t\tREP(i, w){\n\t\t\t\tcin >> lattice[j][i];\n\t\t\t}\n\t\t}\n\t\t\n\t\tREP(j, h){\n\t\t\tREP(i, w){\n\t\t\t\tif(lattice[j][i]=='B') check(i, j, w, h, lattice, lat_b);\n\t\t\t\telse if (lattice[j][i]=='W') check(i, j, w, h, lattice, lat_w);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint black=0, white=0;\n\t\tREP(j, h){\n\t\t\tREP(i, w){\n\t\t\t\tif(lat_b[j][i] && !lat_w[j][i]) ++black;\n\t\t\t\telse if(!lat_b[j][i] && lat_w[j][i]) ++white;\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << black << \" \" << white << endl;\n\t\t\n\t\tcin >> w >> h;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,b,e) for(int i=(b);i<(e);++i)\n#define rep(i,e) for(int i=0;i<(e);++i)\n\nint w, h;\nchar a[50][50];\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {1, 0, -1, 0};\n\ntuple<int, int, int> dfs(int y, int x){\n  if(a[y][x]=='.') a[y][x]='#';\n  int res=1, wcnt=0, bcnt=0;\n  int rest, bct, wct;\n\n  rep(i,4){\n    int nx = x+dx[i], ny = y+dy[i];\n\n    if(0<=nx and nx<w and 0<=ny and ny<h and a[ny][nx]!='#'){\n      if(a[ny][nx]=='.'){\n        tie(wct, bct, rest) = dfs(ny, nx);\n        wcnt += wct;\n        bcnt += bct;\n        res += rest;\n      }\n      else if(a[ny][nx]=='W') wcnt += 1;\n      else if(a[ny][nx]=='B') bcnt += 1;\n    }\n  }\n  return forward_as_tuple(wcnt, bcnt, res);\n}\n\nint main() {\n  int wcnt, bcnt, res;\n  while(true){\n    cin>>w>>h;\n    if(w==0) break;\n\n    int bans=0, wans=0;\n\n    rep(i,h)rep(j,w){\n      cin>>a[i][j];\n    }\n    rep(i,h)rep(j,w){\n      if(a[i][j]=='.'){\n        tie(wcnt, bcnt, res) = dfs(i,j);\n        //cout<<i<<\" \"<<j<<\" \"<<bcnt<<\" \"<<wcnt<<\" \"<<res<<\" \"<<endl;\n        if(wcnt>0 and bcnt==0) wans += res;\n        else if(wcnt==0 and bcnt>0) bans += res;\n      }\n    }\n    cout<<bans<<\" \"<<wans<<endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"vector\"\n#include \"string\"\n#include \"queue\"\n#include \"cstring\"\nusing namespace std;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint main(void)\n{\n\tint w,h;\n\twhile (cin>>w>>h,w) {\n\t\tbool black[h][w],white[h][w];\n\t\tmemset(black,0,sizeof(black));\n\t\tmemset(white,0,sizeof(white));\n\t\tvector<string> in;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tstring t; cin>>t;\n\t\t\tin.push_back(t);\n\t\t}\n\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tint f=0;\n\t\t\t\tif(in[i][j]=='W') f=1;\n\t\t\t\telse if(in[i][j]=='B') f=2;\n\n\t\t\t\tif(in[i][j]!='.')\n\t\t\t\t{\n\t\t\t\t\tbool used[h][w];\n\t\t\t\t\tmemset(used,0,sizeof(used));\n\t\t\t\t\tqueue<int> xs,ys;\n\t\t\t\t\txs.push(j); ys.push(i);\n\t\t\t\t\twhile (!xs.empty()) {\n\t\t\t\t\t\tint x=xs.front(),y=ys.front();\n\t\t\t\t\t\txs.pop(); ys.pop();\n\t\t\t\t\t\tused[y][x]=true;\n\t\t\t\t\t\tif(f==1) white[y][x]=true;\n\t\t\t\t\t\telse black[y][x]=true;\n\t\t\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\t\t\tint nx=x+dx[k],ny=y+dy[k];\n\t\t\t\t\t\t\tif(0<=nx&&nx<w&&0<=ny&&ny<h&&!used[ny][nx]&&in[ny][nx]=='.')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\txs.push(nx); ys.push(ny);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint Black=0,White=0;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif(in[i][j]!='B'&&black[i][j]&&!white[i][j]) Black++;\n\t\t\t\telse if(in[i][j]!='W'&&!black[i][j]&&white[i][j]) White++;\n\t\t\t}\n\t\t}\n\t\tcout<<Black<<\" \"<<White<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint dx[4] = {-1,1,0,0};\nint dy[4] = {0,0,-1,1};\nint w,h;\n\ntypedef pair<int,int> pii;\ntypedef vector<vector<int> > vvi;\n\n\nint dfs(int yi, int xi, vvi& used, vector<string>& m){\n\n  stack<pii> st;\n  st.push(pii(yi,xi));\n\n  int size = 0;\n  set<char> flag;\n  while(st.size()){\n    int y = st.top().first;\n    int x = st.top().second;\n    st.pop();\n    if(used[y][x] == 1) continue;\n    used[y][x] = 1; size ++;\n    \n    for(int i=0; i<4; i++){\n      int ny = y + dy[i];\n      int nx = x + dx[i];\n\n      if(ny >= h || ny < 0 || nx >= w || nx < 0){ // ?????\n\tcontinue;\n      }\n      else if(m[ny][nx] == 'B' || m[ny][nx] == 'W'){ // ???\n\tflag.insert(m[ny][nx]);\n\tcontinue;\n      }\n      else if( used[ny][nx] == 1 ){ // ?????????\n\tcontinue;\n      }\n      else if(m[ny][nx] == '.'){ // ?????????\n\tst.push(pii(ny,nx));\n      }\n    }\n  }\n  if( flag.size() == 2 || flag.size() == 0) return 0;\n  if( *flag.begin() == 'W') return size*(-1);\n  return size;\n\n}\n\n\nint main(){\n\n  while(1){\n    cin >> w >> h;\n    if(!w and !h) break;\n\n    vector<string> m(h);\n    for(int j=0; j<h; j++)\n      cin >> m[j];\n\n    \n    int bl=0,wh=0;\n    vvi used(h,vector<int>(w,0));\n    for(int j=0; j<h; j++){\n      for(int i=0; i<w; i++){\n\tif( m[j][i] == '.' and used[j][i] == 0 ){\n\t  int x = dfs(j,i,used,m);\n\t  if(x > 0){\n\t    bl += x;\n\t  }\n\t  if(x < 0){\n\t    wh -= x;\n\t  }\n\t}\n      }\n    }\n    cout << bl << \" \" << wh << endl;\n  }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include <set>\n#include <cctype>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\nusing namespace std;\n#define INF 100000000\n#define MAXH 64\n#define MAXW 64\n \ntypedef long long ll;\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\n \nchar a[MAXH][MAXW];\nint w, h;\nqueue<int> X, Y;\n \nint main(void) {\n    while (1) {\n        cin >> w >> h;\n        if (w == 0 && h == 0) break;\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                cin >> a[i][j];\n            }\n        }\n        int white = 0, black = 0;\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                if (a[i][j] != '.') continue;\n                bool used[MAXH][MAXW];\n                for (int k = 0; k < h; k++) {\n                    for (int l = 0; l < w; l++) {\n                        used[k][l] = false;\n                    }\n                }\n                X.push(j); Y.push(i);\n                bool white_flag = false, black_flag = false;\n                while (!X.empty()) {\n                    int x = X.front(); X.pop();\n                    int y = Y.front(); Y.pop();\n                    used[y][x] = true;\n                    for (int k = 0; k < 4; k++) {\n                        int nx = x + dx[k];\n                        int ny = y + dy[k];\n                        if (0 <= nx && nx < w && 0 <= ny && ny < h) {\n                            if (a[ny][nx] == 'W') white_flag = true;\n                            else if (a[ny][nx] == 'B') black_flag = true;\n                            else if (!used[ny][nx]) {\n                                X.push(nx);\n                                Y.push(ny);\n                            }\n                        }\n                    }\n                }\n                if (white_flag && !black_flag) white++;\n                if (!white_flag && black_flag) black++;\n            }\n        }\n        cout << black << \" \" << white << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define ALL(a) (a).begin(), (a).end()\n#define llong long long\n\n\nusing namespace std;\nusing ARRAY = vector<pair<int,int>>;\nusing field = vector<ARRAY>;\n\nint dx[] = {0,-1,1,0};\nint dy[] = {1,0,0,-1};\n\nvoid dfs(field &m, size_t h, size_t w, bool isBlack){\n\tfor(size_t i = 0; i < 4; i++){\n\t\tint nexth = h+dx[i];\n\t\tint nextw = w+dy[i];\n\t\tauto &tmp = m[nexth][nextw];\n\t\tif(tmp == make_pair(-1,-1))continue;\n\t\tif(isBlack){\n\t\t\tif(tmp.first == 0 && tmp.second != 2){\n\t\t\t\ttmp = {1, tmp.second};\n\t\t\t\tdfs(m, nexth, nextw, true);\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(tmp.second== 0 && tmp.first != 2){\n\t\t\t\ttmp = {tmp.first, 1};\n\t\t\t\tdfs(m, nexth, nextw, false);\n\t\t\t}\n\t\t}\n\t}\n}\n\nsigned main(){\n\twhile(true){\n\t\tint h,w; cin >> w >> h;\n\t\tif(h == 0)break;\n\t\tfield m(h+2, ARRAY(w+2));\n\t\tfor(int i = 0; i < h+2; i++){\n\t\t\tm[i][0] = {-1,-1};\n\t\t\tm[i][w+1] = {-1,-1};\n\t\t}\n\t\tfor(int i = 0; i < w+2; i++){\n\t\t\tm[0][i] = {-1,-1};\n\t\t\tm[h+1][i] = {-1,-1};\n\t\t}\n\t\tfor(int i = 1; i <= h; i++){\n\t\t\tfor(int j = 1; j <= w; j++){\n\t\t\t\tchar t; cin >> t;\n\t\t\t\tswitch(t){\n\t\t\t\t\tcase 'B':\n\t\t\t\t\t\tm[i][j] = {2,0};\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'W':\n\t\t\t\t\t\tm[i][j] = {0,2};\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 1; i <= h; i++)for(int j = 1; j <= w; j++){\n\t\t\tif(m[i][j] == make_pair(2,0)){\n\t\t\t\tdfs(m,i,j,true);\n\t\t\t}\n\t\t\telse if(m[i][j] == make_pair(0,2)){\n\t\t\t\tdfs(m,i,j,false);\n\t\t\t}\n\t\t}\n\t\tpair<int, int> ans{0,0};\n\t\tfor(auto a : m)for(auto e : a){\n\t\t\tif(e.second == 0 && e.first == 1)ans.first++;\n\t\t\telse if(e.first == 0 && e.second == 1)ans.second++;\n\t\t}\n\t\tcout << ans.first << \" \" << ans.second << endl;\n\t}\n\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#define Black 1\n#define White 2\n#define Double 3\nusing namespace std;\n\nchar map[50][50];\nint acs[50][50]={0};\nint w,h;\nint dxy[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\n\nvoid dfs(int y,int x,int type){\n  if(0<=y && y<h && 0<=x && x<w){\n    if(map[y][x]=='.' && (acs[y][x]&type)!=type){\n      acs[y][x]+=type;\n      for(int k=0;k<4;k++){\n\tdfs(y+dxy[k][1],x+dxy[k][0],type);\n      }\n    }\n  }\n}\n\nint main(){\n  while(cin>>w>>h,w){\n    memset(map,'.',sizeof(map));\n    memset(acs,0,sizeof(acs));\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin>>map[i][j];\n\tif(map[i][j]!='.') acs[i][j]=Double;\n      }\n    }\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tif(map[i][j]=='B'){\n\t  //\t  acs[i][j]=Double;\n\t  for(int k=0;k<4;k++){\n\t    dfs(i+dxy[k][1],j+dxy[k][0],Black);\n\t  }\n\t}else if(map[i][j]=='W'){\n\t  //acs[i][j]=Double;\n\t  for(int k=0;k<4;k++){\n\t    dfs(i+dxy[k][1],j+dxy[k][0],White);\n\t  }\n\t}\n      }\n    }\n    int black=0;\n    int white=0;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tif(acs[i][j]==Black){\n\t  black++;\n\t}else if(acs[i][j]==White){\n\t  white++;\n\t}\n      }\n    }\n    cout<<black<<\" \"<<white<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\n\nusing namespace std;\n\nint w,h;\nchar field[50][50];\nbool check[50][50];\nint dx[] = {-1,0,1,0},dy[] = {0,-1,0,1};\nint sum = 0;\nbool black = false,white = false;\n\nvoid bfs(int x,int y);\n\nint main(){\n\twhile(true){\n\t\tcin >> w >> h;\n\t\tif(w == 0 && h == 0) break;\n\t\tmemset(field,0,sizeof(field));\n\t\tmemset(check,0,sizeof(check));\n\t\t\n\t\tfor(int i = 0;i < h;i++){\n\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\tcin >> field[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tint b_sum = 0,w_sum = 0;\n\t\tfor(int i = 0;i < h;i++){\n\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\tsum = 0;\n\t\t\t\tblack = false;\n\t\t\t\twhite = false;\n\t\t\t\tif(check[i][j] == false && field[i][j] == '.'){\n\t\t\t\t\tbfs(j,i);\n\t\t\t\t}\n\t\t\t\tif(black && !white){\n\t\t\t\t\tb_sum += sum;\n\t\t\t\t}else if(!black && white){\n\t\t\t\t\tw_sum += sum;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << b_sum << \" \" << w_sum << endl;\n\t}\n\treturn 0;\n}\n\nvoid bfs(int x,int y){\n\tcheck[y][x] = true;\n\tsum++;\n\tfor(int i = 0;i < 4;i++){\n\t\tif(0 <= x + dx[i] && x + dx[i] < w && 0 <= y + dy[i] && y + dy[i] < h){\n\t\t\tif(field[y + dy[i]][x + dx[i]] == 'B'){\n\t\t\t\tblack = true;\n\t\t\t}else if(field[y + dy[i]][x + dx[i]] == 'W'){\n\t\t\t\twhite = true;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0;i < 4;i++){\n\t\tif(0 <= x + dx[i] && x + dx[i] < w && 0 <= y + dy[i] && y + dy[i] < h && check[y + dy[i]][x + dx[i]] == false && field[y + dy[i]][x + dx[i]] == '.'){\n\t\t\tbfs(x + dx[i],y + dy[i]);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<cassert>\n#include<cctype>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<functional>\n#include<limits>\n#include<list>\n#include<map>\n#include<numeric>\n#include<set>\n#include<stack>\n#include<string>\n#include<sstream>\n#include<queue>\n#include<vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\n\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n\n//xy???????????????????????\nvoid dfs(int x, int y) {\n\tstatic const int MAX_X = 1, MAX_Y = 1;\n\n\t/* ?????? */\n\n\t//?????4?????????????????????\n\tint dx[4] = { 1,0,-1,0 };\n\tint dy[4] = { 0,1,0,-1 };\n\t//?????4????????????\n\tfor (int i = 0; i < 4; i++) {\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\tif (0 <= nx&&nx < MAX_X && 0 <= ny&&ny < MAX_Y) {\n\t\t\tdfs(nx, ny);\n\t\t}\n\t}\n}\n\n//xy?????????????????????\n//???????????\nint bfs(int sx, int sy, int gx, int gy) {\n\tstatic const int MAX_X = 1, MAX_Y = 1;\n\n\tqueue<pii> Q;\n\tQ.push(pii(sx, sy));\n\n\t//???????????\n\tint d[MAX_X][MAX_Y];\n\tmemset(d, 0x3f, sizeof(d));\n\n\t//?????4?????????????????????\n\tint dx[4] = { 1,0,-1,0 };\n\tint dy[4] = { 0,1,0,-1 };\n\tfor (pii u; !Q.empty();) {\n\t\tu = Q.front(); Q.pop();\n\t\t//?????????????????????????????\n\t\tif (u == pii(gx, gy))break;\n\t\t//?????4????????????\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint nx = sx + dx[i], ny = sy + dy[i];\n\t\t\tif (0 <= nx&&nx < MAX_X && 0 <= ny&&ny < MAX_Y) {\n\t\t\t\t//????????????????\n\t\t\t\tif (d[nx][ny] != INF)continue;\n\t\t\t\td[nx][ny] = d[sx][sy] + 1;\n\t\t\t\tQ.push(pii(nx, ny));\n\t\t\t}\n\t\t}\n\t}\n\treturn d[gx][gy];\n}\n\n#define MAX 50\n\nint main() {\n\tchar a[MAX][MAX];\n\tchar b[MAX][MAX];\n\tfor (int w, h; cin >> w >> h&&w;) {\n\t\tmemset(a, 0, sizeof(a));\n\t\tmemset(b, 0, sizeof(b));\n\n\n\t\tfor (int y = 0; y < h; y++) {\n\t\t\tfor (int x = 0; x < w; x++) {\n\t\t\t\tcin >> a[x][y];\n\t\t\t\tb[x][y] = a[x][y];\n\t\t\t}\n\t\t}\n\n\t\tint B = 0, W = 0;\n\n\t\tfor (int x = 0; x < w; x++) {\n\t\t\tfor (int y = 0; y < h; y++) {\n\n\t\t\t\tif (a[x][y] == '.')continue;\n\n\t\t\t\tqueue<pii> Q;\n\t\t\t\tQ.push(pii(x, y));\n\n\t\t\t\t//?????4?????????????????????\n\t\t\t\tint dx[4] = { 1,0,-1,0 };\n\t\t\t\tint dy[4] = { 0,1,0,-1 };\n\t\t\t\tfor (pii u; !Q.empty();) {\n\t\t\t\t\tu = Q.front(); Q.pop();\n\t\t\t\t\t//?????4????????????\n\t\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\t\tint nx = u.first + dx[i], ny = u.second + dy[i];\n\t\t\t\t\t\tif (0 <= nx&&nx < w && 0 <= ny&&ny < h) {\n\t\t\t\t\t\t\t//W B ??????????????????\n\t\t\t\t\t\t\tif (a[nx][ny] != '.')continue;\n\n\t\t\t\t\t\t\t//?????? ?????? ???????\n\t\t\t\t\t\t\tif (b[nx][ny] == a[x][y]) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//??????\n\t\t\t\t\t\t\telse if (b[nx][ny] == '.') {\n\t\t\t\t\t\t\t\tb[nx][ny] = b[x][y];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t//?????? 0 ???????\n\t\t\t\t\t\t\telse if (b[nx][ny] == '0')\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t//?????? ?????\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tb[nx][ny] = '0';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tQ.push(pii(nx, ny));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int y = 0; y < h; y++) {\n\t\t\tfor (int x = 0; x < w; x++) {\n\t\t\t\t//cerr << b[x][y];\n\t\t\t\tif (a[x][y] == '.') {\n\t\t\t\t\tif (b[x][y] == 'B')B++;\n\t\t\t\t\tif (b[x][y] == 'W')W++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cerr << endl;\n\t\t}\n\t\tcout << B << \" \" << W << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\nusing namespace std;\ntypedef pair<int ,int> P;\nchar grid[50][50];\nint W,H;\nint dx[] = {0,0,1,-1},dy[] = {1,-1,0,0};\nchar c[2] = {'B','W'};\n/*void p(){\n  for(int i = 0 ; i < H ; i++ ){\n    for(int j = 0 ; j < W ; j++ ){\n      cout << grid[j][i];\n    }\n    cout << endl;\n  }\n  }*/\nint bfs(int sx,int sy,int k){\n  queue<P> que;\n  int res[2] = {0};\n  bool flag = true;\n  que.push(P(sx,sy));\n  while(!que.empty()){\n    P p = que.front();\n    que.pop(); \n\n    if(grid[p.first][p.second] == '.'){\n      grid[p.first][p.second] = c[k];\n      res[k]++;\n    } \n\n    for(int i = 0 ; i < 4 ; i++ ){\n      int nx = p.first + dx[i],ny = p.second + dy[i];\n      if(0 <= nx && nx < W && 0 <= ny && ny < H && grid[nx][ny] == '.'){\n\tque.push(P(nx,ny));\n\tif((nx+1 < W && grid[nx+1][ny] == c[!k])||\n\t   (nx-1 >= 0 && grid[nx-1][ny] == c[!k])||\n\t   (ny+1 < H && grid[nx][ny+1] == c[!k])||\n\t   (ny-1 >= 0 && grid[nx][ny-1] == c[!k]))flag = false;\n      }\n    }\n  }\n  if(flag == true)return res[k];\n  else return 0; \n}\n\nint main(){\n  while( cin >> W >> H , W+H ){\n\n    for(int i = 0 ; i < H ; i++ ){\n      for(int j = 0 ; j < W ; j++ ){\n\tcin >> grid[j][i];\n      }\n    }\n    int ans[2] = {0};\n    for(int k = 0 ; k < 2 ; k++ ){\n      for(int i = 0 ; i < H ; i++ ){\n\tfor(int j = 0 ; j < W ; j++ ){\n\t  if(grid[j][i] == '.'){\n\t    if((j+1 < W && grid[j+1][i] == c[k])||\n\t       (j-1 >= 0 && grid[j-1][i] == c[k])||\n\t       (i+1 < H && grid[j][i+1] == c[k])||\n\t       (i-1 >= 0 && grid[j][i-1] == c[k]))ans[k]+=bfs(j,i,k);//p();\n\t  }\n\t}\n      }\n    }\n    cout << ans[0] <<\" \"<< ans[1] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nchar field[50][50];\nbool used[50][50];\nint height, width;\nint b_count, w_count;\nbool b, w;\n\nint dx[] = {\n\t1, 0, -1, 0\n};\nint dy[] = {\n\t0, 1, 0, -1\n};\n\nint move(int i, int j){\n\tint count = 1;\n\tused[i][j] = true;\n\tfor(int k = 0; k < 4; k++){\n\t\tif(i+dy[k] >= 0 && i+dy[k] < height &&\n\t\t   j+dx[k] >= 0 && j+dx[k] < width)\n\t\t{\n\t\t\tint i2 = i+dy[k], j2 = j+dx[k];\n\t\t\tif(field[i2][j2] == '.'){\n\t\t\t\tif(!used[i2][j2]) count += move(i2, j2);\n\t\t\t}else if(field[i2][j2] == 'B'){\n\t\t\t\tb = true;\n\t\t\t}else{\n\t\t\t\tw = true;\n\t\t\t}\n\t\t}\n\t}\n\treturn count;\n}\n\t\n\nint main(){\n\twhile(cin >> width >> height && (width || height)){\n\t\tfor(int i = 0; i < height; i++){\n\t\t\tfor(int j = 0; j < width; j++){\n\t\t\t\tcin >> field[i][j];\n\t\t\t\tused[i][j] = false;\n\t\t\t}\n\t\t}\n\t\tb_count = 0;\n\t\tw_count = 0;\n\t\tfor(int i = 0; i < height; i++){\n\t\t\tfor(int j = 0; j < width; j++){\n\t\t\t\tif(field[i][j] == '.' && !used[i][j]){\n\t\t\t\t\tb = false;\n\t\t\t\t\tw = false;\n\t\t\t\t\tint count = move(i, j);\n\t\t\t\t\tif(b && !w){\n\t\t\t\t\t\tb_count += count;\n\t\t\t\t\t}else if(w && !b){\n\t\t\t\t\t\tw_count += count;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << b_count << \" \" << w_count << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define REP(i, a, n) for(int i = (a); i < (n); i++)\nusing namespace std;\n\nint W, H;\nchar A[80][80];\nint dd[5] = { 0, 1, 0, -1, 0 };\nbool v[80][80], s[2][80][80];\n\nbool isin(int y, int x) { return 0 <= y && y < H && 0 <= x && x < W; }\n\nvoid dfs(int y, int x, int c) {\n  if(v[y][x] || A[y][x] != '.') return;\n  v[y][x] = true;\n  s[c][y][x] = true;\n  REP(i, 0, 4) if(isin(y + dd[i], x + dd[i + 1])) dfs(y + dd[i], x + dd[i + 1], c);\n}\n\nint main(void) {\n  while(cin >> W >> H, W || H) {\n    REP(i, 0, H) cin >> A[i];\n\n    REP(i, 0, 2) REP(j, 0, H) REP(k, 0, W) s[i][j][k] = false;\n    REP(i, 0, H) REP(j, 0, W) if(A[i][j] != '.') {\n      REP(k, 0, 4) if(isin(i + dd[k], j + dd[k + 1])) {\n        REP(l, 0, H) REP(m, 0, W) v[l][m] = false;\n        dfs(i + dd[k], j + dd[k + 1], A[i][j] == 'W');\n      }\n    }\n\n    int ans[2] = { 0, 0 };\n    REP(i, 0, 2) REP(j, 0, H) REP(k, 0, W) if(s[i][j][k] && !s[1 - i][j][k]) ans[i]++;\n    cout << ans[0] << \" \" << ans[1] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int mod=1000000007;\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define FOR(i,a,b) for(int i = (a); i < (b); i++)\nclass Solve {\nprivate:\npublic:\n    bool is_last_;\n    Solve()\n    {\n        \n        int h,w;\n        int dx[4]={0,1,0,-1};\n        int dy[4]={1,0,-1,0};\n        cin >> w>>h;\n        if (h == 0)\n        {\n            is_last_ = true;\n            return;\n        }\n        vector<vector<int>> b=vector<vector<int>> (h+2,vector<int>(w+2,mod));\n        queue<array<int,3>> q;\n        FOR(i,0,h){\n            string s;\n            cin>>s;\n            FOR(j,0,w){\n                if(s[j]=='.'){\n                    b[i+1][j+1]=0;\n                }else if(s[j]=='B'){\n                    q.push({i+1,j+1,1});\n                }else if(s[j]=='W'){\n                    q.push({i+1,j+1,2});\n                }   \n            }\n        }\n        //cerr<<\"test\"<<endl;\n        while(q.size()){\n            auto tpl=q.front();\n            q.pop();\n            FOR(d,0,4){\n                int ni=tpl[0]+dx[d];\n                int nj=tpl[1]+dy[d];\n                int c=tpl[2];\n                if(b[ni][nj]>5)continue;\n                if(b[ni][nj]&c)continue;\n                b[ni][nj]|=c;\n                q.push({ni,nj,c});\n            }\n        }\n        vector<int> v(3,0);\n        FOR(i,1,h+1){\n            FOR(j,1,w+1){\n                if(b[i][j]==1)v[1]++;\n                if(b[i][j]==2)v[2]++;\n            }\n        }\n        cout<<v[1]<<\" \"<<v[2]<<endl;\n    }\n};\n\nint main()\n{\n    while (!Solve().is_last_);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n\nusing namespace std;\n\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {-1, 0, 1, 0};\n\nint W, H;\nstring land[51];\npair<bool, bool> check[51][51]; // Black, White\n\nvoid dfs(int x, int y, char ch)\n{\n    if (ch == 'B' && check[y][x].first)\n        return;\n    else if (ch == 'W' && check[y][x].second)\n        return;\n\n    if (land[y][x] == '.') {\n        if (ch == 'B')\n            check[y][x].first = true;\n        else if (ch == 'W')\n            check[y][x].second = true;\n    }\n\n    for (int i = 0; i < 4; i++) {\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n\n        if (nx < 0 || ny < 0)\n            continue;\n        if (nx >= W || ny >= H)\n            continue;\n        if (land[ny][nx] == '.')\n            dfs(nx, ny, ch);\n    }\n}\n\n\nint main()\n{\n    while (cin >> W >> H, W && H) {\n        // Input\n        for (int y = 0; y < H; y++) {\n            cin >> land[y];\n            for (int x = 0; x < W; x++) {\n                check[y][x].first = false;\n                check[y][x].second = false;                \n            }\n        }\n\n        for (int y = 0; y < H; y++) {\n            for (int x = 0; x < W; x++) {\n                if (land[y][x] == 'B')\n                    dfs(x, y, 'B');\n                else if (land[y][x] == 'W')\n                    dfs(x, y, 'W');\n            }\n        }\n\n        int ab, aw;\n        ab = aw = 0;\n        for (int y = 0; y < H; y++)\n            for (int x = 0; x < W; x++) {\n                if (!check[y][x].first || !check[y][x].second) {\n                    if (check[y][x].first)\n                        ab++;\n                    else if (check[y][x].second)\n                        aw++;\n                }\n            }\n        \n        cout << ab << \" \" << aw << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<map>\n#include<set>\n#include<list>\n#include<iomanip>\n#include<vector>\n#include<random>\n#include<functional>\n#include<algorithm>\n#include<cstdio>\n#include<unordered_map>\nusing namespace std;\n//---------------------------------------------------\n//\ntypedef long long ll;\ntypedef long double ld;\n#define str string\n#define rep(i,j) for(ll i=0;i<(long long)(j);i++)\nconst ll Mod = 1000000007;\nconst ll gosenchou = 5000000000000000;\nshort gh[2][4] = { { 0,0,-1,1 },{ -1,1,0,0 } };\nstruct P {\n\tll pos, cost;\n};\nbool operator<(P a, P b) { return a.cost < b.cost; }\nbool operator>(P a, P b) { return a.cost > b.cost; }\nstruct B {//\n\tll to;\n\tld cost;\n};\nstruct E {//\n\tll from, to, cost;\n};\nbool operator<(E a, E b) {\n\treturn a.cost < b.cost;\n}\nstruct H {\n\tll x, y;\n};\nbool operator<(H a, H b) {\n\tif (a.x != b.x) return a.x < b.x;\n\treturn a.y < b.y;\n}\nbool operator>(H a, H b) {\n\tif (a.x != b.x) return a.x > b.x;\n\treturn a.y > b.y;\n}\nbool operator==(H a, H b) {\n\treturn a.x == b.x&&a.y == b.y;\n}\nbool operator!=(H a, H b) {\n\treturn a.x != b.x || a.y != b.y;\n}\nll gcm(ll i, ll j) {//\n\tif (i > j) swap(i, j);\n\tif (i == 0) return j;\n\treturn gcm(j%i, i);\n}\nld rad(H a, H b) {\n\treturn sqrt(pow(a.x - b.x, 2.0) + pow(a.y - b.y, 2.0));\n}//rad2\nll ari(ll a, ll b, ll c) {\n\treturn (a + b)*c / 2;\n}//\nbool suf(ld a, ld b, ld c, ld d) {\n\tif (b <= c || d <= a) return 0;\n\treturn 1;\n}//[a,b),[c,d)\nll fact(ll x, ll k,ll p) {//\n\tll sum = 1;\n\tfor (int i = 0; i < k; i++) {\n\t\tsum *= (x--);\n\t\tsum %= p;\n\t}\n\treturn sum;\n}//(\nll mod_pow(ll x, ll n, ll p) {\n\tll res = 1;\n\twhile (n > 0) {\n\t\tif (n & 1) res = res*x%p;\n\t\tx = x*x%p;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}//x^n%p\n#define int long long\nconst long long inf = 4523372036854775807;\nconst int iinf = 1500000000;\n//----------------------------------------------------\n//++++++++++++++++++++++++++++++++++++++++++++++++++++\nint w, h;\nchar a[50][50];\nbool c[50][50], d[50][50];\nsigned main() {\n\twhile (cin >> w >> h&&w + h > 0) {\n\t\tint ans1 = 0, ans2 = 0;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\ta[i][j] = s[j];\n\t\t\t\tc[i][j] = 0;\n\t\t\t\td[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (a[i][j] != 'B'&&a[i][j] != 'W'&&!c[i][j]) {\n\t\t\t\t\tqueue<H>q;\n\t\t\t\t\tq.push(H{ i,j });\n\t\t\t\t\tbool B = 0, W = 0;\n\t\t\t\t\twhile (!q.empty()) {\n\t\t\t\t\t\tH t = q.front(); q.pop();\n\t\t\t\t\t\tif (a[t.x][t.y] == 'B') {\n\t\t\t\t\t\t\tB = 1; continue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (a[t.x][t.y] == 'W') {\n\t\t\t\t\t\t\tW = 1; continue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (c[t.x][t.y]) continue;\n\t\t\t\t\t\tc[t.x][t.y] = 1;\n\t\t\t\t\t\tif (t.x > 0)\n\t\t\t\t\t\t\tq.push(H{ t.x - 1,t.y });\n\t\t\t\t\t\tif (t.x < h - 1)\n\t\t\t\t\t\t\tq.push(H{ t.x + 1,t.y });\n\t\t\t\t\t\tif (t.y > 0)\n\t\t\t\t\t\t\tq.push(H{ t.x,t.y - 1 });\n\t\t\t\t\t\tif (t.y < w - 1)\n\t\t\t\t\t\t\tq.push(H{ t.x,t.y + 1 });\n\t\t\t\t\t}\n\t\t\t\t\tif (B != W) {\n\t\t\t\t\t\tq.push(H{ i,j });\n\t\t\t\t\t\twhile (!q.empty()) {\n\t\t\t\t\t\t\tH t = q.front(); q.pop();\n\t\t\t\t\t\t\tif (a[t.x][t.y] == 'B') {\n\t\t\t\t\t\t\t\tB = 1; continue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (a[t.x][t.y] == 'W') {\n\t\t\t\t\t\t\t\tW = 1; continue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (d[t.x][t.y]) continue;\n\t\t\t\t\t\t\td[t.x][t.y] = 1;\n\t\t\t\t\t\t\tif (B) ans1++;\n\t\t\t\t\t\t\telse ans2++;\n\t\t\t\t\t\t\tif (t.x > 0)\n\t\t\t\t\t\t\t\tq.push(H{ t.x - 1,t.y });\n\t\t\t\t\t\t\tif (t.x < h - 1)\n\t\t\t\t\t\t\t\tq.push(H{ t.x + 1,t.y });\n\t\t\t\t\t\t\tif (t.y > 0)\n\t\t\t\t\t\t\t\tq.push(H{ t.x,t.y - 1 });\n\t\t\t\t\t\t\tif (t.y < w - 1)\n\t\t\t\t\t\t\t\tq.push(H{ t.x,t.y + 1 });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans1 << \" \" << ans2 << endl;\n\t}\n\tgetchar(); getchar();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <numeric>\n#include <functional>\n#include <cctype>\n#include <list>\n#include <limits>\n#include <cassert>\n//#include <boost/multiprecision/cpp_int.hpp>\n\nconst double EPS = (1e-10);\n\n\nusing namespace std;\nusing Int = long long;\n//using namespace boost::multiprecision;\n\nconst Int MOD = 1000000007;\n\nvoid fast_input() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n}\n\nint dfs(char color, char enemyColor, vector<vector<char>> &field, vector<vector<int>> &cells, vector<pair<int, int>> &st, int y, int x) {\n    st.push_back({y, x});\n    cells[y][x] = 0;\n    int dx[] = {0, 1, 0, -1};\n    int dy[] = {1, 0, -1, 0};\n\n    int ret = 2;\n    for (int i = 0; i < 4; i++) {\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n        if (field[ny][nx] == enemyColor) {\n            ret = 0;\n        }\n        if (field[ny][nx] == '.' && cells[ny][nx] == -1) {\n            ret = min(dfs(color, enemyColor, field, cells, st, ny, nx), ret);\n        }\n        if (field[ny][nx] == color) {\n            ret = min(ret, 1);\n        }\n    }\n    return ret;\n}\n\npair<int, int> solve(int W, int H) {\n    int ansBlack = 0;\n    int ansWhite = 0;\n    vector<vector<char>> field(H+2, vector<char>(W+2, '#'));\n    for (int i = 1; i <= H; i++) {\n        for (int j = 1; j <= W; j++) {\n            cin >> field[i][j];\n        }\n    }\n\n    vector<vector<int>> blackCells(H+2, vector<int>(W+2, -1));\n    for (int i = 1; i <= H; i++) {\n        for (int j = 1; j <= W; j++) {\n            if (blackCells[i][j] == -1 && field[i][j] == '.') {\n                vector<pair<int, int>> st;\n                int flag = dfs('B', 'W', field, blackCells, st, i, j);\n                for (auto &p : st) {\n                    blackCells[p.first][p.second] = flag;\n                }\n            }\n        }\n    }\n\n    vector<vector<int>> whiteCells(H+2, vector<int>(W+2, -1));\n    for (int i = 1; i <= H; i++) {\n        for (int j = 1; j <= W; j++) {\n            if (whiteCells[i][j] == -1 && field[i][j] == '.') {\n                vector<pair<int, int>> st;\n                int flag = dfs('W', 'B', field, whiteCells, st, i, j);\n                for (auto &p : st) {\n                    whiteCells[p.first][p.second] = flag;\n                }\n            }\n        }\n    }\n\n    for (int i = 1; i <= H; i++) {\n        for (int j = 1; j <= W; j++) {\n            if (blackCells[i][j] == 1) {\n                ansBlack++;\n            }\n        }\n    }\n    for (int i = 1; i <= H; i++) {\n        for (int j = 1; j <= W; j++) {\n            if (whiteCells[i][j] == 1) {\n                ansWhite++;\n            }\n        }\n    }\n    return {ansBlack, ansWhite};\n}\n\nint main(void) {\n    int W, H;\n    vector<pair<int, int>> ans;\n    while (1) {\n        cin >> W >> H;\n        if (!W && !H) break;\n        ans.push_back(solve(W, H));\n    }\n    for (auto &i : ans) {\n        cout << i.first << \" \" << i.second << endl;\n    }\n}   \n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nint W, H; vector<string> M;\n\nconst vector<int> dx = { 0, 1, 0, -1 };\nconst vector<int> dy = { -1, 0, 1, 0 };\n\nint rec(int x, int y, vector<vector<bool> > ok)\n{\n\tif (M[y][x] == 'W')\n\t{\n\t\treturn 2;\n\t}\n\n\tif (M[y][x] == 'B')\n\t{\n\t\treturn 1;\n\t}\n\n\tint ret = 3;\n\n\tfor (int dir = 0; dir < 4; dir++)\n\t{\n\t\tint tx = x + dx[dir];\n\t\tint ty = y + dy[dir];\n\n\t\tif (0 <= tx && tx < W && 0 <= ty && ty < H && ok[ty][tx] == false)\n\t\t{\n\t\t\tvector<vector<bool> > ok2 = ok; ok2[ty][tx] = true;\n\n\t\t\tint c = c & rec(tx, ty, ok2);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint main()\n{\n\tint H, W;\n\n\twhile (true)\n\t{\n\t\tcin >> W >> H;\n\n\t\tif (W == 0 && H == 0) { break; }\n\n\t\tint b = 0, w = 0;\n\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tint c = rec(j, i, vector<vector<bool> >(H, vector<bool>(W, false)));\n\n\t\t\t\tb += c & 1;\n\t\t\t\tw += (c & 2) / 2;\n\t\t\t}\n\t\t}\n\n\t\tcout << b << ' ' << w << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <algorithm>\n#include <string>\n#include <stack>\n#include <queue>\n#include <set>\n#include <cstdio>\n#include <string.h>\n#include <sstream>\n#include <iomanip>\n#include <map>\nusing namespace std;\n\n#define REP(i, n) for(int i = 0; i < n; i++)\n#define RREP(i,n) for(int i=(n)-1;i>=0;i--)\n#define FOR(i, b, e) for(int i = b; i < e; i++)\n#define to_bit(i) static_cast< bitset<8> >(i)\n#define INF (1<<28)\n#define int(n) int n; cin >> n;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> VI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<long long, long long>PLL;\ntypedef queue<int> QI;\ntypedef priority_queue<int> maxpq;\ntypedef priority_queue<int, vector<int>, greater<int> > minpq;\n\nstruct edge{int to, cost;};\n\nvoid begin(){cin.tie(0); ios::sync_with_stdio(false);};\nint gcd(int a, int b){if(a%b==0){return(b);}else{return(gcd(b,a%b));}};\nint lcm(int m, int n){if((0 == m)||(0 == n)){return 0;} return ((m / gcd(m, n)) * n);};\nunsigned long long comb(long n, long m){if(n < m) return 0;\n    unsigned long long c = 1; m = (n - m < m ? n - m : m);\n    for(long ns = n - m + 1, ms = 1; ms <= m; ns ++, ms ++){c *= ns; c /= ms;} return c;};\nint quadratic(int a, int b, int c){return (int)(-b + sqrt(b*b - 4*a*c)) / 2*a;}\n\nvoid cp(int a1[], int a2[], int l){REP(i, l) a2[i] = a1[i];};\nvoid cp(string a1[], string a2[], int l){REP(i, l) a2[i] = a1[i];};\ndouble sq(double d){return d*d;};\nint sq(int i){return i*i;};\ndouble sqdist(int x1, int y1, int x2, int y2){\n    double dx = x1 - x2, dy = y1 - y2; return dx*dx + dy*dy;\n};\nbool inside(int y, int x, int h, int w){return 0 <= y && y <= (h-1) && 0 <= x && x <= (w-1);};\n\n\n// \nbool isCross(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4){\n    // \n    int m = (x2-x1)*(y4-y3)-(y2-y1)*(x4-x3);\n    if(m == 0) return false;\n    // 01\n    double r =(double)((y4-y3)*(x3-x1)-(x4-x3)*(y3-y1))/m;\n    double s =(double)((y2-y1)*(x3-x1)-(x2-x1)*(y3-y1))/m;\n    return (0 < r && r <= 1 && 0 < s && s <= 1);\n};\n\n//  AB CD \nint crossProdct(int ax, int ay, int bx, int by, int cx, int cy, int dx, int dy){\n    int abx = bx - ax; int aby = by - ay;\n    int cdx = dx - cx; int cdy = dy - cy;\n    return abx * cdy - cdx * aby;\n};\ndouble crossProdct(double ax, double ay, double bx, double by, double cx, double cy, double dx, double dy){\n    double abx = bx - ax; double aby = by - ay;\n    double cdx = dx - cx; double cdy = dy - cy;\n    return abx * cdy - cdx * aby;\n};\ndouble innerProduct(double ax, double ay, double bx, double by, double cx, double cy, double dx, double dy){\n    double abx = bx - ax; double aby = by - ay;\n    double cdx = dx - cx; double cdy = dy - cy;\n    return abx * cdx + aby * cdy;\n};\n\n//  ABCP\nbool inTriangle(int ax, int ay, int bx, int by, int cx, int cy, int px, int py){\n    int c1 = crossProdct(ax, ay, bx, by, bx, by, px, py);\n    int c2 = crossProdct(bx, by, cx, cy, cx, cy, px, py);\n    int c3 = crossProdct(cx, cy, ax, ay, ax, ay, px, py);\n    return (c1 > 0 && c2 > 0 && c3 > 0) || (c1 < 0 && c2 < 0 && c3 < 0);\n};\nbool inTriangle(double ax, double ay, double bx, double by, double cx, double cy, double px, double py){\n    double c1 = crossProdct(ax, ay, bx, by, bx, by, px, py);\n    double c2 = crossProdct(bx, by, cx, cy, cx, cy, px, py);\n    double c3 = crossProdct(cx, cy, ax, ay, ax, ay, px, py);\n    return (c1 > 0 && c2 > 0 && c3 > 0) || (c1 < 0 && c2 < 0 && c3 < 0);\n};\n\n// \nvoid circumcenter(double x1, double y1, double x2, double y2, double x3, double y3, double res[3]){\n    double xp1 = (y1-y3)*(y1*y1-y2*y2+x1*x1-x2*x2) - (y1-y2)*(y1*y1-y3*y3+x1*x1-x3*x3);\n    double xp2 = 2*(y1-y3)*(x1-x2)-2*(y1-y2)*(x1-x3);\n    res[0] = xp1/xp2;\n    double yp1 = (x1-x3)*(x1*x1-x2*x2+y1*y1-y2*y2) - (x1-x2)*(x1*x1-x3*x3+y1*y1-y3*y3);\n    double yp2 = 2*(x1-x3)*(y1-y2)-2*(x1-x2)*(y1-y3);\n    res[1] = yp1/yp2;\n    double r = (x3-res[0])*(x3-res[0])+(y3-res[1])*(y3-res[1]);\n    res[2] = sqrt(r);\n}\n\n// \nvoid cal(){\n    string week[7] = {\"Thursday\",\"Friday\",\"Saturday\",\"Sunday\",\"Monday\",\"Tuesday\",\"Wednesday\"};\n    int month[12] = {31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n    vector<string> cal[12];\n    int counter = 0;\n    REP(i, 12) REP(j, month[i]){\n            cal[i].push_back(week[counter%7]);\n            counter++;\n    }\n}\n\n\n\nclass BinaryIndexedTree{\npublic:\n    int n; vector<int> bit;\n    BinaryIndexedTree(int _n){\n        n = _n;\n        bit.resize(n+1,0);\n    }\n    int sum(int i){\n        int sum = 0;\n        while(i > 0){\n            sum += bit[i];\n            i -= i & -i;\n        }\n        return sum;\n    }\n    void add(int i, int v){\n        while(i <= n){\n            bit[i] += v;\n            i += i & -i;\n        }\n    }\n};\n\n\nclass UnionFindTree{\npublic:\n    vector<int> parent, rank;\n    int n;\n    std::set<int> set;\n    // \n    UnionFindTree(int _n){\n        n = _n;\n        for(int i = 0; i < n; i++){\n            parent.resize(n);\n            rank.resize(n);\n            parent[i] = i;\n            rank[i] = 0;\n        }\n    }\n    // \n    int find(int x){\n        if(parent[x] == x){\n            return x;\n        }else{\n            return parent[x] = find(parent[x]);\n        }\n    }\n    // xy\n    void unite(int x, int y){\n        x = find(x);\n        y = find(y);\n        if(x == y){\n            set.insert(x);\n            return;\n        }\n        if(rank[x] < rank[y]){\n            parent[x] = y;\n            set.erase(x);\n            set.insert(y);\n        }else{\n            parent[y] = x;\n            set.erase(y);\n            set.insert(x);\n            if(rank[x] == rank[y]) rank[x]++;\n        }\n    }\n    // xy\n    bool same(int x, int y){\n        return find(x) == find(y);\n    }\n    // \n    int count(){\n        return (int)set.size();\n    }\n};\n\n// \nvoid warshallFloyd(int graph[100][100], int graph_size){\n    for(int mid_node = 0; mid_node < graph_size; mid_node++)\n        for(int s_node = 0; s_node < graph_size; s_node++)\n            for(int g_node = 0; g_node < graph_size; g_node++)\n                if(s_node == g_node) graph[s_node][g_node] = 0;\n                else graph[s_node][g_node] = min(graph[s_node][g_node], graph[s_node][mid_node] + graph[mid_node][g_node]);\n};\n\n\n// d:  n:  s:  dist:\nvoid dijkstra(int graph[1000][1000], int node_count, int start_node, int distances[1000]){\n    // -1\n    REP(i, node_count) distances[i] = -1;\n    distances[start_node] = 0;\n    // pair<int,int> int\n    priority_queue<PII, vector<PII>, greater<PII> > dijkstra_pq;\n    dijkstra_pq.push(PII(0, start_node));\n    while (!dijkstra_pq.empty()) {\n        PII p = dijkstra_pq.top(); dijkstra_pq.pop();\n        int i = p.second;\n        // pop\n        if(distances[i] < p.first) continue;\n        // \n        for(int j = 0; j < node_count; j++){\n            if(graph[i][j] == -1) continue;\n            if(distances[j] == -1){\n                distances[j] = distances[i] + graph[i][j];\n                dijkstra_pq.push(PII(distances[j], j));\n            }else if(distances[j] > distances[i] + graph[i][j]){\n                distances[j] = distances[i] + graph[i][j];\n                dijkstra_pq.push(PII(distances[j], j));\n            }\n        }\n    }\n};\n\n\n\n\n/**\n * start\n * @author yoshikyoto\n */\nstring area[50];\nint color[50][50][2];\n\nint vi[4] = {-1, 1, 0, 0}, vj[4] = {0, 0, -1, 1};\nvoid dfs(int i, int j, int r, int c, int side){\n    // \n    REP(k, 4){\n        int ni = i + vi[k];\n        int nj = j + vj[k];\n        if(inside(ni, nj, r, c) && area[ni][nj] == '.' && !color[ni][nj][side]){\n            color[ni][nj][side] = 1;\n            dfs(ni, nj, r, c, side);\n        }\n    }\n};\n\n\nint main(int argc, const char * argv[]){\n    while(true){\n        int r, c;\n        cin >> c >> r;\n        if(r == 0 && c == 0) break;\n        REP(i, r) cin >> area[i];\n        REP(i, r) REP(j, c){\n            color[i][j][0] = 0;\n            color[i][j][1] = 0;\n        }\n        \n        REP(i, r) REP(j, c){\n            if(area[i][j] == 'B'){\n                dfs(i, j, r, c, 0);\n            }else if(area[i][j] == 'W'){\n                dfs(i, j, r, c, 1);\n            }\n        }\n        \n        int black = 0, white = 0;\n        REP(i, r) REP(j, c){\n            if(color[i][j][0] && !color[i][j][1]){\n                black++;\n            }else if(!color[i][j][0] && color[i][j][1]){\n                white++;\n            }\n        }\n        cout << black << \" \" << white << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n#include <set>\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint h, w;\nstring field[51];\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nchar bfs(int y, int x){\n  if(field[y][x] != '.') return '.';\n  queue<P> que;\n  set<P> check;\n  que.push(P(y, x));\n  bool isW, isB;\n  isW = isB = false;\n  while(!que.empty()){\n    if(isW && isB) return '.';\n    P pos = que.front();\n    que.pop();\n    if(check.find(pos) != check.end()) continue;\n    check.insert(pos);\n    for(int i = 0 ; i < 4 ; i++){\n      if(pos.first+dy[i] < 0 || pos.first+dy[i] >= h) continue;\n      if(pos.second+dx[i] < 0 || pos.second+dx[i] >= w) continue;\n      \n      if(field[pos.first+dy[i]][pos.second+dx[i]] == 'W'){\n\tisW = true;\n\tcontinue;\n      }\n      else if(field[pos.first+dy[i]][pos.second+dx[i]] == 'B'){\n\tisB = true;\n\tcontinue;\n      }\n      else{\n\tque.push(P(pos.first+dy[i], pos.second+dx[i]));\n      }\n    }\n  }\n  \n  if(isW && !isB) return 'W';\n  else if(!isW && isB) return 'B';\n  else return '.';\n}\n\nint main(){\n  while(cin >> w >> h){\n    if(h == 0 && w == 0) break;\n    for(int i = 0 ; i < h ; i++){\n      cin >> field[i];\n    }\n    \n    int W, B;\n    W = B = 0;\n\n    for(int i = 0 ; i < h ; i++){\n      for(int j = 0 ; j < w ; j++){\n\tchar c = bfs(i, j);\n\tif(c == 'W') W++;\n\telse if(c == 'B') B++;\n      }\n    }\n    cout << B << ' ' << W << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\nchar bw[] = {'B', 'W'};\n\nstruct STATE { int x, y, t; };\n\nchar pile[52][52];\nint terr[52][52];\n\nvoid init()\n{\n\tfor (int i = 0; i < 52; i++){\n\t\tfor (int j = 0; j < 52; j++){\n\t\t\tpile[i][j] = 0;\n\t\t\tterr[i][j] = 0;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint w, h;\n\twhile (scanf(\"%d %d\", &w, &h), w + h){\n\t\tinit();\n\t\t\n\t\tfor (int i = 1; i <= h; i++){\n\t\t\tfor (int j = 1; j <= w; j++){\n\t\t\t\tscanf(\" %c\", &pile[i][j]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tqueue<STATE> que;\n\t\tfor (int t = 0; t <= 1; t++){\n\t\t\tfor (int i = 1; i <= h; i++){\n\t\t\t\tfor (int j = 1; j <= w; j++){\n\t\t\t\t\tif (pile[i][j] == bw[t]){\n\t\t\t\t\t\tfor (int dir = 0; dir < 4; dir++){\n\t\t\t\t\t\t\tint tx = i + dx[dir];\n\t\t\t\t\t\t\tint ty = j + dy[dir];\n\t\t\t\t\t\t\tif (pile[tx][ty] == '.'){\n\t\t\t\t\t\t\t\tque.push( {tx, ty, t} );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile (!que.empty()){\n\t\t\tSTATE st = que.front(); que.pop();\n\t\t\tif (terr[st.x][st.y] & (1 << st.t)) continue;\n\t\t\tterr[st.x][st.y] |= (1 << st.t);\n\t\t\tfor (int dir = 0; dir < 4; dir++){\n\t\t\t\tint tx = st.x + dx[dir];\n\t\t\t\tint ty = st.y + dy[dir];\n\t\t\t\tif (pile[tx][ty] == '.' && !(terr[tx][ty] & (1 << st.t))){\n\t\t\t\t\tque.push( {tx, ty, st.t} );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint cnt[2] = {0};\n\t\tfor (int t = 0; t <= 1; t++){\n\t\t\tfor (int i = 1; i <= h; i++){\n\t\t\t\tfor (int j = 1; j <= w; j++){\n\t\t\t\t\tcnt[t] += !(terr[i][j] ^ (1 << t));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d %d\\n\", cnt[0], cnt[1]);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nchar m[55][55];\nbool used[55][55];\nint w,h;\nint dx[] = {0,0,1,-1};\nint dy[] = {1,-1,0,0};\nchar c,c_;\nbool f;\n\nint solve(int x,int y){\n  int ret = 1;\n  used[x][y] = false;\n  for(int i = 0; i < 4; i++){\n    int nx = x + dx[i];\n    int ny = y + dy[i];\n    if(m[nx][ny] == c){\n      f = true;\n    }\n    if(m[nx][ny] == c_){\n      ret -= 1000000;\n    }\n    if(m[nx][ny] == '.' && used[nx][ny]){\n      ret += solve(nx,ny);\n    }\n  }\n  return ret;\n}\n\nint main(void){\n  while(1){\n    scanf(\"%d%d\",&w,&h);\n    if(!w && !h) break;\n    memset(m,0,sizeof(m));\n    for(int i = 1; i <= h; i++){\n      for(int j = 1; j <= w; j++){\n\tscanf(\" %c\",&m[i][j]);\n      }\n    }\n    for(int k = 0; k < 2; k++){\n      int ans = 0;\n      memset(used,true,sizeof(used));\n      c_ = (k)?'B':'W';\n      c = (!k)?'B':'W';\n      for(int i = 1; i <= h; i++){\n\tfor(int j = 1; j <= w; j++){\n\t  if(m[i][j] == '.' && used[i][j]){\n\t    f = false;\n\t    int ret = max(0,solve(i,j));\n\t    if(f){\n\t      //printf(\"%d:%d %d\\n\",i,j,ret);\n\t      ans += ret;\n\t    }\n\t  }\n\t}\n      }\n      printf(\"%d%c\",ans,(k)?'\\n':' ');\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = 1e16;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n\nll mod_add(ll a, ll b) { return (a + b) % MOD; }\nll mod_sub(ll a, ll b) { return (a - b + MOD) % MOD; }\nll mod_mul(ll a, ll b) { return a*b % MOD; }\n\nll w,h;\n\nvector<vector<ll>> v;\nvector<string> vs;\n\nint dy[] = {0,1,0,-1};\nint dx[] = {1,0,-1,0};\n\nbool in(int y,int x){\n    return y >= 0 && y < h && x >= 0 && x < w;\n}\n\nll c(int y,int x){\n    v[y][x] = -1;\n    ll res = 0;\n    rep(i,4){\n        ll ny = y + dy[i];\n        ll nx = x + dx[i];\n        if(!in(ny,nx))continue;\n        if(vs[ny][nx] == 'W'){\n            res |= 1;\n            continue;\n        }\n        else if(vs[ny][nx] == 'B'){\n            res |= 2;\n            continue;\n        }\n        else if(v[ny][nx] == -1)continue;\n        ll num = c(ny,nx);\n        res |= num;\n    }\n    return res;\n}\n\nvoid solve(int y,int x,int col){\n    v[y][x] = col;\n    rep(i,4){\n        int ny = y + dy[i];\n        int nx = x + dx[i];\n        if(!in(ny,nx))continue;\n        if(vs[ny][nx] == '.' && v[ny][nx] == -1)solve(ny,nx,col);\n    }\n}\n\nvoid print(){\n    rep(i,h){\n        rep(j,w){\n            printf(\"%2lld\",v[i][j]);\n        }\n        cout << endl;\n    }\n}\n\nint main(){\n    while(cin >> w >> h && w){\n        vs.clear();\n        v.clear();\n        vs.resize(h);\n        v.resize(h);\n        rep(i,h){\n            v[i].resize(w,0);\n            cin >> vs[i];\n        }\n        rep(i,h){\n            rep(j,w){\n                ll col;\n                if(vs[i][j] == '.'){\n                    col = c(i,j);\n                    solve(i,j,col);\n                // print();\n                }\n            }\n        }\n        ll ans[2] = {};\n        rep(i,h){\n            rep(j,w){\n                // printf(\"%2lld\",v[i][j]);\n                if(v[i][j] == 2)ans[0]++;\n                else if(v[i][j] == 1)ans[1]++;\n            }\n            // cout << endl;\n        }\n        cout << ans[0] << \" \" << ans[1] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"vector\"\n#include \"string\"\n#include \"queue\"\nusing namespace std;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nbool black[50][50],white[50][50];\nint main(void)\n{\n\tint w,h;\n\twhile (cin>>w>>h,w) {\n\t\tmemset(black,0,sizeof(black));\n\t\tmemset(white,0,sizeof(white));\n\t\tvector<string> in;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tstring t; cin>>t;\n\t\t\tin.push_back(t);\n\t\t}\n\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tint f=0;\n\t\t\t\tif(in[i][j]=='W') f=1;\n\t\t\t\telse if(in[i][j]=='B') f=2;\n\n\t\t\t\tif(in[i][j]!='.')\n\t\t\t\t{\n\t\t\t\t\tbool used[50][50];\n\t\t\t\t\tmemset(used,0,sizeof(used));\n\t\t\t\t\tqueue<int> xs,ys;\n\t\t\t\t\txs.push(j); ys.push(i);\n\t\t\t\t\twhile (!xs.empty()) {\n\t\t\t\t\t\tint x=xs.front(),y=ys.front();\n\t\t\t\t\t\txs.pop(); ys.pop();\n\t\t\t\t\t\tused[y][x]=true;\n\t\t\t\t\t\tif(f==1) white[y][x]=true;\n\t\t\t\t\t\telse black[y][x]=true;\n\t\t\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\t\t\tint nx=x+dx[k],ny=y+dy[k];\n\t\t\t\t\t\t\tif(0<=nx&&nx<w&&0<=ny&&ny<h&&!used[ny][nx]&&in[ny][nx]=='.')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\txs.push(nx); ys.push(ny);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint Black=0,White=0;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif(in[i][j]!='B'&&black[i][j]&&!white[i][j]) Black++;\n\t\t\t\telse if(in[i][j]!='W'&&!black[i][j]&&white[i][j]) White++;\n\t\t\t}\n\t\t}\n\t\tcout<<Black<<\" \"<<White<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n#include <cctype>\n#define REP(i,n) for(int i=0;i<(n);i++)\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nint main()\n{\n  while(1){\n    int w, h;\n    cin >> w >> h;\n    if(w == 0 && h == 0) break;\n    char map[h][w];\n    REP(i,h){\n      REP(j,w){\n        cin >> map[i][j];\n      }\n    }\n    queue<pii> a;\n    REP(i,h){\n      REP(j,w){\n        if(map[i][j] == 'B' || map[i][j] == 'W'){\n          if(i > 0){\n            if(map[i-1][j] == '.'){\n              map[i-1][j] = tolower(map[i][j]);\n              a.push(pii(i-1,j));\n            }else if(map[i-1][j] != 'W' && map[i-1][j] != 'B' && map[i-1][j] != 'x' && map[i-1][j] != tolower(map[i][j])){\n              map[i-1][j] = 'x';\n              a.push(pii(i-1,j));\n            }\n          }\n          if(i < h - 1){\n            if(map[i+1][j] == '.'){\n              map[i+1][j] = tolower(map[i][j]);\n              a.push(pii(i+1,j));\n            }else if(map[i+1][j] != 'W' && map[i+1][j] != 'B' && map[i+1][j] != 'x' && map[i+1][j] != tolower(map[i][j])){\n              map[i+1][j] = 'x';\n              a.push(pii(i+1,j));\n            }\n          }\n          if(j > 0){\n            if(map[i][j-1] == '.'){\n              map[i][j-1] = tolower(map[i][j]);\n              a.push(pii(i,j-1));\n            }else if(map[i][j-1] != 'W' && map[i][j-1] != 'B' && map[i][j-1] != 'x' && map[i][j-1] != tolower(map[i][j])){\n              map[i][j-1] = 'x';\n              a.push(pii(i,j-1));\n            }\n          }\n          if(j < w - 1){\n            if(map[i][j+1] == '.'){\n              map[i][j+1] = tolower(map[i][j]);\n              a.push(pii(i,j+1));\n            }else if(map[i][j+1] != 'W' && map[i][j+1] != 'B' && map[i][j+1] != 'x' && map[i][j+1] != tolower(map[i][j])){\n              map[i][j+1] = 'x';\n              a.push(pii(i,j+1));\n            }\n          }\n        }\n      }\n    }\n    while(!a.empty()){\n      int x, y;\n      x = a.front().first;\n      y = a.front().second;\n      a.pop();\n      if(x > 0){\n        if(map[x][y] == 'b'){\n          if(map[x-1][y] == 'w' || map[x-1][y] == 'x'){\n            map[x-1][y] = 'x';\n            a.push(pii(x-1,y));\n          }else if(map[x-1][y] == '.'){\n            map[x-1][y] = 'b';\n            a.push(pii(x-1,y));\n          }\n        }else if(map[x][y] == 'w'){\n          if(map[x-1][y] == 'b' || map[x-1][y] == 'x'){\n            map[x-1][y] = 'x';\n            a.push(pii(x-1,y));\n          }else if(map[x-1][y] == '.'){\n            map[x-1][y] = 'w';\n            a.push(pii(x-1,y));\n          }\n        }else{\n          if(map[x-1][y] != 'B' && map[x-1][y] != 'W' && map[x-1][y] != 'x'){\n            map[x-1][y] = 'x';\n            a.push(pii(x-1,y));\n          }\n        }\n      }\n      if(x < h - 1){\n        if(map[x][y] == 'b'){\n          if(map[x+1][y] == 'w' || map[x+1][y] == 'x'){\n            map[x+1][y] = 'x';\n            a.push(pii(x+1,y));\n          }else if(map[x+1][y] == '.'){\n            map[x+1][y] = 'b';\n            a.push(pii(x+1,y));\n          }\n        }else if(map[x][y] == 'w'){\n          if(map[x+1][y] == 'b' || map[x+1][y] == 'x'){\n            map[x*1][y] = 'x';\n            a.push(pii(x+1,y));\n          }else if(map[x+1][y] == '.'){\n            map[x+1][y] = 'w';\n            a.push(pii(x+1,y));\n          }\n        }else{\n          if(map[x+1][y] != 'B' && map[x+1][y] != 'W' && map[x+1][y] != 'x'){\n            map[x+1][y] = 'x';\n            a.push(pii(x+1,y));\n          }\n        }\n      }\n      if(y > 0){\n        if(map[x][y] == 'b'){\n          if(map[x][y-1] == 'w' || map[x][y-1] == 'x'){\n            map[x][y-1] = 'x';\n            a.push(pii(x,y-1));\n          }else if(map[x][y-1] == '.'){\n            map[x][y-1] = 'b';\n            a.push(pii(x,y-1));\n          }\n        }else if(map[x][y] == 'w'){\n          if(map[x][y-1] == 'b' || map[x][y-1] == 'x'){\n            map[x][y-1] = 'x';\n            a.push(pii(x,y-1));\n          }else if(map[x][y-1] == '.'){\n            map[x][y-1] = 'w';\n            a.push(pii(x,y-1));\n          }\n        }else{\n          if(map[x][y-1] != 'B' && map[x][y-1] != 'W' && map[x][y-1] != 'x'){\n            map[x][y-1] = 'x';\n            a.push(pii(x,y-1));\n          }\n        }\n      }\n      if(y < w - 1){\n        if(map[x][y] == 'b'){\n          if(map[x][y+1] == 'w' || map[x][y+1] == 'x'){\n            map[x][y+1] = 'x';\n            a.push(pii(x,y+1));\n          }else if(map[x][y+1] == '.'){\n            map[x][y+1] = 'b';\n            a.push(pii(x,y+1));\n          }\n        }else if(map[x][y] == 'w'){\n          if(map[x][y+1] == 'b' || map[x][y+1] == 'x'){\n            map[x][y+1] = 'x';\n            a.push(pii(x,y+1));\n          }else if(map[x][y+1] == '.'){\n            map[x][y+1] = 'w';\n            a.push(pii(x,y+1));\n          }\n        }else{\n          if(map[x][y+1] != 'B' && map[x][y+1] != 'W' && map[x][y+1] != 'x'){\n            map[x][y+1] = 'x';\n            a.push(pii(x,y+1));\n          }\n        }\n      }\n    }\n    pii ans;\n    ans.first = ans.second = 0;\n    REP(i,h){\n      REP(j,w){\n        if(map[i][j] == 'b')\n          ans.first++;\n        else if(map[i][j] == 'w')\n          ans.second++;\n      }\n    }\n    cout << ans.first << \" \" << ans.second << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define D(x) cout << #x \" = \" << x << endl\n#define DD(x, y) cout << \"(\" #x \", \" #y \") = (\" << x << \", \" << y << \")\" << endl\n#define DDD(x, y, z) cout << \"(\" #x \", \" #y \", \" #z \") = (\" << x << \", \" << y << \", \" << z << \")\" << endl\n#define DV(v) for (auto __macro_vi : v){ cout << __macro_vi << \" \";} cout << endl;\n#define DA(a, n) for (int __macro_i = 0; __macro_i < n; ++__macro_i) { cout << a[__macro_i] << \" \"; } cout << endl;\n#define REP(i, n) for (int i = 0; i < n; ++i)\n#define ALL(v) (v).begin(), (v).end()\n#include<iostream>\n#include<vector>\n#include<cassert>\n#include<cmath>\n#include<algorithm>\n#include<cstdio>\n#include<tuple>\n\nusing namespace std;\nusing P = pair<char, int>;\nint w, h;\n\nvector<string> mp;\nvector<vector<P>> memo;\nint di[] = {-1, 0, 1, 0};\nint dj[] = {0, 1, 0, -1};\nP dfs(int i, int j) {\n\n    if (mp[i][j] != '.') return make_pair(mp[i][j], 0);\n    if (memo[i][j].second != -1) return memo[i][j];\n    memo[i][j].second = 0;\n\n    int cnt = 1;\n    char last = '-';\n    for (int k = 0; k < 4; ++k) {\n        int ni = i + di[k];\n        int nj = j + dj[k];\n        if (ni < 0 || ni >= h || nj < 0 || nj >= w) continue;\n        if (memo[ni][nj].second != -1) continue;\n        char c;\n        int ncnt;\n        tie(c, ncnt) = dfs(ni, nj);\n        if (c == '?') last = '?';\n        else if (last == '-') last = c;\n        else if (last != c && c != '-') last = '?';\n        cnt += ncnt;\n    }\n    memo[i][j] = make_pair(last, cnt);\n    //     DD(i, j);\n    //     REP(i, h) {\n    //     REP(j, w) {\n    //         cout << memo[i][j].first;\n    //     }\n    //     cout << endl;\n    // }\n    return memo[i][j];\n}\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(1) {\n        cin >> w >> h;\n        if (w == 0) break;\n        mp = vector<string>(h);\n        memo = vector<vector<P>>(h, vector<P>(w, make_pair('.', -1)));\n        REP(i, h) cin >> mp[i];\n        int bcnt = 0;\n        int wcnt = 0;\n        REP(i, h) REP(j, w) {\n            if (memo[i][j].second != -1 || mp[i][j] != '.') continue;\n            int cnt;\n            char c;\n            tie(c, cnt) = dfs(i, j);\n            // REP(i, h) {\n            //     REP(j, w) {\n            //         cout << memo[i][j].first;\n            //     }\n            //     cout << endl;\n            // }\n            // DD(c, cnt);\n            if (c == 'B') bcnt += cnt;\n            if (c == 'W') wcnt += cnt;\n        }\n        cout << bcnt << \" \" << wcnt << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <stack>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <tuple>\n#include <assert.h>\n#include <deque>\n#include <bitset>\n#include <iomanip>\n#include <limits>\n#include <chrono>\n#include <random>\n#include <array>\n#include <unordered_map>\n#include <functional>\n#include <complex>\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\nconstexpr long long MAX = 5100000;\nconstexpr long long INF = 1LL << 60;\nconstexpr int inf = 1 << 28;\n//constexpr long long mod = 1000000007LL;\n//constexpr long long mod = 998244353LL;\n\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef long long ll;\n\nint dh[4] = { 1,0,-1,0 };\nint dw[4] = { 0,1,0,-1 };\nint main()\n{\n\t/*\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\t*/\n\tint kkt = 89;\n\twhile (kkt) {\n\t\tint W, H; cin >> W >> H;\n\t\tif (W == 0) break;\n\t\tvector<string> vs(H); for (int i = 0; i < H; i++) cin >> vs[i];\n\t\tvector<vector<bool>> bl(H, vector<bool>(W, false)), wh(H, vector<bool>(W, false));\n\t\t{\n\t\t\tqueue<pair<int, int>> q;\n\t\t\tfor (int i = 0; i < H; i++) for (int j = 0; j < W; j++) if (vs[i][j] == 'B') q.emplace(i, j);\n\t\t\twhile (!q.empty()) {\n\t\t\t\tint h, w; tie(h, w) = q.front();\n\t\t\t\tq.pop();\n\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\tint nh = h + dh[i];\n\t\t\t\t\tint nw = w + dw[i];\n\t\t\t\t\tif (nh < 0 || nh >= H || nw < 0 || nw >= W) continue;\n\t\t\t\t\tif (vs[nh][nw] != '.') continue;\n\t\t\t\t\tif (bl[nh][nw]) continue;\n\t\t\t\t\tbl[nh][nw] = true;\n\t\t\t\t\tq.emplace(nh, nw);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t{\n\t\t\tqueue<pair<int, int>> q;\n\t\t\tfor (int i = 0; i < H; i++) for (int j = 0; j < W; j++) if (vs[i][j] == 'W') q.emplace(i, j);\n\t\t\twhile (!q.empty()) {\n\t\t\t\tint h, w; tie(h, w) = q.front();\n\t\t\t\tq.pop();\n\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\tint nh = h + dh[i];\n\t\t\t\t\tint nw = w + dw[i];\n\t\t\t\t\tif (nh < 0 || nh >= H || nw < 0 || nw >= W) continue;\n\t\t\t\t\tif (vs[nh][nw] != '.') continue;\n\t\t\t\t\tif (wh[nh][nw]) continue;\n\t\t\t\t\twh[nh][nw] = true;\n\t\t\t\t\tq.emplace(nh, nw);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint rb = 0, rw = 0;\n\t\tfor (int i = 0; i < H; i++) for (int j = 0; j < W; j++) {\n\t\t\tif (bl[i][j] && !wh[i][j]) rb++;\n\t\t\tif (!bl[i][j] && wh[i][j]) rw++;\n\t\t}\n\t\tcout << rb << \" \" << rw << \"\\n\";\n\t}\n\treturn 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n#include <string.h>\n#include <map>\n#include <set>\n#include <functional>\n#include <complex>\n\nusing namespace std;\n\nconst int INF = (1<<30) - 1;\n\nint W, H;\nint dh[] = {0, 0, 1, -1};\nint dw[] = {1, -1, 0, 0};\n\ninline bool in_field(int h, int w){\n    return 0<=h && h<H && 0<=w && w<W;\n}\n\nvoid dfs1(vector<string> &field, int h, int w){\n    for(int i=0; i<4; i++){\n        int nh = h + dh[i];\n        int nw = w + dw[i];\n        if(in_field(nh, nw) && field[nh][nw] == '.'){\n            field[nh][nw] = '1';\n            dfs1(field, nh, nw);\n        }\n    }\n}\n\nvoid dfs2(vector<string> &field, int h, int w){\n    for(int i=0; i<4; i++){\n        int nh = h + dh[i];\n        int nw = w + dw[i];\n        if(in_field(nh, nw) && (field[nh][nw] == '.' || field[nh][nw] == '1')){\n            field[nh][nw] = field[nh][nw] == '.' ? '2' : '3';\n            dfs2(field, nh, nw);\n        }\n    }\n}\n\n\n\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    while(cin>>W>>H, W|H){\n        vector<string> field(H);\n        for(int i=0; i<H; i++)\n            cin >> field[i];\n        \n        for(int i=0; i<H; i++)\n            for(int j=0; j<W; j++)\n                if(field[i][j] == 'B')\n                    dfs1(field, i, j);\n        \n        for(int i=0; i<H; i++)\n            for(int j=0; j<W; j++)\n                if(field[i][j] == 'W')\n                    dfs2(field, i, j);\n        \n        int cnt1 = 0, cnt2 = 0;\n        for(int i=0; i<H; i++)\n            for(int j=0; j<W; j++)\n                if(field[i][j] == '1')\n                    cnt1++;\n                else if(field[i][j] == '2')\n                    cnt2++;\n        \n        cout << cnt1 << \" \" << cnt2 << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;++i)\n#define rep1(i,n) for(int i=1;i<=n;++i)\nusing namespace std;\nint a[52][52]={};\nint dx[4]={0,0,-1,1};\nint dy[4]={-1,1,0,0};\nint h,w;\n\n//color B,W->+1,-1 ?????????\\B,W,B&W->+2,-2,10 ??->100\nvoid paint(int y,int x,int color){\n    if((fabs(a[y][x])!=2 && a[y][x]!=0) || a[y][x]==color)return;\n    if(a[y][x]+color==0)color = 10;\n    a[y][x] = color;\n    rep(i,4)paint(y+dy[i],x+dx[i],color);\n}\n\nint main(void){\n    char tmp;\n    while(cin>>w>>h, w|h){\n        int cntB=0,cntW=0;\n\n        /*??\\???*/\n        rep1(y,h){\n            rep1(x,w){\n                cin>>tmp;\n                if(tmp=='.')a[y][x] = 0;\n                else if(tmp=='B')a[y][x] = 1;\n                else a[y][x] = -1;\n            }\n        }\n\n        /*???????*/\n        rep(y,h+2)a[y][0]=a[y][w+1] = 100;\n        rep(x,w+2)a[0][x]=a[h+1][x] = 100;\n\n        /*????????????*/\n        rep1(y,h)rep1(x,w)if(fabs(a[y][x])==1)rep(i,4)paint(y+dy[i],x+dx[i],2*a[y][x]);\n\n        /*????????????*/\n        rep1(y,h){\n            rep1(x,w){\n                if(a[y][x]==2)cntB++;\n                else if(a[y][x]==-2)cntW++;\n            }\n        }\n        cout<<cntB<<\" \"<<cntW<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint dy[] = {1, -1, 0, 0};\nint dx[] = {0, 0, 1, -1};\n\nint main()\n{\n    for(;;){\n        int w, h;\n        cin >> w >> h;\n        if(w == 0)\n            return 0;\n\n        vector<string> s(h+2, string(w+2, '#'));\n        vector<queue<pair<int, int> > > q(2);\n        for(int i=1; i<=h; ++i){\n            for(int j=1; j<=w; ++j){\n                cin >> s[i][j];\n                if(s[i][j] == 'B')\n                    q[0].push(make_pair(i, j));\n                else if(s[i][j] == 'W')\n                    q[1].push(make_pair(i, j));\n            }\n        }\n\n        vector<vector<vector<bool> > > check(2, vector<vector<bool> >(h+2, vector<bool>(w+2, false)));\n        for(int i=0; i<2; ++i){\n            while(!q[i].empty()){\n                int y = q[i].front().first;\n                int x = q[i].front().second;\n                q[i].pop();\n\n                for(int j=0; j<4; ++j){\n                    int y2 = y + dy[j];\n                    int x2 = x + dx[j];\n                    if(s[y2][x2] == '.' && !check[i][y2][x2]){\n                        check[i][y2][x2] = true;\n                        q[i].push(make_pair(y2, x2));\n                    }\n                }\n            }\n        }\n\n        int retB = 0;\n        int retW = 0;\n        for(int i=1; i<=h; ++i){\n            for(int j=1; j<=w; ++j){\n                if(check[0][i][j] && !check[1][i][j])\n                    ++ retB;\n                else if(!check[0][i][j] && check[1][i][j])\n                    ++ retW;\n            }\n        }\n        cout << retB << ' ' << retW << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n\nusing namespace std;\n\n#define WH 52\n\nint dx[4]={0,0,1,-1};\nint dy[4]={1,-1,0,0};\nchar f[WH][WH];\n\nset<char> s;\n\nvoid dfs1(int ,int);\nvoid dfs2(int ,int ,char);\n\nint main(int argc, char const *argv[])\n{\n\tint w,h;\n\tint bb,ww;\n\n\twhile(1){\n\t\tcin>>w>>h;\n\t\tif(w+h==0) break;\n\n\t\tfor(int i1=0;i1<WH;i1++){\n\t\t\tfor(int i2=0;i2<WH;i2++){\n\t\t\t\tf[i1][i2]='#';\n\t\t\t}\n\t\t}\n\n\t\tfor(int i1=1;i1<=h;i1++){\n\t\t\tfor(int i2=1;i2<=w;i2++){\n\t\t\t\tcin>>f[i1][i2];\n\t\t\t}\n\t\t}\n\n\t\tfor(int i1=1;i1<=h;i1++){\n\t\t\tfor(int i2=1;i2<=w;i2++){\n\t\t\t\tif(f[i1][i2]=='.') {\n\t\t\t\t\ts.clear();\n\t\t\t\t\tdfs1(i2,i1);\n\t\t\t\t\tif(s.size()==2){}\n\t\t\t\t\telse dfs2(i2,i1,(*s.begin()));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbb=0;\n\t\tww=0;\n\t\tfor(int i1=1;i1<=h;i1++){\n\t\t\tfor(int i2=1;i2<=w;i2++){\n\t\t\t\tif(f[i1][i2]=='b') bb++;\n\t\t\t\telse if(f[i1][i2]=='w') ww++;\n\t\t\t}\n\t\t}\n\n\t\tcout<<bb<<\" \"<<ww<<endl;\n\t}\n\treturn 0;\n}\n\nvoid dfs1(int x,int y){\n\n\tf[y][x]='@';\n\tfor(int i1=0;i1<4;i1++){\n\t\tif(f[y+dy[i1]][x+dx[i1]]=='B') s.insert('b');\n\t\telse if(f[y+dy[i1]][x+dx[i1]]=='W') s.insert('w');\n\t\telse if(f[y+dy[i1]][x+dx[i1]]=='.') dfs1(x+dx[i1],y+dy[i1]);\n\t\telse {}\n\t}\n\n}\n\nvoid dfs2(int x,int y, char c){\n\n\tf[y][x]=c;\n\tfor(int i1=0;i1<4;i1++){\n\t\tif(f[y+dy[i1]][x+dx[i1]]=='@') dfs2(x+dx[i1],y+dy[i1],c);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define INF 114514810\n#define ll long long\n#define ALL(a) (a).begin(),(a).end()\n#define SORT(v) sort(ALL(v))\n//#define scanf scanf_s\ntypedef pair<int, int> P;\n\nint n, m;\nstring s;\nint a[100005];\nint b[100005];\nint c[10005];\nset<int> used;\n\nchar sima[55][55];\nint cntw, cntb, cnttmp;\nchar tmp;\nint di[] = { -1, 0, 0, 1 }; int dj[] = { 0, -1, 1, 0 };\nint h, w;\nvoid search(int i,int j)\n{\n\tif (i < 0 || i >= h || j < 0 || j >= w) return;\n\tif (sima[i][j] == 'W')\n\t{\n\t\tif (tmp == 'B')\n\t\t{\n\t\t\tcnttmp = -10000000;\n\t\t}\n\t\telse tmp = 'W';\n\t}\n\tif (sima[i][j] == 'B')\n\t{\n\t\tif (tmp == 'W')\n\t\t{\n\t\t\tcnttmp = -10000000;\n\t\t}\n\t\telse tmp = 'B';\n\t}\n\tif (sima[i][j] == '.')\n\t{\n\t\tsima[i][j] = '@';\n\t\tcnttmp++;\n\t\tREP(k, 4) search(i + di[k], j + dj[k]);\n\t}\n}\n\nint main()\n{\n\twhile (cin >> w >> h, w)\n\t{\n\t\tREP(i, h)REP(j, w) cin >> sima[i][j];\n\t\tcntw = 0, cntb = 0;\n\t\tREP(i, h)REP(j, w)\n\t\t{\n\t\t\tcnttmp = 0;\n\t\t\ttmp = '@';\n\t\t\tif (sima[i][j] == '.')\n\t\t\t{\n\t\t\t\tsearch(i, j);\n\t\t\t\tif (cnttmp>0&&tmp == 'B') cntb += cnttmp;\n\t\t\t\tif (cnttmp>0&&tmp == 'W') cntw += cnttmp;\n\t\t\t}\n\t\t}\n\t\tcout << cntb << \" \" << cntw << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF INT_MAX/1000\nusing namespace std;\n\nint w, h;\nint g[50][50];\nbool used[50][50][2];\n\nconst int dx[] = { 0, -1,  0,  1};\nconst int dy[] = {-1,  0,  1,  0};\n\nbool infield(int x, int y){\n    return 0 <= x && x < w && 0 <= y && y < h;\n}\n\nint dfs(int x, int y, int color){\n    if(g[y][x] == color) return 0;\n    if(g[y][x] != 0){\n        return -INF;\n    }\n    used[y][x][color-1] = true;\n\n    int res = 0;\n    for(int d = 0; d < 4; d++){\n        int nx = x + dx[d], ny = y + dy[d];\n        if(!infield(nx, ny) || used[ny][nx][color-1]) continue;\n        res += dfs(nx, ny, color);\n    }\n\n    return res+1;\n}\n\nint main(void){\n    while(cin >> w >> h, w || h){\n        bool pole_exist = false;\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                char c; cin >> c;\n                used[i][j][0] = used[i][j][1] = false;\n                if(c == 'W' || c == 'B') pole_exist = true;\n                if(c == 'W') g[i][j] = 1;\n                else if(c == 'B') g[i][j] = 2;\n                else g[i][j] = 0;\n            }\n        }\n\n        if(pole_exist == false){\n            cout << 0 << \" \" << 0 << endl;\n            continue;\n        }\n        int white = 0, black = 0;\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                if(used[i][j][0] == false)\n                    white += max(dfs(j, i, 1), 0);\n                if(used[i][j][1] == false)\n                    black += max(dfs(j, i, 2), 0);\n            }\n        }\n\n        cout << black << \" \" << white << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define it ::iterator\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double ESP=1e-10;\nusing namespace std;\nint n,m;\nint x[4]={1,0,-1,0};\nint y[4]={0,1,0,-1};\nint func(vector<string>& in,char d,int i,int j){\n  //cout<<i<<j<<endl;\n  int ans=0;\n  rep(k,4){\n    int x1=i+x[k];\n    int y1=j+y[k];\n    if(x1<0||x1>=n||y1<0||y1>=m)continue;\n    if(in[x1][y1]!='.'&&in[x1][y1]!='!'&&in[x1][y1]!=d)return -1000000;\n    if(in[x1][y1]!='!'&&in[x1][y1]=='.'){ans++;in[x1][y1]='!';ans+=func(in,d,x1,y1);}\n  }\n  //cout<<ans<<endl;\n  return ans;\n}\nint main(){\n  while(cin>>m>>n,n||m){\n    vector<string>in(n);\n    rep(i,n)cin>>in[i];\n    int ans1=0,ans2=0;\n    rep(i,n){\n      rep(j,m){\n\tif(in[i][j]!='!'&&(in[i][j]=='W'||in[i][j]=='B')){\n\t  rep(b,4){\n\t    int ans=0,tmp;\n\t    int x1=i+x[b],y1=j+y[b];\n\t    if(x1<0||x1>=n||y1<0||y1>=m)continue;\n\t    if(in[x1][y1]=='.'){in[x1][y1]='!';ans++;tmp=func(in,in[i][j],x1,y1);}\n\t    else tmp=-1;\n\t    if(tmp>=0)ans+=tmp;\n\t    else ans=0;\n\t    //cout<<ans<<endl;\n\t    if(in[i][j]=='W')ans2+=ans;\n\t    else ans1+=ans;\n\t  }\n\t  //rep(a,n)cout<<in[a]<<endl;\n\t}\n      }\n    }\n    cout<<ans1<<\" \"<<ans2<<endl;\n  }\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<string>\n#include<string.h>\n#include<functional>\nusing namespace std;\n\n#define INF 1<<21\n#define DIV 1000000007\n\ntypedef pair<int, int>P;\n\n\nint w, h;\nint cnt;\nchar f[51][51];\nint dx[] = { 1,-1,0,0 }, dy[] = { 0,0,1,-1 };\n\nvoid rec(int x, int y, char c) {\n  for (int i = 0; i < 4; i++) {\n\tint nx = x + dx[i];\n\tint ny = y + dy[i];\n\tif (nx <= 0 || w < nx || ny <= 0 || h < ny )continue;\n\n\tif (c == 'B') {\n\t  if (f[ny][nx] == 'w') {\n\t\tf[ny][nx] = 'u';\n\t\trec(nx, ny, c);\n\t  }\n\t  else if (f[ny][nx] == '.') {\n\t\tf[ny][nx] = 'b';\n\t\trec(nx, ny, c);\n\t  }\n\t}\n\telse if (c == 'W') {\n\t  if (f[ny][nx] == 'b') {\n\t\tf[ny][nx] = 'u';\n\t\trec(nx, ny, c);\n\t  }\n\t  else if (f[ny][nx] == '.') {\n\t\tf[ny][nx] = 'w';\n\t\trec(nx, ny, c);\n\t  }\n\t}\n  }\n}\n\nint main() {\n  while (cin >> w >> h, (w || h)) {\n\tmemset(f, 0, sizeof(f));\n\tfor (int y = 1; y <= h; y++) {\n\t  for (int x = 1; x <= w; x++) {\n\t\tcin >> f[y][x];\n\t  }\n\t}\n\tfor (int y = 1; y <= h; y++) {\n\t  for (int x = 1; x <= w; x++) {\n\t\tif (f[y][x] == 'W' || f[y][x] == 'B') {\n\t\t  rec(x, y, f[y][x]);\n\t\t}\n\t  }\n\t}\n\tint blacks = 0, whites = 0;\n\tfor (int y = 1; y <= h; y++) {\n\t  for (int x = 1; x <= w; x++) {\n\t\tif (f[y][x] == 'b') {\n\t\t  blacks++;\n\t\t}\n\t\telse if (f[y][x] == 'w') {\n\t\t  whites++;\n\t\t}\n\t  }\n\t}\n\tcout << blacks << \" \" << whites << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2014\n// \n/*\n\n (i, j)      (i, j) \n\n\n\n */\n\n#include <iostream>\n#include <stdio.h>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Point {\n  int x, y;\n};\n\nconst int dir[4][2] = { {0, 1}, {0, -1}, {1, 0}, {-1, 0} };\n\nint main() {\n  int w, h;\n  while (scanf(\"%d%d\", &w, &h) != EOF && w) {\n    char c;\n    queue<Point> Q[2]; // 0B1W\n    bool isempty[60][60];\n    //    bool isnb[2][60][60];\n    fill(&isempty[0][0], &isempty[0][0]+60*60, false);\n    //    fill(&isnb[0][0][0], &isnb[0][0][0]+2*60*60, false);\n    for (int i=1; i<=h; i++) {\n      for (int j=1; j<=w; j++) {\n\tPoint p = { j, i };\n\tscanf(\" %c\", &c);\n\tswitch(c) {\n\tcase 'B':\n\t  Q[0].push(p);\n\t  /* for (int l=0; l<4; l++) {\n\t    isnb[0][j+dir[l][0]][i+dir[l][1]] = true;\n\t    } */\n\t  break;\n\tcase 'W':\n\t  Q[1].push(p);\n\t  /* for (int l=0; l<4; l++) {\n\t    isnb[1][j+dir[l][0]][i+dir[l][1]] = true;\n\t    } */\n\t  break;\n\tdefault:\n\t  isempty[j][i] = true;\n\t}\n      }\n    }\n    bool isnbh[2][60][60];\n    fill(&isnbh[0][0][0], &isnbh[0][0][0]+2*60*60, false);\n    for (int k=0; k<2; k++) {\n      while(! Q[k].empty()) {\n\tPoint now = Q[k].front();\n\tQ[k].pop();\n\tfor (int i=0; i<4; i++) {\n\t  int tx = now.x + dir[i][0];\n\t  int ty = now.y + dir[i][1];\n\t  if (isempty[tx][ty] && !isnbh[k][tx][ty]) {\n\t    isnbh[k][tx][ty] = true;\n\t    Point temp = {tx, ty};\n\t    Q[k].push(temp);\n\t  }\n\t}\n      }\n    }\n    int ans[2] = {0, 0};\n    for (int k=0; k<2; k++) {\n      for (int i=1; i<=h; i++) {\n\tfor (int j=1; j<=w; j++) {\n\t  if (isnbh[k][j][i] && !isnbh[(k+1)%2][j][i]) ans[k]++;\n\t}\n      }\n    }\n    printf(\"%d %d\\n\", ans[0], ans[1]);\n    /* cerr << \"Empty:\" << endl;\n    for (int i=1; i<=h; i++) {\n      for (int j=1; j<=w; j++) {\n\tcerr << isempty[j][i];\n      }\n      cerr << endl;\n    }\n    cerr << \"Neighborhood of Black:\" << endl;\n    for (int i=1; i<=h; i++) {\n      for (int j=1; j<=w; j++) {\n\tcerr << isnb[0][j][i];\n      }\n      cerr << endl;\n    }\n    cerr << \"Neighborhood of White:\" << endl;\n    for (int i=1; i<=h; i++) {\n      for (int j=1; j<=w; j++) {\n\tcerr << isnb[1][j][i];\n      }\n      cerr << endl;\n    }\n    cerr << \"Extended Neighborhood of Black:\" << endl;\n    for (int i=1; i<=h; i++) {\n      for (int j=1; j<=w; j++) {\n\tcerr << isnbh[0][j][i];\n      }\n      cerr << endl;\n    }\n    cerr << \"Extended Neighborhood of White:\" << endl;\n    for (int i=1; i<=h; i++) {\n      for (int j=1; j<=w; j++) {\n\tcerr << isnbh[1][j][i];\n      }\n      cerr << endl;\n    }\n    cerr << \"Black's Area:\" << endl;\n    for (int i=1; i<=h; i++) {\n      for (int j=1; j<=w; j++) {\n\tcerr << (isnbh[0][j][i] && !isnbh[1][j][i]);\n      }\n      cerr << endl;\n    }\n    cerr << \"White's Area:\" << endl;\n    for (int i=1; i<=h; i++) {\n      for (int j=1; j<=w; j++) {\n\tcerr << (isnbh[1][j][i] && !isnbh[0][j][i]);\n      }\n      cerr << endl;\n    } */\n  } \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint w, h;\nint a[50][50];\nbool b[2][50][50];\n\nvoid f(int c, int i, int j) {\n\tb[c][i][j] = true;\n\tfor (int k = 0; k < 4; k++) {\n\t\tif (i + dy[k] >= 0 && i + dy[k] < h && j + dx[k] >= 0 && j + dx[k] < w) {\n\t\t\tif (a[i + dy[k]][j + dx[k]] == -1 && !b[c][i + dy[k]][j + dx[k]]) {\n\t\t\t\tf(c, i + dy[k], j + dx[k]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\twhile (cin >> w >> h, w) {\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (s[j] == 'B') {\n\t\t\t\t\ta[i][j] = 0;\n\t\t\t\t} else if (s[j] == 'W') {\n\t\t\t\t\ta[i][j] = 1;\n\t\t\t\t} else {\n\t\t\t\t\ta[i][j] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int c = 0; c < 2; c++) {\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tb[c][i][j] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (a[i][j] != -1) {\n\t\t\t\t\tf(a[i][j], i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint p = 0, q = 0;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (a[i][j] == -1) {\n\t\t\t\t\tif (b[0][i][j] && !b[1][i][j]) {\n\t\t\t\t\t\tp++;\n\t\t\t\t\t} else if (!b[0][i][j] && b[1][i][j]) {\n\t\t\t\t\t\tq++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << p << ' ' << q << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint m[53][53],sum,ch[4];\n\nint dfs(int i,int j){\n  if(m[i][j]==2){\n    ch[2]=1;\n  }else if(m[i][j]==3){\n    ch[3]=1;\n  }else if(m[i][j]==1){    \n    sum++;\n    m[i][j]=0;\n    if(m[i-1][j]>0)dfs(i-1,j);\n    if(m[i][j-1]>0)dfs(i,j-1);\n    if(m[i+1][j]>0)dfs(i+1,j);\n    if(m[i][j+1]>0)dfs(i,j+1);\n  }\n}\n\nint main(){\n  int wh,b,w,h;\n    char s;\n  while(1){\n    cin>>w>>h;\n    if(w==0&&h==0)break;\n    for(int i=0;i<=h+1;i++){\n      for(int j=0;j<=w+1;j++){\n\tm[i][j]=0;\n      }\n    }\n    b=0;wh=0;\n\n    for(int i=1;i<=h;i++){//??\n      for(int j=1;j<=w;j++){\n\tcin>>s;\n\tif(s=='.')m[i][j]=1;\n\telse if(s=='W')m[i][j]=2;\n\telse if(s=='B')m[i][j]=3;\n      }    \n    }\n\n    for(int i=1;i<=h;i++){\n      for(int j=1;j<=w;j++){\n\tif(m[i][j]==1){\n\t  sum=0;\n\t  ch[2]=0;\n\t  ch[3]=0;\n\t  dfs(i,j);\n\t  if(ch[2]==1&&ch[3]==0)wh+=sum;\n\t  else if(ch[3]==1&&ch[2]==0)b+=sum;\n\t  /*for(int i=0;i<=h+1;i++){////////////\n\t    for(int j=0;j<=w+1;j++){\n\t      cout<<m[i][j];\n\t    }\n\t    cout<<endl;\n\t  }\n\t  cout<<ch[2]<<\" \"<<ch[3]<<endl;//////////*/\n\t}\n      }\n    }\n    cout<<b<<\" \"<<wh<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include <set>\n#include <cctype>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\nusing namespace std;\n#define INF 100000000\n#define MAXH 64\n#define MAXW 64\n\ntypedef long long ll;\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\nchar a[MAXH][MAXW];\nint w, h;\nqueue<int> X, Y;\n\nint main(void) {\n    while (1) {\n        cin >> w >> h;\n        if (w == 0 && h == 0) break;\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                cin >> a[i][j];\n            }\n        }\n        int white = 0, black = 0;\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                if (a[i][j] != '.') continue;\n                bool used[MAXH][MAXW];\n                for (int k = 0; k < h; k++) {\n                    for (int l = 0; l < w; l++) {\n                        used[k][l] = false;\n                    }\n                }\n                while (!X.empty()) X.pop();\n                while (!Y.empty()) Y.pop();\n                X.push(j); Y.push(i);\n                bool white_flag = false, black_flag = false;\n                while (!X.empty()) {\n                    int x = X.front(); X.pop();\n                    int y = Y.front(); Y.pop();\n                    used[y][x] = true;\n                    for (int k = 0; k < 4; k++) {\n                        int nx = x + dx[k];\n                        int ny = y + dy[k];\n                        if (0 <= nx && nx < w && 0 <= ny && ny < h) {\n                            if (a[ny][nx] == 'W') white_flag = true;\n                            else if (a[ny][nx] == 'B') black_flag = true;\n                            else if (!used[ny][nx]) {\n                                X.push(nx);\n                                Y.push(ny);\n                            }\n                        }\n                    }\n                }\n                if (white_flag && !black_flag) white++;\n                if (!white_flag && black_flag) black++;\n            }\n        }\n        cout << black << \" \" << white << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,1,0,-1};\n\nstruct lattice{\n  bool wallB,wallW,black,white;\n};\n\nstruct zahyou{\n  int x;\n  int y;\n};\n\nint main() {\n  vector<int> ans_B,ans_W;\n  while(1){\n    int w,h;\n    char a;\n    cin >> w >> h;\n    if(!w && !h)break;\n    vector<vector<lattice> > v(h+2);\n    for(int i = 1;i <= h;i++){\n      vector<lattice> q(w+2);\n      lattice l;\n      l.wallB = 1;\n      l.wallW = 1;\n      l.black = 0;\n      l.white = 0;\n      q[0] = l;\n      q[w+1] = l;\n      for(int j = 1;j <= w;j++){\n        cin >> a;\n        l.wallB = 0;\n        l.wallW = 0;\n        l.black = 0;\n        l.white = 0;\n        if(a == 'W')l.wallW = 1;\n        if(a == 'B')l.wallB = 1;\n        q[j] = l;\n      }\n      v[i] = q;\n    }\n\n    for(int j = 0;j <= w+1;j++){\n      lattice l;\n      l.wallB = 1;\n      l.wallW = 1;\n      l.black = 0;\n      l.white = 0;\n      v[0].push_back(l);\n      v[h+1].push_back(l);\n    }\n\n    for(int i = 1;i <= h;i++){\n      for(int j = 1;j <= w;j++){\n        if(v[i][j].wallW){\n          queue<zahyou> que;\n          zahyou z;\n          z.x = i;\n          z.y = j;\n          que.push(z);\n          while(que.size()){\n            printf(\"%d , %d\",que.front().x,que.front().y);\n            for(int k = 0;k < 4;k++){\n              if(1 <= que.front().x && que.front().x <= h && 1 <= que.front().y && que.front().y <= w){\n                if(!v[que.front().x + dx[k]][que.front().y + dy[k]].white && !v[que.front().x + dx[k]][que.front().y + dy[k]].wallB && !v[que.front().x + dx[k]][que.front().y + dy[k]].wallW){\n                  z.x = que.front().x + dx[k];\n                  z.y = que.front().y + dy[k];\n                  que.push(z);\n                  v[que.front().x + dx[k]][que.front().y + dy[k]].white = 1;\n                }\n              }\n            }\n            que.pop();\n          }\n        }\n        if(v[i][j].wallB){\n          queue<zahyou> que;\n          zahyou z;\n          z.x = i;\n          z.y = j;\n          que.push(z);\n          while(que.size()){\n            printf(\"%d , %d\",que.front().x,que.front().y);\n            for(int k = 0;k < 4;k++){\n              if(1 <= que.front().x && que.front().x <= h && 1 <= que.front().y && que.front().y <= w){\n                if(!v[que.front().x + dx[k]][que.front().y + dy[k]].black && !v[que.front().x + dx[k]][que.front().y + dy[k]].wallB && !v[que.front().x + dx[k]][que.front().y + dy[k]].wallW){\n                  z.x = que.front().x + dx[k];\n                  z.y = que.front().y + dy[k];\n                  que.push(z);\n                  v[que.front().x + dx[k]][que.front().y + dy[k]].black = 1;\n                }\n              }\n            }\n            que.pop();\n          }\n        }\n      }\n    }\n    int countB=0,countW=0;\n    for(int i = 1;i <= h;i++){\n      for(int j = 1;j <= w;j++){\n        if(v[i][j].black && v[i][j].white){}\n        else if(v[i][j].black && !v[i][j].wallB && !v[i][j].wallW){\n          countB++;\n        }\n        else if(v[i][j].white && !v[i][j].wallB && !v[i][j].wallW){\n          countW++;\n        }\n      }\n    }\n    ans_B.push_back(countB);\n    ans_W.push_back(countW);\n  }\n  for(int i = 0;i < ans_B.size();i++)cout << ans_B[i] << \" \" << ans_W[i] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\n#include <list>\nusing namespace std;\nstatic const double EPS = 1e-5;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define F first\n#define S second\n\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\nmain(){\n  int w,h;\n  while(cin>>w>>h,w|h){\n    string in[h];\n    rep(i,h)cin>>in[i];\n\n    rep(i,h){\n      rep(j,w){\n\tif(in[i][j]!='.')continue;\n\n\tbool cont=true;\n\trep(k,4){\n\t  int ni=i+dx[k],nj=j+dy[k];\n\t  if(ni<0 || h<=ni || nj<0 || w<=nj)continue;\n\t  if(in[ni][nj]=='W' || in[ni][nj]=='B'){\n\t    cont=false;\n\t    switch(in[ni][nj]){\n\t    case 'W':\n\t      in[i][j]='w';\n\t      break;\n\t    case 'B':\n\t      in[i][j]='b';\n\t      break;\n\t    }\n\t    break;\n\t  }\n\t}\n\tif(cont)continue;\n\t\n\tcont=true;\n\tqueue<PI> Q;\n\tQ.push(mp(i,j));\n\n\twhile(!Q.empty()){\n\t  int cx=Q.front().F,cy=Q.front().S;\n\t  Q.pop();\n\n\t  rep(k,4){\n\t    int nx=cx+dx[k],ny=cy+dy[k];\n\t    if(nx<0 || ny<0 || h<=nx || w<=ny)continue;\n\t    if(in[nx][ny]=='w' || in[nx][ny]=='b')continue;\n\t    if(in[nx][ny]=='W' || in[nx][ny]=='B'){\n\t      if(in[nx][ny]=='W' && in[i][j]=='w')continue;\n\t      if(in[nx][ny]=='B' && in[i][j]=='b')continue;\n\t      cont=false;\n\t      break;\n\t    }\n\t    switch(in[i][j]){\n\t    case 'w':\n\t      in[nx][ny]='w';\n\t      break;\n\t    case 'b':\n\t      in[nx][ny]='b';\n\t      break;\n\t    }\n\t    Q.push(mp(nx,ny));\n\t  }\n\t  if(!cont)break;\n\t}\n\n\tif(cont)continue;\n\n\tqueue<PI> nq;\n\tnq.push(mp(i,j));\n\tin[i][j]='X';\n\t\n\twhile(!nq.empty()){\n\t  int cx=nq.front().F,cy=nq.front().S;\n\t  nq.pop();\n\n\t  rep(k,4){\n\t    int nx=cx+dx[k],ny=cy+dy[k];\n\t    if(nx<0 || ny<0 || h<=nx || w<=ny)continue;\n\t    if(in[nx][ny]=='X' || in[nx][ny]=='W' || in[nx][ny]=='B')continue;\n\t    in[nx][ny]='X';\n\t    nq.push(mp(nx,ny));\n\t  }\n\t}\n      }\n    }\n    int bl=0,wl=0;\n    rep(i,h)rep(j,w){\n      //if(!j)cout<<in[i]<<endl;\n      switch(in[i][j]){\n      case 'w':++wl;break;\n      case 'b':++bl;break;\n      }\n    }\n\n    cout<<bl<<\" \"<<wl<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*{{{*/  //template\n#define rep(i,n) for(int i=0;i<n;i++)\n#define INF 1<<29\n#define LINF LLONG_MAX/3\n#define mp make_pair\n#define pb push_back\n#define EB emplace_back\n#define fi first\n#define se second\n#define all(v) ALL(v)\n#define sz(x) (int)(x).size()\n#define debug(x) cerr<<#x<<\":\"<<x<<endl\n#define debug2(x,y) cerr<<#x<<\",\"<<#y\":\"<<x<<\",\"<<y<<endl\n//struct fin{ fin(){ cin.tie(0); ios::sync_with_stdio(false); } } fin_;\nstruct Double{ double d; explicit Double(double x) : d(x){} };\nostream& operator<<(ostream& os,const Double x){ os << fixed << setprecision(20) << x.d; return os; }\ntemplate<typename T> ostream& operator<<(ostream& os,const vector<T>& vec){ os << \"[\"; for(const auto& v : vec){ os << v << \",\"; } os << \"]\"; return os; }\ntemplate<typename T,typename U> ostream& operator<<(ostream& os,const pair<T,U>& p){ os << \"(\" << p.first << \",\"<< p.second <<\")\"; return os; }\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nll gcd(ll a,ll b){ if(b==0) return a; else return gcd(b,a%b); }\nconstexpr double eps = 1e-14; \nconstexpr ll mod = 1e9+7;\nconst int dx[]={1,0,-1,0} ,dy[] = {0,1,0,-1};\n/*}}}*/\n\nint w,h;\nvector<string> a;\n\nint dfs(int x,int y,vector<vector<bool>>& used){\n    if(a[x][y]=='B') return 1;\n    else if(a[x][y]=='W') return 2;\n\n    used[x][y]=true;\n\n    int ret=0;\n    rep(i,4){\n        int nx=x+dx[i];\n        int ny=y+dy[i];\n        if(nx<0 or nx>=h or ny<0 or ny>=w) continue;\n        if(used[nx][ny]) continue;\n        ret |= dfs(nx,ny,used);\n    }\n    return ret;\n}\n\nvoid solve(){\n    a.assign(h,\"\");\n    rep(i,h) cin>>a[i];\n\n    vvi t(h,vi(w,0));\n    rep(i,h) rep(j,w) if(a[i][j]=='.'){\n        vector<vector<bool>> used(h,vector<bool>(w,false));\n        t[i][j] = dfs(i,j,used);\n    }\n\n    int cnt[4]={0};\n    rep(i,h) rep(j,w){\n        cnt[t[i][j]]++;\n    }\n\n    cout << cnt[1] << \" \" << cnt[2]<< endl;\n}\n\nint main(){\n    while(cin>>w>>h){\n        if(w==0 && h==0) break;\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0; i<n; i++)\n#define INF 1000000\nusing namespace std;\ntypedef pair<int,int> P;\nint dx[] = {1,0,-1,0};\nint dy[] = {0,1,0,-1};\nbool start_flag,color_flag;\nchar table[50][50];\nchar color;\nbool flag_table[50][50];\nint w,h;\nqueue<char> tmp;\nqueue<P> que;\nvoid dfs(int y, int x){\n    que.push(P(y,x));    \n    flag_table[y][x] = true;\n    if(start_flag == true) color = tmp.front();\n    rep(i,4){\n        int ny = y+dy[i];\n        int nx = x+dx[i];\n        if(ny < 0 || nx < 0 || ny >= h || nx >= w || flag_table[ny][nx] == true) continue;\n        if(start_flag == false && table[ny][nx] != '.'){\n            start_flag = true;\n            color = table[ny][nx];\n            tmp.push(color);\n        }\n        else if(start_flag == true && table[ny][nx] != color && table[ny][nx] != '.'){\n            color_flag = true;\n        }\n        if(table[ny][nx] == '.')  dfs(ny,nx);\n    }\n}\nint main(){\n    while(cin >> w >> h){\n        if(h == 0 && w == 0) break;\n        rep(i,h) rep(j,w) cin >> table[i][j];\n        int cnt_black = 0;\n        int cnt_white = 0;\n        rep(i,h) rep(j,w) flag_table[i][j] = false;\n        while(!que.empty()) que.pop();\n        while(!tmp.empty()) tmp.pop();\n        rep(i,h){\n            rep(j,w){\n                start_flag = false;\n                color_flag = false;\n                color = '.';\n                if(table[i][j] != '.' || flag_table[i][j] == true) continue;\n                dfs(i,j);\n                if(color_flag == false){\n                    while(!que.empty()){\n                        pair<int,int> pi = que.front();\n                        que.pop();\n                        table[pi.first][pi.second] = color;\n                        if(color == 'B') cnt_black++;\n                        if(color == 'W') cnt_white++;\n                    }\n                }\n                while(!que.empty()) que.pop();\n                while(!tmp.empty()) tmp.pop();\n            }\n        }\n        cout << cnt_black << \" \" << cnt_white << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nint w, h;\nchar fld[100][100];\nchar a[100][100];\nchar b[100][100];\nint dx[]={0, 0, 1, -1};\nint dy[]={1, -1, 0, 0};\n\n\nvoid rec(int i, int j, char c){\n\n    for(int k=0; k<4; k++){\n        int ni=i+dx[k];\n        int nj=j+dy[k];\n        if(!(0<=ni&&ni<h&&0<=nj&&nj<w)) continue;\n        if(c=='w'){\n            if(a[ni][nj]=='.'){\n                a[ni][nj]=c;\n                rec(ni, nj, c);\n            }else if(a[ni][nj]=='b'){\n                a[ni][nj]='#';\n                rec(ni, nj, c);\n            }\n        }else{\n            if(a[ni][nj]=='.'){\n                a[ni][nj]=c;\n                rec(ni, nj, c);\n            }\n        }\n    }\n}\n\nint main(){\n\n    while(1){\n        cin>> w>> h;\n        if(!(w||h)) break;\n        for(int i=0; i<h; i++){\n            for(int j=0; j<w; j++){\n                cin>> fld[i][j];\n            }\n        }\n\n        for(int i=0; i<h; i++){\n            for(int j=0; j<w; j++){\n                a[i][j]=fld[i][j];\n            }\n        }\n\n        for(int i=0; i<h; i++){\n            for(int j=0; j<w; j++){\n                if(fld[i][j]=='B') rec(i, j, 'b');\n            }\n        }\n        for(int i=0; i<h; i++){\n            for(int j=0; j<w; j++){\n                if(fld[i][j]=='W') rec(i, j, 'w');\n            }\n        }\n        int www=0, bbb=0;\n        for(int i=0; i<h; i++){\n            for(int j=0; j<w; j++){\n                www+=(a[i][j]=='w');\n                bbb+=(a[i][j]=='b');\n            }\n        }\n\n        cout<< bbb<< \" \"<< www<< endl;\n    }\n\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<stack>\n\nusing namespace std;\n\n#define MAX 50\n#define WALL 0\n#define BLANK 1\n#define BLACK 2\n#define WHITE 3\n#define JUDGE 4\n#define NOT 5\n#define BLFIE 6\n#define WHFIE 7\n\nstruct S{\n\tint x,y;\n};\n\nint main(){\n\n\tint h,w;\n\tint field[MAX+5][MAX+5];\n\tchar inp;\n\tS tmp,no;\n\tstack<S> po;\n\tint rean=0;\n\tint dy[]={0,0,1,-1};\n\tint dx[]={1,-1,0,0};\n\tint bcn,wcn;\n\n\twhile(1){\n\n\t\tcin>>w>>h;\n\t\tif(w==0&&h==0) break;\n\n\t\tfor(int i=0;i<=h+1;i++){\n\t\t\tfor(int j=0;j<=w+1;j++){\n\t\t\t\tfield[i][j]=WALL;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=1;i<=h;i++){\n\t\t\tgetchar();\n\t\t\tfor(int j=1;j<=w;j++){\n\t\t\t\tinp=getchar();\n\t\t\t\tswitch(inp){\n\t\t\t\t\tcase '.':\n\t\t\t\t\t\tfield[i][j]=BLANK;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'W':\n\t\t\t\t\t\tfield[i][j]=WHITE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'B':\n\t\t\t\t\t\tfield[i][j]=BLACK;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=1;i<=h;i++){\n\t\t\tfor(int j=1;j<=w;j++){\n\t\t\t\tif(field[i][j]!=BLANK) continue;\n\t\t\t\ttmp.x=j,tmp.y=i;\n\t\t\t\tpo.push(tmp);\n\t\t\t\trean=0;\n\t\t\t\twhile(!po.empty()){\n\t\t\t\t\tno=po.top();\n\t\t\t\t\tpo.pop();\n\t\t\t\t\tfield[no.y][no.x]=JUDGE;\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tswitch(field[no.y+dy[k]][no.x+dx[k]]){\n\t\t\t\t\t\t\tcase WALL:\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase BLACK:\n\t\t\t\t\t\t\t\tif(rean/10==0) rean+=10;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase WHITE:\n\t\t\t\t\t\t\t\tif(rean%10==0) rean+=1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase BLANK:\n\t\t\t\t\t\t\t\ttmp.x=no.x+dx[k];\n\t\t\t\t\t\t\t\ttmp.y=no.y+dy[k];\n\t\t\t\t\t\t\t\tpo.push(tmp);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int k=1;k<=h;k++){\n\t\t\t\t\tfor(int l=1;l<=w;l++){\n\t\t\t\t\t\tif(field[k][l]!=JUDGE) continue;\n\t\t\t\t\t\tswitch(rean){\n\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\tfield[k][l]=WHFIE;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 10:\n\t\t\t\t\t\t\t\tfield[k][l]=BLFIE;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\tfield[k][l]=NOT;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\tbcn=0,wcn=0;\n\t\tfor(int i=1;i<=h;i++){\n\t\t\tfor(int j=1;j<=w;j++){\n\t\t\t\tswitch(field[i][j]){\n\t\t\t\tcase WHFIE:\n\t\t\t\t\twcn++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase BLFIE:\n\t\t\t\t\tbcn++;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<bcn<<\" \"<<wcn<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"random\"\n#include \"ctime\"\n#include \"chrono\"\n#include \"string\"\n#include \"bitset\"\n#include \"algorithm\"\n#include \"map\"\n#include \"queue\"\n\nusing namespace std;\n\n\nint main() {\n\tint H, W;\n\tcin >> W >> H;\n\twhile (H) {\n\t\tvector<string>s(H);\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tcin >> s[i];\n\t\t}\n\t\tint wh = 0;\n\t\tint bl = 0;\n\t\tint dir[] = { 1,0,-1,0,1 };\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tif (s[i][j] != '.') {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbool w = false;\n\t\t\t\tbool b = false;\n\t\t\t\tqueue<pair<int, int>>Q;\n\t\t\t\tQ.push({ i,j });\n\t\t\t\tvector<vector<bool>>flag(H, vector<bool>(W, true));\n\t\t\t\tflag[i][j] = false;\n\t\t\t\twhile (!Q.empty()) {\n\t\t\t\t\tint cy = Q.front().first;\n\t\t\t\t\tint cx = Q.front().second;\n\t\t\t\t\tQ.pop();\n\t\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\t\tint ny = cy + dir[k];\n\t\t\t\t\t\tint nx = cx + dir[k + 1];\n\t\t\t\t\t\tif (ny < 0 || nx < 0 || ny >= H || nx >= W) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!flag[ny][nx]) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (s[ny][nx] == 'W') {\n\t\t\t\t\t\t\tflag[ny][nx] = false;\n\t\t\t\t\t\t\tw = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (s[ny][nx] == 'B') {\n\t\t\t\t\t\t\tflag[ny][nx] = false;\n\t\t\t\t\t\t\tb = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tflag[ny][nx] = false;\n\t\t\t\t\t\t\tQ.push({ ny,nx });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (w&&!b) {\n\t\t\t\t\twh++;\n\t\t\t\t\ts[i][j] = 'W';\n\t\t\t\t}\n\t\t\t\tif (b&&!w) {\n\t\t\t\t\tbl++;\n\t\t\t\t\ts[i][j] = 'B';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << bl << \" \" << wh << endl;\n\t\tcin >> W >> H;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\nint main(){\n\tint w,h;\n\twhile(cin>>w>>h){\n\t\tif(w==0&&h==0) break;\n\t\tint k[w+2][h+2],s[w+2][h+2],nk=0,ns=0;\n\t\tfor(int i=0;i<=h+1;i++){\n\t\t\tk[0][i]=1;\n\t\t\tk[w+1][i]=1;\n\t\t\ts[0][i]=1;\n\t\t\ts[w+1][i]=1;\n\t\t}\n\t\tfor(int i=1;i<=w;i++){\n\t\t\tk[i][0]=1;\n\t\t\tk[i][h+1]=1;\n\t\t\ts[i][0]=1;\n\t\t\ts[i][h+1]=1;\n\t\t}\n\t\tstring str;\n\t\tfor(int i=1;i<=h;i++){\n\t\t\tcin>>str;\n\t\t\tfor(int j=1;j<=w;j++){\n\t\t\t\tif(str[j-1]=='.'){\n\t\t\t\t\tk[j][i]=0;\n\t\t\t\t\ts[j][i]=0;\n\t\t\t\t\tnk++;\n\t\t\t\t\tns++;\n\t\t\t\t}\n\t\t\t\telse if(str[j-1]=='B'){\n\t\t\t\t\tk[j][i]=2;\n\t\t\t\t\ts[j][i]=2;\n\t\t\t\t}\n\t\t\t\telse if(str[j-1]=='W'){\n\t\t\t\t\tk[j][i]=3;\n\t\t\t\t\ts[j][i]=3;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ct=1;\n\t\twhile(nk>0){\n\t\t\tfor(int i=1;i<=h;i++){\n\t\t\t\tfor(int j=1;j<=w;j++){\n\t\t\t\t\tif(k[j][i]==0){\n\t\t\t\t\t\tk[j][i]=6;\n\t\t\t\t\t\tnk--;\n\t\t\t\t\t\tgoto e1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\te1:;\n\t\t\tint ckk=0,cks=0;\n\t\t\tct=1;\n\t\t\twhile(ct>0){\n\t\t\t\tct=0;\n\t\t\t\tfor(int i=1;i<=h;i++){\n\t\t\t\t\tfor(int j=1;j<=w;j++){\n\t\t\t\t\t\tif(k[j][i]==6){\n\t\t\t\t\t\t\tif(k[j+1][i]==0){\n\t\t\t\t\t\t\t\tk[j+1][i]=6;\n\t\t\t\t\t\t\t\tnk--;\n\t\t\t\t\t\t\t\tct++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(k[j-1][i]==0){\n\t\t\t\t\t\t\t\tk[j-1][i]=6;\n\t\t\t\t\t\t\t\tnk--;\n\t\t\t\t\t\t\t\tct++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(k[j][i+1]==0){\n\t\t\t\t\t\t\t\tk[j][i+1]=6;\n\t\t\t\t\t\t\t\tnk--;\n\t\t\t\t\t\t\t\tct++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(k[j][i-1]==0){\n\t\t\t\t\t\t\t\tk[j][i-1]=6;\n\t\t\t\t\t\t\t\tnk--;\n\t\t\t\t\t\t\t\tct++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(k[j+1][i]==2) ckk++;\n\t\t\t\t\t\t\tif(k[j-1][i]==2) ckk++;\n\t\t\t\t\t\t\tif(k[j][i+1]==2) ckk++;\n\t\t\t\t\t\t\tif(k[j][i-1]==2) ckk++;\n\t\t\t\t\t\t\tif(k[j+1][i]==3) cks++;\n\t\t\t\t\t\t\tif(k[j-1][i]==3) cks++;\n\t\t\t\t\t\t\tif(k[j][i+1]==3) cks++;\n\t\t\t\t\t\t\tif(k[j][i-1]==3) cks++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(cks>0||ckk==0){\n\t\t\t\tfor(int i=1;i<=h;i++){\n\t\t\t\t\tfor(int j=1;j<=w;j++){\n\t\t\t\t\t\tif(k[j][i]==6) k[j][i]=5;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(int i=1;i<=h;i++){\n\t\t\t\t\tfor(int j=1;j<=w;j++){\n\t\t\t\t\t\tif(k[j][i]==6) k[j][i]=4;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tct=1;\n\t\twhile(ns>0){\n\t\t\tfor(int i=1;i<=h;i++){\n\t\t\t\tfor(int j=1;j<=w;j++){\n\t\t\t\t\tif(s[j][i]==0){\n\t\t\t\t\t\ts[j][i]=6;\n\t\t\t\t\t\tns--;\n\t\t\t\t\t\tgoto e2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\te2:;\n\t\t\tint csk=0,css=0;\n\t\t\tct=1;\n\t\t\twhile(ct>0){\n\t\t\t\tct=0;\n\t\t\t\tfor(int i=1;i<=h;i++){\n\t\t\t\t\tfor(int j=1;j<=w;j++){\n\t\t\t\t\t\tif(s[j][i]==6){\n\t\t\t\t\t\t\tif(s[j+1][i]==0){\n\t\t\t\t\t\t\t\ts[j+1][i]=6;\n\t\t\t\t\t\t\t\tns--;\n\t\t\t\t\t\t\t\tct++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(s[j-1][i]==0){\n\t\t\t\t\t\t\t\ts[j-1][i]=6;\n\t\t\t\t\t\t\t\tns--;\n\t\t\t\t\t\t\t\tct++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(s[j][i+1]==0){\n\t\t\t\t\t\t\t\ts[j][i+1]=6;\n\t\t\t\t\t\t\t\tns--;\n\t\t\t\t\t\t\t\tct++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(s[j][i-1]==0){\n\t\t\t\t\t\t\t\ts[j][i-1]=6;\n\t\t\t\t\t\t\t\tns--;\n\t\t\t\t\t\t\t\tct++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(s[j+1][i]==2) csk++;\n\t\t\t\t\t\t\tif(s[j-1][i]==2) csk++;\n\t\t\t\t\t\t\tif(s[j][i+1]==2) csk++;\n\t\t\t\t\t\t\tif(s[j][i-1]==2) csk++;\n\t\t\t\t\t\t\tif(s[j+1][i]==3) css++;\n\t\t\t\t\t\t\tif(s[j-1][i]==3) css++;\n\t\t\t\t\t\t\tif(s[j][i+1]==3) css++;\n\t\t\t\t\t\t\tif(s[j][i-1]==3) css++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(csk>0||css==0){\n\t\t\t\tfor(int i=1;i<=h;i++){\n\t\t\t\t\tfor(int j=1;j<=w;j++){\n\t\t\t\t\t\tif(s[j][i]==6) s[j][i]=5;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(int i=1;i<=h;i++){\n\t\t\t\t\tfor(int j=1;j<=w;j++){\n\t\t\t\t\t\tif(s[j][i]==6) s[j][i]=4;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint kazub=0,kazuw=0;\n\t\tfor(int i=1;i<=h;i++){\n\t\t\tfor(int j=1;j<=w;j++){\n\t\t\t\tif(k[j][i]==4) kazub++;\n\t\t\t\tif(s[j][i]==4) kazuw++;\n\t\t\t}\n\t\t}\n\t\tcout<<kazub<<\" \"<<kazuw<<endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n\ntypedef long long ll;\n\nint a[50][50], b[2][50][50];\nint w,h,k;\nint dx[4]={1,-1,0,0} , dy[4]={0,0,1,-1};\n\nbool isok(int i,int j){\n    return i>=0 && i<h && j>=0 && j<w;\n}\n\nvoid dfs(int i,int j){\n    if (!a[i][j])\n        b[k-1][i][j] = 1;\n    REP(s,4){\n        int ii=i+dx[s] , jj=j+dy[s];\n        // cout << ii << \" \" << jj << \" \" << isok(ii,jj) << \" \" << b[k-1][ii][jj] << \" \" << a[ii][jj] << endl;\n        if (isok(ii,jj) && !b[k-1][ii][jj] && !a[ii][jj]){\n            dfs(ii,jj);\n        }\n    }\n}\n\nint main(void) {\n    while (cin>>w>>h && w){\n        REP(i,h){\n            REP(j,w){\n                char c;\n                cin >> c;\n                if (c=='B')\n                    a[i][j] = 1;\n                else if (c=='W')\n                    a[i][j] = 2;\n                else\n                    a[i][j] = 0;\n                b[0][i][j] = 0;\n                b[1][i][j] = 0;\n            }\n        }\n        k=1;\n        REP(i,h){\n            REP(j,w){\n                if (a[i][j]==1)\n                    dfs(i,j);\n            }\n        }\n        cout << endl;\n        k=2;\n        REP(i,h){\n            REP(j,w){\n                if (a[i][j]==2)\n                    dfs(i,j);\n            }\n        }\n        int bl = 0 , wh = 0;\n        REP(i,h){\n            REP(j,w){\n                bl += (b[0][i][j] && !b[1][i][j]);\n                wh += (b[1][i][j] && !b[0][i][j]);\n            }\n        }\n\n        cout << bl << \" \" << wh << endl;\n\n    }\n    \n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<math.h>\n#include<algorithm>\n#include<utility>\n#include<queue>\n#include<string.h>\n#include<string>\n#include<set>\n#include<map>\n#include<vector>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> P;\ntypedef pair<int,bool> BW;\nint W,H;\nstring c[52];\nbool f[52][52];\n\nBW Solve(int h,int w){\n    f[h][w]=true;\n    queue<P> q;\n    q.push(P(h,w));\n    bool Bflag=false;\n    bool Wflag=false;\n    int ans=0;\n    while(!q.empty()){\n        P now=q.front();q.pop();\n        ans++;\n        int dh[4]={0,1,-1,0};\n        int dw[4]={1,0,0,-1};\n        for(int i=0;i<4;i++){\n            int ch=now.first +dh[i];\n            int cw=now.second+dw[i];\n            if(0<=ch && ch<H && 0<=cw && cw<W && f[ch][cw]==false){\n                \n                if(c[ch][cw]=='B'){\n                    Bflag=true;\n                }else if(c[ch][cw]=='W'){\n                    Wflag=true;\n                }else{\n                    q.push(P(ch,cw));\n                    f[ch][cw]=true;\n                }\n            }\n        }\n    }\n    if(Bflag && Wflag){\n        return BW(0,false);\n    }else if(Bflag){\n        return BW(ans,false);\n    }\n    else if(Wflag){\n        return BW(ans,true);\n    }else{\n        return BW(0,false);\n    }\n}\n\nint main(){\n    while(cin>>W>>H,W!=0){\n        for(int i=0;i<H;i++){\n            cin>>c[i];\n            for(int j=0;j<W;j++){\n                f[i][j]=false;\n            }\n        }\n        int Bans=0;\n        int Wans=0;\n        for(int i=0;i<H;i++){\n            for(int j=0;j<W;j++){\n                if(!f[i][j] && c[i][j]=='.'){\n                    BW result=Solve(i,j);\n                    if(result.second==false){\n                        Bans+=result.first;\n                    }else{\n                        Wans+=result.first;\n                    }\n                    /*for(int k=0;k<H;k++){\n                        for(int l=0;l<W;l++){\n                            cout<<f[k][l];\n                        }cout<<endl;\n                    }\n                    /*cout<<\"====================\"<<endl;\n                    cout<<Bans<<\" \" <<Wans<<endl;\n                    cout<<\"====================\"<<endl;*/\n                    \n                }\n            }\n        }\n        cout<<Bans<<\" \"<<Wans<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<string>\nusing namespace std;\nint main(){\n\nint W,H;\nwhile(1){\n\tcin>>W>>H;if(W==0&&H==0)break;\n\tint n[53][53]={};int c=0;\n\tstring str;\n\tfor(int i=1;i<H+1;i++){\n\t\tcin>>str;\n\t\tc++;\n\t\tfor(int j=1;j<W+1;j++)\n\t\t{\n\t\t\t\n\t\t\tif(str[j-1]=='.'){n[i][j]=c;}\n\t\t\tif(str[j-1]=='W'){n[i][j]=3001;c++;}\n\t\tif(str[j-1]=='B'){n[i][j]=3002;c++;}\n\t\t}\n\t}\n\n\t\n\n\tfor(int i=1;i<=H;i++)\n\t\tfor(int j=1;j<=W;j++)\n\t\t{if(n[i][j]<3000){int g[]={n[i-1][j],n[i+1][j],n[i][j-1],n[i][j+1]};\n\tint Q=n[i][j];\n\tif(n[i-1][j]>0&&n[i-1][j]<Q)Q=n[i-1][j];\n\tif(n[i+1][j]>0&&n[i+1][j]<Q)Q=n[i+1][j];\n\tif(n[i][j-1]>0&&n[i][j-1]<Q)Q=n[i][j-1];\n\tif(n[i][j+1]>0&&n[i][j+1]<Q)Q=n[i][j+1];\n\tfor(int I=1;I<=H;I++)\n\t\tfor(int J=1;J<=W;J++)\n\t\t\tfor(int K=0;K<=4;K++)\n\t\t\t\tif(n[I][J]==g[K]&&g[K]<3000)n[I][J]=Q;}\n\t}\n\n\n\tint map[2500]={};\n\tfor(int i=1;i<=H;i++)\n\t\tfor(int j=1;j<=W;j++)\n\t\t\t{if(n[i][j]%3000==1&&n[i][j]>3000){\n\t\t\t\tint G[]={n[i-1][j],n[i+1][j],n[i][j-1],n[i][j+1]};\n\t\t\t\tfor(int k=0;k<4;k++)\n\t\t\t\t\tif(map[G[k]]==0||map[G[k]]==2)map[G[k]]+=1;\n\t\t\t\t}\n\n\t\t\tif(n[i][j]%3000==2&&n[i][j]>3000){\n\t\t\t\tint G[]={n[i-1][j],n[i+1][j],n[i][j-1],n[i][j+1]};\n\t\t\t\tfor(int k=0;k<4;k++)\n\t\t\t\t\tif(map[G[k]]==0||map[G[k]]==1)map[G[k]]+=2;\n\t\t\t}}\n\t\tint cnt[2540]={};\n\t\tfor(int i=1;i<=H;i++)\n\t\tfor(int j=1;j<=W;j++)\n\t\t\tcnt[n[i][j]]++;\n\n\t\t\tint J=0,JJ=0;\n\t\tfor(int i=0;i<W*H;i++)\n\t\t{if(map[i]==1)JJ+=cnt[i];else if(map[i]==2)J+=cnt[i];}\n\n\t\t\n\n\t\tcout<<J<<\" \"<<JJ<<endl;\n}\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\n#define X first\n#define Y second\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nint w, h;\nvs m;\nint dx[] = {-1, 0, 1, 0};\nint dy[] = { 0,-1, 0, 1};\n\nvoid dfs(char tar, pii p);\n\nint main(void){\n    for(; cin >> w >> h, w;){\n        m = vs(h);\n        rep(y, h) cin >> m[y];\n\n        rep(y, h) rep(x, w) if(m[y][x] == 'B'){\n            rep(i, 4){\n                dfs('B', mp(x + dx[i], y + dy[i]));\n            }\n        }\n        rep(y, h) rep(x, w) if(m[y][x] == 'W'){\n            rep(i, 4){\n                dfs('W', mp(x + dx[i], y + dy[i]));\n            }\n        }\n\n        rep(y, h){\n            rep(x, w){\n                cout << m[y][x] << \" \";\n            }\n            cout << endl;\n        }\n        pii sum = mp(0, 0);\n        rep(y, h) sum.first += count(all(m[y]), 'b');\n        rep(y, h) sum.second += count(all(m[y]), 'w');\n\n        cout << sum.first << \" \" << sum.second << endl;\n    }\n\n\treturn 0;\n}\n\nvoid dfs(char tar, pii p){\n    if(p.X < 0 || w <= p.X ||\n       p.Y < 0 || h <= p.Y) return;\n\n    char ene = tar == 'B' ? 'W':'B';\n    char extar = tar == 'B' ? 'b':'w';\n    char exene = tar == 'B' ? 'w':'b';\n\n    if(m[p.Y][p.X] == ene || m[p.Y][p.X] == extar || m[p.Y][p.X] == '-' ||\n       m[p.Y][p.X] == tar)\n        return;\n\n    if(m[p.Y][p.X] == '.') m[p.Y][p.X] = extar;\n    if(m[p.Y][p.X] == exene) m[p.Y][p.X] = '-';\n\n    rep(i, 4){\n        dfs(tar, mp(p.X + dx[i], p.Y + dy[i]));\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//Surrounding Area\n#include<bits/stdc++.h>\nusing namespace std;\n#define TMP 9999\n#define INF 1000\n\nint n, m;\nvector<vector<int> > board;\n\n//4\nint dir[4][2]={{-1,0}, {0,1}, {1,0}, {0,-1}};\n\nvoid print(){\n  for(int i=0; i<n; i++){\n    for(int j=0; j<m; j++)\n      printf(\"%5d\", board[i][j]);\n    puts(\"\");\n  }\n}\n\nbool solve(int x, int y, int c){\n  if(!(0<=x && x<n && 0<=y && y<m))return true;//\n  if(board[x][y]==TMP)return true;//\n  if(board[x][y]==INF)return false;//\n  if(board[x][y]==c)return true;\n  if(board[x][y]==-c)return false;\n  if(board[x][y]==2*c)return true;\n  if(board[x][y]==-2*c)return false;\n  board[x][y]=TMP;\n  bool flag=true;\n  for(int i=0; i<4; i++){\n    if(!solve(x+dir[i][0], y+dir[i][1], c)){\n      flag=false;\n      break;\n    }\n  }\n  if(flag){\n    board[x][y]=c*2;\n    return true;\n  }\n  else{\n    board[x][y]=INF;\n    return false;\n  }\n}\n\nint main(){\n  while(true){\n    cin>>n>>m;\n    board.clear();\n    if(n==0 && m==0)break;\n    for(int i=0; i<n; i++){\n      vector<int> tmp;\n      for(int j=0; j<m; j++){\n        char c;\n        cin>>c;\n        int t;\n        if(c=='.')t=0;\n        if(c=='W')t=1;\n        if(c=='B')t=-1;\n        tmp.push_back(t);\n      }\n      board.push_back(tmp);\n    }\n\n    for(int i=0; i<n; i++){\n      for(int j=0; j<m; j++){\n        if(board[i][j]==1){\n          for(int k=0; k<4; k++)solve(i+dir[k][0], j+dir[k][1], 1);\n        }\n        if(board[i][j]==-1){\n          for(int k=0; k<4; k++)solve(i+dir[k][0], j+dir[k][1], -1);\n        }\n      }\n    }\n    /*\n    puts(\"\");\n    print();\n    puts(\"\");\n    */\n    int nw=0, nb=0;\n    for(int i=0; i<n; i++)\n      for(int j=0; j<m; j++)\n        if(board[i][j]==2)nw++;\n        else if(board[i][j]==-2)nb++;\n    printf(\"%d %d\\n\", nb, nw);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint w, h;\nstring field[50];\n    int dx[4] = {1, 0, -1, 0};\n    int dy[4] = {0, 1, 0, -1};\n\nbool isIn(int x, int y){\n     return 0 <= x && x < h && 0 <= y && y < w;\n}\n\nint check(int x, int y){\n    bool used[50][50];\n    for(int i=0; i < 50; i++) for(int j=0; j< 50; j++) used[i][j] = false;\n    int result = 0;\n\n    queue<pair<int, int> > q;\n    q.push(make_pair(x, y));\n    while(!q.empty()){\n        pair<int, int> p = q.front(); q.pop();\n        if(used[p.first][p.second]) continue;\n        used[p.first][p.second] = true;\n        for(int i=0; i< 4; i++){\n            int nx = p.first+dx[i], ny = p.second+dy[i];\n            if(!isIn(nx, ny)) continue;\n            if(field[nx][ny] != '.'){\n                if(result == 0){\n                    if(field[nx][ny] == 'W') result = 1;\n                    else result = 2;\n                }\n                else {\n                    if(result == 2 && field[nx][ny] == 'W') return -1;\n                    else if(result == 1 && field[nx][ny] == 'B') return -1;\n                }\n            } else {\n                q.push(make_pair(nx, ny));\n            }\n        }\n    }\n    return result;\n}\n\nint main(){\n    while(cin >> w >> h, w+h){\n        for(int i=0; i< h; i++) cin >> field[i];\n\n        int a = 0, b = 0;\n        for(int i=0; i < h; i++){\n            for(int j=0; j < w; j++){\n                if(field[i][j] == '.'){\n                    int r = check(i, j);\n                    if(r == 1) a++;\n                    else if(r == 2) b++;\n                }\n            }\n        }\n        cout << b << \" \" << a << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <array>\n#include <set>\n#include <algorithm>\n\n#define X first\n#define Y second\n\nusing namespace std;\n\nchar table[52][52]; // [x][y]\n\nint dx[4] = { 0, 1, 0, -1 };\nint dy[4] = { 1, 0, -1, 0 };\n\nint g_count[2];\n\nvoid breadth(int x, int y) {\n\tstd::vector<pair<int, int>> queue;\n\tqueue.emplace_back(x,y);\n\tset<char> owner;\n\ttable[x][y] = 'H';\n\tint count = 1;\n\twhile (!queue.empty()) {\n\t\tauto a = queue.back();\n\t\tint x = a.X;\n\t\tint y = a.Y;\n\t\tqueue.pop_back();\n\n\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\tif (table[x + dx[i]][y + dy[i]] == '.') {\n\t\t\t\t++count;\n\t\t\t\tqueue.emplace_back(x + dx[i], y + dy[i]);\n\t\t\t\ttable[x + dx[i]][y + dy[i]] = 'H';\n\t\t\t} else {\n\t\t\t\towner.insert(table[x + dx[i]][y + dy[i]]);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (owner.count('W') != 0 && owner.count('B') == 0) {\n\t\tg_count[1] += count;\n\n\t} else if (owner.count('W') == 0 && owner.count('B') != 0) {\n\t\tg_count[0] += count;\n\t}\n}\n\nint main() {\n\tfor (int i = 0; i < 52; ++i) {\n\t\ttable[i][0] = 'H';\n\t\ttable[0][i] = 'H';\n\t}\n\n\twhile (true) {\n\t\tint w, h;\n\t\tcin >> w >> h;\n\t\tif (w == 0) break;\n\n\t\tg_count[0] = 0;\n\t\tg_count[1] = 0;\n\n\t\tfor (int y = 1; y <= h; ++y) {\n\t\t\tfor (int x = 1; x <= w; ++x) {\n\t\t\t\tcin >> table[x][y];\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < 52; ++i) {\n\t\t\ttable[i][h+1] = 'H';\n\t\t\ttable[w+1][i] = 'H';\n\t\t}\n\n\t\tfor (int x = 1; x <= w; ++x) {\n\t\t\tfor (int y = 1; y <= h; ++y) {\n\t\t\t\tif (table[x][y] != '.') continue;\n\t\t\t\tbreadth(x,y);\n\t\t\t}\n\t\t}\n\t\tcout << g_count[0] << \" \" << g_count[1] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\n#include<vector>\n#include<list>\n#include<stdio.h>\n#include<math.h>\n#include<iomanip>\n#include<map>\n#include<stack>\n#include<queue>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) range(i,0,b)\n#define debug(x) cout << \"debug \" << x << endl;\nusing namespace std;\n\nchar land[55][55];\nint white, black;\nint count;\nint w, h;\nbool ww, bb;\n\nvoid solve(int x, int y){\n    if(land[x][y] == 'W'){\n        ww = true;\n        return;\n    }else if(land[x][y] == 'B'){\n        bb = true;\n        return;\n    }else if(land[x][y] == 'G'){\n        return;\n    }\n    count++;\n    land[x][y] = 'G';\n    solve(x + 1, y);\n    solve(x, y + 1);\n    solve(x - 1, y);\n    solve(x, y - 1);\n}\n\nint main(){\n    while(cin >> w >> h, w||h){\n        white = black = 0;\n        rep(i, h + 2){\n            rep(j,w + 2){\n                land[i][j] = 'G';\n            }\n        }\n        range(i, 1, h+1){\n            scanf(\"%s\", land[i] + 1);\n            land[i][w + 1] = 'G';\n        }\n        range(i, 1, h+1){\n            range(j, 1, w+1){\n                if(land[i][j] == '.'){\n                    ww = bb = false;\n                    count = 0;\n                    solve(i,j);\n                    if(ww && !bb)\n                        white += count;\n                    else if(!ww && bb)\n                        black += count;\n                }\n            }\n        }\n        cout << black << ' ' << white << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n\n#define lengthof(x) (sizeof(x) / sizeof(*(x)))\n\nusing namespace std;\n\nint w,h;\nchar inpMap[51][51]={'0'},ctemp;\nconst int dx[4]={0,0,1,-1},dy[4]={1,-1,0,0};\n\nvoid dfs(int y,int x,char moji){\n\t\t\n\tfor(int i=0;i<4;i++){\n\t\tint nx=x+dx[i];\n\t\tint ny=y+dy[i];\n\n\t\tif(0<=nx && nx<w && 0<=ny && ny<h){\n\t\t\tif(inpMap[ny][nx]=='.'){\n\t\t\t\tinpMap[ny][nx]=ctemp;//(moji=='W')? 'w' : 'b';\n\t\t\t\tdfs(ny,nx,moji);\n\t\t\t}\n\t\t\telse if((moji=='B'&&inpMap[ny][nx]=='w')||(moji=='W'&&inpMap[ny][nx]=='b')){\n\t\t\t\tinpMap[ny][nx]='?';\n\t\t\t\tdfs(ny,nx,moji);\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nvoid solve(int y, int x,char moji){\n\tif(moji=='W'){\n\t\tctemp='w';\n\t}\n\telse if(moji=='B'){\n\t\tctemp='b';\n\t}\n\tdfs(y,x,moji);\n}\n\n\nint main(){\n\t\n\n\twhile(cin>>w>>h,w||h){\n\t\tint white=0,black=0;\n\n\t\tfill((int *)inpMap,(int *)inpMap+lengthof(inpMap),'0');\n\t\t\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tcin>>inpMap[i][j];\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(inpMap[i][j]=='W' || inpMap[i][j]=='B'){\n\t\t\t\t\tsolve(i,j,inpMap[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(inpMap[i][j]=='b'){\n\t\t\t\t\tblack++;\n\t\t\t\t}\n\t\t\t\telse if(inpMap[i][j]=='w'){\n\t\t\t\t\twhite++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout<<black<<' '<<white<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\nint A[60][60];\nint B[60][60];\nint x,y;\nint dx[4]={0,0,1,-1};\nint dy[4]={1,-1,0,0};\nint dfs(int x,int y){\n    A[x][y]=3;\n    int ans=0;\n    REP(i,4){\n        int xx=dx[i]+x;\n        int yy=dy[i]+y;\n        if(A[xx][yy]==0){\n           ans+=dfs(xx,yy);\n        }\n    }\n    return ans+1;\n}\n\nint dfs2(int x,int y){\n    B[x][y]=3;\n    int ans=0;\n    REP(i,4){\n        int xx=dx[i]+x;\n        int yy=dy[i]+y;\n        if(B[xx][yy]==0){\n           ans+=dfs2(xx,yy);\n        }\n    }\n    return ans+1;\n}\n\nint main(){\n    int W,H;\n    while(cin>>W>>H,W+H){\n        REP(i,30){\n            REP(j,30){\n                A[i][j]=1;\n                B[i][j]=1;\n            }\n        }\n        REP(i,H){\n            string s;\n            cin>>s;\n            REP(j,W){\n                if(s[j]=='.'){\n                   A[i+1][j+1]=0;\n                   B[i+1][j+1]=0;\n                }\n                if(s[j]=='B'){\n                   A[i+1][j+1]=2;\n                }\n                if(s[j]=='W'){\n                   B[i+1][j+1]=2;\n                }\n            }\n        }\n        REP(i,H+1){\n            REP(j,W+1){\n                if(A[i][j]==2){\n                   REP(k,4){\n                       int x=i+dx[k];\n                       int y=j+dy[k];\n                       if(A[x][y]==0){\n                          dfs(x,y);\n                       }\n                   }\n                }\n            }\n        }\n        REP(i,H+1){\n            REP(j,W+1){\n                if(B[i][j]==2){\n                   REP(k,4){\n                       int x=i+dx[k];\n                       int y=j+dy[k];\n                       if(B[x][y]==0){\n                          dfs2(x,y);\n                       }\n                   }\n                }\n            }\n        }\n        int w=0;\n        int b=0;\n        REP(i,H+1){\n            REP(j,W+1){\n                if(A[i][j]==3&&B[i][j]!=3)b++;\n                if(A[i][j]!=3&&B[i][j]==3)w++;\n            }\n        }\n        cout<<b<<\" \"<<w<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nenum{NONE,BLA,WHI};\n\nint kui[50][50]={};\nbool rin[50][50][WHI+1]={};\nint W,H;\nint dx[4]={1,-1,0,0};\nint dy[4]={0,0,1,-1};\nvoid clear(){\n     for(int i=0;i<50;i++){\n\t  for(int j=0;j<50;j++){\n\t       kui[i][j]=0;\n\t       rin[i][j][BLA]=false;rin[i][j][WHI]=false;\n\t  }\n     }\n}\nvoid rec(int x,int y,int color){\n     if(x>=W||x<0||y>=H||y<0) return;\n     if(kui[x][y]||rin[x][y][color])return;\n     rin[x][y][color]=true;\n     for(int i=0;i<4;i++){\n\t  rec(x+dx[i],y+dy[i],color);\n     }\n}\n\nint main(){\n     while(cin>>W>>H,W||H){\n\t  for(int i=0;i<W;i++){\n\t       for(int j=0;j<H;j++){\n\t\t    char t;\n\t\t    cin>>t;\n\t\t    switch(t){\n\t\t    case '.':\n\t\t\t break;\n\t\t    case 'B':\n\t\t\t kui[i][j]=BLA;\n\t\t\t break;\n\t\t    case 'W':\n\t\t\t kui[i][j]=WHI;\n\t\t\t break;\n\t\t    }\n\t       }\n\t  }\n\t  for(int i=0;i<W;i++){\n\t       for(int j=0;j<H;j++){\n\t\t    switch(kui[i][j]){\n\t\t    case BLA:\n\t\t\t for(int k=0;k<4;k++) rec(i+dx[k],j+dy[k],BLA);\n\t\t\t break;\n\t\t    case WHI:\n\t\t\t for(int k=0;k<4;k++) rec(i+dx[k],j+dy[k],WHI);\n\t\t\t break;\n\t\t    }\n\t       }\n\t  }\n\t  int sumw=0,sumb=0;\n\t  for(int i=0;i<W;i++){\n\t       for(int j=0;j<H;j++){\n\t\t    if(rin[i][j][BLA]&&(!rin[i][j][WHI]))sumb++;\n\t\t    if(rin[i][j][WHI]&&(!rin[i][j][BLA]))sumw++;\n\t       }\n\t  }\n\t  cout<<sumb<<\" \"<<sumw<<endl;\n\t  clear();\n     }\n     return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n    int dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n    int w,h;\n    while(cin>>w>>h,w||h){\n        vector<vector<int> > field(100,vector<int>(100,0));\n        for(int i=0;i<h;i++){\n            string s;cin>>s;\n            for(int j=0;j<w;j++){\n                if(s[j]=='B') field[i][j]=1;\n                else if(s[j]=='W') field[i][j]=-1;\n            }\n        }\n        vector<vector<int> > black(100,vector<int>(100,0)),\n                            white(100,vector<int>(100,0));\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                if(field[i][j]==1){\n                    queue<P> q;\n                    q.push(P(i,j));\n                    while(!q.empty()){\n                        P p=q.front();q.pop();\n                        int y=p.first,x=p.second;\n                        for(int k=0;k<4;k++){\n                            int ny=y+dy[k],nx=x+dx[k];\n                            if(nx<0||w<=nx||ny<0||h<=ny) continue;\n                            if(field[ny][nx]!=0) continue;\n                            if(black[ny][nx]) continue;\n                            black[ny][nx]=1;q.push(P(ny,nx));\n                        }\n                    }\n                }\n                if(field[i][j]==-1){\n                    queue<P> q;\n                    q.push(P(i,j));\n                    while(!q.empty()){\n                        P p=q.front();q.pop();\n                        int y=p.first,x=p.second;\n                        for(int k=0;k<4;k++){\n                            int ny=y+dy[k],nx=x+dx[k];\n                            if(nx<0||w<=nx||ny<0||h<=ny) continue;\n                            if(field[ny][nx]!=0) continue;\n                            if(white[ny][nx]) continue;\n                            white[ny][nx]=1;q.push(P(ny,nx));\n                        }\n                    }\n                }\n            }\n        }\n        int bl=0,wh=0;\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                if(black[i][j]^white[i][j]){\n                    bl+=black[i][j];wh+=white[i][j];\n                }\n            }\n        }\n        cout<<bl<<\" \"<<wh<<endl;\n    }\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cctype>\n#include<utility>\n#include<string>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<map>\n#include<climits>\n\n#define REP(i, n) for(int i = 0;i < n;i++)\n#define REPR(i, n) for(int i = n;i >= 0;i--)\n#define FOR(i, m, n) for(int i = m;i < n;i++)\n#define FORR(i, m, n) for(int i = m;i >= n;i--)\n#define SORT(v, n) sort(v, v+n);\n#define VSORT(v) sort(v.begin(), v.end());\n#define llong long long\n#define pb(a) push_back(a)\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef long long int ll;\ntypedef pair<ll,ll> LLP;\n#define INF 1000000007\n#define MOD 1000000007\n\n#define ARRAY_MAX 60\nint h,w;\nint dx[4] = {1,0,0,-1};\nint dy[4] = {0,1,-1,0};\nint mp[ARRAY_MAX][ARRAY_MAX];\nint B = 0,W = 0;\n\n\nint dfs(int y,int x,int num,int sum,bool& white,bool& black){\n    //num\n    //yx,\n    mp[y][x] = num;\n    int cnt = 0;//dfs\n\n    //\n    REP(i,4){\n        int nx = x + dx[i], ny = y + dy[i];\n        if(mp[ny][nx] == -2){\n            black = true;\n        }\n        if(mp[ny][nx] == -3){\n            white = true;\n        }\n        if(0 <= nx && nx < w && 0 <= ny && ny < h && mp[ny][nx] == -1){\n            cnt += dfs(ny,nx,num,sum,white,black);\n            cnt++;//\n        }\n    }\n    return cnt;\n}\n\nint solve(){\n    //B,W\n    int res = 0;\n    for(int y = 0;y < h;y++){\n        for(int x = 0;x < w;x++){\n            if(mp[y][x] == -1){\n                bool white = false,black = false;\n                int sum = dfs(y,x,res,1,white,black)+1;//\n                res++;\n                if(black == true && white == false){\n                    B += sum;\n                }else if(black == false && white == true){\n                    W += sum;\n                }\n            }\n        }\n    }\n    return res;\n}\n\nint main(){\n\n    while(cin >> w >> h,h){\n\n        REP(i,ARRAY_MAX){\n            REP(j,ARRAY_MAX){\n                mp[i][j] = INF;//\n            }\n        }\n        REP(i,h){\n            REP(j,w){\n                char c;\n                cin >> c;\n                if(c == '.'){\n                    mp[i][j] = -1;\n                }\n                if(c == 'B'){\n                    mp[i][j] = -2;\n                }\n                if(c == 'W'){\n                    mp[i][j] = -3;\n                }\n                //cin >> mp[i][j];\n            }\n        }\n        \n        solve();\n\n        cout << B << \" \" << W << endl;\n        B = W = 0;\n    }\n\n    \n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define rep(i, a, b) for (int i = (a); i < (int)(b); ++i)\n#define rrep(i, a, b) for (int i = ((int)a) - 1; i >= ((int)a); --i)\n#define all(x) x.begin(), x.end()\n#define sz(x) ((int)x.size())\nusing pii = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\n\nvoid dump_impl(string s) {}\ntemplate <class H, class... T>\nvoid dump_impl(string s, H head, T... tail) {\n    int p = 0;\n    rep(i, 0, sz(s)) {\n        char x = s[i];\n        if (p == 0 && x == ',') {\n            cerr << \"=\" << head << \", \";\n            dump_impl(s.substr(i + 1), tail...);\n            return;\n        } else {\n            cerr << x;\n            if (x == '(') p++;\n            if (x == ')') p--;\n        }\n    }\n}\n#ifdef LOCAL\n#define dump(...) do { cerr << \"\\x1b[33;1m\"; dump_impl(#__VA_ARGS__ \",\", __VA_ARGS__); cerr << \"\\x1b[0m\" << endl; } while (0) \n#else\n#define dump(...)\n#endif\n\nconstexpr int DY[8] = {-1, 0, 1, 0, -1, 1, 1, -1};\nconstexpr int DX[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\nvoid solve(int W, int H) {\n    vector<string> S(H);\n    rep(i, 0, H) cin >> S[i];\n\n    int black = 0, white = 0;\n\n    vvi vis(H, vi(W, -1));\n    rep(i, 0, H) {\n        rep(j, 0, W) {\n            if (vis[i][j] != -1) continue;\n            if (S[i][j] != '.') continue;\n            queue<pii> q;\n            q.push({i, j});\n            vis[i][j] = 1;\n            set<char> chars;\n            int cnt = 0;\n            while (sz(q)) {\n                int y, x;\n                tie(y, x) = q.front(); q.pop();\n                assert(S[y][x] == '.');\n                cnt++;\n\n                rep(dir, 0, 4) {\n                    int yy = y + DY[dir];\n                    int xx = x + DX[dir];\n                    if (yy < 0 || yy >= H || xx < 0 || xx >= W) continue;\n                    if (vis[yy][xx] != -1) continue;\n                    if (S[yy][xx] != '.') {\n                        chars.insert(S[yy][xx]);\n                        continue;\n                    }\n                    vis[yy][xx] = 1;\n                    q.push({yy, xx});\n                }\n            }\n\n            dump(i, j, cnt, sz(chars));\n\n            if (sz(chars) == 1) {\n                if (*chars.begin() == 'B') black += cnt;\n                if (*chars.begin() == 'W') white += cnt;\n            }\n        }\n    }\n\n    cout << black << \" \" << white << endl;\n}\n\nsigned main() {\n    while (1) {\n        int W, H;\n        cin >> W >> H;\n        if (W == 0 && H ==0) break;\n        solve(W, H);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n#include <algorithm>\n#include <string>\n#include <stack>\n#include <queue>\n#include <set>\n#include <cstdio>\n#include <string.h>\n#include <sstream>\n#include <iomanip>\n#include <map>\nusing namespace std;\n\n#define REP(i, n) for(int i = 0; i < n; i++)\n#define RREP(i,n) for(int i=(n)-1;i>=0;i--)\n#define FOR(i, b, e) for(int i = b; i < e; i++)\n#define to_bit(i) static_cast< bitset<8> >(i)\n#define INF (1<<28)\n#define int(n) int n; cin >> n;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> VI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<long long, long long>PLL;\ntypedef queue<int> QI;\ntypedef priority_queue<int> maxpq;\ntypedef priority_queue<int, vector<int>, greater<int> > minpq;\n\nstruct edge{int to, cost;};\n\nvoid begin(){cin.tie(0); ios::sync_with_stdio(false);};\nint gcd(int a, int b){if(a%b==0){return(b);}else{return(gcd(b,a%b));}};\nint lcm(int m, int n){if((0 == m)||(0 == n)){return 0;} return ((m / gcd(m, n)) * n);};\nunsigned long long comb(long n, long m){if(n < m) return 0;\n    unsigned long long c = 1; m = (n - m < m ? n - m : m);\n    for(long ns = n - m + 1, ms = 1; ms <= m; ns ++, ms ++){c *= ns; c /= ms;} return c;};\nint quadratic(int a, int b, int c){return (int)(-b + sqrt(b*b - 4*a*c)) / 2*a;}\n\nvoid cp(int a1[], int a2[], int l){REP(i, l) a2[i] = a1[i];};\nvoid cp(string a1[], string a2[], int l){REP(i, l) a2[i] = a1[i];};\ndouble sq(double d){return d*d;};\nint sq(int i){return i*i;};\ndouble sqdist(int x1, int y1, int x2, int y2){\n    double dx = x1 - x2, dy = y1 - y2; return dx*dx + dy*dy;\n};\nbool inside(int y, int x, int h, int w){return 0 <= y && y <= (h-1) && 0 <= x && x <= (w-1);};\n\n\n// \nbool isCross(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4){\n    // \n    int m = (x2-x1)*(y4-y3)-(y2-y1)*(x4-x3);\n    if(m == 0) return false;\n    // 01\n    double r =(double)((y4-y3)*(x3-x1)-(x4-x3)*(y3-y1))/m;\n    double s =(double)((y2-y1)*(x3-x1)-(x2-x1)*(y3-y1))/m;\n    return (0 < r && r <= 1 && 0 < s && s <= 1);\n};\n\n//  AB CD \nint crossProdct(int ax, int ay, int bx, int by, int cx, int cy, int dx, int dy){\n    int abx = bx - ax; int aby = by - ay;\n    int cdx = dx - cx; int cdy = dy - cy;\n    return abx * cdy - cdx * aby;\n};\ndouble crossProdct(double ax, double ay, double bx, double by, double cx, double cy, double dx, double dy){\n    double abx = bx - ax; double aby = by - ay;\n    double cdx = dx - cx; double cdy = dy - cy;\n    return abx * cdy - cdx * aby;\n};\ndouble innerProduct(double ax, double ay, double bx, double by, double cx, double cy, double dx, double dy){\n    double abx = bx - ax; double aby = by - ay;\n    double cdx = dx - cx; double cdy = dy - cy;\n    return abx * cdx + aby * cdy;\n};\n\n//  ABCP\nbool inTriangle(int ax, int ay, int bx, int by, int cx, int cy, int px, int py){\n    int c1 = crossProdct(ax, ay, bx, by, bx, by, px, py);\n    int c2 = crossProdct(bx, by, cx, cy, cx, cy, px, py);\n    int c3 = crossProdct(cx, cy, ax, ay, ax, ay, px, py);\n    return (c1 > 0 && c2 > 0 && c3 > 0) || (c1 < 0 && c2 < 0 && c3 < 0);\n};\nbool inTriangle(double ax, double ay, double bx, double by, double cx, double cy, double px, double py){\n    double c1 = crossProdct(ax, ay, bx, by, bx, by, px, py);\n    double c2 = crossProdct(bx, by, cx, cy, cx, cy, px, py);\n    double c3 = crossProdct(cx, cy, ax, ay, ax, ay, px, py);\n    return (c1 > 0 && c2 > 0 && c3 > 0) || (c1 < 0 && c2 < 0 && c3 < 0);\n};\n\n// \nvoid circumcenter(double x1, double y1, double x2, double y2, double x3, double y3, double res[3]){\n    double xp1 = (y1-y3)*(y1*y1-y2*y2+x1*x1-x2*x2) - (y1-y2)*(y1*y1-y3*y3+x1*x1-x3*x3);\n    double xp2 = 2*(y1-y3)*(x1-x2)-2*(y1-y2)*(x1-x3);\n    res[0] = xp1/xp2;\n    double yp1 = (x1-x3)*(x1*x1-x2*x2+y1*y1-y2*y2) - (x1-x2)*(x1*x1-x3*x3+y1*y1-y3*y3);\n    double yp2 = 2*(x1-x3)*(y1-y2)-2*(x1-x2)*(y1-y3);\n    res[1] = yp1/yp2;\n    double r = (x3-res[0])*(x3-res[0])+(y3-res[1])*(y3-res[1]);\n    res[2] = sqrt(r);\n}\n\n// \nvoid cal(){\n    string week[7] = {\"Thursday\",\"Friday\",\"Saturday\",\"Sunday\",\"Monday\",\"Tuesday\",\"Wednesday\"};\n    int month[12] = {31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n    vector<string> cal[12];\n    int counter = 0;\n    REP(i, 12) REP(j, month[i]){\n            cal[i].push_back(week[counter%7]);\n            counter++;\n    }\n}\n\n\n\nclass BinaryIndexedTree{\npublic:\n    int n; vector<int> bit;\n    BinaryIndexedTree(int _n){\n        n = _n;\n        bit.resize(n+1,0);\n    }\n    int sum(int i){\n        int sum = 0;\n        while(i > 0){\n            sum += bit[i];\n            i -= i & -i;\n        }\n        return sum;\n    }\n    void add(int i, int v){\n        while(i <= n){\n            bit[i] += v;\n            i += i & -i;\n        }\n    }\n};\n\n\nclass UnionFindTree{\npublic:\n    vector<int> parent, rank;\n    int n;\n    std::set<int> set;\n    // \n    UnionFindTree(int _n){\n        n = _n;\n        for(int i = 0; i < n; i++){\n            parent.resize(n);\n            rank.resize(n);\n            parent[i] = i;\n            rank[i] = 0;\n        }\n    }\n    // \n    int find(int x){\n        if(parent[x] == x){\n            return x;\n        }else{\n            return parent[x] = find(parent[x]);\n        }\n    }\n    // xy\n    void unite(int x, int y){\n        x = find(x);\n        y = find(y);\n        if(x == y){\n            set.insert(x);\n            return;\n        }\n        if(rank[x] < rank[y]){\n            parent[x] = y;\n            set.erase(x);\n            set.insert(y);\n        }else{\n            parent[y] = x;\n            set.erase(y);\n            set.insert(x);\n            if(rank[x] == rank[y]) rank[x]++;\n        }\n    }\n    // xy\n    bool same(int x, int y){\n        return find(x) == find(y);\n    }\n    // \n    int count(){\n        return (int)set.size();\n    }\n};\n\n// \nvoid warshallFloyd(int graph[100][100], int graph_size){\n    for(int mid_node = 0; mid_node < graph_size; mid_node++)\n        for(int s_node = 0; s_node < graph_size; s_node++)\n            for(int g_node = 0; g_node < graph_size; g_node++)\n                if(s_node == g_node) graph[s_node][g_node] = 0;\n                else graph[s_node][g_node] = min(graph[s_node][g_node], graph[s_node][mid_node] + graph[mid_node][g_node]);\n};\n\n\n// d:  n:  s:  dist:\nvoid dijkstra(int graph[1000][1000], int node_count, int start_node, int distances[1000]){\n    // -1\n    REP(i, node_count) distances[i] = -1;\n    distances[start_node] = 0;\n    // pair<int,int> int\n    priority_queue<PII, vector<PII>, greater<PII> > dijkstra_pq;\n    dijkstra_pq.push(PII(0, start_node));\n    while (!dijkstra_pq.empty()) {\n        PII p = dijkstra_pq.top(); dijkstra_pq.pop();\n        int i = p.second;\n        // pop\n        if(distances[i] < p.first) continue;\n        // \n        for(int j = 0; j < node_count; j++){\n            if(graph[i][j] == -1) continue;\n            if(distances[j] == -1){\n                distances[j] = distances[i] + graph[i][j];\n                dijkstra_pq.push(PII(distances[j], j));\n            }else if(distances[j] > distances[i] + graph[i][j]){\n                distances[j] = distances[i] + graph[i][j];\n                dijkstra_pq.push(PII(distances[j], j));\n            }\n        }\n    }\n};\n\n\n\n\n/**\n * start\n * @author yoshikyoto\n */\nstring area[50];\nint color[50][50][2];\n\nint vi[4] = {-1, 1, 0, 0}, vj[4] = {0, 0, -1, 1};\nvoid dfs(int i, int j, int r, int c, int side){\n    // \n    REP(k, 4){\n        int ni = i + vi[k];\n        int nj = j + vj[k];\n        if(inside(ni, nj, r, c) && area[ni][nj] == '.' && !color[ni][nj][side]){\n            color[ni][nj][side] = 1;\n            dfs(ni, nj, r, c, side);\n        }\n    }\n};\n\n\nint main(int argc, const char * argv[]){\n    int r, c;\n    cin >> c >> r;\n    REP(i, r) cin >> area[i];\n    REP(i, r) REP(j, c){\n        color[i][j][0] = 0;\n        color[i][j][1] = 0;\n    }\n    \n    REP(i, r) REP(j, c){\n        if(area[i][j] == 'B'){\n            dfs(i, j, r, c, 0);\n        }else if(area[i][j] == 'W'){\n            dfs(i, j, r, c, 1);\n        }\n    }\n    \n    int black = 0, white = 0;\n    REP(i, r) REP(j, c){\n        if(color[i][j][0] && !color[i][j][1]){\n            black++;\n        }else if(!color[i][j][0] && color[i][j][1]){\n            white++;\n        }\n    }\n    cout << black << \" \" << white << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nstruct DATA{\n\tchar c;\n\tbool w;\n\tbool b;\n\tDATA(){\n\t\tc='.';\n\t\tw=false;\n\t\tb=false;\n\t}\n};\n\nint dx[]={-1, 0, 1, 0};\nint dy[]={ 0,-1, 0, 1};\n\nvoid f(vector<vector<DATA>> &m,int w,int h){\n\tfor(int y=0;y<h;y++){\n\t\tfor(int x=0;x<w;x++){\n\t\t\tif( m[y][x].c!='.') continue;\n\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\tint xx = x+dx[k];\n\t\t\t\tint yy = y+dy[k];\n\t\t\t\tif(xx<0||yy<0||xx>=w||yy>=h)continue;\n\t\t\t\tif( m[yy][xx].c=='W' || m[yy][xx].w){\n\t\t\t\t\tm[y][x].w=true;\n\t\t\t\t}\n\t\t\t\tif( m[yy][xx].c=='B' || m[yy][xx].b){\n\t\t\t\t\tm[y][x].b=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\n\t}\t\n}\n\nint main() {\n\t\n\twhile(true){\n\t\tint w,h;\n\t\tcin >>w>>h;\n\t\tif(w==0&&h==0)break;\n\t\tvector<vector<DATA>> m(h);\n\t\tfor(int y=0;y<h;y++){\n\t\t\tm[y].resize(w);\n\t\t\tfor(int x=0;x<w;x++){\n\t\t\t\tcin >> m[y][x].c;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0;i<w+h;i++){\n\t\t\tf(m,w,h);\n\t\t}\n\t\t\n\t\tint wc=0,bc=0;\n\t\tfor(int y=0;y<h;y++){\n\t\t\tfor(int x=0;x<w;x++){\n\t\t\t\t/*\n\t\t\t\tif(m[y][x].w && m[y][x].b){\n\t\t\t\t\tcout << 'x';\n\t\t\t\t}else\n\t\t\t\tif(m[y][x].w){\n\t\t\t\t\tcout << 'w';\n\t\t\t\t}else\n\t\t\t\tif(m[y][x].b){\n\t\t\t\t\tcout << 'b';\n\t\t\t\t}else\n\t\t\t\t{\n\t\t\t\t\tcout << m[y][x].c;\n\t\t\t\t}\n\t\t\t\t*/\n\t\t\t\t\n\t\t\t\tif(m[y][x].c!='.')continue;\n\t\t\t\tif(m[y][x].w && !m[y][x].b) wc++;\n\t\t\t\tif(m[y][x].b && !m[y][x].w) bc++;\n\t\t\t}\n//\t\t\tcout << endl;\n\t\t}\n\t\t\n\t\tcout << bc << \" \" << wc << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\n#define stlice(from, to) substr(from, (to) - (from) + 1)\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\nusing namespace std;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\nusing vd = vector<double>;\nusing vc = vector<char>;\nusing vb = vector<bool>;\nusing vs = vector<string>;\nusing vpii = vector<pii>;\nusing vvi = vector<vi>;\nusing vvb = vector<vb>;\nusing vvpii = vector<vpii>;\ntemplate<typename A> using fn = function<A>;\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = acos(-1);\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nconstexpr bool odd(const int &n) { return n & 1; }\nconstexpr bool even(const int &n) { return !odd(n); }\nvoid solve();\nmain { solve(); return 0; }\n// clang-format on\n\nvoid solve() {\n  int W, H;\n  while (cin >> W >> H, W) {\n    vs v(H);\n    rep(i, H) cin >> v[i];\n    vvi dp(H, vi(W));\n    int b = 0, w = 0;\n    rep(i, H) rep(j, W) {\n      dp[i][j] = 2 * (v[i][j] == 'B') + (v[i][j] == 'W');\n      b -= v[i][j] == 'B';\n      w -= v[i][j] == 'W';\n    }\n    rep(_, W * H) rep(i, H) rep(j, W) {\n      if (v[i][j] != '.') continue;\n      if (i > 0) dp[i][j] |= dp[i - 1][j];\n      if (j > 0) dp[i][j] |= dp[i][j - 1];\n      if (i < H - 1) dp[i][j] |= dp[i + 1][j];\n      if (j < W - 1) dp[i][j] |= dp[i][j + 1];\n    }\n    rep(i, H) rep(j, W) {\n      b += dp[i][j] == 2;\n      w += dp[i][j] == 1;\n    }\n    cout << b << ' ' << w << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(x) cout << (x) << '\\n'\n#define Int int64_t\n#define fi first\n#define se second\n#define all(x) (x).begin(), (x).end()\n\nInt INF = 1e18;\nint inf = 1e9;\nInt mod = 1e9+7;\n\nint h, w;\nchar field[51][51];\nint black, white;\nint sum;\n\nvoid dfs(int y, int x) {\n    field[y][x] = '#';\n    sum++;\n    int dy[] = {1, 0, -1, 0};\n    int dx[] = {0, 1, 0, -1};\n    for (int i = 0; i < 4; i++) {\n        int ny = y + dy[i];\n        int nx = x + dx[i];\n        if (ny < 0 or ny == h or nx < 0 or nx == w) continue;\n        if (field[ny][nx] == '#') continue;\n        if (field[ny][nx] == 'B') {\n            black++;\n            continue;\n        }\n        if (field[ny][nx] == 'W') {\n            white++;\n            continue;\n        }\n        if (field[ny][nx] == '.') {\n            dfs(ny, nx);\n        }\n    }\n}\n\nint main() {\n    vector<pair<int, int>> res;\n    while (true) {\n        cin >> w >> h;\n        if (h == 0) break;\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                cin >> field[i][j];\n            }\n        }\n        int b_cnt = 0;\n        int w_cnt = 0;\n        for (int i = 0; i < h; i++) {\n           for (int j = 0; j < w; j++) {\n               if (field[i][j] != '.') continue;\n               black = white = sum = 0;\n               dfs(i, j);\n               if (black > 0 and white == 0) {\n                   b_cnt += sum;\n               }\n               else if (white > 0 and black == 0) {\n                   w_cnt += sum;\n               }\n            }\n        }\n        res.emplace_back(b_cnt, w_cnt);\n    }\n    for (int i = 0; i < (int)res.size(); i++) {\n        cout << res[i].fi << \" \" << res[i].se << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,...) for(int i = (a)*(strlen(#__VA_ARGS__)!=0);i<(int)(strlen(#__VA_ARGS__)?__VA_ARGS__:(a));++i)\n#define per(i,a,...) for(int i = (strlen(#__VA_ARGS__)?__VA_ARGS__:(a))-1;i>=(int)(strlen(#__VA_ARGS__)?(a):0);--i)\n#define foreach(i, n) for(auto &i:(n))\n#define all(x) (x).begin(), (x).end()\n#define bit(x) (1ll << (x))\n#define lambda(RES_TYPE, ...) (function<RES_TYPE(__VA_ARGS__)>)[&](__VA_ARGS__) -> RES_TYPE\n#define method(FUNC_NAME, RES_TYPE, ...) function<RES_TYPE(__VA_ARGS__)> FUNC_NAME = lambda(RES_TYPE, __VA_ARGS__)\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int,int>;\nusing pll = pair<ll,ll>;\n//const ll MOD = (ll)1e9+7;\nconst ll MOD = 998244353;\nconst int INF = (ll)1e9+7;\nconst ll INFLL = (ll)1e18;\ntemplate<class t>\nusing vvector = vector<vector<t>>;\ntemplate<class t>\nusing vvvector = vector<vector<vector<t>>>;\ntemplate<class t>\nusing priority_queuer = priority_queue<t, vector<t>, greater<t>>;\ntemplate<class t, class u> bool chmax(t &a, u b){if(a<b){a=b;return true;}return false;}\ntemplate<class t, class u> bool chmin(t &a, u b){if(a>b){a=b;return true;}return false;}\n#ifdef DEBUG\n#define debug(x) cout<<\"LINE \"<<__LINE__<<\": \"<<#x<<\" = \"<<x<<endl;\n#else\n#define debug(x) (void)0\n#endif\n\nnamespace templates{\n  ll modpow(ll x, ll b){\n    ll res = 1;\n    while(b){\n      if(b&1)res = res * x % MOD;\n      x = x * x % MOD;\n      b>>=1;\n    }\n    return res;\n  }\n\n  ll modinv(ll x){\n    return modpow(x, MOD-2);\n  }\n\n  bool was_output = false;\n  template<class t>\n  void output(t a){\n    if(was_output)cout << \" \";\n    cout << a;\n    was_output = true;\n  }\n  void outendl(){\n    was_output = false;\n    cout << endl;\n  }\n  ll in(){\n    ll res;\n    scanf(\"%lld\", &res);\n    return res;\n  }\n\n  template<class t>\n  istream& operator>>(istream&is, vector<t>&x){\n    for(auto &i:x)is >> i;\n    return is;\n  }\n\n  template<class t, class u>\n  istream& operator>>(istream&is, pair<t, u>&x){\n    is >> x.first >> x.second;\n    return is;\n  }\n\n  template<class t>\n  void in(t&x){\n    cin >> x;\n  }\n\n  template<class t>\n  t in(){\n    t res; cin >> res; return res;\n  }\n\n  template<class t>\n  void out(t x){\n    cout << x;\n  }\n\n  template<class t>\n  vector<t> sorted(vector<t> line,function<bool(t,t)> comp=[](t a,t b){return a<b;}){\n    sort(line.begin(),line.end(),comp);\n    return line;\n  }\n\n  template<class t>\n  vector<t> reversed(vector<t> line){\n    reverse(line.begin(),line.end());\n    return line;\n  }\n}\n\nusing namespace templates;\n\nstring func(int w,int h){\n    vvector<char> board(h,vector<char>(w));\n    vvector<int> color(h,vector<int>(w,0));\n    rep(i,h){\n        rep(j,w){\n            board[i][j] = in<char>();\n        }\n    }\n    method(tocolor,int,char x){\n        if(x=='B')return 1;\n        if(x=='W')return 2;\n        return 0;\n    };\n    method(func,void,int y,int x,int c){\n        if(min(y,x)<0 or y >= h or x >= w)return;\n        if(tocolor(board[y][x]) and tocolor(board[y][x]) != c)return;\n        if(color[y][x] bitand c)return;\n        color[y][x] |= c;\n        func(y+1,x,c);\n        func(y-1,x,c);\n        func(y,x+1,c);\n        func(y,x-1,c);\n    };\n\n    rep(i,h){\n        rep(j,w){\n            if(tocolor(board[i][j])){\n                func(i,j,tocolor(board[i][j]));\n            }\n        }\n    }\n    int black = 0;\n    int white = 0;\n    rep(i,h){\n        rep(j,w){\n            if(!tocolor(board[i][j])){\n                if(color[i][j]==1){\n                    ++black;\n                }\n                if(color[i][j]==2){\n                    ++white;\n                }\n            }\n        }\n    }\n    return to_string(black) + \" \" + to_string(white);\n}\n\nint main(){\n    int n,m;\n    while(true){\n        n = in();\n        m = in();\n        if(!n)break;\n        cout << func(n,m) << endl;\n    }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <queue>\n\nusing namespace std;\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n\n#define all(v) v.begin(),v.end()\n#define INF 1<<30\n#define mp make_pair\n#define pb push_back\n\n#define fi first\n#define se second\n\n#define each(it,c) for(auto it=(c).begin();it!=(c).end();it++)\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\ntypedef vector<pair<int, int> > vp;\n\ntypedef long long ll;\n\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1}; \n\nint main(){\n  while(1){\n    int w,h;\n    int aa=0;\n    int bb=0;\n    string a[55];\n    string b[55];\n    cin >> w >> h;\n    if(w==0)break;\n    rep(i,h){\n      cin >> a[i];\n      b[i] = a[i];\n    }\n    bool f = true;\n    rep(y,h){\n      rep(x,w){\n        if(a[y][x]=='W'||a[y][x]=='B') f = false;\n      }\n    }\n    if(f){\n      cout << 0 << \" \" << 0 << endl;\n      continue;\n    }\n    rep(y,h){\n      rep(x,w){\n        if(a[y][x]=='W'){\n          \n          queue<pii> que;\n          que.push(mp(x,y));\n          \n          while(!que.empty()){\n            int yy = que.front().se;\n            int xx = que.front().fi;\n            a[yy][xx]='w';\n            que.pop();\n            rep(i,4){\n              if(a[yy+dy[i]][xx+dx[i]]=='.'){\n                que.push(mp(xx+dx[i],yy+dy[i]));\n              }\n            }\n          }\n        }\n      }\n    }\n    rep(y,h){\n      rep(x,w){\n        if(a[y][x]=='.'){\n          bb++;\n        }\n      }\n    }\n    rep(y,h){\n      rep(x,w){\n        if(b[y][x]=='B'){\n          \n          queue<pii> que;\n          que.push(mp(x,y));\n          \n          while(!que.empty()){\n            int yy = que.front().se;\n            int xx = que.front().fi;\n            b[yy][xx]='b';\n            que.pop();\n            rep(i,4){\n              if(b[yy+dy[i]][xx+dx[i]]=='.'){\n                que.push(mp(xx+dx[i],yy+dy[i]));\n              }\n            }\n          }\n        }\n      }\n    }\n    rep(y,h){\n      rep(x,w){\n        if(b[y][x]=='.'){\n          aa++;\n        }\n      }\n    }\n    cout<<bb << \" \"<<aa<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <cstring>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n#define I(n,m) if(find(v.begin(),v.end(),make_pair(n,m))==v.end())ret|=D(n,m,v);\ntypedef vector<pair<int,int> >V;\nchar m[99][99];\n\nint D(int i,int j,V&v){\n\tif(m[i][j]=='B')return 1;\n\tif(m[i][j]=='W')return 2;\n\tif(m[i][j]=='X')return 0;\n\tint ret=0;\n\tv.push_back(make_pair(i,j));\n\tI(i-i,j)I(i+1,j)I(i,j-1)I(i,j+1)\n\treturn ret;\n}\n\nmain(){\n\tint w,h,i,j,r,s;\n\tfor(;scanf(\"%d%d\",&w,&h),w;printf(\"%d %d\\n\",r,s)){\n\t\tfor(memset(m,'X',sizeof(m)),r=s=0,i=1;i<=h;i++)scanf(\"%s\",m[i]+1),m[i][w+1]='X';\n\t\tfor(i=1;i<=h;i++)for(j=1;j<=w;j++)if(m[i][j]=='.'){\n\t\t\tV v;for(int x=D(i,j,v),k=0;k<v.size();k++)\n\t\t\t\tm[v[k].first][v[k].second]=x;\n\t\t}\n\t\tfor(i=1;i<=h;i++)for(j=1;j<=w;j++)\n\t\t\tif(m[i][j]==1)r++;\n\t\t\telse if(m[i][j]==2)s++;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint w, h;\nint dx[] = {0,0,1,-1};\nint dy[] = {1,-1,0,0};\nstring f[51];\n\nvoid solve(int x , int y , char c ){\n\tfor(int i=0 ; i<4 ; i++ ){\n\t\tint mx = x + dx[i];\n\t\tint my = y + dy[i];\n\t\tif( mx < 0 || mx > w || my < 0 || my > h ) continue;\n\t\tif( f[my][mx] == '.' ){\n\t\t\tf[my][mx] = ( c == 'W' )? 'w' : 'b' ;\n\t\t\tsolve( mx , my , c );\n\t\t}else if( c == 'B' && f[my][mx] == 'w' ){\n\t\t\tf[my][mx] = '?';\n\t\t\tsolve( mx , my , 'B' );\n\t\t}\n\t}\n}\n\nint main(){\n\twhile( cin >> w >> h , w || h ){\n\t\tint white=0, black=0;\n\t\tfor(int i=0 ; i < h ; i++ ){\n\t\t\tcin >> f[i];\n\t\t}\n\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\t\tif( f[y][x] == 'W' ){\n\t\t\t\t\tsolve( x , y , 'W' );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\t\tif( f[y][x] == 'B' ){\n\t\t\t\t\tsolve( x , y , 'B' );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\t\tif( f[y][x] == 'b' ){\n\t\t\t\t\tblack++;\n\t\t\t\t}else if( f[y][x] == 'w' ){\n\t\t\t\t\twhite++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << black << \" \" << white << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;++i)\n#define rep1(i,n) for(int i=1;i<=n;++i)\nusing namespace std;\nint a[52][52]={};\nint dx[4]={0,0,-1,1};\nint dy[4]={-1,1,0,0};\nint h,w;\n\n//color 0=. 1=B -1=W 2=b -2=w 10=*\n\nvoid paint(int y,int x,int color){\n    if((fabs(a[y][x])!=2 && a[y][x]!=0) || a[y][x]==color)return;//\n    if(fabs(a[y][x]-color)==4)color = 10;\n    a[y][x] = color;\n    rep(i,4)paint(y+dy[i],x+dx[i],color);\n}\n\nint main(void){\n    char tmp;\n    while(cin>>w>>h, w|h){\n        int cntB=0,cntW=0;\n        /*??\\???*/\n        rep1(y,h){\n            rep1(x,w){\n                cin>>tmp;\n                if(tmp=='.')a[y][x] = 0;\n                else if(tmp=='B')a[y][x] = 1;\n                else a[y][x] = -1;\n            }\n        }\n\n        /*???????*/\n        rep(y,h+2)a[y][0]=a[y][w+1] = 100;\n        rep(x,w+2)a[0][x]=a[h+1][x] = 100;\n\n        /*????????????*/\n        rep1(y,h){\n            rep1(x,w){\n                if(a[y][x] == 1)      rep(i,4)paint(y+dy[i],x+dx[i],2);\n                else if(a[y][x] == -1)rep(i,4)paint(y+dy[i],x+dx[i],-2);\n            }\n        }\n\n        rep1(y,h){\n            rep1(x,w){\n                if(a[y][x]==2)cntB++;\n                else if(a[y][x]==-2)cntW++;\n            }\n        }\n        cout<<cntB<<\" \"<<cntW<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Surrouding Area\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define X '@'//?????????????????????????????\n#define Z ':'//????????\nint dx[4]={-1, 0, 1, 0}, dy[4]={0, 1, 0, -1};\nint w, h;\nvector<string> a;\n\nbool solve(int x, int y, char c){\n  if(!(0<=x && x<h && 0<=y && y<w))return true;\n  if((a[x][y]==X) || (c=='W' && a[x][y]=='B') || (c=='B' && a[x][y]=='W'))return false;\n  if((a[x][y]==Z) || (c==a[x][y]) || (c=='W' && a[x][y]=='w') || (c=='B' && a[x][y]=='b'))return true;\n  a[x][y]=Z;\n\n  bool flag=true;\n  for(int i=0; i<4; i++){\n    int nx=x+dx[i], ny=y+dy[i];\n    if(!solve(nx, ny, c)){flag=false; break;}\n  }\n  if(flag){\n    if(c=='W')a[x][y]='w';\n    else if(c=='B')a[x][y]='b';\n    return true;\n  }\n  else{\n    a[x][y]=X;\n    return false;\n  }\n}\n\nint main(){\n  while(cin>>w>>h, !(w==0&&h==0)){\n    a.clear();\n    for(int i=0; i<h; i++){\n      string tmp;\n      cin>>tmp;\n      a.push_back(tmp);\n    }\n    for(int i=0; i<h; i++)\n      for(int j=0; j<w; j++)\n\tif(a[i][j]=='W')\n\t  for(int k=0; k<4; k++)\n\t    solve(i+dx[k], j+dy[k], 'W');\n\telse if(a[i][j]=='B')\n\t  for(int k=0; k<4; k++)\n\t    solve(i+dx[k], j+dy[k], 'B');\n\n    int wcnt=0, bcnt=0;\n    for(int i=0; i<h; i++)\n      for(int j=0; j<w; j++)\n\tif(a[i][j]=='w')wcnt++;\n\telse if(a[i][j]=='b')bcnt++;\n    cout<<bcnt<<\" \"<<wcnt<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": ""
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\nint w,h;\nvector<string> ss;\nbool is_write[52][52];\nbool is_black[52][52];\n\nvoid dfs(int x_,int y_,bool (*f_)[52],bool f2) {\n    //cout<<x_<<\",\"<<y_<<endl;\n    if(f_[x_][y_]||(ss[x_][y_]!='.'&&f2)) return;\n    f_[x_][y_]=true;\n    rep(i,4) {\n        int x = x_ + dx[i];\n        int y = y_ + dy[i];\n        if(0<=x&&x<ss.size() && 0<=y&&y<ss[x].size()) {\n            dfs(x,y,f_,true);\n        }\n    }\n}\n\nvoid solve() {\n    rep(i,52) rep(j,52) is_write[i][j]=is_black[i][j]=false;\n    ss.resize(w);\n    rep(i,h) {\n        string t; cin>>t;\n        ss[i] = t;\n    }\n    int ans_b=0,ans_w=0;\n    rep(i,ss.size()) {\n        rep(j,ss[i].size()) {\n            if(ss[i][j]=='B') dfs(i,j,is_black,false);\n            if(ss[i][j]=='W') dfs(i,j,is_write,false);\n        }\n    }\n    rep(i,ss.size()) rep(j,ss[i].size()) {\n        //cout<<i<<\",\"<<j<<\":\"<<is_write[i][j]<<\",\"<<is_black[i][j]<<ss[i][j]<<endl;\n        if(ss[i][j]=='.'&&(is_write[i][j]^is_black[i][j])) {\n           if(is_write[i][j]) ans_w++;\n           else ans_b++; \n        }\n    }\n    cout<<ans_b<<\" \"<<ans_w<<endl;\n    ss.clear();\n}\n\nint main() {\n    while(cin>>w>>h) {\n        if(w+h==0) return 0;\n        solve();\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing VI = vector<ll>;\nusing VV = vector<VI>;\nusing VS = vector<string>;\n\n// tourist set\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\n\nvoid debug_out() { cerr << '\\n'; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n// tourist set end\n\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n\n#define FOR(i,a,b) for(ll i=(a);i<(b);++i)\n#define rep(i,b) FOR(i, 0, b)\n#define ALL(v) (v).begin(), (v).end()\n#define p(s) cout<<(s)<<'\\n'\n#define p2(s, t) cout << (s) << \" \" << (t) << '\\n'\n#define br() p(\"\")\n#define pn(s) cout << (#s) << \" \" << (s) << '\\n'\n#define p_yes() p(\"YES\")\n#define p_no() p(\"NO\")\n#define SZ(x) ((int)(x).size())\n#define SORT(A) sort(ALL(A))\n#define RSORT(A) sort(ALL(A), greater<ll>())\n\nvoid no(){p_no(); exit(0);}\nvoid yes(){p_yes(); exit(0);}\n\nconst ll mod = 1e9 + 7;\nconst ll inf = 1e18;\nconst double PI = acos(-1);\n\nll W, H;\n\nbool in_range(ll i, ll j){\n  if(0<=i && i<H && 0<=j && j<W){\n    return true;\n  }else{\n    return false;\n  }\n}\n\nusing PII = pair<ll, ll>;\n#define MP make_pair\nint dx[4] = {-1, 0, 1,  0};\nint dy[4] = { 0, 1, 0, -1};\n\nstring S[100];\n\nPII pour(ll i, ll j){\n  queue<PII> que;\n  que.push(MP(i, j));\n  S[i][j]='c';\n  ll cnt = 1;\n  bool touch_black = false;\n  bool touch_white = false;\n  while(!que.empty()){\n    auto pa = que.front(); que.pop();\n    rep(i, 4){\n      ll ty = pa.first + dy[i];\n      ll tx = pa.second+ dx[i];\n      if(in_range(ty, tx)){\n        if(S[ty][tx]=='.'){\n          que.push(MP(ty, tx));\n          S[ty][tx] = 'c';\n          cnt++;\n        }\n        if(S[ty][tx]=='B') touch_black = true;\n        if(S[ty][tx]=='W') touch_white = true;\n      }\n    }\n  }\n  // 0 : not touch\n  // 1 : white touch\n  // 2 : black touch\n  // 3 : both touch\n  ll status;\n  if(touch_black && touch_white){\n    status = 3;\n  }else if(touch_black){\n    status = 2;\n  }else if(touch_white){\n    status = 1;\n  }else{\n    status = 0;\n  }\n  return MP(status, cnt);\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while(cin >> W >> H){\n      if(W==0) return 0;\n\n      rep(i, H){\n        cin >> S[i];\n      }\n\n      ll black = 0;\n      ll white = 0;\n      rep(i, H){\n        rep(j, W){\n          if(S[i][j]=='.'){\n            auto pa = pour(i, j);\n            if(pa.first==2){\n              black += pa.second;\n            }\n            else if(pa.first==1){\n              white += pa.second;\n            }\n          }\n        }\n      }\n      p2(black, white);\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0; i<n; i++)\n#define INF 1000000\nusing namespace std;\ntypedef pair<int,int> P;\nint dx[] = {1,0,-1,0};\nint dy[] = {0,1,0,-1};\nbool start_flag,color_flag;\nchar table[50][50];\nchar color;\nbool flag_table[50][50];\nint w,h;\nqueue<char> tmp;\nqueue<P> que;\nvoid dfs(int y, int x){\n    que.push(P(y,x));    \n    flag_table[y][x] = true;\n    if(start_flag == true) color = tmp.front();\n    rep(i,4){\n        int ny = y+dy[i];\n        int nx = x+dx[i];\n        if(ny < 0 || nx < 0 || ny >= h || nx >= w || flag_table[ny][nx] == true) continue;\n        if(start_flag == false && table[ny][nx] != '.'){\n            start_flag = true;\n            color = table[ny][nx];\n            tmp.push(color);\n        }\n        else if(start_flag == true && table[ny][nx] != color && table[ny][nx] != '.'){\n            color_flag = true;\n        }\n        if(table[ny][nx] == '.')  dfs(ny,nx);\n    }\n}\nint main(){\n    while(cin >> w >> h){\n        if(h == 0 && w == 0) break;\n        rep(i,h) rep(j,w) cin >> table[i][j];\n        int cnt_black = 0;\n        int cnt_white = 0;\n        rep(i,h) rep(j,w) flag_table[i][j] = false;\n        while(!que.empty()) que.pop();\n        while(!tmp.empty()) tmp.pop();\n        rep(i,h){\n            rep(j,w){\n                start_flag = false;\n                color_flag = false;\n                color = '.';\n                if(table[i][j] != '.' || flag_table[i][j] == true) continue;\n                dfs(i,j);\n                if(color_flag == false){\n                    while(!que.empty()){\n                        pair<int,int> pi = que.front();\n                        que.pop();\n                        table[pi.first][pi.second] = color;\n                        if(color == 'B') cnt_black++;\n                        if(color == 'W') cnt_white++;\n                    }\n                }\n                while(!que.empty()) que.pop();\n                while(!tmp.empty()) tmp.pop();\n            }\n        }\n        cout << cnt_black << \" \" << cnt_white << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint w,h,c1,c2,b,d;\nchar a[51][51];\nint dfs(int i,int j){\n  if(i==h||j==w||i<0||j<0||a[i][j]=='#')return 0;\n  if(a[i][j]=='W'){d++;return 0;}\n  else if(a[i][j]=='B'){b++;return 0;}\n  int s=1;\n  a[i][j]='#';\n  s+=dfs(i+1,j);\n  s+=dfs(i-1,j);\n  s+=dfs(i,j+1);\n  s+=dfs(i,j-1);\n  return s;\n}\nint main(){\n  int i,j,ans;\n  while(cin>>w>>h,w&&h){\n    c1=c2=0;\n    for(i=0;i<h;i++)scanf(\"%c\",&a[i]);\n    for(i=0;i<h;i++)for(j=0;j<w;j++)if(a[i][j]=='.'){\n      d=b=0;\n      ans=dfs(i,j);\n      if(b&&d)continue;\n      else if(b>d)c1+=ans;\n      else if(b<d)c2+=ans;\n    }\n    cout<<c1<<\" \"<<c2<<endl;\n}}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\nusing namespace std;\n\nint w,h;\nchar maps[51][51];\nbool closed[51][51];\nint dx[]={0,0,1,-1};\nint dy[]={-1,1,0,0};\n\nchar check(int i,int j)\n{\n  // cout<<i<<\" \"<<j<<endl;\n  if(i<0 || i>=h || j<0 || j>=w)\n    return 'X';\n  if(maps[i][j]!='.')\n    return maps[i][j];\n  if(closed[i][j])\n    return 'X';\n  closed[i][j]=true;\n  char tmp='X';\n  for(int xx=0;xx<4;xx++)\n    {\n      char tt=check(i+dx[xx],j+dy[xx]);\n      if(tmp=='X' || tmp==tt)\n\ttmp=tt;\n      else if(tt!='X')\n\t{\n\t  tmp='Z';\n\t  break;\n\t}\n    }\n  //maps[i][j]=tmp;\n  //  cout<<i<<\" \"<<j<<\" \"<<tmp<<endl;\n  return tmp;\n}\n\nint main()\n{\n  for(;cin>>w>>h,w;)\n    {\n      int ans[2]={0,0};\n      for(int i=0;i<h;i++)\n\tfor(int j=0;j<w;j++)\n\t  {\n\t    cin>>maps[i][j];\n\t    if(maps[i][j]=='B')\n\t      ans[0]--;\n\t    if(maps[i][j]=='W')\n\t      ans[1]--;\n\t  }\n\n      for(int i=0;i<h;i++)\n\tfor(int j=0;j<w;j++)\n\t  {\n\t    memset(closed,false,sizeof(closed));\n\t    maps[i][j]=check(i,j);\n\t    char tmp=maps[i][j];\n\t    if(tmp=='B')\n\t      ans[0]++;\n\t    if(tmp=='W')\n\t      ans[1]++;\n\t  }\n      /*\n      for(int i=0;i<h;i++)\n\tfor(int j=0;j<w;j++)\n\t  {\n\t    cout<<\t    maps[i][j];\n\t    if(j==w-1)\n\t      cout<<endl;\n\t  }\n      */\n      cout<<ans[0]<<\" \"<<ans[1]<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <map>\n#include <list>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <ctype.h>\n#include <ctime>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <bitset>\n#include <cctype>\n#include <cstdlib>\n#include <cstring>\n#include <utility>\n#include <numeric>\n#include <complex>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n#include <iostream>\n#include <iterator>\n#include <algorithm>\n\nusing namespace std;\n\n#define REP(i, x, n) for(int i = x; i < n; i++)\n#define rep(i, n) REP(i, 1, n)\n#define lengthof(x) (sizeof(x) / sizeof(*(x)))\n#define FILL(ptr, value) FILL_((ptr), sizeof(ptr)/sizeof(value), (value))\ntemplate <typename T>\nvoid FILL_(void * ptr, size_t size, T value){\n  std::fill((T*)ptr, (T*)ptr+size, value);\n}\n//4\nconst int dx[] ={1,0,-1,0};\nconst int dy[] ={0,-1,0,1};\nint w,h;\nchar board[55][55];\nint WS,BS;\nbool white[55][55];\nbool black[55][55];\nvoid dfsw(int y,int x){\n  if(white[y][x]||board[y][x] != '.')\n    return;\n  white[y][x] =true;\n  for(int k = 0;k < 4;k++){\n    int nx = x +dx[k];\n    int ny = y +dy[k];\n    if(nx <=0||nx >w||ny <=0||ny >h)\n      continue;\n    else\n      dfsw(ny,nx); \n  }\n}\nvoid dfsb(int y,int x){\n  if(black[y][x]||board[y][x] != '.')\n    return;\n  black[y][x] =true;\n  for(int k = 0;k < 4;k++){\n    int nx = x +dx[k];\n    int ny = y +dy[k];\n    if(nx <=0||nx >w||ny <=0||ny >h)\n      continue;\n    else\n      dfsb(ny,nx); \n  }\n}\nint main()\n{\n  while(cin>>w>>h,w||h){\n    for(int i = 1;i <=h;i++){\n      for(int j = 1;j <=w;j++){\n\tcin>>board[i][j];\n\twhite[i][j] = false;\n\tblack[i][j] = false;\n      }\n    }\n    for(int i = 1;i <=h;i++){\n      for(int j = 1;j <=w;j++){\n\tif(board[i][j] =='W'){\n\t  for(int k = 0;k < 4;k++){\n\t    int nx = j +dx[k];\n\t    int ny = i +dy[k];\n\t    if(nx <=0||nx >w||ny <=0||ny >h)\n\t      continue;\n\t    else\n\t      dfsw(ny,nx);\n\t}\n      }\n\tif(board[i][j] =='B'){\n\t  for(int k = 0;k < 4;k++){\n\t    int nx = j +dx[k];\n\t    int ny = i +dy[k];\n\t    if(nx <=0||nx >w||ny <=0||ny >h)\n\t      continue;\n\t    else\n\t      dfsb(ny,nx);\n\t  }\n\t}\n      }\n    }\n    WS = 0;\n    BS = 0;\n    for(int i = 1;i <=h;i++){\n      for(int j = 1;j <=w;j++){\n\tif(board[i][j] !='.'||(white[i][j]&&black[i][j])||\n\t   (!white[i][j]&&!black[i][j]))\n\t  continue;\n\tif(white[i][j])\n\t  WS++;\n\telse\n\t  BS++;\n      }\n    }\n    cout <<BS<<\" \"<<WS<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nvoid dfs(int,int);\nint w,h,mat[50][50],flagb,flagw,cnt;\nint main(){\n  int i,j,bcnt,wcnt;\n  string data[50];\n  while(1){\n    bcnt=0;\n    wcnt=0;\n    cin >> w >> h;\n    if(w==0&&h==0) break;\n    for(i=0;i<h;i++){\n      cin >> data[i];\n    }  \n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n        if(data[i][j]=='B') mat[i][j]=1;\n        else if(data[i][j]=='W') mat[i][j]=2;\n        else mat[i][j]=0;\n      }\n    }\n   \n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tcnt=0;\n\tflagb=0;\n\tflagw=0;\n        if(mat[i][j]==0){\n\t  dfs(i,j);\n\t  if(flagb==1&&flagw==1){\n\t    bcnt+=0;\n\t    wcnt+=0;\n\t  }\n\t  else if(flagb==1){\n\t    bcnt+=cnt;\n\t  }\n          else if(flagw==1){\n\t    wcnt+=cnt;\n\t  }\n\t}\n      }\n    }\n    cout << bcnt << ' ' << wcnt << endl;\n  }\n  return 0;\n}\nvoid dfs(int i,int j){\n  if(mat[i][j]==3) return ;\n  if(mat[i][j]==1){\n    flagb=1;\n    return ;\n  }\n  if(mat[i][j]==2){\n    flagw=1;\n    return ;\n  }\n  if(mat[i][j]==0){\n    cnt++;\n  } \n  if(mat[i][j]==3) return ;\n  mat[i][j]=3;\n  if(j+1<w) dfs(i,j+1);\n  if(0<=j-1) dfs(i,j-1);\n  if(i+1<h) dfs(i+1,j);\n  if(0<=i-1) dfs(i-1,j);\n}\n//1:B 2:W"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n\ntypedef long long ll;\n\nint a[50][50], b[2][50][50];\nint w,h,k;\nint dx[4]={1,-1,0,0} , dy[4]={0,0,1,-1};\n\nbool isok(int i,int j){\n    return i>=0 && i<h && j>=0 && j<w;\n}\n\nvoid dfs(int i,int j){\n    if (!a[i][j])\n        b[k-1][i][j] = 1;\n    REP(s,4){\n        int ii=i+dx[s] , jj=j+dy[s];\n        if (isok(ii,jj) && !b[k-1][ii][jj] && !a[ii][jj]){\n            dfs(ii,jj);\n        }\n    }\n}\n\nint main(void) {\n    while (cin>>w>>h && w){\n        REP(i,h){\n            REP(j,w){\n                char c;\n                cin >> c;\n                if (c=='B')\n                    a[i][j] = 1;\n                else if (c=='W')\n                    a[i][j] = 2;\n                else\n                    a[i][j] = 0;\n                b[0][i][j] = 0;\n                b[1][i][j] = 0;\n            }\n        }\n        k=1;\n        REP(i,h){\n            REP(j,w){\n                if (a[i][j]==1)\n                    dfs(i,j);\n            }\n        }\n        k=2;\n        REP(i,h){\n            REP(j,w){\n                if (a[i][j]==2)\n                    dfs(i,j);\n            }\n        }\n        int bl = 0 , wh = 0;\n        REP(i,h){\n            REP(j,w){\n                bl += (b[0][i][j] && !b[1][i][j]);\n                wh += (b[1][i][j] && !b[0][i][j]);\n            }\n        }\n\n        cout << bl << \" \" << wh << endl;\n\n    }\n    \n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nchar t[100][100];\nbool visited[100][100];\nbool a,b;\nint h,w,cnt;\nvoid rec(int y,int x){\n  if(t[y][x]=='B')a=true;\n  if(t[y][x]=='W')b=true;\n  if(t[y][x]!='.')return;\n  if(visited[y][x])return;\n  visited[y][x]=true;\n  cnt++;\n  if(y>0)rec(y-1,x);\n  if(y+1<h)rec(y+1,x);\n  if(x>0)rec(y,x-1);\n  if(x+1<w)rec(y,x+1);\n}\nint main(){\n  while(1){\n    cin>>h>>w;\n    if(h==0&&w==0)break;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n\tcin>>t[i][j],visited[i][j]=false;\n    int suma=0,sumb=0;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tif(visited[i][j])continue;\n\tif(t[i][j]!='.')continue;\n\ta=b=cnt=false;\n\trec(i,j);\n\tif(a&&!b)suma+=cnt;\n\telse if(!a&&b)sumb+=cnt;\n      }\n    }\n    cout<<suma<<' '<<sumb<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define loop(n, i) for(int i=0;i<n;i++)\n#define all(v) v.begin(),v.end()\n#define HERE cout << \"HERE: \" << __LINE__ << endl;\n#define INSP(v) cout << v << \" at \" << __LINE__ << endl;\n\nusing namespace std;\ntypedef long long ll;\n\nint f[50][50];\n\nint dfs(vector<vector<int>> &m, int h, int w, vector<vector<char>> as, int t) {\n    if (h < 0 || w < 0 || h >= m.size() || w >= m[h].size()) {\n        return 0;\n    }\n    if (as[h][w] == 'B') return 1;\n    if (as[h][w] == 'W') return 2;\n    if (f[h][w]) return m[h][w];\n    f[h][w] = 1;\n    t |= m[h][w];\n    t |= dfs(m, h-1, w, as, t);\n    t |= dfs(m, h+1, w, as, t);\n    t |= dfs(m, h, w+1, as, t);\n    t |= dfs(m, h, w-1, as, t);\n    m[h][w] = t;\n    return t;\n}\n\nint main()\n{\n    int w, h;\n    while (cin >> w >> h, w) {\n        loop(50,i) loop(50,j) f[i][j] = 0;\n        vector<vector<char>> as;\n        as.resize(h);\n        loop(h,i) {\n            string s;\n            cin >> s;\n            for (char c:s) as[i].push_back(c);\n        }\n\n        vector<vector<int>> mat(h, vector<int>(w,0));\n        loop(h,i){\n            loop(w,j){\n                if (as[i][j] == '.') {\n                    dfs(mat, i, j, as, 0);\n                }\n            }\n        }\n\n        int ans_w = 0, ans_b = 0;\n        for(auto mm:mat) {\n            for (auto m:mm) {\n                if (m == 1) ans_b++;\n                if (m == 2) ans_w++;\n            }\n        }\n        cout << ans_b << ' ' << ans_w << endl;\n\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\nusing namespace std;\n\nchar a[52][52];\nbool visit[52][52];\nint u, cnt;\n\nint dx[] = {-1, 0, 1, 0};\nint dy[] = {0, -1, 0, 1};\n\nvoid dfs(int y, int x){\n\t++cnt;\n\n\tfor(int i = 0; i < 4; ++i){\n\t\tint ny = y + dy[i], nx = x + dx[i];\n\t\tswitch( a[ny][nx] ){\n\t\t\tcase '.':\n\t\t\t\tif( !visit[ny][nx] ){\n\t\t\t\t\tvisit[ny][nx] = true;\n\t\t\t\t\tdfs(ny, nx);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'B':\n\t\t\t\tu |= 1;\n\t\t\t\tbreak;\n\t\t\tcase 'W':\n\t\t\t\tu |= 2;\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\nint main(){\n\tint w, h;\n\twhile(scanf(\"%d%d\", &w, &h), w != 0){\n\t\tint ans[4] = {};\n\n\t\tmemset(a, 0, sizeof a);\n\t\tmemset(visit, 0, sizeof visit);\n\n\t\tfor(int i = 1; i <= h; ++i){\n\t\t\tscanf(\" %s\", a[i] + 1);\n\t\t}\n\n\t\tfor(int i = 1; i <= h; ++i)\n\t\tfor(int j = 1; j <= w; ++j){\n\t\t\tif( !visit[i][j] && a[i][j] == '.' ){\n\t\t\t\tvisit[i][j] = true;\n\t\t\t\tu = cnt = 0;\n\t\t\t\tdfs(i, j);\n\t\t\t\tans[u] += cnt;\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d %d\\n\", ans[1], ans[2]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 50\nusing namespace std;\nint w,h,a[N][N],cnt,wcnt,bcnt;\nint W,B,used[N][N];\nint dy[4]={-1,0,1,0};\nint dx[4]={0,1,0,-1};\nstring s[N];\n\nvoid dfs(int y,int x){\n  if(used[y][x])return;\n  used[y][x]=1;\n  cnt++;\n  for(int i=0;i<4;i++){\n    int ny=y+dy[i],nx=x+dx[i];\n    if(ny<0||nx<0||h<=ny||w<=nx)continue;\n    if(s[ny][nx]!='.'){\n      if(s[ny][nx]=='B')B=1;\n      if(s[ny][nx]=='W')W=1;\n      continue;\n    }\n    dfs(ny,nx);\n  }\n}\n\nint main(){\n  while(1){\n    cin>>w>>h;\n    if(!w&&!h)break;\n    for(int i=0;i<h;i++)cin>>s[i];\n    memset(used,0,sizeof(used));\n    wcnt=bcnt=0;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n\tif(!used[i][j]&&s[i][j]=='.'){\n\t  W=B=cnt=0;\n\t  dfs(i,j);\n\t  if(!W&&B)bcnt+=cnt;\n\t  if(W&&!B)wcnt+=cnt;\n\t}\n    cout<<bcnt<<' '<<wcnt<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define MAX 50\n#define WHITE 1\n#define BLACK 2\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nchar a[MAX][MAX];\nint judge[MAX][MAX];\nbool visitedw[MAX][MAX];\nbool visitedb[MAX][MAX];\nbool searchedw[MAX][MAX];\nbool searchedb[MAX][MAX];\nP white[MAX * MAX];\nP black[MAX * MAX];\nint countw;\nint countb;\n\nint p[4] = {1, 0, -1, 0}, q[4] = {0, 1, 0, -1};\n\nvoid print_number(int w, int h) {\n  int sumb = 0, sumw = 0;\n  for (int i = 0; i < h; i++) {\n    for (int j = 0; j < w; j++) {\n      if (judge[i][j] == BLACK) sumb++;\n      else if (judge[i][j] == WHITE) sumw++;\n    }\n  }\n\n  cout << sumb << ' ' << sumw << endl;\n}\n\nvoid dfs_b(int w, int h, int x, int y) {\n  for (int i = 0; i < 4; i++) {\n    int s = x + p[i], t = y + q[i];\n    if (0 <= s && s <= w && 0 <= t && t <= h && a[t][s] == '.'\n\t&& !searchedb[t][s]) {\n      judge[t][s] += BLACK;\n      searchedb[t][s] = true;\n      dfs_b(w, h, s, t);\n    }\n  }\n}\n\nvoid dfs_w(int w, int h, int x, int y) {\n  for (int i = 0; i < 4; i++) {\n    int s = x + p[i], t = y + q[i];\n    if (0 <= s && s <= w && 0 <= t && t <= h && a[t][s] == '.'\n\t&& !searchedw[t][s]) {\n      judge[t][s] += WHITE;\n      searchedw[t][s] = true;\n      dfs_w(w, h, s, t);\n    }\n  }\n}\n\nvoid count_black(int w, int h) {\n  for (int i = 0; i < h; i++) {\n    for (int j = 0; j < w; j++) {\n      if (a[i][j] == 'B') {\n\tblack[countb].first = j;\n\tblack[countb].second = i;\n\tcountb++;\n      }\n    }\n  }\n}\n\nvoid count_white(int w, int h) {\n  for (int i = 0; i < h; i++) {\n    for (int j = 0; j < w; j++) {\n      if (a[i][j] == 'W') {\n\twhite[countw].first = j;\n\twhite[countw].second = i;\n\tcountw++;\n      }\n    }\n  }\n}\n\nvoid clear_array() {\n  for (int i = 0; i < MAX; i++) {\n    for (int j = 0; j < MAX; j++) {\n      a[i][j] = 0;\n      judge[i][j] = 0;\n      visitedw[i][j] = visitedb[i][j]  = false;\n      searchedw[i][j] = searchedb[i][j] = false;\n    }\n  }\n  for (int i = 0; i < MAX * MAX; i++) {\n    white[i].first = white[i].second = black[i].first = black[i].second = 0;\n  }\n}\n\nint main() {\n  while (true) {\n    int w, h;\n    cin >> w >> h;\n    if (w == 0 && h == 0) return 0;\n\n    clear_array();\n    \n    for (int i = 0; i < h; i++)\n      for (int j = 0; j < w; j++)\n\tcin >> a[i][j];\n\n    countw = countb = 0;\n    count_white(w, h);\n    count_black(w, h);\n\n    for (int i = 0; i < countw; i++) {\n      dfs_w(w, h, white[i].first, white[i].second);\n    }\n    for (int i = 0; i < countb; i++) {\n      dfs_b(w, h, black[i].first, black[i].second);\n    }\n\n    print_number(w, h);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//=================================\n// Created on: 2018/07/03 03:45:40\n//=================================\n#include <bits/stdc++.h>\nusing namespace std;\nint main()\n{\n    for (int W, H;;) {\n        cin >> W >> H;\n        if (W == 0 and H == 0) { break; }\n        vector<vector<int>> f(H, vector<int>(W, 0));\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                char c;\n                cin >> c, f[i][j] = c == '.' ? 0 : c == 'B' ? 1 : 2;\n            }\n        }\n        int wans = 0, bans = 0;\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (f[i][j] != 0) { continue; }\n                vector<vector<bool>> used(H, vector<bool>(W, false));\n                using P = pair<int, int>;\n                constexpr int d[] = {-1, 0, 1, 0, -1};\n                queue<P> q;\n                used[i][j] = true, q.push({i, j});\n                auto in = [&](const int y, const int x) { return 0 <= y and y < H and 0 <= x and x < W; };\n                bool w = false, b = false;\n                while (not q.empty()) {\n                    const int y = q.front().first, x = q.front().second;\n                    q.pop();\n                    for (int i = 0; i < 4; i++) {\n                        const int newy = y + d[i], newx = x + d[i + 1];\n                        if (not in(newy, newx) or used[newy][newx]) { continue; }\n                        if (f[newy][newx] == 1) {\n                            b = true;\n                            continue;\n                        } else if (f[newy][newx] == 2) {\n                            w = true;\n                            continue;\n                        } else {\n                            used[newy][newx] = true, q.push({newy, newx});\n                        }\n                    }\n                }\n                if (w and not b) { wans++; }\n                if (b and not w) { bans++; }\n            }\n        }\n        cout << bans << \" \" << wans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\ntypedef pair<int,int> pii;\nchar grid[60][60];\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\nint W,H;\nint bw=3;\nint dfs(int color,int w,int h){\n   grid[h][w]=-1;\n  int res=1;\n  for(int i=0;i<4;i++){\n    int nx,ny;\n    nx=w+dx[i];ny=h+dy[i];\n    if(0<=ny && ny<H &&\n       0<=nx && nx < W){\n      if(grid[ny][nx]=='.'){\n\tres += dfs(color,nx,ny);\n      }else if(grid[ny][nx]=='W')bw=1 & bw;\n      else if(grid[ny][nx]=='B')bw=2 & bw;\n    }\n  }\n  return res;\n}\n\nvoid printGrid(){\n  for(int i=0;i<H;i++){\n    for(int j=0;j<W;j++){\n      cout << grid[i][j] << \" \";\n    }\n    cout << endl;\n  }\n  cout << endl;\n}  \n\nint main(){\n  while(cin>>W>>H){\n    if(W==0)break;\n    for(int i=0;i<H;i++)\n      for(int j=0;j<W;j++){\n\tcin>>grid[i][j];\n      }\n    int white=0,black=0;\n    for(int i=0;i<H;i++){\n      for(int j=0;j<W;j++){\n\tif(grid[i][j]=='.'){\n\t  bw=3;\n\t  int tmp=dfs(0,j,i);\n\t  if(bw==1)white+=tmp;\n\t  else if(bw==2)black+=tmp;\n\t}\n      }\n    }\n    cout << black << \" \" << white << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef pair <int,int> pii;\n#define FST first\n#define SEC second\n#define S 50\n\nint w,h;\nint dd[8]={0,1,0,-1,0};\n\nvoid bfs(char map[S][S]){\n  int bc=0,wc=0;\n  rep(i,h){\n    rep(j,w){\n      if(map[j][i]=='.'){\n\tqueue <pii> q;\n\tq.push(pii(j,i));\n\tint count=0;\n\tpii state=pii(0,0);\n\twhile(!q.empty()){\n\t  int cx=q.front().FST,cy=q.front().SEC;\n\t  q.pop();\n\t  if(map[cx][cy]=='.')\n\t    count++;\n\t  map[cx][cy]='#';\n\t  rep(r,4){\n\t    int nx=cx+dd[r],ny=cy+dd[r+1];\n\t    if(nx<0 || ny<0 || nx>=w || ny>=h || map[nx][ny]=='#')\n\t      continue;\n\t    if(map[nx][ny]=='B'){\n\t      state.FST=1;\n\t      continue;\n\t    }\n\t    if(map[nx][ny]=='W'){\n\t      state.SEC=1;\n\t      continue;\n\t    }\n\t    q.push(pii(nx,ny));\n\t  }\n\t}\n\tif(state==pii(1,0))\n\t  bc+=count;\n\tif(state==pii(0,1))\n\t  wc+=count;\n      } \n    }\n  }\n  printf(\"%d %d\\n\",bc,wc);\n}\n\nint main(){\n  for(;;){\n    cin >> w >> h;\n    if(!(w+h)) break;\n    char map[S][S];\n    rep(i,h)\n      rep(j,w)\n        cin >> map[j][i];\n    bfs(map);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <queue>\n#include <sstream>\n\nusing namespace std;\n\nint w, h;\n\nstring field[100];\n\nbool check[100][100];\n\nstring search(int y, int x){\n\tif(y < 0 || x < 0 || y >= h || x >= w){\n\t\treturn \"\";\n\t}\n\tif(check[y][x]){\n\t\treturn \"\";\n\t}\n\tif(field[y][x] != '.'){\n\t\tstring ret = \" \";\n\t\tret[0] = field[y][x];\n\t\treturn ret;\n\t}\n\tcheck[y][x] = true;\n\t\n\treturn search(y - 1, x) + search(y + 1, x) + search(y, x - 1) + search(y, x + 1) + \"1\";\n}\n\nint main(){\n\t\n\twhile(true){\n\t\t\n\t\tcin >> w >> h;\n\t\tif(w == 0 && h == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tcin >> field[i];\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcheck[i][j] = false;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans_b = 0;\n\t\tint ans_w = 0;\n\t\t\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tstring ret = search(i, j);\n\t\t\t\tbool flag1 = false;\n\t\t\t\tbool flag2 = false;\n\t\t\t\tint count = 0;\n\t\t\t\tfor(int k = 0; k < ret.size(); k++){\n\t\t\t\t\tif(ret[k] == 'B'){\n\t\t\t\t\t\tflag1 = true;\n\t\t\t\t\t}else if(ret[k] == 'W'){\n\t\t\t\t\t\tflag2 = true;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flag1 && flag2){\n\t\t\t\t\tcontinue;\n\t\t\t\t}else if(flag1){\n\t\t\t\t\tans_b += count;\n\t\t\t\t}else if(flag2){\n\t\t\t\t\tans_w += count;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << ans_b << \" \" << ans_w << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#define B 'B'\n#define W 'W'\n#define DOT '.'\n#define NG '1'\n\nusing namespace std;\n\nvoid Search1(vector<string>&, int, int, int, int, int&, char&);\nvoid Search2(vector<string>&, int, int, int, int, int&, char&);\n\nint main(){\n  int i, j, w, h, count, black, white, k;\n  char c;\n  string s;\n  vector<string> data;\n\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0) break;\n\n    for(i=0; i<h; ++i){\n      cin >> s;\n      data.push_back(s);\n    }\n    for(i=0, black=0, white=0; i<h; ++i){\n      for(j=0; j<w; ++j){\n\tif(data[i][j] == DOT){\n\t  count = 0;\n\t  c = DOT;\n\t  Search1(data, i, j, h, w, count, c);\n\t  if(c == B) black += count;\n\t  else if(c == W) white += count;\n\t}\n      }\n    }\n\n    cout << black << \" \" << white << endl;\n    data.clear();\n  }\n  return 0;\n}\n\nvoid Search1(vector<string>& data, int i, int j, int h, int w, int& count, char& c){\n  data[i][j] = NG;\n  ++count;\n  Search2(data, i-1, j, h, w, count, c);\n  Search2(data, i+1, j, h, w, count, c);\n  Search2(data, i, j-1, h, w, count, c);\n  Search2(data, i, j+1, h, w, count, c);\n}\n\nvoid Search2(vector<string>& data, int i, int j, int h, int w, int& count, char& c){\n  if(i > -1 && i < h && j > -1 && j < w){\n    if(data[i][j] == DOT){\n      Search1(data, i, j, h, w, count, c);\n    }else if(data[i][j] == B || data[i][j] == W){\n      if(c == DOT) c = data[i][j];\n      else if(c != data[i][j]) c = NG;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n\nusing namespace std;\n\nchar d[50][60];\nbool w[50][50];\nbool b[50][50];\n\nint ww,hh;\nconst int dx[4] = {1,-1,0,0};\nconst int dy[4] = {0,0,1,-1};\n\n#define REP(i,n) for(int i = 0; i<(n); i++)\n\nvoid dfsw(int y, int x){\n  w[y][x] == true;\n  REP(i,4){\n    int xx = x + dx[i];\n    int yy = y + dy[i];\n    if(xx < 0 || yy < 0) continue;\n    if(xx >=ww || yy >=hh) continue;\n    if(d[yy][xx] != 'B' && !w[yy][xx]){\n      w[yy][xx] = true;\n      dfsw(yy,xx);\n    }\n  }\n}\nvoid dfsb(int y, int x){\n  b[y][x] == true;\n  REP(i,4){\n    int xx = x + dx[i];\n    int yy = y + dy[i];\n    if(xx < 0 || yy < 0) continue;\n    if(xx >=ww || yy >=hh) continue;\n    if(d[yy][xx] != 'W' && !b[yy][xx]){\n      b[yy][xx] = true;\n      dfsb(yy,xx);\n    }\n  }\n}\n\nint main(){\n  while(scanf(\"%d%d\",&ww,&hh),ww+hh){\n    memset(w,0,sizeof(w));\n    memset(b,0,sizeof(b));\n    REP(i,hh) scanf(\"%s\",d[i]);\n    REP(i,hh) REP(j,ww){\n      if(d[i][j] == 'W' && !w[i][j])\n\tdfsw(i,j);\n      if(d[i][j] == 'B' && !b[i][j])\n\tdfsb(i,j);\n    }\n    int a1 = 0, a2 = 0;\n    //REP(i,hh){ REP(j,ww) putchar(w[i][j]?'w':'.'); puts(\"\");}\n    //REP(i,hh){ REP(j,ww) putchar(b[i][j]?'b':'.'); puts(\"\");}\n    REP(i,hh) REP(j,ww){\n      if(d[i][j]=='.' && w[i][j] && !b[i][j]) a2++;\n      if(d[i][j]=='.' && !w[i][j] && b[i][j]) a1++;\n    }\n    printf(\"%d %d\\n\",a1,a2);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nint w, h;\nstring s[51];\nint dx[4] = {0,0,-1,1};\nint dy[4] = {1,-1,0,0};\n\nvoid debug(){\n\tcout << \"[debug]\" << endl;\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tcout << s[y] << endl;\n\t}\n\tcout << endl;\n}\n\nvoid solve(int x, int y, char c){\n\tif( c == 'w' ){\n\t\tfor(int i=0 ; i < 4 ; i++ ){\n\t\t\tint mx = x + dx[i];\n\t\t\tint my = y + dy[i];\n\t\t\tif( mx < 0 || my < 0 || mx >= w || my >= h ) continue;\n\t\t\tif( s[my][mx] == '.' ){\n\t\t\t\ts[my][mx] = 'w';\n\t\t\t\tsolve( mx , my , 'w' );\n\t\t\t}\n\t\t}\n\t}\n\tif( c == 'b' ){\n\t\tfor(int i=0 ; i < 4 ; i++ ){\n\t\t\tint mx = x + dx[i];\n\t\t\tint my = y + dy[i];\n\t\t\tif( mx < 0 || my < 0 || mx >= w || my >= h ) continue;\n\t\t\tif( s[my][mx] == '.' ){\n\t\t\t\ts[my][mx] = 'b';\n\t\t\t\tsolve( mx , my , 'b' );\n\t\t\t}else if( s[my][mx] == 'w' ){\n\t\t\t\ts[my][mx] = '?';\n\t\t\t\tsolve( mx , my , '?' );\n\t\t\t}\n\t\t}\n\t}\n\tif( c == '?' ){\n\t\tfor(int i=0 ; i < 4 ; i++ ){\n\t\t\tint mx = x + dx[i];\n\t\t\tint my = y + dy[i];\n\t\t\tif( mx < 0 || my < 0 || mx >= w || my >= h ) continue;\n\t\t\tif( s[my][mx] == '.' || s[my][mx] == 'w' || s[my][mx] == 'b' ){\n\t\t\t\ts[my][mx] = '?';\n\t\t\t\tsolve( mx , my , '?' );\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile( cin >> w >> h, w || h ){\n\t\tfor(int y=0 ; y < h  ; y++ ){\n\t\t\tcin >> s[y];\n\t\t}\n\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\t\tif( s[y][x] == 'W' ){\n\t\t\t\t\tsolve( x , y , 'w' );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\t\tif( s[y][x] == 'B' ){\n\t\t\t\t\tsolve( x , y , 'b' );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// debug();\n\t\tint white=0, black=0;\n\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\t\tif( s[y][x] == 'b' ) black++;\n\t\t\t\tif( s[y][x] == 'w' ) white++;\n\t\t\t}\n\t\t}\n\t\tcout << black << \" \" << white << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i, n) for(int i = 0; i < (int) (n); i++)\n#define ALL(v) (v).begin(), (v).end()\n#define INF 1e9\n\nusing namespace std;\n\nint m[50][50];\nint w, h;\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nvoid dfs(int cw, int ch, int kind){\n  REP(i, 4){\n    int nw = cw + dx[i]; int nh = ch + dy[i];\n    if(0 <= nw and nw < w and 0 <= nh and nh < h){\n      if(m[nh][nw] == 0) { m[nh][nw] = 2 * kind; dfs(nw, nh, kind); }\n      if(m[nh][nw] == -2 * kind) { m[nh][nw] = 9; dfs(nw, nh, kind); }\n    }\n  }\n}\n\nint main(){\n  while(cin >> w >> h and w + h){\n    memset(m, 0, sizeof(m));\n    REP(i, h){\n      string tmp; cin >> tmp;\n      REP(j, w) if(tmp[j] == 'B') m[i][j] = 1; else if(tmp[j] == 'W') m[i][j] = -1;\n    }\n    REP(i, h) REP(j, w){\n      if(m[i][j] == 1) dfs(j, i, 1);\n      if(m[i][j] == -1) dfs(j, i, -1);\n    }\n    int bres = 0; int wres = 0;\n    REP(i, h) REP(j, w) {\n      if(m[i][j] == 2) bres++;\n      if(m[i][j] == -2) wres++;\n    }\n    cout << bres << \" \" << wres << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit atof atoi \n#include <cstdio>\t\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\t\t// require fabs\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\t\t// require srand\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nbool visit[55][55];\nchar island[55][55];\nconst int dy[] = { -1, 0, 1, 0 };\nconst int dx[] = {  0, 1, 0,-1 };\nint w, h;\n\nbool dfs (int cx, int cy, char kui )\n{\n//\tif (visit[cy][cx] ) return;\n\n\tvisit[cy][cx] = true;\n\n\trep (k, 4 ){\n\t\tint ny = cy + dy[k];\n\t\tint nx = cx + dx[k];\n\t\tif (ny < 0 || nx < 0 || ny >= h || nx >= w || visit[ny][nx] ) continue;\n\t\tif (island[ny][nx] == 'B' || island[ny][nx] == 'W' ){\n\t\t\tif ((kui == 'W' && island[ny][nx] == 'B' ) || (kui == 'B' && island[ny][nx] == 'W' ) ){\n\t\t\t\treturn false;\n\t\t\t} // end if\n\t\t\tcontinue;\n\t\t} // end if\n\t\tif (dfs (nx, ny, kui ) ){\n\t\t\tisland[ny][nx] = (kui == 'W' ? 'w' : 'b' );\n\t\t}else{\n\t\t\tisland[ny][nx] = 'f';\n\t\t} // end if\n \t} // end rep\n\n\treturn true;\n}\n\nvoid dfs2 (int cx, int cy )\n{\n\tisland[cy][cx] = 'f';\t\n\tvisit[cy][cx] = true;\n\trep (k, 4 ){\n\t\tint nx = cx + dx[k];\n\t\tint ny = cy + dy[k];\n\t\tif (nx < 0 || nx >= w || ny < 0 || ny >= h || visit[ny][nx] || island[ny][nx] == 'W' || island[ny][nx] == 'B' ) continue;\n\t\tdfs2 (nx, ny );\n\t} // end rep\t\n}\n\nint main()\n{\n//\tcut here before submit \n//\tfreopen (\"testcase.Surrounding_Area\", \"r\", stdin );\n\twhile (scanf (\"%d %d\", &w, &h ) && w && h ){\n\t\tmemset (visit, false, sizeof (visit ) );\n\t\trep (i, h ){\n\t\t\trep (j, w ){\n\t\t\t\tscanf ( \" %c\", &island[i][j] );\n\t\t\t} // end rep\n\t\t} // end rep\n\t\trep (y, h ){\n\t\t\trep (x, w ){\n\t\t\t\tif (!visit[y][x] && (island[y][x] == 'W' || island[y][x] == 'B' ) ){\n\t\t\t\t\tdfs (x, y, island[y][x] );\n\t\t\t\t} // end if\n\t\t\t} // end rep\n\t\t} // end rep\n\t\tmemset (visit, false, sizeof (visit ) );\n\t\trep (y, h ){\n\t\t\trep (x, w ){\n\t\t\t\tif (!visit[y][x] && island[y][x] == 'f' ){\n\t\t\t\t\tdfs2 (x, y );\n\t\t\t\t} // end if\n\t\t\t} // end rep\n\t\t} // end rep\n\t\tint W = 0, B = 0;\n\t\trep (y, h ){\n\t\t\trep (x, w ){\n\t\t\t\tif (island[y][x] == 'w' ) W++;\n\t\t\t\telse\n\t\t\t\tif (island[y][x] == 'b' ) B++;\n//\t\t\t\tcout << island[y][x];\n\t\t\t} // end rep\n//\t\t\tcout << endl;\n\t\t} // end rep\n\t\tprintf (\"%d %d\\n\", B, W );\n\t} // end loop\n\n//\tprintf (\"%d\\n\", res );\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define MAX 50\n#define BLACK 'B'\n#define WHITE 'W'\n#define SPACE '.'\n#define VISITED '#'\n\nusing namespace std;\n\nint w, h;\nint numB, numW;\nint sum;\nchar data[MAX][MAX];\nconst int dx[4] = {1,0,-1,0};\nconst int dy[4] = {0,1,0,-1};\n\nbool isOut(int x, int y) {\n  if(x < 0 || x >= w) return true;\n  if(y < 0 || y >= h) return true;\n  return false;\n}\n\nvoid show() {\n  for(int i = 0; i < h; i++) {\n    for(int j = 0; j < w; j++) {\n      cout << data[i][j];\n    }\n    cout << endl;\n  }\n  cout << endl;\n}\n\nvoid rec(int x, int y, char c) {\n  data[y][x] = VISITED;\n  if(sum != -1) sum++;\n  for(int i = 0; i < 4; i++) {\n    int nx = x + dx[i];\n    int ny = y + dy[i];\n    if(isOut(nx, ny)) continue;\n    if(data[ny][nx] == VISITED) continue;\n    if(data[ny][nx] == SPACE) {\n      rec(nx, ny, c);\n    } else if(data[ny][nx] != c) {\n      sum = -1;\n    }\n  }\n}\n\nmain() {\n  while(1) {\n    cin >> w >> h;\n    if(w == 0 && h == 0) break;\n    for(int i = 0; i < h; i++) {\n      for(int j = 0; j < w; j++) {\n\tcin >> data[i][j];\n      }\n    }\n\n    numB = numW = 0;\n    for(int i = 0; i < h; i++) {\n      for(int j = 0; j < w; j++) {\n\tif(data[i][j] != SPACE && data[i][j] != VISITED) {\n\t  for(int k = 0; k < 4; k++) {\n\t    int nx = j + dx[k];\n\t    int ny = i + dy[k];\n\t    if(isOut(nx, ny)) continue;\n\t    if(data[ny][nx] == VISITED) continue;\n\t    if(data[ny][nx] != SPACE) continue;\n\t    sum = 0;\n\t    rec(nx, ny, data[i][j]);\n\t    if(sum != -1) {\n\t      if(data[i][j] == BLACK) {\n\t\tnumB += sum;\n\t      } else {\n\t\tnumW += sum;\n\t      }\n\t    }\n\t  }\n\t}\n      }\n    }\n\n    cout << numB << ' ' << numW << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nchar t[100][100];\nbool visited[100][100];\nbool a,b;\nint h,w,cnt;\nvoid rec(int y,int x){\n  if(t[y][x]=='B')a=true;\n  if(t[y][x]=='W')b=true;\n  if(t[y][x]!='.')return;\n  if(visited[y][x])return;\n  visited[y][x]=true;\n  cnt++;\n  if(y>0)rec(y-1,x);\n  if(y+1<h)rec(y+1,x);\n  if(x>0)rec(y,x-1);\n  if(x+1<w)rec(y,x+1);\n}\nint main(){\n  while(1){\n    cin>>w>>h;\n    if(h==0&&w==0)break;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n\tcin>>t[i][j],visited[i][j]=false;\n    int suma=0,sumb=0;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tif(visited[i][j])continue;\n\tif(t[i][j]!='.')continue;\n\ta=b=cnt=false;\n\trec(i,j);\n\tif(a&&!b)suma+=cnt;\n\telse if(!a&&b)sumb+=cnt;\n      }\n    }\n    cout<<suma<<' '<<sumb<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define o(a) cout << a << endl\n#define int long long\n#define F first;\n#define S second;\nusing namespace std;\ntypedef pair<int, int> P;\n\nint h, w;\nint dy[4] = {1, -1, 0, 0};\nint dx[4] = {0, 0, 1, -1};\nint f[50][50];\nbool contain(int y, int x){\n    return (0 <= y && y < h && 0 <= x && x < w);\n}\n\nsigned main(){\n    while(1){\n        cin >> w >> h;\n        if(h + w == 0) break;\n        vector<string> s(h);\n        rep(i, 0, h) cin >> s[i];\n        rep(i, 0, h) rep(j, 0, w) f[i][j] = 0;\n        int bc = 0, wc = 0;\n        rep(i, 0, h){\n            rep(j, 0, w){\n                if(s[i][j] == '.') continue;\n                queue<P> q;\n                q.push(P(i, j));\n                int bt = (s[i][j] == 'W' ? 1 : 0);\n                while(!q.empty()){\n                    P p = q.front(); q.pop();\n                    rep(k, 0, 4){\n                        int ny = p.first + dy[k];\n                        int nx = p.second + dx[k];\n                        // cout << ny << \" \" << nx << endl;\n                        if(!contain(ny, nx)) continue;\n                        if(s[ny][nx] == '.'){\n                            // if(s[ny][nx] == 'W' || s[ny][nx] == 'B') continue;\n                            if(f[ny][nx] & (1 << bt)) continue;\n                            f[ny][nx] |= (1 << bt);\n                        // cout << p.first << \" \" << p.second << endl;\n                            \n                            q.push(P(ny, nx));\n                        }\n                    }\n                }\n            }\n        }\n        rep(i, 0, h){\n            rep(j, 0, w){\n                // cout << f[i][j] << \" \";\n                if(f[i][j] == 1) bc++;\n                if(f[i][j] == 2) wc++;\n            }\n            // cout << endl;\n        }\n        cout << bc << \" \" << wc << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> mypair;\nint dx[]={1,-1,0,0};\nint dy[]={0,0,1,-1};\nvoid dfs(vector<vector<bool> > &map,set<mypair> &ans,mypair now){\n\tint x = now.first;\n\tint y = now.second;\n\tmap[x][y] = false;\n\tfor(int i=0;i<4;i++){\n\tint nx = x+dx[i];\n\tint ny = y+dy[i];\n\tif(map[nx][ny]){\n\t\tmypair next = mypair(nx,ny);\n\t\tans.insert(next);\n\t\tdfs(map,ans,next);\n\t}\n\t}\n\treturn ;\n}\n\nint main(){\n\twhile(1){\n\tint w,h;\n\tcin>>w>>h;\n\tif(w==0)break;\n\tvector<vector<bool> > mapb(h+2,vector<bool>(w+2,false) ) ,mapw(h+2,vector<bool>(w+2,false) );\n\tvector<mypair> brack,white;\n\tfor(int i=1;i<=h;i++)\n\t\tfor(int j=1;j<=w;j++)\n\t\t{\n\t\t\tchar a;\n\t\t\tcin>>a;\n\t\t\tif(a=='.'){\n\t\t\t\tmapb[i][j] = true;\n\t\t\t\tmapw[i][j] = true;\n\t\t\t}else if(a=='W')white.push_back(mypair(i,j) );\n\t\t\telse brack.push_back(mypair(i,j) );\n\t\t}\n\tset<mypair> ansb,answ;\n\tfor(int i=0;i<brack.size();i++)dfs(mapb,ansb,brack[i]);\n\tfor(int i=0;i<white.size();i++)dfs(mapw,answ,white[i]);\n\tint cntb=0,cntw=0;\n\tfor(auto i:ansb){\n\t\tauto it = answ.find(i);\n\t\tif(it==answ.end())cntb++;\n\t}\n\tfor(auto i:answ){\n\t\tauto it = ansb.find(i);\n\t\tif(it==ansb.end())cntw++;\n\t}\n\tcout<<cntb<<' '<<cntw<<endl;\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    const int vx[]={0,1,0,-1};\n    const int vy[]={-1,0,1,0};\n    int w,h;\n    while(true){\n        cin>>w>>h;\n        if(w==0)break;\n        vector<vector<char>> m(h+2,vector<char>(w+2,'#'));\n        queue<pair<int,int>> bq,wq;\n        for (int i = 0; i < h; ++i) {\n            string s;\n            cin>>s;\n            for (int j = 0; j < w; ++j) {\n                m[i+1][j+1]=s[j];\n                if(m[i+1][j+1]=='B')bq.push(make_pair(i+1,j+1));\n                else if(m[i+1][j+1]=='W')wq.push(make_pair(i+1,j+1));\n            }\n        }\n        vector<vector<int>> a(h+2,vector<int>(w+2,0));\n        while(!bq.empty()){\n            auto t=bq.front();\n            bq.pop();\n            for (int i = 0; i < 4; ++i) {\n                int ny=t.first+vy[i];\n                int nx=t.second+vx[i];\n                if(a[ny][nx]!=1&&m[ny][nx]=='.'){\n                    bq.push(make_pair(ny,nx));\n                    a[ny][nx]+=1;\n                }\n            }\n        }\n        while(!wq.empty()){\n            auto t=wq.front();\n            wq.pop();\n            for (int i = 0; i < 4; ++i) {\n                int ny=t.first+vy[i];\n                int nx=t.second+vx[i];\n                if((a[ny][nx]&2)==0&&m[ny][nx]=='.'){\n                    wq.push(make_pair(ny,nx));\n                    a[ny][nx]+=2;\n                }\n            }\n        }\n        int ba=0,wa=0;\n        for (int i = 1; i <= h; ++i) {\n            for (int j = 1; j <= w; ++j) {\n                if(a[i][j]==1)++ba;\n                else if(a[i][j]==2)++wa;\n            }\n        }\n        cout<<ba<<\" \"<<wa<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint dxy[4] = {-1, 1, 0, 0};\nint W, H;\nchar a[60][60];\nint temp[60][60];\n\nint huga(int x, int y, int z[60][60]){//cout<<y<<\" \"<<x<<endl;\n\tint w = 0, b = 0, s = 0, ans=-3, t;\n\tqueue <P> Q;\n\t\n\tQ.push(P(y,x));\n\t\n\twhile(!Q.empty()){\n\t\tP p = Q.front();Q.pop();\n\t\tint yy = p.first, xx = p.second;\n\t\tz[yy][xx] = 1;\n\t\tfor(int i = 0; i <= 3; i++){\n\t\t\tint nx = xx+dxy[i], ny = yy+dxy[3-i];\n\t\t\tif(temp[ny][nx] == -1)return -1;\n\t\t\tif(a[ny][nx] == '.' && !z[ny][nx]) Q.push(P(ny,nx));\n\t\t\telse if(a[ny][nx] == 'B')b=1;\n\t\t\telse if(a[ny][nx] == 'W')w=1;\n\t\t}\n\t}\n\t\n\tif(w&&b || !w&&!b) ans = -1;\n\telse if(!w&&b)ans = 1;\n\telse if(!b&&w)ans =  0;\n\telse ans = -4;\n\t\n\t//cout<<ans<<endl<<endl;\n\treturn ans;\n\t\n}\n\nint main(){\n\t\n\twhile(1){\n\t\tint cw=0, cb=0;\n\t\tcin>>W>>H;\n\t\t\n\t\tif(!W&&!H)break;\n\t\tfor(int i = 0; i <= W+1; i++){\n\t\t\ta[0][i] = a[H+1][i] = 0;\n\t\t\ttemp[H+1][i] = temp[0][i] = 2;\n\t\t}\n\t\t\n\t\t\n\t\tfor(int i = 0; i <= H+1; i++){\n\t\t\ta[i][0] = a[i][W+1] = 0;\n\t\t\ttemp[i][0] = temp[0][i] = 2;\n\t\t}\n\t\t\n\t\tfor(int i = 1; i <= H; i++){\n\t\t\tfor(int j = 1; j <= W; j++){\n\t\t\t\tcin>>a[i][j];\n\t\t\t\ttemp[i][j] = 2;\n\t\t\t}\n\t\t}\n\n\t\t\n\t\tfor(int i = 1; i <= H; i++){\n\t\t\tfor(int j = 1; j <= W; j++){\n\t\t\t\tif(a[i][j] == '.'){\n\t\t\t\t\tint z[60][60] = {};\n\t\t\t\t\ttemp[i][j] = huga(j,i,z);\n\t\t\t\t\tif(temp[i][j] == 1)a[i][j]=='B';\n\t\t\t\t\telse if(temp[i][j] == 0)a[i][j]=='W';\n\t\t\t\t\tif(temp[i][j] == 1)cb++;\n\t\t\t\t\telse if(temp[i][j] == 0)cw++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tcout<<cb<<\" \"<<cw<<endl;\n\t}\n\t\n\t\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint W, H;\nint vx[4] = { 0,-1,0,1 }, vy[4] = { 1,0,-1,0 };\nint filed[50][50];\nbool usedB[50][50], usedW[50][50];\n\nvoid dfs(P start, int flg) {\n\tstack<P> s;\n\ts.push(start);\n\t\n\twhile (s.size()) {\n\t\tauto now = s.top(); s.pop();\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint nx = now.first + vx[i], ny = now.second + vy[i];\n\t\t\tif (nx < 0 || ny < 0 || nx >= H || ny >= W)continue;\n\t\t\tif (!flg) {\n\t\t\t\tif (usedW[nx][ny])continue;\n\t\t\t\tif (filed[nx][ny] != 0)continue;\n\t\t\t\tusedW[nx][ny] = true;\n\t\t\t\ts.push(P(nx, ny));\n\t\t\t}else {\n\t\t\t\tif (usedB[nx][ny])continue;\n\t\t\t\tif (filed[nx][ny] != 0)continue;\n\t\t\t\tusedB[nx][ny] = true;\n\t\t\t\ts.push(P(nx, ny));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\t\n\twhile (1) {\n\t\tcin >> W >> H;\n\t\tif (W + H == 0)break;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tchar c;\n\t\t\t\tcin >> c;\n\t\t\t\tif (c == 'W')filed[i][j] = 1;\n\t\t\t\telse if (c == 'B')filed[i][j] = 2;\n\t\t\t\telse filed[i][j] = 0;\n\t\t\t\tusedB[i][j] = false;\n\t\t\t\tusedW[i][j] = false;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tif (filed[i][j] == 1) {\n\t\t\t\t\tdfs(P(i, j), 0);\n\t\t\t\t}\n\t\t\t\telse if (filed[i][j] == 2) {\n\t\t\t\t\tdfs(P(i, j), 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ansB = 0, ansW = 0;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tif (usedW[i][j] && !usedB[i][j])ansW++;\n\t\t\t\tif (usedB[i][j] && !usedW[i][j])ansB++;\n\t\t\t}\n\t\t}\n\t\tcout << ansB << \" \" << ansW << endl;\n\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <iterator>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=1<<29;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nint getcolor(vs& grid,vvi& vis,int i,int j)\n{\n\tint h=grid.size(),w=grid[0].size();\n\tif(i<0 || h<=i || j<0 || w<=j || vis[i][j])\n\t\treturn 0;\n\tif(isupper(grid[i][j]))\n\t\treturn 1<<(grid[i][j]=='W');\n\tvis[i][j]=1;\n\tint res=0;\n\trep(k,4){\n\t\tint ni=i+\"\\xff\\x1\\0\\0\"[k],nj=j+\"\\0\\0\\xff\\x1\"[k];\n\t\tres|=getcolor(grid,vis,ni,nj);\n\t}\n\treturn res;\n}\nvoid setcolor(vs& grid,int i,int j,char c)\n{\n\tint h=grid.size(),w=grid[0].size();\n\tif(i<0 || h<=i || j<0 || w<=j || grid[i][j]!='.')\n\t\treturn;\n\tgrid[i][j]=tolower(c);\n\trep(k,4){\n\t\tint ni=i+\"\\xff\\x1\\0\\0\"[k],nj=j+\"\\0\\0\\xff\\x1\"[k];\n\t\tsetcolor(grid,ni,nj,c);\n\t}\n}\n\nint main()\n{\n\tfor(int w,h;cin>>w>>h,w|h;){\n\t\tvs grid(h);\n\t\trep(i,h) cin>>grid[i];\n\t\t\n\t\tvvi vis(h,vi(w));\n\t\trep(i,h) rep(j,w) if(!vis[i][j]){\n\t\t\tint res=getcolor(grid,vis,i,j);\n\t\t\tsetcolor(grid,i,j,\"*BWX\"[res]);\n\t\t}\n\t\t\n\t\tint bcnt=0,wcnt=0;\n\t\trep(i,h) rep(j,w){\n\t\t\tif(grid[i][j]=='b') bcnt++;\n\t\t\tif(grid[i][j]=='w') wcnt++;\n\t\t}\n\t\tcout<<bcnt<<' '<<wcnt<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n\ntypedef pair<int,int> pi;\n\nint main()\n{\n    while(1)\n    {\n        int w,h;\n        string a[50];\n\n        //input\n        cin >>w >>h;\n        if(w==0) break;\n        rep(i,h) cin >>a[i];\n\n        //0:??????,1:???,2:???,3:??????????????,-1:?????????????????????????????\n        int bw[50][50]={0};\n        rep(i,h)rep(j,w)\n        {\n            if(bw[i][j]==0 && a[i][j]=='.')\n            {\n                //BFS\n                int dx[4]={1,-1,0,0}, dy[4]={0,0,1,-1};\n                int vis[50][50]={0};\n                queue<pi> que;\n                que.push(pi(i,j));\n                vis[i][j]=1;\n\n                bool black=false, white=false;\n                while(!que.empty())\n                {\n                    pi p=que.front();\n                    que.pop();\n                    //printf(\"ac %d,%d\\n\",p.fi,p.se);\n\n                    if(a[p.fi][p.se]=='B') black=true;\n                    else if(a[p.fi][p.se]=='W') white=true;\n                    else\n                    {\n                        rep(k,4)\n                        {\n                            int nx=p.se+dx[k], ny=p.fi+dy[k];\n                            if(0<=nx&&nx<w && 0<=ny&&ny<h)\n                            {\n                                if(!vis[ny][nx])\n                                {\n                                    vis[ny][nx]=1;\n                                    que.push(pi(ny,nx));\n                                }\n                            }\n                        }\n                    }\n                }\n\n                int r=0;\n                if(black) r|=1;\n                if(white) r|=2;\n\n                if(r==0) r=-1;\n                //printf(\"(%d,%d),r=%d\\n\",i,j,r);\n\n                rep(k,h)rep(l,w)\n                {\n                    if(vis[k][l] && a[k][l]=='.') bw[k][l]=r;\n                }\n\n            }\n        }\n\n        int p=0,q=0;\n        rep(i,h)rep(j,w)\n        {\n            if(bw[i][j]==1) ++p;\n            if(bw[i][j]==2) ++q;\n        }\n\n        printf(\"%d %d\\n\",p,q);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#define HMAX 50\n#define WMAX 50\nint dx[4]={1,-1,0,0};\nint dy[4]={0,0,1,-1};\nchar L[HMAX][WMAX];\nint w,h;\n\nvoid dfsW(int y, int x){\n  if (L[y][x]=='.')\n    L[y][x]='P';\n  for (int i=0;i<4;i++){\n    int mx=x+dx[i];\n    int my=y+dy[i];\n    if ((0<=mx && mx<w) && (0<=my && my<h) && (L[my][mx]=='.'))\n      dfsW(my,mx);\n  }  \n}\n\nvoid dfsB(int y, int x){\n  if (L[y][x]=='.')\n    L[y][x]='Q';\n  else if (L[y][x]=='P')\n    L[y][x]='N';\n  for (int i=0;i<4;i++){\n    int mx=x+dx[i];\n    int my=y+dy[i];\n    if ((0<=mx && mx<w) && (0<=my && my<h) && (L[my][mx]=='.' || L[my][mx]=='P'))\n      dfsB(my,mx);\n  }  \n}\n\nint main(){\n  while (true){\n    scanf(\"%d %d\",&w,&h);\n    if (w==0 && h==0) return 0;\n    for (int i=0;i<h;i++)\n      scanf(\"%s\",L[i]);\n    for (int i=0;i<h;i++){\n      for (int j=0;j<w;j++)\n\tif (L[i][j]=='W')\n\t  dfsW(i,j);\n    }\n    for (int i=0;i<h;i++){\n      for (int j=0;j<w;j++)\n\tif (L[i][j]=='B')\n\t  dfsB(i,j);\n    }\n    int cntB=0,cntW=0;\n    for (int i=0;i<h;i++){\n      for (int j=0;j<w;j++)\n\tif (L[i][j]=='P')\n\t  cntW++;\n\telse if (L[i][j]=='Q')\n\t  cntB++;\n    }\n    printf(\"%d %d\\n\",cntB,cntW);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cstring>\nusing namespace std;\n\n#define MAX_WH 50\n\nint w, h;\nstring field[MAX_WH];\nbool wflag[MAX_WH][MAX_WH];\nbool bflag[MAX_WH][MAX_WH];\n\nint dx[] = {0, -1, 0, 1};\nint dy[] = {-1, 0, 1, 0};\n\nvoid bdfs(int y, int x) {\n\tbflag[y][x] = true;\n\tfor (int i = 0; i < 4; i++) {\n\t\tint ny = y + dy[i], nx = x + dx[i];\n\t\tif (0 <= ny && ny < h && 0 <= nx && nx < w && field[ny][nx] != 'W' && bflag[ny][nx] != true)\n\t\t\tbdfs(ny, nx);\n\t}\n}\n\nvoid wdfs(int y, int x) {\n\twflag[y][x] = true;\n\tfor (int i = 0; i < 4; i++) {\n\t\tint ny = y + dy[i], nx = x + dx[i];\n\t\tif (0 <= ny && ny < h && 0 <= nx && nx < w && field[ny][nx] != 'B' && wflag[ny][nx] != true)\n\t\t\twdfs(ny, nx);\n\t}\n}\n\nint count_b() {\n\tint cnt = 0;\n\tfor (int i = 0; i < h; i++) {\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tif (bflag[i][j] && !wflag[i][j] && field[i][j] == '.') cnt++;\n\t\t}\n\t}\n\treturn cnt;\n}\n\nint count_w() {\n\tint cnt = 0;\n\tfor (int i = 0; i < h; i++) {\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tif (wflag[i][j] && !bflag[i][j] && field[i][j] == '.') cnt++;\n\t\t}\n\t}\n\treturn cnt;\n}\n\n\nint main() {\n\twhile (cin >> w >> h) {\n\t\tif (w == 0 && h == 0) break;\n\t\tmemset(bflag, 0, sizeof(bflag));\n\t\tmemset(wflag, 0, sizeof(wflag));\n\t\tfor (int i = 0; i < h; i++) cin >> field[i];\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (field[i][j] == 'B') bdfs(i, j);\n\t\t\t\telse if (field[i][j] == 'W') wdfs(i, j);\n\t\t\t}\n\t\t}\n\t\tcout << count_b() << ' ' << count_w() << endl;\n//\t\tfor (int i = 0; i < h; i++) {\n//\t\t\tfor (int j = 0; j < w; j++) {\n//\t\t\t\tif (bflag[i][j] && wflag[i][j]) cout << \"x \";\n//\t\t\t\telse if (bflag[i][j]) cout << \"b \";\n//\t\t\t\telse if (wflag[i][j]) cout << \"w \";\n//\t\t\t\telse cout << \"n \";\n//\t\t\t}\n//\t\t\tcout << endl;\n//\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n\nusing namespace std;\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n#define pb push_back\n\nint w,h;\nvector<string> board;\n\nbool input(){\n\tcin>>w>>h;\n\tif(w==0)return false;\n\t\n\tboard.clear();\n\trep(i,h){\n\t\tstring s;\n\t\tcin>>s;\n\t\tboard.pb(s);\n\t}\n\treturn true;\n}\n\nint B,W;\n\nint saiki(int y,int x){\n\tif(y<0 || y>=h || x<0 || x>=w)return 0;\n\t\n\tif(board[y][x]=='#')return 0;\n\t\n\tif(board[y][x]=='W'){\n\t\tW++;\n\t\treturn 0;\n\t}\n\tif(board[y][x]=='B'){\n\t\tB++;\n\t\treturn 0;\n\t}\n\t\n\tint ret = 1;\n\tint dx[] = {1,0,-1,0};\n\tint dy[] = {0,1,0,-1};\n\t\n\tboard[y][x]='#';\n\t\n\trep(i,4){\n\t\tret += saiki(y+dy[i], x+dx[i]);\n\t}\n\t\n\treturn ret;\n}\n\nvoid solve(){\n\tint ansB = 0;\n\tint ansW = 0;\n\trep(i,h){\n\t\trep(j,w){\n\t\t\tB=0;\n\t\t\tW=0;\n\t\t\t\n\t\t\tint cnt = saiki(i,j);\n\t\t\t\n\t\t\tif(W==0 && B!=0)ansB += cnt;\n\t\t\tif(B==0 && W!=0)ansW += cnt;\n\t\t}\n\t}\n\t\n\tcout<<ansB<<\" \"<<ansW<<endl;\n}\n\nint main(){\n\twhile(input())solve();\n}"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\n#define stlice(from, to) substr(from, (to) - (from) + 1)\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\nusing namespace std;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\nusing vd = vector<double>;\nusing vc = vector<char>;\nusing vb = vector<bool>;\nusing vs = vector<string>;\nusing vpii = vector<pii>;\nusing vvi = vector<vi>;\nusing vvb = vector<vb>;\nusing vvpii = vector<vpii>;\ntemplate<typename A> using fn = function<A>;\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = acos(-1);\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nconstexpr bool odd(const int &n) { return n & 1; }\nconstexpr bool even(const int &n) { return !odd(n); }\nvoid solve();\nmain { solve(); return 0; }\n// clang-format on\n\nvoid solve() {\n  int W, H;\n  while (cin >> W >> H, W) {\n    vs v(H);\n    rep(i, H) cin >> v[i];\n    vvi dp(H, vi(W));\n    int b = 0, w = 0;\n    rep(i, H) rep(j, W) {\n      dp[i][j] = 2 * (v[i][j] == 'B') + (v[i][j] == 'W');\n      b -= v[i][j] == 'B';\n      w -= v[i][j] == 'W';\n    }\n    rep(_, W * H) rep(i, H) rep(j, W) {\n      if (v[i][j] != '.') continue;\n      if (i > 0) dp[i][j] |= dp[i - 1][j];\n      if (j > 0) dp[i][j] |= dp[i][j - 1];\n      if (i < H - 1) dp[i][j] |= dp[i + 1][j];\n      if (j < W - 1) dp[i][j] |= dp[i][j + 1];\n    }\n    rep(i, H) rep(j, W) {\n      b += dp[i][j] == 2;\n      w += dp[i][j] == 1;\n    }\n    cout << b << ' ' << w << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<cstring>\n#include<queue>\n\nusing namespace std;\n\n#define INF 999999999\n\nvector <string> a(52);\nqueue<pair <int, int> > q[2];\nbool c[2][52][52];\nint f[2];\n\nvoid search(int x, int y, int z){\n\tpair<int, int> r;\n\tif(a[x][y] == '.')f[z]++;\n\tif(a[x+1][y]=='.'&&c[z][x+1][y]==0){\n\t\tc[z][x+1][y] = 1;\n\t\tr.first = x+1;\n\t\tr.second = y;\n\t\tq[z].push(r);\n\t}\n\tif(a[x-1][y]=='.'&&c[z][x-1][y]==0){\n\t\tc[z][x-1][y] = 1;\n\t\tr.first = x-1;\n\t\tr.second = y;\n\t\tq[z].push(r);\n\t}\n\tif(a[x][y-1]=='.'&&c[z][x][y-1]==0){\n\t\tc[z][x][y-1] = 1;\n\t\tr.first = x;\n\t\tr.second = y-1;\n\t\tq[z].push(r);\n\t}\n\tif(a[x][y+1]=='.'&&c[z][x][y+1]==0){\n\t\tc[z][x][y+1] = 1;\n\t\tr.first = x;\n\t\tr.second = y+1;\n\t\tq[z].push(r);\n\t}\n\tq[z].pop();\n\tif(!q[z].empty()) search(q[z].front().first, q[z].front().second, z);\n}\n\nint main(){\n\tint i, j, w, h;\n\tstring s;\n\tpair<int, int> d;\n\twhile(1){\n\t\tcin >> w >> h;\n\t\tif(!w)break;\n\t\tfor(i=0;i<=h+1;i++){\n\t\t\tfor(j=0;j<=w;j++){\n\t\t\t\tc[0][i][j] = 0;\n\t\t\t\tc[1][i][j] = 0;\n\t\t\t\tif(i==0||i==h+1) a[i] = \"####################################################\";\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=h;i++){\n\t\t\tcin >> s;\n\t\t\ta[i] = \"#\" + s + \"#\";\n\t\t}\n\t\t\n\t\tint common = 0;\n\t\tf[0]=0;\n\t\tf[1]=0;\n\t\tfor(i=1;i<=h;i++){\n\t\t\tfor(j=1;j<=w;j++){\n\t\t\t\td.first = i;\n\t\t\t\td.second = j;\n\t\t\t\tif(a[i][j]=='B'){\n\t\t\t\t\tc[0][i][j] = 1;\n\t\t\t\t\tq[0].push(d);\n\t\t\t\t}\n\t\t\t\telse if(a[i][j]=='W'){\n\t\t\t\t\tc[1][i][j] = 1;\n\t\t\t\t\tq[1].push(d);\n\t\t\t\t}\n\t\t\t\telse common++;\n\t\t\t}\n\t\t}\n\t\tif(q[0].empty() && q[1].empty()){\n\t\t\tcout << \"0 0\" << endl;\n\t\t}\n\t\telse{\n\t\t\tif(!q[0].empty()) search(q[0].front().first, q[0].front().second, 0);\n\t\t\tif(!q[1].empty()) search(q[1].front().first, q[1].front().second, 1);\n\t\t\t//cout << common << \" \" << f[0] << \" \" << f[1] << endl;\n\t\t\tcout << common-f[1] << \" \" << common-f[0] << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#include<bits/stdc++.h>\n#include<cstdio>\n#include<cstdlib>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<set>\n#include<string>\n#include<cmath>\n#include<cassert>\n#include<map>\n  using namespace std;\n\ntypedef long long ll;\ntypedef ll int__;\n#define rep(i,j) for(int__ (i)=0;(i)<(j);(i)++)\n#define repeat(i,j,k) for(int__ i=(j);i<(k);(i)++)\n#define all(v) begin(v),end(v)\n\n#define W    0b01\n#define B    0b10\n#define WW 0b0100\n#define BB 0b1000\n\n\nconst int dx[]={0,1,0,-1};\nconst int dy[]={1,0,-1,0};\n\nint w,h;\n\nvoid rec(vector< vector<unsigned char> > &s,unsigned char symbol,int x,int y){\n  rep(dir,4){\n    int nx =x+dx[dir];\n    int ny =y+dy[dir];\n    if(0<=nx and nx <w and 0<=ny and ny<h){\n      if(!(s[ny][nx]&WW) && !(s[ny][nx]&BB)){\n        if((s[ny][nx]&symbol) ==0){\n          s[ny][nx]|=symbol;\n          rec(s,symbol,nx,ny);\n        }\n      }\n    }\n  }\n}\n\n\nint main()\n{\n  while(true){\n    cin>>w>>h;\n    if(w==0 and h==0)break;\n    vector<string> s(h);\n    vector< vector<unsigned char> > flgs(h,vector<unsigned char>(w,0));\n    rep(i,h)cin>>s[i];\n    rep(i,h){\n      rep(j,w){\n        if(s[i][j]=='.')flgs[i][j]=0;\n        if(s[i][j]=='W')flgs[i][j]=WW;\n        if(s[i][j]=='B')flgs[i][j]=BB;\n      }\n    }\n\n    rep(y,h){\n      rep(x,w){\n        if(flgs[y][x]&WW)rec(flgs,W,x,y);\n        else if(flgs[y][x]&BB)rec(flgs,B,x,y);\n      }\n    }\n\n    int white=0,black=0;\n    rep(y,h){\n      rep(x,w){\n        if(!(flgs[y][x]&WW) && !(flgs[y][x]&BB)){\n          if((flgs[y][x]&W) && (flgs[y][x]&B)){\n            //putchar('A');\n            continue;\n          }\n          else if(flgs[y][x]&W){\n            //putchar('W');\n            white++;\n          }\n          else if( flgs[y][x]&B){\n            //putchar('B');\n            black++;\n          }\n        }\n        else{\n          //putchar(flgs[y][x]&WW ? 'W' : 'B');\n          ;\n        }\n      }\n      //puts(\"\");\n    }\n\n    cout<<black<<\" \"<<white<<endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,1,0,-1};\n\nstruct lattice{\n  bool wallB,wallW,black,white;\n};\n\nstruct zahyou{\n  int x;\n  int y;\n};\n\nint main() {\n  vector<int> ans_B,ans_W;\n  while(1){\n    int w,h;\n    char a;\n    cin >> w >> h;\n    if(!w && !h)break;\n    vector<vector<lattice> > v(h+2);\n    for(int i = 1;i <= h;i++){\n      vector<lattice> q(w+2);\n      lattice l;\n      l.wallB = 0;\n      l.wallW = 0;\n      l.black = 0;\n      l.white = 0;\n      q[0] = l;\n      q[h+1] = l;\n      for(int j = 1;j <= w;j++){\n        cin >> a;\n        l.wallB = 0;\n        l.wallW = 0;\n        l.black = 0;\n        l.white = 0;\n        if(a == 'W')l.wallW = 1;\n        if(a == 'B')l.wallB = 1;\n        q[j] = l;\n      }\n      v[i] = q;\n    }\n\n\n\n    for(int j = 0;j <= w+1;j++){\n      lattice l;\n      l.wallB = 0;\n      l.wallW = 0;\n      l.black = 0;\n      l.white = 0;\n      v[0].push_back(l);\n      v[h+1].push_back(l);\n    }\n    \n    for(int i = 1;i <= h;i++){\n      for(int j = 1;j <= w;j++){\n        if(v[i][j].wallW){\n          queue<zahyou> que;\n          zahyou z;\n          z.x = i;\n          z.y = j;\n          que.push(z);\n          while(que.size()){\n            cout << que.size() << endl;\n            for(int k = 0;k < 4;k++){\n              if(1 <= que.front().x && que.front().x <= h && 1 <= que.front().y && que.front().y <= w){\n                if(!v[que.front().x + dx[k]][que.front().y + dy[k]].white && !v[que.front().x + dx[k]][que.front().y + dy[k]].wallB && !v[que.front().x + dx[k]][que.front().y + dy[k]].wallW){\n                  z.x = que.front().x + dx[k];\n                  z.y = que.front().y + dy[k];\n                  que.push(z);\n                  v[que.front().x + dx[k]][que.front().y + dy[k]].white = 1;\n                }\n              }\n            }\n            que.pop();\n          }\n        }\n        if(v[i][j].wallB){\n          queue<zahyou> que;\n          zahyou z;\n          z.x = i;\n          z.y = j;\n          que.push(z);\n          while(que.size()){\n            cout << que.size() << endl;\n            for(int k = 0;k < 4;k++){\n              if(1 <= que.front().x && que.front().x <= h && 1 <= que.front().y && que.front().y <= w){\n                if(!v[que.front().x + dx[k]][que.front().y + dy[k]].black && !v[que.front().x + dx[k]][que.front().y + dy[k]].wallB && !v[que.front().x + dx[k]][que.front().y + dy[k]].wallW){\n                  z.x = que.front().x + dx[k];\n                  z.y = que.front().y + dy[k];\n                  que.push(z);\n                  v[que.front().x + dx[k]][que.front().y + dy[k]].black = 1;\n                }\n              }\n            }\n            que.pop();\n          }\n        }\n      }\n    }\n    int countB=0,countW=0;\n    for(int i = 1;i <= h;i++){\n      for(int j = 1;j <= w;j++){\n        if(v[i][j].black && v[i][j].white){}\n        else if(v[i][j].black && !v[i][j].wallB && !v[i][j].wallW){\n          countB++;\n        }\n        else if(v[i][j].white && !v[i][j].wallB && !v[i][j].wallW){\n          countW++;\n        }\n      }\n    }\n    ans_B.push_back(countB);\n    ans_W.push_back(countW);\n  }\n  for(int i = 0;i < ans_B.size();i++)cout << ans_B[i] << \" \" << ans_W[i] << endl;\n}\n\n44 15\nBB.BBWWB.W.W.B.WWBWBBWWWB.BWWBBBWWBBWBWB.W.W\nWBW..B..BWWBWBBWWBWB..BWBWB...B.WBWBW...W.W.\n...WBWWBBW.BBB.WB.B.WW.B.WBBBB.BWBBBW.W.B.BB\nW.B.B.W.WWBBWBB..B...WWWWB.WBWWWBWBB.W.BBBW.\n.WW.WB.WWB.WBW...BB...BBWWBWW..BWW.WWBB.B.B.\n.WW..WBW.BWWWB..WBB..W.WBWWBBWW.BBWWWWW....W\n..W.WWBBB..BBBB..BW.BBBBBWWBBBWWW..WW..B.BBW\nBBW.BWBBBWWBB..BWW.W..BWWW.WB.BBWWBW..WB.WWB\nB.BB....W.BW.BWW..WBBBW.....WB.W.WBWBB.WBB.B\nB.WWW...W..WWBBW.BBWWBB....WWBWWWBW..WW.BWBB\nW.WWWWWBWBWWWBB..W.BBBBB...B.BWWWW.WW..WB.WB\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nstruct data\n{\n\tint x;\n\tint y;\n};\nstruct mapData\n{\n\tint black;\n\tint white;\n};\nint main()\n{\n\tint w, h;\n\tint dx[4] = {1,0,-1,0};\n\tint dy[4] = {0,1,0,-1};\n\twhile (cin >> w >> h && w != 0 || h != 0)\n\t{\n\t\tchar map[50][50];\n\t\tfor (int i = 0; i < h; i++)\n\t\t{\n\t\t\tcin >> map[i];\n\t\t}\n\n\t\tmapData whiteBlack[50][50];\n\t\tfor (int i = 0; i < h; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t{\n\t\t\t\twhiteBlack[i][j].black = 0;\n\t\t\t\twhiteBlack[i][j].white = 0;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < h; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t{\n\t\t\t\tif (map[i][j] == '.')continue;\n\t\t\t\tint color = (map[i][j] == 'B' ? 1 : 2);\n\t\t\t\tqueue<data> q;\n\t\t\t\tdata first;\n\t\t\t\tfirst.x = j;\n\t\t\t\tfirst.y = i;\n\t\t\t\tq.push(first);\n\t\t\t\twhile (q.size() > 0)\n\t\t\t\t{\n\t\t\t\t\tdata d = q.front(); q.pop();\n\t\t\t\t\tif (map[d.y][d.x] == '.')\n\t\t\t\t\t{\n\t\t\t\t\t\tif (color == 1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\twhiteBlack[d.y][d.x].black = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\twhiteBlack[d.y][d.x].white = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (int k = 0; k < 4; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tint nx = dx[k] + d.x;\n\t\t\t\t\t\tint ny = dy[k] + d.y;\n\t\t\t\t\t\tif (nx >= w || ny >= h || nx < 0 || ny < 0)continue;\n\t\t\t\t\t\tif (map[ny][nx] == 'W' || map[ny][nx] == 'B')continue;\n\t\t\t\t\t\tif (color == 1 && whiteBlack[ny][nx].black == 1)continue;\n\t\t\t\t\t\tif (color == 2 && whiteBlack[ny][nx].white == 1)continue;\n\t\t\t\t\t\tdata add;\n\t\t\t\t\t\tadd.x = nx;\n\t\t\t\t\t\tadd.y = ny;\n\t\t\t\t\t\tq.push(add);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint white = 0;\n\t\tint black = 0;\n\t\tfor (int i = 0; i < h; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t{\n\t\t\t\tif (whiteBlack[i][j].black == 1 && whiteBlack[i][j].white == 0)\n\t\t\t\t{\n\t\t\t\t\tblack++;\n\t\t\t\t}\n\t\t\t\telse if (whiteBlack[i][j].white == 1 && whiteBlack[i][j].black == 0)\n\t\t\t\t{\n\t\t\t\t\twhite++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << black << \" \" << white << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector< vector<char> > a(55, vector<char>(55));\nvector< vector<int> > mp(55, vector<int>(55));\nint bb, ww;\n\nint dx[] = { 1, 0, -1, 0 };\nint dy[] = { 0, 1, 0, -1 };\n\nbool range(int x, int y, int h, int w) {\n\tif (0 <= x && x < w && 0 <= y && y < h) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nint cc;\n\nvoid count(int x, int y, int h, int w) {\n\tfor (int i = 0; i < 4; i++) {\n\t\tif (range(x + dx[i], y + dy[i], h, w)) {\t\t\t\t\n\t\t\tif (mp[y+dy[i]][x+dx[i]] == -1) {\n\t\t\t\tif (a[y + dy[i]][x + dx[i]] == 'B') {\n\t\t\t\t\tbb = 1;\n\t\t\t\t}\n\t\t\t\telse if (a[y + dy[i]][x + dx[i]] == 'W') {\n\t\t\t\t\tww = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcc++;\n\t\t\t\tmp[y + dy[i]][x + dx[i]] = -1;\n\t\t\t\tcount(x + dx[i], y + dy[i], h, w);\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\nint main() {\n\tint w, h;\n\twhile (cin >> w >> h) {\n\t\tif (w == 0 && h == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tcin >> a[i][j];\n\t\t\t\tif (a[i][j] == '.') {\n\t\t\t\t\tmp[i][j] = 0;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmp[i][j] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint b2, w2;\n\t\tb2 = w2 = 0;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tbb = ww = cc = 0;\n\t\t\t\tif (mp[i][j] != -1) {\n\t\t\t\t\tmp[i][j] = -1;\n\t\t\t\t\tcc = 1;\n\t\t\t\t\tcount(j, i, h, w);\n\t\t\t\t\t//cout << bb << ' ' << ww << ' ' << cc << endl;\n\t\t\t\t\tif (bb == 1 && ww == 1) {\n\n\t\t\t\t\t}\n\t\t\t\t\telse if (bb == 1) {\n\t\t\t\t\t\tb2 += cc;\n\t\t\t\t\t}\n\t\t\t\t\telse if (ww == 1){\n\t\t\t\t\t\tw2 += cc;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << b2 << ' ' << w2 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<map>\n#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<string>\n#include<map>\n#include<cmath>\n#include<queue>\t\n#include<functional>\n#include<climits>\n\nusing namespace std;\n\n//define\n#define ALL(a) a.begin(),a.end()\n#define REP(i,n) for(int i=0;i<n;i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n#define debug(x) if(1)cout<<#x<<\":\"<<x<<endl;\n#define DEBUG(x) if(1)cout<<#x<<\":\"<<x<<endl;\n#define ll long long\n#define pb push_back\n#define PB push_back\n#define lb lower_bound\n#define LB lower_bound\n#define ub upper_bound\n#define UB upper_bound\n\n\n//constant\nconst int MOD = 1000000007;\nconst int INF = INT_MAX / 2-1;\nconst double EPS = 1e-9;\nconst int dx4[4] = { 1,0,-1,0 };\nconst int dy4[4] = { 0,1,0,-1 };\n\n//typedef\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef pair<int, int> pii;\n\nint w, h;\nvoid dfs(int y, int x, vvi &a, vvi &p);\n\nint main() {\n\twhile (cin >> w >> h, w) {\n\t\tvvi a(h, vi(w, 0));\n\t\tvvi bp(h, vi(w, 0));\n\t\tvvi wp(h, vi(w, 0));\n\t\tstring buf;\n\t\tREP(i, h) {\n\t\t\tcin >> buf;\n\t\t\tREP(j, w)\n\t\t\t\tif (buf[j] == 'B')\n\t\t\t\t\ta[i][j] = 1;\n\t\t\t\telse if (buf[j] == 'W')\n\t\t\t\t\ta[i][j] = -1;\n\t\t}\n\t\tREP(i,h)\n\t\t\tREP(j,w)\n\t\t\t\tif(a[i][j]==1)\n\t\t\t\t\tdfs(i, j, a, bp);\n\t\tREP(i, h)\n\t\t\tREP(j, w)\n\t\t\tif (a[i][j] == -1)\n\t\t\t\tdfs(i, j, a, wp);\n\t\tint bc = 0;\n\t\tint wc = 0;\n\t\tREP(i, h)\n\t\t\tREP(j, w)\n\t\t\tif (bp[i][j] && wp[i][j])\n\t\t\t\tcontinue;\n\t\t\telse if (bp[i][j])\n\t\t\t\tbc++;\n\t\t\telse if (wp[i][j])\n\t\t\t\twc++;\n\t\tcout << bc << \" \" << wc << endl;\n\n\t}\n\t\n\t\n}\n\nvoid dfs(int y, int x, vvi &a, vvi &p) {\n\tREP(i,4)\n\t\tif(0<=y+dy4[i] && y+dy4[i]<h && 0<=x+dx4[i] && x+dx4[i] <w)\n\t\t\tif(!a[y+dy4[i]][x+dx4[i]] && !p[y+dy4[i]][x+dx4[i]])\n\t\t\t\tp[y + dy4[i]][x + dx4[i]] = 1, dfs(y + dy4[i], x + dx4[i], a, p);\n\treturn;\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "//Surrounding Area\n#include<bits/stdc++.h>\nusing namespace std;\n#define TMP 9999\n#define INF 1000\n\nint n, m;\nvector<vector<int> > board;\n\n//4\nint dir[4][2]={{-1,0}, {0,1}, {1,0}, {0,-1}};\n\nvoid print(){\n  for(int i=0; i<n; i++){\n    for(int j=0; j<m; j++)\n      printf(\"%5d\", board[i][j]);\n    puts(\"\");\n  }\n}\n\nbool solve(int x, int y, int c){\n  if(!(0<=x && x<n && 0<=y && y<m))return true;//\n  if(board[x][y]==TMP)return true;//\n  if(board[x][y]==INF)return false;//\n  if(board[x][y]==c)return true;\n  if(board[x][y]==-c)return false;\n  if(board[x][y]==2*c)return true;\n  if(board[x][y]==-2*c)return false;\n  board[x][y]=TMP;\n  bool flag=true;\n  for(int i=0; i<4; i++){\n    if(!solve(x+dir[i][0], y+dir[i][1], c)){\n      flag=false;\n      break;\n    }\n  }\n  if(flag){\n    board[x][y]=c*2;\n    return true;\n  }\n  else{\n    board[x][y]=INF;\n    return false;\n  }\n}\n\nint main(){\n  while(true){\n    cin>>m>>n;\n    board.clear();\n    if(n==0 && m==0)break;\n    for(int i=0; i<n; i++){\n      vector<int> tmp;\n      for(int j=0; j<m; j++){\n        char c;\n        cin>>c;\n        int t;\n        if(c=='.')t=0;\n        if(c=='W')t=1;\n        if(c=='B')t=-1;\n        tmp.push_back(t);\n      }\n      board.push_back(tmp);\n    }\n\n    for(int i=0; i<n; i++){\n      for(int j=0; j<m; j++){\n        if(board[i][j]==1){\n          for(int k=0; k<4; k++)solve(i+dir[k][0], j+dir[k][1], 1);\n        }\n        if(board[i][j]==-1){\n          for(int k=0; k<4; k++)solve(i+dir[k][0], j+dir[k][1], -1);\n        }\n      }\n    }\n    /*\n    puts(\"\");\n    print();\n    puts(\"\");\n    */\n    int nw=0, nb=0;\n    for(int i=0; i<n; i++)\n      for(int j=0; j<m; j++)\n        if(board[i][j]==2)nw++;\n        else if(board[i][j]==-2)nb++;\n    cout<<nb<<' '<<nw<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n\nusing namespace std;\n\nchar ground[100][100]={'*'};\n\nvoid jin_w(int i,int j){\n  if(ground[i][j-1]=='.'){\n    ground[i][j-1]='w';\n    jin_w(i,j-1);\n  }\n  else if(ground[i][j-1]=='b'){\n    ground[i][j-1]='*';\n    jin_w(i,j-1);\n  }\n  if(ground[i+1][j]=='.'){\n    ground[i+1][j]='w';\n    jin_w(i+1,j);\n  }\n  else if(ground[i+1][j]=='b'){\n    ground[i+1][j]='*';\n    jin_w(i+1,j);\n  }\n  if(ground[i][j+1]=='.'){\n    ground[i][j+1]='w';\n    jin_w(i,j+1);\n  }\n  else if(ground[i][j+1]=='b'){\n    ground[i][j+1]='*';\n    jin_w(i,j+1);\n  }\n  if(ground[i-1][j]=='.'){\n    ground[i-1][j]='w';\n    jin_w(i-1,j);\n  }\n  else if(ground[i-1][j]=='b'){\n    ground[i-1][j]='*';\n    jin_w(i-1,j);\n  } \n}\n\nvoid jin_b(int i,int j){\n  if(ground[i][j-1]=='.'){\n    ground[i][j-1]='b';\n    jin_b(i,j-1);\n  }\n  else if(ground[i][j-1]=='w'){\n    ground[i][j-1]='*';\n    jin_b(i,j-1);\n  }\n  if(ground[i+1][j]=='.'){\n    ground[i+1][j]='b';\n    jin_b(i+1,j);\n  }\n  else if(ground[i+1][j]=='w'){\n    ground[i+1][j]='*';\n    jin_b(i+1,j);\n  }\n  if(ground[i][j+1]=='.'){\n    ground[i][j+1]='b';\n    jin_b(i,j+1);\n  }\n  else if(ground[i][j+1]=='w'){\n    ground[i][j+1]='*';\n    jin_b(i,j+1);\n  }\n  if(ground[i-1][j]=='.'){\n    ground[i-1][j]='b';\n    jin_b(i-1,j);\n  }\n  else if(ground[i-1][j]=='w'){\n    ground[i-1][j]='*';\n    jin_b(i-1,j);\n  } \n}\n\nint main(){\n  int w,h;\n\n  while(cin>>w>>h,w,h){\n    int cnt_w=0;\n    int cnt_b=0;\n    \n    // fill(begin(ground),end(ground),\"*\");\n      \n    for(int i=1;i<h+1;++i){\n      for(int j=1;j<w+1;++j){\n\tcin>>ground[i][j];\n      }\n    }\n    for(int i=1;i<h+1;++i){\n      for(int j=1;j<w+1;++j){\n\tif(ground[i][j]=='W')\n\t  jin_w(i,j);\n\telse if(ground[i][j]=='B')\n\t  jin_b(i,j);\n      }\n    }\n    for(int i=1;i<h+1;++i){\n      for(int j=1;j<w+1;++j){\n\tif(ground[i][j]=='w')\n\t  cnt_w++;\n\telse if(ground[i][j]=='b')\n\t  cnt_b++;\n      }\n    }\n    cout<<cnt_b<<' '<<cnt_w<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\n#include <tuple>\nusing namespace std;\nusing P = pair<int,int>;\n\nchar A[50][50];\nbool isB[50][50];\nbool isW[50][50];\n\nint main(){\n    int w,h;\n    deque<P> B,W;\n    while(cin>>w>>h,w){\n        B.clear();\n        W.clear();\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                cin>>A[i][j];\n                if(A[i][j]=='B')B.emplace_back(i,j);\n                if(A[i][j]=='W')W.emplace_back(i,j);\n            }\n        }\n        fill(isB[0],isB[50],false);\n        fill(isW[0],isW[50],false);\n        while(!B.empty()){\n            int y,x;\n            tie(y,x) = B.front(); B.pop_front();\n            isB[y][x]=true;\n            int d[5]={0,1,0,-1,0};\n            for(int i=0;i<4;i++){\n                int yy=y+d[i],xx=x+d[i+1];\n                if(yy<0||yy>=h||xx<0||xx>=w) continue;\n                if(!isB[yy][xx]&&A[yy][xx]=='.'){\n                    B.emplace_back(yy,xx);\n                }\n            }\n        }\n        while(!W.empty()){\n            int y,x;\n            tie(y,x) = W.front(); W.pop_front();\n            isW[y][x]=true;\n            int d[5]={0,1,0,-1,0};\n            for(int i=0;i<4;i++){\n                int yy=y+d[i],xx=x+d[i+1];\n                if(yy<0||yy>=h||xx<0||xx>=w) continue;\n                if(!isW[yy][xx]&&A[yy][xx]=='.'){\n                    W.emplace_back(yy,xx);\n                }\n            }\n        }\n        int ansB=0,ansW=0;\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                if(A[i][j]=='.'&&isB[i][j]&&!isW[i][j]) ansB++;\n                if(A[i][j]=='.'&&!isB[i][j]&&isW[i][j]) ansW++;\n            }\n        }\n        cout<<ansB<<' '<<ansW<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<cstdlib>\n#include<map>\n#include<iomanip>\n#include<sstream>\n#include<vector>\n#include<stack>\n#include<math.h>\n#include<queue>\n#include<complex>\n#include<random>\n#include<ctime>\n#include<set>\nusing namespace std;\n\n\nconst long long int mod=1000000007;\nconst long long int INF=99999999999999999;\n\n\n//0-indexed\nclass BreadthFirstSearch\n{\npublic:\n\tlong long int **Used,**BFSResult;\n\tchar **HW;\n\tlong long int MaxH,MaxW,Counter;\n\tbool Black,White;\n\tstack<pair<long long int,long long int> >Root;\n\t\n\tBreadthFirstSearch(long long int H,long long int W){\n\t\t\tMaxH=H;\n\t\t\tMaxW=W;\n\t\t\tHW= new char*[H];\n\t\t\tUsed= new long long int*[H];\n\t\t\tBFSResult= new long long int*[H];\n\t\t\tfor(int i=0;i<H;i++)\n\t\t\t{\n\t\t\t\t\tHW[i]= new char[W];\n\t\t\t\t\tUsed[i]= new long long int[W];\n\t\t\t\t\tBFSResult[i]= new long long int[W];\n\t\t\t}\n\t}\n\t\n\tvoid DoBFS(pair<long long int,long long int>Start){\n\t\tfor(int i=0;i<MaxH;i++)\n\t\t{\n\t\t\tfor(int j=0;j<MaxW;j++)\n\t\t\t{\n\t\t\t\tUsed[i][j]=0;\n\t\t\t\tBFSResult[i][j]=INF;\n\t\t\t}\n\t\t}\n\t\tBlack=false;\n\t\tWhite=false;\n\t\tCounter=0;\n\t\tqueue<pair<long long int,long long int> >task;\n\t\ttask.push(Start);\n\t\tUsed[Start.first][Start.second]=1;\n\t\t\n\t\twhile(!task.empty())\n\t\t{\n\t\t\tCounter++;\n\t\t\tlong long int h=task.front().first;\n\t\t\tlong long int w=task.front().second;\n\t\t\tfor(int i=-1;i<=1;i++)\n\t\t\t{\n\t\t\t\tfor(int j=-1;j<=1;j++)\n\t\t\t\t{\n\t\t\t\t\tif(h+i<0||w+j<0||h+i>=MaxH||w+j>=MaxW||i!=0&&j!=0)\n\t\t\t\t\t{\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(Used[h+i][w+j]==0&&HW[h+i][w+j]=='.')\n\t\t\t\t\t{\n\t\t\t\t\t\t\tUsed[h+i][w+j]=1;\n\t\t\t\t\t\t\tBFSResult[h+i][w+j]=BFSResult[h][w]+1;\n\t\t\t\t\t\t\ttask.push({h+i,w+j});\n\t\t\t\t\t}else if(Used[h+i][w+j]==0&&HW[h+i][w+j]=='B'){\n\t\t\t\t\t\tBlack=true;\n\t\t\t\t\t}else if(Used[h+i][w+j]==0&&HW[h+i][w+j]=='W'){\n\t\t\t\t\t\tWhite=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\ttask.pop();\n\t\t}\n\t}\n\t\n\tvoid RootCheck(pair<long long int,long long int>Goal){\n\t\tpair<long long int,long long int>now=Goal;\n\t\twhile(!Root.empty()){\n\t\t\tRoot.pop();\n\t\t}\n\t\tRoot.push(Goal);\n\t\twhile(BFSResult[now.first][now.second]!=0)\n\t\t{\n\t\t\tbool key=false;\n\t\t\tfor(int i=-1;i<=1;i++)\n\t\t\t{\n\t\t\t\tfor(int j=-1;j<=1;j++)\n\t\t\t\t{\n\t\t\t\t\tif(now.first+i<0||now.second+j<0||now.first+i>=MaxH||now.second+j>=MaxW||i!=0&&j!=0)\n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(BFSResult[now.first+i][now.second+j]==BFSResult[now.first][now.second]-1&&HW[now.first+i][now.second+j]=='.')\n\t\t\t\t\t{\n\t\t\t\t\t\tRoot.push({now.first+i,now.second+j});\n\t\t\t\t\t\tkey=true;\n\t\t\t\t\t\tnow={now.first+i,now.second+j};\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(key)\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n        \n};\n\n\nint main() {\n\tcout << fixed << setprecision(18);\n\tlong long int H,W,Counter=0;\n\tcin>>W>>H;\n\twhile(H!=0){\n\t\tlong long int Bl=0,Wh=0;\n\t\tchar resmap[51][51];\n\t\tBreadthFirstSearch bfs(H,W);\n\t\tfor(int i=0;i<H;i++){\n\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\tcin>>bfs.HW[i][j];\n\t\t\t\tif(bfs.HW[i][j]=='.'){Counter++;}\n\t\t\t\tresmap[i][j]=bfs.HW[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<H;i++){\n\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\tif(bfs.HW[i][j]=='.'){\n\t\t\t\t\tbfs.DoBFS({i,j});\n\t\t\t\t\tif(bfs.Counter!=Counter||true){\n\t\t\t\t\t\tif(bfs.Black&&!bfs.White){Bl++;resmap[i][j]='p';}\n\t\t\t\t\t\tif(bfs.White&&!bfs.Black){Wh++;resmap[i][j]='q';}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<Bl<<\" \"<<Wh<<endl;\n\t\tcin>>W>>H;\n\t}\n\t\n} \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>=0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<int, P> PIP;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\ntypedef set<int> S;\n\n#define INF INT_MAX/3\n#define MAX_N 1000000001\n\nint w, h;\nvector<string> island(50);\nP land[50][50];\nint dd[] = {1, 0, -1, 0, 1};\n\nbool range(int y, int x) {\n  return 0 <= y && y <= h && 0 <= x && x <= w;\n}\n\nvoid dfs(int y, int x, bool b) {\n  if(b) land[y][x].fi = 1;\n  else land[y][x].se = 1;\n\n  int yy, xx;\n  rep(i, 4) {\n    yy = y + dd[i], xx = x + dd[i + 1];\n    if (range(yy, xx)) {\n      if (b) {\n        if (island[yy][xx] == '.' && land[yy][xx].fi == 0) dfs(yy, xx, b);\n      } else {\n        if (island[yy][xx] == '.' && land[yy][xx].se == 0) dfs(yy, xx, b);\n      }\n    }\n  }\n}\n\nint main(){\n  cin.sync_with_stdio(false);\n  while(cin >> w >> h, w | h) {\n    rep(i, h) cin >> island[i];\n    rep(i, h)rep(j, w) land[i][j] = P(0, 0);\n    rep(i, h)rep(j, w) {\n      if (island[i][j] != '.') land[i][j] = P(1, 1), dfs(i, j, island[i][j] == 'B');\n    }\n\n    int black = 0, white = 0;\n    rep(i, h)rep(j, w) {\n      if (land[i][j].fi == 1 && land[i][j].se == 0) black++;\n      if (land[i][j].fi == 0 && land[i][j].se == 1) white++;\n    }\n\n    cout << black << \" \" << white << endl;\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define ll long long\n#define fi first\n#define se second\n#define pb push_back\n#define rep(i, s, n) for (int i = s; i < n; i++)\n#define rrep(i, s, n) for (int i = (n)-1; i >= (s); i--)\n#define REP(i,n) for(int i = 0;i < n; i++)\n#define all(a) a.begin(),a.end()\ntypedef pair<int,int>pint;\ntypedef vector<int>vint;\ntypedef vector<pint>vpint;\nconst long long MOD = 1000000007, INF = 1e18;\n\n#define endl '\\n'\n#define IOS() ios_base::sync_with_stdio(0);cin.tie(0)\n \ntemplate<class T>inline bool chmax(T& a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<class T>inline bool chmin(T& a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>vector<T>\nmake_v(size_t a){return vector<T>(a);}\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n\treturn vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value==0>::type\nfill_v(T &t,const V &v){t=v;}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t,const V &v){\n\tfor(auto &e:t) fill_v(e,v);\n}\n\nint dx[] = {1,0,0,-1};\nint dy[] = {0,1,-1,0};\n\nsigned main(){\n\t//IOS();\n\tvector<pint>ans;\n\twhile(1){\n\t\tint h,w;\n\t\tcin>>h>>w;\n\t\tif(w+h==0)break;\n\t\tstring s[w];\n\t\trep(i,0,w)cin>>s[i];\n\t\tvector<vector<int>>used(w,vector<int>(h,0));\n\t\tint B=0,W=0;\n\t\trep(i,0,w)rep(j,0,h){\n\t\t\tif(used[i][j]==0&&s[i][j]=='.'){\n\t\t\t\tstack<pair<int,int>>st;\n\t\t\t\tst.push({i,j});\n\t\t\t\tint black = 0,white = 0,cnt = 0;\n\t\t\t\twhile(!st.empty()){\n\t\t\t\t\tint I = st.top().fi;\n\t\t\t\t\tint J = st.top().se;\n\t\t\t\t\tst.pop();\n\t\t\t\t\tif(used[I][J])continue;\n\t\t\t\t\tused[I][J] = true;\n\t\t\t\t\tcnt++;\n\t\t\t\t\trep(k,0,4){\n\t\t\t\t\t\tint ni = I+dx[k];\n\t\t\t\t\t\tint nj = J+dy[k];\n\t\t\t\t\t\tif(ni<0||nj<0||w<=ni||h<=nj)continue;\n\t\t\t\t\t\tif(used[ni][nj])continue;\n\t\t\t\t\t\tif(s[ni][nj]=='B'){\n\t\t\t\t\t\t\tblack = 1;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(s[ni][nj]=='W'){\n\t\t\t\t\t\t\twhite = 1;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tst.push({ni,nj});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(black&&white)continue;\n\t\t\t\tif(black)B+=cnt;\n\t\t\t\tif(white)W+=cnt;\n\t\t\t}\n\t\t}\n\t\tans.push_back({B,W});\n\t}\n\tfor(auto e:ans){\n\t\tcout<<e.fi<<\" \"<<e.se<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>=0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<int, P> PIP;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\ntypedef set<int> S;\n\n#define INF INT_MAX/3\n#define MAX_N 1000000001\n\nint w, h;\nvector<string> island(51);\nP land[51][51];\nint dd[] = {1, 0, -1, 0, 1};\n\nbool range(int y, int x) {\n  return 0 <= y && y <= h && 0 <= x && x <= w;\n}\n\nvoid dfs(int y, int x, bool b) {\n  if(b) land[y][x].fi = 1;\n  else land[y][x].se = 1;\n\n  int yy, xx;\n  rep(i, 4) {\n    yy = y + dd[i], xx = x + dd[i + 1];\n    if (range(yy, xx)) {\n      if (b) {\n        if (island[yy][xx] == '.' && land[yy][xx].fi == 0) dfs(yy, xx, b);\n      } else {\n        if (island[yy][xx] == '.' && land[yy][xx].se == 0) dfs(yy, xx, b);\n      }\n    }\n  }\n}\n\nint main(){\n  cin.sync_with_stdio(false);\n  while(cin >> w >> h, w | h) {\n    rep(i, h) cin >> island[i];\n    rep(i, h)rep(j, w) land[i][j] = P(0, 0);\n    rep(i, h)rep(j, w) {\n      if (island[i][j] != '.') land[i][j] = P(1, 1), dfs(i, j, island[i][j] == 'B');\n    }\n\n    int black = 0, white = 0;\n    rep(i, h)rep(j, w) {\n      if (land[i][j].fi == 1 && land[i][j].se == 0) black++;\n      if (land[i][j].fi == 0 && land[i][j].se == 1) white++;\n    }\n\n    cout << black << \" \" << white << endl;\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<string>\n#include<string.h>\n#include<functional>\nusing namespace std;\n\n#define INF 1<<21\n#define DIV 1000000007\n\ntypedef pair<int, int>P;\n\n\nint w, h;\nint cnt;\nchar f[51][51];\nint dx[] = { 1,-1,0,0 }, dy[] = { 0,0,1,-1 };\n\nvoid rec(int x, int y, char c) {\n  for (int i = 0; i < 4; i++) {\n\tint nx = x + dx[i];\n\tint ny = y + dy[i];\n\tif (nx <= 0 || w < nx || ny <= 0 || h < ny )continue;\n\n\tif (c == 'B') {\n\t  if (f[ny][nx] == 'w') {\n\t\tf[ny][nx] = 'u';\n\t\trec(nx, ny, c);\n\t  }\n\t  else if (f[ny][nx] == '.') {\n\t\tf[ny][nx] = 'b';\n\t\trec(nx, ny, c);\n\t  }\n\t}\n\telse if (c == 'W') {\n\t  if (f[ny][nx] == 'b') {\n\t\tf[ny][nx] = 'u';\n\t\trec(nx, ny, c);\n\t  }\n\t  else if (f[ny][nx] == '.') {\n\t\tf[ny][nx] = 'w';\n\t\trec(nx, ny, c);\n\t  }\n\t}\n  }\n}\n\nint main(){\n  while (cin >> w >> h, (w || h)) {\n\tmemset(f, 0, sizeof(f));\n\tfor (int y = 1; y <= h; y++) {\n\t  for (int x = 1; x <= w; x++) {\n\t\tcin >> f[y][x];\n\t\t}\n\t  }\n\t}\n\n\tfor (int y = 1; y <= h; y++) {\n\t  for (int x = 1; x <= w; x++) {\n\t\tif (f[y][x] == 'W' || f[y][x] == 'B') {\n\t\t  rec(x, y, f[y][x]);\n\t\t}\n\t  }\n\t}\n\n\n\tint blacks = 0, whites = 0;\n\tfor (int y = 1; y<=h; y++) {\n\t  for (int x = 1; x<=w; x++) {\n\t\tcout << f[y][x] << \"\";\n\t\tif (f[y][x] == 'b') {\n\t\t  blacks++;\n\t\t}\n\t\telse if (f[y][x] == 'w') {\n\t\t  whites++;\n\t\t}\n\t  }\n\t  cout << endl;\n\t}\n\tcout << blacks << \" \" << whites << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int dx[4] = {0, 0, -1, 1};\nconst int dy[4] = {-1, 1, 0, 0};\nconst int W = 1;\nconst int B = 2;\nint w, h;\nvector<vector<int> > label;\n\nvoid dfs(int x, int y, int who) {\n\tlabel[y][x] |= who;\n\tfor(int i = 0; i < 4; ++i) {\n\t\tconst int nx = x + dx[i], ny = y + dy[i];\n\t\tif(nx < 0 || ny < 0 || nx >= w || ny >= h)\n\t\t\tcontinue;\n\n\t\tif(!(label[ny][nx] & who))\n\t\t\tdfs(nx, ny, who);\n\t}\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> w >> h, w) {\n\t\tvector<string> field(h);\n\t\tfor(int i = 0; i < h; ++i)\n\t\t\tcin >> field[i];\n\n\t\tlabel.clear();\n\t\tlabel.resize(h, vector<int>(w, 0));\n\t\tfor(int i = 0; i < h; ++i)\n\t\t\tfor(int j = 0; j < w; ++j)\n\t\t\t\tif(field[i][j] != '.')\n\t\t\t\t\tlabel[i][j] = (W | B);\n\n\t\tfor(int i = 0; i < h; ++i)\n\t\t\tfor(int j = 0; j < w; ++j)\n\t\t\t\tif(field[i][j] == 'W')\n\t\t\t\t\tdfs(j, i, W);\n\t\t\t\telse if(field[i][j] == 'B')\n\t\t\t\t\tdfs(j, i, B);\n\n\t\tint num_b = 0, num_w = 0;\n\t\tfor(int i = 0; i < h; ++i)\n\t\t\tfor(int j = 0; j < w; ++j)\n\t\t\t\tif(label[i][j] == W)\n\t\t\t\t\t++num_w;\n\t\t\t\telse if(label[i][j] == B)\n\t\t\t\t\t++num_b;\n\t\t\t\t\t\n\t\tcout << num_b << \" \" << num_w << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint w,h;\nstring field[50];\nint wb[2][50][50];\n\nint dx[] = {0,1,0,-1},dy[] = {1,0,-1,0};\n\nvoid dfs(int x,int y,int num){\n\tfor(int i = 0;i < 4;i++){\n\t\tint nx = x + dx[i],ny = y + dy[i];\n\t\tif(nx >= 0 && nx < h && ny >= 0 && ny < w && field[nx][ny] == '.' && !wb[num][nx][ny]){\n\t\t\twb[num][nx][ny] = 1;\n\t\t\tdfs(nx,ny,num);\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(cin >> w >> h,w){\n\t\tfor(int i = 0;i < h;i++) cin >> field[i];\n\t\tfor(int i = 0;i < h;i++){\n\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\twb[0][i][j] = 0;\n\t\t\t\twb[1][i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < h;i++){\n\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\tif(field[i][j] == 'W') dfs(i,j,1);\n\t\t\t\telse if(field[i][j] == 'B') dfs(i,j,0);\n\t\t\t}\n\t\t}\n\t\tint a = 0,b = 0;\n\t\tfor(int i = 0;i < h;i++){\n\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\tif(wb[0][i][j] && !wb[1][i][j]) a++;\n\t\t\t\telse if(wb[1][i][j] && !wb[0][i][j]) b++;\n\t\t\t}\n\t\t}\n\t\tcout << a << \" \" << b << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint w,h,c1,c2,b,d;\nchar a[51][51];\nint dfs(int i,int j){\n    if(i==h||j==w||i<0||j<0||a[i][j]=='#')return 0;\n    if(a[i][j]=='W'){d++;return 0;}\n    else if(a[i][j]=='B'){b++;return 0;}\n    int s=1;\n    a[i][j]='#';\n    s+=dfs(i+1,j);\n    s+=dfs(i-1,j);\n    s+=dfs(i,j+1);\n    s+=dfs(i,j-1);\n    return s;\n}\nint main(){\n    int i,j,ans;\n    while(cin>>w>>h,w!=0&&h!=0){\n        c1=c2=0;\n    for(i=0;i<h;i++)cin>>a[i];\n    for(i=0;i<h;i++)for(j=0;j<w;j++)if(a[i][j]=='.'){\n        d=0;b=0;\n        ans=dfs(i,j);\n        if(b>d)c1+=ans;\n        else if(b<d)c2+=ans;\n    }\n        cout<<c1<<\" \"<<c2<<endl;\n}}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint w,h,cntW,cntB;\nchar map[51][51],mapW[51][51],mapB[51][51];\n\n\nvoid visitB(int i, int j){\n  mapB[i][j] = 'B';\n  if( i+1 <= h && mapB[i+1][j] == '.' )visitB(i+1,j);\n  if( i-1 >= 0 && mapB[i-1][j] == '.')visitB(i-1,j);\n  if( j+1 <= w && mapB[i][j+1] == '.')visitB(i,j+1);\n  if( j-1 >= 0 && mapB[i][j-1] == '.')visitB(i,j-1);\n}\n\nvoid visitW(int i, int j){\n  mapW[i][j] = 'W';\n  if( i+1 <= h && mapW[i+1][j] == '.' )visitW(i+1,j);\n  if( i-1 >= 0 && mapW[i-1][j] == '.')visitW(i-1,j);\n  if( j+1 <= w && mapW[i][j+1] == '.')visitW(i,j+1);\n  if( j-1 >= 0 && mapW[i][j-1] == '.')visitW(i,j-1);\n}\n\n\n\nint main(){\n  while(1){\n    int i,j;\n    cin >> w >> h;\n    if ( w == 0 && h == 0 ) break;\n    cntB = 0,cntW = 0;\n    for( i = 1; i <= h; i++ ){\n      for ( j = 1; j <=w; j++ ){\n\tcin >> map[i][j];\n\tmapW[i][j] = map[i][j];\n\tmapB[i][j] = map[i][j];\n      }\n    }\n\n      \n    for( i = 1; i <= h; i++ ){\n      for( j = 1; j <= w; j++ ){\n\tif( mapB[i][j] == 'B' ){\n\t  visitB(i,j);\n\t}\n      }\n    }\n    \n    for( i = 1; i <= h; i++ ){\n      for( j = 1; j <= w; j++ ){\n\tif( mapW[i][j] == 'W' ){\n\t  visitW(i,j);\n\t}\n      }\n    }\n        \n    for( i = 1; i <=h; i++ ){\n      for( j = 1; j <= w; j++ ){\n\tif(map[i][j] == '.' ){\n\t  if( mapB[i][j] == 'B' && mapW[i][j] == 'W' ) continue;\n\t  else if( mapB[i][j] == 'B' ) cntB++;\n\t  else if( mapW[i][j] == 'W' ) cntW++;\n\t  }\n\t}\n      }\n    \n    cout << cntB << \" \" << cntW << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS // #pragma warning(disable:4996)\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <queue>\n#include <functional>\n#include <sstream>\n#include <cmath>\n#include <set>\n#include <map>\n#include <stack>\nusing namespace std; \n\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(a);i>=(b);i--)\n#define pb push_back\n#define mp(a,b) make_pair(a,b)\n#define all(a) a.begin(),a.end()\n#define len(x) ((int)(x).size())\n#define tmax(a,b,c) max((a),max((b),(c)))\n#define tmin(a,b,c) min((a),min((b),(c)))\n#define debug(x) cerr << #x << \" is \" << x << endl;\n#define debug2(x,y) cerr << #x << \" is \" << x << \" \" << #y << \" is \" << y << endl;\n#define debugg(g,h,w) rep(i,0,h) { rep(j,0,w) cout << g[i][j] << \" \"; cout << endl;}\n#define debugv(v) for(auto&& x : v){cout << x << \" \";} cout << endl;\n\ntypedef pair<int, int> Pii;\ntypedef map<int, int> Mii;\ntypedef vector<int> Vi;\ntypedef vector<vector<int> > VVi;\ntypedef long long ll;\nconst int inf = 2e9;\nconst ll ll_inf = 1e17;\nconst int mod = 1e9 + 7;\nconst long double eps = 1e-10;\ntypedef pair<ll, ll> Pll; \n\nint w, h;\nchar g[51][51];\nint dy[4] = {-1,0,1,0}; //nesw\nint dx[4] = {0,1,0,-1};\n\nvoid dfs(int y, int x, char c) \n{\n\trep(i,0,4) {\n\t\tint ny = y + dy[i];\n\t\tint nx = x + dx[i];\n\t\tif (ny < 0 || nx < 0 || ny >= h || nx >= w) continue;\n\t\tif (c == 'W' && g[ny][nx] == '.') {\n\t\t\tg[ny][nx] = 'a';\n\t\t\tdfs(ny,nx,c);\n\t\t}\n\t\telse if (c == 'W' && g[ny][nx] == 'b') {\n\t\t\tg[ny][nx] = 'c';\n\t\t\tdfs(ny,nx,c);\n\t\t}\n\t\telse if (c == 'B' && g[ny][nx] == '.') {\n\t\t\tg[ny][nx] = 'b';\n\t\t\tdfs(ny,nx,c);\n\t\t}\n\t\telse if (c == 'B' && g[ny][nx] == 'a') {\n\t\t\tg[ny][nx] = 'c';\n\t\t\tdfs(ny,nx,c);\n\t\t}\n\t}\n}\n\nint main()\n{\n\twhile (cin >> w >> h && w && h) {\n\t\tmemset(g,0,sizeof(g));\n\t\trep(i,0,h) rep(j,0,w) cin >> g[i][j];\n\t\trep(i,0,h) rep(j,0,w) {\n\t\t\tif (g[i][j] == 'W') dfs(i,j,'W');\n\t\t\tif (g[i][j] == 'B') dfs(i,j,'B');\n\t\t}\n\t\t//debugg(g,h,w);\n\t\tint bcnt = 0, wcnt = 0;\n\t\trep(i,0,h) rep(j,0,w) {\n\t\t\tif (g[i][j] == 'a') wcnt++;\n\t\t\tif (g[i][j] == 'b') bcnt++;\n\t\t}\n\t\tcout << bcnt << \" \" << wcnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\n#define stlice(from, to) substr(from, (to) - (from) + 1)\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\nusing namespace std;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\nusing vd = vector<double>;\nusing vc = vector<char>;\nusing vb = vector<bool>;\nusing vs = vector<string>;\nusing vpii = vector<pii>;\nusing vvi = vector<vi>;\nusing vvb = vector<vb>;\nusing vvpii = vector<vpii>;\ntemplate<typename A> using fn = function<A>;\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = acos(-1);\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nconstexpr bool odd(const int &n) { return n & 1; }\nconstexpr bool even(const int &n) { return !odd(n); }\nvoid solve();\nmain { solve(); return 0; }\n// clang-format on\n\nvoid solve() {\n  int W, H;\n  while (cin >> W >> H, W) {\n    vs v(H);\n    rep(i, H) cin >> v[i];\n    vvi dp(H, vi(W));\n    int b = 0, w = 0;\n    rep(i, H) rep(j, W) {\n      dp[i][j] = 2 * (v[i][j] == 'B') + (v[i][j] == 'W');\n      b -= v[i][j] == 'B';\n      w -= v[i][j] == 'W';\n    }\n    rep(_, W * H) rep(i, H) rep(j, W) {\n      if (v[i][j] != '.') continue;\n      if (i > 0) dp[i][j] |= dp[i - 1][j];\n      if (j > 0) dp[i][j] |= dp[i][j - 1];\n      if (i < H - 1) dp[i][j] |= dp[i + 1][j];\n      if (j < W - 1) dp[i][j] |= dp[i][j + 1];\n    }\n    rep(i, H) rep(j, W) {\n      b += dp[i][j] == 2;\n      w += dp[i][j] == 1;\n    }\n    cout << b << ' ' << w << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream> // cout, endl, cin\n#include <string> // string, to_string, stoi\n#include <vector> // vector\n#include <algorithm> // min, max, swap, sort, reverse, lower_bound, upper_bound\n#include <utility> // pair, make_pair\n#include <tuple> // tuple, make_tuple\n#include <cstdint> // int64_t, int*_t\n#include <cstdio> // printf\n#include <map> // map\n#include <queue> // queue, priority_queue\n#include <set> // set\n#include <stack> // stack\n#include <deque> // deque\n#include <unordered_map> // unordered_map\n#include <unordered_set> // unordered_set\n#include <bitset> // bitset\n#include <cctype> // isupper, islower, isdigit, toupper, tolower\n#include <iomanip> // setprecision\n#include <complex> // complex\n#include <functional>\n#include <math.h> \n#define enld '\\n'\nusing namespace std;\nusing ll = long long;\nusing P = pair<int,int>;\nconstexpr ll INF = 1e18;\nconstexpr int inf = 1e9;\nconstexpr ll mod = 1000000007;\nconstexpr ll mod2 = 998244353;\nconst int dx[8] = {1, 0, -1, 0,1,1,-1,-1};\nconst int dy[8] = {0, 1, 0, -1,1,-1,1,-1};\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n// ---------------------------------------------------------------------------\n\nint H,W;\nvector<vector<bool>> used;\nvector<string> G;\nint cnt = 0;\nbool ok = true;\n\nbool solve(){\n  cin >> W >> H;\n  if(H==0 && W==0) return false;\n  G = vector<string>(H);\n  used = vector<vector<bool>>(H,vector<bool>(W,false));\n  for(int i=0; i<H; i++){\n    cin >> G[i];\n  }\n  function<void(int,int,char)> dfs = [&dfs](int h,int w,char c) -> int{\n    used[h][w] = true;\n    cnt++;\n    for(int k=0; k<4; k++){\n      int ny = h + dy[k];\n      int nx = w + dx[k];\n      if(ny<0 || ny>=H || nx<0 || nx>=W) continue;\n      if(used[ny][nx]) continue;\n      if(G[ny][nx] == c) continue;\n      if(G[ny][nx]!=c && G[ny][nx]!='.'){\n        ok = false;\n        continue;\n      }\n      dfs(ny,nx,c);\n    }\n  };\n  map<char,int> mp;\n  for(int i=0; i<H; i++){\n    for(int j=0; j<W; j++){\n      if(G[i][j] != '.'){\n        for(int k=0; k<4; k++){\n          int ny = i + dy[k];\n          int nx = j + dx[k];\n          if(ny<0 || ny>=H || nx<0 || nx>=W) continue;\n          if(used[ny][nx]) continue;\n          if(G[ny][nx] != '.') continue;\n          ok = true;\n          cnt = 0;\n          dfs(ny,nx,G[i][j]);\n          if(ok){\n            mp[G[i][j]] += cnt;\n          }\n        }\n      }\n    }\n  }\n  cout << mp['B'] << \" \" << mp['W'] << \"\\n\";\n  return true;\n}\n\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(nullptr);\n  while(solve());\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) container.begin(), container.end()\n#define RALL(container) container.rbegin(), container.rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n\nint w, h;\nstring m[60];\nint vis[60][60];\n\nint d[4][2]={{0, 1},{1,0},{-1,0},{0, -1}};\n\npii dfs(int x, int y){\n\tif(x<0||y<0||w<=x||h<=y) return pii(0, 0);\n\tif(m[y][x] == 'B') return pii(2, 0);\n\tif(m[y][x] == 'W') return pii(1, 0);\n\tif(vis[y][x]) return pii(0, 0);\n\tvis[y][x] = 1;\n\tpii ret(0, 1);\n\tREP(i, 4){\n\t\tpii res = dfs(x+d[i][0], y+d[i][1]);\n\t\tret.first |= res.first;\n\t\tret.second += res.second;\n\t}\n\treturn ret;\n}\n\nmain(){\n\twhile(cin >> w >> h, w){\n\t\tmemset(vis, 0, sizeof(vis));\n\t\tREP(i, h) cin >> m[i];\n\t\tint b=0,s=0;\n\t\tREP(i, h)REP(j, w){\n\t\t\tif(!vis[i][j]){\n\t\t\t\tpii ret=dfs(j, i);\n\t\t\t\tif(ret.first == 1) s += ret.second;\n\t\t\t\tif(ret.first == 2) b += ret.second;\n\t\t\t}\n\t\t}\n\t\tcout << b << \" \" << s << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<vector>\nint W,H;\nint nb,nw;\nint n,flag=1,flag2;\nchar field[50][50];\n#define Black true\n#define White false\n\nint umerub(int y,int x){\n\tn++;\n\tfield[x][y]=',';\n\tif(x!=0&&field[x-1][y]=='.')umerub(y,x-1);\n\tif(y!=0&&field[x][y-1]=='.')umerub(y-1,x);\n\tif(x!=H-1&&field[x+1][y]=='.')umerub(y,x+1);\n\tif(y!=W-1&&field[x][y+1]=='.')umerub(y+1,x);\n\tif(x!=0&&field[x-1][y]=='W')flag=0;\n\tif(y!=0&&field[x][y-1]=='W')flag=0;\n\tif(x!=H-1&&field[x+1][y]=='W')flag=0;\n\tif(y!=W-1&&field[x][y+1]=='W')flag=0;\n\tif(x!=0&&field[x-1][y]=='B')flag2=1;\n\tif(y!=0&&field[x][y-1]=='B')flag2=1;\n\tif(x!=H-1&&field[x+1][y]=='B')flag2=1;\n\tif(y!=W-1&&field[x][y+1]=='B')flag2=1;\n\treturn n;\n}\n\nint umeruw(int y,int x){\n\tn++;\n\tfield[x][y]='W';\n\tif(x!=0&&field[x-1][y]==',')umeruw(y,x-1);\n\tif(y!=0&&field[x][y-1]==',')umeruw(y-1,x);\n\tif(x!=H-1&&field[x+1][y]==',')umeruw(y,x+1);\n\tif(y!=W-1&&field[x][y+1]==',')umeruw(y+1,x);\n\tif(x!=0&&field[x-1][y]=='B')flag=0;\n\tif(y!=0&&field[x][y-1]=='B')flag=0;\n\tif(x!=H-1&&field[x+1][y]=='B')flag=0;\n\tif(y!=W-1&&field[x][y+1]=='B')flag=0;\n\tif(x!=0&&field[x-1][y]=='W')flag2=1;\n\tif(y!=0&&field[x][y-1]=='W')flag2=1;\n\tif(x!=H-1&&field[x+1][y]=='W')flag2=1;\n\tif(y!=W-1&&field[x][y+1]=='W')flag2=1;\n\treturn n;\n}\n\nint main(){\n\twhile(cin>>W>>H,W|H){\n\t\tnb=0;\n\t\tnw=0;\n\t\tn=0;\n\t\tflag=1;\n\t\tflag2=0;\n\t\tfor(int i=0;i<H;i++){\n\t\t\tcin>>field[i];\n\t\t}\n\tfor(int i=0;i<H;i++){\n\t\tfor(int j=0;j<W;j++){\n\t\t\tif(field[i][j]=='.'){\n\t\t\t\tnb+=umerub(j,i)*flag*flag2;\n\t\t\t\tflag=1;\n\t\t\t\tflag2=0;\n\t\t\t\tn=0;\n\t\t\t\tnw+=umeruw(j,i)*flag*flag2;\n\t\t\t\tflag=1;\n\t\t\t\tflag2=0;\n\t\t\t\tn=0;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<nb<<\" \"<<nw<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,1,0,-1};\n\nint w,h;\nchar fie[51][51];\n\nvoid dfs(int x, int y){\n    for(int i=0; i<4; i++){\n        int xx = x + dx[i];\n        int yy = y + dy[i];\n        if(0 <= xx && xx <= w && 0 <= yy && yy <= h && fie[yy][xx] == '.'){\n            fie[yy][xx] = 'w';\n            dfs(xx,yy);\n        }\n    }\n}\n\nvoid dfs2(int x, int y){\n    for(int i=0; i<4; i++){\n        int xx = x + dx[i];\n        int yy = y + dy[i];\n        if(0 <= xx && xx <= w && 0 <= yy && yy <= h && (fie[yy][xx] == '.' || fie[yy][xx] == 'w')){\n            if(fie[yy][xx] == '.'){\n                fie[yy][xx] = 'b';\n            } else if(fie[yy][xx] == 'w'){\n                fie[yy][xx] = 'x';\n            }\n            dfs2(xx,yy);\n        }\n    }\n}\n\nint main(){\n    while(cin >> w >> h , w||h){\n        for(int i=0; i<h; i++){\n            cin >> fie[i];\n        }\n\n        for(int i=0; i<h; i++){\n            for(int j=0; j<w; j++){\n                if(fie[i][j] == 'W') dfs(j,i);\n            }\n        }\n        for(int i=0; i<h; i++){\n            for(int j=0; j<w; j++){\n                if(fie[i][j] == 'B') dfs2(j,i);\n            }\n        }\n\n        int answ = 0, ansb = 0;\n        for(int i=0; i<h; i++){\n            for(int j=0; j<w; j++){\n                if(fie[i][j] == 'w') answ++;\n                if(fie[i][j] == 'b') ansb++;\n            }\n        }\n        cout << ansb << \" \" << answ << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <cstring>\nusing namespace std;\n\nint w, h;\nchar mas[50][50];\nint vb[50][50], vw[50][50];\n\nmap< char, int > c;\n\nstatic int dx[] = {1, 0, -1, 0}, dy[] = {0, 1, 0, -1};\n\nvoid rec(int y, int x, int color) {\n    if(!(0 <= x && x < w && 0 <= y && y < h)) return;\n    if(color != c[mas[y][x]] && mas[y][x] != '.') return;\n    if((!color && vb[y][x]) || (color && vw[y][x])) return;\n    if(color) vw[y][x] = 1;\n    else vb[y][x] = 1;\n\n    for(int i = 0; i < 4; i++) {\n        rec(y + dy[i], x + dx[i], color);\n    }\n}\n\nint main() {\n\n    c['B'] = 0, c['W'] = 1, c['.'] = -1;\n\n    while(cin >> w >> h, w) {\n        memset(vb, 0, sizeof(vb));\n        memset(vw, 0, sizeof(vw));\n        for(int i = 0; i < h; i++) {\n            for(int j = 0; j < w; j++) {\n                cin >> mas[i][j];\n            }\n        }\n\n        for(int i = 0; i < h; i++) {\n            for(int j = 0; j < w; j++) {\n                if(mas[i][j] == 'B' && !vb[i][j]) rec(i, j, 0);\n                if(mas[i][j] == 'W' && !vw[i][j]) rec(i, j, 1);\n            }\n        }\n\n        int sumb = 0, sumw = 0;\n        for(int i = 0; i < h; i++) {\n            for(int j = 0; j < w; j++) {\n                if(vb[i][j] ^ vw[i][j] && mas[i][j] == '.') {\n                    if(vb[i][j]) sumb++;\n                    else sumw++;\n                }\n            }\n        }\n\n        cout << sumb << \" \" << sumw << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<time.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nconst int inf=1e8;\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nint sx,sy;\nint gx,gy;\nvvi tmp;\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\nint co;\nvector<vector<char> >in;\nbool func(char d,char q,int x,int y){\n\tin[x][y]=q;\n\tco++;\n\trep(i,4){\n\t\tint nx=x+dx[i];\n\t\tint ny=y+dy[i];\n\t\tif(in[nx][ny]=='.'){\n\t\t\tif(!func(d,q,nx,ny))return false;\n\t\t}else if(in[nx][ny]==d)return false;\n\t}\n\treturn true;\n}\nint main(){\n\tint n,m;\n\twhile(cin>>m>>n,m+n){\n\t\tvector<vector<char> >tmp(n+2,vector<char>(m+2));\n\t\trep(i,n+2)rep(j,m+2){\n\t\t\tif(!i||!j||i==n+1||j==m+1)tmp[i][j]='!';\n\t\t\telse cin>>tmp[i][j];\n\t\t}\n\t\t//cout<<n<<\" \"<<m<<endl;\n\t\tin=tmp;\n\t\tint b=0,w=0;\n\t\trep(i,n+2)rep(j,m+2){\n\t\t\tbool h=false;\n\t\t\tif(in[i][j]=='.'){\n\t\t\t\trep(k,4){\n\t\t\t\t\tint nx=i+dx[k];\n\t\t\t\t\tint ny=j+dy[k];\n\t\t\t\t\tif(in[nx][ny]!='W'&&in[nx][ny]!='B')continue;\n\t\t\t\t\tco=0;\n\t\t\t\t\tif(in[nx][ny]=='W'){\n\t\t\t\t\t\tif(func('B','W',i,j))w+=co;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(func('W','B',i,j))b+=co;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<b<<\" \"<<w<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<utility>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<map>\n#include<complex>\n#define INF 2147483647\n#define llINF 9223372036854775807\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\n\nusing namespace std;\nint main(){\n  int h,w;\n  while(cin>>w>>h,w){\n    string Map[h];\n    for(int i=0;i<h;i++)\n      cin>>Map[i];\n    bool used[h][w]={};\n    int vx[4]={0,1,0,-1};\n    int vy[4]={1,0,-1,0};\n    int black=0,white=0;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tif(Map[i][j]=='.'){\n\t  int cnt=0;\n\t  if(!used[i][j]){\n\t    used[i][j]=true;\n\t    queue<pair<int,int> >que;\n\t    que.push(mp(i,j));\n\t    cnt++;\n\t    bool flag[2]={};\n\t    while(!que.empty()){\n\t      pair<int,int>now=que.front();\n\t      que.pop();\n\t      for(int k=0;k<4;k++){\n\t\tint x=now.F+vx[k],y=now.S+vy[k];\n\t\tif(x>=0&&x<h&&y>=0&&y<w&&used[x][y]==false&&Map[x][y]=='.'){\n\t\t  cnt++;\n\t\t  //cout<<x<<\" \"<<y<<endl;\n\t\t  que.push(mp(x,y));\n\t\t  used[x][y]=true;\n\t\t}else if(x>=0&&x<h&&y>=0&&y<w&&Map[x][y]=='B'){\n\t\t  flag[0]=true;\n\t\t  used[x][y]=true;\n\t\t}else if(x>=0&&x<h&&y>=0&&y<w&&Map[x][y]=='W'){\n\t\t  flag[1]=true;\n\t\t  used[x][y]=true;\n\t\t}\n\t      }\n\t    }\n\t    if(flag[0]&&flag[1]){;\n\t    }else if(flag[0]){\n\t      black+=cnt;\n\t    }else if(flag[1]){\n\t      white+=cnt;\n\t    }\n\t  }\n\t}else\n\t  used[i][j]=true;\n      }\n    }\n    cout<<black<<\" \"<<white<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n\nusing namespace std;\n\nchar d[50][60];\nbool w[50][50];\nbool b[50][50];\n\nint ww,hh;\nconst int dx[4] = {1,-1,0,0};\nconst int dy[4] = {0,0,1,-1};\n\n#define REP(i,n) for(int i = 0; i<(n); i++)\n\nvoid dfsw(int y, int x){\n  w[y][x] == true;\n  REP(i,4){\n    int xx = x + dx[i];\n    int yy = y + dy[i];\n    if(xx < 0 || yy < 0) continue;\n    if(xx >=ww || yy >=hh) continue;\n    if(d[yy][xx] != 'B' && !w[yy][xx]){\n      w[yy][xx] = true;\n      dfsw(yy,xx);\n    }\n  }\n}\nvoid dfsb(int y, int x){\n  b[y][x] == true;\n  REP(i,4){\n    int xx = x + dx[i];\n    int yy = y + dy[i];\n    if(xx < 0 || yy < 0) continue;\n    if(xx >=ww || yy >=hh) continue;\n    if(d[yy][xx] != 'W' && !b[yy][xx]){\n      b[yy][xx] = true;\n      dfsb(yy,xx);\n    }\n  }\n}\n\nint main(){\n  while(scanf(\"%d%d\",&ww,&hh),ww+hh){\n    memset(w,0,sizeof(w));\n    memset(b,0,sizeof(b));\n    REP(i,hh) scanf(\"%s\",d[i]);\n    REP(i,hh) REP(j,ww){\n      if(d[i][j] == 'W' && !w[i][j])\n\tdfsw(i,j);\n      if(d[i][j] == 'B' && !b[i][j])\n\tdfsb(i,j);\n    }\n    int a1 = 0, a2 = 0;\n    //REP(i,hh){ REP(j,ww) putchar(w[i][j]?'w':'.'); puts(\"\");}\n    //REP(i,hh){ REP(j,ww) putchar(b[i][j]?'b':'.'); puts(\"\");}\n    REP(i,hh) REP(j,ww){\n      if(d[i][j]=='.' && w[i][j] && !b[i][j]) a2++;\n      if(d[i][j]=='.' && !w[i][j] && b[i][j]) a1++;\n    }\n    printf(\"%d %d\\n\",a1,a2);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define MAX 50\n#define WHITE 1\n#define BLACK 2\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nchar a[MAX][MAX];\nint judge[MAX][MAX];\nbool visitedw[MAX][MAX];\nbool visitedb[MAX][MAX];\nbool searchedw[MAX][MAX];\nbool searchedb[MAX][MAX];\nP white[MAX * MAX];\nP black[MAX * MAX];\nint countw;\nint countb;\n\nint p[4] = {1, 0, -1, 0}, q[4] = {0, 1, 0, -1};\n\nvoid print_number(int w, int h) {\n  int sumb = 0, sumw = 0;\n  for (int i = 0; i < h; i++) {\n    for (int j = 0; j < w; j++) {\n      if (judge[i][j] == BLACK) sumb++;\n      else if (judge[i][j] == WHITE) sumw++;\n    }\n  }\n\n  cout << sumb << ' ' << sumw << endl;\n}\n\nvoid dfs_b(int w, int h, int x, int y) {\n  for (int i = 0; i < 4; i++) {\n    int s = x + p[i], t = y + q[i];\n    if (0 <= s && s <= w && 0 <= t && t <= h && a[t][s] == '.'\n\t&& !searchedb[t][s]) {\n      judge[t][s] += BLACK;\n      searchedb[t][s] = true;\n      dfs_b(w, h, s, t);\n    }\n  }\n}\n\nvoid dfs_w(int w, int h, int x, int y) {\n  for (int i = 0; i < 4; i++) {\n    int s = x + p[i], t = y + q[i];\n    if (0 <= s && s <= w && 0 <= t && t <= h && a[t][s] == '.'\n\t&& !searchedw[t][s]) {\n      judge[t][s] += WHITE;\n      searchedw[t][s] = true;\n      dfs_w(w, h, s, t);\n    }\n  }\n}\n\nvoid count_black(int w, int h) {\n  for (int i = 0; i < h; i++) {\n    for (int j = 0; j < w; j++) {\n      if (a[i][j] == 'B') {\n\tblack[countb].first = j;\n\tblack[countb].second = i;\n\tcountb++;\n      }\n    }\n  }\n}\n\nvoid count_white(int w, int h) {\n  for (int i = 0; i < h; i++) {\n    for (int j = 0; j < w; j++) {\n      if (a[i][j] == 'W') {\n\twhite[countw].first = j;\n\twhite[countw].second = i;\n\tcountw++;\n      }\n    }\n  }\n}\n\nvoid clear_array() {\n  for (int i = 0; i < MAX; i++) {\n    for (int j = 0; j < MAX; j++) {\n      judge[i][j] = 0;\n      visitedw[i][j] = visitedb[i][j]  = false;\n      searchedw[i][j] = searchedb[i][j] = false;\n    }\n  }\n}\n\nint main() {\n  while (true) {\n    int w, h;\n    cin >> w >> h;\n    if (w == 0 && h == 0) return 0;\n\n    for (int i = 0; i < h; i++)\n      for (int j = 0; j < w; j++)\n\tcin >> a[i][j];\n\n    clear_array();\n\n    countw = countb = 0;\n    count_white(w, h);\n    count_black(w, h);\n\n    for (int i = 0; i < countw; i++) {\n      dfs_w(w, h, white[i].first, white[i].second);\n    }\n    for (int i = 0; i < countb; i++) {\n      dfs_b(w, h, black[i].first, black[i].second);\n    }\n\n    print_number(w, h);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n\nbool visited[51][51][1<<2];\n\nvoid dfs(char stage[51][51],int occupy[51][51],int sx,int sy,int w,int h){\n  if(visited[sx][sy][occupy[sy][sx]]) return;\n\n  visited[sx][sy][occupy[sy][sx]] = true;\n  for(int i=0;i<4;i++){\n    int dx = tx[i] + sx;\n    int dy = ty[i] + sy;\n    if(dx < 0 || dx >= w || dy < 0 || dy >= h) continue;\n    if(stage[dy][dx] == 'B' || stage[dy][dx] == 'W') continue;\n    \n       occupy[dy][dx] |= occupy[sy][sx];\n       dfs(stage,occupy,dx,dy,w,h);\n  }\n}\n\n\n\nint main(){\n  int w,h;\n  while(~scanf(\"%d %d\",&w,&h)){\n    if(w==0 && h==0) break;\n    char stage[51][51];\n    int occupy[51][51];\n    memset(stage,'\\0',sizeof(stage));\n    memset(occupy,0,sizeof(occupy));\n    memset(visited,0,sizeof(visited));\n    for(int y=0;y<h;y++){\n      char buf[51];\n      scanf(\"%s\",buf);\n      for(int x=0;x<w;x++){\n\tstage[y][x] = buf[x];\n\tif(buf[x] == 'B') occupy[y][x] = 1;\n\tif(buf[x] == 'W') occupy[y][x] = (1<<1);\n      }\n    }\n    for(int y=0;y<h;y++){\n      for(int x=0;x<w;x++){\n\tif(stage[y][x] == '.') continue;\n\tdfs(stage,occupy,x,y,w,h);\n      }\n    }\n\n    int B_num = 0;\n    int W_num = 0;\n    for(int y=0;y<h;y++){\n      for(int x=0;x<w;x++){\n\tif(occupy[y][x] != (1<<2) - 1){\n\t  if((occupy[y][x] & 1) && stage[y][x] != 'B') B_num++;\n\t  if((occupy[y][x] & (1<<1)) && stage[y][x] != 'W') W_num++;\n\t}\n      }\n    }\n\n    printf(\"%d %d\\n\",B_num,W_num);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n\n\nvoid insert_stack(std::vector<std::vector<char> > &map, std::stack<std::pair<int, int> > &st, char self_color, char other_color, int &count, bool &check_surrounded, bool &check_only_wall) {\n    int dx[] = {0, 0, 1, -1};\n    int dy[] = {1, -1, 0, 0};\n    int first;\n    int second;\n\n    first = st.top().first;\n    second = st.top().second;\n    st.pop();\n    ++count;\n\n    for (int k = 0; k < 4; k++) {\n        if (map[first + dx[k]][second + dy[k]] == '.') {\n            st.push(std::make_pair(first + dx[k], second + dy[k])); \n            map[first + dx[k]][second + dy[k]] = '$';\n        } else if (map[first + dx[k]][second + dy[k]] == other_color) {\n            check_surrounded = false; \n        } else if (map[first + dx[k]][second + dy[k]] == self_color) {\n            check_only_wall = true;\n        }\n    }\n    return;\n}\n\nvoid dfs(std::vector<std::vector<char> > &map, int i, int j, char self_color, char other_color, int &total) {\n    int count = 0;\n    bool check_surrounded = true;\n    bool check_only_wall = false;\n\n    std::stack<std::pair<int, int> > st;\n    st.push(std::make_pair(i, j));\n    map[i][j] = '$';\n\n    while (1) {\n        if (st.empty() == 1) {\n            break; \n        }\n        insert_stack(map, st, self_color, other_color, count, check_surrounded, check_only_wall);\n    }\n\n    if (check_surrounded == true && check_only_wall == true) {\n        total += count;\n    } else {\n        check_surrounded = true;\n        check_only_wall = false;\n    }\n    return;\n}\n\nint whole_search(std::vector<std::vector<char> > map, int w, int h, char self_color, char other_color) {\n    int total = 0;\n\n    for (int i = 1; i <= h; i++) {\n        for (int j = 1; j <= w; j++) {\n            if (map[i][j] == '.') {\n                dfs(map, i, j, self_color, other_color, total);\n            }\n        }\n    }\n    return total; \n}\n\nint main(void) {\n    int w;\n    int h;\n\n    while (1) {\n        std::cin >> w >> h;\n        if (w == 0 && h == 0) {\n            break;\n        }\n\n        std::vector<std::vector<char> > map_b(h+2, std::vector<char>(w+2, '#'));\n        std::vector<std::vector<char> > map_w(h+2, std::vector<char>(w+2, '#'));\n\n        for (int i = 1; i <= h; i++) {\n            for (int j = 1; j <= w; j++) {\n                std::cin >> map_b[i][j];\n                map_w[i][j] = map_b[i][j];\n            }\n        }\n        std::cout << whole_search(map_b, w, h, 'B', 'W') << \" \" << whole_search(map_w, w, h, 'W', 'B') << std::endl;\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nvoid search(char a[51][51], int c[51][51], int h, int w, int s, int t, int v, char p)\n{\n  if(a[s][t] == p || a[s][t] != '.' || c[s][t] < 0 || c[s][t] == v){\n    return ;\n  }\n  c[s][t] = (c[s][t] > 0)? -3 : v;\n\n  if(s > 0){\n    search(a, c, h, w, s-1, t, v, p);\n  }\n  if(s < h-1){\n    search(a, c, h, w, s+1, t, v, p);\n  }\n  if(t > 0){\n    search(a, c, h, w, s, t-1, v, p);\n  }\n  if(t < w-1){\n    search(a, c, h, w, s, t+1, v, p);\n  }\n\n  return ;\n}\n\nvoid func(char a[51][51], int c[51][51], int h, int w, char p, int s, int t)\n{\n  int v = (p == 'W')? 1 : 2;\n\n  if(s > 0){\n    search(a, c, h, w, s-1, t, v, p);\n  }\n  if(s < h-1){\n    search(a, c, h, w, s+1, t, v, p);\n  }\n  if(t > 0){\n    search(a, c, h, w, s, t-1, v, p);\n  }\n  if(t < w-1){\n    search(a, c, h, w, s, t+1, v, p);\n  }\n\n  return ;\n}\n\nint main(int argc, char **argv)\n{\n  int w, h, c[51][51], cw, cb;\n  char a[51][51];\n\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0){\n      break;\n    }\n    fill(&c[0][0], &c[h][w], 0);\n\n    for(int i = 0; i < h; i++){\n      scanf(\"%s\", a[i]);\n    }\n\n    cw = cb = 0;\n    for(int i = 0; i < h; i++){\n      for(int j = 0; j < w; j++){\n\tif(c[i][j] == 0 && a[i][j] != '.'){\n\t  func(a, c, h, w, a[i][j], i, j);\n\t}\n      }\n    }\n    for(int i = 0; i < h; i++){\n      for(int j = 0; j < w; j++){\n\tif(c[i][j] == 1){\n\t  cw++;\n\t} else if(c[i][j] == 2){\n\t  cb++;\n\t}\n      }\n    }\n\n    cout << cb << \" \" << cw << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>=0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<int, P> PIP;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\ntypedef set<int> S;\n\n#define INF INT_MAX/3\n#define MAX_N 1000000001\n\nint w, h;\nvector<string> island(51);\nP land[51][51];\nint dd[] = {1, 0, -1, 0, 1};\n\nbool range(int y, int x) {\n  return 0 <= y && y < h && 0 <= x && x < w;\n}\n\nvoid dfs(int y, int x, bool b) {\n  if(b) land[y][x].fi = 1;\n  else land[y][x].se = 1;\n\n  int yy, xx;\n  rep(i, 4) {\n    yy = y + dd[i], xx = x + dd[i + 1];\n    if (range(yy, xx)) {\n      if (b) {\n        if (island[yy][xx] == '.' && land[yy][xx].fi == 0) dfs(yy, xx, b);\n      } else {\n        if (island[yy][xx] == '.' && land[yy][xx].se == 0) dfs(yy, xx, b);\n      }\n    }\n  }\n}\n\nint main(){\n  cin.sync_with_stdio(false);\n  while(cin >> w >> h, w | h) {\n    rep(i, h) cin >> island[i];\n    rep(i, h)rep(j, w) land[i][j] = P(0, 0);\n    rep(i, h)rep(j, w) {\n      if (island[i][j] != '.') land[i][j] = P(1, 1), dfs(i, j, island[i][j] == 'B');\n    }\n\n    int black = 0, white = 0;\n    rep(i, h)rep(j, w) {\n      if (land[i][j].fi == 1 && land[i][j].se == 0) black++;\n      if (land[i][j].fi == 0 && land[i][j].se == 1) white++;\n    }\n\n    cout << black << \" \" << white << endl;\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\n\n#define INF INT_MAX/3\n\n#define MAX_N 1000\n\nint w,h;\nstring s[55];\nbool vis[55][55];\nint cnt;\nint flag;\nint d[5]={-1,0,1,0,-1};\n\nvoid dfs(int i,int j){\n\tvis[i][j]=true;\n\tcnt++;\n\trep(dd,5){\n\t\tint ni=i+d[dd],nj=j+d[dd+1];\n\t\tif(ni<0||ni>=h||nj<0||nj>=w)continue;\n\t\tif(s[ni][nj]=='B'){\n\t\t\tflag|=1;\n\t\t}else if(s[ni][nj]=='W'){\n\t\t\tflag|=2;\n\t\t}else if(!vis[ni][nj]&&s[ni][nj]=='.'){\n\t\t\tdfs(ni,nj);\n\t\t}\n\t}\n}\n\nint main(){\n\tcin.sync_with_stdio(false);\n\twhile(1){\n\t\tcin>>w>>h;\n\t\tif(h==0)break;\n\t\trep(i,h){\n\t\t\tcin>>s[i];\n\t\t}\n\t\tmemset(vis,0,sizeof(vis));\n\t\tint res[4];\n\t\tmemset(res,0,sizeof(res));\n\t\trep(i,h)rep(j,w){\n\t\t\tif(vis[i][j]||s[i][j]!='.')continue;\n\t\t\tcnt=flag=0;\n\t\t\tdfs(i,j);\n\t\t\tres[flag]+=cnt;\n\t\t}\n\t\tcout<<res[1]<<\" \"<<res[2]<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\n#define stlice(from, to) substr(from, (to) - (from) + 1)\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\nusing namespace std;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\nusing vd = vector<double>;\nusing vc = vector<char>;\nusing vb = vector<bool>;\nusing vs = vector<string>;\nusing vpii = vector<pii>;\nusing vvi = vector<vi>;\nusing vvb = vector<vb>;\nusing vvpii = vector<vpii>;\ntemplate<typename A> using fn = function<A>;\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = acos(-1);\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nconstexpr bool odd(const int &n) { return n & 1; }\nconstexpr bool even(const int &n) { return !odd(n); }\nvoid solve();\nmain { solve(); return 0; }\n// clang-format on\n\nvoid solve() {\n  int W, H;\n  while (cin >> W >> H, W) {\n    vs v(H);\n    rep(i, H) cin >> v[i];\n    vvi dp(H, vi(W));\n    int b = 0, w = 0;\n    rep(i, H) rep(j, W) {\n      dp[i][j] = 2 * (v[i][j] == 'B') + (v[i][j] == 'W');\n      b -= v[i][j] == 'B';\n      w -= v[i][j] == 'W';\n    }\n    rep(_, W * H) rep(i, H) rep(j, W) {\n      if (v[i][j] != '.') continue;\n      if (i > 0) dp[i][j] |= dp[i - 1][j];\n      if (j > 0) dp[i][j] |= dp[i][j - 1];\n      if (i < H - 1) dp[i][j] |= dp[i + 1][j];\n      if (j < W - 1) dp[i][j] |= dp[i][j + 1];\n    }\n    rep(i, H) rep(j, W) {\n      b += dp[i][j] == 2;\n      w += dp[i][j] == 1;\n    }\n    cout << b << ' ' << w << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n#include <stdio.h>\n#include <iostream>\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define MAX_H 100\n#define MAX_W 100\nusing namespace std;\nconst int INF = 100000000;\n\ntypedef pair<int, int> P;\n\nint H, W;\nchar maze[MAX_H][MAX_W + 1];\nbool check[MAX_H][MAX_W];\n\n//4\nint dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\n\n\nint main(){\n  while (true){\n    cin >> W >> H;\n    if(W == 0 && H == 0)\n      break;\n    int b = 0;\n    int w = 0;\n    rep(i,H)\n      cin >> maze[i];\n    rep(i,H){\n      rep(j,W){\n        if(maze[i][j] == '.'){\n          int flagb = 0;\n          int flagw = 0;\n        rep(i,H){\n          rep(j,W){\n            check[i][j] = false;\n          }\n        }\n        queue<P> que;\n        que.push(P(j,i));\n        while(que.size()){\n          P p = que.front();que.pop();\n          int x = p.first;\n          int y = p.second;\n\n          rep(k,4){\n                int nx = p.first + dx[k], ny = p.second + dy[k];\n                if(0 <= nx && nx < W && 0<= ny && ny < H && maze[ny][nx] == 'B'){\n                  flagb = 1;\n                }\n                if(0 <= nx && nx < W && 0<= ny && ny < H && maze[ny][nx] == 'W'){\n                  flagw = 1;\n                }\n                if(0 <= nx && nx < W && 0<= ny && ny < H && maze[ny][nx] == '.' && check[ny][nx] == false){\n                  if(flagb*flagw == 0){\n                    que.push(P(nx,ny));\n                    check[ny][nx] = true;\n                  }\n                  else{\n                    queue<P> que;\n                  }\n                }\n              }\n            }\n            if(flagb == 1 && flagw == 0){\n              b += 1;\n            }\n            else if(flagw == 1 && flagb == 0){\n              w += 1;\n          }\n        }\n      }\n    }\n    printf(\"%d %d\\n\",b,w);\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\ntypedef pair<int,int> P;\nint W,H;\nint visited[51][51] = {};\nchar A[51][51];\n\nint dx[4] = {-1,1,0,0},dy[4] = {0,0,-1,1};\n\nbool in(int x,int y){\n    return 1<=x && x<=H && 1<=y && y<=W;\n}\n\nvoid init(){\n    for(int i=1;i<=H;i++) for(int j=1;j<=W;j++) visited[i][j] = 0;\n}\n\nint main(){\n    while(cin >> W >> H && W>0){\n        for(int i=1;i<=H;i++) for(int j=1;j<=W;j++) cin >> A[i][j];\n        int black = 0,white = 0;\n        for(int i=1;i<=H;i++){\n            for(int j=1;j<=W;j++){\n                if(A[i][j]!='.') continue;\n                init();\n                visited[i][j] = 1;\n                queue<P> Q;\n                Q.push({i,j});\n                bool b = false,w = false;\n                while(!Q.empty()){\n                    int x = Q.front().first,y = Q.front().second;\n                    Q.pop();\n                    for(int i=0;i<4;i++){\n                        int nx = x+dx[i],ny = y+dy[i];\n                        if(!in(nx,ny)) continue;\n                        if(visited[nx][ny]==1) continue;\n                        if(A[nx][ny]=='W') w = true;\n                        if(A[nx][ny]=='B') b = true;\n                        if(A[nx][ny]=='.'){\n                            visited[nx][ny] = 1;\n                            Q.push({nx,ny});\n                        }\n                    }\n                }\n                if(b&&!w) black++;\n                if(!b&&w) white++;\n            }\n        }\n        cout << black << \" \" << white << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <limits.h>\n#include <math.h>\n#include <set>\n#include <stack>\n#include <stdlib.h>\n#include <string>\n#include <vector>\n\n#define el endl\n#define fd fixed\n#define INF INT_MAX/2-1\n#define pb push_back\n\nusing namespace std;\n\nchar map[50][50];\nbool memoB[50][50];\nbool memoW[50][50];\n\nvoid search(int x, int y, int w, int h, char color) {\n  if (color == 'B') {\n    memoB[x][y] = true;\n  } else if (color == 'W') {\n    memoW[x][y] = true;\n  }\n  if (x > 0 && map[x-1][y] == '.') {\n    if ((color == 'B' && !memoB[x-1][y]) || (color == 'W' && !memoW[x-1][y])) {\n      search(x-1, y, w, h, color);\n    }\n  }\n  if (y > 0 && map[x][y-1] == '.') {\n    if ((color == 'B' && !memoB[x][y-1]) || (color == 'W' && !memoW[x][y-1])) {\n      search(x, y-1, w, h, color);\n    }\n  }\n  if (x < w-1 && map[x+1][y] == '.') {\n    if ((color == 'B' && !memoB[x+1][y]) || (color == 'W' && !memoW[x+1][y])) {\n      search(x+1, y, w, h, color);\n    }\n  }\n  if (y < h-1 && map[x][y+1] == '.') {\n    if ((color == 'B' && !memoB[x][y+1]) || (color == 'W' && !memoW[x][y+1])) {\n      search(x, y+1, w, h, color);\n    }\n  }\n}\n\nint main() {\n  int w, h, cntB, cntW, resB, resW;\n  char tmp;\n  while (cin >> w >> h, w | h) {\n    cntB = cntW = 0;\n    for (int i = 0; i < w; i++) {\n      for (int j = 0; j < h; j++) {\n        cin >> tmp;\n        map[i][j] = tmp;\n        if (tmp == '.') memoB[i][j] = memoW[i][j] = false;\n        if (tmp == 'B') memoB[i][j] = true, memoW[i][j] = false, cntB++;\n        if (tmp == 'W') memoB[i][j] = false, memoW[i][j] = true, cntW++;\n      }\n    }\n    for (int i = 0; i < w; i++) {\n      for (int j = 0; j < h; j++) {\n        if (map[i][j] == 'B') search(i, j, w, h, 'B');\n        if (map[i][j] == 'W') search(i, j, w, h, 'W');\n      }\n    }\n    resB = resW = 0;\n    for (int i = 0; i < w; i++) {\n      for (int j = 0; j < h; j++) {\n        if (memoB[i][j] && !memoW[i][j]) resB++;\n        if (!memoB[i][j] && memoW[i][j]) resW++;\n      }\n    }\n    cout << resB-cntB << \" \" << resW-cntW << el;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nvoid aprint(int a[51][51],  int h, int w)\n{\n  for(int i = 0; i < h; i++){\n    for(int j = 0; j < w; j++){\n      if(a[i][j] == -3){\n\tcout << \" \";\n      } else if(a[i][j] == -1){\n\tcout << \"W\";\n      } else if(a[i][j] == -2){\n\tcout << \"B\";\n      } else if(a[i][j] == 1){\n\tcout << \"*\";\n      } else if(a[i][j] == 2){\n\tcout << \"+\";\n      } else {\n\tcout << \"-\";\n      }\n    }\n    cout << endl;\n  }\n  cout << endl;\n\n  return ;\n}\n\nvoid search(char a[51][51], int c[51][51], int h, int w, int s, int t, int v, char p)\n{\n  if(a[s][t] == p){\n    // c[s][t] = -v;\n    return ;\n  } else if(a[s][t] != '.' || c[s][t] < 0 || c[s][t] == v){\n    return ;\n  }\n  c[s][t] = (c[s][t] > 0)? -3 : v;\n\n  if(s > 0){\n    search(a, c, h, w, s-1, t, v, p);\n  }\n  if(s < h-1){\n    search(a, c, h, w, s+1, t, v, p);\n  }\n  if(t > 0){\n    search(a, c, h, w, s, t-1, v, p);\n  }\n  if(t < w-1){\n    search(a, c, h, w, s, t+1, v, p);\n  }\n\n  return ;\n}\n\nvoid func(char a[51][51], int c[51][51], int h, int w, char p, int s, int t)\n{\n  int v = (p == 'W')? 1 : 2;\n\n  if(s > 0){\n    search(a, c, h, w, s-1, t, v, p);\n  }\n  if(s < h-1){\n    search(a, c, h, w, s+1, t, v, p);\n  }\n  if(t > 0){\n    search(a, c, h, w, s, t-1, v, p);\n  }\n  if(t < w-1){\n    search(a, c, h, w, s, t+1, v, p);\n  }\n\n  return ;\n}\n\nint main(int argc, char **argv)\n{\n  int w, h, c[51][51], cw, cb;\n  char a[51][51];\n\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0){\n      break;\n    }\n    fill(&c[0][0], &c[h][w], 0);\n\n    for(int i = 0; i < h; i++){\n      scanf(\"%s\", a[i]);\n    }\n\n    cw = cb = 0;\n    for(int i = 0; i < h; i++){\n      for(int j = 0; j < w; j++){\n\tif(c[i][j] == 0 && a[i][j] != '.'){\n\t  func(a, c, h, w, a[i][j], i, j);\n\t}\n      }\n    }\n    // aprint(c, h, w);\n    for(int i = 0; i < h; i++){\n      for(int j = 0; j < w; j++){\n\tif(c[i][j] == 1){\n\t  cw++;\n\t} else if(c[i][j] == 2){\n\t  cb++;\n\t}\n      }\n    }\n\n    cout << cb << \" \" << cw << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <climits>\n#include <vector>\n#include <map>\n#include <set>\n#include <list>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <iostream>\n#include <string>\n\n#define REP(i,n) for(long long i=0;i<n;++i)\n#define REPR(i,n) for(long long i=n;i>=0;--i)\n#define REPI(itr,v) for(auto itr=v.begin();itr!=v.end();++itr)\n#define REPIR(itr,v) for(auto itr=v.rbegin();itr!=v.rend();++itr)\n#define FOR(i,a,b) for(long long i=a;i<b;++i)\n#define SORT(v,n) sort(v, v+n)\n#define SORTV(v) sort(v.begin(), v.end())\n#define ALL(v) v.begin(),v.end()\n#define llong long long\n#define INF 999999999\n#define SUR 1000000007\n#define pb push_back\n#define pf push_front\n#define MP make_pair\n#define SV(v) {for(long long sitr=0;sitr<v.size();++sitr){cin>>v[sitr];}}\n\nint dx[] = {0, 0, -1, 1};\nint dy[] = {1, -1, 0, 0};\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nint w, h;\nstring s[50];\nbool B[50][50] = {}, W[50][50] = {};\n\nvoid solve_b(int y, int x, bool visited[50][50]){\n  B[y][x] = true;\n  REP(i,4){\n    int ny = dy[i] + y, nx = dx[i] + x;\n    if(ny >= 0 && ny < h && nx >= 0 && nx < w){\n      if(!visited[ny][nx] && s[ny][nx] == '.'){\n        visited[ny][nx] = true;\n        solve_b(ny, nx, visited);\n      }\n    }\n  }\n  \n}\n\nvoid solve_w(int y, int x, bool visited[50][50]){\n  W[y][x] = true;\n  REP(i,4){\n    int ny = dy[i] + y, nx = dx[i] + x;\n    if(ny >= 0 && ny < h && nx >= 0 && nx < w){\n      if(!visited[ny][nx] && s[ny][nx] == '.'){\n        visited[ny][nx] = true;\n        solve_w(ny, nx, visited);\n      }\n    }\n  }\n  \n}\n\n\n\nint main(){\n\n  while(true){\n    cin >> w >> h;\n\n    if(w == 0 && h == 0) break;\n\n    REP(i,h){\n      cin >> s[i];\n    }\n\n    REP(i,50){\n      REP(j,50){\n        B[i][j] = false;\n        W[i][j] = false;\n      }\n    }\n    \n    REP(i,h){\n      REP(j,w){\n        if(s[i][j] == 'B'){\n\n          bool visited[50][50] = {};\n          visited[i][j] = true;\n          solve_b(i, j, visited);\n        }else if(s[i][j] == 'W'){\n\n          bool visited[50][50] = {};\n          visited[i][j] = true;\n          solve_w(i, j, visited);\n        }\n      }\n    }\n\n    int ans_b = 0, ans_w = 0;\n\n    \n    \n    REP(i,h){\n      REP(j,w){\n        if(s[i][j] == '.'){\n          if(B[i][j] == true && !W[i][j]) ans_b++;\n          else if(!B[i][j] && W[i][j]) ans_w++;\n        }\n      }\n    }\n\n    cout << ans_b << \" \" << ans_w << endl;\n  }\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_H = 50;\nconst int MAX_W = 50;\n\nconst int dxs[] = {1, 0, -1, 0};\nconst int dys[] = {0, 1, 0, -1};\n\n/* typedef */\n\ntypedef pair<int,int> pii;\n\nenum { NA = 0, EW = 1, EB = 2, EWB = 3, W = 7, B = 11};\n\n/* global variables */\n\nint h, w;\nint flds[MAX_H][MAX_W];\n\n/* subroutines */\n\n/* main */\n\nint main() {\n  for (;;) {\n    cin >> w >> h;\n    if (w == 0) break;\n\n    for (int y = 0; y < h; y++) {\n      string line;\n      cin >> line;\n      for (int x = 0; x < w; x++) {\n\tswitch (line[x]) {\n\tcase '.': flds[y][x] = NA; break;\n\tcase 'W': flds[y][x] = W; break;\n\tcase 'B': flds[y][x] = B; break;\n\t}\n      }\n    }\n\n    for (int y0 = 0; y0 < h; y0++)\n      for (int x0 = 0; x0 < w; x0++) {\n\tint fld = flds[y0][x0];\n\tif (fld == W || fld == B) {\n\t  int cl = (fld == W) ? EW : EB;\n\n\t  queue<pii> q;\n\t  q.push(pii(x0, y0));\n\n\t  while (! q.empty()) {\n\t    pii u = q.front();\n\t    q.pop();\n\n\t    int ux = u.first;\n\t    int uy = u.second;\n\n\t    for (int di = 0; di < 4; di++) {\n\t      int vx = ux + dxs[di];\n\t      int vy = uy + dys[di];\n\n\t      if (vx >= 0 && vx < w && vy >= 0 && vy < h &&\n\t\t  ! (flds[vy][vx] & cl)) {\n\t\tflds[vy][vx] |= cl;\n\t\tq.push(pii(vx, vy));\n\t      }\n\t    }\n\t  }\n\t}\n      }\n\n    int nb = 0, nw = 0;\n\n    for (int y = 0; y < h; y++)\n      for (int x = 0; x < w; x++) {\n\tif (flds[y][x] == EB) nb++;\n\tif (flds[y][x] == EW) nw++;\n      }\n\n    printf(\"%d %d\\n\", nb, nw);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <string>\n#include <vector>\nusing namespace std;\nint main(){\n  int w, h;\n  vector<int> v;\n  vector<int> ex, ey;\n  ex = {1,-1,0,0};\n  ey = {0,0,1,-1};\n  while (cin >> w >> h, w){\n    vector<string> M(h);\n    vector< vector<int> > F(h, vector<int>(w,9));\n    queue< vector<int> > que_W, que_B;\n    for (int i = 0; i < h; ++i){\n      cin >> M[i];\n      for (int j = 0; j < w; ++j){\n\tif (M[i][j] == 'W') que_W.push({i,j});\n\telse if (M[i][j] == 'B') que_B.push({i,j});\n\telse F[i][j] = 0;\n      }\n    }\n   \n    while(!que_W.empty()){\n      int x = que_W.front()[0], y = que_W.front()[1];\n      que_W.pop();\n      for (int i = 0; i < 4; ++i){\n\tif (0 <= x+ex[i] && x+ex[i] < h && 0 <= y+ey[i] && y+ey[i] < w && !F[x+ex[i]][y+ey[i]]){\n\t  --F[x+ex[i]][y+ey[i]];\n\t  que_W.push({x+ex[i],y+ey[i]});\n\t}\n      }\n    }\n    while(!que_B.empty()){\n      int x = que_B.front()[0], y = que_B.front()[1];\n      que_B.pop();\n      for (int i = 0; i < 4; ++i){\n\tif (0 <= x+ex[i] && x+ex[i] < h && 0 <= y+ey[i] && y+ey[i] < w && M[x+ex[i]][y+ey[i]] == '.'){\n\t  ++F[x+ex[i]][y+ey[i]];\n\t  M[x+ex[i]][y+ey[i]] = '!';\n\t  que_B.push({x+ex[i],y+ey[i]});\n\t}\n      }\n    }\n    int W = 0, B = 0;\n    for (int i = 0; i < h; ++i){\n      for (int j = 0; j < w; ++j){\n\tif (F[i][j] == 1) ++B;\n\tif (F[i][j] == -1) ++W;\n      }\n    }\n    cout << B << \" \" << W << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <map>\n#include <set>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <bitset>\nusing namespace std;\n#define INF\t100000000\n#define MOD 1000000007\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define sec second\n#define lb lower_bound\n#define ub upper_bound\n#define SS stringstream\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define SORT(x) sort((x).begin(), (x).end())\n#define clr(a,b) memset((a),(b),sizeof(a))\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef vector<int> Vi;\ntypedef vector<ll> Vll;\ntypedef vector<P> Vp;\ntypedef priority_queue<P, vector<P>, greater<P> > PQ;\n\nbool bused[50][50],wused[50][50];\nchar deta[50][50];\nint dh[4] = {1,0,-1,0}, dw[4] = {0,1,0,-1};\nint w,h;\n\nvoid W(int a, int b){\n\tqueue<P> que;\n\tque.push(P(a,b));\n\twhile(que.size() != 0){\n\t\tP p = que.front(); que.pop();\n\t\trep(i,4){\n\t\t\tint th = p.fi+dh[i], tw = p.sec+dw[i];\n\t\t\tif(0<=th&&th<h&&0<=tw&&tw<w){\n\t\t\t\tif(!wused[th][tw] && deta[th][tw] == '.'){\n\t\t\t\t\twused[th][tw] = true;\n\t\t\t\t\tque.push(P(th,tw));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid B(int a, int b){\n\tqueue<P> que;\n\tque.push(P(a,b));\n\twhile(que.size() != 0){\n\t\tP p = que.front(); que.pop();\n\t\trep(i,4){\n\t\t\tint th = p.fi+dh[i], tw = p.sec+dw[i];\n\t\t\tif(0<=th&&th<h&&0<=tw&&tw<w){\n\t\t\t\tif(!bused[th][tw] && deta[th][tw] == '.'){\n\t\t\t\t\tbused[th][tw] = true;\n\t\t\t\t\tque.push(P(th,tw));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(scanf(\"%d%d\", &w, &h),w||h){\n\t\trep(i,50) rep(j,50){\n\t\t\twused[i][j] = false;\n\t\t\tbused[i][j] = false;\n\t\t}\n\t\trep(i,h) rep(j,w) scanf(\" %c\", &deta[i][j]);\n\t\trep(i,h) rep(j,w){\n\t\t\tif(deta[i][j] == 'W') W(i,j);\n\t\t\tif(deta[i][j] == 'B') B(i,j);\n\t\t}\n\t\tint wcnt = 0, bcnt = 0;\n\t\trep(i,h) rep(j,w){\n\t\t\tif(bused[i][j] == true && wused[i][j] == false) bcnt++;\n\t\t\tif(bused[i][j] == false && wused[i][j] == true) wcnt++;\n\t\t}\n\t\tprintf(\"%d %d\\n\", bcnt, wcnt);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvoid spread(int y, int x, vector<vector<bool> >& resField, vector<pair<int, int> > enposes);\n\nint main() {\n  int w, h;\n  while(cin >> w >> h, w || h) {\n    vector<vector<bool> > wfield(h, vector<bool>(w, false));\n    vector<vector<bool> > bfield(h, vector<bool>(w, false));\n    vector<vector<char> > qfield(h, vector<char>(w));\n    vector<pair<int, int> > wposes;\n    vector<pair<int, int> > bposes;\n    for(int y = 0; y < h; ++y) for(int x = 0; x < w; ++x) {\n      char c;\n      cin >> c;\n      qfield[y][x] = c;\n      if(c == 'W') wposes.push_back(make_pair(y, x));\n      if(c == 'B') bposes.push_back(make_pair(y, x));\n    }\n    for(auto&& wpos : wposes) spread(wpos.first, wpos.second, wfield, bposes);\n    for(auto&& bpos : bposes) spread(bpos.first, bpos.second, bfield, wposes);\n    // for(auto&& cols : wfield) {\n    //   for(auto&& bs : cols) cout << bs;\n    //   cout << endl;\n    // }\n    // cout << endl;\n    // for(auto&& cols : bfield) {\n    //   for(auto&& bs : cols) cout << bs;\n    //   cout << endl;\n    // }\n    int answ, ansb;\n    answ = ansb = 0;\n    for(int y = 0; y < h; ++y) for(int x = 0; x < w; ++x) {\n      if(wfield[y][x] xor bfield[y][x] && qfield[y][x] == '.') {\n        answ += wfield[y][x];\n        ansb += bfield[y][x];\n      }\n    }\n    cout << ansb << ' ' << answ << endl;\n  }\n  return 0;\n}\n\nvoid spread(int y, int x, vector<vector<bool> >& resField, vector<pair<int, int> > enposes) {\n  int dy[] = {-1, 0, 1, 0};\n  int dx[] = {0, -1, 0, 1};\n  int h = resField.size();\n  int w = resField[0].size();\n  if(y >= 0 && y < h && x >= 0 && x < w && !resField[y][x] && count(begin(enposes), end(enposes), make_pair(y, x)) == 0) {\n    resField[y][x] = true;\n    for(int i = 0; i < 4; ++i) spread(y + dy[i], x + dx[i], resField, enposes);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long int;\nusing P = pair<ll, ll>;\nusing P3 = pair<ll,P>;\nusing PP = pair<P, P>;\nconstexpr ll INF = 1LL << 60;\nconstexpr ll MOD = ll(1e9) + 7;\nconstexpr int di[] = {0, 1, 0, -1};\nconstexpr int dj[] = {1, 0, -1, 0};\nconstexpr double EPS = 1e-8;\n\nbool solve(){\n    int w, h;\n    cin >> w >> h;\n    if(w == 0) return true;\n    vector<string> s(h);\n    for(int i=0;i<h;i++){\n        cin >> s[i];\n    }\n    vector<vector<int> > c(h, vector<int>(w,0));\n    vector<vector<bool> > visited(h, vector<bool>(w));\n    for(int t=0;t<2;t++){\n        for(auto& v : visited) fill(v.begin(), v.end(), false);\n        queue<P> que;\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                if(s[i][j] == (t%2 ? 'W' : 'B')) que.push(P(i,j));\n            }\n        }\n        while(!que.empty()){\n            auto p = que.front();\n            que.pop();\n            int i = p.first, j = p.second;\n            for(int k=0;k<4;k++){\n                int ni = i+di[k], nj = j+dj[k];\n                if(ni < 0 || ni >= h) continue;\n                if(nj < 0 || nj >= w) continue;\n                if(visited[ni][nj] || s[ni][nj] != '.') continue;\n                visited[ni][nj] = true;\n                que.push(P(ni,nj));\n                c[ni][nj] += (t%2 ? -1:1);\n            }\n        }\n    }\n    int cnt[2]{};\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            if(c[i][j] > 0) cnt[0]++;\n            if(c[i][j] < 0) cnt[1]++;\n        }\n    }\n    cout << cnt[0] << \" \" << cnt[1] << endl;\n    return false;\n}\n\nint main(){\n    while(!solve());\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n \nusing namespace std;\n \n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define rep(i,n) REP(i, 0, n)\n#define pb push_back\n#define mp make_pair\n#define all(r) (r).begin(),(r).end()\n#define rall(r) (r).rbegin(),(r).rend()\n#define fi first\n#define se second\n \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\n\nconst int INF = 1e9;\nconst double EPS = 1e-8;\nconst int mod = 1e9 + 7;\nconst ll LINF = 1e18;\nconst double PI = acos(-1);\n\nstruct Input\n{\n\tint n;char c;char str[1024];string s;ll l;\n\tint nextInt(){scanf(\"%d\", &n);return n;}\n\tll nextLong(){scanf(\"%lld\", &l);return l;}\n\tchar nextChar(){scanf(\"%c\", &c);return c;}\n\tstring next(){scanf(\"%s\", str);return string(str);}\n\tstring nextLine(){getline(cin, s);return s;}\n};\nInput in;\n\nint dx[] = {-1, 1, 0, 0};\nint dy[] = {0, 0, -1, 1};\n\nint h, w;\nstring s[60];\nint d[100][100];\n\nbool isOutOfRange(int x, int y){\n\tif(x < 0 || x >= w | y < 0 || y >= h) return true;\n\treturn false;\n}\n\nvoid calc(int y, int x, bool f){\n\tif(d[y][x] == 3) return ;\n\tif(d[y][x] == 1 && !f) return ;\n\tif(d[y][x] == 2 && f) return;\n\t\n\tif(d[y][x] == 0) d[y][x] = f ? 2 : 1;\n\telse d[y][x] = 3;\n\trep(i, 4){\n\t\tint ny = y + dy[i], nx = x + dx[i];\n\t\tif(isOutOfRange(nx, ny)) continue;\n\t\tcalc(ny, nx, f);\n\t} \n}\n\nint main(){\n\twhile(1){\n\t\tw = in.nextInt(); h = in.nextInt();\n\t\tif(h == 0 && w == 0) break;\n\t\trep(i, h) s[i] = in.next();\n\t\t\n\t\trep(i, h) rep(j, w) d[i][j] = s[i][j] == '.' ? 0 : 3;\n\t\trep(i, h) rep(j, w) if(s[i][j] != '.') {\n\t\t\trep(k, 4){\n\t\t\t\tint ni = i + dy[k], nj = j + dx[k];\n\t\t\t\tif(isOutOfRange(nj, ni)) continue;\n\t\t\t\tcalc(ni, nj, s[i][j] == 'W');\n\t\t\t}\n\t\t}\n\t\tint ans[2] = {};\n\t\trep(i, h) rep(j, w) {\n\t\t\tif(d[i][j] == 1) ans[0]++;\n\t\t\telse if(d[i][j] == 2) ans[1]++;\n\t\t}\n\t\tprintf(\"%d %d\\n\", ans[0], ans[1]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint w,h,c1,c2,b,d;\nchar a[51][51];\nint dfs(int i,int j){\n  if(i==h||j==w||i<0||j<0||a[i][j]=='#')return 0;\n  if(a[i][j]=='W'){d++;return 0;}\n  else if(a[i][j]=='B'){b++;return 0;}\n  int s=1;\n  a[i][j]='#';\n  s+=dfs(i+1,j);\n  s+=dfs(i-1,j);\n  s+=dfs(i,j+1);\n  s+=dfs(i,j-1);\n  return s;\n}\nint main(){\n  int i,j,ans;\n  while(cin>>w>>h,w&&h){\n    c1=c2=0;\n    for(i=0;i<h;i++)scanf(\"%c\",&a[i]);\n    for(i=0;i<h;i++)for(j=0;j<w;j++)if(a[i][j]=='.'){\n      d=b=0;\n      ans=dfs(i,j);\n      if(b&&d)continue;\n      else if(b>d)c1+=ans;\n      else if(b<d)c2+=ans;\n    }\n    cout<<c1<<\" \"<<c2<<endl;\n}}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <complex>\n#include <math.h>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline long toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ninline long toLong(string s) {long v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//math\n//-------------------------------------------\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<long, long> PLL;\ntypedef long long LL;\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(long i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n\n//constant\n//--------------------------------------------\n\n//clear memory\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\nconst long double EPS = 1e-20;\nconst long INF = 1e10;\n\nchar mp[52][52];\nbool flag[52][52];\nint dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\nint main(){\n\tint w,h;\n\twhile(cin>>w>>h){\n\t\tif(w==0&&h==0)break;\n\t\tREP(i,52)REP(j,52)mp[i][j]='#';\n\t\tREP(i,h)REP(j,w)cin>>mp[i+1][j+1];\n\t\tCLR(flag);\n\t\tint bsum=0,wsum=0;\n\t\tREP(i,h)REP(j,w){\n\t\t\tif(flag[i+1][j+1]||mp[i+1][j+1]!='.')continue;\n\t\t\tqueue<PII>q;\n\t\t\tq.push(MP(i+1,j+1));\n\t\t\tbool b=false,w=false;\n\t\t\tint cnt=1;\n\t\t\tflag[i+1][j+1]=true;\n\t\t\twhile(!q.empty()){\n\t\t\t\tPII npos=q.front();q.pop();\n\t\t\t\tint x=npos.first,y=npos.second;\n\t\t\t\tREP(k,4){\n\t\t\t\t\tif(mp[x+dx[k]][y+dy[k]]=='W')w=true;\n\t\t\t\t\telse if(mp[x+dx[k]][y+dy[k]]=='B')b=true;\n\t\t\t\t\telse if(mp[x+dx[k]][y+dy[k]]=='.'&&!flag[x+dx[k]][y+dy[k]]){\n\t\t\t\t\t\tflag[x+dx[k]][y+dy[k]]=true;cnt++;\n\t\t\t\t\t\tq.push(MP(x+dx[k],y+dy[k]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(b&&!w)bsum+=cnt;\n\t\t\telse if(!b&&w)wsum+=cnt;\n\t\t}\n\t\tcout<<bsum<<\" \"<<wsum<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nvoid f(int a[][52],int b[][52],int x,int y){\n  if(a[x][y]==0&&b[x][y]==0){\n    b[x][y]=1;\n    f(a,b,x-1,y);\n    f(a,b,x,y-1);\n    f(a,b,x+1,y);\n    f(a,b,x,y+1);\n  }\n  return;\n}\nint main(){\n  int i,j;\n  int a[52][52],b[52][52],c[52][52],p,q,w,h;\n  char s;\n  while(cin>>w>>h&&w+h){\n    memset(a,-1,sizeof(a));\n    for(i=1;i<h+1;i++){\n      for(j=1;j<w+1;j++){\n\tcin>>s;\n\tif(0){\n\t}else if(s=='.'){\n\t  a[j][i]=0;\n\t}else if(s=='B'){\n\t  a[j][i]=1;\n\t}else if(s=='W'){\n\t  a[j][i]=2;\n\t}\n      }\n    }\n    memset(b,0,sizeof(b));\n    memset(c,0,sizeof(c));\n    for(i=1;i<h+1;i++){\n      for(j=1;j<w+1;j++){\n\tif(0){\n\t}else if(a[j][i]==1){\n\t  f(a,b,j-1,i);\n\t  f(a,b,j,i-1);\n\t  f(a,b,j+1,i);\n\t  f(a,b,j,i+1);\n\t}else if(a[j][i]==2){\n\t  f(a,c,j-1,i);\n\t  f(a,c,j,i-1);\n\t  f(a,c,j+1,i);\n\t  f(a,c,j,i+1);\n\t}\n      }\n    }\n    p=q=0;\n    for(i=1;i<h+1;i++){\n      for(j=1;j<w+1;j++){\n\tif(b[j][i]&&c[j][i]==0)\n\t  p++;\n\tif(b[j][i]==0&&c[j][i])\n\t  q++;\n      }\n    }\n    cout<<p<<\" \"<<q<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cctype>\n#include<utility>\n#include<string>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<map>\n#include<climits>\n\n#define REP(i, n) for(int i = 0;i < n;i++)\n#define REPR(i, n) for(int i = n;i >= 0;i--)\n#define FOR(i, m, n) for(int i = m;i < n;i++)\n#define FORR(i, m, n) for(int i = m;i >= n;i--)\n#define SORT(v, n) sort(v, v+n);\n#define VSORT(v) sort(v.begin(), v.end());\n#define llong long long\n#define pb(a) push_back(a)\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef long long int ll;\ntypedef pair<ll,ll> LLP;\n#define INF 1000000007\n#define MOD 1000000007\n\n#define ARRAY_MAX 55\nint h,w;\nint dx[4] = {1,0,0,-1};\nint dy[4] = {0,1,-1,0};\nchar mp[ARRAY_MAX][ARRAY_MAX];\nint B = 0,W = 0;\n\n\nint dfs(int y,int x,int num,int sum,bool& white,bool& black){\n    //num\n    //yx,\n    mp[y][x] = num;\n    int cnt = 0;//dfs\n\n    //\n    REP(i,4){\n        int nx = x + dx[i], ny = y + dy[i];\n        if(mp[ny][nx] == 'B'){\n            black = true;\n        }\n        if(mp[ny][nx] == 'W'){\n            white = true;\n        }\n        if(0 <= nx && nx < w && 0 <= ny && ny < h && mp[ny][nx] == '.'){\n            cnt += dfs(ny,nx,num,sum,white,black);\n            cnt++;//\n        }\n    }\n    return cnt;\n}\n\nint solve(){\n    //B,W\n    int res = '0';\n    for(int y = 0;y < h;y++){\n        for(int x = 0;x < w;x++){\n            if(mp[y][x] == '.'){\n                bool white = false,black = false;\n                int sum = dfs(y,x,res,1,white,black)+1;\n                res++;\n                if(black == true && white == false){\n                    B += sum;\n                }else if(black == false && white == true){\n                    W += sum;\n                }\n            }\n        }\n    }\n    return res;\n}\n\nint main(){\n\n    while(cin >> w >> h,h){\n\n        REP(i,ARRAY_MAX){\n            REP(j,ARRAY_MAX){\n                mp[i][j] = '&';//\n            }\n        }\n        REP(i,h){\n            REP(j,w){\n                cin >> mp[i][j];\n            }\n        }\n        \n        solve();\n\n        cout << B << \" \" << W << endl;\n        B = W = 0;\n    }\n\n    \n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstring field[50];\nbool isUsed[50][50];\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint black,white;\nint w,h;\n\nvoid dfs(int x,int y){\n  isUsed[y][x]=true;\n  if(field[y][x] == 'W'){\n    white++;\n  }else if(field[y][x] == 'B'){\n    black++;\n  }else{\n    for(int i=0 ; i < 4 ; i++){\n      int nx=x+dx[i],ny=y+dy[i];\n      if(nx >= 0 && ny >= 0 && nx < w && ny < h && !isUsed[ny][nx]){\n\tdfs(nx,ny);\n      }\n    }\n  }\n}\nint solve(int x,int y){\n  black=0,white=0;\n  for(int i=0 ; i < h ; i++){\n    for(int j=0 ; j < w ; j++){\n      isUsed[i][j]=false;\n    }\n  }\n  dfs(x,y);\n  if(black != 0 && white != 0){\n    return 3;\n  }else if(black == 0 && white != 0){\n    return 1;\n  }else if(black != 0 && white == 0){\n    return 0;\n  }\n  return 3;\n}\nint main(){\n  \n  while(1){\n    cin >>w>>h;\n    if(w+h == 0)break;\n    for(int i=0 ; i < h ; i++)cin >>field[i];\n    int ans[3]={0,0,0};\n    for(int i=0 ; i < h ; i++){\n      for(int j=0 ; j < w ; j++){\n\tif(field[i][j] == '.'){\n\t  ans[solve(j,i)]++;\n\t}\n      }\n    }\n    cout <<ans[0]<<\" \"<<ans[1]<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nenum{NONE,BLA,WHI};\n\nint kui[50][50]={};\nbool rin[50][50][2]={};\nint W,H;\nint dx[4]={1,-1,0,0};\nint dy[4]={0,0,1,-1};\nvoid clear(){\n     for(int i=0;i<50;i++){\n\t  for(int j=0;j<50;j++){\n\t       kui[i][j]=0;\n\t       rin[i][j][0]=false;rin[i][j][1]=false;\n\t  }\n     }\n}\nvoid rec(int x,int y,int color){\n     if(x>=W||x<0||y>=H||y<0) return;\n     if(kui[x][y]||rin[x][y][color])return;\n     rin[x][y][color]=true;\n     for(int i=0;i<4;i++){\n\t  rec(x+dx[i],y+dy[i],color);\n     }\n}\n\nint main(){\n     while(cin>>W>>H,W||H){\n\t  for(int i=0;i<W;i++){\n\t       for(int j=0;j<H;j++){\n\t\t    char t;\n\t\t    cin>>t;\n\t\t    switch(t){\n\t\t    case '.':\n\t\t\t break;\n\t\t    case 'B':\n\t\t\t kui[i][j]=BLA;\n\t\t\t break;\n\t\t    case 'W':\n\t\t\t kui[i][j]=WHI;\n\t\t\t break;\n\t\t    }\n\t       }\n\t  }\n\t  for(int i=0;i<W;i++){\n\t       for(int j=0;j<H;j++){\n\t\t    switch(kui[i][j]){\n\t\t    case BLA:\n\t\t\t for(int k=0;k<4;k++) rec(i+dx[k],j+dy[k],BLA);\n\t\t\t break;\n\t\t    case WHI:\n\t\t\t for(int k=0;k<4;k++) rec(i+dx[k],j+dy[k],WHI);\n\t\t\t break;\n\t\t    }\n\t       }\n\t  }\n\t  int sumw=0,sumb=0;\n\t  for(int i=0;i<W;i++){\n\t       for(int j=0;j<H;j++){\n\t\t    if(rin[i][j][BLA]&&(!rin[i][j][WHI]))sumb++;\n\t\t    if(rin[i][j][WHI]&&(!rin[i][j][BLA]))sumw++;\n\t       }\n\t  }\n\t  cout<<sumb<<\" \"<<sumw<<endl;\n\t  clear();\n     }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<vector>\nint W,H;\nint nb,nw;\nint n,flag=1,flag2;\nchar field[50][50];\n#define W_MAX 50\n#define H_MAX 50\n#define Black true\n#define White false\n/*-------------------------\nconst int dx[]={-1,0,1,0};\nconst int dy[]={0,-1,0,1};\n--------------------------*/\nint umerub(int x,int y){\n\tn++;\n\tfield[y][x]='X';\n\tif(y!=0&&field[y-1][x]=='.')umerub(x,y-1);\n\tif(x!=0&&field[y][x-1]=='.')umerub(x-1,y);\n\tif(y!=H-1&&field[y+1][x]=='.')umerub(x,y+1);\n\tif(x!=W-1&&field[y][x+1]=='.')umerub(x+1,y);\n\tif(y!=0&&field[y-1][x]=='W')flag=0;\n\tif(x!=0&&field[y][x-1]=='W')flag=0;\n\tif(y!=H-1&&field[y+1][x]=='W')flag=0;\n\tif(x!=W-1&&field[y][x+1]=='W')flag=0;\n\tif(y!=0&&field[y-1][x]=='B')flag2=1;\n\tif(x!=0&&field[y][x-1]=='B')flag2=1;\n\tif(y!=H-1&&field[y+1][x]=='B')flag2=1;\n\tif(x!=W-1&&field[y][x+1]=='B')flag2=1;\n\treturn n;\n}\n\nint umeruw(int x,int y){\n\tn++;\n\tfield[y][x]='W';\n\tif(y!=0&&field[y-1][x]=='X')umeruw(x,y-1);\n\tif(x!=0&&field[y][x-1]=='X')umeruw(x-1,y);\n\tif(y!=H-1&&field[y+1][x]=='X')umeruw(x,y+1);\n\tif(x!=W-1&&field[y][x+1]=='X')umeruw(x+1,y);\n\tif(y!=0&&field[y-1][x]=='B')flag=0;\n\tif(x!=0&&field[y][x-1]=='B')flag=0;\n\tif(y!=H-1&&field[y+1][x]=='B')flag=0;\n\tif(x!=W-1&&field[y][x+1]=='B')flag=0;\n\tif(y!=0&&field[y-1][x]=='W')flag2=1;\n\tif(x!=0&&field[y][x-1]=='W')flag2=1;\n\tif(y!=H-1&&field[y+1][x]=='W')flag2=1;\n\tif(x!=W-1&&field[y][x+1]=='W')flag2=1;\n\treturn n;\n}\n\nint main(){\n\twhile(cin>>W>>H,W|H){\n\t\tnb=0;\n\t\tnw=0;\n\t\tn=0;\n\t\tflag=1;\n\t\tflag2=0;\n\t\tfill_n((char *)field,W_MAX*H_MAX,0);\n\t\tfor(int i=0;i<H;i++){\n\t\t\tcin>>field[i];\n\t\t}\n\tfor(int i=0;i<H;i++){\n\t\tfor(int j=0;j<W;j++){\n\t\t\tif(field[i][j]=='.'){\n\t\t\t\tnb+=umerub(j,i)*flag*flag2;\n\t\t\t\tflag=1;\n\t\t\t\tflag2=0;\n\t\t\t\tn=0;\n\t\t\t\tnw+=umeruw(j,i)*flag*flag2;\n\t\t\t\tflag=1;\n\t\t\t\tflag2=0;\n\t\t\t\tn=0;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<nb<<\" \"<<nw<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint counter1,counter2;\nint w, h;\nint x, y;\nchar map[50][50];\n\nvoid serch_w(int x, int y);\nvoid serch_b(int x, int y);\n\nint main(){\n\n\twhile (cin >> w >> h, w&&h){\n\t\tcounter1 = 0;\n\t\tcounter2 = 0;\n\t\tfor (int i = 0; i < h; i++){\n\t\t\tfor (int j = 0; j < w; j++){\n\t\t\t\tcin >> map[i][j];\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < h; i++){\n\t\t\tfor (int j = 0; j < w; j++){\n\t\t\t\tif (map[i][j] == 'W'){\n\t\t\t\t\tx = i;\n\t\t\t\t\ty = j;\n\t\t\t\t\tserch_w(x, y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < h; i++){\n\t\t\tfor (int j = 0; j < w; j++){\n\t\t\t\tif (map[i][j] == 'B'){\n\t\t\t\t\tx = i;\n\t\t\t\t\ty = j;\n\t\t\t\t\tserch_b(x, y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < h; i++){\n\t\t\tfor (int j = 0; j < w; j++){\n\t\t\t\tcout << map[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\n\t\tfor (int i = 0; i < h; i++){\n\t\t\tfor (int j = 0; j < w; j++){\n\t\t\t\tif (map[i][j] == '2') counter1++;\n\t\t\t\tif (map[i][j] == '1') counter2++;\n\t\t\t}\n\t\t}\n\n\t\tcout << counter2 << \" \" <<counter1 << endl;\n\t}\n\treturn 0;\n}\n\nvoid serch_w(int x, int y){\n\n\t//if(???????????????????????&&????\\???????????????'.'??????????????)\n\tif (x + 1 < h && map[x + 1][y] == '.' && map[x + 1][y] != '2'){\n\t\tmap[x + 1][y] = '2';\n\t\tserch_w(x + 1, y);\n\t}\n\tif (y + 1 < w && map[x][y + 1] == '.' && map[x][y + 1] != '2'){\n\t\tmap[x][y + 1] = '2';\n\t\tserch_w(x, y + 1);\n\t}\n\tif (x - 1 >= 0 && map[x - 1][y] == '.' && map[x - 1][y] != '2'){\n\t\tmap[x - 1][y] = '2';\n\t\tserch_w(x - 1, y);\n\t}\n\tif (y - 1 >= 0 && map[x][y - 1] == '.' && map[x][y - 1] != '2'){\n\t\tmap[x][y - 1] = '2';\n\t\tserch_w(x, y - 1);\n\t}\n}\n\nvoid serch_b(int x, int y){\n\n\n\tif (x + 1 < h && map[x + 1][y] == '.'){\n\t\tmap[x + 1][y] = '1';\n\t\tserch_b(x + 1, y);\n\t}\n\telse if (x + 1 < h &&  map[x + 1][y] == '2'){\n\t\tmap[x + 1][y] = '3';\n\t\tserch_b(x + 1,y);\n\t}\n\n\n\tif (y + 1 < w && map[x][y + 1] == '.' ){\n\t\tmap[x][y + 1] = '1';\n\t\tserch_b(x, y + 1);\n\t}\n\telse if (y + 1 < w &&  map[x][y + 1] == '2'){\n\t\tmap[x][y + 1] = '3';\n\t\tserch_b(x, y+1);\n\t}\n\n\tif (x - 1 >= 0 && map[x - 1][y] == '.'){\n\t\tmap[x - 1][y] = '1';\n\t\tserch_b(x - 1, y);\n\t}\n\telse if (x - 1 >= 0 &&  map[x - 1][y] == '2'){\n\t\tmap[x - 1][y] ='3';\n\t\tserch_b(x - 1, y);\n\t}\n\n\tif (y - 1 >= 0 && map[x][y - 1] == '.'){\n\t\tmap[x][y - 1] = '1';\n\t\tserch_b(x, y - 1);\n\t}\n\telse if (y - 1 >= 0 &&  map[x][y - 1] == '2'){\n\t\tmap[x][y - 1] = '3';\n\t\tserch_b(x, y - 1);\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n\nusing namespace std;\ntypedef long long ll;\n\nvector<string> v;\nbool used[55][55];\nint w,h,x,y;\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,1,0,-1};\nbool flag_W,flag_B;\nint cnt;\n\nbool can(int y,int x) {\n    if(0 <= y && y < h && 0 <= x && x < w) return true;\n    return false;\n}\n\nvoid dfs(int y,int x) {\n    cnt++;\n    rep(i,4) {\n        int ny = y + dy[i];\n        int nx = x + dx[i];\n\n        if(can(ny,nx)) {\n            if(v[ny][nx] == 'W') flag_W = true;\n            else if(v[ny][nx] == 'B') flag_B = true;\n            else {\n                if(!used[ny][nx]) {\n                    used[ny][nx] = true;\n                    dfs(ny,nx);\n                }\n            }\n        }\n    }\n}\n\nint main()\n{\n    while(cin >> w >> h) {\n        if(w == 0 && h == 0) break;\n        \n        v.clear();\n        v.resize(h);\n        rep(i,h) cin >> v[i];\n\n        memset(used,0,sizeof(used));\n        int a = 0,b = 0;\n        rep(i,h) {\n            rep(j,w) {\n                if(!used[i][j] && v[i][j] == '.') {\n                    flag_W = false;\n                    flag_B = false;\n                    cnt = 0;\n                    used[i][j] = true;\n\n                    dfs(i,j);\n                    if(flag_B && !flag_W) a += cnt;\n                    if(flag_W && !flag_B) b += cnt;\n                }\n            }\n        }\n\n        cout << a << \" \" << b << endl;\n\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n\nusing namespace std;\nusing ll = long long;\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst ll INF = 1e9;\nconst ll MOD = 1e9 + 7;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint w, h;\nchar a[51][51];\nbool visited[51][51];\nbool ok(int y, int x, char c) {\n    bool res = true;\n    if (a[y][x] != '.') {\n        // if(c=='B') cout << \"\\t\" << y << \", \" << x << \": \" << a[y][x] << \", \"\n        // << (a[y][x] == c) << endl;\n        return a[y][x] == c;\n    }\n    rep(k, 4) {\n        int ny = y + dy[k];\n        int nx = x + dx[k];\n        if (ny < 0 || nx < 0) continue;\n        if (ny >= h || nx >= w) continue;\n        if (visited[ny][nx]) continue;\n        visited[ny][nx] = 1;\n        res &= ok(ny, nx, c);\n    }\n    return res;\n}\nint main() {\n    while (cin >> w >> h, w) {\n        int W = 0, B = 0;\n        bool f = 0;\n        rep(i, h) rep(j, w) cin >> a[i][j];\n        rep(i, h) rep(j, w) f |= a[i][j] != '.';\n        rep(i, h) rep(j, w) {\n            memset(visited, 0, sizeof(visited));\n            if (a[i][j] != '.') continue;\n            if (ok(i, j, 'W')) W++;\n            memset(visited, 0, sizeof(visited));\n            if (ok(i, j, 'B')) {\n                B++;\n            }\n        }\n        if (f)\n            cout << B << \" \" << W << endl;\n        else\n            cout << \"0 0\" << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <string>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <functional>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <list>\n#include <tuple>\n#include <bitset>\n\nusing namespace std;\n\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\ninline bool cheak(int x, int y, int xMax, int yMax){ return x >= 0 && y >= 0 && xMax > x && yMax > y; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str(); }\ntemplate<class T> inline T sqr(T x) { return x*x; }\n\ntypedef pair<int, int> P;\ntypedef tuple<int, int,int> T;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define For(i,a,b)\tfor(int (i) = (a);i < (b);(i)++)\n#define rep(i,n)\tFor(i,0,n)\n#define clr(a)\t\tmemset((a), 0 ,sizeof(a))\n#define mclr(a)\t\tmemset((a), -1 ,sizeof(a))\n#define all(a)\t\t(a).begin(),(a).end()\n#define sz(a)\t\t(sizeof(a))\n#define Fill(a,v)\tfill((int*)a,(int*)(a+(sz(a)/sz(*(a)))),v)\n\nconst int dx[8] = { 1, 0, -1, 0, 1, 1, -1, -1 }, dy[8] = { 0, -1, 0, 1, -1, 1, -1, 1 };\nconst int mod = 1000000007;\nconst int INF = 1e9;\n\nconst int M = 51;\nchar c[M][M];\nchar d[M][M];\nint w, h;\nbool f[M][M];\n\nchar dfs(int y, int x){\n\tif (c[y][x] != '.')return c[y][x];\n\tif (d[y][x])return 0;\n\tf[y][x] = true;\n\n\tchar ret = -1;\n\trep(i, 4){\n\t\tint tx = x + dx[i], ty = y + dy[i];\n\t\tif (cheak(tx, ty, w, h) && !f[ty][tx]){\n\t\t\tchar t = dfs(ty, tx);\n\t\t\tif (ret == -1 || t == ret){\n\t\t\t\tret = t;\n\t\t\t}\n\t\t\telse\n\t\t\tif(t != -1){\n\t\t\t\tret = 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nvoid sdfs(int y, int x, char n){\n\tif (!(n == 'B' || n == 'W'))return;\n\tif (c[y][x] != '.')return;\n\tf[y][x] = false;\n\td[y][x] = n;\n\n\trep(i, 4){\n\t\tint tx = x + dx[i], ty = y + dy[i];\n\t\tif (cheak(tx, ty, w, h) && f[ty][tx]){\n\t\t\tsdfs(ty, tx, n);\n\t\t}\n\t}\n}\n\nint main()\n{\n\n\twhile (cin >> w >> h && w){\n\t\tclr(d);\n\t\trep(y, h)rep(x, w){\n\t\t\tcin >> c[y][x];\n\t\t}\n\n\t\trep(y, h)rep(x, w){\n\t\t\tclr(f);\n\t\t\tsdfs(y, x, dfs(y, x));\n\t\t}\n\n\t\tint ba = 0, wa = 0;\n\t\trep(y, h)rep(x, w){\n\t\t\tif (c[y][x] == '.'){\n\t\t\t\tif (d[y][x] == 'B')ba++;\n\t\t\t\tif (d[y][x] == 'W')wa++;\n\t\t\t}\n\t\t}\n\n\t\tcout << ba << \" \" << wa << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1000000007;\nconst int MOD = 1000000007;\n\ntypedef long long ll;\ntypedef pair<int, int> pr;\n\nchar field[50][54];\nint w, h;\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\nint group[50][50];\n\nvoid dfs(int x, int y, int c){\n    if((group[x][y] & c) > 0) return;\n    group[x][y] |= c;\n    for(int i = 0; i < 4; i++){\n        int nx = x + dx[i], ny = y + dy[i];\n        if(0 <= nx && nx < h && 0 <= ny && ny < w &&\n                field[nx][ny] == '.'){\n            dfs(nx, ny, c);\n        }\n    }\n}\n\nint main(){\n    while(true){\n        scanf(\"%d%d\", &w, &h);\n        if(w == 0 && h == 0) break;\n        for(int i = 0; i < h; i++){\n            scanf(\" %s\", field[i]);\n        }\n        for(int i = 0; i < h; i++){\n            fill(group[i], group[i] + w, 0);\n        }\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                if(field[i][j] == 'B'){\n                    dfs(i, j, 1);\n                }else if(field[i][j] == 'W'){\n                    dfs(i, j, 2);\n                }\n            }\n        }\n        int black = 0, white = 0;\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                if(field[i][j] != '.') continue;\n                if(group[i][j] == 1){\n                    ++black;\n                }\n                if(group[i][j] == 2){\n                    ++white;\n                }\n            }\n        }\n        printf(\"%d %d\\n\", black, white);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n\n#define\tmp\tmake_pair\n\nusing namespace std;\n\ntypedef\tpair<int,int>\tpii;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nint main(){\n\tfor(int w,h;scanf(\"%d%d\",&w,&h),w;){\n\t\tstatic char land[50][51];\n\t\tstatic bool visited[50][50];\n\t\tfor(int i=0;i<h;i++){\n\t\t\tscanf(\"%s\",land[i]);\n\t\t\tfor(int j=0;j<w;j++)\tvisited[i][j]=false;\n\t\t}\n\n\t\tint bcnt=0,wcnt=0;\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\tif(land[i][j]!='.' || visited[i][j])\tcontinue;\n\t\t\tvisited[i][j]=true;\n\t\t\tint cnt=1;\n\t\t\tbool blk=false,wht=false;\n\t\t\tqueue<pii> qu;\tqu.push(mp(i,j));\n\t\t\twhile(!qu.empty()){\n\t\t\t\tpii a=qu.front();\tqu.pop();\n\t\t\t\tint x=a.second,y=a.first;\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tint xx=x+dx[k],yy=y+dy[k];\n\t\t\t\t\tif(0<=xx && xx<w && 0<=yy && yy<h && !visited[yy][xx]){\n\t\t\t\t\t\tif(land[yy][xx]=='B'){ blk=true; continue; }\n\t\t\t\t\t\tif(land[yy][xx]=='W'){ wht=true; continue; }\n\t\t\t\t\t\tif(land[yy][xx]=='.'){\n\t\t\t\t\t\t\tqu.push(mp(yy,xx));\n\t\t\t\t\t\t\tvisited[yy][xx]=true;\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(blk && !wht)\tbcnt+=cnt;\n\t\t\tif(wht && !blk)\twcnt+=cnt;\n\t\t}\n\n\t\tprintf(\"%d %d\\n\",bcnt,wcnt);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdio>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <cmath>\n#include <complex>\n#include <map>\n#include <climits>\n#include <sstream>\nusing namespace std;\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define EPS 1e-8\n#define F first\n#define S second\n#define mkp make_pair\n\nstatic const double PI=6*asin(0.5);\ntypedef long long ll;\ntypedef complex<double> CP;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vint;\nstatic const int INF=1<<24;\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v,int a,int b, const T  &t = T()){\n\tv.assign(a,vector<T>(b,t));\n}\n\n//v.erase(unique(v.begin(),v.end()),v.end());\n\nvector<vint> vv;\nvector<vint> vis;\nint B,W;\nint x,y;\nbool f1,f2;\nint foo(int a,int b){\n\tint ret=0;\n\t// cout<<a<<\" \"<<b<<endl;\n\tif(vv[a][b]==1) f1=true;\n\tif(vv[a][b]==2) f2=true;\n\tif(vis[a][b]) return 0;\n\tvis[a][b]=1;\n\tret++;\n\tif(a>0){\n\t\tret+=foo(a-1,b);\n\t}\n\tif(a<x-1){\n\t\tret+=foo(a+1,b);\n\t}\n\tif(b>0){\n\t\tret+=foo(a,b-1);\n\t}\n\tif(b<y-1){\n\t\tret+=foo(a,b+1);\n\t}\n\n\treturn ret;\n}\n\nint main(){\n\t// int x,y;\n\twhile(cin>>y>>x,x||y){\n\t\tinitvv(vv,x,y);\n\t\tinitvv(vis,x,y);\n\t\tB=0;\n\t\tW=0;\n\t\trep(i,x){\n\t\t\trep(j,y){\n\t\t\t\tvis[i][j]=0;\n\t\t\t\tchar t;\n\t\t\t\tcin>>t;\n\t\t\t\tif(t=='B'){\n\t\t\t\t\tvv[i][j]=1;\n\t\t\t\t\tvis[i][j]=1;\n\t\t\t\t}\n\t\t\t\telse if(t=='.'){\n\t\t\t\t\tvv[i][j]=0;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tvv[i][j]=2;\n\t\t\t\t\tvis[i][j]=1;\n\t\t\t\t}\n\t\t\t\t// cout<<vv[i][j];\n\t\t\t}\n\t\t\t// cout<<endl;\n\t\t}\n\t\t// initvv(vis,x,y);\n\t\trep(i,x){\n\t\t\trep(j,y){\n\t\t\t\tif(vis[i][j]==0){\n\t\t\t\t\tf1=false;\n\t\t\t\t\tf2=false;\n\t\t\t\t\tint tt=foo(i,j);\n\t\t\t\t\tif(f1&&!f2){\n\t\t\t\t\t\tB+=tt;\n\t\t\t\t\t}\n\t\t\t\t\tif(!f1&&f2){\n\t\t\t\t\t\tW+=tt;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<B<<\" \"<<W<<endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint dx[4]={0,0,1,-1};\nint dy[4]={1,-1,0,0};\n\nconst int black = 0x01;\nconst int white = 0x02;\n\nint search(vector<vector<char> >& map, int y, int x, int& whose){\n    if(map[y][x]=='A'){\n        return 0;\n    }\n    if(map[y][x]=='B'){\n        whose|=black;\n        return 0;\n    }\n    if(map[y][x]=='W'){\n        whose|=white;\n        return 0;\n    }\n    map[y][x] = 'A';\n    \n    int count=1;\n    for(int i=0; i<4; i++){\n        count += search(map, y+dy[i], x+dx[i], whose);\n    }\n    return count;\n}\n\nint main(){\n    while(1){\n        int w,h;\n        cin >> w >> h;\n        if(w==0) break;\n\n        vector<vector<char> > map(h+2, vector<char>(w+2, 'A'));\n        for(int i=1; i<=h; i++){\n            for(int j=1; j<=w; j++){\n                cin >> map[i][j];\n            }\n        }\n\n        int bcount=0;\n        int wcount=0;\n        for(int i=1; i<=h; i++){\n            for(int j=1; j<=w; j++){\n                if(map[i][j]=='.'){\n                    int whose=0; // 1:black 2:white 3:both\n                    int count=0;\n                    count = search(map, i, j, whose);\n                    if(whose==1){\n                        bcount+=count;\n                    }else if(whose==2){\n                        wcount+=count;\n                    }\n                }\n            }\n        }\n\n        cout << bcount << \" \" << wcount << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < n; ++i)\n\nint w,h;\nbool black[51][51];\nbool white[51][51];\nstring field[51];\n\nint dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\n\nvoid solve(int x, int y, char c) {\n  if ((c == 'B' and black[y][x]) || (c == 'W' and white[y][x])) return;\n\n  if (c == 'W' and field[y][x] != 'W') white[y][x] = true;\n  else if (c == 'B' and field[y][x] != 'B') black[y][x] = true;\n\n  rep(i, 4) {\n    int nx = x + dx[i], ny = y + dy[i];\n    if (0 <= nx and nx < w and 0 <= ny and ny < h and field[ny][nx] == '.') {\n      solve(nx, ny, c);\n    }\n  }\n}\n\nint main() {\n  while (cin >> w >> h, w || h) {\n    rep(i, h) {\n      cin >> field[i];\n    }\n\n    fill(black[0], black[50], false);\n    fill(white[0], white[50], false);\n\n    rep(i, h) rep(j, w) {\n      if (field[i][j] == 'W') solve(j,i,'W');\n      else if (field[i][j] == 'B') solve(j,i,'B');\n    }\n\n    int bl, wh;\n    bl = wh = 0;\n\n    rep(i, h) rep(j, w) {\n      if (black[i][j] && !white[i][j]) bl += 1;\n      else if (!black[i][j] && white[i][j]) wh += 1;\n    }\n\n    cout << bl << \" \" << wh << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nint w, h;\nint dx[]{ 1,-1,0,0 }, dy[]{ 0,0,1,-1 };\nbool cnt[2][51][51];\nchar s[51][51];\nchar dir[]{ 'B','W' };\n\nvoid dfs(int x, int y, int idx) {\n\trep(i, 4) {\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\tif (0 <= nx&&nx < h && 0 <= ny&&ny < w&&s[nx][ny] == '.' && !cnt[idx][nx][ny]) {\n\t\t\tcnt[idx][nx][ny] = true;\n\t\t\tdfs(nx, ny, idx);\n\t\t}\n\t}\n}\nint main() {\n\twhile (scanf(\"%d%d\", &w, &h), w) {\n\t\tmemset(cnt, 0, sizeof(cnt));\n\t\trep(i, h)scanf(\"%s\", s[i]);\n\t\trep(t, 2)rep(i, h)rep(j, w) {\n\t\t\tif (s[i][j] == dir[t])dfs(i, j, t);\n\t\t}\n\t\tint cb = 0, cw = 0;\n\t\trep(i, h)rep(j, w) {\n\t\t\tif (cnt[0][i][j] && cnt[1][i][j])continue;\n\t\t\tif (cnt[0][i][j])cb++;\n\t\t\tif (cnt[1][i][j])cw++;\n\t\t}\n\t\tprintf(\"%d %d\\n\", cb, cw);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(long long i=(a);i<(b);i++)\n#define REP(i,N) for(long long i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define fi first\n#define se second\n\n#define PI acos(-1.0)\n#define INF 10e9+9\n#define EPS 1e-10\n#define MAX_N 100100\n#define MAX_M 100100\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef pair<double, double> PD;\ntypedef pair<string, ll> PS;\ntypedef vector<ll> V;\ntypedef pair<P, char> PC;\n\nint h, w;\nchar field[100][100];\n\nint dx[] = { 1, 0, -1, 0 };\nint dy[] = { 0, 1, 0, -1 };\n\nbool used[100][100];\nbool fw, fb;\nvoid solve(int y,int x){\n\t//cout << y << x << endl;\n\tused[y][x] = 1;\n\n\tif (field[y][x] == 'W'){\n\t\tfw = 1;\n\t\treturn;\n\t}\n\tif (field[y][x] == 'B'){\n\t\tfb = 1;\n\t\treturn;\n\t}\n\n\tREP(i, 4){\n\t\tint ny = y + dy[i], nx = x + dx[i];\n\t\tif (ny >= 0 && ny < h&&nx >= 0 && nx < w){\n\t\t\tif (!used[ny][nx])solve(ny, nx);\n\t\t}\n\t}\n}\n\nint main(){\n\twhile (cin >> h >> w&&h+w){\n\t\tint wans = 0, bans = 0;\n\t\tREP(i, h)REP(j, w)cin >> field[i][j];\n\t\tREP(i, h){\n\t\t\tREP(j, w){\n\t\t\t\tfw = 0; fb = 0;\n\t\t\t\tREP(k, 100)fill(used[k], used[k] + 100, 0);\n\t\t\t\tif (field[i][j] == '.'){\n\t\t\t\t\tsolve(i, j);\n\t\t\t\t}\n\t\t\t\tif (fw&&!fb)wans++;\n\t\t\t\tif (!fw&&fb)bans++;\n\t\t\t\t//cout << endl;\n\t\t\t}\n\t\t}\n\t\tcout << bans << \" \" << wans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef ostringstream OSS; typedef istringstream ISS;\ntypedef long long LL;\ntypedef pair<int, int> PII;  typedef pair<LL, LL> PLL;\ntypedef vector<int>    VI;   typedef vector<VI>   VVI;   typedef vector<VVI>   VVVI;\ntypedef vector<LL>     VLL;  typedef vector<VLL>  VVLL;  typedef vector<VVLL>  VVVLL;\ntypedef vector<double> VD;   typedef vector<VD>   VVD;   typedef vector<VVD>   VVVD;\ntypedef vector<string> VS;   typedef vector<VS>   VVS;   typedef vector<VVS>   VVVS;\ntypedef vector<bool>   VB;   typedef vector<VB>   VVB;   typedef vector<VVB>   VVVB;\ntypedef vector<PII>    VPII; typedef vector<VPII> VVPII; typedef vector<VVPII> VVVPII;\ntypedef vector<PLL>    VPLL; typedef vector<VPLL> VVPLL; typedef vector<VVPLL> VVVPLL;\n\ntypedef unsigned int  UI;\ntypedef vector<UI>    VUI;\ntypedef vector<VUI>   VVUI;\n\n#define fst first\n#define snd second\n// #define Y first\n// #define X second\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back \n#define ALL(x)  (x).begin(),(x).end()\n#define RALL(x) (x).rbegin(),(x).rend()\n#define RANGEBOX(x,y,maxX,maxY) (0 <= (x) && 0 <= (y) && (x) < (maxX) && (y) < (maxY))\n#define RANGE(x, l, r) ((l) <= (x) && (x) <= (r))\n#define rep(i, N)  for (int i = 0; i < (int)(N); i++)\n#define rrep(i, N) for (int i = N - 1; i >= 0; i--)\n#define REP(i, init, N)  for (int i = (init); i < (int)(N); i++)\n#define RREP(i, N, last) for (int i = (init - 1); i >= last; i--)\n#define MAXUD(orig, target) orig = max(orig, target)\n#define MINUD(orig, target) orig = min(orig, target)\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\ntemplate < typename T > inline T fromString(const string &s) { T res; ISS iss(s); iss >> res; return res; };\ntemplate < typename T > inline string toString(const T &a)   { OSS oss; oss << a; return oss.str(); };\n\ntemplate<typename T=int> inline void dump(vector<T> vs, bool ent=false) { rep(i, vs.size()) cout << vs[i] << (i+1==vs.size() ? '\\n' : ' '); if (ent) cout << endl; }\ntemplate<typename T = int> inline void dump(vector<vector<T>> vs, bool ent = false) { rep(i, vs.size()) dump<T>(vs[i]); if (ent) cout << endl; }\n\nconst int    INF  = 0x3f3f3f3f;\nconst LL     INFL = 0x3f3f3f3f3f3f3f3fLL;\nconst double DINF = 0x3f3f3f3f;\nconst int    DX[] = {1,  0, -1, 0};\nconst int    DY[] = {0, -1,  0, 1};\nconst double EPS  = 1e-12;\n// const double PI   = acos(-1.0);\n// lambda: [](T1 x)->T2{return y;}\n// simple lambda: [](T x){return x;}\n\nint H, W;\nVS ts;\n\nvoid dfs(int y, int x, char c) {\n    if (!RANGEBOX(y, x, H, W)) return;\n    if (isupper(ts[y][x]) || ts[y][x] == c || ts[y][x] == 'x') return;\n\n    if (ts[y][x] == '.') ts[y][x] = c;\n    else if (islower(ts[y][x]) && ts[y][x] != c) ts[y][x] = 'x';\n    else assert(false);\n\n    rep(i, 4) {\n        dfs(y + DY[i], x + DX[i], c);\n    }\n}\n\nPII solve() {\n    ts = VS(H);\n    rep(i, H) cin >> ts[i];\n\n    PII res;\n\n    rep(y, H) rep(x, W) {\n        if (ts[y][x] != '.') {\n            rep(i, 4) {\n                dfs(y + DY[i], x + DX[i], tolower(ts[y][x]));\n            }\n        }\n    }\n\n    rep(y, H) rep(x, W) {\n        if (ts[y][x] == 'b') ++res.fst;\n        if (ts[y][x] == 'w') ++res.snd;\n    }\n\n    return res;\n}\n\nint main(void) {\n    while (cin >> W >> H, W) {\n        auto res = solve();\n        cout << res.fst << \" \" << res.snd << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define all(v) begin(v), end(v)\n#define pb(a) push_back(a)\n#define fr first\n#define sc second\n#define INF 2000000000\n#define int long long int\n\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) ( EQ((a).X, (b).X) && EQ((a).Y, (b).Y) )\n#define LE(n, m) ((n) < (m) + EPS)\n#define LEQ(n, m) ((n) <= (m) + EPS)\n#define GE(n, m) ((n) + EPS > (m))\n#define GEQ(n, m) ((n) + EPS >= (m))\n\ntypedef vector<int> VI;\ntypedef vector<VI> MAT;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, double> C;\n\nint dx[]={1, -1, 0, 0};\nint dy[]={0, 0, 1, -1};\nint const MOD = 1000000007;\nll mod_pow(ll x, ll n) {return (!n)?1:(mod_pow((x*x)%MOD,n/2)*((n&1)?x:1))%MOD;}\nint madd(int a, int b) {return (a + b) % MOD;}\nint msub(int a, int b) {return (a - b + MOD) % MOD;}\nint mmul(int a, int b) {return (a * b) % MOD;}\nint minv(int a) {return mod_pow(a, MOD-2);}\nint mdiv(int a, int b) {return mmul(a, minv(b));}\n\nnamespace std {\n    bool operator<(const P& a, const P& b) {\n        return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n    }\n}\n\nint w, h;\nconst int SIZE = 60;\nchar board[SIZE][SIZE];\nint  paint[SIZE][SIZE];\n\nvoid dfs(int x, int y, int color) {\n    rep(i,0,4) {\n        int nx = x + dx[i];\n        int ny = y + dy[i];\n        if(nx < 0 || nx >= h || ny < 0 || ny >= w) continue;\n        int &p = paint[nx][ny];\n        if(board[nx][ny] != '.') continue;\n        if(p == color || p == INF) continue;\n        if(p == -1) p = color;\n        else p = INF;\n        dfs(nx, ny, color);\n    }\n}\n\nsigned main() {\n    while(cin >> w >> h, w||h) {\n        memset(paint, -1, sizeof(paint));\n        rep(i,0,h) rep(j,0,w) cin >> board[i][j];\n        rep(i,0,h) rep(j,0,w) {\n            if(board[i][j] == 'W') dfs(i, j, 0);\n            if(board[i][j] == 'B') dfs(i, j, 1);\n        }\n\n        int cntw = 0, cntb = 0;\n        rep(i,0,h) rep(j,0,w) {\n            if(paint[i][j] == 0) cntw++;\n            else if(paint[i][j] == 1) cntb++;\n        }\n        printf(\"%lld %lld\\n\", cntb, cntw);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint counter1,counter2;\nint w, h;\nint x, y;\nchar map[50][50];\n\nvoid serch_w(int x, int y);\nvoid serch_b(int x, int y);\n\nint main(){\n\n\twhile (cin >> w >> h, w&&h){\n\t\tcounter1 = 0;\n\t\tcounter2 = 0;\n\t\tfor (int i = 0; i < h; i++){\n\t\t\tfor (int j = 0; j < w; j++){\n\t\t\t\tcin >> map[i][j];\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < h; i++){\n\t\t\tfor (int j = 0; j < w; j++){\n\t\t\t\tif (map[i][j] == 'W'){\n\t\t\t\t\tx = i;\n\t\t\t\t\ty = j;\n\t\t\t\t\tserch_w(x, y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < h; i++){\n\t\t\tfor (int j = 0; j < w; j++){\n\t\t\t\tif (map[i][j] == 'B'){\n\t\t\t\t\tx = i;\n\t\t\t\t\ty = j;\n\t\t\t\t\tserch_b(x, y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < h; i++){\n\t\t\tfor (int j = 0; j < w; j++){\n\t\t\t\tcout << map[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\n\t\tfor (int i = 0; i < h; i++){\n\t\t\tfor (int j = 0; j < w; j++){\n\t\t\t\tif (map[i][j] == '2') counter1++;\n\t\t\t\tif (map[i][j] == '1') counter2++;\n\t\t\t}\n\t\t}\n\n\t\tcout << counter1 << \" \" <<counter2 << endl;\n\t}\n\treturn 0;\n}\n\nvoid serch_w(int x, int y){\n\n\t//if(???????????????????????&&????\\???????????????'.'??????????????)\n\tif (x + 1 < h && map[x + 1][y] == '.' && map[x + 1][y] != '2'){\n\t\tmap[x + 1][y] = '2';\n\t\tserch_w(x + 1, y);\n\t}\n\tif (y + 1 < w && map[x][y + 1] == '.' && map[x][y + 1] != '2'){\n\t\tmap[x][y + 1] = '2';\n\t\tserch_w(x, y + 1);\n\t}\n\tif (x - 1 >= 0 && map[x - 1][y] == '.' && map[x - 1][y] != '2'){\n\t\tmap[x - 1][y] = '2';\n\t\tserch_w(x - 1, y);\n\t}\n\tif (y - 1 >= 0 && map[x][y - 1] == '.' && map[x][y - 1] != '2'){\n\t\tmap[x][y - 1] = '2';\n\t\tserch_w(x, y - 1);\n\t}\n}\n\nvoid serch_b(int x, int y){\n\n\n\tif (x + 1 < h && map[x + 1][y] == '.'){\n\t\tmap[x + 1][y] = '1';\n\t\tserch_b(x + 1, y);\n\t}\n\telse if (x + 1 < h &&  map[x + 1][y] == '2'){\n\t\tmap[x + 1][y] = '3';\n\t\tserch_b(x + 1,y);\n\t}\n\n\n\tif (y + 1 < w && map[x][y + 1] == '.' ){\n\t\tmap[x][y + 1] = '1';\n\t\tserch_b(x, y + 1);\n\t}\n\telse if (y + 1 < w &&  map[x][y + 1] == '2'){\n\t\tmap[x][y + 1] = '3';\n\t\tserch_b(x, y+1);\n\t}\n\n\tif (x - 1 >= 0 && map[x - 1][y] == '.'){\n\t\tmap[x - 1][y] = '1';\n\t\tserch_b(x - 1, y);\n\t}\n\telse if (x - 1 >= 0 &&  map[x - 1][y] == '2'){\n\t\tmap[x - 1][y] ='3';\n\t\tserch_b(x - 1, y);\n\t}\n\n\tif (y - 1 >= 0 && map[x][y - 1] == '.'){\n\t\tmap[x][y - 1] = '1';\n\t\tserch_b(x, y - 1);\n\t}\n\telse if (y - 1 >= 0 &&  map[x][y - 1] == '2'){\n\t\tmap[x][y - 1] = '3';\n\t\tserch_b(x, y - 1);\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nint bfs[2][50][50];\nchar str[50][51];\nint dx[]={1,0,0,-1};\nint dy[]={0,1,-1,0};\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<b;i++)scanf(\"%s\",str[i]);\n\t\tfor(int i=0;i<50;i++)for(int j=0;j<50;j++)bfs[0][i][j]=bfs[1][i][j]=0;\n\t\tqueue<pair<int,int> >Q;\n\t\tfor(int i=0;i<b;i++){\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tif(str[i][j]=='B'){\n\t\t\t\t\tbfs[0][i][j]=1;\n\t\t\t\t\tQ.push(make_pair(i,j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(Q.size()){\n\t\t\tint row=Q.front().first;\n\t\t\tint col=Q.front().second;\n\t\t\tQ.pop();\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tif(0<=row+dx[i]&&row+dx[i]<b&&0<=col+dy[i]&&col+dy[i]<a&&str[row+dx[i]][col+dy[i]]=='.'&&!bfs[0][row+dx[i]][col+dy[i]]){\n\t\t\t\t\tbfs[0][row+dx[i]][col+dy[i]]=1;\n\t\t\t\t\tQ.push(make_pair(row+dx[i],col+dy[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<b;i++){\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tif(str[i][j]=='W'){\n\t\t\t\t\tbfs[1][i][j]=1;\n\t\t\t\t\tQ.push(make_pair(i,j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(Q.size()){\n\t\t\tint row=Q.front().first;\n\t\t\tint col=Q.front().second;\n\t\t\tQ.pop();\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tif(0<=row+dx[i]&&row+dx[i]<b&&0<=col+dy[i]&&col+dy[i]<a&&str[row+dx[i]][col+dy[i]]=='.'&&!bfs[1][row+dx[i]][col+dy[i]]){\n\t\t\t\t\tbfs[1][row+dx[i]][col+dy[i]]=1;\n\t\t\t\t\tQ.push(make_pair(row+dx[i],col+dy[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint B=0;\n\t\tint W=0;\n\t\tfor(int i=0;i<b;i++)\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tif(str[i][j]=='.'&&bfs[0][i][j]&&!bfs[1][i][j])B++;\n\t\t\t\tif(str[i][j]=='.'&&!bfs[0][i][j]&&bfs[1][i][j])W++;\n\t\t\t}\n\t\tprintf(\"%d %d\\n\",B,W);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\n#define MAX 52\nbool dfs(char map[MAX][MAX], int i, int j, int h, int w, char &c){\n  const int di[] = {-1,0,1,0};\n  const int dj[] = {0,1,0,-1};\n\n  if( i < 1 || i > h || j < 1 || j > w )\n    return true;\n\n  if( map[i][j] == 'V' )\n    return true;\n\n  //cout << '(' << i << ',' << j << ')' << ' ';\n\n  if( map[i][j] == 'B' || map[i][j] == 'W' ){\n    if( (c == 'B' || c == 'W') && map[i][j] != c ){\n      return false;\n    }else{\n      c = map[i][j];\n      //cout << c << endl;\n      return true;\n    }\n  }\n\n  map[i][j] = 'V';\n  for(int k = 0; k < sizeof(di)/sizeof(*di); ++k){\n    if( !dfs( map, i + di[k], j + dj[k], h, w, c ) )\n      return false;\n  }\n  return true;\n}\nint main(){\n  while(true){\n    int w,h;\n    int numBlack = 0, numWhite = 0;\n    char o_map[MAX][MAX], map[MAX][MAX];\n    cin>>w>>h;\n    if(w==0&&h==0)break;\n    for(int i = 0; i < h; ++i){\n      string s;\n      cin >> s;\n      for(unsigned int j = 0; j < w; ++j){\n\to_map[i+1][j+1] = map[i+1][j+1] = s[j];\n      }\n    }\n    for(int i = 1; i <= h; ++i){\n      for(int j = 1; j <= w; ++j){\n\tchar c = 'V';\n\tif( map[i][j] == '.' ){\n\t  if( dfs( map, i, j, h, w, c ) ){\n\t    if( c == 'B' )\n\t      ++numBlack;\n\t    if( c == 'W' )\n\t      ++numWhite;\n\t  }\n\t  for(int y = 1; y <= h; ++y){\n\t    for(int x = 1; x <= w; ++x){\n\t      //cout << map[y][x];\n\t      map[y][x] = o_map[y][x];\n\t    }\n\t    //cout << endl;\n\t  }\n\t}\n      }\n    }\n    cout << numBlack << ' ' << numWhite << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\nstruct UnionFind {\n  const int n;\n  V<> t; // root ? -sz : par\n  UnionFind(int n) : n(n), t(n, -1) {}\n  int find(int v) { return t[v] < 0 ? v : t[v] = find(t[v]); }\n  void unite(int u, int v) {\n    if ((u = find(u)) == (v = find(v))) return;\n    if (-t[u] < -t[v]) swap(u, v);\n    t[u] += t[v];\n    t[v] = u;\n  }\n  bool same(int u, int v) { return find(u) == find(v); }\n  int size(int v) { return -t[find(v)]; }\n};\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  while (true) {\n    int w, h; cin >> w >> h;\n    if (!w) break;\n    V<string> s(h); for (auto&& e : s) cin >> e;\n    V<> di{1, 0, -1, 0}, dj{0, 1, 0, -1};\n    auto in = [&](int i, int j) -> bool { return 0 <= i and i < h and 0 <= j and j < w; };\n    auto _ = [&](int i, int j) -> int { return i * w + j; };\n    UnionFind uf(h * w);\n    for (int i = 0; i < h; ++i) for (int j = 0; j < w; ++j) if (s[i][j] == '.') {\n      if (i + 1 < h and s[i + 1][j] == '.') uf.unite(_(i, j), _(i + 1, j));\n      if (j + 1 < w and s[i][j + 1] == '.') uf.unite(_(i, j), _(i, j + 1));\n    }\n    set<int> sb, sw;\n    for (int i = 0; i < h; ++i) for (int j = 0; j < w; ++j) {\n      if (s[i][j] == 'B') {\n        for (int d = 0; d < 4; ++d) {\n          int ni = i + di[d], nj = j + dj[d];\n          if (!in(ni, nj)) continue;\n          if (s[ni][nj] == '.') sb.insert(uf.find(_(ni, nj)));\n        }\n      }\n      if (s[i][j] == 'W') {\n        for (int d = 0; d < 4; ++d) {\n          int ni = i + di[d], nj = j + dj[d];\n          if (!in(ni, nj)) continue;\n          if (s[ni][nj] == '.') sw.insert(uf.find(_(ni, nj)));\n        }\n      }\n    }\n    int cb = 0, cw = 0;\n    for (int i = 0; i < h; ++i) for (int j = 0; j < w; ++j) if (s[i][j] == '.') {\n      int p = uf.find(_(i, j));\n      cb += sb.count(p) and !sw.count(p);\n      cw += sw.count(p) and !sb.count(p);\n    }\n    cout << cb << ' ' << cw << '\\n';\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\nusing namespace std;\n\n#define WHITE 1\n#define BLACK 2\n\nint w,h;\nstring s[50];\nint dx[4]={0,-1,0,1};\nint dy[4]={1,0,-1,0};\nvoid rec(int x, int y, int mark)\n{\n  int i;\n  int xx,yy;\n  if(s[x][y]!='W'&&s[x][y]!='B')s[x][y]|=mark;\n  for(i=0;i<4;i++){\n    xx=x+dx[i];\n    yy=y+dy[i];\n    if((xx<0)||(h<=xx))continue;\n    if((yy<0)||(w<=yy))continue;\n    if(s[xx][yy]=='W'||s[xx][yy]=='B')continue;\n    if((s[xx][yy]&mark)==mark)continue;\n    rec(xx,yy,mark);\n  }\n}\n\nint main()\n{\n  int i,j;\n  int W,B;\n  while(cin>>w>>h,w||h){\n    for(i=0;i<h;i++)cin>>s[i];\n    /*\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tcout<<s[i][j];\n      }\n      cout<<endl;\n    }\n    */\n    for(i=0;i<h;i++)for(j=0;j<w;j++)if(s[i][j]=='.')s[i][j]=0;\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tif(s[i][j]=='W')rec(i,j,WHITE);\n\tif(s[i][j]=='B')rec(i,j,BLACK);\n      }\n    }\n    /*\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tprintf(\"%d\",s[i][j]);\n      }\n      cout<<endl;\n    }\n    */\n    W=B=0;\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tif(s[i][j]==WHITE)W++;\n\tif(s[i][j]==BLACK)B++;\n      }\n    }\n    cout<<B<<\" \"<<W<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n\nvoid insert_stack(std::vector<std::vector<char> > &map, std::stack<std::pair<int, int> > &st, char self_color, char other_color, int &count, bool &check_surrounded, bool &check_only_wall); \nvoid dfs(std::vector<std::vector<char> > &map, int i, int j, char self_color, char other_color, int &total); \nint whole_search(std::vector<std::vector<char> > map, int w, int h, char self_color, char other_color); \n\nint main(void) {\n    int w;\n    int h;\n\n    while (1) {\n        std::cin >> w >> h;\n        if (w == 0 && h == 0) {\n            break;\n        }\n\n        std::vector<std::vector<char> > map_b(h+2, std::vector<char>(w+2, '#'));\n        std::vector<std::vector<char> > map_w(h+2, std::vector<char>(w+2, '#'));\n\n        for (int i = 1; i <= h; i++) {\n            for (int j = 1; j <= w; j++) {\n                std::cin >> map_b[i][j];\n                map_w[i][j] = map_b[i][j];\n            }\n        }\n        std::cout << whole_search(map_b, w, h, 'B', 'W') << \" \" << whole_search(map_w, w, h, 'W', 'B') << std::endl;\n    }\n\n\n    return 0;\n}\n\nvoid insert_stack(std::vector<std::vector<char> > &map, std::stack<std::pair<int, int> > &st, char self_color, char other_color, int &count, bool &check_surrounded, bool &check_only_wall) {\n    int dx[] = {0, 0, 1, -1};\n    int dy[] = {1, -1, 0, 0};\n    int first;\n    int second;\n\n    first = st.top().first;\n    second = st.top().second;\n    st.pop();\n    ++count;\n\n    for (int k = 0; k < 4; k++) {\n        if (map[first + dx[k]][second + dy[k]] == '.') {\n            st.push(std::make_pair(first + dx[k], second + dy[k])); \n            map[first + dx[k]][second + dy[k]] = '$';\n        } else if (map[first + dx[k]][second + dy[k]] == other_color) {\n            check_surrounded = false; \n        } else if (map[first + dx[k]][second + dy[k]] == self_color) {\n            check_only_wall = true;\n        }\n    }\n    return;\n}\n\nvoid dfs(std::vector<std::vector<char> > &map, int i, int j, char self_color, char other_color, int &total) {\n    int count = 0;\n    bool check_surrounded = true;\n    bool check_only_wall = false;\n\n    std::stack<std::pair<int, int> > st;\n    st.push(std::make_pair(i, j));\n    map[i][j] = '$';\n\n    while (1) {\n        if (st.empty() == 1) {\n            break; \n        }\n        insert_stack(map, st, self_color, other_color, count, check_surrounded, check_only_wall);\n    }\n\n    if (check_surrounded == true && check_only_wall == true) {\n        total += count;\n    } else {\n        check_surrounded = true;\n        check_only_wall = false;\n    }\n    return;\n}\n\nint whole_search(std::vector<std::vector<char> > map, int w, int h, char self_color, char other_color) {\n    int total = 0;\n\n    for (int i = 1; i <= h; i++) {\n        for (int j = 1; j <= w; j++) {\n            if (map[i][j] == '.') {\n                dfs(map, i, j, self_color, other_color, total);\n            }\n        }\n    }\n    return total; \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint dy[4] = {0, 1, 0, -1};\nint dx[4] = {1, 0, -1, 0};\n\nvoid bfs(int c[][64], queue<pair<int, int> > q, int w, int h, int bit)\n{\n    for (; q.size(); q.pop()){\n        pair<int, int> pos = q.front();\n        \n        for (int i = 0; i < 4; i++){\n            pair<int, int> npos = make_pair(pos.first + dy[i], pos.second + dx[i]);\n            \n            if (0 <= npos.first && npos.first < h && 0 <= npos.second && npos.second < w){\n                if ((c[npos.first][npos.second] & bit) == 0){\n                    c[npos.first][npos.second] |= bit;\n                    q.push(npos);\n                }\n            }\n        }\n    }\n    \n}\n\nint main()\n{\n    int w, h;\n    \n    while (scanf(\"%d %d\", &w, &h) && w){\n        char mp[64];\n        int c[64][64] = {0};\n        \n        queue<pair<int, int> > Bs, Ws;\n        \n        for (int i = 0; i < h; i++){\n            scanf(\"%s\", mp);\n            for (int j = 0; j < 64; j++){\n                if (isalpha(mp[j])){\n                    c[i][j] = -1;\n                    if (mp[j] == 'W') Ws.push(make_pair(i, j));\n                    else Bs.push(make_pair(i, j));\n                }\n            }\n        }\n        \n        bfs(c, Bs, w, h, 1);\n        bfs(c, Ws, w, h, 2);\n        \n        int black = 0, white = 0;\n        for (int i = 0; i < h; i++){\n            for (int j = 0; j < w; j++){\n                if (c[i][j] == 1) black++;\n                else if (c[i][j] == 2) white++;\n            }\n        }\n        \n        printf(\"%d %d\\n\", black, white);\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#define Black 1\n#define White 2\n#define Double 3\nusing namespace std;\n\nchar map[50][50];\nint acs[50][50]={0};\nint w,h;\nint dxy[8][2]={{1,0},{0,1},{-1,0},{0,-1},{1,1},{1,-1},{-1,1},{-1,-1}};\n\nvoid dfs(int y,int x,int type){\n  if(0<=y && y<h && 0<=x && x<w){\n    if(map[y][x]=='.' && (acs[y][x]&type)!=type){\n      acs[y][x]+=type;\n      for(int k=0;k<8;k++){\n\tdfs(y+dxy[1][k],x+dxy[0][k],type);\n      }\n    }\n  }\n}\n\nint main(){\n  while(cin>>w>>h,w){\n    memset(map,'.',sizeof(map));\n    memset(acs,0,sizeof(acs));\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin>>map[i][j];\n      }\n    }\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tif(map[i][j]=='B'){\n\t  acs[i][j]=Double;\n\t  for(int k=0;k<8;k++){\n\t    dfs(i+dxy[1][k],j+dxy[0][k],Black);\n\t  }\n\t}else if(map[i][j]=='W'){\n\t  acs[i][j]=Double;\n\t  for(int k=0;k<8;k++){\n\t    dfs(i+dxy[1][k],j+dxy[0][k],White);\n\t  }\n\t}\n      }\n    }\n    int black=0;\n    int white=0;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tif(acs[i][j]==Black){\n\t  black++;\n\t}else if(acs[i][j]==White){\n\t  white++;\n\t}\n      }\n    }\n    cout<<black<<\" \"<<white<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint w,h,c1,c2,b,d;\nchar a[51][51];\nint dfs(int i,int j){\n    if(i==h||j==w||i<0||j<0||a[i][j]=='#')return 0;\n    if(a[i][j]=='W'){d++;return 0;}\n    else if(a[i][j]=='B'){b++;return 0;}\n    int s=1;\n    a[i][j]='#';\n    s+=dfs(i+1,j);\n    s+=dfs(i-1,j);\n    s+=dfs(i,j+1);\n    s+=dfs(i,j-1);\n    return s;\n}\nint main(){\n    int i,j,ans;\n    while(cin>>w>>h,w!=0&&h!=0){\n        c1=c2=0;\n    for(i=0;i<h;i++)cin>>a[i];\n    for(i=0;i<h;i++)for(j=0;j<w;j++)if(a[i][j]=='.'){\n        d=0;b=0;\n        ans=dfs(i,j);\n        if(b>0&&d>0)continue;\n        else if(b>d)c1+=ans;\n        else if(b<d)c2+=ans;\n    }\n        cout<<c1<<\" \"<<c2<<endl;\n}}"
  },
  {
    "language": "C++",
    "code": "//17\n#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint w,h;\nchar g[50][51];\n\nint res(int y,int x){\n  if(y<0||h<=y||x<0||w<=x){\n    return 0;\n  }else if(g[y][x]=='.'){\n    g[y][x]='t';\n    int a=0;\n    for(int i=0;i<4;i++){\n      int d[]={0,1,0,-1,0};\n      a|=res(y+d[i],x+d[i+1]);\n    }\n    return a;\n  }else{\n    return g[y][x]=='B'|(g[y][x]=='W')<<1;\n  }\n}\n\nvoid ff(int y,int x,int v){\n  if(y<0||h<=y||x<0||w<=x){\n    return;\n  }else if(g[y][x]=='t'){\n    const char *w=\"nbwn\";\n    g[y][x]=w[v];\n    for(int i=0;i<4;i++){\n      int d[]={0,1,0,-1,0};\n      ff(y+d[i],x+d[i+1],v);\n    }\n  }  \n}\n\nint main(){\n  while(cin>>w>>h,w|h){\n    fill(g[0],g[50],0);\n    for(int y=0;y<h;y++){\n      cin>>g[y];\n    }\n    for(int y=0;y<h;y++){\n      for(int x=0;x<w;x++){\n\tff(y,x,res(y,x));\n      }\n    }\n    cout<<count(g[0],g[50],'b')<<' '<<count(g[0],g[50],'w')<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nint W, H; vector<string> M;\n\nconst vector<int> dx = { 0, 1, 0, -1 };\nconst vector<int> dy = { -1, 0, 1, 0 };\n\nint rec(int x, int y, vector<vector<bool> > ok)\n{\n\tif (M[y][x] == 'W')\n\t{\n\t\treturn 2;\n\t}\n\n\tif (M[y][x] == 'B')\n\t{\n\t\treturn 1;\n\t}\n\n\tint ret = 3;\n\n\tfor (int dir = 0; dir < 4; dir++)\n\t{\n\t\tint tx = x + dx[dir];\n\t\tint ty = y + dy[dir];\n\n\t\tif (0 <= tx && tx < W && 0 <= ty && ty < H && ok[ty][tx] == false)\n\t\t{\n\t\t\tvector<vector<bool> > ok2 = ok; ok2[ty][tx] = true;\n\n\t\t\tret = ret & rec(tx, ty, ok2);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tcin >> W >> H;\n\n\t\tif (W == 0 && H == 0) { break; }\n\n\t\tM = vector<string>(H);\n\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tcin >> M[i];\n\t\t}\n\n\t\tint b = 0, w = 0;\n\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tif (M[i][j] == '.')\n\t\t\t\t{\n\t\t\t\t\tint c = rec(j, i, vector<vector<bool> >(H, vector<bool>(W, false)));\n\n\t\t\t\t\tif (c == 1) { b++; }\n\t\t\t\t\tif (c == 2) { w++; }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << b << ' ' << w << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\nusing namespace std;\nint a[51][51],w,h,c;\nbool f;\n\nvoid visit(int i,int j,int bw){\n  a[i][j] = 3;\n  c++;\n  int di[4] = {1,0,-1,0};\n  int dj[4] = {0,1,0,-1};\n  for(int t=0;t<4;t++){\n    int vi = i + di[t];\n    int vj = j + dj[t];\n    if(bw == 1){\n      if(a[vi][vj] == 2){\n\tf = false;\n      }\n      else if(vi >= 0 && vj >= 0 && vi < w && vj < h && !a[vi][vj]){\n\tvisit(vi,vj,1);\n      }\n    }\n    else if(bw == 2){\n      if(a[vi][vj] == 1){\n\tf = false;\n      }\n      else if(vi >= 0 && vj >= 0 && vi < w && vj < h && !a[vi][vj]){\n\tvisit(vi,vj,2);\n      }\n    }\n  }\n}\n\nint main(){\n  int i,j,b,wh;\n  char str;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0) break;\n    for(i=0;i<=h;i++){\n      for(j=0;j<=w;j++){\n\tif(i == h || j == w) a[j][i] = 3;\n\telse{\n\t  cin >> str;\n\t  if(str == 'B') a[j][i] = 1;\n\t  else if(str == 'W') a[j][i] = 2;\n\t  else a[j][i] = 0;\n\t}\n      }\n    }\n\n    b = wh = 0;\n    int di[4] = {1,0,-1,0};\n    int dj[4] = {0,1,0,-1};\n    for(j=0;j<h;j++){\n      for(i=0;i<w;i++){\n\tif(a[i][j] == 1 || a[i][j] == 2){\n\t  for(int t=0;t<4;t++){\n\t    int vi = i + di[t];\n\t    int vj = j + dj[t];\n\t    if(a[i][j] == 1 && vi >= 0 && vj >= 0 && vi < w && vj < h && !a[vi][vj]){\n\t      c = 0;\n\t      f = true;\n\t      visit(vi,vj,1);\n\t      if(f) b += c;\n\t    }\n\t    else if(a[i][j] == 2 && vi >= 0 && vj >= 0 && vi < w && vj < h && !a[vi][vj]){\n\t      c = 0;\n\t      f = true;\n\t      visit(vi,vj,2);\n\t      if(f) wh += c;\n\t    }\n\t  }\n\t}\n      }\n    }\n    cout << b <<\" \" << wh << endl;   \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <iomanip>\n#include <complex>\nusing namespace std;\n\n#define ll long long\n#define vvi vector< vector<int> >\n#define vi vector<int>\n#define All(X) X.begin(),X.end()\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define pb push_back\n#define pii pair<int,int>\n#define mp make_pair\n#define pi 3.14159265359\n#define shosu(X) fixed << setprecision(X)\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){return a/gcd(a,b)*b;}\n\nint h,w;\nchar grid[51][51];\nbool iswhite[51][51];\nbool isblack[51][51];\nint dx[4] = {-1,0,1,0};\nint dy[4] = {0,-1,0,1};\n\nint dfs(int px, int py,char c){\n\tint res = 1;\n\tREP(i,4){\n\t\tint nx = px + dx[i]; \n\t\tint ny = py + dy[i];\n\t\tif(nx < 0 || ny <0 || nx > h-1 || ny > w-1) continue;\n\t\tif(grid[nx][ny] == c) return true;\n\t\telse return dfs(nx,ny);\n\t}\n\treturn false;\n}\nint main(){\n\twhile(1){\n\t\tcin >> w >> h;\n\t\tif(w==0&&h==0) break;\n\t\tREP(i,h) REP(j,w) cin >> grid[i][j];\n\t\tREP(i,h) REP(j,w) iswhite[i][j] = dfs(i,j,'W');\n\t\tREP(i,h) REP(j,w) isblack[i][j] = dfs(i,j,'B');\n\t\tint white = 0; int black = 0;\n\t\tREP(i,h) REP(j,w){\n\t\t\tif(iswhite[i][j] == true && isblack[i][j] == false) white++;\n\t\t\telse is(iswhite[i][j] == false && isblack[i][j] == true) black++;\n\t\t}\n\t\tcout << white << \" \" << black << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define loop(n, i) for(int i=0;i<n;i++)\n#define all(v) v.begin(),v.end()\n#define HERE cout << \"HERE: \" << __LINE__ << endl;\n#define INSP(v) cout << v << \" at \" << __LINE__ << endl;\n\nusing namespace std;\ntypedef long long ll;\n\nint f[50][50];\n\nint dfs(vector<vector<int>> &m, int h, int w, vector<vector<char>> as) {\n    if (h < 0 || w < 0 || h >= m.size() || w >= m[h].size()) {\n        return 0;\n    }\n    if (as[h][w] == 'B') return 1;\n    if (as[h][w] == 'W') return 2;\n    if (f[h][w]) return 0;\n    f[h][w] = 1;\n    int t=0;\n    t |= dfs(m, h-1, w, as);\n    t |= dfs(m, h+1, w, as);\n    t |= dfs(m, h, w+1, as);\n    t |= dfs(m, h, w-1, as);\n    return t;\n}\n\nint main()\n{\n    int w, h;\n    while (cin >> w >> h, w) {\n        loop(50,i) loop(50,j) f[i][j] = 0;\n        vector<vector<char>> as;\n        as.resize(h);\n        loop(h,i) {\n            string s;\n            cin >> s;\n            for (char c:s) as[i].push_back(c);\n        }\n        vector<vector<int>> mat(h, vector<int>(w,0));\n        dfs(mat,9,9,as);\n        loop(h,i){\n            loop(w,j){\n                if (as[i][j] == '.') {\n                    mat[i][j] = dfs(mat, i, j, as);\n                    loop(50,i) loop(50,j) f[i][j] = 0;\n                }\n            }\n        }\n\n        int ans_w = 0, ans_b = 0;\n        for(auto mm:mat) {\n            for (auto m:mm) {\n                if (m == 1) ans_b++;\n                if (m == 2) ans_w++;\n            }\n        }\n        cout << ans_b << ' ' << ans_w << endl;\n\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint dx[] = {1,0,-1,0};\nint dy[] = {0,1,0,-1};\n\nstruct lattice{\n  bool wallB,wallW,black,white;\n};\n\nstruct zahyou{\n  int x;\n  int y;\n};\n\nint main() {\n  vector<int> ans_B,ans_W;\n  while(1){\n    int w,h;\n    char a;\n    cin >> w >> h;\n    if(!w && !h)break;\n    vector<vector<lattice> > v(h+2);\n    for(int i = 1;i <= h;i++){\n      vector<lattice> q(w+2);\n      lattice l;\n      l.wallB = 0;\n      l.wallW = 0;\n      l.black = 0;\n      l.white = 0;\n      q[0] = l;\n      q[h+1] = l;\n      for(int j = 1;j <= w;j++){\n        cin >> a;\n        l.wallB = 0;\n        l.wallW = 0;\n        l.black = 0;\n        l.white = 0;\n        if(a == 'W')l.wallW = 1;\n        if(a == 'B')l.wallB = 1;\n        q[j] = l;\n      }\n      v[i] = q;\n    }\n\n\n\n    for(int j = 0;j <= w+1;j++){\n      lattice l;\n      l.wallB = 0;\n      l.wallW = 0;\n      l.black = 0;\n      l.white = 0;\n      v[0].push_back(l);\n      v[h+1].push_back(l);\n    }\n    \n    for(int i = 1;i <= h;i++){\n      for(int j = 1;j <= w;j++){\n        if(v[i][j].wallW){\n          queue<zahyou> que;\n          zahyou z;\n          z.x = i;\n          z.y = j;\n          que.push(z);\n          while(que.size()){\n            cout << que.size() << endl;\n            for(int k = 0;k < 4;k++){\n              if(1 <= que.front().x && que.front().x <= h && 1 <= que.front().y && que.front().y <= w){\n                if(!v[que.front().x + dx[k]][que.front().y + dy[k]].white && !v[que.front().x + dx[k]][que.front().y + dy[k]].wallB && !v[que.front().x + dx[k]][que.front().y + dy[k]].wallW){\n                  z.x = que.front().x + dx[k];\n                  z.y = que.front().y + dy[k];\n                  que.push(z);\n                  v[que.front().x + dx[k]][que.front().y + dy[k]].white = 1;\n                }\n              }\n            }\n            que.pop();\n          }\n        }\n        if(v[i][j].wallB){\n          queue<zahyou> que;\n          zahyou z;\n          z.x = i;\n          z.y = j;\n          que.push(z);\n          while(que.size()){\n            cout << que.size() << endl;\n            for(int k = 0;k < 4;k++){\n              if(1 <= que.front().x && que.front().x <= h && 1 <= que.front().y && que.front().y <= w){\n                if(!v[que.front().x + dx[k]][que.front().y + dy[k]].black && !v[que.front().x + dx[k]][que.front().y + dy[k]].wallB && !v[que.front().x + dx[k]][que.front().y + dy[k]].wallW){\n                  z.x = que.front().x + dx[k];\n                  z.y = que.front().y + dy[k];\n                  que.push(z);\n                  v[que.front().x + dx[k]][que.front().y + dy[k]].black = 1;\n                }\n              }\n            }\n            que.pop();\n          }\n        }\n      }\n    }\n    int countB=0,countW=0;\n    for(int i = 1;i <= h;i++){\n      for(int j = 1;j <= w;j++){\n        if(v[i][j].black && v[i][j].white){}\n        else if(v[i][j].black && !v[i][j].wallB && !v[i][j].wallW){\n          countB++;\n        }\n        else if(v[i][j].white && !v[i][j].wallB && !v[i][j].wallW){\n          countW++;\n        }\n      }\n    }\n    ans_B.push_back(countB);\n    ans_W.push_back(countW);\n  }\n  for(int i = 0;i < ans_B.size();i++)cout << ans_B[i] << \" \" << ans_W[i] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int WWW = 0;WWW < (n);WWW++)cerr << v[WWW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\nchar mp[55][55];\nint n,m,bb,ww;\nint dx[] = {1,0,-1,0};\nint dy[] = {0,1,0,-1};\nvoid hoge(int h,int w){\n\tqueue<pair<int,int>> q;\n\tbool isb = false,isw = false;\n\tq.push(MP(h,w));\n\tint ret = 0;\n\twhile(!q.empty()){\n\t\tauto now = q.front();q.pop();\n\t\tmp[now.FI][now.SE] = '#';\n\t\tret++;\n\t\tREP(i,4){\n\t\t\tint yy = now.FI + dy[i];\n\t\t\tint xx = now.SE + dx[i];\n\t\t\tif(xx < 0 || yy < 0 || xx >= m|| yy >= n)continue;\n\t\t\tif(mp[yy][xx] == '.')q.push(MP(yy,xx));\n\t\t\tif(mp[yy][xx] == 'B')isb = true;\n\t\t\tif(mp[yy][xx] == 'W')isw = true;\n\t\t}\n\t}\n\tif((isb & isw) || !(isb | isw))return;\n\tif(isb)bb += ret;\n\telse ww += ret;\n}\n\t\t\t\n\nint main(){\n\twhile(cin >> n >> m,n|m){\n\t\tbb = 0,ww = 0;\n\t\tREP(i,n)REP(j,m)cin >> mp[i][j];\n\t\tREP(i,n)REP(j,m){\n\t\t\tif(mp[i][j] == '.')hoge(i,j);\n\t\t}\n\t\tcout << bb << ' ' << ww << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vbb;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n\n#define loop(i,a,b) for(int i=(a);i<ull(b);++i)\n#define rep(i,n) loop(i,0,n)\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst double inf = (int)1e8;\n\nint w, h;\nstring field[50];\n\nbool isIn(int x, int y){\n     return 0 <= x && x < h && 0 <= y && y < w;\n}\n\nint check(int x, int y){\n    bool used[50][50];\n    for(int i=0; i < w; i++) for(int j=0; j< h; j++) used[i][j] = false;\n    used[x][y] = true;\n    int result = 0;\n    int dx[4] = {1, 0, -1, 0};\n    int dy[4] = {0, 1, 0, -1};\n\n    queue<pair<int, int> > q;\n    q.push(make_pair(x, y));\n    while(!q.empty()){\n        pair<int, int> p = q.front(); q.pop();\n        for(int i=0; i< 4; i++){\n            int nx = p.first+dx[i], ny = p.second+dy[i];\n            if(!isIn(nx, ny) || used[nx][ny]) continue;\n            if(field[nx][ny] != '.'){\n                if(result == 0){\n                    if(field[nx][ny] == 'W') result = 1;\n                    else result = 2;\n                }\n                else {\n                    if(result == 2 && field[nx][ny] == 'W') return -1;\n                    else if(result == 1 && field[nx][ny] == 'B') return -1;\n                }\n            } else {\n                used[nx][ny] = true;\n                q.push(make_pair(nx, ny));\n            }\n        }\n    }\n    return result;\n}\n\nint main(){\n    while(cin >> w >> h, w+h){\n        for(int i=0; i< h; i++) cin >> field[i];\n\n        int a = 0, b = 0;\n        for(int i=0; i < h; i++){\n            for(int j=0; j < w; j++){\n                if(field[i][j] == '.'){\n                    int r = check(i, j);\n                    if(r == 1) a++;\n                    else if(r == 2) b++;\n                }\n            }\n        }\n        cout << b << \" \" << a << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n#include <cctype>\n#define REP(i,n) for(int i=0;i<(n);i++)\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nint main()\n{\n  while(1){\n    int w, h;\n    cin >> w >> h;\n    if(w == 0 && h == 0) break;\n    char map[h][w];\n    REP(i,h){\n      REP(j,w){\n        cin >> map[i][j];\n      }\n    }\n    queue<pii> a;\n    REP(i,h){\n      REP(j,w){\n        if(map[i][j] == 'B' || map[i][j] == 'W'){\n          if(i > 0){\n            if(map[i-1][j] == '.'){\n              map[i-1][j] = tolower(map[i][j]);\n              a.push(pii(i-1,j));\n            }else if(map[i-1][j] != 'W' && map[i-1][j] != 'B' && map[i-1][j] != 'x' && map[i-1][j] != tolower(map[i][j])){\n              map[i-1][j] = 'x';\n              a.push(pii(i-1,j));\n            }\n          }\n          if(i < h - 1){\n            if(map[i+1][j] == '.'){\n              map[i+1][j] = tolower(map[i][j]);\n              a.push(pii(i+1,j));\n            }else if(map[i+1][j] != 'W' && map[i+1][j] != 'B' && map[i+1][j] != 'x' && map[i+1][j] != tolower(map[i][j])){\n              map[i+1][j] = 'x';\n              a.push(pii(i+1,j));\n            }\n          }\n          if(j > 0){\n            if(map[i][j-1] == '.'){\n              map[i][j-1] = tolower(map[i][j]);\n              a.push(pii(i,j-1));\n            }else if(map[i][j-1] != 'W' && map[i][j-1] != 'B' && map[i][j-1] != 'x' && map[i][j-1] != tolower(map[i][j])){\n              map[i][j-1] = 'x';\n              a.push(pii(i,j-1));\n            }\n          }\n          if(j < w - 1){\n            if(map[i][j+1] == '.'){\n              map[i][j+1] = tolower(map[i][j]);\n              a.push(pii(i,j+1));\n            }else if(map[i][j+1] != 'W' && map[i][j+1] != 'B' && map[i][j+1] != 'x' && map[i][j+1] != tolower(map[i][j])){\n              map[i][j+1] = 'x';\n              a.push(pii(i,j+1));\n            }\n          }\n        }\n      }\n    }\n    while(!a.empty()){\n      int x, y;\n      x = a.front().first;\n      y = a.front().second;\n      a.pop();\n      if(x > 0){\n        if(map[x][y] == 'b'){\n          if(map[x-1][y] == 'w' || map[x-1][y] == 'x'){\n            map[x-1][y] = 'x';\n            a.push(pii(x-1,y));\n          }else if(map[x-1][y] == '.'){\n            map[x-1][y] = 'b';\n            a.push(pii(x-1,y));\n          }\n        }else if(map[x][y] == 'w'){\n          if(map[x-1][y] == 'b' || map[x-1][y] == 'x'){\n            map[x-1][y] = 'x';\n            a.push(pii(x-1,y));\n          }else if(map[x-1][y] == '.'){\n            map[x-1][y] = 'w';\n            a.push(pii(x-1,y));\n          }\n        }else{\n          if(map[x-1][y] != 'B' && map[x-1][y] != 'W' && map[x-1][y] != 'x'){\n            map[x-1][y] = 'x';\n            a.push(pii(x-1,y));\n          }\n        }\n      }\n      if(x < h - 1){\n        if(map[x][y] == 'b'){\n          if(map[x+1][y] == 'w' || map[x+1][y] == 'x'){\n            map[x+1][y] = 'x';\n            a.push(pii(x+1,y));\n          }else if(map[x+1][y] == '.'){\n            map[x+1][y] = 'b';\n            a.push(pii(x+1,y));\n          }\n        }else if(map[x][y] == 'w'){\n          if(map[x+1][y] == 'b' || map[x+1][y] == 'x'){\n            map[x*1][y] = 'x';\n            a.push(pii(x+1,y));\n          }else if(map[x+1][y] == '.'){\n            map[x+1][y] = 'w';\n            a.push(pii(x+1,y));\n          }\n        }else{\n          if(map[x+1][y] != 'B' && map[x+1][y] != 'W' && map[x+1][y] != 'x'){\n            map[x+1][y] = 'x';\n            a.push(pii(x+1,y));\n          }\n        }\n      }\n      if(y > 0){\n        if(map[x][y] == 'b'){\n          if(map[x][y-1] == 'w' || map[x][y-1] == 'x'){\n            map[x][y-1] = 'x';\n            a.push(pii(x,y-1));\n          }else if(map[x][y-1] == '.'){\n            map[x][y-1] = 'b';\n            a.push(pii(x,y-1));\n          }\n        }else if(map[x][y] == 'w'){\n          if(map[x][y-1] == 'b' || map[x][y-1] == 'x'){\n            map[x][y-1] = 'x';\n            a.push(pii(x,y-1));\n          }else if(map[x][y-1] == '.'){\n            map[x][y-1] = 'w';\n            a.push(pii(x,y-1));\n          }\n        }else{\n          if(map[x][y-1] != 'B' && map[x][y-1] != 'W' && map[x][y-1] != 'x'){\n            map[x][y-1] = 'x';\n            a.push(pii(x,y-1));\n          }\n        }\n      }\n      if(y < w - 1){\n        if(map[x][y] == 'b'){\n          if(map[x][y+1] == 'w' || map[x][y+1] == 'x'){\n            map[x][y+1] = 'x';\n            a.push(pii(x,y+1));\n          }else if(map[x][y+1] == '.'){\n            map[x][y+1] = 'b';\n            a.push(pii(x,y+1));\n          }\n        }else if(map[x][y] == 'w'){\n          if(map[x][y+1] == 'b' || map[x][y+1] == 'x'){\n            map[x][y+1] = 'x';\n            a.push(pii(x,y+1));\n          }else if(map[x][y+1] == '.'){\n            map[x][y+1] = 'w';\n            a.push(pii(x,y+1));\n          }\n        }else{\n          if(map[x][y+1] != 'B' && map[x][y+1] != 'W' && map[x][y+1] != 'x'){\n            map[x][y+1] = 'x';\n            a.push(pii(x,y+1));\n          }\n        }\n      }\n    }\n    pii ans;\n    ans.first = ans.second = 0;\n    REP(i,h){\n      REP(j,w){\n        if(map[i][j] == 'b')\n          ans.first++;\n        else if(map[i][j] == 'w')\n          ans.second++;\n      }\n    }\n    cout << ans.first << \" \" << ans.second << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<cstring>\nusing namespace std;\nint h, w, x[100][100], y[100][100], z[100][100], p, q, BL, WH; char a;\nqueue<int>Q;\n\nvoid A(int B, int C, int P) { \n\tif (x[B][C] == 3 && z[B][C] == 0) { \n\t\tQ.push(B * 100 + C); z[B][C] = 1; \n\t\tif ((P == 1 && y[B][C] % 2 == 0) || (P == 2 && y[B][C] < 2)) { \n\t\t\ty[B][C] += P; \n\t\t} \n\t} \n}\n\nint main() {\n\twhile (true) {\n\t\tBL = 0; WH = 0;\n\t\tcin >> w >> h; if (!w) { break; }\n\t\tfor (int i = 0; i < 10000; i++) { x[i / 100][i % 100] = 4; }\n\t\tfor (int i = 1; i <= h; i++) {\n\t\t\tfor (int j = 1; j <= w; j++) {\n\t\t\t\tcin >> a;\n\t\t\t\tif (a == '.') { x[i][j] = 3; }\n\t\t\t\tif (a == 'B') { x[i][j] = 1; }\n\t\t\t\tif (a == 'W') { x[i][j] = 2; }\n\t\t\t}\n\t\t}\n\t\t//BFS.(BLUE=1,WHITE=2)\n\t\tmemset(y, 0, sizeof(y));\n\t\tfor (int i = 1; i <= h; i++) {\n\t\t\tfor (int j = 1; j <= w; j++) {\n\t\t\t\tif (x[i][j] == 1) {\n\t\t\t\t\tmemset(z, 0, sizeof(z));\n\t\t\t\t\tz[i][j] = 1;\n\t\t\t\t\tQ.push(i * 100 + j);\n\t\t\t\t\twhile (!Q.empty()) {\n\t\t\t\t\t\tp = Q.front() / 100;\n\t\t\t\t\t\tq = Q.front() % 100;\n\t\t\t\t\t\tA(p - 1, q, 1);\n\t\t\t\t\t\tA(p + 1, q, 1);\n\t\t\t\t\t\tA(p, q - 1, 1);\n\t\t\t\t\t\tA(p, q + 1, 1);\n\t\t\t\t\t\tQ.pop();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (x[i][j] == 2) {\n\t\t\t\t\tmemset(z, 0, sizeof(z));\n\t\t\t\t\tQ.push(i * 100 + j);\n\t\t\t\t\tz[i][j] = 1;\n\t\t\t\t\twhile (!Q.empty()) {\n\t\t\t\t\t\tp = Q.front() / 100;\n\t\t\t\t\t\tq = Q.front() % 100;\n\t\t\t\t\t\tA(p - 1, q, 2);\n\t\t\t\t\t\tA(p + 1, q, 2);\n\t\t\t\t\t\tA(p, q - 1, 2);\n\t\t\t\t\t\tA(p, q + 1, 2);\n\t\t\t\t\t\tQ.pop();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= h; i++) {\n\t\t\tfor (int j = 1; j <= w; j++) {\n\t\t\t\tif (y[i][j] == 1) { BL++; }\n\t\t\t\tif (y[i][j] == 2) { WH++; }\n\t\t\t}\n\t\t}\n\t\tcout << BL << ' ' << WH << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nint w,h;\nstring grid[55],col[55];\nbool vis[55][55];\nint dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\n\nint count(char color){\n  int res = 0;\n  rep(i,h)rep(j,w)if(col[i][j]==color)res++;\n  return res;\n}\n\nvoid rec(int y,int x,int color){\n  if(vis[y][x])return;\n  vis[y][x] = true;\n\n  if(grid[y][x]=='.'){\n    if(col[y][x] == '.' || col[y][x] == color)col[y][x] = color;\n    else col[y][x] = 'G';\n  }\n    \n  rep(d,4){\n    int ny = y+dy[d], nx = x+dx[d];\n    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n    if(grid[ny][nx]!='.')continue;\n    rec(ny,nx,color);\n  }\n}\n\nint main(){\n  while(cin >> w >> h, w){\n    rep(i,h){\n      cin >> grid[i];\n      col[i] = \"\";\n      rep(j,w)col[i] += '.';\n    }\n    \n    rep(i,h){\n      rep(j,w){\n\tif(grid[i][j]!='.'){\n\t  memset(vis,0,sizeof(vis));\n\t  rec(i,j,grid[i][j]);\n\t}\n      }\n    }\n   \n    cout << count('B') << \" \" << count('W') << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;++i)\n#define rep1(i,n) for(int i=1;i<=n;++i)\nusing namespace std;\nint a[52][52];\nint dx[4]={0,0,-1,1};\nint dy[4]={-1,1,0,0};\nint cnt[4];\n/* ??????.->0 ?????????\\B,W,B&W->1,2,3 ???B,W->10,20 ??->30 */\n\nvoid paint(int y,int x,int color){\n    if(a[y][x]>=3 || a[y][x]==color)return;\n    cnt[a[y][x]]--;\n    a[y][x] += color;\n    cnt[a[y][x]]++;\n    rep(i,4)paint(y+dy[i],x+dx[i],a[y][x]);\n}\n\nint main(void){\n    int h,w;\n    char c;\n    while(cin>>w>>h, w|h){\n        rep(i,4)cnt[i]=0;\n        rep1(y,h){\n            rep1(x,w){\n                cin>>c;\n                if(c=='.')a[y][x] = 0;\n                else a[y][x] = (c=='B' ? 10 : 20);\n            }\n        }\n        rep(y,h+2)a[y][0]=a[y][w+1] = 30;\n        rep(x,w+2)a[0][x]=a[h+1][x] = 30;\n\n        rep1(y,h)rep1(x,w)if(a[y][x]>=10)rep(i,4)paint(y+dy[i],x+dx[i],a[y][x]/10);\n\n        cout<<cnt[1]<<\" \"<<cnt[2]<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\nint di[] = {0, -1, 0, 1};\nint dj[] = {-1, 0, 1, 0};\n\nint main() {\n\tfor (;;) {\n\t\tint w, h; cin >> w >> h;\n\t\tif (w == 0) break;\n\t\tvector<string> a(h);\n\t\tfor (int i = 0; i < h; i++) cin >> a[i];\n\t\tvector< vector<bool> > b(h, vector<bool>(w)), c(h, vector<bool>(w));\n\t\tfor (int t = 0; t < h * w; t++)\n\t\t\tfor (int i = 0; i < h; i++)\n\t\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\t\tif (a[i][j] == '.')\n\t\t\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\t\t\tint _i = i + di[k], _j = j + dj[k];\n\t\t\t\t\t\t\tif (_i >= 0 && _i < h && _j >= 0 && _j < w) {\n\t\t\t\t\t\t\t\tif (a[_i][_j] == 'B' || b[_i][_j]) b[i][j] = true;\n\t\t\t\t\t\t\t\tif (a[_i][_j] == 'W' || c[_i][_j]) c[i][j] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\tint cnt1 = 0, cnt2 = 0;\n\t\tfor (int i = 0; i < h; i++)\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (b[i][j] && !c[i][j]) cnt1++;\n\t\t\t\tif (!b[i][j] && c[i][j]) cnt2++;\n\t\t\t}\n\t\tcout << cnt1 << ' ' << cnt2 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<string>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nconst ll mod=1e9+7;\nint vx[]={-1,0,1,0},vy[]={0,-1,0,1};\nint main(){\n  vector<P> ans;\n  while(1){\n    int h,w;\n    cin>>h>>w;\n    swap(h,w);\n    if(h==0&&w==0) break;\n    int grid[55][55]={0};\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        char a;\n        cin>>a;\n        if(a=='W') grid[i][j]=1;\n        else if(a=='B') grid[i][j]=2;\n      }\n    }\n    int bcnt=0,wcnt=0;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        if(grid[i][j]==0){\n          bool used[55][55];\n          for(int k=0;k<55;k++){\n            for(int l=0;l<55;l++) used[k][l]=false;\n          }\n          bool black=false,white=false;\n          queue<P> que;\n          que.push(P(i,j));\n          used[i][j]=true;\n          while(!que.empty()){\n            P pos=que.front();\n            que.pop();\n            int x=pos.first,y=pos.second;\n            for(int k=0;k<4;k++){\n              int nx=x+vx[k],ny=y+vy[k];\n              if(0<=nx&&nx<h&&0<=ny&&ny<w){\n                if(!used[nx][ny]){\n                  used[nx][ny]=true;\n                  if(grid[nx][ny]==1) white=true;\n                  else if(grid[nx][ny]==2) black=true;\n                  else que.push(P(nx,ny));\n                }\n              }\n            }\n          }\n          if(black) if(!white) bcnt++;\n          if(white) if(!black) wcnt++;\n          int c=0;\n          if(black) c++;\n          if(white) c+=2;\n          //cout<<c;\n        }\n        //else cout<<4;\n      }\n      //cout<<endl;\n    }\n    ans.push_back(P(bcnt,wcnt));\n  }\n  for(int i=0;i<ans.size();i++){\n    cout<<ans[i].first<<\" \"<<ans[i].second<<endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<string>\nusing namespace std;\nint main(){\n\nint W,H;\nwhile(1){\n\tcin>>W>>H;if(W==0&&H==0)break;\n\tint n[53][53]={};int c=0;\n\tstring str;\n\tfor(int i=1;i<H+1;i++){\n\t\tcin>>str;\n\t\tc++;\n\t\tfor(int j=1;j<W+1;j++)\n\t\t{\n\t\t\t\n\t\t\tif(str[j-1]=='.'){n[i][j]=c;}\n\t\t\tif(str[j-1]=='W'){n[i][j]=7001;c++;}\n\t\tif(str[j-1]=='B'){n[i][j]=7002;c++;}\n\t\t}\n\t}\n\n\t\n\n\tfor(int i=1;i<=H;i++)\n\t\tfor(int j=1;j<=W;j++)\n\t\t{if(n[i][j]<7000){int g[]={n[i-1][j],n[i+1][j],n[i][j-1],n[i][j+1]};\n\tint Q=n[i][j];\n\tif(n[i-1][j]>0&&n[i-1][j]<Q)Q=n[i-1][j];\n\tif(n[i+1][j]>0&&n[i+1][j]<Q)Q=n[i+1][j];\n\tif(n[i][j-1]>0&&n[i][j-1]<Q)Q=n[i][j-1];\n\tif(n[i][j+1]>0&&n[i][j+1]<Q)Q=n[i][j+1];\n\tfor(int I=1;I<=H;I++)\n\t\tfor(int J=1;J<=W;J++)\n\t\t\tfor(int K=0;K<=4;K++)\n\t\t\t\tif(n[I][J]==g[K]&&g[K]<7000)n[I][J]=Q;}\n\t}\n\n\n\tint map[7000]={};\n\tfor(int i=1;i<=H;i++)\n\t\tfor(int j=1;j<=W;j++)\n\t\t\t{if(n[i][j]==7001){\n\t\t\t\tint G[]={n[i-1][j],n[i+1][j],n[i][j-1],n[i][j+1]};\n\t\t\t\tfor(int k=0;k<4;k++)\n\t\t\t\t\tif(map[G[k]]==0||map[G[k]]==2)map[G[k]]+=1;\n\t\t\t\t}\n\n\t\t\tif(n[i][j]==7002){\n\t\t\t\tint G[]={n[i-1][j],n[i+1][j],n[i][j-1],n[i][j+1]};\n\t\t\t\tfor(int k=0;k<4;k++)\n\t\t\t\t\tif(map[G[k]]==0||map[G[k]]==1)map[G[k]]+=2;\n\t\t\t}}\n\t\tint cnt[5540]={};\n\t\tfor(int i=1;i<=H;i++)\n\t\tfor(int j=1;j<=W;j++)\n\t\t\tcnt[n[i][j]]++;\n\n\t\t\tint J=0,JJ=0;\n\t\tfor(int i=1;i<W*H*2;i++)\n\t\t{if(map[i]==1)JJ+=cnt[i];else if(map[i]==2)J+=cnt[i];}\n\t\t\n\t\t\n\n\t\tcout<<J<<\" \"<<JJ<<endl;\n}\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\n#define X first\n#define Y second\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nint w, h;\nvs m;\nint dx[] = {-1, 0, 1, 0};\nint dy[] = { 0,-1, 0, 1};\n\nvoid dfs(char tar, pii p);\n\nint main(void){\n    for(; cin >> w >> h, w;){\n        m = vs(h);\n        rep(y, h) cin >> m[y];\n\n        rep(y, h) rep(x, w) if(m[y][x] == 'B'){\n            rep(i, 4){\n                dfs('B', mp(x + dx[i], y + dy[i]));\n            }\n        }\n        rep(y, h) rep(x, w) if(m[y][x] == 'W'){\n            rep(i, 4){\n                dfs('W', mp(x + dx[i], y + dy[i]));\n            }\n        }\n\n        pii sum = mp(0, 0);\n        rep(y, h) sum.first += count(all(m[y]), 'b');\n        rep(y, h) sum.second += count(all(m[y]), 'w');\n\n        cout << sum.first << \" \" << sum.second << endl;\n    }\n\n\treturn 0;\n}\n\nvoid dfs(char tar, pii p){\n    if(p.X < 0 || w <= p.X ||\n       p.Y < 0 || h <= p.Y) return;\n\n    char ene = tar == 'B' ? 'W':'B';\n    char extar = tar == 'B' ? 'b':'w';\n    char exene = tar == 'B' ? 'w':'b';\n\n    if(m[p.Y][p.X] == ene || m[p.Y][p.X] == extar || m[p.Y][p.X] == '-' ||\n       m[p.Y][p.X] == tar)\n        return;\n\n    if(m[p.Y][p.X] == '.') m[p.Y][p.X] = extar;\n    if(m[p.Y][p.X] == exene) m[p.Y][p.X] = '-';\n\n    rep(i, 4){\n        dfs(tar, mp(p.X + dx[i], p.Y + dy[i]));\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <stdlib.h>\n#include <stdio.h>\n#include <bitset>\n#include <cstring>\nusing namespace std;\n#define FOR(I,A,B) for(int I = (A); I < (B); ++I)\n#define CLR(mat) memset(mat, 0, sizeof(mat))\ntypedef long long ll;\nint w, h;\nvoid dfs(int y, int x, char c, vector<string> &vs) {\n  if(y < 0 || y >= h || x < 0 || x >= w) return;\n  if(vs[y][x] == 'W' || vs[y][x] == 'B') return;\n  if(vs[y][x] == c || vs[y][x] == '3') return;\n  if(vs[y][x] == '.') vs[y][x] = c;\n  else if(vs[y][x] != c) vs[y][x] = '3';\n  dfs(y+1,x,c,vs);\n  dfs(y-1,x,c,vs);\n  dfs(y,x+1,c,vs);\n  dfs(y,x-1,c,vs);\n}\nint main()\n{\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  while(cin>>w>>h,w||h) {\n    vector<string> vs(h);\n    FOR(i,0,h) cin >> vs[i];\n    FOR(y,0,h) {\n      FOR(x,0,w) {\n        if(vs[y][x] == 'W' || vs[y][x] == 'B') {\n          dfs(y + 1, x, vs[y][x] == 'B' ? '1' : '2', vs);\n          dfs(y - 1, x, vs[y][x] == 'B' ? '1' : '2', vs);\n          dfs(y, x + 1, vs[y][x] == 'B' ? '1' : '2', vs);\n          dfs(y, x - 1, vs[y][x] == 'B' ? '1' : '2', vs);\n        }\n      }\n    }\n    int ans[2]; CLR(ans);\n    FOR(y,0,h) {\n      FOR(x,0,w) {\n        if(vs[y][x] == '1') ans[0]++;\n        if(vs[y][x] == '2') ans[1]++;\n      }\n    }\n    cout << ans[0] << \" \" << ans[1] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAX_H=51,MAX_W=51;\nconst int dh[4]={1,0,-1,0};\nconst int dw[4]={0,1,0,-1};\n\nint w,h,cnt,surrounded,x,y,nh,nw,ansb,answ;\nvector<string> a(MAX_H);\nvector<vector<int>> visited(MAX_H,vector<int>(MAX_W));\nqueue<pair<int,int>> que;\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while (cin >> w >> h,w){\n        for (int i=0;i<h;++i) cin >> a[i];\n        for (int i=0;i<h;++i)\n            for (int j=0;j<w;++j)\n                visited[i][j]=0;\n        ansb=answ=0;\n        for (int i=0;i<h;++i){\n            for (int j=0;j<w;++j){\n                if (a[i][j]!='.') continue;\n                if (visited[i][j]) continue;\n                cnt=0,surrounded=0;\n                visited[i][j]=1;\n                que.emplace(i,j);\n                while(!que.empty()){\n                    ++cnt;\n                    auto p=que.front(); que.pop();\n                    x=p.first,y=p.second;\n                    for (int k=0;k<4;++k){\n                        nh=x+dh[k],nw=y+dw[k];\n                        if (nh<0||h<=nh||nw<0||w<=nw) continue;\n                        if (visited[nh][nw]) continue;\n                        if (a[nh][nw]=='B'){surrounded|=1; continue;}\n                        if (a[nh][nw]=='W'){surrounded|=2; continue;}\n                        visited[nh][nw]=1;\n                        que.emplace(nh,nw);\n                    }\n                }\n                if (surrounded==1) ansb+=cnt;\n                if (surrounded==2) answ+=cnt;\n            }\n        }\n        cout << ansb << ' ' << answ << '\\n';\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <cstring>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ntypedef vector<pair<int,int> >vpii;\nchar m[99][99];\n\nchar dfs(int i, int j, vpii&v){\n\tif(m[i][j]=='B')return 1;\n\tif(m[i][j]=='W')return 2;\n\tif(m[i][j]=='X')return 0;\n\tint ret=0;\n\tv.push_back(make_pair(i,j));\n\tif(find(v.begin(),v.end(),make_pair(i-1,j))==v.end())ret|=dfs(i-1,j,v);\n\tif(find(v.begin(),v.end(),make_pair(i+1,j))==v.end())ret|=dfs(i+1,j,v);\n\tif(find(v.begin(),v.end(),make_pair(i,j-1))==v.end())ret|=dfs(i,j-1,v);\n\tif(find(v.begin(),v.end(),make_pair(i,j+1))==v.end())ret|=dfs(i,j+1,v);\n\treturn ret;\n}\n\nmain(){\n\tint w,h,i,j,k,r,s;\n\tfor(;scanf(\"%d%d\",&w,&h),w;printf(\"%d %d\\n\",r,s)){\n\t\tr=s=0;\n\t\tmemset(m,'X',sizeof(m)); //Iron Puyo\n\t\tfor(i=1;i<=h;i++)scanf(\"%s\",m[i]+1),m[i][w+1]='X',m[i][w+2]=0;\n\t\tfor(i=1;i<=h;i++)\n\t\t\tfor(j=1;j<=w;j++)\n\t\t\t\tif(m[i][j]=='.'){\n\t\t\t\t\tvpii v;\n\t\t\t\t\tchar x=dfs(i,j,v);\n\t\t\t\t\tfor(k=0;k<v.size();k++)\n\t\t\t\t\tm[v[k].first][v[k].second]=x;\n\t\t\t\t}\n\t\tfor(i=1;i<=h;i++)\n\t\t\tfor(j=1;j<=w;j++)\n\t\t\t\tif(m[i][j]==1)r++;\n\t\t\t\telse if(m[i][j]==2)s++;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing ld=long double;\n\n#define rep(i,N) for(int i=0;i<(int)(N);++i)\n#define rrep(i,N) for(int i=(int)(N)-1;i>=0;--i)\n#define debug(x) cout<<#x<<\"=\"<<x<<endl;\nconstexpr int MOD=1000000007;\nconstexpr ll INF=(1LL<<61)-1;\ntemplate<class T> inline bool chmin(T& a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<class T> inline bool chmax(T& a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T> void fail(T v){cout << v << endl;exit(0);}\n//template end\nbool inside(int h,int w,int H,int W){return 0<=h&&h<H&&0<=w&&w<W;}\nvoid solve(){\n    int W,H;\n    int dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n    while((cin>>W>>H,H|W)){\n        bool use[H][W];\n        vector<string> S(H);\n        rep(i,H)cin>>S[i];\n        rep(i,H)rep(j,W)use[i][j]=0;\n        queue<int> Q;\n        int rw=0,rb=0;\n        rep(i,H)rep(j,W)if(!use[i][j]&&S[i][j]=='.'){\n            int ct=0,wh=0,bl=0;\n            use[i][j]=1;\n            Q.push(i*100+j);\n            while(Q.size()){\n                int p=Q.front();Q.pop();ct++;\n                int h=p/100,w=p%100;\n                rep(k,4){\n                    int y=h+dy[k],x=w+dx[k];\n                    if(!inside(y,x,H,W)||use[y][x])continue;\n                    if(S[y][x]=='W')wh=1;\n                    else if(S[y][x]=='B')bl=1;\n                    else {Q.push(y*100+x);use[y][x]=1;}\n                }\n            }\n            if(wh&&!bl)rw+=ct;\n            if(!wh&&bl)rb+=ct;\n        }\n        cout<<rb<<\" \"<<rw<<endl;\n    }\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n    solve();\n    return 0;\n}   \n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<n;++i)\n#define FOR(i,a,b) for(int i=a;i<b;++i)\nchar c[60][60];\nint a[60][60];\nint flag, w, h;\n\nvoid dfs(int y,int x){\n  if(c[y][x] == 'B'){\n    if(flag == 0 || flag == 1) flag = 1;\n    else flag = 3;    \n    a[y][x] = 9;\n  }else if(c[y][x] == 'W'){\n    if(flag == 0 || flag == 2) flag = 2;\n    else flag = 3;\n    a[y][x] = 9;\n  }else if(a[y][x]==0){\n    a[y][x] = 4;\n    FOR(i,y-1,y+2) if(i>=0 && i<h) dfs(i,x);\n    FOR(j,x-1,x+2) if(j>=0 && j<w) dfs(y,j);\n  }\n}\nint main(){\n  int bl, wh;\n  while(cin>>w>>h, w){\n    bl = 0; wh = 0;\n    REP(i, h) REP(j, w){\n      cin>>c[i][j];\n      a[i][j]=0;\n    }\n    \n    REP(i, h) REP(j, w){\n      if(c[i][j] == 'B' || c[i][j] == 'W' || a[i][j]) continue;\n      flag = 0;\n      dfs(i,j);\n      \n      if(flag) REP(k,h) REP(l,w){\n          if(a[k][l] == 4) a[k][l] = flag;\n        }\n    }\n    REP(i,h) REP(j,w){\n      if(a[i][j] == 1) bl++;\n      if(a[i][j] == 2) wh++;\n    }\n    cout<<bl<<\" \"<<wh<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#ifdef __GNUC__\n#include <bits/stdc++.h>\n#else\n#define _CRT_SECURE_NO_WARNINGS\n#include <__msvc_all_public_headers.hpp>\n#undef min\n#undef max\n#endif\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define FOR(i, m, n) for (int i = (m); i < (n); ++i)\n#define rrep(i, n) for (int i = (n) - 1; i >= 0; --i)\n#define rfor(i, m, n) for (int i = (m); i >= (n); --i)\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n#define range_it(a, l, r) (a).begin() + (l), (a).begin() + (r)\n\nusing namespace std;\nusing ll = long long;\t\tusing ld = long double;\nusing VB = vector<bool>;\tusing VVB = vector<VB>;\nusing VI = vector<int>;\t\tusing VVI = vector<VI>;\nusing VL = vector<ll>;\t\tusing VVL = vector<VL>;\nusing VS = vector<string>;\tusing VD = vector<ld>;\nusing PII = pair<int, int>;\tusing VP = vector<PII>;\nusing PLL = pair<ll, ll>;\tusing VPL = vector<PLL>;\ntemplate<class T>using PQ = priority_queue<T>;\ntemplate<class T>using PQS = priority_queue<T, vector<T>, greater<T>>;\nconstexpr int inf = (int)1e9;\nconstexpr ll inf_ll = (ll)1e18, MOD = 1000000007;\nconstexpr ld PI = M_PI, EPS = 1e-12;\n\n// --- input --- //\n#ifdef _WIN32\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#endif\ninline int gc()noexcept { return getchar_unlocked(); }\ntemplate<class T>inline void InputF(T& v)noexcept { cin >> v; }\ninline void InputF(char& v)noexcept { while (isspace(v = gc())); }\ninline void InputF(bool& v)noexcept { char c; InputF(c); v = c == '1'; }\ninline void InputF(string& v)noexcept {\n\tchar c; for (InputF(c); !isspace(c); c = gc())v += c;\n}\ninline void InputF(int& v)noexcept {\n\tbool neg = false; v = 0; char c; InputF(c);\n\tif (c == '-') { neg = true; c = gc(); }\n\tfor (; isdigit(c); c = gc())v = v * 10 + (c - '0');\n\tif (neg)v = -v;\n}\ninline void InputF(long long& v)noexcept {\n\tbool neg = false; v = 0; char c; InputF(c);\n\tif (c == '-') { neg = true; c = gc(); }\n\tfor (; isdigit(c); c = gc())v = v * 10 + (c - '0');\n\tif (neg)v = -v;\n}\ninline void InputF(double& v)noexcept {\n\tdouble dp = 1; bool neg = false, adp = false; v = 0; char c; InputF(c);\n\tif (c == '-') { neg = true; c = gc(); }\n\tfor (; isdigit(c) || c == '.'; c = gc()) {\n\t\tif (c == '.')adp = true;\n\t\telse if (adp)v += (c - '0') * (dp *= 0.1);\n\t\telse v = v * 10 + (c - '0');\n\t}\n\tif (neg)v = -v;\n}\ntemplate<class T, class U>inline void InputF(pair<T, U>& v)noexcept {\n\tInputF(v.first); InputF(v.second);\n}\ntemplate<class T>inline void InputF(vector<T>& v)noexcept {\n\tfor (auto& e : v)InputF(e);\n}\ntemplate<class T>inline T InputF() { T v; InputF(v); return v; }\nstruct InputV {\n\tint n, m;\n\tInputV(int N) :n(N), m(0) {}\n\tInputV(pair<int, int> N) :n(N.first), m(N.second) {}\n\ttemplate<class T>operator vector<T>()noexcept {\n\t\tvector<T> v(n); InputF(v); return v;\n\t}\n\ttemplate<class T>operator vector<vector<T>>()noexcept {\n\t\tvector<vector<T>> v(n, vector<T>(m)); InputF(v); return v;\n\t}\n};\nstruct Input {\n\ttemplate<class T>operator T()noexcept { return InputF<T>(); }\n\tint operator--(int) { int v; InputF(v); v--; return v; }\n\tInputV operator[](int n)noexcept { return InputV(n); }\n\tInputV operator[](pair<int, int> n)noexcept { return InputV(n); }\n\tvoid operator()() {}\n\ttemplate<class H, class...T>void operator()(H&& h, T&& ...t) {\n\t\tInputF(h); operator()(forward<T>(t)...);\n\t}\n\ttemplate<class T>Input& operator,(T&& v) {\n\t\tInputF(v); return *this;\n\t}\n}in;\n#define input(T) InputF<T>()\n#define ini input(int)\n#define inl input(ll)\n#define ins input(string)\n#define ind input(ld)\n#define input2(T, ...) T __VA_ARGS__; in(__VA_ARGS__)\n#define INT(...) input2(int, __VA_ARGS__)\n#define LL(...) input2(ll, __VA_ARGS__)\n#define STR(...) input2(string, __VA_ARGS__)\n#define DOUBLE(...) input2(ld, __VA_ARGS__)\n\n// --- output --- //\nstruct BoolStr {\n\tconst char* t, * f; BoolStr(const char* _t, const char* _f) :t(_t), f(_f) {}\n}Yes(\"Yes\", \"No\"), yes(\"yes\", \"no\"), YES(\"YES\", \"NO\"), Int(\"1\", \"0\");\nstruct DivStr {\n\tconst char* d, * l; DivStr(const char* _d, const char* _l) :d(_d), l(_l) {}\n}spc(\" \", \"\\n\"), no_spc(\"\", \"\\n\"), end_line(\"\\n\", \"\\n\"), comma(\",\", \"\\n\"), no_endl(\" \", \"\");\nclass Output {\n\tBoolStr B{ Yes }; DivStr D{ spc }; bool isPrint = true;\n\tvoid p(double v) { printf(\"%.20f\", v); } void p(long double v) { printf(\"%.20Lf\", v); }\n\tvoid p(int v) { printf(\"%d\", v); }\tvoid p(ll v) { printf(\"%lld\", v); }\n\tvoid p(char v) { putchar(v); }\t\tvoid p(bool v) { printf(\"%s\", v ? B.t : B.f); }\n\ttemplate<class T>void p(const T& v) { cout << v; }\n\ttemplate<class T, class U>void p(const pair<T, U>& v) { p(v.first); printf(\"%s\", D.d); p(v.second); }\n\ttemplate<class T>void p(const vector<T>& v) { rep(i, sz(v)) { if (i)printf(\"%s\", D.d); p(v[i]); } }\n\ttemplate<class T>void p(const vector<vector<T>>& v) { rep(i, sz(v)) { if (i)printf(\"%s\", D.l); p(v[i]); } }\n\tvoid p(const BoolStr& v) { B = v; isPrint = false; } void p(const DivStr& v) { D = v; isPrint = false; }\npublic:\n\tOutput& operator()() { printf(\"%s\", D.l); return *this; }\n\ttemplate<class H>Output& operator()(H&& h) {\n\t\tp(h); if (isPrint)printf(\"%s\", D.l); isPrint = true; return *this;\n\t}\n\ttemplate<class H, class...T>Output& operator()(H&& h, T&& ...t) {\n\t\tp(h); if (isPrint)printf(\"%s\", D.d); isPrint = true; return operator()(forward<T>(t)...);\n\t}\n\ttemplate<class...T>void exit(T&& ...t) {\n\t\toperator()(forward<T>(t)...); std::exit(EXIT_SUCCESS);\n\t}\n\tOutput& flush() { cout.flush(); return *this; }\n\tOutput& set(const char* t, const char* f) { B = BoolStr(t, f); return *this; }\n}out;\n\n// --- step --- //\ntemplate<class T>struct Step {\n\tclass It {\n\t\tT a, b, c;\n\tpublic:\n\t\tconstexpr It()noexcept : a(T()), b(T()), c(T()) {}\n\t\tconstexpr It(T _b, T _c, T _s)noexcept : a(_b), b(_c), c(_s) {}\n\t\tconstexpr It& operator++()noexcept { --b; a += c; return *this; }\n\t\tconstexpr It operator++(int)noexcept { It tmp = *this; --b; a += c; return tmp; }\n\t\tconstexpr const T& operator*()const noexcept { return a; }\n\t\tconstexpr const T* operator->()const noexcept { return &a; }\n\t\tconstexpr bool operator==(const It& i)const noexcept { return b == i.b; }\n\t\tconstexpr bool operator!=(const It& i)const noexcept { return !(b == i.b); }\n\t\tconstexpr T start()const noexcept { return a; }\n\t\tconstexpr T count()const noexcept { return b; }\n\t\tconstexpr T step()const noexcept { return c; }\n\t};\n\tconstexpr Step(T b, T c, T s)noexcept : be(b, c, s) {}\n\tconstexpr It begin()const noexcept { return be; }\n\tconstexpr It end()const noexcept { return en; }\n\tconstexpr T start()const noexcept { return be.start(); }\n\tconstexpr T count()const noexcept { return be.count(); }\n\tconstexpr T step()const noexcept { return be.step(); }\n\tconstexpr T sum()const noexcept { return start() * count() + step() * (count() * (count() - 1) / 2); }\n\toperator vector<T>()const noexcept { return as_vector(); }\n\tvector<T> as_vector()const noexcept {\n\t\tvector<T> res; res.reserve(count()); each([&](T i) {res.push_back(i); }); return res;\n\t}\n\ttemplate<class F>void each(const F& f)const noexcept { for (T i : *this)f(i); }\n\ttemplate<class F>auto map(const F& f)const noexcept {\n\t\tvector<decay_t<result_of_t<F(T)>>> res; res.reserve(count());\n\t\teach([&](T i) {res.push_back(f(i)); }); return res;\n\t}\n\ttemplate<class F>int count_if(const F& f)const noexcept {\n\t\tint res = 0; each([&](T i) {res += static_cast<bool>(f(i)); }); return res;\n\t}\n\ttemplate<class F>vector<T> select(const F& f)const noexcept {\n\t\tvector<T> res; each([&](T i) {if (f(i))res.push_back(i); }); return res;\n\t}\n\ttemplate<class F>auto max(const F& f)const noexcept {\n\t\tauto v = map(f); return *max_element(v.begin(), v.end());\n\t}\n\ttemplate<class F>auto min(const F& f)const noexcept {\n\t\tauto v = map(f); return *min_element(v.begin(), v.end());\n\t}\n\ttemplate<class F, class U = decay_t<result_of_t<F(T)>>>auto sum(const F& f)const noexcept {\n\t\tU res = 0; each([&](T i) {res += static_cast<U>(f(i)); }); return res;\n\t}\n\tusing value_type = T;\n\tusing iterator = It;\nprivate:\n\tIt be, en;\n};\ntemplate<class T>inline constexpr auto step(T a)noexcept { return Step<T>(0, a, 1); }\ntemplate<class T>inline constexpr auto step(T a, T b)noexcept { return Step<T>(a, b - a, 1); }\ntemplate<class T>inline constexpr auto step(T a, T b, T c)noexcept { return Step<T>(a, a < b ? (b - a - 1) / c + 1 : 0, c); }\n\ninline namespace {\n\ttemplate<class T>inline void Sort(T& a)noexcept { sort(all(a)); }\n\ttemplate<class T>inline void RSort(T& a)noexcept { sort(rall(a)); }\n\ttemplate<class T>inline T Sorted(T a)noexcept { Sort(a); return a; }\n\ttemplate<class T>inline T RSorted(T a)noexcept { RSort(a); return a; }\n\ttemplate<class T, class F>inline void Sort(T& a, const F& f)noexcept {\n\t\tsort(all(a), [&](const auto& x, const auto& y) {return f(x) < f(y); });\n\t}\n\ttemplate<class T, class F>inline void RSort(T& a, const F& f)noexcept {\n\t\tsort(rall(a), [&](const auto& x, const auto& y) {return f(x) < f(y); });\n\t}\n\ttemplate<class T>inline void Reverse(T& a)noexcept { reverse(all(a)); }\n\ttemplate<class T>inline void Unique(T& a)noexcept { a.erase(unique(all(a)), a.end()); }\n\ttemplate<class T>inline T Reversed(T a)noexcept { Reverse(a); return a; }\n\ttemplate<class T>inline T Uniqued(T a)noexcept { Unique(a); return a; }\n\ttemplate<class T>inline auto Max(const T& a)noexcept { return *max_element(all(a)); }\n\ttemplate<class T>inline auto Min(const T& a)noexcept { return *min_element(all(a)); }\n\ttemplate<class T>inline int MaxPos(const T& a)noexcept { return max_element(all(a)) - a.begin(); }\n\ttemplate<class T>inline int MinPos(const T& a)noexcept { return min_element(all(a)) - a.begin(); }\n\ttemplate<class T, class F>inline auto Max(const T& a, const F& f)noexcept {\n\t\treturn *max_element(all(a), [&](const auto& x, const auto& y) {return f(x) < f(y); });\n\t}\n\ttemplate<class T, class F>inline auto Min(const T& a, const F& f)noexcept {\n\t\treturn *min_element(all(a), [&](const auto& x, const auto& y) {return f(x) < f(y); });\n\t}\n\ttemplate<class T, class U>inline int Count(const T& a, const U& v)noexcept { return count(all(a), v); }\n\ttemplate<class T, class F>inline int CountIf(const T& a, const F& f)noexcept { return count_if(all(a), f); }\n\ttemplate<class T, class U>inline int Find(const T& a, const U& v)noexcept { return find(all(a), v) - a.begin(); }\n\ttemplate<class T, class F>inline int FindIf(const T& a, const F& f)noexcept { return find_if(all(a), f) - a.begin(); }\n\ttemplate<class T, class U = typename T::value_type>inline U Sum(const T& a)noexcept { return accumulate(all(a), U()); }\n\ttemplate<class T, class F>inline auto Sum(const T& v, const F& f) {\n\t\treturn accumulate(next(v.begin()), v.end(), f(v.front()), [&](auto a, auto b) {return a + f(b); });\n\t}\n\ttemplate<class T, class U>inline int Lower(const T& a, const U& v)noexcept { return lower_bound(all(a), v) - a.begin(); }\n\ttemplate<class T, class U>inline int Upper(const T& a, const U& v)noexcept { return upper_bound(all(a), v) - a.begin(); }\n\ttemplate<class T, class F>inline void RemoveIf(T& a, const F& f)noexcept { a.erase(remove_if(all(a), f), a.end()); }\n\ttemplate<class F>inline auto Vector(size_t size, const F& f)noexcept {\n\t\tvector<decay_t<result_of_t<F(size_t)>>> res(size); for (size_t i = 0; i < size; ++i)res[i] = f(i); return res;\n\t}\n\ttemplate<class T>inline auto Grid(size_t h, size_t w, const T& v = T())noexcept { return vector<vector<T>>(h, vector<T>(w, v)); }\n\ttemplate<class T>inline auto Slice(const T& v, size_t i, size_t len)noexcept {\n\t\treturn i < v.size() ? T(v.begin() + i, v.begin() + min(i + len, v.size())) : T();\n\t}\n\ttemplate<class T, class F>inline auto Each(const T& v, const F& f)noexcept { for (auto& i : v)f(i); }\n\ttemplate<class T, class F>inline auto Select(const T& v, const F& f)noexcept {\n\t\tT res; for (const auto& e : v)if (f(e))res.push_back(e); return res;\n\t}\n\ttemplate<class T, class F>inline auto Map(const T& v, const F& f)noexcept {\n\t\tvector<decay_t<result_of_t<F(typename T::value_type)>>> res(v.size());\n\t\tsize_t i = 0; for (const auto& e : v)res[i++] = f(e); return res;\n\t}\n\ttemplate<class T, class F>inline auto MapIndex(const T& v, const F& f)noexcept {\n\t\tvector<decay_t<result_of_t<F(size_t, typename T::value_type)>>> res(v.size());\n\t\tsize_t i = 0; for (auto it = v.begin(); it != v.end(); ++it, ++i)res[i] = f(i, *it); return res;\n\t}\n\ttemplate<class T, class F>inline auto TrueIndex(const T& v, const F& f)noexcept {\n\t\tvector<size_t> res; for (size_t i = 0; i < v.size(); ++i)if (f(v[i]))res.push_back(i); return res;\n\t}\n\tinline string operator*(string s, size_t n)noexcept { string ret; for (size_t i = 0; i < n; ++i)ret += s; return ret; }\n\ttemplate<class T>inline T Ceil(T n, T m)noexcept { return (n + m - 1) / m; }\n\ttemplate<class T>inline T Ceil2(T n, T m)noexcept { return Ceil(n, m) * m; }\n\ttemplate<class T>inline T Tri(T n)noexcept { return (n & 1) ? (n + 1) / 2 * n : n / 2 * (n + 1); }\n\ttemplate<class T>inline T nC2(T n)noexcept { return (n & 1) ? (n - 1) / 2 * n : n / 2 * (n - 1); }\n\ttemplate<class T>inline T Mid(const T& l, const T& r)noexcept { return l + (r - l) / 2; }\n\ttemplate<class T>inline int pop_count(T n)noexcept { return bitset<64>(n).count(); }\n\ttemplate<class T>inline bool chmax(T& a, const T& b)noexcept { if (a < b) { a = b; return true; } return false; }\n\ttemplate<class T>inline bool chmin(T& a, const T& b)noexcept { if (a > b) { a = b; return true; } return false; }\n\ttemplate<class T>inline bool inRange(const T& v, const T& min, const T& max)noexcept { return min <= v && v < max; }\n\ttemplate<class T = ll>inline T BIT(int b)noexcept { return T{ 1 } << b; }\n\ttemplate<class T>inline T Gcd(T n, T m)noexcept { return m ? Gcd(m, n % m) : n; }\n\ttemplate<class T>inline T Lcm(T n, T m)noexcept { return n / Gcd(n, m) * m; }\n\ttemplate<class T, class U = typename T::value_type>inline U Gcdv(const T& v)noexcept {\n\t\treturn accumulate(next(v.begin()), v.end(), U(*v.begin()), Gcd<U>);\n\t}\n\ttemplate<class T, class U = typename T::value_type>inline U Lcmv(const T& v)noexcept {\n\t\treturn accumulate(next(v.begin()), v.end(), U(*v.begin()), Lcm<U>);\n\t}\n\ttemplate<class T>inline T Pow(T a, T n)noexcept { T r = 1; while (n > 0) { if (n & 1)r *= a; a *= a; n /= 2; } return r; }\n\ttemplate<class T>inline T Powmod(T a, T n, T m = MOD)noexcept {\n\t\tT r = 1; while (n > 0) { if (n & 1)r = r * a % m, n--; else a = a * a % m, n /= 2; }return r;\n\t}\n}\n\n// --- dump --- //\n#if __has_include(\"dump.hpp\")\n#include \"dump.hpp\"\n#else\n#define dump(...) ((void)0)\n#endif\n\n// ---------------------------------------------------------------- //\n\nstruct Point {\n\tstatic int H, W;\n\tstatic const vector<Point> d;\n\tstatic void set_range(int _H, int _W) { H = _H; W = _W; }\n\tstatic constexpr Point zero() { return { 0,0 }; }\n\tstatic constexpr Point one() { return { 1,1 }; }\n\tint x, y;\n\tconstexpr Point() :x(0), y(0) {}\n\tconstexpr Point(int _x, int _y) : x(_x), y(_y) {}\n\tPoint(int n) :x(n% W), y(n / W) {}\n\tconstexpr Point operator+()const { return *this; }\n\tconstexpr Point operator-()const { return { -x,-y }; }\n\tconstexpr Point operator+(const Point& p)const { return Point(*this) += p; }\n\tconstexpr Point operator-(const Point& p)const { return Point(*this) -= p; }\n\tconstexpr Point operator*(const Point& p)const { return Point(*this) *= p; }\n\tconstexpr Point operator/(const Point& p)const { return Point(*this) /= p; }\n\tconstexpr Point operator+(int n)const { return Point(*this) += Point(n, n); }\n\tconstexpr Point operator-(int n)const { return Point(*this) -= Point(n, n); }\n\tconstexpr Point operator*(int n)const { return Point(*this) *= Point(n, n); }\n\tconstexpr Point operator/(int n)const { return Point(*this) /= Point(n, n); }\n\tconstexpr Point& operator+=(const Point& p) { x += p.x; y += p.y; return *this; }\n\tconstexpr Point& operator-=(const Point& p) { x -= p.x; y -= p.y; return *this; }\n\tconstexpr Point& operator*=(const Point& p) { x *= p.x; y *= p.y; return *this; }\n\tconstexpr Point& operator/=(const Point& p) { x /= p.x; y /= p.y; return *this; }\n\tconstexpr Point& operator+=(int n) { x += n; x += n; return *this; }\n\tconstexpr Point& operator-=(int n) { x -= n; x -= n; return *this; }\n\tconstexpr Point& operator*=(int n) { x *= n; x *= n; return *this; }\n\tconstexpr Point& operator/=(int n) { x /= n; x /= n; return *this; }\n\tbool operator==(const Point& p)const { return to_i() == p.to_i(); }\n\tbool operator!=(const Point& p)const { return to_i() != p.to_i(); }\n\tbool operator<(const Point& p)const { return to_i() < p.to_i(); }\n\tbool operator<=(const Point& p)const { return to_i() <= p.to_i(); }\n\tbool operator>(const Point& p)const { return to_i() > p.to_i(); }\n\tbool operator>=(const Point& p)const { return to_i() >= p.to_i(); }\n\tconstexpr int operator[](int i)const { return i == 0 ? x : i == 1 ? y : 0; }\n\tbool in_range()const { return 0 <= x && x < W && 0 <= y && y < H; }\n\tint to_i()const { return x + y * W; }\n\tconstexpr pair<int, int> to_pair()const { return { x,y }; }\n\tint dist(const Point& p)const { return std::abs(x - p.x) + std::abs(y - p.y); }\n\tPoint abs(const Point& p)const { return { std::abs(x - p.x),std::abs(y - p.y) }; }\n\tPoint& swap() { std::swap(x, y); return *this; }\n\tvector<Point> adjacent4()const {\n\t\tvector<Point> v(4); for (int i = 0; i < 4; ++i)v[i] = *this + d[i]; return v;\n\t}\n\tvector<Point> adjacent8()const {\n\t\tvector<Point> v(8); for (int i = 0; i < 8; ++i)v[i] = *this + d[i]; return v;\n\t}\n\tvector<Point> adj4_in_range()const {\n\t\tvector<Point> v; for (const auto& P : adjacent4())if (P.in_range())v.push_back(P); return v;\n\t}\n\tvector<Point> adj8_in_range()const {\n\t\tvector<Point> v; for (const auto& P : adjacent8())if (P.in_range())v.push_back(P); return v;\n\t}\n\tconstexpr Point left()const { return { x - 1,y }; }\n\tconstexpr Point right()const { return { x + 1,y }; }\n\tconstexpr Point up()const { return { x,y - 1 }; }\n\tconstexpr Point down()const { return { x,y + 1 }; }\n\tconstexpr Point moved(char c)const { return Point(*this).move(c); }\n\tconstexpr Point& move(char c) {\n\t\tswitch (c) {\n\t\tcase 'L':case 'l':x--; break;\n\t\tcase 'R':case 'r':x++; break;\n\t\tcase 'U':case 'u':y--; break;\n\t\tcase 'D':case 'd':y++; break;\n\t\t}\n\t\treturn *this;\n\t}\n};\nint Point::H, Point::W;\nconst vector<Point> Point::d{ {-1,0},{0,1},{1,0},{0,-1},{-1,-1},{-1,1},{1,-1},{1,1} };\ninline ostream& operator<<(ostream& os, const Point& p) { return os << '(' << p.x << \", \" << p.y << ')'; }\ninline istream& operator>>(istream& is, Point& p) { return is >> p.y >> p.x; }\n\nint main() {\n\tfor (int w = in, h = in; w + h; in(w, h)) {\n\t\tVS s = in[h];\n\t\tPoint::set_range(h, w);\n\t\tauto B = Grid<bool>(h, w), W = Grid<bool>(h, w);\n\t\tfunction<void(Point, VVB&)> dfs = [&](Point p, VVB& flag) {\n\t\t\tfor (auto p2 : p.adj4_in_range()) {\n\t\t\t\tif (s[p2.y][p2.x] == '.' && !flag[p2.y][p2.x]) {\n\t\t\t\t\tflag[p2.y][p2.x] = true;\n\t\t\t\t\tdfs(p2, flag);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\trep(i, h)rep(j, w) {\n\t\t\tif (s[i][j] == 'B') {\n\t\t\t\tdfs(Point(j, i), B);\n\t\t\t} else if (s[i][j] == 'W') {\n\t\t\t\tdfs(Point(j, i), W);\n\t\t\t}\n\t\t}\n\n\t\tint cntB = 0, cntW = 0;\n\t\trep(i, h)rep(j, w)if (s[i][j] == '.') {\n\t\t\tif (B[i][j] && !W[i][j]) {\n\t\t\t\tcntB++;\n\t\t\t} else if (!B[i][j] && W[i][j]) {\n\t\t\t\tcntW++;\n\t\t\t}\n\t\t}\n\t\tout(cntB, cntW);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint w, h;\n\nvoid dfs(vector< vector<int> >& area, int x, int y, bool flag)\n{\n\tif (flag) {\n\t\tarea[x][y] ^= 4;\n\t\tif (x - 1 >= 0 && !(area[x - 1][y] & 2) && !(area[x - 1][y] & 4)) {\n\t\t\tdfs(area,x - 1,y,flag);\n\t\t}\n\t\tif (y - 1 >= 0 && !(area[x][y - 1] & 2) && !(area[x][y - 1] & 4)) {\n\t\t\tdfs(area, x, y - 1, flag);\n\t\t}\n\t\tif (x + 1 < w && !(area[x + 1][y] & 2) && !(area[x + 1][y] & 4)) {\n\t\t\tdfs(area, x + 1, y, flag);\n\t\t}\n\t\tif (y + 1 < h && !(area[x][y + 1] & 2) && !(area[x][y + 1] & 4)) {\n\t\t\tdfs(area, x, y + 1, flag);\n\t\t}\n\t}\n\telse {\n\t\tarea[x][y] ^= 8;\n\t\tif (x - 1 >= 0 && !(area[x - 1][y] & 1) && !(area[x - 1][y] & 8)) {\n\t\t\tdfs(area, x - 1, y, flag);\n\t\t}\n\t\tif (y - 1 >= 0 && !(area[x][y - 1] & 1) && !(area[x][y - 1] & 8)) {\n\t\t\tdfs(area, x, y - 1, flag);\n\t\t}\n\t\tif (x + 1 < w && !(area[x + 1][y] & 1) && !(area[x + 1][y] & 8)) {\n\t\t\tdfs(area, x + 1, y, flag);\n\t\t}\n\t\tif (y + 1 < h && !(area[x][y + 1] & 1) && !(area[x][y + 1] & 8)) {\n\t\t\tdfs(area, x, y + 1, flag);\n\t\t}\n\t}\n}\n\nint main()\n{\n\tchar ch;\n\twhile (cin >> w >> h, w || h) {\n\t\tvector< vector<int> > area(w, vector<int>(h));\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tcin >> ch;\n\t\t\t\tif (ch == 'B') {\n\t\t\t\t\tarea[j][i] = 1;\n\t\t\t\t}\n\t\t\t\telse if (ch == 'W') {\n\t\t\t\t\tarea[j][i] = 2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (area[j][i] & 1) {\n\t\t\t\t\tdfs(area, j, i, true);\n\t\t\t\t}\n\t\t\t\telse if (area[j][i] & 2) {\n\t\t\t\t\tdfs(area, j, i, false);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint bn = 0, wn = 0;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (!(area[j][i] & 3)) {\n\t\t\t\t\tif ((area[j][i] & 4) && !(area[j][i] & 8)) {\n\t\t\t\t\t\tbn++;\n\t\t\t\t\t}\n\t\t\t\t\telse if ((area[j][i] & 8) && !(area[j][i] & 4)) {\n\t\t\t\t\t\twn++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << bn << \" \" << wn << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\nusing namespace std;\n\nint vis[60][60];\nstring map[51];\nint w,h;\n\nvoid emp(){\n  int i,j;\n\n  for(i=0;i<60;i++){\n    for(j=0;j<60;j++){\n      vis[i][j]=0;\n    }\n  }\n}\n\nvoid dfsw(int i,int j){\n  vis[i][j]+=3;\n  \n  if(j+1<w && (vis[i][j+1]==0 || vis[i][j+1]==4)) dfsw(i,j+1);\n  if(0<=i-1 && (vis[i-1][j]==0 || vis[i-1][j]==4)) dfsw(i-1,j);\n  if(0<=j-1 && (vis[i][j-1]==0 || vis[i][j-1]==4)) dfsw(i,j-1);\n  if(i+1<h && (vis[i+1][j]==0 || vis[i+1][j]==4)) dfsw(i+1,j);\n}\n\nvoid dfsb(int i,int j){\n  vis[i][j]+=4;\n  if(j+1<w && (vis[i][j+1]==0 || vis[i][j+1]==3)) dfsb(i,j+1);\n  if(0<=i-1 && (vis[i-1][j]==0 || vis[i-1][j]==3)) dfsb(i-1,j);\n  if(0<=j-1 && (vis[i][j-1]==0 || vis[i][j-1]==3)) dfsb(i,j-1);\n  if(i+1<h && (vis[i+1][j]==0 || vis[i+1][j]==3)) dfsb(i+1,j);\n}\n  \n\nint main(){\n  int i,j;\n  int bc,wc;\n\n  while(1){\n    emp();\n    bc=0;\n    wc=0;\n\n    scanf(\"%d%d\",&w,&h);\n    if(w==0 && h==0)break;\n\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tcin >> map[i][j];\n\tif(map[i][j]=='W'){\n\t  vis[i][j]=2;\n\t}else if(map[i][j]=='B'){\n\t  vis[i][j]=1;\n\t}else if(map[i][j]=='.'){\n\t  vis[i][j]=0;\n\t}\n      }\n    }\n\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tif(vis[i][j]==1)dfsb(i,j);\n\tif(vis[i][j]==2)dfsw(i,j);\n      }\n    }\n    for(i=0;i<h;i++){\n    for(j=0;j<w;j++){\n      if(vis[i][j]==4)bc++;\n      if(vis[i][j]==3)wc++;\n    }\n  }\n\n    printf(\"%d %d\\n\",bc,wc);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nvector< vector<char> > a(55, vector<char>(55));\nvector< vector<int> > mp(55, vector<int>(55));\nint bb, ww;\n\nint dx[] = { 1, 0, -1, 0 };\nint dy[] = { 0, 1, 0, -1 };\n\nbool range(int x, int y, int h, int w) {\n\tif (0 <= x && x < w && 0 <= y && y < h) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nint cc;\n\nvoid count(int x, int y, int h, int w) {\n\tfor (int i = 0; i < 4; i++) {\n\t\tif (range(x + dx[i], y + dy[i], h, w)) {\t\t\t\t\n\t\t\tif (mp[y+dy[i]][x+dx[i]] == -1) {\n\t\t\t\tif (a[y + dy[i]][x + dx[i]] == 'B') {\n\t\t\t\t\tbb = 1;\n\t\t\t\t}\n\t\t\t\telse if (a[y + dy[i]][x + dx[i]] == 'W') {\n\t\t\t\t\tww = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcc++;\n\t\t\t\tmp[y + dy[i]][x + dx[i]] = -1;\n\t\t\t\tcount(x + dx[i], y + dy[i], h, w);\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\nint main() {\n\tint w, h;\n\twhile (cin >> w >> h) {\n\t\tif (w == 0 && h == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tcin >> a[i][j];\n\t\t\t\tif (a[i][j] == '.') {\n\t\t\t\t\tmp[i][j] = 0;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmp[i][j] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint b2, w2;\n\t\tb2 = w2 = 0;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tbb = ww = cc = 0;\n\t\t\t\tif (mp[i][j] != -1) {\n\t\t\t\t\tmp[i][j] = -1;\n\t\t\t\t\tcc = 1;\n\t\t\t\t\tcount(j, i, h, w);\n\t\t\t\t\t//cout << bb << ' ' << ww << ' ' << cc << endl;\n\t\t\t\t\tif (bb == 1 && ww == 1) {\n\n\t\t\t\t\t}\n\t\t\t\t\telse if (bb == 1) {\n\t\t\t\t\t\tb2 += cc;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tw2 += cc;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << b2 << ' ' << w2 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint dxy[4] = {-1, 1, 0, 0};\nint W, H;\nchar a[60][60];\nint temp[60][60];\n\nint huga(int x, int y){//cout<<y<<\" \"<<x<<endl;\n\tint w = 0, b = 0, s = 0, ans=-3, t;    // z[60][60] = {};\n\tvector<vector<int>> z;\n\tz =vector<vector<int>>(H+1, vector<int>(W+1,0));\n\tqueue <P> Q;\n\t\n\tQ.push(P(y,x));\n\t\n\twhile(!Q.empty()){\n\t\tP p = Q.front();Q.pop();\n\t\tint yy = p.first, xx = p.second;\n\t\tz[yy][xx] = 1;\n\t\tfor(int i = 0; i <= 3; i++){\n\t\t\tint nx = xx+dxy[i], ny = yy+dxy[3-i];\n\t\t\tif(temp[ny][nx] == -1)return -1;\n\t\t}\n\t\tfor(int i = 0; i <= 3; i++){\n\t\t\tint nx = xx+dxy[i], ny = yy+dxy[3-i];\n\t\t\tif(a[ny][nx] == '.' && !z[ny][nx]) Q.push(P(ny,nx));\n\t\t\telse if(a[ny][nx] == 'B')b=1;\n\t\t\telse if(a[ny][nx] == 'W')w=1;\n\t\t\tif(b&&w)return ans = -1;\n\t\t}\n\t}\n\t\n\tif(w&&b || !w&&!b) ans = -1;\n\telse if(!w&&b)ans = 1;\n\telse if(!b&&w)ans =  0;\n\telse ans = -4;\n\t\n\t//cout<<ans<<endl<<endl;\n\treturn ans;\n\t\n}\n\nint main(){\n\t\n\twhile(1){\n\t\tint cw=0, cb=0;\n\t\tcin>>W>>H;\n\t\t\n\t\tif(!W&&!H)break;\n\t\tfor(int i = 0; i <= W+1; i++){\n\t\t\ta[0][i] = a[H+1][i] = 0;\n\t\t\ttemp[H+1][i] = temp[0][i] = 2;\n\t\t}\n\t\t\n\t\t\n\t\tfor(int i = 0; i <= H+1; i++){\n\t\t\ta[i][0] = a[i][W+1] = 0;\n\t\t\ttemp[i][0] = temp[0][i] = 2;\n\t\t}\n\t\t\n\t\tfor(int i = 1; i <= H; i++){\n\t\t\tfor(int j = 1; j <= W; j++){\n\t\t\t\tcin>>a[i][j];\n\t\t\t\ttemp[i][j] = 2;\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tfor(int i = 1; i <= H; i++){\n\t\t\tfor(int j = 1; j <= W; j++){\n\t\t\t\tif(a[i][j] == '.'){\n\t\t\t\t\t//cout<<\"---- \"<<i<<\" \"<<j<<endl;\n\t\t\t\t\tint z[60][60] = {};\n\t\t\t\t\ttemp[i][j] = huga(j,i,z);\n\t\t\t\t\tif(temp[i][j] == 1)a[i][j]=='B';\n\t\t\t\t\telse if(temp[i][j] == 0)a[i][j]=='W';\n\t\t\t\t\t//cout<<\"---\"<<endl<<endl;;\n\t\t\t\t\tprintf(\"%2d\" , temp[i][j]);\n\t\t\t\t} else cout<<\" \"<<a[i][j];\n\t\t\t}cout<<endl;\n\t\t\t\n\t\t}*/\n\t\t\n\t\tfor(int i = 1; i <= H; i++){\n\t\t\tfor(int j = 1; j <= W; j++){\n\t\t\t\tif(a[i][j] == '.'){\n\t\t\t\t\ttemp[i][j] = huga(j,i);\n\t\t\t\t\tif(temp[i][j] == 1)a[i][j]=='B';\n\t\t\t\t\telse if(temp[i][j] == 0)a[i][j]=='W';\n\t\t\t\t\tif(temp[i][j] == 1)cb++;\n\t\t\t\t\telse if(temp[i][j] == 0)cw++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tcout<<cb<<\" \"<<cw<<endl;\n\t}\n\t\n\t\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<n;++i)\n#define FOR(i,a,b) for(int i=a;i<b;++i)\nchar c[60][60];\nint a[60][60];\nint flag, w, h;\n\nvoid dfs(int y,int x){\n  if(c[y][x] == 'B'){\n    if(flag == 0 || flag == 1) flag = 1;\n    else flag = 3;    \n    a[y][x] = 9;\n  }else if(c[y][x] == 'W'){\n    if(flag == 0 || flag == 2) flag = 2;\n    else flag = 3;\n    a[y][x] = 9;\n  }else if(a[y][x]==0){\n    a[y][x] = 4;\n    FOR(i,y-1,y+2) if(i>=0 && i<h) dfs(i,x);\n    FOR(j,x-1,x+2) if(j>=0 && j<w) dfs(y,j);\n  }\n}\nint main(){\n  int bl, wh;\n  while(cin>>w>>h, w){\n    bl = 0; wh = 0;\n    REP(i, h) REP(j, w){\n      cin>>c[i][j];\n      a[i][j]=0;\n    }\n    \n    REP(i, h) REP(j, w){\n      if(c[i][j] == 'B' || c[i][j] == 'W' || a[i][j]) continue;\n      flag = 0;\n      dfs(i,j);\n      \n      if(flag) REP(k,h) REP(l,w){\n          if(a[k][l] == 4) a[k][l] = flag;\n        }\n    }\n    REP(i,h) REP(j,w){\n      if(a[i][j] == 1) bl++;\n      if(a[i][j] == 2) wh++;\n    }\n    cout<<bl<<\" \"<<wh<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1e18\n#define int long long\n#define Rep(i, a, n) for (int i = (a); i < (n); i++)\n#define Repr(i, n, a) for (int i = (n); i >= (a); i--)\n#define rep(i, n) Rep(i, 0, n)\n#define repr(i, n) Repr(i, n, 0)\n#define all(a) a.begin(), a.end()\nusing namespace std;\ntypedef pair<int, int> P;\nconst int mod = 1000000007;\n\nint h, w;\nchar a[60][60];\nint dx[4] = {1, 0, -1, 0}, dy[4] = {0, -1, 0, 1};\n\nbool in(int x, int y) { return 0 <= x && x < h && 0 <= y && y < w; }\nvoid solve(int x, int y, char c)\n{\n    if (a[x][y] == '.')\n        a[x][y] = c;\n    if (a[x][y] == 'w' || a[x][y] == 'b')\n    {\n        if (a[x][y] != c)\n            a[x][y] = 'm';\n    }\n    for (int i = 0; i < 4; i++)\n    {\n        int nx = x + dx[i], ny = y + dy[i];\n        if (!in(nx, ny) || a[nx][ny] == 'W' || a[nx][ny] == 'B' || a[nx][ny] == 'm' || a[nx][ny] == c)\n            continue;\n        solve(nx, ny, c);\n    }\n}\n\nsigned main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    while (1)\n    {\n        cin >> w >> h;\n        if (w == 0)\n            break;\n        rep(i, h) rep(j, w) cin >> a[i][j];\n        int sum1 = 0, sum2 = 0;\n        rep(i, h) rep(j, w)\n        {\n            if (a[i][j] == 'W')\n                solve(i, j, 'w');\n            if (a[i][j] == 'B')\n                solve(i, j, 'b');\n        }\n        rep(i, h)\n        {\n            rep(j, w)\n            {\n                if (a[i][j] == 'b')\n                    sum1++;\n                if (a[i][j] == 'w')\n                    sum2++;\n            }\n        }\n        cout << sum1 << \" \" << sum2 << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\nint w,h;\nstring s[51];\nconst int di[4] = {-1, 0, 1, 0};\nconst int dj[4] = {0, 1, 0, -1};\n\nvoid dfs(int ai, int aj, char c) {\n  if (s[ai][aj] == '.') {\n    s[ai][aj] = (c == 'W') ? 'w' : 'b' ;\n  } else if ((s[ai][aj] == 'b' && c == 'W') ||\n             (s[ai][aj] == 'w' && c == 'B')) {\n    s[ai][aj] = 'o'; \n  }\n  \n  for (int z = 0; z < 4; z += 1) {\n    int ti = ai + di[z], tj = aj + dj[z];\n    if (ti < 0 || tj < 0 || ti >= h || tj >= w) continue;\n    if (s[ti][tj] == 'B' || s[ti][tj] == 'W') continue;\n    \n    if ((s[ti][tj] == '.') || \n      (s[ti][tj] == 'b' && c == 'W') ||\n      (s[ti][tj] == 'w' && c == 'B')) {\n      dfs(ti, tj, c);\n    }\n  }\n}\n\nvoid solve() {\n  for(int i=0;i<h;i++) cin>>s[i];\n  \n  for(int i=0;i<h;i++)\n  for(int j=0;j<w;j++)\n  if (s[i][j] == 'B' || s[i][j] == 'W') {\n    dfs(i, j, s[i][j]);\n  }\n  \n  int bc = 0, wc = 0;\n  for(int i=0;i<h;i++)\n  for(int j=0;j<w;j++)\n  if (s[i][j] == 'b') {\n    bc++;\n  } else if (s[i][j] == 'w') {\n    wc++;\n  }\n  \n  cout<<bc<<\" \"<<wc<<endl;\n}\n\nint main (int argc, char const* argv[]) {\n  while (cin>>w>>h, w||h) {\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <tuple>\n#include <queue>\n#include <set>\n#include <cstdio>\n#include <climits>\n#include <cmath>\n#include <array>\n#include <functional>\n#include <sstream>\n#include <list>\n#include <set>\nconst int MOD=1000000007;\nconst int INF=1000000000;\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\nconst double eps=1e-9;\nconst int inf=1e9;\ntypedef pair<int,int> P;\nstruct Point\n{\n  double x,y;\n  Point(){x=0;y=0;}\n  Point(double d_x,double d_y){x=d_x,y=d_y;}\n  double operator*(Point obj){return obj.x*x+obj.y*y;}\n  double operator%(Point obj){return obj.y*x-obj.x*y;}\n  Point operator*(double b){Point tmp;tmp.x=x*b;tmp.y=y*b;return tmp;}\n  Point operator/(double b){Point tmp;tmp.x=x/b;tmp.y=y/b;return tmp;}\n  Point operator+(Point obj){Point tmp;tmp.x=x+obj.x;tmp.y=y+obj.y;return tmp;}\n  Point operator-(){Point tmp;tmp.x=-x;tmp.y=-y;return tmp;}\n  Point operator-(Point obj){Point tmp;tmp.x=x-obj.x;tmp.y=y-obj.y;return tmp;}\n  Point operator-=(Point obj){x-=obj.x;y-=obj.y;return *this;}\n  Point operator+=(Point obj){x+=obj.x;y+=obj.y;return *this;}\n  Point operator/=(double b){x=x/b;y=y/b;return *this;}\n  Point operator*=(double b){x=x*b;y=y*b;return *this;}\n  double size(){return hypot(x,y);}\n  Point unit(){return Point(x/size(),y/size());}\n  Point normal(){return Point(y,-x);}\n  double atan(){return atan2(y,x);}\n};\n\nbool operator<(Point a,Point b){return a.x!=b.x?a.x<b.x:a.y<b.y;}\nbool operator>(Point a,Point b){return b<a;}\nbool operator<=(Point a,Point b){return !(b<a);}\nbool operator>=(Point a,Point b){return !(a<b);}\nbool operator==(Point a,Point b){return (a-b).size()<eps;}\nbool operator!=(Point a,Point b){return !(a==b);}\n\nbool equal(double a,double b){return abs(a-b)<eps;}\ndouble cross(Point a,Point b){return a%b;}\ndouble dot(Point a,Point b){return a*b;}\n\nint ccw(Point a,Point b,Point c)\n{\n  b=b-a;\n  c=c-a;\n  if(b%c>0) return +1;\n  else if(b%c<0)return -1;\n  else if(b*c<0) return +2;\n  else if(b.size()<c.size()) return -2;\n  else return 0;\n}\n\n\nint w,h;\nbool black[55][55];\nbool white[55][55];\nstring field[55];\nint dx[]={-1,0,1,0};\nint dy[]={0,-1,0,1};\n\nvoid solve(int x,int y,char c)\n{\n  if((c=='B' && black[y][x]) || (c=='W' && white[y][x])) return;\n  if(c=='W' && field[y][x]!='W') white[y][x]=true;\n  else if(c=='B' && field[y][x]!='B') black[y][x]=true;\n  for(int i=0;i<4;i++)\n    {\n      int nx=x+dx[i];\n      int ny=y+dy[i];\n      if(0<=nx && nx<w && 0<=ny && ny<h && field[ny][nx]=='.')\n\t{\n\t  solve(nx,ny,c);\n\t}\n    }\n}\n\nint main(int argc,char const* argv[])\n{\n  while(1)\n    {\n      memset(black,false,sizeof(black));\n      memset(white,false,sizeof(white));\n      cin >> w >> h;\n      if(!w)break;\n      for(int i=0;i<h;i++)\n\t{\n\t  cin >> field[i];\n\t}\n      for(int i=0;i<h;i++)\n\t{\n\t  for(int j=0;j<w;j++)\n\t    {\n\t      if(field[i][j]=='W')\n\t\t{\n\t\t  solve(j,i,'W');\n\t\t}\n\t      else if(field[i][j]=='B')\n\t\t{\n\t\t  solve(j,i,'B');\n\t\t}\n\t    }\n\t}\n      int blackcount=0,whitecount=0;\n      for(int i=0;i<h;i++)\n\t{\n\t  for(int j=0;j<w;j++)\n\t    {\n\t      if(black[i][j] && !white[i][j]) blackcount++;\n\t      else if(!black[i][j] && white[i][j]) whitecount++;\n\t    }\n\t}\n      cout << blackcount << ' ' << whitecount << endl;\n    }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <cstring>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ntypedef vector<pair<int,int> >vpii;\nchar m[99][99];\n\nchar dfs(int i, int j, vpii&v){\n\tif(m[i][j]=='B')return 1;\n\tif(m[i][j]=='W')return 2;\n\tif(m[i][j]=='X')return 0;\n\tint ret=0;\n\tv.push_back(make_pair(i,j));\n\tif(find(v.begin(),v.end(),make_pair(i-1,j))==v.end())ret|=dfs(i-1,j,v);\n\tif(find(v.begin(),v.end(),make_pair(i+1,j))==v.end())ret|=dfs(i+1,j,v);\n\tif(find(v.begin(),v.end(),make_pair(i,j-1))==v.end())ret|=dfs(i,j-1,v);\n\tif(find(v.begin(),v.end(),make_pair(i,j+1))==v.end())ret|=dfs(i,j+1,v);\n\treturn ret;\n}\n\nmain(){\n\tint w,h,i,j,k,r,s;\n\tfor(;scanf(\"%d%d\",&w,&h),w;printf(\"%d %d\\n\",r,s)){\n\t\tfor(memset(m,'X',sizeof(m)),r=s=0,i=1;i<=h;i++)scanf(\"%s\",m[i]+1),m[i][w+1]='X';\n\t\tfor(i=1;i<=h;i++)for(j=1;j<=w;j++)if(m[i][j]=='.'){\n\t\t\tvpii v;\n\t\t\tchar x=dfs(i,j,v);\n\t\t\tfor(k=0;k<v.size();k++)\n\t\t\t\tm[v[k].first][v[k].second]=x;\n\t\t}\n\t\tfor(i=1;i<=h;i++)for(j=1;j<=w;j++)\n\t\t\tif(m[i][j]==1)r++;\n\t\t\telse if(m[i][j]==2)s++;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define REP(i, a, n) for(int i = (a); i < (n); i++)\nusing namespace std;\n\nint W, H;\nchar A[50][50];\nint dd[5] = { 0, 1, 0, -1, 0 };\nbool v[50][50], s[2][50][50];\n\nbool isin(int y, int x) { return 0 <= y && y < H && 0 <= x && x < W; }\n\nvoid dfs(int y, int x, int c) {\n  if(v[y][x] || A[y][x] != '.') return;\n  // cout << y << \" \" << x << \" \" << c << endl;\n  v[y][x] = true;\n  s[c][y][x] = true;\n  REP(i, 0, 4) if(isin(y + dd[i], x + dd[i + 1])) dfs(y + dd[i], x + dd[i + 1], c);\n}\n\nint main(void) {\n  while(cin >> W >> H, W || H) {\n    REP(i, 0, H) cin >> A[i];\n\n    REP(i, 0, 2) REP(j, 0, H) REP(k, 0, W) s[i][j][k] = false;\n    REP(i, 0, H) REP(j, 0, W) if(A[i][j] != '.') {\n      REP(k, 0, H) REP(l, 0, W) v[k][l] = false;\n      REP(k, 0, 4) if(isin(i + dd[k], j + dd[k + 1])) dfs(i + dd[k], j + dd[k + 1], A[i][j] == 'B');\n    }\n\n    int ans[2] = { 0, 0 };\n    REP(i, 0, 2) REP(j, 0, H) REP(k, 0, W) if(s[1 - i][j][k] && !s[i][j][k]) ans[i]++;\n    cout << ans[0] << \" \" << ans[1] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nint main()\n{\n  int w, h;\n  while (cin >> w >> h && h != 0) {\n    vector<vector<char> > grid(h, vector<char>(w));\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        cin >> grid[i][j];\n      }\n    }\n    \n    int white = 0, black = 0;\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        if (grid[i][j] != '.') {\n          continue;\n        }\n        int color = 0;  // uninitialized\n        queue<pair<int,int> > q;\n        q.push(make_pair(i, j));\n        grid[i][j] = ' ';\n        int count = 1;\n        while (!q.empty()) {\n          const pair<int,int> p = q.front();\n          q.pop();\n          const int a = p.first;\n          const int b = p.second;\n          for (int d = 0; d < 4; d++) {\n            static const int dir_i[] = {1, -1, 0, 0};\n            static const int dir_j[] = {0, 0, 1, -1};\n            const int k = a + dir_i[d];\n            const int l = b + dir_j[d];\n            if (0 <= k && k < h && 0 <= l && l < w) {\n              if (grid[k][l] == 'W') {\n                if (color == 0 || color == 1) {\n                  color = 1;\n                } else {\n                  color = -1;\n                }\n              } else if (grid[k][l] == 'B') {\n                if (color == 0 || color == 2) {\n                  color = 2;\n                } else {\n                  color = -1;\n                }\n              } else if (grid[k][l] == '.') {\n                grid[k][l] = ' ';\n                q.push(make_pair(k, l));\n                count++;\n              }\n            }\n          }\n        }\n        if (color == 1) {\n          white += count;\n        } else if (color == 2) {\n          black += count;\n        }\n      }\n    }\n    cout << black << ' ' << white << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <string>\nusing namespace std;\n\nint w, h, white, black;\nchar a[52][52];\nint dx[4] = {0, 0, -1, 1};\nint dy[4] = {-1, 1, 0, 0};\n\nvoid dfs(int x, int y, char c){\n\tfor(int i=0 ; i < 4 ; i++ ){\n\t\tint mx = x + dx[i], my = y + dy[i];\n\t\tif( mx < 0 || my < 0 || w <= mx || h <= my ) continue;\n\t\t\n\t\tif( c == 'W' ){\n\t\t\tif( a[y][x] == 'W' || a[y][x] == 'w' ){\n\t\t\t\tif( a[my][mx] == '.' ){\n\t\t\t\t\ta[my][mx] = 'w';\n\t\t\t\t\tdfs(mx, my, c);\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( c == 'B' ){\n\t\t\tif( a[y][x] == 'B' || a[y][x] == 'b' ){\n\t\t\t\tif( a[my][mx] == 'w' || a[my][mx] == 'W'){\n\t\t\t\t\tif( a[y][x] == 'b' ){\n\t\t\t\t\t\ta[y][x] = '?';\n\t\t\t\t\t}\n\t\t\t\t\tif( a[my][mx] == 'w' ){\n\t\t\t\t\t\ta[my][mx] = '?';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif( a[my][mx] == '.' ){\n\t\t\t\t\ta[my][mx] = 'b';\n\t\t\t\t\tdfs(mx, my, c);\n\t\t\t\t}\n\t\t\t}\n\t\t}else if( c == '?' ){\n\t\t\tif( a[y][x] == 'w' || a[y][x] == 'b' ){\n\t\t\t\ta[y][x] = '?';\n\t\t\t}\n\t\t\tif( a[my][mx] == 'w' || a[my][mx] == 'b' ){\n\t\t\t\ta[my][mx] = '?';\n\t\t\t\tdfs(mx, my, c);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid solve(){\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\tif( a[y][x] == 'W' ){\t\t\t\t\n\t\t\t\tdfs(x, y, 'W');\n\t\t\t}\n\t\t}\n\t}\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\tif( a[y][x] == 'B' ){\n\t\t\t\tdfs(x, y, 'B');\n\t\t\t}\n\t\t}\n\t}\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\tif( a[y][x] == '?' ){\n\t\t\t\tdfs(x, y, '?');\n\t\t\t}\n\t\t}\n\t}\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\tif( a[y][x] == 'w' ) white++;\n\t\t\tif( a[y][x] == 'b' ) black++;\n\t\t}\n\t}\n}\n\nint main(){\n\twhile( cin >> w >> h , w || h ){\n\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\tcin >> a[y];\n\t\t}\n\t\twhite = black = 0;\n\t\tsolve();\n\t\tcout << black << \" \" << white << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\nusing namespace std;\nint w,h;\nchar ta[60][60];\nbool used[60][60];\nint fast=-1;\nvoid dfs(int i,int j){\n\tused[i][j]=1;\n\tif(ta[i][j]=='W'){\n\tif(fast==-1)fast=0;\n\telse if(fast==1){\n\tfast=2;\n\t}\n\treturn ;\n\t}\n\tif(ta[i][j]=='B'){\n\tif(fast==-1)fast=1;\n\telse if(fast==0){\n\tfast=2;\n\t}\n\treturn ;\n\t}\n\tif(i+1<h&&used[i+1][j]==0)dfs(i+1,j);\n\tif(i-1>=0&&used[i-1][j]==0)dfs(i-1,j);\n\tif(j+1<w&&used[i][j+1]==0)dfs(i,j+1);\n\tif(j-1>=0&&used[i][j-1]==0)dfs(i,j-1);\n}\n\nint main(){\n\twhile(true){\n\tcin>>w>>h;\n\tif(w==0&&h==0)break;\n\tfor(int i=0;i<60;i++)for(int j=0;j<60;j++)ta[i][j]=' ';\n\tfor(int i=0;i<h;i++){\n\tfor(int j=0;j<w;j++)\n\tcin>>ta[i][j];\n\t}\n\tint a=0,b=0;//W,B\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\tfast=-1;\n\t\tfor(int i=0;i<60;i++)for(int j=0;j<60;j++)used[i][j]=0;\n\t\tif(ta[i][j]!='W'&&ta[i][j]!='B')dfs(i,j);\n\t\telse continue;\n\t\tif(fast==0){a++;}\n\t\telse if(fast==1){b++;}\n\t\t}\n\t}\n\tcout<<b<<\" \"<<a<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<vector>\nint W,H;\nint nb,nw;\nint n,flag=1,flag2;\nchar field[50][50];\n#define W_MAX 50\n#define H_MAX 50\n#define Black true\n#define White false\n/*-------------------------\nconst int dx[]={-1,0,1,0};\nconst int dy[]={0,-1,0,1};\n--------------------------*/\nint umerub(int x,int y){\n\tn++;\n\tfield[y][x]='X';\n\n\tif(y!=0&&field[y-1][x]=='.')umerub(x,y-1);\n\tif(x!=0&&field[y][x-1]=='.')umerub(x-1,y);\n\tif(y!=H-1&&field[y+1][x]=='.')umerub(x,y+1);\n\tif(x!=W-1&&field[y][x+1]=='.')umerub(x+1,y);\n\tif(y!=0&&field[y-1][x]=='W')flag=0;\n\tif(x!=0&&field[y][x-1]=='W')flag=0;\n\tif(y!=H-1&&field[y+1][x]=='W')flag=0;\n\tif(x!=W-1&&field[y][x+1]=='W')flag=0;\n\tif(y!=0&&field[y-1][x]=='B')flag2=1;\n\tif(x!=0&&field[y][x-1]=='B')flag2=1;\n\tif(y!=H-1&&field[y+1][x]=='B')flag2=1;\n\tif(x!=W-1&&field[y][x+1]=='B')flag2=1;\n\treturn n;\n}\n\nint umeruw(int x,int y){\n\tn++;\n\tfield[y][x]='F';\n\tif(y!=0&&field[y-1][x]=='X')umeruw(x,y-1);\n\tif(x!=0&&field[y][x-1]=='X')umeruw(x-1,y);\n\tif(y!=H-1&&field[y+1][x]=='X')umeruw(x,y+1);\n\tif(x!=W-1&&field[y][x+1]=='X')umeruw(x+1,y);\n\tif(y!=0&&field[y-1][x]=='B')flag=0;\n\tif(x!=0&&field[y][x-1]=='B')flag=0;\n\tif(y!=H-1&&field[y+1][x]=='B')flag=0;\n\tif(x!=W-1&&field[y][x+1]=='B')flag=0;\n\tif(y!=0&&field[y-1][x]=='W')flag2=1;\n\tif(x!=0&&field[y][x-1]=='W')flag2=1;\n\tif(y!=H-1&&field[y+1][x]=='W')flag2=1;\n\tif(x!=W-1&&field[y][x+1]=='W')flag2=1;\n\treturn n;\n}\n\nint main(){\n\twhile(cin>>W>>H,W|H){\n\t\tnb=0;\n\t\tnw=0;\n\t\tn=0;\n\t\tflag=1;\n\t\tflag2=0;\n\t\tfor(int i=0;i<50;i++){\n\t\t\tfor(int j=0;j<50;j++){\n\t\t\t\tfield[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<H;i++){\n\t\t\tcin>>field[i];\n\t\t}\n\t\tfor(int i=0;i<H;i++){\n\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\tif(field[i][j]=='.'){\n\t\t\t\t\tnb+=umerub(j,i)*flag*flag2;\n\t\t\t\t\tflag=1;\n\t\t\t\t\tflag2=0;\n\t\t\t\t\tn=0;\n\t\t\t\t\tnw+=umeruw(j,i)*flag*flag2;\n\t\t\t\t\tflag=1;\n\t\t\t\t\tflag2=0;\n\t\t\t\t\tn=0;\n\t\t\t\t\t/*cout<<endl;\n\t\t\t\t\tfor(int k=0;k<H;k++){\n\t\t\tcout<<field[k]<<endl;\n\t\t\t\t\t}\n\t\t\t\t\tcout<<nb<<\" \"<<nw<<endl;*/\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<nb<<\" \"<<nw<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<vector>\nint W,H;\nint nb,nw;\nint n,flag=1,flag2;\nchar field[50][50];\n#define Black true\n#define White false\n\nint umerub(int y,int x){\n\tn++;\n\tfield[x][y]=',';\n\tif(x!=0&&field[x-1][y]=='.')umerub(y,x-1);\n\tif(y!=0&&field[x][y-1]=='.')umerub(y-1,x);\n\tif(x!=H-1&&field[x+1][y]=='.')umerub(y,x+1);\n\tif(y!=W-1&&field[x][y+1]=='.')umerub(y+1,x);\n\tif(x!=0&&field[x-1][y]=='W')flag=0;\n\tif(y!=0&&field[x][y-1]=='W')flag=0;\n\tif(x!=H-1&&field[x+1][y]=='W')flag=0;\n\tif(y!=W-1&&field[x][y+1]=='W')flag=0;\n\tif(x!=0&&field[x-1][y]=='B')flag2=1;\n\tif(y!=0&&field[x][y-1]=='B')flag2=1;\n\tif(x!=H-1&&field[x+1][y]=='B')flag2=1;\n\tif(y!=W-1&&field[x][y+1]=='B')flag2=1;\n\treturn n;\n}\n\nint umeruw(int y,int x){\n\tn++;\n\tfield[x][y]='W';\n\tif(x!=0&&field[x-1][y]==',')umeruw(y,x-1);\n\tif(y!=0&&field[x][y-1]==',')umeruw(y-1,x);\n\tif(x!=H-1&&field[x+1][y]==',')umeruw(y,x+1);\n\tif(y!=W-1&&field[x][y+1]==',')umeruw(y+1,x);\n\tif(x!=0&&field[x-1][y]=='B')flag=0;\n\tif(y!=0&&field[x][y-1]=='B')flag=0;\n\tif(x!=H-1&&field[x+1][y]=='B')flag=0;\n\tif(y!=W-1&&field[x][y+1]=='B')flag=0;\n\tif(x!=0&&field[x-1][y]=='W')flag2=1;\n\tif(y!=0&&field[x][y-1]=='W')flag2=1;\n\tif(x!=H-1&&field[x+1][y]=='W')flag2=1;\n\tif(y!=W-1&&field[x][y+1]=='W')flag2=1;\n\treturn n;\n}\n\nint main(){\n\twhile(cin>>W>>H,W|H){\n\t\tnb=0;\n\t\tnw=0;\n\t\tn=0;\n\t\tflag=1;\n\t\tflag2=0;\n\t\tfor(int i=0;i<H;i++){\n\t\t\tcin>>field[i];\n\t\t}\n\tfor(int i=0;i<H;i++){\n\t\tfor(int j=0;j<W;j++){\n\t\t\tif(field[i][j]=='.'){\n\t\t\t\tnb+=umerub(j,i)*flag*flag2;\n\t\t\t\tflag=1;\n\t\t\t\tflag2=0;\n\t\t\t\tn=0;\n\t\t\t\tnw+=umeruw(j,i)*flag*flag2;\n\t\t\t\tflag=1;\n\t\t\t\tflag2=0;\n\t\t\t\tn=0;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<nb<<\" \"<<nw<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n\nint dfs(std::vector<std::vector<char> > map, int w, int h, char other_color) {\n    int dx[] = {0, 0, 1, -1};\n    int dy[] = {1, -1, 0, 0};\n\n    int first;\n    int second;\n\n    int total = 0;\n    int count; \n    bool check;\n\n    for (int i = 1; i <= h; i++) {\n        for (int j = 1; j <= w; j++) {\n            if (map[i][j] == '.') {\n                count = 0;\n                check = true;\n                std::stack<std::pair<int, int> > st;\n                st.push(std::make_pair(i, j));\n\n                while (1) {\n                    if (st.empty() == 1) {\n                       break; \n                    }\n                    first = st.top().first;\n                    second = st.top().second;\n                    st.pop();\n                    for (int k = 0; k < 4; k++) {\n                       if (map[first + dx[k]][second + dy[k]] == '.') {\n                            st.push(std::make_pair(first + dx[k], second + dy[k])); \n                            map[first + dx[k]][second + dy[k]] = '#';\n                            ++count;\n                       } else if (map[first + dx[k]][second + dy[k]] == other_color) {\n                            check = false; \n                       }\n                    }\n                }\n                if (check == true) {\n                    total += count;\n                } else {\n                    check = true;\n                }\n            }\n        }\n    }\n    return total; \n}\n\nint main(void) {\n    int w;\n    int h;\n    std::cin >> w >> h;\n\n    std::vector<std::vector<char> > map_b(h+2, std::vector<char>(w+2, 'B'));\n    std::vector<std::vector<char> > map_w(h+2, std::vector<char>(w+2, 'W'));\n\n    for (int i = 1; i <= h; i++) {\n        for (int j = 1; j <= w; j++) {\n            std::cin >> map_b[i][j];\n            map_w[i][j] = map_b[i][j];\n        }\n    }\n    std::cout << dfs(map_b, w, h, 'W') << \" \" << dfs(map_w, w, h, 'B') << std::endl;\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint w, h;\nvector<string> feeld;\n\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {1, 0, -1, 1};\n\nvoid rec(int x, int y, int& add, int& id) {\n\tif (feeld[y][x] == 'B') {\n\t\tid |= 1 << 0;\n\t\treturn;\n\t}\n\t\n\tif (feeld[y][x] == 'W') {\n\t\tid |= 1 << 1;\n\t\treturn;\n\t}\n\t\n\tfeeld[y][x] = '-';\n\tadd++;\n\t\n\tfor (int i = 0; i < 4; i++) {\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\tif (!(0 <= nx && nx < w && 0 <= ny && ny < h)) continue;\n\t\tif (feeld[ny][nx] == '-') continue;\n\t\trec(nx, ny, add, id);\n\t}\n}\n\nvoid solve() {\n\tint ansb = 0, answ = 0;\n\t\n\tfor (int i = 0; i < h; i++) {\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tif (feeld[i][j] == '.') {\n\t\t\t\tint add = 0, id = 0;\n\t\t\t\trec(j, i, add, id);\n\t\t\t\tif (id == 1) ansb += add;\n\t\t\t\tif (id == 2) answ += add;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << ansb << \" \" << answ << endl;\n}\n\nint main() {\n\twhile (1) {\n\t\tcin >> w >> h; if (w == 0 && h == 0) break;\n\t\tfeeld.assign(h, \"\");\n\t\tfor (int i = 0; i < h; i++) cin >> feeld[i];\n\t\t\n\t\tsolve();\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint w, h;\nchar data[50][50];\nint cnt;\nchar bw;\nbool flag;\n \nvoid rec(int x, int y) {\n  static int d[4][2] = {{1,0},{0,1},{-1,0},{0,-1}};\n  data[y][x] = '#';\n  cnt++;\n  for(int i = 0; i < 4; i++) {\n    int nx = x + d[i][0];\n    int ny = y + d[i][1];\n    if(nx < 0 || nx >= w) continue;\n    if(ny < 0 || ny >= h) continue;\n    if(data[ny][nx] == '#') continue;\n    if(data[ny][nx] != '.') {\n      if(bw == '.') bw = data[ny][nx];\n      else if(data[ny][nx] != bw) flag = false;\n      continue;\n    }\n    rec(nx, ny);\n  }\n}\n \nint main() {\n  while(1) {\n    cin >> w >> h;\n    if(w == 0 && h == 0) break;\n    for(int i = 0; i < h; i++) {\n      for(int j = 0; j < w; j++) {\n        cin >> data[i][j];\n      }\n    }\n    int numW = 0;\n    int numB = 0;\n    for(int i = 0; i < h; i++) {\n      for(int j = 0; j < w; j++) {\n        if(data[i][j] == '.') {\n          cnt = 0;\n          bw = '.';\n          flag = true;\n          rec(j, i);\n          if(flag) {\n            if(bw == 'B') numB += cnt;\n            else if(bw == 'W') numW += cnt;\n          }\n        }\n      }\n    }\n    cout << numB << ' ' << numW << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,N) for(int i=0;i<(N);i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\nusing namespace std;\nconst long long MOD = 1e9 + 7;\nconst long long INF = 1e12;\nconst int inf = 1e9;\ntypedef long long ll;\ntypedef pair<ll,int> P;\ntypedef set<int> S;\nll n;\nint w,h;\nint dx[]={1,0,-1,0},dy[]={0,1,0,-1};\nchar maze[60][60];\nint area_w[60][60];\nint area_b[60][60];\nint white=0,black=0;\nvoid bfs1(int a,int b){ //black\n    queue<pair<int,int>> q;\n    q.push({a,b});\n    bool check=0;\n    while(!q.empty()){\n        int inow=q.front().first,jnow=q.front().second;\n        q.pop();\n        for(int i=0;i<4;i++){\n            int inew=inow+dx[i],jnew=jnow+dy[i];\n            if(inew<h && inew>-1 && jnew<w && jnew>-1 && area_b[inew][jnew]==0 && maze[inew][jnew]=='.' ){\n                area_b[inew][jnew]=1;\n                q.push({inew,jnew});\n            }\n        }\n    }\n}\n\nvoid bfs2(int a,int b){ //white\n    queue<pair<int,int>> q;\n    q.push({a,b});\n    bool check=0;\n    while(!q.empty()){\n        int inow=q.front().first,jnow=q.front().second;\n        q.pop();\n        for(int i=0;i<4;i++){\n            int inew=inow+dx[i],jnew=jnow+dy[i];\n            if(inew<h && inew>-1 && jnew<w && jnew>-1 && area_w[inew][jnew]==0 && maze[inew][jnew]=='.' ){\n                area_w[inew][jnew]=1;\n                q.push({inew,jnew});\n            }\n        }\n    }\n}\n\nint main(){\n    while(1){\n        cin>>w>>h;\n        white=0;\n        black=0;\n        if(w==0 && h==0) break;\n        for(int i=0;i<60;i++){\n            for(int j=0;j<60;j++){\n                area_w[i][j]=0;\n                area_b[i][j]=0;\n                maze[i][j]='0';\n            }\n        }\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                cin>>maze[i][j];\n            }\n        }\n        /*\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                cout<<maze[i][j];\n            }\n            cout<<endl;\n        }*/\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                if(maze[i][j]=='B') bfs1(i,j);\n                else if(maze[i][j]=='W') bfs2(i,j);\n            }\n        }\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                if(area_w[i][j]==1 && area_b[i][j]==0) white++;\n                if(area_w[i][j]==0 && area_b[i][j]==1) black++;\n            }\n        }/*\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                cout<<area_b[i][j];\n            }\n            cout<<endl;\n        }\n        //cout<<endl;\n        /*for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                cout<<area_w[i][j];\n            }\n            cout<<endl;\n        }*/\n        cout<<black<<\" \"<<white<<endl;\n        //cout<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nint w,h,d[5]={1,0,-1,0,1},i,j,M,Y,X;std::string s[50];int r(int y,int x){if(s[y][x]!=41&&s[y][x]!=20)s[y][x]|=M;for(int i=0;i<5;){Y=y+d[i];X=x+d[++i];if(Y<0||h<=Y||X<0||w<=X||s[Y][X]==41||s[Y][X]==20||(s[Y][X]&M)==M)continue;r(Y,X);}}main(){for(;std::cin>>w>>h,w|h;printf(\"%d %d\\n\",X,Y)){for(M=i=0;i<h;i++)for(std::cin>>s[i],j=w;j-->0;)s[i][j]-=46;for(i=h;i-->0;)for(j=w;j-->0;M=2*(X==41)+(X==20),M&&r(i,j))X=s[i][j];for(X=Y=i=0;i<h;i++)for(j=w;j-->0;s[i][j]==2&&Y++)s[i][j]==1&&X++;}}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\nusing namespace std;\ntypedef pair<int ,int> P;\nchar grid[50][50];\nint W,H;\nint dx[] = {0,0,1,-1},dy[] = {1,-1,0,0};\nchar c[2] = {'B','W'};\n\nint bfs(int sx,int sy,int k){\n  queue<P> que;\n  int res[2] = {0};\n  bool flag = true;\n  que.push(P(sx,sy));\n  while(!que.empty()){\n    P p = que.front();\n    que.pop(); \n\n    if(grid[p.first][p.second] == '.'){\n      grid[p.first][p.second] = c[k];\n      res[k]++;\n    } else continue;\n    for(int i = 0 ; i < 4 ; i++ ){\n      int nx = p.first + dx[i],ny = p.second + dy[i];\n      if(0 <= nx && nx < W && 0 <= ny && ny < H && grid[nx][ny] == '.'){\n\tque.push(P(nx,ny));\n\tif((nx+1 < W && grid[nx+1][ny] == c[!k])||\n\t   (nx-1 >= 0 && grid[nx-1][ny] == c[!k])||\n\t   (ny+1 < H && grid[nx][ny+1] == c[!k])||\n\t   (ny-1 >= 0 && grid[nx][ny-1] == c[!k]))flag = false;\n      }\n    }\n  }\n  if(flag == true)return res[k];\n  else return 0; \n}\n\nint main(){\n  while( cin >> W >> H , W+H ){\n\n    for(int i = 0 ; i < H ; i++ ){\n      for(int j = 0 ; j < W ; j++ ){\n\tcin >> grid[j][i];\n      }\n    }\n    int ans[2] = {0};\n    for(int k = 0 ; k < 2 ; k++ ){\n      for(int i = 0 ; i < H ; i++ ){\n\tfor(int j = 0 ; j < W ; j++ ){\n\t  if(grid[j][i] == '.'){\n\t    if((j+1 < W && grid[j+1][i] == c[k])||\n\t       (j-1 >= 0 && grid[j-1][i] == c[k])||\n\t       (i+1 < H && grid[j][i+1] == c[k])||\n\t       (i-1 >= 0 && grid[j][i-1] == c[k]))ans[k]+=bfs(j,i,k);\n\t  }\n\t}\n      }\n    }\n    cout << ans[0] <<\" \"<< ans[1] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<string>\n#include<cstring>\n#include<iostream>\n\nusing namespace std;\n\nint w,h;\nint fie[60][60];\nint painted[60][60][2];\nint res[2];\nint sx[4]={1,0,-1,0};\nint sy[4]={0,1,0,-1};\n\nvoid paint(int x,int y,int c){\n\tfor(int i=0;i<4;i++){\n\t\tint nx=x+sx[i],ny=y+sy[i];\n\t\tif(nx>=0 && nx<w && ny>=0 && ny<h){\n\t\t\tif(fie[nx][ny]==0 && painted[nx][ny][c]==0){\n\t\t\t\tpainted[nx][ny][c]=1;\n\t\t\t\tpaint(nx,ny,c);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w+h==0)break;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tstring str;\n\t\t\tcin >> str;\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(str[j]=='B')fie[j][i]=1;\n\t\t\t\tif(str[j]=='W')fie[j][i]=2;\n\t\t\t\tif(str[j]=='.')fie[j][i]=0;\n\t\t\t}\n\t\t}\n\t\tmemset(painted,0,sizeof(painted));\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(fie[j][i]==1)paint(j,i,0);\n\t\t\t\tif(fie[j][i]==2)paint(j,i,1);\n\t\t\t}\n\t\t}\n\t\tres[0]=res[1]=0;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(painted[j][i][0]==1 && painted[j][i][1]==0)res[0]++;\n\t\t\t\tif(painted[j][i][0]==0 && painted[j][i][1]==1)res[1]++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\",res[0],res[1]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <limits.h>\n#include <math.h>\n#include <set>\n#include <stack>\n#include <stdlib.h>\n#include <string>\n#include <vector>\n\n#define el endl\n#define fd fixed\n#define INF INT_MAX/2-1\n#define pb push_back\n\nusing namespace std;\n\nchar map[50][50];\nbool memoB[50][50];\nbool memoW[50][50];\n\nvoid search(int x, int y, int w, int h, char color) {\n  if (color == 'B') {\n    memoB[x][y] = true;\n  } else {\n    memoW[x][y] = true;\n  }\n  if (x > 0 && map[x-1][y] == '.') {\n    if ((color == 'B' && !memoB[x-1][y]) || (color == 'W' && !memoW[x-1][y])) {\n      search(x-1, y, w, h, color);\n    }\n  }\n  if (y > 0 && map[x][y-1] == '.') {\n    if ((color == 'B' && !memoB[x][y-1]) || (color == 'W' && !memoW[x][y-1])) {\n      search(x, y-1, w, h, color);\n    }\n  }\n  if (x < w-1 && map[x+1][y] == '.') {\n    if ((color == 'B' && !memoB[x+1][y]) || (color == 'W' && !memoW[x+1][y])) {\n      search(x+1, y, w, h, color);\n    }\n  }\n  if (y < h-1 && map[x][y+1] == '.') {\n    if ((color == 'B' && !memoB[x][y+1]) || (color == 'W' && !memoW[x][y+1])) {\n      search(x, y+1, w, h, color);\n    }\n  }\n}\n\nint main() {\n  int w, h, cntB, cntW, resB, resW;\n  char tmp;\n  while (cin >> w >> h, w | h) {\n    cntB = cntW = 0;\n    for (int i = 0; i < w; i++) {\n      for (int j = 0; j < h; j++) {\n        cin >> tmp;\n        map[i][j] = tmp;\n        if (tmp == '.') memoB[i][j] = memoW[i][j] = false;\n        if (tmp == 'B') memoB[i][j] = true, memoW[i][j] = false, cntB++;\n        if (tmp == 'W') memoB[i][j] = false, memoW[i][j] = true, cntW++;\n      }\n    }\n    for (int i = 0; i < w; i++) {\n      for (int j = 0; j < h; j++) {\n        if (map[i][j] == 'B') search(i, j, w, h, 'B');\n        if (map[i][j] == 'W') search(i, j, w, h, 'W');\n      }\n    }\n    resB = resW = 0;\n    for (int i = 0; i < w; i++) {\n      for (int j = 0; j < h; j++) {\n        if (memoB[i][j] && !memoW[i][j]) resB++;\n        if (!memoB[i][j] && memoW[i][j]) resW++;\n      }\n    }\n    cout << resB-cntB << \" \" << resW-cntW << el;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <tuple>\n#include <utility>\n\nconstexpr size_t m1 = -1;\nconstexpr size_t di[] = {m1, 0, 1, 0};\nconstexpr size_t dj[] = {0, m1, 0, 1};\n\nstd::vector<size_t> make_vector(size_t n, size_t x) {\n  return std::vector<size_t>(n, x);\n}\n\ntemplate <class Tp>\nstd::vector<Tp> make_vector(size_t n, const Tp& x) {\n  return std::vector<Tp>(n, x);\n}\n\ntemplate <class... Ts>\nauto make_vector(size_t n, size_t m, const Ts&... x) {\n  return std::vector<decltype(make_vector(m, x...))>(n, make_vector(m, x...));\n}\n\n\nusing zahyo = std::pair<size_t, size_t>;\nvoid bfs(const std::vector<std::string>& a,\n         std::queue<zahyo>& q, std::vector<std::vector<bool>>& b) {\n\n  size_t h = a.size();\n  size_t w = a[0].size();\n  while (!q.empty()) {\n    size_t i, j;\n    std::tie(i, j) = q.front();\n    q.pop();\n    for (int k = 0; k < 4; ++k) {\n      size_t ni = i + di[k];\n      size_t nj = j + dj[k];\n      if (!(ni < h && nj < w)) continue;\n      if (a[ni][nj] != '.') continue;\n      if (b[ni][nj]) continue;\n      b[ni][nj] = true;\n      q.emplace(ni, nj);\n    }\n  }\n}\n\nint testcase_ends() {\n  size_t h, w;\n  scanf(\"%zu %zu\", &w, &h);\n  if (h == 0 && w == 0) return 1;\n\n  std::queue<zahyo> qw, qb;\n  auto xb = make_vector(h, w, false);\n  auto xw = xb;\n\n  std::vector<std::string> a(h);\n  for (size_t i = 0; i < h; ++i) {\n    char buf[64];\n    scanf(\"%s\", buf);\n    a[i] = buf;\n    for (size_t j = 0; j < w; ++j) {\n      if (a[i][j] == 'W') {\n        qw.emplace(i, j);\n        // xw[i][j] = true;\n      } else if (a[i][j] == 'B') {\n        qb.emplace(i, j);\n        // xb[i][j] = true;\n      }\n    }\n  }\n\n  bfs(a, qw, xw);\n  bfs(a, qb, xb);\n\n  int black = 0;\n  int white = 0;\n  for (size_t i = 0; i < h; ++i) {\n    for (size_t j = 0; j < w; ++j) {\n      if (a[i][j] != '.') continue;\n      if (xb[i][j] && xw[i][j]) continue;\n      int c = 0;\n      if (xb[i][j]) c = +1;\n      if (xw[i][j]) c = -1;\n      if (c == 0) continue;\n      for (int k = 0; k < 4; ++k) {\n        size_t ni = i + di[k];\n        size_t nj = j + dj[k];\n        if (!(ni < h && nj < w)) continue;\n        if (c > 0 && a[ni][nj] == 'W') {\n          c = 0;\n          break;\n        }\n        if (c < 0 && a[ni][nj] == 'B') {\n          c = 0;\n          break;\n        }\n      }\n      if (c > 0) ++black;\n      if (c < 0) ++white;\n    }\n  }\n\n  printf(\"%d %d\\n\", black, white);\n  return 0;\n}\n\nint main() {\n  while (!testcase_ends()) {}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define MOD 1000000007\n#define rep(i,n) for(i=0;i<n;i++)\n#define loop(i,a,n) for(i=a;i<n;i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\nint main(void) {\n  int i,j;\n  int w,h;\n  int d[5]={0,1,0,-1,0};\n  while(1){\n    cin>>w>>h;\n    if(w+h==0)break;\n    vector<string> s(h);\n    rep(i,h)cin>>s[i];\n    queue<pii> q;\n    int white[50][50]={},black[50][50]={};\n\n    rep(i,h)rep(j,w)if(s[i][j]=='W')q.push(pii(i,j));\n    while(q.size()){\n      int x=q.front().first;\n      int y=q.front().second;\n      q.pop();\n      rep(i,4){\n\tint nx=x+d[i];\n\tint ny=y+d[i+1];\n\tif(nx>=0 && nx<h && ny>=0 && ny<w &&\n\t   s[nx][ny]=='.' && white[nx][ny]==0){\n\t  white[nx][ny]++;\n\t  q.push(pii(nx,ny));\n\t}\n      }\n    }\n\n    rep(i,h)rep(j,w)if(s[i][j]=='B')q.push(pii(i,j));\n    while(q.size()){\n      int x=q.front().first;\n      int y=q.front().second;\n      q.pop();\n      rep(i,4){\n        int nx=x+d[i];\n        int ny=y+d[i+1];\n        if(nx>=0 && nx<h && ny>=0 && ny<w &&\n           s[nx][ny]=='.' && black[nx][ny]==0){\n          black[nx][ny]++;\n          q.push(pii(nx,ny));\n\t}\n      }\n    }\n\n    int a=0,b=0;\n    rep(i,h)rep(j,w)\n      if(black[i][j]&&white[i][j]==0)a++;\n      else if(black[i][j]==0&&white[i][j])b++;\n    cout<<a<<\" \"<<b<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\nconst int MAX = 51;\nint H,W,cnt;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nstring str[MAX];\nbool BW[2];\n\nvoid dfs(int x,int y){  \n  if(x < 0 || x >= W || y < 0 || y >= H) return;\n  if(str[x][y] == 'B'){\n    BW[0] = true;\n    return;\n  }\n  else if(str[x][y] == 'W'){\n    BW[1] = true;\n    return;\n  }\n  if(str[x][y] == '.'){\n    cnt++;  \n    str[x][y] = '#';\n  }\n\n  for(int i = 0 ; i < 4 ; i++){\n    int nx = dx[i]+x;\n    int ny = dy[i]+y;\n\n    if(0 <= nx && nx < W && 0 <= ny && ny < H&&str[nx][ny] != '#'){\n      dfs(nx,ny);\n    }\n  }\n}\n\nint main(){\n  while(cin >> H >> W ,H + W){  \n    for(int i = 0 ; i < W ; i++){\n      cin >> str[i];\n    }\n    int BB = 0,WW = 0;\n    for(int i = 0 ; i < W ; i++){\n      for(int j = 0 ; j < H ; j++){\n\tcnt = 0;\n\tmemset(BW,false,sizeof(BW));\n\tdfs(i,j);\n\tif(BW[0]&&!BW[1]) BB += cnt;\n\telse if(!BW[0]&&BW[1]) WW += cnt;\n      }\n    }    \n\n    cout << BB << ' ' << WW << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <utility>\n#include <vector>\n#include <string>\n#include <functional>\nusing namespace std;\n\n#define gcu getchar_unlocked\n#define pcu putchar_unlocked\n#define _T template <typename T>\n#define _HT template <typename H, typename... T>\n#define _il inline\n#define _in _il int in\n#define _sc _il bool scan\n_T T in(int c){T n=0;bool m=false;while(isspace(c)){c=gcu();}if(c=='-')m=true,c=gcu();\n\tdo{n=10*n+(c-'0'),c=gcu();}while(c>='0'&&c<='9');return m?-n:n;}\n_in() {return in<int>(gcu());}\n_T T scan(T &n){int c=gcu();return c==EOF?false:(n=in<T>(c),true);}\n_sc(char &c){c=gcu();gcu();return c!=EOF;}\n#ifdef _GLIBCXX_STRING\n_sc(string &s){int c;s=\"\";\n\tfor(;;){c=gcu();if(c=='\\n'||c==' ')return true;else if(c==EOF)return false;s+=c;}}\n#endif\n_HT _sc(H &h, T&&... t){return scan(h)&&scan(t...);}\n#define _vo _il void out\n#define _vl _il void outl\n_vo(bool b) {pcu('0'+b);}\n_vo(const char *s){while(*s)pcu(*s++);}\n_vo(char c){pcu(c);}\n#ifdef _GLIBCXX_STRING\n_vo(string s){for(char c:s)pcu(c);}\n#endif\n_T _vo(T n){static char buf[20];char *p=buf;\n\tif(n<0)pcu('-'),n*=-1;if(!n)*p++='0';else while(n)*p++=n%10+'0',n/=10;\n\twhile (p!=buf)pcu(*--p);}\n_vl(){out('\\n');}\n#ifdef _GLIBCXX_VECTOR\n_T _vo(vector<T> &v){for(T &x:v)out(&x == &v[0]?\"\":\" \"),out(x);outl();}\n#endif\n_HT _vo(H&& h, T&&... t){out(h);out(move(t)...);}\ntemplate <typename... T> _vl(T&&... t){out(move(t)...);outl();}\n\nusing VV = vector<string>;\nusing P = pair<int, char>;\n\nint main() {\n\tfor (int w, h; w = in(), h = in();) {\n\t\tVV m(h);\n\t\tint B = 0, W = 0;\n\t\tfor (auto &y: m)\n\t\t\tscan(y);\n\t\tfunction<P(int, char)> f = [&](int x, int y) {\n\t\t\tchar &t = m[y][x];\n\t\t\tif (t == 'B' || t == 'W')\n\t\t\t\treturn P{0, t};\n\t\t\tt = 'x';\n\t\t\tint rx = 1, ry = 0;\n\t\t\tP r = {1, 'N'};\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint nx = x + rx, ny = y + ry;\n\t\t\t\tif (nx >= 0 && ny >= 0 && nx < w && ny < h && m[ny][nx] != 'x') {\n\t\t\t\t\tP x = f(nx, ny);\n\t\t\t\t\tr.first += x.first;\n\t\t\t\t\tr.second = x.second == 'C' ? 'C' :\n\t\t\t\t\t\tx.second + r.second == 'W' + 'B' ? 'C' :\n\t\t\t\t\t\tr.second == 'N' ? x.second : r.second;\n\t\t\t\t}\n\t\t\t\tswap(rx, ry *= -1);\n\t\t\t}\n\t\t\treturn r;\n\t\t};\n\t\tfor (int i = 0; i < h; i++)\n\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\tif (m[i][j] == '.') {\n\t\t\t\t\tP r = f(j, i);\n\t\t\t\t\tif (r.second == 'B')\n\t\t\t\t\t\tB += r.first;\n\t\t\t\t\telse if (r.second == 'W')\n\t\t\t\t\t\tW += r.first;\n\t\t\t\t}\n\t\toutl(B, ' ', W);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n\nusing namespace std;\n\nchar ground[60][60]={'*'};\n\nvoid jin_w(int i,int j){\n  if(ground[i][j-1]=='.'){\n    ground[i][j-1]='w';\n    jin_w(i,j-1);\n  }\n  else if(ground[i][j-1]=='b'){\n    ground[i][j-1]='*';\n    jin_w(i,j-1);\n  }\n  if(ground[i+1][j]=='.'){\n    ground[i+1][j]='w';\n    jin_w(i+1,j);\n  }\n  else if(ground[i+1][j]=='b'){\n    ground[i+1][j]='*';\n    jin_w(i+1,j);\n  }\n  if(ground[i][j+1]=='.'){\n    ground[i][j+1]='w';\n    jin_w(i,j+1);\n  }\n  else if(ground[i][j+1]=='b'){\n    ground[i][j+1]='*';\n    jin_w(i,j+1);\n  }\n  if(ground[i-1][j]=='.'){\n    ground[i-1][j]='w';\n    jin_w(i-1,j);\n  }\n  else if(ground[i-1][j]=='b'){\n    ground[i-1][j]='*';\n    jin_w(i-1,j);\n  } \n}\n\nvoid jin_b(int i,int j){\n  if(ground[i][j-1]=='.'){\n    ground[i][j-1]='b';\n    jin_b(i,j-1);\n  }\n  else if(ground[i][j-1]=='w'){\n    ground[i][j-1]='*';\n    jin_b(i,j-1);\n  }\n  if(ground[i+1][j]=='.'){\n    ground[i+1][j]='b';\n    jin_b(i+1,j);\n  }\n  else if(ground[i+1][j]=='w'){\n    ground[i+1][j]='*';\n    jin_b(i+1,j);\n  }\n  if(ground[i][j+1]=='.'){\n    ground[i][j+1]='b';\n    jin_b(i,j+1);\n  }\n  else if(ground[i][j+1]=='w'){\n    ground[i][j+1]='*';\n    jin_b(i,j+1);\n  }\n  if(ground[i-1][j]=='.'){\n    ground[i-1][j]='b';\n    jin_b(i-1,j);\n  }\n  else if(ground[i-1][j]=='w'){\n    ground[i-1][j]='*';\n    jin_b(i-1,j);\n  } \n}\n\nint main(){\n  int w,h;\n\n  while(cin>>w>>h,w,h){\n    int cnt_w=0;\n    int cnt_b=0;\n    \n    // fill(begin(ground),end(ground),\"*\");\n      \n    for(int i=1;i<h+1;++i){\n      for(int j=1;j<w+1;++j){\n\tcin>>ground[i][j];\n      }\n    }\n    for(int i=1;i<h+1;++i){\n      for(int j=1;j<w+1;++j){\n\tif(ground[i][j]=='W')\n\t  jin_w(i,j);\n\telse if(ground[i][j]=='B')\n\t  jin_b(i,j);\n      }\n    }\n    for(int i=1;i<h+1;++i){\n      for(int j=1;j<w+1;++j){\n\tif(ground[i][j]=='w')\n\t  cnt_w++;\n\telse if(ground[i][j]=='b')\n\t  cnt_b++;\n      }\n    }\n    cout<<cnt_b<<' '<<cnt_w<<endl;\n\n    for(int i=0;i<60;++i){\n      for(int j=0;j<60;++j){\n\tground[i][j]='*';\n      }\n    }\n    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nvoid paint(const vector<string> &field, int r, int c, vector<vector<bool>> &buf) {\n    const int R = field.size();\n    const int C = field[0].size();\n    const char ch = field[r][c];\n    queue<pair<int,int>> q;\n    q.push(make_pair(r, c));\n    buf[r][c] = true;\n    while(!q.empty()) {\n        const int cur_r = q.front().first;\n        const int cur_c = q.front().second;\n        q.pop();\n        static const int DR[] = {0, -1, 0, 1};\n        static const int DC[] = {1, 0, -1, 0};\n        for(int dir = 0; dir < 4; ++dir) {\n            const int nr = cur_r + DR[dir];\n            const int nc = cur_c + DC[dir];\n            if(nr < 0 || nr >= R || nc < 0 || nc >= C) continue;\n            if(field[nr][nc] != ch && field[nr][nc] != '.') continue;\n            if(buf[nr][nc]) continue;\n            buf[nr][nc] = true;\n            q.push(make_pair(nr, nc));\n        }\n    }\n}\n\nbool solve() {\n    int R, C;\n    if(!(cin >> C >> R)) return false;\n    if(!R && !C) return false;\n    vector<string> field(R);\n    for(string &s : field) {\n        cin >> s;\n    }\n    vector<vector<bool>> white(R, vector<bool>(C));\n    vector<vector<bool>> black(R, vector<bool>(C));\n    for(int r = 0; r < R; ++r) {\n        for(int c = 0; c < C; ++c) {\n            if(field[r][c] == 'W') {\n                paint(field, r, c, white);\n            } else if(field[r][c] == 'B') {\n                paint(field, r, c, black);\n            }\n        }\n    }\n    int w = 0, b = 0;\n    for(int r = 0; r < R; ++r) {\n        for(int c = 0; c < C; ++c) {\n            if(field[r][c] == '.') {\n                if(white[r][c] && !black[r][c]) ++w;\n                else if(!white[r][c] && black[r][c]) ++b;\n            }\n        }\n    }\n    cout << b << ' ' << w << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <utility>\n#include <ctime>\n#define INF 999999999\n#define mod 1000000007\n \n#define rep(i,n) for(int i=0;i<int(n);i++)\n#define rrep(i,n) for(int i=(n);i>=0;i--)\n#define REP(i,a,b) for(int i=(a);i<int(b);i++)\n#define all(x) (x).begin(),x.end()\n#define pb push_back\n#define MOD(x) (x%(mod))\nusing namespace std;\n \ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\n \nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nbool debug=false;\n/*---------------------------------------------------*/\n \nchar d[55][55];\nint black,white;\nint w,h;\n \nvoid init(){\n  rep(i,55){\n    rep(j,55){\n      d[i][j]='.';\n    }\n  }\n  black=white=0;\n}\n \nvoid bfs(int sy,int sx){\n  d[sy][sx]='#';\n  if(debug)cout<<\"start\"<<endl;\n  if(debug)rep(i,h){rep(j,w)cout<<d[i][j]<<\" \";cout<<endl;}\n  int cnt=1;\n  bool bb=false,ww=false;\n  queue<int>q;\n  q.push(sx);q.push(sy);\n  while(!q.empty()){\n    int x,y;\n    x=q.front();q.pop();\n    y=q.front();q.pop();\n    rep(i,4){\n      if(0<=x+dx[i]&&x+dx[i]<w&&0<=y+dy[i]&&y+dy[i]<h&&d[y+dy[i]][x+dx[i]]!='#'){\n    if(d[y+dy[i]][x+dx[i]]=='W'){\n      ww=true;\n    }else if(d[y+dy[i]][x+dx[i]]=='B'){\n      bb=true;\n    }else{\n      cnt++;\n      q.push(x+dx[i]);q.push(y+dy[i]);\n      d[y+dy[i]][x+dx[i]]='#';\n    }\n      }\n    }\n  }\n  if(!bb&&ww)white+=cnt;\n  else if(bb&&!ww)black+=cnt;\n}\n \nint main(){\n  while(cin>>w>>h){\n    if(w==0&&h==0)break;\n    init();\n    rep(i,h)rep(j,w)cin>>d[i][j];\n    rep(i,h)rep(j,w)if(d[i][j]=='.')bfs(i,j);\n    cout<<black<<\" \"<<white<<endl;\n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define int\t\t\t\tlong long\n#define FOR( i, m, n )  for( int (i) = (m); (i) < (n); (i)++ )\n#define REP( i, n )     FOR( i, 0, n )\n#define REPR( i, m )\tfor( int (i) = (m); (i) >= 0; (i)-- )\n#define REPONE( i, n )\tFOR( i, 1, n + 1 )\n#define ALL( a )        (a).begin(), (a).end()\n#define MP\t\t\t\tmake_pair\n#define X\t\t\t\tfirst.first\n#define Y\t\t\t\tfirst.second\n\ntypedef pair<int, int> P;\n\ntemplate<class T>bool chmax( T& a, const T& b ) { if( a < b ) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin( T& a, const T& b ) { if( a > b ) { a = b; return 1; } return 0; }\n\nconst int INF = 1e9;\nconst int MOD = 1e9 + 7;\n\nint dx[4] = { 1, 0, -1, 0 };\nint dy[4] = { 0, 1, 0, -1 };\n\nchar island[51][51];\nint W, H;\nint black, white, cnt = 0;\nbool b, w;\n\nvoid dfs( int x, int y ) {\n\tREP( i, 4 ) {\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\n\t\tif( nx >= 0 && nx < W && ny >= 0 && ny < H ) {\n\t\t\tif( island[nx][ny] == 'B' ) b = true;\n\t\t\tif( island[nx][ny] == 'W' ) w = true;\n\n\t\t\tif( island[nx][ny] == '.' ) {\n\t\t\t\tisland[nx][ny] = '-';\n\t\t\t\tcnt++;\n\t\t\t\tdfs( nx, ny );\n\t\t\t}\n\t\t}\n\t}\n\n}\n\n\nsigned main() {\n\twhile( cin >> W >> H, W, H ) {\n\t\tREP( i, H ) {\n\t\t\tREP( j, W ) {\n\t\t\t\tcin >> island[j][i];\n\t\t\t}\n\t\t}\n\n\t\tblack = 0; white = 0;\n\t\tREP( i, H ) {\n\t\t\tREP( j, W ) {\n\t\t\t\tif( island[j][i] == '.' ) {\n\t\t\t\t\tb = false; w = false;\n\t\t\t\t\tcnt = 0;\n\t\t\t\t\tisland[j][i] = '-';\n\n\t\t\t\t\tdfs( j, i );\n\n\t\t\t\t\tif( b & !w ) black += cnt + 1;\n\t\t\t\t\tif( !b & w ) white += cnt + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n/*\n\t\tREP( i, H ) {\n\t\t\tREP( j, W ) {\n\t\t\t\tcout << island[j][i] << \" \";\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n*/\n\t\tcout << black << \" \" << white << endl;\n\t\t\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <cctype>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <queue>\n#include <stack>\n#include <map>\nusing namespace std;\n \n#define REP(i, s, e) for (int i = (s); i < (e); i++)\n#define REPI(i, s, e) for (int i = (s); i <= (e); i++)\n#define rep(i, n) REP(i, 0, n)\n#define repi(i, n) REPI(i, 0, n)\n#define ALL(v) (v).begin(), (v).end()\n \n#define dump(x) (cout << #x << \" = \" << x << endl)\n#define dump2(x, y) (cout << \"(\" << #x << \", \" << #y << \") = (\" << x << \", \" << y << \")\" << endl)\n#define dump3(x, y, z) (cout << \"(\" << #x << \", \" << #y << \", \" << #z << \") = (\" << x << \", \" << y << \", \"<< z << \")\" << endl)\n \ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nint w, h;\n\n#define MAX 51\nchar brd[MAX][MAX];\nbool done[MAX][MAX];\nbool calc_done[MAX][MAX];\n\nint dx[] = { 0, 0, -1, 1 };\nint dy[] = { -1, 1, 0, 0 };\n\n#define EMPTY 0\n#define BLACK 1\n#define WHITE 2\n\nint only(int y, int x)\n{\n\tif (!(0 <= y && y < h)) return EMPTY;\n\tif (!(0 <= x && x < w)) return EMPTY;\n\tif (done[y][x]) return EMPTY;\n\tdone[y][x] = true;\n\n\tif (brd[y][x] == 'B')\n\t\treturn BLACK;\n\telse if (brd[y][x] == 'W')\n\t\treturn WHITE;\n\n\tint code = EMPTY;\n\tif (brd[y][x] == '.') {\n\t\trep(i, 4) \n\t\t\tcode |= only(y+dy[i], x+dx[i]);\n\t}\n\treturn code;\n}\n\nint calc(int y, int x)\n{\n\tif (!(0 <= y && y < h)) return 0;\n\tif (!(0 <= x && x < w)) return 0;\n\tif (calc_done[y][x]) return 0;\n\tcalc_done[y][x] = true;\n\tif (brd[y][x] != '.') return 0;\n\n\tint cnt = 1;\n\trep(i, 4)\n\t\tcnt += calc(y+dy[i], x+dx[i]);\n\treturn cnt;\n}\n\nint main(void)\n{\n\twhile (cin >> w >> h, w|h) {\n\t\trep(j, h) rep(i, w) cin >> brd[j][i];\n\n\t\tint ww, bb;\n\t\tww = bb = 0;\n\n\t\tmemset(calc_done, 0, sizeof(calc_done));\n\t\trep(j, h) {\n\t\t\trep(i, w) {\n\t\t\t\tmemset(done, 0, sizeof(done));\n\n\t\t\t\tint c = only(j, i);\n\t\t\t\tif ((c&BLACK) && (c&WHITE))\n\t\t\t\t\tcontinue;\n\t\t\t\telse if (c&BLACK) {\n\t\t\t\t\tbb += calc(j, i);\n\t\t\t\t} else if (c&WHITE) {\n\t\t\t\t\tww += calc(j, i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d %d\\n\", bb, ww);\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<numeric>\n#include<vector>\n#include<set>\n#include<map>\n#include <string>\n#include <math.h>\n#define cinf(n,x) for(int i=0;i<(n);i++) cin >> x[i];\ntypedef long long int ll;\nusing namespace std;\n\n// 4, , , \nint dy[4] = { 0, -1, 0, 1 };\nint dx[4] = { 1, 0, -1, 0 };\n\nbool inside(int y, int x, int H, int W) {\n    return 0 <= y && y < H && 0 <= x && x < W;\n}\nint w,h;\nchar field[55][55];\nint used[2][55][55];\nvoid dfs(int y,int x,int a){\n  if(inside(y,x,h,w)==false||field[y][x]!='.'||used[a][y][x]>0)return;\n  used[a][y][x]++;\n  for(int i=0;i<4;i++){\n    dfs(y+dy[i],x+dx[i],a);\n  }\n}\nint main(){\n  while(1){\n    cin >>w>>h;\n    if(w==0&&h==0)break;\n    for(int i=0;i<h;i++){\n      string s; cin >>s;\n      for(int j=0;j<w;j++){\n        field[i][j]=s[j];\n      }\n    }\n    int cntb=0; int cntw=0;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        used[0][i][j]=0;\n        used[1][i][j]=0;\n      }\n    }\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        if(field[i][j]=='B'){\n          for(int k=0;k<4;k++){\n            dfs(i+dy[k],j+dx[k],0);\n          }\n        }\n        else if(field[i][j]=='W'){\n          for(int k=0;k<4;k++){\n            dfs(i+dy[k],j+dx[k],1);\n          }\n        }\n      }\n    }\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        if(used[0][i][j]>0&&used[1][i][j]==0)cntb++;\n        else if(used[0][i][j]==0&&used[1][i][j]>0) cntw++;\n      }\n    }\n    cout << cntb << \" \" << cntw << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\nint w,h;\nvector<string> ss;\nbool is_white[103][103];\nbool is_black[103][103];\n\nvoid dfs(int x_,int y_,bool (*f_)[103],bool f2) {\n    //cout<<x_<<\",\"<<y_<<endl;\n    if(f_[x_][y_]||(ss[x_][y_]!='.'&&f2)) return;\n    f_[x_][y_]=true;\n    rep(i,4) {\n        int x = x_ + dx[i];\n        int y = y_ + dy[i];\n        if(0<=x&&x<ss.size() && 0<=y&&y<ss[x].size()) {\n            dfs(x,y,f_,true);\n        }\n    }\n}\n\nvoid solve() {\n    rep(i,103) rep(j,103) is_white[i][j]=is_black[i][j]=false;\n    ss.resize(w);\n    rep(i,h) {\n        string t; cin>>t;\n        ss[i] = t;\n    }\n    int ans_b=0,ans_w=0;\n    rep(i,ss.size()) {\n        rep(j,ss[i].size()) {\n            if(ss[i][j]=='B') dfs(i,j,is_black,false);\n            if(ss[i][j]=='W') dfs(i,j,is_white,false);\n        }\n    }\n    rep(i,ss.size()) rep(j,ss[i].size()) {\n        //cout<<i<<\",\"<<j<<\":\"<<is_white[i][j]<<\",\"<<is_black[i][j]<<ss[i][j]<<endl;\n        if(ss[i][j]=='.'&&(is_white[i][j]^is_black[i][j])) {\n           if(is_white[i][j]) ans_w++;\n           else ans_b++; \n        }\n    }\n    cout<<ans_b<<\" \"<<ans_w<<endl;\n    ss.clear();\n}\n\nint main() {\n    while(cin>>w>>h) {\n        if(w+h==0) return 0;\n        solve();\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define repn(i,n) for(int i=1;i<=n;i++)\n\nint n,m;\nchar x[55][55];\nbool used[55][55][2];\nint main(){\n    while (1) {\n        scanf(\"%d%d\",&m,&n);\n        if(n == 0) return 0;\n        rep(i,n) scanf(\"%s\",&x[i]);\n        rep(i,n) rep(j,m) used[i][j][0] = used[i][j][1] = 0;\n        int dx[4]={0,0,1,-1};\n        int dy[4]={1,-1,0,0};\n        queue<pair<int,int> >que[2];\n        rep(i,n) rep(j,m){\n            if(x[i][j] == '.'){\n                rep(k,4){\n                    int nx = i+dx[k];\n                    int ny = j+dy[k];\n                    if(0<=nx&&nx<n&&0<=ny&&ny<m){\n                        if(x[nx][ny] == 'B'){\n                            que[0].push(pair<int,int>(i,j)); //break;\n                        }\n                        if(x[nx][ny] == 'W'){\n                            que[1].push(pair<int,int>(i,j)); //break;\n                        }\n                    }\n                }\n            }\n        }\n        rep(q,2){\n            while(!que[q].empty()){\n                pair<int,int>p = que[q].front(); que[q].pop();\n                if(used[p.first][p.second][q]) continue;\n                used[p.first][p.second][q] = 1;\n                rep(k,4){\n                    int nx = p.first+dx[k];\n                    int ny = p.second+dy[k];\n                    if(0<=nx&&nx<n&&0<=ny&&ny<m){\n                        if(x[nx][ny] == '.'){\n                            que[q].push(pair<int,int>(nx,ny));\n                        }\n                    }\n                }\n            }\n        }\n        int ans[2]={};\n        rep(i,n)rep(j,m){\n            if(used[i][j][0] && !used[i][j][1]) ans[0]++;\n            if(used[i][j][1] && !used[i][j][0]) ans[1]++;\n        }\n        cout << ans[0] << \" \"  << ans[1] << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define ck(a,b) (0<=(a)&&(a)<b)\nusing namespace std;\nint dx[]={-1,1,0,0},dy[]={0,0,-1,1};\nchar land[60][60];\nint w,h;\nint cked[2][60][60],own[2][60][60];\nint ad(int y,int x,int c){\n\tcked[c][y][x]=1;\n\tint r=0,ny,nx;\n\trep(d,4){\n\t\tny=y+dy[d],nx=x+dx[d];\n\t\tif(!ck(ny,h)||!ck(nx,w)||cked[c][ny][nx])continue;\n\t\tif(land[ny][nx]==(c?'W':'B'))return 1;\n\t}\n\trep(d,4){\n\t\tny=y+dy[d],nx=x+dx[d];\n\t\tif(!ck(ny,h)||!ck(nx,w)||cked[c][ny][nx])continue;\n\t\tif(land[ny][nx]=='.')r=r||ad(ny,nx,c);\n\t\tif(r)return 1;\n\t}\n\treturn r;\n}\nvoid fl(int y,int x,int c){\n\town[c][y][x]=1;\n\trep(d,4){\n\t\tint ny=y+dy[d],nx=x+dx[d];\n\t\tif(ck(ny,h)&&ck(nx,w)&&!own[c][ny][nx]&&land[ny][nx]=='.')fl(ny,nx,c);\n\t}\n}\nint main(){\n\twhile(cin>>w>>h,w){\n\t\trep(i,h)cin>>land[i];\n\t\trep(i,h)rep(j,w)rep(k,2)cked[k][i][j]=own[k][i][j]=0;\n\t\trep(i,h)rep(j,w)rep(k,2)\n\t\tif(!cked[k][i][j]&&land[i][j]=='.')if(ad(i,j,k))fl(i,j,k);\n\t\tint ans[2]={0};\n\t\trep(i,h)rep(j,w)if(own[0][i][j]+own[1][i][j]==1)ans[own[0][i][j]]++;\n\t\tcout<<ans[1]<<\" \"<<ans[0]<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2014&lang=jpd>\n ============================================================\n =================================================================\n =============================================================\n ================================================================\n */\nint w,h;\nvector<int> solve(){\n    vector<int> res{0,0};\n    vector<vector<char>> a(h+2,vector<char>(w+2,'#'));\n    for(int i = 1; i <= h;i++) for(int j = 1; j <= w;j++) cin >> a[i][j];\n    vector<vector<int>> flag(h+2,vector<int>(w+2,0));\n    for(int i = 1; i <= h;i++){\n        for(int j = 1; j <= w;j++){\n            if(a[i][j] == '.') continue;\n            int cost = (a[i][j]=='W')?2:1;\n            int d[4] = {1,0,-1,0};\n            queue<pii> q;\n            for(int k = 0; k < 4;k++){\n                int ni = i + d[k], nj = j + d[k^1];\n                if(a[ni][nj] == '.') q.push(make_pair(ni,nj));\n            }\n            while(q.size()){\n                int x,y; tie(x,y) = q.front(); q.pop();\n                if(flag[x][y]&cost) continue;\n                flag[x][y] += cost;\n                for(int k = 0; k < 4;k++){\n                    int nx = x + d[k], ny = y + d[k^1];\n                    if(a[nx][ny] != '.') continue;\n                    q.push(make_pair(nx,ny));\n                }\n            }\n        }\n    }\n    for(int i = 1; i <= h;i++){\n        res[0] += count(flag[i].begin(),flag[i].end(),1);\n        res[1] += count(flag[i].begin(),flag[i].end(),2);\n    }\n    return res;\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    while(cin >> w >> h,w){\n        cout << solve() << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<algorithm>\n using namespace std;\n \n #define mkp make_pair\n #define F first\n #define S second\n #define rep(i,n) for(int i=0;i<n;i++)\n \n typedef vector<int> vint;\n typedef pair<int,int> pii;\n \nint main(){\n\tint w,h;\n\twhile(cin>>w>>h,w||h){\n\t\tvint tt(h,0);\n\t\tvector<vint> vv(w,tt);\n\t\tvector<vint> table=vv;\n\t\tint v[4][2]={0,1,1,0,0,-1,-1,0};\n\t\trep(i,w){\n\t\t\trep(j,h){\n\t\t\t\tchar t;\n\t\t\t\tcin>>t;\n\t\t\t\tif(t=='.') vv[i][j]=0;\n\t\t\t\telse if(t=='W'){\n\t\t\t\t\tvv[i][j]=1;\n\t\t\t\t\ttable[i][j]=-1;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tvv[i][j]=2;\n\t\t\t\t\ttable[i][j]=-1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i,w){\n\t\t\trep(j,h){\n\t\t\t\tif(vv[i][j]==0) continue;\n\t\t\t\telse{\n\t\t\t\t\tqueue<pii> q;\n\t\t\t\t\tq.push(mkp(i,j));\n\t\t\t\t\twhile(!q.empty()){\n\t\t\t\t\t\tpii t=q.front();\n\t\t\t\t\t\tq.pop();\n\t\t\t\t\t\trep(k,4){\n\t\t\t\t\t\t\tint x=t.F+v[k][0],y=t.S+v[k][1];\n\t\t\t\t\t\t\tif(x>=0&&y>=0&&x<w&&y<h){\n\t\t\t\t\t\t\t\tif(table[x][y]==0||table[x][y]==3-vv[i][j]){\n\t\t\t\t\t\t\t\t\ttable[x][y]+=vv[i][j];\n\t\t\t\t\t\t\t\t\tq.push(mkp(x,y));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint answ=0,ansb=0;\n\t\trep(i,w){\n\t\t\trep(j,h){\n\t\t\t\t//cout<<table[i][j]<<\" \";\n\t\t\t\tif(table[i][j]==1){\n\t\t\t\t\tansw++;\n\t\t\t\t}\n\t\t\t\telse if(table[i][j]==2){\n\t\t\t\t\tansb++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cout<<endl;\n\t\t}\n\t\t//cout<<endl;\n\t\tcout<<ansb<<\" \"<<answ<<endl;\n\t\t\n\t}\n\treturn 0;\n}\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <cctype>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <queue>\n#include <stack>\n#include <map>\nusing namespace std;\n \n#define REP(i, s, e) for (int i = (s); i < (e); i++)\n#define REPI(i, s, e) for (int i = (s); i <= (e); i++)\n#define rep(i, n) REP(i, 0, n)\n#define repi(i, n) REPI(i, 0, n)\n#define ALL(v) (v).begin(), (v).end()\n \n#define dump(x) (cout << #x << \" = \" << x << endl)\n#define dump2(x, y) (cout << \"(\" << #x << \", \" << #y << \") = (\" << x << \", \" << y << \")\" << endl)\n#define dump3(x, y, z) (cout << \"(\" << #x << \", \" << #y << \", \" << #z << \") = (\" << x << \", \" << y << \", \"<< z << \")\" << endl)\n \ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nint w, h;\n\n#define MAX 51\nchar brd[MAX][MAX];\nbool done[MAX][MAX];\nbool calc_done[MAX][MAX];\n\nint dx[] = { 0, 0, -1, 1 };\nint dy[] = { -1, 1, 0, 0 };\n\n#define EMPTY 0\n#define BLACK 1\n#define WHITE 2\n\nint only(int y, int x)\n{\n\tif (!(0 <= y && y < h)) return EMPTY;\n\tif (!(0 <= x && x < w)) return EMPTY;\n\tif (done[y][x]) return EMPTY;\n\tdone[y][x] = true;\n\n\tif (brd[y][x] == 'B')\n\t\treturn BLACK;\n\telse if (brd[y][x] == 'W')\n\t\treturn WHITE;\n\n\tint code = EMPTY;\n\tif (brd[y][x] == '.') {\n\t\trep(i, 4) \n\t\t\tcode |= only(y+dy[i], x+dx[i]);\n\t}\n\treturn code;\n}\n\nint calc(int y, int x)\n{\n\tif (!(0 <= y && y < h)) return 0;\n\tif (!(0 <= x && x < w)) return 0;\n\tif (calc_done[y][x]) return 0;\n\tcalc_done[y][x] = true;\n\tif (brd[y][x] != '.') return 0;\n\n\tint cnt = 1;\n\trep(i, 4)\n\t\tcnt += calc(y+dy[i], x+dx[i]);\n\treturn cnt;\n}\n\nint main(void)\n{\n\twhile (cin >> h >> w, w|h) {\n\t\trep(j, h) rep(i, w) cin >> brd[j][i];\n\n\t\tint ww, bb;\n\t\tww = bb = 0;\n\n\t\tmemset(calc_done, 0, sizeof(calc_done));\n\t\trep(j, h) {\n\t\t\trep(i, w) {\n\t\t\t\tmemset(done, 0, sizeof(done));\n\n\t\t\t\tint c = only(j, i);\n\t\t\t\tif ((c&BLACK) && (c&WHITE))\n\t\t\t\t\tcontinue;\n\t\t\t\telse if (c&BLACK)\n\t\t\t\t\tbb += calc(j, i);\n\t\t\t\telse if (c&WHITE)\n\t\t\t\t\tww += calc(j, i);\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d %d\\n\", bb, ww);\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define loop(n, i) for(int i=0;i<n;i++)\n#define all(v) v.begin(),v.end()\n#define HERE cout << \"HERE: \" << __LINE__ << endl;\n#define INSP(v) cout << v << \" at \" << __LINE__ << endl;\n\nusing namespace std;\ntypedef long long ll;\n\nstruct State { int b, w, empty; };\nState operator+(const State& a, const State& b) {\n    return { a.b+b.b, a.w+b.w, a.empty+b.empty };\n}\nint dir[] = { -1, 0, 1, 0, -1 };\n\nint w, h;\nvector<string> A;\nvector<vector<int>> vis;\n\nState dfs(int y, int x) {\n    if (y < 0 || y >= h || x < 0 || x >= w) return { 0, 0, 0 };\n    if (A[y][x] == 'B') return { 1, 0, 0 };\n    if (A[y][x] == 'W') return { 0, 1, 0 };\n    if (vis[y][x]) return { 0, 0, 0 };\n    vis[y][x] = 1;\n    if (A[y][x] == '.') {\n        State sum = { 0, 0, 1 };\n        loop (4, i) sum = sum + dfs(y + dir[i], x + dir[i + 1]);\n        return sum;\n    }\n}\n\nint main()\n{\n    while (1) {\n        cin >> w >> h;\n        if (!w) break;\n        A = vector<string>(h);\n        vis = vector<vector<int>>(h, vector<int>(w));\n\n        loop (h, i) cin >> A[i];\n\n        int ans_b = 0, ans_w = 0;\n        loop (h, i) loop (w, j) {\n            auto rt = dfs(i, j);\n            if (rt.b && rt.w) continue;\n            if (rt.b) ans_b += rt.empty;\n            if (rt.w) ans_w += rt.empty;\n        }\n\n        cout << ans_b << \" \" << ans_w << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\n#define stlice(from, to) substr(from, (to) - (from) + 1)\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\nusing namespace std;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\nusing vd = vector<double>;\nusing vc = vector<char>;\nusing vb = vector<bool>;\nusing vs = vector<string>;\nusing vpii = vector<pii>;\nusing vvi = vector<vi>;\nusing vvb = vector<vb>;\nusing vvpii = vector<vpii>;\ntemplate<typename A> using fn = function<A>;\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = acos(-1);\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nconstexpr bool odd(const int &n) { return n & 1; }\nconstexpr bool even(const int &n) { return !odd(n); }\nvoid solve();\nmain { solve(); return 0; }\n// clang-format on\n\nvoid solve() {\n  int W, H;\n  while (cin >> W >> H, W) {\n    vs v(H);\n    rep(i, H) cin >> v[i];\n    vvi dp(H, vi(W));\n    int b = 0, w = 0;\n    rep(i, H) rep(j, W) {\n      dp[i][j] = 2 * (v[i][j] == 'B') + (v[i][j] == 'W');\n      b -= v[i][j] == 'B';\n      w -= v[i][j] == 'W';\n    }\n    rep(_, W * H) rep(i, H) rep(j, W) {\n      if (v[i][j] != '.') continue;\n      if (i > 0) dp[i][j] |= dp[i - 1][j];\n      if (j > 0) dp[i][j] |= dp[i][j - 1];\n      if (i < H - 1) dp[i][j] |= dp[i + 1][j];\n      if (j < W - 1) dp[i][j] |= dp[i][j + 1];\n    }\n    rep(i, H) rep(j, W) {\n      b += dp[i][j] == 2;\n      w += dp[i][j] == 1;\n    }\n    cout << b << ' ' << w << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vs=vector<string>;\nusing msi=map<string,int>;\nusing mii=map<int,int>;\nusing pii=pair<int,int>;\nusing vlai=valarray<int>;\nusing ll=long long;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define range(i,s,n) for(int i=s;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define fs first\n#define sc second\n\nint main(){\n    int w,h;\n    while(cin>>w>>h,w){\n        vs f(h+2,string(w+2,'#'));\n        bool isExist=true;\n        rep(i,h){\n            cin>>f[i+1];\n            isExist&=count(all(f[i+1]), '.')==f[i+1].length();\n            f[i+1]=\"#\"+f[i+1]+\"#\";\n        }\n        if(isExist){\n            cout<<\"0 0\"<<endl;\n            continue;\n        }\n        \n        int ans;\n        vs b;\n        \n        ans=0;\n        b=f;\n        range(y,1,h+1)range(x,1,w+1){\n            if(b[y][x]=='B')continue;\n            b[y][x]='B';\n            int isEnable=1;\n            stack<pii> bfs;\n            bfs.emplace(y,x);\n            while(!bfs.empty()){\n                auto p=bfs.top();\n                bfs.pop();\n                vi v={1,0,-1,0,1};\n                rep(i,4){\n                    int ty=p.fs,tx=p.sc;\n                    switch(b[ty+v[i]][tx+v[i+1]]){\n                        case 'W':\n                            isEnable=-100000;\n                        case '.':\n                            isEnable++;\n                            bfs.emplace(ty+v[i], tx+v[i+1]);\n                            b[ty+v[i]][tx+v[i+1]]='B';\n                    }\n                }\n            }\n            if(isEnable>0) ans+=isEnable;\n        }\n        cout<<ans<<\" \";\n        \n        ans=0;\n        b=f;\n        range(y,1,h+1)range(x,1,w+1){\n            if(b[y][x]=='W')continue;\n            b[y][x]='W';\n            int isEnable=1;\n            stack<pii> bfs;\n            bfs.emplace(y,x);\n            while(!bfs.empty()){\n                auto p=bfs.top();\n                bfs.pop();\n                vi v={1,0,-1,0,1};\n                rep(i,4){\n                    int ty=p.fs,tx=p.sc;\n                    switch(b[ty+v[i]][tx+v[i+1]]){\n                        case 'B':\n                            isEnable=-10000;\n                        case '.':\n                            isEnable++;\n                            bfs.emplace(ty+v[i], tx+v[i+1]);\n                            b[ty+v[i]][tx+v[i+1]]='W';\n                    }\n                }\n            }\n            if(isEnable>0) ans+=isEnable;\n        }\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint h, w;\nchar ground[52][52];\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint BFS(int i, int j){\n    int isvisited[52][52] = {};\n    bool B = false;\n    bool W = false;\n    queue<pair<int, int>> que;\n    que.push(pair<int, int>(i, j));\n    while(!que.empty()){\n        pair<int, int> q = que.front(); que.pop();\n        for(int k=0;k<4;k++){\n            pair<int, int> next_q;\n            next_q.first = q.first + dx[k];\n            next_q.second = q.second + dy[k];\n            if(0 <= next_q.first && next_q.first < h &&\n            0 <= next_q.second && next_q.second < w &&\n            isvisited[next_q.first][next_q.second] == 0){\n                isvisited[next_q.first][next_q.second] = 1;\n                if(ground[next_q.first][next_q.second] == 'B'){\n                    B = true;\n                }\n                else if(ground[next_q.first][next_q.second] == 'W'){\n                    W = true;\n                }\n                else{\n                    que.push(next_q);\n                }\n            }\n        }\n    }\n    if(B && !W){\n        return 1;\n    }\n    else if(!B && W){\n        return -1;\n    }\n    else{\n        return 0;\n    }\n}\n\nint main(){\n    while(true){\n        cin >> w >> h;\n        if(h == 0 && w == 0) break;\n        int B = 0;\n        int W = 0;\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                cin >> ground[i][j];\n            }\n        }\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                if(ground[i][j] == '.'){\n                    int result = BFS(i, j);\n                    if(result == 1){\n                        B++;\n                    }\n                    if(result == -1){\n                        W++;\n                    }\n                }\n            }\n        }\n        cout << B << \" \" << W << \"\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint w,h,c1,c2,b,d;\nchar a[51][51];\nint dfs(int i,int j){\n  if(i==h||j==w||i<0||j<0||a[i][j]=='#')return 0;\n  if(a[i][j]=='W'){d++;return 0;}\n  else if(a[i][j]=='B'){b++;return 0;}\n  int s=1;\n  a[i][j]='#';\n  s+=dfs(i+1,j);\n  s+=dfs(i-1,j);\n  s+=dfs(i,j+1);\n  s+=dfs(i,j-1);\n  return s;\n}\nint main(){\n  int i,j,ans;\n  while(cin>>w>>h,w){\n    c1=c2=0;\n    for(i=0;i<h;i++)scanf(\"%c\",&a[i]);\n    for(i=0;i<h;i++)for(j=0;j<w;j++)if(a[i][j]=='.'){\n      d=b=0;\n      ans=dfs(i,j);\n      if(b&&d)continue;\n      else if(b>d)c1+=ans;\n      else if(b<d)c2+=ans;\n    }\n    cout<<c1<<\" \"<<c2<<endl;\n}}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n \nusing namespace std;\n\nvoid check_white(int x, int y);\nvoid check_black(int x, int y);\n// map[x][y] x: y:\n\nint W, H;\nint issearched[50][50];\nchar landmap[50][50];\nint dx[4] = {-1, 0, 1, 0};\nint dy[4] = {0, -1, 0, 1};\n// \nint nx, ny;\n\nint main()\n{\n    while(1){\n        cin >> W >> H;\n        if(W == 0 && H == 0) break;\n        vector<pair<int, int> > whitepost(2500);\n        vector<pair<int, int> > blackpost(2500);\n        int whitecnt = 0, blackcnt = 0;\n        for(int i = 0; i < H; i++){\n            for(int j = 0; j < W; j++){\n                cin >> landmap[i][j];\n                if(landmap[i][j] == 'W'){\n                    whitepost[whitecnt] = make_pair<int, int>(i, j);\n                    whitecnt++;\n                } else if(landmap[i][j] == 'B'){\n                    blackpost[blackcnt] = make_pair<int, int>(i, j);\n                    blackcnt++;\n                }\n            }\n        }\n        for(int i = 0; i < H; i++){\n            for(int j = 0; j < W; j++){\n                issearched[i][j] = 0;\n            }\n        }\n        for(int i = 0; i < whitecnt; i++) check_white(whitepost[i].first, whitepost[i].second);\n        for(int i = 0; i < H; i++){\n            for(int j = 0; j < W; j++){\n                issearched[i][j] = 0;\n            }\n        }\n        for(int i = 0; i < blackcnt; i++) check_black(blackpost[i].first, blackpost[i].second);\n        int white_land = 0, black_land = 0;\n        for(int i = 0; i < H; i++){\n            for(int j = 0; j < W; j++){\n                if(landmap[i][j] == 'w') white_land++;\n                else if(landmap[i][j] == 'b') black_land++;\n            }\n        }\n        cout << black_land << ' ' << white_land << endl;\n    }\n    return 0;\n}\n\nvoid check_white(int x, int y)\n{\n    for(int i = 0; i < 4; i++){\n        nx = x + dx[i];\n        ny = y + dy[i];\n        if(nx < 0 || ny < 0 || nx >= H || ny >= W) continue;\n        else {\n            if(issearched[nx][ny] == 0){\n                issearched[nx][ny] = 1;\n                if(landmap[nx][ny] == '.'){\n                    landmap[nx][ny] = 'w';\n                    check_white(nx, ny);\n                }\n                 // else if(map[nx][ny] == 'w'){\n                    // check_white(nx, ny);\n                // }\n            }\n        }\n    }\n    return;\n}\n\nvoid check_black(int x, int y)\n{\n    for(int i = 0; i < 4; i++){\n        nx = x + dx[i];\n        ny = y + dy[i];\n        if(nx < 0 || ny < 0 || nx >= H || ny >= W) continue;\n        else {\n            if(issearched[nx][ny] == 0){\n                issearched[nx][ny] = 1;\n                if(landmap[nx][ny] == '.'){\n                    landmap[nx][ny] = 'b';\n                    check_black(nx, ny);\n                } else if(landmap[nx][ny] == 'w'){\n                    landmap[nx][ny] = '.';\n                    check_black(nx, ny);\n                }\n            }\n        }\n    }\n    return;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint w,h,c1,c2,b,d;\nchar a[51][51];\nint dfs(int i,int j){\n  if(i==h||j==w||i<0||j<0||a[i][j]=='#')return 0;\n  if(a[i][j]=='W'){d++;return 0;}\n  else if(a[i][j]=='B'){b++;return 0;}\n  int s=1;\n  a[i][j]='#';\n  s+=dfs(i+1,j);\n  s+=dfs(i-1,j);\n  s+=dfs(i,j+1);\n  s+=dfs(i,j-1);\n  return s;\n}\nint main(){\n  int i,j,ans;\n  while(cin>>w>>h,w&&h){\n    c1=c2=0;\n    for(i=0;i<h;i++)scanf(\"%c\"&a[i]);\n    for(i=0;i<h;i++)for(j=0;j<w;j++)if(a[i][j]=='.'){\n      d=b=0;\n      ans=dfs(i,j);\n      if(b&&d)continue;\n      else if(b>d)c1+=ans;\n      else if(b<d)c2+=ans;\n    }\n    cout<<c1<<\" \"<<c2<<endl;\n}}"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\n#define stlice(from, to) substr(from, (to) - (from) + 1)\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\nusing namespace std;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\nusing vd = vector<double>;\nusing vc = vector<char>;\nusing vb = vector<bool>;\nusing vs = vector<string>;\nusing vpii = vector<pii>;\nusing vvi = vector<vi>;\nusing vvb = vector<vb>;\nusing vvpii = vector<vpii>;\ntemplate<typename A> using fn = function<A>;\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = acos(-1);\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nconstexpr bool odd(const int &n) { return n & 1; }\nconstexpr bool even(const int &n) { return !odd(n); }\nvoid solve();\nmain { solve(); return 0; }\n// clang-format on\n\nvoid solve() {\n  int W, H;\n  while (cin >> W >> H, W) {\n    vs v(H);\n    rep(i, H) cin >> v[i];\n    vvi dp(H, vi(W));\n    int b = 0, w = 0;\n    rep(i, H) rep(j, W) {\n      dp[i][j] = 2 * (v[i][j] == 'B') + (v[i][j] == 'W');\n      b -= v[i][j] == 'B';\n      w -= v[i][j] == 'W';\n    }\n    rep(_, W * H) rep(i, H) rep(j, W) {\n      if (v[i][j] != '.') continue;\n      if (i > 0) dp[i][j] |= dp[i - 1][j];\n      if (j > 0) dp[i][j] |= dp[i][j - 1];\n      if (i < H - 1) dp[i][j] |= dp[i + 1][j];\n      if (j < W - 1) dp[i][j] |= dp[i][j + 1];\n    }\n    rep(i, H) rep(j, W) {\n      b += dp[i][j] == 2;\n      w += dp[i][j] == 1;\n    }\n    cout << b << ' ' << w << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n\nusing namespace std;\nconst int dx[4] = {1,0,0,-1};\nconst int dy[4] = {0,1,-1,0};\nconst int B = 5;\nconst int W = 8;\nconst int BW = 13;\nint flagB = 0;\nint flagW = 0;\nqueue<pair<int,int> > que;\nvoid dfs(vector<vector<int> > &map,int x,int y){\n  map[x][y] = -1;\n  que.push(pair<int,int>(x,y));\n  for(int i = 0;i < 4;i++){\n    if(x+dx[i] >= 0 && x+dx[i] < map.size() && y+dy[i] >= 0 && y+dy[i] < map[0].size()){\n      if(map[x+dx[i]][y+dy[i]] == 1)flagB = B;\n      else if(map[x+dx[i]][y+dy[i]] == 2)flagW = W;\n      else if(map[x+dx[i]][y+dy[i]] == -1){}\n      else dfs(map,x+dx[i],y+dy[i]);\n      \n    }\n  }\n  \n  return ;\n}\nvoid solve(vector<vector<int> > &map){\n  while(!que.empty()){\n\n    pair<int,int> tmp = que.front();que.pop();\n    map[tmp.first][tmp.second] = flagB+flagW;\n  }\n  flagB = 0;\n  flagW = 0;\n  return ;\n}\nint main(){\n\n  while(1){\n    int w,h;\n    cin >> w >> h;\n    if(w == 0 && h == 0)break;\n    vector<vector<int> > map(w,vector<int>(h,0));\n    for(int i = 0;i < h;i++){\n      for(int j = 0;j < w;j++){\n\tchar a;\n\tcin >> a;\n\tif(a == 'B')map[j][i] = 1;///B\n\telse if(a == 'W')map[j][i] = 2;///W\n      }\n    }\n    for(int i = 0;i < h;i++){\n      for(int j = 0;j < w;j++){\n\tif(map[j][i] == 0){\n\t  dfs(map,j,i);\n\t  //\t  cout << flagW << \"dddddddddddddd\" << flagB << endl;\n\t  solve(map);\n\t}\n      }\n    }\n    int cnt_W = 0;\n    int cnt_B = 0;\n    for(int i = 0;i < h;i++){\n      for(int j = 0;j < w;j++){\n\t//cout << map[i][j] << \" \";\n\tif(map[j][i] == B)cnt_B++;\n\telse if(map[j][i] == W)cnt_W++;\n\t\n      }\n      //      cout << endl;\n    }\n    cout << cnt_B << \" \" << cnt_W << endl;\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint w,h,dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};\nstring a[51];\nbool used[51][51];\nint dfs(int y,int x){\n  if(y==-1||y==h||x==-1||x==w||used[y][x])return 0;\n  if(a[y][x]=='B')return 1;\n  if(a[y][x]=='W')return 2;\n  used[y][x]=1;\n  int pr=0;\n  for(int t,i=0;i<4;i++){\n    t=dfs(y+dy[i],x+dx[i]);\n    if(!pr)pr=t;\n    else if(t&&pr!=t)pr=3;\n  }\n  return pr;\n}\n\nint main(){\n  while(cin>>w>>h,w){\n    for(int i=0;i<h;i++)cin>>a[i];\n    int ans[5]={};\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){  \n\tmemset(used,0,sizeof(used));\n\tif(a[i][j]=='.')ans[dfs(i,j)]++;\n      }\n    cout<<ans[1]<<\" \"<<ans[2]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2014\n\n#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<numeric>\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define dump(a) (cerr << #a << \"=\" << (a) << endl)\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl;\n\nusing namespace std;\n\n#define MAX 52\n\nchar area[MAX][MAX];\nint ans[MAX][MAX];\nint visit[MAX][MAX];\nint W,H;\n\nvoid init()\n{\n\tfill_n((char *)area, sizeof(area) / sizeof(char), '.');\n\tfill_n((int *)ans, sizeof(ans) / sizeof(int), 0);\n\tfill_n((int *)visit, sizeof(visit) / sizeof(int), 0);\n}\n\nvoid clear(){\n\tfill_n((int *)visit, sizeof(visit) / sizeof(int), 0);\n}\n\nvoid dfs(int x, int y, char color)\n{\n\tint mark = (color == 'W') ? 1 : 2;\n\tchar rival  = (color == 'W') ? 'B':'W';\n\n\tint dx[4] = {1,0,-1,0};\n\tint dy[4] = {0,1,0,-1};\n\n\tif(x < 0 || x >= W || y < 0 || y >= H){ return; }\n\tif(area[y][x] == rival){ return; }\n\n\tif(!visit[y][x])\n\t{\n\t\tvisit[y][x] = 1;\n\t\tif(area[y][x] != 'W' && area[y][x] != 'B'){ ans[y][x] |= mark; }\n\n\t\trep(i,4){ dfs(x+dx[i], y+dy[i], color); }\n\t}\n\n\treturn;\n}\n\nint main()\n{\n\n\twhile(cin >> W >> H && W)\n\t{\n\t\tint black=0, white=0;\n\t\tinit();\n\n\t\trep(h,H){\n\t\t\trep(w,W){\n\t\t\t\tcin >> area[h][w];\n\t\t\t}\n\t\t}\n\n\t\trep(h,H){\n\t\t\trep(w,W){\n\t\t\t\tif(area[h][w] != '.'){ \n\t\t\t\t\tclear();\n\t\t\t\t\tdfs(w,h,area[h][w]); \n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\trep(h,H){\n\t\t\trep(w,W)\n\t\t\t{\n\t\t\t\tint num = ans[h][w];\n\t\t\t\tif(num == 1){ white++; }\n\t\t\t\tif(num == 2){ black++; }\n\t\t\t}\n\t\t}\n\n\t\tcout << black << \" \" << white << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <iomanip>\n#include <complex>\nusing namespace std;\n\n#define ll long long\n#define vvi vector< vector<int> >\n#define vi vector<int>\n#define All(X) X.begin(),X.end()\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define pb push_back\n#define pii pair<int,int>\n#define mp make_pair\n#define pi 3.14159265359\n#define shosu(X) fixed << setprecision(X)\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){return a/gcd(a,b)*b;}\n\nint h,w;\nchar grid[51][51];\nbool iswhite[51][51];\nbool isblack[51][51];\nbool issearched[51][51];\nint dx[4] = {-1,0,1,0};\nint dy[4] = {0,-1,0,1};\n\nbool dfs(int px, int py,char c,char c2,bool issearched[51][51]){\n\t//cout << px << \" \" << py << endl;\n\tint res = 1;\n\tREP(i,4){\n\t\tint nx = px + dx[i]; \n\t\tint ny = py + dy[i];\n\t\tif(nx < 0 || ny <0 || nx > h-1 || ny > w-1) continue;\n\t\tif(issearched[nx][ny]) continue;\n\t\tissearched[nx][ny] = true;\n\t\tif(grid[nx][ny] == c) return true;\n\t\telse if(grid[nx][ny] == '.') return dfs(nx,ny,c,c2,issearched);\n\t\telse if(grid[nx][ny] == c2) return false;\n\t}\n\treturn false;\n}\nint main(){\n\twhile(1){\n\t\tcin >> w >> h;\n\t\tif(w==0&&h==0) break;\n\t\tREP(i,h) REP(j,w) cin >> grid[i][j];\n\t\tREP(i,h) REP(j,w) {\n\t\t\tREP(k,h) REP(l,w) issearched[k][l] = false;\n\t\t\tiswhite[i][j] = dfs(i,j,'W','B',issearched);\n\t\t}\n\t\tREP(i,h) REP(j,w) {\n\t\t\tREP(k,h) REP(l,w) issearched[k][l] = false;\n\t\t\tisblack[i][j] = dfs(i,j,'B','W',issearched);\n\t\t}\n\t\tint white = 0; int black = 0;\n\t\tREP(i,h) REP(j,w){\n\t\t\tif(iswhite[i][j] == true && isblack[i][j] == false) white++;\n\t\t\telse if(iswhite[i][j] == false && isblack[i][j] == true) black++;\n\t\t}\n\t\tcout << black << \" \" << white;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<climits>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n#define pb         push_back\n#define mp         make_pair\n#define ALL(C)     (C).begin(),(C).end()\n\n\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n\nint vis[50][50];\nchar m[50][50];\n\n\nvoid dfs(int r,int c,int y,int x,int now){\n  if(((1<<now)&vis[y][x]) != 0)return;\n  vis[y][x]|=(1<<now);\n  rep(i,4){\n    int nex=x+dx[i],ney=y+dy[i];\n    if (nex==-1||nex==c||ney==r||ney==-1||m[ney][nex]!='.')continue;\n    dfs(r,c,ney,nex,now);\n  }\n}\n\nvoid solve(int r,int c){\n  rep(i,r){\n    rep(j,c){\n      vis[i][j]=0;\n    }\n  }\n   \n  rep(i,r){\n    rep(j,c){\n      if (m[i][j] == 'B'){\n\tdfs(r,c,i,j,0);\n      }else if (m[i][j] == 'W'){\n\tdfs(r,c,i,j,1);\n      }\n    }\n  }\n\n  int w=0,b=0;\n  rep(i,r){\n    rep(j,c){\n      if (m[i][j] != '.')continue;\n      if (vis[i][j] == 1)b++;\n      else if (vis[i][j]==2)w++;\n    }\n  }\n  cout << b << \" \" << w << endl;\n}\n\nmain(){\n  int r,c;\n  while(cin>>c>>r && c){\n    rep(i,r){\n      rep(j,c)cin>>m[i][j];\n    }\n    solve(r,c);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#define REP(i, n) for(int i = 0; i < n; i++)\nusing namespace std;\n\nchar map[50][50];\nint w, h;\n\nvoid solve();\nint check(int, int, int);\n\nint main(){\n  while(1){\n    scanf(\" %d %d\", &w, &h);\n    if((w | h) == 0) break;\n    else solve();\n  }\n\n  return 0;\n}\n\nvoid solve(){\n  int black = 0, white = 0;\n\n  REP(i, h){\n    REP(j, w){\n      scanf(\" %c\", &map[j][i]);\n    }\n  }\n   \n  REP(i, h){\n    REP(j, w){\n      if(map[j][i] == 'B'){\n\tcheck(j, i, 1);\n      }\n      else if(map[j][i] == 'W'){\n\tcheck(j, i, 2);\n      }\n    }\n  }\n\n  REP(i, h){\n    REP(j, w){\n      if(map[j][i] == 1) black++;\n      else if(map[j][i] == 2) white++;\n    }\n  }\n    printf(\"%d %d\\n\", black, white);\n}\n\nint check(int x, int y, int mark){\n  int dx[4] = {-1, 0, 1, 0};\n  int dy[4] = {0, -1, 0, 1};\n  int nx, ny;\n\n  REP(i, 4){\n    nx = x + dx[i];\n    ny = y + dy[i];\n    if(nx >= 0 && nx < w && ny >= 0 && ny < h){\n      char point = map[nx][ny];\n      if(point != 'B' && point != 'W'){\n\tif(map[nx][ny] == '.'){\n\t  map[nx][ny] = mark;\n\t  check(nx, ny, mark);\n\t}\n\telse{ \n\t    map[nx][ny] |= mark;\n\t    if((mark & point) != mark) check(nx, ny, mark);\n\t}\n      }\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n\n// C++\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <initializer_list>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <scoped_allocator>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n//#include <boost/foreach.hpp>\n//#include <boost/range/algorithm.hpp>\n#define rep(i,j,k) for(int i=(int)j;i<(int)k;i++)\n#define ll long long\n#define Sort(v) sort(all(v))\n#define INF 1e9\n#define LINF 1e18\n#define END return 0\n#define pb push_back\n#define se second\n#define fi first\n#define pb push_back\n#define all(v) (v).begin() , (v).end()\n#define MP make_pair\n#define MOD 1000000007LL\n#define int long long\nusing namespace std;\nint day[12]={31,28,31,30,31,30,31,31,30,31,30,31};\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nstruct edge{int to,cost;};\ntypedef pair<int,int> P;\n\nbool isupper(char c){if('A'<=c&&c<='Z')return 1;return 0;}\nbool islower(char c){if('a'<=c&&c<='z')return 1;return 0;}\nbool isPrime(int x){if(x==1)return 0;if(x==2)return 1;if(x%2==0)return 0;for(int i=3;i*i<=x;i++)if(x%i==0)return 0;return 1;}\nbool iskaibun(string s){for(int i=0;i<s.size()/2;i++)if(s[i]!=s[s.size()-i-1])return 0;return 1;}\nbool isnumber(char c){return ('0'<=c&&c<='9');}\nbool isalpha(char c){return (isupper(c)&&islower(c));}\nvoid printvi(vector<int> v){rep(i,0,v.size()){if(i)cout<<\" \";cout<<v[i];}cout<<endl;}\nvoid printvil(vector<int> v){rep(i,0,v.size()){cout<<v[i]<<endl;}}\nvoid printvvi(vector<vector<int>> v){\n    rep(i,0,v.size()){\n        rep(j,0,v[i].size())cout<<v[i][j];\n        cout<<endl;\n    }\n}\nvoid printvstr(vector<string> v){\n    rep(i,0,v.size()){\n        cout<<v[i]<<endl;\n    }\n}\n\nsigned main (){\n    int w,h;\n    while(1){   \n        cin>>w>>h;\n        if(w==0 and h==0)break;\n        vector<string> v(h);\n        rep(i,0,h)cin>>v[i];\n        int ansb=0,answ=0;\n        auto bfs=[&](int x,int y){\n            vector<vector<bool>> visited(h,vector<bool>(w,false));\n            int W=0,B=0;\n            queue<pair<int,int>> que;\n            que.push(pair<int,int>(x,y));\n            visited[0][0]=false;\n            while(!que.empty()){\n                pair<int,int> p=que.front();\n                que.pop();\n                rep(i,0,4){\n                    int nx=dx[i]+p.first;\n                    int ny=dy[i]+p.second;\n                    if(!(0<=nx&&nx<w&&0<=ny&&ny<h))continue;\n                    if(v[ny][nx]=='W'){\n                        W++;\n                        continue;\n                    }\n                    else if(v[ny][nx]=='B'){\n                        B++;\n                        continue;\n                    }\n                    if(visited[ny][nx]==false){\n                        que.push(pair<int,int>(nx,ny));\n                        visited[ny][nx]=true;\n                    }\n                }\n            }\n            if(W==0&&B>0)ansb++;\n            else if(W>0&&B==0)answ++;\n        };\n        rep(i,0,h){\n            rep(j,0,w){\n                if(v[i][j]=='W' || v[i][j]=='B')continue;\n                bfs(j,i);\n            }\n        }\n        cout<<ansb<<\" \"<<answ<<endl;    \n    }\n}\n/*\n\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\nint A[60][60];\nint B[60][60];\nint x,y;\nint dx[4]={0,0,1,-1};\nint dy[4]={1,-1,0,0};\nint dfs(int x,int y){\n    A[x][y]=3;\n    int ans=0;\n    REP(i,4){\n        int xx=dx[i]+x;\n        int yy=dy[i]+y;\n        if(A[xx][yy]==0){\n           ans+=dfs(xx,yy);\n        }\n    }\n    return ans+1;\n}\n\nint dfs2(int x,int y){\n    B[x][y]=3;\n    int ans=0;\n    REP(i,4){\n        int xx=dx[i]+x;\n        int yy=dy[i]+y;\n        if(B[xx][yy]==0){\n           ans+=dfs2(xx,yy);\n        }\n    }\n    return ans+1;\n}\n\nint main(){\n    int W,H;\n    while(cin>>W>>H,W+H){\n        REP(i,60){\n            REP(j,60){\n                A[i][j]=1;\n                B[i][j]=1;\n            }\n        }\n        REP(i,H){\n            string s;\n            cin>>s;\n            REP(j,W){\n                if(s[j]=='.'){\n                   A[i+1][j+1]=0;\n                   B[i+1][j+1]=0;\n                }\n                if(s[j]=='B'){\n                   A[i+1][j+1]=2;\n                }\n                if(s[j]=='W'){\n                   B[i+1][j+1]=2;\n                }\n            }\n        }\n        REP(i,H+1){\n            REP(j,W+1){\n                if(A[i][j]==2){\n                   REP(k,4){\n                       int x=i+dx[k];\n                       int y=j+dy[k];\n                       if(A[x][y]==0){\n                          dfs(x,y);\n                       }\n                   }\n                }\n            }\n        }\n        REP(i,H+1){\n            REP(j,W+1){\n                if(B[i][j]==2){\n                   REP(k,4){\n                       int x=i+dx[k];\n                       int y=j+dy[k];\n                       if(B[x][y]==0){\n                          dfs2(x,y);\n                       }\n                   }\n                }\n            }\n        }\n        int w=0;\n        int b=0;\n        REP(i,H+1){\n            REP(j,W+1){\n                if(A[i][j]==3&&B[i][j]!=3)b++;\n                if(A[i][j]!=3&&B[i][j]==3)w++;\n            }\n        }\n        cout<<b<<\" \"<<w<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\n#define all(c) c.begin(),c.end()\n#define rall(c) c.rbegin(),c.rend()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define tr(it,container) for(typeof(container.begin()) it = container.begin(); \\\n                                                  it != container.end(); ++it)\n#define mp(a,b) make_pair((a),(b))\n\ntypedef long long ll;\ntypedef complex<double> point;\n\n// up right down left\nconst int dy[] = {-1,0,1,0};\nconst int dx[] = {0,1,0,-1};\n\nconst double EPS = 1e-9;\nconst int days[]     = {31,28,31,30,31,30,31,31,30,31,30,31};\nconst int daysleap[] = {31,29,31,30,31,30,31,31,30,31,30,31};\n\nint main(){\n    while(true){\n        int w,h;\n        cin >> w >> h;\n        if(w==0) break;\n        // y x.\n        vector<vector<char> > A(h,vector<char>(w,'.'));\n        rep(i,h) rep(j,w){\n            cin >> A[i][j];\n        }\n        rep(height,h) rep(width,w){\n            if(A[height][width] != '.') continue;\n            bool white = false;\n            bool black = false;\n            // y x\n            queue<pair<int,int> > Q;\n            Q.push(mp(height,width));\n            vector<vector<char> > Got(h,vector<char>(w,0));\n            Got[height][width] = true;\n            while(!Q.empty()){\n                pair<int,int> p = Q.front();\n                Q.pop();\n                if(A[p.first][p.second] == 'W'){\n                    white = true;\n                    continue;\n                }\n                if(A[p.first][p.second] == 'B'){\n                    black = true;\n                    continue;\n                }\n                rep(i,4){\n                    int ny = p.first + dy[i];\n                    int nx = p.second + dx[i];\n                    if(nx == -1 or ny == -1 or nx == w or ny == h or Got[ny][nx]) continue;\n                    Got[ny][nx] = true;\n                    Q.push(mp(ny,nx));\n                }\n            }\n            rep(hh,h) rep(ww,w){\n                if(A[hh][ww] == '.' and Got[hh][ww]){\n                    if(white and black){\n                        A[hh][ww] = 'x';\n                    }else if (white){\n                        A[hh][ww] = 'w';\n                    }else if(black){\n                        A[hh][ww] = 'b';\n                    }else{\n                        A[hh][ww] = 'z';\n                    }\n                }\n            }\n        }\n        int whitecnt=0,blackcnt=0;\n        rep(height,h) rep(width,w){\n            if(A[height][width] == 'w') whitecnt++;\n            if(A[height][width] == 'b') blackcnt++;\n        }\n        cout << blackcnt << \" \" << whitecnt << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint w, h;\n\nbool check(int x, int y){\n\treturn x >= 0 && x < w && y >= 0 && y < h;\t\n}\n\n\nint main() {\n\tint dx[] = {1, 0, -1, 0};\n\tint dy[] = {0, 1, 0, -1};\n\twhile(cin >> w >> h && (w || h)){\n\t\tstring a;\n\t\tint cntB = 0, cntW = 0;\n\t\tvector<string> maze;\n\t\tfor(int i = 0; i < h; ++i){\n\t\t\tcin >> a;\n\t\t\tmaze.push_back(a);\n\t\t}\n\t\tfor(int y = 0; y < h; ++y){\n\t\t\tfor(int x = 0; x < w; ++x){\n\t\t\t\tif(maze[y][x] != '.')\n\t\t\t\t\tcontinue;\n\t\t\t\tbool white = false, black = false;\n\t\t\t\tqueue<P> que;\n\t\t\t\tbool visited[128][128] = {0};\n\t\t\t\tque.push(P(x, y));\n\t\t\t\twhile(!que.empty()){\n\t\t\t\t\tP p = que.front();\n\t\t\t\t\tque.pop();\n\t\t\t\t\tint px = p.first;\n\t\t\t\t\tint py = p.second;\n\t\t\t\t\tvisited[py][px] = true;\n\t\t\t\t\tif(maze[py][px] == 'W'){\n\t\t\t\t\t\twhite = true;\n\t\t\t\t\t\t//cout << x << \" \" << y << endl;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(maze[py][px] == 'B'){\n\t\t\t\t\t\tblack = true;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfor(int i = 0; i < 4; ++i){\n\t\t\t\t\t\tint nx = px + dx[i];\n\t\t\t\t\t\tint ny = py + dy[i];\n\t\t\t\t\t\tif(check(nx, ny) && !visited[ny][nx])\n\t\t\t\t\t\t\tque.push(P(nx, ny));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!white && black)\n\t\t\t\t\tcntB++;\n\t\t\t\telse if(white && !black)\n\t\t\t\t\tcntW++;\n\t\t\t}\n\t\t}\n\t\tcout << cntB << \" \" << cntW << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define erep(i, m, n) for(int (i)=(m); (i)<=(n); (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define rrev(i, m, n) for(int (i)=(n)-1; (i)>=(m); (i)--)\n#define erev(i, m, n) for(int (i)=(n); (i)>=(m); (i)--)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define pb            push_back\ntemplate<class T, class S> inline pair<T, S> mp(T x, S y){ return make_pair(x, y); }\ntemplate<class T, class S> inline bool minup(T& m, S x){ return m>(T)x ? (m=(T)x, true) : false; }\ntemplate<class T, class S> inline bool maxup(T& m, S x){ return m<(T)x ? (m=(T)x, true) : false; }\n\nstatic const int    INF = 1000000000;\nstatic const ll     MOD = 1000000007LL;\nstatic const double EPS = 1E-12;\n\nconst int dx[] = {-1, 0, 1, 0};\nconst int dy[] = {0, -1, 0, 1};\nconst int MAX_W = 55;\nconst int MAX_H = 55;\nint W, H;\nchar a[MAX_W][MAX_H+1];\nint d[MAX_W][MAX_H+1];\nbool flag[MAX_W][MAX_H+1];\nmap<char, int> hm;\n\ninline bool check(int hx, int hy){ return 0 <= hx && hx < H && 0 <= hy && hy < W; }\n\nint main()\n{\n  hm['W'] = 1;\n  hm['B'] = -1;\n\n  while(cin >> W >> H, W){\n    rep(i, H) rep(j, W) cin >> a[i][j];\n    rep(i, H) rep(j, W) d[i][j] = 0;\n    rep(i, H) rep(j, W) flag[i][j] = false;\n\n    rep(i, H) rep(j, W) if(a[i][j] != '.'){\n      stack<pii> st;\n      st.push(mp(i, j));\n      while(!st.empty()){\n        pii here = st.top();  st.pop();\n        int hx = here.first;\n        int hy = here.second;\n        rep(k, 4){\n          int nx = hx + dx[k];\n          int ny = hy + dy[k];\n          if(!check(nx, ny)) continue;\n          if(a[nx][ny] == '.' && (!flag[nx][ny] || d[nx][ny] == -hm[a[i][j]])){\n            flag[nx][ny] = true;\n            d[nx][ny] += hm[a[i][j]];\n            st.push(mp(nx, ny));\n          }\n        }\n      }\n    }\n\n    int h = 0;\n    int b = 0;\n    rep(i, H) rep(j, W){\n      if(d[i][j] > 0) h += 1;\n      if(d[i][j] < 0) b += 1;\n    }\n\n    cout << b << ' ' << h << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nint dx[]={0, 0, 1, -1};\nint dy[]={1, -1, 0, 0};\n\nint w, h, vis[2][64][64];\nchar a[64][64];\n\nvoid rec(int x, int y, bool color){\n\t\n\tif(x < 0 || w <= x || y < 0 || h <= y || a[y][x] != '.' || vis[color][y][x])\n\t\treturn;\n\t\n\tvis[color][y][x] = true;\n\t\n\tfor(int i=0; i<4; ++i){\n\t\trec(x+dx[i], y+dy[i], color);\n\t}\n}\n \nint main(){\n\t\n\twhile(cin>>w>>h, (w||h)){\n\t\t\n\t\tint sqw=0, sqb=0;\n\t\tmemset(vis, 0, sizeof(vis));\n\t\t\n\t\tfor(int i=0; i<h; ++i){\n\t\t\tfor(int j=0; j<w; ++j){\n\t\t\t\tcin>>a[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int y=0; y<h; ++y){\n\t\t\tfor(int x=0; x<w; ++x){\n\t\t\t\n\t\t\t\tif(a[y][x]!='.'){\n\t\t\t\t\n\t\t\t\t\tfor(int i=0; i<4; ++i){\n\t\t\t\t\t\trec(x+dx[i], y+dy[i], a[y][x]=='B');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0; i<h; ++i){\n\t\t\tfor(int j=0; j<w; ++j){\n\t\t\t\t\n\t\t\t\tif(vis[0][i][j] ^ vis[1][i][j]){\n\t\t\t\t\t\n\t\t\t\t\tif(vis[0][i][j])\n\t\t\t\t\t\tsqw++;\n\t\t\t\t\telse if(vis[1][i][j])\n\t\t\t\t\t\tsqb++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << sqb << \" \" << sqw << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nchar t[100][100];\nbool visited[100][100];\nbool a,b;\nint h,w,cnt;\nvoid rec(int y,int x){\n  if(t[y][x]=='B')a=true;\n  if(t[y][x]=='W')b=true;\n  if(t[y][x]!='.')return;\n  if(visited[y][x])return;\n  visited[y][x]=true;\n  cnt++;\n  if(y>0)rec(y-1,x);\n  if(y+1<h)rec(y+1,x);\n  if(x>0)rec(y,x-1);\n  if(x+1<w)rec(y,x+1);\n}\nint main(){\n  while(1){\n    cin>>w>>h;\n    if(h==0&&w==0)break;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n    cin>>t[i][j],visited[i][j]=false;\n    int suma=0,sumb=0;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n    if(visited[i][j])continue;\n    if(t[i][j]!='.')continue;\n    a=b=cnt=false;\n    rec(i,j);\n    if(a&&!b)suma+=cnt;\n    else if(!a&&b)sumb+=cnt;\n      }\n    }\n    cout<<suma<<' '<<sumb<<endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <limits.h>\n#include <math.h>\n#include <set>\n#include <stack>\n#include <stdlib.h>\n#include <string>\n#include <vector>\n\n#define el endl\n#define fd fixed\n#define INF INT_MAX/2-1\n#define pb push_back\n\nusing namespace std;\n\nchar map[50][50];\nbool memoB[50][50];\nbool memoW[50][50];\n\nvoid search(int x, int y, int w, int h, char color) {\n  if (color == 'B') memoB[x][y] = true;\n  else memoW[x][y] = true;\n\n  if (x > 0 && map[x-1][y] == '.') {\n    if ((color == 'B' && !memoB[x-1][y]) || (color == 'W' && !memoW[x-1][y])) {\n      search(x-1, y, w, h, color);\n    }\n  }\n  if (y > 0 && map[x][y-1] == '.') {\n    if ((color == 'B' && !memoB[x][y-1]) || (color == 'W' && !memoW[x][y-1])) {\n      search(x, y-1, w, h, color);\n    }\n  }\n  if (x < w-1 && map[x+1][y] == '.') {\n    if ((color == 'B' && !memoB[x+1][y]) || (color == 'W' && !memoW[x+1][y])) {\n      search(x+1, y, w, h, color);\n    }\n  }\n  if (y < h-1 && map[x][y+1] == '.') {\n    if ((color == 'B' && !memoB[x][y+1]) || (color == 'W' && !memoW[x][y+1])) {\n      search(x, y+1, w, h, color);\n    }\n  }\n}\n\nint main() {\n  int w, h, cntB, cntW, resB, resW;\n  char tmp;\n  string s;\n  while (cin >> w >> h, w | h) {\n    cntB = cntW = 0;\n    for (int j = 0; j < h; j++) {\n      cin >> s;\n      for (int i = 0; i < w; i++) {\n        tmp = s[i];\n        map[i][j] = tmp;\n        if (tmp == '.') memoB[i][j] = memoW[i][j] = false;\n        if (tmp == 'B') memoB[i][j] = true, memoW[i][j] = false, cntB++;\n        if (tmp == 'W') memoB[i][j] = false, memoW[i][j] = true, cntW++;\n      }\n    }\n    for (int i = 0; i < w; i++) {\n      for (int j = 0; j < h; j++) {\n        if (map[i][j] != '.')search(i, j, w, h, map[i][j]);\n      }\n    }\n    resB = resW = 0;\n    for (int i = 0; i < w; i++) {\n      for (int j = 0; j < h; j++) {\n        if (memoB[i][j] && !memoW[i][j]) resB++;\n        if (!memoB[i][j] && memoW[i][j]) resW++;\n      }\n    }\n    cout << resB-cntB << \" \" << resW-cntW << el;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<string>\n#include<string.h>\n#include<functional>\nusing namespace std;\n\n#define INF 1<<21\n#define DIV 1000000007\n\ntypedef pair<int, int>P;\n\n\nint w, h;\nint cnt;\nchar f[51][51];\nint dx[] = { 1,-1,0,0 }, dy[] = { 0,0,1,-1 };\n\nvoid rec(int x, int y, char c) {\n  for (int i = 0; i < 4; i++) {\n\tint nx = x + dx[i];\n\tint ny = y + dy[i];\n\tif (nx <= 0 || w < nx || ny <= 0 || h < ny )continue;\n\n\tif (c == 'B') {\n\t  if (f[ny][nx] == 'w') {\n\t\tf[ny][nx] = 'u';\n\t\trec(nx, ny, c);\n\t  }\n\t  else if (f[ny][nx] == '.') {\n\t\tf[ny][nx] = 'b';\n\t\trec(nx, ny, c);\n\t  }\n\t}\n\telse if (c == 'W') {\n\t  if (f[ny][nx] == 'b') {\n\t\tf[ny][nx] = 'u';\n\t\trec(nx, ny, c);\n\t  }\n\t  else if (f[ny][nx] == '.') {\n\t\tf[ny][nx] = 'w';\n\t\trec(nx, ny, c);\n\t  }\n\t}\n  }\n}\n\nint main(){\n  while (cin >> w >> h, (w || h)) {\n\tmemset(f, 0, sizeof(f));\n\tfor (int y = 1; y <= h; y++) {\n\t  for (int x = 1; x <= w; x++) {\n\t\tcin >> f[y][x];\n\t\t}\n\t  }\n\t}\n\n\tfor (int y = 1; y <= h; y++) {\n\t  for (int x = 1; x <= w; x++) {\n\t\tif (f[y][x] == 'W' || f[y][x] == 'B') {\n\t\t  rec(x, y, f[y][x]);\n\t\t}\n\t  }\n\t}\n\n\n\tint blacks = 0, whites = 0;\n\tfor (int y = 1; y<=h; y++) {\n\t  for (int x = 1; x<=w; x++) {\n\t\tcout << f[y][x] << \"\";\n\t\tif (f[y][x] == 'b') {\n\t\t  blacks++;\n\t\t}\n\t\telse if (f[y][x] == 'w') {\n\t\t  whites++;\n\t\t}\n\t  }\n\t  cout << endl;\n\t}\n\tcout << blacks << \" \" << whites << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  int w, h;\n  while (cin >> w) {\n    cin >> h;\n    vector<string> in(h);\n    for (int i = 0; i < h; i++) {\n      cin >> in[i];\n    }\n    int ans_w = 0, ans_b = 0;\n    vector<vector<int>> vis(h, vector<int>(w));\n    int dx[] = {1, -1, 0, 0}, dy[] = {0, 0, 1, -1};\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        if (vis[i][j] || in[i][j] != '.') continue;\n        //cerr << i << \" \" << j << endl;\n        vis[i][j] = 1;\n        int siz = 1;\n        queue<pair<int, int>> que;\n        que.push({i, j});\n        int col[2] = {};\n        while (que.size()) {\n          auto cur = que.front();\n          que.pop();\n          for (int k = 0; k < 4; k++) {\n            int x = cur.first + dx[k];\n            int y = cur.second + dy[k];\n            if (x < 0 || x >= h || y < 0 || y >= w || vis[x][y]) continue;\n            if (in[x][y] == 'W') {col[0] = 1; continue;}\n            if (in[x][y] == 'B') {col[1] = 1; continue;}\n            vis[x][y]++;\n            que.push({x, y});\n            siz++;\n          }\n        }\n        if (col[0] + col[1] == 2) continue;\n        if (col[0] == 1) ans_w += siz;\n        if (col[1] == 1) ans_b += siz;\n      }\n    }\n    cout << ans_b << \" \" << ans_w << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//Surrounding Area\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define INF 10\nint dx[4]={-1, 0, 1, 0}, dy[4]={0, 1, 0, -1};\nint w, h;\nint a[50][50];\n\nvoid print(){\n  for(int i=0; i<h; i++){\n    for(int j=0; j<w; j++){\n      printf(\"%3d\", a[i][j]);\n    }\n    puts(\"\");\n  }\n}\n\nbool solve(int x, int y, int c){\n  if(!(0<=x && x<h && 0<=y && y<w))return true;\n  if(a[x][y]==c || a[x][y]==c*2)return true;\n  if(a[x][y]!=0)return false;\n  bool flag=true;\n  a[x][y]=c*2;\n  for(int i=0; i<4; i++){\n    int nx=x+dx[i], ny=y+dy[i];\n    if(!solve(nx, ny, c)){\n      flag=false;\n      break;\n    }\n  }\n  if(!flag){\n    a[x][y]=INF;\n    return false;\n  }\n  else return true;\n}\n\nint main(){\n  while(cin>>w>>h, !(w==0 && h==0)){\n    memset(a, 0, sizeof(a));\n    for(int i=0; i<h; i++){\n      string s;\n      cin>>s;\n      for(int j=0; j<w; j++){\n\tif(s[j]=='W')a[i][j]=1;\n\telse if(s[j]=='B')a[i][j]=-1;\n\telse if(s[j]=='.')a[i][j]==0;\n      }\n    }\n\n    for(int i=0; i<h; i++)\n      for(int j=0; j<w; j++){\n\tif(a[i][j]==1)\n\t  for(int k=0; k<4; k++)solve(i+dx[k], j+dy[k], 1);\n\telse if(a[i][j]==-1)\n\t  for(int k=0; k<4; k++)solve(i+dx[k], j+dy[k], -1);\n      }\n    int wcnt=0, bcnt=0;\n    for(int i=0; i<h; i++){\n      for(int j=0; j<w; j++){\n\tif(a[i][j]==2)wcnt++;\n\tif(a[i][j]==-2)bcnt++;\n      }\n    }\n    cout<<bcnt<<\" \"<<wcnt<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<list>\n\nusing namespace std;\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing lst = list<int>;\n\nvec parent;\nvec color;\n\nint find(int i)\n{\n    if(i==parent[i])return i;\n    return parent[i]=find(parent[i]);\n}\n\nvoid unite(int i,int j)\n{\n    i=find(i);\n    j=find(j);\n    parent[i]=j;\n    color[j]=color[i]|color[j];\n}\n\nbool solve()\n{\n    int w,h;\n    cin >> w >> h;\n    if(w==0)return false;\n\n    parent=vec(w*h);\n    color=vec(w*h);\n\n    for(int i=0;i<w*h;++i)\n    {\n        parent[i]=i;\n        color[i]=0;\n    }\n\n    mat Tochi(h,vec(w));\n    for(int i=0;i<h;++i)\n    {\n        string s;\n        cin >> s;\n        for(int j=0;j<w;++j)\n        {\n            char c = s[j];\n            if(c=='.')Tochi[i][j]=0;\n            else if(c=='B')Tochi[i][j]=1;\n            else if(c=='W')Tochi[i][j]=2;\n\n            if(i!=0)\n            {\n                if(Tochi[i][j]==0&&Tochi[i-1][j]!=0)\n                {\n                    color[i*w+j]=color[i*w+j] | Tochi[i-1][j];\n                }\n                else if(Tochi[i][j]!=0&&Tochi[i-1][j]==0)\n                {\n                    color[(i-1)*w+j]=color[(i-1)*w+j] | Tochi[i][j];\n                }\n            }\n            if(j!=0)\n            {\n                if(Tochi[i][j]==0&&Tochi[i][j-1]!=0)\n                {\n                    color[i*w+j]=color[i*w+j] | Tochi[i][j-1];\n                }\n                else if(Tochi[i][j]!=0&&Tochi[i][j-1]==0)\n                {\n                    color[i*w+j-1]=color[i*w+j-1] | Tochi[i][j];\n                }\n            }\n        }\n    }\n\n    for(int i=0;i<h;++i)\n    {\n        for(int j=0;j<w;++j)\n        {\n            if(i!=0&&Tochi[i][j]==0&&Tochi[i-1][j]==0)\n            {\n                unite(i*w+j,(i-1)*w+j);\n            }\n            if(j!=0&&Tochi[i][j]==0&&Tochi[i][j-1]==0)\n            {\n                unite(i*w+j,i*w+j-1);\n            }\n        }\n    }\n\n    int ansB=0,ansW=0;\n    for(int i=0;i<w*h;++i)\n    {\n        ansB += color[find(i)]==1;\n        ansW += color[find(i)]==2;\n    }\n\n    cout << ansB << \" \" << ansW << endl;\n\n    return true;\n}\n\nint main()\n{\n    while(solve());\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\n#define stlice(from, to) substr(from, (to) - (from) + 1)\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\nusing namespace std;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\nusing vd = vector<double>;\nusing vc = vector<char>;\nusing vb = vector<bool>;\nusing vs = vector<string>;\nusing vpii = vector<pii>;\nusing vvi = vector<vi>;\nusing vvb = vector<vb>;\nusing vvpii = vector<vpii>;\ntemplate<typename A> using fn = function<A>;\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = acos(-1);\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nconstexpr bool odd(const int &n) { return n & 1; }\nconstexpr bool even(const int &n) { return !odd(n); }\nvoid solve();\nmain { solve(); return 0; }\n// clang-format on\n\nvoid solve() {\n  int W, H;\n  while (cin >> W >> H, W) {\n    vs v(H);\n    rep(i, H) cin >> v[i];\n    vvi dp(H, vi(W));\n    int b = 0, w = 0;\n    rep(i, H) rep(j, W) {\n      dp[i][j] = 2 * (v[i][j] == 'B') + (v[i][j] == 'W');\n      b -= v[i][j] == 'B';\n      w -= v[i][j] == 'W';\n    }\n    rep(_, W * H) rep(i, H) rep(j, W) {\n      if (v[i][j] != '.') continue;\n      if (i > 0) dp[i][j] |= dp[i - 1][j];\n      if (j > 0) dp[i][j] |= dp[i][j - 1];\n      if (i < H - 1) dp[i][j] |= dp[i + 1][j];\n      if (j < W - 1) dp[i][j] |= dp[i][j + 1];\n    }\n    rep(i, H) rep(j, W) {\n      b += dp[i][j] == 2;\n      w += dp[i][j] == 1;\n    }\n    cout << b << ' ' << w << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(int)(a); (i)<(int)(b); ++(i))\n#define rFor(i, a, b) for(int (i)=(int)(a)-1; (i)>=(int)(b); --(i))\n#define rep(i, n) For((i), 0, (n))\n#define rrep(i, n) rFor((i), (n), 0)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> pii;\ntypedef pair<int, lint> pil;\ntypedef pair<lint, lint> pll;\ntemplate<class T> bool chmax(T &a, const T &b){if(a<b){a=b; return true;} return false;}\ntemplate<class T> bool chmin(T &a, const T &b){if(a>b){a=b; return true;} return false;}\ntemplate<class T> T div_floor(const T a, const T b){return a>=0 ? a/b : (a+1)/b-1;}\ntemplate<class T> T div_ceil(const T a, const T b){return a>=0 ? (a-1)/b+1 : a/b;}\n\nconstexpr lint mod = 1e9+7;\nconstexpr lint INF = mod*mod;\nconstexpr int MAX = 100010;\n\ntypedef struct UnionFindTree{\n    vector<int> par, bl, wh;\n\n    UnionFindTree(int n){\n        par.resize(n, -1);\n        bl.resize(n, 0);\n        wh.resize(n, 0);\n    }\n\n    bool is_root(int x){\n        return par[x]<0;\n    }\n\n    int find(int x){\n        if(is_root(x)) return x;\n        return par[x] = find(par[x]);\n    }\n\n    int size(int x){\n        return -par[find(x)];\n    }\n\n    bool unite(int x, int y){\n        x = find(x);\n        y = find(y);\n        if(x == y) return false;\n        if(size(x) < size(y)) swap(x, y);\n        par[x] += par[y];\n        bl[x] |= bl[y];\n        wh[x] |= wh[y];\n        par[y] = x;\n        return true;\n    }\n\n    bool same(int x, int y){\n        return find(x) == find(y);\n    }\n\n    void set_col(int x, int c){\n        x = find(x);\n        if(c == 0) bl[x] = 1;\n        else wh[x] = 1;\n    }\n}UF;\n\nint w, h;\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {1, 0, -1, 0};\n\nint idx(int x, int y){\n    return x*w+y;\n}\n\nint main(){\n    while(scanf(\"%d%d\", &w, &h) && h){\n        char a[h][w];\n        rep(i, h)rep(j, w) scanf(\" %c\", &a[i][j]);\n        UF uf(h*w);\n        rep(x, h)rep(y, w)if(a[x][y]=='.'){\n            rep(i, 4){\n                int nx = x+dx[i], ny = y+dy[i];\n                if(0<=nx && nx<h && 0<=ny && ny<w){\n                    if(a[nx][ny] == 'B') uf.set_col(idx(x, y), 0);\n                    else if(a[nx][ny] == 'W') uf.set_col(idx(x, y), 1);\n                    else uf.unite(idx(x, y), idx(nx, ny));\n                }\n            }\n        }\n        int ansb = 0, answ = 0;\n        rep(i, h*w)if(uf.is_root(i)){\n            if(uf.bl[i] && !uf.wh[i]) ansb += uf.size(i);\n            if(!uf.bl[i] && uf.wh[i]) answ += uf.size(i);\n        }\n        printf(\"%d %d\\n\", ansb, answ);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nconst int dy[] = { 1, 0, -1, 0}, dx[] = { 0, 1, 0, -1};\nint w, h, cntw, cntb;\nbool used[2][50][50];\nchar mas[50][50];\nvoid dfs(int y,int x,bool wb){\n  if(mas[y][x] != '.' || used[wb][y][x]++) return;\n  for(int i = 0 ; i < 4 ; i++ ) dfs( y + dy[i], x + dx[i], wb);\n}\nint main(){\n  while(cin >> w >> h , w){\n    fill_n(**used,5000,0);\n    cntw = cntb = 0;\n    for(int i = 0 ; i < h ; i++ ){\n      for(int j = 0 ; j < w ; j++ ) cin >> mas[i][j];\n    }\n    for(int i = 0 ; i < h ; i++ ) for(int j = 0 ; j < w ; j++ ){\n      if(mas[i][j] == 'W') for(int k = 0 ; k < 4 ; k++ ) dfs(i+dy[k],j+dx[k],1);\n      if(mas[i][j] == 'B') for(int k = 0 ; k < 4 ; k++ ) dfs(i+dy[k],j+dx[k],0);\n    }\n    for(int i = 0 ; i < h ; i++ ){\n      for(int j = 0 ; j < w ; j++ ){\n        if(used[0][i][j] && !used[1][i][j]) cntw++;\n        else if(!used[0][i][j] && used[1][i][j]) cntb++;\n      }\n    }\n    cout << cntw << \" \" << cntb << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint W, H;\nint col, cnt;\nchar M[50][50];\nbool used[50][50];\n\n#define BLACK (1)\n#define WHITE (2)\n\nint in(int x, int y) {\n  return 0 <= x && x < W && 0 <= y && y < H;\n}\n\nvoid dfs(int x, int y) {\n  // \n  if(M[y][x] != '.') return;\n  used[y][x] = true;\n  cnt ++;\n  \n  const int dx[] = {-1, 1, 0, 0};\n  const int dy[] = {0, 0, -1, 1};\n  \n  for(int i=0; i<4; i++) {\n    int nx = x + dx[i], ny = y + dy[i];\n    if(in(nx, ny) && !used[ny][nx]) {\n      if(M[ny][nx] == 'B') col |= BLACK;\n      if(M[ny][nx] == 'W') col |= WHITE;\n      if(M[ny][nx] == '.') dfs(nx, ny);\n    }\n  }\n}\n\nint main() {\n  \n  while(cin >> W >> H && W) {\n    for(int i=0; i<H; i++)\n      for(int j=0; j<W; j++)\n\tcin >> M[i][j];\n    \n    fill(used[0], used[0]+2500, false);\n    \n    int res[4] = {};\n    for(int i=0; i<H; i++)\n      for(int j=0; j<W; j++)\n\tif(!used[i][j]) {\n\t  col = cnt = 0;\n\t  dfs(j, i);\n\t  res[col] += cnt;\n\t}\n    \n    cout << res[BLACK] << \" \" << res[WHITE] << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nint W, H; vector<string> M;\n\nconst vector<int> dx = { 0, 1, 0, -1 };\nconst vector<int> dy = { -1, 0, 1, 0 };\n\nint rec(int x, int y, vector<vector<bool> > ok)\n{\n\tif (M[y][x] == 'W')\n\t{\n\t\treturn 2;\n\t}\n\n\tif (M[y][x] == 'B')\n\t{\n\t\treturn 1;\n\t}\n\n\tint ret = 3;\n\n\tfor (int dir = 0; dir < 4; dir++)\n\t{\n\t\tint tx = x + dx[dir];\n\t\tint ty = y + dy[dir];\n\n\t\tif (0 <= tx && tx < W && 0 <= ty && ty < H && ok[ty][tx] == false)\n\t\t{\n\t\t\tvector<vector<bool> > ok2 = ok; ok2[ty][tx] = true;\n\n\t\t\tret = ret & rec(tx, ty, ok2);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint main()\n{\n\tint H, W;\n\n\twhile (true)\n\t{\n\t\tcin >> W >> H;\n\n\t\tif (W == 0 && H == 0) { break; }\n\n\t\tM = vector<string>(H);\n\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tcin >> M[i];\n\t\t}\n\n\t\tint b = 0, w = 0;\n\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tint c = rec(j, i, vector<vector<bool> >(H, vector<bool>(W, false)));\n\n\t\t\t\tb += c & 1;\n\t\t\t\tw += (c & 2) / 2;\n\t\t\t}\n\t\t}\n\n\t\tcout << b << ' ' << w << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "k"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint dxy[4] = {-1, 1, 0, 0};\nint W, H;\nchar a[60][60];\nint temp[4][60][60];\n\nvoid huga(int y, int x, int Z){//cout<<y<<\" \"<<x<<endl;\n\tint w = 0, b = 0, s = 0, ans=-3, t;\n\tqueue <P> Q;\n\t\n\tQ.push(P(y,x));\n\t\n\twhile(!Q.empty()){\n\t\tP p = Q.front();Q.pop();\n\t\tint yy = p.first, xx = p.second;//cout<<yy<<\" \"<<xx<<endl;\n\t\tfor(int i = 0; i <= 3; i++){\n\t\t\tint nx = xx+dxy[i], ny = yy+dxy[3-i];//cout<<\" \"<<ny<<\" \"<<nx<<endl;\n\t\t\tif(a[ny][nx] == '.' && !temp[Z+2][ny][nx]) {\n\t\t\t\ttemp[Z+2][ny][nx] = temp[Z][ny][nx] = 1;\n\t\t\t\tQ.push(P(ny,nx));\n\t\t\t\t//cout<<temp[2][ny][nx]<<\" \"<<temp[Z][ny][nx]<<\" AA\"<<endl;\n\t\t\t}\n\t\t\t//int fds; cin>>fds;\n\t\t}\n\t}\n}\n\nint main(){\n\t\n\twhile(1){\n\t\tint cw=0, cb=0;\n\t\tcin>>W>>H;\n\t\t\n\t\tif(!W&&!H)break;\n\t\t\n\t\tfor(int i = 0; i <= H+1; i++)\n\t\t\tfor(int j = 0; j <= W+1; j++)\n\t\t\t\ttemp[0][i][j] = temp[1][i][j] = temp[2][i][j] = 0;\n\t\t\t\t\n\t\tfor(int i = 0; i <= 60; i++)\n\t\t\ta[0][i] = a[H+1][i] = 0;\n\t\t\t\n\t\tfor(int i = 1; i <= H; i++)\n\t\t\tfor(int j = 1; j <= W; j++)\n\t\t\t\tcin>>a[i][j];\n\t\t\n\t\tfor(int i = 1; i <= H; i++){\n\t\t\tfor(int j = 1; j <= W; j++){\n\t\t\t\t//if(temp[2][i][j])continue;\n\t\t\t\tif(a[i][j] == 'B') huga(i,j,0);\n\t\t\t\telse if(a[i][j] == 'W') huga(i,j,1);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 1; i <= H; i++){\n\t\t\tfor(int j = 1; j <= W; j++){\n\t\t\t\tif(a[i][j] == '.'){\n\t\t\t\t\tif(temp[0][i][j] && !temp[1][i][j])cb++;\n\t\t\t\t\telse if(!temp[0][i][j] && temp[1][i][j])cw++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout<<cb<<\" \"<<cw<<endl;\n\t}\n\t\n\t\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int> dy = {1, 0, -1, 0};\nvector<int> dx = {0, 1, 0, -1};\nint main(){\n  while (1){\n    int w, h;\n    cin >> w >> h;\n    if (w == 0 && h == 0){\n      break;\n    }\n    vector<vector<char>> a(h + 2, vector<char>(w + 2, '#'));\n    for (int i = 1; i <= h; i++){\n      for (int j = 1; j <= w; j++){\n        cin >> a[i][j];\n      }\n    }\n    vector<vector<bool>> B(h + 2, vector<bool>(w + 2, false));\n    queue<pair<int, int>> Q1;\n    for (int i = 1; i <= h; i++){\n      for (int j = 1; j <= w; j++){\n        if (a[i][j] == 'B'){\n          Q1.push(make_pair(i, j));\n        }\n      }\n    }\n    while (!Q1.empty()){\n      int y = Q1.front().first;\n      int x = Q1.front().second;\n      Q1.pop();\n      for (int i = 0; i < 4; i++){\n        int y2 = y + dy[i];\n        int x2 = x + dx[i];\n        if (a[y2][x2] == '.' && !B[y2][x2]){\n          B[y2][x2] = true;\n          Q1.push(make_pair(y2, x2));\n        }\n      }\n    }\n    vector<vector<bool>> W(h + 2, vector<bool>(w + 2, false));\n    queue<pair<int, int>> Q2;\n    for (int i = 1; i <= h; i++){\n      for (int j = 1; j <= w; j++){\n        if (a[i][j] == 'W'){\n          Q2.push(make_pair(i, j));\n        }\n      }\n    }\n    while (!Q2.empty()){\n      int y = Q2.front().first;\n      int x = Q2.front().second;\n      Q2.pop();\n      for (int i = 0; i < 4; i++){\n        int y2 = y + dy[i];\n        int x2 = x + dx[i];\n        if (a[y2][x2] == '.' && !W[y2][x2]){\n          W[y2][x2] = true;\n          Q2.push(make_pair(y2, x2));\n        }\n      }\n    }\n    int B_ans = 0;\n    int W_ans = 0;\n    for(int i = 1; i <= h; i++){\n      for (int j = 1; j <= w; j++){\n        if (B[i][j] && !W[i][j]){\n          B_ans++;\n        }\n        if (W[i][j] && !B[i][j]){\n          W_ans++;\n        }\n      }\n    }\n    cout << B_ans << ' ' << W_ans << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint w, h;\nchar area[55][55];\nint whose[55][55];\nbool visited[2][55][55];\n\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\n\nvoid dfs(int x, int y, int c)\n{\n  visited[c][y][x] = true;\n  if(area[y][x] == '.'){\n    if(c == 0) whose[y][x]++;\n    else if(c == 1) whose[y][x]--;\n  }\n  for(int i = 0; i < 4; i++){\n    int nx = x + dx[i], ny = y + dy[i];\n    if(nx < 0 || w <= nx || ny < 0 || h <= ny) continue;\n    if(area[ny][nx] == 'B' || area[ny][nx] == 'W') continue;\n    if(visited[c][ny][nx]) continue;\n    dfs(nx, ny, c);\n  }\n  return;\n}\n\nint main()\n{\n  while(cin >> w >> h, w || h){\n    memset(area, '\\0', sizeof(area));\n    memset(whose, 0, sizeof(whose));\n    memset(visited, false, sizeof(visited));\n    for(int i = 0; i < h; i++){\n      for(int j = 0; j < w; j++) cin >> area[i][j];\n    }    \n    for(int i = 0; i < h; i++){\n      for(int j = 0; j < w; j++){\n\tif(area[i][j] == 'B') dfs(j, i, 0);\n\telse if(area[i][j] == 'W') dfs(j, i, 1);\n      }\n    }\n    int bc = 0, wc = 0;\n    for(int i = 0; i < h; i++){\n      for(int j = 0; j < w; j++){\n\t//printf(\"%2d\", whose[i][j]);\n\tif(whose[i][j] == 1) bc++;\n\telse if(whose[i][j] == -1) wc++;\n      }\n      //cout << endl;\n    }\n    cout << bc << \" \" << wc << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define ALL(a) (a).begin(),(a).end()\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define ll long long\n#define ull unsigned long long\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nusing namespace std;\n\nint main(){\n  int H,W;\n  while(true){\n    cin >> H >> W;\n    if(!H)break;\n    vector<vector<char>> mp(H,vector<char>(W));\n    vector<vector<int>> c(H,vector<int>(W,0));\n      REP(i,H)\n      REP(j,W)cin >> mp[i][j];\n      int Bct=0;int Wct =0;\n    REP(i,H){\n      REP(j,W){\n\tif(!c[i][j]){\n\t  queue<pair<int,int>> que;\n\t  que.push(make_pair(i,j));\n\t  int ct = 0;\n\t  bool isBlack = false;\n\t  bool isWhite = false;\n\t  while(que.size()){\n\t    int x = que.front().first;\n\t    int y = que.front().second;\n\t    que.pop();\n\t    REP(k,4){\n\t      int nx = x + dx[k];\n\t      int ny = y + dy[k];\n\t      if(nx<H&&nx>=0&&ny<W&&ny>=0){\n\t\tif(mp[nx][ny] == 'B')isBlack = true;\n\t\telse if(mp[nx][ny] == 'W')isWhite = true;\n\t\telse if(c[nx][ny] == 0){\n\t\t  ct++;\n\t\t  que.push(make_pair(nx,ny));\n\t\t}\n\t\tc[nx][ny] = 1;\n\t\t\n\t      }\n\t    }\n\t  }\n\t  if(isBlack&&!isWhite)Bct += ct;\n\t  else if(isWhite&&!isBlack)Wct += ct;\n\t}\n      }\n    }\n    cout << Bct << \" \" << Wct << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n\n#include <iostream>\n#include <algorithm>\n\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <string>\n#include <utility>\n#include <array>\n#include <complex>\n#include <valarray>\n\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n\nusing namespace std;\n//#define int long long\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n//typedef unsigned __int128 HASH;\ntypedef pair<int,int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ull, ull> pullull;\ntypedef pair<ll,int> plli;\ntypedef pair<double, int> pdbi;\ntypedef pair<int,pii> pipii;\ntypedef pair<ll,pll> plpll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\ntypedef vector<vector<int>> mat;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n);i>0;i--)\n#define rrep2(i,a,b) for (int i=(a);i>b;i--)\n#define pb push_back\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\nconst ll hmod1 = 999999937;\nconst ll hmod2 = 1000000000 + 9;\nconst int INF = 1<<30;\nconst ll mod = 1000000000 + 7;\nconst int dx4[4] = {1, 0, -1, 0};\nconst int dy4[4] = {0, 1, 0, -1};\nconst int dx8[8] = {1, 1, 1, 0, 0, -1, -1, -1};\nconst int dy8[8] = {0, 1, -1, 1, -1, 0, 1, -1};\nconst double pi = 3.141592653589793;\n\n#define addm(X, Y) (X) = ((X) + ((Y) % mod) + mod) % mod\n#define inside(y, x, h, w) (0 <= (y) && (y) < (h) && 0 <= (x) && (x) < (w)) ? true : false\n\nchar g[55][55];\nvoid dfs(int y, int x, int h, int w, vvi& visited, vvi& tr) {\n    visited[y][x] = 1;\n    rep(i, 4) {\n        int ny = y + dy4[i];\n        int nx = x + dx4[i];\n        if (!inside(ny, nx, h, w)) continue;\n        if (visited[ny][nx] || g[ny][nx]  == 'W' || g[ny][nx] == 'B') continue;\n        tr[ny][nx] = 1;\n        dfs(ny, nx, h, w, visited, tr);\n    }\n    return;\n}\n\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while (true) {\n        int w, h;\n        cin >> w >> h;\n        if (w == 0) break;\n        vvi visitedw(h, vi(w)); \n        vvi visitedb(h, vi(w));\n        vvi trw(h, vi(w));\n        vvi trb(h, vi(w));\n        rep(i, h)rep(j, w) cin >> g[i][j];\n        rep(i, h)rep(j, w) {\n            if (g[i][j] == 'W') {\n                dfs(i, j, h, w, visitedw, trw);\n            }\n            else if (g[i][j] == 'B') {\n                dfs(i, j, h, w, visitedb, trb);\n            }\n        }\n        int ansb = 0;\n        int answ = 0;\n        rep(i, h)rep(j, w) {\n            if (g[i][j] == 'W' || g[i][j] == 'B') continue;\n            if (trw[i][j] == 1) {\n                if (trb[i][j] == 1) continue;\n                answ++;\n            }\n            else {\n                if (trb[i][j] == 1) ansb++;\n            }\n        }\n        cout << ansb << \" \" << answ << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define all(vec) vec.begin(),vec.end()\ntypedef long long int ll;\ntypedef pair<ll,ll> P;\nconst ll MOD=1000000007LL;\nconst double INF=1000000000;\nconst int MAX=100001;\nint h,w;\nchar c[60][60];\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\nbool visited[2][60][60];\nbool field(int x,int y,int f){\n    if(x>=0&&x<w&&y>=0&&y<h&&(!visited[f][y][x])&&(c[y][x]=='.')){\n        return true;\n    }\n    return false;\n}\nvoid dfs(int x,int y,char s){\n    if(s=='W'){\n        if(!field(x,y,0)) return;\n        visited[0][y][x]=true;\n    }\n    else{\n        if(!field(x,y,1)) return;\n        visited[1][y][x]=true;\n    }\n\n    for(int i=0;i<4;i++){\n        dfs(x+dx[i],y+dy[i],s);\n    }\n}\nint main(){\n    while(cin>>w>>h,w+h){\n        for(int i=0;i<h;i++){\n            cin>>c[i];\n            for(int j=0;j<w;j++){\n                visited[0][i][j]=false;visited[1][i][j]=false;\n            }\n        }\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                \n                if(c[i][j]=='B'||c[i][j]=='W'){\n                    for(int k=0;k<4;k++){\n                        dfs(j+dx[k],i+dy[k],c[i][j]);\n                    }\n                }\n            }\n        }\n        int br=0;int wh=0;\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                if(visited[0][i][j]&&(!visited[1][i][j])){\n                    wh++;\n                }else if(visited[1][i][j]&&(!visited[0][i][j])){\n                    br++;\n                }\n            }\n        }\n        cout<<br<<\" \"<<wh<<endl;\n    }\n    return 0;\n}\n\n                           \n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint w,h,dx[4]={-1,0,1,0},dy[4]={0,1,0,-1};\nstring a[51];\nbool used[51][51];\nint dfs(int y,int x){\n  if(y==-1||y==h||x==-1||x==w)return 0;\n  if(a[y][x]=='B')return 1;\n  if(a[y][x]=='W')return 2;\n  if(used[y][x])return 0;\n  used[y][x]=1;\n  int pr=0;\n  for(int t,i=0;i<4;i++){\n    t=dfs(y+dy[i],x+dx[i]);\n    if(!pr)pr=t;\n    else if(t&&pr!=t)pr=3;\n  }\n  return pr;\n}\n\nint main(){\n  while(cin>>w>>h,w){\n    for(int i=0;i<h;i++)cin>>a[i];\n    int usedd[51][51]={};\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\t\n\tmemset(used,0,sizeof(used));\n\tif(a[i][j]=='.')usedd[i][j]=dfs(i,j);\n      }\n    int ans[5]={};\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n\tans[usedd[i][j]]++;\n    cout<<ans[1]<<\" \"<<ans[2]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <utility>\n#include <cctype>\n#define REP(i,n) for(int i=0;i<(n);i++)\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nint main()\n{\n  while(1){\n    int w, h;\n    cin >> w >> h;\n    if(w == 0 && h == 0) break;\n    char map[h][w];\n    REP(i,h){\n      REP(j,w){\n        cin >> map[i][j];\n      }\n    }\n    queue<pii> a;\n    REP(i,h){\n      REP(j,w){\n        if(map[i][j] == 'B' || map[i][j] == 'W'){\n          if(i > 0){\n            if(map[i-1][j] == '.'){\n              map[i-1][j] = tolower(map[i][j]);\n              a.push(pii(i-1,j));\n            }else if(map[i-1][j] != 'W' && map[i-1][j] != 'B' && map[i-1][j] != 'x' && map[i-1][j] != tolower(map[i][j])){\n              map[i-1][j] = 'x';\n              a.push(pii(i-1,j));\n            }\n          }\n          if(i < h - 1){\n            if(map[i+1][j] == '.'){\n              map[i+1][j] = tolower(map[i][j]);\n              a.push(pii(i+1,j));\n            }else if(map[i+1][j] != 'W' && map[i+1][j] != 'B' && map[i+1][j] != 'x' && map[i+1][j] != tolower(map[i][j])){\n              map[i+1][j] = 'x';\n              a.push(pii(i+1,j));\n            }\n          }\n          if(j > 0){\n            if(map[i][j-1] == '.'){\n              map[i][j-1] = tolower(map[i][j]);\n              a.push(pii(i,j-1));\n            }else if(map[i][j-1] != 'W' && map[i][j-1] != 'B' && map[i][j-1] != 'x' && map[i][j-1] != tolower(map[i][j])){\n              map[i][j-1] = 'x';\n              a.push(pii(i,j-1));\n            }\n          }\n          if(j < w - 1){\n            if(map[i][j+1] == '.'){\n              map[i][j+1] = tolower(map[i][j]);\n              a.push(pii(i,j+1));\n            }else if(map[i][j+1] != 'W' && map[i][j+1] != 'B' && map[i][j+1] != 'x' && map[i][j+1] != tolower(map[i][j])){\n              map[i][j+1] = 'x';\n              a.push(pii(i,j+1));\n            }\n          }\n        }\n      }\n    }\n    while(!a.empty()){\n      int x, y;\n      x = a.front().first;\n      y = a.front().second;\n      a.pop();\n      if(x > 0){\n        if(map[x][y] == 'b'){\n          if(map[x-1][y] == 'w' || map[x-1][y] == 'x'){\n            map[x][y] = map[x-1][y] = 'x';\n            a.push(pii(x,y));\n            a.push(pii(x-1,y));\n          }else if(map[x-1][y] == '.'){\n            map[x-1][y] = 'b';\n            a.push(pii(x-1,y));\n          }else if(map[x-1][y] == 'W'){\n            map[x][y] = x;\n            a.push(pii(x,y));\n          }\n        }else if(map[x][y] == 'w'){\n          if(map[x-1][y] == 'b' || map[x-1][y] == 'x'){\n            map[x][y] = map[x-1][y] = 'x';\n            a.push(pii(x,y));\n            a.push(pii(x-1,y));\n          }else if(map[x-1][y] == '.'){\n            map[x-1][y] = 'w';\n            a.push(pii(x-1,y));\n          }else if(map[x-1][y] == 'B'){\n            map[x][y] = x;\n            a.push(pii(x,y));\n          }\n        }else{\n          if(map[x-1][y] != 'B' && map[x-1][y] != 'W' && map[x-1][y] != 'x'){\n            map[x-1][y] = 'x';\n            a.push(pii(x-1,y));\n          }\n        }\n      }\n      if(x < h - 1){\n        if(map[x][y] == 'b'){\n          if(map[x+1][y] == 'w' || map[x+1][y] == 'x'){\n            map[x][y] = map[x+1][y] = 'x';\n            a.push(pii(x,y));\n            a.push(pii(x+1,y));\n          }else if(map[x+1][y] == '.'){\n            map[x+1][y] = 'b';\n            a.push(pii(x+1,y));\n          }else if(map[x-1][y] == 'W'){\n            map[x][y] = x;\n            a.push(pii(x,y));\n          }\n        }else if(map[x][y] == 'w'){\n          if(map[x+1][y] == 'b' || map[x+1][y] == 'x'){\n            map[x][y] = map[x+1][y] = 'x';\n            a.push(pii(x,y));\n            a.push(pii(x+1,y));\n          }else if(map[x+1][y] == '.'){\n            map[x+1][y] = 'w';\n            a.push(pii(x+1,y));\n          }else if(map[x-1][y] == 'B'){\n            map[x][y] = x;\n            a.push(pii(x,y));\n          }\n        }else{\n          if(map[x+1][y] != 'B' && map[x+1][y] != 'W' && map[x+1][y] != 'x'){\n            map[x+1][y] = 'x';\n            a.push(pii(x+1,y));\n          }\n        }\n      }\n      if(y > 0){\n        if(map[x][y] == 'b'){\n          if(map[x][y-1] == 'w' || map[x][y-1] == 'x'){\n            map[x][y] = map[x][y-1] = 'x';\n            a.push(pii(x,y));\n            a.push(pii(x,y-1));\n          }else if(map[x][y-1] == '.'){\n            map[x][y-1] = 'b';\n            a.push(pii(x,y-1));\n          }else if(map[x-1][y] == 'W'){\n            map[x][y] = x;\n            a.push(pii(x,y));\n          }\n        }else if(map[x][y] == 'w'){\n          if(map[x][y-1] == 'b' || map[x][y-1] == 'x'){\n            map[x][y] = map[x][y-1] = 'x';\n            a.push(pii(x,y));\n            a.push(pii(x,y-1));\n          }else if(map[x][y-1] == '.'){\n            map[x][y-1] = 'w';\n            a.push(pii(x,y-1));\n          }else if(map[x-1][y] == 'B'){\n            map[x][y] = x;\n            a.push(pii(x,y));\n          }\n        }else{\n          if(map[x][y-1] != 'B' && map[x][y-1] != 'W' && map[x][y-1] != 'x'){\n            map[x][y-1] = 'x';\n            a.push(pii(x,y-1));\n          }\n        }\n      }\n      if(y < w - 1){\n        if(map[x][y] == 'b'){\n          if(map[x][y+1] == 'w' || map[x][y+1] == 'x'){\n            map[x][y] = map[x][y+1] = 'x';\n            a.push(pii(x,y));\n            a.push(pii(x,y+1));\n          }else if(map[x][y+1] == '.'){\n            map[x][y+1] = 'b';\n            a.push(pii(x,y+1));\n          }else if(map[x-1][y] == 'W'){\n            map[x][y] = x;\n            a.push(pii(x,y));\n          }\n        }else if(map[x][y] == 'w'){\n          if(map[x][y+1] == 'b' || map[x][y+1] == 'x'){\n            map[x][y] = map[x][y+1] = 'x';\n            a.push(pii(x,y));\n            a.push(pii(x,y+1));\n          }else if(map[x][y+1] == '.'){\n            map[x][y+1] = 'w';\n            a.push(pii(x,y+1));\n          }else if(map[x-1][y] == 'B'){\n            map[x][y] = x;\n            a.push(pii(x,y));\n          }\n        }else{\n          if(map[x][y+1] != 'B' && map[x][y+1] != 'W' && map[x][y+1] != 'x'){\n            map[x][y+1] = 'x';\n            a.push(pii(x,y+1));\n          }\n        }\n      }\n    }\n    pii ans;\n    ans.first = ans.second = 0;\n    REP(i,h){\n      REP(j,w){\n          if(map[i][j] == 'b')\n          ans.first++;\n        else if(map[i][j] == 'w')\n          ans.second++;\n      }\n    }\n    cout << ans.first << \" \" << ans.second << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint w,h,c1,c2,b,d;\nchar a[51][51];\nint dfs(int i,int j){\n    if(i==h||j==w||i<0||j<0||a[i][j]=='#')return 0;\n    if(a[i][j]=='W'){d++;return 0;}\n    else if(a[i][j]=='B'){b++;return 0;}\n    int s=1;\n    a[i][j]='#';\n    s+=dfs(i+1,j);\n    s+=dfs(i-1,j);\n    s+=dfs(i,j+1);\n    s+=dfs(i,j-1);\n    return s;\n}\nint main(){\n    int i,j,ans;\n    while(cin>>w>>h,w!=0&&h!=0){\n        c1=c2=0;\n    for(i=0;i<h;i++)cin>>a[i];\n    for(i=0;i<h;i++)for(j=0;j<w;j++)if(a[i][j]=='.'){\n        d=b=0;\n        ans=dfs(i,j);\n        if(b>0&&d>0)continue;\n        else if(b>d)c1+=ans;\n        else if(b<d)c2+=ans;\n    }\n        cout<<c1<<\" \"<<c2<<endl;\n}}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n\ntypedef long long ll;\nusing namespace std;\nint mod = 1000000007;\n\nint grid[52][52];\nbool visited[52][52];\nvector<pair<int, int>> vec; \nset<int> st;\n\nint dx[] = {0, -1, 0, 1};\nint dy[] = {1, 0, -1, 0};\n\nvoid init(){\n    rep(i, 52)  rep(j, 52) {grid[i][j] = -1; visited[i][j] = false;}\n}\n\nvoid dfs(int sx, int sy, int px, int py){\n    visited[sx][sy] = true;\n    vec.push_back(make_pair(sx, sy));\n    rep(i, 4){\n        int nx = sx + dx[i];\n        int ny = sy + dy[i];\n        if(grid[nx][ny] == 0){\n            if(!visited[nx][ny]) dfs(nx, ny, sx, sy);\n        }\n        else if(grid[nx][ny] == 1) st.insert(1);\n        else if(grid[nx][ny] == 2) st.insert(2);\n    }\n}\n\nint main(void){\n    int W, H;\n    vector<pair<int, int>> ans;\n    while(true){\n        init();\n        int black = 0, white = 0;\n        cin >> W >> H;\n        if(W == 0) break;\n        string S;\n        rep(i, H){\n            cin >> S;\n            rep(j, W){\n                if(S[j] == 'W'){\n                    grid[i+1][j+1] = 1;\n                }\n                else if(S[j] == 'B'){\n                    grid[i+1][j+1] = 2;\n                }\n                else{\n                    grid[i+1][j+1] = 0;\n                }\n            }\n        }\n        for(int i = 1; i <= H; i++){\n            for(int j = 1; j <= W; j++){\n                if(grid[i][j] == 0 && !visited[i][j]){\n                    dfs(i, j, -1, -1);\n                    if(st.size() == 1){\n                        if(st.count(1)) white += vec.size();\n                        else black += vec.size();\n                    }\n                    st.clear();\n                    vec.clear();\n                }\n            }\n        }\n        ans.push_back(make_pair(black, white));\n    }\n    rep(i, ans.size()) cout << ans[i].first << \" \" << ans[i].second << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n\nint w,h,dx[]={1,0,-1,0},dy[]={0,1,0,-1},used[51][51];\nchar a[51][51];\n\nint bfs(int y,int x){\n\tif(x<0||w<=x||y<0||h<=y||used[y][x])return 0;\n\tif(a[y][x]=='W')return 2;\n\tif(a[y][x]=='B')return 1;\n\tused[y][x]=1;\n\tint res=0;\n\trep(i,4)res|=bfs(y+dy[i],x+dx[i]);\n\treturn res;\n}\n\nint main(){\n\twhile(cin>>w>>h&&w){\n\t\trep(i,h)rep(j,w)cin>>a[i][j];\n\t\tint B=0,W=0;\n\t\trep(i,h)rep(j,w)if(a[i][j]=='.'){\n\t\t\trep(k,h)fill(used[k],used[k]+w,0);\n\t\t\tint res=bfs(i,j);\n\t\t\tif(res==1)B++;\n\t\t\tif(res==2)W++;\n\t\t}\n\t\tcout<<B<<\" \"<<W<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <limits.h>\n#include <math.h>\n#include <set>\n#include <stack>\n#include <stdlib.h>\n#include <string>\n#include <vector>\n\n#define el endl\n#define fd fixed\n#define INF INT_MAX/2-1\n#define pb push_back\n\nusing namespace std;\n\nchar map[50][50];\nbool memoB[50][50];\nbool memoW[50][50];\n\nvoid search(int x, int y, int w, int h, char color) {\n  if (color == 'B') {\n    memoB[x][y] = true;\n  } else {\n    memoW[x][y] = true;\n  }\n  if (x > 0 && map[x-1][y] == '.') {\n    if ((color == 'B' && !memoB[x-1][y]) || (color == 'W' && !memoW[x-1][y])) {\n      search(x-1, y, w, h, color);\n    }\n  }\n  if (y > 0 && map[x][y-1] == '.') {\n    if ((color == 'B' && !memoB[x][y-1]) || (color == 'W' && !memoW[x][y-1])) {\n      search(x, y-1, w, h, color);\n    }\n  }\n  if (x < w-1 && map[x+1][y] == '.') {\n    if ((color == 'B' && !memoB[x+1][y]) || (color == 'W' && !memoW[x+1][y])) {\n      search(x+1, y, w, h, color);\n    }\n  }\n  if (y < h-1 && map[x][y+1] == '.') {\n    if ((color == 'B' && !memoB[x][y+1]) || (color == 'W' && !memoW[x][y+1])) {\n      search(x, y+1, w, h, color);\n    }\n  }\n}\n\nint main() {\n  int w, h, cntB, cntW, resB, resW;\n  char tmp;\n  while (cin >> w >> h, w | h) {\n    cntB = cntW = 0;\n    for (int i = 0; i < w; i++) {\n      for (int j = 0; j < h; j++) {\n        cin >> tmp;\n        map[i][j] = tmp;\n        if (tmp == '.') memoB[i][j] = memoW[i][j] = false;\n        if (tmp == 'B') memoB[i][j] = true, memoW[i][j] = false, cntB++;\n        if (tmp == 'W') memoB[i][j] = false, memoW[i][j] = true, cntW++;\n      }\n    }\n    for (int i = 0; i < w; i++) {\n      for (int j = 0; j < h; j++) {\n        if (map[i][j] == 'B') search(i, j, w, h, 'B');\n        if (map[i][j] == 'W') search(i, j, w, h, 'W');\n      }\n    }\n    resB = resW = 0;\n    for (int i = 0; i < w; i++) {\n      for (int j = 0; j < h; j++) {\n        if (memoB[i][j] && !memoW[i][j]) resB++;\n        if (!memoB[i][j] && memoW[i][j]) resW++;\n      }\n    }\n    cout << resB-cntB << \" \" << resW-cntW << el;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\nusing namespace std;\n\nint vis[60][60];\nstring map[51];\nint w,h;\n\nvoid emp(){\n  int i,j;\n\n  for(i=0;i<60;i++){\n    for(j=0;j<60;j++){\n      vis[i][j]=0;\n    }\n  }\n}\n\nvoid dfsw(int i,int j){\n  vis[i][j]+=3;\n  \n  if(j+1<w && (vis[i][j+1]==0 || vis[i][j+1]==4)) dfsw(i,j+1);\n  if(0<=i-1 && (vis[i-1][j]==0 || vis[i-1][j]==4)) dfsw(i-1,j);\n  if(0<=j-1 && (vis[i][j-1]==0 || vis[i][j-1]==4)) dfsw(i,j-1);\n  if(i+1<h && (vis[i+1][j]==0 || vis[i+1][j]==4)) dfsw(i+1,j);\n}\n\nvoid dfsb(int i,int j){\n  vis[i][j]+=4;\n  if(j+1<w && (vis[i][j+1]==0 || vis[i][j+1]==3)) dfsb(i,j+1);\n  if(0<=i-1 && (vis[i-1][j]==0 || vis[i-1][j]==3)) dfsb(i-1,j);\n  if(0<=j-1 && (vis[i][j-1]==0 || vis[i][j-1]==3)) dfsb(i,j-1);\n  if(i+1<h && (vis[i+1][j]==0 || vis[i+1][j]==3)) dfsb(i+1,j);\n}\n  \n\nint main(){\n  int i,j;\n  int bc,wc;\n\n  while(1){\n    emp();\n    bc=0;\n    wc=0;\n\n    scanf(\"%d%d\",&w,&h);\n    if(w==0 && h==0)break;\n\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tcin >> map[i][j];\n\tif(map[i][j]=='W'){\n\t  vis[i][j]=2;\n\t}else if(map[i][j]=='B'){\n\t  vis[i][j]=1;\n\t}else if(map[i][j]=='.'){\n\t  vis[i][j]=0;\n\t}\n      }\n    }\n\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tif(vis[i][j]==1)dfsb(i,j);\n\tif(vis[i][j]==2)dfsw(i,j);\n      }\n    }\n    for(i=0;i<h;i++){\n    for(j=0;j<w;j++){\n      if(vis[i][j]==4)bc++;\n      if(vis[i][j]==3)wc++;\n    }\n  }\n\n    printf(\"%d %d\\n\",bc,wc);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <limits.h>\n#include <math.h>\n#include <set>\n#include <stack>\n#include <stdlib.h>\n#include <string>\n#include <vector>\n\n#define el endl\n#define fd fixed\n#define INF INT_MAX/2-1\n#define pb push_back\n\nusing namespace std;\n\nchar map[50][50];\nbool memoB[50][50];\nbool memoW[50][50];\n\nvoid search(int x, int y, int w, int h, char color) {\n  if (color == 'B') {\n    memoB[x][y] = true;\n  } else if (color == 'W') {\n    memoW[x][y] = true;\n  } else {\n    if (memoB[x][y] && !memoW[x][y]) {\n      color = 'B';\n    } else if(!memoB[x][y] && memoW[x][y]) {\n      color = 'W';\n    }\n  }\n  if (x > 0 && map[x-1][y] == '.') {\n    if ((color == 'B' && !memoB[x-1][y]) || (color == 'W' && !memoW[x-1][y])) {\n      search(x-1, y, w, h, color);\n    }\n  }\n  if (y > 0 && map[x][y-1] == '.') {\n    if ((color == 'B' && !memoB[x][y-1]) || (color == 'W' && !memoW[x][y-1])) {\n      search(x, y-1, w, h, color);\n    }\n  }\n  if (x < w-1 && map[x+1][y] == '.') {\n    if ((color == 'B' && !memoB[x+1][y]) || (color == 'W' && !memoW[x+1][y])) {\n      search(x+1, y, w, h, color);\n    }\n  }\n  if (y < h-1 && map[x][y+1] == '.') {\n    if ((color == 'B' && !memoB[x][y+1]) || (color == 'W' && !memoW[x][y+1])) {\n      search(x, y+1, w, h, color);\n    }\n  }\n}\n\nint main() {\n  int w, h, cntB, cntW, resB, resW;\n  char tmp;\n  while (cin >> w >> h, w | h) {\n    cntB = cntW = 0;\n    for (int i = 0; i < w; i++) {\n      for (int j = 0; j < h; j++) {\n        cin >> tmp;\n        map[i][j] = tmp;\n        if (tmp == '.') memoB[i][j] = memoW[i][j] = false;\n        if (tmp == 'B') memoB[i][j] = true, memoW[i][j] = false, cntB++;\n        if (tmp == 'W') memoB[i][j] = false, memoW[i][j] = true, cntW++;\n      }\n    }\n    for (int i = 0; i < w; i++) {\n      for (int j = 0; j < h; j++) {\n        search(i, j, w, h, map[i][j]);\n      }\n    }\n    resB = resW = 0;\n    for (int i = 0; i < w; i++) {\n      for (int j = 0; j < h; j++) {\n        if (memoB[i][j] && !memoW[i][j]) resB++;\n        if (!memoB[i][j] && memoW[i][j]) resW++;\n      }\n    }\n    cout << resB-cntB << \" \" << resW-cntW << el;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <array>\n#include <set>\n#include <algorithm>\n\n#define X first\n#define Y second\n\nusing namespace std;\n\nchar table[50][50]; // [x][y]\n\nint dx[4] = { 0, 1, 0, -1 };\nint dy[4] = { 1, 0, -1, 0 };\n\nint g_count[2];\n\nvoid breadth(int x, int y) {\n\tstd::vector<pair<int, int>> queue;\n\tqueue.emplace_back(x,y);\n\tset<char> owner;\n\tint count = 0;\n\twhile (!queue.empty()) {\n\t\tauto a = queue.back();\n\t\tint x = a.X;\n\t\tint y = a.Y;\n\t\tqueue.pop_back();\n\n\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\tif (table[x + dx[i]][y + dy[i]] == '.') {\n\t\t\t\t++count;\n\t\t\t\tqueue.emplace_back(x + dx[i], y + dy[i]);\n\t\t\t\ttable[x + dx[i]][y + dy[i]] = 'H';\n\t\t\t} else {\n\t\t\t\towner.insert(table[x + dx[i]][y + dy[i]]);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (owner.count('W') != 0 && owner.count('B') == 0) {\n\t\tg_count[1] += (count != 0) ? count : 1;\n\n\t} else if (owner.count('W') == 0 && owner.count('B') != 0) {\n\t\tg_count[0] += (count != 0) ? count : 1;\n\t}\n}\n\nint main() {\n\tfor (int i = 0; i < 50; ++i) {\n\t\ttable[i][0] = 'H';\n\t\ttable[0][i] = 'H';\n\t}\n\n\twhile (true) {\n\t\tint w, h;\n\t\tcin >> w >> h;\n\t\tif (w == 0) break;\n\n\t\tg_count[0] = 0;\n\t\tg_count[1] = 0;\n\n\t\tfor (int y = 1; y <= h; ++y) {\n\t\t\tfor (int x = 1; x <= w; ++x) {\n\t\t\t\tcin >> table[x][y];\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < 50; ++i) {\n\t\t\ttable[i][h+1] = 'H';\n\t\t\ttable[w+1][i] = 'H';\n\t\t}\n\n\t\tfor (int x = 1; x <= w; ++x) {\n\t\t\tfor (int y = 1; y <= h; ++y) {\n\t\t\t\tif (table[x][y] != '.') continue;\n\t\t\t\tbreadth(x,y);\n\t\t\t}\n\t\t}\n\t\tcout << g_count[0] << \" \" << g_count[1] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint W, H;\nstring s[51];\nbool visited[51][51];\nbool dfs(int y, int x, char c) {\n    if (s[y][x] != '.' && s[y][x] != c) return false;\n    if (s[y][x] == c) return true;\n    bool ret = true;\n    rep(k, 4) {\n        int ny = y + dy[k];\n        int nx = x + dx[k];\n        if (ny < 0 || nx < 0) continue;\n        if (H <= ny || W <= nx) continue;\n        if (visited[ny][nx]) continue;\n        if (s[y][x] != '.') continue;\n        visited[ny][nx] = true;\n        ret &= dfs(ny, nx, c);\n    }\n    return ret;\n}\nvoid solve() {\n    int ans1 = 0, ans2 = 0;\n    int cnt = 0;\n    rep(i, H) rep(j, W) {\n        if (s[i][j] == '.') cnt++;\n        if (s[i][j] != '.') continue;\n        if (dfs(i, j, 'B')) ans1++;\n        memset(visited, 0, sizeof(visited));\n        if (dfs(i, j, 'W')) ans2++;\n        memset(visited, 0, sizeof(visited));\n    }\n    if (cnt == H * W) {\n        cout << \"0 0\" << endl;\n    } else {\n        cout << ans1 << \" \" << ans2 << endl;\n    }\n}\nint main() {\n    while (cin >> W >> H, W) {\n        rep(i, H) cin >> s[i];\n        solve();\n    }\n    return 0;\n}\n/*\n.....W....\n....W.W...\n...W...W..\n....W...W.\n.....W...W\n......W.W.\nBBB....W..\n..B..BBBBB\n..B..B....\n..B..B..W.\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(n);i++)\n//#define int long long\n\ntypedef pair<int, int> P;\n\nint dx[4] = { 0,0,-1,1 }, dy[4] = { 1,-1,0,0 };\nchar A[55][55];\nbool vis[55][55];\nbool black[55][55], white[55][55];\nint H, W;\nvoid bfs_B(int x, int y) {\n\tqueue<P>que;\n\tque.push({ x,y });\n\tREP(i, H)REP(j, W)vis[i][j] = false;\n\twhile (!que.empty()) {\n\t\tP p = que.front(); que.pop();\n\t\t//cout<<p.first<<\" \"<<p.second<<\" B\"<<endl;\n\t\tREP(k, 4) {\n\t\t\tint nx = p.first + dx[k], ny = p.second + dy[k];\n\t\t\tif (nx >= 0 && nx<H&&ny >= 0 && ny<W && !vis[nx][ny] && A[nx][ny] == '.') {\n\t\t\t\tblack[nx][ny] = true;\n\t\t\t\tque.push({ nx,ny });\n\t\t\t\tvis[nx][ny] = true;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid bfs_W(int x, int y) {\n\tqueue<P>que;\n\tque.push({ x,y });\n\tREP(i, H)REP(j, W)vis[i][j] = false;\n\twhile (!que.empty()) {\n\t\tP p = que.front(); que.pop();\n\t\t//cout<<p.first<<\" \"<<p.second<<\" W\"<<endl;\n\t\tREP(k, 4) {\n\t\t\tint nx = p.first + dx[k], ny = p.second + dy[k];\n\t\t\tif (nx >= 0 && nx<H&&ny >= 0 && ny<W && !vis[nx][ny] && A[nx][ny] == '.') {\n\t\t\t\twhite[nx][ny] = true;\n\t\t\t\tque.push({ nx,ny });\n\t\t\t\tvis[nx][ny] = true;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid solve() {\n\tcin >> W >> H;\n\tif (W == 0)exit(0);\n\tREP(i, H) {\n\t\tREP(j, W) {\n\t\t\tcin >> A[i][j];\n\t\t}\n\t}\n\tREP(i, H)REP(j, W) {\n\t\tvis[i][j] = false;\n\t\tblack[i][j] = false;\n\t\twhite[i][j] = false;\n\t}\n\t// REP(i,H){\n\t//     REP(j,W)cout<<A[i][j];\n\t//     cout<<endl;\n\t// }\n\tREP(i, H) {\n\t\tREP(j, W) {\n\t\t\tif (A[i][j] == 'W')bfs_W(i, j);\n\t\t\telse if (A[i][j] == 'B')bfs_B(i, j);\n\t\t}\n\t}\n\t//cout << \"done\" << endl;\n\tint cB = 0, cW = 0;\n\tREP(i, H) {\n\t\tREP(j, W) {\n\t\t\tif (A[i][j] == '.'&&black[i][j] && !white[i][j]) {\n\t\t\t\tcB++;\n\t\t\t}\n\t\t\telse if (A[i][j] == '.' && !black[i][j] && white[i][j]) {\n\t\t\t\tcW++;\n\t\t\t}\n\t\t}\n\t}\n\tcout << cB << \" \" << cW << endl;\n}\n\nsigned main() {\n\twhile (true)solve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vs=vector<string>;\nusing msi=map<string,int>;\nusing mii=map<int,int>;\nusing pii=pair<int,int>;\nusing vlai=valarray<int>;\nusing ll=long long;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define range(i,s,n) for(int i=s;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define fs first\n#define sc second\n\nint main(){\n    int w,h;\n    while(cin>>w>>h,w){\n        vs f(h+2,string(w+2,'#'));\n        bool isExist=true;\n        rep(i,h){\n            cin>>f[i+1];\n            isExist&=count(all(f[i+1]), '.')==f[i+1].length();\n            f[i+1]=\"#\"+f[i+1]+\"#\";\n        }\n        if(isExist){\n            cout<<\"0 0\"<<endl;\n            continue;\n        }\n        \n        int ans;\n        vs b;\n        \n        ans=0;\n        b=f;\n        range(y,1,h+1)range(x,1,w+1){\n            if(b[y][x]!='.')continue;\n            b[y][x]='B';\n            int isEnable=1;\n            stack<pii> bfs;\n            bfs.emplace(y,x);\n            while(!bfs.empty()){\n                auto p=bfs.top();\n                bfs.pop();\n                vi v={1,0,-1,0,1};\n                rep(i,4){\n                    int ty=p.fs,tx=p.sc;\n                    switch(b[ty+v[i]][tx+v[i+1]]){\n                        case 'W':\n                            isEnable=-100000;\n                            break;\n                        case '.':\n                            isEnable++;\n                            bfs.emplace(ty+v[i], tx+v[i+1]);\n                            b[ty+v[i]][tx+v[i+1]]='B';\n                    }\n                }\n            }\n            if(isEnable>0) ans+=isEnable;\n        }\n        cout<<ans<<\" \";\n        \n        ans=0;\n        b=f;\n        range(y,1,h+1)range(x,1,w+1){\n            if(b[y][x]!='.')continue;\n            b[y][x]='W';\n            int isEnable=1;\n            stack<pii> bfs;\n            bfs.emplace(y,x);\n            while(!bfs.empty()){\n                auto p=bfs.top();\n                bfs.pop();\n                vi v={1,0,-1,0,1};\n                rep(i,4){\n                    int ty=p.fs,tx=p.sc;\n                    switch(b[ty+v[i]][tx+v[i+1]]){\n                        case 'B':\n                            isEnable=-100000;\n                            break;\n                        case '.':\n                            isEnable++;\n                            bfs.emplace(ty+v[i], tx+v[i+1]);\n                            b[ty+v[i]][tx+v[i+1]]='W';\n                    }\n                }\n            }\n            if(isEnable>0) ans+=isEnable;\n        }\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint w, h;\nchar area[55][55];\nint whose[55][55];\nbool visited[2][55][55];\n\nint dx[] = {0, 1, 0, -1};\nint dy[] = {1, 0, -1, 0};\n\nvoid dfs(int x, int y, int c)\n{\n  visited[c][y][x] = true;\n  if(area[y][x] == '.'){\n    if(c == 0) whose[y][x]++;\n    else if(c == 1) whose[y][x]--;\n  }\n  for(int i = 0; i < 4; i++){\n    int nx = x + dx[i], ny = y + dy[i];\n    if(nx < 0 || w <= nx || ny < 0 || h <= ny) continue;\n    if(area[ny][nx] == 'B' || area[ny][nx] == 'W') continue;\n    if(visited[c][ny][nx]) continue;\n    cout << \"aaa\" << endl;\n    dfs(nx, ny, c);\n  }\n  return;\n}\n\nint main()\n{\n  while(cin >> w >> h, w || h){\n    memset(area, '\\0', sizeof(area));\n    memset(whose, 0, sizeof(whose));\n    memset(visited, false, sizeof(visited));\n    for(int i = 0; i < h; i++){\n      for(int j = 0; j < w; j++) cin >> area[i][j];\n    }    \n    for(int i = 0; i < h; i++){\n      for(int j = 0; j < w; j++){\n\tif(area[i][j] == 'B') dfs(j, i, 0);\n\telse if(area[i][j] == 'W') dfs(j, i, 1);\n      }\n    }\n    int bc = 0, wc = 0;\n    for(int i = 0; i < h; i++){\n      for(int j = 0; j < w; j++){\n\t//printf(\"%2d\", whose[i][j]);\n\tif(whose[i][j] == 1) bc++;\n\telse if(whose[i][j] == -1) wc++;\n      }\n      //cout << endl;\n    }\n    cout << bc << \" \" << wc << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define loop(n, i) for(int i=0;i<n;i++)\n#define all(v) v.begin(),v.end()\n#define HERE cout << \"HERE: \" << __LINE__ << endl;\n#define INSP(v) cout << v << \" at \" << __LINE__ << endl;\n\nusing namespace std;\ntypedef long long ll;\n\nint f[50][50];\n\nint dfs(vector<vector<int>> &m, int h, int w, vector<vector<char>> as) {\n    if (h < 0 || w < 0 || h >= m.size() || w >= m[h].size()) {\n        return 0;\n    }\n    if (as[h][w] == 'B') return 1;\n    if (as[h][w] == 'W') return 2;\n    if (f[h][w]) return m[h][w];\n    f[h][w] = 1;\n    int t=0;\n    t |= dfs(m, h-1, w, as);\n    t |= dfs(m, h+1, w, as);\n    t |= dfs(m, h, w+1, as);\n    t |= dfs(m, h, w-1, as);\n    m[h][w] = t;\n    return t;\n}\n\nint siage(vector<vector<int>> &m, int h, int w, vector<vector<char>> as, int max_num) {\n    if (h < 0 || w < 0 || h >= m.size() || w >= m[h].size()) {\n        return 0;\n    }\n    if (as[h][w] == 'B') return 0;\n    if (as[h][w] == 'W') return 0;\n    if (f[h][w]) return m[h][w];\n    f[h][w] = 1;\n    int t=0;\n    max_num = max(max_num, m[h][w]);\n    max_num = max(max_num, siage(m, h-1, w, as, max_num));\n    max_num = max(max_num, siage(m, h+1, w, as, max_num));\n    max_num = max(max_num, siage(m, h, w-1, as, max_num));\n    max_num = max(max_num, siage(m, h, w+1, as, max_num));\n    m[h][w] = max_num;\n    return max_num;\n}\n\nint main()\n{\n    int w, h;\n    while (cin >> w >> h, w) {\n        loop(50,i) loop(50,j) f[i][j] = 0;\n        vector<vector<char>> as;\n        as.resize(h);\n        loop(h,i) {\n            string s;\n            cin >> s;\n            for (char c:s) as[i].push_back(c);\n        }\n       // for(auto mm:as) {\n       //     for (auto m:mm) cout << m << ' ';\n       //     cout << endl;\n       // }\n\n        vector<vector<int>> mat(h, vector<int>(w,0));\n        loop(h,i){\n            loop(w,j){\n                if (as[i][j] == '.') {\n                    dfs(mat, i, j, as);\n                }\n            }\n        }\n        loop(50,i) loop(50,j) f[i][j] = 0;\n\n        loop(h,i){\n            loop(w,j){\n                if (as[i][j] == '.') {\n                    siage(mat, i, j, as, 0);\n                }\n            }\n        }\n        int ans_w = 0, ans_b = 0;\n        for(auto mm:mat) {\n            for (auto m:mm) {\n                if (m == 1) ans_b++;\n                if (m == 2) ans_w++;\n                //cout << m << ' ';\n            }\n            //cout << endl;\n        }\n        cout << ans_b << ' ' << ans_w << endl;\n\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nconst int dy[] = { 1, 0, -1, 0}, dx[] = { 0, 1, 0, -1};\nint w, h, cntw, cntb;\nbool used[2][50][50];\nchar mas[50][50];\nvoid dfs(int y,int x,bool wb){\n  if(y < 0 || y >= h || x < 0 || x >= w || mas[y][x] != '.' || used[wb][y][x]++) return;\n  for(int i = 0 ; i < 4 ; i++ ) dfs( y + dy[i], x + dx[i], wb);\n}\nint main(){\n  while(cin >> w >> h , w){\n    fill_n(**used,5000,0);\n    cntw = cntb = 0;\n    for(int i = 0 ; i < h ; i++ ){\n      for(int j = 0 ; j < w ; j++ ) cin >> mas[i][j];\n    }\n    for(int i = 0 ; i < h ; i++ ) for(int j = 0 ; j < w ; j++ ){\n      if(mas[i][j] == 'W') for(int k = 0 ; k < 4 ; k++ ) dfs(i+dy[k],j+dx[k],1);\n      if(mas[i][j] == 'B') for(int k = 0 ; k < 4 ; k++ ) dfs(i+dy[k],j+dx[k],0);\n    }\n    for(int i = 0 ; i < h ; i++ ){\n      for(int j = 0 ; j < w ; j++ ){\n        if(used[0][i][j] && !used[1][i][j]) cntw++;\n        else if(!used[0][i][j] && used[1][i][j]) cntb++;\n      }\n    }\n    cout << cntw << \" \" << cntb << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\nint w,h;\nstring mp[51];\nvoid check() {\n  for(int i=0;i<h;i++) \n    cout << mp[i] << endl;\n  cout <<\"--------------------\"<<endl;\n}\n\nvoid saiki(int x,int y,char sta){\n  int dx[4] = {0,0,-1,1};\n  int dy[4] = {1,-1,0,0};\n  for(int i=0;i<4;i++) {\n    int nx = x+dx[i];\n    int ny = y + dy[i];\n    if(nx < 0 || ny < 0 || nx >=w || ny >=h) continue;\n    if(mp[ny][nx] == '.'){\n      mp[ny][nx] = sta;\n      saiki(nx,ny,sta);\n    }else if((sta == '1' && mp[ny][nx] == '2') || (sta == '2' && mp[ny][nx] == '1')) {\n      mp[ny][nx] = '3';\n      saiki(nx,ny,sta);\n    } \n  }\n}\n\nint main() {\n\n  while(1) {\n    cin >> w >> h;\n    if(w == 0 && h == 0) break;\n\n    for(int i=0;i<h;i++) cin >> mp[i];\n\n    for(int i=0;i<h;i++) \n      for(int j=0;j<mp[i].size();j++) {\n\tif(mp[i][j] == 'W') saiki(j,i,'1');//,check();\n\telse if(mp[i][j] == 'B') saiki(j,i,'2');//,check();\n      }\n\n    int ans[2]={0,0};\n    for(int i=0;i<h;i++) \n      for(int j=0;j<mp[i].size();j++) {\n\tif(mp[i][j] == '1') ans[1]++;\n\telse if(mp[i][j] == '2') ans[0]++;\n      }\n    \n    // check();\n      cout << ans[0] <<\" \"<<ans[1] <<endl;\n  }\n\n  return  0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = uint32_t;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max() / 32 * 15 + 208;\n\nint main() {\n    int w, h;\n    while(cin >> w >> h, w|h){\n        vector<vector<char>> v(h+2, vector<char>(w+2, -1));\n        vector<string> g(h);\n        for (int i = 0; i < h; ++i) {\n            cin >> g[i];\n            for (int j = 0; j < w; ++j) {\n                v[i+1][j+1] = (g[i][j] != '.');\n            }\n        }\n        queue<pair<int, int>> Q;\n        array<int, 4> di = {1, -1, 0, 0}, dj = {0, 0, 1, -1};\n        vector<vector<char>> visited(h, vector<char>(w, 0));\n\n        int ansW = 0, ansB = 0;\n        for (int i = 0; i < h; ++i) {\n            for (int j = 0; j < w; ++j) {\n                for (auto &&l : visited) {\n                    fill(l.begin(),l.end(), 0);\n                }\n                int hitW = 0, hitB = 0;\n                if(g[i][j] != '.') continue;\n                Q.emplace(i, j);\n                while(!Q.empty()){\n                    int s, t; tie(s, t) = Q.front(); Q.pop();\n                    visited[s][t] = 1;\n                    for (int k = 0; k < 4; ++k) {\n                        if(v[s+di[k]+1][t+dj[k]+1] == 0 && !visited[s+di[k]][t+dj[k]]){\n                            Q.emplace(s+di[k], t+dj[k]);\n                            visited[s+di[k]][t+dj[k]] = 1;\n                        }else if(v[s+di[k]+1][t+dj[k]+1] == 1){\n                            if(g[s+di[k]][t+dj[k]] == 'B') hitB = 1;\n                            else hitW = 1;\n                        }\n                    }\n                }\n                if(hitW && !hitB) ansW++;\n                if(hitB && !hitW) ansB++;\n            }\n        }\n        cout << ansB << \" \" << ansW << \"\\n\";\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nenum{NONE,BLA,WHI};\n\nint kui[50][50]={};\nbool rin[50][50][WHI\n     ]={};\nint W,H;\nint dx[4]={1,-1,0,0};\nint dy[4]={0,0,1,-1};\nvoid clear(){\n     for(int i=0;i<50;i++){\n\t  for(int j=0;j<50;j++){\n\t       kui[i][j]=0;\n\t       rin[i][j][BLA]=false;rin[i][j][WHI]=false;\n\t  }\n     }\n}\nvoid rec(int x,int y,int color){\n     if(x>=W||x<0||y>=H||y<0) return;\n     if(kui[x][y]||rin[x][y][color])return;\n     rin[x][y][color]=true;\n     for(int i=0;i<4;i++){\n\t  rec(x+dx[i],y+dy[i],color);\n     }\n}\n\nint main(){\n     while(cin>>W>>H,W||H){\n\t  for(int i=0;i<W;i++){\n\t       for(int j=0;j<H;j++){\n\t\t    char t;\n\t\t    cin>>t;\n\t\t    switch(t){\n\t\t    case '.':\n\t\t\t break;\n\t\t    case 'B':\n\t\t\t kui[i][j]=BLA;\n\t\t\t break;\n\t\t    case 'W':\n\t\t\t kui[i][j]=WHI;\n\t\t\t break;\n\t\t    }\n\t       }\n\t  }\n\t  for(int i=0;i<W;i++){\n\t       for(int j=0;j<H;j++){\n\t\t    switch(kui[i][j]){\n\t\t    case BLA:\n\t\t\t for(int k=0;k<4;k++) rec(i+dx[k],j+dy[k],BLA);\n\t\t\t break;\n\t\t    case WHI:\n\t\t\t for(int k=0;k<4;k++) rec(i+dx[k],j+dy[k],WHI);\n\t\t\t break;\n\t\t    }\n\t       }\n\t  }\n\t  int sumw=0,sumb=0;\n\t  for(int i=0;i<W;i++){\n\t       for(int j=0;j<H;j++){\n\t\t    if(rin[i][j][BLA]&&(!rin[i][j][WHI]))sumb++;\n\t\t    if(rin[i][j][WHI]&&(!rin[i][j][BLA]))sumw++;\n\t       }\n\t  }\n\t  cout<<sumb<<\" \"<<sumw<<endl;\n\t  clear();\n     }\n     return 0;\n}\n     "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\nint w,h;\nstring grid[55],col[55];\nbool vis[55][55];\nint dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\n\nint count(char color){\n  int res = 0;\n  rep(i,h)rep(j,w)if(col[i][j]==color)res++;\n  return res;\n}\n\nvoid rec(int y,int x,int color){\n  if(vis[y][x])return;\n  vis[y][x] = true;\n\n  if(grid[y][x]=='.'){\n    if(col[y][x] == '.' || col[y][x] == color)col[y][x] = color;\n    else col[y][x] = 'G';\n  }\n    \n  rep(d,4){\n    int ny = y+dy[d], nx = x+dx[d];\n    if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n    if(grid[ny][nx]!='.')continue;\n    rec(ny,nx,color);\n  }\n}\n\nint main(){\n  while(cin >> w >> h, w){\n    rep(i,h){\n      cin >> grid[i];\n      col[i] = \"\";\n      rep(j,w)col[i] += '.';\n    }\n    \n    rep(i,h){\n      rep(j,w){\n\tif(grid[i][j]!='.'){\n\t  memset(vis,0,sizeof(vis));\n\t  rec(i,j,grid[i][j]);\n\t}\n      }\n    }\n   \n    cout << count('B') << \" \" << count('W') << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<string>\n#include<sstream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<climits>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < j; i++)\n#define FOR(i, j, k) for(int i = j; i < k; i++)\n#define P pair<int, int>\nconst int INF = INT_MAX / 2;\n\nint main(){\n    int w, h;\n    while(cin >>w >>h && (w || h)){\n\n        int black = 0, white = 0;\n        vector< vector<char> > m(h, vector<char>(w));\n\n        REP(i, h){\n            REP(j, w){\n                cin >>m[i][j];\n            }\n        }\n\n        REP(i, h){\n            REP(j, w){\n                if(m[i][j] == '.'){\n\n                    int cntb = 0, cntw = 0, cntd = 0;\n                    queue<P> open;\n                    open.push( P(i, j) );\n                    m[i][j] = '@';\n                    while(!open.empty()){\n                        P now = open.front();\n                        open.pop();\n                        cntd++;\n\n                        //debug\n                        //cout <<now.first <<\", \" <<now.second <<endl;\n\n                        int my[] = {0, 0, 1, -1};\n                        int mx[] = {1, -1, 0, 0};\n                        REP(i, 4){\n                            int ny = now.first + my[i];\n                            int nx = now.second + mx[i];\n                            if(ny >= 0 && nx >= 0 && ny < h && nx < w){\n                                if(m[ny][nx] == 'B') cntb++;\n                                if(m[ny][nx] == 'W') cntw++;\n                                if(m[ny][nx] == '.'){\n                                    open.push( P(ny, nx) );\n                                    m[ny][nx] = '@';\n                                }\n                            }\n                        }\n                    }\n                    if(cntb == 0 && cntw != 0) white += cntd;\n                    else if(cntw == 0 && cntb != 0) black += cntd;\n\n                }\n            }\n        }\n        cout <<black <<\" \" <<white <<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint h, w;\n\nchar maze[51][51];\nint bm[51][51];\nint wm[51][51];\n\nint dx[4] = {0, 0, 1, -1};\nint dy[4] = {1, -1, 0, 0};\n\nvoid dfsB(int y, int x){\n\tfor(int i = 0; i < 4; i++){\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\t\tif(0 <= nx and nx < w and 0 <= ny and ny < h and bm[ny][nx] == 0 and maze[ny][nx] == '.'){\n\t\t\tbm[ny][nx] = 1;\n\t\t\tdfsB(ny, nx);\n\t\t}\n\t}\n\treturn;\n}\n\nvoid dfsW(int y, int x){\n\tfor(int i = 0; i < 4; i++){\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\t\tif(0 <= nx and nx < w and 0 <= ny and ny < h and wm[ny][nx] == 0 and maze[ny][nx] == '.'){\n\t\t\twm[ny][nx] = 1;\n\t\t\tdfsW(ny, nx);\n\t\t}\n\t}\n\treturn;\n}\n\n\nint main(){\nwhile(1){//start\n\n\t//init\n\tfor(int i = 0; i < 50; i++){\n\t\tfor(int j = 0; j < 50; j++){\n\t\t\tmaze[i][j] = 'a';\n\t\t\tbm[i][j] = 0;\n\t\t\twm[i][j] = 0;\n\t\t}\n\t}\n\n\n\n\t//int w, h;\n\tcin >> w >> h;\n\tif(w == 0 and h == 0) break;\n\tfor(int i = 0; i < h; i++){\n\t\tfor(int j = 0; j < w; j++) cin >> maze[i][j];\n\t}\n\n\t//debug\n\tfor(int i = 0; i < h; i++){\n\t\tfor(int j = 0; j < w; j++) cout << maze[i][j] << \" \";\n\t\tcout << endl;\n\t}\n\n\tfor(int i = 0; i < h; i++){\n\t\tfor(int j = 0; j < w; j++){\n\t\t\tif(maze[i][j] == 'W') dfsW(i, j);\n\t\t\tif(maze[i][j] == 'B') dfsB(i, j);\n\t\t}\n\t}\n\n/*\n\tfor(int i = 0; i < h; i++){\n\t\tfor(int j = 0; j < w; j++){\n\t\t\tif(maze[i][j] == 'B'){\n\t\t\t\tif(i - 1 >= 0) wm[i - 1][j] = 0;\n\t\t\t\tif(i + 1 < 50) wm[i + 1][j] = 0;\n\t\t\t\tif(j - 1 >= 0) wm[i][j - 1] = 0;\n\t\t\t\tif(j + 1 < 50) wm[i][j + 1] = 0;\n\t\t\t}\n\t\t\tif(maze[i][j] == 'W'){\n\t\t\t\tif(i - 1 >= 0) bm[i - 1][j] = 0;\n\t\t\t\tif(i + 1 < 50) bm[i + 1][j] = 0;\n\t\t\t\tif(j - 1 >= 0) bm[i][j - 1] = 0;\n\t\t\t\tif(j + 1 < 50) bm[i][j + 1] = 0;\n\t\t\t}\n\t\t}\n\t}\n*/\n\tint ansb = 0;\n\tint answ = 0;\n\tfor(int i = 0; i < h; i++){\n\t\tfor(int j = 0; j < w; j++){\n\t\t\tif(wm[i][j] == 0 and bm[i][j] == 1) ansb += 1;\n\t\t\tif(bm[i][j] == 0 and wm[i][j] == 1) answ += 1;\n\t\t}\n\t}\n\n\t/*\n\tfor(int i = 0; i < h; i++){\n\t\tfor(int j = 0; j < w; j++){\n\t\t\tansb += bm[i][j];\n\t\t\tansw += wm[i][j];\n\t\t}\n\t}\n*/\n\tcout << ansb << \" \" << answ << endl;\n}//end\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CLEAR(arr, val) memset(arr, val, sizeof(arr))\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\n\n\n\nint main()\n{\n\tint w, h;\n\twhile (cin >> w >> h, w | h)\n\t{\n\t\tchar f[64][64];\n\t\tCLEAR(f, '@');\n\t\tfor (int i = 1; i <= h; ++i)\n\t\t{\n\t\t\tcin >> f[i] + 1;\n\t\t\tf[i][w + 1] = '@';\n\t\t}\n\n\t\tint white, black;\n\t\twhite = black = 0;\n\t\tfor (int y = 1; y <= h; ++y)\n\t\t{\n\t\t\tfor (int x = 1; x <= w; ++x)\n\t\t\t{\n\t\t\t\tif (f[y][x] == '.')\n\t\t\t\t{\n\t\t\t\t\tint area = 0;\n\t\t\t\t\tbool ww, bb;\n\t\t\t\t\tww = bb = false;\n\t\t\t\t\tqueue<pint> q;\n\t\t\t\t\tq.push(pint(x, y));\n\t\t\t\t\twhile (!q.empty())\n\t\t\t\t\t{\n\t\t\t\t\t\tpint t = q.front(); q.pop();\n\t\t\t\t\t\tint x = t.first, y = t.second;\n\t\t\t\t\t\tif (f[y][x] == 'W')\n\t\t\t\t\t\t\tww = true;\n\t\t\t\t\t\telse if (f[y][x] == 'B')\n\t\t\t\t\t\t\tbb = true;\n\t\t\t\t\t\telse if (f[y][x] == '.')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tf[y][x] = '@';\n\t\t\t\t\t\t\t++area;\n\t\t\t\t\t\t\trep (i, 4)\n\t\t\t\t\t\t\t\tq.push(pint(x + dx[i], y + dy[i]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (ww && !bb)\n\t\t\t\t\t\twhite += area;\n\t\t\t\t\telse if (!ww && bb)\n\t\t\t\t\t\tblack += area;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << black << \" \" << white << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nchar a[51][51];\nint w,h,bcount,wcount;\n//?????????????????????????????????????????????????????????????????????????????????????????????????????????????\nvoid white(int i,int j){\n\tif(a[i-1][j] == 'B' && i-1 >= 0){\n\t\ta[i][j] = 'n';\n\t\treturn;\n\t}\n\tif(a[i+1][j] == 'B' && i+1 < h){\n\t\ta[i][j] = 'n';\n\t\treturn;\n\t}\n\tif(a[i][j-1] == 'B' && j-1 >= 0){\n\t\ta[i][j] = 'n';\n\t\treturn;\n\t}\n\tif(a[i][j+1] == 'B' && j+1 < w){\n\t\ta[i][j] = 'n';\n\t\treturn;\n\t}\n\tif(a[i-1][j] == '.' && i-1 >= 0){\n\t\ta[i-1][j] = 'w';\n\t\twhite(i-1,j);\n\t}\n\tif(a[i+1][j] == '.' && i+1 < h){\n\t\ta[i+1][j] = 'w';\n\t\twhite(i+1,j);\n\t}\n\tif(a[i][j-1] == '.' && j-1 >= 0){\n\t\ta[i][j-1] = 'w';\n\t\twhite(i,j-1);\n\t}\n\tif(a[i][j+1] == '.' && j+1 < w){\n\t\ta[i][j+1] = 'w';\n\t\twhite(i,j+1);\n\t}\n}\n\nvoid black(int i,int j){\n\tif(a[i-1][j] == 'W' && i-1 >= 0){\n\t\ta[i][j] = 'n';\n\t\treturn;\n\t}\n\tif(a[i+1][j] == 'W' && i+1 < h){\n\t\ta[i][j] = 'n';\n\t\treturn;\n\t}\n\tif(a[i][j-1] == 'W' && j-1 >= 0){\n\t\ta[i][j] = 'n';\n\t\treturn;\n\t}\n\tif(a[i][j+1] == 'W' && j+1 < w){\n\t\ta[i][j] = 'n';\n\t\treturn;\n\t}\n\tif(a[i-1][j] == '.' && i-1 >= 0){\n\t\ta[i-1][j] = 'b';\n\t\tblack(i-1,j);\n\t}\n\tif(a[i+1][j] == '.' && i+1 < h){\n\t\ta[i+1][j] = 'b';\n\t\tblack(i+1,j);\n\t}\n\tif(a[i][j-1] == '.' && j-1 >= 0){\n\t\ta[i][j-1] = 'b';\n\t\tblack(i,j-1);\n\t}\n\tif(a[i][j+1] == '.' && j+1 < w){\n\t\ta[i][j+1] = 'b';\n\t\tblack(i,j+1);\n\t}\n}\n\nvoid none(int i,int j){\n\tif(a[i-1][j] == 'w' && i-1 >= 0){\n\t\ta[i-1][j] = 'n';\n\t\tnone(i-1,j);\n\t}\n\tif(a[i+1][j] == 'w' && i+1 < h){\n\t\ta[i+1][j] = 'n';\n\t\tnone(i+1,j);\n\t}\n\tif(a[i][j-1] == 'w' && j-1 >= 0){\n\t\ta[i][j-1] = 'n';\n\t\tnone(i,j-1);\n\t}\n\tif(a[i][j+1] == 'w' && j+1 < w){\n\t\ta[i][j+1] = 'n';\n\t\tnone(i,j+1);\n\t}\n\tif(a[i-1][j] == 'b' && i-1 >= 0){\n\t\ta[i-1][j] = 'n';\n\t\tnone(i-1,j);\n\t}\n\tif(a[i+1][j] == 'b' && i+1 < h){\n\t\ta[i+1][j] = 'n';\n\t\tnone(i+1,j);\n\t}\n\tif(a[i][j-1] == 'b' && j-1 >= 0){\n\t\ta[i][j-1] = 'n';\n\t\tnone(i,j-1);\n\t}\n\tif(a[i][j+1] == 'b' && j+1 < w){\n\t\ta[i][j+1] = 'n';\n\t\tnone(i,j+1);\n\t}\n}\n\n\nvoid check(){\n\tfor(int i = 0;i < h;i++){\n\t\tfor(int j = 0;j < w;j++){\n\t\t\tif(a[i][j] == 'W'){\n\t\t\t\tif(a[i-1][j] == '.' && i-1 >= 0){\n\t\t\t\t\ta[i-1][j] = 'w';\n\t\t\t\t\twhite(i-1,j);\n\t\t\t\t}\n\t\t\t\tif(a[i+1][j] == '.' && i+1 < h){\n\t\t\t\t\ta[i+1][j] = 'w';\n\t\t\t\t\twhite(i+1,j);\n\t\t\t\t}\n\t\t\t\tif(a[i][j-1] == '.' && j-1 >= 0){\n\t\t\t\t\ta[i][j-1] = 'w';\n\t\t\t\t\twhite(i,j-1);\n\t\t\t\t}\n\t\t\t\tif(a[i][j+1] == '.' && j+1 < w){\n\t\t\t\t\ta[i][j+1] = 'w';\n\t\t\t\t\twhite(i,j+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(a[i][j] == 'B'){\n\t\t\t\tif(a[i-1][j] == '.' && i-1 >= 0){\n\t\t\t\t\ta[i-1][j] = 'b';\n\t\t\t\t\tblack(i-1,j);\n\t\t\t\t}\n\t\t\t\tif(a[i+1][j] == '.' && i+1 < h){\n\t\t\t\t\ta[i+1][j] = 'b';\n\t\t\t\t\tblack(i+1,j);\n\t\t\t\t}\n\t\t\t\tif(a[i][j-1] == '.' && j-1 >= 0){\n\t\t\t\t\ta[i][j-1] = 'b';\n\t\t\t\t\tblack(i,j-1);\n\t\t\t\t}\n\t\t\t\tif(a[i][j+1] == '.' && j+1 < w){\n\t\t\t\t\ta[i][j+1] = 'b';\n\t\t\t\t\tblack(i,j+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0;i < h;i++){\n\t\tfor(int j = 0;j < w;j++){\n\t\t\tif(a[i][j] == 'n'){\n\t\t\t\tnone(i,j);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(1){\n\t\tcin >> w >> h;\n\t\tif(h == 0)break;\n\t\tbcount = wcount = 0;\n\t\tfor(int i = 0;i < 51;i++){\n\t\t\tfor(int j = 0;j < 51;j++){\n\t\t\t\ta[i][j] = '0';\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < h;i++){\n\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\tcin >> a[i][j];\n\t\t\t}\n\t\t}\n\tcheck();\n\n\tfor(int i = 0;i < h;i++){\n\t\tfor(int j = 0;j < w;j++){\n\t\t\tif(a[i][j] == 'w')wcount++;\n\t\t\tif(a[i][j] == 'b')bcount++;\n\t\t\t//cout << a[i][j];\n\t\t}\n\t\t//cout << endl;\n\t}\n\tcout << bcount << \" \" << wcount <<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\n#include <list>\nusing namespace std;\nstatic const double EPS = 1e-8;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> PI;\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define SZ(a) (int(a.size()))\n#define F first\n#define S second\nconst double pi=acos(-1);\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\nint w,h;\nstring in[50];\nbool vis[50][50];\n\nvoid solve(){\n  rep(i,h)cin>>in[i];\n  int bn=0,wn=0;\n\n  rep(i,h)rep(j,w){\n    if(in[i][j]!='.')continue;\n    queue<PI> q;\n    q.push(mp(i,j));\n    bool bl=0,wh=0;\n    memset(vis,0,sizeof(vis));\n    while(!q.empty()){\n      int cx=q.front().F,cy=q.front().S;\n      q.pop();\n      if(vis[cx][cy])continue;\n      vis[cx][cy]=true;\n      rep(k,4){\n        int nx=cx+dx[k],ny=cy+dy[k];\n        if(0>nx || nx>=h ||\n           0>ny || ny>=w ||\n           vis[nx][ny])continue;\n        if(in[nx][ny]=='B'){\n          bl=true;\n          continue;\n        }\n        if(in[nx][ny]=='W'){\n            wh=true;\n            continue;\n        }\n        q.push(mp(nx,ny));\n      }\n    }\n\n    char ch;\n    if(bl && wh)ch=' ';\n    else if(bl)ch='b';\n    else if(wh)ch='w';\n    else ch=' ';\n    q=queue<PI>();\n    q.push(mp(i,j));\n    memset(vis,0,sizeof(vis));\n    while(!q.empty()){\n      int cx=q.front().F,cy=q.front().S;\n      q.pop();\n      if(vis[cx][cy])continue;\n      in[cx][cy]=ch;\n      vis[cx][cy]=true;\n      rep(k,4){\n        int nx=cx+dx[k],ny=cy+dy[k];\n        if(0>nx || nx>=h ||\n           0>ny || ny>=w ||\n           vis[nx][ny] || in[nx][ny]!='.')continue;\n        q.push(mp(nx,ny));\n      }      \n    }\n  }\n  rep(i,h)rep(j,w){\n    if(in[i][j]=='b')++bn;\n    else if(in[i][j]=='w')++wn;\n  }\n  cout<<bn<<' '<<wn<<endl;\n}\n\nmain(){\n  while(cin>>w>>h,w)\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <queue>\n#include <cstring>\n\nusing namespace std;\n\nchar field[52][52];\nbool black[52][52];\nbool white[52][52];\n\ntypedef pair<int, int> p;\n\nint t_x[] = {1, 0, -1, 0};\nint t_y[] = {0, 1, 0, -1};\n\nvoid search(int h, int w)\n{\n  char c = field[h][w];\n  queue<p> que;\n  que.push( p(h, w) );\n  while ( !que.empty() ) {\n    p n_c = que.front();\n    //cout << n_c.first << \" \" << n_c.second << endl;\n    que.pop(); \n\n    for ( int i = 0; i < 4; i++ ) {\n      int t_h = n_c.first + t_x[i];\n      int t_w = n_c.second + t_y[i];\n      if ( field[t_h][t_w] == '#' ) continue;\n      if ( field[t_h][t_w] == c || field[t_h][t_w] == '.' ) {\n\tif ( c == 'W') { \n\t  if(!white[t_h][t_w]) {\n\t    white[t_h][t_w] = true;\n\t  } else {\n\t    continue;\n\t  }\n\t}\n \tif (c == 'B') {\n\t  if (!black[t_h][t_w]) {\n\t    black[t_h][t_w] = true;\n\t  } else {\n\t    continue;\n\t  }\n\t}\n\tque.push( p(t_h, t_w) );\n      }\n    }\n  }\n}\n\n\nint main()\n{\n  while ( true ) {\n    int width, height;\n    cin >> width >> height;\n\n    if ( width == 0 && height == 0 ) break;\n\n    memset(field, '#', sizeof field);\n    memset(black, false, sizeof black);\n    memset(white, false, sizeof white);\n\n    for ( int i = 1; i <= height; i++ ) {\n      for ( int j = 1; j <= width; j++ ) {\n\tcin >> field[i][j];\n      }\n    }\n    \n    for ( int i = 1; i <= height; i++ ) {\n      for ( int j = 1; j <= width; j++ ) {\n\tif ( field[i][j] == 'W' && !white[i][j] || field[i][j] == 'B' && !black[i][j]) {\n\t  search(i, j);\n\t}\n      }\n    }\n    for (int i = 1; i <= height; i++) {\n      for (int j = 1; j <= width; j++) {\n\t//cout << ((black[i][j]) ? \"B\" : \".\");\n      }\n      //cout << endl;\n    }\n    for (int i = 1; i <= height; i++) {\n      for (int j = 1; j <= width; j++) {\n\t//cout << ((white[i][j]) ? \"W\" : \".\");\n      }\n      //cout << endl;\n    }\n    int b_counter = 0, w_counter = 0;\n    for (int i = 1; i <= height; i++) {\n      for (int j = 1; j <= width; j++) {\n\tif (field[i][j] != '.') continue;\n\tif (!black[i][j] && white[i][j]) w_counter++;\n\tif (black[i][j] && !white[i][j]) b_counter++;\n      }\n    }\n    cout << b_counter << \" \" << w_counter << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\nbool wh[51][51];\nbool bl[51][51];\nint dx[] = {1,0,-1,0};\nint dy[] = {0,1,0,-1};\nvector<string> grid;\nint w,h;\nvoid dfs(int x,int y,bool cl[51][51]){\n  REP(r,4){\n    int nx = x + dx[r];\n    int ny = y + dy[r];\n    if(nx >=0 && nx < w && ny >= 0 && ny < h){\n      if(grid[ny][nx] == '.' && !cl[ny][nx]){\n        cl[ny][nx] = true;\n        dfs(nx,ny,cl);\n      }\n    }\n  }\n}\nint main(){\n  while(cin>>w>>h,w){\n    memset(wh,0,sizeof(wh));\n    memset(bl,0,sizeof(bl));\n    grid = vector<string>(h);\n    REP(i,h)cin>>grid[i];\n    REP(y,h)REP(x,w){\n      if(grid[y][x]=='W'){\n        dfs(x,y,wh);\n      }else if(grid[y][x] == 'B'){\n        dfs(x,y,bl);\n      }\n    }\n    int ans1=0,ans2=0;\n    REP(y,h)REP(x,w){\n      if(bl[y][x]&&!wh[y][x])ans1++;\n      if(wh[y][x]&&!bl[y][x])ans2++;\n    }\n    printf(\"%d %d\\n\",ans1,ans2);\n  }\n  \n  return 0;\n}\n\n\n\n  "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double PI = 3.14159265358979;\nconst double E = 2.718281828459045;\nconst double root2 = sqrt(2);\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\nconst ll key = 998244353;\nint main() {\n\tint w, h;\n\tint dir1[4] = {1,0,-1,0};\n\tint dir2[4] = { 0,1,0,-1 };\n\twhile (cin >> w >> h, w) {\n\t\tchar lan[52][52]; char b[52][52]; char r[52][52];\n\t\tfor (int i = 0; i < 52; i++) {\n\t\t\tfor (int j = 0; j < 52; j++) {\n\t\t\t\tlan[i][j] = '0'; b[i][j] = '0'; r[i][j] = '0';\n\t\t\t}\n\t\t}\n\t\tstring s;\n\t\tfor (int i = 1; i <= h; i++) {\n\t\t\tcin >> s;\n\t\t\tfor (int j = 1; j <= w; j++) {\n\t\t\t\tlan[i][j] = s[j-1];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i <= h; i++) {\n\t\t\tfor (int j = 1; j <= w; j++) {\n\t\t\t\tif (lan[i][j] == 'W') {\n\t\t\t\t\tvector<P>v;\n\t\t\t\t\tv.push_back({ i,j });\n\t\t\t\t\twhile (!v.empty()) {\n\t\t\t\t\t\tint x = v[0].first; int y = v[0].second; v.erase(v.begin());\n\t\t\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\t\t\tif(lan[x+dir1[k]][y+dir2[k]]=='.'&&r[x+dir1[k]][y+dir2[k]]=='0'){\n\t\t\t\t\t\t\t\tr[x + dir1[k]][y + dir2[k]] = '1';\n\t\t\t\t\t\t\t\tv.push_back({ x + dir1[k],y + dir2[k] });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (lan[i][j] == 'B') {\n\t\t\t\t\tvector<P>v;\n\t\t\t\t\tv.push_back({ i,j });\n\t\t\t\t\twhile (!v.empty()) {\n\t\t\t\t\t\tint x = v[0].first; int y = v[0].second; v.erase(v.begin());\n\t\t\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\t\t\tif (lan[x + dir1[k]][y + dir2[k]] == '.'&&b[x + dir1[k]][y + dir2[k]] == '0') {\n\t\t\t\t\t\t\t\tb[x + dir1[k]][y + dir2[k]] = '1';\n\t\t\t\t\t\t\t\tv.push_back({ x + dir1[k],y + dir2[k] });\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint bcnt = 0; int wcnt = 0;\n\t\tfor (int i = 1; i <= h; i++) {\n\t\t\tfor (int j = 1; j <= w; j++) {\n\t\t\t\tif (r[i][j] == '1' && b[i][j] == '0') {\n\t\t\t\t\twcnt++;\n\t\t\t\t}\n\t\t\t\telse if (r[i][j] == '0'&&b[i][j] == '1') {\n\t\t\t\t\tbcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << bcnt << \" \" << wcnt << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint w, h;\nchar data[50][50];\nint cnt;\nchar bw;\nbool flag;\n\nvoid rec(int x, int y) {\n  static int d[4][2] = {{1,0},{0,1},{-1,0},{0,-1}};\n  data[y][x] = '#';\n  cnt++;\n  for(int i = 0; i < 4; i++) {\n    int nx = x + d[i][0];\n    int ny = y + d[i][1];\n    if(nx < 0 || nx >= w) continue;\n    if(ny < 0 || ny >= h) continue;\n    if(data[ny][nx] == '#') continue;\n    if(data[ny][nx] != '.') {\n      if(bw == '.') bw = data[ny][nx];\n      else if(data[ny][nx] != bw) flag = false;\n      continue;\n    }\n    rec(nx, ny);\n  }\n}\n\nint main() {\n  while(1) {\n    cin >> w >> h;\n    if(w == 0 && h == 0) break;\n    for(int i = 0; i < h; i++) {\n      for(int j = 0; j < w; j++) {\n\tcin >> data[i][j];\n      }\n    }\n    int numW = 0;\n    int numB = 0;\n    for(int i = 0; i < h; i++) {\n      for(int j = 0; j < w; j++) {\n\tif(data[i][j] == '.') {\n\t  cnt = 0;\n\t  bw = '.';\n\t  flag = true;\n\t  rec(j, i);\n\t  if(flag) {\n\t    if(bw == 'B') numB += cnt;\n\t    else if(bw == 'W') numW += cnt;\n\t  }\n\t}\n      }\n    }\n    cout << numB << ' ' << numW << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\nchar map[50][50]; //map[h][w]\nint w,h;\n\nvoid scanmap(){\n\tint i;\n\tfor(i=0;i<h;i++){\n\t\tscanf(\"%s\",map[i]);\n\t}\n}\n\nvoid wpaint(int a,int b){\n\tif(a>0 && map[a-1][b] == '.'){\n\t\tmap[a-1][b] = 'w';\n\t\twpaint(a-1,b);\n\t}\n\tif(b>0 && map[a][b-1] == '.'){\n\t\tmap[a][b-1] = 'w';\n\t\twpaint(a,b-1);\n\t}\n\tif(a<h && map[a+1][b] == '.'){\n\t\tmap[a+1][b] = 'w';\n\t\twpaint(a+1,b);\n\t}\n\tif(b<w && map[a][b+1] == '.'){\n\t\tmap[a][b+1] = 'w';\n\t\twpaint(a,b+1);\n\t}\n}\n\nvoid bpaint(int a,int b){\n\tif(a>0){\n\t\tif(map[a-1][b] == '.'){\n\t\t\tmap[a-1][b] = 'b';\n\t\t\tbpaint(a-1,b);\n\t\t}else if(map[a-1][b] == 'w'){\n\t\t\tmap[a-1][b] = 'g';\n\t\t\tbpaint(a-1,b);\n\t\t}\n\t}\n\tif(b>0){\n\t\tif(map[a][b-1] == '.'){\n\t\t\tmap[a][b-1] = 'b';\n\t\t\tbpaint(a,b-1);\n\t\t}else if(map[a][b-1] == 'w'){\n\t\t\tmap[a][b-1] = 'g';\n\t\t\tbpaint(a,b-1);\n\t\t}\n\t}\n\tif(a<h){\n\t\tif(map[a+1][b] == '.'){\n\t\t\tmap[a+1][b] = 'b';\n\t\t\tbpaint(a+1,b);\n\t\t}else if(map[a+1][b] == 'w'){\n\t\t\tmap[a+1][b] = 'g';\n\t\t\tbpaint(a+1,b);\n\t\t}\n\t}\n\tif(b<w){\n\t\tif(map[a][b+1] == '.'){\n\t\t\tmap[a][b+1] = 'b';\n\t\t\tbpaint(a,b+1);\n\t\t}else if(map[a][b+1] == 'w'){\n\t\t\tmap[a][b+1] = 'g';\n\t\t\tbpaint(a,b+1);\n\t\t}\n\t}\n}\n\nint bcount(){\n\tint i,j;\n\tint count = 0;\n\tfor(i=0;i<h;i++){\n\t\tfor(j=0;j<w;j++){\n\t\t\tif(map[i][j] == 'b') count++;\n\t\t}\n\t}\n\treturn count;\n}\n\nint wcount(){\n\tint i,j;\n\tint count = 0;\n\tfor(i=0;i<h;i++){\n\t\tfor(j=0;j<w;j++){\n\t\t\tif(map[i][j] == 'w') count++;\n\t\t}\n\t}\n\treturn count;\n}\n\nvoid printmap(){\n\tint i;\n\tfor(i=0;i<h;i++){\n\t\tprintf(\"%s\\n\",map[i]);\n\t}\n}\n\nvoid area(){\n\tscanmap();\n\tint i,j;\n\tfor(i=0;i<h;i++){\n\t\tfor(j=0;j<w;j++){\n\t\t\tif(map[i][j] == 'W') wpaint(i,j);\n\t\t}\n\t}\n\tfor(i=0;i<h;i++){\n\t\tfor(j=0;j<w;j++){\n\t\t\tif(map[i][j] == 'B') bpaint(i,j);\n\t\t}\n\t}\n\tprintf(\"%d %d\\n\",bcount(),wcount());\n//\tprintmap();\n}\n\nint main(){\n\twhile(1){\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w == 0 && h == 0) break;\n\t\tarea();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX/10;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nint main() {\n\tint h, w;\n\twhile(cin >> w >> h, h) {\n\t\tvs field(h);\n\t\tREP(i, h) {\n\t\t\tcin >> field[i];\n\t\t}\n\t\tint fb = 0, fw = 0;\n\t\tREP(i, h) {\n\t\t\tREP(j, w) {\n\t\t\t\tif(field[i][j] == 'B') {\n\t\t\t\t\tfb++;\n\t\t\t\t}\n\t\t\t\tif(field[i][j] == 'W') {\n\t\t\t\t\tfw++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tREP(i, h) {\n\t\t\tREP(j, w) {\n\t\t\t\tif(field[i][j] == '.') {\n\t\t\t\t\tstack<pii> S;\n\t\t\t\t\tS.push(make_pair(i, j));\n\t\t\t\t\tvvi visited(h, vi(w, 0));\n\t\t\t\t\tbool black = false, white = false;\n\t\t\t\t\twhile(!S.empty()) {\n\t\t\t\t\t\tpii p = S.top();\n\t\t\t\t\t\tS.pop();\n\t\t\t\t\t\tif(visited[p.first][p.second]) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvisited[p.first][p.second] = 1;\n\t\t\t\t\t\tREP(d, 4) {\n\t\t\t\t\t\t\tint ny = p.first + dy[d];\n\t\t\t\t\t\t\tint nx = p.second + dx[d];\n\t\t\t\t\t\t\tif(ny<0 || h<=ny || nx<0 || w<=nx) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t} else if(field[ny][nx] == 'B') {\n\t\t\t\t\t\t\t\tblack = true;\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t} else if(field[ny][nx] == 'W') {\n\t\t\t\t\t\t\t\twhite = true;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tS.push(make_pair(ny, nx));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(black & white) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else if(black) {\n\t\t\t\t\t\tREP(i, h) {\n\t\t\t\t\t\t\tREP(j, w) {\n\t\t\t\t\t\t\t\tif(visited[i][j]) {\n\t\t\t\t\t\t\t\t\tfield[i][j] = 'B';\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if(white) {\n\t\t\t\t\t\tREP(i, h) {\n\t\t\t\t\t\t\tREP(j, w) {\n\t\t\t\t\t\t\t\tif(visited[i][j]) {\n\t\t\t\t\t\t\t\t\tfield[i][j] = 'W';\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint black = 0, white = 0;\n\t\tREP(i, h) {\n\t\t\tREP(j, w) {\n\t\t\t\tif(field[i][j] == 'B') {\n\t\t\t\t\tblack++;\n\t\t\t\t}\n\t\t\t\tif(field[i][j] == 'W') {\n\t\t\t\t\twhite++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << black-fb << \" \" << white-fw << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\nint main(){\n\tint w,h;\n\twhile(cin>>w>>h){\n\t\tif(w==0&&h==0) break;\n\t\tint k[w+2][h+2],s[w+2][h+2],nk=0,ns=0;\n\t\tfor(int i=0;i<=h+1;i++){\n\t\t\tk[0][i]=1;\n\t\t\tk[w+1][i]=1;\n\t\t\ts[0][i]=1;\n\t\t\ts[w+1][i]=1;\n\t\t}\n\t\tfor(int i=1;i<=w;i++){\n\t\t\tk[i][0]=1;\n\t\t\tk[i][h+1]=1;\n\t\t\ts[i][0]=1;\n\t\t\ts[i][h+1]=1;\n\t\t}\n\t\tstring str;\n\t\tfor(int i=1;i<=h;i++){\n\t\t\tcin>>str;\n\t\t\tfor(int j=1;j<=w;j++){\n\t\t\t\tif(str[j-1]=='.'){\n\t\t\t\t\tk[j][i]=0;\n\t\t\t\t\ts[j][i]=0;\n\t\t\t\t\tnk++;\n\t\t\t\t\tns++;\n\t\t\t\t}\n\t\t\t\telse if(str[j-1]=='B'){\n\t\t\t\t\tk[j][i]=2;\n\t\t\t\t\ts[j][i]=2;\n\t\t\t\t}\n\t\t\t\telse if(str[j-1]=='W'){\n\t\t\t\t\tk[j][i]=3;\n\t\t\t\t\ts[j][i]=3;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ct=1;\n\t\twhile(nk>0){\n\t\t\tfor(int i=1;i<=h;i++){\n\t\t\t\tfor(int j=1;j<=w;j++){\n\t\t\t\t\tif(k[j][i]==0){\n\t\t\t\t\t\tk[j][i]=6;\n\t\t\t\t\t\tnk--;\n\t\t\t\t\t\tgoto e1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\te1:;\n\t\t\tint ckk=0,cks=0;\n\t\t\tct=1;\n\t\t\twhile(ct>0){\n\t\t\t\tct=0;\n\t\t\t\tfor(int i=1;i<=h;i++){\n\t\t\t\t\tfor(int j=1;j<=w;j++){\n\t\t\t\t\t\tif(k[j][i]==6){\n\t\t\t\t\t\t\tif(k[j+1][i]==0){\n\t\t\t\t\t\t\t\tk[j+1][i]=6;\n\t\t\t\t\t\t\t\tnk--;\n\t\t\t\t\t\t\t\tct++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(k[j-1][i]==0){\n\t\t\t\t\t\t\t\tk[j-1][i]=6;\n\t\t\t\t\t\t\t\tnk--;\n\t\t\t\t\t\t\t\tct++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(k[j][i+1]==0){\n\t\t\t\t\t\t\t\tk[j][i+1]=6;\n\t\t\t\t\t\t\t\tnk--;\n\t\t\t\t\t\t\t\tct++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(k[j][i-1]==0){\n\t\t\t\t\t\t\t\tk[j][i-1]=6;\n\t\t\t\t\t\t\t\tnk--;\n\t\t\t\t\t\t\t\tct++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(k[j+1][i]==2) ckk++;\n\t\t\t\t\t\t\telse if(k[j-1][i]==2) ckk++;\n\t\t\t\t\t\t\telse if(k[j][i+1]==2) ckk++;\n\t\t\t\t\t\t\telse if(k[j][i-1]==2) ckk++;\n\t\t\t\t\t\t\telse if(k[j+1][i]==3) cks++;\n\t\t\t\t\t\t\telse if(k[j-1][i]==3) cks++;\n\t\t\t\t\t\t\telse if(k[j][i+1]==3) cks++;\n\t\t\t\t\t\t\telse if(k[j][i-1]==3) cks++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(cks>0||ckk==0){\n\t\t\t\tfor(int i=1;i<=h;i++){\n\t\t\t\t\tfor(int j=1;j<=w;j++){\n\t\t\t\t\t\tif(k[j][i]==6) k[j][i]=5;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(int i=1;i<=h;i++){\n\t\t\t\t\tfor(int j=1;j<=w;j++){\n\t\t\t\t\t\tif(k[j][i]==6) k[j][i]=4;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tct=1;\n\t\twhile(ns>0){\n\t\t\tfor(int i=1;i<=h;i++){\n\t\t\t\tfor(int j=1;j<=w;j++){\n\t\t\t\t\tif(s[j][i]==0){\n\t\t\t\t\t\ts[j][i]=6;\n\t\t\t\t\t\tns--;\n\t\t\t\t\t\tgoto e2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\te2:;\n\t\t\tint csk=0,css=0;\n\t\t\tct=1;\n\t\t\twhile(ct>0){\n\t\t\t\tct=0;\n\t\t\t\tfor(int i=1;i<=h;i++){\n\t\t\t\t\tfor(int j=1;j<=w;j++){\n\t\t\t\t\t\tif(s[j][i]==6){\n\t\t\t\t\t\t\tif(s[j+1][i]==0){\n\t\t\t\t\t\t\t\ts[j+1][i]=6;\n\t\t\t\t\t\t\t\tns--;\n\t\t\t\t\t\t\t\tct++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(s[j-1][i]==0){\n\t\t\t\t\t\t\t\ts[j-1][i]=6;\n\t\t\t\t\t\t\t\tns--;\n\t\t\t\t\t\t\t\tct++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(s[j][i+1]==0){\n\t\t\t\t\t\t\t\ts[j][i+1]=6;\n\t\t\t\t\t\t\t\tns--;\n\t\t\t\t\t\t\t\tct++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(s[j][i-1]==0){\n\t\t\t\t\t\t\t\ts[j][i-1]=6;\n\t\t\t\t\t\t\t\tns--;\n\t\t\t\t\t\t\t\tct++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(s[j+1][i]==2) csk++;\n\t\t\t\t\t\t\telse if(s[j-1][i]==2) csk++;\n\t\t\t\t\t\t\telse if(s[j][i+1]==2) csk++;\n\t\t\t\t\t\t\telse if(s[j][i-1]==2) csk++;\n\t\t\t\t\t\t\telse if(s[j+1][i]==3) css++;\n\t\t\t\t\t\t\telse if(s[j-1][i]==3) css++;\n\t\t\t\t\t\t\telse if(s[j][i+1]==3) css++;\n\t\t\t\t\t\t\telse if(s[j][i-1]==3) css++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(csk>0||css==0){\n\t\t\t\tfor(int i=1;i<=h;i++){\n\t\t\t\t\tfor(int j=1;j<=w;j++){\n\t\t\t\t\t\tif(s[j][i]==6) s[j][i]=5;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(int i=1;i<=h;i++){\n\t\t\t\t\tfor(int j=1;j<=w;j++){\n\t\t\t\t\t\tif(s[j][i]==6) s[j][i]=4;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint kazub=0,kazuw=0;\n\t\tfor(int i=1;i<=h;i++){\n\t\t\tfor(int j=1;j<=w;j++){\n\t\t\t\tif(k[j][i]==4) kazub++;\n\t\t\t\tif(s[j][i]==4) kazuw++;\n\t\t\t}\n\t\t}\n\t\tcout<<kazub<<\" \"<<kazuw<<endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, -1, 0, 1};\n\nint main()\n{\n  const int BLACK = 1 << 0;\n  const int WHITE = 1 << 1;\n\n  int w, h;\n  while (cin >> w >> h) {\n    if ((w|h) == 0)\n      break;\n\n    vector<string> area(h);\n    for (int i = 0; i < h; ++i)\n      cin >> area[i];\n\n    vector<vector<int> > color(h, vector<int>(w, 0));\n    for (int y = 0; y < h; ++y) {\n      for (int x = 0; x < w; ++x) {\n\tif (area[y][x] != '.') {\n\t  int base = 0;\n\t  if (area[y][x] == 'B')\n\t    base = BLACK;\n\t  else\n\t    base = WHITE;\n\t  queue<pair<int, int> > que;\n\t  for (int d = 0; d < 4; ++d) {\n\t    int xx = x + dx[d];\n\t    int yy = y + dy[d];\n\t    if (0 <= xx && xx < w && 0 <= yy && yy < h && area[yy][xx] == '.')\n\t      que.push(make_pair(yy, xx));\n\t  }\n\t  while (!que.empty()) {\n\t    pair<int, int> p = que.front();\n\t    que.pop();\n\n\t    if (color[p.first][p.second] & base)\n\t      continue;\n\n\t    color[p.first][p.second] |= base;\n\t    for (int d = 0; d < 4; ++d) {\n\t      int xx = p.second + dx[d];\n\t      int yy = p.first + dy[d];\n\t      if (0 <= xx && xx < w && 0 <= yy && yy < h && area[yy][xx] == '.')\n\t\tque.push(make_pair(yy, xx));\n\t    }\n\t  }\n\t}\n      }\n    }\n\n    int black = 0, white = 0;\n    for (int i = 0; i < h; ++i) {\n      for (int j = 0; j < w; ++j) {\n\tif (color[i][j] == BLACK)\n\t  ++black;\n\telse if (color[i][j] == WHITE)\n\t  ++white;\n      }\n    }\n    cout << black << \" \" << white << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reg(i,a,b) for(int i=(a);i<=(b);i++)\n\nint w,h;\nchar map[55][55];\nint bn=0,wn=0;\nbool isb,isw;\n\nint dx[4]={1,0,-1,0};\nint dy[4]={0,-1,0,1};\n\nint dfs(int y,int x){\n\tint res=0;\n\tswitch(map[y][x]){\n\tcase 0:\n\t\treturn 0;\n\tcase 'W':\n\t\tisw = true;\n\t\treturn 0;\n\tcase 'B':\n\t\tisb = true;\n\t\treturn 0;\n\tcase '.':\n\t\tmap[y][x] = 0;\n\t\tres++;\n\t\trep(i,4){\n\t\t\tres += dfs(y+dy[i],x+dx[i]);\n\t\t}\n\t\treturn res;\n\t}\n}\n\nvoid sdfs(int y,int x){\n\tisb = isw = false;\n\tint no = dfs(y,x);\n\tif(isw && (!isb))wn+=no;\n\telse if(isb && (!isw))bn+=no;\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d%d\",&w,&h);\n\t\tif(w==0)break;\n\t\tmemset(map,0,sizeof(map));\n\t\trep(y,h){\n\t\t\tscanf(\"%s\",map[y+1]+1);\n\t\t}\n\t\twn=bn=0;\n\t\treg(y,1,h){\n\t\t\treg(x,1,w){\n\t\t\t\tif(map[y][x]=='.'){\n\t\t\t\t\tsdfs(y,x);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\",bn,wn);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<algorithm>\n using namespace std;\n \n #define mkp make_pair\n #define F first\n #define S second\n #define rep(i,n) for(int i=0;i<n;i++)\n \n typedef vector<int> vint;\n typedef pair<int,int> pii;\n \nint main(){\n\tint w,h;\n\twhile(cin>>h>>w,w||h){\n\t\tvint tt(h,0);\n\t\tvector<vint> vv(w,tt);\n\t\tvector<vint> table=vv;\n\t\tint v[4][2]={0,1,1,0,0,-1,-1,0};\n\t\trep(i,w){\n\t\t\trep(j,h){\n\t\t\t\tchar t;\n\t\t\t\tcin>>t;\n\t\t\t\tif(t=='.') vv[i][j]=0;\n\t\t\t\telse if(t=='W'){\n\t\t\t\t\tvv[i][j]=1;\n\t\t\t\t\ttable[i][j]=-1;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tvv[i][j]=2;\n\t\t\t\t\ttable[i][j]=-1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i,w){\n\t\t\trep(j,h){\n\t\t\t\tif(vv[i][j]==0) continue;\n\t\t\t\telse{\n\t\t\t\t\tqueue<pii> q;\n\t\t\t\t\tq.push(mkp(i,j));\n\t\t\t\t\twhile(!q.empty()){\n\t\t\t\t\t\tpii t=q.front();\n\t\t\t\t\t\tq.pop();\n\t\t\t\t\t\trep(k,4){\n\t\t\t\t\t\t\tint x=t.F+v[k][0],y=t.S+v[k][1];\n\t\t\t\t\t\t\tif(x>=0&&y>=0&&x<w&&y<h){\n\t\t\t\t\t\t\t\tif(table[x][y]==0||table[x][y]==3-vv[i][j]){\n\t\t\t\t\t\t\t\t\ttable[x][y]+=vv[i][j];\n\t\t\t\t\t\t\t\t\tq.push(mkp(x,y));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint answ=0,ansb=0;\n\t\t//cout<<\"w h \"<<w<<\" \"<<h<<endl;\n\t\trep(i,w){\n\t\t\trep(j,h){\n\t\t\t\t//cout<<table[i][j]<<\" \";\n\t\t\t\tif(table[i][j]==1){\n\t\t\t\t\tansw++;\n\t\t\t\t}\n\t\t\t\telse if(table[i][j]==2){\n\t\t\t\t\tansb++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cout<<endl;\n\t\t}\n\t\t//cout<<endl;\n\t\tcout<<ansb<<\" \"<<answ<<endl;\n\t\t\n\t}\n\treturn 0;\n}\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define o(a) cout << a << endl\n#define int long long\n#define fi first\n#define se second\nusing namespace std;\ntypedef pair<int, int> P;\n\nint w, h;\nchar c[51][51];\nint dy[4] = {1, -1, 0, 0};\nint dx[4] = {0, 0, 1, -1};\nbool contain(int y, int x){\n    return (0 <= y && y < h && 0 <= x && x < w);\n}\n\nsigned main(){\n    while(1){\n        cin >> w >> h;\n        if(w + h == 0) break;\n        int wsum = 0, bsum = 0;\n        rep(i, 0, h){\n            rep(j, 0, w){\n                cin >> c[i][j];\n                if(c[i][j] == 'W') wsum++;\n                if(c[i][j] == 'B') bsum++;\n            }\n        }\n        int data[51][51] = {};\n        rep(i, 0, h){\n            rep(j, 0, w){\n                if(c[i][j] != '.'){\n                    int id = (c[i][j] == 'W' ? 1 : 2);\n                    int op = id * 2 % 3;\n                    string str = \"?BW\";\n                    if(data[i][j] & id) continue;\n                    queue<P> q;\n                    q.push(P(i, j));\n                    while(!q.empty()){\n                        P p = q.front(); q.pop();\n                        int y = p.first;\n                        int x = p.second;\n                        data[y][x] |= id;\n                        rep(k, 0, 4){\n                            int ny = y + dy[k];\n                            int nx = x + dx[k];\n                            if(!contain(ny, nx)) continue;\n                            if(c[ny][nx] == str[id]) continue;\n                            if(data[ny][nx] & id) continue;\n                            q.push(P(ny, nx));\n                        }\n                    }\n                }\n            }\n        }\n        int wc = 0, bc = 0;\n        rep(i, 0, h){\n            rep(j, 0, w){\n                if(data[i][j] == 1) wc++;\n                if(data[i][j] == 2) bc++;\n                // cout << data[i][j];\n            }\n            // cout << endl;\n        }\n        cout << bc - bsum << \" \" << wc - wsum << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit atof atoi \n#include <cstdio>\t\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\t\t// require fabs\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\t\t// require srand\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n#define BLACK 1\n#define WHITE 2\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nconst int dy[] = { -1, 0, 1, 0 };\nconst int dx[] = {  0, 1, 0,-1 };\n\nbool visit[55][55];\nchar island[55][55];\nint w, h;\nint curr;\n\nvoid dfs (int cx, int cy )\n{\n\tvisit[cy][cx] = true;\n\n\trep (k, 4 ){\n\t\tint ny = cy + dy[k];\n\t\tint nx = cx + dx[k];\n\t\tif (ny < 0 || nx < 0 || ny >= h || nx >= w || visit[ny][nx] ) continue;\n\t\tif (island[ny][nx] == 'B' ){\n\t\t\tcurr |= BLACK;\n\t\t\tcontinue;\n\t\t} // end if\n\t\tif (island[ny][nx] == 'W' ){\n\t\t\tcurr |= WHITE;\n\t\t\tcontinue;\n\t\t} // end if\n\t\tdfs (nx, ny );\n \t} // end rep\n}\n\nvoid dfs2 (int cx, int cy, char c )\n{\n\tisland[cy][cx] = c;\n\trep (k, 4 ){\n\t\tint nx = cx + dx[k];\n\t\tint ny = cy + dy[k];\n\t\tif (nx < 0 || nx >= w || ny < 0 || ny >= h || island[ny][nx] != '.' ) continue;\n\t\tdfs2 (nx, ny, c );\n\t} // end rep\t\n}\n\nint main()\n{\n//\tcut here before submit \n//\tfreopen (\"testcase.Surrounding_Area\", \"r\", stdin );\n\twhile (scanf (\"%d %d\", &w, &h ) && w && h ){\n\t\tmemset (visit, false, sizeof (visit ) );\n\t\tmemset (island, 0, sizeof (island ) );\n\t\trep (i, h ){\n\t\t\trep (j, w ){\n\t\t\t\tscanf ( \" %c\", &island[i][j] );\n\t\t\t} // end rep\n\t\t} // end rep\n\t\trep (y, h ){\n\t\t\trep (x, w ){\n\t\t\t\tif (!visit[y][x] && island[y][x] == '.' ){\n\t\t\t\t\tcurr = 0;\n\t\t\t\t\tdfs (x, y );\n\t\t\t\t\tif (curr == BLACK ){\n\t\t\t\t\t\tdfs2 (x, y, 'b' );\n\t\t\t\t\t}else\n\t\t\t\t\tif (curr == WHITE ){\n\t\t\t\t\t\tdfs2 (x, y, 'w' );\n\t\t\t\t\t}else\n\t\t\t\t\tif (curr == (BLACK & WHITE ) ){\n\t\t\t\t\t\tdfs2 (x, y, 'f' );\n\t\t\t\t\t} // end if\n\t\t\t\t} // end if\n\t\t\t} // end rep\n\t\t} // end rep\n\n\t\tint W = 0, B = 0;\n\t\trep (y, h ){\n\t\t\trep (x, w ){\n\t\t\t\tif (island[y][x] == 'w' ) W++;\n\t\t\t\telse\n\t\t\t\tif (island[y][x] == 'b' ) B++;\n//\t\t\t\tcout << island[y][x];\n\t\t\t} // end rep\n//\t\t\tcout << endl;\n\t\t} // end rep\n\t\tprintf (\"%d %d\\n\", B, W );\n\t} // end loop\n\n//\tprintf (\"%d\\n\", res );\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nbool vis[50][50];\nint mp[50][50];\nbool u[5];\nint w,h;\nint cnt;\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n\nint d(int y,int x){\n  int res=0;\n\n\n  if(mp[y][x]!=0){\n    u[mp[y][x]%2]=1;\n    return 0;\n  }\n  if(vis[y][x]==1) return 0;\n  vis[y][x]=1;\n\n  for(int i=0;i<4;i++){\n    int nx=dx[i]+x,ny=dy[i]+y;\n    if(nx<0 || nx>=w || ny<0 || ny>=h) continue;\n    res+=d(ny,nx);\n  }\n  return res+1;\n}\n\n\n\nint main(){\n  while(cin>>w>>h && w&&h){\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n        vis[i][j]=0;\n    for(int i=0;i<h;i++){\n      string s;\n      cin>>s;\n      for(int j=0;j<w;j++){\n        if(s[j]=='W') mp[i][j]=1;\n        else if(s[j]=='B') mp[i][j]=2;\n        else mp[i][j]=0;\n      }\n    }\n\n    int bn=0,wn=0;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n        u[0]=u[1]=0;\n        if(vis[i][j]==0) cnt = d(i,j);\n        if(u[0]==u[1])continue;\n        if(u[0]) bn+=cnt;\n        if(u[1]) wn+=cnt;\n\n        \n      }\n    cout<<bn<<\" \"<<wn<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define range(i, a, b) for(int i = (a); i < (b); i++)\n#define rep(i, a) range(i, 0, a)\nusing namespace std;\n\nbool B[50][50], W[50][50], used[50][50];\nchar a[50][50];\nint w, h;\n\nvoid dfs(int y, int x, bool flag) {\n    if (y < 0 || h <= y || x < 0 || w <= x) return;\n\n    if (a[y][x] == '.') (flag ? B[y][x] : W[y][x]) = true;\n\n    const int dy[] = {-1, 0, 1, 0},\n              dx[] = {0, -1, 0, 1};\n\n    rep (i, 4) rep (j, 4) {\n        int toy = y + dy[i], tox = x + dx[i];\n        if (toy < 0 || h <= toy || tox < 0 || w <= tox) continue;\n        if (used[toy][tox] || a[toy][tox] != '.') continue;\n        used[toy][tox] = true;\n        dfs(toy, tox, flag);\n    }\n}\n\nint main() {\n    while (cin >> w >> h, w) {\n        rep (i, h) rep (j, w) cin >> a[i][j];\n\n        rep (i, h) rep (j, w) used[i][j] = false, B[i][j] = false;\n        rep (i, h) rep (j, w) if (! used[i][j]) if (a[i][j] == 'B') {\n            used[i][j] = true;\n            dfs(i, j, true);\n        }\n\n        rep (i, h) rep (j, w) used[i][j] = false, W[i][j] = false;\n        rep (i, h) rep (j, w) if (! used[i][j]) if (a[i][j] == 'W') {\n            used[i][j] = true;\n            dfs(i, j, false);\n        }\n\n        int cntB = 0, cntW = 0;\n        rep (i, h) rep (j, w) {\n            cntB += (B[i][j] && ! W[i][j]);\n            cntW += (! B[i][j] && W[i][j]);\n        }\n        cout << cntB << \" \" << cntW << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;++i)\n#define rep1(i,n) for(int i=1;i<=n;++i)\nusing namespace std;\nint a[52][52];\nint dx[4]={0,0,-1,1};\nint dy[4]={-1,1,0,0};\nint cnt[4];\n/*  ??????.->0  ?????????\\B,W,B&W->1,2,3  ???B,W->10,20  ??->30  */\n\nvoid paint(int y,int x,int color){\n    if(a[y][x]>=3 || a[y][x]==color)return;\n    cnt[a[y][x]]--;\n    a[y][x] |= color;\n    cnt[a[y][x]]++;\n    rep(i,4)paint(y+dy[i],x+dx[i],a[y][x]);\n}\n\nint main(void){\n    int h,w;\n    char c;\n    while(cin>>w>>h, w|h){\n        rep(i,4)cnt[i]=0;\n        rep1(y,h){\n            rep1(x,w){\n                cin>>c;\n                if(c=='.')a[y][x] = 0;\n                else a[y][x] = (c=='B' ? 10 : 20);\n            }\n        }\n        rep(y,h+2) a[y][0] = a[y][w+1] = 30;\n        rep(x,w+2) a[0][x] = a[h+1][x] = 30;\n\n        rep1(y,h)rep1(x,w)if(a[y][x]>=10)rep(i,4)paint(y+dy[i],x+dx[i],a[y][x]/10);\n\n        cout<<cnt[1]<<\" \"<<cnt[2]<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint w, h;\nvector<string> feeld;\n\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {1, 0, -1, 1};\n\nvoid rec(int x, int y, int& add, int& id) {\n\tif (feeld[y][x] == 'B') {\n\t\tid |= 1;\n\t\treturn;\n\t}\n\t\n\tif (feeld[y][x] == 'W') {\n\t\tid |= 2;\n\t\treturn;\n\t}\n\t\n\tfeeld[y][x] = '-';\n\tadd++;\n\t\n\tfor (int i = 0; i < 4; i++) {\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\tif (!(0 <= nx && nx < w && 0 <= ny && ny < h)) continue;\n\t\tif (feeld[ny][nx] == '-') continue;\n\t\trec(nx, ny, add, id);\n\t}\n}\n\nvoid solve() {\n\tint ansb = 0, answ = 0;\n\t\n\tfor (int i = 0; i < h; i++) {\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tif (feeld[i][j] == '.') {\n\t\t\t\tint add = 0, id = 0;\n\t\t\t\trec(j, i, add, id);\n\t\t\t\tif (id == 1) ansb += add;\n\t\t\t\tif (id == 2) answ += add;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << ansb << \" \" << answ << endl;\n}\n\nint main() {\n\twhile (1) {\n\t\tcin >> w >> h; if (w == 0 && h == 0) break;\n\t\tfeeld.assign(h, \"\");\n\t\tfor (int i = 0; i < h; i++) cin >> feeld[i];\n\t\t\n\t\tsolve();\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\n#define rep(i, n) for(int i=0; i<(n); ++i)\nconst int dx[] = {-1, 0, 1, 0}, dy[] = {0, -1, 0, 1};\n\nint h, w;\n\ninline bool inrect(int x, int y){\n    return 0 <= x && x < h && 0 <= y && y < w;\n}\n\nint solve(vector<string>& a, char c){\n    int res = 0;\n    rep(i, h)rep(j, w)if(a[i][j] == c){\n        rep(k, 4){\n            int sx = i + dx[k], sy = j + dy[k];\n            if(!inrect(sx, sy) || a[sx][sy] != '.')continue;\n            a[sx][sy] = c;\n            bool ok = true;\n            int cnt = 0;\n            queue<pair<int, int> > q;\n            for(q.emplace(sx, sy); !q.empty();){\n                int x = q.front().first, y = q.front().second; q.pop();\n                cnt++;\n                rep(l, 4){\n                    int nx = x + dx[l], ny = y + dy[l];\n                    if(!inrect(nx, ny))continue;\n                    if(a[nx][ny] == '.'){\n                        a[nx][ny] = c;\n                        q.emplace(nx, ny);\n                    }\n                    else if(a[nx][ny] != c)ok = false;\n                }\n            }\n            if(ok)res += cnt;\n        }\n    }\n    return res;\n}\n\nint main(){\n    while(cin >> w >> h, w|h){\n        vector<string> a(h);\n        rep(i, h)cin >> a[i];\n        cout << solve(a, 'B') << \" \" << solve(a, 'W') << '\\n';\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define ALL(v) (v).begin(), (v).end()\n#define ios()                \\\n\tios::sync_with_stdio(0); \\\n\tcin.tie(0);              \\\n\tcout.tie(0)\nusing ll = long long;\nusing ull = unsigned long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing pii = pair<int, int>;\nconstexpr ll MOD = 1e9 + 7;\nconstexpr ll INF = 1LL << 60;\nconstexpr int Inf = 1e9;\ninline int in()\n{\n\tint x;\n\tcin >> x;\n\treturn x;\n}\ntemplate <typename T>\ninline void out(const T &x) { cout << x << endl; }\ntemplate <class T>\ninline bool chmin(T &a, T b)\n{\n\tif (a > b)\n\t{\n\t\ta = b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\ntemplate <class T>\ninline bool chmax(T &a, T b)\n{\n\tif (a < b)\n\t{\n\t\ta = b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n//UP = 0;RIGHT = 1; DOWN = 2; LEFT =3;\nconst int dx[] = {0, 1, 0, -1, 1, -1, 1, -1}, dy[] = {1, 0, -1, 0, 1, -1, -1, 1};\nint gcd(int a, int b)\n{\n\tif (a < b)\n\t\tgcd(b, a);\n\tint r;\n\twhile ((r = a % b))\n\t{\n\t\ta = b;\n\t\tb = r;\n\t}\n\treturn b;\n}\nvoid eratos(bool *isPrime, int max)\n{\n\tfill(isPrime, isPrime + max, true);\n\tisPrime[0] = false;\n\tisPrime[1] = false;\n\tfor (int i = 2; i <= max / i; ++i)\n\t\tif (isPrime[i])\n\t\t\tfor (int j = 2; j <= max / i; ++j)\n\t\t\t\tisPrime[i * j] = false;\n}\n//\n\nvector<int> divisor(int n)\n{\n\tvector<int> ret;\n\tfor (int i = 0; i * i <= n; i++)\n\t{\n\t\tret.push_back(i);\n\t\tif (i * i != n)\n\t\t\tret.push_back(i);\n\t}\n\tsort(ALL(ret));\n\treturn ret;\n}\n\nchar m[51][51];\nint w, h;\n\nvoid dfs(int x, int y, vector<vector<bool>> &cmap, char color, vector<vector<bool>> &checked)\n{\n\tif (x >= w || y >= h || y < 0 || x < 0) return;\n\tif (checked[x][y]) return;\n\tchecked[x][y] = true;\n\tif (m[x][y] != '.') return;\n\n\tcmap[x][y] = true;\n\tfor (int di = 0; di < 4; di++)\n\t{\n\t\tdfs(x + dx[di], y + dy[di], cmap,color,checked);\n\t}\n}\n\nvoid checkAllGrid(vector<vector<bool>> &inArea, char color)\n{\n\n\tvector<vector<bool>> checked(w,vector<bool>(h,false)) ;\n\tfor (int xi = 0; xi < w; xi++)\n\t{\n\t\tfor (int yi = 0; yi < h; yi++)\n\t\t{\n\t\t\tif (m[xi][yi] == color)\n\t\t\t{\n\t\t\t\tfor(int i = 0; i < 4; i++) {\n\t\t\t\t\tdfs(xi + dx[i], yi + dy[i], inArea, color, checked);\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nsigned main()\n{\n\twhile(true) {\n\t\tcin >> w >> h;\n\t\tif(w == 0 && h == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tfor (int yi = 0; yi < h; yi++)\n\t\t{\n\t\t\tfor (int xi = 0; xi < w; xi++)\n\t\t\t{\n\t\t\t\tcin >> m[xi][yi];\n\t\t\t}\n\t\t}\n\t\tvector<vector<bool>> warea(w,vector<bool>(h,false));\n\t\tvector<vector<bool>> barea(w,vector<bool>(h,false));\n\t\tcheckAllGrid(warea, 'W');\n\t\tcheckAllGrid(barea, 'B');\n\t\tint wAns = 0;\n\t\tfor (int xi = 0; xi < w; xi++)\n\t\t{\n\t\t\tfor (int yi = 0; yi < h; yi++)\n\t\t\t{\n\t\t\t\tif(!barea[xi][yi] && warea[xi][yi]) {\n\t\t\t\t\twAns ++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint bAns = 0;\n\t\tfor (int xi = 0; xi < w; xi++)\n\t\t{\n\t\t\tfor (int yi = 0; yi < h; yi++)\n\t\t\t{\n\t\t\t\tif(barea[xi][yi] && !warea[xi][yi]) {\n\t\t\t\t\tbAns ++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << bAns <<\" \"<< wAns << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stdexcept>\n#include<cmath>\n#include<fstream>\n#include<memory>\n#include<algorithm>\n#include<cstring>\n#include<ctime>\n#include<deque>\n#include<sstream>\n#include<iomanip>\n#include<sstream>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<string>\n#include<climits>\n#include<map>\n#include<set>\n#include<list>\n#include<cassert>\n#include<deque>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<27\n#define all(n) n.begin(),n.end()\n#define insert(a,b,c,d) PP(P(a,b),P(c,d))\n#define F first\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define S second\n#define pb push_back\n#define pf push_front\n#define LIM 100000\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\ntypedef long long ll;\ntypedef unsigned long long ull;\nconst int dx[] = {0,1,0,-1};\nconst int dy[] = {1,0,-1,0};\nchar cmap[55][55];\nbool used[55][55];\nint w,h,cost;\nbool OH_GOD;\n\nvoid input(){\n\n rep(i,h){\n      string s;\n      cin >> s;\n      rep(j,s.length()){\n\tcmap[i][j] = s[j];\n\tused[i][j] = false;\n      }\n    }\n\n}\n\nvoid ok(int x,int y,char key){\n  used[y][x] = true;\n  cost++;\n  rep(i,4){\n    int nx = x+dx[i],ny = y+dy[i];\n    if(!(0<=nx && nx <w && 0<=ny &&ny<h))continue;\n    if(used[ny][nx] || cmap[ny][nx] == key)continue;\n    if(cmap[ny][nx] != '.' && cmap[ny][nx] != key){\n      OH_GOD = false;\n      continue;\n    }\n    ok(nx,ny,key);\n  }\n}\n\nint main(){\n\n \n  while(true){\n    cin >> w >> h;\n    if(w + h == 0)break;\n    input();\n    \n    int w_cnt,b_cnt;\n    w_cnt = b_cnt = 0;\n    rep(i,h){\n      rep(j,w){\n\tif(used[i][j] || cmap[i][j] == '.')continue;\n\trep(k,4){\n\t  cost = 0;\n\t  OH_GOD = true;\n\t  if(!(0<= j+dx[k] && j+dx[k] < w && 0 <= i+dy[k] && i+dy[k] < h))continue;\n\t  if(cmap[i+dy[k]][j+dx[k]] == 'W' || cmap[i+dy[k]][j+dx[k]] == 'B')continue;\n\t  if(used[i+dy[k]][j+dx[k]])continue;\n\t  \n\t  ok(j+dx[k],i+dy[k],cmap[i][j]);\n\t  \n\t  if(OH_GOD){\n\t    cmap[i][j] == 'W'?w_cnt += cost:b_cnt += cost;\n\t  }\n\t}\n\tused[i][j] = true;\n      }\n    }\n    cout << b_cnt << \" \" << w_cnt << endl;\n\n\n  }\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define ALL(a) (a).begin(),(a).end()\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n//typedef pair<int,int> P;\nstruct P{int x,y;};\nconst ll INF=9e18;\nchar fld[50][50];\nint dx[4]={0,-1,0,1};\nint dy[4]={-1,0,1,0};\nint W,H;\nint rec(int x,int y){\n      int clr=0;\n      bool used[50][50];\n      memset(used,false,sizeof(used));\n      queue<P> Q;\n      Q.push((P){x,y});\n      while(!Q.empty()){\n            P p=Q.front();Q.pop();\n            if(used[p.x][p.y])continue;\n            if(p.x<0||p.x>=W||p.y<0||p.y>=H)continue;\n            used[p.x][p.y]=true;\n            if(fld[p.x][p.y]=='B'){clr|=2;continue;}\n            if(fld[p.x][p.y]=='W'){clr|=1;continue;}\n            REP(i,4){\n                  int nx=p.x+dx[i],ny=p.y+dy[i];\n                  if(p.x<0||p.x>=W||p.y<0||p.y>=H)continue;\n                  Q.push((P){nx,ny});\n            }\n      }\n      if(clr==1)return 0;\n      else if(clr==2)return 1;\n      else return -1;\n}\nint main(){\n      while(cin>>W>>H&&(W||H)){\n            int ans[2];\n            memset(ans,0,sizeof(ans));\n            REP(i,H)REP(j,W)cin>>fld[j][i];\n            REP(i,H){\n                  REP(j,W){\n                        if(fld[j][i]=='.'){\n                              int f=rec(j,i);\n                              if(f==-1)continue;\n                              ans[f]++;\n                        }\n                  }\n            }\n            cout<<ans[1]<<\" \"<<ans[0]<<endl;\n      }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint counter1,counter2;\nint w, h;\nint x, y;\nchar map[50][50];\n\nvoid serch_w(int x, int y);\nvoid serch_b(int x, int y);\n\nint main(){\n\n\twhile (cin >> w >> h, w&&h){\n\t\tcounter1 = 0;\n\t\tcounter2 = 0;\n\t\tfor (int i = 0; i < h; i++){\n\t\t\tfor (int j = 0; j < w; j++){\n\t\t\t\tcin >> map[i][j];\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < h; i++){\n\t\t\tfor (int j = 0; j < w; j++){\n\t\t\t\tif (map[i][j] == 'W'){\n\t\t\t\t\tx = i;\n\t\t\t\t\ty = j;\n\t\t\t\t\tserch_w(x, y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < h; i++){\n\t\t\tfor (int j = 0; j < w; j++){\n\t\t\t\tif (map[i][j] == 'B'){\n\t\t\t\t\tx = i;\n\t\t\t\t\ty = j;\n\t\t\t\t\tserch_b(x, y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < h; i++){\n\t\t\tfor (int j = 0; j < w; j++){\n\t\t\t\tif (map[i][j] == '2') counter1++;\n\t\t\t\tif (map[i][j] == '1') counter2++;\n\t\t\t}\n\t\t}\n\n\t\tcout << counter2 << \" \" <<counter1 << endl;\n\t}\n\treturn 0;\n}\n\nvoid serch_w(int x, int y){\n\n\t//if(???????????????????????&&????\\???????????????'.'??????????????)\n\tif (x + 1 < h && map[x + 1][y] == '.' && map[x + 1][y] != '2'){\n\t\tmap[x + 1][y] = '2';\n\t\tserch_w(x + 1, y);\n\t}\n\tif (y + 1 < w && map[x][y + 1] == '.' && map[x][y + 1] != '2'){\n\t\tmap[x][y + 1] = '2';\n\t\tserch_w(x, y + 1);\n\t}\n\tif (x - 1 >= 0 && map[x - 1][y] == '.' && map[x - 1][y] != '2'){\n\t\tmap[x - 1][y] = '2';\n\t\tserch_w(x - 1, y);\n\t}\n\tif (y - 1 >= 0 && map[x][y - 1] == '.' && map[x][y - 1] != '2'){\n\t\tmap[x][y - 1] = '2';\n\t\tserch_w(x, y - 1);\n\t}\n}\n\nvoid serch_b(int x, int y){\n\n\n\tif (x + 1 < h && map[x + 1][y] == '.'){\n\t\tmap[x + 1][y] = '1';\n\t\tserch_b(x + 1, y);\n\t}\n\telse if (x + 1 < h &&  map[x + 1][y] == '2'){\n\t\tmap[x + 1][y] = '3';\n\t\tserch_b(x + 1,y);\n\t}\n\n\n\tif (y + 1 < w && map[x][y + 1] == '.' ){\n\t\tmap[x][y + 1] = '1';\n\t\tserch_b(x, y + 1);\n\t}\n\telse if (y + 1 < w &&  map[x][y + 1] == '2'){\n\t\tmap[x][y + 1] = '3';\n\t\tserch_b(x, y+1);\n\t}\n\n\tif (x - 1 >= 0 && map[x - 1][y] == '.'){\n\t\tmap[x - 1][y] = '1';\n\t\tserch_b(x - 1, y);\n\t}\n\telse if (x - 1 >= 0 &&  map[x - 1][y] == '2'){\n\t\tmap[x - 1][y] ='3';\n\t\tserch_b(x - 1, y);\n\t}\n\n\tif (y - 1 >= 0 && map[x][y - 1] == '.'){\n\t\tmap[x][y - 1] = '1';\n\t\tserch_b(x, y - 1);\n\t}\n\telse if (y - 1 >= 0 &&  map[x][y - 1] == '2'){\n\t\tmap[x][y - 1] = '3';\n\t\tserch_b(x, y - 1);\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nchar island[55][55];\n\nint dh[4]={1,0,-1,0};\nint dw[4]={0,1,0,-1};\n\nint memo[55][55];\n\n\nvoid rec(int i,int j,int color){\n\tif(island[i][j]!='.')\n\t\treturn;\n\tif(memo[i][j]&(1<<color))\n\t\treturn;\n\n\tmemo[i][j]|=(1<<color);\n\n\tfor(int k=0;k<4;++k)\n\t\trec(i+dh[k],j+dw[k],color);\n\n\treturn ;\n}\n\n\nint main(void){\n\tint w,h;\n\twhile(cin >> w >> h){\n\t\tif(w==0&&h==0)\n\t\t\tbreak;\n\n\t\trep(i,55)rep(j,55) island[i][j]='#',memo[i][j]=0;\n\t\trep(i,h)rep(j,w) cin >> island[i+1][j+1];\n\n\t\tint black=0,white=0;\n\n\t\tfor(int i=1;i<=h;++i){\n\t\t\tfor(int j=1;j<=w;++j){\n\t\t\t\tif(island[i][j]=='.')\n\t\t\t\t\tcontinue;\n\t\t\t\t\n\t\t\t\tint color=-1;\n\t\t\t\tif(island[i][j]=='B')\n\t\t\t\t\tcolor=0;\n\t\t\t\tif(island[i][j]=='W')\n\t\t\t\t\tcolor=1;\n\n\t\t\t\tfor(int k=0;k<4;++k)\n\t\t\t\t\trec(i+dh[k],j+dw[k],color);\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=1;i<=h;++i){\n\t\t\tfor(int j=1;j<=w;++j){\n\t\t\t\tif(memo[i][j]==1)\n\t\t\t\t\tblack++;\n\t\t\t\tif(memo[i][j]==2)\n\t\t\t\t\twhite++;\t\t\n\t\t\t}\n\t\t}\n\t\tcout << black << \" \" << white << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n\nint dfs(std::vector<std::vector<char> > map, int w, int h, char self_color, char other_color) {\n    int dx[] = {0, 0, 1, -1};\n    int dy[] = {1, -1, 0, 0};\n\n    int first;\n    int second;\n\n    int total = 0;\n    int count; \n    bool check_surrounded;\n    bool check_only_wall;\n\n    for (int i = 1; i <= h; i++) {\n        for (int j = 1; j <= w; j++) {\n            if (map[i][j] == '.') {\n                count = 0;\n                check_surrounded = true;\n                check_only_wall = false;\n                std::stack<std::pair<int, int> > st;\n                st.push(std::make_pair(i, j));\n                map[i][j] = '$';\n\n                while (1) {\n                    if (st.empty() == 1) {\n                        break; \n                    }\n                    first = st.top().first;\n                    second = st.top().second;\n                    st.pop();\n                    ++count;\n                    for (int k = 0; k < 4; k++) {\n                        if (map[first + dx[k]][second + dy[k]] == '.') {\n                            st.push(std::make_pair(first + dx[k], second + dy[k])); \n                            map[first + dx[k]][second + dy[k]] = '$';\n                        } else if (map[first + dx[k]][second + dy[k]] == other_color) {\n                            check_surrounded = false; \n                        }\n                        if (map[first + dx[k]][second + dy[k]] == self_color) {\n                            check_only_wall = true;\n                        }\n\n                    }\n                }\n                if (check_surrounded == true && check_only_wall == true) {\n                    total += count;\n                } else {\n                    check_surrounded = true;\n                    check_only_wall = false;\n                }\n            }\n            /*\n               for (int a = 0; a <= h + 1; a++) {\n               for (int b = 0; b <= w + 1; b++) {\n               std::cout << map[a][b];\n               }\n               std::cout << std::endl;\n               }\n               std::cout << \"COUNT = \" << count << std::endl;\n               std::cout << \"TOTAL = \" << total << std::endl;\n               std::cout << std::endl;\n             */\n        }\n    }\n    return total; \n}\n\nint main(void) {\n    int w;\n    int h;\n\n    while (1) {\n        std::cin >> w >> h;\n        if (w == 0 && h == 0) {\n            break;\n        }\n\n        std::vector<std::vector<char> > map_b(h+2, std::vector<char>(w+2, '#'));\n        std::vector<std::vector<char> > map_w(h+2, std::vector<char>(w+2, '#'));\n\n        for (int i = 1; i <= h; i++) {\n            for (int j = 1; j <= w; j++) {\n                std::cin >> map_b[i][j];\n                map_w[i][j] = map_b[i][j];\n            }\n        }\n        std::cout << dfs(map_b, w, h, 'B', 'W') << \" \" << dfs(map_w, w, h, 'W', 'B') << std::endl;\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\n#define stlice(from, to) substr(from, (to) - (from) + 1)\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\nusing namespace std;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\nusing vd = vector<double>;\nusing vc = vector<char>;\nusing vb = vector<bool>;\nusing vs = vector<string>;\nusing vpii = vector<pii>;\nusing vvi = vector<vi>;\nusing vvb = vector<vb>;\nusing vvpii = vector<vpii>;\ntemplate<typename A> using fn = function<A>;\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = acos(-1);\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nconstexpr bool odd(const int &n) { return n & 1; }\nconstexpr bool even(const int &n) { return !odd(n); }\nvoid solve();\nmain { solve(); return 0; }\n// clang-format on\n\nvoid solve() {\n  int W, H;\n  while (cin >> W >> H, W) {\n    vs v(H);\n    rep(i, H) cin >> v[i];\n    vvi dp(H, vi(W));\n    int b = 0, w = 0;\n    rep(i, H) rep(j, W) {\n      dp[i][j] = 2 * (v[i][j] == 'B') + (v[i][j] == 'W');\n      b -= v[i][j] == 'B';\n      w -= v[i][j] == 'W';\n    }\n    rep(_, W + H) rep(i, H) rep(j, W) {\n      if (v[i][j] != '.') continue;\n      if (i > 0) dp[i][j] |= dp[i - 1][j];\n      if (j > 0) dp[i][j] |= dp[i][j - 1];\n      if (i < H - 1) dp[i][j] |= dp[i + 1][j];\n      if (j < W - 1) dp[i][j] |= dp[i][j + 1];\n    }\n    rep(i, H) rep(j, W) {\n      b += dp[i][j] == 2;\n      w += dp[i][j] == 1;\n    }\n    cout << b << ' ' << w << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <limits.h>\n#include <math.h>\n#include <set>\n#include <stack>\n#include <stdlib.h>\n#include <string>\n#include <vector>\n\n#define el endl\n#define fd fixed\n#define INF INT_MAX/2-1\n#define pb push_back\n\nusing namespace std;\n\nchar map[50][50];\nbool memoB[50][50];\nbool memoW[50][50];\n\nvoid search(int x, int y, int w, int h, char color) {\n  if (color == 'B') {\n    memoB[x][y] = true;\n  } else if (color == 'W') {\n    memoW[x][y] = true;\n  } else {\n    if (memoB[x][y] && !memoW[x][y]) {\n      color = 'B';\n    } else if(!memoB[x][y] && memoW[x][y]) {\n      color = 'W';\n    }\n  }\n  if (x > 0 && map[x-1][y] == '.') {\n    if ((color == 'B' && !memoB[x-1][y]) || (color == 'W' && !memoW[x-1][y])) {\n      search(x-1, y, w, h, color);\n    }\n  }\n  if (y > 0 && map[x][y-1] == '.') {\n    if ((color == 'B' && !memoB[x][y-1]) || (color == 'W' && !memoW[x][y-1])) {\n      search(x, y-1, w, h, color);\n    }\n  }\n  if (x < w-1 && map[x+1][y] == '.') {\n    if ((color == 'B' && !memoB[x+1][y]) || (color == 'W' && !memoW[x+1][y])) {\n      search(x+1, y, w, h, color);\n    }\n  }\n  if (y < h-1 && map[x][y+1] == '.') {\n    if ((color == 'B' && !memoB[x][y+1]) || (color == 'W' && !memoW[x][y+1])) {\n      search(x, y+1, w, h, color);\n    }\n  }\n}\n\nint main() {\n  int w, h, cntB, cntW, resB, resW;\n  char tmp;\n  while (cin >> w >> h, w | h) {\n    cntB = cntW = 0;\n    for (int i = 0; i < w; i++) {\n      for (int j = 0; j < h; j++) {\n        cin >> tmp;\n        map[i][j] = tmp;\n        if (tmp == '.') memoB[i][j] = false, memoW[i][j] = false;\n        if (tmp == 'B') memoB[i][j] = true, memoW[i][j] = false, cntB++;\n        if (tmp == 'W') memoB[i][j] = false, memoW[i][j] = true, cntW++;\n      }\n    }\n    for (int i = 0; i < w; i++) {\n      for (int j = 0; j < h; j++) {\n        search(i, j, w, h, map[i][j]);\n      }\n    }\n    resB = resW = 0;\n    for (int i = 0; i < w; i++) {\n      for (int j = 0; j < h; j++) {\n        if (memoB[i][j] && !memoW[i][j]) resB++;\n        if (!memoB[i][j] && memoW[i][j]) resW++;\n      }\n    }\n    cout << resB-cntB << \" \" << resW-cntW << el;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> P;\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nint w, h;\nbool visited[64][64];\nvector<string> maze;\n\nbool check(int x, int y){\n\treturn x >= 0 && x < w && y >= 0 && y < h;\t\n}\n\nint dfs(int x, int y){\n\tif(maze[y][x] == 'B')\n\t\treturn 1;\n\telse if(maze[y][x] == 'W')\n\t\treturn 2;\n\t\n\tint res = 0;\n\tfor(int i = 0; i < 4; ++i){\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\t\tif(!check(nx, ny) || visited[ny][nx])\n\t\t\tcontinue;\n\t\tvisited[ny][nx] = true;\n\t\tres |= dfs(nx, ny);\n\t}\n\treturn res;\n}\nint main() {\n\twhile(cin >> w >> h && (w || h)){\n\t\tstring a;\n\t\tmaze.clear();\n\t\tint cntB = 0, cntW = 0;\n\t\tfor(int i = 0; i < h; ++i){\n\t\t\tcin >> a;\n\t\t\tmaze.push_back(a);\n\t\t}\n\t\tfor(int y = 0; y < h; ++y){\n\t\t\tfor(int x = 0; x < w; ++x){\n\t\t\t\tif(maze[y][x] != '.')\n\t\t\t\t\tcontinue;\n\t\t\t\tmemset(visited, 0, sizeof(visited));\n\t\t\t\tvisited[y][x] = true;\n\t\t\t\tint res = dfs(x, y);\n\t\t\t\tif(res == 1)\n\t\t\t\t\tcntB++;\n\t\t\t\telse if(res == 2)\n\t\t\t\t\tcntW++;\n\t\t\t}\n\t\t}\n\t\tcout << cntB << \" \" << cntW << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\n\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nint H, W;\nchar board[60][60];\nint used[60][60];\n\nsigned main() {\n    while(cin >> W >> H, H || W) {\n        for(int i=0; i<H; i++) {\n            string s; cin >> s;\n            for(int j=0; j<W; j++) {\n                board[i][j] = s[j];\n            }\n        }\n\n        int ansB = 0, ansW = 0;\n        for(int i=0; i<H; i++) {\n            for(int j=0; j<W; j++) {\n                memset(used, 0, sizeof(used));\n                if(board[i][j] != '.') continue;\n\n                bool lookB = false, lookW = false;\n                queue< pair<int, int> > que;\n                que.emplace(i, j);\n\n                while(que.size()) {\n                    int x, y; tie(x, y) = que.front(); que.pop();\n                    for(int k=0; k<4; k++) {\n                        int nx = x + dx[k], ny = y + dy[k];\n                        if(nx < 0 or nx >= H or ny < 0 or ny >= W) continue;\n                        if(used[nx][ny]) continue;\n                        used[nx][ny] = true;\n\n                        if(board[nx][ny] == 'B') lookB = true;\n                        if(board[nx][ny] == 'W') lookW = true;\n                        if(board[nx][ny] == '.') que.emplace(nx, ny);\n                    }\n                }\n\n                if(!lookB and  lookW) ansW++;\n                if( lookB and !lookW) ansB++;\n            }\n        }\n        cout << ansB << \" \" << ansW << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\ntypedef pair<int,int> pii;\n\nint dx[] = {-1,0,1,0};\nint dy[] = {0,1,0,-1};\n\nint main() {\n  int w,h;\n  while(cin >> w>>h,w||h) {\n    char ba[w][h];\n    REP(j,h) {\n      REP(i,w)\n        cin >> ba[i][j];\n    }\n    REP(y,h) {\n      REP(x,w) {\n        if (ba[x][y] == 'W') {\n          queue<pii> Q;\n          Q.push(pii(x,y));\n\n          bool visited[w][h];\n          memset(visited,0,sizeof(visited));\n\n          while(!Q.empty()) {\n            int x1 = Q.front().first;\n            int y1 = Q.front().second;\n            Q.pop();\n            \n///            if (!visited[x1][y1] && (ba[x1][y1] == 'w' || ba[x1][y1] == '*')) break;\n            if (visited[x1][y1]) continue;\n            visited[x1][y1] = 1;\n            \n            if (ba[x1][y1] == 'b')\n              ba[x1][y1] = '*';\n            else if (ba[x1][y1] == '.')\n              ba[x1][y1] = 'w';\n            else if (ba[x1][y1] != 'W')\n              continue;\n            \n            \n            REP(k,4) {\n              int xx = x1+dx[k];\n              int yy = y1+dy[k];\n\n              if (xx<0||xx>=w||yy<0||yy>=h) continue;\n              \n              if (ba[xx][yy] != 'W' && ba[xx][yy] != 'B')\n                Q.push(pii(xx,yy));\n            }\n          }\n        } else if (ba[x][y] == 'B') {\n          queue<pii> Q;\n          Q.push(pii(x,y));\n\n          bool visited[w][h];\n          memset(visited,0,sizeof(visited));\n          while(!Q.empty()) {\n            int x1 = Q.front().first;\n            int y1 = Q.front().second;\n            Q.pop();\n            //         if (!visited[x1][y1] && (ba[x1][y1] == 'b' || ba[x1][y1] == '*')) break;\n            if (visited[x1][y1]) continue;\n            visited[x1][y1] = 1;\n\n\n            if (ba[x1][y1] == 'w')\n              ba[x1][y1] = '*';\n            else if (ba[x1][y1] == '.')\n              ba[x1][y1] = 'b';\n            else if (ba[x1][y1] != 'B')\n              continue;\n            \n            REP(k,4) {\n              int xx = x1+dx[k];\n              int yy = y1+dy[k];\n\n              if (xx<0||xx>=w||yy<0||yy>=h) continue;\n              \n              if (ba[xx][yy] != 'W' && ba[xx][yy] != 'B')\n                Q.push(pii(xx,yy));\n            }\n          }\n        }\n\n      }\n    }\n    int res1 = 0, res2 = 0;\n    REP(y,h) {\n      REP(x,w) {\n        if (ba[x][y] == 'w') res1++;\n        else if (ba[x][y] == 'b') res2++;\n      }\n    }\n    cout << res2 <<\" \" << res1 << endl; \n  }\n}"
  },
  {
    "language": "C++",
    "code": "// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2014\n#include <bits/stdc++.h>\nusing namespace std;\n\nint ans_b, ans_w;\nint w,h;\n\nvoid solve(int start_h, int start_w, vector<vector<char>> &field){\n  queue<pair<int,int>> q;\n  q.push(make_pair(start_h,start_w));\n  vector<vector<char>> tmp = field;\n  int flag = 0; //1 B, 2 W, 3 ?????????????\\\n\n  // bfs\n  while(!q.empty()){\n    int i,j;\n    i = q.front().first;\n    j = q.front().second;\n    q.pop();\n\n    // ???????????????????\n    if(tmp[i][j]=='V'){\n      continue;\n    }\n\n    // ?????????????????????\\??????????????????????????\n    // ????????????????????????\\?????????????????????????????????\n    if((flag==1&&tmp[i][j]=='W')||(flag==2&&tmp[i][j]=='B')){\n      flag=3;\n      break;\n    }else if(flag==0){\n      if(tmp[i][j]=='B')\n        flag=1;\n      else if(tmp[i][j]=='W')\n        flag=2;\n    }\n\n    // ??????????????????????????\n    if(tmp[i][j]=='B'||tmp[i][j]=='W'){\n      tmp[i][j]='V';\n      continue;\n    }\n    tmp[i][j] = 'V'; // V is visited state.\n\n    // ??????????????????queue?????????\n    if(j-1>=0)\n      q.push(make_pair(i,j-1));\n    if(j+1<w)\n      q.push(make_pair(i,j+1));\n    if(i-1>=0)\n      q.push(make_pair(i-1,j));\n    if(i+1<h)\n      q.push(make_pair(i+1,j));\n   // cout<<q.size()<<endl;\n  }\n\n  // ????????????????\\???????????????????????????\n  if(flag==1)\n    ans_b++;\n  else if(flag==2)\n    ans_w++;\n}\n\nint main(){\n  while(true){\n    scanf(\"%d %d\", &w, &h);\n    if(w==0)\n      break;\n    ans_b = 0;\n    ans_w = 0;\n\n    vector<vector<char>> field(h,vector<char>(w));\n    // input field info\n    for(int i=0;i<h;++i)\n      for(int j=0;j<w;++j)\n        cin>>field[i][j];\n\n    // check either adjacent to B or adjacent to W\n    for(int i=0;i<h;++i){\n      for(int j=0;j<w;++j){\n        if(field[i][j]=='.')\n          solve(i,j,field);\n      }\n    }\n\n    printf(\"%d %d\\n\", ans_b, ans_w);\n  }\n  return EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MA_DEFINES\n#include <bits/stdc++.h>\n#define int long long\n#define rep(i,n) for(int i=0;i<n;i++)\n#define Rep(i,a,b) for(int i=a;i<b;i++)\n#define REP(i,a,b) for(int i=a;i<=b;i++)\n#define rev(i,n) for(int i=n-1;i>=0;i--)\n#define vi vector<int>\n#define vvi vector<vi>\n#define pb push_back\n#define pi pair<int,int>\n#define vp vector<pair<int,int>>\n#define mp make_pair\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define MEMSET(a) memset(a,0,sizeof(a))\n#define inf (1ll<<60)\n#define Yes(f) cout<<(f?\"Yes\":\"No\")<<endl\n#define yes(f) cout<<(f?\"yes\":\"no\")<<endl\n#define YES(f) cout<<(f?\"YES\":\"NO\")<<endl\n#define SORT(v) sort(all(v))\n#define RSORT(v) sort(all(v), greater<int>())\n\nusing namespace std;\n\nconst int mod=1e9+7;\n\nvoid run();\n\nvoid init() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout<<fixed<<setprecision(12);\n}\n\nsigned main(){\n    init();\n    run();\n    return 0;\n}\n\nint h,w;\nstring a[51];\nbool v[2][51][51];\nint d[]={1,0,-1,0,1};\n\nvoid dfs(int i,int j,int t){\n    rep(k,4){\n        int ni=i+d[k],nj=j+d[k+1];\n        if(ni<0||ni>=h||nj<0||nj>=w||a[ni][nj]!='.'||v[t][ni][nj])continue;\n        v[t][ni][nj]=true;\n        dfs(ni,nj,t);\n    }\n}\n\nvoid run(){\n    cin>>w>>h;\n    if(!w)return;\n    MEMSET(v);\n    rep(i,h)cin>>a[i];\n    rep(i,h){\n        rep(j,w){\n            if(a[i][j]=='B')dfs(i,j,0);\n            else if(a[i][j]=='W')dfs(i,j,1);\n        }\n    }\n    int ansb=0,answ=0;\n    rep(i,h){\n        rep(j,w){\n            if(v[0][i][j]==v[1][i][j])continue;\n            if(v[0][i][j])ansb++;\n            if(v[1][i][j])answ++;\n        }\n    }\n    cout<<ansb<<\" \"<<answ<<endl;\n    run();\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\nusing namespace std;\n#define inf 1000000000\n#define INF 1000000000000000\n#define ll long long\n#define ull unsigned long long\n#define M (int)(1e9+7)\n#define P pair<int,int>\n#define PLL pair<ll,ll>\n#define FOR(i,m,n) for(int i=(int)m;i<(int)n;i++)\n#define RFOR(i,m,n) for(int i=(int)m;i>=(int)n;i--)\n#define rep(i,n) FOR(i,0,n)\n#define rrep(i,n) RFOR(i,n,0)\n#define all(a) a.begin(),a.end()\n#define IN(a,n) rep(i,n){ cin>>a[i]; }\nconst int vx[4] = {0,1,0,-1};\nconst int vy[4] = {1,0,-1,0};\n#define PI 3.14159265\n#define F first\n#define S second\n#define PB push_back\n#define EB emplace_back\n#define int ll\nvoid init(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\n\n\nvoid f(int w,int h){\n\n  char s[100][100];\n  rep(i,h){\n    cin>>s[i];\n  }\n\n  bool sw[100][100]={},sb[100][100]={};\n\n  queue<P> q;\n  rep(i,h){\n    rep(j,w){\n      if(s[i][j]=='W') q.push(P(i,j));\n    }\n  }\n\n  while(!q.empty()){\n    P p=q.front(); q.pop();\n    rep(k,4){\n      int x=p.S+vx[k];\n      int y=p.F+vy[k];\n      if(!(0<=x&&x<w&&0<=y&&y<h)) continue;\n      if(s[y][x]!='.') continue;\n      if(!sw[y][x]){\n        sw[y][x]=true;\n        q.push(P(y,x));\n      }\n    }\n  }\n\n\n  rep(i,h){\n    rep(j,w){\n      if(s[i][j]=='B') q.push(P(i,j));\n    }\n  }\n\n  while(!q.empty()){\n    P p=q.front(); q.pop();\n    rep(k,4){\n      int x=p.S+vx[k];\n      int y=p.F+vy[k];\n      if(!(0<=x&&x<w&&0<=y&&y<h)) continue;\n      if(s[y][x]!='.') continue;\n      if(!sb[y][x]){\n        sb[y][x]=true;\n        q.push(P(y,x));\n      }\n    }\n  }\n\n\n  int nb=0,nw=0;\n  rep(i,h){\n    rep(j,w){\n      if(s[i][j]!='.') continue;\n      if(!(sb[i][j]^sw[i][j])) continue;\n      if(sb[i][j]) nb++;\n      else nw++;\n    }\n  }\n\n  cout<<nb<<' '<<nw<<endl;\n\n\n}\n\n\n\n      \nmain(){\n  int h,w;\n  while(true){\n    cin>>w>>h;\n    if(w==0) break;\n    f(w,h);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\n\nusing namespace std;\n\nstruct State {\n  int x, y;\n  State(int x, int y): x(x), y(y) {;}\n};\n\nconst int MAX_N = 50;\nconst int dx[] = {0, 1, 0, -1},\n          dy[] = {-1, 0, 1, 0};\n\nint W, H;\nchar field[MAX_N][MAX_N];\nbool visit[MAX_N][MAX_N];\n\nint bfs(int sx, int sy, char color)\n{\n  queue<State> que;\n  que.push(State(sx, sy));\n  bool flag = true;\n  int ret = 0;\n  while (!que.empty()) {\n    State s = que.front(); que.pop();\n    int x = s.x, y = s.y;\n\n    if (x < 0 || x >= W || y < 0 || y >= H || visit[y][x] || field[y][x] == color)\n      continue;\n\n    if (field[y][x] != '.')\n      flag = false;\n\n    visit[y][x] = true;\n    ret++;\n\n    for (int k = 0; k < 4; k++) \n      que.push(State(x + dx[k], y + dy[k]));\n  }\n\n  return flag ? ret : 0;\n}\n\nint solve(char c)\n{\n  memset(visit, false, sizeof(visit));\n  int sol = 0, sc = 0;\n  for (int i = 0; i < H; i++) {\n    for (int j = 0; j < W; j++) {\n      if (!visit[i][j]) {\n        int val = bfs(j, i, c);\n        sol += val;\n        sc++;\n      }\n    }\n  }\n\n  return (sc > 1) ? sol : 0;\n}\n\nint main()\n{\n  while (cin >> W >> H && W && H) {\n    for (int i = 0; i < H; i++) {\n      for (int j = 0; j < W; j++) {\n        cin >> field[i][j];\n      }\n    }\n\n    cout << solve('B') << \" \" << solve('W') << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<cstdio>\n#include<cstring>\n#include<string>\n\n#define REP(i,n) for(int i=0;i<(n);i++)\n\nint di[4] = {1, 0, -1, 0};\nint dj[4] = {0, 1, 0, -1};\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\nconst ll INF = 1e18;\n\nint w, h;\nchar field[50][50];\nbool visited[50][50];\nbool white_flg;\nbool black_flg;\n\nint dfs(int i, int j){\n    if(i<0 || h<=i || j<0 || j>=w || visited[i][j]) return 0;\n    if(field[i][j] == 'B'){\n        black_flg = true;\n        return 0;\n    }\n    if(field[i][j] == 'W'){\n        white_flg = true;\n        return 0;\n    }\n    visited[i][j] = true;\n    int res = 1;\n    REP(k,4){\n        res += dfs(i+di[k], j+dj[k]);\n    }\n    return res;\n}\n\nint main(){\n    while(cin >> w >> h){\n        if(w+h==0) break;\n        int white = 0;\n        int black = 0;\n        memset(visited, false, sizeof(visited));\n        REP(i,h) cin >> field[i];\n\n        REP(i,h){\n            REP(j,w){\n                if(!visited[i][j] && field[i][j] == '.'){\n                    white_flg = false;\n                    black_flg = false;\n                    int s = dfs(i,j);\n                    if(white_flg && !black_flg) white += s;\n                    else if(black_flg && !white_flg) black += s;\n                }\n            }\n        }\n        cout << black << ' ' << white << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define pb push_back \n#define pf push_front \n#define mp make_pair\n#define fr first\n#define sc second\n#define Rep(i,n) for(int i=0;i<(n);i++)\n#define All(v) v.begin(),v.end()\ntypedef pair<int, int> Pii; typedef pair<int, Pii> Pip;\nconst int INF = 1107110711071107;\nint dx[4] = {0, 1, 0, -1}, dy[4] = {1, 0, -1, 0};\n\nint w, h;\nint cnt;\nbool B, W;\nbool used[51][51];\nchar data[51][51];\n\nvoid dfs( int y, int x )\n{\n  if( !used[y][x] ) {\n    used[y][x] = true;\n    cnt++;\n\n    for(int i=0; i<4; i++) {\n      int nx = x + dx[i], ny = y + dy[i];\n      \n      if( nx < 0 || ny < 0 || nx >= w || ny >= h ) continue;\n      if( data[ny][nx] == 'B' ) { B = true; continue; }\n      if( data[ny][nx] == 'W' ) { W = true; continue; }\n\n      dfs( ny, nx );\n    }\n  }\n}\n\nmain()\n{\n  while( cin >> w >> h, !(w == 0 && h == 0) ) {\n    int Bcnt = 0, Wcnt = 0;\n    fill_n( *used, 51*51, false );\n \n    Rep(i, h) Rep(j, w) cin >> data[i][j];\n\n    Rep(i, h) Rep(j, w) {\n      if( used[i][j] || data[i][j] == 'B' || data[i][j] == 'W' ) continue;\n      cnt = 0;\n      B = W = false;\n      dfs( i, j );\n      if( B && !W ) Bcnt += cnt;\n      if( W && !B ) Wcnt += cnt;\n    }\n\n    cout << Bcnt << \" \" << Wcnt << endl;\n  }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nchar ma[55][55];\nint used[55][55];\nint used2[55][55];\nint w,h;\nint dx[4]={0,0,-1,1};\nint dy[4]={1,-1,0,0};\n\nint dfs(int x,int y){\n  if(x<0||y<0||x==h||y==w)return 2;\n  if(ma[x][y]=='B')return 1;\n  if(ma[x][y]=='W')return 0;\n  if(used[x][y])return 2;\n  used[x][y]=1;\n  int sum[4]={};\n  for(int i=0;i<4;i++)\n    sum[dfs(x+dx[i],y+dy[i])]++;\n  if(sum[3])return 3;\n  if(sum[0]&&sum[1])return 3;\n  if(sum[0])return 0;\n  if(sum[1])return 1;\n  return 2;\n}\n\nint dfs2(int x,int y){\n  if(x<0||y<0||x==h||y==w)return 0;\n  if(used2[x][y])return 0;\n  if(ma[x][y]!='.')return 0;\n  used2[x][y]=1;\n  int sum=1;\n  for(int i=0;i<4;i++)sum+=dfs2(x+dx[i],y+dy[i]);\n  return sum;\n}\n\nint main(){\n  while(cin>>w>>h,w+h){\n    memset(used,0,sizeof(used));\n    memset(used2,0,sizeof(used2));\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n\tcin>>ma[i][j];\n    int ans[2]={};\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n\tif(used[i][j]==0&&ma[i][j]=='.'){\n\t  int t=dfs(i,j);\n\t  if(t==0||t==1)ans[t]+=dfs2(i,j);\n\t}\n    cout<<ans[1]<<\" \"<<ans[0]<<endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <queue>\n\nusing namespace std;\n\nint main(void){\n\tint black[50][50], white[50][50], h, w, i, j, k, x, y, bc, wc;\n\tchar field[50][51];\n\tconst int dx[4] = {1,0,-1,0},dy[4] = {0,1,0,-1};\n\tqueue<int> qx,qy;\n\tscanf(\"%d%d%*c\",&w,&h);\n\twhile(w != 0 || h != 0){\n\t\tmemset(black,0,sizeof(black));\n\t\tmemset(white,0,sizeof(white));\n\t\tfor(i = 0;i < h;i++){\n\t\t\tfor(j = 0;j < w;j++)\n\t\t\t\tfield[i][j] = getchar();\n\t\t\tgetchar();\n\t\t}\n\t\tfor(i = 0;i < h;i++){\n\t\t\tfor(j = 0;j < w;j++){\n\t\t\t\tif(field[i][j] == 'B'){\n\t\t\t\t\tqx.push(j);\n\t\t\t\t\tqy.push(i);\n\t\t\t\t\twhile(qx.size()){\n\t\t\t\t\t\tx = qx.front();\n\t\t\t\t\t\ty = qy.front();\n\t\t\t\t\t\tqx.pop();\n\t\t\t\t\t\tqy.pop();\n\t\t\t\t\t\tif(field[y][x] == '.')\n\t\t\t\t\t\t\tblack[y][x] = 1;\n\t\t\t\t\t\tfor(k = 0;k < 4;k++){\n\t\t\t\t\t\t\tif(x + dx[k] >= 0 && x + dx[k] < w && y + dy[k] >= 0 && y + dy[k] < h && field[y + dy[k]][x + dx[k]] == '.' && !black[y + dy[k]][x + dx[k]]){\n\t\t\t\t\t\t\t\tqx.push(x + dx[k]);\n\t\t\t\t\t\t\t\tqy.push(y + dy[k]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(field[i][j] == 'W'){\n\t\t\t\t\tqx.push(j);\n\t\t\t\t\tqy.push(i);\n\t\t\t\t\twhile(qx.size()){\n\t\t\t\t\t\tx = qx.front();\n\t\t\t\t\t\ty = qy.front();\n\t\t\t\t\t\tqx.pop();\n\t\t\t\t\t\tqy.pop();\n\t\t\t\t\t\tif(field[y][x] == '.')\n\t\t\t\t\t\t\twhite[y][x] = 1;\n\t\t\t\t\t\tfor(k = 0;k < 4;k++){\n\t\t\t\t\t\t\tif(x + dx[k] >= 0 && x + dx[k] < w && y + dy[k] >= 0 && y + dy[k] < h && field[y + dy[k]][x + dx[k]] == '.' && !white[y + dy[k]][x + dx[k]]){\n\t\t\t\t\t\t\t\tqx.push(x + dx[k]);\n\t\t\t\t\t\t\t\tqy.push(y + dy[k]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbc = wc = 0;\n\t\tfor(i = 0;i < h;i++)\n\t\t\tfor(j = 0;j < w;j++) if(white[i][j] && !black[i][j]) wc++;\n\t\tfor(i = 0;i < h;i++)\n\t\t\tfor(j = 0;j < w;j++) if(black[i][j] && !white[i][j]) bc++;\n\t\tprintf(\"%d %d\\n\",wc,bc);\n\t\tscanf(\"%d%d\",&w,&h);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nchar s[50][51];\nint w,h,x[]={0,1,0,-1,0};\nint F(int i,int j,char c)\n{\n\tif(i<0||j<0||i>=h||j>=w)return 0;\n\tif(s[i][j]==(c=='W'?'B':'W'))return -99999;\n\tif(s[i][j]!='.')return 0;\n\ts[i][j]='!';\n\treturn 1+F(i+1,j,c)+F(i-1,j,c)+F(i,j+1,c)+F(i,j-1,c);\n}\nint main()\n{\n\tint i,j,k,p,q,r;\n\twhile(scanf(\"%d%d\",&w,&h),w)\n\t{\n\t\tfor(i=0;i<h;++i)scanf(\"%s\",s[i]);\n\t\tfor(p=q=i=0;i<h;++i)for(j=0;j<w;++j)\n\t\t{\n\t\t\tif(s[i][j]=='B')\n\t\t\t\tfor(k=0;k<4;++k)\n\t\t\t\t{\n\t\t\t\t\tr=F(i+x[k],j+x[k+1],'B');\n\t\t\t\t\tif(r>0)p+=r;\n\t\t\t\t}\n\t\t\tif(s[i][j]=='W')\n\t\t\t\tfor(k=0;k<4;++k)\n\t\t\t\t{\n\t\t\t\t\tr=F(i+x[k],j+x[k+1],'W');\n\t\t\t\t\tif(r>0)q+=r;\n\t\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\",p,q);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<string>\nusing namespace std;\nint main(){\n\nint W,H;\nwhile(1){\n\tcin>>W>>H;if(W==0&&H==0)break;\n\tint n[53][53]={};int c=0;\n\tstring str;\n\tfor(int i=1;i<H+1;i++){\n\t\tcin>>str;\n\t\tc++;\n\t\tfor(int j=1;j<W+1;j++)\n\t\t{\n\t\t\tif(str[j-1]=='.'){n[i][j]=c;}\n\t\t\tif(str[j-1]=='W'){n[i][j]=7001;c++;}\n\t\t\tif(str[j-1]=='B'){n[i][j]=7002;c++;}\n\t\t}\n\t}\n\n\t\n\n\tfor(int i=1;i<=H;i++)\n\t\tfor(int j=1;j<=W;j++)\n\t\t{if(n[i][j]<7000){int g[]={n[i-1][j],n[i+1][j],n[i][j-1],n[i][j+1]};\n\tint Q=n[i][j];\n\tif(n[i-1][j]>0&&n[i-1][j]<Q)Q=n[i-1][j];\n\tif(n[i+1][j]>0&&n[i+1][j]<Q)Q=n[i+1][j];\n\tif(n[i][j-1]>0&&n[i][j-1]<Q)Q=n[i][j-1];\n\tif(n[i][j+1]>0&&n[i][j+1]<Q)Q=n[i][j+1];\n\tfor(int I=1;I<=H;I++)\n\t\tfor(int J=1;J<=W;J++)\n\t\t\tfor(int K=0;K<=4;K++)\n\t\t\t\tif(n[I][J]==g[K]&&g[K]<7000)n[I][J]=Q;}\n\t}\n\n\n\tint map[7000]={};\n\tfor(int i=1;i<=H;i++)\n\t\tfor(int j=1;j<=W;j++)\n\t\t\t{if(n[i][j]==7001){\n\t\t\t\tint G[]={n[i-1][j],n[i+1][j],n[i][j-1],n[i][j+1]};\n\t\t\t\tfor(int k=0;k<4;k++)\n\t\t\t\t\tif(map[G[k]]==0||map[G[k]]==2)map[G[k]]+=1;\n\t\t\t\t}\n\n\t\t\tif(n[i][j]==7002){\n\t\t\t\tint G[]={n[i-1][j],n[i+1][j],n[i][j-1],n[i][j+1]};\n\t\t\t\tfor(int k=0;k<4;k++)\n\t\t\t\t\tif(map[G[k]]==0||map[G[k]]==1)map[G[k]]+=2;\n\t\t\t}}\n\t\tint cnt[5540]={};\n\t\tfor(int i=1;i<=H;i++)\n\t\tfor(int j=1;j<=W;j++)\n\t\t\tcnt[n[i][j]]++;\n\n\t\t\tint J=0,JJ=0;\n\t\tfor(int i=1;i<5500;i++)\n\t\t{if(map[i]==1)JJ+=cnt[i];else if(map[i]==2)J+=cnt[i];}\n\t\t\n\t\t\n\n\t\tcout<<J<<\" \"<<JJ<<endl;\n}\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<string>\nusing namespace std;\nint main(){\n\nint W,H;\nwhile(1){\n\tcin>>W>>H;if(W==0&&H==0)break;\n\tint n[53][53]={};int c=0;\n\tstring str;\n\tfor(int i=1;i<H+1;i++){\n\t\tcin>>str;\n\t\tc++;\n\t\tfor(int j=1;j<W+1;j++)\n\t\t{\n\t\t\tif(str[j-1]=='.'){n[i][j]=c;}\n\t\t\tif(str[j-1]=='W'){n[i][j]=7001;c++;}\n\t\t\tif(str[j-1]=='B'){n[i][j]=7002;c++;}\n\t\t}\n\t}\n\n\t\n\n\tfor(int i=1;i<=H;i++)\n\t\tfor(int j=1;j<=W;j++)\n\t\t{if(n[i][j]<7000){int g[]={n[i-1][j],n[i+1][j],n[i][j-1],n[i][j+1]};\n\tint Q=n[i][j];\n\tif(n[i-1][j]>0&&n[i-1][j]<Q)Q=n[i-1][j];\n\tif(n[i+1][j]>0&&n[i+1][j]<Q)Q=n[i+1][j];\n\tif(n[i][j-1]>0&&n[i][j-1]<Q)Q=n[i][j-1];\n\tif(n[i][j+1]>0&&n[i][j+1]<Q)Q=n[i][j+1];\n\tfor(int I=1;I<=H;I++)\n\t\tfor(int J=1;J<=W;J++)\n\t\t\tfor(int K=0;K<=4;K++)\n\t\t\t\tif(n[I][J]==g[K]&&g[K]<7000)n[I][J]=Q;}\n\t}\n\n\n\tint map[7000]={};\n\tfor(int i=1;i<=H;i++)\n\t\tfor(int j=1;j<=W;j++)\n\t\t\t{if(n[i][j]==7001){\n\t\t\t\tint G[]={n[i-1][j],n[i+1][j],n[i][j-1],n[i][j+1]};\n\t\t\t\tfor(int k=0;k<4;k++)\n\t\t\t\t\tif(map[G[k]]==0||map[G[k]]==2)map[G[k]]+=1;\n\t\t\t\t}\n\n\t\t\tif(n[i][j]==7002){\n\t\t\t\tint G[]={n[i-1][j],n[i+1][j],n[i][j-1],n[i][j+1]};\n\t\t\t\tfor(int k=0;k<4;k++)\n\t\t\t\t\tif(map[G[k]]==0||map[G[k]]==1)map[G[k]]+=2;\n\t\t\t}}\n\t\tint cnt[5540]={};\n\t\tfor(int i=1;i<=H;i++)\n\t\tfor(int j=1;j<=W;j++)\n\t\t\tcnt[n[i][j]]++;\n\n\t\t\tint J=0,JJ=0;\n\t\tfor(int i=1;i<2700;i++)\n\t\t{if(map[i]==1)JJ+=cnt[i];else if(map[i]==2)J+=cnt[i];}\n\t\t\n\t\t\n\n\t\tcout<<J<<\" \"<<JJ<<endl;\n}\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<time.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nconst int inf=1e8;\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\nint sx,sy;\nint gx,gy;\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\nint co;\nvector<vector<char> >in;\nbool h;\nvoid func(char d,char q,int x,int y){\n\tin[x][y]=q;\n\tco++;\n\trep(i,4){\n\t\tint nx=x+dx[i];\n\t\tint ny=y+dy[i];\n\t\tif(in[nx][ny]=='.'){\n\t\t\tfunc(d,q,nx,ny);\n\t\t}else if(in[nx][ny]==d)h=false;\n\t}\n}\nint main(){\n\tint n,m;\n\twhile(cin>>m>>n,m+n){\n\t\tvector<vector<char> >tmp(n+2,vector<char>(m+2));\n\t\trep(i,n+2)rep(j,m+2){\n\t\t\tif(!i||!j||i==n+1||j==m+1)tmp[i][j]='!';\n\t\t\telse cin>>tmp[i][j];\n\t\t}\n\t\t//cout<<n<<\" \"<<m<<endl;\n\t\tin=tmp;\n\t\tint b=0,w=0;\n\t\trep(i,n+2)rep(j,m+2){\n\t\t\th=true;\n\t\t\tif(in[i][j]=='.'){\n\t\t\t\trep(k,4){\n\t\t\t\t\tint nx=i+dx[k];\n\t\t\t\t\tint ny=j+dy[k];\n\t\t\t\t\tif(in[nx][ny]!='W'&&in[nx][ny]!='B')continue;\n\t\t\t\t\tco=0;\n\t\t\t\t\tif(in[nx][ny]=='W'){\n\t\t\t\t\t\tfunc('B','W',i,j);\n\t\t\t\t\t\tif(h)w+=co;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfunc('W','B',i,j);\n\t\t\t\t\t\tif(h)b+=co;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<b<<\" \"<<w<<endl;\n\t\t//rep(i,n+2){rep(j,m+2)cout<<in[i][j];cout<<endl;}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2014\n\n#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<numeric>\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define dump(a) (cerr << #a << \"=\" << (a) << endl)\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl;\n\nusing namespace std;\n\n#define MAX 10\n\nchar area[MAX][MAX];\nint ans[MAX][MAX];\nint visit[MAX][MAX];\nint W,H;\n\nvoid init()\n{\n\tfill_n((char *)area, sizeof(area) / sizeof(char), '.');\n\tfill_n((int *)ans, sizeof(ans) / sizeof(int), 0);\n\tfill_n((int *)visit, sizeof(visit) / sizeof(int), 0);\n}\n\nvoid clear(){\n\tfill_n((int *)visit, sizeof(visit) / sizeof(int), 0);\n}\n\nvoid dfs(int x, int y, char color)\n{\n\tint mark = (color == 'W') ? 1 : 2;\n\tchar rival  = (color == 'W') ? 'B':'W';\n\n\tint dx[4] = {1,0,-1,0};\n\tint dy[4] = {0,1,0,-1};\n\n\tif(x < 0 || x >= W || y < 0 || y >= H){ return; }\n\tif(area[y][x] == rival){ return; }\n\n\tif(!visit[y][x])\n\t{\n\t\tvisit[y][x] = 1;\n\t\tif(area[y][x] != 'W' && area[y][x] != 'B'){ ans[y][x] |= mark; }\n\n\t\trep(i,4){ dfs(x+dx[i], y+dy[i], color); }\n\t}\n\n\treturn;\n}\n\nint main()\n{\n\n\twhile(cin >> W >> H && W)\n\t{\n\t\tint black=0, white=0;\n\t\tinit();\n\n\t\trep(h,H){\n\t\t\trep(w,W){\n\t\t\t\tcin >> area[h][w];\n\t\t\t}\n\t\t}\n\n\t\trep(h,H){\n\t\t\trep(w,W){\n\t\t\t\tif(area[h][w] != '.'){ \n\t\t\t\t\tclear();\n\t\t\t\t\tdfs(w,h,area[h][w]); \n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\trep(h,H){\n\t\t\trep(w,W)\n\t\t\t{\n\t\t\t\tint num = ans[h][w];\n\t\t\t\tif(num == 1){ white++; }\n\t\t\t\tif(num == 2){ black++; }\n\t\t\t}\n\t\t}\n\n\t\tcout << black << \" \" << white << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef pair<int, int> P;\n\nint main(void) {\n  int w, h;\n  while (cin >> w >> h, w) {\n    vector<string> a(h);\n    for (int i = 0; i < h; i++) {\n      cin >> a[i];\n    }\n\n    bool white[51][51] = {}, black[51][51] = {};\n    int di[] = {0, -1, 0, 1}, dj[] = {1, 0, -1, 0};\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        if (a[i][j] == 'W') {\n          queue<P> que;\n          que.push(P(i, j));\n\n          while (!que.empty()) {\n            P p = que.front(); que.pop();\n            int ci = p.first, cj = p.second;\n            for (int k = 0; k < 4; k++) {\n              int ni = ci + di[k], nj = cj + dj[k];\n              if (ni >= 0 && ni < h && nj >= 0 && nj < w && a[ni][nj] != 'B' && white[ni][nj] == false) {\n                que.push(P(ni, nj));\n                white[ni][nj] = true;\n              }\n            }\n          }\n        } else if (a[i][j] == 'B') {\n          queue<P> que;\n          que.push(P(i, j));\n          while (!que.empty()) {\n            P p = que.front(); que.pop();\n            int ci = p.first, cj = p.second;\n            for (int k = 0; k < 4; k++) {\n              int ni = ci + di[k], nj = cj + dj[k];\n              if (ni >= 0 && ni < h && nj >= 0 && nj < w && a[ni][nj] != 'W' && black[ni][nj] == false) {\n                que.push(P(ni, nj));\n                black[ni][nj] = true;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    int ans_w = 0, ans_b = 0;\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        if (black[i][j] && white[i][j]) continue;\n        if (a[i][j] == '.' && black[i][j]) ans_b++;\n        if (a[i][j] == '.' && white[i][j]) ans_w++;\n      }\n    }\n\n    cout << ans_b << \" \" << ans_w << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define SZ(x) (int)(x.size())\n#define REP(i, n) for(int i=0;i<(n);++i)\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RREP(i, n) for(int i=(int)(n)-1;i>=0;--i)\n#define RFOR(i, a, b) for(int i=(int)(b)-1;i>=(a);--i)\n#define ALL(a) a.begin(),a.end()\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define DEBUG(x) cerr<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<< endl;\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing P = pair<int, int>;\nconst double eps = 1e-8;\nconst ll MOD = 1000000007;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\ntemplate <typename T1, typename T2>\nbool chmax(T1 &a, const T2 &b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate <typename T1, typename T2>\nbool chmin(T1 &a, const T2 &b) {\n    if (a > b) { a = b; return true; }\n    return false;\n}\ntemplate<typename T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n    os << \"[\";\n    REP(i, SZ(v)) {\n        if (i) os << \", \";\n        os << v[i];\n    }\n    return os << \"]\";\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const map<T1, T2> &mp) {\n    os << \"{\";\n    int a = 0;\n    for (auto &tp : mp) {\n        if (a) os << \", \"; a = 1;\n        os << tp;\n    }\n    return os << \"}\";\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2> &p) {\n    os << p.first << \":\" << p.second;\n    return os;\n}\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    for (;;) {\n        int W, H; cin >> W >> H;\n        if (W == 0) break;\n        vector<string> a(H);\n        REP(i, H) cin >> a[i];\n\n        const int di[] = {0, 1, 0, -1};\n        const int dj[] = {1, 0, -1, 0};\n\n        function<void(int,int,vvi&,char)> dfs = [&](int i, int j, vvi& used, char invalid) {\n            if (used[i][j]) return;\n            used[i][j] = 1;\n            REP(k, 4) {\n                int ni = i + di[k], nj = j + dj[k];\n                if (ni < 0 or nj < 0 or H <= ni or W <= nj or\n                    a[ni][nj] == invalid) {\n                    continue;\n                }\n                dfs(ni, nj, used, invalid);\n            }\n        };\n\n        vvi black(H, vi(W));\n        REP(i, H) {\n            REP(j, W) {\n                if (a[i][j] == 'B') dfs(i, j, black, 'W');\n            }\n        }\n        vvi white(H, vi(W));\n        REP(i, H) {\n            REP(j, W) {\n                if (a[i][j] == 'W') dfs(i, j, white, 'B');\n            }\n        }\n\n        int b = 0, w = 0;\n        REP(i, H) {\n            REP(j, W) {\n                if (a[i][j] != '.') continue;\n                if (black[i][j] and !white[i][j]) ++b;\n                if (!black[i][j] and white[i][j]) ++w;\n            }\n        }\n        cout << b << \" \" << w << endl;\n   }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;++i)\n#define rep1(i,n) for(int i=1;i<=n;++i)\nusing namespace std;\nint a[52][52];\nint dx[4]={0,0,-1,1};\nint dy[4]={-1,1,0,0};\nint cnt[4];\n/* ??????.->0 ?????????\\B,W,B&W->1,2,3 ???B,W->10,20 ??->30 */\n\nvoid paint(int y,int x,int color){\n    if(a[y][x]>=3 || a[y][x]==color)return;\n    cnt[a[y][x]]--;\n    a[y][x] |= color;\n    cnt[a[y][x]]++;\n    rep(i,4)paint(y+dy[i],x+dx[i],a[y][x]);\n}\n\nint main(void){\n    int h,w;\n    char c;\n    while(cin>>w>>h, w|h){\n        rep(i,4)cnt[i]=0;\n        rep1(y,h){\n            rep1(x,w){\n                cin>>c;\n                if(c=='.')a[y][x] = 0;\n                else a[y][x] = (c=='B' ? 10 : 20);\n            }\n        }\n        rep(y,h+2)a[y][0]=a[y][w+1] = 30;\n        rep(x,w+2)a[0][x]=a[h+1][x] = 30;\n\n        rep1(y,h)rep1(x,w)if(a[y][x]>=10)rep(i,4)paint(y+dy[i],x+dx[i],a[y][x]/10);\n\n        cout<<cnt[1]<<\" \"<<cnt[2]<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define ALL(a) (a).begin(),(a).end()\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define ll long long\n#define ull unsigned long long\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nusing namespace std;\n\nint main(){\n  int H,W;\n  while(true){\n    cin >> W >> H;\n    if(!H)break;\n    vector<vector<char>> mp(H,vector<char>(W));\n    vector<vector<int>> c(H,vector<int>(W,0));\n      REP(i,H)\n      REP(j,W)cin >> mp[i][j];\n      int Bct=0;int Wct =0;\n    REP(i,H){\n      REP(j,W){\n\tif(!c[i][j] && mp[i][j] == '.'){\n\t  queue<pair<int,int>> que;\n\t  que.push(make_pair(i,j));\n\t  int ct = 1;//???????????????\n\t  c[i][j] = 1;\n\t  bool isBlack = false;\n\t  bool isWhite = false;\n\t  while(que.size()){\n\t    int x = que.front().first;\n\t    int y = que.front().second;\n\t    que.pop();\n\t    REP(k,4){\n\t      int nx = x + dx[k];\n\t      int ny = y + dy[k];\n\t      if(nx<H&&nx>=0&&ny<W&&ny>=0){\n\t\tif(mp[nx][ny] == 'B')isBlack = true;\n\t\telse if(mp[nx][ny] == 'W')isWhite = true;\n\t\telse if(c[nx][ny] == 0){\n\t\t  ct++;\n\t\t  que.push(make_pair(nx,ny));\n\t\t}\n\t\tc[nx][ny] = 1;\n\t      }\n\t    }\n\t  }\n\t  if(isBlack&&!isWhite)Bct += ct;\n\t  else if(isWhite&&!isBlack)Wct += ct;\n\t}\n      }\n    }\n    cout << Bct << \" \" << Wct << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n#define INF 1000000000\n#define rep(i,a,b) for (int i=(a);i<(b);i++)\n#define rev(i,a,b) for (int i=(a)-1;i>=b;i--)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef queue<int> qi;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\nint dx[4] = { 0, 1, 0, -1 };\nint dy[4] = { 1, 0, -1, 0 };\n\nint main() {\n\n\twhile(true) {\n\t\tint h, w;\n\t\tcin >> h >> w;\n\t\tif(!(h||w)) break;\n\n\t\tchar m[51][51];\n\t\trep(i,0,h) rep(j,0,w) cin >> m[i][j];\n\n\t\tbool B[50][50], W[50][50];\n\t\trep(i,0,h) rep(j,0,w) B[i][j] = W[i][j] = false;\n\n\t\trep(y,0,h) {\n\t\t\trep(x,0,w) {\n\t\t\t\tif(m[y][x] == '.') continue;\n\n\t\t\t\tbool m2[h][w];\n\t\t\t\trep(i,0,h) rep(j,0,w) m2[i][j] = false;\n\n\t\t\t\tqueue<pii> que;\n\t\t\t\tque.push(pii(y,x));\n\t\t\t\tm2[y][x] = true;\n\t\t\t\twhile(!que.empty()) {\n\t\t\t\t\tpii tmp = que.front();\n\t\t\t\t\tque.pop();\n\t\t\t\t\tint ny = tmp.first;\n\t\t\t\t\tint nx = tmp.second;\n\t\t\t\t\trep(i,0,4) {\n\t\t\t\t\t\tint my = ny + dy[i];\n\t\t\t\t\t\tint mx = nx + dx[i];\n\t\t\t\t\t\tif(0 <= my && my < h && 0 <= mx && mx < w && !m2[my][mx] &&\n\t\t\t\t\t\t\t m[my][mx] == '.') {\n\t\t\t\t\t\t\tque.push(pii(my, mx));\n\t\t\t\t\t\t\tm2[my][mx] = true;\n\t\t\t\t\t\t\tif(m[y][x] == 'B') B[my][mx] = true;\n\t\t\t\t\t\t\telse if(m[y][x] == 'W') W[my][mx] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\tint ans1 = 0, ans2 = 0;\n\t\trep(i,0,h) rep(j,0,w) {\n\t\t\tif(B[i][j] && !W[i][j]) ans1++;\n\t\t\telse if(!B[i][j] && W[i][j]) ans2++;\n\t\t}\n\n\t\tcout << ans1 << \" \" << ans2 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstring>\n#define Black 1\n#define White 2\n#define Double 3\nusing namespace std;\n\nchar map[50][50];\nint access[50][50]={0};\nint w,h;\nint dxy[8][2]={{1,0},{0,1},{-1,0},{0,-1},{1,1},{1,-1},{-1,1},{-1,-1}};\n\nvoid dfs(int y,int x,int type){\n  if(0<=y && y<h && 0<=x && x<w){\n    if(map[y][x]=='.' && (access[y][x]&type)!=type){\n      access[y][x]+=type;\n      for(int k=0;k<8;k++){\n\tdfs(y+dxy[1][k],x+dxy[0][k],type);\n      }\n    }\n  }\n}\n\nint main(){\n  while(cin>>w>>h,w){\n    memset(map,'.',sizeof(map));\n    memset(access,0,sizeof(access));\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tcin>>map[i][j];\n      }\n    }\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tif(map[i][j]=='B'){\n\t  access[i][j]=Double;\n\t  for(int k=0;k<8;k++){\n\t    dfs(i+dxy[1][k],j+dxy[0][k],Black);\n\t  }\n\t}else if(map[i][j]=='W'){\n\t  access[i][j]=Double;\n\t  for(int k=0;k<8;k++){\n\t    dfs(i+dxy[1][k],j+dxy[0][k],White);\n\t  }\n\t}\n      }\n    }\n    int black=0;\n    int white=0;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n\tif(access[i][j]==Black){\n\t  black++;\n\t}else if(access[i][j]==White){\n\t  white++;\n\t}\n      }\n    }\n    cout<<black<<\" \"<<white<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n\nusing namespace std;\n\nconst int MAX_H = 50;\n\nconst int dx[] = { 0, 0, -1, 1 };\nconst int dy[] = { -1, 1, 0, 0 };\n\nconst char mozi[] = \"BW\";\n\nint w, h;\nint flg;\nint cnt;\n\nvoid search( int x, int y, string map[], char c, char nc );\n\nint main()\n{\t\n\tstring map[2][MAX_H];\t/// Black = 0 , White = 1\n\twhile( cin >> w >> h, w | h )\n\t{\n\t\tint cnt_BW[2] = { 0 };\n\n\t\tfor( int i=0; i < h; i++ ) { cin >> map[0][i]; map[1][i] = map[0][i]; }\n\n\t\tfor( int idx=0; idx < 2; idx++ ) for( int i=0; i < h; i++ ) for( int j=0; j < w; j++ )\n\t\t{\n\t\t\tif( map[idx][i][j] != '.' ) continue;\n\t\t\tint BW[2] = { 0 };\n\t\t\tfor( int k=0; k < 4; k++ )\n\t\t\t{\n\t\t\t\tint mx = j + dx[k];\n\t\t\t\tint my = i + dy[k];\n\t\t\t\tif( 0 <= mx && mx < w && 0 <= my && my < h )\n\t\t\t\t{\n\t\t\t\t\tif( map[idx][my][mx] == mozi[idx] ) BW[idx]++;\n\t\t\t\t\telse if( map[idx][my][mx] == mozi[(idx+1)%2] ) BW[(idx+1)%2]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcnt = 0; flg = true;\n\t\t\tif( BW[idx] && !BW[(idx+1)%2] ) search( j, i, map[idx], mozi[idx], mozi[(idx+1)%2] );\n\t\t\tif( flg ) cnt_BW[idx] += cnt;\n\t\t}\n\t\tcout << cnt_BW[0] << \" \" << cnt_BW[1] << endl;\n\t}\n\treturn 0;\n}\n\nvoid search( int x, int y, string map[], char c, char nc )\n{\n\tif( map[y][x] == '.' )\n\t{\n\t\tcnt++;\n\t\tmap[y][x] = c;\n\t}\n\tfor( int i=0; i < 4; i++ )\n\t{\n\t\tint mx = x + dx[i];\n\t\tint my = y + dy[i];\n\t\tif( 0 <= mx && mx < w && 0 <= my && my < h )\n\t\t{\n\t\t\tif( map[my][mx] == '.' )\n\t\t\t{\n\t\t\t\tsearch( mx, my, map, c, nc );\n\t\t\t}\n\t\t\telse if( map[my][mx] == nc )\n\t\t\t{\n\t\t\t\tflg = false;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define f(i,x,n) for(int i=x;i<(int)(n);++i)\n#define all(x) (x).begin(),(x).end()\nconst int mod=1000000007,MAX=3005,INF=1<<29;\nvector<string> S(50);\nint color[MAX][2];\nint H,W;\nvector<int> dx={-1,0,1,0},dy={0,1,0,-1};\nvoid DFS(int u,int k){\n    if(color[u][k]) return;\n    color[u][k]=1;\n    \n    for(int i=0;i<4;i++){\n        int a=u/W,b=u%W;\n        \n        if(0<=a+dx[i]&&a+dx[i]<H&&0<=b+dy[i]&&b+dy[i]<W){\n            if(S[a+dx[i]][b+dy[i]]=='.') DFS((a+dx[i])*W+b+dy[i],k);\n        }\n    }\n}\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    while(1){\n        cin>>W>>H;\n        if(H+W==0) break;\n        memset(color,0,sizeof(color));\n        \n        for(int i=0;i<H;i++) cin>>S[i];\n        \n        for(int i=0;i<H;i++){\n            for(int j=0;j<W;j++){\n                if(S[i][j]=='B') DFS(i*W+j,0);\n                if(S[i][j]=='W') DFS(i*W+j,1);\n            }\n        }\n        \n        int ans1=0,ans2=0;\n        \n        for(int i=0;i<H;i++){\n            for(int j=0;j<W;j++){\n                if(color[i*W+j][0]&&color[i*W+j][1]==0&&S[i][j]!='B') ans1++;\n                if(color[i*W+j][1]&&color[i*W+j][0]==0&&S[i][j]!='W') ans2++;\n            }\n        }\n        \n        cout<<ans1<<\" \"<<ans2<<endl;\n    }\n    \n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) begin(r),end(r)\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init))\n#define mp(a,b) make_pair(a,b)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\n\ntemplate<typename T>\nvoid O(T t){\n  cout << t << endl;\n}\n\nconst ll mod = 1e9+7;\nconstexpr ll inf = ((1<<30)-1)*2+1 ;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\nconst int dy[] = {-1,0,1,0,1,-1,1,-1};\nconst int dx[] = {0,-1,0,1,1,-1,-1,1};\n\ninline bool value(int x,int y,int w,int h){\n  return (x >= 0 && x < w && y >= 0 && y < h);\n}\n\nll W,h;\nvoid fill(vector<vector<char>> &m,int b){\n  char c,C;\n  if(b == 0){\n    c = 'b';\n    C = 'B';\n  }\n  else{\n    c = 'w';\n    C = 'W';\n  }\n  rep(x,W){\n    rep(y,h){\n      if(m[x][y] == '.'){\n        rep(i,4){\n          int nx = dx[i] + x,ny = dy[i] + y;\n          if(value(nx,ny,W,h) && (m[nx][ny] == C)){\n            m[x][y] = c;\n          }\n        }\n      }\n    }\n  }\n}\nvoid solve(vector<vector<char>> &m,int x,int y,int b){\n  char c,C;\n  if(b == 0){\n    c = 'b';\n    C = 'B';\n  }\n  else{\n    c = 'w';\n    C = 'W';\n  }\n  if(m[x][y] == c){\n    rep(i,4){\n      int nx = dx[i] + x,ny = dy[i] + y;\n      if(value(nx,ny,W,h) && (m[nx][ny] == '.')){\n        m[nx][ny] = c;\n        solve(m,nx,ny,b);\n      }\n    }\n  }\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  while(cin >> W >> h,W+h){\n    vector<vector<char>> w(51,vector<char>(51)),b;\n    rep(i,W){\n      rep(j,h){\n        cin >> w[i][j];\n      }\n    }\n    b = w;\n    fill(w,1);\n    fill(b,0);\n    rep(i,W){\n      rep(j,h){\n        solve(w,i,j,1);\n        solve(b,i,j,0);\n      }\n    }\n    /* rep(i,W){               */\n    /* rep(j,h){               */\n    /* cout << w[i][j] ;       */\n    /* }                       */\n    /* std::cout << std::endl; */\n    /* }                       */\n    ll bc = 0,wc = 0;\n    rep(i,W){\n      rep(j,h){\n        if(w[i][j] == 'w' && b[i][j] != 'b'){\n          int c = 1;\n          /* rep(k,4){                                   */\n          /*   int nx = dx[k] + i,ny = dy[k] + j;        */\n          /*   if(value(nx,ny,W,h) && w[nx][ny] == 'B'){ */\n          /*     c = 0;                                  */\n          /*   }                                         */\n          /* }                                           */\n          /* if(c) w[i][j] = '0';                        */\n          wc += c;\n        }\n      }\n    }\n    rep(i,W){\n      rep(j,h){\n        if(b[i][j] == 'b' && w[i][j] != 'w'){\n          int c = 1;\n          /* rep(k,4){                                     */\n          /*   int nx = dx[k] + i,ny = dy[k] + j;          */\n          /*   if(value(nx,ny,W,h) && (b[nx][ny] == 'W')){ */\n          /*     c = 0;                                    */\n          /*   }                                           */\n          /* }                                             */\n          bc += c;\n        }\n      }\n    }\n    /* rep(i,W){               */\n    /* rep(j,h){               */\n    /* cout << w[i][j] ;       */\n    /* }                       */\n    /* std::cout << std::endl; */\n    /* }                       */\n    cout << bc << ' ' << wc << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) begin(r),end(r)\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init))\n#define mp(a,b) make_pair(a,b)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\n\ntemplate<typename T>\nvoid O(T t){\n  cout << t << endl;\n}\n\nconst ll mod = 1e9+7;\nconstexpr ll inf = ((1<<30)-1)*2+1 ;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\nconst int dy[] = {-1,0,1,0,1,-1,1,-1};\nconst int dx[] = {0,-1,0,1,1,-1,-1,1};\n\ninline bool value(int x,int y,int w,int h){\n  return (x >= 0 && x < w && y >= 0 && y < h);\n}\n\nll W,h;\nvoid solve(vector<vector<char>> &m,int x,int y,int b){\n  char c,C;\n  if(b == 0){\n    c = 'b';\n    C = 'B';\n  }\n  else{\n    c = 'w';\n    C = 'W';\n  }\n  if(m[x][y] == '.'){\n    rep(i,4){\n      int nx = dx[i] + x,ny = dy[i] + y;\n      if(value(nx,ny,W,h) && (m[nx][ny] == C || m[nx][ny] == c)){\n        m[x][y] = c;\n        solve(m,nx,ny,b);\n      }\n    }\n  }\n  if(m[x][y] == c){\n    rep(i,4){\n      int nx = dx[i] + x,ny = dy[i] + y;\n      if(value(nx,ny,W,h) && (m[nx][ny] == '.')){\n        solve(m,nx,ny,b);\n      }\n    }\n  }\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  while(cin >> W >> h,W+h){\n    vector<vector<char>> w(W,vector<char>(h)),b;\n    rep(i,W){\n      rep(j,h){\n        cin >> w[i][j];\n      }\n    }\n    b = w;\n    rep(i,W){\n      rep(j,h){\n        solve(w,i,j,1);\n        solve(b,i,j,0);\n      }\n    }\n    /* rep(i,W){                 */\n    /*   rep(j,h){               */\n    /*     cout << b[i][j] ;     */\n    /*   }                       */\n    /*   std::cout << std::endl; */\n    /* }                         */\n    ll bc = 0,wc = 0;\n    rep(i,W){\n      rep(j,h){\n        if(w[i][j] == 'w' && b[i][j] == '.'){\n          int c = 1;\n          wc += c;\n        }\n      }\n    }\n    rep(i,W){\n      rep(j,h){\n        if(b[i][j] == 'b' && w[i][j] == '.'){\n          int c = 1;\n          bc += c;\n        }\n      }\n    }\n    cout << bc << ' ' << wc << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <cmath>\n#include <algorithm>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <vector>\n#include <string>\n#define REP(i,n) for(int i=0;i<n;i++)\ntypedef long long ll;\nusing namespace std;\ntypedef vector<ll> vl;\ntypedef pair<ll,ll> pll;\ntypedef vector<pll> vpll;\ntypedef vector<string> vs;\n\nint X[4]={0,0,-1,1};\nint Y[4]={-1,1,0,0};\nint w,h;\nint ans[50][50];\nint bl[50][50];\nint wh[50][50];\n\nvoid black(int x,int y){\n\tbl[x][y]=1;\n\tfor(int i=0;i<4;i++){\n\t\tif(x+X[i]>-1&&x+X[i]<w&&y+Y[i]>-1&&y+Y[i]<h){\n\t\t\tif(ans[x+X[i]][y+Y[i]]==0&&bl[x+X[i]][y+Y[i]]==0){black(x+X[i],y+Y[i]);}\n\t\t}\n\t}\n}\n\nint a(0);\n\nvoid white(int x,int y){\n\twh[x][y]=1;\n\tfor(int i=0;i<4;i++){\n\t\tif(x+X[i]>-1&&x+X[i]<w&&y+Y[i]>-1&&y+Y[i]<h){\n\t\t\tif(ans[x+X[i]][y+Y[i]]==0&&wh[x+X[i]][y+Y[i]]==0){white(x+X[i],y+Y[i]);}\n\t\t}\n\t}\n}\n\n\nint main() \n{\n\twhile(cin>>w>>h&&!(w==0&&h==0)){\n\t\tREP(i,51){REP(j,51){ans[j][i]=0;bl[j][i]=0;wh[j][i]=0;}}\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tchar tmp;\n\t\t\t\tcin>>tmp;\n\t\t\t\tswitch(tmp){\n\t\t\t\t  case 'B':ans[j][i]=1;break;\n\t\t\t\t  case 'W':ans[j][i]=2;break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tint tmp1(false),tmp2(false);\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tif(j+X[k]>-1&&j+X[k]<w&&i+Y[k]>-1&&i+Y[k]<h){\n\t\t\t\t\t\tif(ans[j+X[k]][i+Y[k]]==1){tmp1=true;}\n\t\t\t\t\t\tif(ans[j+X[k]][i+Y[k]]==2){tmp2=true;}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(tmp1&&bl[j][i]!=1&&ans[j][i]==0){black(j,i);}\n\t\t\t\tif(tmp2&&wh[j][i]!=1&&ans[j][i]==0){white(j,i);}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans1(0),ans2(0);\n\t\tREP(i,h){REP(j,w){\n\t\t\t\tif(bl[j][i]+wh[j][i]==2){;}\n\t\t\t\telse if(wh[j][i]==1){ans2++;}\n\t\t\t\telse if(bl[j][i]==1){ans1++;}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout<<ans1<<\" \"<<ans2<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define ALL(a) (a).begin(),(a).end()\nconst int INF = INT_MAX/3;\nconst double EPS = 1e-14;\n\ntemplate<typename U, typename T>\nvoid chmin(U &x, T y) { x = min(x, y); }\n\ntemplate<typename U, typename T>\nvoid chmax(U &x, T y) { x = max(x, y); }\n\ntypedef long long int lli;\ntypedef long double ld;\n\nint W, H;\nconst int HMAX = 58, WMAX = 58;\nchar field[HMAX][WMAX];\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\nbool outof_range(int h, int w) {\n  return h < 0 || W <= h || w < 0 || W <= w;\n}\n\nvoid dfs(int h, int w, char c, char target) {\n  if (outof_range(h, w) or field[h][w] != target) {\n    return;\n  }\n  field[h][w] = c;\n  REP(dir, 4) {\n    dfs(h + dy[dir], w + dx[dir], c, target);\n  }\n}\n\nint main() {\n  cout << fixed << setprecision(10);\n  while (cin >> W >> H and W) {\n    REP(y, H) {\n      string row; cin >> row;\n      REP(x, W) {\n        field[y][x] = row[x];\n      }\n    }\n    REP(y, H) REP(x, W) {\n      if (field[y][x] == 'W') {\n        REP(i, 4) {\n          dfs(y + dy[i], x + dx[i], 'w', '.');\n        }\n      }\n      if (field[y][x] == 'B') {\n        REP(i, 4) {\n          dfs(y + dy[i], x + dx[i], 'b', '.');\n        }\n      }\n    }\n    REP(y, H) REP(x, W) {\n      if (field[y][x] == 'W') {\n        REP(i, 4) {\n          dfs(y + dy[i], x + dx[i], 'x', 'b');\n        }\n      }\n      if (field[y][x] == 'B') {\n        REP(i, 4) {\n          dfs(y + dy[i], x + dx[i], 'x', 'w');\n        }\n      }\n    }\n    int white = 0, black = 0;\n    REP(y, H) REP(x, W) {\n      char c = field[y][x];\n      if (c == 'w') { white++; }\n      if (c == 'b') { black++; }\n    }\n    cout << black << \" \" << white << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<string.h>\nusing namespace std;\n\nint h,w;\n\nbool is_next[2][50][50];\nvector<string> M;\n\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n\nvoid dfs(int x,int y,int is_black){\n\tif(x<0 || y<0 || x>=w || y>=h) return;\n\tif(M[y][x]!='.') return;\n\tif(is_next[is_black][y][x]) return;\n\tis_next[is_black][y][x]=true;\n\n\tfor(int r=0;r<4;r++)\n\t\tdfs(x+dx[r],y+dy[r],is_black);\n}\n\nint main()\n{\n\twhile(cin>>w>>h && w!=0){\n\t\tM.clear();\n\t\tmemset(is_next,false,sizeof(is_next));\n\t\tfor(int i=0;i<h;i++){\n\t\t\tstring s; cin>>s; M.push_back(s);\n\t\t}\n\n\t\tfor(int y=0;y<h;y++){\n\t\t\tfor(int x=0;x<w;x++){\n\t\t\t\tif(M[y][x]=='W'){\n\t\t\t\t\tfor(int r=0;r<4;r++){\n\t\t\t\t\t\tdfs(x+dx[r],y+dy[r],1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(M[y][x]=='B'){\n\t\t\t\t\tfor(int r=0;r<4;r++){\n\t\t\t\t\t\tdfs(x+dx[r],y+dy[r],0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans_b=0,ans_w=0;\n\t\tfor(int y=0;y<h;y++){\n\t\t\tfor(int x=0;x<w;x++){\n\t\t\t\tif(is_next[0][y][x] && !is_next[1][y][x]) ans_b++;\n\t\t\t\tif(is_next[1][y][x] && !is_next[0][y][x]) ans_w++;\n\t\t\t}\n\t\t}\n\t\tcout<<ans_b<<\" \"<<ans_w<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint dx[]={1,0,-1,0},dy[]={0,1,0,-1};\nint w,h,bum,wum,sum,B,W;\nchar s[60][60];\nvoid func1(int y,int x){\n\tint p=y,q=x;\n\tif(s[y][x]=='B'){\n\t\tB++;\n\t}\n\telse if(s[y][x]=='W'){\n\t\tW++;\n\t}\n\telse if(s[y][x]!='*'){\n\t\ts[y][x]='*';\n\t\tsum++;\n\t\tfor(int l=0;l<4;l++){\n\t\t\ty=p+dy[l];\n\t\t\tx=q+dx[l];\n\t\t\tif(y>=0&&y<h&&x>=0&&x<w){\n\t\t\t\tfunc1(y,x);\n\t\t\t}\n\t\t}\n\t}\n}\nvoid func2(int y,int x,char c){\n\tint p,q;\n\tif(s[y][x]=='*'){\n\t\ts[y][x]=c;\n\t\tfor(int o=0;o<4;o++){\n\t\t\tp=y+dy[o];\n\t\t\tq=x+dx[o];\n\t\t\tif(p>=0&&p<h&&q>=0&&q<w)\n\t\t\t\tfunc2(p,q,c);\n\t\t}\n\t}\n}\nint main(){\n\twhile(cin>>w>>h,w||h){\n\t\twum=0;\n\t\tbum=0;\n\t\tfor(int i=0;i<h;i++)\n\t\tscanf(\"%s\",s[i]);\n\t\tfor(int i=0;i<h;i++)\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(s[i][j]=='.'){\n\t\t\t\tB=0;\n\t\t\t\tW=0;\n\t\t\t\tsum=0;\n\t\t\t\tfunc1(i,j);\n\t\t\t\tif(B>0&&W==0){\n\t\t\t\t\tbum+=sum;\n\t\t\t\t\tfunc2(i,j,'s');\n\t\t\t\t}\n\t\t\t\telse if(B==0&&W>0){\n\t\t\t\t\twum+=sum;\n\t\t\t\t\tfunc2(i,j,'t');\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tfunc2(i,j,'D');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout<<bum<<' '<<wum<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <iomanip>\n#include <complex>\nusing namespace std;\n\n#define ll long long\n#define vvi vector< vector<int> >\n#define vi vector<int>\n#define All(X) X.begin(),X.end()\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define pb push_back\n#define pii pair<int,int>\n#define mp make_pair\n#define pi 3.14159265359\n#define shosu(X) fixed << setprecision(X)\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){return a/gcd(a,b)*b;}\n\nint h,w;\nchar grid[51][51];\nint reach[51][51];\nbool issearched[51][51];\nint dx[4] = {-1,0,1,0};\nint dy[4] = {0,-1,0,1};\n\nint dfs(int px, int py){\n\t// cout << \"(px,py) = \" << \"(\" << px << \",\" << py << \") = \" << grid[px][py] << \"?????\" << endl;\n\tif(grid[px][py] == 'B') {\n\t\t// cout << \"unko\" << endl; \n\t\treturn 2;  //10\n\t\n\t}\n\tif(grid[px][py] == 'W') return 1;  //01\n\tint res = 0;\n\tREP(i,4){\n\t\tint nx = px + dx[i]; \n\t\tint ny = py + dy[i];\n\t\tif(nx < 0 || ny < 0 || nx > h-1 || ny > w-1) continue;\n\t\tif(issearched[nx][ny]) continue;\n\t\tissearched[nx][ny] = true;\n\t\t// cout << \"??????????????\" << \"(\" << nx << \",\" << ny << \")?????\" << endl;\n\t\tres |= dfs(nx,ny);\t\n\t}\n\treturn res;\n}\nint main(){\n\twhile(1){\n\t\tcin >> w >> h;\n\t\tif(w == 0 && h == 0) break;\n\t\tREP(i,h) REP(j,w) cin >> grid[i][j];\n\t\tREP(i,h) REP(j,w) reach[i][j] = 0;\n\t\tREP(i,h) REP(j,w) {\n\t\t\tREP(k,h) REP(l,w) issearched[k][l] = false;\n\t\t\t// cout << i << \" \" << j << \"??????????????????????????\" << endl;\n\t\t\tissearched[i][j] = true;\n\t\t\tif(grid[i][j]=='.') reach[i][j] = dfs(i,j);\n\t\t}\n\t\tint white = 0; int black = 0;\n\t\tREP(i,h) REP(j,w){\n\t\t\tif(reach[i][j] == 1) white++;\n\t\t\telse if(reach[i][j] == 2) black++;\n\t\t}\n\t\tcout << black << \" \" << white << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nint w,h,d[5]={1,0,-1,0,1},i,j,M,Y,X,T;std::string s[50];int r(int y,int x){T=s[y][x];if(T-41&&T-20)s[y][x]|=M;for(int i=0;i<5;){Y=y+d[i];X=x+d[++i];if(Y<0||h<=Y||X<0||w<=X||s[Y][X]==41||s[Y][X]==20||(s[Y][X]&M)==M)continue;r(Y,X);}}main(){for(;std::cin>>w>>h,w|h;printf(\"%d %d\\n\",X,Y)){for(M=i=0;i<h;i++)for(std::cin>>s[i],j=w;j-->0;)s[i][j]-=46;for(i=h;i-->0;)for(j=w;j-->0;M=2*(X==41)+(X==20),M&&r(i,j))X=s[i][j];for(X=Y=i=0;i<h;i++)for(j=w;j-->0;T==1&&X++,T==2&&Y++)T=s[i][j];}}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"vector\"\n#include \"string\"\n#include \"queue\"\n#include \"cstring\"\nusing namespace std;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nbool black[50][50],white[50][50];\nint main(void)\n{\n\tint w,h;\n\twhile (cin>>w>>h,w) {\n\t\tmemset(black,0,sizeof(black));\n\t\tmemset(white,0,sizeof(white));\n\t\tvector<string> in;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tstring t; cin>>t;\n\t\t\tin.push_back(t);\n\t\t}\n\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tint f=0;\n\t\t\t\tif(in[i][j]=='W') f=1;\n\t\t\t\telse if(in[i][j]=='B') f=2;\n\n\t\t\t\tif(in[i][j]!='.')\n\t\t\t\t{\n\t\t\t\t\tbool used[50][50];\n\t\t\t\t\tmemset(used,0,sizeof(used));\n\t\t\t\t\tqueue<int> xs,ys;\n\t\t\t\t\txs.push(j); ys.push(i);\n\t\t\t\t\twhile (!xs.empty()) {\n\t\t\t\t\t\tint x=xs.front(),y=ys.front();\n\t\t\t\t\t\txs.pop(); ys.pop();\n\t\t\t\t\t\tused[y][x]=true;\n\t\t\t\t\t\tif(f==1) white[y][x]=true;\n\t\t\t\t\t\telse black[y][x]=true;\n\t\t\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\t\t\tint nx=x+dx[k],ny=y+dy[k];\n\t\t\t\t\t\t\tif(0<=nx&&nx<w&&0<=ny&&ny<h&&!used[ny][nx]&&in[ny][nx]=='.')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\txs.push(nx); ys.push(ny);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint Black=0,White=0;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif(in[i][j]!='B'&&black[i][j]&&!white[i][j]) Black++;\n\t\t\t\telse if(in[i][j]!='W'&&!black[i][j]&&white[i][j]) White++;\n\t\t\t}\n\t\t}\n\t\tcout<<Black<<\" \"<<White<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <cstring>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\ntypedef long long ll;\n\nvoid init() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n}\n\nchar field[50][50];\nbool checked[2][50][50];\nint w, h;\n\nvoid fill( int x, int y, int t ) {\n\tchecked[t][y][x] = true;\n\tif( 0<=y-1 && !checked[t][y-1][x] && field[y-1][x]=='.' ) {\n\t\tfill( x, y-1, t );\n\t}\n\tif( y+1<h && !checked[t][y+1][x] && field[y+1][x]=='.' ) {\n\t\tfill( x, y+1, t );\n\t}\n\tif( 0<=x-1 && !checked[t][y][x-1] && field[y][x-1]=='.' ) {\n\t\tfill( x-1, y, t );\n\t}\n\tif( x+1<w && !checked[t][y][x+1] && field[y][x+1]=='.' ) {\n\t\tfill( x+1, y, t );\n\t}\n}\n\nint main() {\n    init();\n\twhile( cin >> w >> h, w||h ) {\n\t\tmemset( field, 0, sizeof(field) );\n\t\tmemset( checked, 0, sizeof(checked) );\n\t\trep(y, h) {\n\t\t\trep(x, w) {\n\t\t\t\tcin >> field[y][x];\n\t\t\t}\n\t\t}\n\t\trep(y, h) {\n\t\t\trep(x, w) {\n\t\t\t\tif( field[y][x] == 'W' ) {\n\t\t\t\t\tfill( x, y, 0 );\n\t\t\t\t} else if( field[y][x] == 'B' ) {\n\t\t\t\t\tfill( x, y, 1 );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint cntW=0, cntB=0;\n\t\trep(y, h) {\n\t\t\trep(x, w) {\n\t\t\t\tif( field[y][x]=='.' && checked[0][y][x] && !checked[1][y][x] )\n\t\t\t\t\tcntW++;\n\t\t\t\tif( field[y][x]=='.' && checked[1][y][x] && !checked[0][y][x] )\n\t\t\t\t\tcntB++;\n\t\t\t}\n\t\t}\n\t\tcout << cntB << ' ' << cntW << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <tuple>\n#include <cstring>\nusing namespace std;\n\n#define loop(i,a,b) for(int i=(a);i<int(b);i++)\n#define rep(i,b) loop(i,0,b)\n#define eb emplace_back\n\nint w,h;\nchar g[55][55];\nint flg[55][55];\n\nvoid draw(int i, int j, int c){\n    rep(d,4){\n        int di[] = {0,1,0,-1};\n        int dj[] = {1,0,-1,0};\n        int ni = i+di[d];\n        int nj = j+dj[d];\n        if(ni >= h || ni < 0 || nj >= w || nj < 0) continue;\n        if(g[ni][nj]!='.' || flg[ni][nj]&c) continue;\n        flg[ni][nj] |= c;\n        draw(ni,nj,c);\n    }\n}\n\nint main(){\n    while(cin >> w >> h && w){\n        rep(i,h) cin >> g[i];\n        memset(flg,0,sizeof(flg));\n        rep(i,h)rep(j,w)if(g[i][j]!='.') draw(i,j,g[i][j]=='W' ? 1 : 2);\n        int cb = 0, cw = 0;\n        rep(i,h)rep(j,w){\n            if(flg[i][j]==1) cw++;\n            if(flg[i][j]==2) cb++;\n        }\n        cout << cb << \" \" << cw << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\nusing namespace std;\nusing P = pair<int,int>;\n\nchar A[50][50];\nbool isB[50][50];\nbool isW[50][50];\n\nint main(){\n    int w,h;\n    deque<P> B,W;\n    while(cin>>w>>h,w){\n        B.clear();\n        W.clear();\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                cin>>A[i][j];\n                if(A[i][j]=='B')B.emplace_back(i,j);\n                if(A[i][j]=='W')W.emplace_back(i,j);\n            }\n        }\n        fill(isB[0],isB[50],false);\n        fill(isW[0],isW[50],false);\n        while(!B.empty()){\n            int y,x;\n            tie(y,x) = B.front(); B.pop_front();\n            isB[y][x]=true;\n            int d[5]={0,1,0,-1,0};\n            for(int i=0;i<4;i++){\n                int yy=y+d[i],xx=x+d[i+1];\n                if(yy<0||yy>=h||xx<0||xx>=w) continue;\n                if(!isB[yy][xx]&&A[yy][xx]=='.'){\n                    B.emplace_back(yy,xx);\n                }\n            }\n        }\n        while(!W.empty()){\n            int y,x;\n            tie(y,x) = W.front(); W.pop_front();\n            isW[y][x]=true;\n            int d[5]={0,1,0,-1,0};\n            for(int i=0;i<4;i++){\n                int yy=y+d[i],xx=x+d[i+1];\n                if(yy<0||yy>=h||xx<0||xx>=w) continue;\n                if(!isW[yy][xx]&&A[yy][xx]=='.'){\n                    W.emplace_back(yy,xx);\n                }\n            }\n        }\n        int ansB=0,ansW=0;\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                if(A[i][j]=='.'&&isB[i][j]&&!isW[i][j]) ansB++;\n                if(A[i][j]=='.'&&!isB[i][j]&&isW[i][j]) ansW++;\n            }\n        }\n        cout<<ansB<<' '<<ansW<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <deque>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define EPS 1e-9\n#define INF MOD\n#define MOD 1000000007LL\n#define fir first\n#define iss istringstream\n#define sst stringstream\n#define ite iterator\n#define ll long long\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<n;i++)\n#define pi pair<int,int>\n#define pb push_back\n#define sec second\n#define sh(i) (1LL<<i)\n#define sz size()\n#define vi vector<int>\n#define vc vector\n#define vl vector<ll>\n#define vs vector<string>\n\nint h,w,c[55][55],dy[]={0,1,0,-1},dx[]={1,0,-1,0};\nchar m[55][55];\n\nvoid dfs(int y,int x,int C){\n\tif((c[y][x]|C)==c[y][x])return;\n\tc[y][x]|=C;\n\trep(i,4){\n\t\tint ny=y+dy[i],nx=x+dx[i];\n\t\tif(0<=ny&&ny<h&&0<=nx&&nx<w&&m[ny][nx]=='.')dfs(ny,nx,C);\n\t}\n}\n\nint main(){\n\twhile(cin>>w>>h,w){\n\t\tint B=0,W=0;\n\t\tmemset(c,0,sizeof(c));\n\t\trep(i,h)cin>>m[i];\n\t\trep(i,h)rep(j,w){\n\t\t\tif(m[i][j]=='B')dfs(i,j,1);\n\t\t\tif(m[i][j]=='W')dfs(i,j,2);\n\t\t}\n\t\trep(i,h)rep(j,w)if(m[i][j]=='.'){\n\t\t\tif(c[i][j]==1)B++;\n\t\t\tif(c[i][j]==2)W++;\n\t\t}\n\t\tcout<<B<<\" \"<<W<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdio>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <cmath>\n#include <complex>\n#include <map>\n#include <climits>\n#include <sstream>\nusing namespace std;\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define EPS 1e-8\n#define F first\n#define S second\n#define mkp make_pair\n\nstatic const double PI=6*asin(0.5);\ntypedef long long ll;\ntypedef complex<double> CP;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vint;\nstatic const int INF=1<<24;\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v,int a,int b, const T  &t = T()){\n\tv.assign(a,vector<T>(b,t));\n}\n\n//v.erase(unique(v.begin(),v.end()),v.end());\n\nvector<vint> vv;\nvector<vint> vis;\nint B,W;\nint x,y;\nbool f1,f2;\nint foo(int a,int b){\n\tint ret=0;\n\t// cout<<a<<\" \"<<b<<endl;\n\tif(vv[a][b]==1) f1=true;\n\tif(vv[a][b]==2) f2=true;\n\tif(vis[a][b]) return 0;\n\tvis[a][b]=1;\n\tret++;\n\tif(a>0){\n\t\tret+=foo(a-1,b);\n\t}\n\tif(a<x-1){\n\t\tret+=foo(a+1,b);\n\t}\n\tif(b>0){\n\t\tret+=foo(a,b-1);\n\t}\n\tif(b<y-1){\n\t\tret+=foo(a,b+1);\n\t}\n\n\treturn ret;\n}\n\nint main(){\n\t// int x,y;\n\twhile(cin>>y>>x,x||y){\n\t\tinitvv(vv,x,y);\n\t\tinitvv(vis,x,y);\n\t\tB=0;\n\t\tW=0;\n\t\trep(i,x){\n\t\t\trep(j,y){\n\t\t\t\tvis[i][j]=0;\n\t\t\t\tchar t;\n\t\t\t\tcin>>t;\n\t\t\t\tif(t=='B'){\n\t\t\t\t\tvv[i][j]=1;\n\t\t\t\t\tvis[i][j]=1;\n\t\t\t\t}\n\t\t\t\telse if(t=='.'){\n\t\t\t\t\tvv[i][j]=0;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tvv[i][j]=2;\n\t\t\t\t\tvis[i][j]=1;\n\t\t\t\t}\n\t\t\t\t// cout<<vv[i][j];\n\t\t\t}\n\t\t\t// cout<<endl;\n\t\t}\n\t\t// initvv(vis,x,y);\n\t\trep(i,x){\n\t\t\trep(j,y){\n\t\t\t\tif(vis[i][j]==0){\n\t\t\t\t\tf1=false;\n\t\t\t\t\tf2=false;\n\t\t\t\t\tint tt=foo(i,j);\n\t\t\t\t\tif(f1&&!f2){\n\t\t\t\t\t\tB+=tt;\n\t\t\t\t\t}\n\t\t\t\t\tif(!f1&&f2){\n\t\t\t\t\t\tW+=tt;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<B<<\" \"<<W<<endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <limits.h>\n#include <math.h>\n#include <set>\n#include <stack>\n#include <stdlib.h>\n#include <string>\n#include <vector>\n\n#define el endl\n#define fd fixed\n#define INF INT_MAX/2-1\n#define pb push_back\n\nusing namespace std;\n\nchar map[50][50];\nbool memoB[50][50];\nbool memoW[50][50];\n\nvoid search(int x, int y, int w, int h, char color) {\n  if (color == 'B') {\n    memoB[x][y] = true;\n  } else {\n    memoW[x][y] = true;\n  }\n  if (x > 0 && map[x-1][y] == '.') {\n    if ((color == 'B' && !memoB[x-1][y]) || (color == 'W' && !memoW[x-1][y])) {\n      search(x-1, y, w, h, color);\n    }\n  }\n  if (y > 0 && map[x][y-1] == '.') {\n    if ((color == 'B' && !memoB[x][y-1]) || (color == 'W' && !memoW[x][y-1])) {\n      search(x, y-1, w, h, color);\n    }\n  }\n  if (x < w-1 && map[x+1][y] == '.') {\n    if ((color == 'B' && !memoB[x+1][y]) || (color == 'W' && !memoW[x+1][y])) {\n      search(x+1, y, w, h, color);\n    }\n  }\n  if (y < h-1 && map[x][y+1] == '.') {\n    if ((color == 'B' && !memoB[x][y+1]) || (color == 'W' && !memoW[x][y+1])) {\n      search(x, y+1, w, h, color);\n    }\n  }\n}\n\nint main() {\n  int w, h, cntB, cntW, resB, resW;\n  char tmp;\n  while (cin >> w >> h, w | h) {\n    cntB = cntW = 0;\n    for (int i = 0; i < w; i++) {\n      for (int j = 0; j < h; j++) {\n        cin >> tmp;\n        map[i][j] = tmp;\n        if (tmp == '.') memoB[i][j] = memoW[i][j] = false;\n        if (tmp == 'B') memoB[i][j] = true, memoW[i][j] = false, cntB++;\n        if (tmp == 'W') memoB[i][j] = false, memoW[i][j] = true, cntW++;\n      }\n    }\n    for (int i = 0; i < w; i++) {\n      for (int j = 0; j < h; j++) {\n        if (map[i][j] == 'B') search(i, j, w, h, 'B');\n        if (map[i][j] == 'W') search(i, j, w, h, 'W');\n      }\n    }\n    resB = resW = 0;\n    for (int i = 0; i < w; i++) {\n      for (int j = 0; j < h; j++) {\n        if (memoB[i][j] && !memoW[i][j]) resB++;\n        if (!memoB[i][j] && memoW[i][j]) resW++;\n      }\n    }\n    cout << resB-cntB << \" \" << resW-cntW << el;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nvoid dfs(int,int);\nint w,h,mat[50][50],flagb,flagw,cnt;\nint main(){\n  int i,j,bcnt,wcnt;\n  string data[50];\n  while(1){\n    bcnt=0;\n    wcnt=0;\n    cin >> w >> h;\n    if(w==0&&h==0) break;\n    for(i=0;i<h;i++){\n      cin >> data[i];\n    }  \n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n        if(data[i][j]=='B') mat[i][j]=1;\n        else if(data[i][j]=='W') mat[i][j]=2;\n        else mat[i][j]=0;\n      }\n    }\n    \n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n    cnt=0;\n    flagb=0;\n    flagw=0;\n        if(mat[i][j]==0){\n      dfs(i,j);\n      if(flagb==1&&flagw==1){\n        bcnt+=0;\n        wcnt+=0;\n      }\n      else if(flagb==1){\n        bcnt+=cnt;\n      }\n          else if(flagw==1){\n        wcnt+=cnt;\n      }\n    }\n      }\n    }\n    cout << bcnt << ' ' << wcnt << endl;\n  }\n  return 0;\n}\nvoid dfs(int i,int j){\n  if(mat[i][j]==3) return ;\n  if(mat[i][j]==1){\n    flagb=1;\n    return ;\n  }\n  if(mat[i][j]==2){\n    flagw=1;\n    return ;\n  }\n  if(mat[i][j]==0){\n    cnt++;\n  } \n  if(mat[i][j]==3) return ;\n  mat[i][j]=3;\n  if(j+1<w) dfs(i,j+1);\n  if(0<=j-1) dfs(i,j-1);\n  if(i+1<h) dfs(i+1,j);\n  if(0<=i-1) dfs(i-1,j);\n}\n//1:B 2:W"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint w, h, cnt;\nchar cmp;\nchar field[50][50];\nint dx[] = { -1, 0, 1, 0 };\nint dy[] = { 0, -1, 0, 1 };\n\nbool search( int sx, int sy ){\n    cnt++;\n    field[sy][sx] = '#';\n    bool ans = true;\n    for( int i = 0; i < 4; i++ ){\n        int x = sx + dx[i];\n        int y = sy + dy[i];\n        if( 0 <= x && x < w && 0 <= y && y < h && field[y][x] != '#' ){\n            if( field[y][x] == 'B' || field[y][x] == 'W' ){\n                if( cmp == '.' ) cmp = field[y][x];\n                else if( cmp != field[y][x] ) ans =  false;\n            }else if( !search( x, y ) ) ans = false;\n        }\n    }\n    return ans;\n}\n\nint main(){\n    while( cin >> w >> h && w ){\n        for( int i = 0; i < h; i++ ){\n            for( int j = 0; j < w; j++ ){\n                cin >> field[i][j];\n            }\n        }\n        int cnt_b = 0, cnt_w = 0;\n        for( int i = 0; i < h; i++ ){\n            for( int j = 0; j < w; j++ ){\n                cnt = 0;\n                cmp = '.';\n                if( field[i][j] == '.' ){\n                    if( search( j, i ) ){\n                        if( cmp == 'B' ) cnt_b += cnt;\n                        else if( cmp == 'W' ) cnt_w += cnt;\n                    }\n                }\n            }\n        }\n        cout << cnt_b << ' ' << cnt_w << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint w, h;\n\nbool check(int x, int y){\n\treturn x >= 0 && x < w && y >= 0 && y < h;\t\n}\n\n\nint main() {\n\tint dx[] = {1, 0, -1, 0};\n\tint dy[] = {0, 1, 0, -1};\n\twhile(cin >> w >> h && (w || h)){\n\t\tstring a;\n\t\tint cntB = 0, cntW = 0;\n\t\tvector<string> maze;\n\t\tfor(int i = 0; i < h; ++i){\n\t\t\tcin >> a;\n\t\t\tmaze.push_back(a);\n\t\t}\n\t\tfor(int y = 0; y < h; ++y){\n\t\t\tfor(int x = 0; x < w; ++x){\n\t\t\t\tif(maze[y][x] != '.')\n\t\t\t\t\tcontinue;\n\t\t\t\tbool white = false, black = false;\n\t\t\t\tqueue<P> que;\n\t\t\t\tbool visited[64][64] = {0};\n\t\t\t\tque.push(P(x, y));\n\t\t\t\twhile(!que.empty()){\n\t\t\t\t\tP p = que.front();\n\t\t\t\t\tque.pop();\n\t\t\t\t\tint px = p.first;\n\t\t\t\t\tint py = p.second;\n\t\t\t\t\tvisited[py][px] = true;\n\t\t\t\t\tif(maze[py][px] == 'W'){\n\t\t\t\t\t\twhite = true;\n\t\t\t\t\t\t//cout << x << \" \" << y << endl;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(maze[py][px] == 'B'){\n\t\t\t\t\t\tblack = true;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfor(int i = 0; i < 4; ++i){\n\t\t\t\t\t\tint nx = px + dx[i];\n\t\t\t\t\t\tint ny = py + dy[i];\n\t\t\t\t\t\tif(check(nx, ny) && !visited[ny][nx])\n\t\t\t\t\t\t\tque.push(P(nx, ny));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!white && black)\n\t\t\t\t\tcntB++;\n\t\t\t\telse if(white && !black)\n\t\t\t\t\tcntW++;\n\t\t\t}\n\t\t}\n\t\tcout << cntB << \" \" << cntW << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\nenum COLOR {\n\tBLACK,\n\tUNKNOWN,\n\tWHITE,\n\tBOTH,\n};\n\nint w, h;\nchar field[52][52];\n\nCOLOR color;\nint count;\n\nvoid dfs(int x, int y) {\n\tfield[y][x] = '#';\n\tcount++;\n\tfor (int i = 0; i < 4; i++) {\n\t\tint nextX = x + dx[i];\n\t\tint nextY = y + dy[i];\n\t\tif (0 <= nextX && nextX < w && 0 <= nextY && nextY < h && field[nextY][nextX] != '#') {\n\t\t\tswitch (field[nextY][nextX]) {\n\t\t\tcase '.':\n\t\t\t\tdfs(nextX, nextY);\n\t\t\t\tbreak;\n\t\t\tcase 'W':\n\t\t\t\tif (color == BLACK) color = BOTH;\n\t\t\t\telse if (color == UNKNOWN) color = WHITE;\n\t\t\t\tbreak;\n\t\t\tcase 'B':\n\t\t\t\tif (color == WHITE) color = BOTH;\n\t\t\t\telse if (color == UNKNOWN) color = BLACK;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid printfield() {\n\tfor (int i = 0; i < h; i++) {\n\t\tcout << field[i] << endl;\n\t}\n}\n\nint main () {\n\twhile (cin >> w >> h, w || h) {\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tcin >> field[i];\n\t\t}\n\t\tint black = 0, white = 0;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (field[i][j] == '.') {\n\t\t\t\t\tcount = 0;\n\t\t\t\t\tcolor = UNKNOWN;\n\t\t\t\t\tdfs(j, i);\n\t\t\t\t\tif (color == BLACK) black += count;\n\t\t\t\t\tif (color == WHITE) white += count;\n//\t\t\t\t\tif (color == UNKNOWN) cout << \"unknown: \" << count << endl;\n//\t\t\t\t\tif (color == BOTH) cout << \"both: \" << count << endl;\n//\t\t\t\t\tprintfield();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << black << ' ' << white << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string>\n#include<stdlib.h>\n#include<math.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<numeric>\n#include<string.h>\n#include<map>\n#include<queue>\n#include<stack>\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\n#define rep(i,j) for(int i=0;i<(j);i++)\n#define reps(i,j,k) for(int i=j;i<=k;i++)\n#define in(i,j,k) ((i)>=(j)&&(i)<=(k))\n\nconst char dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\nint w,h;\nchar a[51][51],b[51][51];\n\t\nvoid dfs(int x,int y,char c){\n\trep(i,4)if(x+dx[i]>=0&&x+dx[i]<h&&y+dy[i]>=0&&y+dy[i]<w){\n\t\tif(a[x+dx[i]][y+dy[i]]=='.' && (b[x+dx[i]][y+dy[i]]&c)!=c){\n\t\t\tb[x+dx[i]][y+dy[i]]|=c;\n\t\t\tdfs(x+dx[i],y+dy[i],c);\n\t\t}\n\t}\n}\nint main(){\n\tdo{\n\t\tscanf(\"%d%d\",&w,&h);\n\t\tif(!w)break;\n\t\trep(i,h)scanf(\"%s\",a[i]);\n\t\tint bl=0,wi=0;\n\t\tmemset(b,0,sizeof(b));\n\t\trep(i,h)rep(j,w){\n\t\t\tif(a[i][j]!='.')dfs(i,j,a[i][j]=='B'?2:1);\n\t\t}\n\t\trep(i,h)rep(j,w){\n\t\t\tbl+=b[i][j]==2;\n\t\t\twi+=b[i][j]==1;\n\t\t}\n\t\tprintf(\"%d %d\\n\",bl,wi,0);\n\t}while(1);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <queue>\n#include <algorithm>\n#include <math.h>\n#include <utility>\n#include <set>\n#include <map>\n#include <cstring>\n#include <cstdio>\n#include <stack>\n#define INF 1000000000\n#define rep(i,n) for(int i =0;i<n;i++)\nusing namespace std;\ntypedef long long int ll;\n\nchar g[60][60];\npair<int, int> used[60][60];\nint w,h;\n\nvoid dfsf(int x, int y, int color){\n    if(x<0 or x>=h or y<0 or y>=w)return;\n    if(used[x][y].first!=0) return;\n    used[x][y].first=color;\n    dfsf(x+1, y, color);\n    dfsf(x-1, y, color);\n    dfsf(x, y+1, color);\n    dfsf(x, y-1, color);\n}\nvoid dfss(int x, int y, int color){\n    if(x<0 or x>=h or y<0 or y>=w)return;\n    if(used[x][y].second!=0) return;\n    used[x][y].second=color;\n    dfss(x+1, y, color);\n    dfss(x-1, y, color);\n    dfss(x, y+1, color);\n    dfss(x, y-1, color);\n}\n\n\nint main(){\n    for(;;){\n        cin >> w >> h;\n        if(w==0)break;\n        memset(used, 0, sizeof(used));\n        rep(i,h){\n            rep(j, w){\n                cin >> g[i][j];\n                if(g[i][j]!='.')used[i][j]={3,3};\n            }\n        }\n        rep(i,h){\n            rep(j, w){\n                if(g[i][j]=='B'){\n                    dfsf(i+1, j, 1);\n                    dfsf(i-1, j, 1);\n                    dfsf(i, j+1, 1);\n                    dfsf(i, j-1, 1);\n                }\n                if(g[i][j]=='W'){\n                    dfss(i+1, j, 1);\n                    dfss(i-1, j, 1);\n                    dfss(i, j+1, 1);\n                    dfss(i, j-1, 1);\n                }\n            }\n        }\n        int ans1=0,ans2 = 0;\n        for (int i=0; i<h; i++) {\n            for (int j=0; j<w; j++) {\n                if (used[i][j].first==1 and used[i][j].second==0) {\n                    ans1++;\n                }\n                if (used[i][j].first ==0 and used[i][j].second == 1) {\n                    ans2++;\n                }\n            }\n        }\n        cout << ans1 <<\" \"<<ans2<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\nint dx[] = {-1,  0, 0, 1};\nint dy[] = { 0, -1, 1, 0};\nint w, h;\nvector< vector<char> > Field;\nvector< vector<char> > used;\nbool Bflag;\nbool Wflag;\nint Bsum;\nint Wsum;\n\nvoid search(int x, int y)\n{\n\tused[y][x] = true;\n\tif(Bflag && Wflag)\n\t{\n\t\treturn;\n\t}\n\tfor(int i = 0; i < 4; ++i)\n\t{\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\t\tif(Field[ny][nx] == '.' && !used[ny][nx])\n\t\t{\n\t\t\tsearch(nx, ny);\n\t\t}\n\t\telse if(Field[ny][nx] == 'W')\n\t\t{\n\t\t\tWflag = true;\n\t\t}\n\t\telse if(Field[ny][nx] == 'B')\n\t\t{\n\t\t\tBflag = true;\n\t\t}\n\t}\n}\n\nvoid sum(int a, int b, char c)\n{\n\tField[b][a] = '2';\n\tif(c == 'B')\n\t{\n\t\t++Bsum;\n\t\tfor(int i = 0; i < 4; ++i)\n\t\t{\n\t\t\tint nx = a + dx[i];\n\t\t\tint ny = b + dy[i];\n\t\t\tif(Field[ny][nx] == '.')\n\t\t\t{\n\t\t\t\tsum(nx, ny, c);\n\t\t\t}\n\t\t}\t\t\n\t}\n\telse if(c == 'W')\n\t{\n\t\t++Wsum;\n\t\tfor(int i = 0; i < 4; ++i)\n\t\t{\n\t\t\tint nx = a + dx[i];\n\t\t\tint ny = b + dy[i];\n\t\t\tif(Field[ny][nx] == '.')\n\t\t\t{\n\t\t\t\tsum(nx, ny, c);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid invalid(int a, int b, char c)\n{\n\tField[b][a] = c;\n\tfor(int i = 0; i < 4; ++i)\n\t{\n\t\tint nx = a + dx[i];\n\t\tint ny = b + dy[i];\n\t\tif(Field[ny][nx] == '.')\n\t\t{\n\t\t\tinvalid(nx, ny, c);\n\t\t}\n\t}\n}\n\nvoid solve()\n{\n\twhile(cin >> w >> h, w || h)\n\t{\n\t\tField.resize(h + 2);\n\t\tused.resize(h + 2);\n\t\tfor(int i = 0; i <= h + 1; ++i)\n\t\t{\n\t\t\tField[i].resize(w + 2);\n\t\t\tused[i].resize(w + 2);\n\t\t}\n\t\tfor(int i = 0; i <= h + 1; ++i)\n\t\t{\n\t\t\tfor(int j = 0; j <=  w + 1; ++j)\n\t\t\t{\n\t\t\t\tField[i][j] = '2';\n\t\t\t\tused[i][j] = false;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 1; i <= h; ++i)\n\t\t{\n\t\t\tfor(int j = 1; j <= w; ++j)\n\t\t\t{\n\t\t\t\tcin >> Field[i][j];\n\t\t\t}\n\t\t}\n\t\tBsum = 0;\n\t\tWsum = 0;\n\t\tfor(int i = 1; i <= h; ++i)\n\t\t{\n\t\t\tfor(int j = 1; j <= w; ++j)\n\t\t\t{\n\t\t\t\tBflag = false;\n\t\t\t\tWflag = false;\n\t\t\t\tif(Field[i][j] == '.')\n\t\t\t\t{\n\t\t\t\t\tsearch(j, i);\n\t\t\t\t\tif(Bflag && !Wflag)\n\t\t\t\t\t{\n\t\t\t\t\t\tsum(j, i, 'B');\n\t\t\t\t\t}\n\t\t\t\t\telse if(!Bflag && Wflag)\n\t\t\t\t\t{\n\t\t\t\t\t\tsum(j, i, 'W');\n\t\t\t\t\t}\n\t\t\t\t\telse if(Bflag && Wflag)\n\t\t\t\t\t{\n\t\t\t\t\t\tinvalid(j, i, '2');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << Bsum << \" \" << Wsum << endl;\n\t}\n}\n\nint main()\n{\n\tsolve();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint n,m;\nstring s[50];\nint a[50][50];\nint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\nvoid dfs(int x,int y,int b)\n{\n\ta[x][y]|=b;\n\tfor(int r=0;r<4;r++)\n\t{\n\t\tint tx=x+dx[r],ty=y+dy[r];\n\t\tif(tx<0||tx>=n||ty<0||ty>=m||s[tx][ty]!='.'||a[tx][ty]&b)continue;\n\t\tdfs(tx,ty,b);\n\t}\n}\nmain()\n{\n\twhile(cin>>m>>n,n)\n\t{\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tcin>>s[i];\n\t\t\tfor(int j=0;j<m;j++)a[i][j]=0;\n\t\t}\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tfor(int j=0;j<m;j++)\n\t\t\t{\n\t\t\t\tif(s[i][j]=='W')dfs(i,j,2);\n\t\t\t\telse if(s[i][j]=='B')dfs(i,j,1);\n\t\t\t}\n\t\t}\n\t\tint cntb=0,cntw=0;\n\t\tfor(int i=0;i<n;i++)for(int j=0;j<m;j++)\n\t\t{\n\t\t\tif(s[i][j]!='.')continue;\n\t\t\tif(a[i][j]==1)cntb++;\n\t\t\telse if(a[i][j]==2)cntw++;\n\t\t}\n\t\tcout<<cntb<<\" \"<<cntw<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <cstdio>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define FOR(i, a, b) for(int i = (a); i < (b); i++)\n#define all(v) (v).begin(), (v).end()\n#define rev(s) (s).rbegin(), (s).rend()\n#define MP make_pair\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nstring field[50];\n\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nint w, h;\n\nint seedfill(int x, int y){\n\tqueue<P> q;\n\tq.push(MP(x,y));\n\tset<char> s;\n\tint cnt = 0;\n\n\twhile(!q.empty()){\n\t\tP p = q.front();\n\t\tq.pop();\n\n\t\tif(field[p.Y][p.X] != '.'){\n\t\t\ts.insert(field[p.Y][p.X]);\n\t\t\tcontinue;\n\t\t}\n\t\tfield[p.Y][p.X] = '#';\n\t\tcnt++;\n\n\t\trep(i, 4){\n\t\t\tint nx = p.X+dx[i];\n\t\t\tint ny = p.Y+dy[i];\n\t\t\tif(nx < 0 || nx >= w || ny < 0 || ny >= h) continue;\n\t\t\tq.push(MP(nx, ny));\n\t\t}\n\t}\n\tbool white = (s.find('W') != s.end());\n\tbool black = (s.find('B') != s.end());\n\tif(white && black) return 0;\n\tif(black) return -cnt;\n\tif(white) return  cnt;\n\treturn 0;\n}\n\nint main(){\n\twhile(1){\n\t\tcin >> w >> h;\n\t\tif(!w && !h)break;\n\t\trep(i, h){\n\t\t\tcin >> field[i];\n\t\t}\n\t\tint br = 0;\n\t\tint wh = 0;\n\t\trep(i, h){\n\t\t\trep(j, w){\n\t\t\t\tif(field[i][j] == '.'){\n\t\t\t\t\tint ret = seedfill(j, i);\n\t\t\t\t\tif(ret < 0) br += -ret;\n\t\t\t\t\telse wh += ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << br << ' ' << wh << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define DEBUG_ON\n#define CONDITION true\nusing namespace std;/*{{{*/\n\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <sys/time.h>\n#include <vector>\n\n#define INF (1e9)\nstatic const double PI = acos(-1.0);\nstatic const double EPS = 1e-10;\n\ntypedef long long int LL;\ntypedef unsigned long long int ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<char> VC;\ntypedef vector<VC> VVC;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef complex<double> P;\n\n#define FOR(i, b, e) for (typeof(e) i = (b); i != (e); i < (e)? ++i : --i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define IFC(c) if(c) continue;\n#define IFB(c) if(c) break;\n#define IFR(c, r) if(c) return r;\n\n#define OPOVER(_op, _type) inline bool operator _op (const _type &t) const\n\n#define arrsz(a) ( sizeof(a) / sizeof(a[0]) )\n\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n\n#define SZ(a) ((LL)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(c,it) for(__typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n\n#define BIT(n) (assert(n < 64), (1ULL << (n)))\n#define BITOF(n, m) (assert(m < 64), ((ULL)(n) >> (m) & 1))\n\n#define RANGE(a, b, c) ((a) <= (b) && (b) <= (c))\n\n#define PQ priority_queue\n#define SC static_cast\n\n#ifdef DEBUG_ON\n\t#define dprt(fmt, ...) if (CONDITION) fprintf(stderr, fmt, ##__VA_ARGS__)\n\t#define darr(a) if (CONDITION) copy( (a), (a) + arrsz(a), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr_range(a, f, t) if (CONDITION) copy( (a) + (f), (a) + (t), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define dvec(v) if (CONDITION) copy( ALL(v), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr2(a, n, m) if (CONDITION) FOR(i, 0, (n)){ darr_range( (a)[i], 0, (m) ); }\n\t#define dvec2(v) if (CONDITION) FOR(i, 0, SZ(v)){ dvec( (v)[i] ); }\n\t#define WAIT() if (CONDITION) { string _wait_; cerr << \"(hit return to continue)\" << endl; getline(cin, _wait_); }\n\t#define dump(x) if (CONDITION) cerr << \" [L\" << __LINE__ << \"] \" << #x << \" = \" << (x) << endl;\n\t#define dumpf() if (CONDITION) cerr << __PRETTY_FUNCTION__ << endl;\n\t#define dumpv(x) if (CONDITION) cerr << \" [L:\" << __LINE__ << \"] \" << #x << \" = \"; REP(q, (x).size()) cerr << (x)[q] << \" \"; cerr << endl;\n\t#define where() if (CONDITION) cerr << __FILE__ << \": \" << __PRETTY_FUNCTION__ << \" [L: \" << __LINE__ << \"]\" << endl;\n\t#define show_bits(b, s) if(CONDITION) { REP(i, s) { cerr << BITOF(b, s-1-i); if(i%4 == 3) cerr << ' '; } cerr << endl; }\n#else\n\t#define cerr if(0) cerr\n\t#define dprt(fmt, ...)\n\t#define darr(a)\n\t#define darr_range(a, f, t)\n\t#define dvec(v)\n\t#define darr2(a, n, m)\n\t#define dvec2(v)\n\t#define WAIT()\n\t#define dump(x)\n\t#define dumpf()\n\t#define dumpv(x)\n\t#define where()\n\t#define show_bits(b, s)\n#endif\n\n/* Inline functions */\ninline int onbits_count(ULL b) { int c = 0; while(b != 0) { c += (b & 1); b >>= 1; } return c; }\ninline int bits_count(ULL b) { int c = 0; while(b != 0) { ++c; b >>= 1; } return c; }\ninline int toInt(string s) { int v; istringstream sin(s);sin>>v;return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout;sout<<x;return sout.str(); }\ninline double now(){ struct timeval tv; gettimeofday(&tv, NULL); return (static_cast<double>(tv.tv_sec) + static_cast<double>(tv.tv_usec) * 1e-6); }\ninline VS split(string s, char delimiter) { VS v; string t; REP(i, s.length()) { if(s[i] == delimiter) v.PB(t), t = \"\"; else t += s[i]; } v.PB(t); return v; }\n\n/* Tweaks */\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \", \" << d.second << \")\";}\n\n/* Frequent stuffs */\nint n_dir = 4;\nint dx[] = {0, 1, 0, -1}, dy[] = {-1, 0, 1, 0}; /* CSS order */\nenum direction {\n\tUP, RIGHT, DOWN, LEFT\n};\n// int n_dir = 8;\n// int dx[] = {0, 1, 1, 1, 0, -1, -1, -1}, dy[] = {-1, -1, 0, 1, 1, 1, 0, -1};\n// enum direction {\n\t// UP, UPRIGHT, RIGHT, DOWNRIGHT, DOWN, DOWNLEFT, LEFT, UPLEFT\n// }\n#define FORDIR(d) REP (d, n_dir)\n\n/*}}}*/\n\nint w, h;\nVVC field;\nVVB adj_white;\nVVB adj_black;\n\nvoid spread(char color, int sy, int sx)\n{\n\tVVB visited = VVB(h, VB(w, false));\n\tqueue<PII> q; q.push(MP(sy, sx));\n\twhile (!q.empty()) {\n\t\tint y = q.front().F, x = q.front().S; q.pop();\n\t\tvisited[y][x] = true;\n\t\tif (color == 'W') {\n\t\t\tadj_white[y][x] = true;\n\t\t} else {\n\t\t\tadj_black[y][x] = true;\n\t\t}\n\t\tREP (d, 4) {\n\t\t\tint ny = y + dy[d], nx = x + dx[d];\n\t\t\tIFC( !(0 <= ny && ny < h) || !(0 <= nx && nx < w) );\n\t\t\tIFC( color == 'W' && adj_white[ny][nx] );\n\t\t\tIFC( color == 'B' && adj_black[ny][nx] );\n\t\t\tif (!visited[ny][nx] && field[ny][nx] == '.') {\n\t\t\t\tq.push(MP(ny, nx));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tstd::ios_base::sync_with_stdio(false);\n\twhile (cin >> w >> h, w | h) {\n\t\tfield = VVC(h, VC(w));\n\t\tREP (i, h) {\n\t\t\tREP (j, w) {\n\t\t\t\tcin >> field[i][j];\n\t\t\t}\n\t\t}\n\n\t\tadj_black = VVB(h, VB(w, false));\n\t\tadj_white = VVB(h, VB(w, false));\n\t\tREP (i, h) {\n\t\t\tREP (j, w) {\n\t\t\t\tif (field[i][j] != '.') {\n\t\t\t\t\tspread(field[i][j], i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint white = 0, black = 0;\n\t\tREP (i, h) {\n\t\t\tREP (j, w) {\n\t\t\t\tif (field[i][j] == '.') {\n\t\t\t\t\tif (adj_white[i][j] && !adj_black[i][j]) {\n\t\t\t\t\t\t++white;\n\t\t\t\t\t}\n\t\t\t\t\tif (!adj_white[i][j] && adj_black[i][j]) {\n\t\t\t\t\t\t++black;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << black << \" \" << white << endl;\n\t}\n}\n\n// vim: foldmethod=marker"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, n) for(int i = a; i < n; i++)\n#define repb(i, a, b) for(int i = a; i >= b; i--)\n#define all(a) a.begin(), a.end()\n#define o(a) cout << a << endl\n#define int long long\n#define F first;\n#define S second;\nusing namespace std;\ntypedef pair<int, int> P;\n\nint h, w;\nint dy[4] = {1, -1, 0, 0};\nint dx[4] = {0, 0, 1, -1};\nint f[50][50];\nbool contain(int y, int x){\n    return (0 <= y && y < h && 0 <= x && x < w);\n}\n\nsigned main(){\n    while(1){\n        cin >> w >> h;\n        if(h + w == 0) break;\n        vector<string> s(h);\n        rep(i, 0, h) cin >> s[i];\n        rep(i, 0, h) rep(j, 0, w) f[i][j] = 0;\n        int bc = 0, wc = 0;\n        rep(i, 0, h){\n            rep(j, 0, w){\n                if(s[i][j] == '.') continue;\n                queue<P> q;\n                q.push(P(i, j));\n                int bt = (s[i][j] == 'W' ? 1 : 0);\n                while(!q.empty()){\n                    P p = q.front(); q.pop();\n                    rep(k, 0, 4){\n                        int ny = p.F + dy[k];\n                        int nx = p.S + dx[k];\n                        // cout << ny << \" \" << nx << endl;\n                        if(!contain(ny, nx)) continue;\n                        if(s[ny][nx] == '.'){\n                            // if(s[ny][nx] == 'W' || s[ny][nx] == 'B') continue;\n                            if(f[ny][nx] & (1 << bt)) continue;\n                            f[ny][nx] |= (1 << bt);\n                        // cout << p.first << \" \" << p.second << endl;\n                            \n                            q.push(P(ny, nx));\n                        }\n                    }\n                }\n            }\n        }\n        rep(i, 0, h){\n            rep(j, 0, w){\n                // cout << f[i][j] << \" \";\n                if(f[i][j] == 1) bc++;\n                if(f[i][j] == 2) wc++;\n            }\n            // cout << endl;\n        }\n        cout << bc << \" \" << wc << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint H,W,sum;\nchar BW[50][50];\n\nint judgeW(int h,int w)\n{\n  int a=0,b=0,c=0,d=0;\n  if(h<0 || h>=H || w<0 || w>=W || BW[h][w]=='B' ||BW[h][w]=='0')return 0;\n  if(BW[h][w]=='W')return 1;\n  if(BW[h][w]=='.'){\n    BW[h][w]='0';\n    sum++;\n  }\n  a=judgeW(h+1,w);\n  b=judgeW(h,w+1);\n  c=judgeW(h-1,w);\n  d=judgeW(h,w-1);\n  return (a+b+c+d);\n}\nint judgeB(int h,int w)\n{\n  int a=0,b=0,c=0,d=0;\n  if(h<0 || h>=H || w<0 || w>=W || BW[h][w]=='W' ||BW[h][w]=='1')return 0;\n  if(BW[h][w]=='B')return 1;\n  if(BW[h][w]=='0')BW[h][w]='1';\n  a=judgeB(h+1,w);\n  b=judgeB(h,w+1);\n  c=judgeB(h-1,w);\n  d=judgeB(h,w-1);\n  return (a+b+c+d);\n}\n\nint main()\n{\n  int a,b,sumb,sumw;\n  while(1){\n    cin>>W>>H;\n    if(H==0&&W==0)break;\n    sumb=0;sumw=0;\n    for(int i=0;i<H;i++){\n      for(int j=0;j<W;j++){\n\tcin>>BW[i][j];\n      }\n    }\n    for(int i=0;i<H;i++){\n      for(int j=0;j<W;j++){\n     \tif(BW[i][j]=='.'){\n\t  sum=0;\n\t  a=judgeW(i,j);\n          b=judgeB(i,j);\n\t  if((a!=0 && b!=0)||(a==0&&b==0))continue;\n          else if(a>0)sumw+=sum;\n\t  else sumb+=sum;\n\t  }\n      }\n    }\n    cout<<sumb<<\" \"<<sumw<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define MOD 1000000007\n#define INF (1LL << 25) // 33554432\n#define PI 3.14159265359\n#define EPS 1e-12\n//#define int ll\n\nint dx[] = {0, 0, 1, -1}, dy[] = {1, -1, 0, 0}, w, h, res;\nstring a[55];\nbool isw = false, isb = false;\n\nint dfs(int y, int x) {\n  a[y][x] = '#';\n  res++;\n  REP(i, 4) {\n    int nx = x + dx[i], ny = y + dy[i];\n    if (nx >= 0 && nx < w && ny >= 0 && ny < h) {\n      if (a[ny][nx] == '.')\n        dfs(ny, nx);\n      if (a[ny][nx] == 'W')\n        isw = true;\n      if (a[ny][nx] == 'B')\n        isb = true;\n    }\n  }\n\n  return res;\n}\n\nsigned main(void) {\n  while (true) {\n    cin >> w >> h;\n    if(!w && !h) break;\n    REP(i, h) cin >> a[i];\n\n    int nw = 0, nb = 0;\n    REP(i, h) REP(j, w) {\n      if (a[i][j] == '.') {\n        // cout << a[i][j] << \" \";\n        isw = false;\n        isb = false;\n        res = 0;\n        dfs(i, j);\n        if (isw && !isb)\n          nw += res;\n        else if (!isw && isb)\n          nb += res;\n        // cout << res << \" \" << i << \" \" << j << \" \" << nb << \" \" << nw <<\n        // endl;\n      }\n    }\n\n    cout << nb << \" \" << nw << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define all(c) (c).begin(),(c).end()\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define REP(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)\n#define pb(a) push_back(a)\n#define rd(a) cin>>(a)\n#define RD(a,b) cin>>(a)>>(b)\n#define pr(a) cout<<(a)<<endl\n#define PR(a,b) cout<<(a)<<\" \"<<(b)<<endl\n#define F first\n#define S second\n#define ll long long\nbool check(int n,int m,int x,int y){return (x<0||x>=n||y<0||y>=m)?false:true;}\nconst ll MAX=1000000007,MAXL=1LL<<60,dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\ntypedef pair<int,int> P;\n\nbool b[51][51];\nint n,m;\nbool ck;\nstring s[51];\n\nint dfs(int nx, int ny,char c) {\n  b[nx][ny]=true;\n  int cnt=0;\n  rep(i,4) {\n    int x=nx+dx[i],y=ny+dy[i];\n    if(check(n,m,x,y) && !b[x][y]) {\n      if(s[x][y]=='.') cnt+=dfs(x,y,c);\n      else if(s[x][y]!=c) ck=false;\n    }\n  }\n  return cnt+1;\n}\n\nint main() {\n  while(cin >> m >> n && n) {\n    rep(i,n) cin >> s[i];\n    memset(b,false,sizeof(b));\n    int p=0,q=0;\n    rep(i,n) {\n      rep(j,m) {\n\tif(s[i][j]=='.') continue;\n\trep(k,4) {\n\t  ck=true;\n\t  int x=i+dx[k],y=j+dy[k];\n\t  if(check(n,m,x,y) && !b[x][y] && s[x][y]=='.') {\n\t    if(s[i][j]=='W') {\n\t      int z=dfs(x,y,'W');\n\t      if(ck) q+=z;\n\t    } else {\n\t      int z=dfs(x,y,'B');\n\t      if(ck) p+=z;\n\t    }\n\t  }\n\t}\n      }\n    }\n    PR(p,q);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <queue>\n\n#pragma warning( disable: 4996 )\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n#define INF 100000000\n#define EPS 1e-9\n\n#define MAX_W 50\n#define MAX_H 50\n\nint W, H;\n\nvector<P> ans_list;\n\nint dx[] = { 1, 0, -1, 0 };\nint dy[] = { 0, -1, 0, 1 };\nbool black = false, white = false;\nchar maze_map[MAX_H][MAX_W];\n\nint solve(int sx, int sy, bool maze[][MAX_W]){\n\n\t\n\tmaze[sy][sx] = true;\n\n\tint ans = 1;\n\n\tfor (int i = 0; i < 4; i++){\n\t\tint nx = sx + dx[i];\n\t\tint ny = sy + dy[i];\n\t\tif (nx >= 0 && nx < W && ny >= 0 && ny < H){\n\t\t\tif (maze_map[ny][nx] == 'W')\n\t\t\t\twhite = true;\n\t\t\telse if (maze_map[ny][nx] == 'B')\n\t\t\t\tblack = true;\n\t\t\telse if(!maze[ny][nx]){\n\t\t\t\tans += solve(nx, ny, maze);\n\t\t\t}\n\t\t}\n\n\t}\n\n\treturn ans;\n\n}\n\nint main(){\n\n\twhile (true){\n\t\n\t\tcin >> W >> H;\n\t\tif (W == 0 && H == 0)\n\t\t\tbreak;\n\n\t\tfor (int i = 0; i < H; i++){\n\t\t\tfor (int j = 0; j < W; j++){\n\t\t\t\tcin >> maze_map[i][j];\n\t\t\t}\n\t\t}\n\n\t\tint white_ans = 0;\n\t\tint black_ans = 0;\n\t\tbool maze[MAX_H][MAX_W];\n\n\t\tfor (int i = 0; i < H; i++){\n\t\t\tfor (int j = 0; j < W; j++){\n\t\t\t\tmaze[i][j] = false;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < H; i++){\n\t\t\tfor (int j = 0; j < W; j++){\n\t\t\t\tblack = false, white = false;\n\t\t\t\tif (!maze[i][j] && maze_map[i][j] == '.'){\n\t\t\t\t\tint tmp = solve(j, i, maze);\n\t\t\t\t\tif (white && black)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\telse if (white)\n\t\t\t\t\t\twhite_ans += tmp;\n\t\t\t\t\telse if (black)\n\t\t\t\t\t\tblack_ans += tmp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tans_list.push_back(P(black_ans, white_ans));\n\t\n\t}\n\n\tfor (int i = 0; i < ans_list.size(); i++){\n\t\tcout << ans_list[i].first << \" \" << ans_list[i].second << endl;\n\t}\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint w,h;\nchar tbl[60][60];\nbool f[2][60][60];\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\nvoid dfs(int x,int y,int c){\n  f[c][y][x]=true;\n  for(int i=0;i<4;++i){\n    int mx = x+dx[i];\n    int my = y+dy[i];\n    if(mx<0 || my<0) continue;\n    if(mx>=w || my>=h) continue;\n    if(f[c][my][mx]) continue;\n    if(tbl[my][mx]!='.') continue;\n    dfs(mx,my,c);\n  }\n}\n\nint main(){\n  while(cin>>w>>h,w||h){\n    memset(f,0,sizeof(f));\n    for(int i=0;i<h;++i) cin >> tbl[i];\n    for(int i=0;i<h;++i)\n      for(int j=0;j<w;++j){\n\tif(tbl[i][j]=='B'){\n\t  dfs(j,i,0);\n\t}\n\tif(tbl[i][j]=='W'){\n\t  dfs(j,i,1);\n\t}\n      }\n    int B=0,W=0;\n    for(int i=0;i<h;++i)\n      for(int j=0;j<w;++j){\n\tif(tbl[i][j]=='.' && f[0][i][j] && !f[1][i][j]) ++B;\n\tif(tbl[i][j]=='.' && f[1][i][j] && !f[0][i][j]) ++W;\n      }\n    cout << B << \" \" << W << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define DEBUG_ON\n#define CONDITION true\nusing namespace std;/*{{{*/\n\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <iterator>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <sys/time.h>\n#include <vector>\n\n#define INF (1e9)\nstatic const double PI = acos(-1.0);\nstatic const double EPS = 1e-10;\n\ntypedef long long int LL;\ntypedef unsigned long long int ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<char> VC;\ntypedef vector<VC> VVC;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef complex<double> P;\n\n#define FOR(i, b, e) for (typeof(e) i = (b); i != (e); i < (e)? ++i : --i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define IFC(c) if(c) continue;\n#define IFB(c) if(c) break;\n#define IFR(c, r) if(c) return r;\n\n#define OPOVER(_op, _type) inline bool operator _op (const _type &t) const\n\n#define arrsz(a) ( sizeof(a) / sizeof(a[0]) )\n\n#define F first\n#define S second\n#define MP(a, b) make_pair(a, b)\n\n#define SZ(a) ((LL)a.size())\n#define PB(e) push_back(e)\n#define SORT(v) sort((v).begin(), (v).end())\n#define RSORT(v) sort((v).rbegin(), (v).rend())\n\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define EACH(c,it) for(__typeof((c).begin()) it=(c).begin(); it!=(c).end(); ++it)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n\n#define BIT(n) (assert(n < 64), (1ULL << (n)))\n#define BITOF(n, m) (assert(m < 64), ((ULL)(n) >> (m) & 1))\n\n#define RANGE(a, b, c) ((a) <= (b) && (b) <= (c))\n\n#define PQ priority_queue\n#define SC static_cast\n\n#ifdef DEBUG_ON\n\t#define dprt(fmt, ...) if (CONDITION) fprintf(stderr, fmt, ##__VA_ARGS__)\n\t#define darr(a) if (CONDITION) copy( (a), (a) + arrsz(a), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr_range(a, f, t) if (CONDITION) copy( (a) + (f), (a) + (t), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define dvec(v) if (CONDITION) copy( ALL(v), ostream_iterator<int>(cerr, \" \") ); cerr << endl\n\t#define darr2(a, n, m) if (CONDITION) FOR(i, 0, (n)){ darr_range( (a)[i], 0, (m) ); }\n\t#define dvec2(v) if (CONDITION) FOR(i, 0, SZ(v)){ dvec( (v)[i] ); }\n\t#define WAIT() if (CONDITION) { string _wait_; cerr << \"(hit return to continue)\" << endl; getline(cin, _wait_); }\n\t#define dump(x) if (CONDITION) cerr << \" [L\" << __LINE__ << \"] \" << #x << \" = \" << (x) << endl;\n\t#define dumpf() if (CONDITION) cerr << __PRETTY_FUNCTION__ << endl;\n\t#define dumpv(x) if (CONDITION) cerr << \" [L:\" << __LINE__ << \"] \" << #x << \" = \"; REP(q, (x).size()) cerr << (x)[q] << \" \"; cerr << endl;\n\t#define where() if (CONDITION) cerr << __FILE__ << \": \" << __PRETTY_FUNCTION__ << \" [L: \" << __LINE__ << \"]\" << endl;\n\t#define show_bits(b, s) if(CONDITION) { REP(i, s) { cerr << BITOF(b, s-1-i); if(i%4 == 3) cerr << ' '; } cerr << endl; }\n#else\n\t#define cerr if(0) cerr\n\t#define dprt(fmt, ...)\n\t#define darr(a)\n\t#define darr_range(a, f, t)\n\t#define dvec(v)\n\t#define darr2(a, n, m)\n\t#define dvec2(v)\n\t#define WAIT()\n\t#define dump(x)\n\t#define dumpf()\n\t#define dumpv(x)\n\t#define where()\n\t#define show_bits(b, s)\n#endif\n\n/* Inline functions */\ninline int onbits_count(ULL b) { int c = 0; while(b != 0) { c += (b & 1); b >>= 1; } return c; }\ninline int bits_count(ULL b) { int c = 0; while(b != 0) { ++c; b >>= 1; } return c; }\ninline int toInt(string s) { int v; istringstream sin(s);sin>>v;return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout;sout<<x;return sout.str(); }\ninline double now(){ struct timeval tv; gettimeofday(&tv, NULL); return (static_cast<double>(tv.tv_sec) + static_cast<double>(tv.tv_usec) * 1e-6); }\ninline VS split(string s, char delimiter) { VS v; string t; REP(i, s.length()) { if(s[i] == delimiter) v.PB(t), t = \"\"; else t += s[i]; } v.PB(t); return v; }\n\n/* Tweaks */\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \", \" << d.second << \")\";}\n\n/* Frequent stuffs */\nint n_dir = 4;\nint dx[] = {0, 1, 0, -1}, dy[] = {-1, 0, 1, 0}; /* CSS order */\nenum direction {\n\tUP, RIGHT, DOWN, LEFT\n};\n// int n_dir = 8;\n// int dx[] = {0, 1, 1, 1, 0, -1, -1, -1}, dy[] = {-1, -1, 0, 1, 1, 1, 0, -1};\n// enum direction {\n\t// UP, UPRIGHT, RIGHT, DOWNRIGHT, DOWN, DOWNLEFT, LEFT, UPLEFT\n// }\n#define FORDIR(d) REP (d, n_dir)\n\n/*}}}*/\n\nint w, h;\nVVC field;\nVVB adj_white;\nVVB adj_black;\n\nvoid spread(char color, int sy, int sx)\n{\n\tVVB visited = VVB(h, VB(w, false));\n\tqueue<PII> q; q.push(MP(sy, sx));\n\twhile (!q.empty()) {\n\t\tint y = q.front().F, x = q.front().S; q.pop();\n\t\tvisited[y][x] = true;\n\t\tif (color == 'W') {\n\t\t\tadj_white[y][x] = true;\n\t\t} else {\n\t\t\tadj_black[y][x] = true;\n\t\t}\n\t\tREP (d, 4) {\n\t\t\tint ny = y + dy[d], nx = x + dx[d];\n\t\t\tIFC( !(0 <= ny && ny < h) || !(0 <= nx && nx < w) );\n\t\t\tif (!visited[ny][nx] && field[ny][nx] == '.') {\n\t\t\t\tq.push(MP(ny, nx));\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main()\n{\n\tstd::ios_base::sync_with_stdio(false);\n\twhile (cin >> w >> h, w | h) {\n\t\tfield = VVC(h, VC(w));\n\t\tREP (i, h) {\n\t\t\tREP (j, w) {\n\t\t\t\tcin >> field[i][j];\n\t\t\t}\n\t\t}\n\n\t\tadj_black = VVB(h, VB(w, false));\n\t\tadj_white = VVB(h, VB(w, false));\n\t\tREP (i, h) {\n\t\t\tREP (j, w) {\n\t\t\t\tif (field[i][j] != '.') {\n\t\t\t\t\tspread(field[i][j], i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint white = 0, black = 0;\n\t\tREP (i, h) {\n\t\t\tREP (j, w) {\n\t\t\t\tif (field[i][j] == '.') {\n\t\t\t\t\tif (adj_white[i][j] && !adj_black[i][j]) {\n\t\t\t\t\t\t++white;\n\t\t\t\t\t}\n\t\t\t\t\tif (!adj_white[i][j] && adj_black[i][j]) {\n\t\t\t\t\t\t++black;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << black << \" \" << white << endl;\n\t}\n}\n\n// vim: foldmethod=marker"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  int w, h;\n  while (cin >> w) {\n    cin >> h;\n    if (w == 0 && h == 0) return 0;\n    vector<string> in(h);\n    for (int i = 0; i < h; i++) {\n      cin >> in[i];\n    }\n    int ans_w = 0, ans_b = 0;\n    vector<vector<int>> vis(h, vector<int>(w));\n    int dx[] = {1, -1, 0, 0}, dy[] = {0, 0, 1, -1};\n    for (int i = 0; i < h; i++) {\n      for (int j = 0; j < w; j++) {\n        if (vis[i][j] || in[i][j] != '.') continue;\n        //cerr << i << \" \" << j << endl;\n        vis[i][j] = 1;\n        int siz = 1;\n        queue<pair<int, int>> que;\n        que.push({i, j});\n        int col[2] = {};\n        while (que.size()) {\n          auto cur = que.front();\n          que.pop();\n          for (int k = 0; k < 4; k++) {\n            int x = cur.first + dx[k];\n            int y = cur.second + dy[k];\n            if (x < 0 || x >= h || y < 0 || y >= w || vis[x][y]) continue;\n            if (in[x][y] == 'W') {col[0] = 1; continue;}\n            if (in[x][y] == 'B') {col[1] = 1; continue;}\n            vis[x][y]++;\n            que.push({x, y});\n            siz++;\n          }\n        }\n        if (col[0] + col[1] == 2) continue;\n        if (col[0] == 1) ans_w += siz;\n        if (col[1] == 1) ans_b += siz;\n      }\n    }\n    cout << ans_b << \" \" << ans_w << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nint w, h;\nint a[50][50];\nbool b[2][50][50];\n\nvoid f(int c, int i, int j) {\n\tb[c][i][j] = true;\n\tfor (int k = 0; k < 4; k++) {\n\t\tif (a[i + dy[k]][j + dx[k]] == -1 && !b[c][i + dy[k]][j + dx[k]]) {\n\t\t\tf(c, i + dy[k], j + dx[k]);\n\t\t}\n\t}\n}\n\nint main() {\n\twhile (cin >> w >> h, w) {\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (s[j] == 'B') {\n\t\t\t\t\ta[i][j] = 0;\n\t\t\t\t} else if (s[j] == 'W') {\n\t\t\t\t\ta[i][j] = 1;\n\t\t\t\t} else {\n\t\t\t\t\ta[i][j] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int c = 0; c < 2; c++) {\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tb[c][i][j] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (a[i][j] != -1) {\n\t\t\t\t\tf(a[i][j], i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint p = 0, q = 0;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (a[i][j] == -1) {\n\t\t\t\t\tif (b[0][i][j] && !b[1][i][j]) {\n\t\t\t\t\t\tp++;\n\t\t\t\t\t} else if (!b[0][i][j] && b[1][i][j]) {\n\t\t\t\t\t\tq++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << p << ' ' << q << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdio>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <cmath>\n#include <complex>\n#include <map>\n#include <climits>\n#include <sstream>\nusing namespace std;\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define EPS 1e-8\n#define F first\n#define S second\n#define mkp make_pair\n\nstatic const double PI=6*asin(0.5);\ntypedef long long ll;\ntypedef complex<double> CP;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vint;\nstatic const int INF=1<<24;\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v,int a,int b, const T  &t = T()){\n\tv.assign(a,vector<T>(b,t));\n}\n\n//v.erase(unique(v.begin(),v.end()),v.end());\n\nvector<vint> vv;\nvector<vint> vis;\nint B,W;\nint x,y;\nbool f1,f2;\nint foo(int a,int b){\n\tint ret=0;\n\t// cout<<a<<\" \"<<b<<endl;\n\tif(vv[a][b]==1) f1=true;\n\tif(vv[a][b]==2) f2=true;\n\tif(vis[a][b]) return 0;\n\tvis[a][b]=1;\n\tret++;\n\tif(a>0){\n\t\tret+=foo(a-1,b);\n\t}\n\tif(a<x-1){\n\t\tret+=foo(a+1,b);\n\t}\n\tif(b>0){\n\t\tret+=foo(a,b-1);\n\t}\n\tif(b<y-1){\n\t\tret+=foo(a,b+1);\n\t}\n\n\treturn ret;\n}\n\nint main(){\n\t// int x,y;\n\twhile(cin>>x>>y,x||y){\n\t\tinitvv(vv,x,y);\n\t\tinitvv(vis,x,y);\n\t\tB=0;\n\t\tW=0;\n\t\trep(i,x){\n\t\t\trep(j,y){\n\t\t\t\tvis[i][j]=0;\n\t\t\t\tchar t;\n\t\t\t\tcin>>t;\n\t\t\t\tif(t=='B'){\n\t\t\t\t\tvv[i][j]=1;\n\t\t\t\t\tvis[i][j]=1;\n\t\t\t\t}\n\t\t\t\telse if(t=='.'){\n\t\t\t\t\tvv[i][j]=0;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tvv[i][j]=2;\n\t\t\t\t\tvis[i][j]=1;\n\t\t\t\t}\n\t\t\t\t// cout<<vv[i][j];\n\t\t\t}\n\t\t\t// cout<<endl;\n\t\t}\n\t\t// initvv(vis,x,y);\n\t\trep(i,x){\n\t\t\trep(j,y){\n\t\t\t\tif(vis[i][j]==0){\n\t\t\t\t\tf1=false;\n\t\t\t\t\tf2=false;\n\t\t\t\t\tint tt=foo(i,j);\n\t\t\t\t\tif(f1&&!f2){\n\t\t\t\t\t\tB+=tt;\n\t\t\t\t\t}\n\t\t\t\t\tif(!f1&&f2){\n\t\t\t\t\t\tW+=tt;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<B<<\" \"<<W<<endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint n, m;\nint b, w;\nchar d[55][55];\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,1,0,-1};\n\nvoid bfs (int x, int y, char s) {\n    queue<P> q;\n    q.push(P(x,y));\n\n    while (q.size()) {\n        P p = q.front();\n        q.pop();\n\n        for (int i = 0; i < 4; i++) {\n            x = p.first + dx[i], y = p.second + dy[i];\n            if (0 <= x && x < n && 0 <= y && y < m) {\n                if (d[x][y] == '.') {\n                    d[x][y] = (s == 'W') ? '*' : '@';\n                    q.push(P(x,y));\n                    s == 'W' ? w++ : b++;\n                } else if (s == 'B' && d[x][y] == '*') {\n                    w--;\n                    q.push(P(x,y));\n                    d[x][y] = '@';\n                }\n            }\n        }\n    }\n}\n\nint main ()\n{\n    while (cin >> m >> n, (n || m)) {\n        for (int i = 0; i < n; i++) {\n            cin >> d[i];\n        }\n        b = w = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (d[i][j] == 'W') {\n                    bfs (i, j, 'W');\n                }\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (d[i][j] == 'B') {\n                    bfs (i, j, 'B');\n                }\n            }\n        }\n\n        cout << b << \" \" << w << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define pii pair<int, int>\nusing namespace std;\n\nchar a[55][55];\nint wh[55][55], bl[55][55];\n\nint di[] = {-1, 0, 1, 0};\nint dj[] = {0, -1, 0, 1};\n\nint main() {\n    int w, h;\n    while (cin >> w >> h, w | h) {\n        queue<pii> q1, q2;\n        for (int i = 0; i < 55; i++) {\n            for (int j = 0; j < 55; j++) {\n                wh[i][j] = bl[i][j] = 0;\n            }\n        }\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                cin >> a[j][i];\n                if (a[j][i] == 'W') {\n                    q1.push(pii(j, i));\n                    wh[j][i] = bl[j][i] = 2;\n                } else if (a[j][i] == 'B') {\n                    q2.push(pii(j, i));\n                    wh[j][i] = bl[j][i] = 2;\n                }\n            }\n        }\n        while (!q1.empty()) {\n            int ci = q1.front().second;\n            int cj = q1.front().first;\n            q1.pop();\n            for (int i = 0; i < 4; i++) {\n                int ni = ci + di[i];\n                int nj = cj + dj[i];\n                if (ni < 0 || ni >= h || nj < 0 || nj >= w) continue;\n                if (wh[nj][ni] == 0 && a[nj][ni] == '.') {\n                    wh[nj][ni] = 1;\n                    q1.push(pii(nj, ni));\n                }\n            }\n        }\n        while (!q2.empty()) {\n            int ci = q2.front().second;\n            int cj = q2.front().first;\n            q2.pop();\n            for (int i = 0; i < 4; i++) {\n                int ni = ci + di[i];\n                int nj = cj + dj[i];\n                if (ni < 0 || ni >= h || nj < 0 || nj >= w) continue;\n                if (bl[nj][ni] == 0 && a[nj][ni] == '.') {\n                    bl[nj][ni] = 1;\n                    q2.push(pii(nj, ni));\n                }\n            }\n        }\n        int r1 = 0, r2 = 0;\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                if (wh[j][i] == 0 && bl[j][i] == 1) r1++;\n                if (wh[j][i] == 1 && bl[j][i] == 0) r2++;\n            }\n        }\n        cout << r1 << \" \" << r2 << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n#define INF 1000000000\n#define rep(i,a,b) for (int i=(a);i<(b);i++)\n#define rev(i,a,b) for (int i=(a)-1;i>=b;i--)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef queue<int> qi;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\nint dx[4] = { 0, 1, 0, -1 };\nint dy[4] = { 1, 0, -1, 0 };\n\nint main() {\n\n\twhile(true) {\n\t\tint h, w;\n\t\tcin >> w >> h;\n\t\tif(!(h||w)) break;\n\n\t\tchar m[51][51];\n\t\trep(i,0,h) rep(j,0,w) cin >> m[i][j];\n\n\t\tbool B[50][50], W[50][50];\n\t\trep(i,0,h) rep(j,0,w) B[i][j] = W[i][j] = false;\n\n\t\trep(y,0,h) {\n\t\t\trep(x,0,w) {\n\t\t\t\tif(m[y][x] == '.') continue;\n\n\t\t\t\tbool m2[h][w];\n\t\t\t\trep(i,0,h) rep(j,0,w) m2[i][j] = false;\n\n\t\t\t\tqueue<pii> que;\n\t\t\t\tque.push(pii(y,x));\n\t\t\t\tm2[y][x] = true;\n\t\t\t\twhile(!que.empty()) {\n\t\t\t\t\tpii tmp = que.front();\n\t\t\t\t\tque.pop();\n\t\t\t\t\tint ny = tmp.first;\n\t\t\t\t\tint nx = tmp.second;\n\t\t\t\t\trep(i,0,4) {\n\t\t\t\t\t\tint my = ny + dy[i];\n\t\t\t\t\t\tint mx = nx + dx[i];\n\t\t\t\t\t\tif(0 <= my && my < h && 0 <= mx && mx < w && !m2[my][mx] &&\n\t\t\t\t\t\t\t m[my][mx] == '.') {\n\t\t\t\t\t\t\tque.push(pii(my, mx));\n\t\t\t\t\t\t\tm2[my][mx] = true;\n\t\t\t\t\t\t\tif(m[y][x] == 'B') B[my][mx] = true;\n\t\t\t\t\t\t\telse if(m[y][x] == 'W') W[my][mx] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\tint ans1 = 0, ans2 = 0;\n\t\trep(i,0,h) rep(j,0,w) {\n\t\t\tif(B[i][j] && !W[i][j]) ans1++;\n\t\t\telse if(!B[i][j] && W[i][j]) ans2++;\n\t\t}\n\n\t\tcout << ans1 << \" \" << ans2 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n\nusing namespace std;\nconst int dx[4] = {1,0,0,-1};\nconst int dy[4] = {0,1,-1,0};\nconst int B = 5;\nconst int W = 8;\nconst int BW = 13;\nint flagB = 0;\nint flagW = 0;\nqueue<pair<int,int> > que;\nvoid dfs(vector<vector<int> > &map,int x,int y){\n  map[x][y] = -1;\n  que.push(pair<int,int>(x,y));\n  for(int i = 0;i < 4;i++){\n    if(x+dx[i] >= 0 && x+dx[i] < map.size() && y+dy[i] >= 0 && y+dy[i] < map[0].size()){\n      if(map[x+dx[i]][y+dy[i]] == 1)flagB = B;\n      else if(map[x+dx[i]][y+dy[i]] == 2)flagW = W;\n      else if(map[x+dx[i]][y+dy[i]] == -1){}\n      else dfs(map,x+dx[i],y+dy[i]);\n      \n    }\n  }\n  \n  return ;\n}\nvoid solve(vector<vector<int> > &map){\n  while(!que.empty()){\n\n    pair<int,int> tmp = que.front();que.pop();\n    map[tmp.first][tmp.second] = flagB+flagW;\n  }\n  flagB = 0;\n  flagW = 0;\n  return ;\n}\nint main(){\n\n  while(1){\n    int w,h;\n    cin >> w >> h;\n    if(w == 0 && h == 0)break;\n    vector<vector<int> > map(w,vector<int>(h,0));\n    for(int i = 0;i < h;i++){\n      for(int j = 0;j < w;j++){\n\tchar a;\n\tcin >> a;\n\tif(a == 'B')map[j][i] = 1;///B\n\telse if(a == 'W')map[j][i] = 2;///W\n      }\n    }\n    for(int i = 0;i < h;i++){\n      for(int j = 0;j < w;j++){\n\tif(map[j][i] == 0){\n\t  dfs(map,j,i);\n\t  //\t  cout << flagW << \"dddddddddddddd\" << flagB << endl;\n\t  solve(map);\n\t}\n      }\n    }\n    int cnt_W = 0;\n    int cnt_B = 0;\n    for(int i = 0;i < h;i++){\n      for(int j = 0;j < w;j++){\n\t//cout << map[i][j] << \" \";\n\tif(map[j][i] == B)cnt_B++;\n\telse if(map[j][i] == W)cnt_W++;\n\t\n      }\n      //      cout << endl;\n    }\n    cout << cnt_B << \" \" << cnt_W << endl;\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing i64 = int64_t;\n\nstruct Node{\n    int i, j, color;\n};\n\nchar island[52][52]={0};\nint owner[52][52]={0};\nint di[4] = {0,1,0,-1}, dj[4] = {-1,0,1,0};\n\nvoid init(int w, int h){\n    for(int i=1;i<=h;++i){\n        for(int j=1;j<=w;++j){\n            island[i][j] = '.';\n            owner[i][j] = 0;\n        }\n    }\n    for(int i=0;i<=w+1;++i){\n        island[0][i] = '#';\n        island[h+1][i] = '#';\n    }\n    for(int i=0;i<=h+1;++i){\n        island[i][0] = '#';\n        island[i][w+1] = '#';\n    }\n}\n\nint main(){\n    int w, h;\n    while(cin >> w >> h, w != 0){\n        init(w, h);\n        queue<Node> que;\n        for(int i=1;i<=h;++i){\n            for(int j=1;j<=w;++j){\n                cin >> island[i][j];\n                if(island[i][j] == 'B'){\n                    que.push((Node){i, j, 1});\n                }else if(island[i][j] == 'W'){\n                    que.push((Node){i, j, 2});\n                }\n            }\n        }\n        while(!que.empty()){\n            Node cur = que.front(); que.pop();\n            for(int k=0;k<4;++k){\n                int ni = cur.i + di[k], nj = cur.j + dj[k];\n                if(island[ni][nj] != '.')continue;\n                if(owner[ni][nj] & cur.color)continue;\n                owner[ni][nj] |= cur.color;\n                que.push((Node){ni, nj, cur.color});\n            }\n        }\n        int black = 0, white = 0;\n        for(int i=1;i<=h;++i){\n            for(int j=1;j<=w;++j){\n                if(owner[i][j] == 1)black++;\n                else if(owner[i][j] == 2)white++;\n            }\n        }\n        cout << black << \" \" << white << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <stdint.h>\n\ntypedef uint32_t u32;\ntypedef uint64_t u64;\ntypedef std::pair<int, int> pii;\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\nint w, h;\nchar a[64][64];\nint used[64][64];\nint count;\nbool black_flag;\nbool white_flag;\n\n\nvoid dfs(int y, int x) {\n  if( not ( 0 <= y and y < h and 0 <= x and x < w ) ) return;\n  if( used[y][x] ) return;\n  if( a[y][x] != '.' ) {\n    if( a[y][x] == 'B' ) black_flag = true;\n    if( a[y][x] == 'W' ) white_flag = true;\n    return;\n  }\n  used[y][x] = true;\n  count += 1;\n  for(int i = 0; i < 4; ++i) {\n    dfs(y + dy[i], x + dx[i]);\n  }\n  return;\n}    \n\nint main() {\n\n  for(;;) {\n    int B = 0, W = 0;\n    std::cin >> w >> h;\n    if( w == 0 and h == 0 ) break;\n    for(int i = 0; i < h; ++i) for(int j = 0; j < w; ++j) std::cin >> a[i][j];\n    for(int i = 0; i < h; ++i) for(int j = 0; j < w; ++j) used[i][j] = false;\n    for(int i = 0; i < h; ++i) {\n      for(int j = 0; j < w; ++j) {\n        count = 0;\n        black_flag = white_flag = false;\n        dfs(i, j);\n        if( black_flag != white_flag ) {\n          if( black_flag ) {\n            B += count;\n          }\n          else {\n            W += count;\n          }\n        }\n      }\n    }\n    std::cout << B << ' ' << W << std::endl;\n  }                                                           \n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define min(a,b) ((a)<(b)?(a):(b))\n#define max(a,b) ((a)>(b)?(a):(b))\n#define REP(i,n) for(int i=0;i<n;i++)\n#define FOR(i,n1,n2) for(int i=n1;i<n2;i++)\n#define bFOR(i,n1,n2) for(int i=n1;i>=n2;i--)\n#define speed_up    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\ntypedef long long int ll;\ntypedef pair<ll,ll> Pi;\nconst int INF=(ll)(1LL<<30)-1;\nconst double INFd=100000000000.0;\nconst ll INFl=(ll)9223372036854775807;\nconst int MAX=10000;\nconst ll MOD=(ll)1e9+7;\nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){return a/gcd(a, b)*b;}\nint dx[4]={0,1,0,-1},dy[4]={-1,0,1,0};\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n\nint w,h;\nchar a[55][55];\nint wa[55][55];\nint ba[55][55];\n\nvoid bdfs(int y,int x){\n\tREP(i,4){\n\t\tint ny=y+dy[i];\n\t\tint nx=x+dx[i];\n\t\tif(0<=ny&&ny<h&&0<=nx&&nx<w&&ba[ny][nx]==0&&a[ny][nx]=='.'){\n\t\t\tba[ny][nx]=1;\n\t\t\tbdfs(ny,nx);\n\t\t}\n\t}\n\treturn;\n}\nvoid wdfs(int y,int x){\n\tREP(i,4){\n\t\tint ny=y+dy[i];\n\t\tint nx=x+dx[i];\n\t\tif(0<=ny&&ny<h&&0<=nx&&nx<w&&wa[ny][nx]==0&&a[ny][nx]=='.'){\n\t\t\twa[ny][nx]=-1;\n\t\t\twdfs(ny,nx);\n\t\t}\n\t}\n\treturn;\n}\nint main(){\n\twhile(1){\n\t\tcin>>w>>h;\n\t\tif(w==0&&h==0)break;\n\t\tREP(i,55)\n\t\t\tREP(j,55){\n\t\t\t\twa[i][j]=0;\n\t\t\t\tba[i][j]=0;\n\t\t\t}\n\t\tREP(i,h)\n\t\t\tREP(j,w)\n\t\t\t\tcin>>a[i][j];\n\t\t\n\t\tREP(i,h)\n\t\t\tREP(j,w){\n\t\t\t\tif(a[i][j]=='W'){\n\t\t\t\t\twdfs(i,j);\n\t\t\t\t}else if(a[i][j]=='B'){\n\t\t\t\t\tbdfs(i,j);\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\tint bans=0;\n\t\tint wans=0;\n\t\tREP(i,h)\n\t\t\tREP(j,w){\n\t\t\t\tif(wa[i][j]+ba[i][j]==1)bans++;\n\t\t\t\tif(wa[i][j]+ba[i][j]==-1)wans++;\n\t\t\t}\n\t\tcout<<bans<<\" \"<<wans<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\nusing namespace std;\nint h,w;\nchar ch[60][60];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\n\nbool outside(int y,int x){\n\tif(x<0||x>=w)return true;\n\tif(y<0||y>=h)return true;\n\treturn false;\n}\n\nvoid paint(int y,int x,int color){\n\tif(ch[y][x]=='.')ch[y][x]=(color)?'w':'b';\n\telse if((ch[y][x]=='w'&&!color)||(ch[y][x]=='b'&&color))ch[y][x]='?';\n\trep(i,4){\n\t\tint nx=x+dx[i],ny=y+dy[i];\n\t\tif(outside(ny,nx))continue;\n\t\tif(ch[ny][nx]=='W'||ch[ny][nx]=='B')continue;\n\t\tif(ch[ny][nx]=='w'&&color)continue;\n\t\tif(ch[ny][nx]=='b'&&!color)continue;\n\t\tif(ch[ny][nx]=='?')continue;\n\t\tpaint(ny,nx,color);\n\t}\n}\n\nint main(){\n\twhile(cin>>w>>h,w||h){\n\t\trep(i,h)rep(j,w)cin>>ch[i][j];\n\t\trep(i,h)rep(j,w){\n\t\t\tif(ch[i][j]=='W')paint(i,j,1);\n\t\t\telse if(ch[i][j]=='B')paint(i,j,0);\n\t\t}\n\t\tint nb=0,nw=0;\n\t\trep(i,h){\n\t\t\trep(j,w){\n\t\t\t\tif(ch[i][j]=='w')nw++;\n\t\t\t\tif(ch[i][j]=='b')nb++;\n\t\t\t}\n\t\t}\n\t\tcout<<nb<<\" \"<<nw<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define ALL(v) (v).begin(),(v).end()\n#define int long long\ntypedef pair<int,int> P;\n\n//-----------------------------------------------------------------------\n\nint dy[]={-1,0,1,0};\nint dx[]={0,-1,0,1};\nint w,h;\nchar M[55][55];\n\nvoid dfs(int y,int x,bool f){\n    REP(i,4){\n\tint ny=y+dy[i],nx=x+dx[i];\n\tif(0<=ny && ny<h && 0<=nx && nx<w){\n\t    if(f && M[ny][nx]=='.') M[ny][nx]='b',dfs(ny,nx,true);\n\t    if(!f&& M[ny][nx]=='.') M[ny][nx]='w',dfs(ny,nx,false);\n\t    if(!f&& M[ny][nx]=='b') M[ny][nx]='x',dfs(ny,nx,false);\n\t}\n    }\n}\n\nsigned main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while(cin>>w>>h,w)\n    {\n\tREP(i,h) REP(j,w) cin>>M[i][j];\n\tREP(i,h) REP(j,w){\n\t    if(M[i][j]=='B') dfs(i,j,true);\n\t}\n\tREP(i,h) REP(j,w){\n\t    if(M[i][j]=='W') dfs(i,j,false);\n\t}\n\tint c1=0,c2=0;\n\tREP(i,h){\n\t    REP(j,w){   \n\t\tif(M[i][j]=='b') c1++;\n\t\tif(M[i][j]=='w') c2++;\n\t    }\n\t}\n\tcout<<c1<<\" \"<<c2<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\ntypedef vector<string> vstring;\ntypedef vector<pint> vpint;\n\nstruct Edge{int to,from,cost;};\n\n#ifdef DEBUG\n#define debug cout\n#else\nstringstream __ss__;\n#define debug __ss__\n#endif\n\ntemplate<class T> void pv(T a, T b) { for (T i = a; i != b; ++i) debug << *i << \" \"; debug << endl; }\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define repd(i,n) for(int i=(n)-1;i>=0;i--)\n#define repn(i,m,n) for(int i=(m);i<=(n);++i)\n#define repnd(i,m,n) for(int i=(n)-1;i>=(m);i--)\n#define rep0(i,n) for(i=0;i<(n);++i)\n#define all(n) n.begin(),n.end()\n#define sz(n) ((int)(n).size())\n#define IL for(;;)\n#define MP make_pair\n#define PB push_back\n#define SS stringstream\n#define X second\n#define Y first\n#define PUTLINE debug<<\"LINE:\"<<__LINE__<<endl;\n\nconst int INF = 2147483647/3;\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\nconst int dx[]={1,-1,0,0,1,-1,1,-1,0};\nconst int dy[]={0,0,1,-1,1,-1,-1,1,0};\n\nstring fld1[60];\nstring fld2[60];\nint h,w;\n\nbool inside(int x,int y){\n\treturn 0<=x&&x<w&&0<=y&&y<h;\n}\n\nvoid f2(int x,int y){\n\tfld2[y][x]=' ';\n\trep(i,4){\n\t\tif(inside(x+dx[i],y+dy[i])&&fld2[y+dy[i]][x+dx[i]]=='.')f2(x+dx[i],y+dy[i]);\n\t}\n}\n\nvoid f1(int x,int y){\n\tfld1[y][x]=' ';\n\trep(i,4){\n\t\tif(inside(x+dx[i],y+dy[i])&&fld1[y+dy[i]][x+dx[i]]=='.')f1(x+dx[i],y+dy[i]);\n\t}\n}\n\nint main() {\n\tIL{\n\t\tcin>>w>>h;\n\t\tif(h==0&&w==0)break;\n\t\trep(i,h)cin>>fld1[i];\n\t\trep(i,h)fld2[i]=fld1[i];\n\t\trep(i,h)rep(j,w)if(fld1[i][j]=='W')f1(j,i);\n\t\trep(i,h)rep(j,w)if(fld2[i][j]=='B')f2(j,i);\n\t\tint res1=0,res2=0;\n\t\trep(i,h)rep(j,w)if(fld1[i][j]=='.')++res1;\n\t\trep(i,h)rep(j,w)if(fld2[i][j]=='.')++res2;\n\t\tbool ok1=false,ok2=false;\n\t\trep(i,h)rep(j,w)if(fld1[i][j]=='B')ok1=true;\n\t\trep(i,h)rep(j,w)if(fld2[i][j]=='W')ok2=true;\n\t\tcout<<(ok1?res1:0)<<\" \"<<(ok2?res2:0)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nstruct UnionFind {\n    vector<int> par;\n    vector<int> rank;\n    vector<ll> Size;\n    UnionFind(int n = 1) {\n        init(n);\n    }\n\n    void init(int n = 1) {\n        par.resize(n + 1); rank.resize(n + 1); Size.resize(n + 1);\n        for (int i = 0; i <= n; ++i) par[i] = i, rank[i] = 0, Size[i] = 1;\n    }\n\n    int root(int x) {\n        if (par[x] == x) {\n            return x;\n        }\n        else {\n            int r = root(par[x]);\n            return par[x] = r;\n        }\n    }\n\n    bool issame(int x, int y) {\n        return root(x) == root(y);\n    }\n\n    bool merge(int x, int y) {\n        x = root(x); y = root(y);\n        if (x == y) return false;\n        if (rank[x] < rank[y]) swap(x, y);\n        if (rank[x] == rank[y]) ++rank[x];\n        par[y] = x;\n        Size[x] += Size[y];\n        return true;\n    }\n\n    ll size(int x){\n        return Size[root(x)];\n    }\n};\n\n\nstring S[55];\nint field[55][55];\nint dh[4] = {-1, 1, 0, 0};\nint dw[4] = {0, 0, 1, -1};\nint H, W;\nvoid dfs(int nowh, int noww, int bit) {\n    for(int k = 0; k < 4; k++) {\n        int newh = nowh + dh[k];\n        int neww = noww + dw[k];\n        if(newh < 1 || newh > H || neww < 1 || neww > W) continue;\n        if(field[newh][neww] < 0) continue;\n        if(field[newh][neww] & (1 << bit)) continue;\n        field[newh][neww] |= (1 << bit);\n        dfs(newh, neww, bit);\n    }\n}\n\nint main() {\n    //cout.precision(10);\n    while(true) {\n        cin >> W >> H;\n        if(H == 0) break;\n        //cerr << H << \" \" << W << endl;\n        for(int h = 1; h <= H; h++) {\n            cin >> S[h];\n            S[h] = \"#\" + S[h];\n            for(int w = 1; w <= W; w++) {\n                if(S[h][w] == '.') field[h][w] = 0;\n                if(S[h][w] == 'B') field[h][w] = -1;\n                if(S[h][w] == 'W') field[h][w] = -2;\n            }\n        }\n        for(int h = 1; h <= H; h++) {\n            for(int w = 1; w <= W; w++) {\n                if(S[h][w] == 'B') dfs(h, w, 0);\n                if(S[h][w] == 'W') dfs(h, w, 1);\n            }\n        }\n        int ansb = 0;\n        int answ = 0;\n        for(int h = 1; h <= H; h++) {\n            for(int w = 1; w <= W; w++) {\n                if(field[h][w] == 1) ansb++;\n                if(field[h][w] == 2) answ++;\n            }\n        }\n        cout << ansb << \" \" << answ << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <cmath>\n#include <algorithm>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <vector>\n#include <string>\n#define REP(i,n) for(int i=0;i<n;i++)\ntypedef long long ll;\nusing namespace std;\ntypedef vector<ll> vl;\ntypedef pair<ll,ll> pll;\ntypedef vector<pll> vpll;\ntypedef vector<string> vs;\n\nint X[4]={0,0,-1,1};\nint Y[4]={-1,1,0,0};\nint w,h;\nint ans[50][50];\nint bl[50][50];\nint wh[50][50];\n\nvoid black(int x,int y){\n\tbl[x][y]=1;\n\tfor(int i=0;i<4;i++){\n\t\tif(x+X[i]>-1&&x+X[i]<w&&y+Y[i]>-1&&y+Y[i]<h){\n\t\t\tif(ans[x+X[i]][y+Y[i]]==0&&bl[x+X[i]][y+Y[i]]==0){black(x+X[i],y+Y[i]);}\n\t\t}\n\t}\n}\n\nint a(0);\n\nvoid white(int x,int y){\n\twh[x][y]=1;\n\tfor(int i=0;i<4;i++){\n\t\tif(x+X[i]>-1&&x+X[i]<w&&y+Y[i]>-1&&y+Y[i]<h){\n\t\t\tif(ans[x+X[i]][y+Y[i]]==0&&wh[x+X[i]][y+Y[i]]==0){white(x+X[i],y+Y[i]);}\n\t\t}\n\t}\n}\n\n\nint main() \n{\n\twhile(cin>>w>>h&&!(w==0&&h==0)){\n\t\tREP(i,51){REP(j,51){ans[j][i]=0;bl[j][i]=0;wh[j][i]=0;}}\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tchar tmp;\n\t\t\t\tcin>>tmp;\n\t\t\t\tswitch(tmp){\n\t\t\t\t  case 'B':ans[j][i]=1;break;\n\t\t\t\t  case 'W':ans[j][i]=2;break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tint tmp1(false),tmp2(false);\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tif(j+X[k]>-1&&j+X[k]<w&&i+Y[k]>-1&&i+Y[k]<h){\n\t\t\t\t\t\tif(ans[j+X[k]][i+Y[k]]==1){tmp1=true;}\n\t\t\t\t\t\tif(ans[j+X[k]][i+Y[k]]==2){tmp2=true;}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(tmp1&&bl[j][i]!=1&&ans[j][i]==0){black(j,i);}\n\t\t\t\tif(tmp2&&wh[j][i]!=1&&ans[j][i]==0){white(j,i);}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans1(0),ans2(0);\n\t\tREP(i,h){REP(j,w){\n\t\t\t\tif(bl[j][i]+wh[j][i]==2){;}\n\t\t\t\telse if(wh[j][i]==1){ans2++;}\n\t\t\t\telse if(bl[j][i]==1){ans1++;}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout<<ans1<<\"  \"<<ans2<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define loop(n, i) for(int i=0;i<n;i++)\n#define all(v) v.begin(),v.end()\n#define HERE cout << \"HERE: \" << __LINE__ << endl;\n#define INSP(v) cout << v << \" at \" << __LINE__ << endl;\n\nusing namespace std;\ntypedef long long ll;\n\nint f[50][50];\n\nint dfs(vector<vector<int>> &m, int h, int w, vector<vector<char>> as, int t) {\n    if (h < 0 || w < 0 || h >= m.size() || w >= m[h].size()) {\n        return 0;\n    }\n    if (as[h][w] == 'B') return 1;\n    if (as[h][w] == 'W') return 2;\n    if (f[h][w]) return t;\n    f[h][w] = 1;\n    t |= m[h][w];\n    t |= dfs(m, h-1, w, as, t);\n    t |= dfs(m, h+1, w, as, t);\n    t |= dfs(m, h, w+1, as, t);\n    t |= dfs(m, h, w-1, as, t);\n    m[h][w] = t;\n    return t;\n}\n\nint main()\n{\n    int w, h;\n    while (cin >> w >> h, w) {\n        loop(50,i) loop(50,j) f[i][j] = 0;\n        vector<vector<char>> as;\n        as.resize(h);\n        loop(h,i) {\n            string s;\n            cin >> s;\n            for (char c:s) as[i].push_back(c);\n        }\n\n        vector<vector<int>> mat(h, vector<int>(w,0));\n        loop(h,i){\n            loop(w,j){\n                if (as[i][j] == '.') {\n                    dfs(mat, i, j, as, 0);\n                }\n            }\n        }\n\n        int ans_w = 0, ans_b = 0;\n        for(auto mm:mat) {\n            for (auto m:mm) {\n                if (m == 1) ans_b++;\n                if (m == 2) ans_w++;\n            }\n        }\n        cout << ans_b << ' ' << ans_w << endl;\n\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cctype>\n#include <limits.h>\n#include <math.h>\n#include <complex>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) static_cast<bitset<16> >(x)\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n\nconst int INF = 1e9;\nconst double EPS = 1e-8;\nconst double PI = 3.14159;\nint dx[4]={0, 1, 0, -1}, dy[4]={-1, 0, 1, 0};\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n/* struct P {\n\tint x, y, n;\n\tP(int n, int x, int y):n(n), x(x), y(y){}\n\tP(){}\n}; */\n\n/** Problem2014 : Surrounding Area **/\nint main()\n{\n\tint W, H;\n\twhile (cin>>W>>H, W) {\n\t\tchar field[W][H];\n\t\trep(i, H) {\n\t\t\trep(j, W) {\n\t\t\t\tcin>>field[j][i];\n\t\t\t}\n\t\t}\n\t\t\n\t\tstring C = \"BW\";\n\t\tint ans[2]={0};\n\t\t// color\n\t\trep(c, 2) {\n\t\t\trep(y, H) {\n\t\t\t\trep(x, W) {\n\t\t\t\t\tif (field[x][y] != '.') continue;\n\t\t\t\t\t\n\t\t\t\t\tint tmp[2]={0};\n\t\t\t\t\tqueue<P> Q;\n\t\t\t\t\tbool vis[W][H];\n\t\t\t\t\tmemset(vis, 0, sizeof(vis));\n\t\t\t\t\t\n\t\t\t\t\tvis[x][y] = true;\n\t\t\t\t\tQ.push(P(x, y));\n\t\t\t\t\t\n\t\t\t\t\twhile (Q.size()) {\n\t\t\t\t\t\tP p = Q.front(); Q.pop();\n\t\t\t\t\t\tif (field[p.first][p.second] != '.') {\n\t\t\t\t\t\t\tif (field[p.first][p.second] == 'B') tmp[0]++;\n\t\t\t\t\t\t\telse\t\t\t\t\t\t\t\t tmp[1]++;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\trep(d, 4) {\n\t\t\t\t\t\t\tint nx = p.first+dx[d], ny = p.second+dy[d];\n\t\t\t\t\t\t\tif_range(nx, ny, W, H) {\n\t\t\t\t\t\t\t\tif (!vis[nx][ny]) {\n\t\t\t\t\t\t\t\t\tQ.push(P(nx, ny));\n\t\t\t\t\t\t\t\t\tvis[nx][ny] = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (tmp[c]>0 && tmp[1-c]==0) ans[c]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << ans[0] << \" \" << ans[1] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\n#include<bitset>\n#include<stack>\n#include<memory>\nusing namespace std;\nusing namespace std::chrono;\ntypedef long long int llint;\ntypedef double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n/*cout<<fixed<<setprecision(20);cin.tie(0);ios::sync_with_stdio(false);*/\nconst llint mod=1000000007;\nconst llint big=2.19e15+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-15;\ntemplate <class T,class U>bool mineq(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool maxeq(T& a,U b){if(a<b){a=b;return true;}return false;}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){if(a==0){return b;}return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>llint LBI(vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>llint UBI(vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\n\nbool solve(void){\n\tint i,j,w,h;cin>>w>>h;\n\tif(w*h==0){return false;}\n\tvector<string>mat(h);\n\tfor(i=0;i<h;i++){cin>>mat[i];}\n\tqueue<tuple<int,int,char>>que;\n\tstatic int mita[100][100];\n\tfor(i=0;i<h;i++){\n\t\tfor(j=0;j<w;j++){\n\t\t\tmita[i][j]=0;\n\t\t\tif(mat[i][j]=='W'){que.push(mt(i,j,'w'));}\n\t\t\tif(mat[i][j]=='B'){que.push(mt(i,j,'b'));}\n\t\t}\n\t}\n\twhile(que.size()){\n\t\tint y,x;char c;\n\t\ttie(y,x,c)=que.front();que.pop();\n\t\tif(x<0||y<0||x>w||y>h){continue;}\n\t\tif(c=='w'){\n\t\t\tif(mita[y][x]%2){continue;}\n\t\t\tmita[y][x]+=1;\n\t\t\tif(mat[y][x]=='W'){}\n\t\t\telse if(mat[y][x]=='.'){mat[y][x]='w';}\n\t\t\telse if(mat[y][x]=='b'){mat[y][x]='r';}\n\t\t\telse{continue;}\n\t\t}else{\n\t\t\tif(mita[y][x]/2){continue;}\n\t\t\tmita[y][x]+=2;\n\t\t\tif(mat[y][x]=='B'){}\n\t\t\telse if(mat[y][x]=='.'){mat[y][x]='b';}\n\t\t\telse if(mat[y][x]=='w'){mat[y][x]='r';}\n\t\t\telse{continue;}\n\t\t}\n\t\t\n\t\t\n\t\tif(c=='w'){\n\t\t\tif(y>0&&(mat[y-1][x]=='.'||mat[y-1][x]=='b'||mat[y-1][x]=='r')){que.push(mt(y-1,x,'w'));}\n\t\t\tif(x>0&&(mat[y][x-1]=='.'||mat[y][x-1]=='b'||mat[y][x-1]=='r')){que.push(mt(y,x-1,'w'));}\n\t\t\tif(y<h-1&&(mat[y+1][x]=='.'||mat[y+1][x]=='b'||mat[y+1][x]=='r')){que.push(mt(y+1,x,'w'));}\n\t\t\tif(x<w-1&&(mat[y][x+1]=='.'||mat[y][x+1]=='b'||mat[y][x+1]=='r')){que.push(mt(y,x+1,'w'));}\n\t\t}else{\n\t\t\tif(y>0&&(mat[y-1][x]=='.'||mat[y-1][x]=='w'||mat[y-1][x]=='r')){que.push(mt(y-1,x,'b'));}\n\t\t\tif(x>0&&(mat[y][x-1]=='.'||mat[y][x-1]=='w'||mat[y][x-1]=='r')){que.push(mt(y,x-1,'b'));}\n\t\t\tif(y<h-1&&(mat[y+1][x]=='.'||mat[y+1][x]=='w'||mat[y+1][x]=='r')){que.push(mt(y+1,x,'b'));}\n\t\t\tif(x<w-1&&(mat[y][x+1]=='.'||mat[y][x+1]=='w'||mat[y][x+1]=='r')){que.push(mt(y,x+1,'b'));}\n\t\t}\n\t}\n\tint ansW=0,ansB=0;\n\tfor(i=0;i<h;i++){\n\t\tfor(j=0;j<w;j++){\n\t\t\t//cerr<<mat[i][j];\n\t\t\tmita[i][j]=0;\n\t\t\tif(mat[i][j]=='w'){ansW++;}\n\t\t\tif(mat[i][j]=='b'){ansB++;}\n\t\t}\n\t\t//cerr<<endl;\n\t}\n\tcout<<ansB<<\" \"<<ansW<<endl;\n\treturn true;\n}\nint main(void){\n\tcin.tie(0);ios::sync_with_stdio(false);\n\twhile(solve()){}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <cmath>\n#include <algorithm>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <vector>\n#include <string>\n#define REP(i,n) for(int i=0;i<n;i++)\ntypedef long long ll;\nusing namespace std;\ntypedef vector<ll> vl;\ntypedef pair<ll,ll> pll;\ntypedef vector<pll> vpll;\ntypedef vector<string> vs;\n\nint X[4]={0,0,-1,1};\nint Y[4]={-1,1,0,0};\nint w,h;\nint ans[50][50];\nint bl[50][50];\nint wh[50][50];\n\nvoid black(int x,int y){\n\tbl[x][y]=1;\n\tfor(int i=0;i<4;i++){\n\t\tif(x+X[i]>-1&&x+X[i]<w&&y+Y[i]>-1&&y+Y[i]<h){\n\t\t\tif(ans[x+X[i]][y+Y[i]]==0&&bl[x+X[i]][y+Y[i]]==0){black(x+X[i],y+Y[i]);}\n\t\t}\n\t}\n}\n\nvoid white(int x,int y){\n\twh[x][y]=1;\n\tfor(int i=0;i<4;i++){\n\t\tif(x+X[i]>-1&&x+X[i]<w&&y+Y[i]>-1&&y+Y[i]<h){\n\t\t\tif(ans[x+X[i]][y+Y[i]]==0&&wh[x+X[i]][y+Y[i]]==0){white(x+X[i],y+Y[i]);}\n\t\t}\n\t}\n}\n\n\nint main() \n{\n\twhile(cin>>w>>h&&!(w==0&&h==0)){\n\t\tREP(i,50){REP(j,50){ans[j][i]=0;bl[j][i]=0;wh[j][i]=0;}}\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tchar tmp;\n\t\t\t\tcin>>tmp;\n\t\t\t\tswitch(tmp){\n\t\t\t\t  case 'B':ans[j][i]=1;break;\n\t\t\t\t  case 'W':ans[j][i]=2;break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tint tmp1(false),tmp2(false);\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tif(j+X[k]>-1&&j+X[k]<w&&i+Y[k]>-1&&i+Y[k]<h){\n\t\t\t\t\t\tif(ans[j+X[k]][i+Y[k]]==1){tmp1=true;}\n\t\t\t\t\t\tif(ans[j+X[k]][i+Y[k]]==2){tmp2=true;}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(tmp1&&bl[j][i]!=1&&ans[j][i]==0){black(j,i);}\n\t\t\t\tif(tmp2&&wh[j][i]!=1&&ans[j][i]==0){white(j,i);}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans1(0),ans2(0);\n\t\tREP(i,h){REP(j,w){\n\t\t\t\tif(bl[j][i]+wh[j][i]==2){;}\n\t\t\t\telse if(wh[j][i]==1){ans2++;}\n\t\t\t\telse if(bl[j][i]==1){ans1++;}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout<<ans1<<\" \"<<ans2<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nconst int dx[] = {1,-1,0,0};\nconst int dy[] = {0,0,-1,1};\nint w,h;\nchar data[50][50];\nstruct P{int x,y,d;};\nint correct(int x,int y){\n\treturn x >= 0 && y >= 0 && x < w && y < h;\n}\n\nint solve(int x,int y){\n\tqueue<P> Q;\n\tbool done[50][50] = {0};\n\tint chk = 0;\n\tP t = {x,y,0};\n\tQ.push(t);\n\twhile(Q.size()){\n\t\tP q = Q.front(); Q.pop();\n\t\tif(done[q.y][q.x])continue;\n\t\telse done[q.y][q.x] = true;\n\t\t\n\t\tif(data[q.y][q.x] != '.'){\n\t\t\tif(data[q.y][q.x] == 'B') chk |= 1;\n\t\t\telse chk |= 2;\n\t\t\tcontinue;\n\t\t}\n\t\trep(i,4){\n\t\t\tP nxt = {q.x+dx[i] , q.y+dy[i], q.d+1};\n\t\t\tif(correct(nxt.x,nxt.y))Q.push(nxt);\n\t\t}\n\t}\n\tif(chk == 1)return 0;\n\telse if(chk == 2)return 1;\n\telse return 2;\n}\nint main(){\n\twhile(cin >> w >> h , w ){\n\t\tint ret[3] = {0};\n\t\trep(i,h)rep(j,w)cin >> data[i][j];\n\t\trep(i,h)rep(j,w)\n\t\t\tif(data[i][j] == '.')ret[solve(j,i)]++;\n\t\t\n\t\tcout << ret[0] << \" \" << ret[1] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\nint w,h;\nvector<string> ss;\nbool write[52][52];\nbool black[52][52];\n\nvoid dfs(int x_,int y_,bool (*f_)[52],bool f2) {\n    //cout<<x_<<\",\"<<y_<<endl;\n    if(f_[x_][y_]||(ss[x_][y_]!='.'&&f2)) return;\n    f_[x_][y_]=true;\n    rep(i,4) {\n        int x = x_ + dx[i];\n        int y = y_ + dy[i];\n        if(0<=x&&x<ss.size() && 0<=y&&y<ss[x].size()) {\n            dfs(x,y,f_,true);\n        }\n    }\n}\n\nvoid solve() {\n    rep(i,52) rep(j,52) write[i][j]=black[i][j]=false;\n    ss.resize(w);\n    rep(i,h) {\n        string t; cin>>t;\n        ss[i] = t;\n    }\n    int ans_b=0,ans_w=0;\n    rep(i,ss.size()) {\n        rep(j,ss[i].size()) {\n            if(ss[i][j]=='B') dfs(i,j,black,false);\n            if(ss[i][j]=='W') dfs(i,j,write,false);\n        }\n    }\n    rep(i,ss.size()) rep(j,ss[i].size()) {\n        //cout<<i<<\",\"<<j<<\":\"<<write[i][j]<<\",\"<<black[i][j]<<ss[i][j]<<endl;\n        if(ss[i][j]=='.'&&(write[i][j]^black[i][j])) {\n           if(write[i][j]) ans_w++;\n           else ans_b++; \n        }\n    }\n    cout<<ans_b<<\" \"<<ans_w<<endl;\n    ss.clear();\n}\n\nint main() {\n    while(cin>>w>>h) {\n        if(w+h==0) return 0;\n        solve();\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\nbool white[50][50],black[50][50],fre[50][50];\nint main(){\n\tint w,h;\n\tchar z;\n\twhile(true){\n\tcin>>w>>h;\n\tif(w==0&&h==0)\n\t\tbreak;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\twhite[i][j]=false;\n\t\t\tblack[i][j]=false;\n\t\t\tfre[i][j]=true;\n\t\t}\n\t}\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tcin>>z;\n\t\t\tif(z=='W'){\n\t\t\t\tfre[i][j]=false;\n\t\t\t\twhite[i][j]=true;\n\t\t\t}\n\t\t\tif(z=='B'){\n\t\t\t\tfre[i][j]=false;\n\t\t\t\tblack[i][j]=true;\n\t\t\t}\n\t\t}\n\t}\n\tint dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\twhile(true){\n\t\tbool cha=false;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(fre[i][j]==true){\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tif(i+dy[k]>=0&&i+dy[k]<h&&j+dx[k]>=0&&j+dx[k]<w){\n\t\t\t\t\t\tif(white[i+dy[k]][j+dx[k]]==true){\n\t\t\t\t\t\t\tif(white[i][j]==false)\n\t\t\t\t\t\t\t\tcha=true;\n\t\t\t\t\t\t\twhite[i][j]=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(black[i+dy[k]][j+dx[k]]==true){\n\t\t\t\t\t\t\tif(black[i][j]==false)\n\t\t\t\t\t\t\t\tcha=true;\n\t\t\t\t\t\t\tblack[i][j]=true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(cha==false)\n\t\t\tbreak;\n\t}\n\tint wans=0,bans=0;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(fre[i][j]==true){\n\t\t\t\tif(white[i][j]==true)\n\t\t\t\t\twans++;\n\t\t\t\tif(black[i][j]==true)\n\t\t\t\t\tbans++;\n\t\t\t\tif(white[i][j]==true&&black[i][j]==true)\n\t\t\t\t\twans--,bans--;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<bans<<\" \"<<wans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define loop(n, i) for(int i=0;i<n;i++)\n#define all(v) v.begin(),v.end()\n#define HERE cout << \"HERE: \" << __LINE__ << endl;\n#define INSP(v) cout << v << \" at \" << __LINE__ << endl;\n\nusing namespace std;\ntypedef long long ll;\n\nint f[50][50];\n\nint dfs(vector<vector<int>> &m, int h, int w, vector<vector<char>> as, int t) {\n    if (h < 0 || w < 0 || h >= m.size() || w >= m[h].size()) {\n        return 0;\n    }\n    if (as[h][w] == 'B') return 1;\n    if (as[h][w] == 'W') return 2;\n    if (f[h][w]) return t;\n    f[h][w] = 1;\n    t |= m[h][w];\n    t |= dfs(m, h-1, w, as, t);\n    t |= dfs(m, h+1, w, as, t);\n    t |= dfs(m, h, w+1, as, t);\n    t |= dfs(m, h, w-1, as, t);\n    m[h][w] = t;\n    return t;\n}\n\nint main()\n{\n    int w, h;\n    while (cin >> w >> h, w) {\n        loop(50,i) loop(50,j) f[i][j] = 0;\n        vector<vector<char>> as;\n        as.resize(h);\n        loop(h,i) {\n            string s;\n            cin >> s;\n            for (char c:s) as[i].push_back(c);\n        }\n\n        vector<vector<int>> mat(h, vector<int>(w,0));\n        loop(h,i){\n            loop(w,j){\n                if (as[i][j] == '.') {\n                    dfs(mat, i, j, as, 0);\n                }\n            }\n        }\n        // ?\n        loop(50,i) loop(50,j) f[i][j] = 0;\n        loop(h,i){\n            loop(w,j){\n                if (as[i][j] == '.') {\n                    dfs(mat, i, j, as, 0);\n                }\n            }\n        }\n\n        int ans_w = 0, ans_b = 0;\n        for(auto mm:mat) {\n            for (auto m:mm) {\n                if (m == 1) ans_b++;\n                if (m == 2) ans_w++;\n            }\n        }\n        cout << ans_b << ' ' << ans_w << endl;\n\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\nusing namespace std;\ntypedef pair<int,int> P;\nint W,H;\nint visited[51][51] = {};\nchar A[51][51];\n\nint dx[4] = {-1,1,0,0},dy[4] = {0,0,-1,1};\n\nbool in(int x,int y){\n    return 1<=x && x<=H && 1<=y && y<=W;\n}\n\nvoid init(){\n    for(int i=1;i<=H;i++) for(int j=1;j<=W;j++) visited[i][j] = 0;\n}\n\nint main(){\n    while(cin >> W >> H && W>0){\n        for(int i=1;i<=H;i++) for(int j=1;j<=W;j++) cin >> A[i][j];\n        int black = 0,white = 0;\n        for(int i=1;i<=H;i++){\n            for(int j=1;j<=W;j++){\n                if(A[i][j]!='.') continue;\n                init();\n                visited[i][j] = 1;\n                queue<P> Q;\n                Q.push({i,j});\n                bool b = false,w = false;\n                while(!Q.empty()){\n                    int x = Q.front().first,y = Q.front().second;\n                    Q.pop();\n                    for(int i=0;i<4;i++){\n                        int nx = x+dx[i],ny = y+dy[i];\n                        if(!in(nx,ny)) continue;\n                        if(visited[nx][ny]==1) continue;\n                        if(A[nx][ny]=='W') w = true;\n                        if(A[nx][ny]=='B') b = true;\n                        if(A[nx][ny]=='.'){\n                            visited[nx][ny] = 1;\n                            Q.push({nx,ny});\n                        }\n                    }\n                }\n                if(b&&!w) black++;\n                if(!b&&w) white++;\n            }\n        }\n        cout << black << \" \" << white << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\nint dx[4] = {-1, 0, 1, 0};\nint dy[4] = {0, 1, 0, -1};\nchar field[51][51];\nint w, h;\nbool b_flag;\nbool w_flag;\nint count;\n\nvoid dfs1(int y, int x)\n{\n\tif(y < 0 || h <= y || x < 0 || w <= x || field[y][x] == '#')\n\t{\n\t\treturn;\n\t}\n\telse\n\t{\n\t\tif(field[y][x] == 'W')\n\t\t{\n\t\t\tw_flag = true;\n\t\t\treturn;\n\t\t}\n\t\telse if(field[y][x] == 'B')\n\t\t{\n\t\t\tb_flag = true;\n\t\t\treturn;\n\t\t}\n\t\telse if(field[y][x] == '.')\n\t\t{\n\t\t\tfield[y][x] = '#';\n\t\t\t++count;\n\t\t}\n\t}\n\tfor(int i = 0; i < 4; ++i)\n\t{\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\t\tdfs1(ny, nx);\n\t}\n}\n\nvoid solve()\n{\n\twhile(cin >> w >> h, w || h)\n\t{\n\t\tfor(int i = 0; i < h; ++i)\n\t\t{\n\t\t\tfor(int j = 0; j < w; ++j)\n\t\t\t{\n\t\t\t\tcin >> field[i][j];\n\t\t\t}\n\t\t}\n\t\tint b_count = 0, w_count = 0;\n\t\tfor(int i = 0; i < h; ++i)\n\t\t{\n\t\t\tfor(int j = 0; j < w; ++j)\n\t\t\t{\n\t\t\t\tif(field[i][j] == '.')\n\t\t\t\t{\n\t\t\t\t\tcount = 0;\n\t\t\t\t\tb_flag = false;\n\t\t\t\t\tw_flag = false;\n\t\t\t\t\tdfs1(i, j);\n\t\t\t\t\tif(b_flag == true && w_flag == false)\n\t\t\t\t\t{\n\t\t\t\t\t\tb_count += count;\n\t\t\t\t\t}\n\t\t\t\t\telse if(b_flag == false && w_flag == true)\n\t\t\t\t\t{\n\t\t\t\t\t\tw_count += count;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << b_count << \" \" << w_count << endl;\n\t}\n}\n\nint main()\n{\n\tsolve();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint h, w;\n\nchar maze[51][51];\nint bm[51][51];\nint wm[51][51];\n\nint dx[4] = {0, 0, 1, -1};\nint dy[4] = {1, -1, 0, 0};\n\nvoid dfsB(int y, int x){\n\tfor(int i = 0; i < 4; i++){\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\t\tif(0 <= nx and nx < w and 0 <= ny and ny < h and bm[ny][nx] == 0 and maze[ny][nx] == '.'){\n\t\t\tbm[ny][nx] = 1;\n\t\t\tdfsB(ny, nx);\n\t\t}\n\t}\n\treturn;\n}\n\nvoid dfsW(int y, int x){\n\tfor(int i = 0; i < 4; i++){\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\t\tif(0 <= nx and nx < w and 0 <= ny and ny < h and wm[ny][nx] == 0 and maze[ny][nx] == '.'){\n\t\t\twm[ny][nx] = 1;\n\t\t\tdfsW(ny, nx);\n\t\t}\n\t}\n\treturn;\n}\n\n\nint main(){\nwhile(1){//start\n\n\t//init\n\tfor(int i = 0; i < 50; i++){\n\t\tfor(int j = 0; j < 50; j++){\n\t\t\tmaze[i][j] = 'a';\n\t\t\tbm[i][j] = 0;\n\t\t\twm[i][j] = 0;\n\t\t}\n\t}\n\n\n\n\t//int w, h;\n\tcin >> w >> h;\n\tif(w == 0 and h == 0) break;\n\tfor(int i = 0; i < h; i++){\n\t\tfor(int j = 0; j < w; j++) cin >> maze[i][j];\n\t}\n\n\t//debug\n\t/*\n\tfor(int i = 0; i < h; i++){\n\t\tfor(int j = 0; j < w; j++) cout << maze[i][j] << \" \";\n\t\tcout << endl;\n\t}\n*/\n\tfor(int i = 0; i < h; i++){\n\t\tfor(int j = 0; j < w; j++){\n\t\t\tif(maze[i][j] == 'W') dfsW(i, j);\n\t\t\tif(maze[i][j] == 'B') dfsB(i, j);\n\t\t}\n\t}\n\n/*\n\tfor(int i = 0; i < h; i++){\n\t\tfor(int j = 0; j < w; j++){\n\t\t\tif(maze[i][j] == 'B'){\n\t\t\t\tif(i - 1 >= 0) wm[i - 1][j] = 0;\n\t\t\t\tif(i + 1 < 50) wm[i + 1][j] = 0;\n\t\t\t\tif(j - 1 >= 0) wm[i][j - 1] = 0;\n\t\t\t\tif(j + 1 < 50) wm[i][j + 1] = 0;\n\t\t\t}\n\t\t\tif(maze[i][j] == 'W'){\n\t\t\t\tif(i - 1 >= 0) bm[i - 1][j] = 0;\n\t\t\t\tif(i + 1 < 50) bm[i + 1][j] = 0;\n\t\t\t\tif(j - 1 >= 0) bm[i][j - 1] = 0;\n\t\t\t\tif(j + 1 < 50) bm[i][j + 1] = 0;\n\t\t\t}\n\t\t}\n\t}\n*/\n\tint ansb = 0;\n\tint answ = 0;\n\tfor(int i = 0; i < h; i++){\n\t\tfor(int j = 0; j < w; j++){\n\t\t\tif(wm[i][j] == 0 and bm[i][j] == 1) ansb += 1;\n\t\t\tif(bm[i][j] == 0 and wm[i][j] == 1) answ += 1;\n\t\t}\n\t}\n\n\t/*\n\tfor(int i = 0; i < h; i++){\n\t\tfor(int j = 0; j < w; j++){\n\t\t\tansb += bm[i][j];\n\t\t\tansw += wm[i][j];\n\t\t}\n\t}\n*/\n\tcout << ansb << \" \" << answ << endl;\n}//end\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nbool in_range(int a, int b){\n  return a >= 0 && a < b;\n}\n\nint main(){\n  int w, h;\n  while(cin >> w >> h, w){\n    vector<string> A(h);\n    for(int i = 0; i < h; ++i) cin >> A[i];\n    queue<pair<int,int>> QB, QW;\n    for(int i = 0; i < h; ++i){\n      for(int j = 0; j < w; ++j){\n        if(A[i][j] == 'W') QW.emplace(i,j);\n        if(A[i][j] == 'B') QB.emplace(i,j);\n      }\n    }\n    vector<vector<bool>> B(h,vector<bool>(w,false)), W(h,vector<bool>(w,false));\n    int dx[] = {1,0,-1,0}, dy[] = {0,1,0,-1};\n    while(not QB.empty()){\n      int x = QB.front().first, y = QB.front().second;\n      QB.pop();\n      for(int j = 0; j < 4; ++j){\n        int x_ = x + dx[j], y_ = y + dy[j];\n        if((not in_range(x_,h)) or (not in_range(y_,w))) continue;\n        if(A[x_][y_] != '.') continue;\n        if(not B[x_][y_]){\n          B[x_][y_] = true;\n          QB.emplace(x_,y_);\n        }\n      }\n    }\n    while(not QW.empty()){\n      int x = QW.front().first, y = QW.front().second;\n      QW.pop();\n      for(int j = 0; j < 4; ++j){\n        int x_ = x + dx[j], y_ = y + dy[j];\n        if((not in_range(x_,h)) or (not in_range(y_,w))) continue;\n        if(A[x_][y_] != '.') continue;\n        if(not W[x_][y_]){\n          W[x_][y_] = true;\n          QW.emplace(x_,y_);\n        }\n      }\n    }\n    int bl = 0, wh = 0;\n    for(int i = 0; i < h; ++i){\n      for(int j = 0; j < w; ++j){\n        if(B[i][j] == W[i][j]) continue;\n        if(B[i][j]) ++bl;\n        if(W[i][j]) ++wh;\n      }\n    }\n    cout << bl << \" \" << wh << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint jud=2,ans=0;\nint grid[52][52]={0};\nvoid search(int w, int h)\n{\n  if(grid[w][h]==2){\n    ans++; grid[w][h]=0;\n    if(grid[w][h-1]) search(w,h-1);\n    if(grid[w-1][h]) search(w-1,h);\n    if(grid[w][h+1]) search(w,h+1);\n    if(grid[w+1][h]) search(w+1,h);\n  } else if(grid[w][h]==1){\n    if(jud==2) jud=1;\n    else if(jud==-1){\n      jud=0;\n    }\n  } else if(grid[w][h]==-1){\n    if(jud==2) jud=-1;\n    else if(jud==1){\n      jud=0;\n    }\n  }\n}\n\nint main()\n{\n  int w,h,i,j;\n  char c;\n\n  for(;;){\n    cin>>w>>h;\n    if(!(w|h)) break;\n\n    for(i=0;i<h+2;i++)\n      for(j=0;j<w+2;j++)\n\tgrid[j][i]=0;\n    for(i=1;i<h+1;i++)\n      for(j=1;j<w+1;j++){\n\tcin>>c;\n\tif(c=='.') grid[j][i]=2;\n\tif(c=='B') grid[j][i]=1;\n\tif(c=='W') grid[j][i]=-1;\n      }\n    int ansB=0,ansW=0;\n    for(i=1;i<h+1;i++)\n      for(j=1;j<w+1;j++){\n\tif(grid[j][i]==2){\n\t  search(j,i);\n\t  if(jud==1) ansB+=ans;\n\t  else if(jud==-1) ansW+=ans;\n\t}\n\tjud=2; ans=0;\n      }\n    cout<<ansB<<\" \"<<ansW<<endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\n#define stlice(from, to) substr(from, (to) - (from) + 1)\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\nusing namespace std;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\nusing vd = vector<double>;\nusing vc = vector<char>;\nusing vb = vector<bool>;\nusing vs = vector<string>;\nusing vpii = vector<pii>;\nusing vvi = vector<vi>;\nusing vvb = vector<vb>;\nusing vvpii = vector<vpii>;\ntemplate<typename A> using fn = function<A>;\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = acos(-1);\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nconstexpr bool odd(const int &n) { return n & 1; }\nconstexpr bool even(const int &n) { return !odd(n); }\nvoid solve();\nmain { solve(); return 0; }\n// clang-format on\n\nvoid solve() {\n  int W, H;\n  while (cin >> W >> H, W) {\n    vs v(H);\n    rep(i, H) cin >> v[i];\n    vvi dp(H, vi(W));\n    int b = 0, w = 0;\n    rep(i, H) rep(j, W) {\n      dp[i][j] = 2 * (v[i][j] == 'B') + (v[i][j] == 'W');\n      b -= v[i][j] == 'B';\n      w -= v[i][j] == 'W';\n    }\n    rep(_, W * H) rep(i, H) rep(j, W) {\n      if (v[i][j] != '.') continue;\n      if (i > 0) dp[i][j] |= dp[i - 1][j];\n      if (j > 0) dp[i][j] |= dp[i][j - 1];\n      if (i < H - 1) dp[i][j] |= dp[i + 1][j];\n      if (j < W - 1) dp[i][j] |= dp[i][j + 1];\n    }\n    rep(i, H) rep(j, W) {\n      b += dp[i][j] == 2;\n      w += dp[i][j] == 1;\n    }\n    cout << b << ' ' << w << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\nusing namespace std;\nusing p = pair<int, int>;\n\nint h, w, bl, wh;\nstring a[55];\nint d[] = {0, 1, 0, -1};\n\nvoid solve();\nbool ch(p now);\n\nint main() {\n  while(1) {\n    cin >> w >> h;\n    if(w + h == 0) break;\n    for(int i = 0; i < h; ++i) cin >> a[i];\n    solve();\n    cout << bl << \" \" << wh << endl;\n  }\n\n  return 0;\n}\n\nvoid solve() {\n  bl = wh = 0;\n  vector<vector<int>> v;\n  queue<p> qu[2];\n  v.resize(h);\n  for(int i = 0; i < h; ++i) v[i].assign(w, 0);\n  for(int i = 0; i < h; ++i)\n    for(int j = 0; j < w; ++j) {\n      if(a[i][j] == 'B') { qu[0].push({i, j}); }\n      if(a[i][j] == 'W') { qu[1].push({i, j}); }\n    }\n  for(int t = 0; t < 2; ++t) {\n    while(qu[t].size() > 0) {\n      p now = qu[t].front();\n      qu[t].pop();\n      for(int i = 0; i < 4; ++i) {\n        p nextp = now;\n        nextp.fi += d[i];\n        nextp.se += d[i ^ 1];\n        if(!ch(nextp)) continue;\n        if((v[nextp.fi][nextp.se] & (t + 1)) != (t + 1) &&\n           a[nextp.fi][nextp.se] == '.') {\n          v[nextp.fi][nextp.se] += (t + 1);\n          qu[t].push(nextp);\n        }\n      }\n    }\n  }\n  for(int i = 0; i < h; ++i)\n    for(int j = 0; j < w; ++j) {\n      bl += (v[i][j] == 1);\n      wh += (v[i][j] == 2);\n    }\n}\n\nbool ch(p now) {\n  return now.fi >= 0 && now.fi < h && now.se >= 0 &&\n         now.se < w;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(long long int i=0;i<n;++i)\ntypedef long long int ll;\n\nint main(){\n\n    while(1){\n        int h,w;\n        cin >> w >> h;\n        if(w==0)break;\n        vector<string> m(h);\n        for(int i=0;i<h;i++){\n            cin >> m[i];\n        }\n        vector<vector<bool>> wf(h,vector<bool>(w,false));\n        vector<vector<bool>> bf(h,vector<bool>(w,false));\n        int dx[]={0,1,0,-1};\n        int dy[]={1,0,-1,0};\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                if(m[i][j]=='W'){\n                    queue<pair<int,int>> q;\n                    wf[i][j]=true;\n                    bf[i][j]=true;\n                    q.push({i,j});\n                    while(!q.empty()){\n                        pair<int,int> t=q.front();\n                        q.pop();\n                        for(int k=0;k<4;k++){\n                            int ny=t.first+dy[k];\n                            int nx=t.second+dx[k];\n                            if(0<=ny&&ny<h&&0<=nx&&nx<w){\n                                if(!wf[ny][nx]&&m[ny][nx]=='.'){\n                                    q.push({ny,nx});\n                                    wf[ny][nx]=true;\n                                }\n                            }\n                        }\n                    }\n                }else if(m[i][j]=='B'){\n                    queue<pair<int,int>> q;\n                    wf[i][j]=true;\n                    bf[i][j]=true;\n                    q.push({i,j});\n                    while(!q.empty()){\n                        pair<int,int> t=q.front();\n                        q.pop();\n                        for(int k=0;k<4;k++){\n                            int ny=t.first+dy[k];\n                            int nx=t.second+dx[k];\n                            if(0<=ny&&ny<h&&0<=nx&&nx<w){\n                                if(!bf[ny][nx]&&m[ny][nx]=='.'){\n                                    q.push({ny,nx});\n                                    bf[ny][nx]=true;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        int bans=0,wans=0;\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                if(!wf[i][j]&&bf[i][j]){\n                    bans++;\n                }else if(!bf[i][j]&&wf[i][j]){\n                    wans++;\n                }\n            }\n        }\n        cout << bans << \" \" << wans << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nint W, H; vector<string> M;\n\nconst vector<int> dx = { 0, 1, 0, -1 };\nconst vector<int> dy = { -1, 0, 1, 0 };\n\nint rec(int x, int y, vector<vector<bool> > ok)\n{\n\tcout << x << ' ' << y << endl;\n\tif (M[y][x] == 'W')\n\t{\n\t\treturn 2;\n\t}\n\n\tif (M[y][x] == 'B')\n\t{\n\t\treturn 1;\n\t}\n\n\tint ret = 3;\n\n\tfor (int dir = 0; dir < 4; dir++)\n\t{\n\t\tint tx = x + dx[dir];\n\t\tint ty = y + dy[dir];\n\n\t\tif (0 <= tx && tx < W && 0 <= ty && ty < H && ok[ty][tx] == false)\n\t\t{\n\t\t\tvector<vector<bool> > ok2 = ok; ok2[ty][tx] = true;\n\n\t\t\tret = ret & rec(tx, ty, ok2);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tcin >> W >> H;\n\n\t\tif (W == 0 && H == 0) { break; }\n\n\t\tM = vector<string>(H);\n\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tcin >> M[i];\n\t\t}\n\n\t\tint b = 0, w = 0;\n\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tfor (int j = 0; j < W; j++)\n\t\t\t{\n\t\t\t\tif (M[i][j] == '.')\n\t\t\t\t{\n\t\t\t\t\tint c = rec(j, i, vector<vector<bool> >(H, vector<bool>(W, false)));\n\n\t\t\t\t\tif (c == 1) { b++; }\n\t\t\t\t\tif (c == 2) { w++; }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << b << ' ' << w << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define _ ios_base::sync_with_stdio(0);cin.tie(0);\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\nconst int MAX_W=50;\n\nchar a[MAX_W][MAX_W];\nbool checked[MAX_W][MAX_W];\nint w,h;\n\npair<int,char> dfs(int x,int y){\n  if(x<0||y<0||x>=w||y>=h) return make_pair(0,0);\n  if(a[y][x]==1) return make_pair(0,1);\n  if(a[y][x]==2) return make_pair(0,2);\n  if(checked[y][x]) return make_pair(0,0);\n  checked[y][x]=true;\n  pair<int,char> l=dfs(x-1,y);\n  pair<int,char> u=dfs(x,y-1);\n  pair<int,char> r=dfs(x+1,y);\n  pair<int,char> d=dfs(x,y+1);\n  char c=l.second|u.second|r.second|d.second;\n  if(c==255||c==3) return make_pair(0,255);\n  if(c!=0) return make_pair(l.first+u.first+r.first+d.first+1,c);\n  return make_pair(l.first+u.first+r.first+d.first+1,0);\n}\n\nint main(){ _;\n  while(cin>>w>>h,(w|h)!=0){\n    REP(i,h)REP(j,w){\n      cin>>a[i][j];\n      a[i][j]=a[i][j]=='B'?1:a[i][j]=='W'?2:0;\n    }\n    REP(i,h)REP(j,w) checked[i][j]=false;\n    int area_b=0,area_w=0;\n    REP(i,h)REP(j,w){\n      pair<int,char> p=dfs(j,i);\n      if(p.second==1) area_b+=p.first;\n      else if(p.second==2) area_w+=p.first;\n    }\n    cout<<area_b<<\" \"<<area_w<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);i++)\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\n\nint w,h;\nvector<string> ss;\nbool is_white[103][103];\nbool is_black[103][103];\n\nvoid dfs(int x_,int y_,bool (*f_)[103],bool f2) {\n    //cout<<x_<<\",\"<<y_<<endl;\n    if(f_[x_][y_]||(ss[x_][y_]!='.'&&f2)) return;\n    f_[x_][y_]=true;\n    rep(i,4) {\n        int x = x_ + dx[i];\n        int y = y_ + dy[i];\n        if(0<=x&&x<ss.size() && 0<=y&&y<ss[x].size()) {\n            dfs(x,y,f_,true);\n        }\n    }\n}\n\nvoid solve() {\n    rep(i,103) rep(j,103) is_white[i][j]=is_black[i][j]=false;\n    ss.resize(h);\n    rep(i,h) {\n        string t; cin>>t;\n        ss[i]=t;\n    }\n    int ans_b=0,ans_w=0;\n    rep(i,ss.size()) {\n        rep(j,ss[i].size()) {\n            if(ss[i][j]=='B') dfs(i,j,is_black,false);\n            if(ss[i][j]=='W') dfs(i,j,is_white,false);\n        }\n    }\n    rep(i,ss.size()) rep(j,ss[i].size()) {\n        //cout<<i<<\",\"<<j<<\":\"<<is_white[i][j]<<\",\"<<is_black[i][j]<<ss[i][j]<<endl;\n        if(ss[i][j]=='.'&&(is_white[i][j]^is_black[i][j])) {\n           if(is_white[i][j]) ans_w++;\n           else ans_b++; \n        }\n    }\n    cout<<ans_b<<\" \"<<ans_w<<endl;\n    ss.clear();\n}\n\nint main() {\n    while(cin>>w>>h) {\n        if(w+h==0) return 0;\n        solve();\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint counter1,counter2;\nint w, h;\nint x, y;\nchar map[50][50];\n\nvoid serch_w(int x, int y);\nvoid serch_b(int x, int y);\n\nint main(){\n\n\twhile (cin >> w >> h, w&&h){\n\t\tcounter1 = 0;\n\t\tcounter2 = 0;\n\t\tfor (int i = 0; i < h; i++){\n\t\t\tfor (int j = 0; j < w; j++){\n\t\t\t\tcin >> map[i][j];\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < h; i++){\n\t\t\tfor (int j = 0; j < w; j++){\n\t\t\t\tif (map[i][j] == 'W'){\n\t\t\t\t\tx = i;\n\t\t\t\t\ty = j;\n\t\t\t\t\tserch_w(x, y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < h; i++){\n\t\t\tfor (int j = 0; j < w; j++){\n\t\t\t\tif (map[i][j] == 'B'){\n\t\t\t\t\tx = i;\n\t\t\t\t\ty = j;\n\t\t\t\t\tserch_b(x, y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < h; i++){\n\t\t\tfor (int j = 0; j < w; j++){\n\t\t\t\tcout << map[i][j];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\n\t\tfor (int i = 0; i < h; i++){\n\t\t\tfor (int j = 0; j < w; j++){\n\t\t\t\tif (map[i][j] == '2') counter1++;\n\t\t\t\tif (map[i][j] == '1') counter2++;\n\t\t\t}\n\t\t}\n\n\t\tcout << counter1 << \" \" <<counter2 << endl;\n\t}\n\treturn 0;\n}\n\nvoid serch_w(int x, int y){\n\n\t//if(???????????????????????&&????\\???????????????'.'??????????????)\n\tif (x + 1 < h && map[x + 1][y] == '.' && map[x + 1][y] != '2'){\n\t\tmap[x + 1][y] = '2';\n\t\tserch_w(x + 1, y);\n\t}\n\tif (y + 1 < w && map[x][y + 1] == '.' && map[x][y + 1] != '2'){\n\t\tmap[x][y + 1] = '2';\n\t\tserch_w(x, y + 1);\n\t}\n\tif (x - 1 >= 0 && map[x - 1][y] == '.' && map[x - 1][y] != '2'){\n\t\tmap[x - 1][y] = '2';\n\t\tserch_w(x - 1, y);\n\t}\n\tif (y - 1 >= 0 && map[x][y - 1] == '.' && map[x][y - 1] != '2'){\n\t\tmap[x][y - 1] = '2';\n\t\tserch_w(x, y - 1);\n\t}\n}\n\nvoid serch_b(int x, int y){\n\n\n\tif (x + 1 < h && map[x + 1][y] == '.'){\n\t\tmap[x + 1][y] = '1';\n\t\tserch_b(x + 1, y);\n\t}\n\telse if (x + 1 < h &&  map[x + 1][y] == '2'){\n\t\tmap[x + 1][y] = '3';\n\t\tserch_w(x + 1,y);\n\t}\n\n\n\tif (y + 1 < w && map[x][y + 1] == '.' ){\n\t\tmap[x][y + 1] = '1';\n\t\tserch_b(x, y + 1);\n\t}\n\telse if (y + 1 < w &&  map[x][y + 1] == '2'){\n\t\tmap[x][y + 1] = '3';\n\t\tserch_w(x, y+1);\n\t}\n\n\tif (x - 1 >= 0 && map[x - 1][y] == '.'){\n\t\tmap[x - 1][y] = '1';\n\t\tserch_b(x - 1, y);\n\t}\n\telse if (x - 1 >= 0 &&  map[x - 1][y] == '2'){\n\t\tmap[x - 1][y] ='3';\n\t\tserch_w(x - 1, y);\n\t}\n\n\tif (y - 1 >= 0 && map[x][y - 1] == '.'){\n\t\tmap[x][y - 1] = '1';\n\t\tserch_b(x, y - 1);\n\t}\n\telse if (y - 1 >= 0 &&  map[x][y - 1] == '2'){\n\t\tmap[x][y - 1] = '3';\n\t\tserch_w(x, y - 1);\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#include<iostream>\n#include<stdio.h>\n#include<bitset>\n#include<algorithm>\n#include<vector>\n#include<list>\n#include<queue>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<cmath>\n#include<utility>\n#include<functional>\n#include<map>\n#include<set>\n\n\n#define FOR(i, a, b) for( int i=(a);i<=(b);i++)\n#define RFOR(i, a, b) for(long long int i=(a);i>=(b);i--)\n#define MOD 1000000007\n#define INF 1000000000 //2000000000\n#define LLINF 1000000000000000000 //9000000000000000000\n#define PI 3.14159265358979\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair< long long int, long long  int> P;\n\nvector<string> dp(50);\nbool now[50][50];\n\nint main(void) {\n\n\twhile (1) {\n\t\tint w, h;\n\t\tint black = 0, white = 0;\n\t\tqueue < pair<int, int> > que;\n\t\tpair <int, int> pos;\n\t\tpair <int, int>load;\n\n\t\tcin >> w >> h;\n\t\tif (w == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tFOR(i, 0, 49) {\n\t\t\tdp[i] = \"\";\n\t\t}\n\t\tFOR(i, 0, 49) {\n\t\t\tFOR(j, 0, 49) {\n\t\t\t\tnow[i][j] = false;\n\t\t\t}\n\t\t}\n\t\tFOR(i, 0, h - 1) {\n\t\t\tcin >> dp[i];\n\t\t}\n\t\tFOR(i, 0, h - 1) {\n\t\t\tFOR(j, 0, w - 1) {\n\t\t\t\tif (dp[i][j] == '.'&&now[i][j] == false) {\n\t\t\t\t\tint count = 1;\n\t\t\t\t\tint sta = 0;//no,white,black,double\n\t\t\t\t\tque.push(make_pair(i, j));\n\t\t\t\t\twhile (!que.empty()) {\n\t\t\t\t\t\tpos = que.front();\n\t\t\t\t\t\tque.pop();\n\t\t\t\t\t\t//cout << pos.first << \" \" << pos.second << \" \" << count << \" \" << sta << endl;\n\t\t\t\t\t\tnow[pos.first][pos.second] = true;\n\t\t\t\t\t\tif (pos.first + 1 <= h - 1) {\n\t\t\t\t\t\t\tif (dp[pos.first + 1][pos.second] == '.'&&now[pos.first + 1][pos.second] == false) {\n\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t\tload = make_pair(pos.first + 1, pos.second);\n\t\t\t\t\t\t\t\tque.push(load);\n\t\t\t\t\t\t\t\tnow[pos.first + 1][pos.second] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (dp[pos.first + 1][pos.second] == 'B') {\n\t\t\t\t\t\t\t\tswitch (sta) {\n\t\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\t\tsta = 2;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\t\tsta = 3;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (dp[pos.first + 1][pos.second] == 'W') {\n\t\t\t\t\t\t\t\tswitch (sta) {\n\t\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\t\tsta = 1;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\t\tsta = 3;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (pos.first - 1 >= 0) {\n\t\t\t\t\t\t\tif (dp[pos.first - 1][pos.second] == '.'&&now[pos.first - 1][pos.second] == false) {\n\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t\tload = make_pair(pos.first - 1, pos.second);\n\t\t\t\t\t\t\t\tque.push(load);\n\t\t\t\t\t\t\t\tnow[pos.first - 1][pos.second] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (dp[pos.first - 1][pos.second] == 'B') {\n\t\t\t\t\t\t\t\tswitch (sta) {\n\t\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\t\tsta = 2;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\t\tsta = 3;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (dp[pos.first - 1][pos.second] == 'W') {\n\t\t\t\t\t\t\t\tswitch (sta) {\n\t\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\t\tsta = 1;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\t\tsta = 3;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (pos.second + 1 <= w - 1) {\n\t\t\t\t\t\t\tif (dp[pos.first][pos.second + 1] == '.'&&now[pos.first][pos.second + 1] == false) {\n\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t\tload = make_pair(pos.first, pos.second + 1);\n\t\t\t\t\t\t\t\tque.push(load);\n\t\t\t\t\t\t\t\tnow[pos.first][pos.second + 1] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (dp[pos.first][pos.second + 1] == 'B') {\n\t\t\t\t\t\t\t\tswitch (sta) {\n\t\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\t\tsta = 2;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\t\tsta = 3;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (dp[pos.first][pos.second + 1] == 'W') {\n\t\t\t\t\t\t\t\tswitch (sta) {\n\t\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\t\tsta = 1;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\t\tsta = 3;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (pos.second - 1 >= 0) {\n\t\t\t\t\t\t\tif (dp[pos.first][pos.second - 1] == '.'&&now[pos.first][pos.second - 1] == false) {\n\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t\tload = make_pair(pos.first, pos.second - 1);\n\t\t\t\t\t\t\t\tque.push(load);\n\t\t\t\t\t\t\t\tnow[pos.first][pos.second - 1] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (dp[pos.first][pos.second - 1] == 'B') {\n\t\t\t\t\t\t\t\tswitch (sta) {\n\t\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\t\tsta = 2;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\t\t\tsta = 3;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (dp[pos.first][pos.second - 1] == 'W') {\n\t\t\t\t\t\t\t\tswitch (sta) {\n\t\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\t\tsta = 1;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\t\tsta = 3;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tswitch (sta) {\n\t\t\t\t\tcase 1:\n\t\t\t\t\t\twhite += count;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2:\n\t\t\t\t\t\tblack += count;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << black << \" \" << white << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n\nchar a[50][50];\nint w,h;\n\nvoid white(int p,int q);\nvoid black(int p,int q);\n\nint main(){\n    while(1){\n        int resb=0,resw=0;\n        scanf(\"%d %d\",&h,&w);\n        if(w==0&&h==0) return 0;\n        for(int i=0;i<w;i++) scanf(\"%s\",&a[i][0]);\n        for(int i=0;i<w;i++){\n            for(int j=0;j<h;j++){\n                if(a[i][j]=='W') white(i,j);\n                if(a[i][j]=='B') black(i,j);\n            }\n        }\n        for(int i=0;i<w;i++){\n            for(int j=0;j<h;j++){\n                if(a[i][j]=='b') resb++;\n                if(a[i][j]=='w') resw++;\n            }\n        }\n        printf(\"%d %d\\n\",resb,resw);\n    }\n}\n\nvoid white(int p,int q){\n    for(int i=-1;i<=1;i++){\n        for(int j=-1;j<=1;j++){\n            if((i==0||j==0)&&p+i>=0&&p+i<w&&q+j>=0&&q+j<h){\n                if(a[p+i][q+j]=='.'){\n                    a[p+i][q+j]='w';\n                    white(p+i,q+j);\n                }else if(a[p+i][q+j]=='b'){\n                    a[p+i][q+j]='g';\n                    white(p+i,q+j);\n                }\n            }\n        }\n    }\n}\n\n\nvoid black(int p,int q){\n    for(int i=-1;i<=1;i++){\n        for(int j=-1;j<=1;j++){\n            if((i==0||j==0)&&p+i>=0&&p+i<w&&q+j>=0&&q+j<h){\n                if(a[p+i][q+j]=='.'){\n                    a[p+i][q+j]='b';\n                    black(p+i,q+j);\n                }else if(a[p+i][q+j]=='w'){\n                    a[p+i][q+j]='g';\n                    black(p+i,q+j);\n                } \n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate <class T>\nvoid readVector(int n, vector<T> &v){\n\tfor(int i=0; i<n; ++i){\n\t\tT t;\n\t\tcin >> t;\n\t\tv.push_back(t);\n\t}\n}\nint dx[4] = {0, 0, -1, 1};\nint dy[4] = {1, -1, 0, 0};\ntypedef pair<long long, long long> P;\n\nvoid solve(int w, int h){\n\tvector<string> a;\n\treadVector(h, a);\n\tint b[h][w];\n\tfor(int i=0; i<h; ++i)\n\t\tfor(int j=0; j<w; ++j)\n\t\t\tb[i][j] = 0;\n\tfor(int i=0; i<h; ++i)\n\t\tfor(int j=0; j<w; ++j){\n\t\t\tint t = 0;\n\t\t\tif(a[i][j] == 'B') t = 1;\n\t\t\telse if(a[i][j] == 'W') t = 2;\n\t\t\tif(t > 0){\n\t\t\t\tqueue<P> q;\n\t\t\t\tfor(int k=0; k<4; ++k){\n\t\t\t\t\tint nx = i+dx[k];\n\t\t\t\t\tint ny = j+dy[k];\n\t\t\t\t\tif(0 <= nx && nx < h && 0 <= ny && ny < w && a[nx][ny] == '.' && (b[nx][ny]&t) == 0){\n\t\t\t\t\t\tq.push(P(nx, ny));\n\t\t\t\t\t\tb[nx][ny] += t;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twhile(!q.empty()){\n\t\t\t\t\tP p = q.front();\n\t\t\t\t\tq.pop();\n\t\t\t\t\tfor(int k=0; k<4; ++k){\n\t\t\t\t\t\tint nx = p.first+dx[k];\n\t\t\t\t\t\tint ny = p.second+dy[k];\n\t\t\t\t\t\tif(0 <= nx && nx < h && 0 <= ny && ny < w && a[nx][ny] == '.' && (b[nx][ny]&t) == 0){\n\t\t\t\t\t\t\tq.push(P(nx, ny));\n\t\t\t\t\t\t\tb[nx][ny] += t;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tint x = 0, y = 0;\n\tfor(int i=0; i<h; ++i)\n\t\tfor(int j=0; j<w; ++j){\n\t\t\tif(b[i][j] == 1) ++x;\n\t\t\tif(b[i][j] == 2) ++y;\n\t\t}\n\tcout << x << \" \" << y << \"\\n\";\n//\tfor(int i=0; i<h; ++i)\n//\t\tfor(int j=0; j<w; ++j)\n//\t\t\tcout << b[i][j] << (j==w-1 ? \"\\n\" : \" \");\n}\n\nint main(){\n//\tcin.tie(0);\n//\tios::sync_with_stdio(false);\n\twhile(1){\n\t\tint w, h;\n\t\tcin >> w >> h;\n\t\tif(w == 0 && h == 0) return 0;\n\t\tsolve(w, h);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<queue>\nusing namespace std;\n\nint W, H;\nstring m[50];\nint t[50][50];\nint v[10000];\n\nint dx[4] = {1, -1, 0, 0}, dy[4] = {0, 0, 1, -1};\n\nint dfs(int xx, int yy, int n)\n{\n  int res = 1;\n  t[yy][xx] = n;\n  queue<int> q;\n  q.push(xx);\n  q.push(yy);\n\n  while(q.size())\n  {\n    int x = q.front(); q.pop();\n    int y = q.front(); q.pop();\n\n    if(m[y][x] != '.')\n    {\n      if(v[n] == 0)\n      {\n        if(m[y][x] == 'W')\n          v[n] = 1;\n        else\n          v[n] = 2;\n      }\n      if(v[n] == 1 && m[y][x] == 'B' || v[n] == 2 && m[y][x] == 'W')\n        v[n] = 3;\n      continue;\n    }\n\n    for(int i = 0; i < 4; i++)\n    {\n      int tx = x + dx[i], ty = y + dy[i];\n      if(0 <= tx && tx < W && 0 <= ty && ty < H && t[ty][tx] <= 0)\n      {\n        q.push(tx);\n        q.push(ty);\n        if(!t[ty][tx])\n        {\n          res++;\n          t[ty][tx] = n;\n        }\n      }\n    }\n  }\n  return res;\n}\n\nint main()\n{\n  while(true)\n  {\n    cin >> W >> H;\n    if(!W)\n      break;\n    fill((int*)t, (int*)t + 2500, 0);\n    fill(v, v + 10000, 0);\n    for(int i = 0; i < H; i++)\n    {\n      cin >> m[i];\n      for(int j = 0; j < W; j++)\n        if(m[i][j] != '.')\n          t[i][j] = -1;\n    }\n\n    int a = 11, w = 0, b = 0;\n    for(int y = 0; y < H; y++)\n    {\n      for(int x = 0; x < W; x++)\n      {\n        if(t[y][x] == 0)\n        {\n          int r = dfs(x, y, a);\n          if(v[a] == 1)\n            w += r;\n          if(v[a] == 2)\n            b += r;\n          a++;\n        }\n      }\n    }\n    cout << b << \" \" << w << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstdlib>\n\nusing namespace std;\n\nconst static int NONE  = 0x00;\nconst static int BLACK = 0x01;\nconst static int WHITE = 0x10;\nconst static int BOTH  = 0x11;\n\nstring getDummyLine( int w ) {\n  string line = \"\";\n  for( int c = 0; c < w + 2; c++ ) {\n    line += \"V\";\n  }\n  return line;\n}\n\nint visit( vector<string>& island, int i, int j, int &counter ) {\n  if( island[ i ][ j ] != '.' ) {\n    if( island[ i ][ j ] == 'B' ) { return BLACK; }\n    if( island[ i ][ j ] == 'W' ) { return WHITE; }\n    return NONE;\n  }\n\n  counter++;\n  island[ i ][ j ] = 'V';\n  \n  return (\n      visit( island, i - 1, j     , counter ) |\n      visit( island, i    , j - 1 , counter ) |\n      visit( island, i + 1, j     , counter ) |\n      visit( island, i    , j + 1, counter  ) \n  );\n}\n\nint main() {\n  while( 1 ) {\n    int w, h;\n    vector<string> island;\n    cin >> w >> h;\n    if( !w && !h ) { return EXIT_SUCCESS; }\n\n    string dummyLine = getDummyLine( w );\n    island.push_back( dummyLine );\n    for( int r = 1; r <= h; r++ ) {\n      string line;\n      cin >> line;\n      island.push_back( 'V' + line + 'V' );\n    }\n    island.push_back( dummyLine );\n    int blackNum = 0, whiteNum = 0;\n    for( int r = 1; r <= h; r++ ) {\n      for( int c = 1; c <= w; c++ ) {\n        int size = 0;\n        int type = visit( island, r, c, size );\n        if( type == BLACK ) {\n          blackNum += size;\n        } else if( type == WHITE ) {\n          whiteNum += size;\n        }\n      }\n    }\n\n    cout << blackNum << \" \" << whiteNum << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n#define FOR(i, a, b) for(int i=(a);i<(b);i++)\n#define REP(i, n) FOR(i, 0, n)\n#define RFOR(i, a, b) for(int i=(a);i>=(b);i--)\n#define RREP(i, n) RFOR(i, n, 0)\n#define MFOR(i, m) for(auto i=(m).begin();i!=(m).end();i++)\n#define ALL(a) (a).begin(), (a).end()\n#define SZ(x) ((int)(x).size())\n\ntypedef long long int ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> Pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vll;\ntypedef vector<vll> vvll;\n\nconst double eps = 1e-10;\nconst int MOD = 1000000007;\nconst int INF = 1000000000;\nconst ll LINF = 1 << 30;\n\ntemplate<typename T>\nvoid printv(vector<T> const& s) {\n  REP(i, SZ(s)) {\n    cout << s[i] << \" \";\n  }\n  cout << endl;\n}\n\nstruct UnionFind {\n  vector< int > data;\n\n  UnionFind(int sz) {\n    data.assign(sz, -1);\n  }\n\n  bool unite(int x, int y) {\n    x = find(x), y = find(y);\n    if(x == y) return (false);\n    if(data[x] > data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n    return (true);\n  }\n\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n\n  int find(int k) {\n    if(data[k] < 0) return (k);\n    return (data[k] = find(data[k]));\n  }\n\n  int size(int k) {\n    return (-data[find(k)]);\n  }\n};\n\n\nint main () {\n  cin.tie(0);\n  cout << setprecision(10);\n\n  vi dx = {-1, 0, 1, 0};\n  vi dy = {0, -1, 0, 1};\n\n  while(1) {\n    int w, h; cin >> w >> h;\n    if(w == 0 && h == 0) break;\n    vector<vector<char>> a(h);\n    REP(i, h) {\n      a[i].resize(w);\n      REP(j, w) {\n        cin >> a[i][j];\n      }\n    }\n\n    int black = 0, white = 0;\n    vector<vector<bool>> sel(h);\n    REP(i, h) sel[i].resize(w, false);\n    REP(i, h) {\n      REP(j, w) {\n        if(sel[i][j]) continue;\n        if(a[i][j] == 'B' || a[i][j] == 'W') {\n          continue;\n        }\n        int area = 1;\n        bool bl = false;\n        bool wh = false;\n        queue<P> q;\n        sel[i][j] = true;\n        q.push(make_pair(i, j));\n        while(!q.empty()) {\n          P p = q.front(); q.pop();\n          REP(k, 4) {\n            P tmp = make_pair(p.first + dy[k], p.second + dx[k]);\n            if(0 <= tmp.first && tmp.first <h && 0 <= tmp.second && tmp.second < w) {\n              if(sel[tmp.first][tmp.second]) continue;\n              if(a[tmp.first][tmp.second] == 'B') {\n                bl = true;\n                continue;\n              }\n              if(a[tmp.first][tmp.second] == 'W') {\n                wh = true;\n                continue;\n              }\n              sel[tmp.first][tmp.second] = true;\n              area++;\n              q.push(tmp);\n            }\n          }\n        }\n\n        // cout << i << \":\" << j << \":\" << area << \":\" << bl << \":\" << wh << endl;\n\n        if(bl && !wh) {\n          black += area;\n        } else if(!bl && wh) {\n          white += area;\n        }\n      }\n    }\n    cout << black << \" \" << white << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nenum Stake{\n    none=0,\n    B=1,\n    W=2,\n    black=3,\n    white=4,\n    eo=5,\n};\n\nStake area[51][51];\nint dx[4] = {0,1,0,-1};\nint dy[4] = {1,0,-1,0};\nint w,h;\n\nvoid B_DFS(int y, int x){\n\n    if(area[y][x] == none){\n        area[y][x] = black;\n    }\n    else if(area[y][x] == white){\n        area[y][x] = eo;\n    }\n\n    for(int i=0; i<4; i++){\n        if(x + dx[i] >= 0 && x + dx[i] < w && y + dy[i] >= 0 && y + dy[i] < h){\n            if(area[y+dy[i]][x+dx[i]] != B && area[y+dy[i]][x+dx[i]] != W && area[y+dy[i]][x+dx[i]] != black && area[y+dy[i]][x+dx[i]] != eo) {\n                B_DFS(y + dy[i], x + dx[i]);\n            }\n        }\n    }\n\n}\n\nvoid W_DFS(int y,int x){\n\n    if(area[y][x] == none){\n        area[y][x] = white;\n    }\n    else if(area[y][x] == black){\n        area[y][x] = eo;\n    }\n\n    for(int i=0; i<4; i++){\n        if(x + dx[i] >= 0 && x + dx[i] < w && y + dy[i] >= 0 && y + dy[i] < h){\n            if(area[y+dy[i]][x+dx[i]] != B && area[y+dy[i]][x+dx[i]] != W && area[y+dy[i]][x+dx[i]] != white && area[y+dy[i]][x+dx[i]] != eo) {\n                W_DFS(y + dy[i], x + dx[i]);\n            }\n        }\n    }\n}\n\nint main() {\n\n    while(true) {\n\n        cin >> w >> h;\n        if (w == 0 && h == 0) {\n            break;\n        }\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                char a;\n                cin >> a;\n                if (a == 'W') {\n                    area[i][j] = W;\n                } else if (a == 'B') {\n                    area[i][j] = B;\n                } else if (a == '.') {\n                    area[i][j] = none;\n                }\n            }\n        }\n\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                if(area[i][j] == B){\n                    B_DFS(i,j);\n                }\n                else if(area[i][j] == W){\n                    W_DFS(i,j);\n                }\n            }\n        }\n\n        int black_count = 0,white_count = 0;\n\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                if(area[i][j] == black){\n                    black_count++;\n                }\n                else if(area[i][j] == white){\n                    white_count++;\n                }\n            }\n        }\n\n        cout << black_count << \" \" << white_count << endl;\n\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\n#define chmin(a, b) ((a)=min((a), (b)))\n#define chmax(a, b) ((a)=max((a), (b)))\n#define fs first\n#define sc second\n#define eb emplace_back\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\n\nconst ll MOD=1e9+7;\nconst ll INF=1e18;\nconst double pi=acos(-1);\nconst double eps=1e-10;\n\nint dx[]={1, 0, -1, 0};\nint dy[]={0, -1, 0, 1};\n\nint main(){\n    while(1){\n        int w, h; cin>>w>>h;\n        if(w == 0) return 0;\n        vector<string> a(h);\n        for(int i=0; i<h; i++) cin>>a[i];\n\n        int BS = 0, WS = 0;\n        vector<vector<bool>> visited(h, vector<bool>(w, false));\n        for(int i=0; i<h; i++){\n            for(int j=0; j<w; j++){\n                if(a[i][j] == '.' && !visited[i][j]){\n                    visited[i][j] = true;\n                    queue<P> que;\n                    que.push(P(i, j));\n                    int S = 1;\n                    bool isW = false, isB = false;\n                    while(que.size()){\n                        int cy, cx;\n                        tie(cy, cx) = que.front();\n                        que.pop();\n\n                        for(int k=0; k<4; k++){\n                            int ny = cy + dy[k];\n                            int nx = cx + dx[k];\n\n                            if(0 <= ny && ny < h && 0 <= nx && nx < w){\n                                if(!visited[ny][nx] && a[ny][nx] == '.'){\n                                    S++;\n                                    visited[ny][nx] = true;\n                                    que.push(P(ny, nx));\n                                }\n                                if(a[ny][nx] == 'W') isW = true;\n                                if(a[ny][nx] == 'B') isB = true;\n                            }\n                        }\n                    }\n\n                    if(!isW && isB) BS += S;\n                    if(isW && !isB) WS += S;\n                }\n            }\n        }\n\n        cout << BS << \" \" << WS << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll MOD = 1000000007;\nconst int MAXW = 50, MAXH = 50;\n\nconst int di[4] = {-1, 0, 1, 0};\nconst int dj[4] = {0, 1, 0, -1};\n\nint w, h;\nstring a[MAXH];\nbool visited[MAXH][MAXW];\nbool iswhite, isblack;\nint cnt = 0;\nint answ = 0, ansb = 0;\n\nvoid dfs(int i, int j){\n    visited[i][j] = true;\n    cnt++;\n    for(int k=0;k<4;k++){\n        if(i + di[k] < 0 || i + di[k] >= h || j + dj[k] < 0 || j + dj[k] >= w) continue;\n        if(a[i + di[k]][j + dj[k]] == 'W') iswhite = true;\n        else if(a[i + di[k]][j + dj[k]] == 'B') isblack = true;\n        else if(!visited[i + di[k]][j + dj[k]]) dfs(i + di[k], j + dj[k]);\n    }\n}\n\nvoid solve(int i, int j){\n    iswhite = false, isblack = false;\n    cnt = 0;\n\n    dfs(i, j);\n\n    if(iswhite && !isblack){\n        answ += cnt;\n    }else if(isblack && !iswhite){\n        ansb += cnt;\n    }\n}\n\n\nint main(){\n    cin.tie(0);\n    ios_base::sync_with_stdio(false);\n    while(1){\n        cin >> w >> h;\n        if(w == 0 && h == 0) break;\n        for(int i=0;i<h;i++){\n            cin >> a[i];\n        }\n        // initialization\n        memset(visited, 0, sizeof visited);\n        ansb = 0, answ = 0;\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                if(a[i][j] == '.' && !visited[i][j]){\n                    solve(i, j);\n                }\n            }\n        }\n        cout << ansb << \" \" << answ << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint dx[]={1,0,-1,0},dy[]={0,1,0,-1};\nint w,h,bum,wum,sum,B,W;\nchar s[60][60];\nvoid func1(int y,int x){\n\tint p=y,q=x;\n\tif(s[y][x]=='B'){\n\t\tB++;\n\t}\n\telse if(s[y][x]=='W'){\n\t\tW++;\n\t}\n\telse if(s[y][x]!='*'){\n\t\ts[y][x]='*';\n\t\tsum++;\n\t\tfor(int l=0;l<4;l++){\n\t\t\ty=p+dy[l];\n\t\t\tx=q+dx[l];\n\t\t\tif(y>=0&&y<h&&x>=0&&x<w){\n\t\t\t\tfunc1(y,x);\n\t\t\t}\n\t\t}\n\t}\n}\nvoid func2(int y,int x,char c){\n\tint p,q;\n\tif(s[y][x]=='*'){\n\t\ts[y][x]=c;\n\t\tfor(int o=0;o<4;o++){\n\t\t\tp=y+dy[o];\n\t\t\tq=x+dx[o];\n\t\t\tif(p>=0&&p<h&&q>=0&&q<w)\n\t\t\t\tfunc2(p,q,c);\n\t\t}\n\t}\n}\nint main(){\n\twhile(cin>>w>>h,w||h){\n\t\twum=0;\n\t\tbum=0;\n\t\tfor(int i=0;i<h;i++)\n\t\tscanf(\"%s\",s[i]);\n\t\tfor(int i=0;i<h;i++)\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(s[i][j]=='.'){\n\t\t\t\tB=0;\n\t\t\t\tW=0;\n\t\t\t\tsum=0;\n\t\t\t\tfunc1(i,j);\n\t\t\t\tif(B>0&&W==0){\n\t\t\t\t\tbum+=sum;\n\t\t\t\t\tfunc2(i,j,'s');\n\t\t\t\t}\n\t\t\t\telse if(B==0&&W>0){\n\t\t\t\t\twum+=sum;\n\t\t\t\t\tfunc2(i,j,'t');\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tfunc2(i,j,'D');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++)\n\t\tcout<<s[i][j];\n\t\t\tcout<<endl;\n\t\t}\n\t\tcout<<bum<<' '<<wum<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <utility>\n#include <stack>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <map>\n#include <climits>\n#include <set>\n#include <numeric>\n#include <iomanip>\n#include <cmath>\n#include <cstring>\nusing namespace std;\nstring grid[50];\nbool used[50][50];\nstring surrounded[50];\nint move_h[4] = {-1, 1, 0, 0};\nint move_w[4] = {0, 0, -1, 1};\n\nvoid dfs_fill(int cur_h, int cur_w, char color, int h, int w){\n  surrounded[cur_h][cur_w] = color;\n  for(int i = 0; i < 4; i++){\n    int next_h = cur_h + move_h[i];\n    int next_w = cur_w + move_w[i];\n    if(0 <= next_h && next_h < h && 0 <= next_w && next_w < w\n        && grid[next_h][next_w] == '.' && surrounded[next_h][next_w] == '.'){\n      dfs_fill(next_h, next_w, color, h, w);  \n    }\n  }\n}\n\nchar dfs_check(int cur_h, int cur_w, int h, int w){\n  used[cur_h][cur_w] = true;\n  if(grid[cur_h][cur_w] != '.'){\n    used[cur_h][cur_w] = false;\n    return grid[cur_h][cur_w];\n  }\n  char ret = '.';\n  bool return_x = false;\n  for(int i = 0; i < 4; i++){\n    int next_h = cur_h + move_h[i];\n    int next_w = cur_w + move_w[i];\n    if(0 <= next_h && next_h < h && 0 <= next_w && next_w < w\n        && !used[next_h][next_w]){\n      char tmp = dfs_check(next_h, next_w, h, w);\n      if(tmp == 'x' || (ret != '.' && tmp != '.' && ret != tmp)){\n        return_x = true;\n      }\n      ret = tmp;\n    }\n  }\n  if(return_x){\n    return 'x';\n  }\n  return ret;\n}\n\nint main(){\n  while(true){\n    int w;\n    int h;\n    cin >> w >> h;\n    if(w == 0 && h == 0){\n      break;\n    }\n    for(int i = 0; i < h; i++){\n      cin >> grid[i];\n    }\n\n    for(int i = 0; i < h; i++){\n      surrounded[i] = \"\";\n      for(int j = 0; j < w; j++){\n        surrounded[i].push_back('.');\n        used[i][j] = false;\n      }\n    }\n\n    for(int i = 0; i < h; i++){\n      for(int j = 0; j < w; j++){\n        if(!used[i][j] && grid[i][j] == '.'){\n          char tmp = dfs_check(i, j, h, w);\n          if(tmp == 'B' || tmp == 'W'){\n            dfs_fill(i, j, tmp, h, w);\n          }\n        }\n      }\n    }\n\n    int ans_B = 0;\n    int ans_W = 0;\n    for(int i = 0; i < h; i++){\n      for(int j = 0; j < w; j++){\n        if(surrounded[i][j] == 'B'){\n          ans_B ++;\n        }\n        if(surrounded[i][j] == 'W'){\n          ans_W ++;\n        }\n      }\n    }\n    /*\n    for(int i = 0; i < h; i++){\n      cout << surrounded[i] << endl;\n    }\n    */\n    cout << ans_B << \" \" << ans_W << endl;\n  }\n  return 0;\n}\n\n/*\n.....W....\n....W.W...\n...W...W..\n....W...W.\n.....W...W\n......W.W.\nBBB....W..\n..B..BBBBB\n..B..B....\n..B..B..W.\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <string>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <functional>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <list>\n#include <tuple>\n#include <bitset>\n\nusing namespace std;\n\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\ninline bool cheak(int x, int y, int xMax, int yMax){ return x >= 0 && y >= 0 && xMax > x && yMax > y; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str(); }\ntemplate<class T> inline T sqr(T x) { return x*x; }\n\ntypedef pair<int, int> P;\ntypedef tuple<int, int,int> T;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define For(i,a,b)\tfor(int (i) = (a);i < (b);(i)++)\n#define rep(i,n)\tFor(i,0,n)\n#define clr(a)\t\tmemset((a), 0 ,sizeof(a))\n#define mclr(a)\t\tmemset((a), -1 ,sizeof(a))\n#define all(a)\t\t(a).begin(),(a).end()\n#define sz(a)\t\t(sizeof(a))\n#define Fill(a,v)\tfill((int*)a,(int*)(a+(sz(a)/sz(*(a)))),v)\n\nconst int dx[8] = { 1, 0, -1, 0, 1, 1, -1, -1 }, dy[8] = { 0, -1, 0, 1, -1, 1, -1, 1 };\nconst int mod = 1000000007;\nconst int INF = 1e9;\n\nconst int M = 51;\nchar c[M][M];\nchar d[M][M];\nint w, h;\nbool f[M][M];\n\nchar dfs(int y, int x){\n\tif (c[y][x] != '.')return c[y][x];\n\tif (d[y][x])return 0;\n\tf[y][x] = true;\n\n\tchar ret = -1;\n\trep(i, 4){\n\t\tint tx = x + dx[i], ty = y + dy[i];\n\t\tif (cheak(tx, ty, w, h) && !f[ty][tx]){\n\t\t\tchar t = dfs(ty, tx);\n\t\t\tif (ret == -1 || t == ret){\n\t\t\t\tret = t;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tret = 0;\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nvoid sdfs(int y, int x, char n){\n\tif (n == 0)return;\n\tf[y][x] = false;\n\td[y][x] = n;\n\n\trep(i, 4){\n\t\tint tx = x + dx[i], ty = y + dy[i];\n\t\tif (cheak(tx, ty, w, h) && f[ty][tx]){\n\t\t\tsdfs(ty, tx, n);\n\t\t}\n\t}\n}\n\nint main()\n{\n\n\twhile (cin >> w >> h && w){\n\t\tclr(d);\n\t\trep(y, h)rep(x, w){\n\t\t\tcin >> c[y][x];\n\t\t}\n\n\t\trep(y, h)rep(x, w){\n\t\t\tclr(f);\n\t\t\tsdfs(y, x, dfs(y, x));\n\t\t}\n\n\t\tint ba = 0, wa = 0;\n\t\trep(y, h)rep(x, w){\n\t\t\tif (c[y][x] == '.'){\n\t\t\t\tif (d[y][x] == 'B')ba++;\n\t\t\t\tif (d[y][x] == 'W')wa++;\n\t\t\t}\n\t\t}\n\n\t\tcout << ba << \" \" << wa << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include <set>\n#include <cctype>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\nusing namespace std;\n#define INF 100000000\n#define MAXH 64\n#define MAXW 64\n\ntypedef long long ll;\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\nchar a[MAXH][MAXW];\nint w, h;\n\nint main(void) {\n    while (1) {\n        cin >> w >> h;\n        if (w == 0 && h == 0) break;\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                cin >> a[i][j];\n            }\n        }\n        int white = 0, black = 0;\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                if (a[i][j] != '.') continue;\n                bool used[h][w];\n                for (int k = 0; k < h; k++) {\n                    for (int l = 0; l < w; l++) {\n                        used[k][l] = false;\n                    }\n                }\n                queue<int> X, Y;\n                X.push(j); Y.push(i);\n                bool white_flag = false, black_flag = false;\n                while (!X.empty()) {\n                    int x = X.front(); X.pop();\n                    int y = Y.front(); Y.pop();\n                    used[y][x] = true;\n                    for (int k = 0; k < 4; k++) {\n                        int nx = x + dx[k];\n                        int ny = y + dy[k];\n                        if (0 <= nx && nx < w && 0 <= ny && ny < h) {\n                            if (a[ny][nx] == 'W') white_flag = true;\n                            else if (a[ny][nx] == 'B') black_flag = true;\n                            else if (!used[ny][nx]) {\n                                X.push(nx);\n                                Y.push(ny);\n                            }\n                        }\n                    }\n                }\n                if (white_flag && !black_flag) white++;\n                if (!white_flag && black_flag) black++;\n            }\n        }\n        cout << black << \" \" << white << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;++i)\n#define rep1(i,n) for(int i=1;i<=n;++i)\nusing namespace std;\nint a[52][52];\nint dx[4]={0,0,-1,1};\nint dy[4]={-1,1,0,0};\nint cnt[4];\n/*  .->0  b,w,b&w->1,2,3  B,W->10,20  WALL->30  */\n\nvoid paint(int y,int x,int color){\n    if(a[y][x]>=3 || a[y][x]==color)return;\n    cnt[a[y][x]]--;\n    a[y][x] |= color;\n    cnt[a[y][x]]++;\n    rep(i,4)paint(y+dy[i],x+dx[i],a[y][x]);\n}\n\nint main(void){\n    int h,w;\n    char c;\n    while(cin>>w>>h, w|h){\n        rep(i,4)cnt[i]=0;\n        rep1(y,h){\n            rep1(x,w){\n                cin>>c;\n                if(c=='.')a[y][x] = 0;\n                else a[y][x] = (c=='B' ? 10 : 20);\n            }\n        }\n        rep(y,h+2) a[y][0] = a[y][w+1] = 30;\n        rep(x,w+2) a[0][x] = a[h+1][x] = 30;\n\n        rep1(y,h)rep1(x,w)if(a[y][x]>=10)rep(i,4)paint(y+dy[i],x+dx[i],a[y][x]/10);\n\n        cout<<cnt[1]<<\" \"<<cnt[2]<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst double eps=1e-9;\ntypedef vector<int> vi;\ntypedef long long ll;\nint H,W;\nbool used[55][55];\nbool black[55][55];\nbool white[55][55];\nstring board[55];\nint dx[]={-1,0,1,0};\nint dy[]={0,-1,0,1};\nbool outrange(int y,int x,int turn)\n{\n  if(y<0 || y>=H || x<0 || x>=W || used[y][x])\n    {\n      return true;\n    }\n  if(turn==0 && board[y][x]=='W') return true;\n  else if(turn==1 && board[y][x]=='B') return true;\n  else return false;\n}\nvoid bfs(int y,int x,int turn)\n{\n  used[y][x]=true;\n  if(turn==0) black[y][x]=true;\n  if(turn==1) white[y][x]=true;\n  for(int k=0;k<4;k++)\n    {\n      int ny=y+dy[k];\n      int nx=x+dx[k];\n      if(!outrange(ny,nx,turn))\n\t{\n\t  bfs(ny,nx,turn);\n\t}\n    }\n}\n\nint main(void)\n{\n  while(cin >> W >> H&& W)\n    {\n      int bnum=0;\n      int wnum=0;\n      memset(used,false,sizeof(used));\n      memset(black,false,sizeof(black));\n      memset(white,false,sizeof(white));\n      for(int i=0;i<H;i++)\n\t{\n\t  cin >> board[i];\n\t}\n      for(int i=0;i<H;i++)\n\t{\n\t  for(int j=0;j<W;j++)\n\t    {\n\t      if(board[i][j]=='B' && !used[i][j]) bfs(i,j,0);\n\t    }\n\t}\n      memset(used,false,sizeof(used));\n      for(int i=0;i<H;i++)\n\t{\n\t  for(int j=0;j<W;j++)\n\t    {\n\t      if(board[i][j]=='W' && !used[i][j]) bfs(i,j,1);\n\t    }\n\t}\n      for(int i=0;i<H;i++)\n\t{\n\t  for(int j=0;j<W;j++)\n\t    {\n\t      if(board[i][j]=='.' &&black[i][j]&&!white[i][j]) bnum++;\n\t      if(board[i][j]=='.' && white[i][j]&&!black[i][j]) wnum++;\n\t    }\n\t}\n      cout << bnum << ' ' << wnum << endl;\n    }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nint main() {\n\n  int dx[4] = { -1,  0,  0,  1 };\n  int dy[4] = {  0, -1,  1,  0 };\n\n  string input;\n\n  long long int w, h;\n\n  while( true ) {\n\n    cin >> w >> h;\n\n    if ( w == 0 ) break;\n\n    vector<string> map;\n\n    for ( long long int y = 0; y < h; y++ ) {\n\n      cin >> input;\n\n      map.push_back( input );\n\n    }\n\n    long long int ans_b = 0;\n    long long int ans_w = 0;\n\n    for ( long long int y = 0; y < h; y++ ) {\n\n      for ( long long int x = 0; x < w; x++ ) {\n\n\tif ( map[y][x] == '.' ) {\n\n\t  map[y][x] = 'C';\n\t  queue<int> qx, qy;\n\t  qx.push( x );\n\t  qy.push( y );\n\n\t  long long int ans = 1;\n\t  bool flag_b = false;\n\t  bool flag_w = false;\n\n\t  while( qx.size() > 0 ) {\n\n\t    int mx = qx.front();\n\t    int my = qy.front();\n\t    qx.pop();\n\t    qy.pop();\n\n\t    for ( int i = 0; i < 4; i++ ) {\n\n\t      mx += dx[i];\n\t      my += dy[i];\n\n\t      if ( mx >= 0 && mx < w && my >= 0 && my < h ) {\n\n\t\tif ( map[my][mx] == '.' ) {\n\t\t  map[my][mx] = 'C';\n\t\t  qx.push(mx);\n\t\t  qy.push(my);\n\t\t  ans++;\n\t\t}else if ( map[my][mx] == 'B' ) {\n\t\t  flag_b = true;\n\t\t}else if ( map[my][mx] == 'W' ) {\n\t\t  flag_w = true;\n\t\t}\n\n\t      }\n\n\t      mx -= dx[i];\n\t      my -= dy[i];\n\n\t    }\n\n\t  }\n\n\t  if ( flag_b == true && flag_w == false ) {\n\t    ans_b += ans;\n\t  }else if ( flag_b == false && flag_w == true ) {\n\t    ans_w += ans;\n\t  }\n\n\t}\n\n      }\n\n    }\n\n    cout << ans_b << \" \" << ans_w << endl;\n\n  }\n\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <cmath>\n#include <cstdio>\n#include <istream>\n#include <sstream>\n#include <iomanip>\nusing namespace std;\n\ntypedef ostringstream OSS;\ntypedef istringstream ISS;\n\ntypedef vector<int> VI;\ntypedef vector< VI > VVI;\n\ntypedef long L;\ntypedef long long LL;\n\ntypedef pair<int, int> PII;\ntypedef vector<PII> VPII;\n\n#define fst first\n#define snd second\n\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {1, 0, -1, 0};\n\nconst string type = \"BW\";\n\n\nvoid dfs(vector< vector< pair<char, int> > >& area, int curx, int cury, int t) {\n\tint H = area.size();\n\tint W = area[0].size();\n\n\tfor (int i = 0; i < 4; i++) {\n\t\tint x = curx + dx[i];\n\t\tint y = cury + dy[i];\n\n\t\tif (!(0 <= x && x < W && 0 <= y && y < H) ||\n\t\t\ttype.find(area[y][x].fst) != string::npos ||\n\t\t\tarea[y][x].snd & t\n\t\t\t) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tarea[y][x].snd |= t;\n\t\tdfs(area, x, y, t);\n\t}\n}\n\nint main(void) {\n\tfor (int W, H; cin >> W >> H, W; ) {\n\t\tvector< vector< pair<char, int> > > area(H, vector< pair<char, int> >(W, pair<char, int>('.', 0)) );\n\t\tfor (int y = 0; y < H; y++) {\n\t\t\tfor (int x = 0; x < W; x++) {\n\t\t\t\tcin >> area[y][x].fst;\n\t\t\t}\n\t\t}\n\n\t\tfor (int t = 0; t < 2; t++) {\n\t\t\tfor (int y = 0; y < H; y++) {\n\t\t\t\tfor (int x = 0; x < W; x++) {\n\t\t\t\t\tif (type.find(area[y][x].fst) == t) {\n\t\t\t\t\t\tdfs(area, x, y, t + 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// cnt\n\t\tint cnt[2] = {0, 0};\n\t\tfor (int y = 0; y < H; y++) {\n\t\t\tfor (int x = 0; x < W; x++) {\n\t\t\t\tif (area[y][x].snd == 1 || area[y][x].snd == 2) {\n\t\t\t\t\tcnt[area[y][x].snd - 1]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//\n\t\tcout << cnt[0] << \" \" << cnt[1] << endl;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nint w, h;\nchar input[50][50];\nint dy[] = {-1, 0, 1, 0};\nint dx[] = {0, 1, 0, -1};\nbool touched[2][50][50];\n\nbool isOver(int y, int x){\n  if(y<0 || y>=h) return true;\n  if(x<0 || x>=w) return true;\n  return false;\n}\n\nvoid dfs(int y, int x, int p){\n  touched[p][y][x] = true;\n  for(int i=0;i<4;i++){\n    int ny = y + dy[i];\n    int nx = x + dx[i];\n    if(isOver(ny, nx)) continue;\n    if(input[ny][nx] != '.') continue;\n    if(touched[p][ny][nx]) continue;\n    dfs(ny, nx, p);\n  }\n}\n\nmain(){\n  while(cin >> w >> h && (w|h)){\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        cin >> input[i][j];\n      }\n    }\n    fill(touched[0][0], touched[2][0], false);\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        if(input[i][j] == '.'){\n          for(int k=0;k<4;k++){\n            int ny = i + dy[k];\n            int nx = j + dx[k];\n            if(isOver(ny, nx)) continue;\n            if(input[ny][nx] == 'B' && !touched[0][i][j]) dfs(i, j, 0);\n            if(input[ny][nx] == 'W' && !touched[1][i][j]) dfs(i, j, 1);\n          }\n        }\n      }\n    }\n    int ans1 = 0, ans2 = 0;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        if(touched[0][i][j] && !touched[1][i][j]) ans1++;\n        if(!touched[0][i][j] && touched[1][i][j]) ans2++;\n      }\n    }\n    cout << ans1 << ' ' << ans2 << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef pair <int,int> pii;\n#define FST first\n#define SEC second\n\nint w,h;\nint dd[8]={0,1,0,-1,0};\n\nvoid bfs(char map[50][50]){\n  stack <pii> q;\n  int bc=0,wc=0;\n  rep(i,h){\n    rep(j,w){\n      if(map[j][i]=='.'){\n\tq.push(pii(j,i));\n\tint count=0;\n\tpii state=pii(0,0);\n\twhile(!q.empty()){\n\t  int cx=q.top().FST,cy=q.top().SEC;\n\t  q.pop();\n\t  if(map[cx][cy]=='.')\n\t    count++;\n\t  map[cx][cy]='#';\n\t  rep(r,4){\n\t    int nx=cx+dd[r],ny=cy+dd[r+1];\n\t    if(nx<0 || ny<0 || nx>=w || ny>=h || map[nx][ny]=='#')\n\t      continue;\n\t    if(map[nx][ny]=='B'){\n\t      state.FST=1;\n\t      continue;\n\t    }\n\t    if(map[nx][ny]=='W'){\n\t      state.SEC=1;\n\t      continue;\n\t    }\n\t    q.push(pii(nx,ny));\n\t  }\n\t}\n\tif(state==pii(1,0))\n\t  bc+=count;\n\tif(state==pii(0,1))\n\t  wc+=count;\n      } \n    }\n  }\n  printf(\"%d %d\\n\",bc,wc);\n}\n\nint main(){\n  for(;;){\n    cin >> w >> h;\n    if(!(w+h)) break;\n    char map[50][50];\n    rep(i,h){\n      rep(j,w){\n        cin >> map[j][i];\n      }\n    }\n    bfs(map);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n#define inRange(x,a,b) (a <= x && x < b)\n\nint dx[4] = {-1,0,1,0};\nint dy[4] = {0,1,0,-1};\n\nint main(){\n    int w, h;\n    while(cin >> w >> h, w+h){\n        char mat[h][w];\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                cin >> mat[i][j];\n            }\n        }\n\n        int black = 0, white = 0;\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                if(mat[i][j] != '.')    continue;\n                queue<pair<int,int>> q;\n                q.push({i,j});\n                bool f = false, g = false;\n                int area = 0;\n                while(!q.empty()){\n                    pair<int,int> now = q.front(); q.pop();\n                    int y = now.first, x = now.second;\n                    if(mat[y][x] != '.'){\n                        if(mat[y][x] == 'W')    f = true;\n                        if(mat[y][x] == 'B')    g = true;\n                        continue;\n                    }\n                    area++;\n                    mat[y][x] = 'x';\n                    for(int k = 0; k < 4; k++){\n                        int ny = y + dy[k];\n                        int nx = x + dx[k];\n                        if(inRange(ny, 0, h) && inRange(nx, 0, w) && mat[ny][nx] != 'x'){\n                            q.push({ny,nx});\n                        }\n                    }\n                }\n\n                if(f && !g) white += area;\n                if(g && !f) black += area;\n            }\n        }\n\n        cout << black << \" \" << white << endl;\n\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n\nusing namespace std;\n\nint w, h;\nchar a[50][50];\nint BW[50][50];\nint dx[] = { 1,0,0,-1 }, dy[] = { 0,1,-1,0 };\n\nvoid dfs(int x, int y, int flag) {\n\tfor (int i = 0; i < 4; ++i) {\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\tif (nx < 0 || nx >= h || ny < 0 || ny >= w) continue;\n\t\tif (a[nx][ny] != '.') continue;\n\t\tif (BW[nx][ny] & flag) continue;\n\t\tBW[nx][ny] |= flag;\n\t\tdfs(nx, ny, flag);\n\t}\n}\n\nint main() {\n\twhile (cin >> w >> h, w) {\n\t\tmemset(BW, 0, sizeof(BW));\n\t\tfor (int i = 0; i < h; ++i)\n\t\t\tfor (int j = 0; j < w; ++j)\n\t\t\t\tcin >> a[i][j];\n\t\tfor (int i = 0; i < h; ++i) {\n\t\t\tfor (int j = 0; j < w; ++j) {\n\t\t\t\tif (a[i][j] == 'B') dfs(i, j, 1);\n\t\t\t\telse if (a[i][j] == 'W') dfs(i, j, 2);\n\t\t\t}\n\t\t}\n\t\tint cntb = 0, cntw = 0;\n\t\tfor (int i = 0; i < h; ++i) {\n\t\t\tfor (int j = 0; j < w; ++j) {\n\t\t\t\tif (BW[i][j] == 1) cntb++;\n\t\t\t\telse if (BW[i][j] == 2) cntw++;\n\t\t\t}\n\t\t}\n\t\tcout << cntb << \" \" << cntw << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n\nint w,h;\n\nint isKakoi(int y,int x,char data[50][50]){\n    bool bf=false,wf=false;\n    int dy[]={-1,0,1,0};\n    int dx[]={0,-1,0,1};\n    bool visited[50][50]={};\n    \n    queue<pair<int,int> > que;\n    \n    que.push( pair<int,int>(y,x) );\n    visited[y][x]=true;\n    \n    while(que.size()){\n        int qff=que.front().first,qfs=que.front().second;\n        rep(i,4){\n            if( qff+dy[i]<h && qff+dy[i]>=0 && qfs+dx[i]<w && qfs+dx[i]>=0 && visited[ qff+dy[i] ][ qfs+dx[i] ]==false){\n                if(data[qff+dy[i]][qfs+dx[i]]=='B')bf=true;\n                else if(data[qff+dy[i]][qfs+dx[i]]=='W')wf=true;\n                else{\n                    que.push( pair<int,int>(qff+dy[i] , qfs+dx[i]) );\n                    visited[ qff+dy[i] ][ qfs+dx[i] ]=true;\n                }\n            }\n        }\n        que.pop();\n    }\n    if(bf && wf)return -1;\n    else if(bf)return 0;\n    else if(wf)return 1;\n    \n    return 100;\n}\n\n\nint main(){\n    while(cin>>w>>h){\n        if(w==0 && h==0)break;\n        \n        char data[50][50];\n        rep(i,h)cin>>data[i];\n        \n        \n        int bk=0,wh=0;\n        rep(i,h){\n            rep(j,w){\n                if(data[i][j]=='.'){\n                    int res=isKakoi(i,j,data);\n                    if( res==0 )wh++;\n                    if( res==1 )bk++;\n                }\n            }\n        }\n        \n        cout<<wh<<\" \"<<bk<<endl;\n    }\n    \n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <climits>\n\n#define INF INT_MAX>>1 \n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n\nusing namespace std;\n\nint dx[] = {-1, 0, 0, 1};\nint dy[] = {0, -1, 1, 0};\n\nint w, h;\nint white, black;\nint tmp_count;\nchar tmp_color;\nchar a[55][55];\n\nvoid dfs(int y, int x){\n\tif(y<0 || h<=y || x<0 || w<=x) return;\n\tif(a[y][x] == '*') return;\n\tif(a[y][x] == 'W' || a[y][x] == 'B'){\n\t\tif(tmp_color == NULL) tmp_color = a[y][x];\n\t\telse if(tmp_color != a[y][x]) tmp_count = -INF;\n\t\treturn;\n\t}\n\n\ta[y][x] = '*';\n\ttmp_count++;\n\trep(i, 4){\n\t\tdfs(y+dy[i], x+dx[i]);\n\t}\n}\n\nint main(void){\n\twhile(1){\n\t\tcin >> w >> h;\n\t\tif(!w && !h) break;\n\t\n\t\tfill(a[0], a[54], '\\0');\n\t\trep(i, h){\n\t\t\tcin >> a[i];\n\t\t}\n\n\t\twhite = black = 0;\n\t\trep(i, h){\n\t\t\trep(j, w){\n\t\t\t\ttmp_count = 0;\n\t\t\t\ttmp_color = NULL;\n\t\t\t\tif(a[i][j] == '.'){\n\t\t\t\t\tdfs(i, j);\n\t\t\t\t\tif(0 < tmp_count){\n\t\t\t\t\t\tif(tmp_color == 'W') white += tmp_count;\n\t\t\t\t\t\telse if(tmp_color == 'B') black += tmp_count;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << black << \" \" << white << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\nvoid search(char a[51][51], int c[51][51], int h, int w, int s, int t, int v, char p)\n{\n  if(a[s][t] == p){\n    c[s][t] = -v;\n    return ;\n  } else if(a[s][t] != '.' || c[s][t] < 0 || c[s][t] == v){\n    return ;\n  }\n  c[s][t] = (c[s][t] > 0)? -3 : v;\n\n  if(s > 0){\n    search(a, c, h, w, s-1, t, v, p);\n  }\n  if(s < h-1){\n    search(a, c, h, w, s+1, t, v, p);\n  }\n  if(t > 0){\n    search(a, c, h, w, s, t-1, v, p);\n  }\n  if(t < w-1){\n    search(a, c, h, w, s, t+1, v, p);\n  }\n\n  return ;\n}\n\nvoid func(char a[51][51], int c[51][51], int h, int w, char p, int s, int t)\n{\n  int v = (p == 'W')? 1 : 2;\n\n  if(s > 0){\n    search(a, c, h, w, s-1, t, v, p);\n  }\n  if(s < h-1){\n    search(a, c, h, w, s+1, t, v, p);\n  }\n  if(t > 0){\n    search(a, c, h, w, s, t-1, v, p);\n  }\n  if(t < w-1){\n    search(a, c, h, w, s, t+1, v, p);\n  }\n\n  return ;\n}\n\nint main(int argc, char **argv)\n{\n  int w, h, c[51][51], cw, cb;\n  char a[51][51];\n\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0){\n      break;\n    }\n    fill(&c[0][0], &c[h][w], 0);\n\n    for(int i = 0; i < h; i++){\n      scanf(\"%s\", a[i]);\n    }\n\n    cw = cb = 0;\n    for(int i = 0; i < h; i++){\n      for(int j = 0; j < w; j++){\n\tif(c[i][j] == 0 && a[i][j] != '.'){\n\t  func(a, c, h, w, a[i][j], i, j);\n\t}\n      }\n    }\n\n    for(int i = 0; i < h; i++){\n      for(int j = 0; j < w; j++){\n\tif(c[i][j] == 1){\n\t  cw++;\n\t} else if(c[i][j] == 2){\n\t  cb++;\n\t}\n      }\n    }\n\n    cout << cb << \" \" << cw << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n#define INF (int32)1e9\n#define REP(i, n) for(int64 i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int64 i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\nconst double eps = 1e-10;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value!=0>::type\nfill_v(U &u,const V... v){u=U(v...);}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_v(U &u,const V... v){\n  for(auto &e:u) fill_v<T>(e,v...);\n}\n\nint64 dy[4] = {-1, 0, 0, 1};\nint64 dx[4] = {0, -1, 1, 0};\n\nint main(void) {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int64 w, h;\n  while (cin >> w >> h && w+h) {\n    vector<string> a(h);\n    REP(i, h) {\n      cin >> a[i];\n    }\n    vector<vector<int>> col(h, vector<int>(w, -1));\n    auto cango = [&](int64 y, int64 x) {\n      return 0<=y&&y<h&&0<=x&&x<w&&col[y][x]==-1;\n    };\n\n    REP(y, h) {\n      REP(x, w) {\n        if (col[y][x] != -1 || a[y][x] != '.') continue;\n        queue<PII> q;\n        queue<PII> vis;\n        vis.emplace(y, x);\n        q.emplace(y, x);\n        col[y][x] = 0;\n        int touch = 0;\n        while (q.size()) {\n          int64 ny, nx;\n          tie(ny, nx) = q.front(); q.pop();\n          REP(k, 4) {\n            int64 yy, xx;\n            yy = ny + dy[k]; xx = nx + dx[k];\n            if (!cango(yy, xx)) continue;\n            if (a[yy][xx] == 'W') touch |= 1;\n            else if (a[yy][xx] == 'B') touch |= 2;\n            else {\n              col[yy][xx] = 0;\n              q.emplace(yy, xx);\n              vis.emplace(yy, xx);\n            }\n          }\n        }\n        while (vis.size()) {\n          int64 yy, xx;\n          tie(yy, xx) = vis.front(); vis.pop();\n          col[yy][xx] = touch;\n        }\n      }\n    }\n    int64 cnt[2] = {};\n    REP(y, h) {\n      REP(x, w) {\n        if (col[y][x] == 1) {\n          cnt[0]++;\n        } else if (col[y][x] == 2) {\n          cnt[1]++;\n        }\n      }\n    }\n    cout << cnt[1] << \" \" << cnt[0] << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\nusing ll = long long;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\n\nvoid solve(int w,int h){\n    string s[h];\n    rep(i,h)cin>>s[i];\n    vector<vector<int>> dw(h,vector<int>(w,inf)),db(h,vector<int>(w,inf));\n    queue<pair<int,int>> que;\n    rep(i,h)rep(j,w){\n        if(s[i][j]=='W'){\n            dw[i][j]=0;\n            que.emplace(i,j);\n        }\n    }\n    int d[]{1,0,-1,0,1};\n    while(que.size()){\n        auto p=que.front();que.pop();\n        int x=p.first,y=p.second;\n        rep(i,4){\n            int nx=x+d[i],ny=y+d[i+1];\n            if(nx<0||nx>=h||ny<0||ny>=w)continue;\n            if(s[nx][ny]!='.')continue;\n            if(dw[nx][ny]>dw[x][y]+1){\n                dw[nx][ny]=dw[x][y]+1;\n                que.emplace(nx,ny);\n            }\n        }\n    }\n    rep(i,h)rep(j,w){\n        if(s[i][j]=='B'){\n            db[i][j]=0;\n            que.emplace(i,j);\n        }\n    }\n    while(que.size()){\n        auto p=que.front();que.pop();\n        int x=p.first,y=p.second;\n        rep(i,4){\n            int nx=x+d[i],ny=y+d[i+1];\n            if(nx<0||nx>=h||ny<0||ny>=w)continue;\n            if(s[nx][ny]!='.')continue;\n            if(db[nx][ny]>db[x][y]+1){\n                db[nx][ny]=db[x][y]+1;\n                que.emplace(nx,ny);\n            }\n        }\n    }\n    int aw=0,ab=0;\n    rep(i,h)rep(j,w){\n        if(dw[i][j]!=inf&&db[i][j]==inf&&s[i][j]!='W')++aw;\n        if(dw[i][j]==inf&&db[i][j]!=inf&&s[i][j]!='B')++ab;\n    }\n    cout<<ab<<\" \"<<aw<<endl;\n}\n\nint main(){\n    int w,h;\n    while(cin>>w>>h,w!=0)solve(w,h);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include <set>\n#include <cctype>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\nusing namespace std;\n#define INF 100000000\n#define MAXH 64\n#define MAXW 64\n\ntypedef long long ll;\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\n\nchar a[MAXH][MAXW];\nint w, h;\n\nint main(void) {\n    while (1) {\n        cin >> w >> h;\n        if (w == 0 && h == 0) break;\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                cin >> a[i][j];\n            }\n        }\n        int white = 0, black = 0;\n        bool used[MAXH][MAXW];\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                if (a[i][j] != '.') continue;\n                for (int k = 0; k < h; k++) {\n                    for (int l = 0; l < w; l++) {\n                        used[k][l] = false;\n                    }\n                }\n                queue<int> X, Y;\n                X.push(j); Y.push(i);\n                bool white_flag = false, black_flag = false;\n                while (!X.empty()) {\n                    int x = X.front(); X.pop();\n                    int y = Y.front(); Y.pop();\n                    used[y][x] = true;\n                    for (int k = 0; k < 4; k++) {\n                        int nx = x + dx[k];\n                        int ny = y + dy[k];\n                        if (0 <= nx && nx < w && 0 <= ny && ny < h) {\n                            if (a[ny][nx] == 'W') white_flag = true;\n                            else if (a[ny][nx] == 'B') black_flag = true;\n                            else if (!used[ny][nx]) {\n                                X.push(nx);\n                                Y.push(ny);\n                            }\n                        }\n                    }\n                }\n                if (white_flag && !black_flag) white++;\n                if (!white_flag && black_flag) black++;\n            }\n        }\n        cout << black << \" \" << white << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint W, H;\nvector<string> m;\nvector<string> m2;\n\nint dx[4] = {0, 0, 1, -1};\nint dy[4] = {1, -1, 0, 0};\n\nvoid paint(int x, int y, char c) {\n\tif (x < 0 || x >= W || y < 0 || y >= H) return;\n\n\tchar c2 = c-'A'+'a';\n\tif (m[y][x] == '.') {\n\t\tm[y][x] = c2;\n\t}\n\telse if (m[y][x] == 'W' || m[y][x] == 'B') return;\n\telse if (m[y][x] == '#') return;\n\telse if (m[y][x] == c2) return;\n\telse m[y][x] = '#';\n\n\tfor (int d = 0; d < 4; ++d) {\n\t\tpaint(x+dx[d], y+dy[d], c);\n\t}\n}\n\nint main() {\n\twhile ( cin >> W >> H, W || H ) {\n\t\tm.resize(H);\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tcin >> m[y];\n\t\t}\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tif (m[y][x] == 'W' || m[y][x] == 'B') {\n\t\t\t\t\tfor (int d = 0; d < 4; ++d) {\n\t\t\t\t\t\tpaint(x+dx[d], y+dy[d], m[y][x]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint w = 0, b = 0;\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tfor (int x = 0; x < W; ++x) {\n\t\t\t\tif (m[y][x] == 'w') ++w;\n\t\t\t\tif (m[y][x] == 'b') ++b;\n\t\t\t}\n\t\t}\n\t\tcout << b << \" \" << w << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n#include <unordered_set>\n#include <unordered_map>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n#include <utility>\n#include <memory>\n#include <functional>\n#include <deque>\n#include <cctype>\n#include <ctime>\n#include <numeric>\n#include <list>\n#include <iomanip>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll;\ntypedef vector<vector<long long> > vvll;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n#define GET_MACRO(_1, _2, _3, NAME, ...) NAME\n#define _rep(i,n) _rep2((i),0,(n))\n#define _rep2(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(...) GET_MACRO(__VA_ARGS__, _rep2, _rep)(__VA_ARGS__)\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define fi first\n#define se second\n#define mkp make_pair\n#define DEBUG\n#ifdef DEBUG\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#else\n#define dump(x) \n#define debug(x) \n#endif\n\n#define MOD 1000000007LL\n#define EPS 1e-8\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n#define maxs(x,y) x=max(x,y)\n#define mins(x,y) x=min(x,y)\n\nvvint vv;\nvvint used[3];\nint w,h;\n\nvoid sta(int,int,int);\n\nint dd[] = {0,1,0,-1,0};\nbool inside(int a, int b){\n\treturn 0<=a&&a<h&&0<=b&&b<w;\n}\n\nvoid dfs(int a, int b, int c){\n\tif(used[c][a][b]) return;\n\tused[c][a][b] = 1;\n\tsta(a, b, c);\n}\n\nvoid sta(int a, int b, int c){\n\trep(i,4){\n\t\tint na = a+dd[i];\n\t\tint nb = b+dd[i+1];\n\t\tif(inside(na, nb) && vv[na][nb] == 0){\n\t\t\tdfs(na, nb, c);\n\t\t}\n\t}\n}\n\nvoid mainmain(){\n\twhile(cin>>w>>h,w||h){\n\t\tinitvv(vv, h, w);\n\t\tinitvv(used[1], h, w, 0);\n\t\tinitvv(used[2], h, w, 0);\n\t\trep(i,h){\n\t\t\trep(j,w){\n\t\t\t\tchar t;\n\t\t\t\tcin>>t;\n\t\t\t\tif(t=='.') vv[i][j] = 0;\n\t\t\t\tif(t=='B') vv[i][j] = 1;\n\t\t\t\tif(t=='W') vv[i][j] = 2;\n\t\t\t}\n\t\t}\n\t\trep(i,h){\n\t\t\trep(j,w){\n\t\t\t\tif(vv[i][j]){\n\t\t\t\t\tsta(i,j,vv[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint a = 0;\n\t\tint b = 0;\n\t\trep(i,h){\n\t\t\trep(j,w){\n\t\t\t\tif(used[1][i][j] && !used[2][i][j]) a++;\n\t\t\t\tif(!used[1][i][j] && used[2][i][j]) b++;\n\t\t\t}\n\t\t}\n\t\tcout<<a<<\" \"<<b<<endl;\n\t}\n}\n\n\nsigned main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout<<fixed<<setprecision(20);\n    mainmain();\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <limits.h>\n#include <math.h>\n#include <set>\n#include <stack>\n#include <stdlib.h>\n#include <string>\n#include <vector>\n\n#define el endl\n#define fd fixed\n#define INF INT_MAX/2-1\n#define pb push_back\n\nusing namespace std;\n\nchar map[50][50];\nbool memoB[50][50];\nbool memoW[50][50];\n\nvoid search(int x, int y, int w, int h, char color) {\n  if (color == 'B') {\n    memoB[x][y] = true;\n  } else {\n    memoW[x][y] = true;\n  }\n  if (x > 0 && map[x-1][y] == '.') {\n    if ((color == 'B' && !memoB[x-1][y]) || (color == 'W' && !memoW[x-1][y])) {\n      search(x-1, y, w, h, color);\n    }\n  }\n  if (y > 0 && map[x][y-1] == '.') {\n    if ((color == 'B' && !memoB[x][y-1]) || (color == 'W' && !memoW[x][y-1])) {\n      search(x, y-1, w, h, color);\n    }\n  }\n  if (x < w-1 && map[x+1][y] == '.') {\n    if ((color == 'B' && !memoB[x+1][y]) || (color == 'W' && !memoW[x+1][y])) {\n      search(x+1, y, w, h, color);\n    }\n  }\n  if (y < h-1 && map[x][y+1] == '.') {\n    if ((color == 'B' && !memoB[x][y+1]) || (color == 'W' && !memoW[x][y+1])) {\n      search(x, y+1, w, h, color);\n    }\n  }\n}\n\nint main() {\n  int w, h, cntB, cntW, resB, resW;\n  char tmp;\n  while (cin >> w >> h, w | h) {\n    cntB = cntW = 0;\n    for (int i = 0; i < w; i++) {\n      for (int j = 0; j < h; j++) {\n        cin >> tmp;\n        map[i][j] = tmp;\n        if (tmp == '.') memoB[i][j] = false; memoW[i][j] = false;\n        if (tmp == 'B') memoB[i][j] = true, memoW[i][j] = false, cntB++;\n        if (tmp == 'W') memoB[i][j] = false, memoW[i][j] = true, cntW++;\n      }\n    }\n    for (int i = 0; i < w; i++) {\n      for (int j = 0; j < h; j++) {\n        if (map[i][j] == 'B') search(i, j, w, h, 'B');\n        if (map[i][j] == 'W') search(i, j, w, h, 'W');\n      }\n    }\n    resB = resW = 0;\n    for (int i = 0; i < w; i++) {\n      for (int j = 0; j < h; j++) {\n        if (memoB[i][j] && !memoW[i][j]) resB++;\n        if (!memoB[i][j] && memoW[i][j]) resW++;\n      }\n    }\n    cout << resB-cntB << \" \" << resW-cntW << el;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "\n#include \"bits/stdc++.h\"\nusing namespace std;\n\nvector<vector<int>>field;\nvector<vector<bool>>used;\n\n\nint dx[4] = { -1,0,1,0 };\nint dy[4] = { 0,1,0,-1 };\n\npair<int, int>getans(const int y, const int x) {\n\tif (used[y][x]) {\n\t\treturn make_pair(field[y][x]?field[y][x]:3, 0);\n\t}\n\tused[y][x] = true;\n\tif (field[y][x]) {\n\t\treturn make_pair(field[y][x], 0);\n\t}\n\tint nowcolor = 3;\n\tint nowcount = 1;\n\tfor (int i = 0; i < 4; ++i) {\n\t\tpair<int, int>p(getans(y + dy[i], x + dx[i]));\n\t\tnowcolor &= p.first;\n\t\tnowcount += p.second;\n\t\t\n\t}\n\treturn make_pair(nowcolor, nowcount);\n}\n\nint main() {\n\twhile (1) {\n\t\tint w, h; cin >> w >> h;\n\t\tfield.clear();\n\t\tused.clear();\n\t\tfield.resize(h + 2);\n\t\tused.resize(h + 2);\n\t\tfor (int i = 0; i < h + 2; ++i) {\n\t\t\tused[i].resize(w + 2);\n\t\t}\n\t\tfor (int i = 0; i < w + 2; ++i) {\n\t\t\tfield[0].push_back(3);\n\t\t}\n\t\tif (!w)break;\n\t\tfor (int i = 0; i < h; ++i) {\n\t\t\tfield[i + 1].push_back(3);\n\t\t\tstring st; cin >> st;\n\t\t\tfor (int j = 0; j < w; ++j) {\n\t\t\t\tif (st[j] == '.') {\n\t\t\t\t\tfield[i + 1].push_back(0);\n\t\t\t\t}\n\t\t\t\telse if (st[j] == 'W') {\n\t\t\t\t\tfield[i + 1].push_back(1);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfield[i + 1].push_back(2);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfield[i + 1].push_back(3);\n\t\t}\n\t\tfor (int i = 0; i < w + 2; ++i) {\n\t\t\tfield[h+1].push_back(3);\n\t\t}\n\t\tint whnum = 0;\n\t\tint blnum = 0;\n\t\tfor (int y = 0; y < h + 2; ++y) {\n\t\t\tfor (int x = 0; x < w + 2; ++x) {\n\t\t\t\tif (!used[y][x]) {\n\t\t\t\t\tpair<int, int>a(getans(y, x));\n\t\t\t\t\tif (a.first == 1)whnum+=a.second;\n\t\t\t\t\tif (a.first == 2)blnum+= a.second;\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << blnum << \" \" <<whnum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Surrounding Area\n#include<bits/stdc++.h>\nusing namespace std;\n#define TMP 9999\n#define INF 1000\n\nint n, m;\nvector<vector<int> > board;\n\n//4\nint dir[4][2]={{-1,0}, {0,1}, {1,0}, {0,-1}};\n\nvoid print(){\n  for(int i=0; i<n; i++){\n    for(int j=0; j<m; j++)\n      printf(\"%5d\", board[i][j]);\n    puts(\"\");\n  }\n}\n\nbool solve(int x, int y, int c){\n  if(!(0<=x && x<n && 0<=y && y<m))return true;//\n  if(board[x][y]==TMP)return true;//\n  if(board[x][y]==INF)return false;//\n  if(board[x][y]==c)return true;\n  if(board[x][y]==-c)return false;\n  if(board[x][y]==2*c)return true;\n  board[x][y]=TMP;\n  bool flag=true;\n  for(int i=0; i<4; i++){\n    if(!solve(x+dir[i][0], y+dir[i][1], c)){\n      flag=false;\n      break;\n    }\n  }\n  if(flag){\n    board[x][y]=c*2;\n    return true;\n  }\n  else{\n    board[x][y]=INF;\n    return false;\n  }\n}\n\nint main(){\n  while(true){\n    cin>>n>>m;\n    board.clear();\n    if(n==0 && m==0)break;\n    for(int i=0; i<n; i++){\n      vector<int> tmp;\n      for(int j=0; j<m; j++){\n        char c;\n        cin>>c;\n        int t;\n        if(c=='.')t=0;\n        if(c=='W')t=1;\n        if(c=='B')t=-1;\n        tmp.push_back(t);\n      }\n      board.push_back(tmp);\n    }\n\n    for(int i=0; i<n; i++){\n      for(int j=0; j<m; j++){\n        if(board[i][j]==1){\n          for(int k=0; k<4; k++)solve(i+dir[k][0], j+dir[k][1], 1);\n        }\n        if(board[i][j]==-1){\n          for(int k=0; k<4; k++)solve(i+dir[k][0], j+dir[k][1], -1);\n        }\n      }\n    }\n\n    int nw=0, nb=0;\n    for(int i=0; i<n; i++)\n      for(int j=0; j<m; j++)\n        if(board[i][j]==2)nw++;\n        else if(board[i][j]==-2)nb++;\n    printf(\"%d %d\\n\", nb, nw);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define F first\n#define S second\n#define INF 1 << 30\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint f[50][50], c[50][50];\nchar  l[50][51];\nint w, h, dx[] = {0,-1,0,1}, dy[] = {-1,0,1,0};\n\n// black 1 white 2\nint dfs(int y, int x){\n  if(l[y][x] == 'B') return 1;\n  if(l[y][x] == 'W') return 2;\n\n  int ret = 0;\n  rep(d, 4){\n    int ny = y+dy[d], nx = x+dx[d];\n    if(ny < 0 || nx < 0 || ny >= h || nx >= w || f[ny][nx]) continue;\n    f[ny][nx] = 1;\n    ret |= dfs(ny, nx);\n  }\n  return ret;\n}\n\nint main(){\n  while(scanf(\"%d%d\", &w, &h) && w+h){\n    rep(i, h) scanf(\"%s\", l[i]);\n    memset(c, 0, sizeof(c));\n\n    rep(i, h) rep(j, w){\n      if(l[i][j] == 'B' || l[i][j] == 'W' || c[i][j]) continue;\n      //      printf(\"%d %d\\n\", i, j);\n      memset(f, 0, sizeof(f));\n      f[i][j] = 1;\n      int flag = dfs(i, j);\n      //      printf(\"%d\\n\", flag);\n      rep(k, h) rep(m, w) if(f[k][m] != 0 && l[k][m] == '.') c[k][m] = flag;\n    }\n\n    int black = 0, white = 0;\n    rep(i, h) rep(j, w){\n      if(c[i][j] == 1) black++;\n      else if(c[i][j] == 2) white++;\n    }\n\n    printf(\"%d %d\\n\", black, white);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int (i)=(0);(i)<(int)(n);++(i))\nusing ll = long long;\nusing P = pair<int, int>;\nusing namespace std;\n\ntemplate<class T> void vin(vector<T>& v, int n) {\n    v.resize(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> v[i];\n    }\n}\n\nint dr[] = { 1, 0, -1, 0 };\nint dc[] = { 0, 1, 0, -1 };\n\nint main() {\n    int w, h;\n    while (cin >> w >> h) {\n        if (w == 0 and h == 0) break;\n        string board[51];\n        rep(r, h) cin >> board[r];\n        int wc = 0, bc = 0;\n        rep(r, h) rep(c, w) {\n            if (board[r][c] != 'B' and board[r][c] != 'W') continue;\n            queue<P> que;\n            que.push(make_pair(r, c));\n            bitset<50*50+1> visited;\n            visited[r*w+c] = 1;\n            while (que.size()) {\n                P p = que.front();\n                que.pop();\n                rep(i, 4) {\n                    int nr = p.first + dr[i], nc = p.second + dc[i];\n                    if (nr < 0 or nr >= h or nc < 0 or nc >= w or visited[nr*w+nc] == 1) continue;\n                    if (board[nr][nc] == 'W' or board[nr][nc] == 'B') continue;\n                    if (board[nr][nc] == '.') {\n                        if (board[r][c] == 'W') board[nr][nc] = 'w';\n                        if (board[r][c] == 'B') board[nr][nc] = 'b';\n                    }\n                    else {\n                        if (board[r][c] == 'W' and board[nr][nc] == 'b') board[nr][nc] = 'x';\n                        if (board[r][c] == 'B' and board[nr][nc] == 'w') board[nr][nc] = 'x';\n                    }\n                    visited[nr*w+nc] = 1;\n                    que.push(make_pair(nr, nc));\n                }\n            }\n        }\n        rep(rr, h) rep(cc, w) {\n            if (board[rr][cc] == 'w') wc++;\n            else if (board[rr][cc] == 'b') bc++;\n        }\n        cout << bc << \" \" << wc << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <cmath>\n#include <algorithm>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <vector>\n#include <string>\n#define REP(i,n) for(int i=0;i<n;i++)\ntypedef long long ll;\nusing namespace std;\ntypedef vector<ll> vl;\ntypedef pair<ll,ll> pll;\ntypedef vector<pll> vpll;\ntypedef vector<string> vs;\n\nint X[4]={0,0,-1,1};\nint Y[4]={-1,1,0,0};\nint w,h;\nint ans[50][50];\n\nint step1(int x,int y){ //0=0  1=B 2=W 3=&\t\n\tbool w(false),b(false);\n\tfor(int i=0;i<4;i++){\n//\t\tif(x+X[i]<w && x+X[i]>-1 && y+Y[i]<h && y+Y[i]>-1){\n\t\t\tif(ans[x+X[i]][y+Y[i]]==-1){b=true;}\n\t\t\tif(ans[x+X[i]][y+Y[i]]==-2){w=true;}\n//\t\t}\n\t}\n\tif(w&&b){return 3;}\n\telse if(w&&!b){return 2;}\n\telse if(!w&&b){return 1;}\n\telse if(!w&&!b){return 0;}\n}\n\nvoid step2(int x,int y,int z){\n\tans[x][y]=z;\n\tfor(int i=0;i<4;i++){\n\t\tif(x+X[i]<w && x+X[i]>-1 && y+Y[i]<h && y+Y[i]>-1){\n\t\t\tif(ans[x+X[i]][y+Y[i]]==0){step2(x+X[i],y+Y[i],z);}\n\t\t}\n\t}\n}\n\nint main() \n{\n\twhile(cin>>w>>h&&!(w==0&&h==0)){\n\t\tREP(i,50){REP(j,50){ans[j][i]=0;}}\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tchar tmp;\n\t\t\t\tcin>>tmp;\n\t\t\t\tswitch(tmp){\n\t\t\t\t  case 'B':ans[j][i]=-1;break;\n\t\t\t\t  case 'W':ans[j][i]=-2;break;\n\t\t\t\t}\t\t// B -1   W -10 3\n\t\t\t}\n\t\t}\n\t\t\n//\t\t/**/REP(i,h){REP(j,w){cout<<step1(j,i)<<\" \";}cout<<endl;}cout<<endl;\t\t\n//\t\t/**/REP(i,h){REP(j,w){cout<<ans[j][i]<<\" \";}cout<<endl;}cout<<endl;\n\t\tREP(i,h){REP(j,w){if(ans[j][i]==0&&step1(j,i)==3){step2(j,i,3);}}}\n\t\tREP(i,h){REP(j,w){if(ans[j][i]==0&&step1(j,i)==2){step2(j,i,2);}}}\n\t\tREP(i,h){REP(j,w){if(ans[j][i]==0&&step1(j,i)==1){step2(j,i,1);}}}\n\t\tint ans1(0),ans2(0);\n\t\tREP(i,h){REP(j,w){if(ans[j][i]==1){ans1++;}if(ans[j][i]==2){ans2++;}}}\n\t\t\n\t\tcout<<ans1<<\" \"<<ans2<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<cstring>\n#include<queue>\n\nusing namespace std;\n\n#define INF 999999999\n\nvector <string> a(52);\nqueue<pair <int, int> > q[2];\nbool c[2][52][52];\nint f[2];\n\nvoid search(int x, int y, int z){\n\tpair<int, int> r;\n\tif(a[x][y] == '.')f[z]++;\n\tif(a[x+1][y]=='.'&&c[z][x+1][y]==0){\n\t\tc[z][x+1][y] = 1;\n\t\tr.first = x+1;\n\t\tr.second = y;\n\t\tq[z].push(r);\n\t}\n\tif(a[x-1][y]=='.'&&c[z][x-1][y]==0){\n\t\tc[z][x-1][y] = 1;\n\t\tr.first = x-1;\n\t\tr.second = y;\n\t\tq[z].push(r);\n\t}\n\tif(a[x][y-1]=='.'&&c[z][x][y-1]==0){\n\t\tc[z][x][y-1] = 1;\n\t\tr.first = x;\n\t\tr.second = y-1;\n\t\tq[z].push(r);\n\t}\n\tif(a[x][y+1]=='.'&&c[z][x][y+1]==0){\n\t\tc[z][x][y+1] = 1;\n\t\tr.first = x;\n\t\tr.second = y+1;\n\t\tq[z].push(r);\n\t}\n\tq[z].pop();\n\tif(!q[z].empty()) search(q[z].front().first, q[z].front().second, z);\n}\n\nint main(){\n\tint i, j, w, h;\n\tstring s;\n\tpair<int, int> d;\n\twhile(1){\n\t\tcin >> w >> h;\n\t\tif(!w)break;\n\t\tfor(i=0;i<=h+1;i++){\n\t\t\tfor(j=0;j<=w;j++){\n\t\t\t\tc[0][i][j] = 0;\n\t\t\t\tc[1][i][j] = 0;\n\t\t\t\tif(i==0||i==h+1) a[i][j] = '#';\n\t\t\t}\n\t\t}\n\t\tfor(i=1;i<=h;i++){\n\t\t\tcin >> s;\n\t\t\ta[i] = \"#\" + s + \"#\";\n\t\t}\n\t\t\n\t\tint common = 0;\n\t\tf[0]=0;\n\t\tf[1]=0;\n\t\tfor(i=1;i<=h;i++){\n\t\t\tfor(j=1;j<=w;j++){\n\t\t\t\td.first = i;\n\t\t\t\td.second = j;\n\t\t\t\tif(a[i][j]=='B'){\n\t\t\t\t\tc[0][i][j] = 1;\n\t\t\t\t\tq[0].push(d);\n\t\t\t\t}\n\t\t\t\telse if(a[i][j]=='W'){\n\t\t\t\t\tc[1][i][j] = 1;\n\t\t\t\t\tq[1].push(d);\n\t\t\t\t}\n\t\t\t\telse common++;\n\t\t\t}\n\t\t}\n\t\tif(q[0].empty() && q[1].empty()){\n\t\t\tcout << \"0 0\" << endl;\n\t\t}\n\t\telse{\n\t\t\tif(!q[0].empty()) search(q[0].front().first, q[0].front().second, 0);\n\t\t\tif(!q[1].empty()) search(q[1].front().first, q[1].front().second, 1);\n\t\t\t//cout << common << \" \" << f[0] << \" \" << f[1] << endl;\n\t\t\tcout << common-f[1] << \" \" << common-f[0] << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n\n\n\nvoid dfs(std::vector<std::vector<char> > &map, int i, int j, char self_color, char other_color, int &total) {\n    int first;\n    int second;\n\n    int count = 0;\n    bool check_surrounded = true;\n    bool check_only_wall = false;\n\n    int dx[] = {0, 0, 1, -1};\n    int dy[] = {1, -1, 0, 0};\n\n    std::stack<std::pair<int, int> > st;\n    st.push(std::make_pair(i, j));\n    map[i][j] = '$';\n\n    while (1) {\n        if (st.empty() == 1) {\n            break; \n        }\n        first = st.top().first;\n        second = st.top().second;\n        st.pop();\n        ++count;\n        for (int k = 0; k < 4; k++) {\n            if (map[first + dx[k]][second + dy[k]] == '.') {\n                st.push(std::make_pair(first + dx[k], second + dy[k])); \n                map[first + dx[k]][second + dy[k]] = '$';\n            } else if (map[first + dx[k]][second + dy[k]] == other_color) {\n                check_surrounded = false; \n            }\n            if (map[first + dx[k]][second + dy[k]] == self_color) {\n                check_only_wall = true;\n            }\n        }\n    }\n    if (check_surrounded == true && check_only_wall == true) {\n        total += count;\n    } else {\n        check_surrounded = true;\n        check_only_wall = false;\n    }\n    return;\n}\n\nint whole_search(std::vector<std::vector<char> > map, int w, int h, char self_color, char other_color) {\n    int total = 0;\n\n    for (int i = 1; i <= h; i++) {\n        for (int j = 1; j <= w; j++) {\n            if (map[i][j] == '.') {\n                dfs(map, i, j, self_color, other_color, total);\n            }\n        }\n    }\n    return total; \n}\n\nint main(void) {\n    int w;\n    int h;\n\n    while (1) {\n        std::cin >> w >> h;\n        if (w == 0 && h == 0) {\n            break;\n        }\n\n        std::vector<std::vector<char> > map_b(h+2, std::vector<char>(w+2, '#'));\n        std::vector<std::vector<char> > map_w(h+2, std::vector<char>(w+2, '#'));\n\n        for (int i = 1; i <= h; i++) {\n            for (int j = 1; j <= w; j++) {\n                std::cin >> map_b[i][j];\n                map_w[i][j] = map_b[i][j];\n            }\n        }\n        std::cout << whole_search(map_b, w, h, 'B', 'W') << \" \" << whole_search(map_w, w, h, 'W', 'B') << std::endl;\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\nusing namespace std;\ntypedef pair<int ,int> P;\nchar grid[50][50];\nint W,H;\nint dx[] = {0,0,1,-1},dy[] = {1,-1,0,0};\nchar c[2] = {'B','W'};\n\nint bfs(int sx,int sy,int k){\n  queue<P> que;\n  int res[2] = {0};\n  bool flag = true;\n  que.push(P(sx,sy));\n  while(!que.empty()){\n    P p = que.front();\n    que.pop(); \n\n    if(grid[p.first][p.second] == '.'){\n      grid[p.first][p.second] = c[k];\n      res[k]++;\n    } \n    for(int i = 0 ; i < 4 ; i++ ){\n      int nx = p.first + dx[i],ny = p.second + dy[i];\n      if(0 <= nx && nx < W && 0 <= ny && ny < H && grid[nx][ny] == '.'){\n\tque.push(P(nx,ny));\n\tif((nx+1 < W && grid[nx+1][ny] == c[!k])||\n\t   (nx-1 >= 0 && grid[nx-1][ny] == c[!k])||\n\t   (ny+1 < H && grid[nx][ny+1] == c[!k])||\n\t   (ny-1 >= 0 && grid[nx][ny-1] == c[!k]))flag = false;\n      }\n    }\n  }\n  if(flag == true)return res[k];\n  else return 0; \n}\n\nint main(){\n  while( cin >> W >> H , W+H ){\n\n    for(int i = 0 ; i < H ; i++ ){\n      for(int j = 0 ; j < W ; j++ ){\n\tcin >> grid[j][i];\n      }\n    }\n    int ans[2] = {0};\n    for(int k = 0 ; k < 2 ; k++ ){\n      for(int i = 0 ; i < H ; i++ ){\n\tfor(int j = 0 ; j < W ; j++ ){\n\t  if(grid[j][i] == '.'){\n\t    if((j+1 < W && grid[j+1][i] == c[k])||\n\t       (j-1 >= 0 && grid[j-1][i] == c[k])||\n\t       (i+1 < H && grid[j][i+1] == c[k])||\n\t       (i-1 >= 0 && grid[j][i-1] == c[k]))ans[k]+=bfs(j,i,k);\n\t  }\n\t}\n      }\n    }\n    cout << ans[0] <<\" \"<< ans[1] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <queue>\n\nusing namespace std;\n\nchar field[52][52];\nbool black[52][52];\nbool white[52][52];\n\ntypedef pair<int, int> p;\n\nint t_x[] = {1, 0, -1, 0};\nint t_y[] = {0, 1, 0, -1};\n\nvoid search(int h, int w)\n{\n  char c = field[h][w];\n  queue<p> que;\n  que.push( p(h, w) );\n  while ( !que.empty() ) {\n    p n_c = que.front();\n    //cout << n_c.first << \" \" << n_c.second << endl;\n    que.pop(); \n\n    for ( int i = 0; i < 4; i++ ) {\n      int t_h = n_c.first + t_x[i];\n      int t_w = n_c.second + t_y[i];\n      if ( field[t_h][t_w] == '#' ) continue;\n      if ( field[t_h][t_w] == c || field[t_h][t_w] == '.' ) {\n\tif ( c == 'W') { \n\t  if(!white[t_h][t_w]) {\n\t    white[t_h][t_w] = true;\n\t  } else {\n\t    continue;\n\t  }\n\t}\n \tif (c == 'B') {\n\t  if (!black[t_h][t_w]) {\n\t    black[t_h][t_w] = true;\n\t  } else {\n\t    continue;\n\t  }\n\t}\n\tque.push( p(t_h, t_w) );\n      }\n    }\n  }\n}\n\n\nint main()\n{\n  while ( true ) {\n    int width, height;\n    cin >> width >> height;\n\n    if ( width == 0 && height == 0 ) break;\n\n    memset(field, '#', sizeof field);\n    memset(black, false, sizeof black);\n    memset(white, false, sizeof white);\n\n    for ( int i = 1; i <= height; i++ ) {\n      for ( int j = 1; j <= width; j++ ) {\n\tcin >> field[i][j];\n      }\n    }\n    \n    for ( int i = 1; i <= height; i++ ) {\n      for ( int j = 1; j <= width; j++ ) {\n\tif ( field[i][j] == 'W' && !white[i][j] || field[i][j] == 'B' && !black[i][j]) {\n\t  search(i, j);\n\t}\n      }\n    }\n    for (int i = 1; i <= height; i++) {\n      for (int j = 1; j <= width; j++) {\n\t//cout << ((black[i][j]) ? \"B\" : \".\");\n      }\n      //cout << endl;\n    }\n    for (int i = 1; i <= height; i++) {\n      for (int j = 1; j <= width; j++) {\n\t//cout << ((white[i][j]) ? \"W\" : \".\");\n      }\n      //cout << endl;\n    }\n    int b_counter = 0, w_counter = 0;\n    for (int i = 1; i <= height; i++) {\n      for (int j = 1; j <= width; j++) {\n\tif (field[i][j] != '.') continue;\n\tif (!black[i][j] && white[i][j]) w_counter++;\n\tif (black[i][j] && !white[i][j]) b_counter++;\n      }\n    }\n    cout << b_counter << \" \" << w_counter << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n\nusing namespace std;\n\nint w,h;\nchar F[52][52][2];\nint check(int x, int y, char a, int wb)\n{\n    if(F[x-1][y][wb] == '.')\n    {\n        F[x-1][y][wb] = a;\n        check(x-1,y,a,wb);\n    }\n    if(F[x+1][y][wb] == '.')\n    {\n        F[x+1][y][wb] = a;\n        check(x+1,y,a,wb);\n    }\n    if(F[x][y-1][wb] == '.')\n    {\n        F[x][y-1][wb] = a;\n        check(x,y-1,a,wb);\n    }\n    if(F[x][y+1][wb] == '.')\n    {\n        F[x][y+1][wb] = a;\n        check(x,y+1,a,wb);\n    }\n}\nint main()\n{\n    int flag;\n    int nw, nb;\n    char a, b;\n    while(cin >> w >> h && w && h)\n    {\n        nw = 0; nb = 0;\n        for(int j=1;j<=h;++j){\n            for(int i=1;i<=w;++i){\n                cin >> F[i][j][0];\n                F[i][j][1] = F[i][j][0];\n            }\n        }\n        for(int k=0;k<2;++k){\n            if(k==0) a='w', b='W';\n            if(k==1) a='b', b='B';\n            for(int j=1;j<=h;++j){\n                for(int i=1;i<=w;++i){\n                    if(F[i][j][k] == b) check(i,j,a,k);\n                }\n            }\n        }\n        for(int j=1;j<=h;++j){\n            for(int i=1;i<=w;++i){\n                if(F[i][j][0] == 'w' && F[i][j][1]== '.') ++nw;\n                else if(F[i][j][1] == 'b' && F[i][j][0] == '.')++nb;\n            }\n        }\n        cout << nb << \" \" << nw << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<ctime>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y-1);(X) >=0;--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\n\nint used[60][60],dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\npii dfs(vector<string> &mp,int y,int x){\n  if(mp[y][x]=='#')\n    return pii(0,0);\n  if(mp[y][x]=='B')\n    return pii(0,2);\n  if(mp[y][x]=='W')\n    return pii(0,1);\n  if(used[y][x])\n    return pii(0,0);\n  used[y][x]=1;\n  pii re=pii(1,0),tmp;\n  rep(i,4){\n    tmp=dfs(mp,y+dy[i],x+dx[i]);\n    re.X+=tmp.X;\n    re.Y|=tmp.Y;\n  }\n  return re;\n}\n\nint main(){\n  clock_t St,Et;\n  St=clock();\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n  int i,j,k;\n  while(1){\n    int w,h;\n    cin>>w>>h;\n    if(w==0)break;\n    vector<string> mp(h+2,string(w+2,'#'));\n    rep(i,h){\n      cin>>mp[i+1];\n      mp[i+1]=\"#\"+mp[i+1]+\"#\";\n    }\n    //   rep(i,h+2)cout<<mp[i]<<endl;\n    fill(used[0],used[0]+60*60,0);\n    int rew=0,reb=0;\n    for(i=1;i<=h;i++)\n      for(j=1;j<=w;j++)\n\tif(!used[i][j]&&mp[i][j]=='.'){\n\t  pii tmp=dfs(mp,i,j);\n\t  if(tmp.Y==1){\n\t    rew+=tmp.X;\n\t  }else if(tmp.Y==2){\n\t    reb+=tmp.X;\n\t  }\n\t}\n    //   rep(i,h+2){rep(j,2+w)cout<<used[i][j];cout<<endl;}\n    cout<<reb<<\" \"<<rew<<endl;\n  }\n  double hoge=2;\n  while((clock()-St)/CLOCKS_PER_SEC<5.0){\n    hoge*=1.0001;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <unordered_set>\n#include <unordered_map>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <cstdio>\n#include <climits>\n#include <complex>\n#include <cstdint>\n#include <tuple>\n\n#define M_PI       3.14159265358979323846\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str(); }\ninline int readInt() { int x; scanf(\"%d\", &x); return x; }\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SQ(a) ((a)*(a))\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,s,n) for(int i=s;i<(int)n;++i)\n#define REP(i,n) FOR(i,0,n)\n#define MOD 1000000007\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\nstruct Edge {\n    int to, cost;\n    Edge(int to, int cost): to(to), cost(cost) {}\n};\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vector<Edge>> AdjList;\nAdjList graph;\n\nconst int INF = 100000000;\nint w, h;\nint dxy[5] = {-1, 0, 1, 0, -1};\nbool bb[60][60], ww[60][60], visited[60][60];\nvoid dfs1(int y, int x, vector<string>&field){\n\n    if(visited[y][x]) return;\n\n    ww[y][x] = true;\n    visited[y][x] = true;\n\n    for(int i=0; i<4; ++i){\n        int ny = y + dxy[i],\n            nx = x + dxy[i+1];\n        if(ny < h && ny>=0 && nx < w && nx >= 0 && field[ny][nx] == '.'){\n            dfs1(ny, nx, field);\n        }\n    }\n}\n\nvoid dfs2(int y, int x, vector<string>&field){\n\n    if(visited[y][x]) return;\n\n    bb[y][x] = true;\n    visited[y][x] = true;\n\n    for(int i=0; i<4; ++i){\n        int ny = y + dxy[i],\n                nx = x + dxy[i+1];\n        if(ny < h && ny>=0 && nx < w && nx >= 0 && field[ny][nx] == '.'){\n            dfs2(ny, nx, field);\n        }\n    }\n}\nint main() {\n    //cout << fixed << setprecision(15);\n\n\n    while(cin >> w >> h) {\n        if (w == 0 && h == 0) break;\n\n        vector<string> field;\n\n        REP(i, h) {\n            string str;\n            cin >> str;\n            field.push_back(str);\n        }\n        REP(i, 60) {\n            REP(j, 60) {\n                ww[i][j]=false;\n                bb[i][j]=false;\n                visited[i][j] = false;\n            }\n        }\n\n        REP(i, h) REP(j, w) {\n                if (field[i][j] == 'W') {\n                    dfs1(i, j, field);\n                }\n            }\n        REP(i, 60) {\n            REP(j, 60) {\n                visited[i][j] = false;\n            }\n        }\n\n        REP(i, h) REP(j, w) {\n                if (field[i][j] == 'B') {\n                    dfs2(i, j, field);\n                }\n        }\n\n        int cnt_b=0, cnt_w=0;\n\n        REP(i, h){\n            REP(j, w){\n                if(field[i][j]=='.' && bb[i][j] && !ww[i][j]) cnt_b++;\n                else if(field[i][j]=='.' && !bb[i][j] && ww[i][j]) cnt_w++;\n            }\n        }\n\n        cout << cnt_b << \" \" << cnt_w << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<cstring>\n#include<map>\nusing namespace std;\ntypedef pair<int ,int > P;\nint xs[] = {-1, 0, 1, 0}, ys[] = {0, 1, 0, -1};\nchar a[55][55];\nint w, h;\nbool b[55][55], wh[55][55];\n \nint main(){\n\twhile(cin >> w >> h, w | h){\n\t\tmemset(b, 0, sizeof(b));\n\t\tmemset(wh, 0, sizeof(wh));\n\t\tqueue<P> black, white;\n\t\tfor(int i = 0;i < h;i++){\n\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\tcin >> a[i][j];\n\t\t\t\tif(a[i][j] == 'B')black.push(P(i, j));\n\t\t\t\tif(a[i][j] == 'W')white.push(P(i, j));\n\t\t\t}\n\t\t}\n\t\twhile(!black.empty()){\n\t\t\tfor(int t = black.size() - 1;t >= 0;t--){\n\t\t\t\tP tmp = black.front();black.pop();\n\t\t\t\tfor(int i = 0;i < 4;i++){\n\t\t\t\t\tint nx = tmp.first + xs[i], ny = tmp.second + ys[i];\n\t\t\t\t\tif(nx < 0 || nx >= h || ny < 0 || ny >= w || a[nx][ny] != '.')continue;\n\t\t\t\t\tif(b[nx][ny])continue;\n\t\t\t\t\tb[nx][ny] = true;\n\t\t\t\t\tblack.push(P(nx, ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(!white.empty()){\n\t\t\tfor(int t = white.size() - 1;t >= 0;t--){\n\t\t\t\tP tmp = white.front();white.pop();\n\t\t\t\tfor(int i = 0;i < 4;i++){\n\t\t\t\t\tint nx = tmp.first + xs[i], ny = tmp.second + ys[i];\n\t\t\t\t\tif(nx < 0 || nx >= h || ny < 0 || ny >= w || a[nx][ny] != '.')continue;\n\t\t\t\t\tif(wh[nx][ny])continue;\n\t\t\t\t\twh[nx][ny] = true;\n\t\t\t\t\twhite.push(P(nx, ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint bc = 0, wc = 0;\n\t\tfor(int i = 0;i < h;i++){\n\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\tif(b[i][j] && !wh[i][j])bc++;\n\t\t\t\tif(!b[i][j] && wh[i][j])wc++;\n\t\t\t}\n\t\t}\n\t\tcout << bc << \" \" << wc << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = (1LL << 31) - 1;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n#define MAX_N 100100 * 3\n\nint h, w;\n\nstring s[100];\nbool used[100][100];\nbool F[100][100][2];\n\nint dx[4] = { 0,1,0,-1 };\nint dy[4] = { 1,0,-1,0 };\n\nvoid solve(int y, int x, int f) {\n\tused[y][x] = 1;\n\tF[y][x][f] = 1;\n\tREP(i, 4) {\n\t\tint ny = y + dy[i], nx = x + dx[i];\n\t\tif (used[ny][nx])continue;\n\t\tif (ny >= 0 && ny < h&&nx >= 0 && nx < w) {\n\t\t\tif (f == 0) {\n\t\t\t\tif (s[ny][nx] != 'B') {\n\t\t\t\t\tsolve(ny, nx, f);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (s[ny][nx] != 'W') {\n\t\t\t\t\tsolve(ny, nx, f);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\twhile (cin >> w >> h&&h + w) {\n\t\tREP(i, 100)REP(j, 100) {\n\t\t\tused[i][j] = 0;\n\t\t\tREP(k, 2)F[i][j][k] = 0;\n\t\t}\n\t\tREP(i, h)cin >> s[i];\n\t\tREP(k, 2) {\n\t\t\tREP(i, 100)REP(j, 100) {\n\t\t\t\tused[i][j] = 0;\n\t\t\t}\n\t\t\tREP(i, h) {\n\t\t\t\tREP(j, w) {\n\t\t\t\t\tif (used[i][j])continue;\n\t\t\t\t\tif (k == 0 && s[i][j] == 'W') {\n\t\t\t\t\t\tsolve(i, j, k);\n\t\t\t\t\t}\n\t\t\t\t\telse if (k == 1 && s[i][j] == 'B') {\n\t\t\t\t\t\tsolve(i, j, k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//REP(I, h) {\n\t\t//\tREP(J, w) {\n\t\t//\t\tcout << F[I][J][0] << \" \";\n\t\t//\t}\n\t\t//\tcout << endl;\n\t\t//}\n\t\t//cout << endl;\n\t\t//REP(I, h) {\n\t\t//\tREP(J, w) {\n\t\t//\t\tcout << F[I][J][2] << \" \";\n\t\t//\t}\n\t\t//\tcout << endl;\n\t\t//}\n\t\tint ans[2] = {};\n\t\tREP(i, h) {\n\t\t\tREP(j, w) {\n\t\t\t\tif (s[i][j] != '.')continue;\n\t\t\t\tif (F[i][j][0] == 1 && F[i][j][1] == 0) {\n\t\t\t\t\tans[0]++;\n\t\t\t\t}\n\t\t\t\telse if (F[i][j][0] == 0 && F[i][j][1] == 1) {\n\t\t\t\t\tans[1]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans[1] << \" \" << ans[0] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nchar field[51][51];\nint black[51][51],white[51][51];//0:non-rinsetu 1::rinsetu\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\nint w,h;\n\nvoid recB(int x,int y){\n  if(field[x][y]=='B' || black[x][y]==1){\n    for(int i=0;i<4;i++){\n      int nx=x+dx[i],ny=y+dy[i];\n      if(0<=nx && nx<h && 0<=ny && ny<w){\n        if(field[nx][ny]!='W' && black[nx][ny]==0){\n          black[nx][ny]=1;\n          recB(nx,ny);\n        }\n      }\n    }\n  }\n}\n\nvoid recW(int x,int y){\n  if(field[x][y]=='W' || white[x][y]==1){\n    for(int i=0;i<4;i++){\n      int nx=x+dx[i],ny=y+dy[i];\n      if(0<=nx && nx<h && 0<=ny && ny<w){\n        if(field[nx][ny]!='B' && white[nx][ny]==0){\n          white[nx][ny]=1;\n          recW(nx,ny);\n        }\n      }\n    }\n  }\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  while(cin>>w>>h,w|h){\n    for(int i=0;i<h;i++){\n      string s;cin >>s;\n      for(int j=0;j<w;j++){\n        field[i][j]=s[j];\n      }\n    }\n    for(int i=0;i<h;i++) for(int j=0;j<w;j++){\n      black[i][j]=0,white[i][j]=0;\n    }\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        if(field[i][j]=='W') recW(i,j);\n        if(field[i][j]=='B') recB(i,j);\n      }\n    }\n    int resB=0,resW=0;\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        if(field[i][j]!='B' && black[i][j]==1 && white[i][j]==0)resB++;\n        if(field[i][j]!='W' && black[i][j]==0 && white[i][j]==1)resW++;\n      }\n    }\n   /* for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            cout<<black[i][j];\n        }\n        cout << endl;\n    }\n    cout << endl;\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            cout<<white[i][j];\n        }\n        cout << endl;\n    }*/\n    cout << resB << \" \"<< resW<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define lp(i,n) for(int i=0;i<n;i++)\n\nint dp[60][60];\nchar a[60][60];\n//1 null 2 B 3 W 4 non\nvoid calc(int w,int h){\n  queue<tuple<int,int,int>> task;\n  task.push(make_tuple(1,1,1));\n  while(!task.empty()){\n    tuple<int,int,int>memo =task.front();\n    task.pop();\n    int x,y,stat;\n    x=get<0>(memo);\n    y=get<1>(memo);\n    stat=get<2>(memo);\n    if(dp[x][y]==stat||dp[x][y]==4) continue;\n    if(dp[x][y]>1&&stat==1) continue;\n    if(dp[x][y]==2&&stat==3||dp[x][y]==3&&stat==2) stat=4;\n    if(a[x][y]!='.'&&stat==4) continue;\n    if(a[x][y]=='W') stat=3;\n    if(a[x][y]=='B') stat=2;\n    if(a[x][y]=='!') continue;\n    dp[x][y]=stat;\n    task.push(make_tuple(x+1,y,stat));\n    task.push(make_tuple(x-1,y,stat));\n    task.push(make_tuple(x,y+1,stat));\n    task.push(make_tuple(x,y-1,stat));\n  }\n\n  return;\n}\nint main(){\n  while(1){\n    int w,h;\n    cin>>w>>h;\n    if(w==0&&h==0) break;\n    lp(i,60){\n      lp(j,60){\n\tdp[i][j]=0;\n\ta[i][j]='!';\n      }\n    }\n    lp(i,h+1){\n      if(i==0) continue;\n      lp(j,w+1){\n\tif(j==0) continue;\n\tcin>>a[j][i];\n      }\n    }\n    calc(w,h);\n    int countb=0,countw=0;\n    lp(i,h+1){\n      if(i==0) continue;\n      lp(j,w+1){\n\tif(j==0) continue;\n\tif(a[j][i]=='.'){\n\t  if(dp[j][i]==2) countb++;\n\t  if(dp[j][i]==3) countw++;\n\t}\n      }\n    }\n    cout<<countb<<\" \"<<countw<<endl;\n    \n  }\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint dx[]={1,0,-1,0},dy[]={0,1,0,-1};\nint w,h,bum,wum,sum,B,W;\nchar s[60][60];\nvoid func1(int y,int x){\n\tint p=y,q=x;\n\tif(s[y][x]=='B'){\n\t\tB++;\n\t}\n\telse if(s[y][x]=='W'){\n\t\tW++;\n\t}\n\telse if(s[y][x]!='*'){\n\t\ts[y][x]='*';\n\t\tsum++;\n\t\tfor(int l=0;l<4;l++){\n\t\t\ty=p+dy[l];\n\t\t\tx=q+dx[l];\n\t\t\tif(y>=0&&y<h&&x>=0&&x<w){\n\t\t\t\tfunc1(y,x);\n\t\t\t}\n\t\t}\n\t}\n}\nvoid func2(int y,int x,char c){\n\tint p,q;\n\tif(s[y][x]=='*'){\n\t\ts[y][x]=c;\n\t\tfor(int o=0;o<4;o++){\n\t\t\tp=y+dy[o];\n\t\t\tq=x+dx[o];\n\t\t\tif(p>=0&&p<h&&q>=0&&q<w)\n\t\t\t\tfunc2(p,q,c);\n\t\t}\n\t}\n}\nint main(){\n\twhile(cin>>w>>h,w||h){\n\t\twum=0;\n\t\tbum=0;\n\t\tfor(int i=0;i<h;i++)\n\t\tscanf(\"%s\",s[i]);\n\t\tfor(int i=0;i<h;i++)\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(s[i][j]=='.'){\n\t\t\t\tB=0;\n\t\t\t\tW=0;\n\t\t\t\tsum=0;\n\t\t\t\tfunc1(i,j);\n\t\t\t\tif(B>0&&W==0){\n\t\t\t\t\tbum+=sum;\n\t\t\t\t\tfunc2(i,j,'s');\n\t\t\t\t}\n\t\t\t\telse if(B==0&&W>0){\n\t\t\t\t\twum+=sum;\n\t\t\t\t\tfunc2(i,j,'t');\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tfunc2(i,j,'D');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++)\n\t\tcout<<s[i][j];\n\t\t\tcout<<endl;\n\t\t}\n\t\tcout<<bum<<' '<<wum<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<utility>\n#include<string>\n#include<queue>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n;i++)\ntypedef  pair<int,int> pii;\nint dx[]={0,0,1,-1};\nint dy[]={1,-1,0,0};\nint main(){\n    int w,h;\n    while(cin>>w>>h,w+h){\n        vector<vector<bool> >black(51,vector<bool>(51,true));\n        vector<vector<bool> >white(51,vector<bool>(51,true));\n        vector<pii>b,wh;\n        vector<vector<char>>v(51,vector<char>(51));\n        rep(i,h)rep(j,w){\n            cin>>v[i][j];\n            if(v[i][j]=='W')wh.push_back(pii(i,j));\n            if(v[i][j]=='B')b.push_back(pii(i,j));\n        }\n        queue<pii>que;\n        rep(i,wh.size())que.push(wh[i]);\n        while(!que.empty()){\n            pii now=que.front(); que.pop();\n            rep(i,4){\n                int nx=now.second+dx[i];\n                int ny=now.first+dy[i];\n                if(0<=nx&&nx<w&&0<=ny&&ny<h){\n                    if(v[ny][nx]!='.'||white[ny][nx]==false)continue;\n                    white[ny][nx]=false;\n                    que.push(pii(ny,nx));\n                }\n            }\n        }\n        rep(i,b.size())que.push(b[i]);\n        while(!que.empty()){\n            pii now=que.front(); que.pop();\n            rep(i,4){\n                int nx=now.second+dx[i];\n                int ny=now.first+dy[i];\n                if(0<=nx&&nx<w&&0<=ny&&ny<h){\n                    if(v[ny][nx]!='.'||black[ny][nx]==false)continue;\n                    black[ny][nx]=false;\n                    que.push(pii(ny,nx));\n                }\n            }\n        }\n        int bl=0,whi=0;\n        rep(i,h)rep(j,w){\n            if(white[i][j]==false&&black[i][j]==true)whi++;\n            if(white[i][j]==true&&black[i][j]==false)bl++;\n        }\n        cout<<bl<<\" \"<<whi<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"vector\"\n#include \"string\"\n#include \"queue\"\n#include \"cstring\"\nusing namespace std;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint main(void)\n{\n\tint w,h;\n\twhile (cin>>w>>h,w) {\n\t\tbool black[h][w],white[h][w];\n\t\tmemset(black,0,sizeof(black));\n\t\tmemset(white,0,sizeof(white));\n\t\tstring in[h];\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tcin>>in[i];\n\t\t}\n\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tint f=0;\n\t\t\t\tif(in[i][j]=='W') f=1;\n\t\t\t\telse if(in[i][j]=='B') f=2;\n\n\t\t\t\tif(in[i][j]!='.')\n\t\t\t\t{\n\t\t\t\t\tbool used[h][w];\n\t\t\t\t\tmemset(used,0,sizeof(used));\n\t\t\t\t\tqueue<int> xs,ys;\n\t\t\t\t\txs.push(j); ys.push(i);\n\t\t\t\t\twhile (!xs.empty()) {\n\t\t\t\t\t\tint x=xs.front(),y=ys.front();\n\t\t\t\t\t\txs.pop(); ys.pop();\n\t\t\t\t\t\tused[y][x]=true;\n\t\t\t\t\t\tif(f==1) white[y][x]=true;\n\t\t\t\t\t\telse black[y][x]=true;\n\t\t\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\t\t\tint nx=x+dx[k],ny=y+dy[k];\n\t\t\t\t\t\t\tif(0<=nx&&nx<w&&0<=ny&&ny<h&&!used[ny][nx]&&in[ny][nx]=='.')\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\txs.push(nx); ys.push(ny);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint Black=0,White=0;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif(in[i][j]!='B'&&black[i][j]&&!white[i][j]) Black++;\n\t\t\t\telse if(in[i][j]!='W'&&!black[i][j]&&white[i][j]) White++;\n\t\t\t}\n\t\t}\n\t\tcout<<Black<<\" \"<<White<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <algorithm>\n\n#define CH(N,A,B) (A<=N&&N<B)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define RREP(i,a,b) for(int i=(b-1);a<=i;i--)\n\nusing namespace std;\n\nint dx[] = {1, 0, -1, 0};\nint dy[] = {0, 1, 0, -1};\n\nint w, h;\nint grand[55][55];\nstring s[55];\nbool flag[55][55];\n\nvoid dfs(int y, int x){\n  if(s[y][x] != '.' || !flag[y][x]) return;\n  flag[y][x] = false;\n  for(int k=0; k<4; k++){\n    if(!CH(x + dx[k],0,w) || !CH(y + dy[k],0,h)) continue;\n    if(s[y + dy[k]][x + dx[k]] != '.') continue;\n    if(grand[y + dy[k]][x + dx[k]] != 3) grand[y + dy[k]][x + dx[k]] = grand[y][x];\n  }\n  for(int k=0; k<4; k++){\n    if(!CH(x + dx[k],0,w) || !CH(y + dy[k],0,h)) continue;\n    if(s[y + dy[k]][x + dx[k]] != '.') continue;\n    dfs(y + dy[k], x + dx[k]);\n  }\n}\n\nint main() {\n\n  while(1){\n    cin>>w>>h;\n    if(w==0 && h==0) break;\n    for(int i=0; i<h; i++){\n      cin>>s[i];\n    }\n    memset(grand, 0, sizeof(grand));\n\n    for(int i=0; i<h; i++){\n      for(int j=0; j<w; j++){\n        if(s[i][j] == '.'){\n          for(int k = 0; k<4; k++){\n            if(!CH(j + dx[k],0,w) || !CH(i + dy[k],0,h)) continue;\n            int posx = j + dx[k], posy = i + dy[k];\n            while(1){\n              if(!CH(posx,0,w) || !CH(posy,0,h)){\n                break;\n              }else if(s[posy][posx] == 'W'){\n                int tx = posx - dx[k], ty = posy - dy[k];\n                while(1){\n                  if(grand[ty][tx] == 0 || grand[ty][tx] == 1) grand[ty][tx] = 1;\n                  else grand[ty][tx] = 3;\n                  if(tx == j && ty == i ) break;\n                  tx -= dx[k];\n                  ty -= dy[k];\n                }\n                break;\n              }else if(s[posy][posx] == 'B'){\n                int tx = posx - dx[k], ty = posy - dy[k];\n                while(1){\n                  if(grand[ty][tx] == 0 || grand[ty][tx] == 2) grand[ty][tx] = 2;\n                  else grand[ty][tx] = 3;\n                  if(tx == j && ty == i ) break;\n                  tx -= dx[k];\n                  ty -= dy[k];\n                }\n                break;\n              }\n              posx += dx[k];\n              posy += dy[k];\n            }\n          }\n        }\n      }\n    }\n\n    for(int i=0; i<h; i++){\n      for(int j=0; j<w; j++){\n        memset(flag, true, sizeof(flag));\n        dfs(i, j);\n      }\n    }\n\n    int wcnt=0, bcnt=0;\n    for(int i=0; i<h; i++){\n      for(int j=0; j<w; j++){\n        if(grand[i][j] == 1) wcnt++;\n        if(grand[i][j] == 2) bcnt++;\n      }\n    }\n\n    cout<<bcnt<<\" \"<<wcnt<<endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <iterator>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <string>\n#include <cmath>\nusing namespace std;\n#define MOD 998244353\n#define INF 1<<30\n#define LINF (ll)1<<62\n#define MAX 510000\n#define rep(i,n) for(ll i=0; i<(n); i++)\n#define REP(i,a,b) for(ll i=(a); i<(b); i++)\n#define all(x) (x).begin(),(x).end()\n#define uni(q) unique(all(q)),q.end()\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef pair<ll, ll> P;\ntypedef vector<pair<ll, ll>> vpl;\n\nll h,w;\nchar s[55][55];\nbool visit[55][55];\nll dy[4] = {1,0,-1,0};\nll dx[4] = {0,1,0,-1};\n\nbool in(ll y, ll x){\n    return 0<=y && y<h && 0<=x && x<w;\n}\n\nint main(){\n    while(1){\n        cin >> w >> h;\n        if(h==0 && w==0) break;\n        rep(i,h){\n            rep(j,w) cin >> s[i][j];\n        }\n        P ans = P(0,0);\n        rep(i,h){\n            rep(j,w){\n                rep(k,h) rep(l,w) visit[k][l] = false;\n                if(s[i][j] != '.') continue;\n                bool W = false;\n                bool B = false;\n                queue<P> q;\n                q.push(P(i,j));\n                visit[i][j] = true;\n                while(!q.empty()){\n                    P p = q.front(); q.pop();\n                    ll y = p.first;\n                    ll x = p.second;\n                    rep(i,4){\n                        ll ny = y + dy[i];\n                        ll nx = x + dx[i];\n                        if(in(ny,nx)){\n                            if(visit[ny][nx]) continue;\n                            visit[ny][nx] = true;\n                            if(s[ny][nx]=='W') W = true;\n                            else if(s[ny][nx]=='B') B = true;\n                            else q.push(P(ny,nx));\n                        }\n                    }\n                }\n                if(W == B) continue;\n                else{\n                    if(B) ans.first++;\n                    else ans.second++;\n                }\n            }\n        }\n        cout << ans.first << \" \" << ans.second << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <queue>\n#include <algorithm>\n#define INF 100000000\nusing namespace std;\ntypedef pair<int ,int >P; \nint W,H;\nchar grid[50][50];\nint dx[] = {1,-1,0,0},dy[] = {0,0,1,-1};\nint ansB,ansW; \n\nvoid bfs(int sx,int sy){\n  queue<P>que;\n  bool flagB = true,flagW = true;\n  int res = 0;\n  while(!que.empty())que.pop();\n\n  que.push(P(sx,sy)); \n\n  while(!que.empty()){\n    P p = que.front();\n    que.pop();\n    int x = p.first,y = p.second;\n    if(grid[x][y] == '.'){\n      res++;\n      grid[x][y] = '#';\n\tif(flagB == true\n\t   &&((x+1 < W && grid[x+1][y] == 'B' )||\n\t      (x-1 >= 0 && grid[x-1][y] == 'B')||\n\t      (y+1 < H && grid[x][y+1] == 'B')||\n\t      (y-1 >= 0 && grid[x][y-1] == 'B'))){\n\t  flagB = false;\n\t}\n\tif(flagW == true &&\n\t   ((x+1 < W && grid[x+1][y] == 'W' )||\n\t    (x-1 >= 0 && grid[x-1][y] == 'W')||\n\t    (y+1 < H && grid[x][y+1] == 'W')||\n\t    (y-1 >= 0 && grid[x][y-1] == 'W'))){\n\t  flagW = false;\n\t}\n    }else continue;\n    for(int i = 0 ; i < 4 ; i++ ){\n      int nx = x + dx[i],ny = y + dy[i];\n\n      if(0 <= nx && nx < W && 0 <= ny && ny < H && grid[nx][ny] == '.'){\n\tque.push(P(nx,ny));\n      }\n    }\n  }\n  if(flagB == false && flagW == true)ansB+=res;\n  else if(flagB == true && flagW == false)ansW+=res;\n N:;\n}\n\nint main(){\n\n  while( cin >> W >> H,W + H ){\n    ansB = 0,ansW = 0;\n\n    for(int i = 0 ; i < H ; i++ ){\n      for(int j = 0 ; j < W ; j++ ){\n\tcin >> grid[j][i];\n      }\n    }\n\n    for(int i = 0 ; i < H ; i++ ){\n      for(int j = 0 ; j < W ; j++ ){\n\tif(grid[j][i] == '.'){\n\t  bfs(j,i);\n\t}\n      }\n    }\n    cout << ansB << \" \" << ansW << endl;\n  } \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<climits>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<queue>\n#include<functional>\n#include<stack>\n#include<list>\n#include<string>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define INF INT_MAX/3\n\nchar MAP[50][50];\nint B_area = 0;\nint W_area = 0;\nint W, H;\nint temp = 0;\n//0:black,1:white\nint color = -1;\nint color_f = 1;\nint dx[4] = { 1, 0, -1, 0 };\nint dy[4] = { 0, 1, 0, -1 };\n\n\nvoid dfs(int x, int y) \n{\n\tif (x < 0 || W <= x || y < 0 || H <= y)return;\n\tif (MAP[y][x]=='D')return;\n\telse if (MAP[y][x] == '.')\n\t{\n\t\ttemp++;\n\t\tMAP[y][x] = 'D';\n\t\tfor (int r = 0; r < 4; r++)\n\t\t{\n\t\t\tint nx = x + dx[r];\n\t\t\tint ny = y + dy[r];\n\t\t\tdfs(nx, ny);\n\t\t}\n\t}\n\telse if (MAP[y][x] == 'W')\n\t{\n\t\tif(color==-1)color = 1;\n\t\telse if (color == 0)color_f = -1;\n\t}\n\telse if (MAP[y][x] == 'B')\n\t{\n\t\tif (color == -1)color = 0;\n\t\telse if (color == 1)color_f = -1;\n\t}\n\t\n\tif (color_f == -1)\n\t{\n\t\tW_area = 0;\n\t\tB_area = 0;\n\t}\n\telse if (color == 0)\n\t{\n\t\tB_area = temp;\n\t\tW_area = 0;\n\t}\n\telse if (color == 1)\n\t{\n\t\tW_area = temp;\n\t\tB_area = 0;\n\t}\n}\n\nint main()\n{\n\twhile (1)\n\t{\n\t\tB_area = 0;\n\t\tW_area = 0;\n\t\tcin >> W >> H;\n\t\tif (W == 0)break;\n\t\tint ansB=0, ansW=0;\n\t\tREP(i, H)REP(j, W)cin >> MAP[i][j];\n\t\tREP(i, H)REP(j, W)\n\t\t{\n\t\t\tif (MAP[i][j] == '.')\n\t\t\t{\n\t\t\t\tcolor = -1;\n\t\t\t\tcolor_f = 1;\n\t\t\t\ttemp = 0;\n\t\t\t\tW_area = 0;\n\t\t\t\tB_area = 0;\n\t\t\t\tdfs(j, i);\n\t\t\t\tansB += B_area;\n\t\t\t\tansW += W_area;\n\t\t\t}\n\t\t}\n\t\tcout << ansB << \" \" << ansW << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvoid spread(int y, int x, vector<vector<bool> >& resField, vector<pair<int, int> > enposes);\n\nint main() {\n  int w, h;\n  while(cin >> w >> h, w || h) {\n    vector<vector<bool> > wfield(h, vector<bool>(w, false));\n    vector<vector<bool> > bfield(h, vector<bool>(w, false));\n    vector<vector<char> > qfield(h, vector<char>(w));\n    vector<pair<int, int> > wposes;\n    vector<pair<int, int> > bposes;\n    for(int y = 0; y < h; ++y) for(int x = 0; x < w; ++x) {\n      char c;\n      cin >> c;\n      qfield[y][x] = c;\n      if(c == 'W') wposes.push_back(make_pair(y, x));\n      if(c == 'B') bposes.push_back(make_pair(y, x));\n    }\n    for(auto&& wpos : wposes) spread(wpos.first, wpos.second, wfield, bposes);\n    for(auto&& bpos : bposes) spread(bpos.first, bpos.second, bfield, wposes);\n    int answ, ansb;\n    answ = ansb = 0;\n    for(int y = 0; y < h; ++y) for(int x = 0; x < w; ++x) {\n      if(wfield[y][x] xor bfield[y][x] && qfield[y][x] == '.') {\n        answ += wfield[y][x];\n        ansb += bfield[y][x];\n      }\n    }\n    cout << ansb << ' ' << answ << endl;\n  }\n  return 0;\n}\n\nvoid spread(int y, int x, vector<vector<bool> >& resField, vector<pair<int, int> > enposes) {\n  int dy[] = {-1, 0, 1, 0};\n  int dx[] = {0, -1, 0, 1};\n  int h = resField.size();\n  int w = resField[0].size();\n  if(y >= 0 && y < h && x >= 0 && x < w && !resField[y][x] && count(begin(enposes), end(enposes), make_pair(y, x)) == 0) {\n    resField[y][x] = true;\n    for(int i = 0; i < 4; ++i) spread(y + dy[i], x + dx[i], resField, enposes);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\nint w,h;\nchar tbl[60][60];\nbool f[2][60][60];\nint dx[] = {0,1,0,-1};\nint dy[] = {1,0,-1,0};\nvoid dfs(int x,int y,int c){\n  f[c][y][x]=true;\n  for(int i=0;i<4;++i){\n    int mx = x+dx[i];\n    int my = y+dy[i];\n    if(mx<0 || my<0) continue;\n    if(mx>=w || my>=h) continue;\n    if(f[c][my][mx]) continue;\n    if(tbl[my][mx]!='.') continue;\n    dfs(mx,my,c);\n  }\n}\n\nint main(){\n  while(cin>>w>>h,w||h){\n    memset(f,0,sizeof(f));\n    for(int i=0;i<h;++i) cin >> tbl[i];\n    for(int i=0;i<h;++i)\n      for(int j=0;j<w;++j){\n\tif(tbl[i][j]=='B'){\n\t  dfs(j,i,0);\n\t}\n\tif(tbl[i][j]=='W'){\n\t  dfs(j,i,1);\n\t}\n      }\n    int B=0,W=0;\n    for(int i=0;i<h;++i)\n      for(int j=0;j<w;++j){\n\tif(tbl[i][j]=='.' && f[0][i][j] && !f[1][i][j]) ++B;\n\tif(tbl[i][j]=='.' && f[1][i][j] && !f[0][i][j]) ++W;\n      }\n    cout << B << \" \" << W << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\n#define stlice(from, to) substr(from, (to) - (from) + 1)\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\nusing namespace std;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\nusing vd = vector<double>;\nusing vc = vector<char>;\nusing vb = vector<bool>;\nusing vs = vector<string>;\nusing vpii = vector<pii>;\nusing vvi = vector<vi>;\nusing vvb = vector<vb>;\nusing vvpii = vector<vpii>;\ntemplate<typename A> using fn = function<A>;\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = acos(-1);\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nconstexpr bool odd(const int &n) { return n & 1; }\nconstexpr bool even(const int &n) { return !odd(n); }\nvoid solve();\nmain { solve(); return 0; }\n// clang-format on\n\nvoid solve() {\n  int W, H;\n  while (cin >> W >> H, W) {\n    vs v(H);\n    rep(i, H) cin >> v[i];\n    vvi dp(H, vi(W));\n    int b = 0, w = 0;\n    rep(i, H) rep(j, W) {\n      dp[i][j] = 2 * (v[i][j] == 'B') + (v[i][j] == 'W');\n      b -= v[i][j] == 'B';\n      w -= v[i][j] == 'W';\n    }\n    rep(_, W * H) rep(i, H) rep(j, W) {\n      if (v[i][j] != '.') continue;\n      if (i > 0) dp[i][j] |= dp[i - 1][j];\n      if (j > 0) dp[i][j] |= dp[i][j - 1];\n      if (i < H - 1) dp[i][j] |= dp[i + 1][j];\n      if (j < W - 1) dp[i][j] |= dp[i][j + 1];\n    }\n    rep(i, H) rep(j, W) {\n      b += dp[i][j] == 2;\n      w += dp[i][j] == 1;\n    }\n    cout << b << ' ' << w << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nchar a[51][51];\nint w,h,bcount,wcount;\n\nvoid white(int i,int j){\n\tif(a[i-1][j] == 'B' && i-1 >= 0){\n\t\ta[i][j] = 'n';\n\t\treturn;\n\t}\n\telse if(a[i+1][j] == 'B' && i+1 < h){\n\t\ta[i][j] = 'n';\n\t\treturn;\n\t}\n\telse if(a[i][j-1] == 'B' && j-1 >= 0){\n\t\ta[i][j] = 'n';\n\t\treturn;\n\t}\n\telse if(a[i][j+1] == 'B' && j+1 < w){\n\t\ta[i][j] = 'n';\n\t\treturn;\n\t}\n\tif(a[i-1][j] == '.' && i-1 >= 0){\n\t\ta[i-1][j] = 'w';\n\t\twhite(i-1,j);\n\t}\n\tif(a[i+1][j] == '.' && i+1 < h){\n\t\ta[i+1][j] = 'w';\n\t\twhite(i+1,j);\n\t}\n\tif(a[i][j-1] == '.' && j-1 >= 0){\n\t\ta[i][j-1] = 'w';\n\t\twhite(i,j-1);\n\t}\n\tif(a[i][j+1] == '.' && j+1 < w){\n\t\ta[i][j+1] = 'w';\n\t\twhite(i,j+1);\n\t}\n}\n\nvoid black(int i,int j){\n\tif(a[i-1][j] == 'W' && i-1 >= 0){\n\t\ta[i][j] = 'n';\n\t\treturn;\n\t}\n\telse if(a[i+1][j] == 'W' && i+1 < h){\n\t\ta[i][j] = 'n';\n\t\treturn;\n\t}\n\telse if(a[i][j-1] == 'W' && j-1 >= 0){\n\t\ta[i][j] = 'n';\n\t\treturn;\n\t}\n\telse if(a[i][j+1] == 'W' && j+1 < w){\n\t\ta[i][j] = 'n';\n\t\treturn;\n\t}\n\tif(a[i-1][j] == '.' && i-1 >= 0){\n\t\ta[i-1][j] = 'b';\n\t\tblack(i-1,j);\n\t}\n\tif(a[i+1][j] == '.' && i+1 < h){\n\t\ta[i+1][j] = 'b';\n\t\tblack(i+1,j);\n\t}\n\tif(a[i][j-1] == '.' && j-1 >= 0){\n\t\ta[i][j-1] = 'b';\n\t\tblack(i,j-1);\n\t}\n\tif(a[i][j+1] == '.' && j+1 < w){\n\t\ta[i][j+1] = 'b';\n\t\tblack(i,j+1);\n\t}\n}\n\nvoid none(int i,int j){\n\tif(a[i-1][j] == 'w' && i-1 >= 0){\n\t\ta[i-1][j] = 'n';\n\t\tnone(i-1,j);\n\t}\n\tif(a[i+1][j] == 'w' && i+1 < h){\n\t\ta[i+1][j] = 'n';\n\t\tnone(i+1,j);\n\t}\n\tif(a[i][j-1] == 'w' && j-1 >= 0){\n\t\ta[i][j-1] = 'n';\n\t\tnone(i,j-1);\n\t}\n\tif(a[i][j+1] == 'w' && j+1 < w){\n\t\ta[i][j+1] = 'n';\n\t\tnone(i,j+1);\n\t}\n\tif(a[i-1][j] == 'b' && i-1 >= 0){\n\t\ta[i-1][j] = 'n';\n\t\tnone(i-1,j);\n\t}\n\tif(a[i+1][j] == 'b' && i+1 < h){\n\t\ta[i+1][j] = 'n';\n\t\tnone(i+1,j);\n\t}\n\tif(a[i][j-1] == 'b' && j-1 >= 0){\n\t\ta[i][j-1] = 'n';\n\t\tnone(i,j-1);\n\t}\n\tif(a[i][j+1] == 'b' && j+1 < w){\n\t\ta[i][j+1] = 'n';\n\t\tnone(i,j+1);\n\t}\n}\n\n\nvoid check(){\n\tfor(int i = 0;i < h;i++){\n\t\tfor(int j = 0;j < w;j++){\n\t\t\tif(a[i][j] == 'W'){\n\t\t\t\tif(a[i-1][j] == '.' && i-1 >= 0){\n\t\t\t\t\ta[i-1][j] = 'w';\n\t\t\t\t\twhite(i-1,j);\n\t\t\t\t}\n\t\t\t\tif(a[i+1][j] == '.' && i+1 < h){\n\t\t\t\t\ta[i+1][j] = 'w';\n\t\t\t\t\twhite(i+1,j);\n\t\t\t\t}\n\t\t\t\tif(a[i][j-1] == '.' && j-1 >= 0){\n\t\t\t\t\ta[i][j-1] = 'w';\n\t\t\t\t\twhite(i,j-1);\n\t\t\t\t}\n\t\t\t\tif(a[i][j+1] == '.' && j+1 < w){\n\t\t\t\t\ta[i][j+1] = 'w';\n\t\t\t\t\twhite(i,j+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(a[i][j] == 'B'){\n\t\t\t\tif(a[i-1][j] == '.' && i-1 >= 0){\n\t\t\t\t\ta[i-1][j] = 'b';\n\t\t\t\t\tblack(i-1,j);\n\t\t\t\t}\n\t\t\t\tif(a[i+1][j] == '.' && i+1 < h){\n\t\t\t\t\ta[i+1][j] = 'b';\n\t\t\t\t\tblack(i+1,j);\n\t\t\t\t}\n\t\t\t\tif(a[i][j-1] == '.' && j-1 >= 0){\n\t\t\t\t\ta[i][j-1] = 'b';\n\t\t\t\t\tblack(i,j-1);\n\t\t\t\t}\n\t\t\t\tif(a[i][j+1] == '.' && j+1 < w){\n\t\t\t\t\ta[i][j+1] = 'b';\n\t\t\t\t\tblack(i,j+1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0;i < h;i++){\n\t\tfor(int j = 0;j < w;j++){\n\t\t\tif(a[i][j] == 'n'){\n\t\t\t\tnone(i,j);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile(1){\n\t\tcin >> h >> w;\n\t\tif(h == 0)break;\n\t\tbcount = wcount = 0;\n\t\tfor(int i = 0;i < h;i++){\n\t\t\tfor(int j = 0;j < w;j++){\n\t\t\t\tcin >> a[i][j];\n\t\t\t}\n\t\t}\n\tcheck();\n\n\tfor(int i = 0;i < h;i++){\n\t\tfor(int j = 0;j < w;j++){\n\t\t\tif(a[i][j] == 'w')wcount++;\n\t\t\tif(a[i][j] == 'b')bcount++;\n\t\t\tcout << a[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << bcount << \" \" << wcount <<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include<bits/stdc++.h>\n#define F first\n#define S second\nusing namespace std;\ntypedef pair<int,int> P;\nint h,w,dx[]={1,0,-1,0},dy[]={0,1,0,-1},ch[50][50],ansb,answ,nx,ny,ok;\nstring s[50];\nchar cnt;\nqueue<P> que;\nvoid ini(void){\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            ch[i][j]=0;\n        }\n    }\n}\nint main(void){\n    while(1){\n    cin>>w>>h;\n    ansb=0,answ=0;\n    if(h==0&&w==0)return 0;\n    for(int i=0;i<h;i++){\n        cin>>s[i];\n    }\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            ok=1;\n            ini();\n            cnt='N';\n            if(s[i][j]!='.')continue;\n            que.push({i,j});\n            ch[i][j]=1;\n            while(que.size()){\n                P q=que.front();\n                que.pop();\n                for(int k=0;k<4;k++){\n                    nx=q.F+dx[k],ny=q.S+dy[k];\n                    if(0<=nx&&nx<h&&0<=ny&&ny<w&&ch[nx][ny]==0){\n                        if(s[nx][ny]=='.'){\n                            que.push({nx,ny});\n                            ch[nx][ny]=1;\n                        }\n                        if(s[nx][ny]=='W'){\n                            if(cnt=='B')ok=0;\n                            else if(cnt=='N')cnt='W';\n                        }\n                        if(s[nx][ny]=='B'){\n                            if(cnt=='W')ok=0;\n                            else if(cnt=='N')cnt='B';\n                        }\n                    }\n                }\n            }\n            if(ok){\n                if(cnt=='B')ansb++;\n                if(cnt=='W')answ++;\n            }\n        }\n        \n    }\n    cout<<ansb<<\" \"<<answ<<endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define endl '\\n'\n#define FOR(i, a, n) for (int i = (a); i < (n); ++i)\n#define REP(i, n) FOR(i, 0, n)\nusing namespace std;\n\nconst int dy[] = {-1, 0, 0, 1};\nconst int dx[] = {0, -1, 1, 0};\nint w, h;\nstring a[50];\nint isW[50][50], isB[50][50];\n\nvoid dfs1(int y, int x) {\n    isW[y][x] = 1;\n    REP (i, 4) {\n        int ny = y + dy[i];\n        int nx = x + dx[i];\n        if (ny >= 0 && ny < h && nx >= 0 && nx < w && !isW[ny][nx] && a[ny][nx] != 'B') {\n            dfs1(ny, nx);\n        }\n    }\n}\n\nvoid dfs2(int y, int x) {\n    isB[y][x] = 1;\n    REP (i, 4) {\n        int ny = y + dy[i];\n        int nx = x + dx[i];\n        if (ny >= 0 && ny < h && nx >= 0 && nx < w && !isB[ny][nx] && a[ny][nx] != 'W') {\n            dfs2(ny, nx);\n        }\n    }\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    while (cin >> w >> h, w) {\n        memset(isW, 0, sizeof(isW));\n        memset(isB, 0, sizeof(isB));\n        REP (i, h) cin >> a[i];\n        REP (i, h) REP (j, w) if (a[i][j] == 'W') {\n            dfs1(i, j);\n        }\n        REP (i, h) REP (j, w) if (a[i][j] == 'B') {\n            dfs2(i, j);\n        }\n        int numW = 0, numB = 0;\n        REP (i, h) REP (j, w) if (a[i][j] == '.') {\n            if (isW[i][j] && !isB[i][j]) numW++;\n            if (!isW[i][j] && isB[i][j]) numB++;\n        }\n        cout << numB << \" \" << numW << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\nconst int dx[] = {1,0,-1,0};\nconst int dy[] = {0,1,0,-1};\n\nint w,h;\nchar fie[51][51];\n\nvoid dfs(int x, int y){\n    for(int i=0; i<4; i++){\n        int xx = x + dx[i];\n        int yy = y + dy[i];\n        if(0 <= xx && xx <= w && 0 <= yy && yy <= h && fie[yy][xx] == '.'){\n            fie[yy][xx] = 'w';\n            dfs(xx,yy);\n        }\n    }\n}\n\nvoid dfs2(int x, int y){\n    for(int i=0; i<4; i++){\n        int xx = x + dx[i];\n        int yy = y + dy[i];\n        if(0 <= xx && xx <= w && 0 <= yy && yy <= h && (fie[yy][xx] == '.' || fie[yy][xx] == 'w')){\n            if(fie[yy][xx] == '.'){\n                fie[yy][xx] = 'b';\n            } else if(fie[yy][xx] == 'w'){\n                fie[yy][xx] = 'x';\n            }\n            dfs2(xx,yy);\n        }\n    }\n}\n\nint main(){\n    while(cin >> w >> h , w||h){\n        for(int i=0; i<h; i++){\n            cin >> fie[i];\n        }\n\n        for(int i=0; i<h; i++){\n            for(int j=0; j<w; j++){\n                if(fie[i][j] == 'W') dfs(j,i);\n            }\n        }\n        for(int i=0; i<h; i++){\n            for(int j=0; j<w; j++){\n                if(fie[i][j] == 'B') dfs2(j,i);\n            }\n        }\n\n        int answ = 0, ansb = 0;\n        for(int i=0; i<h; i++){\n            for(int j=0; j<w; j++){\n                if(fie[i][j] == 'w') answ++;\n                if(fie[i][j] == 'b') ansb++;\n            }\n        }\n        cout << ansb << \" \" << answ << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <array>\n#include <set>\n#include <algorithm>\n\n#define X first\n#define Y second\n\nusing namespace std;\n\nchar table[50][50]; // [x][y]\n\nint dx[4] = { 0, 1, 0, -1 };\nint dy[4] = { 1, 0, -1, 0 };\n\nint g_count[2];\n\nvoid breadth(int x, int y) {\n\tstd::vector<pair<int, int>> queue;\n\tqueue.emplace_back(x,y);\n\tset<char> owner;\n\ttable[x][y] = 'H';\n\tint count = 1;\n\twhile (!queue.empty()) {\n\t\tauto a = queue.back();\n\t\tint x = a.X;\n\t\tint y = a.Y;\n\t\tqueue.pop_back();\n\n\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\tif (table[x + dx[i]][y + dy[i]] == '.') {\n\t\t\t\t++count;\n\t\t\t\tqueue.emplace_back(x + dx[i], y + dy[i]);\n\t\t\t\ttable[x + dx[i]][y + dy[i]] = 'H';\n\t\t\t} else {\n\t\t\t\towner.insert(table[x + dx[i]][y + dy[i]]);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (owner.count('W') != 0 && owner.count('B') == 0) {\n\t\tg_count[1] += count;\n\n\t} else if (owner.count('W') == 0 && owner.count('B') != 0) {\n\t\tg_count[0] += count;\n\t}\n}\n\nint main() {\n\tfor (int i = 0; i < 50; ++i) {\n\t\ttable[i][0] = 'H';\n\t\ttable[0][i] = 'H';\n\t}\n\n\twhile (true) {\n\t\tint w, h;\n\t\tcin >> w >> h;\n\t\tif (w == 0) break;\n\n\t\tg_count[0] = 0;\n\t\tg_count[1] = 0;\n\n\t\tfor (int y = 1; y <= h; ++y) {\n\t\t\tfor (int x = 1; x <= w; ++x) {\n\t\t\t\tcin >> table[x][y];\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < 50; ++i) {\n\t\t\ttable[i][h+1] = 'H';\n\t\t\ttable[w+1][i] = 'H';\n\t\t}\n\n\t\tfor (int x = 1; x <= w; ++x) {\n\t\t\tfor (int y = 1; y <= h; ++y) {\n\t\t\t\tif (table[x][y] != '.') continue;\n\t\t\t\tbreadth(x,y);\n\t\t\t}\n\t\t}\n\t\tcout << g_count[0] << \" \" << g_count[1] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint w = 0, b = 0;\nint n, m;\nchar d[50][50];\nconst int dx[] = {0,1,0,-1}, dy[] = {1,0,-1,0};\n\nvoid bfs (int x, int y, char s, char t, char u) {\n    queue<P> q;\n    q.push(P(x,y));\n\n    while (q.size()) {\n        P p = q.front();\n        q.pop();\n        for (int i = 0; i < 4; i++) {\n            int x = p.first + dx[i], y = p.second + dy[i];\n            if (0 <= x && x < m && 0 <= y && y < n) {\n                if (d[x][y] == '.') {\n                    if (s == 'W') w++;\n                    else b++;\n                    q.push(P(x,y));\n                    d[x][y] = t;\n                } else if (d[x][y] == u) {\n                    if (s == 'W') b--;\n                    else w--;\n                    q.push(P(x,y));\n                    d[x][y] = t;\n                }\n            }\n        }\n    }\n}\n\nint main ()\n{\n    while (cin >> n >> m, (n || m)) {\n        for (int i = 0; i < m; i++) {\n            cin >> d[i];\n        }\n\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (d[i][j] == 'W') {\n                    bfs(i, j, 'W', '*', '@');\n                }\n            }\n        }\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (d[i][j] == 'B') {\n                    bfs(i, j, 'B', '@', '*');\n                }\n            }\n        }\n        cout << b << \" \" << w << endl;\n        w = b = 0;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <map>\nusing namespace std;\ntypedef pair<int ,int> P;\nchar grid[50][50];\nint W,H;\nint dx[] = {0,0,1,-1},dy[] = {1,-1,0,0};\nchar c[2] = {'B','W'};\n\nint bfs(int sx,int sy,int k){\n  queue<P> que;\n  int res[2] = {0};\n  bool flag = true;\n  que.push(P(sx,sy));\n  while(!que.empty()){\n    P p = que.front();\n    que.pop(); \n    if(grid[p.first][p.second] == '.'){\n      grid[p.first][p.second] = c[k];\n      res[k]++;\n      cout << res[k] << endl;\n    }\n    for(int i = 0 ; i < 4 ; i++ ){\n      int nx = p.first + dx[i],ny = p.second + dy[i];\n      if(0 <= nx && nx < W && 0 <= ny && ny < H && grid[nx][ny] == '.'){\n\tque.push(P(nx,ny));\n\tif((nx+1 < W && grid[nx+1][ny] == c[!k])||\n\t   (nx-1 >= 0 && grid[nx-1][ny] == c[!k])||\n\t   (ny+1 < H && grid[nx][ny+1] == c[!k])||\n\t   (ny-1 >= 0 && grid[nx][ny-1] == c[!k]))flag = false;\n      }\n    }\n  }\n  if(flag == true)return res[k];\n  else return 0; \n}\n\nint main(){\n  while( cin >> W >> H , W+H ){\n\n    for(int i = 0 ; i < H ; i++ ){\n      for(int j = 0 ; j < W ; j++ ){\n\tcin >> grid[j][i];\n      }\n    }\n    int ans[2] = {0};\n    for(int k = 0 ; k < 2 ; k++ ){\n      for(int i = 0 ; i < H ; i++ ){\n\tfor(int j = 0 ; j < W ; j++ ){\n\t  if(grid[j][i] == '.'){\n\t    if((j+1 < W && grid[j+1][i] == c[k])||\n\t       (j-1 >= 0 && grid[j-1][i] == c[k])||\n\t       (i+1 < H && grid[j][i+1] == c[k])||\n\t       (i-1 >= 0 && grid[j][i-1] == c[k]))ans[k]+=bfs(j,i,k);\n\t  }\n\t}\n      }\n    }\n    cout << ans[0] <<\" \"<< ans[1] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <functional>\n#include <set>\n#include <sstream>\n#include <map>\n#include <queue>\n#include <stack>\n\nusing namespace std;\n\n\nconst int dx[]={0,0,-1,1};\nconst int dy[]={-1,1,0,0};\n\nint main()\n{\n\tint w,h;\n\twhile(cin>>w>>h,w||h){\n\t\tvector<string> p(h);\n\t\tfor(int i=0;i<h;i++) cin>>p[i];\n\n\t\tint resB=0,resW=0;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tbool black=false,white=false;\n\t\t\t\tif(p[i][j]=='.'){\n\t\t\t\t\tvector<vector<bool> > vis(h,vector<bool>(w,false));\n\t\t\t\t\tqueue<pair<int,int> > q;\n\t\t\t\t\tq.push(make_pair(i,j));\n\n\t\t\t\t\twhile(!q.empty()){\n\t\t\t\t\t\tint y=q.front().first,x=q.front().second;\n\t\t\t\t\t\tq.pop();\n\t\t\t\t\t\tif(vis[y][x]) continue;\n\n\t\t\t\t\t\tvis[y][x]=true;\n\n\t\t\t\t\t\tif(p[y][x]=='W'){ white=true; continue;}\n\t\t\t\t\t\tif(p[y][x]=='B'){ black=true; continue;}\n\n\t\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\t\tint ny=y+dy[k],nx=x+dx[k];\n\t\t\t\t\t\t\tif(ny<0 || ny>=h || nx<0 || nx>=w) continue;\n\t\t\t\t\t\t\tq.push(make_pair(ny,nx));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n/*\n\t\t\t\tcout<<i<<\" \"<<j<<\":\";\n\t\t\t\tif(black) cout<<\"B\";\n\t\t\t\tif(white) cout<<\"W\";\n\t\t\t\tcout<<endl;\n*/\n\t\t\t\tif(black && !white) resB++;\n\t\t\t\tif(!black && white) resW++;\n\t\t\t}\n\t\t}\n\n\t\tcout<<resB<<\" \"<<resW<<endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nchar m[55][55];\nbool used[55][55];\nint w,h;\nint dx[] = {0,0,1,-1};\nint dy[] = {1,-1,0,0};\nchar c;\n\nint solve(int x,int y){\n  int ret = 0;\n  for(int i = 0; i < 4; i++){\n    int nx = x + dx[i];\n    int ny = y + dy[i];\n    if(m[nx][ny] == c){\n      return -1000000;\n    }\n    if(m[nx][ny] == '.' && used[nx][ny]){\n      used[nx][ny] = false;\n      ret += solve(nx,ny) + 1;\n    }\n  }\n  return ret;\n}\n\nint main(void){\n  while(1){\n    scanf(\"%d%d\",&w,&h);\n    if(!w && !h) break;\n    memset(m,0,sizeof(m));\n    for(int i = 1; i <= h; i++){\n      for(int j = 1; j <= w; j++){\n\tscanf(\" %c\",&m[i][j]);\n      }\n    }\n    for(int k = 0; k < 2; k++){\n      int ans = 0;\n      memset(used,true,sizeof(used));\n      c = (k)?'B':'W';\n      for(int i = 1; i <= h; i++){\n\tfor(int j = 1; j <= w; j++){\n\t  ans += max(0,solve(i,j));\n\t}\n      }\n      printf(\"%d%c\",ans,(k)?'\\n':' ');\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\n\nint w,h;\nstring s[100];\n\nvoid solve(int i,int j,char c){\n\n  if(i < 0 || j < 0 || i == w || j == h) return;\n  if(s[j][i] == 'W' || s[j][i] == 'B') return;\n  if(c == 'W' && s[j][i] == '*') return;\n  if(c == 'B' && s[j][i] == '#') return;\n  if(s[j][i] == '@') return;\n\n  if(s[j][i] == '.' && c == 'W') s[j][i] = '*';\n  if(s[j][i] == '.' && c == 'B') s[j][i] = '#';\n\n  if(s[j][i] == '*' && c == 'B') s[j][i] = '@';\n  if(s[j][i] == '#' && c == 'W') s[j][i] = '@';\n\n  solve(i+1,j,c);\n  solve(i,j+1,c);\n  solve(i-1,j,c);\n  solve(i,j-1,c);\n\n}\n\nint main(){\n\n  while(true){\n    cin >> w >> h;\n    if(!w && !h) break;\n\n    for(int i=0;i<h;i++) cin >> s[i];\n\n    for(int i=0;i<w;i++){\n      for(int j=0;j<h;j++){\n\tif(s[j][i] == 'W' || s[j][i] == 'B'){\n\t  solve(i+1,j,s[j][i]);\n\t  solve(i,j+1,s[j][i]);\n\t  solve(i-1,j,s[j][i]);\n\t  solve(i,j-1,s[j][i]);\n\t}\n      }\n    }\n\n    int answ = 0,ansb = 0;\n\n    for(int i=0;i<w;i++){\n      for(int j=0;j<h;j++){\n\tif(s[j][i] == '*') answ++;\n\tif(s[j][i] == '#') ansb++;\n      }\n    }\n\n    cout << ansb << \" \" << answ << endl;\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint w = 0, b = 0;\nint n, m;\nchar d[50][50];\nconst int dx[] = {0,1,0,-1}, dy[] = {1,0,-1,0};\n\nvoid bfs (int x, int y, char s) {\n    queue<P> q;\n    q.push(P(x,y));\n\n    while (q.size()) {\n        P p = q.front();\n        q.pop();\n        for (int i = 0; i < 4; i++) {\n            int x = p.first + dx[i], y = p.second + dy[i];\n            if (0 <= x && x < m && 0 <= y && y < n) {\n                if (d[x][y] == '.') {\n                    d[x][y] = s == 'W' ? '@' : '*';\n                    s == 'W' ? b++ : w++;\n                    q.push(P(x,y));\n                } else if (d[x][y] == (s == 'W' ? '*' : '@')) {\n                    d[x][y] = s == 'W' ? '@' : '*';\n                    s == 'W' ? w-- : b--;\n                    q.push(P(x,y));\n                }\n            }\n        }\n    }\n}\n\nint main ()\n{\n    while (cin >> n >> m, (n || m)) {\n        for (int i = 0; i < m; i++) {\n            cin >> d[i];\n        }\n\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (d[i][j] == 'W') {\n                    bfs(i, j, 'W');\n                }\n            }\n        }\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (d[i][j] == 'B') {\n                    bfs(i, j, 'B');\n                }\n            }\n        }\n        cout << w << \" \" << b << endl;\n        w = b = 0;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nint h,w;\nint black[52][52];\nint white[52][52];\n\nbool chk_b(int x,int y){\n  if (black[x][y] == 1)\n    return true;\n  if (black[x][y] < 0)\n    return false;\n  if (black[x][y] == 0){\n    black[x][y] = -1;\n    if (chk_b(x-1,y)||chk_b(x+1,y)||chk_b(x,y+1)||chk_b(x,y-1)){\n      black[x][y] = 1;\n      return true;\n    }\n    else{\n      black[x][y] = 0;\n      return false;\n    }\n  }\n}\n\nbool chk_w(int x,int y){\n  if (white[x][y] == 1)\n    return true;\n  if (white[x][y] < 0)\n    return false;\n  if (white[x][y] == 0){\n    white[x][y] = -1;\n    if (chk_w(x-1,y)||chk_w(x+1,y)||chk_w(x,y+1)||chk_w(x,y-1)){\n      white[x][y] = 1;\n      return true;\n    }\n    else{\n      white[x][y] = 0;\n      return false;\n    }\n  }\n}\n\nint reset(){\n  for(int y=1;y<51;y++){\n    for(int x = 1;x<51;x++){\n      black[x][y] = 0;\n      white[x][y] = 0;\n    }\n  }\n  for(int i=0;i<52;i++){\n    black[i][0] = -2;\n    black[0][i] = -2;\n    black[i][h+1] = -2;\n    black[w+1][i] = -2;\n    white[i][0] = -2;\n    white[0][i] = -2;\n    white[i][h+1] = -2;\n    white[w+1][i] = -2;\n  }\n}\n\nint main(){\n  while(true){\n    int bb=0,ww=0;\n    cin >> w >> h;\n    if (w==0&&h==0)\n      break;\n    reset();\n    vector<string> dataset(h);\n    for(int i=0;i<h;i++){\n      cin >> dataset[i];\n    }\n    for(int y=0;y<h;y++){\n      for(int x=0;x<w;x++){\n\tswitch (dataset[y][x]){\n\tcase '.':\n\t  break;\n\tcase 'W':\n\t  white[x+1][y+1] = 1;\n\t  black[x+1][y+1] = -1;\n\t  ww--;\n\t  break;\n\tcase 'B':\n\t  bb--;\n\t  black[x+1][y+1] = 1;\n\t  white[x+1][y+1] = -1;\n\t  break;\n\t}\n      }\n    }\n\n    for(int y=1;y<h+1;y++){\n      for(int x=1;x<w+1;x++){\n\tif (chk_b(x,y) && !chk_w(x,y))\n\t  bb++;\n\tif (!chk_b(x,y) && chk_w(x,y))\n\t  ww++;\n      }\n    }\n    cout << bb << \" \" << ww << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n\nint w,h;\nstring f[100];\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,1,0,-1};\n\nvoid solve(int x,int y,char c){\n\tchar c_ , r ;\n\tif( c == 'W' ){\n\t\tc_ = 'w';\n\t\tr = 'B';\n\t}\n\tif( c == 'B'){\n\t\tc_ = 'b';\n\t\tr = 'W';\n\t}\n\t\n\tfor(int i=0 ; i<4 ; ++i ){\n\t\tint mx = x + dx[i];\n\t\tint my = y + dy[i];\n\t\t\n\t\tif( mx < 0 || my < 0 || mx >= w || my >= h ) continue;\n\t\t\n\t\tif( c == 'W' || c == 'B'){\n\t\t\tif( f[my][mx] == '.' ){\n\t\t\t\tf[my][mx] = c_ ;\n\t\t\t\tsolve( mx , my , c );\n\t\t\t}\n\t\t\tif( f[my][mx] == r ){\n\t\t\t\tf[my][mx] = 'x' ;\n\t\t\t\tsolve( mx , my , 'x' );\n\t\t\t}\n\t\t}else if( c == 'x' ){\n\t\t\tif( f[my][mx] == 'w' || f[my][mx] == 'b' || f[my][mx] == '.' ){\n\t\t\t\tf[my][mx] = 'x';\n\t\t\t\tsolve( mx , my , 'x' );\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid debug(){\n\tcout << endl;\n\tfor(int y=0 ; y<h ; ++y ){\n\t\tcout << f[y] << endl;\n\t}\n\tcout << endl;\n}\n\nint main(){\n\n\twhile( cin >> w >> h , w|h ){\n\t\tfor(int y=0 ; y<h ; ++y ){\n\t\t\tcin >> f[y];\n\t\t}\n\t\tfor(int y=0 ; y<h ; ++y ){\n\t\t\tfor(int x=0 ; x<w ; ++x ){\n\t\t\t\tif( f[y][x] == 'W' ){\n\t\t\t\t\tsolve( x , y , 'W' );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int y=0 ; y<h ; ++y ){\n\t\t\tfor(int x=0 ; x<w ; ++x ){\n\t\t\t\tif( f[y][x] == 'B' ){\n\t\t\t\t\tsolve( x , y , 'B' );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//debug();\n\t\tint black = 0 , white = 0;\n\t\tfor(int y=0 ; y<h ; ++y ){\n\t\t\tfor(int x=0 ; x<w ; ++x ){\n\t\t\t\tif( f[y][x] == 'w' )\n\t\t\t\t\twhite++;\n\t\t\t\tif( f[y][x] == 'b' )\n\t\t\t\t\tblack++;\n\t\t\t}\n\t\t}\n\t\tcout << black << \" \" << white << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"vector\"\n#include \"string\"\n#include \"cstring\"\nusing namespace std;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nbool black[50][50],white[50][50];\nstring in[50];\nbool used[50][50];\nint w,h;\n\nvoid dfs(int y,int x,int f)\n{\n\tif(f==1) white[y][x]=true;\n\telse black[y][x]=true;\n\tused[y][x]=true;\n\tfor (int i = 0; i < 4; i++) {\n\t\tint nx=x+dx[i],ny=y+dy[i];\n\t\tif(0<=nx&&nx<w&&0<=ny&&ny<h&&!used[ny][nx]&&in[ny][nx]=='.')\n\t\t\tdfs(ny,nx,f);\n\t}\n}\n\nint main(void)\n{\n\twhile (cin>>w>>h,w) {\n\t\tmemset(black,0,sizeof(black));\n\t\tmemset(white,0,sizeof(white));\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tcin>>in[i];\n\t\t}\n\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tint f=0;\n\t\t\t\tif(in[i][j]=='W') f=1;\n\t\t\t\telse if(in[i][j]=='B') f=2;\n\n\t\t\t\tif(in[i][j]!='.')\n\t\t\t\t{\n\t\t\t\t\tmemset(used,0,sizeof(used));\n\t\t\t\t\tdfs(i,j,f);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint Black=0,White=0;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif(in[i][j]!='B'&&black[i][j]&&!white[i][j]) Black++;\n\t\t\t\telse if(in[i][j]!='W'&&!black[i][j]&&white[i][j]) White++;\n\t\t\t}\n\t\t}\n\t\tcout<<Black<<\" \"<<White<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing namespace std;\n\nint w,h,a[50][50];\nint dx[4]={1,0,-1,0},dy[4]={0,1,0,-1};\n\nvoid dfs(int x,int y,int c) {\n\tfor(int i=0;i<4;i++) {\n\t\tint nx=x+dx[i],ny=y+dy[i];\n\t\tif(0<=nx&&nx<w&&0<=ny&&ny<h) {\n\t\t\tif(a[nx][ny]=='.') {\n\t\t\t\ta[nx][ny]=c;\n\t\t\t\tdfs(nx,ny,c);\n\t\t\t}else if((a[nx][ny]=='w'&&c=='b')||(a[nx][ny]=='b'&&c=='w')) {\n\t\t\t\ta[nx][ny]='#';\n\t\t\t\tdfs(nx,ny,c);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\twhile(scanf(\"%d %d\",&w,&h),w||h) {\n\t\tgetchar();\n\t\tfor(int j=0;j<h;j++) {\n\t\t\tfor(int i=0;i<w;i++) {\n\t\t\t\ta[i][j]=getchar();\n\t\t\t}\n\t\t\tgetchar();\n\t\t}\n\t\tfor(int j=0;j<h;j++) {\n\t\t\tfor(int i=0;i<w;i++) {\n\t\t\t\tif(a[i][j]=='W') dfs(i,j,'w');\n\t\t\t\tif(a[i][j]=='B') dfs(i,j,'b');\n\t\t\t}\n\t\t}\n\t\tint cw=0,cb=0;\n\t\tfor(int j=0;j<h;j++) {\n\t\t\tfor(int i=0;i<w;i++) {\n\t\t\t\tif(a[i][j]=='w') cw++;\n\t\t\t\tif(a[i][j]=='b') cb++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\",cb,cw);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nconst int dx[4] = {-1, 0, 0, 1};\nconst int dy[4] = {0, -1, 1, 0};\nint w, h;\nchar v[51][51];\nbool used[51][51];\n\ninline bool valid(int y, int x) {\n    return 0 <= y && y < h && 0 <= x && x < w;\n}\n\nint dfs(int y, int x, bool &adjb, bool &adjw, int &area) {\n    used[y][x] = true;\n    area ++;\n    for (int i=0; i<4; ++i) {\n        if (valid(y + dy[i], x + dx[i])) {\n            adjb |= (v[y + dy[i]][x + dx[i]] == 'B');\n            adjw |= (v[y + dy[i]][x + dx[i]] == 'W');\n            if ( ! used[y + dy[i]][x + dx[i]] && v[y + dy[i]][x + dx[i]] == '.') {\n                dfs(y + dy[i], x + dx[i], adjb, adjw, area);\n            }\n        }\n    }\n}\n\nint main() {\n    while (cin >> w >> h) {\n        if (w == 0 && h == 0) break;\n        for (int i=0; i<h; ++i) {\n            for (int j=0; j<w; ++j) {\n                cin >> v[i][j];\n            }\n        }\n        memset(used, 0, sizeof used);\n        int white = 0, black = 0;\n        for (int i=0; i<h; ++i) {\n            for (int j=0; j<w; ++j) {\n                if ( ! used[i][j] && v[i][j] == '.') {\n                    int area = 0;\n                    bool adjb = false, adjw = false;\n                    dfs(i, j, adjb, adjw, area);\n                    if ( ! adjb && adjw) {\n                        white += area;\n                    } else if (adjb && ! adjw) {\n                        black += area;\n                    }\n                }\n            }\n        }\n        cout << black << \" \" << white << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\n#define stlice(from, to) substr(from, (to) - (from) + 1)\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\nusing namespace std;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\nusing vd = vector<double>;\nusing vc = vector<char>;\nusing vb = vector<bool>;\nusing vs = vector<string>;\nusing vpii = vector<pii>;\nusing vvi = vector<vi>;\nusing vvb = vector<vb>;\nusing vvpii = vector<vpii>;\ntemplate<typename A> using fn = function<A>;\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = acos(-1);\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nconstexpr bool odd(const int &n) { return n & 1; }\nconstexpr bool even(const int &n) { return !odd(n); }\nvoid solve();\nmain { solve(); return 0; }\n// clang-format on\n\nvoid solve() {\n  int W, H;\n  while (cin >> W >> H, W) {\n    vs v(H);\n    rep(i, H) cin >> v[i];\n    vvi dp(H, vi(W));\n    int b = 0, w = 0;\n    rep(i, H) rep(j, W) {\n      dp[i][j] = 2 * (v[i][j] == 'B') + (v[i][j] == 'W');\n      b -= v[i][j] == 'B';\n      w -= v[i][j] == 'W';\n    }\n    rep(_, W * H) rep(i, H) rep(j, W) {\n      if (v[i][j] != '.') continue;\n      if (i > 0) dp[i][j] |= dp[i - 1][j];\n      if (j > 0) dp[i][j] |= dp[i][j - 1];\n      if (i < H - 1) dp[i][j] |= dp[i + 1][j];\n      if (j < W - 1) dp[i][j] |= dp[i][j + 1];\n    }\n    rep(i, H) rep(j, W) {\n      b += dp[i][j] == 2;\n      w += dp[i][j] == 1;\n    }\n    cout << b << ' ' << w << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint dx[4] = {-1,1,0,0};\nint dy[4] = {0,0,-1,1};\nint w,h;\n\nint dfs(int y, int x, set<char>& flag, vector<string>& m,vector<vector<int> >& used){\n\n\n  if(y >= h || y < 0 || x >= w || x < 0) return 0; \n  if(used[y][x] == 1) return 0; // ?????????\n  if(m[y][x] == 'B' || m[y][x] == 'W'){\n    flag.insert(m[y][x]);\n    return 0;\n  }\n\n\n  used[y][x] = 1;  \n  int ans = 1;\n  for(int i=0; i<4; i++){\n    int nx = x + dx[i], ny = y + dy[i];\n    ans += dfs(ny,nx,flag,m,used);\n  }\n  return ans;\n}\n\n\nint main(){\n\n  while(1){\n    cin >> w >> h;\n    if(!w and !h) break;\n\n    vector<string> m(h);\n    for(int j=0; j<h; j++)\n      cin >> m[j];\n\n    int bl=0,wh=0;\n    vector<vector<int> > used(h,vector<int>(w,0));\n    for(int j=0; j<h; j++){\n      for(int i=0; i<w; i++){\n\tif(m[j][i] == '.' and used[j][i] == 0){\n\t  set<char> flag;\n\t  int x = dfs(j,i,flag,m,used);\n\t  if(flag.size() == 1 and *flag.begin() == 'B')\n\t    bl += x;\n\t  if(flag.size() == 1 and *flag.begin() == 'W')\n\t    wh += x;\n\t}\n      }\n    }\n    cout << bl << \" \" << wh << endl;\n  }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<algorithm>\n#include<string>\nusing namespace std;\n\nint main(){\n\n\tstring X;\n\n\tchar MA[55][55];\n\tint x,y;\n\n\twhile(1){\n\t\tcin>>x>>y;if(x==0&&y==0)break;\n\n\t\tfor(int i=0;i<y;i++)\n\t\t{cin>>X;\n\t\tfor(int j=0;j<X.size();j++)\n\t\t\tMA[i][j]=X[j];}\n\n\t\tint map[55][55]={};\n\t\tint G=0;\n\n\t\tfor(int i=0;i<y;i++)\n\t\t{G++;\n\t\tfor(int j=0;j<x;j++)\n\t\t{if(MA[i][j]=='.'){\n\t\t\tif(j>0&&MA[i][j-1]!='.')G++;\n\t\t\tmap[i][j]=G;\n\t\t}\n\t\t\n\t\tif(MA[i][j]=='B'){map[i][j]=7001;}\n\t\tif(MA[i][j]=='W'){map[i][j]=7005;}\n\t\t}}\n\t\tfor(int i=0;i<y;i++)\n\t\tfor(int j=0;j<x;j++)\n\t\t{if(map[i][j]<7000){\n\t\t\tif(map[i][j]!=map[i+1][j]&&map[i+1][j]<7000){\n\t\t\t\tint P=map[i+1][j];\n\t\t\t\tfor(int I=0;I<y;I++)\n\t\t\t\t\tfor(int J=0;J<x;J++)\n\t\t\t\t\t\tif(map[I][J]==P)map[I][J]=map[i][j];\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t}\n\n\t\tint F[7000]={};int cnt[7010]={};\n\t\tfor(int i=0;i<y;i++)\n\t\tfor(int j=0;j<x;j++)\n\t\t\t{\n\n\t\t\t\tcnt[map[i][j]]++;\n\t\t\t\tif(map[i][j]==7001){\n\t\t\t\t\tif(i>0&&map[i-1][j]<7000){if(F[map[i-1][j]]==0||F[map[i-1][j]]==5)F[map[i-1][j]]+=1;}\n\t\t\t\t\tif(map[i+1][j]<7000){if(F[map[i+1][j]]==0||F[map[i+1][j]]==5)F[map[i+1][j]]+=1;}\n\t\t\t\t\tif(j>0&&map[i][j-1]<7000){if(F[map[i][j-1]]==0||F[map[i][j-1]]==5)F[map[i][j-1]]+=1;}\n\t\t\t\t\tif(map[i][j+1]<7000){if(F[map[i][j+1]]==0||F[map[i][j+1]]==5)F[map[i][j+1]]+=1;}\n\t\t\t\t}\n\n\t\t\t\telse if(map[i][j]==7005){\n\t\t\t\t\tif(i>0&&map[i-1][j]<7000){if(F[map[i-1][j]]==0||F[map[i-1][j]]==1)F[map[i-1][j]]+=5;}\n\t\t\t\t\tif(map[i+1][j]<7000){if(F[map[i+1][j]]==0||F[map[i+1][j]]==1)F[map[i+1][j]]+=5;}\n\t\t\t\t\tif(j>0&&map[i][j-1]<7000){if(F[map[i][j-1]]==0||F[map[i][j-1]]==1)F[map[i][j-1]]+=5;}\n\t\t\t\t\tif(map[i][j+1]<7000){if(F[map[i][j+1]]==0||F[map[i][j+1]]==1)F[map[i][j+1]]+=5;}\n\t\t\t\t}\n\n\t\t}\n\t\t\t\n\t\tint B=0,W=0;\n\t\tfor(int i=0;i<7000;i++)\n\t\t{if(F[i]==1)B+=cnt[i];\n\t\telse if(F[i]==5)W+=cnt[i];\n\t\t}\n\t\tcout<<B<<\" \"<<W<<endl;\n\n\n/*\n\t\t\n\t\tfor(int i=0;i<y;i++)\n\t\t{cout<<endl;\n\t\tfor(int j=0;j<x;j++)\n\t\t\tcout<<map[i][j];}\n\n\t\t\t*/\n\t\t\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\n#include <cstring>\n#include <set>\n\nusing namespace std;\n\nchar f[52][52];\nbool visited[52][52];\nint w,h;\n\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,-1,0,1};\n\nint bfs(int y, int x){\n    deque<pair<int,int> > q;\n    set<char> s;\n    int ret=1;\n    q.push_back(make_pair(y,x));\n    visited[y][x] = true;\n\n    int tx, ty, nx, ny;\n    while(!q.empty()){\n        ty = q.front().first;\n        tx = q.front().second;\n        q.pop_front();\n        for(int i=0;i<4;i++){\n            ny = ty + dy[i];\n            nx = tx + dx[i];\n\n            if(f[ny][nx] == -1){\n                //do nothing\n            }else if(f[ny][nx] == 'W'){\n                s.insert('W');\n            }else if(f[ny][nx] == 'B'){\n                s.insert('B');\n            }else{\n                if(!visited[ny][nx]){\n                    visited[ny][nx] = true;\n                    q.push_back(make_pair(ny,nx));\n                    ret++;\n                }\n            }\n        }\n    }\n    if(s.size() == 2 || s.size() == 0){\n        return -1;\n    }else{\n        if(s.find('W') != s.end()){\n            return ret+10000;\n        }else{\n            return ret;\n        }\n    }\n}\n\nint main(){\n    while(cin >> w >> h){\n        if((w|h) == 0) break;\n        memset(f, -1 , sizeof(f));\n        memset(visited, false, sizeof(visited));\n\n        for(int i=1;i<=h;i++){\n            for(int j=1;j<=w;j++){\n                cin >> f[i][j];\n            }\n        }\n        int bl=0,wh=0,tmp;\n        for(int i=1;i<=h;i++){\n            for(int j=1;j<=w;j++){\n                if(!visited[i][j] && f[i][j] == '.'){\n                    tmp = bfs(i,j);\n                    if(tmp != -1){\n                        if(tmp > 10000){\n                            wh += tmp%10000;\n                        }else{\n                            bl += tmp;\n                        }\n                    }\n                }\n            }\n        }\n        cout << bl << \" \" << wh << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef _WIN32\n#include<iostream>\n#endif\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<queue>\nusing namespace std;\n\n#define FOR(i,bg,ed) for(int i=(bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\ntypedef vector<string> VS;\nVS wrap(VS v,char c) {\n\tint R = v.size(), C = v[0].size();\n\tVS ret(R + 2, string(C + 2, c));\n\tREP(i, R)REP(j, C)ret[i + 1][j + 1] = v[i][j];\n\treturn ret;\n}\nconst int dr[] = { 0,0,1,-1 };\nconst int dc[] = { 1,-1,0,0 };\n\nvoid w(int r, int c,VS&x) {\n\tif (x[r][c] != '.')return;\n\tx[r][c] = 'w';\n\tREP(i, 4) {\n\t\tw(r + dr[i], c + dc[i], x);\n\t}\n}\nvoid b(int r, int c, VS&x) {\n\tif (x[r][c] != '.')return;\n\tx[r][c] = 'b';\n\tREP(i, 4) {\n\t\tb(r + dr[i], c + dc[i], x);\n\t}\n}\n\nint main() {\n\tint R, C;\n\twhile (cin >> C >> R, R + C) {\n\t\tVS in(R);\n\t\tREP(i, R)cin >> in[i];\n\t\tin = wrap(in, '#');\n\t\tauto ww = in;\n\t\tauto bb = in;\n\t\tREP(i, R + 2)REP(j, C + 2)if (in[i][j] == 'W') {\n\t\t\tREP(k,4)w(i+dr[k], j+dc[k], ww);\n\t\t}\n\t\tREP(i, R + 2)REP(j, C + 2)if (in[i][j] == 'B') {\n\t\t\tREP(k,4)b(i+dr[k], j+dc[k], bb);\n\t\t}\n\t\tint wwww = 0, bbbb = 0;\n\t\tREP(i, R + 2)REP(j, C + 2)if (in[i][j] == '.') {\n\t\t\tif (ww[i][j] == 'w'&&bb[i][j] != 'b')wwww++;\n\t\t\tif (bb[i][j] == 'b'&&ww[i][j] != 'w')bbbb++;\n\n\t\t}\n\t\tcout << bbbb << \" \" << wwww << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<stdio.h>\n#include<queue>\n#include <climits>\n#include <map>\n#include <set>\nconst int mod = 1e9 + 7;\nconst int INF = 1 << 20;\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint dx[4] = {-1,0,0,1};\nint dy[4] = {0,-1,1,0};\nint w,h;\n\nvoid wdfs(int x,int y,char f[51][51])\n{\n    if(f[y][x] == '.') f[y][x] = 'w';\n    for(int i = 0; i < 4; i++){\n        int nx = x+dx[i];\n        int ny = y+dy[i];\n        if(nx >= 0 && ny >= 0 && nx < w && ny < h && f[ny][nx] == '.'){\n            wdfs(nx,ny,f);\n        }\n    }\n    return ;\n}\n\nvoid bdfs(int x,int y,char f[51][51])\n{\n    if(f[y][x] == '.') f[y][x] = 'b';\n    for(int i = 0; i < 4; i++){\n        int nx = x+dx[i];\n        int ny = y+dy[i];\n        \n        if(nx >= 0 && ny >= 0 && nx < w && ny < h && f[ny][nx] == '.'){\n            \n            bdfs(nx,ny,f);\n        }\n    }\n    return ;\n}\n\nint main()\n{\n    while(true){\n        cin >> w >> h;\n        if(w == 0 && h == 0) break;\n        char white[51][51];\n        char black[51][51];\n        char f[51][51];\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                char c;\n                cin >> c;\n                white[i][j] = c;\n                black[i][j] = c;\n                f[i][j] = c;\n            }\n        }\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                if(f[i][j] == 'W'){\n                    wdfs(j,i,white);\n                } \n                if(f[i][j] == 'B'){\n                    bdfs(j,i,black);\n                }\n            }\n        }\n        int wcnt = 0,bcnt = 0;\n        for(int i = 0; i < h; i++){\n            for(int j= 0; j < w; j++){\n                if(white[i][j] == 'w' && black[i][j] == '.'){\n                    wcnt++;\n                }\n                if(white[i][j] == '.' && black[i][j] == 'b'){\n                    bcnt++;\n                }\n            }\n        }\n        cout << bcnt << ' ' << wcnt << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef pair<ll, ll> P;\n\n#define EACH(i,a) for (auto& i : a)\n#define FOR(i,a,b) for (ll i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (ll i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (ll i=0;i<(n);i++)\n#define RREP(i,n) for (ll i=(n)-1;i>=0;i--)\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\nconst ll linf = 1e18;\nconst int inf = 1e9;\nconst double eps = 1e-12;\nconst double pi = acos(-1);\n\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& vec) {\n\tEACH(x,vec) is >> x;\n\treturn is;\n}\n/*\ntemplate<class... T>\nostream& operator<<(ostream& os, tuple<T...>& t) {\n\tfor (size_t i = 0; i < tuple_size< tuple<T...> >::value; ++i) {\n\t\tif (i) os << \" \";\n\t\tos << get<0>(t);\n\t}\n\treturn os;\n}\n*/\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << \" \";\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector< vector<T> >& vec) {\n\tREP(i,vec.size()) {\n\t\tif (i) os << endl;\n\t\tos << vec[i];\n\t}\n\treturn os;\n}\n\nint W, H;\nvector<string> m;\nbool inRange(int x, int y) {\n\treturn 0 <= x && x < W && 0 <= y && y < H;\n}\nconst int dx[] = {0, 1, 0, -1};\nconst int dy[] = {-1, 0, 1, 0};\nset<char> check(int x, int y, vector< vector<bool> >& checked) {\n\tset<char> res;\n\tif ( !inRange(x, y) ) return res;\n\tif (checked[y][x]) return res;\n\tchecked[y][x] = true;\n\tif ( m[y][x] != '.' ) {\n\t\tres.insert(m[y][x]);\n\t\treturn res;\n\t}\n\tREP(i, 4) {\n\t\tset<char> s = check(x+dx[i], y+dy[i], checked);\n\t\tEACH(e, s) res.insert(e);\n\t}\n\treturn res;\n}\nint main() {\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\twhile ( cin >> W >> H, W || H ) {\n\t\tm = vector<string>(H); cin >> m;\n\t\tmap<char, int> ans;\n\t\tans['W'] = 0;\n\t\tans['B'] = 0;\n\t\tREP(y, H) REP(x, W) {\n\t\t\tswitch (m[y][x]) {\n\t\t\t\tcase 'W': break;\n\t\t\t\tcase 'B': break;\n\t\t\t\tcase '.':\n\t\t\t\t{\n\t\t\t\t\tvector< vector<bool> > checked(H, vector<bool>(W, false));\n\t\t\t\t\tset<char> s = check(x, y, checked);\n\t\t\t\t\tif (s.size() == 1) {\n\t\t\t\t\t\tans[*s.begin()]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans['B'] << \" \" << ans['W'] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <queue>\n\nusing namespace std;\n\nint main(void){\n\tint black[50][50], white[50][50], h, w, i, j, k, x, y, bc, wc;\n\tchar field[50][51];\n\tconst int dx[4] = {1,0,-1,0},dy[4] = {0,1,0,-1};\n\tqueue<int> qx,qy;\n\tscanf(\"%d%d%*c\",&w,&h);\n\twhile(w != 0 || h != 0){\n\t\tmemset(black,0,sizeof(black));\n\t\tmemset(white,0,sizeof(white));\n\t\tfor(i = 0;i < h;i++){\n\t\t\tfor(j = 0;j < w;j++)\n\t\t\t\tfield[i][j] = getchar();\n\t\t\tgetchar();\n\t\t}\n\t\tfor(i = 0;i < h;i++){\n\t\t\tfor(j = 0;j < w;j++){\n\t\t\t\tif(field[i][j] == 'B'){\n\t\t\t\t\tqx.push(j);\n\t\t\t\t\tqy.push(i);\n\t\t\t\t\twhile(qx.size()){\n\t\t\t\t\t\tx = qx.front();\n\t\t\t\t\t\ty = qy.front();\n\t\t\t\t\t\tqx.pop();\n\t\t\t\t\t\tqy.pop();\n\t\t\t\t\t\tif(field[y][x] == '.')\n\t\t\t\t\t\t\tblack[y][x] = 1;\n\t\t\t\t\t\tfor(k = 0;k < 4;k++){\n\t\t\t\t\t\t\tif(x + dx[k] >= 0 && x + dx[k] < w && y + dy[k] >= 0 && y + dy[k] < h && field[y + dy[k]][x + dx[k]] == '.' && !black[y + dy[k]][x + dx[k]]){\n\t\t\t\t\t\t\t\tqx.push(x + dx[k]);\n\t\t\t\t\t\t\t\tqy.push(y + dy[k]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(field[i][j] == 'W'){\n\t\t\t\t\tqx.push(j);\n\t\t\t\t\tqy.push(i);\n\t\t\t\t\twhile(qx.size()){\n\t\t\t\t\t\tx = qx.front();\n\t\t\t\t\t\ty = qy.front();\n\t\t\t\t\t\tqx.pop();\n\t\t\t\t\t\tqy.pop();\n\t\t\t\t\t\tif(field[y][x] == '.')\n\t\t\t\t\t\t\twhite[y][x] = 1;\n\t\t\t\t\t\tfor(k = 0;k < 4;k++){\n\t\t\t\t\t\t\tif(x + dx[k] >= 0 && x + dx[k] < w && y + dy[k] >= 0 && y + dy[k] < h && field[y + dy[k]][x + dx[k]] == '.' && !white[y + dy[k]][x + dx[k]]){\n\t\t\t\t\t\t\t\tqx.push(x + dx[k]);\n\t\t\t\t\t\t\t\tqy.push(y + dy[k]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbc = wc = 0;\n\t\tfor(i = 0;i < h;i++)\n\t\t\tfor(j = 0;j < w;j++) if(white[i][j] && !black[i][j]) wc++;\n\t\tfor(i = 0;i < h;i++)\n\t\t\tfor(j = 0;j < w;j++) if(black[i][j] && !white[i][j]) bc++;\n\t\tprintf(\"%d %d\\n\",bc,wc);\n\t\tscanf(\"%d%d%*c\",&w,&h);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n\n#define W_MAX 50\n#define H_MAX 50\n\n\nusing namespace std;\n\nint map[H_MAX][W_MAX];\nint zyo[H_MAX][W_MAX];\nint w,h;\nint flag;\n\nvoid solve(int H,int W){\n\tint dx[4]={-1,1,0, 0};\n\tint dy[4]={ 0,0,1,-1};\n\t/*cout<<H<<\",\"<<W<<\",\"<<map[H][W]<<\",\"<<zyo[H][W]<<\",\"<<flag<<endl;*/\n\tfor(int a=0;a<4;a++){\n\t\t\tif(H+dx[a]<0||H+dx[a]>=h) continue;\n\t\t\tif(W+dy[a]<0||W+dy[a]>=w) continue;\n\t\t\tif(zyo[H+dx[a]][W+dy[a]]==-1&&map[H+dx[a]][W+dy[a]]==0){\n\t\t\t\tzyo[H+dx[a]][W+dy[a]]=3;\n\t\t\t\tsolve(H+dx[a],W+dy[a]);\n\t\t\t}\n\t\t\telse if(map[H+dx[a]][W+dy[a]]==1){\n\t\t\t\tif(flag==-1) flag=1;\n\t\t\t\tif(flag==2) flag=0;\n\t\t\t}\n\t\t\telse if(map[H+dx[a]][W+dy[a]]==2){\n\t\t\t\tif(flag==-1) flag=2;\n\t\t\t\tif(flag==1) flag=0;\n\t\t}\n\t}\n\treturn;\n}\n\nint main(void){\n\n\tchar tmp;\n\tint bc,wc;\n\n\twhile(1){\n\t\t\tmemset(map,-1,sizeof(map));\n\t\t\tmemset(zyo,-1,sizeof(zyo));\n\t\t\tbc=0,wc=0;\n\n\t\t\tcin>>w>>h;\n\t\t\tif(w==0&&h==0) break;\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tcin>>tmp;\n\t\t\t\t\tswitch(tmp){\n\t\t\t\t\tcase '.':\n\t\t\t\t\t\tmap[i][j]=0;\n\t\t\t\t\t\tzyo[i][j]=-1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'B':\n\t\t\t\t\t\tmap[i][j]=1;\n\t\t\t\t\t\tzyo[i][j]=0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'W':\n\t\t\t\t\t\tmap[i][j]=2;\n\t\t\t\t\t\tzyo[i][j]=0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(zyo[i][j]==-1){\n\t\t\t\t\tzyo[i][j]=3;\n\t\t\t\t\tflag=-1;\n\t\t\t\t\tsolve(i,j);\n\t\t\t\t\tfor(int k=0;k<h;k++){\n\t\t\t\t\t\tfor(int l=0;l<w;l++){\n\t\t\t\t\t\t\tif(zyo[k][l]==3) zyo[k][l]=flag;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t//cout<<zyo[i][j];\n\t\t\t\tif(zyo[i][j]==1) bc++;\n\t\t\t\telse if(zyo[i][j]==2) wc++;\n\t\t\t}\n\t\t\t//cout<<endl;\n\t\t}\n\t\tcout<<bc<<\" \"<<wc<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst double pi  = 2 * acos(0.0);\nconst double eps = 1e-8;\n\n#define REP(i,a,b) for(int i=(a); i<(b);++i)\n#define rep(i,n) REP(i,0,n)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\ntypedef int Cost;\nstruct Edge {\n  int src, dst; Cost cost;\n  Edge(int s, int d, Cost c) : src(s), dst(d), cost(c) {}\n};\ntypedef vector<Edge>  Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Cost>  Array;\ntypedef vector<Array> Matrix;\n\nint dx[8] = {0, 1, 0, -1, 1, -1, 1, -1};\nint dy[8] = {1, 0, -1, 0, 1, -1, -1, 1};\n\nstruct Status {\n  bool b, w;\n  Status() : b(false), w(false) {}\n};\n\nchar a[51][51];\nint w, h;\n\nint dfs(int y, int x, Status &s) {\n  if (a[y][x] == 'W') {\n    s.w = true;\n    return 0;\n  }\n  if (a[y][x] == 'B') {\n    s.b = true;\n    return 0;\n  }\n\n  int count = 1;\n  a[y][x] = 'D';\n  rep(i, 4) {\n    int nx = x + dx[i];\n    int ny = y + dy[i];\n\n    if (0 <= nx && nx < w && 0 <= ny && ny < h && a[ny][nx] != 'D') {\n      count += dfs(ny, nx, s);\n    }\n  }\n\n  return count;\n}\n\nint main(void) {\n  ios_base::sync_with_stdio(false); cin.tie(0);\n  while (cin >> w >> h, w || h) {\n    rep(i, h) rep(j, w) cin >> a[i][j];\n\n    int cnt_w = 0;\n    int cnt_b = 0;\n\n    rep(i, h) rep(j, w) {\n      if (a[i][j] == '.') {\n        Status s;\n        int count = dfs(i, j, s);\n        if (s.w && s.b) continue;\n        if (s.w) cnt_w += count;\n        if (s.b) cnt_b += count;\n      }\n    }\n\n    cout << cnt_b << \" \" << cnt_w << endl;\n  }\n  return 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint w, h;\nvector<string> feeld;\n\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {1, 0, -1, 1};\n\nint add, id;\nvoid rec(int x, int y) {\n\tif (feeld[y][x] == 'B') {\n\t\tid |= 1;\n\t\treturn;\n\t}\n\t\n\tif (feeld[y][x] == 'W') {\n\t\tid |= 2;\n\t\treturn;\n\t}\n\t\n\tfeeld[y][x] = '-';\n\tadd++;\n\t\n\tfor (int i = 0; i < 4; i++) {\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\tif (!(0 <= nx && nx < w && 0 <= ny && ny < h)) continue;\n\t\tif (feeld[ny][nx] == '-') continue;\n\t\trec(nx, ny);\n\t}\n}\n\nvoid solve() {\n\tint ansb = 0, answ = 0;\n\t\n\tfor (int i = 0; i < h; i++) {\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tif (feeld[i][j] == '.') {\n\t\t\t\tadd = 0; id = 0;\n\t\t\t\trec(j, i);\n\t\t\t\tif (id == 1) ansb += add;\n\t\t\t\tif (id == 2) answ += add;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << ansb << \" \" << answ << endl;\n}\n\nint main() {\n\twhile (1) {\n\t\tcin >> w >> h; if (w == 0 && h == 0) break;\n\t\tfeeld.assign(h, \"\");\n\t\tfor (int i = 0; i < h; i++) cin >> feeld[i];\n\t\t\n\t\tsolve();\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef pair <int,int> pii;\n#define FST first\n#define SEC second\n#define S 50\n\nint w,h;\nint dd[8]={0,1,0,-1,0};\n\nvoid bfs(char map[S][S]){\n  int bc=0,wc=0;\n  rep(i,h){\n    rep(j,w){\n      if(map[j][i]=='.'){\n\tqueue <pii> q;\n\tq.push(pii(j,i));\n\tint count=0;\n\tpii state=pii(0,0);\n\twhile(!q.empty()){\n\t  int cx=q.front().FST,cy=q.front().SEC;\n\t  q.pop();\n\t  if(map[cx][cy]=='.')\n\t    count++;\n\t  map[cx][cy]='#';\n\t  rep(r,4){\n\t    int nx=cx+dd[r],ny=cy+dd[r+1];\n\t    if(nx<0 || ny<0 || nx>=w || ny>=h || map[nx][ny]=='#')\n\t      continue;\n\t    if(map[nx][ny]=='B'){\n\t      state.FST=1;\n\t      continue;\n\t    }\n\t    if(map[nx][ny]=='W'){\n\t      state.SEC=1;\n\t      continue;\n\t    }\n\t    q.push(pii(nx,ny));\n\t  }\n\t}\n\tif(state==pii(1,0))\n\t  bc+=count;\n\tif(state==pii(0,1))\n\t  wc+=count;\n      } \n    }\n  }\n  cout << bc << \" \" << wc << endl;\n}\n\nint main(){\n  for(;;){\n    cin >> w >> h;\n    if(!(w+h)) break;\n    char map[S][S];\n    rep(i,h)\n      rep(j,w)\n        cin >> map[j][i];\n    bfs(map);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\n#define stlice(from, to) substr(from, (to) - (from) + 1)\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\nusing namespace std;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\nusing vd = vector<double>;\nusing vc = vector<char>;\nusing vb = vector<bool>;\nusing vs = vector<string>;\nusing vpii = vector<pii>;\nusing vvi = vector<vi>;\nusing vvb = vector<vb>;\nusing vvpii = vector<vpii>;\ntemplate<typename A> using fn = function<A>;\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = acos(-1);\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nconstexpr bool odd(const int &n) { return n & 1; }\nconstexpr bool even(const int &n) { return !odd(n); }\nvoid solve();\nmain { solve(); return 0; }\n// clang-format on\n\nvoid solve() {\n  int W, H;\n  while (cin >> W >> H, W) {\n    vs v(H);\n    rep(i, H) cin >> v[i];\n    vvi dp(H, vi(W));\n    int b = 0, w = 0;\n    rep(i, H) rep(j, W) {\n      dp[i][j] = 2 * (v[i][j] == 'B') + (v[i][j] == 'W');\n      b -= v[i][j] == 'B';\n      w -= v[i][j] == 'W';\n    }\n    rep(_, W * H) rep(i, H) rep(j, W) {\n      if (v[i][j] != '.') continue;\n      if (i > 0) dp[i][j] |= dp[i - 1][j];\n      if (j > 0) dp[i][j] |= dp[i][j - 1];\n      if (i < H - 1) dp[i][j] |= dp[i + 1][j];\n      if (j < W - 1) dp[i][j] |= dp[i][j + 1];\n    }\n    rep(i, H) rep(j, W) {\n      b += dp[i][j] == 2;\n      w += dp[i][j] == 1;\n    }\n    cout << b << ' ' << w << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\nusing namespace std;\n\nint cnt[3] = { 0 };\nint w, h;\nint mx[] = { -1,0,1,0};\nint my[] = { 0,1,0,-1};\nvector<string> area;\n\nvoid dfs(int x,int y,char color){\n\tfor (int i = 0; i < 4; i++){\n\t\tint nextx = x + mx[i];\n\t\tint nexty = y + my[i];\n\t\t//b,w,.?????????????????????????????????????????\n\t\tif (nextx >= 0 && nextx < w &&\n\t\t\tnexty >= 0 && nexty < h){\n\t\t\tif (area[nexty][nextx] != 'B' &&\n\t\t\t\tarea[nexty][nextx] != 'W' &&\n\t\t\t\tarea[nexty][nextx] != 'G'){\n\n\t\t\t\t//??????????????????????????\n\t\t\t\tif (color == 'W'){\n\t\t\t\t\tif (area[nexty][nextx] == 'w') continue;\n\t\t\t\t\tif (area[nexty][nextx] == 'b'){\n\t\t\t\t\t\tarea[nexty][nextx] = 'G';\n\t\t\t\t\t\tcnt[2]++;\n\t\t\t\t\t\tcnt[0]--;\n\t\t\t\t\t}\n\t\t\t\t\telse if (area[nexty][nextx] == '.'){\n\t\t\t\t\t\tarea[nexty][nextx] = 'w';\n\t\t\t\t\t\tcnt[1]++;\n\t\t\t\t\t}\n\t\t\t\t\tdfs(nextx, nexty, color);\n\t\t\t\t}\n\t\t\t\t//???????????\n\t\t\t\telse{\n\t\t\t\t\tif (area[nexty][nextx] == 'b') continue;\n\t\t\t\t\tif (area[nexty][nextx] == 'w'){\n\t\t\t\t\t\tarea[nexty][nextx] = 'G';\n\t\t\t\t\t\tcnt[2]++;\n\t\t\t\t\t\tcnt[1]--;\n\t\t\t\t\t}\n\t\t\t\t\telse if (area[nexty][nextx] == '.'){\n\t\t\t\t\t\tarea[nexty][nextx] = 'b';\n\t\t\t\t\t\tcnt[0]++;\n\t\t\t\t\t}\n\t\t\t\t\tdfs(nextx, nexty, color);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile (1){\n\t\tcin >> w >> h;\n\t\tif (w == 0 && h == 0) break;\n\t\t//?????????\n\t\tfor (int i = 0; i < 3; i++){\n\t\t\tcnt[i] = 0;\n\t\t}\n\t\t//??\\???\n\t\tfor (int i = 0; i < h; i++){\n\t\t\tstring input;\n\t\t\tcin >> input;\n\t\t\tarea.push_back(input);\n\t\t}\n\t\t//????????????????????????????????????????????????????\n\t\tfor (int i = 0; i < h; i++){\n\t\t\tfor (int j = 0; j < w; j++){\n\t\t\t\tif (area[i][j] == 'W'){\n\t\t\t\t\tdfs(j, i, 'W');\n\t\t\t\t}\n\t\t\t\telse if (area[i][j] == 'B'){\n\t\t\t\t\tdfs(j,i,'B');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << cnt[0] << \" \" << cnt[1] << endl;\n\t\tarea.clear();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <cmath>\n#include <algorithm>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <vector>\n#include <string>\n#define REP(i,n) for(int i=0;i<n;i++)\ntypedef long long ll;\nusing namespace std;\ntypedef vector<ll> vl;\ntypedef pair<ll,ll> pll;\ntypedef vector<pll> vpll;\ntypedef vector<string> vs;\n\nint X[4]={0,0,-1,1};\nint Y[4]={-1,1,0,0};\nint w,h;\nint ans[50][50];\nint bl[50][50];\nint wh[50][50];\n\nvoid black(int x,int y){\n\tbl[x][y]=1;\n\tfor(int i=0;i<4;i++){\n\t\tif(x+X[i]>-1&&x+X[i]<w&&y+Y[i]>-1&&y+Y[i]<h){\n\t\t\tif(ans[x+X[i]][y+Y[i]]==0&&bl[x+X[i]][y+Y[i]]==0){black(x+X[i],y+Y[i]);}\n\t\t}\n\t}\n}\n\nvoid white(int x,int y){\n\twh[x][y]=1;\n\tfor(int i=0;i<4;i++){\n\t\tif(x+X[i]>-1&&x+X[i]<w&&y+Y[i]>-1&&y+Y[i]<h){\n\t\t\tif(ans[x+X[i]][y+Y[i]]==0&&wh[x+X[i]][y+Y[i]]==0){white(x+X[i],y+Y[i]);}\n\t\t}\n\t}\n}\n\n\nint main() \n{\n\twhile(cin>>w>>h&&!(w==0&&h==0)){\n\t\tREP(i,51){REP(j,51){ans[j][i]=0;bl[j][i]=0;wh[j][i]=0;}}\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tchar tmp;\n\t\t\t\tcin>>tmp;\n\t\t\t\tswitch(tmp){\n\t\t\t\t  case 'B':ans[j][i]=1;break;\n\t\t\t\t  case 'W':ans[j][i]=2;break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tint tmp1(false),tmp2(false);\n\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\tif(j+X[k]>-1&&j+X[k]<w&&i+Y[k]>-1&&i+Y[k]<h){\n\t\t\t\t\t\tif(ans[j+X[k]][i+Y[k]]==1){tmp1=true;}\n\t\t\t\t\t\tif(ans[j+X[k]][i+Y[k]]==2){tmp2=true;}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(tmp1&&bl[j][i]!=1&&ans[j][i]==0){black(j,i);}\n\t\t\t\tif(tmp2&&wh[j][i]!=1&&ans[j][i]==0){white(j,i);}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans1(0),ans2(0);\n\t\tREP(i,h){REP(j,w){\n\t\t\t\tif(bl[j][i]+wh[j][i]==2){;}\n\t\t\t\telse if(wh[j][i]==1){ans2++;}\n\t\t\t\telse if(bl[j][i]==1){ans1++;}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout<<ans1<<\" \"<<ans2<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<pii, int> ppi;\n\n#define INF 1000000000\n#define EMP '.'\n#define W 'W'\n#define B 'B'\n#define FLG '-'\n\nchar mat[50][50];\n\nint main(){\n  int Wi,H;\n\n  while(scanf(\"%d %d\\n\", &Wi, &H), Wi|H){\n    rep(i,H){\n      rep(j,Wi){\n\tscanf(\"%c\", &mat[i][j]);\n      }\n      getchar();\n    }\n\n    int aw=0,ab=0;\n    rep(i,H){\n      rep(j,Wi){\n\tif(mat[i][j]==EMP){\n\t  bool w=false, b=false;\n\t  int cnt=0;\n\n\t  queue<pii> q;\n\t  q.push(mp(i,j));\n\t  while(!q.empty()){\n\t    pii p = q.front(); q.pop();\n\t    int x = p.first, y=p.second;\n\n\t    if(mat[x][y]==W){\n\t      w=true;\n\t      continue;\n\t    } else if(mat[x][y]==B){\n\t      b=true;\n\t      continue;\n\t    } else if(mat[x][y]==FLG){\n\t      continue;\n\t    }\n\t    cnt++;\n\t    mat[x][y]=FLG;\n\t    int dx[]={-1,1,0,0}, dy[]={0,0,-1,1};\n\t    rep(k,4){\n\t      int nx=x+dx[k], ny=y+dy[k];\n\t      if(nx>=0 && nx<H && ny>=0 && ny<Wi && mat[nx][ny]!=FLG){\n\t\tq.push(mp(nx,ny));\n\t      }\n\t    }\n\t  }\n\n\t  if((w^b)==false) continue;\n\t  else {\n\t    if(w) aw+=cnt;\n\t    else  ab+=cnt;\n\t  }\n\t} // end if EMPTY\n      } // end rep j\n    } //end rep i\n\n    cout << ab << \" \" << aw << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "/* main code starts from line 133. */\n\n/* ---------- STL Libraries ---------- */\n\n// IO library\n#include <cstdio>\n#include <iomanip>\n#include <ios>\n#include <iostream>\n\n// algorithm library\n#include <algorithm>\n#include <cmath>\n#include <numeric>\n\n#include <cctype>\n\n// container library\n#include <array>\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <vector>\n\n/* ---------- Namespace ---------- */\n\nusing namespace std;\n\n/* ---------- Type Abbreviation ---------- */\n\ntemplate <typename T>\nusing V = vector<T>;\ntemplate <typename T, typename U>\nusing P = pair<T, U>;\ntemplate <typename T>\nusing PQ = priority_queue<T>;\ntemplate <typename T>\nusing GPQ = priority_queue<T, vector<T>, greater<T>>;\n\nusing ll = long long;\n\n#define fst first\n#define snd second\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n\n/* ---------- conversion ---------- */\n\n#define INT(c) static_cast<int>(c)\n#define CHAR(n) static_cast<char>(n)\n#define LL(n) static_cast<ll>(n)\n#define DOUBLE(n) static_cast<double>(n)\n\n/* ---------- container ---------- */\n\n#define ALL(v) (v).begin(), (v).end()\n#define SIZE(v) (LL((v).size()))\n\n#define FIND(v, k) (v).find(k) != (v).end()\n#define VFIND(v, k) find(ALL(v), k) != (v).end()\n\n#define SORT(v) sort(ALL(v))\n#define GSORT(v) sort(ALL(v), greater<decltype((v).front())>())\n\n/* ---------- repetition ---------- */\n\n#define FOR(i, a, b) for (ll i = (a); i < (b); i++)\n#define REP(i, n) FOR(i, 0, n)\n#define NREP(i, n) FOR(i, 1, n + 1)\n\n#define RFOR(i, a, b) for (ll i = (a); i >= (b); i--)\n#define RREP(i, n) RFOR(i, n - 1, 0)\n#define RNREP(i, n) RFOR(i, n, 1)\n\n// Usual REP runs from 0 to n-1 (R: n-1 to 0)\n// Natural REP runs from 1 to n (R: n to 1)\n\n/* ---------- Short Functions ---------- */\n\ntemplate <typename T>\nT sq(T a) {\n    return a * a;\n}\n\n#define fcout cout << fixed << setprecision(10)\n\n/* ----------- debug ---------- */\n\ntemplate <typename T, typename U>\nvoid testP2(T a, U b) {\n    cout << \"(\" << a << \", \" << b << \")\" << endl;\n    return;\n}\n\ntemplate <typename T>\nvoid testV(T v) {\n    cout << \"[\";\n    for (auto i : v) {\n        cout << i << \", \";\n    }\n    cout << \"\\b\\b]\" << endl;\n    return;\n}\n\ntemplate <typename T>\nvoid testV2(T v) {\n    for (auto sv : v) {\n        testV(sv);\n    }\n    cout << endl;\n    return;\n}\n\n#define GET_VAR_NAME(variable) #variable\n#define test(x) cout << GET_VAR_NAME(x) << \" = \" << x << endl;\n#define testP(p)                      \\\n    cout << GET_VAR_NAME(p) << \" = \"; \\\n    testP2(p.fst, p.snd);\n\n/* ---------- Constants ---------- */\n\n// const ll MOD = 1e9 + 7;\n// const int INF = 1 << 25;\n// const ll INF = 1LL << 50;\n// const double PI = acos(-1);\n// const double EPS = 1e-10;\nconst ll dx[4] = {0, -1, 1, 0};\nconst ll dy[4] = {-1, 0, 0, 1};\n// const ll dx[8] = {-1, 0, 1, -1, 1, -1, 0, 1};\n// const ll dy[8] = {-1, -1, -1, 0, 0, 1, 1, 1};\n\n/* v-v-v-v-v-v-v-v-v Main Part v-v-v-v-v-v-v-v-v */\n\n/* ---------- Type Definition ----------- */\n\n\n/* ---------- Global Variance ----------- */\n\n\n/* ------------- Functions -------------- */\n\n\n/* ----------- Main Function ------------ */\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while (true) {\n        ll w, h;\n        cin >> w >> h;\n        if (w == 0) break;\n\n        V<string> field(h);\n        REP(i, h) {\n            cin >> field[i];\n        }\n\n        while (true) {\n            bool update = false;\n\n            REP(x, h) {\n                REP(y, w) {\n                    if (isupper(field[x][y])) continue;\n\n                    char p = tolower(field[x][y]);\n\n                    REP(i, 4) {\n                        ll sx = x + dx[i];\n                        ll sy = y + dy[i];\n\n                        if (sx < 0 || sx >= h || sy < 0 || sy >= w) continue;\n\n                        if (field[sx][sy] == '.') continue;\n\n                        if (field[sx][sy] == 'N') {\n                            p = 'N';\n                            break;\n                        }\n\n                        if (p == '.') {\n                            p = tolower(field[sx][sy]);\n                            continue;\n                        }\n\n                        if (p != tolower(field[sx][sy])) {\n                            p = 'N';\n                            break;\n                        }\n                    }\n\n                    if (field[x][y] != p) {\n                        field[x][y] = p;\n                        update = true;\n                    }\n                }\n            }\n\n            if (!update) break;\n        }\n\n        V<ll> ans(2, 0);\n\n        REP(x, h) {\n            REP(y, w) {\n                if (field[x][y] == 'b') {\n                    ans[0]++;\n                } else if (field[x][y] == 'w') {\n                    ans[1]++;\n                }\n            }\n        }\n\n        cout << ans[0] << \" \" << ans[1] << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "Haskell",
    "code": "import Data.Set (Set, (\\\\), intersection, elems, null, size, fromList)\nimport qualified Data.Set as S\n\nmain :: IO ()\nmain = interact $ unlines . map (show' . uncurry surrounding_area) . read' . lines\n where\n  read' (\"0 0\":_) = []\n  read' (wh:xs) = ((w,h),(black,white)) : read' xs'\n   where\n    [w,h] = map read (words wh)\n    (m,xs') = splitAt h xs\n    black = fromList [(x,y) | x<-[1..w], y<-[1..h], m!!(y-1)!!(x-1)=='B']\n    white = fromList [(x,y) | x<-[1..w], y<-[1..h], m!!(y-1)!!(x-1)=='W']\n  show' (b,w) = show b ++ \" \" ++ show w\n\ntype Grid = Set (Int,Int)\n\nwasteland :: Int -> Int -> Grid\nwasteland x y = fromList [(w,h) | w<-[1..x], h<-[1..y]]\n\nsurrounding_area :: (Int,Int) -> (Grid,Grid) -> (Int,Int)\nsurrounding_area (w,h) (black,white) = (nb,nw)\n where\n  nb = if S.null black then 0 else untouched (wasteland w h \\\\ black) white\n  nw = if S.null white then 0 else untouched (wasteland w h \\\\ white) black\n\nuntouched :: Grid -> Grid -> Int\nuntouched gw gp = size $ gw \\\\ (untilFix (survey gw) gp)\n\nsurvey :: Grid -> Grid -> Grid\nsurvey gw = intersection gw . expand\n\nexpand :: Grid -> Grid\nexpand = fromList . concatMap neighbor . elems\n\nneighbor :: (Int,Int) -> [(Int,Int)]\nneighbor (x,y) = [(x,y),(x-1,y),(x+1,y),(x,y-1),(x,y+1)]\n\nuntilFix :: Eq a => (a -> a) -> a -> a\nuntilFix f x = if f x == x then x else untilFix f (f x)"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nchar map[50][50]; //map[h][w]\nint w,h;\n\nvoid scanmap(){\n\tint i;\n\tfor(i=0;i<h;i++){\n\t\tscanf(\"%s\",map[i]);\n\t}\n}\n\nvoid wpaint(int a,int b){\n\tif(a>0 && map[a-1][b] == '.'){\n\t\tmap[a-1][b] = 'w';\n\t\twpaint(a-1,b);\n\t}\n\tif(b>0 && map[a][b-1] == '.'){\n\t\tmap[a][b-1] = 'w';\n\t\twpaint(a,b-1);\n\t}\n\tif(a<h && map[a+1][b] == '.'){\n\t\tmap[a+1][b] = 'w';\n\t\twpaint(a+1,b);\n\t}\n\tif(b<w && map[a][b+1] == '.'){\n\t\tmap[a][b+1] = 'w';\n\t\twpaint(a,b+1);\n\t}\n}\n\nvoid bpaint(int a,int b){\n\tif(a>0){\n\t\tif(map[a-1][b] == '.'){\n\t\t\tmap[a-1][b] = 'b';\n\t\t\tbpaint(a-1,b);\n\t\t}else if(map[a-1][b] == 'w'){\n\t\t\tmap[a-1][b] = 'g';\n\t\t\tbpaint(a-1,b);\n\t\t}\n\t}\n\tif(b>0){\n\t\tif(map[a][b-1] == '.'){\n\t\t\tmap[a][b-1] = 'b';\n\t\t\tbpaint(a,b-1);\n\t\t}else if(map[a][b-1] == 'w'){\n\t\t\tmap[a][b-1] = 'g';\n\t\t\tbpaint(a,b-1);\n\t\t}\n\t}\n\tif(a<h){\n\t\tif(map[a+1][b] == '.'){\n\t\t\tmap[a+1][b] = 'b';\n\t\t\tbpaint(a+1,b);\n\t\t}else if(map[a+1][b] == 'w'){\n\t\t\tmap[a+1][b] = 'g';\n\t\t\tbpaint(a+1,b);\n\t\t}\n\t}\n\tif(b<w){\n\t\tif(map[a][b+1] == '.'){\n\t\t\tmap[a][b+1] = 'b';\n\t\t\tbpaint(a,b+1);\n\t\t}else if(map[a][b+1] == 'w'){\n\t\t\tmap[a][b+1] = 'g';\n\t\t\tbpaint(a,b+1);\n\t\t}\n\t}\n}\n\nint bcount(){\n\tint i,j;\n\tint count = 0;\n\tfor(i=0;i<h;i++){\n\t\tfor(j=0;j<w;j++){\n\t\t\tif(map[i][j] == 'b') count++;\n\t\t}\n\t}\n\treturn count;\n}\n\nint wcount(){\n\tint i,j;\n\tint count = 0;\n\tfor(i=0;i<h;i++){\n\t\tfor(j=0;j<w;j++){\n\t\t\tif(map[i][j] == 'w') count++;\n\t\t}\n\t}\n\treturn count;\n}\n\nvoid printmap(){\n\tint i;\n\tfor(i=0;i<h;i++){\n\t\tprintf(\"%s\\n\",map[i]);\n\t}\n}\n\nvoid area(){\n\tscanmap();\n\tint i,j;\n\tfor(i=0;i<h;i++){\n\t\tfor(j=0;j<w;j++){\n\t\t\tif(map[i][j] == 'W') wpaint(i,j);\n\t\t}\n\t}\n\tfor(i=0;i<h;i++){\n\t\tfor(j=0;j<w;j++){\n\t\t\tif(map[i][j] == 'B') bpaint(i,j);\n\t\t}\n\t}\n\tprintf(\"%d %d\\n\",bcount(),wcount());\n//\tprintmap();\n}\n\nint main(){\n\twhile(1){\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w == 0 && h == 0) break;\n\t\tarea();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint main(){\n\t\n\tint i,j,p,c;\n\tint w,h;\n\tint wf,bf;\n\tint pw,ph;\n\t\n\twhile(1){\n\t\tscanf(\"%d%d\",&w,&h);\n\t\tif(w==0&&h==0) break;\n\t\tc = 1;\n\t\twf = 0;\n\t\tbf = 0;\n\t\tint a[52][52]={};\n\t\tfor(i=0;i<(w+2)*(h+2);i++){\n\t\t\ta[i/(w+2)][i%(w+2)] = 1;\n\t\t}\n\t\tchar in[w];\n\t\tfor(i=0;i<h;i++){\n\t\t\tscanf(\"%s\",in);\n\t\t\tfor(j=0;j<w;j++){\n\t\t\t\tif(in[j]=='W'){\n\t\t\t\t\ta[i+1][j+1] = 4;\n\t\t\t\t\twf++;\n\t\t\t\t}else if(in[j]=='B'){\n\t\t\t\t\ta[i+1][j+1] = 9;\n\t\t\t\t\tbf++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(c!=0){\n\t\t\tc = 0;\n\t\t\tfor(p=0;p<w*h;p++){\n\t\t\t\tpw = p%w+1;\n\t\t\t\tph = p/w+1;\n\t\t\t\tif(a[ph][pw]==0||a[ph][pw]==4||a[ph][pw]==9){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint x = a[ph-1][pw]*a[ph+1][pw]*a[ph][pw-1]*a[ph][pw+1];\n\t\t\t\tif(x==0){\n\t\t\t\t\ta[ph][pw] = 0;\n\t\t\t\t\tc++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint f1 = x%2;\n\t\t\t\tint f2 = x%3;\n\t\t\t\tif(a[ph][pw]==1){\n\t\t\t\t\tif(f1==0&&f2==0){\n\t\t\t\t\t\ta[ph][pw] = 0;\n\t\t\t\t\t\tc++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}else if(f1!=0&&f2!=0){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}else if(f1==0){\n\t\t\t\t\t\ta[ph][pw] = 2;\n\t\t\t\t\t\tc++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}else{\n\t\t\t\t\t\ta[ph][pw] = 3;\n\t\t\t\t\t\tc++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(a[ph][pw]==2){\n\t\t\t\t\tif(f2==0){\n\t\t\t\t\t\ta[ph][pw] = 0;\n\t\t\t\t\t\tc++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(a[ph][pw]==3){\n\t\t\t\t\tif(f1==0){\n\t\t\t\t\t\ta[ph][pw] = 0;\n\t\t\t\t\t\tc++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint wc=0,bc=0;\n\t\tfor(i=0;i<w*h;i++){\n\t\t\tif(a[i/w+1][i%w+1]==2){\n\t\t\t\twc++;\n\t\t\t}\n\t\t\tif(a[i/w+1][i%w+1]==3){\n\t\t\t\tbc++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\",bc,wc);\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint w,h;\nint b_sum,w_sum;\nchar map[52][52];\n\nint dx[4] = {1,-1,0,0};\nint dy[4] = {0,0,1,-1};\n\nvoid calc_area(int *b_sum,int *w_sum){\n\tint x,y;\n\n  *b_sum = *w_sum = 0;\n\n  for(y=0;y<h;y++){\n    for(x=0;x<w;x++){\n      if(map[y][x] == '.' + 1){\n        (*b_sum)++;\n      }\n      else if(map[y][x] == '.' - 1){\n        (*w_sum)++;\n      }\n    }\n  }\n}\n\nvoid check_land(int x,int y,char color){\n\tint i;\n\n\tfor(i=0;i<4;i++){\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\n\t\tif(nx>=0 && ny>=0 && nx<w && ny<h && (map[ny][nx]=='.' || map[ny][nx]=='.'+1)){\n\t\t\tif(color == 'B'){\n\t\t\t\tif(map[ny][nx] == '.'){\n\t\t\t\t\tmap[ny][nx]++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(map[ny][nx] == '.'){\n\t\t\t\t\tmap[ny][nx]--;\n\t\t\t\t}\n\t\t\t\telse if(map[ny][nx] == '.' + 1){\n\t\t\t\t\tmap[ny][nx]++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcheck_land(nx,ny,color);\n\t\t}\n\t}\n}\n\nvoid get_land(char color){\n\tint x,y;\n\n\tfor(y=0;y<h;y++){\n\t\tfor(x=0;x<w;x++){\n\t\t\tif(map[y][x] == color){\n\t\t\t\tcheck_land(x,y,color);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint input_map(void){\n\tint y;\n\n\tscanf(\"%d%d\",&w,&h);\n\tif(w==0 && h==0){\n\t\treturn 0;\n\t}\n\n\tfor(y=0;y<h;y++){\n\t\tscanf(\"%s\",map[y]);\n\t}\n\treturn 1;\n}\n\nint main(void){\n\tint b_sum,w_sum;\n\n\twhile(1){\n\t\tif(input_map() == 0){\n\t\t\tbreak;\n\t\t}\n\n\t\tget_land('B');\n\t\tget_land('W');\n\n\t\tcalc_area(&b_sum,&w_sum);\n\n\t\tprintf(\"%d %d\\n\",b_sum,w_sum);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define rep(i,n) for(int i=0;(i)<(n);(i)++)\nint w,h;\nint black[51][51];\nint white[51][51];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nchar map[51][51];\nvoid solve(int y,int x,char c){\n    if((c == 'B' && black[y][x]) || (c == 'W' && white[y][x])) return;\n    if(c == 'W' && map[y][x]!='W') white[y][x] = 1;\n    else if(c == 'B' && map[y][x]!='B') black[y][x] = 1;\n    \n    rep(i, 4){\n        int nx = x + dx[i]; int ny = y + dy[i];\n        if(0 <= nx && nx < w && 0 <= ny && ny < h && map[ny][nx] == '.'){\n            solve(ny, nx, c);\n        }\n    }\n}\nint main(void){\n    while(1){\n        scanf(\"%d%d\",&w,&h);\n        if(w+h==0) break;\n        getchar();\n        rep(i,h) scanf(\"%s\",map[i]);\n        rep(i,h){\n            rep(j,w){\n                black[i][j]=white[i][j]=0;\n            }\n        }\n        rep(i,h){\n            rep(j,w){\n                if(map[i][j]=='W'){\n                    solve(i,j,'W');\n                }else if(map[i][j]=='B'){\n                    solve(i,j,'B');\n                }\n            }\n        }\n        int bl=0,wh=0;\n        rep(i,h){\n            rep(j,w){\n                if(black[i][j] && !white[i][j]) bl++;\n                else if(!black[i][j] && white[i][j]) wh++;\n            }\n        }\n        printf(\"%d %d\\n\",bl,wh);\n    }\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define ll long long\n#define rep(i,l,r)for(ll i=(l);i<(r);i++)\n\nll w,h;\nchar s[99][99];\nll d4[]={0,-1,0,1,0};\nvoid f(char c,int a[][99]){\n\tint que[10000],quecnt=0;\n\trep(i,0,h)rep(j,0,w){\n\t\tif(s[i][j]==c){\n\t\t\ta[i][j]=10;\n\t\t\tque[quecnt++]=i*128+j;\n\t\t}else{\n\t\t\ta[i][j]=0;\n\t\t}\n\t}\n\tfor(int idx=0;idx<quecnt;idx++){\n\t\tint x=que[idx]/128;\n\t\tint y=que[idx]%128;\n\t\trep(k,0,4){\n\t\t\tint xx=x+d4[k];\n\t\t\tint yy=y+d4[k+1];\n\t\t\tif(0<=xx&&xx<h&&0<=yy&&yy<w&&!a[xx][yy]){\n\t\t\t\tif(s[xx][yy]=='.'){\n\t\t\t\t\tque[quecnt++]=xx*128+yy;\n\t\t\t\t\ta[xx][yy]=2;\n\t\t\t\t}else{\n\t\t\t\t\ta[xx][yy]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint a[99][99];\nint b[99][99];\n\nint main(){\n\twhile(scanf(\"%lld%lld\",&w,&h),w){\n\t\trep(i,0,h)scanf(\" %s\",s[i]);\n\t\tf('B',a);\n\t\tf('W',b);\n\t\tll x=0,y=0;\n\t\trep(i,0,h)rep(j,0,w){\n\t\t\tif(a[i][j]==2&&b[i][j]!=2)x++;\n\t\t\tif(a[i][j]!=2&&b[i][j]==2)y++;\n\t\t}\n\t\tprintf(\"%lld %lld\\n\",x,y);\n\t}\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nchar map[50][50]; //map[h][w]\nint w,h;\n\nvoid scanmap(){\n\tint i;\n\tfor(i=0;i<h;i++){\n\t\tscanf(\"%s\",map[i]);\n\t}\n}\n\nvoid wpaint(int a,int b){\n\tif(a>0 && map[a-1][b] == '.'){\n\t\tmap[a-1][b] = 'w';\n\t\twpaint(a-1,b);\n\t}\n\tif(b>0 && map[a][b-1] == '.'){\n\t\tmap[a][b-1] = 'w';\n\t\twpaint(a,b-1);\n\t}\n\tif(a<h-1 && map[a+1][b] == '.'){\n\t\tmap[a+1][b] = 'w';\n\t\twpaint(a+1,b);\n\t}\n\tif(b<w-1 && map[a][b+1] == '.'){\n\t\tmap[a][b+1] = 'w';\n\t\twpaint(a,b+1);\n\t}\n}\n\nvoid bpaint(int a,int b){\n\tif(a>0){\n\t\tif(map[a-1][b] == '.'){\n\t\t\tmap[a-1][b] = 'b';\n\t\t\tbpaint(a-1,b);\n\t\t}else if(map[a-1][b] == 'w'){\n\t\t\tmap[a-1][b] = 'g';\n\t\t\tbpaint(a-1,b);\n\t\t}\n\t}\n\tif(b>0){\n\t\tif(map[a][b-1] == '.'){\n\t\t\tmap[a][b-1] = 'b';\n\t\t\tbpaint(a,b-1);\n\t\t}else if(map[a][b-1] == 'w'){\n\t\t\tmap[a][b-1] = 'g';\n\t\t\tbpaint(a,b-1);\n\t\t}\n\t}\n\tif(a<h-1){\n\t\tif(map[a+1][b] == '.'){\n\t\t\tmap[a+1][b] = 'b';\n\t\t\tbpaint(a+1,b);\n\t\t}else if(map[a+1][b] == 'w'){\n\t\t\tmap[a+1][b] = 'g';\n\t\t\tbpaint(a+1,b);\n\t\t}\n\t}\n\tif(b<w-1){\n\t\tif(map[a][b+1] == '.'){\n\t\t\tmap[a][b+1] = 'b';\n\t\t\tbpaint(a,b+1);\n\t\t}else if(map[a][b+1] == 'w'){\n\t\t\tmap[a][b+1] = 'g';\n\t\t\tbpaint(a,b+1);\n\t\t}\n\t}\n}\n\nint bcount(){\n\tint i,j;\n\tint count = 0;\n\tfor(i=0;i<h;i++){\n\t\tfor(j=0;j<w;j++){\n\t\t\tif(map[i][j] == 'b') count++;\n\t\t}\n\t}\n\treturn count;\n}\n\nint wcount(){\n\tint i,j;\n\tint count = 0;\n\tfor(i=0;i<h;i++){\n\t\tfor(j=0;j<w;j++){\n\t\t\tif(map[i][j] == 'w') count++;\n\t\t}\n\t}\n\treturn count;\n}\n\nvoid printmap(){\n\tint i;\n\tfor(i=0;i<h;i++){\n\t\tprintf(\"%s\\n\",map[i]);\n\t}\n}\n\nvoid area(){\n\tscanmap();\n\tint i,j;\n\tfor(i=0;i<h;i++){\n\t\tfor(j=0;j<w;j++){\n\t\t\tif(map[i][j] == 'W') wpaint(i,j);\n\t\t}\n\t}\n\tfor(i=0;i<h;i++){\n\t\tfor(j=0;j<w;j++){\n\t\t\tif(map[i][j] == 'B') bpaint(i,j);\n\t\t}\n\t}\n\tprintf(\"%d %d\\n\",bcount(),wcount());\n//\tprintmap();\n}\n\nint main(){\n\twhile(1){\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w == 0 && h == 0) break;\n\t\tarea();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "/* \n   AOJ 2014\n   Surrounding Area\n   2015/9/18\n*/\n\n#include<stdio.h>\n#define W_MAX 51\n#define H_MAX 51\n#define DIR_N 4\n\nint w, h, white_area = 0, black_area = 0, count, flag;\nchar area[H_MAX][W_MAX];\nint dir[DIR_N][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n/* dir := down->right->up->left */\n\nint is_area(int x, int y)\n{\n  return (0 <= x && x < w && 0 <= y && y < h && area[y][x] != 'V');\n}\n\nvoid dfs(int x, int y)\n{\n  int i, j, dir_x, dir_y;\n  count++;\n  area[y][x] = 'V';\n\n  for(i = 0; i < DIR_N; i++)\n    {\n      dir_x = x + dir[i][0];\n      dir_y = y + dir[i][1];\n      if(is_area(dir_x, dir_y))\n\t{\n\t  if(area[dir_y][dir_x] == 'W')\n\t    {\n\t      if(flag == 0)\n\t\t{\n\t\t  flag = 1;\n\t\t}\n\t      if(flag == 2)\n\t\t{\n\t\t  flag = 3;\n\t\t}\n\t      continue;\n\t    }\n\t  if(area[dir_y][dir_x] == 'B')\n\t    {\n\t      if(flag == 0)\n\t\t{\n\t\t  flag = 2;\n\t\t}\n\t      if(flag == 1)\n\t\t{\n\t\t  flag = 3;\n\t\t}\n\t      continue;\n\t    }\n\t  dfs(dir_x, dir_y);\n\t}\n    }\n}\n\nvoid ans_f(int x, int y)\n{\n  count = 0;\n  flag = 0;\n  dfs(x, y);\n  if(flag == 1)\n    {\n      white_area += count;\n    }\n  if(flag == 2)\n    {\n      black_area += count;\n    }\n}\n\nint main(void)\n{\n  int i, j;\n\n  while(1)\n    {\n      white_area = 0;\n      black_area = 0;\n      count = 0;\n      scanf(\"%d %d\", &w, &h);\n      if(w == 0 && h == 0)\n\t{\n\t  break;\n\t}\n      for(i = 0; i < h; i++)\n\t{\n\t  scanf(\"%s\", area[i]);\n\t}\n      for(i = 0; i < h; i++)\n\t{\n\t  for(j = 0; j < w; j++)\n\t    {\n\t      if(area[i][j] == '.')\n\t\t{\n\t\t  ans_f(j, i);\n\t\t}\n\t    }\n\t}\n      printf(\"%d %d\\n\",black_area, white_area);\n    }\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int X[]={0,1,0,-1};\n  int Y[]={1,0,-1,0};\t   \n  int w,h,i,j,ny,nx,k,l,x[3000],y[3000],t,r;\n  while(scanf(\"%d %d\",&w,&h),w||h){\n    char s[55][55]={0};\n    int c[4]={0};\n    int e[55][55]={0};\n    for(i=0;i<h;i++)scanf(\"%s\",s[i+1]+1);\n    for(i=1;i<=h;i++){\n      for(j=1;j<=w;j++){\n\tif(s[i][j]=='.')continue;\n\tif(s[i][j]=='W')k=2;\n\telse            k=1;\n\ty[0  ]=i;\n\tx[t=0]=j;\n\tfor(r=1;r-t;t++){//printf(\"%d\\n\",r);\n\t  for(l=0;l<4;l++){\n\t    ny=y[t]+Y[l];\n\t    nx=x[t]+X[l];\n\t    if(s[ny][nx]-'.'||e[ny][nx]==k||e[ny][nx]==3)continue;\n\t    e[y[r]=ny][x[r]=nx]+=k;\n\t    r++;\n\t  }\n\t}\n      }\n    }\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++)c[e[i+1][j+1]]++;//,printf(\"%d\",e[i+1][j+1]);printf(\"\\n\");\n    }\n    printf(\"%d %d\\n\",c[1],c[2]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2014: Surrounding Area\n// 2017.10.1\n\n#include <stdio.h>\n#include <string.h>\n\ntypedef struct { int r, c; } Q;\nQ q[2700]; int top;\n\nchar map[52][52]; int w, h;\nchar visited[50][52];\n\nint mv[4][2] = { {-1,0},{0,1},{1,0},{0,-1} };\n\nvoid calc(int *sb, int *sw)\n{\n\tint i, f, r, c, r1, c1, r2, c2, sum;\n\n\t*sb = *sw = 0;\n\tmemset(visited, 0, sizeof(visited));\n\tfor (r = 0; r < h; r++) for (c = 0; c < w; c++) {\n\t\tif (map[r][c] != '.' || visited[r][c]) continue;\n\n\t\tf = 0, sum = 1, visited[r][c] = 1;\n\t\tq[0].r = r, q[0].c = c, top = 1;\n\t\twhile (top > 0) {\n\t\t\tr1 = q[--top].r, c1 = q[top].c;\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tr2 = r1 + mv[i][0], c2 = c1 + mv[i][1];\n\t\t\t\tif (r2 < 0 || r2 >= h || c2 < 0 || c2 >= w || visited[r2][c2]) continue;\n\t\t\t\tif      (map[r2][c2] == 'B') f |= 1;\n\t\t\t\telse if (map[r2][c2] == 'W') f |= 2;\n\t\t\t\telse {\n\t\t\t\t\tvisited[r2][c2] = 1; sum++;\n\t\t\t\t\tq[top].r = r2, q[top++].c = c2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif      (f == 1) *sb += sum;\n\t\telse if (f == 2) *sw += sum;\n\t}\n}\n\nint main()\n{\n\tint r, c, sb, sw;\n\n\twhile (scanf(\"%d%d\", &w, &h) && w > 0) {\n\t\tfor (sb = sw = 0, r = 0; r < h; r++) {\n\t\t\tscanf(\"%s\", map[r]);\n\t\t\tfor (c = 0; c < w; c++) {\n\t\t\t\tif (map[r][c] == 'B') sb++;\n\t\t\t\telse if (map[r][c] == 'W') sw++;\n\t\t\t}\n\t\t}\n\t\tif (!sb && !sw) puts(\"0 0\");\n\t\telse if (!sb) printf(\"0 %d\\n\", w*h - sw);\n\t\telse if (!sw) printf(\"%d 0\\n\", w*h - sb);\n\t\telse { calc(&sb, &sw); printf(\"%d %d\\n\", sb, sw); }\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A2014\nMaximum Sum Sequence\n*/\n#include <stdio.h>\n#include <string.h>\n\nint W,H;\nchar a[50][51];\nchar b[50][51];\n\nvoid printa()\n{\n  int i;\n  for(i=0;i<H;i++)\n    {\n      printf(\"%s\\n\",&(a[i]));\n    }\n}\nvoid printb()\n{\n  int i;\n  for(i=0;i<H;i++)\n    {\n      printf(\"%s\\n\",(char *)&(b[i]));\n    }\n}\nvoid fill_black2(int y,int x)\n{\n  //printf(\"%d %d\\n\",x,y);\n  if((x < 0)||(x > W-1)||(y < 0)||(y > H-1))\n    return;\n  if(a[y][x]=='.')\n    {\n      a[y][x] = 'b';\n      fill_black2(y-1,x);\n      fill_black2(y+1,x);\n      fill_black2(y,x-1);\n      fill_black2(y,x+1);\n    }\n}\nvoid fill_black()\n{\n  int i,j;\n  for(i=0;i<H;i++)\n     for(j=0;j<W;j++)\n       if(a[i][j]=='B')\n\t {\n\t   fill_black2(i-1,j);\n\t   fill_black2(i+1,j);\n\t   fill_black2(i,j-1);\n\t   fill_black2(i,j+1);\n\t }\n}\nvoid fill_white2(int y,int x)\n{\n  //printf(\"%d %d\\n\",x,y);\n  if((x < 0)||(x > W-1)||(y < 0)||(y > H-1))\n    return;\n  if(b[y][x]=='.')\n    {\n      b[y][x] = 'w';\n      fill_white2(y-1,x);\n      fill_white2(y+1,x);\n      fill_white2(y,x-1);\n      fill_white2(y,x+1);\n    }\n}\nvoid fill_white()\n{\n  int i,j;\n  for(i=0;i<H;i++)\n     for(j=0;j<W;j++)\n       if(b[i][j]=='W')\n\t {\n\t   fill_white2(i-1,j);\n\t   fill_white2(i+1,j);\n\t   fill_white2(i,j-1);\n\t   fill_white2(i,j+1);\n\t }\n}\nvoid mokusan()\n{\n  int i,j;\n  int wc,bc;\n\n  bc=wc=0;\n  for(i=0;i<H;i++)\n     for(j=0;j<W;j++)\n       {\n\t if(a[i][j]=='b' && b[i][j]== '.')\n\t   bc ++;\n\t if(a[i][j]=='.' && b[i][j]== 'w')\n\t   wc ++;\n       }\n  printf(\"%d %d\\n\",bc,wc);\n}\nmain()\n{\n  int i,j;\n\n  while(EOF!=scanf(\"%d %d\",&W,&H) && (W || H))\n    {\n     for(i=0;i<H;i++)\n\t{\n\t  scanf(\"%s\",(char *)&(a[i]));\n\t  strcpy((char *)&(b[i]),(char *)&(a[i]));\n\t}\n     fill_black();\n     //printa();\n     fill_white();\n     //printb();\n     mokusan();\n     //break;\n    }\nreturn(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nchar map[60][60], v[60][60], visited[60][60];\nint H, W;\nint dr[]={-1, 0, 1, 0}, dc[]={0, -1, 0, 1};\n\nint dfs(int r, int c, int k)\n{\n    int i;\n    char *t=&v[r][c];\n    *t|=k;\n    for(i=0;i<4;++i) {\n        int nr=r+dr[i];\n        int nc=c+dc[i];\n        if (nr<0 || nr>=H || nc<0 || nc>=W)\n            *t|=4;\n        else if (map[nr][nc]=='B')\n            *t|=1;\n        else if (map[nr][nc]=='W')\n            *t|=2;\n    }\n    for(i=0;i<4;++i) {\n        int nr=r+dr[i];\n        int nc=c+dc[i];\n        if (nr<0 || nr>=H || nc<0 || nc>=W || map[nr][nc]!='.' || (*t&v[nr][nc])==*t)\n            continue;\n        dfs(nr, nc, *t);\n    }\n}\n\nint main(void)\n{\n    while (scanf(\"%d%d\", &W, &H), W) {\n        int r, c, b, w;\n        memset(map, 0, sizeof(map));\n        memset(v, 0, sizeof(v));\n        b=w=0;\n        for(r=0;r<H;++r) scanf(\"%s\", map[r]);\n\n        for(r=0;r<H;++r) for(c=0;c<W;++c) {\n            if (!v[r][c] && map[r][c]=='.') dfs(r, c, 0);\n        }\n        for(r=0;r<H;++r) for(c=0;c<W;++c) {\n            b+=(v[r][c]==1 || v[r][c]==5);\n            w+=(v[r][c]==2 || v[r][c]==6);\n        }\n        printf(\"%d %d\\n\", b, w);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define MAX_WH 50\n#define BLACK 1\n#define WHITE 2\n\nchar map[MAX_WH][MAX_WH + 1];\nchar flag[MAX_WH][MAX_WH + 1];\n\nint w, h;\n\nvoid printFlag() {\n  int i, j;\n  for (i = 0; i < w; i++) {\n    for (j = 0; j < h; j++) printf(\"%d\", flag[j][i]);\n    puts(\"\");\n  }\n  puts(\"****************\");\n}\n\nint count(int n) {\n  int i, j, cnt = 0;\n  for (i = 0; i < w; i++) {\n    for (j = 0; j < h; j++) {\n      if (flag[j][i] == n) cnt++;\n    }\n  }\n  return cnt;\n}\n\nvoid reset_flag() {\n  int i, j;\n  for (i = 0; i < w; i++) {\n    for (j = 0; j < h; j++) {\n      flag[j][i] = 0;\n    }\n  }\n}\n\nint rinsetsu(int mask, int x, int y) {\n  char c = mask == BLACK ? 'B' : 'W';\n  if (0 <= x + 1 && x + 1 < w && map[y][x + 1] == c) return 1;\n  if (0 <= x - 1 && x - 1 < w && map[y][x - 1] == c) return 1;\n  if (0 <= y + 1 && y + 1 < h && map[y + 1][x] == c) return 1;\n  if (0 <= y - 1 && y - 1 < h && map[y - 1][x] == c) return 1;\n  return 0;\n}\n\nint kakudai_rinsetsu(int mask, int x, int y) {\n  if (0 <= x + 1 && x + 1 < w && flag[y][x + 1] & mask) return 1;\n  if (0 <= x - 1 && x - 1 < w && flag[y][x - 1] & mask) return 1;\n  if (0 <= y + 1 && y + 1 < h && flag[y + 1][x] & mask) return 1;\n  if (0 <= y - 1 && y - 1 < h && flag[y - 1][x] & mask) return 1;\n  return 0;\n}\n\nvoid fill(int mask, int x, int y) {\n  if (0 <= x && x < w && 0 <= y && y < h) {\n    int c = map[y][x];\n    if (c == 'B' || c == 'W') return;\n    if (flag[y][x] & mask) return;\n    \n    if (rinsetsu(mask, x, y) || kakudai_rinsetsu(mask, x, y)) {\n      flag[y][x] |= mask;\n      fill(mask, x + 1, y);\n      fill(mask, x, y + 1);\n      fill(mask, x - 1, y);\n      fill(mask, x, y - 1);\n    }\n  }\n}\n\nvoid solve() {\n  int i, j;\n  \n  for (i = 0; i < w; i++) {\n    for (j = 0; j < h; j++) {\n      if (map[j][i] == 'B' || map[j][i] == 'W') {\n        int mask = map[j][i] == 'B' ? BLACK : WHITE;\n        fill(mask, i + 1, j);\n        fill(mask, i, j + 1);\n        fill(mask, i - 1, j);\n        fill(mask, i, j - 1);\n      }\n    }\n  }\n  \n  printf(\"%d %d\\n\", count(BLACK), count(WHITE));\n}\n\nint main() {\n  int i;\n  while (1) {\n    scanf(\"%d %d\\n\", &w, &h);\n    if (!(w | h)) break;\n    \n    for (i = 0; i < h; i++) {\n      scanf(\"%s\\n\", map[i]);\n    }\n    reset_flag();\n    \n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nchar map[52][52]; //map[h][w]\nint w,h;\n\nvoid scanmap(){\n\tint i;\n\tfor(i=0;i<h;i++){\n\t\tscanf(\"%s\",map[i]);\n\t}\n}\n\nvoid wpaint(int a,int b){\n\tif(a>0 && map[a-1][b] == '.'){\n\t\tmap[a-1][b] = 'w';\n\t\twpaint(a-1,b);\n\t}\n\tif(b>0 && map[a][b-1] == '.'){\n\t\tmap[a][b-1] = 'w';\n\t\twpaint(a,b-1);\n\t}\n\tif(a<h-1 && map[a+1][b] == '.'){\n\t\tmap[a+1][b] = 'w';\n\t\twpaint(a+1,b);\n\t}\n\tif(b<w-1 && map[a][b+1] == '.'){\n\t\tmap[a][b+1] = 'w';\n\t\twpaint(a,b+1);\n\t}\n}\n\nvoid bpaint(int a,int b){\n\tif(a>0){\n\t\tif(map[a-1][b] == '.'){\n\t\t\tmap[a-1][b] = 'b';\n\t\t\tbpaint(a-1,b);\n\t\t}else if(map[a-1][b] == 'w'){\n\t\t\tmap[a-1][b] = 'g';\n\t\t\tbpaint(a-1,b);\n\t\t}\n\t}\n\tif(b>0){\n\t\tif(map[a][b-1] == '.'){\n\t\t\tmap[a][b-1] = 'b';\n\t\t\tbpaint(a,b-1);\n\t\t}else if(map[a][b-1] == 'w'){\n\t\t\tmap[a][b-1] = 'g';\n\t\t\tbpaint(a,b-1);\n\t\t}\n\t}\n\tif(a<h-1){\n\t\tif(map[a+1][b] == '.'){\n\t\t\tmap[a+1][b] = 'b';\n\t\t\tbpaint(a+1,b);\n\t\t}else if(map[a+1][b] == 'w'){\n\t\t\tmap[a+1][b] = 'g';\n\t\t\tbpaint(a+1,b);\n\t\t}\n\t}\n\tif(b<w-1){\n\t\tif(map[a][b+1] == '.'){\n\t\t\tmap[a][b+1] = 'b';\n\t\t\tbpaint(a,b+1);\n\t\t}else if(map[a][b+1] == 'w'){\n\t\t\tmap[a][b+1] = 'g';\n\t\t\tbpaint(a,b+1);\n\t\t}\n\t}\n}\n\nint bcount(){\n\tint i,j;\n\tint count = 0;\n\tfor(i=0;i<h;i++){\n\t\tfor(j=0;j<w;j++){\n\t\t\tif(map[i][j] == 'b') count++;\n\t\t}\n\t}\n\treturn count;\n}\n\nint wcount(){\n\tint i,j;\n\tint count = 0;\n\tfor(i=0;i<h;i++){\n\t\tfor(j=0;j<w;j++){\n\t\t\tif(map[i][j] == 'w') count++;\n\t\t}\n\t}\n\treturn count;\n}\n\nvoid printmap(){\n\tint i;\n\tfor(i=0;i<h;i++){\n\t\tprintf(\"%s\\n\",map[i]);\n\t}\n}\n\nvoid area(){\n\tscanmap();\n\tint i,j;\n\tfor(i=0;i<h;i++){\n\t\tfor(j=0;j<w;j++){\n\t\t\tif(map[i][j] == 'W') wpaint(i,j);\n\t\t}\n\t}\n\tfor(i=0;i<h;i++){\n\t\tfor(j=0;j<w;j++){\n\t\t\tif(map[i][j] == 'B') bpaint(i,j);\n\t\t}\n\t}\n\tprintf(\"%d %d\\n\",bcount(),wcount());\n//\tprintmap();\n}\n\nint main(){\n\twhile(1){\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w == 0 && h == 0) break;\n\t\tarea();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint main(){\n\t\n\tint i,j,p,c;\n\tint w,h;\n\tint wf,bf;\n\tint pw,ph;\n\t\n\twhile(1){\n\t\tscanf(\"%d%d\",&w,&h);\n\t\tif(w==0&&h==0) break;\n\t\tc = 1;\n\t\twf = 0;\n\t\tbf = 0;\n\t\tint a[52][52]={};\n\t\tfor(i=0;i<(w+2)*(h+2);i++){\n\t\t\ta[i/(w+2)][i%(w+2)] = 1;\n\t\t}\n\t\tchar in[w];\n\t\tfor(i=0;i<h;i++){\n\t\t\tscanf(\"%s\",in);\n\t\t\tfor(j=0;j<w;j++){\n\t\t\t\tif(in[j]=='W'){\n\t\t\t\t\ta[i+1][j+1] = 4;\n\t\t\t\t\twf++;\n\t\t\t\t}else if(in[j]=='B'){\n\t\t\t\t\ta[i+1][j+1] = 9;\n\t\t\t\t\tbf++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n/*\t\tfor(i=0;i<(w+2)*(h+2);i++){\n\t\t\tprintf(\"%d\",a[i/(w+2)][i%(w+2)]);\n\t\t\tif(i%(w+2)==(w+1)){\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t}\n\t\tprintf(\"\\n\");*/\n\t\twhile(c!=0){\n\t\t\tc = 0;\n\t\t\tfor(p=0;p<w*h;p++){\n\t\t\t\tpw = p%w+1;\n\t\t\t\tph = p/w+1;\n\t\t\t\tif(a[ph][pw]==0||a[ph][pw]==4||a[ph][pw]==9){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint x = a[ph-1][pw]*a[ph+1][pw]*a[ph][pw-1]*a[ph][pw+1];\n\t\t\t\tif(x==0){\n\t\t\t\t\ta[ph][pw] = 0;\n\t\t\t\t\tc++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint f1 = x%2;\n\t\t\t\tint f2 = x%3;\n\t\t\t\tif(a[ph][pw]==1){\n\t\t\t\t\tif(f1==0&&f2==0){\n\t\t\t\t\t\ta[ph][pw] = 0;\n\t\t\t\t\t\tc++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}else if(f1!=0&&f2!=0){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}else if(f1==0){\n\t\t\t\t\t\ta[ph][pw] = 2;\n\t\t\t\t\t\tc++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}else{\n\t\t\t\t\t\ta[ph][pw] = 3;\n\t\t\t\t\t\tc++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(a[ph][pw]==2){\n\t\t\t\t\tif(f2==0){\n\t\t\t\t\t\ta[ph][pw] = 0;\n\t\t\t\t\t\tc++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(a[ph][pw]==3){\n\t\t\t\t\tif(f1==0){\n\t\t\t\t\t\ta[ph][pw] = 0;\n\t\t\t\t\t\tc++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n//\t\t\tprintf(\"%d\\n\",c);\n\t\t}\n\t\tint wc=0,bc=0;\n\t\tfor(i=0;i<w*h;i++){\n\t\t\tif(a[i/w+1][i%w+1]==2){\n\t\t\t\twc++;\n\t\t\t}\n\t\t\tif(a[i/w+1][i%w+1]==3){\n\t\t\t\tbc++;\n\t\t\t}\n\t\t}\n/*\t\tfor(i=0;i<(w+2)*(h+2);i++){\n\t\t\tprintf(\"%d\",a[i/(w+2)][i%(w+2)]);\n\t\t\tif(i%(w+2)==(w+1)){\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t}*/\n\t\tprintf(\"%d %d\\n\",bc,wc);\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint w;\nint b;\nchar map[50][51];\nint we;\nint he;\n\nint measure(int x,int y){\n  int i,m=0,dir[4][2]={{1,0},{-1,0},{0,1},{0,-1}},nx,ny;\n  map[y][x]='F';\n  for(m=1,i=0;i<4;i++){\n    nx=x+dir[i][1];\n    ny=y+dir[i][0];\n    if(nx<we&&nx>-1&&ny<he&&ny>-1){\n      if(map[ny][nx]=='.'){\n\tm+=measure(nx,ny);\n      }else if(map[ny][nx]=='B'){\n\tb++;\n      }else if(map[ny][nx]=='W'){\n\tw++;\n      }\n    }\n  }\n  return m;\n}\nint main(){\n  int i,white,black,m,j;\n  do{\n    scanf(\"%d %d\",&we,&he);\n    if(we==0&&he==0) break;\n    for(i=0;i<he;i++) scanf(\"%s\",map[i]);\n    for(i=white=black=0;i<he;i++){\n      for(j=0;j<we;j++){\n\tif(map[i][j]=='.'){\n\t  m=measure(j,i);\n\t  if(w&&!b){\n\t    white+=m;\n\t  }else if(!w&&b){\n\t    black+=m;\n\t  }\n\t  w=b=0;\n\t}\n      }\n    }\n    printf(\"%d %d\\n\",black,white);\n  }while(1);\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint c,r,i,j,b[50][50]={0},w[50][50]={0},cb,cw;\nchar m[51][51];\nvoid f(int (*p)[50],int y,int x,char k)\n{\n\tint v[5]={0,1,0,-1,0},i;\n\tif(y>=0&&y<r&&x>=0&&x<c&&!p[y][x]&&m[y][x]!=k)\n\t\tfor(p[y][x]=1,i=0;i<4;i++)\n\t\t\tf(p,y+v[i],x+v[i+1],k);\n}\n\nint main()\n{\n\tfor(;scanf(\"%d%d\\n\",&c,&r),r;)\n\t{\n\t\tmemset(b,0,sizeof(b));\n\t\tmemset(w,0,sizeof(w));\n\t\tfor(i=0;i<r;i++)\n\t\t\tgets(m[i]);\n\t\tfor(i=cb=cw=0;i<r;i++)\n\t\t\tfor(j=0;j<c;j++)\n\t\t\t{\n\t\t\t\tif(m[i][j]=='B')\n\t\t\t\t\tcb++,f(b,i,j,'W');\n\t\t\t\telse if(m[i][j]=='W')\n\t\t\t\t\tcw++,f(w,i,j,'B');\n\t\t\t}\n\t\tfor(cw*=-1,cb*=-1,i=0;i<r;i++)\n\t\t\tfor(j=0;j<c;j++)\n\t\t\t{\n\t\t\t\tif(b[i][j]&&!w[i][j])\n\t\t\t\t\tcb++;\n\t\t\t\telse if(!b[i][j]&&w[i][j])\n\t\t\t\t\tcw++;\n\t\t\t}\n\t\tprintf(\"%d %d\\n\",cb,cw);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\nint dx[4]={-1,0,0,1};\nint dy[4]={0,1,-1,0};\nint w,h,wsum,bsum,wnum=0,bnum=0,kari;\nchar sima[51][51];\n\nint dfs(int y,int x){\n    int res=1,i;\n    if(y<0||y>=h||x<0||x>=w)\n        return 0;\n    \n    if(sima[y][x]!='.'){\n        if(sima[y][x]=='W')wnum++;\n        if(sima[y][x]=='B')bnum++;\n        return 0;\n    }\n    sima[y][x]='X';\n    \n    for(i=0;i<4;i++){\n        int nx=x+dx[i];\n        int ny=y+dy[i];\n        res+=dfs(ny, nx);\n    }\n    return res;\n}\n\nint main(void){\n    int i,j;\n    while(1){\n    scanf(\"%d %d\",&w,&h);\n        if(w==0)\n            break;\n    for(i=0;i<h;i++)\n        scanf(\"%s\",sima[i]);\n    \n    wsum=bsum=0;\n    for(i=0;i<h;i++)\n        for(j=0;j<w;j++){\n            wnum=bnum=0;\n            if(sima[i][j]!='.')\n                continue;\n            kari=dfs(i,j);\n            if(wnum!=0&&bnum==0)\n                wsum+=kari;\n            \n            if(wnum==0&&bnum!=0)\n                bsum+=kari;\n            \n        }\n    printf(\"%d %d\\n\",bsum,wsum);\n    }\n    return 0;\n    \n}"
  },
  {
    "language": "C",
    "code": "//\n//  main.c\n//  Surrounding Area\n//\n//  Created by x15071xx on 2016/06/22.\n//  Copyright ?? 2016?? AIT. All rights reserved.\n//\n\n#include <stdio.h>\n\nint dx[4] = {1,0,-1,0};\nint dy[4] = {0,1,0,-1};\n\nvoid paint (char field[51][51],int x,int y,char S,int h,int w) {\n    int i;\n    if (S == 'W') {\n        for (i=0; i<4; i++) {\n            if (y+dy[i] >= 0 && y+dy[i] < h && x+dx[i] >= 0 && x+dx[i] < w && field[y+dy[i]][x+dx[i]] == '.') {\n                field[y+dy[i]][x+dx[i]] = 'w';\n                paint(field, x+dx[i], y+dy[i], 'W', h, w);\n            }\n        }\n    } else if (S=='B'){\n        for (i=0; i<4; i++) {\n            if (y+dy[i] >= 0 && y+dy[i] < h && x+dx[i] >= 0 && x+dx[i] < w ) {\n                if (field[y+dy[i]][x+dx[i]] == 'w') {\n                    field[y+dy[i]][x+dx[i]] = 'x';\n                    paint(field, x+dx[i], y+dy[i], 'B', h, w);\n                } else if (field[y+dy[i]][x+dx[i]] == '.'){\n                    field[y+dy[i]][x+dx[i]] = 'b';\n                    paint(field, x+dx[i], y+dy[i], 'B', h, w);\n                }\n                \n                \n            }\n        }\n    }\n}\n\nint main(int argc, const char * argv[]) {\n    int i,j,k;\n    while (1) {\n        char field[51][51];\n        int w,h,b;\n        int count_w=0,count_b=0;\n        for (i=0; i<50; i++) {\n            for (j=0; j<50; j++) {\n                field[i][j] = 0;\n            }\n        }\n        \n        scanf(\"%d %d\",&w,&h);\n        \n        if (w==0&&h==0) {\n            break;\n        }\n        for (i=0; i<h; i++) {\n            scanf(\"%s\",field[i]);\n        }\n        \n        for (i=0; i<h; i++) {\n            for (j=0; j<w; j++) {\n                if (field[i][j] == 'W') {\n                    paint(field, j, i, 'W', h, w);\n                }\n            }\n        }\n        \n        \n        for (i=0; i<h; i++) {\n            for (j=0; j<w; j++) {\n                \n                if (field[i][j] == 'B') {\n                    paint(field, j, i, 'B', h, w);\n                }\n            }\n        }\n\n        \n        \n        for (i=0; i<h; i++) {\n            for (j=0; j<w; j++) {\n                if (field[i][j] == 'w') {\n                    count_w++;\n                } else if (field[i][j] == 'b') {\n                    count_b++;\n                }\n            }\n        }\n        \n        \n        printf(\"%d %d\\n\",count_b,count_w);\n        \n        \n        \n        \n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint width,height;\nint map[50][50];\nchar input_map[50][51];\n\nint main(void) {\n\tint i,j,k;\n\tint black,white;\n\twhile(1) {\n\t\tscanf(\"%d%d\",&width,&height);\n\t\tif(width==0 && height==0)break;\n\t\tmemset(map,0,sizeof(map));\n\t\tfor(i=0;i<height;i++) {\n\t\t\tscanf(\"%s\",input_map[i]);\n\t\t\tfor(j=0;j<width;j++) {\n\t\t\t\tif(input_map[i][j]=='B')map[i][j]=5;\n\t\t\t\telse if(input_map[i][j]=='W')map[i][j]=6;\n\t\t\t}\n\t\t}\n\t\tfor(k=0;k<width+height;k++) {\n\t\t\tfor(i=0;i<height;i++) {\n\t\t\t\tfor(j=0;j<width;j++) {\n\t\t\t\t\tif((map[i][j] & 4)==0) {\n\t\t\t\t\t\tif(i>0)map[i][j]|=map[i-1][j]&3;\n\t\t\t\t\t\tif(j>0)map[i][j]|=map[i][j-1]&3;\n\t\t\t\t\t\tif(i<height-1)map[i][j]|=map[i+1][j]&3;\n\t\t\t\t\t\tif(j<width-1)map[i][j]|=map[i][j+1]&3;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tblack=white=0;\n\t\tfor(i=0;i<height;i++) {\n\t\t\tfor(j=0;j<width;j++) {\n\t\t\t\tif(map[i][j]==1)black++;\n\t\t\t\telse if(map[i][j]==2)white++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\",black,white);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2014: Surrounding Area\n// 2017.10.1\n\n#include <stdio.h>\n#include <string.h>\n\ntypedef struct { int r, c; } Q;\nQ q[2700]; int top;\n\nchar map[52][52]; int w, h;\nchar visited[50][52];\n\nint mv[4][2] = { {-1,0},{0,1},{1,0},{0,-1} };\n\nvoid calc(int *sb, int *sw)\n{\n\tint i, f, r, c, r2, c2, sum;\n\n\t*sb = *sw = 0;\n\tmemset(visited, 0, sizeof(visited));\n\tfor (r = 0; r < h; r++) for (c = 0; c < w; c++) {\n\t\tif (map[r][c] != '.' || visited[r][c]) continue;\n\n\t\tf = 0, sum = 1, visited[r][c] = 1;\n\t\tq[0].r = r, q[0].c = c, top = 1;\n\t\twhile (top) {\n\t\t\tr = q[--top].r, c = q[top].c;\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tr2 = r + mv[i][0], c2 = c + mv[i][1];\n\t\t\t\tif (r2 < 0 || r2 >= h || c2 < 0 || c2 >= w || visited[r2][c2]) continue;\n\t\t\t\tif      (map[r2][c2] == 'B') f |= 1;\n\t\t\t\telse if (map[r2][c2] == 'W') f |= 2;\n\t\t\t\telse {\n\t\t\t\t\tvisited[r2][c2] = 1; sum++;\n\t\t\t\t\tq[top].r = r2, q[top++].c = c2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (f == 3);\n\t\telse if (f == 1) *sb += sum;\n\t\telse if (f == 2) *sw += sum;\n\t}\n}\n\nint main()\n{\n\tint r, c, sb, sw;\n\n\twhile (scanf(\"%d%d\", &w, &h) && w > 0) {\n\t\tfor (sb = sw = 0, r = 0; r < h; r++) {\n\t\t\tscanf(\"%s\", map[r]);\n\t\t\tfor (c = 0; c < w; c++) {\n\t\t\t\tif (map[r][c] == 'B') sb++;\n\t\t\t\telse if (map[r][c] == 'W') sw++;\n\t\t\t}\n\t\t}\n\t\tif (!sb && !sw) puts(\"0 0\");\n\t\telse if (!sb) printf(\"0 %d\\n\", w*h - sw);\n\t\telse if (!sw) printf(\"%d 0\\n\", w*h - sb);\n\t\telse { calc(&sb, &sw); printf(\"%d %d\\n\", sb, sw); }\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nchar map[60][60], v[60][60];\nint H, W;\nint dr[]={-1, 0, 1, 0}, dc[]={0, -1, 0, 1};\n\nint dfs(int r, int c, int k)\n{\n    char *t=&v[r][c];\n    *t|=k;\n    for(int i=0;i<4;++i) {\n        int nr=r+dr[i];\n        int nc=c+dc[i];\n        if (nr<0 || nr>=H || nc<0 || nc>=W)\n            *t|=4;\n        else if (map[nr][nc]=='B')\n            *t|=1;\n        else if (map[nr][nc]=='W')\n            *t|=2;\n    }\n    for(int i=0;i<4;++i) {\n        int nr=r+dr[i];\n        int nc=c+dc[i];\n        if (nr<0 || nr>=H || nc<0 || nc>=W || map[nr][nc]!='.' || (*t&v[nr][nc])==*t) continue;\n        dfs(nr, nc, *t);\n    }\n}\n\nint main(void)\n{\n    while (scanf(\"%d%d\", &W, &H), W) {\n        int r, c, b, w;\n        memset(map, 0, sizeof(map));\n        memset(v, 0, sizeof(v));\n        b=w=0;\n        for(r=0;r<H;++r) scanf(\"%s\", map[r]);\n\n        for(r=0;r<H;++r) for(c=0;c<W;++c) {\n            if (!v[r][c] && map[r][c]=='.') dfs(r, c, 0);\n        }\n        for(r=0;r<H;++r) for(c=0;c<W;++c) {\n            b+=(v[r][c]==1 || v[r][c]==5);\n            w+=(v[r][c]==2 || v[r][c]==6);\n        }\n        printf(\"%d %d\\n\", b, w);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nchar map[60][60], v[60][60];\nint H, W;\nint dr[]={-1, 0, 1, 0}, dc[]={0, -1, 0, 1};\n\nint dfs(int r, int c, int k)\n{\n    int i;\n    char *t=&v[r][c];\n    *t|=k;\n    for(i=0;i<4;++i) {\n        int nr=r+dr[i];\n        int nc=c+dc[i];\n        if (nr<0 || nr>=H || nc<0 || nc>=W)\n            *t|=4;\n        else if (map[nr][nc]=='B')\n            *t|=1;\n        else if (map[nr][nc]=='W')\n            *t|=2;\n    }\n    for(i=0;i<4;++i) {\n        int nr=r+dr[i];\n        int nc=c+dc[i];\n        if (nr<0 || nr>=H || nc<0 || nc>=W) continue;\n        if (map[nr][nc]!='.' || (*t&v[nr][nc])==*t) continue;\n        dfs(nr, nc, *t);\n    }\n}\n\nint main(void)\n{\n    while (scanf(\"%d%d\", &W, &H), W) {\n        int r, c, b, w;\n        memset(map, 0, sizeof(map));\n        memset(v, 0, sizeof(v));\n        b=w=0;\n        for(r=0;r<H;++r) scanf(\"%s\", map[r]);\n\n        for(r=0;r<H;++r) for(c=0;c<W;++c) {\n            if (!v[r][c] && map[r][c]=='.') dfs(r, c, 0);\n        }\n        for(r=0;r<H;++r) for(c=0;c<W;++c) {\n            b+=(v[r][c]==1 || v[r][c]==5);\n            w+=(v[r][c]==2 || v[r][c]==6);\n        }\n        printf(\"%d %d\\n\", b, w);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint main(){\n\t\n\tint i,j,p,c;\n\tint w,h;\n\tint wf,bf;\n\tint pw,ph;\n\t\n\twhile(1){\n\t\tscanf(\"%d%d\",&w,&h);\n\t\tif(w==0&&h==0) break;\n\t\tc = 1;\n\t\twf = 0;\n\t\tbf = 0;\n\t\tint a[52][52];\n\t\tfor(i=0;i<(w+2)*(h+2);i++){\n\t\t\ta[i/(w+2)][i%(w+2)] = 1;\n\t\t}\n\t\tchar in[w];\n\t\tfor(i=0;i<h;i++){\n\t\t\tscanf(\"%s\",in);\n\t\t\tfor(j=0;j<w;j++){\n\t\t\t\tif(in[j]=='W'){\n\t\t\t\t\ta[i+1][j+1] = 4;\n\t\t\t\t\twf++;\n\t\t\t\t}else if(in[j]=='B'){\n\t\t\t\t\ta[i+1][j+1] = 9;\n\t\t\t\t\tbf++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n/*\t\tfor(i=0;i<(w+2)*(h+2);i++){\n\t\t\tprintf(\"%d\",a[i/(w+2)][i%(w+2)]);\n\t\t\tif(i%(w+2)==(w+1)){\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t}\n\t\tprintf(\"\\n\");*/\n\t\twhile(c!=0){\n\t\t\tc = 0;\n\t\t\tfor(p=0;p<w*h;p++){\n\t\t\t\tpw = p%w+1;\n\t\t\t\tph = p/w+1;\n\t\t\t\tif(a[ph][pw]==0||a[ph][pw]==4||a[ph][pw]==9){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint x = a[ph-1][pw]*a[ph+1][pw]*a[ph][pw-1]*a[ph][pw+1];\n\t\t\t\tif(x==0){\n\t\t\t\t\ta[ph][pw] = 0;\n\t\t\t\t\tc++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint f1 = x%2;\n\t\t\t\tint f2 = x%3;\n\t\t\t\tif(a[ph][pw]==1){\n\t\t\t\t\tif(f1==0&&f2==0){\n\t\t\t\t\t\ta[ph][pw] = 0;\n\t\t\t\t\t\tc++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}else if(f1!=0&&f2!=0){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}else if(f1==0){\n\t\t\t\t\t\ta[ph][pw] = 2;\n\t\t\t\t\t\tc++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}else{\n\t\t\t\t\t\ta[ph][pw] = 3;\n\t\t\t\t\t\tc++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(a[ph][pw]==2){\n\t\t\t\t\tif(f2==0){\n\t\t\t\t\t\ta[ph][pw] = 0;\n\t\t\t\t\t\tc++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(a[ph][pw]==3){\n\t\t\t\t\tif(f1==0){\n\t\t\t\t\t\ta[ph][pw] = 0;\n\t\t\t\t\t\tc++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n//\t\t\tprintf(\"%d\\n\",c);\n\t\t}\n\t\tint wc=0,bc=0;\n\t\tfor(i=0;i<w*h;i++){\n\t\t\tif(a[i/w+1][i%w+1]==2){\n\t\t\t\twc++;\n\t\t\t}\n\t\t\tif(a[i/w+1][i%w+1]==3){\n\t\t\t\tbc++;\n\t\t\t}\n\t\t}\n/*\t\tfor(i=0;i<(w+2)*(h+2);i++){\n\t\t\tprintf(\"%d\",a[i/(w+2)][i%(w+2)]);\n\t\t\tif(i%(w+2)==(w+1)){\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t}*/\n\t\tprintf(\"%d %d\\n\",bc,wc);\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\nusing namespace std;\nint a[51][51],w,h,c;\nbool f;\n\nvoid visit(int i,int j,int bw){\n  a[i][j] = 3;\n  c++;\n  int di[4] = {1,0,-1,0};\n  int dj[4] = {0,1,0,-1};\n  for(int t=0;t<4;t++){\n    int vi = i + di[t];\n    int vj = j + dj[t];\n    if(bw == 1){\n      if(a[vi][vj] == 2){\n\tf = false;\n      }\n      else if(vi >= 0 && vj >= 0 && vi < w && vj < h && !a[vi][vj]){\n\tvisit(vi,vj,1);\n      }\n    }\n    else if(bw == 2){\n      if(a[vi][vj] == 1){\n\tf = false;\n      }\n      else if(vi >= 0 && vj >= 0 && vi < w && vj < h && !a[vi][vj]){\n\tvisit(vi,vj,2);\n      }\n    }\n  }\n}\n\nint main(){\n  int i,j,b,wh;\n  char str;\n  while(1){\n    cin >> w >> h;\n    if(w == 0 && h == 0) break;\n    for(i=0;i<=h;i++){\n      for(j=0;j<=w;j++){\n\tif(i == h || j == w) a[j][i] = 3;\n\telse{\n\t  cin >> str;\n\t  if(str == 'B') a[j][i] = 1;\n\t  else if(str == 'W') a[j][i] = 2;\n\t  else a[j][i] = 0;\n\t}\n      }\n    }\n\n    b = wh = 0;\n    int di[4] = {1,0,-1,0};\n    int dj[4] = {0,1,0,-1};\n    for(j=0;j<h;j++){\n      for(i=0;i<w;i++){\n\tif(a[i][j] == 1 || a[i][j] == 2){\n\t  for(int t=0;t<4;t++){\n\t    int vi = i + di[t];\n\t    int vj = j + dj[t];\n\t    if(a[i][j] == 1 && vi >= 0 && vj >= 0 && vi < w && vj < h && !a[vi][vj]){\n\t      c = 0;\n\t      f = true;\n\t      visit(vi,vj,1);\n\t      if(f) b += c;\n\t    }\n\t    else if(a[i][j] == 2 && vi >= 0 && vj >= 0 && vi < w && vj < h && !a[vi][vj]){\n\t      c = 0;\n\t      f = true;\n\t      visit(vi,vj,2);\n\t      if(f) wh += c;\n\t    }\n\t  }\n\t}\n      }\n    }\n    cout << b <<\" \" << wh << endl;   \n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<math.h>\n\nvoid CheckBlack(int, int, int, int);\nvoid CheckWhite(int, int, int, int);\n\nint area[50][50];\n\nint main()\n{\n\tint wCount, bCount;\n\tint i, j, h, w;\n\t\n\twhile(1)\n\t{\n\t\twCount = bCount = 0;\n\t\t\n\t\tscanf(\"%d %d\", &w, &h);\n\t\t\n\t\tchar input[51];\n\t\t\n\t\tif(h == 0 && w == 0) break;\n\t\t\n\t\tfor(i = 0; i < h; i++)\n\t\t{\n\t\t\tscanf(\" %s\", input);\n\t\t\tfor(j = 0; j < w; j++)\n\t\t\t{\n\t\t\t\tif(input[j] == 'W') {\n\t\t\t\t\tarea[i][j] = 1;\n\t\t\t\t} else if(input[j] == 'B') {\n\t\t\t\t\tarea[i][j] = 2;\n\t\t\t\t} else {\n\t\t\t\t\tarea[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(i = 0; i < h; i++)\n\t\t{\n\t\t\tfor(j = 0; j < w; j++)\n\t\t\t{\n\t\t\t\tif((area[i][j] & 3) == 1) {\n\t\t\t\t\tarea[i][j] |= 8;\n\t\t\t\t\tCheckWhite(i, j, h, w);\n\t\t\t\t} else if((area[i][j] & 3) == 2) {\n\t\t\t\t\tarea[i][j] |= 4;\n\t\t\t\t\tCheckBlack(i, j, h, w);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(i = 0; i < h; i++)\n\t\t{\n\t\t\tfor(j = 0; j < w; j++)\n\t\t\t{\n\t\t\t\tif((area[i][j] & 12) == 4) {\n\t\t\t\t\twCount++;\n\t\t\t\t} else if((area[i][j] & 12) == 8) {\n\t\t\t\t\tbCount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d %d\\n\", bCount, wCount);\n\t}\n\t\n\treturn 0;\n}\n\nvoid CheckBlack(int h, int w, int maxH, int maxW)\n{\n\tint i, hh, ww;\n\t\n\tif((area[h][w] & 8) != 8)\n\t{\n\t\tarea[h][w] |= 8;\n\t\t\n\t\tfor(i = 0; i < 4; i++)\n\t\t{\n\t\t\tww = cos(90 * i * M_PI / 180);\n\t\t\thh = sin(90 * i * M_PI / 180);\n\t\t\t\n\t\t\tif(h + hh > -1 && h + hh < maxH && w + ww > -1 && w + ww < maxW && (area[h + hh][w + ww] & 3) == 0)\n\t\t\t{\n\t\t\t\tCheckBlack(h + hh, w + ww, maxH, maxW);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid CheckWhite(int h, int w, int maxH, int maxW)\n{\n\tint i, hh, ww;\n\t\n\tif((area[h][w] & 4) != 4)\n\t{\n\t\tarea[h][w] |= 4;\n\t\t\n\t\tfor(i = 0; i < 4; i++)\n\t\t{\n\t\t\tww = cos(90 * i * M_PI / 180);\n\t\t\thh = sin(90 * i * M_PI / 180);\n\t\t\t\n\t\t\tif(h + hh > -1 && h + hh < maxH && w + ww > -1 && w + ww < maxW && (area[h + hh][w + ww] & 3) == 0)\n\t\t\t{\n\t\t\t\tCheckWhite(h + hh, w + ww, maxH, maxW);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint width,height;\nint map[50][50];\nchar input_map[50][51];\n\nint main(void) {\n\tint i,j,k;\n\tint black,white;\n\twhile(1) {\n\t\tscanf(\"%d%d\",&width,&height);\n\t\tif(width==0 && height==0)break;\n\t\tmemset(map,0,sizeof(map));\n\t\tfor(i=0;i<height;i++) {\n\t\t\tscanf(\"%s\",input_map[i]);\n\t\t\tfor(j=0;j<width;j++) {\n\t\t\t\tif(input_map[i][j]=='B')map[i][j]=5;\n\t\t\t\telse if(input_map[i][j]=='W')map[i][j]=6;\n\t\t\t}\n\t\t}\n\t\tfor(k=0;k<width*height;k++) {\n\t\t\tfor(i=0;i<height;i++) {\n\t\t\t\tfor(j=0;j<width;j++) {\n\t\t\t\t\tif((map[i][j] & 4)==0) {\n\t\t\t\t\t\tif(i>0)map[i][j]|=map[i-1][j]&3;\n\t\t\t\t\t\tif(j>0)map[i][j]|=map[i][j-1]&3;\n\t\t\t\t\t\tif(i<height-1)map[i][j]|=map[i+1][j]&3;\n\t\t\t\t\t\tif(j<width-1)map[i][j]|=map[i][j+1]&3;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tblack=white=0;\n\t\tfor(i=0;i<height;i++) {\n\t\t\tfor(j=0;j<width;j++) {\n\t\t\t\tif(map[i][j]==1)black++;\n\t\t\t\telse if(map[i][j]==2)white++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\",black,white);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint main(){\n\t\n\tint i,j,p,c;\n\tint w,h;\n\tint wf,bf;\n\tint pw,ph;\n\t\n\twhile(1){\n\t\tscanf(\"%d%d\",&w,&h);\n\t\tif(w==0&&h==0) break;\n\t\tc = 1;\n\t\twf = 0;\n\t\tbf = 0;\n\t\tint a[52][52]={};\n\t\tfor(i=0;i<(w+2)*(h+2);i++){\n\t\t\ta[i/(w+2)][i%(w+2)] = 1;\n\t\t}\n\t\tchar in[w];\n\t\tfor(i=0;i<h;i++){\n\t\t\tscanf(\"%s\",in);\n\t\t\tfor(j=0;j<w;j++){\n\t\t\t\tif(in[j]=='W'){\n\t\t\t\t\ta[i+1][j+1] = 4;\n\t\t\t\t\twf++;\n\t\t\t\t}else if(in[j]=='B'){\n\t\t\t\t\ta[i+1][j+1] = 9;\n\t\t\t\t\tbf++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(c!=0){\n\t\t\tc = 0;\n\t\t\tfor(p=0;p<w*h;p++){\n\t\t\t\tpw = p%w+1;\n\t\t\t\tph = p/w+1;\n\t\t\t\tif(a[ph][pw]==0||a[ph][pw]==4||a[ph][pw]==9){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint x = a[ph-1][pw]*a[ph+1][pw]*a[ph][pw-1]*a[ph][pw+1];\n\t\t\t\tif(x==0){\n\t\t\t\t\ta[ph][pw] = 0;\n\t\t\t\t\tc++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint f1 = x%2;\n\t\t\t\tint f2 = x%3;\n\t\t\t\tif(a[ph][pw]==1){\n\t\t\t\t\tif(f1==0&&f2==0){\n\t\t\t\t\t\ta[ph][pw] = 0;\n\t\t\t\t\t\tc++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}else if(f1!=0&&f2!=0){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}else if(f1==0){\n\t\t\t\t\t\ta[ph][pw] = 2;\n\t\t\t\t\t\tc++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}else{\n\t\t\t\t\t\ta[ph][pw] = 3;\n\t\t\t\t\t\tc++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(a[ph][pw]==2){\n\t\t\t\t\tif(f2==0){\n\t\t\t\t\t\ta[ph][pw] = 0;\n\t\t\t\t\t\tc++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(a[ph][pw]==3){\n\t\t\t\t\tif(f1==0){\n\t\t\t\t\t\ta[ph][pw] = 0;\n\t\t\t\t\t\tc++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint wc=0,bc=0;\n\t\tfor(i=0;i<w*h;i++){\n\t\t\tif(a[i/w+1][i%w+1]==2){\n\t\t\t\twc++;\n\t\t\t}\n\t\t\tif(a[i/w+1][i%w+1]==3){\n\t\t\t\tbc++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d %d\\n\",bc,wc);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nchar map[50][50];\nint w,h;\n\nvoid areaw(int x,int y)\n{\n  if(x+1<h){\n    if(map[x+1][y] == '.'){\n\t\t\tmap[x+1][y] = 'w';\n\t\t\tareaw(x+1,y);\n    }else if(map[x+1][y]=='b'){\n\t\t\tmap[x+1][y] = 'o';\n\t\t\tareaw(x+1,y);\n    }\n  }\n  if(y+1<w){\n    if(map[x][y+1] == '.'){\n\t\t\tmap[x][y+1] = 'w';\n\t\t\tareaw(x,y+1);\n    }else if(map[x][y+1]=='b'){\n\t\t\tmap[x][y+1] = 'o';\n\t\t\tareaw(x,y+1);\n    }\n  }\n  if(x-1>=0){\n    if(map[x-1][y] == '.'){\n\t\t\tmap[x-1][y] = 'w';\n\t\t\tareaw(x-1,y);\n    }else if(map[x-1][y]=='b'){\n\t\t\tmap[x-1][y] = 'o';\n\t\t\tareaw(x-1,y);\n    }\n  }\n  if(y-1>=0){\n    if(map[x][y-1] == '.'){\n\t\t\tmap[x][y-1] = 'w';\n\t\t\tareaw(x,y-1);\n    }else if(map[x][y-1]=='b'){\n\t\t\tmap[x][y-1] = 'o';\n\t\t\tareaw(x,y-1);\n    }\n  }\n}\n\nvoid areab(int x,int y)\n{\n  if(x+1<h){\n    if(map[x+1][y] == '.'){\n\t\t\tmap[x+1][y] = 'b';\n\t\t\tareab(x+1,y);\n   \t}else if(map[x+1][y]=='w'){\n\t\t\tmap[x+1][y] = 'o';\n\t\t\tareab(x+1,y);\n    }\n  }\n  if(y+1<w){\n    if(map[x][y+1] == '.'){\n\t\t\tmap[x][y+1] = 'b';\n\t\t\tareab(x,y+1);\n    }else if(map[x][y+1]=='w'){\n\t\t\tmap[x][y+1] = 'o';\n\t\t\tareab(x,y+1);\n    }\n  }\n  if(x-1>=0){\n    if(map[x-1][y] == '.'){\n\t\t\tmap[x-1][y] = 'b';\n\t\t\tareab(x-1,y);\n    }else if(map[x-1][y]=='w'){\n\t\t\tmap[x-1][y] = 'o';\n\t\t\tareab(x-1,y);\n    }\n  }\n  if(y-1>=0){\n    if(map[x][y-1] == '.'){\n\t\t\tmap[x][y-1] = 'b';\n\t\t\tareab(x,y-1);\n    }else if(map[x][y-1]=='w'){\n\t\t\tmap[x][y-1] = 'o';\n\t\t\tareab(x,y-1);\n    }\n  }\n} \n\nint main(void)\n{\n  int i,j;\n  int black,white;\n\n  while(1){\n    scanf(\"%d %d \",&w,&h);\n    if(w==0 && h==0)break;\n\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\t\t\t\tscanf(\"%c \",&map[i][j]);\n      }\n    }\n\n    for(i=0;i<h;i++){\n    \tfor(j=0;j<w;j++){\n    \t\tif(map[i][j]=='W')areaw(i,j);\n    \t\tif(map[i][j]=='B')areab(i,j);\n    \t}\n    }\n    \n    white = 0;\n    black = 0;\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\t\t\t\tif(map[i][j]=='w')white++;\n\t\t\t\tif(map[i][j]=='b')black++;\n      }\n    }\n    printf(\"%d %d\\n\",black,white);\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nchar map[50][50]; //map[h][w]\nint w,h;\n\nvoid scanmap(){\n\tint i;\n\tfor(i=0;i<h;i++){\n\t\tscanf(\"%s\",map[i]);\n\t}\n}\n\nvoid wpaint(int a,int b){\n\tif(a>0 && map[a-1][b] == '.'){\n\t\tmap[a-1][b] = 'w';\n\t\twpaint(a-1,b);\n\t}\n\tif(b>0 && map[a][b-1] == '.'){\n\t\tmap[a][b-1] = 'w';\n\t\twpaint(a,b-1);\n\t}\n\tif(a<h && map[a+1][b] == '.'){\n\t\tmap[a+1][b] = 'w';\n\t\twpaint(a+1,b);\n\t}\n\tif(b<w && map[a][b+1] == '.'){\n\t\tmap[a][b+1] = 'w';\n\t\twpaint(a,b+1);\n\t}\n}\n\nvoid bpaint(int a,int b){\n\tif(a>0){\n\t\tif(map[a-1][b] == '.'){\n\t\t\tmap[a-1][b] = 'b';\n\t\t\tbpaint(a-1,b);\n\t\t}else if(map[a-1][b] == 'w'){\n\t\t\tmap[a-1][b] = 'g';\n\t\t\tbpaint(a-1,b);\n\t\t}\n\t}\n\tif(b>0){\n\t\tif(map[a][b-1] == '.'){\n\t\t\tmap[a][b-1] = 'b';\n\t\t\tbpaint(a,b-1);\n\t\t}else if(map[a][b-1] == 'w'){\n\t\t\tmap[a][b-1] = 'g';\n\t\t\tbpaint(a,b-1);\n\t\t}\n\t}\n\tif(a<h){\n\t\tif(map[a+1][b] == '.'){\n\t\t\tmap[a+1][b] = 'b';\n\t\t\tbpaint(a+1,b);\n\t\t}else if(map[a+1][b] == 'w'){\n\t\t\tmap[a+1][b] = 'g';\n\t\t\tbpaint(a+1,b);\n\t\t}\n\t}\n\tif(b<w){\n\t\tif(map[a][b+1] == '.'){\n\t\t\tmap[a][b+1] = 'b';\n\t\t\tbpaint(a,b+1);\n\t\t}else if(map[a][b+1] == 'w'){\n\t\t\tmap[a][b+1] = 'g';\n\t\t\tbpaint(a,b+1);\n\t\t}\n\t}\n}\n\nint bcount(){\n\tint i,j;\n\tint count = 0;\n\tfor(i=0;i<h;i++){\n\t\tfor(j=0;j<w;j++){\n\t\t\tif(map[i][j] == 'b') count++;\n\t\t}\n\t}\n\treturn count;\n}\n\nint wcount(){\n\tint i,j;\n\tint count = 0;\n\tfor(i=0;i<h;i++){\n\t\tfor(j=0;j<w;j++){\n\t\t\tif(map[i][j] == 'w') count++;\n\t\t}\n\t}\n\treturn count;\n}\n\nvoid printmap(){\n\tint i;\n\tfor(i=0;i<h;i++){\n\t\tprintf(\"%s\\n\",map[i]);\n\t}\n}\n\nvoid area(){\n\tscanmap();\n\tint i,j;\n\tfor(i=0;i<h;i++){\n\t\tfor(j=0;j<w;j++){\n\t\t\tif(map[i][j] == 'W') wpaint(i,j);\n\t\t}\n\t}\n\tfor(i=0;i<h;i++){\n\t\tfor(j=0;j<w;j++){\n\t\t\tif(map[i][j] == 'B') bpaint(i,j);\n\t\t}\n\t}\n\tprintf(\"%d %d\\n\",bcount(),wcount());\n//\tprintmap();\n}\n\nint main(){\n\twhile(1){\n\t\tscanf(\"%d %d\",&w,&h);\n\t\tif(w == 0 && b == 0) break;\n\t\tarea();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint main(){\n\t\n\tint i,j,p,c;\n\tint w,h;\n\tint wf,bf;\n\tint pw,ph;\n\t\n\twhile(1){\n\t\tscanf(\"%d%d\",&w,&h);\n\t\tif(w==0&&h==0) break;\n\t\tc = 1;\n\t\twf = 0;\n\t\tbf = 0;\n\t\tint a[h+2][w+2];\n\t\tfor(i=0;i<(w+2)*(h+2);i++){\n\t\t\ta[i/(w+2)][i%(w+2)] = 1;\n\t\t}\n\t\tchar in[w];\n\t\tfor(i=0;i<h;i++){\n\t\t\tscanf(\"%s\",in);\n\t\t\tfor(j=0;j<w;j++){\n\t\t\t\tif(in[j]=='W'){\n\t\t\t\t\ta[i+1][j+1] = 4;\n\t\t\t\t\twf++;\n\t\t\t\t}else if(in[j]=='B'){\n\t\t\t\t\ta[i+1][j+1] = 9;\n\t\t\t\t\tbf++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n/*\t\tfor(i=0;i<(w+2)*(h+2);i++){\n\t\t\tprintf(\"%d\",a[i/(w+2)][i%(w+2)]);\n\t\t\tif(i%(w+2)==(w+1)){\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t}\n\t\tprintf(\"\\n\");*/\n\t\twhile(c!=0){\n\t\t\tc = 0;\n\t\t\tfor(p=0;p<w*h;p++){\n\t\t\t\tpw = p%w+1;\n\t\t\t\tph = p/w+1;\n\t\t\t\tif(a[ph][pw]==0||a[ph][pw]==4||a[ph][pw]==9){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint x = a[ph-1][pw]*a[ph+1][pw]*a[ph][pw-1]*a[ph][pw+1];\n\t\t\t\tif(x==0){\n\t\t\t\t\ta[ph][pw] = 0;\n\t\t\t\t\tc++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint f1 = x%2;\n\t\t\t\tint f2 = x%3;\n\t\t\t\tif(a[ph][pw]==1){\n\t\t\t\t\tif(f1==0&&f2==0){\n\t\t\t\t\t\ta[ph][pw] = 0;\n\t\t\t\t\t\tc++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}else if(f1!=0&&f2!=0){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}else if(f1==0){\n\t\t\t\t\t\ta[ph][pw] = 2;\n\t\t\t\t\t\tc++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}else{\n\t\t\t\t\t\ta[ph][pw] = 3;\n\t\t\t\t\t\tc++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(a[ph][pw]==2){\n\t\t\t\t\tif(f2==0){\n\t\t\t\t\t\ta[ph][pw] = 0;\n\t\t\t\t\t\tc++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(a[ph][pw]==3){\n\t\t\t\t\tif(f1==0){\n\t\t\t\t\t\ta[ph][pw] = 0;\n\t\t\t\t\t\tc++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n//\t\t\tprintf(\"%d\\n\",c);\n\t\t}\n\t\tint wc=0,bc=0;\n\t\tfor(i=0;i<w*h;i++){\n\t\t\tif(a[i/w+1][i%w+1]==2){\n\t\t\t\twc++;\n\t\t\t}\n\t\t\tif(a[i/w+1][i%w+1]==3){\n\t\t\t\tbc++;\n\t\t\t}\n\t\t}\n/*\t\tfor(i=0;i<(w+2)*(h+2);i++){\n\t\t\tprintf(\"%d\",a[i/(w+2)][i%(w+2)]);\n\t\t\tif(i%(w+2)==(w+1)){\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t}*/\n\t\tprintf(\"%d %d\\n\",bc,wc);\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define N 50\n\nint dmap[N][N];\nint bmap[N][N];\nint wmap[N][N];\nint pmap[N][N];\nint dx[4]={0,1,0,-1};\nint dy[4]={-1,0,1,0};\nint w, h;\nvoid bdfs(int,int);\nvoid wdfs(int,int);\n\nint main(){\n  int i, j, ansb, answ, k,l;\n  char input;\n  while(1){\n    scanf(\"%d %d\", &w, &h);\n    if(w==0 && h==0) break;\n    for(i=0;i<h;i++){\n      getchar();\n      for(j=0;j<w;j++){\n        scanf(\"%c\", &input);\n        if(input=='B'){\n          dmap[i][j]=1;\n        }\n        else if(input=='W'){\n          dmap[i][j]=2;\n        }\n        else{\n          dmap[i][j]=0;\n        }\n        bmap[i][j]=0;\n        wmap[i][j]=0;\n      }\n    }\n\n\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n        for(k=0;k<h;k++){\n          for(l=0;l<w;l++){\n            pmap[k][l]=0;\n          }\n        }\n        bdfs(i,j);\n      }\n    }\n\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n        for(k=0;k<h;k++){\n          for(l=0;l<w;l++){\n            pmap[k][l]=0;\n          }\n        }\n        wdfs(i,j);\n      }\n    }\n    ansb=0;\n    answ=0;\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n        if(dmap[i][j]) continue;\n        if(bmap[i][j] && !wmap[i][j]) ansb++;\n        else if(!bmap[i][j] && wmap[i][j]){\n          answ++;\n        }\n      }\n    }\n\n    printf(\"%d %d\\n\", ansb, answ);\n  }\n  return 0;\n}\n\nvoid bdfs(int y, int x){\n  if(pmap[y][x]) return;\n  if(dmap[y][x]) return;\n  pmap[y][x]=1;\n  int tx, ty, i;\n  for(i=0;i<4;i++){\n    tx=dx[i]+x;\n    ty=dy[i]+y;\n    if(tx<0 || tx>=w) continue;\n    if(ty<0 || ty>=h) continue;\n    if(dmap[ty][tx]==1){\n      bmap[y][x]=1;\n    }\n    else if(bmap[ty][tx]){\n      bmap[y][x]=1;\n    }\n    bdfs(ty,tx);\n  }\n  return;\n}\n\n\nvoid wdfs(int y, int x){\n  if(pmap[y][x]) return;\n  if(dmap[y][x]) return;\n  pmap[y][x]=1;\n  int tx, ty, i;\n  for(i=0;i<4;i++){\n    tx=dx[i]+x;\n    ty=dy[i]+y;\n    if(tx<0 || tx>=w) continue;\n    if(ty<0 || ty>=h) continue;\n    else if(dmap[ty][tx]==2){\n      wmap[y][x]=1;\n    }\n    else if(wmap[ty][tx]) wmap[y][x]=1;\n    else wdfs(ty,tx);\n  }\n  return;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint main(void)\n{\n\tint w, h;\n\tint map[51][51];\n\tchar in[51];\n\tint i, j;\n\tint nb, nw;\n\tint n;\n\tint cnt;\n\tint flag;\n\tint flag_b, flag_w;\n\t\n\twhile (1){\n\t\tscanf(\"%d%d\", &w, &h);\n\t\tif (w == 0 && h == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tmemset(map, -1, sizeof(map));\n\t\t\n\t\tfor (i = 1; i <= h; i++){\n\t\t\tscanf(\"%s\", in);\n\t\t\tfor (j = 1; j <= w; j++){\n\t\t\t\tswitch (in[j - 1]){\n\t\t\t\t  case '.':\n\t\t\t\t    map[i][j] = -2;\n\t\t\t\t\tbreak;\n\n\t\t\t\t  case 'B':\n\t\t\t\t    map[i][j] = -4;\n\t\t\t\t\tbreak;\n\n\t\t\t\t  case 'W':\n\t\t\t\t    map[i][j] = -8;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tn = 1;\n\t\tnb = nw = 0;\n\t\t\n\t\twhile (1){\n\t\t\tfor (i = 1; i <= h; i++){\n\t\t\t\tfor (j = 1; j <= w; j++){\n\t\t\t\t\tif (map[i][j] == -2){\n\t\t\t\t\t\tgoto exit;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\nexit:;\n\n\t\t\tif (i == h + 1 && j == w + 1){\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tflag_b = flag_w = 0;\n\t\t\tmap[i][j] = n;\n\t\t\tif (map[i    ][j - 1] == -4){\n\t\t\t\t flag_b = 1;\n\t\t\t}\n\t\t\tif (map[i    ][j - 1] == -8){\n\t\t\t\t flag_w = 1;\n\t\t\t}\n\t\t\tif (map[i    ][j + 1] == -4){\n\t\t\t\t flag_b = 1;\n\t\t\t}\n\t\t\tif (map[i    ][j + 1] == -8){\n\t\t\t\t flag_w = 1;\n\t\t\t}\n\t\t\tif (map[i - 1][j] == -4){\n\t\t\t\t flag_b = 1;\n\t\t\t}\n\t\t\tif (map[i - 1][j] == -8){\n\t\t\t\t flag_w = 1;\n\t\t\t}\n\t\t\tif (map[i + 1][j] == -4){\n\t\t\t\t flag_b = 1;\n\t\t\t}\n\t\t\tif (map[i + 1][j] == -8){\n\t\t\t\t flag_w = 1;\n\t\t\t}\n\n\t\t\tcnt = 1;\n\n\t\t\tdo {\n\t\t\t\tflag = 0;\n\t\t\t\tfor (i = 1; i <= h; i++){\n\t\t\t\t\tfor (j = 1; j <= w; j++){\n\t\t\t\t\t\tif (map[i][j] == -2){\n\t\t\t\t\t\t\tif (map[i    ][j - 1] == n ||\n\t\t\t\t\t\t\t\tmap[i - 1][j    ] == n ||\n\t\t\t\t\t\t\t\tmap[i    ][j + 1] == n ||\n\t\t\t\t\t\t\t\tmap[i + 1][j    ] == n){\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tmap[i][j] = n;\n\t\t\t\t\t\t\t\tflag = 1;\n\t\t\t\t\t\t\t\tcnt++;\n\n\t\t\t\t\t\t\t\tif (map[i    ][j - 1] == -4){\n\t\t\t\t\t\t\t\t\t flag_b = 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (map[i    ][j - 1] == -8){\n\t\t\t\t\t\t\t\t\t flag_w = 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (map[i    ][j + 1] == -4){\n\t\t\t\t\t\t\t\t\t flag_b = 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (map[i    ][j + 1] == -8){\n\t\t\t\t\t\t\t\t\t flag_w = 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (map[i - 1][j] == -4){\n\t\t\t\t\t\t\t\t\t flag_b = 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (map[i - 1][j] == -8){\n\t\t\t\t\t\t\t\t\t flag_w = 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (map[i + 1][j] == -4){\n\t\t\t\t\t\t\t\t\t flag_b = 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (map[i + 1][j] == -8){\n\t\t\t\t\t\t\t\t\t flag_w = 1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} while (flag == 1);\n\t\n\t\t\tif (flag_b == 1 && flag_w == 0){\n\t\t\t\tnb += cnt;\n\t\t\t}\n\t\t\telse if (flag_b == 0 && flag_w == 1){\n\t\t\t\tnw += cnt;\n\t\t\t}\n\t\t\tn++;\n#if 0\t\t\t\n\t\t\tfor (i = 1; i <= h; i++){\n\t\t\t\tfor (j = 1; j <= w; j++){\n\t\t\t\t\tprintf(\"%4d\", map[i][j]);\n\t\t\t\t}\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n#endif\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t\tprintf(\"%d %d\\n\", nb, nw);\n\t}\n\treturn (0);\n}\n\n\t\t\t\t\t\t\t\t\t"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int X[]={0,1,0,-1};\n  int Y[]={1,0,-1,0};\t   \n  int w,h,i,j,ny,nx,k,l,x[3000],y[3000],t,r;\n  char s[55][55];\n  while(scanf(\"%d %d\",&w,&h),w||h){\n    int c[4]={0};\n    int e[55][55]={0};\n    for(i=0;i<h;i++)scanf(\"%s\",s[i+1]+1);\n    for(i=1;i<=h;i++){\n      for(j=1;j<=w;j++){\n\tif(s[i][j]=='.')continue;\n\tif(s[i][j]=='W')k=2;\n\telse            k=1;\n\ty[0  ]=i;\n\tx[t=0]=j;\n\tfor(r=1;r-t;t++){//printf(\"%d\\n\",r);\n\t  for(l=0;l<4;l++){\n\t    ny=y[t]+Y[l];\n\t    nx=x[t]+X[l];\n\t    if(s[ny][nx]-'.'||e[ny][nx]==k||e[ny][nx]==3)continue;\n\t    e[y[r]=ny][x[r]=nx]+=k;\n\t    r++;\n\t  }\n\t}\n      }\n    }\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++)c[e[i+1][j+1]]++;\n    }\n    printf(\"%d %d\\n\",c[1],c[2]);\n  }\n  return 0;\n}"
  },
  {
    "language": "Kotlin",
    "code": "\nfun main(args:Array<String>):Unit{\n    while(true){\n        val (w, h) = readLine()!!.split(' ').map(String::toInt)\n        if (w == 0 && h == 0) return\n        val map = Array(h){\n            readLine()!!.map { when(it){\n                'W' -> Pole.White\n                'B' -> Pole.Black\n                else -> Pole.None\n            } }.toTypedArray()\n        }\n        val teritory = Array(h){Array(w){Teritory()}}\n        map.forEachIndexed{height, line -> line.forEachIndexed { width, pole ->\n            search(teritory, map, height, width, pole)\n        }}\n        println(\"${teritory.map{line -> line.count{it.isBlackTeritory}}.sum() - map.map{it.count{it == Pole.Black}}.sum()} ${teritory.map{line -> line.count{it.isWhiteTeritory}}.sum() - map.map{it.count{it == Pole.White}}.sum()}\")\n    }\n}\nfun search(teritory:Array<Array<Teritory>>, map:Array<Array<Pole>>, h:Int, w:Int, pole:Pole):Unit{\n    if (h !in teritory.indices || w !in teritory[0].indices || teritory[h][w].isAlreadyNeighbor(pole) || (map[h][w] != Pole.None && map[h][w] != pole)) return\n    teritory[h][w].addExtendedNeighborhood(pole)\n    search(teritory, map,h - 1, w, pole)\n    search(teritory, map, h + 1, w, pole)\n    search(teritory, map, h, w - 1, pole)\n    search(teritory, map, h, w + 1, pole)\n}\nenum class Pole{\n    Black, White, None\n}\nclass Teritory{\n    private var mIsWhiteNeighbor:Boolean = false\n    private var mIsBlackNeighbor:Boolean = false\n    fun addExtendedNeighborhood(pole:Pole):Unit{\n        when(pole){\n            Pole.Black -> mIsBlackNeighbor = true\n            Pole.White -> mIsWhiteNeighbor = true\n            else -> {}\n        }\n    }\n    fun isAlreadyNeighbor(pole:Pole):Boolean {\n        return when(pole){\n            Pole.Black -> mIsBlackNeighbor\n            Pole.White -> mIsWhiteNeighbor\n            else -> true\n        }\n    }\n    val isBlackTeritory:Boolean\n        get() = mIsBlackNeighbor && !mIsWhiteNeighbor\n    val isWhiteTeritory:Boolean\n        get() = mIsWhiteNeighbor && !mIsBlackNeighbor\n    val isBlackNeighbor:Boolean\n        get() = mIsBlackNeighbor\n    val isWhiteNeighbor:Boolean\n        get() = mIsWhiteNeighbor\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "\nfun main(args:Array<String>):Unit{\n    while(true){\n        val (w, h) = readLine()!!.split(' ').map(String::toInt)\n        if (w == 0 && h == 0) return\n        val map = Array(h){\n            readLine()!!.map { when(it){\n                'W' -> Pole.White\n                'B' -> Pole.Black\n                else -> Pole.None\n            } }.toTypedArray()\n        }\n        val teritory = Array(h){Array(w){Teritory()}}\n        map.forEachIndexed{h, line -> line.forEachIndexed { w, pole ->\n            search(teritory, map, h, w, pole)\n        }}\n        println(\"${teritory.map{line -> line.count{it.isBlackTeritory}}.sum() - map.map{it.count{it == Pole.Black}}.sum()} ${teritory.map{line -> line.count{it.isWhiteTeritory}}.sum() - map.map{it.count{it == Pole.White}}.sum()}\")\n    }\n}\nfun search(teritory:Array<Array<Teritory>>, map:Array<Array<Pole>>, h:Int, w:Int, pole:Pole):Unit{\n    if (h !in teritory.indices || w !in teritory[0].indices || teritory[h][w].isAlreadyNeighbor(pole) || (map[h][w] != Pole.None && map[h][w] != pole)) return\n    teritory[h][w].addExtendedNeighborhood(pole)\n    search(teritory, map,h - 1, w, pole)\n    search(teritory, map, h + 1, w, pole)\n    search(teritory, map, h, w - 1, pole)\n    search(teritory, map, h, w + 1, pole)\n}\nenum class Pole{\n    Black, White, None\n}\nclass Teritory{\n    private var mIsWhiteNeighbor:Boolean = false\n    private var mIsBlackNeighbor:Boolean = false\n    fun addExtendedNeighborhood(pole:Pole):Unit{\n        when(pole){\n            Pole.Black -> mIsBlackNeighbor = true\n            Pole.White -> mIsWhiteNeighbor = true\n            else -> {}\n        }\n    }\n    fun isAlreadyNeighbor(pole:Pole):Boolean {\n        return when(pole){\n            Pole.Black -> mIsBlackNeighbor\n            Pole.White -> mIsWhiteNeighbor\n            else -> true\n        }\n    }\n    val isBlackTeritory:Boolean\n        get() = mIsBlackNeighbor && !mIsWhiteNeighbor\n    val isWhiteTeritory:Boolean\n        get() = mIsWhiteNeighbor && !mIsBlackNeighbor\n    val isBlackNeighbor:Boolean\n        get() = mIsBlackNeighbor\n    val isWhiteNeighbor:Boolean\n        get() = mIsWhiteNeighbor\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n\npublic class Main{\n\nstatic PrintWriter out;\nstatic InputReader ir;\n\nstatic void solve(){\n for(;;){\n  w=ir.nextInt();\n  h=ir.nextInt();\n  if(w==0&&h==0) return;\n  map=ir.nextCharMap(h,w);\n  cnd=new int[h][w];\n  for(int i=0;i<h;i++){\n   for(int j=0;j<w;j++){\n    if(map[i][j]!='.'){\n     for(int k=0;k<4;k++){\n      int nx=x+dd[k],ny=y+dd[k^1];\n      if(!in(nx,ny)) continue;\n      if(map[nx][ny]=='.'&&(cnd[nx][ny]&m)==0) dfs(i,j,map[i][j]=='B'?1:2);\n     }\n    }\n   }\n  }\n  int bl=0,wh=0;\n  for(int i=0;i<h;i++){\n   for(int j=0;j<w;j++){\n    if(cnd[i][j]==1) bl++;\n    if(cnd[i][j]==2) wh++;\n   }\n  }\n  out.println(bl+\" \"+wh);\n }\n}\n\nstatic final int[] dd=new int[]{0,-1,0,1};\nstatic int w,h;\nstatic char[][] map;\nstatic int[][] cnd;\nstatic Deque<int[]> que=new ArrayDeque<>();\n\npublic static boolean in(int x,int y){\n return (x>=0&&y>=0&&x<h&&y<w);\n}\n\npublic static void dfs(int x,int y,int m){\n cnd[x][y]|=m;\n for(int i=0;i<4;i++){\n  int nx=x+dd[i],ny=y+dd[i^1];\n  if(!in(nx,ny)) continue;\n  if(map[nx][ny]=='.'&&(cnd[nx][ny]&m)==0) dfs(nx,ny,m);\n }\n}\n\npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n\nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n\n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n\n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n \n public boolean hasNext(){skip(); return hasNextByte();}\n \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n\n public double nextDouble(){return Double.parseDouble(next());}\n\n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n\n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n\n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Supplier;\n\npublic class Main {\n  final static int INF = 1 << 28;\n  final static long LNF = 1L << 60;\n  final static long MOD = 1_000_000_007;\n  final static double EPS = 1e-9;\n  final static double GOLDEN_RATIO = (1.0 + Math.sqrt(5)) / 2.0;\n  Scanner sc = new Scanner(System.in);\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  int[][] ofs = {\n      {0, 1},\n      {1, 0},\n      {-1, 0},\n      {0, -1}\n  };\n\n  int[] map = new int[256];\n\n  boolean[][] done;\n  char[][] field;\n\n  int dfs(int x, int y) {\n    if (done[y][x]) {\n      return 0;\n    }\n    done[y][x] = true;\n    if (field[y][x] != '.') {\n      return map[field[y][x]];\n    }\n    int bits = 0;\n    for (int[] d : ofs) {\n      int nx = x + d[0];\n      int ny = y + d[1];\n      bits |= dfs(nx, ny);\n    }\n    return bits;\n  }\n\n  void run() {\n    map['B'] = 1;\n    map['W'] = 2;\n    map['X'] = 0;\n    for (; ; ) {\n      int h, w;\n      w = ni();\n      h = ni();\n      if (h == 0) {\n        break;\n      }\n      field = new char[h + 2][w + 2];\n      for (char[] a : field) Arrays.fill(a, 'X');\n      for (int i = 1; i <= h; ++i) {\n        String s = sc.next();\n        for (int j = 1; j <= w; ++j) {\n          field[i][j] = s.charAt(j - 1);\n        }\n      }\n      int[] ans = new int[4];\n      for (int i = 1; i <= h; ++i) {\n        for (int j = 1; j <= w; ++j) {\n          if (field[i][j] == '.') {\n            done = new boolean[h + 2][w + 2];\n            int bits = dfs(j, i);\n            ans[bits]++;\n          }\n        }\n      }\n      System.out.println(ans[1] + \" \" + ans[2]);\n    }\n  }\n\n  int ni() {\n    return Integer.parseInt(sc.next());\n  }\n\n  void debug(Object... os) {\n    System.err.println(Arrays.deepToString(os));\n  }\n\n  /**\n   * ??????????????????????????????\n   *\n   * @return a ?? b ??????????????\n   */\n  long gcd(long a, long b) {\n    if (b == 0) {\n      return a;\n    }\n    return gcd(b, a % b);\n  }\n\n  /**\n   * ????????????????????????????????????\n   *\n   * @return mx + ny = gcd(m, n)?????????????????(x, y)?????????\n   */\n  Pair<Long, Long> gcd_ex(long m, long n) {\n    long[][] mat = _gcd_ex(m, n);\n    return new Pair<>(mat[0][0], mat[0][1]);\n  }\n\n  long[][] _gcd_ex(long m, long n) {\n    if (n == 0) {\n      return new long[][]{{1, 0}, {0, 1}};\n    }\n    long k = m / n;\n    long[][] K = new long[][]{{0, 1}, {1, -k}};\n    long[][] r = _gcd_ex(n, m % n);\n    long[][] dst = new long[2][2];\n    for (int y = 0; y < 2; ++y)\n      for (int x = 0; x < 2; ++x)\n        for (int i = 0; i < 2; ++i)\n          dst[y][x] += r[y][i] * K[i][x];\n    return dst;\n  }\n\n  /**\n   * ???????????2??????????????????????????????????\n   *\n   * @return a^r (mod 1,000,000,007)\n   */\n  long pow(long a, long r) {\n    long sum = 1;\n    while (r > 0) {\n      if ((r & 1) == 1) {\n        sum *= a;\n        sum %= MOD;\n      }\n      a *= a;\n      a %= MOD;\n      r >>= 1;\n    }\n    return sum;\n  }\n\n  /**\n   * ???????????????\n   * O(n)\n   *\n   * @return {}_nC_r\n   */\n  long C(int n, int r) {\n    long sum = 1;\n    for (int i = n; 0 < i; --i) {\n      sum *= i;\n      sum %= MOD;\n    }\n    long s = 1;\n    for (int i = r; 0 < i; --i) {\n      s *= i;\n      s %= MOD;\n    }\n    sum *= pow(s, MOD - 2);\n    sum %= MOD;\n\n    long t = 1;\n    for (int i = n - r; 0 < i; --i) {\n      t *= i;\n      t %= MOD;\n    }\n    sum *= pow(t, MOD - 2);\n    sum %= MOD;\n\n    return sum;\n  }\n\n  /**\n   * ???????????????\n   *\n   * @param left  ??????\n   * @param right ??????\n   * @param f     ?????????????\n   * @param comp  ???????????????????????????????????????Comparator.comparingDouble(Double::doubleValue)\n   *              ???????????????????????????????????????Comparator.comparingDouble(Double::doubleValue).reversed()\n   * @return ?\\???????????x\n   */\n  double goldenSectionSearch(double left, double right, Function<Double, Double> f, Comparator<Double> comp) {\n    double c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n    double c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n    double d1 = f.apply(c1);\n    double d2 = f.apply(c2);\n    while (right - left > 1e-9) {\n      if (comp.compare(d1, d2) > 0) {\n        right = c2;\n        c2 = c1;\n        d2 = d1;\n        c1 = divideInternally(left, right, 1, GOLDEN_RATIO);\n        d1 = f.apply(c1);\n      } else {\n        left = c1;\n        c1 = c2;\n        d1 = d2;\n        c2 = divideInternally(left, right, GOLDEN_RATIO, 1);\n        d2 = f.apply(c2);\n      }\n    }\n    return right;\n  }\n\n  /**\n   * [a,b]???m:n???????????????????????????\n   */\n  double divideInternally(double a, double b, double m, double n) {\n    return (n * a + m * b) / (m + n);\n  }\n\n  /**\n   * http://alexbowe.com/popcount-permutations/\n   * bit???????????????????????????????????????????????????????????????????????\n   * ex)\n   * <pre>\n   * for (int i = 0; i < 25; ++i) {\n   *   int bits = (1 << i) - 1;\n   *   long m = C(25, num);\n   *   for (j = 0; j < m; ++j) {\n   *     ...(25???????????????i???bit?????????????????)\n   *     if (bits != 0)\n   *       bits = next_perm(bits);\n   *   }\n   * }\n   * </pre>\n   *\n   * @param v ????????bit???\n   * @return ?????bit???\n   */\n  int next_perm(int v) {\n    int t = (v | (v - 1)) + 1;\n    return t | ((((t & -t) / (v & -v)) >> 1) - 1);\n  }\n\n  static class Util {\n    static <T extends Comparable<T>> T max(T a, T b) {\n      if (a.compareTo(b) > 0) {\n        return a;\n      } else {\n        return b;\n      }\n    }\n\n    static <T extends Comparable<T>> T min(T a, T b) {\n      if (a.compareTo(b) < 0) {\n        return a;\n      } else {\n        return b;\n      }\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class Line {\n    double a;\n    double b;\n    double c;\n\n    /**\n     * ???????????????????????????????????????????????????\n     *\n     * @param a x????????\n     * @param b y????????\n     * @param c ????????\n     */\n    Line(double a, double b, double c) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n\n    /**\n     * 2???(x1, y1), (x2, y2)?????????????????????????????\n     *\n     * @param x1 1?????????x????\n     * @param y1 1?????????y????\n     * @param x2 2?????????x????\n     * @param y2 2?????????y????\n     * @return ?????\n     */\n    static Line fromPoints(double x1, double y1, double x2, double y2) {\n      double dx = x2 - x1;\n      double dy = y2 - y1;\n      return new Line(dy, -dx, dx * y1 - dy * x1);\n    }\n\n    /**\n     * ????????????????????????????????????????\n     *\n     * @param l ?????\n     * @return ?????????2?????????????????????????null\n     */\n    Point2D getIntersectionPoint(Line l) {\n      double d = a * l.b - l.a * b;\n      if (d == 0.0) {\n        return null;\n      }\n      double x = (b * l.c - l.b * c) / d;\n      double y = (l.a * c - a * l.c) / d;\n      return new Point2D.Double(x, y);\n    }\n\n    @Override\n    public String toString() {\n      return \"a = \" + a + \", b = \" + b + \", c = \" + c;\n    }\n  }\n\n  static class Line1D {\n    int x1;\n    int x2;\n\n    // [x1, x2) : ????????????\n    Line1D(int x1, int x2) {\n      this.x1 = x1;\n      this.x2 = x2;\n    }\n\n    boolean isCross(Line1D l) {\n      return isCross(l.x1, l.x2);\n    }\n\n    boolean isCross(int y1, int y2) {\n      boolean ret = x1 < y2 && y1 < x2;\n      assert ret == new LineSegment(x1, 0, x2, 0).intersects(new LineSegment(y1, 0, y2, 0));\n      return ret;\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static public class LineSegment {\n    double x1;\n    double y1;\n    double x2;\n    double y2;\n\n    LineSegment(double x1, double y1, double x2, double y2) {\n      this.x1 = x1;\n      this.y1 = y1;\n      this.x2 = x2;\n      this.y2 = y2;\n    }\n\n    Line toLine() {\n      return Line.fromPoints(x1, y1, x2, y2);\n    }\n\n    boolean intersects(Line l) {\n      double t1 = l.a * x1 + l.b * y1 + l.c;\n      double t2 = l.a * x2 + l.b * y2 + l.c;\n      return t1 * t2 <= 0;\n    }\n\n    boolean intersects(LineSegment s) {\n      return bothSides(s) && s.bothSides(this);\n    }\n\n    // s???????????????????????????????????????????????????????????\n    private boolean bothSides(LineSegment s) {\n      double ccw1 = GeomUtils.ccw(x1, y1, s.x1, s.y1, x2, y2);\n      double ccw2 = GeomUtils.ccw(x1, y1, s.x2, s.y2, x2, y2);\n      if (ccw1 == 0 && ccw2 == 0) { // s???????????????????????????????????????\n        // s???????????????1??????????????????????????????????????????????????s??????????????????????????????????????\n        // true?????????\n        return internal(s.x1, s.y1) || internal(s.x2, s.y2);\n      } else { // ????????\\???????????\n        // CCW??????????????????????????????true?????????\n        return ccw1 * ccw2 <= 0;\n      }\n    }\n\n    // (x, y)?????????????????????????????????????????????????????????\n    private boolean internal(double x, double y) {\n      // (x, y)????????????????????????????????????????????????????????\\??????????????????????????????\n      return GeomUtils.dot(x1 - x, y1 - y, x2 - x, y2 - y) <= 0;\n    }\n\n    public Point2D getIntersectionPoint(Line l) {\n      if (!intersects(l)) {\n        return null; // ???????????????????????null?????????\n      }\n      return l.getIntersectionPoint(toLine());\n    }\n\n    public Point2D getIntersectionPoint(LineSegment s) {\n      if (!intersects(s)) {\n        return null; // ???????????????????????null?????????\n      }\n      return s.toLine().getIntersectionPoint(toLine());\n    }\n\n    /**\n     * from : http://www.deqnotes.net/acmicpc/2d_geometry/lines#distance_between_line_segment_and_point\n     */\n    double distance(double x0, double y0) {\n      // ?????????????????\n      if (GeomUtils.dot(x2 - x1, y2 - y1, x0 - x1, y0 - y1) < EPS) {\n        return GeomUtils.abs(x0 - x1, y0 - y1);\n      }\n      if (GeomUtils.dot(x1 - x2, y1 - y2, x0 - x2, y0 - y2) < EPS) {\n        return GeomUtils.abs(x0 - x2, y0 - y2);\n      }\n      // ??????????????????\n      return Math.abs(GeomUtils.cross(x2 - x1, y2 - y1, x0 - x1, y0 - y1)) / GeomUtils.abs(x2 - x1, y2 - y1);\n    }\n\n    double distance(LineSegment l) {\n      if (this.intersects(l)) {\n        return 0.0;\n      }\n      double min = Double.MAX_VALUE;\n      min = Math.min(min, distance(l.x1, l.y1));\n      min = Math.min(min, distance(l.x2, l.y2));\n      min = Math.min(min, l.distance(x1, y1));\n      min = Math.min(min, l.distance(x2, y2));\n      return min;\n    }\n\n    @Override\n    public String toString() {\n      return \"(\" + x1 + \", \" + y1 + \") - (\" + x2 + \", \" + y2 + \")\";\n    }\n  }\n\n  /**\n   * from http://gihyo.jp/dev/serial/01/geometry part 6\n   */\n  static class GeomUtils {\n    // ??????\n    static double cross(double x1, double y1, double x2, double y2) {\n      return x1 * y2 - x2 * y1;\n    }\n\n    // ??????\n    static double dot(double x1, double y1, double x2, double y2) {\n      return x1 * x2 + y1 * y2;\n    }\n\n    // (x1, y1) -> (x2, y2) -> (x3, y3) ????????????????????????????????????????????????????????\n    // ???????????????????????????????????????????????????????????????????????\n    static double ccw(double x1, double y1, double x2, double y2,\n                      double x3, double y3) {\n      return cross(x2 - x1, y2 - y1, x3 - x2, y3 - y2);\n    }\n\n    static double ccw(Point2D p1, Point2D p2, Point2D p3) {\n      return ccw(p1.getX(), p1.getY(), p2.getX(), p2.getY(), p3.getX(), p3.getY());\n    }\n\n    // ?????????????????????\n    static double abs(double x, double y) {\n      return Math.sqrt(x * x + y * y);\n    }\n\n    // ??????????????????????\n    // http://www.nttpc.co.jp/technology/number_algorithm.html\n    boolean isIn(ArrayList<LineSegment> list, double x, double y) {\n      int wn = 0;\n      for (LineSegment l : list) {\n        if (l.y1 <= y && l.y2 > y) {\n          double vt = (y - l.y1) / (l.y2 - l.y1);\n          if (x < l.x1 + (vt * (l.x2 - l.x1))) {\n            ++wn;\n          }\n        }\n        if (l.y1 > y && l.y2 <= y) {\n          double vt = (y - l.y1) / (l.y2 - l.y1);\n          if (x < (l.x1 + (vt * (l.x2 - l.x1)))) {\n            --wn;\n          }\n        }\n      }\n      return wn > 0;\n    }\n  }\n\n  /**\n   * http://qiita.com/p_shiki37/items/65c18f88f4d24b2c528b\n   */\n  static class FastScanner {\n    private final InputStream in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public FastScanner(InputStream in) {\n      this.in = in;\n    }\n\n    private static boolean isPrintableChar(int c) {\n      return 33 <= c && c <= 126;\n    }\n\n    private boolean hasNextByte() {\n      if (ptr < buflen) {\n        return true;\n      } else {\n        ptr = 0;\n        try {\n          buflen = in.read(buffer);\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n        if (buflen <= 0) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    private int readByte() {\n      if (hasNextByte()) return buffer[ptr++];\n      else return -1;\n    }\n\n    private void skipUnprintable() {\n      while (hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;\n    }\n\n    public boolean hasNext() {\n      skipUnprintable();\n      return hasNextByte();\n    }\n\n    public String next() {\n      if (!hasNext()) throw new NoSuchElementException();\n      StringBuilder sb = new StringBuilder();\n      int b = readByte();\n      while (isPrintableChar(b)) {\n        sb.appendCodePoint(b);\n        b = readByte();\n      }\n      return sb.toString();\n    }\n\n    public long nextLong() {\n      if (!hasNext()) throw new NoSuchElementException();\n      long n = 0;\n      boolean minus = false;\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n        b = readByte();\n      }\n      if (b < '0' || '9' < b) {\n        throw new NumberFormatException();\n      }\n      while (true) {\n        if ('0' <= b && b <= '9') {\n          n *= 10;\n          n += b - '0';\n        } else if (b == -1 || !isPrintableChar(b)) {\n          return minus ? -n : n;\n        } else {\n          throw new NumberFormatException();\n        }\n        b = readByte();\n      }\n    }\n  }\n\n  static class Pair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<Pair<F, S>> {\n    F f;\n    S s;\n\n    Pair() {\n    }\n\n    Pair(F f, S s) {\n      this.f = f;\n      this.s = s;\n    }\n\n    Pair(Pair<F, S> p) {\n      f = p.f;\n      s = p.s;\n    }\n\n    @Override\n    public int compareTo(Pair<F, S> p) {\n      if (f.compareTo(p.f) != 0) {\n        return f.compareTo(p.f);\n      }\n      return s.compareTo(p.s);\n    }\n\n    @Override\n    public int hashCode() {\n      return f.hashCode() ^ s.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null || this.f == null || this.s == null) {\n        return false;\n      }\n      if (this.getClass() != o.getClass()) {\n        return false;\n      }\n      Pair p = (Pair) o;\n      return this.f.equals(p.f) && this.s.equals(p.s);\n    }\n\n    @Override\n    public String toString() {\n      return \"{\" + f.toString() + \", \" + s.toString() + \"}\";\n    }\n  }\n\n  class BIT<T> {\n    int n;\n    ArrayList<T> bit;\n    BiFunction<T, T, T> bif;\n\n    /**\n     * 1-indexed ???Binary Indexed Tree??????????????\n     *\n     * @param n   ??????\n     * @param bif ??????????????????\n     * @param sup ?????????\n     */\n    BIT(int n, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      this.n = n;\n      bit = new ArrayList<>(n + 1);\n      for (int i = 0; i < n + 1; ++i) {\n        bit.add(sup.get());\n      }\n      this.bif = bif;\n    }\n\n    /**\n     * i??????????????????v????????????\n     *\n     * @param i index\n     * @param v ???????????\n     */\n    void set(int i, T v) {\n      for (int x = i; x <= n; x += x & -x) {\n        bit.set(x, bif.apply(bit.get(x), v));\n      }\n    }\n\n    /**\n     * ???????????\n     *\n     * @param defaultValue ?????????\n     * @param i            index\n     * @return [1, i]?????f????????????????????\n     */\n    T reduce(T defaultValue, int i) {\n      T ret = defaultValue;\n      for (int x = i; x > 0; x -= x & -x) {\n        ret = bif.apply(ret, bit.get(x));\n      }\n      return ret;\n    }\n  }\n\n  class SegmentTree<T> {\n    int n;\n    ArrayList<T> dat;\n    BiFunction<T, T, T> bif;\n    Supplier<T> sup;\n\n    /**\n     * 0-indexed ???Segment Tree??????????????\n     *\n     * @param n_  ???????????\n     * @param bif ??????????????????\n     * @param sup ?????????\n     */\n    SegmentTree(int n_, BiFunction<T, T, T> bif, Supplier<T> sup) {\n      n = 1;\n      while (n < n_) n *= 2;\n\n      dat = new ArrayList<>(2 * n - 1);\n      for (int i = 0; i < 2 * n - 1; ++i) {\n        dat.add(sup.get());\n      }\n      this.bif = bif;\n      this.sup = sup;\n    }\n\n    /**\n     * k??????????????????v????????????\n     *\n     * @param k index\n     * @param v ???????????\n     */\n    void set(int k, T v) {\n      k += n - 1;\n      dat.set(k, v);\n      while (k > 0) {\n        k = (k - 1) / 2;\n        dat.set(k, bif.apply(dat.get(k * 2 + 1), dat.get(k * 2 + 2)));\n      }\n    }\n\n    /**\n     * ???????????\n     *\n     * @param l ?????????\n     * @param r ?????????\n     * @return [l, r)???????????bif?????????????????????????????\n     */\n    T reduce(int l, int r) {\n      return _reduce(l, r, 0, 0, n);\n    }\n\n    T _reduce(int a, int b, int k, int l, int r) {\n      if (r <= a || b <= l) return sup.get();\n      if (a <= l && r <= b) return dat.get(k);\n      T vl = _reduce(a, b, k * 2 + 1, l, (l + r) / 2);\n      T vr = _reduce(a, b, k * 2 + 2, (l + r) / 2, r);\n      return bif.apply(vl, vr);\n    }\n  }\n\n  class UnionFind {\n    int[] par;\n\n    UnionFind(int n) {\n      par = new int[n];\n      for (int i = 0; i < n; ++i) {\n        par[i] = i;\n      }\n    }\n\n    int find(int x) {\n      if (par[x] == x) {\n        return x;\n      }\n      return par[x] = find(par[x]);\n    }\n\n    boolean same(int x, int y) {\n      return find(x) == find(y);\n    }\n\n    void union(int x, int y) {\n      x = find(x);\n      y = find(y);\n      if (x == y) {\n        return;\n      }\n      par[x] = y;\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main{\n    public static void main(String[] args){\n\tnew Main().run();\n    }\n    Scanner sc = new Scanner(System.in);\n\n    char[][] map;\n    char[][] round; // \"\":, B:? W:, x:?????n:\n    int w, h;\n    int B, W;\n\n\n    void run(){\n\twhile(sc.hasNext()){\n\t    w = sc.nextInt();\n\t    h = sc.nextInt();\n\t    if(w==0 && h==0) break;\n\t    \n\t    map = new char[h][w];\n\t    round = new char[h][w];\n\t    \n\t    for(int i=0; i<h; i++){\n\t\tString s = sc.next();\n\t\tArrays.fill(round[i], 'o');\n\t\tfor(int k=0; k<w; k++)\n\t\t    map[i] = s.toCharArray();\n\t    }\n\t    \n\t    for(int i=0; i<h; i++)\n\t\tfor(int k=0; k<w; k++){\n\t\t    solve(i, k, map[i][k]);\n\t\t}\n\t    \n\t    count();\n\t    //show();\n\t    System.out.println(B+\" \"+W);\n\t}\n    }\n\n    void solve(int a, int b, char c){\n\tif(a<0 || a>=h || b<0 || b>=w) return;\n\tif(round[a][b]=='x' || round[a][b]=='n' || c=='.') return;\n\t\n\tif(map[a][b]=='B' || map[a][b]=='W'){\n\t    c = map[a][b];\n\t    round[a][b] = 'n';\n\t    solve(a+1, b, c);\n\t    solve(a-1, b, c);\n\t    solve(a, b+1, c);\n\t    solve(a, b-1, c);\n\t}\n\telse if(round[a][b]=='o'){\n\t    round[a][b] = c;\n\t    solve(a+1, b, c);\n\t    solve(a-1, b, c);\n\t    solve(a, b+1, c);\n\t    solve(a, b-1, c);\n\t}\n\telse if( (round[a][b]=='B' && c=='W') || (round[a][b]=='W' && c=='B')){\n\t    round[a][b] = 'x';\n\t    solve(a+1, b, c);\n\t    solve(a-1, b, c);\n\t    solve(a, b+1, c);\n\t    solve(a, b-1, c);\n\t}\n    }\n\n    void count(){\n\tB = 0;\n\tW = 0;\n\tfor(int i=0; i<h; i++)\n\t    for(int k=0; k<w; k++)\n\t\tif(round[i][k]=='B') B++;\n\t\telse if(round[i][k]=='W') W++;\n    }\n\n    void show(){\n\tfor(int i=0; i<h; i++){\n\t    for(int k=0; k<w; k++)\n\t\tSystem.out.print(round[i][k]+\" \");\n\t    System.out.println();\n\t}\n\tSystem.out.println(\"-------------------\");\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tFastScanner in = new FastScanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\n\tboolean black, white;\n\tchar[][] map;\n\tboolean[][] visited;\n\n\tint[] vx = {-1, 0, 0, 1};\n\tint[] vy = {0, -1, 1, 0};\n\t\n\tint dfs(int x, int y) {\n\t\tif (visited[y][x]) return 0;\n\t\tif (map[y][x] == 'B') {\n\t\t\tblack = true;\n\t\t\treturn 0;\n\t\t} else if (map[y][x] == 'W') {\n\t\t\twhite = true;\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\tvisited[y][x] = true;\n\t\tint res = 1;\n\t\t\n\t\tfor (int d = 0; d < vx.length; d++) {\n\t\t\tint nx = x + vx[d], ny = y + vy[d];\n\t\t\tif (nx >= 0 && nx < map[0].length && ny >= 0 && ny < map.length) {\n\t\t\t\tres += dfs(nx, ny);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tpublic void run() {\n\t\t\n\t\twhile (true) {\n\t\t\tint m = in.nextInt(), n = in.nextInt();\n\t\t\tif (n == 0) break;\n\t\t\n\t\t\tmap = new char[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.next().toCharArray();\n\t\t\t}\n\t\t\t\n\t\t\tint wres = 0, bres = 0;\n\t\t\tvisited = new boolean[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\t\tif (!visited[i][j])\t{\n\t\t\t\t\t\twhite = false;\n\t\t\t\t\t\tblack = false;\n\t\t\t\t\t\tint cnt = dfs(j, i);\n\t\t\t\t\t\tif (white && !black) wres += cnt;\n\t\t\t\t\t\tif (!white && black) bres += cnt;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(bres + \" \" + wres);\n\t\t}\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main{\n    public static void main(String[] args){\n\tnew Main().run();\n    }\n    Scanner sc = new Scanner(System.in);\n\n    char[][] map;\n    int[][] round; // 0:, 1:, 2:, -1: -2:\n    int w, h;\n    int B, W;\n\n\n    void run(){\n\twhile(sc.hasNext()){\n\t    w = sc.nextInt();\n\t    h = sc.nextInt();\n\t    if(w==0 && h==0) break;\n\t    \n\t    map = new char[h][w];\n\t    round = new int[h][w];\n\t    \n\t    for(int i=0; i<h; i++){\n\t\tString s = sc.next();\n\t\tfor(int k=0; k<w; k++)\n\t\t    map[i] = s.toCharArray();\n\t    }\n\t    \n\t    for(int i=0; i<h; i++)\n\t\tfor(int k=0; k<w; k++)\n\t\t    solve(0, 0, map[i][k]);\n\t    \n\t    count();\n\t    //show();\n\t    System.out.println(B+\" \"+W);\n\t}\n    }\n\n    void solve(int a, int b, char c){\n\tif(a<0 || a>=h || b<0 || b>=w) return;\n\tif(round[a][b]==-1 || round[a][b]==-2 || c=='.') return;\n\t\n\tif(map[a][b]=='B' || map[a][b]=='W'){\n\t    c = map[a][b];\n\t    round[a][b] = -2;\n\t    solve(a+1, b, c);\n\t    solve(a-1, b, c);\n\t    solve(a, b+1, c);\n\t    solve(a, b-1, c);\n\t}\n\telse if(round[a][b]==0){\n\t    round[a][b] = c=='B' ? 1 : 2;\n\t    solve(a+1, b, c);\n\t    solve(a-1, b, c);\n\t    solve(a, b+1, c);\n\t    solve(a, b-1, c);\n\t}\n\telse if( (round[a][b]==1 && c=='W') || (round[a][b]==2 && c=='B')){\n\t    round[a][b] = -1;\n\t    solve(a+1, b, c);\n\t    solve(a-1, b, c);\n\t    solve(a, b+1, c);\n\t    solve(a, b-1, c);\n\t}\n    }\n\n    void count(){\n\tB = 0;\n\tW = 0;\n\tfor(int i=0; i<h; i++)\n\t    for(int k=0; k<w; k++)\n\t\tif(round[i][k]==1) B++;\n\t\telse if(round[i][k]==2) W++;\n    }\n\n    void show(){\n\tfor(int i=0; i<h; i++){\n\t    for(int k=0; k<w; k++)\n\t\tSystem.out.print(round[i][k]+\" \");\n\t    System.out.println();\n\t}\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile (true) {\n\t\t\tfinal int w = sc.nextInt();\n\t\t\tfinal int h = sc.nextInt();\n\n\t\t\tif (w == 0 && h == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint[][] map = new int[h][w];\n\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tchar[] input = sc.next().toCharArray();\n\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tif (input[j] == 'W') {\n\t\t\t\t\t\tmap[i][j] = 1;\n\t\t\t\t\t} else if (input[j] == 'B') {\n\t\t\t\t\t\tmap[i][j] = -1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmap[i][j] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint[][] w_dist = new int[h][w];\n\t\t\tint[][] b_dist = new int[h][w];\n\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tw_dist[i][j] = Integer.MAX_VALUE;\n\t\t\t\t\tb_dist[i][j] = Integer.MAX_VALUE;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\twhile(true){\n\t\t\t\tboolean updated = false;\n\t\t\t\t\n\t\t\t\t// w-forward\n\t\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\t\tif (map[i][j] == -1) {\n\t\t\t\t\t\t\tw_dist[i][j] = Integer.MAX_VALUE;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t} else if (map[i][j] == 1) {\n\t\t\t\t\t\t\tw_dist[i][j] = 0;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tint cur = w_dist[i][j];\n\n\t\t\t\t\t\tif (i == 0 && j == 0) {\n\t\t\t\t\t\t\tw_dist[i][j] = Math.min(Integer.MAX_VALUE, w_dist[i][j]);\n\t\t\t\t\t\t} else if (i == 0) {\n\t\t\t\t\t\t\tif (w_dist[i][j - 1] != Integer.MAX_VALUE) {\n\t\t\t\t\t\t\t\tw_dist[i][j] = Math.min(w_dist[i][j - 1] + 1, w_dist[i][j]);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tw_dist[i][j] = Math.min(w_dist[i][j - 1], w_dist[i][j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (j == 0) {\n\t\t\t\t\t\t\tif (w_dist[i - 1][j] != Integer.MAX_VALUE) {\n\t\t\t\t\t\t\t\tw_dist[i][j] = Math.min(w_dist[i - 1][j] + 1, w_dist[i][j]);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tw_dist[i][j] = Math.min(w_dist[i - 1][j], w_dist[i][j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfinal int min = Math.min(w_dist[i - 1][j],\n\t\t\t\t\t\t\t\t\tw_dist[i][j - 1]);\n\t\t\t\t\t\t\tif (min != Integer.MAX_VALUE) {\n\t\t\t\t\t\t\t\tw_dist[i][j] = Math.min(min + 1, w_dist[i][j]);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tw_dist[i][j] = Math.min(min, w_dist[i][j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(w_dist[i][j] != cur){\n\t\t\t\t\t\t\tupdated = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// w-back\n\t\t\t\tfor (int i = h - 1; i >= 0; i--) {\n\t\t\t\t\tfor (int j = w - 1; j >= 0; j--) {\n\t\t\t\t\t\tif (map[i][j] == -1) {\n\t\t\t\t\t\t\tw_dist[i][j] = Integer.MAX_VALUE;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t} else if (map[i][j] == 1) {\n\t\t\t\t\t\t\tw_dist[i][j] = 0;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tint cur = w_dist[i][j];\n\n\t\t\t\t\t\tif (i == h - 1 && j == w - 1) {\n\t\t\t\t\t\t\tw_dist[i][j] = Math.min(Integer.MAX_VALUE,\n\t\t\t\t\t\t\t\t\tw_dist[i][j]);\n\t\t\t\t\t\t} else if (i == h - 1) {\n\t\t\t\t\t\t\tif (w_dist[i][j + 1] != Integer.MAX_VALUE) {\n\t\t\t\t\t\t\t\tw_dist[i][j] = Math.min(w_dist[i][j + 1] + 1,\n\t\t\t\t\t\t\t\t\t\tw_dist[i][j]);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tw_dist[i][j] = Math.min(w_dist[i][j + 1],\n\t\t\t\t\t\t\t\t\t\tw_dist[i][j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (j == w - 1) {\n\t\t\t\t\t\t\tif (w_dist[i + 1][j] != Integer.MAX_VALUE) {\n\t\t\t\t\t\t\t\tw_dist[i][j] = Math.min(w_dist[i + 1][j] + 1,\n\t\t\t\t\t\t\t\t\t\tw_dist[i][j]);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tw_dist[i][j] = Math.min(w_dist[i + 1][j],\n\t\t\t\t\t\t\t\t\t\tw_dist[i][j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfinal int min = Math.min(w_dist[i + 1][j],\n\t\t\t\t\t\t\t\t\tw_dist[i][j + 1]);\n\t\t\t\t\t\t\tif (min != Integer.MAX_VALUE) {\n\t\t\t\t\t\t\t\tw_dist[i][j] = Math.min(min + 1, w_dist[i][j]);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tw_dist[i][j] = Math.min(min, w_dist[i][j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(w_dist[i][j] != cur){\n\t\t\t\t\t\t\tupdated = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// b-forward\n\t\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\t\tif (map[i][j] == 1) {\n\t\t\t\t\t\t\tb_dist[i][j] = Integer.MAX_VALUE;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t} else if (map[i][j] == -1) {\n\t\t\t\t\t\t\tb_dist[i][j] = 0;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tint cur = b_dist[i][j];\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (i == 0 && j == 0) {\n\t\t\t\t\t\t\tb_dist[i][j] = Math.min(Integer.MAX_VALUE, b_dist[i][j]);\n\t\t\t\t\t\t} else if (i == 0) {\n\t\t\t\t\t\t\tif (b_dist[i][j - 1] != Integer.MAX_VALUE) {\n\t\t\t\t\t\t\t\tb_dist[i][j] = Math.min(b_dist[i][j - 1] + 1, b_dist[i][j]);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tb_dist[i][j] = Math.min(b_dist[i][j - 1], b_dist[i][j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (j == 0) {\n\t\t\t\t\t\t\tif (b_dist[i - 1][j] != Integer.MAX_VALUE) {\n\t\t\t\t\t\t\t\tb_dist[i][j] = Math.min(b_dist[i - 1][j] + 1, b_dist[i][j]);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tb_dist[i][j] = Math.min(b_dist[i - 1][j], b_dist[i][j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfinal int min = Math.min(b_dist[i - 1][j],\n\t\t\t\t\t\t\t\t\tb_dist[i][j - 1]);\n\t\t\t\t\t\t\tif (min != Integer.MAX_VALUE) {\n\t\t\t\t\t\t\t\tb_dist[i][j] = Math.min(min + 1, b_dist[i][j]);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tb_dist[i][j] = Math.min(min, b_dist[i][j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(b_dist[i][j] != cur){\n\t\t\t\t\t\t\tupdated = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// b-back\n\t\t\t\tfor (int i = h - 1; i >= 0; i--) {\n\t\t\t\t\tfor (int j = w - 1; j >= 0; j--) {\n\t\t\t\t\t\tif (map[i][j] == 1) {\n\t\t\t\t\t\t\tb_dist[i][j] = Integer.MAX_VALUE;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t} else if (map[i][j] == -1) {\n\t\t\t\t\t\t\tb_dist[i][j] = 0;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tint cur = b_dist[i][j];\n\n\t\t\t\t\t\tif (i == h - 1 && j == w - 1) {\n\t\t\t\t\t\t\tb_dist[i][j] = Math.min(Integer.MAX_VALUE,\n\t\t\t\t\t\t\t\t\tb_dist[i][j]);\n\t\t\t\t\t\t} else if (i == h - 1) {\n\t\t\t\t\t\t\tif (b_dist[i][j + 1] != Integer.MAX_VALUE) {\n\t\t\t\t\t\t\t\tb_dist[i][j] = Math.min(b_dist[i][j + 1] + 1,\n\t\t\t\t\t\t\t\t\t\tb_dist[i][j]);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tb_dist[i][j] = Math.min(b_dist[i][j + 1],\n\t\t\t\t\t\t\t\t\t\tb_dist[i][j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (j == w - 1) {\n\t\t\t\t\t\t\tif (b_dist[i + 1][j] != Integer.MAX_VALUE) {\n\t\t\t\t\t\t\t\tb_dist[i][j] = Math.min(b_dist[i + 1][j] + 1,\n\t\t\t\t\t\t\t\t\t\tb_dist[i][j]);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tb_dist[i][j] = Math.min(b_dist[i + 1][j],\n\t\t\t\t\t\t\t\t\t\tb_dist[i][j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfinal int min = Math.min(b_dist[i + 1][j],\n\t\t\t\t\t\t\t\t\tb_dist[i][j + 1]);\n\t\t\t\t\t\t\tif (min != Integer.MAX_VALUE) {\n\t\t\t\t\t\t\t\tb_dist[i][j] = Math.min(min + 1, b_dist[i][j]);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tb_dist[i][j] = Math.min(min, b_dist[i][j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(b_dist[i][j] != cur){\n\t\t\t\t\t\t\tupdated = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(!updated){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint b_count = 0;\n\t\t\tint w_count = 0;\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tfinal int w_d = w_dist[i][j] == Integer.MAX_VALUE ? Integer.MIN_VALUE\n\t\t\t\t\t\t\t: w_dist[i][j];\n\t\t\t\t\tfinal int b_d = b_dist[i][j] == Integer.MAX_VALUE ? Integer.MIN_VALUE\n\t\t\t\t\t\t\t: b_dist[i][j];\n\n\t\t\t\t\tif (w_d > 0 && b_d > 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else if (w_d > 0) {\n\t\t\t\t\t\tw_count++;\n\t\t\t\t\t} else if (b_d > 0) {\n\t\t\t\t\t\tb_count++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(b_count + \" \" + w_count);\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint[] dir = { -1, 1 };\n\t\twhile (true) {\n\t\t\tint width = scanner.nextInt();// \n\t\t\tif (width == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint height = scanner.nextInt();\n\t\t\tint[][] field = new int[height][width];\n\t\t\tfor (int i = 0; i < field.length; i++) {\n\t\t\t\t/*\n\t\t\t\t * 0 1 2 3\n\t\t\t\t */\n\t\t\t\tString line = scanner.next();\n\t\t\t\tfor (int j = 0; j < field[i].length; j++) {\n\t\t\t\t\tchar letter = line.charAt(j);\n\t\t\t\t\tif (letter == 'B') {\n\t\t\t\t\t\tfield[i][j] = 2;\n\t\t\t\t\t} else if (letter == 'W') {\n\t\t\t\t\t\tfield[i][j] = 3;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint black = 0, white = 0;\n\t\t\tDeque<Integer[]> deque = new ArrayDeque<Integer[]>();\n\t\t\tfor (int i = 0; i < field.length; i++) {\n\t\t\t\tfor (int j = 0; j < field[i].length; j++) {\n\t\t\t\t\tif (field[i][j] == 0) {\n\t\t\t\t\t\tInteger[] push = { i, j };\n\t\t\t\t\t\tfield[i][j] = 1;\n\t\t\t\t\t\tdeque.add(push);\n\t\t\t\t\t}\n\t\t\t\t\tint sum = 0;\n\t\t\t\t\tboolean is_black = false, is_white = false;\n\t\t\t\t\twhile (deque.size() > 0) {\n\t\t\t\t\t\tInteger[] poll = deque.poll();\n\t\t\t\t\t\tsum++;\n\t\t\t\t\t\tfor (int k = 0; k < dir.length; k++) {\n\t\t\t\t\t\t\tif (poll[0] + dir[k] >= 0\n\t\t\t\t\t\t\t\t\t&& poll[0] + dir[k] < field.length) {\n\t\t\t\t\t\t\t\tswitch (field[poll[0] + dir[k]][poll[1]]) {\n\t\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\t\tInteger[] push = { poll[0] + dir[k],\n\t\t\t\t\t\t\t\t\t\t\tpoll[1] };\n\t\t\t\t\t\t\t\t\tfield[poll[0] + dir[k]][poll[1]] = 1;\n\t\t\t\t\t\t\t\t\tdeque.add(push);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\t\tis_black = true;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t\t\tis_white = true;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (poll[1] + dir[k] >= 0\n\t\t\t\t\t\t\t\t\t&& poll[1] + dir[k] < field[0].length) {\n\t\t\t\t\t\t\t\tswitch (field[poll[0]][poll[1] + dir[k]]) {\n\t\t\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\t\t\tInteger[] push = { poll[0],\n\t\t\t\t\t\t\t\t\t\t\tpoll[1] + dir[k] };\n\t\t\t\t\t\t\t\t\tfield[poll[0]][poll[1] + dir[k]] = 1;\n\t\t\t\t\t\t\t\t\tdeque.add(push);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\t\t\tis_black = true;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t\t\tis_white = true;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (is_black && !is_white) {\n\t\t\t\t\t\tblack += sum;\n\t\t\t\t\t} else if (is_white && !is_black) {\n\t\t\t\t\t\twhite += sum;\n\t\t\t\t\t}\n\n\t\t\t\t\t// for (int k = 0; k < field.length; k++) {\n\t\t\t\t\t// for (int k2 = 0; k2 < field[k].length; k2++) {\n\t\t\t\t\t// System.out.print(field[k][k2]);\n\t\t\t\t\t// }\n\t\t\t\t\t// System.out.println();\n\t\t\t\t\t// }\n\t\t\t\t\t// System.out.println();\n\t\t\t\t\t// System.out.println(black + \" \" + white);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(black + \" \" + white);\n\t\t}\n\t}\n\n\tstatic int nextInt() {\n\t\tint c;\n\t\ttry {\n\t\t\tc = System.in.read();\n\t\t\twhile (c != '-' && (c < '0' || c > '9'))\n\t\t\t\tc = System.in.read();\n\t\t\tif (c == '-')\n\t\t\t\treturn -nextInt();\n\t\t\tint res = 0;\n\t\t\twhile (c >= '0' && c <= '9') {\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = System.in.read();\n\t\t\t}\n\t\t\treturn res;\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic char nextChar() {\n\t\ttry {\n\t\t\tint b = System.in.read();\n\t\t\twhile (b != -1 && (b == ' ' || b == '\\r' || b == '\\n'))\n\t\t\t\t;\n\t\t\tif (b == -1)\n\t\t\t\treturn 0;\n\t\t\treturn (char) b;\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn 0;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n    int h,w;\n    char[][] grid;\n    Boolean B,W;\n    int countB,countW;\n    int[] dx = {1,-1,0,0};\n    int[] dy = {0,0,1,-1};\n    char from,to;\n    int countGrid;\n\n    void solve(){\n\tScanner sc = new Scanner(System.in);\n\tw = sc.nextInt();\n\twhile(w!=0){\n\t    h = sc.nextInt();\n\t    grid = new char[h][w];\n\t    for(int i=0; i<h; i++){\n\t\tString line = sc.next();\n\t\tgrid[i] = line.toCharArray();\n\t    }\n\n\t    countB = 0;\n\t    countW = 0;\n\t    for(int i=0; i<h; i++){\n\t\tfor(int j=0; j<w; j++){\n\t\t    if(grid[i][j]=='.'){\n\t\t\tB = false;\n\t\t\tW = false;\n\t\t\tcountGrid = 0;\n\t\t\tdfs(j,i);\n\t\t\tif(B&&!W)countB+=countGrid;\n\t\t\tif(!B&&W)countW+=countGrid;\n\t\t    }\n\t\t}\n\t    }\n\n\t    System.out.println(countB+\" \"+countW);\n\n\t    w = sc.nextInt();\n\t}\n    }\n\n    void dfs(int x, int y){\n\tgrid[y][x] = 'x';\n\tcountGrid++;\n\tfor(int i=0; i<4; i++){\n\t    int nx = x+dx[i];\n\t    int ny = y+dy[i];\n\t    if(nx<w && nx>=0 && ny<h && ny>=0){\n\t\tif(grid[ny][nx]=='B')B = true;\n\t\telse if(grid[ny][nx]=='W')W = true;\n\t\telse if(grid[ny][nx]=='.'){\n\t\t    dfs(nx,ny);\n\t\t}\n\t    }\n\t}\n    }\n    \n    public static void main(String[] args){\n\tnew Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.Scanner;\n\npublic class Main{\n\tint nx;\n\tint ny;\n\tint[] dx = {0,-1,0,1};\n\tint[] dy = {1,0,-1,0};\n\tchar[][] map;\n\tboolean flagW ;\n\tboolean flagB ;\n\tint res = 0;\n\n\n\tvoid dfs(int y, int x){\n\t\tint sx;\n\t\tint sy;\n\t\tmap[y][x] = 'X';\n\n\t\tfor(int i=0; i<4; i++){\n\t\t\tsy = y + dy[i];\n\t\t\tsx = x + dx[i];\n\t\t\tif(sx < 0 || sy <0 || sx >= nx || sy >= ny) continue;\n\n\t\t\tif(map[sy][sx] == '.'){\n\t\t\t\tres++;\n\t\t\t\tdfs(sy,sx);\n\t\t\t}\n\t\t\telse if(map[sy][sx] == 'W')\n\t\t\t\tflagW = true;\n\n\t\t\telse if(map[sy][sx] == 'B')\n\t\t\t\tflagB = true;\n\t\t}\n\n\t}\n\n\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\n\n\t\twhile (sc.hasNext()) {\n\t\t\tnx = sc.nextInt();\n\t\t\tny = sc.nextInt();\n\t\t\tString p = sc.nextLine();\n\n\t\t\tint cntW = 0;\n\t\t\tint cntB = 0;\n\t\t\tmap = new char[ny][];\n\n\n\t\t\tfor (int i = 0; i < ny; i++) {\n\t\t\t\tString s = sc.nextLine();\n\t\t\t\tmap[i] = s.toCharArray();\n\t\t\t}\n\n\n\n\t\t\tfor (int i = 0; i < ny; i++) {\n\t\t\t\tfor (int j = 0; j < nx; j++) {\n\t\t\t\t\tif (map[i][j] != '.')\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tflagW = false;\n\t\t\t\t\tflagB = false;\n\t\t\t\t\tres = 1;\n\n\t\t\t\t\tdfs(i, j);\n\n\t\t\t\t\tif (flagW && !flagB)\n\t\t\t\t\t\tcntW += res;\n\t\t\t\t\tif (flagB && !flagW)\n\t\t\t\t\t\tcntB += res;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(cntB + \" \" + cntW);\n\t\t}\n\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew A3().run();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\n\tint w, h, count, cb, cw;\n\tint[][] map;\n\tboolean black, white;\n\t\n\tpublic void func(){\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(map[i][j]==0){\n\t\t\t\t\tcount = 0;\n\t\t\t\t\tblack = true;\n\t\t\t\t\twhite = true;\n\t\t\t\t\tloop(i, j);\n\t\t\t\t\tif(black==false && white==true){\n\t\t\t\t\t\tcb += count;\n\t\t\t\t\t}else if(black==true && white==false){\n\t\t\t\t\t\tcw += count;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(cb + \" \" + cw);\n\t}\n\t\n\tpublic void loop(int y, int x){\n\t\tif(map[y][x]==8){\n\t\t\tblack = false;\n\t\t}else if(map[y][x]==9){\n\t\t\twhite = false;\n\t\t}else if(map[y][x]==0){\n\t\t\tmap[y][x] = 1;\n\t\t\tcount++;\n\t\t\tif(y!=0) loop(y-1,x);\n\t\t\tif(x!=0) loop(y,x-1);\n\t\t\tif(y!=h-1) loop(y+1,x);\n\t\t\tif(x!=w-1) loop(y,x+1);\n\t\t}\n\t}\n\t\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tMain A = new Main();\n\t\t\tA.w = sc.nextInt();\n\t\t\tA.h = sc.nextInt();\n\t\t\tif(A.w==0 && A.h==0)break;\n\t\t\tA.map = new int[A.h][A.w];\n\t\t\tString s = \"\";\n\t\t\tfor(int i=0;i<A.h;i++){\n\t\t\t\ts = sc.next();\n\t\t\t\tfor(int j=0;j<A.w;j++){\n\t\t\t\t\tif(s.codePointAt(j)==66) A.map[i][j]=8;\n\t\t\t\t\telse if(s.codePointAt(j)==87) A.map[i][j]=9;\n\t\t\t\t}\n\t\t\t}\n\t\t\tA.func();\n\t\t\t\n\t\t}\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n\npublic class Main{\n\nstatic PrintWriter out;\nstatic InputReader ir;\n\nstatic void solve(){\n for(;;){\n  int w=ir.nextInt();\n  int h=ir.nextInt();\n  if(w==0&&h==0) return;\n  char[][] map=ir.nextCharMap(h,w);\n  int[][] cnd=new int[h][w];\n  for(int i=0;i<h;i++){\n   for(int j=0;j<w;j++){\n    if(map[i][j]!='.') bfs(i,j,map[i][j]=='B'?1:2,map,cnd);\n   }\n  }\n  int bl=0,wh=0;\n  for(int i=0;i<h;i++){\n   for(int j=0;j<w;j++){\n    if(cnd[i][j]==1) bl++;\n    if(cnd[i][j]==2) wh++;\n   }\n  }\n  out.println(bl+\" \"+wh);\n }\n}\n\nstatic final int[] dd=new int[]{0-1,0,1};\n\npublic static boolean in(int x,int y,int h,int w){\n return (x>=0&&y>=0&&x<h&&y<w);\n}\n\npublic static void bfs(int x,int y,int m,char[][] map,int[][] cnd){\n int h=map.length,w=map[0].length;\n Deque<int[]> que=new ArrayDeque<>();\n for(int i=0;i<4;i++){\n  int nx=x+dd[i],ny=y+dd[i^1];\n // if(!in(nx,ny,h,w)) continue;\n // if(map[nx][ny]=='.'&&(cnd[nx][ny]&m)==0) que.offerLast(new int[]{nx,ny});\n }\n /*while(!que.isEmpty()){\n  int[] p=que.pollFirst();\n  int px=p[0],py=p[1];\n  cnd[px][py]|=m;\n  for(int i=0;i<4;i++){\n   int nx=px+dd[i],ny=py+dd[i^1];\n   if(!in(nx,ny,h,w)) continue;\n   if(map[nx][ny]=='.'&&(cnd[nx][ny]&m)==0) que.offerLast(new int[]{nx,ny});\n  }\n }*/\n}\n\npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n\nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n\n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n\n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n \n public boolean hasNext(){skip(); return hasNextByte();}\n \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n\n public double nextDouble(){return Double.parseDouble(next());}\n\n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n\n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n\n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n \npublic class Main{\n \nstatic PrintWriter out;\nstatic InputReader ir;\n \nstatic void solve(){\n for(;;){\n  w=ir.nextInt();\n  h=ir.nextInt();\n  if(w==0&&h==0) return;\n  map=ir.nextCharMap(h,w);\n  cnd=new int[h][w];\n  for(int i=0;i<h;i++){\n   for(int j=0;j<w;j++){\n    if(map[i][j]!='.') bfs(i,j,map[i][j]=='B'?1:2);\n   }\n  }\n  int bl=0,wh=0;\n  for(int i=0;i<h;i++){\n   for(int j=0;j<w;j++){\n    if(cnd[i][j]==1) bl++;\n    if(cnd[i][j]==2) wh++;\n   }\n  }\n  out.println(bl+\" \"+wh);\n }\n}\n \nstatic final int[] dd=new int[]{0,-1,0,1};\nstatic int w,h;\nstatic char[][] map;\nstatic int[][] cnd;\nstatic Deque<int[]> que=new ArrayDeque<>();\n \npublic static boolean in(int x,int y){\n return (x>=0&&y>=0&&x<h&&y<w);\n}\n \npublic static void bfs(int x,int y,int m){\n int nx,ny;\n for(int i=0;i<4;i++){\n  nx=x+dd[i];\n  ny=y+dd[i^1];\n  if(!in(nx,ny)) continue;\n  if((map[nx][ny]=='.')&&((cnd[nx][ny]&m)==0)) que.offerLast(new int[]{nx,ny});\n }\n while(!que.isEmpty()){\n  int[] p=que.pollFirst();\n  cnd[p[0]][p[1]]|=m;\n  for(int i=0;i<4;i++){\n   nx=p[0]+dd[i];\n   ny=p[1]+dd[i^1];\n   if(!in(nx,ny)) continue;\n   if((map[nx][ny]=='.')&&((cnd[nx][ny]&m)==0)) que.offerLast(new int[]{nx,ny});\n  }\n }\n}\n \npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n \nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n \n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n  \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n \n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n  \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n  \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n  \n public boolean hasNext(){skip(); return hasNextByte();}\n  \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n  \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n  \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public double nextDouble(){return Double.parseDouble(next());}\n \n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n \n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n \n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n\npublic class Main{\n\nstatic PrintWriter out;\nstatic InputReader ir;\n\nstatic void solve(){\n for(;;){\n  int w=ir.nextInt();\n  int h=ir.nextInt();\n  if(w==0&&h==0) return;\n  char[][] map=ir.nextCharMap(h,w);\n  int[][] cnd=new int[h][w];\n  for(int i=0;i<h;i++){\n   for(int j=0;j<w;j++){\n    if(map[i][j]!='.') bfs(i,j,map[i][j]=='B'?1:2,map,cnd);\n   }\n  }\n  int bl=0,wh=0;\n  for(int i=0;i<h;i++){\n   for(int j=0;j<w;j++){\n    if(cnd[i][j]==1) bl++;\n    if(cnd[i][j]==2) wh++;\n   }\n  }\n  out.println(bl+\" \"+wh);\n }\n}\n\nstatic final int[] dd=new int[]{0-1,0,1};\n\npublic static boolean in(int x,int y,int h,int w){\n return (x>=0&&y>=0&&x<h&&y<w);\n}\n\npublic static void bfs(int x,int y,int m,char[][] map,int[][] cnd){\n int h=map.length,w=map[0].length;\n Deque<int[]> que=new ArrayDeque<>();\n for(int i=0;i<4;i++){\n  int nx=x+dd[i],ny=y+dd[i^1];\n  if(!in(nx,ny,h,w)) continue;\n  if(map[nx][ny]=='.'&&(cnd[nx][ny]&m)==0) que.offerLast(new int[]{nx,ny});\n }\n while(!que.isEmpty()){\n  int[] p=que.pollFirst();\n  int px=p[0],py=p[1];\n  cnd[px][py]|=m;\n  for(int i=0;i<4;i++){\n   int nx=px+dd[i],ny=py+dd[i^1];\n   if(!in(nx,ny,h,w)) continue;\n   if(map[nx][ny]=='.'&&(cnd[nx][ny]&m)==0) que.offerLast(new int[]{nx,ny});\n  }\n }\n}\n\npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n\nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n\n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n\n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n \n public boolean hasNext(){skip(); return hasNextByte();}\n \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n\n public double nextDouble(){return Double.parseDouble(next());}\n\n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n\n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n\n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\n    int w,h;\n    char[][] map;\n    boolean B,W;\n    int[] dx = {0,0,1,-1};\n    int[] dy = {1,-1,0,0};\n    int cnt;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        while(true){\n            w = sc.nextInt();\n            h = sc.nextInt();\n            if(w==0 && h==0) break;\n\n            map = new char[h][w];\n            for(int i=0; i<h; i++){\n                String line = sc.next();\n                map[i] = line.toCharArray();\n            }\n\n            int bsum = 0, wsum = 0;\n            for(int i=0; i<h; i++){\n                for(int j=0; j<w; j++){\n                    if(map[i][j]=='.'){\n                        cnt = 0;\n                        B = false;\n                        W = false;\n                        bfs(j,i);\n                        if(B && !W) bsum += cnt;\n                        if(!B && W) wsum += cnt;\n                    }\n                }\n            }\n\n            System.out.println(bsum+\" \"+wsum);\n        }\n    }\n\n    void bfs(int sx, int sy){\n        LinkedList<int[]> list = new LinkedList<int[]>();\n        list.add(new int[]{sx,sy});\n        boolean[][] v = new boolean[h][w];\n\n        while(list.size()>0){\n            int[] xy = list.poll();\n            int x = xy[0], y = xy[1];\n\n            if(v[y][x]) continue;\n            v[y][x] = true;\n\n            cnt++;\n            map[y][x] = 'x';\n\n            for(int i=0; i<4; i++){\n                int nx = x+dx[i], ny = y+dy[i];\n                if(nx<0 || nx>=w || ny<0 || ny>=h) continue;\n                if(map[ny][nx]=='.') list.add(new int[]{nx,ny});\n                else if(map[ny][nx]=='B') B = true;\n                else if(map[ny][nx]=='W') W = true;\n            }\n        }\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main{\n    public static void main(String[] args){\n\tnew Main().run();\n    }\n    Scanner sc = new Scanner(System.in);\n\n    char[][] map;\n    char[][] round; // \"\":, B:? W:, x:?????n:\n    int w, h;\n    int B, W;\n\n\n    void run(){\n\twhile(sc.hasNext()){\n\t    w = sc.nextInt();\n\t    h = sc.nextInt();\n\t    if(w==0 && h==0) break;\n\t    \n\t    map = new char[h][w];\n\t    round = new char[h][w];\n\t    \n\t    for(int i=0; i<h; i++){\n\t\tString s = sc.next();\n\t\tArrays.fill(round[i], 'o');\n\t\tfor(int k=0; k<w; k++)\n\t\t    map[i] = s.toCharArray();\n\t    }\n\t    \n\t    for(int i=0; i<h; i++)\n\t\tfor(int k=0; k<w; k++){\n\t\t    solve(i, k, map[i][k]);\n\t\t}\n\t    \n\t    count();\n\t    //show();\n\t    System.out.println(B+\" \"+W);\n\t}\n    }\n\n    void solve(int a, int b, char c){\n\tif(a<0 || a>=h || b<0 || b>=w) return;\n\tif(round[a][b]=='x' || round[a][b]=='n' || c=='.') return;\n\t\n\tif(map[a][b]=='B' || map[a][b]=='W'){\n\t    c = map[a][b];\n\t    round[a][b] = 'n';\n\t    solve(a+1, b, c);\n\t    solve(a-1, b, c);\n\t    solve(a, b+1, c);\n\t    solve(a, b-1, c);\n\t}\n\telse if(round[a][b]=='o'){\n\t    round[a][b] = c;\n\t    solve(a+1, b, c);\n\t    solve(a-1, b, c);\n\t    solve(a, b+1, c);\n\t    solve(a, b-1, c);\n\t}\n\telse if( (round[a][b]=='B' && c=='W') || (round[a][b]=='W' && c=='B')){\n\t    round[a][b] = 'x';\n\t    solve(a+1, b, c);\n\t    solve(a-1, b, c);\n\t    solve(a, b+1, c);\n\t    solve(a, b-1, c);\n\t}\n    }\n\n    void count(){\n\tB = 0;\n\tW = 0;\n\tfor(int i=0; i<h; i++)\n\t    for(int k=0; k<w; k++)\n\t\tif(round[i][k]=='B') B++;\n\t\telse if(round[i][k]=='W') W++;\n    }\n\n    void show(){\n\tfor(int i=0; i<h; i++){\n\t    for(int k=0; k<w; k++)\n\t\tSystem.out.print(round[i][k]+\" \");\n\t    System.out.println();\n\t}\n\tSystem.out.println(\"-------------------\");\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\n\tint w, h, count, cb, cw;\n\tint[][] map;\n\tboolean black, white;\n\t\n\tpublic void func(){\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(map[i][j]==0){\n\t\t\t\t\tcount = 0;\n\t\t\t\t\tblack = true;\n\t\t\t\t\twhite = true;\n\t\t\t\t\tloop(i, j);\n\t\t\t\t\tif(black==false && white==true){\n\t\t\t\t\t\tcb += count;\n\t\t\t\t\t}else if(black==true && white==false){\n\t\t\t\t\t\tcw += count;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(cb + \" \" + cw);\n\t}\n\t\n\tpublic void loop(int y, int x){\n\t\tif(map[y][x]==8){\n\t\t\tblack = false;\n\t\t}else if(map[y][x]==9){\n\t\t\twhite = false;\n\t\t}else if(map[y][x]==0){\n\t\t\tmap[y][x] = 1;\n\t\t\tcount++;\n\t\t\tif(y!=0) loop(y-1,x);\n\t\t\tif(x!=0) loop(y,x-1);\n\t\t\tif(y!=h-1) loop(y+1,x);\n\t\t\tif(x!=w-1) loop(y,x+1);\n\t\t}\n\t}\n\t\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tAOJ_2014 A = new AOJ_2014();\n\t\t\tA.w = sc.nextInt();\n\t\t\tA.h = sc.nextInt();\n\t\t\tif(A.w==0 && A.h==0)break;\n\t\t\tA.map = new int[A.h][A.w];\n\t\t\tString s = \"\";\n\t\t\tfor(int i=0;i<A.h;i++){\n\t\t\t\ts = sc.next();\n\t\t\t\tfor(int j=0;j<A.w;j++){\n\t\t\t\t\tif(s.codePointAt(j)==66) A.map[i][j]=8;\n\t\t\t\t\telse if(s.codePointAt(j)==87) A.map[i][j]=9;\n\t\t\t\t}\n\t\t\t}\n\t\t\tA.func();\n\t\t\t\n\t\t}\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile (true) {\n\t\t\tfinal int w = sc.nextInt();\n\t\t\tfinal int h = sc.nextInt();\n\n\t\t\tif (w == 0 && h == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint[][] map = new int[h][w];\n\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tchar[] input = sc.next().toCharArray();\n\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tif (input[j] == 'W') {\n\t\t\t\t\t\tmap[i][j] = 1;\n\t\t\t\t\t} else if (input[j] == 'B') {\n\t\t\t\t\t\tmap[i][j] = -1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmap[i][j] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint[][] w_dist = new int[h][w];\n\t\t\tint[][] b_dist = new int[h][w];\n\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tw_dist[i][j] = Integer.MAX_VALUE;\n\t\t\t\t\tb_dist[i][j] = Integer.MAX_VALUE;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int tt = 0; tt < 2500; tt++){\n\t\t\t\tboolean updated = false;\n\t\t\t\t\n\t\t\t\t// w-forward\n\t\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\t\tif (map[i][j] == -1) {\n\t\t\t\t\t\t\tw_dist[i][j] = Integer.MAX_VALUE;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t} else if (map[i][j] == 1) {\n\t\t\t\t\t\t\tw_dist[i][j] = 0;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tint cur = w_dist[i][j];\n\n\t\t\t\t\t\tif (i == 0 && j == 0) {\n\t\t\t\t\t\t\tw_dist[i][j] = Math.min(Integer.MAX_VALUE, w_dist[i][j]);\n\t\t\t\t\t\t} else if (i == 0) {\n\t\t\t\t\t\t\tif (w_dist[i][j - 1] != Integer.MAX_VALUE) {\n\t\t\t\t\t\t\t\tw_dist[i][j] = Math.min(w_dist[i][j - 1] + 1, w_dist[i][j]);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tw_dist[i][j] = Math.min(w_dist[i][j - 1], w_dist[i][j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (j == 0) {\n\t\t\t\t\t\t\tif (w_dist[i - 1][j] != Integer.MAX_VALUE) {\n\t\t\t\t\t\t\t\tw_dist[i][j] = Math.min(w_dist[i - 1][j] + 1, w_dist[i][j]);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tw_dist[i][j] = Math.min(w_dist[i - 1][j], w_dist[i][j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfinal int min = Math.min(w_dist[i - 1][j],\n\t\t\t\t\t\t\t\t\tw_dist[i][j - 1]);\n\t\t\t\t\t\t\tif (min != Integer.MAX_VALUE) {\n\t\t\t\t\t\t\t\tw_dist[i][j] = Math.min(min + 1, w_dist[i][j]);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tw_dist[i][j] = Math.min(min, w_dist[i][j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(w_dist[i][j] != cur){\n\t\t\t\t\t\t\tupdated = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// w-back\n\t\t\t\tfor (int i = h - 1; i >= 0; i--) {\n\t\t\t\t\tfor (int j = w - 1; j >= 0; j--) {\n\t\t\t\t\t\tif (map[i][j] == -1) {\n\t\t\t\t\t\t\tw_dist[i][j] = Integer.MAX_VALUE;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t} else if (map[i][j] == 1) {\n\t\t\t\t\t\t\tw_dist[i][j] = 0;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tint cur = w_dist[i][j];\n\n\t\t\t\t\t\tif (i == h - 1 && j == w - 1) {\n\t\t\t\t\t\t\tw_dist[i][j] = Math.min(Integer.MAX_VALUE,\n\t\t\t\t\t\t\t\t\tw_dist[i][j]);\n\t\t\t\t\t\t} else if (i == h - 1) {\n\t\t\t\t\t\t\tif (w_dist[i][j + 1] != Integer.MAX_VALUE) {\n\t\t\t\t\t\t\t\tw_dist[i][j] = Math.min(w_dist[i][j + 1] + 1,\n\t\t\t\t\t\t\t\t\t\tw_dist[i][j]);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tw_dist[i][j] = Math.min(w_dist[i][j + 1],\n\t\t\t\t\t\t\t\t\t\tw_dist[i][j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (j == w - 1) {\n\t\t\t\t\t\t\tif (w_dist[i + 1][j] != Integer.MAX_VALUE) {\n\t\t\t\t\t\t\t\tw_dist[i][j] = Math.min(w_dist[i + 1][j] + 1,\n\t\t\t\t\t\t\t\t\t\tw_dist[i][j]);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tw_dist[i][j] = Math.min(w_dist[i + 1][j],\n\t\t\t\t\t\t\t\t\t\tw_dist[i][j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfinal int min = Math.min(w_dist[i + 1][j],\n\t\t\t\t\t\t\t\t\tw_dist[i][j + 1]);\n\t\t\t\t\t\t\tif (min != Integer.MAX_VALUE) {\n\t\t\t\t\t\t\t\tw_dist[i][j] = Math.min(min + 1, w_dist[i][j]);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tw_dist[i][j] = Math.min(min, w_dist[i][j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(w_dist[i][j] != cur){\n\t\t\t\t\t\t\tupdated = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// b-forward\n\t\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\t\tif (map[i][j] == 1) {\n\t\t\t\t\t\t\tb_dist[i][j] = Integer.MAX_VALUE;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t} else if (map[i][j] == -1) {\n\t\t\t\t\t\t\tb_dist[i][j] = 0;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tint cur = b_dist[i][j];\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (i == 0 && j == 0) {\n\t\t\t\t\t\t\tb_dist[i][j] = Integer.MAX_VALUE;\n\t\t\t\t\t\t} else if (i == 0) {\n\t\t\t\t\t\t\tif (b_dist[i][j - 1] != Integer.MAX_VALUE) {\n\t\t\t\t\t\t\t\tb_dist[i][j] = Math.min(b_dist[i][j - 1] + 1, b_dist[i][j]);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tb_dist[i][j] = Math.min(b_dist[i][j - 1], b_dist[i][j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (j == 0) {\n\t\t\t\t\t\t\tif (b_dist[i - 1][j] != Integer.MAX_VALUE) {\n\t\t\t\t\t\t\t\tb_dist[i][j] = Math.min(b_dist[i - 1][j] + 1, b_dist[i][j]);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tb_dist[i][j] = Math.min(b_dist[i - 1][j], b_dist[i][j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfinal int min = Math.min(b_dist[i - 1][j],\n\t\t\t\t\t\t\t\t\tb_dist[i][j - 1]);\n\t\t\t\t\t\t\tif (min != Integer.MAX_VALUE) {\n\t\t\t\t\t\t\t\tb_dist[i][j] = Math.min(min + 1, b_dist[i][j]);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tb_dist[i][j] = Math.min(min, b_dist[i][j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(b_dist[i][j] != cur){\n\t\t\t\t\t\t\tupdated = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// b-back\n\t\t\t\tfor (int i = h - 1; i >= 0; i--) {\n\t\t\t\t\tfor (int j = w - 1; j >= 0; j--) {\n\t\t\t\t\t\tif (map[i][j] == 1) {\n\t\t\t\t\t\t\tb_dist[i][j] = Integer.MAX_VALUE;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t} else if (map[i][j] == -1) {\n\t\t\t\t\t\t\tb_dist[i][j] = 0;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tint cur = b_dist[i][j];\n\n\t\t\t\t\t\tif (i == h - 1 && j == w - 1) {\n\t\t\t\t\t\t\tb_dist[i][j] = Math.min(Integer.MAX_VALUE,\n\t\t\t\t\t\t\t\t\tb_dist[i][j]);\n\t\t\t\t\t\t} else if (i == h - 1) {\n\t\t\t\t\t\t\tif (b_dist[i][j + 1] != Integer.MAX_VALUE) {\n\t\t\t\t\t\t\t\tb_dist[i][j] = Math.min(b_dist[i][j + 1] + 1,\n\t\t\t\t\t\t\t\t\t\tb_dist[i][j]);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tb_dist[i][j] = Math.min(b_dist[i][j + 1],\n\t\t\t\t\t\t\t\t\t\tb_dist[i][j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (j == w - 1) {\n\t\t\t\t\t\t\tif (b_dist[i + 1][j] != Integer.MAX_VALUE) {\n\t\t\t\t\t\t\t\tb_dist[i][j] = Math.min(b_dist[i + 1][j] + 1,\n\t\t\t\t\t\t\t\t\t\tb_dist[i][j]);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tb_dist[i][j] = Math.min(b_dist[i + 1][j],\n\t\t\t\t\t\t\t\t\t\tb_dist[i][j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfinal int min = Math.min(b_dist[i + 1][j],\n\t\t\t\t\t\t\t\t\tb_dist[i][j + 1]);\n\t\t\t\t\t\t\tif (min != Integer.MAX_VALUE) {\n\t\t\t\t\t\t\t\tb_dist[i][j] = Math.min(min + 1, b_dist[i][j]);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tb_dist[i][j] = Math.min(min, b_dist[i][j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(b_dist[i][j] != cur){\n\t\t\t\t\t\t\tupdated = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(!updated){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint b_count = 0;\n\t\t\tint w_count = 0;\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tfinal int w_d = w_dist[i][j] == Integer.MAX_VALUE ? Integer.MIN_VALUE\n\t\t\t\t\t\t\t: w_dist[i][j];\n\t\t\t\t\tfinal int b_d = b_dist[i][j] == Integer.MAX_VALUE ? Integer.MIN_VALUE\n\t\t\t\t\t\t\t: b_dist[i][j];\n\n\t\t\t\t\tif (w_d > 0 && b_d > 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else if (w_d > 0) {\n\t\t\t\t\t\tw_count++;\n\t\t\t\t\t} else if (b_d > 0) {\n\t\t\t\t\t\tb_count++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(b_count + \" \" + w_count);\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n \npublic class Main{\n \nstatic PrintWriter out;\nstatic InputReader ir;\n \nstatic void solve(){\n for(;;){\n  w=ir.nextInt();\n  h=ir.nextInt();\n  if(w==0&&h==0) return;\n  map=ir.nextCharMap(h,w);\n  cnd=new int[h][w];\n  for(int i=0;i<h;i++){\n   for(int j=0;j<w;j++){\n    if(map[i][j]!='.') bfs(i,j,map[i][j]=='B'?1:2);\n   }\n  }\n  int bl=0,wh=0;\n  for(int i=0;i<h;i++){\n   for(int j=0;j<w;j++){\n    if(cnd[i][j]==1) bl++;\n    if(cnd[i][j]==2) wh++;\n   }\n  }\n  out.println(bl+\" \"+wh);\n }\n}\n \nstatic final int[] dd=new int[]{0,-1,0,1};\nstatic int w,h;\nstatic char[][] map;\nstatic int[][] cnd;\nstatic Deque<int[]> que=new ArrayDeque<>();\n \npublic static boolean in(int x,int y){\n return (x>=0&&y>=0&&x<h&&y<w);\n}\n \npublic static void bfs(int x,int y,int m){\n int nx,ny;\n for(int i=0;i<4;i++){\n  nx=x+dd[i];\n  ny=y+dd[i^1];\n  if(!in(nx,ny)) continue;\n  if((map[nx][ny]=='.')&&((cnd[nx][ny]&m)==0)) que.offerLast(new int[]{nx,ny});\n }\n/* while(!que.isEmpty()){\n  int[] p=que.pollFirst();\n  cnd[p[0]][p[1]]|=m;\n  for(int i=0;i<4;i++){\n   nx=p[0]+dd[i];\n   ny=p[1]+dd[i^1];\n   if(!in(nx,ny)) continue;\n   if((map[nx][ny]=='.')&&((cnd[nx][ny]&m)==0)) que.offerLast(new int[]{nx,ny});\n  }\n }*/\n}\n \npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n \nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n \n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n  \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n \n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n  \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n  \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n  \n public boolean hasNext(){skip(); return hasNextByte();}\n  \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n  \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n  \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public double nextDouble(){return Double.parseDouble(next());}\n \n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n \n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n \n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\tstatic final long INF = Long.MAX_VALUE / 2;\n\tstatic int[] wd = new int[]{0,1,0,-1};\n\tstatic int[] hd = new int[]{1,0,-1,0};\n\tstatic int w;\n\tstatic int h;\n\tprivate static void solve() {\n\t\tPrintWriter pr = new PrintWriter(System.out);\n\t\twhile(true){\n\t\t\tw = ni();\n\t\t\th = ni();\n\t\t\tif(w==0 && h==0) break;\n\t\t\tchar[][] map = new char[h][w];\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tmap[i][j] = nc();\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean[][] B = new boolean[h][w];\n\t\t\tboolean[][] W = new boolean[h][w];\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tif(map[i][j]=='B'){\n\t\t\t\t\t\tdfs(B,map,i,j);\n\t\t\t\t\t}\n\t\t\t\t\tif(map[i][j]=='W'){\n\t\t\t\t\t\tdfs(W,map,i,j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint bs = 0;\n\t\t\tint ws = 0;\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tif(B[i][j]==true&&W[i][j]==false) bs++;\n\t\t\t\t\tif(W[i][j]==true&&B[i][j]==false) ws++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpr.println(bs+\" \"+ws);\n\t\t}\n\t\tpr.flush();\n\t}\n\t\n\tprivate static void dfs(boolean[][] b, char[][] map, int i, int j) {\n\t\tfor(int k=0;k<4;k++){\n\t\t\tif(j+wd[k]<w && j+wd[k]>=0 && i+hd[k]<h && i+hd[k]>=0\n\t\t\t\t\t&&b[i+hd[k]][j+wd[k]]==false && map[i+hd[k]][j+wd[k]]!='B' && map[i+hd[k]][j+wd[k]]!='W'){\n\t\t\t\tb[i+hd[k]][j+wd[k]] = true;\n\t\t\t\tdfs(b,map,i+hd[k],j+wd[k]);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n\t//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n  \npublic class Main {\n    Scanner sc = new Scanner(System.in);\n  \n    public static void main(String[] args) {\n        new Main(); \n    }\n  \n    public Main() {\n        new A().doIt();\n    }\n    class A{\n    \tint map[][];\n    \tint W = 0;int B = 0;int X = 0;int Y = 0;\n    \tint mx[] = {0,1,0,-1};\n    \tint my[] = {1,0,-1,0};\n    \tboolean w,b;\n    \t\n    \tint dfs(int y,int x,int cnt){\n    \t\tif(cnt == 0){\n    \t\t\tmap[y][x] = -1;\n    \t\t\tcnt++;\n    \t\t}\n    \t\tfor(int i = 0;i < 4;i++){\n    \t\t\tif(x + mx[i] < X && x + mx[i] >= 0 &&\n    \t\t\t\t\ty + my[i] < Y && y + my[i] >= 0){\n    \t\t\t\tif(map[y + my[i]][x + mx[i]] == 0){\n    \t\t\t\t\tmap[y + my[i]][x + mx[i]] = -1;\n    \t\t\t\t\tcnt = dfs(y + my[i],x + mx[i],cnt+1);\n    \t\t\t\t}else if(map[y + my[i]][x + mx[i]] == 1){\n    \t\t\t\t\tw = true;\n    \t\t\t\t}else if(map[y + my[i]][x + mx[i]] == 2){\n    \t\t\t\t\tb = true;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t\tif(w && b)cnt = 0;\n    \t\treturn cnt;\n    \t}\n    \t\n    \tvoid check(){\n    \t\tfor(int i = 0;i < Y;i++){\n    \t\t\tfor(int j = 0;j < X;j++){\n    \t\t\t\tSystem.out.printf(\"%3d\",map[i][j]);\n    \t\t\t}\n    \t\t\tSystem.out.println();\n    \t\t}\n    \t\tSystem.out.println();\n    \t}\n    \t\n        void doIt(){\n        \twhile(true){\n        \t\tB = 0;W = 0;\n        \t\tX = sc.nextInt();\n        \t\tY = sc.nextInt();\n        \t\tif(X + Y == 0)break;\n        \t\tmap = new int [Y][X];\n        \t\tfor(int i = 0;i < Y;i++){\n        \t\t\tString str = sc.next();\n        \t\t\tchar ctr[] = str.toCharArray();\n        \t\t\tfor(int j = 0;j < X;j++){\n        \t\t\t\tif(ctr[j] == 'W')map[i][j] = 1;\n        \t\t\t\telse if(ctr[j] == 'B')map[i][j] = 2;\n        \t\t\t\telse map[i][j] = 0;\n        \t\t\t}\n        \t\t}\n        \t\tfor(int i = 0;i < Y;i++){\n        \t\t\tfor(int j = 0;j < X;j++){\n        \t\t\t\tif(map[i][j] == 0){\n        \t\t\t\t\tw = false;b = false;\n        \t\t\t\t\tint cnt = dfs(i,j,0);\n//        \t\t\t\t\tSystem.out.println(w+\" \"+b+\" \"+cnt);\n//        \t\t\t\t\tcheck();\n        \t\t\t\t\tif(w && !b)W += cnt;\n        \t\t\t\t\telse if(!w && b)B += cnt;\n        \t\t\t\t}\n        \t\t\t}\n        \t\t}\n        \t\tSystem.out.println(B+\" \"+W);\n        \t}\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n\npublic class Main{\n\nstatic PrintWriter out;\nstatic InputReader ir;\n\nstatic void solve(){\n for(;;){\n  w=ir.nextInt();\n  h=ir.nextInt();\n  if(w==0&&h==0) return;\n  map=ir.nextCharMap(h,w);\n  cnd=new int[h][w];\n  for(int i=0;i<h;i++){\n   for(int j=0;j<w;j++){\n    if(map[i][j]!='.'){\n     int m=(map[i][j]=='B'?1:2);\n     for(int k=0;k<4;k++){\n      int nx=i+dd[k],ny=j+dd[k^1];\n      if(!in(nx,ny)) continue;\n      if(map[nx][ny]=='.'&&(cnd[nx][ny]&m)==0) dfs(i,j,m);\n     }\n    }\n   }\n  }\n  int bl=0,wh=0;\n  for(int i=0;i<h;i++){\n   for(int j=0;j<w;j++){\n    if(cnd[i][j]==1) bl++;\n    if(cnd[i][j]==2) wh++;\n   }\n  }\n  out.println(bl+\" \"+wh);\n }\n}\n\nstatic final int[] dd=new int[]{0,-1,0,1};\nstatic int w,h;\nstatic char[][] map;\nstatic int[][] cnd;\nstatic Deque<int[]> que=new ArrayDeque<>();\n\npublic static boolean in(int x,int y){\n return (x>=0&&y>=0&&x<h&&y<w);\n}\n\npublic static void dfs(int x,int y,int m){\n cnd[x][y]|=m;\n for(int i=0;i<4;i++){\n  int nx=x+dd[i],ny=y+dd[i^1];\n  if(!in(nx,ny)) continue;\n  if(map[nx][ny]=='.'&&(cnd[nx][ny]&m)==0) dfs(nx,ny,m);\n }\n}\n\npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n\nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n\n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n\n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n \n public boolean hasNext(){skip(); return hasNextByte();}\n \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n\n public double nextDouble(){return Double.parseDouble(next());}\n\n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n\n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n\n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n\npublic class Main{\n\nstatic PrintWriter out;\nstatic InputReader ir;\n\nstatic void solve(){\n for(;;){\n  int w=ir.nextInt();\n  int h=ir.nextInt();\n  if(w==0&&h==0) return;\n  char[][] map=ir.nextCharMap(h,w);\n  int[][] cnd=new int[h][w];\n  for(int i=0;i<h;i++){\n   for(int j=0;j<w;j++){\n    if(map[i][j]!='.') bfs(i,j,map[i][j]=='B'?1:2,map,cnd);\n   }\n  }\n  int bl=0,wh=0;\n  for(int i=0;i<h;i++){\n   for(int j=0;j<w;j++){\n    if(cnd[i][j]==1) bl++;\n    if(cnd[i][j]==2) wh++;\n   }\n  }\n  out.println(bl+\" \"+wh);\n  System.gc();\n }\n}\n\nstatic final int[] dd=new int[]{0,-1,0,1};\nstatic Deque<int[]> que=new ArrayDeque<>();\n\npublic static boolean in(int x,int y,int h,int w){\n return (x>=0&&y>=0&&x<h&&y<w);\n}\n\npublic static void bfs(int x,int y,int m,char[][] map,int[][] cnd){\n int h=map.length,w=map[0].length;\n for(int i=0;i<4;i++){\n  int nx=x+dd[i],ny=y+dd[i^1];\n  if(!in(nx,ny,h,w)) continue;\n  if(map[nx][ny]=='.'&&(cnd[nx][ny]&m)==0) que.offerLast(new int[]{nx,ny});\n }\n while(!que.isEmpty()){\n  int[] p=que.pollFirst();\n  int px=p[0],py=p[1];\n  cnd[px][py]|=m;\n  for(int i=0;i<4;i++){\n   int nx=px+dd[i],ny=py+dd[i^1];\n   if(!in(nx,ny,h,w)) continue;\n   if(map[nx][ny]=='.'&&(cnd[nx][ny]&m)==0) que.offerLast(new int[]{nx,ny});\n  }\n }\n}\n\npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n\nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n\n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n\n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n \n public boolean hasNext(){skip(); return hasNextByte();}\n \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n\n public double nextDouble(){return Double.parseDouble(next());}\n\n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n\n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n\n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\npublic class Main{\n\tint nx;\n\tint ny;\n\tint[] dx = {0,-1,0,1};\n\tint[] dy = {1,0,-1,0};\n\tchar[][] map;\n\tboolean flagW ;\n\tboolean flagB ;\n\tint res = 0;\n\n\n\tvoid dfs(int y, int x){\n\t\tint sx;\n\t\tint sy;\n\t\tmap[y][x] = 'X';\n\n\t\tfor(int i=0; i<4; i++){\n\t\t\tsy = y + dy[i];\n\t\t\tsx = x + dx[i];\n\t\t\tif(sx < 0 || sy <0 || sx >= nx || sy >= ny) continue;\n\n\t\t\tif(map[sy][sx] == '.'){\n\t\t\t\tres++;\n\t\t\t\tdfs(sy,sx);\n\t\t\t}\n\t\t\telse if(map[sy][sx] == 'W')\n\t\t\t\tflagW = true;\n\n\t\t\telse if(map[sy][sx] == 'B')\n\t\t\t\tflagB = true;\n\t\t}\n\n\t}\n\n\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\n\n\t\twhile (true) {\n\t\t\tnx = sc.nextInt();\n\t\t\tny = sc.nextInt();\n\t\t\tString p = sc.nextLine();\n\n\t\t\tint cntW = 0;\n\t\t\tint cntB = 0;\n\t\t\tmap = new char[ny][];\n\n\t\t\tif(nx == 0 && ny == 0) break;\n\n\n\t\t\tfor (int i = 0; i < ny; i++) {\n\t\t\t\tString s = sc.nextLine();\n\t\t\t\tmap[i] = s.toCharArray();\n\t\t\t}\n\n\n\n\t\t\tfor (int i = 0; i < ny; i++) {\n\t\t\t\tfor (int j = 0; j < nx; j++) {\n\t\t\t\t\tif (map[i][j] != '.')\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tflagW = false;\n\t\t\t\t\tflagB = false;\n\t\t\t\t\tres = 1;\n\n\t\t\t\t\tdfs(i, j);\n\n\t\t\t\t\tif (flagW && !flagB)\n\t\t\t\t\t\tcntW += res;\n\t\t\t\t\tif (flagB && !flagW)\n\t\t\t\t\t\tcntB += res;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(cntB + \" \" + cntW);\n\t\t}\n\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\npublic class Main\n{\n\tstatic int field[][];\n\tstatic int white,black,cnt,fb,fw;\n\tstatic int W,H;\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tfor(;;)\n\t\t{\n\t\t\tW=in.nextInt();\n\t\t\tH=in.nextInt();\n\t\t\tif((W|H)==0)\n\t\t\t\treturn;\n\t\t\tfield=new int[H][W];\n\t\t\tfor(int i=0;i<H;i++)\n\t\t\t{\n\t\t\t\tString st=in.next();\n\t\t\t\tfor(int j=0;j<W;j++)\n\t\t\t\t{\n\t\t\t\t\tif(st.charAt(j)=='.')\n\t\t\t\t\t\tfield[i][j]=0;\n\t\t\t\t\telse if(st.charAt(j)=='W')\n\t\t\t\t\t\tfield[i][j]=1;\n\t\t\t\t\telse if(st.charAt(j)=='B')\n\t\t\t\t\t\tfield[i][j]=2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tblack=0;\n\t\t\twhite=0;\n\t\t\tfor(int i=0;i<H;i++)\n\t\t\t{\n\t\t\t\tfor(int j=0;j<W;j++)\n\t\t\t\t{\n\t\t\t\t\tfb=0;\n\t\t\t\t\tfw=0;\n\t\t\t\t\tcnt=0;\n\t\t\t\t\tif(field[i][j]==0)\n\t\t\t\t\t\tsolve(i,j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(black+\" \"+white);\n\t\t}\t\n\t}\n\tpublic static void solve(int h,int w)\n\t{\n\t\tfield[h][w]=3;\n\t\tcnt++;\n\t\tif(h-1>=0&&field[h-1][w]==1)\n\t\t\tfw=1;\n\t\tif(h-1>=0&&field[h-1][w]==2)\n\t\t\tfb=1;\n\t\tif(h+1<H&&field[h+1][w]==1)\n\t\t\tfw=1;\n\t\tif(h+1<H&&field[h+1][w]==2)\n\t\t\tfb=1;\n\t\tif(w-1>=0&&field[h][w-1]==1)\n\t\t\tfw=1;\n\t\tif(w-1>=0&&field[h][w-1]==2)\n\t\t\tfb=1;\n\t\tif(w+1<W&&field[h][w+1]==1)\n\t\t\tfw=1;\n\t\tif(w+1<W&&field[h][w+1]==2)\n\t\t\tfb=1;\n\t\tif(h-1>=0&&w-1>=0&&field[h-1][w-1]==1)\n\t\t\tfw=1;\n\t\tif(h-1>=0&&w-1>=0&&field[h-1][w-1]==2)\n\t\t\tfb=1;\n\t\tif(h-1>=0&&w+1<W&&field[h-1][w+1]==1)\n\t\t\tfw=1;\n\t\tif(h-1>=0&&w+1<W&&field[h-1][w+1]==2)\n\t\t\tfb=1;\n\t\tif(h+1<H&&w+1<W&&field[h+1][w+1]==1)\n\t\t\tfw=1;\n\t\tif(h+1<H&&w+1<W&&field[h+1][w+1]==2)\n\t\t\tfb=1;\n\t\tif(h+1<H&&w-1>=0&&field[h+1][w-1]==1)\n\t\t\tfw=1;\n\t\tif(h+1<H&&w-1>=0&&field[h+1][w-1]==2)\n\t\t\tfb=1;\n\t\t\n\t\tif(h-1>=0&&field[h-1][w]==0)\n\t\t\tsolve(h-1,w);\n\t\tif(h+1<H&&field[h+1][w]==0)\n\t\t\tsolve(h+1,w);\n\t\tif(w-1>=0&&field[h][w-1]==0)\n\t\t\tsolve(h,w-1);\n\t\tif(w+1<W&&field[h][w+1]==0)\n\t\t\tsolve(h,w+1);\n\n\t\tif(fw==1&&fb==0)\n\t\t{\n\t\t\twhite+=cnt;\n\t\t\tcnt=0;\n\t\t\treturn;\n\t\t}\n\t\telse if(fw==0&&fb==1)\n\t\t{\n\t\t\tblack+=cnt;\n\t\t\tcnt=0;\n\t\t\treturn;\n\t\t}\n\t\telse if(fw==1&&fb==1)\n\t\t{\n\t\t\tcnt=0;\n\t\t\treturn;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n\npublic class Main{\n\nstatic PrintWriter out;\nstatic InputReader ir;\n\nstatic void solve(){\n for(;;){\n  w=ir.nextInt();\n  h=ir.nextInt();\n  if(w==0&&h==0) return;\n  map=ir.nextCharMap(h,w);\n  cnd=new int[h][w];\n  for(int i=0;i<h;i++){\n   for(int j=0;j<w;j++){\n    if(map[i][j]!='.') bfs(i,j,map[i][j]=='B'?1:2);\n   }\n  }\n  int bl=0,wh=0;\n  for(int i=0;i<h;i++){\n   for(int j=0;j<w;j++){\n    if(cnd[i][j]==1) bl++;\n    if(cnd[i][j]==2) wh++;\n   }\n  }\n  out.println(bl+\" \"+wh);\n }\n}\n\nstatic final int[] dd=new int[]{0,-1,0,1};\nstatic int w,h;\nstatic char[][] map;\nstatic int[][] cnd;\nstatic Deque<int[]> que=new ArrayDeque<>();\n\npublic static boolean in(int x,int y){\n return (x>=0&&y>=0&&x<h&&y<w);\n}\n\npublic static void bfs(int x,int y,int m){\n for(int i=0;i<4;i++){\n  int nx=x+dd[i],ny=y+dd[i^1];\n  if(!in(nx,ny)) continue;\n  if(map[nx][ny]=='.'&&(cnd[nx][ny]&m)==0) que.offerLast(new int[]{nx,ny});\n }\n while(!que.isEmpty()){\n  int[] p=que.pollFirst();\n  int px=p[0],py=p[1];\n  cnd[px][py]|=m;\n  for(int i=0;i<4;i++){\n   int nx=px+dd[i],ny=py+dd[i^1];\n   if(!in(nx,ny)) continue;\n   if(map[nx][ny]=='.'&&(cnd[nx][ny]&m)==0) que.offerLast(new int[]{nx,ny});\n  }\n }\n}\n\npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n\nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n\n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n\n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n \n public boolean hasNext(){skip(); return hasNextByte();}\n \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n\n public double nextDouble(){return Double.parseDouble(next());}\n\n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n\n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n\n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic char board[][];\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int[] vx = new int[]{0,1,0,-1};\n\tstatic int[] vy = new int[]{1,0,-1,0};\n\tstatic int maxh, maxw;\n\tstatic boolean wflag;\n\tstatic boolean bflag;\n\tprivate static int count;\n\tprivate static int wcount = 0;\n\tprivate static int bcount = 0;;\n\t\n\tpublic static void main(String[] args) {\n        while (true) {\n            maxw = sc.nextInt();\n            maxh = sc.nextInt();\n            if(maxw == 0) break;\n            board = new char[maxh][maxw];\n            for (int i = 0; i < maxh; i++) {\n            \tboard[i] = sc.next().toCharArray();\n            }\n            wcount=0;\n            bcount=0;\n            solve();\n            System.out.println(bcount + \" \" + wcount);\n        }\n\t}\n\n\tprivate static void solve() {\n\t\tfor (int i = 0; i < maxh; i++) {\n\t\t\tfor (int j = 0; j < maxw; j++) {\n\t\t\t\tif (board[i][j] == '.') {\n\t\t\t\t\tcount=0;\n\t\t\t\t\twflag = false;\n\t\t\t\t\tbflag = false;\n\t\t\t\t\tdfs(i, j);\n\t\t\t\t\tif (wflag && !bflag) wcount += count;\n\t\t\t\t\tif (!wflag && bflag) bcount += count;\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\t\n\t}\n\n\tprivate static void dfs(int h, int w) {\n\t\tboard[h][w] = 'X';\n\t\tcount++;\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tif (h + vx[i] >= maxh || h + vx[i]  < 0 || w + vy[i] >= maxw || w + vy[i] < 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tchar c = board[h + vx[i]][w + vy[i]];\n\t\t\t\tif (c == 'X') continue;\n\t\t\t\tif (c == 'W') {\n\t\t\t\t\twflag = true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (c == 'B') {\n\t\t\t\t\tbflag = true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdfs(h + vx[i], w + vy[i]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.util.ArrayDeque;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int[] DR = { 1, 0, -1, 0 };\n\tstatic int[] DC = { 0, 1, 0, -1 };\n\tstatic int H, W;\n\n\tpublic static void main(String[] arg) {\n\t\twhile (true) {\n\t\t\tW = sc.nextInt();\n\t\t\tH = sc.nextInt();\n\t\t\tif (W == 0) break;\n\t\t\tchar[][] m = new char[H][];\n\t\t\tfor (int i = 0; i < H; ++i) {\n\t\t\t\tm[i] = sc.next().toCharArray();\n\t\t\t}\n\t\t\tint[][] st = new int[H][W];\n\t\t\tbfs('B', 1, m, st);\n\t\t\tbfs('W', 2, m, st);\n\t\t\tSystem.out.println(count(1, st) + \" \" + count(2, st));\n\t\t}\n\t}\n\n\tstatic int count(int v, int[][] st) {\n\t\tint c = 0;\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tif (st[i][j] == v) ++c;\n\t\t\t}\n\t\t}\n\t\treturn c;\n\t}\n\n\tstatic void bfs(char ch, int v, char[][] m, int[][] st) {\n\t\tQueue<Point> q = new ArrayDeque<Point>();\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tif (m[i][j] == ch) {\n\t\t\t\t\tq.add(new Point(i, j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tboolean[][] visited = new boolean[H][W];\n\t\twhile (!q.isEmpty()) {\n\t\t\tPoint p = q.poll();\n\t\t\tint r = p.x;\n\t\t\tint c = p.y;\n\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\tint nr = r + DR[i];\n\t\t\t\tint nc = c + DC[i];\n\t\t\t\tif (0 <= nr && nr < H && 0 <= nc && nc < W && !visited[nr][nc] && m[nr][nc] == '.') {\n\t\t\t\t\tq.add(new Point(nr, nc));\n\t\t\t\t\tvisited[nr][nc] = true;\n\t\t\t\t\tst[nr][nc] |= v;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic char board[][];\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int[] vx = new int[]{0,1,0,-1};\n\tstatic int[] vy = new int[]{1,0,-1,0};\n\tstatic int maxh, maxw;\n\tstatic boolean wflag;\n\tstatic boolean bflag;\n\tstatic int count;\n\tstatic int wcount = 0;\n\tstatic int bcount = 0;;\n\t\n\tpublic static void main(String[] args) {\n        while (true) {\n            maxw = sc.nextInt();\n            maxh = sc.nextInt();\n            if(maxw == 0) break;\n            board = new char[maxh][maxw];\n            for (int i = 0; i < maxh; i++) {\n            \tboard[i] = sc.next().toCharArray();\n            }\n            wcount=0;\n            bcount=0;\n            solve();\n            System.out.println(bcount + \" \" + wcount);\n        }\n\t}\n\n\tprivate static void solve() {\n\t\tfor (int i = 0; i < maxh; i++) {\n\t\t\tfor (int j = 0; j < maxw; j++) {\n\t\t\t\tif (board[i][j] == '.') {\n\t\t\t\t\tcount=0;\n\t\t\t\t\twflag = false;\n\t\t\t\t\tbflag = false;\n\t\t\t\t\tdfs(i, j);\n\t\t\t\t\tif (wflag && !bflag) wcount += count;\n\t\t\t\t\tif (!wflag && bflag) bcount += count;\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\t\n\t}\n\n\tprivate static void dfs(int h, int w) {\n\t\tboard[h][w] = 'X';\n\t\tcount++;\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tif (h + vx[i] >= maxh || h + vx[i]  < 0 || w + vy[i] >= maxw || w + vy[i] < 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tchar c = board[h + vx[i]][w + vy[i]];\n\t\t\t\tif (c == 'X') continue;\n\t\t\t\tif (c == 'W') {\n\t\t\t\t\twflag = true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (c == 'B') {\n\t\t\t\t\tbflag = true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdfs(h + vx[i], w + vy[i]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tstatic char[][] field;\n\tstatic int w;\n\tstatic int h;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif (w == 0 && h == 0)\n\t\t\t\tbreak;\n\t\t\tfield = new char[h][w];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tString str = sc.next();\n\t\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\t\tfield[i][j] = str.charAt(j);\n\t\t\t}\n\t\t\tfor (int i = 0; i < h; i++)\n\t\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\t\tif (field[i][j] != '.')\n\t\t\t\t\t\tcheck(j, i);\n\t\t\tint black = 0;\n\t\t\tint white = 0;\n\t\t\tfor (int i = 0; i < h; i++)\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tif (field[i][j] == 'b')\n\t\t\t\t\t\tblack++;\n\t\t\t\t\tif (field[i][j] == 'w')\n\t\t\t\t\t\twhite++;\n\t\t\t\t}\n\t\t\tSystem.out.println(black + \" \" + white);\n\t\t}\n\t\tsc.close();\n\t}\n\n\tstatic void check(int x, int y) {\n\t\tint[] dx = { 0, 1, 0, -1 };\n\t\tint[] dy = { -1, 0, 1, 0 };\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tswitch (field[y][x]) {\n\t\t\tcase 'W':\n\t\t\tcase 'w':\n\t\t\t\tif (x + dx[i] >= 0 && x + dx[i] < w && y + dy[i] >= 0\n\t\t\t\t\t\t&& y + dy[i] < h)\n\t\t\t\t\tswitch (field[y + dy[i]][x + dx[i]]) {\n\t\t\t\t\tcase '.':\n\t\t\t\t\t\tfield[y + dy[i]][x + dx[i]] = 'w';\n\t\t\t\t\t\tcheck(x + dx[i], y + dy[i]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'b':\n\t\t\t\t\t\tfield[y + dy[i]][x + dx[i]] = 'n';\n\t\t\t\t\t\tcheck(x + dx[i], y + dy[i]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'B':\n\t\t\tcase 'b':\n\t\t\t\tif (x + dx[i] >= 0 && x + dx[i] < w && y + dy[i] >= 0\n\t\t\t\t\t\t&& y + dy[i] < h)\n\t\t\t\t\tswitch (field[y + dy[i]][x + dx[i]]) {\n\t\t\t\t\tcase '.':\n\t\t\t\t\t\tfield[y + dy[i]][x + dx[i]] = 'b';\n\t\t\t\t\t\tcheck(x + dx[i], y + dy[i]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'w':\n\t\t\t\t\t\tfield[y + dy[i]][x + dx[i]] = 'n';\n\t\t\t\t\t\tcheck(x + dx[i], y + dy[i]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'n':\n\t\t\t\tif (x + dx[i] >= 0 && x + dx[i] < w && y + dy[i] >= 0\n\t\t\t\t\t\t&& y + dy[i] < h)\n\t\t\t\t\tswitch (field[y + dy[i]][x + dx[i]]) {\n\t\t\t\t\tcase '.':\n\t\t\t\t\tcase 'b':\n\t\t\t\t\tcase 'w':\n\t\t\t\t\t\tfield[y + dy[i]][x + dx[i]] = 'n';\n\t\t\t\t\t\tcheck(x + dx[i], y + dy[i]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic char[][] a;\n\tstatic char[][] wMap;\n\tstatic char[][] bMap;\n\tstatic int[][] directions8 = { { -1, -1 }, { -1, 0 }, { -1, 1 }, { 0, -1 }, { 0, 1 }, { 1, -1 }, { 1, 0 },\n\t\t\t{ 1, 1 } };\n\tstatic int[][] directions4 = { { -1, 0 }, { 1, 0 }, { 0, -1 }, { 0, 1 } };\n\tstatic int ans;\n\tstatic int countW;\n\tstatic int countB;\n\tstatic int w;\n\tstatic int h;\n\tstatic boolean[][] wSquare;\n\tstatic boolean[][] bSquare;\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile (true) {\n\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\n\t\t\tif ((w | h) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ta = new char[h][w];\n\t\t\twMap = new char[h][w];\n\t\t\tbMap = new char[h][w];\n\t\t\twSquare = new boolean[h][w];\n\t\t\tbSquare = new boolean[h][w];\n\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tString s = sc.next();\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\t// a[][]\n\t\t\t\t\ta[i][j] = s.charAt(j);\n\t\t\t\t\twMap[i][j] = a[i][j];\n\t\t\t\t\tbMap[i][j] = a[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tif (a[i][j] == 'B') {\n\t\t\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\t\t\tcountB(i + directions4[k][0], j + directions4[k][1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcountB(i, j);\n\t\t\t\t\t} else if (a[i][j] == 'W') {\n\t\t\t\t\t\tfor (int k = 0; k < 4; k++) {\n\t\t\t\t\t\t\tcountW(i + directions4[k][0], j + directions4[k][1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcountB = 0;\n\t\t\tcountW = 0;\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tif (bSquare[i][j] && !wSquare[i][j]) {\n\t\t\t\t\t\tcountB++;\n\t\t\t\t\t} else if (!bSquare[i][j] && wSquare[i][j]) {\n\t\t\t\t\t\tcountW++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(countB + \" \" + countW);\n\t\t}\n\n\t}\n\n\tstatic void countW(int thisH, int thisW) {\n\t\tif (thisH >= h || thisH < 0 || thisW >= w || thisW < 0 || wSquare[thisH][thisW] || wMap[thisH][thisW] != '.') {\n\t\t\treturn;\n\t\t}\n\t\t// wMap[thisH][thisW] = 'W';\n\t\twSquare[thisH][thisW] = true;\n\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tcountW(thisH + directions4[i][0], thisW + directions4[i][1]);\n\t\t}\n\t}\n\n\tstatic void countB(int thisH, int thisW) {\n\t\tif (thisH >= h || thisH < 0 || thisW >= w || thisW < 0 || bSquare[thisH][thisW] || bMap[thisH][thisW] != '.') {\n\t\t\treturn;\n\t\t}\n\t\tbSquare[thisH][thisW] = true;\n\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tcountB(thisH + directions4[i][0], thisW + directions4[i][1]);\n\t\t}\n\t}\n\n\t// BFS\n\tstatic int[] addArrayElms(int[] a, int[] b) {\n\t\tint[] c = new int[a.length];\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tc[i] = a[i] + b[i];\n\t\t}\n\t\treturn c;\n\t}\n\n\t// //\n\t// k <= num k\n\tstatic private int binarySearch(long num, long[] orderedArray) {\n\t\tint lowerBorder = -1;\n\t\tint upperBorder = orderedArray.length;\n\t\tint mid;\n\n\t\twhile (upperBorder - lowerBorder > 1) {\n\t\t\tmid = (upperBorder + lowerBorder) / 2;\n\t\t\tif (orderedArray[mid] <= num) {\n\t\t\t\tlowerBorder = mid;\n\t\t\t} else {\n\t\t\t\tupperBorder = mid;\n\t\t\t}\n\t\t}\n\t\treturn lowerBorder;\n\t}\n\n\t// \n\t// k <= num Listk\n\tstatic private int binarySearch(long num, ArrayList<Long> orderedList) {\n\t\tint lowerBorder = -1;\n\t\tint upperBorder = orderedList.size();\n\t\tint mid;\n\n\t\twhile (upperBorder - lowerBorder > 1) {\n\t\t\tmid = (upperBorder + lowerBorder) / 2;\n\t\t\tif (orderedList.get(mid) <= num) {\n\t\t\t\tlowerBorder = mid;\n\t\t\t} else {\n\t\t\t\tupperBorder = mid;\n\t\t\t}\n\t\t}\n\t\treturn lowerBorder;\n\t}\n\n\t// ab\n\tpublic static int gcd(int a, int b) {\n\t\treturn b == 0 ? a : gcd(b, a % b);\n\t}\n\n\tpublic static long gcd(long a, long b) {\n\t\treturn b == 0 ? a : gcd(b, a % b);\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\npublic class Main\n{\n\tstatic int field[][];\n\tstatic int white=0,black=0,cnt,fb,fw;\n\tstatic int W,H;\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tfor(;;)\n\t\t{\n\t\t\tW=in.nextInt();\n\t\t\tH=in.nextInt();\n\t\t\tif((W|H)==0)\n\t\t\t\treturn;\n\t\t\tfield=new int[H][W];\n\t\t\tfor(int i=0;i<H;i++)\n\t\t\t{\n\t\t\t\tString st=in.next();\n\t\t\t\tfor(int j=0;j<W;j++)\n\t\t\t\t{\n\t\t\t\t\tif(st.charAt(j)=='.')\n\t\t\t\t\t\tfield[i][j]=0;\n\t\t\t\t\telse if(st.charAt(j)=='W')\n\t\t\t\t\t\tfield[i][j]=1;\n\t\t\t\t\telse if(st.charAt(j)=='B')\n\t\t\t\t\t\tfield[i][j]=2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tblack=0;\n\t\t\twhite=0;\n\t\t\tfor(int i=0;i<H;i++)\n\t\t\t{\n\t\t\t\tfor(int j=0;j<W;j++)\n\t\t\t\t{\n\t\t\t\t\tcnt=0;\n\t\t\t\t\tfb=0;\n\t\t\t\t\tfw=0;\n\t\t\t\t\tif(field[i][j]==0)\n\t\t\t\t\t\tsolve(i,j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(black+\" \"+white);\n\t\t}\t\n\t}\n\tpublic static void solve(int h,int w)\n\t{\n\t\tfield[h][w]=3;\n\t\tcnt++;\n\t\tif(h-1>=0&&field[h-1][w]==1)\n\t\t\tfw=1;\n\t\tif(h-1>=0&&field[h-1][w]==2)\n\t\t\tfb=1;\n\t\tif(h+1<H&&field[h+1][w]==1)\n\t\t\tfw=1;\n\t\tif(h+1<H&&field[h+1][w]==2)\n\t\t\tfb=1;\n\t\tif(w-1>=0&&field[h][w-1]==1)\n\t\t\tfw=1;\n\t\tif(w-1>=0&&field[h][w-1]==2)\n\t\t\tfb=1;\n\t\tif(w+1<W&&field[h][w+1]==1)\n\t\t\tfw=1;\n\t\tif(w+1<W&&field[h][w+1]==2)\n\t\t\tfb=1;\n\t\tif(h-1>=0&&w-1>=0&&field[h-1][w-1]==1)\n\t\t\tfw=1;\n\t\tif(h-1>=0&&w-1>=0&&field[h-1][w-1]==2)\n\t\t\tfb=1;\n\t\tif(h-1>=0&&w+1<W&&field[h-1][w+1]==1)\n\t\t\tfw=1;\n\t\tif(h-1>=0&&w+1<W&&field[h-1][w+1]==2)\n\t\t\tfb=1;\n\t\tif(h+1<H&&w+1<W&&field[h+1][w+1]==1)\n\t\t\tfw=1;\n\t\tif(h+1<H&&w+1<W&&field[h+1][w+1]==2)\n\t\t\tfb=1;\n\t\tif(h+1<H&&w-1>=0&&field[h+1][w-1]==1)\n\t\t\tfw=1;\n\t\tif(h+1<H&&w-1>=0&&field[h+1][w-1]==2)\n\t\t\tfb=1;\n\t\t\n\t\tif(h-1>=0&&field[h-1][w]==0)\n\t\t\tsolve(h-1,w);\n\t\tif(h+1<H&&field[h+1][w]==0)\n\t\t\tsolve(h+1,w);\n\t\tif(w-1>=0&&field[h][w-1]==0)\n\t\t\tsolve(h,w-1);\n\t\tif(w+1<W&&field[h][w+1]==0)\n\t\t\tsolve(h,w+1);\n\n\t\tif(fw==1&&fb==0)\n\t\t{\n\t\t\twhite+=cnt;\n\t\t\tcnt=0;\n\t\t\treturn;\n\t\t}\n\t\telse if(fw==0&&fb==1)\n\t\t{\n\t\t\tblack+=cnt;\n\t\t\tcnt=0;\n\t\t\treturn;\n\t\t}\n\t\telse if(fw==1&&fb==1)\n\t\t{\n\t\t\tcnt=0;\n\t\t\treturn;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n\npublic class Main{\n\nstatic PrintWriter out;\nstatic InputReader ir;\n\nstatic void solve(){\n for(;;){\n  w=ir.nextInt();\n  h=ir.nextInt();\n  if(w==0&&h==0) return;\n  map=ir.nextCharMap(h,w);\n  cnd=new int[h][w];\n  for(int i=0;i<h;i++){\n   for(int j=0;j<w;j++){\n    if(map[i][j]!='.') bfs(i,j,map[i][j]=='B'?1:2);\n   }\n  }\n  int bl=0,wh=0;\n  for(int i=0;i<h;i++){\n   for(int j=0;j<w;j++){\n    if(cnd[i][j]==1) bl++;\n    if(cnd[i][j]==2) wh++;\n   }\n  }\n  out.println(bl+\" \"+wh);\n }\n}\n\nstatic final int[] dd=new int[]{0,-1,0,1};\nstatic int w,h\nstatic char[][] map;\nstatic int[][] cnd;\nstatic Deque<int[]> que=new ArrayDeque<>();\n\npublic static boolean in(int x,int y){\n return (x>=0&&y>=0&&x<h&&y<w);\n}\n\npublic static void bfs(int x,int y,int m){\n for(int i=0;i<4;i++){\n  int nx=x+dd[i],ny=y+dd[i^1];\n  if(!in(nx,ny,h,w)) continue;\n  if(map[nx][ny]=='.'&&(cnd[nx][ny]&m)==0) que.offerLast(new int[]{nx,ny});\n }\n while(!que.isEmpty()){\n  int[] p=que.pollFirst();\n  int px=p[0],py=p[1];\n  cnd[px][py]|=m;\n  for(int i=0;i<4;i++){\n   int nx=px+dd[i],ny=py+dd[i^1];\n   if(!in(nx,ny,h,w)) continue;\n   if(map[nx][ny]=='.'&&(cnd[nx][ny]&m)==0) que.offerLast(new int[]{nx,ny});\n  }\n }\n}\n\npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n\nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n\n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n\n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n \n public boolean hasNext(){skip(); return hasNextByte();}\n \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n\n public double nextDouble(){return Double.parseDouble(next());}\n\n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n\n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n\n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.util.Scanner;\n\npublic class Main{\n\tint nx;\n\tint ny;\n\tint[] dx = {0,-1,0,1};\n\tint[] dy = {1,0,-1,0};\n\tchar[][] map;\n\tboolean flagW ;\n\tboolean flagB ;\n\tint res = 0;\n\n\n\tvoid dfs(int y, int x){\n\t\tint sx;\n\t\tint sy;\n\t\tmap[y][x] = 'X';\n\n\t\tfor(int i=0; i<4; i++){\n\t\t\tsy = y + dy[i];\n\t\t\tsx = x + dx[i];\n\t\t\tif(sx < 0 || sy <0 || sx >= nx || sy >= ny) continue;\n\n\t\t\tif(map[sy][sx] == '.'){\n\t\t\t\tres++;\n\t\t\t\tdfs(sy,sx);\n\t\t\t}\n\t\t\telse if(map[sy][sx] == 'W')\n\t\t\t\tflagW = true;\n\n\t\t\telse if(map[sy][sx] == 'B')\n\t\t\t\tflagB = true;\n\t\t}\n\n\t}\n\n\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\n\n\t\twhile (sc.hasNext()) {\n\t\t\tnx = sc.nextInt();\n\t\t\tny = sc.nextInt();\n\t\t\tString p = sc.nextLine();\n\n\t\t\tint cntW = 0;\n\t\t\tint cntB = 0;\n\t\t\tmap = new char[ny][];\n\n\n\t\t\tfor (int i = 0; i < ny; i++) {\n\t\t\t\tString s = sc.nextLine();\n\t\t\t\tmap[i] = s.toCharArray();\n\t\t\t}\n\n\n\n\t\t\tfor (int i = 0; i < ny; i++) {\n\t\t\t\tfor (int j = 0; j < nx; j++) {\n\t\t\t\t\tif (map[i][j] != '.')\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tflagW = false;\n\t\t\t\t\tflagB = false;\n\t\t\t\t\tres = 1;\n\n\t\t\t\t\tdfs(i, j);\n\n\t\t\t\t\tif (flagW && !flagB)\n\t\t\t\t\t\tcntW += res;\n\t\t\t\t\tif (flagB && !flagW)\n\t\t\t\t\t\tcntB += res;\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(cntB + \" \" + cntW);\n\t\t}\n\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    int h, w;\n    char[][] map;\n    boolean B, W;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        while(true){\n            w = sc.nextInt(); h = sc.nextInt();\n            if(w==0 && h==0) break;\n            map = new char[h][w];\n            for(int i=0; i<h; i++) map[i] = sc.next().toCharArray();\n\n            int cntB = 0, cntW = 0;\n            for(int i=0; i<h; i++){\n                for(int j=0; j<w; j++){\n                    if(map[i][j]!='.') continue;\n                    B = false;\n                    W = false;\n                    int cnt = bfs(i, j);\n                    if(B && !W) cntB+=cnt;\n                    if(!B && W) cntW+=cnt;\n                }\n            }\n            System.out.println(cntB+\" \"+cntW);\n        }\n    }\n\n    int[] dx = {0, 0, 1, -1};\n    int[] dy = {1, -1, 0, 0};\n    int bfs(int y, int x){\n        LinkedList<int[]> q = new LinkedList<int[]>();\n        q.add(new int[]{x, y});\n        boolean[][] v = new boolean[h][w];\n        int cnt = 0;\n\n        while(q.size()>0){\n            int[] qq = q.poll();\n            int X = qq[0], Y = qq[1];\n\n            if(v[Y][X]) continue;\n            v[Y][X] = true;\n\n            if(map[Y][X]=='W') {W = true; continue;}\n            if(map[Y][X]=='B') {B = true; continue;}\n\n            cnt++;\n            map[Y][X] = 'x';\n\n            for(int i=0; i<4; i++){\n                int nx = X + dx[i], ny = Y + dy[i];\n                if(nx<0 || nx>=w || ny<0 || ny>=h) continue;\n                q.add(new int[]{nx, ny});\n            }\n        }\n        return cnt;\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tScanner sc = new Scanner(System.in);\n\tpublic void run() {\n\t\twhile(sc.hasNext()){\n\t\t\tint w = sc.nextInt();\n\t\t\tint h = sc.nextInt();\n\t\t\tif(w == 0 && h == 0) break;\n\t\t\telse calc(w,h);\n\t\t}\n\t}\n\tpublic void calc(int w, int h){\n\t\tint[][] map = new int[w][h];\n\t\tint[][] blacks = new int[w][h];\n\t\tint[][] whites = new int[w][h];\n\t\tArrayList<int[]> wList = new ArrayList<int[]>();\n\t\tArrayList<int[]> bList = new ArrayList<int[]>();\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tString next = sc.next();\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tchar c = next.charAt(j);\n\t\t\t\tif(c == 'W'){\n\t\t\t\t\tmap[j][i] = 1;\n\t\t\t\t\tblacks[j][i] = 1;\n\t\t\t\t\twList.add(new int[]{j, i});\n\t\t\t\t}\n\t\t\t\telse if(c == 'B'){\n\t\t\t\t\tmap[j][i] = -1;\n\t\t\t\t\tbList.add(new int[]{j, i});\n\t\t\t\t\twhites[j][i] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\twhile(!wList.isEmpty()){\n\t\t\tint nowW = wList.get(0)[0];\n\t\t\tint nowH = wList.get(0)[1];\n\t\t\twList.remove(0);\n\t\t\t\n\t\t\tif(nowW > 0 && map[nowW-1][nowH] == 0 &&  whites[nowW-1][nowH] == 0){\n\t\t\t\twhites[nowW-1][nowH] = 1;\n\t\t\t\twList.add(new int[]{nowW-1, nowH});\n\t\t\t}\n\t\t\tif(nowW < w-1 && map[nowW+1][nowH] == 0 && whites[nowW+1][nowH] == 0){\n\t\t\t\twhites[nowW+1][nowH] = 1;\n\t\t\t\twList.add(new int[]{nowW+1, nowH});\n\t\t\t}\n\t\t\tif(nowH > 0 && map[nowW][nowH-1] == 0 &&  whites[nowW][nowH-1] == 0){\n\t\t\t\twhites[nowW][nowH-1] = 1;\n\t\t\t\twList.add(new int[]{nowW, nowH-1});\n\t\t\t}\n\t\t\tif(nowH < h-1 && map[nowW][nowH+1] == 0 && whites[nowW][nowH+1] == 0){\n\t\t\t\twhites[nowW][nowH+1] = 1;\n\t\t\t\twList.add(new int[]{nowW, nowH+1});\n\t\t\t}\n\t\t\t\n\t\t}\n\t\twhile(!bList.isEmpty()){\n\t\t\tint nowW = bList.get(0)[0];\n\t\t\tint nowH = bList.get(0)[1];\n\t\t\tbList.remove(0);\n\t\t\t\n\t\t\tif(nowW > 0 && map[nowW-1][nowH] == 0 &&  blacks[nowW-1][nowH] == 0){\n\t\t\t\tblacks[nowW-1][nowH] = 1;\n\t\t\t\tbList.add(new int[]{nowW-1, nowH});\n\t\t\t}\n\t\t\tif(nowW < w-1 && map[nowW+1][nowH] == 0 && blacks[nowW+1][nowH] == 0){\n\t\t\t\tblacks[nowW+1][nowH] = 1;\n\t\t\t\tbList.add(new int[]{nowW+1, nowH});\n\t\t\t}\n\t\t\tif(nowH > 0 && map[nowW][nowH-1] == 0 &&  blacks[nowW][nowH-1] == 0){\n\t\t\t\tblacks[nowW][nowH-1] = 1;\n\t\t\t\tbList.add(new int[]{nowW, nowH-1});\n\t\t\t}\n\t\t\tif(nowH < h-1 && map[nowW][nowH+1] == 0 && blacks[nowW][nowH+1] == 0){\n\t\t\t\tblacks[nowW][nowH+1] = 1;\n\t\t\t\tbList.add(new int[]{nowW, nowH+1});\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\t\n\t\tint black = 0;\n\t\tint white = 0;\n\t\tfor(int i = 0; i < w; i++){\n\t\t\tfor(int j = 0; j < h; j++){\n\t\t\t\tif(map[i][j] == 0 && \n\t\t\t\t\t\t((blacks[i][j] == 1 && whites[i][j] == 0) || (blacks[i][j] == 0 && whites[i][j] == 1)) ){\n\t\t\t\t\tif(blacks[i][j] == 1) black++;\n\t\t\t\t\telse white++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(black + \" \"+ white);\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n\npublic class Main{\n\nstatic PrintWriter out;\nstatic InputReader ir;\n\nstatic void solve(){\n for(;;){\n  int w=ir.nextInt();\n  int h=ir.nextInt();\n  if(w==0&&h==0) return;\n  char[][] map=ir.nextCharMap(h,w);\n  int[][] cnd=new int[h][w];\n  for(int i=0;i<h;i++){\n   for(int j=0;j<w;j++){\n    if(map[i][j]!='.') bfs(i,j,map[i][j]=='B'?1:2,map,cnd);\n   }\n  }\n  int bl=0,wh=0;\n  for(int i=0;i<h;i++){\n   for(int j=0;j<w;j++){\n    if(cnd[i][j]==1) bl++;\n    if(cnd[i][j]==2) wh++;\n   }\n  }\n  out.println(bl+\" \"+wh);\n }\n}\n\nstatic final int[] dd=new int[]{0-1,0,1};\n\npublic static boolean in(int x,int y,int h,int w){\n return (x>=0&&y>=0&&x<h&&y<w);\n}\n\npublic static void bfs(int x,int y,int m,char[][] map,int[][] cnd){\n int h=map.length,w=map[0].length;\n Deque<int[]> que=new ArrayDeque<>();\n for(int i=0;i<4;i++){\n  int nx=x+dd[i],ny=y+dd[i^1];\n // if(!in(nx,ny,h,w)) continue;\n // if(map[nx][ny]=='.'&&(cnd[nx][ny]&m)==0) que.offerLast(new int[]{nx,ny});\n }\n /*while(!que.isEmpty()){\n  int[] p=que.pollFirst();\n  int px=p[0],py=p[1];\n  cnd[px][py]|=m;\n  for(int i=0;i<4;i++){\n   int nx=px+dd[i],ny=py+dd[i^1];\n   if(!in(nx,ny,h,w)) continue;\n   if(map[nx][ny]=='.'&&(cnd[nx][ny]&m)==0) que.offerLast(new int[]{nx,ny});\n  }\n }*/\n}\n\npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n\nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n\n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n\n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n \n public boolean hasNext(){skip(); return hasNextByte();}\n \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n\n public double nextDouble(){return Double.parseDouble(next());}\n\n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n\n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n\n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n\npublic class Main{\n\nstatic PrintWriter out;\nstatic InputReader ir;\n\nstatic void solve(){\n for(;;){\n  w=ir.nextInt();\n  h=ir.nextInt();\n  if(w==0&&h==0) return;\n  map=ir.nextCharMap(h,w);\n  cnd=new int[h][w];\n  for(int i=0;i<h;i++){\n   for(int j=0;j<w;j++){\n    if(map[i][j]=='.'){\n     int ret=dfs(i,j);\n     if(ret==1) bl++;\n     if(ret==2) wh++;\n    }\n   }\n  }\n  int bl=0,wh=0;\n  for(int i=0;i<h;i++){\n   for(int j=0;j<w;j++){\n    if(cnd[i][j]==1) bl++;\n    if(cnd[i][j]==2) wh++;\n   }\n  }\n  out.println(bl+\" \"+wh);\n }\n}\n\nstatic final int[] dd=new int[]{0,-1,0,1};\nstatic int w,h;\nstatic char[][] map;\nstatic int[][] cnd;\n\npublic static boolean in(int x,int y){\n return (x>=0&&y>=0&&x<h&&y<w);\n}\n\npublic static int dfs(int x,int y,int m){\n if(map[x][y]=='B') return 1;\n if(map[x][y]=='W') return 2;\n int ret=0;\n for(int i=0;i<4;i++){\n  int nx=x+dd[i],ny=y+dd[i^1];\n  if(!in(nx,ny)) ret|=dfs(nx,ny,m);\n }\n return ret;\n}\n\npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n\nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n\n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n\n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n \n public boolean hasNext(){skip(); return hasNextByte();}\n \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n\n public double nextDouble(){return Double.parseDouble(next());}\n\n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n\n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n\n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n\npublic class Main{\n\nstatic PrintWriter out;\nstatic InputReader ir;\n\nstatic void solve(){\n for(;;){\n  int w=ir.nextInt();\n  int h=ir.nextInt();\n  if(w==0&&h==0) return;\n  map=ir.nextCharMap(h,w);\n  cnd=new int[h][w];\n  for(int i=0;i<h;i++){\n   for(int j=0;j<w;j++){\n    if(map[i][j]!='.') bfs(i,j,map[i][j]=='B'?1:2);\n   }\n  }\n  int bl=0,wh=0;\n  for(int i=0;i<h;i++){\n   for(int j=0;j<w;j++){\n    if(cnd[i][j]==1) bl++;\n    if(cnd[i][j]==2) wh++;\n   }\n  }\n  out.println(bl+\" \"+wh);\n }\n}\n\nstatic final int[] dd=new int[]{0,-1,0,1};\nstatic char[][] map;\nstatic int[][] cnd;\nstatic Deque<int[]> que=new ArrayDeque<>();\n\npublic static boolean in(int x,int y,int h,int w){\n return (x>=0&&y>=0&&x<h&&y<w);\n}\n\npublic static void bfs(int x,int y,int m){\n int h=map.length,w=map[0].length;\n for(int i=0;i<4;i++){\n  int nx=x+dd[i],ny=y+dd[i^1];\n  if(!in(nx,ny,h,w)) continue;\n  if(map[nx][ny]=='.'&&(cnd[nx][ny]&m)==0) que.offerLast(new int[]{nx,ny});\n }\n while(!que.isEmpty()){\n  int[] p=que.pollFirst();\n  int px=p[0],py=p[1];\n  cnd[px][py]|=m;\n  for(int i=0;i<4;i++){\n   int nx=px+dd[i],ny=py+dd[i^1];\n   if(!in(nx,ny,h,w)) continue;\n   if(map[nx][ny]=='.'&&(cnd[nx][ny]&m)==0) que.offerLast(new int[]{nx,ny});\n  }\n }\n}\n\npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n\nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n\n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n\n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n \n public boolean hasNext(){skip(); return hasNextByte();}\n \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n\n public double nextDouble(){return Double.parseDouble(next());}\n\n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n\n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n\n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\tpublic Main() {\n\t\tnew A().doIt();\n\t}\n\n\tclass A{\n\t\tint w,h;\n\t\tchar[][] map;\n\t\tchar[][] memo;\n\t\tboolean wsw,bsw;\n\t\tboolean come[][];\n\t\tint sx[] = {1,0,-1,0};\n\t\tint sy[] = {0,1,0,-1};\n\t\tvoid dfs(int x,int y){\n\t\t\tif(map[y][x]=='W'){\n\t\t\t\twsw=true;return;\n\t\t\t}else if(map[y][x]=='B'){\n\t\t\t\tbsw=true;return;\n\t\t\t}\n\t\t\tif(come[y][x])return;\n\t\t\tcome[y][x]=true;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint nx=x+sx[i];\n\t\t\t\tint ny=y+sy[i];\n\t\t\t\tif(nx<0||nx>=w||ny<0||ny>=h)continue;\n\t\t\t\tdfs(nx,ny);\n\t\t\t}\n\t\t}\n\t\t\n\t\tvoid dfs2(int x,int y,char a){\n\t\t\tif(map[y][x]=='W'||map[y][x]=='B')return;\n\t\t\tif(memo[y][x]=='w'||memo[y][x]=='b'||memo[y][x]=='.')return;\n\t\t\tmemo[y][x]=a;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint nx=x+sx[i];\n\t\t\t\tint ny=y+sy[i];\n\t\t\t\tif(nx<0||nx>=w||ny<0||ny>=h)continue;\n\t\t\t\tdfs2(nx,ny,a);\n\t\t\t}\n\t\t}\n\t\t\n\t\tvoid solve(){\n\t\t\tmemo = new char[h][w];\n\t\t\tfor(int i=0;i<h;i++)Arrays.fill(memo[i], ' ');\n\t\t\tfor(int i=0;i<h;i++)for(int s=0;s<w;s++)if(memo[i][s]==' '){\n\t\t\t\twsw = false;bsw = false;\n\t\t\t\tcome = new boolean[h][w];\n\t\t\t\tdfs(s,i);\n\t\t\t\tchar target = '.';\n\t\t\t\tif(wsw&&!bsw)target='w';\n\t\t\t\telse if(!wsw&&bsw)target='b';\n\t\t\t\tdfs2(s, i, target);\n\t\t\t}\n\t\t\t\n//\t\t\tfor(int i=0;i<h;i++){\n//\t\t\t\tfor(int s=0;s<w;s++)System.out.print(memo[i][s]);\n//\t\t\t\tSystem.out.println();\n//\t\t\t}\n//\t\t\t\n\t\t\tint white=0,black=0;\n\t\t\tfor(int i=0;i<h;i++)for(int s=0;s<w;s++){\n\t\t\t\tif(memo[i][s]=='w')white++;\n\t\t\t\telse if(memo[i][s]=='b')black++;\n\t\t\t}\n\t\t\tSystem.out.println(black+\" \"+white);\n\t\t}\n\t\t\n\t\tvoid doIt(){\n\t\t\twhile(in.hasNext()){\n\t\t\t\tw = in.nextInt(); h = in.nextInt();\n\t\t\t\tif(w+h==0)break;\n\t\t\t\tmap = new char[h][w];\n\t\t\t\tfor(int i=0;i<h;i++)map[i]= in.next().toCharArray(); \n\t\t\t\tsolve();\n\t\t\t}\n\n\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n\npublic class Main{\n\nstatic PrintWriter out;\nstatic InputReader ir;\n\nstatic void solve(){\n for(;;){\n  int w=ir.nextInt();\n  int h=ir.nextInt();\n  if(w==0&&h==0) return;\n  char[][] map=ir.nextCharMap(h,w);\n  int[][] cnd=new int[h][w];\n  /*for(int i=0;i<h;i++){\n   for(int j=0;j<w;j++){\n    if(map[i][j]!='.') bfs(i,j,map[i][j]=='B'?1:2,map,cnd);\n   }\n  }*/\n  int bl=0,wh=0;\n  for(int i=0;i<h;i++){\n   for(int j=0;j<w;j++){\n    if(cnd[i][j]==1) bl++;\n    if(cnd[i][j]==2) wh++;\n   }\n  }\n  out.println(bl+\" \"+wh);\n }\n}\n\nstatic final int[] dd=new int[]{0-1,0,1};\n\npublic static boolean in(int x,int y,int h,int w){\n return (x>=0&&y>=0&&x<h&&y<w);\n}\n\npublic static void bfs(int x,int y,int m,char[][] map,int[][] cnd){\n int h=map.length,w=map[0].length;\n Deque<int[]> que=new ArrayDeque<>();\n for(int i=0;i<4;i++){\n  int nx=x+dd[i],ny=y+dd[i^1];\n  if(in(nx,ny,h,w)&&map[nx][ny]=='.'&&(cnd[nx][ny]&m)==0) que.offerLast(new int[]{nx,ny});\n }\n while(!que.isEmpty()){\n  int[] p=que.pollFirst();\n  int px=p[0],py=p[1];\n  cnd[px][py]|=m;\n  for(int i=0;i<4;i++){\n   int nx=px+dd[i],ny=py+dd[i^1];\n   if(in(nx,ny,h,w)&&map[nx][ny]=='.'&&(cnd[nx][ny]&m)==0) que.offerLast(new int[]{nx,ny});\n  }\n }\n}\n\npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n\nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n\n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n\n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n \n public boolean hasNext(){skip(); return hasNextByte();}\n \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n\n public double nextDouble(){return Double.parseDouble(next());}\n\n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n\n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n\n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n\npublic class Main{\n\nstatic PrintWriter out;\nstatic InputReader ir;\n\nstatic void solve(){\n for(;;){\n  int w=ir.nextInt();\n  int h=ir.nextInt();\n  if(w==0&&h==0) return;\n  char[][] map=ir.nextCharMap(h,w);\n  int[][] cnd=new int[h][w];\n  for(int i=0;i<h;i++){\n   for(int j=0;j<w;j++){\n    if(map[i][j]!='.') bfs(i,j,map[i][j]=='B'?1:2,map,cnd);\n   }\n  }\n  int bl=0,wh=0;\n  for(int i=0;i<h;i++){\n   for(int j=0;j<w;j++){\n    if(cnd[i][j]==1) bl++;\n    if(cnd[i][j]==2) wh++;\n   }\n  }\n  out.println(bl+\" \"+wh);\n }\n}\n\nstatic final int[] dd=new int[]{0,-1,0,1};\n\npublic static boolean in(int x,int y,int h,int w){\n return (x>=0&&y>=0&&x<h&&y<w);\n}\n\npublic static void bfs(int x,int y,int m,char[][] map,int[][] cnd){\n int h=map.length,w=map[0].length;\n Deque<int[]> que=new ArrayDeque<>();\n for(int i=0;i<4;i++){\n  int nx=x+dd[i],ny=y+dd[i^1];\n  if(!in(nx,ny,h,w)) continue;\n  if(map[nx][ny]=='.'&&(cnd[nx][ny]&m)==0) que.offerLast(new int[]{nx,ny});\n }\n /*while(!que.isEmpty()){\n  int[] p=que.pollFirst();\n  int px=p[0],py=p[1];\n  cnd[px][py]|=m;\n  for(int i=0;i<4;i++){\n   int nx=px+dd[i],ny=py+dd[i^1];\n   if(!in(nx,ny,h,w)) continue;\n   if(map[nx][ny]=='.'&&(cnd[nx][ny]&m)==0) que.offerLast(new int[]{nx,ny});\n  }\n }*/\n}\n\npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n\nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n\n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n\n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n \n public boolean hasNext(){skip(); return hasNextByte();}\n \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n\n public double nextDouble(){return Double.parseDouble(next());}\n\n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n\n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n\n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main{\n\tstatic int[][] map;\n\tstatic int[][] used;\n\tstatic int w, h;\n\tpublic static void main(String[] args) throws IOException{\n\t\tScanner in = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tw = in.nextInt();\n\t\t\th = in.nextInt();\n\t\t\tif(w == 0) break;\n\t\t\tmap = new int[h][w];\n\t\t\tused = new int[h][w];\n\t\t\tchecked = new int[h][w];\n\t\t\tfor(int i=0; i<h; i++){\n\t\t\t\tchar[] s = in.next().toCharArray();\n\t\t\t\tfor(int j=0; j<w; j++){\n\t\t\t\t\tmap[i][j] = s[j]=='.'?0:s[j]=='W'?1:2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tturn = 1;\n\t\t\tfor(int i=0; i<h; i++){\n\t\t\t\tfor(int j=0; j<w; j++){\n\t\t\t\t\tif(map[i][j] == 0) continue;\n\t\t\t\t\tint color = map[i][j];\n\t\t\t\t\tfor(int k=0; k<4; k++){\n\t\t\t\t\t\tint nx = j+dx[k];\n\t\t\t\t\t\tint ny = i+dy[k];\n\t\t\t\t\t\tif(out(nx, ny) || map[ny][nx] != 0) continue;\n\t\t\t\t\t\tif(checked[ny][nx] != 0) continue;\n\t\t\t\t\t\tif(dfs(nx, ny, color)){\n\t\t\t\t\t\t\tcheck(nx, ny, color);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tturn++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint white = 0;\n\t\t\tint black = 0;\n\t\t\tfor(int i=0; i<h; i++){\n\t\t\t\tfor(int j=0; j<w; j++){\n\t\t\t\t\tif(used[i][j] == 1) white++;\n\t\t\t\t\telse if(used[i][j] == 2) black++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(black+\" \"+white);\n\t\t}\n\t}\n\tstatic int turn;\n\tstatic String dump(int[][] map){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i=0; i<h; i++){\n\t\t\tfor(int j=0; j<w; j++){\n\t\t\t\tsb.append(map[i][j]+\" \");\n\t\t\t}\n\t\t\tsb.append(\"\\n\");\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic void check(int x, int y, int color){\n\t\tif(used[y][x] != 0) return;\n\t\tused[y][x] = color;\n\t\tfor(int i=0; i<4; i++){\n\t\t\tint nx = x+dx[i];\n\t\t\tint ny = y+dy[i];\n\t\t\tif(out(nx, ny) || map[ny][nx] == color) continue;\n\t\t\tcheck(nx, ny, color);\n\t\t}\n\t}\n\t\n\tstatic final int[] dx = {0, 1, 0, -1};\n\tstatic final int[] dy = {1, 0, -1, 0};\n\tstatic int[][] checked;\n\tstatic boolean dfs(int x, int y, int color){\n\t\tif(checked[y][x] == turn) return true;\n\t\telse if(checked[y][x] != 0) return false;\n\t\tchecked[y][x] = turn;\n\t\tfor(int i=0; i<4; i++){\n\t\t\tint nx = x+dx[i];\n\t\t\tint ny = y+dy[i];\n\t\t\tif(out(nx, ny) || map[ny][nx] == color){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(map[ny][nx] == 0){\n\t\t\t\tif(!dfs(nx, ny, color)) return false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tstatic boolean out(int x, int y){\n\t\treturn x<0||x>=w||y<0||y>=h;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n\npublic class Main{\n\nstatic PrintWriter out;\nstatic InputReader ir;\n\nstatic void solve(){\n for(;;){\n  w=ir.nextInt();\n  h=ir.nextInt();\n  if(w==0&&h==0) return;\n  map=ir.nextCharMap(h,w);\n  cnd=new int[h][w];\n  for(int i=0;i<h;i++){\n   for(int j=0;j<w;j++){\n    if(map[i][j]!='.') bfs(i,j,map[i][j]=='B'?1:2);\n   }\n  }\n  int bl=0,wh=0;\n  for(int i=0;i<h;i++){\n   for(int j=0;j<w;j++){\n    if(cnd[i][j]==1) bl++;\n    if(cnd[i][j]==2) wh++;\n   }\n  }\n  out.println(bl+\" \"+wh);\n }\n}\n\nstatic final int[] dd=new int[]{0,-1,0,1};\nstatic int w,h;\nstatic char[][] map;\nstatic int[][] cnd;\nstatic Deque<int[]> que=new ArrayDeque<>();\n\npublic static boolean in(int x,int y){\n return (x>=0&&y>=0&&x<h&&y<w);\n}\n\npublic static void bfs(int x,int y,int m){\n for(int i=0;i<4;i++){\n  int nx=x+dd[i],ny=y+dd[i^1];\n  if(!in(nx,ny,h,w)) continue;\n  if(map[nx][ny]=='.'&&(cnd[nx][ny]&m)==0) que.offerLast(new int[]{nx,ny});\n }\n while(!que.isEmpty()){\n  int[] p=que.pollFirst();\n  int px=p[0],py=p[1];\n  cnd[px][py]|=m;\n  for(int i=0;i<4;i++){\n   int nx=px+dd[i],ny=py+dd[i^1];\n   if(!in(nx,ny,h,w)) continue;\n   if(map[nx][ny]=='.'&&(cnd[nx][ny]&m)==0) que.offerLast(new int[]{nx,ny});\n  }\n }\n}\n\npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n\nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n\n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n\n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n \n public boolean hasNext(){skip(); return hasNextByte();}\n \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n\n public double nextDouble(){return Double.parseDouble(next());}\n\n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n\n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n\n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO \n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile(true){\n\t\t\tint w = sc.nextInt();\n\t\t\tint h = sc.nextInt();\n\n\t\t\tif(w == 0 && h == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tchar matrix[][] = new char[h][w];\n\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tString input = sc.next();\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tmatrix[i][j] = input.charAt(j);\n\t\t\t\t}\n\t\t\t}\n\n//\t\t\tshowMatrix(matrix);\n\t\t\tsolve(matrix);\n\t\t}\n\t}\n\n\tstatic void solve(char[][] matrix){\n\t\tint h = matrix.length;\n\t\tint w = matrix[0].length;\n\n\t\tint[][] resultB = new int[h][w];\n\t\tint[][] resultW = new int[h][w];\n\n\t\tint black = 0;\n\t\tint white = 0;\n\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n//\t\t\t\tif(matrix[i][j] != '.'){\n//\t\t\t\t\tcontinue;\n//\t\t\t\t}\n\t\t\t\tif(matrix[i][j] == 'B'){\n\t\t\t\t\tisExNeighbor(matrix, resultB, j, i, 'B');\n\t\t\t\t}\n\t\t\t\tif(matrix[i][j] == 'W'){\n\t\t\t\t\tisExNeighbor(matrix, resultW, j, i, 'W');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tif(resultB[i][j] == TRUE && resultW[i][j] != TRUE){\n\t\t\t\t\tblack++;\n\t\t\t\t}\n\t\t\t\telse if(resultW[i][j] == TRUE && resultB[i][j] != TRUE){\n\t\t\t\t\twhite++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\t//debug\n//\t\tshowMatrix(resultB);\n//\t\tshowMatrix(resultW);\n\n\t\tSystem.out.println(black+\" \"+white);\n\t}\n\n\tstatic void showMatrix(char[][] matrix){\n\t\tfor(int i = 0; i < matrix.length; i++){\n\t\t\tfor(int j = 0; j < matrix[0].length ; j++){\n\t\t\t\tSystem.out.print(matrix[i][j]+\" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println();\n\n\t}\n\n\tstatic void showMatrix(int[][] matrix){\n\t\tfor(int i = 0; i < matrix.length; i++){\n\t\t\tfor(int j = 0; j < matrix[0].length ; j++){\n\t\t\t\tSystem.out.print(matrix[i][j]+\" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println();\n\n\t}\n\n\tstatic final int TRUE = 2;\n\tstatic final int FALSE = 1;\n\tstatic final int NOT_VISITED = 0;\n\tstatic final int JUDGE = 4;\n\tstatic final int DC = 5;\n\tstatic void isExNeighbor(char[][] map, int[][] result, int x, int y, char type){\n//\t\tSystem.out.println(\"x = \"+x+\" y = \"+y);\n\t\tint w = map[0].length;\n\t\tint h = map.length;\n\n\t\tint dx[] = {1, 0, -1, 0};\n\t\tint dy[] = {0, 1, 0, -1};\n\n//\t\tresult[y][x] = JUDGE;\n\t\tif(map[y][x] == type){\n\t\t\tresult[y][x] = DC;\n\t\t}\n\t\telse {\n\t\t\tresult[y][x] = TRUE;\n\t\t}\n\n\t\tfor(int i = 0; i < 4; i++){\n\t\t\tint tmpX = x + dx[i];\n\t\t\tint tmpY = y + dy[i];\n\n\t\t\tif(!inRange(tmpX, tmpY, h, w)){\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif(map[tmpY][tmpX] == '.' && result[tmpY][tmpX] == NOT_VISITED){\n\t\t\t\tisExNeighbor(map, result, tmpX, tmpY, type);\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic boolean inRange(int x, int y, int h, int w){\n\t\tif(x >= 0 && x < w && y >= 0 && y < h){\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\t\n\tstatic int h;\n\tstatic int w;\n\tstatic int cnt = 0;\n\tstatic char[][] g;\n\tstatic boolean[][] v;\n\tstatic boolean wbool;\n\tstatic boolean bbool;\n\t\n\tstatic void dfs(int i, int j) {\n\t\tif(v[i][j]) return;\n\t\tif(g[i][j] == 'W') {\n\t\t\twbool = true;\n\t\t\treturn;\n\t\t}\n\t\tif(g[i][j] == 'B') {\n\t\t\tbbool = true;\n\t\t\treturn;\n\t\t}\n\t\tif(g[i][j] != '.') return;\n\t\tv[i][j] = true;\n\t\tcnt++;\n\t\tif(i > 0) dfs(i-1, j);\n\t\tif(i < h-1) dfs(i+1, j);\n\t\tif(j > 0) dfs(i, j-1);\n\t\tif(j < w-1) dfs(i, j+1);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif(w + h == 0) break;\n\t\t\tg = new char[h+1][w+1];\n\t\t\tv = new boolean[h+1][w+1];\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tg[i] = sc.next().toCharArray();\n\t\t\t}\n\t\t\t\n\t\t\tint hcnt = 0;\n\t\t\tint bcnt = 0;\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\t\tif(g[i][j] == '.' && v[i][j] == false) {\n\t\t\t\t\t\twbool =false;\n\t\t\t\t\t\tbbool = false;\n\t\t\t\t\t\tcnt = 0;\n\t\t\t\t\t\tdfs(i, j);\n\t\t\t\t\t\tif(wbool && !bbool) {\n\t\t\t\t\t\t\thcnt += cnt;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(bbool && !wbool) {\n\t\t\t\t\t\t\tbcnt += cnt;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(bcnt + \" \" + hcnt);\n\t\t}\n\n\t}\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n  Scanner sc;\n\n  class Point {\n    int x, y;\n\n    Point(int x_, int y_) {\n      x = x_;\n      y = y_;\n    }\n  }\n\n  int[][] ofs = new int[][] { { 0, 1 }, { 1, 0 }, { -1, 0 }, { 0, -1 } };\n\n  void run() {\n    for ( ;; ) {\n      int w, h;\n      w = ni();\n      h = ni();\n      if ( w == 0 ) {\n        break;\n      }\n\n      boolean[][] W = new boolean[h + 2][w + 2];\n      boolean[][] B = new boolean[h + 2][w + 2];\n      char[][] field = new char[h + 2][w + 2];\n      Queue<Point> wq = new LinkedList<Point>();\n      Queue<Point> bq = new LinkedList<Point>();\n      for ( int i = 1; i <= h; ++i ) {\n        char[] str = sc.next().toCharArray();\n        for ( int j = 1; j <= w; ++j ) {\n          field[ i ][ j ] = str[ j - 1 ];\n          if ( field[ i ][ j ] == 'W' ) {\n            wq.add( new Point( j, i ) );\n          }\n          if ( field[ i ][ j ] == 'B' ) {\n            bq.add( new Point( j, i ) );\n          }\n        }\n      }\n\n      while (wq.size() > 0) {\n        Point e = wq.poll();\n        for ( int[] v : ofs ) {\n          Point np = new Point( e.x + v[ 0 ], e.y + v[ 1 ] );\n          if ( field[ np.y ][ np.x ] == '.' && !W[ np.y ][ np.x ] ) {\n            wq.add( np );\n            W[ np.y ][ np.x ] |= true;\n          }\n        }\n      }\n      while (bq.size() > 0) {\n        Point e = bq.poll();\n        for ( int[] v : ofs ) {\n          Point np = new Point( e.x + v[ 0 ], e.y + v[ 1 ] );\n          if ( field[ np.y ][ np.x ] == '.' && !B[ np.y ][ np.x ] ) {\n            bq.add( np );\n            B[ np.y ][ np.x ] |= true;\n          }\n        }\n      }\n\n      int wc, bc;\n      wc = bc = 0;\n      for ( int i = 1; i <= h; ++i ) {\n        for ( int j = 1; j <= w; ++j ) {\n          if ( W[ i ][ j ] && B[ i ][ j ] )\n            continue;\n          if ( W[ i ][ j ] )\n            ++wc;\n          if ( B[ i ][ j ] )\n            ++bc;\n        }\n      }\n\n      System.out.println( bc + \" \" + wc );\n    }\n  }\n\n  Main() {\n    sc = new Scanner( System.in );\n  }\n\n  int ni() {\n    return sc.nextInt();\n  }\n\n  public static void main(String[] args) {\n    new Main().run();\n  }\n\n  void debug(Object... os) {\n    System.err.println( Arrays.deepToString( os ) );\n  }\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n \npublic class Main{\n \nstatic PrintWriter out;\nstatic InputReader ir;\n \nstatic void solve(){\n for(;;){\n  w=ir.nextInt();\n  h=ir.nextInt();\n  if(w==0&&h==0) return;\n  map=ir.nextCharMap(h,w);\n  cnd=new int[h][w];\n  for(int i=0;i<h;i++){\n   for(int j=0;j<w;j++){\n    if(map[i][j]!='.') bfs(i,j,map[i][j]=='B'?1:2);\n   }\n  }\n  int bl=0,wh=0;\n  for(int i=0;i<h;i++){\n   for(int j=0;j<w;j++){\n    if(cnd[i][j]==1) bl++;\n    if(cnd[i][j]==2) wh++;\n   }\n  }\n  out.println(bl+\" \"+wh);\n }\n}\n \nstatic final int[] dd=new int[]{0,-1,0,1};\nstatic int w,h;\nstatic char[][] map;\nstatic int[][] cnd;\nstatic Deque<int[]> que=new ArrayDeque<>();\n \npublic static boolean in(int x,int y){\n return (x>=0&&y>=0&&x<h&&y<w);\n}\n \npublic static void bfs(int x,int y,int m){\n int nx,ny;\n for(int i=0;i<4;i++){\n  nx=x+dd[i];\n  ny=y+dd[i^1];\n  if(!in(nx,ny)) continue;\n  if((map[nx][ny]=='.')&&((cnd[nx][ny]&m)==0)){\n   cnd[nx][ny]|=m;\n   que.offerLast(new int[]{nx,ny});\n  }\n }\n while(!que.isEmpty()){\n  int[] p=que.pollFirst();\n  cnd[p[0]][p[1]]|=m;\n  for(int i=0;i<4;i++){\n   nx=p[0]+dd[i];\n   ny=p[1]+dd[i^1];\n   if(!in(nx,ny)) continue;\n   if((map[nx][ny]=='.')&&((cnd[nx][ny]&m)==0)){\n//    cnd[nx][ny]|=m;\n    que.offerLast(new int[]{nx,ny});\n   }\n  }\n }\n}\n \npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n \nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n \n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n  \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n \n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n  \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n  \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n  \n public boolean hasNext(){skip(); return hasNextByte();}\n  \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n  \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n  \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public double nextDouble(){return Double.parseDouble(next());}\n \n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n \n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n \n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nimport java.awt.geom.*;\nimport java.math.*;\n\npublic class Main {\n\n\tstatic final Scanner in = new Scanner(System.in);\n\tstatic final PrintWriter out = new PrintWriter(System.out,false);\n\tstatic boolean debug = false;\n\n\tstatic int h, w;\n\tstatic char[][] t, a, b;\n\tstatic int[][] p;\n\n\tstatic int[] dx = { 0, 1, 0,-1};\n\tstatic int[] dy = { 1, 0,-1, 0};\n\n\tstatic void rec1(int cy, int cx) {\n\t\ta[cy][cx] = 'B';\n\t\tfor (int i=0; i<4; i++) {\n\t\t\tint ny = cy + dy[i];\n\t\t\tint nx = cx + dx[i];\n\t\t\tif (ny < 0 || nx < 0 || h <= ny || w <= nx) continue;\n\t\t\tif (a[ny][nx] == '.') {\n\t\t\t\trec1(ny, nx);\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic void rec2(int cy, int cx) {\n\t\tb[cy][cx] = 'W';\n\t\tfor (int i=0; i<4; i++) {\n\t\t\tint ny = cy + dy[i];\n\t\t\tint nx = cx + dx[i];\n\t\t\tif (ny < 0 || nx < 0 || h <= ny || w <= nx) continue;\n\t\t\tif (b[ny][nx] == '.') {\n\t\t\t\trec2(ny, nx);\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic boolean solve() {\n\t\tw = in.nextInt();\n\t\th = in.nextInt();\n\t\tif (w + h == 0) return false;\n\n\t\tt = new char[h][w];\n\t\ta = new char[h][w];\n\t\tb = new char[h][w];\n\n\t\tfor (int i=0; i<h; i++) {\n\t\t\tt[i] = in.next().toCharArray();\n\t\t\tfor (int j=0; j<w; j++) {\n\t\t\t\ta[i][j] = b[i][j] = t[i][j];\n\t\t\t}\n\t\t}\n\n\t\tfor (int i=0; i<h; i++) {\n\t\t\tfor (int j=0; j<w; j++) {\n\t\t\t\tif (t[i][j] == 'B') {\n\t\t\t\t\trec1(i, j);\n\t\t\t\t} else if (t[i][j] == 'W') {\n\t\t\t\t\trec2(i, j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint cntB = 0, cntW = 0;\n\n\t\tfor (int i=0; i<h; i++) {\n\t\t\tfor (int j=0; j<w; j++) {\n\t\t\t\tif (t[i][j] != '.') continue;\n\t\t\t\tif (a[i][j] == 'B' && b[i][j] == '.') {\n\t\t\t\t\tcntB++;\n\t\t\t\t} else if (a[i][j] == '.' && b[i][j] == 'W') {\n\t\t\t\t\tcntW++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tout.println(cntB+\" \"+cntW);\n\n\t\treturn true;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tdebug = args.length > 0;\n\t\tlong start = System.nanoTime();\n\n\t\twhile(solve());\n\t\tout.flush();\n\n\t\tlong end = System.nanoTime();\n\t\tdump((end - start) / 1000000 + \" ms\");\n\t\tin.close();\n\t\tout.close();\n\t}\n\n\tstatic void dump(Object... o) { if (debug) System.err.println(Arrays.deepToString(o)); }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.FileInputStream;\nimport java.io.PrintStream;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int w, h;\n\tstatic int[][] map;\n\t\n\tpublic static void main(String[] args)\n\t{\n\t\t\n\t\tScanner sca = new Scanner(System.in);\n\t\t\n\t\twhile(true)\n\t\t{\n\t\t\tw = sca.nextInt();\n\t\t\th = sca.nextInt();\n\t\t\tif(w == 0) break;\n\t\t\t\n\t\t\tint x, y;\n\t\t\t\n\t\t\tmap = new int[h][w];\n\t\t\tfor(y = 0;y < h;y++)\n\t\t\t{\n\t\t\t\tString text = sca.next();\n\t\t\t\tfor(x = 0;x < w;x++)\n\t\t\t\t{\n\t\t\t\t\tswitch(text.charAt(x))\n\t\t\t\t\t{\n\t\t\t\t\tcase '.': map[y][x] = 0; break;\n\t\t\t\t\tcase 'B': map[y][x] = 1; break;\n\t\t\t\t\tcase 'W': map[y][x] = 2; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tBoolean modify = true;\n\t\t\twhile(modify)\n\t\t\t{\n\t\t\t\tmodify = false;\n\t\t\t\t\n\t\t\t\tfor(y = 0;y < h;y++)\n\t\t\t\t{\n\t\t\t\t\tfor(x = 0;x < w;x++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(map[y][x] == 1 || map[y][x] == 2 || map[y][x] == 5) continue;\n\t\t\t\t\t\t\n\t\t\t\t\t\tint black = 0, white = 0, brank = 0;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(0 < x)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tswitch(map[y][x-1])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t\tblack++;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\t\twhite++;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 5:\n\t\t\t\t\t\t\t\tbrank++;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(0 < y)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tswitch(map[y-1][x])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t\tblack++;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\t\twhite++;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 5:\n\t\t\t\t\t\t\t\tbrank++;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(x < w-1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tswitch(map[y][x+1])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t\tblack++;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\t\twhite++;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 5:\n\t\t\t\t\t\t\t\tbrank++;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(y < h-1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tswitch(map[y+1][x])\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tcase 3:\n\t\t\t\t\t\t\t\tblack++;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 2:\n\t\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\t\twhite++;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 5:\n\t\t\t\t\t\t\t\tbrank++;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(brank > 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmap[y][x] = 5;\n\t\t\t\t\t\t\tmodify = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(black == 0 && white > 0 && map[y][x] != 4)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmap[y][x] = 4;\n\t\t\t\t\t\t\tmodify = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(black > 0 && white == 0 && map[y][x] != 3)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmap[y][x] = 3;\n\t\t\t\t\t\t\tmodify = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(black > 0 && white > 0 && map[y][x] != 5)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmap[y][x] = 5;\n\t\t\t\t\t\t\tmodify = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint black=0, white=0;\n\t\t\tfor(y = 0;y < h;y++)\n\t\t\t{\n\t\t\t\tfor(x = 0;x < w;x++)\n\t\t\t\t{\n\t\t\t\t\tif(map[y][x] == 3)\n\t\t\t\t\t\tblack++;\n\t\t\t\t\telse if(map[y][x] == 4)\n\t\t\t\t\t\twhite++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(black + \" \" + white);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\npublic class Main\n{\n\tstatic int field[][];\n\tstatic int white=0,black=0,cnt,fb,fw;\n\tstatic int W,H;\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tfor(;;)\n\t\t{\n\t\t\tW=in.nextInt();\n\t\t\tH=in.nextInt();\n\t\t\tif((W|H)==0)\n\t\t\t\treturn;\n\t\t\tfield=new int[H][W];\n\t\t\tfor(int i=0;i<H;i++)\n\t\t\t{\n\t\t\t\tString st=in.next();\n\t\t\t\tfor(int j=0;j<W;j++)\n\t\t\t\t{\n\t\t\t\t\tif(st.charAt(j)=='.')\n\t\t\t\t\t\tfield[i][j]=0;\n\t\t\t\t\telse if(st.charAt(j)=='W')\n\t\t\t\t\t\tfield[i][j]=1;\n\t\t\t\t\telse if(st.charAt(j)=='B')\n\t\t\t\t\t\tfield[i][j]=2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tblack=0;\n\t\t\twhite=0;\n\t\t\tfor(int i=0;i<H;i++)\n\t\t\t{\n\t\t\t\tfor(int j=0;j<W;j++)\n\t\t\t\t{\n\t\t\t\t\tcnt=0;\n\t\t\t\t\tfb=0;\n\t\t\t\t\tfw=0;\n\t\t\t\t\tif(field[i][j]==0)\n\t\t\t\t\t\tsolve(i,j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(black+\" \"+white);\n\t\t}\t\n\t}\n\tpublic static void solve(int h,int w)\n\t{\n\t\tfield[h][w]=3;\n\t\tcnt++;\n\t\tif(h-1>=0&&field[h-1][w]==1)\n\t\t\tfw=1;\n\t\tif(h-1>=0&&field[h-1][w]==2)\n\t\t\tfb=1;\n\t\tif(h+1<H&&field[h+1][w]==1)\n\t\t\tfw=1;\n\t\tif(h+1<H&&field[h+1][w]==2)\n\t\t\tfb=1;\n\t\tif(w-1>=0&&field[h][w-1]==1)\n\t\t\tfw=1;\n\t\tif(w-1>=0&&field[h][w-1]==2)\n\t\t\tfb=1;\n\t\tif(w+1<W&&field[h][w+1]==1)\n\t\t\tfw=1;\n\t\tif(w+1<W&&field[h][w+1]==2)\n\t\t\tfb=1;\n\n\t\tif(h-1>=0&&field[h-1][w]==0)\n\t\t\tsolve(h-1,w);\n\t\tif(h+1<H&&field[h+1][w]==0)\n\t\t\tsolve(h+1,w);\n\t\tif(w-1>=0&&field[h][w-1]==0)\n\t\t\tsolve(h,w-1);\n\t\tif(w+1<W&&field[h][w+1]==0)\n\t\t\tsolve(h,w+1);\n\n\t\tif(fw==1&&fb==0)\n\t\t{\n\t\t\twhite+=cnt;\n\t\t\tcnt=0;\n\t\t\treturn;\n\t\t}\n\t\telse if(fw==0&&fb==1)\n\t\t{\n\t\t\tblack+=cnt;\n\t\t\tcnt=0;\n\t\t\treturn;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcnt=0;\n\t\t\treturn;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n\npublic class Main{\n\nstatic PrintWriter out;\nstatic InputReader ir;\n\nstatic void solve(){\n for(;;){\n  int w=ir.nextInt();\n  int h=ir.nextInt();\n  if(w==0&&h==0) return;\n  char[][] map=ir.nextCharMap(h,w);\n  int[][] cnd=new int[h][w];\n  for(int i=0;i<h;i++){\n   for(int j=0;j<w;j++){\n    if(map[i][j]!='.') bfs(i,j,map[i][j]=='B'?1:2,map,cnd);\n   }\n  }\n  int bl=0,wh=0;\n  for(int i=0;i<h;i++){\n   for(int j=0;j<w;j++){\n    if(cnd[i][j]==1) bl++;\n    if(cnd[i][j]==2) wh++;\n   }\n  }\n  out.println(bl+\" \"+wh);\n }\n}\n\nstatic final int[] dd=new int[]{0,-1,0,1};\nstatic Deque<int[]> que=new ArrayDeque<>();\n\npublic static boolean in(int x,int y,int h,int w){\n return (x>=0&&y>=0&&x<h&&y<w);\n}\n\npublic static void bfs(int x,int y,int m,char[][] map,int[][] cnd){\n int h=map.length,w=map[0].length;\n for(int i=0;i<4;i++){\n  int nx=x+dd[i],ny=y+dd[i^1];\n  if(!in(nx,ny,h,w)) continue;\n  if(map[nx][ny]=='.'&&(cnd[nx][ny]&m)==0) que.offerLast(new int[]{nx,ny});\n }\n while(!que.isEmpty()){\n  int[] p=que.pollFirst();\n  int px=p[0],py=p[1];\n  cnd[px][py]|=m;\n  for(int i=0;i<4;i++){\n   int nx=px+dd[i],ny=py+dd[i^1];\n   if(!in(nx,ny,h,w)) continue;\n   if(map[nx][ny]=='.'&&(cnd[nx][ny]&m)==0) que.offerLast(new int[]{nx,ny});\n  }\n }\n}\n\npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n\nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n\n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n\n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n \n public boolean hasNext(){skip(); return hasNextByte();}\n \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n\n public double nextDouble(){return Double.parseDouble(next());}\n\n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n\n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n\n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main {\n\n\tstatic boolean touched[][] = new boolean[55][55];\n\tstatic char board[][] = new char[55][55];\n\tstatic int owner[][] = new int[55][55];\n\tstatic int w, h;\n\tstatic int dx[] = {1,0,-1,0}, dy[] = {0,1,0,-1};\n\n\tpublic static void main(String args[]){\n\t\tScanner in = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tw = in.nextInt();\n\t\t\th = in.nextInt();\n\t\t\tfor(int i=0; i<55; i++)for(int j=0; j<55; j++){\n\t\t\t\tboard[i][j] = '@';\n\t\t\t\towner[i][j] = 0;\n\t\t\t}\n\t\t\tfor(int i=0; i<h; i++){\n\t\t\t\tString str = in.next();\n\t\t\t\tfor(int j=0; j<w; j++){\n\t\t\t\t\tboard[i][j] = str.charAt(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0; i<h; i++){\n\t\t\t\tfor(int j=0; j<w; j++){\n\t\t\t\t\tif(board[i][j] != '.'){\n\t\t\t\t\t\tfor(int ii=0; ii<h; ii++)for(int jj=0;jj<w;jj++) touched[ii][jj] = false;\n\t\t\t\t\t\tfor(int k=0; k<4; k++)dfs(j+dx[k], i+dy[k], board[i][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint black = 0, white = 0;\n\t\t\tfor(int i=0; i<h; i++)\n\t\t\t\tfor(int j=0; j<w; j++)\n\t\t\t\t\tif(owner[i][j]==1) black++;\n\t\t\t\t\telse if(owner[i][j]==2) white++;\n\t\t\t\n\t\t\tSystem.out.println(black + \" \" + white);\n\t\t}\n\t}\n\t\n\tstatic void dfs(int x, int y, char c){\n\t\tif(x<0 || w<=x || y<0 || h<=y) return ;\n\t\ttouched[y][x] = true;\n\t\tif(board[y][x]=='.'){\n\t\t\towner[y][x] |= (c=='B')?1:2;\n\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\tif(!(x+dx[i]<0 || w<=x+dx[i] || y+dy[i]<0 || h<=y+dy[i]) && !touched[y+dy[i]][x+dx[i]]){\n\t\t\t\t\tdfs(x+dx[i], y+dy[i], c);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main { \n\tpublic static boolean[][] wMap;\n\tpublic static boolean[][] bMap;\n\tpublic static boolean[][] wxMap;\n\tpublic static boolean[][] bxMap;\n\tpublic static void main(String[] args) {\n\t\tScanner stdIn = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tint w = stdIn.nextInt();\n\t\t\tint h = stdIn.nextInt();\n\t\t\tif(w == 0 && h == 0) break;\n\t\t\twMap = new boolean[h][w];\n\t\t\tbMap = new boolean[h][w];\n\t\t\twxMap = new boolean[h][w];\n\t\t\tbxMap = new boolean[h][w];\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tString tmp = stdIn.next();\n\t\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\t\tif(tmp.charAt(j) == 'W') {\n\t\t\t\t\t\twMap[i][j] = true;\n\t\t\t\t\t}\n\t\t\t\t\telse if(tmp.charAt(j) == 'B') {\n\t\t\t\t\t\tbMap[i][j] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\t\tif(wMap[i][j]) {\n\t\t\t\t\t\tsolvW(i+1,j);\n\t\t\t\t\t\tsolvW(i-1,j);\n\t\t\t\t\t\tsolvW(i,j+1);\n\t\t\t\t\t\tsolvW(i,j-1);\n\t\t\t\t\t}\n\t\t\t\t\tif(bMap[i][j]) {\n\t\t\t\t\t\tsolvB(i+1,j);\n\t\t\t\t\t\tsolvB(i-1,j);\n\t\t\t\t\t\tsolvB(i,j+1);\n\t\t\t\t\t\tsolvB(i,j-1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint wc = 0;\n\t\t\tint bc = 0;\n\t\t\tfor(int i = 0; i < h; i++) {\n\t\t\t\tfor(int j = 0; j < w; j++) {\n\t\t\t\t\tif(wxMap[i][j] && !bxMap[i][j] &&checkW(i,j)) {\n\t\t\t\t\t\twc++;\n\t\t\t\t\t}\n\t\t\t\t\telse if(bxMap[i][j] && !wxMap[i][j] && checkB(i,j)) {\n\t\t\t\t\t\tbc++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(bc + \" \"+ wc);\n\t\t\t\n\t\t}\n\t}\n\tpublic static void solvW(int i, int j) {\n\t\tif(i < 0 || j < 0 || i >= wMap.length || j >= wMap[i].length) return;\n\t\tif(wMap[i][j] || bMap[i][j]) return;\n\t\tif(wxMap[i][j]) return;\n\t\tboolean isChange = false;\n\t\tif(i != 0 && (wxMap[i-1][j] || wMap[i-1][j])) {\n\t\t\twxMap[i][j] = true;\n\t\t\tisChange = true;\n\t\t}\n\t\telse if(j != 0 && (wxMap[i][j-1] || wMap[i][j-1])) {\n\t\t\twxMap[i][j] = true;\n\t\t\tisChange = true;\n\t\t}\n\t\telse if(i != wxMap.length-1 && (wxMap[i+1][j] || wMap[i+1][j])) {\n\t\t\twxMap[i][j] = true;\n\t\t\tisChange = true;\n\t\t}\n\t\telse if(j != wxMap[i].length-1 && (wxMap[i][j+1] || wMap[i][j+1])) {\n\t\t\twxMap[i][j] = true;\n\t\t\tisChange = true;\n\t\t}\n\t\t\n\t\tif(!isChange) return;\n\t\tsolvW(i+1,j);\n\t\tsolvW(i-1,j);\n\t\tsolvW(i,j+1);\n\t\tsolvW(i,j-1);\n\t}\n\tpublic static void solvB(int i, int j) {\n\t\tif(i < 0 || j < 0 || i >= bMap.length || j >= bMap[i].length) return;\n\t\tif(wMap[i][j] || bMap[i][j]) return;\n\t\tif(bxMap[i][j]) return;\n\t\tboolean isChange = false;\n\t\tif(i != 0 && (bxMap[i-1][j] || bMap[i-1][j])) {\n\t\t\tbxMap[i][j] = true;\n\t\t\tisChange = true;\n\t\t}\n\t\telse if(j != 0 && (bxMap[i][j-1] || bMap[i][j-1])) {\n\t\t\tbxMap[i][j] = true;\n\t\t\tisChange = true;\n\t\t}\n\t\telse if(i != bxMap.length-1 && (bxMap[i+1][j] || bMap[i+1][j])) {\n\t\t\tbxMap[i][j] = true;\n\t\t\tisChange = true;\n\t\t}\n\t\telse if(j != bxMap[i].length-1 && (bxMap[i][j+1] || bMap[i][j+1])) {\n\t\t\tbxMap[i][j] = true;\n\t\t\tisChange = true;\n\t\t}\n\t\t\n\t\tif(!isChange) return;\n\t\tsolvB(i+1,j);\n\t\tsolvB(i-1,j);\n\t\tsolvB(i,j+1);\n\t\tsolvB(i,j-1);\n\t}\n\t\n\tpublic static boolean checkW(int i, int j) {\n\t\tif(i != 0 && bMap[i-1][j]) {\n\t\t\treturn false;\n\t\t}\n\t\telse if(j != 0 && bMap[i][j-1]) {\n\t\t\treturn false;\n\t\t}\n\t\telse if(i != bMap.length-1 && bMap[i+1][j]) {\n\t\t\treturn false;\n\t\t}\n\t\telse if(j != bMap[i].length-1 && bMap[i][j+1]) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\tpublic static boolean checkB(int i, int j) {\n\t\tif(i != 0 && wMap[i-1][j]) {\n\t\t\treturn false;\n\t\t}\n\t\telse if(j != 0 && wMap[i][j-1]) {\n\t\t\treturn false;\n\t\t}\n\t\telse if(i != wMap.length-1 && wMap[i+1][j]) {\n\t\t\treturn false;\n\t\t}\n\t\telse if(j != wMap[i].length-1 && wMap[i][j+1]) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Surrounding Area\npublic class Main{\n\n\tint w, h;\n\tchar[][] m;\n\tint[][] move = {{-1,0}, {0,1}, {1,0}, {0,-1}};\n\tboolean[][] white, black;\n\n\tvoid fw(int i, int j){\n\t\tif(white[i][j]||m[i][j]!='.')return;\n\t\twhite[i][j] = true;\n\t\tfor(int k=0;k<4;k++){\n\t\t\tint ni = i+move[k][0], nj = j+move[k][1];\n\t\t\tif(0<=ni&&ni<h&&0<=nj&&nj<w)fw(ni, nj);\n\t\t}\n\t}\n\tvoid fb(int i, int j){\n\t\tif(black[i][j]||m[i][j]!='.')return;\n\t\tblack[i][j] = true;\n\t\tfor(int k=0;k<4;k++){\n\t\t\tint ni = i+move[k][0], nj = j+move[k][1];\n\t\t\tif(0<=ni&&ni<h&&0<=nj&&nj<w)fb(ni, nj);\n\t\t}\n\t}\n\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tw = sc.nextInt(); h = sc.nextInt();\n\t\t\tif((w|h)==0)break;\n\t\t\tm = new char[h][];\n\t\t\tfor(int i=0;i<h;i++)m[i]=sc.next().toCharArray();\n\t\t\twhite = new boolean[h][w]; black = new boolean[h][w];\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\t\tif(m[i][j]=='W'){\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tint ni = i+move[k][0], nj = j+move[k][1];\n\t\t\t\t\t\tif(0<=ni&&ni<h&&0<=nj&&nj<w)fw(ni, nj);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(m[i][j]=='B'){\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tint ni = i+move[k][0], nj = j+move[k][1];\n\t\t\t\t\t\tif(0<=ni&&ni<h&&0<=nj&&nj<w)fb(ni, nj);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint cw = 0, cb = 0;\n\t\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++){\n\t\t\t\tif(m[i][j]!='.'||white[i][j]&&black[i][j]||!white[i][j]&&!black[i][j])continue;\n\t\t\t\tif(white[i][j])cw++;\n\t\t\t\telse cb++;\n\t\t\t}\n\t\t\tSystem.out.println(cb+\" \"+cw);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "// AOJ 2014 \"\" (ICPC 2007 Problem C)\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (true) {\n            int w = sc.nextInt();\n            int h = sc.nextInt();\n            if (w == 0) {\n                break;\n            }\n            \n            StringBuffer[] field = new StringBuffer[h];\n            for (int i = 0; i < field.length; i++) {\n                field[i] = new StringBuffer(sc.next());\n            }\n            \n            for (int i = 0; i < field.length; i++) {\n                for (int j = 0; j < field[i].length(); j++) {\n                    if (field[i].charAt(j) == 'W') {\n                        dfs(field, j, i, 'w');\n                    } else if (field[i].charAt(j) == 'B') {\n                        dfs(field, j, i, 'b');\n                    }\n                }\n            }\n            \n            int bArea = 0;\n            int wArea = 0;\n            for (int i = 0; i < field.length; i++) {\n                for (int j = 0; j < field[i].length(); j++) {\n                    if (field[i].charAt(j) == 'b') {\n                        bArea++;\n                    } else if (field[i].charAt(j) == 'w') {\n                        wArea++;\n                    }\n                }\n            }\n            System.out.println(bArea + \" \" + wArea);\n        }\n    }\n    \n    public static void dfs(StringBuffer[] field, int x, int y, char c) {\n        int[] dx = {0, 1, 0, -1};\n        int[] dy = {1, 0, -1, 0};\n        \n        for (int i = 0; i < dx.length; i++) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n            \n            if (0 <= ny && ny < field.length && 0 <= nx && nx < field[ny].length()) {\n                if (field[ny].charAt(nx) == '.') {\n                    field[ny].setCharAt(nx, c);\n                    dfs(field, nx, ny, c);\n                } else if ((field[ny].charAt(nx) == 'b' && c == 'w')\n                || (field[ny].charAt(nx) == 'w' && c == 'b')) {\n                    field[ny].setCharAt(nx, 'g');\n                    dfs(field, nx, ny, c);\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main {\n\n\tstatic boolean touched[][] = new boolean[55][55];\n\tstatic char board[][] = new char[55][55];\n\tstatic int owner[][] = new int[55][55];\n\tstatic int w, h;\n\tstatic int dx[] = {1,0,-1,0}, dy[] = {0,1,0,-1};\n\n\tpublic static void main(String args[]){\n\t\tScanner in = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tw = in.nextInt();\n\t\t\th = in.nextInt();\n\t\t\tif(w==0 && h==0) break;\n\t\t\tfor(int i=0; i<55; i++)for(int j=0; j<55; j++){\n\t\t\t\tboard[i][j] = '@';\n\t\t\t\towner[i][j] = 0;\n\t\t\t}\n\t\t\tfor(int i=0; i<h; i++){\n\t\t\t\tString str = in.next();\n\t\t\t\tfor(int j=0; j<w; j++){\n\t\t\t\t\tboard[i][j] = str.charAt(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0; i<h; i++){\n\t\t\t\tfor(int j=0; j<w; j++){\n\t\t\t\t\tif(board[i][j] != '.'){\n\t\t\t\t\t\tfor(int ii=0; ii<h; ii++)for(int jj=0;jj<w;jj++) touched[ii][jj] = false;\n\t\t\t\t\t\tfor(int k=0; k<4; k++)dfs(j+dx[k], i+dy[k], board[i][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint black = 0, white = 0;\n\t\t\tfor(int i=0; i<h; i++)\n\t\t\t\tfor(int j=0; j<w; j++)\n\t\t\t\t\tif(owner[i][j]==1) black++;\n\t\t\t\t\telse if(owner[i][j]==2) white++;\n\t\t\t\n\t\t\tSystem.out.println(black + \" \" + white);\n\t\t}\n\t}\n\t\n\tstatic void dfs(int x, int y, char c){\n\t\tif(x<0 || w<=x || y<0 || h<=y) return ;\n\t\ttouched[y][x] = true;\n\t\tif(board[y][x]=='.'){\n\t\t\towner[y][x] |= (c=='B')?1:2;\n\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\tif(!(x+dx[i]<0 || w<=x+dx[i] || y+dy[i]<0 || h<=y+dy[i]) && !touched[y+dy[i]][x+dx[i]]){\n\t\t\t\t\tdfs(x+dx[i], y+dy[i], c);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Surrounding Area\n */\npublic class Main {\n\n\tstatic final int BLACK = 1;\n\tstatic final int WHITE = 2;\n\tstatic final int[][] HV = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\tString[] words;\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tint w, h;\n\t\t\tw = parseInt(line.substring(0, line.indexOf(' ')));\n\t\t\th = parseInt(line.substring(line.indexOf(' ') + 1));\n\t\t\tif ((w | h) == 0) break;\n\n\t\t\tchar[][] map = new char[h + 2][w + 2];\n\t\t\tint[][] check = new int[h + 2][w + 2];\n\n\t\t\tfor (int i = 1; i <= h; i++) {\n\t\t\t\tline = br.readLine();\n\t\t\t\tfor (int j = 1; j <= w; j++) {\n\t\t\t\t\tmap[i][j] = line.charAt(j - 1);\n\t\t\t\t\tif (map[i][j] == 'B' || map[i][j] == 'W') {\n\t\t\t\t\t\tcheck[i][j] = BLACK | WHITE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = 1; i <= h; i++) {\n\t\t\t\tfor (int j = 1; j <= w; j++) {\n\t\t\t\t\tif (map[i][j] == 'B' || map[i][j] == 'W') {\n\t\t\t\t\t\tint marker = 0;\n\t\t\t\t\t\tif (map[i][j] == 'B') {\n\t\t\t\t\t\t\tmarker = BLACK;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tmarker = WHITE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tDeque<int[]> queue = new ArrayDeque<>();\n\t\t\t\t\t\tqueue.offer(new int[]{i, j});\n\t\t\t\t\t\twhile (!queue.isEmpty()) {\n\t\t\t\t\t\t\tint[] p = queue.poll();\n\t\t\t\t\t\t\tfor (int k = 0; k < HV.length; k++) {\n\t\t\t\t\t\t\t\tint ny = p[0] + HV[k][0];\n\t\t\t\t\t\t\t\tint nx = p[1] + HV[k][1];\n\t\t\t\t\t\t\t\tif (1 <= ny && ny <= h\n\t\t\t\t\t\t\t\t\t\t&& 1 <= nx && nx <= w\n\t\t\t\t\t\t\t\t\t\t&& map[ny][nx] == '.'\n\t\t\t\t\t\t\t\t\t\t&& (check[ny][nx] & marker) == 0) {\n\t\t\t\t\t\t\t\t\tqueue.offer(new int[]{ny, nx});\n\t\t\t\t\t\t\t\t\tcheck[ny][nx] |= marker;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint black = 0;\n\t\t\tint white = 0;\n\t\t\tfor (int i = 1; i <= h; i++) {\n\t\t\t\tfor (int j = 1; j <= w; j++) {\n\t\t\t\t\tif (check[i][j] == BLACK) {\n\t\t\t\t\t\tblack++;\n\t\t\t\t\t} else if (check[i][j] == WHITE) {\n\t\t\t\t\t\twhite++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(black + \" \" + white);\n\n\t\t} //end while\n\t} //end main\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\n    int w,h;\n    char[][] map;\n    int[][] map2;\n    boolean B,W;\n    int[] dx = {0,0,1,-1};\n    int[] dy = {1,-1,0,0};\n    int idx;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        while(true){\n            w = sc.nextInt();\n            h = sc.nextInt();\n            if(w==0 && h==0) break;\n\n            map = new char[h][w];\n            for(int i=0; i<h; i++){\n                String line = sc.next();\n                map[i] = line.toCharArray();\n            }\n        \n            ArrayList<Integer> black = new ArrayList<Integer>();\n            ArrayList<Integer> white = new ArrayList<Integer>();\n            map2 = new int[h][w];\n            idx = 1;\n            for(int i=0; i<h; i++){\n                for(int j=0; j<w; j++){\n                    if(map[i][j]=='.'){\n                        B = false;\n                        W = false;\n                        bfs(j,i);\n                        if(B && !W) black.add(idx);\n                        if(!B && W) white.add(idx);\n                        idx++; \n                    }\n                }\n            }\n\n            int bsum = 0, wsum = 0;\n            for(int i=0; i<h; i++){\n                for(int j=0; j<w; j++){\n                    if(black.contains(map2[i][j])) bsum++;\n                    if(white.contains(map2[i][j])) wsum++;\n                }\n            }\n\n            System.out.println(bsum+\" \"+wsum);\n        }\n    }\n\n    void bfs(int sx, int sy){\n        LinkedList<int[]> list = new LinkedList<int[]>();\n        list.add(new int[]{sx,sy});\n        boolean[][] v = new boolean[h][w];\n\n        while(list.size()>0){\n            int[] xy = list.poll();\n            int x = xy[0], y = xy[1];\n\n            if(v[y][x]) continue;\n            v[y][x] = true;\n\n            map2[y][x] = idx;\n            map[y][x] = 'x';\n\n            for(int i=0; i<4; i++){\n                int nx = x+dx[i], ny = y+dy[i];\n                if(nx<0 || nx>=w || ny<0 || ny>=h) continue;\n                if(map[ny][nx]=='.'){\n                    list.add(new int[]{nx,ny});\n                }else if(map[ny][nx]=='B') B = true;\n                else if(map[ny][nx]=='W') W = true;\n            }\n        }\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n\npublic class Main {\n    static Scanner s = new Scanner(System.in);\n\n    static boolean black,white;\n    static char[][] map;\n    static int W,H;\n\n    public static void main(String[] args) {\n        int count;\n        while (true) {\n            W = s.nextInt();\n            H = s.nextInt();\n            if (W == 0 && H == 0) break;\n\n            int bCount=0,wCount=0;\n            map = new char[H][W];\n\n            for (int i = 0; i < H; i++) {\n                map[i] = s.next().toCharArray();\n            }\n\n            for(int i=0;i<H;i++){\n                for(int j=0;j<W;j++){\n                    black=false;\n                    white=false;\n                    count=0;\n\n                    if(map[i][j]=='.')\n                        count=search(i,j);\n\n                    if(black && !white)\n                        bCount+=count;\n                    else if(!black && white)\n                        wCount+=count;\n                }\n            }\n            System.out.println(bCount+\" \"+wCount);\n        }\n    }\n\n    static int search(int i,int j) {\n        int count=0;\n        if(i<0 || i>=H || j<0 || j>=W) return 0;\n        if(map[i][j]=='.'){\n            map[i][j]='x';\n            count++;\n            count+=search(i+1,j)+search(i-1,j)+search(i,j+1)+search(i,j-1);\n        }else if(map[i][j]=='B'){\n            black=true;\n        }else if(map[i][j]=='W'){\n            white=true;\n        }\n        return count;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\n    /**\n     * @param args\n     */\n    public static void main(String[] args) {\n        Scanner sc=new Scanner(System.in);\n        while(true){\n            int w=sc.nextInt();\n            int h=sc.nextInt();\n            if(w+h==0)break;\n            int[][] a = new int[h][w];\n            for (int i = 0; i < a.length; i++) {\n                String s = sc.next();\n                for (int j = 0; j < a[i].length; j++) {\n                    a[i][j]=s.charAt(j);\n                }\n            }\n            int bs = 0,ws=0;\n            for (int i = 0; i < a.length; i++) {\n                for (int j = 0; j < a[i].length; j++) {\n                    if(a[i][j]!='.')continue;\n                    int[] res = rec(a,i,j);\n                    if(res[1]==1){\n                        bs+=res[0];\n                    } else if(res[1]==2){\n                        ws+=res[0];                        \n                    }\n                }\n            }\n            System.out.println(bs+\" \"+ws);\n        }\n    }\n    static int[] v1 = {0,0,1,-1};\n    static int[] v2 = {1,-1,0,0};\n    static int[] rec(int[][] a,int h,int w){\n        int[] res = new int[2];\n        Queue<int[]>q = new LinkedList<int[]>();\n        a[h][w]=-1;\n        q.add(new int[]{h,w});\n        while(!q.isEmpty()){\n            int y = q.peek()[0];\n            int x = q.poll()[1];\n            res[0]++;\n            for (int i = 0; i < v1.length; i++) {\n                int yy = y + v1[i];\n                int xx = x + v2[i];\n                try {\n                    a[yy][xx]*=1;\n                } catch (Exception e) {\n                    continue;\n                }\n                if(a[yy][xx]=='B'){\n                    res[1]|=1;\n                } else if(a[yy][xx]=='W'){\n                    res[1]|=2;\n                } else if(a[yy][xx]==-1){\n                    continue;\n                } else {\n                    a[yy][xx]=-1;\n                    q.add(new int[]{yy,xx});\n                }\n            }\n        }\n        return res;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n\npublic class Main{\n\nstatic PrintWriter out;\nstatic InputReader ir;\n\nstatic void solve(){\n for(;;){\n  int w=ir.nextInt();\n  int h=ir.nextInt();\n  if(w==0&&h==0) return;\n  char[][] map=ir.nextCharMap(h,w);\n  int[][] cnd=new int[h][w];\n  for(int i=0;i<h;i++){\n   for(int j=0;j<w;j++){\n    if(map[i][j]!='.') bfs(i,j,map[i][j]=='B'?1:2,map,cnd);\n   }\n  }\n  int bl=0,wh=0;\n  for(int i=0;i<h;i++){\n   for(int j=0;j<w;j++){\n    if(cnd[i][j]==1) bl++;\n    if(cnd[i][j]==2) wh++;\n   }\n  }\n  out.println(bl+\" \"+wh);\n }\n}\n\nstatic final int[] dd=new int[]{0-1,0,1};\n\npublic static boolean in(int x,int y,int h,int w){\n return (x>=0&&y>=0&&x<h&&y<w);\n}\n\npublic static void bfs(int x,int y,int m,char[][] map,int[][] cnd){\n int h=map.length,w=map[0].length;\n Deque<int[]> que=new ArrayDeque<>();\n for(int i=0;i<4;i++){\n // int nx=x+dd[i],ny=y+dd[i^1];\n // if(!in(nx,ny,h,w)) continue;\n // if(map[nx][ny]=='.'&&(cnd[nx][ny]&m)==0) que.offerLast(new int[]{nx,ny});\n }\n /*while(!que.isEmpty()){\n  int[] p=que.pollFirst();\n  int px=p[0],py=p[1];\n  cnd[px][py]|=m;\n  for(int i=0;i<4;i++){\n   int nx=px+dd[i],ny=py+dd[i^1];\n   if(!in(nx,ny,h,w)) continue;\n   if(map[nx][ny]=='.'&&(cnd[nx][ny]&m)==0) que.offerLast(new int[]{nx,ny});\n  }\n }*/\n}\n\npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n\nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n\n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n\n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n \n public boolean hasNext(){skip(); return hasNextByte();}\n \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n\n public double nextDouble(){return Double.parseDouble(next());}\n\n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n\n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n\n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\nclass Main {\n    private static void mark(int x, int y, int flag, char[][] data, int[][] map) {\n        for (int i = x + 1; i < data.length; i++) {\n            if (data[i][y] == '.' && (map[i][y] & flag) == 0) {\n                map[i][y] |= flag;\n                mark(i, y, flag, data, map);\n            } else {\n                break;\n            }\n        }\n        for (int i = x - 1; i >= 0; i--) {\n            if (data[i][y] == '.' && (map[i][y] & flag) == 0) {\n                map[i][y] |= flag;\n                mark(i, y, flag, data, map);\n            } else {\n                break;\n            }\n        }\n        for (int j = y + 1; j < data[0].length; j++) {\n            if (data[x][j] == '.' && (map[x][j] & flag) == 0) {\n                map[x][j] |= flag;\n                mark(x, j, flag, data, map);\n            } else {\n                break;\n            }\n        }\n        for (int j = y - 1; j >= 0; j--) {\n            if (data[x][j] == '.' && (map[x][j] & flag) == 0) {\n                map[x][j] |= flag;\n                mark(x, j, flag, data, map);\n            } else {\n                break;\n            }\n        }\n    }\n\n    private static void solve() {\n        final Scanner scanner = new Scanner(System.in);\n\n        while (true) {\n            final int w = scanner.nextInt();\n            final int h = scanner.nextInt();\n            if (w == 0 && h == 0) {\n                break;\n            }\n\n            final char[][] data = new char[h][];\n            final int[][] map = new int[h][w];\n            for (int i = 0; i < h; i++) {\n                    data[i] = scanner.next().toCharArray();\n            }\n            for (int i = 0; i < h; i++) {\n                for (int j = 0; j < w; j++) {\n                    switch (data[i][j]) {\n                        case 'B':\n                            mark(i, j, 0x1, data, map);\n                            break;\n                        case 'W':\n                            mark(i, j, 0x2, data, map);\n                            break;\n                        default:\n                            break;\n                    }\n                }\n            }\n            int black = 0;\n            int white = 0;\n            for (int i = 0; i < h; i++) {\n                for (int j = 0; j < w; j++) {\n                    switch (map[i][j]) {\n                        case 0x1:\n                            black++;\n                            break;\n                        case 0x2:\n                            white++;\n                            break;\n                        default:\n                            break;\n                    }\n                }\n            }\n            System.out.println(black + \" \" + white);\n        }\n    }\n\n    public static void main(String... args) {\n        solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic int width, height, count=0;\n\tstatic char[][] field;\n\tstatic boolean[][] v;\n\tstatic boolean wbool, bbool;\n\n\tstatic void visit(int x, int y) {\n\t\tif(field[x][y]=='B') bbool=true;\n\t\tif(field[x][y]=='W') wbool=true;\n\t\tif(field[x][y]!='.') return;\n\t\tif(v[x][y]) return;\n\t\tv[x][y]=true;\n\t\tcount++;\n\t\tif(x<height-1)\n\t\t\tvisit(x+1, y);\n\t\tif(x>0)\n\t\t\tvisit(x-1, y);\n\t\tif(y<width-1)\n\t\t\tvisit(x, y+1);\n\t\tif(y>0)\n\t\t\tvisit(x, y-1);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\ttry(Scanner sc = new Scanner(System.in)){\n\t\t\twhile(sc.hasNext()) {\n\t\t\t\twidth=sc.nextInt();\n\t\t\t\theight=sc.nextInt();\n\t\t\t\tif(width==0) break;\n\t\t\t\tfield=new char[height+1][width+1];\n\t\t\t\tv=new boolean[height+1][width+1];\n\t\t\t\tfor(int i=0; i<height; i++) {\n\t\t\t\t\tString str=sc.next();\n\t\t\t\t\tfor(int j=0; j<width; j++) {\n\t\t\t\t\t\tfield[i][j]=str.charAt(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint wcount=0, bcount=0;\n\t\t\t\tfor(int i=0; i<height; i++) {\n\t\t\t\t\tfor(int j=0; j<width; j++) {\n\t\t\t\t\t\tif(v[i][j]) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(field[i][j]!='.') {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\twbool=false;\n\t\t\t\t\t\tbbool=false;\n\t\t\t\t\t\tcount=0;\n\t\t\t\t\t\tvisit(i, j);\n\t\t\t\t\t\tif(wbool && ! bbool) {\n\t\t\t\t\t\t\twcount+=count;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(bbool && ! wbool) {\n\t\t\t\t\t\t\tbcount+=count;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(bcount+\" \"+wcount);\n\t\t\t}\n\n\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\npublic class Main\n{\n\tstatic int field[][];\n\tstatic int which[][];\n\tstatic int white,black,cnt;\n\tstatic int W,H;\n\tstatic int dx[]={0,1,-1,0};\n\tstatic int dy[]={1,0,0,-1};\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tfor(;;)\n\t\t{\n\t\t\tW=in.nextInt();\n\t\t\tH=in.nextInt();\n\t\t\tif((W|H)==0)\n\t\t\t\treturn;\n\t\t\tfield=new int[H][W];\n\t\t\twhich=new int[H][W];\n\t\t\tfor(int i=0;i<H;i++)\n\t\t\t{\n\t\t\t\tString st=in.next();\n\t\t\t\tfor(int j=0;j<W;j++)\n\t\t\t\t{\n\t\t\t\t\tif(st.charAt(j)=='.')\n\t\t\t\t\t\tfield[i][j]=0;\n\t\t\t\t\telse if(st.charAt(j)=='W')\n\t\t\t\t\t\tfield[i][j]=1;\n\t\t\t\t\telse if(st.charAt(j)=='B')\n\t\t\t\t\t\tfield[i][j]=2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tblack=0;\n\t\t\twhite=0;\n\t\t\tfor(int i=0;i<H;i++)\n\t\t\t{\n\t\t\t\tfor(int j=0;j<W;j++)\n\t\t\t\t{\n\t\t\t\t\tif(field[i][j]==1)//\n\t\t\t\t\t\tdfs(i,j,\"w\",0);\n\t\t\t\t\tif(field[i][j]==2)//\n\t\t\t\t\t\tdfs(i,j,\"b\",0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<H;i++)\n\t\t\t{\n\t\t\t\tfor(int j=0;j<W;j++)\n\t\t\t\t{\n\t\t\t\t\tif(which[i][j]==1)\n\t\t\t\t\t\twhite++;\n\t\t\t\t\telse if(which[i][j]==2)\n\t\t\t\t\t\tblack++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(black+\" \"+white);\n\t\t}\t\n\t}\n\tpublic static void dfs(int h,int w,String s,int n)\n\t{\n\t\tif(n!=0)\n\t\t{\n\t\t\tif(s.equals(\"w\"))\n\t\t\t{\n\t\t\t\tfield[h][w]=3;//\n\t\t\t\twhich[h][w]+=1;//1\n\t\t\t}\n\t\t\telse if(s.equals(\"b\"))\n\t\t\t{\n\t\t\t\tfield[h][w]=4;//\n\t\t\t\twhich[h][w]+=2;//2\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<4;i++)\n\t\t{\n\t\t\tint nh=h+dy[i];\n\t\t\tint nw=w+dx[i];\n\t\t\tif(s.equals(\"w\"))\n\t\t\t\tif(nh>=0&&nh<H&&nw>=0&&nw<W&&(field[nh][nw]==0||field[nh][nw]==4))//\n\t\t\t\t\tdfs(nh,nw,s,n+1);\n\t\t\tif(s.equals(\"b\"))\n\t\t\t\tif(nh>=0&&nh<H&&nw>=0&&nw<W&&(field[nh][nw]==0||field[nh][nw]==3))//\n\t\t\t\t\tdfs(nh,nw,s,n+1);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main{\n    public static void main(String[] args){\n\tnew Main().run();\n    }\n    Scanner sc = new Scanner(System.in);\n\n    char[][] map;\n    int[][] round; // 0:, 1:, 2:, -1:\n    int w, h;\n    int B, W;\n\n\n    void run(){\n\twhile(sc.hasNext()){\n\t    w = sc.nextInt();\n\t    h = sc.nextInt();\n\t    if(w==0 && h==0) break;\n\t    \n\t    map = new char[h][w];\n\t    round = new int[h][w];\n\t    \n\t    for(int i=0; i<h; i++){\n\t\tString s = sc.next();\n\t\tfor(int k=0; k<w; k++)\n\t\t    map[i] = s.toCharArray();\n\t    }\n\t    \n\t    for(int i=0; i<h; i++)\n\t\tfor(int k=0; k<w; k++)\n\t\t    if(map[i][k]=='B' || map[i][k]=='W')\n\t\t\tsolve(0, 0, map[i][k]);\n\t    \n\t    count();\n\t    //show();\n\t    System.out.println(B+\" \"+W);\n\t}\n    }\n\n    void solve(int a, int b, char c){\n\tif(a<0 || a>=h || b<0 || b>=w) return;\n\tif(round[a][b]==-1) return;\n\t\n\tif(map[a][b]=='B' || map[a][b]=='W'){\n\t    c = map[a][b];\n\t    round[a][b] = -1;\n\t    solve(a+1, b, c);\n\t    solve(a-1, b, c);\n\t    solve(a, b+1, c);\n\t    solve(a, b-1, c);\n\t}\n\telse if(round[a][b]==0){\n\t    round[a][b] = c=='B' ? 1 : 2;\n\t    solve(a+1, b, c);\n\t    solve(a-1, b, c);\n\t    solve(a, b+1, c);\n\t    solve(a, b-1, c);\n\t}\n\telse if( (round[a][b]==1 && c=='W') || (round[a][b]==2 && c=='B')){\n\t    round[a][b] = -1;\n\t    solve(a+1, b, c);\n\t    solve(a-1, b, c);\n\t    solve(a, b+1, c);\n\t    solve(a, b-1, c);\n\t}\n    }\n\n    void count(){\n\tB = 0;\n\tW = 0;\n\tfor(int i=0; i<h; i++)\n\t    for(int k=0; k<w; k++)\n\t\tif(round[i][k]==1) B++;\n\t\telse if(round[i][k]==2) W++;\n    }\n\n    void show(){\n\tfor(int i=0; i<h; i++){\n\t    for(int k=0; k<w; k++)\n\t\tSystem.out.print(round[i][k]+\" \");\n\t    System.out.println();\n\t}\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main{\n    public static void main(String[] args){\n\tnew Main().run();\n    }\n    Scanner sc = new Scanner(System.in);\n\n    char[][] map;\n    char[][] round; // \"\":, B:, W:, x: n:\n    int w, h;\n    int B, W;\n\n\n    void run(){\n\twhile(sc.hasNext()){\n\t    w = sc.nextInt();\n\t    h = sc.nextInt();\n\t    if(w==0 && h==0) break;\n\t    \n\t    map = new char[h][w];\n\t    round = new char[h][w];\n\t    \n\t    for(int i=0; i<h; i++){\n\t\tString s = sc.next();\n\t\tArrays.fill(round[i], 'o');\n\t\tfor(int k=0; k<w; k++)\n\t\t    map[i] = s.toCharArray();\n\t    }\n\t    \n\t    for(int i=0; i<h; i++)\n\t\tfor(int k=0; k<w; k++){\n\t\t    solve(i, k, map[i][k]);\n\t\t}\n\t    \n\t    count();\n\t    //show();\n\t    System.out.println(B+\" \"+W);\n\t}\n    }\n\n    void solve(int a, int b, char c){\n\tif(a<0 || a>=h || b<0 || b>=w) return;\n\tif(round[a][b]=='x' || round[a][b]=='n' || c=='.') return;\n\t\n\tif(map[a][b]=='B' || map[a][b]=='W'){\n\t    c = map[a][b];\n\t    round[a][b] = 'n';\n\t    solve(a+1, b, c);\n\t    solve(a-1, b, c);\n\t    solve(a, b+1, c);\n\t    solve(a, b-1, c);\n\t}\n\telse if(round[a][b]=='o'){\n\t    round[a][b] = c;\n\t    solve(a+1, b, c);\n\t    solve(a-1, b, c);\n\t    solve(a, b+1, c);\n\t    solve(a, b-1, c);\n\t}\n\telse if( (round[a][b]=='B' && c=='W') || (round[a][b]=='W' && c=='B')){\n\t    round[a][b] = 'x';\n\t    solve(a+1, b, c);\n\t    solve(a-1, b, c);\n\t    solve(a, b+1, c);\n\t    solve(a, b-1, c);\n\t}\n    }\n\n    void count(){\n\tB = 0;\n\tW = 0;\n\tfor(int i=0; i<h; i++)\n\t    for(int k=0; k<w; k++)\n\t\tif(round[i][k]=='B') B++;\n\t\telse if(round[i][k]=='W') W++;\n    }\n\n    void show(){\n\tfor(int i=0; i<h; i++){\n\t    for(int k=0; k<w; k++)\n\t\tSystem.out.print(round[i][k]+\" \");\n\t    System.out.println();\n\t}\n\tSystem.out.println(\"-------------------\");\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.System.*;\n\npublic class Main {\n\n\tScanner sc = new Scanner(in);\n\t\n\tboolean[][] check;\n\tboolean[][] checkall;\n\t\n\tint[] dx = {-1, 0, 1, 0};\n\tint[] dy = {0, -1, 0, 1};\n\tint w, h;\n\tint[][] map;\n\t\n\tint countb, countw;\n\t\n\tvoid calc(int n, int x, int y) {\n\t\tif (n == 1) countb++;\n\t\telse if (n == -1) countw++;\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tif (x+dx[i] >= 0 && x+dx[i] < h &&\n\t\t\t\ty+dy[i] >= 0 && y+dy[i] < w &&\n\t\t\t\t!checkall[x+dx[i]][y+dy[i]]) {\n\t\t\t\tif (map[x+dx[i]][y+dy[i]] == 0) {\n\t\t\t\t\tcheckall[x+dx[i]][y+dy[i]] = true;\n\t\t\t\t\tcalc(n, x+dx[i], y+dy[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\tboolean isB(int x, int y) {\n\t\tboolean flag = false;\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tif (x+dx[i] >= 0 && x+dx[i] < h &&\n\t\t\t\ty+dy[i] >= 0 && y+dy[i] < w &&\n\t\t\t\t!check[x+dx[i]][y+dy[i]]) {\n\t\t\t\tcheck[x+dx[i]][y+dy[i]] = true;\n\t\t\t\tif (map[x+dx[i]][y+dy[i]] == 1) return true;\n\t\t\t\tif (map[x+dx[i]][y+dy[i]] == 0) flag = flag || isB(x+dx[i], y+dy[i]);\n\t\t\t}\n\t\t}\n\t\treturn flag;\n\t}\n\t\n\tboolean isW(int x, int y) {\n\t\tboolean flag = false;\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tif (x+dx[i] >= 0 && x+dx[i] < h &&\n\t\t\t\ty+dy[i] >= 0 && y+dy[i] < w &&\n\t\t\t\t!check[x+dx[i]][y+dy[i]]) {\n\t\t\t\tcheck[x+dx[i]][y+dy[i]] = true;\n\t\t\t\tif (map[x+dx[i]][y+dy[i]] == -1) return true;\n\t\t\t\tif (map[x+dx[i]][y+dy[i]] == 0) flag = flag || isW(x+dx[i], y+dy[i]);\n\t\t\t}\n\t\t}\n\t\treturn flag;\n\t}\n\t\n\tvoid run() {\n\t\twhile (true) {\n\t\t\tw = sc.nextInt(); h = sc.nextInt();\n\t\t\tsc.nextLine();\n\t\t\tif (w == 0) break;\n\t\t\tmap = new int[h][w];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tString s = sc.nextLine();\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tif (s.charAt(j) == '.')\n\t\t\t\t\t\tmap[i][j] = 0;\n\t\t\t\t\telse if (s.charAt(j) == 'B')\n\t\t\t\t\t\tmap[i][j] = 1;\n\t\t\t\t\telse\n\t\t\t\t\t\tmap[i][j] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tcheck = new boolean[h][w];\n\t\t\tcheckall = new boolean[h][w];\n\t\t\tcountb = countw = 0;\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++){\n\t\t\t\t\tif (!checkall[i][j] && map[i][j] == 0) {\t\n\t\t\t\t\t\tboolean b, w;\n\t\t\t\t\t\tfor (int k = 0; k < h; k++) Arrays.fill(check[k], false);\n\t\t\t\t\t\tcheck[i][j] = true;\n\t\t\t\t\t\tb = isB(i, j);\n\t\t\t\t\t\tfor (int k = 0; k < h; k++) Arrays.fill(check[k], false);\n\t\t\t\t\t\tcheck[i][j] = true;\n\t\t\t\t\t\tw = isW(i, j);\n\t\t\t\t\t\tcheckall[i][j] = true;\n\t\t\t\t\t\tif (b && !w) {\n\t\t\t\t\t\t\tcalc(1, i, j);\n\t\t\t\t\t\t} else if (!b && w) {\n\t\t\t\t\t\t\tcalc(-1, i, j);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcalc(0, i, j);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tout.printf(\"%d %d\\n\", countb, countw);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n\npublic class Main{\n\nstatic PrintWriter out;\nstatic InputReader ir;\n\nstatic void solve(){\n for(;;){\n  w=ir.nextInt();\n  h=ir.nextInt();\n  if(w==0&&h==0) return;\n  map=ir.nextCharMap(h,w);\n  cnd=new int[h][w];\n  for(int i=0;i<h;i++){\n   for(int j=0;j<w;j++){\n    if(map[i][j]!='.'){\n     for(int i=0;i<4;i++){\n      int nx=x+dd[i],ny=y+dd[i^1];\n      if(!in(nx,ny)) continue;\n      if(map[nx][ny]=='.'&&(cnd[nx][ny]&m)==0) dfs(i,j,map[i][j]=='B'?1:2);\n   }\n  }\n  int bl=0,wh=0;\n  for(int i=0;i<h;i++){\n   for(int j=0;j<w;j++){\n    if(cnd[i][j]==1) bl++;\n    if(cnd[i][j]==2) wh++;\n   }\n  }\n  out.println(bl+\" \"+wh);\n }\n}\n\nstatic final int[] dd=new int[]{0,-1,0,1};\nstatic int w,h;\nstatic char[][] map;\nstatic int[][] cnd;\nstatic Deque<int[]> que=new ArrayDeque<>();\n\npublic static boolean in(int x,int y){\n return (x>=0&&y>=0&&x<h&&y<w);\n}\n\npublic static void dfs(int x,int y,int m){\n cnd[x][y]|=m;\n for(int i=0;i<4;i++){\n  int nx=x+dd[i],ny=y+dd[i^1];\n  if(!in(nx,ny)) continue;\n  if(map[nx][ny]=='.'&&(cnd[nx][ny]&m)==0) dfs(nx,ny,m);\n }\n}\n\npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n\nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n\n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n\n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n \n public boolean hasNext(){skip(); return hasNextByte();}\n \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n\n public double nextDouble(){return Double.parseDouble(next());}\n\n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n\n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n\n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "public class Main {\n\n\tprivate static void simulate(char[][] d) {\n\t\tjava.util.Queue<Pair> lis = new java.util.LinkedList<Pair>();\n\t\t\n\t\tfor (int i = 0; i < d.length; ++i) {\n\t\t\tfor (int j = 0; j < d[i].length; ++j) {\n\t\t\t\tif (d[i][j] == 'B') {\n\t\t\t\t\tlis.add(new Pair(i, j - 1));\n\t\t\t\t\tlis.add(new Pair(i, j + 1));\n\t\t\t\t\tlis.add(new Pair(i - 1, j));\n\t\t\t\t\tlis.add(new Pair(i + 1, j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile (!lis.isEmpty()) {\n\t\t\tfinal Pair p = lis.remove();\n\t\t\tfinal int i = p.i;\n\t\t\tfinal int j = p.j;\n\t\t\tif (i < 0 || i >= d.length) continue ;\n\t\t\tif (j < 0 || j >= d[i].length) continue ;\n\t\t\tif (d[i][j] == '.') {\n\t\t\t\td[i][j] = 'b';\n\t\t\t} else continue ;\n\t\t\tlis.add(new Pair(i, j - 1));\n\t\t\tlis.add(new Pair(i, j + 1));\n\t\t\tlis.add(new Pair(i - 1, j));\n\t\t\tlis.add(new Pair(i + 1, j));\n\t\t}\n\t\t\n\t\tlis.clear();\t\t\n\t\tfor (int i = 0; i < d.length; ++i) {\n\t\t\tfor (int j = 0; j < d[i].length; ++j) {\n\t\t\t\tif (d[i][j] == 'W') {\n\t\t\t\t\tlis.add(new Pair(i, j - 1));\n\t\t\t\t\tlis.add(new Pair(i, j + 1));\n\t\t\t\t\tlis.add(new Pair(i - 1, j));\n\t\t\t\t\tlis.add(new Pair(i + 1, j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile (!lis.isEmpty()) {\n\t\t\tfinal Pair p = lis.remove();\n\t\t\tfinal int i = p.i;\n\t\t\tfinal int j = p.j;\n\t\t\tif (i < 0 || i >= d.length) continue ;\n\t\t\tif (j < 0 || j >= d[i].length) continue ;\n\t\t\tif (d[i][j] == '.') {\n\t\t\t\td[i][j] = 'w';\n\t\t\t} else if (d[i][j] == 'b') {\n\t\t\t\td[i][j] = 'g';\n\t\t\t} else continue ;\n\t\t\tlis.add(new Pair(i, j - 1));\n\t\t\tlis.add(new Pair(i, j + 1));\n\t\t\tlis.add(new Pair(i - 1, j));\n\t\t\tlis.add(new Pair(i + 1, j));\n\t\t}\n\t}\n\t\n\tprivate static int countif(char[][] d, char ch) {\n\t\tint rvalue = 0;\n\t\tfor (int i = 0; i < d.length; ++i) {\n\t\t\tfor (int j = 0; j < d[i].length; ++j) {\n\t\t\t\tif (d[i][j] == ch) {\n\t\t\t\t\trvalue += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn rvalue;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\ttry (final java.util.Scanner sc = new java.util.Scanner(System.in)) {\n\t\t\tfor (;;) {\n\t\t\t\tfinal int w = sc.nextInt();\n\t\t\t\tfinal int h = sc.nextInt();\n\t\t\t\tif (w == 0 && h == 0) break ;\n\t\t\t\tfinal char[][] d = new char[h][];\n\t\t\t\tfor (int i = 0; i < h; ++i) {\n\t\t\t\t\td[i] = sc.next().toCharArray();\n\t\t\t\t}\n\t\t\t\tsimulate(d);\n\t\t\t\tSystem.out.printf(\"%d %d\\n\", countif(d, 'b'), countif(d, 'w'));\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static class Pair {\n\t\tprivate int i;\n\t\tprivate int j;\n\t\t\n\t\tprivate Pair(int i, int j) {\n\t\t\tthis.i = i;\n\t\t\tthis.j = j;\n\t\t}\n\t}\n\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tchar [][] data;\n\tint black,white,temp;\n\tchar state;\n\n\tfinal int []xdir = {0,1,0,-1};\n\tfinal int []ydir = {1,0,-1,0};\n\n\tprivate void solve(int x, int y){\n\t\tif(data[y][x] == '*'){\n\t\t\treturn;\n\t\t}\n\t\tif(data[y][x] == 'W'){\n\t\t\tif(state == 'N')\n\t\t\t\tstate = 'W';\n\t\t\tif(state == 'B')\n\t\t\t\tstate = 'D';\n\t\t\treturn;\n\t\t}\n\t\tif(data[y][x] == 'B'){\n\t\t\tif(state == 'N')\n\t\t\t\tstate = 'B';\n\t\t\tif(state == 'W')\n\t\t\t\tstate = 'D';\n\t\t\treturn;\n\t\t}\n\t\tdata[y][x] = '*';\n\t\ttemp++;\n\t\tfor(int i=0; i < 4; i++)\n\t\t\tsolve(x + xdir[i], y + ydir[i]);\n\t}\n\n\tprivate void doIt() {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint w = sc.nextInt();\n\t\t\tint h = sc.nextInt();\n\t\t\tif(w == 0 && h == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdata = new char[h + 2][w + 2];\n\t\t\tblack = 0;\n\t\t\twhite = 0;\n\t\t\ttemp = 0;\n\t\t\tstate = 'N';\n\t\t\tfor(int i=0; i <= h + 1; i++){\n\t\t\t\tdata[i][0] = '*';\n\t\t\t\tdata[i][w+1] = '*';\n\t\t\t}\n\t\t\tfor(int i =0; i <= w + 1; i++){\n\t\t\t\tdata[0][i] = '*';\n\t\t\t\tdata[h+1][i] = '*';\n\t\t\t}\n\t\t\tfor(int i=1; i < h + 1; i++){\n\t\t\t\tString str = sc.next();\n\t\t\t\tfor(int j = 1; j < w + 1; j++){\n\t\t\t\t\tdata[i][j] = str.charAt(j - 1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int i=1; i < h + 1; i++){\n\t\t\t\tfor(int j=1; j < w + 1; j++){\n\t\t\t\t\tif(data[i][j] == '.'){\n\t\t\t\t\t\tsolve(j,i);\n\t\t\t\t\t\t//System.out.println(temp + \" \" + black + \" \" + white+ \" \"+  i + \" \" + j);\n\t\t\t\t\t\tswitch(state){\n\t\t\t\t\t\tcase 'B':\n\t\t\t\t\t\t\tblack += temp;\n\t\t\t\t\t\t\ttemp = 0;\n\t\t\t\t\t\t\tstate = 'N';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'W':\n\t\t\t\t\t\t\twhite += temp;\n\t\t\t\t\t\t\ttemp = 0;\n\t\t\t\t\t\t\tstate = 'N';\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\ttemp = 0;\n\t\t\t\t\t\t\tstate = 'N';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(black + \" \" + white);\n\n\t\t\t//debug\n//\t\t\tfor(int i=0; i <= h + 1; i++){\n//\t\t\t\tfor(int j = 0; j <= w + 1; j++){\n//\t\t\t\t\tSystem.out.print(data[i][j] + \" \");\n//\t\t\t\t}\n//\t\t\t\tSystem.out.println(\"\");\n//\t\t\t}\n\t\t}\n\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain obj = new Main();\n\t\tobj.doIt();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        StringBuilder sb = new StringBuilder();\n        while (true) {\n            int w = sc.nextInt();\n            int h = sc.nextInt();\n            if (w == 0 && h == 0) {\n                break;\n            }\n            char[][] field = new char[h][];\n            for (int i = 0; i < h; i++) {\n                field[i] = sc.next().toCharArray();\n            }\n            HashMap<Character, Boolean> counts = new HashMap<>();\n            int whiteCount = 0;\n            int blackCount = 0;\n            char current = (char)('W' + 1);\n            for (int i = 0; i < h; i++) {\n                for (int j = 0; j < w; j++) {\n                    if (field[i][j] == '.') {\n                        Result result = new Result();\n                        check(i, j, current, field, result);\n                        if (result.white && !result.black) {\n                            counts.put(current, true);\n                        } else if (!result.white && result.black) {\n                            counts.put(current, false);\n                        }\n                        current = (char)(current + 1);\n                    }\n                }\n            }\n            for (int i = 0; i < h; i++) {\n                for (int j = 0; j < w; j++) {\n                    if (counts.containsKey(field[i][j])) {\n                        if (counts.get(field[i][j])) {\n                            whiteCount++;\n                        } else {\n                            blackCount++;\n                        }\n                    }\n                }\n            }\n            sb.append(blackCount).append(\" \").append(whiteCount).append(\"\\n\");\n        }\n        System.out.print(sb);\n    }\n    \n    static void check(int r, int c, char mark, char[][] field, Result result) {\n        if (field[r][c] == 'W') {\n            result.white = true;\n            return;\n        }\n        if (field[r][c] == 'B') {\n            result.black = true;\n            return;\n        }\n        if (field[r][c] != '.') {\n            return;\n        }\n        field[r][c] = mark;\n        if (r != 0) {\n            check(r - 1, c, mark, field, result);\n        }\n        if (r < field.length - 1) {\n            check(r + 1, c, mark, field, result);\n        }\n        if (c > 0) {\n            check(r, c - 1, mark, field, result);\n        }\n        if (c < field[r].length - 1) {\n            check(r, c + 1, mark, field, result);\n        }\n    }\n    \n    static class Result {\n        boolean white = false;\n        boolean black = false;\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Surrounding Area\n */\npublic class Main {\n\n\tstatic final int BLACK = 1;\n\tstatic final int WHITE = 2;\n\tstatic final int[][] HV = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\tString[] words;\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tint w, h;\n\t\t\tw = parseInt(line.substring(0, line.indexOf(' ')));\n\t\t\th = parseInt(line.substring(line.indexOf(' ') + 1));\n\t\t\tif ((w | h) == 0) break;\n\n\t\t\tchar[][] map = new char[h + 2][w + 2];\n\t\t\tint[][] check = new int[h + 2][w + 2];\n\n\t\t\tfor (int i = 1; i <= h; i++) {\n\t\t\t\tline = br.readLine();\n\t\t\t\tfor (int j = 1; j <= w; j++) {\n\t\t\t\t\tmap[i][j] = line.charAt(j - 1);\n\t\t\t\t\tif (map[i][j] == 'B' || map[i][j] == 'W') {\n\t\t\t\t\t\tcheck[i][j] = BLACK + WHITE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = 1; i <= h; i++) {\n\t\t\t\tfor (int j = 1; j <= w; j++) {\n\t\t\t\t\tif (map[i][j] == 'B' || map[i][j] == 'W') {\n\t\t\t\t\t\tint marker = 0;\n\t\t\t\t\t\tif (map[i][j] == 'B') {\n\t\t\t\t\t\t\tmarker = BLACK;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tmarker = WHITE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tDeque<int[]> queue = new ArrayDeque<>();\n\t\t\t\t\t\tqueue.offer(new int[]{i, j});\n\t\t\t\t\t\twhile (!queue.isEmpty()) {\n\t\t\t\t\t\t\tint[] p = queue.poll();\n\t\t\t\t\t\t\tfor (int k = 0; k < HV.length; k++) {\n\t\t\t\t\t\t\t\tint ny = p[0] + HV[k][0];\n\t\t\t\t\t\t\t\tint nx = p[1] + HV[k][1];\n\t\t\t\t\t\t\t\tif (1 <= ny && ny <= h\n\t\t\t\t\t\t\t\t\t\t&& 1 <= nx && nx <= w\n\t\t\t\t\t\t\t\t\t\t&& map[ny][nx] == '.'\n\t\t\t\t\t\t\t\t\t\t&& (check[ny][nx] & marker) == 0) {\n\t\t\t\t\t\t\t\t\tqueue.offer(new int[]{ny, nx});\n\t\t\t\t\t\t\t\t\tcheck[ny][nx] += marker;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint black = 0;\n\t\t\tint white = 0;\n\t\t\tfor (int i = 1; i <= h; i++) {\n\t\t\t\tfor (int j = 1; j <= w; j++) {\n\t\t\t\t\tif (check[i][j] == BLACK) {\n\t\t\t\t\t\tblack++;\n\t\t\t\t\t} else if (check[i][j] == WHITE) {\n\t\t\t\t\t\twhite++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(black + \" \" + white);\n\n\t\t} //end while\n\t} //end main\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n    private static int count;\n    private static int dominant_type; // 1 if white, 2 if black, 3 if neither;\n    private static int[][] Map;\n    private static int[][] directions = new int[][] {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\n    private static void paint(int x, int y) {\n        count++;\n        Map[y][x] = -1;\n        int t;\n        int ny, nx;\n        for (int[] direction: directions) {\n            ny = y + direction[1];\n            nx = x + direction[0];\n\n            if (nx >= 0 && nx < Map[0].length && ny >= 0 && ny < Map.length) {\n                t = Map[ny][nx];\n                if (t == -1) continue;\n                if (t == 0) {\n                    paint(nx, ny);\n                } else {\n                    if (dominant_type == 0)\n                        dominant_type = t;\n                    else if (dominant_type != t)\n                        dominant_type = 3;\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int w, h;\n        int white, black;\n        String[] input;\n\n        while (true) {\n            input = sc.nextLine().trim().split(\" \");\n            w = Integer.parseInt(input[0]);\n            h = Integer.parseInt(input[1]);\n            count = 0;\n            dominant_type = 0;\n            white = 0;\n            black = 0;\n\n            if (w == 0) break;\n\n            // Initialize Map\n            Map = new int[h][w];\n            for (int y = 0; y < h; y++) {\n                input = sc.nextLine().trim().split(\"\");\n//                System.out.println(Arrays.toString(input));\n                for (int x = 0; x < w; x++) {\n//                    System.out.println(input[x]);\n                    if (input[x].equals(\"W\"))\n                        Map[y][x] = 1;\n                    else if (input[x].equals(\"B\"))\n                        Map[y][x] = 2;\n                }\n            }\n\n            for (int x = 0; x < w; x++) {\n                for (int y = 0; y < h; y++) {\n                    if (Map[y][x] == 0) {\n                        paint(x, y);\n//                        System.out.println(dominant_type + \" \" + count);\n                        if (dominant_type == 1)\n                            white += count;\n                        else if (dominant_type == 2)\n                            black += count;\n                    }\n                    count = 0;\n                    dominant_type = 0;\n\n                }\n            }\n\n            System.out.println(black + \" \" + white);\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main{\n\tstatic int[][] map;\n\tstatic int[][] used;\n\tstatic int w, h;\n\tpublic static void main(String[] args) throws IOException{\n\t\tScanner in = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tw = in.nextInt();\n\t\t\th = in.nextInt();\n\t\t\tif(w == 0) break;\n\t\t\tmap = new int[h][w];\n\t\t\tused = new int[h][w];\n\t\t\tchecked = new int[h][w];\n\t\t\tfor(int i=0; i<h; i++){\n\t\t\t\tchar[] s = in.next().toCharArray();\n\t\t\t\tfor(int j=0; j<w; j++){\n\t\t\t\t\tmap[i][j] = s[j]=='.'?0:s[j]=='W'?1:2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0; i<h; i++){\n\t\t\t\tfor(int j=0; j<w; j++){\n\t\t\t\t\tif(map[i][j] == 0) continue;\n\t\t\t\t\tint color = map[i][j];\n\t\t\t\t\tfor(int k=0; k<4; k++){\n\t\t\t\t\t\tint nx = j+dx[k];\n\t\t\t\t\t\tint ny = i+dy[k];\n\t\t\t\t\t\tif(out(nx, ny) || map[ny][nx] != 0) continue;\n\t\t\t\t\t\tif(checked[ny][nx] != 0) continue;\n\t\t\t\t\t\tif(dfs(nx, ny, color)){\n\t\t\t\t\t\t\tcheck(nx, ny, color);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint white = 0;\n\t\t\tint black = 0;\n\t\t\tfor(int i=0; i<h; i++){\n\t\t\t\tfor(int j=0; j<w; j++){\n\t\t\t\t\tif(used[i][j] == 1) white++;\n\t\t\t\t\telse if(used[i][j] == 2) black++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(black+\" \"+white);\n\t\t}\n\t}\n\t\n\tstatic String dump(int[][] map){\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int i=0; i<h; i++){\n\t\t\tfor(int j=0; j<w; j++){\n\t\t\t\tsb.append(map[i][j]+\" \");\n\t\t\t}\n\t\t\tsb.append(\"\\n\");\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tstatic void check(int x, int y, int color){\n\t\tif(used[y][x] != 0) return;\n\t\tused[y][x] = color;\n\t\tfor(int i=0; i<4; i++){\n\t\t\tint nx = x+dx[i];\n\t\t\tint ny = y+dy[i];\n\t\t\tif(out(nx, ny) || map[ny][nx] == color) continue;\n\t\t\tcheck(nx, ny, color);\n\t\t}\n\t}\n\t\n\tstatic final int[] dx = {0, 1, 0, -1};\n\tstatic final int[] dy = {1, 0, -1, 0};\n\tstatic int[][] checked;\n\tstatic boolean dfs(int x, int y, int color){\n\t\tif(checked[y][x] == color) return true;\n\t\telse if(checked[y][x] != 0) return false;\n\t\tchecked[y][x] = color;\n\t\tfor(int i=0; i<4; i++){\n\t\t\tint nx = x+dx[i];\n\t\t\tint ny = y+dy[i];\n\t\t\tif(out(nx, ny) || map[ny][nx] == color){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(map[ny][nx] == 0){\n\t\t\t\tif(!dfs(nx, ny, color)) return false;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tstatic boolean out(int x, int y){\n\t\treturn x<0||x>=w||y<0||y>=h;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n\npublic class Main{\n\nstatic PrintWriter out;\nstatic InputReader ir;\n\nstatic void solve(){\n for(;;){\n  int w=ir.nextInt();\n  int h=ir.nextInt();\n  if(w==0&&h==0) return;\n  char[][] map=ir.nextCharMap(h,w);\n  int[][] cnd=new int[h][w];\n  for(int i=0;i<h;i++){\n   for(int j=0;j<w;j++){\n    if(map[i][j]!='.') bfs(i,j,map[i][j]=='B'?1:2,map,cnd);\n   }\n  }\n  int bl=0,wh=0;\n  for(int i=0;i<h;i++){\n   for(int j=0;j<w;j++){\n    if(cnd[i][j]==1) bl++;\n    if(cnd[i][j]==2) wh++;\n   }\n  }\n  out.println(bl+\" \"+wh);\n }\n}\n\nstatic final int[] dd=new int[]{0-1,0,1};\n\npublic static boolean in(int x,int y,int h,int w){\n return (x>=0&&y>=0&&x<h&&y<w);\n}\n\npublic static void bfs(int x,int y,int m,char[][] map,int[][] cnd){\n int h=map.length,w=map[0].length;\n Deque<int[]> que=new ArrayDeque<>();\n for(int i=0;i<4;i++){\n  int nx=x+dd[i],ny=y+dd[i^1];\n  if(in(nx,ny,h,w)&&map[nx][ny]=='.'&&(cnd[nx][ny]&m)==0) que.offerLast(new int[]{nx,ny});\n }\n while(!que.isEmpty()){\n  int[] p=que.pollFirst();\n  int px=p[0],py=p[1];\n  cnd[px][py]|=m;\n  for(int i=0;i<4;i++){\n   int nx=px+dd[i],ny=py+dd[i^1];\n   if(in(nx,ny,h,w)&&map[nx][ny]=='.'&&(cnd[nx][ny]&m)==0) que.offerLast(new int[]{nx,ny});\n  }\n }\n}\n\npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n\nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n\n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n\n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n \n public boolean hasNext(){skip(); return hasNextByte();}\n \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n\n public double nextDouble(){return Double.parseDouble(next());}\n\n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n\n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n\n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile (true) {\n\t\t\tfinal int w = sc.nextInt();\n\t\t\tfinal int h = sc.nextInt();\n\n\t\t\tif (w == 0 && h == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint[][] map = new int[h][w];\n\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tchar[] input = sc.next().toCharArray();\n\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tif (input[j] == 'W') {\n\t\t\t\t\t\tmap[i][j] = 1;\n\t\t\t\t\t} else if (input[j] == 'B') {\n\t\t\t\t\t\tmap[i][j] = -1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmap[i][j] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint[][] w_dist = new int[h][w];\n\t\t\tint[][] b_dist = new int[h][w];\n\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tw_dist[i][j] = Integer.MAX_VALUE;\n\t\t\t\t\tb_dist[i][j] = Integer.MAX_VALUE;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\twhile(true){\n\t\t\t\tboolean updated = false;\n\t\t\t\t\n\t\t\t\t// w-forward\n\t\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\t\tif (map[i][j] == -1) {\n\t\t\t\t\t\t\tw_dist[i][j] = Integer.MAX_VALUE;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t} else if (map[i][j] == 1) {\n\t\t\t\t\t\t\tw_dist[i][j] = 0;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tint cur = w_dist[i][j];\n\n\t\t\t\t\t\tif (i == 0 && j == 0) {\n\t\t\t\t\t\t\tw_dist[i][j] = Math.min(Integer.MAX_VALUE, w_dist[i][j]);\n\t\t\t\t\t\t} else if (i == 0) {\n\t\t\t\t\t\t\tif (w_dist[i][j - 1] != Integer.MAX_VALUE) {\n\t\t\t\t\t\t\t\tw_dist[i][j] = Math.min(w_dist[i][j - 1] + 1, w_dist[i][j]);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tw_dist[i][j] = Math.min(w_dist[i][j - 1], w_dist[i][j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (j == 0) {\n\t\t\t\t\t\t\tif (w_dist[i - 1][j] != Integer.MAX_VALUE) {\n\t\t\t\t\t\t\t\tw_dist[i][j] = Math.min(w_dist[i - 1][j] + 1, w_dist[i][j]);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tw_dist[i][j] = Math.min(w_dist[i - 1][j], w_dist[i][j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfinal int min = Math.min(w_dist[i - 1][j],\n\t\t\t\t\t\t\t\t\tw_dist[i][j - 1]);\n\t\t\t\t\t\t\tif (min != Integer.MAX_VALUE) {\n\t\t\t\t\t\t\t\tw_dist[i][j] = Math.min(min + 1, w_dist[i][j]);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tw_dist[i][j] = Math.min(min, w_dist[i][j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(w_dist[i][j] != cur){\n\t\t\t\t\t\t\tupdated = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// w-back\n\t\t\t\tfor (int i = h - 1; i >= 0; i--) {\n\t\t\t\t\tfor (int j = w - 1; j >= 0; j--) {\n\t\t\t\t\t\tif (map[i][j] == -1) {\n\t\t\t\t\t\t\tw_dist[i][j] = Integer.MAX_VALUE;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t} else if (map[i][j] == 1) {\n\t\t\t\t\t\t\tw_dist[i][j] = 0;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tint cur = w_dist[i][j];\n\n\t\t\t\t\t\tif (i == h - 1 && j == w - 1) {\n\t\t\t\t\t\t\tw_dist[i][j] = Math.min(Integer.MAX_VALUE,\n\t\t\t\t\t\t\t\t\tw_dist[i][j]);\n\t\t\t\t\t\t} else if (i == h - 1) {\n\t\t\t\t\t\t\tif (w_dist[i][j + 1] != Integer.MAX_VALUE) {\n\t\t\t\t\t\t\t\tw_dist[i][j] = Math.min(w_dist[i][j + 1] + 1,\n\t\t\t\t\t\t\t\t\t\tw_dist[i][j]);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tw_dist[i][j] = Math.min(w_dist[i][j + 1],\n\t\t\t\t\t\t\t\t\t\tw_dist[i][j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (j == w - 1) {\n\t\t\t\t\t\t\tif (w_dist[i + 1][j] != Integer.MAX_VALUE) {\n\t\t\t\t\t\t\t\tw_dist[i][j] = Math.min(w_dist[i + 1][j] + 1,\n\t\t\t\t\t\t\t\t\t\tw_dist[i][j]);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tw_dist[i][j] = Math.min(w_dist[i + 1][j],\n\t\t\t\t\t\t\t\t\t\tw_dist[i][j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfinal int min = Math.min(w_dist[i + 1][j],\n\t\t\t\t\t\t\t\t\tw_dist[i][j + 1]);\n\t\t\t\t\t\t\tif (min != Integer.MAX_VALUE) {\n\t\t\t\t\t\t\t\tw_dist[i][j] = Math.min(min + 1, w_dist[i][j]);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tw_dist[i][j] = Math.min(min, w_dist[i][j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(w_dist[i][j] != cur){\n\t\t\t\t\t\t\tupdated = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// b-forward\n\t\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\t\tif (map[i][j] == 1) {\n\t\t\t\t\t\t\tb_dist[i][j] = Integer.MAX_VALUE;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t} else if (map[i][j] == -1) {\n\t\t\t\t\t\t\tb_dist[i][j] = 0;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tint cur = b_dist[i][j];\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (i == 0 && j == 0) {\n\t\t\t\t\t\t\tb_dist[i][j] = Integer.MAX_VALUE;\n\t\t\t\t\t\t} else if (i == 0) {\n\t\t\t\t\t\t\tif (b_dist[i][j - 1] != Integer.MAX_VALUE) {\n\t\t\t\t\t\t\t\tb_dist[i][j] = Math.min(b_dist[i][j - 1] + 1, b_dist[i][j]);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tb_dist[i][j] = Math.min(b_dist[i][j - 1], b_dist[i][j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (j == 0) {\n\t\t\t\t\t\t\tif (b_dist[i - 1][j] != Integer.MAX_VALUE) {\n\t\t\t\t\t\t\t\tb_dist[i][j] = Math.min(b_dist[i - 1][j] + 1, b_dist[i][j]);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tb_dist[i][j] = Math.min(b_dist[i - 1][j], b_dist[i][j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfinal int min = Math.min(b_dist[i - 1][j],\n\t\t\t\t\t\t\t\t\tb_dist[i][j - 1]);\n\t\t\t\t\t\t\tif (min != Integer.MAX_VALUE) {\n\t\t\t\t\t\t\t\tb_dist[i][j] = Math.min(min + 1, b_dist[i][j]);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tb_dist[i][j] = Math.min(min, b_dist[i][j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(b_dist[i][j] != cur){\n\t\t\t\t\t\t\tupdated = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// b-back\n\t\t\t\tfor (int i = h - 1; i >= 0; i--) {\n\t\t\t\t\tfor (int j = w - 1; j >= 0; j--) {\n\t\t\t\t\t\tif (map[i][j] == 1) {\n\t\t\t\t\t\t\tb_dist[i][j] = Integer.MAX_VALUE;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t} else if (map[i][j] == -1) {\n\t\t\t\t\t\t\tb_dist[i][j] = 0;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tint cur = b_dist[i][j];\n\n\t\t\t\t\t\tif (i == h - 1 && j == w - 1) {\n\t\t\t\t\t\t\tb_dist[i][j] = Math.min(Integer.MAX_VALUE,\n\t\t\t\t\t\t\t\t\tb_dist[i][j]);\n\t\t\t\t\t\t} else if (i == h - 1) {\n\t\t\t\t\t\t\tif (b_dist[i][j + 1] != Integer.MAX_VALUE) {\n\t\t\t\t\t\t\t\tb_dist[i][j] = Math.min(b_dist[i][j + 1] + 1,\n\t\t\t\t\t\t\t\t\t\tb_dist[i][j]);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tb_dist[i][j] = Math.min(b_dist[i][j + 1],\n\t\t\t\t\t\t\t\t\t\tb_dist[i][j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (j == w - 1) {\n\t\t\t\t\t\t\tif (b_dist[i + 1][j] != Integer.MAX_VALUE) {\n\t\t\t\t\t\t\t\tb_dist[i][j] = Math.min(b_dist[i + 1][j] + 1,\n\t\t\t\t\t\t\t\t\t\tb_dist[i][j]);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tb_dist[i][j] = Math.min(b_dist[i + 1][j],\n\t\t\t\t\t\t\t\t\t\tb_dist[i][j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfinal int min = Math.min(b_dist[i + 1][j],\n\t\t\t\t\t\t\t\t\tb_dist[i][j + 1]);\n\t\t\t\t\t\t\tif (min != Integer.MAX_VALUE) {\n\t\t\t\t\t\t\t\tb_dist[i][j] = Math.min(min + 1, b_dist[i][j]);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tb_dist[i][j] = Math.min(min, b_dist[i][j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(b_dist[i][j] != cur){\n\t\t\t\t\t\t\tupdated = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(!updated){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint b_count = 0;\n\t\t\tint w_count = 0;\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tfinal int w_d = w_dist[i][j] == Integer.MAX_VALUE ? Integer.MIN_VALUE\n\t\t\t\t\t\t\t: w_dist[i][j];\n\t\t\t\t\tfinal int b_d = b_dist[i][j] == Integer.MAX_VALUE ? Integer.MIN_VALUE\n\t\t\t\t\t\t\t: b_dist[i][j];\n\n\t\t\t\t\tif (w_d > 0 && b_d > 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else if (w_d > 0) {\n\t\t\t\t\t\tw_count++;\n\t\t\t\t\t} else if (b_d > 0) {\n\t\t\t\t\t\tb_count++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(b_count + \" \" + w_count);\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n\npublic class Main{\n\nstatic PrintWriter out;\nstatic InputReader ir;\n\nstatic void solve(){\n for(;;){\n  int w=ir.nextInt();\n  int h=ir.nextInt();\n  if(w==0&&h==0) return;\n  char[][] map=ir.nextCharMap(h,w);\n  int[][] cnd=new int[h][w];\n  for(int i=0;i<h;i++){\n   for(int j=0;j<w;j++){\n    if(map[i][j]!='.') bfs(i,j,map[i][j]=='B'?1:2,map,cnd);\n   }\n  }\n  int bl=0,wh=0;\n  for(int i=0;i<h;i++){\n   for(int j=0;j<w;j++){\n    if(cnd[i][j]==1) bl++;\n    if(cnd[i][j]==2) wh++;\n   }\n  }\n  out.println(bl+\" \"+wh);\n }\n}\n\nstatic final int[] dd=new int[]{0-1,0,1};\n\npublic static boolean in(int x,int y,int h,int w){\n return (x>=0&&y>=0&&x<h&&y<w);\n}\n\npublic static void bfs(int x,int y,int m,char[][] map,int[][] cnd){\n int h=map.length,w=map[0].length;\n Deque<int[]> que=new ArrayDeque<>();\n for(int i=0;i<4;i++){\n  int nx=x+dd[i],ny=y+dd[i^1];\n  if(!in(nx,ny,h,w)) continue;\n // if(map[nx][ny]=='.'&&(cnd[nx][ny]&m)==0) que.offerLast(new int[]{nx,ny});\n }\n /*while(!que.isEmpty()){\n  int[] p=que.pollFirst();\n  int px=p[0],py=p[1];\n  cnd[px][py]|=m;\n  for(int i=0;i<4;i++){\n   int nx=px+dd[i],ny=py+dd[i^1];\n   if(!in(nx,ny,h,w)) continue;\n   if(map[nx][ny]=='.'&&(cnd[nx][ny]&m)==0) que.offerLast(new int[]{nx,ny});\n  }\n }*/\n}\n\npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n\nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n\n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n\n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n \n public boolean hasNext(){skip(); return hasNextByte();}\n \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n\n public double nextDouble(){return Double.parseDouble(next());}\n\n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n\n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n\n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\n\nimport static java.lang.System.*;\n\nclass Main {\n\tpublic static Scanner sc = new Scanner(in);\n\tpublic static Random rand=new Random();\n\n\tclass P{\n\t\tint x;\n\t\tint y;\n\t\tpublic P(int x,int y){\n\t\t\tthis.x=x;this.y=y;\n\t\t}\n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tif(!(obj instanceof P))return false;\n\t\t\tP p=(P)obj;\n\t\t\treturn p.x==x && p.y==y;\n\t\t}\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"(\"+x+\",\"+y+\")\";\n\t\t}\n\t}\n\n\tint[][] dr=new int[][]{{0,1},{1,0},{0,-1},{-1,0}};\n\n\tpublic void run() {\n\t\twhile(true){\n\t\t\tint W=sc.nextInt(),H=sc.nextInt();\n\t\t\tif(W==0 && H==0)return;\n\n\t\t\tchar[][] map=new char[H][W];\n\t\t\tfor(int h=0;h<H;h++){\n\t\t\t\tmap[h]=sc.next().toCharArray();\n\t\t\t}\n\t\t\tint wc=0,bc=0;\n\n\t\t\tsmap:while(true){\n\t\t\t\tQueue<P> que=new LinkedList<P>();\n\t\t\t\tint c=0;\n\t\t\t\tsdot:for(int h=0;h<H;h++)for(int w=0;w<W;w++){\n\t\t\t\t\tif(map[h][w]=='.'){\n\t\t\t\t\t\tque.add(new P(w,h));\n\t\t\t\t\t\tmap[h][w]='-';\n\t\t\t\t\t\tc++;\n\t\t\t\t\t\tbreak sdot;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(que.isEmpty())break smap;\n\t\t\t\tint color=0;\n\t\t\t\twhile(!que.isEmpty()){\n\t\t\t\t\tP p=que.poll();\n\n\t\t\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\t\t\tint x=p.x+dr[i][0];\n\t\t\t\t\t\tint y=p.y+dr[i][1];\n\t\t\t\t\t\tif(0<=x&& x<W && 0<=y && y<H){\n\t\t\t\t\t\t\tswitch(map[y][x]){\n\t\t\t\t\t\t\tcase '.':\n\t\t\t\t\t\t\t\tmap[y][x]='-';\n\t\t\t\t\t\t\t\tc++;\n\t\t\t\t\t\t\t\tque.add(new P(x,y));\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'B':\n\t\t\t\t\t\t\t\tif(color==2)color=-1;\n\t\t\t\t\t\t\t\tif(color==0)color=1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tcase 'W':\n\t\t\t\t\t\t\t\tif(color==1)color=-1;\n\t\t\t\t\t\t\t\tif(color==0)color=2;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(color==1)\n\t\t\t\t\tbc+=c;\n\t\t\t\tif(color==2)\n\t\t\t\t\twc+=c;\n\t\t\t}\n\t\t\tln(bc+\" \"+wc);\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic int[] nextIntArray(int n){\n\t\tint[] res=new int[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tres[i]=sc.nextInt();\n\t\t}\n\t\treturn res;\n\t}\n\tpublic static void pr(Object o) {\n\t\tout.print(o);\n\t}\n\tpublic static void ln(Object o) {\n\t\tout.println(o);\n\t}\n\tpublic static void ln() {\n\t\tout.println();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n \npublic class Main{\n \nstatic PrintWriter out;\nstatic InputReader ir;\n \nstatic void solve(){\n for(;;){\n  w=ir.nextInt();\n  h=ir.nextInt();\n  if(w==0&&h==0) return;\n  map=ir.nextCharMap(h,w);\n  cnd=new int[h][w];\n  for(int i=0;i<h;i++){\n   for(int j=0;j<w;j++){\n    if(map[i][j]!='.') bfs(i,j,map[i][j]=='B'?1:2);\n   }\n  }\n  int bl=0,wh=0;\n  for(int i=0;i<h;i++){\n   for(int j=0;j<w;j++){\n    if(cnd[i][j]==1) bl++;\n    if(cnd[i][j]==2) wh++;\n   }\n  }\n  out.println(bl+\" \"+wh);\n }\n}\n \nstatic final int[] dd=new int[]{0,-1,0,1};\nstatic int w,h;\nstatic char[][] map;\nstatic int[][] cnd;\nstatic Deque<int[]> que=new ArrayDeque<>();\n \npublic static boolean in(int x,int y){\n return (x>=0&&y>=0&&x<h&&y<w);\n}\n \npublic static void bfs(int x,int y,int m){\n int nx,ny;\n for(int i=0;i<4;i++){\n  nx=x+dd[i];\n  ny=y+dd[i^1];\n  if(!in(nx,ny)) continue;\n  if((map[nx][ny]=='.')&&((cnd[nx][ny]&m)==0)){\n   cnd[nx][ny]|=m;\n   que.offerLast(new int[]{nx,ny});\n  }\n }\n while(!que.isEmpty()){\n  int[] p=que.pollFirst();\n  for(int i=0;i<4;i++){\n   nx=p[0]+dd[i];\n   ny=p[1]+dd[i^1];\n   if(!in(nx,ny)) continue;\n   if((map[nx][ny]=='.')&&((cnd[nx][ny]&m)==0)){\n    cnd[nx][ny]|=m;\n    que.offerLast(new int[]{nx,ny});\n   }\n  }\n }\n}\n \npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n \nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n \n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n  \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n \n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n  \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n  \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n  \n public boolean hasNext(){skip(); return hasNextByte();}\n  \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n  \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n  \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public double nextDouble(){return Double.parseDouble(next());}\n \n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n \n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n \n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n \npublic class Main{\n \nstatic PrintWriter out;\nstatic InputReader ir;\n \nstatic void solve(){\n for(;;){\n  w=ir.nextInt();\n  h=ir.nextInt();\n  if(w==0&&h==0) return;\n  map=ir.nextCharMap(h,w);\n  cnd=new int[h][w];\n  for(int i=0;i<h;i++){\n   for(int j=0;j<w;j++){\n    if(map[i][j]!='.') bfs(i,j,map[i][j]=='B'?1:2);\n   }\n  }\n  int bl=0,wh=0;\n  for(int i=0;i<h;i++){\n   for(int j=0;j<w;j++){\n    if(cnd[i][j]==1) bl++;\n    if(cnd[i][j]==2) wh++;\n   }\n  }\n  out.println(bl+\" \"+wh);\n }\n}\n \nstatic final int[] dd=new int[]{0,-1,0,1};\nstatic int w,h;\nstatic char[][] map;\nstatic int[][] cnd;\nstatic Deque<int[]> que=new ArrayDeque<>();\n \npublic static boolean in(int x,int y){\n return (x>=0&&y>=0&&x<h&&y<w);\n}\n \npublic static void bfs(int x,int y,int m){\n int nx,ny;\n for(int i=0;i<4;i++){\n  nx=x+dd[i];\n  ny=y+dd[i^1];\n  if(!in(nx,ny)) continue;\n  if((map[nx][ny]=='.')&&((cnd[nx][ny]&m)==0)) que.offerLast(new int[]{nx,ny});\n }\n while(!que.isEmpty()){\n  int[] p=que.pollFirst();\n  cnd[p[0]][p[1]]|=m;\n  for(int i=0;i<4;i++){\n   nx=p[0]+dd[i];\n   ny=p[1]+dd[i^1];\n   if(!in(nx,ny)) continue;\n//   if((map[nx][ny]=='.')&&((cnd[nx][ny]&m)==0)) que.offerLast(new int[]{nx,ny});\n  }\n }\n}\n \npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n \nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n \n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n  \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n \n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n  \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n  \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n  \n public boolean hasNext(){skip(); return hasNextByte();}\n  \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n  \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n  \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public double nextDouble(){return Double.parseDouble(next());}\n \n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n \n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n \n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n\npublic class Main{\n\nstatic PrintWriter out;\nstatic InputReader ir;\n\nstatic void solve(){\n for(;;){\n  int w=ir.nextInt();\n  int h=ir.nextInt();\n  if(w==0&&h==0) return;\n  char[][] map=ir.nextCharMap(h,w);\n  int[][] cnd=new int[h][w];\n  for(int i=0;i<h;i++){\n   for(int j=0;j<w;j++){\n    if(map[i][j]!='.') bfs(i,j,map[i][j]=='B'?1:2,map,cnd);\n   }\n  }\n  int bl=0,wh=0;\n  for(int i=0;i<h;i++){\n   for(int j=0;j<w;j++){\n    if(cnd[i][j]==1) bl++;\n    if(cnd[i][j]==2) wh++;\n   }\n  }\n  out.println(bl+\" \"+wh);\n }\n}\n\nstatic final int[] dd=new int[]{0,-1,0,1};\n\npublic static boolean in(int x,int y,int h,int w){\n return (x>=0&&y>=0&&x<h&&y<w);\n}\n\npublic static void bfs(int x,int y,int m,char[][] map,int[][] cnd){\n int h=map.length,w=map[0].length;\n Deque<int[]> que=new ArrayDeque<>();\n for(int i=0;i<4;i++){\n  int nx=x+dd[i],ny=y+dd[i^1];\n  if(!in(nx,ny,h,w)) continue;\n  if(map[nx][ny]=='.'&&(cnd[nx][ny]&m)==0) que.offerLast(new int[]{nx,ny});\n }\n while(!que.isEmpty()){\n  int[] p=que.pollFirst();\n  int px=p[0],py=p[1];\n  cnd[px][py]|=m;\n  for(int i=0;i<4;i++){\n   int nx=px+dd[i],ny=py+dd[i^1];\n   if(!in(nx,ny,h,w)) continue;\n   if(map[nx][ny]=='.'&&(cnd[nx][ny]&m)==0) que.offerLast(new int[]{nx,ny});\n  }\n }\n}\n\npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n\nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n\n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n\n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n \n public boolean hasNext(){skip(); return hasNextByte();}\n \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n\n public double nextDouble(){return Double.parseDouble(next());}\n\n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n\n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n\n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n\npublic class Main{\n\nstatic PrintWriter out;\nstatic InputReader ir;\n\nstatic void solve(){\n for(;;){\n  int w=ir.nextInt();\n  int h=ir.nextInt();\n  if(w==0&&h==0) return;\n  char[][] map=ir.nextCharMap(h,w);\n  int[][] cnd=new int[h][w];\n  for(int i=0;i<h;i++){\n   for(int j=0;j<w;j++){\n    if(map[i][j]!='.') bfs(i,j,map[i][j]=='B'?1:2,map,cnd);\n   }\n  }\n  int bl=0,wh=0;\n  for(int i=0;i<h;i++){\n   for(int j=0;j<w;j++){\n    if(cnd[i][j]==1) bl++;\n    if(cnd[i][j]==2) wh++;\n   }\n  }\n  out.println(bl+\" \"+wh);\n }\n}\n\nstatic final int[] dd=new int[]{0-1,0,1};\n\npublic static boolean in(int x,int y,int h,int w){\n return (x>=0&&y>=0&&x<h&&y<w);\n}\n\npublic static void bfs(int x,int y,int m,char[][] map,int[][] cnd){\n int h=map.length,w=map[0].length;\n Deque<int[]> que=new ArrayDeque<>();\n /*for(int i=0;i<4;i++){\n  int nx=x+dd[i],ny=y+dd[i^1];\n  if(!in(nx,ny,h,w)) continue;\n  if(map[nx][ny]=='.'&&(cnd[nx][ny]&m)==0) que.offerLast(new int[]{nx,ny});\n }*/\n /*while(!que.isEmpty()){\n  int[] p=que.pollFirst();\n  int px=p[0],py=p[1];\n  cnd[px][py]|=m;\n  for(int i=0;i<4;i++){\n   int nx=px+dd[i],ny=py+dd[i^1];\n   if(!in(nx,ny,h,w)) continue;\n   if(map[nx][ny]=='.'&&(cnd[nx][ny]&m)==0) que.offerLast(new int[]{nx,ny});\n  }\n }*/\n}\n\npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n\nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n\n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n\n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n \n public boolean hasNext(){skip(); return hasNextByte();}\n \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n\n public double nextDouble(){return Double.parseDouble(next());}\n\n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n\n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n\n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n\npublic class Main{\n\nstatic PrintWriter out;\nstatic InputReader ir;\n\nstatic void solve(){\n for(;;){\n  int w=ir.nextInt();\n  int h=ir.nextInt();\n  if(w==0&&h==0) return;\n  char[][] map=ir.nextCharMap(h,w);\n  int[][] cnd=new int[h][w];\n  for(int i=0;i<h;i++){\n   for(int j=0;j<w;j++){\n    if(map[i][j]!='.') bfs(i,j,map[i][j]=='B'?1:2,map,cnd);\n   }\n  }\n  int bl=0,wh=0;\n  for(int i=0;i<h;i++){\n   for(int j=0;j<w;j++){\n    if(cnd[i][j]==1) bl++;\n    if(cnd[i][j]==2) wh++;\n   }\n  }\n  out.println(bl+\" \"+wh);\n }\n}\n\nstatic final int[] dd=new int[]{0-1,0,1};\n\npublic static boolean in(int x,int y,int h,int w){\n return (x>=0&&y>=0&&x<h&&y<w);\n}\n\npublic static void bfs(int x,int y,int m,char[][] map,int[][] cnd){\n int h=map.length,w=map[0].length;\n Deque<int[]> que=new ArrayDeque<>();\n for(int i=0;i<4;i++){\n  int nx=x+dd[i],ny=y+dd[i^1];\n  if(!in(nx,ny,h,w)) continue;\n  if(map[nx][ny]=='.'&&(cnd[nx][ny]&m)==0) que.offerLast(new int[]{nx,ny});\n }\n /*while(!que.isEmpty()){\n  int[] p=que.pollFirst();\n  int px=p[0],py=p[1];\n  cnd[px][py]|=m;\n  for(int i=0;i<4;i++){\n   int nx=px+dd[i],ny=py+dd[i^1];\n   if(!in(nx,ny,h,w)) continue;\n   if(map[nx][ny]=='.'&&(cnd[nx][ny]&m)==0) que.offerLast(new int[]{nx,ny});\n  }\n }*/\n}\n\npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n\nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n\n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n\n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n \n public boolean hasNext(){skip(); return hasNextByte();}\n \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n\n public double nextDouble(){return Double.parseDouble(next());}\n\n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n\n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n\n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\nimport java.math.BigDecimal;\nimport java.awt.geom.*;\nimport static java.util.Arrays.*;\nimport static java.lang.Math.*;\n\npublic class Main{\n\n    static final Reader sc = new Reader();\n    static final PrintWriter out = new PrintWriter(System.out,false);\n\n    public static void main(String[] args) throws Exception {\n        while(true){\n\t        int w = sc.nextInt();\n    \t    int h = sc.nextInt();\n    \t    if(w==0 && h==0){\n    \t    \tbreak;\n    \t    }\n    \t    String[] str = new String[h];\n    \t    boolean[][] judge = new boolean[w][h];\n    \t    for(int i=0;i<h;i++){\n    \t    \tstr[i] = sc.next();\n    \t    }\n    \t    int[] dx = {-1,0,1,0};\n    \t    int[] dy = {0,-1,0,1};\n    \t    ArrayList<Point> list1 = new ArrayList<Point>();\n    \t    ArrayList<Point> list2 = new ArrayList<Point>();\n    \t    int bcount = 0;\n    \t    int wcount = 0;\n    \t    for(int i=0;i<h;i++){\n    \t    \tfor(int j=0;j<w;j++){\n    \t    \t\tif(str[i].charAt(j)!='.'){\n    \t    \t\t\tcontinue;\n    \t    \t\t}\n    \t    \t\tPoint point = new Point(j,i);\n    \t    \t\tboolean black = false;\n    \t    \t\tboolean white = false;\n    \t    \t\tlist1.add(point);\n    \t    \t\twhile(true){\n    \t    \t\t\twhile(!list1.isEmpty()){\n    \t    \t\t\t\tpoint = list1.get(0);\n    \t    \t\t\t\tlist1.remove(0);\n    \t    \t\t\t\tfor(int k=0;k<4;k++){\n    \t    \t\t\t\t\tif(point.x==0 && k==0){\n    \t    \t\t\t\t\t\tcontinue;\n    \t    \t\t\t\t\t}\n    \t    \t\t\t\t\tif(point.x==w-1&&k==2){\n    \t    \t\t\t\t\t\tcontinue;\n    \t    \t\t\t\t\t}\n    \t    \t\t\t\t\tif(point.y==0&&k==1){\n    \t    \t\t\t\t\t\tcontinue;\n    \t    \t\t\t\t\t}\n    \t    \t\t\t\t\tif(point.y==h-1&&k==3){\n    \t    \t\t\t\t\t\tcontinue;\n    \t    \t\t\t\t\t}\n    \t    \t\t\t\t\tif(str[point.y+dy[k]].charAt(point.x+dx[k])=='.' && !judge[point.x+dx[k]][point.y+dy[k]]){\n    \t    \t\t\t\t\t\tjudge[point.x+dx[k]][point.y+dy[k]] = true;\n    \t    \t\t\t\t\t\tPoint p = new Point(point.x+dx[k],point.y+dy[k]);\n    \t    \t\t\t\t\t\tlist2.add(p);\n    \t    \t\t\t\t\t}\n    \t    \t\t\t\t\tif(str[point.y+dy[k]].charAt(point.x+dx[k])=='B'){\n    \t    \t\t\t\t\t\tblack = true;\n    \t    \t\t\t\t\t}\n    \t    \t\t\t\t\tif(str[point.y+dy[k]].charAt(point.x+dx[k])=='W'){\n    \t    \t\t\t\t\t\twhite = true;\n    \t    \t\t\t\t\t}\n    \t    \t\t\t\t}\n    \t    \t\t\t}\n    \t    \t\t\tif(list2.isEmpty()){\n    \t    \t\t\t\tbreak;\n    \t    \t\t\t}\n    \t    \t\t\tlist1.clear();\n    \t    \t\t\tfor(int k=0;k<list2.size();k++){\n    \t    \t\t\t\tlist1.add(list2.get(k));\n    \t    \t\t\t}\n    \t    \t\t\tlist2.clear();\n    \t    \t\t}\n    \t    \t\tfor(int k=0;k<w;k++){\n    \t    \t\t\tArrays.fill(judge[k],false);\n    \t    \t\t}\n    \t    \t\tif(black && !white){\n    \t    \t\t\tbcount++;\n    \t    \t\t}\n    \t    \t\tif(!black && white){\n    \t    \t\t\twcount++;\n    \t    \t\t}\n    \t    \t}\n    \t    }\n    \t    out.println(bcount+\" \"+wcount);\n    \t    out.flush();\n    \t}\n        sc.close();\n        out.close();\n    }\n\n    static void trace(Object... o) { System.out.println(Arrays.deepToString(o));}\n}\n\nclass Point{\n\tint x;\n\tint y;\n\tPoint(int x,int y){\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n}\n\nclass Reader {\n    private final InputStream sc;\n    private final byte[] buf = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n\n    public Reader() { this(System.in);}\n    public Reader(InputStream source) { this.sc = source;}\n\n    private boolean hasNextByte() {\n        if (ptr < buflen) return true;\n        ptr = 0;\n        try{\n            buflen = sc\n\n.read(buf);\n        }catch (IOException e) {e.printStackTrace();}\n        if (buflen <= 0) return false;\n        return true;\n    }\n\n    private int readByte() { if (hasNextByte()) return buf[ptr++]; else return -1;}\n\n    private boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n\n    private void skip() { while(hasNextByte() && !isPrintableChar(buf[ptr])) ptr++;}\n\n    public boolean hasNext() {skip(); return hasNextByte();}\n\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while (isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        boolean minus = false;\n        long num = readByte();\n\n        if(num == '-'){\n            num = 0;\n            minus = true;\n        }else if (num < '0' || '9' < num){\n            throw new NumberFormatException();\n        }else{\n            num -= '0';\n        }\n        \n        while(true){\n            int b = readByte();\n            if('0' <= b && b <= '9')\n                num = num * 10 + (b - '0');\n            else if(b == -1 || !isPrintableChar(b))\n                return minus ? -num : num;\n            else\n                throw new NoSuchElementException();\n        }\n    }\n\n    public int nextInt() {\n        long num = nextLong();\n        if (num < Integer.MIN_VALUE || Integer.MAX_VALUE < num)\n            throw new NumberFormatException();\n        return (int)num;\n    }\n\n    public double nextDouble() {\n        return Double.parseDouble(next());\n    }\n\n    public char nextChar() {\n        if (!hasNext()) throw new NoSuchElementException();\n        return (char)readByte();\n    }\n\n    public String nextLine() {\n        while (hasNextByte() && (buf[ptr] == '\\n' || buf[ptr] == '\\r')) ptr++;\n        if (!hasNextByte()) throw new NoSuchElementException();\n\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while (b != '\\n' && b != '\\r') {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n\n        return sb.toString();\n    }\n\n    public int[] nextIntArray(int n) {\n        int[] res = new int[n];\n        for (int i=0; i<n; i++) res[i] = nextInt();\n        return res;\n    }\n\n    public char[] nextCharArray(int n) {\n        char[] res = new char[n];\n        for (int i=0; i<n; i++) res[i] = nextChar();\n        return res;\n    }\n\n    public void close() {try{ sc.close();}catch(IOException e){ e.printStackTrace();}};\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.regex.*;\n\nimport static java.lang.Math.*;\nimport static java.lang.System.out;\n\n// AOJ\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().AOJ2014();\n\t}\n\tclass Point{\n\t\tint x, y;\n\t\tPoint(int x, int y){\n\t\t\tthis.x=x;\tthis.y=y;\n\t\t}\n\t}\n\tint[] vx={1,0,-1,0};\tint[] vy={0,1,0,-1};\n\t\n\tvoid AOJ2014(){\n\t\twhile(sc.hasNext()){\n\t\t\tint W=sc.nextInt(), H=sc.nextInt();\n\t\t\tif((W|H)==0)\tbreak;\n\t\t\tchar[][] c=new char[W+2][H+2];\n\t\t\tfor(int i=0; i<W+2; i++){\n\t\t\t\tc[i][0]='A';\n\t\t\t\tc[i][H+1]='A';\n\t\t\t}\n\t\t\tfor(int i=0; i<H+2; i++){\n\t\t\t\tc[0][i]='A';\n\t\t\t\tc[W+1][i]='A';\n\t\t\t}\n\t\t\tfor(int y=0; y<H; y++){\n\t\t\t\tString line=sc.next();\n\t\t\t\tfor(int x=0; x<W; x++){\n\t\t\t\t\tc[x+1][y+1]=line.charAt(x);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// TODO debug\n\t\t\t//D2012(c,W,H);\n\t\t\t\n\t\t\tboolean[][] b=new boolean[W+2][H+2];\n\t\t\tboolean[][] w=new boolean[W+2][H+2];\n\t\t\t\n\t\t\t// B\n\t\t\tfor(int x=1; x<W+1; x++){\n\t\t\t\tfor(int y=1; y<H+1; y++){\n\t\t\t\t\tif(c[x][y]!='B')\tcontinue;\n\t\t\t\t\tLinkedList<Point> open=new LinkedList<Point>();\n\t\t\t\t\tboolean[][] close = new boolean[W+2][H+2];\n\t\t\t\t\topen.add(new Point(x,y));\n\t\t\t\t\twhile(!open.isEmpty()){\n\t\t\t\t\t\tPoint now=open.poll();\n\t\t\t\t\t\tclose[now.x][now.y]=true;\n\t\t\t\t\t\tb[now.x][now.y]=(c[now.x][now.y]=='.'?true:false);\n\t\t\t\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\t\t\t\tint xx=now.x+vx[i], yy=now.y+vy[i];\n\t\t\t\t\t\t\tif(!(0<xx&&xx<W+2 && 0<yy&&yy<H+2))\tcontinue;\n\t\t\t\t\t\t\tif(c[xx][yy]=='.' && !b[xx][yy] && !close[xx][yy]){\n\t\t\t\t\t\t\t\topen.add(new Point(xx,yy));\n\t\t\t\t\t\t\t\tclose[xx][yy]=true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// W\n\t\t\tfor(int x=1; x<W+1; x++){\n\t\t\t\tfor(int y=1; y<H+1; y++){\n\t\t\t\t\tif(c[x][y]!='W')\tcontinue;\n\t\t\t\t\tLinkedList<Point> open=new LinkedList<Point>();\n\t\t\t\t\tboolean[][] close = new boolean[W+2][H+2];\n\t\t\t\t\topen.add(new Point(x,y));\n\t\t\t\t\twhile(!open.isEmpty()){\n\t\t\t\t\t\tPoint now=open.poll();\n\t\t\t\t\t\tclose[now.x][now.y]=true;\n\t\t\t\t\t\tw[now.x][now.y]=(c[now.x][now.y]=='.'?true:false);\n\t\t\t\t\t\tfor(int i=0; i<4; i++){\n\t\t\t\t\t\t\tint xx=now.x+vx[i], yy=now.y+vy[i];\n\t\t\t\t\t\t\tif(!(0<xx&&xx<W+2 && 0<yy&&yy<H+2))\tcontinue;\n\t\t\t\t\t\t\tif(c[xx][yy]=='.' && !w[xx][yy] && !close[xx][yy]){\n\t\t\t\t\t\t\t\topen.add(new Point(xx,yy));\n\t\t\t\t\t\t\t\tclose[xx][yy]=true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// TODO debug\n\t\t\t//D2012(b,W,H);\n\t\t\t//D2012(w,W,H);\n\t\t\t\n\t\t\t\n\t\t\tint ansB=0, ansW=0;\n\t\t\tfor(int x=0; x<W+2; x++){\n\t\t\t\tfor(int y=0; y<H+2; y++){\n\t\t\t\t\tif(b[x][y] && !w[x][y])\tansB++;\n\t\t\t\t\tif(!b[x][y] && w[x][y])\tansW++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tout.println(ansB+\" \"+ansW);\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t}\n\t}\n\tvoid D2012(boolean[][] c, int W, int H){\n\t\tout.println(\"\\n\\n\");\n\t\tfor(int y=0; y<H+2; y++){\n\t\t\tfor(int x=0; x<W+2; x++){\n\t\t\t\tout.print(c[x][y]?\"T\":\".\");\n\t\t\t}\n\t\t\tout.println();\n\t\t}\n\t}\n\tvoid D2012(char[][] c, int W, int H){\n\t\tout.println(\"\\n-------------\");\n\t\tfor(int y=0; y<H+2; y++){\n\t\t\tfor(int x=0; x<W+2; x++){\n\t\t\t\tout.print(c[x][y]);\n\t\t\t}\n\t\t\tout.println();\n\t\t}\n\t\tout.println(\"\\n-------------\");\n\t}\n\t\n\tvoid AOJ2012(){\n\t\twhile(sc.hasNext()){\n\t\t\tint e=sc.nextInt(), ans=Integer.MAX_VALUE;\n\t\t\tif(e==0)\tbreak;\n\t\t\tfor(int i=0; i*i*i<=e; i++){\n\t\t\t\tfor(int j=0; j*j+i*i*i<=e; j++){\n\t\t\t\t\tint k=e-(i*i*i+j*j);\n\t\t\t\t\tif(i*i*i+j*j+k==e)\tans=min(ans,i+j+k);\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main{\n\n\n\tint h,w;\n\tvoid solve(){\n\n\t\tScanner cin = new Scanner(System.in);\n\t\twhile(true)\n\t\t{\n\t\t\tint h, w;\n\t\t\tw = cin.nextInt();\n\t\t\th = cin.nextInt();\n\t\t\tString[] board = new String[h];\n\t\t\tfor(int i=0;i<h;i++) board[i] = cin.next();\n\t\t\tboolean[][] white = new boolean[h][w];\n\t\t\tboolean[][] black = new boolean[h][w];\n\n\t\t\tint[] vx = new int[]{0,1,0,-1};\n\t\t\tint[] vy = new int[]{1,0,-1,0};\n\n\t\t\tfor(int turn = 0; turn<h*w;turn++){\n\t\t\t\tfor(int i=0;i<w;i++){\n\t\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\t\tint y = i; int x = j;\n\t\t\t\t\t\tif(board[i].charAt(j)!='.') continue;\n\t\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\t\tint ny = y + vy[k];\n\t\t\t\t\t\t\tint nx = x + vx[k];\n\t\t\t\t\t\t\tif(!ok(ny,nx)) continue;\n\t\t\t\t\t\t\tif(board[ny].charAt(nx)==('b')) black[y][x] = true;\n\t\t\t\t\t\t\tif(board[ny].charAt(nx)==('w')) white[y][x] = true;\n\t\t\t\t\t\t\tif(black[ny][nx]) black[y][x] = true;\n\t\t\t\t\t\t\tif(white[y][x]) white[y][x] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint bnum = 0;\n\t\t\tint wnum = 0;\n\t\t\tfor(int i=0;i<w;i++){\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tif(board[i].charAt(j)!='.') continue;\n\t\t\t\t\tif(white[i][j]&&!black[i][j]) wnum++;\n\t\t\t\t\tif(!white[i][j]&&black[i][j]) bnum++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(bnum + \" \" + wnum);\n\t\t}\n\t}\n\n\tboolean ok(int y, int x){\n\t\treturn y>=0 && x>=0 && y<h && x<w;\n\t}\n\n\n\tpublic static void main(String[] args){\n\t\tnew Main().solve();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tint w, h;\n\tchar[][] f;\n\tint[] dx = {-1, 0, 0, 1};\n\tint[] dy = {0, -1, 1, 0};\n\tboolean flgW, flgB;\n\n\tint dfs(int x, int y) {\n\t\tif (x < 0 || w <= x || y < 0 || h <= y) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (f[y][x] != '.') {\n\t\t\tif (f[y][x] == 'W') flgW = true;\n\t\t\tif (f[y][x] == 'B') flgB = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\tf[y][x] = 'X';\n\t\tint res = 1;\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tint nx = x + dx[i];\n\t\t\tint ny = y + dy[i];\n\t\t\tres += dfs(nx, ny);\n\t\t}\n\t\treturn res;\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile (true) {\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif ((w | h) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tf = new char[h][];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tf[i] = sc.next().toCharArray();\n\t\t\t}\n\n\t\t\tint sumW = 0, sumB = 0;\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tif (f[i][j] != '.') continue;\n\t\t\t\t\tflgW = flgB = false;\n\t\t\t\t\tint tmp = dfs(j, i);\n\t\t\t\t\tif (flgB && !flgW) {\n\t\t\t\t\t\tsumB += tmp;\n\t\t\t\t\t} else if (!flgB && flgW) {\n\t\t\t\t\t\tsumW += tmp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(sumB + \" \" + sumW);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n\npublic class Main{\n\nstatic PrintWriter out;\nstatic InputReader ir;\n\nstatic void solve(){\n for(;;){\n  w=ir.nextInt();\n  h=ir.nextInt();\n  if(w==0&&h==0) return;\n  map=ir.nextCharMap(h,w);\n  cnd=new int[h][w];\n  for(int i=0;i<h;i++){\n   for(int j=0;j<w;j++){\n    if(map[i][j]!='.'){\n     for(int i=0;i<4;i++){\n      int nx=x+dd[i],ny=y+dd[i^1];\n      if(!in(nx,ny)) continue;\n      if(map[nx][ny]=='.'&&(cnd[nx][ny]&m)==0) dfs(i,j,map[i][j]=='B'?1:2);\n     }\n    }\n   }\n  }\n  int bl=0,wh=0;\n  for(int i=0;i<h;i++){\n   for(int j=0;j<w;j++){\n    if(cnd[i][j]==1) bl++;\n    if(cnd[i][j]==2) wh++;\n   }\n  }\n  out.println(bl+\" \"+wh);\n }\n}\n\nstatic final int[] dd=new int[]{0,-1,0,1};\nstatic int w,h;\nstatic char[][] map;\nstatic int[][] cnd;\nstatic Deque<int[]> que=new ArrayDeque<>();\n\npublic static boolean in(int x,int y){\n return (x>=0&&y>=0&&x<h&&y<w);\n}\n\npublic static void dfs(int x,int y,int m){\n cnd[x][y]|=m;\n for(int i=0;i<4;i++){\n  int nx=x+dd[i],ny=y+dd[i^1];\n  if(!in(nx,ny)) continue;\n  if(map[nx][ny]=='.'&&(cnd[nx][ny]&m)==0) dfs(nx,ny,m);\n }\n}\n\npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n\nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n\n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n\n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n \n public boolean hasNext(){skip(); return hasNextByte();}\n \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n\n public double nextDouble(){return Double.parseDouble(next());}\n\n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n\n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n\n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tw = scanner.nextInt();\n\t\t\th = scanner.nextInt();\n\t\t\tif ((w | h) == 0)\n\t\t\t\tbreak;\n\t\t\tmap = new char[h][w];\n\t\t\tv = new boolean[h][w];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tmap[i] = scanner.next().toCharArray();\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tif (map[i][j] != '.') {\n\t\t\t\t\t\tv[i][j] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = new int[4];\n\t\t\tfor (int i = 0; i < h; i++)\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tu = 0;\n\t\t\t\t\tif (v[i][j])\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tint ret  = dfs(i, j);\n\t\t\t\t\tans[u] += ret;\n\t\t\t\t}\n\t\t\tSystem.out.println(ans[1] + \" \" + ans[2]);\n\t\t}\n\t}\n\n\tprivate int dfs(int y, int x) {\n\t\tint ret = 0;\n\t\tif (v[y][x])\n\t\t\treturn ret;\n\t\tv[y][x] = true;\n\t\tret++;\n\t\tfor (int[] m : move) {\n\t\t\tint ny = y + m[0];\n\t\t\tint nx = x + m[1];\n\t\t\tif (!isOK(ny, nx))\n\t\t\t\tcontinue;\n\t\t\tif (map[ny][nx] == 'B') {\n\t\t\t\tu |= 1;\n\t\t\t\tcontinue;\n\t\t\t} else if (map[ny][nx] == 'W') {\n\t\t\t\tu |= 2;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tret += dfs(ny, nx);\n\t\t}\n\t\treturn ret;\n\t}\n\n\tprivate boolean isOK(int y, int x) {\n\t\treturn 0 <= y && y < h && 0 <= x && x < w;\n\t}\n\n\tint w, h, u, ans[];\n\tboolean[][] v;\n\tchar[][] map;\n\tint[][] move = { { -1, 0 }, { 0, -1 }, { 0, 1 }, { 1, 0 } };\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    int h, w;\n    char[][] map;\n    boolean B, W;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        while(true){\n            w = sc.nextInt(); h = sc.nextInt();\n            if(w==0 && h==0) break;\n            map = new char[h][w];\n            for(int i=0; i<h; i++) map[i] = sc.next().toCharArray();\n\n            int cntB = 0, cntW = 0;\n            for(int i=0; i<h; i++){\n                for(int j=0; j<w; j++){\n                    if(map[i][j]!='.') continue;\n                    B = false;\n                    W = false;\n                    bfs(i, j);\n                    if(B && !W) cntB++;\n                    if(!B && W) cntW++;\n                }\n            }\n            System.out.println(cntB+\" \"+cntW);\n        }\n    }\n\n    int[] dx = {0, 0, 1, -1};\n    int[] dy = {1, -1, 0, 0};\n    void bfs(int y, int x){\n        LinkedList<int[]> q = new LinkedList<int[]>();\n        q.add(new int[]{x, y});\n        boolean[][] v = new boolean[h][w];\n\n        while(q.size()>0){\n            int[] qq = q.poll();\n            int X = qq[0], Y = qq[1];\n\n            if(v[Y][X]) continue;\n            v[Y][X] = true;\n\n            if(map[Y][X]=='W') {W = true; continue;}\n            if(map[Y][X]=='B') {B = true; continue;}\n\n            for(int i=0; i<4; i++){\n                int nx = X + dx[i], ny = Y + dy[i];\n                if(nx<0 || nx>=w || ny<0 || ny>=h) continue;\n                q.add(new int[]{nx, ny});\n            }\n        }\n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main{\n\n\n\tint h,w;\n\tvoid solve(){\n\n\t\tScanner cin = new Scanner(System.in);\n\t\twhile(true)\n\t\t{\n\t\t\tw = cin.nextInt();\n\t\t\th = cin.nextInt();\n\t\t\tif(w==0) break;\n\t\t\tString[] board = new String[h];\n\t\t\tfor(int i=0;i<h;i++) board[i] = cin.next();\n\t\t\tboolean[][] white = new boolean[h][w];\n\t\t\tboolean[][] black = new boolean[h][w];\n\n\t\t\tint[] vx = new int[]{0,1,0,-1};\n\t\t\tint[] vy = new int[]{1,0,-1,0};\n\n\t\t\tfor(int turn = 0; turn< h*w ;turn++){\n\t\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\t\tint y = i; int x = j;\n\t\t\t\t\t\tif(board[i].charAt(j)!='.') continue;\n\t\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\t\tint ny = y + vy[k];\n\t\t\t\t\t\t\tint nx = x + vx[k];\n\t\t\t\t\t\t\tif(!ok(ny,nx)) continue;\n\t\t\t\t\t\t\tif(board[ny].charAt(nx)=='B') black[y][x] = true;\n\t\t\t\t\t\t\tif(board[ny].charAt(nx)=='W') white[y][x] = true;\n\t\t\t\t\t\t\tif(black[ny][nx]) black[y][x] = true;\n\t\t\t\t\t\t\tif(white[ny][nx]) white[y][x] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint bnum = 0;\n\t\t\tint wnum = 0;\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tif(board[i].charAt(j)!='.') continue;\n\t\t\t\t\tif(white[i][j] && !black[i][j]) wnum++;\n\t\t\t\t\tif(!white[i][j] && black[i][j]) bnum++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(bnum + \" \" + wnum);\n\t\t}\n\t}\n\n\tboolean ok(int y, int x){\n\t\treturn y>=0 && x>=0 && y<h && x<w;\n\t}\n\n\n\tpublic static void main(String[] args){\n\t\tnew Main().solve();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n\npublic class Main{\n\nstatic PrintWriter out;\nstatic InputReader ir;\n\nstatic void solve(){\n for(;;){\n  int w=ir.nextInt();\n  int h=ir.nextInt();\n  if(w==0&&h==0) return;\n  map=ir.nextCharMap(h,w);\n  cnd=new int[h][w];\n  for(int i=0;i<h;i++){\n   for(int j=0;j<w;j++){\n    if(map[i][j]!='.') bfs(i,j,map[i][j]=='B'?1:2,map,cnd);\n   }\n  }\n  int bl=0,wh=0;\n  for(int i=0;i<h;i++){\n   for(int j=0;j<w;j++){\n    if(cnd[i][j]==1) bl++;\n    if(cnd[i][j]==2) wh++;\n   }\n  }\n  out.println(bl+\" \"+wh);\n }\n}\n\nstatic final int[] dd=new int[]{0,-1,0,1};\nstatic char[][] map;\nstatic int[][] cnd;\nstatic Deque<int[]> que=new ArrayDeque<>();\n\npublic static boolean in(int x,int y,int h,int w){\n return (x>=0&&y>=0&&x<h&&y<w);\n}\n\npublic static void bfs(int x,int y,int m,){\n int h=map.length,w=map[0].length;\n for(int i=0;i<4;i++){\n  int nx=x+dd[i],ny=y+dd[i^1];\n  if(!in(nx,ny,h,w)) continue;\n  if(map[nx][ny]=='.'&&(cnd[nx][ny]&m)==0) que.offerLast(new int[]{nx,ny});\n }\n while(!que.isEmpty()){\n  int[] p=que.pollFirst();\n  int px=p[0],py=p[1];\n  cnd[px][py]|=m;\n  for(int i=0;i<4;i++){\n   int nx=px+dd[i],ny=py+dd[i^1];\n   if(!in(nx,ny,h,w)) continue;\n   if(map[nx][ny]=='.'&&(cnd[nx][ny]&m)==0) que.offerLast(new int[]{nx,ny});\n  }\n }\n}\n\npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n\nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n\n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n\n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n \n public boolean hasNext(){skip(); return hasNextByte();}\n \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n\n public double nextDouble(){return Double.parseDouble(next());}\n\n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n\n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n\n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n\npublic class Main{\n\nstatic PrintWriter out;\nstatic InputReader ir;\n\nstatic void solve(){\n for(;;){\n  int w=ir.nextInt();\n  int h=ir.nextInt();\n  if(w==0&&h==0) return;\n  char[][] map=ir.nextCharMap(h,w);\n  int[][] cnd=new int[h][w];\n  for(int i=0;i<h;i++){\n   for(int j=0;j<w;j++){\n    if(map[i][j]!='.') bfs(i,j,map[i][j]=='B'?1:2,map,cnd);\n   }\n  }\n  int bl=0,wh=0;\n  for(int i=0;i<h;i++){\n   for(int j=0;j<w;j++){\n    if(cnd[i][j]==1) bl++;\n    if(cnd[i][j]==2) wh++;\n   }\n  }\n  out.println(bl+\" \"+wh);\n }\n}\n\nstatic final int[] dd=new int[]{0-1,0,1};\n\npublic static boolean in(int x,int y,int h,int w){\n return (x>=0&&y>=0&&x<h&&y<w);\n}\n\npublic static void bfs(int x,int y,int m,char[][] map,int[][] cnd){\n int h=map.length,w=map[0].length;\n Deque<int[]> que=new ArrayDeque<>();\n/* for(int i=0;i<4;i++){\n  int nx=x+dd[i],ny=y+dd[i^1];\n // if(!in(nx,ny,h,w)) continue;\n // if(map[nx][ny]=='.'&&(cnd[nx][ny]&m)==0) que.offerLast(new int[]{nx,ny});\n }*/\n /*while(!que.isEmpty()){\n  int[] p=que.pollFirst();\n  int px=p[0],py=p[1];\n  cnd[px][py]|=m;\n  for(int i=0;i<4;i++){\n   int nx=px+dd[i],ny=py+dd[i^1];\n   if(!in(nx,ny,h,w)) continue;\n   if(map[nx][ny]=='.'&&(cnd[nx][ny]&m)==0) que.offerLast(new int[]{nx,ny});\n  }\n }*/\n}\n\npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n\nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n\n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n\n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n \n public boolean hasNext(){skip(); return hasNextByte();}\n \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n\n public double nextDouble(){return Double.parseDouble(next());}\n\n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n\n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n\n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\npublic class Main\n{\n\tstatic int field[][];\n\tstatic int white=0,black=0,cnt,fb,fw;\n\tstatic int W,H;\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tfor(;;)\n\t\t{\n\t\t\tW=in.nextInt();\n\t\t\tH=in.nextInt();\n\t\t\tif((W|H)==0)\n\t\t\t\treturn;\n\t\t\tfield=new int[H][W];\n\t\t\tfor(int i=0;i<H;i++)\n\t\t\t{\n\t\t\t\tString st=in.next();\n\t\t\t\tfor(int j=0;j<W;j++)\n\t\t\t\t{\n\t\t\t\t\tif(st.charAt(j)=='.')\n\t\t\t\t\t\tfield[i][j]=0;\n\t\t\t\t\telse if(st.charAt(j)=='W')\n\t\t\t\t\t\tfield[i][j]=1;\n\t\t\t\t\telse if(st.charAt(j)=='B')\n\t\t\t\t\t\tfield[i][j]=2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tblack=0;\n\t\t\twhite=0;\n\t\t\tfor(int i=0;i<H;i++)\n\t\t\t{\n\t\t\t\tfor(int j=0;j<W;j++)\n\t\t\t\t{\n\t\t\t\t\tcnt=0;\n\t\t\t\t\tfb=0;\n\t\t\t\t\tfw=0;\n\t\t\t\t\tif(field[i][j]==0)\n\t\t\t\t\t\tsolve(i,j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(black+\" \"+white);\n\t\t}\t\n\t}\n\tpublic static void solve(int h,int w)\n\t{\n\t\tfield[h][w]=3;\n\t\tcnt++;\n\t\tif(h-1>=0&&field[h-1][w]==1)\n\t\t\tfw=1;\n\t\tif(h-1>=0&&field[h-1][w]==2)\n\t\t\tfb=1;\n\t\tif(h+1<H&&field[h+1][w]==1)\n\t\t\tfw=1;\n\t\tif(h+1<H&&field[h+1][w]==2)\n\t\t\tfb=1;\n\t\tif(w-1>=0&&field[h][w-1]==1)\n\t\t\tfw=1;\n\t\tif(w-1>=0&&field[h][w-1]==2)\n\t\t\tfb=1;\n\t\tif(w+1<W&&field[h][w+1]==1)\n\t\t\tfw=1;\n\t\tif(w+1<W&&field[h][w+1]==2)\n\t\t\tfb=1;\n\n\t\tif(h-1>=0&&field[h-1][w]==0)\n\t\t\tsolve(h-1,w);\n\t\tif(h+1<H&&field[h+1][w]==0)\n\t\t\tsolve(h+1,w);\n\t\tif(w-1>=0&&field[h][w-1]==0)\n\t\t\tsolve(h,w-1);\n\t\tif(w+1<W&&field[h][w+1]==0)\n\t\t\tsolve(h,w+1);\n\n\t\tif(fw==1&&fb==0)\n\t\t{\n\t\t\twhite+=cnt;\n\t\t\tcnt=0;\n\t\t\treturn;\n\t\t}\n\t\telse if(fw==0&&fb==1)\n\t\t{\n\t\t\tblack+=cnt;\n\t\t\tcnt=0;\n\t\t\treturn;\n\t\t}\n\t\telse if(fw==1&&fb==1)\n\t\t{\n\t\t\tcnt=0;\n\t\t\treturn;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n/**\n * Created by Reopard on 2014/07/06.\n */\npublic class Main{\n    static Scanner sc = new Scanner(System.in);\n    static int[] dx = {-1, 0, 1, 0};\n    static int[] dy = {0, -1, 0, 1};\n    static char[][] general;\n\n    public static void main(String[] args){\n\n        char[][] black_area, white_area;\n        int w, h, black, white;\n        while((w = sc.nextInt()) != 0 | (h = sc.nextInt()) != 0){\n            general = new char[h][w];\n            black_area = new char[h + 2][w + 2];\n            white_area = new char[h + 2][w + 2];\n            for(int i = 0; i < h; i++) general[i] = sc.next().toCharArray();\n            initArea(black_area, 'B');\n            initArea(white_area, 'W');\n            black = findAreaStock(black_area, 'B', 'W');\n            white = findAreaStock(white_area, 'W', 'B');\n            System.out.println(black + \" \" + white);\n        }\n    }\n\n    static void initArea(char[][] area, char side){\n        for(int i = 0; i < area[0].length; i++) area[0][i] = side;\n        for(int i = 1; i <= area.length - 2; i++){\n            area[i][0] = side;\n            for(int j = 0; j < general[i - 1].length; j++) area[i][j + 1] = general[i - 1][j];\n            area[i][area[i].length - 1] = side;\n        }\n        for(int i = 0; i < area[area.length - 1].length; i++) area[area.length - 1][i] = side;\n    }\n\n    static int findAreaStock(char[][] area, char side, char ob){\n        int temp = 0;\n        char[][] check_area;\n        for(int i = 1; i <= area.length - 2; i++){\n            for(int j = 1; j <= area[i].length - 2; j++){\n                if(area[i][j] == side){\n                    for(int k = 0; k < 4; k++){\n                        check_area = copyArea(area);\n                        if(checkStock(check_area, side, ob, j + dx[k], i + dy[k])){\n                            temp += calcArea(area, side, j + dx[k], i + dy[k]);\n                        }\n                    }\n                }\n            }\n        }\n        return temp;\n    }\n\n    static boolean checkStock(char[][] area, char side, char ob, int x, int y){\n        boolean temp = true;\n        if(area[y][x] == side || area[y][x] == '-') return true;\n        else if(area[y][x] == ob)  return false;\n        else if(area[y][x] == '.'){\n            area[y][x] = '-';\n            for(int i = 0; i < 4; i++) temp &= checkStock(area, side, ob, x + dx[i], y + dy[i]);\n        }\n        return temp;\n    }\n\n    static int calcArea(char[][] area, char side, int x, int y){\n        int count = 0;\n        if(area[y][x] == side){\n            return 0;\n        }else if(area[y][x] == '.'){\n            area[y][x] = ' ';\n            count++;\n            for(int i = 0; i < 4; i++){\n                count += calcArea(area, side, x + dx[i], y + dy[i]);\n            }\n        }\n        return count;\n    }\n\n    static char[][] copyArea(char[][] copying){\n        char[][] temp = new char[copying.length][copying[0].length];\n        for(int i = 0; i < copying.length; i++){\n            for(int j = 0; j < copying[i].length; j++){\n                temp[i][j] = copying[i][j];\n            }\n        }\n        return temp;\n\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tw = scanner.nextInt();\n\t\t\th = scanner.nextInt();\n\t\t\tif ((w | h) == 0)\n\t\t\t\tbreak;\n\t\t\tmap = new char[h][w];\n\t\t\tv = new boolean[h][w];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tmap[i] = scanner.next().toCharArray();\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tif (map[i][j] != '.') {\n\t\t\t\t\t\tv[i][j] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = new int[4];\n\t\t\tfor (int i = 0; i < h; i++)\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\t\n\t\t\t\t\tif (v[i][j])\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tu = 0;\n\t\t\t\t\tint ret  = dfs(i, j);\n\t\t\t\t\tans[u] += ret;\n\t\t\t\t}\n\t\t\tSystem.out.println(ans[1] + \" \" + ans[2]);\n\t\t}\n\t}\n\n\tprivate int dfs(int y, int x) {\n\t\tint ret = 0;\n\t\tif (v[y][x])\n\t\t\treturn ret;\n\t\tv[y][x] = true;\n\t\tret++;\n\t\tfor (int[] m : move) {\n\t\t\tint ny = y + m[0];\n\t\t\tint nx = x + m[1];\n\t\t\tif (!isOK(ny, nx))\n\t\t\t\tcontinue;\n\t\t\tif (map[ny][nx] == 'B') {\n\t\t\t\tu |= 1;\n\t\t\t\tcontinue;\n\t\t\t} else if (map[ny][nx] == 'W') {\n\t\t\t\tu |= 2;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tret += dfs(ny, nx);\n\t\t}\n\t\treturn ret;\n\t}\n\n\tprivate boolean isOK(int y, int x) {\n\t\treturn 0 <= y && y < h && 0 <= x && x < w;\n\t}\n\n\tint w, h, u, ans[];\n\tboolean[][] v;\n\tchar[][] map;\n\tint[][] move = { { -1, 0 }, { 0, -1 }, { 0, 1 }, { 1, 0 } };\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\npublic class Main\n{\n\tstatic int field[][];\n\tstatic int white=0,black=0,cnt,fb,fw;\n\tstatic int W,H;\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tfor(;;)\n\t\t{\n\t\t\tW=in.nextInt();\n\t\t\tH=in.nextInt();\n\t\t\tif((W|H)==0)\n\t\t\t\treturn;\n\t\t\tfield=new int[H][W];\n\t\t\tfor(int i=0;i<H;i++)\n\t\t\t{\n\t\t\t\tString st=in.next();\n\t\t\t\tfor(int j=0;j<W;j++)\n\t\t\t\t{\n\t\t\t\t\tif(st.charAt(j)=='.')\n\t\t\t\t\t\tfield[i][j]=0;\n\t\t\t\t\telse if(st.charAt(j)=='W')\n\t\t\t\t\t\tfield[i][j]=1;\n\t\t\t\t\telse if(st.charAt(j)=='B')\n\t\t\t\t\t\tfield[i][j]=2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tblack=0;\n\t\t\twhite=0;\n\t\t\tfor(int i=0;i<H;i++)\n\t\t\t{\n\t\t\t\tfor(int j=0;j<W;j++)\n\t\t\t\t{\n\t\t\t\t\tcnt=0;\n\t\t\t\t\tfb=0;\n\t\t\t\t\tfw=0;\n\t\t\t\t\tif(field[i][j]==0)\n\t\t\t\t\t\tsolve(i,j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(black+\" \"+white);\n\t\t}\t\n\t}\n\tpublic static void solve(int h,int w)\n\t{\n\t\tfield[h][w]=3;\n\t\tcnt++;\n\t\tif(h-1>=0&&field[h-1][w]==1)\n\t\t\tfw=1;\n\t\telse if(h-1>=0&&field[h-1][w]==2)\n\t\t\tfb=1;\n\t\telse if(h+1<H&&field[h+1][w]==1)\n\t\t\tfw=1;\n\t\telse if(h+1<H&&field[h+1][w]==2)\n\t\t\tfb=1;\n\t\telse if(w-1>=0&&field[h][w-1]==1)\n\t\t\tfw=1;\n\t\telse if(w-1>=0&&field[h][w-1]==2)\n\t\t\tfb=1;\n\t\telse if(w+1<W&&field[h][w+1]==1)\n\t\t\tfw=1;\n\t\telse if(w+1<W&&field[h][w+1]==2)\n\t\t\tfb=1;\n\n\t\tif(h-1>=0&&field[h-1][w]==0)\n\t\t\tsolve(h-1,w);\n\t\tif(h+1<H&&field[h+1][w]==0)\n\t\t\tsolve(h+1,w);\n\t\tif(w-1>=0&&field[h][w-1]==0)\n\t\t\tsolve(h,w-1);\n\t\tif(w+1<W&&field[h][w+1]==0)\n\t\t\tsolve(h,w+1);\n\n\t\tif(fw==1&&fb==0)\n\t\t{\n\t\t\twhite+=cnt;\n\t\t\tcnt=0;\n\t\t\treturn;\n\t\t}\n\t\telse if(fw==0&&fb==1)\n\t\t{\n\t\t\tblack+=cnt;\n\t\t\tcnt=0;\n\t\t\treturn;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcnt=0;\n\t\t\treturn;\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n    int h,w;\n    char[][] grid;\n    Boolean B,W;\n    int countB,countW;\n    int[] dx = {1,-1,0,0};\n    int[] dy = {0,0,1,-1};\n\n    void solve(){\n\tScanner sc = new Scanner(System.in);\n\tw = sc.nextInt();\n\twhile(w!=0){\n\t    h = sc.nextInt();\n\t    grid = new char[h][w];\n\t    for(int i=0; i<h; i++){\n\t\tString line = sc.next();\n\t\tgrid[i] = line.toCharArray();\n\t    }\n\n\t    countB = 0;\n\t    countW = 0;\n\t    for(int i=0; i<h; i++){\n\t\tfor(int j=0; j<w; j++){\n\t\t    if(grid[i][j]=='.'){\n\t\t\tB = false;\n\t\t\tW = false;\n\t\t\tdfs(j,i);\n\t\t\tif(B&&!W)countB++;\n\t\t\tif(!B&&W)countW++;\n\t\t    }\n\t\t}\n\t    }\n\n\t    System.out.println(countB+\" \"+countW);\n\n\t    w = sc.nextInt();\n\t}\n    }\n\n    void dfs(int x, int y){\n\tif(B && W)return;\n\tfor(int i=0; i<4; i++){\n\t    int nx = x+dx[i];\n\t    int ny = y+dy[i];\n\t    if(nx<w && nx>=0 && ny<h && ny>=0){\n\t\tif(grid[ny][nx]=='B')B = true;\n\t\telse if(grid[ny][nx]=='W')W = true;\n\t\telse if(grid[ny][nx]=='.'){\n\t\t    grid[y][x] = 'x';\n\t\t    dfs(nx,ny);\n\t\t    grid[y][x] = '.';\n\t\t}\n\t    }\n\t}\n    }\n    \n    public static void main(String[] args){\n\tnew Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tstatic char[][] field;\n\tstatic int w;\n\tstatic int h;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif (w == 0 && h == 0)\n\t\t\t\tbreak;\n\t\t\tfield = new char[h][w];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tString str = sc.next();\n\t\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\t\tfield[i][j] = str.charAt(j);\n\t\t\t}\n\t\t\tfor (int i = 0; i < h; i++)\n\t\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\t\tif (field[i][j] != '.')\n\t\t\t\t\t\tcheck(j, i);\n\t\t\tint black = 0;\n\t\t\tint white = 0;\n\t\t\tfor (int i = 0; i < h; i++)\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tif (field[i][j] == 'b')\n\t\t\t\t\t\tblack++;\n\t\t\t\t\tif (field[i][j] == 'w')\n\t\t\t\t\t\twhite++;\n\t\t\t\t}\n\t\t\tSystem.out.println(black + \" \" + white);\n\t\t}\n\t\tsc.close();\n\t}\n\n\tstatic void check(int x, int y) {\n\t\tint[] dx = { 0, 1, 0, -1 };\n\t\tint[] dy = { -1, 0, 1, 0 };\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tswitch (field[y][x]) {\n\t\t\tcase 'W':\n\t\t\tcase 'w':\n\t\t\t\tif (x + dx[i] >= 0 && x + dx[i] < w && y + dy[i] >= 0\n\t\t\t\t\t\t&& y + dy[i] < h)\n\t\t\t\t\tswitch (field[y + dy[i]][x + dx[i]]) {\n\t\t\t\t\tcase '.':\n\t\t\t\t\t\tfield[y + dy[i]][x + dx[i]] = 'w';\n\t\t\t\t\t\tcheck(x + dx[i], y + dy[i]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'B':\n\t\t\t\t\tcase 'b':\n\t\t\t\t\t\tfield[y + dy[i]][x + dx[i]] = 'n';\n\t\t\t\t\t\tcheck(x + dx[i], y + dy[i]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'B':\n\t\t\tcase 'b':\n\t\t\t\tif (x + dx[i] >= 0 && x + dx[i] < w && y + dy[i] >= 0\n\t\t\t\t\t\t&& y + dy[i] < h)\n\t\t\t\t\tswitch (field[y + dy[i]][x + dx[i]]) {\n\t\t\t\t\tcase '.':\n\t\t\t\t\t\tfield[y + dy[i]][x + dx[i]] = 'b';\n\t\t\t\t\t\tcheck(x + dx[i], y + dy[i]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'W':\n\t\t\t\t\tcase 'w':\n\t\t\t\t\t\tfield[y + dy[i]][x + dx[i]] = 'n';\n\t\t\t\t\t\tcheck(x + dx[i], y + dy[i]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'n':\n\t\t\t\tif (x + dx[i] >= 0 && x + dx[i] < w && y + dy[i] >= 0\n\t\t\t\t\t\t&& y + dy[i] < h)\n\t\t\t\t\tswitch (field[y + dy[i]][x + dx[i]]) {\n\t\t\t\t\tcase '.':\n\t\t\t\t\tcase 'b':\n\t\t\t\t\tcase 'w':\n\t\t\t\t\t\tfield[y + dy[i]][x + dx[i]] = 'n';\n\t\t\t\t\t\tcheck(x + dx[i], y + dy[i]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport static java.util.Arrays.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\t\n\tint w, h;\n\tint[][] W, B;\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tfor(;;) {\n\t\t\tw = sc.nextInt();\n\t\t\th = sc.nextInt();\n\t\t\tif( (w|h) == 0 ) break;\n\t\t\t\n\t\t\tW = new int[h+2][w+2];\n\t\t\tB = new int[h+2][w+2];\n\t\t\t\n\t\t\tfor(int[] a: W) fill(a, 1);\n\t\t\tfor(int[] a: B) fill(a, -1);\n\t\t\t\n\t\t\tboolean flg = false;\n\t\t\tfor(int i=1;i<=h;i++) {\n\t\t\t\tString str = sc.next();\n\t\t\t\tfor(int j=1;j<=w;j++) {\n\t\t\t\t\tif( str.charAt(j-1) == 'W' ) { flg = true; W[i][j] = B[i][j] = 1; }\n\t\t\t\t\telse if( str.charAt(j-1) == 'B' ) { flg = true; W[i][j] = B[i][j] = -1;}\n\t\t\t\t\telse W[i][j] = B[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint wc = 0, bc = 0;\n\t\t\t\n\t\t\tif(flg)\n\t\t\tfor(int i=1;i<=h;i++) for(int j=1;j<=w;j++) {\n\t\t\t\tint c = 0;\n\t\t\t\tif( W[i][j] == 0 ) c = dfs(j,i,1, W);\n\t\t\t\tif(c != 0) debug( j, i, c, \"W\" );\n\t\t\t\twc += max(c, 0);\n\t\t\t\tc  = 0;\n\t\t\t\tif( B[i][j] == 0 ) c = dfs(j,i,-1, B);\n\t\t\t\tif(c != 0) debug(j, i, c, \"B\");\n\t\t\t\tbc += max(c, 0);\n\t\t\t}\n\t\t\t\n///\t\t\tfor(int[] a: W) debug(a);\n//\t\t\tfor(int[] a: B) debug(a);\n\t\t\t\n\t\t\tSystem.out.println(bc + \" \" + wc);\n\t\t}\n\t}\n\t\n\tint[] dx = {-1,0,1,0};\n\tint[] dy = {0,-1,0,1};\n\t\n\tint dfs(int x, int y, int c, int[][] map) {\n\t\tif( map[y][x] == -c ) return -1;\n\t\tmap[y][x] = c;\n\t\t\n\t\tint cnt = 1;\n\t\tfor(int i=0;i<4;i++) if( map[y+dy[i]][x+dx[i]] != c ) {\n\t\t\tint cc = dfs(x+dx[i], y+dy[i], c, map);\n\t\t\tif( cc == -1 ) {cnt = -1; }\n\t\t\tif( cnt != -1 ) cnt += cc;\n\t\t}\n\t\t\n\t\treturn cnt;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\t\n\tvoid debug( Object... o ) {\n//\t\tSystem.err.println(deepToString(o));\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile (true) {\n\t\t\tfinal int w = sc.nextInt();\n\t\t\tfinal int h = sc.nextInt();\n\n\t\t\tif (w == 0 && h == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tint[][] map = new int[h][w];\n\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tchar[] input = sc.next().toCharArray();\n\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tif (input[j] == 'W') {\n\t\t\t\t\t\tmap[i][j] = 1;\n\t\t\t\t\t} else if (input[j] == 'B') {\n\t\t\t\t\t\tmap[i][j] = -1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmap[i][j] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint[][] w_dist = new int[h][w];\n\t\t\tint[][] b_dist = new int[h][w];\n\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tw_dist[i][j] = Integer.MAX_VALUE;\n\t\t\t\t\tb_dist[i][j] = Integer.MAX_VALUE;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\twhile(true){\n\t\t\t\tboolean updated = false;\n\t\t\t\t\n\t\t\t\t// w-forward\n\t\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\t\tif (map[i][j] == -1) {\n\t\t\t\t\t\t\tw_dist[i][j] = Integer.MAX_VALUE;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t} else if (map[i][j] == 1) {\n\t\t\t\t\t\t\tw_dist[i][j] = 0;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tint cur = w_dist[i][j];\n\n\t\t\t\t\t\tif (i == 0 && j == 0) {\n\t\t\t\t\t\t\tw_dist[i][j] = Math.min(Integer.MAX_VALUE, w_dist[i][j]);\n\t\t\t\t\t\t} else if (i == 0) {\n\t\t\t\t\t\t\tif (w_dist[i][j - 1] != Integer.MAX_VALUE) {\n\t\t\t\t\t\t\t\tw_dist[i][j] = Math.min(w_dist[i][j - 1] + 1, w_dist[i][j]);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tw_dist[i][j] = Math.min(w_dist[i][j - 1], w_dist[i][j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (j == 0) {\n\t\t\t\t\t\t\tif (w_dist[i - 1][j] != Integer.MAX_VALUE) {\n\t\t\t\t\t\t\t\tw_dist[i][j] = Math.min(w_dist[i - 1][j] + 1, w_dist[i][j]);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tw_dist[i][j] = Math.min(w_dist[i - 1][j], w_dist[i][j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfinal int min = Math.min(w_dist[i - 1][j],\n\t\t\t\t\t\t\t\t\tw_dist[i][j - 1]);\n\t\t\t\t\t\t\tif (min != Integer.MAX_VALUE) {\n\t\t\t\t\t\t\t\tw_dist[i][j] = Math.min(min + 1, w_dist[i][j]);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tw_dist[i][j] = Math.min(min, w_dist[i][j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(w_dist[i][j] != cur){\n\t\t\t\t\t\t\tupdated = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// w-back\n\t\t\t\tfor (int i = h - 1; i >= 0; i--) {\n\t\t\t\t\tfor (int j = w - 1; j >= 0; j--) {\n\t\t\t\t\t\tif (map[i][j] == -1) {\n\t\t\t\t\t\t\tw_dist[i][j] = Integer.MAX_VALUE;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t} else if (map[i][j] == 1) {\n\t\t\t\t\t\t\tw_dist[i][j] = 0;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tint cur = w_dist[i][j];\n\n\t\t\t\t\t\tif (i == h - 1 && j == w - 1) {\n\t\t\t\t\t\t\tw_dist[i][j] = Math.min(Integer.MAX_VALUE,\n\t\t\t\t\t\t\t\t\tw_dist[i][j]);\n\t\t\t\t\t\t} else if (i == h - 1) {\n\t\t\t\t\t\t\tif (w_dist[i][j + 1] != Integer.MAX_VALUE) {\n\t\t\t\t\t\t\t\tw_dist[i][j] = Math.min(w_dist[i][j + 1] + 1,\n\t\t\t\t\t\t\t\t\t\tw_dist[i][j]);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tw_dist[i][j] = Math.min(w_dist[i][j + 1],\n\t\t\t\t\t\t\t\t\t\tw_dist[i][j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (j == w - 1) {\n\t\t\t\t\t\t\tif (w_dist[i + 1][j] != Integer.MAX_VALUE) {\n\t\t\t\t\t\t\t\tw_dist[i][j] = Math.min(w_dist[i + 1][j] + 1,\n\t\t\t\t\t\t\t\t\t\tw_dist[i][j]);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tw_dist[i][j] = Math.min(w_dist[i + 1][j],\n\t\t\t\t\t\t\t\t\t\tw_dist[i][j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfinal int min = Math.min(w_dist[i + 1][j],\n\t\t\t\t\t\t\t\t\tw_dist[i][j + 1]);\n\t\t\t\t\t\t\tif (min != Integer.MAX_VALUE) {\n\t\t\t\t\t\t\t\tw_dist[i][j] = Math.min(min + 1, w_dist[i][j]);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tw_dist[i][j] = Math.min(min, w_dist[i][j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(w_dist[i][j] != cur){\n\t\t\t\t\t\t\tupdated = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// b-forward\n\t\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\t\tif (map[i][j] == 1) {\n\t\t\t\t\t\t\tb_dist[i][j] = Integer.MAX_VALUE;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t} else if (map[i][j] == -1) {\n\t\t\t\t\t\t\tb_dist[i][j] = 0;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tint cur = b_dist[i][j];\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (i == 0 && j == 0) {\n\t\t\t\t\t\t\tb_dist[i][j] = Integer.MAX_VALUE;\n\t\t\t\t\t\t} else if (i == 0) {\n\t\t\t\t\t\t\tif (b_dist[i][j - 1] != Integer.MAX_VALUE) {\n\t\t\t\t\t\t\t\tb_dist[i][j] = Math.min(b_dist[i][j - 1] + 1, b_dist[i][j]);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tb_dist[i][j] = Math.min(b_dist[i][j - 1], b_dist[i][j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (j == 0) {\n\t\t\t\t\t\t\tif (b_dist[i - 1][j] != Integer.MAX_VALUE) {\n\t\t\t\t\t\t\t\tb_dist[i][j] = Math.min(b_dist[i - 1][j] + 1, b_dist[i][j]);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tb_dist[i][j] = Math.min(b_dist[i - 1][j], b_dist[i][j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfinal int min = Math.min(b_dist[i - 1][j],\n\t\t\t\t\t\t\t\t\tb_dist[i][j - 1]);\n\t\t\t\t\t\t\tif (min != Integer.MAX_VALUE) {\n\t\t\t\t\t\t\t\tb_dist[i][j] = Math.min(min + 1, b_dist[i][j]);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tb_dist[i][j] = Math.min(min, b_dist[i][j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(b_dist[i][j] != cur){\n\t\t\t\t\t\t\tupdated = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// b-back\n\t\t\t\tfor (int i = h - 1; i >= 0; i--) {\n\t\t\t\t\tfor (int j = w - 1; j >= 0; j--) {\n\t\t\t\t\t\tif (map[i][j] == 1) {\n\t\t\t\t\t\t\tb_dist[i][j] = Integer.MAX_VALUE;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t} else if (map[i][j] == -1) {\n\t\t\t\t\t\t\tb_dist[i][j] = 0;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tint cur = b_dist[i][j];\n\n\t\t\t\t\t\tif (i == h - 1 && j == w - 1) {\n\t\t\t\t\t\t\tb_dist[i][j] = Math.min(Integer.MAX_VALUE,\n\t\t\t\t\t\t\t\t\tb_dist[i][j]);\n\t\t\t\t\t\t} else if (i == h - 1) {\n\t\t\t\t\t\t\tif (b_dist[i][j + 1] != Integer.MAX_VALUE) {\n\t\t\t\t\t\t\t\tb_dist[i][j] = Math.min(b_dist[i][j + 1] + 1,\n\t\t\t\t\t\t\t\t\t\tb_dist[i][j]);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tb_dist[i][j] = Math.min(b_dist[i][j + 1],\n\t\t\t\t\t\t\t\t\t\tb_dist[i][j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if (j == w - 1) {\n\t\t\t\t\t\t\tif (b_dist[i + 1][j] != Integer.MAX_VALUE) {\n\t\t\t\t\t\t\t\tb_dist[i][j] = Math.min(b_dist[i + 1][j] + 1,\n\t\t\t\t\t\t\t\t\t\tb_dist[i][j]);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tb_dist[i][j] = Math.min(b_dist[i + 1][j],\n\t\t\t\t\t\t\t\t\t\tb_dist[i][j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfinal int min = Math.min(b_dist[i + 1][j],\n\t\t\t\t\t\t\t\t\tb_dist[i][j + 1]);\n\t\t\t\t\t\t\tif (min != Integer.MAX_VALUE) {\n\t\t\t\t\t\t\t\tb_dist[i][j] = Math.min(min + 1, b_dist[i][j]);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tb_dist[i][j] = Math.min(min, b_dist[i][j]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(b_dist[i][j] != cur){\n\t\t\t\t\t\t\tupdated = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(!updated){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint b_count = 0;\n\t\t\tint w_count = 0;\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tfinal int w_d = w_dist[i][j] == Integer.MAX_VALUE ? Integer.MIN_VALUE\n\t\t\t\t\t\t\t: w_dist[i][j];\n\t\t\t\t\tfinal int b_d = b_dist[i][j] == Integer.MAX_VALUE ? Integer.MIN_VALUE\n\t\t\t\t\t\t\t: b_dist[i][j];\n\n\t\t\t\t\tif (w_d > 0 && b_d > 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t} else if (w_d > 0) {\n\t\t\t\t\t\tw_count++;\n\t\t\t\t\t} else if (b_d > 0) {\n\t\t\t\t\t\tb_count++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(b_count + \" \" + w_count);\n\t\t}\n\t}"
  },
  {
    "language": "Java",
    "code": "import java.io.InputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\n\npublic class Main{\n\nstatic PrintWriter out;\nstatic InputReader ir;\n\nstatic void solve(){\n for(;;){\n  int w=ir.nextInt();\n  int h=ir.nextInt();\n  if(w==0&&h==0) return;\n  char[][] map=ir.nextCharMap(h,w);\n  int[][] cnd=new int[h][w];\n  for(int i=0;i<h;i++){\n   for(int j=0;j<w;j++){\n    if(map[i][j]!='.') bfs(i,j,map[i][j]=='B'?1:2,map,cnd);\n   }\n  }\n  int bl=0,wh=0;\n  for(int i=0;i<h;i++){\n   for(int j=0;j<w;j++){\n    if(cnd[i][j]==1) bl++;\n    if(cnd[i][j]==2) wh++;\n   }\n  }\n  out.println(bl+\" \"+wh);\n }\n}\n\nstatic final int[] dd=new int[]{0-1,0,1};\n\npublic static boolean in(int x,int y,int h,int w){\n return (x>=0&&y>=0&&x<h&&y<w);\n}\n\npublic static void bfs(int x,int y,int m,char[][] map,int[][] cnd){\n int h=map.length,w=map[0].length;\n Deque<int[]> que=new ArrayDeque<>();\n for(int i=0;i<4;i++){\n  int nx=x+dd[i],ny=y+dd[i^1];\n  if(in(nx,ny,h,w)&&map[nx][ny]=='.') que.offerLast(new int[]{nx,ny});\n }\n while(!que.isEmpty()){\n  int[] p=que.pollFirst();\n  int px=p[0],py=p[1];\n  cnd[px][py]|=m;\n  for(int i=0;i<4;i++){\n   int nx=px+dd[i],ny=py+dd[i^1];\n   if(in(nx,ny,h,w)&&map[nx][ny]=='.'&&(cnd[nx][ny]&m)==0) que.offerLast(new int[]{nx,ny});\n  }\n }\n}\n\npublic static void main(String[] args) throws Exception{\n ir=new InputReader(System.in);\n out=new PrintWriter(System.out);\n solve();\n out.flush();\n}\n\nstatic class InputReader {\n private InputStream in;\n private byte[] buffer=new byte[1024];\n private int curbuf;\n private int lenbuf;\n\n public InputReader(InputStream in) {this.in=in; this.curbuf=this.lenbuf=0;}\n \n public boolean hasNextByte() {\n  if(curbuf>=lenbuf){\n   curbuf= 0;\n   try{\n    lenbuf=in.read(buffer);\n   }catch(IOException e) {\n    throw new InputMismatchException();\n   }\n   if(lenbuf<=0) return false;\n  }\n  return true;\n }\n\n private int readByte(){if(hasNextByte()) return buffer[curbuf++]; else return -1;}\n \n private boolean isSpaceChar(int c){return !(c>=33&&c<=126);}\n \n private void skip(){while(hasNextByte()&&isSpaceChar(buffer[curbuf])) curbuf++;}\n \n public boolean hasNext(){skip(); return hasNextByte();}\n \n public String next(){\n  if(!hasNext()) throw new NoSuchElementException();\n  StringBuilder sb=new StringBuilder();\n  int b=readByte();\n  while(!isSpaceChar(b)){\n   sb.appendCodePoint(b);\n   b=readByte();\n  }\n  return sb.toString();\n }\n \n public int nextInt() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  int res=0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n \n public long nextLong() {\n  if(!hasNext()) throw new NoSuchElementException();\n  int c=readByte();\n  while (isSpaceChar(c)) c=readByte();\n  boolean minus=false;\n  if (c=='-') {\n   minus=true;\n   c=readByte();\n  }\n  long res = 0;\n  do{\n   if(c<'0'||c>'9') throw new InputMismatchException();\n   res=res*10+c-'0';\n   c=readByte();\n  }while(!isSpaceChar(c));\n  return (minus)?-res:res;\n }\n\n public double nextDouble(){return Double.parseDouble(next());}\n\n public int[] nextIntArray(int n){\n  int[] a=new int[n];\n  for(int i=0;i<n;i++) a[i]=nextInt();\n  return a;\n }\n\n public long[] nextLongArray(int n){\n  long[] a=new long[n];\n  for(int i=0;i<n;i++) a[i]=nextLong();\n  return a;\n }\n\n public char[][] nextCharMap(int n,int m){\n  char[][] map=new char[n][m];\n  for(int i=0;i<n;i++) map[i]=next().toCharArray();\n  return map;\n }\n}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\npublic class Main\n{\n\tstatic int field[][];\n\tstatic int white=0,black=0,cnt,fb,fw;\n\tstatic int W,H;\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tfor(;;)\n\t\t{\n\t\t\tW=in.nextInt();\n\t\t\tH=in.nextInt();\n\t\t\tif((W|H)==0)\n\t\t\t\treturn;\n\t\t\tfield=new int[H][W];\n\t\t\tfor(int i=0;i<H;i++)\n\t\t\t{\n\t\t\t\tString st=in.next();\n\t\t\t\tfor(int j=0;j<W;j++)\n\t\t\t\t{\n\t\t\t\t\tif(st.charAt(j)=='.')\n\t\t\t\t\t\tfield[i][j]=0;\n\t\t\t\t\telse if(st.charAt(j)=='W')\n\t\t\t\t\t\tfield[i][j]=1;\n\t\t\t\t\telse if(st.charAt(j)=='B')\n\t\t\t\t\t\tfield[i][j]=2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tblack=0;\n\t\t\twhite=0;\n\t\t\tfor(int i=0;i<H;i++)\n\t\t\t{\n\t\t\t\tfor(int j=0;j<W;j++)\n\t\t\t\t{\n\t\t\t\t\tcnt=0;\n\t\t\t\t\tfb=0;\n\t\t\t\t\tfw=0;\n\t\t\t\t\tif(field[i][j]==0)\n\t\t\t\t\t\tsolve(i,j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(black+\" \"+white);\n\t\t}\t\n\t}\n\tpublic static void solve(int h,int w)\n\t{\n\t\tfield[h][w]=3;\n\t\tcnt++;\n\t\tif(h-1>=0&&field[h-1][w]==1)\n\t\t\tfw=1;\n\t\tif(h-1>=0&&field[h-1][w]==2)\n\t\t\tfb=1;\n\t\tif(h+1<H&&field[h+1][w]==1)\n\t\t\tfw=1;\n\t\tif(h+1<H&&field[h+1][w]==2)\n\t\t\tfb=1;\n\t\tif(w-1>=0&&field[h][w-1]==1)\n\t\t\tfw=1;\n\t\tif(w-1>=0&&field[h][w-1]==2)\n\t\t\tfb=1;\n\t\tif(w+1<W&&field[h][w+1]==1)\n\t\t\tfw=1;\n\t\tif(w+1<W&&field[h][w+1]==2)\n\t\t\tfb=1;\n\t\tif(h-1>=0&&w-1>=0&&field[h-1][w-1]==1)\n\t\t\tfw=1;\n\t\tif(h-1>=0&&w-1>=0&&field[h-1][w-1]==2)\n\t\t\tfb=1;\n\t\tif(h-1>=0&&w+1<W&&field[h-1][w+1]==1)\n\t\t\tfw=1;\n\t\tif(h-1>=0&&w+1<W&&field[h-1][w+1]==2)\n\t\t\tfb=1;\n\t\tif(h+1<H&&w+1<W&&field[h+1][w+1]==1)\n\t\t\tfw=1;\n\t\tif(h+1<H&&w+1<W&&field[h+1][w+1]==2)\n\t\t\tfb=1;\n\t\tif(h+1<H&&w-1>=0&&field[h+1][w-1]==1)\n\t\t\tfw=1;\n\t\tif(h+1<H&&w-1>=0&&field[h+1][w-1]==2)\n\t\t\tfb=1;\n\t\t\n\t\tif(h-1>=0&&field[h-1][w]==0)\n\t\t\tsolve(h-1,w);\n\t\tif(h+1<H&&field[h+1][w]==0)\n\t\t\tsolve(h+1,w);\n\t\tif(w-1>=0&&field[h][w-1]==0)\n\t\t\tsolve(h,w-1);\n\t\tif(w+1<W&&field[h][w+1]==0)\n\t\t\tsolve(h,w+1);\n\n\t\tif(fw==1&&fb==0)\n\t\t{\n\t\t\twhite+=cnt;\n\t\t\tcnt=0;\n\t\t\tfw=0;\n\t\t\tfb=0;\n\t\t\treturn;\n\t\t}\n\t\telse if(fw==0&&fb==1)\n\t\t{\n\t\t\tblack+=cnt;\n\t\t\tcnt=0;\n\t\t\tfw=0;\n\t\t\tfb=0;\n\t\t\treturn;\n\t\t}\n\t\telse if(fw==1&&fb==1)\n\t\t{\n\t\t\tcnt=0;\n\t\t\treturn;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace V2014{\n    public class Program{\n        readonly int W;\n        readonly int H;\n        readonly string[] A;\n\n        readonly int[][] _grid;\n        readonly int[] _dx = {1, 0, -1, 0};\n        readonly int[] _dy = {0, 1, 0, -1};\n\n        bool IsInside(int x, int y){\n            return 0 <= x && x < W && 0 <= y && y < H;\n        }\n\n        public static void Main(string[] args){\n            new Program().Nyan();\n        }\n\n        void Nyan() { }\n\n        Program(){\n            while(true){\n                var sr = new StreamReader();\n                W = sr.Next<int>();\n                H = sr.Next<int>();\n                A = sr.Next<string>(H);\n                if(W + H == 0) return;\n\n                _grid = new int[H, W].ToJaggedArray();\n                for(var i = 0; i < H; i++){\n                    for(var j = 0; j < W; j++){\n                        _grid[i][j] = \".BW\".IndexOf(A[i][j]);\n                    }\n                }\n                Solve();\n            }\n        }\n\n        void Solve(){\n            var dic = new Dictionary<int, int>{{-1, 0}, {1, 0}};\n            for(var i = 0; i < H; i++){\n                for(var j = 0; j < W; j++){\n                    var count = Bfs(j, i);\n                    if(dic.ContainsKey(Math.Sign(count))){\n                        dic[Math.Sign(count)] += Math.Sign(count) * count;\n                    }\n                }\n            }\n            Console.WriteLine(string.Join(\" \", dic.Values.Select(x => x.ToString()).ToArray()));\n        }\n\n        int Bfs(int x, int y){\n            if(_grid[y][x] != 0) return 0;\n\n            var count = 1;\n            _grid[y][x] = int.MinValue;\n            var hs = new HashSet<int>();\n\n            var que = new Queue<int>();\n            que.Enqueue(x);\n            que.Enqueue(y);\n\n            while(que.Count > 0){\n                var cx = que.Dequeue();\n                var cy = que.Dequeue();\n                for(var i = 0; i < _dx.Length; i++){\n                    var nx = cx + _dx[i];\n                    var ny = cy + _dy[i];\n                    if(IsInside(nx, ny) && _grid[ny][nx] != int.MinValue){\n                        if(_grid[ny][nx] == 0){\n                            que.Enqueue(nx);\n                            que.Enqueue(ny);\n                            _grid[ny][nx] = int.MinValue;\n                            count++;\n                        } else{\n                            hs.Add(_grid[ny][nx]);\n                        }\n                    }\n                }\n            }\n            if(hs.Count != 1) return 0;\n            return (2 * hs.Single() - 3) * count;\n        }\n    }\n\n    public static class ExMethod{\n        public static T[][] ToJaggedArray<T>(this T[,] src){\n            var x = src.GetLength(1);\n            var y = src.GetLength(0);\n            var ret = new T[y][];\n\n            for(var i = 0; i < y; i++){\n                ret[i] = new T[x];\n                for(var j = 0; j < x; j++){\n                    ret[i][j] = src[i, j];\n                }\n            }\n\n            return ret;\n        }\n    }\n\n    public class StreamReader{\n        private readonly char[] _c = {' '};\n        private int _index = -1;\n        private string[] _input = new string[0];\n        private readonly System.IO.StreamReader _sr = new System.IO.StreamReader(Console.OpenStandardInput());\n\n        public T Next<T>(){\n            if(_index == _input.Length - 1){\n                _index = -1;\n                while(true){\n                    string rl = _sr.ReadLine();\n                    if(rl == null){\n                        if(typeof(T).IsClass) return default(T);\n                        return (T)typeof(T).GetField(\"MinValue\").GetValue(null);\n                    }\n                    if(rl != \"\"){\n                        _input = rl.Split(_c, StringSplitOptions.RemoveEmptyEntries);\n                        break;\n                    }\n                }\n            }\n            return (T)Convert.ChangeType(_input[++_index], typeof(T), System.Globalization.CultureInfo.InvariantCulture);\n        }\n\n        public T[] Next<T>(int x){\n            var ret = new T[x];\n            for(var i = 0; i < x; ++i) ret[i] = Next<T>();\n            return ret;\n        }\n\n        public T[][] Next<T>(int y, int x){\n            var ret = new T[y][];\n            for(var i = 0; i < y; ++i) ret[i] = Next<T>(x);\n            return ret;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace V2014{\n    public class Program{\n        \n        readonly int W;\n        readonly int H;\n        //readonly string[] A;\n        /*\n        readonly int[][] _grid;\n        readonly int[] _dx = {1, 0, -1, 0};\n        readonly int[] _dy = {0, 1, 0, -1};\n\n        bool IsInside(int x, int y){\n            return 0 <= x && x < W && 0 <= y && y < H;\n        }\n        */\n        public static void Main(string[] args){\n            new Program();\n        }\n        \n        Program(){\n            while(true){\n                var sr = new StreamReader();\n                W = sr.Next<int>();\n                H = sr.Next<int>();\n                //A = sr.Next<string>(H);\n                if(W + H == 0) return;\n\n                //_grid = new int[H, W].ToJaggedArray();\n                for(var i = 0; i < H; i++){\n                    for(var j = 0; j < W; j++){\n                        //_grid[i][j] = \".BW\".IndexOf(A[i][j]);\n                    }\n                }\n                //Solve();\n            }\n        }\n        /*\n        void Solve(){\n            var dic = new Dictionary<int, int>{{-1, 0}, {1, 0}};\n            for(var i = 0; i < H; i++){\n                for(var j = 0; j < W; j++){\n                    var count = Bfs(j, i);\n                    if(dic.ContainsKey(Math.Sign(count))){\n                        dic[Math.Sign(count)] += Math.Sign(count) * count;\n                    }\n                }\n            }\n            Console.WriteLine(string.Join(\" \", dic.Values.Select(x => x.ToString()).ToArray()));\n        }\n\n        int Bfs(int x, int y){\n            if(_grid[y][x] != 0) return 0;\n\n            var count = 1;\n            _grid[y][x] = int.MinValue;\n            var hs = new HashSet<int>();\n\n            var que = new Queue<int>();\n            que.Enqueue(x);\n            que.Enqueue(y);\n\n            while(que.Count > 0){\n                var cx = que.Dequeue();\n                var cy = que.Dequeue();\n                for(var i = 0; i < _dx.Length; i++){\n                    var nx = cx + _dx[i];\n                    var ny = cy + _dy[i];\n                    if(IsInside(nx, ny) && _grid[ny][nx] != int.MinValue){\n                        if(_grid[ny][nx] == 0){\n                            que.Enqueue(nx);\n                            que.Enqueue(ny);\n                            _grid[ny][nx] = int.MinValue;\n                            count++;\n                        } else{\n                            hs.Add(_grid[ny][nx]);\n                        }\n                    }\n                }\n            }\n            if(hs.Count != 1) return 0;\n            return (2 * hs.Single() - 3) * count;\n        }\n        */\n    }\n\n    public static class ExMethod{\n        public static T[][] ToJaggedArray<T>(this T[,] src){\n            var x = src.GetLength(1);\n            var y = src.GetLength(0);\n            var ret = new T[y][];\n\n            for(var i = 0; i < y; i++){\n                ret[i] = new T[x];\n                for(var j = 0; j < x; j++){\n                    ret[i][j] = src[i, j];\n                }\n            }\n\n            return ret;\n        }\n    }\n\n    public class StreamReader{\n        private readonly char[] _c = {' '};\n        private int _index = -1;\n        private string[] _input = new string[0];\n        private readonly System.IO.StreamReader _sr = new System.IO.StreamReader(Console.OpenStandardInput());\n\n        public T Next<T>(){\n            if(_index == _input.Length - 1){\n                _index = -1;\n                while(true){\n                    string rl = _sr.ReadLine();\n                    if(rl == null){\n                        if(typeof(T).IsClass) return default(T);\n                        return (T)typeof(T).GetField(\"MinValue\").GetValue(null);\n                    }\n                    if(rl != \"\"){\n                        _input = rl.Split(_c, StringSplitOptions.RemoveEmptyEntries);\n                        break;\n                    }\n                }\n            }\n            return (T)Convert.ChangeType(_input[++_index], typeof(T), System.Globalization.CultureInfo.InvariantCulture);\n        }\n\n        public T[] Next<T>(int x){\n            var ret = new T[x];\n            for(var i = 0; i < x; ++i) ret[i] = Next<T>();\n            return ret;\n        }\n\n        public T[][] Next<T>(int y, int x){\n            var ret = new T[y][];\n            for(var i = 0; i < y; ++i) ret[i] = Next<T>(x);\n            return ret;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.IO;\nusing System.Linq;\nusing System.Numerics;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Threading.Tasks;\nusing static System.Math;\nusing MethodImplAttribute = System.Runtime.CompilerServices.MethodImplAttribute;\nusing MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions;\n\npublic static class P\n{\n    const int PACKET_SIZE = 512;\n    public static void Main()\n    {\n        while (true)\n        {\n            var wh = Console.ReadLine().Split().Select(int.Parse).ToArray();\n            var w = wh[0];\n            var h = wh[1];\n            if (w == 0) break;\n\n            var map = Enumerable.Repeat(0, h).SelectMany(_ => Console.ReadLine()).ToArray();\n\n            List<int>[] graph = Enumerable.Repeat(0, h * w).Select(_ => new List<int>()).ToArray();\n            for (int i = 0; i < h - 1; i++)\n                for (int j = 0; j < w; j++)\n                { var id = i * w + j; graph[id].Add(id + w); graph[id + w].Add(id); }\n            for (int i = 0; i < h; i++)\n                for (int j = 0; j < w - 1; j++)\n                { var id = i * w + j; graph[id].Add(id + 1); graph[id + 1].Add(id); }\n\n            int[] flag = new int[w * h];\n            UnionFind uf = new UnionFind(w * h);\n            for (int i = 0; i < graph.Length; i++)\n            {\n                if (map[i] != '.') continue;\n                foreach (var j in graph[i])\n                {\n                    if (map[j] == '.')\n                    {\n                        uf.TryUnite(i, j);\n                    }\n                    if (map[j] == 'B')\n                    {\n                        flag[i] |= 1;\n                    }\n                    if (map[j] == 'W')\n                    {\n                        flag[i] |= 2;\n                    }\n                }\n            }\n\n            int res1 = 0;\n            int res2 = 0;\n            foreach (var item in Enumerable.Range(0, w * h).GroupBy(x => uf.Find(x)))\n            {\n                var count = item.Count();\n                var a = item.Aggregate(0, (x, y) => x | flag[y]);\n                if (a == 1) res1 += count;\n                if (a == 2) res2 += count;\n            }\n\n            Console.WriteLine($\"{res1} {res2}\");\n        }\n    }\n}\n\n\nclass UnionFind\n{\n    public int Size { get; private set; }\n    public int GroupCount { get; private set; }\n    public IEnumerable<int> AllRepresents => Parent.Where((x, y) => x == y);\n    int[] Sizes;\n    int[] Parent;\n    public UnionFind(int count)\n    {\n        Size = count;\n        GroupCount = count;\n        Parent = new int[count];\n        Sizes = new int[count];\n        for (int i = 0; i < count; i++) Sizes[Parent[i] = i] = 1;\n    }\n    public bool TryUnite(int x, int y)\n    {\n        int xp = Find(x);\n        int yp = Find(y);\n        if (yp == xp) return false;\n        if (Sizes[xp] < Sizes[yp]) { var tmp = xp; xp = yp; yp = tmp; }\n        GroupCount--;\n        Parent[yp] = xp;\n        Sizes[xp] += Sizes[yp];\n        return true;\n    }\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public int GetSize(int x) => Sizes[Find(x)];\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public int Find(int x)\n    {\n        while (x != Parent[x]) x = (Parent[x] = Parent[Parent[x]]);\n        return x;\n    }\n}\n\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace V2014{\n    public class Program{\n        int W;\n        int H;\n        string[] A;\n\n        int[][] _grid;\n        int[] _dx = {1, 0, -1, 0};\n        int[] _dy = {0, 1, 0, -1};\n\n        bool IsInside(int x, int y){\n            return 0 <= x && x < W && 0 <= y && y < H;\n        }\n\n        public static void Main(string[] args){\n            new Program().Solve();\n        }\n\n        void Solve(){\n            while(true){\n                var sr = new StreamReader();\n                W = sr.Next<int>();\n                H = sr.Next<int>();\n                A = sr.Next<string>(H);\n                if(W + H == 0) return;\n\n                _grid = new int[H, W].ToJaggedArray();\n                for(var i = 0; i < H; i++){\n                    for(var j = 0; j < W; j++){\n                        _grid[i][j] = \".BW\".IndexOf(A[i][j]);\n                    }\n                }\n\n                var dic = new Dictionary<int, int>{{-1, 0}, {1, 0}};\n                for(var i = 0; i < H; i++){\n                    for(var j = 0; j < W; j++){\n                        var count = Bfs(j, i);\n                        if(dic.ContainsKey(Math.Sign(count))){\n                            dic[Math.Sign(count)] += Math.Sign(count) * count;\n                        }\n                    }\n                }\n                Console.WriteLine(string.Join(\" \", dic.Values.Select(x => x.ToString()).ToArray()));\n            }\n        }\n\n        int Bfs(int x, int y){\n            if(_grid[y][x] != 0) return 0;\n\n            var count = 1;\n            _grid[y][x] = int.MinValue;\n            var hs = new HashSet<int>();\n\n            var que = new Queue<int>();\n            que.Enqueue(x);\n            que.Enqueue(y);\n\n            while(que.Count > 0){\n                var cx = que.Dequeue();\n                var cy = que.Dequeue();\n                for(var i = 0; i < _dx.Length; i++){\n                    var nx = cx + _dx[i];\n                    var ny = cy + _dy[i];\n                    if(IsInside(nx, ny) && _grid[ny][nx] != int.MinValue){\n                        if(_grid[ny][nx] == 0){\n                            que.Enqueue(nx);\n                            que.Enqueue(ny);\n                            _grid[ny][nx] = int.MinValue;\n                            count++;\n                        } else{\n                            hs.Add(_grid[ny][nx]);\n                        }\n                    }\n                }\n            }\n            if(hs.Count != 1) return 0;\n            return (2 * hs.Single() - 3) * count;\n        }\n    }\n\n    public static class ExMethod{\n        public static T[][] ToJaggedArray<T>(this T[,] src){\n            var x = src.GetLength(1);\n            var y = src.GetLength(0);\n            var ret = new T[y][];\n\n            for(var i = 0; i < y; i++){\n                ret[i] = new T[x];\n                for(var j = 0; j < x; j++){\n                    ret[i][j] = src[i, j];\n                }\n            }\n\n            return ret;\n        }\n    }\n\n    public class StreamReader{\n        private readonly char[] _c = {' '};\n        private int _index = -1;\n        private string[] _input = new string[0];\n        private readonly System.IO.StreamReader _sr = new System.IO.StreamReader(Console.OpenStandardInput());\n\n        public T Next<T>(){\n            if(_index == _input.Length - 1){\n                _index = -1;\n                while(true){\n                    string rl = _sr.ReadLine();\n                    if(rl == null){\n                        if(typeof(T).IsClass) return default(T);\n                        return (T)typeof(T).GetField(\"MinValue\").GetValue(null);\n                    }\n                    if(rl != \"\"){\n                        _input = rl.Split(_c, StringSplitOptions.RemoveEmptyEntries);\n                        break;\n                    }\n                }\n            }\n            return (T)Convert.ChangeType(_input[++_index], typeof(T), System.Globalization.CultureInfo.InvariantCulture);\n        }\n\n        public T[] Next<T>(int x){\n            var ret = new T[x];\n            for(var i = 0; i < x; ++i) ret[i] = Next<T>();\n            return ret;\n        }\n\n        public T[][] Next<T>(int y, int x){\n            var ret = new T[y][];\n            for(var i = 0; i < y; ++i) ret[i] = Next<T>(x);\n            return ret;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace V2014{\n    public class Program{\n        int W;\n        int H;\n        string[] A;\n        \n        int[][] _grid;\n        //int[] _dx = {1, 0, -1, 0};\n        //int[] _dy = {0, 1, 0, -1};\n        \n        bool IsInside(int x, int y){\n            return 0 <= x && x < W && 0 <= y && y < H;\n        }\n        \n        public static void Main(string[] args){\n            new Program();\n        }\n        \n        Program(){\n            while(true){\n                var sr = new StreamReader();\n                W = sr.Next<int>();\n                H = sr.Next<int>();\n                A = sr.Next<string>(H);\n                if(W + H == 0) return;\n\n                _grid = new int[H, W].ToJaggedArray();\n                for(var i = 0; i < H; i++){\n                    for(var j = 0; j < W; j++){\n                        _grid[i][j] = \".BW\".IndexOf(A[i][j]);\n                    }\n                }\n                //Solve();\n            }\n        }\n        /*\n        void Solve(){\n            var dic = new Dictionary<int, int>{{-1, 0}, {1, 0}};\n            for(var i = 0; i < H; i++){\n                for(var j = 0; j < W; j++){\n                    var count = Bfs(j, i);\n                    if(dic.ContainsKey(Math.Sign(count))){\n                        dic[Math.Sign(count)] += Math.Sign(count) * count;\n                    }\n                }\n            }\n            Console.WriteLine(string.Join(\" \", dic.Values.Select(x => x.ToString()).ToArray()));\n        }\n\n        int Bfs(int x, int y){\n            if(_grid[y][x] != 0) return 0;\n\n            var count = 1;\n            _grid[y][x] = int.MinValue;\n            var hs = new HashSet<int>();\n\n            var que = new Queue<int>();\n            que.Enqueue(x);\n            que.Enqueue(y);\n\n            while(que.Count > 0){\n                var cx = que.Dequeue();\n                var cy = que.Dequeue();\n                for(var i = 0; i < _dx.Length; i++){\n                    var nx = cx + _dx[i];\n                    var ny = cy + _dy[i];\n                    if(IsInside(nx, ny) && _grid[ny][nx] != int.MinValue){\n                        if(_grid[ny][nx] == 0){\n                            que.Enqueue(nx);\n                            que.Enqueue(ny);\n                            _grid[ny][nx] = int.MinValue;\n                            count++;\n                        } else{\n                            hs.Add(_grid[ny][nx]);\n                        }\n                    }\n                }\n            }\n            if(hs.Count != 1) return 0;\n            return (2 * hs.Single() - 3) * count;\n        }\n        */\n    }\n\n    public static class ExMethod{\n        public static T[][] ToJaggedArray<T>(this T[,] src){\n            var x = src.GetLength(1);\n            var y = src.GetLength(0);\n            var ret = new T[y][];\n\n            for(var i = 0; i < y; i++){\n                ret[i] = new T[x];\n                for(var j = 0; j < x; j++){\n                    ret[i][j] = src[i, j];\n                }\n            }\n\n            return ret;\n        }\n    }\n\n    public class StreamReader{\n        private readonly char[] _c = {' '};\n        private int _index = -1;\n        private string[] _input = new string[0];\n        private readonly System.IO.StreamReader _sr = new System.IO.StreamReader(Console.OpenStandardInput());\n\n        public T Next<T>(){\n            if(_index == _input.Length - 1){\n                _index = -1;\n                while(true){\n                    string rl = _sr.ReadLine();\n                    if(rl == null){\n                        if(typeof(T).IsClass) return default(T);\n                        return (T)typeof(T).GetField(\"MinValue\").GetValue(null);\n                    }\n                    if(rl != \"\"){\n                        _input = rl.Split(_c, StringSplitOptions.RemoveEmptyEntries);\n                        break;\n                    }\n                }\n            }\n            return (T)Convert.ChangeType(_input[++_index], typeof(T), System.Globalization.CultureInfo.InvariantCulture);\n        }\n\n        public T[] Next<T>(int x){\n            var ret = new T[x];\n            for(var i = 0; i < x; ++i) ret[i] = Next<T>();\n            return ret;\n        }\n\n        public T[][] Next<T>(int y, int x){\n            var ret = new T[y][];\n            for(var i = 0; i < y; ++i) ret[i] = Next<T>(x);\n            return ret;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace V2014{\n    public class Program{\n        readonly int W;\n        readonly int H;\n        readonly string[] A;\n\n        readonly int[][] _grid;\n        readonly int[] _dx = {1, 0, -1, 0};\n        readonly int[] _dy = {0, 1, 0, -1};\n\n        bool IsInside(int x, int y){\n            return 0 <= x && x < W && 0 <= y && y < H;\n        }\n\n        public static void Main(string[] args){\n            new Program();\n        }\n\n        Program(){\n            while(true){\n                var sr = new StreamReader();\n                W = sr.Next<int>();\n                H = sr.Next<int>();\n                A = sr.Next<string>(H);\n                if(W + H == 0) return;\n\n                _grid = new int[H, W].ToJaggedArray();\n                for(var i = 0; i < H; i++){\n                    for(var j = 0; j < W; j++){\n                        _grid[i][j] = \".BW\".IndexOf(A[i][j]);\n                    }\n                }\n                //Solve();\n            }\n        }\n\n        void Solve(){\n            var dic = new Dictionary<int, int>{{-1, 0}, {1, 0}};\n            for(var i = 0; i < H; i++){\n                for(var j = 0; j < W; j++){\n                    var count = Bfs(j, i);\n                    if(dic.ContainsKey(Math.Sign(count))){\n                        dic[Math.Sign(count)] += Math.Sign(count) * count;\n                    }\n                }\n            }\n            Console.WriteLine(string.Join(\" \", dic.Values.Select(x => x.ToString()).ToArray()));\n        }\n\n        int Bfs(int x, int y){\n            if(_grid[y][x] != 0) return 0;\n\n            var count = 1;\n            _grid[y][x] = int.MinValue;\n            var hs = new HashSet<int>();\n\n            var que = new Queue<int>();\n            que.Enqueue(x);\n            que.Enqueue(y);\n\n            while(que.Count > 0){\n                var cx = que.Dequeue();\n                var cy = que.Dequeue();\n                for(var i = 0; i < _dx.Length; i++){\n                    var nx = cx + _dx[i];\n                    var ny = cy + _dy[i];\n                    if(IsInside(nx, ny) && _grid[ny][nx] != int.MinValue){\n                        if(_grid[ny][nx] == 0){\n                            que.Enqueue(nx);\n                            que.Enqueue(ny);\n                            _grid[ny][nx] = int.MinValue;\n                            count++;\n                        } else{\n                            hs.Add(_grid[ny][nx]);\n                        }\n                    }\n                }\n            }\n            if(hs.Count != 1) return 0;\n            return (2 * hs.Single() - 3) * count;\n        }\n    }\n\n    public static class ExMethod{\n        public static T[][] ToJaggedArray<T>(this T[,] src){\n            var x = src.GetLength(1);\n            var y = src.GetLength(0);\n            var ret = new T[y][];\n\n            for(var i = 0; i < y; i++){\n                ret[i] = new T[x];\n                for(var j = 0; j < x; j++){\n                    ret[i][j] = src[i, j];\n                }\n            }\n\n            return ret;\n        }\n    }\n\n    public class StreamReader{\n        private readonly char[] _c = {' '};\n        private int _index = -1;\n        private string[] _input = new string[0];\n        private readonly System.IO.StreamReader _sr = new System.IO.StreamReader(Console.OpenStandardInput());\n\n        public T Next<T>(){\n            if(_index == _input.Length - 1){\n                _index = -1;\n                while(true){\n                    string rl = _sr.ReadLine();\n                    if(rl == null){\n                        if(typeof(T).IsClass) return default(T);\n                        return (T)typeof(T).GetField(\"MinValue\").GetValue(null);\n                    }\n                    if(rl != \"\"){\n                        _input = rl.Split(_c, StringSplitOptions.RemoveEmptyEntries);\n                        break;\n                    }\n                }\n            }\n            return (T)Convert.ChangeType(_input[++_index], typeof(T), System.Globalization.CultureInfo.InvariantCulture);\n        }\n\n        public T[] Next<T>(int x){\n            var ret = new T[x];\n            for(var i = 0; i < x; ++i) ret[i] = Next<T>();\n            return ret;\n        }\n\n        public T[][] Next<T>(int y, int x){\n            var ret = new T[y][];\n            for(var i = 0; i < y; ++i) ret[i] = Next<T>(x);\n            return ret;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.ComponentModel.Design;\n\nclass Program {\n  static int n, m;\n  static char[][] map;\n  private static readonly int[] dy = new[] {1, -1, 0, 0};\n  private static readonly int[] dx = new[] {0, 0, 1, -1};\n  public static int Main() {\n    Scanner cin = new Scanner();\n    while (true)\n    {\n      n = cin.nextInt();\n      m = cin.nextInt();\n      if (n == 0 && m == 0)\n      {\n        break;\n      }\n      map = new char[m][];\n      for (int i = 0; i < m; i++)\n      {\n        map[i] = cin.next().ToCharArray();\n      }\n      int b = 0, w = 0;\n      for (int i = 0; i < m; i++)\n      {\n        for (int j = 0; j < n; j++)\n        {\n          if (map[i][j] == '.')\n          {\n            char color = getColor(j, i);\n            if (color == 'B')\n            {\n              b += dfs(j, i);\n            }\n            if (color == 'W')\n            {\n              w += dfs(j, i);\n            }\n          }\n        }\n      }\n      Console.WriteLine(\"{0} {1}\", b, w);\n    }\n    return 0;\n  }\n\n  private static char getColor(int nowx, int nowy)\n  {\n    if (map[nowy][nowx] != '.')\n    {\n      return map[nowy][nowx];\n    }\n    map[nowy][nowx] = 'C';\n    char res = '.';\n    for (int i = 0; i < 4; i++)\n    {\n      if (nowy + dy[i] < 0 || nowy + dy[i] == m || nowx + dx[i] < 0 || nowx + dx[i] == n || map[nowy + dy[i]][nowx + dx[i]] == 'C')\n      {\n        continue;\n      }\n      char c = getColor(nowx + dx[i], nowy + dy[i]);\n      if ((res != '.' && res != c && c != '.') || c == 'e')\n      {\n        res = 'e';\n      }\n      else\n      {\n        res = c;\n      }\n    }\n    return res;\n  }\n\n  private static int dfs(int nowx, int nowy)\n  {\n    if (map[nowy][nowx] != 'C')\n    {\n      return 0;\n    }\n    map[nowy][nowx] = 'S';\n    int res = 1;\n    for (int i = 0; i < 4; i++)\n    {\n      if (nowy + dy[i] < 0 || nowy + dy[i] == m || nowx + dx[i] < 0 || nowx + dx[i] == n) {\n        continue;\n      }\n      res += dfs(nowx + dx[i], nowy + dy[i]);\n    }\n    return res;\n  }\n\n}\n\nclass Scanner {\n  string[] s;\n  int i;\n\n  char[] cs = new char[] { ' ' };\n\n  public Scanner() {\n    s = new string[0];\n    i = 0;\n  }\n\n  public string next() {\n    if (i < s.Length) return s[i++];\n    do {\n      s = Console.ReadLine().Split(cs, StringSplitOptions.RemoveEmptyEntries);\n    } while ((s.Length == 1 && s[0] == \"\") || s.Length == 0);\n    i = 0;\n    return s[i++];\n  }\n\n  public int nextInt() {\n    return int.Parse(next());\n  }\n\n  public long nextLong() {\n    return long.Parse(next());\n  }\n\n  public double nextDouble() {\n    return double.Parse(next());\n  }\n\n}"
  },
  {
    "language": "C#",
    "code": "using System;\n\npublic class Hello\n{\n    public static void Main()\n    {\n        var dx = new int[] { 0, 1, 0, -1 };\n        var dy = new int[] { 1, 0, -1, 0 };\n        while (true)\n        {\n            string[] line = Console.ReadLine().Trim().Split(' ');\n            var w = int.Parse(line[0]);\n            var h = int.Parse(line[1]);\n            if (w == 0 && h == 0) break;\n            var map1 = new int[h, w]; var map2 = new int[h, w];\n            for (int i = 0; i < h; i++)\n            {\n                var s = Console.ReadLine().Trim();\n                for (int j = 0; j < w; j++)\n                    if (s[j] == 'B') { map1[i, j] = 1; map2[i, j] = 1; }\n                    else if (s[j] == 'W') { map1[i, j] = 2; map2[i, j] = 2; }\n            }\n            var found = false;\n            for (int i = 0; i < h; i++)\n                for (int j = 0; j < w; j++)\n                {\n                    if (map1[i, j] == 1) { goDfs(map1, dx, dy, i, j); found = true; }\n                    if (map2[i, j] == 2) { goDfs(map2, dx, dy, i, j); found = true; }\n                }\n            if (!found) { Console.WriteLine(\"0 0\");  goto end; }\n            var wcount = 0; var bcount = 0;\n            for (int i = 0; i < h; i++)\n                for (int j = 0; j < w; j++)\n                {\n                    if (map1[i, j] == 0) wcount++;\n                    if (map2[i, j] == 0) bcount++;\n                }\n            Console.WriteLine(\"{0} {1}\", bcount, wcount);\n            end:;\n        }\n    }\n    public static void goDfs(int[,] map, int[] dx, int[] dy, int x, int y)\n    {\n        var h = map.GetLength(0); var w = map.GetLength(1);\n        if (map[x, y] == 0) map[x, y] = 10;\n        for (int i = 0; i < 4; i++)\n        {\n            var nx = x + dx[i];\n            var ny = y + dy[i];\n            if (nx >= 0 && nx < h && ny >= 0 && ny < w && map[nx, ny] == 0)\n                goDfs(map, dx, dy, nx, ny);\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace V2014{\n    public class Program{\n        int W;\n        int H;\n        //string[] A;\n        \n        //int[][] _grid;\n        //int[] _dx = {1, 0, -1, 0};\n        //int[] _dy = {0, 1, 0, -1};\n        /*\n        bool IsInside(int x, int y){\n            return 0 <= x && x < W && 0 <= y && y < H;\n        }*/\n        \n        public static void Main(string[] args){\n            new Program();\n        }\n        \n        Program(){\n            while(true){\n                var sr = new StreamReader();\n                W = sr.Next<int>();\n                H = sr.Next<int>();\n                //A = sr.Next<string>(H);\n                if(W + H == 0) return;\n\n                //_grid = new int[H, W].ToJaggedArray();\n                for(var i = 0; i < H; i++){\n                    for(var j = 0; j < W; j++){\n                        //_grid[i][j] = \".BW\".IndexOf(A[i][j]);\n                    }\n                }\n                //Solve();\n            }\n        }\n        /*\n        void Solve(){\n            var dic = new Dictionary<int, int>{{-1, 0}, {1, 0}};\n            for(var i = 0; i < H; i++){\n                for(var j = 0; j < W; j++){\n                    var count = Bfs(j, i);\n                    if(dic.ContainsKey(Math.Sign(count))){\n                        dic[Math.Sign(count)] += Math.Sign(count) * count;\n                    }\n                }\n            }\n            Console.WriteLine(string.Join(\" \", dic.Values.Select(x => x.ToString()).ToArray()));\n        }\n\n        int Bfs(int x, int y){\n            if(_grid[y][x] != 0) return 0;\n\n            var count = 1;\n            _grid[y][x] = int.MinValue;\n            var hs = new HashSet<int>();\n\n            var que = new Queue<int>();\n            que.Enqueue(x);\n            que.Enqueue(y);\n\n            while(que.Count > 0){\n                var cx = que.Dequeue();\n                var cy = que.Dequeue();\n                for(var i = 0; i < _dx.Length; i++){\n                    var nx = cx + _dx[i];\n                    var ny = cy + _dy[i];\n                    if(IsInside(nx, ny) && _grid[ny][nx] != int.MinValue){\n                        if(_grid[ny][nx] == 0){\n                            que.Enqueue(nx);\n                            que.Enqueue(ny);\n                            _grid[ny][nx] = int.MinValue;\n                            count++;\n                        } else{\n                            hs.Add(_grid[ny][nx]);\n                        }\n                    }\n                }\n            }\n            if(hs.Count != 1) return 0;\n            return (2 * hs.Single() - 3) * count;\n        }\n        */\n    }\n\n    public static class ExMethod{\n        public static T[][] ToJaggedArray<T>(this T[,] src){\n            var x = src.GetLength(1);\n            var y = src.GetLength(0);\n            var ret = new T[y][];\n\n            for(var i = 0; i < y; i++){\n                ret[i] = new T[x];\n                for(var j = 0; j < x; j++){\n                    ret[i][j] = src[i, j];\n                }\n            }\n\n            return ret;\n        }\n    }\n\n    public class StreamReader{\n        private readonly char[] _c = {' '};\n        private int _index = -1;\n        private string[] _input = new string[0];\n        private readonly System.IO.StreamReader _sr = new System.IO.StreamReader(Console.OpenStandardInput());\n\n        public T Next<T>(){\n            if(_index == _input.Length - 1){\n                _index = -1;\n                while(true){\n                    string rl = _sr.ReadLine();\n                    if(rl == null){\n                        if(typeof(T).IsClass) return default(T);\n                        return (T)typeof(T).GetField(\"MinValue\").GetValue(null);\n                    }\n                    if(rl != \"\"){\n                        _input = rl.Split(_c, StringSplitOptions.RemoveEmptyEntries);\n                        break;\n                    }\n                }\n            }\n            return (T)Convert.ChangeType(_input[++_index], typeof(T), System.Globalization.CultureInfo.InvariantCulture);\n        }\n\n        public T[] Next<T>(int x){\n            var ret = new T[x];\n            for(var i = 0; i < x; ++i) ret[i] = Next<T>();\n            return ret;\n        }\n\n        public T[][] Next<T>(int y, int x){\n            var ret = new T[y][];\n            for(var i = 0; i < y; ++i) ret[i] = Next<T>(x);\n            return ret;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace V2014{\n    public class Program{\n        //int W;\n        //int H;\n        //string[] A;\n        \n        //int[][] _grid;\n        //int[] _dx = {1, 0, -1, 0};\n        //int[] _dy = {0, 1, 0, -1};\n        /*\n        bool IsInside(int x, int y){\n            return 0 <= x && x < W && 0 <= y && y < H;\n        }*/\n        \n        public static void Main(string[] args){\n            new Program();\n        }\n        \n        Program(){\n            while(true){\n                var sr = new StreamReader();\n                //W = sr.Next<int>();\n                //H = sr.Next<int>();\n                //A = sr.Next<string>(H);\n                //if(W + H == 0) return;\n\n                //_grid = new int[H, W].ToJaggedArray();\n                //for(var i = 0; i < H; i++){\n                    //for(var j = 0; j < W; j++){\n                        //_grid[i][j] = \".BW\".IndexOf(A[i][j]);\n                    //}\n                //}\n                //Solve();\n                break;\n            }\n        }\n        /*\n        void Solve(){\n            var dic = new Dictionary<int, int>{{-1, 0}, {1, 0}};\n            for(var i = 0; i < H; i++){\n                for(var j = 0; j < W; j++){\n                    var count = Bfs(j, i);\n                    if(dic.ContainsKey(Math.Sign(count))){\n                        dic[Math.Sign(count)] += Math.Sign(count) * count;\n                    }\n                }\n            }\n            Console.WriteLine(string.Join(\" \", dic.Values.Select(x => x.ToString()).ToArray()));\n        }\n\n        int Bfs(int x, int y){\n            if(_grid[y][x] != 0) return 0;\n\n            var count = 1;\n            _grid[y][x] = int.MinValue;\n            var hs = new HashSet<int>();\n\n            var que = new Queue<int>();\n            que.Enqueue(x);\n            que.Enqueue(y);\n\n            while(que.Count > 0){\n                var cx = que.Dequeue();\n                var cy = que.Dequeue();\n                for(var i = 0; i < _dx.Length; i++){\n                    var nx = cx + _dx[i];\n                    var ny = cy + _dy[i];\n                    if(IsInside(nx, ny) && _grid[ny][nx] != int.MinValue){\n                        if(_grid[ny][nx] == 0){\n                            que.Enqueue(nx);\n                            que.Enqueue(ny);\n                            _grid[ny][nx] = int.MinValue;\n                            count++;\n                        } else{\n                            hs.Add(_grid[ny][nx]);\n                        }\n                    }\n                }\n            }\n            if(hs.Count != 1) return 0;\n            return (2 * hs.Single() - 3) * count;\n        }\n        */\n    }\n\n    public static class ExMethod{\n        public static T[][] ToJaggedArray<T>(this T[,] src){\n            var x = src.GetLength(1);\n            var y = src.GetLength(0);\n            var ret = new T[y][];\n\n            for(var i = 0; i < y; i++){\n                ret[i] = new T[x];\n                for(var j = 0; j < x; j++){\n                    ret[i][j] = src[i, j];\n                }\n            }\n\n            return ret;\n        }\n    }\n\n    public class StreamReader{\n        private readonly char[] _c = {' '};\n        private int _index = -1;\n        private string[] _input = new string[0];\n        private readonly System.IO.StreamReader _sr = new System.IO.StreamReader(Console.OpenStandardInput());\n\n        public T Next<T>(){\n            if(_index == _input.Length - 1){\n                _index = -1;\n                while(true){\n                    string rl = _sr.ReadLine();\n                    if(rl == null){\n                        if(typeof(T).IsClass) return default(T);\n                        return (T)typeof(T).GetField(\"MinValue\").GetValue(null);\n                    }\n                    if(rl != \"\"){\n                        _input = rl.Split(_c, StringSplitOptions.RemoveEmptyEntries);\n                        break;\n                    }\n                }\n            }\n            return (T)Convert.ChangeType(_input[++_index], typeof(T), System.Globalization.CultureInfo.InvariantCulture);\n        }\n\n        public T[] Next<T>(int x){\n            var ret = new T[x];\n            for(var i = 0; i < x; ++i) ret[i] = Next<T>();\n            return ret;\n        }\n\n        public T[][] Next<T>(int y, int x){\n            var ret = new T[y][];\n            for(var i = 0; i < y; ++i) ret[i] = Next<T>(x);\n            return ret;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace V2014{\n    public class Program{\n        int W;\n        int H;\n        string[] A;\n        \n        int[][] _grid;\n        readonly int[] _dx = {1, 0, -1, 0};\n        readonly int[] _dy = {0, 1, 0, -1};\n\n        bool IsInside(int x, int y){\n            return 0 <= x && x < W && 0 <= y && y < H;\n        }\n        \n        public static void Main(string[] args){\n            new Program();\n        }\n        \n        Program(){\n            while(true){\n                var sr = new StreamReader();\n                W = sr.Next<int>();\n                H = sr.Next<int>();\n                A = sr.Next<string>(H);\n                if(W + H == 0) return;\n\n                _grid = new int[H, W].ToJaggedArray();\n                for(var i = 0; i < H; i++){\n                    for(var j = 0; j < W; j++){\n                        _grid[i][j] = \".BW\".IndexOf(A[i][j]);\n                    }\n                }\n                Solve();\n            }\n        }\n        \n        void Solve(){\n            var dic = new Dictionary<int, int>{{-1, 0}, {1, 0}};\n            for(var i = 0; i < H; i++){\n                for(var j = 0; j < W; j++){\n                    var count = Bfs(j, i);\n                    if(dic.ContainsKey(Math.Sign(count))){\n                        dic[Math.Sign(count)] += Math.Sign(count) * count;\n                    }\n                }\n            }\n            Console.WriteLine(string.Join(\" \", dic.Values.Select(x => x.ToString()).ToArray()));\n        }\n\n        int Bfs(int x, int y){\n            if(_grid[y][x] != 0) return 0;\n\n            var count = 1;\n            _grid[y][x] = int.MinValue;\n            var hs = new HashSet<int>();\n\n            var que = new Queue<int>();\n            que.Enqueue(x);\n            que.Enqueue(y);\n\n            while(que.Count > 0){\n                var cx = que.Dequeue();\n                var cy = que.Dequeue();\n                for(var i = 0; i < _dx.Length; i++){\n                    var nx = cx + _dx[i];\n                    var ny = cy + _dy[i];\n                    if(IsInside(nx, ny) && _grid[ny][nx] != int.MinValue){\n                        if(_grid[ny][nx] == 0){\n                            que.Enqueue(nx);\n                            que.Enqueue(ny);\n                            _grid[ny][nx] = int.MinValue;\n                            count++;\n                        } else{\n                            hs.Add(_grid[ny][nx]);\n                        }\n                    }\n                }\n            }\n            if(hs.Count != 1) return 0;\n            return (2 * hs.Single() - 3) * count;\n        }\n    }\n\n    public static class ExMethod{\n        public static T[][] ToJaggedArray<T>(this T[,] src){\n            var x = src.GetLength(1);\n            var y = src.GetLength(0);\n            var ret = new T[y][];\n\n            for(var i = 0; i < y; i++){\n                ret[i] = new T[x];\n                for(var j = 0; j < x; j++){\n                    ret[i][j] = src[i, j];\n                }\n            }\n\n            return ret;\n        }\n    }\n\n    public class StreamReader{\n        private readonly char[] _c = {' '};\n        private int _index = -1;\n        private string[] _input = new string[0];\n        private readonly System.IO.StreamReader _sr = new System.IO.StreamReader(Console.OpenStandardInput());\n\n        public T Next<T>(){\n            if(_index == _input.Length - 1){\n                _index = -1;\n                while(true){\n                    string rl = _sr.ReadLine();\n                    if(rl == null){\n                        if(typeof(T).IsClass) return default(T);\n                        return (T)typeof(T).GetField(\"MinValue\").GetValue(null);\n                    }\n                    if(rl != \"\"){\n                        _input = rl.Split(_c, StringSplitOptions.RemoveEmptyEntries);\n                        break;\n                    }\n                }\n            }\n            return (T)Convert.ChangeType(_input[++_index], typeof(T), System.Globalization.CultureInfo.InvariantCulture);\n        }\n\n        public T[] Next<T>(int x){\n            var ret = new T[x];\n            for(var i = 0; i < x; ++i) ret[i] = Next<T>();\n            return ret;\n        }\n\n        public T[][] Next<T>(int y, int x){\n            var ret = new T[y][];\n            for(var i = 0; i < y; ++i) ret[i] = Next<T>(x);\n            return ret;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\n\npublic class Hello\n{\n    public static void Main()\n    {\n        var dx = new int[] { 0, 1, 0, -1 };\n        var dy = new int[] { 1, 0, -1, 0 };\n        while (true)\n        {\n            string[] line = Console.ReadLine().Trim().Split(' ');\n            var w = int.Parse(line[0]);\n            var h = int.Parse(line[1]);\n            if (w == 0 && h == 0) break;\n            var map1 = new int[h, w]; var map2 = new int[h, w];\n            for (int i = 0; i < h; i++)\n            {\n                var s = Console.ReadLine().Trim();\n                for (int j = 0; j < w; j++)\n                    if (s[j] == 'B') { map1[i, j] = 1; map2[i, j] = 1; }\n                    else if (s[j] == 'W') { map1[i, j] = 2; map2[i, j] = 2; }\n            }\n            for (int i = 0; i < h; i++)\n                for (int j = 0; j < w; j++)\n                {\n                    if (map1[i, j] == 1) goDfs(map1, dx, dy, i, j);\n                    if (map2[i, j] == 2) goDfs(map2, dx, dy, i, j);\n                }\n            var wcount = 0; var bcount = 0;\n            for (int i = 0; i < h; i++)\n                for (int j = 0; j < w; j++)\n                {\n                    if (map1[i, j] == 0) wcount++;\n                    if (map2[i, j] == 0) bcount++;\n                }\n            Console.WriteLine(\"{0} {1}\", bcount, wcount);\n        }\n    }\n    public static void goDfs(int[,] map, int[] dx, int[] dy, int x, int y)\n    {\n        var h = map.GetLength(0); var w = map.GetLength(1);\n        if (map[x, y] == 0) map[x, y] = 10;\n        for (int i = 0; i < 4; i++)\n        {\n            var nx = x + dx[i];\n            var ny = y + dy[i];\n            if (nx >= 0 && nx < h && ny >= 0 && ny < w && map[nx, ny] == 0)\n                goDfs(map, dx, dy, nx, ny);\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace V2014{\n    public class Program{\n        readonly int W;\n        readonly int H;\n        readonly string[] A;\n\n        readonly int[][] _grid;\n        readonly int[] _dx = {1, 0, -1, 0};\n        readonly int[] _dy = {0, 1, 0, -1};\n\n        bool IsInside(int x, int y){\n            return 0 <= x && x < W && 0 <= y && y < H;\n        }\n\n        public static void Main(string[] args){\n            var prg = new Program();\n        }\n\n        Program(){\n            while(true){\n                var sr = new StreamReader();\n                W = sr.Next<int>();\n                H = sr.Next<int>();\n                A = sr.Next<string>(H);\n                if(W + H == 0) return;\n\n                _grid = new int[H, W].ToJaggedArray();\n                for(var i = 0; i < H; i++){\n                    for(var j = 0; j < W; j++){\n                        _grid[i][j] = \".BW\".IndexOf(A[i][j]);\n                    }\n                }\n                Solve();\n            }\n        }\n\n        void Solve(){\n            var dic = new Dictionary<int, int>{{-1, 0}, {1, 0}};\n            for(var i = 0; i < H; i++){\n                for(var j = 0; j < W; j++){\n                    var count = Bfs(j, i);\n                    if(dic.ContainsKey(Math.Sign(count))){\n                        dic[Math.Sign(count)] += Math.Sign(count) * count;\n                    }\n                }\n            }\n            Console.WriteLine(string.Join(\" \", dic.Values.Select(x => x.ToString()).ToArray()));\n        }\n\n        int Bfs(int x, int y){\n            if(_grid[y][x] != 0) return 0;\n\n            var count = 1;\n            _grid[y][x] = int.MinValue;\n            var hs = new HashSet<int>();\n\n            var que = new Queue<int>();\n            que.Enqueue(x);\n            que.Enqueue(y);\n\n            while(que.Count > 0){\n                var cx = que.Dequeue();\n                var cy = que.Dequeue();\n                for(var i = 0; i < _dx.Length; i++){\n                    var nx = cx + _dx[i];\n                    var ny = cy + _dy[i];\n                    if(IsInside(nx, ny) && _grid[ny][nx] != int.MinValue){\n                        if(_grid[ny][nx] == 0){\n                            que.Enqueue(nx);\n                            que.Enqueue(ny);\n                            _grid[ny][nx] = int.MinValue;\n                            count++;\n                        } else{\n                            hs.Add(_grid[ny][nx]);\n                        }\n                    }\n                }\n            }\n            if(hs.Count != 1) return 0;\n            return (2 * hs.Single() - 3) * count;\n        }\n    }\n\n    public static class ExMethod{\n        public static T[][] ToJaggedArray<T>(this T[,] src){\n            var x = src.GetLength(1);\n            var y = src.GetLength(0);\n            var ret = new T[y][];\n\n            for(var i = 0; i < y; i++){\n                ret[i] = new T[x];\n                for(var j = 0; j < x; j++){\n                    ret[i][j] = src[i, j];\n                }\n            }\n\n            return ret;\n        }\n    }\n\n    public class StreamReader{\n        private readonly char[] _c = {' '};\n        private int _index = -1;\n        private string[] _input = new string[0];\n        private readonly System.IO.StreamReader _sr = new System.IO.StreamReader(Console.OpenStandardInput());\n\n        public T Next<T>(){\n            if(_index == _input.Length - 1){\n                _index = -1;\n                while(true){\n                    string rl = _sr.ReadLine();\n                    if(rl == null){\n                        if(typeof(T).IsClass) return default(T);\n                        return (T)typeof(T).GetField(\"MinValue\").GetValue(null);\n                    }\n                    if(rl != \"\"){\n                        _input = rl.Split(_c, StringSplitOptions.RemoveEmptyEntries);\n                        break;\n                    }\n                }\n            }\n            return (T)Convert.ChangeType(_input[++_index], typeof(T), System.Globalization.CultureInfo.InvariantCulture);\n        }\n\n        public T[] Next<T>(int x){\n            var ret = new T[x];\n            for(var i = 0; i < x; ++i) ret[i] = Next<T>();\n            return ret;\n        }\n\n        public T[][] Next<T>(int y, int x){\n            var ret = new T[y][];\n            for(var i = 0; i < y; ++i) ret[i] = Next<T>(x);\n            return ret;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace V2014{\n    public class Program{\n        //int W;\n        //int H;\n        //string[] A;\n        \n        //int[][] _grid;\n        //int[] _dx = {1, 0, -1, 0};\n        //int[] _dy = {0, 1, 0, -1};\n        /*\n        bool IsInside(int x, int y){\n            return 0 <= x && x < W && 0 <= y && y < H;\n        }*/\n        \n        public static void Main(string[] args){\n            new Program();\n        }\n        \n        Program(){\n            while(true){\n                //var sr = new StreamReader();\n                //W = sr.Next<int>();\n                //H = sr.Next<int>();\n                //A = sr.Next<string>(H);\n                //if(W + H == 0) return;\n\n                //_grid = new int[H, W].ToJaggedArray();\n                //for(var i = 0; i < H; i++){\n                    //for(var j = 0; j < W; j++){\n                        //_grid[i][j] = \".BW\".IndexOf(A[i][j]);\n                    //}\n                //}\n                //Solve();\n                break;\n            }\n        }\n        /*\n        void Solve(){\n            var dic = new Dictionary<int, int>{{-1, 0}, {1, 0}};\n            for(var i = 0; i < H; i++){\n                for(var j = 0; j < W; j++){\n                    var count = Bfs(j, i);\n                    if(dic.ContainsKey(Math.Sign(count))){\n                        dic[Math.Sign(count)] += Math.Sign(count) * count;\n                    }\n                }\n            }\n            Console.WriteLine(string.Join(\" \", dic.Values.Select(x => x.ToString()).ToArray()));\n        }\n\n        int Bfs(int x, int y){\n            if(_grid[y][x] != 0) return 0;\n\n            var count = 1;\n            _grid[y][x] = int.MinValue;\n            var hs = new HashSet<int>();\n\n            var que = new Queue<int>();\n            que.Enqueue(x);\n            que.Enqueue(y);\n\n            while(que.Count > 0){\n                var cx = que.Dequeue();\n                var cy = que.Dequeue();\n                for(var i = 0; i < _dx.Length; i++){\n                    var nx = cx + _dx[i];\n                    var ny = cy + _dy[i];\n                    if(IsInside(nx, ny) && _grid[ny][nx] != int.MinValue){\n                        if(_grid[ny][nx] == 0){\n                            que.Enqueue(nx);\n                            que.Enqueue(ny);\n                            _grid[ny][nx] = int.MinValue;\n                            count++;\n                        } else{\n                            hs.Add(_grid[ny][nx]);\n                        }\n                    }\n                }\n            }\n            if(hs.Count != 1) return 0;\n            return (2 * hs.Single() - 3) * count;\n        }\n        */\n    }\n\n    public static class ExMethod{\n        public static T[][] ToJaggedArray<T>(this T[,] src){\n            var x = src.GetLength(1);\n            var y = src.GetLength(0);\n            var ret = new T[y][];\n\n            for(var i = 0; i < y; i++){\n                ret[i] = new T[x];\n                for(var j = 0; j < x; j++){\n                    ret[i][j] = src[i, j];\n                }\n            }\n\n            return ret;\n        }\n    }\n\n    public class StreamReader{\n        private readonly char[] _c = {' '};\n        private int _index = -1;\n        private string[] _input = new string[0];\n        private readonly System.IO.StreamReader _sr = new System.IO.StreamReader(Console.OpenStandardInput());\n\n        public T Next<T>(){\n            if(_index == _input.Length - 1){\n                _index = -1;\n                while(true){\n                    string rl = _sr.ReadLine();\n                    if(rl == null){\n                        if(typeof(T).IsClass) return default(T);\n                        return (T)typeof(T).GetField(\"MinValue\").GetValue(null);\n                    }\n                    if(rl != \"\"){\n                        _input = rl.Split(_c, StringSplitOptions.RemoveEmptyEntries);\n                        break;\n                    }\n                }\n            }\n            return (T)Convert.ChangeType(_input[++_index], typeof(T), System.Globalization.CultureInfo.InvariantCulture);\n        }\n\n        public T[] Next<T>(int x){\n            var ret = new T[x];\n            for(var i = 0; i < x; ++i) ret[i] = Next<T>();\n            return ret;\n        }\n\n        public T[][] Next<T>(int y, int x){\n            var ret = new T[y][];\n            for(var i = 0; i < y; ++i) ret[i] = Next<T>(x);\n            return ret;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.ComponentModel.Design;\n\nclass Program {\n  static int n, m;\n  static char[][] map;\n  private static readonly int[] dy = new[] {1, -1, 0, 0};\n  private static readonly int[] dx = new[] {0, 0, 1, -1};\n  public static int Main() {\n    Scanner cin = new Scanner();\n    while (true)\n    {\n      n = cin.nextInt();\n      m = cin.nextInt();\n      if (n == 0 && m == 0)\n      {\n        break;\n      }\n      map = new char[m][];\n      for (int i = 0; i < m; i++)\n      {\n        map[i] = cin.next().ToCharArray();\n      }\n      int b = 0, w = 0;\n      for (int i = 0; i < m; i++)\n      {\n        for (int j = 0; j < n; j++)\n        {\n          if (map[i][j] == '.')\n          {\n            char color = getColor(j, i);\n            if (color == 'B')\n            {\n              b += dfs(j, i, color);\n            }\n            if (color == 'W')\n            {\n              w += dfs(j, i, color);\n            }\n          }\n        }\n      }\n      Console.WriteLine(\"{0} {1}\", b, w);\n    }\n    return 0;\n  }\n\n  private static char getColor(int nowx, int nowy)\n  {\n    if (map[nowy][nowx] != '.')\n    {\n      return map[nowy][nowx];\n    }\n    map[nowy][nowx] = 'C';\n    char res = '.';\n    for (int i = 0; i < 4; i++)\n    {\n      if (nowy + dy[i] < 0 || nowy + dy[i] == m || nowx + dx[i] < 0 || nowx + dx[i] == n || map[nowy + dy[i]][nowx + dx[i]] == 'C')\n      {\n        continue;\n      }\n      char c = getColor(nowx + dx[i], nowy + dy[i]);\n      if ((res != '.' && res != c && c != '.') || c == 'e')\n      {\n        res = 'e';\n      }\n      else if(c != '.')\n      {\n        res = c;\n      }\n    }\n    return res;\n  }\n\n  private static int dfs(int nowx, int nowy, char color)\n  {\n    if (map[nowy][nowx] != 'C')\n    {\n      return 0;\n    }\n    map[nowy][nowx] = color;\n    int res = 1;\n    for (int i = 0; i < 4; i++)\n    {\n      if (nowy + dy[i] < 0 || nowy + dy[i] == m || nowx + dx[i] < 0 || nowx + dx[i] == n) {\n        continue;\n      }\n      res += dfs(nowx + dx[i], nowy + dy[i], color);\n    }\n    return res;\n  }\n\n}\n\nclass Scanner {\n  string[] s;\n  int i;\n\n  char[] cs = new char[] { ' ' };\n\n  public Scanner() {\n    s = new string[0];\n    i = 0;\n  }\n\n  public string next() {\n    if (i < s.Length) return s[i++];\n    do {\n      s = Console.ReadLine().Split(cs, StringSplitOptions.RemoveEmptyEntries);\n    } while ((s.Length == 1 && s[0] == \"\") || s.Length == 0);\n    i = 0;\n    return s[i++];\n  }\n\n  public int nextInt() {\n    return int.Parse(next());\n  }\n\n  public long nextLong() {\n    return long.Parse(next());\n  }\n\n  public double nextDouble() {\n    return double.Parse(next());\n  }\n\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace V2014{\n    public class Program{\n        readonly int W;\n        readonly int H;\n        readonly string[] A;\n\n        readonly int[][] _grid;\n        readonly int[] _dx = {1, 0, -1, 0};\n        readonly int[] _dy = {0, 1, 0, -1};\n\n        bool IsInside(int x, int y){\n            return 0 <= x && x < W && 0 <= y && y < H;\n        }\n\n        public static void Main(string[] args){\n            new Program();\n        }\n\n        Program(){\n            while(true){\n                var sr = new StreamReader();\n                W = sr.Next<int>();\n                H = sr.Next<int>();\n                A = sr.Next<string>(H);\n                if(W + H == 0) return;\n\n                _grid = new int[H, W].ToJaggedArray();\n                for(var i = 0; i < H; i++){\n                    for(var j = 0; j < W; j++){\n                        _grid[i][j] = \".BW\".IndexOf(A[i][j]);\n                    }\n                }\n                Solve();\n            }\n        }\n\n        void Solve(){\n            var dic = new Dictionary<int, int>{{-1, 0}, {1, 0}};\n            for(var i = 0; i < H; i++){\n                for(var j = 0; j < W; j++){\n                    var count = Bfs(j, i);\n                    if(dic.ContainsKey(Math.Sign(count))){\n                        dic[Math.Sign(count)] += Math.Sign(count) * count;\n                    }\n                }\n            }\n            Console.WriteLine(string.Join(\" \", dic.Values.Select(x => x.ToString()).ToArray()));\n        }\n\n        int Bfs(int x, int y){\n            if(_grid[y][x] != 0) return 0;\n\n            var count = 1;\n            _grid[y][x] = int.MinValue;\n            var hs = new HashSet<int>();\n\n            var que = new Queue<int>();\n            que.Enqueue(x);\n            que.Enqueue(y);\n\n            while(que.Count > 0){\n                var cx = que.Dequeue();\n                var cy = que.Dequeue();\n                for(var i = 0; i < _dx.Length; i++){\n                    var nx = cx + _dx[i];\n                    var ny = cy + _dy[i];\n                    if(IsInside(nx, ny) && _grid[ny][nx] != int.MinValue){\n                        if(_grid[ny][nx] == 0){\n                            que.Enqueue(nx);\n                            que.Enqueue(ny);\n                            _grid[ny][nx] = int.MinValue;\n                            count++;\n                        } else{\n                            hs.Add(_grid[ny][nx]);\n                        }\n                    }\n                }\n            }\n            if(hs.Count != 1) return 0;\n            return (2 * hs.Single() - 3) * count;\n        }\n    }\n\n    public static class ExMethod{\n        public static T[][] ToJaggedArray<T>(this T[,] src){\n            var x = src.GetLength(1);\n            var y = src.GetLength(0);\n            var ret = new T[y][];\n\n            for(var i = 0; i < y; i++){\n                ret[i] = new T[x];\n                for(var j = 0; j < x; j++){\n                    ret[i][j] = src[i, j];\n                }\n            }\n\n            return ret;\n        }\n    }\n\n    public class StreamReader{\n        private readonly char[] _c = {' '};\n        private int _index = -1;\n        private string[] _input = new string[0];\n        private readonly System.IO.StreamReader _sr = new System.IO.StreamReader(Console.OpenStandardInput());\n\n        public T Next<T>(){\n            if(_index == _input.Length - 1){\n                _index = -1;\n                while(true){\n                    string rl = _sr.ReadLine();\n                    if(rl == null){\n                        if(typeof(T).IsClass) return default(T);\n                        return (T)typeof(T).GetField(\"MinValue\").GetValue(null);\n                    }\n                    if(rl != \"\"){\n                        _input = rl.Split(_c, StringSplitOptions.RemoveEmptyEntries);\n                        break;\n                    }\n                }\n            }\n            return (T)Convert.ChangeType(_input[++_index], typeof(T), System.Globalization.CultureInfo.InvariantCulture);\n        }\n\n        public T[] Next<T>(int x){\n            var ret = new T[x];\n            for(var i = 0; i < x; ++i) ret[i] = Next<T>();\n            return ret;\n        }\n\n        public T[][] Next<T>(int y, int x){\n            var ret = new T[y][];\n            for(var i = 0; i < y; ++i) ret[i] = Next<T>(x);\n            return ret;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace V2014{\n    public class Program{\n        /*\n        readonly int W;\n        readonly int H;\n        readonly string[] A;\n\n        readonly int[][] _grid;\n        readonly int[] _dx = {1, 0, -1, 0};\n        readonly int[] _dy = {0, 1, 0, -1};\n\n        bool IsInside(int x, int y){\n            return 0 <= x && x < W && 0 <= y && y < H;\n        }\n        */\n        public static void Main(string[] args){\n            new Program();\n        }\n        /*\n        Program(){\n            while(true){\n                var sr = new StreamReader();\n                W = sr.Next<int>();\n                H = sr.Next<int>();\n                A = sr.Next<string>(H);\n                if(W + H == 0) return;\n\n                _grid = new int[H, W].ToJaggedArray();\n                for(var i = 0; i < H; i++){\n                    for(var j = 0; j < W; j++){\n                        _grid[i][j] = \".BW\".IndexOf(A[i][j]);\n                    }\n                }\n                Solve();\n            }\n        }\n\n        void Solve(){\n            var dic = new Dictionary<int, int>{{-1, 0}, {1, 0}};\n            for(var i = 0; i < H; i++){\n                for(var j = 0; j < W; j++){\n                    var count = Bfs(j, i);\n                    if(dic.ContainsKey(Math.Sign(count))){\n                        dic[Math.Sign(count)] += Math.Sign(count) * count;\n                    }\n                }\n            }\n            Console.WriteLine(string.Join(\" \", dic.Values.Select(x => x.ToString()).ToArray()));\n        }\n\n        int Bfs(int x, int y){\n            if(_grid[y][x] != 0) return 0;\n\n            var count = 1;\n            _grid[y][x] = int.MinValue;\n            var hs = new HashSet<int>();\n\n            var que = new Queue<int>();\n            que.Enqueue(x);\n            que.Enqueue(y);\n\n            while(que.Count > 0){\n                var cx = que.Dequeue();\n                var cy = que.Dequeue();\n                for(var i = 0; i < _dx.Length; i++){\n                    var nx = cx + _dx[i];\n                    var ny = cy + _dy[i];\n                    if(IsInside(nx, ny) && _grid[ny][nx] != int.MinValue){\n                        if(_grid[ny][nx] == 0){\n                            que.Enqueue(nx);\n                            que.Enqueue(ny);\n                            _grid[ny][nx] = int.MinValue;\n                            count++;\n                        } else{\n                            hs.Add(_grid[ny][nx]);\n                        }\n                    }\n                }\n            }\n            if(hs.Count != 1) return 0;\n            return (2 * hs.Single() - 3) * count;\n        }\n        */\n    }\n\n    public static class ExMethod{\n        public static T[][] ToJaggedArray<T>(this T[,] src){\n            var x = src.GetLength(1);\n            var y = src.GetLength(0);\n            var ret = new T[y][];\n\n            for(var i = 0; i < y; i++){\n                ret[i] = new T[x];\n                for(var j = 0; j < x; j++){\n                    ret[i][j] = src[i, j];\n                }\n            }\n\n            return ret;\n        }\n    }\n\n    public class StreamReader{\n        private readonly char[] _c = {' '};\n        private int _index = -1;\n        private string[] _input = new string[0];\n        private readonly System.IO.StreamReader _sr = new System.IO.StreamReader(Console.OpenStandardInput());\n\n        public T Next<T>(){\n            if(_index == _input.Length - 1){\n                _index = -1;\n                while(true){\n                    string rl = _sr.ReadLine();\n                    if(rl == null){\n                        if(typeof(T).IsClass) return default(T);\n                        return (T)typeof(T).GetField(\"MinValue\").GetValue(null);\n                    }\n                    if(rl != \"\"){\n                        _input = rl.Split(_c, StringSplitOptions.RemoveEmptyEntries);\n                        break;\n                    }\n                }\n            }\n            return (T)Convert.ChangeType(_input[++_index], typeof(T), System.Globalization.CultureInfo.InvariantCulture);\n        }\n\n        public T[] Next<T>(int x){\n            var ret = new T[x];\n            for(var i = 0; i < x; ++i) ret[i] = Next<T>();\n            return ret;\n        }\n\n        public T[][] Next<T>(int y, int x){\n            var ret = new T[y][];\n            for(var i = 0; i < y; ++i) ret[i] = Next<T>(x);\n            return ret;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace V2014{\n    public class Program{\n        int W;\n        int H;\n        //string[] A;\n        \n        //int[][] _grid;\n        //int[] _dx = {1, 0, -1, 0};\n        //int[] _dy = {0, 1, 0, -1};\n        \n        bool IsInside(int x, int y){\n            return 0 <= x && x < W && 0 <= y && y < H;\n        }\n        \n        public static void Main(string[] args){\n            new Program();\n        }\n        \n        Program(){\n            while(true){\n                var sr = new StreamReader();\n                W = sr.Next<int>();\n                H = sr.Next<int>();\n                //A = sr.Next<string>(H);\n                if(W + H == 0) return;\n\n                //_grid = new int[H, W].ToJaggedArray();\n                for(var i = 0; i < H; i++){\n                    for(var j = 0; j < W; j++){\n                        //_grid[i][j] = \".BW\".IndexOf(A[i][j]);\n                    }\n                }\n                //Solve();\n            }\n        }\n        /*\n        void Solve(){\n            var dic = new Dictionary<int, int>{{-1, 0}, {1, 0}};\n            for(var i = 0; i < H; i++){\n                for(var j = 0; j < W; j++){\n                    var count = Bfs(j, i);\n                    if(dic.ContainsKey(Math.Sign(count))){\n                        dic[Math.Sign(count)] += Math.Sign(count) * count;\n                    }\n                }\n            }\n            Console.WriteLine(string.Join(\" \", dic.Values.Select(x => x.ToString()).ToArray()));\n        }\n\n        int Bfs(int x, int y){\n            if(_grid[y][x] != 0) return 0;\n\n            var count = 1;\n            _grid[y][x] = int.MinValue;\n            var hs = new HashSet<int>();\n\n            var que = new Queue<int>();\n            que.Enqueue(x);\n            que.Enqueue(y);\n\n            while(que.Count > 0){\n                var cx = que.Dequeue();\n                var cy = que.Dequeue();\n                for(var i = 0; i < _dx.Length; i++){\n                    var nx = cx + _dx[i];\n                    var ny = cy + _dy[i];\n                    if(IsInside(nx, ny) && _grid[ny][nx] != int.MinValue){\n                        if(_grid[ny][nx] == 0){\n                            que.Enqueue(nx);\n                            que.Enqueue(ny);\n                            _grid[ny][nx] = int.MinValue;\n                            count++;\n                        } else{\n                            hs.Add(_grid[ny][nx]);\n                        }\n                    }\n                }\n            }\n            if(hs.Count != 1) return 0;\n            return (2 * hs.Single() - 3) * count;\n        }\n        */\n    }\n\n    public static class ExMethod{\n        public static T[][] ToJaggedArray<T>(this T[,] src){\n            var x = src.GetLength(1);\n            var y = src.GetLength(0);\n            var ret = new T[y][];\n\n            for(var i = 0; i < y; i++){\n                ret[i] = new T[x];\n                for(var j = 0; j < x; j++){\n                    ret[i][j] = src[i, j];\n                }\n            }\n\n            return ret;\n        }\n    }\n\n    public class StreamReader{\n        private readonly char[] _c = {' '};\n        private int _index = -1;\n        private string[] _input = new string[0];\n        private readonly System.IO.StreamReader _sr = new System.IO.StreamReader(Console.OpenStandardInput());\n\n        public T Next<T>(){\n            if(_index == _input.Length - 1){\n                _index = -1;\n                while(true){\n                    string rl = _sr.ReadLine();\n                    if(rl == null){\n                        if(typeof(T).IsClass) return default(T);\n                        return (T)typeof(T).GetField(\"MinValue\").GetValue(null);\n                    }\n                    if(rl != \"\"){\n                        _input = rl.Split(_c, StringSplitOptions.RemoveEmptyEntries);\n                        break;\n                    }\n                }\n            }\n            return (T)Convert.ChangeType(_input[++_index], typeof(T), System.Globalization.CultureInfo.InvariantCulture);\n        }\n\n        public T[] Next<T>(int x){\n            var ret = new T[x];\n            for(var i = 0; i < x; ++i) ret[i] = Next<T>();\n            return ret;\n        }\n\n        public T[][] Next<T>(int y, int x){\n            var ret = new T[y][];\n            for(var i = 0; i < y; ++i) ret[i] = Next<T>(x);\n            return ret;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace V2014{\n    public class Program{\n        int W;\n        int H;\n        string[] A;\n\n        int[][] _grid;\n        int[] _dx = {1, 0, -1, 0};\n        int[] _dy = {0, 1, 0, -1};\n\n        bool IsInside(int x, int y){\n            return 0 <= x && x < W && 0 <= y && y < H;\n        }\n\n        public static void Main(string[] args){\n            new Program().Solve();\n        }\n\n        void Solve(){\n            var sr = new StreamReader();\n            while(true){\n                W = sr.Next<int>();\n                H = sr.Next<int>();\n                A = sr.Next<string>(H);\n                if(W + H == 0) return;\n\n                _grid = new int[H, W].ToJaggedArray();\n                for(var i = 0; i < H; i++){\n                    for(var j = 0; j < W; j++){\n                        _grid[i][j] = \".BW\".IndexOf(A[i][j]);\n                    }\n                }\n\n                var dic = new Dictionary<int, int>{{-1, 0}, {1, 0}};\n                for(var i = 0; i < H; i++){\n                    for(var j = 0; j < W; j++){\n                        var count = Bfs(j, i);\n                        if(dic.ContainsKey(Math.Sign(count))){\n                            dic[Math.Sign(count)] += Math.Sign(count) * count;\n                        }\n                    }\n                }\n                Console.WriteLine(string.Join(\" \", dic.Values.Select(x => x.ToString()).ToArray()));\n            }\n        }\n\n        int Bfs(int x, int y){\n            if(_grid[y][x] != 0) return 0;\n\n            var count = 1;\n            _grid[y][x] = int.MinValue;\n            var hs = new HashSet<int>();\n\n            var que = new Queue<int>();\n            que.Enqueue(x);\n            que.Enqueue(y);\n\n            while(que.Count > 0){\n                var cx = que.Dequeue();\n                var cy = que.Dequeue();\n                for(var i = 0; i < _dx.Length; i++){\n                    var nx = cx + _dx[i];\n                    var ny = cy + _dy[i];\n                    if(IsInside(nx, ny) && _grid[ny][nx] != int.MinValue){\n                        if(_grid[ny][nx] == 0){\n                            que.Enqueue(nx);\n                            que.Enqueue(ny);\n                            _grid[ny][nx] = int.MinValue;\n                            count++;\n                        } else{\n                            hs.Add(_grid[ny][nx]);\n                        }\n                    }\n                }\n            }\n            if(hs.Count != 1) return 0;\n            return (2 * hs.Single() - 3) * count;\n        }\n    }\n\n    public static class ExMethod{\n        public static T[][] ToJaggedArray<T>(this T[,] src){\n            var x = src.GetLength(1);\n            var y = src.GetLength(0);\n            var ret = new T[y][];\n\n            for(var i = 0; i < y; i++){\n                ret[i] = new T[x];\n                for(var j = 0; j < x; j++){\n                    ret[i][j] = src[i, j];\n                }\n            }\n\n            return ret;\n        }\n    }\n\n    public class StreamReader{\n        private readonly char[] _c = {' '};\n        private int _index = -1;\n        private string[] _input = new string[0];\n        private readonly System.IO.StreamReader _sr = new System.IO.StreamReader(Console.OpenStandardInput());\n\n        public T Next<T>(){\n            if(_index == _input.Length - 1){\n                _index = -1;\n                while(true){\n                    string rl = _sr.ReadLine();\n                    if(rl == null){\n                        if(typeof(T).IsClass) return default(T);\n                        return (T)typeof(T).GetField(\"MinValue\").GetValue(null);\n                    }\n                    if(rl != \"\"){\n                        _input = rl.Split(_c, StringSplitOptions.RemoveEmptyEntries);\n                        break;\n                    }\n                }\n            }\n            return (T)Convert.ChangeType(_input[++_index], typeof(T), System.Globalization.CultureInfo.InvariantCulture);\n        }\n\n        public T[] Next<T>(int x){\n            var ret = new T[x];\n            for(var i = 0; i < x; ++i) ret[i] = Next<T>();\n            return ret;\n        }\n\n        public T[][] Next<T>(int y, int x){\n            var ret = new T[y][];\n            for(var i = 0; i < y; ++i) ret[i] = Next<T>(x);\n            return ret;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace V2014{\n    public class Program{\n        int W;\n        int H;\n        string[] A;\n        \n        //int[][] _grid;\n        //int[] _dx = {1, 0, -1, 0};\n        //int[] _dy = {0, 1, 0, -1};\n        \n        bool IsInside(int x, int y){\n            return 0 <= x && x < W && 0 <= y && y < H;\n        }\n        \n        public static void Main(string[] args){\n            new Program();\n        }\n        \n        Program(){\n            while(true){\n                var sr = new StreamReader();\n                W = sr.Next<int>();\n                H = sr.Next<int>();\n                A = sr.Next<string>(H);\n                if(W + H == 0) return;\n\n                //_grid = new int[H, W].ToJaggedArray();\n                for(var i = 0; i < H; i++){\n                    for(var j = 0; j < W; j++){\n                        //_grid[i][j] = \".BW\".IndexOf(A[i][j]);\n                    }\n                }\n                //Solve();\n            }\n        }\n        /*\n        void Solve(){\n            var dic = new Dictionary<int, int>{{-1, 0}, {1, 0}};\n            for(var i = 0; i < H; i++){\n                for(var j = 0; j < W; j++){\n                    var count = Bfs(j, i);\n                    if(dic.ContainsKey(Math.Sign(count))){\n                        dic[Math.Sign(count)] += Math.Sign(count) * count;\n                    }\n                }\n            }\n            Console.WriteLine(string.Join(\" \", dic.Values.Select(x => x.ToString()).ToArray()));\n        }\n\n        int Bfs(int x, int y){\n            if(_grid[y][x] != 0) return 0;\n\n            var count = 1;\n            _grid[y][x] = int.MinValue;\n            var hs = new HashSet<int>();\n\n            var que = new Queue<int>();\n            que.Enqueue(x);\n            que.Enqueue(y);\n\n            while(que.Count > 0){\n                var cx = que.Dequeue();\n                var cy = que.Dequeue();\n                for(var i = 0; i < _dx.Length; i++){\n                    var nx = cx + _dx[i];\n                    var ny = cy + _dy[i];\n                    if(IsInside(nx, ny) && _grid[ny][nx] != int.MinValue){\n                        if(_grid[ny][nx] == 0){\n                            que.Enqueue(nx);\n                            que.Enqueue(ny);\n                            _grid[ny][nx] = int.MinValue;\n                            count++;\n                        } else{\n                            hs.Add(_grid[ny][nx]);\n                        }\n                    }\n                }\n            }\n            if(hs.Count != 1) return 0;\n            return (2 * hs.Single() - 3) * count;\n        }\n        */\n    }\n\n    public static class ExMethod{\n        public static T[][] ToJaggedArray<T>(this T[,] src){\n            var x = src.GetLength(1);\n            var y = src.GetLength(0);\n            var ret = new T[y][];\n\n            for(var i = 0; i < y; i++){\n                ret[i] = new T[x];\n                for(var j = 0; j < x; j++){\n                    ret[i][j] = src[i, j];\n                }\n            }\n\n            return ret;\n        }\n    }\n\n    public class StreamReader{\n        private readonly char[] _c = {' '};\n        private int _index = -1;\n        private string[] _input = new string[0];\n        private readonly System.IO.StreamReader _sr = new System.IO.StreamReader(Console.OpenStandardInput());\n\n        public T Next<T>(){\n            if(_index == _input.Length - 1){\n                _index = -1;\n                while(true){\n                    string rl = _sr.ReadLine();\n                    if(rl == null){\n                        if(typeof(T).IsClass) return default(T);\n                        return (T)typeof(T).GetField(\"MinValue\").GetValue(null);\n                    }\n                    if(rl != \"\"){\n                        _input = rl.Split(_c, StringSplitOptions.RemoveEmptyEntries);\n                        break;\n                    }\n                }\n            }\n            return (T)Convert.ChangeType(_input[++_index], typeof(T), System.Globalization.CultureInfo.InvariantCulture);\n        }\n\n        public T[] Next<T>(int x){\n            var ret = new T[x];\n            for(var i = 0; i < x; ++i) ret[i] = Next<T>();\n            return ret;\n        }\n\n        public T[][] Next<T>(int y, int x){\n            var ret = new T[y][];\n            for(var i = 0; i < y; ++i) ret[i] = Next<T>(x);\n            return ret;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace V2014{\n    public class Program{\n        int W;\n        int H;\n        string[] A;\n        \n        readonly int[][] _grid;\n        readonly int[] _dx = {1, 0, -1, 0};\n        readonly int[] _dy = {0, 1, 0, -1};\n\n        bool IsInside(int x, int y){\n            return 0 <= x && x < W && 0 <= y && y < H;\n        }\n        \n        public static void Main(string[] args){\n            new Program();\n        }\n        \n        Program(){\n            while(true){\n                var sr = new StreamReader();\n                W = sr.Next<int>();\n                H = sr.Next<int>();\n                A = sr.Next<string>(H);\n                if(W + H == 0) return;\n\n                _grid = new int[H, W].ToJaggedArray();\n                for(var i = 0; i < H; i++){\n                    for(var j = 0; j < W; j++){\n                        _grid[i][j] = \".BW\".IndexOf(A[i][j]);\n                    }\n                }\n                Solve();\n            }\n        }\n        \n        void Solve(){\n            var dic = new Dictionary<int, int>{{-1, 0}, {1, 0}};\n            for(var i = 0; i < H; i++){\n                for(var j = 0; j < W; j++){\n                    var count = Bfs(j, i);\n                    if(dic.ContainsKey(Math.Sign(count))){\n                        dic[Math.Sign(count)] += Math.Sign(count) * count;\n                    }\n                }\n            }\n            Console.WriteLine(string.Join(\" \", dic.Values.Select(x => x.ToString()).ToArray()));\n        }\n\n        int Bfs(int x, int y){\n            if(_grid[y][x] != 0) return 0;\n\n            var count = 1;\n            _grid[y][x] = int.MinValue;\n            var hs = new HashSet<int>();\n\n            var que = new Queue<int>();\n            que.Enqueue(x);\n            que.Enqueue(y);\n\n            while(que.Count > 0){\n                var cx = que.Dequeue();\n                var cy = que.Dequeue();\n                for(var i = 0; i < _dx.Length; i++){\n                    var nx = cx + _dx[i];\n                    var ny = cy + _dy[i];\n                    if(IsInside(nx, ny) && _grid[ny][nx] != int.MinValue){\n                        if(_grid[ny][nx] == 0){\n                            que.Enqueue(nx);\n                            que.Enqueue(ny);\n                            _grid[ny][nx] = int.MinValue;\n                            count++;\n                        } else{\n                            hs.Add(_grid[ny][nx]);\n                        }\n                    }\n                }\n            }\n            if(hs.Count != 1) return 0;\n            return (2 * hs.Single() - 3) * count;\n        }\n    }\n\n    public static class ExMethod{\n        public static T[][] ToJaggedArray<T>(this T[,] src){\n            var x = src.GetLength(1);\n            var y = src.GetLength(0);\n            var ret = new T[y][];\n\n            for(var i = 0; i < y; i++){\n                ret[i] = new T[x];\n                for(var j = 0; j < x; j++){\n                    ret[i][j] = src[i, j];\n                }\n            }\n\n            return ret;\n        }\n    }\n\n    public class StreamReader{\n        private readonly char[] _c = {' '};\n        private int _index = -1;\n        private string[] _input = new string[0];\n        private readonly System.IO.StreamReader _sr = new System.IO.StreamReader(Console.OpenStandardInput());\n\n        public T Next<T>(){\n            if(_index == _input.Length - 1){\n                _index = -1;\n                while(true){\n                    string rl = _sr.ReadLine();\n                    if(rl == null){\n                        if(typeof(T).IsClass) return default(T);\n                        return (T)typeof(T).GetField(\"MinValue\").GetValue(null);\n                    }\n                    if(rl != \"\"){\n                        _input = rl.Split(_c, StringSplitOptions.RemoveEmptyEntries);\n                        break;\n                    }\n                }\n            }\n            return (T)Convert.ChangeType(_input[++_index], typeof(T), System.Globalization.CultureInfo.InvariantCulture);\n        }\n\n        public T[] Next<T>(int x){\n            var ret = new T[x];\n            for(var i = 0; i < x; ++i) ret[i] = Next<T>();\n            return ret;\n        }\n\n        public T[][] Next<T>(int y, int x){\n            var ret = new T[y][];\n            for(var i = 0; i < y; ++i) ret[i] = Next<T>(x);\n            return ret;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace V2014{\n    public class Program{\n        readonly int W;\n        readonly int H;\n        readonly string[] A;\n\n        readonly int[][] _grid;\n        readonly int[] _dx = {1, 0, -1, 0};\n        readonly int[] _dy = {0, 1, 0, -1};\n\n        bool IsInside(int x, int y){\n            return 0 <= x && x < W && 0 <= y && y < H;\n        }\n\n        public static void Main(string[] args){\n            new Program();\n        }\n\n        Program(){\n            /*\n            while(true){\n                var sr = new StreamReader();\n                W = sr.Next<int>();\n                H = sr.Next<int>();\n                A = sr.Next<string>(H);\n                if(W + H == 0) return;\n\n                _grid = new int[H, W].ToJaggedArray();\n                for(var i = 0; i < H; i++){\n                    for(var j = 0; j < W; j++){\n                        _grid[i][j] = \".BW\".IndexOf(A[i][j]);\n                    }\n                }\n                Solve();\n            }\n            */\n        }\n\n        void Solve(){\n            var dic = new Dictionary<int, int>{{-1, 0}, {1, 0}};\n            for(var i = 0; i < H; i++){\n                for(var j = 0; j < W; j++){\n                    var count = Bfs(j, i);\n                    if(dic.ContainsKey(Math.Sign(count))){\n                        dic[Math.Sign(count)] += Math.Sign(count) * count;\n                    }\n                }\n            }\n            Console.WriteLine(string.Join(\" \", dic.Values.Select(x => x.ToString()).ToArray()));\n        }\n\n        int Bfs(int x, int y){\n            if(_grid[y][x] != 0) return 0;\n\n            var count = 1;\n            _grid[y][x] = int.MinValue;\n            var hs = new HashSet<int>();\n\n            var que = new Queue<int>();\n            que.Enqueue(x);\n            que.Enqueue(y);\n\n            while(que.Count > 0){\n                var cx = que.Dequeue();\n                var cy = que.Dequeue();\n                for(var i = 0; i < _dx.Length; i++){\n                    var nx = cx + _dx[i];\n                    var ny = cy + _dy[i];\n                    if(IsInside(nx, ny) && _grid[ny][nx] != int.MinValue){\n                        if(_grid[ny][nx] == 0){\n                            que.Enqueue(nx);\n                            que.Enqueue(ny);\n                            _grid[ny][nx] = int.MinValue;\n                            count++;\n                        } else{\n                            hs.Add(_grid[ny][nx]);\n                        }\n                    }\n                }\n            }\n            if(hs.Count != 1) return 0;\n            return (2 * hs.Single() - 3) * count;\n        }\n    }\n\n    public static class ExMethod{\n        public static T[][] ToJaggedArray<T>(this T[,] src){\n            var x = src.GetLength(1);\n            var y = src.GetLength(0);\n            var ret = new T[y][];\n\n            for(var i = 0; i < y; i++){\n                ret[i] = new T[x];\n                for(var j = 0; j < x; j++){\n                    ret[i][j] = src[i, j];\n                }\n            }\n\n            return ret;\n        }\n    }\n\n    public class StreamReader{\n        private readonly char[] _c = {' '};\n        private int _index = -1;\n        private string[] _input = new string[0];\n        private readonly System.IO.StreamReader _sr = new System.IO.StreamReader(Console.OpenStandardInput());\n\n        public T Next<T>(){\n            if(_index == _input.Length - 1){\n                _index = -1;\n                while(true){\n                    string rl = _sr.ReadLine();\n                    if(rl == null){\n                        if(typeof(T).IsClass) return default(T);\n                        return (T)typeof(T).GetField(\"MinValue\").GetValue(null);\n                    }\n                    if(rl != \"\"){\n                        _input = rl.Split(_c, StringSplitOptions.RemoveEmptyEntries);\n                        break;\n                    }\n                }\n            }\n            return (T)Convert.ChangeType(_input[++_index], typeof(T), System.Globalization.CultureInfo.InvariantCulture);\n        }\n\n        public T[] Next<T>(int x){\n            var ret = new T[x];\n            for(var i = 0; i < x; ++i) ret[i] = Next<T>();\n            return ret;\n        }\n\n        public T[][] Next<T>(int y, int x){\n            var ret = new T[y][];\n            for(var i = 0; i < y; ++i) ret[i] = Next<T>(x);\n            return ret;\n        }\n    }\n}"
  },
  {
    "language": "JavaScript",
    "code": "function bomb(y,x){\n   cnt++;\n   var dx=[0,-1,1,0];\n   var dy=[-1,0,0,1];\n   for(var i=0;i<4;i++){\n      var X=x+dx[i];\n      var Y=y+dy[i];\n      if(Y>=h || Y<0 || X>=w || X<0)continue;\n      if(yx[Y][X]==\"S\")continue;\n      else if(yx[Y][X]==\".\"){yx[Y][X]=\"S\";bomb(Y,X);}\n      else {\n         if(color==\"\" || color==yx[Y][X])color=yx[Y][X];\n         else color=\"bad\";\n      }\n   }\n}\nvar input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar arr=input.trim().split(\"\\n\");\nwhile(true){\n   var wh=arr.shift();\n   if(wh==\"0 0\")break;\n   wh=wh.split(\" \").map(Number);\n   var w=wh[0];\n   var h=wh[1];\n   var yx=[];\n   for(var i=0;i<h;i++)yx.push(arr.shift().split(\"\"));\n   var ans=[0,0];\n   for(var y=0;y<h;y++){\n      for(var x=0;x<w;x++){\n         var color=\"\";\n         var cnt=0;\n         if(yx[y][x]==\".\"){yx[y][x]=\"S\";bomb(y,x);}\n         if(color==\"B\")ans[0]+=cnt;\n         else if(color==\"W\")ans[1]+=cnt;\n      }\n   }\n   console.log(ans[0]+\" \"+ans[1]);\n}"
  },
  {
    "language": "JavaScript",
    "code": "function bomb(y,x){\n   cnt++;\n   var dx=[0,-1,1,0];\n   var dy=[-1,0,0,1];\n   for(var i=0;i<4;i++){\n      var X=x+dx[i];\n      var Y=y+dy[i];\n      if(Y>=h || Y<0 || X>=w || X<0)continue;\n      if(yx[Y][X]==\"S\")continue;\n      else if(yx[Y][X]==\".\"){yx[Y][X]=\"S\";bomb(Y,X);}\n      else {\n         if(color==\"\" || color==yx[Y][X])color=yx[Y][X];\n         else color=\"bad\";\n      }\n   }\n}\nvar input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar arr=input.trim().split(\"\\n\");\nwhile(true){\n   var wh=arr.shift();\n   if(wh==\"0 0\")break;\n   wh=wh.split(\" \").map(Number);\n   var w=wh[0];\n   var h=wh[1];\n   var yx=[];\n   for(var i=0;i<h;i++)yx.push(arr.shift().split(\"\"));\n   var ans=[0,0];\n   for(var y=0;y<h;y++){\n      for(var x=0;x<w;x++){\n         var color=\"\";\n         var cnt=0;\n         if(yx[y][x]==\".\"){yx[y][x]=\"S\";bomb(y,x);}\n         if(color==\"B\")ans[0]+=cnt;\n         else if(color==\"W\")ans[1]+=cnt;\n      }\n   }\n   console.log(ans);\n}"
  },
  {
    "language": "Ruby",
    "code": "D = [[1,0],[0,-1],[-1,0],[0,1]]\n\ndef dfs(x, y)\n  if $fld[y][x] == \"B\"\n    $flag_b = true \n    return\n  end\n  if $fld[y][x] == \"W\"\n    $flag_w = true\n    return\n  end\n  $vst[y][x] = true\n  D.each do |dx, dy|\n    nx, ny = x + dx, y + dy\n    if nx >= 0 && nx < $w && ny >= 0 && ny < $h && $vst[ny][nx].nil?\n      dfs(nx, ny)\n    end\n  end\nend\n\nloop do\n  $w, $h = gets.split.map(&:to_i)\n  break if $w == 0\n  $fld = $h.times.map{ gets.chomp.split(\"\") }\n  cw = cb = 0\n  for i in (0...$w)\n    for j in (0...$h)\n      $vst = $h.times.map{ [nil]*$w }\n      $flag_b = $flag_w = false\n      dfs(i, j) unless $fld[j][i] == \"B\" || $fld[j][i] == \"W\" \n      cb += 1 if $flag_b && !$flag_w\n      cw += 1 if !$flag_b && $flag_w\n    end\n  end\n  puts \"#{cb} #{cw}\"\nend"
  },
  {
    "language": "Ruby",
    "code": "class UnionFind\n\tdef initialize\n\t\t@obj_to_node = {}\n\tend\n\n\tdef add(obj)\n\t\t@obj_to_node[obj] ||= Node.new(obj)\n\tend\n\n\tdef size(x = nil)\n\t\tx ? @obj_to_node[x].root.size : @obj_to_node.size\n\tend\n\n\tclass Node\n\t\tdef initialize(obj)\n\t\t\t@obj = obj\n\t\t\t@parent = self\n\t\t\t@size = 1\n\t\tend\n\n\t\tdef root\n\t\t\treturn self if @parent == self\n\t\t\t@parent = @parent.root\n\t\tend\t\n\n\t\tattr_accessor :parent, :size\n\tend\n\n\tdef union(x, y)\n\t\tu = (@obj_to_node[x] ||= Node.new(x)).root\n\t\tv = (@obj_to_node[y] ||= Node.new(y)).root\n\t\treturn if u == v\n\t\tu.parent = v.root\n\t\tv.size += u.size\n\tend\n\n\tdef same?(x, y)\n\t\treturn false unless u = @obj_to_node[x]\n\t\treturn false unless v = @obj_to_node[y]\n\t\tu.root == v.root\n\tend\n\n\tdef root_of(x)\n\t\tu = @obj_to_node[x]\n\t\tu ? u.root : nil\n\tend\nend\n\nrequire 'set'\nloop {\n\tw, h = gets.split.map &:to_i\n\tbreak if w == 0\n\ta = (1..h).map{ gets.chomp.split(\"\") }\n\tcolor = (1..h).map{ (1..w).map{ Set.new } }\n\tuf = UnionFind.new\n\t(0..h-1).each{|i|\n\t\t(0..w-1).each{|j|\n\t\t\tuf.add([i,j])\n\t\t\tif i < h-1\n\t\t\t\tcolor[i][j] << :w if a[i][j] == ?. && a[i+1][j] == ?W\n\t\t\t\tcolor[i][j] << :b if a[i][j] == ?. && a[i+1][j] == ?B\n\t\t\t\tcolor[i+1][j] << :w if a[i+1][j] == ?. && a[i][j] == ?W\n\t\t\t\tcolor[i+1][j] << :b if a[i+1][j] == ?. && a[i][j] == ?B\n\t\t\t\tuf.union([i,j], [i+1, j]) if a[i][j] == ?. && a[i+1][j] == ?.\n\t\t\tend\n\t\t\tif j < w-1\n\t\t\t\tcolor[i][j] << :w if a[i][j] == ?. && a[i][j+1] == ?W\n\t\t\t\tcolor[i][j] << :b if a[i][j] == ?. && a[i][j+1] == ?B\n\t\t\t\tcolor[i][j+1] << :w if a[i][j+1] == ?. && a[i][j] == ?W\n\t\t\t\tcolor[i][j+1] << :b if a[i][j+1] == ?. && a[i][j] == ?B\n\t\t\t\tuf.union([i,j], [i, j+1]) if a[i][j] == ?. && a[i][j+1] == ?.\n\t\t\tend\n\t\t}\n\t}\n\n\thash = {}\n\t(0..h-1).each{|i|\n\t\t(0..w-1).each{|j|\n\t\t\tr = uf.root_of([i,j])\n\t\t\thash[r] ||= Set.new\n\t\t\thash[r] += color[i][j]\n\t\t}\n\t}\n\twhite = black = 0\n\thash.each{|r, cs|\n\t\tnext unless r\n\t\twhite += r.size if cs.to_a == [:w]\n\t\tblack += r.size if cs.to_a == [:b]\n\t}\n\tputs \"#{black} #{white}\"\n}"
  },
  {
    "language": "Ruby",
    "code": "while true\n    @w,@h=gets.split(\" \").map(&:to_i)\n    if @w==0\n        break\n    end\n    a=(0...@h).map{gets}\n    @flag=Array.new(@h).map{Array.new(@w,0)}\n    @h.times do |i|\n        @w.times do |j|\n            if a[i][j]=='W'\n                @flag[i][j]|=1\n            elsif a[i][j]=='B'\n                @flag[i][j]|=2\n            end\n        end\n    end\n    def solve(x,y,c)\n        dx=[0,1,0,-1]\n        dy=[1,0,-1,0]\n        4.times do |i|\n            if x+dx[i]<0||x+dx[i]>=@w||y+dy[i]<0||y+dy[i]>=@h\n                next\n            end\n            if @flag[y+dy[i]][x+dx[i]]&3>0\n                next\n            end\n            if @flag[y+dy[i]][x+dx[i]]&c>0\n                next\n            end\n            @flag[y+dy[i]][x+dx[i]]|=c\n            solve(x+dx[i],y+dy[i],c)\n        end\n    end\n    @h.times do |i|\n        @w.times do |j|\n            if @flag[i][j]==1\n                solve(j,i,4)\n            elsif @flag[i][j]==2\n                solve(j,i,8)\n            end\n        end\n    end\n    bcnt=0\n    wcnt=0\n    @h.times do |i|\n        @w.times do |j|\n            if @flag[i][j]&15==4\n                wcnt+=1\n            elsif @flag[i][j]&15==8\n                bcnt+=1\n            end\n        end\n    end\n    print(\"#{bcnt} #{wcnt}\\n\")\nend"
  },
  {
    "language": "Ruby",
    "code": "$dx = [0,1,0,-1]\n$dy = [1,0,-1,0]\ndef bfs(f, sy, sx, h, w)\n    q = [[sy,sx]]\n    visited = [[sy,sx]]\n    col = f[sy][sx].downcase\n    while q.size > 0\n        sy, sx = q.shift\n        for i in 0..3\n            cy = sy + $dy[i]\n            cx = sx + $dx[i]\n            if cy.between?(0,h-1) && cx.between?(0,w-1) && f[cy][cx] != \"W\" && f[cy][cx] != \"B\" && !visited.include?([cy,cx])\n                q.push([cy,cx])\n                visited.push([cy,cx])\n                if f[cy][cx] == \".\"\n                    f[cy][cx] = col\n                elsif f[cy][cx] != col\n                    f[cy][cx] = \"*\" \n                end\n            end\n        end\n    end\n    return f\nend\ndef pp(f)\n    f.each do |r|\n        puts r\n    end\n    puts\nend\nloop do\n    w, h = gets.split.map(&:to_i)\n    break if w == 0 && h == 0\n    f = h.times.map{gets.strip}\n    h.times do |i|\n        w.times do |j|\n            next if f[i][j] != \"W\" && f[i][j] != \"B\"\n            f = bfs(f,i,j,h,w)\n        end\n    end\n    wc = bc = 0\n    h.times do |i|\n        w.times do |j|\n            wc += 1 if f[i][j] == \"w\"\n            bc += 1 if f[i][j] == \"b\"\n        end\n    end\n    puts \"#{bc} #{wc}\"\nend"
  },
  {
    "language": "Ruby",
    "code": "D = [[1,0],[0,-1],[-1,0],[0,1]]\n \ndef dfs(x, y)\n  if $fld[y][x] == \"B\"\n    $flag_b = true\n    return\n  elsif $fld[y][x] == \"W\"\n    $flag_w = true\n    return\n  end\n  $cnt += 1\n  $vst[y][x] = true\n  D.each do |dx, dy|\n    nx, ny = x + dx, y + dy\n    if nx >= 0 && nx < $w && ny >= 0 && ny < $h && !$vst[ny][nx]\n      dfs(nx, ny)\n    end\n  end\nend\n \nloop do\n  $w, $h = gets.split.map(&:to_i)\n  break if $w == 0\n  $fld = $h.times.map{ gets.chomp.split(\"\") }\n  \n  cw = cb = 0\n  $vst = $h.times.map{ [false]*$w }\n  for i in (0...$h)\n    for j in (0...$w)\n      if $fld[i][j] == \".\" && !$vst[i][j]\n        $flag_b = $flag_w = false\n        $cnt = 0\n        dfs(j, i) \n        cb += $cnt if $flag_b && !$flag_w\n        cw += $cnt if !$flag_b && $flag_w\n      end\n    end\n  end\n  puts \"#{cb} #{cw}\"\nend"
  },
  {
    "language": "Ruby",
    "code": "$dx = [0,1,0,-1]\n$dy = [1,0,-1,0]\n$bc = 0\n$wc = 0\ndef bfs(f, sy, sx, h, w, visited, bc, wc)\n    f[sy][sx] = \"*\"\n    wf = false\n    bf = false\n    count = 1\n    q = [[sy,sx]]\n    visited.push([sy,sx])\n    col = f[sy][sx].downcase\n    while q.size > 0\n        sy, sx = q.shift\n        for i in 0..3\n            cy = sy + $dy[i]\n            cx = sx + $dx[i]\n            if cy.between?(0,h-1) && cx.between?(0,w-1) && !visited.include?([cy,cx])\n                if  f[cy][cx] == \"W\"\n                    wf = true\n                elsif\n                    f[cy][cx] == \"B\"\n                    bf = true\n                elsif\n                    count += 1\n                    q.push([cy,cx])\n                    visited.push([cy,cx])\n                    f[cy][cx] = \"*\"\n                end\n            end\n        end\n    end\n    bc += count if bf && !wf\n    wc += count if !bf && wf\n    return [f,visited,bc,wc]\nend\ndef pp(f)\n    f.each do |r|\n        puts r\n    end\n    puts\nend\nloop do\n    w, h = gets.split.map(&:to_i)\n    break if w == 0 && h == 0\n    f = h.times.map{gets.strip}\n    visited = []\n    bc = wc = 0\n    h.times do |i|\n        w.times do |j|\n            next if f[i][j] == \"W\" || f[i][j] == \"B\" || visited.include?([i,j])\n            f, visited, bc, wc = bfs(f,i,j,h,w,visited,bc,wc)\n        end\n    end\n    puts \"#{bc} #{wc}\"\nend"
  },
  {
    "language": "Ruby",
    "code": "$field\n$visited\n$cnt\n$b_flg\n$w_flg\n$w\n$h\n$dy = Array[0, -1, 0, 1]\n$dx = Array[1, 0, -1, 0]\n\ndef search(i, j)\n  $cnt += 1\n  $visited[i][j] = true\n\n  for k in 0...4\n    y = i + $dy[k]\n    x = j + $dx[k]\n    if y < 0 || $h <= y\n      next\n    end\n    if x < 0 || $w <= x\n      next\n    end\n    if $visited[y][x]\n      next\n    end\n    if $field[y][x] == 'B'\n      $b_flg = true\n    elsif $field[y][x] == 'W'\n      $w_flg = true\n    else\n      search(y, x)\n    end\n  end\nend\n\nloop do\n  $w, $h = gets.chomp.split.map(&:to_i)\n\n  if $w == 0 && $h == 0\n    break;\n  end\n\n  $field = Array.new($h)\n  $visited = Array.new($h)\n\n  for i in 0...$h\n    $field[i] = gets.chomp.split(//).map(&:to_s)\n    $visited[i] = Array.new($w, false)\n  end\n\n  ans_b = ans_w = 0\n\n  for i in 0...$h\n    for j in 0...$w\n      if $field[i][j] == '.' && !$visited[i][j]\n        $b_flg = $w_flg = false\n        $cnt = 0\n        search(i, j)\n        if $b_flg && !$w_flg\n          ans_b += $cnt\n        elsif !$b_flg && $w_flg\n          ans_w += $cnt\n        end\n      end\n    end\n  end\n\n  puts \"#{ans_b} #{ans_w}\"\nend"
  },
  {
    "language": "D",
    "code": "import std.stdio,std.conv, std.algorithm, std.container,std.array,std.range,std.string,std.typecons,std.numeric,std.math,std.random,std.functional;\n\nvoid main(){\n\tfor(int w,h ; read(w,h),w|h ; ){\t\t\n\t\tauto land = readAciiMap(w,h);\n\t\tint B,W;\n\t\tland.DFS!(char)( DPos , '.'\n\t\t\t,(Pos p,ref char state){\n\t\t\t\tif(land[p] == 'W' || land[p] == 'B'){\n\t\t\t\t\tif(state == '.') state = land[p];\n\t\t\t\t\telse if(state != land[p] ) state = 'X';\n\t\t\t\t\treturn false;\n\t\t\t\t} \n\t\t\t\treturn true;\n\t\t\t},(Pos[] set,char state){\n\t\t\t\tif(state == 'B') B += set.length;\n\t\t\t\tif(state == 'W') W += set.length;\n\t\t\t\treturn true;\n\t\t\t});\n\t\twriteln(B,\" \",W);\n\t}\n}\n\n\nint   read(){int n;read(n);return n;}\nvoid  read(T...)  (auto ref T args){mixin(readMixin);}\nvoid  readArray(T)(auto ref T args){mixin(readMixin);}\nconst readMixin = q{ \n\tauto line = readln().split();\n\tforeach(i,ref arg; args){ \n\t\tif (i >= line.length) return;\n\t\targ = line[i].to!(typeof(arg));\n\t}\n};\nvoid times(int n,void delegate() stmt){ foreach(i;0..n)stmt();}\nvoid Swap(T)(ref T a,ref T b){T t = a;a = b;b = t;}\n\nconst DPos = [Pos(1,0),Pos(0,1),Pos(-1,0),Pos(0,-1)];\nstruct Pos{ \n\tint x,y,z;\n\tthis(int x_ =0,int y_=0,int z_=0){x=x_;y=y_;z=z_;}\n\tthis(ulong x_ =0,ulong y_=0,ulong z_=0){x=cast(int)x_;y=cast(int)y_;z=cast(int)z_;}\n\tbool inRange(int w,int h,int Z=1){\n\t\treturn x>=0 && y >= 0 && z >=0 && x < w && y < h && z < Z;\n\t}\n\tbool inRange(ulong w,ulong h,ulong Z=1){return inRange(cast(int)w,cast(int)h,cast(int)Z);}\n\tPos opBinary(string op)(Pos rhs) {\n\t\treturn Pos ( mixin( \"x\"~op~\"rhs.x\" ),\n\t\t\t\t\t mixin( \"y\"~op~\"rhs.y\" ),\n\t\t\t\t\tmixin( \"z\"~op~\"rhs.z\" ));\n\t}\n\tvoid opOpAssign(string op)(Pos lhs) {\n\t\tmixin(\"x\"~op~\"=lhs.x;\");\n\t\tmixin(\"y\"~op~\"=lhs.y;\");\n\t\tmixin(\"z\"~op~\"=lhs.z;\");\n\t}\n}\n\nstruct Matrix(T){\n\timport std.conv;\n\tprivate T[][] data;\n\tthis(int w,int h){ data = new T[][](w,h);}\n\tthis(ref T[][] data_){ data = data_;}\n\tT opIndexAssign(T v, size_t x, size_t y){return data[x][y] = v;}\n\tT opIndexAssign(T v, Pos p){return opIndexAssign(v,p.x,p.y);}\n\tref T opIndex(size_t x, size_t y){return data[x][y];}\n\tref T opIndex(Pos p){return opIndex(p.x,p.y);}\n\tref T opCall(Pos p){return data[p.x][p.y];}\n\t@property auto W()const{return data.length;}\t\n\t@property auto H()const{return data[0].length;}\t\n\tauto X(int x){T[]res;foreach(y;0..H())res ~= data[x][y];return res; }\n\tauto Y(int y){T[]res;foreach(x;0..W())res ~= data[x][y];return res; }\n\tvoid setX(T[] vec, int x){foreach(int y,v;vec)data[x][y] = v; }\n\tvoid setY(T[] vec, int y){foreach(int x,v;vec)data[x][y] = v; }\n\tvoid toString(scope void delegate(const(char)[]) sink) const{\n\t\tforeach(y;0..H()) {\n\t\t\tforeach(x;0..W())sink(data[x][y].to!string);\n\t\t\tif(y != H()-1)sink(\"\\n\");\n\t\t}\n    }\n\tbool DFS(S)(const Pos[] nexts, S initState\n\t\t\t\t,bool delegate(Pos,ref S) dfsContinue\n\t\t\t\t,bool delegate(Pos[],S) searchNextSet){\n\t\tauto seeked = Matrix!bool(W(),H());\n\t\tvoid dfs(Pos p,ref Pos[] set,ref S state){ \n\t\t\tif(!p.inRange(W(),H())) return;\n\t\t\tif(seeked[p]) return;\n\t\t\tif(!dfsContinue(p,state))return;\n\t\t\tset ~= p;\n\t\t\tseeked[p] = true;\n\t\t\tforeach(n;nexts) dfs(p+n,set,state);\n\t\t}\n\t\tforeach(y;0..H()){\n\t\t\tforeach(x;0..W()){\n\t\t\t\tPos[] set;\n\t\t\t\tS state = initState;\n\t\t\t\tdfs(Pos(x,y),set,state);\n\t\t\t\tif(!searchNextSet(set,state)) return false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n\nauto  readAciiMap(int w,int h){ \n\timport std.stdio,std.string;\n\tauto M=new char[][](w,h);\n\tforeach(y;0..h) foreach(int x,c;readln().chomp) M[x][y] = c;\t\t\n\treturn Matrix!(char)(M);\n}\n\nauto  readMatrix(int w,int h){\n\timport std.stdio,std.string,std.conv;\n\tauto M=new int[][](w,h);\n\tforeach(y;0..h) foreach(int x,c;readln().split()) M[x][y] = c.to!int;\n\treturn Matrix!(int)(M);\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio,std.conv, std.algorithm, std.container,std.array,std.range,std.string,std.typecons,std.numeric,std.math,std.random,std.functional;\n\nvoid main(){\n\tint w,h;\n\twhile(read(w,h),w|h){\t\t\n\t\tauto land = readMatrix(w,h);\n\t\tauto seeked = Matrix!(bool)(w,h);\n\n\t\tvoid SEEK (Pos p,ref Pos[] seeking,ref char type){\n\t\t\tif(!p.inRange(w,h))return;\n\t\t\tif(seeked[p])return;\n\t\t\tif(land[p] == 'W' || land[p] == 'B') {\n\t\t\t\tif(type == '.') type = land[p];\n\t\t\t\telse if(type != land[p]) type = 'X';\n\t\t\t\treturn ;\n\t\t\t}\n\t\t\tseeking ~= p;\n\t\t\tseeked[p] = true;\n\t\t\tforeach(dpos;DPos) SEEK(p + dpos,seeking,type);\n\t\t}\n\n\t\tint B ,W;\n\t\tforeach(y;iota(h)){\n\t\t\tforeach(x;iota(w)){\n\t\t\t\tPos[] seeking;\n\t\t\t\tchar type = '.';\n\t\t\t\tSEEK(Pos(x,y),seeking,type);\n\t\t\t\tif(seeking.length == 0) continue;\n\t\t\t\tif(type == 'B') B += seeking.length;\n\t\t\t\tif(type == 'W') W += seeking.length;\n\t\t\t}\n\t\t}\n\t\twriteln(B,\" \",W);\n\t}\n}\n\n\n////////////////////////////////////LIB72//////////////////////////\nconst readMixin = q{ auto line = readln().split();foreach(i,ref arg; args){ if (i >= line.length) return;arg = line[i].to!(typeof(arg));}};\nvoid read(T...)  (auto ref T args){mixin(readMixin);}\nvoid readArray(T)(auto ref T args){mixin(readMixin);}\nint  read(){int n;read(n);return n;}\nconst Dx = [1,0,-1,0], Dy = [0,1,0,-1];\nconst DPos = [Pos(1,0),Pos(0,1),Pos(-1,0),Pos(0,-1)];\nvoid times(int n,void delegate() stmt){ foreach(i;iota(n))stmt();}\n\nauto dot(R1,R2)(R1 a,R2 b) { \n\tElementType!(R1) res=0;\n\tfor(;!a.empty&&!b.empty;a.popFront(),b.popFront())\n\t\tres+=a.front*b.front;\n\treturn res;\n}\nstruct infIota { \n\tint i=0;\n\tenum empty=false;\n\tint front(){return i;}\n\tvoid popFront(){i++;}\n}\nstruct Pos{ \n\tint x,y,z;\n\tbool inRange(int w,int h,int Z=1){\n\t\treturn x>=0 && y >= 0 && z >=0 && x < w && y < h && z < Z;\n\t}\n\tPos opBinary(string op)(Pos rhs) {\n\t\treturn Pos ( mixin( \"x\"~op~\"rhs.x\" ),\n\t\t\t\t\t mixin( \"y\"~op~\"rhs.y\" ),\n\t\t\t\t\t mixin( \"z\"~op~\"rhs.z\" ));\n\t}\n\tvoid opOpAssign(string op)(Pos lhs) {\n\t\tmixin(\"x\"~op~\"=lhs.x;\");\n\t\tmixin(\"y\"~op~\"=lhs.y;\");\n\t\tmixin(\"z\"~op~\"=lhs.z;\");\n\t}\n}\nstruct Matrix(T){\n\tprivate T[][] data;\n\tthis(int w,int h){ data = new T[][](w,h);}\n\tthis(ref T[][] data_){ data = data_;}\n\tT opIndexAssign(T v, size_t x, size_t y){return data[x][y] = v;}\n\tT opIndexAssign(T v, Pos p){return opIndexAssign(v,p.x,p.y);}\n\tT opIndex(size_t x, size_t y){return data[x][y];}\n\tT opIndex(Pos p){return opIndex(p.x,p.y);}\n\tref T opCall(Pos p){return data[p.x][p.y];}\n\tauto W()const{return data.length;}\t\n\tauto H()const{return data[0].length;}\t\n\tvoid toString(scope void delegate(const(char)[]) sink) const{\n\t\tforeach(y;iota(H())) {\n\t\t\tforeach(x;iota(W()))sink(data[x][y].to!string);\n\t\t\tif(y != H()-1)sink(\"\\n\");\n\t\t}\n    }\n}\nauto readMatrix(int w,int h){ \n\tauto M=new char[][](w,h);\n\tforeach(y;iota(h)) foreach(int x,c;readln().chomp) M[x][y] = c;\t\t\n\treturn Matrix!(char)(M);\n}\n\n////////////////////////////////////LIB72//////////////////////////\n\nvoid rep(int[] ms,void delegate(int,int) f){\n\tfor(int i0;i0<ms[0];i0++) \n\t\tfor(int i1;i1<ms[1];i1++) \n\t\t\tf(i0,i1);\n}\n//[3,4,5,6].REP!((i,j,k,l)=>{});"
  },
  {
    "language": "D",
    "code": "import std.stdio,std.conv, std.algorithm, std.container,std.array,std.range,std.string,std.typecons,std.numeric,std.math,std.random,std.functional;\n\nvoid main(){\n\tfor(int w,h ; read(w,h),w|h ; ){\t\t\n\t\tauto land = readAciiMap(w,h);\n\t\tint B,W;\n\t\tland.DFS!(char)( DPos , '.'\n\t\t\t,(Pos p,ref char state){\n\t\t\t\tif(land[p] == 'W' || land[p] == 'B'){\n\t\t\t\t\tif(state == '.') state = land[p];\n\t\t\t\t\telse if(state != land[p] ) state = 'X';\n\t\t\t\t\treturn false;\n\t\t\t\t} \n\t\t\t\treturn true;\n\t\t\t},(Pos[] set,char state){\n\t\t\t\tif(state == 'B') B += set.length;\n\t\t\t\tif(state == 'W') W += set.length;\n\t\t\t\treturn true;\n\t\t\t});\n\t\twriteln(B,\" \",W);\n\t}\n}\n\n\nint   read(){int n;read(n);return n;}\nvoid  read(T...)  (auto ref T args){mixin(readMixin);}\nvoid  readArray(T)(auto ref T args){mixin(readMixin);}\nconst readMixin = q{ \n\tauto line = readln().split();\n\tforeach(i,ref arg; args){ \n\t\tif (i >= line.length) return;\n\t\targ = line[i].to!(typeof(arg));\n\t}\n};\nvoid times(int n,void delegate() stmt){ foreach(i;0..n)stmt();}\nvoid Swap(T)(ref T a,ref T b){T t = a;a = b;b = t;}\n\nconst DPos = [Pos(1,0),Pos(0,1),Pos(-1,0),Pos(0,-1)];\nstruct Pos{ \n\tint x,y,z;\n\tbool inRange(int w,int h,int Z=1){\n\t\treturn x>=0 && y >= 0 && z >=0 && x < w && y < h && z < Z;\n\t}\n\tPos opBinary(string op)(Pos rhs) {\n\t\treturn Pos ( mixin( \"x\"~op~\"rhs.x\" ),\n\t\t\t\t\t mixin( \"y\"~op~\"rhs.y\" ),\n\t\t\t\t\tmixin( \"z\"~op~\"rhs.z\" ));\n\t}\n\tvoid opOpAssign(string op)(Pos lhs) {\n\t\tmixin(\"x\"~op~\"=lhs.x;\");\n\t\tmixin(\"y\"~op~\"=lhs.y;\");\n\t\tmixin(\"z\"~op~\"=lhs.z;\");\n\t}\n}\n\nstruct Matrix(T){\n\timport std.conv;\n\tprivate T[][] data;\n\tthis(int w,int h){ data = new T[][](w,h);}\n\tthis(ref T[][] data_){ data = data_;}\n\tT opIndexAssign(T v, size_t x, size_t y){return data[x][y] = v;}\n\tT opIndexAssign(T v, Pos p){return opIndexAssign(v,p.x,p.y);}\n\tref T opIndex(size_t x, size_t y){return data[x][y];}\n\tref T opIndex(Pos p){return opIndex(p.x,p.y);}\n\tref T opCall(Pos p){return data[p.x][p.y];}\n\t@property int W()const{return cast(int)data.length;}\t\n\t@property int H()const{return cast(int)data[0].length;}\t\n\tauto X(int x){T[]res;foreach(y;0..H())res ~= data[x][y];return res; }\n\tauto Y(int y){T[]res;foreach(x;0..W())res ~= data[x][y];return res; }\n\tvoid setX(T[] vec, int x){foreach(int y,v;vec)data[x][y] = v; }\n\tvoid setY(T[] vec, int y){foreach(int x,v;vec)data[x][y] = v; }\n\tvoid toString(scope void delegate(const(char)[]) sink) const{\n\t\tforeach(y;0..H()) {\n\t\t\tforeach(x;0..W())sink(data[x][y].to!string);\n\t\t\tif(y != H()-1)sink(\"\\n\");\n\t\t}\n    }\n\tbool DFS(S)(const Pos[] nexts, S initState\n\t\t\t\t,bool delegate(Pos,ref S) dfsContinue\n\t\t\t\t,bool delegate(Pos[],S) searchNextSet){\n\t\tauto seeked = Matrix!bool(W(),H());\n\t\tvoid dfs(Pos p,ref Pos[] set,ref S state){ \n\t\t\tif(!p.inRange(W(),H())) return;\n\t\t\tif(seeked[p]) return;\n\t\t\tif(!dfsContinue(p,state))return;\n\t\t\tset ~= p;\n\t\t\tseeked[p] = true;\n\t\t\tforeach(n;nexts) dfs(p+n,set,state);\n\t\t}\n\t\tforeach(y;0..H()){\n\t\t\tforeach(x;0..W()){\n\t\t\t\tPos[] set;\n\t\t\t\tS state = initState;\n\t\t\t\tdfs(Pos(x,y),set,state);\n\t\t\t\tif(!searchNextSet(set,state)) return false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n\nauto  readAciiMap(int w,int h){ \n\timport std.stdio,std.string;\n\tauto M=new char[][](w,h);\n\tforeach(y;0..h) foreach(int x,c;readln().chomp) M[x][y] = c;\t\t\n\treturn Matrix!(char)(M);\n}\n\nauto  readMatrix(int w,int h){\n\timport std.stdio,std.string,std.conv;\n\tauto M=new int[][](w,h);\n\tforeach(y;0..h) foreach(int x,c;readln().split()) M[x][y] = c.to!int;\n\treturn Matrix!(int)(M);\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio,std.conv, std.algorithm, std.container,std.array,std.range,std.string,std.typecons,std.numeric,std.math,std.random,std.functional;\n\nvoid main(){\n\tint w,h;\n\twhile(read(w,h),w|h){\t\t\n\t\tauto land = readMatrix(w,h);\n\t\tauto seeked = Matrix!(bool)(w,h);\n\n\t\tvoid SEEK (Pos p,ref Pos[] seeking,ref char type){\n\t\t\tif(!p.inRange(w,h))return;\n\t\t\tif(seeked[p])return;\n\t\t\tif(land[p] == 'W' || land[p] == 'B') {\n\t\t\t\tif(type == '.') type = land[p];\n\t\t\t\telse if(type != land[p]) type = 'X';\n\t\t\t\treturn ;\n\t\t\t}\n\t\t\tseeking ~= p;\n\t\t\tseeked[p] = true;\n\t\t\tforeach(dpos;DPos) SEEK(p + dpos,seeking,type);\n\t\t}\n\n\t\tint B ,W;\n\t\tforeach(y;iota(h)){\n\t\t\tforeach(x;iota(w)){\n\t\t\t\tPos[] seeking;\n\t\t\t\tchar type = '.';\n\t\t\t\tSEEK(Pos(x,y),seeking,type);\n\t\t\t\tif(seeking.length == 0) continue;\n\t\t\t\tif(type == 'B') B += seeking.length;\n\t\t\t\tif(type == 'W') W += seeking.length;\n\t\t\t}\n\t\t}\n\t\twriteln(B,\" \",W);\n\t}\n}\n\n\n////////////////////////////////////LIB72//////////////////////////\nconst readMixin = q{ auto line = readln().split();foreach(i,ref arg; args){ if (i >= line.length) return;arg = line[i].to!(typeof(arg));}};\nvoid read(T...)  (auto ref T args){mixin(readMixin);}\nvoid readArray(T)(auto ref T args){mixin(readMixin);}\nint  read(){int n;read(n);return n;}\nconst Dx = [1,0,-1,0], Dy = [0,1,0,-1];\nconst DPos = [Pos(1,0),Pos(0,1),Pos(-1,0),Pos(0,-1)];\nvoid times(int n,void delegate() stmt){ foreach(i;iota(n))stmt();}\n\nauto dot(R1,R2)(R1 a,R2 b) { \n\tElementType!(R1) res=0;\n\tfor(;!a.empty&&!b.empty;a.popFront(),b.popFront())\n\t\tres+=a.front*b.front;\n\treturn res;\n}\nstruct infIota { \n\tint i=0;\n\tenum empty=false;\n\tint front(){return i;}\n\tvoid popFront(){i++;}\n}\nstruct Pos{ \n\tint x,y,z;\n\tbool inRange(int w,int h,int Z=1){\n\t\treturn x>=0 && y >= 0 && z >=0 && x < w && y < h && z < Z;\n\t}\n\tPos opBinary(string op)(Pos rhs) {\n\t\treturn Pos ( mixin( \"x\"~op~\"rhs.x\" ),\n\t\t\t\t\t mixin( \"y\"~op~\"rhs.y\" ),\n\t\t\t\t\t mixin( \"z\"~op~\"rhs.z\" ));\n\t}\n\tvoid opOpAssign(string op)(Pos lhs) {\n\t\tmixin(\"x\"~op~\"=lhs.x;\");\n\t\tmixin(\"y\"~op~\"=lhs.y;\");\n\t\tmixin(\"z\"~op~\"=lhs.z;\");\n\t}\n}\nstruct Matrix(T){\n\tprivate T[][] data;\n\tthis(int w,int h){ data = new T[][](w,h);}\n\tthis(ref T[][] data_){ data = data_;}\n\tT opIndexAssign(T v, size_t x, size_t y){return data[x][y] = v;}\n\tT opIndexAssign(T v, Pos p){return opIndexAssign(v,p.x,p.y);}\n\tT opIndex(size_t x, size_t y){return data[x][y];}\n\tT opIndex(Pos p){return opIndex(p.x,p.y);}\n\tref T opCall(Pos p){return data[p.x][p.y];}\n\tint W()const{return data.length;}\t\n\tint H()const{return data[0].length;}\t\n\tvoid toString(scope void delegate(const(char)[]) sink) const{\n\t\tforeach(y;iota(H())) {\n\t\t\tforeach(x;iota(W()))sink(data[x][y].to!string);\n\t\t\tif(y != H()-1)sink(\"\\n\");\n\t\t}\n    }\n}\nauto readMatrix(int w,int h){ \n\tauto M=new char[][](w,h);\n\tforeach(y;iota(h)) foreach(int x,c;readln().chomp) M[x][y] = c;\t\t\n\treturn Matrix!(char)(M);\n}\n\n////////////////////////////////////LIB72//////////////////////////\n\nvoid rep(int[] ms,void delegate(int,int) f){\n\tfor(int i0;i0<ms[0];i0++) \n\t\tfor(int i1;i1<ms[1];i1++) \n\t\t\tf(i0,i1);\n}\n//[3,4,5,6].REP!((i,j,k,l)=>{});"
  },
  {
    "language": "D",
    "code": "import std.stdio,std.conv, std.algorithm, std.container,std.array,std.range,std.string,std.typecons,std.numeric,std.math,std.random,std.functional;\n\nvoid main(){\n\tfor(int w,h ; read(w,h),w|h ; ){\t\t\n\t\tauto land = readAciiMap(w,h);\n\t\tint B,W;\n\t\tland.DFS!(char)( DPos , '.'\n\t\t\t,(Pos p,ref char state){\n\t\t\t\tif(land[p] == 'W' || land[p] == 'B'){\n\t\t\t\t\tif(state == '.') state = land[p];\n\t\t\t\t\telse if(state != land[p] ) state = 'X';\n\t\t\t\t\treturn false;\n\t\t\t\t} \n\t\t\t\treturn true;\n\t\t\t},(Pos[] set,char state){\n\t\t\t\tif(state == 'B') B += set.length;\n\t\t\t\tif(state == 'W') W += set.length;\n\t\t\t\treturn true;\n\t\t\t});\n\t\twriteln(B,\" \",W);\n\t}\n}\n\n\nint   read(){int n;read(n);return n;}\nvoid  read(T...)  (auto ref T args){mixin(readMixin);}\nvoid  readArray(T)(auto ref T args){mixin(readMixin);}\nconst readMixin = q{ \n\tauto line = readln().split();\n\tforeach(i,ref arg; args){ \n\t\tif (i >= line.length) return;\n\t\targ = line[i].to!(typeof(arg));\n\t}\n};\nvoid times(int n,void delegate() stmt){ foreach(i;0..n)stmt();}\nvoid Swap(T)(ref T a,ref T b){T t = a;a = b;b = t;}\n\nconst DPos = [Pos(1,0),Pos(0,1),Pos(-1,0),Pos(0,-1)];\nstruct Pos{ \n\tint x,y,z;\n\tbool inRange(int w,int h,int Z=1){\n\t\treturn x>=0 && y >= 0 && z >=0 && x < w && y < h && z < Z;\n\t}\n\tPos opBinary(string op)(Pos rhs) {\n\t\treturn Pos ( mixin( \"x\"~op~\"rhs.x\" ),\n\t\t\t\t\t mixin( \"y\"~op~\"rhs.y\" ),\n\t\t\t\t\tmixin( \"z\"~op~\"rhs.z\" ));\n\t}\n\tvoid opOpAssign(string op)(Pos lhs) {\n\t\tmixin(\"x\"~op~\"=lhs.x;\");\n\t\tmixin(\"y\"~op~\"=lhs.y;\");\n\t\tmixin(\"z\"~op~\"=lhs.z;\");\n\t}\n}\n\nstruct Matrix(T){\n\timport std.conv;\n\tprivate T[][] data;\n\tthis(int w,int h){ data = new T[][](w,h);}\n\tthis(ulong w,ulong h){ data = new T[][](w,h);}\n\tthis(ref T[][] data_){ data = data_;}\n\tT opIndexAssign(T v, size_t x, size_t y){return data[x][y] = v;}\n\tT opIndexAssign(T v, Pos p){return opIndexAssign(v,p.x,p.y);}\n\tref T opIndex(size_t x, size_t y){return data[x][y];}\n\tref T opIndex(Pos p){return opIndex(p.x,p.y);}\n\tref T opCall(Pos p){return data[p.x][p.y];}\n\t@property auto W()const{return cast(int)data.length;}\t\n\t@property auto H()const{return cast(int)data[0].length;}\t\n\tauto X(int x){T[]res;foreach(y;0..H())res ~= data[x][y];return res; }\n\tauto Y(int y){T[]res;foreach(x;0..W())res ~= data[x][y];return res; }\n\tvoid setX(T[] vec, int x){foreach(int y,v;vec)data[x][y] = v; }\n\tvoid setY(T[] vec, int y){foreach(int x,v;vec)data[x][y] = v; }\n\tvoid toString(scope void delegate(const(char)[]) sink) const{\n\t\tforeach(y;0..H()) {\n\t\t\tforeach(x;0..W())sink(data[x][y].to!string);\n\t\t\tif(y != H()-1)sink(\"\\n\");\n\t\t}\n    }\n\tbool DFS(S)(const Pos[] nexts, S initState\n\t\t\t\t,bool delegate(Pos,ref S) dfsContinue\n\t\t\t\t,bool delegate(Pos[],S) searchNextSet){\n\t\tauto seeked = Matrix!bool(W(),H());\n\t\tvoid dfs(Pos p,ref Pos[] set,ref S state){ \n\t\t\tif(!p.inRange(W(),H())) return;\n\t\t\tif(seeked[p]) return;\n\t\t\tif(!dfsContinue(p,state))return;\n\t\t\tset ~= p;\n\t\t\tseeked[p] = true;\n\t\t\tforeach(n;nexts) dfs(p+n,set,state);\n\t\t}\n\t\tforeach(y;0..H()){\n\t\t\tforeach(x;0..W()){\n\t\t\t\tPos[] set;\n\t\t\t\tS state = initState;\n\t\t\t\tdfs(Pos(x,y),set,state);\n\t\t\t\tif(!searchNextSet(set,state)) return false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n\nauto  readAciiMap(int w,int h){ \n\timport std.stdio,std.string;\n\tauto M=new char[][](w,h);\n\tforeach(y;0..h) foreach(int x,c;readln().chomp) M[x][y] = c;\t\t\n\treturn Matrix!(char)(M);\n}\n\nauto  readMatrix(int w,int h){\n\timport std.stdio,std.string,std.conv;\n\tauto M=new int[][](w,h);\n\tforeach(y;0..h) foreach(int x,c;readln().split()) M[x][y] = c.to!int;\n\treturn Matrix!(int)(M);\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio,std.conv, std.algorithm, std.container,std.array,std.range,std.string,std.typecons,std.numeric,std.math,std.random,std.functional;\n\nvoid main(){\n\tfor(int w,h ; read(w,h),w|h ; ){\t\t\n\t\tauto land = readAciiMap(w,h);\n\t\tint B,W;\n\t\tland.DFS!(char)( DPos , '.'\n\t\t\t,(Pos p,ref char state){\n\t\t\t\tif(land[p] == 'W' || land[p] == 'B'){\n\t\t\t\t\tif(state == '.') state = land[p];\n\t\t\t\t\telse if(state != land[p] ) state = 'X';\n\t\t\t\t\treturn false;\n\t\t\t\t} \n\t\t\t\treturn true;\n\t\t\t},(Pos[] set,char state){\n\t\t\t\tif(state == 'B') B += set.length;\n\t\t\t\tif(state == 'W') W += set.length;\n\t\t\t\treturn true;\n\t\t\t});\n\t\twriteln(B,\" \",W);\n\t}\n}\n\n\nint   read(){int n;read(n);return n;}\nvoid  read(T...)  (auto ref T args){mixin(readMixin);}\nvoid  readArray(T)(auto ref T args){mixin(readMixin);}\nconst readMixin = q{ \n\tauto line = readln().split();\n\tforeach(i,ref arg; args){ \n\t\tif (i >= line.length) return;\n\t\targ = line[i].to!(typeof(arg));\n\t}\n};\nvoid times(int n,void delegate() stmt){ foreach(i;0..n)stmt();}\nvoid Swap(T)(ref T a,ref T b){T t = a;a = b;b = t;}\n\nconst DPos = [Pos(1,0),Pos(0,1),Pos(-1,0),Pos(0,-1)];\nstruct Pos{ \n\tint x,y,z;\n\tbool inRange(int w,int h,int Z=1){\n\t\treturn x>=0 && y >= 0 && z >=0 && x < w && y < h && z < Z;\n\t}\n\tPos opBinary(string op)(Pos rhs) {\n\t\treturn Pos ( mixin( \"x\"~op~\"rhs.x\" ),\n\t\t\t\t\t mixin( \"y\"~op~\"rhs.y\" ),\n\t\t\t\t\tmixin( \"z\"~op~\"rhs.z\" ));\n\t}\n\tvoid opOpAssign(string op)(Pos lhs) {\n\t\tmixin(\"x\"~op~\"=lhs.x;\");\n\t\tmixin(\"y\"~op~\"=lhs.y;\");\n\t\tmixin(\"z\"~op~\"=lhs.z;\");\n\t}\n}\n\nstruct Matrix(T){\n\timport std.conv;\n\tprivate T[][] data;\n\tthis(int w,int h){ data = new T[][](w,h);}\n\tthis(ref T[][] data_){ data = data_;}\n\tT opIndexAssign(T v, size_t x, size_t y){return data[x][y] = v;}\n\tT opIndexAssign(T v, Pos p){return opIndexAssign(v,p.x,p.y);}\n\tref T opIndex(size_t x, size_t y){return data[x][y];}\n\tref T opIndex(Pos p){return opIndex(p.x,p.y);}\n\tref T opCall(Pos p){return data[p.x][p.y];}\n\tauto W()const{return data.length;}\t\n\tauto H()const{return data[0].length;}\t\n\tauto X(int x){T[]res;foreach(y;0..H())res ~= data[x][y];return res; }\n\tauto Y(int y){T[]res;foreach(x;0..W())res ~= data[x][y];return res; }\n\tvoid setX(T[] vec, int x){foreach(int y,v;vec)data[x][y] = v; }\n\tvoid setY(T[] vec, int y){foreach(int x,v;vec)data[x][y] = v; }\n\tvoid toString(scope void delegate(const(char)[]) sink) const{\n\t\tforeach(y;0..H()) {\n\t\t\tforeach(x;0..W())sink(data[x][y].to!string);\n\t\t\tif(y != H()-1)sink(\"\\n\");\n\t\t}\n    }\n\tbool DFS(S)(const Pos[] nexts, S initState\n\t\t\t\t,bool delegate(Pos,ref S) dfsContinue\n\t\t\t\t,bool delegate(Pos[],S) searchNextSet){\n\t\tauto seeked = Matrix!bool(W(),H());\n\t\tvoid dfs(Pos p,ref Pos[] set,ref S state){ \n\t\t\tif(!p.inRange(W(),H())) return;\n\t\t\tif(seeked[p]) return;\n\t\t\tif(!dfsContinue(p,state))return;\n\t\t\tset ~= p;\n\t\t\tseeked[p] = true;\n\t\t\tforeach(n;nexts) dfs(p+n,set,state);\n\t\t}\n\t\tforeach(y;0..H()){\n\t\t\tforeach(x;0..W()){\n\t\t\t\tPos[] set;\n\t\t\t\tS state = initState;\n\t\t\t\tdfs(Pos(x,y),set,state);\n\t\t\t\tif(!searchNextSet(set,state)) return false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n\nauto  readAciiMap(int w,int h){ \n\timport std.stdio,std.string;\n\tauto M=new char[][](w,h);\n\tforeach(y;0..h) foreach(int x,c;readln().chomp) M[x][y] = c;\t\t\n\treturn Matrix!(char)(M);\n}\n\nauto  readMatrix(int w,int h){\n\timport std.stdio,std.string,std.conv;\n\tauto M=new int[][](w,h);\n\tforeach(y;0..h) foreach(int x,c;readln().split()) M[x][y] = c.to!int;\n\treturn Matrix!(int)(M);\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio,std.conv, std.algorithm, std.container,std.array,std.range,std.string,std.typecons,std.numeric,std.math,std.random,std.functional;\n\nvoid main(){\n\tfor(int w,h ; read(w,h),w|h ; ){\t\t\n\t\tauto land = readAciiMap(w,h);\n\t\tint B,W;\n\t\tland.DFS!(char)( DPos , '.'\n\t\t\t,(Pos p,ref char state){\n\t\t\t\tif(land[p] == 'W' || land[p] == 'B'){\n\t\t\t\t\tif(state == '.') state = land[p];\n\t\t\t\t\telse if(state != land[p] ) state = 'X';\n\t\t\t\t\treturn false;\n\t\t\t\t} \n\t\t\t\treturn true;\n\t\t\t},(Pos[] set,char state){\n\t\t\t\tif(state == 'B') B += set.length;\n\t\t\t\tif(state == 'W') W += set.length;\n\t\t\t\treturn true;\n\t\t\t});\n\t\twriteln(B,\" \",W);\n\t}\n}\n\n\nint   read(){int n;read(n);return n;}\nvoid  read(T...)  (auto ref T args){mixin(readMixin);}\nvoid  readArray(T)(auto ref T args){mixin(readMixin);}\nconst readMixin = q{ \n\tauto line = readln().split();\n\tforeach(i,ref arg; args){ \n\t\tif (i >= line.length) return;\n\t\targ = line[i].to!(typeof(arg));\n\t}\n};\nvoid times(int n,void delegate() stmt){ foreach(i;0..n)stmt();}\nvoid Swap(T)(ref T a,ref T b){T t = a;a = b;b = t;}\n\nconst DPos = [Pos(1,0),Pos(0,1),Pos(-1,0),Pos(0,-1)];\nstruct Pos{ \n\tint x,y,z;\n\tthis(int x_ =0,int y_=0,int z=0){x=_x;y=y_;z=z_;}\n\tthis(ulong x_ =0,ulong y_=0,ulong z_=0){x=cast(int)_x;y=cast(int)y_;z=cast(int)z_;}\n\tbool inRange(int w,int h,int Z=1){\n\t\treturn x>=0 && y >= 0 && z >=0 && x < w && y < h && z < Z;\n\t}\n\tPos opBinary(string op)(Pos rhs) {\n\t\treturn Pos ( mixin( \"x\"~op~\"rhs.x\" ),\n\t\t\t\t\t mixin( \"y\"~op~\"rhs.y\" ),\n\t\t\t\t\tmixin( \"z\"~op~\"rhs.z\" ));\n\t}\n\tvoid opOpAssign(string op)(Pos lhs) {\n\t\tmixin(\"x\"~op~\"=lhs.x;\");\n\t\tmixin(\"y\"~op~\"=lhs.y;\");\n\t\tmixin(\"z\"~op~\"=lhs.z;\");\n\t}\n}\n\nstruct Matrix(T){\n\timport std.conv;\n\tprivate T[][] data;\n\tthis(int w,int h){ data = new T[][](w,h);}\n\tthis(ref T[][] data_){ data = data_;}\n\tT opIndexAssign(T v, size_t x, size_t y){return data[x][y] = v;}\n\tT opIndexAssign(T v, Pos p){return opIndexAssign(v,p.x,p.y);}\n\tref T opIndex(size_t x, size_t y){return data[x][y];}\n\tref T opIndex(Pos p){return opIndex(p.x,p.y);}\n\tref T opCall(Pos p){return data[p.x][p.y];}\n\t@property auto W()const{return data.length;}\t\n\t@property auto H()const{return data[0].length;}\t\n\tauto X(int x){T[]res;foreach(y;0..H())res ~= data[x][y];return res; }\n\tauto Y(int y){T[]res;foreach(x;0..W())res ~= data[x][y];return res; }\n\tvoid setX(T[] vec, int x){foreach(int y,v;vec)data[x][y] = v; }\n\tvoid setY(T[] vec, int y){foreach(int x,v;vec)data[x][y] = v; }\n\tvoid toString(scope void delegate(const(char)[]) sink) const{\n\t\tforeach(y;0..H()) {\n\t\t\tforeach(x;0..W())sink(data[x][y].to!string);\n\t\t\tif(y != H()-1)sink(\"\\n\");\n\t\t}\n    }\n\tbool DFS(S)(const Pos[] nexts, S initState\n\t\t\t\t,bool delegate(Pos,ref S) dfsContinue\n\t\t\t\t,bool delegate(Pos[],S) searchNextSet){\n\t\tauto seeked = Matrix!bool(W(),H());\n\t\tvoid dfs(Pos p,ref Pos[] set,ref S state){ \n\t\t\tif(!p.inRange(W(),H())) return;\n\t\t\tif(seeked[p]) return;\n\t\t\tif(!dfsContinue(p,state))return;\n\t\t\tset ~= p;\n\t\t\tseeked[p] = true;\n\t\t\tforeach(n;nexts) dfs(p+n,set,state);\n\t\t}\n\t\tforeach(y;0..H()){\n\t\t\tforeach(x;0..W()){\n\t\t\t\tPos[] set;\n\t\t\t\tS state = initState;\n\t\t\t\tdfs(Pos(x,y),set,state);\n\t\t\t\tif(!searchNextSet(set,state)) return false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n\nauto  readAciiMap(int w,int h){ \n\timport std.stdio,std.string;\n\tauto M=new char[][](w,h);\n\tforeach(y;0..h) foreach(int x,c;readln().chomp) M[x][y] = c;\t\t\n\treturn Matrix!(char)(M);\n}\n\nauto  readMatrix(int w,int h){\n\timport std.stdio,std.string,std.conv;\n\tauto M=new int[][](w,h);\n\tforeach(y;0..h) foreach(int x,c;readln().split()) M[x][y] = c.to!int;\n\treturn Matrix!(int)(M);\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.conv;\nimport std.string;\nimport std.typecons;\nimport std.algorithm;\nimport std.array;\nimport std.range;\nimport std.math;\nimport std.container;\n\nvoid main()\n{\n\twhile (1) {\n\t\tauto x = readln.chomp.split.map!(to!int);\n\t\tif (!x[0]) break;\n\t\tauto area = new char[][](x[1], x[0]);\n\t\tforeach (i; 0..x[1]) {\n\t\t\tarea[i] = readln.chomp.map!(to!char).array;\n\t\t}\n\t\tint num[2];\n\t\tauto hu = ['W', 'B'];\n\n\t\tvoid solve(int i, int j, int type) {\n\t\t\tif (area[i][j] == '.') {\n\t\t\t\tnum[type]++;\n\t\t\t\tarea[i][j] = (hu[type] + 32).to!char;\n\t\t\t} else if (area[i][j] == hu[!type] + 32) {\n\t\t\t\tnum[(!type).to!int]--;\n\t\t\t\tarea[i][j] = 'd';\n\t\t\t}\n\t\t\tforeach (a; iota(-1, 2, 2)) {\n\t\t\t\tif (i + a >= 0 && i + a < x[1]) {\n\t\t\t\t\tif (area[i+a][j] != 'W' && area[i+a][j] != 'B' && area[i+a][j] != (hu[type] + 32).to!char && area[i+a][j] != 'd') {\n\t\t\t\t\t\tsolve(i + a, j, type);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (j + a >= 0 && j + a < x[0]) {\n\t\t\t\t\tif (area[i][j+a] != 'W' && area[i][j+a] != 'B' && area[i][j+a] != (hu[type] + 32).to!char && area[i][j+a] != 'd') {\n\t\t\t\t\t\tsolve(i, j + a, type);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tforeach (i; 0..x[1]) {\n\t\t\tforeach (j; 0..x[0]) {\n\t\t\t\tif (area[i][j] != 'W' && area[i][j] != 'B') continue;\n\t\t\t\tif (area[i][j] == 'W') solve(i, j, 0);\n\t\t\t\telse solve(i, j, 1);\n\t\t\t}\n\t\t}\n\t\twriteln(num[1], \" \", num[0]);\n\t}\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.random;\nimport std.regex;\nimport std.typecons;\n\nint H, W;\nstring[] F;\nbool input() {\n    scanf(\"%d %d\\n\", &W, &H);\n    if (W == 0 && H == 0) return false;\n    F = new string[H];\n    foreach (i; 0 .. H) {\n        F[i] = readln.chomp;\n    }\n    return true;\n}\n\nconst dy = [-1, 0, 1, 0],\n      dx = [0, -1, 0, 1];\n\nvoid solve() {\n    auto M = new int[][](H, W);\n    int ans_b, ans_w;\n\n    void fill(int y, int x, int v) {\n        struct P {\n            int y, x;\n        }\n        int f = 0;\n        auto Q = new DList!P(P(y, x));\n        while (!Q.empty) {\n            P c = Q.front; Q.removeFront;\n            foreach (i; 0 .. 4) {\n                int ny = c.y + dy[i],\n                    nx = c.x + dx[i];\n                if (ny < 0 || ny >= H) continue;\n                if (nx < 0 || nx >= W) continue;\n                if (M[ny][nx] & v) continue;\n                if (F[ny][nx] != '.') continue;\n                M[ny][nx] |= v;\n                Q.insert(P(ny, nx));\n            }\n        }\n    }\n\n    foreach (i; 0 .. H) {\n        foreach (j; 0 .. W) {\n            char c = F[i][j];\n            if (c == 'B') {\n                fill(i, j, 1);\n            } else if (c == 'W') {\n                fill(i, j, 2);\n            }\n        }\n    }\n    foreach (i; 0 .. H) {\n        foreach (j; 0 .. W) {\n            if (F[i][j] == '.' && M[i][j] == 1) {\n                ans_b++;\n            } else if (F[i][j] == '.' && M[i][j] == 2) {\n                ans_w++;\n            }\n        }\n    }\n    writeln(ans_b, \" \", ans_w);\n}\n\nvoid main() {\n    while (input) solve;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio,std.conv, std.algorithm, std.container,std.array,std.range,std.string,std.typecons,std.numeric,std.math,std.random,std.functional;\n\nvoid main(){\n\tfor(int w,h ; read(w,h),w|h ; ){\t\t\n\t\tauto land = readAciiMap(w,h);\n\t\tint B,W;\n\t\tland.DFS!(char)( DPos , '.'\n\t\t\t,(Pos p,ref char state){\n\t\t\t\tif(land[p] == 'W' || land[p] == 'B'){\n\t\t\t\t\tif(state == '.') state = land[p];\n\t\t\t\t\telse if(state != land[p] ) state = 'X';\n\t\t\t\t\treturn false;\n\t\t\t\t} \n\t\t\t\treturn true;\n\t\t\t},(Pos[] set,char state){\n\t\t\t\tif(state == 'B') B += set.length;\n\t\t\t\tif(state == 'W') W += set.length;\n\t\t\t\treturn true;\n\t\t\t});\n\t\twriteln(B,\" \",W);\n\t}\n}\n\n\nint   read(){int n;read(n);return n;}\nvoid  read(T...)  (auto ref T args){mixin(readMixin);}\nvoid  readArray(T)(auto ref T args){mixin(readMixin);}\nconst readMixin = q{ \n\tauto line = readln().split();\n\tforeach(i,ref arg; args){ \n\t\tif (i >= line.length) return;\n\t\targ = line[i].to!(typeof(arg));\n\t}\n};\nvoid times(int n,void delegate() stmt){ foreach(i;0..n)stmt();}\nvoid Swap(T)(ref T a,ref T b){T t = a;a = b;b = t;}\n\nconst DPos = [Pos(1,0),Pos(0,1),Pos(-1,0),Pos(0,-1)];\nstruct Pos{ \n\tint x,y,z;\n\tthis(int x_ =0,int y_=0,int z=0){x=_x;y=y_;z=z_;}\n\tthis(ulong x_ =0,ulong y_=0,ulong z=0){x=cast(int)_x;y=cast(int)y_;z=cast(int)z_;}\n\tbool inRange(int w,int h,int Z=1){\n\t\treturn x>=0 && y >= 0 && z >=0 && x < w && y < h && z < Z;\n\t}\n\tPos opBinary(string op)(Pos rhs) {\n\t\treturn Pos ( mixin( \"x\"~op~\"rhs.x\" ),\n\t\t\t\t\t mixin( \"y\"~op~\"rhs.y\" ),\n\t\t\t\t\tmixin( \"z\"~op~\"rhs.z\" ));\n\t}\n\tvoid opOpAssign(string op)(Pos lhs) {\n\t\tmixin(\"x\"~op~\"=lhs.x;\");\n\t\tmixin(\"y\"~op~\"=lhs.y;\");\n\t\tmixin(\"z\"~op~\"=lhs.z;\");\n\t}\n}\n\nstruct Matrix(T){\n\timport std.conv;\n\tprivate T[][] data;\n\tthis(int w,int h){ data = new T[][](w,h);}\n\tthis(ref T[][] data_){ data = data_;}\n\tT opIndexAssign(T v, size_t x, size_t y){return data[x][y] = v;}\n\tT opIndexAssign(T v, Pos p){return opIndexAssign(v,p.x,p.y);}\n\tref T opIndex(size_t x, size_t y){return data[x][y];}\n\tref T opIndex(Pos p){return opIndex(p.x,p.y);}\n\tref T opCall(Pos p){return data[p.x][p.y];}\n\t@property auto W()const{return data.length;}\t\n\t@property auto H()const{return data[0].length;}\t\n\tauto X(int x){T[]res;foreach(y;0..H())res ~= data[x][y];return res; }\n\tauto Y(int y){T[]res;foreach(x;0..W())res ~= data[x][y];return res; }\n\tvoid setX(T[] vec, int x){foreach(int y,v;vec)data[x][y] = v; }\n\tvoid setY(T[] vec, int y){foreach(int x,v;vec)data[x][y] = v; }\n\tvoid toString(scope void delegate(const(char)[]) sink) const{\n\t\tforeach(y;0..H()) {\n\t\t\tforeach(x;0..W())sink(data[x][y].to!string);\n\t\t\tif(y != H()-1)sink(\"\\n\");\n\t\t}\n    }\n\tbool DFS(S)(const Pos[] nexts, S initState\n\t\t\t\t,bool delegate(Pos,ref S) dfsContinue\n\t\t\t\t,bool delegate(Pos[],S) searchNextSet){\n\t\tauto seeked = Matrix!bool(W(),H());\n\t\tvoid dfs(Pos p,ref Pos[] set,ref S state){ \n\t\t\tif(!p.inRange(W(),H())) return;\n\t\t\tif(seeked[p]) return;\n\t\t\tif(!dfsContinue(p,state))return;\n\t\t\tset ~= p;\n\t\t\tseeked[p] = true;\n\t\t\tforeach(n;nexts) dfs(p+n,set,state);\n\t\t}\n\t\tforeach(y;0..H()){\n\t\t\tforeach(x;0..W()){\n\t\t\t\tPos[] set;\n\t\t\t\tS state = initState;\n\t\t\t\tdfs(Pos(x,y),set,state);\n\t\t\t\tif(!searchNextSet(set,state)) return false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n\nauto  readAciiMap(int w,int h){ \n\timport std.stdio,std.string;\n\tauto M=new char[][](w,h);\n\tforeach(y;0..h) foreach(int x,c;readln().chomp) M[x][y] = c;\t\t\n\treturn Matrix!(char)(M);\n}\n\nauto  readMatrix(int w,int h){\n\timport std.stdio,std.string,std.conv;\n\tauto M=new int[][](w,h);\n\tforeach(y;0..h) foreach(int x,c;readln().split()) M[x][y] = c.to!int;\n\treturn Matrix!(int)(M);\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio,std.conv, std.algorithm, std.container,std.array,std.range,std.string,std.typecons,std.numeric,std.math,std.random,std.functional;\n\nvoid main(){\n\tfor(int w,h ; read(w,h),w|h ; ){\t\t\n\t\tauto land = readAciiMap(w,h);\n\t\tint B,W;\n\t\tland.DFS!(char)( DPos , '.'\n\t\t\t,(Pos p,ref char state){\n\t\t\t\tif(land[p] == 'W' || land[p] == 'B'){\n\t\t\t\t\tif(state == '.') state = land[p];\n\t\t\t\t\telse if(state != land[p] ) state = 'X';\n\t\t\t\t\treturn false;\n\t\t\t\t} \n\t\t\t\treturn true;\n\t\t\t},(Pos[] set,char state){\n\t\t\t\tif(state == 'B') B += set.length;\n\t\t\t\tif(state == 'W') W += set.length;\n\t\t\t\treturn true;\n\t\t\t});\n\t\twriteln(B,\" \",W);\n\t}\n}\n\n\nint   read(){int n;read(n);return n;}\nvoid  read(T...)  (auto ref T args){mixin(readMixin);}\nvoid  readArray(T)(auto ref T args){mixin(readMixin);}\nconst readMixin = q{ \n\tauto line = readln().split();\n\tforeach(i,ref arg; args){ \n\t\tif (i >= line.length) return;\n\t\targ = line[i].to!(typeof(arg));\n\t}\n};\nvoid times(int n,void delegate() stmt){ foreach(i;0..n)stmt();}\nvoid Swap(T)(ref T a,ref T b){T t = a;a = b;b = t;}\n\nconst DPos = [Pos(1,0),Pos(0,1),Pos(-1,0),Pos(0,-1)];\nstruct Pos{ \n\tint x,y,z;\n\tthis(int x_ =0,int y_=0,int z_=0){x=x_;y=y_;z=z_;}\n\tthis(ulong x_ =0,ulong y_=0,ulong z_=0){x=cast(int)x_;y=cast(int)y_;z=cast(int)z_;}\n\tbool inRange(int w,int h,int Z=1){\n\t\treturn x>=0 && y >= 0 && z >=0 && x < w && y < h && z < Z;\n\t}\n\tPos opBinary(string op)(Pos rhs) {\n\t\treturn Pos ( mixin( \"x\"~op~\"rhs.x\" ),\n\t\t\t\t\t mixin( \"y\"~op~\"rhs.y\" ),\n\t\t\t\t\tmixin( \"z\"~op~\"rhs.z\" ));\n\t}\n\tvoid opOpAssign(string op)(Pos lhs) {\n\t\tmixin(\"x\"~op~\"=lhs.x;\");\n\t\tmixin(\"y\"~op~\"=lhs.y;\");\n\t\tmixin(\"z\"~op~\"=lhs.z;\");\n\t}\n}\n\nstruct Matrix(T){\n\timport std.conv;\n\tprivate T[][] data;\n\tthis(int w,int h){ data = new T[][](w,h);}\n\tthis(ref T[][] data_){ data = data_;}\n\tT opIndexAssign(T v, size_t x, size_t y){return data[x][y] = v;}\n\tT opIndexAssign(T v, Pos p){return opIndexAssign(v,p.x,p.y);}\n\tref T opIndex(size_t x, size_t y){return data[x][y];}\n\tref T opIndex(Pos p){return opIndex(p.x,p.y);}\n\tref T opCall(Pos p){return data[p.x][p.y];}\n\t@property auto W()const{return data.length;}\t\n\t@property auto H()const{return data[0].length;}\t\n\tauto X(int x){T[]res;foreach(y;0..H())res ~= data[x][y];return res; }\n\tauto Y(int y){T[]res;foreach(x;0..W())res ~= data[x][y];return res; }\n\tvoid setX(T[] vec, int x){foreach(int y,v;vec)data[x][y] = v; }\n\tvoid setY(T[] vec, int y){foreach(int x,v;vec)data[x][y] = v; }\n\tvoid toString(scope void delegate(const(char)[]) sink) const{\n\t\tforeach(y;0..H()) {\n\t\t\tforeach(x;0..W())sink(data[x][y].to!string);\n\t\t\tif(y != H()-1)sink(\"\\n\");\n\t\t}\n    }\n\tbool DFS(S)(const Pos[] nexts, S initState\n\t\t\t\t,bool delegate(Pos,ref S) dfsContinue\n\t\t\t\t,bool delegate(Pos[],S) searchNextSet){\n\t\tauto seeked = Matrix!bool(W(),H());\n\t\tvoid dfs(Pos p,ref Pos[] set,ref S state){ \n\t\t\tif(!p.inRange(W(),H())) return;\n\t\t\tif(seeked[p]) return;\n\t\t\tif(!dfsContinue(p,state))return;\n\t\t\tset ~= p;\n\t\t\tseeked[p] = true;\n\t\t\tforeach(n;nexts) dfs(p+n,set,state);\n\t\t}\n\t\tforeach(y;0..H()){\n\t\t\tforeach(x;0..W()){\n\t\t\t\tPos[] set;\n\t\t\t\tS state = initState;\n\t\t\t\tdfs(Pos(x,y),set,state);\n\t\t\t\tif(!searchNextSet(set,state)) return false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n\nauto  readAciiMap(int w,int h){ \n\timport std.stdio,std.string;\n\tauto M=new char[][](w,h);\n\tforeach(y;0..h) foreach(int x,c;readln().chomp) M[x][y] = c;\t\t\n\treturn Matrix!(char)(M);\n}\n\nauto  readMatrix(int w,int h){\n\timport std.stdio,std.string,std.conv;\n\tauto M=new int[][](w,h);\n\tforeach(y;0..h) foreach(int x,c;readln().split()) M[x][y] = c.to!int;\n\treturn Matrix!(int)(M);\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio,std.conv, std.algorithm, std.container,std.array,std.range,std.string,std.typecons,std.numeric,std.math,std.random,std.functional;\n\nvoid main(){\n\tfor(int w,h ; read(w,h),w|h ; ){\t\t\n\t\tauto land = readAciiMap(w,h);\n\t\tint B,W;\n\t\tland.DFS!(char)( DPos , '.'\n\t\t\t,(Pos p,ref char state){\n\t\t\t\tif(land[p] == 'W' || land[p] == 'B'){\n\t\t\t\t\tif(state == '.') state = land[p];\n\t\t\t\t\telse if(state != land[p] ) state = 'X';\n\t\t\t\t\treturn false;\n\t\t\t\t} \n\t\t\t\treturn true;\n\t\t\t},(Pos[] set,char state){\n\t\t\t\tif(state == 'B') B += set.length;\n\t\t\t\tif(state == 'W') W += set.length;\n\t\t\t\treturn true;\n\t\t\t});\n\t\twriteln(B,\" \",W);\n\t}\n}\n\n\nint   read(){int n;read(n);return n;}\nvoid  read(T...)  (auto ref T args){mixin(readMixin);}\nvoid  readArray(T)(auto ref T args){mixin(readMixin);}\nconst readMixin = q{ \n\tauto line = readln().split();\n\tforeach(i,ref arg; args){ \n\t\tif (i >= line.length) return;\n\t\targ = line[i].to!(typeof(arg));\n\t}\n};\nvoid times(int n,void delegate() stmt){ foreach(i;0..n)stmt();}\nvoid Swap(T)(ref T a,ref T b){T t = a;a = b;b = t;}\n\nconst DPos = [Pos(1,0),Pos(0,1),Pos(-1,0),Pos(0,-1)];\nstruct Pos{ \n\tint x,y,z;\n\tthis(int x_ =0,int y_=0,int z_=0){x=_x;y=y_;z=z_;}\n\tthis(ulong x_ =0,ulong y_=0,ulong z_=0){x=cast(int)_x;y=cast(int)y_;z=cast(int)z_;}\n\tbool inRange(int w,int h,int Z=1){\n\t\treturn x>=0 && y >= 0 && z >=0 && x < w && y < h && z < Z;\n\t}\n\tPos opBinary(string op)(Pos rhs) {\n\t\treturn Pos ( mixin( \"x\"~op~\"rhs.x\" ),\n\t\t\t\t\t mixin( \"y\"~op~\"rhs.y\" ),\n\t\t\t\t\tmixin( \"z\"~op~\"rhs.z\" ));\n\t}\n\tvoid opOpAssign(string op)(Pos lhs) {\n\t\tmixin(\"x\"~op~\"=lhs.x;\");\n\t\tmixin(\"y\"~op~\"=lhs.y;\");\n\t\tmixin(\"z\"~op~\"=lhs.z;\");\n\t}\n}\n\nstruct Matrix(T){\n\timport std.conv;\n\tprivate T[][] data;\n\tthis(int w,int h){ data = new T[][](w,h);}\n\tthis(ref T[][] data_){ data = data_;}\n\tT opIndexAssign(T v, size_t x, size_t y){return data[x][y] = v;}\n\tT opIndexAssign(T v, Pos p){return opIndexAssign(v,p.x,p.y);}\n\tref T opIndex(size_t x, size_t y){return data[x][y];}\n\tref T opIndex(Pos p){return opIndex(p.x,p.y);}\n\tref T opCall(Pos p){return data[p.x][p.y];}\n\t@property auto W()const{return data.length;}\t\n\t@property auto H()const{return data[0].length;}\t\n\tauto X(int x){T[]res;foreach(y;0..H())res ~= data[x][y];return res; }\n\tauto Y(int y){T[]res;foreach(x;0..W())res ~= data[x][y];return res; }\n\tvoid setX(T[] vec, int x){foreach(int y,v;vec)data[x][y] = v; }\n\tvoid setY(T[] vec, int y){foreach(int x,v;vec)data[x][y] = v; }\n\tvoid toString(scope void delegate(const(char)[]) sink) const{\n\t\tforeach(y;0..H()) {\n\t\t\tforeach(x;0..W())sink(data[x][y].to!string);\n\t\t\tif(y != H()-1)sink(\"\\n\");\n\t\t}\n    }\n\tbool DFS(S)(const Pos[] nexts, S initState\n\t\t\t\t,bool delegate(Pos,ref S) dfsContinue\n\t\t\t\t,bool delegate(Pos[],S) searchNextSet){\n\t\tauto seeked = Matrix!bool(W(),H());\n\t\tvoid dfs(Pos p,ref Pos[] set,ref S state){ \n\t\t\tif(!p.inRange(W(),H())) return;\n\t\t\tif(seeked[p]) return;\n\t\t\tif(!dfsContinue(p,state))return;\n\t\t\tset ~= p;\n\t\t\tseeked[p] = true;\n\t\t\tforeach(n;nexts) dfs(p+n,set,state);\n\t\t}\n\t\tforeach(y;0..H()){\n\t\t\tforeach(x;0..W()){\n\t\t\t\tPos[] set;\n\t\t\t\tS state = initState;\n\t\t\t\tdfs(Pos(x,y),set,state);\n\t\t\t\tif(!searchNextSet(set,state)) return false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n\nauto  readAciiMap(int w,int h){ \n\timport std.stdio,std.string;\n\tauto M=new char[][](w,h);\n\tforeach(y;0..h) foreach(int x,c;readln().chomp) M[x][y] = c;\t\t\n\treturn Matrix!(char)(M);\n}\n\nauto  readMatrix(int w,int h){\n\timport std.stdio,std.string,std.conv;\n\tauto M=new int[][](w,h);\n\tforeach(y;0..h) foreach(int x,c;readln().split()) M[x][y] = c.to!int;\n\treturn Matrix!(int)(M);\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio,std.conv, std.algorithm, std.container,std.array,std.range,std.string,std.typecons,std.numeric,std.math,std.random,std.functional;\n\nvoid main(){\n\tfor(int w,h ; read(w,h),w|h ; ){\t\t\n\t\tauto land = readAciiMap(w,h);\n\t\tint B,W;\n\t\tland.DFS!(char)( DPos , '.'\n\t\t\t,(Pos p,ref char state){\n\t\t\t\tif(land[p] == 'W' || land[p] == 'B'){\n\t\t\t\t\tif(state == '.') state = land[p];\n\t\t\t\t\telse if(state != land[p] ) state = 'X';\n\t\t\t\t\treturn false;\n\t\t\t\t} \n\t\t\t\treturn true;\n\t\t\t},(Pos[] set,char state){\n\t\t\t\tif(state == 'B') B += set.length;\n\t\t\t\tif(state == 'W') W += set.length;\n\t\t\t\treturn true;\n\t\t\t});\n\t\twriteln(B,\" \",W);\n\t}\n}\n\n\nint   read(){int n;read(n);return n;}\nvoid  read(T...)  (auto ref T args){mixin(readMixin);}\nvoid  readArray(T)(auto ref T args){mixin(readMixin);}\nconst readMixin = q{ \n\tauto line = readln().split();\n\tforeach(i,ref arg; args){ \n\t\tif (i >= line.length) return;\n\t\targ = line[i].to!(typeof(arg));\n\t}\n};\nvoid times(int n,void delegate() stmt){ foreach(i;0..n)stmt();}\nvoid Swap(T)(ref T a,ref T b){T t = a;a = b;b = t;}\n\nconst DPos = [Pos(1,0),Pos(0,1),Pos(-1,0),Pos(0,-1)];\nstruct Pos{ \n\tint x,y,z;\n\tbool inRange(int w,int h,int Z=1){\n\t\treturn x>=0 && y >= 0 && z >=0 && x < w && y < h && z < Z;\n\t}\n\tPos opBinary(string op)(Pos rhs) {\n\t\treturn Pos ( mixin( \"x\"~op~\"rhs.x\" ),\n\t\t\t\t\t mixin( \"y\"~op~\"rhs.y\" ),\n\t\t\t\t\tmixin( \"z\"~op~\"rhs.z\" ));\n\t}\n\tvoid opOpAssign(string op)(Pos lhs) {\n\t\tmixin(\"x\"~op~\"=lhs.x;\");\n\t\tmixin(\"y\"~op~\"=lhs.y;\");\n\t\tmixin(\"z\"~op~\"=lhs.z;\");\n\t}\n}\n\nstruct Matrix(T){\n\timport std.conv;\n\tprivate T[][] data;\n\tthis(int w,int h){ data = new T[][](w,h);}\n\tthis(ref T[][] data_){ data = data_;}\n\tT opIndexAssign(T v, size_t x, size_t y){return data[x][y] = v;}\n\tT opIndexAssign(T v, Pos p){return opIndexAssign(v,p.x,p.y);}\n\tref T opIndex(size_t x, size_t y){return data[x][y];}\n\tref T opIndex(Pos p){return opIndex(p.x,p.y);}\n\tref T opCall(Pos p){return data[p.x][p.y];}\n\t@property auto W()const{return data.length;}\t\n\t@property auto H()const{return data[0].length;}\t\n\tauto X(int x){T[]res;foreach(y;0..H())res ~= data[x][y];return res; }\n\tauto Y(int y){T[]res;foreach(x;0..W())res ~= data[x][y];return res; }\n\tvoid setX(T[] vec, int x){foreach(int y,v;vec)data[x][y] = v; }\n\tvoid setY(T[] vec, int y){foreach(int x,v;vec)data[x][y] = v; }\n\tvoid toString(scope void delegate(const(char)[]) sink) const{\n\t\tforeach(y;0..H()) {\n\t\t\tforeach(x;0..W())sink(data[x][y].to!string);\n\t\t\tif(y != H()-1)sink(\"\\n\");\n\t\t}\n    }\n\tbool DFS(S)(const Pos[] nexts, S initState\n\t\t\t\t,bool delegate(Pos,ref S) dfsContinue\n\t\t\t\t,bool delegate(Pos[],S) searchNextSet){\n\t\tauto seeked = Matrix!bool(W(),H());\n\t\tvoid dfs(Pos p,ref Pos[] set,ref S state){ \n\t\t\tif(!p.inRange(W(),H())) return;\n\t\t\tif(seeked[p]) return;\n\t\t\tif(!dfsContinue(p,state))return;\n\t\t\tset ~= p;\n\t\t\tseeked[p] = true;\n\t\t\tforeach(n;nexts) dfs(p+n,set,state);\n\t\t}\n\t\tforeach(y;iota(H())){\n\t\t\tforeach(x;iota(W())){\n\t\t\t\tPos[] set;\n\t\t\t\tS state = initState;\n\t\t\t\tdfs(Pos(x,y),set,state);\n\t\t\t\tif(!searchNextSet(set,state)) return false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n\nauto  readAciiMap(int w,int h){ \n\timport std.stdio,std.string;\n\tauto M=new char[][](w,h);\n\tforeach(y;0..h) foreach(int x,c;readln().chomp) M[x][y] = c;\t\t\n\treturn Matrix!(char)(M);\n}\n\nauto  readMatrix(int w,int h){\n\timport std.stdio,std.string,std.conv;\n\tauto M=new int[][](w,h);\n\tforeach(y;0..h) foreach(int x,c;readln().split()) M[x][y] = c.to!int;\n\treturn Matrix!(int)(M);\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio,std.conv, std.algorithm, std.container,std.array,std.range,std.string,std.typecons,std.numeric,std.math,std.random,std.functional;\n\nvoid main(){\n\tfor(int w,h ; read(w,h),w|h ; ){\t\t\n\t\tauto land = readAciiMap(w,h);\n\t\tint B,W;\n\t\tland.DFS!(char)( DPos , '.'\n\t\t\t,(Pos p,ref char state){\n\t\t\t\tif(land[p] == 'W' || land[p] == 'B'){\n\t\t\t\t\tif(state == '.') state = land[p];\n\t\t\t\t\telse if(state != land[p] ) state = 'X';\n\t\t\t\t\treturn false;\n\t\t\t\t} \n\t\t\t\treturn true;\n\t\t\t},(Pos[] set,char state){\n\t\t\t\tif(state == 'B') B += set.length;\n\t\t\t\tif(state == 'W') W += set.length;\n\t\t\t\treturn true;\n\t\t\t});\n\t\twriteln(B,\" \",W);\n\t}\n}\n\n\nint   read(){int n;read(n);return n;}\nvoid  read(T...)  (auto ref T args){mixin(readMixin);}\nvoid  readArray(T)(auto ref T args){mixin(readMixin);}\nconst readMixin = q{ \n\tauto line = readln().split();\n\tforeach(i,ref arg; args){ \n\t\tif (i >= line.length) return;\n\t\targ = line[i].to!(typeof(arg));\n\t}\n};\nvoid times(int n,void delegate() stmt){ foreach(i;0..n)stmt();}\nvoid Swap(T)(ref T a,ref T b){T t = a;a = b;b = t;}\n\nconst DPos = [Pos(1,0),Pos(0,1),Pos(-1,0),Pos(0,-1)];\nstruct Pos{ \n\tint x,y,z;\n\tbool inRange(int w,int h,int Z=1){\n\t\treturn x>=0 && y >= 0 && z >=0 && x < w && y < h && z < Z;\n\t}\n\tPos opBinary(string op)(Pos rhs) {\n\t\treturn Pos ( mixin( \"x\"~op~\"rhs.x\" ),\n\t\t\t\t\t mixin( \"y\"~op~\"rhs.y\" ),\n\t\t\t\t\tmixin( \"z\"~op~\"rhs.z\" ));\n\t}\n\tvoid opOpAssign(string op)(Pos lhs) {\n\t\tmixin(\"x\"~op~\"=lhs.x;\");\n\t\tmixin(\"y\"~op~\"=lhs.y;\");\n\t\tmixin(\"z\"~op~\"=lhs.z;\");\n\t}\n}\n\nstruct Matrix(T){\n\timport std.conv;\n\tprivate T[][] data;\n\tthis(int w,int h){ data = new T[][](w,h);}\n\tthis(ref T[][] data_){ data = data_;}\n\tT opIndexAssign(T v, size_t x, size_t y){return data[x][y] = v;}\n\tT opIndexAssign(T v, Pos p){return opIndexAssign(v,p.x,p.y);}\n\tref T opIndex(size_t x, size_t y){return data[x][y];}\n\tref T opIndex(Pos p){return opIndex(p.x,p.y);}\n\tref T opCall(Pos p){return data[p.x][p.y];}\n\t@property auto W()const{return data.length;}\t\n\t@property auto H()const{return data[0].length;}\t\n\tauto X(int x){T[]res;foreach(y;0..H())res ~= data[x][y];return res; }\n\tauto Y(int y){T[]res;foreach(x;0..W())res ~= data[x][y];return res; }\n\tvoid setX(T[] vec, int x){foreach(int y,v;vec)data[x][y] = v; }\n\tvoid setY(T[] vec, int y){foreach(int x,v;vec)data[x][y] = v; }\n\tvoid toString(scope void delegate(const(char)[]) sink) const{\n\t\tforeach(y;0..H()) {\n\t\t\tforeach(x;0..W())sink(data[x][y].to!string);\n\t\t\tif(y != H()-1)sink(\"\\n\");\n\t\t}\n    }\n\tbool DFS(S)(const Pos[] nexts, S initState\n\t\t\t\t,bool delegate(Pos,ref S) dfsContinue\n\t\t\t\t,bool delegate(Pos[],S) searchNextSet){\n\t\tauto seeked = Matrix!bool(W(),H());\n\t\tvoid dfs(Pos p,ref Pos[] set,ref S state){ \n\t\t\tif(!p.inRange(W(),H())) return;\n\t\t\tif(seeked[p]) return;\n\t\t\tif(!dfsContinue(p,state))return;\n\t\t\tset ~= p;\n\t\t\tseeked[p] = true;\n\t\t\tforeach(n;nexts) dfs(p+n,set,state);\n\t\t}\n\t\tforeach(y;0..H()){\n\t\t\tforeach(x;0..W()){\n\t\t\t\tPos[] set;\n\t\t\t\tS state = initState;\n\t\t\t\tdfs(Pos(x,y),set,state);\n\t\t\t\tif(!searchNextSet(set,state)) return false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n\nauto  readAciiMap(int w,int h){ \n\timport std.stdio,std.string;\n\tauto M=new char[][](w,h);\n\tforeach(y;0..h) foreach(int x,c;readln().chomp) M[x][y] = c;\t\t\n\treturn Matrix!(char)(M);\n}\n\nauto  readMatrix(int w,int h){\n\timport std.stdio,std.string,std.conv;\n\tauto M=new int[][](w,h);\n\tforeach(y;0..h) foreach(int x,c;readln().split()) M[x][y] = c.to!int;\n\treturn Matrix!(int)(M);\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio,std.conv, std.algorithm, std.container,std.array,std.range,std.string,std.typecons,std.numeric,std.math,std.random,std.functional;\n\nvoid main(){\n\tfor(int w,h ; read(w,h),w|h ; ){\t\t\n\t\tauto land = readAciiMap(w,h);\n\t\tint B,W;\n\t\tland.DFS!(char)( DPos , '.'\n\t\t\t,(Pos p,ref char state){\n\t\t\t\tif(land[p] == 'W' || land[p] == 'B'){\n\t\t\t\t\tif(state == '.') state = land[p];\n\t\t\t\t\telse if(state != land[p] ) state = 'X';\n\t\t\t\t\treturn false;\n\t\t\t\t} \n\t\t\t\treturn true;\n\t\t\t},(Pos[] set,char state){\n\t\t\t\tif(state == 'B') B += set.length;\n\t\t\t\tif(state == 'W') W += set.length;\n\t\t\t\treturn true;\n\t\t\t});\n\t\twriteln(B,\" \",W);\n\t}\n}\n\n\nint   read(){int n;read(n);return n;}\nvoid  read(T...)  (auto ref T args){mixin(readMixin);}\nvoid  readArray(T)(auto ref T args){mixin(readMixin);}\nconst readMixin = q{ \n\tauto line = readln().split();\n\tforeach(i,ref arg; args){ \n\t\tif (i >= line.length) return;\n\t\targ = line[i].to!(typeof(arg));\n\t}\n};\nvoid times(int n,void delegate() stmt){ foreach(i;0..n)stmt();}\nvoid Swap(T)(ref T a,ref T b){T t = a;a = b;b = t;}\n\nconst DPos = [Pos(1,0),Pos(0,1),Pos(-1,0),Pos(0,-1)];\nstruct Pos{ \n\tint x,y,z;\n\tthis(int x_ =0,int y_=0,int z_=0){x=x_;y=y_;z=z_;}\n\tthis(ulong x_ =0,ulong y_=0,ulong z_=0){x=cast(int)x_;y=cast(int)y_;z=cast(int)z_;}\n\tbool inRange(int w,int h,int Z=1){\n\t\treturn x>=0 && y >= 0 && z >=0 && x < w && y < h && z < Z;\n\t}\n\tbool inRange(ulong w,ulong h,ulong Z=1){return inRange(cast(int)w,cast(int)h,cast(int)Z);}\n\tPos opBinary(string op)(Pos rhs) {\n\t\treturn Pos ( mixin( \"x\"~op~\"rhs.x\" ),\n\t\t\t\t\t mixin( \"y\"~op~\"rhs.y\" ),\n\t\t\t\t\tmixin( \"z\"~op~\"rhs.z\" ));\n\t}\n\tvoid opOpAssign(string op)(Pos lhs) {\n\t\tmixin(\"x\"~op~\"=lhs.x;\");\n\t\tmixin(\"y\"~op~\"=lhs.y;\");\n\t\tmixin(\"z\"~op~\"=lhs.z;\");\n\t}\n}\n\nstruct Matrix(T){\n\timport std.conv;\n\tprivate T[][] data;\n\tthis(int w,int h){ data = new T[][](w,h);}\n\tthis(ulong w,ulong h){ data = new T[][](w,h);}\n\tthis(ref T[][] data_){ data = data_;}\n\tT opIndexAssign(T v, size_t x, size_t y){return data[x][y] = v;}\n\tT opIndexAssign(T v, Pos p){return opIndexAssign(v,p.x,p.y);}\n\tref T opIndex(size_t x, size_t y){return data[x][y];}\n\tref T opIndex(Pos p){return opIndex(p.x,p.y);}\n\tref T opCall(Pos p){return data[p.x][p.y];}\n\t@property auto W()const{return data.length;}\t\n\t@property auto H()const{return data[0].length;}\t\n\tauto X(int x){T[]res;foreach(y;0..H())res ~= data[x][y];return res; }\n\tauto Y(int y){T[]res;foreach(x;0..W())res ~= data[x][y];return res; }\n\tvoid setX(T[] vec, int x){foreach(int y,v;vec)data[x][y] = v; }\n\tvoid setY(T[] vec, int y){foreach(int x,v;vec)data[x][y] = v; }\n\tvoid toString(scope void delegate(const(char)[]) sink) const{\n\t\tforeach(y;0..H()) {\n\t\t\tforeach(x;0..W())sink(data[x][y].to!string);\n\t\t\tif(y != H()-1)sink(\"\\n\");\n\t\t}\n    }\n\tbool DFS(S)(const Pos[] nexts, S initState\n\t\t\t\t,bool delegate(Pos,ref S) dfsContinue\n\t\t\t\t,bool delegate(Pos[],S) searchNextSet){\n\t\tauto seeked = Matrix!bool(W(),H());\n\t\tvoid dfs(Pos p,ref Pos[] set,ref S state){ \n\t\t\tif(!p.inRange(W(),H())) return;\n\t\t\tif(seeked[p]) return;\n\t\t\tif(!dfsContinue(p,state))return;\n\t\t\tset ~= p;\n\t\t\tseeked[p] = true;\n\t\t\tforeach(n;nexts) dfs(p+n,set,state);\n\t\t}\n\t\tforeach(y;0..H()){\n\t\t\tforeach(x;0..W()){\n\t\t\t\tPos[] set;\n\t\t\t\tS state = initState;\n\t\t\t\tdfs(Pos(x,y),set,state);\n\t\t\t\tif(!searchNextSet(set,state)) return false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n\nauto  readAciiMap(int w,int h){ \n\timport std.stdio,std.string;\n\tauto M=new char[][](w,h);\n\tforeach(y;0..h) foreach(int x,c;readln().chomp) M[x][y] = c;\t\t\n\treturn Matrix!(char)(M);\n}\n\nauto  readMatrix(int w,int h){\n\timport std.stdio,std.string,std.conv;\n\tauto M=new int[][](w,h);\n\tforeach(y;0..h) foreach(int x,c;readln().split()) M[x][y] = c.to!int;\n\treturn Matrix!(int)(M);\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio,std.conv, std.algorithm, std.container,std.array,std.range,std.string,std.typecons,std.numeric,std.math,std.random,std.functional;\n\nvoid main(){\n\tfor(int w,h ; read(w,h),w|h ; ){\t\t\n\t\tauto land = readAciiMap(w,h);\n\t\tint B,W;\n\t\tland.DFS!(char)( DPos , '.'\n\t\t\t,(Pos p,ref char state){\n\t\t\t\tif(land[p] == 'W' || land[p] == 'B'){\n\t\t\t\t\tif(state == '.') state = land[p];\n\t\t\t\t\telse if(state != land[p] ) state = 'X';\n\t\t\t\t\treturn false;\n\t\t\t\t} \n\t\t\t\treturn true;\n\t\t\t},(Pos[] set,char state){\n\t\t\t\tif(state == 'B') B += set.length;\n\t\t\t\tif(state == 'W') W += set.length;\n\t\t\t\treturn true;\n\t\t\t});\n\t\twriteln(B,\" \",W);\n\t}\n}\n\n\nint   read(){int n;read(n);return n;}\nvoid  read(T...)  (auto ref T args){mixin(readMixin);}\nvoid  readArray(T)(auto ref T args){mixin(readMixin);}\nconst readMixin = q{ \n\tauto line = readln().split();\n\tforeach(i,ref arg; args){ \n\t\tif (i >= line.length) return;\n\t\targ = line[i].to!(typeof(arg));\n\t}\n};\nvoid times(int n,void delegate() stmt){ foreach(i;0..n)stmt();}\nvoid Swap(T)(ref T a,ref T b){T t = a;a = b;b = t;}\n\nconst DPos = [Pos(1,0),Pos(0,1),Pos(-1,0),Pos(0,-1)];\nstruct Pos{ \n\tint x,y,z;\n\tbool inRange(int w,int h,int Z=1){\n\t\treturn x>=0 && y >= 0 && z >=0 && x < w && y < h && z < Z;\n\t}\n\tPos opBinary(string op)(Pos rhs) {\n\t\treturn Pos ( mixin( \"x\"~op~\"rhs.x\" ),\n\t\t\t\t\t mixin( \"y\"~op~\"rhs.y\" ),\n\t\t\t\t\tmixin( \"z\"~op~\"rhs.z\" ));\n\t}\n\tvoid opOpAssign(string op)(Pos lhs) {\n\t\tmixin(\"x\"~op~\"=lhs.x;\");\n\t\tmixin(\"y\"~op~\"=lhs.y;\");\n\t\tmixin(\"z\"~op~\"=lhs.z;\");\n\t}\n}\n\nstruct Matrix(T){\n\timport std.conv;\n\tprivate T[][] data;\n\tthis(int w,int h){ data = new T[][](w,h);}\n\tthis(ref T[][] data_){ data = data_;}\n\tT opIndexAssign(T v, size_t x, size_t y){return data[x][y] = v;}\n\tT opIndexAssign(T v, Pos p){return opIndexAssign(v,p.x,p.y);}\n\tref T opIndex(size_t x, size_t y){return data[x][y];}\n\tref T opIndex(Pos p){return opIndex(p.x,p.y);}\n\tref T opCall(Pos p){return data[p.x][p.y];}\n\t@property int W()const{return data.length;}\t\n\t@property int H()const{return data[0].length;}\t\n\tauto X(int x){T[]res;foreach(y;0..H())res ~= data[x][y];return res; }\n\tauto Y(int y){T[]res;foreach(x;0..W())res ~= data[x][y];return res; }\n\tvoid setX(T[] vec, int x){foreach(int y,v;vec)data[x][y] = v; }\n\tvoid setY(T[] vec, int y){foreach(int x,v;vec)data[x][y] = v; }\n\tvoid toString(scope void delegate(const(char)[]) sink) const{\n\t\tforeach(y;0..H()) {\n\t\t\tforeach(x;0..W())sink(data[x][y].to!string);\n\t\t\tif(y != H()-1)sink(\"\\n\");\n\t\t}\n    }\n\tbool DFS(S)(const Pos[] nexts, S initState\n\t\t\t\t,bool delegate(Pos,ref S) dfsContinue\n\t\t\t\t,bool delegate(Pos[],S) searchNextSet){\n\t\tauto seeked = Matrix!bool(W(),H());\n\t\tvoid dfs(Pos p,ref Pos[] set,ref S state){ \n\t\t\tif(!p.inRange(W(),H())) return;\n\t\t\tif(seeked[p]) return;\n\t\t\tif(!dfsContinue(p,state))return;\n\t\t\tset ~= p;\n\t\t\tseeked[p] = true;\n\t\t\tforeach(n;nexts) dfs(p+n,set,state);\n\t\t}\n\t\tforeach(y;0..H()){\n\t\t\tforeach(x;0..W()){\n\t\t\t\tPos[] set;\n\t\t\t\tS state = initState;\n\t\t\t\tdfs(Pos(x,y),set,state);\n\t\t\t\tif(!searchNextSet(set,state)) return false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n}\n\nauto  readAciiMap(int w,int h){ \n\timport std.stdio,std.string;\n\tauto M=new char[][](w,h);\n\tforeach(y;0..h) foreach(int x,c;readln().chomp) M[x][y] = c;\t\t\n\treturn Matrix!(char)(M);\n}\n\nauto  readMatrix(int w,int h){\n\timport std.stdio,std.string,std.conv;\n\tauto M=new int[][](w,h);\n\tforeach(y;0..h) foreach(int x,c;readln().split()) M[x][y] = c.to!int;\n\treturn Matrix!(int)(M);\n}"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\nimport queue\nwhile 1:\n    w,h=map(int,input().split())\n    if w==0:\n        break\n    field=[]\n    for i in range(h):\n        field.append(list(input()))\n    B=0\n    W=0\n    for i in range(h):\n        for j in range(w):\n            if field[i][j]=='.':\n                q=queue.Queue()\n                q.put((i,j))\n                check=set()\n                d=0\n                while not q.empty():\n                    y,x=q.get()\n                    if field[y][x]=='.':\n                        field[y][x]='#'\n                        d+=1\n                    elif field[y][x]=='W':\n                        check.add('W')\n                        continue\n                    elif field[y][x]=='B':\n                        check.add('B')\n                        continue\n                    else:\n                        continue\n                    if 0<=y+1<h and 0<=x<w:\n                        q.put((y+1,x))\n                    if 0<=y-1<h and 0<=x<w:\n                        q.put((y-1,x))\n                    if 0<=y<h and 0<=x+1<w:\n                        q.put((y,x+1))\n                    if 0<=y<h and 0<=x-1<w:\n                        q.put((y,x-1))\n                if len(check)==2:\n                    pass\n                elif 'B' in check:\n                    B+=d\n                elif 'W' in check:\n                    W+=d\n    print(B,W)\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\nwhile True:\n\n    W,H = map(int,input().split())\n\n    if W == 0 and H == 0:\n        break\n\n    a = []\n\n    for i in range(H):\n\n        A = list(input())\n        a.append(A)\n\n    q = deque([])\n\n    for i in range(H):\n        for j in range(W):\n\n            if a[i][j] in [\"W\",\"B\"]:\n                q.append([i,j])\n\n    while len(q) > 0:\n\n        now = q.pop()\n        nx = now[0]\n        ny = now[1]\n\n        if a[nx][ny] in[ \"W\",\"X\" ]:\n\n            if nx - 1 >= 0 and a[nx-1][ny] == \".\":\n                a[nx-1][ny] = \"X\"\n                q.append([nx-1,ny])\n\n            if ny - 1 >= 0 and a[nx][ny-1] == \".\":\n                a[nx][ny-1] = \"X\"\n                q.append([nx,ny-1])\n\n            if nx + 1 < H and a[nx+1][ny] == \".\":\n                a[nx+1][ny] = \"X\"\n                q.append([nx+1,ny])\n\n            if ny + 1 < W and a[nx][ny+1] == \".\":\n                a[nx][ny+1] = \"X\"\n                q.append([nx,ny+1])\n\n\n        if a[nx][ny] in [\"B\",\"C\"]:\n\n            if nx - 1 >= 0 and a[nx-1][ny] == \".\":\n                a[nx-1][ny] = \"C\"\n                q.append([nx-1,ny])\n\n            if ny - 1 >= 0 and a[nx][ny-1] == \".\":\n                a[nx][ny-1] = \"C\"\n                q.append([nx,ny-1])\n\n            if nx + 1 < H and a[nx+1][ny] == \".\":\n                a[nx+1][ny] = \"C\"\n                q.append([nx+1,ny])\n\n            if ny + 1 < W and a[nx][ny+1] == \".\":\n                a[nx][ny+1] = \"C\"\n                q.append([nx,ny+1])\n\n        if a[nx][ny] in [\"B\",\"C\",\"Z\"]:\n\n            if nx - 1 >= 0 and a[nx-1][ny] == \"X\":\n                a[nx-1][ny] = \"Z\"\n                q.append([nx-1,ny])\n\n            if ny - 1 >= 0 and a[nx][ny-1] == \"X\":\n                a[nx][ny-1] = \"Z\"\n                q.append([nx,ny-1])\n\n            if nx + 1 < H and a[nx+1][ny] == \"X\":\n                a[nx+1][ny] = \"Z\"\n                q.append([nx+1,ny])\n\n            if ny + 1 < W and a[nx][ny+1] == \"X\":\n                a[nx][ny+1] = \"Z\"\n                q.append([nx,ny+1])\n\n\n        if a[nx][ny] in [\"W\",\"X\",\"Z\"]:\n\n            if nx - 1 >= 0 and a[nx-1][ny] == \"C\":\n                a[nx-1][ny] = \"Z\"\n                q.append([nx-1,ny])\n\n            if ny - 1 >= 0 and a[nx][ny-1] == \"C\":\n                a[nx][ny-1] = \"Z\"\n                q.append([nx,ny-1])\n\n            if nx + 1 < H and a[nx+1][ny] == \"C\":\n                a[nx+1][ny] = \"Z\"\n                q.append([nx+1,ny])\n\n            if ny + 1 < W and a[nx][ny+1] == \"C\":\n                a[nx][ny+1] = \"Z\"\n                q.append([nx,ny+1])\n\n    bn = 0\n    wn = 0\n    for i in range(H):\n\n        #print (a[i])\n\n        for j in range(W):\n\n            if a[i][j] == \"C\":\n                bn += 1\n            elif a[i][j] == \"X\":\n                wn += 1\n    \n    print (bn,wn)\n\n"
  },
  {
    "language": "Python",
    "code": "def dfs(r, c, n):\n    if board[r][c] == n:\n        return\n    if board[r][c] in 'WB':\n        pile.append(board[r][c])\n        return \n    board[r][c] = n\n    drc = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    for dr, dc in drc:\n        nr, nc = r + dr, c + dc\n        if 0 <= nr < h and 0 <= nc < w:\n            dfs(nr, nc, n)\n\nwhile True:\n    w, h = map(int, input().split())\n    if w == 0 and h == 0: break\n    board = [list(input()) for _ in range(h)]\n    place = 0\n    piles = []\n    black, white = [], []\n    for r in range(h):\n        for c in range(w):\n            if board[r][c] == '.':\n                pile = []\n                place += 1\n                dfs(r, c, place)\n                piles.append(pile)\n    for i, pile in enumerate(piles):\n        if not pile: continue\n        for p in pile:\n            if p != 'B':\n                break\n        else:\n            black.append(i+1)\n        for p in pile:\n            if p != 'W':\n                break\n        else:\n            white.append(i+1)\n    ans_b, ans_w = 0, 0\n    for row in board:\n        for c in row:\n            if c in black:\n                ans_b += 1\n            elif c in white:\n                ans_w += 1\n    print(ans_b, ans_w)"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(1000000)\nwhile True:\n  w,h=map(int,input().split())\n  if w==0:\n    break\n  mp=[\"X\"+input()+\"X\" for _ in range(h)]\n  mp.insert(0,\"X\"*(w+2))\n  mp.append('X'*(w+2))\n\n  visited_w=[[False]*(w+2) for _ in range(h+2)]\n  visited_b=[[False]*(w+2) for _ in range(h+2)]\n  vec=((0,1),(0,-1),(1,0),(-1,0))\n\n  def search(x,y,visited):\n    for dx, dy in vec:\n      nx,ny=x+dx,y+dy\n      if not visited[ny][nx] and mp[ny][nx]==\".\":\n        visited[ny][nx]=True\n        search(nx,ny,visited)\n\n  for y in range(1,h+1):\n    for x in range(1,w+1):\n      if mp[y][x]==\"W\":\n        search(x,y,visited_w)\n      elif mp[y][x]==\"B\":\n        search(x,y,visited_b)\n\n  ans_w=ans_b=0\n\n  for y in range(1,h+1):\n    for x in range(1,w+1):\n      if visited_w[y][x] and not visited_b[y][x]:\n        ans_w +=1\n      elif not visited_w[y][x] and visited_b[y][x]:\n        ans_b+=1\n  print(ans_b,ans_w)\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\ndxs = [1,0,-1,0]\ndys = [0,1,0,-1]\ndef bfs(x,y,c):\n    q = deque([(x,y)])\n    while q:\n        x,y = q.popleft()\n        for dx,dy in zip(dxs,dys):\n            nx,ny = x+dx,y+dy\n            if nx < 0 or nx >= W or ny < 0 or ny >= H: continue\n            if src[ny][nx] != '.' or mem[c][ny][nx]: continue\n            q.append((nx,ny))\n            mem[c][ny][nx] = 1\n\nwhile True:\n    W,H = map(int,input().split())\n    if W == 0: break\n    src = [input() for i in range(H)]\n    mem = [[[0 for w in range(W)] for h in range(H)] for c in range(2)]\n    for y in range(H):\n        for x in range(W):\n            if src[y][x] == '.': continue\n            c = (0 if src[y][x] == 'B' else 1)\n            bfs(x,y,c)\n    b = w = 0\n    for y in range(H):\n        for x in range(W):\n            bm,wm = mem[0][y][x], mem[1][y][x]\n            if bm and not wm: b += 1\n            elif wm and not bm: w += 1\n    print(str(b) + ' ' + str(w))"
  },
  {
    "language": "Python",
    "code": "#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport os\nimport sys\nimport itertools\nimport math\nfrom collections import Counter, defaultdict\n\nclass Main(object):\n    \n    def __init__(self):\n        pass\n\n    def solve(self):\n        '''\n        insert your code\n        '''\n        while True:\n            w, h = map(int, raw_input().split())\n            if w == h == 0:\n                break\n            m = []\n            for i in range(1, h+1):\n                row = list(raw_input())\n                m.append(row)\n            # for row in m:\n            #     print row\n            # print \n            d = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n            w_count = 0\n            b_count = 0\n            for i in range(h):\n                for j in range(w):\n                    if m[i][j] == '.':\n                        q = [(i, j)]\n                        flg = None\n                        count = 0\n                        while q:\n                            y, x = q.pop()\n                            if m[y][x] == '.':\n                                count += 1\n                            m[y][x] = 'U'\n                            for dy, dx in d:\n                                if 0 <= y + dy < h and 0 <= x + dx < w:\n                                    if m[y+dy][x+dx] == 'W':\n                                        if flg is None:\n                                            flg = 'W'\n                                        elif flg == 'B':\n                                            flg = 'NotOccupied'\n                                    elif m[y+dy][x+dx] == 'B':\n                                        if flg is None:\n                                            flg = 'B'\n                                        elif flg == 'W':\n                                            flg = 'NotOccupied'\n                                    elif m[y+dy][x+dx] == '.':\n                                        q.append((y + dy, x + dx))\n                                                                            \n                        if flg == 'W':\n                            w_count += count\n                        elif flg == 'B':\n                            b_count += count\n                        # for row in m:\n                        #     print row\n                        # print b_count, w_count\n                        # print \n                            \n            print b_count, w_count\n                                                \n                                    \n        return None\n\nif __name__ == '__main__':\n    m = Main()\n    m.solve()"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\nimport sys\nsys.setrecursionlimit(10**6)\n\ndef dfs(x, y, symbol,land):\n    if land[y][x] != '.':\n        return ([land[y][x]] if not str(land[y][x]).isnumeric() else False), 0\n    land[y][x] = symbol\n    count = 1\n    dxdy = [(1,0),(-1,0),(0,1),(0,-1)]\n\n    owner_list = []\n    for dx,dy in dxdy:\n        if 0 <= x + dx < len(land[0]) and 0 <= y + dy < len(land):\n            ret,c = dfs(x + dx, y + dy, symbol,land)\n            count += c\n\n            if ret is not False:\n                owner_list += ret\n    return (list(set(owner_list)), count)\n\nwhile True:\n    w,h = map(int,input().split())\n    if w == 0 and h == 0:\n        break\n    land = [list(input()) for i in range(0,h)]\n\n    symbol = 0\n    count_dict = {'W' :0, 'B' :0}\n\n    for y in range(h):\n        for x in range(w):\n            if land[y][x] == '.':\n                ret, count = dfs(x,y,symbol,land)\n                if len(ret) == 1:\n                    count_dict[ret[0]] += count\n                symbol += 1\n    print(count_dict['B'],count_dict['W'])"
  },
  {
    "language": "Python",
    "code": "\nW = 0\nH = 0\nisland = list()\n\nNOT_SUR = 0\nBLACK = 1\nWHITE = 2\n\ndef read_island():\n    island = list()\n    w, h = map(int, raw_input().split())\n    for i in xrange(h):\n        line = raw_input()\n        chars = list()\n        for ch in line:\n            chars.append(ch)\n        island.append(chars)\n\n    return w, h, island\n\n\ndir_x = [0, 1, 0, -1] # up, right, down, left\ndir_y = [-1, 0, 1, 0]\n\ndef check_ex_adj(x, y, color):\n    global island\n\n    if island[y][x] != \".\":\n        return False\n\n    for i in xrange(4):\n        next_x = x + dir_x[i]\n        next_y = y + dir_y[i]\n        if not (0 <= next_x < W) or not (0 <= next_y < H):\n            continue\n\n        if island[y + dir_y[i]][x + dir_x[i]] == color:\n            return True\n\n    for i in xrange(4):\n        next_x = x + dir_x[i]\n        next_y = y + dir_y[i]\n        if not (0 <= next_x < W) or not (0 <= next_y < H):\n            continue\n\n        island[y][x] = \"B\" if color == \"W\" else \"W\"\n        is_ex_adj = check_ex_adj(next_x, next_y, color)\n        island[y][x] = \".\"\n        if is_ex_adj:\n            return is_ex_adj\n\n    return False\n\n\ndef check_surrounded(x, y):\n    is_adj_b = check_ex_adj(x, y, \"B\")\n    is_adj_w = check_ex_adj(x, y, \"W\")\n\n    if is_adj_b and not is_adj_w:\n        return BLACK\n    elif not is_adj_b and is_adj_w:\n        return WHITE\n\n    return NOT_SUR\n\n\ndef solve():\n    global W\n    global H\n    global island\n    while True:\n        W, H, island = read_island()\n        if W == 0 and H == 0:\n            break\n\n        black_area = 0\n        white_area = 0\n        for x in xrange(W):\n            for y in xrange(H):\n                surrounded_by = check_surrounded(x, y)\n                if surrounded_by == NOT_SUR:\n                    continue\n\n                if surrounded_by == BLACK: # Black\n                    black_area += 1\n                elif surrounded_by == WHITE:\n                    white_area += 1\n\n        print \"{} {}\".format(black_area, white_area)\n\n\nif __name__ == \"__main__\":\n    solve()"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 998244353\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    rr = []\n\n    d = [(0,1),(0,-1),(1,0),(-1,0)]\n\n    while True:\n        w,h = LI()\n        if w == 0 and h == 0:\n            break\n\n        a = [S() for _ in range(h)]\n        b = [[0]*w for _ in range(h)]\n        c = [[0]*w for _ in range(h)]\n        q = []\n        for i in range(h):\n            for j in range(w):\n                if a[i][j] == 'B':\n                    q.append((i,j))\n        qi = 0\n        f = [[None]*w for _ in range(h)]\n        while len(q) > qi:\n            i,j = q[qi]\n            qi += 1\n            for di,dj in d:\n                ni = di + i\n                nj = dj + j\n                if 0 <= ni < h and 0 <= nj < w and f[ni][nj] is None:\n                    f[ni][nj] = 1\n                    if a[ni][nj] == '.':\n                        q.append((ni,nj))\n                        b[ni][nj] = 1\n\n        q = []\n        for i in range(h):\n            for j in range(w):\n                if a[i][j] == 'W':\n                    q.append((i,j))\n        qi = 0\n        f = [[None]*w for _ in range(h)]\n        while len(q) > qi:\n            i,j = q[qi]\n            qi += 1\n            for di,dj in d:\n                ni = di + i\n                nj = dj + j\n                if 0 <= ni < h and 0 <= nj < w and f[ni][nj] is None:\n                    f[ni][nj] = 1\n                    if a[ni][nj] == '.':\n                        q.append((ni,nj))\n                        c[ni][nj] = 1\n        bc = wc = 0\n        for i in range(h):\n            for j in range(w):\n                if b[i][j] == 1 and c[i][j] == 0:\n                    bc += 1\n                elif c[i][j] == 1 and b[i][j] == 0:\n                    wc += 1\n\n\n        rr.append('{} {}'.format(bc,wc))\n\n    return '\\n'.join(map(str, rr))\n\n\nprint(main())\n\n\n"
  },
  {
    "language": "Python",
    "code": "class Area:\n    def __init__(self,m,x,y):\n        self.m = m\n        self.f_W = False\n        self.f_B = False\n        self.side = 0\n        self.count = 0\n        self.standardx = x\n        self.standardy = y\n        self.check(x,y)\n        self.getSide()\n\n    def check(self,x,y):\n        if(y<0 or y >= len(m) or x<0 or x>=len(m[0])):\n            return\n        c = self.m[y][x]\n        if(c!=0):\n            if(c==1):\n                self.f_B=True\n            if(c==2):\n                self.f_W=True\n            return\n        else:\n            if(c==0):\n                self.m[y][x]=3\n                self.count += 1\n                self.check(x-1,y)\n                self.check(x+1,y)\n                self.check(x,y-1)\n                self.check(x,y+1)\n\n    def getSide(self):\n        if(self.f_B and self.f_W):\n            self.side = 0\n        elif(self.f_B):\n            self.side = 1\n        elif(self.f_W):\n            self.side = 2\n        else:\n            self.side = 0\n        return self.side\n            \nimport sys\nlimit = 100000\nsys.setrecursionlimit(limit)\n\n\nwhile True:\n    w,h = map(int,raw_input().split())\n    if(not w) :\n        break\n    m = []\n    for i in range(h):\n        m.append([])\n        l = raw_input()\n        for ii in range(w):\n            dic = {\".\":0,\"B\":1,\"W\":2}\n            m[i].append(dic[l[ii]])\n    B = 0\n    W = 0\n    for i,l in enumerate(m):\n        for ii,c in enumerate(l):\n            if(c==0):\n                a = Area(m,ii,i)\n                if(a.getSide() == 1):\n                    B += a.count\n                elif(a.getSide() == 2):\n                    W += a.count\n    print B,W"
  },
  {
    "language": "Python",
    "code": "from collections import deque\ndef bfs(y,x):\n    q = deque()\n    q.append((y,x))\n    bfs_map[y][x] = 0\n    res = 0\n    su = 1\n    while q:\n        y,x = q.popleft()\n        for dy,dx in d:\n            y_ = y+dy\n            x_ = x+dx\n            if 0 <= y_ < h and 0 <= x_ < w:\n                res |= f[s[y_][x_]]\n                if bfs_map[y_][x_]:\n                    bfs_map[y_][x_] = 0\n                    if not f[s[y_][x_]]:\n                        q.append((y_,x_))\n                        su += 1\n    return res,su\nd = [(1,0),(-1,0),(0,1),(0,-1)]\nwhile 1:\n    w,h = map(int, input().split())\n    if w == h == 0:\n        break\n    s = [input() for i in range(h)]\n    bfs_map = [[1 for j in range(w)] for i in range(h)]\n    f = {\".\":0, \"B\":1, \"W\":2}\n    ans = [0,0,0,0]\n    for y in range(h):\n        for x in range(w):\n            if bfs_map[y][x] and s[y][x] == \".\":\n                k,su = bfs(y,x)\n                ans[k] += su\n    print(*ans[1:3])\n\n"
  },
  {
    "language": "Python",
    "code": "def fill(MAP,xy,stick):\n    global w,h\n    if stick=='B': sflag=0\n    else: sflag=1\n    x,y=(xy[0],xy[1])\n    if MAP[y][x][sflag]==0: MAP[y][x][sflag]=1\n    xlist=[1,-1,0,0]\n    ylist=[0,0,1,-1]\n    for dx,dy in zip(xlist,ylist):\n        nx=x+dx\n        ny=y+dy\n        if 0<=nx<w and 0<=ny<h:\n            if  MAP[ny][nx][0]==-1 or MAP[ny][nx][1]==-1:\n                continue\n            elif MAP[ny][nx][sflag]==0:\n                fill(MAP,[nx,ny],stick)\n\ndef countMAP(MAP):\n    global w,h\n    countB=0\n    countW=0\n    for x in range(w):\n        for y in range(h):\n            if MAP[y][x]==[1,0]:\n                countB+=1\n            elif MAP[y][x]==[0,1]:\n                countW+=1\n    return countB,countW\n\nwhile  True:\n    w,h=map(int,input().split())\n    if w==h==0: break\n    MAP=[]\n    for i in range(h):\n        temp=input()\n        MAP.append([])\n        for j in range(w):\n            if temp[j]=='.': MAP[i].append([0,0])\n            elif temp[j]=='B': MAP[i].append([-1,0])\n            else: MAP[i].append([0,-1])\n    for y in range(h):\n        for x in range(w):\n            if MAP[y][x][0]==-1:\n                fill(MAP,[x,y],'B')\n            elif MAP[y][x][1]==-1:\n                fill(MAP,[x,y],'W')\n    countB,countW=countMAP(MAP)\n    print(countB,countW)\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\ndef dfs(x, y, symbol,land):\n    if land[y][x] != '.':\n        return ([land[y][x]] if not str(land[y][x]).isnumeric() else False), 0\n    land[y][x] = symbol\n    count = 1\n    dxdy = [(1,0),(-1,0),(0,1),(0,-1)]\n\n    owner_list = []\n    for dx,dy in dxdy:\n        if 0 <= x + dx < len(land[0]) and 0 <= y + dy < len(land):\n            ret,c = dfs(x + dx, y + dy, symbol,land)\n            count += c\n\n            if ret is not False:\n                owner_list += ret\n    return (list(set(owner_list)), count)\n\nwhile True:\n    w,h = map(int,input().split())\n    if w == 0 and h == 0:\n        break\n    land = [list(input()) for i in range(0,h)]\n\n    symbol = 0\n    count_dict = {'W' :0, 'B' :0}\n\n    for y in range(h):\n        for x in range(w):\n            if land[y][x] == '.':\n                ret, count = dfs(x,y,symbol,land)\n                if len(ret) == 1:\n                    count_dict[ret[0]] += count\n                symbol += 1\n    print(count_dict['B'],count_dict['W'])"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict,deque\nimport sys,heapq,bisect,math,itertools,string,queue,copy,time\nsys.setrecursionlimit(10**8)\nINF = float('inf')\nmod = 10**9+7\neps = 10**-7\ndef inp(): return int(input())\ndef inpl(): return list(map(int, input().split()))\ndef inpl_str(): return list(input().split())\n\ndef dfs(x,y):\n    global st\n    global visited\n    global ans\n\n    if MAP[y][x] == '#':\n        ans |= 0\n        return\n    elif MAP[y][x] == 'B':\n        ans |= 1\n        return\n    elif MAP[y][x] == 'W':\n        ans |= 2\n        return\n    else:\n        visited[y][x] = True\n        st.add((x,y))\n        if not visited[y][x+1]:\n            dfs(x+1,y)\n        if not visited[y][x-1]:\n            dfs(x-1,y)\n        if not visited[y+1][x]:\n            dfs(x,y+1)\n        if not visited[y-1][x]:\n            dfs(x,y-1)\n        return\n\nwhile True:\n    W,H = inpl()\n    if W == 0:\n        break\n    else:\n        MAP = []\n        MAP.append(['#']*(W+2))\n        for _ in range(H):\n            MAP.append(['#']+list(input())+['#'])\n        MAP.append(['#']*(W+2))\n\n        visited = [[False]*(W+2) for _ in range(H+2)]\n        dp = [[-1]*(W+2) for _ in range(H+2)]\n        ansb = answ = 0\n        for y0 in range(1,H+1):\n            for x0 in range(1,W+1):\n                if not visited[y0][x0]:\n                    st = set([])\n                    ans = 0\n                    dfs(x0,y0)\n                    for x,y in st:\n                        dp[y][x] = ans\n\n        #for d in dp:\n        #    print(' '.join([str(k).rjust(2) for k in d]))\n\n        answ = ansb = 0\n        for d in dp:\n            answ += d.count(2)\n            ansb += d.count(1)\n\n        print(ansb,answ)\n\n"
  },
  {
    "language": "Python",
    "code": "def fill(MAP,xy,stick):\n    global w,h\n    if stick=='B': sflag=0\n    else: sflag=1\n    x,y=(xy[0],xy[1])\n    if MAP[y][x][sflag]==0: MAP[y][x][sflag]=1\n    xlist=[1,-1,0,0]\n    ylist=[0,0,1,-1]\n    for dx,dy in zip(xlist,ylist):\n        nx=x+dx\n        ny=y+dy\n        if 0<=nx<w and 0<=ny<h:\n            if  MAP[ny][nx][0]==-1 or MAP[ny][nx][1]==-1:\n                continue\n            elif MAP[ny][nx][sflag]==0:\n                fill(MAP,[nx,ny],stick)\n\ndef countMAP(MAP):\n    global w,h\n    countB=0\n    countW=0\n    for x in range(w):\n        for y in range(h):\n            if MAP[y][x]==[1,0]:\n                countB+=1\n            elif MAP[y][x]==[0,1]:\n                countW+=1\n    return countB,countW\n\nwhile  True:\n    w,h=map(int,input().split())\n    if w==h==0: break\n    MAP=[]\n    for i in range(h):\n        temp=input()\n        MAP.append([])\n        for j in range(w):\n            if temp[j]=='.': MAP[i].append([0,0])\n            elif temp[j]=='B': MAP[i].append([-1,0])\n            else: MAP[i].append([0,-1])\n    for y in range(h):\n        for x in range(w):\n            if MAP[y][x][0]==-1:\n                fill(MAP,[x,y],'B')\n            elif MAP[y][x][1]==-1:\n                fill(MAP,[x,y],'W')\n    countB,countW=countMAP(MAP)\n    print(countB,countW)\n"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom collections import Counter\n\nsys.set_coroutine_wrapper(2500)\n\n\ndef paint(field, i, j, b, f, moves={(-1, 0), (1, 0), (0, 1), (0, -1)}):\n    fij = field[i][j]\n    if fij & f:\n        return\n    if fij & 4 and not fij & b:\n        return\n    field[i][j] |= b | f\n    for di, dj in moves:\n        ni = i + di\n        nj = j + dj\n        if nj < 0 or w <= nj or ni < 0 or h <= ni:\n            continue\n        paint(field, ni, nj, b, f)\n\n\nbuf = []\nchardict = {'.': 0, 'W': 5, 'B': 6}\nwhile True:\n    w, h = map(int, input().split())\n    if w == 0:\n        break\n    field = []\n    init_w, init_b = 0, 0\n    for _ in range(h):\n        line = input().strip()\n        init_w += line.count('W')\n        init_b += line.count('B')\n        field.append([chardict[c] for c in line])\n    for i in range(h):\n        for j in range(w):\n            fij = field[i][j]\n            if fij & 4 and not fij & 24:\n                paint(field, i, j, fij & 3, (fij & 3) << 3)\n    result = Counter(b & 3 for row in field for b in row)\n    print(result[2] - init_b, result[1] - init_w)"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom collections import Counter\n\nsys.setrecursionlimit(2502)\n\n\ndef paint(field, i, j, b, f, moves={(-1, 0), (1, 0), (0, 1), (0, -1)}):\n    fij = field[i][j]\n    if fij & f:\n        return\n    if fij & 4 and not fij & b:\n        return\n    field[i][j] |= b | f\n    for di, dj in moves:\n        ni = i + di\n        nj = j + dj\n        if nj < 0 or w <= nj or ni < 0 or h <= ni:\n            continue\n        paint(field, ni, nj, b, f)\n\n\nbuf = []\nchardict = {'.': 0, 'W': 5, 'B': 6}\nwhile True:\n    w, h = map(int, input().split())\n    if w == 0:\n        break\n    field = []\n    init_w, init_b = 0, 0\n    for _ in range(h):\n        line = input().strip()\n        init_w += line.count('W')\n        init_b += line.count('B')\n        field.append([chardict[c] for c in line])\n    for i in range(h):\n        for j in range(w):\n            fij = field[i][j]\n            if fij & 4 and not fij & 24:\n                paint(field, i, j, fij & 3, (fij & 3) << 3)\n    result = Counter(b & 3 for row in field for b in row)\n    print(result[2] - init_b, result[1] - init_w)"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(3000)\ndef rec(x,y,c):\n    if   A[y][x] == \".\": A[y][x] = c\n    elif A[y][x] != c  : A[y][x] = \"x\"\n    for dx,dy in zip([1,0,-1,0],[0,1,0,-1]):\n        nx,ny = x+dx,y+dy\n        if 0 <= nx < w and 0 <= ny < h and A[ny][nx] in [\".\",\"b\" if c == \"w\" else \"w\"]:\n            rec(nx,ny,c)\n\nwhile 1:\n    w,h = map(int,raw_input().split())\n    if w == 0: break\n    A = [list(raw_input()) for _ in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if A[y][x] == \"W\": rec(x,y,\"w\")\n            if A[y][x] == \"B\": rec(x,y,\"b\")\n    print sum(Ai.count(\"b\") for Ai in A),sum(Ai.count(\"w\") for Ai in A)"
  },
  {
    "language": "Python",
    "code": "class Area:\n    def __init__(self,m,x,y):\n        self.m = m\n        self.f_W = False\n        self.f_B = False\n        self.side = 0\n        self.count = 0\n        self.standardx = x\n        self.standardy = y\n        self.check(x,y)\n        self.getSide()\n    def check(self,x,y):\n        if(y<0 or y >= len(m) or x<0 or x>=len(m[0])):\n            return\n        c = self.m[y][x]\n        if(c!=0):\n            if(c==1):\n                self.f_B=True\n            if(c==2):\n                self.f_W=True\n            return\n        else:\n            if(c==0):\n                self.m[y][x]=3\n                self.count += 1\n                self.check(x-1,y)\n                self.check(x+1,y)\n                self.check(x,y-1)\n                self.check(x,y+1)\n    def getSide(self):\n        if(self.f_B and self.f_W):\n            self.side = 0\n        elif(self.f_B):\n            self.side = 1\n        elif(self.f_W):\n            self.side = 2\n        else:\n            self.side = 0\n        return self.side\n            \n\n\n\nwhile True:\n    w,h = map(int,raw_input().split())\n    if(not w) :\n        break\n    m = []\n    for i in range(h):\n        m.append([])\n        l = raw_input()\n        for ii in range(w):\n            dic = {\".\":0,\"B\":1,\"W\":2}\n            m[i].append(dic[l[ii]])\n\n    B = 0\n    W = 0\n    for i,l in enumerate(m):\n        for ii,c in enumerate(l):\n            if(c==0):\n                a = Area(m,ii,i)\n                if(a.getSide() == 1):\n                    B += a.count\n                elif(a.getSide() == 2):\n                    W += a.count\n    print B,W"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(3000)\ndef dfs(r, c, n):\n    board[r][c] = n\n    drc = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    for dr, dc in drc:\n        nr, nc = r + dr, c + dc\n        if 0 <= nr < h and 0 <= nc < w and board[nr][nc] != n:\n            if board[nr][nc] in 'WB':\n                pile.append(board[nr][nc])\n                continue\n            dfs(nr, nc, n)\n\nwhile True:\n    w, h = map(int, input().split())\n    if w == 0 and h == 0: break\n    board = [list(input()) for _ in range(h)]\n    place = 0\n    piles = []\n    black, white = [], []\n    for r in range(h):\n        for c in range(w):\n            if board[r][c] == '.':\n                pile = []\n                place += 1\n                dfs(r, c, place)\n                piles.append(pile)\n\n    for i, pile in enumerate(piles):\n        if not pile: continue\n        if all(p == 'B' for p in pile):\n            black.append(i+1)\n        elif all(p == 'W' for p in pile):\n            white.append(i+1)\n\n    ans_b, ans_w = 0, 0\n    for row in board:\n        for c in row:\n            if c in black:\n                ans_b += 1\n            elif c in white:\n                ans_w += 1\n    print(ans_b, ans_w)"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(3000)\ndef dfs(r, c, n):\n    board[r][c] = n\n    drc = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    for dr, dc in drc:\n        nr, nc = r + dr, c + dc\n        if 0 <= nr < h and 0 <= nc < w and board[nr][nc] != n:\n            if board[nr][nc] in 'WB':\n                pile.append(board[nr][nc])\n                continue\n            dfs(nr, nc, n)\n\nwhile True:\n    w, h = map(int, input().split())\n    if w == 0 and h == 0: break\n    board = [list(input()) for _ in range(h)]\n    place = 0\n    piles = []\n    black, white = [], []\n    for r in range(h):\n        for c in range(w):\n            if board[r][c] == '.':\n                pile = []\n                place += 1\n                dfs(r, c, place)\n                piles.append(pile)\n    for i, pile in enumerate(piles):\n        if not pile: continue\n        if all(p == 'B' for p in pile):\n            black.append(i)\n        elif all(p == 'W' for p in pile):\n            white.append(i)\n\n    ans_b, ans_w = 0, 0\n    for row in board:\n        for c in row:\n            if c in black:\n                ans_b += 1\n            elif c in white:\n                ans_w += 1\n    print(ans_b, ans_w)"
  },
  {
    "language": "Python",
    "code": "from collections import deque\ndxy = [[0, 1], [1, 0], [-1, 0], [0, -1]]\n\n\ndef which(x, y, map):\n    if(map[x][y] != \".\" ):\n        return (True, 0)\n    else:\n        Q = deque()\n        W, H = len(map[0]), len(map)\n        map[x][y] = \"#\"\n        Q.append((x, y))\n        # 0,12, \n        Black, White = False, False\n        res = 1\n        while(len(Q) != 0):\n            now = Q.popleft()\n            for d in dxy:\n                tx, ty = now[0]+d[0], now[1]+d[1]\n                # \n                if 0 <= tx <= H-1 and 0 <= ty <= W-1:\n                    if map[tx][ty] == \".\":\n                        map[tx][ty] = \"#\"\n                        res += 1\n                        Q.append((tx, ty))\n                    elif map[tx][ty] == \"B\":\n                        Black = True\n                    elif map[tx][ty] == \"W\":\n                        White = True\n    # True 0\n    return (Black, res) if Black ^ White else (True, 0)\n\n\n\n\nwhile(True):\n    # .BFSWW\n    W, H = [int(n) for n in input().split()]\n    V = [[False for _ in range(W)]for __ in range(H)]\n    if W+H == 0:\n        break\n    map = [\"\" for _ in range(H)]\n    for i in range(H):\n        map[i] = list(str(input()))\n    b = 0\n    w = 0\n    for i in range(H):\n        for j in range(W):\n            Black, cnt = which(i, j, map)\n            if Black:\n                b += cnt\n            else:\n                w += cnt\n    # for i in range(H):\n    #     print(map[i])\n    print(b, w)\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom collections import Counter\n\nsys.setrecursionlimit(2502)\n\n\ndef paint(field, i, j, b, f, moves={(-1, 0), (1, 0), (0, 1), (0, -1)}):\n    fij = field[i][j]\n    if fij & f:\n        return\n    if fij & 4 and not fij & b:\n        return\n    field[i][j] |= b | f\n    for di, dj in moves:\n        ni = i + di\n        nj = j + dj\n        if nj < 0 or w <= nj or ni < 0 or h <= ni:\n            continue\n        paint(field, ni, nj, b, f)\n\n\nbuf = []\nchardict = {'.': 0, 'W': 5, 'B': 6}\nwhile True:\n    w, h = map(int, input().split())\n    if w == 0:\n        break\n    field = [[chardict[c] for c in input()] for _ in range(h)]\n    for i in range(h):\n        for j in range(w):\n            fij = field[i][j]\n            if fij & 4 and not fij & 24:\n                paint(field, i, j, fij & 3, (fij & 3) << 3)\n    result = Counter(b & 7 for row in field for b in row)\n    buf.append('{} {}'.format(result[2], result[1]))\nprint('\\n'.join(buf))"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(3000)\ndef dfs(r, c, n):\n    board[r][c] = n\n    drc = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n    for dr, dc in drc:\n        nr, nc = r + dr, c + dc\n        if 0 <= nr < h and 0 <= nc < w and board[nr][nc] != n:\n            if board[nr][nc] in 'WB':\n                pile.append(board[nr][nc])\n                continue\n            dfs(nr, nc, n)\n\nwhile True:\n    w, h = map(int, input().split())\n    if w == 0 and h == 0: break\n    board = [list(input()) for _ in range(h)]\n    place = 0\n    piles = []\n    black, white = [], []\n    for r in range(h):\n        for c in range(w):\n            if board[r][c] == '.':\n                pile = []\n                place += 1\n                dfs(r, c, place)\n                piles.append(pile)\n    for i, pile in enumerate(piles):\n        if not pile: continue\n        for p in pile:\n            if p != 'B':\n                break\n        else:\n            black.append(i+1)\n        for p in pile:\n            if p != 'W':\n                break\n        else:\n            white.append(i+1)\n    ans_b, ans_w = 0, 0\n    for row in board:\n        for c in row:\n            if c in black:\n                ans_b += 1\n            elif c in white:\n                ans_w += 1\n    print(ans_b, ans_w)"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(1000000)\n\nwhile True:\n  w, h = map(int, input().split())\n  if w == 0:\n    break\n\n  mp = [\"X\" + input() + \"X\" for _ in range(h)]\n  mp.insert(0, \"X\" * (w + 2))\n  mp.append(\"X\" * (w + 2))\n\n  visited_w = [[False] * (w + 2) for _ in range(h + 2)]\n  visited_b = [[False] * (w + 2) for _ in range(h + 2)]\n  vec = ((0, 1), (0, -1), (1, 0), (-1, 0))\n  def search(x, y, visited):\n    for dx, dy in vec:\n      nx, ny = x + dx, y + dy\n      if not visited[ny][nx] and mp[ny][nx] == \".\":\n        visited[ny][nx] = True\n        search(nx, ny, visited)\n  \n  for y in range(1, h + 1):\n    for x in range(1, w + 1):\n      if mp[y][x] == \"W\":\n        search(x, y, visited_w)\n      elif mp[y][x] == \"B\":\n        search(x, y, visited_b)\n\n  ans_w = ans_b = 0\n  for y in range(1, h + 1):\n    for x in range(1, w + 1):\n      if visited_w[y][x] and not visited_b[y][x]:\n        ans_w += 1\n      elif not visited_w[y][x] and visited_b[y][x]:\n        ans_b += 1\n\n  print(ans_b, ans_w)\n\n"
  },
  {
    "language": "Python",
    "code": "#! /usr/bin/python\n# -*- coding: utf-8 -*-\n\ndef dfs(Map, used, i, j):\n    cnt = 0\n    wc = False\n    bc = False\n    q = [[i, j]]\n    used[i][j] = True\n    while q!=[]:\n        cnt += 1\n        i = q[0][0]\n        j = q[0][1]\n        if Map[i][j] == 'W':\n            wc = True\n        elif Map[i][j] == 'B':\n            bc = True\n        q.pop(0)\n        if i-1>=0:\n            if Map[i-1][j] == 'W':\n                wc = True\n            elif Map[i-1][j] == 'B':\n                bc = True\n            elif used[i-1][j] == False:\n                q.append([i-1, j])\n                used[i-1][j] = True\n        if i+1<len(used):\n            if Map[i+1][j] == 'W':\n                wc = True\n            elif Map[i+1][j] == 'B':\n                bc = True\n            elif used[i+1][j] == False:\n                q.append([i+1, j])\n                used[i+1][j] = True\n        if j-1>=0:\n            if Map[i][j-1] == 'W':\n                wc = True\n            elif Map[i][j-1] == 'B':\n                bc = True\n            elif used[i][j-1] == False:\n                q.append([i, j-1])\n                used[i][j-1] = True\n        if j+1<len(used[i]):\n            if Map[i][j+1] == 'W':\n                wc = True\n            elif Map[i][j+1] == 'B':\n                bc = True\n            elif used[i][j+1] == False:\n                q.append([i, j+1])\n                used[i][j+1] = True\n    if wc == True and bc == True:\n        return int(0)\n    elif wc == True:\n        return -int(cnt)\n    elif bc == True:\n        return int(cnt)\n    else:\n        return 0\n\nwhile 1:\n    (w, h) = map(int, raw_input().split())\n    if w==0: break\n    M = []\n    [wr, br] = [0, 0]\n    for i in range(h):\n        M.append(raw_input())\n    used = [[False]*w for i in range(h)]\n    for i in range(h):\n        for j in range(w):\n            if M[i][j] in ('W','B'): used[i][j] = True\n    for i in range(h):\n        for j in range(w):\n            if used[i][j] == False:\n                s = dfs(M, used, i, j)\n                if s < 0:\n                    wr -= s\n                elif s > 0:\n                    br += s\n    print br, wr\n            "
  },
  {
    "language": "Python",
    "code": "class Area:\n    def __init__(self,m,x,y):\n        self.m = m\n        self.f_W = False\n        self.f_B = False\n        self.side = 0\n        self.count = 0\n        self.standardx = x\n        self.standardy = y\n        self.check(x,y)\n        self.getSide()\n\n    def check(self,x,y):\n        if(y<0 or y >= len(m) or x<0 or x>=len(m[0])):\n            return\n        c = self.m[y][x]\n        if(c!=0):\n            if(c==1):\n                self.f_B=True\n            if(c==2):\n                self.f_W=True\n            return\n        else:\n            if(c==0):\n                self.m[y][x]=3\n                self.count += 1\n                self.check(x-1,y)\n                self.check(x+1,y)\n                self.check(x,y-1)\n                self.check(x,y+1)\n\n    def getSide(self):\n        if(self.f_B and self.f_W):\n            self.side = 0\n        elif(self.f_B):\n            self.side = 1\n        elif(self.f_W):\n            self.side = 2\n        else:\n            self.side = 0\n        return self.side\n            \n\n\n\nwhile True:\n    w,h = map(int,raw_input().split())\n    if(not w) :\n        break\n    m = []\n    for i in range(h):\n        m.append([])\n        l = raw_input()\n        for ii in range(w):\n            dic = {\".\":0,\"B\":1,\"W\":2}\n            m[i].append(dic[l[ii]])\n    b = 0\n    w = 0\n    for i,l in enumerate(m):\n        for ii,c in enumerate(l):\n            if(c==0):\n                a = Area(m,ii,i)\n                if(a.getSide() == 1):\n                    B += a.count\n                elif(a.getSide() == 2):\n                    W += a.count\n    print B,W"
  },
  {
    "language": "Python",
    "code": "dx=(1,-1,0,0)\ndy=(0,0,1,-1)\n\ndef dfsW(y,x):\n    if L[y][x]==\".\":\n        L[y][x]=\"P\"\n    for i in range(4):\n        mx=x+dx[i]\n        my=y+dy[i]\n        if 0<=mx<w and 0<=my<h and L[my][mx]==\".\":\n            dfsW(my,mx)\n\ndef dfsB(y,x):\n    if L[y][x]==\".\":\n        L[y][x]=\"Q\"\n    elif L[y][x]==\"P\":\n        L[y][x]=\"N\"\n    for i in range(4):\n        mx=x+dx[i]\n        my=y+dy[i]\n        if 0<=mx<w and 0<=my<h and (L[my][mx]==\".\" or L[my][mx]==\"P\"):\n            dfsB(my,mx)\n\nwhile True:\n    w,h=map(int,raw_input().split())\n    if w==h==0:break\n    L=[list(raw_input()) for i in range(h)]\n    for i in range(h):\n        for j in range(w):\n            if L[i][j]==\"W\":\n                dfsW(i,j)\n    for i in range(h):\n        for j in range(w):\n            if L[i][j]==\"B\":\n                dfsB(i,j)\n    cntW=cntB=0\n    for i in range(h):\n\tcntW+=L[i].count(\"P\")\n\tcntB+=L[i].count(\"Q\")\n    print cntB,cntW"
  },
  {
    "language": "Python",
    "code": "\nW = 0\nH = 0\nisland = list()\n\nNOT_SUR = 0\nBLACK = 1\nWHITE = 2\n\ndef read_island():\n    island = list()\n    w, h = map(int, raw_input().split())\n    for i in xrange(h):\n        line = raw_input()\n        chars = list()\n        for ch in line:\n            chars.append(ch)\n        island.append(chars)\n\n    return w, h, island\n\n\ndir_x = [0, 1, 0, -1] # up, right, down, left\ndir_y = [-1, 0, 1, 0]\n\ndef check_ex_adj(x, y, color):\n    global island\n\n    if island[y][x] != \".\":\n        return False\n\n    for i in xrange(4):\n        next_x = x + dir_x[i]\n        next_y = y + dir_y[i]\n        if not (0 <= next_x < W) or not (0 <= next_y < H):\n            continue\n\n        if island[y + dir_y[i]][x + dir_x[i]] == color:\n            return True\n\n    for i in xrange(4):\n        next_x = x + dir_x[i]\n        next_y = y + dir_y[i]\n        if not (0 <= next_x < W) or not (0 <= next_y < H):\n            continue\n\n        island[y][x] = \"B\" if color == \"W\" else \"W\"\n        is_ex_adj = check_ex_adj(next_x, next_y, color)\n        island[y][x] = \".\"\n        if is_ex_adj:\n            return is_ex_adj\n\n    return False\n\n\ndef check_surrounded(x, y):\n    is_adj_b = check_ex_adj(x, y, \"B\")\n    is_adj_w = check_ex_adj(x, y, \"W\")\n\n    if is_adj_b and not is_adj_w:\n        return BLACK\n    elif not is_adj_b and is_adj_w:\n        return WHITE\n\n    return NOT_SUR\n\n\ndef solve():\n    global W\n    global H\n    global island\n    while True:\n        W, H, island = read_island()\n        if W == 0 and H == 0:\n            break\n\n        black_area = 0\n        white_area = 0\n        for x in xrange(W):\n            for y in xrange(H):\n                surrounded_by = check_surrounded(x, y)\n                if surrounded_by == NOT_SUR:\n                    continue\n\n                if surrounded_by == BLACK: # Black\n                    black_area += 1\n                elif surrounded_by == WHITE:\n                    white_area += 1\n\n        print \"{} {}\".format(black_area, white_area)\n\n\nif __name__ == \"__main__\":\n    solve()"
  },
  {
    "language": "Python",
    "code": "import sys\nimport math\n\nwhile True:\n    w, h = map(int, sys.stdin.readline().split())\n    if w == 0:\n        break\n    field = [[-2 for i in xrange(h + 2)] for j in xrange(w + 2)]\n    white = [[0 for i in xrange(h + 2)] for j in xrange(w + 2)]\n    black = [[0 for i in xrange(h + 2)] for j in xrange(w + 2)]\n    \n    cand_white = []\n    cand_black = []\n    for i in xrange(h):\n        line = raw_input()\n        for j in xrange(w):\n            if line[j] == 'W':\n                field[j + 1][i + 1] = 1\n                cand_white.append((j + 1, i + 1))\n            elif line[j] == 'B':\n                field[j + 1][i + 1] = -1\n                cand_black.append((j + 1, i + 1))\n            else:\n                field[j + 1][i + 1] = 0\n    next = [(-1, 0), (1, 0), (0, 1), (0, -1)]\n    while len(cand_white) > 0:\n        cur_x, cur_y = cand_white.pop()\n        for n_x, n_y in next:\n            if field[cur_x + n_x][cur_y + n_y] == 0 and white[cur_x + n_x][cur_y + n_y] == 0:\n                cand_white.append((cur_x + n_x, cur_y + n_y))\n                white[cur_x + n_x][cur_y + n_y] = 1\n    while len(cand_black) > 0:\n        cur_x, cur_y = cand_black.pop()\n        for n_x, n_y in next:\n            if field[cur_x + n_x][cur_y + n_y] == 0 and black[cur_x + n_x][cur_y + n_y] == 0:\n                cand_black.append((cur_x + n_x, cur_y + n_y))\n                black[cur_x + n_x][cur_y + n_y] = 1\n    count_black = 0\n    count_white = 0\n    for i in xrange(h):\n        for j in xrange(w):\n            if white[j + 1][i + 1] > black[j + 1][i + 1]:\n                count_white += 1\n            if black[j + 1][i + 1] > white[j + 1][i + 1]:\n                count_black += 1\n    print count_black, count_white"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom collections import Counter\n\nsys.setrecursionlimit(2502)\n\n\ndef paint(field, i, j, b, f, moves={(-1, 0), (1, 0), (0, 1), (0, -1)}):\n    fij = field[i][j]\n    if fij & f:\n        return\n    if fij & 4 and not fij & b:\n        return\n    field[i][j] |= b | f\n    for di, dj in moves:\n        ni = i + di\n        nj = j + dj\n        if nj < 0 or w <= nj or ni < 0 or h <= ni:\n            continue\n        paint(field, ni, nj, b, f)\n\n\nbuf = []\nchardict = {'.': 0, 'W': 5, 'B': 6}\nwhile True:\n    w, h = map(int, input().split())\n    if w == 0:\n        break\n    field = [[chardict[c] for c in input()] for _ in range(h)]\n    for i in range(h):\n        for j in range(w):\n            fij = field[i][j]\n            if fij & 4 and not fij & 24:\n                paint(field, i, j, fij & 3, (fij & 3) << 3)\n    result = Counter(b & 7 for row in field for b in row)\n    print(result[2], result[1])"
  },
  {
    "language": "Python",
    "code": "class Area:\n    def __init__(self,m,x,y):\n        self.m = m\n        self.f_W = False\n        self.f_B = False\n        self.side = 0\n        self.count = 0\n        self.standardx = x\n        self.standardy = y\n        self.check(x,y)\n        self.getSide()\n\n    def check(self,x,y):\n        if(y<0 or y >= len(m) or x<0 or x>=len(m[0])):\n            return\n        c = self.m[y][x]\n        if(c!=0):\n            if(c==1):\n                self.f_B=True\n            if(c==2):\n                self.f_W=True\n            return\n        else:\n            if(c==0):\n                self.m[y][x]=3\n                self.count += 1\n                self.check(x-1,y)\n                self.check(x+1,y)\n                self.check(x,y-1)\n                self.check(x,y+1)\n\n    def getSide(self):\n        if(self.f_B and self.f_W):\n            self.side = 0\n        elif(self.f_B):\n            self.side = 1\n        elif(self.f_W):\n            self.side = 2\n        else:\n            self.side = 0\n        return self.side\n            \n\n\n\nwhile True:\n    w,h = map(int,raw_input().split())\n    if(not w) :\n        break\n    m = []\n    for i in range(h):\n        m.append([])\n        l = raw_input()\n        for ii in range(w):\n            dic = {\".\":0,\"B\":1,\"W\":2}\n            m[i].append(dic[l[ii]])\n    B = 0\n    W = 0\n    for i,l in enumerate(m):\n        for ii,c in enumerate(l):\n            if(c==0):\n                a = Area(m,ii,i)\n                if(a.getSide() == 1):\n                    B += a.count\n                elif(a.getSide() == 2):\n                    W += a.count\n    print B,W"
  },
  {
    "language": "Python",
    "code": "import sys\ndef ds4(here, lb, ub, field, label):\n\tif not field[here[1]][here[0]][label]:\n\t\tfield[here[1]][here[0]][label] = True\n\t\n\t\tif lb[0] < here[0]:\n\t\t\tds4((here[0]-1, here[1]), lb, ub, field, label)\n\n\t\tif lb[1] < here[1]:\n\t\t\tds4((here[0], here[1]-1), lb, ub, field, label)\n\t\t\t\n\t\tif ub[0] > here[0]:\n\t\t\tds4((here[0]+1, here[1]), lb, ub, field, label)\n\t\t\t\n\t\tif ub[1] > here[1]:\n\t\t\tds4((here[0], here[1]+1), lb, ub, field, label)\n\nsys.setrecursionlimit(10000)\t\nwhile 1:\n\tw,h = map(int,raw_input().split())\n\tif (w,h) == (0,0):\n\t\tbreak\n\tW = []\n\tB = []\n\tisland = [[[False, False] for i in range(w)] for j in range(h)]\n\tfor j in range(h):\n\t\ts = raw_input()\n\t\tfor i in range(w):\n\t\t\tif s[i] == \"B\":\n\t\t\t\tisland[j][i][0] = True\n\t\t\t\tB.append((i,j))\n\t\t\telif s[i] == \"W\":\n\t\t\t\tisland[j][i][1] = True\n\t\t\t\tW.append((i,j))\n\tfor wh in W:\n\t\tds4(wh,(0,0),(w-1,h-1),island,0)\n\tfor bl in B:\n\t\tds4(bl,(0,0),(w-1,h-1),island,1)\n\twnum = bnum = 0\n\tfor j in range(h):\n\t\tfor i in range(w):\n\t\t\tif island[j][i][0]^island[j][i][1]:\t\n\t\t\t\tif island[j][i][0] and not island[j][i][1]:\n\t\t\t\t\twnum += 1\n\t\t\t\telif island[j][i][1] and not island[j][i][0]:\n\t\t\t\t\tbnum += 1\n\tprint bnum, wnum"
  },
  {
    "language": "Python",
    "code": "def bfs(i, j):\n    if a[i][j] == \".\":\n        a[i][j] = \"#\"\n    res=1\n    wc=0\n    bc=0\n    for dy in range(-1, 2):\n        for dx in range(-1, 2):\n            if (dx==0 and dy!=0) or (dx!=0 and dy==0):\n                pass\n            else:\n                continue\n            ny = i+dy\n            nx = j+dx\n\n            if 0<=nx<=w-1 and 0<=ny<=h-1 and a[ny][nx]!=\"#\":\n                if a[ny][nx] == \".\":\n                    wct, bct, rest = bfs(ny, nx)\n                    wc+=wct\n                    bc+=bct\n                    res+=rest\n                elif a[ny][nx]==\"W\":\n                    wc+=1\n                elif a[ny][nx]==\"B\":\n                    bc+=1\n    #print(wc, bc, res)\n    return wc, bc, res\n\nimport sys\nsys.setrecursionlimit(100000)\n\nwhile True:\n    w, h = map(int, input().split())\n    wans = 0\n    bans = 0\n    if w==0 and h==0:\n        break\n    a = [list(input()) for _ in range(h)]\n\n    for i in range(w):\n        for j in range(h):\n            if a[j][i] ==\".\":\n                wc, bc, res = bfs(j, i)\n                if wc>0 and bc==0:\n                    wans+=res\n                elif wc==0 and bc>0:\n                    bans+=res\n    print(bans, wans)\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\ndef dfs(x, y, symbol,land):\n    if land[y][x] != '.':\n        return ([land[y][x]] if not str(land[y][x]).isnumeric() else False), 0\n    land[y][x] = symbol\n    count = 1\n    dxdy = [(1,0),(-1,0),(0,1),(0,-1)]\n\n    owner_list = []\n    for dx,dy in dxdy:\n        if 0 <= x + dx < len(land[0]) and 0 <= y + dy < len(land):\n            ret,c = dfs(x + dx, y + dy, symbol,land)\n            count += c\n\n            if ret is not False:\n                owner_list += ret\n    return (list(set(owner_list)), count)\n\nwhile True:\n    w,h = map(int,input().split())\n    if w == 0 and h == 0:\n        break\n    land = [list(input()) for i in range(0,h)]\n\n    symbol = 0\n    count_dict = {'W' :0, 'B' :0}\n\n    for y in range(h):\n        for x in range(w):\n            if land[y][x] == '.':\n                ret, count = dfs(x,y,symbol,land)\n                if len(ret) == 1:\n                    count_dict[ret[0]] += count\n                symbol += 1\n    print(count_dict['B'],count_dict['W'])"
  },
  {
    "language": "Python",
    "code": "from collections import Counter\n\n\ndef paint(field, i, j, b, f, moves={(-1, 0), (1, 0), (0, 1), (0, -1)}):\n    fij = field[i][j]\n    if fij & f:\n        return\n    if fij & 4 and not fij & b:\n        return\n    field[i][j] |= b | f\n    for di, dj in moves:\n        ni = i + di\n        nj = j + dj\n        if nj < 0 or w <= nj or ni < 0 or h <= ni:\n            continue\n        paint(field, ni, nj, b, f)\n\n\nbuf = []\nchardict = {'.': 0, 'W': 5, 'B': 6}\nwhile True:\n    w, h = map(int, input().split())\n    if w == 0:\n        break\n    field = []\n    init_w, init_b = 0, 0\n    for _ in range(h):\n        line = input().strip()\n        init_w += line.count('W')\n        init_b += line.count('B')\n        field.append([chardict[c] for c in line])\n    for i in range(h):\n        for j in range(w):\n            fij = field[i][j]\n            if fij & 4 and not fij & 24:\n                paint(field, i, j, fij & 3, (fij & 3) << 3)\n    result = Counter(b & 3 for row in field for b in row)\n    print(result[2] - init_b, result[1] - init_w)"
  },
  {
    "language": "Python",
    "code": "class Area:\n    def __init__(self,m,x,y):\n        self.m = m\n        self.f_W = False\n        self.f_B = False\n        self.side = 0\n        self.count = 0\n        self.standardx = x\n        self.standardy = y\n        self.check(x,y)\n        self.getSide()\n    def check(self,x,y):\n        if(y<0 or y >= len(m) or x<0 or x>=len(m[0])):\n            return\n        c = self.m[y][x]\n        if(c!=0):\n            if(c==1):\n                self.f_B=True\n            if(c==2):\n                self.f_W=True\n            return\n        else:\n            if(c==0):\n                self.m[y][x]=3\n                self.count += 1\n                self.check(x-1,y)\n                self.check(x+1,y)\n                self.check(x,y-1)\n                self.check(x,y+1)\n    def getSide(self):\n        if(self.f_B and self.f_W):\n            self.side = 0\n        elif(self.f_B):\n            self.side = 1\n        elif(self.f_W):\n            self.side = 2\n        else:\n            self.side = 0\n        return self.side\n            \n\n\n\nwhile True:\n    w,h = map(int,raw_input().split())\n    if(not w) :\n        break\n    m = []\n    for i in range(h):\n        m.append([])\n        l = raw_input()\n        for ii in range(w):\n            dic = {\".\":0,\"B\":1,\"W\":2}\n            m[i].append(dic[l[ii]])\n\n    B = 0\n    W = 0\n    for i,l in enumerate(m):\n        for ii,c in enumerate(l):\n            if(c==0):\n                a = Area(m,ii,i)\n                if(a.getSide() == 1):\n                    B += a.count\n                elif(a.getSide() == 2):\n                    W += a.count\n    print B,W"
  },
  {
    "language": "Python",
    "code": "def rec(x,y,c):\n    if   A[y][x] == \".\": A[y][x] = c\n    elif A[y][x] != c  : A[y][x] = \"x\"\n    for dx,dy in zip([1,0,-1,0],[0,1,0,-1]):\n        nx,ny = x+dx,y+dy\n        if 0 <= nx < w and 0 <= ny < h and A[ny][nx] in [\".\",\"b\" if c == \"w\" else \"w\"]:\n            rec(nx,ny,c)\n\nwhile 1:\n    w,h = map(int,raw_input().split())\n    if w == 0: break\n    A = [list(raw_input()) for _ in range(h)]\n    for y in range(h):\n        for x in range(w):\n            if A[y][x] == \"W\": rec(x,y,\"w\")\n            if A[y][x] == \"B\": rec(x,y,\"b\")\n    print sum(Ai.count(\"b\") for Ai in A),sum(Ai.count(\"w\") for Ai in A)"
  }
]