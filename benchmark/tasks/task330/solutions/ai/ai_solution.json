[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_SIZE 100\n\ntypedef struct {\n    int x, y;\n} Point;\n\nchar grid[MAX_SIZE][MAX_SIZE];\nint visited[MAX_SIZE][MAX_SIZE];\nint rows, cols;\nint directions[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\nint bfs(int x, int y, char stake) {\n    Point queue[MAX_SIZE * MAX_SIZE];\n    int front = 0, rear = 0;\n    queue[rear++] = (Point){x, y};\n    visited[x][y] = 1;\n    int count = 1;\n    int is_surrounded = 1;\n\n    while (front < rear) {\n        Point p = queue[front++];\n        for (int i = 0; i < 4; i++) {\n            int nx = p.x + directions[i][0];\n            int ny = p.y + directions[i][1];\n            if (nx < 0 || nx >= rows || ny < 0 || ny >= cols) {\n                is_surrounded = 0;\n                continue;\n            }\n            if (!visited[nx][ny] && grid[nx][ny] == '.') {\n                visited[nx][ny] = 1;\n                queue[rear++] = (Point){nx, ny};\n                count++;\n            }\n        }\n    }\n    return is_surrounded ? count : 0;\n}\n\nvoid solve() {\n    while (1) {\n        scanf(\"%d %d\", &rows, &cols);\n        if (rows == 0 && cols == 0) break;\n        for (int i = 0; i < rows; i++) {\n            scanf(\"%s\", grid[i]);\n        }\n\n        memset(visited, 0, sizeof(visited));\n        int black_area = 0, white_area = 0;\n\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                if (grid[i][j] == '.' && !visited[i][j]) {\n                    int area = bfs(i, j, 'B');\n                    black_area += area;\n                }\n            }\n        }\n\n        memset(visited, 0, sizeof(visited));\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                if (grid[i][j] == '.' && !visited[i][j]) {\n                    int area = bfs(i, j, 'W');\n                    white_area += area;\n                }\n            }\n        }\n\n        printf(\"%d %d\\n\", black_area, white_area);\n    }\n}\n\nint main() {\n    solve();\n    return 0;\n}",
    "timestamp": "2025-08-05 21:06:02"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nconst int dx[] = {1, -1, 0, 0};\nconst int dy[] = {0, 0, 1, -1};\n\nvoid bfs(int i, int j, vector<vector<char>>& grid, vector<vector<bool>>& visited, char stake, bool& surrounded, int& count) {\n    queue<pair<int, int>> q;\n    q.push({i, j});\n    visited[i][j] = true;\n    count = 1;\n    surrounded = true;\n\n    while (!q.empty()) {\n        auto [x, y] = q.front();\n        q.pop();\n\n        for (int d = 0; d < 4; ++d) {\n            int nx = x + dx[d];\n            int ny = y + dy[d];\n\n            if (nx < 0 || nx >= grid.size() || ny < 0 || ny >= grid[0].size()) {\n                surrounded = false;\n                continue;\n            }\n\n            if (grid[nx][ny] == '.' && !visited[nx][ny]) {\n                visited[nx][ny] = true;\n                q.push({nx, ny});\n                count++;\n            } else if (grid[nx][ny] != stake) {\n                surrounded = false;\n            }\n        }\n    }\n}\n\nvoid solve(vector<vector<char>>& grid) {\n    int black = 0, white = 0;\n    int rows = grid.size();\n    if (rows == 0) {\n        cout << \"0 0\\n\";\n        return;\n    }\n    int cols = grid[0].size();\n    vector<vector<bool>> visited(rows, vector<bool>(cols, false));\n\n    for (int i = 0; i < rows; ++i) {\n        for (int j = 0; j < cols; ++j) {\n            if (grid[i][j] == '.' && !visited[i][j]) {\n                bool surroundedB = false, surroundedW = false;\n                int countB = 0, countW = 0;\n\n                bool tempB = false, tempW = false;\n                int tempCount = 0;\n\n                bfs(i, j, grid, visited, 'B', tempB, tempCount);\n                if (tempB) {\n                    surroundedB = true;\n                    countB = tempCount;\n                }\n\n                tempB = false;\n                tempCount = 0;\n                vector<vector<bool>> visited2(rows, vector<bool>(cols, false));\n                bfs(i, j, grid, visited2, 'W', tempW, tempCount);\n                if (tempW) {\n                    surroundedW = true;\n                    countW = tempCount;\n                }\n\n                if (surroundedB && !surroundedW) {\n                    black += countB;\n                } else if (surroundedW && !surroundedB) {\n                    white += countW;\n                }\n            }\n        }\n    }\n\n    cout << black << \" \" << white << \"\\n\";\n}\n\nint main() {\n    int rows, cols;\n    while (cin >> rows >> cols) {\n        vector<vector<char>> grid(rows, vector<char>(cols));\n        for (int i = 0; i < rows; ++i) {\n            for (int j = 0; j < cols; ++j) {\n                cin >> grid[i][j];\n            }\n        }\n        solve(grid);\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 21:07:03"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    static int rows, cols;\n    static char[][] grid;\n    static boolean[][] visited;\n    static int[] dx = { -1, 1, 0, 0 };\n    static int[] dy = { 0, 0, -1, 1 };\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        while (scanner.hasNext()) {\n            rows = scanner.nextInt();\n            cols = scanner.nextInt();\n            if (rows == 0 && cols == 0) break;\n            grid = new char[rows][cols];\n            for (int i = 0; i < rows; i++) {\n                String line = scanner.next();\n                for (int j = 0; j < cols; j++) {\n                    grid[i][j] = line.charAt(j);\n                }\n            }\n\n            int blackArea = 0;\n            int whiteArea = 0;\n            visited = new boolean[rows][cols];\n\n            for (int i = 0; i < rows; i++) {\n                for (int j = 0; j < cols; j++) {\n                    if (grid[i][j] == '.' && !visited[i][j]) {\n                        boolean[] encountered = new boolean[2]; // 0: B, 1: W\n                        int area = dfs(i, j, encountered);\n                        if (encountered[0] && !encountered[1]) {\n                            blackArea += area;\n                        } else if (encountered[1] && !encountered[0]) {\n                            whiteArea += area;\n                        }\n                    }\n                }\n            }\n\n            System.out.println(blackArea + \" \" + whiteArea);\n        }\n        scanner.close();\n    }\n\n    static int dfs(int x, int y, boolean[] encountered) {\n        if (x < 0 || x >= rows || y < 0 || y >= cols) {\n            return 0;\n        }\n        if (grid[x][y] == 'B') {\n            encountered[0] = true;\n            return 0;\n        }\n        if (grid[x][y] == 'W') {\n            encountered[1] = true;\n            return 0;\n        }\n        if (visited[x][y]) {\n            return 0;\n        }\n        visited[x][y] = true;\n        int area = 1;\n        for (int i = 0; i < 4; i++) {\n            area += dfs(x + dx[i], y + dy[i], encountered);\n        }\n        return area;\n    }\n}",
    "timestamp": "2025-08-05 21:07:25"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class StakeTerritory {\n    static char[][] grid;\n    static boolean[][] visited;\n    static int rows, cols;\n    static int[] dx = {0, 0, 1, -1};\n    static int[] dy = {1, -1, 0, 0};\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        while (sc.hasNextInt()) {\n            rows = sc.nextInt();\n            cols = sc.nextInt();\n            \n            if (rows == 0 && cols == 0) break;\n            \n            grid = new char[rows][cols];\n            visited = new boolean[rows][cols];\n            \n            for (int i = 0; i < rows; i++) {\n                grid[i] = sc.next().toCharArray();\n            }\n            \n            int blackArea = 0, whiteArea = 0;\n            \n            for (int i = 0; i < rows; i++) {\n                for (int j = 0; j < cols; j++) {\n                    if (!visited[i][j] && grid[i][j] == '.') {\n                        int[] result = bfs(i, j);\n                        if (result[0] == 1) blackArea += result[1];\n                        else if (result[0] == 2) whiteArea += result[1];\n                    }\n                }\n            }\n            \n            System.out.println(blackArea + \" \" + whiteArea);\n        }\n        \n        sc.close();\n    }\n    \n    static int[] bfs(int startX, int startY) {\n        Queue<int[]> queue = new LinkedList<>();\n        Set<Character> boundaryStakes = new HashSet<>();\n        int area = 0;\n        \n        queue.offer(new int[]{startX, startY});\n        visited[startX][startY] = true;\n        \n        while (!queue.isEmpty()) {\n            int[] curr = queue.poll();\n            int x = curr[0], y = curr[1];\n            area++;\n            \n            for (int i = 0; i < 4; i++) {\n                int nx = x + dx[i], ny = y + dy[i];\n                \n                if (nx < 0 || nx >= rows || ny < 0 || ny >= cols) {\n                    boundaryStakes.add('O');\n                    continue;\n                }\n                \n                if (grid[nx][ny] == 'B' || grid[nx][ny] == 'W') {\n                    boundaryStakes.add(grid[nx][ny]);\n                }\n                \n                if (!visited[nx][ny] && grid[nx][ny] == '.') {\n                    queue.offer(new int[]{nx, ny});\n                    visited[nx][ny] = true;\n                }\n            }\n        }\n        \n        if (boundaryStakes.size() == 1) {\n            if (boundaryStakes.contains('B')) return new int[]{1, area};\n            if (boundaryStakes.contains('W')) return new int[]{2, area};\n        }\n        \n        return new int[]{0, 0};\n    }\n}",
    "timestamp": "2025-08-05 21:07:35"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MAX_SIZE 50\n\nchar grid[MAX_SIZE][MAX_SIZE];\nint rows, cols;\nint visited[MAX_SIZE][MAX_SIZE];\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\n\nint is_valid(int x, int y) {\n    return x >= 0 && x < rows && y >= 0 && y < cols;\n}\n\nint is_surrounded(int x, int y, char color) {\n    for (int i = 0; i < 4; i++) {\n        int nx = x, ny = y;\n        int blocked = 0;\n        \n        while (is_valid(nx, ny)) {\n            if (grid[nx][ny] == color) {\n                blocked = 1;\n                break;\n            }\n            nx += dx[i];\n            ny += dy[i];\n        }\n        \n        if (!blocked) return 0;\n    }\n    return 1;\n}\n\nvoid dfs(int x, int y, char color, int* area) {\n    if (!is_valid(x, y) || visited[x][y] || grid[x][y] != '.') return;\n    \n    visited[x][y] = 1;\n    (*area)++;\n    \n    for (int i = 0; i < 4; i++) {\n        dfs(x + dx[i], y + dy[i], color, area);\n    }\n}\n\nint main() {\n    while (scanf(\"%d %d\", &rows, &cols) == 2 && rows && cols) {\n        memset(grid, 0, sizeof(grid));\n        memset(visited, 0, sizeof(visited));\n        \n        for (int i = 0; i < rows; i++) {\n            scanf(\"%s\", grid[i]);\n        }\n        \n        int black_area = 0, white_area = 0;\n        \n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                if (grid[i][j] == '.' && !visited[i][j]) {\n                    int area = 0;\n                    dfs(i, j, '.', &area);\n                    \n                    if (is_surrounded(i, j, 'B')) {\n                        black_area += area;\n                    } else if (is_surrounded(i, j, 'W')) {\n                        white_area += area;\n                    }\n                }\n            }\n        }\n        \n        printf(\"%d %d\\n\", black_area, white_area);\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:07:44"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\n\nbool isValid(int x, int y, int rows, int cols) {\n    return x >= 0 && x < rows && y >= 0 && y < cols;\n}\n\npair<int, int> calculateSurroundedArea(vector<vector<char>>& grid) {\n    int rows = grid.size();\n    int cols = grid[0].size();\n    vector<vector<bool>> visitedBlack(rows, vector<bool>(cols, false));\n    vector<vector<bool>> visitedWhite(rows, vector<bool>(cols, false));\n    \n    int blackArea = 0;\n    int whiteArea = 0;\n    \n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            if (grid[i][j] == '.' && !visitedBlack[i][j]) {\n                bool surroundedByBlack = true;\n                bool surroundedByWhite = true;\n                int area = 0;\n                \n                queue<pair<int, int>> q;\n                q.push({i, j});\n                visitedBlack[i][j] = true;\n                \n                while (!q.empty()) {\n                    int x = q.front().first;\n                    int y = q.front().second;\n                    q.pop();\n                    area++;\n                    \n                    for (int k = 0; k < 4; k++) {\n                        int nx = x + dx[k];\n                        int ny = y + dy[k];\n                        \n                        if (!isValid(nx, ny, rows, cols)) {\n                            surroundedByBlack = false;\n                            surroundedByWhite = false;\n                            break;\n                        }\n                        \n                        if (grid[nx][ny] == 'B') {\n                            surroundedByWhite = false;\n                        }\n                        \n                        if (grid[nx][ny] == 'W') {\n                            surroundedByBlack = false;\n                        }\n                        \n                        if (grid[nx][ny] == '.' && !visitedBlack[nx][ny]) {\n                            q.push({nx, ny});\n                            visitedBlack[nx][ny] = true;\n                        }\n                    }\n                }\n                \n                if (surroundedByBlack) {\n                    blackArea += area;\n                }\n                \n                if (surroundedByWhite) {\n                    whiteArea += area;\n                }\n            }\n        }\n    }\n    \n    return {blackArea, whiteArea};\n}\n\nint main() {\n    int rows, cols;\n    while (cin >> rows >> cols && rows != 0 && cols != 0) {\n        vector<vector<char>> grid(rows, vector<char>(cols));\n        \n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                cin >> grid[i][j];\n            }\n        }\n        \n        pair<int, int> result = calculateSurroundedArea(grid);\n        cout << result.first << \" \" << result.second << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:07:55"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def calculate_areas(grid):\n    def traverse(x, y, color):\n        stack = [(x, y)]\n        area = 0\n        captured = True\n        visited.add((x, y))\n        \n        while stack:\n            cx, cy = stack.pop()\n            if grid[cx][cy] == '.':\n                area += 1\n            for dx, dy in directions:\n                nx, ny = cx + dx, cy + dy\n                if 0 <= nx < len(grid) and 0 <= ny < len(grid[0]):\n                    if (nx, ny) not in visited:\n                        if grid[nx][ny] == color:\n                            continue\n                        visited.add((nx, ny))\n                        if grid[nx][ny] == '.':\n                            stack.append((nx, ny))\n                else:  \n                    captured = False\n        return area if captured else 0\n\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    black_area = 0\n    white_area = 0\n    visited = set()\n\n    for i in range(len(grid)):\n        for j in range(len(grid[0])):\n            if (i, j) not in visited:\n                if grid[i][j] == '.':\n                    black_area += traverse(i, j, 'W')\n                    white_area += traverse(i, j, 'B')\n    \n    return black_area, white_area\n\n\ndef main():\n    import sys\n    input = sys.stdin.read\n    data = input().strip().split('\\n')\n    \n    i = 0\n    while i < len(data):\n        dims = data[i]\n        if len(dims.strip()) == 0:\n            break\n        n, m = map(int, dims.split())\n        grid = [data[i+1+j] for j in range(n)]\n        black_area, white_area = calculate_areas(grid)\n        print(black_area, white_area)\n        i += n + 1\n\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 05:02:31"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class RealEstateIsland {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        while (scanner.hasNext()) {\n            List<String> grid = new ArrayList<>();\n            String line;\n            while (!(line = scanner.nextLine()).isEmpty()) {\n                grid.add(line);\n            }\n            System.out.println(calculateAreas(grid));\n        }\n        scanner.close();\n    }\n\n    private static String calculateAreas(List<String> grid) {\n        int rows = grid.size();\n        if (rows == 0) return \"0 0\";\n        int cols = grid.get(0).length();\n        boolean[][] visitedBlack = new boolean[rows][cols];\n        boolean[][] visitedWhite = new boolean[rows][cols];\n\n        int blackArea = 0;\n        int whiteArea = 0;\n\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                if (grid.get(i).charAt(j) == '.') {\n                    boolean isBlackSurrounded = expand(grid, visitedBlack, i, j, 'B');\n                    boolean isWhiteSurrounded = expand(grid, visitedWhite, i, j, 'W');\n                    if (isBlackSurrounded) {\n                        blackArea++;\n                    }\n                    if (isWhiteSurrounded) {\n                        whiteArea++;\n                    }\n                }\n            }\n        }\n        return blackArea + \" \" + whiteArea;\n    }\n\n    private static boolean expand(List<String> grid, boolean[][] visited, int x, int y, char stakeType) {\n        int rows = grid.size();\n        int cols = grid.get(0).length();\n        if (x < 0 || y < 0 || x >= rows || y >= cols || visited[x][y] || grid.get(x).charAt(y) == stakeType) return true;\n\n        if (grid.get(x).charAt(y) == opposite(stakeType)) return false;\n\n        visited[x][y] = true;\n\n        boolean up = expand(grid, visited, x - 1, y, stakeType);\n        boolean down = expand(grid, visited, x + 1, y, stakeType);\n        boolean left = expand(grid, visited, x, y - 1, stakeType);\n        boolean right = expand(grid, visited, x, y + 1, stakeType);\n\n        return up && down && left && right;\n    }\n\n    private static char opposite(char stakeType) {\n        return stakeType == 'B' ? 'W' : 'B';\n    }\n}",
    "timestamp": "2025-08-13 05:02:39"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_SIZE 100\n\ntypedef struct {\n    int x, y;\n} Point;\n\nint n, m;\nchar grid[MAX_SIZE][MAX_SIZE];\nint visited[MAX_SIZE][MAX_SIZE];\n\nint directions[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\nint bfs_surrounded_area(Point start, char stake) {\n    int isSurrounded = 1;\n    int queueSize = 0;\n    Point queue[MAX_SIZE * MAX_SIZE];\n    int area = 0;\n    \n    visited[start.x][start.y] = 1;\n    queue[queueSize++] = start;\n    \n    for (int front = 0; front < queueSize; front++) {\n        Point current = queue[front];\n        area++;\n        for (int i = 0; i < 4; i++) {\n            Point next = (Point){current.x + directions[i][0], current.y + directions[i][1]};\n            if (next.x < 0 || next.x >= n || next.y < 0 || next.y >= m) {\n                isSurrounded = 0;\n                continue;\n            }\n            if (grid[next.x][next.y] == stake) {\n                continue;\n            }\n            if (grid[next.x][next.y] == '.' && !visited[next.x][next.y]) {\n                visited[next.x][next.y] = 1;\n                queue[queueSize++] = next;\n            }\n        }\n    }\n    return isSurrounded ? area : 0;\n}\n\nint main() {\n    while (scanf(\"%d %d\", &n, &m) != EOF) {\n        for (int i = 0; i < n; i++) {\n            scanf(\"%s\", grid[i]);\n        }\n\n        memset(visited, 0, sizeof(visited));\n\n        int black_area = 0, white_area = 0;\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (grid[i][j] == '.' && !visited[i][j]) {\n                    int result = bfs_surrounded_area((Point){i, j}, 'B');\n                    black_area += result;\n                }\n            }\n        }\n        \n        memset(visited, 0, sizeof(visited));\n        \n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (grid[i][j] == '.' && !visited[i][j]) {\n                    int result = bfs_surrounded_area((Point){i, j}, 'W');\n                    white_area += result;\n                }\n            }\n        }\n\n        printf(\"%d %d\\n\", black_area, white_area);\n    }\n    return 0;\n}",
    "timestamp": "2025-08-13 05:02:51"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def find_territories(grid):\n    rows, cols = len(grid), len(grid[0])\n    black_visited = [[False] * cols for _ in range(rows)]\n    white_visited = [[False] * cols for _ in range(rows)]\n    \n    def is_valid(x, y):\n        return 0 <= x < rows and 0 <= y < cols\n    \n    def is_surrounded(x, y, color, visited):\n        directions = [(0,1), (0,-1), (1,0), (-1,0)]\n        stack = [(x, y)]\n        territory = set([(x, y)])\n        is_surrounded = True\n        \n        while stack:\n            cx, cy = stack.pop()\n            for dx, dy in directions:\n                nx, ny = cx + dx, cy + dy\n                \n                if not is_valid(nx, ny):\n                    is_surrounded = False\n                    continue\n                \n                if grid[nx][ny] == color or visited[nx][ny]:\n                    continue\n                \n                if grid[nx][ny] == '.':\n                    stack.append((nx, ny))\n                    territory.add((nx, ny))\n                    visited[nx][ny] = True\n                else:\n                    is_surrounded = False\n        \n        return territory if is_surrounded else set()\n    \n    black_territory = 0\n    white_territory = 0\n    \n    for r in range(rows):\n        for c in range(cols):\n            if grid[r][c] == '.' and not black_visited[r][c]:\n                territory = is_surrounded(r, c, 'B', black_visited)\n                black_territory += len(territory)\n            \n            if grid[r][c] == '.' and not white_visited[r][c]:\n                territory = is_surrounded(r, c, 'W', white_visited)\n                white_territory += len(territory)\n    \n    return f\"{black_territory} {white_territory}\"\n\ndef main():\n    while True:\n        try:\n            m, n = map(int, input().split())\n            grid = [list(input().strip()) for _ in range(m)]\n            print(find_territories(grid))\n        except EOFError:\n            break\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 05:03:12"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef solve():\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    while True:\n        line = sys.stdin.readline()\n        if not line or line.strip() == '':\n            break\n        \n        h, w = map(int, line.strip().split())\n        grid = []\n        for _ in range(h):\n            grid.append(list(sys.stdin.readline().strip()))\n        \n        black_area = 0\n        white_area = 0\n        \n        visited = [[False for _ in range(w)] for _ in range(h)]\n        \n        for i in range(h):\n            for j in range(w):\n                if grid[i][j] == '.' and not visited[i][j]:\n                    queue = deque()\n                    queue.append((i, j))\n                    visited[i][j] = True\n                    current_area = 1\n                    is_black = None\n                    valid = True\n                    \n                    while queue and valid:\n                        x, y = queue.popleft()\n                        for dx, dy in directions:\n                            nx, ny = x + dx, y + dy\n                            if 0 <= nx < h and 0 <= ny < w:\n                                if grid[nx][ny] == '.':\n                                    if not visited[nx][ny]:\n                                        visited[nx][ny] = True\n                                        current_area += 1\n                                        queue.append((nx, ny))\n                                else:\n                                    if grid[nx][ny] == 'B':\n                                        if is_black is None:\n                                            is_black = True\n                                        elif not is_black:\n                                            valid = False\n                                    elif grid[nx][ny] == 'W':\n                                        if is_black is None:\n                                            is_black = False\n                                        elif is_black:\n                                            valid = False\n                            else:\n                                valid = False\n                    \n                    if valid and is_black is not None:\n                        if is_black:\n                            black_area += current_area\n                        else:\n                            white_area += current_area\n        \n        print(black_area, white_area)\n\nsolve()",
    "timestamp": "2025-08-13 05:03:31"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nstruct Point {\n    int x, y;\n};\n\nint bfsSurroundedArea(vector<vector<char>> &grid, char stake) {\n    int rows = grid.size(), cols = grid[0].size();\n    vector<vector<bool>> visited(rows, vector<bool>(cols, false));\n    queue<Point> q;\n\n    auto addBoundaryPoints = [&](char boundary) {\n        for (int i = 0; i < rows; ++i) {\n            if (grid[i][0] == boundary) q.push({i, 0});\n            if (grid[i][cols - 1] == boundary) q.push({i, cols - 1});\n        }\n        for (int j = 0; j < cols; ++j) {\n            if (grid[0][j] == boundary) q.push({0, j});\n            if (grid[rows - 1][j] == boundary) q.push({rows - 1, j});\n        }\n    };\n\n    addBoundaryPoints(stake);\n\n    int direction[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\n    while (!q.empty()) {\n        Point p = q.front(); q.pop();\n        for (auto dir : direction) {\n            int nx = p.x + dir[0], ny = p.y + dir[1];\n            if (nx >= 0 && nx < rows && ny >= 0 && ny < cols && !visited[nx][ny]) {\n                visited[nx][ny] = true;\n                if (grid[nx][ny] == stake) {\n                    q.push({nx, ny});\n                }\n            }\n        }\n    }\n\n    int surroundedArea = 0;\n    for (int i = 0; i < rows; ++i) {\n        for (int j = 0; j < cols; ++j) {\n            if (!visited[i][j] && grid[i][j] == '.') {\n                bool isSurrounded = true;\n                q.push({i, j});\n                visited[i][j] = true;\n\n                while (!q.empty()) {\n                    Point p = q.front(); q.pop();\n                    for (auto dir : direction) {\n                        int nx = p.x + dir[0], ny = p.y + dir[1];\n                        if (nx >= 0 && nx < rows && ny >= 0 && ny < cols && !visited[nx][ny]) {\n                            if (grid[nx][ny] == stake) {\n                                visited[nx][ny] = true;\n                                continue;\n                            }\n                            if (grid[nx][ny] == '.') {\n                                q.push({nx, ny});\n                                visited[nx][ny] = true;\n                            }\n                            if (grid[nx][ny] != stake) {\n                                isSurrounded = false;\n                            }\n                        }\n                    }\n                }\n\n                if (isSurrounded) {\n                    surroundedArea++;\n                }\n            }\n        }\n    }\n    return surroundedArea;\n}\n\nint main() {\n    int rows, cols;\n    while (cin >> rows >> cols) {\n        vector<vector<char>> grid(rows, vector<char>(cols));\n        for (int i = 0; i < rows; ++i) {\n            for (int j = 0; j < cols; ++j) {\n                cin >> grid[i][j];\n            }\n        }\n\n        int blackArea = bfsSurroundedArea(grid, 'B');\n        int whiteArea = bfsSurroundedArea(grid, 'W');\n\n        cout << blackArea << \" \" << whiteArea << endl;\n    }\n    return 0;\n}",
    "timestamp": "2025-08-13 11:22:42"
  }
]