[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_WEBSITES 100\n#define MAX_LINKS 1000\n\ntypedef struct {\n    int points;\n    int time;\n    int max_ads;\n} Website;\n\ntypedef struct {\n    int from;\n    int to;\n    int travel_time;\n} Link;\n\nint max_points(int N, int M, int T, Website websites[], Link links[]) {\n    int dp[MAX_WEBSITES][MAX_WEBSITES][MAX_WEBSITES] = {0};\n    \n    for (int start = 0; start < N; start++) {\n        for (int end = 0; end < N; end++) {\n            for (int ad_count = 0; ad_count <= MAX_WEBSITES; ad_count++) {\n                dp[start][end][ad_count] = INT_MIN;\n            }\n            dp[start][end][0] = 0;\n        }\n    }\n    \n    for (int start = 0; start < N; start++) {\n        dp[start][start][1] = websites[start].points;\n    }\n    \n    for (int m = 0; m < M; m++) {\n        int u = links[m].from;\n        int v = links[m].to;\n        int travel_time = links[m].travel_time;\n        \n        for (int start = 0; start < N; start++) {\n            for (int end = 0; end < N; end++) {\n                for (int ad_count = 0; ad_count <= MAX_WEBSITES; ad_count++) {\n                    if (dp[start][u][ad_count] != INT_MIN) {\n                        int remaining_time = T - travel_time;\n                        \n                        // Option 1: Watch ad at destination website\n                        if (ad_count < websites[v].max_ads && \n                            remaining_time >= websites[v].time) {\n                            int new_points = dp[start][u][ad_count] + websites[v].points;\n                            dp[start][v][ad_count + 1] = fmax(dp[start][v][ad_count + 1], new_points);\n                        }\n                        \n                        // Option 2: Do not watch ad\n                        dp[start][v][ad_count] = fmax(dp[start][v][ad_count], dp[start][u][ad_count]);\n                    }\n                }\n            }\n        }\n    }\n    \n    int max_score = 0;\n    for (int start = 0; start < N; start++) {\n        for (int end = 0; end < N; end++) {\n            for (int ad_count = 0; ad_count <= MAX_WEBSITES; ad_count++) {\n                max_score = fmax(max_score, dp[start][end][ad_count]);\n            }\n        }\n    }\n    \n    return max_score;\n}\n\nint main() {\n    int N, M, T;\n    Website websites[MAX_WEBSITES];\n    Link links[MAX_LINKS];\n    \n    scanf(\"%d %d %d\", &N, &M, &T);\n    \n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d %d\", &websites[i].points, &websites[i].time, &websites[i].max_ads);\n    }\n    \n    for (int i = 0; i < M; i++) {\n        scanf(\"%d %d %d\", &links[i].from, &links[i].to, &links[i].travel_time);\n    }\n    \n    int result = max_points(N, M, T, websites, links);\n    printf(\"%d\\n\", result);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:47:28"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MAX_N 50\n#define MAX_T 3000\n\ntypedef struct {\n    int to, time;\n} Edge;\n\nEdge edges[MAX_N][MAX_N];\nint edgeCount[MAX_N];\nint p[MAX_N], t[MAX_N], k[MAX_N];\nint dp[MAX_N][MAX_T + 1][MAX_N + 1];\nint N, M, T;\n\nint max(int a, int b) {\n    return a > b ? a : b;\n}\n\nvoid solve() {\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j <= T; ++j) {\n            for (int l = 0; l <= k[i]; ++l) {\n                dp[i][j][l] = -1;\n            }\n        }\n    }\n\n    for (int i = 0; i < N; ++i) {\n        if (t[i] <= T) {\n            dp[i][t[i]][1] = p[i];\n        }\n    }\n\n    for (int time = 0; time <= T; ++time) {\n        for (int u = 0; u < N; ++u) {\n            for (int cnt = 0; cnt <= k[u]; ++cnt) {\n                if (dp[u][time][cnt] == -1) continue;\n\n                for (int i = 0; i < edgeCount[u]; ++i) {\n                    Edge e = edges[u][i];\n                    int v = e.to;\n                    int new_time = time + e.time;\n                    if (new_time > T) continue;\n\n                    if (dp[v][new_time][0] < dp[u][time][cnt]) {\n                        dp[v][new_time][0] = dp[u][time][cnt];\n                    }\n                }\n\n                if (cnt < k[u]) {\n                    int new_time = time + t[u];\n                    if (new_time <= T) {\n                        if (dp[u][new_time][cnt + 1] < dp[u][time][cnt] + p[u]) {\n                            dp[u][new_time][cnt + 1] = dp[u][time][cnt] + p[u];\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    int max_points = 0;\n    for (int u = 0; u < N; ++u) {\n        for (int time = 0; time <= T; ++time) {\n            for (int cnt = 0; cnt <= k[u]; ++cnt) {\n                max_points = max(max_points, dp[u][time][cnt]);\n            }\n        }\n    }\n\n    printf(\"%d\\n\", max_points);\n}\n\nint main() {\n    scanf(\"%d %d %d\", &N, &M, &T);\n    for (int i = 0; i < N; ++i) {\n        scanf(\"%d %d %d\", &p[i], &t[i], &k[i]);\n        edgeCount[i] = 0;\n    }\n    for (int i = 0; i < M; ++i) {\n        int u, v, time;\n        scanf(\"%d %d %d\", &u, &v, &time);\n        u--; v--;\n        edges[u][edgeCount[u]].to = v;\n        edges[u][edgeCount[u]].time = time;\n        edgeCount[u]++;\n        edges[v][edgeCount[v]].to = u;\n        edges[v][edgeCount[v]].time = time;\n        edgeCount[v]++;\n    }\n    solve();\n    return 0;\n}",
    "timestamp": "2025-08-05 21:47:58"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nstruct Edge {\n    int to, time;\n};\n\nstruct State {\n    int website, time, points;\n    vector<int> watched;\n    bool operator<(const State& other) const {\n        return points < other.points;\n    }\n};\n\nint main() {\n    int N, M, T;\n    cin >> N >> M >> T;\n    vector<int> p(N), t(N), k(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> p[i] >> t[i] >> k[i];\n    }\n    vector<vector<Edge>> adj(N);\n    for (int i = 0; i < M; ++i) {\n        int u, v, time;\n        cin >> u >> v >> time;\n        u--; v--;\n        adj[u].push_back({v, time});\n        adj[v].push_back({u, time});\n    }\n\n    priority_queue<State> pq;\n    vector<vector<vector<int>>> max_points(N, vector<vector<int>>(T + 1, vector<int>(*max_element(k.begin(), k.end()) + 1, -1)));\n\n    for (int i = 0; i < N; ++i) {\n        if (t[i] <= T && k[i] > 0) {\n            max_points[i][t[i]][1] = p[i];\n            pq.push({i, t[i], p[i], vector<int>(N, 0)});\n            pq.top().watched[i] = 1;\n        }\n    }\n\n    int ans = 0;\n    while (!pq.empty()) {\n        State current = pq.top();\n        pq.pop();\n        if (current.points < max_points[current.website][current.time][current.watched[current.website]]) {\n            continue;\n        }\n        ans = max(ans, current.points);\n        for (const Edge& edge : adj[current.website]) {\n            int new_time = current.time + edge.time;\n            if (new_time > T) continue;\n            if (max_points[edge.to][new_time][current.watched[edge.to]] < current.points) {\n                max_points[edge.to][new_time][current.watched[edge.to]] = current.points;\n                State next = current;\n                next.website = edge.to;\n                next.time = new_time;\n                pq.push(next);\n            }\n            if (current.watched[edge.to] < k[edge.to] && new_time + t[edge.to] <= T) {\n                int new_watched = current.watched[edge.to] + 1;\n                int new_points = current.points + p[edge.to];\n                if (max_points[edge.to][new_time + t[edge.to]][new_watched] < new_points) {\n                    max_points[edge.to][new_time + t[edge.to]][new_watched] = new_points;\n                    State next = current;\n                    next.website = edge.to;\n                    next.time = new_time + t[edge.to];\n                    next.points = new_points;\n                    next.watched[edge.to] = new_watched;\n                    pq.push(next);\n                }\n            }\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 21:48:28"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class ICPCContest {\n    static class Edge {\n        int to, time;\n        Edge(int to, int time) {\n            this.to = to;\n            this.time = time;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        int M = sc.nextInt();\n        int T = sc.nextInt();\n\n        int[] p = new int[N + 1];\n        int[] t = new int[N + 1];\n        int[] k = new int[N + 1];\n\n        for (int i = 1; i <= N; i++) {\n            p[i] = sc.nextInt();\n            t[i] = sc.nextInt();\n            k[i] = sc.nextInt();\n        }\n\n        List<List<Edge>> adj = new ArrayList<>();\n        for (int i = 0; i <= N; i++) {\n            adj.add(new ArrayList<>());\n        }\n\n        for (int i = 0; i < M; i++) {\n            int u = sc.nextInt();\n            int v = sc.nextInt();\n            int time = sc.nextInt();\n            adj.get(u).add(new Edge(v, time));\n            adj.get(v).add(new Edge(u, time));\n        }\n\n        int[][] dp = new int[N + 1][T + 1];\n        for (int[] row : dp) {\n            Arrays.fill(row, -1);\n        }\n\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);\n        for (int i = 1; i <= N; i++) {\n            if (t[i] <= T && k[i] > 0) {\n                dp[i][t[i]] = p[i];\n                pq.offer(new int[]{i, t[i]});\n            }\n        }\n\n        int maxPoints = 0;\n        while (!pq.isEmpty()) {\n            int[] current = pq.poll();\n            int u = current[0];\n            int timeUsed = current[1];\n            if (dp[u][timeUsed] == -1) continue;\n            maxPoints = Math.max(maxPoints, dp[u][timeUsed]);\n\n            for (Edge edge : adj.get(u)) {\n                int v = edge.to;\n                int newTime = timeUsed + edge.time;\n                if (newTime > T) continue;\n\n                if (dp[v][newTime] < dp[u][timeUsed]) {\n                    dp[v][newTime] = dp[u][timeUsed];\n                    pq.offer(new int[]{v, newTime});\n                }\n\n                if (k[v] > 0) {\n                    int watchTime = newTime + t[v];\n                    if (watchTime > T) continue;\n                    if (dp[v][watchTime] < dp[u][timeUsed] + p[v]) {\n                        dp[v][watchTime] = dp[u][timeUsed] + p[v];\n                        pq.offer(new int[]{v, watchTime});\n                    }\n                }\n            }\n        }\n\n        System.out.println(maxPoints);\n    }\n}",
    "timestamp": "2025-08-05 21:48:59"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class ICPCPointCollection {\n    static class Website {\n        int points;\n        int time;\n        int maxWatches;\n        List<Edge> links;\n\n        Website(int points, int time, int maxWatches) {\n            this.points = points;\n            this.time = time;\n            this.maxWatches = maxWatches;\n            this.links = new ArrayList<>();\n        }\n    }\n\n    static class Edge {\n        int destination;\n        int travelTime;\n\n        Edge(int destination, int travelTime) {\n            this.destination = destination;\n            this.travelTime = travelTime;\n        }\n    }\n\n    static class State {\n        int website;\n        int time;\n        int points;\n        int[] watchCount;\n\n        State(int website, int time, int points, int[] watchCount) {\n            this.website = website;\n            this.time = time;\n            this.points = points;\n            this.watchCount = watchCount.clone();\n        }\n    }\n\n    public static int maxPoints(int N, int T, Website[] websites) {\n        int maxPointsCollected = 0;\n        Queue<State> queue = new LinkedList<>();\n\n        for (int start = 0; start < N; start++) {\n            int[] initialWatchCount = new int[N];\n            queue.offer(new State(start, 0, 0, initialWatchCount));\n        }\n\n        while (!queue.isEmpty()) {\n            State current = queue.poll();\n            maxPointsCollected = Math.max(maxPointsCollected, current.points);\n\n            for (Edge link : websites[current.website].links) {\n                int newTime = current.time + websites[current.website].time + link.travelTime;\n                if (newTime <= T) {\n                    State nextState = new State(link.destination, newTime, current.points, current.watchCount);\n                    queue.offer(nextState);\n                }\n            }\n\n            if (current.watchCount[current.website] < websites[current.website].maxWatches) {\n                int newTime = current.time + websites[current.website].time;\n                if (newTime <= T) {\n                    State nextState = new State(\n                        current.website, \n                        newTime, \n                        current.points + websites[current.website].points, \n                        current.watchCount\n                    );\n                    nextState.watchCount[current.website]++;\n                    queue.offer(nextState);\n                }\n            }\n        }\n\n        return maxPointsCollected;\n    }\n\n    public static void main(String[] args) {\n        int N = 3; // Number of websites\n        int T = 100; // Time limit\n        Website[] websites = new Website[N];\n\n        websites[0] = new Website(10, 5, 2);\n        websites[1] = new Website(15, 7, 3);\n        websites[2] = new Website(20, 6, 1);\n\n        websites[0].links.add(new Edge(1, 10));\n        websites[1].links.add(new Edge(2, 15));\n        websites[2].links.add(new Edge(0, 20));\n\n        int result = maxPoints(N, T, websites);\n        System.out.println(\"Maximum points: \" + result);\n    }\n}",
    "timestamp": "2025-08-05 21:49:10"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 105;\nconst int MAXM = 205;\n\nstruct Website {\n    int points;\n    int time;\n    int max_views;\n};\n\nstruct Edge {\n    int to;\n    int travel_time;\n};\n\nclass Solution {\nprivate:\n    int N, M, T;\n    Website websites[MAXN];\n    vector<Edge> graph[MAXN];\n    int dp[MAXN][MAXN][105];\n\n    int solve() {\n        memset(dp, -1, sizeof(dp));\n        \n        int max_points = 0;\n        \n        for (int start = 1; start <= N; start++) {\n            dp[start][start][0] = 0;\n            \n            for (int time = 0; time <= T; time++) {\n                for (int curr = 1; curr <= N; curr++) {\n                    if (dp[start][curr][time] == -1) continue;\n                    \n                    // Option 1: Watch advertisement if possible\n                    for (int view_count = 1; view_count <= websites[curr].max_views; view_count++) {\n                        int new_time = time + websites[curr].time;\n                        int new_points = dp[start][curr][time] + websites[curr].points;\n                        \n                        if (new_time <= T) {\n                            max_points = max(max_points, new_points);\n                            dp[start][curr][new_time] = max(dp[start][curr][new_time], new_points);\n                        }\n                    }\n                    \n                    // Option 2: Move to other websites\n                    for (const Edge& edge : graph[curr]) {\n                        int next = edge.to;\n                        int new_time = time + edge.travel_time;\n                        \n                        if (new_time <= T) {\n                            dp[start][next][new_time] = max(dp[start][next][new_time], dp[start][curr][time]);\n                        }\n                    }\n                }\n            }\n        }\n        \n        return max_points;\n    }\n\npublic:\n    void readInput() {\n        cin >> N >> M >> T;\n        \n        for (int i = 1; i <= N; i++) {\n            cin >> websites[i].points >> websites[i].time >> websites[i].max_views;\n        }\n        \n        for (int i = 0; i < M; i++) {\n            int u, v, time;\n            cin >> u >> v >> time;\n            graph[u].push_back({v, time});\n            graph[v].push_back({u, time});\n        }\n    }\n    \n    void run() {\n        readInput();\n        int result = solve();\n        cout << result << endl;\n    }\n};\n\nint main() {\n    Solution solution;\n    solution.run();\n    return 0;\n}",
    "timestamp": "2025-08-05 21:49:20"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def max_points(N, M, edges, points, times, limits, T):\n    from collections import defaultdict\n    import heapq\n\n    graph = defaultdict(list)\n    for u, v, w in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n\n    dp = {i: defaultdict(lambda: -1) for i in range(1, N + 1)}\n    pq = []\n\n    for i in range(1, N + 1):\n        for j in range(limits[i - 1] + 1):\n            time_spent = j * times[i - 1]\n            if time_spent <= T:\n                points_gained = j * points[i - 1]\n                dp[i][time_spent] = max(dp[i][time_spent], points_gained)\n                heapq.heappush(pq, (-points_gained, time_spent, i))\n\n    max_points = 0\n\n    while pq:\n        curr_points, curr_time, u = heapq.heappop(pq)\n        curr_points = -curr_points\n        if dp[u][curr_time] < curr_points:\n            continue\n        max_points = max(max_points, curr_points)\n\n        for v, travel_time in graph[u]:\n            for j in range(limits[v - 1] + 1):\n                additional_time = travel_time + j * times[v - 1]\n                if curr_time + additional_time <= T:\n                    additional_points = j * points[v - 1]\n                    total_points = curr_points + additional_points\n                    new_time = curr_time + additional_time\n                    if dp[v][new_time] < total_points:\n                        dp[v][new_time] = total_points\n                        heapq.heappush(pq, (-total_points, new_time, v))\n\n    return max_points\n\n# Example usage:\nN = 5  # number of websites\nM = 6  # number of links\nedges = [\n    (1, 2, 2),\n    (1, 3, 3),\n    (2, 4, 4),\n    (3, 4, 1),\n    (4, 5, 2),\n    (3, 5, 6)\n]  # each tuple is (u, v, w), representing a link with travel time w\npoints = [10, 20, 15, 30, 25]  # points at each website\ntimes = [1, 2, 1, 2, 1]  # times to watch ads at each website\nlimits = [3, 1, 2, 1, 3]  # max times you can watch ads at each website\nT = 15  # total time available\n\nprint(max_points(N, M, edges, points, times, limits, T))  # Output: maximum points you can collect",
    "timestamp": "2025-08-13 07:34:14"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class ICPCContest {\n\n    static class Website {\n        int id;\n        int points;\n        int time;\n        int maxWatch;\n\n        public Website(int id, int points, int time, int maxWatch) {\n            this.id = id;\n            this.points = points;\n            this.time = time;\n            this.maxWatch = maxWatch;\n        }\n    }\n\n    static class Edge {\n        int from;\n        int to;\n        int travelTime;\n\n        public Edge(int from, int to, int travelTime) {\n            this.from = from;\n            this.to = to;\n            this.travelTime = travelTime;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        int N = scanner.nextInt();\n        int M = scanner.nextInt();\n        int T = scanner.nextInt();\n\n        Website[] websites = new Website[N + 1];\n        for (int i = 1; i <= N; i++) {\n            int p = scanner.nextInt();\n            int t = scanner.nextInt();\n            int k = scanner.nextInt();\n            websites[i] = new Website(i, p, t, k);\n        }\n\n        List<Edge>[] adjList = new ArrayList[N + 1];\n        for (int i = 1; i <= N; i++) {\n            adjList[i] = new ArrayList<>();\n        }\n\n        for (int i = 0; i < M; i++) {\n            int u = scanner.nextInt();\n            int v = scanner.nextInt();\n            int time = scanner.nextInt();\n            adjList[u].add(new Edge(u, v, time));\n        }\n\n        int[][] maxPoints = new int[N + 1][T + 1];\n        for (Edge edge : adjList[1]) {\n            Arrays.fill(maxPoints[edge.from], Integer.MIN_VALUE);\n        }\n        \n        for (int i = 1; i <= N; i++) {\n            for (int j = 0; j <= T; j++) {\n                int maxP = 0;\n                for (int q = 0; q <= websites[i].maxWatch && q * websites[i].time <= j; q++) {\n                    maxP = Math.max(maxP, q * websites[i].points);\n                    maxPoints[i][j] = Math.max(maxPoints[i][j], maxP);\n                }\n            }\n        }\n\n        Queue<int[]> queue = new LinkedList<>();\n        for (int i = 1; i <= N; i++) {\n            if (websites[i].time <= T) {\n                queue.offer(new int[]{i, websites[i].maxWatch, websites[i].time, websites[i].points * websites[i].maxWatch});\n            }\n        }\n\n        while (!queue.isEmpty()) {\n            int[] current = queue.poll();\n            int site = current[0];\n            int remainingWatches = current[1];\n            int currentTime = current[2];\n            int collectedPoints = current[3];\n\n            for (Edge edge : adjList[site]) {\n                int nextSite = edge.to;\n                int totalTime = currentTime + edge.travelTime;\n\n                if (totalTime <= T) {\n                    for (int q = 0; q <= websites[nextSite].maxWatch && totalTime + q * websites[nextSite].time <= T; q++) {\n                        int nextPoints = collectedPoints + q * websites[nextSite].points;\n                        if (nextPoints > maxPoints[nextSite][totalTime + q * websites[nextSite].time]) {\n                            maxPoints[nextSite][totalTime + q * websites[nextSite].time] = nextPoints;\n                            queue.offer(new int[]{nextSite, websites[nextSite].maxWatch - q, totalTime + q * websites[nextSite].time, nextPoints});\n                        }\n                    }\n                }\n            }\n        }\n\n        int maxCollectedPoints = 0;\n        for (int i = 1; i <= N; i++) {\n            for (int j = 0; j <= T; j++) {\n                maxCollectedPoints = Math.max(maxCollectedPoints, maxPoints[i][j]);\n            }\n        }\n\n        System.out.println(maxCollectedPoints);\n    }\n}",
    "timestamp": "2025-08-13 07:34:35"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_N 100\n#define MAX_M 1000\n\ntypedef struct {\n    int to;\n    int time;\n} Link;\n\nint N, M, T;\nint p[MAX_N + 1], t[MAX_N + 1], k[MAX_N + 1];\nLink links[MAX_M];\nint adj[MAX_N + 1][MAX_N + 1];\nint maxPoints[MAX_N + 1][MAX_N + 1][MAX_N * 100 + 1];  // Max time is 100, multiplied by points\n\nvoid initialize() {\n    for (int i = 1; i <= N; i++) {\n        for (int j = 0; j <= T; j++) {\n            for (int pp = 0; pp <= N * 100; pp++) {\n                maxPoints[i][j][pp] = -1;\n            }\n        }\n    }\n}\n\nint max(int a, int b) {\n    return a > b ? a : b;\n}\n\nint main() {\n    scanf(\"%d %d %d\", &N, &M, &T);\n\n    for (int i = 1; i <= N; i++) {\n        scanf(\"%d %d %d\", &p[i], &t[i], &k[i]);\n    }\n\n    memset(adj, -1, sizeof(adj));\n    for (int i = 0; i < M; i++) {\n        int u, v, time;\n        scanf(\"%d %d %d\", &u, &v, &time);\n        adj[u][v] = time;\n        adj[v][u] = time;  // BI-directional\n    }\n\n    initialize();\n\n    for (int i = 1; i <= N; i++) {\n        for (int watch = 0; watch <= k[i]; watch++) {\n            if (watch * t[i] <= T) {\n                maxPoints[i][watch * t[i]][watch * p[i]] = watch * p[i];\n            }\n        }\n    }\n\n    int result = 0;\n    for (int u = 1; u <= N; u++) {\n        for (int time = 0; time <= T; time++) {\n            for (int point = 0; point <= N * 100; point++) {\n                if (maxPoints[u][time][point] == -1) continue;\n\n                result = max(result, maxPoints[u][time][point]);\n\n                for (int v = 1; v <= N; v++) {\n                    if (adj[u][v] != -1) {\n                        int newTime = time + adj[u][v];\n                        if (newTime > T) continue;\n\n                        for (int watch = 0; watch <= k[v]; watch++) {\n                            int advTime = watch * t[v];\n                            if (newTime + advTime > T) break;\n\n                            int newPoints = point + watch * p[v];\n                            maxPoints[v][newTime + advTime][newPoints] = max(\n                                maxPoints[v][newTime + advTime][newPoints],\n                                maxPoints[u][time][point] + watch * p[v]\n                            );\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    printf(\"%d\\n\", result);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 07:34:56"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def max_points_collection(N, M, T, links, websites):\n    # Initialize dynamic programming table\n    # dp[time][website][ad_count] = max points collected\n    dp = [[[float('-inf') for _ in range(max(site[2] for site in websites) + 1)] \n           for _ in range(N+1)] for _ in range(T+1)]\n    \n    # Initialize starting point\n    for i in range(1, N+1):\n        dp[0][i][0] = 0\n    \n    # Iterate through time, websites, and ad counts\n    for time in range(1, T+1):\n        for curr_site in range(1, N+1):\n            for ad_count in range(max(site[2] for site in websites) + 1):\n                # Skip if current state is impossible\n                if dp[time-1][curr_site][ad_count] == float('-inf'):\n                    continue\n                \n                # Option 1: Stay at current site and watch ad\n                for site in websites:\n                    if site[0] == curr_site:\n                        if ad_count < site[2] and time >= site[1]:\n                            dp[time][curr_site][ad_count+1] = max(\n                                dp[time][curr_site][ad_count+1],\n                                dp[time-1][curr_site][ad_count] + site[3]\n                            )\n                \n                # Option 2: Move to another site via links\n                for link in links:\n                    if link[0] == curr_site:\n                        target_site = link[1]\n                        dp[time][target_site][ad_count] = max(\n                            dp[time][target_site][ad_count],\n                            dp[time-1][curr_site][ad_count]\n                        )\n    \n    # Find maximum points\n    max_points = max(max(dp[time][site][ad_count] \n                         for site in range(1, N+1) \n                         for ad_count in range(max(site[2] for site in websites) + 1)) \n                     for time in range(T+1))\n    \n    return max_points if max_points != float('-inf') else 0\n\n# Input parsing and function call\ndef main():\n    N, M, T = map(int, input().split())\n    \n    websites = [(0, 0, 0, 0)]  # dummy first entry\n    for _ in range(N):\n        site, time, max_ads, points = map(int, input().split())\n        websites.append((site, time, max_ads, points))\n    \n    links = []\n    for _ in range(M):\n        u, v = map(int, input().split())\n        links.append((u, v))\n    \n    print(max_points_collection(N, M, T, links, websites))\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 07:35:17"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import heapq\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    idx = 0\n    \n    N = int(data[idx])\n    idx += 1\n    M = int(data[idx])\n    idx += 1\n    T = int(data[idx])\n    idx += 1\n    \n    p = []\n    t = []\n    k = []\n    for _ in range(N):\n        p_i = int(data[idx])\n        t_i = int(data[idx+1])\n        k_i = int(data[idx+2])\n        p.append(p_i)\n        t.append(t_i)\n        k.append(k_i)\n        idx += 3\n    \n    adj = [[] for _ in range(N+1)]\n    for _ in range(M):\n        u = int(data[idx])\n        v = int(data[idx+1])\n        w = int(data[idx+2])\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n        idx += 3\n    \n    # dp[i][j] = max points at website i with j seconds spent\n    dp = [[-1] * (T + 1) for _ in range(N + 1)]\n    heap = []\n    \n    for i in range(1, N+1):\n        if t[i-1] <= T:\n            max_watch = min(k[i-1], T // t[i-1]) if t[i-1] != 0 else 0\n            for cnt in range(1, max_watch + 1):\n                time_spent = cnt * t[i-1]\n                points = cnt * p[i-1]\n                if time_spent <= T and points > dp[i][time_spent]:\n                    dp[i][time_spent] = points\n                    heapq.heappush(heap, (-points, i, time_spent))\n    \n    max_points = 0\n    \n    while heap:\n        neg_pts, u, time_u = heapq.heappop(heap)\n        current_pts = -neg_pts\n        if current_pts < dp[u][time_u]:\n            continue\n        if current_pts > max_points:\n            max_points = current_pts\n        \n        for (v, w) in adj[u]:\n            new_time = time_u + w\n            if new_time > T:\n                continue\n            if current_pts > dp[v][new_time]:\n                dp[v][new_time] = current_pts\n                heapq.heappush(heap, (-current_pts, v, new_time))\n            \n            # Try watching ad at v\n            p_v = p[v-1]\n            t_v = t[v-1]\n            k_v = k[v-1]\n            if t_v == 0:\n                continue\n            max_possible = min(k_v, (T - new_time) // t_v)\n            for cnt in range(1, max_possible + 1):\n                total_time = new_time + cnt * t_v\n                if total_time > T:\n                    continue\n                total_pts = current_pts + cnt * p_v\n                if total_pts > dp[v][total_time]:\n                    dp[v][total_time] = total_pts\n                    heapq.heappush(heap, (-total_pts, v, total_time))\n    \n    print(max_points)\n\nsolve()",
    "timestamp": "2025-08-13 07:35:40"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nstruct Website {\n    int points;\n    int time;\n    int max_views;\n};\n\nstruct Link {\n    int from;\n    int to;\n    int time;\n};\n\nint main() {\n    int N, M, T;\n    cin >> N >> M >> T;\n\n    vector<Website> websites(N + 1);\n    for (int i = 1; i <= N; ++i) {\n        int p_i, t_i, k_i;\n        cin >> p_i >> t_i >> k_i;\n        websites[i] = {p_i, t_i, k_i};\n    }\n\n    vector<vector<int>> adj(N + 1);\n    vector<vector<int>> link_time(N + 1, vector<int>(N + 1, INT_MAX));\n    for (int i = 0; i < M; ++i) {\n        int a, b, t;\n        cin >> a >> b >> t;\n        adj[a].push_back(b);\n        adj[b].push_back(a);\n        link_time[a][b] = t;\n        link_time[b][a] = t;\n    }\n\n    vector<vector<int>> dp(T + 1, vector<int>(N + 1, 0));\n\n    for (int t = 0; t <= T; ++t) {\n        for (int i = 1; i <= N; ++i) {\n            int max_views = min(t / websites[i].time, websites[i].max_views);\n            for (int v = 0; v <= max_views; ++v) {\n                dp[t][i] = max(dp[t][i], v * websites[i].points + (t >= v * websites[i].time ? dp[t - v * websites[i].time][i] : 0));\n            }\n\n            for (int j : adj[i]) {\n                if (t >= link_time[i][j]) {\n                    dp[t][j] = max(dp[t][j], dp[t - link_time[i][j]][i]);\n                }\n            }\n        }\n    }\n\n    int max_points = 0;\n    for (int i = 1; i <= N; ++i) {\n        max_points = max(max_points, dp[T][i]);\n    }\n\n    cout << max_points << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 11:39:42"
  }
]