[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAX_V 110\n#define N 110\nusing namespace std;\n\n/* ?????£?????????????§£ O(|V|+|E|) */\nint V; //????????°\nvector<int> G[MAX_V]; //??°???????????£??\\??????????????¨???\nvector<int> rG[MAX_V];//?????????????????????????????°??????\nvector<int> vs;       //??°?????????????????????\nbool used[MAX_V];     //?????§???????????????\nint cmp[MAX_V];       //?±????????????£?????????????????????????????????\n\nvoid add_edge(int from,int to){\n  G[from].push_back(to);\n  rG[to].push_back(from);\n}\n\nvoid dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++)if(!used[G[v][i]])dfs(G[v][i]);\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v]=true;\n  cmp[v]=k;\n  for(int i=0;i<rG[v].size();i++) if(!used[rG[v][i]])rdfs(rG[v][i],k);\n}\n\nint scc(){\n  memset(used,0,sizeof(used));\n  vs.clear();\n  for(int v=0;v<V;v++) if(!used[v]) dfs(v);\n  memset(used,0,sizeof(used));\n  int k=0;\n  for(int i=vs.size()-1;i>=0;i--)if(!used[vs[i]]) rdfs(vs[i],k++);\n  return k;\n}\n\n\n\nint n,v[N],w[N],K[N],T;\nint Max(int &a,int b){return a=max(a,b);}\n\nset<int> Idx;\nset<int>g[N];\nint calc(){\n  int dp[20010]={};\n    \n  for(int i:Idx){ //??????\n    int num = g[cmp[i]].count(cmp[i])? K[i]:1;\n    for(int j=1;num;j=min(num,j*2)){ //???????????°\n      num -= j;\n      for(int k=T;k>=j*w[i];k--)  //?????¨?????????\n        Max(dp[k],dp[k-j*w[i]]+j*v[i]);\n    }\n  }\n  int res = 0;\n  for(int i=0;i<=T;i++)  Max(res,dp[i]);\n  return res;\n}\n\nint calc(int col){\n  int res = 0,flg=1;\n  for(int i=0;i<n;i++) if(cmp[i]==col) Idx.insert(i);\n\n  \n  for(int nx:g[col]) if(nx!=col) res=max(res,calc(nx)),flg=0;\n  if(flg)res =  calc();  \n  for(int i=0;i<n;i++) if(cmp[i]==col) Idx.erase(i);\n  return res;\n}\n\n\nint main(){\n  while(1){\n  int m;\n  cin>>n>>m>>T;\n  if(!n&&!m&&!T)break;\n  memset(cmp,0,sizeof(cmp));\n  for(int i=0;i<N;i++) G[i].clear(),rG[i].clear(),Idx.clear(),g[i].clear();\n  for(int i=0;i<n;i++)cin>>v[i]>>w[i]>>K[i];\n  for(int i=0,a,b;i<m;i++)cin>>a>>b,add_edge(a-1,b-1);\n  V = n;\n  V=scc();\n\n  bool start[N]={};\n  for(int i=0;i<n;i++)\n    for(int j:G[i])g[cmp[i]].insert(cmp[j]),start[cmp[j]] |= cmp[i]!=cmp[j];\n  \n  \n  int ans = 0;\n  memset(used,0,sizeof(used));\n  for(int i=0;i<n;i++){\n    if(used[cmp[i]] || start[cmp[i]]) continue;\n    used[cmp[i]] = 1;\n    Max(ans,calc(cmp[i]));    \n  }\n  cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define MAX_T 10005\n#define MAX_V 105\nusing namespace std;\n\ntypedef pair<int,int> P;\n\n/* ?????£?????????????§£ O(|V|+|E|) */\nint V; //????????°\nvector<int> G[MAX_V]; //??°???????????£??\\??????????????¨???\nvector<int> rG[MAX_V];//?????????????????????????????°??????\nvector<int> vs;       //??°?????????????????????\nbool used[MAX_V];     //?????§???????????????\nint cmp[MAX_V];       //?±????????????£?????????????????????????????????\n\nvoid add_edge(int from,int to){\n  G[from].push_back(to);\n  rG[to].push_back(from);\n}\n\nvoid dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++)if(!used[G[v][i]])dfs(G[v][i]);\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v]=true;\n  cmp[v]=k;\n  for(int i=0;i<rG[v].size();i++) if(!used[rG[v][i]])rdfs(rG[v][i],k);\n}\n\nint scc(){\n  memset(used,0,sizeof(used));\n  vs.clear();\n  for(int v=0;v<V;v++) if(!used[v]) dfs(v);\n  \n  memset(used,0,sizeof(used));\n  int k=0;\n  for(int i=vs.size()-1;i>=0;i--)if(!used[vs[i]]) rdfs(vs[i],k++);\n  return k;\n}\n\nint N, M, T, K, p[MAX_V], t[MAX_V], k[MAX_V], memo[MAX_V];\nint dp[MAX_V][MAX_T], C[MAX_V];\n\nvector<int> G2[MAX_V];\nvector<int> nodelist[MAX_V];\n\nvoid solve(){\n    \n  memset(dp,-1,sizeof(dp));\n\n  for(int i=0;i<K;i++) dp[i][0]=0;\n  \n  for(int i=0;i<N;i++)\n    nodelist[cmp[i]].push_back(i);\n  \n  int ans=0;\n  \n  for(int i=0;i<K;i++){\n    \n    for(int j=0;j<nodelist[i].size();j++){\n      \n      int node=nodelist[i][j];\n      \n      int maxk=k[node];\n      \n      if(!memo[node]&&nodelist[i].size()==1) maxk=1;\n      \n      int x=1;\n    \n      while(maxk){\n      \n\tif(maxk<x) x=maxk;\n\n\tint y=t[node]*x, z=p[node]*x;\n\t\n\tfor(int l=T;l>=0;l--){\n\t  \n\t  if(dp[i][l]==-1) continue;\n\t\n\t  if(l+y<=T) dp[i][l+y]=max(dp[i][l+y], dp[i][l]+z);\n\t}\n      \n\tmaxk-=x;\n      \n\tx*=2;\n      }\n\n      for(int l=0;l<=T;l++) ans=max(ans,dp[i][l]);\n      \n    }\n    \n    for(int j=0;j<G2[i].size();j++)\n      for(int l=0;l<=T;l++) dp[G2[i][j]][l]=max(dp[G2[i][j]][l],dp[i][l]);\n    \n  }\n  \n  cout<<ans<<endl;\n}\n\nvoid init(){\n  \n  memset(memo,0,sizeof(memo));\n  \n  for(int i=0;i<N;i++){\n    G[i].clear();\n    rG[i].clear();\n    G2[i].clear();\n    nodelist[i].clear();\n  }\n  \n  vs.clear();\n  \n}\n\nint used2[MAX_V];\n\nvoid dfs2(int x, int color){\n  \n  if(used2[x]) return ;\n  used2[x]=1;\n  \n  C[x]=color;\n  \n  for(int i=0;i<G[x].size();i++) dfs2(G[x][i],color);\n  \n}\n\nsigned main(){\n\n  while(1){\n    \n    cin>>N>>M>>T;\n    if(!N&&!M&&!T) break;\n    \n    V=N;\n    \n    init();\n    \n    for(int i=0;i<N;i++)\n      cin>>p[i]>>t[i]>>k[i];\n    \n    memset(used2,0,sizeof(used2));\n    \n    for(int i=0;i<M;i++){\n      int a, b;\n      cin>>a>>b;\n      add_edge(a-1,b-1);\n    }\n    \n    for(int i=0;i<N;i++)\n      if(!used2[i]) dfs2(i,i);\n    \n    K=scc();\n    \n    set<P> S;\n    \n    for(int i=0;i<N;i++)\n      for(int j=0;j<G[i].size();j++)\n\t\n\tif(!S.count(P(cmp[i],cmp[G[i][j]]))){\n\t  \n\t  if(cmp[i]==cmp[G[i][j]]){\n\t    memo[cmp[i]]=1;\n\t    continue;\n\t  }\n\t  \n\t  S.insert(P(cmp[i],cmp[G[i][j]]));\n\t  G2[cmp[i]].push_back(cmp[G[i][j]]);\n\t}\n    \n    solve();\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAX_V 110\n#define N 110\nusing namespace std;\n\n/* ?????£?????????????§£ O(|V|+|E|) */\nint V; //????????°\nvector<int> G[MAX_V]; //??°???????????£??\\??????????????¨???\nvector<int> rG[MAX_V];//?????????????????????????????°??????\nvector<int> vs;       //??°?????????????????????\nbool used[MAX_V];     //?????§???????????????\nint cmp[MAX_V];       //?±????????????£?????????????????????????????????\n\nvoid add_edge(int from,int to){\n  G[from].push_back(to);\n  rG[to].push_back(from);\n}\n\nvoid dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++)if(!used[G[v][i]])dfs(G[v][i]);\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v]=true;\n  cmp[v]=k;\n  for(int i=0;i<rG[v].size();i++) if(!used[rG[v][i]])rdfs(rG[v][i],k);\n}\n\nint scc(){\n  memset(used,0,sizeof(used));\n  vs.clear();\n  for(int v=0;v<V;v++) if(!used[v]) dfs(v);\n  memset(used,0,sizeof(used));\n  int k=0;\n  for(int i=vs.size()-1;i>=0;i--)if(!used[vs[i]]) rdfs(vs[i],k++);\n  return k;\n}\n\nint n,v[N],w[N],K[N],T;\nint Max(int &a,int b){return a=max(a,b);}\n\nset<int>g[N];\nvector<int> DP[N];\nvoid update(vector<int> I,vector<int> &dp){\n  int col = cmp[I[0]];\n  for(int i:I){ //??????\n    int num = g[cmp[i]].count(cmp[i])? K[i]:1;\n    for(int j=1;num;j=min(num,j*2)){ //???????????°\n      num -= j;\n      for(int k=T;k>=j*w[i];k--)  //?????¨?????????\n        Max(dp[k],dp[k-j*w[i]]+j*v[i]);\n    }\n  }\n  \n\n  for(int nx:g[col])\n    for(int j=0;j<=T;j++) Max(DP[nx][j],dp[j]);\n  \n}\n\nvoid init(){\n  for(int i=0;i<N;i++){\n    cmp[i] = 0;\n    G[i].clear();\n    rG[i].clear();\n    g[i].clear();\n    DP[i].clear();\n    DP[i].resize(T+1,0);\n  }\n}\n\nint main(){\n  while(1){\n    int m;\n    cin>>n>>m>>T;\n    if(!n&&!m&&!T)break;\n    init();\n  \n    for(int i=0;i<n;i++)cin>>v[i]>>w[i]>>K[i];\n    for(int i=0,a,b;i<m;i++)cin>>a>>b,add_edge(a-1,b-1);\n    V = n;\n    V=scc();\n    \n    for(int i=0;i<n;i++)\n      for(int j:G[i])g[cmp[i]].insert(cmp[j]);\n  \n    int ans = 0;\n    for(int i=0;i<V;i++){\n      vector<int> I;\n      for(int j=0;j<n;j++)if(cmp[j]==i) I.push_back(j);\n      update(I,DP[i]);\n    }\n    for(int i=0;i<V;i++)\n      for(int j=0;j<=T;j++) Max(ans,DP[i][j]);\n  \n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define all(a) (a).begin(),(a).end()\n#define INIT(a) memset(a,0,sizeof(a))\n\n#define fs first\n#define sc second\n#define pb push_back\n#define sz size()\n\nusing namespace std;\n\nconst int MAX_N = 110;\nconst int INF = 1e8;\n\nint level[MAX_N], iter[MAX_N];\n\nvector<int> g[MAX_N], rg[MAX_N];\nvector<int> sccg[MAX_N], sccv[MAX_N];\nvector<int> vs;\nbool use[MAX_N];\nint ord[MAX_N];\n\nint n,m,s;\nint v[MAX_N], w[MAX_N], k[MAX_N];\n\nvoid fdfs(int x){\n  use[x] = true;\n  rep(i,g[x].sz){\n    if(!use[g[x][i]])fdfs(g[x][i]);\n  }\n  vs.pb(x);\n}\n\nvoid rdfs(int x,int id){\n  use[x] = true;\n  ord[x] = id;\n  rep(i,rg[x].sz){\n    if(!use[rg[x][i]])rdfs(rg[x][i],id);\n  }\n}\n\nint scc(){\n  INIT(use);\n  vs.clear();\n  rep(i,n){\n    if(!use[i])fdfs(i);\n  }\n\n  INIT(use);\n  int id = 0;\n  rrep(i,vs.sz){\n    if(!use[vs[i]])rdfs(vs[i],id++);\n  }\n  return id;\n}\n\n\nint main(){\n  while(cin >> n >> m >> s){\n    if(n==0 && m==0 && s==0)break;\n    rep(i,n){\n      g[i].clear(); rg[i].clear();\n      sccg[i].clear(); sccv[i].clear();\n    }\n\n    rep(i,n)cin >> v[i] >> w[i] >> k[i];\n    rep(i,m){\n      int a,b;\n      cin >> a >> b; a--; b--;\n      g[a].pb(b); rg[b].pb(a);\n    }\n\n    int sccn = scc();\n\n    rep(i,n)sccv[ord[i]].pb(i);\n    rep(i,sccn){\n      for(int j : sccv[i]){\n\tfor(int u : g[j]){\n\t  if(i != ord[u])sccg[i].pb(ord[u]);\n\t}\n      }\n      sort(all(sccg[i]));\n      sccg[i].erase(unique(all(sccg[i])),sccg[i].end());\n    }\n\n    vector<int> self(sccn,0);\n    rep(i,sccn){\n      if(sccv[i].sz==1){\n\tint u = sccv[i][0];\n\tfor(int to : g[u]){\n\t  if(u == to)self[i] = 1;\n\t}\n      }\n    }\n\n    //TODO: self-loop\n    vector< vector<int> > dp(sccn, vector<int>(s+1, 0));\n    vector<int> deq(s+1), deqv(s+1);\n\n    rep(i,sccn){\n      if(sccv[i].sz > 1 || self[i]){\n\tfor(int u : sccv[i]){\n\t  for(int a=0;a<w[u];a++){\n\t    int l = 0, r = 0;\n\t    for(int j=0;j*w[u]+a<=s;j++){\n\t      int val = dp[i][j*w[u]+a] - j * v[u];\n\t      while(l < r && deqv[r-1] <= val)r--;\n\t      deq[r] = j;\n\t      deqv[r++] = val;\n\t      dp[i][j*w[u]+a] = deqv[l] + j*v[u];\n\t      if(deq[l] == j-k[u])l++;\n\t    }\n\t  }\n\t}\n      }else{\n\tint u = sccv[i][0];\n\trrep(j,s-w[u]+1){\n\t  dp[i][j+w[u]] = max(dp[i][j+w[u]], dp[i][j] + v[u]);\n\t}\n      }\n      \n      for(int u : sccg[i]){\n\trep(j,s+1)dp[u][j] = max(dp[u][j], dp[i][j]);\n      }\n    }\n\n    int res = 0;\n    rep(i,sccn)rep(j,s+1)res = max(res, dp[i][j]);\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define MAX_T 10005\n#define MAX_V 105\nusing namespace std;\n\ntypedef pair<int,int> P;\n\n/* ?????£?????????????§£ O(|V|+|E|) */\nint V; //????????°\nvector<int> G[MAX_V]; //??°???????????£??\\??????????????¨???\nvector<int> rG[MAX_V];//?????????????????????????????°??????\nvector<int> vs;       //??°?????????????????????\nbool used[MAX_V];     //?????§???????????????\nint cmp[MAX_V];       //?±????????????£?????????????????????????????????\n\nvoid add_edge(int from,int to){\n  G[from].push_back(to);\n  rG[to].push_back(from);\n}\n\nvoid dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++)if(!used[G[v][i]])dfs(G[v][i]);\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v]=true;\n  cmp[v]=k;\n  for(int i=0;i<rG[v].size();i++) if(!used[rG[v][i]])rdfs(rG[v][i],k);\n}\n\nint scc(){\n  memset(used,0,sizeof(used));\n  vs.clear();\n  for(int v=0;v<V;v++) if(!used[v]) dfs(v);\n  \n  memset(used,0,sizeof(used));\n  int k=0;\n  for(int i=vs.size()-1;i>=0;i--)if(!used[vs[i]]) rdfs(vs[i],k++);\n  return k;\n}\n\nint N, M, T, K, p[MAX_V], t[MAX_V], k[MAX_V], memo[MAX_V];\nint dp[MAX_V][MAX_T];\n\nvector<int> G2[MAX_V];\nvector<int> nodelist[MAX_V];\n\nvoid solve(){\n    \n  memset(dp,-1,sizeof(dp));\n\n  for(int i=0;i<K;i++) dp[i][0]=0;\n  \n  for(int i=0;i<N;i++)\n    nodelist[cmp[i]].push_back(i);\n  \n  int ans=0;\n  \n  for(int i=0;i<K;i++){\n    \n    for(int j=0;j<nodelist[i].size();j++){\n      \n      int node=nodelist[i][j];\n      \n      int maxk=k[node];\n      \n      if(!memo[node]&&nodelist[i].size()==1) maxk=1;\n      \n      int x=1;\n    \n      while(maxk){\n      \n\tif(maxk<x) x=maxk;\n\n\tint y=t[node]*x, z=p[node]*x;\n\t\n\tfor(int l=T;l>=0;l--){\n\t  \n\t  if(dp[i][l]==-1) continue;\n\t  \n\t  if(l+y<=T) dp[i][l+y]=max(dp[i][l+y], dp[i][l]+z);\n\t}\n      \n\tmaxk-=x;\n      \n\tx*=2;\n      }\n\n      for(int l=0;l<=T;l++) ans=max(ans,dp[i][l]);\n      \n    }\n    \n    for(int j=0;j<G2[i].size();j++)\n      for(int l=0;l<=T;l++) dp[G2[i][j]][l]=max(dp[G2[i][j]][l],dp[i][l]);\n    \n  }\n  \n  cout<<ans<<endl;\n}\n\nvoid init(){\n  \n  memset(memo,0,sizeof(memo));\n  \n  for(int i=0;i<N;i++){\n    G[i].clear();\n    rG[i].clear();\n    G2[i].clear();\n    nodelist[i].clear();\n  }\n  \n  vs.clear();\n  \n}\n\nsigned main(){\n\n  while(1){\n    \n    cin>>N>>M>>T;\n    if(!N&&!M&&!T) break;\n    \n    V=N;\n    \n    init();\n    \n    for(int i=0;i<N;i++)\n      cin>>p[i]>>t[i]>>k[i];\n    \n    for(int i=0;i<M;i++){\n      int a, b;\n      cin>>a>>b;\n      if(a==b) memo[a-1]=1;\n      add_edge(a-1,b-1);\n    }\n    \n    K=scc();\n    \n    set<P> S;\n    \n    for(int i=0;i<N;i++)\n      for(int j=0;j<G[i].size();j++)\n\t\n\tif(!S.count(P(cmp[i],cmp[G[i][j]]))){\n\t  \n\t  if(cmp[i]==cmp[G[i][j]]) continue;\n\t  \n\t  S.insert(P(cmp[i],cmp[G[i][j]]));\n\t  G2[cmp[i]].push_back(cmp[G[i][j]]);\n\t}\n    \n    solve();\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct StronglyConnectedComponents\n{\n  vector< vector< int > > gg, rg;\n  vector< pair< int, int > > edges;\n  vector< int > comp, order, used;\n\n  StronglyConnectedComponents(size_t v) : gg(v), rg(v), comp(v, -1), used(v, 0) {}\n\n  void add_edge(int x, int y)\n  {\n    gg[x].push_back(y);\n    rg[y].push_back(x);\n    edges.emplace_back(x, y);\n  }\n\n  int operator[](int k)\n  {\n    return (comp[k]);\n  }\n\n  void dfs(int idx)\n  {\n    if(used[idx]) return;\n    used[idx] = true;\n    for(int to : gg[idx]) dfs(to);\n    order.push_back(idx);\n  }\n\n  void rdfs(int idx, int cnt)\n  {\n    if(comp[idx] != -1) return;\n    comp[idx] = cnt;\n    for(int to : rg[idx]) rdfs(to, cnt);\n  }\n\n  void build(vector< vector< int > > &t)\n  {\n    for(int i = 0; i < gg.size(); i++) dfs(i);\n    reverse(begin(order), end(order));\n    int ptr = 0;\n    for(int i : order) rdfs(i, ptr), ptr++;\n\n    t.resize(ptr);\n    set< pair< int, int > > connect;\n    for(auto &e : edges) {\n      int x = comp[e.first], y = comp[e.second];\n      if(x == y) continue;\n      if(connect.count({x, y})) continue;\n      t[x].push_back(y);\n      connect.emplace(x, y);\n    }\n  }\n};\n\nint main()\n{\n  int N, M, S, P[100], T[100], K[100];\n  bool mine[100];\n  int deq[10001], deqv[10001];\n\n  while(scanf(\"%d %d %d\", &N, &M, &S), N) {\n    for(int i = 0; i < N; i++) {\n      scanf(\"%d %d %d\", &P[i], &T[i], &K[i]);\n    }\n    StronglyConnectedComponents g(N);\n    memset(mine, false, sizeof(mine));\n    for(int i = 0; i < M; i++) {\n      int x, y;\n      scanf(\"%d %d\", &x, &y);\n      g.add_edge(--x, --y);\n      if(x == y) mine[x] = true;\n    }\n\n    vector< vector< int > > dag;\n    g.build(dag);\n    vector< vector< int > > component(dag.size());\n    for(int i = 0; i < N; i++) component[g[i]].push_back(i);\n\n    int dp[100][10001] = {{}};\n    int ret = 0;\n\n    for(int i = 0; i < dag.size(); i++) {\n      if(component[i].size() == 1 && !mine[component[i][0]]) K[component[i][0]] = 1;\n      for(int j : component[i]) {\n        for(int k = 0; k < T[j]; k++) {\n          int s = 0, t = 0;\n          for(int l = 0; l * T[j] + k <= S; l++) {\n            int val = dp[i][l * T[j] + k] - l * P[j];\n            while(s < t && deqv[t - 1] <= val) --t;\n            deq[t] = l;\n            deqv[t++] = val;\n            dp[i][l * T[j] + k] = deqv[s] + l * P[j];\n            if(deq[s] == l - K[j]) ++s;\n          }\n        }\n      }\n      for(int k = 0; k <= S; k++) {\n        ret = max(ret, dp[i][k]);\n        for(int j : dag[i]) dp[j][k] = max(dp[j][k], dp[i][k]);\n      }\n    }\n\n    printf(\"%d\\n\", ret);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing pii = pair<int, int>;\n\nstruct edge {\n    int from, to;\n};\n\nusing edges = std::vector<edge>;\nusing graph = std::vector<edges>;\n\nvoid add_edge(graph& g, int from, int to) {\n    g[from].push_back((edge){from, to});\n}\n\nint scc(graph& G, std::vector<int>& cmp) {\n    int V = G.size();\n    std::vector<std::vector<int>> g(V), rg(V);\n    std::vector<bool> used(V, false);\n    std::vector<int> vs;\n    cmp.resize(V);\n    for(int i=0; i<V; ++i) {\n        for(auto e : G[i]) {\n            g[i].push_back(e.to);\n            rg[e.to].push_back(i);\n        }\n    }\n    std::function<void(int)> dfs = [&g, &vs, &used, &dfs](int v) {\n        used[v] = true;\n        for(auto i : g[v]) {\n            if(!used[i]) {\n                dfs(i);\n            }\n        }\n        vs.push_back(v);\n    };\n    std::function<void(int, int)> rdfs = [&rg, &cmp, &used, &rdfs](int v, int k) {\n        used[v] = true;\n        cmp[v] = k;\n        for(int i : rg[v]) {\n            if(!used[i]) {\n                rdfs(i, k);\n            }\n        }\n    };\n    for(int v=0; v<V; ++v) {\n        if(!used[v]) {\n            dfs(v);\n        }\n    }\n    std::fill(used.begin(), used.end(), false);\n    int k = 0;\n    for(int i=vs.size()-1; i>=0; --i) {\n        if(!used[vs[i]]) {\n            rdfs(vs[i], k++);\n        }\n    }\n    return k;\n}\n\nstd::vector<std::vector<int>> build_graph(graph const& g, std::vector<int> const& cmp, int K) {\n    int V = g.size();\n    std::vector<std::set<int>> s(K);\n    std::vector<std::vector<int>> res(K);\n    for(int i=0; i<V; ++i) {\n        for(auto e : g[i]) {\n            s[cmp[i]].insert(cmp[e.to]);\n        }\n    }\n    for(int i=0; i<K; ++i) {\n        for(auto j : s[i]) {\n            if(i != j) {\n                res[i].push_back(j);\n            }\n        }\n    }\n    return res;\n}\n\n\nint main() {\n    int N, M, T;\n    while(cin >> N >> M >> T, N) {\n        graph g(N);\n        vector<int> p(N), t(N), k(N);\n        vector<bool> self(N);\n        for(int i = 0; i < N; ++i) {\n            cin >> p[i] >> t[i] >> k[i];\n        }\n        for(int i = 0; i < M; ++i) {\n            int a, b;\n            cin >> a >> b;\n            a--; b--;\n            add_edge(g, a, b);\n            if(a == b) {\n                self[a] = true;\n            }\n        }\n        \n        vector<int> cmp;\n        int const K = scc(g, cmp);\n        auto g2 = build_graph(g, cmp, K);\n        vector<vector<int>> C(K);\n        for(int i = 0; i < N; ++i) {\n            C[cmp[i]].push_back(i);\n        }\n\n        vector<vector<int>> dp(K, vector<int>(T + 1));\n        for(int i = 0; i < K; ++i) {\n            if(C[i].size() == 1 && !self[C[i][0]]) {\n                k[C[i][0]] = 1;\n            }\n            for(auto v : C[i]) {\n                for(int j = 0; j < t[v]; ++j) {\n                    deque<pii> deq;\n                    for(int l = 0; l * t[v] + j <= T; ++l) {\n                        int val = dp[i][l * t[v] + j] - l * p[v];\n                        while(deq.size() > 0 && deq.back().second <= val) {\n                            deq.pop_back();\n                        }\n                        deq.emplace_back(l, val);\n                        dp[i][l * t[v] + j] = deq.front().second + l * p[v];\n                        if(deq.front().first == l - k[v]) {\n                            deq.pop_front();\n                        }\n                    }\n                }\n                for(auto to : g2[i]) {\n                    for(int j = 0; j <= T; ++j) {\n                        dp[to][j] = max(dp[to][j], dp[i][j]);\n                    }\n                }\n            }\n        }\n\n        int res = 0;\n        for(int i = 0; i < K; ++i) {\n            res = max(res, dp[i][T]);\n        }\n        cout << res << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define mp make_pair\n#define ll long long\n#define line printf(\"\\n\")\n#define rep(a,b,c) for(int a= (int)b;a<(int)c;a++)\n#define repd(a,b,c) for(int a=(int)b;a>=c;a--)\n#define pb push_back\n#define pf push_front\n#define pb2 pop_back\n#define pf2 pop_front\n#define pq priority_queue\n#define haha printf(\"hahaha\\n\")\n\nconst int INF = 1e9+7;\nconst ll INFLL = 1e17;\nconst double EPS = 1e-5;\n\nusing namespace std;\n\nint n,m,t;\nint adj[105][105],par[105];\nint root(int now){\n\tif(par[now]==now)return now;\n\treturn par[now] = root(par[now]);\t\n}\nvoid join(int a,int b){\n\tif(root(a)==root(b))return;\n\tpar[root(a)] = root(b);\n}\nstruct info{\n\tint v,w,c;\n}node[105];\n\nint flag[105];\nvoid init();\nvoid compress();\nvoid set_data();\n\nvector<int> adj3[105];\nint dp[105][10005];\nint tmp[10005];\nvoid DP(int now){\n\tif(flag[now])return;\n\tflag[now] = 1;\n\t\n\tif(adj3[now].empty()){\n\t\trep(cap,0,t+1){\n\t\t\tint k = cap/node[now].w;\n\t\t\tk = min(k,node[now].c);\n\t\t\tdp[now][cap] = k*node[now].v;\n\t\t}\n\t\treturn;\n\t}\n\t\n\trep(i,0,adj3[now].size()){\n\t\tint next = adj3[now][i];\n\t\tDP(next);\n\t\trep(cap,0,t+1)tmp[cap] = dp[next][cap];\n\t\t\n\t\tint w = node[now].w;\n\t\tint c = node[now].c;\n\t\tint v = node[now].v;\n\t\trep(cc,0,w){\n\t\t\tdeque<pii>arr;int all=0;\n\t\t\tfor(int cap = cc;cap<=t;cap+= w){\n\t\t\t\tint &ret = dp[now][cap];ret = max(ret,tmp[cap]);\n\t\t\t\t\n\t\t\t\t\n\t\t\t\twhile(arr.front().se<cap-w*c && arr.size())arr.pf2();\n\t\t\t\t\n\t\t\t\tif(arr.size())ret = max(arr.front().fi+all,ret);\n\t\t\t\t\n\t\t\t\tpii inp = mp(tmp[cap]-all,cap);\n\t\t\t\twhile(arr.size() && arr.back().fi <= inp.fi)arr.pb2();\n\t\t\t\tarr.pb(inp);\n\t\t\t\tall+= v;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n\t\n\treturn;\n}\n\nvoid debug(){\n\tline;\n\trep(k,1,n+1)printf(\"%d %d %d\\n\",node[k].v,node[k].w,node[k].c);\n\trep(k,1,n+1){\n\t\tprintf(\"%d : \",k);\n\t\trep(i,0,adj3[k].size())printf(\"%d \",adj3[k][i]);line;\t\n\t}\n\t\n\tprintf(\"|%d\\n\",t);\n\trep(k,1,n+1){\n\t\trep(i,0,t+1)printf(\"%2d \",dp[k][i]);line;\n\t}\n\tline;\n}\nint main(){\n\twhile(scanf(\"%d%d%d\",&n,&m,&t),n){\n\t\tinit();\n\t\tset_data();\n\t\t\n\t\tint ret = 0;\n\t\tmemset(dp,0,sizeof(dp));\n\t\tmemset(flag,0,sizeof(flag));\n\t\trep(k,1,n+1)DP(k);\n\t\trep(k,1,n+1)rep(i,0,t+1)ret = max(ret,dp[k][i]);\n\t//\tdebug();\n\t\tprintf(\"%d\\n\",ret);\n\t}\n\t\n\treturn 0;\n}\n\n\nvoid init(){\n\trep(k,0,n+1)flag[k] = 0,par[k] = k,adj3[k].clear();\n\t\n\trep(k,1,n+1){\n\t\tscanf(\"%d%d%d\",&node[k].v,&node[k].w,&node[k].c);\n\t}\n\tmemset(adj,0,sizeof(adj));\n\trep(k,0,m){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\tadj[a][b] = 1;\t\n\t}\n}\n\nint num[105],ori[105],rev[105],cnt=1;\nint dfs(int now){\n\tif(num[now])return num[now];\n\tnum[now] = cnt;\n\trev[cnt] = now;\n\tori[now] = cnt++;\n\trep(k,1,n+1)if(adj[now][k]){\n\t\tnum[now] = min(num[now],dfs(k));\n\t\tif(now==k)flag[now]= 1;\n\t}\n\treturn num[now];\n}\n\n\nvoid set_data(){\n\tvector<int> adj2[105];\n\tmemset(num,0,sizeof(num));\n\tmemset(ori,0,sizeof(ori));\n\tmemset(rev,0,sizeof(rev));\n\tcnt = 1;\n\t\n\trep(k,1,n+1)if(!num[k])dfs(k);\n\trep(k,1,n+1)if(num[k]<ori[k])join(k,rev[num[k]]);\t\n\trep(k,1,n+1)if(root(k)!=k)flag[root(k)] = 1,flag[k] = 1,adj2[root(k)].pb(k);\n\trep(k,1,n+1)if(!flag[k])node[k].c= 1;\n\t\n\trep(k,1,n+1)if(root(k)==k)adj2[k].pb(k);\n\trep(k,1,n+1){\n\t\tint ada[105];memset(ada,0,sizeof(ada));\n\t\trep(i,0,adj2[k].size()){\n\t\t\tint now = adj2[k][i];\n\t\t\tada[now] = 1;\n\t\t}\n\t\trep(i,0,adj2[k].size()){\n\t\t\tint now = adj2[k][i];\n\t\t\trep(j,1,n+1)if(adj[now][j] && !ada[j]){//edge ke luar SCC\n\t\t\t\tint next = root(j);\n\t\t\t\tnext = adj2[next][0];\n\t\t\t\tadj3[k].pb(next);\n\t\t\t}\n\t\t\t\n\t\t\tif(i){\n\t\t\t\tint last = adj2[k][i-1];\n\t\t\t\tadj3[last].pb(now);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/*rep(k,1,n+1){\n\t\tprintf(\"%d : \",k);\n\t\trep(i,0,adj2[k].size())printf(\"%d \",adj2[k][i]);line;\t\n\t}*/\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n#define mod 1000000007\n\nstruct UnionFind{\n  vector<int> v;\n  UnionFind(int n) : v(n, -1) {}\n  void init(){ for(int i = 0;i < (int)v.size();i++)v[i]=-1; }\n  int find(int x) { return v[x] < 0 ? x : v[x] = find(v[x]); }\n  bool unite(int x, int y) {\n    x = find(x); y = find(y);\n    if (x == y) return false;\n    if (-v[x] < -v[y]) swap(x, y);\n    v[x] += v[y]; v[y] = x;\n    return true;\n  }\n  bool root(int x) { return v[x] < 0; }\n  bool same(int x, int y) { return find(x) == find(y); }\n  int size(int x) { return -v[find(x)]; }\n};\n\nint N,M,T;\nint p[100],t[100],c[100];\nbool d[100][100];\nvector<int> g[100],idx[100];\nbool vis[100];\nint dp[100][10001];\nbool loop[100];\n\nvoid dfs(int v){\n  vis[v]=true;\n  rep(j,T+1)dp[v][j]=0;\n  for(int nv : g[v]){\n    if(!vis[nv])dfs(nv);\n    rep(j,T+1)maxch(dp[v][j],dp[nv][j]);\n  }\n  for(int i : idx[v]){\n    int num=c[i];\n    for(int k=1;num>0;k<<=1){\n      int ml=min(k,num);\n      for(int j=T;j>=t[i]*ml;j--){\n        maxch(dp[v][j],dp[v][j-t[i]*ml]+p[i]*ml);\n      }\n      num-=ml;\n    }\n  }\n}\n\nint main(){\n  while(1){\n    cin>>N>>M>>T;\n    if(N==0)break;\n    UnionFind uf(N);\n    vector<P> es;\n    rep(i,N)cin>>p[i]>>t[i]>>c[i];\n    memset(d,0,sizeof(d));\n    rep(i,N){\n      g[i].clear();\n      idx[i].clear();\n      vis[i]=false;\n      loop[i]=false;\n      d[i][i]=true;\n    }\n    rep(i,M){\n      int a,b;\n      cin>>a>>b;\n      a--;b--;\n      if(a==b){\n        loop[a]=true;\n        continue;\n      }\n      es.push_back(P(a,b));\n      d[a][b]=true;\n    }\n    M=es.size();\n    rep(k,N)rep(i,N)rep(j,N)d[i][j]|=(d[i][k]&d[k][j]);\n    rep(i,N)rep(j,N){\n      if(d[i][j]&&d[j][i])uf.unite(i,j);\n    }\n    rep(i,M){\n      g[uf.find(es[i].fi)].push_back(uf.find(es[i].se));\n    }\n    rep(i,N){\n      rep(j,N){\n        if(uf.find(j)==i)idx[i].push_back(j);\n      }\n      if(idx[i].size()==1&&!loop[idx[i][0]])c[idx[i][0]]=1;\n    }\n    int res=0;\n    rep(i,N){\n      if(idx[i].size()==0)continue;\n      if(!vis[i])dfs(i);\n      maxch(res,dp[i][T]);\n    }\n    cout<<res<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct StronglyConnectedComponents\n{\n  vector< vector< int > > gg, rg;\n  vector< pair< int, int > > edges;\n  vector< int > comp, order, used;\n\n  StronglyConnectedComponents(size_t v) : gg(v), rg(v), comp(v, -1), used(v, 0) {}\n\n  void add_edge(int x, int y)\n  {\n    gg[x].push_back(y);\n    rg[y].push_back(x);\n    edges.emplace_back(x, y);\n  }\n\n  int operator[](int k)\n  {\n    return (comp[k]);\n  }\n\n  void dfs(int idx)\n  {\n    if(used[idx]) return;\n    used[idx] = true;\n    for(int to : gg[idx]) dfs(to);\n    order.push_back(idx);\n  }\n\n  void rdfs(int idx, int cnt)\n  {\n    if(comp[idx] != -1) return;\n    comp[idx] = cnt;\n    for(int to : rg[idx]) rdfs(to, cnt);\n  }\n\n  void build(vector< vector< int > > &t)\n  {\n    for(int i = 0; i < gg.size(); i++) dfs(i);\n    reverse(begin(order), end(order));\n    int ptr = 0;\n    for(int i : order) rdfs(i, ptr), ptr++;\n\n    t.resize(ptr);\n    set< pair< int, int > > connect;\n    for(auto &e : edges) {\n      int x = comp[e.first], y = comp[e.second];\n      if(x == y) continue;\n      if(connect.count({x, y})) continue;\n      t[x].push_back(y);\n      connect.emplace(x, y);\n    }\n  }\n};\n\nint main()\n{\n  int N, M, S, P[100], T[100], K[100];\n  bool mine[100];\n\n  while(scanf(\"%d %d %d\", &N, &M, &S), N) {\n    for(int i = 0; i < N; i++) {\n      scanf(\"%d %d %d\", &P[i], &T[i], &K[i]);\n    }\n    StronglyConnectedComponents g(N);\n    memset(mine, false, sizeof(mine));\n    for(int i = 0; i < M; i++) {\n      int x, y;\n      scanf(\"%d %d\", &x, &y);\n      g.add_edge(--x, --y);\n      if(x == y) mine[x] = true;\n    }\n\n    vector< vector< int > > dag;\n    g.build(dag);\n    vector< vector< int > > component(dag.size());\n    for(int i = 0; i < N; i++) component[g[i]].push_back(i);\n\n    int dp[101][10001] = {{}};\n    int deq[10001], deqv[10001];\n    int ret = 0;\n\n    for(int i = 0; i < dag.size(); i++) {\n      if(component[i].size() == 1 && !mine[component[i][0]]) {\n        int now = component[i][0];\n        for(int k = S; k >= T[now]; k--) {\n          dp[i][k] = max(dp[i][k], dp[i][k - T[now]] + P[now]);\n        }\n      } else {\n        for(int j : component[i]) {\n          for(int k = 0; k < T[j]; k++) {\n            int s = 0, t = 0;\n            for(int l = 0; l * T[j] + k <= S; l++) {\n              int val = dp[i][l * T[j] + k] - l * P[j];\n              while(s < t && deqv[t - 1] <= val) --t;\n              deq[t] = l;\n              deqv[t++] = val;\n              dp[i][l * T[j] + k] = deqv[s] + l * P[j];\n              if(deq[s] == l - K[j]) ++s;\n            }\n          }\n        }\n      }\n      for(int k = 0; k <= S; k++) {\n        ret = max(ret, dp[i][k]);\n        for(int j : dag[i]) dp[j][k] = max(dp[j][k], dp[i][k]);\n      }\n    }\n\n    printf(\"%d\\n\", ret);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define MAX_T 10005\n#define MAX_V 105\nusing namespace std;\n\ntypedef pair<int,int> P;\n\n/* ?????£?????????????§£ O(|V|+|E|) */\nint V; //????????°\nvector<int> G[MAX_V]; //??°???????????£??\\??????????????¨???\nvector<int> rG[MAX_V];//?????????????????????????????°??????\nvector<int> vs;       //??°?????????????????????\nbool used[MAX_V];     //?????§???????????????\nint cmp[MAX_V];       //?±????????????£?????????????????????????????????\n\nvoid add_edge(int from,int to){\n  G[from].push_back(to);\n  rG[to].push_back(from);\n}\n\nvoid dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++)if(!used[G[v][i]])dfs(G[v][i]);\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v]=true;\n  cmp[v]=k;\n  for(int i=0;i<rG[v].size();i++) if(!used[rG[v][i]])rdfs(rG[v][i],k);\n}\n\nint scc(){\n  memset(used,0,sizeof(used));\n  vs.clear();\n  for(int v=0;v<V;v++) if(!used[v]) dfs(v);\n  \n  memset(used,0,sizeof(used));\n  int k=0;\n  for(int i=vs.size()-1;i>=0;i--)if(!used[vs[i]]) rdfs(vs[i],k++);\n  return k;\n}\n\nint N, M, T, p[MAX_V], t[MAX_V], k[MAX_V], memo[MAX_V];\nint dp[MAX_V][MAX_T], C[MAX_V];\n\nvoid solve(){\n  \n  vector<P> order;\n  map<int,int> cnt;\n  \n  for(int i=0;i<N;i++){\n    order.push_back(P(cmp[i],i));\n    cnt[cmp[i]]++;\n  }\n  \n  sort(order.begin(),order.end());\n  \n  memset(dp,-1,sizeof(dp));\n  \n  int ans=0;\n  \n  for(int i=0;i<N;i++){\n    \n    if(!i||(i&&C[order[i].second]!=C[order[i-1].second])) dp[i][0]=0;\n    else for(int j=0;j<=T;j++) dp[i][j]=dp[i-1][j];\n    \n    int maxk=k[order[i].second];\n    \n    if(!memo[cmp[order[i].second]]&&cnt[cmp[order[i].second]]==1) maxk=1;\n    \n    int x=1;\n    while(x<=maxk) x*=2;\n    \n    while(maxk){\n      \n      while(x-1<=maxk){\n\t\n\tmaxk-=x-1;\n\t\n\tint x2=1, y=t[order[i].second], z=p[order[i].second];\n\t\n\twhile(x2<x){\n\t  \n\t  for(int j=T-1;j>=0;j--){\n\t    if(dp[i][j]==-1) continue;\n\t    \n\t    if(j+y<=T) dp[i][j+y]=max(dp[i][j+y], dp[i][j]+z);\n\t  }\n\t  \n\t  x2*=2;\n\t  y*=2;\n\t  z*=2;\n\t}\n\t\n      }\n      \n      x/=2;\n    }\n    \n    for(int j=0;j<=T;j++) ans=max(ans,dp[i][j]);\n    \n  }\n  \n  cout<<ans<<endl;\n}\n\nvoid init(){\n  \n  memset(memo,0,sizeof(memo));\n  \n  for(int i=0;i<N;i++){\n    G[i].clear();\n    rG[i].clear();\n  }\n  \n  vs.clear();\n  \n}\n\nint used2[MAX_V];\n\nvoid dfs2(int x, int color){\n  \n  if(used2[x]) return ;\n  used2[x]=1;\n  \n  C[x]=color;\n  \n  for(int i=0;i<G[x].size();i++) dfs2(G[x][i],color);\n  \n}\n\nsigned main(){\n\n  while(1){\n  \n    cin>>N>>M>>T;\n    if(!N&&!M&&!T) break;\n    \n    V=N;\n  \n    init();\n  \n    for(int i=0;i<N;i++)\n      cin>>p[i]>>t[i]>>k[i];\n    \n    memset(used2,0,sizeof(used2));\n    memset(memo,0,sizeof(memo));\n    \n    for(int i=0;i<M;i++){\n      int a, b;\n      cin>>a>>b;\n      add_edge(a-1,b-1);\n      if(a==b) memo[a-1]=1;\n    }\n    \n    for(int i=0;i<N;i++)\n      if(!used2[i]) dfs2(i,i);\n    \n    scc();\n    \n    solve();\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <complex>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << (x) << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 2010\n\nvector<vector<int> > G, rev, G2, rev2;\nvector<int> id;\nvector<int> idDic;\nvector<vector<int> > groupList;\nvector<int> group;\nvector<vector<int> > dp;\n\nint dfs1(int now, int num=1){\n  if(id[now] != -1) return num;\n\n  id[now] = 0;\n  \n  for(int i=0;i<G[now].size();i++){\n    num = dfs1(G[now][i], num);\n  }\n\n  id[now] = num;\n  idDic[num] = now;\n  num++;\n\n  return num;\n}\n\nbool dfs2(int now, int g){\n  if(group[now] >= 0)\n    return false;\n\n  group[now] = g;\n  groupList[g].push_back(now);\n  \n  for(int i=0;i<rev[now].size();i++)\n    dfs2(rev[now][i], g);\n\n  return true;\n}\n\nvector<int> TopologicalSort(vector<vector<int> > G,int n= -1){\n  if(n==-1) n=(int)G.size();\n  \n  int u;\n  vector<int> ret,ret2;\n  queue<int> que;\n  vector<int> indeg(n+1,0);\n  \n  for(int i=0;i<n;i++){\n    for(int j=0;j<G[i].size();j++){\n      indeg[G[i][j]]++;\n    }\n  }\n  \n  for(int i=0;i<n;i++){\n    if(indeg[i]==0){\n      que.push(i);\n    }\n  }\n  \n  while(!que.empty()){\n    u = que.front();\n    que.pop();\n    \n    ret.push_back(u);\n    \n    for(int i=0;i<G[u].size();i++){\n      indeg[G[u][i]]--;\n      if(indeg[G[u][i]]==0){\n        que.push(G[u][i]);\n      }\n    }\n  }\n  \n  if(n==(int)ret.size()){\n    return ret;\n  }else{\n    return ret2;\n  }\n}\n\nbool solve(){\n  int N,M,T;\n  int p[SIZE], t[SIZE], k[SIZE];\n  int a[SIZE], b[SIZE];\n  bool selfloop[SIZE] = {};\n  \n  scanf(\"%d%d%d\",&N,&M,&T);\n\n  if(N == 0) return false;\n  \n  G.assign(N, vector<int>());\n  rev.assign(N, vector<int>());\n  G2.assign(N, vector<int>());\n  rev2.assign(N, vector<int>());\n  id.assign(N, -1);\n  idDic.assign(N, -1);\n  group.assign(N, -1);\n  groupList.assign(N, vector<int>());\n\n  for(int i=0;i<N;i++)\n    scanf(\"%d%d%d\",p+i, t+i, k+i);\n  \n  for(int i=0;i<M;i++){\n    scanf(\"%d%d\",a+i, b+i);\n    a[i]--; b[i]--;\n    G[a[i]].push_back(b[i]);\n    rev[b[i]].push_back(a[i]);\n\n    if(a[i] == b[i])\n      selfloop[a[i]] = true;\n  }\n  \n  int num = 1, g = 0;\n  for(int i=0;i<N;i++) num = dfs1(i, num);\n  for(int i=N;i>=1;i--) g += dfs2(idDic[i], g);\n  assert(num == N+1);\n  \n  bool used[110][110] = {};\n  \n  for(int i=0;i<M;i++){\n    int ga = group[a[i]];\n    int gb = group[b[i]];\n    if(!used[ga][gb] && ga != gb){\n       G2[ga].push_back(gb);\n       rev2[gb].push_back(ga);\n       used[ga][gb] = true;\n    }\n  }\n\n  auto vec = TopologicalSort(G2, g);\n  dp.assign(g, vector<int>(T+1, -INF));\n  int ans = 0;\n  \n  for(int i=0;i<g;i++){\n    int gid = vec[i];\n    dp[gid][0] = 0;\n    bool flag = groupList[gid].size() > 1 || selfloop[groupList[gid][0]];\n    \n    for(int j=0;j<rev2[gid].size();j++){\n      for(int l=0;l<=T;l++)\n        dp[gid][l] = max(dp[gid][l], dp[rev2[gid][j]][l]);\n    }\n    \n    for(int j=0;j<groupList[gid].size();j++){\n      int q = groupList[gid][j];\n      int curk = flag ? k[q] : 1;\n      \n      for(int base=0;base<t[q];base++){\n        priority_queue<pair<int,int> > pq;\n        for(int l=base;l<=T;l+=t[q]){\n          while(pq.size() && pq.top().second + curk < l/t[q])\n            pq.pop();\n          \n          if(pq.size()){\n            auto pqtop = pq.top();\n            if(dp[gid][l] >= 0) pq.push({dp[gid][l] - l/t[q] * p[q], l/t[q]});\n            dp[gid][l] = max(dp[gid][l], pqtop.first + l/t[q] * p[q]);\n          }else{\n            if(dp[gid][l] >= 0) pq.push({dp[gid][l] - l/t[q] * p[q], l/t[q]});\n          }\n        }\n      }\n    }\n\n    for(int j=0;j<=T;j++){\n      ans = max(ans, dp[gid][j]);\n    }\n  }\n\n  printf(\"%d\\n\",ans);\n\n  return true;\n}\n\nint main(){\n\n  while(solve());\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\n\ntemplate<class T> inline void chmax(T &a, const T &b) { if(a < b) a = b; }\n\ntypedef vector<vector<int>> graph;\n\n// SCC Strongly Connected Component 強連結成分分解\nstruct SCC {\n\tint V;\n\tint cV;\n\tgraph G;\n\tgraph cG;\n\tvector<int> cmp;\n\tvector<int> vs;\n\tvector<bool> used;\n\tvector<vector<int>> nodes;\n\n\tSCC(int V_):V(V_), G(V_), cmp(V_), used(V_) {}\n\tSCC(const graph &G_):V(G_.size()), G(G_), cmp(V), used(V) {}\n\n\tvoid add_edge(int from, int to) {\n\t\tG[from].emplace_back(to);\n\t}\n\n\tvoid dfs(int v) {\n\t\tused[v] = true;\n\t\tfor(const auto &to : G[v]) {\n\t\t\tif(!used[to]) dfs(to);\n\t\t}\n\t\tvs.emplace_back(v);\n\t}\n\n\tvoid rdfs(int v, int k, graph &rG) {\n\t\tused[v] = true;\n\t\tcmp[v] = k;\n\t\tfor(const auto &to : rG[v]) {\n\t\t\tif(!used[to]) rdfs(to, k, rG);\n\t\t}\n\t}\n\n\tint scc() {\n\t\tvs.clear();\n\t\tfill(used.begin(), used.end(), false);\n\n\t\tfor(int v = 0; v < V; ++v) {\n\t\t\tif(!used[v]) dfs(v);\n\t\t}\n\n\t\tgraph rG(V);\n\t\tfor(int v = 0; v < V; ++v) {\n\t\t\tfor(const auto &to : G[v]) {\n\t\t\t\trG[to].emplace_back(v);\n\t\t\t}\n\t\t}\n\n\t\tfill(used.begin(), used.end(), false);\n\t\tint k = 0;\n\t\tfor(int i = static_cast<int>(vs.size()) - 1; i >= 0; --i) {\n\t\t\tif(!used[vs[i]]) rdfs(vs[i], k++, rG);\n\t\t}\n\t\treturn k;\n\t}\n\n\tvoid construct() {\n\t\tcV = scc();\n\t\tcG.clear();\n\t\tcG.resize(cV);\n\t\tnodes.resize(cV);\n\n\t\tfor(int v = 0; v < V; ++v) {\n\t\t\tnodes[cmp[v]].emplace_back(v);\n\t\t\tfor(const auto &to : G[v]) {\n\t\t\t\tif(cmp[v] != cmp[to]) cG[cmp[v]].emplace_back(cmp[to]);\n\t\t\t}\n\t\t}\n\n\t\tfor(auto &es : cG) {\n\t\t\tsort(es.begin(), es.end());\n\t\t\tes.erase(unique(es.begin(), es.end()), es.end());\n\t\t}\n\t}\n};\n\nconstexpr int MAX_N = 100;\nconstexpr int MAX_T = 10000;\n\nint p[MAX_N];\nint t[MAX_N];\nint k[MAX_N];\nbool selfloop[MAX_N];\nint local_score[MAX_N][MAX_T + 1];\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tfor(int N, M, T; cin >> N >> M >> T && N;) {\n\t\tfor(int i = 0; i < N; ++i) {\n\t\t\tcin >> p[i] >> t[i] >> k[i];\n\t\t}\n\n\t\tmemset(selfloop, false, sizeof(selfloop));\n\n\t\tSCC scc(N);\n\t\tfor(int i = 0; i < M; ++i) {\n\t\t\tint a, b;\n\t\t\tcin >> a >> b;\n\n\t\t\tif(a == b) {\n\t\t\t\tselfloop[a - 1] = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tscc.add_edge(a - 1, b - 1);\n\t\t\t}\n\t\t}\n\n\t\tscc.construct();\n\n\t\tvector<int> in(scc.cV, 0);\n\t\tfor(const auto &edges : scc.cG) {\n\t\t\tfor(const auto &to : edges) {\n\t\t\t\t++in[to];\n\t\t\t}\n\t\t}\n\n\t\tqueue<int> que;\n\t\tfor(int v = 0; v < scc.cV; ++v) {\n\t\t\tif(in[v] == 0) que.push(v);\n\t\t}\n\t\tmemset(local_score, 0, sizeof(local_score));\n\n\t\tint ans = 0;\n\t\twhile(!que.empty()) {\n\t\t\tconst int v = que.front();\n\t\t\tque.pop();\n\n\t\t\tauto &dp = local_score[v];\n\n\t\t\tif(scc.nodes[v].size() == 1 && !selfloop[scc.nodes[v].front()]) {\n\t\t\t\tconst int cv = scc.nodes[v].front();\n\n\t\t\t\tfor(int i = T - t[cv]; i >= 0; --i) {\n\t\t\t\t\tchmax(dp[i + t[cv]], dp[i] + p[cv]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor(const auto &cv : scc.nodes[v]) {\n\t\t\t\t\tint num = k[cv];\n\n\t\t\t\t\tfor(int j = 1; num > 0; j <<= 1) {\n\n\t\t\t\t\t\tconst int mul = min(num, j);\n\t\t\t\t\t\tnum -= mul;\n\n\t\t\t\t\t\tfor(int i = T - mul * t[cv]; i >= 0; --i) {\n\t\t\t\t\t\t\tchmax(dp[i + mul * t[cv]], dp[i] + mul * p[cv]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tchmax(ans, *max_element(dp, dp + T + 1));\n\n\t\t\tfor(const auto &to : scc.cG[v]) {\n\t\t\t\tfor(int i = 0; i <= T; ++i) {\n\t\t\t\t\tchmax(local_score[to][i], dp[i]);\n\t\t\t\t}\n\t\t\t\tif(--in[to] == 0) que.push(to);\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<functional>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\nusing namespace std;\n\n#define mind(a,b) (a>b?b:a)\n#define maxd(a,b) (a>b?a:b)\n#define absd(x) (x<0?-(x):x)\n#define pow2(x) ((x)*(x))\n#define rep(i,n) for(int i=0; i<n; ++i)\n#define repr(i,n) for(int i=n-1; i>=0; --i)\n#define repl(i,s,n) for(int i=s; i<=n; ++i)\n#define replr(i,s,n) for(int i=n; i>=s; --i)\n#define repf(i,s,n,j) for(int i=s; i<=n; i+=j)\n#define repe(e,obj) for(auto e : obj)\n\n#define SP << \" \" <<\n#define COL << \" : \" <<\n#define COM << \", \" <<\n#define ARR << \" -> \" <<\n#define PNT(STR) cout << STR << endl\n#define POS(X,Y) \"(\" << X << \", \" << Y << \")\"\n#define DEB(A) \" (\" << #A << \") \" << A\n#define DEBREP(i,n,val) for(int i=0; i<n; ++i) cout << val << \" \"; cout << endl\n#define ALL(V) (V).begin(), (V).end()\n#define INF 1000000007\n#define INFLL 10000000000000000007LL\n#define EPS 1e-9\n\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> P;\n//typedef pair<ll, ll> P;\ntypedef pair<P, int> PI;\ntypedef pair<int, P> IP;\ntypedef pair<P, P> PP;\ntypedef priority_queue<P, vector<P>, greater<P> > pvqueue;\n\n#define N 103\n#define M 1003\nint p[N], t[N], k[N];\n\n#define V 103\nint v;\nvector<int> g[V];\nvector<int> rg[V];\nint group[V];\n\nvector<int> ord;\nbool used[V];\nvoid dfs(int s) {\n  used[s] = true;\n  rep(i, g[s].size()) {\n    int t = g[s][i];\n    if(!used[t]) {\n      dfs(t);\n    }\n  }\n  ord.push_back(s);\n}\n\nvoid rdfs(int s, int col) {\n  group[s] = col;\n  used[s] = true;\n  rep(i, rg[s].size()) {\n    int t = rg[s][i];\n    if(!used[t]) {\n      rdfs(t, col);\n    }\n  }\n}\n\nint scc() {\n  rep(i, v) used[i] = false;\n  rep(i, v) {\n    if(!used[i]) dfs(i);\n  }\n  ord.clear();\n  rep(i, v) used[i] = false;\n  int cnt = 0;\n  repr(i, v) {\n    int s = ord[i];\n    if(!used[s]) rdfs(s, cnt++);\n  }\n  return cnt;\n}\n\nvector<int> g2[V];\nvector<int> rg2[V];\nvector<int> els[V];\nbool eused[N][N];\nbool self[N];\n\nint n, m, ti;\n\n\n#define W 10005\nint deq[W];\nll deqv[W];\n\nll dp[V][W];\nll sdfs(int v, int idx) {\n  ll res = 0, r;\n  if(els[v].size() == 1 && !self[v]) {\n    int u = els[v][0];\n    rep(i, ti+1) dp[idx+1][i] = dp[idx][i];\n    rep(j, ti-t[u]+1) {\n      dp[idx+1][j+t[u]] = r = maxd(dp[idx+1][j+t[u]], dp[idx][j] + p[u]);\n      res = maxd(res, r);\n    }\n    ++idx;\n  } else {\n    rep(i, els[v].size()) {\n      int u = els[v][i];\n      rep(j, ti+1) dp[idx+1][j] = dp[idx][j];\n\n      rep(a, t[u]) {\n        int sq = 0, tq = 0;\n        for(int j=0; j*t[u]+a <= ti; ++j) {\n          ll val = dp[idx+1][j*t[u] + a] - j*p[u];\n          while(sq < tq && deqv[tq - 1] <= val) --tq;\n          deq[tq] = j;\n          deqv[tq++] = val;\n\n          dp[idx+1][j*t[u] + a] = r = deqv[sq] + j*p[u];\n          if(deq[sq] == j - k[u]) ++sq;\n          res = maxd(res, r);\n        }\n      }\n      ++idx;\n    }\n  }\n  rep(i, g2[v].size()) {\n    int to = g2[v][i];\n    ll ret = sdfs(to, idx);\n    res = maxd(res, ret);\n  }\n  return res;\n}\n\nint main() {\n  while(cin >> n >> m >> ti && n+m+ti) {\n    rep(i, n) {\n      cin >> p[i] >> t[i] >> k[i];\n      g[i].clear();\n      rg[i].clear();\n    }\n    rep(i, m) {\n      int a, b;\n      cin >> a >> b; --a; --b;\n      g[a].push_back(b);\n      rg[b].push_back(a);\n    }\n\n    v = n;\n    int w = scc();\n    rep(i, w) rep(j, w) eused[i][j] = false;\n    rep(i, w) {\n      g2[i].clear();\n      rg2[i].clear();\n      els[i].clear();\n      self[i] = false;\n    }\n    rep(i, n) {\n      int c = group[i];\n      els[c].push_back(i);\n      rep(j, g[i].size()) {\n        int d = group[g[i][j]];\n        if(c==d) {\n          self[c] = true;\n          continue;\n        }\n        if(eused[c][d]) continue;\n        g2[c].push_back(d);\n        rg2[d].push_back(c);\n        eused[c][d] = true;\n      }\n    }\n\n    ll ans = 0;\n    rep(i, w) {\n      if(rg2[i].empty()) {\n        ll r = sdfs(i, 0);\n        ans = maxd(ans, r);\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int MAXN = 200, MAXT = 10000 + 10;\n\nvector<int> G[MAXN];\nbool mark[MAXN];\nint p[MAXN], t[MAXN], k[MAXN];\nint N, M, T;\n\nnamespace SCC {\n  vector<int> SCC[MAXN], SCCG[MAXN];\n  int low[MAXN], dfn[MAXN], ord[MAXN];\n  int scc_cnt;\n  void dfs(int x) {\n    static int stk[MAXN], top = 0, sz = 0;\n    stk[++ top] = x; low[x] = dfn[x] = ++ sz;\n    for (auto &y : G[x]) {\n      if (!dfn[y]) {\n        dfs(y); low[x] = min(low[x], low[y]);\n      }\n      else if (ord[y] == -1) low[x] = min(low[x], dfn[y]);\n    }\n    if (dfn[x] == low[x]) {\n      SCC[scc_cnt ++].clear();\n      do {\n        SCC[scc_cnt - 1].push_back(stk[top]);\n        ord[stk[top]] = scc_cnt - 1;\n      } while (x != stk[top --]);\n    }\n  }\n  void scc() {\n    memset(dfn, 0, sizeof(dfn));\n    memset(ord, -1, sizeof(ord));\n    scc_cnt = 0;\n    for (int i = 0; i < N; ++ i) {\n      if (!dfn[i]) dfs(i);\n    }\n  }\n  void build() {\n    for (int i = 0; i < scc_cnt; ++ i) {\n      SCCG[i].clear();\n      for (auto &u : SCC[i]) for (auto &v : G[u]) {\n        if (ord[v] != ord[u]) SCCG[i].push_back(ord[v]);\n      }\n      sort(SCCG[i].begin(), SCCG[i].end());\n      SCCG[i].resize(unique(SCCG[i].begin(), SCCG[i].end()) - SCCG[i].begin());\n    }\n  }\n  int deg[MAXN], self[MAXN];\n  int dp[MAXN][MAXT];\n  void update(int x) {\n    vector<PII> item;\n    for (auto &u : SCC[x]) {\n      for (int s = 1; s <= k[u]; s <<= 1) {\n        item.push_back(PII(s * t[u], s * p[u]));\n        k[u] -= s;\n      }\n      if (k[u]) item.push_back(PII(k[u] * t[u], k[u] * p[u]));\n    }\n    for (auto &v : item) {\n      for (int i = T; i >= v.first; -- i) {\n        dp[x][i] = max(dp[x][i], dp[x][i - v.first] + v.second);\n      }\n    }\n  }\n  int solve() {\n    scc(); build();\n    memset(deg, 0, sizeof(deg));\n    for (int i = 0; i < scc_cnt; ++ i) {\n      self[i] = (SCC[i].size() == 1 && mark[SCC[i][0]]);\n      for (auto &v : SCCG[i]) deg[v] ++;\n      for (int j = 0; j <= T; ++ j) dp[i][j] = 0;\n    }\n    queue<int> Q;\n    for (int i = 0; i < scc_cnt; ++ i) {\n      if (deg[i] == 0) Q.push(i);\n    }\n    while (!Q.empty()) {\n      int x = Q.front(); Q.pop();\n      if (SCC[x].size() == 1 && !self[x]) {\n        int u = SCC[x][0];\n        for (int j = T - t[u]; j >= 0; -- j) {\n          dp[x][j + t[u]] = max(dp[x][j + t[u]], dp[x][j] + p[u]);\n        }\n      }\n      else update(x);\n      for (auto &y : SCCG[x]) {\n        for (int i = 0; i <= T; ++ i) {\n          dp[y][i] = max(dp[y][i], dp[x][i]);\n        }\n        if (-- deg[y] == 0) Q.push(y);\n      }\n    }\n    int ret = 0;\n    for (int i = 0; i < scc_cnt; ++ i) {\n      for (int j = 0; j <= T; ++ j) {\n        ret = max(ret, dp[i][j]);\n      }\n    }\n    return ret;\n  }\n}\nint main() {\n  while (scanf(\"%d%d%d\", &N, &M, &T) == 3 && N) {\n    for (int i = 0; i < N; ++ i) {\n      G[i].clear(); mark[i] = false;\n      scanf(\"%d%d%d\", p + i, t + i, k + i);\n    }\n    for (int i = 0; i < M; ++ i) {\n      int u, v; scanf(\"%d%d\", &u, &v);\n      -- u, -- v; G[u].push_back(v);\n      if (u == v) mark[u] = true;\n    }\n    printf(\"%d\\n\", SCC::solve());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 105\n\nstruct Info{\n\tint point,time,limit;\n};\n\nstruct GROUP{\n\tvector<int> nodes;\n};\n\nint N,M,T;\n\nGROUP group[NUM]; //強連結成分のグループ\nvector<int> G[NUM],GROUP_G[NUM];\nvector<int> reverse_G[NUM];\nstack<int> S;\n\nbool check[NUM],have_self_link[NUM],G_check[NUM][NUM],calc_check[NUM];\nint table[NUM],in_num[NUM];;\ndouble sleep[NUM];\nInfo info[NUM];\nint ans;\n\nint group_index;\n\nvoid dfs(int node_id){\n\tcheck[node_id] = true;\n\n\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\tif(!check[G[node_id][i]])dfs(G[node_id][i]);\n\t}\n\tS.push(node_id);\n}\n\nvoid reverse_dfs(int node_id){\n\tcheck[node_id] = true;\n\n\tgroup[group_index].nodes.push_back(node_id); //group[group_index]にノードを突っ込む\n\ttable[node_id] = group_index;\n\n\tfor(int i = 0; i < reverse_G[node_id].size(); i++){\n\t\tif(!check[reverse_G[node_id][i]])reverse_dfs(reverse_G[node_id][i]);\n\t}\n}\n\nvoid recursive(int group_id,int tmp_dp[10001]){\n\n\tcalc_check[group_id] = true; //1度通れば良し\n\n\tint dp[10001],next_dp[10001];\n\tfor(int i = 0; i <= T; i++){\n\t\tdp[i] = tmp_dp[i];\n\t\tnext_dp[i] = dp[i];\n\t}\n\n\tint node_id;\n\tfor(int i = 0; i < group[group_id].nodes.size(); i++){\n\t\tnode_id = group[group_id].nodes[i];\n\t\t//printf(\"node_id:%d\\n\",node_id);\n\n\t\tfor(int k = 1; k <= info[node_id].limit; k++){\n\t\t\tfor(int t = T; t-info[node_id].time*k >= 0; t--){\n\t\t\t\tif(dp[t-info[node_id].time*k] == -1)continue;\n\t\t\t\tnext_dp[t] = max(next_dp[t],dp[t-info[node_id].time*k]+info[node_id].point*k);\n\t\t\t}\n\t\t}\n\t\tfor(int k = 0; k <= T; k++)dp[k] = next_dp[k]; //★サイト毎にdpの更新が必要★\n\t}\n\n\t/*for(int i = 0; i <= T; i++)ans = max(ans,next_dp[i]);\n\t//printf(\"ans:%d\\n\",ans);*/\n\n\tif(GROUP_G[group_id].size() == 0){ //DAGの終点\n\n\t\t//printf(\"%dは終点です\\n\",group_id);\n\n\t\tfor(int i = 0; i <= T; i++)ans = max(ans,next_dp[i]);\n\n\t}else{\n\n\t\tfor(int i = 0; i < GROUP_G[group_id].size(); i++){\n\t\t\trecursive(GROUP_G[group_id][i],next_dp);\n\t\t\t//printf(\"グループ%dから%dへ\\n\",group_id,GROUP_G[group_id][i]);\n\t\t}\n\t}\n}\n\nvoid func(){\n\n\tfor(int i = 0; i < N; i++){\n\t\tG[i].clear();\n\t\treverse_G[i].clear();\n\t\thave_self_link[i] = false;\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d %d %d\",&info[i].point,&info[i].time,&info[i].limit);\n\t}\n\n\tint from,to;\n\n\tfor(int loop = 0; loop < M; loop++){\n\t\tscanf(\"%d %d\",&from,&to);\n\t\tfrom--;\n\t\tto--;\n\n\t\tif(from == to){\n\t\t\thave_self_link[from] = true; //★強連結成分扱いとする(自分に戻れる)★\n\t\t\tcontinue;\n\t\t}\n\t\tG[from].push_back(to);\n\t\treverse_G[to].push_back(from);\n\t}\n\n\tfor(int i = 0; i < N; i++)check[i] = false;\n\n\t//まずは帰りがけ順を計算\n\tfor(int i = 0; i < N;i++){\n\t\tif(!check[i])dfs(i);\n\t}\n\n\tfor(int i = 0; i < N;i++)check[i] = false;\n\tfor(int i = 0; i < NUM; i++){\n\t\tgroup[i].nodes.clear();\n\t\tGROUP_G[i].clear();\n\t\tcalc_check[i] = false;\n\t\tin_num[i] = 0;\n\t\tfor(int k = 0; k < NUM; k++){\n\t\t\tG_check[i][k] = false;\n\t\t}\n\t}\n\n\n\tgroup_index = -1;\n\t//ノードを、帰りがけ順の逆順に、各強連結成分(グループ)に分解\n\twhile(!S.empty()){\n\t\tif(!check[S.top()]){\n\t\t\tgroup_index++;\n\n\t\t\treverse_dfs(S.top());\n\t\t}\n\t\tS.pop();\n\t}\n\n\tint node_id,adj_node,adj_group;\n\t//グループ間の有向エッジを探す\n\tfor(int i = 0; i <= group_index; i++){\n\t\tfor(int k = 0; k < group[i].nodes.size(); k++){\n\t\t\tnode_id = group[i].nodes[k];\n\t\t\tfor(int a = 0; a < G[node_id].size(); a++){\n\t\t\t\tadj_node = G[node_id][a];\n\t\t\t\tadj_group = table[adj_node];\n\t\t\t\tif(adj_group == i || G_check[i][adj_group] == true)continue;\n\t\t\t\tG_check[i][adj_group] = true;\n\t\t\t\tGROUP_G[i].push_back(adj_group);\n\t\t\t\tin_num[adj_group]++;\n\t\t\t}\n\t\t}\n\t}\n\n\t//あらかじめ、強連結成分でなく、かつ自己ループを持たないサイトは、制限個数を1にしておく\n\tfor(int i = 0; i <= group_index; i++){\n\t\tif(group[i].nodes.size() == 1 && have_self_link[group[i].nodes[0]] == false){\n\t\t\tinfo[group[i].nodes[0]].limit = 1;\n\t\t\t//printf(\"%dは1回\\n\",group[i].nodes[0]);\n\t\t}\n\t}\n\n\tans = 0;\n\n\tint first_dp[10001];\n\tfirst_dp[0] = 0;\n\tfor(int i = 1; i <= T; i++)first_dp[i] = -1;\n\n\tfor(int start_group = 0; start_group <= group_index; start_group++){\n\t\tif(in_num[start_group] == 0)\n\t\trecursive(start_group,first_dp);\n\t}\n\n\tprintf(\"%d\\n\",ans);\n}\n\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d %d\",&N,&M,&T);\n\t\tif(N == 0 && M == 0 && T == 0)break;\n\n\t\tfunc();\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define MAX_T 10005\n#define MAX_V 105\nusing namespace std;\n\ntypedef pair<int,int> P;\n\n/* ?????£?????????????§£ O(|V|+|E|) */\nint V; //????????°\nvector<int> G[MAX_V]; //??°???????????£??\\??????????????¨???\nvector<int> rG[MAX_V];//?????????????????????????????°??????\nvector<int> vs;       //??°?????????????????????\nbool used[MAX_V];     //?????§???????????????\nint cmp[MAX_V];       //?±????????????£?????????????????????????????????\n\nvoid add_edge(int from,int to){\n  G[from].push_back(to);\n  rG[to].push_back(from);\n}\n\nvoid dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++)if(!used[G[v][i]])dfs(G[v][i]);\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v]=true;\n  cmp[v]=k;\n  for(int i=0;i<rG[v].size();i++) if(!used[rG[v][i]])rdfs(rG[v][i],k);\n}\n\nint scc(){\n  memset(used,0,sizeof(used));\n  vs.clear();\n  for(int v=0;v<V;v++) if(!used[v]) dfs(v);\n  \n  memset(used,0,sizeof(used));\n  int k=0;\n  for(int i=vs.size()-1;i>=0;i--)if(!used[vs[i]]) rdfs(vs[i],k++);\n  return k;\n}\n\nint N, M, T, K, p[MAX_V], t[MAX_V], k[MAX_V], memo[MAX_V];\nint dp[MAX_V][MAX_T], C[MAX_V];\n\nvector<int> G2[MAX_V];\nvector<int> nodelist[MAX_V];\n\nvoid solve(){\n    \n  memset(dp,-1,sizeof(dp));\n\n  for(int i=0;i<K;i++) dp[i][0]=0;\n  \n  for(int i=0;i<N;i++)\n    nodelist[cmp[i]].push_back(i);\n  \n  int ans=0;\n  \n  for(int i=0;i<K;i++){\n    \n    for(int j=0;j<nodelist[cmp[i]].size();j++){\n      \n      int node=nodelist[cmp[i]][j];\n      \n      int maxk=k[node];\n      \n      if(!memo[node]&&nodelist[cmp[i]].size()==1) maxk=1;\n      \n      int x=1;\n    \n      while(maxk){\n      \n\tif(maxk<x) x=maxk;\n\n\tint y=t[node]*x, z=p[node]*x;\n\t\n\tfor(int l=T;l>=0;l--){\n\t  \n\t  if(dp[i][l]==-1) continue;\n\t\n\t  if(l+y<=T) dp[i][l+y]=max(dp[i][l+y], dp[i][l]+z);\n\t}\n      \n\tmaxk-=x;\n      \n\tx*=2;\n      }\n\n      for(int l=0;l<=T;l++) ans=max(ans,dp[i][l]);\n      \n    }\n    \n    for(int j=0;j<G2[i].size();j++)\n      for(int l=0;l<=T;l++) dp[G2[i][j]][l]=max(dp[G2[i][j]][l],dp[i][l]);\n    \n  }\n  \n  cout<<ans<<endl;\n}\n\nvoid init(){\n  \n  memset(memo,0,sizeof(memo));\n  \n  for(int i=0;i<N;i++){\n    G[i].clear();\n    rG[i].clear();\n    G2[i].clear();\n    nodelist[i].clear();\n  }\n  \n  vs.clear();\n  \n}\n\nint used2[MAX_V];\n\nvoid dfs2(int x, int color){\n  \n  if(used2[x]) return ;\n  used2[x]=1;\n  \n  C[x]=color;\n  \n  for(int i=0;i<G[x].size();i++) dfs2(G[x][i],color);\n  \n}\n\nsigned main(){\n\n  while(1){\n    \n    cin>>N>>M>>T;\n    if(!N&&!M&&!T) break;\n    \n    V=N;\n    \n    init();\n    \n    for(int i=0;i<N;i++)\n      cin>>p[i]>>t[i]>>k[i];\n    \n    memset(used2,0,sizeof(used2));\n    \n    for(int i=0;i<M;i++){\n      int a, b;\n      cin>>a>>b;\n      add_edge(a-1,b-1);\n    }\n    \n    for(int i=0;i<N;i++)\n      if(!used2[i]) dfs2(i,i);\n    \n    K=scc();\n    \n    set<P> S;\n    \n    for(int i=0;i<N;i++)\n      for(int j=0;j<G[i].size();j++)\n\t\n\tif(!S.count(P(cmp[i],cmp[G[i][j]]))){\n\t  if(cmp[i]==cmp[G[i][j]]){\n\t    memo[cmp[i]]=1;\n\t    continue;\n\t  }\n\t  S.insert(P(cmp[i],cmp[G[i][j]]));\n\t  G2[cmp[i]].push_back(cmp[G[i][j]]);\n\t}\n    \n    solve();\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct StronglyConnectedComponents\n{\n  vector< vector< int > > gg, rg;\n  vector< pair< int, int > > edges;\n  vector< int > comp, order, used;\n\n  StronglyConnectedComponents(size_t v) : gg(v), rg(v), comp(v, -1), used(v, 0) {}\n\n  void add_edge(int x, int y)\n  {\n    gg[x].push_back(y);\n    rg[y].push_back(x);\n    edges.emplace_back(x, y);\n  }\n\n  int operator[](int k)\n  {\n    return (comp[k]);\n  }\n\n  void dfs(int idx)\n  {\n    if(used[idx]) return;\n    used[idx] = true;\n    for(int to : gg[idx]) dfs(to);\n    order.push_back(idx);\n  }\n\n  void rdfs(int idx, int cnt)\n  {\n    if(comp[idx] != -1) return;\n    comp[idx] = cnt;\n    for(int to : rg[idx]) rdfs(to, cnt);\n  }\n\n  void build(vector< vector< int > > &t)\n  {\n    for(int i = 0; i < gg.size(); i++) dfs(i);\n    reverse(begin(order), end(order));\n    int ptr = 0;\n    for(int i : order) rdfs(i, ptr), ptr++;\n\n    t.resize(ptr);\n    set< pair< int, int > > connect;\n    for(auto &e : edges) {\n      int x = comp[e.first], y = comp[e.second];\n      if(x == y) continue;\n      if(connect.count({x, y})) continue;\n      t[x].push_back(y);\n      connect.emplace(x, y);\n    }\n  }\n};\n\nint main()\n{\n  int N, M, S, P[100], T[100], K[100];\n  bool mine[100];\n  int deq[10001], deqv[10001];\n\n  while(scanf(\"%d %d %d\", &N, &M, &S), N) {\n    for(int i = 0; i < N; i++) {\n      scanf(\"%d %d %d\", &P[i], &T[i], &K[i]);\n    }\n    StronglyConnectedComponents g(N);\n    memset(mine, false, sizeof(mine));\n    for(int i = 0; i < M; i++) {\n      int x, y;\n      scanf(\"%d %d\", &x, &y);\n      g.add_edge(--x, --y);\n      if(x == y) mine[x] = true;\n    }\n\n    vector< vector< int > > dag;\n    g.build(dag);\n    vector< vector< int > > component(dag.size());\n    for(int i = 0; i < N; i++) component[g[i]].push_back(i);\n\n    vector< vector< int > > dp(dag.size(), vector< int >(S + 1, 0));\n    int ret = 0;\n\n    for(int i = 0; i < dag.size(); i++) {\n      if(component[i].size() == 1 && !mine[component[i][0]]) {\n        int now = component[i][0];\n        for(int k = S; k >= T[now]; k--) {\n          dp[i][k] = max(dp[i][k], dp[i][k - T[now]] + P[now]);\n        }\n      } else {\n        for(int j : component[i]) {\n          for(int k = 0; k < T[j]; k++) {\n            int s = 0, t = 0;\n            for(int l = 0; l * T[j] + k <= S; l++) {\n              int val = dp[i][l * T[j] + k] - l * P[j];\n              while(s < t && deqv[t - 1] <= val) --t;\n              deq[t] = l;\n              deqv[t++] = val;\n              dp[i][l * T[j] + k] = deqv[s] + l * P[j];\n              if(deq[s] == l - K[j]) ++s;\n            }\n          }\n        }\n      }\n      for(int k = 0; k <= S; k++) {\n        ret = max(ret, dp[i][k]);\n        for(int j : dag[i]) dp[j][k] = max(dp[j][k], dp[i][k]);\n      }\n    }\n\n    printf(\"%d\\n\", ret);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\n\nconst int vmax=110;\n\nint V;\nvi G[vmax];\nvi rG[vmax];\nvi vs;\nbool used[vmax];\nint cmp[vmax];\n\n\nvoid add_edge(int from,int to){\n\tG[from].push_back(to);\n\trG[to].push_back(from);\n}\n\nvoid dfs(int v){\n\tused[v]=true;\n\tfor(int i=0;i<G[v].size();i++)\n\t\tif(!used[G[v][i]])\n\t\t\tdfs(G[v][i]);\n\tvs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n\tused[v]=true;\n\tcmp[v]=k;\n\n\tfor(int i=0;i<rG[v].size();i++)\n\t\tif(!used[rG[v][i]])\n\t\t\trdfs(rG[v][i],k);\n}\n\nint scc(void){\n\tmemset(used,0,sizeof(used));\n\tvs.clear();\n\tfor(int v=0;v< V ;v++)\n\t\tif(!used[v])\n\t\t\tdfs(v);\n\tmemset(used,0,sizeof(used));\n\tint  k=0;\n\tfor(int i=vs.size()-1;i>=0;i--){\n\t\tif(!used[vs[i]])\n\t\t\trdfs(vs[i],k++);\n\t}\n\treturn k;\n}\n\nint N,M,T;\nint dp[110][10010];\nint p[110],t[110],k[110];\nint a[1010],b[1010];\n\nbool rel[110][110];\nbool check[110];\n\nint s;\n\nint deq[10010];\nint deqv[10010];\n\nvoid solve(int cur){\n\tvi index;\n\trep(i,N) if(cur==cmp[i]) index.pb(i);\n\tif(index.size()==1&&!rel[cur][cur]){\n\t\tint tar=index[0];\n\t\tfor(int j=T;j>=t[tar];j--) dp[cur][j]=max(dp[cur][j],dp[cur][j-t[tar]]+p[tar]);\n\t}else{\n\t\tfor(auto &i :index){\n\t\t\trep(aa,t[i]){\n\t\t\t\tint ss=0,tt=0;\n\t\t\t\tfor(int j=0;j*t[i]+aa<=T;++j){\n\t\t\t\t\tint val=dp[cur][j*t[i]+aa]-j*p[i];\n\t\t\t\t\twhile(ss<tt && deqv[tt-1]<=val) tt--;\n\t\t\t\t\tdeq[tt]=j;\n\t\t\t\t\tdeqv[tt++]=val;\n\t\t\t\t\tdp[cur][j*t[i]+aa]=deqv[ss]+j*p[i];\n\t\t\t\t\tif(deq[ss]==j-k[i]) ss++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\trep(i,s) if(rel[cur][i]) rep(j,T+1) dp[i][j]=max(dp[i][j],dp[cur][j]);\n}\n\nint main(void){\n\twhile(cin >> N >> M >> T){\n\t\tif(N==0)\n\t\t\tbreak;\n\t\tV=N;\n\t\trep(i,N) cin >> p[i]  >> t[i] >> k[i];\n\n\t\trep(i,vmax) G[i].clear(),rG[i].clear();\n\t\trep(i,vmax)rep(j,10010) dp[i][j]=0;\n\t\trep(i,vmax)rep(j,vmax) rel[i][j]=false;\n\t\trep(i,vmax) check[i]=false;\n\n\t\trep(i,M){\n\t\t\tcin >> a[i] >> b[i];\n\t\t\ta[i]--,b[i]--;\n\t\t\tadd_edge(a[i],b[i]);\n\t\t}\n\n\t\ts=scc();\n\t\trep(i,M) a[i]=cmp[a[i]],b[i]=cmp[b[i]];\n\t\trep(i,M) rel[a[i]][b[i]]=true;\n\n\t\tint ans=0;\n\t\trep(i,s) solve(i);\n\n\t\trep(i,s) ans=max(ans,dp[i][T]);\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define all(a) (a).begin(),(a).end()\n#define INIT(a) memset(a,0,sizeof(a))\n\n#define fs first\n#define sc second\n#define pb push_back\n#define sz size()\n\nusing namespace std;\n\nconst int MAX_N = 110;\nconst int INF = 1e8;\n\nint level[MAX_N], iter[MAX_N];\n\nvector<int> g[MAX_N], rg[MAX_N];\nvector<int> sccg[MAX_N], sccv[MAX_N];\nvector<int> vs;\nbool use[MAX_N];\nint ord[MAX_N];\n\nint n,m,s;\nint v[MAX_N], w[MAX_N], k[MAX_N];\n\nvoid fdfs(int x){\n  use[x] = true;\n  rep(i,g[x].sz){\n    if(!use[g[x][i]])fdfs(g[x][i]);\n  }\n  vs.pb(x);\n}\n\nvoid rdfs(int x,int id){\n  use[x] = true;\n  ord[x] = id;\n  rep(i,rg[x].sz){\n    if(!use[rg[x][i]])rdfs(rg[x][i],id);\n  }\n}\n\nint scc(){\n  INIT(use);\n  vs.clear();\n  rep(i,n){\n    if(!use[i])fdfs(i);\n  }\n\n  INIT(use);\n  int id = 0;\n  rrep(i,vs.sz){\n    if(!use[vs[i]])rdfs(vs[i],id++);\n  }\n  return id;\n}\n\n\nint main(){\n  while(cin >> n >> m >> s){\n    if(n==0 && m==0 && s==0)break;\n    rep(i,n){\n      g[i].clear(); rg[i].clear();\n      sccg[i].clear(); sccv[i].clear();\n    }\n\n    rep(i,n)cin >> v[i] >> w[i] >> k[i];\n    rep(i,m){\n      int a,b;\n      cin >> a >> b; a--; b--;\n      g[a].pb(b); rg[b].pb(a);\n    }\n\n    int sccn = scc();\n\n    rep(i,n)sccv[ord[i]].pb(i);\n    rep(i,sccn){\n      for(int j : sccv[i]){\n\tfor(int u : g[j]){\n\t  if(i != ord[u])sccg[i].pb(ord[u]);\n\t}\n      }\n      sort(all(sccg[i]));\n      sccg[i].erase(unique(all(sccg[i])),sccg[i].end());\n    }\n\n    vector<int> self(sccn,0);\n    rep(i,sccn){\n      if(sccv[i].sz==1){\n\tint u = sccv[i][0];\n\tfor(int to : g[u]){\n\t  if(u == to)self[i] = 1;\n\t}\n      }\n    }\n\n    //TODO: self-loop\n    vector< vector<int> > dp(sccn, vector<int>(s+1, 0));\n    vector<int> deq(s+1), deqv(s+1);\n\n    rep(i,sccn){\n      if(sccv[i].sz > 1 || self[i]){\n\tfor(int u : sccv[i]){\n\t  for(int a=0;a<w[u];a++){\n\t    int l = 0, r = 0;\n\t    for(int j=0;j*w[u]+a<=s;j++){\n\t      int val = dp[i][j*w[u]+a] - j * v[u];\n\t      while(l < r && deqv[r-1] <= val)r--;\n\t      deq[r] = j;\n\t      deqv[r++] = val;\n\t      dp[i][j*w[u]+a] = deqv[l] + j*v[u];\n\t      if(deq[l] == j-k[u])l++;\n\t    }\n\t  }\n\t}\n      }else{\n\tint u = sccv[i][0];\n\trrep(j,s-w[u]+1){\n\t  dp[i][j+w[u]] = max(dp[i][j+w[u]], dp[i][j] + v[u]);\n\t}\n      }\n      \n      for(int u : sccg[i]){\n\trep(j,s+1)dp[u][j] = max(dp[u][j], dp[i][j]);\n      }\n    }\n\n    int res = 0;\n    rep(i,sccn)rep(j,s+1)res = max(res, dp[i][j]);\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\n\ntemplate<class T> inline void chmax(T &a, const T &b) { if(a < b) a = b; }\n\ntypedef vector<vector<int>> graph;\n\n// SCC Strongly Connected Component 強連結成分分解\nstruct SCC {\n\tint V;\n\tint cV;\n\tgraph G;\n\tgraph cG;\n\tvector<int> cmp;\n\tvector<int> vs;\n\tvector<bool> used;\n\tvector<vector<int>> nodes;\n\n\tSCC(int V_):V(V_), G(V_), cmp(V_), used(V_) {}\n\tSCC(const graph &G_):V(G_.size()), G(G_), cmp(V), used(V) {}\n\n\tvoid add_edge(int from, int to) {\n\t\tG[from].emplace_back(to);\n\t}\n\n\tvoid dfs(int v) {\n\t\tused[v] = true;\n\t\tfor(const auto &to : G[v]) {\n\t\t\tif(!used[to]) dfs(to);\n\t\t}\n\t\tvs.emplace_back(v);\n\t}\n\n\tvoid rdfs(int v, int k, graph &rG) {\n\t\tused[v] = true;\n\t\tcmp[v] = k;\n\t\tfor(const auto &to : rG[v]) {\n\t\t\tif(!used[to]) rdfs(to, k, rG);\n\t\t}\n\t}\n\n\tint scc() {\n\t\tvs.clear();\n\t\tfill(used.begin(), used.end(), false);\n\n\t\tfor(int v = 0; v < V; ++v) {\n\t\t\tif(!used[v]) dfs(v);\n\t\t}\n\n\t\tgraph rG(V);\n\t\tfor(int v = 0; v < V; ++v) {\n\t\t\tfor(const auto &to : G[v]) {\n\t\t\t\trG[to].emplace_back(v);\n\t\t\t}\n\t\t}\n\n\t\tfill(used.begin(), used.end(), false);\n\t\tint k = 0;\n\t\tfor(int i = static_cast<int>(vs.size()) - 1; i >= 0; --i) {\n\t\t\tif(!used[vs[i]]) rdfs(vs[i], k++, rG);\n\t\t}\n\t\treturn k;\n\t}\n\n\tvoid construct() {\n\t\tcV = scc();\n\t\tcG.clear();\n\t\tcG.resize(cV);\n\t\tnodes.resize(cV);\n\n\t\tfor(int v = 0; v < V; ++v) {\n\t\t\tnodes[cmp[v]].emplace_back(v);\n\t\t\tfor(const auto &to : G[v]) {\n\t\t\t\tif(cmp[v] != cmp[to]) cG[cmp[v]].emplace_back(cmp[to]);\n\t\t\t}\n\t\t}\n\n\t\tfor(auto &es : cG) {\n\t\t\tsort(es.begin(), es.end());\n\t\t\tes.erase(unique(es.begin(), es.end()), es.end());\n\t\t}\n\t}\n};\n\nconstexpr int MAX_N = 100;\nconstexpr int MAX_T = 10000;\n\nint p[MAX_N];\nint t[MAX_N];\nint k[MAX_N];\nbool selfloop[MAX_N];\nint local_score[MAX_N][MAX_T + 1];\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tfor(int N, M, T; cin >> N >> M >> T && N;) {\n\t\tfor(int i = 0; i < N; ++i) {\n\t\t\tcin >> p[i] >> t[i] >> k[i];\n\t\t}\n\n\t\tmemset(selfloop, false, sizeof(selfloop));\n\n\t\tSCC scc(N);\n\t\tfor(int i = 0; i < M; ++i) {\n\t\t\tint a, b;\n\t\t\tcin >> a >> b;\n\n\t\t\tif(a == b) {\n\t\t\t\tselfloop[a - 1] = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tscc.add_edge(a - 1, b - 1);\n\t\t\t}\n\t\t}\n\n\t\tscc.construct();\n\n\t\tvector<int> in(scc.cV, 0);\n\t\tfor(const auto &edges : scc.cG) {\n\t\t\tfor(const auto &to : edges) {\n\t\t\t\t++in[to];\n\t\t\t}\n\t\t}\n\n\t\tqueue<int> que;\n\t\tfor(int v = 0; v < scc.cV; ++v) {\n\t\t\tif(in[v] == 0) que.insert(v);\n\t\t}\n\t\tmemset(local_score, 0, sizeof(local_score));\n\n\t\tint ans = 0;\n\t\twhile(!que.empty()) {\n\t\t\tconst int v = que.front();\n\t\t\tque.pop();\n\n\t\t\tauto &dp = local_score[v];\n\n\t\t\tif(scc.nodes[v].size() == 1 && !selfloop[scc.nodes[v].front()]) {\n\t\t\t\tconst int cv = scc.nodes[v].front();\n\n\t\t\t\tfor(int i = T - t[cv]; i >= 0; --i) {\n\t\t\t\t\tchmax(dp[i + t[cv]], dp[i] + p[cv]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor(const auto &cv : scc.nodes[v]) {\n\t\t\t\t\tint num = k[cv];\n\n\t\t\t\t\tfor(int j = 1; num > 0; j <<= 1) {\n\n\t\t\t\t\t\tconst int mul = min(num, j);\n\t\t\t\t\t\tnum -= mul;\n\n\t\t\t\t\t\tfor(int i = T - mul * t[cv]; i >= 0; --i) {\n\t\t\t\t\t\t\tchmax(dp[i + mul * t[cv]], dp[i] + mul * p[cv]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tchmax(ans, *max_element(dp, dp + T + 1));\n\n\t\t\tfor(const auto &to : scc.cG[v]) {\n\t\t\t\tfor(int i = 0; i <= T; ++i) {\n\t\t\t\t\tchmax(local_score[to][i], dp[i]);\n\t\t\t\t}\n\t\t\t\tif(--in[to] == 0) que.insert(to);\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define MAX_T 10005\n#define MAX_V 105\nusing namespace std;\n\ntypedef pair<int,int> P;\n\n/* ?????£?????????????§£ O(|V|+|E|) */\nint V; //????????°\nvector<int> G[MAX_V]; //??°???????????£??\\??????????????¨???\nvector<int> rG[MAX_V];//?????????????????????????????°??????\nvector<int> vs;       //??°?????????????????????\nbool used[MAX_V];     //?????§???????????????\nint cmp[MAX_V];       //?±????????????£?????????????????????????????????\n\nvoid add_edge(int from,int to){\n  G[from].push_back(to);\n  rG[to].push_back(from);\n}\n\nvoid dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++)if(!used[G[v][i]])dfs(G[v][i]);\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v]=true;\n  cmp[v]=k;\n  for(int i=0;i<rG[v].size();i++) if(!used[rG[v][i]])rdfs(rG[v][i],k);\n}\n\nint scc(){\n  memset(used,0,sizeof(used));\n  vs.clear();\n  for(int v=0;v<V;v++) if(!used[v]) dfs(v);\n  \n  memset(used,0,sizeof(used));\n  int k=0;\n  for(int i=vs.size()-1;i>=0;i--)if(!used[vs[i]]) rdfs(vs[i],k++);\n  return k;\n}\n\nint N, M, T, p[MAX_V], t[MAX_V], k[MAX_V], memo[MAX_V];\nint dp[MAX_V][10005], C[MAX_V];\n\nvoid solve(){\n  \n  vector<P> order;\n  map<int,int> cnt;\n  \n  for(int i=0;i<N;i++){\n    order.push_back(P(cmp[i],i));\n    cnt[cmp[i]]++;\n  }\n  \n  sort(order.begin(),order.end());\n  \n  memset(dp,-1,sizeof(dp));\n  \n  int ans=0;\n    \n  for(int i=0;i<N;i++){\n    \n    if(!i||(i&&C[order[i].second]!=C[order[i-1].second])) dp[i][0]=0;\n    else for(int j=0;j<=T;j++) dp[i][j]=dp[i-1][j];\n    \n    int maxk=k[order[i].second];\n    \n    if(!memo[cmp[order[i].second]]&&cnt[cmp[order[i].second]]==1) maxk=1;\n    \n    int x=1;\n    while(x<=maxk) x*=2;\n    \n    while(maxk){\n      \n      while(x-1<=maxk){\n\t\n\tmaxk-=x-1;\n\t\n\tint x2=1, y=t[order[i].second], z=p[order[i].second];\n\t\n\twhile(x2<x){\n\t  \n\t  for(int j=T-1;j>=0;j--){\n\t    if(dp[i][j]==-1) continue;\n\t    \n\t    if(j+y<=T) dp[i][j+y]=max(dp[i][j+y], dp[i][j]+z);\n\t  }\n\t  \n\t  x2*=2;\n\t  y*=2;\n\t  z*=2;\n\t}\n\t\n      }\n      \n      x/=2;\n    }\n    \n    for(int j=0;j<=T;j++) ans=max(ans,dp[i][j]);\n    \n  }\n  \n  cout<<ans<<endl;\n}\n\nvoid init(){\n  \n  memset(memo,0,sizeof(memo));\n  \n  for(int i=0;i<N;i++){\n    G[i].clear();\n    rG[i].clear();\n  }\n  \n  vs.clear();\n  \n}\n\nint used2[MAX_V];\n\nvoid dfs2(int x, int color){\n  \n  if(used2[x]) return ;\n  used2[x]=1;\n  \n  C[x]=color;\n  \n  for(int i=0;i<G[x].size();i++) dfs2(G[x][i],color);\n  \n}\n\nsigned main(){\n\n  while(1){\n  \n    cin>>N>>M>>T;\n    if(!N&&!M&&!T) break;\n    \n    V=N;\n  \n    init();\n  \n    for(int i=0;i<N;i++)\n      cin>>p[i]>>t[i]>>k[i];\n    \n    memset(used2,0,sizeof(used2));\n    \n    for(int i=0;i<M;i++){\n      int a, b;\n      cin>>a>>b;\n      add_edge(a-1,b-1);\n      if(a==b) memo[a-1]=1;\n    }\n    \n    for(int i=0;i<N;i++)\n      if(!used2[i]) dfs2(i,i);\n    \n    scc();\n    \n    solve();\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 105\n\nstruct Info{\n\tint point,time,limit;\n};\n\nstruct GROUP{\n\tvector<int> nodes;\n};\n\nint N,M,T;\n\nGROUP group[NUM];\nvector<int> G[NUM],GROUP_G[NUM];\nvector<int> reverse_G[NUM];\nstack<int> S;\n\nbool check[NUM],have_self_link[NUM],G_check[NUM][NUM];\nint table[NUM];\ndouble sleep[NUM];\nInfo info[NUM];\nint ans;\n\nint group_index;\n\nvoid dfs(int node_id){\n\tcheck[node_id] = true;\n\n\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\tif(!check[G[node_id][i]])dfs(G[node_id][i]);\n\t}\n\tS.push(node_id);\n}\n\nvoid reverse_dfs(int node_id){\n\tcheck[node_id] = true;\n\n\tgroup[group_index].nodes.push_back(node_id);\n\ttable[node_id] = group_index;\n\n\tfor(int i = 0; i < reverse_G[node_id].size(); i++){\n\t\tif(!check[reverse_G[node_id][i]])reverse_dfs(reverse_G[node_id][i]);\n\t}\n}\n\nvoid recursive(int group_id,int tmp_dp[10001]){\n\n\tint dp[10001],next_dp[10001];\n\tfor(int i = 0; i <= T; i++){\n\t\tdp[i] = tmp_dp[i];\n\t\tnext_dp[i] = dp[i];\n\t}\n\n\tint node_id;\n\tfor(int i = 0; i < group[group_id].nodes.size(); i++){\n\t\tnode_id = group[group_id].nodes[i];\n\n\t\tfor(int k = 1; k <= info[node_id].limit; k++){\n\t\t\tfor(int t = T; t-info[node_id].time*k >= 0; t--){\n\t\t\t\tif(dp[t-info[node_id].time*k] == -1)continue;\n\t\t\t\tnext_dp[t] = max(next_dp[t],dp[t-info[node_id].time*k]+info[node_id].point*k);\n\t\t\t}\n\t\t}\n\t\tfor(int k = 0; k <= T; k++)dp[k] = next_dp[k];\n\t}\n\n\tif(GROUP_G[group_id].size() == 0){\n\n\t\tfor(int i = 0; i <= T; i++)ans = max(ans,next_dp[i]);\n\n\t}else{\n\n\t\tfor(int i = 0; i < GROUP_G[group_id].size(); i++){\n\t\t\trecursive(GROUP_G[group_id][i],next_dp);\n\t\t}\n\t}\n}\n\nvoid func(){\n\n\tfor(int i = 0; i < N; i++){\n\t\tG[i].clear();\n\t\treverse_G[i].clear();\n\t\thave_self_link[i] = false;\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d %d %d\",&info[i].point,&info[i].time,&info[i].limit);\n\t}\n\n\tint from,to;\n\n\tfor(int loop = 0; loop < M; loop++){\n\t\tscanf(\"%d %d\",&from,&to);\n\t\tfrom--;\n\t\tto--;\n\n\t\tif(from == to){\n\t\t\thave_self_link[from] = true;\n\t\t\tcontinue;\n\t\t}\n\t\tG[from].push_back(to);\n\t\treverse_G[to].push_back(from);\n\t}\n\n\tfor(int i = 0; i < N; i++)check[i] = false;\n\n\tfor(int i = 0; i < N;i++){\n\t\tif(!check[i])dfs(i);\n\t}\n\n\tfor(int i = 0; i < N;i++)check[i] = false;\n\tfor(int i = 0; i < NUM; i++){\n\t\tgroup[i].nodes.clear();\n\t\tGROUP_G[i].clear();\n\t\tfor(int k = 0; k < NUM; k++){\n\t\t\tG_check[i][k] = false;\n\t\t}\n\t}\n\n\n\tgroup_index = -1;\n\n\twhile(!S.empty()){\n\t\tif(!check[S.top()]){\n\t\t\tgroup_index++;\n\n\t\t\treverse_dfs(S.top());\n\t\t}\n\t\tS.pop();\n\t}\n\n\tint node_id,adj_node,adj_group;\n\n\tfor(int i = 0; i <= group_index; i++){\n\t\tfor(int k = 0; k < group[i].nodes.size(); k++){\n\t\t\tnode_id = group[i].nodes[k];\n\t\t\tfor(int a = 0; a < G[node_id].size(); a++){\n\t\t\t\tadj_node = G[node_id][a];\n\t\t\t\tadj_group = table[adj_node];\n\t\t\t\tif(adj_group == i || G_check[i][adj_group] == true)continue;\n\t\t\t\tG_check[i][adj_group] = true;\n\t\t\t\tGROUP_G[i].push_back(adj_group);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i <= group_index; i++){\n\t\tif(group[i].nodes.size() == 1 && have_self_link[group[i].nodes[0]] == false){\n\t\t\tinfo[group[i].nodes[0]].limit = 1;\n\t\t}\n\t}\n\n\tans = 0;\n\n\tint first_dp[10001];\n\tfirst_dp[0] = 0;\n\tfor(int i = 1; i <= T; i++)first_dp[i] = -1;\n\n\tfor(int start_group = 0; start_group <= group_index; start_group++){\n\t\trecursive(start_group,first_dp);\n\t}\n\n\tprintf(\"%d\\n\",ans);\n}\n\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d %d\",&N,&M,&T);\n\t\tif(N == 0 && M == 0 && T == 0)break;\n\n\t\tfunc();\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAX_V 110\n#define N 110\nusing namespace std;\n\n/* ?????£?????????????§£ O(|V|+|E|) */\nint V; //????????°\nvector<int> G[MAX_V]; //??°???????????£??\\??????????????¨???\nvector<int> rG[MAX_V];//?????????????????????????????°??????\nvector<int> vs;       //??°?????????????????????\nbool used[MAX_V];     //?????§???????????????\nint cmp[MAX_V];       //?±????????????£?????????????????????????????????\n\nvoid add_edge(int from,int to){\n  G[from].push_back(to);\n  rG[to].push_back(from);\n}\n\nvoid dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++)if(!used[G[v][i]])dfs(G[v][i]);\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v]=true;\n  cmp[v]=k;\n  for(int i=0;i<rG[v].size();i++) if(!used[rG[v][i]])rdfs(rG[v][i],k);\n}\n\nint scc(){\n  memset(used,0,sizeof(used));\n  vs.clear();\n  for(int v=0;v<V;v++) if(!used[v]) dfs(v);\n  memset(used,0,sizeof(used));\n  int k=0;\n  for(int i=vs.size()-1;i>=0;i--)if(!used[vs[i]]) rdfs(vs[i],k++);\n  return k;\n}\n\nint n,v[N],w[N],K[N],T;\nint Max(int &a,int b){return a=max(a,b);}\n\nset<int>g[N];\nvector<int> DP[N];\nvoid update(vector<int> I,vector<int> &dp){\n  int col = cmp[I[0]];\n  for(int i:I){ //??????\n    int num = g[cmp[i]].count(cmp[i])? K[i]:1;\n    for(int j=1;num;j=min(num,j*2)){ //???????????°\n      num -= j;\n      for(int k=T;k>=j*w[i];k--)  //?????¨?????????\n        Max(dp[k],dp[k-j*w[i]]+j*v[i]);\n    }\n  }\n  \n\n  for(int nx:g[col])\n    for(int j=0;j<=T;j++) Max(DP[nx][j],dp[j]);\n  \n}\n\nvoid init(){\n  for(int i=0;i<N;i++){\n    cmp[i] = 0;\n    G[i].clear();\n    rG[i].clear();\n    g[i].clear();\n    DP[i].clear();\n    DP[i].resize(T+1,0);\n  }\n}\n\nint main(){\n  while(1){\n    int m;\n    cin>>n>>m>>T;\n    if(!n&&!m&&!T)break;\n    init();\n  \n    for(int i=0;i<n;i++)cin>>v[i]>>w[i]>>K[i];\n    for(int i=0,a,b;i<m;i++)cin>>a>>b,add_edge(a-1,b-1);\n    V = n;\n    V=scc();\n    \n    for(int i=0;i<n;i++)\n      for(int j:G[i])g[cmp[i]].insert(cmp[j]);\n  \n    int ans = 0;\n    for(int i=0;i<V;i++){\n      vector<int> I;\n      for(int j=0;j<n;j++)if(cmp[j]==i) I.push_back(j);\n      update(I,DP[i]);\n    }\n    for(int i=0;i<V;i++)\n      for(int j=0;j<=T;j++) Max(ans,DP[i][j]);\n  \n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntypedef vector<int> vi;\ntypedef pair<int,int> P;\nvi G[100];\nint ord[100],low[100],sid[100];\nbool inS[100];\nstack<int> S;\nint cnt;\nvector<vi> scc;\nint N,M,T;\nvoid vis(int v){\n\tord[v]=low[v]=++cnt;\n\tS.push(v);\n\tinS[v]=1;\n\tfor(int u:G[v]){\n\t\tif(ord[u]==0){\n\t\t\tvis(u);\n\t\t\tchmin(low[v],low[u]);\n\t\t}else if(inS[u]){\n\t\t\tchmin(low[v],ord[u]);\n\t\t}\n\t}\n\tif(low[v]==ord[v]){\n\t\tvi vc;\n\t\twhile(true){\n\t\t\tint w=S.top();S.pop();\n\t\t\tinS[w]=0;\n\t\t\tvc.pb(w);\n\t\t\tsid[w]=scc.size();\n\t\t\tif(v==w) break;\n\t\t}\n\t\tscc.pb(vc);\n\t}\n}\nvoid makescc(){\n\trep(i,N) if(ord[i]==0) vis(i);\n}\nint p[100],t[100],k[100];\nint deq[10001],deqv[10001];\nP es[1000];\nvector<int> nG[100];\t\t//y in nG[x] : x<-y\nint dp[100][10001];\nvoid init(){\n\trep(i,100) G[i].clear(),nG[i].clear(),ord[i]=0,low[i]=0,inS[i]=0;\n\trep(i,100) rep(j,10001) dp[i][j]=0;\n\tcnt=0;\n\tscc.clear();\n}\nint main(){\n\twhile(true){\n\t\tcin>>N>>M>>T;\n\t\tif(N==0) break;\n\t\tinit();\n\t\trep(i,N) cin>>p[i]>>t[i]>>k[i];\n\t\trep(i,M){\n\t\t\tint a,b;\n\t\t\tcin>>a>>b;\n\t\t\ta--,b--;\n\t\t\tG[a].pb(b);\n\t\t\tes[i]=P(a,b);\n\t\t}\n\t\tmakescc();\n\t\tint K=scc.size();\n\t\t{\n\t\t\tbool ise[100][100]={};\n\t\t\trep(i,M) ise[ sid[es[i].fs] ][ sid[es[i].sc] ]=1;\n\t\t\trep(i,K) rep(j,K) if(ise[i][j]) nG[j].pb(i);\n\t\t}\n\t\tfor(int i=K-1;i>=0;i--){\n\t\t\tbool isol=1;\n\t\t\tfor(int j:nG[i]){\n\t\t\t\tif(j==i){\n\t\t\t\t\tisol=0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\trep(t,T+1) chmax(dp[i][t],dp[j][t]);\n\t\t\t}\n\t\t\tif(isol){\n\t\t\t\tk[scc[i][0]]=1;\n\t\t\t}\n\t\t\tfor(int v:scc[i]){\n\t\t\t\trep(a,t[v]){\n\t\t\t\t\tint be=0,en=0;\n\t\t\t\t\tfor(int j=0;j*t[v]+a<=T;j++){\n\t\t\t\t\t\tint val=dp[i][j*t[v]+a]-j*p[v];\n\t\t\t\t\t\twhile(be<en&&deqv[en-1]<=val) en--;\n\t\t\t\t\t\tdeq[en]=j,deqv[en]=val;\n\t\t\t\t\t\ten++;\n\t\t\t\t\t\tdp[i][j*t[v]+a]=deqv[be]+j*p[v];\n\t\t\t\t\t\tif(deq[be]==j-k[v]) be++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=0;\n\t\trep(i,K) rep(t,T+1) chmax(ans,dp[i][t]);\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 105\n\nstruct Info{\n    int point,time,limit;\n};\n\nstruct GROUP{\n    vector<int> nodes;\n};\n\nint N,M,T;\n\nGROUP group[NUM]; //強連結成分のグループ\nvector<int> G[NUM],GROUP_G[NUM];\nvector<int> reverse_G[NUM];\nstack<int> S;\n\nbool check[NUM],have_self_link[NUM],G_check[NUM][NUM];\nint table[NUM],in_num[NUM];\nint dp[NUM][10001],next_dp[10001];\ndouble sleep[NUM];\nInfo info[NUM];\nint ans;\n\nint group_index;\n\nvoid dfs(int node_id){\n    check[node_id] = true;\n\n    for(int i = 0; i < G[node_id].size(); i++){\n        if(!check[G[node_id][i]])dfs(G[node_id][i]);\n    }\n    S.push(node_id);\n}\n\nvoid reverse_dfs(int node_id){\n    check[node_id] = true;\n\n    group[group_index].nodes.push_back(node_id); //group[group_index]にノードを突っ込む\n    table[node_id] = group_index;\n\n    for(int i = 0; i < reverse_G[node_id].size(); i++){\n        if(!check[reverse_G[node_id][i]])reverse_dfs(reverse_G[node_id][i]);\n    }\n}\n\n\nvoid func(){\n\n    for(int i = 0; i < N; i++){\n        G[i].clear();\n        reverse_G[i].clear();\n        have_self_link[i] = false;\n    }\n\n    for(int i = 0; i < N; i++){\n        scanf(\"%d %d %d\",&info[i].point,&info[i].time,&info[i].limit);\n    }\n\n    int from,to;\n\n    for(int loop = 0; loop < M; loop++){\n        scanf(\"%d %d\",&from,&to);\n        from--;\n        to--;\n\n        if(from == to){\n            have_self_link[from] = true; //★強連結成分扱いとする(自分に戻れる)★\n            continue;\n        }\n        G[from].push_back(to);\n        reverse_G[to].push_back(from);\n    }\n\n    for(int i = 0; i < N; i++)check[i] = false;\n\n    //まずは帰りがけ順を計算\n    for(int i = 0; i < N;i++){\n        if(!check[i])dfs(i);\n    }\n\n    for(int i = 0; i < N;i++)check[i] = false;\n    for(int i = 0; i < NUM; i++){\n        group[i].nodes.clear();\n        GROUP_G[i].clear();\n        in_num[i] = 0;\n        for(int k = 0; k < NUM; k++){\n            G_check[i][k] = false;\n        }\n    }\n\n\n    group_index = -1;\n    //ノードを、帰りがけ順の逆順に、各強連結成分(グループ)に分解\n    while(!S.empty()){\n        if(!check[S.top()]){\n            group_index++;\n\n            reverse_dfs(S.top());\n        }\n        S.pop();\n    }\n\n    int node_id,adj_node,adj_group;\n    //グループ間の有向エッジを探す\n    for(int i = 0; i <= group_index; i++){\n        for(int k = 0; k < group[i].nodes.size(); k++){\n            node_id = group[i].nodes[k];\n            for(int a = 0; a < G[node_id].size(); a++){\n                adj_node = G[node_id][a];\n                adj_group = table[adj_node];\n                if(adj_group == i || G_check[i][adj_group] == true)continue;\n                G_check[i][adj_group] = true;\n                GROUP_G[i].push_back(adj_group);\n                in_num[adj_group]++;\n            }\n        }\n    }\n\n    //あらかじめ、強連結成分でなく、かつ自己ループを持たないサイトは、制限個数を1にしておく\n    for(int i = 0; i <= group_index; i++){\n        if(group[i].nodes.size() == 1 && have_self_link[group[i].nodes[0]] == false){\n            info[group[i].nodes[0]].limit = 1;\n            //printf(\"%dは1回\\n\",group[i].nodes[0]);\n        }\n    }\n\n    for(int i = 0; i <= group_index; i++){\n        dp[i][0] = 0;\n        for(int k = 1; k <= T; k++)dp[i][k] = -1;\n    }\n\n    ans = 0;\n\n    //トポロジカル順にやる\n    queue<int> Q;\n    for(int i = 0; i <= group_index; i++){\n        if(in_num[i] == 0){\n            Q.push(i);\n        }\n    }\n\n    int group_id;\n\n    while(!Q.empty()){\n        group_id = Q.front();\n        Q.pop();\n\n        for(int i = 0; i <= T; i++){\n            next_dp[i] = dp[group_id][i];\n        }\n\n        for(int i = 0; i < group[group_id].nodes.size(); i++){\n            node_id = group[group_id].nodes[i];\n            //printf(\"node_id:%d\\n\",node_id);\n            for(int k = 1; k <= info[node_id].limit; k++){\n                if(info[node_id].time*k > T)break;\n                for(int t = T; t-info[node_id].time*k >= 0; t--){\n                    if(dp[group_id][t-info[node_id].time*k] == -1)continue;\n                    next_dp[t] = max(next_dp[t],dp[group_id][t-info[node_id].time*k]+info[node_id].point*k);\n                }\n            }\n            for(int k = 0; k <= T; k++)dp[group_id][k] = next_dp[k];\n        }\n\n        if(GROUP_G[group_id].size() == 0){ //DAGの終点\n\n            for(int i = 0; i <= T; i++)ans = max(ans,next_dp[i]);\n\n        }else{\n\n            for(int i = 0; i < GROUP_G[group_id].size(); i++){\n                adj_group = GROUP_G[group_id][i];\n                for(int k = 0; k <= T; k++)dp[adj_group][k] = max(dp[adj_group][k],next_dp[k]); //dpの情報を引き継ぐ\n                in_num[adj_group]--;\n                if(in_num[adj_group] == 0){\n                    Q.push(adj_group);\n                }\n            }\n        }\n    }\n\n    printf(\"%d\\n\",ans);\n}\n\n\nint main(){\n\n    while(true){\n        scanf(\"%d %d %d\",&N,&M,&T);\n        if(N == 0 && M == 0 && T == 0)break;\n\n        func();\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 105\n\nstruct Info{\n    int point,time,limit;\n};\n\nstruct GROUP{\n    vector<int> nodes;\n};\n\nint N,M,T;\n\nGROUP group[NUM]; //強連結成分のグループ\nvector<int> G[NUM],GROUP_G[NUM];\nvector<int> reverse_G[NUM];\nstack<int> S;\n\nbool check[NUM],have_self_link[NUM],G_check[NUM][NUM];\nint table[NUM],in_num[NUM];\nint dp[NUM][10001];\ndouble sleep[NUM];\nInfo info[NUM];\nint ans;\n\nint group_index;\n\nvoid dfs(int node_id){\n    check[node_id] = true;\n\n    for(int i = 0; i < G[node_id].size(); i++){\n        if(!check[G[node_id][i]])dfs(G[node_id][i]);\n    }\n    S.push(node_id);\n}\n\nvoid reverse_dfs(int node_id){\n    check[node_id] = true;\n\n    group[group_index].nodes.push_back(node_id); //group[group_index]にノードを突っ込む\n    table[node_id] = group_index;\n\n    for(int i = 0; i < reverse_G[node_id].size(); i++){\n        if(!check[reverse_G[node_id][i]])reverse_dfs(reverse_G[node_id][i]);\n    }\n}\n\n\nvoid func(){\n\n    for(int i = 0; i < N; i++){\n        G[i].clear();\n        reverse_G[i].clear();\n        have_self_link[i] = false;\n    }\n\n    for(int i = 0; i < N; i++){\n        scanf(\"%d %d %d\",&info[i].point,&info[i].time,&info[i].limit);\n    }\n\n    int from,to;\n\n    for(int loop = 0; loop < M; loop++){\n        scanf(\"%d %d\",&from,&to);\n        from--;\n        to--;\n\n        if(from == to){\n            have_self_link[from] = true; //★強連結成分扱いとする(自分に戻れる)★\n            continue;\n        }\n        G[from].push_back(to);\n        reverse_G[to].push_back(from);\n    }\n\n    for(int i = 0; i < N; i++)check[i] = false;\n\n    //まずは帰りがけ順を計算\n    for(int i = 0; i < N;i++){\n        if(!check[i])dfs(i);\n    }\n\n    for(int i = 0; i < N;i++)check[i] = false;\n    for(int i = 0; i < NUM; i++){\n        group[i].nodes.clear();\n        GROUP_G[i].clear();\n        in_num[i] = 0;\n        for(int k = 0; k < NUM; k++){\n            G_check[i][k] = false;\n        }\n    }\n\n\n    group_index = -1;\n    //ノードを、帰りがけ順の逆順に、各強連結成分(グループ)に分解\n    while(!S.empty()){\n        if(!check[S.top()]){\n            group_index++;\n\n            reverse_dfs(S.top());\n        }\n        S.pop();\n    }\n\n    int node_id,adj_node,adj_group;\n    //グループ間の有向エッジを探す\n    for(int i = 0; i <= group_index; i++){\n        for(int k = 0; k < group[i].nodes.size(); k++){\n            node_id = group[i].nodes[k];\n            for(int a = 0; a < G[node_id].size(); a++){\n                adj_node = G[node_id][a];\n                adj_group = table[adj_node];\n                if(adj_group == i || G_check[i][adj_group] == true)continue;\n                G_check[i][adj_group] = true;\n                GROUP_G[i].push_back(adj_group);\n                in_num[adj_group]++;\n            }\n        }\n    }\n\n    //あらかじめ、強連結成分でなく、かつ自己ループを持たないサイトは、制限個数を1にしておく\n    for(int i = 0; i <= group_index; i++){\n        if(group[i].nodes.size() == 1 && have_self_link[group[i].nodes[0]] == false){\n            info[group[i].nodes[0]].limit = 1;\n            //printf(\"%dは1回\\n\",group[i].nodes[0]);\n        }\n    }\n\n    for(int i = 0; i <= group_index; i++){\n        dp[i][0] = 0;\n        for(int k = 1; k <= T; k++)dp[i][k] = -1;\n    }\n\n    ans = 0;\n\n    //トポロジカル順にやる\n    queue<int> Q;\n    for(int i = 0; i <= group_index; i++){\n        if(in_num[i] == 0){\n            Q.push(i);\n        }\n    }\n\n    int group_id,count,mult;\n\n    while(!Q.empty()){\n        group_id = Q.front();\n        Q.pop();\n\n       for(int i = 0; i < group[group_id].nodes.size(); i++){\n            node_id = group[group_id].nodes[i];\n\n            count = info[node_id].limit;\n            for (int k = 1; count > 0; k *= 2) { //★★ダブリングナップザック★★\n\t\t\t\t\tmult = min(k,count);\n\t\t\t\t\tif(info[node_id].time*mult > T)break;\n\t\t\t\t\tfor (int t = T; t-info[node_id].time*mult >= 0; t--){\n\t\t\t\t\t\tif(dp[group_id][t-info[node_id].time*mult] == -1)continue;\n\t\t\t\t\t\tdp[group_id][t] = max(dp[group_id][t],dp[group_id][t-info[node_id].time*mult]+info[node_id].point*mult);\n\t\t\t\t\t}\n\t\t\t\t\tcount -= mult;\n\t\t\t}\n        }\n\n        if(GROUP_G[group_id].size() == 0){ //DAGの終点\n\n            for(int i = 0; i <= T; i++)ans = max(ans,dp[group_id][i]);\n\n        }else{\n\n            for(int i = 0; i < GROUP_G[group_id].size(); i++){\n                adj_group = GROUP_G[group_id][i];\n                for(int k = 0; k <= T; k++)dp[adj_group][k] = max(dp[adj_group][k],dp[group_id][k]); //dpの情報を引き継ぐ\n                in_num[adj_group]--;\n                if(in_num[adj_group] == 0){\n                    Q.push(adj_group);\n                }\n            }\n        }\n    }\n\n    printf(\"%d\\n\",ans);\n}\n\n\nint main(){\n\n    while(true){\n        scanf(\"%d %d %d\",&N,&M,&T);\n        if(N == 0 && M == 0 && T == 0)break;\n\n        func();\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 105\n\nstruct Info{\n\tint point,time,limit;\n};\n\nstruct GROUP{\n\tvector<int> nodes;\n};\n\nint N,M,T;\n\nGROUP group[NUM]; //強連結成分のグループ\nvector<int> G[NUM],GROUP_G[NUM];\nvector<int> reverse_G[NUM];\nstack<int> S;\n\nbool check[NUM],have_self_link[NUM],G_check[NUM][NUM];\nint table[NUM],in_num[NUM];\nint dp[NUM][10001],next_dp[10001];\ndouble sleep[NUM];\nInfo info[NUM];\nint ans;\n\nint group_index;\n\nvoid dfs(int node_id){\n\tcheck[node_id] = true;\n\n\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\tif(!check[G[node_id][i]])dfs(G[node_id][i]);\n\t}\n\tS.push(node_id);\n}\n\nvoid reverse_dfs(int node_id){\n\tcheck[node_id] = true;\n\n\tgroup[group_index].nodes.push_back(node_id); //group[group_index]にノードを突っ込む\n\ttable[node_id] = group_index;\n\n\tfor(int i = 0; i < reverse_G[node_id].size(); i++){\n\t\tif(!check[reverse_G[node_id][i]])reverse_dfs(reverse_G[node_id][i]);\n\t}\n}\n\n\nvoid func(){\n\n\tfor(int i = 0; i < N; i++){\n\t\tG[i].clear();\n\t\treverse_G[i].clear();\n\t\thave_self_link[i] = false;\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d %d %d\",&info[i].point,&info[i].time,&info[i].limit);\n\t}\n\n\tint from,to;\n\n\tfor(int loop = 0; loop < M; loop++){\n\t\tscanf(\"%d %d\",&from,&to);\n\t\tfrom--;\n\t\tto--;\n\n\t\tif(from == to){\n\t\t\thave_self_link[from] = true; //★強連結成分扱いとする(自分に戻れる)★\n\t\t\tcontinue;\n\t\t}\n\t\tG[from].push_back(to);\n\t\treverse_G[to].push_back(from);\n\t}\n\n\tfor(int i = 0; i < N; i++)check[i] = false;\n\n\t//まずは帰りがけ順を計算\n\tfor(int i = 0; i < N;i++){\n\t\tif(!check[i])dfs(i);\n\t}\n\n\tfor(int i = 0; i < N;i++)check[i] = false;\n\tfor(int i = 0; i < NUM; i++){\n\t\tgroup[i].nodes.clear();\n\t\tGROUP_G[i].clear();\n\t\tin_num[i] = 0;\n\t\tfor(int k = 0; k < NUM; k++){\n\t\t\tG_check[i][k] = false;\n\t\t}\n\t}\n\n\n\tgroup_index = -1;\n\t//ノードを、帰りがけ順の逆順に、各強連結成分(グループ)に分解\n\twhile(!S.empty()){\n\t\tif(!check[S.top()]){\n\t\t\tgroup_index++;\n\n\t\t\treverse_dfs(S.top());\n\t\t}\n\t\tS.pop();\n\t}\n\n\tint node_id,adj_node,adj_group;\n\t//グループ間の有向エッジを探す\n\tfor(int i = 0; i <= group_index; i++){\n\t\tfor(int k = 0; k < group[i].nodes.size(); k++){\n\t\t\tnode_id = group[i].nodes[k];\n\t\t\tfor(int a = 0; a < G[node_id].size(); a++){\n\t\t\t\tadj_node = G[node_id][a];\n\t\t\t\tadj_group = table[adj_node];\n\t\t\t\tif(adj_group == i || G_check[i][adj_group] == true)continue;\n\t\t\t\tG_check[i][adj_group] = true;\n\t\t\t\tGROUP_G[i].push_back(adj_group);\n\t\t\t\tin_num[adj_group]++;\n\t\t\t}\n\t\t}\n\t}\n\n\t//あらかじめ、強連結成分でなく、かつ自己ループを持たないサイトは、制限個数を1にしておく\n\tfor(int i = 0; i <= group_index; i++){\n\t\tif(group[i].nodes.size() == 1 && have_self_link[group[i].nodes[0]] == false){\n\t\t\tinfo[group[i].nodes[0]].limit = 1;\n\t\t\t//printf(\"%dは1回\\n\",group[i].nodes[0]);\n\t\t}\n\t}\n\n\tfor(int i = 0; i <= group_index; i++){\n\t\tdp[i][0] = 0;\n\t\tfor(int k = 1; k <= T; k++)dp[i][k] = -1;\n\t}\n\n\tans = 0;\n\n\t//トポロジカル順にやる\n\tqueue<int> Q;\n\tfor(int i = 0; i <= group_index; i++){\n\t\tif(in_num[i] == 0){\n\t\t\tQ.push(i);\n\t\t}\n\t}\n\n\tint group_id;\n\n\twhile(!Q.empty()){\n\t\tgroup_id = Q.front();\n\t\tQ.pop();\n\n\t\tfor(int i = 0; i <= T; i++){\n\t\t\tnext_dp[i] = dp[group_id][i];\n\t\t}\n\n\t\tfor(int i = 0; i < group[group_id].nodes.size(); i++){\n\t\t\tnode_id = group[group_id].nodes[i];\n\t\t\t//printf(\"node_id:%d\\n\",node_id);\n\t\t\tfor(int k = 1; k <= info[node_id].limit; k++){\n\t\t\t\tif(info[node_id].time*k > T)break;\n\t\t\t\tfor(int t = T; t-info[node_id].time*k >= 0; t--){\n\t\t\t\t\tif(dp[group_id][t-info[node_id].time*k] == -1)continue;\n\t\t\t\t\tnext_dp[t] = max(next_dp[t],dp[group_id][t-info[node_id].time*k]+info[node_id].point*k);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int k = 0; k <= T; k++)dp[group_id][k] = next_dp[k]; //★サイト毎にdpの更新が必要★\n\t\t}\n\n\t\tif(GROUP_G[group_id].size() == 0){ //DAGの終点\n\n\t\t\tfor(int i = 0; i <= T; i++)ans = max(ans,next_dp[i]);\n\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < GROUP_G[group_id].size(); i++){\n\t\t\t\tadj_group = GROUP_G[group_id][i];\n\t\t\t\tfor(int k = 0; k <= T; k++)dp[adj_group][k] = max(dp[adj_group][k],next_dp[k]); //dpの情報を引き継ぐ\n\t\t\t\tin_num[adj_group]--;\n\t\t\t\tif(in_num[adj_group] == 0){\n\t\t\t\t\tQ.push(adj_group);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",ans);\n}\n\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d %d\",&N,&M,&T);\n\t\tif(N == 0 && M == 0 && T == 0)break;\n\n\t\tfunc();\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//Name: Website Tour\n//Level: 4\n//Category: グラフ,Graph,動的計画法,DP,強連結成分分解,個数制限付きナップサック問題\n//Note:\n\n/**\n * 以下のどちらかの条件を満たすとき、ある頂点の広告は好きなだけ見ることができる。\n * ・自己ループをもつ\n * ・この頂点を含む強連結成分内に他の頂点が存在する\n * したがって、強連結成分分解したグラフを1ノードずつたどりながら、個数制限付きナップサック問題を解いていけばよい。\n * 個数制限付きナップサック問題は、荷物の重さを2冪で分解することにより、O(N log W)で計算できる。\n *\n * オーダーは O(NT log T)。\n */\n\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <unordered_set>\n\nusing namespace std;\n\nstruct Node {\n    int p, t, k;\n};\n\nvoid dfs1(int pos, const vector<vector<int>> &g, vector<bool> &visited, vector<int> &buf) {\n    if(visited[pos]) return;\n    visited[pos] = true;\n    for(int to : g[pos]) dfs1(to, g, visited, buf);\n    buf.push_back(pos);\n}\n\nvoid dfs2(int pos, const vector<vector<int>> &g, int label, vector<int> &buf) {\n    if(buf[pos] != -1) return;\n    buf[pos] = label;\n    for(int to : g[pos]) dfs2(to, g, label, buf);\n}\n\nvector<int> scc(const vector<vector<int>> &g) {\n    const int N = g.size();\n    vector<vector<int>> rev(N);\n    for(int i = 0; i < N; ++i) {\n        for(int to : g[i]) {\n            rev[to].push_back(i);\n        }\n    }\n    vector<bool> visited(N, false);\n    vector<int> ord;\n    for(int i = 0; i < N; ++i) {\n        dfs1(i, g, visited, ord);\n    }\n    reverse(begin(ord), end(ord));\n    vector<int> label(N, -1);\n    int l = 0;\n    for(int i = 0; i < N; ++i) {\n        if(label[i] == -1) dfs2(i, rev, l++, label);\n    }\n    return label;\n}\n\nbool solve() {\n    int N, M, T;\n    if(!(cin >> N >> M >> T)) return false;\n    if(!N && !M && !T) return false;\n\n    vector<Node> nodes(N);\n    for(int i = 0; i < N; ++i) {\n        cin >> nodes[i].p >> nodes[i].t >> nodes[i].k;\n    }\n    vector<vector<int>> g(N);\n    vector<bool> self_looped(N, false);\n    for(int i = 0; i < M; ++i) {\n        int a, b;\n        cin >> a >> b;\n        --a; --b;\n        g[a].push_back(b);\n        if(a == b) self_looped[a] = true;\n    }\n\n    vector<int> label = scc(g);\n    const int L = *max_element(begin(label), end(label)) + 1;\n    vector<vector<int>> nodes_of(L);\n    for(int i = 0; i < N; ++i) {\n        nodes_of[label[i]].push_back(i);\n    }\n\n    vector<vector<long long>> dp(L, vector<long long>(T+1, 0));\n    vector<unordered_set<int>> prev_of(L);\n    long long ans = 0;\n    for(int cur = 0; cur < L; ++cur) {\n        for(int t = 0; t <= T; ++t) {\n            for(int prev : prev_of[cur]) {\n                dp[cur][t] = max(dp[cur][t], dp[prev][t]);\n            }\n        }\n\n        if(nodes_of[cur].size() >= 2 || self_looped[nodes_of[cur][0]]) {\n            // Can take any numbers of advertisement\n            for(int n : nodes_of[cur]) {\n                int rem = nodes[n].k;\n                for(int ord = 1; rem > 0; ord *= 2) {\n                    const int k = min(ord, rem);\n                    rem -= ord;\n                    for(int t = T; t >= 0; --t) {\n                        if(t-k*nodes[n].t >= 0) dp[cur][t] = max(dp[cur][t], dp[cur][t-k*nodes[n].t] + k * nodes[n].p);\n                    }\n                }\n            }\n        } else {\n            // Can take only one advertisement\n            for(int t = T; t >= 0; --t) {\n                for(int n : nodes_of[cur]) {\n                    if(t-nodes[n].t >= 0) dp[cur][t] = max(dp[cur][t], dp[cur][t-nodes[n].t] + nodes[n].p);\n                }\n            }\n        }\n        for(int n : nodes_of[cur]) {\n            for(int to : g[n]) {\n                prev_of[label[to]].insert(cur);\n            }\n        }\n        ans = max(ans, *max_element(begin(dp[cur]), end(dp[cur]))); \n    }\n    cout << ans << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define MAX_T 10005\n#define MAX_V 105\nusing namespace std;\n\ntypedef pair<int,int> P;\n\n/* ?????£?????????????§£ O(|V|+|E|) */\nint V; //????????°\nvector<int> G[MAX_V]; //??°???????????£??\\??????????????¨???\nvector<int> rG[MAX_V];//?????????????????????????????°??????\nvector<int> vs;       //??°?????????????????????\nbool used[MAX_V];     //?????§???????????????\nint cmp[MAX_V];       //?±????????????£?????????????????????????????????\n\nvoid add_edge(int from,int to){\n  G[from].push_back(to);\n  rG[to].push_back(from);\n}\n\nvoid dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++)if(!used[G[v][i]])dfs(G[v][i]);\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v]=true;\n  cmp[v]=k;\n  for(int i=0;i<rG[v].size();i++) if(!used[rG[v][i]])rdfs(rG[v][i],k);\n}\n\nint scc(){\n  memset(used,0,sizeof(used));\n  vs.clear();\n  for(int v=0;v<V;v++) if(!used[v]) dfs(v);\n  \n  memset(used,0,sizeof(used));\n  int k=0;\n  for(int i=vs.size()-1;i>=0;i--)if(!used[vs[i]]) rdfs(vs[i],k++);\n  return k;\n}\n\nint N, M, T, K, p[MAX_V], t[MAX_V], k[MAX_V], memo[MAX_V];\nint dp[MAX_V][MAX_T];\n\nvector<int> G2[MAX_V];\nvector<int> nodelist[MAX_V];\n\nvoid solve(){\n    \n  memset(dp,-1,sizeof(dp));\n\n  for(int i=0;i<K;i++) dp[i][0]=0;\n  \n  for(int i=0;i<N;i++)\n    nodelist[cmp[i]].push_back(i);\n  \n  int ans=0;\n  \n  for(int i=0;i<K;i++){\n    \n    for(int j=0;j<nodelist[i].size();j++){\n      \n      int node=nodelist[i][j];\n      \n      int maxk=k[node];\n      \n      if(!memo[node]&&nodelist[i].size()==1) maxk=1;\n      \n      int x=1;\n    \n      while(maxk){\n      \n\tif(maxk<x) x=maxk;\n\n\tint y=t[node]*x, z=p[node]*x;\n\t\n\tfor(int l=T;l>=0;l--){\n\t  \n\t  if(dp[i][l]==-1) continue;\n\t  \n\t  if(l+y<=T) dp[i][l+y]=max(dp[i][l+y], dp[i][l]+z);\n\t}\n      \n\tmaxk-=x;\n      \n\tx*=2;\n      }\n\n      for(int l=0;l<=T;l++) ans=max(ans,dp[i][l]);\n      \n    }\n    \n    for(int j=0;j<G2[i].size();j++)\n      for(int l=0;l<=T;l++) dp[G2[i][j]][l]=max(dp[G2[i][j]][l],dp[i][l]);\n    \n  }\n  \n  cout<<ans<<endl;\n}\n\nvoid init(){\n  \n  memset(memo,0,sizeof(memo));\n  \n  for(int i=0;i<N;i++){\n    G[i].clear();\n    rG[i].clear();\n    G2[i].clear();\n    nodelist[i].clear();\n  }\n  \n  vs.clear();\n  \n}\n\nsigned main(){\n\n  while(1){\n    \n    cin>>N>>M>>T;\n    if(!N&&!M&&!T) break;\n    \n    V=N;\n    \n    init();\n    \n    for(int i=0;i<N;i++)\n      cin>>p[i]>>t[i]>>k[i];\n    \n    for(int i=0;i<M;i++){\n      int a, b;\n      cin>>a>>b;\n      add_edge(a-1,b-1);\n    }\n    \n    K=scc();\n    \n    set<P> S;\n    \n    for(int i=0;i<N;i++)\n      for(int j=0;j<G[i].size();j++)\n\t\n\tif(!S.count(P(cmp[i],cmp[G[i][j]]))){\n\t  \n\t  if(cmp[i]==cmp[G[i][j]]){\n\t    memo[cmp[i]]=1;\n\t    continue;\n\t  }\n\t  \n\t  S.insert(P(cmp[i],cmp[G[i][j]]));\n\t  G2[cmp[i]].push_back(cmp[G[i][j]]);\n\t}\n    \n    solve();\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define MAX_T 10005\n#define MAX_V 105\nusing namespace std;\n\ntypedef pair<int,int> P;\n\n/* ?????£?????????????§£ O(|V|+|E|) */\nint V; //????????°\nvector<int> G[MAX_V]; //??°???????????£??\\??????????????¨???\nvector<int> rG[MAX_V];//?????????????????????????????°??????\nvector<int> vs;       //??°?????????????????????\nbool used[MAX_V];     //?????§???????????????\nint cmp[MAX_V];       //?±????????????£?????????????????????????????????\n\nvoid add_edge(int from,int to){\n  G[from].push_back(to);\n  rG[to].push_back(from);\n}\n\nvoid dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++)if(!used[G[v][i]])dfs(G[v][i]);\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v]=true;\n  cmp[v]=k;\n  for(int i=0;i<rG[v].size();i++) if(!used[rG[v][i]])rdfs(rG[v][i],k);\n}\n\nint scc(){\n  memset(used,0,sizeof(used));\n  vs.clear();\n  for(int v=0;v<V;v++) if(!used[v]) dfs(v);\n  \n  memset(used,0,sizeof(used));\n  int k=0;\n  for(int i=vs.size()-1;i>=0;i--)if(!used[vs[i]]) rdfs(vs[i],k++);\n  return k;\n}\n\nint N, M, T, p[MAX_V], t[MAX_V], k[MAX_V], memo[MAX_V];\nint dp[MAX_V][MAX_T], C[MAX_V];\n\nvoid solve(){\n  \n  vector<P> order;\n  map<int,int> cnt;\n  \n  for(int i=0;i<N;i++){\n    order.push_back(P(cmp[i],i));\n    cnt[cmp[i]]++;\n  }\n  \n  sort(order.begin(),order.end());\n  \n  memset(dp,-1,sizeof(dp));\n  \n  vector<int> AA;\n  \n  for(int i=0;i<N-1;i++)\n    AA.push_back(C[order[i].second]);\n\n  AA.push_back((1e9));\n  set<int> AAA;\n  for(int i=0;i<AA.size()-1;i++)\n    if(AA[i]!=AA[i+1]){\n      assert(AAA.count(AA[i])==0);\n      AAA.insert(AA[i]);\n    }\n  \n  int ans=0;\n  \n  for(int i=0;i<N;i++){\n    \n    if(!i||(i&&C[order[i].second]!=C[order[i-1].second])) dp[i][0]=0;\n    else{\n      for(int j=0;j<=T;j++) dp[i][j]=dp[i-1][j];\n    }\n    \n    int maxk=k[order[i].second];\n    \n    if(!memo[cmp[order[i].second]]&&cnt[cmp[order[i].second]]==1) maxk=1;\n    \n    int x=1;\n    while(x<=maxk) x*=2;\n    \n    while(maxk){\n      \n      while(x-1<=maxk){\n\t\n\tmaxk-=x-1;\n\t\n\tint x2=1, y=t[order[i].second], z=p[order[i].second];\n\t\n\twhile(x2<x){\n\t  \n\t  for(int j=T;j>=0;j--){\n\t    if(dp[i][j]==-1) continue;\n\t    \n\t    if(j+y<=T) dp[i][j+y]=max(dp[i][j+y], dp[i][j]+z);\n\t  }\n\t  \n\t  x2*=2;\n\t  y*=2;\n\t  z*=2;\n\t}\n\t\n      }\n      \n      x/=2;\n    }\n    \n    for(int j=0;j<=T;j++) ans=max(ans,dp[i][j]);\n    \n  }\n  \n  cout<<ans<<endl;\n}\n\nvoid init(){\n  \n  memset(memo,0,sizeof(memo));\n  \n  for(int i=0;i<N;i++){\n    G[i].clear();\n    rG[i].clear();\n  }\n  \n  vs.clear();\n  \n}\n\nint used2[MAX_V];\n\nvoid dfs2(int x, int color){\n  \n  if(used2[x]) return ;\n  used2[x]=1;\n  \n  C[x]=color;\n  \n  for(int i=0;i<G[x].size();i++) dfs2(G[x][i],color);\n  \n}\n\nsigned main(){\n\n  while(1){\n  \n    cin>>N>>M>>T;\n    if(!N&&!M&&!T) break;\n    \n    V=N;\n  \n    init();\n  \n    for(int i=0;i<N;i++)\n      cin>>p[i]>>t[i]>>k[i];\n    \n    memset(used2,0,sizeof(used2));\n    \n    for(int i=0;i<M;i++){\n      int a, b;\n      cin>>a>>b;\n      add_edge(a-1,b-1);\n      if(a==b) memo[a-1]=1;\n    }\n    \n    for(int i=0;i<N;i++)\n      if(!used2[i]) dfs2(i,i);\n    \n    scc();\n    \n    solve();\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<functional>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\nusing namespace std;\n\n#define mind(a,b) (a>b?b:a)\n#define maxd(a,b) (a>b?a:b)\n#define absd(x) (x<0?-(x):x)\n#define pow2(x) ((x)*(x))\n#define rep(i,n) for(int i=0; i<n; ++i)\n#define repr(i,n) for(int i=n-1; i>=0; --i)\n#define repl(i,s,n) for(int i=s; i<=n; ++i)\n#define replr(i,s,n) for(int i=n; i>=s; --i)\n#define repf(i,s,n,j) for(int i=s; i<=n; i+=j)\n#define repe(e,obj) for(auto e : obj)\n\n#define SP << \" \" <<\n#define COL << \" : \" <<\n#define COM << \", \" <<\n#define ARR << \" -> \" <<\n#define PNT(STR) cout << STR << endl\n#define POS(X,Y) \"(\" << X << \", \" << Y << \")\"\n#define DEB(A) \" (\" << #A << \") \" << A\n#define DEBREP(i,n,val) for(int i=0; i<n; ++i) cout << val << \" \"; cout << endl\n#define ALL(V) (V).begin(), (V).end()\n#define INF 1000000007\n#define INFLL 10000000000000000007LL\n#define EPS 1e-9\n\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> P;\n//typedef pair<ll, ll> P;\ntypedef pair<P, int> PI;\ntypedef pair<int, P> IP;\ntypedef pair<P, P> PP;\ntypedef priority_queue<P, vector<P>, greater<P> > pvqueue;\n\n#define N 103\n#define M 1003\nint p[N], t[N], k[N];\n\n#define V 103\nint v;\nvector<int> g[V];\nvector<int> rg[V];\nint group[V];\n\nvector<int> ord;\nbool used[V];\nvoid dfs(int s) {\n  used[s] = true;\n  rep(i, g[s].size()) {\n    int t = g[s][i];\n    if(!used[t]) {\n      dfs(t);\n    }\n  }\n  ord.push_back(s);\n}\n\nvoid rdfs(int s, int col) {\n  group[s] = col;\n  used[s] = true;\n  rep(i, rg[s].size()) {\n    int t = rg[s][i];\n    if(!used[t]) {\n      rdfs(t, col);\n    }\n  }\n}\n\nint scc() {\n  rep(i, v) used[i] = false;\n  rep(i, v) {\n    if(!used[i]) dfs(i);\n  }\n  ord.clear();\n  rep(i, v) used[i] = false;\n  int cnt = 0;\n  repr(i, v) {\n    int s = ord[i];\n    if(!used[s]) rdfs(s, cnt++);\n  }\n  return cnt;\n}\n\nvector<int> g2[V];\nvector<int> rg2[V];\nvector<int> els[V];\nbool eused[N][N];\nbool self[N];\n\nint n, m, ti;\n\n\n#define W 10005\nint deq[W];\nll deqv[W];\nbool sused[N];\n\nll dp[V][W];\nvoid sdfs(int v) {\n  if(sused[v]) return;\n  sused[v] = true;\n  rep(i, ti+1) dp[v][i] = 0;\n  rep(i, g2[v].size()) {\n    int to = g2[v][i];\n    sdfs(to);\n    rep(j, ti+1) dp[v][j] = maxd(dp[to][j], dp[v][j]);\n  }\n  if(els[v].size() == 1 && !self[v]) {\n    int u = els[v][0];\n    repr(j, ti-t[u]+1) {\n      dp[v][j+t[u]] = maxd(dp[v][j+t[u]], dp[v][j] + p[u]);\n    }\n  } else {\n    rep(i, els[v].size()) {\n      int u = els[v][i];\n\n      rep(a, t[u]) {\n        int sq = 0, tq = 0;\n        for(int j=0; j*t[u]+a <= ti; ++j) {\n          ll val = dp[v][j*t[u] + a] - j*p[u];\n          while(sq < tq && deqv[tq - 1] <= val) --tq;\n          deq[tq] = j;\n          deqv[tq++] = val;\n\n          dp[v][j*t[u] + a] = deqv[sq] + j*p[u];\n          if(deq[sq] == j - k[u]) ++sq;\n        }\n      }\n    }\n  }\n}\n\nint main() {\n  while(cin >> n >> m >> ti && n+m+ti) {\n    rep(i, n) {\n      cin >> p[i] >> t[i] >> k[i];\n      g[i].clear();\n      rg[i].clear();\n    }\n    rep(i, m) {\n      int a, b;\n      cin >> a >> b; --a; --b;\n      g[a].push_back(b);\n      rg[b].push_back(a);\n    }\n\n    v = n;\n    int w = scc();\n    rep(i, w) rep(j, w) eused[i][j] = false;\n    rep(i, w) {\n      g2[i].clear();\n      rg2[i].clear();\n      els[i].clear();\n      self[i] = false;\n      sused[i] = false;\n    }\n    rep(i, n) {\n      int c = group[i];\n      els[c].push_back(i);\n      rep(j, g[i].size()) {\n        int d = group[g[i][j]];\n        if(c==d) {\n          self[c] = true;\n          continue;\n        }\n        if(eused[c][d]) continue;\n        g2[c].push_back(d);\n        rg2[d].push_back(c);\n        eused[c][d] = true;\n      }\n    }\n\n    ll ans = 0;\n    rep(i, w) {\n      if(rg2[i].empty()) {\n        sdfs(i);\n        rep(j, ti+1) {\n          ans = maxd(ans, dp[i][j]);\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAX_T 10005\n#define MAX_V 105\nusing namespace std;\n\ntypedef pair<int,int> P;\n\n/* ?????£?????????????§£ O(|V|+|E|) */\nint V; //????????°\nvector<int> G[MAX_V]; //??°???????????£??\\??????????????¨???\nvector<int> rG[MAX_V];//?????????????????????????????°??????\nvector<int> vs;       //??°?????????????????????\nbool used[MAX_V];     //?????§???????????????\nint cmp[MAX_V];       //?±????????????£?????????????????????????????????\n\nvoid add_edge(int from,int to){\n  G[from].push_back(to);\n  rG[to].push_back(from);\n}\n\nvoid dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++)if(!used[G[v][i]])dfs(G[v][i]);\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v]=true;\n  cmp[v]=k;\n  for(int i=0;i<rG[v].size();i++) if(!used[rG[v][i]])rdfs(rG[v][i],k);\n}\n\nint scc(){\n  memset(used,0,sizeof(used));\n  vs.clear();\n  for(int v=0;v<V;v++) if(!used[v]) dfs(v);\n  \n  memset(used,0,sizeof(used));\n  int k=0;\n  for(int i=vs.size()-1;i>=0;i--)if(!used[vs[i]]) rdfs(vs[i],k++);\n  return k;\n}\n\nint N, M, T, p[MAX_V], t[MAX_V], k[MAX_V], memo[MAX_V];\nint dp[MAX_V][10005], C[MAX_V];\n\nvoid solve(){\n  \n  vector<P> order;\n  map<int,int> cnt;\n  \n  for(int i=0;i<N;i++){\n    order.push_back(P(cmp[i],i));\n    cnt[cmp[i]]++;\n  }\n  \n  sort(order.begin(),order.end());\n  \n  memset(dp,-1,sizeof(dp));\n  \n  int ans=0;\n    \n  for(int i=0;i<N;i++){\n    \n    if(!i||(i&&C[order[i].second]!=C[order[i-1].second])) dp[i][0]=0;\n    else{\n      for(int j=0;j<=T;j++) dp[i][j]=dp[i-1][j];\n    }\n    \n    int maxk=k[order[i].second];\n    \n    if(!memo[cmp[order[i].second]]&&cnt[cmp[order[i].second]]==1) maxk=1;\n    \n    int x=1;\n    while(x<=maxk) x*=2;\n    \n    while(maxk){\n      \n      while(x-1<=maxk){\n\t\n\tmaxk-=x-1;\n\t\n\tint x2=1, y=t[order[i].second], z=p[order[i].second];\n\t\n\twhile(x2<x){\n\t  \n\t  for(int j=T-1;j>=0;j--){\n\t    if(dp[i][j]==-1) continue;\n\t    \n\t    if(j+y<=T) dp[i][j+y]=max(dp[i][j+y], dp[i][j]+z);\n\t  }\n\t  \n\t  x2*=2;\n\t  y*=2;\n\t  z*=2;\n\t}\n\t\n      }\n      \n      x/=2;\n    }\n\n    for(int j=0;j<N;j++)\n      for(int l=0;l<=T;l++) ans=max(ans,dp[j][l]);\n    \n  }\n  \n  cout<<ans<<endl;\n}\n\nvoid init(){\n  \n  memset(memo,0,sizeof(memo));\n  \n  for(int i=0;i<N;i++){\n    G[i].clear();\n    rG[i].clear();\n  }\n  \n  vs.clear();\n  \n}\n\nint used2[MAX_V];\n\nvoid dfs2(int x, int color){\n  \n  if(used2[x]) return ;\n  used2[x]=1;\n  \n  C[x]=color;\n  \n  for(int i=0;i<G[x].size();i++) dfs2(G[x][i],color);\n  \n}\n\nint main(){\n\n  while(1){\n  \n    cin>>N>>M>>T;\n    if(!N&&!M&&!T) break;\n    \n    V=N;\n  \n    init();\n  \n    for(int i=0;i<N;i++)\n      cin>>p[i]>>t[i]>>k[i];\n    \n    memset(used2,0,sizeof(used2));\n    \n    for(int i=0;i<M;i++){\n      int a, b;\n      cin>>a>>b;\n      add_edge(a-1,b-1);\n      if(a==b) memo[a-1]=1;\n    }\n    \n    for(int i=0;i<N;i++)\n      if(!used2[i]) dfs2(i,i);\n    \n    scc();\n    \n    solve();\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\n\n\nnamespace SCC{\n    void visit(const vector<vector<int>>&G,vector<int>&vs,vector<int>&used,int v){\n        used[v]=true;\n        for(auto u:G[v]){\n            if(!used[u])visit(G,vs,used,u);\n        }\n        vs.push_back(v);\n    }\n\n    void visit2(const vector<vector<int>>&T,vector<int>&used,vector<int>&comp,vector<int>&vec,int k,int v){\n        comp[v]=k;\n        used[v]=true;\n        vec.push_back(v);\n\n        for(auto u:T[v]){\n            if(!used[u])visit2(T,used,comp,vec,k,u);\n        }\n    }\n\n    void decompose(const vector<vector<int>>&G,vector<vector<int>>&H,vector<int>&comp){\n        vector<vector<int>>T(G.size());\n        for(int i=0;i<G.size();i++){\n            for(auto v:G[i]){\n                T[v].push_back(i);\n            }\n        }\n        comp.resize(G.size());\n\n        vector<int>vs(G.size());\n        vector<int>used(G.size());\n        for(int i=0;i<G.size();i++){\n            if(!used[i])visit(G,vs,used,i);\n        }\n        reverse(vs.begin(),vs.end());\n        fill(used.begin(),used.end(),0);\n\n        int K=0;\n        vector<vector<int>>S;\n        for(auto v:vs){\n            if(!used[v]){\n                S.push_back(vector<int>());\n                visit2(T,used,comp,S.back(),K++,v);\n            }\n        }\n\n        H.resize(K);\n        fill(used.begin(),used.end(),0);\n        for(int i=0;i<K;i++){\n            for(auto v:S[i]){\n                for(auto u:G[v]){\n                    if(used[comp[u]]||comp[v]==comp[u])continue;\n                    used[comp[u]]=true;\n                    H[comp[v]].push_back(comp[u]);\n                }\n            }\n            for(auto v:H[i])used[v]=false;\n        }\n\n    }\n}\n\n\nint N,M,T;\n\nvoid solve(){\n    vint p(N),t(N),k(N);\n    rep(i,N)cin>>p[i]>>t[i]>>k[i];\n\n    vector<vint>G(N);\n    vector<int>sel(N);\n    rep(i,M){\n        int a,b;\n        cin>>a>>b;\n        a--;b--;\n        G[a].pb(b);\n        if(a==b)sel[a]=true;\n    }\n\n    vector<vint>H;\n    vint comp;\n\n    SCC::decompose(G,H,comp);\n\n    vector<vpint>lis(H.size());\n\n    vint cnt(H.size());\n    for(int i=0;i<N;i++)cnt[comp[i]]++;\n\n    for(int i=0;i<N;i++){\n        if(cnt[comp[i]]==1&&!sel[i]){\n            lis[comp[i]].pb({p[i],t[i]});\n        }\n        else{\n            for(int j=1;;j<<=1){\n                if(k[i]>=j){\n                    lis[comp[i]].pb({p[i]*j,t[i]*j});\n                    k[i]-=j;\n                }\n                else{\n                    if(k[i])lis[comp[i]].pb({p[i]*k[i],t[i]*k[i]});\n                    break;\n                }\n            }\n        }\n    }\n\n    vector<vint>dp(H.size(),vint(T+1));\n\n    for(int i=0;i<H.size();i++){\n        for(auto &w:lis[i]){\n            for(int j=T;j>=0;j--){\n                if(j+w.se<=T)chmax(dp[i][j+w.se],dp[i][j]+w.fi);\n            }\n        }\n        for(auto &u:H[i])rep(j,T+1)chmax(dp[u][j],dp[i][j]);\n    }\n\n    int ans=0;\n    rep(i,H.size())rep(j,T+1)chmax(ans,dp[i][j]);\n    cout<<ans<<endl;\n}\n\nsigned main(){\n    while(cin>>N>>M>>T,N||M||T)solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAX_V 110\n#define N 110\nusing namespace std;\n\n/* ?????£?????????????§£ O(|V|+|E|) */\nint V; //????????°\nvector<int> G[MAX_V]; //??°???????????£??\\??????????????¨???\nvector<int> rG[MAX_V];//?????????????????????????????°??????\nvector<int> vs;       //??°?????????????????????\nbool used[MAX_V];     //?????§???????????????\nint cmp[MAX_V];       //?±????????????£?????????????????????????????????\n\nvoid add_edge(int from,int to){\n  G[from].push_back(to);\n  rG[to].push_back(from);\n}\n\nvoid dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++)if(!used[G[v][i]])dfs(G[v][i]);\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v]=true;\n  cmp[v]=k;\n  for(int i=0;i<rG[v].size();i++) if(!used[rG[v][i]])rdfs(rG[v][i],k);\n}\n\nint scc(){\n  memset(used,0,sizeof(used));\n  vs.clear();\n  for(int v=0;v<V;v++) if(!used[v]) dfs(v);\n  memset(used,0,sizeof(used));\n  int k=0;\n  for(int i=vs.size()-1;i>=0;i--)if(!used[vs[i]]) rdfs(vs[i],k++);\n  return k;\n}\n\nint n,v[N],w[N],K[N],T;\nint Max(int &a,int b){return a=max(a,b);}\n\nset<int>g[N];\nvector<int> DP[N];\nvoid update(vector<int> I,vector<int> &dp){\n  int col = cmp[I[0]];\n  for(int i:I){\n  int num = g[cmp[i]].count(cmp[i])? K[i]:1;\n  for(int j=1;num;j=min(num,j*2)){ //???????????°\n    num -= j;\n    for(int k=T;k>=j*w[i];k--)  //?????¨?????????\n      Max(dp[k],dp[k-j*w[i]]+j*v[i]);\n  }\n  }\n  \n\n  for(int nx:g[col])\n    for(int j=0;j<=T;j++) Max(DP[nx][j],dp[j]);\n  \n}\n\nvoid init(){\n  for(int i=0;i<N;i++){\n    cmp[i] = 0;\n    G[i].clear();\n    rG[i].clear();\n    g[i].clear();\n    DP[i].clear();\n    DP[i].resize(T+1,0);\n  }\n}\n\nint main(){\n  while(1){\n  int m;\n  cin>>n>>m>>T;\n  if(!n&&!m&&!T)break;\n  init();\n  \n  for(int i=0;i<n;i++)cin>>v[i]>>w[i]>>K[i];\n  for(int i=0,a,b;i<m;i++)cin>>a>>b,add_edge(a-1,b-1);\n  V = n;\n  V=scc();\n  //for(int i=0;i<n;i++)cout<<cmp[i]<<\" \";cout<<endl;\n\n  for(int i=0;i<n;i++)\n    for(int j:G[i])g[cmp[i]].insert(cmp[j]);\n  \n  \n  int ans = 0;\n  for(int i=0;i<V;i++){\n    vector<int> I;\n    for(int j=0;j<n;j++)if(cmp[j]==i) I.push_back(j);\n    update(I,DP[i]);\n  }\n  for(int i=0;i<V;i++)\n    for(int j=0;j<=T;j++) Max(ans,DP[i][j]);\n  \n  cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\n\n\nnamespace SCC{\n    void visit(const vector<vector<int>>&G,vector<int>&vs,vector<int>&used,int v){\n        used[v]=true;\n        for(auto u:G[v]){\n            if(!used[u])visit(G,vs,used,u);\n        }\n        vs.push_back(v);\n    }\n\n    void visit2(const vector<vector<int>>&T,vector<int>&used,vector<int>&comp,vector<int>&vec,int k,int v){\n        comp[v]=k;\n        used[v]=true;\n        vec.push_back(v);\n\n        for(auto u:T[v]){\n            if(!used[u])visit2(T,used,comp,vec,k,u);\n        }\n    }\n\n    void decompose(const vector<vector<int>>&G,vector<vector<int>>&H,vector<int>&comp){\n        vector<vector<int>>T(G.size());\n        for(int i=0;i<G.size();i++){\n            for(auto v:G[i]){\n                T[v].push_back(i);\n            }\n        }\n        comp.resize(G.size());\n\n        vector<int>vs(G.size());\n        vector<int>used(G.size());\n        for(int i=0;i<G.size();i++){\n            if(!used[i])visit(G,vs,used,i);\n        }\n        reverse(vs.begin(),vs.end());\n        fill(used.begin(),used.end(),0);\n\n        int K=0;\n        vector<vector<int>>S;\n        for(auto v:vs){\n            if(!used[v]){\n                S.push_back(vector<int>());\n                visit2(T,used,comp,S.back(),K++,v);\n            }\n        }\n\n        H.resize(K);\n        fill(used.begin(),used.end(),0);\n        for(int i=0;i<K;i++){\n            for(auto v:S[i]){\n                for(auto u:G[v]){\n                    if(used[comp[u]]||comp[v]==comp[u])continue;\n                    used[comp[u]]=true;\n                    H[comp[v]].push_back(comp[u]);\n                }\n            }\n            for(auto v:H[i])used[v]=false;\n        }\n\n    }\n}\n\n\nint N,M,T;\n\nvoid solve(){\n    vint p(N),t(N),k(N);\n    rep(i,N)cin>>p[i]>>t[i]>>k[i];\n\n    vector<vint>G(N);\n    vector<int>sel(N);\n    rep(i,M){\n        int a,b;\n        cin>>a>>b;\n        a--;b--;\n        G[a].pb(b);\n        if(a==b)sel[i]=true;\n    }\n\n    vector<vint>H;\n    vint comp;\n\n    SCC::decompose(G,H,comp);\n\n    vector<vpint>lis(H.size());\n\n    vint cnt(H.size());\n    for(int i=0;i<N;i++)cnt[comp[i]]++;\n\n    for(int i=0;i<N;i++){\n        if(cnt[comp[i]]==1&&!sel[i]){\n            lis[comp[i]].pb({p[i],t[i]});\n        }\n        else{\n            for(int j=1;;j<<=1){\n                if(k[i]>=j){\n                    lis[comp[i]].pb({p[i]*j,t[i]*j});\n                    k[i]-=j;\n                }\n                else{\n                    if(k[i])lis[comp[i]].pb({p[i]*k[i],t[i]*k[i]});\n                    break;\n                }\n            }\n        }\n    }\n\n    vector<vint>dp(H.size(),vint(T+1));\n\n    for(int i=0;i<H.size();i++){\n        for(auto &w:lis[i]){\n            for(int j=T;j>=0;j--){\n                if(j+w.se<=T)chmax(dp[i][j+w.se],dp[i][j]+w.fi);\n            }\n        }\n        for(auto &u:H[i])rep(j,T+1)chmax(dp[u][j],dp[i][j]);\n    }\n\n    int ans=0;\n    rep(i,H.size())rep(j,T+1)chmax(ans,dp[i][j]);\n    cout<<ans<<endl;\n}\n\nsigned main(){\n    while(cin>>N>>M>>T,N||M||T)solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Name: Website Tour\n//Level: 4\n//Category: グラフ,Graph,動的計画法,DP,強連結成分分解,個数制限付きナップサック問題\n//Note:\n\n/**\n * 以下のどちらかの条件を満たすとき、ある頂点の広告は好きなだけ見ることができる。\n * ・自己ループをもつ\n * ・この頂点を含む強連結成分内に他の頂点が存在する\n * したがって、強連結成分分解したグラフを1ノードずつたどりながら、個数制限付きナップサック問題を解いていけばよい。\n * 個数制限付きナップサック問題は、荷物の重さを2冪で分解することにより、O(N log W)で計算できる。\n *\n * オーダーは O(NT log T)。\n */\n\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <unordered_set>\n\nusing namespace std;\n\nstruct Node {\n    int p, t, k;\n};\n\nvoid dfs1(int pos, const vector<vector<int>> &g, vector<bool> &visited, vector<int> &buf) {\n    if(visited[pos]) return;\n    visited[pos] = true;\n    for(int to : g[pos]) dfs1(to, g, visited, buf);\n    buf.push_back(pos);\n}\n\nvoid dfs2(int pos, const vector<vector<int>> &g, int label, vector<int> &buf) {\n    if(buf[pos] != -1) return;\n    buf[pos] = label;\n    for(int to : g[pos]) dfs2(to, g, label, buf);\n}\n\nvector<int> scc(const vector<vector<int>> &g) {\n    const int N = g.size();\n    vector<vector<int>> rev(N);\n    for(int i = 0; i < N; ++i) {\n        for(int to : g[i]) {\n            rev[to].push_back(i);\n        }\n    }\n    vector<bool> visited(N, false);\n    vector<int> ord;\n    for(int i = 0; i < N; ++i) {\n        dfs1(i, g, visited, ord);\n    }\n    reverse(begin(ord), end(ord));\n    vector<int> label(N, -1);\n    int l = 0;\n    for(int i = 0; i < N; ++i) {\n        if(label[i] == -1) dfs2(i, rev, l++, label);\n    }\n    return label;\n}\n\nbool solve() {\n    int N, M, T;\n    if(!(cin >> N >> M >> T)) return false;\n    if(!N && !M && !T) return false;\n\n    vector<Node> nodes(N);\n    for(int i = 0; i < N; ++i) {\n        cin >> nodes[i].p >> nodes[i].t >> nodes[i].k;\n    }\n    vector<vector<int>> g(N);\n    vector<bool> self_looped(N, false);\n    for(int i = 0; i < M; ++i) {\n        int a, b;\n        cin >> a >> b;\n        --a; --b;\n        g[a].push_back(b);\n        if(a == b) self_looped[a] = true;\n    }\n\n    vector<int> label = scc(g);\n    const int L = *max_element(begin(label), end(label)) + 1;\n    vector<vector<int>> nodes_of(L);\n    for(int i = 0; i < N; ++i) {\n        nodes_of[label[i]].push_back(i);\n    }\n\n    vector<vector<long long>> dp(L, vector<long long>(T+1, 0));\n    vector<unordered_set<int>> prev_of(L);\n    long long ans = 0;\n    for(int cur = 0; cur < L; ++cur) {\n        for(int t = 0; t <= T; ++t) {\n            for(int prev : prev_of[cur]) {\n                dp[cur][t] = max(dp[cur][t], dp[prev][t]);\n            }\n            if(t > 0) dp[cur][t] = max(dp[cur][t], dp[cur][t-1]);\n        }\n\n        if(nodes_of[cur].size() >= 2 || self_looped[nodes_of[cur][0]]) {\n            // Can take any numbers of advertisement\n            for(int n : nodes_of[cur]) {\n                int rem = nodes[n].k;\n                for(int ord = 1; rem > 0; ord *= 2) {\n                    const int k = min(ord, rem);\n                    rem -= k;\n                    for(int t = T; t >= 0; --t) {\n                        if(t-k*nodes[n].t >= 0) dp[cur][t] = max(dp[cur][t], dp[cur][t-k*nodes[n].t] + k * nodes[n].p);\n                        if(t > 0) dp[cur][t] = max(dp[cur][t], dp[cur][t-1]);\n                    }\n                }\n            }\n        } else {\n            // Can take only one advertisement\n            for(int t = T; t >= 0; --t) {\n                for(int n : nodes_of[cur]) {\n                    if(t-nodes[n].t >= 0) dp[cur][t] = max(dp[cur][t], dp[cur][t-nodes[n].t] + nodes[n].p);\n                    if(t > 0) dp[cur][t] = max(dp[cur][t], dp[cur][t-1]);\n                }\n            }\n        }\n        for(int n : nodes_of[cur]) {\n            for(int to : g[n]) {\n                prev_of[label[to]].insert(cur);\n            }\n        }\n        ans = max(ans, *max_element(begin(dp[cur]), end(dp[cur]))); \n    }\n    cout << ans << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\ntypedef pair<int, int> Pi;\ntypedef tuple<int, int, int> Ti;\ntypedef vector<int> vint;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nstruct SCC {\n  vector< vector<int> > graph, rgraph, dag;\n  vector< pair<int, int> > edges;\n  vector<int> cmp, selfloop;\n  SCC(int V):graph(V), rgraph(V), cmp(V, -1), selfloop(V, 0){}\n  void add_edge(int from, int to) {\n    graph[from].push_back(to);\n    rgraph[to].push_back(from);\n    edges.emplace_back(from, to);\n  }\n  void dfs(int u, vector<int>& ord, vector<int>& used) {\n    if(used[u]) return;\n    used[u] = 1;\n    for(int v : graph[u]) dfs(v, ord, used);\n    ord.push_back(u);\n  }\n  void rdfs(int u, int& id) {\n    if(~cmp[u]) return;\n    cmp[u] = id;\n    for(int v : rgraph[u]) rdfs(v, id);\n  }\n  int build() {\n    vector<int> ord, used(graph.size(), 0);\n    for(int u = 0; u < (int)graph.size(); u++) dfs(u, ord, used);\n    reverse(ord.begin(), ord.end());\n    int sz = 0;\n    for(int u : ord) if(cmp[u] == -1) rdfs(u, sz), sz++;\n\n    dag.resize(sz);\n    set< pair<int, int> > st;\n    for(auto e : edges) {\n      int u = cmp[e.first], v = cmp[e.second];\n      if(u == v) {\n\tselfloop[u] = 1;\n\tcontinue;\n      }\n      if(st.count(make_pair(u, v))) continue;\n      dag[u].push_back(v);\n      st.emplace(u, v);\n    }\n\n    return sz;\n  }\n};\n\nint N, M, T;\nvector<int> p, t, k;\n\nint dp[101][10010];\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  while(cin >> N >> M >> T, N+M+T) {\n    resz(p, N), resz(t, N), resz(k, N);\n    rep(i, N) cin >> p[i] >> t[i] >> k[i];\n\n\n    SCC graph(N);\n    rep(i, M) {\n      int a, b;\n      cin >> a >> b;\n      --a, --b;\n      graph.add_edge(a, b);\n    }\n    graph.build();\n\n\n    auto& dag = graph.dag;\n    auto& cmp = graph.cmp;\n    int n = dag.size();\n    vector< vector<int> > cmp_id(n);\n    rep(i, N) cmp_id[cmp[i]].push_back(i);\n\n\n    memset(dp, 0, sizeof(dp));\n    rep(id, n) {\n      for(int i : cmp_id[id]) {\n\tint lim = (cmp_id[id].size() > 1 || graph.selfloop[id] ? k[i] : 1);\n\tfor(int l = 0; lim > 0; l++) {\n\t  int num = min(lim, 1LL<<l);\n\t  for(int j = T; j >= t[i]*num; j--) chmax(dp[id][j], dp[id][j-t[i]*num]+p[i]*num);\n\t  lim -= num;\n\t}\n      }\n      for(int to : dag[id]) rep(j, T+1) chmax(dp[to][j], dp[id][j]);\n    }\n\n\n    int ans = 0;\n    rep(i, n) rep(j, T+1) chmax(ans, dp[i][j]);\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define MAX_T 10005\n#define MAX_V 105\nusing namespace std;\n\ntypedef pair<int,int> P;\n\n/* ?????£?????????????§£ O(|V|+|E|) */\nint V; //????????°\nvector<int> G[MAX_V]; //??°???????????£??\\??????????????¨???\nvector<int> rG[MAX_V];//?????????????????????????????°??????\nvector<int> vs;       //??°?????????????????????\nbool used[MAX_V];     //?????§???????????????\nint cmp[MAX_V];       //?±????????????£?????????????????????????????????\n\nvoid add_edge(int from,int to){\n  G[from].push_back(to);\n  rG[to].push_back(from);\n}\n\nvoid dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++)if(!used[G[v][i]])dfs(G[v][i]);\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v]=true;\n  cmp[v]=k;\n  for(int i=0;i<rG[v].size();i++) if(!used[rG[v][i]])rdfs(rG[v][i],k);\n}\n\nint scc(){\n  memset(used,0,sizeof(used));\n  vs.clear();\n  for(int v=0;v<V;v++) if(!used[v]) dfs(v);\n  \n  memset(used,0,sizeof(used));\n  int k=0;\n  for(int i=vs.size()-1;i>=0;i--)if(!used[vs[i]]) rdfs(vs[i],k++);\n  return k;\n}\n\nint N, M, T, p[MAX_V], t[MAX_V], k[MAX_V], memo[MAX_V];\nint dp[MAX_V][MAX_T], C[MAX_V];\n\nvoid solve(){\n  \n  vector<P> order;\n  map<int,int> cnt;\n  \n  for(int i=0;i<N;i++){\n    order.push_back(P(cmp[i],i));\n    cnt[cmp[i]]++;\n  }\n  \n  sort(order.begin(),order.end());\n  \n  memset(dp,-1,sizeof(dp));\n  \n  int ans=0;\n  \n  for(int i=0;i<N;i++){\n    \n    if(!i||(i&&C[order[i].second]!=C[order[i-1].second])) dp[i][0]=0;\n    else{\n      for(int j=0;j<=T;j++) dp[i][j]=dp[i-1][j];\n    }\n    \n    int maxk=k[order[i].second];\n    \n    if(!memo[cmp[order[i].second]]&&cnt[cmp[order[i].second]]==1) maxk=1;\n    \n    int x=1;\n    \n    while(maxk){\n      \n      if(maxk<x) x=maxk;\n\n      int y=t[order[i].second]*x, z=p[order[i].second]*x;\n      \n      for(int j=T;j>=0;j--){\n\t\n\tif(dp[i][j]==-1) continue;\n\t\n\tif(j+y<=T) dp[i][j+y]=max(dp[i][j+y], dp[i][j]+z);\n      }\n      \n      maxk-=x;\n      \n      x*=2;\n    }\n    \n    for(int j=0;j<=T;j++) ans=max(ans,dp[i][j]);\n    \n  }\n  \n  cout<<ans<<endl;\n}\n\nvoid init(){\n  \n  memset(memo,0,sizeof(memo));\n  \n  for(int i=0;i<N;i++){\n    G[i].clear();\n    rG[i].clear();\n  }\n  \n  vs.clear();\n  \n}\n\nint used2[MAX_V];\n\nvoid dfs2(int x, int color){\n  \n  if(used2[x]) return ;\n  used2[x]=1;\n  \n  C[x]=color;\n  \n  for(int i=0;i<G[x].size();i++) dfs2(G[x][i],color);\n  \n}\n\nsigned main(){\n\n  while(1){\n  \n    cin>>N>>M>>T;\n    if(!N&&!M&&!T) break;\n    \n    V=N;\n  \n    init();\n  \n    for(int i=0;i<N;i++)\n      cin>>p[i]>>t[i]>>k[i];\n    \n    memset(used2,0,sizeof(used2));\n    \n    for(int i=0;i<M;i++){\n      int a, b;\n      cin>>a>>b;\n      add_edge(a-1,b-1);\n      if(a==b) memo[a-1]=1;\n    }\n    \n    for(int i=0;i<N;i++)\n      if(!used2[i]) dfs2(i,i);\n    \n    scc();\n    \n    solve();\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 105\n\nstruct Info{\n\tint point,time,limit;\n};\n\nstruct GROUP{\n\tvector<int> nodes;\n};\n\nint N,M,T;\n\nGROUP group[NUM]; //強連結成分のグループ\nvector<int> G[NUM],GROUP_G[NUM];\nvector<int> reverse_G[NUM];\nstack<int> S;\n\nbool check[NUM],have_self_link[NUM],G_check[NUM][NUM];\nint table[NUM],in_num[NUM];\nint dp[NUM][10001],next_dp[10001];\ndouble sleep[NUM];\nInfo info[NUM];\nint ans;\n\nint group_index;\n\nvoid dfs(int node_id){\n\tcheck[node_id] = true;\n\n\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\tif(!check[G[node_id][i]])dfs(G[node_id][i]);\n\t}\n\tS.push(node_id);\n}\n\nvoid reverse_dfs(int node_id){\n\tcheck[node_id] = true;\n\n\tgroup[group_index].nodes.push_back(node_id); //group[group_index]にノードを突っ込む\n\ttable[node_id] = group_index;\n\n\tfor(int i = 0; i < reverse_G[node_id].size(); i++){\n\t\tif(!check[reverse_G[node_id][i]])reverse_dfs(reverse_G[node_id][i]);\n\t}\n}\n\n\nvoid func(){\n\n\tfor(int i = 0; i < N; i++){\n\t\tG[i].clear();\n\t\treverse_G[i].clear();\n\t\thave_self_link[i] = false;\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d %d %d\",&info[i].point,&info[i].time,&info[i].limit);\n\t}\n\n\tint from,to;\n\n\tfor(int loop = 0; loop < M; loop++){\n\t\tscanf(\"%d %d\",&from,&to);\n\t\tfrom--;\n\t\tto--;\n\n\t\tif(from == to){\n\t\t\thave_self_link[from] = true; //★強連結成分扱いとする(自分に戻れる)★\n\t\t\tcontinue;\n\t\t}\n\t\tG[from].push_back(to);\n\t\treverse_G[to].push_back(from);\n\t}\n\n\tfor(int i = 0; i < N; i++)check[i] = false;\n\n\t//まずは帰りがけ順を計算\n\tfor(int i = 0; i < N;i++){\n\t\tif(!check[i])dfs(i);\n\t}\n\n\tfor(int i = 0; i < N;i++)check[i] = false;\n\tfor(int i = 0; i < NUM; i++){\n\t\tgroup[i].nodes.clear();\n\t\tGROUP_G[i].clear();\n\t\tin_num[i] = 0;\n\t\tfor(int k = 0; k < NUM; k++){\n\t\t\tG_check[i][k] = false;\n\t\t}\n\t}\n\n\n\tgroup_index = -1;\n\t//ノードを、帰りがけ順の逆順に、各強連結成分(グループ)に分解\n\twhile(!S.empty()){\n\t\tif(!check[S.top()]){\n\t\t\tgroup_index++;\n\n\t\t\treverse_dfs(S.top());\n\t\t}\n\t\tS.pop();\n\t}\n\n\tint node_id,adj_node,adj_group;\n\t//グループ間の有向エッジを探す\n\tfor(int i = 0; i <= group_index; i++){\n\t\tfor(int k = 0; k < group[i].nodes.size(); k++){\n\t\t\tnode_id = group[i].nodes[k];\n\t\t\tfor(int a = 0; a < G[node_id].size(); a++){\n\t\t\t\tadj_node = G[node_id][a];\n\t\t\t\tadj_group = table[adj_node];\n\t\t\t\tif(adj_group == i || G_check[i][adj_group] == true)continue;\n\t\t\t\tG_check[i][adj_group] = true;\n\t\t\t\tGROUP_G[i].push_back(adj_group);\n\t\t\t\tin_num[adj_group]++;\n\t\t\t}\n\t\t}\n\t}\n\n\t//あらかじめ、強連結成分でなく、かつ自己ループを持たないサイトは、制限個数を1にしておく\n\tfor(int i = 0; i <= group_index; i++){\n\t\tif(group[i].nodes.size() == 1 && have_self_link[group[i].nodes[0]] == false){\n\t\t\tinfo[group[i].nodes[0]].limit = 1;\n\t\t\t//printf(\"%dは1回\\n\",group[i].nodes[0]);\n\t\t}\n\t}\n\n\tfor(int i = 0; i <= group_index; i++){\n\t\tdp[i][0] = 0;\n\t\tfor(int k = 1; k <= T; k++)dp[i][k] = -1;\n\t}\n\n\tans = 0;\n\n\t//トポロジカル順にやる\n\tqueue<int> Q;\n\tfor(int i = 0; i <= group_index; i++){\n\t\tif(in_num[i] == 0){\n\t\t\tQ.push(i);\n\t\t}\n\t}\n\n\tint group_id;\n\n\twhile(!Q.empty()){\n\t\tgroup_id = Q.front();\n\t\tQ.pop();\n\n\t\tfor(int i = 0; i <= T; i++){\n\t\t\tnext_dp[i] = dp[group_id][i];\n\t\t}\n\n\t\tfor(int i = 0; i < group[group_id].nodes.size(); i++){\n\t\t\tnode_id = group[group_id].nodes[i];\n\t\t\t//printf(\"node_id:%d\\n\",node_id);\n\t\t\tfor(int count = 0; count < info[node_id].limit; count++){\n\t\t\t\tif((count+1)*info[node_id].time > T)break;\n\t\t\t\tfor(int t = T; t-info[node_id].time >= 0; t--){ //★★毎回1倍を引くことで、最大でk倍のpointを足したことになる!!!★★\n\t\t\t\t\tif(next_dp[t-info[node_id].time] == -1)continue;\n\t\t\t\t\tnext_dp[t] = max(next_dp[t],next_dp[t-info[node_id].time]+info[node_id].point);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(GROUP_G[group_id].size() == 0){ //DAGの終点\n\n\t\t\tfor(int i = 0; i <= T; i++)ans = max(ans,next_dp[i]);\n\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < GROUP_G[group_id].size(); i++){\n\t\t\t\tadj_group = GROUP_G[group_id][i];\n\t\t\t\tfor(int k = 0; k <= T; k++)dp[adj_group][k] = max(dp[adj_group][k],next_dp[k]); //dpの情報を引き継ぐ\n\t\t\t\tin_num[adj_group]--;\n\t\t\t\tif(in_num[adj_group] == 0){\n\t\t\t\t\tQ.push(adj_group);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",ans);\n}\n\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d %d\",&N,&M,&T);\n\t\tif(N == 0 && M == 0 && T == 0)break;\n\n\t\tfunc();\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 105\n\nstruct Info{\n\tint point,time,limit;\n};\n\nstruct GROUP{\n\tvector<int> nodes;\n};\n\nint N,M,T;\n\nGROUP group[NUM]; //強連結成分のグループ\nvector<int> G[NUM],GROUP_G[NUM];\nvector<int> reverse_G[NUM];\nstack<int> S;\n\nbool check[NUM],have_self_link[NUM],G_check[NUM][NUM],calc_check[NUM];\nint table[NUM];\ndouble sleep[NUM];\nInfo info[NUM];\nint ans;\n\nint group_index;\n\nvoid dfs(int node_id){\n\tcheck[node_id] = true;\n\n\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\tif(!check[G[node_id][i]])dfs(G[node_id][i]);\n\t}\n\tS.push(node_id);\n}\n\nvoid reverse_dfs(int node_id){\n\tcheck[node_id] = true;\n\n\tgroup[group_index].nodes.push_back(node_id); //group[group_index]にノードを突っ込む\n\ttable[node_id] = group_index;\n\n\tfor(int i = 0; i < reverse_G[node_id].size(); i++){\n\t\tif(!check[reverse_G[node_id][i]])reverse_dfs(reverse_G[node_id][i]);\n\t}\n}\n\nvoid recursive(int group_id,int tmp_dp[10001]){\n\n\tcalc_check[group_id] = true; //1度通れば良し\n\n\tint dp[10001],next_dp[10001];\n\tfor(int i = 0; i <= T; i++){\n\t\tdp[i] = tmp_dp[i];\n\t\tnext_dp[i] = dp[i];\n\t}\n\n\tint node_id;\n\tfor(int i = 0; i < group[group_id].nodes.size(); i++){\n\t\tnode_id = group[group_id].nodes[i];\n\t\t//printf(\"node_id:%d\\n\",node_id);\n\n\t\tfor(int k = 1; k <= info[node_id].limit; k++){\n\t\t\tfor(int t = T; t-info[node_id].time*k >= 0; t--){\n\t\t\t\tif(dp[t-info[node_id].time*k] == -1)continue;\n\t\t\t\tnext_dp[t] = max(next_dp[t],dp[t-info[node_id].time*k]+info[node_id].point*k);\n\t\t\t}\n\t\t}\n\t\tfor(int k = 0; k <= T; k++)dp[k] = next_dp[k]; //★サイト毎にdpの更新が必要★\n\t}\n\n\t/*for(int i = 0; i <= T; i++)ans = max(ans,next_dp[i]);\n\t//printf(\"ans:%d\\n\",ans);*/\n\n\tif(GROUP_G[group_id].size() == 0){ //DAGの終点\n\n\t\t//printf(\"%dは終点です\\n\",group_id);\n\n\t\tfor(int i = 0; i <= T; i++)ans = max(ans,next_dp[i]);\n\n\t}else{\n\n\t\tfor(int i = 0; i < GROUP_G[group_id].size(); i++){\n\t\t\trecursive(GROUP_G[group_id][i],next_dp);\n\t\t\t//printf(\"グループ%dから%dへ\\n\",group_id,GROUP_G[group_id][i]);\n\t\t}\n\t}\n}\n\nvoid func(){\n\n\tfor(int i = 0; i < N; i++){\n\t\tG[i].clear();\n\t\treverse_G[i].clear();\n\t\thave_self_link[i] = false;\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d %d %d\",&info[i].point,&info[i].time,&info[i].limit);\n\t}\n\n\tint from,to;\n\n\tfor(int loop = 0; loop < M; loop++){\n\t\tscanf(\"%d %d\",&from,&to);\n\t\tfrom--;\n\t\tto--;\n\n\t\tif(from == to){\n\t\t\thave_self_link[from] = true; //★強連結成分扱いとする(自分に戻れる)★\n\t\t\tcontinue;\n\t\t}\n\t\tG[from].push_back(to);\n\t\treverse_G[to].push_back(from);\n\t}\n\n\tfor(int i = 0; i < N; i++)check[i] = false;\n\n\t//まずは帰りがけ順を計算\n\tfor(int i = 0; i < N;i++){\n\t\tif(!check[i])dfs(i);\n\t}\n\n\tfor(int i = 0; i < N;i++)check[i] = false;\n\tfor(int i = 0; i < NUM; i++){\n\t\tgroup[i].nodes.clear();\n\t\tGROUP_G[i].clear();\n\t\tcalc_check[i] = false;\n\t\tfor(int k = 0; k < NUM; k++){\n\t\t\tG_check[i][k] = false;\n\t\t}\n\t}\n\n\n\tgroup_index = -1;\n\t//ノードを、帰りがけ順の逆順に、各強連結成分(グループ)に分解\n\twhile(!S.empty()){\n\t\tif(!check[S.top()]){\n\t\t\tgroup_index++;\n\n\t\t\treverse_dfs(S.top());\n\t\t}\n\t\tS.pop();\n\t}\n\n\tint node_id,adj_node,adj_group;\n\t//グループ間の有向エッジを探す\n\tfor(int i = 0; i <= group_index; i++){\n\t\tfor(int k = 0; k < group[i].nodes.size(); k++){\n\t\t\tnode_id = group[i].nodes[k];\n\t\t\tfor(int a = 0; a < G[node_id].size(); a++){\n\t\t\t\tadj_node = G[node_id][a];\n\t\t\t\tadj_group = table[adj_node];\n\t\t\t\tif(adj_group == i || G_check[i][adj_group] == true)continue;\n\t\t\t\tG_check[i][adj_group] = true;\n\t\t\t\tGROUP_G[i].push_back(adj_group);\n\t\t\t}\n\t\t}\n\t}\n\n\t//あらかじめ、強連結成分でなく、かつ自己ループを持たないサイトは、制限個数を1にしておく\n\tfor(int i = 0; i <= group_index; i++){\n\t\tif(group[i].nodes.size() == 1 && have_self_link[group[i].nodes[0]] == false){\n\t\t\tinfo[group[i].nodes[0]].limit = 1;\n\t\t\t//printf(\"%dは1回\\n\",group[i].nodes[0]);\n\t\t}\n\t}\n\n\tans = 0;\n\n\tint first_dp[10001];\n\tfirst_dp[0] = 0;\n\tfor(int i = 1; i <= T; i++)first_dp[i] = -1;\n\n\tfor(int start_group = 0; start_group <= group_index; start_group++){\n\t\tif(!calc_check[start_group])\n\t\trecursive(start_group,first_dp);\n\t}\n\n\tprintf(\"%d\\n\",ans);\n}\n\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d %d\",&N,&M,&T);\n\t\tif(N == 0 && M == 0 && T == 0)break;\n\n\t\tfunc();\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct SCC{\n  int V;\n  vector<vector<int> > G,rG,T;\n  vector<int> vs,used,cmp;\n  SCC(){}\n  SCC(int V):V(V){init();}\n  void init(){\n    G.clear();\n    rG.clear();\n    vs.clear();\n    used.clear();\n    cmp.clear();\n    T.clear();\n    \n    G.resize(V);\n    rG.resize(V);\n    used.resize(V);\n    cmp.resize(V);\n  }\n  void add_edge(int from,int to){\n    G[from].push_back(to);\n    rG[to].push_back(from);\n  }\n  void dfs(int v){\n    used[v]=1;\n    for(int i=0;i<(int)G[v].size();i++){\n      if(!used[G[v][i]]) dfs(G[v][i]);\n    }\n    vs.push_back(v);\n  }\n  void rdfs(int v,int k){\n    used[v]=1;\n    cmp[v]=k;\n    T[k].push_back(v);\n    for(int i=0;i<(int)rG[v].size();i++){\n      if(!used[rG[v][i]]) rdfs(rG[v][i],k);\n    }\n  }\n  \n  int scc(){\n    fill(used.begin(),used.end(),0);\n    vs.clear();\n    for(int v=0;v<V;v++){\n      if(!used[v]) dfs(v);\n    }\n    fill(used.begin(),used.end(),0);\n    int k=0;\n    for(int i=vs.size()-1;i>=0;i--){\n      if(!used[vs[i]]){\n\tT.push_back(vector<int>());\n\trdfs(vs[i],k++);\n      }\n    }\n    return k;\n  }\n};\n\n#define MAX 114514\nint dp[111][MAX];\nvoid knapsak(int v,int p,int t,int k){\n  //cout<<k<<\":\"<<endl;\n  for(int i=1;i<=k;k-=i,i*=2){\n    //cout<<i<<endl;\n    for(int j=MAX-1;j>=0;j--){\n      if(dp[v][j]<0) continue;\n      if(j+t*i>=MAX) continue;\n      dp[v][j+t*i]=max(dp[v][j+t*i],dp[v][j]+p*i);\n    }\n  }\n  //cout<<k<<endl;\n  if(!k) return;\n  for(int j=MAX-1;j>=0;j--){\n    if(dp[v][j]<0) continue;\n    if(j+t*k>=MAX) continue;\n    dp[v][j+t*k]=max(dp[v][j+t*k],dp[v][j]+p*k);\n  }\n}\n\nint N,M,T,V;\nint p[111],t[111],k[111];\nbool used[111],self[111];\n\nint ans;\nvoid dfs(int v,SCC &scc){\n  if(used[v]) return;\n  used[v]=1;\n  memset(dp[v],-1,sizeof(dp[v]));\n  dp[v][0]=0;\n  vector<int> &g=scc.T[v];\n  for(int i=0;i<(int)g.size();i++){\n    vector<int> &h=scc.G[g[i]];\n    for(int j=0;j<(int)h.size();j++){\n      int u=scc.cmp[h[j]];\n      dfs(u,scc);\n      for(int k=0;k<MAX;k++)\n\tdp[v][k]=max(dp[v][k],dp[u][k]);\n    }\n  }\n  if((int)scc.T[v].size()==1&&!self[g[0]]){\n    knapsak(v,p[g[0]],t[g[0]],1);\n  }else{\n    for(int i=0;i<(int)g.size();i++){\n      knapsak(v,p[g[i]],t[g[i]],k[g[i]]);\n    }\n  }\n  for(int i=0;i<=T;i++) ans=max(ans,dp[v][i]);\n}\n\nsigned main(){\n  while(cin>>N>>M>>T,N){\n    //cout<<N<<\" \"<<M<<\" \"<<T<<endl;\n    for(int i=0;i<N;i++) cin>>p[i]>>t[i]>>k[i];\n    SCC scc(N);\n    memset(self,0,sizeof(self));\n    for(int i=0;i<M;i++){\n      int a,b;\n      cin>>a>>b;\n      a--;b--;\n      if(a==b) self[a]=1;\n      else scc.add_edge(a,b);\n    }\n    ans=0;\n    memset(used,0,sizeof(used));\n    V=scc.scc();\n    for(int i=0;i<V;i++)\n      if(!used[i]) dfs(i,scc);\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 105\n\nstruct Info{\n\tint point,time,limit;\n};\n\nstruct GROUP{\n\tvector<int> nodes;\n};\n\nint N,M,T;\n\nGROUP group[NUM]; //強連結成分のグループ\nvector<int> G[NUM],GROUP_G[NUM];\nvector<int> reverse_G[NUM];\nstack<int> S;\n\nbool check[NUM],have_self_link[NUM],G_check[NUM][NUM];\nint table[NUM],in_num[NUM];\nint dp[NUM][10001],next_dp[10001];\ndouble sleep[NUM];\nInfo info[NUM];\nint ans;\n\nint group_index;\n\nvoid dfs(int node_id){\n\tcheck[node_id] = true;\n\n\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\tif(!check[G[node_id][i]])dfs(G[node_id][i]);\n\t}\n\tS.push(node_id);\n}\n\nvoid reverse_dfs(int node_id){\n\tcheck[node_id] = true;\n\n\tgroup[group_index].nodes.push_back(node_id); //group[group_index]にノードを突っ込む\n\ttable[node_id] = group_index;\n\n\tfor(int i = 0; i < reverse_G[node_id].size(); i++){\n\t\tif(!check[reverse_G[node_id][i]])reverse_dfs(reverse_G[node_id][i]);\n\t}\n}\n\n\nvoid func(){\n\n\tfor(int i = 0; i < N; i++){\n\t\tG[i].clear();\n\t\treverse_G[i].clear();\n\t\thave_self_link[i] = false;\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d %d %d\",&info[i].point,&info[i].time,&info[i].limit);\n\t}\n\n\tint from,to;\n\n\tfor(int loop = 0; loop < M; loop++){\n\t\tscanf(\"%d %d\",&from,&to);\n\t\tfrom--;\n\t\tto--;\n\n\t\tif(from == to){\n\t\t\thave_self_link[from] = true; //★強連結成分扱いとする(自分に戻れる)★\n\t\t\tcontinue;\n\t\t}\n\t\tG[from].push_back(to);\n\t\treverse_G[to].push_back(from);\n\t}\n\n\tfor(int i = 0; i < N; i++)check[i] = false;\n\n\t//まずは帰りがけ順を計算\n\tfor(int i = 0; i < N;i++){\n\t\tif(!check[i])dfs(i);\n\t}\n\n\tfor(int i = 0; i < N;i++)check[i] = false;\n\tfor(int i = 0; i < NUM; i++){\n\t\tgroup[i].nodes.clear();\n\t\tGROUP_G[i].clear();\n\t\tin_num[i] = 0;\n\t\tfor(int k = 0; k < NUM; k++){\n\t\t\tG_check[i][k] = false;\n\t\t}\n\t}\n\n\n\tgroup_index = -1;\n\t//ノードを、帰りがけ順の逆順に、各強連結成分(グループ)に分解\n\twhile(!S.empty()){\n\t\tif(!check[S.top()]){\n\t\t\tgroup_index++;\n\n\t\t\treverse_dfs(S.top());\n\t\t}\n\t\tS.pop();\n\t}\n\n\tint node_id,adj_node,adj_group;\n\t//グループ間の有向エッジを探す\n\tfor(int i = 0; i <= group_index; i++){\n\t\tfor(int k = 0; k < group[i].nodes.size(); k++){\n\t\t\tnode_id = group[i].nodes[k];\n\t\t\tfor(int a = 0; a < G[node_id].size(); a++){\n\t\t\t\tadj_node = G[node_id][a];\n\t\t\t\tadj_group = table[adj_node];\n\t\t\t\tif(adj_group == i || G_check[i][adj_group] == true)continue;\n\t\t\t\tG_check[i][adj_group] = true;\n\t\t\t\tGROUP_G[i].push_back(adj_group);\n\t\t\t\tin_num[adj_group]++;\n\t\t\t}\n\t\t}\n\t}\n\n\t//あらかじめ、強連結成分でなく、かつ自己ループを持たないサイトは、制限個数を1にしておく\n\tfor(int i = 0; i <= group_index; i++){\n\t\tif(group[i].nodes.size() == 1 && have_self_link[group[i].nodes[0]] == false){\n\t\t\tinfo[group[i].nodes[0]].limit = 1;\n\t\t\t//printf(\"%dは1回\\n\",group[i].nodes[0]);\n\t\t}\n\t}\n\n\tfor(int i = 0; i <= group_index; i++){\n\t\tdp[i][0] = 0;\n\t\tfor(int k = 1; k <= T; k++)dp[i][k] = -1;\n\t}\n\n\tans = 0;\n\n\t//トポロジカル順にやる\n\tqueue<int> Q;\n\tfor(int i = 0; i <= group_index; i++){\n\t\tif(in_num[i] == 0){\n\t\t\tQ.push(i);\n\t\t}\n\t}\n\n\tint group_id;\n\n\twhile(!Q.empty()){\n\t\tgroup_id = Q.front();\n\t\tQ.pop();\n\n\t\tfor(int i = 0; i <= T; i++){\n\t\t\tnext_dp[i] = dp[group_id][i];\n\t\t}\n\n\t\tfor(int i = 0; i < group[group_id].nodes.size(); i++){\n\t\t\tnode_id = group[group_id].nodes[i];\n\t\t\t//printf(\"node_id:%d\\n\",node_id);\n\t\t\tfor(int count = 0; count < info[node_id].limit; count++){\n\t\t\t\tfor(int t = T; t-info[node_id].time >= 0; t--){ //★★毎回1倍を引くことで、最大でk倍のpointを足したことになる!!!★★\n\t\t\t\t\tif(next_dp[t-info[node_id].time] == -1)continue;\n\t\t\t\t\tnext_dp[t] = max(next_dp[t],next_dp[t-info[node_id].time]+info[node_id].point);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(GROUP_G[group_id].size() == 0){ //DAGの終点\n\n\t\t\tfor(int i = 0; i <= T; i++)ans = max(ans,next_dp[i]);\n\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < GROUP_G[group_id].size(); i++){\n\t\t\t\tadj_group = GROUP_G[group_id][i];\n\t\t\t\tfor(int k = 0; k <= T; k++)dp[adj_group][k] = max(dp[adj_group][k],next_dp[k]); //dpの情報を引き継ぐ\n\t\t\t\tin_num[adj_group]--;\n\t\t\t\tif(in_num[adj_group] == 0){\n\t\t\t\t\tQ.push(adj_group);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",ans);\n}\n\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d %d\",&N,&M,&T);\n\t\tif(N == 0 && M == 0 && T == 0)break;\n\n\t\tfunc();\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//Name: Website Tour\n//Level: 4\n//Category: グラフ,Graph,動的計画法,DP,強連結成分分解,個数制限付きナップサック問題\n//Note:\n\n/**\n * 以下のどちらかの条件を満たすとき、ある頂点の広告は好きなだけ見ることができる。\n * ・自己ループをもつ\n * ・この頂点を含む強連結成分内に他の頂点が存在する\n * したがって、強連結成分分解したグラフを1ノードずつたどりながら、個数制限付きナップサック問題を解いていけばよい。\n * 個数制限付きナップサック問題は、荷物の重さを2冪で分解することにより、O(N log W)で計算できる。\n *\n * オーダーは O(NT log T)。\n */\n\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <unordered_set>\n\nusing namespace std;\n\nstruct Node {\n    int p, t, k;\n};\n\nvoid dfs1(int pos, const vector<vector<int>> &g, vector<bool> &visited, vector<int> &buf) {\n    if(visited[pos]) return;\n    visited[pos] = true;\n    for(int to : g[pos]) dfs1(to, g, visited, buf);\n    buf.push_back(pos);\n}\n\nvoid dfs2(int pos, const vector<vector<int>> &g, int label, vector<int> &buf) {\n    if(buf[pos] != -1) return;\n    buf[pos] = label;\n    for(int to : g[pos]) dfs2(to, g, label, buf);\n}\n\nvector<int> scc(const vector<vector<int>> &g) {\n    const int N = g.size();\n    vector<vector<int>> rev(N);\n    for(int i = 0; i < N; ++i) {\n        for(int to : g[i]) {\n            rev[to].push_back(i);\n        }\n    }\n    vector<bool> visited(N, false);\n    vector<int> ord;\n    for(int i = 0; i < N; ++i) {\n        dfs1(i, g, visited, ord);\n    }\n    reverse(begin(ord), end(ord));\n    vector<int> label(N, -1);\n    int l = 0;\n    for(int i = 0; i < N; ++i) {\n        if(label[i] == -1) dfs2(i, rev, l++, label);\n    }\n    return label;\n}\n\nbool solve() {\n    int N, M, T;\n    if(!(cin >> N >> M >> T)) return false;\n    if(!N && !M && !T) return false;\n\n    vector<Node> nodes(N);\n    for(int i = 0; i < N; ++i) {\n        cin >> nodes[i].p >> nodes[i].t >> nodes[i].k;\n    }\n    vector<vector<int>> g(N);\n    vector<bool> self_looped(N, false);\n    for(int i = 0; i < M; ++i) {\n        int a, b;\n        cin >> a >> b;\n        --a; --b;\n        g[a].push_back(b);\n        if(a == b) self_looped[a] = true;\n    }\n\n    vector<int> label = scc(g);\n    const int L = *max_element(begin(label), end(label)) + 1;\n    vector<vector<int>> nodes_of(L);\n    for(int i = 0; i < N; ++i) {\n        nodes_of[label[i]].push_back(i);\n    }\n\n    vector<vector<long long>> dp(L, vector<long long>(T+1, 0));\n    vector<unordered_set<int>> prev_of(L);\n    long long ans = 0;\n    for(int cur = 0; cur < L; ++cur) {\n        for(int t = 0; t <= T; ++t) {\n            for(int prev : prev_of[cur]) {\n                dp[cur][t] = max(dp[cur][t], dp[prev][t]);\n            }\n        }\n        for(int t = 1; t <= T; ++t) {\n            dp[cur][t] = max(dp[cur][t], dp[cur][t-1]);\n        }\n\n        if(nodes_of[cur].size() >= 2 || self_looped[nodes_of[cur][0]]) {\n            // Can take any numbers of advertisement\n            for(int n : nodes_of[cur]) {\n                int rem = nodes[n].k;\n                for(int ord = 1; rem > 0; ord *= 2) {\n                    const int k = min(ord, rem);\n                    rem -= k;\n                    for(int t = T; t >= 0; --t) {\n                        if(t-k*nodes[n].t >= 0) dp[cur][t] = max(dp[cur][t], dp[cur][t-k*nodes[n].t] + k * nodes[n].p);\n                    }\n                    for(int t = 1; t <= T; ++t) {\n                        dp[cur][t] = max(dp[cur][t], dp[cur][t-1]);\n                    }\n                }\n            }\n        } else {\n            // Can take only one advertisement\n            for(int t = T; t >= 0; --t) {\n                for(int n : nodes_of[cur]) {\n                    if(t-nodes[n].t >= 0) dp[cur][t] = max(dp[cur][t], dp[cur][t-nodes[n].t] + nodes[n].p);\n                }\n            }\n            for(int t = 1; t <= T; ++t) {\n                dp[cur][t] = max(dp[cur][t], dp[cur][t-1]);\n            }\n        }\n        for(int n : nodes_of[cur]) {\n            for(int to : g[n]) {\n                prev_of[label[to]].insert(cur);\n            }\n        }\n        ans = max(ans, *max_element(begin(dp[cur]), end(dp[cur]))); \n    }\n    cout << ans << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAX_T 10005\n#define MAX_V 105\nusing namespace std;\n\ntypedef pair<int,int> P;\n\n/* ?????£?????????????§£ O(|V|+|E|) */\nint V; //????????°\nvector<int> G[MAX_V]; //??°???????????£??\\??????????????¨???\nvector<int> rG[MAX_V];//?????????????????????????????°??????\nvector<int> vs;       //??°?????????????????????\nbool used[MAX_V];     //?????§???????????????\nint cmp[MAX_V];       //?±????????????£?????????????????????????????????\n\nvoid add_edge(int from,int to){\n  G[from].push_back(to);\n  rG[to].push_back(from);\n}\n\nvoid dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++)if(!used[G[v][i]])dfs(G[v][i]);\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v]=true;\n  cmp[v]=k;\n  for(int i=0;i<rG[v].size();i++) if(!used[rG[v][i]])rdfs(rG[v][i],k);\n}\n\nint scc(){\n  memset(used,0,sizeof(used));\n  vs.clear();\n  for(int v=0;v<V;v++) if(!used[v]) dfs(v);\n  \n  memset(used,0,sizeof(used));\n  int k=0;\n  for(int i=vs.size()-1;i>=0;i--)if(!used[vs[i]]) rdfs(vs[i],k++);\n  return k;\n}\n\nint N, M, T, p[MAX_V], t[MAX_V], k[MAX_V], memo[MAX_V];\nint dp[MAX_V][10005], C[MAX_V];\n\nvoid solve(){\n  \n  vector<P> order;\n  map<int,int> cnt;\n  \n  for(int i=0;i<N;i++){\n    order.push_back(P(cmp[i],i));\n    cnt[cmp[i]]++;\n  }\n  \n  sort(order.begin(),order.end());\n  \n  memset(dp,-1,sizeof(dp));\n  \n  int ans=0;\n    \n  for(int i=0;i<N;i++){\n    \n    if(!i||(i&&C[order[i].second]!=C[order[i-1].second])) dp[i][0]=0;\n    else{\n      for(int j=0;j<=T;j++) dp[i][j]=dp[i-1][j];\n    }\n    \n    int maxk=k[order[i].second];\n    \n    if(!memo[cmp[order[i].second]]&&cnt[cmp[order[i].second]]==1) maxk=1;\n    \n    int x=1;\n    while(x<=maxk) x*=2;\n    \n    while(maxk){\n      \n      while(x-1<=maxk){\n\t\n\tmaxk-=x-1;\n\t\n\tint x2=1, y=t[order[i].second], z=p[order[i].second];\n\t\n\twhile(x2<x){\n\t  \n\t  for(int j=T-1;j>=0;j--){\n\t    if(dp[i][j]==-1) continue;\n\t    \n\t    if(j+y<=T) dp[i][j+y]=max(dp[i][j+y], dp[i][j]+z);\n\t  }\n\t  \n\t  x2*=2;\n\t  y*=2;\n\t  z*=2;\n\t}\n\t\n      }\n      \n      x/=2;\n    }\n    \n    for(int j=0;j<=T;j++) ans=max(ans,dp[i][j]);\n    \n  }\n  \n  cout<<ans<<endl;\n}\n\nvoid init(){\n  \n  memset(memo,0,sizeof(memo));\n  \n  for(int i=0;i<N;i++){\n    G[i].clear();\n    rG[i].clear();\n  }\n  \n  vs.clear();\n  \n}\n\nint used2[MAX_V];\n\nvoid dfs2(int x, int color){\n  \n  if(used2[x]) return ;\n  used2[x]=1;\n  \n  C[x]=color;\n  \n  for(int i=0;i<G[x].size();i++) dfs2(G[x][i],color);\n  \n}\n\nint main(){\n\n  while(1){\n  \n    cin>>N>>M>>T;\n    if(!N&&!M&&!T) break;\n    \n    V=N;\n  \n    init();\n  \n    for(int i=0;i<N;i++)\n      cin>>p[i]>>t[i]>>k[i];\n    \n    memset(used2,0,sizeof(used2));\n    \n    for(int i=0;i<M;i++){\n      int a, b;\n      cin>>a>>b;\n      add_edge(a-1,b-1);\n      if(a==b) memo[a-1]=1;\n    }\n    \n    for(int i=0;i<N;i++)\n      if(!used2[i]) dfs2(i,i);\n    \n    scc();\n    \n    solve();\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define MAX_T 10005\n#define MAX_V 105\nusing namespace std;\n\ntypedef pair<int,int> P;\n\n/* ?????£?????????????§£ O(|V|+|E|) */\nint V; //????????°\nvector<int> G[MAX_V]; //??°???????????£??\\??????????????¨???\nvector<int> rG[MAX_V];//?????????????????????????????°??????\nvector<int> vs;       //??°?????????????????????\nbool used[MAX_V];     //?????§???????????????\nint cmp[MAX_V];       //?±????????????£?????????????????????????????????\n\nvoid add_edge(int from,int to){\n  G[from].push_back(to);\n  rG[to].push_back(from);\n}\n\nvoid dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++)if(!used[G[v][i]])dfs(G[v][i]);\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v]=true;\n  cmp[v]=k;\n  for(int i=0;i<rG[v].size();i++) if(!used[rG[v][i]])rdfs(rG[v][i],k);\n}\n\nint scc(){\n  memset(used,0,sizeof(used));\n  vs.clear();\n  for(int v=0;v<V;v++) if(!used[v]) dfs(v);\n  \n  memset(used,0,sizeof(used));\n  int k=0;\n  for(int i=vs.size()-1;i>=0;i--)if(!used[vs[i]]) rdfs(vs[i],k++);\n  return k;\n}\n\nint N, M, T, K, p[MAX_V], t[MAX_V], k[MAX_V], memo[MAX_V];\nint dp[MAX_V][MAX_T], C[MAX_V];\n\nvector<int> G2[MAX_V];\nvector<int> nodelist[MAX_V];\n\nvoid solve(){\n    \n  memset(dp,-1,sizeof(dp));\n\n  for(int i=0;i<K;i++) dp[i][0]=0;\n  \n  for(int i=0;i<N;i++)\n    nodelist[cmp[i]].push_back(i);\n  \n  int ans=0;\n  \n  for(int i=0;i<K;i++){\n    \n    for(int j=0;j<nodelist[i].size();j++){\n      \n      int node=nodelist[i][j];\n      \n      int maxk=k[node];\n      \n      if(!memo[node]&&nodelist[cmp[i]].size()==1) maxk=1;\n      \n      int x=1;\n    \n      while(maxk){\n      \n\tif(maxk<x) x=maxk;\n\n\tint y=t[node]*x, z=p[node]*x;\n\t\n\tfor(int l=T;l>=0;l--){\n\t  \n\t  if(dp[i][l]==-1) continue;\n\t\n\t  if(l+y<=T) dp[i][l+y]=max(dp[i][l+y], dp[i][l]+z);\n\t}\n      \n\tmaxk-=x;\n      \n\tx*=2;\n      }\n\n      for(int l=0;l<=T;l++) ans=max(ans,dp[i][l]);\n      \n    }\n    \n    for(int j=0;j<G2[i].size();j++)\n      for(int l=0;l<=T;l++) dp[G2[i][j]][l]=max(dp[G2[i][j]][l],dp[i][l]);\n    \n  }\n  \n  cout<<ans<<endl;\n}\n\nvoid init(){\n  \n  memset(memo,0,sizeof(memo));\n  \n  for(int i=0;i<N;i++){\n    G[i].clear();\n    rG[i].clear();\n    G2[i].clear();\n    nodelist[i].clear();\n  }\n  \n  vs.clear();\n  \n}\n\nint used2[MAX_V];\n\nvoid dfs2(int x, int color){\n  \n  if(used2[x]) return ;\n  used2[x]=1;\n  \n  C[x]=color;\n  \n  for(int i=0;i<G[x].size();i++) dfs2(G[x][i],color);\n  \n}\n\nsigned main(){\n\n  while(1){\n    \n    cin>>N>>M>>T;\n    if(!N&&!M&&!T) break;\n    \n    V=N;\n    \n    init();\n    \n    for(int i=0;i<N;i++)\n      cin>>p[i]>>t[i]>>k[i];\n    \n    memset(used2,0,sizeof(used2));\n    \n    for(int i=0;i<M;i++){\n      int a, b;\n      cin>>a>>b;\n      add_edge(a-1,b-1);\n    }\n    \n    for(int i=0;i<N;i++)\n      if(!used2[i]) dfs2(i,i);\n    \n    K=scc();\n    \n    set<P> S;\n    \n    for(int i=0;i<N;i++)\n      for(int j=0;j<G[i].size();j++)\n\t\n\tif(!S.count(P(cmp[i],cmp[G[i][j]]))){\n\t  \n\t  if(cmp[i]==cmp[G[i][j]]){\n\t    memo[cmp[i]]=1;\n\t    continue;\n\t  }\n\t  \n\t  S.insert(P(cmp[i],cmp[G[i][j]]));\n\t  G2[cmp[i]].push_back(cmp[G[i][j]]);\n\t}\n    \n    solve();\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cstring>\n#define MAX 210\n#define MAXW 10005\n#define INF 1e9\n#define value first\n#define order second\n#define mp make_pair\nusing namespace std;\ntypedef pair<int,int> pii;\nint n, m, t, v, temp, num_cyc;\nint P[MAX], T[MAX], K[MAX];\nint dist[MAX][MAX];\nint dp[MAX][MAXW];\nint dpnow[MAXW];\nint ortu[MAX];\nint nextcyc[MAX][MAX];\nint A[MAX], B[MAX];\nbool udah[MAX];\nvector<int> adjcyc[MAX];\nbool visited[MAX];\npii deque[MAXW<<1];\n\ninline void playdp(int from, int to) {\n\tfor(int i = 0; i <= t; i++) dpnow[i] = dp[to][i];\n\tint size = adjcyc[from].size();\n\tfor(int i = 0; i < size; i++) {\n\t\tint next = adjcyc[from][i];\n\t\tfor(int mod = 0; mod < T[next]; mod++) {\n\t\t\tint front = 1, back = 1;\n\t\t\tfor(int w = mod; w <= t; w += T[next]) {\n\t\t\t\tint order = w/T[next];\n\t\t\t\tint dpnext = dpnow[w] - order*P[next];\n\t\t\t\twhile(front < back && deque[back - 1].value <= dpnext) back -= 1;\n\t\t\t\t\n\t\t\t\tdeque[back].value = dpnext;\n\t\t\t\tdeque[back].order = order;\n\t\t\t\tback += 1;\n\t\t\t\t\n\t\t\t\tdpnow[w] = deque[front].value + order*P[next];\n\t\t\t\tif (order - deque[front].order == K[next]) ++front;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0; i <= t; i++) dp[from][i] = max(dp[from][i], dpnow[i]);\n}\n\nvoid dfs(int cycnow) {\n\tvisited[cycnow] = 1;\n\tplaydp(cycnow,0);\n\t// system(\"PAUSE\");\n\tfor(int i = 1; i <= num_cyc; i++) {\n\t\tif (nextcyc[cycnow][i] && !visited[i]) dfs(i);\n\t\tif (nextcyc[cycnow][i]) playdp(cycnow, i);\n\t}\n}\n\nint main() {\n\twhile(true) {\n\t\t\n\tscanf(\"%d %d %d\",&n,&m,&t);\n\tif (n == 0 && m == 0 && t == 0) break;\n\t\n\tfor(int i = 1; i <= n; i++) {\n\t\tscanf(\"%d %d %d\",&P[i], &T[i], &K[i]);\n\t}\n\t\n\tfor(int i = 0; i < MAX; i++) {\n\t\tfor(int j = 0; j < MAX; j++) {\n\t\t\tdist[i][j] = INF;\n\t\t}\n\t}\n\t\n\tfor(int i = 1; i <= m; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\",&u,&v);\n\t\tA[i] = u, B[i] = v;\n\t\tdist[u][v] = 1;\n\t}\n\t\n\tfor(int k = 1; k <= n; k++) {\n\t\tfor(int i = 1; i <= n; i++) {\n\t\t\tfor(int j = 1; j <= n; j++) {\n\t\t\t\tdist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tnum_cyc = 0;\n\tmemset(ortu, -1, sizeof ortu);\n\t\n\tfor(int i = 1; i <= n; i++) {\n\t\tif (ortu[i] != -1) continue;\n\t\tnum_cyc += 1;\n\t\tif (dist[i][i] == INF) {\n\t\t\tK[i] = 1;\n\t\t\tdist[i][i] = 1;\n\t\t}\n\t\tfor(int j = 1; j <= n; j++) {\n\t\t\tif (dist[i][j] < 1e9 && dist[j][i] < 1e9) {\n\t\t\t\tortu[j] = num_cyc;\n\t\t\t\tadjcyc[num_cyc].push_back(j);\n\t\t\t}\n\t\t}\n\t}\n\t\n\t//terhubung tapi gak satu cycle\n\tfor(int i = 1; i <= m; i++) {\n\t\tif (ortu[A[i]] != ortu[B[i]]) {\n\t\t\tnextcyc[ortu[A[i]]][ortu[B[i]]] = 1;\n\t\t}\n\t}\n\t\n\tmemset(dp,0,sizeof(dp));\n\tmemset(visited, false, sizeof visited);\n\tfor(int v = 1; v <= num_cyc; v++) {\n\t\tif (!visited[v]) \n\t\t\tdfs(v);\n\t}\n\t\n\tint ans = 0;\n\tfor(int i = 1; i <= num_cyc; i++) {\n\t\tfor(int j = 0; j <= t; j++) {\n\t\t\tans = max(ans, dp[i][j]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\t\n\tfor(int i = 0; i < MAX; i++) adjcyc[i].clear();\n\tmemset(nextcyc, 0, sizeof nextcyc);\n\t\n\t} // end testcase\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAX_T 10005\n#define MAX_V 105\nusing namespace std;\n\ntypedef pair<int,int> P;\n\n/* ?????£?????????????§£ O(|V|+|E|) */\nint V; //????????°\nvector<int> G[MAX_V]; //??°???????????£??\\??????????????¨???\nvector<int> rG[MAX_V];//?????????????????????????????°??????\nvector<int> vs;       //??°?????????????????????\nbool used[MAX_V];     //?????§???????????????\nint cmp[MAX_V];       //?±????????????£?????????????????????????????????\n\nvoid add_edge(int from,int to){\n  G[from].push_back(to);\n  rG[to].push_back(from);\n}\n\nvoid dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++)if(!used[G[v][i]])dfs(G[v][i]);\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v]=true;\n  cmp[v]=k;\n  for(int i=0;i<rG[v].size();i++) if(!used[rG[v][i]])rdfs(rG[v][i],k);\n}\n\nint scc(){\n  memset(used,0,sizeof(used));\n  vs.clear();\n  for(int v=0;v<V;v++) if(!used[v]) dfs(v);\n  \n  memset(used,0,sizeof(used));\n  int k=0;\n  for(int i=vs.size()-1;i>=0;i--)if(!used[vs[i]]) rdfs(vs[i],k++);\n  return k;\n}\n\nint N, M, T, K, p[MAX_V], t[MAX_V], k[MAX_V], memo[MAX_V];\nint dp[MAX_V][10005], C[MAX_V];\n\nvoid solve(){\n  \n  vector<P> order;\n  map<int,int> cnt;\n  \n  for(int i=0;i<N;i++){\n    order.push_back(P(cmp[i],i));\n    cnt[cmp[i]]++;\n  }\n  \n  sort(order.begin(),order.end());\n  \n  memset(dp,-1,sizeof(dp));\n  \n  int ans=0;\n    \n  for(int i=0;i<N;i++){\n    \n    if(!i||(i&&C[order[i].second]!=C[order[i-1].second])) dp[i][0]=0;\n    else{\n      for(int j=0;j<=T;j++) dp[i][j]=dp[i-1][j];\n    }\n    \n    int maxk=k[order[i].second];\n    \n    if(!memo[cmp[order[i].second]]&&cnt[cmp[order[i].second]]==1) maxk=1;\n    \n    int x=1;\n    while(x<=maxk) x*=2;\n    \n    while(maxk){\n      \n      while(x-1<=maxk){\n\t\n\tmaxk-=x-1;\n\t\n\tint x2=1, y=t[order[i].second], z=p[order[i].second];\n\t\n\twhile(x2<x){\n\t  \n\t  for(int j=T-1;j>=0;j--){\n\t    if(dp[i][j]==-1) continue;\n\t    \n\t    if(j+y<=T) dp[i][j+y]=max(dp[i][j+y], dp[i][j]+z);\n\t  }\n\t  \n\t  x2*=2;\n\t  y*=2;\n\t  z*=2;\n\t}\n\t\n      }\n      \n      x/=2;\n    }\n\n    for(int j=0;j<N;j++)\n      for(int k=0;k<=T;k++) ans=max(ans,dp[j][k]);\n    \n  }\n  \n  cout<<ans<<endl;\n}\n\nvoid init(){\n  \n  memset(memo,0,sizeof(memo));\n  \n  for(int i=0;i<N;i++){\n    G[i].clear();\n    rG[i].clear();\n  }\n  \n  vs.clear();\n  \n}\n\nint used2[MAX_V];\n\nvoid dfs2(int x, int color){\n  \n  if(used2[x]) return ;\n  used2[x]=1;\n  \n  C[x]=color;\n  \n  for(int i=0;i<G[x].size();i++) dfs2(G[x][i],color);\n  \n}\n\nint main(){\n\n  while(1){\n  \n    cin>>N>>M>>T;\n    if(!N&&!M&&!T) break;\n    \n    V=N;\n  \n    init();\n  \n    for(int i=0;i<N;i++)\n      cin>>p[i]>>t[i]>>k[i];\n    \n    memset(used2,0,sizeof(used2));\n    \n    for(int i=0;i<M;i++){\n      int a, b;\n      cin>>a>>b;\n      add_edge(a-1,b-1);\n      if(a==b) memo[a-1]=1;\n    }\n    \n    for(int i=0;i<N;i++)\n      if(!used2[i]) dfs2(i,i);\n    \n    K=scc();\n    \n    solve();\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 105\n\nstruct Info{\n    int point,time,limit;\n};\n\nstruct GROUP{\n    vector<int> nodes;\n};\n\nint N,M,T;\n\nGROUP group[NUM]; //強連結成分のグループ\nvector<int> G[NUM],GROUP_G[NUM];\nvector<int> reverse_G[NUM];\nstack<int> S;\n\nbool check[NUM],have_self_link[NUM],G_check[NUM][NUM];\nint table[NUM],in_num[NUM];\nint dp[NUM][10001],next_dp[10001];\ndouble sleep[NUM];\nInfo info[NUM];\nint ans;\n\nint group_index;\n\nvoid dfs(int node_id){\n    check[node_id] = true;\n\n    for(int i = 0; i < G[node_id].size(); i++){\n        if(!check[G[node_id][i]])dfs(G[node_id][i]);\n    }\n    S.push(node_id);\n}\n\nvoid reverse_dfs(int node_id){\n    check[node_id] = true;\n\n    group[group_index].nodes.push_back(node_id); //group[group_index]にノードを突っ込む\n    table[node_id] = group_index;\n\n    for(int i = 0; i < reverse_G[node_id].size(); i++){\n        if(!check[reverse_G[node_id][i]])reverse_dfs(reverse_G[node_id][i]);\n    }\n}\n\n\nvoid func(){\n\n    for(int i = 0; i < N; i++){\n        G[i].clear();\n        reverse_G[i].clear();\n        have_self_link[i] = false;\n    }\n\n    for(int i = 0; i < N; i++){\n        scanf(\"%d %d %d\",&info[i].point,&info[i].time,&info[i].limit);\n    }\n\n    int from,to;\n\n    for(int loop = 0; loop < M; loop++){\n        scanf(\"%d %d\",&from,&to);\n        from--;\n        to--;\n\n        if(from == to){\n            have_self_link[from] = true; //★強連結成分扱いとする(自分に戻れる)★\n            continue;\n        }\n        G[from].push_back(to);\n        reverse_G[to].push_back(from);\n    }\n\n    for(int i = 0; i < N; i++)check[i] = false;\n\n    //まずは帰りがけ順を計算\n    for(int i = 0; i < N;i++){\n        if(!check[i])dfs(i);\n    }\n\n    for(int i = 0; i < N;i++)check[i] = false;\n    for(int i = 0; i < NUM; i++){\n        group[i].nodes.clear();\n        GROUP_G[i].clear();\n        in_num[i] = 0;\n        for(int k = 0; k < NUM; k++){\n            G_check[i][k] = false;\n        }\n    }\n\n\n    group_index = -1;\n    //ノードを、帰りがけ順の逆順に、各強連結成分(グループ)に分解\n    while(!S.empty()){\n        if(!check[S.top()]){\n            group_index++;\n\n            reverse_dfs(S.top());\n        }\n        S.pop();\n    }\n\n    int node_id,adj_node,adj_group;\n    //グループ間の有向エッジを探す\n    for(int i = 0; i <= group_index; i++){\n        for(int k = 0; k < group[i].nodes.size(); k++){\n            node_id = group[i].nodes[k];\n            for(int a = 0; a < G[node_id].size(); a++){\n                adj_node = G[node_id][a];\n                adj_group = table[adj_node];\n                if(adj_group == i || G_check[i][adj_group] == true)continue;\n                G_check[i][adj_group] = true;\n                GROUP_G[i].push_back(adj_group);\n                in_num[adj_group]++;\n            }\n        }\n    }\n\n    //あらかじめ、強連結成分でなく、かつ自己ループを持たないサイトは、制限個数を1にしておく\n    for(int i = 0; i <= group_index; i++){\n        if(group[i].nodes.size() == 1 && have_self_link[group[i].nodes[0]] == false){\n            info[group[i].nodes[0]].limit = 1;\n            //printf(\"%dは1回\\n\",group[i].nodes[0]);\n        }\n    }\n\n    for(int i = 0; i <= group_index; i++){\n        dp[i][0] = 0;\n        for(int k = 1; k <= T; k++)dp[i][k] = -1;\n    }\n\n    ans = 0;\n\n    //トポロジカル順にやる\n    queue<int> Q;\n    for(int i = 0; i <= group_index; i++){\n        if(in_num[i] == 0){\n            Q.push(i);\n        }\n    }\n\n    int group_id;\n    vector<int> UPDATED;\n\n    while(!Q.empty()){\n        group_id = Q.front();\n        Q.pop();\n\n        for(int i = 0; i <= T; i++){\n            next_dp[i] = dp[group_id][i];\n        }\n\n        for(int i = 0; i < group[group_id].nodes.size(); i++){\n            node_id = group[group_id].nodes[i];\n            //printf(\"node_id:%d\\n\",node_id);\n            for(int k = 1; k <= info[node_id].limit; k++){\n                if(info[node_id].time*k > T)break;\n                for(int t = T; t-info[node_id].time*k >= 0; t--){\n                    if(dp[group_id][t-info[node_id].time*k] == -1)continue;\n                    //next_dp[t] = max(next_dp[t],dp[group_id][t-info[node_id].time*k]+info[node_id].point*k);\n                    if(next_dp[t] < dp[group_id][t-info[node_id].time*k]+info[node_id].point*k){\n                    \tnext_dp[t] = dp[group_id][t-info[node_id].time*k]+info[node_id].point*k;\n                    \tUPDATED.push_back(t);\n                    }\n                }\n            }\n            for(int k = 0; k < UPDATED.size(); k++){\n            \tdp[group_id][UPDATED[k]] = next_dp[UPDATED[k]];\n            \tUPDATED.clear();\n            }\n        }\n\n        if(GROUP_G[group_id].size() == 0){ //DAGの終点\n\n            for(int i = 0; i <= T; i++)ans = max(ans,next_dp[i]);\n\n        }else{\n\n            for(int i = 0; i < GROUP_G[group_id].size(); i++){\n                adj_group = GROUP_G[group_id][i];\n                for(int k = 0; k <= T; k++)dp[adj_group][k] = max(dp[adj_group][k],next_dp[k]); //dpの情報を引き継ぐ\n                in_num[adj_group]--;\n                if(in_num[adj_group] == 0){\n                    Q.push(adj_group);\n                }\n            }\n        }\n    }\n\n    printf(\"%d\\n\",ans);\n}\n\n\nint main(){\n\n    while(true){\n        scanf(\"%d %d %d\",&N,&M,&T);\n        if(N == 0 && M == 0 && T == 0)break;\n\n        func();\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ninline void chmax(int &x, int y) { x = max(x, y); }\n\nint n, m, t, p[128], q[128], r[128], sn;\nvector<int> G[128], rG[128], vs, scc[128], to[128];\nint self[128], done[128], belong[128], cnt[128];\n\nvoid topo_dfs(int v)\n{\n        if(done[v]) return;\n        done[v] = 1;\n        for(auto &e: G[v]) topo_dfs(e);\n        vs.push_back(v);\n}\n\nvoid scc_dfs(int v, int id)\n{\n        if(~belong[v]) return;\n        belong[v] = id;\n        scc[id].push_back(v);\n        for(auto &e: rG[v]) scc_dfs(e, id);\n}\n\nvoid strongly_cc()\n{\n        for (int i = 0; i < n; i++) topo_dfs(i);\n        reverse(begin(vs),end(vs));\n        sn = 0;\n        for (int i = 0; i < n; i++) if(!~belong[vs[i]]) scc_dfs(vs[i],sn++);\n}\n\nvoid scc_topo_dfs(int v)\n{\n        if(done[v]) return;\n        done[v] = 1;\n        for(auto &e: to[v]) scc_topo_dfs(e);\n        vs.push_back(v);\n}\n\nint dp[128][10010];\n\nint solve()\n{\n        strongly_cc();\n\n        for (int i = 0; i < n; i++)\n                for(auto &e: G[i])\n                        if(belong[e] != belong[i])\n                                to[belong[i]].push_back(belong[e]);\n        for (int i = 0; i < sn; i++) {\n                sort(begin(to[i]),end(to[i]));\n                to[i].erase(unique(begin(to[i]),end(to[i])), end(to[i]));\n        }\n\n        vs.clear();\n        memset(done,0,sizeof(done));\n        for (int i = 0; i < sn; i++) scc_topo_dfs(i);\n        reverse(begin(vs),end(vs));\n\n        int ans = 0;\n        for(auto &si: vs) {\n                if((int)scc[si].size() == 1 and !self[scc[si][0]]) r[scc[si][0]] = 1;\n                for(auto &i: scc[si]) {\n                        int num = r[i];\n                        for (int k = 1; num > 0; k <<= 1) {\n                                int mul = min(k, num);\n                                for (int j = t; j >= q[i]*mul; j--)\n                                        chmax(dp[si][j], dp[si][j-q[i]*mul]+p[i]*mul);\n                                num -= mul;\n                        }\n                }\n                for(auto &e: to[si])\n                        for (int j = 0; j <= t; j++)\n                                chmax(dp[e][j], dp[si][j]);\n                chmax(ans, dp[si][t]);\n        }\n        return ans;\n}\n\nvoid init()\n{\n        for (int i = 0; i < 128; i++) {\n                G[i].clear();\n                rG[i].clear();\n                scc[i].clear();\n                to[i].clear();\n                self[i] = done[i] = cnt[i] = 0;\n                belong[i] = -1;\n        }\n        memset(dp,0,sizeof(dp));\n        vs.clear();\n}\n\nbool input()\n{\n        init();\n        scanf(\"%d %d %d\", &n, &m, &t);\n        for (int i = 0; i < n; i++) scanf(\"%d %d %d\", p+i, q+i, r+i);\n        for (int i = 0; i < m; i++) {\n                int a, b; scanf(\"%d %d\", &a, &b); a--; b--;\n                G[a].push_back(b);\n                rG[b].push_back(a);\n                if(a == b) self[a] = 1;\n        }\n        return n or m or t;\n}\n\nint main()\n{\n        while(input()) printf(\"%d\\n\", solve());\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 105\n\nstruct Info{\n    int point,time,limit;\n};\n\nstruct GROUP{\n    vector<int> nodes;\n};\n\nint N,M,T;\n\nGROUP group[NUM]; //強連結成分のグループ\nvector<int> G[NUM],GROUP_G[NUM];\nvector<int> reverse_G[NUM];\nstack<int> S;\n\nbool check[NUM],have_self_link[NUM],G_check[NUM][NUM];\nint table[NUM],in_num[NUM];\nint dp[NUM][10001];\ndouble sleep[NUM];\nInfo info[NUM];\nint ans;\n\nint group_index;\n\nvoid dfs(int node_id){\n    check[node_id] = true;\n\n    for(int i = 0; i < G[node_id].size(); i++){\n        if(!check[G[node_id][i]])dfs(G[node_id][i]);\n    }\n    S.push(node_id);\n}\n\nvoid reverse_dfs(int node_id){\n    check[node_id] = true;\n\n    group[group_index].nodes.push_back(node_id); //group[group_index]にノードを突っ込む\n    table[node_id] = group_index;\n\n    for(int i = 0; i < reverse_G[node_id].size(); i++){\n        if(!check[reverse_G[node_id][i]])reverse_dfs(reverse_G[node_id][i]);\n    }\n}\n\n\nvoid func(){\n\n    for(int i = 0; i < N; i++){\n        G[i].clear();\n        reverse_G[i].clear();\n        have_self_link[i] = false;\n    }\n\n    for(int i = 0; i < N; i++){\n        scanf(\"%d %d %d\",&info[i].point,&info[i].time,&info[i].limit);\n    }\n\n    int from,to;\n\n    for(int loop = 0; loop < M; loop++){\n        scanf(\"%d %d\",&from,&to);\n        from--;\n        to--;\n\n        if(from == to){\n            have_self_link[from] = true; //★強連結成分扱いとする(自分に戻れる)★\n            continue;\n        }\n        G[from].push_back(to);\n        reverse_G[to].push_back(from);\n    }\n\n    for(int i = 0; i < N; i++)check[i] = false;\n\n    //まずは帰りがけ順を計算\n    for(int i = 0; i < N;i++){\n        if(!check[i])dfs(i);\n    }\n\n    for(int i = 0; i < N;i++)check[i] = false;\n    for(int i = 0; i < NUM; i++){\n        group[i].nodes.clear();\n        GROUP_G[i].clear();\n        in_num[i] = 0;\n        for(int k = 0; k < NUM; k++){\n            G_check[i][k] = false;\n        }\n    }\n\n\n    group_index = -1;\n    //ノードを、帰りがけ順の逆順に、各強連結成分(グループ)に分解\n    while(!S.empty()){\n        if(!check[S.top()]){\n            group_index++;\n\n            reverse_dfs(S.top());\n        }\n        S.pop();\n    }\n\n    int node_id,adj_node,adj_group;\n    //グループ間の有向エッジを探す\n    for(int i = 0; i <= group_index; i++){\n        for(int k = 0; k < group[i].nodes.size(); k++){\n            node_id = group[i].nodes[k];\n            for(int a = 0; a < G[node_id].size(); a++){\n                adj_node = G[node_id][a];\n                adj_group = table[adj_node];\n                if(adj_group == i || G_check[i][adj_group] == true)continue;\n                G_check[i][adj_group] = true;\n                GROUP_G[i].push_back(adj_group);\n                in_num[adj_group]++;\n            }\n        }\n    }\n\n    //あらかじめ、強連結成分でなく、かつ自己ループを持たないサイトは、制限個数を1にしておく\n    for(int i = 0; i <= group_index; i++){\n        if(group[i].nodes.size() == 1 && have_self_link[group[i].nodes[0]] == false){\n            info[group[i].nodes[0]].limit = 1;\n            //printf(\"%dは1回\\n\",group[i].nodes[0]);\n        }\n    }\n\n    for(int i = 0; i <= group_index; i++){\n        dp[i][0] = 0;\n        for(int k = 1; k <= T; k++)dp[i][k] = -1;\n    }\n\n    ans = 0;\n\n    //トポロジカル順にやる\n    queue<int> Q;\n    for(int i = 0; i <= group_index; i++){\n        if(in_num[i] == 0){\n            Q.push(i);\n        }\n    }\n\n    int group_id,count,mult;\n\n    while(!Q.empty()){\n        group_id = Q.front();\n        Q.pop();\n\n       for(int i = 0; i < group[group_id].nodes.size(); i++){\n            node_id = group[group_id].nodes[i];\n\n            count = info[node_id].limit;\n            for (int k = 1; count > 0; k *= 2) { //★★ダブリングナップザック★★\n\t\t\t\t\tmult = min(k,count);\n\t\t\t\t\tfor (int t = T; t-info[node_id].time*mult >= 0; t--){\n\t\t\t\t\t\tif(dp[group_id][t-info[node_id].time*mult] == -1)continue;\n\t\t\t\t\t\tdp[group_id][t] = max(dp[group_id][t],dp[group_id][t-info[node_id].time*mult]+info[node_id].point*mult);\n\t\t\t\t\t}\n\t\t\t\t\tcount -= mult;\n\t\t\t}\n        }\n\n        if(GROUP_G[group_id].size() == 0){ //DAGの終点\n\n            for(int i = 0; i <= T; i++)ans = max(ans,dp[group_id][i]);\n\n        }else{\n\n            for(int i = 0; i < GROUP_G[group_id].size(); i++){\n                adj_group = GROUP_G[group_id][i];\n                for(int k = 0; k <= T; k++)dp[adj_group][k] = max(dp[adj_group][k],dp[group_id][k]); //dpの情報を引き継ぐ\n                in_num[adj_group]--;\n                if(in_num[adj_group] == 0){\n                    Q.push(adj_group);\n                }\n            }\n        }\n    }\n\n    printf(\"%d\\n\",ans);\n}\n\n\nint main(){\n\n    while(true){\n        scanf(\"%d %d %d\",&N,&M,&T);\n        if(N == 0 && M == 0 && T == 0)break;\n\n        func();\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\nint p[110];\nint q[110];\nint r[110];\nvector<int>g[110];\nint g2[110][110];\nint UF[110];\nint FIND(int a){\n\tif(UF[a]<0)return a;\n\treturn UF[a]=FIND(UF[a]);\n}\nvoid UNION(int a,int b){\n\ta=FIND(a);b=FIND(b);if(a==b)return;UF[a]+=UF[b];UF[b]=a;\n}\nint dp[110][11000];\nint jk[110];\nint sz;\nint top[110];\nint rep[110];\nint v[110];\nint cnt;\nvoid dfs(int a){\n\tv[a]=1;\n\tfor(int i=0;i<sz;i++){\n\t\tif(i!=a&&g2[rep[a]][rep[i]]&&!v[i]){\n\t\t\tdfs(i);\n\t\t}\n\t}\n\ttop[cnt--]=a;\n}\nint main(){\n\tint a,b,c;\n\twhile(scanf(\"%d%d%d\",&a,&b,&c),a){\n\t\tfor(int i=0;i<a;i++)jk[i]=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tscanf(\"%d%d%d\",p+i,q+i,r+i);\n\t\t}\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<a;j++)g2[i][j]=0;\n\t\tfor(int i=0;i<a;i++)g2[i][i]=1;\n\t\tfor(int i=0;i<a;i++)g[i].clear();\n\t\tfor(int i=0;i<b;i++){\n\t\t\tint s,t;scanf(\"%d%d\",&s,&t);s--;t--;\n\t\t\tif(s==t)jk[s]=1;\n\t\t\tg[s].push_back(t);\n\t\t\tg2[s][t]=1;\n\t\t}\n\t\tfor(int k=0;k<a;k++)for(int i=0;i<a;i++)for(int j=0;j<a;j++){\n\t\t\tg2[i][j]|=(g2[i][k]&g2[k][j]);\n\t\t}\n\t\tfor(int i=0;i<a;i++)UF[i]=-1;\n\t\tfor(int i=0;i<a;i++)for(int j=i+1;j<a;j++){\n\t\t\tif(g2[i][j]&&g2[j][i])UNION(i,j);\n\t\t}\n\t\tsz=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tif(UF[i]<0){\n\t\t\t\trep[sz++]=i;\n\t\t\t}\n\t\t}\n\t\tcnt=sz-1;\n\t\tfor(int i=0;i<sz;i++){\n\t\t\tv[i]=0;\n\t\t}\n\t\tfor(int i=0;i<sz;i++){\n\t\t\tif(v[i]==0){\n\t\t\t\tdfs(i);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<sz;i++)for(int j=0;j<=c;j++)dp[i][j]=-999999999;\n\t\tfor(int i=0;i<sz;i++)dp[i][0]=0;\n\t\tfor(int i=0;i<sz;i++){\n\t\t\tfor(int j=0;j<i;j++){\n\t\t\t\tif(g2[rep[top[j]]][rep[top[i]]]){\n\t\t\t\t\tfor(int k=0;k<=c;k++)dp[i][k]=max(dp[i][k],dp[j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(UF[rep[top[i]]]==-1&&jk[rep[top[i]]]==0){\n\t\t\t\tfor(int j=c;j>=q[rep[top[i]]];j--){\n\t\t\t\t\tdp[i][j]=max(dp[i][j],dp[i][j-q[rep[top[i]]]]+p[rep[top[i]]]);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\t\tif(FIND(j)==rep[top[i]]){\n\t\t\t\t\t\tfor(int k=0;k<q[j];k++){\n\t\t\t\t\t\t\tdeque<pair<int,int> >Q;\n\t\t\t\t\t\t\tfor(int l=k;l<=c;l+=q[j]){\n\t\t\t\t\t\t\t\twhile(Q.size()&&dp[i][l]-p[j]*(l/q[j])>=Q.back().second){\n\t\t\t\t\t\t\t\t\tQ.pop_back();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tQ.push_back(make_pair(l,dp[i][l]-p[j]*(l/q[j])));\n\t\t\t\t\t\t\t\tdp[i][l]=max(dp[i][l],Q.front().second+p[j]*(l/q[j]));\n\t\t\t\t\t\t\t\tif(Q.front().first<=l-r[j]*q[j])Q.pop_front();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t//\tprintf(\"%d %d %d\\n\",rep[top[i]],UF[rep[top[i]]],jk[rep[top[i]]]);\n\t//\t\tfor(int j=0;j<=c;j++)printf(\"%d \",dp[i][j]);\n//\t\t\tprintf(\"\\n\");\n\t\t}\n\t\tint ret=0;\n\t\tfor(int i=0;i<sz;i++)for(int j=0;j<=c;j++)ret=max(ret,dp[i][j]);\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\n\nconst int vmax=110;\n\nint V;\nvi G[vmax];\nvi rG[vmax];\nvi vs;\nbool used[vmax];\nint cmp[vmax];\n\n\nvoid add_edge(int from,int to){\n\tG[from].push_back(to);\n\trG[to].push_back(from);\n}\n\nvoid dfs(int v){\n\tused[v]=true;\n\tfor(int i=0;i<G[v].size();i++)\n\t\tif(!used[G[v][i]])\n\t\t\tdfs(G[v][i]);\n\tvs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n\tused[v]=true;\n\tcmp[v]=k;\n\n\tfor(int i=0;i<rG[v].size();i++)\n\t\tif(!used[rG[v][i]])\n\t\t\trdfs(rG[v][i],k);\n}\n\nint scc(void){\n\tmemset(used,0,sizeof(used));\n\tvs.clear();\n\tfor(int v=0;v< V ;v++)\n\t\tif(!used[v])\n\t\t\tdfs(v);\n\tmemset(used,0,sizeof(used));\n\tint  k=0;\n\tfor(int i=vs.size()-1;i>=0;i--){\n\t\tif(!used[vs[i]])\n\t\t\trdfs(vs[i],k++);\n\t}\n\treturn k;\n}\n\nint N,M,T;\nint dp[110][10010];\nint p[110],t[110],k[110];\nint a[1010],b[1010];\n\nbool rel[110][110];\nbool check[110];\n\nint s;\n\nint deq[10010];\nint deqv[10010];\n\nvoid solve(int cur){\n\tvi index;\n\trep(i,N) if(cur==cmp[i]) index.pb(i);\n\tif(index.size()==1&&!rel[cur][cur]){\n\t\tint tar=index[0];\n\t\tfor(int j=T;j>=t[tar];j--) dp[cur][j]=max(dp[cur][j],dp[cur][j-t[tar]]+p[tar]);\n\t}else{\n\t\tfor(auto &i :index){\n\t\t\trep(aa,t[i]){\n\t\t\t\tint ss=0,tt=0;\n\t\t\t\tfor(int j=0;j*t[i]+aa<=T;++j){\n\t\t\t\t\tint val=dp[cur][j*t[i]+aa]-j*p[i];\n\t\t\t\t\twhile(ss<tt && deqv[tt-1]<=val) tt--;\n\t\t\t\t\tdeq[tt]=j;\n\t\t\t\t\tdeqv[tt++]=val;\n\t\t\t\t\tdp[cur][j*t[i]+aa]=deqv[ss]+j*p[i];\n\t\t\t\t\tif(deq[ss]==j-k[i]) ss++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\trep(i,s) if(rel[cur][i]) rep(j,T+1) dp[i][j]=max(dp[i][j],dp[cur][j]);\n}\n\nint main(void){\n\twhile(cin >> N >> M >> T){\n\t\tif(N==0)\n\t\t\tbreak;\n\t\tV=N;\n\t\trep(i,N) cin >> p[i]  >> t[i] >> k[i];\n\n\t\trep(i,vmax) G[i].clear(),rG[i].clear();\n\t\trep(i,vmax)rep(j,10010) dp[i][j]=0;\n\t\trep(i,vmax)rep(j,vmax) rel[i][j]=false;\n\t\trep(i,vmax) check[i]=false;\n\n\t\trep(i,M){\n\t\t\tcin >> a[i] >> b[i];\n\t\t\ta[i]--,b[i]--;\n\t\t\tadd_edge(a[i],b[i]);\n\t\t}\n\n\t\ts=scc();\n\t\trep(i,M) a[i]=cmp[a[i]],b[i]=cmp[b[i]];\n\t\trep(i,M) rel[a[i]][b[i]]=true;\n\n\t\tint ans=0;\n\t\trep(i,s) solve(i);\n\n\t\trep(i,s) ans=max(ans,dp[i][T]);\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MAX_V 110\n#define N 110\nusing namespace std;\n\n/* ?????£?????????????§£ O(|V|+|E|) */\nint V; //????????°\nvector<int> G[MAX_V]; //??°???????????£??\\??????????????¨???\nvector<int> rG[MAX_V];//?????????????????????????????°??????\nvector<int> vs;       //??°?????????????????????\nbool used[MAX_V];     //?????§???????????????\nint cmp[MAX_V];       //?±????????????£?????????????????????????????????\n\nvoid add_edge(int from,int to){\n  G[from].push_back(to);\n  rG[to].push_back(from);\n}\n\nvoid dfs(int v){\n  used[v]=true;\n  for(int i=0;i<G[v].size();i++)if(!used[G[v][i]])dfs(G[v][i]);\n  vs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n  used[v]=true;\n  cmp[v]=k;\n  for(int i=0;i<rG[v].size();i++) if(!used[rG[v][i]])rdfs(rG[v][i],k);\n}\n\nint scc(){\n  memset(used,0,sizeof(used));\n  vs.clear();\n  for(int v=0;v<V;v++) if(!used[v]) dfs(v);\n  memset(used,0,sizeof(used));\n  int k=0;\n  for(int i=vs.size()-1;i>=0;i--)if(!used[vs[i]]) rdfs(vs[i],k++);\n  return k;\n}\n\nint n,v[N],w[N],K[N],T;\nint Max(int &a,int b){return a=max(a,b);}\n\nset<int>g[N];\nvector<int> DP[N];\nvoid update(vector<int> I,vector<int> &dp){\n  int col = cmp[I[0]];\n  for(int i:I){ //??????\n    int num = g[cmp[i]].count(cmp[i])? K[i]:1;\n    for(int j=1;num;j=min(num,j*2)){ //???????????°\n      num -= j;\n      for(int k=T;k>=j*w[i];k--)  //?????¨?????????\n        Max(dp[k],dp[k-j*w[i]]+j*v[i]);\n    }\n  }\n  \n\n  for(int nx:g[col])\n    for(int j=0;j<=T;j++) Max(DP[nx][j],dp[j]);\n  \n}\n\nvoid init(){\n  for(int i=0;i<N;i++){\n    cmp[i] = 0;\n    G[i].clear();\n    rG[i].clear();\n    g[i].clear();\n    DP[i].clear();\n    DP[i].resize(T+1,0);\n  }\n}\n\nint main(){\n  while(1){\n    int m;\n    cin>>n>>m>>T;\n    if(!n&&!m&&!T)break;\n    init();\n  \n    for(int i=0;i<n;i++)cin>>v[i]>>w[i]>>K[i];\n    for(int i=0,a,b;i<m;i++)cin>>a>>b,add_edge(a-1,b-1);\n    V = n;\n    V=scc();\n    \n    for(int i=0;i<n;i++)\n      for(int j:G[i])g[cmp[i]].insert(cmp[j]);\n  \n    int ans = 0;\n    for(int i=0;i<V;i++){\n      vector<int> I;\n      for(int j=0;j<n;j++)if(cmp[j]==i) I.push_back(j);\n      update(I,DP[i]);\n    }\n    for(int i=0;i<V;i++)\n      for(int j=0;j<=T;j++) Max(ans,DP[i][j]);\n  \n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Name: Website Tour\n//Level: 4\n//Category: グラフ,Graph,動的計画法,DP,強連結成分分解,個数制限付きナップサック問題\n//Note:\n\n/**\n * 以下のどちらかの条件を満たすとき、ある頂点の広告は好きなだけ見ることができる。\n * ・自己ループをもつ\n * ・この頂点を含む強連結成分内に他の頂点が存在する\n * したがって、強連結成分分解したグラフを1ノードずつたどりながら、個数制限付きナップサック問題を解いていけばよい。\n * 個数制限付きナップサック問題は、荷物の重さを2冪で分解することにより、O(N log W)で計算できる。\n *\n * オーダーは O(NT log T)。\n */\n\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <unordered_set>\n\nusing namespace std;\n\nstruct Node {\n    int p, t, k;\n};\n\nvoid dfs1(int pos, const vector<vector<int>> &g, vector<bool> &visited, vector<int> &buf) {\n    if(visited[pos]) return;\n    visited[pos] = true;\n    for(int to : g[pos]) dfs1(to, g, visited, buf);\n    buf.push_back(pos);\n}\n\nvoid dfs2(int pos, const vector<vector<int>> &g, int label, vector<int> &buf) {\n    if(buf[pos] != -1) return;\n    buf[pos] = label;\n    for(int to : g[pos]) dfs2(to, g, label, buf);\n}\n\nvector<int> scc(const vector<vector<int>> &g) {\n    const int N = g.size();\n    vector<vector<int>> rev(N);\n    for(int i = 0; i < N; ++i) {\n        for(int to : g[i]) {\n            rev[to].push_back(i);\n        }\n    }\n    vector<bool> visited(N, false);\n    vector<int> ord;\n    for(int i = 0; i < N; ++i) {\n        dfs1(i, g, visited, ord);\n    }\n    reverse(begin(ord), end(ord));\n    vector<int> label(N, -1);\n    int l = 0;\n    for(int pos : ord) {\n        if(label[pos] == -1) dfs2(pos, rev, l++, label);\n    }\n    return label;\n}\n\nbool solve() {\n    int N, M, T;\n    if(!(cin >> N >> M >> T)) return false;\n    if(!N && !M && !T) return false;\n\n    vector<Node> nodes(N);\n    for(int i = 0; i < N; ++i) {\n        cin >> nodes[i].p >> nodes[i].t >> nodes[i].k;\n    }\n    vector<vector<int>> g(N);\n    vector<bool> self_looped(N, false);\n    for(int i = 0; i < M; ++i) {\n        int a, b;\n        cin >> a >> b;\n        --a; --b;\n        g[a].push_back(b);\n        if(a == b) self_looped[a] = true;\n    }\n\n    vector<int> label = scc(g);\n    const int L = *max_element(begin(label), end(label)) + 1;\n    vector<vector<int>> nodes_of(L);\n    for(int i = 0; i < N; ++i) {\n        nodes_of[label[i]].push_back(i);\n    }\n\n    vector<vector<long long>> dp(L, vector<long long>(T+1, 0));\n    vector<unordered_set<int>> prev_of(L);\n    long long ans = 0;\n    for(int cur = 0; cur < L; ++cur) {\n        for(int t = 0; t <= T; ++t) {\n            for(int prev : prev_of[cur]) {\n                dp[cur][t] = max(dp[cur][t], dp[prev][t]);\n            }\n        }\n        for(int t = 1; t <= T; ++t) {\n            dp[cur][t] = max(dp[cur][t], dp[cur][t-1]);\n        }\n\n        if(nodes_of[cur].size() >= 2 || self_looped[nodes_of[cur][0]]) {\n            // Can take any numbers of advertisement\n            for(int n : nodes_of[cur]) {\n                int rem = nodes[n].k;\n                for(int ord = 1; rem > 0; ord *= 2) {\n                    const int k = min(ord, rem);\n                    rem -= k;\n                    for(int t = T; t >= 0; --t) {\n                        if(t-k*nodes[n].t >= 0) dp[cur][t] = max(dp[cur][t], dp[cur][t-k*nodes[n].t] + k * nodes[n].p);\n                    }\n                }\n            }\n        } else {\n            // Can take only one advertisement\n            for(int t = T; t >= 0; --t) {\n                for(int n : nodes_of[cur]) {\n                    if(t-nodes[n].t >= 0) dp[cur][t] = max(dp[cur][t], dp[cur][t-nodes[n].t] + nodes[n].p);\n                }\n            }\n        }\n        for(int n : nodes_of[cur]) {\n            for(int to : g[n]) {\n                prev_of[label[to]].insert(cur);\n            }\n        }\n        ans = max(ans, *max_element(begin(dp[cur]), end(dp[cur]))); \n    }\n    cout << ans << endl;\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntypedef vector<int> vi;\ntypedef pair<int,int> P;\nvi G[100];\nint ord[100],low[100],sid[100];\nbool inS[100];\nstack<int> S;\nint cnt;\nvector<vi> scc;\nint N,M,T;\nvoid vis(int v){\n\tord[v]=low[v]=++cnt;\n\tS.push(v);\n\tinS[v]=1;\n\tfor(int u:G[v]){\n\t\tif(ord[u]==0){\n\t\t\tvis(u);\n\t\t\tchmin(low[v],low[u]);\n\t\t}else if(inS[u]){\n\t\t\tchmin(low[v],ord[u]);\n\t\t}\n\t}\n\tif(low[v]==ord[v]){\n\t\tvi vc;\n\t\twhile(true){\n\t\t\tint w=S.top();S.pop();\n\t\t\tinS[w]=0;\n\t\t\tvc.pb(w);\n\t\t\tsid[w]=scc.size();\n\t\t\tif(v==w) break;\n\t\t}\n\t\tscc.pb(vc);\n\t}\n}\nvoid makescc(){\n\trep(i,N) if(ord[i]==0) vis(i);\n}\nint p[100],t[100],k[100];\nint deq[10001],deqv[10001];\nP es[1000];\nvector<int> nG[100];\t\t//y in nG[x] : x<-y\nint dp[100][10001];\nvoid init(){\n\trep(i,100) G[i].clear(),nG[i].clear(),ord[i]=0,low[i]=0,inS[i]=0;\n\trep(i,100) rep(j,10001) dp[i][j]=0;\n\twhile(!S.empty()) S.pop();\n\tcnt=0;\n\tscc.clear();\n}\nint main(){\n\twhile(true){\n\t\tcin>>N>>M>>T;\n\t\tif(N==0) break;\n\t\tinit();\n\t\trep(i,N) cin>>p[i]>>t[i]>>k[i];\n\t\trep(i,M){\n\t\t\tint a,b;\n\t\t\tcin>>a>>b;\n\t\t\ta--,b--;\n\t\t\tG[a].pb(b);\n\t\t\tes[i]=P(a,b);\n\t\t}\n\t\tmakescc();\n\t\tint K=scc.size();\n\t\t{\n\t\t\tbool ise[100][100]={};\n\t\t\trep(i,M) ise[ sid[es[i].fs] ][ sid[es[i].sc] ]=1;\n\t\t\trep(i,K) rep(j,K) if(ise[i][j]) nG[j].pb(i);\n\t\t}\n\t\tfor(int i=K-1;i>=0;i--){\n\t\t\tbool isol=1;\n\t\t\tfor(int j:nG[i]){\n\t\t\t\tif(j==i){\n\t\t\t\t\tisol=0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\trep(t,T+1) chmax(dp[i][t],dp[j][t]);\n\t\t\t}\n\t\t\tif(isol) k[scc[i][0]]=1;\n\t\t\tfor(int v:scc[i]){\n\t\t\t\trep(a,t[v]){\n\t\t\t\t\tint be=0,en=0;\n\t\t\t\t\tfor(int j=0;j*t[v]+a<=T;j++){\n\t\t\t\t\t\tint val=dp[i][j*t[v]+a]-j*p[v];\n\t\t\t\t\t\twhile(be<en&&deqv[en-1]<=val) en--;\n\t\t\t\t\t\tdeq[en]=j,deqv[en]=val;\n\t\t\t\t\t\ten++;\n\t\t\t\t\t\tdp[i][j*t[v]+a]=deqv[be]+j*p[v];\n\t\t\t\t\t\tif(deq[be]==j-k[v]) be++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=0;\n\t\trep(t,T+1) chmax(ans,dp[0][t]);\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\ntypedef vector<int> Node;\ntypedef vector<Node> Graph;\nGraph G, RG;\n\nvoid dfs(int u, vector<bool>& used, vector<int>& order) {\n    if(used[u]) return;\n    used[u] = true;\n    for(int v : G[u]) {\n        dfs(v, used, order);\n    }\n    order.push_back(u);\n}\n\nvoid rdfs(int u, int k, vector<bool>& used, vector<int>& node) {\n    if(used[u]) return;\n    used[u] = true;\n    node[u] = k;\n    for(int v : RG[u]) {\n        rdfs(v, k, used, node);\n    }\n}\n\nint main(){\n    int N, M, T;\n    while(cin >> N >> M >> T && N > 0) {\n        vector<int> p(N);\n        vector<int> t(N);\n        vector<int> r(N);\n        REP(i, N) cin >> p[i] >> t[i] >> r[i];\n\n        G.assign(N, Node());\n        RG.assign(N, Node());\n        bool d[100][100] = {};\n        REP(i, M) {\n            int a, b;\n            cin >> a >> b;\n            a--; b--;\n            G[a].push_back(b);\n            RG[b].push_back(a);\n            d[a][b] = true;\n        }\n\n        REP(k, N) REP(i, N) REP(j, N) if(d[i][k] && d[k][j]) d[i][j] = true;\n\n\n        vector<int> order;\n        vector<bool> used(N);\n        REP(i, N) dfs(i, used, order);\n        reverse(order.begin(), order.end());\n\n        vector<int> node(N);\n        used.assign(N, false);\n        int V = 0;\n        for(int v : order) if(!used[v]) rdfs(v, V++, used, node);\n\n        vector<set<int>> SG(V);\n        REP(i, N) for(int j : G[i]) if(node[i] != node[j]) {\n            SG[node[i]].insert(node[j]);\n        }\n\n        int dp[100][10001] = {};\n        REP(i, V) {\n            REP(v, N) if(node[v] == i) {\n                int b = 1;\n                int rest = (d[v][v] ? r[v] : 1);\n                while(rest > 0) {\n                    int use = min(rest, b);\n                    rest -= use;\n                    b *= 2;\n                    \n                    int get = p[v] * use;\n                    int cost = t[v] * use;\n\n                    for(int j = T - cost; j >= 0; j--) {\n                        dp[i][j + cost] = max(dp[i][j + cost], dp[i][j] + get);\n                    }\n                }\n            }\n\n            for(int j : SG[i]) {\n                for(int k = 0; k <= T; k++) {\n                    dp[j][k] = max(dp[j][k], dp[i][k]);\n                }\n            }\n        }\n\n        int ans = 0;\n        REP(i, V) REP(j, T + 1) ans = max(ans, dp[i][j]);\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing ll = long long;\nconstexpr ll INF = 1LL << 60;\nstruct Graph\n{\n    explicit Graph(const std::size_t v) : V{v}, edge(v), rev_edge(v) {}\n    void addEdge(const std::size_t from, const std::size_t to) { edge[from].push_back(to), rev_edge[to].push_back(from); }\n    const std::size_t V;\n    std::vector<std::vector<std::size_t>> edge;\n    std::vector<std::vector<std::size_t>> rev_edge;\n};\nstd::pair<bool, std::vector<std::size_t>> TopologicalSort(const Graph& g)\n{\n    std::vector<std::size_t> srt, used(g.V, 0);\n    auto dfs = [&](auto&& self, const std::size_t s) -> bool {\n        if (used[s] == 1) {\n            return false;\n        } else if (used[s] == 0) {\n            used[s] = 1;\n            for (const std::size_t to : g.edge[s]) {\n                if (not self(self, to)) { return false; }\n            }\n            used[s] = 2, srt.push_back(s);\n        }\n        return true;\n    };\n    for (std::size_t i = 0; i < g.V; i++) {\n        if (not dfs(dfs, i)) { return {false, srt}; }\n    }\n    std::reverse(srt.begin(), srt.end());\n    return {true, srt};\n}\n\nclass StronglyConnectedComponents\n{\npublic:\n    StronglyConnectedComponents(const Graph& g) : size(g.V), comp(size, size)\n    {\n        for (std::size_t i = 0; i < size; i++) {\n            for (const std::size_t to : g.edge[i]) { edge.push_back({i, to}); }\n        }\n        std::vector<std::size_t> st;\n        std::vector<bool> used(size, false);\n        auto dfs1 = [&](auto&& self, const std::size_t s) -> void {\n            used[s] = true;\n            for (const std::size_t to : g.edge[s]) {\n                if (not used[to]) { self(self, to); }\n            }\n            st.push_back(s);\n        };\n        auto dfs2 = [&](auto&& self, const std::size_t s) -> void {\n            comp[s] = comp_num;\n            for (const std::size_t to : g.rev_edge[s]) {\n                if (comp[to] != size) { continue; }\n                self(self, to);\n            }\n        };\n        for (std::size_t i = 0; i < size; i++) {\n            if (used[i]) { continue; }\n            dfs1(dfs1, i);\n        }\n        for (std::size_t i = 0; i < st.size(); i++) {\n            const std::size_t s = st[st.size() - i - 1];\n            if (comp[s] != size) { continue; }\n            dfs2(dfs2, s), comp_num++;\n        }\n    }\n    const std::vector<std::size_t>& getComp() const { return comp; }\n    std::size_t getCompNum() const { return comp_num; }\n    Graph toDAG() const\n    {\n        Graph dag(comp_num);\n        for (const auto& e : edge) {\n            const std::size_t u = comp[e.first], v = comp[e.second];\n            if (u != v) { dag.addEdge(u, v); }\n        }\n        return dag;\n    }\n\nprivate:\n    std::size_t size, comp_num = 0;\n    std::vector<std::size_t> comp;\n    std::vector<std::pair<std::size_t, std::size_t>> edge;\n};\nint main()\n{\n    for (int N, M, T;;) {\n        std::cin >> N >> M >> T;\n        if (N == 0 and M == 0 and T == 0) { break; }\n        Graph g(N);\n        std::vector<int> p(N), t(N), k(N);\n        for (int i = 0; i < N; i++) { std::cin >> p[i] >> t[i] >> k[i]; }\n        for (int i = 0, a, b; i < M; i++) { std::cin >> a >> b, a--, b--, g.addEdge(a, b); }\n        StronglyConnectedComponents scc(g);\n        const Graph dag = scc.toDAG();\n        const auto comp = scc.getComp();\n\n        const auto ord = TopologicalSort(dag).second;\n        const int C = scc.getCompNum();\n        std::vector<std::vector<int>> cp(C);\n        for (int i = 0; i < N; i++) { cp[comp[i]].push_back(i); }\n        std::vector<std::vector<ll>> dp(C, std::vector<ll>(T + 1, -INF));  //連結成分c内で時間tで最大利益\n        for (int i = 0; i < C; i++) { dp[i][0] = 0; }\n        for (int j = 0; j < C; j++) {\n            const int i = ord[j];\n            if (cp[i].size() == 1) {\n                bool cir = false;\n                for (const int to : g.edge[cp[i][0]]) {\n                    if (to == cp[i][0]) { cir = true; }\n                }\n                if (not cir) { k[cp[i][0]] = 1; }\n            }\n            std::vector<ll> v, w;\n            for (const int node : cp[i]) {\n                int K = k[node];\n                for (int sz = 1; K > 0; sz *= 2) {\n                    const int num = (K >= sz ? sz : K);\n                    K -= num;\n                    v.push_back(p[node] * num), w.push_back(t[node] * num);\n                }\n            }\n            const int S = v.size();\n            for (int j = 0; j < S; j++) {\n                for (int k = T - w[j]; k >= 0; k--) { dp[i][k + w[j]] = std::max(dp[i][k + w[j]], dp[i][k] + v[j]); }\n            }\n            for (const int to : dag.edge[i]) { dp[to] = dp[i]; }\n        }\n        ll ans = 0;\n        for (int i = 0; i < C; i++) {\n            for (int j = 0; j <= T; j++) { ans = std::max(ans, dp[i][j]); }\n        }\n        std::cout << ans << std::endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nimport sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\n\ndef scc(N, G, RG):\n    order = []\n    used = [0]*N\n    group = [None]*N\n    def dfs(s):\n        used[s] = 1\n        for t in G[s]:\n            if not used[t]:\n                dfs(t)\n        order.append(s)\n    def rdfs(s, col):\n        group[s] = col\n        used[s] = 1\n        for t in RG[s]:\n            if not used[t]:\n                rdfs(t, col)\n    for i in range(N):\n        if not used[i]:\n            dfs(i)\n    used = [0]*N\n    label = 0\n    for s in reversed(order):\n        if not used[s]:\n            rdfs(s, label)\n            label += 1\n    return label, group\n\ndef construct(N, G, label, group):\n    G0 = [set() for i in range(label)]\n    RG0 = [set() for i in range(label)]\n    GP = [[] for i in range(label)]\n    for v in range(N):\n        lbs = group[v]\n        for w in G[v]:\n            lbt = group[w]\n            if lbs == lbt:\n                continue\n            G0[lbs].add(lbt)\n            RG0[lbt].add(lbs)\n        GP[lbs].append(v)\n    return G0, RG0, GP\n\ndef solve():\n    N, M, T = map(int, readline().split())\n    if N == M == T == 0:\n        return False\n    V = [0]*N; W = [0]*N; C = [0]*N\n    for i in range(N):\n        V[i], W[i], C[i] = map(int, readline().split())\n    G = [[] for i in range(N)]\n    RG = [[] for i in range(N)]\n    SL = [0]*N\n    for i in range(M):\n        a, b = map(int, readline().split())\n        if a == b:\n            SL[a-1] = 1\n        else:\n            G[a-1].append(b-1)\n            RG[b-1].append(a-1)\n    label, group = scc(N, G, RG)\n    G0, RG0, GP = construct(N, G, label, group)\n\n    INF = 10**18\n    dp = [None]*label\n    zeros = [0] + [-INF]*T\n\n    que = deque()\n    deg = [0]*label\n    for i in range(label):\n        if len(RG0[i]) == 0:\n            que.append(i)\n            dp[i] = zeros[:]\n        deg[i] = len(RG0[i])\n\n    ans = 0\n    dp1 = [0]*(T+1)\n    while que:\n        v = que.popleft()\n        dp0 = dp[v]\n        if len(GP[v]) == 1 and not SL[GP[v][0]]:\n            e, = GP[v]\n            ve = V[e]; we = W[e]\n            for i in range(T, we-1, -1):\n                dp0[i] = max(dp0[i], dp0[i-we] + ve)\n        else:\n            deq = deque()\n            push = deq.append\n            popl = deq.popleft\n            pop = deq.pop\n            clear = deq.clear\n            for e in GP[v]:\n                ve = V[e]; we = W[e]; ce = C[e]\n                if T < we:\n                    continue\n                if ce == 1:\n                    for i in range(T, we-1, -1):\n                        dp0[i] = max(dp0[i], dp0[i-we] + ve)\n                elif T <= we*ce:\n                    for i in range(we, T+1):\n                        dp0[i] = max(dp0[i], dp0[i-we] + ve)\n                else:\n                    for k in range(we):\n                        for i in range((T - k) // we + 1):\n                            v0 = dp0[k] - i*ve\n                            while deq and deq[-1][1] <= v0:\n                                pop()\n                            push((i, v0))\n\n                            dp0[k] = deq[0][1] + i*ve\n\n                            if deq[0][0] == i-ce:\n                                popl()\n                            k += we\n                        clear()\n        ans = max(ans, max(dp0))\n\n        for w in G0[v]:\n            deg[w] -= 1\n            if deg[w] == 0:\n                que.append(w)\n            if dp[w] is None:\n                dp[w] = dp0[:]\n            else:\n                dp[w][:] = (max(p, q) for p, q in zip(dp[w], dp0))\n    write(\"%d\\n\" % ans)\n    return True\nwhile solve():\n    ...\n"
  }
]