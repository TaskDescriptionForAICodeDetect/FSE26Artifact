[
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define all(x)  x.begin(), x.end()\n#define mp      make_pair\n\nvector<int> g[2020];\nint used[2020];\nvector<int> a;\nvector<int> tmp;\n\nvoid dfs(int v) {\n        used[v] = true;\n        tmp.push_back(a[v]);\n        //vector<pair<int, int>> p;\n        //for (auto u : g[v]) if (u != prev) p.emplace_back(a[u], u);\n        //sort(all(p));\n        //for (auto u : p) {\n        //        if (!used[u.second]) {\n        //                dfs(u.second, v);\n        //        }\n        //}\n        for (auto u : g[v]) if (!used[u]) {\n                dfs(u);\n        }\n}\n\nint main() {\n        int n;\n        scanf(\"%d\", &n);\n        a.resize(n);\n        for (int i = 0; i < n; i ++) scanf(\"%d\", &a[i]);\n\n        //Takahashi\n        for (int i = 0; i < n; i ++) {\n                for (int j = i + 1; j < n; j ++) {\n                        if (__gcd(a[i], a[j]) != 1) {\n                                g[i].push_back(j);\n                                g[j].push_back(i);\n                        }\n                }\n        }\n        sort(all(a));\n        for (int i = 0; i < n; i ++) {\n                if (!used[i]) {\n                        dfs(i);\n                }\n        }\n\n        for (int i = 0; i < n; i ++) {\n                int j = i;\n                for (int k = i - 1; k >= 0 && __gcd(tmp[k], tmp[i]) == 1; k --) {\n                        if (tmp[k] < tmp[i]) j = k;\n                }\n                rotate(tmp.begin() + j, tmp.begin() + i, tmp.begin() + i + 1);\n            }\n        //Aoki\n        for (int i = 0; i < n; i ++) g[i].clear();\n        for (int i = 0; i < n; i ++) {\n                for (int j = i + 1; j < n; j ++) {\n                        if (__gcd(tmp[i], tmp[j]) != 1) {\n                                g[i].push_back(j);\n                        }\n                }\n        }\n        //vector<int> in_cnt(n, 0);\n        //for (int i = 0; i < n; i ++) {\n        //        for (auto u : g[i]) {\n        //                in_cnt[u] ++;\n        //        }\n        //}\n        //priority_queue<pair<int, int>> pq;\n        //for (int i = 0; i < n; i ++) if (in_cnt[i] == 0) pq.push(mp(tmp[i], i));\n        //vector<int> ans;\n        //while (!pq.empty()) {\n        //        auto get = pq.top();\n        //        pq.pop();\n        //        ans.push_back(get.first);\n        //        for (auto u : g[get.second]) {\n        //                in_cnt[u] --;\n        //                if (in_cnt[u] == 0) pq.push(mp(tmp[u], u));\n        //        }\n        //}\n        for (int i = 0; i < n; i ++) cout << tmp[i] << (i == n - 1 ? '\\n' : ' ');\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n,a[2005],V;\nvector<int>edge[2005];\nbool used[2005][2005];\nbool in[2005];\nvector<int>nxt;\nP q;\nvoid dfs(int v){\n\tif(used[V][v]) return; used[V][v] = 1;\n\tnxt.pb(v);\n\trep(i,edge[v].size()){\n\t\tif(used[V][edge[v][i]] || in[edge[v][i]] != V) continue;\n\t\tdfs(edge[v][i]);\n\t}\n}\nvector<int>make(vector<int>L,int cut){\n\tvector<int>ret;\n\tif(L.size() == 1){\n\t\tret.pb(cut); return ret;\n\t}\n\trep(i,L.size()){\n\t\tin[L[i]] = cut;\n\t}\n\trep(i,L.size()){\n\t\tif(L[i] == cut) continue;\n\t\tif(!used[cut][L[i]]){\n\t\t\tnxt.clear(); q = mp(INF,INF);\n\t\t\tV = cut; dfs(L[i]);\n\t\t\trep(j,nxt.size()){\n\t\t\t\tif(__gcd(a[nxt[j]],a[cut]) > 1){\n\t\t\t\t\tq = min(q,mp(a[nxt[j]],nxt[j]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tvector<int>hoge = make(nxt,q.sc);\n\t\t\tvector<int>ret2;\n\t\t\tint c = ret.size(),b = hoge.size();\n\t\t\tint i = 0,j = 0;\n\t\t\twhile(i!=c || j!=b){\n\t\t\t\tif(i==c) ret2.pb(hoge[j++]);\n\t\t\t\telse if(j==b) ret2.pb(ret[i++]);\n\t\t\t\telse{\n\t\t\t\t\tif(a[ret[i]] > a[hoge[j]]) ret2.pb(ret[i++]);\n\t\t\t\t\telse ret2.pb(hoge[j++]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tret = ret2;\n\t\t}\n\t}\n\treverse(ret.begin(),ret.end());\n\tret.pb(cut);\n\treverse(ret.begin(),ret.end());\n\treturn ret;\n}\nbool U[2005];\nvector<int>vi;\nP p;\nvoid DFS(int x){\n\tif(U[x]) return; U[x] = 1;\n\tvi.pb(x); p = min(p,mp(a[x],x));\n\trep(i,edge[x].size()){\n\t\tDFS(edge[x][i]);\n\t}\n}\nvector<int>res;\nint main(){\n\tcin>>n;\n\trepn(i,n){\n\t\tcin>>a[i];\n\t}\n\trepn(i,n) repn(j,n){\n\t\tif(i != j && __gcd(a[i],a[j]) > 1){\n\t\t\tedge[i].pb(j);\n\t\t}\n\t}\n\trepn(i,n){\n\t\tif(U[i]) continue; p = mp(INF,INF); vi.clear();\n\t\tDFS(i);\n\t\tvector<int>vec = make(vi,p.sc);\n\t\tvector<int>res2;\n\t\tint c = 0,b = 0;\n\t\twhile(c != res.size() || b != vec.size()){\n\t\t\tif(c == res.size()) res2.pb(vec[b++]);\n\t\t\telse if(b == vec.size()) res2.pb(res[c++]);\n\t\t\telse{\n\t\t\t\tif(a[res[c]] > a[vec[b]]) res2.pb(res[c++]);\n\t\t\t\telse res2.pb(vec[b++]);\n\t\t\t}\n\t\t}\n\t\tres = res2;\n\t}\n\trep(i,n) cout<<a[res[i]]<<\" \";\n\tcout<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <vector>\n#include <map>\n#include <set>\n\nusing namespace std;\n\ntypedef pair<int , int> P2;\ntypedef pair<pair<int , int> , int> P3;\ntypedef pair<pair<int , int> , pair<int , int> > P4;\n#define Fst first\n#define Snd second\n#define PB(a) push_back(a)\n#define MP(a , b) make_pair((a) , (b))\n#define M3P(a , b , c) make_pair(make_pair((a) , (b)) , (c))\n#define M4P(a , b , c , d) make_pair(make_pair((a) , (b)) , make_pair((c) , (d)))\n#define repp(i,a,b) for(int i = (int)(a) ; i < (int)(b) ; ++i)\n#define repm(i,a,b) for(int i = (int)(a) ; i > (int)(b) ; --i)\n#define repv(t,it,v) for(vector<t>::iterator it = v.begin() ; it != v.end() ; ++it)\n\nint N;\nint A[2017];\nbool e[2017][2017];\nbool b[2017];\n\nint gcd(int x , int y){\n\treturn y > 0 ? gcd(y,x%y) : x;\n}\n\nvector<int> mer(const vector<int> &S , const vector<int> &T){\n\tvector<int> V;\n\tint i = 0 , j = 0;\n\twhile(i != (int)S.size() || j != (int)T.size()){\n\t\tif(i == (int)S.size()) V.PB(T[j++]);\n\t\telse if(j == (int)T.size()) V.PB(S[i++]);\n\t\telse V.PB(A[S[i]] > A[T[j]] ? S[i++] : T[j++]);\n\t}\n\treturn V;\n}\n\nvector<int> func(int k){\n\tvector<int> V;\n\tb[k] = 1;\n\trepp(i,0,N){\n\t\tif(!e[k][i] || b[i]) continue;\n\t\tV = mer(V,func(i));\n\t}\n\tV.insert(V.begin(),k);\n\treturn V;\n}\n\nint main(){\n\tscanf(\"%d\" , &N);\n\trepp(i,0,N){\n\t\tscanf(\"%d\" , A + i);\n\t}\n\tsort(A,A+N);\n\trepp(i,0,N){\n\t\trepp(j,i+1,N){\n\t\t\tif(gcd(A[i],A[j]) > 1){\n\t\t\t\te[i][j] = e[j][i] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tvector<int> V;\n\trepp(i,0,N){\n\t\tif(b[i]) continue;\n\t\tV = mer(V,func(i));\n\t}\n\trepp(i,0,N){\n\t\tprintf(\"%d%c\" , A[V[i]] , i+1==N ? '\\n' : ' ');\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(2)\n// Happy TLE and WA every day!\n// by: zxb the vegetable chicken\n#include<bits/stdc++.h>\n#define mp\t\t\t\tmake_pair\n#define rep(i,n)\t\tfor(int i = 0; i < n; i++)\n#define foreach(i,c)\tfor(VAR(i, (c).begin()); i != (c).end(); ++i)\n#define BINF\t\t\t0x7fffffff\n#define INF\t\t\t\t0x3f3f3f3f\n#define LINF\t\t\t3223372036854775807\n#define END(s)\t\t\t{cout<<s; return 0;}\n#define CON(s)\t\t\t{cout<<s; continue;}\n#define BRE(s)\t\t\t{cout<<s; break;}\n#define pb\t\t\t\tpush_back\n//#define int\t\t\t\tlong long\n#define All(a)\t\t\ta.begin(), a.end()  //with A in CAPITAL!!!\n#define sz(a)\t\t\t(int)a.size()\n#define F\t\t\t\tfirst\n#define S\t\t\t\tsecond\n//#define usingFiles\nusing namespace std;\n\nconst int rp = 666666;\nconst bool debug = 1;\nconst bool I_good_vegetable_a = 1;\n\nint a[2020];\nint n;\nvector<int> v[2020];\nint ltksize;\nint mnstart;\nbool used[2020];\nvector<int> ltk[2020];\nvector<pair<int, int> > ans;\nint cnt = 0;\nint num = 0;\n\nint count(int now){\n\tif(a[now] < a[mnstart]) mnstart = now;\n\tint ans = 1;\n\tused[now] = true;\n\trep(i, v[now].size()){\n\t\tif(!used[v[now][i]]) ans += count(v[now][i]);\n\t}\n\treturn ans;\n}\n\nvoid uncount(int now){\n\tused[now] = false;\n\trep(i, v[now].size()){\n\t\tif(used[v[now][i]]) uncount(v[now][i]);\n\t}\n}\n\nbool dfs(int now){\n\tused[now] = true;\n\tnum++;\n\tif(num == ltksize){\n\t\tltk[cnt].pb(now);\n\t\treturn 1;\n\t}\n\trep(i, v[now].size()){\n\t\tif(used[v[now][i]]) continue;\n\t\tif(dfs(v[now][i])){\n\t\t\tltk[cnt].pb(now);\n\t\t\treturn 1;\n\t\t}\n\t}\n\tused[now] = false;\n\treturn 0;\n}\n\nbool cmp1(int x, int y){\n\treturn a[x] < a[y];\n}\n\nbool cmp(pair<int, int> x, pair<int, int> y){\n\treturn x > y;\n}\n\nsigned main(){\n\tios::sync_with_stdio(false);\n\t#ifdef usingFiles\n\t\tfreopen(\"input.txt\", \"r\", stdin);\n\t\tfreopen(\"output.txt\", \"w\", stdout);\n\t#endif\n\tcin >> n;\n\trep(i, n) cin >> a[i];\n\trep(i, n){\n\t\tfor(int j = 0; j < i; j++){\n\t\t\tif(__gcd(a[i], a[j]) > 1){\n\t\t\t\tv[i].pb(j);\n\t\t\t\tv[j].pb(i);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, n){\n\t\tsort(v[i].begin(), v[i].end(), cmp1);\n\t}\n\trep(i, n){\n\t\tif(!used[i]){\n\t\t\tmnstart = i; \n\t\t\tltksize = count(i);\n\t\t\tuncount(i);\n\t\t\tnum = 0;\n\t\t\tdfs(mnstart);\n\t\t\treverse(ltk[cnt].begin(), ltk[cnt].end());\n\t\t\tans.pb(mp(a[ltk[cnt][0]], cnt));\n\t\t\tcnt++;\n\t\t}\n\t}\n\tsort(ans.begin(), ans.end(), cmp);\n\trep(i, ans.size()){\n\t\trep(j, ltk[ans[i].S].size()){\n\t\t\tcout << a[ltk[ans[i].S][j]] << \" \"; \n\t\t}\n\t}\n\tcout << endl;\n\treturn 0;\n}\n/*\n5\n1 2 3 4 5\n*/"
  },
  {
    "language": "C++",
    "code": "// Ho-kago Tea Time\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define fst first\n#define snd second\n#define SZ(u) ((int) (u).size())\n#define ALL(u) (u).begin(), (u).end()\n\ninline void proc_status()\n{\n\tifstream t(\"/proc/self/status\");\n\tcerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>()) << endl;\n}\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntemplate<typename T> inline T read()\n{\n\tregister T sum(0), fg(1);\n\tregister char ch(getchar());\n\tfor(; !isdigit(ch); ch = getchar()) if(ch == '-') fg = -1;\n\tfor(;  isdigit(ch); ch = getchar()) sum = sum * 10 - '0' + ch;\n\treturn sum * fg;\n}\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\nconst int MAXN = (int) 2e3;\n\nint n;\n\nint a[MAXN + 5];\n\ninline void input()\n{\n\tn = read<int>();\n\tfor(int i = 1; i <= n; ++i) a[i] = read<int>();\n}\n\nvector<int> adj[MAXN + 5];\n\nint vis[MAXN + 5];\nvector<int> s[MAXN + 5];\nint N = 0;\n\ninline void BFS(int S, int t)\n{\n\tstatic priority_queue<pii, vector<pii>, greater<pii> > q;\n\n\tvis[S] = 1, q.emplace(a[S], S);\n\twhile(!q.empty())\n\t{\n\t\tint u = q.top().snd;\n\t\tq.pop();\n\n\t\ts[t].push_back(a[u]);\n\t\tfor(auto v : adj[u]) if(!vis[v]) vis[v] = 1, q.emplace(a[v], v);\n\t}\n\treverse(ALL(s[t]));\n}\n\ninline void solve()\n{\n\tfor(int i = 1; i <= n; ++i)\n\t\tfor(int j = i + 1; j <= n; ++j) if(__gcd(a[i], a[j]) > 1)\n\t\t{\n\t\t\tadj[i].push_back(j);\n\t\t\tadj[j].push_back(i);\n\t\t}\n\n\tstatic int id[MAXN + 5];\n\tfor(int i = 1; i <= n; ++i) id[i] = i;\n\tsort(id + 1, id + n + 1, [&](int x, int y) { return a[x] < a[y]; });\n\n\tfor(int i = 1; i <= n; ++i) if(!vis[i]) BFS(i, ++N);\n\n\tfor(int i = 1; i <= n; ++i)\n\t{\n\t\tint t = 0;\n\t\tfor(int j = 1; j <= N; ++j) if(!s[j].empty() && (!t || s[j].back() > s[t].back())) t = j;\n\t\tprintf(\"%d \", s[t].back());\n\t\ts[t].pop_back();\n\t}\n\tputs(\"\");\n}\n\nint main()\n{\n#ifdef K_ON // K-ON!\n\tfreopen(\"E.in\", \"r\", stdin);\n\tfreopen(\"E.out\", \"w\", stdout);\n#endif\n\n\tinput();\n\tsolve();\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// Written By NewbieChd\n#include <cstdio>\n#include <cctype>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\nconst int BUF = 1000000;\nchar buf[BUF], *p1, *p2;\ninline char getChar() { return p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, BUF, stdin), p1 == p2) ? EOF : *p1++; }\ninline int read() {\n    int f = 0;\n    char c;\n    while (!isdigit(c = getChar())) {}\n    do\n        f = f * 10 + (c ^ 48);\n    while (isdigit(c = getChar()));\n    return f;\n}\n\nconst int maxN = 2003;\nint n, a[maxN];\nbool f[maxN][maxN];\ninline int gcd(int x, int y) { return y ? gcd(y, x % y) : x; }\n\nbool vis[maxN];\nint deg[maxN];\nvector<int> g[maxN];\nvoid dfs(int x) {\n    vis[x] = 1;\n    for (int y = 1; y <= n; ++y)\n        if (f[x][y] && !vis[y])\n            g[x].push_back(y), ++deg[y], dfs(y);\n}\n\npriority_queue<int> que;\n\nint main() {\n    int i, x;\n    n = read();\n    for (i = 1; i <= n; ++i)\n        a[i] = read();\n    sort(a + 1, a + n + 1);\n    for (i = 1; i <= n; ++i)\n        for (x = i + 1; x <= n; ++x)\n            f[i][x] = f[x][i] = gcd(a[i], a[x]) > 1;\n    \n    for (i = 1; i <= n; ++i)\n        if (!vis[i])\n            dfs(i);\n    for (i = 1; i <= n; ++i)\n        if (!deg[i])\n            que.push(i);\n    while (!que.empty()) {\n        x = que.top(), que.pop();\n        printf(\"%d \", a[x]);\n        for (auto y : g[x])\n            if (--deg[y] == 0)\n                que.push(y);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef vector<int> vi;\n\n#define f first\n#define s second\n#define all(x) (x).begin(), (x).end()\n#define pb push_back\n#define mp make_pair\n#define forn(i, n) for(register int i=0; i<n; i++)\n#define Forn(i, n) for(register int i=1; i<=n; i++)\n#define foreach(it, a) for(__typeof((a).begin()) it=(a).begin(); it!=(a).end(); it++)\n#define Foreach(it, a) for(__typeof((a).rbegin()) it=(a).rbegin(); it!=(a).rend(); it++)\n\ninline int in()\n{\n    char c=getchar();\n    int neg=1, x=0;\n    while(!isdigit(c)) (c=='-')?neg=-1, c=getchar():c=getchar();\n    while(isdigit(c)) x=(x<<3)+(x<<1)+(c^48), c=getchar();\n    return neg*x;\n}\n\nconst int MAX=2005;\n\nbool vis[MAX], con[MAX][MAX];\nint N, a[MAX];\nvi tmp;\nvector<vi> ret;\n\ninline void dfs(int x)\n{\n//    cout<<x<<\" \"<<a[x]<<endl;\n    vis[x]=true;\n    forn(i, N)\n        if(!vis[i]&&con[x][i])\n        {\n            dfs(i);\n            break;\n        }\n    tmp.pb(a[x]);\n}\n\nint main()\n{\n    N=in();\n    forn(i, N)\n        a[i]=in();\n    sort(a, a+N);\n    forn(i, N) forn(j, N)\n        con[i][j]=(__gcd(a[i], a[j])!=1);\n    \n//    cout<<\"st\"<<endl;\n    forn(i, N)\n        if(!vis[i])\n        {\n            tmp.clear();\n            dfs(i);\n            ret.pb(tmp);\n        }\n    \n    Foreach(i, ret)\n        Foreach(it, *i)\n            printf(\"%d \", *it);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\n#define INF 1e9\n#define LINF 1e18\n#define ld double\n#define ll long long\n#define ull unsigned long long\n\ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1, c = getchar();\n\tfor (;!isdigit(c);c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c);c = getchar()) x = (x<<3) + (x<<1) + (c^48);\n\tx *= f;\n}\n\nconst int N = 2005;\nint n, a[N], g[N][N], used[N], canuse[N], vis[N], que[N];\n\nint bfs(int s) {\n\tmemcpy(vis, used, sizeof vis);\n\tint mn = n;\n\tint l = 0, r = 0;\n\tque[r ++] = s;\n\twhile (l < r) {\n\t\tint u = que[l ++];\n\t\tif (canuse[u] && u < mn) mn = u;\n\t\tvis[u >> 6] |= 1 << (u & 63);\n\t\tfor (int i = 0; (i << 6) < n; ++ i) {\n\t\t\tif (g[u][i] & vis[i]) {\n\t\t\t\tfor (int j = i << 6; j < ((i + 1) << 6); ++ j) {\n\t\t\t\t\tif (g[u][i] & 1 << (j & 63)) {\n\t\t\t\t\t\tif (!(vis[j >> 6] & 1 << (j & 63))) {\n\t\t\t\t\t\t\tque[r ++] = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn mn;\n}\n\nvoid print() {\n\tint mx = 0;\n\tfor (int i = 0; i < n; ++ i) if (!(used[i >> 6] & 1 << (i & 63))) mx = max(mx, bfs(i));\n\tprintf(\"%d\", a[mx]);\n\tfor (int i = 0; i < n; ++ i) if (g[mx][i >> 6] & 1 << (i & 63)) canuse[i] = 1; else if (a[i] > a[mx]) canuse[i] = 0;\n\tused[mx >> 6] |= 1 << (mx & 63);\n}\n\nint main() {\n\tread(n);\n\tfor (int i = 0; i < n; ++ i) read(a[i]);\n\tsort(a, a + n);\n\tfor (int i = 0; i < n; ++ i) for (int j = 0; j < n; ++ j) if (__gcd(a[i], a[j]) != 1) g[i][j >> 6] |= 1 << (j & 63);\n\tfor (int i = 0; i < n; ++ i) canuse[i] = 1;\n\tfor (int i = 0; i < n; ++ i) print(), putchar(\" \\n\"[i + 1 == n]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<cmath>\n#include<queue>\n#include<bitset>\n#include<string>\n#include<cstdio>\n#include<cctype>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n#include<sstream>\n#include<numeric>\n#include<iostream>\n#include<algorithm>\n#include<functional>\n\n#define For(i,x,y) for (int i=x;i<y;i++)\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\n\ntypedef long long ll;\ntypedef double db;\ntypedef vector<int> Vi;\ntypedef pair<int,int> pii;\n\nint IN(){\n\tint c,f,x;\n\twhile (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');\n\twhile (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;\n}\n\nconst int N=200000+19;\nconst int oo=(1<<30)-1;\n\nstruct Edge{\n\tint y,nxt;\n} E[N];\nmap<int,int> M;\nmultiset<int> S;\nint A[N],las[N],col[N],chk[N],mn[N],pre[N],suf[N],res[N],f[N],g[N];\nint n,x,tot,cnt,c,mx;\nVi V[N];\n\nvoid Link(int x,int y){\n\tE[cnt]=(Edge){y,las[x]};las[x]=cnt++;\n\tE[cnt]=(Edge){x,las[y]};las[y]=cnt++;\n}\nvoid Init(int n){\n\tint m=n;\n\tif (V[m].size()) return;\n\tfor (int i=2;i*i<=n;i++)\n\t\tif (n%i==0){\n\t\t\tV[m].pb(i);\n\t\t\twhile (n%i==0) n/=i;\n\t\t}\n\tif (n>1) V[m].pb(n);\n}\nvoid Renew(int x){\n\tif (!M.count(x)) M[x]=++tot;\n}\nvoid dfs(int x,int c){\n\tif (col[x]) return;\n\tcol[x]=c;\n\tif (x<=*A) mn[c]=min(mn[c],A[x]);\n\tfor (int i=las[x];~i;i=E[i].nxt) dfs(E[i].y,c);\n}\nint work(int val){\n\tM.clear();\n\tFor(i,1,tot+1){\n\t\tlas[i]=-1;\n\t\tcol[i]=0;\n\t}\n\ttot=*A;cnt=0;c=0;\n\tFor(i,1,*A+1){\n\t\tint tmp=A[i];\n\t\tfor (int x=2;x*x<=tmp;x++)\n\t\t\tif (tmp%x==0){\n\t\t\t\tRenew(x);\n\t\t\t\tLink(i,M[x]);\n\t\t\t\twhile (tmp%x==0) tmp/=x;\n\t\t\t}\n\t\tif (tmp>1){\n\t\t\tRenew(tmp);\n\t\t\tLink(i,M[tmp]);\n\t\t}\n\t}\n\tFor(i,1,tot+1)\n\t\tif (!col[i]){\n\t\t\tmn[++c]=oo;\n\t\t\tdfs(i,c);\n\t\t}\n\tpre[0]=suf[c+1]=0;\n\tfor (int i=1;i<=c;i++) pre[i]=max(pre[i-1],mn[i]);\n\tfor (int i=c;i>=1;i--) suf[i]=max(suf[i+1],mn[i]);\n\tFor(i,1,*A+1){\n\t\tif (A[i]>max(pre[col[i]-1],suf[col[i]+1])){\n\t\t\tint pos=0;\n\t\t\tfor (int j:V[A[i]]) pos=max(pos,f[j]);\n\t\t\tif (A[i]<g[pos+1]) return A[i];\n\t\t}\n\t}\n\tassert(0);\n}\n\nint main(){\n\tmemset(las,-1,sizeof(las));\n\tn=IN();\n\tFor(i,1,n+1){\n\t\tx=IN();\n\t\tInit(x);\n\t\tS.insert(x);\n\t}\n\tx=oo;\n\tg[1]=oo;\n\tFor(t,1,n+1){\n\t\t*A=0;\n\t\tfor (int i:S) A[++*A]=i;\n\t\tx=work(x);\n\t\tS.erase(S.find(x));\n\t\tres[t]=x;\n\t\tfor (int i:V[x]) f[i]=max(f[i],t);\n\t\tg[t+1]=oo;\n\t\tfor (int i=t;~i;i--) g[i]=min(g[i+1],res[i]);\n\t}\n\tFor(i,1,n+1) printf(\"%d \",res[i]);\n\tputs(\"\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define re register\n#define ll long long\ninline int gi(){\n\tint f=1,sum=0;char ch=getchar();\n\twhile(ch>'9' || ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0' && ch<='9'){sum=(sum<<3)+(sum<<1)+ch-'0';ch=getchar();}\n\treturn f*sum;\n}\nconst int N=2010;\nint a[N],link[N][N],vis[N],d[N],n;\nvector<int>G[N];\nvoid dfs(int u){\n\tvis[u]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tif(link[u][i] && !vis[i]){\n\t\t\td[i]++;\n\t\t\tG[u].push_back(i);\n\t\t\tdfs(i);\n\t\t}\n}\npriority_queue<int>Q;\nint main(){\n\tn=gi();for(int i=1;i<=n;i++)a[i]=gi();\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<n;i++)\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\tif(__gcd(a[i],a[j])!=1)link[i][j]=link[j][i]=1;\n\tfor(int i=1;i<=n;i++)if(!vis[i])dfs(i);\n\tfor(int i=1;i<=n;i++)if(!d[i])Q.push(i);\n\twhile(!Q.empty()){\n\t\tint u=Q.top();Q.pop();\n\t\tprintf(\"%d \",a[u]);\n\t\tfor(auto v:G[u])Q.push(v);\n\t}\n\tputs(\"\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define per(i,b,a) for(int i=b;i>=a;i--)\n#define For(i,a,b) for(int i=a;i<=b;i++)\n#define Forenska(it,c) for(register __typeof(c.begin()) it=c.begin();it!=c.end();it++)\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\n#define all(x) x.begin(),x.end()\n#define sqr(x) ((x)*(x))\n#define lowbit(x) ((x)&(-x))\n#define GREATER(x) x,vector<x>,greater<x>\nusing namespace std;\nint i,j;\ntypedef long long LL;\ntypedef pair<int,int> pii;\ntypedef pair<LL,LL> pLL;\ntypedef vector<int> vec;\ntypedef vector<LL> vecL;\ntypedef vector<pii> vecP;\ntypedef vector<pLL> vecPL;\ntypedef vector<string> vecS;\ntypedef vector<vec> mat;\ntypedef complex<double> point;\nconst long double PI=3.1415926535897932384626433832795028841971693993751058209749445923078164062862089;\nconst LL INFLL=0x3f3f3f3f3f3f3f3f;\nconst int INF=0x3f3f3f3f;\nconst long double EPS=1e-10;\nint read()\n{\n\tint x=0;\n\tchar ch=' ';\n\tbool flag=false;\n\twhile(!isdigit(ch))\n\t{\n\t\tif(ch=='-')flag=true;\n\t\tch=getchar();\n\t}\n\twhile(isdigit(ch))\n\t{\n\t\tx=(x<<3)+(x<<1)+ch-'0';\n\t\tch=getchar();\n\t}\n\treturn flag?-x:x;\n}\nint n;\nvec A;\nmat g1,g2;\nconst int MAX_N=2005;\nbool vis[MAX_N];\nint in[MAX_N];\nvoid dfs(int v)\n{\n\tif(vis[v])return;\n\tvis[v]=true;\n\trep(i,0,g1[v].size())\n\t{\n\t\tint to=g1[v][i];\n\t\tif(!vis[to])\n\t\t{\n\t\t\tg2[v].pb(to);\n\t\t\tin[to]++;\n\t\t\tdfs(to);\n\t\t}\n\t}\n}\nint main()\n{\n\tn=read();\n\tA.resize(n);\n\trep(i,0,n)A[i]=read();\n\tsort(all(A));\n\tA.resize(unique(all(A))-A.begin());\n\tn=A.size();\n\tg1.resize(n);\n\tg2.resize(n);\n\trep(i,0,n)\n\t{\n\t\trep(j,i+1,n)\n\t\t{\n\t\t\tif(__gcd(A[i],A[j])>1)\n\t\t\t{\n\t\t\t\tg1[i].pb(j);\n\t\t\t\tg1[j].pb(i);\n\t\t\t}\n\t\t}\n\t}\n\trep(i,0,n)\n\t{\n\t\tdfs(i);\n\t}\n\tpriority_queue <int> q;\n\tvec ans;\n//\trep(i,0,n)cout<<in[i]<<endl;\n\tper(i,n-1,0)if(!in[i])q.push(i),ans.pb(i);\n\twhile(!q.empty())\n\t{\n\t\tint t=q.top();\n\t\tq.pop();\n\t\trep(i,0,g2[t].size())\n\t\t{\n\t\t\tint to=g2[t][i];\n\t\t\tin[to]--;\n\t\t\tif(!in[to])\n\t\t\t{\n\t\t\t\tq.push(to);\n\t\t\t\tans.pb(to);\n\t\t\t}\n\t\t}\n\t}\n\trep(i,0,ans.size())ans[i]=A[ans[i]];\n\trep(i,0,ans.size())\n\t{\n\t\trep(j,0,ans.size()-1)\n\t\t{\n\t\t\tif(ans[j]<ans[j+1] && __gcd(ans[j],ans[j+1])==1)swap(ans[j],ans[j+1]);\n\t\t}\n\t}\n\trep(i,0,ans.size()-1)cout<<ans[i]<<\" \";\n\tcout<<ans.back()<<endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\ncat <<EOF >mistaken-paste\n*/\n\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <time.h>\n\n#define BIG 2000000007\n#define VERYBIG 2000000000000007LL\n\n#define MOD 1000000007\n#define FOD  998244353\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\n#define N_MAX 1000000\n#define M_MAX 200000\n\n#ifdef __cplusplus\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <array>\n\nusing std::queue;\nusing std::priority_queue;\nusing std::stack;\nusing std::tuple;\nusing std::set;\nusing std::map;\nusing std::vector;\nusing std::greater;\nusing std::pair;\nusing std::string;\n\n#endif\n\ntypedef struct {\n\tint32_t a;\n\tint32_t b;\n} hw;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n} hwll;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n\tsll c;\n} hwllc;\n\ntypedef struct {\n\thwll a;\n\thwll b;\n} linell;\n\null n, m;\null h, w;\null k;\null q;\nsll va, vb, vc, vd, ve, vf;\null ua, ub, uc, ud, ue, uf;\nlong double vra, vrb, vrc;\ndouble vda, vdb, vdc;\nchar ch, dh;\n\null umin (ull x, ull y) {\n\treturn (x < y) ? x : y;\n}\n\null umax (ull x, ull y) {\n\treturn (x > y) ? x : y;\n}\n\nsll smin (sll x, sll y) {\n\treturn (x < y) ? x : y;\n}\n\nsll smax (sll x, sll y) {\n\treturn (x > y) ? x : y;\n}\n\null gcd (ull x, ull y) {\n\tif (x < y) {\n\t\treturn gcd(y, x);\n\t} else if (y == 0) {\n\t\treturn x;\n\t} else {\n\t\treturn gcd(y, x % y);\n\t}\n}\n\null bitpow (ull a, ull x, ull modulo) {\n\tull result = 1;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tresult *= a;\n\t\t\tresult %= modulo;\n\t\t}\n\t\tx /= 2;\n\t\ta = (a * a) % modulo;\n\t}\n\treturn result;\n}\n\null divide (ull a, ull b, ull modulo) {\n\treturn (a * bitpow(b, modulo - 2, modulo)) % modulo;\n}\n\null udiff (ull a, ull b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nsll sdiff (sll a, sll b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nint bitcount (ull n) {\n\tint result = 0;\n\twhile (n) {\n\t\tif (n & 1) result++;\n\t\tn /= 2;\n\t}\n\treturn result;\n}\n\n// double distance (sll x1, sll y1, sll x2, sll y2) {\n// \tdouble xdist2, ydist2, origindist, dist;\n\n// \txdist2 = (x1 - x2) * (x1 - x2);\n// \tydist2 = (y1 - y2) * (y1 - y2);\n// \treturn sqrt(xdist2 + ydist2);\n// }\n\nint32_t pullcomp (const void *left, const void *right) {\n\tull l = *(ull*)left;\n\tull r = *(ull*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t psllcomp (const void *left, const void *right) {\n\tsll l = *(sll*)left;\n\tsll r = *(sll*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t pcharcomp (const void *left, const void *right) {\n\tchar l = *(char*)left;\n\tchar r = *(char*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t pdoublecomp (const void *left, const void *right) {\n\tdouble l = *(double*)left;\n\tdouble r = *(double*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t pstrcomp (const void *left, const void *right) {\n\tchar* l = *(char**)left;\n\tchar* r = *(char**)right;\n\n\treturn strcmp(l, r);\n}\n\nint32_t phwllABcomp (const void *left, const void *right) {\n\thwll l = *(hwll*)left;\n\thwll r = *(hwll*)right;\n\tif (l.a < r.a) {\n\t\treturn -1;\n\t}\n\tif (l.a > r.a) {\n\t\treturn +1;\n\t}\n\tif (l.b < r.b) {\n\t\treturn -1;\n\t}\n\tif (l.b > r.b) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t phwllREVcomp (const void *left, const void *right) {\n\thwll l = *(hwll*)left;\n\thwll r = *(hwll*)right;\n\tif (l.b < r.b) {\n\t\treturn -1;\n\t}\n\tif (l.b > r.b) {\n\t\treturn +1;\n\t}\n\tif (l.a < r.a) {\n\t\treturn -1;\n\t}\n\tif (l.a > r.a) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t ptriplecomp (const void *left, const void *right) {\n\thwllc l = *(hwllc*)left;\n\thwllc r = *(hwllc*)right;\n\n\tif (l.a < r.a) {\n\t\treturn -1;\n\t}\n\tif (l.a > r.a) {\n\t\treturn +1;\n\t}\n\tif (l.b < r.b) {\n\t\treturn -1;\n\t}\n\tif (l.b > r.b) {\n\t\treturn +1;\n\t}\n\tif (l.c < r.c) {\n\t\treturn -1;\n\t}\n\tif (l.c > r.c) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nbool isinrange (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right);\n}\n\nbool isinrange_soft (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right) || (left >= x && x >= right);\n}\n\nsll a[N_MAX];\n// sll a[3001][3001];\nsll b[N_MAX];\n// sll b[3001][3001];\nsll c[N_MAX];\n// sll d[N_MAX];\n// sll e[N_MAX];\nchar s[N_MAX + 1];\n// char s[3010][3010];\nchar t[N_MAX + 1];\n// char t[3010][3010];\n// hwll xy[N_MAX];\n// sll table[1000][1000];\n\nset<ull> g[2002];\nbool iscoprime[2002][2002];\nclock_t tot;\n\null iswatched[2002];\nvoid toggle (ull v, ull x) {\n\tiswatched[v] = x;\n\n\tfor (ull u : g[v]) {\n\t\tif (iswatched[u] ^ x) toggle(u, x);\n\t}\n}\nclock_t togrec (clock_t t) {\n\tstatic clock_t total = 0;\n\ttotal += t;\n\treturn total;\n}\n\ntypedef pair<ull, ull> P;\nvoid merge(vector<vector<ull>> &x, vector<ull> &v) {\n\tull curr[x.size()];\n\tpriority_queue<P, vector<P> > que;\n\tfor (ull i = 0; i < x.size(); i++) {\n\t\tcurr[i] = 0;\n\t\tque.push(P(x[i][0], i));\n\t}\n\twhile (!que.empty()) {\n\t\tP p = que.top();\n\t\tque.pop();\n\n\t\tv.push_back(p.first);\n\t\tull i = p.second;\n\t\tif (++curr[i] < x[i].size()) {\n\t\t\tque.push(P(x[i][curr[i]], i));\n\t\t}\n\t}\n\n\t// return v;\n}\n\nclock_t ft = 0;\n// bool iscome[2002];\nvector<ull> func (ull v) { // This can be O(NlogN)\n\tvector<ull> r;\n\t\n\t// clock_t times = 0;\n\t// times -= clock();\n\n\t// fprintf(stderr, \"%lld.. (%d)\\n\", v, clock() - tot);\n\t// fflush(stderr);\n\t// if (iscome[v]) {\n\t// \tfprintf(stderr, \"came %lld!\\n\", v);\n\t// \tabort();\n\t// }\n\t// iscome[v] = true;\n\n\tpriority_queue<ull, vector<ull>, greater<ull> > que;\n\t// clock_t start = clock();\n\t// toggle(v, 0);\n\t// clock_t end = clock();\n\t// fprintf(stderr, \"toggle(%lld, 0): %d\\n\", v, end - start);\n\t// togrec(end - start);\n\tiswatched[v] = 1;\n\n\tfor (ull u : g[v]) {\n\t\tg[u].erase(v);\n\t\tque.push(u);\n\t}\n\n\tvector<vector<ull>> vs;\n\twhile (!que.empty()) {\n\t\tull u = que.top();\n\t\tque.pop();\n\t\tif (iswatched[u]) continue;\n\n\t\t// clock_t start = clock();\n\t\t// toggle(u, 1);\n\t\t// clock_t end = clock();\n\t\t// fprintf(stderr, \"toggle(%lld, 1): %d\\n\", u, end - start);\n\t\t// fflush(stderr);\n\t\t// togrec(end - start);\n\n\t\t// times += clock();\n\t\tvs.push_back(func(u));\n\t\t// times -= clock();\n\t}\n\n\tr.push_back(v);\n\tmerge(vs, r);\n\n\t// times += clock();\n\t// fprintf(stderr, \"%lld: %d\\n\", v, times);\n\t// fflush(stderr);\n\t// ft += times;\n\n\treturn r;\n}\n\null solve () {\n\tsll i, j, ki, li;\n\tull result = 0;\n\t// sll result = 0;\n\tdouble dresult = 0;\n\t// ull maybe = 0;\n\tsll maybe = 0;\n\t// ull sum = 0;\n\tsll sum = 0;\n\tsll item;\n\tull *dpcell;\n\n\tqsort(a, n, sizeof(ull), pullcomp);\n\n\tfor (i = 0; i < n; i++) {\n\t\tfor (j = i + 1; j < n; j++) {\n\t\t\tif (gcd(a[i], a[j]) > 1) {\n\t\t\t\tg[i].insert(j);\n\t\t\t\tg[j].insert(i);\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<vector<ull>> finals;\n\n\t// tot = clock();\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (iswatched[i]) continue;\n\n\t\t// clock_t start = clock();\n\t\t// toggle(i, 1);\n\t\t// clock_t end = clock();\n\t\t// fprintf(stderr, \"toggle(%lld, 1): %d\\n\", i, end - start);\n\t\t// togrec(end - start);\n\n\t\tfinals.push_back(func(i));\n\t\t// for (j = 0; j < finals[finals.size() - 1].size(); j++) printf(\"%llu \", finals[finals.size() - 1][j]);\n\t\t// \tputs(\"\");\n\t\t// fflush(stdout);\n\t}\n\tvector<ull> r;\n\tmerge(finals, r);\n\tfor (i = 0; i < n; i++) {\n\t\tprintf(\"%llu%c\", a[r[i]], (i == n - 1 ? '\\n' : ' '));\n\t}\n\t// fprintf(stderr, \"togrec: %d\\n\", togrec(0));\n\t// fprintf(stderr, \"ft: %d\\n\", ft);\n\n\t// printf(\"%lld\\n\", result);\n\t// printf(\"%.15lf\\n\", dresult);\n\t// puts(s);\n\n\treturn 0;\n\n\tsuccess:\n\t// puts(\"YES\");\n\tputs(\"Yes\");\n\t// printf(\"%llu\\n\", result);\n\t// puts(\"0\");\n\t// puts(\"Yay!\");\n\treturn 0;\n\n\tfail:\n\t// puts(\"NO\");\n\tputs(\"No\");\n\t// puts(\"0\");\n\t// puts(\"-1\");\n\t// puts(\"-1 -1 -1\");\n\t// puts(\":(\");\n\treturn 1;\n}\n\nint32_t main (void) {\n\tint32_t i, j;\n\tint32_t x, y;\n\n\tscanf(\"%llu\", &n, &m);\n\t// scanf(\"%llu\", &k, &n, &m);\n\t// scanf(\"%llu%llu\", &h, &w);\n\t// scanf(\"%lld\", &va, &vb, &vc, &vd);\n\t// scanf(\"%llu%llu\", &ua, &ub, &uc, &ud);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%s\", s);\n\t// scanf(\"%s\", t);\n\tfor (i = 0; i < n; i++) {\n\t\t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t\tscanf(\"%lld\", &a[i]);\n\t\t// scanf(\"%lld\", &b[i]);\n\t\t// scanf(\"%lld\", &c[i]);\n\t\t// scanf(\"%lld\", &d[i]);\n\t\t// a[i]--;\n\t\t// b[i]--;\n\t\t// c[i]--;\n\t}\n\t// scanf(\"%llu\", &m, &k);\n\t// scanf(\"%llu\", &q);\n\t// for (i = 0; i < n; i++) {\n\t// \tscanf(\"%lld\", &b[i]);\n\t// }\n\n\t// for (i = 0; i < h; i++) {\n\t// \tfor (j = 0; j < w; j++) {\n\t// \t\tscanf(\"%llu\", &table[i][j]);\n\t// \t}\n\t// }\n\t// for (i = 0; i < h; i++) {\n\t// \tscanf(\"%s\", &s[i]);\n\t// }\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \nusing namespace std;\n//author_name:tourist\n//date:2018/11/18\n//title:AGC 010 E Rearranging\n//ÒòÎªÇÓÅ³£¬ËùÒÔÌÓ±ÜÉúÃü£¬ÒÔ²»µÖ¿¹ÔÚ×îºÚ°µµÄ³ÁÂÙÖÐÉú³ö½¾°Á£¬ÒòÎª½¾°Á£¬ËùÒÔ²»Ñ¡ÔñÉú£¬ËùÒÔ¾Ü³â´Ö±ÉµÄÀÖ¹ÛÖ÷Òå¡£\n//Ìì²ÅµÄ±¯¾çµØÓÚ±»Ð¡¶øÊæÊÊµÄÃûÍûËùÊø¸¿¡£\n//It's human to lie. Most of the time we can't even be honest with ourselves.\n\nconst int N=2010;\nconst int NN=2010;\nconst int one=1;\nunsigned long long g[N][NN];\nunsigned long long was[NN];\n\nint a[N];\nint x[N];\nbool alive[N];\nbool can_put[N];\n\nint main()\n{\t\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++)\n\t\tscanf(\"%d\",a+i);\n\tfor(int i=0;i<n;i++)\n\t\tfor(int j=i+1;j<n;j++)\n\t\t\tif(__gcd(a[i],a[j])>1)\n\t\t\t{\n\t\t\t\tg[i][j>>6]|=(one<<(j&63));\n\t\t\t\tg[j][i>>6]|=(one<<(i&63));\n\t\t\t}\n\tint nn=((n-1)>>6)+1;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcan_put[i]=true;\n\t\talive[i]=true;\n\t}\n\tfor(int it=0;it<n;it++)\n\t{\n\t\tfor(int i=0;i<nn;i++)\n\t\t\twas[i]=0;\n\t\tfor(int i=0;i<n;i++)\n\t\t\tif(!alive[i])\n\t\t\t\twas[i>>6]|=(one<<(i&63));\n\t\tint best=-1;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tif(was[i >> 6]&(one << (i&63)))\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tint b=0,e=1;\n\t\t\tx[0]=i;\n\t\t\twas[i >> 6]|=(one << (i&63));\n\t\t\twhile(b<e)\n\t\t\t{\n\t\t\t\tfor(int j=0;j<nn;j++)\n\t\t\t\t\tif((g[x[b]][j]&was[j])!=g[x[b]][j])\n\t\t\t\t\t\tfor(int u=j*64;u<(j+1)*64;u++)\n\t\t\t\t\t\t\tif(g[x[b]][u >> 6] & (one << (u&63)))\n\t\t\t\t\t\t\t\tif(!(was[u >> 6] & (one << (u&63))))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\twas[u >> 6]|=(one << (u&63));\n\t\t\t\t\t\t\t\t\tx[e++]=u;\n\t\t\t\t\t\t\t\t}\n\t\t\t\tb++;\n\t\t\t}\n\t\t\tint cur=-1;\n\t\t\tfor(int j=0;j<e;j++)\n\t\t\t{\n\t\t\t\tif(!can_put[x[j]])\n\t\t\t\t\tcontinue;\n\t\t\t\tif(cur==-1||a[cur]>a[x[j]])\n\t\t\t\t\tcur=x[j];\n\t\t\t}\n\t\t\tif(best==-1||(cur!=-1&&a[cur]>a[best]))\n\t\t\t\tbest=cur;\n\t\t}\n\t\talive[best]=false;\n\t\tif(it) printf(\" \");\n\t\tprintf(\"%d\",a[best]);\n\t\t\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tif(!alive[i])\n\t\t\t\tcontinue;\n\t\t\tif(g[best][i >> 6] & (one << (i&63)))\n\t\t\t\tcan_put[i]=true;\n\t\t\telse {\n\t\t\t\tif(a[best]<a[i]) \n\t\t\t\t\tcan_put[i]=false;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<iomanip>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <functional>\n#include<complex>\nusing namespace std;\n\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define repn(i,x) for(ll i=1;i<=x;i++)\n\ntypedef long long ll;\nconst ll INF = 1e17;\nconst ll MOD = 1000000007;\nconst ll MAX = 4000001;\nconst long double eps = 1E-14;\n\nll max(ll a, ll b) {\n\tif (a > b) { return a; }\n\treturn b;\n}\n\nll min(ll a, ll b) {\n\tif (a > b) { return b; }\n\treturn a;\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) { return a; }\n\tif (a < b) { return gcd(b, a); }\n\treturn gcd(b, a % b);\n}\n\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b) * b;\n}\n\nstruct edge {\n\tll ind;\n\tll fr;\n\tll to;\n\tll d;\n};\n\nclass mint {\n\tlong long x;\npublic:\n\tmint(long long x = 0) : x((x% MOD + MOD) % MOD) {}\n\tmint operator-() const {\n\t\treturn mint(-x);\n\t}\n\tmint& operator+=(const mint& a) {\n\t\tif ((x += a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator-=(const mint& a) {\n\t\tif ((x += MOD - a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator*=(const  mint& a) {\n\t\t(x *= a.x) %= MOD;\n\t\treturn *this;\n\t}\n\tmint operator+(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res += a;\n\t}\n\tmint operator-(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res -= a;\n\t}\n\tmint operator*(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res *= a;\n\t}\n\n\tmint pow(ll t) const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\n\t// for prime MOD\n\tmint inv() const {\n\t\treturn pow(MOD - 2);\n\t}\n\tmint& operator/=(const mint& a) {\n\t\treturn (*this) *= a.inv();\n\t}\n\tmint operator/(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res /= a;\n\t}\n\n\tfriend ostream& operator<<(ostream& os, const mint& m) {\n\t\tos << m.x;\n\t\treturn os;\n\t}\n};\n\nmint pw(mint a, ll b) {\n\tif (b == 0) { return 1; }\n\tmint ret = pw(a, b >> 1);\n\tret *= ret;\n\tif (b & 1) { ret *= a; }\n\treturn ret;\n}\n\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef vector<vector<vector<ll>>> vvvll;\n\ntypedef vector<mint> vmint;\ntypedef vector<vector<mint>> vvmint;\ntypedef vector<vector<vector<mint>>> vvvmint;\n\n/////////////////////////////////////\nvvll g;\nvll con;\n\nvoid dfs(ll v, ll x) {\n\tcon[v] = x;\n\tfor (ll w : g[v]) {\n\t\tif (con[w] != 0) { continue; }\n\t\tdfs(w, x);\n\t}\n}\n\nint main() {\n\tll N;\n\tcin >> N;\n\tvll A(N + 1);\n\trepn(i, N)cin >> A[i];\n\n\tsort(++A.begin(), A.end());\n\n\tg.resize(N + 1);\n\trepn(i, N)for (ll j = i; j <= N; j++) {\n\t\tif (gcd(A[i], A[j]) > 1) { g[i].push_back(j); g[j].push_back(i); }\n\t}\n\n\tcon.assign(N + 1, 0);\n\tvll mn(1, 0);\n\n\tll M = 0;\n\trepn(v, N) {\n\t\tif (con[v] != 0) { continue; }\n\t\tM++;\n\t\tdfs(v, M);\n\t\tmn.push_back(v);\n\t}\n\n\tvector<set<ll>> st(M + 1);\n\trepn(i, M)st[i].insert(mn[i]);\n\n\t//repn(v, M)cout << mn[v] << endl;\n\n\tvll lis(N + 1, 0);\n\n\trepn(i, N) {\n\t\tll ans = 0;\n\t\tll id = 0;\n\t\trepn(j, M) {\n\t\t\tif (st[j].empty()) { continue; }\n\t\t\tll x = *st[j].begin();\n\t\t\tif (x > ans) { ans = x; id = j; }\n\t\t}\n\t\t\n\t\tcout << A[ans] << \" \";\n\t\tlis[ans] = i;\n\n\t\tst[id].erase(ans);\n\t\tfor (ll v : g[ans]) { if (lis[v] == 0) { st[id].insert(v); } }\n\t}\n\tcout << endl;\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cctype>\n#include <algorithm>\n#include <queue>\nusing namespace std;\ntypedef long long int64;\ninline int read(int f = 1, int x = 0, char ch = ' ')\n{\n    while(!isdigit(ch = getchar())) if(ch == '-') f = -1;\n    while(isdigit(ch)) x = x*10+ch-'0', ch = getchar();\n    return f*x;\n}\nconst int N = 2e3+5;\nint gcd(int a, int b) { return b?gcd(b, a%b):a; }\nstruct Edge\n{\n    int next, to;\n    Edge(int next = 0, int to = 0):next(next), to(to) {};\n}edge[N*N];\nint tot, head[N];\nint n, vis[N], f[N][N], deg[N], a[N];\nvoid add(int x, int y) { edge[++tot] = Edge(head[x], y), head[x] = tot, ++deg[y]; } \nvoid dfs(int x)\n{\n    vis[x] = 1;\n    for(int y = 1; y <= n; ++y)\n        if(!vis[y]&&f[x][y])\n            add(x, y), dfs(y);\n}\nint main()\n{\n    n = read();\n    for(int i = 1; i <= n; ++i) a[i] = read();\n    sort(a+1, a+1+n);\n    for(int i = 1; i <= n; ++i) \n        for(int j = 1; j < i; ++j)\n            if(gcd(a[i], a[j]) != 1) f[i][j] = f[j][i] = 1;\n    for(int i = 1; i <= n; ++i) if(!vis[i]) dfs(i);\n    priority_queue<int> q;\n    for(int i = 1; i <= n; ++i) if(!deg[i]) q.push(i);\n    while(q.size())\n    {\n        int x = q.top(); q.pop();\n        printf(\"%d \", a[x]);\n        for(int i = head[x]; i; i = edge[i].next) q.push(edge[i].to);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\n#define fst first\n#define snd second\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vii;\n#define sz(c) (int)(c).size()\n#define ALL(c) (c).begin(), (c).end()\n\nvi combine (const vi &l, const vi &r)\n{\n    if (l.empty() || r.empty())\n        return l.empty() ? r : l;\n\n    vi res(sz(l) + sz(r));\n    int pl = 0, pr = 0, h = 0;\n    while (pl < sz(l) && pr < sz(r))\n        res[h++] = (l[pl] > r[pr] ? l[pl++] : r[pr++]);\n    while (pl < sz(l))\n        res[h++] = l[pl++];\n    while (pr < sz(r))\n        res[h++] = l[pl++];\n    assert(h == sz(res));\n\n    return res;\n}\n\nvi dfs (int x, const vvi &g, vector<char> &used)\n{\n    used[x] = 1;\n    vi res;\n\n    for (int dest : g[x])\n    if (!used[dest])\n        res = combine(res, dfs(dest, g, used));\n\n    res.insert(res.begin(), x);\n    return res;\n}\n\nvoid solve (int n)\n{\n    vi a(n);\n    forn (i, n) cin >> a[i];\n    sort(ALL(a));\n\n    vvi g(n);\n    forn (i, n) forn (j, i)\n    if (__gcd(a[i], a[j]) != 1)\n    {\n        g[i].pb(j);\n        g[j].pb(i);\n    }\n\n    forn (i, n)\n        sort(ALL(g[i]));\n\n    vi res;\n    vector<char> used(n);\n    forn (i, n) if (!used[i])\n        res = combine(res, dfs(i, g, used));\n\n    forn (i, n)\n        cout << a[res[i]] << \" \\n\"[i + 1 == n];\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n;\n    while (cin >> n)\n        solve(n);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<typename T> \nmap<T, Int> factorize(T x){\n  map<T, Int> res;\n  for(Int i=2;i*i<=x;i++){\n    while(x%i==0){\n      x/=i;\n      res[i]++;\n    }\n  }\n  if(x!=1) res[x]++;\n  return res;\n}\n\n//INSERT ABOVE HERE\nInt cop[2020][2020];\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<Int> a(n);\n  for(Int i=0;i<n;i++) cin>>a[i];\n  sort(a.begin(),a.end());\n\n  vector<Int> ans(n),used(n,0),post(n,0);\n\n  memset(cop,0,sizeof(cop));\n  \n  for(Int i=0;i<n;i++)\n    for(Int j=0;j<n;j++)\n      cop[i][j]=__gcd(a[i],a[j])>1;\n\n  Int m=0;\n  map<Int, Int> r;\n\n  vector<vector<Int> > G(n*100);\n  for(Int i=0;i<n;i++){\n    auto x=factorize(a[i]);\n    for(auto p:x){\n      if(!r.count(p.first)) r[p.first]=m++;\n      G[i].emplace_back(n+r[p.first]);\n      G[n+r[p.first]].emplace_back(i);\n    }\n  }\n  \n  for(Int t=0;t<n;t++){\n    vector<Int> cs(n+m,-1);\n    Int color=0;\n    for(Int i=0;i<n+m;i++){\n      if(~cs[i]) continue;\n      queue<Int> q;\n      cs[i]=color;\n      q.emplace(i);\n      while(!q.empty()){\n\tInt v=q.front();q.pop();\n\tfor(Int u:G[v]){\n\t  if(~cs[u]) continue;\n\t  cs[u]=color;\n\t  q.emplace(u);\n\t}\n      }\n      color++;\n    }\n    \n    Int idx=-1;\n    for(Int i=0;i<n;i++){\n      if(used[i]||post[i]) continue;\n      idx=i;\n      break;\n    }\n    \n    used[idx]=1;\n    ans[t]=idx;\n    \n    for(Int i=0;i<n;i++){\n      if(cs[idx]!=cs[i]) continue;\n      if(cop[idx][i]) post[i]=0;\n      else if(a[idx]<a[i]) post[i]=1;\n    }\n  }\n\n\n  vector<Int> b(n);\n  for(Int i=0;i<n;i++) b[i]=a[ans[i]];\n  \n  vector<vector<Int> > H(n);\n  for(Int i=0;i<n;i++)\n    for(Int j=i+1;j<n;j++)\n      if(__gcd(b[i],b[j])>1) H[i].emplace_back(j);\n\n  vector<Int> indeg(n);\n  for(Int i=0;i<n;i++)\n    for(Int j:H[i]) indeg[j]++;\n  \n  using P = pair<Int, Int>;\n  priority_queue<P> pq;\n  for(Int i=0;i<n;i++)\n    if(!indeg[i]) pq.emplace(b[i],i);\n\n  vector<Int> c;\n  while(!pq.empty()){\n    P p=pq.top();pq.pop();\n    c.emplace_back(p.first);\n    for(Int u:H[p.second]){\n      indeg[u]--;\n      if(!indeg[u]) pq.emplace(b[u],u);\n    }\n  }\n  \n  assert((Int)c.size()==n);\n  for(Int i=0;i<n;i++){\n    if(i) cout<<\" \";\n    cout<<c[i];\n  }\n  cout<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define all(x)  x.begin(), x.end()\n#define mp      make_pair\n\nvector<int> g[2020];\nint used[2020];\nvector<int> a;\nvector<int> tmp;\n\nvoid dfs(int v) {\n        used[v] = true;\n        tmp.push_back(a[v]);\n        //vector<pair<int, int>> p;\n        //for (auto u : g[v]) if (u != prev) p.emplace_back(a[u], u);\n        //sort(all(p));\n        //for (auto u : p) {\n        //        if (!used[u.second]) {\n        //                dfs(u.second, v);\n        //        }\n        //}\n        for (auto u : g[v]) if (!used[u]) {\n                dfs(u);\n        }\n}\n\nint main() {\n        int n;\n        scanf(\"%d\", &n);\n        a.resize(n);\n        for (int i = 0; i < n; i ++) scanf(\"%d\", &a[i]);\n\n        //Takahashi\n        for (int i = 0; i < n; i ++) {\n                for (int j = i + 1; j < n; j ++) {\n                        if (__gcd(a[i], a[j]) != 1) {\n                                g[i].push_back(j);\n                                g[j].push_back(i);\n                        }\n                }\n        }\n        sort(all(a));\n        for (int i = 0; i < n; i ++) {\n                if (!used[i]) {\n                        dfs(i);\n                }\n        }\n\n        for (int i = 0; i < n; i ++) {\n                int j = i;\n                for (int k = i - 1; k >= 0 && __gcd(tmp[k], tmp[i]) == 1; k --) {\n                        if (tmp[k] < tmp[i]) j = k;\n                }\n                rotate(tmp.begin() + j, tmp.begin() + i, tmp.begin() + i + 1);\n            }\n        //Aoki\n        for (int i = 0; i < n; i ++) g[i].clear();\n        for (int i = 0; i < n; i ++) {\n                for (int j = i + 1; j < n; j ++) {\n                        if (__gcd(tmp[i], tmp[j]) != 1) {\n                                g[i].push_back(j);\n                                g[j].push_back(i);\n                        }\n                }\n        }\n        //vector<int> in_cnt(n, 0);\n        //for (int i = 0; i < n; i ++) {\n        //        for (auto u : g[i]) {\n        //                in_cnt[u] ++;\n        //        }\n        //}\n        //priority_queue<pair<int, int>> pq;\n        //for (int i = 0; i < n; i ++) if (in_cnt[i] == 0) pq.push(mp(tmp[i], i));\n        //vector<int> ans;\n        //while (!pq.empty()) {\n        //        auto get = pq.top();\n        //        pq.pop();\n        //        ans.push_back(get.first);\n        //        for (auto u : g[get.second]) {\n        //                in_cnt[u] --;\n        //                if (in_cnt[u] == 0) pq.push(mp(tmp[u], u));\n        //        }\n        //}\n        for (int i = 0; i < n; i ++) cout << tmp[i] << (i == n - 1 ? '\\n' : ' ');\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nconst int N=2000+5;\ntypedef long long ll;\nint n,a[N];\nint gcd(int x,int y){\n    if(!y)\n        return x;\n    return gcd(y,x%y);\n}\nint G[N][N];\nstruct node{\n    int u,v,nxt;\n}edge[N*2];\nint head[N],mcnt;\nvoid add_edge(int u,int v){\n    mcnt++;\n    edge[mcnt].u=u;\n    edge[mcnt].v=v;\n    edge[mcnt].nxt=head[u];\n    head[u]=mcnt;\n}\nbool vis[N];\nint rudu[N];\nvoid dfs(int u){\n    vis[u]=1;\n    for(int v=1;v<=n;v++){\n        if(G[u][v]&&!vis[v]){\n            add_edge(u,v);\n            rudu[v]++;\n            dfs(v);\n        }\n    }\n}\nint ans[N];\ntypedef pair<int,int>pi;\npriority_queue<pi>q;\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)\n        scanf(\"%d\",&a[i]);\n    sort(a+1,a+n+1);\n    for(int i=1;i<=n;i++)\n        for(int j=i+1;j<=n;j++)\n            if(gcd(a[i],a[j])>1)\n                G[i][j]=G[j][i]=1;\n    for(int i=1;i<=n;i++)\n        if(!vis[i])\n            dfs(i);\n    int cnt=0;\n    for(int i=1;i<=n;i++)\n        if(!rudu[i])\n            q.push(pi(a[i],i));\n    while(!q.empty()){\n        int w=q.top().first,u=q.top().second;\n        q.pop();\n        ans[++cnt]=w;\n        for(int i=head[u];i;i=edge[i].nxt){\n            int v=edge[i].v;\n            rudu[v]--;\n            if(!rudu[v])\n                q.push(pi(a[v],v));\n        }\n    }\n    for(int i=1;i<=n;i++)\n        printf(\"%d \",ans[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n;\nvector < int > G[2020], A[2020], answer;\nint a[2020], nxt[2020];\nbool used[2020];\n\nvoid go(int v, int p = 0)\n{\n  used[v] = true;\n  priority_queue < int > q;\n  for(int i = 0; i < G[v].size(); ++ i)\n  {\n    int to = G[v][i];\n    if(used[to])\n      continue;\n    go(to, v);\n    q.push(A[to][0]);\n  }\n  A[v].push_back(v);\n  while(!q.empty())\n  {\n    int x = q.top();\n    q.pop();\n    nxt[A[v].back()] = x;\n    A[v].push_back(x);\n    if(nxt[x] != 0)\n      q.push(nxt[x]);\n  }\n  nxt[A[v].back()] = 0;\n}\n\nint main()\n{\n  scanf(\"%d\", &n);\n  for(int i = 1; i <= n; ++ i)\n    scanf(\"%d\", &a[i]), G[0].push_back(i);\n  sort(a + 1, a + n + 1);\n  for(int i = 1; i <= n; ++ i)\n    for(int j = 1; j <= n; ++ j)\n    {\n      if(j == i) continue;\n      if(__gcd(a[i], a[j]) > 1)\n        G[i].push_back(j);\n    }\n  go(0);\n\n  for(int i = 1; i <= n; ++ i)\n    printf(\"%d \", a[A[0][i]]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ADD(a, b) a = (a + ll(b)) % mod\n#define MUL(a, b) a = (a * ll(b)) % mod\n#define MAX(a, b) a = max(a, b)\n#define MIN(a, b) a = min(a, b)\n#define rep(i, a, b) for(int i = int(a); i < int(b); i++)\n#define rer(i, a, b) for(int i = int(a) - 1; i >= int(b); i--)\n#define all(a) (a).begin(), (a).end()\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sec second\n#define fst first\n#define debug(fmt, ...) Debug(__LINE__, \":\", fmt, ##__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<int, pi> ppi;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vl> mat;\ntypedef complex<double> comp;\nvoid Debug() {cout << '\\n'; }\ntemplate<class FIRST, class... REST>void Debug(FIRST arg, REST... rest){\n\tcout<<arg<<\" \";Debug(rest...);}\ntemplate<class T>ostream& operator<<(ostream& out,const vector<T>& v) {\n\tout<<\"[\";if(!v.empty()){rep(i,0,sz(v)-1)out<<v[i]<<\", \";out<<v.back();}out<<\"]\";return out;}\ntemplate<class S, class T>ostream& operator<<(ostream& out,const pair<S, T>& v){\n\tout<<\"(\"<<v.first<<\", \"<<v.second<<\")\";return out;}\nconst int MAX_N = 2010;\nconst int MAX_V = 100010;\nconst double eps = 1e-6;\nconst ll mod = 1000000007;\nconst int inf = 1 << 29;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\nll gcd(ll a, ll b) {\n\tif(b == 0) return a;\n\telse return gcd(b, a % b);\n}\n\nint N;\nbool on[MAX_N], used[MAX_N];\nint A[MAX_N];\nvector<pi> G[MAX_N];\n\nvoid add_edge(int from, int to) {\n\tG[from].pb(pi(to, sz(G[to])));\n\tG[to].pb(pi(from, sz(G[from]) - 1));\n}\n\nvoid erase_node(int v) {\n\ton[v] = false;\n\trep(i, 0, sz(G[v])) {\n\t\tint n = G[v][i].fst, rat = G[v][i].sec;\n\t\tif(rat == -1) continue;\n\t\ton[n] = true;\n\t\tG[n][rat].sec = -1;\n\t\tG[v][i].sec = -1;\n\t}\n}\n\npi loop(int v, bool only = false) {\n\tused[v] = true;\n\tpi res;\n\tif(!only || on[v]) res = pi(A[v], v);\n\telse res = pi(inf, inf);\n\trep(i, 0, sz(G[v])) {\n\t\tint n = G[v][i].fst;\n\t\tif(G[v][i].sec == -1) continue;\n\t\tif(!used[n]) MIN(res, loop(n));\n\t}\n\treturn res;\n}\n\nvoid graph_show() {\n\trep(i, 0, N) {\n\t\tvector<int> res;\n\t\trep(j, 0, sz(G[i])) {\n\t\t\tint n = G[i][j].fst;\n\t\t\tif(G[i][j].sec == -1) continue;\n\t\t\tres.pb(A[n]);\n\t\t}\n\t\tdebug(A[i], res);\n\t}\n}\n\n\nvoid solve() {\n\tcin >> N;\n\trep(i, 0, N) cin >> A[i];\n\trep(i, 0, N) {\n\t\trep(j, i + 1, N) {\n\t\t\tif(gcd(A[i], A[j]) != 1) {\n\t\t\t\tadd_edge(i, j);\n\t\t\t}\n\t\t}\n\t}\n\n\trep(i, 0, N) {\n\t\tif(!used[i]) {\n\t\t\tpi p = loop(i);\n\t\t\ton[p.sec] = true;\n\t\t}\n\t}\n\tvector<int> ans;\n\trep(q, 0, N) {\n\t\t// debug(vi(on, on + N));\n\t\t// graph_show();\n\t\tint a = -1, at = -1;\n\t\tmemset(used, 0, sizeof(used));\n\t\trep(i, 0, N) {\n\t\t\tif(!used[i]) {\n\t\t\t\tpi p = loop(i, true);\n\t\t\t\tif(p.fst == inf) continue;\n\t\t\t\tif(a < p.fst) {\n\t\t\t\t\ta = p.fst; at = p.sec;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans.pb(a);\n\t\terase_node(at);\n\t}\n\trep(i, 0, N) {\n\t\tcout << ans[i] << \" \";\n\t}\n\tcout << \"\\n\";\n}\n\n\nint main() {\n#ifndef LOCAL\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n\tcout.precision(20);\n\tsrand((unsigned int)time(NULL));\n#ifdef LOCAL\n\t//freopen(\"in.txt\", \"wt\", stdout); //for tester\n    freopen(\"in.txt\", \"rt\", stdin);\n#endif\t\n\tsolve();\n#ifdef LOCAL\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ADD(a, b) a = (a + ll(b)) % mod\n#define MUL(a, b) a = (a * ll(b)) % mod\n#define MAX(a, b) a = max(a, b)\n#define MIN(a, b) a = min(a, b)\n#define rep(i, a, b) for(int i = int(a); i < int(b); i++)\n#define rer(i, a, b) for(int i = int(a) - 1; i >= int(b); i--)\n#define all(a) (a).begin(), (a).end()\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sec second\n#define fst first\n#define debug(fmt, ...) Debug(__LINE__, \":\", fmt, ##__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<int, pi> ppi;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vl> mat;\ntypedef complex<double> comp;\nvoid Debug() {cout << '\\n'; }\ntemplate<class FIRST, class... REST>void Debug(FIRST arg, REST... rest){\n\tcout<<arg<<\" \";Debug(rest...);}\ntemplate<class T>ostream& operator<<(ostream& out,const vector<T>& v) {\n\tout<<\"[\";if(!v.empty()){rep(i,0,sz(v)-1)out<<v[i]<<\", \";out<<v.back();}out<<\"]\";return out;}\ntemplate<class S, class T>ostream& operator<<(ostream& out,const pair<S, T>& v){\n\tout<<\"(\"<<v.first<<\", \"<<v.second<<\")\";return out;}\nconst int MAX_N = 2010;\nconst int MAX_V = 100010;\nconst double eps = 1e-6;\nconst ll mod = 1000000007;\nconst int inf = 1 << 29;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\nll gcd(ll a, ll b) {\n\tif(b == 0) return a;\n\telse return gcd(b, a % b);\n}\n\nint N;\nint A[MAX_N];\nbool used[MAX_N];\nvector<int> G[MAX_N];\n\nvi loop(int v) {\n\tused[v] = true;\n\tvector<vi> E;\n\tvector<int> at;\n\tvector<int> res;\n\tvector<int> order;\n\n\n\tif(v != 0) res.pb(A[v]);\n\n\trep(i, 0, sz(G[v])) {\n\t\tint n = G[v][i];\n\t\tif(used[n]) continue;\n\t\torder.pb(i);\n\t}\n\tsort(all(order), [&](int a, int b){ return A[G[v][a]] < A[G[v][b]]; });\n\n\trep(i, 0, sz(order)) {\n\t\tint n = G[v][order[i]];\n\t\tif(!used[n]) {\n\t\t\tE.pb(loop(n));\n\t\t\tat.pb(0);\n\t\t}\n\t}\n\n\tint m = sz(E);\n\twhile(true) {\n\t\tint a = -1, tat = -1;\n\t\trep(i, 0, m) {\n\t\t\tif(sz(E[i]) == at[i]) continue;\n\t\t\tif(a < E[i][at[i]]) {\n\t\t\t\ta = E[i][at[i]]; tat = i;\n\t\t\t}\n\t\t}\n\t\tif(tat == -1) break;\n\t\tat[tat]++; res.pb(a);\n\t}\n\treturn res;\n}\n\nvoid solve() {\n\tcin >> N;\n\trep(i, 0, N) {\n\t\tcin >> A[i + 1];\n\t}\n\trep(i, 1, N + 1) {\n\t\trep(j, i + 1, N + 1) {\n\t\t\tif(gcd(A[i], A[j]) != 1) {\n\t\t\t\tG[i].pb(j);\n\t\t\t\tG[j].pb(i);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, 1, N + 1) {\n\t\tG[i].pb(0);\n\t\tG[0].pb(i);\n\t}\n\n\tvector<int> ans = loop(0);\n\trep(i, 0, N) {\n\t\tcout << ans[i] << \" \";\n\t}\n\tcout << \"\\n\";\n}\n\nint main() {\n#ifndef LOCAL\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n\tcout.precision(20);\n\tsrand((unsigned int)time(NULL));\n#ifdef LOCAL\n\t//freopen(\"in.txt\", \"wt\", stdout); //for tester\n    freopen(\"in.txt\", \"rt\", stdin);\n#endif\t\n\tsolve();\n#ifdef LOCAL\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n *                             UM.\n *                            J@B@1                                                                    iO@1\n *                           Y@@@B@BB.                                                              7B@B@B@\n *                          :@B@i,B@B@O                                                          ,Z@B@B@B@Br\n *                          @B@q   i@B@BS                                                      7@B@@@O5vMB@q\n *                         8@@B      LB@B@i                                                  FB@@@BNjYjLE@B@\n *                        ,B@B:        0@@@Z                                               P@B@BM1JJ125JPB@B\n *                        B@BB          :@B@B                                            XB@B@Z2LuU52F2u2@B@.\n *                       :@B@             @@@B:                                        v@B@B8uJj51F1525uUB@B7\n *                       @B@O              0@@B.               ..::ir7vvYUuU777r::.   B@B@OULU2F2F151F11Y@B@S\n *                       B@B,               8B@B  :ruXMB@B@B@B@B@B@B@B@B@B@@@B@B@B@B@B@B@5Jj1211F1F1F2FUJO@BB\n *                      U@B@                 @B@B@B@B@B@@@B@B@B@MMqPS5JuYL7rq@B@OBB@B@B8Yu211F1515251515YGB@@\n *                      @B@u                 v@@@@MSur:.                    LB@MvvjJuU5YU252F1F1F25251F2uX@@@\n *                      @@@.                                                N@BML2U2UUU12F15252525251515Jk@@B\n *                     r@B@                                                 YB@Bju52121252515252F15251F2u5@B@\n *                     PB@B                                                  @@@PYUF151F25151F152F2F1F15jF@@B\n *                     @@BS                                                  N@@@UJ2F25252F251525151F1F1u5@B@\n *                     @@@7                                                   B@B@5Yj12F152F1F1F25252515jFB@B\n *                     B@Bi                                                    M@B@O2Luu52525212F151121UY1@B@7\n *                    O@B@:                                                     v@B@BMSuYJJuuUu2u2uujjYJJXB@B@M\n *                  7B@B@,                                                        1B@@@B@GPF1uujuu21PNMB@B@B@B@@\n *                 qB@B2                                                            i8B@B@B@B@B@@@@@B@B@B@q: @@@B\n *                MB@B:                                                                 7SBB@B@B@B@B@Zu:      @B@B\n *               ZB@B.                                              ,v.                                        @B@L\n *              LB@B,                         Y7                    @B@Bu                                      7@B@\n *   :B@B@@B2:  @@B7                         @B@Z                   r@B@B@BP:                                   B@BE\n *    BB@@@B@B@B@BE                        r@B@B                       7@B@B@B@Ou:                              iB@B\n *         :uM@@B@@2.           :7::::ivk@B@B@0                           :5B@B@B@B@B@B@G.                       @B@i\n *            BB@@@B@@         :@B@B@@@B@B@@1                                 .i5M@B@B@@@5                       M@@2\n *            B@B ,@B1          L0EZZG0F7:                                            .:,                        uB@MrP@M7\n *           2@B@                                                                                               ,O@B@B@B@B\n *           @B@1                                                     :@B@@@r                                :@@@@B@BL:,,\n *           B@Bi                         :2ZS;                      :@B@B@B@r                               L@B@B@BU\n *           @B@.                        @@@B@B@                     vB@B@B@B5                                   @B@i\n *           B@B                        7B@B@B@BM                     OB@B@B@                                   ,B@B\n *           @B@                         @B@B@@@i                       rL7.                                    B@BM\n *           B@B7.:                       NB@@M.                                                               .@B@.\n *  .;JEB@@@B@B@B@B@.                                                                                       .  @B@u\n *@@@B@B@B@B@@@B@18U                                                                                      :B@B@B@BU,\n *7@BOui.    ,@@B                                                                                          SP@B@B@B@B@Or\n *            @@@U                                                                                           B@BJ.YO@B@B@i\n *            r@B@                                                                                         :B@Bk     .k@B@\n *             B@B@                                                                                       LB@@k         2i\n *              B@BM                                      .7jXEGqF7:                                     OB@@L\n *              .B@BM                                   .B@B@B@B@B@B@.                                 :@B@B:\n *               .B@B@                                   @@MYr::ivG@B                                .M@B@G\n *                 B@@@S                                                                           ,MB@B@,\n *                  v@@@BF                                                                      .1B@B@Br\n *                    2@@B@BL                                                                ,FB@@@B8,\n *                      r@B@B@BF,                                                        :YBB@B@B@B\n *                         L@B@B@B@P7,                                           .ivXB@B@B@B@B@M@B@\n *                            ,1B@B@B@B@@@BOP2L7i:,.              ..,:i7LSNB@@B@B@@@B@B@B@Z5v;.LB@@\n *                              @B@OEB@B@@@B@B@B@B@B@B@B@B@@@B@B@B@B@B@@@B@B@B@B@BM0SJ7i::::i:,u@B@\n *                              B@Bu ::i;7vu2XNGOMB@B@BMB@B@B@B@B@B@@@B1UFuj77ii:::::::iir;r;i.YB@B\n *                              @B@L.:i:i:i::::::::::..Y@B@BMYi:i;SB@B@N:.::i:iirir;r;rii::::ivO@B@\n *                              B@@X::,::::iirir;riri:E@B@1         ,@B@Br:;;r;rii:i::::i7JEB@@@@@B\n *                              @@@B@BBq5v7ii:::::::.2@@@i  ..,..     @B@@,,:::::irv2XMB@B@B@B@2@B@:\n *                             .B@BBB@@@B@B@B@BMNP5u7@B@1 .,,:,,  :.   @B@P50MB@B@B@B@B@@@BS:   @@B1\n *                             E@B@   ijGB@B@B@B@B@B@B@Bi .,:,,..@@B@7 B@B@B@B@B@B@BM57.        kB@B\n *                            .@B@:          .,ivu5Nq@B@u  ..,.. SB@B@@@B@PL7i,                 ,@B@\n *                            @@@8                   i@B@:    .     :B@B@@                       B@@2\n *                          i@@@@                     0@B@u          B@@B.                       vB@B\n *                         ,@B@G                       L@B@BOv:.:iFB@B@M                          @B@Bi\n *                          vNi                          S@@B@B@B@B@BM:                            MB@N\n *                                                          758BMqJ,\n *\n *                 .  YO.               vq                            :G       Z:\n *        SqOMBB@B@Br @@r rBE           @B     B@@@@@B@ONX8k    i::::.OB1.:::.u@O.::::i           @B@B@U:@@B@@BPEBu\n *        B@@NB@k.    5@i  uB@E.        BM     1U2uUJvirB@@Z   r@@B@B@@@B@B@B@B@B@@@B@Bi   LB@B@1 BX :@k uLLLvr@BJ:\n *            iB      iBi    7@     .@M8@BGMZZ         @@F            ,B       Pi          v@  Bq @i v@        B@\n *       vuL7r8@S7vJL7N@Z7LLri;72.   F7@Bvvv@@       @BX         @@@B@B@@@@@B@@@B@B@B      7@  @F Bi @q  @B@Bu @B\n *       N@B@G@@@8@BBOMB@G@BMNXG@,     B@   @@      .Bk          .:u;    i@:      Zv       7@  Bk @,;@  ,BY @B B@\n *            r@       @G     5.      ,@v   BZ :::,.r@E .::i,      @B     B@    .@BL       7@  @F B:i@. .@  @M @B\n *            7B: ,vO, @@   iB@:      @B   7@:MB@B@B@@@B@B@BM       @@.    B:  2@q         7@  BS @i 0@  B. @O B@\n *       ,r2EBB@B@B@Bi G@  @BB        B@   @B        @S              :    r@   ..          7B  @F @7  B7 @  @B @B\n *       E@B@UOBr       @B@Bi          L@0PB        .BZ        .@B@B@B@B@B@B@B@B@B@B@B@,   r@  BF @i  @G B@B@B B@\n *            7@,      kB@U    ;r        @@@.       .@Z                GBuL@iBBi           vB@B@q BP:5@7 @u,.  @B\n *            LBi   YB@BrB@    @@       @B:L@Br      BM             .M@B  rB  rB@J         v@. Pi @XZ8r  .     B@\n *        .   G@i B@BM.  ,B@,  @B    iB@B    N, 7r..q@k         ,LB@B8    J@,   i@B@B1r           Br           @@\n *        MB@B@B  ,i       B@B@B,    B@:        @B@B@F         .@BB:      P@i      :OBZ          .@U       B@B@B:\n *                          .ll                                           rB.                     :\n */\n/*\n██████████████████████████████████████████████████████████████████████████████\n██              ██████    ██████      ██      ██  ██    ██████              ██\n██  ██████████  ██  ██      ██      ██████████████  ██████  ██  ██████████  ██\n██  ██      ██  ██    ██  ████      ██    ██████████    ██  ██  ██      ██  ██\n██  ██      ██  ██    ██  ██      ██  ████        ██  ████  ██  ██      ██  ██\n██  ██      ██  ██  ██████  ████  ████████████  ██    ████████  ██      ██  ██\n██  ██████████  ██  ████  ██    ████    ████  ██████  ████  ██  ██████████  ██\n██              ██  ██  ██  ██  ██  ██  ██  ██  ██  ██  ██  ██              ██\n████████████████████  ██  ██    ██████  ██    ████  ████    ██████████████████\n██████  ████          ████        ██    ██    ████  ████████  ██          ████\n████  ██      ██  ██      ██  ██████  ████  ████    ██    ████    ████████  ██\n██      ██      ██    ██    ████      ████        ██████  ██      ██  ██    ██\n██  ██    ████████████  ████  ██  ████            ████  ████████████  ████  ██\n██  ██      ██  ██  ████    ████████                ████████      ██  ██    ██\n██  ██  ██  ██████████  ████    ██  ████  ██    ████  ████        ████  ██  ██\n██    ██  ████  ██████  ██    ******************    ████  ██            ██  ██\n██    ██████  ██  ██████      * Scan this QR   *██████    ██  ██  ██  ████████\n████  ████  ██  ██████      ██* code to join   *██  ████    ██  ████████  ████\n██████      ████████  ██      * in the Three   *██  ████          ████  ██  ██\n████              ████  ████  * Body ETO.      *  ████        ██  ████  ██  ██\n██████  ██    ████████        *  --ETO manager *██  ██                ██    ██\n████    ██  ██  ██    ██████  *    Ye Wenjie   *████  ████  ██  ████  ██  ████\n██  ████  ██████    ████  ██  *ETO(C),1988~2018*      ██  ██  ██  ██    ██████\n██  ██████  ██  ████    ██  ██******************          ██████    ██████  ██\n██  ██  ██    ████    ██        ██  ██        ████████      ████  ██  ██    ██\n████████████    ██    ██████  ██████████  ██  ████  ██████████    ██  ██  ████\n██████████    ██  ████  ██        ██    ██████████  ██    ██      ██  ██    ██\n██    ██  ████    ██  ████  ████      ██████    ██    ██      ██  ██  ████  ██\n██████  ██  ██████  ██            ██████████  ██    ██    ████  ████  ██    ██\n██      ██████  ████  ████  ████      ████    ████  ████            ██████████\n██████████████████      ██  ██  ████  ██    ██  ██    ████  ██████    ██    ██\n██              ██        ████████████  ████  ██  ██  ██    ██  ██      ██  ██\n██  ██████████  ██    ████  ██████  ██  ██████████████      ██████    ██  ████\n██  ██      ██  ████████    ██  ██      ████  ████  ██              ████  ████\n██  ██      ██  ████  ████  ████  ██████  ██████████████  ██████████    ██  ██\n██  ██      ██  ██    ██████  ██  ██  ██████████  ██  ██      ████    ██    ██\n██  ██████████  ██████  ████            ██    ████████  ██  ████    ██████████\n██              ██████    ████  ████████  ██  ████    ██    ██  ████  ████  ██\n██████████████████████████████████████████████████████████████████████████████\n    扫    描    二    维    码    加    入    三    体    E    T    O\n*/\n/*****************\n *   I<3   C++   *\n *  IWANT ANYAC  *\n * ILOVEPROGRAM! *\n *IT'SINTERESTING*\n * ILOVEPROGRAM! *\n *  INCONTESTS   *\n *   GETSCORE    *\n *    ACCODE     *\n *     LETS      *\n *      GO       *\n *Written by:    *\n *    charlieyan *\n *****************/\n#include <assert.h>\n#include <ctype.h>\n#include <errno.h>\n#include <float.h>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <locale>\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <wchar.h>\n#include <wctype.h>\n#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <cerrno>\n#include <clocale>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <limits>\n#include <map>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <istream>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <utility>\n#include <vector>\n#include <cwchar>\n#include <cwctype>\n#include <numeric>\n#include <list>\n#define LL long long\n#define pb push_back\n#define pob pop_back\n#define mp make_pair\n#define FILL(a,v) memset((void*)a,v,sizeof(a))\n#define FILL0(a) FILL(a,0)\n#define FILL1(a) FILL(a,-1)\n#define FILLBIG(a) FILL(a,0x3f)\n#define ALL(a) (a).begin(),(a).end()\n#define Inf ((int)0x3f3f3f3f)\n#define INF ((long long)0x3f3f3f3f3f3f3f3f)\n#define Mod 1000000007\n#define foreach(it,x) for(__typeof(x.begin()) it=x.begin();it!=x.end();it++)\n#define FOR(i,x) for(int i=0;i<x;i++)\n#define RFOR(i,x) for(int i=x-1;i>=0;i--)\n#define FFOR(i,a,b) for(int i=a;i<b;i++)\n#define FRFOR(i,a,b) for(int i=a-1;i>=b;i--)\n#define SZ(a) ((int)(a).size())\n#define FI first\n#define SE second\n#define OVER(...) return printf(__VA_ARGS__),0\n#define fastio ios::sync_with_stdio(0)\n#define filei(f) freopen(f,\"r\",stdin)\n#define fileo(f) freopen(f,\"w\",stdout)\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define MASK(a) (1<<(a))\n#define MASKX(x,a) ((x)<<(a))\n#define BIT(a,b) (((a)>>(b))&1)\n#define cddx(a) priority_queue<a >\n#define cxdd(a) priority_queue<a,vector<a >,greater<a > >\n#define deval(a) {cerr<<#a<<\" = \"<<a<<endl;}\n#define dearr(be,en) {cerr<<#be;cerr<<\" = {\";for(auto i=be;i!=en;i++)cerr<<' '<<*i;cerr<<\" }\\n\";}\n#define reg register\n#define prtime eprintf(\"\\n\\nTime used: %dms\\n\",clock());\n#define PI 3.1415926535897932384626\n#define TODEG(a) (a*180/PI)\n#define y0 ykangjimutigeidiqiuyipianjingtu\n#define y1 yxiaomiexuduhuanrenleiwannianankang\n#define endl '\\n'\n#define left leftxiaomiexudurenrenyouze\n#define hash hashxushibingduyouweilifushiyiqiedewuti\n//抗击母体，给地球一片净土\n//消灭徐毒，还人类万年安康\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef unsigned long long UINT;\ntypedef unsigned int uint;\ntypedef long long INT;\ntypedef long double ldouble;\ntypedef pair<INT,INT> PII;\ntypedef stringstream sst;\ntypedef istringstream iss;\ntypedef vector<int> vint;\ntypedef vector<INT> VINT;\ntypedef vector<pii> vpii;\ntypedef vector<PII> VPII;\ntypedef priority_queue<int> pqi;\ntypedef priority_queue<INT> PQI;\ntypedef priority_queue<pii> pqp;\ntypedef priority_queue<PII> PQP;\ntypedef priority_queue<int,vint,greater<int> > xqi;\ntypedef priority_queue<INT,VINT,greater<INT> > XQI;\ntypedef priority_queue<pii,vpii,greater<pii> > xqp;\ntypedef priority_queue<PII,VPII,greater<PII> > XQP;\nstruct fastIO\n{\n\tinline fastIO operator>>(int& num)\n\t{\n\t\tnum=0;\n\t\tchar c=getchar();\n\t\twhile(c!='-'&&(c<'0'||c>'9'))c=getchar();\n\t\tbool foo=0;\n\t\tif(c=='-')\n\t\t{\n\t\t\tfoo=1;\n\t\t\tc=getchar();\n\t\t}\n\t\twhile(c>='0'&&c<='9')\n\t\t{\n\t\t\tnum=(num<<3)+(num<<1)+c-'0';\n\t\t\tc=getchar();\n\t\t}\n\t\tif(foo)num=-num;\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(INT& num)\n\t{\n\t\tnum=0;\n\t\tchar c=getchar();\n\t\twhile(c!='-'&&(c<'0'||c>'9'))c=getchar();\n\t\tbool foo=0;\n\t\tif(c=='-')\n\t\t{\n\t\t\tfoo=1;\n\t\t\tc=getchar();\n\t\t}\n\t\twhile(c>='0'&&c<='9')\n\t\t{\n\t\t\tnum=(num<<3)+(num<<1)+c-'0';\n\t\t\tc=getchar();\n\t\t}\n\t\tif(foo)num=-num;\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(float& num)\n\t{\n\t\tscanf(\"%f\",&num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(double& num)\n\t{\n\t\tscanf(\"%lf\",&num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(long double& num)\n\t{\n\t\tscanf(\"%Lf\",&num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(char& num)\n\t{\n\t\tnum=getchar();\n\t\twhile(num==' '||num=='\\n')num=getchar();\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(char* num)\n\t{\n\t\tint cnt=0;\n\t\tchar c=getchar();\n\t\twhile(c==' '||c=='\\n')c=getchar();\n\t\twhile(c!=' '&&c!='\\n')\n\t\t{\n\t\t\tnum[cnt++]=c;\n\t\t\tc=getchar();\n\t\t}\n\t\tnum[cnt]=0;\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(string& num)\n\t{\n\t\tcin>>num;\n\t\treturn *this;\n\t}\n\tinline void printInt(const int& num)\n\t{\n\t\tif(num<10)\n\t\t{\n\t\t\tputchar(num+'0');\n\t\t\treturn;\n\t\t}\n\t\tprintInt(num/10);\n\t\tputchar((num%10)+'0');\n\t}\n\tinline void printINT(const INT& num)\n\t{\n\t\tif(num<10)\n\t\t{\n\t\t\tputchar(num+'0');\n\t\t\treturn;\n\t\t}\n\t\tprintINT(num/10);\n\t\tputchar((num%10)+'0');\n\t}\n\tinline fastIO operator<<(const int& num)\n\t{\n\t\tif(num<0)putchar('-'),printInt(-num);\n\t\telse printInt(num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const INT& num)\n\t{\n\t\tif(num<0)putchar('-'),printINT(-num);\n\t\telse printINT(num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const float& num)\n\t{\n\t\tprintf(\"%.10f\",num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const double& num)\n\t{\n\t\tprintf(\"%.16lf\",num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const long double& num)\n\t{\n\t\tprintf(\"%.20Lf\",num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const char& num)\n\t{\n\t\tputchar(num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const char* num)\n\t{\n\t\tfor(int i=0;num[i];i++)\n\t\t\tputchar(num[i]);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const string& num)\n\t{\n\t\tcout<<num;\n\t\treturn *this;\n\t}\n}fio;\n//Coded by Charlieyan\n//版权所有，翻印必究\n\nint n;\nint a[2005];\nint fin[2005];\nbool eg[2005][2005];\n\nvector<int> Merge(const vector<int> &a,const vector<int> &b){\n\tvector<int> c(SZ(a)+SZ(b),-1);\n\tint noa=0,nob=0;\n\tfor(int i=0;i<SZ(a)+SZ(b);i++){\n\t\tif(noa<SZ(a)&&(nob==SZ(b)||a[noa]>b[nob])){\n\t\t\tc[noa+nob]=a[noa];\n\t\t\tnoa++;\n\t\t}else{\n\t\t\tc[noa+nob]=b[nob];\n\t\t\tnob++;\n\t\t}\n\t}\n\treturn c;\n}\n\nvector<int> dfs(int now){\n\tfin[now]=1;\n\tvector<int> ans;\n\tfor(int i=0;i<n;i++){\n\t\tif(!fin[i]&&eg[now][i]){\n\t\t\tvector<int> fff=dfs(i);\n\t\t\tfff.insert(fff.begin(),a[i]);\n\t\t\tans=Merge(ans,fff);\n\t\t}\n\t}\n\treturn ans;\n}\n\nvoid solve(){\n\tsort(a,a+n);\n\tfor(int i=0;i<=n;i++){\n\t\tfor(int j=0;j<=n;j++){\n\t\t\tif(i!=j&&(i==n||j==n||__gcd(a[i],a[j])!=1)){\n\t\t\t\teg[i][j]=1;\n\t\t\t}\n\t\t}\n\t}\n\tauto ans=dfs(n);\n\tfor(int i=0;i<n;i++){\n\t\tprintf(\"%d%c\",ans[i],i==n-1?'\\n':' ');\n\t}\n}\n\nint main(){\n\tfio>>n;\n\tfor(int i=0;i<n;i++){\n\t\tfio>>a[i];\n\t}\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// This amazing code is by Eric Sunli Chen.\n#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\ntemplate<typename T> bool get_int(T &x)\n{\n\tchar t=getchar();\n\tbool neg=false;\n\tx=0;\n\tfor(; (t>'9'||t<'0')&&t!='-'&&t!=EOF; t=getchar());\n\tif(t=='-')neg=true,t=getchar();if(t==EOF)return false;\n\tfor(; t<='9'&&t>='0'; t=getchar())x=x*10+t-'0';\n\tif(neg)x=-x;return true;\n}\ntemplate<typename T> void print_int(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tshort a[20]= {},sz=0;\n\twhile(x>0)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1; i>=0; i--)putchar('0'+a[i]);\n}\n#define ff first\n#define ss second\n#define pb push_back\n#define mp make_pair\n#define get1(a) get_int(a)\n#define get2(a,b) (get1(a)&&get1(b))\n#define get3(a,b,c) (get1(a)&&get2(b,c))\n#define printendl(a) print_int(a),puts(\"\")\ntypedef long long LL;\ntypedef unsigned long long uLL;\ntypedef pair<int,int> pii;\nconst int inf=0x3f3f3f3f;\nconst LL Linf=1ll<<61;\nconst double pi=acos(-1.0);\n\n\nstruct Bitset\n{\n\tunsigned a[64];\n\tvoid reset(){memset(a,0,sizeof(a));}\n\tBitset(){reset();}\n\tvoid flip(int x){a[x>>5]^=1u<<(x&31);}\n\tvoid set(int x){a[x>>5]|=1u<<(x&31);}\n\tvoid reset(int x){a[x>>5]&=~(1u<<(x&31));}\n\tint test(int x){return (a[x>>5]>>(x&31))&1;}\n\tBitset operator ~()const\n\t{\n\t\tBitset ret;\n\t\tfor(int i=0;i<64;i++)ret.a[i]=~a[i];\n\t\treturn ret;\n\t}\n\tBitset operator &(const Bitset &b)const\n\t{\n\t\tBitset ret;\n\t\tfor(int i=0;i<64;i++)ret.a[i]=a[i]&b.a[i];\n\t\treturn ret;\n\t}\n\tBitset operator |(const Bitset &b)const\n\t{\n\t\tBitset ret;\n\t\tfor(int i=0;i<64;i++)ret.a[i]=a[i]|b.a[i];\n\t\treturn ret;\n\t}\n\tBitset operator ^(const Bitset &b)const\n\t{\n\t\tBitset ret;\n\t\tfor(int i=0;i<64;i++)ret.a[i]=a[i]^b.a[i];\n\t\treturn ret;\n\t}\n\tBitset operator <<(const int t)const\n\t{\n\t\tBitset ret;\n\t\tunsigned last=0;\n\t\tint high=t>>5,low=t&31;\n\t\tfor(int i=0;i+high<64;i++)\n\t\t{\n\t\t\tret.a[i+high]=last|(a[i]<<low);\n\t\t\tif(low)last=a[i]>>(32-low);\n\t\t}\n\t\treturn ret;\n\t}\n\tBitset operator >>(const int t)const\n\t{\n\t\tBitset ret;\n\t\tunsigned last=0;\n\t\tint high=t>>5,low=t&31;\n\t\tfor(int i=64-1;i>=high;i--)\n\t\t{\n\t\t\tret.a[i-high]=last|(a[i]>>low);\n\t\t\tif(low)last=a[i]<<(32-low);\n\t\t}\n\t\treturn ret;\n\t}\n\tint popcount()\n\t{\n\t\tint ret=0;\n\t\tfor(int i=0;i<64;i++)ret+=__builtin_popcount(a[i]);\n\t\treturn ret;\n\t}\n\tvoid ones(vector<int>&ret)const\n\t{\n\t\tret.clear();\n\t\tfor(int i=0;i<64;i++)\n\t\t{\n\t\t\tunsigned tmp=a[i];\n\t\t\twhile(tmp)\n\t\t\t{\n\t\t\t\tint t=__builtin_ctz(tmp);\n\t\t\t\tret.pb(t|(i<<5));\n\t\t\t\ttmp^=1u<<t;\n\t\t\t}\n\t\t}\n\t}\n};\n\nBitset con[2333],good;\nint n,a[2333],tot,cmp[2333],q[2333];\nbool ok[2333],use[2333];\npii best;\n\nint f[2333];\nint gf(int x){return x==f[x]?x:f[x]=gf(f[x]);}\npii getcomp()\n{\n\tmemset(cmp,0,sizeof(cmp));\n\ttot=0;best=mp(0,0);pii now;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(!ok[i]||cmp[i])continue;\n\t\ttot++;now=mp(inf,inf);\n\t\tBitset all;all.set(i);\n\t\tint front=0,rear=1;q[0]=i;\n\t\tvector<int> newv;\n\t\tfor(;front<rear;front++)\n\t\t{\n\t\t\tint x=q[front];cmp[x]=tot;if(good.test(x)||!use[gf(x)])now=min(now,mp(a[x],x));\n\t\t\t(con[x]&~all).ones(newv);all=all|con[x];\n\t\t\tfor(auto v:newv)q[rear++]=v;\n\t\t}\n\t\tbest=max(best,now);\n\t}\n\treturn best;\n}\nint main()\n{\n\tget1(n);\n\tfor(int i=1;i<=n;i++)get1(a[i]),f[i]=i;\n\tfor(int i=1;i<=n;i++)for(int j=1;j<=n;j++)if(i!=j&&__gcd(a[i],a[j])>1){con[i].set(j);f[gf(i)]=gf(j);}\n\tfor(int i=1;i<=n;i++)ok[i]=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tpii now=getcomp();good=good|con[now.ss];use[gf(now.ss)]=1;\n\t\tok[now.ss]=0;for(int j=1;j<=n;j++)con[j].reset(now.ss);\n\t\tprintf(\"%d \",now.ff);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define N 2010\ninline int read() {\n    int x=0;\n    char ch=getchar();\n    while (!isdigit(ch)) ch=getchar();\n    while (isdigit(ch)) x=x*10+ch-'0',ch=getchar();\n    return x;\n}\ninline int gcd(int x,int y) {\n    return y?gcd(y,x%y):x;\n}\nint f[N][N];\nint a[N],vis[N],ind[N];\nvector<int> v[N];\ninline void dfs(int x,int n) {\n    vis[x]=true;\n    for (int i=1;i<=n;i++) {\n        if (!f[x][i] || vis[i]) continue;\n        ind[i]++,v[x].push_back(i),dfs(i,n);\n    }\n}\ninline void Top(int n) {\n    priority_queue<int> q;\n    for (int i=1;i<=n;i++) \n        if (!ind[i]) q.push(i);\n    while (!q.empty()) {\n        int x=q.top(); q.pop();\n        printf(\"%d \",a[x]);\n        for (int i=0;i<v[x].size();i++) q.push(v[x][i]);\n    }\n}\nint main() {\n    int n=read();\n    for (int i=1;i<=n;i++) a[i]=read();\n    sort(a+1,a+n+1);\n    for (int i=1;i<=n;i++) {\n        for (int j=1;j<=n;j++) {\n            if (gcd(a[i],a[j])!=1) f[i][j]=true;\n        }\n    }\n    for (int i=1;i<=n;i++) \n        if (!vis[i]) dfs(i,n);\n    Top(n);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 2005;\n\ninline int gcd(int a, int b)\n{ return b == 0 ? a : gcd(b, a%b); }\n\nint n, a[MAXN], vis[MAXN];\nint b[MAXN], d[MAXN];\n\nvector<int> nxt, cur;\n\nstruct node {\n\tint to, next;\n} edge[MAXN];\nint head[MAXN], top = 0;\ninline void push(int i, int j)\n{ d[j]++, edge[++top] = (node) {j, head[i]}, head[i] = top; }\n\nvoid dfs(int nd)\n{\n\tvis[nd] = 1;\n\tfor (int i = 1; i <= n; i++)\n\t\tif (!vis[i] && gcd(a[i], a[nd]) > 1)\n\t\t\tpush(nd, i), dfs(i);\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++) {\n\t\tcin >> a[i];\n\t}\n\tsort(a+1, a+n+1);\n\tfor (int i = 1; i <= n; i++)\n\t\tif (!vis[i])\n\t\t\tdfs(i);\n\tmemset(vis, 0, sizeof vis);\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = n; j >= 1; j--)\n\t\t\tif (!vis[j] && !d[j]) {\n\t\t\t\tvis[j] = 1;\n\t\t\t\tcout << a[j] << \" \";\n\t\t\t\tfor (int k = head[j]; k; k = edge[k].next) {\n\t\t\t\t\tint to = edge[k].to;\n\t\t\t\t\td[to]--;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\tcout << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n,a[2010];\nvector<int> v[2010];\nbool vis[2010][2010],used[2010];\nvector<int> dp[2010];\n\ninline void dfs2(int u,int x)\n{\n\tvis[u][x]=1;\n\tfor(int i=0;i<v[x].size();i++) if(!used[v[x][i]]&&!vis[u][v[x][i]]){\n\t\tdfs2(u,v[x][i]);\n\t}\n}\n\ninline void dfs(int x)\n{\n\tused[x]=1;\n\tfor(int i=0;i<v[x].size();i++) if(!used[v[x][i]]&&!vis[x][v[x][i]]){\n\t\tdfs2(x,v[x][i]);\n\t\tdp[x].push_back(v[x][i]);\n\t}\n\tfor(int i=0;i<dp[x].size();i++) dfs(dp[x][i]);\n}\n\ninline void dfs3(int x)\n{\n\tif(x>0) cout<<a[x]<<\" \";\n\tfor(int i=dp[x].size()-1;i>=0;i--) dfs3(dp[x][i]);\n}\n\nsigned main()\n{\n\t//freopen(\"agc010e.in\",\"r\",stdin);\n\tios::sync_with_stdio(false);\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++){\n\t\tv[0].push_back(i);v[i].push_back(0);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=i+1;j<=n;j++){\n\t\t\tif(__gcd(a[i],a[j])>1){\n\t\t\t\tv[i].push_back(j);\n\t\t\t\tv[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tdfs(0);\n\tdfs3(0);\n\tcout<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<cstring>\n#include<algorithm>\n#include<queue>\n#define fo(i,a,b) for(i=a;i<=b;i++)\n#define ll long long\nusing namespace std;\nint n,a[2005],tot,du[2005],h[2005],to[4000005],nex[4000005];\nbool bhz[2005][2005],pd[2005];\nint gcd(int a,int b)\n{\n    return b?gcd(b,a%b):a;\n}\nstruct node{\n    int fr,id;\n}st;\nbool operator <(node a,node b)\n{\n    return a.fr<b.fr;\n}\npriority_queue<node> q;\nvoid add(int a,int b)\n{\n    du[b]++;\n    to[++tot]=b;\n    nex[tot]=h[a];\n    h[a]=tot;\n}\nvoid dfs(int x)\n{\n    pd[x]=1;\n    for(int i=1;i<=n;i++)\n        if(bhz[x][i]&&!pd[i])\n        {\n            add(x,i);\n            dfs(i);\n        }\n}\nint main()\n{\n    cin>>n;\n    for(int i=1;i<=n;i++) cin>>a[i];\n    sort(a+1,a+n+1);\n    for(int i=1;i<=n-1;i++)\n    for(int j=i+1;j<=n;j++)\n    if(gcd(a[i],a[j])>1) bhz[i][j]=bhz[j][i]=1;\n    for(int i=1;i<=n;i++) if(!pd[i]) dfs(i);\n    for(int i=1;i<=n;i++) \n        if(!du[i])\n        { \n            st.fr=a[i];\n            st.id=i;\n            q.push(st); \n        }\n    for(int i=1;i<=n;i++)\n    {\n        st=q.top();\n        q.pop();\n        int now=st.id;\n        cout<<a[now]<<\" \";\n//        for(int k=h[now];k;k=nex[k])\n//        {\n//            du[to[k]]--;\n//            if(!du[to[k]])\n//            {\n//                st.fr=a[to[k]];\n//                st.id=to[k];\n//                q.push(st);\n//            }\n//        }\n        int t=h[now];\n        while (t){\n            du[to[t]]--;\n            if (!du[to[t]]){\n                st.fr=a[to[t]];\n                st.id=to[t];\n                q.push(st);\n            }\n            t=nex[t];\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#include <vector>\n\nusing namespace std;\n\ntypedef vector<int> V;\n\nconst int N=2005;\nconst int E=N*N;\n\nV seq[N];\n\nint tov[E],nxt[E];\nint num[N],id[N];\nbool vis[N];\nint last[N];\nint n,tot,rt;\n\ninline bool cmp(int x,int y){return num[x]<num[y];}\n\ninline void insert(int x,int y){tov[++tot]=y,nxt[tot]=last[x],last[x]=tot;}\n\nint gcd(int x,int y){return y?gcd(y,x%y):x;}\n\ninline void merge(V a,V b,V &ret)\n{\n\tret.resize(0),ret.reserve(a.size()+b.size());\n\tvector<int>::iterator ita=a.begin(),itb=b.begin();\n\tfor (;ita!=a.end()||itb!=b.end();)\n\t\tif (ita==a.end()||itb!=b.end()&&num[*itb]>num[*ita]) ret.push_back(*itb),++itb;\n\t\telse ret.push_back(*ita),++ita;\n}\n\nvoid dfs(int x)\n{\n\tV son;vis[x]=1;\n\tfor (int i=last[x];i;i=nxt[i]) son.push_back(tov[i]);\n\tsort(son.begin(),son.end(),cmp);\n\tfor (int i=0,y;i<(int)son.size();++i)\n\t\tif (!vis[y=son[i]]) dfs(y),merge(seq[y],seq[x],seq[x]);\n\tseq[x].insert(seq[x].begin(),x);\n}\n\nint main()\n{\n\t//freopen(\"rearranging.in\",\"r\",stdin),freopen(\"rearranging.out\",\"w\",stdout);\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;++i) scanf(\"%d\",&num[i]),id[i]=i;\n\tsort(id+1,id+1+n,cmp);\n\tfor (int i=1;i<n;++i)\n\t\tfor (int j=i+1;j<=n;++j)\n\t\t\tif (gcd(num[i],num[j])!=1) insert(i,j),insert(j,i);\n\trt=0;\n\tfor (int i=1,x;i<=n;++i)\n\t\tif (!vis[x=id[i]]) dfs(x),merge(seq[rt],seq[x],seq[x]),rt=x;\n\tfor (int i=0;i<(int)seq[rt].size();++i) printf(\"%d%c\",num[seq[rt][i]],i+1<(int)seq[rt].size()?' ':'\\n');\n\t//fclose(stdin),fclose(stdout);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define all(x)  x.begin(),x.end()\n#define sz(x)   x.size()\n#define pb      push_back\n\nconst int   N   = 2e3 + 1;\n\ntypedef long long   ll;\ntypedef vector<int> vi;\n\nll  gcd(ll a,ll b)  {\n    return !a ? b : gcd(b % a,a);\n}\n\nvi  mer(vi a,vi b)  {\n    vi c;\n    int i = 0, j = 0;\n    while(i < sz(a) && j < sz(b))   {\n        if(a[i] < b[j]) c.pb(b[j++]);\n        else            c.pb(a[i++]);\n    }\n    while(i < sz(a))    c.pb(a[i++]);\n    while(j < sz(b))    c.pb(b[j++]);\n    return c;\n}\n\nvector<int> g[N], ar[N];\n\nll  a[N];\nint p[N], n;\n\nvoid dfs(int u) {\n    for(int v : g[u])\n        if(v != p[u] && p[v] < 0)   {\n            p[v] = u;\n            dfs(v);\n        }\n}\n\nvoid sol(int u) {\n    ar[u].push_back(u);\n    vector<int> res;\n    for(int v : g[u])\n        if(p[v] == u)   {\n            sol(v);\n            res = mer(res,ar[v]);\n        }\n    for(int i = 0 ; i < sz(res) ; ++i)\n        ar[u].pb(res[i]);\n}\n\nint main()  {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    cin >> n;\n\n    for(int i = 1 ; i <= n ; ++i)\n        cin >> a[i];\n\n    sort(a + 1,a + 1 + n);\n\n    int j = 1;\n    while(a[j] < 2) ++j;\n\n    vector<int> res(j - 1,1);\n\n    n -= (j - 1);\n    for(int i = 1 ; i <= n ; ++i)\n        a[i] = a[i + j - 1];\n\n    for(int i = 0 ; i <= n ; ++i)\n        for(int j = 0 ; j <= n ; ++j)    {\n            if(i == j || gcd(a[i],a[j]) < 2)\n                continue;\n            g[i].pb(j);\n        }\n\n    memset(p,-1,sizeof p);\n    p[0] = 0;\n    dfs(0);\n    sol(0);\n\n    for(int i = sz(ar[0]) - 1 ; i ; --i)\n        res.pb(a[ar[0][i]]);\n\n    reverse(all(res));\n    for(int i = 0 ; i < sz(res) ; ++i)\n        cout << res[i] << ' ';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int maxn = 2030, maxm = 54010, oo = 123456789;\n\nint n, m, K, a[maxn], q[maxm], rar, mn, rem, id[maxm];\nbool vis[maxn], f[maxn], inq[maxm];\nstd::vector<int> has[maxm], con[maxn], all, ans[maxn];\n\nvoid dfs(int u) {\n\tif(vis[u]) {\n\t\treturn;\n\t}\n\tif(a[u] < mn) {\n\t\tmn = a[u];\n\t\trem = u;\n\t}\n\tvis[u] = 1;\n\tfor (int i: con[u]) {\n\t\tfor (int j: has[i]) {\n\t\t\tdfs(j);\n\t\t}\n\t}\n\treturn;\n}\n\nvoid work(int u) {\n//\tprintf(\"work(%d)\\n\", u);\n\tif(a[u] == 1) {\n\t\tans[K].push_back(1);\n\t\tvis[u] = f[u] = 1;\n\t\treturn;\n\t}\n\tmn = oo;\n\tdfs(u);\n\trar = 0;\n//\tprintf(\"%d\\n\", rem);\n\tfor (int i: con[u]) {\n\t\tq[rar++] = i;\n\t}\n//\tprintf(\"rar = %d\\n\", rar);\n\tfor(;;) {\n\t\tmn = oo;\n\t\tfor (int i = 0; i < rar; ++i) {\n\t\t\tint j = q[i];\n//\t\t\tprintf(\"\\t\\t%d\\n\", j);\n\t\t\twhile(id[j] < (int)(has[j].size()) && f[has[j][id[j]]]) {\n\t\t\t\t++id[j];\n\t\t\t}\n\t\t\tif(id[j] < (int)has[j].size()) {\n\t\t\t\tint k = has[j][id[j]];\n\t\t\t\tif(a[k] < mn) {\n\t\t\t\t\tmn = a[k];\n\t\t\t\t\trem = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(mn == oo) {\n\t\t\treturn;\n\t\t}\n\t\t//printf(\"\\t%d\\n\", mn);\n\t\tans[K].push_back(mn);\n\t\tint i = has[rem][id[rem]++];\n\t\tfor (int j: con[i]) {\n\t\t\tif(!inq[j]) {\n\t\t\t\tq[rar++] = j;\n\t\t\t}\n\t\t}\n\t\tf[i] = 1;\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tscanf(\"%d\", a + i);\n\t\tfor (int x = 2; x * x <= a[i]; ++x) {\n\t\t\tif(a[i] % x == 0) {\n\t\t\t\tall.push_back(x);\n\t\t\t\tall.push_back(a[i] / x);\n\t\t\t}\n\t\t}\n\t\tif(a[i] > 1) {\n\t\t\tall.push_back(a[i]);\n\t\t}\n\t}\n\tsort(all.begin(), all.end());\n\tall.resize(unique(all.begin(), all.end()) - all.begin());\n\tm = (int)(all.size());\n\tfor (int j = 0; j < m; ++j) {\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tif(a[i] % all[j] == 0) {\n\t\t\t\thas[j].push_back(i);\n\t\t\t\tcon[i].push_back(j);\n\t\t\t}\n\t\t}\n\t\tsort(has[j].begin(), has[j].end(), [&](int i, int j) {\n\t\t\treturn a[i] < a[j];\n\t\t});\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif(!vis[i]) {\n\t\t\twork(i);\n\t\t\treverse(ans[K].begin(), ans[K].end());\n\t\t\t++K;\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; ++i)  {\n\t\tint mx = 0, rem;\n\t\tfor (int j = 0; j < K; ++j) {\n\t\t\tif((int)(ans[j].size())) {\n\t\t\t\tif(ans[j].back() > mx) {\n\t\t\t\t\tmx = ans[j].back();\n\t\t\t\t\trem = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d%c\", mx, \" \\n\"[i == n]);\n\t\tans[rem].pop_back();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<queue>\n#define fo(i,a,b) for(i=a;i<=b;i++)\nusing namespace std;\nconst int maxn=2000+10;\nstruct dong{\n    int x,y;\n    friend bool operator <(dong a,dong b){\n        return a.x<b.x;\n    }\n} zlt;\npriority_queue<dong> dl;\nbool bz[maxn][maxn],pd[maxn];\nint a[maxn],d[maxn];\nint h[maxn],go[maxn*maxn],nxt[maxn*maxn];\nint i,j,k,l,t,n,m,tot,now;\nint gcd(int a,int b){\n    return b?gcd(b,a%b):a;\n}\nvoid add(int x,int y){\n    d[y]++;\n    go[++tot]=y;\n    nxt[tot]=h[x];\n    h[x]=tot;\n}\nvoid dfs(int x){\n    pd[x]=1;\n    int i;\n    fo(i,1,n)\n        if (bz[x][i]&&!pd[i]){\n            add(x,i);\n            dfs(i);\n        }\n}\nint main(){\n    scanf(\"%d\",&n);\n    fo(i,1,n) scanf(\"%d\",&a[i]);\n    sort(a+1,a+n+1);\n    fo(i,1,n-1)\n        fo(j,i+1,n)\n            if (gcd(a[i],a[j])>1) bz[i][j]=bz[j][i]=1;\n    fo(i,1,n)\n        if (!pd[i]) dfs(i);\n    fo(i,1,n)\n        if (!d[i]){\n            zlt.x=a[i];\n            zlt.y=i;\n            dl.push(zlt);\n        }\n    fo(i,1,n){\n        zlt=dl.top();\n        dl.pop();\n        now=zlt.y;\n        printf(\"%d \",a[now]);\n        t=h[now];\n        while (t){\n            d[go[t]]--;\n            if (!d[go[t]]){\n                zlt.x=a[go[t]];\n                zlt.y=go[t];\n                dl.push(zlt);\n            }\n            t=nxt[t];\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<queue>\nusing namespace std;\n#define MAXN 2010\nint gcd(int a,int b)\n{\n\twhile(b)\n\t{\n\t\tint t=a;a=b;b=t%b;\n\t}\n\treturn a;\n}\nint a[MAXN],g[MAXN][MAXN],du[MAXN],vis[MAXN],n;\nvector<int>G[MAXN];\nvoid dfs(int u)\n{\n\tvis[u]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tif(!vis[i]&&g[u][i])\n\t\t{\n\t\t\tG[u].push_back(i);\n\t\t\tdu[i]++;\n\t\t\tdfs(i);\n\t\t}\n}\npriority_queue<int>Q;\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tsort(a+1,a+1+n);\n\tfor(int i=1;i<n;i++)\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\tif(gcd(a[i],a[j])!=1)\n\t\t\t\tg[i][j]=g[j][i]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tif(!vis[i])\n\t\t\tdfs(i);\n\tfor(int i=1;i<=n;i++)\n\t\tif(!du[i])\n\t\t\tQ.push(i);\n\twhile(!Q.empty())\n\t{\n\t\tint u=Q.top();Q.pop();\n\t\tprintf(\"%d \",a[u]);\n\t\tfor(int i=0;i<G[u].size();i++)\n\t\t\tQ.push(G[u][i]);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define ll long long\n\n#define maxN 2017\n\nint n, nn, i, j;\nint a[maxN];\nvector<int> adj[maxN];\n\nvector<int> ans[maxN], aux;\nbool us[maxN];\n\n\nint cmmdc(int a, int b) {\n    if (a < b) swap(a, b);\n\n    while (b != 0) {\n        a %= b;\n        swap(a, b);\n    }\n\n    return a;\n}\n\nvoid dfs(int node) {\n    us[node] = true;\n\n    ans[node] = {};\n    sort(adj[node].begin(), adj[node].end());\n\n    for (auto to : adj[node]) {\n        if (us[to]) continue;\n\n        dfs(to);\n        aux = ans[node];\n        ans[node].resize(ans[node].size() + ans[to].size());\n        merge(aux.begin(), aux.end(),\n              ans[to].begin(), ans[to].end(),\n              ans[node].begin(), [](int a, int b)->bool const {return a > b;});\n    }\n\n    if (node != 0)\n        ans[node].insert(ans[node].begin(), a[node]);\n}\n\n\nint main()\n{\n  //  freopen(\"test.in\",\"r\",stdin);\n\n    scanf(\"%d\", &n);\n    for (i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n    sort(a + 1, a + n + 1);\n\n    for (i = 1; i <= n; i++) {\n        for (j = i + 1; j <= n; j++) {\n            if (cmmdc(a[i], a[j]) != 1) {\n                adj[i].pb(j);\n                adj[j].pb(i);\n            }\n        }\n\n        adj[0].pb(i);\n        adj[i].pb(0);\n    }\n\n    dfs(0);\n\n    for (auto e : ans[0]) printf(\"%d \", e);\n\n\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<cstring>\n#include<algorithm>\n#include<queue>\n#define fo(i,a,b) for(i=a;i<=b;i++)\n#define ll long long\nusing namespace std;\nint n,a[2005],tot,du[2005],h[2005],to[4000005],nex[4000005];\nbool bhz[2005][2005],pd[2005];\nint gcd(int a,int b)\n{\n    return b?gcd(b,a%b):a;\n}\nstruct node{\n    int fr,id;\n}st;\nbool operator <(node a,node b)\n{\n    return a.fr<b.fr;\n}\npriority_queue<node> q;\nvoid add(int a,int b)\n{\n    du[b]++;\n    to[++tot]=b;\n    nex[tot]=h[a];\n    h[a]=tot;\n}\nvoid dfs(int x)\n{\n    pd[x]=1;\n    for(int i=1;i<=n;i++)\n        if(bhz[x][i]&&!pd[i])\n        {\n            add(x,i);\n            dfs(i);\n        }\n}\nint main()\n{\n    cin>>n;\n    for(int i=1;i<=n;i++) cin>>a[i];\n    sort(a+1,a+n+1);\n    for(int i=1;i<=n-1;i++)\n    for(int j=i+1;j<=n;j++)\n    if(gcd(a[i],a[j])>1) bhz[i][j]=bhz[j][i]=1;\n    for(int i=1;i<=n;i++) if(!pd[i]) dfs(i);\n    for(int i=1;i<=n;i++) \n        if(!du[i])\n        { \n            st.fr=a[i];\n            st.id=i;\n            q.push(st); \n        }\n    for(int i=1;i<=n;i++)\n    {\n        st=q.top();\n        q.pop();\n        int now=st.id;\n        cout<<a[now]<<\" \";\n        int t=h[now];\n        while (t){\n            du[to[t]]--;\n            if (!du[to[t]]){\n                st.fr=a[to[t]];\n                st.id=to[t];\n                q.push(st);\n            }\n            t=nex[t];\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\ntypedef long long ll ;\n#define rep(i, a, b) for (int i = a ; i <= b; ++ i) \nconst int N = 2005, inf = 1e9 + 7 ;\nusing namespace std ;\n\nint n, a[N], cnt ;\nbool G[N][N], vis[N] ;\n\nint gcd(int x, int y) {\n\treturn (y ? gcd(y, x % y) : x) ;\n}\n\nvector <int> dfs(int p) {\n\tvis[p] = false ;\n\tvector <int> res, A, B ;\n\tres.push_back(a[p]) ;\n\trep(i, 0, n) A.push_back(0) ;\n\trep(u, 1, n) if (G[p][u] && vis[u]) {\n\t\tB = dfs(u) ;\n\t\tint na = (int) res.size() - 2, nb = (int) B.size() - 1, topa = 0, topb = 0 ;\n\t\trep(i, 0, na) A[i] = res[i + 1] ;\n\t\trep(i, 1, nb + 1) res.push_back(0) ;\n\t\trep(i, 1, na + nb + 2) {\n\t\t\tif (topa <= na && (topb > nb || A[topa] >= B[topb])) res[i] = A[topa ++] ; else res[i] = B[topb ++] ;\n\t\t} \n\t}\n\treturn res ;\n}\n\nint main() {\n\tscanf(\"%d\", &n) ;\n\tcnt = 0 ;\n\trep(i, 1, n) scanf(\"%d\", &a[i]) ; sort(a + 1, a + n + 1) ;\n\trep(i, 0, n) G[i][0] = G[0][i] = vis[i] = true ;\n\trep(i, 1, n) rep(j, 1, n) G[i][j] = G[j][i] = (gcd(a[i], a[j]) != 1) ;\n\tvector <int> ans = dfs(0) ;\n\trep(i, 0, n - 1) printf(\"%d \", ans[i + 1]) ; puts(\"\") ;\n\treturn 0 ; \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define MN 2000\nusing namespace std;\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\ninline int gcd(int x,int y){return y?gcd(y,x%y):x;}\nint n,a[MN+5],head[MN+5],cnt=0,mark[MN+5],res,vis[MN+5],used[MN+5];\nstruct edge{int to,next;}e[MN*MN*2+5];\ninline void ins(int f,int t)\n{\n\te[++cnt]=(edge){t,head[f]};head[f]=cnt;\n\te[++cnt]=(edge){f,head[t]};head[t]=cnt;\t\n}\nvoid Mark(int x)\n{\n\tmark[x]=0;\n\tfor(int i=head[x];i;i=e[i].next)\n\t\tif(mark[e[i].to]&&!used[e[i].to]) Mark(e[i].to);\n}\nvoid dfs(int x,int v)\n{\n\tvis[x]=v;if(mark[x]==v-1&&a[x]<a[res]) res=x;\n\tfor(int i=head[x];i;i=e[i].next)\n\t\tif(vis[e[i].to]!=v&&!used[e[i].to]) dfs(e[i].to,v); \n}\nint main()\n{\n\tn=read();a[0]=int(1e9);\n\tfor(int i=1;i<=n;++i) a[i]=read();\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=i+1;j<=n;++j) \n\t\t\tif(gcd(a[i],a[j])>1) ins(i,j);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tint mx=0,from=0;\n\t\tfor(int j=1;j<=n;++j)\n\t\t\tif(!used[j]&&vis[j]!=i) res=0,dfs(j,i),a[res]>mx?(mx=a[res],from=res):0;\n\t\tprintf(\"%d \",mx);used[from]=1;\n\t\tfor(int j=1;j<=n;++j) mark[j]=i;\n\t\tMark(from);\n\t\tfor(int j=head[from];j;j=e[j].next) mark[e[j].to]=i;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"Ofast\")\n#include <iostream>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <set>\n#include <queue>\n#define rep(x, a, b) for(int x = (a); x <= (b); ++x)\n#define rop(x, a, b) for(int x = (a); x < (b); ++x)\n#define per(x, a, b) for(int x = (a); x >= (b); --x)\nusing namespace std;\ntypedef long long LL;\ntypedef double DB;\npriority_queue<int> PQ;\nint a[2005], rd[2005];\nstruct graph {\n\tset<int> S[2005], E[2005];\n\tint vs[2005];\n\tvoid push(int x, int y) {\n\t\tS[x].insert(y);\n\t}\n\tvoid dfs(int nw) {\n\t\tvs[nw] = 1;\n\t\tauto IT = S[nw].begin();\n\t\twhile(IT != S[nw].end()) {\n\t\t\tif(vs[*IT]) {++IT; continue;}\n\t\t\t++rd[*IT];\n\t\t\tE[nw].insert(*IT);\n\t\t\tdfs(*IT);\n\t\t\t++IT;\n\t\t}\n\t}\n\tvoid tuopu() {\n\t\tPQ.push(0);\n\t\twhile(PQ.size()) {\n\t\t\tint nw = PQ.top();\n\t\t\tif(nw) printf(\"%d \", a[nw]);\n\t\t\tPQ.pop();\n\t\t\tauto IT = E[nw].begin();\n\t\t\twhile(IT != E[nw].end()) {\n\t\t\t\t--rd[*IT];\n\t\t\t\tif(rd[*IT] == 0) PQ.push(*IT);\n\t\t\t\t++IT;\n\t\t\t}\n\t\t}\n\t}\n}G;\nint n;\nint main() {\n\tscanf(\"%d\", &n);\n  sort(a + 1, a + 1 + n);\n\trep(i, 1, n) scanf(\"%d\", &a[i]);\n\trep(i, 1, n) rep(j, 1, n) if(i != j && __gcd(a[i], a[j]) != 1) G.push(i, j); \n\trep(i, 1, n) G.push(0, i), G.push(i, 0);\n\tG.dfs(0);\n\tG.tuopu();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nbool coprime[2222][2222];\nbool used[2222];\n\nint gcd(int a, int b){\n\treturn b == 0 ? a : gcd(b,a%b);\n}\n\nint main(){\n\n\tint n;cin >> n;\n\tvector<int> v(n);REP(i,n)cin >> v[i];\n\tsort(ALL(v),greater<int>());\n\n\tREP(i,n){\n\t\tfor(int j = i+1;j < n;j++){\n\t\t\tif(gcd(v[i], v[j]) == 1){\n\t\t\t\tcoprime[i][j] = true;\n\t\t\t\tcoprime[j][i] = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<int> ans;\n\tREP(i,n){\n\t\tif(!used[i]){\n\t\t\tpriority_queue<P> q;\n\t\t\tused[i] = true;\n\t\t\tq.push(MP(v[i],i));\n\t\t\twhile(!q.empty()){\n\t\t\t\tauto now = q.top();q.pop();\n\t\t\t\tans.PB(now.FI);\n\t\t\t\tREP(j,n){\n\t\t\t\t\tif(!used[j] && !coprime[now.SE][j]){\n\t\t\t\t\t\tused[j] = true;\n\t\t\t\t\t\tq.push(MP(v[j],j));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treverse(ALL(ans));\n\t//SHOW1d(ans,n);\n\n\tREP(i,n){\n\t\tREP(j,n-1){\n\t\t\tif(gcd(ans[j],ans[j+1]) == 1 && ans[j] < ans[j+1]){\n\t\t\t\tswap(ans[j],ans[j+1]);\n\t\t\t}\n\t\t}\n\t}\n\n\tREP(i,n)cout << ans[i] << \" \";cout << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nvector<int> e[2010];\nint a[2010];\nbool vis[2010];\n\nvector<int> merge(vector<int> &x,vector<int> &y){\n\tint xidx=0,yidx=0;\n\tvector<int> z;\n\twhile(xidx<x.size()&&yidx<y.size())\n\t\tif(x[xidx] > y[yidx])\n\t\t\tz.emplace_back(x[xidx++]);\n\t\telse\n\t\t\tz.emplace_back(y[yidx++]);\n\twhile(xidx<x.size())\n\t\tz.emplace_back(x[xidx++]);\n\twhile(yidx<y.size())\n\t\tz.emplace_back(y[yidx++]);\n\treturn z;\n}\n\nvector<int> dfs(int x){\n\tvis[x]=true;\n\tvector<int> res;\n\tfor(int u:e[x])\n\t\tif(!vis[u]){\n\t\t\tvector<int> cur = dfs(u);\n\t\t\tres = merge(res,cur);\n\t\t}\n\tif(x!=0){\n\t\tres.emplace_back(0);\n\t\tfor(int i=(int)res.size()-1;i>0;i--)\n\t\t\tres[i] = res[i-1];\n\t\tres[0] = x;\n\t}\n\treturn res;\n}\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n;\n\tcin>>n;\n\tfor(int i=1;i<=n;i++)\n\t\tcin>>a[i];\n\tfor(int i=1;i<=n;i++)\n\t\te[0].emplace_back(i);\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(gcd(a[i],a[j]) != 1)\n\t\t\t\te[i].emplace_back(j);\n\tvector<int> res = dfs(0);\n\tfor(int x:res)\n\t\tcout<<a[x]<<' ';\n\tcout<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<set>\n#include<unordered_set>\n#define lol(i,n) for(ll i=0;i<n;i++)\n#define mod 1000000007\n#define chmax(a,b) a=max(a,b);\n#define chmin(a,b) a=min(a,b);\ntypedef long long ll;\n\nusing namespace std;\nll gcd(ll a,ll b){\n  if(a<b)swap(a,b);\n  if(b==0)return a;\n  return gcd(a%b,b);\n}\n#define N 2010\nll b[N],a[N],n;\nvector<ll> g[N];\n\nclass Aoki{\n  public:\n  ll nz[N];\n  void buildg(){\n    lol(i,n)g[i].clear();\n    lol(i,n)lol(j,i){\n      if(gcd(b[i],b[j])>1){\n\tg[j].push_back(i);\n\tnz[i]++;\n      }\n    }\n  }\n  void main(){\n    lol(i,n)nz[i]=0;\n    buildg();\n    priority_queue<pair<ll,ll> >Q;\n    lol(i,n)if(nz[i]==0)Q.push(make_pair(b[i],i));\n    vector<ll> res;\n    unordered_set<ll> vis;\n    while(!Q.empty()){\n      ll val=Q.top().first;\n      ll x=Q.top().second;\n      Q.pop();\n      if(vis.find(x)!=vis.end())continue;\n      vis.insert(x);\n      res.push_back(val);\n      for(auto y:g[x]){\n\tnz[y]--;\n\tif(nz[y]==0)Q.push(make_pair(b[y],y));\n      }\n    }\n    lol(i,n){\n      if(i)cout<<\" \";\n      cout<<res[i];\n    }cout<<endl;\n  }\n};Aoki kensho;\n\nclass Takahashi{\n  public:\n  void buildg(){\n    lol(i,n)lol(j,n){\n      if(i!=j&&gcd(a[i],a[j])>1){\n\tg[i].push_back(j);\n      }\n    }\n    lol(i,n)sort(g[i].begin(),g[i].end());\n  }\n  unordered_set<ll> vis;\n  vector<ll> res;\n  void dfs(ll x){\n      if(vis.find(x)!=vis.end())return;\n      vis.insert(x);\n      res.push_back(x);\n      for(auto y:g[x])dfs(y);\n  }\n  void main(){\n    buildg();\n    lol(i,n)dfs(i);\n    lol(i,n)b[i]=a[res[i]];\n  }\n};Takahashi chokudai;\n\nint main(){\n    cin>>n;\n    lol(i,n)cin>>a[i];\n    sort(a,a+n);\n    chokudai.main();\n    kensho.main();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(2)\n// Happy TLE and WA every day!\n// by: zxb the vegetable chicken\n#include<bits/stdc++.h>\n#define mp\t\t\t\tmake_pair\n#define rep(i,n)\t\tfor(int i = 0; i < n; i++)\n#define foreach(i,c)\tfor(VAR(i, (c).begin()); i != (c).end(); ++i)\n#define BINF\t\t\t0x7fffffff\n#define INF\t\t\t\t0x3f3f3f3f\n#define LINF\t\t\t3223372036854775807\n#define END(s)\t\t\t{cout<<s; return 0;}\n#define CON(s)\t\t\t{cout<<s; continue;}\n#define BRE(s)\t\t\t{cout<<s; break;}\n#define pb\t\t\t\tpush_back\n//#define int\t\t\t\tlong long\n#define All(a)\t\t\ta.begin(), a.end()  //with A in CAPITAL!!!\n#define sz(a)\t\t\t(int)a.size()\n#define F\t\t\t\tfirst\n#define S\t\t\t\tsecond\n//#define usingFiles\nusing namespace std;\n\nconst int rp = 666666;\nconst bool debug = 1;\nconst bool I_good_vegetable_a = 1;\n\nint a[2020];\nint n;\nvector<int> v[2020];\nint ltksize;\nbool used[2020];\nvector<int> ltk[2020];\nvector<pair<int, int> > ans;\nint cnt = 0;\nint num = 0;\n\nint count(int now){\n\tint ans = 1;\n\tused[now] = true;\n\trep(i, v[now].size()){\n\t\tif(!used[v[now][i]]) ans += count(v[now][i]);\n\t}\n\treturn ans;\n}\n\nvoid uncount(int now){\n\tused[now] = false;\n\trep(i, v[now].size()){\n\t\tif(used[v[now][i]]) uncount(v[now][i]);\n\t}\n}\n\nbool dfs(int now){\n\tused[now] = true;\n\tnum++;\n\tif(num == ltksize){\n\t\tltk[cnt].pb(now);\n\t\treturn 1;\n\t}\n\trep(i, v[now].size()){\n\t\tif(used[v[now][i]]) continue;\n\t\tif(dfs(v[now][i])){\n\t\t\tltk[cnt].pb(now);\n\t\t\treturn 1;\n\t\t}\n\t}\n\tused[now] = false;\n\treturn 0;\n}\n\nbool cmp(pair<int, int> a, pair<int, int> b){\n\treturn a > b;\n}\n\nsigned main(){\n\tios::sync_with_stdio(false);\n\t#ifdef usingFiles\n\t\tfreopen(\"input.txt\", \"r\", stdin);\n\t\tfreopen(\"output.txt\", \"w\", stdout);\n\t#endif\n\tcin >> n;\n\trep(i, n) cin >> a[i];\n\trep(i, n){\n\t\tfor(int j = 0; j < i; j++){\n\t\t\tif(__gcd(a[i], a[j]) > 1){\n\t\t\t\tv[i].pb(j);\n\t\t\t\tv[j].pb(i);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, n){\n\t\tsort(v[i].begin(), v[i].end());\n\t}\n\trep(i, n){\n\t\tif(!used[i]){\n\t\t\tltksize = count(i);\n\t\t\tuncount(i);\n\t\t\tnum = 0;\n\t\t\tdfs(i);\n\t\t\treverse(ltk[cnt].begin(), ltk[cnt].end());\n\t\t\tans.pb(mp(a[ltk[cnt][0]], cnt));\n\t\t\tcnt++;\n\t\t}\n\t}\n\tsort(ans.begin(), ans.end(), cmp);\n\trep(i, ans.size()){\n\t\trep(j, ltk[ans[i].S].size()){\n\t\t\tcout << a[ltk[ans[i].S][j]] << \" \"; \n\t\t}\n\t}\n\tcout << endl;\n\treturn 0;\n}\n/*\n5\n1 2 3 4 5\n*/"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"Ofast\")\n#include <iostream>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <set>\n#include <queue>\n#define rep(x, a, b) for(int x = (a); x <= (b); ++x)\n#define rop(x, a, b) for(int x = (a); x < (b); ++x)\n#define per(x, a, b) for(int x = (a); x >= (b); --x)\nusing namespace std;\ntypedef long long LL;\ntypedef double DB;\npriority_queue<int> PQ;\nint a[2005], rd[2005];\nstruct graph {\n\tset<int> S[2005], E[2005];\n\tint vs[2005];\n\tvoid push(int x, int y) {\n\t\tS[x].insert(y);\n\t}\n\tvoid dfs(int nw) {\n\t\tvs[nw] = 1;\n\t\tauto IT = S[nw].begin();\n\t\twhile(IT != S[nw].end()) {\n\t\t\tif(vs[*IT]) {++IT; continue;}\n\t\t\t++rd[*IT];\n\t\t\tE[nw].insert(*IT);\n\t\t\tdfs(*IT);\n\t\t\t++IT;\n\t\t}\n\t}\n\tvoid tuopu() {\n\t\tPQ.push(0);\n\t\twhile(PQ.size()) {\n\t\t\tint nw = PQ.top();\n\t\t\tif(nw) printf(\"%d \", a[nw]);\n\t\t\tPQ.pop();\n\t\t\tauto IT = E[nw].begin();\n\t\t\twhile(IT != E[nw].end()) {\n\t\t\t\t--rd[*IT];\n\t\t\t\tif(rd[*IT] == 0) PQ.push(*IT);\n\t\t\t\t++IT;\n\t\t\t}\n\t\t}\n\t}\n}G;\nint n;\nint main() {\n\tscanf(\"%d\", &n);\n\trep(i, 1, n) scanf(\"%d\", &a[i]);\n\trep(i, 1, n) rep(j, 1, n) if(i != j && __gcd(a[i], a[j]) != 1) G.push(i, j); \n\trep(i, 1, n) G.push(0, i), G.push(i, 0);\n\tG.dfs(0);\n\tG.tuopu();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n                                                                                                     \n                                             `-:://:::-                                             \n                                           `//:-------:/:`                                          \n                                          .+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .o:--...```..---+/`                                        \n                                       `/y+o/---....---:+o.                                         \n                                   `...````-os+/:---:/+o/--.`                                       \n              `-/+++++/:.      `...`       :h+d+oooo+/+-`   ...                                     \n            `/++//:::://++-`....`         -.`//````````:`     `..`                                  \n           `o+/::------://o/`           `-` -.          -`       `..`                               \n `---.-o/:./o/::-..``..-ЗАПУСКАЕМ      ..  ..            -`        `...       ``..``                \n  `....o+:-++/:--.```..-://s.        `-`  .-              -`          `-o: .-//::::/:-`             \n          `:s+/:--....-::/+s-`      .-   `-                -`           -///:--------:/:`           \n           ./s+//:::::://oo-``..НЕЙРОННУЮ: СЕТЬ:::::::-`РАБОТЯГИ        `+:--........--:/`          \n            .:ooo+++++osso-`    `.:-...`/` ./::-------:/:`   -`         :+--..``````.--:+:...-+:-`  \n             `.-/+++++/+-.-`    -.   ``:so:/:--.......--:+`  `-```````o+/+--..`````..--:o/-..:s+:.  \n                 ```````:``.. `-`     -` `+:--..`````..--/+-.../.`````..-o:--.......---/o.    `     \n                        `:  `:-      -.  .o:--..`` ``..--:o`   `-`      `:o+:--------:+o-`          \n                         `-`-...    ..   .o/--...```..--:+/`    `-`     `oy/so/////++o/.`           \n                          -/`  `-` `- ``+s/o/:---...---:++.      `-`   .-../d://///:-.`             \n                `.---..``-..-    .-/..`````-oo+/:::::/+o+-        `-``-`  `-.  ````                 \n             `:++++/+++++-  ..``.-/:`      /y-:/++o++/:.`..`       ./.   `-                         \n            -++/::::::://+/..:-``:` ..   `-.`  ```.```    `..`   `..`-` `-                          \n       ``  -o//:--....-::/++` -.-`   `-`.-`                 `..`..`  `-.-                           \n  -----ss+:++/:--.```..-://s.  /.     `::                    `-:.     ./`                           \n  `````/:..+o/::-..``.--:/+s. ..-`   `-``-`                 ..` `-`  `-`-`                          \n          `-s+/::-----::/+oo---``-` ..    .:-    ```      .-`     .-.-  `-`                         \n           `:oo+//::://+os/..:`..-/:`      :y.-:::::::.`.-`        ./-`  `-`                        \n            `./+oooooooo+/.`-    .-:...`.. .//:-------://`        `- `..` `:.                       \n              ``.-::::-.``-/`  `-` `-  `oo:+:--.......--:/`      `-    `.:--h.``..```               \n                          -.-`.-    .-   `+:--..`````..--//`    `-       /s-//::::::::.             \n                         -` `/-      ..  .o:--..`` ``..--:o.```.-        `//:--------://`           \n                        -` .-`.-`     -.`-o/--...```..--:+/.``-:....``:-.+:--....`...--:+`          \n                       ..`-.   `-.   ``:os:o/:---...---:++.  `-     ``///+:-..``````.--:+-````-.`   \n              `.:///////.-`      .:-..` -``-+o+/:::::/+o/.  `-         `:+:-..`````..--:o/:--/ys+-  \n            `-++///////+o/. ``....`-.    :` `.:++++++/:.`  .-           -o/---......---/o.   `.`    \n           `++//:-----::/+o:..`     .-`   :    ```````    .-           `+so+:--------:++-`          \n  `````:-``:o/::-..`..--:/+o`         -.  `-             .-          `../../+o+////+o+:.`           \n  -----syo/o+/:--.```..-://s.          .-` `-           .-        `...     ``-:////:-``             \n       .` `/s//:--....-::/+s.            -. `-`        .-       `..`                                \n           .+o+/:::--:://+s/-..`          .::+y  ```  .-     `..`                                   \n            ./oo++////+oso-`   `....       :y-+:::::::/`   ...                                      \n             `.:+oooooo/-`         `....-. .//:-------:/:-.`                                        \n                ``...``                 /+:+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .+/--...```..--:+/`                                        \n                                         `-o/:---...---:++.                                         \n                                          `-+o+/:---:/+o/.                                          \n                                            `.:+oooo+/-.`                                           \n                                               ``````                                               \n*/\n\n#ifdef aimbot\n#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#endif\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <set>\n#include <queue>\n#include <ostream>\n#include <istream>\n#include <typeinfo>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <limits>\n#include <fstream>\n#include <array>\n#include <list>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <cstring>\n#include <chrono>\n\n#define random escape__from__random__aetuhoetnuhshe\n#define mt make_tuple\n#define x first\n#define y second\n#define pb push_back\n#define ppb pop_back\n#define mp make_pair\n#define umap unordered_map\n#define uset unordered_set\n#define elif else if\n#define len(v) ((int)v.size())\n#define f(i, n) for (int i = 0; i < (n); i++)\n#define rof(i, n) for (int i = ((n) - 1); i >= 0; i--)\n#define apply(v, act) for (auto &x : v) { act; }\n#define log(args...) {string s = #args;deque<string> deq;\\\nstring buf = \"\";int bal = 0;for (char c : s) {\\\nif (c == '(' || c == '[' || c == '{') {bal++;\\\n} else if (c == ')' || c == ']' || c == '}') {\\\nbal--;} else {if (bal == 0) {if (c == ',') {\\\ndeq.pb(buf);buf = \"\";} else {if (c != ' ') {\\\nbuf += c;}}}}}if (!buf.empty()) {deq.pb(buf);}\\\nsmart_io::precall_print();smart_io::_print(deq, args);}\n\ninline int min(const int &x, const int &y) { return (((y-x)>>(32-1))&(x^y))^x; }\ninline int max(const int &x, const int &y) { return (((y-x)>>(32-1))&(x^y))^y; }\ninline long long min(const long long &x, const long long &y) { return (((y-x)>>(64-1))&(x^y))^x; }\ninline long long max(const long long &x, const long long &y) { return (((y-x)>>(64-1))&(x^y))^y; }\n\n#define print    \\\nsmart_io::precall_print(); \\\ncout,\n\n#define scan cin,\n\n#ifdef fast_allocator\nconst int MAXMEM = 200 * 1000 * 1024;\nchar _memory[MAXMEM];\nsize_t _ptr = 0;\nvoid* operator new(size_t _x) { _ptr += _x; assert(_ptr < MAXMEM); return _memory + _ptr - _x; }\nvoid operator delete (void*) noexcept {}\n#endif\n\nusing namespace std;\n\nchar string_in_buffer[(int)260];\n\n\nvoid fast_scan(int &x) { scanf(\"%d\", &x); }\nvoid fast_scan(long long &x) { scanf(\"%lld\", &x); }\nvoid fast_scan(unsigned long long &x) { scanf(\"%llu\", &x); }\nvoid fast_scan(double &x) { scanf(\"%lf\", &x); }\nvoid fast_scan(long double &x) { scanf(\"%Lf\", &x); }\nvoid fast_scan(char &x) {\n\tscanf(\"%c\", &x);\n\tif (x == '\\n') {\n\t\tfast_scan(x);\n\t}\n}\nvoid fast_scan(string &x) {\n\tscanf(\"%s\", string_in_buffer);\n\tx = string(string_in_buffer);\n}\n\ntemplate<class TFirst, class TSecond>\nvoid fast_scan(pair<TFirst, TSecond> &p) {\n\tfast_scan(p.first);\n\tfast_scan(p.second);\n}\n\ntemplate <class T>\nvoid fast_scan(vector<T> &v) {\n\tfor (auto &x : v) fast_scan(x);\n}\n\nvoid fast_print(const int &x) { printf(\"%d\", x); }\nvoid fast_print(const unsigned int &x) { printf(\"%u\", x); }\nvoid fast_print(const long long &x) { printf(\"%lld\", x); }\nvoid fast_print(const unsigned long long &x) { printf(\"%llu\", x); }\nvoid fast_print(const char &x) { printf(\"%c\", x); };\n// void fast_print(__int128 x) {\n// \tif (x == 0) { fast_print('0'); return; }\n// \tif (x < 0) {\n// \t\tfast_print('-');\n// \t\tx = -x;\n// \t}\n// \t__int128 p = 1;\n// \twhile (x / (p * 10)) p *= 10;\n// \twhile (p) {\n// \t\t__int128 symb = x / p;\n// \t\tfast_print((int)symb);\n// \t\tx -= p * symb;\n// \t\tp /= 10;\n// \t}\n// };\nvoid fast_print(const double &x) { printf(\"%.15lf\", x); }\nvoid fast_print(const long double &x) { printf(\"%.15Lf\", x); }\nvoid fast_print(const string &x) { printf(\"%s\", x.c_str());}\nvoid fast_print(const char v[]) { fast_print((string)v); }\n\ntemplate<class TFirst, class TSecond>\nvoid fast_print(const pair<TFirst, TSecond> &p) {\n\tfast_print(p.first);\n\tfast_print(' ');\n\tfast_print(p.second);\n}\n\ntemplate <class T>\nvoid fast_print(const vector<T> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print(' ');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const vector<vector<T>> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print('\\n');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const T &v) {\n\tfor (const auto &x : v) {\n\t\tfast_print(x);\n\t\tfast_print(' ');\n\t}\n}\n\n\nusing namespace std;\n\n\nnamespace smart_io {\n\tstring print_start = \"\";\n\tstring sep = \" \";\n\tbool first_print = false;\n\t\n\tvoid precall_print() {\n\t\tfast_print(print_start);\n\t\tprint_start = \"\\n\";\n\t\tfirst_print = true;\n\t}\n\t\n\tvoid _print(deque<string>) {}\n\ttemplate<class T, class... Args>\n\tvoid _print(deque<string> names, T elem, Args... args) {\n\t\tif (!first_print) {\n\t\t\tfast_print(\"\\n\");\n\t\t} else {\n\t\t\tfirst_print = false;\n\t\t}\n\t\tfast_print(names.front());\n\t\tfast_print(\" = \");\n\t\tfast_print(elem);\n\t\tnames.pop_front();\n\t\t_print(names, args...);\n\t}\n} //namespace smart_io\n\n\ntemplate <class T>\nostream &operator,(ostream &os, const T &object) {\n\tif (!smart_io::first_print) {\n\t\tfast_print(smart_io::sep);\n\t} else {\n\t\tsmart_io::first_print = false;\n\t}\n\tfast_print(object);\n\treturn os;\n}\n\ntemplate <class T>\nistream &operator,(istream &is, T &object) {\n\tfast_scan(object);\n\treturn is;\n}\n\nnamespace random {\n\tusing namespace std::chrono;\n\tmt19937 rng(duration_cast< milliseconds >(\n\t\t\t\t\t\t\t\t\t\t\t  system_clock::now().time_since_epoch()\n\t\t\t\t\t\t\t\t\t\t\t  ).count());\n\tuniform_real_distribution<> prob_dist(0.0, 1.0);\n};\n\nnamespace typedefs {\n\ttypedef long long ll;\n\ttypedef unsigned long long ull;\n\ttypedef pair<int, int> pii;\n\ttypedef long double ld;\n}\n\nnamespace numbers_operation {\n\ttemplate<class T>\n\tinline T floor_mod(T a, const T &b) {\n\t\ta %= b;\t\n\t\tif (a < 0) a += b;\n\t\treturn a;\n\t}\n}\n\nusing namespace numbers_operation;\nusing namespace typedefs;\nusing namespace random;\n\nint gcd(int a, int b) {\n\treturn __gcd((unsigned int)a, (unsigned int)b);\n}\t\n\nint n;\nvector<vector<int>> factors;\nvector<int> v;\n\nvoid factorize(int n, vector<int> &rez) {\n\tfor (int i = 2; i * i <= n; i++) {\n\t\twhile (n % i == 0) {\n\t\t\tn /= i;\n\t\t\trez.pb(i);\n\t\t}\n\t}\n\tif (n > 1) rez.pb(n);\n\tsort(rez.begin(), rez.end());\n\trez.resize(unique(rez.begin(), rez.end()) - rez.begin());\n}\n\nstruct SUS {\n\tvector<int> up;\n\tint get_root(int i) {\n\t\tif (up[i] == i) return i;\n\t\treturn up[i] = get_root(up[i]);\n\t}\n\tSUS(int n) {\n\t\tup.resize(n);\n\t\tf(i, n) up[i] = i;\n\t}\n\tvoid merge(int a, int b) {\n\t\tup[get_root(a)] = get_root(b);\n\t}\n\tbool one_comp(int a, int b) {\n\t\treturn get_root(a) == get_root(b);\n\t}\n};\n\nvector<int> order(vector<int> cur, const set<int> &F, int lv = 0) {\n\tif (len(cur) <= 1) return cur;\n\tint take = -1;\n\tfor (int i = 0; i < len(cur); i++) {\n\t\tif (F.count(v[cur[i]])) \n\t\t\tif (take == -1 || v[cur[i]] < v[cur[take]])\n\t\t\t\ttake = i;\n\t}\n\tassert(take != -1);\n\tstatic map<int, vector<int>> at;\n\tat.clear();\n\tfor (int i = 0; i < len(cur); i++) {\n\t\tif (i == take) continue;\n\t\tfor (int x : factors[cur[i]]) {\n\t\t\tat[x].pb(i);\n\t\t}\n\t}\n\tSUS sus(len(cur));\n\tfor (auto p : at) {\n\t\tfor (int j = 0; j < len(p.y) - 1; j++) {\n\t\t\tsus.merge(p.y[j], p.y[j + 1]);\n\t\t}\n\t}\n\tmap<int, vector<int>> index;\n\tfor (int i = 0; i < len(cur); i++) {\n\t\tif (i == take) continue;\n\t\tindex[sus.get_root(i)].pb(cur[i]);\n\t}\n\tset<int> ava;\n\tfor (int i = 0; i < len(cur); i++) {\n\t\tif (i == take) continue;\n\t\tif (gcd(v[cur[i]], v[cur[take]]) > 1 || (v[cur[i]] <= v[cur[take]] && F.count(v[cur[i]])))\n\t\t\tava.insert(v[cur[i]]);\n\t}\n\tvector<int> rez;\n\tfor (auto p : index) {\n\t\tvector<int> t = order(p.y, ava, lv + 1);\n\t\tvector<int> final;\n\t\tmerge(rez.begin(), rez.end(), t.begin(), t.end(), back_inserter(final), [](int i, int j) {\n\t\t\treturn v[i] > v[j];\n\t\t});\n\t\trez = final;\n\t}\n\trez.insert(rez.begin(), cur[take]);\n\treturn rez;\n}\n\nsigned main(signed argc, char *argv[]) {\n\tscan n;\n\tv.resize(n);\n\tfactors.resize(n);\n\tscan v;\n\tfor (int i = 0; i < n; i++) {\n\t\tfactorize(v[i], factors[i]);\n\t}\n\tvector<int> cur(n);\n\tiota(cur.begin(), cur.end(), 0);\n\t{\n\t\tmap<int, vector<int>> at;\n\t\tfor (int i = 0; i < len(cur); i++) {\n\t\t\tfor (int x : factors[cur[i]]) {\n\t\t\t\tat[x].pb(i);\n\t\t\t}\n\t\t}\n\t\tSUS sus(len(cur));\n\t\tfor (auto p : at) {\n\t\t\tfor (int j = 0; j < len(p.y) - 1; j++) {\n\t\t\t\tsus.merge(p.y[j], p.y[j + 1]);\n\t\t\t}\n\t\t}\n\t\tmap<int, vector<int>> index;\n\t\tfor (int i = 0; i < len(cur); i++) {\n\t\t\tindex[sus.get_root(i)].pb(i);\n\t\t}\n\t\tset<int> ava;\n\t\tfor (int i = 0; i < len(cur); i++) {\n\t\t\tava.insert(v[cur[i]]);\n\t\t}\n\t\tvector<int> rez;\n\t\tfor (auto p : index) {\n\t\t\tvector<int> t = order(p.y, ava);\n\t\t\tvector<int> final;\n\t\t\tmerge(rez.begin(), rez.end(), t.begin(), t.end(), back_inserter(final), [](int i, int j) {\n\t\t\t\treturn v[i] > v[j];\n\t\t\t});\n\t\t\trez = final;\n\t\t}\n\t\tfor (int i = 0; i < len(rez); i++)\n\t\t\trez[i] = v[rez[i]];\n\t\tprint rez;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "// 修改自提交记录：233271\n// 原记录作者：E.Space (UID: 1579)\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<cstdlib>\n#include<cassert>\n#include<ctime>\n#include<map>\n#define cmin(a,b) (a>(b)?a=(b),1:0)\n#define cmax(a,b) (a<(b)?a=(b),1:0)\n#define dmin(a,b) ((a)<(b)?(a):(b))\n#define dmax(a,b) ((a)>(b)?(a):(b))\nnamespace io\n{\n\tint F()\n\t{\n\t\tint n=0,F=1;\n\t\tchar ch;\n\t\twhile((ch=getchar())!='-'&&(ch<'0'||ch>'9'));\n\t\tch=='-'?F=0:n=ch-'0';\n\t\twhile((ch=getchar())>='0'&&ch<='9')n=n*10+ch-'0';\n\t\treturn F?n:-n;\n\t}\n}\nint gcd(int x,int y)\n{\n\tint r;\n\twhile(r=x%y)x=y,y=r;\n\treturn y;\n}\nstruct edge\n{\n\tint to;\n\tint next;\n}e[1444444];\nint pe=6666;\nvoid insert(int a,int to)\n{\n\te[pe]=(edge){to,e[a].next};\n\te[a].next=pe++;\n}\nint addedge(int x,int y)\n{\n\t//fprintf(stderr,\"%d %d\\n\",x,y);\n\tinsert(x,y);\n\tinsert(y,x);\n}\nint d[2222];\nint g[2222][2222];\nint vis[6666],pv;\nstd::map<int,int> no;\nint pno;\nint s[11111],p[11111],pp;\nint op[6666];\nint q[6666],hq,tq;\nint main()\n{\n\tint n=io::F();\n\tfor(register int i=1;i<=n;++i)d[i]=io::F();\n\tstd::sort(d+1,d+n+1);\n\tint cnt1=0,now=0;\n\tfor(register int i=1;i<=n;++i)\n\t\tif(d[i]!=1)d[++now]=d[i];\n\t\t\telse ++cnt1;\n\tn=now;\n\tfor(register int i=1;i<=n;++i)\n\t\tfor(register int j=i+1;j<=n;++j)\n\t\t\tg[i][j]=g[j][i]=gcd(d[i],d[j]);\n\tfor(register int i=2;i<=10000;++i)\n\t{\n\t\tif(!s[i])s[i]=p[++pp]=i;\n\t\tfor(register int j=1,u=dmin(10000/i,s[i]);j<=pp&&p[j]<=u;++j)\n\t\t\ts[i*p[j]]=p[j];\n\t}\n\t//fprintf(stderr,\"%d\\n\",pp);\n\tpno=n;\n\tfor(register int i=1;i<=n;++i)\n\t{\n\t\tint T=d[i];\n\t\tfor(register int j=1;j<=pp&&p[j]*p[j]<=T;++j)\n\t\t\tif(T%p[j]==0)\n\t\t\t{\n\t\t\t\tint to;\n\t\t\t\tif(!(to=no[p[j]]))to=no[p[j]]=++pno,addedge(0,pno);\n\t\t\t\taddedge(i,to);\n\t\t\t\twhile(T%p[j]==0)T/=p[j];\n\t\t\t}\n\t\tif(T!=1)\n\t\t{\n\t\t\tint to;\n\t\t\tif(!(to=no[T]))to=no[T]=++pno,addedge(0,pno);\n\t\t\taddedge(i,to);\n\t\t}\n\t}\n\top[0]=1;\n\tfor(register int z=1;z<=n+1;++z)\n\t{\n\t\tint max=0;\n\t\t++pv;\n\t\tfor(register int i=0;i<=n;++i)\n\t\t\tif(vis[i]<pv)\n\t\t\t{\n\t\t\t\tint min=2222;\n\t\t\t\tfor(q[hq=1]=i,tq=2,vis[i]=pv;hq!=tq;++hq)\n\t\t\t\t{\n\t\t\t\t\tif(q[hq]<=n&&op[q[hq]])cmin(min,q[hq]);\n\t\t\t\t\tfor(register int p=e[q[hq]].next;p;p=e[p].next)\n\t\t\t\t\t\tif(vis[e[p].to]<pv)vis[e[p].to]=pv,q[tq++]=e[p].to;\n\t\t\t\t}\n\t\t\t\tcmax(max,min);\n\t\t\t}\n\t\tvis[max]=1000000;\n\t\tif(max)printf(\"%d \",d[max]);\n\t\t++pv;\n\t\tfor(q[hq=1]=max,tq=2;hq!=tq;++hq)\n\t\t{\n\t\t\top[q[hq]]=0;\n\t\t\tfor(register int p=e[q[hq]].next;p;p=e[p].next)\n\t\t\t\tif(vis[e[p].to]<pv)vis[e[p].to]=pv,q[tq++]=e[p].to;\n\t\t}\n\t\tfor(register int i=1;i<=n;++i)\n\t\t\tif(g[max][i]!=1)op[i]=1;\n\t}\n\tfor(register int i=1;i<=cnt1;++i)printf(\"1 \");\n\tputs(\"\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ninline char nchar() {\n\tstatic const int bufl=1<<20;\n\tstatic char buf[bufl],*a=NULL,*b=NULL;\n\treturn a==b && (b=(a=buf)+fread(buf,1,bufl,stdin),a==b)?EOF:*a++;\n}\ninline int read() {\n\tint x=0,f=1;\n\tchar c=nchar();\n\tfor (;!isdigit(c);c=nchar()) if (c=='-') f=-1;\n\tfor (;isdigit(c);c=nchar()) x=x*10+c-'0';\n\treturn x*f;\n}\nconst int maxn=2e3+10;\ntypedef vector<int> vec;\nint n,a[maxn];\nvec operator + (const vec &a,const vec &b) {\n\tvec ret(a.size()+b.size());\n\tcopy(b.begin(),b.end(),copy(a.begin(),a.end(),ret.begin()));\n\treturn ret;\n}\nvec operator ^ (const vec &a,const vec &b) {\n\tvec ret(a.size()+b.size());\n\tvec::const_iterator ai=a.begin(),bi=b.begin();\n\tvec::iterator ri=ret.begin();\n\twhile (ai!=a.end() || bi!=b.end()) {\n\t\tif (ai==a.end()) *ri++=*bi++; else\n\t\tif (bi==b.end()) *ri++=*ai++; else\n\t\t*ri++=*(*ai>*bi?(ai++):(bi++));\n\t}\n\treturn ret;\n}\nnamespace graph {\n\tvec g[maxn],f[maxn];\n\tbool vis[maxn];\n\tinline void add(int x,int y) {\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\tvoid dfs(int x) {\n\t\tvis[x]=true;\n\t\tvec &fx=f[x];\n\t\tsort(g[x].begin(),g[x].end(),[](int x,int y)->bool{return a[x]<a[y];});\n\t\tfor (const int &v:g[x]) g[v].erase(find(g[v].begin(),g[v].end(),x));\n\t\tfor (const int &v:g[x]) if (!vis[v]) {\n\t\t\tdfs(v);\n\t\t\tfx=fx^f[v];\n\t\t}\n\t\tfx=vec(1,a[x])+fx;\n\t}\n\tvec work() {\n\t\tdfs(0);\n\t\treturn f[0];\n\t}\n}\nint main() {\n\tn=read(),generate_n(a+1,n,read);\n\tfor (int i=1;i<=n;++i) graph::add(0,i);\n\tfor (int i=1;i<=n;++i) for (int j=i+1;j<=n;++j) if (__gcd(a[i],a[j])>1) graph::add(i,j);\n\tvec ans(graph::work());\n\tfor (int i=1;i<=n;++i) printf(\"%d%c\",ans[i],\" \\n\"[i==n]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n                                                                                                     \n                                             `-:://:::-                                             \n                                           `//:-------:/:`                                          \n                                          .+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .o:--...```..---+/`                                        \n                                       `/y+o/---....---:+o.                                         \n                                   `...````-os+/:---:/+o/--.`                                       \n              `-/+++++/:.      `...`       :h+d+oooo+/+-`   ...                                     \n            `/++//:::://++-`....`         -.`//````````:`     `..`                                  \n           `o+/::------://o/`           `-` -.          -`       `..`                               \n `---.-o/:./o/::-..``..-ЗАПУСКАЕМ      ..  ..            -`        `...       ``..``                \n  `....o+:-++/:--.```..-://s.        `-`  .-              -`          `-o: .-//::::/:-`             \n          `:s+/:--....-::/+s-`      .-   `-                -`           -///:--------:/:`           \n           ./s+//:::::://oo-``..НЕЙРОННУЮ: СЕТЬ:::::::-`РАБОТЯГИ        `+:--........--:/`          \n            .:ooo+++++osso-`    `.:-...`/` ./::-------:/:`   -`         :+--..``````.--:+:...-+:-`  \n             `.-/+++++/+-.-`    -.   ``:so:/:--.......--:+`  `-```````o+/+--..`````..--:o/-..:s+:.  \n                 ```````:``.. `-`     -` `+:--..`````..--/+-.../.`````..-o:--.......---/o.    `     \n                        `:  `:-      -.  .o:--..`` ``..--:o`   `-`      `:o+:--------:+o-`          \n                         `-`-...    ..   .o/--...```..--:+/`    `-`     `oy/so/////++o/.`           \n                          -/`  `-` `- ``+s/o/:---...---:++.      `-`   .-../d://///:-.`             \n                `.---..``-..-    .-/..`````-oo+/:::::/+o+-        `-``-`  `-.  ````                 \n             `:++++/+++++-  ..``.-/:`      /y-:/++o++/:.`..`       ./.   `-                         \n            -++/::::::://+/..:-``:` ..   `-.`  ```.```    `..`   `..`-` `-                          \n       ``  -o//:--....-::/++` -.-`   `-`.-`                 `..`..`  `-.-                           \n  -----ss+:++/:--.```..-://s.  /.     `::                    `-:.     ./`                           \n  `````/:..+o/::-..``.--:/+s. ..-`   `-``-`                 ..` `-`  `-`-`                          \n          `-s+/::-----::/+oo---``-` ..    .:-    ```      .-`     .-.-  `-`                         \n           `:oo+//::://+os/..:`..-/:`      :y.-:::::::.`.-`        ./-`  `-`                        \n            `./+oooooooo+/.`-    .-:...`.. .//:-------://`        `- `..` `:.                       \n              ``.-::::-.``-/`  `-` `-  `oo:+:--.......--:/`      `-    `.:--h.``..```               \n                          -.-`.-    .-   `+:--..`````..--//`    `-       /s-//::::::::.             \n                         -` `/-      ..  .o:--..`` ``..--:o.```.-        `//:--------://`           \n                        -` .-`.-`     -.`-o/--...```..--:+/.``-:....``:-.+:--....`...--:+`          \n                       ..`-.   `-.   ``:os:o/:---...---:++.  `-     ``///+:-..``````.--:+-````-.`   \n              `.:///////.-`      .:-..` -``-+o+/:::::/+o/.  `-         `:+:-..`````..--:o/:--/ys+-  \n            `-++///////+o/. ``....`-.    :` `.:++++++/:.`  .-           -o/---......---/o.   `.`    \n           `++//:-----::/+o:..`     .-`   :    ```````    .-           `+so+:--------:++-`          \n  `````:-``:o/::-..`..--:/+o`         -.  `-             .-          `../../+o+////+o+:.`           \n  -----syo/o+/:--.```..-://s.          .-` `-           .-        `...     ``-:////:-``             \n       .` `/s//:--....-::/+s.            -. `-`        .-       `..`                                \n           .+o+/:::--:://+s/-..`          .::+y  ```  .-     `..`                                   \n            ./oo++////+oso-`   `....       :y-+:::::::/`   ...                                      \n             `.:+oooooo/-`         `....-. .//:-------:/:-.`                                        \n                ``...``                 /+:+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .+/--...```..--:+/`                                        \n                                         `-o/:---...---:++.                                         \n                                          `-+o+/:---:/+o/.                                          \n                                            `.:+oooo+/-.`                                           \n                                               ``````                                               \n*/\n\n#ifdef aimbot\n#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#endif\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <set>\n#include <queue>\n#include <ostream>\n#include <istream>\n#include <typeinfo>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <limits>\n#include <fstream>\n#include <array>\n#include <list>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <cstring>\n#include <chrono>\n\n#define random escape__from__random__aetuhoetnuhshe\n#define mt make_tuple\n#define x first\n#define y second\n#define pb push_back\n#define ppb pop_back\n#define mp make_pair\n#define umap unordered_map\n#define uset unordered_set\n#define elif else if\n#define len(v) ((int)v.size())\n#define f(i, n) for (int i = 0; i < (n); i++)\n#define rof(i, n) for (int i = ((n) - 1); i >= 0; i--)\n#define apply(v, act) for (auto &x : v) { act; }\n#define log(args...) {string s = #args;deque<string> deq;\\\nstring buf = \"\";int bal = 0;for (char c : s) {\\\nif (c == '(' || c == '[' || c == '{') {bal++;\\\n} else if (c == ')' || c == ']' || c == '}') {\\\nbal--;} else {if (bal == 0) {if (c == ',') {\\\ndeq.pb(buf);buf = \"\";} else {if (c != ' ') {\\\nbuf += c;}}}}}if (!buf.empty()) {deq.pb(buf);}\\\nsmart_io::precall_print();smart_io::_print(deq, args);}\n\ninline int min(const int &x, const int &y) { return (((y-x)>>(32-1))&(x^y))^x; }\ninline int max(const int &x, const int &y) { return (((y-x)>>(32-1))&(x^y))^y; }\ninline long long min(const long long &x, const long long &y) { return (((y-x)>>(64-1))&(x^y))^x; }\ninline long long max(const long long &x, const long long &y) { return (((y-x)>>(64-1))&(x^y))^y; }\n\n#define print    \\\nsmart_io::precall_print(); \\\ncout,\n\n#define scan cin,\n\n#ifdef fast_allocator\nconst int MAXMEM = 200 * 1000 * 1024;\nchar _memory[MAXMEM];\nsize_t _ptr = 0;\nvoid* operator new(size_t _x) { _ptr += _x; assert(_ptr < MAXMEM); return _memory + _ptr - _x; }\nvoid operator delete (void*) noexcept {}\n#endif\n\nusing namespace std;\n\nchar string_in_buffer[(int)260];\n\n\nvoid fast_scan(int &x) { scanf(\"%d\", &x); }\nvoid fast_scan(long long &x) { scanf(\"%lld\", &x); }\nvoid fast_scan(unsigned long long &x) { scanf(\"%llu\", &x); }\nvoid fast_scan(double &x) { scanf(\"%lf\", &x); }\nvoid fast_scan(long double &x) { scanf(\"%Lf\", &x); }\nvoid fast_scan(char &x) {\n\tscanf(\"%c\", &x);\n\tif (x == '\\n') {\n\t\tfast_scan(x);\n\t}\n}\nvoid fast_scan(string &x) {\n\tscanf(\"%s\", string_in_buffer);\n\tx = string(string_in_buffer);\n}\n\ntemplate<class TFirst, class TSecond>\nvoid fast_scan(pair<TFirst, TSecond> &p) {\n\tfast_scan(p.first);\n\tfast_scan(p.second);\n}\n\ntemplate <class T>\nvoid fast_scan(vector<T> &v) {\n\tfor (auto &x : v) fast_scan(x);\n}\n\nvoid fast_print(const int &x) { printf(\"%d\", x); }\nvoid fast_print(const unsigned int &x) { printf(\"%u\", x); }\nvoid fast_print(const long long &x) { printf(\"%lld\", x); }\nvoid fast_print(const unsigned long long &x) { printf(\"%llu\", x); }\nvoid fast_print(const char &x) { printf(\"%c\", x); };\n// void fast_print(__int128 x) {\n// \tif (x == 0) { fast_print('0'); return; }\n// \tif (x < 0) {\n// \t\tfast_print('-');\n// \t\tx = -x;\n// \t}\n// \t__int128 p = 1;\n// \twhile (x / (p * 10)) p *= 10;\n// \twhile (p) {\n// \t\t__int128 symb = x / p;\n// \t\tfast_print((int)symb);\n// \t\tx -= p * symb;\n// \t\tp /= 10;\n// \t}\n// };\nvoid fast_print(const double &x) { printf(\"%.15lf\", x); }\nvoid fast_print(const long double &x) { printf(\"%.15Lf\", x); }\nvoid fast_print(const string &x) { printf(\"%s\", x.c_str());}\nvoid fast_print(const char v[]) { fast_print((string)v); }\n\ntemplate<class TFirst, class TSecond>\nvoid fast_print(const pair<TFirst, TSecond> &p) {\n\tfast_print(p.first);\n\tfast_print(' ');\n\tfast_print(p.second);\n}\n\ntemplate <class T>\nvoid fast_print(const vector<T> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print(' ');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const vector<vector<T>> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print('\\n');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const T &v) {\n\tfor (const auto &x : v) {\n\t\tfast_print(x);\n\t\tfast_print(' ');\n\t}\n}\n\n\nusing namespace std;\n\n\nnamespace smart_io {\n\tstring print_start = \"\";\n\tstring sep = \" \";\n\tbool first_print = false;\n\t\n\tvoid precall_print() {\n\t\tfast_print(print_start);\n\t\tprint_start = \"\\n\";\n\t\tfirst_print = true;\n\t}\n\t\n\tvoid _print(deque<string>) {}\n\ttemplate<class T, class... Args>\n\tvoid _print(deque<string> names, T elem, Args... args) {\n\t\tif (!first_print) {\n\t\t\tfast_print(\"\\n\");\n\t\t} else {\n\t\t\tfirst_print = false;\n\t\t}\n\t\tfast_print(names.front());\n\t\tfast_print(\" = \");\n\t\tfast_print(elem);\n\t\tnames.pop_front();\n\t\t_print(names, args...);\n\t}\n} //namespace smart_io\n\n\ntemplate <class T>\nostream &operator,(ostream &os, const T &object) {\n\tif (!smart_io::first_print) {\n\t\tfast_print(smart_io::sep);\n\t} else {\n\t\tsmart_io::first_print = false;\n\t}\n\tfast_print(object);\n\treturn os;\n}\n\ntemplate <class T>\nistream &operator,(istream &is, T &object) {\n\tfast_scan(object);\n\treturn is;\n}\n\nnamespace random {\n\tusing namespace std::chrono;\n\tmt19937 rng(duration_cast< milliseconds >(\n\t\t\t\t\t\t\t\t\t\t\t  system_clock::now().time_since_epoch()\n\t\t\t\t\t\t\t\t\t\t\t  ).count());\n\tuniform_real_distribution<> prob_dist(0.0, 1.0);\n};\n\nnamespace typedefs {\n\ttypedef long long ll;\n\ttypedef unsigned long long ull;\n\ttypedef pair<int, int> pii;\n\ttypedef long double ld;\n}\n\nnamespace numbers_operation {\n\ttemplate<class T>\n\tinline T floor_mod(T a, const T &b) {\n\t\ta %= b;\t\n\t\tif (a < 0) a += b;\n\t\treturn a;\n\t}\n}\n\nusing namespace numbers_operation;\nusing namespace typedefs;\nusing namespace random;\n\nint gcd(int a, int b) {\n\treturn __gcd((unsigned int)a, (unsigned int)b);\n}\t\n\nint n;\nvector<vector<int>> factors;\nvector<int> v;\n\nvoid factorize(int n, vector<int> &rez) {\n\tfor (int i = 2; i * i <= n; i++) {\n\t\twhile (n % i == 0) {\n\t\t\tn /= i;\n\t\t\trez.pb(i);\n\t\t}\n\t}\n\tif (n > 1) rez.pb(n);\n\tsort(rez.begin(), rez.end());\n\trez.resize(unique(rez.begin(), rez.end()) - rez.begin());\n}\n\nstruct SUS {\n\tvector<int> up;\n\tint get_root(int i) {\n\t\tif (up[i] == i) return i;\n\t\treturn up[i] = get_root(up[i]);\n\t}\n\tSUS(int n) {\n\t\tup.resize(n);\n\t\tf(i, n) up[i] = i;\n\t}\n\tvoid merge(int a, int b) {\n\t\tup[get_root(a)] = get_root(b);\n\t}\n\tbool one_comp(int a, int b) {\n\t\treturn get_root(a) == get_root(b);\n\t}\n};\n\nvector<int> order(vector<int> cur, const set<int> &F, int lv = 0) {\n\tif (len(cur) <= 1) return cur;\n\tint take = -1;\n\tfor (int i = 0; i < len(cur); i++) {\n\t\tif (F.count(v[cur[i]])) \n\t\t\tif (take == -1 || v[cur[i]] < v[cur[take]])\n\t\t\t\ttake = i;\n\t}\n\tassert(take != -1);\n\tstatic map<int, vector<int>> at;\n\tfor (int i = 0; i < len(cur); i++) {\n\t\tif (i == take) continue;\n\t\tfor (int x : factors[cur[i]]) {\n\t\t\tat[x].pb(i);\n\t\t}\n\t}\n\tstatic SUS sus(len(cur));\n\tfor (auto p : at) {\n\t\tfor (int j = 0; j < len(p.y) - 1; j++) {\n\t\t\tsus.merge(p.y[j], p.y[j + 1]);\n\t\t}\n\t}\n\tmap<int, vector<int>> index;\n\tfor (int i = 0; i < len(cur); i++) {\n\t\tif (i == take) continue;\n\t\tindex[sus.get_root(i)].pb(cur[i]);\n\t}\n\tset<int> ava;\n\tfor (int i = 0; i < len(cur); i++) {\n\t\tif (i == take) continue;\n\t\tif (gcd(v[cur[i]], v[cur[take]]) > 1 || (v[cur[i]] <= v[cur[take]] && F.count(v[cur[i]])))\n\t\t\tava.insert(v[cur[i]]);\n\t}\n\tvector<int> rez;\n\tfor (auto p : index) {\n\t\tvector<int> t = order(p.y, ava, lv + 1);\n\t\tvector<int> final;\n\t\tmerge(rez.begin(), rez.end(), t.begin(), t.end(), back_inserter(final), [](int i, int j) {\n\t\t\treturn v[i] > v[j];\n\t\t});\n\t\trez = final;\n\t}\n\trez.insert(rez.begin(), cur[take]);\n\treturn rez;\n}\n\nsigned main(signed argc, char *argv[]) {\n\tscan n;\n\tv.resize(n);\n\tfactors.resize(n);\n\tscan v;\n\tfor (int i = 0; i < n; i++) {\n\t\tfactorize(v[i], factors[i]);\n\t}\n\tvector<int> cur(n);\n\tiota(cur.begin(), cur.end(), 0);\n\t{\n\t\tmap<int, vector<int>> at;\n\t\tfor (int i = 0; i < len(cur); i++) {\n\t\t\tfor (int x : factors[cur[i]]) {\n\t\t\t\tat[x].pb(i);\n\t\t\t}\n\t\t}\n\t\tSUS sus(len(cur));\n\t\tfor (auto p : at) {\n\t\t\tfor (int j = 0; j < len(p.y) - 1; j++) {\n\t\t\t\tsus.merge(p.y[j], p.y[j + 1]);\n\t\t\t}\n\t\t}\n\t\tmap<int, vector<int>> index;\n\t\tfor (int i = 0; i < len(cur); i++) {\n\t\t\tindex[sus.get_root(i)].pb(i);\n\t\t}\n\t\tset<int> ava;\n\t\tfor (int i = 0; i < len(cur); i++) {\n\t\t\tava.insert(v[cur[i]]);\n\t\t}\n\t\tvector<int> rez;\n\t\tfor (auto p : index) {\n\t\t\tvector<int> t = order(p.y, ava);\n\t\t\tvector<int> final;\n\t\t\tmerge(rez.begin(), rez.end(), t.begin(), t.end(), back_inserter(final), [](int i, int j) {\n\t\t\t\treturn v[i] > v[j];\n\t\t\t});\n\t\t\trez = final;\n\t\t}\n\t\tfor (int i = 0; i < len(rez); i++)\n\t\t\trez[i] = v[rez[i]];\n\t\tprint rez;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n \n#define all(x)  x.begin(), x.end()\n#define mp      make_pair\n \nvector<int> g[2020];\nint used[2020];\nvector<int> a;\nvector<int> tmp;\n \nvoid dfs(int v, int prev) {\n        used[v] = true;\n        tmp.push_back(a[v]);\n        vector<pair<int, int>> p;\n        for (auto u : g[v]) if (u != prev) p.emplace_back(a[u], u);\n        sort(all(p));\n        for (auto u : p) {\n                if (!used[u.second]) {\n                        dfs(u.second, v);\n                }\n        }\n}\n \nint main() {\n        int n;\n        scanf(\"%d\", &n);\n        a.resize(n);\n        sort(all(a));\n        for (int i = 0; i < n; i ++) scanf(\"%d\", &a[i]);\n        for (int i = 0; i < n; i ++) {\n                for (int j = i + 1; j < n; j ++) {\n                        if (__gcd(a[i], a[j]) != 1) {\n                                g[i].push_back(j);\n                                g[j].push_back(i);\n                        }\n                }\n        }\n        for (int i = 0; i < n; i ++) {\n                if (!used[i]) {\n                        dfs(i, -1);\n                }\n        }\n        for (int i = 0; i < n; i ++) g[i].clear();\n        for (int i = 0; i < n; i ++) {\n                for (int j = i + 1; j < n; j ++) {\n                        if (__gcd(tmp[i], tmp[j]) != 1) {\n                                g[i].push_back(j);\n                        }\n                }\n        }\n        vector<int> in_cnt(n, 0);\n        for (int i = 0; i < n; i ++) {\n                for (auto u : g[i]) {\n                        in_cnt[u] ++;\n                }\n        }\n        priority_queue<pair<int, int>> pq;\n        for (int i = 0; i < n; i ++) if (in_cnt[i] == 0) pq.push(mp(tmp[i], i));\n        vector<int> ans;\n        while (!pq.empty()) {\n                auto get = pq.top();\n                pq.pop();\n                ans.push_back(get.first);\n                for (auto u : g[get.second]) {\n                        in_cnt[u] --;\n                        if (in_cnt[u] == 0) pq.push(mp(tmp[u], u));\n                }\n        }\n        for (int i = 0; i < n; i ++) cout << ans[i] << (i == n - 1 ? '\\n' : ' ');\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n██████████████████████████████████████████████████████████████████████████████\n██              ██████    ██████      ██      ██  ██    ██████              ██\n██  ██████████  ██  ██      ██      ██████████████  ██████  ██  ██████████  ██\n██  ██      ██  ██    ██  ████      ██    ██████████    ██  ██  ██      ██  ██\n██  ██      ██  ██    ██  ██      ██  ████        ██  ████  ██  ██      ██  ██\n██  ██      ██  ██  ██████  ████  ████████████  ██    ████████  ██      ██  ██\n██  ██████████  ██  ████  ██    ████    ████  ██████  ████  ██  ██████████  ██\n██              ██  ██  ██  ██  ██  ██  ██  ██  ██  ██  ██  ██              ██\n████████████████████  ██  ██    ██████  ██    ████  ████    ██████████████████\n██████  ████          ████        ██    ██    ████  ████████  ██          ████\n████  ██      ██  ██      ██  ██████  ████  ████    ██    ████    ████████  ██\n██      ██      ██    ██    ████      ████        ██████  ██      ██  ██    ██\n██  ██    ████████████  ████  ██  ████            ████  ████████████  ████  ██\n██  ██      ██  ██  ████    ████████                ████████      ██  ██    ██\n██  ██  ██  ██████████  ████    ██  ████  ██    ████  ████        ████  ██  ██\n██    ██  ████  ██████  ██    ******************    ████  ██            ██  ██\n██    ██████  ██  ██████      * Scan this QR   *██████    ██  ██  ██  ████████\n████  ████  ██  ██████      ██* code to join   *██  ████    ██  ████████  ████\n██████      ████████  ██      * in the Three   *██  ████          ████  ██  ██\n████              ████  ████  * Body ETO.      *  ████        ██  ████  ██  ██\n██████  ██    ████████        *  --ETO manager *██  ██                ██    ██\n████    ██  ██  ██    ██████  *    Ye Wenjie   *████  ████  ██  ████  ██  ████\n██  ████  ██████    ████  ██  *ETO(C),1988~2018*      ██  ██  ██  ██    ██████\n██  ██████  ██  ████    ██  ██******************          ██████    ██████  ██\n██  ██  ██    ████    ██        ██  ██        ████████      ████  ██  ██    ██\n████████████    ██    ██████  ██████████  ██  ████  ██████████    ██  ██  ████\n██████████    ██  ████  ██        ██    ██████████  ██    ██      ██  ██    ██\n██    ██  ████    ██  ████  ████      ██████    ██    ██      ██  ██  ████  ██\n██████  ██  ██████  ██            ██████████  ██    ██    ████  ████  ██    ██\n██      ██████  ████  ████  ████      ████    ████  ████            ██████████\n██████████████████      ██  ██  ████  ██    ██  ██    ████  ██████    ██    ██\n██              ██        ████████████  ████  ██  ██  ██    ██  ██      ██  ██\n██  ██████████  ██    ████  ██████  ██  ██████████████      ██████    ██  ████\n██  ██      ██  ████████    ██  ██      ████  ████  ██              ████  ████\n██  ██      ██  ████  ████  ████  ██████  ██████████████  ██████████    ██  ██\n██  ██      ██  ██    ██████  ██  ██  ██████████  ██  ██      ████    ██    ██\n██  ██████████  ██████  ████            ██    ████████  ██  ████    ██████████\n██              ██████    ████  ████████  ██  ████    ██    ██  ████  ████  ██\n██████████████████████████████████████████████████████████████████████████████\n    扫    描    二    维    码    加    入    三    体    E    T    O\n*/\n/*****************\n *   I<3   C++   *\n *  IWANT ANYAC  *\n * ILOVEPROGRAM! *\n *IT'SINTERESTING*\n * ILOVEPROGRAM! *\n *  INCONTESTS   *\n *   GETSCORE    *\n *    ACCODE     *\n *     LETS      *\n *      GO       *\n *Written by:    *\n *    charlieyan *\n *****************/\n#include <assert.h>\n#include <ctype.h>\n#include <errno.h>\n#include <float.h>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <locale>\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <wchar.h>\n#include <wctype.h>\n#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <cerrno>\n#include <clocale>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <limits>\n#include <map>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <istream>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <utility>\n#include <vector>\n#include <cwchar>\n#include <cwctype>\n#include <numeric>\n#include <list>\n#define LL long long\n#define pb push_back\n#define pob pop_back\n#define mp make_pair\n#define FILL(a,v) memset((void*)a,v,sizeof(a))\n#define FILL0(a) FILL(a,0)\n#define FILL1(a) FILL(a,-1)\n#define FILLBIG(a) FILL(a,0x3f)\n#define ALL(a) (a).begin(),(a).end()\n#define Inf ((int)0x3f3f3f3f)\n#define INF ((long long)0x3f3f3f3f3f3f3f3f)\n#define Mod 1000000007\n#define foreach(it,x) for(__typeof(x.begin()) it=x.begin();it!=x.end();it++)\n#define FOR(i,x) for(int i=0;i<x;i++)\n#define RFOR(i,x) for(int i=x-1;i>=0;i--)\n#define FFOR(i,a,b) for(int i=a;i<b;i++)\n#define FRFOR(i,a,b) for(int i=a-1;i>=b;i--)\n#define SZ(a) ((int)(a).size())\n#define FI first\n#define SE second\n#define OVER(...) return printf(__VA_ARGS__),0\n#define fastio ios::sync_with_stdio(0)\n#define filei(f) freopen(f,\"r\",stdin)\n#define fileo(f) freopen(f,\"w\",stdout)\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define MASK(a) (1<<(a))\n#define MASKX(x,a) ((x)<<(a))\n#define BIT(a,b) (((a)>>(b))&1)\n#define cddx(a) priority_queue<a >\n#define cxdd(a) priority_queue<a,vector<a >,greater<a > >\n#define deval(a) {cerr<<#a<<\" = \"<<a<<endl;}\n#define dearr(be,en) {cerr<<#be;cerr<<\" = {\";for(auto i=be;i!=en;i++)cerr<<' '<<*i;cerr<<\" }\\n\";}\n#define reg register\n#define prtime eprintf(\"\\n\\nTime used: %dms\\n\",clock());\n#define PI 3.1415926535897932384626\n#define TODEG(a) (a*180/PI)\n#define y0 ykangjimutigeidiqiuyipianjingtu\n#define y1 yxiaomiexuduhuanrenleiwannianankang\n#define endl '\\n'\n//抗击母体，给地球一片净土\n//消灭徐毒，还人类万年安康\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef unsigned long long UINT;\ntypedef unsigned int uint;\ntypedef long long INT;\ntypedef long double ldouble;\ntypedef pair<INT,INT> PII;\ntypedef stringstream sst;\ntypedef istringstream iss;\ntypedef vector<int> vint;\ntypedef vector<INT> VINT;\ntypedef vector<pii> vpii;\ntypedef vector<PII> VPII;\ntypedef priority_queue<int> pqi;\ntypedef priority_queue<INT> PQI;\ntypedef priority_queue<pii> pqp;\ntypedef priority_queue<PII> PQP;\ntypedef priority_queue<int,vint,greater<int> > xqi;\ntypedef priority_queue<INT,VINT,greater<INT> > XQI;\ntypedef priority_queue<pii,vpii,greater<pii> > xqp;\ntypedef priority_queue<PII,VPII,greater<PII> > XQP;\nstruct fastIO\n{\n\tinline fastIO operator>>(int& num)\n\t{\n\t\tnum=0;\n\t\tchar c=getchar();\n\t\twhile(c!='-'&&(c<'0'||c>'9'))c=getchar();\n\t\tbool foo=0;\n\t\tif(c=='-')\n\t\t{\n\t\t\tfoo=1;\n\t\t\tc=getchar();\n\t\t}\n\t\twhile(c>='0'&&c<='9')\n\t\t{\n\t\t\tnum=(num<<3)+(num<<1)+c-'0';\n\t\t\tc=getchar();\n\t\t}\n\t\tif(foo)num=-num;\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(INT& num)\n\t{\n\t\tnum=0;\n\t\tchar c=getchar();\n\t\twhile(c!='-'&&(c<'0'||c>'9'))c=getchar();\n\t\tbool foo=0;\n\t\tif(c=='-')\n\t\t{\n\t\t\tfoo=1;\n\t\t\tc=getchar();\n\t\t}\n\t\twhile(c>='0'&&c<='9')\n\t\t{\n\t\t\tnum=(num<<3)+(num<<1)+c-'0';\n\t\t\tc=getchar();\n\t\t}\n\t\tif(foo)num=-num;\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(float& num)\n\t{\n\t\tscanf(\"%f\",&num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(double& num)\n\t{\n\t\tscanf(\"%lf\",&num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(long double& num)\n\t{\n\t\tscanf(\"%Lf\",&num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(char& num)\n\t{\n\t\tnum=getchar();\n\t\twhile(num==' '||num=='\\n')num=getchar();\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(char* num)\n\t{\n\t\tint cnt=0;\n\t\tchar c=getchar();\n\t\twhile(c==' '||c=='\\n')c=getchar();\n\t\twhile(c!=' '&&c!='\\n')\n\t\t{\n\t\t\tnum[cnt++]=c;\n\t\t\tc=getchar();\n\t\t}\n\t\tnum[cnt]=0;\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(string& num)\n\t{\n\t\tcin>>num;\n\t\treturn *this;\n\t}\n\tinline void printInt(const int& num)\n\t{\n\t\tif(num<10)\n\t\t{\n\t\t\tputchar(num+'0');\n\t\t\treturn;\n\t\t}\n\t\tprintInt(num/10);\n\t\tputchar((num%10)+'0');\n\t}\n\tinline void printINT(const INT& num)\n\t{\n\t\tif(num<10)\n\t\t{\n\t\t\tputchar(num+'0');\n\t\t\treturn;\n\t\t}\n\t\tprintINT(num/10);\n\t\tputchar((num%10)+'0');\n\t}\n\tinline fastIO operator<<(const int& num)\n\t{\n\t\tif(num<0)putchar('-'),printInt(-num);\n\t\telse printInt(num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const INT& num)\n\t{\n\t\tif(num<0)putchar('-'),printINT(-num);\n\t\telse printINT(num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const float& num)\n\t{\n\t\tprintf(\"%.10f\",num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const double& num)\n\t{\n\t\tprintf(\"%.16lf\",num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const long double& num)\n\t{\n\t\tprintf(\"%.20Lf\",num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const char& num)\n\t{\n\t\tputchar(num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const char* num)\n\t{\n\t\tfor(int i=0;num[i];i++)\n\t\t\tputchar(num[i]);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const string& num)\n\t{\n\t\tcout<<num;\n\t\treturn *this;\n\t}\n}fio;\n//Coded by Charlieyan\n//版权所有，翻印必究\n\nvector<int> nei[2005],nei2[2005];\nint num[2005];\nbool SortComp13(int a,int b){\n\treturn num[a]<num[b];\n}\n\nbool lgl[2005];\nvector<int> ltks[2005];\nint ans[2005];\n\nvoid dfs(int now,int ltk){\n\tif(lgl[now]){\n\t\treturn;\n\t}\n\tlgl[now]=1;\n\tltks[ltk].pb(now);\n\tfor(int i=0;i<SZ(nei[now]);i++){\n\t\tif(!lgl[nei[now][i]]){\n\t\t\tdfs(nei[now][i],ltk);\n\t\t\tnei2[now].pb(nei[now][i]);\n\t\t}\t\n\t}\n}\n\nint n;\n\nint gcd(int a,int b){\n\treturn !b?a:gcd(b,a%b);\n}\n\nint main(){\n\tfio>>n;\n\tfor(int i=0;i<n;i++){\n\t\tfio>>num[i];\n\t}\n\tsort(num,num+n);\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(gcd(num[i],num[j])!=1){\n\t\t\t\tnei[i].pb(j);\n\t\t\t}\n\t\t}\n\t}\n\tint cntltk=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(!lgl[i]){\n\t\t\tdfs(i,cntltk++);\n\t\t}\n\t}\n\tpriority_queue<pii> pq;\n\tfor(int i=0;i<cntltk;i++){\n\t\tpq.push(mp(num[ltks[i][0]],ltks[i][0]));\n\t}\n\tint N=0;\n\twhile(SZ(pq)){\n\t\tpii fff=pq.top();\n\t\tpq.pop();\n\t\tint Num=fff.first,x=fff.second;\n\t\tans[N++]=Num;\n\t\tfor(int i=0;i<SZ(nei2[x]);i++){\n\t\t\tpq.push(mp(num[nei2[x][i]],nei2[x][i]));\n\t\t}\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tprintf(\"%d%c\",ans[i],i==N-1?'\\n':' ');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nProblem:Rearranging\nAlgorithm:\nStatus:\n*/\n\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <map>\n#include <queue>\n#include <deque>\n#include <set>\n#include <sstream>\n#include <utility>\n#include <list>\n#include <ctime>\n#include <memory.h>\n#include <stack>\n#include <stdio.h>\n#include <string.h>\n\nusing namespace std;\n\n#define INF 1e9+7\ntypedef long long ll;\n\nint n;\nint a[2005];\nvector<int> nei[2005];\nvector<int> nei2[2005];\nbool used[2005];\nint in[2005];\nvector<int> block[2005];\nvector<int> beg[2005];\nvector<int> ans;\n\nbool cmp(const vector<int> &a,const vector<int> &b){\n\treturn a[0]>b[0];\n}\n\nvoid dfs1(int x,int id) {\n\tif(used[x])return;\n\tused[x]=true;\n\tblock[id].push_back(x);\n\tfor(int i=0; i<nei2[x].size(); i++) {\n\t\tdfs1(nei2[x][i],id);\n\t}\n}\n\nvoid dfs2(int x){\n\tif(used[x])return;\n\tused[x]=true;\n\tans.push_back(a[x]);\n\tfor(int i=0;i<nei[x].size();i++){\n\t\tdfs2(nei[x][i]);\n\t}\n}\n\nint main() {\n#ifndef ZZZYT\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n#endif\n\n\tcin>>n;\n\tfor(int i=0; i<n; i++) {\n\t\tcin>>a[i];\n\t}\n\tfor(int i=0; i<n; i++) {\n\t\tfor(int j=i+1; j<n; j++) {\n\t\t\tif(__gcd(a[i],a[j])!=1) {\n\t\t\t\tif(a[i]<a[j]){\n\t\t\t\t\tnei[i].push_back(j);\n\t\t\t\t\tin[j]++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tnei[j].push_back(i);\n\t\t\t\t\tin[i]++;\n\t\t\t\t}\n\t\t\t\tnei2[i].push_back(j);\n\t\t\t\tnei2[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\n\tint id=0;\n\tfor(int i=0; i<n; i++) {\n\t\tif(!used[i]) {\n\t\t\tdfs1(i,id);\n\t\t\tid++;\n\t\t}\n\t}\n\n\tfor(int i=0; i<id; i++) {\n\t\tfor(int j=0;j<block[i].size();j++){\n\t\t\tif(in[block[i][j]]==0){\n\t\t\t\tbeg[i].push_back(block[i][j]);\n\t\t\t}\n\t\t}\n\t\tsort(beg[i].begin(),beg[i].end());\n\t}\n\tsort(beg,beg+id,cmp);\n\t\n\tmemset(used,0,sizeof(used));\n\tfor(int i=0;i<id;i++){\n\t\tfor(int j=0;j<beg[i].size();j++){\n\t\t\tdfs2(beg[i][j]);\n\t\t}\n\t}\n\n\tfor(int i=0;i<ans.size();i++){\n\t\tcout<<ans[i]<<' ';\n\t}\n\tcout<<endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint Eulg(int a, int b);\n\nint main(int argc, char *argv[]){\n\n\tint N;\n\tcin>>N;\n\n\tint *a = new int[N]();\n\n\tfor(int i=0; i<N; i++){\n\t\tcin>>a[i];\n\t}\n\n\tsort(a, a+N);\n\n\tbool flag = true;\n\twhile(flag){\n\tfor(int i=0; i<N; i++){\n\t\tfor(int j=i+1; j<N; j++){\n\t\t\tif(Eulg(a[i], a[j]) == 1){\n\t\t\t\tif(a[i]<a[j]){\n\t\t\t\t\tint tmp;\n\t\t\t\t\ttmp =a[i];\n\t\t\t\t\ta[i] = b[j];\n\t\t\t\t\tb[j] = tmp;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t}\n}\n\nfor(int i=0; i<N; i++)\n\tcout<<a[i]<<\"  \";\n\n\n\n\tdelete[] a;\n\treturn 0;\n}\n\nint Eulg(int a, int b){\n\tif(a<b){\n\t\tint tmp;\n\t\ttmp =a;\n\t\ta = b;\n\t\tb = tmp;\n\t}\n\n\tint r;\n\tr = a % b;\n\twhile(r){\n\t\ta = b;\n\t\tb = r;\n\t\tr = a % b;\n\t}\n\treturn b;\n}"
  },
  {
    "language": "C++",
    "code": "#if 0\n2019.08.08\n\n两个不互质的数的左右关系被第一次操作安排后就不会因第二次操作再改变了。\n考虑将不互质的数连无向边，那么第一次操作实际上就是给所有边定向，且不能成环，\n之后就是 DAG ，第二次操作就是求一个拓扑序。\n\n考虑两次操作分别如何做到最优。\n先考虑第二次操作，显然就是求最大拓扑序，每次在入度为 0 的点中选值最大的放前头即可。\n在考虑第一次操作，要求定向后第二次操作的结果字典序最小。\n不同联通快之间只受第二次操作支配，那么只考虑每个联通块如何安排。\n首先选最小值作为 DAG 的唯一根，第二次操作中它一定在联通块中最先被选，删掉它，\n第二次操作中一定会第二选与它相连的点，为了让第二个选的尽量小，把根连接的点中的边从小向大连，\n以此类推，具体地，用 dfs 实现，每次当前节点向连接的点中从小到大贪心定向即可。\n#endif\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\ntypedef std::pair<int, int> Par;\ninline int input() { int x; scanf(\"%d\", &x); return x; }\n\nconst int maxn = 2020;\nint du[maxn];\nint a[maxn];\nbool link[maxn][maxn];\nbool vis[maxn];\nstd::vector<int> G[maxn];\n\nvoid dfs(int u, int n) {\n\tvis[u] = true;\n\tfor(int v = 1; v <= n; v ++)\n\t\tif(not vis[v] and link[u][v] and u != v) {\n\t\t\tlink[u][v] = link[v][u] = false;\n\t\t\t// debug(\"%d -> %d\\n\", u, v);\n\t\t\tG[u].push_back(v);\n\t\t\tdu[v] ++;\n\t\t\tdfs(v, n);\n\t\t}\n}\n\nint main() {\n\tint n = input();\n\tfor(int i = 1; i <= n; i ++)\n\t\ta[i] = input();\n\tstd::sort(a + 1, a + n + 1);\n\tfor(int i = 1; i <= n; i ++)\n\t\tfor(int j = 1; j <= n; j ++)\n\t\t\tif(std::__gcd(a[i], a[j]) > 1)\n\t\t\t\tlink[i][j] = true;\n\tfor(int i = 1; i <= n; i ++)\n\t\tif(not vis[i])\n\t\t\tdfs(i, n);\n\tstd::priority_queue<Par> q;\n\tfor(int i = 1; i <= n; i ++)\n\t\tq.push(Par(- du[i], i));\n\twhile(not q.empty()) {\n\t\tint d = - q.top().first, u = q.top().second;\n\t\tq.pop();\n\t\tif(d != du[u]) continue;\n\t\tfor(int v : G[u]) {\n\t\t\tdu[v] --;\n\t\t\tq.push(Par(- du[v], v));\n\t\t}\n\t\tprintf(\"%d \", a[u]);\n\t}\n\tputs(\"\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nconst int maxn = 2030, oo = 123456789, maxm = 34010;\n \nint n, m, T, ans, mn, a[maxn], foo[maxn], lst[maxm], tag[maxn], q[maxn], rar, mx[maxn];\nbool vis[maxn], f[maxn], G[maxn][maxn], F[maxn];\nstd::vector<int> g[maxn], has[maxn], rhas[maxm], all;\nstd::vector<std::pair<int, int> > v;\n \nvoid GEN() {\n\tint mx = 0;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif(!foo[i]) {\n\t\t\tif(a[i] == 1) {\n\t\t\t\tF[i] = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tF[i] = 0;\n\t\t\t\tfor (int j: has[i]) {\n\t\t\t\t\tif(lst[j] >= mx) {\n\t\t\t\t\t\tF[i] = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t(foo[i] > mx) && (mx = foo[i]);\n\t\t}\n\t}\n\treturn;\n}\n /*\ninline void dfs(int &u) {\n\ttag[u] = T;\n\t(F[u] && a[u] < mn) && (mn = a[u]);\n\tvis[u] = 1;\n\tfor (int &v: g[u]) {\n\t\tif(!vis[v] && !f[v]) {\n\t\t\tdfs(v);\n\t\t}\n\t}\n\treturn;\n}\n */\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tscanf(\"%d\", a + i);\n\t\tint t = a[i];\n\t\tfor (int x = 2; x * x <= t; ++x) {\n\t\t\tif(t % x == 0) {\n\t\t\t\tall.push_back(x);\n\t\t\t\twhile(t % x == 0) {\n\t\t\t\t\tt /= x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(t > 1) {\n\t\t\tall.push_back(t);\n\t\t}\n\t}\n\tstd::sort(a + 1, a + n + 1);\n\tstd::sort(all.begin(), all.end());\n\tall.resize(std::unique(all.begin(), all.end()) - all.begin());\n\tm = (int)(all.size());\n\tfor (int i = 1; i <= n; ++i) {\n\t\tF[i] = 1;\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tif(a[i] % all[j] == 0) {\n\t\t\t\thas[i].push_back(j);\n\t\t\t\trhas[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int j = 0; j < m; ++j) {\n\t\tfor (int i = 0; i < (int)(rhas[j].size()); ++i) {\n\t\t\tfor (int k = 0; k < i; ++k) {\n\t\t\t\tint u = rhas[j][i], v = rhas[j][k];\n\t\t\t\tif(!G[u][v]) {\n\t\t\t\t\tg[u].push_back(v);\n\t\t\t\t\tg[v].push_back(u);\n\t\t\t\t\tG[u][v] = G[v][u] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n//\t\tGEN();\n\t\tmemset(vis + 1, 0, sizeof(vis[0]) * n);\n\t\tv.clear();\n\t\tfor (int u = 1; u <= n; ++u) {\n\t\t\tif(F[u]) {\n\t\t\t\tif(!vis[u] && !f[u]) {\n\t\t\t\t\t++T;\n\t\t\t\t\tmn = oo;\n//\t\t\t\t\tdfs(u);\n\t\t\t\t\trar = 0;\n\t\t\t\t\tq[rar++] = u;\n\t\t\t\t\tvis[u] = 1;\n\t\t\t\t\tfor (register int fnt = 0; fnt < rar; ++fnt) {\n\t\t\t\t\t\tint u = q[fnt];\n\t\t\t\t\t\ttag[u] = T;\n\t\t\t\t\t\t(F[u] && a[u] < mn) && (mn = a[u]);\n\t\t\t\t\t\tfor (int &v: g[u]) {\n\t\t\t\t\t\t\tif(!vis[v] && !f[v]) {\n\t\t\t\t\t\t\t\tq[rar++] = v;\n\t\t\t\t\t\t\t\tvis[v] = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tv.push_back(std::make_pair(mn, T));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstd::sort(v.begin(), v.end());\n\t\tint sz = (int)(v.size());\n\t\t//ans = 0;\n\t\tfor (int u = 1; u <= n; ++u) {\n\t\t\tif(F[u] && !f[u]) {\n\t\t\t\tint i = sz - 1;\n\t\t\t\tif(v[i].second == tag[u]) {\n\t\t\t\t\t--i;\n\t\t\t\t}\n\t\t\t\tif(i < 0 || v[i].first <= a[u]) {\n\t\t\t\t\tans = u;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tf[ans] = 1;\n\t\tfoo[ans] = i;\n\t\tprintf(\"%d \", a[ans]);\n\t\tfor (int j: has[ans]) {\n\t\t\tlst[j] = i;\n\t\t}\n\t\tfor (register int j = ans + 1; j <= n; ++j) {\n\t\t\tmx[j] = i;\n\t\t\tF[j] = G[ans][j];\n\t\t}\n\t\tfor (int u: g[ans]) {\n\t\t\tif(u < ans) {\n\t\t\t\tF[u] = 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst long long inf = 1e18;\n\nstruct Task {\n\tint n;\n\tvector<int> a;\n\tvector<vector<int>> g;\n\n\tTask(int n): n(n), a(n), g(n) {\n\t\tfor (auto& item : a) {\n\t\t\tcin >> item;\n\t\t}\n\t}\n\n\tvoid dfs(int v, vector<int>& was, vector<int>& path) {\n\t\twas[v] = 1;\n\t\tfor (auto& to : g[v]) {\n\t\t\tif (was[to]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tpath[to] = v;\n\t\t\tdfs(to, was, path);\n\t\t}\n\t}\n\n\tvector<int> compute(int v, vector<int> &was) {\n\t\tvector<int> path(n, -1);\n\t\tpath[v] = v;\n\t\tdfs(v, was, path);\n\t\tpriority_queue<int> q;\n\t\tq.push(v);\n\t\tvector<int> result;\n\t\twhile (!q.empty()) {\n\t\t\tint v = q.top();\n\t\t\tq.pop();\n\t\t\tresult.push_back(a[v]);\n\t\t\tfor (auto& to : g[v]) {\n\t\t\t\tif (path[to] != v) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tq.push(to);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tvector<int> merge(vector<int>& a, vector<int>& b) {\n\t\tvector<int> result;\n\t\tint i = 0, j = 0;\n\t\twhile (i < (int)a.size() && j < (int)b.size()) {\n\t\t\tif (a[i] >= b[j]) {\n\t\t\t\tresult.push_back(a[i++]);\n\t\t\t} else {\n\t\t\t\tresult.push_back(b[j++]);\n\t\t\t}\n\t\t}\n\t\twhile (i < (int)a.size()) {\n\t\t\tresult.push_back(a[i++]);\n\t\t}\n\t\twhile (j < (int)b.size()) {\n\t\t\tresult.push_back(b[j++]);\n\t\t}\n\t\treturn result;\n\t}\n\n\tvoid run() {\n\t\tsort(a.begin(), a.end());\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\tif (i == j) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (__gcd(a[i], a[j]) > 1) {\n\t\t\t\t\tg[i].push_back(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int> was(n);\n\t\tvector<int> result;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (!was[i]) {\n\t\t\t\tvector<int> now = compute(i, was);\n\t\t\t\tresult = merge(result, now);\n\t\t\t}\n\t\t}\n\t\tfor (auto& item : result) {\n\t\t\tcout << item << ' ';\n\t\t}\n\t\tcout << '\\n';\n\t}\n};\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint n;\n\tcin >> n;\n\n\tTask a(n);\n\ta.run();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nvector<int>e[2005];int n,a[2005],vis[2005],ind[2005],use[2005];\nvoid dfs(int x){vis[x]=1;for(int i=1;i<=n;i++) if(!vis[i]&&__gcd(a[i],a[x])!=1) e[x].push_back(i),ind[i]++,dfs(i);}\nint main()\n{\n\tscanf(\"%d\",&n);for(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);sort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++) if(!vis[i]) dfs(i);\n\tfor(int i=1;i<=n;i++) for(int j=n;j;j--) if(!use[j]&&!ind[j])\n\t{\n\t\tuse[j]=1;printf(\"%d \",a[j]);\n\t\tfor(int k=0;k<e[j].size();k++) ind[e[j][k]]--;\n\t\tbreak;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint dat[2002];\nvector<int> graph[2002];\nbool visit[2005];\nint n;\n\nint gcd(int a, int b)\n{\n\treturn b ? gcd(b, a % b) : a;\n}\n\nvector<int> merge(vector<vector<int>> vvt, int head)\n{\n\tint total = 0;\n\tfor (auto &&v : vvt) total += v.size();\n\tvector<int> ret(total + (head >= 0));\n\tint ptr = 0;\n\tif (head >= 0) ret[ptr++] = head;\n\tpriority_queue<tuple<int, int, int>> pq;\n\tfor (int i = 0; i < vvt.size(); i++)\n\t{\n\t\tpq.emplace(vvt[i][0], i, 0);\n\t}\n\twhile (pq.empty() == false)\n\t{\n\t\tint val, idx, nxt;\n\t\ttie(val, idx, nxt) = pq.top();\n\t\tpq.pop();\n\t\tret[ptr++] = val;\n\n\t\tif (nxt + 1 < vvt[idx].size())\n\t\t\tpq.emplace(vvt[idx][nxt + 1], idx, nxt + 1);\n\t}\n\treturn ret;\n}\n\nvector<int> process(int t)\n{\n\tvector<vector<int>> vvt;\n\tvisit[t] = true;\n\n\tfor (int nxt : graph[t])\n\t{\n\t\tif (visit[nxt]) continue;\n\t\tvvt.emplace_back(process(nxt));\n\t}\n\n\treturn merge(move(vvt), t);\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &dat[i]);\n\t}\n\n\t//sort(dat, dat + n);\n\n\tfor (int i = 0; i < n - 1; i++)\n\t{\n\t\tfor (int j = i + 1; j < n; j++)\n\t\t{\n\t\t\tif (gcd(dat[i], dat[j]) > 1)\n\t\t\t{\n\t\t\t\tgraph[i].push_back(j);\n\t\t\t\tgraph[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) sort(graph[i].begin(), graph[i].end());\n\n\tvector<vector<int>> vvt;\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (visit[i]) continue;\n\t\tvvt.emplace_back(process(i));\n\t}\n\n\tauto ret = merge(move(vvt), -1);\n\n\tfor (int t : ret) printf(\"%d \", dat[t]);\n\tprintf(\"\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define re register\n#define ll long long\ninline int gi(){\n\tint f=1,sum=0;char ch=getchar();\n\twhile(ch>'9' || ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0' && ch<='9'){sum=(sum<<3)+(sum<<1)+ch-'0';ch=getchar();}\n\treturn f*sum;\n}\nconst int N=2010;\nint a[N],link[N][N],vis[N],d[N],n;\nvector<int>G[N];\nvoid dfs(int u){\n\tvis[u]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tif(link[u][i] && !vis[i]){\n\t\t\td[i]++;\n\t\t\tG[u].push_back(i);\n\t\t\tdfs(i);\n\t\t}\n}\nqueue<int>Q;\nint main(){\n\tn=gi();for(int i=1;i<=n;i++)a[i]=gi();\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\tif(__gcd(a[i],a[j])!=1)link[i][j]=link[j][i]=1;\n\tfor(int i=1;i<=n;i++)if(!vis[i])dfs(i);\n\tfor(int i=1;i<=n;i++)if(!d[i])Q.push(i);\n\twhile(!Q.empty()){\n\t\tint u=Q.front();Q.pop();\n\t\tprintf(\"%d \",a[u]);\n\t\tfor(auto v:G[u])Q.push(v);\n\t}\n\tputs(\"\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pb push_back\n#define all(x) x.begin(), x.end()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nconst int N = 2000 + 10;\nconst int MOD = 1000000007;\nconst int LOG = 20;\nconst int INF = 1000000010;\nconst int delta = 11353;\n\nint n;\nvi G[N], a;\nmap<int, int> mp;\nint mark[N];\nint mark2[N];\n\nvoid DFS(int v){\n\tmark[v] = 1;\n\tfor (auto u:G[v]){\n\t\tif ((mark[u] == 0) && (mark2[u] == 0)){\n\t\t\tDFS(u);\n\t\t}\n\t}\n}\nint GCD(int x, int y){\n\tif (x == 0 || y == 0) return (x + y);\n\tif (x == 1 || y == 1) return 1;\n\tif (x < y) swap(x, y);\n\treturn GCD(y, x % y);\n}\n\nint32_t main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++){\n\t\tint x;\n\t\tcin >> x;\n\t\tmp[x] ++;\n\t\ta.pb(x);\n\t}\n\tsort(all(a));\n\ta.resize(unique(all(a)) - a.begin());\n\tfor (int i = 0; i < a.size(); i++) for (int j = 0; j < i; j++) if (__gcd(a[i], a[j]) != 1){\n\t\tG[i].pb(j), G[j].pb(i);\n\t}\n\t//cout << GCD(7, 11) << '\\n';\n\tvi ans;\n\tint last = 0;\n\tfor (int i = 0; i < a.size(); i++){\n\t\tmemset(mark, 0, sizeof mark);\n\t\tif (i == 0){\n\t\t\tint mx = 0;\n\t\t\tfor (int j = 0; j < a.size(); j++) if (!mark[j]) mx = j, DFS(j);\n\t\t\tmark2[mx] = 1;\n\t\t\tans.pb(a[mx]);\n\t\t\t//cout << a[mx] << endl;\n\t\t\tlast = mx;\n\t\t}else{\n\t\t\tsort(all(G[last]));\n\t\t\tint mx = 0;\n\t\t\tfor (auto u:G[last]){\n\t\t\t\tif ((mark[u] == 0) && (mark2[u] == 0)){\n\t\t\t\t\tDFS(u), mx = u;\n\t\t\t\t\tif (u < last) assert(0);\n\t\t\t\t}\n\t\t\t}\t\n\t\t\tfor (int j = 0;  j < a.size(); j++){\n\t\t\t\tif ((mark[j] == 0) && (mark2[j] == 0)){\n\t\t\t\t\tmx = max(j, mx), DFS(j);\n\t\t\t\t\t//if (j > last) assert(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tmark2[mx] = 1;\n\t\t\tans.pb(a[mx]);\n\t\t\tlast = mx;\n\t\t\t//cout << a[mx] << endl;\n\t\t}\n\t}\n\tfor (int i = 0; i < ans.size(); i++){\n\t\tint u = ans[i];\n\t\tif (i != 0){\n\t\t\t//if (GCD(ans[i], ans[i - 1]) == 1 && ans[i - 1] < ans[i]) assert(0);\n\t\t\t//if (GCD(ans[i], ans[i - 1]) != 1 && ans[i - 1] > ans[i]) assert(0);\n\t\t\t\n\t\t}\n\t\tfor (int i = 0; i < mp[u]; i++) cout << u << ' ';\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 2010;\nconst int NN = 2010;\n\nunsigned long long one = 1;\nunsigned long long g[N][NN];\nunsigned long long was[NN];\n\nbool alive[N];\nbool can_put[N];\n\nint a[N];\nint x[N];\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", a + i);\n  }\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      if (__gcd(a[i], a[j]) > 1) {\n        g[i][j >> 6] |= (one << (j & 63));\n        g[j][i >> 6] |= (one << (i & 63));\n      }\n    }\n  }\n  int nn = ((n - 1) >> 6) + 1;\n  for (int i = 0; i < n; i++) {\n    alive[i] = true;\n    can_put[i] = true;\n  }\n  for (int it = 0; it < n; it++) {\n    for (int i = 0; i < nn; i++) {\n      was[i] = 0;\n    }\n    for (int i = 0; i < n; i++) {\n      if (!alive[i]) {\n        was[i >> 6] |= (one << (i & 63));\n      }\n    }\n    int best = -1;\n    for (int i = 0; i < n; i++) {\n      if (was[i >> 6] & (one << (i & 63))) {\n        continue;\n      }\n      int b = 0, e = 1;\n      x[0] = i;\n      was[i >> 6] |= (one << (i & 63));\n      while (b < e) {\n        for (int j = 0; j < nn; j++) {\n          if ((g[x[b]][j] & was[j]) != g[x[b]][j]) {\n            for (int u = j * 64; u < (j + 1) * 64; u++) {\n              if (g[x[b]][u >> 6] & (one << (u & 63))) {\n                if (!(was[u >> 6] & (one << (u & 63)))) {\n                  was[u >> 6] |= (one << (u & 63));\n                  x[e++] = u;\n                }\n              }\n            }\n          }\n        }\n        b++;\n      }\n      int cur = -1;\n      for (int j = 0; j < e; j++) {\n        if (!can_put[x[j]]) {\n          continue;\n        }\n        if (cur == -1 || a[x[j]] < a[cur]) {\n          cur = x[j];\n        }\n      }\n      if (best == -1 || (cur != -1 && a[cur] > a[best])) {\n        best = cur;\n      }\n    }\n    if (it > 0) putchar(' ');\n    printf(\"%d\", a[best]);\n    alive[best] = false;\n    for (int i = 0; i < n; i++) {\n      if (!alive[i]) {\n        continue;\n      }\n      if (g[best][i >> 6] & (one << (i & 63))) {\n        can_put[i] = true;\n      } else {\n        if (a[best] < a[i]) {\n          can_put[i] = false;\n        }\n      }\n    }\n  }\n  printf(\"\\n\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <vector>\n#include <cassert>\n#include <algorithm>\nusing namespace std;\n\nconst int N = 2005;\nbool G[N][N];\nbool used[N];\nvector <int> g[N];\nint n, a[N], sz;\nint in[N];\npriority_queue <int> pq;\n\ninline int gcd(int a, int b) { return !b ? a : gcd(b, a % b); }\n\nvoid dfs(int i) {\n    used[i] = 1;\n    for (int j = 0; j < n; ++ j) if (!used[j] && G[i][j]) { g[i].push_back(j); ++ in[j]; dfs(j); }\n}\n\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; ++ i) scanf(\"%d\", &a[i]);\n    sort(a, a + n);\n    for (int i = 0; i < n; ++ i) for (int j = 0; j < n; ++ j) if (i ^ j) G[i][j] = (gcd(a[i], a[j]) != 1);\n    for (int i = 0; i < n; ++ i) if (!used[i]) dfs(i);\n    for (int i = 0; i < n; ++ i) assert(in[i] <= 1);\n    for (int i = 0; i < n; ++ i) if (!in[i]) pq.push(i);\n    while (!pq.empty()) {\n        int i = pq.top(); pq.pop();\n        printf(\"%d \", a[i]);\n        for (int j = 0; j < (int) g[i].size(); ++ j) {\n            -- in[g[i][j]];\n            if (!in[g[i][j]]) pq.push(g[i][j]);\n        }\n    }\n    puts(\"\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\nstruct UnionFind{\n  Int n;\n  vector<Int> r,p;\n  UnionFind(Int x,Int y):n(x+y),r(x+y,1),p(x+y,0){\n    iota(p.begin(),p.end(),0);\n    for(Int i=0;i<x;i++) r[i]=1;\n    for(Int i=0;i<y;i++) r[x+i]=0;\n  }\n  Int find(Int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(Int x,Int y){\n    return find(x)==find(y);\n  }\n  void unite(Int x,Int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    if(r[x]<r[y]) swap(x,y);\n    r[x]+=r[y];\n    p[y]=x;\n  }\n};\n\n\ntemplate<typename T> \nmap<T, Int> factorize(T x){\n  map<T, Int> res;\n  for(Int i=2;i*i<=x;i++){\n    while(x%i==0){\n      x/=i;\n      res[i]++;\n    }\n  }\n  if(x!=1) res[x]++;\n  return res;\n}\n\n//INSERT ABOVE HERE\nInt cop[2020][2020];\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<Int> a(n);\n  for(Int i=0;i<n;i++) cin>>a[i];\n  sort(a.begin(),a.end());\n\n  vector<Int> ans(n),used(n,0),post(n,0);\n\n  memset(cop,0,sizeof(cop));\n  \n  for(Int i=0;i<n;i++)\n    for(Int j=0;j<n;j++)\n      cop[i][j]=__gcd(a[i],a[j])>1;\n\n  Int m=0;\n  map<Int, Int> r;\n\n  vector<vector<Int> > G(n);\n  for(Int i=0;i<n;i++){\n    auto x=factorize(a[i]);\n    for(auto p:x){\n      if(!r.count(p.first)) r[p.first]=m++;\n      G[i].emplace_back(r[p.first]);\n    }\n  }\n  \n  for(Int t=0;t<n;t++){\n    UnionFind uf(n,m);\n    for(Int i=0;i<n;i++)\n      if(!used[i]) for(Int j:G[i]) uf.unite(i,n+j);\n    \n    Int idx=-1,sum=t;\n    set<Int> tmp;\n    for(Int i=0;i<n;i++){\n      if(used[i]) continue;\n      Int k=uf.find(i);\n      if(!tmp.count(k)){\n\ttmp.emplace(k);\n\tsum+=uf.r[k];\n      }\n      if(post[i]) continue;\n      if(sum==n){\n\tidx=i;\n\tbreak;\n      }\n    }\n    assert(sum==n);\n    if(idx<0) post.assign(n,0);\n    //while(idx<0);\n    used[idx]=1;\n    ans[t]=idx;\n    \n    for(Int i=0;i<n;i++){\n      if(cop[idx][i]) post[i]=0;\n      else if(a[idx]<a[i]) post[i]=1;\n    }\n  }\n  for(Int i=0;i<n;i++){\n    if(i) cout<<\" \";\n    cout<<a[ans[i]];\n  }\n  cout<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#define maxn 2010\nusing namespace std;\nint read()\n{\n    int x=0,f=1;\n    char ch=getchar();\n    while(ch-'0'<0||ch-'0'>9){if(ch=='-') f=-1;ch=getchar();}\n    while(ch-'0'>=0&&ch-'0'<=9){x=x*10+ch-'0';ch=getchar();}\n    return x*f;\n}\nint gcd(int x,int y)\n{\n    if(!y)  return x;\n    return gcd(y,x%y);\n}\nint n;\nint a[maxn];\nint head[maxn],nxt[maxn*maxn],to[maxn*maxn],tot;\nvoid add(int u,int v)\n{\n    tot++;\n    nxt[tot]=head[u];\n    head[u]=tot;\n    to[tot]=v;\n}\nint book[maxn];\nvector<int>e[maxn];\nint deg[maxn];\nvoid dfs(int x)\n{\n    book[x]=1;\n    for(int i=head[x];i;i=nxt[i])\n    {\n        if(book[to[i]])  continue;\n        e[x].push_back(to[i]);\n        deg[to[i]]++;\n        dfs(to[i]);\n    }\n}\npriority_queue<int>q;\nint ans[maxn],top;\nint main()\n{\n    n=read();\n    for(int i=1;i<=n;i++)  a[i]=read();\n    sort(a+1,a+n+1);\n    for(int i=1;i<=n;i++)\n      for(int j=n;j>=1;j--)\n        if(i!=j&&gcd(a[i],a[j])>1)  add(i,j);\n    for(int i=1;i<=n;i++)\n    {\n        if(book[i]) continue;\n        dfs(i);\n    }\n    for(int i=1;i<=n;i++)\n      if(!deg[i])  q.push(i);\n    while(q.size())\n    {\n        int now=q.top();\n        q.pop();\n        ans[++top]=now;\n        for(int i=0;i<e[now].size();i++)\n        {\n            deg[e[now][i]]--;\n            if(!deg[e[now][i]])  q.push(e[now][i]);\n        }\n    }\n    for(int i=1;i<=n;i++)  printf(\"%d \",a[ans[i]]);\n    puts(\"\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int maxn = 2e3 + 10;\n\nint Gcd(int a, int b) { return b ? Gcd(b, a % b) : a; }\n\nint a[maxn];\nvector<int> adj[maxn], g[maxn];\nint deg[maxn];\nbool vis[maxn], insta[maxn];\npriority_queue<int> Q;\n\nvoid Dfs(int u)\n{\n\tvis[u] = insta[u] = true;\n\tint d = adj[u].size();\n\tfor (int i = 0; i < d; ++ i)\n\t{\n\t\tint v = adj[u][i];\n\t\tif (!vis[v]) Dfs(v);\n\t\tif (!insta[v])\n\t\t{\n\t\t\tg[u].push_back(v);\n\t\t\t++ deg[v];\n\t\t}\n\t}\n\tinsta[u] = false;\n}\n\nint main()\n{\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++ i) scanf(\"%d\", a + i);\n\tsort(a + 1, a + n + 1);\n\tfor (int i = 1; i <= n; ++ i)\n\t\tfor (int j = 1; j <= n; ++ j)\n\t\t{\n\t\t\tif (i == j) continue;\n\t\t\tif (Gcd(a[i], a[j]) != 1) adj[i].push_back(j);\n\t\t}\n\tfor (int i = 1; i <= n; ++ i)\n\t\tif (!vis[i]) Dfs(i);\n\tfor (int i = 1; i <= n; ++ i)\n\t\tif (!deg[i]) Q.push(i);\n\twhile (!Q.empty())\n\t{\n\t\tint u = Q.top();\n\t\tprintf(\"%d \", a[u]);\n\t\tQ.pop();\n\t\tint d = g[u].size();\n\t\tfor (int i = 0; i < d; ++ i)\n\t\t{\n\t\t\tint v = g[u][i];\n\t\t\tif (!-- deg[v]) Q.push(v);\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <sstream>\n#include <functional>\n#include <map>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <set>\n#include <list>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll,ll> P;\nconst double PI = 3.14159265358979323846;\nconst double EPS = 1e-12;\nconst ll INF = 1LL<<29;\nconst ll mod = 1e9+7;\n#define rep(i,n) for(int (i)=0;(i)<(ll)(n);++(i))\n#define repd(i,n,d) for(ll (i)=0;(i)<(ll)(n);(i)+=(d))\n#define all(v) (v).begin(), (v).end()\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair((x),(y))\n#define mset(m,v) memset((m),(v),sizeof(m))\n#define chmin(X,Y) ((X)>(Y)?X=(Y),true:false)\n#define chmax(X,Y) ((X)<(Y)?X=(Y),true:false)\n#define fst first\n#define snd second\n#define UNIQUE(x) (x).erase(unique(all(x)),(x).end())\ntemplate<class T> ostream &operator<<(ostream &os, const vector<T> &v){int n=v.size();rep(i,n)os<<v[i]<<(i==n-1?\"\":\" \");return os;}\n#define N 2010\nint a[N];\nint n;\nvector<int> g[N];\nbool used[N];\n\nvector<int> dfs(int u){\n\tused[u] = true;\n\tvector<int> res(1, u);\n\tvector<vector<int>> r;\n\tpriority_queue<P> q;\n\tfor(auto v: g[u]){\n\t\tif(used[v]) continue;\n\t\tvector<int> x = dfs(v);\n\t\treverse(all(x));\n\t\tr.push_back(x);\n\t\tq.push(P(x.back(), r.size()-1));\n\t}\n\twhile(!q.empty()){\n\t\tP p = q.top(); q.pop();\n\t\tres.push_back(p.fst);\n\t\tr[p.snd].pop_back();\n\t\tif(!r[p.snd].empty()) q.push(P(r[p.snd].back(), p.snd));\n\t}\n\treturn res;\n}\n\nint main(){\n\tcin>>n;\n\trep(i, n) cin>>a[i];\n\tsort(a, a+n);\n\trep(i, n) rep(j, n){\n\t\tif(i==j) continue;\n\t\tif(__gcd(a[i], a[j])>1){\n\t\t\tg[i].push_back(j);\n\t\t}\n\t}\n\trep(i, n){\n\t\tg[n].push_back(i);\n\t\t//g[i].push_back(n);\n\t}\n\tvector<int> res = dfs(n);\n\trep(i, n) cout<<a[res[i+1]]<<\" \"; cout<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> ii;\ntypedef vector<int> vi;\n\n#define SZ(x) ((int)x.size())\n\nconst int N = (int)2e3+5;\nint n, ind[N], a[N];\nbool vis[N];\nvector<int> g[N];\n\nbool dfs(int u) {\n\tvis[u] = true;\n\tfor (int v = 1; v <= n; ++v) if (__gcd(a[u], a[v]) > 1 && !vis[v]) {\n\t\tg[u].push_back(v), ++ind[v];\n\t\tdfs(v);\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++i) scanf(\"%d\", &a[i]);\n\tsort(a + 1, a + n + 1);\n\tfor (int i = 1; i <= n; ++i) if (!vis[i]) dfs(i);\n\tpriority_queue<ii> pq;\n\tfor (int i = 1; i <= n; ++i) if (!ind[i]) pq.push(ii(a[i], i));\n\twhile (SZ(pq)) {\n\t\tint u = pq.top().second; pq.pop();\n\t\tprintf(\"%d \", a[u]);\n\t\tfor (int v : g[u]) if (!(--ind[v])) pq.push(ii(a[v], v));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\nVI ME(const VI &a, const VI &b) {\n    VI ret; ret.reserve(a.size() + b.size());\n    int i = 0, j = 0;\n    while (i < (int)a.size() && j < (int)b.size()) {\n\tif (a[i] < b[j]) ret.push_back(b[j++]);\n\telse ret.push_back(a[i++]);\n    }\n    ret.insert(ret.end(), a.begin()+i, a.end());\n    ret.insert(ret.end(), b.begin()+j, b.end());\n    return ret;\n}\n\nint N;\nint A[2011];\nVI G[2011];\nbool use[2011];\n\nint D[2011], cnt;\nVI rec(int s, int last) {\n    if (A[s] == 1) {\n\tuse[s] = true;\n\treturn { 1 };\n    }\n\n    VI vs;\n    cnt++;\n    vs.push_back(s);\n    D[s] = cnt;\n    for (int i=0; i<(int)vs.size(); i++) {\n\tint v = vs[i];\n\tEACH (e, G[v]) if (!use[*e] && D[*e] != cnt) {\n\t    vs.push_back(*e);\n\t    D[*e] = cnt;\n\t}\n    }\n\n    int pick = -1;\n    EACH (e, vs) if (__gcd(last, A[*e]) > 1) {\n\tif (pick == -1 || A[pick] > A[*e]) {\n\t    pick = *e;\n\t}\n    }\n\n    // pick;\n    use[pick] = true;\n    VI cur;\n    EACH (e, G[pick]) if (!use[*e]) {\n\tVI tmp = rec(*e, A[pick]);\n\tcur = ME(cur, tmp);\n    }\n    \n    cur.insert(cur.begin(), A[pick]);\n    return cur;\n}\n\n\nvoid MAIN() {\n    scanf(\"%d\", &N);\n    REP (i, N) scanf(\"%d\", A+i);\n\n    REP (i, N) REP (j, N) if (i != j) {\n\tif (__gcd(A[i], A[j]) > 1) {\n\t    G[i].push_back(j);\n\t}\n    }\n\n    VI ans;\n\n    REP (i, N) if (!use[i]) {\n\tVI tmp = rec(i, 0);\n\tans = ME(ans, tmp);\n    }\n    rprintf(\"%d\", ans.begin(), ans.end());\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvoid Get_Val(int &Ret)\n{\n\tRet = 0;\n\tchar ch;\n\twhile (ch = getchar(), ch > '9' || ch < '0')\n\t\t;\n\tdo\n\t{\n\t\t(Ret *= 10) += ch - '0';\n\t}\n\twhile (ch = getchar(), ch >= '0' && ch <= '9');\n}\n\nconst int Max_N(2050);\n\nint gcd(const int &a, const int &b)\n{\n\treturn b == 0 ? a : gcd(b, a % b);\n}\n\nint N, A[Max_N];\nvector<int> To[Max_N];\n\ninline void Add_Edge(const int &s, const int &t)\n{\n\tTo[s].push_back(t);\n}\n\nvoid init()\n{\n\tGet_Val(N);\n\tfor (int i = 1;i <= N;++i)\n\t\tGet_Val(A[i]);\n\tsort(A + 1, A + 1 + N);\n\tfor (int s = 1;s <= N;++s)\n\t\tfor (int t = 1;t <= N;++t)\n\t\t\tif (s != t && gcd(A[s], A[t]) > 1)\n\t\t\t\tAdd_Edge(s, t);\n}\n\nbool done[Max_N];\nvector<int> Ans[Max_N], Tmp;\n\nvoid merge(vector<int> &u, vector<int> &v)\n{\n\tTmp.clear();\n\tfor (int a = 0, b = 0;a < u.size() || b < v.size();)\n\t\tif (a == u.size())\n\t\t\tTmp.push_back(v[b++]);\n\t\telse\n\t\t\tif (b == v.size())\n\t\t\t\tTmp.push_back(u[a++]);\n\t\t\telse\n\t\t\t\tif (u[a] > v[b])\n\t\t\t\t\tTmp.push_back(u[a++]);\n\t\t\t\telse\n\t\t\t\t\tTmp.push_back(v[b++]);\n\tu = Tmp;\n}\n\nvoid dfs(const int &u)\n{\n\tdone[u] = true;\n\tfor (int i = 0, v;i != To[u].size();++i)\n\t\tif (!done[v = To[u][i]])\n\t\t\tdfs(v), merge(Ans[u], Ans[v]);\n\tTmp = Ans[u];\n\tAns[u].clear(), Ans[u].push_back(A[u]);\n\tfor (int i = 0;i != Tmp.size();++i)\n\t\tAns[u].push_back(Tmp[i]);\n}\n\nvoid work()\n{\n\tfor (int x = 1;x <= N;++x)\n\t\tif (!done[x])\n\t\t\tdfs(x), merge(Ans[0], Ans[x]);\n\tfor (int i = 0;i != Ans[0].size();++i)\n\t\tprintf(\"%d \", Ans[0][i]);\n}\n\nint main()\n{\n\tinit();\n\twork();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\nconst int N=100010,M=4000010,P=1e9+7;\nconst int inf=0x3f3f3f3f;\nconst int INF=0xcfcfcfcf;\nconst double eps=1e-9,pi=asin(1)*2;\ninline ll read();\n#define cmax(a,b) a=max(a,b)\n#define cmin(a,b) a=min(a,b)\ninline int ADD(int a,int b) { return a+b>=P?a+b-P:a+b; }\ninline int MINUS(int a,int b) { return a-b<0?a-b+P:a-b; }\n#define plus(a,b) a=ADD(a,b)\n#define minus(a,b) a=MINUS(a,b)\n#define mul(a,b) a=(1ll*a*(b))%P\n#define mem(a,b) memset(a,b,sizeof(a))\n#define pii pair<int,int>\n#define pil pair<int,ll>\n#define pli pair<ll,int>\n#define pll pair<ll,ll>\n#define mp(x,y) make_pair(x,y)\n\ninline int gcd(int x,int y) { return y?gcd(y,x%y):x; }\nint head[N],ver[M],nxt[M],du[N];\nint n,m,tot=1;\nint a[N];\ninline void add(int x,int y)\n{\n\tver[++tot]=y,nxt[tot]=head[x],head[x]=tot,du[y]++;\n}\n\nbool G[2010][2010];\nbool visit[N];\ninline void dfs(int x)\n{\n\tvisit[x]=true;\n\tfor(int y=1;y<=n;y++)\n\t{\n\t\tif(visit[y]||!G[x][y]) continue;\n\t\tadd(x,y);\n\t\tdfs(y);\n\t}\n}\npriority_queue<int> q;\n\n#ifdef FILE\nconst int READ_SIZE=1<<20;\nchar buf[READ_SIZE],*p1=buf,*p2=buf;\n#define getchar() p1==p2&&(p2=(p1=buf)+fread(buf,1,READ_SIZE,stdin),p1==p2)?EOF:*p1++\n#endif\ninline ll read()\n{\n\tll s=0;\n\tbool flag=false;\n\tchar ch=getchar();\n\tfor(;ch<'0'||ch>'9';ch=getchar()) if(ch=='-') flag=true;\n\tfor(;'0'<=ch&&ch<='9';ch=getchar()) s=(s<<3)+(s<<1)+(ch^'0');\n\tif(flag) return -s;\n\treturn s;\n}\n\nint main()\n{\n#ifdef FILE\n\tfreopen(FILE \".in\",\"r\",stdin);\n\tfreopen(FILE \".out\",\"w\",stdout);\n#endif\n\tn=read();\n\tfor(int i=1;i<=n;i++) a[i]=read();\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\tif(gcd(a[i],a[j])>1)\n\t\t\t\tG[i][j]=G[j][i]=true;\n\tfor(int i=1;i<=n;i++)\n\t\tif(!visit[i]) dfs(i);\n\t\n\twhile(q.size()) q.pop();\n\tfor(int i=1;i<=n;i++)\n\t\tif(!du[i]) q.push(i);\n\t\n\twhile(q.size())\n\t{\n\t\tint x=q.top();q.pop();\n\t\tprintf(\"%d \",a[x]);\n\t\tfor(int i=head[x];i;i=nxt[i])\n\t\t{\n\t\t\tint y=ver[i];\n\t\t\tdu[y]--;\n\t\t\tif(!du[y]) q.push(y);\n\t\t}\n\t}\n\tputchar('\\n');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1000000007\nusing namespace std;\n\nint x[2010],n,cnt,minv;\nbool vis[2010],ok;\nvector<int> v[2010];\npair<int,vector<int> > e[2010];\nvector<int> ans[2010];\n\nbool cmp(pair<int,vector<int> > w,pair<int,vector<int> > k)\n{\n\treturn w.first>k.first;\n}\n\nint gcd(int a,int b)\n{\n\tif(b==0) return a;\n\telse return gcd(b,a%b);\n}\n\nvoid dfs1(int u)\n{\n\tfor(int i=0;i<v[u].size();i++) if(!vis[v[u][i]]){\n\t\tvis[v[u][i]]=true;\n\t\tminv=min(minv,v[u][i]);\n\t\te[cnt].second.push_back(v[u][i]);\n\t\tdfs1(v[u][i]);\n\t}\n}\n\nvoid dfs2(int u,int lvl,int p){\n\tif(lvl==e[p].second.size()){\n\t\tok=true;\n\t\treturn;\n\t}\n\tfor(int i=0;i<v[u].size()&&!ok;i++) if(!vis[v[u][i]]){\n\t\tvis[v[u][i]]=true;\n\t\tans[p].push_back(v[u][i]);\n\t\tdfs2(v[u][i],lvl+1,p);\n\t\tif(ok==true) return;\n\t\tvis[v[u][i]]=false;\n\t\tans[p].pop_back();\n\t}\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) cin>>x[i];\n\tsort(x+1,x+n+1);\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=i+1;j<=n;j++){\n\t\t\tif(gcd(x[i],x[j])>1){\n\t\t\t\tv[i].push_back(j);\n\t\t\t\tv[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++) if(!vis[i])\n\t{\n\t\tvis[i]=true;\n\t\t++cnt;\n\t\tminv=i;\n\t\te[cnt].second.push_back(i);\n\t\tdfs1(i);\n\t\te[cnt].first=minv;\n\t}\n\tmemset(vis,0,sizeof(vis));\n\tsort(e+1,e+cnt+1,cmp);\n\tfor(int i=1;i<=cnt;i++){\n\t\tvis[e[i].first]=true;\n\t\tok=false;\n\t\tans[i].push_back(e[i].first);\n\t\tdfs2(e[i].first,1,i);\n\t}\n\tfor(int i=1;i<=cnt;i++){\n\t\tfor(int j=0;j<ans[i].size();j++) cout<<x[ans[i][j]]<<\" \";\n\t}\n\tcout<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:1024000000,1024000000\")\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <string>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\n#define fr first\n#define sc second\nconst int N=2005,M=10000,D=N+1500+N;\nmap<int,int> S;\nvector<int> ep[D],Prm;\nint b[M+5],a[N],ans[N],mmj,n;\nint vis[D],vis0[D],xm[N],cm[N];\n\nint GetP()\n{\n    Prm.pb(0);\n    for (int i=2;i<=M;i++)\n    {\n        if (b[i]) continue;\n        Prm.pb(i);\n        for (int j=i;j<=M;j+=i) b[j]=1;\n    }\n    return Prm.size();\n}\nvoid dfs(int x)\n{\n    int i,tot=ep[x].size();vis[x]=1;if (x<=n) {if (xm[x]<=cm[x]) mmj=min(mmj,x);}\n    for (i=0;i<tot;i++) if (!vis0[ep[x][i]]&&!vis[ep[x][i]]) dfs(ep[x][i]);\n}\nint Copm(int x,int y)\n{\n    int i,j,t1=ep[x].size(),t2=ep[y].size();\n    for (i=0,j=0;i<t1&&j<t2;)\n    {\n        if (ep[x][i]==ep[y][j]) return 0;\n        if (ep[x][i]<ep[y][j]) i++; else j++;\n    }\n    return 1;\n}\nint main()\n{\n  //  freopen(\"in.txt\",\"r\",stdin);freopen(\"out.txt\",\"w\",stdout);\n    int i,j,tot=GetP();\n    scanf(\"%d\",&n);\n    for (i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n    sort(a+1,a+n+1);\n    for (i=1;i<=n;i++)\n    {\n        int x=a[i];\n        for (j=1;j<=tot;j++)\n        {\n            if (x%Prm[j]) continue;\n            ep[i].pb(n+j);ep[n+j].pb(i);\n            while (x%Prm[j]==0) x/=Prm[j];\n        }\n        if (x>1)\n        {\n            map<int,int>::iterator i1=S.find(x);\n            if (i1!=S.end()) j=(*i1).sc;\n             else {Prm.pb(x);S.insert(mp(x,Prm.size()-1));j=Prm.size()-1;}\n            ep[i].pb(n+j);ep[n+j].pb(i);\n        }\n    }\n    tot=Prm.size();\n    for (i=1;i<=n;i++)\n    {\n        int mj=0;\n        memset(vis,0,sizeof(vis));\n        for (j=1;j<=n;j++)\n         if (!vis0[j])\n         {\n               if (ans[i-1]<j) xm[j]=i-1;\n               if (!Copm(ans[i-1],j)) cm[j]=i-1; \n         }\n        for (j=1;j<=n;j++) if (!vis0[j]&&!vis[j]) {mmj=n;dfs(j);mj=max(mj,mmj);}\n        ans[i]=mj;vis0[mj]=1;\n    }\n    printf(\"%d\",a[ans[1]]);for (i=2;i<=n;i++) printf(\" %d\",a[ans[i]]);\n    puts(\"\");\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n #define rep(i, a, b) for (int i = a; i <= b; i++)\n #define vep(i, v) for (int i = 0; i < (int)v.size(); i++)\n #define fill(a, x) memset(a, x, sizeof(a))\n #define pb push_back\n #define mp make_pair\n\n typedef vector<int> Vi;\n typedef pair<int, int> Pii;\n\n const int N = 2000 + 5, M = N * N, INF = 0x3f3f3f3f;\n\n int n, es, dfs_cnt;\n int a[N], pre[N], vis[N], fa[N], is_con[N];\n Vi comp[N], all, tmp;\n bool del[N];\n\n inline int gcd(int x, int y) { return (!y) ? x : gcd(y, x % y); }\n\n struct Edge { int from, to, pre; } e[M];\n inline void init_graph() { es = dfs_cnt = 0; fill(vis, 0); fill(pre, 0); fill(is_con, 0); }\n inline void ine(int a, int b) {\n \tint i = ++es;\n \te[i].from = a; e[i].to = b; e[i].pre = pre[a];\n \tpre[a] = i;\n }\n inline void ine2(int a, int b) { ine(a, b); ine(b, a); }\n #define reg(i, x) for (int i = pre[x]; i; i = e[i].pre)\n\n inline int find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }\n inline void do_union(int from, int to) {\n \tint fx = find(from), fy = find(to);\n \tif (fx != fy) fa[fy] = fx;\n }\n\n inline void merge(Vi &v1, Vi v2) {\n \tif (v1.empty()) { v1 = v2; return; }\n \tVi tmp;\n \tint p1 = 0, p2 = 0, s1 = v1.size(), s2 = v2.size();\n // printf(\"s1 = %d  s2 = %d\\n\", s1, s2);\n \twhile (p1 < s1 && p2 < s2) {\n \t\tint x = v1[p1], y = v2[p2];\n // printf(\"p1 = %d  p2 = %d  x = %d  y = %d\\n\", p1, p2, x, y);\n \t\tif (a[x] > a[y]) tmp.pb(x), p1++; else tmp.pb(y), p2++;\n // printf(\"ok\\n\");\n \t}\n\n \tif (p1 < s1) rep(i, p1, s1 - 1) tmp.pb(v1[i]);\n \telse rep(i, p2, s2 - 1) tmp.pb(v2[i]);\n \tv1 = tmp;\n }\n\n inline void dfs(int x, int dfs_id, Vi &list) {\n \tlist.pb(x);\n \tvis[x] = dfs_id;\n // printf(\"x = %d\\n  list.sz = %lu\\n\", x, list.size());\n // vep(i, list) printf(\"list[%d] = %d\\n\", i, list[i]);\n \treg(i, x) {\n \t\tint y = e[i].to;\n \t\tif (del[y] || vis[y] == dfs_id) continue;\n \t\tdfs(y, dfs_id, list);\n \t}\n }\n\n inline Vi solve_comp(int pa, Vi cop) {\n \tVi ret, res, tmp;\n \tret.clear();\n // vep(i, cop) printf(\"cop[%d] = %d\\n\", i, cop[i]); puts(\"\");\n \tif (cop.size() == 1) { del[cop[0]] = true; ret.pb(cop[0]); return ret; }\n \tPii minp = mp(INF, 0);\n \tvep(i, cop) {\n \t\tint x = cop[i];\n // printf(\"x = %d  is_con[x] = %d\\n\", x, is_con[x]);\n \t\tif (is_con[x] != pa) continue;\n \t\tminp = min(minp, mp(a[x], x));\n \t}\n // printf(\"minp.first = %d\\n\\n\", minp.first);\n \tint sel = minp.second;\n \tdel[sel] = true;\n \tret.clear();\n \tret.pb(0);\n \treg(i, sel) {\n \t\tint y = e[i].to;\n // printf(\"sel = %d  y = %d  del = %d\", sel, y, del[y]);\n \t\tif (!del[y]) is_con[y] = sel;\n \t}\n // puts(\"\");\n // printf(\"pa = %d\\n\", pa);\n \tvep(i, cop) {\n \t\tint y = cop[i];\n \t\ttmp.clear();\n // printf(\"y = %d  del = %d\\n\", y, del[y]);\n \t\tif (!del[y]) {\n \t\t\tdfs(y, ++dfs_cnt, tmp);\n // printf(\"tmp.size = %lu\\n\", tmp.size());\n \t\t\tres = solve_comp(sel, tmp);\n // puts(\"86\");\n \t\t\tmerge(ret, res);\n \t\t}\n \t}\n // puts(\"87\");\n\n \tret[0] = sel;\n // printf(\"pa = %d  cop.size = %lu  sel = %d\\n\", pa, cop.size(), sel);\n // vep(i, ret) printf(\"ret[%d] = %d\\n\", i, ret[i]); puts(\"---------\");\n \treturn ret;\n }\n\nint main()\n{\n\t// freopen(\"atc2306.in\", \"r\", stdin);\n\n\tscanf(\"%d\", &n);\n\ta[0] = INF;\n\trep(i, 1, n) scanf(\"%d\", &a[i]), fa[i] = i, comp[i].clear();\n\n\tinit_graph();\n\trep(i, 1, n - 1) rep(j, i + 1, n)\n\t\tif (gcd(a[i], a[j]) > 1) ine2(i, j);\n\n\tfor (int i = 1; i < es; i += 2) do_union(e[i].from, e[i].to);\n\trep(i, 1, n) comp[fa[i]].pb(i);\n// rep(i, 1, n) printf(\"fa[%d] = %d\\n\", i, fa[i]);\n\n\tfill(del, false);\n\tall.clear();\n\trep(i, 1, n) if (!del[i]) {\n\t\ttmp = solve_comp(0, comp[fa[i]]);\n\t\tmerge(all, tmp);\n// printf(\"i = %d\\n\", i);\n// vep(i, all) printf(\"all[%d] = %d\\n\", i, all[i]);\n// puts(\"Line 136\\n\");\n\t}\n\n\trep(i, 0, n - 2) printf(\"%d \", a[all[i]]);\n\tprintf(\"%d\\n\", a[all[n - 1]]);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Zhupengfei 2018\n// This program / source file is in public domain.\n\n// Solution for problem: Rearranging\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n// Main segment\n\nint a[2001] = {};\nvector<int> g[2001] = {};\nbool v[2001] = {};\nvector<vector<int>> seq;\nvector<int> tmpseq;\n\nvoid dfs(int x) {\n    v[x] = 1;\n    tmpseq.push_back(a[x]);\n    for (int y : g[x]) {\n        if (!v[y]) {\n            dfs(y);\n        }\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int N;\n    cin >> N;\n    for (int i = 1; i <= N; i++) {\n        cin >> a[i];\n    }\n    sort(a + 1, a + N + 1);\n    for (int i = 1; i <= N; i++) {\n        for (int j = i + 1; j <= N; j++) {\n            if (__gcd(a[i], a[j]) != 1) {\n                g[i].push_back(j);\n                g[j].push_back(i);\n            }\n        }\n    }\n    for (int i = 1; i <= N; i++) {\n        sort(g[i].begin(), g[i].end());\n    }\n    for (int i = 1; i <= N; i++) {\n        if (!v[i]) {\n            dfs(i);\n            seq.emplace_back(std::move(tmpseq));\n            tmpseq = std::vector<int>();\n        }\n    }\n    sort(seq.begin(), seq.end(), greater<vector<int>>());\n    for (const auto& vec : seq) {\n        for (int x : vec) {\n            cout << x << \" \";\n        }\n    }\n    cout << endl;\n\n#ifdef LOCAL\n    system(\"pause\");\n#endif\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <memory.h>\n\nusing namespace std;\nconst int maxn = 2005;\n\nbool e[maxn][maxn];\nint deg[maxn],n,a[maxn],usd[maxn];\nint gcd(int n,int m) {return m?gcd(m,n%m):n;}\n\nvoid dfs(int u)\n{\n\tusd[u]=1;\n\tfor (int j=1;j<=n;j++)\n\tif (e[u][j]) {\n\t\tif (!usd[j]) {\n\t\t\te[j][u]=false;deg[j]++;dfs(j);\n\t\t}\n\t\telse {\n\t\t\te[j][u]=e[u][j]=false;\n\t\t}\n\t}\n}\nint main()\n{\n\t#ifdef Amberframe\n\t\tfreopen(\"agc010e.in\",\"r\",stdin);\n\t\tfreopen(\"agc010e.out\",\"w\",stdout);\n\t#endif\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tsort(a+1,a+n+1);\n\t\n\tfor (int i=1;i<=n;i++)\n\tfor (int j=i+1;j<=n;j++)\n\t\tif (gcd(a[i],a[j])>1) e[i][j]=e[j][i]=true; \n\tfor (int i=1;i<=n;i++)\n\t\tif (!usd[i]) dfs(i);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tint pos=n;while (!usd[pos]||deg[pos]) --pos;\n\t\tprintf(\"%d \",a[pos]);usd[pos]=0;\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tif (e[pos][j]) --deg[j];\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nconst int maxn = 2030, oo = 123456789, maxm = 34010;\n \nint n, m, T, ans, mn, a[maxn], foo[maxn], lst[maxm], tag[maxn], q[maxn], rar, mx[maxn];\nbool vis[maxn], f[maxn], G[maxn][maxn], F[maxn];\nstd::vector<int> g[maxn], has[maxn], rhas[maxm], all;\nstd::vector<std::pair<int, int> > v;\n \nvoid GEN() {\n\tint mx = 0;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif(!foo[i]) {\n\t\t\tif(a[i] == 1) {\n\t\t\t\tF[i] = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tF[i] = 0;\n\t\t\t\tfor (int j: has[i]) {\n\t\t\t\t\tif(lst[j] >= mx) {\n\t\t\t\t\t\tF[i] = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t(foo[i] > mx) && (mx = foo[i]);\n\t\t}\n\t}\n\treturn;\n}\n /*\ninline void dfs(int &u) {\n\ttag[u] = T;\n\t(F[u] && a[u] < mn) && (mn = a[u]);\n\tvis[u] = 1;\n\tfor (int &v: g[u]) {\n\t\tif(!vis[v] && !f[v]) {\n\t\t\tdfs(v);\n\t\t}\n\t}\n\treturn;\n}\n */\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tscanf(\"%d\", a + i);\n\t\tint t = a[i];\n\t\tfor (int x = 2; x * x <= t; ++x) {\n\t\t\tif(t % x == 0) {\n\t\t\t\tall.push_back(x);\n\t\t\t\twhile(t % x == 0) {\n\t\t\t\t\tt /= x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(t > 1) {\n\t\t\tall.push_back(t);\n\t\t}\n\t}\n\tstd::sort(a + 1, a + n + 1);\n\tstd::sort(all.begin(), all.end());\n\tall.resize(std::unique(all.begin(), all.end()) - all.begin());\n\tm = (int)(all.size());\n\tfor (int i = 1; i <= n; ++i) {\n\t\tF[i] = 1;\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tif(a[i] % all[j] == 0) {\n\t\t\t\thas[i].push_back(j);\n\t\t\t\trhas[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int j = 0; j < m; ++j) {\n\t\tfor (int i = 0; i < (int)(rhas[j].size()); ++i) {\n\t\t\tfor (int k = 0; k < i; ++k) {\n\t\t\t\tint u = rhas[j][i], v = rhas[j][k];\n\t\t\t\tif(!G[u][v]) {\n\t\t\t\t\tg[u].push_back(v);\n\t\t\t\t\tg[v].push_back(u);\n\t\t\t\t\tG[u][v] = G[v][u] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n//\t\tGEN();\n\t\tmemset(vis + 1, 0, sizeof(vis[0]) * n);\n\t\tv.clear();\n\t\tfor (int u = 1; u <= n; ++u) {\n\t\t\tif(F[u]) {\n\t\t\t\tif(!vis[u] && !f[u]) {\n\t\t\t\t\t++T;\n\t\t\t\t\tmn = oo;\n//\t\t\t\t\tdfs(u);\n\t\t\t\t\trar = 0;\n\t\t\t\t\tq[rar++] = u;\n\t\t\t\t\tvis[u] = 1;\n\t\t\t\t\tfor (register int fnt = 0; fnt < rar; ++fnt) {\n\t\t\t\t\t\tint u = q[fnt];\n\t\t\t\t\t\ttag[u] = T;\n\t\t\t\t\t\t(F[u] && a[u] < mn) && (mn = a[u]);\n\t\t\t\t\t\tfor (int &v: g[u]) {\n\t\t\t\t\t\t\tif(!vis[v] && !f[v]) {\n\t\t\t\t\t\t\t\tq[rar++] = v;\n\t\t\t\t\t\t\t\tvis[v] = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tv.push_back(std::make_pair(mn, T));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstd::sort(v.begin(), v.end());\n\t\tint sz = (int)(v.size());\n\t\t//ans = 0;\n\t\tfor (int u = 1; u <= n; ++u) {\n\t\t\tif(F[u] && !f[u]) {\n\t\t\t\tint i = sz - 1;\n\t\t\t\tif(v[i].second == tag[u]) {\n\t\t\t\t\t--i;\n\t\t\t\t}\n\t\t\t\tif(i < 0 || v[i].first <= a[u]) {\n\t\t\t\t\tans = u;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tf[ans] = 1;\n\t\tfoo[ans] = i;\n\t\tprintf(\"%d \", a[ans]);\n\t\tfor (int j: has[ans]) {\n\t\t\tlst[j] = i;\n\t\t}\n\t\tfor (register int j = ans + 1; j <= n; ++j) {\n\t\t\tmx[j] = i;\n\t\t\tF[j] = G[ans][j];\n\t\t}\n\t\tfor (int j: has[ans]) {\n\t\t\tfor (register int &k: rhas[j]) {\n\t\t\t\tif(k > ans) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tF[k] |= (lst[j] >= mx[k]);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\nconst int MaxN = 2000 + 10 ;\nint N , A[MaxN] ;\nbool Map[MaxN][MaxN] , Vis[MaxN] ;\nint Cnt , Head[MaxN] , To[MaxN] , Next[MaxN] , In[MaxN] ;\ninline void Add( int U , int V ) {\n\tTo[++Cnt] = V ;\n\tNext[Cnt] = Head[U] ;\n\tHead[U] = Cnt ;\n\t++In[V] ;\n}\nvoid Dfs( int Nod ) {\n\tVis[Nod] = true ;\n\tfor(register int i = 0 ; ++i <= N ; )\n\t\tif( Map[Nod][i] and not Vis[i] ) {\n\t\t\tAdd( Nod , i ) ;\n\t\t\tDfs( i ) ;\n\t\t}\n}\npriority_queue<int> Q ;\nint main() {\n\tscanf( \"%d\" , &N ) ;\n\tfor(register int i = 0 ; ++i <= N ; )\n\t\tscanf( \"%d\" , &A[i] ) ;\n\tsort( A + 1 , A + 1 + N ) ;\n\tfor(register int i = 0 ; ++i <= N ; )\n\t\tfor(register int j = 0 ; ++j <= N ; )\n\t\t\tMap[i][j] = __gcd( i , j ) != 1 ;\n\tfor(register int i = 0 ; ++i <= N ; )\n\t\tif( not Vis[i] ) Dfs( i ) ;\n\tfor(register int i = 0 ; ++i <= N ; )\n\t\tif( In[i] == 0 )\n\t\t\tQ.push( i ) ;\n\twhile( Q.size() ) {\n\t\tregister int Nod = Q.top() ;\n\t\tQ.pop() ;\n\t\tprintf( \"%d \" , Nod ) ;\n\t\tfor(register int i = Head[Nod] ; i ; i = Next[i] )\n\t\t\tif( --In[To[i]] == 0 )\n\t\t\t\tQ.push( To[i] ) ;\n\t}\n\treturn 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#define ALL(v) v.begin(), v.end()\nusing namespace std;\ntypedef long long LL;\ntypedef vector <int> vec;\nconst int N = 2000 + 5;\nint a[N], dsu[N];\nint n;\nint vis[N];\nvec G[N], idx[N], ans;\nint find(int x){\n\treturn x == dsu[x] ? x : dsu[x] = find(dsu[x]);\n}\nvoid unite(int x, int y){\n\tif(find(x) < find(y)){\n\t\tdsu[find(y)] = find(x);\n\t}else if(find(x) > find(y)){\n\t\tdsu[find(x)] = find(y);\n\t}\n}\nvec mer(vec a, vec b){\n\tvec ret;\n\tfor(int i = 0, j = 0; i < a.size() || j < b.size(); ){\n\t\tif(i < a.size() && j < b.size()){\n\t\t\tif(a[i] >= b[j]) ret.push_back(a[i ++]);\n\t\t\telse ret.push_back(b[j ++]);\n\t\t}else if(i < a.size()){\n\t\t\tret.push_back(a[i ++]);\n\t\t}else{\n\t\t\tret.push_back(b[j ++]);\n\t\t}\n\t}\n\treturn ret;\n}\nvec dfs(int o){\n\tvec ret;\n\t//printf(\"o = %d\\n\", o);\n\tvis[o] = 1;\n\tfor(int i = 0; i < G[o].size(); i ++){\n\t\tif(vis[G[o][i]] == 1) continue;\n\t\tret = mer(ret, dfs(G[o][i]));\n\t}\n\tret.insert(ret.begin(), a[o]);\n\treturn ret;\n}\nint main(){\n\tint u, v;\n\tscanf(\"%d\", &n);\n\tfor(int i = 1; i <= n; i ++) scanf(\"%d\", &a[i]), dsu[i] = i;\n\tsort(a+1,a+n+1);\n\tfor(int i = 1; i <= n; i ++){\n\t\tfor(int j = i+1; j <= n; j ++){\n\t\t\tif(__gcd(a[i], a[j]) != 1){\n\t\t\t\tG[i].push_back(j);\n\t\t\t\tG[j].push_back(i);\n\t\t\t\tunite(i, j);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 1; i <= n; i ++){\n\t\tif(dsu[i] == i) ans = mer(ans, dfs(i));\n\t}\n\tfor(int i = 0; i < ans.size(); i ++){\n\t\tprintf(\"%d \", ans[i]);\n\t}puts(\"\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 2005\nusing namespace std;\ndeque<int> ans[N];\nvector<int> g[N];\nint n,vis[N],val[N];\ndeque<int> merge(deque<int> a,deque<int> b){//merge b to a\n    deque<int> ret;\n    while(!a.empty()||!b.empty())\n        if(b.empty() || (!a.empty() && a.front()>b.front() ))\n            ret.push_back(a.front()),a.pop_front();\n        else ret.push_back(b.front()),b.pop_front();\n    return ret;\n}\nvoid DFS(int u){\n    vis[u]=1;\n    for(int i:g[u])\n        if(vis[i]==0)\n            DFS(i),ans[u]=merge(ans[u],ans[i]);\n    ans[u].push_front(val[u]);\n}\nint main(){\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++) scanf(\"%d\",&val[i]);\n    sort(val+1,val+n+1);\n    for(int i=1;i<=n;i++)\n        for(int j=i+1;j<=n;j++)\n            if(__gcd(val[j],val[i])!=1) \n                g[i].push_back(j),g[j].push_back(i);\n    for(int i=1;i<=n;i++) sort(g[i].begin(),g[i].end());\n    for(int i=1;i<=n;i++)\n        if(vis[i]==0)\n            DFS(i),ans[0]=merge(ans[0],ans[i]);\n    for(int i:ans[0]) printf(\"%d \",i);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef int sign;\ntypedef long long ll;\n#define For(i,a,b) for(register sign i=(sign)a;i<=(sign)b;++i)\n#define Fordown(i,a,b) for(register sign i=(sign)a;i>=(sign)b;--i)\nconst int N=2e3+5;\ntemplate<typename T>bool cmax(T &a,T b){return (a<b)?a=b,1:0;}\ntemplate<typename T>bool cmin(T &a,T b){return (a>b)?a=b,1:0;}\ntemplate<typename T>T read()\n{\n\tT ans=0,f=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch)&&ch!='-')ch=getchar();\n\tif(ch=='-')f=-1,ch=getchar();\n\twhile(isdigit(ch))ans=(ans<<3)+(ans<<1)+(ch-'0'),ch=getchar();\n\treturn ans*f;\n}\ntemplate<typename T>void write(T x,char y)\n{\n\tif(x==0)\n\t{\n\t\tputchar('0'),putchar(y);\n\t\treturn;\n\t}\n\tif(x<0)\n\t{\n\t\tputchar('-');\n\t\tx=-x;\n\t}\n\tstatic char wr[20];\n\tint top=0;\n\tfor(;x;x/=10)wr[++top]=x%10+'0';\n\twhile(top)putchar(wr[top--]);\n\tputchar(y);\n}\nvoid file()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"E.in\",\"r\",stdin);\n\tfreopen(\"E.out\",\"w\",stdout);\n#endif\n}\nint n,a[N],b[N],top;\nvoid input()\n{\n\tn=read<int>();\n\tFor(i,1,n)a[i]=b[i]=read<int>();\n}\nvoid init()\n{\n\tsort(b+1,b+n+1);\n\ttop=unique(b+1,b+n+1)-b-1;\n\tFor(i,1,n)a[i]=lower_bound(b+1,b+top+1,a[i])-b;\n}\nvector<int>E[N];\nbool vis[N];\ntypedef pair<int,int>pii;\n#define mk make_pair\n#define fir first\n#define sec second\npriority_queue<pii>q;\n#define pb push_back\nint nex[N],l[N];\nbool cmp(int x,int y){return a[x]<a[y];}\nvoid dfs(int u)\n{\n\tint Min=n+1;\n\tvis[u]=1;\n\tfor(int v:E[u])if(!vis[v])cmin(Min,v);\n\tif(Min>n)return;\n\tnex[u]=Min;dfs(Min);\n}\nvoid work()\n{\n\tFor(i,1,n)For(j,i+1,n)\n\t{\n\t\tif(__gcd(b[a[i]],b[a[j]])!=1)\n\t\t{\n\t\t\tE[i].pb(j),E[j].pb(i);\t\t\t\n\t\t}\n\t}\n\tFor(i,1,n)l[i]=i;\n\tsort(l+1,l+n+1,cmp);\n\tFor(i,1,n)if(!vis[l[i]])dfs(l[i]),q.push(mk(b[a[l[i]]],l[i]));\n\t//For(i,1,n)if(!d[i])q.push(mk(b[a[i]],i));\n\tpii t;\n\twhile(!q.empty())\n\t{\n\t\tt=q.top();q.pop();\n\t\twrite(t.fir,' ');\n\t\tif(nex[t.sec])q.push(mk(b[a[nex[t.sec]]],nex[t.sec]));\n\t}\n}\nint main()\n{\n\t//file();\n\tinput();\n\tinit();\n\twork();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "///////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////\n//                       _oo0oo_                         //\n//                      o8888888o                        //\n//                      88\" . \"88      ------ hzt1       //\n//                      (| -_- |)                        //\n//                      0\\  =  /0                        //\n//                    ___/`---'\\___                      //\n//                  .' \\|     |// '.                     //\n//                 / \\|||  :  |||// \\                    //\n//                / _||||| -:- |||||- \\                  //\n//               |   | \\  -  /// |     |                 //\n//               | \\_|  ''\\---/''  |_/ |                 //\n//               \\  .-\\__  '-'  ___/-. /                 //\n//             ___'. .'  /--.--\\  `. .'___               //\n//          .\"\" '<  `.___\\_<|>_/___.' >' \"\".             //\n//         | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |           //\n//         \\  \\ `_.   \\_ __\\ /__ _/   .-` /  /           //\n//     =====`-.____`.___ \\_____/___.-`___.-'=====        //\n//                       `=---='                         //\n//                                                       //\n//                                                       //\n//     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~       //\n//                                                       //\n//                 God-He Bless All.                     //\n//           This Code Will Never Explode.               //\n//                                                       //\n//                                                       //\n///////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////\n#include<cstdio>\n#include<cstring>\n#include<cctype>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#define pb push_back\n#define mp make_pair\n#define xx first\n#define yy second\n#define rep(i,a,b) for(int i=(a),i##_end_=(b);i<=i##_end_;i++)\n#define dwn(i,a,b) for(int i=(a),i##_end_=(b);i>=i##_end_;i--)\nusing namespace std;\nconst int Size=1<<16;\nchar buffer[Size],*head,*tail;\ninline char Getchar() {\n    if(head==tail) {\n        int l=fread(buffer,1,Size,stdin);\n        tail=(head=buffer)+l;\n    }\n    if(head==tail) return -1;\n    return *head++;\n}\ninline int read() {\n    int x=0,f=1;char c=getchar();\n    for(;!isdigit(c);c=getchar()) if(c=='-') f=-1;\n    for(;isdigit(c);c=getchar()) x=x*10+c-'0';\n    return x*f;\n}\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int maxn=2048;\nint gcd(int a,int b) {return !b?a:gcd(b,a%b);}\nint n,A[maxn],e[maxn][maxn],e2[maxn][maxn];\nint vis[maxn],clo;\nvoid dfs(int x,int fa) {\n\tvis[x]=++clo;\n\trep(i,1,n) if(e[x][i]&&i!=fa) {\n\t\tif(!vis[i]) {\n\t\t\te2[x][i]=1;\n\t\t\tdfs(i,x);\n\t\t}\n\t\telse if(vis[i]<vis[x]) e2[i][x]=1;\n\t}\n}\nint in[maxn];\npriority_queue<int> Q;\nvoid solve() {\n\trep(i,1,n) rep(j,1,n) if(e2[i][j]) in[j]++;\n\trep(i,1,n) if(!in[i]) Q.push(i);\n\twhile(Q.size()) {\n\t\tint x=Q.top();Q.pop();\n\t\tprintf(\"%d \",A[x]);\n\t\trep(i,1,n) if(e2[x][i]) {\n\t\t\tif(!(--in[i])) Q.push(i);\n\t\t}\n\t}\n}\nint main() {\n\tn=read();\n\trep(i,1,n) A[i]=read();\n\tsort(A+1,A+n+1);\n\trep(i,1,n) rep(j,i+1,n) if(gcd(A[i],A[j])>1) e[i][j]=e[j][i]=1;\n\trep(i,1,n) if(!vis[i]) dfs(i,0);\n\tsolve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define repu(i,x,y) for (int i=x; i<=y; ++i)\n#define repd(i,x,y) for (int i=x; i>=y; --i)\nusing namespace std;\n\nint n,a[2010];\nbool flag[2010];\nstruct edge\n{\n    int v;\n    edge *nxt;\n} pool[4000100],*tp=pool,*fst[2010];\nstruct data\n{\n    int n,a[2010];\n    void add(int x)\n    {\n        repd(i,n,1)\n            a[i+1]=a[i];\n        a[1]=x,++n;\n    }\n    void merge(data &b)\n    {\n        static int c[2010];\n        int m=0;\n        for (int i=1,j=1; i<=n || j<=b.n;)\n            if (i<=n && (j>b.n || a[i]>b.a[j]))\n                c[++m]=a[i++];\n            else\n                c[++m]=b.a[j++];\n        memcpy(a,c,sizeof(a)),n=m;\n    }\n} f[2010],ans;\n\nint gcd(int x,int y)\n{\n    for (int t; t=x%y; x=y,y=t);\n    return y;\n}\n\nvoid dfs(int x)\n{\n    flag[x]=1;\n    for (edge *i=fst[x]; i; i=i->nxt)\n        if (!flag[i->v])\n            dfs(i->v),f[x].merge(f[i->v]);\n    f[x].add(x);\n}\n\nint main()\n{\n    scanf(\"%d\",&n);\n    repu(i,1,n)\n        scanf(\"%d\",&a[i]);\n    sort(a+1,a+1+n);\n    repu(i,1,n)\n        repd(j,n,1)\n            if (i!=j && gcd(a[i],a[j])>1)\n                *tp=(edge){j,fst[i]},fst[i]=tp++;\n    repu(i,1,n)\n        if (!flag[i])\n            dfs(i),ans.merge(f[i]);\n    repu(i,1,n)\n        printf(\"%d \",a[ans.a[i]]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// This amazing code is by Eric Sunli Chen.\n#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\ntemplate<typename T> bool get_int(T &x)\n{\n\tchar t=getchar();\n\tbool neg=false;\n\tx=0;\n\tfor(; (t>'9'||t<'0')&&t!='-'&&t!=EOF; t=getchar());\n\tif(t=='-')neg=true,t=getchar();if(t==EOF)return false;\n\tfor(; t<='9'&&t>='0'; t=getchar())x=x*10+t-'0';\n\tif(neg)x=-x;return true;\n}\ntemplate<typename T> void print_int(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tshort a[20]= {},sz=0;\n\twhile(x>0)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1; i>=0; i--)putchar('0'+a[i]);\n}\n#define ff first\n#define ss second\n#define pb push_back\n#define mp make_pair\n#define get1(a) get_int(a)\n#define get2(a,b) (get1(a)&&get1(b))\n#define get3(a,b,c) (get1(a)&&get2(b,c))\n#define printendl(a) print_int(a),puts(\"\")\ntypedef long long LL;\ntypedef unsigned long long uLL;\ntypedef pair<int,int> pii;\nconst int inf=0x3f3f3f3f;\nconst LL Linf=1ll<<61;\nconst double pi=acos(-1.0);\n\nvector<int>g[2333],seq[2333],tmp;\nbool use[2333];\nint n,a[2333];\n\nvoid dfs(int x)\n{\n\tuse[x]=1;\n\tfor(auto v:g[x])if(!use[v])\n\t{\n\t\tdfs(v);\n\t\ttmp.resize(seq[x].size()+seq[v].size());\n\t\tmerge(seq[x].begin(),seq[x].end(),seq[v].begin(),seq[v].end(),tmp.begin());\n\t\tseq[x]=tmp;\n\t}\n\tseq[x].resize(seq[x].size()+1);for(int i=seq[x].size()-2;i>=0;i--)seq[x][i+1]=seq[x][i];\n\tseq[x][0]=-a[x];\n}\n\nint main()\n{\n\tget1(n);\n\tfor(int i=1;i<=n;i++)\n\t\tget1(a[i]);\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++)for(int j=1;j<=n;j++)if(i!=j&&__gcd(a[i],a[j])>1)\n\t{\n\t\tg[i].pb(j);\n\t\tg[j].pb(i);\n\t}\n\tfor(int i=1;i<=n;i++)sort(g[i].begin(),g[i].end());\n\tvector<int> ans;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(use[i])continue;\n\t\tdfs(i);\n\t\ttmp.resize(ans.size()+seq[i].size());\n\t\tmerge(ans.begin(),ans.end(),seq[i].begin(),seq[i].end(),tmp.begin());\n\t\tans=tmp;\n\t}\n\tfor(auto x:ans)printf(\"%d \",-x);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst int INF=1001001001001001001ll;\n\nint gcd(int a,int b){\n    return b?gcd(b,a%b):a;\n}\n\nint N;\nint A[2222];\n\nvint G[22222];\n\nbool ex[22222];\nbool ok[22222];\nbool vis[22222];\n\nint dfs(int v){\n    vis[v]=true;\n    int ret=INF;\n    if(ok[v])ret=A[v];\n    for(auto u:G[v]){\n        if(vis[u]||!ex[u])continue;\n        chmin(ret,dfs(u));\n    }\n    return ret;\n}\n\nsigned main(){\n    cin>>N;\n    rep(i,N)cin>>A[i];\n\n    vint ps;\n    rep(i,N){\n        int a=A[i];\n        for(int j=2;j*j<=a;j++){\n            if(a%j)continue;\n            ps.pb(j);\n            while(a%j==0)a/=j;\n        }\n        if(a!=1)ps.pb(a);\n    }\n    sort(all(ps));ps.erase(unique(all(ps)),ps.end());\n\n    rep(k,ps.size()){\n        rep(i,N){\n            if(A[i]%ps[k]==0){\n                G[N+k].pb(i);\n                G[i].pb(N+k);\n            }\n        }\n    }\n\n    rep(i,N)ok[i]=true;\n    rep(i,N+ps.size())ex[i]=true;\n\n    rep(i,N){\n        memset(vis,0,sizeof(vis));\n\n        int ei=-1;\n        rep(j,N){\n            if(vis[j]||!ex[j])continue;\n            int tmp=dfs(j);\n            if(tmp!=INF)chmax(ei,tmp);\n        }\n        int k=-1;\n        rep(j,N)if(A[j]==ei&&ex[j])k=j;\n\n\n        ex[k]=false;\n        rep(j,N)if(ex[j]&&A[j]>A[k])ok[j]=false;\n        rep(j,N)if(ex[j]&&gcd(A[j],A[k])!=1)ok[j]=true;\n\n\n        if(i)cout<<\" \";\n        cout<<A[k];\n    }cout<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<queue>\n#include<vector>\nusing namespace std;\nconst int N=2333;\nint a[N];\nint g[N][N];\nint n;\nint gcd(int a,int b){return b?gcd(b,a%b):a;}\nstruct sumireko{int to,ne;}e[N*1000];\nint he[N],ecnt;\nvoid addline(int f,int t)\n{\n\te[++ecnt].to=t;\n\te[ecnt].ne=he[f];\n\the[f]=ecnt;\n}\n\nbool vv[N];\nint bi;\nint sp[N];\nvector<int> to[N];\nvoid dfs(int x)\n{\n\tvv[x]=1;\n\tfor(int i=he[x],t;i;i=e[i].ne)\n\t{\n\t\tt=e[i].to;\n\t\tif(!vv[t])\n\t\t{\n\t\t\tto[x].push_back(t);\n\t\t\tdfs(t);\n\t\t}\n\t}\n}\n\npriority_queue<int> q;\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tsort(a+1,a+1+n);\n\tfor(int i=n;i;i--)\n\t\tfor(int j=i-1;j;j--)\n\t\t\tif(gcd(a[i],a[j])!=1)\n\t\t\t\taddline(i,j),addline(j,i)/*,printf(\"line %d %d\\n\",i,j)*/;\n\tfor(int i=1;i<=n;i++) if(!vv[i])\n\t{\n\t\tbi++;\n\t\tsp[bi]=i;\n\t\tdfs(i);\n\t}\n\t/*printf(\"%d\\n\",bi);\n\tfor(int i=1;i<=bi;i++) printf(\"%d \",sp[i]);\n\tputs(\"\\n----------------------------------\");\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tprintf(\"%d:\",i);\n\t\tfor(int j=0;j<to[i].size();j++) printf(\"%d \",to[i][j]);\n\t\tputchar('\\n');\n\t}\n\tputs(\"\\n----------------------------------\");*/\n\tfor(int i=1;i<=bi;i++)\n\t\tq.push(sp[i]);\n\twhile(!q.empty())\n\t{\n\t\tint g=q.top();\n\t\tq.pop();\n\t\tprintf(\"%d \",a[g]);\n\t\tfor(int i=0;i<to[g].size();i++) q.push(to[g][i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<ctime>\n#include<queue>\n#include<set>\n#include<map>\n#include<stack>\n#include<bitset>\nusing namespace std;\ntypedef vector<int> vi;\nconst int N=2010;\nint gi() {\n\tint w=0;bool q=1;char c=getchar();\n\twhile ((c<'0'||c>'9') && c!='-') c=getchar();\n\tif (c=='-') q=0,c=getchar();\n\twhile (c>='0'&&c <= '9') w=w*10+c-'0',c=getchar();\n\treturn q? w:-w;\n}\nint a[N],n;\nbool v[N];\nstruct cmp{ bool operator () (const vi &a,const vi &b) { return a.back()<b.back(); } };\nvi merge(vector<vi> p) {\n\tpriority_queue<vi,vector<vi>,cmp>q;\n\tfor (auto k:p) reverse(k.begin(),k.end()),q.push(k);\n\tvi ans,t;\n\twhile (!q.empty()) {\n\t\tt=q.top();q.pop();\n\t\tans.push_back(t.back());t.pop_back();\n\t\tif (!t.empty()) q.push(t);\n\t}\n\treturn ans;\t\n}\ninline vi dfs(int k) {\n\tv[k]=true;\n\tvector<vi>ans;\n\tfor (int i=1;i<=n;i++)\n\t\tif (!v[i]&&__gcd(a[k],a[i])!=1)\n\t\t\tans.push_back(dfs(i));\n\tvi v=merge(ans);\n\tv.insert(v.begin(),a[k]);\n\treturn v;\n}\nint main()\n{\n\tn=gi();\n\tfor (int i=1;i<=n;i++) a[i]=gi();\n\tsort(a+1,a+1+n);\n\tvector<vi>ans;\n\tfor (int i=1;i<=n;i++)\n\t\tif (!v[i])\n\t\t\tans.push_back(dfs(i));\n\tvi v=merge(ans);\n\tfor (auto k:v)\n\t\tprintf(\"%d \",k);\n\tputchar(10);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <deque>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <vector>\n\n#define FOR(i,k,n) for (int (i)=(k); (i)<(n); ++(i))\n#define rep(i,n) FOR(i,0,n)\n#define pb push_back\n#define all(v) begin(v), end(v)\n#define debug(x) cerr<< #x <<\": \"<<x<<endl\n#define debug2(x,y) cerr<< #x <<\": \"<< x <<\", \"<< #y <<\": \"<< y <<endl\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll> > vvll;\ntemplate<class T> using vv=vector<vector< T > >;\n\nvi a; // number of node\nvvi g;\nvvi child;\nset<int, greater<int> > root;\ndeque<bool> reached;\n\nvoid dfs(int s) {\n  root.insert(s);\n  deque<int> st;\n  st.push_back(s);\n  reached[s] = true;\n  while (!st.empty()) {\n    int u = st.back();\n    for (int v : g[u]) {\n      if (!reached[v]) {\n        child[u].push_back(v);\n        st.push_back(v);\n        reached[v] = true;\n        st.push_back(v);\n        break;\n      }\n    }\n    if (st.back() == u) {\n      st.pop_back();\n    }\n  }\n}\n\nvi retrieve(int r) {\n  int sz = (int)child[r].size();\n  if (sz == 0) {\n    return (vi){r};\n  }\n  int ret_size = 0;\n  vvi tmp(sz);\n  rep (i, sz) {\n    tmp[i] = retrieve(child[r][i]);\n    tmp[i].push_back(-1);\n    ret_size += (int)tmp[i].size();\n  }\n  vi ret;\n  ret.reserve(ret_size + 10);\n  ret.push_back(r);\n  vi index(sz, 0);\n  while (true) {\n    int next_i = -1;\n    int selected = -1;\n    rep (i, sz) {\n      if (next_i < tmp[i][index[i]]) {\n        next_i = tmp[i][index[i]];\n        selected = i;\n      }\n    }\n    if (next_i == -1) {\n      break;\n    }\n    ret.push_back(next_i);\n    index[selected] += 1;\n  }\n  return ret;\n}\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  a.resize(n);\n  rep (i, n) {\n    scanf(\"%d\", &a[i]);\n  }\n  sort(all(a));\n\n  g.resize(n);\n  rep (i, n) {\n    rep (j, n) {\n      if (i == j) {\n        continue;\n      }\n      if (__gcd(a[i], a[j]) == 1) {\n        continue;\n      }\n      g[i].push_back(j);\n      g[j].push_back(i);\n    }\n  }\n  rep (i, n) {\n    sort(all(g[i]));\n  }\n\n  // construct tree\n  child.resize(n);\n  reached.assign(n, false);\n  rep (i, n) {\n    if (reached[i]) {\n      continue;\n    }\n    if (a[i] == 1) {\n      root.insert(i);\n      reached[i] = true;\n      continue;\n    }\n    dfs(i);\n  }\n\n  for (int r : root) {\n    vi tmp = retrieve(r);\n    for (int i : tmp) {\n      printf(\"%d \", a[i]);\n    }\n  }\n  printf(\"\\n\");\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint gcd(int a,int b)\n{\n\tif (b==0) return a;\n\treturn gcd(b,a%b);\n}\nint a[2001];\nint main()\n{\n\tint i,j,k,l,m,n;\n\tcin>>n;\n\tfor (i=1;i<=n;i++)\n\t{\n\t\tcin>>a[i];\n\t}\n\tsort(a+1,a+1+n);\n\tk=1;\n\tfor (i=1;i<n;i++)\n\t{\n\t\tif (gcd(a[i],a[i+1])==1)\n\t\t{\n\t\t\tif (a[i]<a[i+1])\n\t\t\t{\n\t\t\t\tk=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (k==1)\n\t{\n\t\tfor (i=1;i<=n;i++) cout<<a[i]<<' ';\n\t\treturn 0;\n\t}\n\twhile (next_permutation(a+1,a+1+n))\n\t{\n\t\t\n\t\tk=1;\n\tfor (i=1;i<n;i++)\n\t{\n\t\tif (gcd(a[i],a[i+1])==1)\n\t\t{\n\t\t\tif (a[i]<a[i+1])\n\t\t\t{\n\t\t\t\tk=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (k==1)\n\t{\n\t\tfor (i=1;i<=n;i++) cout<<a[i]<<' ';\n\t\treturn 0;\n\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <vector>\n#include <string>\n#include <string.h>\n#include <cstdlib>\n#include <ctime>\n#include <cmath>\n#include <map>\n#include <set>\n#include <iostream>\n#include <sstream>\n#include <numeric>\n#include <cctype>\n#include <bitset>\n#include <cassert>\n#include <random>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define gep(i,g,j) for(int i = g.head[j]; i != -1; i = g.e[i].next)\n#define each(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)\n#define rng(a) a.begin(),a.end()\n#define maxs(x,y) x = max(x,y)\n#define mins(x,y) x = min(x,y)\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcount\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define df(x) int x = in()\n#define dame { puts(\"-1\"); return 0;}\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,vector<T>,greater<T> >\n#define bn(x) ((1<<x)-1)\n#define newline puts(\"\")\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ninline int in() { int x; scanf(\"%d\",&x); return x;}\ninline void priv(vi a) { rep(i,sz(a)) printf(\"%d%c\",a[i],i==sz(a)-1?'\\n':' ');}\ntemplate<typename T>istream& operator>>(istream&i,vector<T>&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(vector<T>&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>ostream& operator<<(ostream&o,vector<T>&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>ostream& operator<<(ostream&o,pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\nconst int MX = 100005, INF = 1001001001;\nconst ll LINF = 1e18;\nconst double eps = 1e-10;\n\n// coordinate compression\nstruct X {\n  typedef int T;\n  vector<T> d;\n  inline void add(T x) { d.pb(x);}\n  void init() {\n    sort(rng(d));\n    d.erase(unique(rng(d)), d.end());\n  }\n  inline int size() { return sz(d);}\n  inline int operator[](T x) { return upper_bound(rng(d),x)-d.begin()-1;}\n};\n//\n\n// Lowlink\n// bridge : v->u, ord[u]==low[u]\n// articulation : exist ord[v]<=low[u] (root:*2)\nstruct Lowlink {\n  int n, k;\n  vvi to, st, br, g, gr;\n  vi ord, low, art, gv;\n  Lowlink(int n=0):n(n),to(n),st(n),br(n),ord(n,-1),low(n),art(n){}\n  void add(int a, int b) {\n    to[a].pb(b); st[a].pb(0);\n    to[b].pb(a); st[b].pb(0);\n  }\n  void dfs(int v, int p=-1) {\n    ord[v] = low[v] = k++;\n    rep(i,sz(to[v])) {\n      int u = to[v][i];\n      if (u == p) continue;\n      if (ord[u] == -1) {\n        st[v][i] = 1;\n        dfs(u,v);\n        mins(low[v],low[u]);\n      } else {\n        st[v][i] = -1;\n        mins(low[v],ord[u]);\n      }\n    }\n  }\n  void init() {\n    k = 0;\n    dfs(0);\n    rep(i,n)rep(j,sz(to[i])) {\n      int v = i, u = to[i][j];\n      if (ord[v] > ord[u]) swap(v,u);\n      br[i].pb(ord[u] == low[u]);\n    }\n    rep(i,n) {\n      int cnt = 0;\n      rep(j,sz(to[i])) {\n        if (st[i][j] == 1 && ord[i] <= low[to[i][j]]) ++cnt;\n      }\n      art[i] = cnt > !i;\n    }\n    g = vvi(1);\n    gr = vvi(1);\n    gv = vi(n);\n    gfs(0,0);\n    k = sz(g);\n  }\n  void gfs(int v, int r) {\n    gr[r].pb(v);\n    gv[v] = r;\n    rep(i,sz(to[v])) {\n      if (st[v][i] != 1) continue;\n      if (br[v][i]) {\n        g[r].pb(sz(g));\n        g.pb(vi(1,r));\n        gr.pb(vi());\n        gfs(to[v][i],sz(g)-1);\n      } else gfs(to[v][i],r);\n    }\n  }\n};\n//\n\n\nint main() {\n  int n;\n  scanf(\"%d\",&n);\n  vi a(n);\n  rep(i,n) {\n    scanf(\"%d\",&a[i]);\n  }\n  X xs;\n  vvi a;\n  rep(i,n) {\n    int na = a[i];\n    for (int j = 2; j*j <= na; ++j) {\n      if (na%j) continue;\n      xs.add(j);\n      while (na%j == 0) {\n        na /= j;\n      }\n    }\n    if (na != 1) xs.add(na);\n  }\n  int m = sz(xs);\n  xs.init();\n  map<int,vi> mp;\n  rep(i,n) {\n    vi ps;\n    rep(j,m) {\n      if (a[i]%xs.d[j] == 0) ps.pb(j);\n    }\n    mp[a[i]] = ps;\n  }\n\n  vi ans;\n  while (sz(a)) {\n    n = sz(a);\n    sort(rng(a));\n    Lowlink g(n+m);\n    rep(i,n) {\n      vi ps = mp[a[i]];\n      for (int j : ps) g.add(i,n+j);\n    }\n    g.init();\n    \n  }\n  cout<<ans<<endl;\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=2005;\nvector<int> ad[N],ap[N];\npriority_queue<int> pq;\nint a[N],ans[N],vis[N],tail[N];\nint n,v,cnt;\nvoid dfs(int x){\n\tvis[x]=1;\n\tfor(int i=0;i<ad[x].size();i++){\n\t\tv=ad[x][i];\n\t\tif(vis[v])continue;\n\t\ttail[v]=1;ap[x].push_back(v);\n\t\tdfs(v);\n\t}\n}\nint main(){\n\tcin>n;\n\tfor(int i=1;i<=n;i++)cin>>a[i];\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++)for(int j=1;j<=n;j++)\n\tif(__gcd(a[i],a[j])>1&&i!=j)ad[i].push_back(j);\n\tfor(int i=1;i<=n;i++)if(vis[i]==0)dfs(i);\n\tfor(int i=1;i<=n;i++)if(tail[i]==0)pq.push(i);\n\twhile(pq.size()>0){\n\t\tv=pq.top();\n\t\tcnt++;ans[cnt]=a[v];\n\t\tpq.pop();\n\t\tfor(int i=0;i<ap[v].size();i++)\n\t\tpq.push(ap[v][i]);\n\t}\n\tfor(int i=1;i<=cnt;i++)cout<<ans[i]<<\" \";\n\tcout<<endl;\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <memory.h>\n\nusing namespace std;\nconst int maxn = 2005;\n\nbool e[maxn][maxn];\nint deg[maxn],n,a[maxn],usd[maxn];\nint gcd(int n,int m) {return m?gcd(m,n%m):n;}\n\nvoid dfs(int u)\n{\n\tusd[u]=1;\n\tfor (int j=1;j<=n;j++)\n\tif (e[u][j]) {\n\t\tif (!usd[j]) {\n\t\t\te[j][u]=false;deg[j]++;dfs(j);\n\t\t}\n\t\telse {\n\t\t\te[j][u]=e[u][j]=false;\n\t\t}\n\t}\n}\nint main()\n{\n\t#ifdef Amberframe\n\t\tfreopen(\"agc010e.in\",\"r\",stdin);\n\t\tfreopen(\"agc010e.out\",\"w\",stdout);\n\t#endif\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\t\n\tfor (int i=1;i<=n;i++)\n\tfor (int j=i+1;j<=n;j++)\n\t\tif (gcd(a[i],a[j])>1) e[i][j]=e[j][i]=true; \n\tfor (int i=1;i<=n;i++)\n\t\tif (!usd[i]) dfs(i);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tint pos=n;while (!usd[pos]||deg[pos]) --pos;\n\t\tprintf(\"%d \",a[pos]);usd[pos]=0;\n\t\tfor (int j=1;j<=n;j++)\n\t\t\tif (e[pos][j]) --deg[j];\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double lf;\ntypedef long double llf;\ntypedef std::pair<int,int> pii;\n\n#define xx first\n#define yy second\n\ntemplate<typename T> inline T max(T a,T b){return a>b?a:b;}\ntemplate<typename T> inline T min(T a,T b){return a<b?a:b;}\ntemplate<typename T> inline T abs(T a){return a>0?a:-a;}\ntemplate<typename T> inline bool repr(T &a,T b){return a<b?a=b,1:0;}\ntemplate<typename T> inline bool repl(T &a,T b){return a>b?a=b,1:0;}\ntemplate<typename T> inline T gcd(T a,T b){T t;if(a<b){while(a){t=a;a=b%a;b=t;}return b;}else{while(b){t=b;b=a%b;a=t;}return a;}}\ntemplate<typename T> inline T sqr(T x){return x*x;}\n#define mp(a,b) std::make_pair(a,b)\n#define pb push_back\n#define I inline\n#define mset(a,b) memset(a,b,sizeof(a))\n#define mcpy(a,b) memcpy(a,b,sizeof(a))\n\n#define fo0(i,n) for(int i=0,i##end=n;i<i##end;i++)\n#define fo1(i,n) for(int i=1,i##end=n;i<=i##end;i++)\n#define fo(i,a,b) for(int i=a,i##end=b;i<=i##end;i++)\n#define fd0(i,n) for(int i=(n)-1;~i;i--)\n#define fd1(i,n) for(int i=n;i;i--)\n#define fd(i,a,b) for(int i=a,i##end=b;i>=i##end;i--)\n#define foe(i,x)for(__typeof(x.end())i=x.begin();i!=x.end();++i)\n\nstruct Cg{I char operator()(){return getchar();}};\nstruct Cp{I void operator()(char x){putchar(x);}};\n#define OP operator\n#define RT return *this;\n#define RX x=0;char t=P();while((t<'0'||t>'9')&&t!='-')t=P();bool f=0;\\\nif(t=='-')t=P(),f=1;x=t-'0';for(t=P();t>='0'&&t<='9';t=P())x=x*10+t-'0'\n#define RL if(t=='.'){lf u=0.1;for(t=P();t>='0'&&t<='9';t=P(),u*=0.1)x+=u*(t-'0');}if(f)x=-x\n#define RU x=0;char t=P();while(t<'0'||t>'9')t=P();x=t-'0';for(t=P();t>='0'&&t<='9';t=P())x=x*10+t-'0'\n#define TR *this,x;return x;\nI bool IS(char x){return x==10||x==13||x==' ';}template<typename T>struct Fr{T P;I Fr&OP,(int&x)\n{RX;if(f)x=-x;RT}I OP int(){int x;TR}I Fr&OP,(ll &x){RX;if(f)x=-x;RT}I OP ll(){ll x;TR}I Fr&OP,(char&x)\n{for(x=P();IS(x);x=P());RT}I OP char(){char x;TR}I Fr&OP,(char*x){char t=P();for(;IS(t);t=P());if(~t){for(;!IS\n(t)&&~t;t=P())*x++=t;}*x++=0;RT}I Fr&OP,(lf&x){RX;RL;RT}I OP lf(){lf x;TR}I Fr&OP,(llf&x){RX;RL;RT}I OP llf()\n{llf x;TR}I Fr&OP,(uint&x){RU;RT}I OP uint(){uint x;TR}I Fr&OP,(ull&x){RU;RT}I OP ull(){ull x;TR}};Fr<Cg>in;\n#define WI(S) if(x){if(x<0)P('-'),x=-x;char s[S],c=0;while(x)s[c++]=x%10+'0',x/=10;while(c--)P(s[c]);}else P('0')\n#define WL if(y){lf t=0.5;for(int i=y;i--;)t*=0.1;if(x>=0)x+=t;else x-=t,P('-');*this,(ll)(abs(x));P('.');if(x<0)\\\nx=-x;while(y--){x*=10;x-=floor(x*0.1)*10;P(((int)x)%10+'0');}}else if(x>=0)*this,(ll)(x+0.5);else *this,(ll)(x-0.5);\n#define WU(S) if(x){char s[S],c=0;while(x)s[c++]=x%10+'0',x/=10;while(c--)P(s[c]);}else P('0')\ntemplate<typename T>struct Fw{T P;I Fw&OP,(int x){WI(10);RT}I Fw&OP()(int x){WI(10);RT}I Fw&OP,(uint x){WU(10);RT}\nI Fw&OP()(uint x){WU(10);RT}I Fw&OP,(ll x){WI(19);RT}I Fw&OP()(ll x){WI(19);RT}I Fw&OP,(ull x){WU(20);RT}I Fw&OP()\n(ull x){WU(20);RT}I Fw&OP,(char x){P(x);RT}I Fw&OP()(char x){P(x);RT}I Fw&OP,(const char*x){while(*x)P(*x++);RT}\nI Fw&OP()(const char*x){while(*x)P(*x++);RT}I Fw&OP()(lf x,int y){WL;RT}I Fw&OP()(llf x,int y){WL;RT}};Fw<Cp>out;\n\nconst int N=2005;\n\nint n,e,s[N],d[N],q[N];\nbool c[N][N],v[N];\n\ninline int u(int x)\n{\n\tv[x]=1;\n\tfo1(i,n)if(c[x][i])v[i]?c[x][i]=0:u(i);\n}\n\nint main()\n{\n\tin,n;\n\tfo1(i,n)in,s[i];\n\tstd::sort(s+1,s+n+1);\n\tfo1(i,n)fo1(j,n)c[i][j]=gcd(s[i],s[j])!=1;\n\tfo1(i,n)if(!v[i])u(i);\n\tfo1(i,n)fo1(j,n)d[j]+=c[i][j];\n\tfo1(i,n)if(!d[i])q[e++]=i;\n\tfo0(i,n)\n\t{\n\t\tint x=0;\n\t\tfo0(j,e)repr(x,s[q[j]]);\n\t\tfo0(j,e)if(s[q[j]]==x){x=q[j],q[j]=0;break;}\n\t\tout,s[x],' ';\n\t\tfo1(j,n)if(c[x][j]&&!--d[j])q[e++]=j;\n\t}\n\tout,'\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n,a[2010];\nvector<int> v[2010];\nbool vis[2010],used[2010];\nvector<int> dp[2010];\n\ninline void dfs2(int x)\n{\n\tvis[x]=1;\n\tfor(int i=0;i<v[x].size();i++) if(!used[v[x][i]]&&!vis[v[x][i]]){\n\t\tdfs2(v[x][i]);\n\t}\n}\n\ninline void dfs(int x)\n{\n\tused[x]=1;//memset(vis,0,sizeof(vis));\n\tfor(int i=0;i<v[x].size();i++) if(!used[v[x][i]]&&!vis[v[x][i]]){\n\t\tdfs2(v[x][i]);\n\t\tdp[x].push_back(v[x][i]);\n\t}\n\tfor(int i=0;i<dp[x].size();i++) dfs(dp[x][i]);\n}\n\ninline void dfs3(int x)\n{\n\tif(x>0) cout<<a[x]<<\" \";\n\tfor(int i=dp[x].size()-1;i>=0;i--) dfs3(dp[x][i]);\n}\n\nsigned main()\n{\n\t//freopen(\"agc010e.in\",\"r\",stdin);\n\tios::sync_with_stdio(false);\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++){\n\t\tv[0].push_back(i);v[i].push_back(0);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=i+1;j<=n;j++){\n\t\t\tif(__gcd(a[i],a[j])>1){\n\t\t\t\tv[i].push_back(j);\n\t\t\t\tv[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tdfs(0);\n\tdfs3(0);\n\tcout<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstring>\n#include<cstdlib>\n#include<cstdio>\n#include<cmath>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#define N 2100\n#define pb push_back\nusing namespace std;\nstruct node{int y,nex;}a[N*N];\nint fir[N],len,n,d[N],A[N],B[N],num;\nbool b[N];\nvector<int> v[N];\nvoid ins(int x,int y)\n{\n\ta[++len].y=y;a[len].nex=fir[x];fir[x]=len;\n}\nint gcd(int a,int b)\n{\n\tif(b==0) return a;\n\treturn gcd(b,a%b);\n}\nvoid merge(int x,int y)\n{\n\tint siz=v[x].size(),al=0,bl=0;\n\tfor(int i=0;i<siz;i++) A[++al]=v[x][i];\n\tsiz=v[y].size();\n\tfor(int i=0;i<siz;i++) B[++bl]=v[y][i];\n\tv[x].clear();\n\tint i=1,j=1;\n\twhile(i<=al || j<=bl)\n\t{\n\t\tif(j<=bl && (i>al || A[i]<B[j])) v[x].pb(B[j++]);\n\t\telse v[x].pb(A[i++]);\n\t}\n}\nvoid dfs(int x)\n{\n\tb[x]=1;\n\tfor(int k=fir[x];k;k=a[k].nex)\n\t{\n\t\tint y=a[k].y;\n\t\tif(b[y]) continue;\n\t\tdfs(y);\n\t\tmerge(x,y);\n\t}\n\tint siz=v[x].size();\n\tnum=0;\n\tA[0]=d[x];\n\tfor(int i=0;i<siz;i++) A[++num]=v[x][i];\n\tv[x].clear();\n\tfor(int i=0;i<=num;i++) v[x].pb(A[i]);\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&d[i]);\n\tsort(d+1,d+n+1);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=n;j>=1;j--)\n\t\t{\n\t\t\tif(i==j) continue;\n\t\t\tif(gcd(d[i],d[j])>1) ins(i,j);\n\t\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(b[i]) continue;\n\t\tdfs(i);\n\t\tmerge(0,i);\n\t}\n\tfor(int i=0;i<n;i++) printf(\"%d \",v[0][i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define X first\n#define Y second\n\nint gcd(int a,int b) {return b?gcd(b,a%b):a;}\n\nconst int maxn=4010;\n\nint n,times,a[maxn],dfn[maxn],deg[maxn];\nint tote,FIR[maxn],TO[maxn],NEXT[maxn];\nint vis[maxn];\npriority_queue<pair<int,int> > q;\n\nvoid addedge(int u,int v)\n{\n\tTO[++tote]=v;\n\tNEXT[tote]=FIR[u];\n\tFIR[u]=tote;\n}\n\nint search(int u)\n{\n\tint Ans=u;\n\tvis[u]=1;\n\tfor (int p=FIR[u];p;p=NEXT[p])\n\t{\n\t\tint v=TO[p];\n\t\tif (vis[v]) continue;\n\t\tint tmp=search(v);\n\t\tAns=a[Ans]<a[tmp]?Ans:tmp;\n\t}\n\treturn Ans;\n}\n\nvoid dfs(int u)\n{\n\tvis[u]=2;\n\tdfn[u]=++times;\n\tvector<pair<int,int> > son;\n\tson.clear();\n\tfor (int p=FIR[u];p;p=NEXT[p])\n\t\tson.push_back(make_pair(a[TO[p]],TO[p]));\n\tsort(son.begin(),son.end());\n\tfor (int i=0;i<(int)son.size();i++)\n\t\tif (vis[son[i].Y]!=2) dfs(son[i].Y);\n}\n\nint main()\n{\n#ifdef h10\n\tfreopen(\"E.in\",\"r\",stdin);\n\tfreopen(\"E.out\",\"w\",stdout);\n#endif\n\tint i,j;\n\tscanf(\"%d\",&n);\n\tfor (i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tfor (i=1;i<=n;i++)\n\tfor (j=i+1;j<=n;j++)\n\t\tif (gcd(a[i],a[j])!=1)\n\t\t\taddedge(i,j),addedge(j,i);\n\n\treturn 0;\n\tvector<pair<int,int> > root;\n\tfor (i=1;i<=n;i++)\n\t\tif (!vis[i])\n\t\t{\n\t\t\tint tmp=search(i);\n\t\t\troot.push_back(make_pair(a[tmp],tmp));\n\t\t}\n\n\tsort(root.begin(),root.end());\n\tfor (i=0;i<(int)root.size();i++) dfs(root[i].Y);\n\n\ttote=0;\n\tmemset(FIR,0,sizeof(FIR));\n\tfor (i=1;i<=n;i++)\n\tfor (j=1;j<=n;j++)\n\t\tif (gcd(a[i],a[j])!=1&&dfn[i]<dfn[j])\n\t\t\taddedge(i,j),deg[j]++;\n\n\tfor (i=1;i<=n;i++)\n\t\tif (!deg[i]) q.push(make_pair(a[i],i));\n\twhile (!q.empty())\n\t{\n\t\tpair<int,int> u=q.top(); q.pop();\n\t\tprintf(\"%d \",u.X);\n\t\tfor (int p=FIR[u.Y];p;p=NEXT[p])\n\t\t{\n\t\t\tint v=TO[p];\n\t\t\tif (!(--deg[v])) q.push(make_pair(a[v],v));\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\n#define mp make_pair\n#define ff first\n#define ss second\n#define pb push_back\n#define pf push_front\n#define popb pop_back\n#define popf pop_front\n#define all(v) v.begin(),v.end()\n\nconst int maxn = 2e3 + 100;\nconst ll inf = 2e18, mod = 1e9 + 7;\n\nint n, a[maxn], arr[maxn], d[maxn], ans[maxn], ansind;\nbool visited[maxn];\npair<int, int> srt[maxn];\nvector<int> graph[maxn], adj[maxn];\npriority_queue<pair<int, int> > pq;\n\nbool cmp(int A, int B)\n{\n\treturn (a[A] < a[B]);\n}\n\nvoid dfs(int u)\n{\n\tstatic int ind = 0;\n\tarr[ind++] = u;\n\tvisited[u] = true;\n\tfor (int i : graph[u])\n\t\tif (!visited[i])\n\t\t\tdfs(i);\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> n;\n\tfor (int i = 0; i < n; i++)\n\t\tcin >> a[i];\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = i + 1; j < n; j++)\n\t\t\tif (__gcd(a[i], a[j]) != 1)\n\t\t\t{\n\t\t\t\tgraph[i].pb(j);\n\t\t\t\tgraph[j].pb(i);\n\t\t\t}\n\tfor (int i = 0; i < n; i++)\n\t\tsort(all(graph[i]), cmp);\n\tfor (int i = 0; i < n; i++)\n\t\tsrt[i] = mp(a[i], i);\n\tsort(srt, srt + n);\n\tfor (int i = 0; i < n; i++)\n\t\tif (!visited[srt[i].ss])\n\t\t\tdfs(srt[i].ss);\n\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = i + 1; j < n; j++)\n\t\t\tif (__gcd(a[arr[i]], a[arr[j]]) != 1)\n\t\t\t\tadj[arr[i]].pb(arr[j]), d[arr[j]]++;\n\tfor (int i = 0; i < n; i++)\n\t\tif (!d[i])\n\t\t\tpq.push(mp(a[i], i));\n\twhile (!pq.empty())\n\t{\n\t\tpair<int, int> now = pq.top();\n\t\tans[ansind++] = now.ff;\n\t\tpq.pop();\n\n\t\tfor (int i : adj[now.ss])\n\t\t{\n\t\t\td[i]--;\n\t\t\tif (!d[i])\n\t\t\t\tpq.push(mp(a[i], i));\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++)\n\t\tcout << ans[i] << ' ';\n\tcout << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst long long inf = 1e18;\n\nstruct Task {\n\tint n;\n\tvector<int> a;\n\n\tTask(int n): n(n), a(n) {\n\t\tfor (auto& item : a) {\n\t\t\tcin >> item;\n\t\t}\n\t}\n\n\tbool edge(int x, int y) {\n\t\treturn x >= y || __gcd(x, y) > 1;\n\t}\n\n\tvector<int> go(vector<int> a) {\n\t\tif (a.size() == 1) {\n\t\t\treturn a;\n\t\t}\n\t\tvector<int> f, s;\n\t\tint x = a[0];\n\t\tfor (int i = 1; i < (int)a.size(); ++i) {\n\t\t\tif (edge(x, a[i])) {\n\t\t\t\tf.push_back(a[i]);\n\t\t\t} else {\n\t\t\t\ts.push_back(a[i]);\n\t\t\t}\n\t\t}\n\t\tvector<int> now;\n\t\tfor (auto& item : f) {\n\t\t\tnow.push_back(item);\n\t\t}\n\t\tfor (auto& item : s) {\n\t\t\tnow.push_back(item);\n\t\t}\n\t\tnow = go(now);\n\t\tvector<int> result;\n\t\tfor (int i = 0; i <= (int)now.size(); ++i) {\n\t\t\tbool before = (!i || edge(now[i - 1], x));\n\t\t\tbool after = (i == (int)now.size() || edge(x, now[i]));\n\t\t\tif (before && after) {\n\t\t\t\tfor (int j = 0; j < i; ++j) {\n\t\t\t\t\tresult.push_back(now[j]);\n\t\t\t\t}\n\t\t\t\tresult.push_back(x);\n\t\t\t\tfor (int j = i; j < (int)now.size(); ++j) {\n\t\t\t\t\tresult.push_back(now[j]);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\tvoid run() {\n\t\tsort(a.begin(), a.end());\n\t\tvector<int> result = go(a);\n\t\tfor (int i = 0; i < (int)result.size(); ++i) {\n\t\t\tint j = i - 1;\n\t\t\tint ps = i;\n\t\t\twhile (j >= 0 && __gcd(result[j], result[i]) == 1) {\n\t\t\t\tif (result[j] < result[i]) ps = j;\n\t\t\t\t--j;\n\t\t\t}\n\t\t\tj = i;\n\t\t\twhile (j != ps) {\n\t\t\t\t--j;\n\t\t\t\tswap(result[j], result[j + 1]);\n\t\t\t}\n\t\t}\n\t\tfor (auto& item : result) {\n\t\t\tcout << item << ' ';\n\t\t}\n\t\tcout << endl;\n\t}\n};\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint n;\n\tcin >> n;\n\n\tTask a(n);\n\ta.run();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nint n,v[2010][2010],mp[2010],a[2010],ru[2010];\npriority_queue<int>q;\nvector<int>zh[2010];\nvoid dfs(int x){\n\tint i;\n\tmp[x]=1;\n\tfor(i=1;i<=n;i++)if(!mp[i]&&v[x][i]){\n\t\tru[i]++;\n\t\tzh[x].push_back(i);\n\t\tdfs(i);\n\t}\n}\nvoid topsort(){\n\tint i,j,x;\n\tfor(i=1;i<=n;i++)if(!ru[i])q.push(i);\n\twhile(!q.empty()){\n\t\tx=q.top();\n\t\tq.pop();\n\t\tprintf(\"%d \",a[x]);\n\t\tfor(i=0;i<zh[x].size();i++)q.push(zh[x][i]);\n\t}\n}\nint gcd(int x,int y){\n\tif(!y)return x;\n\treturn gcd(y,x%y);\n}\nint main(){\n\tint i,j;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n\tsort(a+1,a+n+1);\n\tfor(i=1;i<=n;i++)\n\t for(j=i+1;j<=n;j++)if(gcd(a[i],a[j])!=1)v[i][j]=v[j][i]=1;\n\tfor(i=1;i<=n;i++)if(!mp[i])dfs(i);\n\ttopsort();\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n \n#define all(x)  x.begin(), x.end()\n#define mp      make_pair\n \nvector<int> g[2020];\nint used[2020];\nvector<int> a;\nvector<int> tmp;\n \nvoid dfs(int v, int prev) {\n        used[v] = true;\n        tmp.push_back(a[v]);\n        vector<pair<int, int>> p;\n        for (auto u : g[v]) if (u != prev) p.emplace_back(a[u], u);\n        sort(all(p));\n        for (auto u : p) {\n                if (!used[u.second]) {\n                        dfs(u.second, v);\n                }\n        }\n}\n \nint main() {\n        int n;\n        scanf(\"%d\", &n);\n        a.resize(n);\n        for (int i = 0; i < n; i ++) scanf(\"%d\", &a[i]);\n        sort(all(a));\n        for (int i = 0; i < n; i ++) {\n                for (int j = i + 1; j < n; j ++) {\n                        if (__gcd(a[i], a[j]) != 1) {\n                                g[i].push_back(j);\n                                g[j].push_back(i);\n                        }\n                }\n        }\n        for (int i = 0; i < n; i ++) {\n                if (!used[i]) {\n                        dfs(i, -1);\n                }\n        }\n        for (int i = 0; i < n; i ++) g[i].clear();\n        for (int i = 0; i < n; i ++) {\n                for (int j = i + 1; j < n; j ++) {\n                        if (__gcd(tmp[i], tmp[j]) != 1) {\n                                g[i].push_back(j);\n                        }\n                }\n        }\n        vector<int> in_cnt(n, 0);\n        for (int i = 0; i < n; i ++) {\n                for (auto u : g[i]) {\n                        in_cnt[u] ++;\n                }\n        }\n        priority_queue<pair<int, int>> pq;\n        for (int i = 0; i < n; i ++) if (in_cnt[i] == 0) pq.push(mp(tmp[i], i));\n        vector<int> ans;\n        while (!pq.empty()) {\n                auto get = pq.top();\n                pq.pop();\n                ans.push_back(get.first);\n                for (auto u : g[get.second]) {\n                        in_cnt[u] --;\n                        if (in_cnt[u] == 0) pq.push(mp(tmp[u], u));\n                }\n        }\n        for (int i = 0; i < n; i ++) cout << ans[i] << (i == n - 1 ? '\\n' : ' ');\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\",\"inline\",\"-ffast-math\")\n#pragma GCC target(\"avx,sse2,sse3,sse4,mmx\")\n#include <bits/stdc++.h>\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/hash_policy.hpp>\nusing namespace __gnu_pbds;\nusing namespace std;\n\nint n,a[2010];\nvector<int> v[2010];\nbool vis[2010],used[2010];\nvector<int> dp[2010];\n\ninline void dfs2(int x)\n{\n\tvis[x]=1;\n\tfor(int i=0;i<v[x].size();i++) if(!used[v[x][i]]&&!vis[v[x][i]]){\n\t\tdfs2(v[x][i]);\n\t}\n}\n\ninline void dfs(int x)\n{\n\tused[x]=1;memset(vis,0,sizeof(vis));\n\tfor(int i=0;i<v[x].size();i++) if(!used[v[x][i]]&&!vis[v[x][i]]){\n\t\tdfs2(v[x][i]);\n\t\tdp[x].push_back(v[x][i]);\n\t}\n\tfor(int i=0;i<dp[x].size();i++) dfs(dp[x][i]);\n} \n\ninline void dfs3(int x)\n{\n\tif(x>0) cout<<a[x]<<\" \";\n\tfor(int i=dp[x].size()-1;i>=0;i--) dfs3(dp[x][i]);\n}\n\nsigned main()\n{\n\tios::sync_with_stdio(false);\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++){\n\t\tv[0].push_back(i);v[i].push_back(0);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=i+1;j<=n;j++){\n\t\t\tif(__gcd(a[i],a[j])>1){\n\t\t\t\tv[i].push_back(j);\n\t\t\t\tv[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tdfs(0);\n\tdfs3(0);\n\tcout<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pb push_back\n#define all(x) x.begin(), x.end()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nconst int N = 2000 + 10;\nconst int MOD = 1000000007;\nconst int LOG = 20;\nconst int INF = 1000000010;\nconst int delta = 11353;\n\nint n;\nvi G[N], a;\nmap<int, int> mp;\nint mark[N];\nint mark2[N], mark3[N];\n\nvoid DFS(int v){\n\tmark[v] = 1;\n\tfor (auto u:G[v]){\n\t\tif ((mark[u] == 0) && (mark3[u] == 0)){\n\t\t\tDFS(u);\n\t\t}\n\t}\n}\nint GCD(int x, int y){\n\tif (x == 0 || y == 0) return (x + y);\n\tif (x == 1 || y == 1) return 1;\n\tif (x < y) swap(x, y);\n\treturn GCD(y, x % y);\n}\n\nint32_t main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++){\n\t\tint x;\n\t\tcin >> x;\n\t\tmp[x] ++;\n\t\ta.pb(x);\n\t}\n\tsort(all(a));\n\ta.resize(unique(all(a)) - a.begin());\n\tfor (int i = 0; i < a.size(); i++) for (int j = 0; j < i; j++) if (__gcd(a[i], a[j]) != 1){\n\t\tG[i].pb(j), G[j].pb(i);\n\t}\n\t//cout << GCD(7, 11) << '\\n';\n\tvi ans;\n\tint last = 0;\n\tn = a.size();\n\tfor (int i = 0; i < n; i++){\n\t\tif (!mark[i]) DFS(i), mark2[i] = 1;\n\t}\n\tfor (int i = 0; i < n; i++){\n\t\tmemset(mark, 0, sizeof mark);\n\t\tint mx = 0;\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tif (mark2[j]) mx = j;\n\t\t//\tcout << j << ' ' << mark2[j] << '\\n';\n\t\t}\n\t\tans.pb(a[mx]);\n\t\tsort(all(G[mx]));\n\t\tmark2[mx] = 0;\n\t\tmark3[mx] = 1;\n\t\t//cout << mx << '\\n';\n\t\tfor (auto u:G[mx]){\n\t\t\tif ((mark3[u] == 0) && (mark[u] == 0)){\n\t\t\t\tmark2[u] = 1;\n\t\t\t//\tcout << u << '\\n';\n\t\t\t\tDFS(u);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < ans.size(); i++){\n\t\tint u = ans[i];\n\t\tfor (int i = 0; i < mp[u]; i++) cout << u << ' ';\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <stack>\n#include <map>\n#include <set>\n#include <deque>\n#include <cstring>\n#include <functional>\n#include <climits>\n#include <list>\n#include <ctime>\n#include <complex>\n\n#define F1(x,y,z) for(int x=(y);x<(z);x++)\n#define F2(x,y,z) for(int x=(y);x<=(z);x++)\n#define F3(x,y,z) for(int x=(y);x>(z);x--)\n#define F4(x,y,z) for(int x=(y);x>=(z);x--)\n#define mp make_pair\n#define pb push_back\n#define LL long long\n#define co complex<double>\n#define fi first\n#define se second\n\n#define MAX 100005\n#define AMAX 1025*1005\n#define MOD 1000000007\n\n#define f(c,d) ((1<<(c))*(d))\n\nusing namespace std;\n\nint n,ta,x[2005],i,at[MAX];\nvector<int> np[2005],p,em;\nvector<vector<int> > ans;\nmap<int,int> m;\nmap<int,int>::iterator it;\nbool o,v[2005],vm[MAX];\npair<int,int> mi[MAX];\nvector<pair<int,int> > vn[MAX]; \npriority_queue<pair<int,int> > q;\npriority_queue<pair<int,int> > qq;\n\nvoid up(int a);\n\nvoid pp(int a){\n\tv[a]=1;\n\tq.push(mp(-x[a],a));\n}\n\nvoid up(int a){\n\twhile(at[a]!=vn[a].size()){\n\t\tif(!v[vn[a][at[a]].se]){\n\t\t\tpp(vn[a][at[a]].se);\n\t\t\tat[a]++;\n\t\t\tbreak;\n\t\t}else at[a]++;\n\t}\n}\n\nvoid upp(int a){\n\tif(at[a]!=ans[a].size()){\n\t\tqq.push(mp(ans[a][at[a]],a));\n\t\tat[a]++;\n\t}\n}\n\nint main(){\n\tF1(a,0,MAX)mi[a]=mp(INT_MAX,a);\n\tF2(a,2,10000){\n\t\to=1;\n\t\tF1(b,0,p.size()){\n\t\t\tif(p[b]*p[b]>a)break;\n\t\t\tif(a%p[b]==0){\n\t\t\t\to=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(o)p.pb(a);\n\t}\n\tscanf(\"%d\",&n);\n\tF1(a,0,n){\n\t\tscanf(\"%d\",x+a);\n\t\tta=x[a];\n\t\tF1(b,0,p.size()){\n\t\t\tif(p[b]*p[b]>ta)break;\n\t\t\tif(ta%p[b]==0){\n\t\t\t\ti=m.insert(mp(p[b],m.size())).fi->se;\n\t\t\t\tnp[a].pb(i);\n\t\t\t\tmi[i].fi=min(mi[i].fi,x[a]);\n\t\t\t\tvn[i].pb(mp(x[a],a));\n\t\t\t\twhile(ta%p[b]==0)ta/=p[b];\n\t\t\t}\n\t\t}\n\t\tif(ta!=1){\n\t\t\ti=m.insert(mp(ta,m.size())).fi->se;\n\t\t\tnp[a].pb(i);\n\t\t\tmi[i].fi=min(mi[i].fi,x[a]);\n\t\t\tvn[i].pb(mp(x[a],a));\n\t\t}\n\t}\n\tsort(mi,mi+m.size());\n\tF1(a,0,m.size()){\n\t\ti=mi[a].se;\n\t\tif(!vm[i]){\n\t\t\tvm[i]=1;\n\t\t\tans.pb(em);\n\t\t\tsort(vn[i].begin(),vn[i].end());\n\t\t\tup(i);\n\t\t\twhile(!q.empty()){\n\t\t\t\tans.back().pb(-q.top().fi);\n\t\t\t\tta=q.top().se;\n\t\t\t\tq.pop();\n\t\t\t\tF1(b,0,np[ta].size()){\n\t\t\t\t\tif(!vm[np[ta][b]])vm[np[ta][b]]=1;\n\t\t\t\t\tup(np[ta][b]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//F1(a,0,ans.size())F1(b,0,ans[a].size())printf(\"%d%c\",ans[a][b],b==ans[a].size()-1?'\\n':' ');\n\tF1(a,0,ans.size())at[a]=0;\n\tF1(a,0,ans.size())upp(a);\n\twhile(!qq.empty()){\n\t\tprintf(\"%d \",qq.top().fi);\n\t\tint ttt=qq.top().se;\n\t\tqq.pop();\n\t\tupp(ttt);\n\t}\n\tF1(a,0,n)if(x[a]==1)printf(\"1 \");\n\t#ifdef LOCAL_PROJECT\n\tsystem(\"pause\");\n\t#endif\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, s, t) for(int i = (s), mi = (t); i <= mi; i++)\n#define dwn(i, s, t) for(int i = (s), mi = (t); i >= mi; i--)\n\nint read() {\n\tint x = 0, f = 1; char c = getchar();\n\twhile(!isdigit(c)){ if(c == '-') f = -1; c = getchar(); }\n\twhile(isdigit(c)){ x = x * 10 + c - '0'; c = getchar(); }\n\treturn x * f;\n}\n\n#define maxn 2010\n\nint gcd(int a, int b) { return b ? gcd(b, a % b) : a; }\n\nint n, A[maxn], G[maxn][maxn];\n\nbool vis[maxn];\nvector <int> dfs(int u) {\n\tvis[u] = 1;\n\tvector <vector <int> > As; As.clear();\n\tvector <int> Ait; Ait.clear();\n\trep(v, 1, n) if(!vis[v] && G[v][u]) As.push_back(dfs(v)), Ait.push_back(0);\n\tvector <int> ans; ans.clear(); ans.push_back(u);\n\twhile(1) {\n\t\tint mx = 0, mxid = -1;\n\t\trep(i, 0, (int)Ait.size() - 1) if(Ait[i] < As[i].size()) {\n\t\t\tif(mx < As[i][Ait[i]]) mx = As[i][Ait[i]], mxid = i;\n\t\t}\n\t\t// printf(\"mx: %d %d\\n\", mx, mxid);\n\t\tif(mxid < 0) break;\n\t\tans.push_back(mx); Ait[mxid]++;\n\t}\n\treturn ans;\n}\n\nint main() {\n\tn = read();\n\trep(i, 1, n) A[i] = read();\n\t\n\tsort(A + 1, A + n + 1);\n\trep(i, 1, n) rep(j, i, n) if(gcd(A[i], A[j]) > 1) G[i][j] = G[j][i] = 1;\n\tvector <vector <int> > As; As.clear();\n\tvector <int> Ait; Ait.clear();\n\trep(i, 1, n) if(!vis[i]) As.push_back(dfs(i)), Ait.push_back(0);\n\tvector <int> ans; ans.clear();\n\twhile(1) {\n\t\tint mx = 0, mxid = -1;\n\t\trep(i, 0, (int)Ait.size() - 1) if(Ait[i] < As[i].size()) {\n\t\t\tif(mx < As[i][Ait[i]]) mx = As[i][Ait[i]], mxid = i;\n\t\t}\n\t\t// printf(\"mx: %d %d\\n\", mx, mxid);\n\t\tif(mxid < 0) break;\n\t\tans.push_back(mx); Ait[mxid]++;\n\t}\n\t\n\tassert(ans.size() == n);\n\trep(i, 0, n - 1) printf(\"%d%c\", A[ans[i]], i < mi ? ' ' : '\\n');\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<set>\n#include<bitset>\n#include<map>\n\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef double db;\n\nint get(){\n\tchar ch;\n\twhile(ch=getchar(),(ch<'0'||ch>'9')&&ch!='-');\n\tif (ch=='-'){\n\t\tint s=0;\n\t\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\t\treturn -s;\n\t}\n\tint s=ch-'0';\n\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\treturn s;\n}\n\nconst int N = 2005;\n\nint n;\nint a[N];\nstruct edge{\n\tint x,nxt;\n}e[N*N*2];\nint h[N],tot;\nint fa[N];\nint ans[N];\nint f[N][N];\nbool bz[N];\n\nint gcd(int x,int y){return y==0?x:gcd(y,x%y);}\n\nvoid inse(int x,int y){\n\te[++tot].x=y;\n\te[tot].nxt=h[x];\n\th[x]=tot;\n}\n\nvoid addedge(int x,int y){\n\tinse(x,y);\n\tinse(y,x);\n}\n\nint getfather(int x){return fa[x]==x?x:fa[x]=getfather(fa[x]);}\n\nbool cmp(int x,int y){\n\treturn a[x]<a[y];\n}\n\nint c[N];\n\nvoid merge(int *x,int *y){\n\tint ha=1,hb=1;\n\tfo(i,1,x[0]+y[0]){\n\t\tif (hb>y[0]||(ha<=x[0]&&a[x[ha]]>a[y[hb]]))c[i]=x[ha++];\n\t\telse c[i]=y[hb++];\n\t}\n\tc[0]=x[0]+y[0];\n\tfo(i,1,c[0])x[i]=c[i];\n\tx[0]=c[0];\n}\n\nvoid dfs(int x){\n\tbz[x]=1;\n\tint k=0,t[N];\n\tfor(int p=h[x];p;p=e[p].nxt)t[++k]=e[p].x;\n\tsort(t+1,t+1+k,cmp);\n\tf[x][0]=0;\n\tfo(i,1,k)\n\tif (!bz[t[i]]){\n\t\tdfs(t[i]);\n\t\tmerge(f[x],f[t[i]]);\n\t}\n\tfd(i,f[x][0]+1,2)f[x][i]=f[x][i-1];\n\tf[x][0]++;\n\tf[x][1]=x;\n}\n\nint main(){\n\tn=get();\n\tfo(i,1,n)fa[i]=i;\n\tfo(i,1,n)a[i]=get();\n\tfo(i,1,n)\n\t\tfo(j,i+1,n)\n\t\tif (gcd(a[i],a[j])!=1){\n\t\t\tint x=getfather(i),y=getfather(j);\n\t\t\tfa[x]=y;\n\t\t\taddedge(i,j);\n\t\t}\n\tans[0]=0;\n\tfo(i,1,n)\n\tif (getfather(i)==i){\n\t\tint w=0;\n\t\tfo(j,1,n)\n\t\tif (getfather(j)==i)\n\t\t\tif (!w||a[w]>a[j])w=j;\n\t\tdfs(w);\n\t\tmerge(ans,f[w]);\n\t}\n\tfo(i,1,n-1)printf(\"%d \",a[ans[i]]);\n\tprintf(\"%d\\n\",a[ans[n]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<queue>\n#define N 2010\nusing namespace std;\nint nxt[N<<2],to[N<<2],head[N],cnt;\nvoid add(int u,int v)\n{\n\tnxt[++cnt]=head[u];\n\tto[cnt]=v;\n\thead[u]=cnt;\n}\nint in[N];\nbool vis[N];\nint num[N],n;\nvoid dfs(int u)\n{\n\tvis[u]=true;\n\tfor(int i=1;i<=n;i++)\n\tif(!vis[i] && __gcd(num[u],num[i])!=1)\n\t{\n\t\tadd(u,i);\n\t\tin[i]++;\n\t\tdfs(i);\n\t}\n}\npriority_queue<int>q;\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&num[i]);\n\tsort(num+1,num+n+1);\n\tfor(int i=1;i<=n;i++)\n\tif(!vis[i])dfs(i);\n\tfor(int i=1;i<=n;i++)\n\tif(!in[i]) q.push(i);\n\twhile(!q.empty())\n\t{\n\t\tint u=q.top();\n\t\tprintf(\"%d \",num[u]);\n\t\tq.pop();\n\t\tfor(int i=head[u];i;i=nxt[i])\n\t\tq.push(to[i]);\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<queue>\nusing namespace std;\ntypedef long long s64;\n\nconst int ONE = 2005;\nconst int MOD = 1e9 + 7;\n\nint get()\n{\n\t\tint res = 1, Q = 1; char c;\n\t\twhile( (c = getchar()) < 48 || c > 57)\n\t\t\tif(c == '-') Q = -1;\n\t\tif(Q) res = c - 48;\n\t\twhile( (c = getchar()) >= 48 && c <= 57)\n\t\t\tres = res * 10 + c - 48;\n\t\treturn res * Q;\n}\n\nint gcd(int a, int b)\n{\n\t\twhile(int r = a % b) {a = b; b = r;}\n\t\treturn b;\n}\n\nint a[ONE];\npriority_queue <int> q;\n\nint n;\nint E[ONE][ONE];\n\nint vis[ONE], Input[ONE];\nint next[ONE], first[ONE], go[ONE], tot;\nvoid Add(int u, int v)\n{\n\t\tInput[v]++, next[++tot] = first[u], first[u] = tot, go[tot] = v;\n}\n\nvoid Dfs(int u)\n{\n\t\tif(vis[u]) return;\n\t\tvis[u] = 1;\n\t\tfor(int i = 1; i <= n; i++)\n\t\t\tif(E[u][i] && !vis[i])\n\t\t\t\tAdd(u, i), Dfs(i);\n}\n\nint main()\n{\n\t\t//freopen(\".in\",\"r\",stdin);\n\t\t//freopen(\".out\",\"w\",stdout);\n\t\tn = get();\n\t\tfor(int i = 1; i <= n; i++)\n\t\t\ta[i] = get();\n\t\tsort(a + 1, a + n + 1);\n\t\tfor(int i = 1; i <= n; i++)\n\t\t\tfor(int j = 1; j <= n; j++)\n\t\t\t\tif(i != j)\n\t\t\t\t\tif(gcd(a[i], a[j]) != 1) E[i][j] = 1;\n\n\t\tfor(int i = 1; i <= n; i++)\n\t\t\tDfs(i);\n\n\t\tfor(int i = 1; i <= n; i++)\n\t\t\tif(!Input[i]) q.push(i);\n\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tint u = q.top(); q.pop();\n\t\t\tprintf(\"%d \", a[u]);\n\t\t\tfor(int e = first[u]; e; e = next[e])\n\t\t\t{\n\t\t\t\tint v = go[e];\n\t\t\t\tif(--Input[v] == 0) q.push(v);\n\t\t\t}\n\t\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#pragma comment(linker, \"/STACK:128777216\")\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cctype>\n#include <cstring>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <ctime>\n#include<complex>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for (int i = (b)-1; i >= (a); i--)\n#define ITER(it,a) for (__typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a,value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int)a.size()\n#define ALL(a) a.begin(), a.end()\n#define PB push_back\n#define MP make_pair\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\ntypedef pair<long long, long long> PLL;\n\n\nconst double PI = acos(-1.0);\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst LL LINF = INF * (LL)INF;\n\nconst int MAX = 2000 + 47;\nconst int MOD = 1000 * 1000 * 1000 + 7;\n\n//#define DEBUG\nint A[MAX];\nint B[MAX];\nint C[MAX];\nint IND[MAX];\n\nvector<int> g[MAX];\nint U[MAX];\nvector<int> L[MAX];\nvector<int> P;\nint sz;\n\nint gcd(int a, int b)\n{\n\treturn b == 0 ? a : gcd(b, a % b);\n}\n\nint merge(int v, vector<int> A)\n{\n\tif (v != -1)\n\t{\n\t\tL[sz].push_back(v);\n\t}\n\n\tP.assign(SZ(A), 0);\n\twhile (1)\n\t{\n\t\tint ind = -1;\n\t\tFOR(i, 0, SZ(A))\n\t\t{\n\t\t\tif (P[i] < SZ(L[A[i]]))\n\t\t\t{\n\t\t\t\tind = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (ind == -1) break;\n\t\tFOR(i, 0, SZ(A))\n\t\t{\n\t\t\tif (P[i] < SZ(L[A[i]]) && L[A[i]][P[i]] > L[A[ind]][P[ind]])\n\t\t\t{\n\t\t\t\tind = i;\n\t\t\t}\n\t\t}\n\n\t\tL[sz].push_back(L[A[ind]][P[ind]]);\n\t\tP[ind]++;\n\t}\n\n\tsz++;\n\treturn sz - 1;\n}\n\nint dfs(int v)\n{\n\tU[v] = 1;\n\tvector<int> A;\n\tFOR(i, 0, SZ(g[v]))\n\t{\n\t\tint to = g[v][i];\n\t\tif (U[to]) continue;\n\t\tA.push_back(dfs(to));\n\t}\n\n\treturn merge(v, A);\n}\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t//freopen(\"out.txt\", \"w\", stdout);\n\t//ios::sync_with_stdio(false); cin.tie(0);\n\tint n;\n\tcin >> n;\n\tFOR(i, 0, n)\n\t{\n\t\tcin >> A[i];\n\t\tB[i] = A[i];\n\t}\n\n\tsort(B, B + n);\n\tint sz = unique(B, B + n) - B;\n\tFOR(i, 0, n)\n\t{\n\t\tint ind = lower_bound(B, B + sz, A[i]) - B;\n\t\tIND[i] = ind;\n\t\tC[ind]++;\n\t}\n\n\tFOR(i, 0, n)\n\t{\n\t\tFOR(j, 0, n)\n\t\t{\n\t\t\tif (i == j) continue;\n\t\t\tif (gcd(A[i], A[j]) == 1) continue;\n\t\t\tg[IND[i]].push_back(IND[j]);\n\t\t}\n\t}\n\n\tFOR(i, 0, n)\n\t{\n\t\tsort(ALL(g[i]));\n\t}\n\n#ifdef DEBUG\n\tcout << \"B=\" << endl;\n\tFOR(i, 0, sz)\n\t{\n\t\tcout << B[i] << \" \";\n\t}\n\tcout << endl;\n\tcout << \"g=\" << endl;\n\tFOR(i, 0, sz)\n\t{\n\t\tcout << i << \": \";\n\t\tFOR(j, 0, SZ(g[i])) cout << g[i][j] << \" \";\n\t\tcout << endl;\n\t}\n#endif\n\tvector<int> D;\n\tFOR(i, 0, sz)\n\t{\n\t\tif (!U[i])\n\t\t{\n\t\t\tD.push_back(dfs(i));\n\t\t}\n\t}\n\n\tint p = merge(-1, D);\n\tFOR(i, 0, SZ(L[p]))\n\t{\n\t\tint ind = L[p][i];\n\t\tFOR(j, 0, C[ind])\n\t\t{\n\t\t\tcout << B[ind] << \" \";\n\t\t}\n\t}\n\n\tcout << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <queue>\n#define maxn 2005\nusing namespace std;\ntypedef long long ll;\nconst int inf = 0x3f3f3f3f;\nint n,a[maxn];\nvector <int> adj[maxn];\nbool vis_compo[maxn],vis[maxn];\nint mini,minu;\nvector <int> chi[maxn];\nint gcd(int a,int b){\n\tif(a % b == 0) return b;\n\treturn gcd(b,a % b);\n}\nvoid dfs_compo(int u){\n\tif(a[u] < mini){\n\t\tmini = a[u];\n\t\tminu = u;\n\t}\n\tvis_compo[u] = true;\n\tfor(int i=0;i<(int)adj[u].size();i++){\n\t\tint v = adj[u][i];\n\t\tif(!vis_compo[v]) dfs_compo(v);\n\t}\n}\nvoid dfs(int u){\n\tvis[u] = true;\n\tfor(int i=0;i<(int)adj[u].size();i++){\n\t\tint v = adj[u][i];\n\t\tif(!vis[v]){\n\t\t\tchi[u].push_back(v);\n\t\t\tdfs(v);\n\t\t}\n\t}\n}\nbool cmp(const int &x,const int &y){\n\treturn a[x] < a[y];\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=i + 1;j<=n;j++){\n\t\t\tif(gcd(a[i],a[j]) != 1){\n\t\t\t\tadj[i].push_back(j);\n\t\t\t\tadj[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++) sort(adj[i].begin(),adj[i].end(),cmp);\n\tpriority_queue <int> que;\n\tfor(int i=1;i<=n;i++){\n\t\tif(!vis[i]){\n\t\t\tmini = inf,minu = -1;\n\t\t\tdfs_compo(i);\n\t\t\tdfs(minu);\n\t\t\tque.push(minu);\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tint u = que.top();que.pop();\n\t\tprintf(\"%d%c\",a[u],i == n ? '\\n' : ' ');\n\t\tfor(int j=0;j<(int)chi[u].size();j++){\n\t\t\tque.push(chi[u][j]);\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#define ALL(v) v.begin(), v.end()\nusing namespace std;\ntypedef long long LL;\ntypedef vector <int> vec;\nconst int N = 2000 + 5;\nint a[N], dsu[N];\nint n;\nint vis[N];\nvec G[N], idx[N], ans;\nint find(int x){\n\treturn x == dsu[x] ? x : dsu[x] = find(dsu[x]);\n}\nvoid unite(int x, int y){\n\tif(find(x) < find(y)){\n\t\tdsu[find(y)] = find(x);\n\t}else if(find(x) > find(y)){\n\t\tdsu[find(x)] = find(y);\n\t}\n}\nvec mer(vec a, vec b){\n\tvec ret;\n\tfor(int i = 0, j = 0; i < a.size() || j < b.size(); ){\n\t\tif(i < a.size() && j < b.size()){\n\t\t\tif(a[i] >= b[j]) ret.push_back(a[i ++]);\n\t\t\telse ret.push_back(b[j ++]);\n\t\t}else if(i < a.size()){\n\t\t\tret.push_back(a[i ++]);\n\t\t}else{\n\t\t\tret.push_back(b[j ++]);\n\t\t}\n\t}\n\treturn ret;\n}\nvec dfs(int o){\n\tvec ret;\n\t//printf(\"o = %d\\n\", o);\n\tvis[o] = 1;\n\tfor(int i = 0; i < G[o].size(); i ++){\n\t\tif(vis[G[o][i]] == 1) continue;\n\t\tret = mer(ret, dfs(G[o][i]));\n\t}\n\tret.insert(ret.begin(), a[o]);\n\treturn ret;\n}\nint main(){\n\tint u, v;\n\tscanf(\"%d\", &n);\n\tfor(int i = 1; i <= n; i ++) scanf(\"%d\", &a[i]), dsu[i] = i;\n\tfor(int i = 1; i <= n; i ++){\n\t\tfor(int j = i+1; j <= n; j ++){\n\t\t\tif(__gcd(a[i], a[j]) != 1){\n\t\t\t\tG[i].push_back(j);\n\t\t\t\tG[j].push_back(i);\n\t\t\t\tunite(i, j);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = n; i >= 1; i --){\n\t\tif(dsu[i] == i) ans = mer(ans, dfs(i));\n\t}\n\tfor(int i = 0; i < ans.size(); i ++){\n\t\tprintf(\"%d \", ans[i]);\n\t}puts(\"\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define sz(s) ((int) ((s).size()))\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\ntypedef long long ll;\ntypedef long double ld;\n\nconst int inf = (int) 1.01e9;\nconst ld eps = 1e-11;\nconst ld pi = acos(-1.0L);\n\nmt19937 mrand(random_device{} ());\nint rnd(int x) {\n  return mrand() % x;\n}\n\nconst int mod = (int) 1e9 + 7;\n\nvoid add(int & x, int y) {\n  if ((x += y) >= mod) {\n    x -= mod;\n  }\n}\n\nint sum(int x, int y) {\n  add(x, y);\n  return x;\n}\n\nint mult(int x, int y) {\n  return (ll) x * y % mod;\n}\n\nint power(int x, ll p) {\n  int res = 1;\n  while (p) {\n    if (p & 1) {\n      res = mult(res, x);\n    }\n    x = mult(x, x);\n    p >>= 1;\n  }\n  return res;\n}\n\nvoid precalc() {\n}\n\nconst int maxn = 2e3 + 100;\n\nint n;\nint a[maxn];\n\nbool read() {\n  if (scanf(\"%d\", &n) < 1) {\n    return false;\n  }\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", a + i);\n  }\n  return true;\n}\n\nint par[maxn], ranks[maxn];\nint waiting[maxn];\nint alive[maxn];\nint mns[maxn];\nint maxu;\n\nint getpar(int a) {\n  if (par[a] == a) {\n    return a;\n  } else {\n    return par[a] = getpar(par[a]);\n  }\n}\n\nvoid myUnion(int a, int b) {\n  a = getpar(a);\n  b = getpar(b);\n  if (a == b) {\n    return;\n  }\n  if (ranks[a] == ranks[b]) {\n    ++ranks[a];\n  }\n  if (ranks[a] < ranks[b]) {\n    swap(a, b);\n  }\n  par[b] = a;\n}\n\nint g[maxn][maxn];\n\nvoid solve() {\n  sort(a, a + n);\n  map<int, vector<int> > comps;\n  for (int i = 0; i < n; i++) {\n    int cur = a[i];\n    for (int j = 2; j * j <= cur; j++) {\n      if (cur % j == 0) {\n        comps[j].pb(i);\n        while (cur % j == 0) {\n          cur /= j;\n        }\n      }\n    }\n    if (cur > 1) {\n      comps[cur].pb(i);\n    }\n  }\n  for (auto & v : comps) {\n    for (auto i : v.second) {\n      for (auto j : v.second) {\n        g[i][j] = 1;\n      }\n    }\n  }\n  for (int i = 0; i < n; i++) {\n    alive[i] = 1;\n    waiting[i] = 0;\n  }\n  vector<int> ans;\n  for (int it = 0; it < n; it++) {\n    for (int i = 0; i < n; i++) {\n      par[i] = i;\n      ranks[i] = 0;\n    }\n    for (auto & v : comps) {\n      int was = -1;\n      for (auto i : v.second) {\n        if (!alive[i]) {\n          continue;\n        }\n        if (was != -1) {\n          myUnion(was, i);\n        }\n        was = i;\n      }\n    }\n    for (int i = 0; i < n; i++) {\n      mns[i] = 1e9;\n    }\n    for (int i = 0; i < n; i++) {\n      if (alive[i] && !waiting[i]) {\n        int p = getpar(i);\n        mns[p] = min(mns[p], i);\n      }\n    }\n    int cur = 0;\n    for (int i = 0; i < n; i++) {\n      if (alive[i]) {\n        cur = max(cur, mns[getpar(i)]);\n      }\n    }\n    ans.pb(cur);\n    alive[cur] = 0;\n    for (int i = 0; i < n; i++) {\n      if (alive[i]) {\n        if (g[cur][i]) {\n          waiting[i] = 0;\n        } else if (a[i] > a[cur]) {\n          waiting[i] = 1;\n        }\n      }\n    }\n  }\n  assert(sz(ans) == n);\n  for (int i = 0; i < n; i++) {\n    printf(\"%d%c\", a[ans[i]], \" \\n\"[i == n - 1]);\n  }\n}\n\nint main() {\n  precalc();\n#ifdef DEBUG\n  assert(freopen(\"text.in\", \"r\", stdin));\n  assert(freopen(\"text.out\", \"w\", stdout));\n#endif\n\n  while (read()) {\n    solve();\n#ifdef DEBUG\n    eprintf(\"Time: %.3f\\n\", (double) clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<stack>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<cmath>\nusing namespace std;\nint gcd(int x,int y){return (y==0)?x:gcd(y,x%y);}\nint n;\nint a[1001];\nint in[1001];\nint vis[1001];\nint ed[1001][1001];\nvector<int> e[1001];\npriority_queue<int,vector<int>,less<int> > q;\nvoid dfs(int x)\n{\n\tvis[x]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tif(!vis[i]&&ed[x][i])\n\t\t{\n\t\t\tin[i]++;\n\t\t\te[x].push_back(i);\n\t\t\tdfs(i);\n\t\t}\n}\nsigned main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\tif(gcd(a[i],a[j])!=1)\n\t\t\t\ted[i][j]=1,ed[j][i]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tif(!vis[i])\n\t\t\tdfs(i);\n\tfor(int i=1;i<=n;i++)\n\t\tif(in[i]==0)\n\t\t\tq.push(i);\n\twhile(!q.empty())\n\t{\n\t\tint u=q.top();\n\t\tq.pop();\n\t\tprintf(\"%d \",a[u]);\n\t\tfor(int i=0;i<e[u].size();i++)\n\t\t{\n\t\t\tint to=e[u][i];\n\t\t\tin[to]--;\n\t\t\tif(in[to]==0)\n\t\t\t\tq.push(to);\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h> \nusing namespace std;\nint n,a[2005];\nbool used[2005],ok;\nvector<int> v[2005],tmp;\nvector<vector<int> > ans;\ninline int gcd(int x,int y){return !x?y:gcd(y%x,x);}\nvoid dfs(int from)\n{\n\tused[from]=1;tmp.push_back(a[from]);\n\tfor(int i=0;i<v[from].size();i++)\n\t{\n\t\tint to=v[from][i];\n\t\tif(used[to])continue;\n\t\tdfs(to);\n\t\tif(ok)return;\n\t}\n\tans.push_back(tmp);tmp.clear();ok=1;\n}\nbool cmp(const vector<int> &x,const vector<int> &y){return !(x<y);}\nint main()\n{\n\tios::sync_with_stdio(0);\n\tcin>>n;\n\t/*for(int i=0;i<n;i++)\n\t{\n\tcin>>a[i];\n\tfor(int j=i-1;i>=0;j--)\n\tif(gcd(a[i],a[j])==1)v[i].push_back(j),v[j].push_back(i);\n\t}\n\tdfs(0);*/\n\tfor(int i=0;i<n;i++)cin>>a[i];\n\tsort(a,a+n);\n\tfor(int i=0;i<n;i++)\n\tfor(int j=i-1;j>=0;j--)\n\tif(gcd(a[j],a[i])!=1)\n\tv[i].push_back(j),v[j].push_back(i);\n\tfor(int i=0;i<n;i++)if(!used[i])dfs(i),ok=0;\n\tsort(ans.begin(),ans.end(),cmp);\n\tfor(int i=0;i<ans.size();i++)\n\tfor(int j=0;j<ans[i].size();j++)\n\tcout<<ans[i][j]<<' ';//cout<<(j==ans[i].size()-1?'\\n':' ');\n\tcout<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #include {{{\n#include <iostream>\n#include <cassert>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <set>\n#include <map>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <complex>\n#include <algorithm>\nusing namespace std;\n// }}}\n// #define {{{\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n#define de(x) cout << #x << \"=\" << x << endl\n#define rep(i,a,b) for(int i=a;i<(b);++i)\n#define per(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n// }}}\n\nconst int N = 2020;\nint n , a[N] , vis[N];\nvi g[N];\n\nvi merge(vi a,vi b) {\n  vi r(sz(a)+sz(b),0);\n  for(int i=0,j=0,x=0;i<sz(a)||j<sz(b);)\n    r[x++]=(j==sz(b)||(i!=sz(a)&&a[i]>b[j]))?a[i++]:b[j++];\n  return r;\n}\n\nvi dfs(int c) {\n  vis[c]=true;\n  sort(all(g[c]),[&](int x,int y){return a[x]<a[y];});\n  vi res;\n  for(auto t : g[c]) if(!vis[t]) {\n    res = merge(res , dfs(t));\n  }\n  res.insert(res.begin(),a[c]);\n  return res;\n}\n\nint main(){\n  cin >> n;\n  rep(i,1,n+1) cin >> a[i];\n  rep(i,1,n+1) g[0].pb(i);\n  rep(i,1,n+1) rep(j,i+1,n+1) if(__gcd(a[i],a[j])!=1)\n    g[i].pb(j),g[j].pb(i);\n  vi v = dfs(0);\n  rep(i,1,n+1) cout << v[i] << \" \\n\"[i==n];\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cstdlib>\n#include <queue>\nusing namespace std;\n#define N 2050\npriority_queue<int>q;\nint n,a[N],G[N][N],gg[N][N],vis[N],du[N];\nint gcd(int x,int y) {return y?gcd(y,x%y):x;}\nvoid dfs(int x) {\n\tvis[x]=1;\n\tint i;\n\tfor(i=1;i<=n;i++) if(!vis[i]&&gg[x][i]>1) {\n\t\tdfs(i); G[x][i]=1; du[i]++;\n\t}\n}\nint main() {\n\tscanf(\"%d\",&n);\n\tint i,j;\n\tfor(i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tsort(a+1,a+n+1);\n\tfor(i=1;i<=n;i++) {\n\t\tfor(j=1;j<=n;j++) {\n\t\t\tgg[i][j]=gcd(a[i],a[j]);\n\t\t}\n\t}\n\tfor(i=1;i<=n;i++) if(!vis[i]) dfs(i);\n\tfor(i=1;i<=n;i++) if(!du[i]) q.push(i);\n\twhile(!q.empty()) {\n\t\tint x=q.top(); q.pop();\n\t\tprintf(\"%d \",a[x]);\n\t\tfor(i=1;i<=n;i++) if(G[x][i]) {\n\t\t\tdu[i]--;\n\t\t\tif(!du[i]) q.push(i);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define RI register int\n\nusing namespace std;\n\nchar buf[1000000], *p1 = buf, *p2 = buf;\ninline char gc() {\n  if (p1 == p2) p2 = (p1 = buf) + fread(buf, 1, 1000000, stdin);\n  return p1 == p2 ? EOF : *(p1++);\n}\ntemplate <class T> inline void read(T &n) {\n  n = 0; RI ch = gc();\n  while (ch < '0' || ch > '9') ch = gc();\n  while (ch >= '0' && ch <= '9') n = n * 10 + (ch ^ 48), ch = gc();\n}\n\nint const MAXN = 2005;\nint vis[MAXN], a[MAXN], In[MAXN], Dfn[MAXN], cnt;\nvector <int> G[MAXN];\npriority_queue <int> q;\n\ninline int gcd(int x, int y) {\n  int t;\n  while (y) t = x % y, x = y, y = t;\n  return x;\n}\n\nvoid Dfs(int now) {\n  Dfn[now] = ++cnt;\n  vis[now] = 1;\n  vector <int> :: iterator it = G[now].begin(), en = G[now].end();\n  for (; it != en; ++it) {\n    if (Dfn[now] < Dfn[*it]) ++In[*it];\n    if (!vis[*it]) ++In[*it], Dfs(*it);\n  }\n}\n\nint main() {\n // freopen(\"rearranging.in\", \"r\", stdin);\n // freopen(\"rearranging.out\", \"w\", stdout);\n  int n; read(n);\n  for (RI i = 1; i <= n; ++i) read(a[i]);\n  sort(a + 1, a + 1 + n);\n  for (RI i = 1; i <= n; ++i)\n    for (RI j = i + 1; j <= n; ++j)\n      if (gcd(a[i], a[j]) != 1)\n        G[i].push_back(j), G[j].push_back(i);\n  for (RI i = 1; i <= n; ++i)\n    sort(G[i].begin(), G[i].end());\n  for (RI i = 1; i <= n; ++i)\n    if (!vis[i]) Dfs(i);\n  for (RI i = 1; i <= n; ++i) if (!In[i]) q.push(i);\n  while (!q.empty()) {\n    int t = q.top(); q.pop();\n    printf(\"%d \", a[t]);\n    vector <int> :: iterator it = G[t].begin(), en = G[t].end();\n    for (; it != en; ++it)\n      if (Dfn[t] < Dfn[*it]) {\n        --In[*it];\n        if (!In[*it]) q.push(*it);\n      }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\nconst int N = 2005;\nint n, a[N];\nbool g[N][N], vis[N];\nvector <int> merge(vector <vector <int> > a) {\n\tvector <int> ans;\n\tpriority_queue <vector <int> > pq;\n\tfor (int i = 0; i < a.size(); ++ i)\n\t\tpq.push(a[i]);\n\twhile (!pq.empty()) {\n\t\tvector <int> tmp = pq.top(); pq.pop();\n\t\tans.push_back(tmp[0]);\n\t\ttmp.erase(tmp.begin());\n\t\tif (tmp.size()) pq.push(tmp);\n\t}\n\treturn ans;\n}\nvector <int> dfs(int u) {\n\tvis[u] = 1;\n\tvector <vector <int> > tmp;\n\tfor (int i = 0; i < n; ++ i) if (g[u][i] && !vis[i]) tmp.push_back(dfs(i));\n\tvector <int> ans = merge(tmp);\n\tans.insert(ans.begin(), a[u]);\n\treturn ans;\n}\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; ++ i) scanf(\"%d\", &a[i]);\n\tsort(a, a + n);\n\tfor (int i = 0; i < n; ++ i) for (int j = i + 1; j < n; ++ j) if (__gcd(a[i], a[j]) != 1) g[i][j] = g[j][i] = 1;\n\tvector <vector <int> > tmp;\n\tfor (int i = 0; i < n; ++ i) if (!vis[i]) tmp.push_back(dfs(i));\n\tvector <int> ans = merge(tmp);\n\tfor (int i = 0; i < ans.size(); ++ i) printf(\"%d%c\", ans[i], \" \\n\"[i + 1 == ans.size()]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nconst int maxn = 2030, oo = 123456789, maxm = 34010;\n \nint n, m, T, ans, mn, a[maxn], foo[maxn], lst[maxm], tag[maxn], q[maxn], rar, mx[maxn];\nbool vis[maxn], f[maxn], G[maxn][maxn], F[maxn];\nstd::vector<int> g[maxn], has[maxn], rhas[maxm], all;\nstd::vector<std::pair<int, int> > v;\n \nvoid GEN() {\n\tint mx = 0;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif(!foo[i]) {\n\t\t\tif(a[i] == 1) {\n\t\t\t\tF[i] = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tF[i] = 0;\n\t\t\t\tfor (int j: has[i]) {\n\t\t\t\t\tif(lst[j] >= mx) {\n\t\t\t\t\t\tF[i] = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t(foo[i] > mx) && (mx = foo[i]);\n\t\t}\n\t}\n\treturn;\n}\n /*\ninline void dfs(int &u) {\n\ttag[u] = T;\n\t(F[u] && a[u] < mn) && (mn = a[u]);\n\tvis[u] = 1;\n\tfor (int &v: g[u]) {\n\t\tif(!vis[v] && !f[v]) {\n\t\t\tdfs(v);\n\t\t}\n\t}\n\treturn;\n}\n */\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tscanf(\"%d\", a + i);\n\t\tint t = a[i];\n\t\tfor (int x = 2; x * x <= t; ++x) {\n\t\t\tif(t % x == 0) {\n\t\t\t\tall.push_back(x);\n\t\t\t\twhile(t % x == 0) {\n\t\t\t\t\tt /= x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(t > 1) {\n\t\t\tall.push_back(t);\n\t\t}\n\t}\n\tstd::sort(a + 1, a + n + 1);\n\tstd::sort(all.begin(), all.end());\n\tall.resize(std::unique(all.begin(), all.end()) - all.begin());\n\tm = (int)(all.size());\n\tfor (int i = 1; i <= n; ++i) {\n\t\tF[i] = 1;\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tif(a[i] % all[j] == 0) {\n\t\t\t\thas[i].push_back(j);\n\t\t\t\trhas[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int j = 0; j < m; ++j) {\n\t\tfor (int i = 0; i < (int)(rhas[j].size()); ++i) {\n\t\t\tfor (int k = 0; k < i; ++k) {\n\t\t\t\tint u = rhas[j][i], v = rhas[j][k];\n\t\t\t\tif(!G[u][v]) {\n\t\t\t\t\tg[u].push_back(v);\n\t\t\t\t\tg[v].push_back(u);\n\t\t\t\t\tG[u][v] = G[v][u] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n//\t\tGEN();\n\t\tmemset(vis + 1, 0, sizeof(vis[0]) * n);\n\t\tv.clear();\n\t\tfor (int u = 1; u <= n; ++u) {\n\t\t\tif(F[u]) {\n\t\t\t\tif(!vis[u] && !f[u]) {\n\t\t\t\t\t++T;\n\t\t\t\t\tmn = oo;\n//\t\t\t\t\tdfs(u);\n\t\t\t\t\trar = 0;\n\t\t\t\t\tq[rar++] = u;\n\t\t\t\t\tvis[u] = 1;\n\t\t\t\t\tfor (register int fnt = 0; fnt < rar; ++fnt) {\n\t\t\t\t\t\tint u = q[fnt];\n\t\t\t\t\t\ttag[u] = T;\n\t\t\t\t\t\t(F[u] && a[u] < mn) && (mn = a[u]);\n\t\t\t\t\t\tfor (int &v: g[u]) {\n\t\t\t\t\t\t\tif(!vis[v] && !f[v]) {\n\t\t\t\t\t\t\t\tq[rar++] = v;\n\t\t\t\t\t\t\t\tvis[v] = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tv.push_back(std::make_pair(mn, T));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstd::sort(v.begin(), v.end());\n\t\tint sz = (int)(v.size());\n\t\t//ans = 0;\n\t\tfor (int u = 1; u <= n; ++u) {\n\t\t\tif(F[u] && !f[u]) {\n\t\t\t\tint i = sz - 1;\n\t\t\t\tif(v[i].second == tag[u]) {\n\t\t\t\t\t--i;\n\t\t\t\t}\n\t\t\t\tif(i < 0 || v[i].first <= a[u]) {\n\t\t\t\t\tans = u;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tf[ans] = 1;\n\t\tfoo[ans] = i;\n\t\tprintf(\"%d \", a[ans]);\n\t\tfor (int j: has[ans]) {\n\t\t\tlst[j] = i;\n\t\t}\n\t\tfor (register int j = ans + 1; j <= n; ++j) {\n\t\t\tmx[j] = i;\n\t\t\tF[j] = G[ans][j];\n\t\t}\n\t\tfor (int j: has[ans]) {\n\t\t\tfor (register int &k: rhas[j]) {\n\t\t\t\tif(k > ans) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tF[k] = 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<queue>\n#include<map>\nusing namespace std;\nconst int N=2010,V=1e5+10;\nint n,a[V],id;\nvector<int> e[V];\nmap<int,int> mp;\nbool used[V];\nint ok[N][N];\nint gcd(int x,int y){return y?gcd(y,x%y):x;}\nvoid addedge(int p,int prime){\n    int x=mp[prime];\n    if (!x) mp[prime]=x=++id;\n    e[p].push_back(x);\n    e[x].push_back(p);\n}\nvoid makegragh(int p){\n    int x=a[p];\n    for (int i=2;i*i<=x;i++)\n    if (x%i==0){\n        while (x%i==0) x/=i;\n        addedge(p,i);\n    }\n    if (x>1) addedge(p,x);\n}\nint q[N],size;\nbool test1(int x){//和前面的交换\n    for (int i=size;ok[x][q[i]];i--)\n        if (x>q[i]) return 0;\n    return 1;\n}\nint vis[V],C;\nvoid dfs(int x){\n    if (used[x]||vis[x]==C) return;\n    vis[x]=C;\n    for (int i=0;i<e[x].size();i++) dfs(e[x][i]);\n}\nbool test2(int x){\n    C++;\n    for (int i=1;i<=x;i++) dfs(i);\n    for (int i=x+1;i<=n;i++)\n    if (!used[i]&&vis[i]!=C) return 0;\n    return 1;\n}\nstruct array{\n    int cnt[N*4];\n    #define lc x<<1\n    #define rc x<<1|1\n    void set(int x,int l,int r,int p,int v){\n        if (l==r) return void(cnt[x]=v);\n        int mid=(l+r)>>1;\n        if (p>mid) set(rc,mid+1,r,p,v);else set(lc,l,mid,p,v);\n        cnt[x]=cnt[lc]+cnt[rc];\n    }\n    int next(int x,int l,int r,int p){\n        if (r<p||!cnt[x]) return n;\n        if (l==r) return l;\n        int mid=(l+r)>>1,ans=next(lc,l,mid,p);\n        return ans<n?ans:next(rc,mid+1,r,p);\n    }\n}arr[N];\nint main()\n{\n    scanf(\"%d\",&n);id=n;\n    for (int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n    sort(a+1,a+n+1);\n    for (int i=1;i<=n;i++) makegragh(i);\n    for (int i=1;i<=n;i++)\n    for (int j=1;j<=n;j++)\n        ok[i][j]=(gcd(a[i],a[j])==1);\n    for (int i=0;i<=n;i++)\n    for (int j=1;j<=n;j++)\n        if (!ok[i][j]) arr[i].set(1,1,n,j,1);\n    for (int i=1;i<=n;i++){\n        /*int Min;C++;\n        for (int j=1,p=n;j<=n;j++){\n            dfs(j);\n            while ((used[p]||vis[p]==C)&&p>j) p--;\n            if (p==j){Min=j;break;}\n        }\n        //>=Min的都满足test2()\n        int val=1e9,Max=n;\n        for (int j=size;j>=0;j--){\n            int nxt=arr[q[j]].next(1,1,n,Min);\n            if (nxt<=Max) val=min(val,nxt);\n            Max=min(Max,q[j]-1);\n        }\n        used[q[++size]=val]=1;\n        for (int j=1;j<=n;j++) arr[j].set(1,1,n,val,0);*/\n        for (int j=1;j<=n;j++)\n        if (!used[j]&&test1(j)&&test2(j)){\n            used[q[++size]=j]=1;\n            break;\n        }\n    }\n    for (int i=1;i<=n;i++) printf(\"%d \",a[q[i]]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=2005;\nint gcd(int a,int b)\n{\n\treturn a%b==0?b:gcd(b,a%b);\n}\nint n,A[N];\nbool vis[N];\nvector<int> adj[N],adj2[N];\nint deg[N],ans[N];\npriority_queue<int>Q;\nvoid dfs(int u)\n{\n\tvis[u]=true;\n\tfor(int i=0;i<(int)adj[u].size();i++)\n\t{\n\t\tint v=adj[u][i];\n\t\tif(vis[v])\n\t\t\tcontinue;\n\t\tadj2[u].push_back(v);\n\t\tdeg[v]++;\n\t\tdfs(v);\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&A[i]);\n\tsort(A+1,A+n+1);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(i!=j&&gcd(A[i],A[j])>1)\n\t\t\t\tadj[i].push_back(j);\n\tfor(int i=1;i<=n;i++)\n\t\tif(!vis[i])\n\t\t\tdfs(i);\n\tfor(int i=1;i<=n;i++)\n\t\tif(deg[i]==0)\n\t\t\tQ.push(i);\n\tint it=0;\n\twhile(!Q.empty())\n\t{\n\t\tint u=Q.top();\n\t\tans[++it]=A[u];\n\t\tQ.pop();\n\t\tfor(int i=0;i<(int)adj2[u].size();i++)\n\t\t{\n\t\t\tint v=adj2[u][i];\n\t\t\tdeg[v]--;\n\t\t\tif(deg[v]==0)\n\t\t\t\tQ.push(v);\n\t\t}\n\t}\n\tfor(int i=1;i<n;i++)\n\t\tprintf(\"%d \",ans[i]);\n\tprintf(\"%d\\n\",ans[n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=2005;\nstruct edge{\n\tint to,next;\n}e[N*N/2]; \nint gcd(int x,int y){\n\treturn y?gcd(y,x%y):x;\n}\nint head[N],tot;\nint deg[N],a[N],n;\nbool vis[N];\nvoid add(int x,int y){\n\te[++tot]=(edge){y,head[x]};\n\thead[x]=tot; deg[y]++;\n}\nvoid dfs(int x){\n\tvis[x]=1;\n\tfor (int i=1;i<=n;i++)\n\t\tif (!vis[i]&&gcd(a[x],a[i])>1)\n\t\t\tadd(x,i),dfs(i);\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tsort(a+1,a+n+1);\n\tfor (int i=1;i<=n;i++)\n\t\tif (!vis[i]) dfs(i);\n\tmemset(vis,0,sizeof(vis));\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=n;j;j--)\n\t\t\tif (!vis[j]&&!deg[j]){\n\t\t\t\tvis[j]=1;\n\t\t\t\tprintf(\"%d \",a[j]);\n\t\t\t\tfor (int k=head[j];k;k=e[k].ext)\n\t\t\t\t\tdeg[e[k].to]--;\n\t\t\t\tbreak;\n\t\t\t}\n} \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nconst int maxn = 2030, oo = 123456789, maxm = 34010;\n \nint n, m, T, ans, mn, a[maxn], foo[maxn], lst[maxm], tag[maxn];\nbool vis[maxn], f[maxn], G[maxn][maxn], F[maxn];\nstd::vector<int> g[maxn], has[maxn], rhas[maxm], all;\nstd::vector<std::pair<int, int> > v;\n \nvoid GEN() {\n\tint mx = 0;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif(!foo[i]) {\n\t\t\tif(a[i] == 1) {\n\t\t\t\tF[i] = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tF[i] = 0;\n\t\t\tfor (int j: has[i]) {\n\t\t\t\tif(lst[j] >= mx) {\n\t\t\t\t\tF[i] = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t(foo[i] > mx) && (mx = foo[i]);\n\t\t}\n\t}\n\treturn;\n}\n \nvoid dfs(int u) {\n\ttag[u] = T;\n\tif(F[u] && a[u] < mn) {\n\t\tmn = a[u];\n\t}\n\tvis[u] = 1;\n\tfor (int v: g[u]) {\n\t\tif(!vis[v] && !f[v]) {\n\t\t\tdfs(v);\n\t\t}\n\t}\n\treturn;\n}\n \nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tscanf(\"%d\", a + i);\n\t\tint t = a[i];\n\t\tfor (int x = 2; x * x <= t; ++x) {\n\t\t\tif(t % x == 0) {\n\t\t\t\tall.push_back(x);\n\t\t\t\twhile(t % x == 0) {\n\t\t\t\t\tt /= x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(t > 1) {\n\t\t\tall.push_back(t);\n\t\t}\n\t}\n\tstd::sort(a + 1, a + n + 1);\n\tstd::sort(all.begin(), all.end());\n\tall.resize(std::unique(all.begin(), all.end()) - all.begin());\n\tm = (int)(all.size());\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tif(a[i] % all[j] == 0) {\n\t\t\t\thas[i].push_back(j);\n\t\t\t\trhas[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int j = 0; j < m; ++j) {\n\t\tfor (int i = 0; i < (int)(rhas[j].size()); ++i) {\n\t\t\tfor (int k = 0; k < i; ++k) {\n\t\t\t\tint u = rhas[j][i], v = rhas[j][k];\n\t\t\t\tif(!G[u][v]) {\n\t\t\t\t\tg[u].push_back(v);\n\t\t\t\t\tg[v].push_back(u);\n\t\t\t\t\tG[u][v] = G[v][u] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tGEN();\n\t\tmemset(vis + 1, 0, sizeof(vis[0]) * n);\n\t\tv.clear();\n\t\tfor (int u = 1; u <= n; ++u) {\n\t\t\tif(F[u]) {\n\t\t\t\tif(!vis[u] && !f[u]) {\n\t\t\t\t\t++T;\n\t\t\t\t\tmn = oo;\n\t\t\t\t\tdfs(u);\n\t\t\t\t\tv.push_back(std::make_pair(mn, T));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstd::sort(v.begin(), v.end());\n\t\tint sz = (int)(v.size());\n\t\t//ans = 0;\n\t\tfor (int u = 1; u <= n; ++u) {\n\t\t\tif(F[u] && !f[u]) {\n\t\t\t\tint i = sz - 1;\n\t\t\t\tif(v[i].second == tag[u]) {\n\t\t\t\t\t--i;\n\t\t\t\t}\n\t\t\t\tif(i < 0 || v[i].first <= a[u]) {\n\t\t\t\t\tans = u;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tf[ans] = 1;\n\t\tfoo[ans] = i;\n\t\tprintf(\"%d \", a[ans]);\n\t\tfor (int j: has[ans]) {\n\t\t\tlst[j] = i;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"-Ofast\",\"-funroll-all-loops\")\n#include<bits/stdc++.h>\n//#define int long long\nusing namespace std;\nconst int N=2e3+10;\nint a[N],n,vis[N],cnt,dag[N];\nvector<int> g[N],v[N];\nvoid dfs(int x){\n\tvis[x]=1;\n\tfor(auto to:g[x])\tif(!vis[to]){\n\t\tdag[to]++;\tv[x].push_back(to);\tdfs(to);\n\t}\t\n}\nvoid top_sort(){\n\tpriority_queue<int> q;\n\tfor(int i=1;i<=n;i++)\tif(!dag[i])\tq.push(i);\n\twhile(q.size()){\n\t\tint u=q.top();\tq.pop();\n\t\tcout<<a[u]<<' ';\n\t\tfor(auto to:v[u])\tq.push(to);\n\t}\n}\nsigned main(){\n\tcin>>n;\n\tfor(int i=1;i<=n;i++)\tcin>>a[i];\n\tsort(a+1,a+1+n);\n\tfor(int i=1;i<=n;i++)\tfor(int j=i+1;j<=n;j++)\tif(__gcd(a[i],a[j])!=1){\n\t\tg[i].push_back(j),g[j].push_back(i);\n\t}\t\n\tfor(int i=1;i<=n;i++)\tif(!vis[i])\tdfs(i);\n\ttop_sort();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int, int> pii;\n\nconst int N = 2e3 + 5;\n\nll n, a[N], ans[N], in[N], tp[N], cur;\nbool mark[N];\nvector <int> adj[N];\nvector <pii> g[N];\n\nvoid dfs(int v) {\n\ttp[cur++] = v;\n\tmark[v] = true;\n\tfor (auto e : g[v]) {\n\t\tint u = e.second;\n\t\tif(!mark[u]) {\n\t\t\tdfs(u);\n\t\t}\n\t}\n}\n\nint main() {\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\t\n\tcin >> n;\n\tfor (int i = 0; i < n; i++)\n\t\tcin >> a[i];\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = i + 1; j < n; j++)\n\t\t\tif(__gcd(a[i], a[j]) > 1)\n\t\t\t\tg[i].push_back({a[j], j}), g[j].push_back({a[i], i});;\n\tfor (int i = 0; i < n; i++)\n\t\tsort(g[i].begin(), g[i].end());\n\tfor (int i = 0; i < n; i++)\n\t\tif(!mark[i])\n\t\t\tdfs(i);\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tint x = tp[i], y = tp[j];\n\t\t\tif(__gcd(a[x], a[y]) > 1) {\n\t\t\t\tadj[x].push_back(y);\n\t\t\t\tin[y]++;\n\t\t\t}\n\t\t}\n\t}\n\tpriority_queue <pii> pq;\n\tfor (int i = 0; i < n; i++) {\n\t\tif(!in[i])\n\t\t\tpq.push({a[i], i});\n\t}\n\tint cnt = 0;\n\twhile(!pq.empty()) {\n\t\tpii p = pq.top();\n\t\tpq.pop();\n\t\tans[cnt++] = p.first;\n\t\tint v = p.second;\n\t\tfor (auto u : adj[v]) {\n\t\t\tin[u]--;\n\t\t\tif(!in[u])\n\t\t\t\tpq.push({a[u], u});\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++)\n\t\tcout << ans[i] << \" \";\n\tcout << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<cstring>\n#include<algorithm>\n#include<stack>\n#define fo(i,a,b) for(i=a;i<=b;i++)\n#define ll long long\nusing namespace std;\nint n,a[2005],tot,du[2005],h[2005],to[4000005],nex[4000005];\nbool bhz[2005][2005],pd[2005];\nint gcd(int a,int b)\n{\n    return b?gcd(b,a%b):a;\n}\nstruct node{\n    int fr,id;\n}st;\nbool operator <(node a,node b)\n{\n    return a.fr<b.fr;\n}\nstack<node> q;\nvoid add(int a,int b)\n{\n    du[b]++;\n    to[++tot]=b;\n    nex[tot]=h[a];\n    h[a]=tot;\n}\nvoid dfs(int x)\n{\n    pd[x]=1;\n    for(int i=1;i<=n;i++)\n        if(bhz[x][i]&&!pd[i])\n        {\n            add(x,i);\n            dfs(i);\n        }\n}\nint main()\n{\n    cin>>n;\n    for(int i=1;i<=n;i++) cin>>a[i];\n    sort(a+1,a+n+1);\n    for(int i=1;i<=n-1;i++)\n    for(int j=i+1;j<=n;j++)\n    if(gcd(a[i],a[j])>1) bhz[i][j]=bhz[j][i]=1;\n    for(int i=1;i<=n;i++) if(!pd[i]) dfs(i);\n    for(int i=1;i<=n;i++) \n        if(!du[i])\n        { \n            st.fr=a[i];\n            st.id=i;\n            q.push(st); \n        }\n    for(int i=1;i<=n;i++)\n    {\n        st=q.top();\n        q.pop();\n        int now=st.id;\n        cout<<a[now]<<\" \";\n        int t=h[now];\n        while (t){\n            du[to[t]]--;\n            if (!du[to[t]]){\n                st.fr=a[to[t]];\n                st.id=to[t];\n                q.push(st);\n            }\n            t=nex[t];\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int _ = 2003;\nint A[_] , N , fa[_]; bool clr[_] , vis[_] , ban[_];\nint find(int x){return fa[x] == x ? x : (fa[x] = find(fa[x]));}\n\nint czys; map < int , int > zys; vector < int > pot[_ << 1] , fac[_];\nint getzys(int x){return zys[x] ? zys[x] : zys[x] = ++czys;}\n\nbool check(int mid){\n\twhile(mid && vis[mid]) --mid;\n\tif(!mid) return 0;\n\tfor(int i = 1 ; i <= N ; ++i){fa[i] = i; clr[i] = !vis[i] && (ban[i] || i > mid);}\n\tfor(int i = 0 ; i <= czys ; ++i)\n\t\tfor(int j = 1 ; j < pot[i].size() ; ++j){int p = find(pot[i][0]) , q = find(pot[i][j]); if(p != q){fa[q] = p; clr[p] &= clr[q];}}\n\tfor(int i = 1 ; i <= N ; ++i) if(clr[i] && fa[i] == i) return 0;\n\treturn 1;\n}\n\nvoid factor(int x){\n\tint p = A[x];\n\tfor(int i = 2 ; i * i <= p ; ++i)\n\t\tif(p % i == 0){int t = getzys(i); fac[x].push_back(t); pot[t].push_back(x); while(p % i == 0) p /= i;}\n\tif(p != 1){int t = getzys(p); fac[x].push_back(t); pot[t].push_back(x);}\n}\n\nint main(){\n\tcin >> N; for(int i = 1 ; i <= N ; ++i) cin >> A[i];\n\tsort(A + 1 , A + N + 1); for(int i = 1 ; i <= N ; ++i) factor(i);\n\t\n\tfor(int i = 1 ; i <= N ; ++i){\n\t\tint L = 1 , R = N; while(L < R){int mid = (L + R) >> 1; check(mid) ? R = mid : L = mid + 1;}\n\t\tvis[L] = 1; cout << A[L] << ' ';\n\t\tfor(auto t : fac[L]) pot[t].erase(find(pot[t].begin() , pot[t].end() , L));\n\t\tfor(int j = 1 ; j <= N ; ++j) if(vis[j] || __gcd(A[j] , A[L]) != 1) ban[j] = 0; else ban[j] |= j > L;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define gc c=getchar()\n#define r(x) read(x)\n#define ll long long\n\ntemplate<typename T>\ninline void read(T&x){\n    x=0;T k=1;char gc;\n    while(!isdigit(c)){if(c=='-')k=-1;gc;}\n    while(isdigit(c)){x=x*10+c-'0';gc;}x*=k;\n}\n\nconst int N=2005;\n\nint gcd(int a,int b){\n\treturn b?gcd(b,a%b):a;\n}\n\nvector<int>G1[N];\nvector<int>G2[N];\n\nint a[N];\nint deg[N];\nbool vis[N];\n\nvoid dfs(int x){\n\tvis[x]=1;\n\tfor(int i=0;i<G1[x].size();++i){\n\t\tint v=G1[x][i];\n\t\tif(!vis[v]){\n\t\t\tG2[x].push_back(v);\n\t\t\tdeg[v]++;\n\t\t\tdfs(v);\n\t\t}\n\t}\n}\n\nint main(){\n//\tfreopen(\".in\",\"r\",stdin);\n//\tfreopen(\".out\",\"w\",stdout);\n\tint n;r(n);\n\tfor(int i=1;i<=n;++i)r(a[i]);\n\tfor(int i=1;i<=n;++i){\n\t\tfor(int j=i+1;j<=n;++j){\n\t\t\tif(gcd(a[i],a[j])!=1){\n\t\t\t\tG1[i].push_back(j);\n\t\t\t\tG1[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\tif(!vis[i]){\n\t\t\tdfs(i);\n\t\t}\n\t}\n\tpriority_queue<pair<int,int> >Q;\n\tfor(int i=1;i<=n;++i){\n\t\tif(!deg[i]){\n\t\t\tQ.push(make_pair(a[i],i));\n\t\t}\n\t}\n\twhile(!Q.empty()){\n\t\tint x=Q.top().second;Q.pop();\n\t\tprintf(\"%d \",a[x]);\n\t\tfor(int i=0;i<G2[x].size();++i){\n\t\t\tint v=G2[x][i];\n\t\t\tif(!--deg[v]){\n\t\t\t\tQ.push(make_pair(a[v],v));\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define X first\n#define Y second\n\nint gcd(int a,int b) {return b?gcd(b,a%b):a;}\n\nconst int maxn=4010;\n\nint n,times,a[maxn],dfn[maxn],deg[maxn];\nint tote,FIR[maxn],TO[maxn],NEXT[maxn];\nint vis[maxn];\npriority_queue<pair<int,int> > q;\n\nvoid addedge(int u,int v)\n{\n\tTO[++tote]=v;\n\tNEXT[tote]=FIR[u];\n\tFIR[u]=tote;\n}\n\nint search(int u)\n{\n\tint Ans=u;\n\tvis[u]=1;\n\tfor (int p=FIR[u];p;p=NEXT[p])\n\t{\n\t\tint v=TO[p];\n\t\tif (vis[v]) continue;\n\t\tint tmp=search(v);\n\t\tAns=a[Ans]<a[tmp]?Ans:tmp;\n\t}\n\treturn Ans;\n}\n\nvoid dfs(int u)\n{\n\tvis[u]=2;\n\tdfn[u]=++times;\n\tvector<pair<int,int> > son;\n\tson.clear();\n\tfor (int p=FIR[u];p;p=NEXT[p])\n\t\tson.push_back(make_pair(a[TO[p]],TO[p]));\n\tsort(son.begin(),son.end());\n\tfor (int i=0;i<(int)son.size();i++)\n\t\tif (vis[son[i].Y]!=2) dfs(son[i].Y);\n}\n\nint main()\n{\n#ifdef h10\n\tfreopen(\"E.in\",\"r\",stdin);\n\tfreopen(\"E.out\",\"w\",stdout);\n#endif\n\tint i,j;\n\tscanf(\"%d\",&n);\n\tfor (i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tfor (i=1;i<=n;i++)\n\tfor (j=i+1;j<=n;j++)\n\t\tif (gcd(a[i],a[j])!=1)\n\t\t\taddedge(i,j),addedge(j,i);\n\n\tvector<pair<int,int> > root;\n\tfor (i=1;i<=n;i++)\n\t\tif (!vis[i])\n\t\t{\n\t\t\tint tmp=search(i);\n\t\t\troot.push_back(make_pair(a[tmp],tmp));\n\t\t}\n\tsort(root.begin(),root.end());\n\tfor (i=0;i<(int)root.size();i++) dfs(root[i].Y);\n\n\treturn 0;\n\n\ttote=0;\n\tmemset(FIR,0,sizeof(FIR));\n\tfor (i=1;i<=n;i++)\n\tfor (j=1;j<=n;j++)\n\t\tif (gcd(a[i],a[j])!=1&&dfn[i]<dfn[j])\n\t\t\taddedge(i,j),deg[j]++;\n\n\tfor (i=1;i<=n;i++)\n\t\tif (!deg[i]) q.push(make_pair(a[i],i));\n\twhile (!q.empty())\n\t{\n\t\tpair<int,int> u=q.top(); q.pop();\n\t\tprintf(\"%d \",u.X);\n\t\tfor (int p=FIR[u.Y];p;p=NEXT[p])\n\t\t{\n\t\t\tint v=TO[p];\n\t\t\tif (!(--deg[v])) q.push(make_pair(a[v],v));\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define LL long long\n#define RG register\n\nusing namespace std;\ntemplate<class T> T gi() {\n\tT x = 0; bool f = 0; char c = getchar();\n\twhile (c != '-' && (c < '0' || c > '9')) c = getchar();\n\tif (c == '-') f = 1, c = getchar();\n\twhile (c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n\treturn f ? -x : x;\n}\nconst int N = 4010;\nstruct node { int to, nxt; } g[N];\nint lst[N], gl, a[N];\nvoid add(int x, int y) { g[++gl] = (node) {y, lst[x]}; lst[x] = gl; }\nstruct cmp1 {\n\tbool operator () (int x, int y) const {\n\t\treturn a[x] > a[y];\n\t}\n};\npriority_queue<int, vector<int>, cmp1> q[N];\npriority_queue<pair<int, int> > p;\nint fa[N], mn[N];\nint find(int x) {\n\treturn fa[x] == x ? x : fa[x] = find(fa[x]);\n}\nbool vis[N];\nint main() {\n\t//freopen(\".in\", \"r\", stdin);\n\t//freopen(\".out\", \"w\", stdout);\n\tint n = gi<int>();\n\tfor (int i = 1; i <= n; i++) a[i] = gi<int>(), fa[i] = i, mn[i] = a[i];\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 1; j <= n; j++)\n\t\t\tif (a[i] < a[j] && __gcd(a[i], a[j]) > 1) {\n\t\t\t\tadd(i, j), add(j, i);\n\t\t\t\tmn[find(i)] = min(mn[find(i)], mn[find(j)]);\n\t\t\t\tfa[find(j)] = find(i);\n\t\t\t}\n\tfor (int i = 1; i <= n; i++)\n\t\tif (mn[find(i)] == a[i]) {\n\t\t\tp.push(make_pair(a[i], find(i))), vis[i] = 1;\n\t\t\tq[find(i)].push(i);\n\t\t}\n\twhile (!p.empty()) {\n\t\tpair<int, int> u = p.top(); p.pop();\n\t\tprintf(\"%d \", u.first);\n\t\tint x = q[u.second].top(); q[u.second].pop();\n\t\tfor (int i = lst[x]; i; i = g[i].nxt) {\n\t\t\tint v = g[i].to;\n\t\t\tif (!vis[v]) q[u.second].push(v), vis[v] = 1;\n\t\t}\n\t\tif (!q[u.second].empty()) p.push(make_pair(a[q[u.second].top()], u.second));\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> ii;\nint n;\nint a[2005];\nint gcd(int a, int b){\n    return a == 0 ? b:gcd(b%a,a);\n}\nint vis[2005];\nint nxt[2005];\nvector<int> dfs(int u){\n    vector<vector<int> > pos;\n    for (int i = 1; i <= n; i++){\n        if ((a[i] == 1 || gcd(a[u],a[i]) != 1) && vis[i] == 0){\n            //printf(\"%d -> %d: gcd(%d,%d) is %d\\n\",u,i,a[i],a[u],gcd(a[i],a[u]));\n            vis[i] = 1;\n            pos.push_back(dfs(i));\n        }\n    }\n    int NUM = pos.size();\n    int ct[NUM];\n    memset(ct,0,sizeof(ct));\n    priority_queue<ii> pq;\n    for (int i = 0; i < NUM; i++){\n        pq.push({pos[i][0],i});\n    }\n    vector<int> ans;\n    if (u != 0) ans.push_back(a[u]);\n    while (pq.size()){\n        ii cur = pq.top(); pq.pop();\n        ans.push_back(cur.first);\n        int id = cur.second;\n        ct[id]++;\n        if (ct[id] != pos[id].size()){\n            pq.push({pos[id][ct[id]],id});\n        }\n    }\n    return ans;\n}\nint main(){\n    scanf(\"%d\",&n);\n    for (int i = 1; i <= n; i++) scanf(\"%d\",&a[i]);\n    sort(a+1,a+n+1);\n    vector<int> v = dfs(0);\n    for (auto x : v){\n        printf(\"%d \",x);\n    }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nconst int maxn = 2030, oo = 123456789, maxm = 16010;\n \nint n, m, T, ans, mn, a[maxn], foo[maxn], lst[maxm], tag[maxn];\nbool vis[maxn], f[maxn], G[maxn][maxn], F[maxn];\nstd::vector<int> g[maxn], has[maxn], rhas[maxm], all;\nstd::vector<std::pair<int, int> > v;\n \nvoid GEN() {\n\tint mx = 0;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif(!foo[i]) {\n\t\t\tif(a[i] == 1) {\n\t\t\t\tF[i] = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tF[i] = 0;\n\t\t\tfor (int j: has[i]) {\n\t\t\t\tif(lst[j] >= mx) {\n\t\t\t\t\tF[i] = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t(foo[i] > mx) && (mx = foo[i]);\n\t\t}\n\t}\n\treturn;\n}\n \ninline void dfs(const int &u) {\n\ttag[u] = T;\n\tvis[u] = 1;\n\t(F[u] && a[u] < mn) && (mn = a[u]);\n\tfor (register int &v: g[u]) {\n\t\tif(!vis[v] && !f[v]) {\n\t\t\tdfs(v);\n\t\t}\n\t}\n\treturn;\n}\n \nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tscanf(\"%d\", a + i);\n\t\tint t = a[i];\n\t\tfor (int x = 2; x * x <= t; ++x) {\n\t\t\tif(t % x == 0) {\n\t\t\t\tall.push_back(x);\n\t\t\t\twhile(t % x == 0) {\n\t\t\t\t\tt /= x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(t > 1) {\n\t\t\tall.push_back(t);\n\t\t}\n\t}\n\tstd::sort(a + 1, a + n + 1);\n\tstd::sort(all.begin(), all.end());\n\tall.resize(std::unique(all.begin(), all.end()) - all.begin());\n\tm = (int)(all.size());\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tif(a[i] % all[j] == 0) {\n\t\t\t\thas[i].push_back(j);\n\t\t\t\trhas[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int j = 0; j < m; ++j) {\n\t\tfor (int i = 0; i < (int)(rhas[j].size()); ++i) {\n\t\t\tfor (int k = 0; k < i; ++k) {\n\t\t\t\tint u = rhas[j][i], v = rhas[j][k];\n\t\t\t\tif(!G[u][v]) {\n\t\t\t\t\tg[u].push_back(v);\n\t\t\t\t\tg[v].push_back(u);\n\t\t\t\t\tG[u][v] = G[v][u] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tGEN();\n\t\tmemset(vis + 1, 0, sizeof(vis[0]) * n);\n\t\tv.clear();\n\t\tfor (register int u = 1; u <= n; ++u) {\n\t\t\tif(F[u] && !vis[u] && !f[u]) {\n\t\t\t\t++T;\n\t\t\t\tmn = oo;\n\t\t\t\tdfs(u);\n\t\t\t\tv.push_back(std::make_pair(mn, T));\n\t\t\t}\n\t\t}\n\t\tstd::sort(v.begin(), v.end());\n\t\tint sz = (int)(v.size());\n//\t\tans = 0;\n\t\tfor (register int u = 1; u <= n; ++u) {\n\t\t\tif(F[u] && !f[u]) {\n\t\t\t\tint i = sz - 1;\n\t\t\t\tif(v[i].second == tag[u]) {\n\t\t\t\t\t--i;\n\t\t\t\t}\n\t\t\t\tif(v[i].first <= a[u] || i < 0) {\n\t\t\t\t\tans = u;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\tassert(ans);\n\t\tf[ans] = 1;\n\t\tfoo[ans] = i;\n\t\tprintf(\"%d \", a[ans]);\n\t\tfor (int j: has[ans]) {\n\t\t\tlst[j] = i;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//              +-- -- --++-- +-In the name of ALLAH-+ --++-- -- --+              \\\\\n\n#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define _sz(x) (int)x.size()\n\nusing namespace std ;\nusing ll = long long ;\nusing ld = long double ;\nusing pii = pair <int , int> ;\n\nint const N = 30000 + 20 , M = 30000 + 20 ,  MAX = 1e8 + 20 , S = 1e4 + 20 ;\nint n , a[N] ;\nvector <int> vec ;\n\nvector <int> g[M] ;\nint sz ;\nvector <int> comp[N] ;\n\nint ans[N] , mn[N] , last[M] ;\nbool dead[N] , vis[M] ;\nint mx1 , mx2 , mn_val[N] ;\n\nvector <int> primes ;\nvoid pre () {\n\tbool np[S] ;\n\tmemset(np , 0 , sizeof np) ;\n\tfor (int i = 2 ; i < S ; i ++) {\n\t\tif (np[i]) continue ;\n\t\tprimes.push_back(i) ;\n\t\tfor (int j = 2 * i ; j < S ; j += i) np[j] = 1 ;\n\t}\n}\n\ninline vector<int> get (int x) {\t\t\n\tvector <int> vec ;\n\n\tfor (int j = 0 ; 1ll * primes[j] * primes[j] <= x ; j ++) {\n\t\tif (x % primes[j]) continue ;\n\t\tvec.push_back(primes[j]) ;\n\t\twhile (x % primes[j] == 0) x /= primes[j] ;\n\t}\n\tif (x > 1) vec.push_back(x) ;\n\n\treturn vec ;\n}\n\ninline int get_id (int x) {\n\treturn lower_bound(vec.begin() , vec.end() , x) - vec.begin() ;\n}\n\ninline bool cmp (int x , int y) { return a[x] < a[y] ; }\n\nvoid dfs (int v) {\n\tif (vis[v]) return ;\n\tif (v < n) {\n\t\tif (dead[v]) return ;\n\t\tcomp[sz].push_back(v) ;\n\t}\n\tvis[v] = 1 ;\n\n\tfor (int u : g[v]) dfs(u) ;\n}\n\nint main(){\n\tios::sync_with_stdio(false) , cin.tie(0) , cout.tie(0) ;\n\n\tpre() ;\n\n\tcin >> n ;\n\tfor (int i = 0 ; i < n ; i ++) {\n\t\tcin >> a[i] ;\n\n\t\tvector <int> tmp = get(a[i]) ;\n\t\tfor (int x : tmp) vec.push_back(x) ;\n\t}\n\n\tsort(vec.begin() , vec.end()) ;\n\tvec.resize( unique(vec.begin() , vec.end()) - vec.begin() ) ;\n\n\tfor (int i = 0 ; i < n ; i ++) {\n\t\tvector <int> tmp = get(a[i]) ;\n\t\tfor (int x : tmp) {\n\t\t\tint u = i , v = n + get_id(x) ;\n\t\t\tg[u].push_back(v) ;\n\t\t\tg[v].push_back(u) ;\n\t\t}\n\t}\n\n\tmemset(last , -1 , sizeof last) ;\n\tmemset(mn , 63 , sizeof mn) ;\n\n\tfor (int i = 0 ; i < n ; i ++) {\n\t\tmemset(vis , 0 , sizeof vis) ;\n\t\tmx1 = 0 , mx2 = 0 ;\n\t\tsz = 0 ;\n\n\t\tfor (int v = 0 ; v < n ; v ++) {\n\t\t\tif (!dead[v] && !vis[v]) {\n\t\t\t\tcomp[sz].clear() ;\n\t\t\t\tdfs(v) ;\n\n\t\t\t\tsort(comp[sz].begin() , comp[sz].end() , cmp) ;\n\t\t\n\t\t\t\tmx2 = max(mx2 , a[comp[sz][0]]) ;\n\t\t\t\tif (mx2 > mx1) swap(mx1 , mx2) ;\n\n\t\t\t\tfor (int u : comp[sz]) mn_val[u] = a[comp[sz][0]] ;\n\t\t\t\t\n\t\t\t\tsz ++ ;\n\t\t\t}\n\t\t}\n\n\t\tint res = -1 ;\n\t\tfor (int j = 0 ; j < n ; j ++) {\n\t\t\tif (dead[j]) continue ;\n\n\t\t\tint val = (mn_val[j] == mx1 ? mx2 : mx1) ;\n\t\t\tif (val > a[j]) continue ;\n\n\t\t\tvector <int> tmp = get(a[j]) ;\n\t\t\tint pp = -1 ;\n\t\t\tfor (int x : tmp) pp = max(pp , last[x]) ;\n\n\t\t\tif (mn[pp + 1] < a[j]) continue ;\n\n\t\t\tif (res == -1 || a[res] > a[j]) res = j ;\n\t\t}\n\n\t\tdead[res] = 1 ;\n\t\tans[i] = a[res] ;\n\t\tfor (int j = i ; j >= 0 ; j --) mn[j] = min(mn[j] , a[res]) ;\n\t\tvector <int> tmp = get(a[res]) ;\n\t\tfor (int x : tmp) last[x] = i ;\n\t}\n\n\tfor (int i = 0 ; i < n ; i ++) cout << ans[i] << ' ' ; cout << '\\n' ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 0x3f3f3f3f;\n\nint GCD(int a, int b){\n\treturn b == 0 ? a : GCD(b, a % b);\n}\n\nint a[2010];\nint gcd[2010][2010];\nvector <int> from[2010];\nint ans[2010];\nint c[2010], in_ans[2010], minj[2010], last[2010], best[2010];\nint C, n;\n\nvoid dfs(int x){\n\tc[x] = C;\n\tfor (int i = 0; i < from[x].size(); i++){\n\t\tint v = from[x][i];\n\t\tif (c[v] != -1 || in_ans[v]) continue;\n\t\tdfs(v);\n\t}\n}\n\nvoid color(){\n\tC = 0;\n\tfor (int i = 0; i < n; i++){\n\t\tc[i] = -1;\n\t}\n\tfor (int i = 0; i < n; i++){\n\t\tif (c[i] != -1 || in_ans[i]) continue;\n\t\tdfs(i), C++;\n\t}\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++){\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tgcd[i][j] = GCD(a[i], a[j]) != 1;\n\t\t\tif (gcd[i][j]) from[i].push_back(j), from[j].push_back(i);\n\t\t}\n\t}\n\tfor (int i = 0; i <= n; i++){\n\t\tminj[i] = INF, last[i] = -1;\n\t}\n\tint tot = 0;\n\twhile (tot != n){\n\t\tcolor();\n\t\tfor (int i = 0; i < C; i++){\n\t\t\tbest[i] = -1;\n\t\t}\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tif (in_ans[i]) continue;\n\t\t\tif (minj[last[i] + 1] < a[i]) continue;\n\t\t\tif (best[c[i]] == -1 || a[best[c[i]]] > a[i]) best[c[i]] = i;\n\t\t}\n\t\tint id = -1;\n\t\tfor (int i = 0; i < C; i++){\n\t\t\tif (best[i] == -1) continue;\n\t\t\tif (id == -1 || a[id] < a[best[i]]) id = best[i];\n\t\t}\n\t\tif (id == -1) throw;\n\t\tin_ans[id] = 1, ans[tot++] = a[id];\n\t\tfor (int i = 0; i < tot; i++){\n\t\t\tminj[i] = min(minj[i], a[id]);\n\t\t}\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tif (gcd[id][i]) last[i] = tot - 1;\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++){\n\t\tprintf(\"%d \", ans[i]);\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define re register\n#define ll long long\ninline int gi(){\n\tint f=1,sum=0;char ch=getchar();\n\twhile(ch>'9' || ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0' && ch<='9'){sum=(sum<<3)+(sum<<1)+ch-'0';ch=getchar();}\n\treturn f*sum;\n}\nconst int N=2010;\nint a[N],link[N][N],vis[N],d[N],n;\nvector<int>G[N];\nvoid dfs(int u){\n\tvis[u]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tif(link[u][i] && !vis[i]){\n\t\t\td[i]++;\n\t\t\tG[u].push_back(i);\n\t\t\tdfs(i);\n\t\t}\n}\nqueue<int>Q;\nint main(){\n\tn=gi();for(int i=1;i<=n;i++)a[i]=gi();\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\tif(__gcd(a[i],a[j])==1)link[i][j]=link[j][i]=1;\n\tfor(int i=1;i<=n;i++)if(!vis[i])dfs(i);\n\tfor(int i=1;i<=n;i++)if(!d[i])Q.push(i);\n\twhile(!Q.empty()){\n\t\tint u=Q.front();Q.pop();\n\t\tprintf(\"%d \",a[u]);\n\t\tfor(auto v:G[u])Q.push(v);\n\t}\n\tputs(\"\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n\nstruct Nums {\n\tint a, b;\n\n\tbool operator < (const Nums& rhs)const {\n\t\tif (a < rhs.a) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n};\n\nint N, A[2000] = { 0 };\n\nbool CheckDisjoint(int a, int b) {\n\tstatic std::map<Nums, bool> Map;\n\n\tNums temp;\n\tif (a < b) {\n\t\ttemp.a = a;\n\t\ttemp.b = b;\n\t} else {\n\t\ttemp.a = b;\n\t\ttemp.b = a;\n\t};\n\n\t//std::map<Nums, bool>::iterator it = Map.find(temp);\n\t//if (it != Map.end()) {\n\t//\treturn it->second;\n\t//}\n\n\tif (temp.a == 1) {\n\t\tMap.insert(std::map<Nums, bool>::value_type(temp, true));\n\t\treturn true;\n\t}\n\tif (a % 2 == 0 && b % 2 == 0) {\n\t\tMap.insert(std::map<Nums, bool>::value_type(temp, false));\n\t\treturn false;\n\t}\n\tfor (int i = 3; i <= a && i <= b; i += 2) {\n\t\tif (a % i == 0 && b % i == 0) {\n\t\t\tMap.insert(std::map<Nums, bool>::value_type(temp, false));\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tMap.insert(std::map<Nums, bool>::value_type(temp, true));\n\treturn true;\n}\n\nbool DescSort() {\n\tbool result = false;\n\tfor (int i = 0; i < N - 1; i++) {\n\t\tif (A[i] < A[i + 1]) {\n\t\t\tif (CheckDisjoint(A[i], A[i + 1])) {\n\t\t\t\tint temp = A[i];\n\t\t\t\tA[i] = A[i + 1];\n\t\t\t\tA[i + 1] = temp;\n\t\t\t\tresult = true;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n\nbool AscSort() {\n\tbool result = false;\n\tfor (int i = 0; i < N - 1; i++) {\n\t\tif (A[i] > A[i + 1]) {\n\t\t\tif (CheckDisjoint(A[i], A[i + 1])) {\n\t\t\t\tint temp = A[i];\n\t\t\t\tA[i] = A[i + 1];\n\t\t\t\tA[i + 1] = temp;\n\t\t\t\tresult = true;\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n\n\nint main() {\n\tstd::cin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tstd::cin >> A[i];\n\t}\n\n\twhile (AscSort());\n\twhile (DescSort());\n\n\tstd::cout << A[0];\n\tfor (int i = 1; i < N; i++) {\n\t\tstd::cout << \" \" << A[i];\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define pb push_back\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\nusing namespace std;\nconst int N=2005+5,M=5e6+5;\nstruct eg{int v,nx;}e[M];int head[N],tot;\ninline void add(R int u,R int v){e[++tot]={v,head[u]},head[u]=tot;}\nvector<int>to[N];int deg[N],vis[N],a[N],n;\npriority_queue<int>q;\nvoid dfs(int u){\n\tvis[u]=1;\n\tfor(auto v:to[u])if(!vis[v])add(u,v),++deg[v],dfs(v);\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfp(i,1,n)scanf(\"%d\",&a[i]);\n\tsort(a+1,a+1+n);\n\tfp(i,1,n)fp(j,i+1,n)if(__gcd(a[i],a[j])>1)to[i].pb(j),to[j].pb(i);\n\tfp(i,1,n)if(!vis[i])dfs(i);\n\tfp(i,1,n)if(!deg[i])q.push(i);\n\tfor(R int u;!q.empty();){\n\t\tu=q.top(),q.pop();\n\t\tprintf(\"%d \",a[u]);\n\t\tgo(u)if(!--deg[v])q.push(v);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#define rep(x, a, b) for(int x = (a); x <= (b); ++x)\n#define rop(x, a, b) for(int x = (a); x < (b); ++x)\n#define per(x, a, b) for(int x = (a); x >= (b); --x)\nusing namespace std;\ntypedef long long LL;\ntypedef double DB;\nint n, a[3005];\nstruct tree {\n\tint hd[3005], vr[3005], nt[3005], tt;\n\tvoid push(int x, int y) {\n\t\tvr[++tt] = y; nt[tt] = hd[x]; hd[x] = tt;\n\t}\n\tint dfs(int nw) {\n\t\tfor(int i = hd[nw]; i; i = nt[i]) {\n\t\t\tif(a[vr[i]] >= a[nw]) continue;\n\t\t\tif(!dfs(vr[i])) return 1;\n\t\t}\n\t\treturn 0;\n\t}\n}T;\nint x, y;\nint main() {\n\tscanf(\"%d\", &n);\n\trep(i, 1, n) scanf(\"%d\", &a[i]);\n\trop(i, 1, n) {\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tT.push(x, y);\n\t\tT.push(y, x); \n\t}\n\trep(i, 1, n) {\n\t\tif(T.dfs(i)) printf(\"%d \", i);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nconstexpr auto MAXN = 2000+550;\n\nint num[MAXN]; bool vis[MAXN];\nstd::vector<int> link[MAXN],G[MAXN];\nint inc[MAXN];\n\nvoid Dfs(const int& nowAt){\n\tvis[nowAt] = true;\n\tfor(const auto &it : link[nowAt])\n\t\tif(!vis[it]){\n\t\t\tG[nowAt].push_back(it);\n\t\t\tinc[it]++;\n\t\t\tDfs(it);\n\t\t}\n}\n\nsigned main(void)\n{\n\tint totNums;\n\n\tscanf(\"%d\", &totNums);\n\tfor(int i=0;i<totNums;i++) scanf(\"%d\", num+i);\n\tstd::sort(num,num+totNums);\n\n\tfor(int i=0;i<totNums;i++)\n\t\tfor(int j=i+1;j<totNums;j++)\n\t\t\tif(std::__gcd(num[i],num[j]) > 1){\n\t\t\t\tlink[i].push_back(j); link[j].push_back(i);\n\t\t\t}\n\n\tmemset(vis,false,sizeof(vis));\n\tfor(int i=0;i<totNums;i++)\n\t\tif(!vis[i]) Dfs(i);\n\n\tstd::priority_queue<int,std::vector<int>,std::less<int>> que;\n\tfor(int i=0;i<totNums;i++)\n\t\tif(inc[i] == 0) que.push(i);\n\n\tint nowAt;\n\twhile(!que.empty()){\n\t\tnowAt = que.top(); que.pop();\n\t\tprintf(\"%d \", num[nowAt]);\n\t\tfor(const auto &it : G[nowAt])\n\t\t\tif(--inc[it] == 0) que.push(it);\n\t}\n\tputchar('\\n');\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ADD(a, b) a = (a + ll(b)) % mod\n#define MUL(a, b) a = (a * ll(b)) % mod\n#define MAX(a, b) a = max(a, b)\n#define MIN(a, b) a = min(a, b)\n#define rep(i, a, b) for(int i = int(a); i < int(b); i++)\n#define rer(i, a, b) for(int i = int(a) - 1; i >= int(b); i--)\n#define all(a) (a).begin(), (a).end()\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sec second\n#define fst first\n#define debug(fmt, ...) Debug(__LINE__, \":\", fmt, ##__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<int, pi> ppi;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vl> mat;\ntypedef complex<double> comp;\nvoid Debug() {cout << '\\n'; }\ntemplate<class FIRST, class... REST>void Debug(FIRST arg, REST... rest){\n\tcout<<arg<<\" \";Debug(rest...);}\ntemplate<class T>ostream& operator<<(ostream& out,const vector<T>& v) {\n\tout<<\"[\";if(!v.empty()){rep(i,0,sz(v)-1)out<<v[i]<<\", \";out<<v.back();}out<<\"]\";return out;}\ntemplate<class S, class T>ostream& operator<<(ostream& out,const pair<S, T>& v){\n\tout<<\"(\"<<v.first<<\", \"<<v.second<<\")\";return out;}\nconst int MAX_N = 2010;\nconst int MAX_V = 100010;\nconst double eps = 1e-6;\nconst ll mod = 1000000007;\nconst int inf = 1 << 29;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\nll gcd(ll a, ll b) {\n\tif(b == 0) return a;\n\telse return gcd(b, a % b);\n}\n\nint N;\nbool on[MAX_N], used[MAX_N];\nbool deleted[MAX_N];\nint A[MAX_N];\nvector<int> G[MAX_N];\n\nvoid add_edge(int from, int to) {\n\tG[from].pb(to);\n\tG[to].pb(from);\n}\n\nvoid erase_node(int v) {\n\tdeleted[v] = true;\n\trep(i, 0, sz(G[v])) {\n\t\tint n = G[v][i];\n\t\ton[n] = true;\n\t}\n}\n\npi loop(int v, bool only = false) {\n\tused[v] = true;\n\tpi res;\n\tif(!only || on[v]) res = pi(A[v], v);\n\telse res = pi(inf, inf);\n\trep(i, 0, sz(G[v])) {\n\t\tint n = G[v][i];\n\t\tif(!used[n] && !deleted[n]) MIN(res, loop(n));\n\t}\n\treturn res;\n}\n\nvoid graph_show() {\n\trep(i, 0, N) {\n\t\tvector<int> res;\n\t\trep(j, 0, sz(G[i])) {\n\t\t\tint n = G[i][j];\n\t\t\tif(deleted[n]) continue;\n\t\t\tres.pb(A[n]);\n\t\t}\n\t\tdebug(A[i], res);\n\t}\n}\n\n\nvoid solve() {\n\tcin >> N;\n\trep(i, 0, N) {\n\t\tcin >> A[i];\n\t}\n\trep(i, 0, N) {\n\t\trep(j, i + 1, N) {\n\t\t\tif(gcd(A[i], A[j]) != 1) {\n\t\t\t\tadd_edge(i, j);\n\t\t\t}\n\t\t}\n\t}\n\n\trep(i, 0, N) {\n\t\tif(!used[i]) {\n\t\t\tpi p = loop(i);\n\t\t\ton[p.sec] = true;\n\t\t}\n\t}\n\tvector<int> ans;\n\trep(q, 0, N) {\n\t\t// debug(vi(on, on + N));\n\t\t// graph_show();\n\t\tint a = -1, at = -1;\n\t\tmemset(used, 0, sizeof(used));\n\t\trep(i, 0, N) {\n\t\t\tif(!used[i] && !deleted[i]) {\n\t\t\t\tpi p = loop(i, true);\n\t\t\t\tif(a < p.fst) {\n\t\t\t\t\ta = p.fst; at = p.sec;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans.pb(a);\n\t\terase_node(at);\n\t}\n\trep(i, 0, N) {\n\t\tcout << ans[i] << \" \";\n\t}\n\tcout << \"\\n\";\n}\n\n\nint main() {\n#ifndef LOCAL\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n\tcout.precision(20);\n\tsrand((unsigned int)time(NULL));\n#ifdef LOCAL\n\t//freopen(\"in.txt\", \"wt\", stdout); //for tester\n    freopen(\"in.txt\", \"rt\", stdin);\n#endif\t\n\tsolve();\n#ifdef LOCAL\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\ntypedef long long ll ;\n#define rep(i, a, b) for (int i = a ; i <= b; ++ i) \nconst int N = 2005, inf = 1e9 + 7 ;\nusing namespace std ;\n\nint n, a[N], opt[N] ;\nbool G[N][N] ;\n\nint gcd(int x, int y) {\n\treturn (y ? gcd(y, x % y) : x) ;\n}\n\nvector <int> solve(vector <int> S, int las) {\n\tvector <int> res, A ;\n\tvector <bool> vis ;\n\tint sz = S.size(), rt = n + 1 ; a[n + 1] = inf ;\n\tif (sz == 1) {\n\t\tres.push_back(a[S[0]]) ;\n\t\treturn res ;\n\t}\n\trep(i, 0, sz - 1) if (G[las][S[i]] && a[S[i]] < a[rt]) rt = S[i] ;\n\tres.push_back(a[rt]) ;\n\trep(i, 1, n) G[i][rt] = false ;\n\trep(i, 0, sz - 1) vis.push_back(true), A.push_back(0) ;\n\trep(p, 0, sz - 1) if (S[p] != rt && vis[p]) {\n\t\tint he = 0, ta = 1 ;\n\t\topt[1] = S[p], vis[p] = false ;\n\t\tfor ( ; he != ta ; ) {\n\t\t\tint u = opt[++ he] ;\n\t\t\trep(i, 0, sz - 1) if (G[u][S[i]] && vis[i]) {\n\t\t\t\tvis[i] = false ;\n\t\t\t\topt[++ ta] = S[i] ;\n\t\t\t}\n\t\t}\n\t\tvector <int> T ;\n\t\trep(i, 1, ta) T.push_back(opt[i]) ;\n\t\tvector <int> B = solve(T, rt) ;\n\t\tint na = (int) res.size() - 2, nb = (int) B.size() - 1, topa = 0, topb = 0 ;\n\t\trep(i, 0, na) A[i] = res[i + 1] ;\n\t\trep(i, 1, ta) res.push_back(0) ;\n\t\trep(i, 1, na + nb + 2) {\n\t\t\tif (topa <= na && (topb > nb || A[topa] >= B[topb])) res[i] = A[topa ++] ; else res[i] = B[topb ++] ;\n\t\t} \n\t}\n\treturn res ;\n}\n\nint main() {\n\tscanf(\"%d\", &n) ;\n\trep(i, 1, n) scanf(\"%d\", &a[i]) ;\n\trep(i, 0, n) G[i][0] = G[0][i] = true ;\n\trep(i, 1, n) rep(j, 1, n) G[i][j] = G[j][i] = (gcd(a[i], a[j]) != 1) ;\n\tvector <int> S, ans ; a[0] = - inf ;\n\trep(i, 0, n) S.push_back(i) ;\n\tans = solve(S, 0) ;\n\trep(i, 0, n - 1) printf(\"%d \", ans[i + 1]) ; puts(\"\") ;\n\treturn 0 ; \n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"Ofast\")\n#include <iostream>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <set>\n#include <deque> \n#define rep(x, a, b) for(int x = (a); x <= (b); ++x)\n#define rop(x, a, b) for(int x = (a); x < (b); ++x)\n#define per(x, a, b) for(int x = (a); x >= (b); --x)\nusing namespace std;\ntypedef long long LL;\ntypedef double DB;\ndeque<int> C[2005];\nint a[2005];\nstruct graph {\n\tset<int> S[2005];\n\tint vs[2005];\n\tvoid push(int x, int y) {\n\t\tS[x].insert(y);\n\t}\n\tvoid dfs(int nw) {\n\t\tC[nw].clear();\n\t\tvs[nw] = 1;\n\t\tint SM = 0;\n\t\tauto IT = S[nw].begin();\n\t\twhile(IT != S[nw].end()) {\n\t\t\tif(vs[*IT]) {C[*IT].clear(); ++IT; continue;}\n\t\t\tdfs(*IT);\n\t\t\tSM += C[*IT].size();\n\t\t\t++IT;\n\t\t}\n\t\trep(i, 1, SM) {\n\t\t\tint mx = 0, bj = 0;\n\t\t\tauto IT = S[nw].begin();\n\t\t\twhile(IT != S[nw].end()) {\n\t\t\t\tif(!C[*IT].size()) {++IT; continue;}\n\t\t\t\tif(mx < C[*IT][0]) mx = C[*IT][0], bj = *IT;\n\t\t\t\t++IT;\n\t\t\t}\n\t\t\tC[bj].pop_front();\n\t\t\tC[nw].push_back(mx);\n\t\t}\n\t\tC[nw].push_front(a[nw]);\n\t}\n}G;\nint n;\nint main() {\n\tscanf(\"%d\", &n);\n\trep(i, 1, n) scanf(\"%d\", &a[i]);\n\trep(i, 1, n) rep(j, 1, n) if(i != j && __gcd(a[i], a[j]) != 1) G.push(i, j); \n\trep(i, 1, n) G.push(0, i);\n\tG.dfs(0);\n\trop(i, 1, C[0].size()) printf(\"%d \", C[0][i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mp make_pair\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int > vi;\ntypedef pair<int ,int > pii;\ntypedef vector<pii> vii;\nconst int inf=0x3f3f3f3f, maxn=100007, mod=1e9+7;\nconst ll linf=0x3f3f3f3f3f3f3f3fLL;\nint n,a[2007];\nvi e[2007];\nvi e2[2007];\nbool vis[2007];\nint deg[2007];\nvoid dfs(int x){\n\tif(vis[x])return ;\n\tvis[x]=true;\n\tfor(int i=0;i<e[x].size();i++){\n\t\tif(!vis[e[x][i]]){\n\t\t\te2[x].pb(e[x][i]);\n\t\t\tdeg[e[x][i]]++;\n\t\t\tdfs(e[x][i]);\n\t\t}\n\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=i+1;j<=n;j++){\n\t\t\tif(__gcd(a[i],a[j])>1)e[i].pb(j),e[j].pb(i);\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)sort(e[i].begin(),e[i].end());\n\tfor(int i=1;i<=n;i++)if(!vis[i])dfs(i);\n\tmemset(vis,0,sizeof(vis));\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=n;j>=1;j--){\n\t\t\tif(!deg[j]&&!vis[j]){\n\t\t\t\tvis[j]=true;\n\t\t\t\tprintf(\"%d \",a[j]);\n\t\t\t\tfor(int k=0;k<e2[j].size();k++)deg[e2[j][k]]--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxN = 2005;\n\nint n;\nint a[maxN + 1], deg[maxN + 1];\nbool flag[maxN + 1];\n\nvector<int> to[maxN + 1], nxt[maxN + 1];\n\npriority_queue<int> q;\n\ninline void dfs(int u)\n{\n\tflag[u] = true;\n\tfor(int i = 0; i < to[u].size(); i++)\n\t{\n\t\tint v = to[u][i];\n\t\tif(flag[v]) continue;\n\t\tnxt[u].push_back(v); deg[v] ++;\n\t\tdfs(v);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor(int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n\n\tsort(a + 1, a + n + 1);\n\n\tfor(int i = 1; i <= n; i++)\n\t\tfor(int j = 1; j <= n; j++)\n\t\t\tif(i != j && __gcd(a[i], a[j]) != 1) to[i].push_back(j);\n\n\tfor(int i = 1; i <= n; i++)\n\t\tif(!flag[i]) dfs(i);\n\t\n\tfor(int i = 1; i <= n; i++)\n\t\tif(!deg[i]) q.push(i);\n\twhile(!q.empty())\n\t{\n\t\tint x = q.top(); q.pop();\n\t\tprintf(\"%d \", a[x]);\n\t\tfor(int i = 0; i < nxt[x].size(); i++)\n\t\t\tif(-- deg[ nxt[x][i] ] == 0) q.push(nxt[x][i]);\n\t}\n\tputs(\"\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n#define MOD @\n#define ADD(X,Y) ((X) = ((X) + (Y)%MOD) % MOD)\ntypedef long long i64; typedef vector<int> ivec; typedef vector<string> svec;\n\nint gcd(int a, int b)\n{\n\twhile (b) {\n\t\tint t = a % b;\n\t\ta = b;\n\t\tb = t;\n\t}\n\treturn a;\n}\n\nint N, A[2020];\nvector<int> dv[2020];\nvector<int> rdiv[50505];\nint RC;\n\nbool isok[2020], used[2020];\nbool rdivvis[50505];\nbool vis[2020];\n\nbool chk(int iic)\n{\n\tfor (int i = 0; i < N; ++i) vis[i] = false;\n\tfor (int i = 0; i < RC; ++i) rdivvis[i] = false;\n\n\tqueue<int> Qa, Qb;\n\t// place [0, iic] first\n//\tprintf(\"chk %d\\n\", A[iic]);\n\tfor (int i = 0; i <= iic; ++i) if (!used[i] && isok[i]) {\n\t\tQa.push(i);\n\t\tvis[i] = true;\n\t}\n\twhile (!Qa.empty()) {\n\t\tint v = Qa.front(); Qa.pop();\n\t\tfor (int p : dv[v]) if (!rdivvis[p]) {\n\t\t\trdivvis[p] = true;\n\t\t\tfor (int i : rdiv[p]) if (!used[i] && !vis[i]) {\n\t\t\t\tvis[i] = true;\n\t\t\t\tif (i <= iic) Qa.push(i);\n\t\t\t\telse Qa.push(i);\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\twhile (!Qb.empty()) {\n\t\tint v = Qb.front(); Qb.pop();\n\t\tfor (int p : dv[v]) if (!rdivvis[p]) {\n\t\t\trdivvis[p] = true;\n\t\t\tfor (int i : rdiv[p]) if (!used[i] && !vis[i]) {\n\t\t\t\tvis[i] = true;\n\t\t\t\tif (i <= iic) {\n\t\t\t\t\tputs(\"><\");\n\t\t\t\t\texit(0);\n\t\t\t\t} else Qb.push(i);\n\t\t\t}\n\t\t}\n\t}\n\t*/\n\tfor (int i = 0; i < N; ++i) if (!used[i] && !vis[i]) return false;\n\treturn true;\n}\n\nint main()\n{\n\tscanf(\"%d\", &N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tscanf(\"%d\", A + i);\n\t}\n\tsort(A, A + N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tint v = A[i];\n\t\tfor (int j = 2; j * j <= v; ++j) {\n\t\t\tif (v % j == 0) {\n\t\t\t\tdv[i].push_back(j);\n\t\t\t\twhile (v % j == 0) v /= j;\n\t\t\t}\n\t\t}\n\t\tif (v > 1) dv[i].push_back(v);\n\t}\n\tvector<int> alldv;\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int p : dv[i]) alldv.push_back(p);\n\t}\n\tsort(alldv.begin(), alldv.end());\n\talldv.erase(unique(alldv.begin(), alldv.end()), alldv.end());\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int &p : dv[i]) {\n\t\t\tp = lower_bound(alldv.begin(), alldv.end(), p) - alldv.begin();\n\t\t\trdiv[p].push_back(i);\n\t\t}\n\t}\n\tRC = alldv.size();\n\n\tfor (int i = 0; i < N; ++i) {\n\t\tisok[i] = true;\n\t\tused[i] = false;\n\t}\n\n\tvector<int> ans;\n\tfor (int i = 0; i < N; ++i) {\n\t\tvector<int> cand;\n\t\tfor (int j = 0; j < N; ++j) if (!used[j]) cand.push_back(j);\n\n\t\tint left = 0, right = cand.size() - 1;\n\t\twhile (left < right) {\n\t\t\tint mid = (left + right) / 2;\n\t\t\tif (chk(cand[mid])) {\n\t\t\t\tright = mid;\n\t\t\t} else {\n\t\t\t\tleft = mid + 1;\n\t\t\t}\n\t\t}\n\t\tint v = A[cand[left]];\n\t\tans.push_back(v);\n\t//\tprintf(\"%d\\n\", v);\n\t\tused[cand[left]] = true;\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tif (A[j] > v) {\n\t\t\t\tisok[j] = false;\n\t\t\t}\n\t\t\tif (gcd(A[j], v) != 1) {\n\t\t\t\tisok[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < N; ++i) printf(\"%d%c\", ans[i], i == N - 1 ? '\\n' : ' ');\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nconst int N=2005;\n\nint n,a[N],last[N],deg[N],cnt;\nbool vis[N];\nstruct edge{int to,next;}e[N*N];\n\nint gcd(int x,int y)\n{\n\tif (!y) return x;\n\telse return gcd(y,x%y);\n}\n\nvoid addedge(int u,int v)\n{\n\te[++cnt].to=v;e[cnt].next=last[u];last[u]=cnt;\n\tdeg[v]++;\n}\n\nvoid dfs(int x)\n{\n\tvis[x]=1;\n\tfor (int i=1;i<=n;i++)\n\t\tif (!vis[i]&&gcd(a[x],a[i])>1)\n\t\t{\n\t\t\taddedge(x,i);\n\t\t\tdfs(i);\n\t\t}\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tsort(a+1,a+n+1);\n\tfor (int i=1;i<=n;i++) if (!vis[i]) dfs(i);\n\tmemset(vis,0,sizeof(vis));\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=n;j>=1;j--)\n\t\t\tif (!vis[j]&&!deg[j])\n\t\t\t{\n\t\t\t\tvis[j]=1;\n\t\t\t\tprintf(\"%d \",a[j]);\n\t\t\t\tfor (int k=last[j];k;k=e[k].next) deg[e[k].to]--;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cstdio>\n#include<vector>\n#include<functional>\n#include<queue>\n\nusing namespace std;\nconst int MX=2011;\nint n,a[MX];\nstruct Edge{int t,nxt;Edge(int _t=0,int _nxt=0):t(_t),nxt(_nxt){}}e[MX*MX];\nint hed[MX],ec;\ninline void ade(int f,int t){e[++ec]=Edge(t,hed[f]);hed[f]=ec;}\n#define FE(k,i) for(int (i)=hed[k];(i);(i)=e[i].nxt)if(!vis[e[i].t])\ninline int gcd(int x,int y){if(x<y)swap(x,y);while(y)x%=y,swap(x,y);return x;}\n\nint vis[MX],stk[MX],nxt[MX],stc;\n\nvector<int> operator+(vector<int> x,vector<int> y){\n\tvector<int> res;res.clear();\n\tvector<int>::iterator i=x.begin(),j=y.begin();\n\twhile(i!=x.end()||j!=y.end()){\n\t\tif(i!=x.end()&&(j==y.end()||*i>*j))res.push_back(*(i++));\n\t\telse res.push_back(*(j++));\n\t}\n\treturn res;\n}\nvector<int> dfs(int k){\n\tvis[k]=1;\n\tvector<int>res;res.clear();\n\tres.push_back(0x7fffffff);\n\tFE(k,i)res=res+dfs(e[i].t);\n\tres[0]=k;\n\treturn res;\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n\tsort(a+1,a+n+1);\n\tfor(int i=n;i>=1;i--)\n\t\tfor(int j=n;j>i;j--)\n\t\t\tif(gcd(a[i],a[j])>1)ade(i,j),ade(j,i);\n\tvector<int>S;S.clear();\n\tfor(int i=1;i<=n;i++)if(!vis[i])S=S+dfs(i);\n\tfor(vector<int>::iterator it=S.begin();it!=S.end();it++)printf(\"%d \",a[*it]);\n\tputs(\"\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O2\")\n#include <iostream>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <set>\n#include <deque> \n#define rep(x, a, b) for(int x = (a); x <= (b); ++x)\n#define rop(x, a, b) for(int x = (a); x < (b); ++x)\n#define per(x, a, b) for(int x = (a); x >= (b); --x)\nusing namespace std;\ntypedef long long LL;\ntypedef double DB;\ndeque<int> C[2005];\nint a[2005];\nstruct graph {\n\tset<int> S[2005];\n\tint vs[2005];\n\tvoid push(int x, int y) {\n\t\tS[x].insert(y);\n\t}\n\tvoid dfs(int nw) {\n\t\tC[nw].clear();\n\t\tvs[nw] = 1;\n\t\tint SM = 0;\n\t\tauto IT = S[nw].begin();\n\t\twhile(IT != S[nw].end()) {\n\t\t\tif(vs[*IT]) {C[*IT].clear(); ++IT; continue;}\n\t\t\tdfs(*IT);\n\t\t\tSM += C[*IT].size();\n\t\t\t++IT;\n\t\t}\n\t\trep(i, 1, SM) {\n\t\t\tint mx = 0, bj = 0;\n\t\t\tauto IT = S[nw].begin();\n\t\t\twhile(IT != S[nw].end()) {\n\t\t\t\tif(!C[*IT].size()) {++IT; continue;}\n\t\t\t\tif(mx < C[*IT][0]) mx = C[*IT][0], bj = *IT;\n\t\t\t\t++IT;\n\t\t\t}\n\t\t\tC[bj].pop_front();\n\t\t\tC[nw].push_back(mx);\n\t\t}\n\t\tC[nw].push_front(a[nw]);\n\t}\n}G;\nint n;\nint main() {\n\tscanf(\"%d\", &n);\n\trep(i, 1, n) scanf(\"%d\", &a[i]);\n\trep(i, 1, n) rep(j, 1, n) if(i != j && __gcd(a[i], a[j]) != 1) G.push(i, j); \n\trep(i, 1, n) G.push(0, i);\n\tG.dfs(0);\n\trop(i, 1, C[0].size()) printf(\"%d \", C[0][i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mp make_pair\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int > vi;\ntypedef pair<int ,int > pii;\ntypedef vector<pii> vii;\nconst int inf=0x3f3f3f3f, maxn=2007, mod=1e9+7;\nconst ll linf=0x3f3f3f3f3f3f3f3fLL;\nint n;\nint a[maxn];\nbool e[maxn][maxn];\nvi e1[maxn];\nbool vis[maxn];\nint ind[maxn];\nbool book[maxn];\ninline int read(){\n   int s=0,w=1;\n   char ch=getchar();\n   while(ch<='0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}\n   while(ch>='0'&&ch<='9') s=(s<<1)+(s<<3)+ch-'0',ch=getchar();\n   return s*w;\n}\ninline void write(int x)\n{\n     if(x<0) putchar('-'),x=-x;\n     if(x>9) write(x/10);\n     putchar(x%10+'0');\n}\nvoid dfs(int u){\n//\tcout<<u<<endl;\n\tvis[u]=true;\n\tfor(int i=1;i<=n;i++){\n\t\tif(!vis[i]&&e[u][i]==true){\n//\t\t\tcout<<i<<endl;\n\t\t\te1[u].pb(i);\n\t\t\tind[i]++;\n\t\t\tdfs(i);\n\t\t}\n\t}\n}\n\nint main(){\n\tn=read();\n\tfor(int i=1;i<=n;i++){\n\t\ta[i]=read();\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=i+1;j<=n;j++){\n\t\t\tif(__gcd(a[i],a[j])!=1)e[i][j]=true,e[j][i]=true;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tif(!vis[i])dfs(i);\n//\t\tcout<<endl;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=n;j>=1;j--){\n\t\t\tif(!book[j]&&ind[j]==0){\n\t\t\t\tbook[j]=true;\n\t\t\t\tprintf(\"%d \",a[j]);\n\t\t\t\tfor(int k=0;k<e1[j].size();k++){\n\t\t\t\t\tind[e1[j][k]]--;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\n#define sf scanf\n#define pf printf\n#define pb push_back\n#define mp make_pair\n#define PI ( acos(-1.0) )\n#define mod 1000000007LL\n#define IN freopen(\"pieaters.in\",\"r\",stdin)\n#define OUT freopen(\"pieaters.out\",\"w\",stdout)\n#define FOR(i,a,b) for(i=a ; i<=b ; i++)\n#define DBG pf(\"Hi\\n\")\n#define i64 long long int\n#define eps (1e-8)\n#define xx first\n#define yy second\n#define ln 17\n#define off 2\n\nusing namespace __gnu_pbds;\nusing namespace std ;\n\ntypedef tree< i64, null_type, less<i64>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\ntypedef pair<i64, i64> pii;\n\n#define INF 2000000000\n#define alpha 26\n\n#define maxn 5010\n#define LOG 18\n\nvector <int> g[maxn] ;\nint last[maxn] , mini[maxn] ;\nint a[maxn] , vis[maxn] ;\n\nint gcd(int a, int b)\n{\n    if(b==0) return a ;\n    return gcd(b,a%b) ;\n}\nvector <int> cur ;\n\nvoid dfs(int u)\n{\n    vis[u] = 1 ;\n    cur.pb(u) ;\n    for( int v: g[u])\n    {\n        if( !vis[v] ) dfs(v) ;\n    }\n}\n\nint ans[maxn] ;\n\nint main()\n{\n    int n ;\n\n    scanf(\"%d\",&n) ;\n\n    for(int i=1 ; i<=n ; i++) scanf(\"%d\",&a[i]) ;\n\n    sort( a+1 , a+n+1 ) ;\n\n    for(int i=1 ; i<=n ; i++)\n    {\n        for(int j=i+1 ; j<=n ; j++)\n        {\n            if( gcd( a[i] , a[j] ) > 1 )\n            {\n                g[i].pb(j) ; g[j].pb(i) ;\n            }\n        }\n    }\n\n    for(int i=1 ; i<=n ; i++)\n    {\n        vector < vector <int> > vec ;\n\n        memset(vis,0,sizeof(vis)) ;\n\n        for(int j=1 ; j<i ; j++) vis[ ans[j] ] = 1 ;\n\n        for(int j=1 ; j<=n ; j++)\n        {\n            if( !vis[j] )\n            {\n                cur.clear() ;\n                dfs(j) ;\n                sort( cur.begin() , cur.end() ) ;\n                vec.pb(cur) ;\n            }\n        }\n\n        mini[i] = INF ;\n\n        multiset <int> ms ;\n\n        ms.insert( -INF ) ;\n\n        vector < pair<int,int> > eligible ;\n\n        for(int j=0 ; j<vec.size() ; j++)\n        {\n            ms.insert( a[vec[j][0]] ) ;\n        }\n\n        for(int j=0 ; j<vec.size() ; j++)\n        {\n            ms.erase( ms.find(a[vec[j][0]]) ) ;\n            for(int k=0 ; k<vec[j].size() ; k++)\n            {\n                int fl1 = 0 , fl2 = 0 ;\n\n                if( mini[ last[ vec[j][k] ] + 1 ] > a[ vec[j][k] ] ) fl1 = 1 ;\n\n                auto it = ms.end() ;\n                it-- ;\n\n                if( (*it) <= a[ vec[j][k] ] ) fl2 = 1 ;\n\n                if(fl1&fl2) eligible.pb( mp( a[vec[j][k] ] , vec[j][k] ) ) ;\n            }\n            ms.insert( a[vec[j][0]] ) ;\n        }\n        sort( eligible.begin() , eligible.end() ) ;\n\n        ans[i] = eligible[0].yy ;\n        mini[i] = a[ ans[i] ] ;\n        for(int j=i-1 ; j>=1 ; j-- ) mini[j] = min( a[ ans[j] ] , mini[j+1] ) ;\n        for(int j=0 ; j<g[ ans[i] ].size() ; j++) last[ g[ ans[i] ][j] ] = i ;\n\n     //   printf(\"%d\\n\",a[ans[i]]) ;\n    }\n\n    for(int i=1 ; i<=n ; i++) printf(\"%d \",a[ans[i]] ) ;\n    printf(\"\\n\") ;\n\n    return 0 ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <cstdio>\n#include <queue>\n#include <set>\n#include <map>\n#include <fstream>\n#include <cstdlib>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <numeric>\n\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\n#define for1(i, n) for (int i = 1; i <= (int)(n); ++i)\n#define ford(i, n) for (int i = (int)(n) - 1; i >= 0; --i)\n#define fore(i, a, b) for (int i = (int)(a); i <= (int)(b); ++i)\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector<vi> vvi;\ntypedef long long i64;\ntypedef vector<i64> vi64;\ntypedef vector<vi64> vvi64;\n\ntemplate<class T> bool uin(T &a, T b) { return a > b ? (a = b, true) : false; }\ntemplate<class T> bool uax(T &a, T b) { return a < b ? (a = b, true) : false; }\n\nint gcd(int a, int b) {\n    while (b) {\n        a %= b;\n        swap(a, b);\n    }\n    return a;\n}\n\nconst int maxn = 2100;\nint a[maxn], vis[maxn];\nvi e[maxn];\n\nstruct TComp {\n    bool operator()(int i, int j) {\n        return mp(a[i], i) < mp(a[j], j);\n    }\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.precision(10);\n    cout << fixed;\n#ifdef LOCAL_DEFINE\n    freopen(\"input.txt\", \"rt\", stdin);\n#endif\n\n    int n;\n    cin >> n;\n    forn(i, n) cin >> a[i];\n    sort(a, a + n);\n    forn(i, n) forn(j, n) if (i != j && gcd(a[i], a[j]) > 1) e[i].pb(j);\n\n    vi ans;\n\n    forn(i, n) {\n        if (vis[i]) continue;\n        set<int, TComp> q;\n        q.insert(i);\n        vis[i] = 1;\n        vi res;\n        while (!q.empty()) {\n            int v = *q.begin();\n            q.erase(v);\n            res.pb(a[v]);\n            for (int u: e[v]) {\n                if (!vis[u]) {\n                    q.insert(u);\n                    vis[u] = 1;\n                }\n            }\n        }\n\n        vi nans;\n        {\n        int i = 0, j = 0;\n        while (i < ans.size() || j < res.size()) {\n            if (j == res.size() || (i < ans.size() && ans[i] > res[j])) nans.pb(ans[i++]);\n            else nans.pb(res[j++]);\n        }\n        ans = nans;\n        }\n    }\n    for (int x: ans) cout << x << ' ';\n    cout << '\\n';\n    \n\n#ifdef LOCAL_DEFINE\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nconst int maxn = 2010;\nint n, a[maxn], degree[maxn];\nbool mp[maxn][maxn], vis[maxn];\nvector <int> edge[maxn];\nint gcd(int a, int b) { return b ? gcd(b, a % b) : a; }\n\nvoid dfs(int u) {\n    vis[u] = 1;\n    for(int i = 1; i <= n; i++) \n        if(mp[u][i] && !vis[i]) dfs(i), edge[u].push_back(i), degree[i]++;\n}\n\nvoid toposort() {\n    priority_queue <int> pq;\n    for(int i = 1; i <= n; i++)\n        if(degree[i] == 0) pq.push(i);\n    while(!pq.empty()) {\n        int u = pq.top();\n        pq.pop();\n        printf(\"%d \", a[u]);\n        for(int i = 0; i < (int)edge[u].size(); i++) pq.push(edge[u][i]);\n    }\n}\n\nint main()\n{\n    scanf(\"%d\", &n);\n    for(int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n    sort(a + 1, a + 1 + n);\n    for(int i = 1; i < n; i++)\n        for(int j = i + 1; j <= n; j++)\n            if(gcd(a[i], a[j]) != 1) mp[i][j] = mp[j][i] = 1;\n    for(int i = 1; i <= n; i++)\n        if(!vis[i]) dfs(i);\n    toposort();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <deque>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <vector>\n\n#define FOR(i,k,n) for (int (i)=(k); (i)<(n); ++(i))\n#define rep(i,n) FOR(i,0,n)\n#define pb push_back\n#define all(v) begin(v), end(v)\n#define debug(x) cerr<< #x <<\": \"<<x<<endl\n#define debug2(x,y) cerr<< #x <<\": \"<< x <<\", \"<< #y <<\": \"<< y <<endl\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll> > vvll;\ntemplate<class T> using vv=vector<vector< T > >;\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  vi a;\n  a.resize(n);\n  map<int, int> mp;\n  rep (i, n) {\n    scanf(\"%d\", &a[i]);\n    mp[a[i]] += 1;\n  }\n  for (auto p : mp) {\n    assert(p.second == 1);\n  }\n\n  rep (i, n-1) {\n    printf(\"%d \", a[i]);\n  }\n  printf(\"%d\\n\", a[n-1]);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\",\"inline\",\"-ffast-math\")\n#pragma GCC target(\"avx,sse2,sse3,sse4,mmx\")\n#include <bits/stdc++.h>\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/hash_policy.hpp>\nusing namespace __gnu_pbds;\nusing namespace std;\n\nint n,a[2010];\nvector<int> v[2010];\nbool vis[2010][2010],used[2010];\nvector<int> dp[2010];\n\ninline int gcd(int a,int b)\n{\n\tif(b==0) return a;\n\treturn gcd(b,a%b);\n}\n\ninline void dfs2(int u,int x)\n{\n\tvis[u][x]=1;\n\tfor(int i=0;i<v[x].size();i++) if(!used[v[x][i]]&&!vis[u][v[x][i]]){\n\t\tdfs2(u,v[x][i]);\n\t}\n}\n\ninline void dfs(int x)\n{\n\tused[x]=1;\n\tfor(int i=0;i<v[x].size();i++) if(!used[v[x][i]]&&!vis[x][v[x][i]]){\n\t\tdfs2(x,v[x][i]);\n\t\tdfs(v[x][i]);\n\t\tdp[x].push_back(v[x][i]);\n\t}\n\treverse(dp[x].begin(),dp[x].end());\n}\n\ninline void dfs3(int x)\n{\n\tif(x>0) cout<<a[x]<<\" \";\n\tfor(int i=0;i<dp[x].size();i++) dfs3(dp[x][i]);\n}\n\nsigned main()\n{\n\tios::sync_with_stdio(false);\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=i+1;j<=n;j++){\n\t\t\tif(gcd(a[i],a[j])>1){\n\t\t\t\tv[i].push_back(j);\n\t\t\t\tv[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tv[0].push_back(i);v[i].push_back(0);\n\t}\n\tdfs(0);\n\tdfs3(0);\n\tcout<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb push_back\n#define SZ(x) ((int)x.size())\n\nconst int N = 2010 ;\n\nint vis[N], ok[N][N], in[N], a[N] ;\nvector <int> g[N] ;\nint n ;\n\nvoid dfs(int rt) {\n\tvis[rt] = 1 ;\n\tfor (int i = 1; i <= n; i++)\n\tif (!vis[i] && ok[rt][i]) {\n\t\tin[i]++ ;\n\t\tg[rt].pb(i) ;\n\t\tdfs(i) ;\n\t}\n}\n\nvoid Top() {\n\tpriority_queue <int> q ;\n\tfor (int i = 1;  i <= n; i++) if (!in[i]) q.push(i) ;\n\twhile (!q.empty()) {\n\t\tint now = q.top() ;\n\t\tq.pop() ;\n\t\tcout << a[now] << \" \" ;\n\t\tfor (int i = 0; i < SZ(g[now]); i++) q.push(g[now][i]) ;\n\t}\n}\n\nsigned main(){\n\tscanf(\"%d\", &n) ;\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]) ;\n\tsort(a + 1, a + n + 1) ;\n\tfor (int i = 1; i <= n; i++)\n\tfor (int j = i + 1; j <= n; j++)\n\tif (__gcd(a[i], a[j]) != 1) ok[i][j] = ok[j][i] = 1 ;\n\tfor (int i = 1; i <= n; i++) if (!vis[i]) dfs(i) ;//连通块\n\tTop() ;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(2)\n// Happy TLE and WA every day!\n// by: zxb the vegetable chicken\n#include<bits/stdc++.h>\n#define mp\t\t\t\tmake_pair\n#define rep(i,n)\t\tfor(int i = 0; i < n; i++)\n#define foreach(i,c)\tfor(VAR(i, (c).begin()); i != (c).end(); ++i)\n#define BINF\t\t\t0x7fffffff\n#define INF\t\t\t\t0x3f3f3f3f\n#define LINF\t\t\t3223372036854775807\n#define END(s)\t\t\t{cout<<s; return 0;}\n#define CON(s)\t\t\t{cout<<s; continue;}\n#define BRE(s)\t\t\t{cout<<s; break;}\n#define pb\t\t\t\tpush_back\n//#define int\t\t\t\tlong long\n#define All(a)\t\t\ta.begin(), a.end()  //with A in CAPITAL!!!\n#define sz(a)\t\t\t(int)a.size()\n#define F\t\t\t\tfirst\n#define S\t\t\t\tsecond\n//#define usingFiles\nusing namespace std;\n\nconst int rp = 666666;\nconst bool debug = 1;\nconst bool I_good_vegetable_a = 1;\n\nint a[2020];\nint n;\nvector<int> v[2020];\nint ltksize;\nint mnstart;\nbool used[2020];\nvector<int> ltk[2020];\nint indx[2020];\nvector<int> ans;\nint cnt = 0;\nint num = 0;\n\nint count(int now){\n\tif(a[now] < a[mnstart]) mnstart = now;\n\tint ans = 1;\n\tused[now] = true;\n\trep(i, v[now].size()){\n\t\tif(!used[v[now][i]]) ans += count(v[now][i]);\n\t}\n\treturn ans;\n}\n\nvoid uncount(int now){\n\tused[now] = false;\n\trep(i, v[now].size()){\n\t\tif(used[v[now][i]]) uncount(v[now][i]);\n\t}\n}\n\nbool dfs(int now){\n\tused[now] = true;\n\tnum++;\n\tif(num == ltksize){\n\t\tltk[cnt].pb(now);\n\t\treturn 1;\n\t}\n\trep(i, v[now].size()){\n\t\tif(used[v[now][i]]) continue;\n\t\tif(dfs(v[now][i])){\n\t\t\tltk[cnt].pb(now);\n\t\t\treturn 1;\n\t\t}\n\t}\n\tused[now] = false;\n\treturn 0;\n}\n\nbool cmp1(int x, int y){\n\treturn a[x] < a[y];\n}\n\nbool cmp(pair<int, int> x, pair<int, int> y){\n\treturn x > y;\n}\n\nsigned main(){\n\tios::sync_with_stdio(false);\n\t#ifdef usingFiles\n\t\tfreopen(\"input.txt\", \"r\", stdin);\n\t\tfreopen(\"output.txt\", \"w\", stdout);\n\t#endif\n\tmemset(indx, 0, sizeof(indx));\n\tcin >> n;\n\trep(i, n) cin >> a[i];\n\trep(i, n){\n\t\tfor(int j = 0; j < i; j++){\n\t\t\tif(__gcd(a[i], a[j]) > 1){\n\t\t\t\tv[i].pb(j);\n\t\t\t\tv[j].pb(i);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, n){\n\t\tsort(v[i].begin(), v[i].end(), cmp1);\n\t}\n\trep(i, n){\n\t\tif(!used[i]){\n\t\t\tmnstart = i; \n\t\t\tltksize = count(i);\n\t\t\tuncount(i);\n\t\t\tnum = 0;\n\t\t\tdfs(mnstart);\n\t\t\treverse(ltk[cnt].begin(), ltk[cnt].end());\n\t\t\tcnt++;\n\t\t}\n\t}\n\twhile(1){\n\t\tint mx = -1, mxpos;\n\t\trep(i, cnt){\n\t\t\tif(indx[i] >= ltk[i].size()) continue;\n\t\t\tif(a[ltk[i][indx[i]]] > mx){\n\t\t\t\tmx = a[ltk[i][indx[i]]];\n\t\t\t\tmxpos = i;\n\t\t\t}\n\t\t}\n\t\tif(mx == -1) break;\n\t\tindx[mxpos]++;\n\t\tans.pb(mx);\n\t}\n\trep(i, ans.size()) cout << ans[i] << \" \";\n\tcout << endl;\n\treturn 0;\n}\n/*\n5\n1 2 3 4 5\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 2010;\nconst int NN = 2010;\n\nunsigned long long one = 1;\nunsigned long long g[N][NN];\nunsigned long long was[NN];\n\nbool alive[N];\nbool can_put[N];\n\nint a[N];\nint x[N];\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", a + i);\n  }\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      if (__gcd(a[i], a[j]) > 1) {\n        g[i][j >> 6] |= (one << (j & 63));\n        g[j][i >> 6] |= (one << (i & 63));\n      }\n    }\n  }\n  int nn = ((n - 1) >> 6) + 1;\n  for (int i = 0; i < n; i++) {\n    alive[i] = true;\n    can_put[i] = true;\n  }\n  for (int it = 0; it < n; it++) {\n    for (int i = 0; i < nn; i++) {\n      was[i] = 0;\n    }\n    for (int i = 0; i < n; i++) {\n      if (!alive[i]) {\n        was[i >> 6] |= (one << (i & 63));\n      }\n    }\n    int best = -1;\n    for (int i = 0; i < n; i++) {\n      if (was[i >> 6] & (one << (i & 63))) {\n        continue;\n      }\n      int b = 0, e = 1;\n      x[0] = i;\n      was[i >> 6] |= (one << (i & 63));\n      while (b < e) {\n        for (int j = 0; j < nn; j++) {\n          if ((g[x[b]][j] & was[j]) != g[x[b]][j]) {\n            for (int u = j * 64; u < (j + 1) * 64; u++) {\n              if (g[x[b]][u >> 6] & (one << (u & 63))) {\n                if (!(was[u >> 6] & (one << (u & 63)))) {\n                  was[u >> 6] |= (one << (u & 63));\n                  x[e++] = u;\n                }\n              }\n            }\n          }\n        }\n        b++;\n      }\n      int cur = -1;\n      for (int j = 0; j < e; j++) {\n        if (!can_put[x[j]]) {\n          continue;\n        }\n        if (cur == -1 || a[x[j]] < a[cur]) {\n          cur = x[j];\n        }\n      }\n      if (best == -1 || (cur != -1 && a[cur] > a[best])) {\n        best = cur;\n      }\n    }\n    if (it > 0) putchar(' ');\n    printf(\"%d\", a[best]);\n    alive[best] = false;\n    for (int i = 0; i < n; i++) {\n      if (!alive[i]) {\n        continue;\n      }\n      if (g[best][i >> 6] & (one << (i & 63))) {\n        can_put[i] = true;\n      } else {\n        if (a[best] < a[i]) {\n          can_put[i] = false;\n        }\n      }\n    }\n  }\n  printf(\"\\n\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\nint N, a[2001], apr[2001], G[2001][2001], q[2002], ue[2002], ref[2002], v[2002], L;\nstd::vector < int > Son[2001], Ans[2001];\nint gcd(int a, int b)\n{\n\tint r;\n\twhile (b)\n\t{\n\t\tr = a % b;\n\t\ta = b;\n\t\tb = r;\n\t}\n\treturn a;\n}\nstd::vector < int > merge(std::vector < int > a, std::vector < int > b)\n{\n\tstd::vector < int > O;\n\tO.reserve(a.size() + b.size());\n\tauto i = a.begin(), j = b.begin();\n\twhile (i != a.end() && j != b.end())\n\t\tO.push_back(*(*i > *j ? i : j)++);\n\twhile (i != a.end())\n\t\tO.push_back(*i++);\n\twhile (j != b.end())\n\t\tO.push_back(*j++);\n\treturn O;\n}\nint main()\n{\n\tdo\n\t{\n\t\tstatic int w[2001], L;\n\t\tscanf(\"%d\", &L);\n\t\tfor (int i = 1; i <= L; i++)\n\t\t\tscanf(\"%d\", w + i);\n\t\tstd::sort(w + 1, w + L + 1);\n\t\tfor (int i = 1; i <= L; i++)\n\t\t\tif (!N || a[N] != w[i])\n\t\t\t{\n\t\t\t\ta[++N] = w[i];\n\t\t\t\tapr[N] = 1;\n\t\t\t}\n\t\t\telse\n\t\t\t\tapr[N]++;\n\t}\n\twhile (0);\n\tfor (int i = 1; i < N; i++)\n\t\tfor (int j = i + 1; j <= N; j++)\n\t\t\tif (gcd(a[i], a[j]) != 1)\n\t\t\t\tG[i][j] = G[j][i] = 1;\n\tfor (int i = 1; i <= N; i++)\n\t\tG[0][i] = G[i][0] = 1;\n\tint D = 1;\n\tq[1] = 0;\n\tue[1] = 0;\n\tv[0] = 1;\n\tref[L = 1] = 0;\n\twhile (D)\n\t{\n\t\twhile (ue[D] <= N && (!G[q[D]][ue[D]] || v[ue[D]]))\n\t\t\tue[D]++;\n\t\tif (ue[D] <= N)\n\t\t{\n\t\t\tint To = ue[D]++;\n\t\t\tSon[q[D]].push_back(To);\n\t\t\tv[To] = 1;\n\t\t\tq[++D] = To;\n\t\t\tue[D] = 0;\n\t\t\tv[ref[++L] = To] = 1;\n\t\t}\n\t\telse\n\t\t\tD--;\n\t}\n\tfor (int i = L; i; i--)\n\t{\n\t\tint u = ref[i];\n\t\tstd::vector < int > TMP;\n\t\tfor (int j : Son[u])\n\t\t\tTMP = merge(TMP, Ans[j]);\n\t\tAns[u].resize(TMP.size() + 1);\n\t\tAns[u][0] = u;\n\t\tstd::copy(TMP.begin(), TMP.end(), Ans[u].begin() + 1);\n\t}\n\tfor (int i : Ans[0])\n\t\tfor (int T = apr[i]; T--; )\n\t\t\tprintf(\"%d \", a[i]);\n\tputs(\"\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/* --- author: dxm --- */\n#include<bits/stdc++.h>\n#pragma GCC optimize(2)\nusing namespace std;\n\n#define INF 1e9\n#define Inf 1e18\n#define rep(i,n) for(int (i)=0;(i)<n;i++)\n#define REP(i,n) for(int (i)=1;(i)<=n;i++)\n#define mp make_pair\n#define pb push_back\n#define fst first\n#define snd second\ntypedef long long ll;\ntypedef double db;\ntypedef long double ldb;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<long long,long long> pll;\n\nvoid qread(int &x){\n\tint neg=1;x=0;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9'){if(c=='-')neg=-1;c=getchar();}\n\twhile(c>='0'&&c<='9')x=10*x+c-'0',c=getchar();\n\tx*=neg;\n}\n\nconst int maxn=2005;\nint n,k;\nint a[maxn];\nvector<int>edge[maxn],child[maxn];\nbool vis[maxn];\n\nclass Array{\npublic:\n\tint len;\n\tint a[maxn];\n\tArray(){len=0;}\n\tArray operator + (const Array &o)const{\n\t\tArray res=*this;\n\t\trep(i,o.len)res.a[res.len++]=o.a[i];\n\t\treturn res;\n\t}\n\tArray operator * (const Array &o)const{\n\t\tArray res;\n\t\tint p1=0,p2=0;\n\t\twhile(p1<len||p2<o.len){\n\t\t\tif(p2==o.len||(p1<len&&a[p1]>o.a[p2]))res.a[res.len++]=a[p1++];\n\t\t\telse res.a[res.len++]=o.a[p2++];\n\t\t}\n\t\treturn res;\n\t}\n\tvoid print(){\n\t\tREP(i,len-1)printf(\"%d%c\",a[i],i==len-1?'\\n':' ');\n\t}\n}val[maxn];\n\nint gcd(int a,int b){\n\treturn !b?a:gcd(b,a%b);\n}\n\nvoid dfs(int x){\n\tvis[x]=true;\n\trep(i,edge[x].size()){\n\t\tif(!vis[edge[x][i]]){\n\t\t\tdfs(edge[x][i]);\n\t\t\tchild[x].pb(edge[x][i]);\n\t\t}\n\t}\n}\n\nvoid work(int x){\n\tArray tmp;\n\ttmp.len=1;\n\ttmp.a[0]=a[x];\n\trep(i,child[x].size()){\n\t\twork(child[x][i]);\n\t\tval[x]=val[x]*val[child[x][i]];\n\t}\n\tval[x]=tmp+val[x];\n}\n\nint main(){\n#ifdef FILE\n\tfreopen(\"FILE.in\",\"r\",stdin);\n\tfreopen(\"FILE.out\",\"w\",stdout);\n#endif\n\tscanf(\"%d\",&n);\n\tREP(i,n)scanf(\"%d\",&a[i]);\n\tsort(a+1,a+1+n);\n\tREP(i,n)for(int j=i;j<=n;j++)if(gcd(a[i],a[j])!=1){\n\t\tedge[i].pb(j);\n\t\tedge[j].pb(i);\n\t}\n\tREP(i,n)sort(edge[i].begin(),edge[i].end());\n\tREP(i,n)if(!vis[i])dfs(i),child[0].pb(i);\n\twork(0);\n\tval[0].print();\n#ifdef TIME\n\tprintf(\"Running Time = %d ms\\n\",int(clock()*1000.0/CLOCKS_PER_SEC));\n#endif\n\treturn 0;\n}\n\n/*\nInput:\n-----------------\nOutput:\n*/\n"
  },
  {
    "language": "C++",
    "code": "/*\n\t不互质的数两两连边\n\t先手的操作就是对边重定向\n\t后受到操作是找到最大的 topo 序\n*/\n#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#include <queue>\n#define N 2005\n\nusing namespace std;\n\nint n;\nint a[N], deg[N];\nbool gra[N][N], vis[N];\n\ninline int gcd(int u, int v) { return v ? gcd(v, u % v) : u; }\n\nvoid dfs(int u) {\n\tvis[u] = true;\n\tfor(int v = 1; v <= n; ++v) {\n\t\tif(vis[v] || !gra[u][v]) continue;\n\t\tgra[v][u] = false, ++deg[v];\n\t}\n\tfor(int v = 1; v <= n; ++v) {\n\t\tif(vis[v] || !gra[u][v]) continue;\n\t\tdfs(v);\n\t}\n\treturn;\n}\nvoid topo() {\n\tpriority_queue<int> hp;\n\tfor(int i = 1; i <= n; ++i)\n\t\tif(!deg[i]) hp.push(i);\n\twhile(!hp.empty()) {\n\t\tint u = hp.top(); hp.pop();\n\t\tprintf(\"%d \", a[u]);\n\t\tfor(int v = 1; v <= n; ++v)\n\t\t\tif(gra[u][v] && !--deg[v])\n\t\t\t\thp.push(v);\n\t}\n\tputchar('\\n');\n\treturn;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor(int i = 1; i <= n; ++i) scanf(\"%d\", &a[i]);\n\tsort(a + 1, a + 1 + n);\n\tfor(int i = 1; i <= n; ++i)\n\t\tfor(int j = i + 1; j <= n; ++j)\n\t\t\tgra[i][j] = gra[j][i] = (gcd(a[i], a[j]) != 1);\n\tfor(int i = 1; i <= n; ++i)\n\t\tif(!vis[i])\tdfs(i);\n\ttopo();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<vector>\n#include<queue>\n#include<map>\n#include<bitset>\n#include<set>\n#define N (2010)\n#define P ()\n#define M (N*N)\n#define inf (0x7f7f7f7f)\n#define rg register int\n#define Label puts(\"NAIVE\")\n#define spa print(' ')\n#define ent print('\\n')\n#define rand() (((rand())<<(15))^(rand()))\n#define file(s) freopen(s\".in\",\"r\",stdin),freopen(s\".out\",\"w\",stdout)\ntypedef long double ld;\ntypedef long long LL;\ntypedef unsigned long long ull;\nusing namespace std;\nnamespace fastIO1{\n\tinline char read(){\n\t\tstatic const int IN_LEN=1000000;\n\t\tstatic char buf[IN_LEN],*s,*t;\n\t\treturn (s==t?t=(s=buf)+fread(buf,1,IN_LEN,stdin),(s==t?-1:*s++):*s++);\n\t}\n\ttemplate<class T>\n\tinline void read(T &x){\n\t\tstatic bool iosig;\n\t\tstatic char c;\n\t\tfor(iosig=false,c=read();!isdigit(c);c=read()){\n\t\t\tif(c=='-')iosig=true;\n\t\t\tif(c==-1)return;\n\t\t}\n\t\tfor(x=0;isdigit(c);c=read())x=((x+(x<<2))<<1)+(c^'0');\n\t\tif(iosig)x=-x;\n\t}\n\tinline char readc(char &c){\n\t\tfor(c=read();!isalpha(c)&&!isdigit(c);c=read())\n\t\tif(c==-1)return 0;\n\t}\n\tconst int OUT_LEN = 10000000;\n\tchar obuf[OUT_LEN],*ooh=obuf;\n\tinline void print(char c) {\n\t\tif(ooh==obuf+OUT_LEN)fwrite(obuf,1,OUT_LEN,stdout),ooh=obuf;\n\t\t*ooh++=c;\n\t}\n\ttemplate<class T>\n\tinline void print(T x){\n\t\tstatic int buf[30],cnt;\n\t\tif(x==0)print('0');\n\t\telse{\n\t\t\tif(x<0)print('-'),x=-x;\n\t\t\tfor(cnt=0;x;x/=10)buf[++cnt]=x%10+48;\n\t\t\twhile(cnt)print((char)buf[cnt--]);\n\t\t}\n\t}\n\tinline void flush(){fwrite(obuf,1,ooh-obuf,stdout);}\n}\nnamespace fastIO2{\n\ttemplate<class T>\n\tinline void read(T &x){\n\t\tstatic bool iosig;\n\t\tstatic char c;\n\t\tfor(iosig=false,c=getchar();!isdigit(c);c=getchar()){\n\t\t\tif(c=='-')iosig=true;\n\t\t\tif(c==-1)return;\n\t\t}\n\t\tfor(x=0;isdigit(c);c=getchar())x=((x+(x<<2))<<1)+(c^'0');\n\t\tif(iosig)x=-x;\n\t}\n}\nusing namespace fastIO1;\nvector<int> G[N],T[N];\nint n,a[N],deg[N]; bool vis[N];\npriority_queue<int> Q;\nint gcd(int x,int y){return y?gcd(y,x%y):x;}\nvoid dfs(int u){\n\tvis[u]=1;\n\tfor(int i=0;i<T[u].size();i++){\n\t\tint v=T[u][i];\n\t\tif(!vis[v])G[u].push_back(v),deg[v]++,dfs(v);\n\t}\n}\nint main(){\n\tread(n);\n\tfor(int i=1;i<=n;i++)read(a[i]);\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++)\n\tfor(int j=1;j<=n;j++)\n\tif(i!=j&&gcd(a[i],a[j])!=1)T[i].push_back(j);\n\tfor(int i=1;i<=n;i++)if(!vis[i])dfs(i);\n\tfor(int i=1;i<=n;i++)if(!deg[i])Q.push(i);\n\twhile(!Q.empty()){\n\t\tint u=Q.top(); Q.pop(),printf(\"%d \",a[u]);\n\t\tfor(int i=0;i<G[u].size();i++){\n\t\t\tint v=G[u][i]; deg[v]--;\n\t\t\tif(!deg[v])Q.push(v);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define index(xs, x) (int)(lower_bound(all(xs), x) - xs.begin())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n\nint N;\nvector<int> C[(int)1e8+1];\nint A[2000];\nvector<int> R[2000];\nbool used[2000], dead[2000];\n\nvector<int> prime_list(int x) {\n  vector<int> ret;\n  for (int p=2; p*p<=x; p++) if (x%p == 0) {\n    while (x%p == 0) x /= p;\n    ret.pb(p);\n  }\n  if (x > 1) ret.pb(x);\n  return ret;\n}\nint num = 0;\nvoid dfs(int x);\nvoid dfs2(int p) {\n  vector<int> vs(C[p]);\n  C[p].clear();\n  for (int x : vs) dfs(x);\n}\nvoid dfs(int x) {\n  assert(!dead[x]);\n  if (used[x]) return;\n  num--;\n  used[x] = true;\n  for (int p : R[x]) dfs2(p);\n}\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> N;\n  vector<int> all;\n  rep(i, N) cin >> A[i];\n  sort(A, A+N);\n  rep(i, N) R[i] = prime_list(A[i]), all.insert(all.end(), all(R[i]));\n  sort(all(all)); uniq(all);\n\n  vector<int> seq;\n  rep(_, N) {\n    num = N-_;\n    for (int x : all) C[x].clear();\n    rep(i, N) if (!dead[i]) used[i] = false;\n    rep(i, N) if (!dead[i]) for (int p : R[i]) C[p].pb(i);\n    int m = -1;\n    rep(i, N) if (!dead[i]) {\n      dfs(i);\n      if (num == 0) {\n        m = i;\n        break;\n      }\n    }\n    assert(m != -1);\n    seq.pb(A[m]);\n    dead[m] = true;\n  }\n  rep(i, N) cout << seq[i] << \" \"; cout << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\n\nconst int INF = 1 << 30;\n\nvector< int > g[2000];\nint N, A[2000];\nbool v[2000];\nvector< int > ord;\n\nvoid dfs(int idx) {\n  v[idx] = true;\n  ord.emplace_back(A[idx]);\n  for(int i = 0; i < N; i++) {\n    if(v[i]) continue;\n    if(__gcd(A[i], A[idx]) == 1) continue;\n    dfs(i);\n  }\n}\n\nint main() {\n  cin >> N;\n  for(int i = 0; i < N; i++) cin >> A[i];\n  sort(A, A + N);\n  for(int i = 0; i < N; i++) {\n    if(!v[i]) dfs(i);\n  }\n  for(int i = 0; i < N; i++) {\n    for(int j = i + 1; j < N; j++) {\n      if(__gcd(ord[i], ord[j]) != 1) {\n        g[i].emplace_back(j);\n      }\n    }\n  }\n  vector< int > deg(N);\n  for(int i = 0; i < N; i++) for(int j : g[i]) ++deg[j];\n  priority_queue< pair< int, int > > que;\n  for(int i = 0; i < N; i++) if(deg[i] == 0) que.emplace(ord[i], i);\n  vector< int > ord2;\n  while(que.size()) {\n    auto p = que.top();\n    que.pop();\n    ord2.emplace_back(p.second);\n    for(auto to : g[p.second]) {\n      if(--deg[to] == 0) que.emplace(ord[to], to);\n    }\n  }\n  for(int i = 0; i < N; i++) cout << ord[ord2[i]] << \" \";\n  cout << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define all(x)  x.begin(),x.end()\n#define sz(x)   x.size()\n#define pb      push_back\n\nconst int   N   = 2e3 + 5;\n\ntypedef long long   ll;\ntypedef vector<int> vi;\n\nll  gcd(ll a,ll b)  {\n    return !a ? b : gcd(b % a,a);\n}\n\nvi  mer(vi a,vi b)  {\n    vi c;\n    int i = 0, j = 0;\n    while(i < sz(a) && j < sz(b))   {\n        if(a[i] < b[j]) c.pb(b[j++]);\n        else            c.pb(a[i++]);\n    }\n    while(i < sz(a))    c.pb(a[i++]);\n    while(j < sz(b))    c.pb(b[j++]);\n    return c;\n}\n\nvector<int> g[N], ar[N];\n\nll  a[N];\nint p[N], n;\n\nvoid dfs(int u) {\n    for(int v : g[u])\n        if(v != p[u] && p[v] < 0)   {\n            p[v] = u;\n            dfs(v);\n        }\n}\n\nvoid sol(int u) {\n    ar[u].push_back(u);\n    vector<int> res;\n    for(int v : g[u])\n        if(p[v] == u)   {\n            sol(v);\n            res = mer(res,ar[v]);\n        }\n    for(int i = 0 ; i < sz(res) ; ++i)\n        ar[u].pb(res[i]);\n}\n\nint main()  {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    cin >> n;\n\n    for(int i = 1 ; i <= n ; ++i)\n        cin >> a[i];\n\n    sort(a + 1,a + 1 + n);\n\n    int j = 1;\n    while(a[j] < 2) ++j;\n\n    vector<int> res(j - 1,1);\n\n    n -= (j - 1);\n    for(int i = 1 ; i <= n ; ++i)\n        a[i] = a[i + j - 1];\n\n    for(int i = 0 ; i <= n ; ++i)\n        for(int j = 0 ; j <= n ; ++j)    {\n            if(i == j || gcd(a[i],a[j]) < 2)\n                continue;\n            g[i].pb(j);\n        }\n\n    memset(p,-1,sizeof p);\n    p[0] = 0;\n    dfs(0);\n    sol(0);\n\n    for(int i = sz(ar[0]) - 1 ; i ; --i)\n        res.pb(a[ar[0][i]]);\n\n    reverse(all(res));\n    for(int i = 0 ; i < sz(res) ; ++i)\n        cout << res[i] << ' ';\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <math.h>\n#include <string.h>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <cassert>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <sstream>\n#include <functional>\n#include <iomanip>\n//#include <windows.h>  //Should be deleted when using AtCoder&POJ\nusing namespace std;\n\n#define ll long long\n#define pii pair<int,int>\n#define qi ios::sync_with_stdio(0)\n/**==Info==\n*Program:1\n*Problem:Rearranging\n*Date:2018-11-17\n*Algorithm:Teacher's Graph and greedy\n*Stats:WA*/\n\nbool debug=false;\n\ntemplate<typename T> ostream& operator<<(ostream& o,vector<T> vec){\n\to<<\"{\";\n\tfor(int i=0;i<vec.size();i++){\n\t\to<<vec[i]<<\" \";\n\t}\n\to<<\"}\";\n\treturn o;\n}\n\nint n;\nint a[2005];\n\nvector<int> nei[2005];\n\nint fa[2005];\n\nbool visit[2005];\n\nint getFa(int pos){\n\tif(fa[pos]==pos) return pos;\n\treturn fa[pos]=getFa(fa[pos]);\n}\n\nvoid Union(int x,int y){\n\tif(getFa(x)==getFa(y)){\n\t\treturn;\n\t}\n\t\n\tfa[getFa(x)]=getFa(y);\n}\n\nvector<int> path;\n\nvoid dfs(int pos){\n\tvisit[pos]=true;\n\tpath.push_back(pos);\n\tint mn=-1;\n\tfor(int i=0;i<nei[pos].size();i++){\n\t\tif(!visit[nei[pos][i]] && (mn==-1||a[nei[pos][i]]<a[nei[pos][mn]])){\n\t\t\tmn=i;\n\t\t}\n\t}\n\t\n\tif(mn==-1){\n\t\treturn;\n\t}\n\tdfs(nei[pos][mn]);\n}\n\nvoid solve(int x){\n\t//Solve the CC within <x>\n\tint f=getFa(x);\n\tvector<pii> pes;\n\tfor(int i=0;i<n;i++){\n\t\tif(fa[i]==f){\n\t\t\tpes.push_back(make_pair(a[i],i));\n\t\t}\n\t}\n\t\n\tsort(pes.begin(),pes.end());\n\t\n\tfor(int i=0;i<pes.size();i++){\n\t\tif(!visit[pes[i].second]){\n\t\t\tdfs(pes[i].second);\n\t\t}\n\t}\n}\n\nvector<vector<int>> shits;\n\nint main(int argc,char* argv[]){\n\t\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>a[i];\n\t}\n\t\n\tfor(int i=0;i<n;i++){\n\t\tfa[i]=i;\n\t}\n\t\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(__gcd(a[i],a[j])!=1){\n\t\t\t\tnei[i].push_back(j);\n\t\t\t\tUnion(i,j);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i=0;i<n;i++){\n\t\tif(!visit[i]){\n\t\t\tpath.clear();\n\t\t\tsolve(i);\n\t\t\t\n\t\t\tfor(int j=0;j<path.size();j++){\n\t\t\t\tpath[j]=a[path[j]];\n\t\t\t}\n\t\t\tshits.push_back(path);\n\t\t}\n\t}\n\n\t\n\tsort(shits.begin(),shits.end());\n\treverse(shits.begin(),shits.end());\n\t \n//\t cout<<shits<<endl;\n\tfor(vector<int> v:shits){\n\t\tfor(int p:v){\n\t\t\tcout<<p<<\" \";\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=2005;\nint a[N],vis[N];\nvector<int>e[N],g[N]; \npriority_queue<int>pq;\nvoid dfs(int v)\n{\n\tvis[v]=1;\n\tfor(int i=0;i<e[v].size();i++)\n\t{\n\t\tint u=e[v][i];\n\t\tif(vis[u])\n\t\t\tcontinue;\n\t\tg[v].push_back(u);\n\t\tdfs(u);\n\t}\n}\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++)\t\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(__gcd(a[i],a[j])>1)\n\t\t\t\te[i].push_back(j);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(!vis[i])\n\t\t{\n\t\t\tdfs(i);\n\t\t\tpq.push(i);\n\t\t}\n\t}\n\twhile(!pq.empty())\n\t{\n\t\tint k=pq.top();\n\t\tpq.pop();\n\t\tprintf(\"%d \",a[k]);\n\t\tfor(int i=0;i<g[k].size();i++)\n\t\t\tpq.push(g[k][i]);\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define loop(i,n) for(int i = 0;i < (n);i++)\n#define all(A) A.begin(),A.end()\n#define pb push_back\n#define mp make_pair\n#define sz(A) ((int)A.size())\ntypedef std::vector<int> vi;\ntypedef std::pair<int,int> pi;\ntypedef std::vector<pi> vp;\ntypedef long long ll;\n#define popcnt(x) __builtin_popcount(x)\n#define LSOne(x) ((x) & (-(x)))\n#define print(A,t) cerr << #A << \": \"; copy(all(A),ostream_iterator<t>(cerr,\" \" )); cerr << endl\n#define prArr(A,n,t)  cerr << #A << \": \"; copy(A,A + n,ostream_iterator<t>(cerr,\" \" )); cerr << endl\n#define PRESTDIO() cin.tie(0),cerr.tie(0),ios_base::sync_with_stdio(0)\n#define what_is(x) cerr << #x << \" is \" << x << endl\n#define bit_lg(x) (assert(x > 0),__builtin_ffsll(x) - 1)\nconst double PI = acos(-1);\ntemplate<class A,class B>\nstd::ostream& operator << (std::ostream& st,const std::pair<A,B> p) {\n\tst << \"(\" << p.first << \", \" << p.second << \")\";\n\treturn st;\n}\n#define tc() int T; scanf(\"%d\",&T); for(int t = 1;t <= T;t++)\nusing namespace std;\n\n\nmap<int,int> pot;\n\nvoid insert(int x,vi & V) {\n\tstatic vi aux;\n\taux.clear();\n\twhile(!V.empty() && __gcd(x,V.back()) == 1) {\n\t\taux.push_back(V.back());\n\t\tV.pop_back();\n\t}\n\tV.push_back(x);\n\twhile(!aux.empty()) {\n\t\tV.push_back(aux.back());\n\t\taux.pop_back();\n\t}\n}\n\nint main(){\n#ifdef HOME\n\tfreopen(\"in.in\", \"r\", stdin);\n#endif\n\tint n; scanf(\"%d\",&n);\n\tvi V(n);\n\tloop(i,n)scanf(\"%d\",&V[i]);\n\tsort(all(V));\n\tvi res,aux;\n\tloop(t,n){\n\t\tpot.clear();\n\t\tfor(int y : V) pot[y] = 0;\n\t\tloop(i,t) {\n\t\t\tint x = res[i];\n\t\t\tfor(int y : V)\n\t\t\t\tif(__gcd(x,y) != 1)\n\t\t\t\t\tpot[y] = i + 1;\n\t\t}\n\t\tint x = -1,p = -1;\n\t\tfor(auto q : pot)\n\t\t\tif(q.second > p) {\n\t\t\t\tp = q.second;\n\t\t\t\tx = q.first;\n\t\t\t}\n\t\tinsert(x,res);\n\t\tpot.erase(x);\n\t\tV.erase(find(all(V),x));\n\t}\n\tfor(int i = 0;i < n;i++) printf(\"%d%c\",res[i],\" \\n\"[i==n-1]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<cmath>\n#include<queue>\n#include<bitset>\n#include<string>\n#include<cstdio>\n#include<cctype>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n#include<sstream>\n#include<numeric>\n#include<iostream>\n#include<algorithm>\n#include<functional>\n\n#define For(i,x,y) for (int i=x;i<y;i++)\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\n\ntypedef long long ll;\ntypedef double db;\ntypedef vector<int> Vi;\ntypedef pair<int,int> pii;\n\nint IN(){\n\tint c,f,x;\n\twhile (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');\n\twhile (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;\n}\n\nconst int N=200000+19;\nconst int oo=(1<<30)-1;\n\nstruct Edge{\n\tint y,nxt;\n} E[N];\nmap<int,int> M;\nmultiset<int> S;\nint A[N],las[N],col[N],mn[N],pre[N],suf[N],res[N],f[N],id[N];\nint n,x,tot,cnt,c,mx,num,m;\nVi V[N];\n\nvoid Link(int x,int y){\n\tE[cnt]=(Edge){y,las[x]};las[x]=cnt++;\n\tE[cnt]=(Edge){x,las[y]};las[y]=cnt++;\n}\nvoid Init(int n,int m){\n\tfor (int i=2;i*i<=n;i++)\n\t\tif (n%i==0){\n\t\t\tif (!M.count(i)) M[i]=++tot;\n\t\t\tV[m].pb(M[i]);\n\t\t\twhile (n%i==0) n/=i;\n\t\t}\n\tif (n>1){\n\t\tif (!M.count(n)) M[n]=++tot;\n\t\tV[m].pb(M[n]);\n\t}\n}\nvoid dfs(int x,int c){\n\tif (col[x]) return;\n\tcol[x]=c;\n\tif (x<=*id) mn[c]=min(mn[c],A[id[x]]);\n\tfor (int i=las[x];~i;i=E[i].nxt) dfs(E[i].y,c);\n}\nint work(){\n\tFor(i,1,tot+1){\n\t\tlas[i]=-1;\n\t\tcol[i]=0;\n\t}\n\tcnt=0;c=0;\n\tFor(i,1,*id+1){\n\t\tfor (int x:V[id[i]]) Link(i,x);\n\t}\n\tFor(i,1,*id+1)\n\t\tif (!col[i]){\n\t\t\tmn[++c]=oo;\n\t\t\tdfs(i,c);\n\t\t}\n\tpre[0]=suf[c+1]=0;\n\tfor (int i=1;i<=c;i++) pre[i]=max(pre[i-1],mn[i]);\n\tfor (int i=c;i>=1;i--) suf[i]=max(suf[i+1],mn[i]);\n\tFor(i,1,*id+1)\n\t\tif (A[id[i]]>max(pre[col[i]-1],suf[col[i]+1])){\n\t\t\tif (A[id[i]]<f[id[i]]) return id[i];\n\t\t}\n\tassert(0);\n}\n\nint main(){\n\tmemset(las,-1,sizeof(las));\n\ttot=n=IN();\n\tFor(i,1,n+1) A[i]=IN();\n\tsort(A+1,A+n+1);\n\tFor(i,1,n+1){\n\t\tInit(A[i],i);\n\t\tS.insert(i);\n\t\tf[i]=oo;\n\t}\n\tA[0]=oo;\n\tFor(t,1,n+1){\n\t\t*id=0;\n\t\tfor (int i:S) id[++*id]=i;\n\t\tx=work();\n\t\tS.erase(S.find(x));\n\t\tres[t]=A[x];\n\t\tFor(i,1,n+1){\n\t\t\tif (__gcd(A[i],A[x])>1) f[i]=oo;else f[i]=min(f[i],A[x]);\n\t\t}\n\t}\n\tFor(i,1,n+1) printf(\"%d \",res[i]);\n\tputs(\"\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 2005\nusing namespace std;\nint gcd(int a,int b)\n{\n    if(!b)return a;\n    return gcd(b,a%b);\n}\nint mp[N][N];\nint n,a[N],du[N],vis[N];\nvector<int>v[N];\nvoid ds(int x)\n{\n    vis[x]=1;\n    for(int i=1;i<=n;i++)\n    {\n        if(!vis[i]&&mp[x][i])\n        {\n            v[x].push_back(i);\n            du[i]++;\n            ds(i);\n        }\n    }\n    return ;\n}\npriority_queue<int>q;\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++)\n    {\n        scanf(\"%d\",&a[i]);\n    }\n    sort(a+1,a+n+1);\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<i;j++)\n            if(gcd(a[i],a[j])!=1)mp[i][j]=mp[j][i]=1;\n    for(int i=1;i<=n;i++)if(!vis[i])ds(i);\n    for(int i=1;i<=n;i++)if(!du[i])q.push(i);\n    for(int i=1;i<=n;i++)\n    {\n        int tmp=q.top();q.pop();\n        printf(\"%d \",a[tmp]);\n        for(int j=0;j<v[tmp].size();j++)\n        {\n            du[v[tmp][j]]--;\n            if(!du[v[tmp][j]])q.push(v[tmp][j]);\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nstruct ha{\n\tint a[2005],tot;\n}c[2005];\nint gcd(int a,int b){\n\tint t;\n\twhile(b){\n\t\tt=a;a=b;b=t%a;\n\t}\n\treturn a;\n}\nint n,a[2005],b[2005][2005],tot[2005],now;\npair<int,int> g[2005];\nint fst[2005],lst[2005],cnt=0,e[4000005];\nbool vis[2005];\nvoid dfs(int k){\n\tvis[k]=1;c[now].a[++c[now].tot]=a[k];\n\tfor(int i=fst[k];i<=lst[k];i++) if(!vis[e[i]])\n\t\tdfs(e[i]);\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++){\n\t\tfst[i]=cnt+1;\n\t\tfor(int p=1;p<=n;p++) if(p!=i){\n\t\t\tif(gcd(a[i],a[p])>1) e[++cnt]=p;\n\t\t}\n\t\tlst[i]=cnt;\n\t\tsort(e+fst[i],e+lst[i]+1);\n\t}\n\tfor(int i=1;i<=n;i++) if(!vis[i]){\n\t\tnow++;\n\t\tdfs(i);\n\t\tg[now]=make_pair(c[now].a[1],now);\n\t}\n\tsort(g+1,g+now+1);\n\tfor(int i=now;i;i--){\n\t\tint id=g[i].second;\n\t\tfor(int p=1;p<=c[id].tot;p++)\n\t\t\tprintf(\"%d \",c[id].a[p]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define X first\n#define Y second\n\nint gcd(int a,int b) {return b?gcd(b,a%b):a;}\n\nconst int maxn=4000010;\n\nint n,times,a[maxn],dfn[maxn],deg[maxn];\nint tote,FIR[maxn],TO[maxn],NEXT[maxn];\nint vis[maxn];\npriority_queue<pair<int,int> > q;\n\nvoid addedge(int u,int v)\n{\n\tTO[++tote]=v;\n\tNEXT[tote]=FIR[u];\n\tFIR[u]=tote;\n}\n\nint search(int u)\n{\n\tint Ans=u;\n\tvis[u]=1;\n\tfor (int p=FIR[u];p;p=NEXT[p])\n\t{\n\t\tint v=TO[p];\n\t\tif (vis[v]) continue;\n\t\tint tmp=search(v);\n\t\tAns=a[Ans]<a[tmp]?Ans:tmp;\n\t}\n\treturn Ans;\n}\n\nvoid dfs(int u)\n{\n\tvis[u]=2;\n\tdfn[u]=++times;\n\tvector<pair<int,int> > son;\n\tson.clear();\n\tfor (int p=FIR[u];p;p=NEXT[p])\n\t\tson.push_back(make_pair(a[TO[p]],TO[p]));\n\tsort(son.begin(),son.end());\n\tfor (int i=0;i<(int)son.size();i++)\n\t\tif (vis[son[i].Y]!=2) dfs(son[i].Y);\n}\n\nint main()\n{\n#ifdef h10\n\tfreopen(\"E.in\",\"r\",stdin);\n\tfreopen(\"E.out\",\"w\",stdout);\n#endif\n\tint i,j;\n\tscanf(\"%d\",&n);\n\tfor (i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tfor (i=1;i<=n;i++)\n\tfor (j=i+1;j<=n;j++)\n\t\tif (gcd(a[i],a[j])!=1)\n\t\t\taddedge(i,j),addedge(j,i);\n\n\tvector<pair<int,int> > root;\n\tfor (i=1;i<=n;i++)\n\t\tif (!vis[i])\n\t\t{\n\t\t\tint tmp=search(i);\n\t\t\troot.push_back(make_pair(a[tmp],tmp));\n\t\t}\n\tsort(root.begin(),root.end());\n\tfor (i=0;i<(int)root.size();i++) dfs(root[i].Y);\n\n\ttote=0;\n\tmemset(FIR,0,sizeof(FIR));\n\tfor (i=1;i<=n;i++)\n\tfor (j=1;j<=n;j++)\n\t\tif (gcd(a[i],a[j])!=1&&dfn[i]<dfn[j])\n\t\t\taddedge(i,j),deg[j]++;\n\n\tfor (i=1;i<=n;i++)\n\t\tif (!deg[i]) q.push(make_pair(a[i],i));\n\twhile (!q.empty())\n\t{\n\t\tpair<int,int> u=q.top(); q.pop();\n\t\tprintf(\"%d \",u.X);\n\t\tfor (int p=FIR[u.Y];p;p=NEXT[p])\n\t\t{\n\t\t\tint v=TO[p];\n\t\t\tif (!(--deg[v])) q.push(make_pair(a[v],v));\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define MAXN (2010)\n\nint n, a[MAXN];\nbool vis[MAXN];\nstd::vector<int> vec[MAXN];\nstd::vector<int> seq[MAXN];\n\nvoid merge(std::vector<int> &u, std::vector<int> &v){\n\tstd::vector<int> tmp;\n\tint i = 0, j = 0, nu = u.size(), nv = v.size();\n\tfor( ; i < nu && j < nv; ){\n\t\tif(u[i] > v[j]){\n\t\t\ttmp.push_back(u[i ++]);\n\t\t}\n\t\telse{\n\t\t\ttmp.push_back(v[j ++]);\n\t\t}\n\t}\n\twhile(i < nu) tmp.push_back(u[i ++]);\n\twhile(j < nv) tmp.push_back(v[j ++]);\n\tu = tmp;\n}\n\nbool cmp(const int &u, const int &v){\n\treturn a[u] < a[v];\n}\n\nvoid dfs(int u){\n\tvis[u] = true;\n\tstd::sort(vec[u].begin(), vec[u].end(), cmp);\n\tfor(auto v : vec[u]){\n\t\tif(vis[v]) continue;\n\t\tdfs(v);\n\t\tmerge(seq[u], seq[v]);\n\t}\n\tseq[u].insert(seq[u].begin(), a[u]);\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\tfor(int i = 1; i <= n; ++ i){\n\t\tscanf(\"%d\", a + i);\n\t}\n\tstd::sort(a + 1, n + a + 1);\n\tfor(int i = 1; i <= n; ++ i){\n\t\tfor(int j = 1; j < i; ++ j){\n\t\t\tif(std::__gcd(a[i], a[j]) != 1){\n\t\t\t\tvec[i].push_back(j);\n\t\t\t\tvec[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tstd::vector<int> ans;\n\tfor(int i = 1; i <= n; ++ i){\n\t\tif(!vis[i]){\n\t\t\tdfs(i);\n\t\t\tmerge(ans, seq[i]);\n\t\t}\n\t}\n\tfor(auto p : ans){\n\t\tprintf(\"%d \", p);\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cassert>\n#include <complex>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <cstdlib>\n#include <cstring>\n#include <iomanip>\n#include <numeric>\n#include <sstream>\n#include <ctime>\n#include <cctype>\n#include <set>\n#include <map>\n#include <queue>\n#include <bitset>\n#include <deque>\n#include <stack>\n#include <memory.h>\nusing namespace std;\ntypedef long long ll;\n#define mp make_pair\n#define pb push_back\nvector<int> nei[2005],nei2[2005];\nint num[2005];\nbool lol[2005];\nvector<int> ltks[2005];\nint ans[2005];\ninline void dfs(int now,int ltk){\n\tif(lol[now]){\n\t\treturn;\n\t}\n\tlol[now]=1;\n\tltks[ltk].pb(now);\n\tfor(int i=0;i<nei[now].size();i++){\n\t\tif(!lol[nei[now][i]]){\n\t\t\tdfs(nei[now][i],ltk);\n\t\t\tnei2[now].pb(nei[now][i]);\n\t\t}\t\n\t}\n}\nint n;\ninline ll gcd(ll a,ll b){\n\twhile(a&&b){\n    \tif(a>b){\n    \t\ta%=b;\n\t\t}\n    \telse{\n    \t\tb%=a;\n\t\t}\n\t}\n\treturn a+b;\n}\nint main(){\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>num[i];\n\t}\n\tsort(num,num+n);\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(gcd(num[i],num[j])!=1){\n\t\t\t\tnei[i].pb(j);\n\t\t\t}\n\t\t}\n\t}\n\tint cntltk=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(!lol[i]){\n\t\t\tdfs(i,cntltk++);\n\t\t}\n\t}\n\tpriority_queue<pair<int,int> > pq;\n\tfor(int i=0;i<cntltk;i++){\n\t\tpq.push(mp(num[ltks[i][0]],ltks[i][0]));\n\t}\n\tint nn=0;\n\twhile(pq.size()){\n\t\tpair<int,int> nnaa=pq.top();\n\t\tpq.pop();\n\t\tint nnum=nnaa.first,x=nnaa.second;\n\t\tans[nn++]=nnum;\n\t\tfor(int i=0;i<nei2[x].size();i++){\n\t\t\tpq.push(mp(num[nei2[x][i]],nei2[x][i]));\n\t\t}\n\t}\n\tfor(int i=0;i<nn;i++){\n\t\tcout<<ans[i]<<' ';\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(2)\n// Happy TLE and WA every day!\n// by: zxb the vegetable chicken\n#include<bits/stdc++.h>\n#define mp\t\t\t\tmake_pair\n#define rep(i,n)\t\tfor(int i = 0; i < n; i++)\n#define foreach(i,c)\tfor(VAR(i, (c).begin()); i != (c).end(); ++i)\n#define BINF\t\t\t0x7fffffff\n#define INF\t\t\t\t0x3f3f3f3f\n#define LINF\t\t\t3223372036854775807\n#define END(s)\t\t\t{cout<<s; return 0;}\n#define CON(s)\t\t\t{cout<<s; continue;}\n#define BRE(s)\t\t\t{cout<<s; break;}\n#define pb\t\t\t\tpush_back\n//#define int\t\t\t\tlong long\n#define All(a)\t\t\ta.begin(), a.end()  //with A in CAPITAL!!!\n#define sz(a)\t\t\t(int)a.size()\n#define F\t\t\t\tfirst\n#define S\t\t\t\tsecond\n//#define usingFiles\nusing namespace std;\n\nconst int rp = 666666;\nconst bool debug = 1;\nconst bool I_good_vegetable_a = 1;\n\nint a[2020];\nint n;\nvector<int> v[2020];\nint ltksize;\nbool used[2020];\nvector<int> ltk[2020];\nvector<pair<int, int> > ans;\nint cnt = 0;\nint num = 0;\n\nint count(int now){\n\tint ans = 1;\n\tused[now] = true;\n\trep(i, v[now].size()){\n\t\tif(!used[v[now][i]]) ans += count(v[now][i]);\n\t}\n\treturn ans;\n}\n\nvoid uncount(int now){\n\tused[now] = false;\n\trep(i, v[now].size()){\n\t\tif(used[v[now][i]]) uncount(v[now][i]);\n\t}\n}\n\nbool dfs(int now){\n\tused[now] = true;\n\tnum++;\n\tif(num == ltksize){\n\t\tltk[cnt].pb(now);\n\t\treturn 1;\n\t}\n\trep(i, v[now].size()){\n\t\tif(used[v[now][i]]) continue;\n\t\tif(dfs(v[now][i])){\n\t\t\tltk[cnt].pb(now);\n\t\t\treturn 1;\n\t\t}\n\t}\n\tused[now] = false;\n\treturn 0;\n}\n\nbool cmp1(int x, int y){\n\treturn a[x] < a[y];\n}\n\nbool cmp(pair<int, int> x, pair<int, int> y){\n\treturn x > y;\n}\n\nsigned main(){\n\tios::sync_with_stdio(false);\n\t#ifdef usingFiles\n\t\tfreopen(\"input.txt\", \"r\", stdin);\n\t\tfreopen(\"output.txt\", \"w\", stdout);\n\t#endif\n\tcin >> n;\n\trep(i, n) cin >> a[i];\n\trep(i, n){\n\t\tfor(int j = 0; j < i; j++){\n\t\t\tif(__gcd(a[i], a[j]) > 1){\n\t\t\t\tv[i].pb(j);\n\t\t\t\tv[j].pb(i);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, n){\n\t\tsort(v[i].begin(), v[i].end(), cmp1);\n\t}\n\trep(i, n){\n\t\tif(!used[i]){\n\t\t\tltksize = count(i);\n\t\t\tuncount(i);\n\t\t\tnum = 0;\n\t\t\tdfs(i);\n\t\t\treverse(ltk[cnt].begin(), ltk[cnt].end());\n\t\t\tans.pb(mp(a[ltk[cnt][0]], cnt));\n\t\t\tcnt++;\n\t\t}\n\t}\n\tsort(ans.begin(), ans.end(), cmp);\n\trep(i, ans.size()){\n\t\trep(j, ltk[ans[i].S].size()){\n\t\t\tcout << a[ltk[ans[i].S][j]] << \" \"; \n\t\t}\n\t}\n\tcout << endl;\n\treturn 0;\n}\n/*\n5\n1 2 3 4 5\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct nd{int x,y;friend bool operator < (nd a,nd b){if(a.x==b.x)return a.y<b.y;return a.x<b.x;}};\nconst int N=5100;\nint a[N],n,m,c[N][N],dfn[N],fir[N],nxt[N],to[N],cnt,in[N];\nmap<int,int>l;\nvoid add(int u,int v)\n{\n\tto[++cnt]=v,nxt[cnt]=fir[u],fir[u]=cnt;\n}\nvoid dfs(int x)\n{\n\tdfn[x]=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(!c[x][i])continue;\n\t\tif(dfn[i])continue;\n\t\tdfn[i]=1;\n\t\tdfs(i);add(x,i);in[i]++;\n\t}\n}\nint main()\n{freopen(\"rearranging.in\",\"r\",stdin);\n\tfreopen(\"rearranging.out\",\"w\",stdout);\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=i+1;j<=n;j++)\n\t\tif(__gcd(a[i],a[j])!=1)\n\t\tc[i][j]=c[j][i]=1;l[a[i]]=i;\n\t}\n\tfor(int i=1;i<=n;i++)\n\tif(!dfn[i])dfs(i);\n\tpriority_queue<nd>q;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(!in[i])q.push({a[i],i});\n\t}\n\twhile(!q.empty())\n\t{\n\t\tint x=q.top().y;q.pop();\n\t\tfor(int i=fir[x];i;i=nxt[i])\n\t\t{\n\t\t\tin[to[i]]--;if(in[to[i]]==0)q.push({a[to[i]],to[i]});\n\t\t}printf(\"%d \",a[x]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nconst int MAXN=2005;\nint n,a[MAXN];\nint rd[MAXN];\nint vis[MAXN];\nstruct edge\n{\n\tint v,nxt;\n\tedge(){}\n\tedge(int vv,int nn)\n\t{\n\t\tv=vv,nxt=nn;\n\t}\n}E[MAXN*MAXN];\nint w[MAXN],ncnt=0;\nstruct node\n{\n\tint id,val;\n\tnode(){}\n\tnode(int ii,int vv)\n\t{\n\t\tid=ii,val=vv;\n\t}\n\tbool operator < (const node &a)const \n\t{\n\t\treturn a.val>val;\n\t}\n};\npriority_queue<node>q;\nint gcd(int a,int b)\n{\n\treturn b==0?a:gcd(b,a%b);\n}\nvoid addedge(int u,int v)\n{\n\tncnt++;\n\tE[ncnt]=edge(v,w[u]);\n\tw[u]=ncnt;\n}\nvoid dfs(int u)\n{\n\tvis[u]=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(!vis[i]&&gcd(a[u],a[i])!=1)\n\t\t{\n\t\t\tdfs(i);\n\t\t\trd[i]++;\n\t\t\taddedge(u,i);\n\t\t}\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++)\n\t\tif(!vis[i])\n\t\t\tdfs(i);\n\tfor(int i=1;i<=n;i++)\n\t\tif(rd[i]==0)\n\t\t\tq.push(node(i,a[i]));\n\twhile(!q.empty())\n\t{\n\t\tnode k=q.top();\n\t\tq.pop();\n\t\tprintf(\"%d \",k.val);\n\t\tfor(int i=w[k.id];i;i=E[i].nxt)\n\t\t{\n\t\t\tint v=E[i].v;\n\t\t\trd[v]--;\n\t\t\tif(rd[v]==0)\n\t\t\t\tq.push(node(v,a[v]));\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\nusing namespace std;\n\nint gcd(int a, int b) {\n\tif(a > b) swap(a, b);\n\treturn (a == 0) ? b : gcd(b%a, a);\n}\n\nvoid DFS(int R, auto & G, auto & comp, auto & live, int comp_id) {\n\tcomp[R] = comp_id;\n\tfor(auto v : G[R]) if(live[v] && comp[v] == -1)\n\t\tDFS(v, G, comp, live, comp_id);\n}\n\nint main() {\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tint N;\n\tcin >> N;\n\tvector<int> A(N);\n\tfor(int i = 0; i < N; i++) cin >> A[i];\n\tsort(begin(A), end(A));\n\tvector<int> ans(N);\n\tvector<char> live(N, 1);\n\n\tmap<int, vector<int> > prime_adj;\n\tfor(int i = 0; i < N; i++) {\n\t\tint a = A[i];\n\t\tfor(int j = 2; j*j <= a; j++) if(a%j == 0) {\n\t\t\tif(prime_adj.find(j) == end(prime_adj)) prime_adj[j] = {};\n\t\t\tprime_adj[j].push_back(i);\n\t\t\twhile(a%j == 0) a /= j;\n\t\t}\n\t\tif(a > 1) prime_adj[a].push_back(i);\n\t}\n\tint P = 0;\n\tfor(auto & p : prime_adj) if((int)(p.second.size()) >= 2) P++;\n\tlive.resize(N+P, 1);\n\tvector< vector<int> > G(N+P);\n\tP = 0;\n\tfor(auto & p : prime_adj) if((int)(p.second.size()) >= 2) {\n\t\tfor(auto x : p.second) {\n\t\t\tG[N+P].push_back(x);\n\t\t\tG[x].push_back(N+P);\n\t\t}\n\t\tP++;\n\t}\n\tvector<int> comp(N+P, -1);\n\tfor(int i = 0; i < N+P; i++) if(comp[i] == -1) DFS(i, G, comp, live, i);\n\n\tvector<int> last_nc(N, -1), last_lt(N, -1);\n\tfor(int i = 0; i < N; i++) {\n\t\tvector<char> ok(N);\n\t\tfor(int j = 0; j < N; j++) ok[j] = (live[j] && last_lt[j] <= last_nc[j]);\n\t\tvector<char> comp_state(N, 0);\n\t\tfor(int j = 0; j < N; j++) if(live[j]) comp_state[comp[j]] = 1;\n\t\tint num_rm_comp = 0, num_comp = 0;\n\t\tfor(int j = 0; j < N; j++) if(comp_state[j]) num_comp++;\n\n\t\tint this_id = -1;\n\t\tfor(int j = 0; j < N; j++) if(ok[j]) {\n\t\t\tif(num_rm_comp+comp_state[comp[j]] < num_comp) {\n\t\t\t\tif(comp_state[comp[j]] == 1) num_rm_comp++;\n\t\t\t\tcomp_state[comp[j]] = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis_id = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tans[i] = A[this_id];\n\t\tlive[this_id] = 0;\n\t\tfor(int j = 0; j < N; j++) if(live[j]) {\n\t\t\tif(gcd(A[j], A[this_id]) > 1) last_nc[j] = i;\n\t\t\tif(A[j] > A[this_id]) last_lt[j] = i;\n\t\t}\n\t\tint c0 = comp[this_id];\n\t\tfor(int j = 0; j < N+P; j++) if(comp[j] == c0) comp[j] = -1;\n\t\tfor(int j = 0; j < N+P; j++) if(comp[j] == -1 && live[j]) DFS(j, G, comp, live, j);\n\t}\n\n\tfor(int i = 0; i < N; i++) cout << ans[i] << ((i == N-1) ? \"\\n\" : \" \");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define fst first\n#define snd second\n#define mkp make_pair\ntypedef pair<int, int> pii;\nconst int MAXN = 2010;\n\ninline int read() {\n\tint x = 0, f = 1;\n\tchar ch = getchar();\n\tfor(; !isdigit(ch); ch = getchar()) if(ch=='-') f=-1;\n\tfor(; isdigit(ch); ch = getchar()) x = (x*10)+(ch^48);\n\treturn x * f;\n}\n\nint gcd(int a, int b) {\n\treturn b ? gcd(b, a % b) : a;\n}\n\nint n, a[MAXN], indeg[MAXN];\nint st[MAXN], to[MAXN*MAXN];\nint nxt[MAXN*MAXN], e;\ninline void Add(int u, int v) {\n\tto[++e] = v, nxt[e] = st[u];\n\tst[u] = e, indeg[v]++;\n}\n\nbool vis[MAXN];\nint dep[MAXN];\nvector<int> G[MAXN];\n\nbool cmp(const int &x, const int &y) {\n\treturn a[x] < a[y];\n}\n\ninline void dfs(int u, int fa) {\n\tvis[u] = true;\n\tint i;\n\tsort(G[u].begin(), G[u].end(), cmp);\n\tfor(i = 0; i < (int)G[u].size(); i++) {\n\t\tint v = G[u][i];\n\t\tif(v == fa) continue;\n\t\tif(vis[v]) {\n\t\t\tif(dep[v] > dep[u]) Add(u, v);\n\t\t\tcontinue;\n\t\t}\n\t\tdep[v] = dep[u]+1;\n\t\tAdd(u, v), dfs(v, u);\n\t}\n}\n\npriority_queue<pii> q;\n\nint main() {\n\n\tint i, j;\n\tn = read();\n\tgenerate(a+1, a+n+1, read);\n\tsort(a+1, a+n+1);\n\n\tfor(i = 1; i <= n; i++) \n\t\tfor(j = 1; j < i; j++) \n\t\t\tif(gcd(a[i], a[j]) != 1) \n\t\t\t\tG[i].push_back(j), G[j].push_back(i);\n\n\tfor(i = 1; i <= n; i++) \n\t\tif(!vis[i]) dfs(i, 0);\n\n\tfor(i = 1; i <= n; i++)\n\t\tif(!indeg[i]) q.push(mkp(a[i], i));\n\t\n\twhile(!q.empty()) {\n\t\tint u = q.top().snd;\n\t\tprintf(\"%d \", a[u]);\n\t\tq.pop();\n\t\tfor(i = st[u]; i; i = nxt[i]) {\n\t\t\tint v = to[i];\n\t\t\tindeg[v]--;\n\t\t\tif(!indeg[v]) q.push(mkp(a[v], v));\n\t\t}\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int nmax = 2009;\n\nint boss[nmax] , head[nmax] , now[nmax] , used[nmax] , in[nmax] , x[nmax] , blocked[nmax];\nvector < int > g[nmax] , oneway[nmax];\nint i , j , n , first , last , bst;\n\nint gcd(int a , int b)\n{\n    if (b == 0) return a;\n    return gcd(b , a % b);\n}\n\nvoid dfs(int act)\n{\n    used[act] = 1;\n\n    for (int i = 0 ; i < g[act].size() ; ++i)\n    {\n        int nxt = g[act][i];\n        if (used[nxt]) continue;\n        dfs(nxt);\n    }\n}\n\nvoid dfs2(int act)\n{\n    now[act] = 1;\n\n    for (int i = 0 ; i < g[act].size() ; ++i)\n    {\n        int nxt = g[act][i];\n        if (now[nxt]) continue;\n        if (blocked[nxt]) continue;\n        dfs2(nxt);\n    }\n}\n\nvoid readData()\n{\n    cin >> n;\n    for (i = 1 ; i <= n ; ++i)\n    cin >> x[i];\n\n    for (i = 1 ; i <= n ; ++i)\n    for (j = i + 1 ; j <= n ; ++j)\n    if (2 <= gcd(x[i] , x[j]))\n    {\n        g[i].push_back(j);\n        g[j].push_back(i);\n    }\n\n    first = 1 , last = 0;\n    for (i = 1 ; i <= n ; ++i)\n    {\n        if (used[i]) continue;\n        dfs(i);\n        head[++last] = i , boss[last] = 0;\n    }\n    x[0] = 1000000000;\n}\n\nint walk(int act , int forced)\n{\n    int ret = 0;\n    now[act] = 1;\n\n    for (int i = 0 ; i < g[act].size() ; ++i)\n    {\n        int nxt = g[act][i];\n        if (blocked[nxt]) continue;\n        if (now[nxt]) continue;\n        int t = walk(nxt , forced);\n        if (x[t] < x[ret]) ret = t;\n    }\n\n    if (forced == 0) return (x[act] < x[ret]) ? act : ret;\n    else\n    {\n        if (2 <= gcd(x[act] , forced)) return (x[act] < x[ret]) ? act : ret;\n        else return ret;\n    }\n}\n\nvoid solve(int k)\n{\n    vector < int > sons;\n    int root = head[k];\n    memset(now , 0 , sizeof(now));\n\n    int forced = (boss[k]) ? x[boss[k]] : 0;\n    root = walk(root , forced);\n\n    for (int i = 0 ; i < g[root].size() ; ++i)\n    {\n        int nxt = g[root][i];\n        if (blocked[nxt]) continue;\n        sons.push_back(nxt);\n    }\n    blocked[root] = 1;\n\n    memset(now , 0 , sizeof(now));\n    for (int i = 0 ; i < sons.size() ; ++i)\n    {\n        int nxt = sons[i];\n        oneway[root].push_back(nxt);\n        in[nxt]++;\n\n        if (now[nxt]) continue;\n        dfs2(nxt);\n\n        head[++last] = nxt;\n        boss[last] = root;\n    }\n}\n\nint main()\n{\n\n//freopen(\"test.in\" , \"r\" , stdin);\n//freopen(\"test.out\" , \"w\" , stdout);\n\nreadData();\nwhile (first <= last) solve(first++);\n\nx[0] = -1000000000;\nmemset(used , 0 , sizeof(used));\nfor (i = 1 ; i <= n ; ++i)\n{\n    bst = 0;\n    for (j = 1 ; j <= n ; ++j)\n    if (used[j] == 0 && in[j] == 0 && x[bst] < x[j]) bst = j;\n\n    used[bst] = 1;\n    cout << x[bst] << \" \";\n\n    for (j = 0 ; j < oneway[bst].size() ; ++j)\n    in[oneway[bst][j]]--;\n}\n\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#pragma GCC optimize(2)\n#define int long long\n//#include<ext/pb_ds/assoc_container.hpp>\n#pragma comment(linker, \"/STACK:16000000\")\n//#define map gp_hash_table\n#define PI 3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679\nusing namespace std;\n//using namespace __gnu_pbds;\nconst int inf=0x3f3f3f3f;\nconst long long inf2=0x3f3f3f3f3f3f3f3f;\nconst double eps=1e-6;\nconst int mod=1000000007;\nvector<int> g[2222],g2[2222];\nint n;\npair<int,int> a[2002];\nint itr[2002];\nvector<vector<int> > vec;\nbool used[2002];\nvector<int> cur;\nvoid dfs(int x){\n\tused[x]=true;\n\tfor(int i=0;i<g[x].size();i++){\n\t\tif(used[g[x][i]])continue;\n\t\tg2[x].push_back(g[x][i]);\n\t\tdfs(g[x][i]);\n\t\treturn;\n\t}\n}\nbool ok(){\n\tfor(int i=0;i<vec.size();i++)if(itr[i]!=vec[i].size())return false;\n\treturn true;\n}\npriority_queue<int>q;\nsigned main(){\n\tvec.clear();\n\tios::sync_with_stdio(0);\n\tcin>>n;\n\tfor(int i=1;i<=n;i++)cin>>a[i].first,a[i].second=i;\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++)for(int j=1;j<=n;j++)if(__gcd(a[i].first,a[j].first)!=1){\n\t\tg[i].push_back(j);\n\t}\n\tfor(int i=1;i<=n;i++)sort(g[i].begin(),g[i].end());\n\tfor(int i=1;i<=n;i++)if(!used[i]){\n\t\tdfs(i);\n\t\tq.push(i);\n\t}\n\tmemset(used,false,sizeof(used));\n\twhile(q.size()){\n\t\tint x=q.top();q.pop();\n\t\tused[x]=false;\n\t\tfor(int i=0;i<g2[x].size();i++)q.push(g2[x][i]);\n\t\tcout<<a[x].first<<\" \";\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#define MN 2000\n#define ull unsigned long long\nusing namespace std;\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nstruct Bitset\n{\n\tull\ts[32];\n\tvoid Reset(){memset(s,0,sizeof(s));}\n\tBitset operator &(const Bitset&y)\n\t{\n\t\tBitset c;\n\t\tfor(int j=0;j<32;++j) c.s[j]=s[j]&y.s[j];\n\t\treturn c;\t\n\t}\n\tvoid Mod(int y){s[y>>6]^=1ULL<<(y&63);}\n\tint lowbit()\n\t{\n\t\tfor(int j=0;j<32;++j) if(s[j])\n\t\t{\n\t\t\tull x=s[j];int pos=j*64;\n\t\t\twhile(!(x&255)) x>>=8,pos+=8;\n\t\t\tfor(int k=0;k<8;++k) if(x&(1<<k)) return pos+k;\n\t\t}\n\t\treturn -1;\t\n\t}\n}b[MN+5],to,Left;\ninline int gcd(int x,int y){return y?gcd(y,x%y):x;}\nint n,a[MN+5],head[MN+5],cnt=0,mark[MN+5],res,vis[MN+5],used[MN+5];\nstruct edge{int to,next;}e[MN*MN*2+5];\ninline void ins(int f,int t)\n{\n\te[++cnt]=(edge){t,head[f]};head[f]=cnt;b[f].Mod(t);\n\te[++cnt]=(edge){f,head[t]};head[t]=cnt;b[t].Mod(f);\n}\nvoid Mark(int x)\n{\n\tmark[x]=0;to.Mod(x);\n\tint low=(to&b[x]).lowbit();\n\twhile(low!=-1)\n\t{\n\t\tMark(low);\n\t\tlow=(to&b[x]).lowbit();\n\t}\n}\nvoid dfs(int x,int v)\n{\n\tvis[x]=v;if(mark[x]==v-1&&a[x]<a[res]) res=x;\n\tfor(int i=head[x];i;i=e[i].next)\n\t\tif(vis[e[i].to]!=v&&!used[e[i].to]) dfs(e[i].to,v); \n}\nint main()\n{\n\tn=read();a[0]=int(1e9);\n\tfor(int i=1;i<=n;++i) a[i]=read(),Left.Mod(i);\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=i+1;j<=n;++j) \n\t\t\tif(gcd(a[i],a[j])>1) ins(i,j);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tint mx=0,from=0;\n\t\tfor(int j=1;j<=n;++j)\n\t\t\tif(!used[j]&&vis[j]!=i) res=0,dfs(j,i),a[res]>mx?(mx=a[res],from=res):0;\n\t\tprintf(\"%d \",mx);used[from]=1;Left.Mod(from);\n\t\tfor(int j=1;j<=n;++j) mark[j]=i;\n\t\tto=Left;Mark(from);\n\t\tfor(int j=head[from];j;j=e[j].next) mark[e[j].to]=i;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\nusing namespace std;\ntypedef pair<int,int>pii;\nint n,cnt;\nint a[2010],w[2010],rd[2010];\npii e[4000010];\nbool vis[2010];\nvector<int>G[2010];\ninline int gcd(int x,int y){\n    if(y==0) return x;\n    return gcd(y,x%y);\n}\nvoid add(int u,int v){\n    e[++cnt]=mp(v,w[u]);\n    w[u]=cnt;\n}\nvoid dfs(int x){\n    vis[x]=1;\n    for(auto to:G[x])if(!vis[to]){\n        add(x,to);\n        rd[to]++;\n        dfs(to);\n    }\n}\npriority_queue<pii,vector<pii>,greater<pii> >pq;\nint main(){\n    cin>>n;\n    for(int i=1;i<=n;i++)cin>>a[i];\n    sort(a+1,a+n+1);\n    for(int i=1;i<n;i++)\n        for(int j=i+1;j<=n;j++)\n            if(gcd(a[i],a[j])>1){\n                G[i].pb(j);\n                G[j].pb(i);\n            }\n    for(int i=1;i<=n;i++)if(!vis[i])dfs(i);\n    for(int i=1;i<=n;i++)if(!rd[i])pq.push(mp(a[i],i));\n    while(!pq.empty()){\n        pii curr=pq.top();\n        pq.pop();\n        cout<<curr.first<<' ';\n        for(int i=w[curr.second];i;i=e[i].second){\n            int v=e[i].first;\n            rd[v]--;\n            if(!rd[v])pq.push(mp(a[v],v));\n        }\n    }\n    puts(\"\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nconst int MAXN=2005;\nint gcd(int a,int b)\n{\n\tif(b==0)\n\t\treturn a;\n\treturn gcd(b,a%b);\n}\nint lcm(int a,int b)\n{\n\treturn a*b/gcd(a,b);\n}\n\nint n,A[MAXN];\nbool vis[MAXN];\nvector<int> adj[MAXN],adj2[MAXN];\nint deg[MAXN],ans[MAXN];\npriority_queue<int> Q;\n\nvoid dfs(int u)\n{\n\tvis[u]=true;\n\tfor(int i=0;i<(int)adj[u].size();i++)\n\t{\n\t\tint v=adj[u][i];\n\t\tif(vis[v])\n\t\t\tcontinue;\n\t\tadj2[u].push_back(v);\n\t\tdeg[v]++;\n\t\tdfs(v);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&A[i]);\n\tsort(A+1,A+n+1);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(i!=j&&gcd(A[i],A[j])>1)\n\t\t\t\tadj[i].push_back(j);\n\tfor(int i=1;i<=n;i++)\n\t\tif(!vis[i])\n\t\t\tdfs(i);\n\t\n\tfor(int i=1;i<=n;i++)\n\t\tif(deg[i]==0)\n\t\t\tQ.push(i);\n\tint it=0;\n\twhile(!Q.empty())\n\t{\n\t\tint u=Q.top();\n\t\tans[++it]=A[u];\n\t\tQ.pop();\n\t\tfor(int i=0;i<(int)adj2[u].size();i++)\n\t\t{\n\t\t\tint v=adj2[u][i];\n\t\t\tdeg[v]--;\n\t\t\tif(deg[v]==0)\n\t\t\t\tQ.push(v);\n\t\t}\n\t}\n\tfor(int i=1;i<n;i++)\n\t\tprintf(\"%d \",ans[i]);\n\tprintf(\"%d\\n\",ans[n]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"Ofast\")\n#include <iostream>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <set>\n#include <queue>\n#define rep(x, a, b) for(int x = (a); x <= (b); ++x)\n#define rop(x, a, b) for(int x = (a); x < (b); ++x)\n#define per(x, a, b) for(int x = (a); x >= (b); --x)\nusing namespace std;\ntypedef long long LL;\ntypedef double DB;\npriority_queue<int> PQ;\nint a[2005], rd[2005];\nstruct graph {\n\tset<int> S[2005];\n\tint vs[2005];\n\tvoid push(int x, int y) {\n\t\tS[x].insert(y);\n\t}\n\tvoid dfs(int nw) {\n//\t\tcout << nw << endl;\n\t\tvs[nw] = 1;\n\t\tauto IT = S[nw].begin();\n\t\twhile(IT != S[nw].end()) {\n//\t\t\tcout << a[nw] << \"0 \" << a[(*IT)] << endl; \n\t\t\t++rd[*IT];\n\t\t\tS[*IT].erase(nw); \n\t\t\t++IT;\n\t\t}\n\t\tIT = S[nw].begin();\n\t\twhile(IT != S[nw].end()) {\n\t\t\tif(vs[*IT]) {++IT; continue;}\n\t\t\tdfs(*IT);\n\t\t\t++IT;\n\t\t}\n\t}\n\tvoid tuopu() {\n\t\tPQ.push(0);\n\t\twhile(PQ.size()) {\n\t\t\tint nw = PQ.top();\n\t\t\tif(nw) printf(\"%d \", a[nw]);\n\t\t\tPQ.pop();\n\t\t\tauto IT = S[nw].begin();\n\t\t\twhile(IT != S[nw].end()) {\n\t\t\t\t--rd[*IT];\n\t\t\t\tif(rd[*IT] == 0) PQ.push(*IT);\n\t\t\t\t++IT;\n\t\t\t}\n\t\t}\n\t}\n}G;\nint n;\nint main() {\n\tscanf(\"%d\", &n);\n\trep(i, 1, n) scanf(\"%d\", &a[i]);\n  sort(a + 1, a + 1 + n);\n\trep(i, 1, n) rep(j, 1, n) if(i != j && __gcd(a[i], a[j]) != 1) G.push(i, j); \n\trep(i, 1, n) G.push(0, i), G.push(i, 0);\n\tG.dfs(0);\n\tG.tuopu();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint gcd(int a,int b){return b==0?a:gcd(b,a%b);}\nconst int N=2005;\nint n,t,s,v,id,a[N],d[N],vis[N];\nset<int>S;\nvector<int>f[N],e[N];\nvoid dfs(int v){\n\tvis[v]=1;d[++t]=a[v];\n\tint i,u;\n\tfor(i=0;i<e[v].size();i++){\n\t\tu=e[v][i];\n\t\tif(vis[u]==0)dfs(u);\n\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++)for(int j=1;j<i;j++)if(gcd(a[i],a[j])!=1){\n\t\te[i].push_back(j);\n\t\te[j].push_back(i);\n\t}\n\tfor(int i=1;i<=n;i++)sort(e[i].begin(),e[i].end());\n\tfor(int i=1;i<=n;i++)if(vis[i]==0){vis[i]=1;S.insert(i);dfs(i);}\n//\tfor(int i=1;i<=n;i++)printf(\"%d \",d[i]);printf(\"\\n\");\n\tfor(int i=1;i<=n;i++){\n\t\ts=sqrt(t=d[i]);\n\t\tfor(int j=2;j<=s;j++)if(t%j==0){\n\t\t\twhile(t%j==0)t/=j;\n\t\t\tf[i].push_back(j);\n\t\t}\n\t\tif(t!=1)f[i].push_back(t);\n\t}\n\tfor(int i=1;i<=n;i++)a[i]=i;\n\tfor(int i=1;i<=n;i++){\n\t\ts=d[a[i]];id=i;\n\t\tS.clear();\n\t\tfor(int j=i;j<=n;j++){\n\t\t\tt=(d[a[j]]>s);\n\t\t\tfor(int l=0;l<f[a[j]].size();l++){\n\t\t\t\tv=f[a[j]][l];\n\t\t\t\tif(S.find(v)==S.end())S.insert(v);\n\t\t\t\telse t=0;\n\t\t\t}\n\t\t\tif(t==1){s=d[a[j]];id=j;}\n\t\t}\n\t\tfor(int j=id-1;j>=i;j--)swap(a[j],a[j+1]);\n//\t\tfor(int i=1;i<=n;i++)printf(\"%d \",d[a[i]]);printf(\"\\n\");\n\t}\n\tfor(int i=1;i<=n;i++)printf(\"%d \",d[a[i]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\ncat <<EOF >mistaken-paste\n*/\n\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <time.h>\n\n#define BIG 2000000007\n#define VERYBIG 2000000000000007LL\n\n#define MOD 1000000007\n#define FOD  998244353\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\n#define N_MAX 1000000\n#define M_MAX 200000\n\n#ifdef __cplusplus\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <array>\n\nusing std::queue;\nusing std::priority_queue;\nusing std::stack;\nusing std::tuple;\nusing std::set;\nusing std::map;\nusing std::vector;\nusing std::greater;\nusing std::pair;\nusing std::string;\n\n#endif\n\ntypedef struct {\n\tint32_t a;\n\tint32_t b;\n} hw;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n} hwll;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n\tsll c;\n} hwllc;\n\ntypedef struct {\n\thwll a;\n\thwll b;\n} linell;\n\null n, m;\null h, w;\null k;\null q;\nsll va, vb, vc, vd, ve, vf;\null ua, ub, uc, ud, ue, uf;\nlong double vra, vrb, vrc;\ndouble vda, vdb, vdc;\nchar ch, dh;\n\null umin (ull x, ull y) {\n\treturn (x < y) ? x : y;\n}\n\null umax (ull x, ull y) {\n\treturn (x > y) ? x : y;\n}\n\nsll smin (sll x, sll y) {\n\treturn (x < y) ? x : y;\n}\n\nsll smax (sll x, sll y) {\n\treturn (x > y) ? x : y;\n}\n\null gcd (ull x, ull y) {\n\tif (x < y) {\n\t\treturn gcd(y, x);\n\t} else if (y == 0) {\n\t\treturn x;\n\t} else {\n\t\treturn gcd(y, x % y);\n\t}\n}\n\null bitpow (ull a, ull x, ull modulo) {\n\tull result = 1;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tresult *= a;\n\t\t\tresult %= modulo;\n\t\t}\n\t\tx /= 2;\n\t\ta = (a * a) % modulo;\n\t}\n\treturn result;\n}\n\null divide (ull a, ull b, ull modulo) {\n\treturn (a * bitpow(b, modulo - 2, modulo)) % modulo;\n}\n\null udiff (ull a, ull b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nsll sdiff (sll a, sll b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nint bitcount (ull n) {\n\tint result = 0;\n\twhile (n) {\n\t\tif (n & 1) result++;\n\t\tn /= 2;\n\t}\n\treturn result;\n}\n\n// double distance (sll x1, sll y1, sll x2, sll y2) {\n// \tdouble xdist2, ydist2, origindist, dist;\n\n// \txdist2 = (x1 - x2) * (x1 - x2);\n// \tydist2 = (y1 - y2) * (y1 - y2);\n// \treturn sqrt(xdist2 + ydist2);\n// }\n\nint32_t pullcomp (const void *left, const void *right) {\n\tull l = *(ull*)left;\n\tull r = *(ull*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t psllcomp (const void *left, const void *right) {\n\tsll l = *(sll*)left;\n\tsll r = *(sll*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t pcharcomp (const void *left, const void *right) {\n\tchar l = *(char*)left;\n\tchar r = *(char*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t pdoublecomp (const void *left, const void *right) {\n\tdouble l = *(double*)left;\n\tdouble r = *(double*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t pstrcomp (const void *left, const void *right) {\n\tchar* l = *(char**)left;\n\tchar* r = *(char**)right;\n\n\treturn strcmp(l, r);\n}\n\nint32_t phwllABcomp (const void *left, const void *right) {\n\thwll l = *(hwll*)left;\n\thwll r = *(hwll*)right;\n\tif (l.a < r.a) {\n\t\treturn -1;\n\t}\n\tif (l.a > r.a) {\n\t\treturn +1;\n\t}\n\tif (l.b < r.b) {\n\t\treturn -1;\n\t}\n\tif (l.b > r.b) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t phwllREVcomp (const void *left, const void *right) {\n\thwll l = *(hwll*)left;\n\thwll r = *(hwll*)right;\n\tif (l.b < r.b) {\n\t\treturn -1;\n\t}\n\tif (l.b > r.b) {\n\t\treturn +1;\n\t}\n\tif (l.a < r.a) {\n\t\treturn -1;\n\t}\n\tif (l.a > r.a) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t ptriplecomp (const void *left, const void *right) {\n\thwllc l = *(hwllc*)left;\n\thwllc r = *(hwllc*)right;\n\n\tif (l.a < r.a) {\n\t\treturn -1;\n\t}\n\tif (l.a > r.a) {\n\t\treturn +1;\n\t}\n\tif (l.b < r.b) {\n\t\treturn -1;\n\t}\n\tif (l.b > r.b) {\n\t\treturn +1;\n\t}\n\tif (l.c < r.c) {\n\t\treturn -1;\n\t}\n\tif (l.c > r.c) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nbool isinrange (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right);\n}\n\nbool isinrange_soft (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right) || (left >= x && x >= right);\n}\n\nsll a[N_MAX];\n// sll a[3001][3001];\nsll b[N_MAX];\n// sll b[3001][3001];\nsll c[N_MAX];\n// sll d[N_MAX];\n// sll e[N_MAX];\nchar s[N_MAX + 1];\n// char s[3010][3010];\nchar t[N_MAX + 1];\n// char t[3010][3010];\n// hwll xy[N_MAX];\n// sll table[1000][1000];\n\nset<ull> g[2002];\nbool iscoprime[2002][2002];\n\null iswatched[2002];\null labels[2002];\null id = 0;\nvoid toggle (ull v, ull x, ull id) {\n\tif (iswatched[v] == x) return;\n\n\tiswatched[v] = x;\n\tlabels[v] = id;\n\tfor (ull u : g[v]) {\n\t\ttoggle(u, x, id);\n\t}\n}\n\ntypedef pair<ull, ull> P;\nvector<ull> merge(vector<vector<ull>> x) {\n\tvector<ull> v;\n\n\tull curr[x.size()];\n\tpriority_queue<P, vector<P> > que;\n\tfor (ull i = 0; i < x.size(); i++) {\n\t\tcurr[i] = 0;\n\t\tque.push(P(x[i][0], i));\n\t}\n\twhile (!que.empty()) {\n\t\tP p = que.top();\n\t\tque.pop();\n\n\t\tv.push_back(p.first);\n\t\tull i = p.second;\n\t\tif (++curr[i] < x[i].size()) {\n\t\t\tque.push(P(x[i][curr[i]], i));\n\t\t}\n\t}\n\n\treturn v;\n}\n\nvector<ull> func (ull v) {\n\tvector<ull> r;\n\t\n\tset<ull> s = g[v];\n\tpriority_queue<ull, vector<ull>, greater<ull> > que;\n\ttoggle(v, 0, id++);\n\tfor (ull u : s) {\n\t\tg[u].erase(v);\n\t\tque.push(u);\n\t}\n\n\tvector<vector<ull>> vs;\n\twhile (!que.empty()) {\n\t\tull u = que.top();\n\t\tque.pop();\n\t\tif (iswatched[u]) continue;\n\n\t\ttoggle(u, 1, id++);\n\t\tvs.push_back(func(u));\n\t}\n\tiswatched[v] = 1;\n\n\tr = merge(vs);\n\tr.insert(r.begin(), v);\n\n\treturn r;\n}\n\null solve () {\n\tsll i, j, ki, li;\n\tull result = 0;\n\t// sll result = 0;\n\tdouble dresult = 0;\n\t// ull maybe = 0;\n\tsll maybe = 0;\n\t// ull sum = 0;\n\tsll sum = 0;\n\tsll item;\n\tull *dpcell;\n\n\tqsort(a, n, sizeof(ull), pullcomp);\n\n\tfor (i = 0; i < n; i++) {\n\t\tfor (j = 0; j < n; j++) {\n\t\t\tif (i != j && gcd(a[i], a[j]) > 1) {\n\t\t\t\tg[i].insert(j);\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<vector<ull>> finals;\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (iswatched[i]) continue;\n\n\t\ttoggle(i, 1, id++);\n\t\tfinals.push_back(func(i));\n\t\t// for (j = 0; j < finals[finals.size() - 1].size(); j++) printf(\"%llu \", finals[finals.size() - 1][j]);\n\t\t// \tputs(\"\");\n\t\t// fflush(stdout);\n\t}\n\tvector<ull> r = merge(finals);\n\tfor (i = 0; i < n; i++) {\n\t\tprintf(\"%llu%c\", a[r[i]], (i == n - 1 ? '\\n' : ' '));\n\t}\n\n\t// printf(\"%lld\\n\", result);\n\t// printf(\"%.15lf\\n\", dresult);\n\t// puts(s);\n\n\treturn 0;\n\n\tsuccess:\n\t// puts(\"YES\");\n\tputs(\"Yes\");\n\t// printf(\"%llu\\n\", result);\n\t// puts(\"0\");\n\t// puts(\"Yay!\");\n\treturn 0;\n\n\tfail:\n\t// puts(\"NO\");\n\tputs(\"No\");\n\t// puts(\"0\");\n\t// puts(\"-1\");\n\t// puts(\"-1 -1 -1\");\n\t// puts(\":(\");\n\treturn 1;\n}\n\nint32_t main (void) {\n\tint32_t i, j;\n\tint32_t x, y;\n\n\tscanf(\"%llu\", &n, &m);\n\t// scanf(\"%llu\", &k, &n, &m);\n\t// scanf(\"%llu%llu\", &h, &w);\n\t// scanf(\"%lld\", &va, &vb, &vc, &vd);\n\t// scanf(\"%llu%llu\", &ua, &ub, &uc, &ud);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%s\", s);\n\t// scanf(\"%s\", t);\n\tfor (i = 0; i < n; i++) {\n\t\t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t\tscanf(\"%lld\", &a[i]);\n\t\t// scanf(\"%lld\", &b[i]);\n\t\t// scanf(\"%lld\", &c[i]);\n\t\t// scanf(\"%lld\", &d[i]);\n\t\t// a[i]--;\n\t\t// b[i]--;\n\t\t// c[i]--;\n\t}\n\t// scanf(\"%llu\", &m, &k);\n\t// scanf(\"%llu\", &q);\n\t// for (i = 0; i < n; i++) {\n\t// \tscanf(\"%lld\", &b[i]);\n\t// }\n\n\t// for (i = 0; i < h; i++) {\n\t// \tfor (j = 0; j < w; j++) {\n\t// \t\tscanf(\"%llu\", &table[i][j]);\n\t// \t}\n\t// }\n\t// for (i = 0; i < h; i++) {\n\t// \tscanf(\"%s\", &s[i]);\n\t// }\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Ho-kago Tea Time\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define fst first\n#define snd second\n#define SZ(u) ((int) (u).size())\n#define ALL(u) (u).begin(), (u).end()\n\ninline void proc_status()\n{\n\tifstream t(\"/proc/self/status\");\n\tcerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>()) << endl;\n}\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntemplate<typename T> inline T read()\n{\n\tregister T sum(0), fg(1);\n\tregister char ch(getchar());\n\tfor(; !isdigit(ch); ch = getchar()) if(ch == '-') fg = -1;\n\tfor(;  isdigit(ch); ch = getchar()) sum = sum * 10 - '0' + ch;\n\treturn sum * fg;\n}\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\n\nconst int MAXN = (int) 2e3;\n\nint n;\n\nint a[MAXN + 5];\n\ninline void input()\n{\n\tn = read<int>();\n\tfor(int i = 1; i <= n; ++i) a[i] = read<int>();\n}\n\nvector<int> adj[MAXN + 5];\n\nint vis[MAXN + 5], size[MAXN + 5];\nvector<int> son[MAXN + 5];\ndeque<int> s[MAXN + 5];\n\ninline void dfs(int u)\n{\n\tvis[u] = 1;\n\tsize[u] = 1;\n\tfor(auto v : adj[u]) if(!vis[v])\n\t{\n\t\tson[u].push_back(v);\n\t\tdfs(v);\n\t\tsize[u] += size[v];\n\t}\n\n\ts[u].push_back(a[u]);\n\tfor(int i = 2; i <= size[u]; ++i)\n\t{\n\t\tint t = -1;\n\t\tfor(auto j : son[u]) if(!s[j].empty() && (t == -1 || s[j].front() > s[t].front())) t = j;\n\t\ts[u].push_back(s[t].front()), s[t].pop_front();\n\t}\n}\n\ninline void solve()\n{\n\tfor(int i = 1; i <= n; ++i) adj[0].push_back(i);\n\tfor(int i = 1; i <= n; ++i)\n\t\tfor(int j = i + 1; j <= n; ++j) if(__gcd(a[i], a[j]) > 1)\n\t\t{\n\t\t\tadj[i].push_back(j);\n\t\t\tadj[j].push_back(i);\n\t\t}\n\tfor(int i = 0; i <= n; ++i) sort(ALL(adj[i]), [&](int x, int y) { return a[x] < a[y]; });\n\n\tdfs(0), s[0].pop_front();\n\tfor(auto i : s[0]) printf(\"%d \", i);\n\tputs(\"\");\n}\n\nint main()\n{\n#ifdef K_ON // K-ON!\n\tfreopen(\"E.in\", \"r\", stdin);\n\tfreopen(\"E.out\", \"w\", stdout);\n#endif\n\n\tinput();\n\tsolve();\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint gcd(int x,int y)\n{\n\treturn (y==0?x:gcd(y,x%y));\n}\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define mp make_pair\nconst int N=2020;\nconst int V=40020;\nint n,m;\nint a[N];\nbool b[N][N];\nint ans[N];\nbool inAns[N];\nint ansSz=0;\nint lastNotCoprime[N];\nint minOnSuff[N];\nint comp[V];\nvector<int> g[V];\nint C;\nint bestForCol[N];\nmap<int,int> primeId;\nint getId(int y)\n{\n\tif(primeId.count(y)>0) return primeId[y];\n\tprimeId[y]=m;\n\treturn m++;\n}\nvoid dfs(int v)\n{\n\tcomp[v]=C;\n\tfor(int u:g[v])\n\t{\n\t\tif(u<n&&inAns[u]) \n\t\t\tcontinue;\n\t\tif(comp[u]!=-1) \n\t\t\tcontinue;\n\t\tdfs(u);\n\t}\n\treturn;\n}\nvoid color()\n{\n\tfor(int i=0;i<m;i++)\n\t\tcomp[i]=-1;\n\tC=0;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(inAns[i]) \n\t\t\tcontinue;\n\t\tif(comp[i]!=-1) \n\t\t\tcontinue;\n\t\tdfs(i);\n\t\tC++;\n\t}\n\treturn;\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tm=n;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t\tint x=a[i];\n\t\tfor(int y=2;y*y<=x;y++)\n\t\t{\n\t\t\tif(x%y!=0) \n\t\t\t\tcontinue;\n\t\t\tint id=getId(y);\n\t\t\tg[id].push_back(i);\n\t\t\tg[i].push_back(id);\n\t\t\twhile(x%y==0) \n\t\t\t\tx/=y;\n\t\t}\n\t\tif(x!=1)\n\t\t{\n\t\t\tint id=getId(x);\n\t\t\tg[id].push_back(i);\n\t\t\tg[i].push_back(id);\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++) \n\t\tfor(int j=i+1;j<n;j++) \n\t\t\tif(gcd(a[i],a[j])>1) \n\t\t\t\tb[i][j]=b[j][i]=true;\n\tfor(int i=0;i<n;i++) \n\t\tminOnSuff[i]=1e9+2;\n\tfor(int i=0;i<n;i++) \n\t\tlastNotCoprime[i]=-1;\n\twhile(ansSz!=n)\n\t{\n\t\tcolor();\n\t\tfor(int i=0;i<C;i++)\n\t\t\tbestForCol[i]=-1;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tif(inAns[i]) \n\t\t\t\tcontinue;\n\t\t\tif(minOnSuff[lastNotCoprime[i]+1]<a[i]) \n\t\t\t\tcontinue;\n\t\t\tif(bestForCol[comp[i]]==-1||a[bestForCol[comp[i]]]>a[i])\n\t\t\t\tbestForCol[comp[i]]=i;\n\t\t}\n\t\tint id=-1;\n\t\tfor(int i=0;i<C;i++)\n\t\t{\n\t\t\tif(bestForCol[i]==-1) \n\t\t\t\tcontinue;\n\t\t\tif(id==-1||a[bestForCol[i]]>a[id])\n\t\t\t\tid=bestForCol[i];\n\t\t}\n\t\tif(id==-1) \n\t\t\tthrow;\n\t\tinAns[id]=true;\n\t\tans[ansSz++]=a[id];\n\t\tfor(int i=0;i<ansSz;i++)\n\t\t\tminOnSuff[i]=min(minOnSuff[i],a[id]);\n\t\tfor(int i=0;i<n;i++) \n\t\t\tif(b[id][i])\t\n\t\t\t\tlastNotCoprime[i]=ansSz-1;\n\t}\n\tfor(int i=0;i<ansSz;i++)\n\t\tprintf(\"%d \",ans[i]);\n\tprintf(\"\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<queue>\nusing namespace std;\npriority_queue<int>Q;\nint edgenum,vet[4005],nex[4005],head[4005],du[4005];\nint n,a[2005];\nbool adj[2005][2005],vis[4000005];\nint gcd(int a,int b)\n{\n\treturn (b==0)?a:gcd(b,a%b);\n}\nvoid addedge(int u,int v)\n{\n\tedgenum++,vet[edgenum]=v,nex[edgenum]=head[u],head[u]=edgenum,du[v]++;\n}\nvoid dfs(int u)\n{\n\tfor (int i=1;i<=n;i++)\n\t\tif (adj[u][i]==true && vis[i]==false) addedge(u,i),vis[i]=true,dfs(i);\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tsort(a+1,a+n+1);\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=i+1;j<=n;j++)\n\t\t\tif (gcd(a[i],a[j])>1) adj[i][j]=adj[j][i]=true;\n\tfor (int i=1;i<=n;i++)\n\t\tif (!vis[i]) vis[i]=true,dfs(i);\n\tfor (int i=1;i<=n;i++)\n\t\tif (du[i]==0) Q.push(i);\n\twhile (!Q.empty())\n\t{\n\t\tint u=Q.top();Q.pop();\n\t\tprintf(\"%d \",a[u]);\n\t\tfor (int i=head[u];i!=0;i=nex[i])\n\t\t{\n\t\t\tdu[vet[i]]--;\n\t\t\tif (du[vet[i]]==0) Q.push(vet[i]);\n\t\t}\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#define pb push_back\nusing namespace std;\nconst int N=2100;\npriority_queue<int> Q;\nvector<int> E[N],W[N];\nint n,a[N],d[N],vis[N];\nvoid dfs(int x)\n{\n    vis[x]=1;\n    for(auto R:E[x]) if(!vis[R]) W[x].pb(R);\n    for(auto R:E[x]) if(!vis[R]) dfs(R);\n}\nint main()\n{\n    cin>>n;\n    for(int i=1;i<=n;i++) cin>>a[i];\n    sort(a+1,a+n+1);\n    for(int i=1;i<=n;i++)\n        for(int j=i+1;j<=n;j++)\n            if(__gcd(a[i],a[j])>1) E[i].pb(j),E[j].pb(i);\n    for(int i=1;i<=n;i++) sort(E[i].begin(),E[i].end());\n    for(int i=1;i<=n;i++) if(!vis[i]) dfs(i);\n    for(int i=1;i<=n;i++) for(auto R:W[i]) d[R]++;\n    for(int i=1;i<=n;i++) if(!d[i]) Q.push(i);\n    while(!Q.empty())\n    {\n        int x=Q.top();Q.pop();\n        printf(\"%d \",a[x]);\n        for(auto R:W[x])\n            if(--d[R]==0) Q.push(R);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n                                                                                                     \n                                             `-:://:::-                                             \n                                           `//:-------:/:`                                          \n                                          .+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .o:--...```..---+/`                                        \n                                       `/y+o/---....---:+o.                                         \n                                   `...````-os+/:---:/+o/--.`                                       \n              `-/+++++/:.      `...`       :h+d+oooo+/+-`   ...                                     \n            `/++//:::://++-`....`         -.`//````````:`     `..`                                  \n           `o+/::------://o/`           `-` -.          -`       `..`                               \n `---.-o/:./o/::-..``..-ЗАПУСКАЕМ      ..  ..            -`        `...       ``..``                \n  `....o+:-++/:--.```..-://s.        `-`  .-              -`          `-o: .-//::::/:-`             \n          `:s+/:--....-::/+s-`      .-   `-                -`           -///:--------:/:`           \n           ./s+//:::::://oo-``..НЕЙРОННУЮ: СЕТЬ:::::::-`РАБОТЯГИ        `+:--........--:/`          \n            .:ooo+++++osso-`    `.:-...`/` ./::-------:/:`   -`         :+--..``````.--:+:...-+:-`  \n             `.-/+++++/+-.-`    -.   ``:so:/:--.......--:+`  `-```````o+/+--..`````..--:o/-..:s+:.  \n                 ```````:``.. `-`     -` `+:--..`````..--/+-.../.`````..-o:--.......---/o.    `     \n                        `:  `:-      -.  .o:--..`` ``..--:o`   `-`      `:o+:--------:+o-`          \n                         `-`-...    ..   .o/--...```..--:+/`    `-`     `oy/so/////++o/.`           \n                          -/`  `-` `- ``+s/o/:---...---:++.      `-`   .-../d://///:-.`             \n                `.---..``-..-    .-/..`````-oo+/:::::/+o+-        `-``-`  `-.  ````                 \n             `:++++/+++++-  ..``.-/:`      /y-:/++o++/:.`..`       ./.   `-                         \n            -++/::::::://+/..:-``:` ..   `-.`  ```.```    `..`   `..`-` `-                          \n       ``  -o//:--....-::/++` -.-`   `-`.-`                 `..`..`  `-.-                           \n  -----ss+:++/:--.```..-://s.  /.     `::                    `-:.     ./`                           \n  `````/:..+o/::-..``.--:/+s. ..-`   `-``-`                 ..` `-`  `-`-`                          \n          `-s+/::-----::/+oo---``-` ..    .:-    ```      .-`     .-.-  `-`                         \n           `:oo+//::://+os/..:`..-/:`      :y.-:::::::.`.-`        ./-`  `-`                        \n            `./+oooooooo+/.`-    .-:...`.. .//:-------://`        `- `..` `:.                       \n              ``.-::::-.``-/`  `-` `-  `oo:+:--.......--:/`      `-    `.:--h.``..```               \n                          -.-`.-    .-   `+:--..`````..--//`    `-       /s-//::::::::.             \n                         -` `/-      ..  .o:--..`` ``..--:o.```.-        `//:--------://`           \n                        -` .-`.-`     -.`-o/--...```..--:+/.``-:....``:-.+:--....`...--:+`          \n                       ..`-.   `-.   ``:os:o/:---...---:++.  `-     ``///+:-..``````.--:+-````-.`   \n              `.:///////.-`      .:-..` -``-+o+/:::::/+o/.  `-         `:+:-..`````..--:o/:--/ys+-  \n            `-++///////+o/. ``....`-.    :` `.:++++++/:.`  .-           -o/---......---/o.   `.`    \n           `++//:-----::/+o:..`     .-`   :    ```````    .-           `+so+:--------:++-`          \n  `````:-``:o/::-..`..--:/+o`         -.  `-             .-          `../../+o+////+o+:.`           \n  -----syo/o+/:--.```..-://s.          .-` `-           .-        `...     ``-:////:-``             \n       .` `/s//:--....-::/+s.            -. `-`        .-       `..`                                \n           .+o+/:::--:://+s/-..`          .::+y  ```  .-     `..`                                   \n            ./oo++////+oso-`   `....       :y-+:::::::/`   ...                                      \n             `.:+oooooo/-`         `....-. .//:-------:/:-.`                                        \n                ``...``                 /+:+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .+/--...```..--:+/`                                        \n                                         `-o/:---...---:++.                                         \n                                          `-+o+/:---:/+o/.                                          \n                                            `.:+oooo+/-.`                                           \n                                               ``````                                               \n*/\n\n#ifdef aimbot\n#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#endif\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <set>\n#include <queue>\n#include <ostream>\n#include <istream>\n#include <typeinfo>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <limits>\n#include <fstream>\n#include <array>\n#include <list>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <cstring>\n#include <chrono>\n\n#define random escape__from__random__aetuhoetnuhshe\n#define mt make_tuple\n#define x first\n#define y second\n#define pb push_back\n#define ppb pop_back\n#define mp make_pair\n#define umap unordered_map\n#define uset unordered_set\n#define elif else if\n#define len(v) ((int)v.size())\n#define f(i, n) for (int i = 0; i < (n); i++)\n#define rof(i, n) for (int i = ((n) - 1); i >= 0; i--)\n#define apply(v, act) for (auto &x : v) { act; }\n#define log(args...) {string s = #args;deque<string> deq;\\\nstring buf = \"\";int bal = 0;for (char c : s) {\\\nif (c == '(' || c == '[' || c == '{') {bal++;\\\n} else if (c == ')' || c == ']' || c == '}') {\\\nbal--;} else {if (bal == 0) {if (c == ',') {\\\ndeq.pb(buf);buf = \"\";} else {if (c != ' ') {\\\nbuf += c;}}}}}if (!buf.empty()) {deq.pb(buf);}\\\nsmart_io::precall_print();smart_io::_print(deq, args);}\n\ninline int min(const int &x, const int &y) { return (((y-x)>>(32-1))&(x^y))^x; }\ninline int max(const int &x, const int &y) { return (((y-x)>>(32-1))&(x^y))^y; }\ninline long long min(const long long &x, const long long &y) { return (((y-x)>>(64-1))&(x^y))^x; }\ninline long long max(const long long &x, const long long &y) { return (((y-x)>>(64-1))&(x^y))^y; }\n\n#define print    \\\nsmart_io::precall_print(); \\\ncout,\n\n#define scan cin,\n\n#ifdef fast_allocator\nconst int MAXMEM = 200 * 1000 * 1024;\nchar _memory[MAXMEM];\nsize_t _ptr = 0;\nvoid* operator new(size_t _x) { _ptr += _x; assert(_ptr < MAXMEM); return _memory + _ptr - _x; }\nvoid operator delete (void*) noexcept {}\n#endif\n\nusing namespace std;\n\nchar string_in_buffer[(int)260];\n\n\nvoid fast_scan(int &x) { scanf(\"%d\", &x); }\nvoid fast_scan(long long &x) { scanf(\"%lld\", &x); }\nvoid fast_scan(unsigned long long &x) { scanf(\"%llu\", &x); }\nvoid fast_scan(double &x) { scanf(\"%lf\", &x); }\nvoid fast_scan(long double &x) { scanf(\"%Lf\", &x); }\nvoid fast_scan(char &x) {\n\tscanf(\"%c\", &x);\n\tif (x == '\\n') {\n\t\tfast_scan(x);\n\t}\n}\nvoid fast_scan(string &x) {\n\tscanf(\"%s\", string_in_buffer);\n\tx = string(string_in_buffer);\n}\n\ntemplate<class TFirst, class TSecond>\nvoid fast_scan(pair<TFirst, TSecond> &p) {\n\tfast_scan(p.first);\n\tfast_scan(p.second);\n}\n\ntemplate <class T>\nvoid fast_scan(vector<T> &v) {\n\tfor (auto &x : v) fast_scan(x);\n}\n\nvoid fast_print(const int &x) { printf(\"%d\", x); }\nvoid fast_print(const unsigned int &x) { printf(\"%u\", x); }\nvoid fast_print(const long long &x) { printf(\"%lld\", x); }\nvoid fast_print(const unsigned long long &x) { printf(\"%llu\", x); }\nvoid fast_print(const char &x) { printf(\"%c\", x); };\n// void fast_print(__int128 x) {\n// \tif (x == 0) { fast_print('0'); return; }\n// \tif (x < 0) {\n// \t\tfast_print('-');\n// \t\tx = -x;\n// \t}\n// \t__int128 p = 1;\n// \twhile (x / (p * 10)) p *= 10;\n// \twhile (p) {\n// \t\t__int128 symb = x / p;\n// \t\tfast_print((int)symb);\n// \t\tx -= p * symb;\n// \t\tp /= 10;\n// \t}\n// };\nvoid fast_print(const double &x) { printf(\"%.15lf\", x); }\nvoid fast_print(const long double &x) { printf(\"%.15Lf\", x); }\nvoid fast_print(const string &x) { printf(\"%s\", x.c_str());}\nvoid fast_print(const char v[]) { fast_print((string)v); }\n\ntemplate<class TFirst, class TSecond>\nvoid fast_print(const pair<TFirst, TSecond> &p) {\n\tfast_print(p.first);\n\tfast_print(' ');\n\tfast_print(p.second);\n}\n\ntemplate <class T>\nvoid fast_print(const vector<T> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print(' ');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const vector<vector<T>> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print('\\n');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const T &v) {\n\tfor (const auto &x : v) {\n\t\tfast_print(x);\n\t\tfast_print(' ');\n\t}\n}\n\n\nusing namespace std;\n\n\nnamespace smart_io {\n\tstring print_start = \"\";\n\tstring sep = \" \";\n\tbool first_print = false;\n\t\n\tvoid precall_print() {\n\t\tfast_print(print_start);\n\t\tprint_start = \"\\n\";\n\t\tfirst_print = true;\n\t}\n\t\n\tvoid _print(deque<string>) {}\n\ttemplate<class T, class... Args>\n\tvoid _print(deque<string> names, T elem, Args... args) {\n\t\tif (!first_print) {\n\t\t\tfast_print(\"\\n\");\n\t\t} else {\n\t\t\tfirst_print = false;\n\t\t}\n\t\tfast_print(names.front());\n\t\tfast_print(\" = \");\n\t\tfast_print(elem);\n\t\tnames.pop_front();\n\t\t_print(names, args...);\n\t}\n} //namespace smart_io\n\n\ntemplate <class T>\nostream &operator,(ostream &os, const T &object) {\n\tif (!smart_io::first_print) {\n\t\tfast_print(smart_io::sep);\n\t} else {\n\t\tsmart_io::first_print = false;\n\t}\n\tfast_print(object);\n\treturn os;\n}\n\ntemplate <class T>\nistream &operator,(istream &is, T &object) {\n\tfast_scan(object);\n\treturn is;\n}\n\nnamespace random {\n\tusing namespace std::chrono;\n\tmt19937 rng(duration_cast< milliseconds >(\n\t\t\t\t\t\t\t\t\t\t\t  system_clock::now().time_since_epoch()\n\t\t\t\t\t\t\t\t\t\t\t  ).count());\n\tuniform_real_distribution<> prob_dist(0.0, 1.0);\n};\n\nnamespace typedefs {\n\ttypedef long long ll;\n\ttypedef unsigned long long ull;\n\ttypedef pair<int, int> pii;\n\ttypedef long double ld;\n}\n\nnamespace numbers_operation {\n\ttemplate<class T>\n\tinline T floor_mod(T a, const T &b) {\n\t\ta %= b;\t\n\t\tif (a < 0) a += b;\n\t\treturn a;\n\t}\n}\n\nusing namespace numbers_operation;\nusing namespace typedefs;\nusing namespace random;\n\nint n;\nvector<int> v;\n\nint gcd(int a, int b) {\n\treturn __gcd((unsigned int)a, (unsigned int)b);\n}\n\nbool can_add(vector<int> p, int x) {\n\tvector<int> q = p;\n\tp.pb(x);\n\tfor (int i = len(p) - 1; i > 0; i--) {\n\t\tif (gcd(p[i], p[i - 1]) == 1) swap(p[i], p[i - 1]);\n\t\telse break;\n\t\tif (q < p) return false;\n\t}\n\treturn true;\n}\n\nsigned main(signed argc, char *argv[]) {\n\tscan n;\n\tv.resize(n);\n\tscan v;\n\tsort(v.begin(), v.end());\n\tvector<int> remain = v;\n\tvector<int> rez;\n\tint pref = 0;\n\twhile (!remain.empty()) {\n\t\t// print \"STATE\";\n\t\tvector<bool> used(len(remain), false);\n\t\tint next = -1;\n\t\tfor (int x : remain) {\n\t\t\t// print rez, x, (int)can_add(rez, x);\n\t\t\tif (!can_add(rez, x)) continue;\n\t\t\tbool fail = false;\n\t\t\tdeque<int> deq{x};\n\t\t\twhile (!deq.empty()) {\n\t\t\t\tint cur = deq[0];\n\t\t\t\tdeq.pop_front();\n\t\t\t\tfor (int i = 0; i < len(used); i++) {\n\t\t\t\t\tif (remain[i] >= x && (gcd(remain[i], cur) > 1 || remain[i] == x) && !used[i]) {\n\t\t\t\t\t\tused[i] = true;\n\t\t\t\t\t\t// print \"ADD\", remain[i];\n\t\t\t\t\t\tdeq.pb(remain[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < len(used); i++)\n\t\t\t\tif (remain[i] >= x && !used[i]) {\n\t\t\t\t\tfail = true;\n\t\t\t\t}\n\t\t\tif (!fail) {\n\t\t\t\tnext = x;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tassert(next != -1);\n\t\tremain.erase(find(remain.begin(), remain.end(), next));\n\t\trez.pb(next);\n\t\tpref = next;\n\t}\n\tprint rez;\n}\n"
  },
  {
    "language": "C++",
    "code": "//MIPT Cryptozoology\n//Room 265\n#define _CRT_SECURE_NO_WARNINGS\n#pragma comment (linker, \"/STACK:128000000\")\n#include <stdio.h>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <queue>\n#include <deque>\n#include <cmath>\n#include <ctime>\n#include <stack>\n#include <bitset>\n#include <set>\n#include <map>\n#include <cassert>\n#include <memory.h>\n#include <sstream>\n\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define all(a) a.begin(), a.end()\n#define itn int\n\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\n\ntypedef long long li;\ntypedef long long i64;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef pair <int, int> pi;\n\nvoid solve(bool);\n\nvoid precalc();\n\nint TESTNUM = 0;\n#define FILENAME \"\"\n\nint main() {\n\tstring s = FILENAME;\n#ifdef YA\n\t//assert(!s.empty());\n\tfreopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\t//cerr<<FILENAME<<endl;\n\t//assert (s != \"change me please\");\n\tclock_t start = clock();\n#else\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\t//freopen(FILENAME \".in\", \"r\", stdin);\n\t//freopen(FILENAME \".out\", \"w\", stdout);\n\tcin.tie(0);\n#endif\n\tcout.sync_with_stdio(0);\n\tcout.precision(10);\n\tcout << fixed;\n\tprecalc();\n\tint t = 1;\n\t//cin >> t;\n\tint test_num = 1;\n\twhile (t--) {\n\t\t//cout << \"Case #\" << test_num++ << \": \";\n\t\t++TESTNUM;\n\t\tsolve(true);\n\t}\n#ifdef YAH\n\twhile (true) {\n\t\tsolve(false);\n\t}\n#endif\n#ifdef YA\n\tcerr << \"\\n\\n\\n\" << (clock() - start) / 1.0 / CLOCKS_PER_SEC << \"\\n\\n\\n\";\n#endif\n\treturn 0;\n}\n\n//#define int li\n\n/*int pr[] = { 97, 2011 };\nint mods[] = { 1000000007, 1000000009 };\n\nconst int C = 100500;\nint powers[2][C];*/\n\n//int MOD = 1000000007;\n\n//int c[5010][5010];\n\ntemplate<typename T>\nT binpow(T q, T w, T mod) {\n\tif (!w)\n\t\treturn 1 % mod;\n\tif (w & 1)\n\t\treturn q * 1LL * binpow(q, w - 1, mod) % mod;\n\treturn binpow(q * 1LL * q % mod, w / 2, mod);\n}\n\nvoid precalc() {\n\n\t/*for (int w = 0; w < 2; ++w) {\n\tpowers[w][0] = 1;\n\tfor (int j = 1; j < C; ++j) {\n\tpowers[w][j] = (powers[w][j - 1] * 1LL * pr[w]) % mods[w];\n\t}\n\t}*/\n\n\t/*for (int i = 0; i < 5010; ++i) {\n\tc[i][i] = c[i][0] = 1;\n\tfor (int j = 1; j < i; ++j) {\n\tc[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % MOD;\n\t}\n\t}*/\n}\n\ntemplate<typename T>\nT gcd(T q, T w) {\n\twhile (w) {\n\t\tq %= w;\n\t\tswap(q, w);\n\t}\n\treturn q;\n}\ntemplate<typename T>\nT lcm(T q, T w) {\n\treturn q / gcd(q, w) * w;\n}\n\ninline int nxt(){\n\tint x;\n\tcin >> x;\n\treturn x;\n}\n\n//#define int li\n\nint n;\nvector<int> dsu;\nvoid init() {\n\tdsu.resize(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tdsu[i] = i;\n\t}\n}\n\nint find_set(int v) {\n\tif (dsu[v] == v) {\n\t\treturn v;\n\t}\n\treturn dsu[v] = find_set(dsu[v]);\n}\n\nvoid merge(int q, int w) {\n\tq = find_set(q);\n\tw = find_set(w);\n\tdsu[q] = w;\n}\n\nvoid solve(bool read) {\n\tcin >> n;\n\tvector<int> a(n);\n\tvector<vector<int>> primes(n);\n\tmap<int, set<int>> poses;\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t\tint cur = a[i];\n\t\tfor (int p = 2; p * p <= cur; ++p) {\n\t\t\tif (cur % p == 0) {\n\t\t\t\tposes[p].insert(i);\n\t\t\t\tprimes[i].push_back(p);\n\t\t\t\twhile (cur % p == 0) {\n\t\t\t\t\tcur /= p;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (cur > 1) {\n\t\t\tposes[cur].insert(i);\n\t\t\tprimes[i].push_back(cur);\n\t\t}\n\t}\n\tvector<int> res;\n\tvector<char> used(n, false);\n\tfor (int i = 0; i < n; ++i) {\n\t\tinit();\n\t\tfor (auto& item : poses) {\n\t\t\tfor (auto it = item.second.begin(); it != item.second.end(); ++it) {\n\t\t\t\tauto nex = it;\n\t\t\t\t++nex;\n\t\t\t\tif (nex == item.second.end()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tmerge(*it, *nex);\n\t\t\t}\n\t\t}\n\n\t\tvector<vector<int>> comps(n);\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (!used[i]) {\n\t\t\t\tcomps[find_set(i)].push_back(i);\n\t\t\t}\n\t\t}\n\n\t\tint cur_take = -1;\n\t\tint cur_id = -1;\n\t\tfor (int i = 0; i < comps.size(); ++i) {\n\t\t\tsort(all(comps[i]), [&a](int q, int w) {\n\t\t\t\treturn a[q] < a[w];\n\t\t\t});\n\t\t\tint best = 2e9;\n\t\t\tint best_id = -1;\n\t\t\tfor (int cur : comps[i]) {\n\t\t\t\tint cand = a[cur];\n\t\t\t\tbool f = true;\n\t\t\t\tfor (int prev = (int)res.size() - 1; prev >= 0; --prev) {\n\t\t\t\t\tif (gcd(res[prev], cand) > 1) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (cand > res[prev]) {\n\t\t\t\t\t\tf = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (f) {\n\t\t\t\t\tif (best > cand) {\n\t\t\t\t\t\tbest = cand;\n\t\t\t\t\t\tbest_id = cur;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!comps[i].empty() && best > cur_take) {\n\t\t\t\tcur_take = best;\n\t\t\t\tcur_id = best_id;\n\t\t\t}\n\t\t}\n\t\t\n\t\tassert(cur_take != -1);\n\t\tres.push_back(a[cur_id]);\n\t\tused[cur_id] = true;\n\t\tfor (int p : primes[cur_id]) {\n\t\t\tposes[p].erase(cur_id);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tcout << res[i] << \" \";\n\t}\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb  push_back\nusing namespace std;\n\ntypedef pair<int,int>  PII;\nint n,a[2010],e[2010][2010],vis[2010];\n\nint gcd(int a,int b){return b?gcd(b,a%b):a;}\n\nvector <int> solve(int x)\n{\n\tint m=0;\n\tvector <vector <int> > V;\n\tvector <vector <int> ::iterator> h;\n\tvector <int> r;\n\tvis[x]=1;\n\tfor (int y=1; y<=n; y++)\n\t\tif ((e[x][y])&&(!vis[y]))\n\t\t\tV.pb(solve(y)),h.pb(V[m].begin()),m++;\n\tr.pb(a[x]);\n\twhile (1)\n\t\t{\n\t\t\tint x=-1;\n\t\t\tfor (int i=0; i<m; i++)\n\t\t\t\tif ((h[i]!=V[i].end())&&((x<0)||(*h[i]>*h[x])))\n\t\t\t\t\tx=i;\n\t\t\tif (x<0)  return r;\n\t\t\tr.pb(*h[x]),h[x]++;\t\t\t\n\t\t}\n}\n\nvoid work()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1; i<=n; i++)  scanf(\"%d\",&a[i]),e[0][i]=1;\n\tsort(a+1,a+n+1);\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=i+1; j<=n; j++)\n\t\t\tif (gcd(a[i],a[j])!=1)\n\t\t\t\te[i][j]=e[j][i]=1;\n\tvector <int> ans=solve(0);\n\tfor (int i=1; i<=n; i++)  printf(\"%d \",ans[i]);\n}\n\nint main()\n{\n\twork();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\",\"inline\",\"-ffast-math\")\n#pragma GCC target(\"avx,sse2,sse3,sse4,mmx\")\n#include <bits/stdc++.h>\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/hash_policy.hpp>\nusing namespace __gnu_pbds;\nusing namespace std;\n\nint n,a[2010];\nvector<int> v[2010];\nbool vis[2010],used[2010];\nvector<int> dp[2010];\n\ninline int gcd(int a,int b)\n{\n\tif(b==0) return a;\n\treturn gcd(b,a%b);\n}\n\ninline void dfs2(int x)\n{\n\tvis[x]=1;\n\tfor(int i=0;i<v[x].size();i++) if(!used[v[x][i]]&&!vis[v[x][i]]){\n\t\tdfs2(v[x][i]);\n\t}\n}\n\ninline void dfs(int x)\n{\n\tused[x]=1;memset(vis,0,sizeof(vis));\n\tfor(int i=0;i<v[x].size();i++) if(!used[v[x][i]]&&!vis[v[x][i]]){\n\t\tdfs2(v[x][i]);\n\t\tdp[x].push_back(v[x][i]);\n\t}\n\tfor(int i=0;i<dp[x].size();i++) dfs(dp[x][i]);\n} \n\ninline void dfs3(int x)\n{\n\tif(x>0) cout<<a[x]<<\" \";\n\tfor(int i=dp[x].size()-1;i>=0;i--) dfs3(dp[x][i]);\n}\n\nsigned main()\n{\n\tios::sync_with_stdio(false);\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++){\n\t\tv[0].push_back(i);v[i].push_back(0);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=i+1;j<=n;j++){\n\t\t\tif(gcd(a[i],a[j])>1){\n\t\t\t\tv[i].push_back(j);\n\t\t\t\tv[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tdfs(0);\n\tdfs3(0);\n\tcout<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pb push_back\n#define all(x) x.begin(), x.end()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nconst int N = 2000 + 10;\nconst int MOD = 1000000007;\nconst int LOG = 20;\nconst int INF = 1000000010;\nconst int delta = 11353;\n\nint n;\nvi G[N], a;\nmap<int, int> mp;\nint mark[N];\nint mark2[N];\n\nvoid DFS(int v){\n\tmark[v] = 1;\n\tfor (auto u:G[v]){\n\t\tif ((mark[u] == 0) && (mark2[u] == 0)){\n\t\t\tDFS(u);\n\t\t}\n\t}\n}\nint GCD(int x, int y){\n\tif (x == 0 || y == 0) return (x + y);\n\tif (x == 1 || y == 1) return 1;\n\tif (x < y) swap(x, y);\n\treturn GCD(y, x % y);\n}\n\nint32_t main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++){\n\t\tint x;\n\t\tcin >> x;\n\t\tmp[x] ++;\n\t\ta.pb(x);\n\t}\n\tsort(all(a));\n\ta.resize(unique(all(a)) - a.begin());\n\tfor (int i = 0; i < a.size(); i++) for (int j = 0; j < i; j++) if (GCD(a[i], a[j]) != 1){\n\t\tG[i].pb(j), G[j].pb(i);\n\t}\n\t//cout << GCD(7, 11) << '\\n';\n\tvi ans;\n\tint last = 0;\n\tfor (int i = 0; i < a.size(); i++){\n\t\tmemset(mark, 0, sizeof mark);\n\t\tif (i == 0){\n\t\t\tint mx = 0;\n\t\t\tfor (int j = 0; j < a.size(); j++) if (!mark[j]) mx = j, DFS(j);\n\t\t\tmark2[mx] = 1;\n\t\t\tans.pb(a[mx]);\n\t\t\t//cout << a[mx] << endl;\n\t\t\tlast = mx;\n\t\t}else{\n\t\t\tsort(all(G[last]));\n\t\t\tint mx = 0;\n\t\t\tfor (auto u:G[last]){\n\t\t\t\tif ((mark[u] == 0) && (mark2[u] == 0)) DFS(u), mx = u;\n\t\t\t}\t\n\t\t\tfor (int j = 0;  j < a.size(); j++){\n\t\t\t\tif ((mark[j] == 0) && (mark2[j] == 0)) mx = max(j, mx), DFS(j);\n\t\t\t}\n\t\t\tmark2[mx] = 1;\n\t\t\tans.pb(a[mx]);\n\t\t\tlast = mx;\n\t\t\t//cout << a[mx] << endl;\n\t\t}\n\t}\n\tfor (int i = 0; i < ans.size(); i++){\n\t\tint u = ans[i];\n\t\tif (i != 0){\n\t\t\t//if (GCD(ans[i], ans[i - 1]) == 1 && ans[i - 1] < ans[i]) assert(0);\n\t\t\tif (GCD(ans[i], ans[i - 1]) != 1 && ans[i - 1] > ans[i]) assert(0);\n\t\t\t\n\t\t}\n\t\tfor (int i = 0; i < mp[u]; i++) cout << u << ' ';\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define REP(i,n) for(int i=0;i<int(n);i++)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\ntypedef double ld;\n\ntemplate<class T> inline void read(T &x){\n\tint f=0;x=0;char ch=getchar();\n\tfor(;!isdigit(ch);ch=getchar())f|=(ch=='-');\n\tfor(;isdigit(ch);ch=getchar())x=x*10+ch-'0';\n\tif(f)x=-x;\n}\n\nconst int N=2005;\nint a[N],vis[N],in[N],n;\npriority_queue<int> Q;\nvi e[N],t[N];\n\nvoid dfs(int x){\n\tvis[x]=1;\n\tsort(e[x].begin(),e[x].end());\n\tfor(auto y:e[x]){\n\t\tif(vis[y]) continue;\n\t\tdfs(y);\n\t\tt[x].pb(y);\n\t\tin[y]++;\n\t}\n}\n\nint main(){\n\tread(n);\n\trep(i,1,n) read(a[i]);\n\tsort(a+1,a+n+1);\n\trep(i,1,n) rep(j,i+1,n)\n\t\tif(__gcd(a[i],a[j])>=2) e[i].pb(j),e[j].pb(i);\n\trep(i,1,n) if(!vis[i]) dfs(i);\n\trep(i,1,n) if(!in[i]) Q.push(i);\n\twhile(!Q.empty()){\n\t\tint x=Q.top(); Q.pop();\n\t\tprintf(\"%d \",a[x]);\n\t\tfor(auto y:t[x]) if(!(--in[y])) Q.push(y);\n\t}\n\tputs(\"\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N=2010;\nbitset<N>A[N];\nvector<int>g[N];\nint n,a[N],vis[N];\npriority_queue<pair<int,int> >pq;\n\n\nvoid dfs(int x){\n\tvis[x]=1;\n\tfor(int i=1;i<=n;++i)if(A[x][i]&&!vis[i])g[x].push_back(i),dfs(i);\n}\n\nint main(){\n\tios::sync_with_stdio(0);cin.tie(0);cout.tie(0);\n\tcin>>n;\n\tfor(int i=1;i<=n;++i)cin>>a[i];\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=1;j<=n;++j)if(i!=j&&__gcd(a[i],a[j])>1)A[i][j]=1;\n\tfor(int i=1;i<=n;++i)if(!vis[i])dfs(i),pq.emplace(a[i],i);\n\tfor(int i=1;i<=n;++i){\n\t\tauto x=pq.top();pq.pop();\n\t\tcout<<x.first<<\" \\n\"[i==n];\n\t\tfor(int j:g[x.second])pq.emplace(a[j],j);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mp make_pair\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int > vi;\ntypedef pair<int ,int > pii;\ntypedef vector<pii> vii;\nconst int inf=0x3f3f3f3f, maxn=100007, mod=1e9+7;\nconst ll linf=0x3f3f3f3f3f3f3f3fLL;\nint n,a[2007];\nvi e[2007];\nvi e2[2007];\nbool vis[2007];\nint deg[2007];\nvoid dfs(int x){\n\tif(vis[x])return ;\n\tvis[x]=true;\n\tfor(int i=0;i<e[x].size();i++){\n\t\tif(!vis[e[x][i]]){\n\t\t\te2[x].pb(e[x][i]);\n\t\t\tdeg[e[x][i]]++;\n\t\t\tdfs(e[x][i]);\n\t\t}\n\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=i+1;j<=n;j++){\n\t\t\tif(__gcd(a[i],a[j])>1)e[i].pb(j),e[j].pb(i);\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)sort(e[i].begin(),e[i].end());\n\tfor(int i=1;i<=n;i++)if(!vis[i])dfs(i);\n\tmemset(vis,0,sizeof(vis));\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=n;j>=1;j--){\n\t\t\tif(!deg[j]&&!vis[j]){\n\t\t\t\tvis[j]=true;\n\t\t\t\tprintf(\"%d \",a[j]);\n\t\t\t\tfor(int k=0;k<e2[j].size();k++)deg[e2[j][k]]--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 2345;\n\nint n, a[N], b[N], degree[N];\nvector<int> adj[N], new_adj[N];\nbool visit[N];\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n;\n  for (int i = 1; i <= n; ++i) {\n    cin >> a[i];\n  }\n  sort(a + 1, a + 1 + n);\n  for (int i = 1; i <= n; ++i) {\n    for (int j = 1; j < i; ++j) {\n      if (__gcd(a[i], a[j]) != 1) {\n        adj[i].push_back(j);\n        adj[j].push_back(i);\n      }\n    }\n  }\n  function<void (int)> dfs = [&] (int x) {\n    visit[x] = true;\n    for (auto y : adj[x]) {\n      if (!visit[y]) {\n        new_adj[x].push_back(y);\n        ++degree[y];\n        dfs(y);\n      }\n    }\n  };\n  for (int i = 1; i <= n; ++i) {\n    if (!visit[i]) {\n      dfs(i);\n    }\n  }\n  int t = 0;\n  priority_queue<int> q;\n  for (int i = 1; i <= n; ++i) {\n    if (!degree[i]) {\n      q.push(i);\n    }\n  }\n  while (!q.empty()) {\n    int x = q.top();\n    q.pop();\n    b[++t] = a[x];\n    for (auto y : new_adj[x]) {\n      if (--degree[y] == 0) {\n        q.push(y);\n      }\n    }\n  }\n  for (int i = 1; i <= n; ++i) {\n    cout << b[i] << \" \\n\"[i == n];\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n    \nusing namespace std;\n    \nconst int N = 2005;\n    \nint a[N];\n    \nvector<pair<int,int> >adj[N];\n    \nint vis[N];\n    \nint id;\nvoid dfs(int x){\n    vis[x]= 1;\n    if(a[id]>a[x])id = x;\n    \n    int u,i;\n    \n    for(i=0;i<adj[x].size();++i){\n        u = adj[x][i].second;\n        if(!vis[u])\n            dfs(u);\n    }\n}   \n\nvector<int> ret[N];\n\nvoid merge(vector<int> &a,vector<int> &b){\n    vector<int> R;\n    int p1 = 0,p2 = 0;\n    \n    while(p1<a.size() && p2<b.size())\n        if(a[p1]>b[p2])\n            R.push_back(a[p1++]);\n        else\n            R.push_back(b[p2++]);\n    \n    while(p1<a.size())\n        R.push_back(a[p1++]);\n    while(p2<b.size())\n        R.push_back(b[p2++]);\n    \n    a = R;\n}   \nvoid dfs2(int x){\n    int u,i;\n    vis[x]= 2;\n    for(i=0;i<adj[x].size();++i){\n        u = adj[x][i].second;\n\n        if(vis[u]==2)continue;\n\n        dfs2(u);\n        merge(ret[x],ret[u]);\n    }\n    ret[x].push_back(0);\n    for(i=ret[x].size()-1;i>=1;--i)\n        ret[x][i]= ret[x][i-1];\n    ret[x][0]= a[x];\n}\n\nint gcd(int x,int y){\n    if(x==0)return y;\n    return gcd(y%x,x);\n}\nint main(){\n    int n,i;\n    cin>>n;\n    for(i=1;i<=n;++i)scanf(\"%d\",&a[i]);\n    int j;\n    for(i=1;i<=n;++i){\n        for(j=1;j<=n;++j){\n            if(gcd(a[i],a[j])>1)\n                adj[i].push_back(make_pair(a[j],j));\n        }\n        sort(adj[i].begin(),adj[i].end());\n    }\n    vector<int> R;\n    for(i=1;i<=n;++i){\n        if(vis[i])continue;\n        id = i;\n        dfs(i);\n        \n        dfs2(id);\n        merge(R,ret[id]);\n    }\n    for(i=0;i<R.size();++i)printf(\"%d \",R[i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define re register\n#define ll long long\ninline int gi(){\n\tint f=1,sum=0;char ch=getchar();\n\twhile(ch>'9' || ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0' && ch<='9'){sum=(sum<<3)+(sum<<1)+ch-'0';ch=getchar();}\n\treturn f*sum;\n}\nconst int N=2010;\nint a[N],link[N][N],vis[N],d[N],n;\nvector<int>G[N];\nvoid dfs(int u){\n\tvis[u]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tif(link[u][i] && !vis[i]){\n\t\t\td[i]++;\n\t\t\tG[u].push_back(i);\n\t\t\tdfs(i);\n\t\t}\n}\npriority_queue<int>Q;\nint main(){\n\tn=gi();for(int i=1;i<=n;i++)a[i]=gi();\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<n;i++)\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\tif(__gcd(a[i],a[j])!=1)link[i][j]=link[j][i]=1;\n\tfor(int i=1;i<=n;i++)if(!vis[i])dfs(i);\n\tfor(int i=1;i<=n;i++)if(!d[i])Q.push(i);\n\twhile(!Q.empty()){\n\t\tint u=Q.top();Q.pop();\n\t\tprintf(\"%d \",a[u]);\n\t\tfor(auto v:G[u])Q.push(v);\n\t}\n\tputs(\"\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nThough leaves are many , the root is one.\nThrough all the lying days of my youth\nI swayed my leaves and flowers in the sun.\nNow I may wither into the truth.\n\t  \t  \t- William Butler Yeats\n*/\n//#pragma GCC optimize(\"Ofast,no-stack-protector\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx\")\n//#pragma GCC target(\"avx,tune=native\")\n#include<bits/stdc++.h>\n//#include<ext/pb_ds/assoc_container.hpp>\nusing namespace std;\n//using namespace __gnu_pbds;\nconst int inf=0x3f3f3f3f;\nconst double eps=1e-6;\nconst int mod=1000000007;\ntypedef long long ll;\n#ifndef LOCAL\n#define cerr if(0)cout\n#endif\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\ninline string getstr(string &s,int l,int r){string ret=\"\";for(int i=l;i<=r;i++)ret.push_back(s[i]);return ret;}\nint modpow(int x,int y,int md=mod){if(y==0)return 1;int ret=modpow(x,y>>1,md);ret=(ll)ret*ret%md;if(y&1)ret=(ll)ret*x%md;return ret;}\nvector<int>g[2005],Tree[2005];\nint nn,n;\nint a[2005],used[2005];\nvoid dfs(int x){\n\tused[x]=1;\n\tfor(auto to:g[x])if(!used[to]){\n\t\tTree[x].push_back(to);\n\t\tdfs(to);\n\t}\n}\nint main(){\n\tcin>>nn;n=nn;\n\tfor(int i=1;i<=nn;i++)cin>>a[i];\n\tsort(a+1,a+nn+1);reverse(a+1,a+nn+1);\n\twhile(n&&a[n]==1)n--;\n\treverse(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=i+1;j<=n;j++){\n\t\t\tif(__gcd(a[i],a[j])>1){\n\t\t\t\tg[i].push_back(j);\n\t\t\t\tg[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tpriority_queue<int>q;\n\tfor(int i=1;i<=n;i++){\n\t\tif(!used[i]){\n\t\t\tq.push(i);dfs(i);\n\t\t}\n\t}\n\twhile(!q.empty()){\n\t\tcout<<a[q.top()]<<\" \";int v=q.top();q.pop();\n\t\tfor(auto x:Tree[v])q.push(x);\n\t}\n\tfor(int i=n+1;i<=nn;i++)cout<<1<<\" \";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<ctime>\n#include<climits>\n#include<queue>\n#include<cmath>\n#include<vector>\nusing namespace std;\nconst int N=2010;\nint n;\nint a[N],book[N],map[N][N];\nvector<int> v[N];\npriority_queue<int> q;\nvoid ff(int x)\n{\n\tbook[x]=1;\n\tfor(int i=2;i<=n;i++) \n\t{\n\t\tif(book[i] || map[x][i]==0) continue;\n\t\tv[x].push_back(i);\n\t\tff(i);\n\t}\n}\nint main()\n{\n    int i,j,x;\n    scanf(\"%d\",&n);\n    for(i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n    sort(a+1,a+n+1);\n    for(i=1;i<=n;i++) for(j=i+1;j<=n;j++) if(__gcd(a[i],a[j])>1) map[i][j]=map[j][i]=1;\n    for(i=1;i<=n;i++) if(!book[i]) ff(i),q.push(i);\n\twhile(!q.empty())\n    {\n    \tx=q.top(),q.pop();\n    \tcout<<a[x]<<\" \";\n    \tfor(i=0;i<v[x].size();i++) q.push(v[x][i]); \n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<queue>\n#define fo(i,a,b) for(i=a;i<=b;i++)\nusing namespace std;\nconst int maxn=2000+10;\nstruct dong{\n    int x,y;\n    friend bool operator <(dong a,dong b){\n        return a.x<b.x;\n    }\n} zlt;\npriority_queue<dong> dl;\nbool bz[maxn][maxn],pd[maxn];\nint a[maxn],d[maxn];\nint h[maxn],go[maxn*maxn],nxt[maxn*maxn];\nint i,j,k,l,t,n,m,tot,now;\nint gcd(int a,int b){\n    return b?gcd(b,a%b):a;\n}\nvoid add(int x,int y){\n    d[y]++;\n    go[++tot]=y;\n    nxt[tot]=h[x];\n    h[x]=tot;\n}\nvoid dfs(int x){\n    pd[x]=1;\n    int i;\n    fo(i,1,n)\n        if (bz[x][i]&&!pd[i]){\n            add(x,i);\n            dfs(i);\n        }\n}\nint main(){\n    scanf(\"%d\",&n);\n    fo(i,1,n) scanf(\"%d\",&a[i]);\n    sort(a+1,a+n+1);\n    fo(i,1,n-1)\n        fo(j,i+1,n)\n            if (gcd(a[i],a[j])>1) bz[i][j]=bz[j][i]=1;\n    fo(i,1,n)\n        if (!pd[i]) dfs(i);\n    fo(i,1,n)\n        if (!d[i]){\n            zlt.x=a[i];\n            zlt.y=i;\n            dl.push(zlt);\n        }\n    fo(i,1,n){\n        zlt=dl.top();\n        dl.pop();\n        now=zlt.y;\n        printf(\"%d \",a[now]);\n        t=h[now];\n        while (t){\n            d[go[t]]--;\n            if (!d[go[t]]){\n                zlt.x=a[go[t]];\n                zlt.y=go[t];\n                dl.push(zlt);\n            }\n            t=nxt[t];\n        }\n    }\n    puts(\"\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\nusing uint=unsigned;\nusing ll=long long;\nusing ull=unsigned long long;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vl=vector<ll>;\nusing vvl=vector<vl>;\nusing vd=vector<double>;\nusing vvd=vector<vd>;\nusing vs=vector<string>;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tprint_tuple<Cdr...>(os,t);\n\tos<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\nvi merge(const vi& a,const vi& us,const vi& vs)\n{\n\tvi res;\n\tfor(int i=0,j=0;i<us.size()||j<vs.size();){\n\t\tif(i<us.size()&&j<vs.size())\n\t\t\tres.push_back(a[us[i]]>=a[vs[j]]?us[i++]:vs[j++]);\n\t\telse if(i<us.size())\n\t\t\tres.push_back(us[i++]);\n\t\telse\n\t\t\tres.push_back(vs[j++]);\n\t}\n\treturn res;\n}\n\nvi dfs(const vvi& g,const vi& a,int u,vi& vis)\n{\n\tvis[u]=1;\n\tvi res;\n\tfor(int v:g[u]) if(!vis[v])\n\t\tres=merge(a,res,dfs(g,a,v,vis));\n\tres.insert(begin(res),u);\n\treturn res;\n}\n\nint main()\n{\n\tfor(int n;cin>>n&&n;){\n\t\tvi a(n);\n\t\trep(i,n) cin>>a[i];\n\t\tsort(all(a));\n\t\tvvi g(n);\n\t\trep(i,n) repi(j,i+1,n) if(__gcd(a[i],a[j])!=1){\n\t\t\tg[i].push_back(j);\n\t\t\tg[j].push_back(i);\n\t\t}\n\t\tvi vis(n),res;\n\t\trep(i,n) if(!vis[i])\n\t\t\tres=merge(a,res,dfs(g,a,i,vis));\n\t\trep(i,n) cout<<a[res[i]]<<\" \\n\"[i==n-1];\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nconst int maxn = 2030, oo = 123456789, maxm = 34010;\n \nint n, m, T, ans, mn, a[maxn], foo[maxn], lst[maxm], tag[maxn], q[maxn], rar, mx[maxn];\nbool vis[maxn], f[maxn], G[maxn][maxn], F[maxn];\nstd::vector<int> g[maxn], has[maxn], rhas[maxm], all;\nstd::vector<std::pair<int, int> > v;\n \nvoid GEN() {\n\tint mx = 0;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif(!foo[i]) {\n\t\t\tif(a[i] == 1) {\n\t\t\t\tF[i] = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tF[i] = 0;\n\t\t\t\tfor (int j: has[i]) {\n\t\t\t\t\tif(lst[j] >= mx) {\n\t\t\t\t\t\tF[i] = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t(foo[i] > mx) && (mx = foo[i]);\n\t\t}\n\t}\n\treturn;\n}\n /*\ninline void dfs(int &u) {\n\ttag[u] = T;\n\t(F[u] && a[u] < mn) && (mn = a[u]);\n\tvis[u] = 1;\n\tfor (int &v: g[u]) {\n\t\tif(!vis[v] && !f[v]) {\n\t\t\tdfs(v);\n\t\t}\n\t}\n\treturn;\n}\n */\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tscanf(\"%d\", a + i);\n\t\tint t = a[i];\n\t\tfor (int x = 2; x * x <= t; ++x) {\n\t\t\tif(t % x == 0) {\n\t\t\t\tall.push_back(x);\n\t\t\t\twhile(t % x == 0) {\n\t\t\t\t\tt /= x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(t > 1) {\n\t\t\tall.push_back(t);\n\t\t}\n\t}\n\tstd::sort(a + 1, a + n + 1);\n\tstd::sort(all.begin(), all.end());\n\tall.resize(std::unique(all.begin(), all.end()) - all.begin());\n\tm = (int)(all.size());\n\tfor (int i = 1; i <= n; ++i) {\n\t\tF[i] = 1;\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tif(a[i] % all[j] == 0) {\n\t\t\t\thas[i].push_back(j);\n\t\t\t\trhas[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int j = 0; j < m; ++j) {\n\t\tfor (int i = 0; i < (int)(rhas[j].size()); ++i) {\n\t\t\tfor (int k = 0; k < i; ++k) {\n\t\t\t\tint u = rhas[j][i], v = rhas[j][k];\n\t\t\t\tif(!G[u][v]) {\n\t\t\t\t\tg[u].push_back(v);\n\t\t\t\t\tg[v].push_back(u);\n\t\t\t\t\tG[u][v] = G[v][u] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n//\t\tGEN();\n\t\tmemset(vis + 1, 0, sizeof(vis[0]) * n);\n\t\tv.clear();\n\t\tfor (int u = 1; u <= n; ++u) {\n\t\t\tif(F[u]) {\n\t\t\t\tif(!vis[u] && !f[u]) {\n\t\t\t\t\t++T;\n\t\t\t\t\tmn = oo;\n//\t\t\t\t\tdfs(u);\n\t\t\t\t\trar = 0;\n\t\t\t\t\tq[rar++] = u;\n\t\t\t\t\tvis[u] = 1;\n\t\t\t\t\tfor (register int fnt = 0; fnt < rar; ++fnt) {\n\t\t\t\t\t\tint u = q[fnt];\n\t\t\t\t\t\ttag[u] = T;\n\t\t\t\t\t\t(F[u] && a[u] < mn) && (mn = a[u]);\n\t\t\t\t\t\tfor (int &v: g[u]) {\n\t\t\t\t\t\t\tif(!vis[v] && !f[v]) {\n\t\t\t\t\t\t\t\tq[rar++] = v;\n\t\t\t\t\t\t\t\tvis[v] = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tv.push_back(std::make_pair(mn, T));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstd::sort(v.begin(), v.end());\n\t\tint sz = (int)(v.size());\n\t\t//ans = 0;\n\t\tfor (int u = 1; u <= n; ++u) {\n\t\t\tif(F[u] && !f[u]) {\n\t\t\t\tint i = sz - 1;\n\t\t\t\tif(v[i].second == tag[u]) {\n\t\t\t\t\t--i;\n\t\t\t\t}\n\t\t\t\tif(i < 0 || v[i].first <= a[u]) {\n\t\t\t\t\tans = u;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tf[ans] = 1;\n\t\tfoo[ans] = i;\n\t\tprintf(\"%d \", a[ans]);\n\t\tfor (int j: has[ans]) {\n\t\t\tlst[j] = i;\n\t\t}\n\t\tfor (register int j = ans + 1; j <= n; ++j) {\n\t\t\tmx[j] = i;\n\t\t\tF[j] = 0;\n\t\t\tfor (int &k: has[j]) {\n\t\t\t\tif(lst[k] >= i) {\n\t\t\t\t\tF[j] = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int j: has[ans]) {\n\t\t\tfor (register int &k: rhas[j]) {\n\t\t\t\tif(k > ans) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tF[k] |= (lst[j] >= mx[k]);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#pragma GCC optimize(2)\n#define int long long\n//#include<ext/pb_ds/assoc_container.hpp>\n#pragma comment(linker, \"/STACK:16000000\")\n//#define map gp_hash_table\n#define PI 3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679\nusing namespace std;\n//using namespace __gnu_pbds;\nconst int inf=0x3f3f3f3f;\nconst long long inf2=0x3f3f3f3f3f3f3f3f;\nconst double eps=1e-6;\nconst int mod=1000000007;\nvector<int> g[2222],g2[2222];\nint n;\npair<int,int> a[2002];\nvector<vector<int> > vec;\nbool used[2002];\nvoid dfs(int x){\n\tused[x]=true;\n\tfor(int i=0;i<g[x].size();i++){\n\t\tif(used[g[x][i]])continue;\n\t\tg2[x].push_back(g[x][i]);\n\t\tdfs(g[x][i]);\n\t}\n}\npriority_queue<int>q;\nsigned main(){\n\tvec.clear();\n\tios::sync_with_stdio(0);\n\tcin>>n;\n\tfor(int i=1;i<=n;i++)cin>>a[i].first,a[i].second=i;\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++)for(int j=1;j<=n;j++)if(__gcd(a[i].first,a[j].first)!=1){\n\t\tg[i].push_back(j);\n\t}\n\tfor(int i=1;i<=n;i++)if(!used[i]){\n\t\tdfs(i);\n\t\tq.push(i);\n\t}\n\tmemset(used,false,sizeof(used));\n\twhile(q.size()){\n\t\tint x=q.top();q.pop();\n\t\tused[x]=false;\n\t\tfor(int i=0;i<g2[x].size();i++)q.push(g2[x][i]);\n\t\tcout<<a[x].first<<\" \";\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//By Ralif Rakhmatullin\n#include<iostream>\n#include<fstream>\n#include<string>\n#include<cstring>\n#include<math.h>\n#include<cassert>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<ctime>\n#include<queue>\n#include<stack>\n#include<set>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n#include<bitset>\n#include<valarray>\n#include<iterator>\n#include<list>\n#define ll long long\n#define ull unsigned long long\n#define mp make_pair\n#define S second\n#define ld long double\n#define F first\n#define y1 LOL\n#define ld long double\n#define pb push_back\n#define len length\n#define sz size\n#define beg begin\nconst ll INF = (ll)1e18 + 123;\nconst int inf=(int)2e9 + 123; \nconst int mod=1e9+7;\nusing namespace std;\nint n;\nint a[2011];\nbool u[2011];\nvector<int> g[2011];\nvector<int> merg(vector<int> x, vector<int> y){\n\tvector<int> c;\n//\tcerr << \"IN \" << (int)x.sz() << \" \" << (int)y.sz() << endl; \n\tfor(int i = 0, j = 0; i < x.sz() || j < y.sz();){\n\t\tif(i == (int)x.sz() || (j < (int)y.sz() && x[i] < y[j]))\n\t\t\tc.pb(y[j ++]);\n\t\telse\n\t\t\tc.pb(x[i ++]);\n\t}\n\treturn c;\n}\nbool cmp(int x, int y){\n\treturn a[x] < a[y];\n}\nvector<int> dfs(int v){\n\tu[v] = 1;\n\tvector<int> res;\n\tres.pb(inf);\n\tsort(g[v].beg(), g[v].end(), &cmp);\n\tfor(auto to : g[v]){\n\t\tif(!u[to]){\n\t\t\tres = merg(res, dfs(to));\n\t\t}\n\t}\n\tres[0] = a[v];\n\treturn res;\n}\npair<int, int> b[2011];\nint main(){\n\tunsigned int FOR;\n \tasm(\"rdtsc\" : \"=A\"(FOR));\n  \tsrand(FOR);\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\t//cout.tie(0);\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tcin >> n;\n\tfor(int i = 1; i <= n; i ++){\n\t\tcin >> a[i];\n\t}\n\tfor(int i = 1; i <= n; i ++){\n\t\tfor(int j = i + 1; j <= n; j ++){\n\t\t\tif(__gcd(a[i], a[j]) > 1){\n\t\t\t\tg[i].pb(j);\n\t\t\t\tg[j].pb(i);\n\t\t\t}\n\t\t}\n\t\tb[i] = mp(a[i], i);\n\t}\t\n\tvector<int> ans;\n\tsort(b + 1, b + 1 + n);\n\tfor(int i = 1; i <= n; i ++){\n\t\tif(!u[b[i].S]){\n\t\t\tans = merg(ans, dfs(b[i].S));\n\t\t}\n\t}\n\tfor(int i = 0; i < ans.sz(); i ++)\n\t\tcout << ans[i] << \" \";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\n#include<cstdio>\nusing namespace std;\n\nbool vis[2005];\nint d[2005],h[2005],tot;\nint n,v[2005];\nstruct Edge{\n\tint x,next;\n}e[10005];\n\nvoid add_edge(int x,int y){\n\te[++tot].x=y;\n\te[tot].next=h[x],h[x]=tot;\n}\n\nint gcd(int a,int b){\n\tif(b==0)return a;\n\treturn gcd(b,a%b);\n}\n\nvoid dfs(int x){\n\tvis[x]=true;\n\tfor(int i=1;i<=n;i++){\n\t\tif(vis[i])continue;\n\t\tif(gcd(v[x],v[i])==1)continue;\n\t\tadd_edge(x,i),d[i]++;\n\t\tdfs(i);\n\t}\n}\n\nvoid solve(){\n\tpriority_queue<int> q;\n\tfor(int i=1;i<=n;i++)\n\t\tif(d[i]==0)q.push(i),vis[i]=false;\n\twhile(!q.empty()){\n\t\tint x=q.top();q.pop();\n\t\tfor(int i=h[x];i;i=e[i].next){\n\t\t\tif(!vis[e[i].x])continue;\n\t\t\td[e[i].x]--;\n\t\t\tif(d[e[i].x]==0){\n\t\t\t\tvis[e[i].x]=false;\n\t\t\t\tq.push(e[i].x);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d \",v[x]);\n\t}\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",v+i);\n\tsort(v+1,v+n+1);\n\tfor(int i=1;i<=n;i++)if(!vis[i])dfs(i);\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i, x, y) for(int i = (x); i < (y); ++i)\n#define REP(i, x, y) for(int i = (x); i <= (y); ++i)\n#define MP make_pair\n#define PB push_back\n#define PH push\n#define fst first\n#define snd second\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair<int, int> pii;\n\nconst int INF = 1e9 + 7;\nconst int maxn = 2005;\n\nint n;\nint a[maxn], vis[maxn];\nvector<int> ans;\nvector<int> g[maxn], tr[maxn];\npriority_queue<pii> que;\n\ninline void dfs(int u){\n\tvis[u] = true;\n\tFOR(i, 0, g[u].size()){\n\t\tint v = g[u][i];\n\t\tif(!vis[v]){\n\t\t\tdfs(v);\n\t\t\ttr[u].PB(v);\n\t\t}\n\t}\n\treturn;\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\tFOR(i, 0, n)\n\t\tscanf(\"%d\", a + i);\n\tsort(a, a + n);\n\tFOR(i, 0, n) FOR(j, 0, n) if(i != j && __gcd(a[i], a[j]) != 1)\n\t\tg[i].PB(j);\n\n\tFOR(i, 0, n) if(!vis[i])\n\t\tdfs(i), que.PH(MP(a[i], i));\n\twhile(!que.empty()){\n\t\tint u = que.top().snd;\n\t\tque.pop();\n\t\tans.PB(a[u]);\n\t\tFOR(i, 0, tr[u].size())\n\t\t\tque.PH(MP(a[tr[u][i]], tr[u][i]));\n\t}\n\t\n\tFOR(i, 0, n)\n\t\tprintf(\"%d \", ans[i]);\n\tputs(\"\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nvector<int> v[2222];\nint n,a[2222];\nbool use[2222];\nvector<deque<int> >vd;\npair<int,int> p[2222];\ndeque<int> vv;\ninline void dfs(int x){\n\tif(use[x]) return;\n\tuse[x]=1;\n\tvv.push_back(x);\n\tfor(int i=0;i<v[x].size();++i) dfs(v[x][i]);\n}\nint main(){\n\tint i,j,p,q;\n\tcin>>n;\n\tfor(i=1;i<=n;++i) cin>>a[i];\n\tfor(i=1;i<=n;++i) for(j=1;j<=n;++j) if(__gcd(a[i],a[j])!=1) v[i].push_back(j);\n\tfor(i=1;i<=n;++i) sort(v[i].begin(),v[i].end());\n\tfor(i=1;i<=n;++i) if(!use[i]){\n\t\tvv.clear();\n\t\tdfs(i);\n\t\tvd.push_back(vv);\n\t}\n//\tfor(i=0;i<vd.size();++i){\n//\t\tfor(j=0;j<vd[i].size();++j) cout<<vd[i][j]<<' ';\n//\t\tcout<<endl;\n//\t}\n//\tcout<<\"OK\"<<endl<<endl;\n\tvector<int> ans;\n\tans.clear();\n\tfor(i=1;i<=n;++i){\n\t\tint mx=0;\n\t\tint wz=0;\n\t\tfor(j=0;j<vd.size();++j){\n\t\t\tif(vd[j].size()){\n\t\t\t\tif(a[vd[j][0]]>mx){\n\t\t\t\t\tmx=a[vd[j][0]];\n\t\t\t\t\twz=j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\tfor(p=0;p<vd.size();++p){\n//\t\t\tcout<<vd[p].size()<<\" :  \";\n//\t\t\tfor(q=0;q<vd[p].size();++q) cout<<vd[p][q]<<' ';\n//\t\t\tcout<<endl;\n//\t\t}\n//\t\tcout<<endl;\n//\t\tcout<<mx<<\" \"<<wz<<endl;\n\t\tans.push_back(mx);\n\t\tvd[wz].pop_front();\n\t}\n\tfor(i=0;i<ans.size();++i) cout<<ans[i]<<' ';\n\tcout<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <algorithm>\nusing namespace std;\nint gcd(int a,int b){\n\tif(b==0){\n\t\treturn a;\n\t}\n\treturn gcd(b,a%b);\n}\nint a[2005];\nvector<pair<int,int> > g[2005];\nvector<int> circle[2005];\nbool visit[2005];\npriority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > > q;\nvoid bfs(int s,int tmp){\n\twhile(!q.empty()){\n\t\tq.pop();\n\t}\n\tq.push(make_pair(a[s],s));\n\tint u;\n\tvisit[s]=1;\n\twhile(!q.empty()){\n\t\tu=q.top().second;\n\t\tcircle[tmp].push_back(u);\n\t\tq.pop();\n\t\tfor(int i=0;i<(int)g[u].size();i++){\n\t\t\tif(g[u][i].second==1&&!visit[g[u][i].first]){\n\t\t\t\tvisit[g[u][i].first]=1;\n\t\t\t\tq.push(make_pair(a[g[u][i].first],g[u][i].first));\n\t\t\t}\n\t\t}\n\t}\n}\nbool cmp(vector<int> p,vector<int> q){\n\tfor(int i=0;i<(int)p.size()&&i<(int)q.size();i++){\n\t\tif(p[i]!=q[i]){\n\t\t\treturn p[i]>q[i];\n\t\t}\n\t}\n\treturn p.size()>q.size();\n}\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\tsort(a+1,a+1+n);\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=i+1;j<=n;j++){\n\t\t\tif(i==j){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(gcd(a[i],a[j])>1){\n\t\t\t\tif(a[i]>a[j]){\n\t\t\t\t\tg[j].push_back(make_pair(i,1));\n\t\t\t\t\tg[i].push_back(make_pair(j,0));\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tg[i].push_back(make_pair(j,1));\n\t\t\t\t\tg[j].push_back(make_pair(i,0));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint tmp=0;\n\tfor(int i=1;i<=n;i++){\n\t\tif(!visit[i]){\n\t\t\tbfs(i,++tmp);\n\t\t}\n\t}\n\tsort(circle+1,circle+1+tmp,cmp);\n\tfor(int i=1;i<=tmp;i++){\n\t\tfor(int j=0;j<(int)circle[i].size();j++){\n\t\t\tprintf(\"%d \",a[circle[i][j]]);\n\t\t}\n\t}\n\tputs(\"\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n//author_name:krij\n//date:2018/11/18\n//title:AGC 010 E Rearranging\n//ÒòÎªÇÓÅ³£¬ËùÒÔÌÓ±ÜÉúÃü£¬ÒÔ²»µÖ¿¹ÔÚ×îºÚ°µµÄ³ÁÂÙÖÐÉú³ö½¾°Á£¬ÒòÎª½¾°Á£¬ËùÒÔ²»Ñ¡ÔñÉú£¬ËùÒÔ¾Ü³â´Ö±ÉµÄÀÖ¹ÛÖ÷Òå¡£\n//Ìì²ÅµÄ±¯¾çµØÓÚ±»Ð¡¶øÊæÊÊµÄÃûÍûËùÊø¸¿¡£\n//It's human to lie. Most of the time we can't even be honest with ourselves.\n\nbool done[2020];\nbool e[2020][2020];\nint a[2020];\nint n;\n\ninline vector<int> merge(const vector<int> a,const vector<int> b)\n{\n\tvector<int> ret(a.size()+b.size());\n\tint a1=0,b1=0;\n\twhile(a1<a.size()||b1<b.size())\n\t{\n\t\tif(a1<a.size()&&(b1>=b.size()||b[b1]<a[a1])) ret[a1+b1]=a[a1++];\n\t\telse ret[a1+b1]=b[b1++];\n\t}\n\treturn ret;\n}\n\nvector<int> dfs(int u)\n{\n\tdone[u]=true;\n\tvector<int> ret;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(done[i]||!e[u][i])\n\t\t\tcontinue;\n\t\tvector<int> cur=dfs(i);\n\t\tcur.insert(cur.begin(),a[i]);\n\t\tret=merge(ret,cur);\n\t}\n\treturn ret;\n}\n\nvoid solve()\n{\n\tsort(a,a+n);\n\tfor(int i=0;i<=n;i++)\n\t\tfor(int j=0;j<=n;j++)\n\t\t\tif(i!=j&&(__gcd(a[i],a[j])!=1||i==n||j==n))\n\t\t\t\te[i][j]=e[j][i]=true;\n\tvector<int> ret=dfs(n);\n\tfor(int i=0;i<ret.size();i++)\n\t{\n\t\tif(i) printf(\" \");\n\t\tprintf(\"%d\",ret[i]);\n\t}\n\tprintf(\"\\n\");\n\treturn;\n}\n\nvoid run()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tsolve();\n\treturn;\n}\n\nint main()\n{\n\trun();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint n,a[2100];\nint vis[2100],flag[2100][2100],ind[2100];\npriority_queue<int> que;\nvector<int> vec[2100];\ninline int gcd(int a,int b){\n\tif (!b) return a;\n\treturn gcd(b,a%b);\n}\nvoid dfs(int u){\n    vis[u]=true;\n    for (int i=1;i<=n;i++)\n\t    if (!vis[i]&&flag[u][i]){\n\t        ind[i]++;\n\t        vec[u].push_back(i);\n\t        dfs(i);\n\t    }\n}\nvoid bfs(){\n    for (int i=1;i<=n;i++)\n\t\tif (!ind[i]) que.push(i);\n    while (!que.empty()){\n        int u=que.top(); que.pop();\n        printf(\"%d \",a[u]);\n        for (int i=0;i<(int)vec[u].size();i++) que.push(vec[u][i]);\n    }\n}\nint main(){\n    scanf(\"%d\",&n);\n    for (int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n    sort(a+1,a+n+1);\n    for (int i=1;i<=n;i++)\n\t    for (int j=i+1;j<=n;j++)\n    \t\tif (gcd(a[i],a[j])!=1)\n\t\t\t\tflag[i][j]=flag[j][i]=1;\n    for (int i=1;i<=n;i++)\n\t\tif (!vis[i]) dfs(i);\n\tbfs();\n    return 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "/*************************************************\n *************************************************\n *************************************************\n *** _________________  |            |  |     /***\n ***         |          |            |  |    / ***\n ***         |          |            |  |   /  ***\n ***         |          |            |  |  /   ***\n ***         |          |            |  | /    ***\n ***         |          |____________|  |/  en ***\n ***         |          |            |  |\\     ***\n ***         |          |            |  | \\    ***\n *** _____   |          |            |  |  \\   ***\n ***   |     |          |            |  |   \\  ***\n ***   \\     /          |            |  |    \\ ***\n ***    \\___/           |            |  |     \\***\n *************************************************\n *************Written by: JiangHaoKai*************\n *************************************************/\n\n#pragma GCC optimize(2)\n#pragma G++ optimize(2)\n#pragma comment(linker,\"/STACK:102400000,102400000\")\n\n//#include <bits/stdc++.h>\n#include <cassert>\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdalign>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <string>\n#include <typeinfo>\n#include <valarray>\n#include <vector>\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <scoped_allocator>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <unordered_map>\n#include <unordered_set>\n//#include <conio.h>\n//#include <windows.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned int ui;\ntypedef unsigned long long ull;\ntypedef float fl;\ntypedef double ld;\ntypedef pair<int,int> pii;\n#define ui(n) ((unsigned int)(n))\n#define ll(n) ((long long)(n))\n#define ull(n) ((unsigned long long)(n))\n#define fl(n) ((float)(n))\n#define ld(n) ((double)(n))\n#define char(n) ((char)(n))\n#define Bool(n) ((bool)(n))\n#define fixpoint(n) fixed<<setprecision(n)\nconst int INF=1061109567;\nconst LL LINF=4557430888798830399;\n#define PI 3.1415926535897932384626433832795028841971\n#define MP make_pair\n#define MT make_tuple\n#define All(a) (a).begin(),(a).end()\n#define pall(a) (a).rbegin(),(a).rend()\n#define MOD 1000000007\n#define sz(a) ((int)(a).size())\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define repa(i,a,n) for(int i=a;i<n;i++)\n#define repa1(i,a,n) for(int i=a;i<=n;i++)\n#define repd(i,n) for(int i=n-1;i>=0;i--)\n#define repd1(i,n) for(int i=n;i>=1;i--)\n#define repda(i,n,a) for(int i=n;i>a;i--)\n#define repda1(i,n,a) for(int i=n;i>=a;i--)\n#define FOR(i,a,n,step) for(int i=a;i<n;i+=step)\n#define repv(itr,v) for(__typeof((v).begin()) itr=(v).begin();itr!=(v).end();itr++)\n#define repV(i,v) for(auto i:v)\n#define repE(i,v) for(auto &i:v)\n#define MS(x,y) memset(x,y,sizeof(x))\n#define MC(x) MS(x,0)\n#define MCP(x,y) memcpy(x,y,sizeof(y))\n#define sqr(x) ((x)*(x))\n#define filein(x) freopen(x,\"r\",stdin)\n#define fileout(x) freopen(x,\"w\",stdout)\n#define fileout2(filename,name) ofstream name(filename,ios::out)\n#define filein2(filename,name) ifstream name(filename,ios::in)\n#define file(filename,name) fstream name(filename,ios::in|ios::out)\n#define Pause system(\"pause\")\n#define Cls system(\"cls\")\n#define fs first\n#define sc second\n#define PC(x) putchar(x)\n#define GC(x) x=getchar()\n#define Endl PC('\\n')\n#define SF scanf\n#define PF printf\n\ninline int Read()\n{\n    int X=0,w=0;char ch=0;while(!isdigit(ch)){w|=ch=='-';ch=getchar();}while(isdigit(ch))X=(X<<3)+(X<<1)+(ch^48),ch=getchar();\n\treturn w?-X:X;\n}\ninline void Write(int x){if(x<0)putchar('-'),x=-x;if(x>9)Write(x/10);putchar(x%10+'0');}\n\ninline LL powmod(LL a,LL b){LL res=1;a%=MOD;assert(b>=0);for(;b;b>>=1){if(b&1)res=res*a%MOD;a=a*a%MOD;}return res;}\ninline LL gcdll(LL a,LL b){return b?gcdll(b,a%b):a;}\nconst int dx[]={0,1,0,-1,1,-1,-1,1};\nconst int dy[]={1,0,-1,0,-1,-1,1,1};\n/**************************************************************Begin***************************************************************/\nconst int maxn=2010;\n\nint n,a[maxn],degree[maxn];\nvector<int> e[maxn],g[maxn];\nbool vis[maxn];\n\ninline void dfs(int x)\n{\n\tvis[x]=1;\n\trepV(i,e[x]) if(!vis[i])\n\t{\n\t\tdegree[i]++;\n\t\tg[x].push_back(i);\n\t\tdfs(i);\n\t}\n}\n\ninline void toposort()\n{\n\tpriority_queue<int> q;while(!q.empty()) q.pop();\n\t\n\trep1(i,n) if(!degree[i]) q.push(i);\n\twhile(!q.empty())\n\t{\n\t\tint x=q.top();q.pop();\n\t\tPF(\"%d \",a[x]);\n\t\trepV(i,g[x]) if(--degree[i]==0) q.push(i);\n\t}\n}\n\nint main()\n{\n\tSF(\"%d\",&n);\n\trep1(i,n) SF(\"%d\",&a[i]);\n\tsort(a+1,a+n+1);\n\t\n\trep1(i,n) repa1(j,i+1,n) if(__gcd(a[i],a[j])!=1) e[i].push_back(j),e[j].push_back(i);\n\trep1(i,n) if(!vis[i]) dfs(i);\n\ttoposort();\n\n\treturn 0;\n}\n/***************************************************************End****************************************************************/\n"
  },
  {
    "language": "C++",
    "code": "/*\n██████████████████████████████████████████████████████████████████████████████\n██              ██████    ██████      ██      ██  ██    ██████              ██\n██  ██████████  ██  ██      ██      ██████████████  ██████  ██  ██████████  ██\n██  ██      ██  ██    ██  ████      ██    ██████████    ██  ██  ██      ██  ██\n██  ██      ██  ██    ██  ██      ██  ████        ██  ████  ██  ██      ██  ██\n██  ██      ██  ██  ██████  ████  ████████████  ██    ████████  ██      ██  ██\n██  ██████████  ██  ████  ██    ████    ████  ██████  ████  ██  ██████████  ██\n██              ██  ██  ██  ██  ██  ██  ██  ██  ██  ██  ██  ██              ██\n████████████████████  ██  ██    ██████  ██    ████  ████    ██████████████████\n██████  ████          ████        ██    ██    ████  ████████  ██          ████\n████  ██      ██  ██      ██  ██████  ████  ████    ██    ████    ████████  ██\n██      ██      ██    ██    ████      ████        ██████  ██      ██  ██    ██\n██  ██    ████████████  ████  ██  ████            ████  ████████████  ████  ██\n██  ██      ██  ██  ████    ████████                ████████      ██  ██    ██\n██  ██  ██  ██████████  ████    ██  ████  ██    ████  ████        ████  ██  ██\n██    ██  ████  ██████  ██    ******************    ████  ██            ██  ██\n██    ██████  ██  ██████      * Scan this QR   *██████    ██  ██  ██  ████████\n████  ████  ██  ██████      ██* code to join   *██  ████    ██  ████████  ████\n██████      ████████  ██      * in the Three   *██  ████          ████  ██  ██\n████              ████  ████  * Body ETO.      *  ████        ██  ████  ██  ██\n██████  ██    ████████        *  --ETO manager *██  ██                ██    ██\n████    ██  ██  ██    ██████  *    Ye Wenjie   *████  ████  ██  ████  ██  ████\n██  ████  ██████    ████  ██  *ETO(C),1988~2018*      ██  ██  ██  ██    ██████\n██  ██████  ██  ████    ██  ██******************          ██████    ██████  ██\n██  ██  ██    ████    ██        ██  ██        ████████      ████  ██  ██    ██\n████████████    ██    ██████  ██████████  ██  ████  ██████████    ██  ██  ████\n██████████    ██  ████  ██        ██    ██████████  ██    ██      ██  ██    ██\n██    ██  ████    ██  ████  ████      ██████    ██    ██      ██  ██  ████  ██\n██████  ██  ██████  ██            ██████████  ██    ██    ████  ████  ██    ██\n██      ██████  ████  ████  ████      ████    ████  ████            ██████████\n██████████████████      ██  ██  ████  ██    ██  ██    ████  ██████    ██    ██\n██              ██        ████████████  ████  ██  ██  ██    ██  ██      ██  ██\n██  ██████████  ██    ████  ██████  ██  ██████████████      ██████    ██  ████\n██  ██      ██  ████████    ██  ██      ████  ████  ██              ████  ████\n██  ██      ██  ████  ████  ████  ██████  ██████████████  ██████████    ██  ██\n██  ██      ██  ██    ██████  ██  ██  ██████████  ██  ██      ████    ██    ██\n██  ██████████  ██████  ████            ██    ████████  ██  ████    ██████████\n██              ██████    ████  ████████  ██  ████    ██    ██  ████  ████  ██\n██████████████████████████████████████████████████████████████████████████████\n    扫    描    二    维    码    加    入    三    体    E    T    O\n*/\n/*****************\n *   I<3   C++   *\n *  IWANT ANYAC  *\n * ILOVEPROGRAM! *\n *IT'SINTERESTING*\n * ILOVEPROGRAM! *\n *  INCONTESTS   *\n *   GETSCORE    *\n *    ACCODE     *\n *     LETS      *\n *      GO       *\n *Written by:    *\n *    charlieyan *\n *****************/\n#include <assert.h>\n#include <ctype.h>\n#include <errno.h>\n#include <float.h>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <locale>\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <wchar.h>\n#include <wctype.h>\n#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <cerrno>\n#include <clocale>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <limits>\n#include <map>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <istream>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <utility>\n#include <vector>\n#include <cwchar>\n#include <cwctype>\n#include <numeric>\n#include <list>\n#define LL long long\n#define pb push_back\n#define pob pop_back\n#define mp make_pair\n#define FILL(a,v) memset((void*)a,v,sizeof(a))\n#define FILL0(a) FILL(a,0)\n#define FILL1(a) FILL(a,-1)\n#define FILLBIG(a) FILL(a,0x3f)\n#define ALL(a) (a).begin(),(a).end()\n#define Inf ((int)0x3f3f3f3f)\n#define INF ((long long)0x3f3f3f3f3f3f3f3f)\n#define Mod 1000000007\n#define foreach(it,x) for(__typeof(x.begin()) it=x.begin();it!=x.end();it++)\n#define FOR(i,x) for(int i=0;i<x;i++)\n#define RFOR(i,x) for(int i=x-1;i>=0;i--)\n#define FFOR(i,a,b) for(int i=a;i<b;i++)\n#define FRFOR(i,a,b) for(int i=a-1;i>=b;i--)\n#define SZ(a) ((int)(a).size())\n#define FI first\n#define SE second\n#define OVER(...) return printf(__VA_ARGS__),0\n#define fastio ios::sync_with_stdio(0)\n#define filei(f) freopen(f,\"r\",stdin)\n#define fileo(f) freopen(f,\"w\",stdout)\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define MASK(a) (1<<(a))\n#define MASKX(x,a) ((x)<<(a))\n#define BIT(a,b) (((a)>>(b))&1)\n#define cddx(a) priority_queue<a >\n#define cxdd(a) priority_queue<a,vector<a >,greater<a > >\n#define deval(a) {cerr<<#a<<\" = \"<<a<<endl;}\n#define dearr(be,en) {cerr<<#be;cerr<<\" = {\";for(auto i=be;i!=en;i++)cerr<<' '<<*i;cerr<<\" }\\n\";}\n#define reg register\n#define prtime eprintf(\"\\n\\nTime used: %dms\\n\",clock());\n#define PI 3.1415926535897932384626\n#define TODEG(a) (a*180/PI)\n#define y0 ykangjimutigeidiqiuyipianjingtu\n#define y1 yxiaomiexuduhuanrenleiwannianankang\n#define endl '\\n'\n//抗击母体，给地球一片净土\n//消灭徐毒，还人类万年安康\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef unsigned long long UINT;\ntypedef unsigned int uint;\ntypedef long long INT;\ntypedef long double ldouble;\ntypedef pair<INT,INT> PII;\ntypedef stringstream sst;\ntypedef istringstream iss;\ntypedef vector<int> vint;\ntypedef vector<INT> VINT;\ntypedef vector<pii> vpii;\ntypedef vector<PII> VPII;\ntypedef priority_queue<int> pqi;\ntypedef priority_queue<INT> PQI;\ntypedef priority_queue<pii> pqp;\ntypedef priority_queue<PII> PQP;\ntypedef priority_queue<int,vint,greater<int> > xqi;\ntypedef priority_queue<INT,VINT,greater<INT> > XQI;\ntypedef priority_queue<pii,vpii,greater<pii> > xqp;\ntypedef priority_queue<PII,VPII,greater<PII> > XQP;\nstruct fastIO\n{\n\tinline fastIO operator>>(int& num)\n\t{\n\t\tnum=0;\n\t\tchar c=getchar();\n\t\twhile(c!='-'&&(c<'0'||c>'9'))c=getchar();\n\t\tbool foo=0;\n\t\tif(c=='-')\n\t\t{\n\t\t\tfoo=1;\n\t\t\tc=getchar();\n\t\t}\n\t\twhile(c>='0'&&c<='9')\n\t\t{\n\t\t\tnum=(num<<3)+(num<<1)+c-'0';\n\t\t\tc=getchar();\n\t\t}\n\t\tif(foo)num=-num;\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(INT& num)\n\t{\n\t\tnum=0;\n\t\tchar c=getchar();\n\t\twhile(c!='-'&&(c<'0'||c>'9'))c=getchar();\n\t\tbool foo=0;\n\t\tif(c=='-')\n\t\t{\n\t\t\tfoo=1;\n\t\t\tc=getchar();\n\t\t}\n\t\twhile(c>='0'&&c<='9')\n\t\t{\n\t\t\tnum=(num<<3)+(num<<1)+c-'0';\n\t\t\tc=getchar();\n\t\t}\n\t\tif(foo)num=-num;\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(float& num)\n\t{\n\t\tscanf(\"%f\",&num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(double& num)\n\t{\n\t\tscanf(\"%lf\",&num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(long double& num)\n\t{\n\t\tscanf(\"%Lf\",&num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(char& num)\n\t{\n\t\tnum=getchar();\n\t\twhile(num==' '||num=='\\n')num=getchar();\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(char* num)\n\t{\n\t\tint cnt=0;\n\t\tchar c=getchar();\n\t\twhile(c==' '||c=='\\n')c=getchar();\n\t\twhile(c!=' '&&c!='\\n')\n\t\t{\n\t\t\tnum[cnt++]=c;\n\t\t\tc=getchar();\n\t\t}\n\t\tnum[cnt]=0;\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(string& num)\n\t{\n\t\tcin>>num;\n\t\treturn *this;\n\t}\n\tinline void printInt(const int& num)\n\t{\n\t\tif(num<10)\n\t\t{\n\t\t\tputchar(num+'0');\n\t\t\treturn;\n\t\t}\n\t\tprintInt(num/10);\n\t\tputchar((num%10)+'0');\n\t}\n\tinline void printINT(const INT& num)\n\t{\n\t\tif(num<10)\n\t\t{\n\t\t\tputchar(num+'0');\n\t\t\treturn;\n\t\t}\n\t\tprintINT(num/10);\n\t\tputchar((num%10)+'0');\n\t}\n\tinline fastIO operator<<(const int& num)\n\t{\n\t\tif(num<0)putchar('-'),printInt(-num);\n\t\telse printInt(num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const INT& num)\n\t{\n\t\tif(num<0)putchar('-'),printINT(-num);\n\t\telse printINT(num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const float& num)\n\t{\n\t\tprintf(\"%.10f\",num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const double& num)\n\t{\n\t\tprintf(\"%.16lf\",num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const long double& num)\n\t{\n\t\tprintf(\"%.20Lf\",num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const char& num)\n\t{\n\t\tputchar(num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const char* num)\n\t{\n\t\tfor(int i=0;num[i];i++)\n\t\t\tputchar(num[i]);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const string& num)\n\t{\n\t\tcout<<num;\n\t\treturn *this;\n\t}\n}fio;\n//Coded by Charlieyan\n//版权所有，翻印必究\n\nvector<int> nei[2005],nei2[2005];\nint num[2005];\nbool SortComp13(int a,int b){\n\treturn num[a]<num[b];\n}\n\nbool lgl[2005];\nvector<int> ltks[2005];\nint ans[2005];\n\nvoid dfs(int now,int ltk){\n\tif(lgl[now]){\n\t\treturn;\n\t}\n\tlgl[now]=1;\n\tltks[ltk].pb(now);\n\tfor(int i=0;i<SZ(nei[now]);i++){\n\t\tif(!lgl[nei[now][i]]){\n\t\t\tdfs(nei[now][i],ltk);\n\t\t\tnei2[now].pb(nei[now][i]);\n\t\t}\t\n\t}\n}\n\nint n;\n\nint gcd(int a,int b){\n\treturn !b?a:gcd(b,a%b);\n}\n\nint main(){\n\tfio>>n;\n\tfor(int i=0;i<n;i++){\n\t\tfio>>num[i];\n\t}\n\tsort(num,num+n);\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(gcd(num[i],num[j])!=1){\n\t\t\t\tnei[i].pb(j);\n\t\t\t}\n\t\t}\n\t}\n\tint cntltk=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(!lgl[i]){\n\t\t\tdfs(i,cntltk++);\n\t\t}\n\t}\n\tpriority_queue<pii> pq;\n\tfor(int i=0;i<cntltk;i++){\n\t\tpq.push(mp(num[ltks[i][0]],ltks[i][0]));\n\t}\n\tint N=0;\n\twhile(SZ(pq)){\n\t\tpii fff=pq.top();\n\t\tpq.pop();\n\t\tint Num=fff.first,x=fff.second;\n\t\tans[N++]=Num;\n\t\tfor(int i=0;i<SZ(nei2[x]);i++){\n\t\t\tpq.push(mp(num[nei2[x][i]],nei2[x][i]));\n\t\t}\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tprintf(\"%d%c\",ans[i],i==N-1?'\\n':' ');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#if 0\ndate +%Y.%m.%d\n\n题解先咕着。\n#endif\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n\ntypedef std::pair<int, int> Par;\ninline int input() { int x; scanf(\"%d\", &x); return x; }\n\nconst int maxn = 2020;\nint du[maxn];\nint a[maxn];\nbool link[maxn][maxn];\nbool vis[maxn];\nstd::vector<int> G[maxn];\n\nvoid dfs(int u, int n) {\n\tvis[u] = true;\n\tfor(int v = 1; v <= n; v ++)\n\t\tif(not vis[v] and link[u][v] and u != v) {\n\t\t\tlink[u][v] = link[v][u] = false;\n\t\t\t// debug(\"%d -> %d\\n\", u, v);\n\t\t\tG[u].push_back(v);\n\t\t\tdu[v] ++;\n\t\t\tdfs(v, n);\n\t\t}\n}\n\nint main() {\n\tint n = input();\n\tfor(int i = 1; i <= n; i ++)\n\t\ta[i] = input();\n\tstd::sort(a + 1, a + n + 1);\n\tfor(int i = 1; i <= n; i ++)\n\t\tfor(int j = 1; j <= n; j ++)\n\t\t\tif(std::__gcd(a[i], a[j]) > 1)\n\t\t\t\tlink[i][j] = true;\n\tfor(int i = 1; i <= n; i ++)\n\t\tif(not vis[i])\n\t\t\tdfs(i, n);\n\tstd::priority_queue<Par> q;\n\tfor(int i = 1; i <= n; i ++)\n\t\tq.push(Par(- du[i], i));\n\twhile(not q.empty()) {\n\t\tint d = - q.top().first, u = q.top().second;\n\t\tq.pop();\n\t\tif(d != du[u]) continue;\n\t\tfor(int v : G[u]) {\n\t\t\tdu[v] --;\n\t\t\tq.push(Par(- du[v], v));\n\t\t}\n\t\tprintf(\"%d \", a[u]);\n\t}\n\tputs(\"\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define LL long long\n#define RG register\n\nusing namespace std;\ntemplate<class T> T gi() {\n\tT x = 0; bool f = 0; char c = getchar();\n\twhile (c != '-' && (c < '0' || c > '9')) c = getchar();\n\tif (c == '-') f = 1, c = getchar();\n\twhile (c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n\treturn f ? -x : x;\n}\nconst int N = 2010;\nstruct node { int to, nxt; } g[N * N];\nint lst[N], gl, a[N];\nvoid add(int x, int y) { g[++gl] = (node) {y, lst[x]}; lst[x] = gl; }\nstruct cmp1 {\n\tbool operator () (int x, int y) const {\n\t\treturn a[x] < a[y];\n\t}\n};\npriority_queue<int, vector<int>, cmp1> q[N];\npriority_queue<pair<int, int> > p;\nint fa[N], mn[N];\nint find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }\nbool vis[N];\nint main() {\n\t//freopen(\".in\", \"r\", stdin);\n\t//freopen(\".out\", \"w\", stdout);\n\tint n = gi<int>();\n\tfor (int i = 1; i <= n; i++) a[i] = gi<int>(), fa[i] = i, mn[i] = a[i];\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 1; j <= n; j++)\n\t\t\tif (a[i] < a[j] && __gcd(a[i], a[j]) > 1) {\n\t\t\t\tadd(i, j), add(j, i);\n\t\t\t\tmn[find(i)] = min(mn[find(i)], mn[find(j)]);\n\t\t\t\tfa[find(j)] = find(i);\n\t\t\t}\n\tfor (int i = 1; i <= n; i++)\n\t\tif (mn[find(i)] == a[i]) {\n\t\t\tp.push(make_pair(a[i], find(i))), vis[i] = 1;\n\t\t\tq[find(i)].push(i);\n\t\t}\n\twhile (!p.empty()) {\n\t\tpair<int, int> u = p.top(); p.pop();\n\t\tprintf(\"%d \", u.first);\n\t\tint x = q[u.second].top(); q[u.second].pop();\n\t\tfor (int i = lst[x]; i; i = g[i].nxt) {\n\t\t\tint v = g[i].to;\n\t\t\tif (!vis[v]) q[u.second].push(v), vis[v] = 1;\n\t\t}\n\t\tif (!q[u.second].empty()) p.push(make_pair(a[q[u.second].top()], u.second));\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=2005;\nint n,b[N][N],flag2[N],a[N],flag[N];\npriority_queue<int>q;\nvector<int>Ans[N];\nvoid dfs(int x){\n\tflag2[x]=1;\n\tfor (int i=1;i<=n;i++)\n\t\tif (!flag2[i]&&b[x][i]){\n\t\t\tflag[i]++;\n\t\t\tAns[x].push_back(i);\n\t\t\tdfs(i);\n\t\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n\tsort(a+1,a+n+1);\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=i+1;j<=n;j++)\n\t\t\tif (__gcd(a[i],a[j])!=1)b[i][j]=b[j][i]=1;\n\tfor (int i=1;i<=n;i++)\n\t\tif (!flag2[i])dfs(i);\n\tfor (int i=1;i<=n;i++)\n\t\tif (!flag[i])q.push(i);\n\twhile (!q.empty()){\n\t\tint now=q.top();\n\t\tq.pop();\n\t\tprintf(\"%d \",a[now]);\n\t\tfor (int i=0;i<Ans[now].size();i++)q.push(Ans[now][i]);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<set>\n#include<unordered_set>\n#define lol(i,n) for(ll i=0;i<n;i++)\n#define mod 1000000007\n#define chmax(a,b) a=max(a,b);\n#define chmin(a,b) a=min(a,b);\ntypedef long long ll;\n\nusing namespace std;\nll gcd(ll a,ll b){\n  if(a<b)swap(a,b);\n  if(b==0)return a;\n  return gcd(a%b,b);\n}\n#define N 2010\nll b[N],a[N],n;\nvector<ll> g[N];\n\nclass Aoki{\n  public:\n  ll nz[N];\n  void buildg(){\n    lol(i,n)g[i].clear();\n    lol(i,n)lol(j,i){\n      if(gcd(b[i],b[j])>1){\n\tg[j].push_back(i);\n\tnz[i]++;\n      }\n    }\n  }\n  void main(){\n    lol(i,n)nz[i]=0;\n    buildg();\n    //cout<<\"b=\";lol(i,n)cout<<b[i]<<\" \";cout<<endl;\n    //lol(i,n)cout<<nz[i]<<\" \";cout<<endl;\n    priority_queue<pair<ll,ll> >Q;\n    lol(i,n)if(nz[i]==0)Q.push(make_pair(b[i],i));\n    vector<ll> res;\n    unordered_set<ll> vis;\n    while(!Q.empty()){\n      ll val=Q.top().first;\n      ll x=Q.top().second;\n      Q.pop();\n      if(vis.find(x)!=vis.end())continue;\n      vis.insert(x);\n      res.push_back(val);\n      for(auto y:g[x]){\n\tnz[y]--;\n\tif(nz[y]==0)Q.push(make_pair(b[y],y));\n      }\n    }\n    lol(i,n){\n      if(i)cout<<\" \";\n      cout<<res[i];\n    }cout<<endl;\n  }\n};Aoki kensho;\n\nclass Takahashi{\n  public:\n  void buildg(){\n    lol(i,n)lol(j,n){\n      if(i!=j&&gcd(a[i],a[j])>1){\n\tg[i].push_back(j);\n      }\n    }\n  }\n  unordered_set<ll> vis;\n  ll dfs(ll x){\n    if(vis.find(x)!=vis.end())return mod;\n    vis.insert(x);\n    ll res=x;\n    for(auto y:g[x]){\n      chmin(res,dfs(y));\n    }\n    return res;\n  }\n  ll ma[N];\n  void upd(ll x,ll val){\n    if(~ma[x])return;\n    ma[x]=val;\n    for(auto y:g[x]){\n      upd(y,val);\n    }\n  }\n  void main(){\n    buildg();\n    //cout<<\"buildend\"<<endl;\n    lol(i,n)ma[i]=-1;\n    lol(i,n){\n      if(vis.find(i)!=vis.end())continue;\n      upd(i,dfs(i));\n    }\n    //cout<<\"ma=\";lol(i,n)cout<<ma[i]<<\" \";cout<<endl;\n    //cout<<\"dfsend\"<<endl;\n    priority_queue<ll,vector<ll>,greater<ll> >Q;\n    lol(i,n){\n      if(i==ma[i])Q.push(i);\n    }\n    vector<ll> res;\n    vis.clear();\n    while(!Q.empty()){\n      ll x=Q.top(); Q.pop();\n      if(vis.find(x)!=vis.end())continue;\n      vis.insert(x);\n      res.push_back(x);\n      for(auto y:g[x]){\n\tQ.push(y);\n      }\n    }\n    //cout<<\"#\"<<res.size()<<endl;\n    //cout<<\"a=\";lol(i,n)cout<<res[i]<<\" \";cout<<endl;\n    lol(i,n)b[i]=a[res[i]];\n  }\n};Takahashi chokudai;\n\nint main(){\n    cin>>n;\n    lol(i,n)cin>>a[i];\n    sort(a,a+n);\n    chokudai.main();\n    //cout<<\"chokudai-end\"<<endl;\n    kensho.main();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=2005;\nint l,f[N],n,b[N][N],flag2[N],a[N],flag[N];\nvector<int>Ans[N];\ninline void down(int x){\n\tint i=x;\n\tif (x*2<=l&&f[x*2]>f[x])i=x*2;\n\tif (x*2<l&&f[x*2+1]>f[i])i=x*2+1;\n\tif (i!=x){\n\t\tswap(f[x],f[i]);\n\t\tdown(x);\n\t}\n}\ninline void up(int x){\n\tif (x==1)return;\n\tif (f[x]>f[x/2]){\n\t\tswap(f[x],f[x/2]);\n\t\tup(x/2);\n\t}\n}\ninline void dfs(int x){\n\tflag2[x]=1;\n\tfor (int i=1;i<=n;i++)\n\t\tif (!flag2[i]&&b[x][i]){\n\t\t\tflag[i]++;\n\t\t\tAns[x].push_back(i);\n\t\t\tdfs(i);\n\t\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n\tsort(a+1,a+n+1);\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=i+1;j<=n;j++)\n\t\t\tif (__gcd(a[i],a[j])!=1)b[i][j]=b[j][i]=1;\n\tfor (int i=1;i<=n;i++)\n\t\tif (!flag2[i])dfs(i);\n\tfor (int i=1;i<=n;i++)\n\t\tif (!flag[i])f[++l]=i,up(l);\n\twhile (l){\n\t\tint now=f[1];\n\t\tf[1]=f[l--];\n\t\tdown(1);\n\t\tprintf(\"%d \",a[now]);\n\t\tfor (int i:Ans[now])f[++l]=i,up(l);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#define SF scanf\n#define PF printf\n#define MAXN 2010\nusing namespace std;\ntypedef long long ll;\nint n,cnt[MAXN];\nll a[MAXN];\nvector<int> b[MAXN],c[MAXN];\npriority_queue<pair<ll,int> > qx;\nll gcd(ll x,ll y){\n\tif(y==0)\n\t\treturn x;\n\treturn gcd(y,x%y);\t\n}\nint d[MAXN];\nbool vis[MAXN];\nvoid dfs(int x){\n\tvis[x]=1;\n\tfor(int i=0;i<int(b[x].size());i++)\n\t\tif(vis[b[x][i]]==0){\n\t\t\tc[x].push_back(b[x][i]);\n\t\t\td[b[x][i]]++;\n\t\t\tdfs(b[x][i]);\n\t\t\tbreak;\n\t\t}\n}\t\npriority_queue<pair<ll,int> > q;\nint main(){\n\t//freopen(\"newgame.in\",\"r\",stdin);\n\t//freopen(\"newgame.out\",\"w\",stdout);\n\tSF(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t\tSF(\"%lld\",&a[i]);\n\tsort(a+1,a+1+n);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(i!=j&&gcd(a[i],a[j])!=1ll)\n\t\t\t\tb[i].push_back(j);\n\tfor(int i=1;i<=n;i++)\n\t\tif(vis[i]==0)\n\t\t\tdfs(i);\n\tfor(int i=1;i<=n;i++)\n\t\tif(d[i]==0)\n\t\t\tq.push(make_pair(a[i],i));\n\twhile(!q.empty()){\n\t\tPF(\"%lld \",q.top().first);\t\n\t\tint x=q.top().second;\n\t\tq.pop();\n\t\tfor(int i=0;i<int(c[x].size());i++){\n\t\t\td[c[x][i]]--;\n\t\t\tif(d[c[x][i]]==0)\n\t\t\t\tq.push(make_pair(a[c[x][i]],c[x][i]));\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long ll;\nll gi(){\n\tll x=0,f=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch))f^=ch=='-',ch=getchar();\n\twhile(isdigit(ch))x=x*10+ch-'0',ch=getchar();\n\treturn f?x:-x;\n}\nint n,A[2010],vis[2010];\nstd::vector<int>G[2010];\nstruct cmp{bool operator()(int a,int b){return A[a]<A[b];}};\nstd::priority_queue<int,std::vector<int>,cmp>que;\nvoid dfs(int x){\n\tvis[x]=1;\n\tfor(int i=1;i<=n;++i)if(!vis[i]&&std::__gcd(A[x],A[i])>1)dfs(i),G[x].push_back(i);\n}\nint main(){\n#ifdef XZZSB\n\tfreopen(\"in.in\",\"r\",stdin);\n\tfreopen(\"out.out\",\"w\",stdout);\n#endif\n\tn=gi();\n\tfor(int i=1;i<=n;++i)A[i]=gi();\n\tstd::sort(A+1,A+n+1);\n\tfor(int i=1;i<=n;++i)if(!vis[i])que.push(i),dfs(i);\n\tmemset(vis,0,sizeof vis);\n\twhile(!que.empty()){\n\t\tint x=que.top();vis[x]=1;printf(\"%d \",A[x]);que.pop();\n\t\tfor(int i:G[x])que.push(i),vis[i]=1;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define ll long long\n#define REP(a,b,c) for(int a=b;a<=c;a++)\n#define re register\n#define file(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)\ntypedef pair<int,int> pii;\n#define mp make_pair\ninline int gi()\n{\n\tint f=1,sum=0;char ch=getchar();\n\twhile(ch>'9' || ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0' && ch<='9'){sum=(sum<<3)+(sum<<1)+ch-'0';ch=getchar();}\n\treturn f*sum;\n}\nconst int N=2010;\nint n,a[N],d[N],ans[N],vis[N];\nvector<int>G[N],g[N];\nvoid Add(int u,int v){d[v]++;g[u].push_back(v);}\nvoid dfs(int u){vis[u]=1;for(int v:G[u])if(!vis[v])Add(u,v),dfs(v);}\npriority_queue<int>q;\nint main()\n{\n\tn=gi();\n\tfor(int i=1;i<=n;i++)a[i]=gi();\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\tif(__gcd(a[i],a[j])!=1)G[i].push_back(j),G[j].push_back(i);\n\tfor(int i=1;i<=n;i++)if(!vis[i])dfs(i);\n\tfor(int i=1;i<=n;i++)if(!d[i])q.push(i);\n\tint tot=0;\n\twhile(!q.empty())\n\t{\n\t\tint u;ans[++tot]=u=q.top();q.pop();\n\t\tfor(int v:g[u])\n\t\t\tif(!--d[v])q.push(v);\n\t}\n\tfor(int i=1;i<=n;i++)printf(\"%d%c\",a[ans[i]],i==n?'\\n':' ');\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n//author_name:w4y \n//date:2018/11/18\n//title:AGC 010 E Rearranging\n//ÒòÎªÇÓÅ³£¬ËùÒÔÌÓ±ÜÉúÃü£¬ÒÔ²»µÖ¿¹ÔÚ×îºÚ°µµÄ³ÁÂÙÖÐÉú³ö½¾°Á£¬ÒòÎª½¾°Á£¬ËùÒÔ²»Ñ¡ÔñÉú£¬ËùÒÔ¾Ü³â´Ö±ÉµÄÀÖ¹ÛÖ÷Òå¡£\n//Ìì²ÅµÄ±¯¾çµØÓÚ±»Ð¡¶øÊæÊÊµÄÃûÍûËùÊø¸¿¡£\n//It's human to lie. Most of the time we can't even be honest with ourselves.\n\nbool d[2020][2020];\nint a[2020];\nbool used[2020];\nint ans[2020];\nvector<int> ord;\nint bloc[2020];\nint n;\n\nvoid dfs(int u)\n{\n\tused[u]=true;\n\tord.push_back(u);\n\tfor(int i=0;i<n;i++)\n\t\tif(d[i][u]&&!used[i])\n\t\t\tdfs(i);\n\treturn;\n}\n\t\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin>>n;\n\tfor(int i=0;i<n;i++)\n\t\tcin>>a[i];\n\tsort(a,a+n);\n\tfor(int i=0;i<n;i++)\n\t\tfor(int j=i+1;j<n;j++)\n\t\t\tif(__gcd(a[i],a[j])>1)\n\t\t\t\td[i][j]=d[j][i]=true;\n\tfor(int i=0;i<n;i++) if(!used[i])\n\t\tdfs(i);\n\tfor(int i=0;i<n;i++)\n\t\tfor(int j=i+1;j<n;j++)\n\t\t\tif(d[ord[i]][ord[j]])\n\t\t\t\tbloc[ord[j]]++;\n\tmemset(used,0,sizeof used);\n\tfor(int z=0;z<n;z++)\n\t{\n\t\tfor(int i=n-1;i>=0;--i)\n\t\t{\n\t\t\tif(used[i]||bloc[i]) continue;\n\t\t\tans[z]=i;\n\t\t\tint pos=0;\n\t\t\twhile(ord[pos]!=i) pos++;\n\t\t\tfor(int j=pos+1;j<n;j++)\n\t\t\t\tif(d[i][ord[j]])\n\t\t\t\t\tbloc[ord[j]]--;\n\t\t\tused[i]=true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)\n\t\tcout<<a[ans[i]]<<\" \";\n\tcout<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n\nconst int maxn = 2010;\nconst int SZ = 2e5;\n\nint N;\nvi prs;\n\nint A[maxn];\nbool us[maxn], vis[SZ];\nvi g[SZ];\n\nvoid dfs(int v, vi &vec, vi &cmp) {\n\tvis[v] = 1;\n\tif (v < N) {\n\t\tcmp.pb(v);\n\t}\n\n\tfor (int to : g[v]) {\n\t\tif (!vis[to]) {\n\t\t\tdfs(to, vec, cmp);\n\t\t}\n\t}\n}\n\nvi merge(vi va, vi vb) {\n\tvi res;\n\tint tm = va.size() + vb.size();\n\tva.pb(-1);\n\tvb.pb(-1);\n\n\tint i1 = 0, i2 = 0;\n\n\trep(i, tm) {\n\t\tif (va[i1] > vb[i2]) {\n\t\t\tres.pb(va[i1++]);\n\t\t} else {\n\t\t\tres.pb(vb[i2++]);\n\t\t}\n\t}\n\n\treturn res;\n}\n\nvi decide(int ban, vi cand) {\n\tvi res;\n\tif (cand.size() == 0) {\n\t\treturn res;\n\t}\n\n\tint mini = 1e9;\n\tint piv = -1;\n\n\tfor (int t : cand) {\n\t\tif (ban == 0 || __gcd(A[t], ban) != 1) {\n\t\t\tif (mini > A[t]) {\n\t\t\t\tmini = A[t];\n\t\t\t\tpiv = t;\n\t\t\t}\n\t\t}\n\t}\n\n\tvi nx;\n\tfor (int t : cand) if (t != piv) {\n\t\tnx.pb(t);\n\t}\n\n\tvi cmp(N);\n\n\tfor (int v : nx) {\n\t\tvis[v] = 0;\n\t\tfor (int to : g[v]) {\n\t\t\tvis[to] = 0;\n\t\t}\n\t}\n\n\tfor (int t : nx) if (!cmp[t]) {\n\t\tvi vec;\n\t\tdfs(t, nx, vec);\n\t\tfor (int i : vec) {\n\t\t\tcmp[i] = 1;\n\t\t}\n\t\tvi sub = decide(mini, vec);\n\t\tres = merge(res, sub);\n\t}\n\n\tres.insert(res.begin(), mini);\n\n\treturn res;\n}\n\nint main() {\n\tcin >> N;\n\tfor (int i = 2; i <= 10000; ++i) {\n\t\tbool f = 1;\n\t\tfor (int j = 2; j * j <= i; ++j) {\n\t\t\tif (i % j != 0) {\n\t\t\t\tf = 0;\n\t\t\t}\n\t\t}\n\t\tif (f) {\n\t\t\tprs.pb(i);\n\t\t}\n\t}\n\n\tvi np;\n\n\trep(i, N) {\n\t\tcin >> A[i];\n\t\tint x = A[i];\n\t\tfor (int v : prs) {\n\t\t\twhile (x % v == 0) {\n\t\t\t\tx /= v;\n\t\t\t}\n\t\t}\n\t\tif (x != 1) {\n\t\t\tnp.pb(x);\n\t\t}\n\t}\n\n\tsort(ALL(np));\n\tnp.erase(unique(ALL(np)), np.end());\n\tfor (int p : np) {\n\t\tprs.pb(p);\n\t}\n\n\trep(i, N) {\n\t\tint x = A[i];\n\t\trep(j, prs.size()) if (A[i] % prs[j] == 0) {\n\t\t\tg[i].pb(j + N);\n\t\t\tg[j + N].pb(i);\n\t\t}\n\t}\n\n\tvector<vi> vec;\n\tvi vx, ans;\n\trep(i, N) vx.pb(i);\n\n\trep(i, N) {\n\t\tif (!us[i]) {\n\t\t\tvi v;\n\t\t\tdfs(i, vx, v);\n\t\t\tfor (int a : v) {\n\t\t\t\tus[a] = 1;\n\t\t\t}\n\t\t\tauto res = decide(0, v);\n\t\t\tans = merge(ans, res);\n\t\t}\n\t}\n\n\trep(i, N) printf(\"%d%c\", ans[i], i == N - 1 ? '\\n' : ' ');\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\nconst int N=100010,M=1000010,P=1e9+7;\nconst int inf=0x3f3f3f3f;\nconst int INF=0xcfcfcfcf;\nconst double eps=1e-9,pi=asin(1)*2;\ninline ll read();\n#define cmax(a,b) a=max(a,b)\n#define cmin(a,b) a=min(a,b)\ninline int ADD(int a,int b) { return a+b>=P?a+b-P:a+b; }\ninline int MINUS(int a,int b) { return a-b<0?a-b+P:a-b; }\n#define plus(a,b) a=ADD(a,b)\n#define minus(a,b) a=MINUS(a,b)\n#define mul(a,b) a=(1ll*a*(b))%P\n#define mem(a,b) memset(a,b,sizeof(a))\n#define pii pair<int,int>\n#define pil pair<int,ll>\n#define pli pair<ll,int>\n#define pll pair<ll,ll>\n#define mp(x,y) make_pair(x,y)\n\ninline int gcd(int x,int y) { return y?gcd(y,x%y):x; }\nint head[N],ver[M],nxt[M],du[N];\nint n,m,tot=1;\nint a[N];\ninline void add(int x,int y)\n{\n\tver[++tot]=y,nxt[tot]=head[x],head[x]=tot,du[y]++;\n}\n\nbool G[2010][2010];\nbool visit[N];\ninline void dfs(int x)\n{\n\tvisit[x]=true;\n\tfor(int y=1;y<=n;y++)\n\t{\n\t\tif(visit[y]||!G[x][y]) continue;\n\t\tadd(x,y);\n\t\tdfs(y);\n\t}\n}\npriority_queue<int> q;\n\n#ifdef FILE\nconst int READ_SIZE=1<<20;\nchar buf[READ_SIZE],*p1=buf,*p2=buf;\n#define getchar() p1==p2&&(p2=(p1=buf)+fread(buf,1,READ_SIZE,stdin),p1==p2)?EOF:*p1++\n#endif\ninline ll read()\n{\n\tll s=0;\n\tbool flag=false;\n\tchar ch=getchar();\n\tfor(;ch<'0'||ch>'9';ch=getchar()) if(ch=='-') flag=true;\n\tfor(;'0'<=ch&&ch<='9';ch=getchar()) s=(s<<3)+(s<<1)+(ch^'0');\n\tif(flag) return -s;\n\treturn s;\n}\n\nint main()\n{\n#ifdef FILE\n\tfreopen(FILE \".in\",\"r\",stdin);\n\tfreopen(FILE \".out\",\"w\",stdout);\n#endif\n\tn=read();\n\tfor(int i=1;i<=n;i++) a[i]=read();\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(a[i]<a[j]&&gcd(a[i],a[j])>1)\n\t\t\t\tG[i][j]=G[j][i]=true;\n\tfor(int i=1;i<=n;i++)\n\t\tif(!visit[i]) dfs(i);\n\t\n\twhile(q.size()) q.pop();\n\tfor(int i=1;i<=n;i++)\n\t\tif(!du[i]) q.push(i);\n\t\n\twhile(q.size())\n\t{\n\t\tint x=q.top();q.pop();\n\t\tprintf(\"%d \",a[x]);\n\t\tfor(int i=head[x];i;i=nxt[i])\n\t\t{\n\t\t\tint y=ver[i];\n\t\t\tdu[y]--;\n\t\t\tif(!du[y]) q.push(y);\n\t\t}\n\t}\n\tputchar('\\n');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <queue>\n#define maxn 2005\nusing namespace std;\ntypedef long long ll;\nint n,a[maxn];\nvector <int> adj[maxn];\nbool vis[maxn];\nvector <int> chi[maxn];\nint gcd(int a,int b){\n\tif(a % b == 0) return b;\n\treturn gcd(b,a % b);\n}\nvoid dfs(int u){\n\tvis[u] = true;\n\tfor(int i=0;i<(int)adj[u].size();i++){\n\t\tint v = adj[u][i];\n\t\tif(!vis[v]){\n\t\t\tchi[u].push_back(v);\n\t\t\tdfs(v);\n\t\t}\n\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=i + 1;j<=n;j++){\n\t\t\tif(gcd(a[i],a[j]) != 1){\n\t\t\t\tadj[i].push_back(j);\n\t\t\t\tadj[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++) sort(adj[i].begin(),adj[i].end());\n\tpriority_queue <int> que;\n\tfor(int i=1;i<=n;i++){\n\t\tif(!vis[i]){\n\t\t\tdfs(i);\n\t\t\tque.push(i);\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tint u = que.top();que.pop();\n\t\tprintf(\"%d%c\",a[u],i == n ? '\\n' : ' ');\n\t\tfor(int j=0;j<(int)chi[u].size();j++){\n\t\t\tque.push(chi[u][j]);\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> ii;\nint n;\nint a[2005];\nint G[2005][2005];\nint gcd(int a, int b){\n    return a == 0 ? b:gcd(b%a,a);\n}\nint vis[2005];\nint nxt[2005];\nvector<int> dfs(int u){\n    vector<vector<int> > pos;\n    for (int i = 1; i <= n; i++){\n        if (G[u][i] && vis[i] == 0){\n            //printf(\"%d -> %d: gcd(%d,%d) is %d\\n\",u,i,a[i],a[u],gcd(a[i],a[u]));\n            vis[i] = 1;\n            pos.push_back(dfs(i));\n        }\n    }\n    int NUM = pos.size();\n    int ct[NUM];\n    memset(ct,0,sizeof(ct));\n    priority_queue<ii> pq;\n    for (int i = 0; i < NUM; i++){\n        pq.push({pos[i][0],i});\n    }\n    vector<int> ans;\n    if (u != 0) ans.push_back(a[u]);\n    while (pq.size()){\n        ii cur = pq.top(); pq.pop();\n        ans.push_back(cur.first);\n        int id = cur.second;\n        ct[id]++;\n        if (ct[id] != pos[id].size()){\n            pq.push({pos[id][ct[id]],id});\n        }\n    }\n    return ans;\n}\nint main(){\n    scanf(\"%d\",&n);\n    for (int i = 1; i <= n; i++) scanf(\"%d\",&a[i]);\n    sort(a+1,a+n+1);\n    for (int i = 0 ; i <= n; i++){\n        for (int j =0 ; j <= n; j++){\n            if (a[i] == 1 || a[j] == 1){\n                if (a[i] == 0 || a[j] == 0) G[i][j] = 1;\n                else G[i][j] = 0;\n            }\n            else G[i][j] = (gcd(a[i],a[j]) != 1);\n        }\n    }\n    vector<int> v = dfs(0);\n    for (int i = 0; i < n; i++){\n        for (int j = 0; j < n-1; j++){\n            if (gcd(v[j],v[j+1]) == 1 && v[j] < v[j+1]){\n                swap(v[j],v[j+1]);\n            }\n        }\n    }\n    for (auto x : v){\n        printf(\"%d \",x);\n    }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "//              +-- -- --++-- +-In the name of ALLAH-+ --++-- -- --+              \\\\\n\n#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define _sz(x) (int)x.size()\n\nusing namespace std ;\nusing ll = long long ;\nusing ld = long double ;\nusing pii = pair <int , int> ;\n\nint const N = 2000 + 20 , M = 30000 + 20 ,  MAX = 1e8 + 20 , S = 1e4 + 20 ;\nint n , a[N] ;\nvector <int> vec ;\n\nvector <int> g[M] ;\nint sz ;\nvector <int> comp[N] ;\n\nint ans[N] , mn[N] , last[M] ;\nbool dead[N] , vis[M] ;\nint mx1 , mx2 , mn_val[N] ;\n\nvector <int> primes ;\nvoid pre () {\n\tbool np[S] ;\n\tmemset(np , 0 , sizeof np) ;\n\tfor (int i = 2 ; i < S ; i ++) {\n\t\tif (np[i]) continue ;\n\t\tprimes.push_back(i) ;\n\t\tfor (int j = 2 * i ; j < S ; j += i) np[j] = 1 ;\n\t}\n}\n\ninline vector<int> get (int x) {\t\t\n\tvector <int> vec ;\n\n\tfor (int j = 0 ; 1ll * primes[j] * primes[j] <= x ; j ++) {\n\t\tif (x % primes[j]) continue ;\n\t\tvec.push_back(primes[j]) ;\n\t\twhile (x % primes[j] == 0) x /= primes[j] ;\n\t}\n\tif (x > 1) vec.push_back(x) ;\n\n\treturn vec ;\n}\n\ninline int get_id (int x) {\n\treturn lower_bound(vec.begin() , vec.end() , x) - vec.begin() ;\n}\n\ninline bool cmp (int x , int y) { return a[x] < a[y] ; }\n\nvoid dfs (int v) {\n\tif (vis[v]) return ;\n\tif (v < n) {\n\t\tif (dead[v]) return ;\n\t\tcomp[sz].push_back(v) ;\n\t}\n\tvis[v] = 1 ;\n\n\tfor (int u : g[v]) dfs(u) ;\n}\n\nint main(){\n\tios::sync_with_stdio(false) , cin.tie(0) , cout.tie(0) ;\n\n\tpre() ;\n\n\tcin >> n ;\n\tfor (int i = 0 ; i < n ; i ++) {\n\t\tcin >> a[i] ;\n\n\t\tvector <int> tmp = get(a[i]) ;\n\t\tfor (int x : tmp) vec.push_back(x) ;\n\t}\n\n\tsort(vec.begin() , vec.end()) ;\n\tvec.resize( unique(vec.begin() , vec.end()) - vec.begin() ) ;\n\n\tfor (int i = 0 ; i < n ; i ++) {\n\t\tvector <int> tmp = get(a[i]) ;\n\t\tfor (int x : tmp) {\n\t\t\tint u = i , v = n + get_id(x) ;\n\t\t\tg[u].push_back(v) ;\n\t\t\tg[v].push_back(u) ;\n\t\t}\n\t}\n\n\tmemset(last , -1 , sizeof last) ;\n\tmemset(mn , 63 , sizeof mn) ;\n\n\tfor (int i = 0 ; i < n ; i ++) {\n\t\tmemset(vis , 0 , sizeof vis) ;\n\t\tmx1 = 0 , mx2 = 0 ;\n\t\tsz = 0 ;\n\n\t\tfor (int v = 0 ; v < n ; v ++) {\n\t\t\tif (!dead[v] && !vis[v]) {\n\t\t\t\tcomp[sz].clear() ;\n\t\t\t\tdfs(v) ;\n\n\t\t\t\tsort(comp[sz].begin() , comp[sz].end() , cmp) ;\n\t\t\n\t\t\t\tmx2 = max(mx2 , a[comp[sz][0]]) ;\n\t\t\t\tif (mx2 > mx1) swap(mx1 , mx2) ;\n\n\t\t\t\tfor (int u : comp[sz]) mn_val[u] = a[comp[sz][0]] ;\n\t\t\t\t\n\t\t\t\tsz ++ ;\n\t\t\t}\n\t\t}\n\n\t\tint res = -1 ;\n\t\tfor (int j = 0 ; j < n ; j ++) {\n\t\t\tif (dead[j]) continue ;\n\n\t\t\tint val = (mn_val[j] == mx1 ? mx2 : mx1) ;\n\t\t\tif (val > a[j]) continue ;\n\n\t\t\tvector <int> tmp = get(a[j]) ;\n\t\t\tint pp = -1 ;\n\t\t\tfor (int x : tmp) pp = max(pp , last[x]) ;\n\n\t\t\tif (mn[pp + 1] < a[j]) continue ;\n\n\t\t\tif (res == -1 || a[res] > a[j]) res = j ;\n\t\t}\n\n\t\tdead[res] = 1 ;\n\t\tans[i] = a[res] ;\n\t\tfor (int j = i ; j >= 0 ; j --) mn[j] = min(mn[j] , a[res]) ;\n\t\tvector <int> tmp = get(a[res]) ;\n\t\tfor (int x : tmp) last[x] = i ;\n\t}\n\n\tfor (int i = 0 ; i < n ; i ++) cout << ans[i] << ' ' ; cout << '\\n' ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<ctime>\n#include<map>\n#include<bitset>\n#include<set>\n#define LL long long\n#define mp(x,y) make_pair(x,y)\n#define pll pair<long long,long long>\n#define pii pair<int,int>\nusing namespace std;\ninline int read()\n{\n\tint f=1,x=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint stack[20];\ntemplate<typename T>inline void write(T x)\n{\n\tif(x<0){putchar('-');x=-x;}\n    if(!x){putchar('0');return;}\n    int top=0;\n    while(x)stack[++top]=x%10,x/=10;\n    while(top)putchar(stack[top--]+'0');\n}\ntemplate<typename T>inline void pr1(T x){write(x);putchar(' ');}\ntemplate<typename T>inline void pr2(T x){write(x);putchar('\\n');}\nconst int MAXN=2005;\nvector<int> nxt[MAXN];\nint cal[MAXN],vis[MAXN],n,id[MAXN];\nbool cmp(int n1,int n2){return cal[n1]<cal[n2];}\npriority_queue<pii> hp;\nint gcd(int a,int b){return a==0?b:gcd(b%a,a);}\nint du[MAXN];\nvoid dfs(int x,int up)\n{\n\tif(up)nxt[up].push_back(x),++du[x];\n\tvis[x]=1;\n\tfor(int i=1;i<=n;i++)if(!vis[i]&&gcd(cal[i],cal[x])!=1)\n\t\tdfs(i,x);\n}\nint main()\n{\n\tn=read();\n\tfor(int i=1;i<=n;i++)cal[i]=read(),id[i]=i;\n\tsort(id+1,id+1+n,cmp);\n\tfor(int i=1;i<=n;i++)if(!vis[id[i]])\n\t\thp.push(mp(cal[id[i]],id[i])),dfs(id[i],0);\n\twhile(!hp.empty())\n\t{\n\t\tint x=hp.top().second;hp.pop();pr1(cal[x]);\n\t\tfor(int k=0;k<nxt[x].size();k++)\n\t\t{\n\t\t\tint y=nxt[x][k];\n\t\t\t--du[y];if(!du[y])hp.push(mp(cal[y],y));\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <queue>\n#define N 2005\n\nusing namespace std;\n\nstruct edge{\n\tint to, nxt;\n}e[N * N];\n\nint n, cnt;\nint a[N], fir[N], ins[N];\nbool vis[N];\n\nvector < int > G[N];\n\nvoid add(int ,int);\nvoid work();\nvoid dfs(int);\n\nint main(){\n\tscanf(\"%d\", &n);\n\tfor(int i = 1; i <= n; ++i)\n\t\tscanf(\"%d\", a + i);\n\tsort(a + 1, a + 1 + n);\n\tfor(int i = 1; i <= n; ++i)\n\t\tfor(int j = n; j; --j)\n\t\t\tif(__gcd(a[i], a[j]) != 1 && i != j)\n\t\t\t\tadd(i, j);\n\tfor(int i = 1; i <= n; ++i)\n\t\tif(!vis[i]) dfs(i);\n\twork();\n\treturn 0;\n}\n\nvoid add(int u,int v){\n\te[++cnt].to = v;e[cnt].nxt = fir[u];fir[u] = cnt;\n\treturn ;\n}\n\nvoid dfs(int u){\n\tvis[u] = true;\n\tfor(int i = fir[u]; i; i = e[i].nxt){\n\t\tint v = e[i].to;\n\t\tif(vis[v]) continue;\n\t\tG[u].push_back(v);\n\t\t++ins[v];dfs(v);\n\t}\n\treturn ;\n}\n\nvoid work(){\n\tpriority_queue < int > Q;\n\tfor(int i = 1; i <= n; ++i)\n\t\tif(!ins[i])\n\t\t\tQ.push(i);\n\twhile(!Q.empty()){\n\t\tint u = Q.top();Q.pop();\n\t\tprintf(\"%d \", a[u]);\n\t\tint sz = G[u].size();\n\t\tfor(int i = 0; i < sz; ++i){\n\t\t\tint v = G[u][i];\n\t\t\t--ins[v];\n\t\t\tif(!ins[v]) Q.push(v);\n\t\t}\n\t}\n\treturn ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 2010\n#define ll long long\n#define db double\n#define For(i,x,y) for(int i=(x);i<=(y);++i)\n#define Rof(i,x,y) for(int i=(x);i>=(y);--i)\n#define Edge(x) for(int i=head[x];i;i=e[i].nxt)\n#define lson l,mid,o<<1\n#define rson mid+1,r,o<<1|1\n#define mset(x,y) memset(x,y,sizeof(y))\n#define mcpy(x,y) memcpy(x,y,sizeof(x))\n#define p_b push_back\nusing namespace std;\nint a[N],deg[N],head[N],n,cnt;\nbool vis[N];\nint gcd(int x,int y){\n\tif(x<y) swap(x,y);\n\treturn x%y?gcd(y,x%y):y;\n}\nstruct abc{\n\tint id,val;\n\tbool operator <(const abc &x)const{ return val<x.val; }\n};\npriority_queue<abc> q;\nstruct ed{\n\tint v,nxt;\n}e[N*N];\nvoid add(int u,int v){ e[++cnt]=(ed){v,head[u]},head[u]=cnt; }\nvoid dfs(int x,int id){\n\tvis[id]=1;\n\tFor(i,1,n) if(!vis[i] && gcd(x,a[i])!=1){\n\t\tadd(id,i),deg[i]++,dfs(a[i],i);\n\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tFor(i,1,n) scanf(\"%d\",&a[i]);\n\tsort(a+1,a+n+1);\n\tFor(i,1,n) if(!vis[i]) dfs(a[i],i);\n\tFor(i,1,n) if(!deg[i]) q.push((abc){i,a[i]});\n\twhile(!q.empty()){\n\t\tabc x=q.top();q.pop();\n\t\tprintf(\"%d \",x.val);\n\t\tEdge(x.id){\n\t\t\tint to=e[i].v;\n\t\t\tdeg[to]--;\n\t\t\tif(!deg[to]) q.push((abc){to,a[to]}); \n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,a[2005],in[2005];\nbool vis[2005];\nvector<int> g1[2005],g2[2005];\nvoid dfs(int x)\n{\n\tvis[x]=1;\n\tfor(int i=0;i<g1[x].size();i++)\n\t\tif(!vis[g1[x][i]])\n\t\t{\n\t\t\tin[g1[x][i]]++;\n\t\t\tg2[x].push_back(g1[x][i]);\n\t\t\tdfs(g1[x][i]);\n\t\t}\n}\nvoid topo()\n{\n\tpriority_queue<int> pq;\n\tfor(int i=1;i<=n;i++)\n\t\tif(!in[i])\n\t\t\tpq.push(i);\n\twhile(!pq.empty())\n\t{\n\t\tint now=pq.top();\n\t\tpq.pop();\n\t\tcout<<a[now]<<' ';\n\t\tfor(int i=0;i<g2[now].size();i++)\n\t\t{\n\t\t\tin[g2[now][i]]--;\n\t\t\tpq.push(g2[now][i]);\n\t\t}\n\t}\n\tcout<<endl;\n}\nint main()\n{\n\tcin>>n;\n\tfor(int i=1;i<=n;i++)\n\t\tcin>>a[i];\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\tif(__gcd(a[i],a[j])!=1)\n\t\t\t{\n\t\t\t\tg1[i].push_back(j);\n\t\t\t\tg1[j].push_back(i);\n\t\t\t}\n\tfor(int i=1;i<=n;i++)\n\t\tif(!vis[i])\n\t\t\tdfs(i);\n\ttopo();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int N = 200010;\nint n, a[N], g[N];\nint gcd(int x, int y) {\n\treturn !y ? x : gcd(y, x % y);\n}\nbool ok() {\n\tlong long sum = 0;\n\tfor (int i = 1; i <= n; i++) sum += a[i];\n\tif (n == 1 && a[1] == 1) return 0;\n\tif (n == 1) return 1;\n\tif (!(n & 1)) return sum & 1;\n\tif ((n & 1) && !(sum & 1)) return 1;\n\t\n\tfor (int j = 0; ; j ^= 1) {\n\t\tg[n] = a[n];\n\t\tlong long S = a[n] - 1; int G;\n\t\tfor (int i = n - 1; i; i--) g[i] = gcd(g[i + 1], a[i]), S += a[i];\n\t\tbool flag = 0;\n\t\tif (a[1] > 1 && (1 & (S / (G = gcd(g[2], a[1] - 1))))) flag = 1, a[1]--;\n\t\telse \n\t\t\tfor (int i = 2, f = a[1]; i <= n; f = gcd(f, a[i]), i++)\n\t\t\t\tif (a[i] > 1) {\n\t\t\t\t\tint now = gcd(f, a[i] - 1);\n\t\t\t\t\tif (i < n) now = gcd(now, g[i + 1]);\n\t\t\t\t\tif (1 & (S / (G = now))) {\n\t\t\t\t\t\tflag = 1;\n\t\t\t\t\t\ta[i]--;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse break;\n\t\tif (!flag) return j;\n\t\tfor (int i = 1; i <= n; i++) a[i] /= G;\n\t}\n}\n main() {\n\tscanf(\"%lld\", &n);\n\tfor (int i = 1; i <= n; i++) scanf(\"%lld\", &a[i]);\n\tputs(ok() ? \"First\" : \"Second\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <cmath>\nusing namespace std;\nconst int N=2010;\nint n,tt;\nbool w[N];\nint head[N],to[N],nxt[N],a[N],in[N];\ninline int gi() {\n    int x=0,o=1;\n    char ch=getchar();\n    while(ch!='-'&&(ch<'0'||ch>'9')) ch=getchar();\n    if(ch=='-') o=-1,ch=getchar();\n    while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n    return x*o;\n}\ninline int gcd(int x,int y) {return y?gcd(y,x%y):x;}\ninline void dfs(int x) {\n    w[x]=1;\n    for(int i=1;i<=n;i++)\n\tif(!w[i]&&gcd(a[x],a[i])>1) {\n\t    to[++tt]=i,nxt[tt]=head[x],head[x]=tt;\n\t    ++in[i],dfs(i);\n\t}\n}\nint main() {\n    cin>>n;\n    for(int i=1;i<=n;i++) a[i]=gi();\n    sort(a+1,a+1+n);\n    for(int i=1;i<=n;i++)\n\tif(!w[i]) dfs(i);\n    for(int t=1;t<=n;t++)\n\tfor(int x=n;x;x--)\n\t    if(!in[x]) {\n\t\t--in[x],printf(\"%d \",a[x]);\n\t\tfor(int i=head[x];i;i=nxt[i]) --in[to[i]];\n\t\tbreak;\n\t    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n\nconst int maxn = 2010;\nconst int SZ = 2e5;\n\nint N;\nvi prs;\n\nint A[maxn];\nbool us[maxn], vis[SZ];\nvi g[SZ];\n\nvoid dfs(int v, vi &vec, vi &cmp) {\n\tvis[v] = 1;\n\tif (v < N) {\n\t\tcmp.pb(v);\n\t}\n\n\tfor (int to : g[v]) {\n\t\tif (!vis[to]) {\n\t\t\tdfs(to, vec, cmp);\n\t\t}\n\t}\n}\n\nvi merge(vi va, vi vb) {\n\tvi res;\n\tint tm = va.size() + vb.size();\n\tva.pb(-1);\n\tvb.pb(-1);\n\n\tint i1 = 0, i2 = 0;\n\n\trep(i, tm) {\n\t\tif (va[i1] > vb[i2]) {\n\t\t\tres.pb(va[i1++]);\n\t\t} else {\n\t\t\tres.pb(vb[i2++]);\n\t\t}\n\t}\n\n\treturn res;\n}\n\nvi decide(int ban, vi cand) {\n\tvi res;\n\tif (cand.size() == 0) {\n\t\treturn res;\n\t}\n\n\tint mini = 1e9;\n\tint piv = -1;\n\n\tfor (int t : cand) {\n\t\tif (ban == 0 || __gcd(A[t], ban) != 1) {\n\t\t\tif (mini > A[t]) {\n\t\t\t\tmini = A[t];\n\t\t\t\tpiv = t;\n\t\t\t}\n\t\t}\n\t}\n\n\tvi nx;\n\tfor (int t : cand) if (t != piv) {\n\t\tnx.pb(t);\n\t}\n\n\tvi cmp(N);\n\n\tfor (int v : nx) {\n\t\tvis[v] = 0;\n\t\tfor (int to : g[v]) {\n\t\t\tvis[to] = 0;\n\t\t}\n\t}\n\n\tfor (int t : nx) if (!cmp[t]) {\n\t\tvi vec;\n\t\tdfs(t, nx, vec);\n\t\tfor (int i : vec) {\n\t\t\tcmp[i] = 1;\n\t\t}\n\t\tvi sub = decide(mini, vec);\n\t\tres = merge(res, sub);\n\t}\n\n\tres.insert(res.begin(), mini);\n\n\treturn res;\n}\n\nint main() {\n\tcin >> N;\n\tfor (int i = 2; i <= 10000; ++i) {\n\t\tbool f = 1;\n\t\tfor (int j = 2; j * j <= i; ++j) {\n\t\t\tif (i % j == 0) {\n\t\t\t\tf = 0;\n\t\t\t}\n\t\t}\n\t\tif (f) {\n\t\t\tprs.pb(i);\n\t\t}\n\t}\n\n\tvi np;\n\n\trep(i, N) {\n\t\tcin >> A[i];\n\t\tint x = A[i];\n\t\tfor (int v : prs) {\n\t\t\twhile (x % v == 0) {\n\t\t\t\tx /= v;\n\t\t\t}\n\t\t}\n\t\tif (x != 1) {\n\t\t\tnp.pb(x);\n\t\t}\n\t}\n\n\tsort(ALL(np));\n\tnp.erase(unique(ALL(np)), np.end());\n\tfor (int p : np) {\n\t\tprs.pb(p);\n\t}\n\n\trep(i, N) {\n\t\trep(j, prs.size()) if (A[i] % prs[j] == 0) {\n\t\t\tg[i].pb(j + N);\n\t\t\tg[j + N].pb(i);\n\t\t}\n\t}\n\n\tvector<vi> vec;\n\tvi vx, ans;\n\trep(i, N) vx.pb(i);\n\n\trep(i, N) {\n\t\tif (!us[i]) {\n\t\t\tvi v;\n\t\t\tdfs(i, vx, v);\n\t\t\tfor (int a : v) {\n\t\t\t\tus[a] = 1;\n\t\t\t}\n\t\t\tauto res = decide(0, v);\n\t\t\tans = merge(ans, res);\n\t\t}\n\t}\n\n\trep(i, N) printf(\"%d%c\", ans[i], i == N - 1 ? '\\n' : ' ');\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<cstring>\n#include<algorithm>\n#include<stack>\n#define fo(i,a,b) for(i=a;i<=b;i++)\n#define ll long long\nusing namespace std;\nint n,a[2005],tot,du[2005],h[2005],to[4000005],nex[4000005];\nbool bhz[2005][2005],pd[2005];\nint gcd(int a,int b)\n{\n    return b?gcd(b,a%b):a;\n}\nstruct node{\n    int fr,id;\n}st;\nbool operator <(node a,node b)\n{\n    return a.fr<b.fr;\n}\nstack<node> q;\nvoid add(int a,int b)\n{\n    du[b]++;\n    to[++tot]=b;\n    nex[tot]=h[a];\n    h[a]=tot;\n}\nvoid dfs(int x)\n{\n    pd[x]=1;\n    for(int i=1;i<=n;i++)\n        if(bhz[x][i]&&!pd[i])\n        {\n            add(x,i);\n            dfs(i);\n        }\n}\nint main()\n{\n    cin>>n;\n    for(int i=1;i<=n;i++) cin>>a[i];\n    sort(a+1,a+n+1);\n    for(int i=1;i<=n-1;i++)\n    for(int j=i+1;j<=n;j++)\n    if(gcd(a[i],a[j])>1) bhz[i][j]=bhz[j][i]=1;\n    for(int i=1;i<=n;i++) if(!pd[i]) dfs(i);\n    for(int i=1;i<=n;i++) \n        if(!du[i])\n        { \n            st.fr=a[i];\n            st.id=i;\n            q.push(st); \n        }\n    for(int i=1;i<=n;i++)\n    {\n        st=q.top();\n        q.pop();\n        int now=st.id;\n        cout<<a[now]<<\" \";\n        int t=h[now];\n        while (t){\n            du[to[t]]--;\n            if (!du[to[t]]){\n                st.fr=a[to[t]];\n                st.id=to[t];\n                q.push(st);\n            }\n            t=nex[t];\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#prag\\\nma GCC optimzie(3)\nconst int maxn = 2010;\nint n, a[maxn], deg[maxn];\nvector <int> vec[maxn];\npriority_queue <int> q;\nbitset <maxn> vis, g[maxn];\n\nvoid dfs(int u) {\n\tvis[u] = 1;\n\tfor (int v = 1; v <= n; v++) {\n\t\tif (!vis[v] && g[u][v]) vec[u].push_back(v), deg[v]++, dfs(v);\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", a + i);\n\t}\n\tsort(a + 1, a + n + 1);\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = i + 1; j <= n; j++) {\n\t\t\tif (__gcd(a[i], a[j]) != 1) g[i][j] = g[j][i] = 1;\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (!vis[i]) dfs(i);\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (!deg[i]) q.push(i);\n\t}\n\twhile (!q.empty()) {\n\t\tint u = q.top(); q.pop();\n\t\tfor (int v : vec[u]) q.push(v);\n\t\tprintf(\"%d \", a[u]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\nconst int MaxN = 2000 + 10 ;\nint N , A[MaxN] ;\nbool Map[MaxN][MaxN] , Vis[MaxN] ;\nint Cnt , Head[MaxN] , To[MaxN] , Next[MaxN] , In[MaxN] ;\ninline void Add( int U , int V ) {\n\tTo[++Cnt] = V ;\n\tNext[Cnt] = Head[U] ;\n\tHead[U] = Cnt ;\n\t++In[V] ;\n}\nvoid Dfs( int Nod ) {\n\tVis[Nod] = true ;\n\tfor(register int i = 0 ; ++i <= N ; )\n\t\tif( Map[Nod][i] and ( not Vis[i] ) ) {\n\t\t\tAdd( Nod , i ) ;\n\t\t\tDfs( i ) ;\n\t\t}\n}\npriority_queue<int> Q ;\nint main() {\n\tscanf( \"%d\" , &N ) ;\n\tfor(register int i = 0 ; ++i <= N ; )\n\t\tscanf( \"%d\" , &A[i] ) ;\n\tsort( A + 1 , A + 1 + N ) ;\n\tfor(register int i = 0 ; ++i <= N ; )\n\t\tfor(register int j = 0 ; ++j <= N ; )\n\t\t\tMap[i][j] = __gcd( A[i] , A[j] ) != 1 ;\n\tfor(register int i = 0 ; ++i <= N ; )\n\t\tif( not Vis[i] ) Dfs( i ) ;\n\tfor(register int i = 0 ; ++i <= N ; )\n\t\tif( In[i] == 0 )\n\t\t\tQ.push( i ) ;\n\twhile( Q.size() ) {\n\t\tregister int Nod = Q.top() ;\n\t\tQ.pop() ;\n\t\tprintf( \"%d \" , A[Nod] ) ;\n\t\tfor(register int i = Head[Nod] ; i ; i = Next[i] )\n\t\t\tif( --In[To[i]] == 0 )\n\t\t\t\tQ.push( To[i] ) ;\n\t}\n\treturn 0 ;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 0x3f3f3f3f;\n\nint GCD(int a, int b){\n\treturn b == 0 ? a : GCD(b, a % b);\n}\n\nint a[2010];\nint gcd[2010][2010];\nvector <int> from[2010];\nint ans[2010];\nint c[2010], in_ans[2010], minj[2010], last[2010], best[2010];\nint C, n;\n\nvoid dfs(int x){\n\tc[x] = C;\n\tfor (int i = 0; i < from[x].size(); i++){\n\t\tint v = from[x][i];\n\t\tif (c[v] != -1 || in_ans[v]) continue;\n\t\tdfs(v);\n\t}\n}\n\nvoid color(){\n\tC = 0;\n\tmemset(c, -1, sizeof(c));\n\tfor (int i = 0; i < n; i++){\n\t\tif (c[i] != -1 || in_ans[i]) continue;\n\t\tdfs(i), C++;\n\t}\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++){\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tgcd[i][j] = GCD(a[i], a[j]) != 1;\n\t\t\tif (gcd[i][j]) from[i].push_back(j), from[j].push_back(i);\n\t\t}\n\t}\n\tfor (int i = 0; i <= n; i++){\n\t\tminj[i] = INF, last[i] = -1;\n\t}\n\tint tot = 0;\n\twhile (tot != n){\n\t\tcolor();\n\t\tmemset(best, -1, sizeof(best));\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tif (in_ans[i]) continue;\n\t\t\tif (minj[last[i] + 1] < a[i]) continue;\n\t\t\tif (best[c[i]] == -1 || a[best[c[i]]] > a[i]) best[c[i]] = i;\n\t\t}\n\t\tint id = -1;\n\t\tfor (int i = 0; i < C; i++){\n\t\t\tif (best[i] == -1) continue;\n\t\t\tif (id == -1 || a[id] < a[best[i]]) id = best[i];\n\t\t}\n\t\tin_ans[id] = 1, ans[tot++] = a[id];\n\t\tfor (int i = 0; i < tot; i++){\n\t\t\tminj[i] = min(minj[i], a[id]);\n\t\t}\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tif (gcd[id][i]) last[i] = tot - 1;\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++){\n\t\tprintf(\"%d \", ans[i]);\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\nusing namespace std;\n\nconst int N=2010;\nstruct Edge{int to,next;} e[N];\nint h[N],sum=0;\nint deg[N],a[N],n;\nbool vis[N];\n\nvoid add_edge(int u,int v)\n{\n\te[++sum].to=v;\n\te[sum].next=h[u];\n\th[u]=sum;\n}\n\nvoid dfs(int u)\n{\n\tvis[u]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tif(!vis[i]&&__gcd(a[u],a[i])!=1)\n\t\t\tdfs(i),add_edge(u,i),deg[i]++;\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",a+i);\n\tsort(a+1,a+1+n);\n\tfor(int i=1;i<=n;i++)\n\t\tif(!vis[i]) dfs(i);\n\tmemset(vis,0,sizeof(vis));\n\tfor(int T=1;T<=n;T++)\n\t{\n\t\tfor(int i=n;i>=0;i--)\n\t\t\tif(!vis[i]&&!deg[i])\n\t\t\t{\n\t\t\t\tprintf(\"%d \",a[i]);\n\t\t\t\tvis[i]=1;\n\t\t\t\tfor(int tmp=h[i];tmp;tmp=e[tmp].next)\n\t\t\t\t\tdeg[e[tmp].to]--;\n\t\t\t\tbreak;\n\t\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"Ofast\")\n#include <iostream>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <set>\n#include <queue>\n#define rep(x, a, b) for(int x = (a); x <= (b); ++x)\n#define rop(x, a, b) for(int x = (a); x < (b); ++x)\n#define per(x, a, b) for(int x = (a); x >= (b); --x)\nusing namespace std;\ntypedef long long LL;\ntypedef double DB;\npriority_queue<int> PQ;\nint a[2005], rd[2005];\nstruct graph {\n\tset<int> S[2005];\n\tint vs[2005];\n\tvoid push(int x, int y) {\n\t\tS[x].insert(y);\n\t}\n\tvoid dfs(int nw) {\n//\t\tcout << nw << endl;\n\t\tvs[nw] = 1;\n\t\tauto IT = S[nw].begin();\n\t\twhile(IT != S[nw].end()) {\n//\t\t\tcout << a[nw] << \"0 \" << a[(*IT)] << endl; \n\t\t\t++rd[*IT];\n\t\t\tS[*IT].erase(nw); \n\t\t\t++IT;\n\t\t}\n\t\tIT = S[nw].begin();\n\t\twhile(IT != S[nw].end()) {\n\t\t\tif(vs[*IT]) {++IT; continue;}\n\t\t\tdfs(*IT);\n\t\t\t++IT;\n\t\t}\n\t}\n\tvoid tuopu() {\n\t\tPQ.push(0);\n\t\twhile(PQ.size()) {\n\t\t\tint nw = PQ.top();\n\t\t\tif(nw) printf(\"%d \", a[nw]);\n\t\t\tPQ.pop();\n\t\t\tauto IT = S[nw].begin();\n\t\t\twhile(IT != S[nw].end()) {\n\t\t\t\t--rd[*IT];\n\t\t\t\tif(rd[*IT] == 0) PQ.push(*IT);\n\t\t\t\t++IT;\n\t\t\t}\n\t\t}\n\t}\n}G;\nint n;\nint main() {\n\tscanf(\"%d\", &n);\n\trep(i, 1, n) scanf(\"%d\", &a[i]);\n\trep(i, 1, n) rep(j, 1, n) if(i != j && __gcd(a[i], a[j]) != 1) G.push(i, j); \n\trep(i, 1, n) G.push(0, i), G.push(i, 0);\n\tG.dfs(0);\n\tG.tuopu();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nID:njbxgub1\nPROB:\nLANG:C++\n*/\n/*\n                   _ooOoo_\n                  o8888888o\n                  88\" . \"88\n                  (| -_- |)\n                  O\\  =  /O\n               ____/`---'\\____\n             .'  \\\\|     |//  `.\n            /  \\\\|||  :  |||//  \\\n           /  _||||| -:- |||||-  \\\n           |   | \\\\\\  -  /// |   |\n           | \\_|  ''\\---/''  |   |\n           \\  .-\\__  `-`  ___/-. /\n         ___`. .'  /--.--\\  `. . ___\n      .\"\" '<  `.___\\_<|>_/___.'  >'\"\".\n     | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |\n     \\  \\ `-.   \\_ __\\ /__ _/   .-` /  /\n======`-.____`-.___\\_____/___.-`____.-'======\n                   `=---='\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n         ·e×?±￡óó       óà?TBUG\n*/\n/*\n                 .::                                                       ,,         .:                    :,         :.\n          :LuqL  5B@   :v             77L21F5F5F5F1F5S15Uv7,              :@B         0@U                  .B@        L@P\n B@B@@@B@B@B@@B  L@B   B@B@,          @BB2XSPSPkPXPkPXPF2B@B     .@B@B@B@B@@@B@B@B@B@@@B@B@B@B@B@ :@@@@BBMOB@BGM@B@BME@@@EMB@B@B@r\n ,Yi:  @B2       iB@     2@@@7        B@,                8Bq      vriii:.:0@@:ii::,:::B@B::iiii77 ,E1uJuJJ7GB@7LUk2ULvB@B7LjJjjSq:\n       B@7        @B       i7         @B@B@B@B@B@B@B@B@B@B@k          @B  .BZ    u@.   :                   ,@N        7B2\n0EqEqX2@B@1N0Z0ZSqB@qX0ZNPUYLSZ8      B@                 NBP          :@B       1@BMX0uj2EEZN15,    8@B@B@@@GGB@7 5@B@BOM@B@B@B.\n@B@B@B@@@B@B@B@B@B@B@B@B@B@B@B@B      @B@B@B@B@B@B@B@B@B@B@q      @B@B@B@B@@@u S@B2qOOMOMM@BMB@L              @@7            B@.\n       @Bv        @@v       .         B@:                k@v      :i;.,...q5::B@k            @Bi     8@@B@B@B@B@v  BB@B@B@B@@@B.\n       B@L   .,7  0B@     SB@S   :5jj7vi::iiiii:..,:iii::;77LY25   B@     @B u@20B@B@B@B@N   @@:     B@       .:   B@        ::\n .:v28P@B@@@B@B@, ,@@   u@B@.    YB@B@ME0OB@B@@@B@BMB@B@BBOBB@B@.  L@@   OBS    B@:    JB@   @B.    v@BLuXP0qXvL: 1@B7ukXE00SYvL\n@@@B@B@B@Z.        B@kLB@B:            7Ei      @@;                 @B:  B@     @B     .@O   B@      LO1i   , @B0  ;BX7.  ,..P@B\n       @Bu         1B@B5     ::       :@B       B@@@B@B@@@B@B@      7@@ U@u     B@i,::.PB@   @B      .7OBGu   Z@v   rNBOFi   7B8\n       B@5      7B@B@B@      B@B     i@B@7      @BN.::i:i:i:ii       17 @B      @B@B@B@MMY   B@          u@OBUMBi      :@BNBYv@F\n       @B0  u@B@B@L  kB@;    @@;    0@B.J@@O:   B@i               ,:ii7@B@B@@@u SZ          i@B    LB@@@B@5Y, B@, 5@@@B@GFY: ZBu\n :5rr:5B@J  MBM:      iB@@k:@@@  ,NB@E    k@@B@B@B@qEZMMBM@MBB@Br @B@B@OY77:,      :MSUjuukB@Br    iBvUr.   .8@B  i5::r     YB@\n .B@B@BZ:                0B@B8   @BO         .:i:77uU5uFSkFkFXXq                    B@B@@@GU.         ,@B@B@BM:       B@B@B@B7\n          .:7kq  ;@B,   ,                   @B.    i@M                .B@,      N@@       .BO       :,.            .:..\n LB@@@B@B@B@B@@  :B@,  EB@O,                B@i    U@@                 ,q@BX    1@B    ,q@B0:      ,B@B@B@B@B@B@1  @B@B@B@B@B@B@\n  kri. M@@        @B:    u@B@J    @B@B@B@B@@@Bi    J@@@B@B@B@B@B   irrvi:u@BjLJ7@B@7YYLB@Bj::rir              @Bj            i@B\n       EBO        @@:      :1     iiii:i::,:B@:    uB@.::i:i:iii   @B@qquvrLu1127rrUU5Uvrrv5q@B@.    .,iiiii::B@L   .,:iiiii:E@@\nYLLvv7iB@Bi7YLYL7r@@ErLLL7r::iYU            @@i    Y@@             B@k      . .     ...       @B,    B@B@B@B@B@BF   @B@B@B@B@@@B\n@@B@B@B@B@@@B@B@B@B@B@B@B@B@B@B@.           B@i    uB@             r7. ,B@MMMBMBMBMBMBMMG@B@  7v    r@M            LB8\n       E@O        PBM       .     vB@B@B@@@B@Bi    J@B@B@B@B@@@7       .@B               P@8        @BX.::i:i:     B@2,:::i:i.  .\n       Z@M     ;  ;@B     i@@@    ,ULYLJLL77@@i    uB@ivLYLJLJu:       ,B@B@B@B@B@B@B@B@B@B@        BOEOB@B@B@B@q  BZNO@B@B@B@B@@\n  ,:i7JB@B@B@B@@u  B@:  :B@Bv               @Bi    J@B                  2J      uB@      :u:         @@r      @BL  7@X:       8BZ\nB@B@B@B@B@,i.      kBBi@B@L                 B@i    j@@               uYjvJ2kSk1jM@@u2kFS1uLuJUi      iu@B@O   B@i  .iNB@Bj    B@u\n .     Z@M         :@B@Mi     :  rEXqXXXPS5U@Bi    Y@Bj1XXqkXXN07    B@Bq088OOGk@B@SE8OZZNq5@B@          i7:, @@,       ::i2r @B7\n       MB@      ,8B@B@B      kB@ Y@@B@B@BBOGB@i    uB@EMB@B@B@B@j    @Bi        7@B         G@8    ukBB@@@B@P B@  .75BB@@@B@: B@:\n       O@B  7u@B@BO, v@@v    B@G            @Bi    J@B               B@Y        uB@    7:,.i@BS   ,B@B1:     .@B  N@@BL       @B.\n  5ri:r@B@  k@BL.     ,@B@q:5@B             B@r    1@@               @B7        F@B    @B@B@Or        .i.,,:1@B8       r,:::u@B@\n  @B@B@B1               .q@B@B:             @Br    L@B                          5B@                   kB@B@@@5.       r@@@@B@Z;\n           ,ijN   B@L   .             B@5                          .:...,:,:,.     ,,:.......                  ... .\n :@B@B@@@B@B@@@i  @B1  j@B@.         .@B      .B@B@B@@@B@B@B@B@B   G@B@B@B@B@B@B  .B@B@B@@@B@B@v    7;L7ri. @@@B@B@@ B@B@B@@@B@B@@\n  NLrr:0B@        B@2    YB@@N       UBB       ... .      .@B@Bi              B@             @Br    B@BBB@8 B@   JBE         :B@\n       :@B        BBk      .O:   E@B@B@B@B@B@P          .M@BS        ..,:,:,.7@@    ,.:,:::.,B@i    @B  :BS BB   B@           @B\n:L77rr:E@@ir7vvvr:B@B:rv7ri:::rJ :7ij@Biir:@BM        :@B@i         v@B@@@B@B@@@   UB@B@B@B@B@BL    B@  i@5 M@  S@v  UB@B@@M  B@\n8B@B@B@B@B@B@B@B@B@@@B@B@@@B@B@@L   JBM    @@i        5B@           @B.            @@               @B  ;@F BB  @B   O@L .@B  @B\n       7B@        i@B               @@,    @B         L@B          ,B@..,:,,..    :@B..,,:,:.  .    B@  i@5 M@ .B@   NB.  B@  @@\n       ;@B     ,,  B@      @@B.    U@B    0BE @B@B@B@B@B@B@B@B@B@  LBEOB@@@B@B@B  UO0G@B@B@B@B@Bi   @B  rBS MB. :@@  X@,  @B  @B\n    ,;7B@@B@B@B@B  @B5   MB@q      @B7    B@          Y@B           :@5.      B@   OOv        @@    B@  i@5 M@.  jB5 kB.  B@  B@\n7B@B@B@B@@1r:      ;@B.Z@@O        iB@@r B@j          vB@           ,1@B@B;  :@B   i0B@B@     @B    @B  ,BF MB.   @B 2@5i7@B  @B\n ::    7B@          B@B@u             7@B@B           Y@@                j , r@@        i :0 ,B@    B@LLG@F M@    @@ 0@@B@MZ  B@\n       L@B       v@B@@@:     :@B:      B@B@B1.        jB@         :LLkBB@B@B 7@B  :7L0@B@@@B :@@    @@MO@BO BB2B@B@7 Y@       @@\n       7B@  .7B@B@B7 :B@u    qB@    .@B@  .@B@:       7@B         O@@B7,     BBO  B@BMi      SB@    B@   :  B@.:i:            B@\n  u::.,B@B  LB@Gi     .B@B2.:B@i  uB@B7         rL::,:@B@             :.   ,P@@:      :,  .:uB@r            @B.         .:.  U@@\n  B@B@BBS                5B@BM:   MB            v@@@@@Mv              @@B@B@Bv        B@@@B@Bu              M@          .@B@B@X\n*/\n/*\n                             UM.\n                            J@B@1                                                                    iO@1\n                           Y@@@B@BB.                                                              7B@B@B@\n                          :@B@i,B@B@O                                                          ,Z@B@B@B@Br\n                          @B@q   i@B@BS                                                      7@B@@@O5vMB@q\n                         8@@B      LB@B@i                                                  FB@@@BNjYjLE@B@\n                        ,B@B:        0@@@Z                                               P@B@BM1JJ125JPB@B\n                        B@BB          :@B@B                                            XB@B@Z2LuU52F2u2@B@.\n                       :@B@             @@@B:                                        v@B@B8uJj51F1525uUB@B7\n                       @B@O              0@@B.               ..::ir7vvYUuU777r::.   B@B@OULU2F2F151F11Y@B@S\n                       B@B,               8B@B  :ruXMB@B@B@B@B@B@B@B@B@B@@@B@B@B@B@B@B@5Jj1211F1F1F2FUJO@BB\n                      U@B@                 @B@B@B@B@B@@@B@B@B@MMqPS5JuYL7rq@B@OBB@B@B8Yu211F1515251515YGB@@\n                      @B@u                 v@@@@MSur:.                    LB@MvvjJuU5YU252F1F1F25251F2uX@@@\n                      @@@.                                                N@BML2U2UUU12F15252525251515Jk@@B\n                     r@B@                                                 YB@Bju52121252515252F15251F2u5@B@\n                     PB@B                                                  @@@PYUF151F25151F152F2F1F15jF@@B\n                     @@BS                                                  N@@@UJ2F25252F251525151F1F1u5@B@\n                     @@@7                                                   B@B@5Yj12F152F1F1F25252515jFB@B\n                     B@Bi                                                    M@B@O2Luu52525212F151121UY1@B@7\n                    O@B@:                                                     v@B@BMSuYJJuuUu2u2uujjYJJXB@B@M\n                  7B@B@,                                                        1B@@@B@GPF1uujuu21PNMB@B@B@B@@\n                 qB@B2                                                            i8B@B@B@B@B@@@@@B@B@B@q: @@@B\n                MB@B:                                                                 7SBB@B@B@B@B@Zu:      @B@B\n               ZB@B.                                              ,v.                                        @B@L\n              LB@B,                         Y7                    @B@Bu                                      7@B@\n   :B@B@@B2:  @@B7                         @B@Z                   r@B@B@BP:                                   B@BE\n    BB@@@B@B@B@BE                        r@B@B                       7@B@B@B@Ou:                              iB@B\n         :uM@@B@@2.           :7::::ivk@B@B@0                           :5B@B@B@B@B@B@G.                       @B@i\n            BB@@@B@@         :@B@B@@@B@B@@1                                 .i5M@B@B@@@5                       M@@2\n            B@B ,@B1          L0EZZG0F7:                                            .:,                        uB@MrP@M7\n           2@B@                                                                                               ,O@B@B@B@B\n           @B@1                                                     :@B@@@r                                :@@@@B@BL:,,\n           B@Bi                         :2ZS;                      :@B@B@B@r                               L@B@B@BU\n           @B@.                        @@@B@B@                     vB@B@B@B5                                   @B@i\n           B@B                        7B@B@B@BM                     OB@B@B@                                   ,B@B\n           @B@                         @B@B@@@i                       rL7.                                    B@BM\n           B@B7.:                       NB@@M.                                                               .@B@.\n  .;JEB@@@B@B@B@B@.                                                                                       .  @B@u\n@@@B@B@B@B@@@B@18U                                                                                      :B@B@B@BU,\n7@BOui.    ,@@B                                                                                          SP@B@B@B@B@Or\n            @@@U                                                                                           B@BJ.YO@B@B@i\n            r@B@                                                                                         :B@Bk     .k@B@\n             B@B@                                                                                       LB@@k         2i\n              B@BM                                      .7jXEGqF7:                                     OB@@L\n              .B@BM                                   .B@B@B@B@B@B@.                                 :@B@B:\n               .B@B@                                   @@MYr::ivG@B                                .M@B@G\n                 B@@@S                                                                           ,MB@B@,\n                  v@@@BF                                                                      .1B@B@Br\n                    2@@B@BL                                                                ,FB@@@B8,\n                      r@B@B@BF,                                                        :YBB@B@B@B\n                         L@B@B@B@P7,                                           .ivXB@B@B@B@B@M@B@\n                            ,1B@B@B@B@@@BOP2L7i:,.              ..,:i7LSNB@@B@B@@@B@B@B@Z5v;.LB@@\n                              @B@OEB@B@@@B@B@B@B@B@B@B@B@@@B@B@B@B@B@@@B@B@B@B@BM0SJ7i::::i:,u@B@\n                              B@Bu ::i;7vu2XNGOMB@B@BMB@B@B@B@B@B@@@B1UFuj77ii:::::::iir;r;i.YB@B\n                              @B@L.:i:i:i::::::::::..Y@B@BMYi:i;SB@B@N:.::i:iirir;r;rii::::ivO@B@\n                              B@@X::,::::iirir;riri:E@B@1         ,@B@Br:;;r;rii:i::::i7JEB@@@@@B\n                              @@@B@BBq5v7ii:::::::.2@@@i  ..,..     @B@@,,:::::irv2XMB@B@B@B@2@B@:\n                             .B@BBB@@@B@B@B@BMNP5u7@B@1 .,,:,,  :.   @B@P50MB@B@B@B@B@@@BS:   @@B1\n                             E@B@   ijGB@B@B@B@B@B@B@Bi .,:,,..@@B@7 B@B@B@B@B@B@BM57.        kB@B\n                            .@B@:          .,ivu5Nq@B@u  ..,.. SB@B@@@B@PL7i,                 ,@B@\n                            @@@8                   i@B@:    .     :B@B@@                       B@@2\n                          i@@@@                     0@B@u          B@@B.                       vB@B\n                         ,@B@G                       L@B@BOv:.:iFB@B@M                          @B@Bi\n                          vNi                          S@@B@B@B@B@BM:                            MB@N\n                                                          758BMqJ,\n\n                 .  YO.               vq                            :G       Z:\n        SqOMBB@B@Br @@r rBE           @B     B@@@@@B@ONX8k    i::::.OB1.:::.u@O.::::i           @B@B@U:@@B@@BPEBu\n        B@@NB@k.    5@i  uB@E.        BM     1U2uUJvirB@@Z   r@@B@B@@@B@B@B@B@B@@@B@Bi   LB@B@1 BX :@k uLLLvr@BJ:\n            iB      iBi    7@     .@M8@BGMZZ         @@F            ,B       Pi          v@  Bq @i v@        B@\n       vuL7r8@S7vJL7N@Z7LLri;72.   F7@Bvvv@@       @BX         @@@B@B@@@@@B@@@B@B@B      7@  @F Bi @q  @B@Bu @B\n       N@B@G@@@8@BBOMB@G@BMNXG@,     B@   @@      .Bk          .:u;    i@:      Zv       7@  Bk @,;@  ,BY @B B@\n            r@       @G     5.      ,@v   BZ :::,.r@E .::i,      @B     B@    .@BL       7@  @F B:i@. .@  @M @B\n            7B: ,vO, @@   iB@:      @B   7@:MB@B@B@@@B@B@BM       @@.    B:  2@q         7@  BS @i 0@  B. @O B@\n       ,r2EBB@B@B@Bi G@  @BB        B@   @B        @S              :    r@   ..          7B  @F @7  B7 @  @B @B\n       E@B@UOBr       @B@Bi          L@0PB        .BZ        .@B@B@B@B@B@B@B@B@B@B@B@,   r@  BF @i  @G B@B@B B@\n            7@,      kB@U    ;r        @@@.       .@Z                GBuL@iBBi           vB@B@q BP:5@7 @u,.  @B\n            LBi   YB@BrB@    @@       @B:L@Br      BM             .M@B  rB  rB@J         v@. Pi @XZ8r  .     B@\n        .   G@i B@BM.  ,B@,  @B    iB@B    N, 7r..q@k         ,LB@B8    J@,   i@B@B1r           Br           @@\n        MB@B@B  ,i       B@B@B,    B@:        @B@B@F         .@BB:      P@i      :OBZ          .@U       B@B@B:\n                          .ll                                           rB.                     :\n*////////////////////\n//******************/\n//*   I<3   C++    */\n//*  I WANT ANY AC */\n//* I LOVE PROGRAM!*/\n//*IT'S INTERESTING*/\n//* I LOVE PROGRAM!*/\n//*  IN CONTESTS   */\n//*   GET SCORE    */\n//*    AC CODE     */\n//*     LET'S      */\n//*      GO        */\n//*  Written by:   */\n//*    gbc\t\t   */\n//******************/\n/////////////////////\n#include <bits/stdc++.h>\nusing namespace std;\n#define fro for\n#define itn int\n#define mp make_pair\n#define pb push_back\n#define one first\n#define two second\n#define fi(n) n.begin()\n#define se(n) n.end()\n#define all(n) (n).begin(),(n).end()\n#define po(n) n.pop()\n#define PI 3.141592653\n#define son(n) int lf=2*n,ri=2*n+1\n#define pr (int prime[]={0,2,3,5,7,11,13,17,19,23,29,31,37})\n#define sz(n) n.size()\n#define big int maxi=-1\n#define rep(i,n) for(int (i)=1;(i)<=(n);(i)++)\n#define small int mini=1e9+7\n#define op(x) freopen(x,\"r\",stdin)\n#define wr(x) freopen(x,\"w\",stdout)\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<int,pair<int,int> > pipi;\ntypedef vector<int> vi;\ntypedef map<int,int> mii;\ntypedef map<string,int> msi;\ntypedef stack<int> sti;\ntypedef set<int> jihe;\ntypedef queue<int> qi;\ntypedef vector<pair<int,int> > vp;\ntypedef priority_queue<int,vector<int>,greater<int> > pqi;\ntypedef priority_queue<pii,vector<pii>,greater<pii> > pqpi;\nconst int inf=1e9+7;\nconst int maxn=5005;\nconst int maxm=200005;\nint Read(){\n    int x=0;char c=getchar();\n    while(c>'9'||c<'0')c=getchar();\n    while(c>='0'&&c<='9')x=x*10+c-'0',c=getchar();\n    return x;\n}\n\n/*-------------------------------main part------------------*/\n\nint n,m;\nint a[2005],ed[2005];\nvi v[2005],g[2005];\nvector<int> lt[2005];\nbool vis[2005];\n\n/*---------------------------declare * function-------------*/\n\nvoid dfs(int x,int it)\n{\n\tlt[it].pb(x);\n\tvis[x]=1;\n\tfor(int i=0;i<g[x].size();i++)\n\t{\n\t\tif(!vis[g[x][i]]) dfs(g[x][i],it);\n\t}\n}\n\n/*---------------------------function * main----------------*/\nint main()\n{\n\tios_base::sync_with_stdio(false);\n    cin>>n;\n    for(int i=1;i<=n;i++)\n    {\n    \tcin>>a[i];\n\t}\n\tmemset(ed,0,sizeof(ed));\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t{\n\t\t\tif(__gcd(a[i],a[j])!=1)\n\t\t\t{\n\t\t\t\ted[j]++;\n\t\t\t\tv[i].pb(j);\n\t\t\t\tg[i].pb(j);\n\t\t\t\tg[j].pb(i);\n\t\t\t}\n\t\t}\n\t}\n\tmemset(vis,0,sizeof(vis));\n\tm=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(!vis[i])\n\t\t{\n\t\t\tm++;\n\t\t\tdfs(i,m);\n\t\t}\n\t}\n\tmemset(vis,0,sizeof(vis));\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=n;j>=1;j--)\n\t\t{\n\t\t\tif(!vis[j] && !ed[j])\n\t\t\t{\n\t\t\t\tvis[j]=1;\n\t\t\t\tcout<<a[j]<<' ';\n\t\t\t\tfor(int k=0;k<v[j].size();k++)\n\t\t\t\t{\n\t\t\t\t\ted[v[j][k]]--;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nconst int MAXN=2005;\n\nint gcd(int a,int b)\n{\n\tif(b==0)\n\t\treturn a;\n\treturn gcd(b,a%b);\n}\n\nint n,A[MAXN];\nbool vis[MAXN];\nvector<int> adj[MAXN],adj2[MAXN];\nint deg[MAXN],ans[MAXN];\npriority_queue<int> Q;\n\nvoid dfs(int u)\n{\n\tvis[u]=true;\n\tfor(int i=0;i<(int)adj[u].size();i++)\n\t{\n\t\tint v=adj[u][i];\n\t\tif(vis[v])\n\t\t\tcontinue;\n\t\tadj2[u].push_back(v);\n\t\tdeg[v]++;\n\t\tdfs(v);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&A[i]);\n\tsort(A+1,A+n+1);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(i!=j&&gcd(A[i],A[j])>1)\n\t\t\t\tadj[i].push_back(j);\n\tfor(int i=1;i<=n;i++)\n\t\tif(!vis[i])\n\t\t\tdfs(i);\n\t\n\tfor(int i=1;i<=n;i++)\n\t\tif(deg[i]==0)\n\t\t\tQ.push(i);\n\tint it=0;\n\twhile(!Q.empty())\n\t{\n\t\tint u=Q.top();\n\t\tans[++it]=A[u];\n\t\tQ.pop();\n\t\tfor(int i=0;i<(int)adj2[u].size();i++)\n\t\t{\n\t\t\tint v=adj2[u][i];\n\t\t\tdeg[v]--;\n\t\t\tif(deg[v]==0)\n\t\t\t\tQ.push(v);\n\t\t}\n\t}\n\t\n\tfor(int i=1;i<n;i++)\n\t\tprintf(\"%d \",ans[i]);\n\tprintf(\"%d\\n\",ans[n]);\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<stack>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<cmath>\nusing namespace std;\nint gcd(int x,int y){return (y==0)?x:gcd(y,x%y);}\nint n;\nint a[2010];\nint in[2010];\nint vis[2010];\nint ed[2010][2010];\nvector<int> e[2010];\npriority_queue<int,vector<int>,less<int> > q;\nvoid dfs(int x)\n{\n\tvis[x]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tif(!vis[i]&&ed[x][i])\n\t\t{\n\t\t\tin[i]++;\n\t\t\te[x].push_back(i);\n\t\t\tdfs(i);\n\t\t}\n}\nsigned main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\tif(gcd(a[i],a[j])!=1)\n\t\t\t\ted[i][j]=1,ed[j][i]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tif(!vis[i])\n\t\t\tdfs(i);\n\tfor(int i=1;i<=n;i++)\n\t\tif(in[i]==0)\n\t\t\tq.push(i);\n\twhile(!q.empty())\n\t{\n\t\tint u=q.top();\n\t\tq.pop();\n\t\tprintf(\"%d \",a[u]);\n\t\tfor(int i=0;i<e[u].size();i++)\n\t\t{\n\t\t\tint to=e[u][i];\n\t\t\tin[to]--;\n\t\t\tif(in[to]==0)\n\t\t\t\tq.push(to);\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint a[5010],inn[5010],n;bool vis[5010];\nvector <int> des[5010];\nvoid dfs(int s)\n{\n\tvis[s]=true;\n\tfor (int i=1;i<=n;i++) if ((__gcd(a[i],a[s])!=1)&&(!vis[i]))\n\t{\n\t\tdes[s].push_back(i);\n\t\tinn[i]++;dfs(i);\n\t}\n}\n\t\t\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tsort(a+1,a+n+1);\n\tfor (int i=1;i<=n;i++) if (!vis[i]) dfs(i);\n\tpriority_queue<int> que;\n\tfor (int i=1;i<=n;i++) if (!inn[i]) que.push(i);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tint s=que.top();que.pop();\n\t\tprintf(\"%d \",a[s]);\n\t\tfor (int k=0;k<des[s].size();k++)\n\t\t{\n\t\t\tinn[des[s][k]]--;\n\t\t\tif (!inn[des[s][k]]) que.push(des[s][k]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<set>\n#include<iomanip>\n#define sqr(x)(x)*(x)\n#define fz1(i,n) for (i=1;i<=n;i++)\n#define fd1(i,n) for (i=n;i>=1;i--)\n#define fz0g(i,n) for (i=0;i<=n;i++)\n#define fd0g(i,n) for (i=n;i>=0;i--)\n#define fz0k(i,n) for (i=0;i<n;i++)\n#define fd0k(i,n) for (i=(long long)(n-1);i>=0;i--)\n#define fz(i,x,y) for (i=x;i<=y;i++)\n#define fd(i,y,x) for (i=y;i>=x;i--)\n#define ff(c,itr) for (__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n#define rdst(st,len){char ss[len];scanf(\"%s\",ss);(st)=ss;}\nusing namespace std;\n//struct bit{T_ arr[1000005];int lowbit(int x){return x&(-x);}void add(int x,T_ y){for (int i=x;i<=n;i+=lowbit(i)) arr[i]+=y;}T_ query(int x){T_ s=0;for (int i=x;i>0;i-=lowbit(i)) s+=arr[i];return s;}};\n//struct seg{struct treedot{int l,r;T_ sum,add;void update(T_ x){sum+=(r-l+1)*x; add+=x;}}c[800005];void pushdown(int id){if (c[id].add){c[id*2].update(c[id].add);c[id*2+1].update(c[id].add);c[id].add=0;}}void pushup(int id){c[id].sum=c[id*2].sum+c[id*2+1].sum;}void build(int id,int l,int r){if (l>r) return;c[id].l=l;c[id].r=r;c[id].sum=0;c[id].add=0;if (l==r) c[id].sum=0;else{int mid=l+(r-l)/2;build(id*2,l,mid);build(id*2+1,mid+1,r);pushup(id);}}void update(int id,int le,int ri,T_ x){if (le>c[id].r||ri<c[id].l) return;if (le<=c[id].l&&c[id].r<=ri) c[id].update(x);else{pushdown(id);update(id*2,le,ri,x);update(id*2+1,le,ri,x);pushup(id);}}T_ query(int id,int le,int ri){if (ri<c[id].l||c[id].r<le) return 0;if (le<=c[id].l&&c[id].r<=ri) return c[id].sum;T_ ans=0;pushdown(id);ans+=query(id*2,le,ri);ans+=query(id*2+1,le,ri);pushup(id);return ans;}};\nint n,m,i,j,a[2005],vis[2005];\nvector<int> bi[2005],bi2[2005];\nset<int> s;\nvoid dfs(int x)\n{\n\tif (vis[x]) return;\n\tvis[x]=1;\n\tff(bi[x],it)\n\t{\n\t\tif (!vis[*it])\n\t\t{\n\t\t\tbi2[x].push_back(*it);\n\t\t\tdfs(*it);\n\t\t}\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfz1(i,n) scanf(\"%d\",&a[i]);\n\tsort(a+1,a+n+1);\n\tfz1(i,n) fz1(j,n)\n\t{\n\t\tif (__gcd(a[i],a[j])!=1) bi[i].push_back(j);\n\t}\n\tfz1(i,n) if (!vis[i]) {dfs(i);s.insert(-i);}\n\twhile (!s.empty())\n\t{\n\t\tint x=*s.begin();s.erase(s.begin());\n\t\tff(bi2[-x],it) s.insert(-*it);\n\t\tcout<<a[-x]<<' ';\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n                                                                                                     \n                                             `-:://:::-                                             \n                                           `//:-------:/:`                                          \n                                          .+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .o:--...```..---+/`                                        \n                                       `/y+o/---....---:+o.                                         \n                                   `...````-os+/:---:/+o/--.`                                       \n              `-/+++++/:.      `...`       :h+d+oooo+/+-`   ...                                     \n            `/++//:::://++-`....`         -.`//````````:`     `..`                                  \n           `o+/::------://o/`           `-` -.          -`       `..`                               \n `---.-o/:./o/::-..``..-ЗАПУСКАЕМ      ..  ..            -`        `...       ``..``                \n  `....o+:-++/:--.```..-://s.        `-`  .-              -`          `-o: .-//::::/:-`             \n          `:s+/:--....-::/+s-`      .-   `-                -`           -///:--------:/:`           \n           ./s+//:::::://oo-``..НЕЙРОННУЮ: СЕТЬ:::::::-`РАБОТЯГИ        `+:--........--:/`          \n            .:ooo+++++osso-`    `.:-...`/` ./::-------:/:`   -`         :+--..``````.--:+:...-+:-`  \n             `.-/+++++/+-.-`    -.   ``:so:/:--.......--:+`  `-```````o+/+--..`````..--:o/-..:s+:.  \n                 ```````:``.. `-`     -` `+:--..`````..--/+-.../.`````..-o:--.......---/o.    `     \n                        `:  `:-      -.  .o:--..`` ``..--:o`   `-`      `:o+:--------:+o-`          \n                         `-`-...    ..   .o/--...```..--:+/`    `-`     `oy/so/////++o/.`           \n                          -/`  `-` `- ``+s/o/:---...---:++.      `-`   .-../d://///:-.`             \n                `.---..``-..-    .-/..`````-oo+/:::::/+o+-        `-``-`  `-.  ````                 \n             `:++++/+++++-  ..``.-/:`      /y-:/++o++/:.`..`       ./.   `-                         \n            -++/::::::://+/..:-``:` ..   `-.`  ```.```    `..`   `..`-` `-                          \n       ``  -o//:--....-::/++` -.-`   `-`.-`                 `..`..`  `-.-                           \n  -----ss+:++/:--.```..-://s.  /.     `::                    `-:.     ./`                           \n  `````/:..+o/::-..``.--:/+s. ..-`   `-``-`                 ..` `-`  `-`-`                          \n          `-s+/::-----::/+oo---``-` ..    .:-    ```      .-`     .-.-  `-`                         \n           `:oo+//::://+os/..:`..-/:`      :y.-:::::::.`.-`        ./-`  `-`                        \n            `./+oooooooo+/.`-    .-:...`.. .//:-------://`        `- `..` `:.                       \n              ``.-::::-.``-/`  `-` `-  `oo:+:--.......--:/`      `-    `.:--h.``..```               \n                          -.-`.-    .-   `+:--..`````..--//`    `-       /s-//::::::::.             \n                         -` `/-      ..  .o:--..`` ``..--:o.```.-        `//:--------://`           \n                        -` .-`.-`     -.`-o/--...```..--:+/.``-:....``:-.+:--....`...--:+`          \n                       ..`-.   `-.   ``:os:o/:---...---:++.  `-     ``///+:-..``````.--:+-````-.`   \n              `.:///////.-`      .:-..` -``-+o+/:::::/+o/.  `-         `:+:-..`````..--:o/:--/ys+-  \n            `-++///////+o/. ``....`-.    :` `.:++++++/:.`  .-           -o/---......---/o.   `.`    \n           `++//:-----::/+o:..`     .-`   :    ```````    .-           `+so+:--------:++-`          \n  `````:-``:o/::-..`..--:/+o`         -.  `-             .-          `../../+o+////+o+:.`           \n  -----syo/o+/:--.```..-://s.          .-` `-           .-        `...     ``-:////:-``             \n       .` `/s//:--....-::/+s.            -. `-`        .-       `..`                                \n           .+o+/:::--:://+s/-..`          .::+y  ```  .-     `..`                                   \n            ./oo++////+oso-`   `....       :y-+:::::::/`   ...                                      \n             `.:+oooooo/-`         `....-. .//:-------:/:-.`                                        \n                ``...``                 /+:+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .+/--...```..--:+/`                                        \n                                         `-o/:---...---:++.                                         \n                                          `-+o+/:---:/+o/.                                          \n                                            `.:+oooo+/-.`                                           \n                                               ``````                                               \n*/\n\n#ifdef aimbot\n#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#endif\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <set>\n#include <queue>\n#include <ostream>\n#include <istream>\n#include <typeinfo>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <limits>\n#include <fstream>\n#include <array>\n#include <list>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <cstring>\n#include <chrono>\n\n#define random escape__from__random__aetuhoetnuhshe\n#define mt make_tuple\n#define x first\n#define y second\n#define pb push_back\n#define ppb pop_back\n#define mp make_pair\n#define umap unordered_map\n#define uset unordered_set\n#define elif else if\n#define len(v) ((int)v.size())\n#define f(i, n) for (int i = 0; i < (n); i++)\n#define rof(i, n) for (int i = ((n) - 1); i >= 0; i--)\n#define apply(v, act) for (auto &x : v) { act; }\n#define log(args...) {string s = #args;deque<string> deq;\\\nstring buf = \"\";int bal = 0;for (char c : s) {\\\nif (c == '(' || c == '[' || c == '{') {bal++;\\\n} else if (c == ')' || c == ']' || c == '}') {\\\nbal--;} else {if (bal == 0) {if (c == ',') {\\\ndeq.pb(buf);buf = \"\";} else {if (c != ' ') {\\\nbuf += c;}}}}}if (!buf.empty()) {deq.pb(buf);}\\\nsmart_io::precall_print();smart_io::_print(deq, args);}\n\ninline int min(const int &x, const int &y) { return (((y-x)>>(32-1))&(x^y))^x; }\ninline int max(const int &x, const int &y) { return (((y-x)>>(32-1))&(x^y))^y; }\ninline long long min(const long long &x, const long long &y) { return (((y-x)>>(64-1))&(x^y))^x; }\ninline long long max(const long long &x, const long long &y) { return (((y-x)>>(64-1))&(x^y))^y; }\n\n#define print    \\\nsmart_io::precall_print(); \\\ncout,\n\n#define scan cin,\n\n#ifdef fast_allocator\nconst int MAXMEM = 200 * 1000 * 1024;\nchar _memory[MAXMEM];\nsize_t _ptr = 0;\nvoid* operator new(size_t _x) { _ptr += _x; assert(_ptr < MAXMEM); return _memory + _ptr - _x; }\nvoid operator delete (void*) noexcept {}\n#endif\n\nusing namespace std;\n\nchar string_in_buffer[(int)260];\n\n\nvoid fast_scan(int &x) { scanf(\"%d\", &x); }\nvoid fast_scan(long long &x) { scanf(\"%lld\", &x); }\nvoid fast_scan(unsigned long long &x) { scanf(\"%llu\", &x); }\nvoid fast_scan(double &x) { scanf(\"%lf\", &x); }\nvoid fast_scan(long double &x) { scanf(\"%Lf\", &x); }\nvoid fast_scan(char &x) {\n\tscanf(\"%c\", &x);\n\tif (x == '\\n') {\n\t\tfast_scan(x);\n\t}\n}\nvoid fast_scan(string &x) {\n\tscanf(\"%s\", string_in_buffer);\n\tx = string(string_in_buffer);\n}\n\ntemplate<class TFirst, class TSecond>\nvoid fast_scan(pair<TFirst, TSecond> &p) {\n\tfast_scan(p.first);\n\tfast_scan(p.second);\n}\n\ntemplate <class T>\nvoid fast_scan(vector<T> &v) {\n\tfor (auto &x : v) fast_scan(x);\n}\n\nvoid fast_print(const int &x) { printf(\"%d\", x); }\nvoid fast_print(const unsigned int &x) { printf(\"%u\", x); }\nvoid fast_print(const long long &x) { printf(\"%lld\", x); }\nvoid fast_print(const unsigned long long &x) { printf(\"%llu\", x); }\nvoid fast_print(const char &x) { printf(\"%c\", x); };\n// void fast_print(__int128 x) {\n// \tif (x == 0) { fast_print('0'); return; }\n// \tif (x < 0) {\n// \t\tfast_print('-');\n// \t\tx = -x;\n// \t}\n// \t__int128 p = 1;\n// \twhile (x / (p * 10)) p *= 10;\n// \twhile (p) {\n// \t\t__int128 symb = x / p;\n// \t\tfast_print((int)symb);\n// \t\tx -= p * symb;\n// \t\tp /= 10;\n// \t}\n// };\nvoid fast_print(const double &x) { printf(\"%.15lf\", x); }\nvoid fast_print(const long double &x) { printf(\"%.15Lf\", x); }\nvoid fast_print(const string &x) { printf(\"%s\", x.c_str());}\nvoid fast_print(const char v[]) { fast_print((string)v); }\n\ntemplate<class TFirst, class TSecond>\nvoid fast_print(const pair<TFirst, TSecond> &p) {\n\tfast_print(p.first);\n\tfast_print(' ');\n\tfast_print(p.second);\n}\n\ntemplate <class T>\nvoid fast_print(const vector<T> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print(' ');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const vector<vector<T>> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print('\\n');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const T &v) {\n\tfor (const auto &x : v) {\n\t\tfast_print(x);\n\t\tfast_print(' ');\n\t}\n}\n\n\nusing namespace std;\n\n\nnamespace smart_io {\n\tstring print_start = \"\";\n\tstring sep = \" \";\n\tbool first_print = false;\n\t\n\tvoid precall_print() {\n\t\tfast_print(print_start);\n\t\tprint_start = \"\\n\";\n\t\tfirst_print = true;\n\t}\n\t\n\tvoid _print(deque<string>) {}\n\ttemplate<class T, class... Args>\n\tvoid _print(deque<string> names, T elem, Args... args) {\n\t\tif (!first_print) {\n\t\t\tfast_print(\"\\n\");\n\t\t} else {\n\t\t\tfirst_print = false;\n\t\t}\n\t\tfast_print(names.front());\n\t\tfast_print(\" = \");\n\t\tfast_print(elem);\n\t\tnames.pop_front();\n\t\t_print(names, args...);\n\t}\n} //namespace smart_io\n\n\ntemplate <class T>\nostream &operator,(ostream &os, const T &object) {\n\tif (!smart_io::first_print) {\n\t\tfast_print(smart_io::sep);\n\t} else {\n\t\tsmart_io::first_print = false;\n\t}\n\tfast_print(object);\n\treturn os;\n}\n\ntemplate <class T>\nistream &operator,(istream &is, T &object) {\n\tfast_scan(object);\n\treturn is;\n}\n\nnamespace random {\n\tusing namespace std::chrono;\n\tmt19937 rng(duration_cast< milliseconds >(\n\t\t\t\t\t\t\t\t\t\t\t  system_clock::now().time_since_epoch()\n\t\t\t\t\t\t\t\t\t\t\t  ).count());\n\tuniform_real_distribution<> prob_dist(0.0, 1.0);\n};\n\nnamespace typedefs {\n\ttypedef long long ll;\n\ttypedef unsigned long long ull;\n\ttypedef pair<int, int> pii;\n\ttypedef long double ld;\n}\n\nnamespace numbers_operation {\n\ttemplate<class T>\n\tinline T floor_mod(T a, const T &b) {\n\t\ta %= b;\t\n\t\tif (a < 0) a += b;\n\t\treturn a;\n\t}\n}\n\nusing namespace numbers_operation;\nusing namespace typedefs;\nusing namespace random;\n\nint gcd(int a, int b) {\n\treturn __gcd((unsigned int)a, (unsigned int)b);\n}\t\n\nint n;\nvector<vector<int>> factors;\nvector<int> v;\n\nvoid factorize(int n, vector<int> &rez) {\n\tfor (int i = 2; i * i <= n; i++) {\n\t\twhile (n % i == 0) {\n\t\t\tn /= i;\n\t\t\trez.pb(i);\n\t\t}\n\t}\n\tif (n > 1) rez.pb(n);\n\tsort(rez.begin(), rez.end());\n\trez.resize(unique(rez.begin(), rez.end()) - rez.begin());\n}\n\nstruct SUS {\n\tvector<int> up;\n\tint get_root(int i) {\n\t\tif (up[i] == i) return i;\n\t\treturn up[i] = get_root(up[i]);\n\t}\n\tSUS(int n) {\n\t\tup.resize(n);\n\t\tf(i, n) up[i] = i;\n\t}\n\tvoid merge(int a, int b) {\n\t\tup[get_root(a)] = get_root(b);\n\t}\n\tbool one_comp(int a, int b) {\n\t\treturn get_root(a) == get_root(b);\n\t}\n};\n\nvector<int> order(vector<int> cur, const set<int> &F, int lv = 0) {\n\tif (len(cur) <= 1) return cur;\n\tint take = -1;\n\tfor (int i = 0; i < len(cur); i++) {\n\t\tif (F.count(v[cur[i]])) \n\t\t\tif (take == -1 || v[cur[i]] < v[cur[take]])\n\t\t\t\ttake = i;\n\t}\n\tassert(take != -1);\n\tstatic map<int, vector<int>> at{};\n\tfor (int i = 0; i < len(cur); i++) {\n\t\tif (i == take) continue;\n\t\tfor (int x : factors[cur[i]]) {\n\t\t\tat[x].pb(i);\n\t\t}\n\t}\n\tSUS sus(len(cur));\n\tfor (auto p : at) {\n\t\tfor (int j = 0; j < len(p.y) - 1; j++) {\n\t\t\tsus.merge(p.y[j], p.y[j + 1]);\n\t\t}\n\t}\n\tmap<int, vector<int>> index;\n\tfor (int i = 0; i < len(cur); i++) {\n\t\tif (i == take) continue;\n\t\tindex[sus.get_root(i)].pb(cur[i]);\n\t}\n\tset<int> ava;\n\tfor (int i = 0; i < len(cur); i++) {\n\t\tif (i == take) continue;\n\t\tif (gcd(v[cur[i]], v[cur[take]]) > 1 || (v[cur[i]] <= v[cur[take]] && F.count(v[cur[i]])))\n\t\t\tava.insert(v[cur[i]]);\n\t}\n\tvector<int> rez;\n\tfor (auto p : index) {\n\t\tvector<int> t = order(p.y, ava, lv + 1);\n\t\tvector<int> final;\n\t\tmerge(rez.begin(), rez.end(), t.begin(), t.end(), back_inserter(final), [](int i, int j) {\n\t\t\treturn v[i] > v[j];\n\t\t});\n\t\trez = final;\n\t}\n\trez.insert(rez.begin(), cur[take]);\n\treturn rez;\n}\n\nsigned main(signed argc, char *argv[]) {\n\tscan n;\n\tv.resize(n);\n\tfactors.resize(n);\n\tscan v;\n\tfor (int i = 0; i < n; i++) {\n\t\tfactorize(v[i], factors[i]);\n\t}\n\tvector<int> cur(n);\n\tiota(cur.begin(), cur.end(), 0);\n\t{\n\t\tmap<int, vector<int>> at;\n\t\tfor (int i = 0; i < len(cur); i++) {\n\t\t\tfor (int x : factors[cur[i]]) {\n\t\t\t\tat[x].pb(i);\n\t\t\t}\n\t\t}\n\t\tSUS sus(len(cur));\n\t\tfor (auto p : at) {\n\t\t\tfor (int j = 0; j < len(p.y) - 1; j++) {\n\t\t\t\tsus.merge(p.y[j], p.y[j + 1]);\n\t\t\t}\n\t\t}\n\t\tmap<int, vector<int>> index;\n\t\tfor (int i = 0; i < len(cur); i++) {\n\t\t\tindex[sus.get_root(i)].pb(i);\n\t\t}\n\t\tset<int> ava;\n\t\tfor (int i = 0; i < len(cur); i++) {\n\t\t\tava.insert(v[cur[i]]);\n\t\t}\n\t\tvector<int> rez;\n\t\tfor (auto p : index) {\n\t\t\tvector<int> t = order(p.y, ava);\n\t\t\tvector<int> final;\n\t\t\tmerge(rez.begin(), rez.end(), t.begin(), t.end(), back_inserter(final), [](int i, int j) {\n\t\t\t\treturn v[i] > v[j];\n\t\t\t});\n\t\t\trez = final;\n\t\t}\n\t\tfor (int i = 0; i < len(rez); i++)\n\t\t\trez[i] = v[rez[i]];\n\t\tprint rez;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <functional>\n#define repeat(i,n) for (int i = 0; (i) < int(n); ++(i))\n#define whole(f,x,...) ([&](decltype((x)) whole) { return (f)(begin(whole), end(whole), ## __VA_ARGS__); })(x)\nusing ll = long long;\nusing namespace std;\ntemplate <class T> using reversed_priority_queue = priority_queue<T, vector<T>, greater<T> >;\nint gcd(int a, int b) { while (a) { b %= a; swap(a, b); } return b; }\nbool is_swappable(int a, int b) { return gcd(a, b) == 1; }\nint main() {\n    // input\n    int n; cin >> n;\n    vector<int> a(n); repeat (i,n) cin >> a[i];\n    // rearrange\n    whole(sort, a);\n    vector<int> b;\n    vector<bool> used(n);\n    repeat (root,n) if (not used[root]) {\n        reversed_priority_queue<int> que;\n        que.push(a[root]);\n        used[root] = true;\n        while (not que.empty()) {\n            int ai = que.top(); que.pop();\n            b.push_back(ai);\n            repeat (j,n) if (not used[j] and not is_swappable(ai, a[j])) {\n                que.push(a[j]);\n                used[j] = true;\n            }\n        }\n    }\n    // insertion sort\n    repeat (i,n) {\n        int j = i;\n        for (int k = i-1; k >= 0 and is_swappable(b[k], b[i]); -- k) {\n            if (b[k] < b[i]) j = k;\n        }\n        rotate(b.begin() + j, b.begin() + i, b.begin() + i + 1);\n    }\n    // output\n    for (auto it : b) cout << it << ' '; cout << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int jt=998244353;\n#define loop(i,n) for(int i=0;i<(n);i++)\n#define pool(i,n) for(int i=(n)-1;i>=0;i--)\n#define cont(i,n) for(int i=1;i<=(n);i++)\n#define tnoc(i,n) for(int i=(n);i>=1;i--)\n#define circ(i,a,b) for(int i=(a);i<=(b);i++)\n#define cric(i,a,b) for(int i=(b);i>=(a);i--)\n#define sub(i,a) for(int i=a;i;i=((i-1)&(a)))\n#define subs(i,a) for(int i=a;i>=0;i=(!i?-1:((i-1)&(a))))\n#define subt(i,a) for(int i=((a-1)&a);i;i=((i-1)&(a)))\n#define subst(i,a) for(int i=((a-1)&a);i>=0;i=(!i?-1:((i-1)&(a))))\n#define range(i,a,b,c) for(int i=(a);((c)>0?i<=(b):i>=(b));i+=(c))\n#define foreach(it,v) for(__typeof((v).begin()) it=(v).begin(),_e_D_=(v).end();it!=_e_D_;it++)\n#define parse(i,s) for(int i=0;s[i];i++)\n#define ln '\\n'\n#define all(a) a.begin(),a.end()\n#define OVER(s) return puts(s),0;\n#define FILL(a,x) memset(a,x,sizeof(a))\n#define FILL0(a) memset(a,0,sizeof(a))\n#define FILL1(a) memset(a,-1,sizeof(a))\n#define FILLBIG(a) memset(a,0x3f,sizeof(a))\n#define COPY(frm,to) memcpy(to,frm,sizeof(frm))\n#define Mask(a) (1ll<<(a))\n#define Maskx(a,x) ((a)<<(x))\n#define Full(a) ((1ll<<(a))-1)\n#define Bit(a,x) (((a)>>(x))&1)\n#define SZ(a) ((int)((a).size()))\n#define filei(a) freopen(a,\"r\",stdin);\n#define fileo(a) freopen(a,\"w\",stdout);\n#define fileio(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)\n#define Floyd(a,n) cont(k,n)cont(i,n)cont(j,n)chmin(a[i][j],a[i][k]+a[k][j])\n#define Floyd0(a,n) loop(k,n)loop(i,n)loop(j,n)chmin(a[i][j],a[i][k]+a[k][j])\n#define Floydlr(a,l,r) circ(k,l,r)circ(i,l,r)circ(j,l,r)chmin(a[i][j],a[i][k]+a[k][j])\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define y0 y0O0OO00OO0OO0OO0OOO00OO0OO0O0O000OO0\n#define y1 y1II11II11III11I1III11II111IIII1II1I1\n#define ws WSrAkIoi2333wSraKIoIWSraKiOi\n#define left left_jTjTJtJtIoiiOiioIAuaU66666jtIOIau\n#define hash whYusEthiSnamE_caNyoUusEothERnaMesliKeHSH\n#define pub push_back\n#define pob pop_back\n#define puf push_front\n#define pof pop_front\n#define mak make_pair\n#define emb emplace_back\n#define emf emplace_front\n#define emp emplace\n#define popcnt __builtin_popcount\n#define Popcnt __builtin_popcountll\ntemplate<typename _T>\nusing pair2=pair<_T,_T>;\ntemplate<typename _T>\nusing pair3=pair<pair<_T,_T>,_T>;\ntemplate<typename _T>\nusing pair4=pair<pair<_T,_T>,pair<_T,_T> >;\n#define mak3(a,b,c) make_pair(make_pair(a,b),c)\n#define mak4(a,b,c,d) make_pair(make_pair(a,b),make_pair(c,d))\ntemplate<typename _T>\nusing priq=priority_queue<_T>;\ntemplate<typename _T>\nusing qrip=priority_queue<_T,vector<_T>,greater<_T> >;\n#define ST first\n#define ND second\n#define FST first.first\n#define SND first.second\n#define RD second\n#define SRD second.first\n#define FTH second.second\n#ifndef JTAKIOI\n#define cerr if(0)cout\n#define tctest(clas,meth,...)\n#else\n#define tctest(clas,meth,...) int main(){fio<<(new clas)->meth(__VA_ARGS__)<<ln;}\n#endif\ntypedef long long ll;\ntypedef long double lf;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef istringstream iss;\ntypedef stringstream sst;\nconst lf pi=acosl(-1);\nconst int Inf=0x3f3f3f3f;\nconst ll INF=0x3f3f3f3f3f3f3f3fll;\nconst lf inF=11451419198101145141919810.1145141919810;\nconst int Dx[]={1,0,-1,0,1,1,-1,-1},Dy[]={0,1,0,-1,1,-1,1,-1};\n#ifdef JTAKIOI\nmt19937_64 Rand;void inline Srand(int x){Rand.seed(x);}\n#else\nvoid inline Srand(int x){srand(x);}\null inline Rand(){return ((rand()*32768ull+rand())*32768ull+rand())*32768ull+rand();}\n#endif\nll inline rand(ll a,ll b){return Rand()%(b-a+1)+a;}\ntemplate<typename _T>\ninline _T chmin(_T &a,_T b){return a>b?(a=b):a;}\ntemplate<typename _T>\ninline _T chmax(_T &a,_T b){return a<b?(a=b):a;}\ntemplate<typename _T,int len>\nstruct BIT{\n\t_T dt[len];\n\tinline void add(int a,_T x){while(a<len){dt[a]+=x;a+=a&-a;}}\n\tinline void add(int l,int r,_T x){add(l,x);add(r+1,-x);}\n\tinline _T get(int a){_T ans=0;while(a){ans+=dt[a];a-=a&-a;}return ans;}\n\tinline _T get(int l,int r){return get(r)-get(l-1);}\n};\ntemplate<typename _T,int len>\nstruct segbit{\n\t_T dt[2][len];\n\tinline void add(int a,_T x){int b=a;while(a<len){dt[0][a]+=x;dt[1][a]+=x*b;a+=a&-a;}}\n\tinline void add(int l,int r,_T x){add(l,x);add(r+1,-x);}\n\tinline _T sum(int a){_T ans=0;int b=a;while(a){ans+=(b+1)*dt[0][a]-dt[1][a];a-=a&-a;}return ans;}\n\tinline _T sum(int l,int r){return sum(r)-sum(l-1);}\n};\nconst lf eps=1e-10;\nstruct point{\n\tlf x,y;\n\tlf ang;\n\tpoint(){}\n\tpoint(lf x,lf y):x(x),y(y){ang=atan2l(y,x);}\n\tinline point operator=(const point &pt){x=pt.x;y=pt.y;return *this;}\n\tinline point operator-()const{return point(-x,-y);}\n\tinline point operator+(const point &pt)const{return point(x+pt.x,y+pt.y);}\n\tinline point operator-(const point &pt)const{return point(x-pt.x,y-pt.y);}\n\tinline point operator*(const lf &a)const{return point(x*a,y*a);}\n\tinline point operator/(const lf &a)const{return point(x/a,y/a);}\n\tinline point operator^(const lf &ang)const{return point(x*cosl(ang)-y*sinl(ang),x*sinl(ang)+y*cosl(ang));}\n\tinline point operator+=(const point &pt){return *this=point(x+pt.x,y+pt.y);}\n\tinline point operator-=(const point &pt){return *this=point(x-pt.x,y-pt.y);}\n\tinline point operator*=(const lf &a){return *this=point(x*a,y*a);}\n\tinline point operator/=(const lf &a){return *this=point(x/a,y/a);}\n\tinline point operator^=(const lf &ang){return *this=point(x*cosl(ang)-y*sinl(ang),x*sinl(ang)+y*cosl(ang));}\n\tinline lf operator*(const point &pt)const{return x*pt.x+y*pt.y;}//dot\n\tinline lf operator%(const point &pt)const{return x*pt.y-y*pt.x;}//det\n\tinline lf length()const{return x*x+y*y;}\n\tinline lf size()const{return sqrtl(x*x+y*y);}\n\tinline lf operator^(const point &pt)const{return acosl(*this*pt)/length()/pt.length();}\n\tinline lf getangle(){return ang=atan2l(y,x);}\n\tinline lf angle()const{return atan2l(y,x);}\n\tinline bool operator<(const point &p)const{return ang<p.ang;}\n};\ninline bool xsmaller(const point &x,const point &y){return fabs(x.x-y.x)<1e-10?x.y<y.y:x.x<y.x;}\ninline bool ysmaller(const point &x,const point &y){return fabs(x.y-y.y)<1e-10?x.x<y.x:x.y<y.y;}\nstruct line{\n\tpoint a,b;\n\tline(){}\n\tline(point a,point b):a(a),b(b){}\n};\npoint inline intersect(line x,line y){\n\tpoint p1=x.a,v1=x.b-x.a;\n\tpoint p2=y.a,v2=y.b-y.a;\n\treturn p1+v1*(((p2-p1)%v2)/(v1%v2));\n}\ntemplate<int jt>\nint inline natsu_ksmii_with_jt(int a,int b){\n\tif(b<0)return natsu_ksmii_with_jt<jt>(a,jt-1-b);\n\tif(!b)return 1;\n\tint x=natsu_ksmii_with_jt<jt>(a,b>>1);\n\tx=1ll*x*x%jt;\n\tif(b&1)x=1ll*x*a%jt;\n\treturn x;\n}\ntemplate<int jt>\nstruct modint{\n\tint x;\n\tmodint(int X=0){x=X;x%=jt;if(x<0)x+=jt;}\n\tmodint(long long X=0){x=X%jt;if(x<0)x+=jt;}\n\tmodint<jt> inline &operator+=(const modint<jt> &m)const{x+=m.x;if(x>=jt)x-=jt;return *this;}\n\tmodint<jt> inline &operator++()const{return *this+=1;}\n\tmodint<jt> inline operator+(const modint<jt> &m)const{modint<jt> mc=*this;mc+=m;return mc;}\n\tmodint<jt> inline &operator-=(const modint<jt> &m)const{x-=m.x;if(x<0)x+=jt;return *this;}\n\tmodint<jt> inline &operator--()const{return *this-=1;}\n\tmodint<jt> inline operator-(const modint<jt> &m)const{modint<jt> mc=*this;mc-=m;return mc;}\n\tmodint<jt> inline operator*(const modint<jt> &m)const{return 1ll*x*m.x%jt;}\n\tmodint<jt> inline &operator*=(const modint<jt> &m)const{return *this=*this*m;}\n\tmodint<jt> inline inv()const{modint<jt> mc=*this;mc.x=natsu_ksmii_with_jt<jt>(mc.x,jt-2);}\n\tmodint<jt> inline &operator/(const modint<jt> &m)const{return 1ll*x*m.inv().x%jt;}\n\tmodint<jt> inline &operator/=(const modint<jt> &m)const{return *this=*this/m;}\n\tbool inline empty()const{return !x;}\n};\ninline int ksmii(int a,int b=jt-2){\n\tif(b<0){return ksmii(ksmii(a),-b);}\n\tif(!b){return 1;}\n\tint x=ksmii(a,b>>1);x=1ll*x*x%jt;\n\tif(b&1)x=1ll*x*a%jt;return x;\n}\ntypedef modint<jt> mint;\ntemplate<typename tp> tp gcd(tp a,tp b){return !b?a:gcd(b,a%b);}\ntemplate<int len>\nstruct bitmod{\n\tint dt[len];\n\tinline void add(int a,int x){while(a<len){dt[a]=(dt[a]+x)%jt;a+=a&-a;}}\n\tinline void add(int l,int r,int x){add(l,x%jt);add(r+1,jt-x%jt);}\n\tinline int get(int a){int ans=0;while(a){ans=(ans+dt[a])%jt;a-=a&-a;}return ans;}\n\tinline int get(int l,int r){return (get(r)-get(l-1)+jt)%jt;}\n};\ntemplate<int len>\nstruct DSU{\n\tint fa[len],sz[len];\n\tDSU(){loop(i,len)fa[i]=i,sz[i]=1;}\n\tvoid inline init(){loop(i,len)fa[i]=i,sz[i]=1;}\n\tint inline root(int x){return fa[x]==x?x:(fa[x]=root(fa[x]));}\n\tbool inline conn(int a,int b){a=root(a);b=root(b);if(a==b)return 0;fa[a]=b;sz[b]+=sz[a];return 1;}\n};\ntemplate<typename _T>\ninline _T qp(_T a,int b){\n\tif(!b){return 1;}\n\t_T x=qp(a,b>>1);x=x*x;\n\tif(b&1){x=x*a;}return x;\n}\ntemplate<int R,int C=R>\nstruct matrix{\n\tint mat[R][C];\n\tint* operator[](int x){return mat[x];}\n\tmatrix(){loop(i,R)loop(j,C)mat[i][j]=0;}\n\tmatrix(int x){loop(i,R)loop(j,C)mat[i][j]=(i==j?x:0);}\n\tmatrix<R,C> inline operator+(const matrix<R,C> m){\n\t\tmatrix<R,C> ans;\n\t\tloop(i,R)loop(j,C)ans.mat[i][j]=(mat[i][j]+m.mat[i][j])%jt;\n\t\treturn ans;\n\t}\n\ttemplate<int D> matrix<R,D> inline operator*(const matrix<C,D> m){\n\t\tmatrix<R,D> ans;\n\t\tloop(i,R)loop(j,C)loop(k,D)ans.mat[i][k]=(ans.mat[i][k]+((ll)mat[i][j])*m.mat[j][k])%jt;\n\t\treturn ans;\n\t}\n\tmatrix<R,C> inline operator+=(const matrix<R,C> m){\n\t\tmatrix<R,C> ans;\n\t\tloop(i,R)loop(j,C)ans.mat[i][j]=(mat[i][j]+m.mat[i][j])%jt;\n\t\treturn ans;\n\t}\n\tmatrix<R,C> inline operator-=(const matrix<R,C> m){\n\t\tmatrix<R,C> ans;\n\t\tloop(i,R)loop(j,C)ans.mat[i][j]=(mat[i][j]-m.mat[i][j]+jt)%jt;\n\t\treturn ans;\n\t}\n\tvoid inline debug(){loop(i,R){loop(j,C)cerr<<mat[i][j]<<' ';cerr<<endl;}cerr<<endl;}\n};\nstruct fastIO{\n\tinline fastIO operator>>(int& num){\n\t\tnum=0;char c=getchar();while(c!='-'&&(c<'0'||c>'9'))c=getchar();\n\t\tbool foo=0;if(c=='-'){foo=1;c=getchar();}\n\t\twhile(c>='0'&&c<='9'){num=(num<<3)+(num<<1)+c-'0';c=getchar();}\n\t\tif(foo)num=-num;return *this;\n\t}\n\tinline fastIO operator>>(ll& num){\n\t\tnum=0;char c=getchar();while(c!='-'&&(c<'0'||c>'9'))c=getchar();\n\t\tbool foo=0;if(c=='-'){foo=1;c=getchar();}\n\t\twhile(c>='0'&&c<='9'){num=(num<<3)+(num<<1)+c-'0';c=getchar();}\n\t\tif(foo)num=-num;return *this;\n\t}\n\tinline fastIO operator>>(float& num){scanf(\"%f\",&num);return *this;}\n\tinline fastIO operator>>(double& num){scanf(\"%lf\",&num);return *this;}\n\tinline fastIO operator>>(long double& num){scanf(\"%Lf\",&num);return *this;}\n\tinline fastIO operator>>(char& num){num=getchar();while(num==' '||num=='\\n')num=getchar();return *this;}\n\tinline fastIO operator>>(char* num){\n\t\tint cnt=0;char c=getchar();while(c==' '||c=='\\n')c=getchar();\n\t\twhile(c!=' '&&c!='\\n'){num[cnt++]=c;c=getchar();}num[cnt]=0;return *this;\n\t}\n\tinline fastIO operator>>(string& num){cin>>num;return *this;}\n\ttemplate<int jt> inline fastIO operator>>(modint<jt> &num){int x;*this>>x;num=x;return *this;}\n\tinline void printInt(const int& num){if(num<10){putchar(num+'0');return;}printInt(num/10);putchar((num%10)+'0');}\n\tinline void printll(const ll& num){if(num<10){putchar(num+'0');return;}printll(num/10);putchar((num%10)+'0');}\n\tinline fastIO operator<<(const int& num){if(num<0)putchar('-'),printInt(-num);else printInt(num);return *this;}\n\tinline fastIO operator<<(const ll& num){if(num<0)putchar('-'),printll(-num);else printll(num);return *this;}\n\tinline fastIO operator<<(const float& num){printf(\"%.10f\",num);return *this;}\n\tinline fastIO operator<<(const double& num){printf(\"%.16lf\",num);return *this;}\n\tinline fastIO operator<<(const long double& num){printf(\"%.20Lf\",num);return *this;}\n\tinline fastIO operator<<(const char& num){putchar(num);return *this;}\n\tinline fastIO operator<<(const char* num){for(int i=0;num[i];i++)putchar(num[i]);return *this;}\n\tinline fastIO operator<<(const string& num){cout<<num;return *this;}\n\ttemplate<int jt> inline fastIO operator<<(const modint<jt> &num){printInt(num.x);return *this;}\n\ttemplate<typename _T> inline fastIO operator<<(const vector<_T> &vec){printf(\"{ \");foreach(i,vec)operator<<(*i)<<' ';printf(\"}\");return *this;}\n}fio;\n\nint n,a[2005];\nvector<int> nei[2005],son[2005],cs[2005],ans;\nbool lgl[2005];\n\nvoid dfs(int now,int cc){\n\tcs[cc].pub(now);lgl[now]=1;\n\tforeach(i,nei[now])if(!lgl[*i])dfs(*i,cc),son[now].pub(*i);\n}\n\nint main(){\n\tfio>>n;cont(i,n)fio>>a[i];sort(a+1,a+n+1);\n\tcont(i,n)cont(j,n)if(gcd(a[i],a[j])!=1)nei[i].pub(j);\n\tint ccs=0;cont(i,n)if(!lgl[i])dfs(i,++ccs);\n\tpriq<pair2<int>> pq;cont(i,ccs)pq.emp(a[cs[i][0]],cs[i][0]);\n\twhile(pq.size()){\n\t\tpair2<int> X=pq.top();pq.pop();\n\t\tint v=X.ST,x=X.ND;ans.pub(v);\n\t\tforeach(i,son[x])pq.emp(a[*i],*i);\n\t}\n\tforeach(i,ans)fio<<*i<<' ';fio<<ln;return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \nusing namespace std;\n\n#define ll long long\n#define mp make_pair\n#define pb push_back\n\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#define rep(i, n) for (int i = 0; i < (int)(n); ++ i)\n\nconst int maxn = 2005;\nint n;\nint a[maxn];\nvector <int> g[maxn], ng[maxn];\nbool vis[maxn];\n\nvoid dfs(int u) {\n\tvis[u] = 1;\n\trep(i, g[u].size()) {\n\t\tint v = g[u][i];\n\t\tif (!vis[v]) dfs(v), ng[u].pb(v);\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\trep(i, n) scanf(\"%d\", &a[i]);\n\tsort(a, a + n);\n\trep(i, n) rep(j, i) if (__gcd(a[i], a[j]) > 1) g[i].pb(j), g[j].pb(i);\n\tpriority_queue <pair <int, int> > pq;\n\trep(i, n) if (!vis[i]) dfs(i), pq.push(mp(a[i], i));\n\twhile (!pq.empty()) {\n\t\tint u = pq.top().second;\n\t\tpq.pop();\n\t\tprintf(\"%d \", a[u]);\n\t\trep(i, ng[u].size()) {\n\t\t\tint v = ng[u][i];\n\t\t\tpq.push(mp(a[v], v));\n\t\t}\n\t}\n\tputs(\"\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i, a, b) for (int i = (a), i##_end_ = (b); i < i##_end_; ++i)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define mp make_pair\n#define x first\n#define y second\n#define pb push_back\n#define SZ(x) (int((x).size()))\n#define ALL(x) (x).begin(), (x).end()\n\ntemplate<typename T> inline bool chkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate<typename T> inline bool chkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\n\ntypedef long long LL;\n\nconst int oo = 0x3f3f3f3f;\n\nconst int maxn = 2010;\n\nint n;\nint a[maxn + 5];\n\nbool vis[maxn + 5];\n\nint ans[maxn + 5];\n\nint p[maxn + 5];\n\nint main()\n{\n#ifdef matthew99\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\tscanf(\"%d\", &n);\n\tREP(i, 0, n) scanf(\"%d\", a + i);\n\tsort(a, a + n);\n\tmemset(p, 0, sizeof p);\n\tREP(i, 0, n)\n\t{\n\t\tint Maxp = -1;\n\t\tint pos = -1;\n\t\tREP(j, 0, n) if (!vis[j] && (!~Maxp || p[j] > pos))\n\t\t{\n\t\t\tMaxp = j;\n\t\t\tpos = p[j];\n\t\t\twhile (pos < i && ans[pos] > a[Maxp]) ++pos;\n\t\t}\n\t\tvis[Maxp] = 1;\n\t\tREP(j, 0, n) if (!vis[j])\n\t\t{\n\t\t\tif (p[j] > pos) ++p[j];\n\t\t\telse if (__gcd(a[Maxp], a[j]) > 1) p[j] = pos + 1;\n\t\t}\n\t\trotate(ans + pos, ans + i, ans + i + 1);\n\t\tans[pos] = a[Maxp];\n\t}\n\tREP(i, 0, n) printf(\"%d \", ans[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <cmath>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <bitset>\n#define y1 y11\n#define fs first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define mt make_tuple\n#define NAME \"\"\n\nusing namespace std;\n\t\ntypedef long long ll;\ntypedef long double ld;\n\nconst ld PI = acos(-1.0);\n\nint gcd(int a, int b)\n{\n\twhile (b != 0)\n\t{\n\t\tint c = a % b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\n\nconst int MAXN = 2001;\n\nint a[MAXN];\nvector <int> pd[MAXN];\nvector <int> as[MAXN * 40];\nint ps[MAXN * 100];\nint pc = 0;\nbool w[MAXN];\nbool wc[MAXN];\n\nbool pw[MAXN * 40];\nint q[MAXN], qb, qe;\nint block[MAXN];\nint mn[MAXN];\n\nbool e[MAXN][MAXN];\nint main()\n{\n\t//freopen(\"input.txt\", \"r\", stdin); freopen(\"output.txt\", \"w\", stdout);\t\n\tint n;\n\tcin >> n;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tcin >> a[i];\n\t}\n\tsort(a, a + n);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (int j = 0; j < n; j++)\n\t\t{\n\t\t\te[i][j] = (gcd(a[i], a[j]) > 1);\n\t\t}\n\t\tint na = a[i];\n\t\tfor (int j = 2; j * j <= a[i]; j++)\n\t\t{\n\t\t\tif (na % j == 0)\n\t\t\t{\n\t\t\t\twhile (na % j == 0) na /= j;\n\t\t\t\tpd[i].push_back(j);\n\t\t\t\tps[pc++] = j;\n\t\t\t}\n\t\t}\n\t\tif (na != 1) pd[i].push_back(na), ps[pc++] = na;\n\t}\n\tsort(ps, ps + pc);\n\tpc = unique(ps, ps + pc) - ps;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tw[i] = false;\n\t\tfor (int j = 0; j < pd[i].size(); j++)\n\t\t{\n\t\t\tint v = lower_bound(ps, ps + pc, pd[i][j]) -ps;\n\t\t\tpd[i][j] = v;\n\t\t\tas[v].push_back(i);\n\t\t}\n\t}\n\tfor (int iter = 0; iter < n; iter++)\n\t{\n\t\tmn[iter] = n;\n\t\tqe = qb = 0;\n\t\tfor (int i = 0; i < n; i++) wc[i] = w[i];\n\t\tfor (int i = 0; i < pc; i++) ps[i] = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (!wc[i]) q[qe++] = i, wc[i] = true;\n\t\t\twhile (qb < qe)\n\t\t\t{\n\t\t\t\tint v = q[qb++];\n\t\t\t\tfor (int j = 0; j < pd[v].size(); j++)\n\t\t\t\t{\n\t\t\t\t\tint u = pd[v][j];\n\t\t\t\t\tif (ps[u]) continue;\n\t\t\t\t\tps[u] = 1;\n\t\t\t\t\tfor (int l = 0; l < as[u].size(); l++)\n\t\t\t\t\t{\n\t\t\t\t\t\tint v2 = as[u][l];\n\t\t\t\t\t\tif (wc[v2]) continue;\n\t\t\t\t\t\twc[v2] = true;\n\t\t\t\t\t\tq[qe++] = v2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((qe + iter == n) && (mn[block[i]] > i) && (!w[i]))\n\t\t\t{\n\t\t\t\tcout << a[i] << \" \";\n\t\t\t\tfor (int j = 0; j <= iter; j++) mn[j] = min(mn[j], i); \n\t\t\t\tw[i] = true;\n\t\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\t{\n\t\t\t\t\tif (e[i][j]) block[j] = iter + 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define FOR(i,a,b) for (register int i=(a);i<=(b);i++)\n#define For(i,a,b) for (register int i=(a);i>=(b);i--)\n#define mem(i,j) memset(i,j,sizeof(i))\n#define GO(u) for (register int j=f[u];j!=-1;j=nxt[j])\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define MP make_pair\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\nconst int N=2020;\nint n,a[N],vis[N],l[N],r[N],line[N][N],cnt=0,ans[N];\nvector<int> vec[N];\npriority_queue <pii> q;\ninline int read()\n{\n\tint x=0,f=1;\n\tchar c=getchar();\n\twhile (c<'0'||c>'9') {if (c=='-') f=-1;c=getchar();}\n\twhile (c>='0'&&c<='9') {x=(x<<1)+(x<<3)+c-'0';c=getchar();}\n\treturn f*x;\n}\ninline void write(int x)\n{\n\tif (x<0) putchar('-'),x=-x;\n\tif (x>9) write(x/10);\n\tputchar(x%10+'0');\n\treturn;\n}\ninline int GCD(int x,int y)\n{\n\tif (!y) return x;\n\tif (x<y) return GCD(y,x);\n\treturn GCD(y,x%y);\n}\ninline void dfs(int u)\n{\n\tvis[u]=1;\n\tline[cnt][++r[cnt]]=u;\n\tFOR(i,0,(int)vec[u].size()-1)\n\t{\n\t\tint v=vec[u][i];\n\t\tif (vis[v]) continue;\n\t\tdfs(v);\n\t}\n\treturn;\n}\nint main()\n{\n\tn=read();\n\tFOR(i,1,n) a[i]=read();\n\tFOR(i,1,n) FOR(j,1,n) if (i!=j) if (GCD(a[i],a[j])>1) vec[i].pb(j);\n\tFOR(i,1,n) sort(vec[i].begin(),vec[i].end());\n\tFOR(i,1,n) if (!vis[i]) {cnt++;l[cnt]=1,r[cnt]=0;dfs(i);}\n\tFOR(i,1,cnt) q.push(MP(line[i][l[i]],i));\n\twhile (q.size())\n\t{\n\t\tpii tmp=q.top();\n\t\tq.pop();\n\t\tans[++ans[0]]=tmp.fi;\n\t\tif (l[tmp.se]<=r[tmp.se])\n\t\t{\n\t\t\tl[tmp.se]++;\n\t\t\tq.push(MP(line[tmp.se][l[tmp.se]],tmp.se));\n\t\t}\n\t}\n\tFOR(i,1,n) ans[i]=a[ans[i]];\n\tFOR(i,1,n) write(ans[i]),putchar(' ');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<cstring>\n#include<algorithm>\n#include<stack>\n#define ll long long\nusing namespace std;\nint n,a[2005],tot,du[2005],h[2005],to[4000005],nex[4000005];\nbool bhz[2005][2005],pd[2005];\nint gcd(int a,int b)\n{\n    return b?gcd(b,a%b):a;\n}\nstruct node{\n    int fr,id;\n}st;\nstack<node> q;\nvoid add(int a,int b)\n{\n    du[b]++;\n    tot++;\n    to[tot]=b;\n    nex[tot]=h[a];\n    h[a]=tot;\n}\nvoid dfs(int x)\n{\n    pd[x]=1;\n    for(int i=1;i<=n;i++)\n        if(bhz[x][i]&&!pd[i])\n        {\n            add(x,i);\n            dfs(i);\n        }\n}\nint main()\n{\n    cin>>n;\n    for(int i=1;i<=n;i++) cin>>a[i];\n    sort(a+1,a+n+1);\n    for(int i=1;i<=n-1;i++)\n    for(int j=i+1;j<=n;j++)\n    if(gcd(a[i],a[j])>1) bhz[i][j]=bhz[j][i]=1;\n    for(int i=1;i<=n;i++) if(!pd[i]) dfs(i);\n    for(int i=1;i<=n;i++) \n        if(!du[i])\n        { \n            st.fr=a[i];\n            st.id=i;\n            q.push(st); \n        }\n    for(int i=1;i<=n;i++)\n    {\n        st=q.top();\n        q.pop();\n        int now=st.id;\n        cout<<a[now]<<\" \";\n        for(int k=h[now];k;k=nex[k])\n        {\n            du[to[k]]--;\n            if(du[to[k]]==0)\n            {\n                st.fr=a[to[k]];\n                st.id=to[k];\n                q.push(st);\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\nstruct UnionFind{\n  Int n;\n  vector<Int> r,p;\n  UnionFind(Int x,Int y):n(x+y),r(x+y,1),p(x+y,0){\n    iota(p.begin(),p.end(),0);\n    for(Int i=0;i<x;i++) r[i]=1;\n    for(Int i=0;i<y;i++) r[x+i]=0;\n  }\n  Int find(Int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(Int x,Int y){\n    return find(x)==find(y);\n  }\n  void unite(Int x,Int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    if(r[x]<r[y]) swap(x,y);\n    r[x]+=r[y];\n    p[y]=x;\n  }\n};\n\n\ntemplate<typename T> \nmap<T, Int> factorize(T x){\n  map<T, Int> res;\n  for(Int i=2;i*i<=x;i++){\n    while(x%i==0){\n      x/=i;\n      res[i]++;\n    }\n  }\n  if(x!=1) res[x]++;\n  return res;\n}\n\n//INSERT ABOVE HERE\nInt cop[2020][2020];\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<Int> a(n);\n  for(Int i=0;i<n;i++) cin>>a[i];\n  sort(a.begin(),a.end());\n\n  vector<Int> ans(n),used(n,0),post(n,0);\n\n  memset(cop,0,sizeof(cop));\n  \n  for(Int i=0;i<n;i++)\n    for(Int j=0;j<n;j++)\n      cop[i][j]=__gcd(a[i],a[j])>1;\n\n  Int m=0;\n  map<Int, Int> r;\n\n  vector<vector<Int> > G(n);\n  for(Int i=0;i<n;i++){\n    auto x=factorize(a[i]);\n    for(auto p:x){\n      if(!r.count(p.first)) r[p.first]=m++;\n      G[i].emplace_back(r[p.first]);\n    }\n  }\n  \n  for(Int t=0;t<n;t++){\n    UnionFind uf(n,m);\n    for(Int i=0;i<n;i++)\n      if(!used[i]) for(Int j:G[i]) uf.unite(i,n+j);\n    \n    Int idx=-1;\n    for(Int i=0;i<n;i++){\n      if(used[i]||post[i]) continue;\n      idx=i;\n      break;\n    }\n    \n    used[idx]=1;\n    ans[t]=idx;\n    \n    for(Int i=0;i<n;i++){\n      if(!uf.same(idx,i)) continue;\n      if(cop[idx][i]) post[i]=0;\n      else if(a[idx]<a[i]) post[i]=1;\n    }\n  }\n\n\n  vector<Int> b(n);\n  for(Int i=0;i<n;i++) b[i]=a[ans[i]];\n  \n  vector<vector<Int> > H(n);\n  for(Int i=0;i<n;i++)\n    for(Int j=i+1;j<n;j++)\n      if(__gcd(b[i],b[j])>1) H[i].emplace_back(j);\n\n  vector<Int> indeg(n);\n  for(Int i=0;i<n;i++)\n    for(Int j:H[i]) indeg[j]++;\n  \n  using P = pair<Int, Int>;\n  priority_queue<P> pq;\n  for(Int i=0;i<n;i++)\n    if(!indeg[i]) pq.emplace(b[i],i);\n\n  vector<Int> c;\n  while(!pq.empty()){\n    P p=pq.top();pq.pop();\n    c.emplace_back(p.first);\n    for(Int u:H[p.second]){\n      indeg[u]--;\n      if(!indeg[u]) pq.emplace(b[u],u);\n    }\n  }\n  \n  assert((Int)c.size()==n);\n  for(Int i=0;i<n;i++){\n    if(i) cout<<\" \";\n    cout<<c[i];\n  }\n  cout<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\nint n, c;\nint a[2000];\nint d[2000];\nint f[12000];\nvector <int> v[12000];\nvector <int> w[2000];\n\nint gcd(int a, int b) {\n    if (a % b == 0) {\n        return b;\n    } else {\n        return gcd(b, a % b);\n    }\n}\n\nvoid dfs(int x, int c, vector <int> &z) {\n    int i;\n    \n    f[x] = c;\n    if (x < n) z.push_back(x);\n    \n    for (i = 0; i < v[x].size(); i++) {\n        if (f[v[x][i]] == c || f[v[x][i]] == -1) continue;\n        \n        dfs(v[x][i], c, z);\n    }\n}\n\nvoid calc(vector <int> &z, int x) {\n    int i, j;\n    \n    if (z.size() == 0) return;\n    \n    sort(z.begin(), z.end());\n    \n    for (i = 0; i < z.size(); i++) {\n        if (x == -1 || gcd(x, a[z[i]]) != 1) break;\n    }\n    \n    f[z[i]] = -1;\n    for (j = 0; j < z.size(); j++) {\n        if (i != j) {\n            d[z[j]]++;\n            w[z[i]].push_back(z[j]);\n        }\n    }\n    \n    for (j = 0; j < v[z[i]].size(); j++) {\n        int y = v[z[i]][j];\n        \n        if (f[y] != -1) {\n            vector <int> z2;\n            \n            dfs(y, ++c, z2);\n            \n            calc(z2, a[z[i]]);\n        }\n    }\n}\n\nint main() {\n    int p, i, j;\n    vector <int> ans;\n    map <int, int> mp;\n    priority_queue <int> q;\n    \n    scanf(\"%d\", &n);\n    \n    for (i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n    \n    sort(a, a + n);\n    \n    p = n;\n    \n    for (i = 0; i < n; i++) {\n        int x = a[i];\n        \n        for (j = 2; j * j <= x; j++) {\n            if (x % j == 0) {\n                while (x % j == 0) x /= j;\n                \n                if (!mp.count(j)) mp[j] = p++;\n                \n                v[i].push_back(mp[j]);\n                v[mp[j]].push_back(i);\n            }\n        }\n        \n        if (x > 1) {\n            if (!mp.count(x)) mp[x] = p++;\n            \n            v[i].push_back(mp[x]);\n            v[mp[x]].push_back(i);\n        }\n    }\n    \n    for (i = 0; i < n; i++) {\n        if (f[i] != -1) {\n            vector <int> z;\n            \n            dfs(i, ++c, z);\n            \n            calc(z, -1);\n            \n            q.push(i);\n        }\n    }\n    \n    while (!q.empty()) {\n        int x = q.top();\n        \n        q.pop();\n        \n        ans.push_back(a[x]);\n        \n        for (i = 0; i < w[x].size(); i++) {\n            int y = w[x][i];\n            \n            d[y]--;\n            \n            if (d[y] == 0) q.push(y);\n        }\n    }\n    \n    for (i = 0; i < n; i++) {\n        if (i > 0) putchar(' ');\n        printf(\"%d\", ans[i]);\n    }\n    puts(\"\");\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pb push_back\n#define all(x) x.begin(), x.end()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nconst int N = 2000 + 10;\nconst int MOD = 1000000007;\nconst int LOG = 20;\nconst int INF = 1000000010;\nconst int delta = 11353;\n\nint n;\nvi G[N], a;\nmap<int, int> mp;\nint mark[N];\nint mark2[N], mark3[N];\n\nvoid DFS(int v){\n\tmark[v] = 1;\n\tfor (auto u:G[v]){\n\t\tif ((mark[u] == 0) && (mark3[u] == 0)){\n\t\t\tDFS(u);\n\t\t}\n\t}\n}\nint GCD(int x, int y){\n\tif (x == 0 || y == 0) return (x + y);\n\tif (x == 1 || y == 1) return 1;\n\tif (x < y) swap(x, y);\n\treturn GCD(y, x % y);\n}\n\nint32_t main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++){\n\t\tint x;\n\t\tcin >> x;\n\t\tmp[x] ++;\n\t\ta.pb(x);\n\t}\n\tsort(all(a));\n\ta.resize(unique(all(a)) - a.begin());\n\tfor (int i = 0; i < a.size(); i++) for (int j = 0; j < i; j++) if (GCD(a[i], a[j]) != 1){\n\t\tG[i].pb(j), G[j].pb(i);\n\t}\n\t//cout << GCD(7, 11) << '\\n';\n\tvi ans;\n\tint last = 0;\n\tn = a.size();\n\tfor (int i = 0; i < n; i++){\n\t\tif (!mark[i]){\n\t\t\tDFS(i); \n\t\t\tmark2[i] = 1;\n\t\t\t//cout << i << ' ';\n\t\t}\n\t}\n\t//cout << '\\n';\n\tfor (int i = 0; i < n; i++){\n\t\tmemset(mark, 0, sizeof mark);\n\t\tint mx = 0;\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tif (mark2[j] == 1) mx = j;\n\t\t//\tcout << j << ' ' << mark2[j] << '\\n';\n\t\t}\n\t\tans.pb(a[mx]);\n\t\tsort(all(G[mx]));\n\t\tmark2[mx] = 0;\n\t\tmark3[mx] = 1;\n\t\t//cout << mx << '\\n';\n\t\tfor (auto u:G[mx]){\n\t\t\tif ((mark3[u] == 0) && (mark[u] == 0)){\n\t\t\t\tmark2[u] = 1;\n\t\t\t\t//cout << u << '\\n';\n\t\t\t\tDFS(u);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++) if (!mark3[i]) assert(0);\n\tfor (auto u:ans){\n\t\tfor (int i = 0; i < mp[u]; i++) cout << u << ' ';\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define EB emplace_back\n#define gcd std::__gcd\n\ntypedef std::vector <int> vector;\nconst int N = 2054, M = N * N;\n\nint n, E = 0;\nint a[N], to[M], first[N], next[M], deg[N];\nbool used[N];\nvector G[N];\nstd::priority_queue <int> pq;\n\ninline void addedge(int u, int v) {to[++E] = v, next[E] = first[u], first[u] = E, ++deg[v];}\ninline void dfs(int x) {used[x] = true; for (int y : G[x]) if (!used[y]) addedge(x, y), dfs(y);}\n\nint main() {\n\tint i, j, x, y;\n\tscanf(\"%d\", &n);\n\tfor (i = 1; i <= n; ++i) scanf(\"%d\", a + i);\n\tstd::sort(a + 1, a + (n + 1));\n\tfor (i = 1; i < n; ++i)\n\t\tfor (j = i + 1; j <= n; ++j)\n\t\t\tif (gcd(a[i], a[j]) > 1) G[i].EB(j), G[j].EB(i);\n\tfor (i = 1; i <= n; ++i) if (!used[i]) dfs(i);\n\tfor (i = 1; i <= n; ++i) if (!deg[i]) pq.emplace(i);\n\tfor (i = 1; i <= n; ++i) {\n\t\tprintf(\"%d%c\", a[x = pq.top()], i == n ? 10 : 32), pq.pop();\n\t\tfor (j = first[x]; j; j = next[j])\n\t\t\tif (!--deg[y = to[j]]) pq.emplace(y);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//              +-- -- --++-- +-In the name of ALLAH-+ --++-- -- --+              \\\\\n\n#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define _sz(x) (int)x.size()\n\nusing namespace std ;\nusing ll = long long ;\nusing ld = long double ;\nusing pii = pair <int , int> ;\n\nint const N = 30000 + 20 , M = 30000 + 20 ,  MAX = 1e8 + 20 , S = 1e4 + 20 ;\nint n , a[N] ;\nvector <int> vec ;\n\nvector <int> g[M] ;\nint sz ;\nvector <int> comp[N] ;\n\nvector <int> save[N] ;\n\nint ans[N] , mn[N] , last[M] ;\nbool dead[N] , vis[M] ;\nint mx1 , mx2 , mn_val[N] ;\n\nvector <int> primes ;\nvoid pre () {\n\tbool np[S] ;\n\tmemset(np , 0 , sizeof np) ;\n\tfor (int i = 2 ; i < S ; i ++) {\n\t\tif (np[i]) continue ;\n\t\tprimes.push_back(i) ;\n\t\tfor (int j = 2 * i ; j < S ; j += i) np[j] = 1 ;\n\t}\n}\n\ninline vector<int> get (int x) {\t\t\n\tvector <int> vec ;\n\n\tfor (int j = 0 ; 1ll * primes[j] * primes[j] <= x ; j ++) {\n\t\tif (x % primes[j]) continue ;\n\t\tvec.push_back(primes[j]) ;\n\t\twhile (x % primes[j] == 0) x /= primes[j] ;\n\t}\n\tif (x > 1) vec.push_back(x) ;\n\n\treturn vec ;\n}\n\ninline int get_id (int x) {\n\treturn lower_bound(vec.begin() , vec.end() , x) - vec.begin() ;\n}\n\ninline bool cmp (int x , int y) { return a[x] < a[y] ; }\n\nvoid dfs (int v) {\n\tif (vis[v]) return ;\n\tif (v < n) {\n\t\tif (dead[v]) return ;\n\t\tcomp[sz].push_back(v) ;\n\t}\n\tvis[v] = 1 ;\n\n\tfor (int u : g[v]) dfs(u) ;\n}\n\nint main(){\n\tios::sync_with_stdio(false) , cin.tie(0) , cout.tie(0) ;\n\n\tpre() ;\n\n\tcin >> n ;\n\tfor (int i = 0 ; i < n ; i ++) {\n\t\tcin >> a[i] ;\n\n\t\tsave[i] = get(a[i]) ;\n\t\tfor (int x : save[i]) vec.push_back(x) ;\n\t}\n\n\tsort(vec.begin() , vec.end()) ;\n\tvec.resize( unique(vec.begin() , vec.end()) - vec.begin() ) ;\n\n\tfor (int i = 0 ; i < n ; i ++) {\n\t\tfor (int x : save[i]) {\n\t\t\tint u = i , v = n + get_id(x) ;\n\t\t\tg[u].push_back(v) ;\n\t\t\tg[v].push_back(u) ;\n\t\t}\n\t}\n\n\tmemset(last , -1 , sizeof last) ;\n\tmemset(mn , 63 , sizeof mn) ;\n\n\tfor (int i = 0 ; i < n ; i ++) {\n\t\tmemset(vis , 0 , sizeof vis) ;\n\t\tmx1 = 0 , mx2 = 0 ;\n\t\tsz = 0 ;\n\n\t\tfor (int v = 0 ; v < n ; v ++) {\n\t\t\tif (!dead[v] && !vis[v]) {\n\t\t\t\tcomp[sz].clear() ;\n\t\t\t\tdfs(v) ;\n\n\t\t\t\tsort(comp[sz].begin() , comp[sz].end() , cmp) ;\n\t\t\n\t\t\t\tmx2 = max(mx2 , a[comp[sz][0]]) ;\n\t\t\t\tif (mx2 > mx1) swap(mx1 , mx2) ;\n\n\t\t\t\tfor (int u : comp[sz]) mn_val[u] = a[comp[sz][0]] ;\n\t\t\t\t\n\t\t\t\tsz ++ ;\n\t\t\t}\n\t\t}\n\n\t\tint res = -1 ;\n\t\tfor (int j = 0 ; j < n ; j ++) {\n\t\t\tif (dead[j]) continue ;\n\n\t\t\tint val = (mn_val[j] == mx1 ? mx2 : mx1) ;\n\t\t\tif (val > a[j]) continue ;\n\n\t\t\tint pp = -1 ;\n\t\t\tfor (int x : save[j]) pp = max(pp , last[x]) ;\n\n\t\t\tif (mn[pp + 1] < a[j]) continue ;\n\n\t\t\tif (res == -1 || a[res] > a[j]) res = j ;\n\t\t}\n\n\t\tdead[res] = 1 ;\n\t\tans[i] = a[res] ;\n\t\tfor (int j = i ; j >= 0 ; j --) mn[j] = min(mn[j] , a[res]) ;\n\t\tfor (int x : save[res]) last[x] = i ;\n\t}\n\n\tfor (int i = 0 ; i < n ; i ++) cout << ans[i] << ' ' ; cout << '\\n' ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <vector>\n#include <iostream>\n#include <string.h>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <string>\nusing namespace std;\n\ntypedef double LD;\ntypedef long long LL;\ntypedef pair<int, int> PII;\n#define MP make_pair\n#define PB push_back\n#define FOR(i,a,b) for(int i = (a); i < (b); ++i)\n#define RFOR(i,b,a) for(int i = (b) - 1; i >= (a); --i)\n#define REP(i, t) FOR(i,0,t)\n#define ALL(a) a.begin(), a.end()\n#define SZ(a) (int)((a).size())\n\nconst LL MOD = 1000000007;\nconst int INF = 1e9;\nconst LL LINF = 1LL * INF * INF;\nconst int MAXN = 2007;\nconst LD EPS = 1e-7;\n\nint n, A[MAXN], r = 0, P[MAXN];\nbool used[MAXN];\nvector <int> B[MAXN];\nbool G[MAXN][MAXN];\n\nint gcd(int a, int b)\n{\n\tif (a == 0) return b;\n\treturn gcd(b % a, a);\n}\n\nvoid dfs(int v, int p)\n{\n\tused[v] = true;\n\tif (!B[r].empty() && B[r][SZ(B[r]) - 1] != p)\n\t\t++r;\n\tB[r].push_back(v);\n\tREP(i, n)\n\t{\n\t\tif (G[v][i] && !used[i])\n\t\t\tdfs(i, v);\n\t}\t\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0);\n\t//freopen(\"In.txt\", \"r\", stdin);\n\tcin >> n;\n\tREP(i, n) cin >> A[i];\n\tsort(A, A + n);\n\tREP(i, n)\n\t{\n\t\tREP(j, i)\n\t\tif (gcd(A[i], A[j]) > 1)\n\t\t\tG[i][j] = G[j][i] = true;\n\t}\n\tREP(i, n)\n\t\tif (!used[i])\n\t\t\tdfs(i, -1);\n\tREP(i, n)\n\t{\n\t\tint m = 0, curr;\n\t\tREP(j, r + 1)\n\t\t{\n\t\t\tif (P[j] < SZ(B[j]) && A[B[j][P[j]]] > m)\n\t\t\t{\n\t\t\t\tm = A[B[j][P[j]]];\n\t\t\t\tcurr = j;\n\t\t\t}\n\t\t}\n\t\tcout << m << ' ';\n\t\t++P[curr];\n\t}\n\t//cout << endl; system(\"pause\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define space putchar(' ')\n#define enter putchar('\\n')\n#define eps 1e-10\n#define MAXN 2005\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef unsigned int u32;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;T f = 1;char c = getchar();\n    while(c < '0' || c > '9') {\n    \tif(c == '-') f = -1;\n    \tc = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n    \tres = res * 10 +c - '0';\n    \tc = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {x = -x;putchar('-');}\n    if(x >= 10) {\n\tout(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nstruct node {\n    int to,next;\n}E[MAXN * MAXN * 2];\nint head[MAXN],sumE,A[MAXN],N;\nint dfn[MAXN];\nbool vis[MAXN];\nvector<int> L;\nint gcd(int a,int b) {\n    return b == 0 ? a : gcd(b,a % b);\n}\nvoid add(int u,int v) {\n    E[++sumE].to = v;\n    E[sumE].next = head[u];\n    head[u] = sumE;\n}\nvector<int> Merge(vector<int> a,vector<int> b) {\n    vector<int> c;\n    int pa = 0,pb = 0;\n    while(pa < a.size() && pb < b.size()) {\n        if(a[pa] > b[pb]) c.pb(a[pa++]);\n        else c.pb(b[pb++]);\n    }\n    while(pa < a.size()) c.pb(a[pa++]);\n    while(pb < b.size()) c.pb(b[pb++]);\n    return c;\n}\nvector<int> Calc(int u) {\n    vector<int> son;\n    vis[u] = 1;\n    for(int i = head[u] ; i ; i = E[i].next) {\n        int v = E[i].to;\n        if(!vis[v]) son.pb(v);\n    }\n    sort(son.begin(),son.end());\n    vector<int> tmp;\n    for(auto t : son) dfn[t] = dfn[u] + 1;\n    for(auto t : son) {\n        if(!vis[t] && dfn[t] == dfn[u] + 1) {\n            tmp = Merge(tmp,Calc(t));\n        }\n    }\n    tmp.insert(tmp.begin(),A[u]);\n    return tmp;\n}\n\nvoid Solve() {\n    read(N);\n    for(int i = 1 ; i <= N ; ++i) read(A[i]);\n    for(int i = 1 ; i <= N ; ++i) {\n        for(int j = i + 1 ; j <= N ; ++j) {\n            if(gcd(A[i],A[j]) != 1) {\n                add(i,j);add(j,i);\n            }\n        }\n    }\n    for(int i = 1 ; i <= N ; ++i) {\n        if(dfn[i] == 0) {\n            L = Merge(Calc(i),L);\n        }\n    }\n    for(auto t : L) {\n        out(t);space;\n    }\n    enter;\n}\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int maxn = 2030, maxm = 54010, oo = 123456789;\n\nint n, m, K, a[maxn], q[maxm], rar, mn, rem, id[maxm];\nbool vis[maxn], f[maxn], inq[maxm];\nstd::vector<int> has[maxm], con[maxn], all, ans[maxn];\n\nvoid dfs(int u) {\n\tif(vis[u]) {\n\t\treturn;\n\t}\n\tif(a[u] < mn) {\n\t\tmn = a[u];\n\t\trem = u;\n\t}\n\tvis[u] = 1;\n\tfor (int i: con[u]) {\n\t\tfor (int j: has[i]) {\n\t\t\tdfs(j);\n\t\t}\n\t}\n\treturn;\n}\n\nvoid work(int u) {\n//\tprintf(\"work(%d)\\n\", u);\n\tif(a[u] == 1) {\n\t\tans[K].push_back(1);\n\t\tvis[u] = f[u] = 1;\n\t\treturn;\n\t}\n\tmn = oo;\n\tdfs(u);\n\trar = 0;\n//\tprintf(\"%d\\n\", rem);\n\tfor (int i: con[u]) {\n\t\tq[rar++] = i;\n\t}\n//\tprintf(\"rar = %d\\n\", rar);\n\tfor(;;) {\n\t\tmn = 0;\n\t\tfor (int i = 0; i < rar; ++i) {\n\t\t\tint j = q[i];\n//\t\t\tprintf(\"\\t\\t%d\\n\", j);\n\t\t\twhile(id[j] < (int)(has[j].size()) && f[has[j][id[j]]]) {\n\t\t\t\t++id[j];\n\t\t\t}\n\t\t\tif(id[j] < (int)has[j].size()) {\n\t\t\t\tint k = has[j][id[j]];\n\t\t\t\tif(a[k] > mn) {\n\t\t\t\t\tmn = a[k];\n\t\t\t\t\trem = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(mn == 0) {\n\t\t\treturn;\n\t\t}\n\t\t//printf(\"\\t%d\\n\", mn);\n\t\tans[K].push_back(mn);\n\t\tint i = has[rem][id[rem]++];\n\t\tfor (int j: con[i]) {\n\t\t\tif(!inq[j]) {\n\t\t\t\tq[rar++] = j;\n\t\t\t}\n\t\t}\n\t\tf[i] = 1;\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tscanf(\"%d\", a + i);\n\t\tint t = a[i];\n\t\tfor (int x = 2; x * x <= t; ++x) {\n\t\t\tif(t % x == 0) {\n\t\t\t\tall.push_back(x);\n\t\t\t\twhile(t % x == 0) {\n\t\t\t\t\tt /= x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(t > 1) {\n\t\t\tall.push_back(t);\n\t\t}\n\t}\n\tsort(all.begin(), all.end());\n\tall.resize(unique(all.begin(), all.end()) - all.begin());\n\tm = (int)(all.size());\n\tfor (int j = 0; j < m; ++j) {\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tif(a[i] % all[j] == 0) {\n\t\t\t\thas[j].push_back(i);\n\t\t\t\tcon[i].push_back(j);\n\t\t\t}\n\t\t}\n\t\tsort(has[j].begin(), has[j].end(), [&](int i, int j) {\n\t\t\treturn a[i] < a[j];\n\t\t});\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif(!vis[i]) {\n\t\t\twork(i);\n\t\t\treverse(ans[K].begin(), ans[K].end());\n\t\t\t++K;\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; ++i)  {\n\t\tint mx = 0, rem;\n\t\tfor (int j = 0; j < K; ++j) {\n\t\t\tif((int)(ans[j].size())) {\n\t\t\t\tif(ans[j].back() > mx) {\n\t\t\t\t\tmx = ans[j].back();\n\t\t\t\t\trem = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d%c\", mx, \" \\n\"[i == n]);\n\t\tans[rem].pop_back();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n #define rep(i, a, b) for (int i = a; i <= b; i++)\n #define vep(i, v) for (int i = 0; i < (int)v.size(); i++)\n #define fill(a, x) memset(a, x, sizeof(a))\n #define pb push_back\n #define mp make_pair\n\n typedef vector<int> Vi;\n typedef pair<int, int> Pii;\n\n const int N = 1000 + 5, M = N * N, INF = 0x3f3f3f3f;\n\n int n, es, dfs_cnt;\n int a[N], pre[N], vis[N], fa[N], is_con[N];\n Vi comp[N], all, tmp;\n bool del[N];\n\n inline int gcd(int x, int y) { return (!y) ? x : gcd(y, x % y); }\n\n struct Edge { int from, to, pre; } e[M];\n inline void init_graph() { es = dfs_cnt = 0; fill(vis, 0); fill(pre, 0); fill(is_con, 0); }\n inline void ine(int a, int b) {\n \tint i = ++es;\n \te[i].from = a; e[i].to = b; e[i].pre = pre[a];\n \tpre[a] = i;\n }\n inline void ine2(int a, int b) { ine(a, b); ine(b, a); }\n #define reg(i, x) for (int i = pre[x]; i; i = e[i].pre)\n\n inline int find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }\n inline void do_union(int from, int to) {\n \tint fx = find(from), fy = find(to);\n \tif (fx != fy) fa[fy] = fx;\n }\n\n inline void merge(Vi &v1, Vi v2) {\n \tif (v1.empty()) { v1 = v2; return; }\n \tVi tmp;\n \tint p1 = 0, p2 = 0, s1 = v1.size(), s2 = v2.size();\n // printf(\"s1 = %d  s2 = %d\\n\", s1, s2);\n \twhile (p1 < s1 && p2 < s2) {\n \t\tint x = v1[p1], y = v2[p2];\n // printf(\"p1 = %d  p2 = %d  x = %d  y = %d\\n\", p1, p2, x, y);\n \t\tif (a[x] > a[y]) tmp.pb(x), p1++; else tmp.pb(y), p2++;\n // printf(\"ok\\n\");\n \t}\n\n \tif (p1 < s1) rep(i, p1, s1 - 1) tmp.pb(v1[i]);\n \telse rep(i, p2, s2 - 1) tmp.pb(v2[i]);\n \tv1 = tmp;\n }\n\n inline void dfs(int x, int dfs_id, Vi &list) {\n \tlist.pb(x);\n \tvis[x] = dfs_id;\n // printf(\"x = %d\\n  list.sz = %lu\\n\", x, list.size());\n // vep(i, list) printf(\"list[%d] = %d\\n\", i, list[i]);\n \treg(i, x) {\n \t\tint y = e[i].to;\n \t\tif (del[y] || vis[y] == dfs_id) continue;\n \t\tdfs(y, dfs_id, list);\n \t}\n }\n\n inline Vi solve_comp(int pa, Vi cop) {\n \tVi ret, res, tmp;\n \tret.clear();\n // vep(i, cop) printf(\"cop[%d] = %d\\n\", i, cop[i]); puts(\"\");\n \tif (cop.size() == 1) { del[cop[0]] = true; ret.pb(cop[0]); return ret; }\n \tPii minp = mp(INF, 0);\n \tvep(i, cop) {\n \t\tint x = cop[i];\n // printf(\"x = %d  is_con[x] = %d\\n\", x, is_con[x]);\n \t\tif (is_con[x] != pa) continue;\n \t\tminp = min(minp, mp(a[x], x));\n \t}\n // printf(\"minp.first = %d\\n\\n\", minp.first);\n \tint sel = minp.second;\n \tdel[sel] = true;\n \tret.clear();\n \tret.pb(0);\n \treg(i, sel) {\n \t\tint y = e[i].to;\n // printf(\"sel = %d  y = %d  del = %d\", sel, y, del[y]);\n \t\tif (!del[y]) is_con[y] = sel;\n \t}\n // puts(\"\");\n // printf(\"pa = %d\\n\", pa);\n \tvep(i, cop) {\n \t\tint y = cop[i];\n \t\ttmp.clear();\n // printf(\"y = %d  del = %d\\n\", y, del[y]);\n \t\tif (!del[y]) {\n \t\t\tdfs(y, ++dfs_cnt, tmp);\n // printf(\"tmp.size = %lu\\n\", tmp.size());\n \t\t\tres = solve_comp(sel, tmp);\n // puts(\"86\");\n \t\t\tmerge(ret, res);\n \t\t}\n \t}\n // puts(\"87\");\n\n \tret[0] = sel;\n // printf(\"pa = %d  cop.size = %lu  sel = %d\\n\", pa, cop.size(), sel);\n // vep(i, ret) printf(\"ret[%d] = %d\\n\", i, ret[i]); puts(\"---------\");\n \treturn ret;\n }\n\nint main()\n{\n\n\tscanf(\"%d\", &n);\n\ta[0] = INF;\n\trep(i, 1, n) scanf(\"%d\", &a[i]), fa[i] = i, comp[i].clear();\n\n\tinit_graph();\n\trep(i, 1, n - 1) rep(j, i + 1, n)\n\t\tif (gcd(a[i], a[j]) > 1) ine2(i, j);\n\n\tfor (int i = 1; i < es; i += 2) do_union(e[i].from, e[i].to);\n\trep(i, 1, n) comp[fa[i]].pb(i);\n\t// rep(i, 1, n) printf(\"fa[%d] = %d\\n\", i, fa[i]);\n\n\tfill(del, false);\n\tall.clear();\n\trep(i, 1, n) if (!del[i]) {\n\t\ttmp = solve_comp(0, comp[fa[i]]);\n\n\t\tmerge(all, tmp);\n// printf(\"i = %d\\n\", i);\n// vep(i, all) printf(\"all[%d] = %d\\n\", i, all[i]);\n// puts(\"Line 136\\n\");\n\t}\n\n\trep(i, 0, n - 2) printf(\"%d \", a[all[i]]);\n\tprintf(\"%d\\n\", a[all[n - 1]]);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\",\"inline\",\"-ffast-math\")\n#pragma GCC target(\"avx,sse2,sse3,sse4,mmx\")\n#include <bits/stdc++.h>\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/hash_policy.hpp>\nusing namespace __gnu_pbds;\nusing namespace std;\n\nint n,a[2010];\nvector<int> v[2010];\nbool vis[2010][2010],c[2010][2010],used[2010];\nvector<int> dp[2010];\n\ninline int gcd(int a,int b)\n{\n\tif(b==0) return a;\n\treturn gcd(b,a%b);\n}\n\ninline void dfs2(int u,int x,vector<pair<int,int> >&res)\n{\n\tres.push_back(make_pair(a[x],x));\n\tfor(int i=0;i<v[x].size();i++) if(!used[v[x][i]]&&!vis[u][v[x][i]]&&c[u][v[x][i]]){\n\t\tvis[u][v[x][i]]=1;\n\t\tdfs2(u,v[x][i],res);\n\t}\n}\n\ninline void dfs(int x)\n{\n\tused[x]=1;\n\tvector<vector<int> > w;\n\tvector<pair<int,int> > res;\n\tfor(int i=0;i<v[x].size();i++) if(!used[v[x][i]]&&!vis[x][v[x][i]]){\n\t\tvis[x][v[x][i]]=1;res.clear();dfs2(x,v[x][i],res);\n\t\tsort(res.begin(),res.end());\n\t\tdfs(res[0].second);\n\t\tw.push_back(dp[res[0].second]);\n\t}\n\tsort(w.begin(),w.end());\n\tdp[x].push_back(x);\n\tfor(int i=w.size()-1;i>=0;i--) for(int j=0;j<w[i].size();j++) dp[x].push_back(w[i][j]);\n}\n\nsigned main()\n{\n\tios::sync_with_stdio(false);\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=i+1;j<=n;j++){\n\t\t\tif(gcd(a[i],a[j])>1){\n\t\t\t\tv[i].push_back(j);\n\t\t\t\tv[j].push_back(i);\n\t\t\t\tc[i][j]=1;c[j][i]=1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tv[0].push_back(i);v[i].push_back(0);c[0][i]=1;c[i][0]=1;\n\t}\n\tdfs(0);\n\tfor(int i=1;i<dp[0].size();i++) cout<<a[dp[0][i]]<<\" \";\n\tcout<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// #define DEBUG\n//#define USEPB_DS\n#define USETR1\n#define CPPELEVEN\n#define GPP\n\n/*\n * temp.cpp\n *\n *  Created on: 2012-7-18\n *      Author: BSBandme\n */\n//#pragma comment(linker, \"/STACK:1024000000,1024000000\")\n\n#include <iostream>\n#include <fstream>\n#include <string.h>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <cassert>\n#include <list>\n#include <iomanip>\n#include <math.h>\n#include <deque>\n#include <utility>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cctype>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <functional>\n#include <sstream>\n#include <tuple>\n\nusing namespace std;\n\n#ifndef CPPELEVEN\n#ifdef USETR1\n#include <tr1/unordered_map>\n#include <tr1/unordered_set>\nusing namespace tr1;\n#endif\n#else\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\n#ifdef USEPB_DS\n#include <ext/pb_ds/priority_queue.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\n// binomial_heap_tag, rc_binomial_heap_tag, thin_heap_tag, binary_heap_tag\ntypedef __gnu_pbds::priority_queue<int, greater<int>, pairing_heap_tag> pq_type;\n// splay_tree_tag, ov_tree_tag\ntypedef tree <int, null_type, less <int>, rb_tree_tag, tree_order_statistics_node_update> tree_type;\n#endif\n\n#define mpr make_pair\ntypedef unsigned int ui;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <double, double> pdd;\ntypedef vector <int> vi;\ntypedef vector <ll> vll;\ntypedef vector <double> vd;\ntypedef vector <string> vs;\ntypedef map <string, int> mpsi;\ntypedef map <double, int> mpdi;\ntypedef map <int, int> mpii;\n\nconst double pi = acos(0.0) * 2.0;\nconst long double eps = 1e-10;\nconst int step[8][2] = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}, {-1, 1}, {1, 1}, {1, -1}, {-1, -1}};\n\ntemplate <class T> inline T abs1(T a) {return a < 0 ? -a : a;}\n\n#ifndef CPPELEVEN\ntemplate <class T> inline T max1(T a, T b) { return b < a ? a : b; }\ntemplate <class T> inline T max1(T a, T b, T c) { return max1(max1(a, b), c); }\ntemplate <class T> inline T max1(T a, T b, T c, T d) { return max1(max1(a, b, c), d); }\ntemplate <class T> inline T max1(T a, T b, T c, T d, T e) { return max1(max1(a, b, c, d), e); }\ntemplate <class T> inline T min1(T a, T b) { return a < b ? a : b; }\ntemplate <class T> inline T min1(T a, T b, T c) { return min1(min1(a, b), c); }\ntemplate <class T> inline T min1(T a, T b, T c, T d) { return min1(min1(a, b, c), d); }\ntemplate <class T> inline T min1(T a, T b, T c, T d, T e) { return min1(min1(a, b, c, d), e); }\n#else\ntemplate <typename t, typename t1>\nt min1(t a, t1 b) { return a < b ? a : b; }\ntemplate <typename t, typename... arg>\nt min1(t a, arg... arr) { return min1(a, min1(arr...)); }\ntemplate <typename t, typename t1>\nt max1(t a, t1 b) { return a > b ? a : b; }\ntemplate <typename t, typename... arg>\nt max1(t a, arg... arr) { return max1(a, max1(arr...)); }\n#endif\n\ninline int jud(double a, double b){\n\tif(abs(a) < eps && abs(b) < eps) return 0;\n\telse if(abs1(a - b) / max(abs1(a), abs1(b)) < eps) return 0;\n\tif(a < b) return -1;\n\treturn 1;\n}\ntemplate <typename t> inline int jud(t a, t b){\n\tif(a < b) return -1;\n\tif(a == b) return 0;\n\treturn 1;\n}\n\n// f_lb == 1代表返回相同的一串的左边界，f_small == 1代表返回如果没有寻找的值返回小的数\ntemplate <typename it, typename t1>\ninline int find(t1 val, it a, int na, bool f_small = 1, bool f_lb = 1){\n\tif(na == 0) return 0;\n\tint be = 0, en = na - 1;\n\tif(*a <= *(a + na - 1)){\n\t\tif(f_lb == 0) while(be < en){\n\t\t\tint mid = (be + en + 1) / 2;\n\t\t\tif(jud(*(a + mid), val) != 1) be = mid;\n\t\t\telse en = mid - 1;\n\t\t}else while(be < en){\n\t\t\tint mid = (be + en) / 2;\n\t\t\tif(jud(*(a + mid), val) != -1) en = mid;\n\t\t\telse be = mid + 1;\n\t\t}\n\t\tif(f_small && jud(*(a + be), val) == 1) be--;\n\t\tif(!f_small && jud(*(a + be), val) == -1) be++;\n\t} else {\n\t\tif(f_lb) while(be < en){\n\t\t\tint mid = (be + en + 1) / 2;\n\t\t\tif(jud(*(a + mid), val) != -1) be = mid;\n\t\t\telse en = mid - 1;\n\t\t}else while(be < en){\n\t\t\tint mid = (be + en) / 2;\n\t\t\tif(jud(*(a + mid), val) != 1) en = mid;\n\t\t\telse be = mid + 1;\n\t\t}\n\t\tif(!f_small && jud(*(a + be), val) == -1) be--;\n\t\tif(f_small && jud(*(a + be), val) == 1) be++;\n\t}\n\treturn be;\n}\n\ntemplate <class T> inline T lowb(T num) {return num & (-num); }\n#ifdef GPP\ninline int bitnum(ui nValue) { return __builtin_popcount(nValue); }\ninline int bitnum(int nValue) { return __builtin_popcount(nValue); }\ninline int bitnum(ull nValue) { return __builtin_popcount(nValue) + __builtin_popcount(nValue >> 32); }\ninline int bitnum(ll nValue) { return __builtin_popcount(nValue) + __builtin_popcount(nValue >> 32); }\ninline int bitmaxl(ui a) { if(a == 0) return 0; return 32 - __builtin_clz(a); }\ninline int bitmaxl(int a) { if(a == 0) return 0; return 32 - __builtin_clz(a); }\ninline int bitmaxl(ull a) { int temp = a >> 32; if(temp) return 32 - __builtin_clz(temp) + 32; return bitmaxl(int(a)); }\ninline int bitmaxl(ll a) { int temp = a >> 32; if(temp) return 32 - __builtin_clz(temp) + 32; return bitmaxl(int(a)); }\n#else\n#endif\n\nlong long pow(long long n, long long m, long long mod = 0){\n\tif(m < 0) return 0;\n\tlong long ans = 1;\n\tlong long k = n;\n\twhile(m){\n\t\tif(m & 1) {\n\t\t\tans *= k;\n\t\t\tif(mod) ans %= mod;\n\t\t}\n\t\tk *= k;\n\t\tif(mod) k %= mod;\n\t\tm >>= 1;\n\t}\n\treturn ans;\n}\n\n#define  MOD 1000000007\ntemplate <class t1, class t2>\ninline void add(t1 &a, t2 b, int mod = -1) {\n\tif(mod == -1) mod = MOD;\n\ta += b;\n\twhile(a >= mod) a -= mod;\n\twhile(a < 0) a += mod;\n}\ntemplate <class t>\nvoid output1(t arr) {\n\tfor(int i = 0; i < (int)arr.size(); i++)\n\t\tcerr << arr[i] << ' ';\n\tcerr << endl;\n}\ntemplate <class t>\nvoid output2(t arr) {\n\tfor(int i = 0; i < (int)arr.size(); i++)\n\t\toutput1(arr[i]);\n}\n\n//....................密..........封..........线..........下..........禁..........止..........hack...............................................\n\nconst int maxn = 2010;\nint arr[maxn];\nint ans[maxn], lans;\nbitset <maxn> e[maxn];\nint have[maxn];\nint n;\n\nvoid dfs(int no) {\n\tans[lans++] = arr[no];\n\thave[no] = 1;\n\tvector <pii> temp;\n\tfor(int i = 0; i < n; i++) if(!have[i] && e[no].test(i)) {\n\t\ttemp.push_back(mpr(arr[i], i));\n\t}\n\tsort(temp.begin(), temp.end());\n\tfor(auto it : temp\t) if(!have[it.second]) {\n\t\tdfs(it.second);\n\t}\n}\n\nint main() {\n\n\n//............................不要再忘了检查maxn大小了！！！！BSBandme你个SB！！！！...................................................\n\n\tios_base::sync_with_stdio(0);\n\t#ifdef DEBUG //......................................................................................................\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint __size__ = 256 << 20; // 256MB\n\tchar *__p__ = (char*)malloc(__size__) + __size__;\n\t__asm__(\"movl %0, %%esp\\n\" :: \"r\"(__p__));\n\t#endif //...........................................................................................................\n\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", arr + i);\n\t}\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = i + 1; j < n; j++) if(__gcd(arr[i], arr[j]) != 1) {\n\t\t\te[i].set(j, 1);\n\t\t\te[j].set(i, 1);\n\t\t}\n\n\tfor(int i = 0; i < n; i++) if(!have[i]) {\n\t\tint rlans = lans;\n\t\tdfs(i);\n\t\treverse(ans + rlans, ans + lans);\n\t}\n\tfor(int i = lans - 1; i >= 0; i--)\n\t\tprintf(\"%d \", ans[i]);\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <cstdio>\nusing namespace std;\n#define N 2005\n#define V 40005\n#define Inf (1<<30)\nint lastNotCoprime[N];\nint minOnSuff[N];\nint a[N]; \nint ans[N];\nbool b[N][N];\nint comp[V];\nint C;\nint bestForCol[N];\nmap<int,int> primeId;\nvector<int> g[V];\nint n,m;\nbool inAns[N];\nint ansSz;\nint gcd(int a,int b){\n\tif(b==0){\n\t\treturn a;\n\t}\n\treturn gcd(b,a%b);\n}\nint getId(int p){\n\tif(primeId.count(p)>0){\n\t\treturn primeId[p];\n\t}\n\tprimeId[p]=m;\n\treturn m++;\n}\nvoid dfs(int v){\n\tcomp[v]=C;\n\tint u;\n\tfor(int i=0;i<(int)g[v].size();i++){\n\t\tu=g[v][i];\n\t\tif(comp[u]!=-1){\n\t\t\tcontinue;\n\t\t}\n\t\tif(u<n&&inAns[u]){\n\t\t\tcontinue;\n\t\t}\n\t\tdfs(u);\n\t}\n}\nvoid colors(){\n\tfor(int i=0;i<m;i++){\n\t\tcomp[i]=-1;\n\t}\n\tC=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(inAns[i]){\n\t\t\tcontinue;\n\t\t}\n\t\tif(comp[i]!=-1){\n\t\t\tcontinue;\n\t\t}\n\t\tdfs(i);\n\t\tC++;\n\t}\n}\nint mn(int a,int b){\n\treturn a<b?a:b;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tm=n;\n\tint x,id;\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d\",&a[i]);\n\t\tx=a[i];\n\t\tfor(int j=2;j*j<=x;j++){\n\t\t\tif(x%j!=0){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tid=getId(j);\n\t\t\tg[i].push_back(id);\n\t\t\tg[id].push_back(i);\n\t\t\twhile(x%j==0){\n\t\t\t\tx/=j;\n\t\t\t}\n\t\t}\n\t\tif(x>1){\n\t\t\tid=getId(x);\n\t\t\tg[i].push_back(id);\n\t\t\tg[id].push_back(i);\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=i+1;j<n;j++){\n\t\t\tif(gcd(a[i],a[j])>1){\n\t\t\t\tb[i][j]=b[j][i]=1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tlastNotCoprime[i]=-1;\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tminOnSuff[i]=Inf;\n\t}\n\twhile(ansSz<n){\n\t\tcolors();\n\t\tfor(int i=0;i<C;i++){\n\t\t\tbestForCol[i]=-1;\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(inAns[i]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(minOnSuff[lastNotCoprime[i]+1]<a[i]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(bestForCol[comp[i]]==-1||a[bestForCol[comp[i]]]>a[i]){\n\t\t\t\tbestForCol[comp[i]]=i;\n\t\t\t}\n\t\t}\n\t\tid=-1;\n\t\tfor(int i=0;i<C;i++){\n\t\t\tif(bestForCol[i]==-1){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(id==-1||a[bestForCol[i]]>a[id]){\n\t\t\t\tid=bestForCol[i];\n\t\t\t}\n\t\t}\n\t\tans[ansSz++]=a[id];\n\t\tinAns[id]=1;\n\t\tfor(int i=0;i<ansSz;i++){\n\t\t\tminOnSuff[i]=mn(minOnSuff[i],a[id]);\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(b[id][i]){\n\t\t\t\tlastNotCoprime[i]=ansSz-1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tprintf(\"%d \",ans[i]);\n\t}\n\tputs(\"\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\n#define INF 1e9\n#define LINF 1e18\n#define ld double\n#define ll long long\n#define ull unsigned long long\n\ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1, c = getchar();\n\tfor (;!isdigit(c);c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c);c = getchar()) x = (x<<3) + (x<<1) + (c^48);\n\tx *= f;\n}\n\nconst int N = 2005;\nint n, a[N], g[N][N], used[N], canuse[N], vis[N], que[N];\n\nint bfs(int s) {\n\tint mn = n;\n\tint l = 0, r = 0;\n\tque[r ++] = s;\n\twhile (l < r) {\n\t\tint u = que[l ++];\n\t\tif (canuse[u] && u < mn) mn = u;\n\t\tvis[u >> 6] |= 1 << (u & 63);\n\t\tfor (int i = 0; (i << 6) < n; ++ i) {\n\t\t\tif (g[u][i] & vis[i] != g[u][i]) {\n\t\t\t\tfor (int j = i << 6; j < ((i + 1) << 6); ++ j) {\n\t\t\t\t\tif (g[u][i] & 1 << (j & 63)) {\n\t\t\t\t\t\tif (!(vis[j >> 6] & 1 << (j & 63))) {\n\t\t\t\t\t\t\tque[r ++] = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn mn;\n}\n\nvoid print() {\n\tmemcpy(vis, used, sizeof vis);\n\tint mx = 0;\n\tfor (int i = 0; i < n; ++ i) if (!(vis[i >> 6] & 1 << (i & 63))) mx = max(mx, bfs(i));\n\tprintf(\"%d\", a[mx]);\n\tfor (int i = 0; i < n; ++ i) if (!used[i >> 6] & 1 << (i & 63)) {\n\t\tif (g[mx][i >> 6] & 1 << (i & 63)) canuse[i] = 1;\n\t\telse if (a[i] > a[mx]) canuse[i] = 0;\n\t}\n\tused[mx >> 6] |= 1 << (mx & 63);\n}\n\nint main() {\n\tread(n);\n\tfor (int i = 0; i < n; ++ i) read(a[i]);\n\tsort(a, a + n);\n\tfor (int i = 0; i < n; ++ i) for (int j = 0; j < n; ++ j) if (__gcd(a[i], a[j]) != 1)\n\t\tg[i][j >> 6] |= 1 << (j & 63);\n\tfor (int i = 0; i < n; ++ i) canuse[i] = 1;\n\tfor (int i = 0; i < n; ++ i) print(), putchar(\" \\n\"[i + 1 == n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//author:Um_nik\n//date:2018/11/17\n//title:Rearranging AGC 010 E\n\ninline int gcd(int x,int y)\n{\n\treturn (y==0?x:gcd(y,x%y));\n}\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst int N=2020;\nconst int V=40020;\n\nint n,m;\nint a[N];\nbool b[N][N];\nint ans[N];\nbool inAns[N];\nint ansSz=0;\nint lastNotCoprime[N];\nint minOnSuff[N];\nint comp[V];\nvector<int> g[V];\n\nint C;\nint bestForCol[N];\n\nmap<int,int> primeId;\nint getId(int y)\n{\n\tif(primeId.count(y)>0) return primeId[y];\n\tprimeId[y]=m;\n\treturn m++;\n}\n\nvoid dfs(int v)\n{\n\tcomp[v]=C;\n\tfor(int u:g[v]){\n\t\tif(u<n&&inAns[u]) continue;\n\t\tif(comp[u]!=-1) continue;\n\t\tdfs(u);\n\t}\n\treturn;\n}\n\nvoid color()\n{\n\tfor(int i=0;i<m;i++)\n\t\tcomp[i]=-1;\n\tC=0;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(inAns[i]) continue;\n\t\tif(comp[i]!=-1) continue;\n\t\tdfs(i);\n\t\tC++;\n\t}\n\treturn;\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tm=n;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t\tint x=a[i];\n\t\tfor(int y=2;y*y<=x;y++){\n\t\t\tif(x%y!=0) continue;\n\t\t\tint id=getId(y);\n\t\t\tg[id].push_back(i);\n\t\t\tg[i].push_back(id);\n\t\t\twhile(x%y==0) x/=y;\n\t\t}\n\t\tif(x!=1)\n\t\t{\n\t\t\tint id=getId(x);\n\t\t\tg[id].push_back(i);\n\t\t\tg[i].push_back(id);\n\t\t}\n\t}\n\t\n\tfor(int i=0;i<n;i++) \n\t\tfor(int j=i+1;j<n;j++) \n\t\t\tif(gcd(a[i],a[j])>1) \n\t\t\t\tb[i][j]=b[j][i]=true;\n\t\n\tfor(int i=0;i<n;i++) \n\t\tminOnSuff[i]=1e9+2;\n\tfor(int i=0;i<n;i++) \n\t\tlastNotCoprime[i]=-1;\n\twhile(ansSz!=n)\n\t{\n\t\tcolor();\n\t\tfor(int i=0;i<C;i++)\n\t\t\tbestForCol[i]=-1;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tif(inAns[i]) continue;\n\t\t\tif(minOnSuff[lastNotCoprime[i]+1]<a[i]) continue;\n\t\t\tif(bestForCol[comp[i]]==-1||a[bestForCol[comp[i]]]>a[i])\n\t\t\t\tbestForCol[comp[i]]=i;\n\t\t}\n\t\t\n\t\tint id=-1;\n\t\tfor(int i=0;i<C;i++)\n\t\t{\n\t\t\tif(bestForCol[i]==-1) continue;\n\t\t\tif(id==-1||a[bestForCol[i]]>a[id])\n\t\t\t\tid=bestForCol[i];\n\t\t}\n\t\tif(id==-1) throw;\n\t\tinAns[id]=true;\n\t\tans[ansSz++]=a[id];\n\t\tfor(int i=0;i<ansSz;i++)\n\t\t\tminOnSuff[i]=min(minOnSuff[i],a[id]);\n\t\t\n\t\tfor(int i=0;i<n;i++) if(b[id][i])\tlastNotCoprime[i]=ansSz-1;\n\t}\n\tfor(int i=0;i<ansSz;i++)\n\t\tprintf(\"%d \",ans[i]);\n\tprintf(\"\\n\");\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pb push_back\n#define all(x) x.begin(), x.end()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nconst int N = 2000 + 10;\nconst int MOD = 1000000007;\nconst int LOG = 20;\nconst int INF = 1000000010;\nconst int delta = 11353;\n\nint n;\nvi G[N], a;\nmap<int, int> mp;\nint mark[N];\nint mark2[N], mark3[N];\n\nvoid DFS(int v){\n\tmark[v] = 1;\n\tfor (auto u:G[v]){\n\t\tif ((mark[u] == 0) && (mark3[u] == 0)){\n\t\t\tDFS(u);\n\t\t}\n\t}\n}\nint GCD(int x, int y){\n\tif (x == 0 || y == 0) return (x + y);\n\tif (x == 1 || y == 1) return 1;\n\tif (x < y) swap(x, y);\n\treturn GCD(y, x % y);\n}\n\nint32_t main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++){\n\t\tint x;\n\t\tcin >> x;\n\t\tmp[x] ++;\n\t\ta.pb(x);\n\t}\n\tsort(all(a));\n\ta.resize(unique(all(a)) - a.begin());\n\tfor (int i = 0; i < a.size(); i++) for (int j = 0; j < i; j++) if (__gcd(a[i], a[j]) != 1){\n\t\tG[i].pb(j), G[j].pb(i);\n\t}\n\t//cout << GCD(7, 11) << '\\n';\n\tvi ans;\n\tint last = 0;\n\tn = a.size();\n\tfor (int i = 0; i < n; i++){\n\t\tif (!mark[i]) DFS(i), mark2[i] = 1;\n\t}\n\tfor (int i = 0; i < n; i++){\n\t\tmemset(mark, 0, sizeof mark);\n\t\tint mx = 0;\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tif (mark2[j]) mx = j;\n\t\t//\tcout << j << ' ' << mark2[j] << '\\n';\n\t\t}\n\t\tans.pb(a[mx]);\n\t\tsort(all(G[mx]));\n\t\tmark2[mx] = 0;\n\t\tmark3[mx] = 1;\n\t\t//cout << mx << '\\n';\n\t\tfor (auto u:G[mx]){\n\t\t\tif (mark3[u] == 0 && mark[u] == 0){\n\t\t\t\tmark2[u] = 1;\n\t\t\t//\tcout << u << '\\n';\n\t\t\t\tDFS(u);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < ans.size(); i++){\n\t\tint u = ans[i];\n\t\tfor (int i = 0; i < mp[u]; i++) cout << u << ' ';\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#pragma GCC optimize(\"O3\")\n#define _CRT_SECURE_NO_WARNINGS\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <complex>\n#include <math.h>\n#include <set>\n#include <vector>\n#include <map>\n#include <queue>\n#include <stdio.h>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <ctime>\n\n#include <memory.h>\n#include <assert.h>\n\n#define y0 sdkfaslhagaklsldk\n\n#define y1 aasdfasdfasdf\n#define yn askfhwqriuperikldjk\n#define j1 assdgsdgasghsf\n#define tm sdfjahlfasfh\n#define lr asgasgash\n#define norm asdfasdgasdgsd\n#define have adsgagshdshfhds\n#define ends asdgahhfdsfshdshfd\n#define right asdashgasrhsdf\n\n#define eps 1e-14\n#define M_PI 3.141592653589793\n#define bs 663224321\n#define bsize 64\n\n#define ldouble long double\n\nusing namespace std;\n\nlong long INF = 1e9;\nconst int N = 220031;\n\nint n,ar[N];\n\nvector<int> g[N];\nint used[N];\nvector<int> ans;\n\nint gcd(int a,int b)\n{\n\twhile (a&&b)a>b?a%=b:b%=a;\n\treturn a+b;\n}\n\nvector<int> run_merge(vector<int> a,vector<int> b){\n\n\tvector<int> ret;\n\n\tint ptr1=0;\n\tint ptr2=0;\n\n\twhile (ptr1<a.size()||ptr2<b.size())\n\t{\n\t\tif (ptr1==a.size())\n\t\t{\n\t\t\tret.push_back(b[ptr2]);\n\t\t\t++ptr2;\n\t\t}\n\t\telse if (ptr2==b.size())\n\t\t{\n\t\t\tret.push_back(a[ptr1]);\n\t\t\t++ptr1;\n\t\t}\n\t\telse if (a[ptr1]>b[ptr2])\n\t\t{\n\t\t\tret.push_back(a[ptr1]);\n\t\t\t++ptr1;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tret.push_back(b[ptr2]);\n\t\t\t++ptr2;\n\t\t}\n\t}\n\treturn ret;\n}\n\nvector<int> dfs(int v){\n\tvector<int> here;\n\tused[v]=1;\n\tfor (int i=0;i<g[v].size();i++)\n\t{\n\t\tint to=g[v][i];\n\t\tif (used[to])\n\t\t\tcontinue;\n\t\tvector<int> v2=dfs(to);\n\t\there=run_merge(here,v2);\n\t}\n\there.insert(here.begin(),ar[v]);\n\treturn here;\n}\n\nint main(){\n\t//freopen(\"tree.in\",\"r\",stdin);\n\t//freopen(\"tree.out\",\"w\",stdout);\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t//freopen(\"out.txt\", \"w\", stdout);\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tcin>>n;\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tcin>>ar[i];\n\t}\n\n\tsort(ar+1,ar+n+1);\n\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tfor (int j=1;j<=n;j++)\n\t\t{\n\t\t\tif (gcd(ar[i],ar[j])!=1)\n\t\t\t{\n\t\t\t\tg[i].push_back(j);\n\t\t\t\tg[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tif (used[i])\n\t\t\tcontinue;\n\t\tvector<int> here=dfs(i);\n\t\tans=run_merge(ans,here);\n\t}\n\n\tfor (int i=0;i<ans.size();i++)\n\t{\n\t\tif (i)\n\t\t\tcout<<\" \";\n\t\tcout<<ans[i];\n\t}\n\tcout<<endl;\n\n\tcin.get(); cin.get();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author majk\n */\n\n#ifndef MAJK_LIB\n#define MAJK_LIB\n\n#include <vector>\n#include <stack>\n#include <iostream>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <functional>\n#include <algorithm>\n#include <numeric>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <array>\n#include <bitset>\nusing namespace std;\n\n#define x first\n#define y second\ntypedef std::pair<int,int> pii; typedef long long ll; typedef unsigned long long ull; typedef unsigned int ui; typedef pair<ui,ui> puu;\n\ntemplate <typename T, typename U> std::istream&operator>>(std::istream&i, pair<T,U>&p) {i >> p.x >> p.y; return i;}\ntemplate<typename T>std::istream&operator>>(std::istream&i,vector<T>&t) {for(auto&v:t){i>>v;}return i;}\ntemplate <typename T, typename U> std::ostream&operator<<(std::ostream&o, const pair<T,U>&p) {o << p.x << ' ' << p.y; return o;}\ntemplate<typename T>std::ostream&operator<<(std::ostream&o,const vector<T>&t) {if(t.empty())o<<'\\n';for(size_t i=0;i<t.size();++i){o<<t[i]<<\" \\n\"[i == t.size()-1];}return o;}\ntemplate<typename T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T> using maxheap = priority_queue<T, vector<T>, less<T>>;\nui logceil(ll x) { return x?8*sizeof(ll)-__builtin_clzll(x):0; }\n\nnamespace std { template<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}}; }\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename F> double bshd(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){l=m;}else{h=m;}}return (l+h)/2;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename F> double bsld(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){h=m;}else{l=m;}}return (l+h)/2;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\n\ntemplate<typename T>class vector2:public vector<vector<T>>{public:vector2(){} vector2(size_t a,size_t b,T t=T()):vector<vector<T>>(a,vector<T>(b,t)){}};\ntemplate<typename T>class vector3:public vector<vector2<T>>{public:vector3(){} vector3(size_t a,size_t b,size_t c,T t=T()):vector<vector2<T>>(a,vector2<T>(b,c,t)){}};\ntemplate<typename T>class vector4:public vector<vector3<T>>{public:vector4(){} vector4(size_t a,size_t b,size_t c,size_t d,T t=T()):vector<vector3<T>>(a,vector3<T>(b,c,d,t)){}};\ntemplate<typename T>class vector5:public vector<vector4<T>>{public:vector5(){} vector5(size_t a,size_t b,size_t c,size_t d,size_t e,T t=T()):vector<vector4<T>>(a,vector4<T>(b,c,d,e,t)){}};\n\n\n#endif\n\nclass ERearranging {\npublic:\n    int N, M, P;\n    vector<vector<int>> Multiples;\n    vector<vector<int>> Factors;\n    map<int, int> Compress;\n    map<int, int> C;\n    vector<int> B;\n    vector<int> Stack;\n    vector<bool> Forbidden;\n    vector<int> CompVisit, PrimeVisit;\n    int CompTime;\n\n    vector<int> component(int value) {\n        ++CompTime;\n        CompVisit[value] = CompTime;\n        vector<int> Q{value};\n        for (int q = 0; q < Q.size(); ++q) {\n            int v = Q[q];\n            for (int f: Factors[v]) {\n                if (PrimeVisit[f] == CompTime) continue;\n                PrimeVisit[f] = CompTime;\n                for (int m: Multiples[f]) {\n                    if (Forbidden[m]) continue;\n                    if (CompVisit[m] == CompTime) continue;\n                    CompVisit[m] = CompTime;\n                    Q.push_back(m);\n                }\n            }\n        }\n        sort(Q.begin(),Q.end());\n        return Q;\n    }\n\n    vector<int> solve(const vector<int> &Component) {\n        vector<vector<int>> Others;\n        vector<bool> Used(N, false);\n\n        for (int val: Component) {\n            if (!Used[val]) {\n                auto cc = component(val);\n                for (int c: cc) Used[c] = true;\n\n                int root = -1;\n                for (int c: cc) {\n                    bool ok = Stack.empty() || gcd(B[Stack.back()], B[c]) != 1;\n//true;\n//                    for (int i = (int) Stack.size() - 1; i >= 0; --i) {\n//                        if (gcd(B[Stack[i]], B[c]) != 1) break;\n//                        else if (B[Stack[i]] < B[c]) {\n//                            ok = false;\n//                            break;\n//                        }\n//                    }\n                    if (ok) {\n                        root = c;\n                        break;\n                    }\n                }\n\n                Stack.push_back(root);\n                Forbidden[root] = true;\n                cc.erase(find(cc.begin(),cc.end(),root));\n                vector<int> Z = solve(cc);\n                Stack.pop_back();\n                Forbidden[root] = false;\n\n                Others.push_back({B[root]});\n                for (int z: Z) Others.back().push_back(z);\n            }\n        }\n\n        vector<int> Answer;\n        if (!Others.empty()) {\n            vector<int> Merged = Others[0];\n            for (int i = 1; i < Others.size(); ++i) {\n                vector<int> QQ;\n                int j = 0, k = 0;\n                while (j < Merged.size() || k < Others[i].size()) {\n                    if (j == Merged.size()) { QQ.push_back(Others[i][k++]); }\n                    else if (k == Others[i].size()) { QQ.push_back(Merged[j++]); }\n                    else if (Merged[j] < Others[i][k]) { QQ.push_back(Others[i][k++]); }\n                    else { QQ.push_back(Merged[j++]); }\n                }\n                swap(Merged, QQ);\n            }\n            for (int m: Merged) Answer.push_back(m);\n        }\n        return Answer;\n    }\n\n\n    void solve(istream& cin, ostream& cout) {\n        cin >> N;\n        vector<int> A(N); cin >> A;\n        for (int a: A) C[a]++;\n        for (pii c: C) if (c.x != 1) B.push_back(c.x);\n\n        vector<int> Ans;\n        if (!B.empty()) {\n\n            M = 0;\n            for (int b: B) Compress[b] = M++;\n            Forbidden.assign(M, false);\n\n            CompTime = 0;\n            CompVisit.assign(M, 0);\n\n            vector<int> AllPrimes;\n            for (int b: B) {\n                int x = b;\n                for (int p = 2; p <= 10000; ++p) {\n                    if (x%p == 0) {\n                        AllPrimes.push_back(p);\n                        while (x%p == 0) x /= p;\n                    }\n                }\n                if (x != 1) {\n                    AllPrimes.push_back(x);\n                }\n            }\n            map<int, int> CompressPrimes;\n            P = 0;\n            sort(AllPrimes.begin(),AllPrimes.end());\n            AllPrimes.resize(distance(AllPrimes.begin(),unique(AllPrimes.begin(),AllPrimes.end())));\n            for (int p: AllPrimes) CompressPrimes[p] = P++;\n            Multiples.resize(P);\n            PrimeVisit.assign(P, 0);\n\n            for (int b: B) {\n                int j = Compress[b];\n                int x = b;\n                Factors.push_back({});\n                for (int p = 2; p <= 10000; ++p) {\n                    if (x%p == 0) {\n                        Factors.back().push_back(CompressPrimes[p]);\n                        while (x%p == 0) x /= p;\n                        Multiples[CompressPrimes[p]].push_back(j);\n                    }\n                }\n                if (x != 1) {\n                    Factors.back().push_back(CompressPrimes[x]);\n                    Multiples[CompressPrimes[x]].push_back(j);\n                }\n            }\n\n            vector<int> All;\n            for (int i = 0; i < M; ++i) All.push_back(i);\n            auto res = solve(All);\n            for (int r: res) for (int i = 0; i < C[r]; ++i) Ans.push_back(r);\n        }\n        for (int i = 0; i < C[1]; ++i) Ans.push_back(1);\n        cout << Ans;\n    }\n};\n\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n\tERearranging solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1e5 + 5;\nint n, a[N], vis[N], to[N];\nvector <int> edges[N], g[N];\npriority_queue <pair <int, int> > que;\nint gcd (int a, int b) {\n\tif (!b)\n\t\treturn a;\n\treturn gcd (b, a % b);\n}\nvoid dfs (int x) {\n\tvis[x] = 1;\n\tfor (int j = 0; j < edges[x].size (); j ++)\n\t\tif (!vis[edges[x][j]]) {\n\t\t\tto[edges[x][j]] = 1;\n\t\t\tg[x].push_back (edges[x][j]);\n\t\t\tdfs (edges[x][j]);\n\t\t}\n\treturn ;\n}\nint main () {\n\tscanf (\"%d\", &n);\n\tfor (int i = 1; i <= n; i ++)\n\t\tscanf (\"%d\", &a[i]);\n\tsort (a + 1, a + n + 1);\n\tfor (int i = 1; i <= n; i ++)\n\t\tfor (int j = 1; j <= n; j ++)\n\t\t\tif (i != j && gcd (a[i], a[j]) > 1)\n\t\t\t\tedges[i].push_back (j);\n\tfor (int i = 1; i <= n; i ++)\n\t\tif (!vis[i])\n\t\t\tdfs (i);\n\tfor (int i = 1; i <= n; i ++)\n\t\tif (!to[i])\n\t\t\tque.push (make_pair (a[i], i));\n\twhile (!que.empty()) {\n\t\tint x = que.top().second;\n\t\tque.pop ();\n\t\tprintf (\"%d \", a[x]);\n\t\tfor (int i = 0; i < g[x].size (); i ++)\n\t\t\tque.push (make_pair (a[g[x][i]], g[x][i]));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n//#pragma GCC optimize(\"O3\")\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\nconst int maxN = 2005;\nbool can[maxN][maxN];\nint n;\nint a[maxN];\ntypedef bitset < maxN > bs;\nbs bad[maxN];\nbool used[maxN];\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n//    freopen(\"input.txt\", \"r\", stdin);\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n        cin >> a[i];\n    }\n    sort(a + 1, a + n + 1);\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i == j) continue;\n            bool f = (__gcd(a[i], a[j]) == 1);\n            if (!f) bad[i][j] = true;\n        }\n    }\n    bs cur_ban = 0;\n    vector < int > ans;\n    for (int i = 1; i <= n; i++) {\n        bs all = 0;\n        for (int v = 1; v <= n; v++) {\n            if (!used[v]) {\n                all[v] = 1;\n            }\n        }\n        vector < int > cand;\n        for (int v = 1; v <= n; v++) {\n            if (!used[v] && cur_ban[v] == 0) {\n                cand.emplace_back(v);\n            }\n        }\n        bs good = 0;\n        queue < int > q;\n        int dd = -1;\n        for (int p = 0; p < cand.size(); p++) {\n            if (good[cand[p]]) continue;\n            q.push(cand[p]);\n            while (!q.empty()) {\n                int v = q.front();\n                q.pop();\n                good[v] = true;\n                bs add = (bad[v] & all) & (all ^ good);\n                for (int c = add._Find_first(); c < add.size(); c = add._Find_next(c)) {\n//                    cout << c << \" WUT \" << endl;\n//                    cout << add._Find_next(c) << endl;\n                    good[c] = true;\n                    q.push(c);\n                }\n            }\n            if (good == all) {\n                dd = cand[p];\n                break;\n            }\n        }\n        assert(dd != -1);\n        ans.emplace_back(a[dd]);\n        used[dd] = true;\n        for (int c = 1; c <= n; c++) {\n            if (!used[c]) {\n                if (bad[c][dd]) cur_ban[c] = false;\n                if (c > dd && !bad[c][dd]) cur_ban[c] = true;\n            }\n        }\n    }\n    for (int v : ans) cout << v << \" \";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<map>\nusing namespace std;\nmap<int,int>Map;\nint n, w[2100], cnt, ct;\nvector<int>E[51000], P[2100];\nbool chk[51000], v[51000];\nvoid Ins(int a, int num){\n    int i;\n    for(i=2;i*i<=a;i++){\n        if(a%i==0){\n            if(!Map[i]) Map[i] = ++cnt;\n            P[num].push_back(Map[i]);\n            while(a%i==0)a/=i;\n        }\n    }\n    if(a!=1){\n        if(!Map[a]) Map[a] = ++cnt;\n        P[num].push_back(Map[a]);\n    }\n}\nvoid Make_Edge(int a){\n    int i;\n    for(i=0;i<P[a].size();i++){\n        if(i)E[P[a][0]].push_back(P[a][i]);\n        v[P[a][i]]=false;\n    }\n}\nvoid DFS(int a){\n    int i;\n    ct--;\n    v[a]=true;\n    for(i=0;i<E[a].size();i++){\n        if(!v[E[a][i]])DFS(E[a][i]);\n    }\n}\nint main(){\n    int i, j, k;\n    scanf(\"%d\",&n);\n    for(i=1;i<=n;i++){\n        scanf(\"%d\",&w[i]);\n    }\n    sort(w+1,w+n+1);\n    for(i=1;i<=n;i++){\n        Ins(w[i], i);\n    }\n    for(i=1;i<=n;i++){\n        for(j=1;j<=cnt;j++){\n            E[j].clear();\n            v[j] = true;\n        }\n        for(j=1;j<=n;j++){\n            if(!chk[j]){\n                Make_Edge(j);\n            }\n        }\n        ct=0;\n        for(j=1;j<=cnt;j++)if(!v[j])ct++;\n        for(j=1;j<=n;j++){\n            if(!chk[j]){\n                for(k=0;k<P[j].size();k++){\n                    if(!v[P[j][k]])DFS(P[j][k]);\n                }\n                if(!ct){\n                    printf(\"%d \",w[j]);\n                    chk[j] = true;\n                    break;\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define MAXN 2005\n\nusing namespace std;\n\nint n, a[MAXN], deg[MAXN];\nbool visit[MAXN];\nvector<int> g[MAXN], h[MAXN], ans;\n\nstruct node {\n\tint u, v;\n\tnode(int u = 0, int v = 0):u(u), v(v) {}\n\n\tbool operator < (const node b) const {\n\t\treturn v < b.v;\n\t}\n};\n\nint gcd(int a, int b) {\n\treturn !b ? a : gcd(b, a % b);\n}\n\nint read() {\n\tchar c = getchar();\n\tint x = 0;\n\twhile (!isdigit(c))\n\t\tc = getchar();\n\twhile (isdigit(c)) {\n\t\tx = (x << 3) + (x << 1) + c - '0';\n\t\tc = getchar();\n\t}\n\treturn x;\n}\n\nvoid DFS(int u) {\n\tvisit[u] = true;\n\tfor (int i = 0; i < (int)g[u].size(); ++i) {\n\t\tint v = g[u][i];\n\t\tif (visit[v])\n\t\t\tcontinue;\n\t\th[u].push_back(v);\n\t\t++deg[v];\n\t\tDFS(v);\n\t}\n}\n\nvoid toposort() {\n\tpriority_queue<node> q;\n\tfor (int i = 1; i <= n; ++i)\n\t\tif (!deg[i])\n\t\t\tq.push(node(i, a[i]));\n\twhile (!q.empty()) {\n\t\tint u = q.top().u;\n\t\tans.push_back(a[u]);\n\t\tq.pop();\n\t\tfor (int i = 0; i < (int)h[u].size(); ++i) {\n\t\t\tint v = h[u][i];\n\t\t\tif (--deg[v] == 0)\n\t\t\t\tq.push(node(v, a[v]));\n\t\t}\n\t}\n}\n\nint main() {\n\tn = read();\n\tfor (int i = 1; i <= n; ++i)\n\t\ta[i] = read();\n\tsort(a + 1, a + n + 1);\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = i + 1; j <= n; ++j)\n\t\t\tif (gcd(a[i], a[j]) != 1) {\n\t\t\t\tg[i].push_back(j);\n\t\t\t\tg[j].push_back(i);\n\t\t\t\t// cout << i << \" \" << j << endl;\n\t\t\t\t// ++deg[j];\n\t\t\t}\n\tfor (int i = 1; i <= n; ++i)\n\t\tif (!visit[i])\n\t\t\tDFS(i);\n\ttoposort();\n\t// bool isreverse = false;\n\tfor (int i = 0; i < n; ++i)\n\t\tprintf(\"%d \", ans[i]);\n\t// for (int i = 1; i < n; ++i)\n\t\t// if (!isreverse && gcd(ans[i], ans[i - 1]) == 1 && ans[i] < ans[i - 1])\n\t\t\t// swap(ans[i], ans[i - 1]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <queue>\n#define file(x) freopen(#x\".in\", \"r\", stdin), freopen(#x\".out\", \"w\", stdout)\n\nconst int N(2010);\nstruct edge { int next, to; } e[N];\nint head[N], e_num, n, A[N], vis[N], G[N][N], deg[N];\ninline void add_edge(int from, int to)\n{\n\te[++e_num] = (edge) {head[from], to};\n\thead[from] = e_num;\n}\n\nvoid dfs(int x)\n{\n\tfor (int i = vis[x] = 1; i <= n; i++) if (!vis[i] && G[x][i])\n\t\t++deg[i], add_edge(x, i), dfs(i);\n}\n\nvoid TopSort()\n{\n\tstd::priority_queue<int> Q;\n\tfor (int i = 1; i <= n; i++) if (!deg[i]) Q.push(i);\n\twhile (!Q.empty())\n\t{\n\t\tint x = Q.top(); Q.pop(); printf(\"%d \", A[x]);\n\t\tfor (int i = head[x]; i; i = e[i].next) Q.push(e[i].to);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", A + i);\n\tstd::sort(A + 1, A + n + 1);\n\tfor (int i = 1; i <= n; i++) for (int j = i + 1; j <= n; j++)\n\t\tif (std::__gcd(A[i], A[j]) != 1) G[i][j] = G[j][i] = 1;\n\tfor (int i = 1; i <= n; i++) if (!vis[i]) dfs(i);\n\tTopSort();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <stdio.h>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N = 2048;\n\ninline void Read(int &x) {\n\tx = 0; register char cc = '\\0'; int fff = 1;\n\tfor (; cc < '0' || cc > '9'; cc = getchar())\n\t\tif (cc == '-') fff = -1;\n\tfor (; cc >= '0' && cc <= '9'; cc = getchar())\n\t\tx = (x << 1) + (x << 3) + (cc & 15);\n\tx *= fff;\n}\n\nbool vis[N], E[N][N], G[N][N];\nint n, deg[N], a[N];\n\nint Gcd(int x, int y) {\n\tif (!y) return x;\n\treturn Gcd(y, x % y);\n}\n\nvoid DFS(int x) { /* to decide the direction of the edges */\n\tvis[x] = true;\n\tfor (int i = 1; i <= n; ++i)\n\t\tif ((E[x][i]) && (!vis[i])) {\n\t\t\t++deg[i];\n\t\t\tG[x][i] = true;\n\t\t\tDFS(i);\n\t\t}\n}\n\nint main()\n{\n\tRead(n);\n\tfor (int i = 1; i <= n; ++i)\n\t\tRead(a[i]);\n\tsort(a + 1, a + 1 + n);\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = i + 1; j <= n; ++j)\n\t\t\tif (Gcd(a[i], a[j]) != 1)\n\t\t\t\tE[i][j] = E[j][i] = true;\n\tfor (int i = 1; i <= n; ++i)\n\t\tif (!vis[i]) DFS(i /*1*/);\n\tmemset(vis, false, sizeof(vis));\n//\tfor (int i = 1; i <= n; ++i) {\n//\t\tfor (int j = 1; j <= n; ++j)\n//\t\t\tprintf(\"%d\", E[i][j]);\n//\t\tprintf(\"\\n\");\n//\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tint fps = 0;\n\t\tfor (int j = n; j >= 1; --j) /* from end to begin!!! */ \n\t\t\tif ((!vis[j]) && (!deg[j])) {\n\t\t\t\tfps = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tvis[fps] = true;\n\t\tfor (int j = 1 /* fps + 1 not always from small to big */; j <= n; ++j)\n\t\t\tif (G[fps][j]) --deg[j];\n\t\tprintf(\"%d \", a[fps]);\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<queue>\nusing namespace std;\n#define MAXN 2010\nint gcd(int a,int b)\n{\n\twhile(b)\n\t{\n\t\tint t=a;a=b;b=t%b;\n\t}\n\treturn a;\n}\nint a[MAXN],g[MAXN][MAXN],du[MAXN],vis[MAXN],n;\nvector<int>G[MAXN];\nvoid dfs(int u)\n{\n\tvis[u]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tif(!vis[i]&&g[u][i])\n\t\t{\n\t\t\tG[u].push_back(i);\n\t\t\tdu[i]++;\n\t\t\tdfs(i);\n\t\t}\n}\npriority_queue<int>Q;\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tsort(a+1,a+1+n);\n\tfor(int i=1;i<n;i++)\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\tif(gcd(a[i],a[j])!=1)\n\t\t\t\tg[i][j]=g[j][i]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tif(!vis[i])\n\t\t\tdfs(i);\n\tfor(int i=1;i<=n;i++)\n\t\tif(!du[i])\n\t\t\tQ.push(i);\n\twhile(!Q.empty())\n\t{\n\t\tint u=Q.top();Q.pop();\n\t\tprintf(\"%d \",a[u]);\n\t\tfor(int i=0;i<G[u].size();i++)\n\t\t\tQ.push(G[u][i]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cassert>\n#include<cmath>\n#include<queue>\n#define ll long long\nusing namespace std;\ninline int read(){\n\tint re=0,flag=1;char ch=getchar();\n\twhile(ch>'9'||ch<'0'){\n\t\tif(ch=='-') flag=-1;\n\t\tch=getchar();\n\t}\n\twhile(ch>='0'&&ch<='9') re=(re<<1)+(re<<3)+ch-'0',ch=getchar();\n\treturn re*flag;\n}\nint n,g[2010][2010],a[2010],vis[2010],in[2010];\nint first[2010],cnte;\nstruct edge{\n\tint to,next;\n}e[10010];\ninline void add(int u,int v){\n\te[++cnte]=(edge){v,first[u]};first[u]=cnte;in[v]++;\n}\nint gcd(int x,int y){\n\tif(y==0) return x;\n\treturn gcd(y,x%y);\n}\nvoid dfs(int u){\n//\tcout<<\"dfs \"<<u<<'\\n';\n\tvis[u]=1;int i;\n\tfor(i=1;i<=n;i++){\n//\t\tcout<<\"\ttry \"<<i<<\" from \"<<u<<' '<<g[u][i]<<'\\n';\n\t\tif(!vis[i]&&!g[u][i]) add(u,i),dfs(i);\n\t}\n}\nstruct gaygayquan{\n\tint val,id;\n};\ninline bool operator <(gaygayquan x,gaygayquan b){\n\treturn x.val<b.val;\n}\ngaygayquan mp(int l,int r){\n\treturn (gaygayquan){l,r};\n}\npriority_queue<gaygayquan>q;\nint main(){\n\tmemset(first,-1,sizeof(first));\n\tn=read();int i,j,v;gaygayquan gay;\n\tfor(i=1;i<=n;i++) a[i]=read();\n\tsort(a+1,a+n+1);\n\tfor(i=1;i<=n;i++){\n\t\tfor(j=1;j<i;j++){\n\t\t\tif(gcd(a[i],a[j])==1) g[i][j]=g[j][i]=1;\n//\t\t\tcout<<i<<' '<<j<<' '<<a[i]<<' '<<a[j]<<' '<<g[i][j]<<'\\n';\n\t\t}\n\t}\n\tfor(i=1;i<=n;i++) if(!vis[i]) dfs(i);\n\tfor(i=1;i<=n;i++) if(!in[i]) q.push(mp(a[i],i));\n\twhile(!q.empty()){\n\t\tgay=q.top();q.pop();\n\t\tprintf(\"%d \",gay.val);\n\t\tfor(i=first[gay.id];~i;i=e[i].next){\n\t\t\tv=e[i].to;in[v]--;\n\t\t\tif(in[v]==0) q.push(mp(a[v],v));\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nconst int MAX_N = 2005;\n\nclass Edge {\npublic:\n  int nxt, to;\n} e[MAX_N * MAX_N << 1];\n\nint head[MAX_N], cnt;\nvoid addedge(int u, int v) {\n  e[++cnt] = (Edge){head[u], v}, head[u] = cnt;\n}\n\npriority_queue<int> q;\n\nint N, A[MAX_N], vis[MAX_N], deg[MAX_N];\nvector<int> G[MAX_N];\n\nvoid dfs(int u, int v) {\n  static int tot = 0;\n  vis[u] = ++tot;\n  sort(G[u].begin(), G[u].end());\n\n  for (int i = 0; i < G[u].size(); ++i)\n    if (!vis[G[u][i]]) {\n      deg[G[u][i]]++, addedge(u, G[u][i]);\n      dfs(G[u][i], u);\n    } else if (G[u][i] != v && vis[G[u][i]] < vis[u]) {\n      deg[u]++;\n      addedge(G[u][i], u);\n    }\n}\n\nint main() {\n  scanf(\"%d\", &N);\n  for (int i = 1; i <= N; ++i) scanf(\"%d\", &A[i]);\n  sort(A + 1, A + N + 1);\n  \n  for (int i = 1; i <= N; ++i)\n    for (int j = i + 1; j <= N; ++j)\n      if (__gcd(A[i], A[j]) != 1) {\n\tG[i].push_back(j);\n\tG[j].push_back(i);\n      }\n  \n  for (int i = 1; i <= N; ++i) \n    if (!vis[i])\n      dfs(i, 0);\n\n  for (int i = 1; i <= N; ++i)\n    if (!deg[i]) \n      q.push(i);\n\n  while (!q.empty()) {\n    int u = q.top();\n    q.pop();\n    printf(\"%d \", A[u]);\n    for (int i = head[u]; i; i = e[i].nxt) {\n      deg[e[i].to]--;\n      if (!deg[e[i].to]) q.push(e[i].to);\n    }\n  }\n  puts(\"\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <queue>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\n#define fi first\n#define se second\n#define MP make_pair\n\nint read()\n{\n    int v = 0, f = 1;\n    char c = getchar();\n    while (c < 48 || 57 < c) {if (c == '-') f = -1; c = getchar();}\n    while (48 <= c && c <= 57) v = (v << 3) + v + v + c - 48, c = getchar();\n    return v * f;\n}\n\nconst int N = 2e3 + 10;\nconst int INF = 2e9;\n\nint n, a[N], vis[N];\nVI V[N], E[N];\n\nbool cmp(int i, int j)\n{\n    return a[i] < a[j];\n}\n\nVI merge(const VI &a, const VI &b)\n{\n    int i = 0, j = 0;\n    VI re;\n    while (i < a.size() && j < b.size())\n        if (a[i] > b[j])\n            re.push_back(a[i++]);\n        else\n            re.push_back(b[j++]);\n    while (i < a.size())\n        re.push_back(a[i++]);\n    while (j < b.size())\n        re.push_back(b[j++]);\n    return re;\n}\n\nvoid dfs(int u)\n{\n    vis[u] = 1;\n    V[u].push_back(INF);\n    for (int e = 0; e < E[u].size(); e++)\n    {\n        int v = E[u][e];\n        if (vis[v]) continue;\n        dfs(v);\n        V[u] = merge(V[u], V[v]);\n    }\n    V[u][0] = a[u];\n}\n\nint main()\n{\n    n = read();\n    for (int i = 1; i <= n; i++) a[i] = read();\n    for (int i = 1; i <= n; i++)\n        for (int j = i + 1; j <= n; j++)\n            if (__gcd(a[i], a[j]) > 1)\n            {\n                E[i].push_back(j);\n                E[j].push_back(i);\n            }\n    for (int i = 1; i <= n; i++)\n        E[0].push_back(i);\n    for (int i = 0; i <= n; i++)\n        sort(E[i].begin(), E[i].end(), cmp);\n    dfs(0);\n    for (int i = 1; i <= n; i++)\n        printf(\"%d \", V[0][i]);\n    puts(\"\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pii pair <int, int>\n\nusing namespace std;\n\nconst int N = 2005, M = 4005;\nint n, a[N], edge[N][N], ans[N], root[N], size[N], b[N], ed[N], fa[N];\nbool vis[N];\n\nint gcd(int x, int y) {\n    if (y == 0) return x;\n    return gcd(y, x % y);\n}\n\n\nvoid dfs(int x) {\n    vis[x] = 1;\n    size[x] = 1;\n    for (int xx = 1; xx <= n; xx++) {\n        if (edge[x][xx] && !vis[xx]) {\n            dfs(xx);\n            size[x] += size[xx];\n        }\n    }\n}\n\nvoid solve(int x, int l, int r)\n{\n    priority_queue <pii> q;\n    vis[x] = 1;\n    int now = l;\n    for (int xx = 1; xx <= n; xx++) {\n        if (edge[x][xx] && !vis[xx]) {\n            solve(xx, now + 1, now + size[xx]);\n            q.push(pii(ans[now + 1], now + 1));\n            now += size[xx];\n        }\n    }\n    now = 0;\n    while (!q.empty()) {\n        pii xx = q.top();\n        q.pop();\n        b[++now] = xx.first;\n        if (xx.second < ed[xx.second]) {\n            q.push(pii(ans[xx.second + 1], xx.second + 1));\n        }\n    }\n    ans[l] = a[x];\n    ed[l] = r;\n    for (int i = l + 1; i <= r; i++) {\n        ans[i] = b[i - l];\n        ed[i] = r;\n    }\n}\n\nint main() {\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n        cin >> a[i];\n    }\n    sort(a + 1, a + n + 1);\n    for (int i = 1; i <= n; i++) {\n        for (int j = i + 1; j <= n; j++) {\n            if (gcd(a[i], a[j]) > 1) {\n                edge[i][j] = 1;\n                edge[j][i] = 1;\n            }\n        }\n    }\n    for (int i = 1; i <= n; i++) {\n        if (!vis[i]) {\n            dfs(i);\n            edge[0][i] = 1;\n            edge[i][0] = 1;\n        }\n    }\n    memset(vis, 0, sizeof(vis));\n    solve(0, 0, n);\n    for (int i = 1; i < n; i++) {\n        cout << ans[i] << \" \";\n    }\n    cout << ans[n] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n #define rep(i, a, b) for (int i = a; i <= b; i++)\n #define dep(i, a, b) for (int i = a; i >= b; i--)\n #define vep(i, v) for (int i = 0; i < (int)v.size(); i++)\n #define fill(a, x) memset(a, x, sizeof(a))\n #define pb push_back\n\n typedef vector<int> Vi;\n\n const int N = 2000 + 5, M = N * N, INF = 0x3f3f3f3f;\n\n int n, es;\n int a[N], pre[N];\n Vi all, cur;\n bool vis[N];\n\n struct Edge { int from, to, pre; } e[M];\n inline void init_graph() { es = 0; fill(vis, 0); fill(pre, 0); }\n inline void ine(int a, int b) {\n \tint i = ++es;\n \te[i].from = a; e[i].to = b; e[i].pre = pre[a];\n \tpre[a] = i;\n }\n inline void ine2(int a, int b) { ine(a, b); ine(b, a); }\n #define reg(i, x) for (int i = pre[x]; i; i = e[i].pre)\n\n inline bool cmp(int x, int y) { return x >= y; }\n inline int gcd(int x, int y) { return (!y) ? x : gcd(y, x % y);}\n\n inline void merge(Vi &v1, Vi v2) {\n \tVi tmp;\n \tint p1 = 0, p2 = 0, s1 = v1.size(), s2 = v2.size();\n \ttmp.clear();\n \twhile (p1 < s1 && p2 < s2) {\n \t\tint x = v1[p1], y = v2[p2];\n \t\tif (a[x] > a[y]) tmp.pb(x), p1++; else tmp.pb(y), p2++;\n \t}\n \tif (p1 < s1) rep(i, p1, s1 - 1) tmp.pb(v1[i]);\n \telse rep(i, p2, s2 - 1) tmp.pb(v2[i]);\n \tv1 = tmp;\n }\n\n inline Vi dfs(int x) {\n \tvis[x] = true;\n \tVi ret, cur;\n \tret.clear();\n \tret.pb(0);\n \treg(i, x) {\n \t\tint y = e[i].to;\n \t\tif (!vis[y]) {\n \t\t\tcur = dfs(y);\n \t\t\tmerge(ret, cur);\n \t\t}\n \t}\n \tret[0] = x;\n \t// printf(\"ret[%d] = \", x); vep(i, ret) printf(\"%d \", ret[i]); puts(\"\");\n \treturn ret;\n }\n\nint main()\n{\n\t// freopen(\"atc2306.in\", \"r\", stdin);\n\n\tscanf(\"%d\", &n);\n\ta[0] = INF;\n\trep(i, 1, n) scanf(\"%d\", &a[i]);\n\tsort(a + 1, a + n + 1, cmp);\n\n\tinit_graph();\n\trep(i, 1, n - 1) rep(j, i + 1, n)\n\t\tif (gcd(a[i], a[j]) > 1) ine2(i, j);\n\n\tall.clear();\n\tdep(i, n, 1) if (!vis[i]) {\n\t\tcur = dfs(i);\n\t\tmerge(all, cur);\n\t\t// printf(\"i = %d :: \", i);\n\t\t// vep(i, all) printf(\"%d \", a[all[i]]); puts(\"\");\n\t}\n\t// vep(i, all) printf(\"%d \", a[all[i]]); puts(\"\");\n\trep(i, 0, n - 2) printf(\"%d \", a[all[i]]);\n\tprintf(\"%d\\n\", a[all[n - 1]]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\nusing namespace std;\ntypedef long long int llint;\ntypedef long double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n/*\ncout<<setprecision(20)\ncin.tie(0);\nios::sync_with_stdio(false);\n*/\nconst llint mod=100000000000000007LL;\nconst llint big=2.19e15+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-15;\ntemplate <class T,class U>void mineq(T& a,U b){if(a>b){a=b;}}\ntemplate <class T,class U>void maxeq(T& a,U b){if(a<b){a=b;}}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\nllint LBI(vector<int>&ar,int in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\nllint UBI(vector<int>&ar,int in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\nint main(void){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n,i,j;cin>>n;\n\t//連結かどうか、再帰的にすればよい\n\t//連結判定はn回することになる...\n\t//「互いに素」とは、どういうことか考える\n\t//すると、連結性が速くできる\n\tvector<vector<int>>go;\n\tvector<int>A(n);\n\tfor(i=0;i<n;i++){cin>>A[i];}\n\tSO(A);\n\tmap<int,int>sokai;//素数,それが現れた回数\n\tfor(i=0;i<n;i++){\n\t\tint ter=A[i];\n\t\tfor(j=2;ter>1&&j<10000;j++){\n\t\t\tif(ter%j==0){sokai[j]++;}\n\t\t\twhile(ter%j==0){ter/=j;}\n\t\t}\n\t\tif(ter>1){sokai[ter]++;}\n\t}\n\tvector<int>uso;//use so\n\tfor(auto it:sokai){\n\t\tif(it.sec>=2){uso.pub(it.fir);}\n\t}\n\tint m=n+uso.size();\n\tgo.res(m);\n\tfor(i=0;i<n;i++){\n\t\tint ter=A[i];\n\t\tfor(j=0;j<uso.size();j++){\n\t\t\tif(ter%uso[j]==0){\n\t\t\t\tgo[i].pub(n+j);\n\t\t\t\tgo[n+j].pub(i);\n\t\t\t}\n\t\t}\n\t}\n\t//これで連結条件が同じで辺の数が少ないグラフができた 後は気合\n\tvector<bool>uscan(n,true);\n\tvector<bool>used(n);\n\t//これがtrueじゃないととってはダメ\n\t\n\tfor(i=0;i<n;i++){\n\t\t//「連結内において、最小」でないものに、usedを変える\n\t\tvector<bool>mita(m);\n\t\tfor(j=0;j<n;j++){\n\t\t\tif(used[j]||mita[j]||(!uscan[j])){uscan[j]=false;continue;}\n\t\t\tqueue<int>que;\n\t\t\tque.push(j);\n\t\t\tmita[j]=true;\n\t\t\twhile(que.size()>0){\n\t\t\t\tint ter=que.front();\n\t\t\t\tque.pop();\n\t\t\t\tif(ter<n&&used[ter]){continue;}\n\t\t\t\tfor(auto it:go[ter]){\n\t\t\t\t\tif(mita[it]){continue;}\n\t\t\t\t\tmita[it]=true;\n\t\t\t\t\tque.push(it);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t//uscanの中で最大を選ぶ\n\t\tint sen=n;\n\t\tfor(j=n-1;j>=0;j--){if(uscan[j]){sen=j;break;}}\n\t\tcout<<A[sen]<<\" \";\n\t\tfor(j=0;j<m;j++){mita[j]=false;}\n\t\tqueue<int>que;\n\t\tque.push(sen);\n\t\tmita[sen]=true;\n\t\t\n\t\twhile(que.size()>0){\n\t\t\tint ter=que.front();\n\t\t\tque.pop();\n\t\t\tif(ter<n&&used[ter]){continue;}\n\t\t\tif(ter<n){uscan[ter]=false;}\n\t\t\tfor(auto it:go[ter]){\n\t\t\t\tif(mita[it]){continue;}\n\t\t\t\tmita[it]=true;\n\t\t\t\tque.push(it);\n\t\t\t}\n\t\t}\n\t\tused[sen]=true;\n\t\t\n\t\tfor(j=0;j<n;j++){\n\t\t\tif(used[j]){continue;}\n\t\t\tif(gcd(A[sen],A[j])>1){uscan[j]=true;}\n\t\t}\n\t}\n\tcout<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n//author_name:unused\n//date:2018/11/18\n//title:AGC 010 E Rearranging\n//ÒòÎªÇÓÅ³£¬ËùÒÔÌÓ±ÜÉúÃü£¬ÒÔ²»µÖ¿¹ÔÚ×îºÚ°µµÄ³ÁÂÙÖÐÉú³ö½¾°Á£¬ÒòÎª½¾°Á£¬ËùÒÔ²»Ñ¡ÔñÉú£¬ËùÒÔ¾Ü³â´Ö±ÉµÄÀÖ¹ÛÖ÷Òå¡£\n//Ìì²ÅµÄ±¯¾çµØÓÚ±»Ð¡¶øÊæÊÊµÄÃûÍûËùÊø¸¿¡£\n//It's human to lie. Most of the time we can't even be honest with ourselves.\n\ninline int gcd(int a,int b)\n{\n\treturn b?gcd(b,a%b):a;\n}\n\nint dat[2020];\nvector<int> graph[2020];\nbool visit[2020];\nint n;\n\nvector<int> merge(vector<vector<int>> vvt,int head)\n{\n\tint total=0;\n\tfor(auto v:vvt) total+=v.size();\n\tvector<int> ret(total+(head>=0));\n\tint ptr=0;\n\tif(head>=0) ret[ptr++]=head;\n\tpriority_queue<tuple<int,int,int>> pq;\n\tfor(int i=0;i<vvt.size();i++) \n\t\tpq.emplace(vvt[i][0],i,0);\n\twhile(!pq.empty())\n\t{\n\t\tint val,idx,nxt;\n\t\ttie(val,idx,nxt)=pq.top();\n\t\tpq.pop();\n\t\tret[ptr++]=val;\n\t\t\n\t\tif(nxt+1<vvt[idx].size())\n\t\t\tpq.emplace(vvt[idx][nxt+1],idx,nxt+1);\n\t}\n\treturn ret;\n}\n\nvector<int> process(int u)\n{\n\tvisit[u]=true;\n\tvector<vector<int> > vvt;\n\tfor(int v:graph[u])\tif(!visit[v])\n\t{\n\t\tvvt.emplace_back(process(v));\n\t}\n\treturn merge(move(vvt),u);\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++)\n\t\tscanf(\"%d\",dat+i);\n\tsort(dat,dat+n);\n\tfor(int i=0;i<n;i++)\n\t\tfor(int j=i+1;j<n;j++)\n\t\t\tif(gcd(dat[i],dat[j])>1)\n\t\t\t{\n\t\t\t\tgraph[i].emplace_back(j);\n\t\t\t\tgraph[j].emplace_back(i);\n\t\t\t}\n\tfor(int i=0;i<n;i++) sort(graph[i].begin(),graph[i].end());\n\t\n\tvector<vector<int>> vvt;\n\tfor(int i=0;i<n;i++)\n\t\tif(!visit[i])\n\t\t{\n\t\t\t\n\t\t\tvvt.emplace_back(process(i));\n\t\t}\n\tauto ret=merge(vvt,-1);\n\tfor(int i=0;i<n;i++)\n\t\tprintf(\"%d \",dat[ret[i]]);\n\tprintf(\"\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//MIPT Cryptozoology\n//Room 265\n#define _CRT_SECURE_NO_WARNINGS\n#pragma comment (linker, \"/STACK:128000000\")\n#include <stdio.h>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <queue>\n#include <deque>\n#include <cmath>\n#include <ctime>\n#include <stack>\n#include <bitset>\n#include <set>\n#include <map>\n#include <cassert>\n#include <memory.h>\n#include <sstream>\n\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define all(a) a.begin(), a.end()\n#define itn int\n\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\n\ntypedef long long li;\ntypedef long long i64;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef pair <int, int> pi;\n\nvoid solve(bool);\n\nvoid precalc();\n\nint TESTNUM = 0;\n#define FILENAME \"\"\n\nint main() {\n\tstring s = FILENAME;\n#ifdef YA\n\t//assert(!s.empty());\n\tfreopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\t//cerr<<FILENAME<<endl;\n\t//assert (s != \"change me please\");\n\tclock_t start = clock();\n#else\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\t//freopen(FILENAME \".in\", \"r\", stdin);\n\t//freopen(FILENAME \".out\", \"w\", stdout);\n\tcin.tie(0);\n#endif\n\tcout.sync_with_stdio(0);\n\tcout.precision(10);\n\tcout << fixed;\n\tprecalc();\n\tint t = 1;\n\t//cin >> t;\n\tint test_num = 1;\n\twhile (t--) {\n\t\t//cout << \"Case #\" << test_num++ << \": \";\n\t\t++TESTNUM;\n\t\tsolve(true);\n\t}\n#ifdef YAH\n\twhile (true) {\n\t\tsolve(false);\n\t}\n#endif\n#ifdef YA\n\tcerr << \"\\n\\n\\n\" << (clock() - start) / 1.0 / CLOCKS_PER_SEC << \"\\n\\n\\n\";\n#endif\n\treturn 0;\n}\n\n//#define int li\n\n/*int pr[] = { 97, 2011 };\nint mods[] = { 1000000007, 1000000009 };\n\nconst int C = 100500;\nint powers[2][C];*/\n\n//int MOD = 1000000007;\n\n//int c[5010][5010];\n\ntemplate<typename T>\nT binpow(T q, T w, T mod) {\n\tif (!w)\n\t\treturn 1 % mod;\n\tif (w & 1)\n\t\treturn q * 1LL * binpow(q, w - 1, mod) % mod;\n\treturn binpow(q * 1LL * q % mod, w / 2, mod);\n}\n\nvoid precalc() {\n\n\t/*for (int w = 0; w < 2; ++w) {\n\tpowers[w][0] = 1;\n\tfor (int j = 1; j < C; ++j) {\n\tpowers[w][j] = (powers[w][j - 1] * 1LL * pr[w]) % mods[w];\n\t}\n\t}*/\n\n\t/*for (int i = 0; i < 5010; ++i) {\n\tc[i][i] = c[i][0] = 1;\n\tfor (int j = 1; j < i; ++j) {\n\tc[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % MOD;\n\t}\n\t}*/\n}\n\ntemplate<typename T>\nT gcd(T q, T w) {\n\twhile (w) {\n\t\tq %= w;\n\t\tswap(q, w);\n\t}\n\treturn q;\n}\ntemplate<typename T>\nT lcm(T q, T w) {\n\treturn q / gcd(q, w) * w;\n}\n\ninline int nxt(){\n\tint x;\n\tcin >> x;\n\treturn x;\n}\n\n//#define int li\n\nint n;\nvector<int> dsu;\nvoid init() {\n\tdsu.resize(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tdsu[i] = i;\n\t}\n}\n\nint find_set(int v) {\n\tif (dsu[v] == v) {\n\t\treturn v;\n\t}\n\treturn dsu[v] = find_set(dsu[v]);\n}\n\nvoid merge(int q, int w) {\n\tq = find_set(q);\n\tw = find_set(w);\n\tdsu[q] = w;\n}\n\nvoid solve(bool read) {\n\tcin >> n;\n\tvector<int> a(n);\n\tvector<vector<int>> primes(n);\n\tmap<int, set<int>> poses;\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t\tint cur = a[i];\n\t\tfor (int p = 2; p * p <= cur; ++p) {\n\t\t\tif (cur % p == 0) {\n\t\t\t\tposes[p].insert(i);\n\t\t\t\tprimes[i].push_back(p);\n\t\t\t\twhile (cur % p == 0) {\n\t\t\t\t\tcur /= p;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (cur > 1) {\n\t\t\tposes[cur].insert(i);\n\t\t\tprimes[i].push_back(cur);\n\t\t}\n\t}\n\tvector<int> res;\n\tvector<char> used(n, false);\n\tfor (int i = 0; i < n; ++i) {\n\t\tinit();\n\t\tfor (auto& item : poses) {\n\t\t\tfor (auto it = item.second.begin(); it != item.second.end(); ++it) {\n\t\t\t\tauto nex = it;\n\t\t\t\t++nex;\n\t\t\t\tif (nex == item.second.end()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tmerge(*it, *nex);\n\t\t\t}\n\t\t}\n\n\t\tvector<vector<int>> comps(n);\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (!used[i]) {\n\t\t\t\tcomps[find_set(i)].push_back(i);\n\t\t\t}\n\t\t}\n\n\t\tint cur_take = -1;\n\t\tint cur_id = -1;\n\t\tfor (int i = 0; i < comps.size(); ++i) {\n\t\t\tsort(all(comps[i]), [&a](int q, int w) {\n\t\t\t\treturn a[q] < a[w];\n\t\t\t});\n\t\t\tint best = 2e9;\n\t\t\tint best_id = -1;\n\t\t\tfor (int cur : comps[i]) {\n\t\t\t\tint cand = a[cur];\n\t\t\t\tbool f = true;\n\t\t\t\tfor (int prev = (int)res.size() - 1, its = 0; prev >= 0 && its < 10; --prev, ++its) {\n\t\t\t\t\tif (gcd(res[prev], cand) > 1) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (cand > res[prev]) {\n\t\t\t\t\t\tf = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (f) {\n\t\t\t\t\tif (best > cand) {\n\t\t\t\t\t\tbest = cand;\n\t\t\t\t\t\tbest_id = cur;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!comps[i].empty() && best > cur_take) {\n\t\t\t\tcur_take = best;\n\t\t\t\tcur_id = best_id;\n\t\t\t}\n\t\t}\n\t\t\n\t\tassert(cur_take != -1);\n\t\tres.push_back(a[cur_id]);\n\t\tused[cur_id] = true;\n\t\tfor (int p : primes[cur_id]) {\n\t\t\tposes[p].erase(cur_id);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tcout << res[i] << \" \";\n\t}\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n *                             UM.\n *                            J@B@1                                                                    iO@1\n *                           Y@@@B@BB.                                                              7B@B@B@\n *                          :@B@i,B@B@O                                                          ,Z@B@B@B@Br\n *                          @B@q   i@B@BS                                                      7@B@@@O5vMB@q\n *                         8@@B      LB@B@i                                                  FB@@@BNjYjLE@B@\n *                        ,B@B:        0@@@Z                                               P@B@BM1JJ125JPB@B\n *                        B@BB          :@B@B                                            XB@B@Z2LuU52F2u2@B@.\n *                       :@B@             @@@B:                                        v@B@B8uJj51F1525uUB@B7\n *                       @B@O              0@@B.               ..::ir7vvYUuU777r::.   B@B@OULU2F2F151F11Y@B@S\n *                       B@B,               8B@B  :ruXMB@B@B@B@B@B@B@B@B@B@@@B@B@B@B@B@B@5Jj1211F1F1F2FUJO@BB\n *                      U@B@                 @B@B@B@B@B@@@B@B@B@MMqPS5JuYL7rq@B@OBB@B@B8Yu211F1515251515YGB@@\n *                      @B@u                 v@@@@MSur:.                    LB@MvvjJuU5YU252F1F1F25251F2uX@@@\n *                      @@@.                                                N@BML2U2UUU12F15252525251515Jk@@B\n *                     r@B@                                                 YB@Bju52121252515252F15251F2u5@B@\n *                     PB@B                                                  @@@PYUF151F25151F152F2F1F15jF@@B\n *                     @@BS                                                  N@@@UJ2F25252F251525151F1F1u5@B@\n *                     @@@7                                                   B@B@5Yj12F152F1F1F25252515jFB@B\n *                     B@Bi                                                    M@B@O2Luu52525212F151121UY1@B@7\n *                    O@B@:                                                     v@B@BMSuYJJuuUu2u2uujjYJJXB@B@M\n *                  7B@B@,                                                        1B@@@B@GPF1uujuu21PNMB@B@B@B@@\n *                 qB@B2                                                            i8B@B@B@B@B@@@@@B@B@B@q: @@@B\n *                MB@B:                                                                 7SBB@B@B@B@B@Zu:      @B@B\n *               ZB@B.                                              ,v.                                        @B@L\n *              LB@B,                         Y7                    @B@Bu                                      7@B@\n *   :B@B@@B2:  @@B7                         @B@Z                   r@B@B@BP:                                   B@BE\n *    BB@@@B@B@B@BE                        r@B@B                       7@B@B@B@Ou:                              iB@B\n *         :uM@@B@@2.           :7::::ivk@B@B@0                           :5B@B@B@B@B@B@G.                       @B@i\n *            BB@@@B@@         :@B@B@@@B@B@@1                                 .i5M@B@B@@@5                       M@@2\n *            B@B ,@B1          L0EZZG0F7:                                            .:,                        uB@MrP@M7\n *           2@B@                                                                                               ,O@B@B@B@B\n *           @B@1                                                     :@B@@@r                                :@@@@B@BL:,,\n *           B@Bi                         :2ZS;                      :@B@B@B@r                               L@B@B@BU\n *           @B@.                        @@@B@B@                     vB@B@B@B5                                   @B@i\n *           B@B                        7B@B@B@BM                     OB@B@B@                                   ,B@B\n *           @B@                         @B@B@@@i                       rL7.                                    B@BM\n *           B@B7.:                       NB@@M.                                                               .@B@.\n *  .;JEB@@@B@B@B@B@.                                                                                       .  @B@u\n *@@@B@B@B@B@@@B@18U                                                                                      :B@B@B@BU,\n *7@BOui.    ,@@B                                                                                          SP@B@B@B@B@Or\n *            @@@U                                                                                           B@BJ.YO@B@B@i\n *            r@B@                                                                                         :B@Bk     .k@B@\n *             B@B@                                                                                       LB@@k         2i\n *              B@BM                                      .7jXEGqF7:                                     OB@@L\n *              .B@BM                                   .B@B@B@B@B@B@.                                 :@B@B:\n *               .B@B@                                   @@MYr::ivG@B                                .M@B@G\n *                 B@@@S                                                                           ,MB@B@,\n *                  v@@@BF                                                                      .1B@B@Br\n *                    2@@B@BL                                                                ,FB@@@B8,\n *                      r@B@B@BF,                                                        :YBB@B@B@B\n *                         L@B@B@B@P7,                                           .ivXB@B@B@B@B@M@B@\n *                            ,1B@B@B@B@@@BOP2L7i:,.              ..,:i7LSNB@@B@B@@@B@B@B@Z5v;.LB@@\n *                              @B@OEB@B@@@B@B@B@B@B@B@B@B@@@B@B@B@B@B@@@B@B@B@B@BM0SJ7i::::i:,u@B@\n *                              B@Bu ::i;7vu2XNGOMB@B@BMB@B@B@B@B@B@@@B1UFuj77ii:::::::iir;r;i.YB@B\n *                              @B@L.:i:i:i::::::::::..Y@B@BMYi:i;SB@B@N:.::i:iirir;r;rii::::ivO@B@\n *                              B@@X::,::::iirir;riri:E@B@1         ,@B@Br:;;r;rii:i::::i7JEB@@@@@B\n *                              @@@B@BBq5v7ii:::::::.2@@@i  ..,..     @B@@,,:::::irv2XMB@B@B@B@2@B@:\n *                             .B@BBB@@@B@B@B@BMNP5u7@B@1 .,,:,,  :.   @B@P50MB@B@B@B@B@@@BS:   @@B1\n *                             E@B@   ijGB@B@B@B@B@B@B@Bi .,:,,..@@B@7 B@B@B@B@B@B@BM57.        kB@B\n *                            .@B@:          .,ivu5Nq@B@u  ..,.. SB@B@@@B@PL7i,                 ,@B@\n *                            @@@8                   i@B@:    .     :B@B@@                       B@@2\n *                          i@@@@                     0@B@u          B@@B.                       vB@B\n *                         ,@B@G                       L@B@BOv:.:iFB@B@M                          @B@Bi\n *                          vNi                          S@@B@B@B@B@BM:                            MB@N\n *                                                          758BMqJ,\n *\n *                 .  YO.               vq                            :G       Z:\n *        SqOMBB@B@Br @@r rBE           @B     B@@@@@B@ONX8k    i::::.OB1.:::.u@O.::::i           @B@B@U:@@B@@BPEBu\n *        B@@NB@k.    5@i  uB@E.        BM     1U2uUJvirB@@Z   r@@B@B@@@B@B@B@B@B@@@B@Bi   LB@B@1 BX :@k uLLLvr@BJ:\n *            iB      iBi    7@     .@M8@BGMZZ         @@F            ,B       Pi          v@  Bq @i v@        B@\n *       vuL7r8@S7vJL7N@Z7LLri;72.   F7@Bvvv@@       @BX         @@@B@B@@@@@B@@@B@B@B      7@  @F Bi @q  @B@Bu @B\n *       N@B@G@@@8@BBOMB@G@BMNXG@,     B@   @@      .Bk          .:u;    i@:      Zv       7@  Bk @,;@  ,BY @B B@\n *            r@       @G     5.      ,@v   BZ :::,.r@E .::i,      @B     B@    .@BL       7@  @F B:i@. .@  @M @B\n *            7B: ,vO, @@   iB@:      @B   7@:MB@B@B@@@B@B@BM       @@.    B:  2@q         7@  BS @i 0@  B. @O B@\n *       ,r2EBB@B@B@Bi G@  @BB        B@   @B        @S              :    r@   ..          7B  @F @7  B7 @  @B @B\n *       E@B@UOBr       @B@Bi          L@0PB        .BZ        .@B@B@B@B@B@B@B@B@B@B@B@,   r@  BF @i  @G B@B@B B@\n *            7@,      kB@U    ;r        @@@.       .@Z                GBuL@iBBi           vB@B@q BP:5@7 @u,.  @B\n *            LBi   YB@BrB@    @@       @B:L@Br      BM             .M@B  rB  rB@J         v@. Pi @XZ8r  .     B@\n *        .   G@i B@BM.  ,B@,  @B    iB@B    N, 7r..q@k         ,LB@B8    J@,   i@B@B1r           Br           @@\n *        MB@B@B  ,i       B@B@B,    B@:        @B@B@F         .@BB:      P@i      :OBZ          .@U       B@B@B:\n *                          .ll                                           rB.                     :\n */\n/*\n██████████████████████████████████████████████████████████████████████████████\n██              ██████    ██████      ██      ██  ██    ██████              ██\n██  ██████████  ██  ██      ██      ██████████████  ██████  ██  ██████████  ██\n██  ██      ██  ██    ██  ████      ██    ██████████    ██  ██  ██      ██  ██\n██  ██      ██  ██    ██  ██      ██  ████        ██  ████  ██  ██      ██  ██\n██  ██      ██  ██  ██████  ████  ████████████  ██    ████████  ██      ██  ██\n██  ██████████  ██  ████  ██    ████    ████  ██████  ████  ██  ██████████  ██\n██              ██  ██  ██  ██  ██  ██  ██  ██  ██  ██  ██  ██              ██\n████████████████████  ██  ██    ██████  ██    ████  ████    ██████████████████\n██████  ████          ████        ██    ██    ████  ████████  ██          ████\n████  ██      ██  ██      ██  ██████  ████  ████    ██    ████    ████████  ██\n██      ██      ██    ██    ████      ████        ██████  ██      ██  ██    ██\n██  ██    ████████████  ████  ██  ████            ████  ████████████  ████  ██\n██  ██      ██  ██  ████    ████████                ████████      ██  ██    ██\n██  ██  ██  ██████████  ████    ██  ████  ██    ████  ████        ████  ██  ██\n██    ██  ████  ██████  ██    ******************    ████  ██            ██  ██\n██    ██████  ██  ██████      * Scan this QR   *██████    ██  ██  ██  ████████\n████  ████  ██  ██████      ██* code to join   *██  ████    ██  ████████  ████\n██████      ████████  ██      * in the Three   *██  ████          ████  ██  ██\n████              ████  ████  * Body ETO.      *  ████        ██  ████  ██  ██\n██████  ██    ████████        *  --ETO manager *██  ██                ██    ██\n████    ██  ██  ██    ██████  *    Ye Wenjie   *████  ████  ██  ████  ██  ████\n██  ████  ██████    ████  ██  *ETO(C),1988~2018*      ██  ██  ██  ██    ██████\n██  ██████  ██  ████    ██  ██******************          ██████    ██████  ██\n██  ██  ██    ████    ██        ██  ██        ████████      ████  ██  ██    ██\n████████████    ██    ██████  ██████████  ██  ████  ██████████    ██  ██  ████\n██████████    ██  ████  ██        ██    ██████████  ██    ██      ██  ██    ██\n██    ██  ████    ██  ████  ████      ██████    ██    ██      ██  ██  ████  ██\n██████  ██  ██████  ██            ██████████  ██    ██    ████  ████  ██    ██\n██      ██████  ████  ████  ████      ████    ████  ████            ██████████\n██████████████████      ██  ██  ████  ██    ██  ██    ████  ██████    ██    ██\n██              ██        ████████████  ████  ██  ██  ██    ██  ██      ██  ██\n██  ██████████  ██    ████  ██████  ██  ██████████████      ██████    ██  ████\n██  ██      ██  ████████    ██  ██      ████  ████  ██              ████  ████\n██  ██      ██  ████  ████  ████  ██████  ██████████████  ██████████    ██  ██\n██  ██      ██  ██    ██████  ██  ██  ██████████  ██  ██      ████    ██    ██\n██  ██████████  ██████  ████            ██    ████████  ██  ████    ██████████\n██              ██████    ████  ████████  ██  ████    ██    ██  ████  ████  ██\n██████████████████████████████████████████████████████████████████████████████\n    扫    描    二    维    码    加    入    三    体    E    T    O\n*/\n/*****************\n *   I<3   C++   *\n *  IWANT ANYAC  *\n * ILOVEPROGRAM! *\n *IT'SINTERESTING*\n * ILOVEPROGRAM! *\n *  INCONTESTS   *\n *   GETSCORE    *\n *    ACCODE     *\n *     LETS      *\n *      GO       *\n *Written by:    *\n *    charlieyan *\n *****************/\n#include <assert.h>\n#include <ctype.h>\n#include <errno.h>\n#include <float.h>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <locale>\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <wchar.h>\n#include <wctype.h>\n#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <cerrno>\n#include <clocale>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <limits>\n#include <map>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <istream>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <utility>\n#include <vector>\n#include <cwchar>\n#include <cwctype>\n#include <numeric>\n#include <list>\n#define LL long long\n#define pb push_back\n#define pob pop_back\n#define mp make_pair\n#define FILL(a,v) memset((void*)a,v,sizeof(a))\n#define FILL0(a) FILL(a,0)\n#define FILL1(a) FILL(a,-1)\n#define FILLBIG(a) FILL(a,0x3f)\n#define ALL(a) (a).begin(),(a).end()\n#define Inf ((int)0x3f3f3f3f)\n#define INF ((long long)0x3f3f3f3f3f3f3f3f)\n#define Mod 1000000007\n#define foreach(it,x) for(__typeof(x.begin()) it=x.begin();it!=x.end();it++)\n#define FOR(i,x) for(int i=0;i<x;i++)\n#define RFOR(i,x) for(int i=x-1;i>=0;i--)\n#define FFOR(i,a,b) for(int i=a;i<b;i++)\n#define FRFOR(i,a,b) for(int i=a-1;i>=b;i--)\n#define SZ(a) ((int)(a).size())\n#define FI first\n#define SE second\n#define OVER(...) return printf(__VA_ARGS__),0\n#define fastio ios::sync_with_stdio(0)\n#define filei(f) freopen(f,\"r\",stdin)\n#define fileo(f) freopen(f,\"w\",stdout)\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define MASK(a) (1<<(a))\n#define MASKX(x,a) ((x)<<(a))\n#define BIT(a,b) (((a)>>(b))&1)\n#define cddx(a) priority_queue<a >\n#define cxdd(a) priority_queue<a,vector<a >,greater<a > >\n#define deval(a) {cerr<<#a<<\" = \"<<a<<endl;}\n#define dearr(be,en) {cerr<<#be;cerr<<\" = {\";for(auto i=be;i!=en;i++)cerr<<' '<<*i;cerr<<\" }\\n\";}\n#define reg register\n#define prtime eprintf(\"\\n\\nTime used: %dms\\n\",clock());\n#define PI 3.1415926535897932384626\n#define TODEG(a) (a*180/PI)\n#define y0 ykangjimutigeidiqiuyipianjingtu\n#define y1 yxiaomiexuduhuanrenleiwannianankang\n#define endl '\\n'\n#define left leftxiaomiexudurenrenyouze\n#define hash hashxushibingduyouweilifushiyiqiedewuti\n//抗击母体，给地球一片净土\n//消灭徐毒，还人类万年安康\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef unsigned long long UINT;\ntypedef unsigned int uint;\ntypedef long long INT;\ntypedef long double ldouble;\ntypedef pair<INT,INT> PII;\ntypedef stringstream sst;\ntypedef istringstream iss;\ntypedef vector<int> vint;\ntypedef vector<INT> VINT;\ntypedef vector<pii> vpii;\ntypedef vector<PII> VPII;\ntypedef priority_queue<int> pqi;\ntypedef priority_queue<INT> PQI;\ntypedef priority_queue<pii> pqp;\ntypedef priority_queue<PII> PQP;\ntypedef priority_queue<int,vint,greater<int> > xqi;\ntypedef priority_queue<INT,VINT,greater<INT> > XQI;\ntypedef priority_queue<pii,vpii,greater<pii> > xqp;\ntypedef priority_queue<PII,VPII,greater<PII> > XQP;\nstruct fastIO\n{\n\tinline fastIO operator>>(int& num)\n\t{\n\t\tnum=0;\n\t\tchar c=getchar();\n\t\twhile(c!='-'&&(c<'0'||c>'9'))c=getchar();\n\t\tbool foo=0;\n\t\tif(c=='-')\n\t\t{\n\t\t\tfoo=1;\n\t\t\tc=getchar();\n\t\t}\n\t\twhile(c>='0'&&c<='9')\n\t\t{\n\t\t\tnum=(num<<3)+(num<<1)+c-'0';\n\t\t\tc=getchar();\n\t\t}\n\t\tif(foo)num=-num;\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(INT& num)\n\t{\n\t\tnum=0;\n\t\tchar c=getchar();\n\t\twhile(c!='-'&&(c<'0'||c>'9'))c=getchar();\n\t\tbool foo=0;\n\t\tif(c=='-')\n\t\t{\n\t\t\tfoo=1;\n\t\t\tc=getchar();\n\t\t}\n\t\twhile(c>='0'&&c<='9')\n\t\t{\n\t\t\tnum=(num<<3)+(num<<1)+c-'0';\n\t\t\tc=getchar();\n\t\t}\n\t\tif(foo)num=-num;\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(float& num)\n\t{\n\t\tscanf(\"%f\",&num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(double& num)\n\t{\n\t\tscanf(\"%lf\",&num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(long double& num)\n\t{\n\t\tscanf(\"%Lf\",&num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(char& num)\n\t{\n\t\tnum=getchar();\n\t\twhile(num==' '||num=='\\n')num=getchar();\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(char* num)\n\t{\n\t\tint cnt=0;\n\t\tchar c=getchar();\n\t\twhile(c==' '||c=='\\n')c=getchar();\n\t\twhile(c!=' '&&c!='\\n')\n\t\t{\n\t\t\tnum[cnt++]=c;\n\t\t\tc=getchar();\n\t\t}\n\t\tnum[cnt]=0;\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(string& num)\n\t{\n\t\tcin>>num;\n\t\treturn *this;\n\t}\n\tinline void printInt(const int& num)\n\t{\n\t\tif(num<10)\n\t\t{\n\t\t\tputchar(num+'0');\n\t\t\treturn;\n\t\t}\n\t\tprintInt(num/10);\n\t\tputchar((num%10)+'0');\n\t}\n\tinline void printINT(const INT& num)\n\t{\n\t\tif(num<10)\n\t\t{\n\t\t\tputchar(num+'0');\n\t\t\treturn;\n\t\t}\n\t\tprintINT(num/10);\n\t\tputchar((num%10)+'0');\n\t}\n\tinline fastIO operator<<(const int& num)\n\t{\n\t\tif(num<0)putchar('-'),printInt(-num);\n\t\telse printInt(num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const INT& num)\n\t{\n\t\tif(num<0)putchar('-'),printINT(-num);\n\t\telse printINT(num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const float& num)\n\t{\n\t\tprintf(\"%.10f\",num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const double& num)\n\t{\n\t\tprintf(\"%.16lf\",num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const long double& num)\n\t{\n\t\tprintf(\"%.20Lf\",num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const char& num)\n\t{\n\t\tputchar(num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const char* num)\n\t{\n\t\tfor(int i=0;num[i];i++)\n\t\t\tputchar(num[i]);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const string& num)\n\t{\n\t\tcout<<num;\n\t\treturn *this;\n\t}\n}fio;\n//Coded by Charlieyan\n//版权所有，翻印必究\n\nvector<int> nei[2005];\nbool lgl[2005];\nint a[2005];\nvector<int> L;\n\nvoid dfs(int now,vector<int> &l){\n\tif(lgl[now]){\n\t\treturn;\n\t}\n\tlgl[now]=1;\n\tsort(ALL(nei[now]));\n\tfor(int i:nei[now]){\n\t\tvector<int> t,tmp;\n\t\tdfs(i,t);\n\t\tmerge(ALL(t),ALL(l),back_inserter(tmp),greater<int>());\n\t\tl=tmp;\n\t}\n\tl.insert(l.begin(),a[now]);\n}\n\nint n;\n\nint main(){\n\tfio>>n;\n\tfor(int i=1;i<=n;i++){\n\t\tfio>>a[i];\n\t}\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<i;j++){\n\t\t\tif(__gcd(a[i],a[j])!=1){\n\t\t\t\tnei[i].pb(j);\n\t\t\t\tnei[j].pb(i);\n\t\t\t}\n\t\t}\n\t\tnei[i].pb(0);\n\t\tnei[0].pb(i);\n\t}\n\tdfs(0,L);\n\tfor(int i=1;i<SZ(L);i++){\n\t\tfio<<L[i]<<' ';\n\t}\n\tfio<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Zhupengfei 2018\n// This program / source file is in public domain.\n\n// Solution for problem: Rearranging\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n// Main segment\n\nint a[2001] = {};\nvector<int> g[2001] = {};\nbool v[2001] = {};\nvector<vector<int>> seq;\nvector<int> tmpseq;\nvector<int> topores;\n\nvoid dfs(int x) {\n    v[x] = 1;\n    tmpseq.push_back(x);\n    for (int y : g[x]) {\n        if (!v[y]) {\n            dfs(y);\n        }\n    }\n}\n\nbool topov[2001] = {};\n\nvoid topo() {\n    priority_queue<int, vector<int>, greater<int>> pq;\n\n    pq.push(tmpseq[0]);\n    topov[tmpseq[0]] = 1;\n    while (!pq.empty()) {\n        int u = pq.top();\n        pq.pop();\n        topores.push_back(u);\n        for (int y : g[u]) {\n            if (topov[y])\n                continue;\n            pq.push(y);\n            topov[y] = 1;\n        }\n    }\n}\n\nint gcd(int a, int b) {\n    return b == 0 ? a : gcd(b, a % b);\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int N;\n    cin >> N;\n    for (int i = 1; i <= N; i++) {\n        cin >> a[i];\n    }\n    sort(a + 1, a + N + 1);\n    for (int i = 1; i <= N; i++) {\n        for (int j = i + 1; j <= N; j++) {\n            if (gcd(a[i], a[j]) != 1) {\n                g[i].push_back(j);\n                g[j].push_back(i);\n            }\n        }\n    }\n    for (int i = 1; i <= N; i++) {\n        sort(g[i].begin(), g[i].end());\n    }\n    for (int i = 1; i <= N; i++) {\n        if (!v[i]) {\n            dfs(i);\n            topo();\n            seq.emplace_back(topores);\n            tmpseq.clear();\n            topores.clear();\n        }\n    }\n    sort(seq.begin(), seq.end(), greater<vector<int>>());\n    for (const auto& vec : seq) {\n        for (int x : vec) {\n            cout << a[x] << \" \";\n        }\n    }\n    cout << endl;\n\n#ifdef LOCAL\n    system(\"pause\");\n#endif\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n\n#define rep(i,x,y) for (int i=x;i<=y;i++)\n#define dep(i,y,x) for (int i=y;i>=x;i--)\n#define sz(x) (int)(x.size())\n\nusing namespace std;\n\ntypedef long long LL; \ntypedef unsigned long long uLL;\n\nconst int maxn=2000+7;\n\nstruct Edge{\n int v,next;\n} E[maxn*maxn];\n\nint n,m,Esize,p,q,last[maxn],a[maxn],s[maxn];\nvector<int> v[maxn],temp;\n\nbool vis[maxn];\n\nint gcd(int x,int y) {return (y==0)?(x):(gcd(y,x%y));}\n\nvoid addedge(int x,int y)\n{\n E[++Esize]=(Edge){y,last[x]},last[x]=Esize;\n E[++Esize]=(Edge){x,last[y]},last[y]=Esize;\n // M[x][y]=M[y][x]=1;\n}\n\nvoid merge(int x,int y)\n{\n temp.resize(sz(v[x]));\n rep(i,0,sz(v[x])-1) temp[i]=v[x][i];\n \n p=0,q=0,m=sz(temp)+sz(v[y]),v[x].resize(m);\n rep(i,0,m-1)\n {\n  if (p>=sz(temp)) {v[x][i]=v[y][q],++q;continue;}\n  if (q>=sz(v[y])) {v[x][i]=temp[p],++p;continue;}\n\n  if (temp[p]>v[y][q]) v[x][i]=temp[p],++p; else v[x][i]=v[y][q],++q;\n }\n}\n\nvoid DFS(int k)\n{\n vis[k]=1;\n for (int i=last[k];i;i=E[i].next)\n {\n  int nxt=E[i].v;\n  if (vis[nxt]) continue;\n\n  DFS(nxt);\n  merge(k,nxt);v[nxt].clear();\n }\n \n m=sz(v[k]);\n rep(i,0,m-1) s[i+1]=v[k][i];\n v[k].resize(m+1);\n v[k][0]=a[k];\n rep(i,1,m) v[k][i]=s[i];\n}\n\nint main()\n{\n scanf(\"%d\",&n);\n rep(i,1,n) scanf(\"%d\",&a[i]);\n \n sort(a+1,a+n+1);\n rep(i,1,n/2) swap(a[i],a[n-i+1]);\n \n rep(i,1,n-1)\n  rep(j,i+1,n)\n   if (gcd(a[i],a[j])>1) addedge(i,j);\n \n memset(vis,0,sizeof(vis));\n dep(i,n,1)\n  if (!vis[i])\n  {\n   DFS(i);\n   merge(0,i);\n  }\n \n rep(i,1,n-1) printf(\"%d \",v[0][i-1]);\n printf(\"%d\\n\",v[0][n-1]);\n\n // system(\"pause\");\n return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\nstruct UnionFind{\n  Int n;\n  vector<Int> r,p;\n  UnionFind(Int x,Int y):n(x+y),r(x+y,1),p(x+y,0){\n    iota(p.begin(),p.end(),0);\n    for(Int i=0;i<x;i++) r[i]=1;\n    for(Int i=0;i<y;i++) r[x+i]=0;\n  }\n  Int find(Int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(Int x,Int y){\n    return find(x)==find(y);\n  }\n  void unite(Int x,Int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    if(r[x]<r[y]) swap(x,y);\n    r[x]+=r[y];\n    p[y]=x;\n  }\n};\n\n\ntemplate<typename T> \nmap<T, Int> factorize(T x){\n  map<T, Int> res;\n  for(Int i=2;i*i<=x;i++){\n    while(x%i==0){\n      x/=i;\n      res[i]++;\n    }\n  }\n  if(x!=1) res[x]++;\n  return res;\n}\n\n//INSERT ABOVE HERE\nInt cop[2020][2020];\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<Int> a(n);\n  for(Int i=0;i<n;i++) cin>>a[i];\n  sort(a.begin(),a.end());\n\n  vector<Int> ans(n),used(n,0),post(n,0);\n\n  memset(cop,0,sizeof(cop));\n  \n  for(Int i=0;i<n;i++)\n    for(Int j=0;j<n;j++)\n      cop[i][j]=__gcd(a[i],a[j])>1;\n\n  Int m=0;\n  map<Int, Int> r;\n\n  vector<vector<Int> > G(n);\n  for(Int i=0;i<n;i++){\n    auto x=factorize(a[i]);\n    for(auto p:x){\n      if(!r.count(p.first)) r[p.first]=m++;\n      G[i].emplace_back(r[p.first]);\n    }\n  }\n  \n  for(Int t=0;t<n;t++){\n    UnionFind uf(n,m);\n    for(Int i=0;i<n;i++)\n      if(!used[i]) for(Int j:G[i]) uf.unite(i,n+j);\n    \n    Int idx=-1,sum=t;\n    set<Int> tmp;\n    for(Int i=0;i<n;i++){\n      if(used[i]) continue;\n      Int k=uf.find(i);\n      if(!tmp.count(k)){\n\ttmp.emplace(k);\n\tsum+=uf.r[k];\n      }\n      if(post[i]) continue;\n      if(sum==n){\n\tidx=i;\n\tbreak;\n      }\n    }\n    while(idx<0);\n    used[idx]=1;\n    ans[t]=idx;\n    \n    for(Int i=0;i<n;i++)\n      if(cop[idx][i]) post[i]=0;\n      else if(a[idx]<a[i]) post[i]=1;\n  }\n  for(Int i=0;i<n;i++){\n    if(i) cout<<\" \";\n    cout<<a[ans[i]];\n  }\n  cout<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Heaplax\n//别让自己后悔\n#include<bits/stdc++.h>\n#define N 2005\n#define LL long long\n#define LOG(x) cerr<<#x<<\" = \"<<x<<endl\n#define add_edge(u,v) nxt[++cnt]=head[u],head[u]=cnt,to[cnt]=v\n#define open(x) freopen(#x\".in\",\"r\",stdin),freopen(#x\".out\",\"w\",stdout)\nchar ch;bool fs;void re(int& x)\n{\n\twhile(ch=getchar(),ch<33);\n\tif(ch=='-')fs=1,x=0;else fs=0,x=ch-48;\n\twhile(ch=getchar(),ch>33)x=x*10+ch-48;\n\tif(fs)x=-x;\n}\nusing namespace std;\nint n,a[N];\nint cnt,head[N],nxt[N*N],to[N*N];\nbool vis[N];\nvoid dfs(int u)\n{\n\tvis[u]=1;\n\tfor(int i=head[u],v;i;i=nxt[i])\n\t\tif(!vis[v=to[i]])\n\t\t\tdfs(v);\n}\nvector<int> solve(int u)\n{\n\tvis[u]=1;\n\tvector<int> son;\n\tfor(int i=head[u],v;i;i=nxt[i])\n\t\tif(!vis[v=to[i]])\n\t\t\tson.push_back(v);\n\tsort(son.begin(),son.end());\n\tvector<vector<int>> que;\n\tfor(int v:son)if(!vis[v])\n\t\tque.push_back(solve(v));\n\tfor(vector<int>& i:que)\n\t\treverse(i.begin(),i.end());\n\tvector<int> res;\n\tres.push_back(a[u]);\n\twhile(1)\n\t{\n\t\tint mx=0;\n\t\tvector<int> *num;\n\t\tfor(vector<int> &i:que)\n\t\t\tif(!i.empty() && *i.rbegin()>mx)\n\t\t\t\tmx=*i.rbegin(),num=&i;\n\t\tif(!mx)break;\n\t\t(*num).pop_back();\n\t\tres.push_back(mx);\n\t}\n\treturn res;\n}\nint main()\n{\n\tre(n);++n;\n\tfor(int i=2;i<=n;++i)re(a[i]);\n\tsort(a+2,a+n+1);\n\tfor(int i=2;i<=n;++i)\n\t\tfor(int j=i+1;j<=n;++j)\n\t\t\tif(__gcd(a[i],a[j]) != 1)\n\t\t\t\tadd_edge(i,j),add_edge(j,i);\n\tfor(int i=2;i<=n;++i)\n\t\tif(!vis[i])\n\t\t{\n\t\t\tadd_edge(1,i);\n\t\t\tdfs(i);\n\t\t}\n\tmemset(vis,0,sizeof vis);\n\tvector<int> ans=solve(1);\n\tfor(int i=1;i<n;++i)\n\t\tprintf(\"%d \",ans[i]);\n\tputs(\"\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<iomanip>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <functional>\n#include<complex>\nusing namespace std;\n\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define repn(i,x) for(ll i=1;i<=x;i++)\n\ntypedef long long ll;\nconst ll INF = 1e17;\nconst ll MOD = 1000000007;\nconst ll MAX = 4000001;\nconst long double eps = 1E-14;\n\nll max(ll a, ll b) {\n\tif (a > b) { return a; }\n\treturn b;\n}\n\nll min(ll a, ll b) {\n\tif (a > b) { return b; }\n\treturn a;\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) { return a; }\n\tif (a < b) { return gcd(b, a); }\n\treturn gcd(b, a % b);\n}\n\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b) * b;\n}\n\nstruct edge {\n\tll ind;\n\tll fr;\n\tll to;\n\tll d;\n};\n\nclass mint {\n\tlong long x;\npublic:\n\tmint(long long x = 0) : x((x% MOD + MOD) % MOD) {}\n\tmint operator-() const {\n\t\treturn mint(-x);\n\t}\n\tmint& operator+=(const mint& a) {\n\t\tif ((x += a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator-=(const mint& a) {\n\t\tif ((x += MOD - a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator*=(const  mint& a) {\n\t\t(x *= a.x) %= MOD;\n\t\treturn *this;\n\t}\n\tmint operator+(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res += a;\n\t}\n\tmint operator-(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res -= a;\n\t}\n\tmint operator*(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res *= a;\n\t}\n\n\tmint pow(ll t) const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\n\t// for prime MOD\n\tmint inv() const {\n\t\treturn pow(MOD - 2);\n\t}\n\tmint& operator/=(const mint& a) {\n\t\treturn (*this) *= a.inv();\n\t}\n\tmint operator/(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res /= a;\n\t}\n\n\tfriend ostream& operator<<(ostream& os, const mint& m) {\n\t\tos << m.x;\n\t\treturn os;\n\t}\n};\n\nmint pw(mint a, ll b) {\n\tif (b == 0) { return 1; }\n\tmint ret = pw(a, b >> 1);\n\tret *= ret;\n\tif (b & 1) { ret *= a; }\n\treturn ret;\n}\n\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef vector<vector<vector<ll>>> vvvll;\n\ntypedef vector<mint> vmint;\ntypedef vector<vector<mint>> vvmint;\ntypedef vector<vector<vector<mint>>> vvvmint;\n\n/////////////////////////////////////\nvvll g;\nvll con;\n\nvoid dfs(ll v, ll x) {\n\tcon[v] = x;\n\tfor (ll w : g[v]) {\n\t\tif (con[w] != 0) { continue; }\n\t\tdfs(w, x);\n\t}\n}\n\nint main() {\n\tll N;\n\tcin >> N;\n\tvll A(N + 1);\n\trepn(i, N)cin >> A[i];\n\n\tsort(++A.begin(), A.end());\n\n\tg.resize(N + 1);\n\trepn(i, N)for (ll j = i+1; j <= N; j++) {\n\t\tif (gcd(A[i], A[j]) > 1) { g[i].push_back(j); g[j].push_back(i); }\n\t}\n\n\tcon.assign(N + 1, 0);\n\tvll mn(1, 0);\n\n\tll M = 0;\n\trepn(v, N) {\n\t\tif (con[v] != 0) { continue; }\n\t\tM++;\n\t\tdfs(v, M);\n\t\tmn.push_back(v);\n\t}\n\n\tvector<set<ll>> st(M + 1);\n\trepn(i, M)st[i].insert(mn[i]);\n\n\t//repn(v, M)cout << mn[v] << endl;\n\n\tvll lis(N + 1, 0);\n\n\trepn(i, N) {\n\t\tll ans = 0;\n\t\tll id = 0;\n\t\trepn(j, M) {\n\t\t\tif (st[j].empty()) { continue; }\n\t\t\tll x = *st[j].begin();\n\t\t\tif (x > ans) { ans = x; id = j; }\n\t\t}\n\t\t\n\t\tcout << A[ans] << \" \";\n\t\tlis[ans] = i;\n\n\t\tst[id].erase(ans);\n\t\tfor (ll v : g[ans]) { if (lis[v] == 0) { st[id].insert(v); } }\n\t}\n\tcout << endl;\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <stdio.h>\n#include <stdlib.h>\n#include <vector>\n#include <map>\n#include <self/operator>\n#include <queue>\n#include <set>\n#include <string>\n#include <string.h>\n#include <stack>\n#include <assert.h>\n#include <bitset>\n#define Endl endl\n#define mp make_pair\n#define ll long long \n#define ull unsigned long long\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define over(A) {cout<<A<<endl;exit(0);}\n#define all(A) A.begin(),A.end()\n#define ceil(a,b) ((a-1)/b+1)\n#define quickcin ios_base::sync_with_stdio(false);\nconst int mod=1e9+7;\nconst int inf=1039074182;\nconst ll llinf=1LL*inf*inf;\nusing namespace std;\ntemplate <typename T1,typename T2> inline void chmin(T1 &x,T2 b) {if(b<x) x=b;}\ntemplate <typename T1,typename T2> inline void chmax(T1 &x,T2 b) {if(b>x) x=b;}\ntemplate <typename T1,typename T2> inline void chadd(T1 &x,T2 b) {x+=b;if(x>=mod) x-=mod;}\ntemplate <typename T1,typename T2> inline void chmul(T1 &x,T2 b) {x=1LL*x*b%mod;}\ntemplate <typename T1,typename T2> inline void chmod(T1 &x,T2 b) {x%=b,x+=b;if(x>=b) x-=b;}\nint n;\nint a[2005];\nvector <int> vec[2000+2000*8+5];\nint visit[2005];\nint colors;\nmap <int,int> toid;\nbool isprime[10005];\nvector <int> prime;\nbool block[2000+2000*8+5];\nbool e[2005][2005];\nint tot;\n\ninline vector <int> merge(vector <int> a,vector <int> b)\n{\n\tvector <int> res;\n\tint la=(int)a.size();\n\tint lb=(int)b.size();\n\tres.push_back(a[0]);\n\tfor(int i=1,j=0;;)\n\t{\n\t\tif(i==la && j==lb) break;\n\t\tif(i==la) res.push_back(b[j++]);\n\t\telse if(j==lb) res.push_back(a[i++]);\n\t\telse if(a[i]>b[j]) res.push_back(a[i++]);\n\t\telse res.push_back(b[j++]);\n\t}\n\treturn res;\n}\n\npii dfs(int x,int col,int head)\n{\n//\tcout<<x<<' '<<col<<' '<<head<<endl;\n\tvisit[x]=col;\n\tpii res={inf,-1};\n\tif(x<n && (head==-1 || e[head][x])) res={a[x],x};\n\tfor(auto u:vec[x])\n\t{\n\t\tif(block[u]) continue;\n\t\tif(visit[u]>=col) continue;\n\t\tchmin(res,dfs(u,col,head));\n\t}\n\treturn res;\n}\n\nvector <int> solve(int x)\n{\n\tassert(x<n);\n\tblock[x]=true;\n\tcolors++;\n\tvisit[x]=colors;\n\tvector <int> res;\n\tres.push_back(a[x]);\n\tvector <int> adj;\n\tfor(auto &u:vec[x])\n\t{\n\t\tadj.push_back(u);\n\t}\n\tfor(auto &u:adj)\n\t{\n\t\tif(visit[u]>=colors) continue;\n\t\tif(block[u]) continue;\n\t\tint minx=dfs(u,colors,x).second;\n\t\tif(minx==-1) continue;\n\t\tres=merge(res,solve(minx));\n\t}\n\tcolors--;\n\treturn res;\n}\n\nvoid init()\n{\n\tmemset(isprime,true,sizeof(isprime));\n\tisprime[0]=isprime[1]=false;\n\tfor(int i=2;i<=10000;i++)\n\t{\n\t\tif(isprime[i]) prime.push_back(i);\n\t\tfor(auto &j:prime)\n\t\t{\n\t\t\tif(i*j>10000) break;\n\t\t\tisprime[i*j]=false;\n\t\t\tif(i%j==0) break;\n\t\t}\n\t}\n}\n\nvoid add_edge(int x,int p)\n{\n\tif(toid.find(p)==toid.end()) toid[p]=tot++;\n\tint y=toid[p];\n\tvec[x].push_back(y);\n\tvec[y].push_back(x);\n}\n\nvoid build_graph()\n{\n\tint tn;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\ttn=a[i];\n\t\tfor(auto &p:prime)\n\t\t{\n\t\t\tif(tn%p==0) add_edge(i,p);\n\t\t\twhile(tn%p==0) tn/=p;\n\t\t}\n\t\tif(tn!=1) add_edge(i,tn);\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<n;j++)\n\t\t{\n\t\t\tif(i==j) continue;\n\t\t\tif(__gcd(a[i],a[j])!=1) e[i][j]=true;\n\t\t}\n\t}\n}\n\nvoid gogo()\n{\n\tcolors++;\n\tvector <int> res;\n\tres.push_back(0);\n\tvector <int> adj;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tadj.push_back(i);\n\t}\n\tfor(auto &u:adj)\n\t{\n\t\tif(visit[u]>=colors) continue;\n\t\tif(block[u]) continue;\n\t\tint minx=dfs(u,colors,-1).second;\n\t\tif(minx==-1) continue;\n\t\tvector <int> temp=solve(minx);\n//\t\tcout<<temp<<endl;\n\t\tres=merge(res,temp);\n\t}\n\tcolors--;\n\tfor(int i=1;i<res.size();i++)\n\t{\n\t\tcout<<res[i]<<' ';\n\t}\n\tcout<<endl;\n}\n\nvoid print_graph()\n{\n\tcout<<\"--------Graph is below--------\"<<endl;\n\tfor(int i=0;i<tot;i++)\n\t{\n\t\tfor(int &j:vec[i])\n\t\t{\n\t\t\tcout<<i<<' '<<j<<endl;\n\t\t}\n\t}\n\tcout<<\"--------Graph is above--------\"<<endl;\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\",\"r\",stdin);\n\tinit();\n\tcin>>n;\n\ttot=n;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcin>>a[i];\n\t}\n\tbuild_graph();\n//\tprint_graph();\n\tgogo();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cctype>\n#include<cstdio>\n#include<vector>\n#include<utility>\n#include<algorithm>\nconst int N=2007;\nusing pi=std::pair<int,int>;\nint n,a[N],vis[N],deg[N];std::vector<int>e[N];std::priority_queue<pi>q;\nint read(){int x=0,c=getchar();while(isspace(c))c=getchar();while(isdigit(c))(x*=10)+=c&15,c=getchar();return x;}\nvoid dfs(int u)\n{\n    for(int v=vis[u]=1;v<=n;++v) if(!vis[v]&&std::__gcd(a[u],a[v])>1) e[u].push_back(v),++deg[v],dfs(v);\n}\nint main()\n{\n    n=read();\n    for(int i=1;i<=n;++i) a[i]=read();\n    std::sort(a+1,a+n+1);\n    for(int i=1;i<=n;++i) if(!vis[i]) dfs(i);\n    for(int i=1;i<=n;++i) if(!deg[i]) q.emplace(a[i],i);\n    for(int u;!q.empty();)\n    {\n\tprintf(\"%d \",q.top().first),u=q.top().second,q.pop();\n\tfor(int v:e[u]) if(!--deg[v]) q.emplace(a[v],v);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nProblem:Rearranging\nAlgorithm:\nStatus:\n*/\n\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <map>\n#include <queue>\n#include <deque>\n#include <set>\n#include <sstream>\n#include <utility>\n#include <list>\n#include <ctime>\n#include <memory.h>\n#include <stack>\n#include <stdio.h>\n#include <string.h>\n\nusing namespace std;\n\n#define INF 1e9+7\ntypedef long long ll;\n\nint n;\nint a[2005];\nvector<int> nei[2005];\nvector<int> nei2[2005];\nbool used[2005];\nint in[2005];\nvector<int> block[2005];\nvector<int> beg[2005];\nvector<int> ans;\n\nbool cmp1(const int &aa,const int &bb){\n\treturn a[aa]<a[bb];\n}\n\nbool cmp2(const vector<int> &aa,const vector<int> &bb){\n\treturn aa[0]>bb[0];\n}\n\nvoid dfs1(int x,int id) {\n\tif(used[x])return;\n\tused[x]=true;\n\tblock[id].push_back(x);\n\tfor(int i=0; i<nei2[x].size(); i++) {\n\t\tdfs1(nei2[x][i],id);\n\t}\n}\n\nvoid dfs2(int x){\n\tif(used[x])return;\n\tused[x]=true;\n\tans.push_back(a[x]);\n\tfor(int i=0;i<nei[x].size();i++){\n\t\tdfs2(nei[x][i]);\n\t}\n}\n\nint main() {\n#ifndef ZZZYT\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n#endif\n\n\tcin>>n;\n\tfor(int i=0; i<n; i++) {\n\t\tcin>>a[i];\n\t}\n\tfor(int i=0; i<n; i++) {\n\t\tfor(int j=i+1; j<n; j++) {\n\t\t\tif(__gcd(a[i],a[j])!=1) {\n\t\t\t\tif(a[i]<a[j]){\n\t\t\t\t\tnei[i].push_back(j);\n\t\t\t\t\tin[j]++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tnei[j].push_back(i);\n\t\t\t\t\tin[i]++;\n\t\t\t\t}\n\t\t\t\tnei2[i].push_back(j);\n\t\t\t\tnei2[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\n\tint id=0;\n\tfor(int i=0; i<n; i++) {\n\t\tif(!used[i]) {\n\t\t\tdfs1(i,id);\n\t\t\tid++;\n\t\t}\n\t}\n\n\tfor(int i=0; i<id; i++) {\n\t\tfor(int j=0;j<block[i].size();j++){\n\t\t\tif(in[block[i][j]]==0){\n\t\t\t\tbeg[i].push_back(block[i][j]);\n\t\t\t}\n\t\t}\n\t\tsort(beg[i].begin(),beg[i].end(),cmp1);\n\t}\n\tsort(beg,beg+id,cmp2);\n\t\n\tmemset(used,0,sizeof(used));\n\tfor(int i=0;i<id;i++){\n\t\tfor(int j=0;j<beg[i].size();j++){\n\t\t\tdfs2(beg[i][j]);\n\t\t}\n\t}\n\n\tfor(int i=0;i<ans.size();i++){\n\t\tcout<<ans[i]<<' ';\n\t}\n\tcout<<endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int, int> pir;\n\nint read() {\n    int x = 0, f = 1; char ch = getchar();\n    while (!isdigit(ch)) { if (ch == '-') f = -1; ch = getchar(); }\n    while (isdigit(ch)) { x = x * 10 + ch - '0'; ch = getchar(); }\n    return x * f;\n}\n\nconst int Max = 2033;\nint n, cnte, a[Max], fir[Max], g[Max][Max], vis[Max], deg[Max];\npriority_queue<pir> que;\nvector<int> ans;\nstruct edge {\n    int to, nxt;\n    edge() {}\n    edge(int a, int b) {\n        to = a, nxt = b;\n    }\n} e[Max * Max * 2];\nvoid addedge(int u, int v) {\n    deg[v]++;\n    e[++cnte] = edge(v, fir[u]);\n    fir[u] = cnte;\n}\nvoid dfs(int u) {\n    vis[u] = 1;\n    for (int i = 1; i <= n; i++)\n        if (!vis[i] && g[u][i]) {\n            addedge(u, i);\n            dfs(i);\n        }\n}\nint gcd(int a, int b) {\n\treturn !b ? a : gcd(b, a % b);\n}\n\nint main() {\n    n = read();\n    for (int i = 1; i <= n; i++) a[i] = read();\n    sort(a + 1, a + n + 1);\n    for (int i = 1; i <= n; i++)\n        for (int j = i + 1; j <= n; j++)\n            g[i][j] = g[j][i] = gcd(a[i], a[j]) != 1;\n    for (int i = 1; i <= n; i++)\n        if (!vis[i]) dfs(i);\n    for (int i = 1; i <= n; i++)\n        if (!deg[i]) que.push(pir(a[i], i));\n    while (!que.empty()) {\n        ans.push_back(que.top().first);\n        int u = que.top().second;\n        que.pop();\n        for (int i = fir[u]; i; i = e[i].nxt) {\n            deg[e[i].to]--;\n            if (!deg[e[i].to])\n                que.push(pir(a[e[i].to], e[i].to));\n        }\n    }\n    for (int i = 0; i < n; i++) printf(\"%d \", ans[i]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint mark[3000];\nint main()\n{\n    int n,arr[3000],brr[3000],a;\n    cin>>n;\n    for(int i=0; i<n; i++)\n    {\n        cin>>arr[i];\n        brr[i]=arr[i];\n    }\n    sort(arr,arr+n);\n    sort(brr,brr+n);\n    for(int i=0; i<n; i++)\n    {\n        for(int j=i+1; j<n; j++)\n        {\n            if(__gcd(arr[i],arr[j])!=1)\n            {\n                swap(arr[i+1],arr[j]);\n                break;\n            }\n        }\n    }\n    int idx;\n    int cnt=0;\n    for(int i=0; i<n; i++)\n    {\n        int j=0;\n        for( j=0; j<n; j++)\n        {\n            if(brr[i]==arr[j]&&mark[j]==0)\n            {\n                idx=j;\n                break;\n            }\n        }\n        for( j=idx; j>0; j--)\n        {\n            if(__gcd(arr[j],arr[j-1])==1)\n                swap(arr[j-1],arr[j]);\n            else\n                break;\n        }\n        mark[j]=1;\n    }\n    for(int i=0; i<n; i++)\n        cout<<arr[i]<<\" \";\n    cout<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pb push_back\n#define all(x) x.begin(), x.end()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nconst int N = 2000 + 10;\nconst int MOD = 1000000007;\nconst int LOG = 20;\nconst int INF = 1000000010;\nconst int delta = 11353;\n\nint n;\nvi G[N], a;\nmap<int, int> mp;\nint mark[N];\nint mark2[N];\n\nvoid DFS(int v){\n\tmark[v] = 1;\n\tfor (auto u:G[v]){\n\t\tif ((mark[u] == 0) && (mark2[u] == 0)){\n\t\t\tDFS(u);\n\t\t}\n\t}\n}\nint GCD(int x, int y){\n\tif (x == 0 || y == 0) return (x + y);\n\tif (x == 1 || y == 1) return 1;\n\tif (x < y) swap(x, y);\n\treturn GCD(y, x % y);\n}\n\nint32_t main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++){\n\t\tint x;\n\t\tcin >> x;\n\t\tmp[x] ++;\n\t\ta.pb(x);\n\t}\n\tsort(all(a));\n\ta.resize(unique(all(a)) - a.begin());\n\tfor (int i = 0; i < a.size(); i++) for (int j = 0; j < i; j++) if (__gcd(a[i], a[j]) != 1){\n\t\tG[i].pb(j), G[j].pb(i);\n\t}\n\t//cout << GCD(7, 11) << '\\n';\n\tvi ans;\n\tint last = 0;\n\tfor (int i = 0; i < a.size(); i++){\n\t\tmemset(mark, 0, sizeof mark);\n\t\tif (i == 0){\n\t\t\tint mx = 0;\n\t\t\tfor (int j = 0; j < a.size(); j++) if (!mark[j]) mx = j, DFS(j);\n\t\t\tmark2[mx] = 1;\n\t\t\tans.pb(a[mx]);\n\t\t\t//cout << a[mx] << endl;\n\t\t\tlast = mx;\n\t\t}else{\n\t\t\tsort(all(G[last]));\n\t\t\tint mx = 0;\n\t\t\tfor (auto u:G[last]){\n\t\t\t\tif ((mark[u] == 0) && (mark2[u] == 0)){\n\t\t\t\t\tDFS(u), mx = u;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\t\n\t\t\tfor (int j = 0;  j < a.size(); j++){\n\t\t\t\tif ((mark[j] == 0) && (mark2[j] == 0)){\n\t\t\t\t\tmx = max(j, mx), DFS(j);\n\t\t\t\t\tif (j > last) assert(0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tmark2[mx] = 1;\n\t\t\tans.pb(a[mx]);\n\t\t\tlast = mx;\n\t\t\t//cout << a[mx] << endl;\n\t\t}\n\t}\n\tfor (int i = 0; i < ans.size(); i++){\n\t\tint u = ans[i];\n\t\tif (i != 0){\n\t\t\t//if (GCD(ans[i], ans[i - 1]) == 1 && ans[i - 1] < ans[i]) assert(0);\n\t\t\t//if (GCD(ans[i], ans[i - 1]) != 1 && ans[i - 1] > ans[i]) assert(0);\n\t\t\t\n\t\t}\n\t\tfor (int i = 0; i < mp[u]; i++) cout << u << ' ';\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 2020;\nint gcd(int a, int b){\n\twhile(b){\n\t\ta %= b;\n\t\tswap(a, b);\n\t}\n\treturn a;\n}\nvector<int> to[maxn];\nint a[maxn], vis[maxn];\nvector<int> merge(const vector<int> &a, const vector<int> &b){\n\tint pa = 0, pb = 0, la = a.size(), lb = b.size();\n\tvector<int> ans;\n\twhile(pa < la && pb < lb){\n\t\tif(a[pa] > b[pb]) ans.push_back(a[pa++]);\n\t\telse ans.push_back(b[pb++]);\n\t}\n\twhile(pa < la) ans.push_back(a[pa++]);\n\twhile(pb < lb) ans.push_back(b[pb++]);\n\treturn ans;\n}\nvector<int> dfs(int u){\n\tvector<int> ans;\n\tvis[u] = 1;\n\tfor(int v : to[u]){\n\t\tif(!vis[v]){\n\t\t\tans = merge(ans, dfs(v));\n\t\t}\n\t}\n\tans.insert(ans.begin(), a[u]);\n\treturn ans;\n}\nint main(){\n\tint n; cin >> n;\n\tfor(int i = 0; i < n; i++) cin >> a[i];\n\tsort(a, a + n);\n\tfor(int i = 0; i < n; i++) for(int j = 0; j < n; j++) if(i != j) {\n\t\tif(gcd(a[i], a[j]) != 1){\n\t\t\tto[i].push_back(j);\n\t\t}\n\t}\n\tvector<int> ans;\n\tfor(int i = 0; i < n; i++){\n\t\tif(!vis[i]){\n\t\t\tans = merge(ans, dfs(i));\n\t\t}\n\t}\n\tfor(int v : ans) cout << v << \" \";\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n██████████████████████████████████████████████████████████████████████████████\n██              ██████    ██████      ██      ██  ██    ██████              ██\n██  ██████████  ██  ██      ██      ██████████████  ██████  ██  ██████████  ██\n██  ██      ██  ██    ██  ████      ██    ██████████    ██  ██  ██      ██  ██\n██  ██      ██  ██    ██  ██      ██  ████        ██  ████  ██  ██      ██  ██\n██  ██      ██  ██  ██████  ████  ████████████  ██    ████████  ██      ██  ██\n██  ██████████  ██  ████  ██    ████    ████  ██████  ████  ██  ██████████  ██\n██              ██  ██  ██  ██  ██  ██  ██  ██  ██  ██  ██  ██              ██\n████████████████████  ██  ██    ██████  ██    ████  ████    ██████████████████\n██████  ████          ████        ██    ██    ████  ████████  ██          ████\n████  ██      ██  ██      ██  ██████  ████  ████    ██    ████    ████████  ██\n██      ██      ██    ██    ████      ████        ██████  ██      ██  ██    ██\n██  ██    ████████████  ████  ██  ████            ████  ████████████  ████  ██\n██  ██      ██  ██  ████    ████████                ████████      ██  ██    ██\n██  ██  ██  ██████████  ████    ██  ████  ██    ████  ████        ████  ██  ██\n██    ██  ████  ██████  ██    ******************    ████  ██            ██  ██\n██    ██████  ██  ██████      * Scan this QR   *██████    ██  ██  ██  ████████\n████  ████  ██  ██████      ██* code to join   *██  ████    ██  ████████  ████\n██████      ████████  ██      * in the Three   *██  ████          ████  ██  ██\n████              ████  ████  * Body ETO.      *  ████        ██  ████  ██  ██\n██████  ██    ████████        *  --ETO manager *██  ██                ██    ██\n████    ██  ██  ██    ██████  *    Ye Wenjie   *████  ████  ██  ████  ██  ████\n██  ████  ██████    ████  ██  *ETO(C),1988~2018*      ██  ██  ██  ██    ██████\n██  ██████  ██  ████    ██  ██******************          ██████    ██████  ██\n██  ██  ██    ████    ██        ██  ██        ████████      ████  ██  ██    ██\n████████████    ██    ██████  ██████████  ██  ████  ██████████    ██  ██  ████\n██████████    ██  ████  ██        ██    ██████████  ██    ██      ██  ██    ██\n██    ██  ████    ██  ████  ████      ██████    ██    ██      ██  ██  ████  ██\n██████  ██  ██████  ██            ██████████  ██    ██    ████  ████  ██    ██\n██      ██████  ████  ████  ████      ████    ████  ████            ██████████\n██████████████████      ██  ██  ████  ██    ██  ██    ████  ██████    ██    ██\n██              ██        ████████████  ████  ██  ██  ██    ██  ██      ██  ██\n██  ██████████  ██    ████  ██████  ██  ██████████████      ██████    ██  ████\n██  ██      ██  ████████    ██  ██      ████  ████  ██              ████  ████\n██  ██      ██  ████  ████  ████  ██████  ██████████████  ██████████    ██  ██\n██  ██      ██  ██    ██████  ██  ██  ██████████  ██  ██      ████    ██    ██\n██  ██████████  ██████  ████            ██    ████████  ██  ████    ██████████\n██              ██████    ████  ████████  ██  ████    ██    ██  ████  ████  ██\n██████████████████████████████████████████████████████████████████████████████\n    扫    描    二    维    码    加    入    三    体    E    T    O\n*/\n/*****************\n *   I<3   C++   *\n *  IWANT ANYAC  *\n * ILOVEPROGRAM! *\n *IT'SINTERESTING*\n * ILOVEPROGRAM! *\n *  INCONTESTS   *\n *   GETSCORE    *\n *    ACCODE     *\n *     LETS      *\n *      GO       *\n *Written by:    *\n *    charlieyan *\n *****************/\n#include <assert.h>\n#include <ctype.h>\n#include <errno.h>\n#include <float.h>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <locale>\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <wchar.h>\n#include <wctype.h>\n#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <cerrno>\n#include <clocale>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <limits>\n#include <map>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <istream>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <utility>\n#include <vector>\n#include <cwchar>\n#include <cwctype>\n#include <numeric>\n#include <list>\n#define LL long long\n#define pb push_back\n#define pob pop_back\n#define mp make_pair\n#define FILL(a,v) memset((void*)a,v,sizeof(a))\n#define FILL0(a) FILL(a,0)\n#define FILL1(a) FILL(a,-1)\n#define FILLBIG(a) FILL(a,0x3f)\n#define ALL(a) (a).begin(),(a).end()\n#define Inf ((int)0x3f3f3f3f)\n#define INF ((long long)0x3f3f3f3f3f3f3f3f)\n#define Mod 1000000007\n#define foreach(it,x) for(__typeof(x.begin()) it=x.begin();it!=x.end();it++)\n#define FOR(i,x) for(int i=0;i<x;i++)\n#define RFOR(i,x) for(int i=x-1;i>=0;i--)\n#define FFOR(i,a,b) for(int i=a;i<b;i++)\n#define FRFOR(i,a,b) for(int i=a-1;i>=b;i--)\n#define SZ(a) ((int)(a).size())\n#define FI first\n#define SE second\n#define OVER(...) return printf(__VA_ARGS__),0\n#define fastio ios::sync_with_stdio(0)\n#define filei(f) freopen(f,\"r\",stdin)\n#define fileo(f) freopen(f,\"w\",stdout)\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define MASK(a) (1<<(a))\n#define MASKX(x,a) ((x)<<(a))\n#define BIT(a,b) (((a)>>(b))&1)\n#define cddx(a) priority_queue<a >\n#define cxdd(a) priority_queue<a,vector<a >,greater<a > >\n#define deval(a) {cerr<<#a<<\" = \"<<a<<endl;}\n#define dearr(be,en) {cerr<<#be;cerr<<\" = {\";for(auto i=be;i!=en;i++)cerr<<' '<<*i;cerr<<\" }\\n\";}\n#define reg register\n#define prtime eprintf(\"\\n\\nTime used: %dms\\n\",clock());\n#define PI 3.1415926535897932384626\n#define TODEG(a) (a*180/PI)\n#define y0 ykangjimutigeidiqiuyipianjingtu\n#define y1 yxiaomiexuduhuanrenleiwannianankang\n#define endl '\\n'\n//抗击母体，给地球一片净土\n//消灭徐毒，还人类万年安康\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef unsigned long long UINT;\ntypedef unsigned int uint;\ntypedef long long INT;\ntypedef long double ldouble;\ntypedef pair<INT,INT> PII;\ntypedef stringstream sst;\ntypedef istringstream iss;\ntypedef vector<int> vint;\ntypedef vector<INT> VINT;\ntypedef vector<pii> vpii;\ntypedef vector<PII> VPII;\ntypedef priority_queue<int> pqi;\ntypedef priority_queue<INT> PQI;\ntypedef priority_queue<pii> pqp;\ntypedef priority_queue<PII> PQP;\ntypedef priority_queue<int,vint,greater<int> > xqi;\ntypedef priority_queue<INT,VINT,greater<INT> > XQI;\ntypedef priority_queue<pii,vpii,greater<pii> > xqp;\ntypedef priority_queue<PII,VPII,greater<PII> > XQP;\nstruct fastIO\n{\n\tinline fastIO operator>>(int& num)\n\t{\n\t\tnum=0;\n\t\tchar c=getchar();\n\t\twhile(c!='-'&&(c<'0'||c>'9'))c=getchar();\n\t\tbool foo=0;\n\t\tif(c=='-')\n\t\t{\n\t\t\tfoo=1;\n\t\t\tc=getchar();\n\t\t}\n\t\twhile(c>='0'&&c<='9')\n\t\t{\n\t\t\tnum=(num<<3)+(num<<1)+c-'0';\n\t\t\tc=getchar();\n\t\t}\n\t\tif(foo)num=-num;\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(INT& num)\n\t{\n\t\tnum=0;\n\t\tchar c=getchar();\n\t\twhile(c!='-'&&(c<'0'||c>'9'))c=getchar();\n\t\tbool foo=0;\n\t\tif(c=='-')\n\t\t{\n\t\t\tfoo=1;\n\t\t\tc=getchar();\n\t\t}\n\t\twhile(c>='0'&&c<='9')\n\t\t{\n\t\t\tnum=(num<<3)+(num<<1)+c-'0';\n\t\t\tc=getchar();\n\t\t}\n\t\tif(foo)num=-num;\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(float& num)\n\t{\n\t\tscanf(\"%f\",&num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(double& num)\n\t{\n\t\tscanf(\"%lf\",&num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(long double& num)\n\t{\n\t\tscanf(\"%Lf\",&num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(char& num)\n\t{\n\t\tnum=getchar();\n\t\twhile(num==' '||num=='\\n')num=getchar();\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(char* num)\n\t{\n\t\tint cnt=0;\n\t\tchar c=getchar();\n\t\twhile(c==' '||c=='\\n')c=getchar();\n\t\twhile(c!=' '&&c!='\\n')\n\t\t{\n\t\t\tnum[cnt++]=c;\n\t\t\tc=getchar();\n\t\t}\n\t\tnum[cnt]=0;\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(string& num)\n\t{\n\t\tcin>>num;\n\t\treturn *this;\n\t}\n\tinline void printInt(const int& num)\n\t{\n\t\tif(num<10)\n\t\t{\n\t\t\tputchar(num+'0');\n\t\t\treturn;\n\t\t}\n\t\tprintInt(num/10);\n\t\tputchar((num%10)+'0');\n\t}\n\tinline void printINT(const INT& num)\n\t{\n\t\tif(num<10)\n\t\t{\n\t\t\tputchar(num+'0');\n\t\t\treturn;\n\t\t}\n\t\tprintINT(num/10);\n\t\tputchar((num%10)+'0');\n\t}\n\tinline fastIO operator<<(const int& num)\n\t{\n\t\tif(num<0)putchar('-'),printInt(-num);\n\t\telse printInt(num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const INT& num)\n\t{\n\t\tif(num<0)putchar('-'),printINT(-num);\n\t\telse printINT(num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const float& num)\n\t{\n\t\tprintf(\"%.10f\",num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const double& num)\n\t{\n\t\tprintf(\"%.16lf\",num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const long double& num)\n\t{\n\t\tprintf(\"%.20Lf\",num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const char& num)\n\t{\n\t\tputchar(num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const char* num)\n\t{\n\t\tfor(int i=0;num[i];i++)\n\t\t\tputchar(num[i]);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const string& num)\n\t{\n\t\tcout<<num;\n\t\treturn *this;\n\t}\n}fio;\n//Coded by Charlieyan\n//版权所有，翻印必究\n\nvector<int> nei[2005],nei2[2005];\nint num[2005];\nbool SortComp13(int a,int b){\n\treturn num[a]<num[b];\n}\n\nbool lgl[2005];\nvector<int> ltks[2005];\nint ans[2005];\n\nvoid dfs(int now,int ltk){\n\tif(lgl[now]){\n\t\treturn;\n\t}\n\tlgl[now]=1;\n\tltks[ltk].pb(now);\n\tfor(int i=0;i<SZ(nei[now]);i++){\n\t\tif(!lgl[nei[now][i]]){\n\t\t\tdfs(nei[now][i],ltk);\n\t\t\tnei2[now].pb(nei[now][i]);\n\t\t}\t\n\t}\n}\n\nint n;\n\nint gcd(int a,int b){\n\treturn !b?a:gcd(b,a%b);\n}\n\nint main(){\n\tfio>>n;\n\tfor(int i=0;i<n;i++){\n\t\tfio>>num[i];\n\t}\n\tsort(num,num+n);\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(gcd(num[i],num[j])!=1){\n\t\t\t\tnei[i].pb(j);\n\t\t\t}\n\t\t}\n\t}\n\tint cntltk=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(!lgl[i]){\n\t\t\tdfs(i,cntltk++);\n\t\t}\n\t}\n\tpriority_queue<pii> pq;\n\tfor(int i=0;i<cntltk;i++){\n\t\tpq.push(mp(num[ltks[i][0]],ltks[i][0]));\n\t}\n\tint N=0;\n\twhile(SZ(pq)){\n\t\tpii fff=pq.top();\n\t\tpq.pop();\n\t\tint Num=fff.first,x=fff.second;\n\t\tans[N++]=Num;\n\t\tfor(int i=0;i<SZ(nei2[x]);i++){\n\t\t\tpq.push(mp(num[nei2[x][i]],nei2[x][i]));\n\t\t}\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tprintf(\"%d%c\",ans[i],i==N-1?'\\n':' ');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define FOR(i,a,b) for (register int i=(a);i<=(b);i++)\n#define For(i,a,b) for (register int i=(a);i>=(b);i--)\n#define mem(i,j) memset(i,j,sizeof(i))\n#define GO(u) for (register int j=f[u];j!=-1;j=nxt[j])\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define MP make_pair\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\nconst int N=2020;\nint n,a[N],vis[N],cnt=0,ans[N],du[N];\nvector<int> vec[N],G[N];\npriority_queue <pii> q;\ninline int read()\n{\n\tint x=0,f=1;\n\tchar c=getchar();\n\twhile (c<'0'||c>'9') {if (c=='-') f=-1;c=getchar();}\n\twhile (c>='0'&&c<='9') {x=(x<<1)+(x<<3)+c-'0';c=getchar();}\n\treturn f*x;\n}\ninline void write(int x)\n{\n\tif (x<0) putchar('-'),x=-x;\n\tif (x>9) write(x/10);\n\tputchar(x%10+'0');\n\treturn;\n}\ninline int GCD(int x,int y)\n{\n\tif (!y) return x;\n\tif (x<y) return GCD(y,x);\n\treturn GCD(y,x%y);\n}\ninline void dfs(int u)\n{\n\tvis[u]=1;\n\tFOR(i,0,(int)vec[u].size()-1)\n\t{\n\t\tint v=vec[u][i];\n\t\tif (vis[v]) continue;\n\t\tG[u].pb(v);\n\t\tdu[v]++;\n\t\tdfs(v);\n\t}\n\treturn;\n}\nbool cmp(const int x,const int y) {return a[x]<a[y];}\nint main()\n{\n\tn=read();\n\tFOR(i,1,n) a[i]=read();\n\tsort(a+1,a+n+1);\n\tFOR(i,1,n) FOR(j,1,n) if (i!=j) if (GCD(a[i],a[j])>1) vec[i].pb(j);\n\tFOR(i,1,n) sort(vec[i].begin(),vec[i].end());\n\tFOR(i,1,n) if (!vis[i])\n\t{\n\t\tdfs(i);\n\t\tq.push(MP(a[i],i));\n\t}\n\twhile (q.size())\n\t{\n\t\tpii tmp=q.top();\n\t\tq.pop();\n\t\tans[++ans[0]]=tmp.fi;\n\t\tFOR(i,0,(int)G[tmp.se].size()-1)\n\t\t{\n\t\t\tint v=G[tmp.se][i];\n\t\t\tdu[v]--;\n\t\t\tif (!du[v]) q.push(MP(a[v],v));\n\t\t}\n\t}\n\tFOR(i,1,n) write(ans[i]),putchar(' ');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 2345;\n\nint n, a[N], b[N], degree[N];\nvector<int> adj[N], new_adj[N];\nbool visit[N];\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.tie(0);\n  cin >> n;\n  for (int i = 1; i <= n; ++i) {\n    cin >> a[i];\n  }\n  sort(a + 1, a + 1 + n);\n  for (int i = 1; i <= n; ++i) {\n    for (int j = 1; j < i; ++j) {\n      if (__gcd(a[i], a[j]) != 1) {\n        adj[i].push_back(j);\n        adj[j].push_back(i);\n      }\n    }\n  }\n  function<void (int)> dfs = [&] (int x) {\n    visit[x] = true;\n    for (auto y : adj[x]) {\n      if (!visit[y]) {\n        new_adj[x].push_back(y);\n        ++degree[y];\n        dfs(y);\n      }\n    }\n  };\n  for (int i = 1; i <= n; ++i) {\n    if (!visit[i]) {\n      dfs(i);\n    }\n  }\n  int t = 0;\n  priority_queue<int> q;\n  for (int i = 1; i <= n; ++i) {\n    if (!degree[i]) {\n      q.push(i);\n    }\n  }\n  while (!q.empty()) {\n    int x = q.top();\n    q.pop();\n    b[++t] = a[x];\n    for (auto y : new_adj[x]) {\n      if (--degree[y] == 0) {\n        q.push(y);\n      }\n    }\n  }\n  for (int i = 1; i <= n; ++i) {\n    cout << b[i] << \" \\n\"[i == n];\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=2005;\nint a[N],vis[N];\nvector<int>e[N],g[N]; \npriority_queue<int>pq;\nvoid dfs(int v)\n{\n\tvis[v]=1;\n\tfor(int i=0;i<e[v].size();i++)\n\t{\n\t\tint u=e[v][i];\n\t\tif(vis[u])\n\t\t\tcontinue;\n\t\tg[v].push_back(u);\n\t\tdfs(u);\n\t}\n}\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++)\t\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(__gcd(a[i],a[j])>1)\n\t\t\t\te[i].push_back(j);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(!vis[i])\n\t\t{\n\t\t\tdfs(i);\n\t\t\tpq.push(i);\n\t\t}\n\t}\n\twhile(!pq.empty())\n\t{\n\t\tint k=pq.top();\n\t\tpq.pop();\n\t\tprintf(\"%d \",a[k]);\n\t\tfor(int i=0;i<g[k].size();i++)\n\t\t\tpq.push(g[k][i]);\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n\nusing namespace std;\n\nconst int MAX_N = 2e3 + 5;\nconst int MAX_V = 3e4 + 5; // max # of vertices in our graph\nconst int MAX_P = 1e4 + 5;\nconst int INF = 1e9 + 5;\n\nint arr [MAX_N];\nvector<int> adj [MAX_N];\nvoid add_edge (int u, int v) {\n  adj[u].push_back(v);\n  adj[v].push_back(u);\n}\n\nint n, m;\nint state [MAX_N]; // 0 - innocent, 1 - blocked, 2 - allowed, 3 - deleted\n\nint comp [MAX_N];\nvoid find_comps (int u, int c) {\n  comp[u] = c;\n  for (int nxt : adj[u]) {\n    if (state[nxt] != 3 && comp[nxt] == -1) {\n      find_comps(nxt, c);\n    }\n  }\n}\n\npair<int, int> smallest [MAX_N];\nvoid solve () {\n  for (int i = 0; i < n + m; i++) {\n    comp[i] = -1;\n  }\n  for (int i = 0; i < n; i++) {\n    if (state[i] != 3 && comp[i] == -1) {\n      find_comps(i, i);\n    }\n  }\n\n  // for each component, find the smallest thing with state 0 or 2\n  for (int i = 0; i < n; i++) {\n    smallest[i] = make_pair(INF, 0);\n  }\n  for (int i = 0; i < n; i++) {\n    if (state[i] == 0 || state[i] == 2) {\n      smallest[comp[i]] = min(smallest[comp[i]], make_pair(arr[i], i));\n    }\n  }\n\n  // and pick the biggest of those\n  pair<int, int> ans = make_pair(0, -1); // <value, idx>\n  for (int i = 0; i < n; i++) {\n    if (smallest[i].first != INF) {\n      ans = max(ans, smallest[i]);\n    }\n  }\n\n  int idx = ans.second;\n  cout << arr[idx] << \" \";\n\n  // if it is innocent block its component\n  if (state[idx] == 0) {\n    for (int i = 0; i < n; i++) {\n      if (comp[i] == comp[idx]) {\n        state[idx] = 1;\n      }\n    }\n  }\n\n  // unblock cousins\n  for (int p : adj[idx]) {\n    for (int u : adj[p]) {\n      if (state[u] != 3) {\n        state[u] = 2;\n      }\n    }\n  }\n\n  // delete\n  state[idx] = 3;\n}\n\nint sieve [MAX_P];\nvector<int> smallp;\nmap<int, int> compr;\nvoid add_to_compr (int x) {\n  for (int p : smallp) {\n    if (x % p == 0) {\n      compr[p] = 0;\n      while (x % p == 0) {\n        x /= p;\n      }\n    }\n  }\n\n  if (x != 1) {\n    compr[x] = 0;\n  }\n}\n\nvoid add_edges (int idx, int x) {\n  for (int p : smallp) {\n    if (x % p == 0) {\n      add_edge(idx, compr[p]);\n      while (x % p == 0) {\n        x /= p;\n      }\n    }\n  }\n\n  if (x != 1) {\n    add_edge(idx, compr[x]);\n  }\n}\n\nint main () {\n  for (int i = 2; i < MAX_P; i++) {\n    if (!sieve[i]) {\n      smallp.push_back(i);\n      for (int j = i; j < MAX_P; j += i) {\n        sieve[j] = 1;\n      }\n    }\n  }\n  \n  ios::sync_with_stdio(false);\n\n  cin >> n;\n  \n  for (int i = 0; i < n; i++) {\n    cin >> arr[i];\n    add_to_compr(arr[i]);\n  }\n\n  int cur_c = n;\n  for (auto it = compr.begin(); it != compr.end(); it++) {\n    it->second = cur_c;\n    cur_c++;\n  }\n\n  for (int i = 0; i < n; i++) {\n    add_edges(i, arr[i]);\n  }\n  m = compr.size();\n  \n  for (int i = 0; i < n; i++) {\n    solve();\n  }\n  cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n \n#define all(x)  x.begin(), x.end()\n \nint n;\nint used[2020];\nvector<int> a, ans;\n \nvoid dfs(int v) {\n        used[v] = true;\n        ans.push_back(a[v]);\n        for (int u = 0; u < n; u ++) {\n                if (!used[u] && __gcd(a[v], a[u]) != 1) dfs(u);\n        }\n}\n \nint main() {\n        scanf(\"%d\", &n);\n        a.resize(n);\n        for (int i = 0; i < n; i ++) scanf(\"%d\", &a[i]);\n        sort(all(a));\n        for (int i = 0; i < n; i ++) if (!used[i]) dfs(i);\n        for (int i = 0; i < n; i ++) {\n                int p = i;\n                for (int j = i - 1; j >= 0 && __gcd(ans[i], ans[j]) == 1; j --) {\n                        if (ans[j] < ans[i]) p = j;\n                }\n                rotate(ans.begin() + p, ans.begin() + i, ans.begin() + i + 1);\n        }\n        for (int i = 0; i < n; i ++) cout << ans[i] << (i == n - 1 ? '\\n' : ' ');\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb  push_back\nusing namespace std;\n \ntypedef pair<int,int>  PII;\nint n,a[2010],e[2010][2010],vis[2010];\n \nint gcd(int a,int b){return b?gcd(b,a%b):a;}\n \nvector <int> solve(int x)\n{\n\tint m=0;\n\tvector <vector <int> > V;\n\tvector <vector <int> ::iterator> h;\n\tvector <int> r;\n\tvis[x]=1;\n\tfor (int y=1; y<=n; y++)\n\t\tif ((e[x][y])&&(!vis[y]))\n\t\t\tV.pb(solve(y)),h.pb(V[m].begin()),m++;\n\tr.pb(a[x]);\n\twhile (1)\n\t\t{\n\t\t\tint x=-1;\n\t\t\tfor (int i=0; i<m; i++)\n\t\t\t\tif ((h[i]!=V[i].end())&&((x<0)||(*h[i]>*h[x])))\n\t\t\t\t\tx=i;\n\t\t\tif (x<0)  return r;\n\t\t\tr.pb(*h[x]),h[x]++;\t\t\t\n\t\t}\n}\n \nvoid work()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1; i<=n; i++)  scanf(\"%d\",&a[i]),e[0][i]=1;\n\tsort(a+1,a+n+1);\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=i+1; j<=n; j++)\n\t\t\tif (gcd(a[i],a[j])!=1)\n\t\t\t\te[i][j]=e[j][i]=1;\n\tvector <int> ans=solve(0);\n\tfor (int i=1; i<=n; i++)  printf(\"%d \",ans[i]);\n}\n \nint main()\n{\n\twork();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int maxn = 2030, oo = 123456789, maxm = 54010;\n\nint n, m, T, ans, mn, a[maxn], foo[maxn], lst[maxm], tag[maxn];\nbool vis[maxn], f[maxn], G[maxn][maxn], F[maxn];\nstd::vector<int> g[maxn], has[maxn], all;\nstd::vector<std::pair<int, int> > v;\n\nvoid GEN() {\n\tint mx = 0;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif(!foo[i]) {\n\t\t\tif(a[i] == 1) {\n\t\t\t\tF[i] = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tF[i] = 0;\n\t\t\tfor (int j: has[i]) {\n\t\t\t\tif(lst[j] >= mx) {\n\t\t\t\t\tF[i] = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n//\t\t\tprintf(\"(%d, %d) \", mx, F[i]);\n\t\t}\n\t\telse {\n\t\t\t(foo[i] > mx) && (mx = foo[i]);\n\t\t}\n\t}\n//\tputs(\"\");\n\treturn;\n}\n\nvoid dfs(int u) {\n\tif(vis[u] || f[u]) {\n\t\treturn;\n\t}\n\ttag[u] = T;\n\tif(a[u] < mn) {\n\t\tmn = a[u];\n\t}\n\tvis[u] = 1;\n\tfor (int v: g[u]) {\n\t\tdfs(v);\n\t}\n\treturn;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tscanf(\"%d\", a + i);\n\t\tint t = a[i];\n\t\tfor (int x = 2; x * x <= t; ++x) {\n\t\t\tif(t % x == 0) {\n\t\t\t\tall.push_back(x);\n\t\t\t\twhile(t % x == 0) {\n\t\t\t\t\tt /= x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(t > 1) {\n\t\t\tall.push_back(t);\n\t\t}\n\t}\n\tstd::sort(a + 1, a + n + 1);\n\tstd::sort(all.begin(), all.end());\n\tall.resize(std::unique(all.begin(), all.end()) - all.begin());\n\tm = (int)(all.size());\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tif(a[i] % all[j] == 0) {\n\t\t\t\thas[i].push_back(j);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = 1; j <= n; ++j) {\n\t\t\tif(i != j) {\n\t\t\t\tint d = std::__gcd(a[i], a[j]);\n\t\t\t\tif(d > 1) {\n\t\t\t\t\tg[i].push_back(j);\n\t\t\t\t\tg[j].push_back(i);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tG[i][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tGEN();\n\t\tmemset(vis + 1, 0, sizeof(vis[0]) * n);\n\t\tv.clear();\n\t\tfor (int u = 1; u <= n; ++u) {\n\t\t\tif(F[u]) {\n\t\t\t\tif(!vis[u] && !f[u]) {\n\t\t\t\t\t++T;\n\t\t\t\t\tmn = oo;\n\t\t\t\t\tdfs(u);\n\t\t\t\t\tv.push_back(std::make_pair(mn, T));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstd::sort(v.begin(), v.end());\n\t\tfor (int u = 1; u <= n; ++u) {\n\t\t\tif(F[u] && !f[u]) {\n\t\t\t\tint i = (int)(v.size()) - 1;\n\t\t\t\tif(v[i].second == tag[u]) {\n\t\t\t\t\t--i;\n\t\t\t\t}\n\t\t\t\tif(i < 0 || v[i].first <= a[u]) {\n\t\t\t\t\tans = u;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tf[ans] = 1;\n\t\tfoo[ans] = i;\n\t\tprintf(\"%d \", a[ans]);\n//\t\tprintf(\"%d\\n\", ans);\n\t\tfor (int j: has[ans]) {\n\t\t\tlst[j] = i;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<cstring>\n#include<algorithm>\n#include<queue>\n#define fo(i,a,b) for(i=a;i<=b;i++)\n#define ll long long\nusing namespace std;\nint n,a[2005],tot,du[2005],h[2005],to[4000005],nex[4000005];\nbool bhz[2005][2005],pd[2005];\nint gcd(int a,int b)\n{\n    return b?gcd(b,a%b):a;\n}\nstruct node{\n    int fr,id;\n}st;\nbool operator <(node a,node b)\n{\n    return a.fr<b.fr;\n}\npriority_queue<node> q;\nvoid add(int a,int b)\n{\n    du[b]++;\n    to[++tot]=b;\n    nex[tot]=h[a];\n    h[a]=tot;\n}\nvoid dfs(int x)\n{\n    pd[x]=1;\n    for(int i=1;i<=n;i++)\n        if(bhz[x][i]&&!pd[i])\n        {\n            add(x,i);\n            dfs(i);\n        }\n}\nint main()\n{\n    cin>>n;\n    for(int i=1;i<=n;i++) cin>>a[i];\n    sort(a+1,a+n+1);\n    for(int i=1;i<=n-1;i++)\n    for(int j=i+1;j<=n;j++)\n    if(gcd(a[i],a[j])>1) bhz[i][j]=bhz[j][i]=1;\n    for(int i=1;i<=n;i++) if(!pd[i]) dfs(i);\n    for(int i=1;i<=n;i++) \n        if(!du[i])\n        { \n            st.fr=a[i];\n            st.id=i;\n            q.push(st); \n        }\n    for(int i=1;i<=n;i++)\n    {\n        st=q.top();\n        q.pop();\n        int now=st.id;\n        cout<<a[now]<<\" \";\n        int t=h[now];\n        while (t){\n            du[to[t]]--;\n            if (!du[to[t]]){\n                st.fr=a[to[t]];\n                st.id=to[t];\n                q.push(st);\n            }\n            t=nex[t];\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// =================================\n//   author: M_sea\n//   website: http://m-sea-blog.com/\n// =================================\n#include <algorithm>\n#include <iostream>\n#include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#include <queue>\n#define re register\nusing namespace std;\n\ninline int read() {\n    int X=0,w=1; char c=getchar();\n    while (c<'0'||c>'9') { if (c=='-') w=-1; c=getchar(); }\n    while (c>='0'&&c<='9') X=X*10+c-'0',c=getchar();\n    return X*w;\n}\n\nconst int N=2000+10;\n\nstruct Edge { int v,nxt; } e[N];\nint head[N];\n\ninline void addEdge(int u,int v) {\n    static int cnt=0;\n    e[++cnt]=(Edge){v,head[u]},head[u]=cnt;\n}\n\nint n;\nint a[N],vis[N],deg[N];\nint G[N][N];\n\ninline void dfs(int u) {\n    vis[u]=1;\n    for (re int i=1;i<=n;++i) {\n        if (vis[i]||!G[u][i]) continue;\n        ++deg[i],addEdge(u,i);\n        dfs(i);\n    }\n}\n\ninline void topsort() {\n    priority_queue<int> Q;\n    for (re int i=1;i<=n;++i)\n        if (!deg[i]) Q.push(i);\n    while (!Q.empty()) {\n        int u=Q.top(); Q.pop();\n        printf(\"%d \",a[u]);\n        for (re int i=head[u];i;i=e[i].nxt) Q.push(e[i].v);\n    }\n}\n\nint main() {\n    n=read();\n    for (re int i=1;i<=n;++i) a[i]=read();\n    sort(a+1,a+n+1);\n    for (re int i=1;i<=n;++i)\n        for (re int j=i+1;j<=n;++j) {\n            if (__gcd(a[i],a[j])==1) continue;\n            G[i][j]=G[j][i]=1;\n        }\n    for (re int i=1;i<=n;++i)\n        if (!vis[i]) dfs(i);\n    topsort();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n#define sqr(x) ((x)*(x))\n#define mp make_pair\n#define uint unsigned\n#define PI pair<int,int>\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline ll read(){\n\tll x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(ll a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(ll a){write(a); puts(\"\");}\ninline void wri(ll a){write(a); putchar(' ');}\ninline ull rnd(){\n\treturn ((ull)rand()<<30^rand())<<4|rand()%4;\n}\nconst int N=2005;\nint vis[N],rd[N],a[N],n;\nbitset<N> ycl[N];\nvector<int> v[N];\nvoid dfs(int p){\n\tvis[p]=1;\n\tfor(int i=1;i<=n;i++)if(!vis[i]&&ycl[p][i]){v[p].push_back(i); rd[i]++; dfs(i);}\n}\npriority_queue<int> q;\nsigned main(){\n\tn=read(); \n\tfor(int i=1;i<=n;i++)a[i]=read();\n\tsort(&a[1],&a[n+1]);\n\tfor(int i=1;i<=n;i++)for(int j=i+1;j<=n;j++)ycl[i][j]=ycl[j][i]=__gcd(a[i],a[j])>1;\n\tfor(int i=1;i<=n;i++)if(!vis[i]){\n\t\tdfs(i);\n\t}\n\tfor(int i=1;i<=n;i++)if(rd[i]==0)q.push(i);\n\twhile(q.size()){\n\t\tint t=q.top(); q.pop(); write(a[t]); putchar(' ');\n\t\tfor(auto i:v[t])if(--rd[i]==0)q.push(i);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<stack>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<cmath>\nusing namespace std;\nint gcd(int x,int y){return (y==0)?x:gcd(y,x%y);}\nint n;\nint a[1001];\nint in[1001];\nint vis[1001];\nint ed[1001][1001];\nvector<int> e[1001];\npriority_queue<int,vector<int>,less<int> > q;\nvoid dfs(int x)\n{\n\tvis[x]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tif(!vis[i]&&ed[x][i])\n\t\t{\n\t\t\tin[i]++;\n\t\t\te[x].push_back(i);\n\t\t\tdfs(i);\n\t\t}\n}\nsigned main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\tif(gcd(a[i],a[j])!=1)\n\t\t\t\ted[i][j]=1,ed[j][i]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tif(!vis[i])\n\t\t\tdfs(i);\n\tfor(int i=1;i<=n;i++)\n\t\tif(in[i]==0)\n\t\t\tq.push(i);\n\twhile(!q.empty())\n\t{\n\t\tint u=q.top();\n\t\tq.pop();\n\t\tprintf(\"%d \",a[u]);\n\t\tfor(int i=0;i<e[u].size();i++)\n\t\t{\n\t\t\tint to=e[u][i];\n\t\t\tin[to]--;\n\t\t\tif(in[to]==0)\n\t\t\t\tq.push(to);\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 0x3f3f3f3f;\n\nint GCD(int a, int b){\n\treturn b == 0 ? a : GCD(b, a % b);\n}\n\nint a[2010];\nint gcd[2010][2010];\nvector <int> from[2010];\nint ans[2010];\nint c[40010], in_ans[2010], minj[2010], last[2010], best[2010];\nint C, n;\n\nvoid dfs(int x){\n\tc[x] = C;\n\tfor (int i = 0; i < from[x].size(); i++){\n\t\tint v = from[x][i];\n\t\tif (c[v] != -1 || v < n && in_ans[v]) continue;\n\t\tdfs(v);\n\t}\n}\n\nvoid color(){\n\tC = 0;\n\tmemset(c, -1, sizeof(c));\n\tfor (int i = 0; i < n; i++){\n\t\tif (c[i] != -1 || in_ans[i]) continue;\n\t\tdfs(i), C++;\n\t}\n}\n\nmap <int, int> mp;\nint m;\n\nint id(int x){\n\tif (!mp.count(x)){\n\t\tm++, mp[x] = m - 1;\n\t\treturn m - 1;\n\t}\n\treturn mp[x];\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\tm = n;\n\tfor (int i = 0; i < n; i++){\n\t\tscanf(\"%d\", &a[i]);\n\t\tint t = a[i];\n\t\tfor (int j = 2; j * j <= t; j++){\n\t\t\tif (t % j == 0){\n\t\t\t\tfrom[id(j)].push_back(i);\n\t\t\t\tfrom[i].push_back(id(j));\n\t\t\t\twhile (t % j == 0) t /= j;\n\t\t\t}\n\t\t}\n\t\tif (t != 1){\n\t\t\tfrom[i].push_back(id(t));\n\t\t\tfrom[id(t)].push_back(i);\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tgcd[i][j] = GCD(a[i], a[j]) != 1;\n\t\t}\n\t}\n\tfor (int i = 0; i <= n; i++){\n\t\tminj[i] = INF, last[i] = -1;\n\t}\n\tint tot = 0;\n\twhile (tot != n){\n\t\tcolor();\n\t\tfor (int i = 0; i < C; i++){\n\t\t\tbest[i] = -1;\n\t\t}\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tif (in_ans[i]) continue;\n\t\t\tif (minj[last[i] + 1] < a[i]) continue;\n//\t\t\tcout << i << \" \";\n\t\t\tif (best[c[i]] == -1 || a[best[c[i]]] > a[i]) best[c[i]] = i;\n\t\t}\n\t\tint id = -1;\n\t\tfor (int i = 0; i < C; i++){\n\t\t\tif (best[i] == -1) continue;\n\t\t\tif (id == -1 || a[id] < a[best[i]]) id = best[i];\n\t\t}\n\t\tif (id == -1) throw;\n\t\tin_ans[id] = 1, ans[tot++] = a[id];\n\t\tfor (int i = 0; i < tot; i++){\n\t\t\tminj[i] = min(minj[i], a[id]);\n\t\t}\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tif (gcd[id][i]) last[i] = tot - 1;\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++){\n\t\tprintf(\"%d \", ans[i]);\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int nmax = 2009;\n\nint used[nmax] , usedcrt[nmax] , x[nmax] , boss[nmax] , blocked[nmax];\nvector < int > g[nmax];\nqueue < int > answer[nmax];\nvector < int > cc[nmax];\nint p , low , n , i , j , first , last;\n\nvoid dfs(int act)\n{\n    used[act] = 1;\n    cc[last].push_back(act);\n    for (int i = 0 ; i < g[act].size() ; ++i)\n    {\n        int nxt = g[act][i];\n        if (used[nxt]) continue;\n        dfs(nxt);\n    }\n}\n\nvoid mark(int act)\n{\n    usedcrt[act] = 1;\n    cc[last].push_back(act);\n    for (int i = 0 ; i < g[act].size() ; ++i)\n    {\n        int nxt = g[act][i];\n        if (usedcrt[nxt]) continue;\n        if (blocked[nxt]) continue;\n        mark(nxt);\n    }\n}\n\nvoid split(int act , int whr)\n{\n    memset(usedcrt , 0 , sizeof(usedcrt));\n    vector < int > sons;\n\n    for (int i = 0 ; i < g[act].size() ; ++i)\n    {\n        int nxt = g[act][i];\n        if (blocked[nxt]) continue;\n        sons.push_back(nxt);\n    }\n\n    blocked[act] = 1;\n\n    for (int i = 0 ; i < sons.size() ; ++i)\n    {\n        int nxt = sons[i];\n        if (usedcrt[nxt]) continue;\n\n        ++last;\n        mark(nxt);\n        boss[last] = act;\n        answer[last] = answer[whr];\n        answer[last].push(act);\n    }\n\n\n}\n\nvoid solve(int whr)\n{\n    if (cc[whr].size() == 1)\n    {\n        answer[whr].push(cc[whr][0]);\n        blocked[cc[whr][0]] = 1;\n        return;\n    }\n\n    int forced = x[boss[whr]] , i , bst;\n    if (forced == 0)\n    {\n        bst = -1;\n        for (i = 0 ; i < cc[whr].size() ; ++i)\n        {\n            int act = cc[whr][i];\n            if (x[act] < x[bst] || bst == -1) bst = act;\n        }\n\n        split(bst , whr);\n    }\n    else\n    {\n        bst = -1;\n        for (i = 0 ; i < cc[whr].size() ; ++i)\n        {\n            int act = cc[whr][i];\n            if (1 < __gcd(forced , x[act]))\n            if (x[act] < x[bst] || bst == -1) bst = act;\n        }\n\n        split(bst , whr);\n    }\n}\n\nint main()\n{\n\n//freopen(\"test.in\" , \"r\" , stdin);\n//freopen(\"test.out\" , \"w\" , stdout);\n\nscanf(\"%d\" , &n);\n\nfor (i = 1 ; i <= n ; ++i)\nscanf(\"%d\" , &x[i]);\n\nsort(x + 1 , x + n + 1);\n\nfor (i = 1 ; i <= n ; ++i)\nfor (j = i + 1 ; j <= n ; ++j)\nif (1 < __gcd(x[i] , x[j]))\n{\n    g[i].push_back(j);\n    g[j].push_back(i);\n}\n\nfirst = 1 , last = 0;\nfor (i = 1 ; i <= n ; ++i)\n{\n    if (used[i]) continue;\n    ++last;\n    dfs(i);\n}\n\nwhile (first <= last)\n{\n    solve(first);\n    first++;\n}\n\nassert(n >= last);\n\nx[0] = -1000000000;\nfor (i = 1 ; i <= n ; ++i)\n{\n    int low = 0;\n    for (p = 1 ; p <= last ; ++p)\n    if (answer[p].size())\n    if (x[low] < x[answer[p].front()]) low = answer[p].front();\n\n    for (p = 1 ; p <= last ; ++p)\n    if (answer[p].size())\n    if (x[low] == x[answer[p].front()]) answer[p].pop();\n\n    printf(\"%d \" , x[low]);\n}\n\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*----------------by syr----------------*/\n/*\n  -----  -----  -----\n  |   |  |---|    _/\n  |   |  | \\_    /\n  -----  |   \\  -----\n\n  |---\\  \\   /  |\\  /|\n  |   |   \\_/   | \\/ |\n  |   |   / \\   |    |\n  |---/  /   \\  |    |\n*/\n#include<algorithm>\n#include<bitset>\n#include<cctype>\n#include<cstring>\n#include<cstdlib>\n#include<deque>\n#include<fstream>\n#include<functional>\n#include<iomanip>\n#include<iostream>\n#include<iterator>\n#include<limits>\n#include<list>\n#include<map>\n#include<math.h>\n#include<queue>\n#include<set>\n#include<stack>\n#include<stdio.h>\n#include<sstream>\n#include<string>\n#include<time.h>\n#include<utility>\n#include<vector>\n\n#define PH push\n#define MP make_pair\n#define PB push_back\n#define fst first\n#define snd second\n#define FOR(i,x,y) for(int i=(x);i<(y);++i)\n#define REP(i,x,y) for(int i=(x);i<=(y);++i)\n#define x0 x234567891\n#define y0 y234567891\n#define x2 x123456789\n#define y2 y123456789\n\nusing namespace std;\n\ntypedef double db;\ntypedef long long ll;\ntypedef long double ldb;\ntypedef pair<int,int> pii;\n\nconst int INF=1e9+7;\nconst int maxn=2005;\n\nint n,cnt;\nint a[maxn];\nbool vis[maxn];\nvector<int> b;\nvector<int> g[maxn],ng[maxn];\npriority_queue<pii> pq;\n\nvoid dfs(int u){\n\tvis[u]=1;\n\tFOR(i,0,g[u].size()){\n\t\tint v=g[u][i];\n\t\tif(vis[v]) continue;\n\t\tng[u].PB(v);\n\t\tdfs(v);\n\t\treturn;\n\t}\n\treturn;\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tFOR(i,0,n) scanf(\"%d\",a+i);\n\tsort(a,a+n);\n\tFOR(i,0,n){\n\t\tFOR(j,0,n){\n\t\t\tif(__gcd(a[i],a[j])!=1) g[i].PB(j);\n\t\t}\n\t}\n\tFOR(i,0,n) if(!vis[i]) dfs(i),pq.PH(MP(a[i],i));\n/*\tFOR(i,0,n){\n\t\tFOR(j,0,ng[i].size()) printf(\"%d \",ng[i][j]);\n\t\tputs(\"\");\n\t}\n*/\twhile(!pq.empty()){\n\t\tint u=pq.top().snd;\n\t\tb.PB(pq.top().fst);\n\t\tpq.pop();\n\t\tFOR(i,0,ng[u].size()) pq.PH(MP(a[ng[u][i]],ng[u][i]));\n\t}\n\tFOR(i,0,n) printf(\"%d \",b[i]);\n\tputs(\"\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint gcd(int a, int b){\n\treturn b == 0 ? a : gcd(b, a % b);\n}\n\nvector <int> combine(const vector <int> &a, const vector <int> &b){\n\tvector <int> res(a.size() + b.size());\n\tmerge(a.begin(), a.end(), b.begin(), b.end(), res.begin(), greater <int>());\n}\n\nint vis[2010];\nint n, e[2010][2010];\nint a[2010];\n\nvector <int> dfs(int x){\n\tvis[x] = 1;\n\tvector <int> res;\n\tfor (int v = 0; v < n; v++){\n\t\tif (vis[v] || !e[x][v]) continue;\n\t\tres = combine(res, dfs(v));\n\t}\n\treturn res;\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++){\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\tfor (int i = 0; i <= n; i++){\n\t\tfor (int j = 0; j <= n; j++){\n\t\t\te[i][j] = i != j && (i == n || j == n || gcd(a[i], a[j]) != 1);\n\t\t}\n\t}\n\tvector <int> res = dfs(n);\n\tfor (int i = 0; i < n; i++){\n\t\tprintf(\"%d \", res[i]);\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \nusing namespace std;\nint n = 0, num[2050];\nint gcd(int x, int y) { return y? gcd(y, x % y): x; }\nint dis[2050];\nbool abl[2050][2050], lin[2050][2050];\nbool vis[2050];\nint ans[2050], tot = 0;\nvoid dfs(int x)\n{\n\tvis[x] = true;\n\tfor(int i = 1; i <= n; i++)\n\t\tif(not vis[i] && abl[x][i])\n\t\t{\n\t\t\tlin[x][i] = true;\n\t\t\tdfs(i);\n\t\t}\n}\nsigned main()\n{\n\tscanf(\"%d\", &n);\n\tfor(int i = 1; i <= n; i++)\n\t\tscanf(\"%d\", num + i);\n\tsort(num + 1, num + n + 1);\n\tfor(int i = 1; i < n; i++)\n\t\tfor(int j = i + 1; j <= n; j++)\n\t\t\tif(gcd(num[i], num[j]) > 1)\n\t\t\t\tabl[i][j] = abl[j][i] = true;\n\tfor(int i = 1; i <= n; i++)\n\t\tif(not vis[i]) dfs(i);\n\tfor(int i = 1; i <= n; i++)\n\t\tfor(int j = 1; j <= n; j++)\n\t\t\tif(lin[i][j]) dis[j]++;\n\tpriority_queue<int> df;\n\tfor(int i = 1; i <= n; i++)\n\t\tif(dis[i] == 0) df.push(i);\n\twhile(not df.empty())\n\t{\n\t\tint x = df.top(); df.pop();\n\t\ttot++, ans[tot] = num[x];\n\t\tfor(int i = 1; i <= n; i++)\n\t\t\tif(lin[x][i])\n\t\t\t{\n\t\t\t\tdis[i]--;\n\t\t\t\tif(dis[i] == 0) df.push(i);\n\t\t\t}\n\t}\n\tfor(int i = 1; i <= n; i++)\n\t\tprintf(\"%d%c\", ans[i], \" \\n\"[i == n]);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "//Link : https://atcoder.jp/contests/code-festival-2017-qualb/tasks/code_festival_2017_qualb_d\n\n#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define N 2002\n\nint in[N],cc[N];\nint deg[N];\n\nint gcd(int x,int y) {\n  if(x==0) {\n    return y;\n  }\n  return gcd(y%x,x);\n}\nvector<int> adj[N];\nint vis[N];\n\nvector<int> merge(vector<int> a,vector<int> b) {\n  vector<int> ret;\n  int apos  =0,bpos = 0;\n  while(apos<a.size() && bpos< b.size()) {\n    if(a[apos]>b[bpos]) {\n      ret.push_back(a[apos++]);\n    } else {\n      ret.push_back(b[bpos++]);\n    }\n  }\n  while(apos<a.size() ) {\n    ret.push_back(a[apos++]);\n  }\n  while(bpos< b.size()) {\n    ret.push_back(b[bpos++]);\n  }\n  return ret;\n}\n\nint mini;\nvoid dfs(int node) {\n  vis[node] = 1;\n  mini = min(mini,node);\n  for(int ch : adj[node]) {\n    if(!vis[ch]) {\n      dfs(ch);\n    }\n  }\n}\n\nvector<int> dfs2(int node) {\n  vis[node] = 2;\n  vector<int> ret;\n  while(cc[node]>1) {\n      --cc[node];\n      ret.push_back(in[node]);\n  }\n  for(int ch : adj[node]) {\n    if(vis[ch]!=2) {\n      vector<int> tmp = dfs2(ch);\n      ret = merge(ret,tmp);\n    }\n  }\n  vector<int> out;\n  while(cc[node]>0) {\n    --cc[node];\n    out.push_back(in[node]);\n  }\n  for(int i=0;i<ret.size();++i) {\n    out.push_back(ret[i]);\n  }\n  return out;\n}\n\nvoid solve() {\n  int n;\n  scanf(\"%d \", &n);\n  for(int i=0;i<n;++i) {\n    scanf(\"%d\",&in[i]);\n  }\n  sort(in,in+n);\n  int pos=0;\n  for(int i=0;i<n;++i) {\n    cc[pos] = 1;\n    in[pos] = in[i];\n    ++pos;\n  }\n  int num = 0;\n  for(int i=0;i<pos;++i) {\n    for(int j=i+1;j<pos;++j) {\n      if(gcd(in[i],in[j])!=1) {\n        adj[i].push_back(j);\n        adj[j].push_back(i);\n      }\n    }\n  }\n  vector<int> ret;\n  for(int i=0;i<pos;++i) {\n    if(!vis[i]) {\n      mini = 1e9;\n      dfs(i);\n      vector<int> out = dfs2(mini);\n      ret = merge(ret,out);\n    }\n  }\n  assert(ret.size()==n);\n  for(int i=0;i<n;++i) {\n    printf(\"%d \", ret[i]);\n  }\n  putchar('\\n');\n}\n\nint main() {\n    //freopen(\"input.txt\",\"r\",stdin);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define mp make_pair\n#define pb push_back\n#define space putchar(' ')\n#define enter putchar('\\n')\n#define eps 1e-10\n#define MAXN 2005\n//#define ivorysi\nusing namespace std;\ntypedef long long int64;\ntypedef unsigned int u32;\ntypedef double db;\ntemplate<class T>\nvoid read(T &res) {\n    res = 0;T f = 1;char c = getchar();\n    while(c < '0' || c > '9') {\n    \tif(c == '-') f = -1;\n    \tc = getchar();\n    }\n    while(c >= '0' && c <= '9') {\n    \tres = res * 10 +c - '0';\n    \tc = getchar();\n    }\n    res *= f;\n}\ntemplate<class T>\nvoid out(T x) {\n    if(x < 0) {x = -x;putchar('-');}\n    if(x >= 10) {\n\tout(x / 10);\n    }\n    putchar('0' + x % 10);\n}\nstruct node {\n    int to,next;\n}E[MAXN * MAXN * 2];\nint head[MAXN],sumE,A[MAXN],N;\nint dfn[MAXN];\nbool vis[MAXN];\nvector<int> L;\nint gcd(int a,int b) {\n    return b == 0 ? a : gcd(b,a % b);\n}\nvoid add(int u,int v) {\n    E[++sumE].to = v;\n    E[sumE].next = head[u];\n    head[u] = sumE;\n}\nvector<int> Merge(vector<int> a,vector<int> b) {\n    vector<int> c;\n    int pa = 0,pb = 0;\n    while(pa < a.size() && pb < b.size()) {\n        if(a[pa] > b[pb]) c.pb(a[pa++]);\n        else c.pb(b[pb++]);\n    }\n    while(pa < a.size()) c.pb(a[pa++]);\n    while(pb < b.size()) c.pb(b[pb++]);\n    return c;\n}\nvector<int> Calc(int u) {\n    vector<int> son;\n    vis[u] = 1;\n    for(int i = head[u] ; i ; i = E[i].next) {\n        int v = E[i].to;\n        if(!vis[v]) son.pb(v);\n    }\n    sort(son.begin(),son.end());\n    vector<int> tmp;\n    for(auto t : son) dfn[t] = dfn[u] + 1;\n    for(auto t : son) {\n        if(!vis[t] && dfn[t] == dfn[u] + 1) {\n            tmp = Merge(tmp,Calc(t));\n        }\n    }\n    tmp.insert(tmp.begin(),A[u]);\n    return tmp;\n}\n\nvoid Solve() {\n    read(N);\n    for(int i = 1 ; i <= N ; ++i) read(A[i]);\n    sort(A + 1,A + N + 1);\n    for(int i = 1 ; i <= N ; ++i) {\n        for(int j = i + 1 ; j <= N ; ++j) {\n            if(gcd(A[i],A[j]) != 1) {\n                add(i,j);add(j,i);\n            }\n        }\n    }\n    for(int i = 1 ; i <= N ; ++i) {\n        if(dfn[i] == 0) {\n            L = Merge(Calc(i),L);\n        }\n    }\n    for(auto t : L) {\n        out(t);space;\n    }\n    enter;\n}\nint main() {\n#ifdef ivorysi\n    freopen(\"f1.in\",\"r\",stdin);\n#endif\n    Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n                                                                                                     \n                                             `-:://:::-                                             \n                                           `//:-------:/:`                                          \n                                          .+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .o:--...```..---+/`                                        \n                                       `/y+o/---....---:+o.                                         \n                                   `...````-os+/:---:/+o/--.`                                       \n              `-/+++++/:.      `...`       :h+d+oooo+/+-`   ...                                     \n            `/++//:::://++-`....`         -.`//````````:`     `..`                                  \n           `o+/::------://o/`           `-` -.          -`       `..`                               \n `---.-o/:./o/::-..``..-ЗАПУСКАЕМ      ..  ..            -`        `...       ``..``                \n  `....o+:-++/:--.```..-://s.        `-`  .-              -`          `-o: .-//::::/:-`             \n          `:s+/:--....-::/+s-`      .-   `-                -`           -///:--------:/:`           \n           ./s+//:::::://oo-``..НЕЙРОННУЮ: СЕТЬ:::::::-`РАБОТЯГИ        `+:--........--:/`          \n            .:ooo+++++osso-`    `.:-...`/` ./::-------:/:`   -`         :+--..``````.--:+:...-+:-`  \n             `.-/+++++/+-.-`    -.   ``:so:/:--.......--:+`  `-```````o+/+--..`````..--:o/-..:s+:.  \n                 ```````:``.. `-`     -` `+:--..`````..--/+-.../.`````..-o:--.......---/o.    `     \n                        `:  `:-      -.  .o:--..`` ``..--:o`   `-`      `:o+:--------:+o-`          \n                         `-`-...    ..   .o/--...```..--:+/`    `-`     `oy/so/////++o/.`           \n                          -/`  `-` `- ``+s/o/:---...---:++.      `-`   .-../d://///:-.`             \n                `.---..``-..-    .-/..`````-oo+/:::::/+o+-        `-``-`  `-.  ````                 \n             `:++++/+++++-  ..``.-/:`      /y-:/++o++/:.`..`       ./.   `-                         \n            -++/::::::://+/..:-``:` ..   `-.`  ```.```    `..`   `..`-` `-                          \n       ``  -o//:--....-::/++` -.-`   `-`.-`                 `..`..`  `-.-                           \n  -----ss+:++/:--.```..-://s.  /.     `::                    `-:.     ./`                           \n  `````/:..+o/::-..``.--:/+s. ..-`   `-``-`                 ..` `-`  `-`-`                          \n          `-s+/::-----::/+oo---``-` ..    .:-    ```      .-`     .-.-  `-`                         \n           `:oo+//::://+os/..:`..-/:`      :y.-:::::::.`.-`        ./-`  `-`                        \n            `./+oooooooo+/.`-    .-:...`.. .//:-------://`        `- `..` `:.                       \n              ``.-::::-.``-/`  `-` `-  `oo:+:--.......--:/`      `-    `.:--h.``..```               \n                          -.-`.-    .-   `+:--..`````..--//`    `-       /s-//::::::::.             \n                         -` `/-      ..  .o:--..`` ``..--:o.```.-        `//:--------://`           \n                        -` .-`.-`     -.`-o/--...```..--:+/.``-:....``:-.+:--....`...--:+`          \n                       ..`-.   `-.   ``:os:o/:---...---:++.  `-     ``///+:-..``````.--:+-````-.`   \n              `.:///////.-`      .:-..` -``-+o+/:::::/+o/.  `-         `:+:-..`````..--:o/:--/ys+-  \n            `-++///////+o/. ``....`-.    :` `.:++++++/:.`  .-           -o/---......---/o.   `.`    \n           `++//:-----::/+o:..`     .-`   :    ```````    .-           `+so+:--------:++-`          \n  `````:-``:o/::-..`..--:/+o`         -.  `-             .-          `../../+o+////+o+:.`           \n  -----syo/o+/:--.```..-://s.          .-` `-           .-        `...     ``-:////:-``             \n       .` `/s//:--....-::/+s.            -. `-`        .-       `..`                                \n           .+o+/:::--:://+s/-..`          .::+y  ```  .-     `..`                                   \n            ./oo++////+oso-`   `....       :y-+:::::::/`   ...                                      \n             `.:+oooooo/-`         `....-. .//:-------:/:-.`                                        \n                ``...``                 /+:+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .+/--...```..--:+/`                                        \n                                         `-o/:---...---:++.                                         \n                                          `-+o+/:---:/+o/.                                          \n                                            `.:+oooo+/-.`                                           \n                                               ``````                                               \n*/\n\n#ifdef aimbot\n#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#endif\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <set>\n#include <queue>\n#include <ostream>\n#include <istream>\n#include <typeinfo>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <limits>\n#include <fstream>\n#include <array>\n#include <list>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <cstring>\n#include <chrono>\n\n#define random escape__from__random__aetuhoetnuhshe\n#define mt make_tuple\n#define x first\n#define y second\n#define pb push_back\n#define ppb pop_back\n#define mp make_pair\n#define umap unordered_map\n#define uset unordered_set\n#define elif else if\n#define len(v) ((int)v.size())\n#define f(i, n) for (int i = 0; i < (n); i++)\n#define rof(i, n) for (int i = ((n) - 1); i >= 0; i--)\n#define apply(v, act) for (auto &x : v) { act; }\n#define log(args...) {string s = #args;deque<string> deq;\\\nstring buf = \"\";int bal = 0;for (char c : s) {\\\nif (c == '(' || c == '[' || c == '{') {bal++;\\\n} else if (c == ')' || c == ']' || c == '}') {\\\nbal--;} else {if (bal == 0) {if (c == ',') {\\\ndeq.pb(buf);buf = \"\";} else {if (c != ' ') {\\\nbuf += c;}}}}}if (!buf.empty()) {deq.pb(buf);}\\\nsmart_io::precall_print();smart_io::_print(deq, args);}\n\ninline int min(const int &x, const int &y) { return (((y-x)>>(32-1))&(x^y))^x; }\ninline int max(const int &x, const int &y) { return (((y-x)>>(32-1))&(x^y))^y; }\ninline long long min(const long long &x, const long long &y) { return (((y-x)>>(64-1))&(x^y))^x; }\ninline long long max(const long long &x, const long long &y) { return (((y-x)>>(64-1))&(x^y))^y; }\n\n#define print    \\\nsmart_io::precall_print(); \\\ncout,\n\n#define scan cin,\n\n#ifdef fast_allocator\nconst int MAXMEM = 200 * 1000 * 1024;\nchar _memory[MAXMEM];\nsize_t _ptr = 0;\nvoid* operator new(size_t _x) { _ptr += _x; assert(_ptr < MAXMEM); return _memory + _ptr - _x; }\nvoid operator delete (void*) noexcept {}\n#endif\n\nusing namespace std;\n\nchar string_in_buffer[(int)260];\n\n\nvoid fast_scan(int &x) { scanf(\"%d\", &x); }\nvoid fast_scan(long long &x) { scanf(\"%lld\", &x); }\nvoid fast_scan(unsigned long long &x) { scanf(\"%llu\", &x); }\nvoid fast_scan(double &x) { scanf(\"%lf\", &x); }\nvoid fast_scan(long double &x) { scanf(\"%Lf\", &x); }\nvoid fast_scan(char &x) {\n\tscanf(\"%c\", &x);\n\tif (x == '\\n') {\n\t\tfast_scan(x);\n\t}\n}\nvoid fast_scan(string &x) {\n\tscanf(\"%s\", string_in_buffer);\n\tx = string(string_in_buffer);\n}\n\ntemplate<class TFirst, class TSecond>\nvoid fast_scan(pair<TFirst, TSecond> &p) {\n\tfast_scan(p.first);\n\tfast_scan(p.second);\n}\n\ntemplate <class T>\nvoid fast_scan(vector<T> &v) {\n\tfor (auto &x : v) fast_scan(x);\n}\n\nvoid fast_print(const int &x) { printf(\"%d\", x); }\nvoid fast_print(const unsigned int &x) { printf(\"%u\", x); }\nvoid fast_print(const long long &x) { printf(\"%lld\", x); }\nvoid fast_print(const unsigned long long &x) { printf(\"%llu\", x); }\nvoid fast_print(const char &x) { printf(\"%c\", x); };\n// void fast_print(__int128 x) {\n// \tif (x == 0) { fast_print('0'); return; }\n// \tif (x < 0) {\n// \t\tfast_print('-');\n// \t\tx = -x;\n// \t}\n// \t__int128 p = 1;\n// \twhile (x / (p * 10)) p *= 10;\n// \twhile (p) {\n// \t\t__int128 symb = x / p;\n// \t\tfast_print((int)symb);\n// \t\tx -= p * symb;\n// \t\tp /= 10;\n// \t}\n// };\nvoid fast_print(const double &x) { printf(\"%.15lf\", x); }\nvoid fast_print(const long double &x) { printf(\"%.15Lf\", x); }\nvoid fast_print(const string &x) { printf(\"%s\", x.c_str());}\nvoid fast_print(const char v[]) { fast_print((string)v); }\n\ntemplate<class TFirst, class TSecond>\nvoid fast_print(const pair<TFirst, TSecond> &p) {\n\tfast_print(p.first);\n\tfast_print(' ');\n\tfast_print(p.second);\n}\n\ntemplate <class T>\nvoid fast_print(const vector<T> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print(' ');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const vector<vector<T>> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print('\\n');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const T &v) {\n\tfor (const auto &x : v) {\n\t\tfast_print(x);\n\t\tfast_print(' ');\n\t}\n}\n\n\nusing namespace std;\n\n\nnamespace smart_io {\n\tstring print_start = \"\";\n\tstring sep = \" \";\n\tbool first_print = false;\n\t\n\tvoid precall_print() {\n\t\tfast_print(print_start);\n\t\tprint_start = \"\\n\";\n\t\tfirst_print = true;\n\t}\n\t\n\tvoid _print(deque<string>) {}\n\ttemplate<class T, class... Args>\n\tvoid _print(deque<string> names, T elem, Args... args) {\n\t\tif (!first_print) {\n\t\t\tfast_print(\"\\n\");\n\t\t} else {\n\t\t\tfirst_print = false;\n\t\t}\n\t\tfast_print(names.front());\n\t\tfast_print(\" = \");\n\t\tfast_print(elem);\n\t\tnames.pop_front();\n\t\t_print(names, args...);\n\t}\n} //namespace smart_io\n\n\ntemplate <class T>\nostream &operator,(ostream &os, const T &object) {\n\tif (!smart_io::first_print) {\n\t\tfast_print(smart_io::sep);\n\t} else {\n\t\tsmart_io::first_print = false;\n\t}\n\tfast_print(object);\n\treturn os;\n}\n\ntemplate <class T>\nistream &operator,(istream &is, T &object) {\n\tfast_scan(object);\n\treturn is;\n}\n\nnamespace random {\n\tusing namespace std::chrono;\n\tmt19937 rng(duration_cast< milliseconds >(\n\t\t\t\t\t\t\t\t\t\t\t  system_clock::now().time_since_epoch()\n\t\t\t\t\t\t\t\t\t\t\t  ).count());\n\tuniform_real_distribution<> prob_dist(0.0, 1.0);\n};\n\nnamespace typedefs {\n\ttypedef long long ll;\n\ttypedef unsigned long long ull;\n\ttypedef pair<int, int> pii;\n\ttypedef long double ld;\n}\n\nnamespace numbers_operation {\n\ttemplate<class T>\n\tinline T floor_mod(T a, const T &b) {\n\t\ta %= b;\t\n\t\tif (a < 0) a += b;\n\t\treturn a;\n\t}\n}\n\nusing namespace numbers_operation;\nusing namespace typedefs;\nusing namespace random;\n\nint n;\nvector<int> v;\nvector<vector<int>> factors;\n\nvoid factorize(int n, vector<int> &rez) {\n\tfor (int i = 2; i * i <= n; i++) {\n\t\twhile (n % i == 0) {\n\t\t\tn /= i;\n\t\t\trez.pb(i);\n\t\t}\n\t}\n\tif (n > 1) rez.pb(n);\n\tsort(rez.begin(), rez.end());\n\trez.resize(unique(rez.begin(), rez.end()) - rez.begin());\n}\n\nint gcd(int a, int b) {\n\treturn __gcd((unsigned int)a, (unsigned int)b);\n}\n\nbool can_add(vector<int> p, int x) {\n\tvector<int> q = p;\n\tp.pb(x);\n\tfor (int i = len(p) - 1; i > 0; i--) {\n\t\tif (gcd(p[i], p[i - 1]) == 1) swap(p[i], p[i - 1]);\n\t\telse break;\n\t\tif (q < p) return false;\n\t}\n\treturn true;\n}\n\nstruct SUS {\n\tvector<int> up;\n\tint get_root(int i) {\n\t\tif (up[i] == i) return i;\n\t\treturn up[i] = get_root(up[i]);\n\t}\n\tSUS(int n) {\n\t\tup.resize(n);\n\t\tf(i, n) up[i] = i;\n\t}\n\tvoid merge(int a, int b) {\n\t\tup[get_root(a)] = get_root(b);\n\t}\n\tbool one_comp(int a, int b) {\n\t\treturn get_root(a) == get_root(b);\n\t}\n};\n\nsigned main(signed argc, char *argv[]) {\n\tscan n;\n\tfactors.resize(n);\n\tv.resize(n);\n\tmap<int, int> cnt;\n\tvector<int> remain;\n\tfor (int i = 0; i < n; i++) {\n\t\tint x;\n\t\tscan x;\n\t\tcnt[x]++;\n\t\tfactorize(x, factors[i]);\n\t\tv[i] = x;\n\t\tif (x > 1 && cnt[x] == 1) {\n\t\t\tremain.pb(i);\n\t\t}\n\t}\n\tsort(remain.begin(), remain.end(), [](int i, int j) {\n\t\treturn v[i] < v[j];\n\t});\n\tvector<int> rez;\n\twhile (!remain.empty()) {\n\t\tint next = -1;\n\t\tSUS sus(len(remain));\n\t\tmap<int, vector<int>> at;\n\t\tfor (int i = 0; i < len(remain); i++) {\n\t\t\tfor (int x : factors[remain[i]]) {\n\t\t\t\tat[x].pb(i);\n\t\t\t}\n\t\t}\n\t\tfor (auto p : at) {\n\t\t\tfor (int j = 0; j < len(p.y) - 1; j++) {\n\t\t\t\tsus.merge(p.y[j], p.y[j + 1]);\n\t\t\t}\n\t\t}\n\t\tfor (int i = len(remain) - 1; ~i; i--) {\n\t\t\tif (sus.get_root(i) != sus.get_root(len(remain) - 1)) break;\n\t\t\tif (!can_add(rez, v[remain[i]])) continue;\n\t\t\tnext = i;\n\t\t}\n\t\tassert(next != -1);\n\t\trez.pb(v[remain[next]]);\n\t\tremain.erase(remain.begin() + next);\n\t}\n\tvector<int> final;\n\trez.pb(1);\n\tfor (int x : rez) {\n\t\tf(k, cnt[x]) {\n\t\t\tfinal.pb(x);\n\t\t}\n\t}\n\tprint final;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\",\"inline\",\"-ffast-math\")\n#pragma GCC target(\"avx,sse2,sse3,sse4,mmx\")\n#include <bits/stdc++.h>\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/hash_policy.hpp>\nusing namespace __gnu_pbds;\nusing namespace std;\n\nint n,a[2010];\nvector<int> v[2010];\nbool vis[2010][2010],c[2010][2010],used[2010];\nvector<int> dp[2010];\n\ninline int gcd(int a,int b)\n{\n\tif(b==0) return a;\n\treturn gcd(b,a%b);\n}\n\ninline void dfs2(int u,int x,vector<int>&res)\n{\n\tres.push_back(x);\n\tfor(int i=0;i<v[x].size();i++) if(!used[v[x][i]]&&!vis[u][v[x][i]]){\n\t\tvis[u][v[x][i]]=1;\n\t\tdfs2(u,v[x][i],res);\n\t}\n}\n\ninline void dfs(int x)\n{\n\tused[x]=1;\n\tvector<vector<int> > w;\n\tvector<int> res;\n\tfor(int i=0;i<v[x].size();i++) if(!used[v[x][i]]&&!vis[x][v[x][i]]){\n\t\tvis[x][v[x][i]]=1;res.clear();dfs2(x,v[x][i],res);\n\t\tsort(res.begin(),res.end());\n\t\tfor(int j=0;j<res.size();j++) if(c[x][res[j]]){\n\t\t\tdfs(res[j]);\n\t\t\tw.push_back(dp[res[j]]);\n\t\t\tbreak;\n\t\t}\n\t}\n\tsort(w.begin(),w.end());\n\tdp[x].push_back(x);\n\tfor(int i=w.size()-1;i>=0;i--) for(int j=0;j<w[i].size();j++) dp[x].push_back(w[i][j]);\n}\n\nsigned main()\n{\n\tios::sync_with_stdio(false);\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=i+1;j<=n;j++){\n\t\t\tif(gcd(a[i],a[j])>1){\n\t\t\t\tv[i].push_back(j);\n\t\t\t\tv[j].push_back(i);\n\t\t\t\tc[i][j]=1;c[j][i]=1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tv[0].push_back(i);v[i].push_back(0);c[0][i]=1;c[i][0]=1;\n\t}\n\tdfs(0);\n\tfor(int i=1;i<dp[0].size();i++) cout<<a[dp[0][i]]<<\" \";\n\tcout<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,i,j,a[2005],book[2005][2005];\nint max1,ans[2005],flag[2005],du[2005];\nint vis[2005],top,nex[4000005],to[4000005],fir[2005];\nint lj(int u,int v){\n\ttop++;\n\tnex[top]=fir[u];\n\tfir[u]=top;\n\tto[top]=v;\n\treturn 0;\n}\nint ss(int v){\n\tvis[v]=1;\n\tfor(int top1=fir[v];top1;top1=nex[top1])\n\t\tif(vis[to[top1]]==0){\n\t\t\tbook[v][to[top1]]=1;\n\t\t\tdu[to[top1]]++;\n\t\t\tss(to[top1]);\n\t\t}\n\treturn 0;\n}\nint read(){\n\tint xx=0,flag=1;\n\tchar ch=getchar();\n\twhile((ch<'0'||ch>'9')&&ch!='-')\n\t\tch=getchar();\n\tif(ch=='-'){\n\t\tflag=-1;\n\t\tch=getchar();\n\t}\n\twhile(ch>='0'&&ch<='9'){\n\t\txx=xx*10+ch-'0';\n\t\tch=getchar();\n\t}\n\treturn flag*xx;\n}\nint gcd(int u,int v){\n\tif(v==0) return u;\n\treturn gcd(v,u%v);\n}\nint main(){\n\tn=read();\n\tfor(i=1;i<=n;i++)\n\t\ta[i]=read();\n\tsort(a+1,a+n+1);\n\tfor(i=n;i>=1;i--)\n\t\tfor(j=n;j>=i+1;j--)\n\t\t\tif(gcd(a[i],a[j])!=1){\n\t\t\t\tlj(i,j);\n\t\t\t\tlj(j,i);\n\t\t\t}\n\tfor(i=1;i<=n;i++)\n\t\tif(vis[i]==0)\n\t\t\tss(i);\n\tfor(i=1;i<=n;i++){\n\t\tmax1=0;\n\t\tfor(j=1;j<=n;j++)\n\t\t\tif(flag[j]==0&&du[j]==0)\n\t\t\t\tmax1=j;\n\t\tfor(j=1;j<=n;j++)\n\t\t\tif(book[max1][j]==1)\n\t\t\t\tdu[j]--;\n\t\tans[i]=a[max1];\n\t\tflag[max1]=1;\n\t} \n\tfor(i=1;i<=n;i++)\n\t\tprintf(\"%d \",ans[i]);\n\tcout<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio> \n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<map>\nusing namespace std;\n#define fo(i,j,k) for(i=j;i<=k;i++)\n#define fd(i,j,k) for(i=j;i>=k;i--)\n#define cmax(a,b) (a=(a>b)?a:b)\n#define cmin(a,b) (a=(a<b)?a:b)\ntypedef long long ll;\ntypedef double db;\nconst int N=2e5+5;\nint b[N],nxt[N],fst[N],tt,pd[N],vis[N],du[N],n,a[N],i,j;\nvoid cr(int x,int y)\n{\n\ttt++;\n\tdu[y]++;\n\tb[tt]=y;\n\tnxt[tt]=fst[x];\n\tfst[x]=tt;\n}\nint gcd(int a,int b)\n{\n\tif (!b) return a;\n\treturn gcd(b,a%b);\n}\nvoid dfs(int x)\n{\n\tpd[x]=1;\n\tint i;\n\tfo(i,1,n)\n\tif (!pd[i]&&gcd(a[i],a[x])>1)\n\t{\n\t\tcr(x,i);\n\t\tdfs(i);\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfo(i,1,n) scanf(\"%d\",a+i);\n\tsort(a+1,a+1+n);\n\tfo(i,1,n) if (!pd[i])\n\t\tdfs(i);\n\tfo(i,1,n)\n\t{\n\t\tfd(j,n,1)\n\t\tif (!du[j]&&!vis[j])\n\t\t{\n\t\t\tprintf(\"%d \",a[j]);\n\t\t\tvis[j]=1;\n\t\t\tfor(int p=fst[j];p;p=nxt[p]) du[b[p]]--;\n\t\t\tbreak;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O2\")\n#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\ntypedef long long ll;\n#define N 10005\nvector<int>v[N];\nint n,a[N];\npriority_queue<int>q;\nbool vv[2002][2002],vis[N],vvv[N];\nvoid dfs(int x)\n{\n\tvis[x]=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(!vis[i]&&vv[x][i])\n\t\t{\n\t\t\tv[x].push_back(i);\n\t\t\tvvv[i]=1;\n\t\t\tdfs(i);\n\t\t}\n\t}\n}\nint main()\n{\n\t//freopen(\"rearranging.in\",\"r\",stdin);\n\t//freopen(\"rearranging.out\",\"w\",stdout);\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n\tsort(a+1,a+1+n);\n\tfor(int i=1;i<=n;i++)\n\tfor(int j=1;j<=n;j++)\n\t{\n\t\tif(__gcd(a[i],a[j])!=1)\n\t\t{\n\t\t\tvv[i][j]=vv[j][i]=1;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)\n\tif(!vis[i])dfs(i);\n\tfor(int i=1;i<=n;i++)if(!vvv[i])q.push(i);\n\twhile(!q.empty())\n\t{\n\t\tint a1=q.top();\n\t\tprintf(\"%d \",a[a1]);\n\t\tq.pop();\n\t\tfor(int i=0;i<v[a1].size();i++)\n\t\t{\n\t\t\tint j=v[a1][i];\n\t\t\tq.push(j);\n\t\t}\n\t}\n\tputs(\"\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\nusing namespace std;\nint a[100005];\nint main()\n{\n\tint n,i,j;\n\tcin>>n;\n\tfor (i=1;i<=n;i++)\n\tscanf(\"%d\",&a[i]);\n\tsort(a+1,a+n+1);\n\tfor (i=1;i<=n;i++)\n\tprintf(\"%d \",a[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define LL long long\n#define RG register\n\nusing namespace std;\ntemplate<class T> T gi() {\n\tT x = 0; bool f = 0; char c = getchar();\n\twhile (c != '-' && (c < '0' || c > '9')) c = getchar();\n\tif (c == '-') f = 1, c = getchar();\n\twhile (c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n\treturn f ? -x : x;\n}\nconst int N = 2010;\nint a[N], d[N], e[N][N], n;\nbool vis[N];\nvector<int> vec[N];\nvoid dfs(int u) {\n\tvis[u] = 1;\n\tfor (int i = 1; i <= n; i++)\n\t\tif (e[u][i] && !vis[i]) {\n\t\t\td[i]++; vec[u].push_back(i); dfs(i);\n\t\t}\n}\nstruct cmp {\n\tbool operator () (int x, int y) const {\n\t\treturn a[x] < a[y];\n\t}\n};\npriority_queue<int, vector<int>, cmp> q;\nint main() {\n\t//freopen(\".in\", \"r\", stdin);\n\t//freopen(\".out\", \"w\", stdout);\n\tn = gi<int>();\n\tfor (int i = 1; i <= n; i++) a[i] = gi<int>();\n\tsort(a + 1, a + 1 + n);\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = i + 1; j <= n; j++)\n\t\t\tif (__gcd(a[i], a[j]) > 1)\n\t\t\t\te[i][j] = e[j][i] = 1;\n\tfor (int i = 1; i <= n; i++)\n\t\tif (!vis[i]) dfs(i);\n\tfor (int i = 1; i <= n; i++)\n\t\tif (!d[i]) q.push(i);\n\twhile (!q.empty()) {\n\t\tint u = q.top(); q.pop();\n\t\tprintf(\"%d \", a[u]);\n\t\tfor (int i = 0; i < (int) vec[u].size(); i++)\n\t\t\tq.push(vec[u][i]);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#define MAXN 2000\nusing namespace std;\npriority_queue<int> que;\nvector<int> G[MAXN+5];\nvector<int> ans;\nint n,a[MAXN+5],d[MAXN+5];\nint M[MAXN+5][MAXN+5];\nbool vis[MAXN+5];\nint gcd(int x,int y)\n{\n\tif(y==0)\n\t\treturn x;\n\treturn gcd(y,x%y);\n}\nvoid DFS(int u)\n{\n\tvis[u]=true;\n\tfor(int v=1;v<=n;v++)\n\t\tif(vis[v]==false&&M[u][v])\n\t\t{\n\t\t\td[v]++;\n\t\t\tG[u].push_back(v);\n\t\t\tDFS(v);\n\t\t}\n}\nint main()\n{\n//\tfreopen(\"newgame.in\",\"r\",stdin);\n//\tfreopen(\"newgame.out\",\"w\",stdout);\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tsort(a+1,a+1+n);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\tif(gcd(a[i],a[j])!=1)\n\t\t\t\tM[i][j]=M[j][i]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tif(vis[i]==false)\n\t\t\tDFS(i);\n\tfor(int i=1;i<=n;i++)\n\t\tif(d[i]==0)\n\t\t\tvis[i]=true,que.push(i);\n\tmemset(vis,0,sizeof(vis));\n\twhile(que.empty()==false)\n\t{\n\t\tint u=que.top();\n\t\tque.pop();\n\t\tans.push_back(u);\n\t\tfor(int i=0;i<(int)G[u].size();i++)\n\t\t{\n\t\t\tint v=G[u][i];\n\t\t\tif(vis[v]==false)\n\t\t\t{\n\t\t\t\tvis[v]=true;\n\t\t\t\tque.push(v);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<(int)ans.size();i++)\n\t\tif(i==0)\n\t\t\tprintf(\"%d\",a[ans[i]]);\n\t\telse\n\t\t\tprintf(\" %d\",a[ans[i]]);\n\tprintf(\"\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pb push_back\n#define all(x) x.begin(), x.end()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nconst int N = 2000 + 10;\nconst int MOD = 1000000007;\nconst int LOG = 20;\nconst int INF = 1000000010;\nconst int delta = 11353;\n\nint n;\nvi G[N], a;\nmap<int, int> mp;\nint mark[N];\nint mark2[N];\n\nvoid DFS(int v){\n\tmark[v] = 1;\n\tfor (auto u:G[v]){\n\t\tif ((mark[u] == 0) && (mark2[u] == 0)){\n\t\t\tDFS(u);\n\t\t}\n\t}\n}\nint GCD(int x, int y){\n\tif (x == 0 || y == 0) return (x + y);\n\tif (x == 1 || y == 1) return 1;\n\tif (x < y) swap(x, y);\n\treturn GCD(y, x % y);\n}\n\nint32_t main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++){\n\t\tint x;\n\t\tcin >> x;\n\t\tmp[x] ++;\n\t\ta.pb(x);\n\t}\n\tsort(all(a));\n\ta.resize(unique(all(a)) - a.begin());\n\tfor (int i = 0; i < a.size(); i++) for (int j = 0; j < i; j++) if (GCD(a[i], a[j]) != 1){\n\t\tG[i].pb(j), G[j].pb(i);\n\t}\n\t//cout << GCD(7, 11) << '\\n';\n\tvi ans;\n\tint last = 0;\n\tfor (int i = 0; i < a.size(); i++){\n\t\tint ki;\n\t\tmemset(mark, 0, sizeof mark);\n\t\tif (i == 0){\n\t\t\tint mx = 0;\n\t\t\tfor (int j = 0; j < a.size(); j++) if (!mark[j]) mx = j, DFS(j);\n\t\t\tmark2[mx] = 1;\n\t\t\tans.pb(a[mx]);\n\t\t\t//cout << a[mx] << endl;\n\t\t\tlast = mx;\n\t\t}else{\n\t\t\tsort(all(G[last]));\n\t\t\tint mx = 0;\n\t\t\tfor (auto u:G[last]){\n\t\t\t\tif ((mark2[u] == 0) && (mark[u] == 0)) mx = u, DFS(u);\n\t\t\t}\n\t\t\tfor (int j = 0;  j < a.size(); j++){\n\t\t\t\tif ((mark[j] == 0) && (mark2[j] == 0)) mx = max(j, mx), DFS(j);\n\t\t\t}\n\t\t\tmark2[mx] = 1;\n\t\t\tans.pb(a[mx]);\n\t\t\tlast = mx;\n\t\t\t//cout << a[mx] << endl;\n\t\t}\n\t}\n\tfor (auto u:ans){\n\t\tfor (int i = 0; i < mp[u]; i++) cout << u << ' ';\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,x,y) for (int i=(x);i<=(y);i++)\n#define Vi vector<int>\n#define pii pair<int,int>\n\nusing namespace std;\n\nconst int N=2010;\nint n,a[N],cnt,head[N],st[N],tot,vis[N]; Vi G[N],V[N];\n\nconst bool cmp(int x,int y){return a[x]<a[y];}\n\nvoid dfs(int u){\n\tvis[u]=1,V[tot].push_back(u);\n\tfor (auto v:G[u]) if (!vis[v]) dfs(v);\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\trep (i,1,n) scanf(\"%d\",&a[i]);\n\trep (i,1,n) rep (j,1,n) if (i!=j&&__gcd(a[i],a[j])!=1) G[i].push_back(j);\n\trep (i,1,n) sort(G[i].begin(),G[i].end(),cmp);\n\trep (i,1,n) if (!vis[i]) ++tot,dfs(i);\n\tpriority_queue<pii> q;\n\trep (i,1,tot) q.push(pii(V[i][0],i));\n\twhile (!q.empty()){\n\t\tint x,y; tie(x,y)=q.top(); q.pop();\n\t\tprintf(\"%d \",a[x]);\n\t\tst[y]++;\n\t\tif (st[y]<V[y].size()) q.push(pii(V[y][st[y]],y));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n#define N 2010\n#define chmax(a,b) a=max(a,b);\nvector<ll> g[N];\nll a[N],n;\nvector<ll> t[N];\nll nz[N];\nll gcd(ll a,ll b){\n    if(a<b)swap(a,b);\n    if(b==0)return a;\n    a%=b;\n    return gcd(a,b);\n}\n\nvoid Solve(){\n for(int i=0;i<n;i++)nz[i]=0;\n for(int i=0;i<n;i++){\n  for(auto x:t[i])nz[x]++;   \n }\n priority_queue<ll> Q;\n vector<ll> ans;\n for(int i=0;i<n;i++){\n     if(nz[i]==0)Q.push(i);\n }\n while(!Q.empty()){\n  ll x=Q.top();\n  Q.pop();\n  ans.push_back(a[x]);\n  for(auto y:t[x]){\n   nz[y]--;\n   if(nz[y]==0)Q.push(y);\n  }\n }\n for(int i=0;i<n;i++){\n  if(i)cout<<\" \";\n  cout<<ans[i];\n }cout<<endl;\n}\n\nbool vis[N];\nll maxfrom[N];\npriority_queue<ll,vector<ll>,greater<ll> >Q;\nvoid bfs(ll x){\n    if(vis[x])return; vis[x]=1;\n    //cout<<x<<\" \"<<maxfrom[x]<<endl;\n    if(~maxfrom[x])t[maxfrom[x]].push_back(x);\n    for(auto y:g[x]){\n        chmax(maxfrom[y],x);\n        Q.push(y);\n    }\n}\nvoid MakeT(ll s){\n while(!Q.empty())Q.pop();\n Q.push(s);\n while(!Q.empty()){\n  ll x=Q.top();\n  Q.pop();\n  bfs(x);\n }\n}\nint main(){\n cin>>n;\n for(int i=0;i<n;i++)cin>>a[i];\n sort(a,a+n);\n for(int i=0;i<n;i++)nz[i]=0;\n for(int i=0;i<n;i++){\n  for(int j=0;j<i;j++){\n   if(gcd(a[i],a[j])>1){\n       g[i].push_back(j);\n       g[j].push_back(i);\n   }\n  }\n }\n for(int i=0;i<n;i++)vis[i]=0,maxfrom[i]=-1;\n for(int i=0;i<n;i++){\n  if(vis[i])continue;\n  MakeT(i);\n }\n Solve();\n return 0;   \n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n                                                                                                     \n                                             `-:://:::-                                             \n                                           `//:-------:/:`                                          \n                                          .+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .o:--...```..---+/`                                        \n                                       `/y+o/---....---:+o.                                         \n                                   `...````-os+/:---:/+o/--.`                                       \n              `-/+++++/:.      `...`       :h+d+oooo+/+-`   ...                                     \n            `/++//:::://++-`....`         -.`//````````:`     `..`                                  \n           `o+/::------://o/`           `-` -.          -`       `..`                               \n `---.-o/:./o/::-..``..-ЗАПУСКАЕМ      ..  ..            -`        `...       ``..``                \n  `....o+:-++/:--.```..-://s.        `-`  .-              -`          `-o: .-//::::/:-`             \n          `:s+/:--....-::/+s-`      .-   `-                -`           -///:--------:/:`           \n           ./s+//:::::://oo-``..НЕЙРОННУЮ: СЕТЬ:::::::-`РАБОТЯГИ        `+:--........--:/`          \n            .:ooo+++++osso-`    `.:-...`/` ./::-------:/:`   -`         :+--..``````.--:+:...-+:-`  \n             `.-/+++++/+-.-`    -.   ``:so:/:--.......--:+`  `-```````o+/+--..`````..--:o/-..:s+:.  \n                 ```````:``.. `-`     -` `+:--..`````..--/+-.../.`````..-o:--.......---/o.    `     \n                        `:  `:-      -.  .o:--..`` ``..--:o`   `-`      `:o+:--------:+o-`          \n                         `-`-...    ..   .o/--...```..--:+/`    `-`     `oy/so/////++o/.`           \n                          -/`  `-` `- ``+s/o/:---...---:++.      `-`   .-../d://///:-.`             \n                `.---..``-..-    .-/..`````-oo+/:::::/+o+-        `-``-`  `-.  ````                 \n             `:++++/+++++-  ..``.-/:`      /y-:/++o++/:.`..`       ./.   `-                         \n            -++/::::::://+/..:-``:` ..   `-.`  ```.```    `..`   `..`-` `-                          \n       ``  -o//:--....-::/++` -.-`   `-`.-`                 `..`..`  `-.-                           \n  -----ss+:++/:--.```..-://s.  /.     `::                    `-:.     ./`                           \n  `````/:..+o/::-..``.--:/+s. ..-`   `-``-`                 ..` `-`  `-`-`                          \n          `-s+/::-----::/+oo---``-` ..    .:-    ```      .-`     .-.-  `-`                         \n           `:oo+//::://+os/..:`..-/:`      :y.-:::::::.`.-`        ./-`  `-`                        \n            `./+oooooooo+/.`-    .-:...`.. .//:-------://`        `- `..` `:.                       \n              ``.-::::-.``-/`  `-` `-  `oo:+:--.......--:/`      `-    `.:--h.``..```               \n                          -.-`.-    .-   `+:--..`````..--//`    `-       /s-//::::::::.             \n                         -` `/-      ..  .o:--..`` ``..--:o.```.-        `//:--------://`           \n                        -` .-`.-`     -.`-o/--...```..--:+/.``-:....``:-.+:--....`...--:+`          \n                       ..`-.   `-.   ``:os:o/:---...---:++.  `-     ``///+:-..``````.--:+-````-.`   \n              `.:///////.-`      .:-..` -``-+o+/:::::/+o/.  `-         `:+:-..`````..--:o/:--/ys+-  \n            `-++///////+o/. ``....`-.    :` `.:++++++/:.`  .-           -o/---......---/o.   `.`    \n           `++//:-----::/+o:..`     .-`   :    ```````    .-           `+so+:--------:++-`          \n  `````:-``:o/::-..`..--:/+o`         -.  `-             .-          `../../+o+////+o+:.`           \n  -----syo/o+/:--.```..-://s.          .-` `-           .-        `...     ``-:////:-``             \n       .` `/s//:--....-::/+s.            -. `-`        .-       `..`                                \n           .+o+/:::--:://+s/-..`          .::+y  ```  .-     `..`                                   \n            ./oo++////+oso-`   `....       :y-+:::::::/`   ...                                      \n             `.:+oooooo/-`         `....-. .//:-------:/:-.`                                        \n                ``...``                 /+:+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .+/--...```..--:+/`                                        \n                                         `-o/:---...---:++.                                         \n                                          `-+o+/:---:/+o/.                                          \n                                            `.:+oooo+/-.`                                           \n                                               ``````                                               \n*/\n\n#ifdef aimbot\n#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#endif\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <set>\n#include <queue>\n#include <ostream>\n#include <istream>\n#include <typeinfo>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <limits>\n#include <fstream>\n#include <array>\n#include <list>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <cstring>\n#include <chrono>\n\n#define random escape__from__random__aetuhoetnuhshe\n#define mt make_tuple\n#define x first\n#define y second\n#define pb push_back\n#define ppb pop_back\n#define mp make_pair\n#define umap unordered_map\n#define uset unordered_set\n#define elif else if\n#define len(v) ((int)v.size())\n#define f(i, n) for (int i = 0; i < (n); i++)\n#define rof(i, n) for (int i = ((n) - 1); i >= 0; i--)\n#define apply(v, act) for (auto &x : v) { act; }\n#define log(args...) {string s = #args;deque<string> deq;\\\nstring buf = \"\";int bal = 0;for (char c : s) {\\\nif (c == '(' || c == '[' || c == '{') {bal++;\\\n} else if (c == ')' || c == ']' || c == '}') {\\\nbal--;} else {if (bal == 0) {if (c == ',') {\\\ndeq.pb(buf);buf = \"\";} else {if (c != ' ') {\\\nbuf += c;}}}}}if (!buf.empty()) {deq.pb(buf);}\\\nsmart_io::precall_print();smart_io::_print(deq, args);}\n\ninline int min(const int &x, const int &y) { return (((y-x)>>(32-1))&(x^y))^x; }\ninline int max(const int &x, const int &y) { return (((y-x)>>(32-1))&(x^y))^y; }\ninline long long min(const long long &x, const long long &y) { return (((y-x)>>(64-1))&(x^y))^x; }\ninline long long max(const long long &x, const long long &y) { return (((y-x)>>(64-1))&(x^y))^y; }\n\n#define print    \\\nsmart_io::precall_print(); \\\ncout,\n\n#define scan cin,\n\n#ifdef fast_allocator\nconst int MAXMEM = 200 * 1000 * 1024;\nchar _memory[MAXMEM];\nsize_t _ptr = 0;\nvoid* operator new(size_t _x) { _ptr += _x; assert(_ptr < MAXMEM); return _memory + _ptr - _x; }\nvoid operator delete (void*) noexcept {}\n#endif\n\nusing namespace std;\n\nchar string_in_buffer[(int)260];\n\n\nvoid fast_scan(int &x) { scanf(\"%d\", &x); }\nvoid fast_scan(long long &x) { scanf(\"%lld\", &x); }\nvoid fast_scan(unsigned long long &x) { scanf(\"%llu\", &x); }\nvoid fast_scan(double &x) { scanf(\"%lf\", &x); }\nvoid fast_scan(long double &x) { scanf(\"%Lf\", &x); }\nvoid fast_scan(char &x) {\n\tscanf(\"%c\", &x);\n\tif (x == '\\n') {\n\t\tfast_scan(x);\n\t}\n}\nvoid fast_scan(string &x) {\n\tscanf(\"%s\", string_in_buffer);\n\tx = string(string_in_buffer);\n}\n\ntemplate<class TFirst, class TSecond>\nvoid fast_scan(pair<TFirst, TSecond> &p) {\n\tfast_scan(p.first);\n\tfast_scan(p.second);\n}\n\ntemplate <class T>\nvoid fast_scan(vector<T> &v) {\n\tfor (auto &x : v) fast_scan(x);\n}\n\nvoid fast_print(const int &x) { printf(\"%d\", x); }\nvoid fast_print(const unsigned int &x) { printf(\"%u\", x); }\nvoid fast_print(const long long &x) { printf(\"%lld\", x); }\nvoid fast_print(const unsigned long long &x) { printf(\"%llu\", x); }\nvoid fast_print(const char &x) { printf(\"%c\", x); };\n// void fast_print(__int128 x) {\n// \tif (x == 0) { fast_print('0'); return; }\n// \tif (x < 0) {\n// \t\tfast_print('-');\n// \t\tx = -x;\n// \t}\n// \t__int128 p = 1;\n// \twhile (x / (p * 10)) p *= 10;\n// \twhile (p) {\n// \t\t__int128 symb = x / p;\n// \t\tfast_print((int)symb);\n// \t\tx -= p * symb;\n// \t\tp /= 10;\n// \t}\n// };\nvoid fast_print(const double &x) { printf(\"%.15lf\", x); }\nvoid fast_print(const long double &x) { printf(\"%.15Lf\", x); }\nvoid fast_print(const string &x) { printf(\"%s\", x.c_str());}\nvoid fast_print(const char v[]) { fast_print((string)v); }\n\ntemplate<class TFirst, class TSecond>\nvoid fast_print(const pair<TFirst, TSecond> &p) {\n\tfast_print(p.first);\n\tfast_print(' ');\n\tfast_print(p.second);\n}\n\ntemplate <class T>\nvoid fast_print(const vector<T> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print(' ');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const vector<vector<T>> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print('\\n');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const T &v) {\n\tfor (const auto &x : v) {\n\t\tfast_print(x);\n\t\tfast_print(' ');\n\t}\n}\n\n\nusing namespace std;\n\n\nnamespace smart_io {\n\tstring print_start = \"\";\n\tstring sep = \" \";\n\tbool first_print = false;\n\t\n\tvoid precall_print() {\n\t\tfast_print(print_start);\n\t\tprint_start = \"\\n\";\n\t\tfirst_print = true;\n\t}\n\t\n\tvoid _print(deque<string>) {}\n\ttemplate<class T, class... Args>\n\tvoid _print(deque<string> names, T elem, Args... args) {\n\t\tif (!first_print) {\n\t\t\tfast_print(\"\\n\");\n\t\t} else {\n\t\t\tfirst_print = false;\n\t\t}\n\t\tfast_print(names.front());\n\t\tfast_print(\" = \");\n\t\tfast_print(elem);\n\t\tnames.pop_front();\n\t\t_print(names, args...);\n\t}\n} //namespace smart_io\n\n\ntemplate <class T>\nostream &operator,(ostream &os, const T &object) {\n\tif (!smart_io::first_print) {\n\t\tfast_print(smart_io::sep);\n\t} else {\n\t\tsmart_io::first_print = false;\n\t}\n\tfast_print(object);\n\treturn os;\n}\n\ntemplate <class T>\nistream &operator,(istream &is, T &object) {\n\tfast_scan(object);\n\treturn is;\n}\n\nnamespace random {\n\tusing namespace std::chrono;\n\tmt19937 rng(duration_cast< milliseconds >(\n\t\t\t\t\t\t\t\t\t\t\t  system_clock::now().time_since_epoch()\n\t\t\t\t\t\t\t\t\t\t\t  ).count());\n\tuniform_real_distribution<> prob_dist(0.0, 1.0);\n};\n\nnamespace typedefs {\n\ttypedef long long ll;\n\ttypedef unsigned long long ull;\n\ttypedef pair<int, int> pii;\n\ttypedef long double ld;\n}\n\nnamespace numbers_operation {\n\ttemplate<class T>\n\tinline T floor_mod(T a, const T &b) {\n\t\ta %= b;\t\n\t\tif (a < 0) a += b;\n\t\treturn a;\n\t}\n}\n\nusing namespace numbers_operation;\nusing namespace typedefs;\nusing namespace random;\n\nint n;\nvector<vector<int>> factors;\nvector<int> v;\n\nvoid factorize(int n, vector<int> &rez) {\n\tfor (int i = 2; i * i <= n; i++) {\n\t\twhile (n % i == 0) {\n\t\t\tn /= i;\n\t\t\trez.pb(i);\n\t\t}\n\t}\n\tif (n > 1) rez.pb(n);\n\tsort(rez.begin(), rez.end());\n\trez.resize(unique(rez.begin(), rez.end()) - rez.begin());\n}\n\nstruct SUS {\n\tvector<int> up;\n\tint get_root(int i) {\n\t\tif (up[i] == i) return i;\n\t\treturn up[i] = get_root(up[i]);\n\t}\n\tSUS(int n) {\n\t\tup.resize(n);\n\t\tf(i, n) up[i] = i;\n\t}\n\tvoid merge(int a, int b) {\n\t\tup[get_root(a)] = get_root(b);\n\t}\n\tbool one_comp(int a, int b) {\n\t\treturn get_root(a) == get_root(b);\n\t}\n};\n\nvector<int> order(vector<int> cur, const set<int> &F, int lv = 0) {\n\tif (len(cur) <= 1) return cur;\n\tint take = -1;\n\tfor (int i = 0; i < len(cur); i++) {\n\t\tif (F.count(v[cur[i]])) \n\t\t\tif (take == -1 || v[cur[i]] < v[cur[take]])\n\t\t\t\ttake = i;\n\t}\n\tassert(take != -1);\n\tmap<int, vector<int>> at;\n\tfor (int i = 0; i < len(cur); i++) {\n\t\tif (i == take) continue;\n\t\tfor (int x : factors[cur[i]]) {\n\t\t\tat[x].pb(i);\n\t\t}\n\t}\n\tSUS sus(len(cur));\n\tfor (auto p : at) {\n\t\tfor (int j = 0; j < len(p.y) - 1; j++) {\n\t\t\tsus.merge(p.y[j], p.y[j + 1]);\n\t\t}\n\t}\n\tmap<int, vector<int>> index;\n\tfor (int i = 0; i < len(cur); i++) {\n\t\tif (i == take) continue;\n\t\tindex[sus.get_root(i)].pb(cur[i]);\n\t}\n\tset<int> ava;\n\tfor (int i = 0; i < len(cur); i++) {\n\t\tif (i == take) continue;\n\t\tif (gcd(v[cur[i]], v[cur[take]]) > 1 || (v[cur[i]] <= v[cur[take]] && F.count(v[cur[i]])))\n\t\t\tava.insert(v[cur[i]]);\n\t}\n\tvector<int> rez;\n\tfor (auto p : index) {\n\t\tvector<int> t = order(p.y, ava, lv + 1);\n\t\tif (lv == 0) {\n\t\t\t// print \"GO\", p.y, \":\", t;\n\t\t}\n\t\tvector<int> final;\n\t\tmerge(rez.begin(), rez.end(), t.begin(), t.end(), back_inserter(final), [](int i, int j) {\n\t\t\treturn v[i] > v[j];\n\t\t});\n\t\trez = final;\n\t}\n\trez.insert(rez.begin(), cur[take]);\n\treturn rez;\n}\n\nsigned main(signed argc, char *argv[]) {\n\tscan n;\n\tv.resize(n);\n\tfactors.resize(n);\n\tscan v;\n\tfor (int i = 0; i < n; i++) {\n\t\tfactorize(v[i], factors[i]);\n\t}\n\tvector<int> cur(n);\n\tiota(cur.begin(), cur.end(), 0);\n\t{\n\t\tmap<int, vector<int>> at;\n\t\tfor (int i = 0; i < len(cur); i++) {\n\t\t\t// if (i == take) continue;\n\t\t\tfor (int x : factors[cur[i]]) {\n\t\t\t\tat[x].pb(i);\n\t\t\t}\n\t\t}\n\t\tSUS sus(len(cur));\n\t\tfor (auto p : at) {\n\t\t\tfor (int j = 0; j < len(p.y) - 1; j++) {\n\t\t\t\tsus.merge(p.y[j], p.y[j + 1]);\n\t\t\t}\n\t\t}\n\t\tmap<int, vector<int>> index;\n\t\tfor (int i = 0; i < len(cur); i++) {\n\t\t\t// if (i == take) continue;\n\t\t\tindex[sus.get_root(i)].pb(i);\n\t\t}\n\t\tset<int> ava;\n\t\tfor (int i = 0; i < len(cur); i++) {\n\t\t\t// if (i == take) continue;\n\t\t\t// if (gcd(v[cur[i]], v[cur[take]]) > 1 || v[cur[i]] <= v[cur[take]])\n\t\t\t\tava.insert(v[cur[i]]);\n\t\t}\n\t\tvector<int> rez;\n\t\tfor (auto p : index) {\n\t\t\tvector<int> t = order(p.y, ava);\n\t\t\t// print \"GO\", p.y, \"->\", t;\n\t\t\tvector<int> final;\n\t\t\tmerge(rez.begin(), rez.end(), t.begin(), t.end(), back_inserter(final), [](int i, int j) {\n\t\t\t\treturn v[i] > v[j];\n\t\t\t});\n\t\t\trez = final;\n\t\t}\n\t\tfor (int i = 0; i < len(rez); i++)\n\t\t\trez[i] = v[rez[i]];\n\t\tprint rez;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<stack>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<cmath>\nusing namespace std;\nint gcd(int x,int y){return (y==0)?x:gcd(y,x%y);}\nint n;\nint a[2010];\nint in[2010];\nint vis[2010];\nint ed[2010][2010];\nvector<int> e[2010];\npriority_queue<int,vector<int>,less<int> > q;\nvoid dfs(int x)\n{\n\tvis[x]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tif(!vis[i]&&ed[x][i])\n\t\t{\n\t\t\tin[i]++;\n\t\t\te[x].push_back(i);\n\t\t\tdfs(i);\n\t\t}\n}\nsigned main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\tif(gcd(a[i],a[j])!=1)\n\t\t\t\ted[i][j]=1,ed[j][i]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tif(!vis[i])\n\t\t\tdfs(i);\n\tfor(int i=1;i<=n;i++)\n\t\tif(in[i]==0)\n\t\t\tq.push(i);\n\twhile(!q.empty())\n\t{\n\t\tint u=q.top();\n\t\tq.pop();\n\t\tprintf(\"%d \",a[u]);\n\t\tfor(int i=0;i<e[u].size();i++)\n\t\t{\n\t\t\tint to=e[u][i];\n\t\t\tin[to]--;\n\t\t\tif(in[to]==0)\n\t\t\t\tq.push(to);\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,tmp,a[2005],num[2005];\nbool vis[2005];\nvector<int> topo,p,g[2005];\nvector<int> topos[2005];\nint gcd(int a,int b)\n{\n\treturn b?gcd(b,a%b):a;\n}\nbool cmp1(int i,int j)\n{\n\treturn a[i]<a[j];\n}\nbool cmp2(vector<int> v1,vector<int> v2)\n{\n\treturn v1[0]>v2[0];\n}\nvoid dfs(int x)\n{\n\tnum[x]=tmp;\n\tfor(int i=0;i<g[x].size();i++)\n\t\tif(!num[g[x][i]])\n\t\t\tdfs(g[x][i]);\n}\nvoid dfstopo(int x)\n{\n\tvis[x]=1;\n\tfor(int i=0;i<g[x].size();i++)\n\t\tif(!vis[g[x][i]])\n\t\t\tdfstopo(g[x][i]);\n\ttopo.push_back(x);\n}\nint main()\n{\n\tcin>>n;\n\tfor(int i=1;i<=n;i++)\n\t\tcin>>a[i];\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\tif(gcd(a[i],a[j])!=1)\n\t\t\t{\n\t\t\t\tg[i].push_back(j);\n\t\t\t\tg[j].push_back(i);\n\t\t\t}\n\tfor(int i=1;i<=n;i++)\n\t\tsort(g[i].begin(),g[i].end(),cmp1);\n\tfor(int i=1;i<=n;i++)\n\t\tif(!num[i])\n\t\t{\n\t\t\ttmp++;\n\t\t\tdfs(i);\n\t\t}\n\tfor(int i=1;i<=tmp;i++)\n\t{\n\t\tmemset(vis,0,sizeof(vis));\n\t\ttopo.clear();\n\t\tp.clear();\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(num[j]==i)\n\t\t\t\tp.push_back(j);\n\t\tsort(p.begin(),p.end(),cmp1);\n\t\tdfstopo(p[0]);\n\t\treverse(topo.begin(),topo.end());\n\t\ttopos[i]=topo;\n\t}\n\tsort(topos+1,topos+tmp+1,cmp2);\n\tfor(int i=1;i<=tmp;i++)\n\t\tfor(int j=0;j<topos[i].size();j++)\n\t\t\tcout<<a[topos[i][j]]<<' ';\n\tcout<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Zhupengfei 2018\n// This program / source file is in public domain.\n\n// Solution for problem: Rearranging\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n// Main segment\n\nint a[2001] = {};\nvector<int> g[2001] = {};\nbool v[2001] = {};\nvector<vector<int>> seq;\nvector<int> tmpseq;\nvector<int> topores;\n\nvoid dfs(int x) {\n    v[x] = 1;\n    tmpseq.push_back(x);\n    for (int y : g[x]) {\n        if (!v[y]) {\n            dfs(y);\n        }\n    }\n}\n\nbool topov[2001] = {};\n\nvoid topo() {\n    priority_queue<int, vector<int>, greater<int>> pq;\n\n    // cout << \"Running topo on \";\n    // for (int y : tmpseq) {\n    //     cout << y << \" \";\n    // }\n    // cout << endl;\n    pq.push(tmpseq[0]);\n    topov[tmpseq[0]] = 1;\n    while (!pq.empty()) {\n        int u = pq.top();\n        pq.pop();\n        topores.push_back(u);\n        for (int y : g[u]) {\n            if (topov[y])\n                continue;\n            pq.push(y);\n            topov[y] = 1;\n        }\n    }\n    // cout << \"Result is\";\n    // for (int y : topores) {\n    //     cout << y << \" \";\n    // }\n    // cout << endl;\n}\n\nint gcd(int a, int b) {\n    return b == 0 ? a : gcd(b, a % b);\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int N;\n    cin >> N;\n    for (int i = 1; i <= N; i++) {\n        cin >> a[i];\n    }\n    sort(a + 1, a + N + 1);\n    for (int i = 1; i <= N; i++) {\n        for (int j = i + 1; j <= N; j++) {\n            if (gcd(a[i], a[j]) != 1) {\n                g[i].push_back(j);\n                g[j].push_back(i);\n            }\n        }\n    }\n    for (int i = 1; i <= N; i++) {\n        sort(g[i].begin(), g[i].end());\n    }\n    for (int i = 1; i <= N; i++) {\n        if (!v[i]) {\n            dfs(i);\n            topo();\n            assert(topores.size() == tmpseq.size());\n            seq.emplace_back(std::move(topores));\n            tmpseq.clear();\n            topores = std::vector<int>();\n        }\n    }\n    sort(seq.begin(), seq.end(), greater<vector<int>>());\n    for (const auto& vec : seq) {\n        for (int x : vec) {\n            cout << a[x] << \" \";\n        }\n    }\n    cout << endl;\n\n#ifdef LOCAL\n    system(\"pause\");\n#endif\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int, int> pii;\n\nconst int N = 5e3 + 5;\n\nll n, a[N], ans[N], in[N], tp[N], cur;\nbool mark[N];\nvector <int> adj[N];\nvector <pii> g[N];\n\nvoid dfs(int v) {\n\ttp[cur++] = v;\n\tmark[v] = true;\n\tfor (auto e : g[v]) {\n\t\tint u = e.second;\n\t\tif(!mark[u]) {\n\t\t\tdfs(u);\n\t\t}\n\t}\n}\n\nint main() {\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\t\n\tcin >> n;\n\tfor (int i = 0; i < n; i++)\n\t\tcin >> a[i];\n\tsort(a, a + n);\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = i + 1; j < n; j++)\n\t\t\tif(__gcd(a[i], a[j]) > 1)\n\t\t\t\tg[i].push_back({a[j], j}), g[j].push_back({a[i], i});;\n\tfor (int i = 0; i < n; i++)\n\t\tsort(g[i].begin(), g[i].end());\n\tfor (int i = 0; i < n; i++)\n\t\tif(!mark[i])\n\t\t\tdfs(i);\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tint x = tp[i], y = tp[j];\n\t\t\tif(__gcd(a[x], a[y]) > 1) {\n\t\t\t\tadj[x].push_back(y);\n\t\t\t\tin[y]++;\n\t\t\t}\n\t\t}\n\t}\n\tpriority_queue <pii> pq;\n\tfor (int i = 0; i < n; i++) {\n\t\tif(!in[i])\n\t\t\tpq.push({a[i], i});\n\t}\n\tint cnt = 0;\n\twhile(!pq.empty()) {\n\t\tpii p = pq.top();\n\t\tpq.pop();\n\t\tans[cnt++] = p.first;\n\t\tint v = p.second;\n\t\tfor (auto u : adj[v]) {\n\t\t\tin[u]--;\n\t\t\tif(!in[u])\n\t\t\t\tpq.push({a[u], u});\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++)\n\t\tcout << ans[i] << \" \";\n\tcout << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "\n//#define USEPB_DS\n#define USETR1\n#define CPPELEVEN\n#define GPP\n\n/*\n * temp.cpp\n *\n *  Created on: 2012-7-18\n *      Author: BSBandme\n */\n//#pragma comment(linker, \"/STACK:1024000000,1024000000\")\n\n#include <iostream>\n#include <fstream>\n#include <string.h>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <cassert>\n#include <list>\n#include <iomanip>\n#include <math.h>\n#include <deque>\n#include <utility>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cctype>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <functional>\n#include <sstream>\n#include <tuple>\n\nusing namespace std;\n\n#ifndef CPPELEVEN\n#ifdef USETR1\n#include <tr1/unordered_map>\n#include <tr1/unordered_set>\nusing namespace tr1;\n#endif\n#else\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\n#ifdef USEPB_DS\n#include <ext/pb_ds/priority_queue.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\n// binomial_heap_tag, rc_binomial_heap_tag, thin_heap_tag, binary_heap_tag\ntypedef __gnu_pbds::priority_queue<int, greater<int>, pairing_heap_tag> pq_type;\n// splay_tree_tag, ov_tree_tag\ntypedef tree <int, null_type, less <int>, rb_tree_tag, tree_order_statistics_node_update> tree_type;\n#endif\n\n#define mpr make_pair\ntypedef unsigned int ui;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <double, double> pdd;\ntypedef vector <int> vi;\ntypedef vector <ll> vll;\ntypedef vector <double> vd;\ntypedef vector <string> vs;\ntypedef map <string, int> mpsi;\ntypedef map <double, int> mpdi;\ntypedef map <int, int> mpii;\n\nconst double pi = acos(0.0) * 2.0;\nconst long double eps = 1e-10;\nconst int step[8][2] = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}, {-1, 1}, {1, 1}, {1, -1}, {-1, -1}};\n\ntemplate <class T> inline T abs1(T a) {return a < 0 ? -a : a;}\n\n#ifndef CPPELEVEN\ntemplate <class T> inline T max1(T a, T b) { return b < a ? a : b; }\ntemplate <class T> inline T max1(T a, T b, T c) { return max1(max1(a, b), c); }\ntemplate <class T> inline T max1(T a, T b, T c, T d) { return max1(max1(a, b, c), d); }\ntemplate <class T> inline T max1(T a, T b, T c, T d, T e) { return max1(max1(a, b, c, d), e); }\ntemplate <class T> inline T min1(T a, T b) { return a < b ? a : b; }\ntemplate <class T> inline T min1(T a, T b, T c) { return min1(min1(a, b), c); }\ntemplate <class T> inline T min1(T a, T b, T c, T d) { return min1(min1(a, b, c), d); }\ntemplate <class T> inline T min1(T a, T b, T c, T d, T e) { return min1(min1(a, b, c, d), e); }\n#else\ntemplate <typename t, typename t1>\nt min1(t a, t1 b) { return a < b ? a : b; }\ntemplate <typename t, typename... arg>\nt min1(t a, arg... arr) { return min1(a, min1(arr...)); }\ntemplate <typename t, typename t1>\nt max1(t a, t1 b) { return a > b ? a : b; }\ntemplate <typename t, typename... arg>\nt max1(t a, arg... arr) { return max1(a, max1(arr...)); }\n#endif\n\ninline int jud(double a, double b){\n\tif(abs(a) < eps && abs(b) < eps) return 0;\n\telse if(abs1(a - b) / max(abs1(a), abs1(b)) < eps) return 0;\n\tif(a < b) return -1;\n\treturn 1;\n}\ntemplate <typename t> inline int jud(t a, t b){\n\tif(a < b) return -1;\n\tif(a == b) return 0;\n\treturn 1;\n}\n\n// f_lb == 1代表返回相同的一串的左边界，f_small == 1代表返回如果没有寻找的值返回小的数\ntemplate <typename it, typename t1>\ninline int find(t1 val, it a, int na, bool f_small = 1, bool f_lb = 1){\n\tif(na == 0) return 0;\n\tint be = 0, en = na - 1;\n\tif(*a <= *(a + na - 1)){\n\t\tif(f_lb == 0) while(be < en){\n\t\t\tint mid = (be + en + 1) / 2;\n\t\t\tif(jud(*(a + mid), val) != 1) be = mid;\n\t\t\telse en = mid - 1;\n\t\t}else while(be < en){\n\t\t\tint mid = (be + en) / 2;\n\t\t\tif(jud(*(a + mid), val) != -1) en = mid;\n\t\t\telse be = mid + 1;\n\t\t}\n\t\tif(f_small && jud(*(a + be), val) == 1) be--;\n\t\tif(!f_small && jud(*(a + be), val) == -1) be++;\n\t} else {\n\t\tif(f_lb) while(be < en){\n\t\t\tint mid = (be + en + 1) / 2;\n\t\t\tif(jud(*(a + mid), val) != -1) be = mid;\n\t\t\telse en = mid - 1;\n\t\t}else while(be < en){\n\t\t\tint mid = (be + en) / 2;\n\t\t\tif(jud(*(a + mid), val) != 1) en = mid;\n\t\t\telse be = mid + 1;\n\t\t}\n\t\tif(!f_small && jud(*(a + be), val) == -1) be--;\n\t\tif(f_small && jud(*(a + be), val) == 1) be++;\n\t}\n\treturn be;\n}\n\ntemplate <class T> inline T lowb(T num) {return num & (-num); }\n#ifdef GPP\ninline int bitnum(ui nValue) { return __builtin_popcount(nValue); }\ninline int bitnum(int nValue) { return __builtin_popcount(nValue); }\ninline int bitnum(ull nValue) { return __builtin_popcount(nValue) + __builtin_popcount(nValue >> 32); }\ninline int bitnum(ll nValue) { return __builtin_popcount(nValue) + __builtin_popcount(nValue >> 32); }\ninline int bitmaxl(ui a) { if(a == 0) return 0; return 32 - __builtin_clz(a); }\ninline int bitmaxl(int a) { if(a == 0) return 0; return 32 - __builtin_clz(a); }\ninline int bitmaxl(ull a) { int temp = a >> 32; if(temp) return 32 - __builtin_clz(temp) + 32; return bitmaxl(int(a)); }\ninline int bitmaxl(ll a) { int temp = a >> 32; if(temp) return 32 - __builtin_clz(temp) + 32; return bitmaxl(int(a)); }\n#else\n#endif\n\nlong long pow(long long n, long long m, long long mod = 0){\n\tif(m < 0) return 0;\n\tlong long ans = 1;\n\tlong long k = n;\n\twhile(m){\n\t\tif(m & 1) {\n\t\t\tans *= k;\n\t\t\tif(mod) ans %= mod;\n\t\t}\n\t\tk *= k;\n\t\tif(mod) k %= mod;\n\t\tm >>= 1;\n\t}\n\treturn ans;\n}\n\n#define  MOD 1000000007\ntemplate <class t1, class t2>\ninline void add(t1 &a, t2 b, int mod = -1) {\n\tif(mod == -1) mod = MOD;\n\ta += b;\n\twhile(a >= mod) a -= mod;\n\twhile(a < 0) a += mod;\n}\ntemplate <class t>\nvoid output1(t arr) {\n\tfor(int i = 0; i < (int)arr.size(); i++)\n\t\tcerr << arr[i] << ' ';\n\tcerr << endl;\n}\ntemplate <class t>\nvoid output2(t arr) {\n\tfor(int i = 0; i < (int)arr.size(); i++)\n\t\toutput1(arr[i]);\n}\n\n//....................密..........封..........线..........下..........禁..........止..........hack...............................................\n\nconst int maxn = 2010;\nint arr[maxn];\nint ans[maxn], lans;\nbitset <maxn> e[maxn];\nint have[maxn];\nint n;\nint temp[maxn], nxt[maxn];\n\nvoid rearrange(vi st) {\n\tif(st.size() == 0) return;\n\tfor(int i = st[0]; i < lans; i++)\n\t\tnxt[i] = i + 1;\n\tfor(auto it : st) if(it > 0){\n\t\tnxt[it - 1] = -1;\n\t}\n\tnxt[lans - 1] = -1;\n\tpriority_queue <pii> pq;\n\tfor(auto it : st)\n\t\tpq.push(mpr(ans[it], it));\n\tint lt = 0;\n\twhile(pq.size()) {\n\t\tint val = pq.top().first, no = pq.top().second;\n\t\tpq.pop();\n\t\ttemp[lt++] = val;\n\t\tif(nxt[no] != -1) {\n\t\t\tpq.push(mpr(ans[no + 1], no + 1));\n\t\t}\n\t}\n\tfor(int i = 0; i < lt; i++)\n\t\tans[st[0] + i] = temp[i];\n}\n\nvoid dfs(int no) {\n\tans[lans++] = arr[no];\n\thave[no] = 1;\n\tvector <pii> temp;\n\tfor(int i = 0; i < n; i++) if(!have[i] && e[no].test(i)) {\n\t\ttemp.push_back(mpr(arr[i], i));\n\t}\n\tsort(temp.begin(), temp.end());\n\tint rlans = lans, rlans1 = lans;\n\tvi st;\n\tfor(auto it : temp\t) if(!have[it.second]) {\n\t\tst.push_back(lans);\n\t\tdfs(it.second);\n\t}\n\trearrange(st);\n}\n\nint main() {\n\n\n//............................不要再忘了检查maxn大小了！！！！BSBandme你个SB！！！！...................................................\n\n\tios_base::sync_with_stdio(0);\n\t#ifdef DEBUG //......................................................................................................\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint __size__ = 256 << 20; // 256MB\n\tchar *__p__ = (char*)malloc(__size__) + __size__;\n\t__asm__(\"movl %0, %%esp\\n\" :: \"r\"(__p__));\n\t#endif //...........................................................................................................\n\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", arr + i);\n\t}\n\tsort(arr, arr + n);\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = i + 1; j < n; j++) if(__gcd(arr[i], arr[j]) != 1) {\n\t\t\te[i].set(j, 1);\n\t\t\te[j].set(i, 1);\n\t\t}\n\n\tvi st;\n\tfor(int i = 0; i < n; i++) if(!have[i]) {\n\t\tst.push_back(lans);\n\t\tdfs(i);\n\t}\n\trearrange(st);\n\tfor(int i = 0; i < lans; i++)\n\t\tprintf(\"%d \", ans[i]);\n\n\tfor(int i = 1; i < n; i++) {\n\t\tfor(int j = i - 1; j >= 0; j--) {\n\t\t\tif(__gcd(ans[j], ans[i]) != 1) break;\n\t\t\tif(ans[j] < ans[i]) {\n\t\t\t\tcout << i << ' ' << j << endl;\n\t\t\t}\n\t\t}\n\t}\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <vector>\n#include <iostream>\n#include <string.h>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <string>\nusing namespace std;\n\ntypedef double LD;\ntypedef long long LL;\ntypedef pair<int, int> PII;\n#define MP make_pair\n#define PB push_back\n#define FOR(i,a,b) for(int i = (a); i < (b); ++i)\n#define RFOR(i,b,a) for(int i = (b) - 1; i >= (a); --i)\n#define REP(i, t) FOR(i,0,t)\n#define ALL(a) a.begin(), a.end()\n#define SZ(a) (int)((a).size())\n\nconst LL MOD = 1000000007;\nconst int INF = 1e9;\nconst LL LINF = 1LL * INF * INF;\nconst int MAXN = 2007;\nconst LD EPS = 1e-7;\n\nint n, A[MAXN];\nbool used[MAXN];\nvector <int> B[MAXN];\nbool G[MAXN][MAXN];\n\nint gcd(int a, int b)\n{\n\tif (a == 0) return b;\n\treturn gcd(b % a, a);\n}\n\nvoid dfs(int v)\n{\n\tvector <int> C, P;\n\tused[v] = true;\n\tREP(i, n)\n\t{\n\t\tif (G[v][i] && !used[i])\n\t\t{\n\t\t\tC.push_back(i);\n\t\t\tdfs(i);\n\t\t}\n\t}\n\tP.resize(SZ(C));\n\tB[v].push_back(A[v]);\n\twhile (true)\n\t{\n\t\tint mx = 0, c;\n\t\tREP(i, SZ(C))\n\t\t{\n\t\t\tif (P[i] < SZ(B[C[i]]) && B[C[i]][P[i]] > mx)\n\t\t\t{\n\t\t\t\tmx = B[C[i]][P[i]];\n\t\t\t\tc = i;\n\t\t\t}\n\t\t}\n\t\tif (mx == 0) break;\n\t\tB[v].push_back(mx);\n\t\t++P[c];\n\t}\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0);\n\t//freopen(\"In.txt\", \"r\", stdin);\n\tcin >> n;\n\tREP(i, n) cin >> A[i];\n\tsort(A, A + n);\n\tREP(i, n)\n\t{\n\t\tREP(j, i)\n\t\t\tif (gcd(A[i], A[j]) > 1)\n\t\t\t\tG[i][j] = G[j][i] = true;\n\t\tG[i][n] = G[n][i] = true;\n\t}\n\tdfs(n);\n\tFOR(i, 1, n + 1)\n\t\tcout << B[n][i] << ' ';\n\t//cout << endl; system(\"pause\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mp make_pair\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int > vi;\ntypedef pair<int ,int > pii;\ntypedef vector<pii> vii;\nconst int inf=0x3f3f3f3f, maxn=2007, mod=1e9+7;\nconst ll linf=0x3f3f3f3f3f3f3f3fLL;\nint n;\nint a[maxn];\nbool e[maxn][maxn];\nvi e1[maxn];\nbool vis[maxn];\nint ind[maxn];\nbool book[maxn];\ninline int read(){\n   int s=0,w=1;\n   char ch=getchar();\n   while(ch<='0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}\n   while(ch>='0'&&ch<='9') s=(s<<1)+(s<<3)+ch-'0',ch=getchar();\n   return s*w;\n}\ninline void write(int x)\n{\n     if(x<0) putchar('-'),x=-x;\n     if(x>9) write(x/10);\n     putchar(x%10+'0');\n}\nvoid dfs(int u){\n//\tcout<<u<<endl;\n\tvis[u]=true;\n\tfor(int i=1;i<=n;i++){\n\t\tif(!vis[i]&&e[u][i]==true){\n//\t\t\tcout<<i<<endl;\n\t\t\tvis[i]=true;\n\t\t\te1[u].pb(i);\n\t\t\tind[i]++;\n\t\t\tdfs(i);\n\t\t}\n\t}\n}\n\nint main(){\n\tn=read();\n\tfor(int i=1;i<=n;i++){\n\t\ta[i]=read();\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=i+1;j<=n;j++){\n\t\t\tif(__gcd(a[i],a[j])!=1)e[i][j]=true,e[j][i]=true;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tif(!vis[i])dfs(i);\n//\t\tcout<<endl;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=n;j>=1;j--){\n\t\t\tif(!book[j]&&ind[j]==0){\n\t\t\t\tbook[j]=true;\n\t\t\t\tprintf(\"%d \",a[j]);\n\t\t\t\tfor(int k=0;k<e1[j].size();k++){\n\t\t\t\t\tind[e1[j][k]]--;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <bitset>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define TRACE(x) cerr << #x << \" = \" << x << endl\n#define REP(i, n) for (int i=0; i<n; i++)\n#define FOR(i, a, b) for (int i=(a); i<(b); i++)\n#define _ << \" \" <<\n\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\n#define X first\n#define Y second\n\nconst int MAX = 2005, MAXL = 2005 / 64 + 2;\n\nbitset <MAX> ne_rel[MAX];\null ne_rel_ull[MAX][MAXL];\nbitset <MAX> manji[MAX];\nbitset <MAX> smije;\nbitset <MAX> ostalo;\nint n;\nint p[MAX];\nint rje[MAX];\nint done[MAX];\nint indk[MAX], brk;\n\nvoid bfs()\n{\n  ull nodovi[MAXL];\n  REP(i, n)\n    if (!done[i])\n      nodovi[i/64] |= ((ull) 1) << (i % 64);\n\n  queue <int> Q;\n\n  brk = 0;\n  REP(i, n) {\n    if (nodovi[i/64] & ((ull) 1) << (i % 64)) {\n      nodovi[i/64] ^= ((ull) 1) << (i % 64);\n      Q.push(i);\n      \n      for (; !Q.empty();) {\n\tint tmp = Q.front(); Q.pop();\n\tindk[tmp] = brk;\n\t//\tTRACE(tmp _ brk);\n\n\tREP(j, MAXL) {\n\t  ull val = nodovi[j] & ne_rel_ull[tmp][j];\n\t  for (; val; ) {\n\t    ull koji = val & (-val);\n\t    int ind = __builtin_ctzll(koji);\n\t    \n\t    nodovi[j] ^= ((ull) 1) << ind;\n\t    val ^= ((ull) 1) << ind;\n\t    Q.push(64 * j + ind);\n\t  }\n\t}\n      }\n      \n      brk++;\n    }\n  }  \n}\n\nint main()\n{\n  scanf(\"%d\", &n);\n  REP(i, n) scanf(\"%d\", &p[i]);\n\n  sort(p, p + n);\n\n  REP(i, n)\n    REP(j, n)\n    if (__gcd(p[i], p[j]) > 1) {\n      ne_rel_ull[i][j/64] |= ((ull) 1) << (j % 64);    \n      ne_rel[i][j] = 1;\n    }\n\n  REP(i, n) smije[i] = 1;\n  REP(i, n) ostalo[i] = 1;\n\n  REP(i, n) {\n    bfs();\n\n    int ima[MAX];\n    memset(ima, 0, sizeof ima);\n    int poklopio = 0;\n\n    //    TRACE(brk);\n    \n\n    int ind = -1;\n    REP(j, n) {\n      if (done[j]) continue;\n      if (smije[j]) {\n\t//\tTRACE(j _ smije[j]);\n\n\tif (!ima[indk[j]]) {\n\t  ima[indk[j]] = 1;\n\t  poklopio++;\n\t}\n\n\tif (poklopio == brk) {\n\t  ind = j;\n\t  break;\n\t}\n      }\n    }\n\n    assert(ind != -1);\n\n    //postavi ind\n    done[ind] = 1;\n    smije[ind] = 0;\n    rje[i] = ind;\n    //    TRACE(i _ p[rje[i]]);      \n\n    REP(k, n) {\n      if (ne_rel[ind][k])\n\tsmije[k] = 1;\n      else if (smije[k] && k < ind)\n\tsmije[k] = 1;\n      else\n\tsmije[k] = 0;\n    }      \n  }    \n\n  REP(i, n)\n    printf(\"%d \", p[rje[i]]);\n  printf(\"\\n\");\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\n#define INF 1e9\n#define LINF 1e18\n#define ld double\n#define ll long long\n#define ull unsigned long long\n\ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1, c = getchar();\n\tfor (;!isdigit(c);c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c);c = getchar()) x = (x<<3) + (x<<1) + (c^48);\n\tx *= f;\n}\n\nconst int N = 2005;\nint n, a[N];\nbool used[N], canuse[N];\null g[N][N], vis[N];\nint que[N], lb, rb;\n\nint bfs(int s) {\n\tlb = rb = 0;\n\tque[rb ++] = s;\n\tvis[s >> 6] |= 1ull << (s & 63);\n\tint mn = n;\n\twhile (lb < rb) {\n\t\tint u = que[lb ++];\n\t\tif (canuse[u] && u < mn) mn = u;\n\t\tfor (int i = 0; (i << 6) < n; ++ i) {\n\t\t\tif ((g[u][i] & vis[i]) != g[u][i]) {\n\t\t\t\tfor (int j = i << 6; j < ((i + 1) << 6); ++ j) {\n\t\t\t\t\tif (g[u][i] & 1ull << (j & 63)) {\n\t\t\t\t\t\tif (!(vis[i] & 1ull << (j & 63))) {\n\t\t\t\t\t\t\tvis[i] |= 1ull << (j & 63);\n\t\t\t\t\t\t\tque[rb ++] = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n//\tfor (int i = 0; i < lb; ++ i) fprintf(stderr, \" %d\", que[i]);\n//\tfprintf(stderr, \" |\");\n\treturn mn;\n}\n\nvoid print() {\n\tmemset(vis, 0, sizeof vis);\n\tfor (int i = 0; i < n; ++ i) if (used[i]) vis[i >> 6] |= 1ull << (i & 63);\n\tint mx = 0;\n\tfor (int i = 0; i < n; ++ i) if (!(vis[i >> 6] & 1ull << (i & 63))) {\n\t\tint cur = bfs(i);\n\t\tif (cur != n) mx = max(mx, cur);\n\t}\n//\tfprintf(stderr, \"\\n\");\n\tprintf(\"%d\", a[mx]);\n\tused[mx] = 1;\n\tfor (int i = 0; i < n; ++ i) if (!used[i]) {\n\t\tif (g[mx][i >> 6] & 1ull << (i & 63)) canuse[i] = 1;\n\t\telse { if (a[i] > a[mx]) canuse[i] = 0; }\n\t}\n}\n\nint main() {\n\tread(n);\n\tfor (int i = 0; i < n; ++ i) read(a[i]);\n\tsort(a, a + n);\n\tfor (int i = 0; i < n; ++ i) for (int j = 0; j < n; ++ j) if (i != j && __gcd(a[i], a[j]) != 1) g[i][j >> 6] |= 1ull << (j & 63);\n\tfor (int i = 0; i < n; ++ i) canuse[i] = 1;\n\tfor (int i = 0; i < n; ++ i) {\n\t\tprint();\n\t\tputchar(\" \\n\"[i + 1 == n]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iomanip>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define all(x) (x).begin(),(x).end()\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n \ntemplate<class T> inline bool chmax(T &a, T b){\n    if(a<b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T> inline bool chmin(T &a, T b){\n    if(a>b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<typename T>\nT gcd(T a, T b)\n{\n    return b ? gcd(b, a % b) : a;\n}\n\ntemplate<typename T>\nT lcm(T a,T b)\n{\n    return  a / gcd(a,b) * b;\n}\nclass UnionFind {\nprivate:\n    int sz;\n    vector<int> par, size_;\npublic:\n    UnionFind(){}\n    UnionFind(int node_size) : sz(node_size), par(sz), size_(sz, 1){\n        iota(par.begin(), par.end(), 0);\n    }\n    int find(int x){\n        if(par[x] == x) return x;\n        else return par[x] = find(par[x]);\n    }\n    void unite(int x,int y){\n        x = find(x), y = find(y);\n        if(x == y) return;\n        if(size_[x] < size_[y]) swap(x,y);\n        par[y] = x;\n        size_[x] += size_[y];\n    }\n    int size(int x){\n        x = find(x);\n        return size_[x];\n    }\n    bool same(int x,int y){\n        return find(x) == find(y);\n    }\n};\n\nvector<int> calc(vector<int> &a){\n    int n = a.size();\n    vector<int> res(n);\n    rep(i,n){\n        if(i==0){\n            res[i] = a[i];\n            continue;\n        }\n        int xxx = i;\n        for(int j=i-1;j>=0;j--){\n            if(res[j]<a[i]&&gcd(res[j],a[i])==1){\n                xxx = j;\n            }else{\n                break;\n            }\n        }\n        for(int j=i;j>xxx;j--){\n            res[j] = res[j-1];\n        }\n        res[xxx] = a[i];\n    }\n    return res;\n}\n\nint main(){\n    int n;\n    cin >> n;\n    vector<int>a(n);\n    rep(i,n){\n        cin >> a[i];\n    }\n    vector<vector<int> > g(n);\n    UnionFind uf(n);\n    rep(i,n){\n        for(int j=i+1;j<n;j++){\n            if(gcd(a[i],a[j])!=1){\n                g[i].push_back(j);\n                g[j].push_back(i);\n                uf.unite(i,j);\n            }\n        }\n    }\n    vector<pair<int,int> > p(n,MP(inf,inf));\n    rep(i,n){\n        p[uf.find(i)] = min(MP(a[i],i),p[uf.find(i)]);\n    }\n    vector<bool> used(n);\n    vector<vector<int> > res;\n    rep(i,n){\n        if(!used[i]){\n            auto ss = p[uf.find(i)];\n            int s = ss.second;\n            int t = ss.first;\n            priority_queue<pair<int,int>,vector<pii>,greater<pii> > pq;\n            pq.push(ss);\n            vector<int> tmp;\n            used[s] = true;\n            while(!pq.empty()){\n                pii c = pq.top();\n                tmp.push_back(c.first);\n                pq.pop();\n                for(auto x:g[c.second]){\n                    if(!used[x]){\n                        used[x] = true;\n                        pq.push(MP(a[x],x));        \n                    }\n                }\n            }\n            res.push_back(calc(tmp));\n        }\n    }\n    // for(auto x:res){\n    //     for(auto y:x){\n    //         cerr << y << \" \";\n    //     }\n    //     cerr << endl;\n    // }\n    priority_queue<pair<int,pii > > pp;\n    int m = res.size();\n    rep(i,m){\n        pp.push(MP(res[i][0],MP(i,0)));\n    }\n    vector<int> ans;\n    while(!pp.empty()){\n        auto x = pp.top();\n        pp.pop();\n        ans.push_back(x.first);\n        if(res[x.second.first].size()!=x.second.second+1){\n            pp.push(MP(res[x.second.first][x.second.second+1],MP(x.second.first,x.second.second+1)));\n        }\n    }\n    for(auto x:ans){\n        cout << x << \" \";\n    }\n    cout << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\n#define fst first\n#define snd second\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vii;\n#define sz(c) (int)(c).size()\n#define ALL(c) (c).begin(), (c).end()\n\nvi combine (const vi &l, const vi &r)\n{\n    if (l.empty() || r.empty())\n        return l.empty() ? r : l;\n\n    vi res(sz(l) + sz(r));\n//    int pl = 0, pr = 0, h = 0;\n//    while (pl < sz(l) && pr < sz(r))\n//        res[h++] = (l[pl] > r[pr] ? l[pl++] : r[pr++]);\n//    while (pl < sz(l))\n//        res[h++] = l[pl++];\n//    while (pr < sz(r))\n//        res[h++] = r[pr++];\n//    assert(h == sz(res));\n    merge(ALL(l), ALL(r), res.begin(), greater<int>());\n\n    return res;\n}\n\nvi dfs (int x, const vvi &g, vector<char> &used)\n{\n    used[x] = 1;\n    vi res;\n\n    for (int dest : g[x])\n    if (!used[dest])\n        res = combine(res, dfs(dest, g, used));\n\n    res.insert(res.begin(), x);\n    return res;\n}\n\nvoid solve (int n)\n{\n    vi a(n);\n    forn (i, n) cin >> a[i];\n    sort(ALL(a));\n\n    vvi g(n);\n    forn (i, n) forn (j, i)\n    if (__gcd(a[i], a[j]) != 1)\n    {\n        g[i].pb(j);\n        g[j].pb(i);\n    }\n\n    forn (i, n)\n        sort(ALL(g[i]));\n\n    vi res;\n    vector<char> used(n);\n    forn (i, n) if (!used[i])\n        res = combine(res, dfs(i, g, used));\n\n    forn (i, n)\n        cout << a[res[i]] << \" \\n\"[i + 1 == n];\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n;\n    while (cin >> n)\n        solve(n);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\n#define ll long long\n#define MAX 2020\ninline ll read()\n{\n\tll x=0;bool t=false;char ch=getchar();\n\twhile((ch<'0'||ch>'9')&&ch!='-')ch=getchar();\n\tif(ch=='-')t=true,ch=getchar();\n\twhile(ch<='9'&&ch>='0')x=x*10+ch-48,ch=getchar();\n\treturn t?-x:x;\n}\nstruct Line{int v,next;}e[MAX*MAX];\nint h[MAX],cnt=1,dg[MAX];\nvector<int> E[MAX];\ninline void Add(int u,int v){e[cnt]=(Line){v,h[u]};h[u]=cnt++;dg[v]+=1;}\ninline void ADD(int u,int v){E[u].push_back(v);}\nint n;\nll a[MAX];\npriority_queue<int> Q;\nbool vis[MAX];\nvoid dfs(int u)\n{\n\tvis[u]=true;\n\tfor(int v:E[u])if(!vis[v])dfs(v),Add(u,v);\n}\nint main()\n{\n\tn=read();\n\tfor(int i=1;i<=n;++i)a[i]=read();\n\tsort(&a[1],&a[n+1]);\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=i+1;j<=n;++j)\n\t\t\tif(__gcd(a[i],a[j])>1)ADD(i,j),ADD(j,i);\n\tfor(int i=1;i<=n;++i)if(!vis[i])dfs(i);\n\tfor(int i=1;i<=n;++i)if(!dg[i])Q.push(i);\n\twhile(!Q.empty())\n\t{\n\t\tint u=Q.top();Q.pop();printf(\"%lld \",a[u]);\n\t\tfor(int i=h[u];i;i=e[i].next)\n\t\t\tif(!--dg[e[i].v])Q.push(e[i].v);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define per(i,b,a) for(int i=b;i>=a;i--)\n#define For(i,a,b) for(int i=a;i<=b;i++)\n#define Forenska(it,c) for(register __typeof(c.begin()) it=c.begin();it!=c.end();it++)\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\n#define all(x) x.begin(),x.end()\n#define sqr(x) ((x)*(x))\n#define lowbit(x) ((x)&(-x))\n#define GREATER(x) x,vector<x>,greater<x>\nusing namespace std;\nint i,j;\ntypedef long long LL;\ntypedef pair<int,int> pii;\ntypedef pair<LL,LL> pLL;\ntypedef vector<int> vec;\ntypedef vector<LL> vecL;\ntypedef vector<pii> vecP;\ntypedef vector<pLL> vecPL;\ntypedef vector<string> vecS;\ntypedef vector<vec> mat;\ntypedef complex<double> point;\nconst long double PI=3.1415926535897932384626433832795028841971693993751058209749445923078164062862089;\nconst LL INFLL=0x3f3f3f3f3f3f3f3f;\nconst int INF=0x3f3f3f3f;\nconst long double EPS=1e-10;\nint read()\n{\n\tint x=0;\n\tchar ch=' ';\n\tbool flag=false;\n\twhile(!isdigit(ch))\n\t{\n\t\tif(ch=='-')flag=true;\n\t\tch=getchar();\n\t}\n\twhile(isdigit(ch))\n\t{\n\t\tx=(x<<3)+(x<<1)+ch-'0';\n\t\tch=getchar();\n\t}\n\treturn flag?-x:x;\n}\nint n;\nvec A;\nmat g1,g2;\nconst int MAX_N=2005;\nbool vis[MAX_N];\nint in[MAX_N];\nvoid dfs(int v)\n{\n\tif(vis[v])return;\n\tvis[v]=true;\n\trep(i,0,g1[v].size())\n\t{\n\t\tint to=g1[v][i];\n\t\tif(!vis[to])\n\t\t{\n\t\t\tg2[v].pb(to);\n\t\t\tin[to]++;\n\t\t\tdfs(to);\n\t\t}\n\t}\n}\nint main()\n{\n\tn=read();\n\tA.resize(n);\n\trep(i,0,n)A[i]=read();\n\tsort(all(A));\n\tA.resize(unique(all(A))-A.begin());\n\tn=A.size();\n\tg1.resize(n);\n\tg2.resize(n);\n\trep(i,0,n)\n\t{\n\t\trep(j,i+1,n)\n\t\t{\n\t\t\tif(__gcd(A[i],A[j])>1)\n\t\t\t{\n\t\t\t\tg1[i].pb(j);\n\t\t\t\tg1[j].pb(i);\n\t\t\t}\n\t\t}\n\t}\n\trep(i,0,n)\n\t{\n\t\tdfs(i);\n\t}\n\tpriority_queue <int> q;\n\tvec ans;\n//\trep(i,0,n)cout<<in[i]<<endl;\n\tper(i,n-1,0)if(!in[i])q.push(i),ans.pb(i);\n\twhile(!q.empty())\n\t{\n\t\tint t=q.top();\n\t\tq.pop();\n\t\trep(i,0,g2[t].size())\n\t\t{\n\t\t\tint to=g2[t][i];\n\t\t\tin[to]--;\n\t\t\tif(!in[to])\n\t\t\t{\n\t\t\t\tq.push(to);\n\t\t\t\tans.pb(to);\n\t\t\t}\n\t\t}\n\t}\n\trep(i,0,ans.size())ans[i]=A[ans[i]];\n\trep(i,0,ans.size())\n\t{\n\t\trep(j,0,ans.size()-1)\n\t\t{\n\t\t\tif(ans[j]<ans[j+1] && __gcd(ans[j],ans[j+1])==1)swap(ans[j],ans[j+1]);\n\t\t}\n\t}\n\trep(i,0,ans.size()-1)cout<<ans[i]<<\" \";\n\tcout<<ans.back()<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cstdio>\n#include<vector>\n#include<functional>\n#include<queue>\n\nusing namespace std;\nconst int MX=2011;\nint n,a[MX];\nstruct Edge{int t,nxt;Edge(int _t=0,int _nxt=0):t(_t),nxt(_nxt){}}e[MX<<1];\nint hed[MX],ec;\ninline void ade(int f,int t){e[++ec]=Edge(t,hed[f]);hed[f]=ec;}\n#define FE(k,i) for(int (i)=hed[k];(i);(i)=e[i].nxt)if(!vis[e[i].t])\ninline int gcd(int x,int y){if(x<y)swap(x,y);while(y)x%=y,swap(x,y);return x;}\n\nint vis[MX],stk[MX],nxt[MX],stc;\n\nvoid mktr(int k){\n\tvis[k]=1;\n\tint cur=k;\n\tpriority_queue<int,vector<int>,greater<int> >q;\n\twhile(!q.empty())q.pop();\n\tFE(k,i)q.push(e[i].t),vis[e[i].t]=1;\n\twhile(!q.empty()){\n\t\tint r=q.top();q.pop();\n\t\tnxt[cur]=r;cur=r;\n\t\tFE(r,i)q.push(e[i].t),vis[e[i].t]=1;\n\t}\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\tif(gcd(a[i],a[j])>1)ade(i,j),ade(j,i);\n\tfor(int i=1;i<=n;i++)if(!vis[i])stk[++stc]=i,mktr(i);\n\tfor(int i=stc;i;i--)for(int j=stk[i];j;j=nxt[j])printf(\"%d \",a[j]);\n\tputs(\"\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*************************************************\n *************************************************\n *************************************************\n *** _________________  |            |  |     /***\n ***         |          |            |  |    / ***\n ***         |          |            |  |   /  ***\n ***         |          |            |  |  /   ***\n ***         |          |            |  | /    ***\n ***         |          |____________|  |/  en ***\n ***         |          |            |  |\\     ***\n ***         |          |            |  | \\    ***\n *** _____   |          |            |  |  \\   ***\n ***   |     |          |            |  |   \\  ***\n ***   \\     /          |            |  |    \\ ***\n ***    \\___/           |            |  |     \\***\n *************************************************\n *************Written by: JiangHaoKai*************\n *************************************************/\n\n#pragma GCC optimize(2)\n#pragma G++ optimize(2)\n#pragma comment(linker,\"/STACK:102400000,102400000\")\n\n//#include <bits/stdc++.h>\n#include <cassert>\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdalign>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <string>\n#include <typeinfo>\n#include <valarray>\n#include <vector>\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <scoped_allocator>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <unordered_map>\n#include <unordered_set>\n//#include <conio.h>\n//#include <windows.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned int ui;\ntypedef unsigned long long ull;\ntypedef float fl;\ntypedef double ld;\ntypedef pair<int,int> pii;\n#define ui(n) ((unsigned int)(n))\n#define ll(n) ((long long)(n))\n#define ull(n) ((unsigned long long)(n))\n#define fl(n) ((float)(n))\n#define ld(n) ((double)(n))\n#define char(n) ((char)(n))\n#define Bool(n) ((bool)(n))\n#define fixpoint(n) fixed<<setprecision(n)\nconst int INF=1061109567;\nconst LL LINF=4557430888798830399;\n#define PI 3.1415926535897932384626433832795028841971\n#define MP make_pair\n#define MT make_tuple\n#define All(a) (a).begin(),(a).end()\n#define pall(a) (a).rbegin(),(a).rend()\n#define MOD 1000000007\n#define sz(a) ((int)(a).size())\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define repa(i,a,n) for(int i=a;i<n;i++)\n#define repa1(i,a,n) for(int i=a;i<=n;i++)\n#define repd(i,n) for(int i=n-1;i>=0;i--)\n#define repd1(i,n) for(int i=n;i>=1;i--)\n#define repda(i,n,a) for(int i=n;i>a;i--)\n#define repda1(i,n,a) for(int i=n;i>=a;i--)\n#define FOR(i,a,n,step) for(int i=a;i<n;i+=step)\n#define repv(itr,v) for(__typeof((v).begin()) itr=(v).begin();itr!=(v).end();itr++)\n#define repV(i,v) for(auto i:v)\n#define repE(i,v) for(auto &i:v)\n#define MS(x,y) memset(x,y,sizeof(x))\n#define MC(x) MS(x,0)\n#define MCP(x,y) memcpy(x,y,sizeof(y))\n#define sqr(x) ((x)*(x))\n#define filein(x) freopen(x,\"r\",stdin)\n#define fileout(x) freopen(x,\"w\",stdout)\n#define fileout2(filename,name) ofstream name(filename,ios::out)\n#define filein2(filename,name) ifstream name(filename,ios::in)\n#define file(filename,name) fstream name(filename,ios::in|ios::out)\n#define Pause system(\"pause\")\n#define Cls system(\"cls\")\n#define fs first\n#define sc second\n#define PC(x) putchar(x)\n#define GC(x) x=getchar()\n#define Endl PC('\\n')\n#define SF scanf\n#define PF printf\n\ninline int Read()\n{\n    int X=0,w=0;char ch=0;while(!isdigit(ch)){w|=ch=='-';ch=getchar();}while(isdigit(ch))X=(X<<3)+(X<<1)+(ch^48),ch=getchar();\n\treturn w?-X:X;\n}\ninline void Write(int x){if(x<0)putchar('-'),x=-x;if(x>9)Write(x/10);putchar(x%10+'0');}\n\ninline LL powmod(LL a,LL b){LL res=1;a%=MOD;assert(b>=0);for(;b;b>>=1){if(b&1)res=res*a%MOD;a=a*a%MOD;}return res;}\ninline LL gcdll(LL a,LL b){return b?gcdll(b,a%b):a;}\nconst int dx[]={0,1,0,-1,1,-1,-1,1};\nconst int dy[]={1,0,-1,0,-1,-1,1,1};\n/**************************************************************Begin***************************************************************/\nconst int maxn=2010;\n\nint n,nn,a[maxn],x[maxn];\null g[maxn][maxn],was[maxn];\nbool alive[maxn],canput[maxn];\n\nint main()\n{\n\tSF(\"%d\",&n);\n\trep(i,n) SF(\"%d\",&a[i]);\n\t\n\trep(i,n) rep(j,n) if(__gcd(a[i],a[j])>1)\n\t{\n\t\tg[i][j>>6]|=(1<<(j&63));\n\t\tg[j][i>>6]|=(1<<(i&63));\n\t}\n\t\n\tnn=((n-1)>>6)+1;\n\trep(i,n) alive[i]=canput[i]=1;\n\t\n\trep(it,n)\n\t{\n\t\trep(i,nn) was[i]=0;\n\t\trep(i,n) if(!alive[i]) was[i>>6]|=(1<<(i&63));\n\t\t\n\t\tint best=-1;\n\t\trep(i,n) if(!(was[i>>6]&(1<<(i&63))))\n\t\t{\n\t\t\tint b=0,e=1;\n\t\t\tx[0]=i;\n\t\t\twas[i>>6]|=(1<<(i&63));\n\t\t\t\n\t\t\twhile(b<e)\n\t\t\t{\n\t\t\t\trep(j,nn) if((g[x[b]][j]&was[j])!=g[x[b]][j])\n\t\t\t\t{\n\t\t\t\t\trepa(u,j*64,(j+1)*64) if(g[x[b]][u>>6]&(1<<(u&63))) if(!(was[u>>6]&(1<<(u&63))))\n\t\t\t\t\t{\n\t\t\t\t\t\twas[u>>6]|=(1<<(u&63));\n\t\t\t\t\t\tx[e++]=u;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tb++;\n\t\t\t}\n\t\t\t\n\t\t\tint cur=-1;\n\t\t\trep(j,e) if(canput[x[j]])\n\t\t\t{\n\t\t\t\tif(cur==-1||a[x[j]]<a[cur]) cur=x[j];\n\t\t\t}\n\t\t\t\n\t\t\tif(best==-1||(cur!=-1&&a[cur]>a[best])) best=cur;\n\t\t}\n\t\t\n\t\tPF(\"%d \",a[best]);\n\t\talive[best]=0;\n\t\trep(i,n) if(alive[i])\n\t\t{\n\t\t\tif(g[best][i>>6]&(1<<(i&63))) canput[i]=1;\n\t\t\telse if(a[best]<a[i]) canput[i]=0;\n\t\t}\n\t}\n\n\treturn 0;\n}\n/***************************************************************End****************************************************************/\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\ninline int read(){\n\tint f=1,ans=0;char c=getchar();\n\twhile(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}\n\twhile(c>='0'&&c<='9'){ans=ans*10+c-'0';c=getchar();}\n\treturn ans*f;\n}\nconst int MAXN=2001;\nvector<int> vec[MAXN];\npriority_queue<int> que;\nint N,A[MAXN],M[MAXN][MAXN],vis[MAXN],d[MAXN];\nvoid dfs(int u){\n\tvis[u]=1;\n\tfor(int i=1;i<=N;i++){\n\t\tif(!vis[i]&&M[u][i]){\n\t\t\tvec[u].push_back(i);\n\t\t\tvis[i]=1,d[i]++;dfs(i);\n\t\t}\n\t}return;\n}\nint main(){\n\tN=read();for(int i=1;i<=N;i++) A[i]=read();sort(A+1,A+N+1);\n\tfor(int i=1;i<=N;i++) for(int j=2;j<=N;j++) if(__gcd(A[i],A[j])!=1) M[i][j]=M[j][i]=1;\n\tfor(int i=1;i<=N;i++) if(!vis[i]) dfs(i);\n\tfor(int i=1;i<=N;i++) if(!d[i]) que.push(i);\n\twhile(!que.empty()){\n\t\tint xx=que.top();que.pop();printf(\"%d \",xx);\n\t\tfor(int i=0;i<vec[xx].size();i++){\n\t\t\tint v=vec[xx][i];\n\t\t\td[v]--;if(!d[v]) que.push(v);\n\t\t}\n\t}printf(\"\\n\");return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\nstruct UnionFind{\n  Int n;\n  vector<Int> r,p;\n  UnionFind(Int x,Int y):n(x+y),r(x+y,1),p(x+y,0){\n    iota(p.begin(),p.end(),0);\n    for(Int i=0;i<x;i++) r[i]=1;\n    for(Int i=0;i<y;i++) r[x+i]=0;\n  }\n  Int find(Int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(Int x,Int y){\n    return find(x)==find(y);\n  }\n  void unite(Int x,Int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    if(r[x]<r[y]) swap(x,y);\n    r[x]+=r[y];\n    p[y]=x;\n  }\n};\n\n\ntemplate<typename T> \nmap<T, Int> factorize(T x){\n  map<T, Int> res;\n  for(Int i=2;i*i<=x;i++){\n    while(x%i==0){\n      x/=i;\n      res[i]++;\n    }\n  }\n  if(x!=1) res[x]++;\n  return res;\n}\n\n//INSERT ABOVE HERE\nInt cop[2020][2020];\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<Int> a(n);\n  for(Int i=0;i<n;i++) cin>>a[i];\n  sort(a.begin(),a.end());\n\n  vector<Int> ans(n),used(n,0),post(n,0);\n\n  memset(cop,0,sizeof(cop));\n  \n  for(Int i=0;i<n;i++)\n    for(Int j=0;j<n;j++)\n      cop[i][j]=__gcd(a[i],a[j])>1;\n\n  Int m=0;\n  map<Int, Int> r;\n\n  vector<vector<Int> > G(n);\n  for(Int i=0;i<n;i++){\n    auto x=factorize(a[i]);\n    for(auto p:x){\n      if(!r.count(p.first)) r[p.first]=m++;\n      G[i].emplace_back(r[p.first]);\n    }\n  }\n  \n  for(Int t=0;t<n;t++){\n    UnionFind uf(n,m);\n    for(Int i=0;i<n;i++)\n      if(!used[i]) for(Int j:G[i]) uf.unite(i,n+j);\n    \n    Int idx=-1,sum=t;\n    set<Int> tmp;\n    for(Int i=0;i<n;i++){\n      if(used[i]) continue;\n      Int k=uf.find(i);\n      if(!tmp.count(k)){\n\ttmp.emplace(k);\n\tsum+=uf.r[k];\n      }\n      if(post[i]) continue;\n      if(sum==n){\n\tidx=i;\n\tbreak;\n      }\n    }\n    assert(sum==n);\n    while(idx<0);\n    used[idx]=1;\n    ans[t]=idx;\n    \n    for(Int i=0;i<n;i++)\n      if(cop[idx][i]) post[i]=0;\n      else if(a[idx]<a[i]) post[i]=1;\n  }\n  for(Int i=0;i<n;i++){\n    if(i) cout<<\" \";\n    cout<<a[ans[i]];\n  }\n  cout<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<queue>\n#include<vector>\nusing namespace std;\nconst int maxn=2003;\nint a[maxn],n,g[maxn][maxn],vis[maxn],in[maxn];\nvector<int>G[maxn];\nint gcd(int a,int b) { return a==0?b:gcd(b%a,a); }\nvoid dfs(int now)\n{\n    vis[now]=1;\n    for(int i=1;i<=n;i++)\n        if(!vis[i] and g[now][i])\n        {\n            in[i]++;\n            G[now].push_back(i);\n            dfs(i);\n        }\n}\nvoid Top()\n{\n    priority_queue<int>que;\n    for(int i=1;i<=n;i++) if(!in[i]) que.push(i);\n    while(!que.empty())\n    {\n        int x=que.top(); que.pop();\n        cout<<a[x]<<' ';\n        for(int i=0;i<(int)G[x].size();i++)\n            que.push(G[x][i]);\n    }\n}\nint main()\n{\n    //freopen(\"t.in\",\"r\",stdin);\n    //freopen(\"t.out\",\"w\",stdout);\n    cin>>n;\n    for(int i=1;i<=n;i++)\n        cin>>a[i];\n    sort(a+1,a+n+1);\n    for(int i=1;i<=n;i++)\n        for(int j=i+1;j<=n;j++)\n            if(gcd(a[i],a[j])!=1)\n                g[i][j]=g[j][i]=1;\n    for(int i=1;i<=n;i++)\n        if(!vis[i])\n            dfs(i);\n    Top();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int maxn = 2030, oo = 123456789, maxm = 54010;\n\nint n, m, T, ans, mn, a[maxn], foo[maxn], lst[maxm], tag[maxn];\nbool vis[maxn], f[maxn], G[maxn][maxn], F[maxn];\nstd::vector<int> g[maxn], has[maxn], rhas[maxm], all;\nstd::vector<std::pair<int, int> > v;\n\nvoid GEN() {\n\tint mx = 0;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif(!foo[i]) {\n\t\t\tif(a[i] == 1) {\n\t\t\t\tF[i] = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tF[i] = 0;\n\t\t\tfor (int j: has[i]) {\n\t\t\t\tif(lst[j] >= mx) {\n\t\t\t\t\tF[i] = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t(foo[i] > mx) && (mx = foo[i]);\n\t\t}\n\t}\n\treturn;\n}\n\nvoid dfs(int u) {\n\ttag[u] = T;\n\tif(a[u] < mn) {\n\t\tmn = a[u];\n\t}\n\tvis[u] = 1;\n\tfor (int v: g[u]) {\n\t\tif(!vis[v] && !f[v]) {\n\t\t\tdfs(v);\n\t\t}\n\t}\n\treturn;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tscanf(\"%d\", a + i);\n\t\tint t = a[i];\n\t\tfor (int x = 2; x * x <= t; ++x) {\n\t\t\tif(t % x == 0) {\n\t\t\t\tall.push_back(x);\n\t\t\t\twhile(t % x == 0) {\n\t\t\t\t\tt /= x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(t > 1) {\n\t\t\tall.push_back(t);\n\t\t}\n\t}\n\tstd::sort(a + 1, a + n + 1);\n\tstd::sort(all.begin(), all.end());\n\tall.resize(std::unique(all.begin(), all.end()) - all.begin());\n\tm = (int)(all.size());\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tif(a[i] % all[j] == 0) {\n\t\t\t\thas[i].push_back(j);\n\t\t\t\trhas[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int j = 0; j < m; ++j) {\n\t\tfor (int i = 0; i < (int)(rhas[j].size()); ++i) {\n\t\t\tfor (int k = 0; k < i; ++k) {\n\t\t\t\tint u = rhas[j][i], v = rhas[j][k];\n\t\t\t\tif(!G[u][v]) {\n\t\t\t\t\tg[u].push_back(v);\n\t\t\t\t\tg[v].push_back(u);\n\t\t\t\t\tG[u][v] = G[v][u] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tGEN();\n\t\tmemset(vis + 1, 0, sizeof(vis[0]) * n);\n\t\tv.clear();\n\t\tfor (int u = 1; u <= n; ++u) {\n\t\t\tif(F[u]) {\n\t\t\t\tif(!vis[u] && !f[u]) {\n\t\t\t\t\t++T;\n\t\t\t\t\tmn = oo;\n\t\t\t\t\tdfs(u);\n\t\t\t\t\tv.push_back(std::make_pair(mn, T));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstd::sort(v.begin(), v.end());\n\t\tint sz = (int)(v.size());\n\t\tans = 0;\n\t\tfor (int u = 1; u <= n; ++u) {\n\t\t\tif(F[u] && !f[u]) {\n\t\t\t\tint i = sz - 1;\n\t\t\t\tif(v[i].second == tag[u]) {\n\t\t\t\t\t--i;\n\t\t\t\t}\n\t\t\t\tif(i < 0 || v[i].first <= a[u]) {\n\t\t\t\t\tans = u;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tassert(ans);\n\t\tf[ans] = 1;\n\t\tfoo[ans] = i;\n\t\tprintf(\"%d \", a[ans]);\n\t\tfor (int j: has[ans]) {\n\t\t\tlst[j] = i;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define SZ(x) ((int)x.size())\n\nconst int N = 2010;\n\nint vis[N], ok[N][N], in[N], a[N];\nvector<int> g[N];\nint n;\n\nvoid dfs(int rt) {\n  vis[rt] = 1;\n  for (int i = 1; i <= n; i++)\n    if (!vis[i] && ok[rt][i]) {\n      in[i]++;\n      g[rt].pb(i);\n      dfs(i);\n    }\n}\n\nvoid Top() {\n  priority_queue<int> q;\n  for (int i = 1; i <= n; i++)\n    if (!in[i]) q.push(i);\n  while (!q.empty()) {\n    int now = q.top();\n    q.pop();\n    cout << a[now] << \" \";\n    for (int i = 0; i < SZ(g[now]); i++) q.push(g[now][i]);\n  }\n}\n\nsigned main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n  sort(a + 1, a + n + 1);\n  for (int i = 1; i <= n; i++)\n    for (int j = i + 1; j <= n; j++)\n      if (__gcd(a[i], a[j]) != 1) ok[i][j] = ok[j][i] = 1;\n  for (int i = 1; i <= n; i++)\n    if (!vis[i]) dfs(i);\n  Top();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<queue>\n#define fo(i,a,b) for(i=a;i<=b;i++)\nusing namespace std;\nconst int maxn=2000+10;\nstruct dong{\n\tint x,y;\n\tfriend bool operator <(dong a,dong b){\n\t\treturn a.x<b.x;\n\t}\n} zlt;\npriority_queue<dong> dl;\nbool bz[maxn][maxn],pd[maxn];\nint a[maxn],d[maxn];\nint h[maxn],go[maxn*maxn],nxt[maxn*maxn];\nint i,j,k,l,t,n,m,tot,now;\nint gcd(int a,int b){\n\treturn b?gcd(b,a%b):a;\n}\nvoid add(int x,int y){\n\td[y]++;\n\tgo[++tot]=y;\n\tnxt[tot]=h[x];\n\th[x]=tot;\n}\nvoid dfs(int x){\n\tpd[x]=1;\n\tint i;\n\tfo(i,1,n)\n\t\tif (bz[x][i]&&!pd[i]){\n\t\t\tadd(x,i);\n\t\t\tdfs(i);\n\t\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfo(i,1,n) scanf(\"%d\",&a[i]);\n\tsort(a+1,a+n+1);\n\tfo(i,1,n-1)\n\t\tfo(j,i+1,n)\n\t\t\tif (gcd(a[i],a[j])>1) bz[i][j]=bz[j][i]=1;\n\tfo(i,1,n)\n\t\tif (!pd[i]) dfs(i);\n\tfo(i,1,n)\n\t\tif (!d[i]){\n\t\t\tzlt.x=a[i];\n\t\t\tzlt.y=i;\n\t\t\tdl.push(zlt);\n\t\t}\n\tfo(i,1,n){\n\t\tzlt=dl.top();\n\t\tdl.pop();\n\t\tnow=zlt.y;\n\t\tprintf(\"%d \",a[now]);\n\t\tt=h[now];\n\t\twhile (t){\n\t\t\td[go[t]]--;\n\t\t\tif (!d[go[t]]){\n\t\t\t\tzlt.x=a[go[t]];\n\t\t\t\tzlt.y=go[t];\n\t\t\t\tdl.push(zlt);\n\t\t\t}\n\t\t\tt=nxt[t];\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cassert>\n#include<cmath>\n#include<queue>\n#define ll long long\nusing namespace std;\ninline int read(){\n\tint re=0,flag=1;char ch=getchar();\n\twhile(ch>'9'||ch<'0'){\n\t\tif(ch=='-') flag=-1;\n\t\tch=getchar();\n\t}\n\twhile(ch>='0'&&ch<='9') re=(re<<1)+(re<<3)+ch-'0',ch=getchar();\n\treturn re*flag;\n}\nint n,g[2010][2010],a[2010],vis[2010],in[2010];\nint first[2010],cnte;\nstruct edge{\n\tint to,next;\n}e[10010];\ninline void add(int u,int v){\n\te[++cnte]=(edge){v,first[u]};first[u]=cnte;in[v]++;\n}\nint gcd(int x,int y){\n\tif(y==0) return x;\n\treturn gcd(y,x%y);\n}\nvoid dfs(int u){\n//\tcout<<\"dfs \"<<u<<'\\n';\n\tvis[u]=1;int i;\n\tfor(i=1;i<=n;i++){\n//\t\tcout<<\"\ttry \"<<i<<\" from \"<<u<<' '<<g[u][i]<<'\\n';\n\t\tif(!vis[i]&&!g[u][i]) add(u,i),dfs(i);\n\t}\n}\nstruct gaygayquan{\n\tint val,id;\n};\ninline bool operator <(gaygayquan x,gaygayquan b){\n\treturn x.val<b.val;\n}\ngaygayquan mp(int l,int r){\n\treturn (gaygayquan){l,r};\n}\npriority_queue<gaygayquan>q;\nint main(){\n\tmemset(first,-1,sizeof(first));\n\tn=read();int i,j,v;gaygayquan gay;\n\tfor(i=1;i<=n;i++) a[i]=read();\n\tsort(a+1,a+n+1);\n\tfor(i=1;i<=n;i++){\n\t\tfor(j=1;j<i;j++){\n\t\t\tif(gcd(a[i],a[j])==1) g[i][j]=g[j][i]=1;\n//\t\t\tcout<<i<<' '<<j<<' '<<a[i]<<' '<<a[j]<<' '<<g[i][j]<<'\\n';\n\t\t}\n\t}\n\tfor(i=1;i<=n;i++) if(!vis[i]) dfs(i);\n\tfor(i=1;i<=n;i++) if(!in[i]) q.push(mp(a[i],i));\n\twhile(!q.empty()){\n\t\tgay=q.top();q.pop();\n\t\tprintf(\"%d \",gay.val);\n\t\tfor(i=first[gay.id];~i;i=e[i].next){\n\t\t\tv=e[i].to;in[v]--;\n\t\t\tif(in[v]==0) q.push(mp(a[v],v));\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint gcd(int a, int b){\n\treturn b == 0 ? a : gcd(b, a % b);\n}\n\nvector <int> combine(const vector <int> &a, const vector <int> &b){\n\tvector <int> res;\n\tmerge(a.begin(), a.end(), b.begin(), b.end(), res.begin(), greater <int>());\n}\n\nint vis[2010];\nint n, e[2010][2010];\nint a[2010];\n\nvector <int> dfs(int x){\n\tvis[x] = 1;\n\tvector <int> res;\n\tfor (int v = 0; v < n; v++){\n\t\tif (vis[v] || !e[x][v]) continue;\n\t\tres = combine(res, dfs(v));\n\t}\n\treturn res;\n}\n\nint main(){\n\tscanf(\"%d\", n);\n\tfor (int i = 0; i < n; i++){\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\tfor (int i = 0; i <= n; i++){\n\t\tfor (int j = 0; j <= n; j++){\n\t\t\te[i][j] = i != j && (i == n || j == n || gcd(a[i], a[j]) != 1);\n\t\t}\n\t}\n\tvector <int> res = dfs(n);\n\tfor (int i = 0; i < n; i++){\n\t\tprintf(\"%d \", res[i]);\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<set>\n#include<unordered_set>\n#define lol(i,n) for(ll i=0;i<n;i++)\n#define mod 1000000007\n#define chmax(a,b) a=max(a,b);\n#define chmin(a,b) a=min(a,b);\ntypedef long long ll;\n\nusing namespace std;\nll gcd(ll a,ll b){\n  if(a<b)swap(a,b);\n  if(b==0)return a;\n  return gcd(a%b,b);\n}\nbool edge(ll a,ll b){\n  return gcd(a,b)>1;\n}\n#define N 2010\nll b[N],a[N],n;\nvector<ll> g[N];\n\nclass Aoki{\n  public:\n  ll nz[N];\n  void buildg(){\n    lol(i,n)g[i].clear();\n    lol(i,n)lol(j,i){\n      if(edge(b[i],b[j])){\n\tg[j].push_back(i);\n\tnz[i]++;\n      }\n    }\n  }\n  void main(){\n    lol(i,n)nz[i]=0;\n    buildg();\n    //cout<<\"b=\";lol(i,n)cout<<b[i]<<\" \";cout<<endl;\n    //lol(i,n)cout<<nz[i]<<\" \";cout<<endl;\n    priority_queue<pair<ll,ll> >Q;\n    lol(i,n)if(nz[i]==0)Q.push(make_pair(b[i],i));\n    vector<ll> res;\n    unordered_set<ll> vis;\n    while(!Q.empty()){\n      ll val=Q.top().first;\n      ll x=Q.top().second;\n      Q.pop();\n      if(vis.find(x)!=vis.end())continue;\n      vis.insert(x);\n      res.push_back(val);\n      for(auto y:g[x]){\n\tnz[y]--;\n\tif(nz[y]==0)Q.push(make_pair(b[y],y));\n      }\n    }\n    lol(i,n){\n      if(i)cout<<\" \";\n      cout<<res[i];\n    }cout<<endl;\n  }\n};Aoki kensho;\n\nclass Takahashi{\n  public:\n  bool used[N];\n  void buildg(){\n    lol(i,n)g[i].clear();\n    lol(i,n)lol(j,n){\n      if(used[i])continue;\n      if(used[j])continue;\n      if(i!=j&&edge(a[i],a[j])){\n\tg[i].push_back(j);\n      }\n    }\n    //cout<<\"g2=\";for(auto x:g[2])cout<<x<<\" \";cout<<endl;\n  }\n  unordered_set<ll> vis;\n  ll dfs(ll x){\n    if(vis.find(x)!=vis.end())return mod;\n    vis.insert(x);\n    ll res=x;\n    for(auto y:g[x]){\n      chmin(res,dfs(y));\n    }\n    return res;\n  }\n  ll ma[N];\n  void upd(ll x,ll val){\n    if(~ma[x])return;\n    ma[x]=val;\n    for(auto y:g[x]){\n      upd(y,val);\n    }\n  }\n  \n  vector<ll> res;\n  void sub(){\n    buildg();\n    //cout<<\"buildend\"<<endl;\n    lol(i,n)ma[i]=-1;\n    lol(i,n){\n      if(vis.find(i)!=vis.end())continue;\n      upd(i,dfs(i));\n    }\n    //cout<<\"ma=\";lol(i,n)cout<<ma[i]<<\" \";cout<<endl;\n    //cout<<\"dfsend\"<<endl;\n    //priority_queue<ll,vector<ll>,greater<ll> >Q;\n    queue<ll> Q;\n    lol(i,n){\n      if(i==ma[i])Q.push(i);\n    }\n    vis.clear();\n    while(!Q.empty()){\n      ll x=Q.front(); Q.pop();\n      if(vis.find(x)!=vis.end())continue;\n      vis.insert(x);\n      used[x]=1;\n      //cout<<x<<\" \";\n      res.push_back(x);\n      ll mini=1e18;\n      for(auto y:g[x]){\n\tif(!used[y])\n\tchmin(mini,y);\n      }\n      if(mini<1e18)Q.push(mini);\n    }//cout<<endl;\n    //cout<<\"#\"<<res.size()<<endl;\n    //cout<<\"a=\";lol(i,n)cout<<res[i]<<\" \";cout<<endl;\n  }\n  void main(){\n    lol(i,n)used[i]=0;\n    while(1){\n      bool ok=0;\n      lol(i,n)if(used[i]==0)ok=1;\n      if(!ok)break;\n      sub();\n    }\n    //cout<<\"#\"<<res.size()<<endl;\n    //cout<<\"a=\";lol(i,n)cout<<res[i]<<\" \";cout<<endl;\n    lol(i,n)b[i]=a[res[i]];\n    //cout<<\"b=\";lol(i,n)cout<<b[i]<<\" \";cout<<endl;\n  }\n};Takahashi chokudai;\n\nint main(){\n    cin>>n;\n    lol(i,n)cin>>a[i];\n    sort(a,a+n);\n    chokudai.main();\n    //cout<<\"chokudai-end\"<<endl;\n    kensho.main();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<cstring>\n#include<algorithm>\n#include<stack>\n#define fo(i,a,b) for(i=a;i<=b;i++)\n#define ll long long\nusing namespace std;\nint n,a[2005],tot,du[2005],h[2005],to[4000005],nex[4000005];\nbool bhz[2005][2005],pd[2005];\nint gcd(int a,int b)\n{\n    return b?gcd(b,a%b):a;\n}\nstruct node{\n    int fr,id;\n}st;\nbool operator <(node a,node b)\n{\n    return a.fr<b.fr;\n}\nstack<node> q;\nvoid add(int a,int b)\n{\n    du[b]++;\n    to[++tot]=b;\n    nex[tot]=h[a];\n    h[a]=tot;\n}\nvoid dfs(int x)\n{\n    pd[x]=1;\n    for(int i=1;i<=n;i++)\n        if(bhz[x][i]&&!pd[i])\n        {\n            add(x,i);\n            dfs(i);\n        }\n}\nint main()\n{\n    cin>>n;\n    for(int i=1;i<=n;i++) cin>>a[i];\n    sort(a+1,a+n+1);\n    for(int i=1;i<=n-1;i++)\n    for(int j=i+1;j<=n;j++)\n    if(gcd(a[i],a[j])>1) bhz[i][j]=bhz[j][i]=1;\n    for(int i=1;i<=n;i++) if(!pd[i]) dfs(i);\n    for(int i=1;i<=n;i++) \n        if(!du[i])\n        { \n            st.fr=a[i];\n            st.id=i;\n            q.push(st); \n        }\n    for(int i=1;i<=n;i++)\n    {\n        st=q.top();\n        q.pop();\n        int now=st.id;\n        cout<<a[now]<<\" \";\n        int t=h[now];\n        while (t){\n            du[to[t]]--;\n            if (!du[to[t]]){\n                st.fr=a[to[t]];\n                st.id=to[t];\n                q.push(st);\n            }\n            t=nex[t];\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\ncat <<EOF >mistaken-paste\n*/\n\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <time.h>\n\n#define BIG 2000000007\n#define VERYBIG 2000000000000007LL\n\n#define MOD 1000000007\n#define FOD  998244353\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\n#define N_MAX 1000000\n#define M_MAX 200000\n\n#ifdef __cplusplus\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <array>\n\nusing std::queue;\nusing std::priority_queue;\nusing std::stack;\nusing std::tuple;\nusing std::set;\nusing std::map;\nusing std::vector;\nusing std::greater;\nusing std::pair;\nusing std::string;\n\n#endif\n\ntypedef struct {\n\tint32_t a;\n\tint32_t b;\n} hw;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n} hwll;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n\tsll c;\n} hwllc;\n\ntypedef struct {\n\thwll a;\n\thwll b;\n} linell;\n\null n, m;\null h, w;\null k;\null q;\nsll va, vb, vc, vd, ve, vf;\null ua, ub, uc, ud, ue, uf;\nlong double vra, vrb, vrc;\ndouble vda, vdb, vdc;\nchar ch, dh;\n\null umin (ull x, ull y) {\n\treturn (x < y) ? x : y;\n}\n\null umax (ull x, ull y) {\n\treturn (x > y) ? x : y;\n}\n\nsll smin (sll x, sll y) {\n\treturn (x < y) ? x : y;\n}\n\nsll smax (sll x, sll y) {\n\treturn (x > y) ? x : y;\n}\n\null gcd (ull x, ull y) {\n\tif (x < y) {\n\t\treturn gcd(y, x);\n\t} else if (y == 0) {\n\t\treturn x;\n\t} else {\n\t\treturn gcd(y, x % y);\n\t}\n}\n\null bitpow (ull a, ull x, ull modulo) {\n\tull result = 1;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tresult *= a;\n\t\t\tresult %= modulo;\n\t\t}\n\t\tx /= 2;\n\t\ta = (a * a) % modulo;\n\t}\n\treturn result;\n}\n\null divide (ull a, ull b, ull modulo) {\n\treturn (a * bitpow(b, modulo - 2, modulo)) % modulo;\n}\n\null udiff (ull a, ull b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nsll sdiff (sll a, sll b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nint bitcount (ull n) {\n\tint result = 0;\n\twhile (n) {\n\t\tif (n & 1) result++;\n\t\tn /= 2;\n\t}\n\treturn result;\n}\n\n// double distance (sll x1, sll y1, sll x2, sll y2) {\n// \tdouble xdist2, ydist2, origindist, dist;\n\n// \txdist2 = (x1 - x2) * (x1 - x2);\n// \tydist2 = (y1 - y2) * (y1 - y2);\n// \treturn sqrt(xdist2 + ydist2);\n// }\n\nint32_t pullcomp (const void *left, const void *right) {\n\tull l = *(ull*)left;\n\tull r = *(ull*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t psllcomp (const void *left, const void *right) {\n\tsll l = *(sll*)left;\n\tsll r = *(sll*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t pcharcomp (const void *left, const void *right) {\n\tchar l = *(char*)left;\n\tchar r = *(char*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t pdoublecomp (const void *left, const void *right) {\n\tdouble l = *(double*)left;\n\tdouble r = *(double*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t pstrcomp (const void *left, const void *right) {\n\tchar* l = *(char**)left;\n\tchar* r = *(char**)right;\n\n\treturn strcmp(l, r);\n}\n\nint32_t phwllABcomp (const void *left, const void *right) {\n\thwll l = *(hwll*)left;\n\thwll r = *(hwll*)right;\n\tif (l.a < r.a) {\n\t\treturn -1;\n\t}\n\tif (l.a > r.a) {\n\t\treturn +1;\n\t}\n\tif (l.b < r.b) {\n\t\treturn -1;\n\t}\n\tif (l.b > r.b) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t phwllREVcomp (const void *left, const void *right) {\n\thwll l = *(hwll*)left;\n\thwll r = *(hwll*)right;\n\tif (l.b < r.b) {\n\t\treturn -1;\n\t}\n\tif (l.b > r.b) {\n\t\treturn +1;\n\t}\n\tif (l.a < r.a) {\n\t\treturn -1;\n\t}\n\tif (l.a > r.a) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t ptriplecomp (const void *left, const void *right) {\n\thwllc l = *(hwllc*)left;\n\thwllc r = *(hwllc*)right;\n\n\tif (l.a < r.a) {\n\t\treturn -1;\n\t}\n\tif (l.a > r.a) {\n\t\treturn +1;\n\t}\n\tif (l.b < r.b) {\n\t\treturn -1;\n\t}\n\tif (l.b > r.b) {\n\t\treturn +1;\n\t}\n\tif (l.c < r.c) {\n\t\treturn -1;\n\t}\n\tif (l.c > r.c) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nbool isinrange (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right);\n}\n\nbool isinrange_soft (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right) || (left >= x && x >= right);\n}\n\nsll a[N_MAX];\n// sll a[3001][3001];\nsll b[N_MAX];\n// sll b[3001][3001];\nsll c[N_MAX];\n// sll d[N_MAX];\n// sll e[N_MAX];\nchar s[N_MAX + 1];\n// char s[3010][3010];\nchar t[N_MAX + 1];\n// char t[3010][3010];\n// hwll xy[N_MAX];\n// sll table[1000][1000];\n\nset<ull> g[2002];\nbool iscoprime[2002][2002];\n\nbool iswatched[2002];\null labels[2002];\null id = 0;\nvoid toggle (ull v, bool x, ull id) {\n\tif (iswatched[v] == x) return;\n\n\tiswatched[v] = x;\n\tlabels[v] = id;\n\tfor (ull u : g[v]) {\n\t\ttoggle(u, x, id);\n\t}\n}\n\ntypedef pair<ull, ull> P;\nvector<ull> merge(vector<vector<ull>> x) {\n\tvector<ull> v;\n\n\tull curr[x.size()];\n\tpriority_queue<P, vector<P> > que;\n\tfor (ull i = 0; i < x.size(); i++) {\n\t\tcurr[i] = 0;\n\t\tque.push(P(x[i][0], i));\n\t}\n\twhile (!que.empty()) {\n\t\tP p = que.top();\n\t\tque.pop();\n\n\t\tv.push_back(p.first);\n\t\tull i = p.second;\n\t\tif (++curr[i] < x[i].size()) {\n\t\t\tque.push(P(x[i][curr[i]], i));\n\t\t}\n\t}\n\n\treturn v;\n}\n\nvector<ull> func (ull v) {\n\tvector<ull> r;\n\t\n\tset<ull> s = g[v];\n\tpriority_queue<ull, vector<ull>, greater<ull> > que;\n\ttoggle(v, false, id++);\n\tfor (ull u : s) {\n\t\tg[u].erase(v);\n\t\tque.push(u);\n\t}\n\n\tvector<vector<ull>> vs;\n\twhile (!que.empty()) {\n\t\tull u = que.top();\n\t\tque.pop();\n\t\tif (iswatched[u]) continue;\n\n\t\ttoggle(u, true, id++);\n\t\tvs.push_back(func(u));\n\t}\n\tiswatched[v] = true;\n\n\tr = merge(vs);\n\tr.insert(r.begin(), v);\n\n\treturn r;\n}\n\null solve () {\n\tsll i, j, ki, li;\n\tull result = 0;\n\t// sll result = 0;\n\tdouble dresult = 0;\n\t// ull maybe = 0;\n\tsll maybe = 0;\n\t// ull sum = 0;\n\tsll sum = 0;\n\tsll item;\n\tull *dpcell;\n\n\tqsort(a, n, sizeof(ull), pullcomp);\n\n\tfor (i = 0; i < n; i++) {\n\t\tfor (j = 0; j < n; j++) {\n\t\t\tif (i != j && gcd(a[i], a[j]) > 1) {\n\t\t\t\tg[i].insert(j);\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<vector<ull>> finals;\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (iswatched[i]) continue;\n\n\t\ttoggle(i, true, id++);\n\t\tfinals.push_back(func(i));\n\t\t// for (j = 0; j < finals[finals.size() - 1].size(); j++) printf(\"%llu \", finals[finals.size() - 1][j]);\n\t\t// \tputs(\"\");\n\t\t// fflush(stdout);\n\t}\n\tvector<ull> r = merge(finals);\n\tfor (i = 0; i < n; i++) {\n\t\tprintf(\"%llu%c\", a[r[i]], (i == n - 1 ? '\\n' : ' '));\n\t}\n\n\t// printf(\"%lld\\n\", result);\n\t// printf(\"%.15lf\\n\", dresult);\n\t// puts(s);\n\n\treturn 0;\n\n\tsuccess:\n\t// puts(\"YES\");\n\tputs(\"Yes\");\n\t// printf(\"%llu\\n\", result);\n\t// puts(\"0\");\n\t// puts(\"Yay!\");\n\treturn 0;\n\n\tfail:\n\t// puts(\"NO\");\n\tputs(\"No\");\n\t// puts(\"0\");\n\t// puts(\"-1\");\n\t// puts(\"-1 -1 -1\");\n\t// puts(\":(\");\n\treturn 1;\n}\n\nint32_t main (void) {\n\tint32_t i, j;\n\tint32_t x, y;\n\n\tscanf(\"%llu\", &n, &m);\n\t// scanf(\"%llu\", &k, &n, &m);\n\t// scanf(\"%llu%llu\", &h, &w);\n\t// scanf(\"%lld\", &va, &vb, &vc, &vd);\n\t// scanf(\"%llu%llu\", &ua, &ub, &uc, &ud);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%s\", s);\n\t// scanf(\"%s\", t);\n\tfor (i = 0; i < n; i++) {\n\t\t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t\tscanf(\"%lld\", &a[i]);\n\t\t// scanf(\"%lld\", &b[i]);\n\t\t// scanf(\"%lld\", &c[i]);\n\t\t// scanf(\"%lld\", &d[i]);\n\t\t// a[i]--;\n\t\t// b[i]--;\n\t\t// c[i]--;\n\t}\n\t// scanf(\"%llu\", &m, &k);\n\t// scanf(\"%llu\", &q);\n\t// for (i = 0; i < n; i++) {\n\t// \tscanf(\"%lld\", &b[i]);\n\t// }\n\n\t// for (i = 0; i < h; i++) {\n\t// \tfor (j = 0; j < w; j++) {\n\t// \t\tscanf(\"%llu\", &table[i][j]);\n\t// \t}\n\t// }\n\t// for (i = 0; i < h; i++) {\n\t// \tscanf(\"%s\", &s[i]);\n\t// }\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <queue>\n\n#define Rep(i, n) for (int i = 1; i <= n; i ++)\n#define Rep0(i, n) for (int i = 0; i <= n; i ++)\n#define mp(a, b) make_pair(a, b)\n\nusing namespace std;\n\nconst int N = 2010;\n\nvector<int> e[N], e0[N];\nint dep[N], d[N], a[N];\nbool vis[N], vis0[N];\n\nint dfs0(int x)\n{\n\tvis0[x] = true;\n\tint ret = x;\n\tif (e[x].size()) Rep0(i, e[x].size() - 1)\n\t\tif (!vis0[e[x][i]]) ret = min(ret, dfs0(e[x][i]));\n\treturn ret;\n}\n\nvoid dfs(int x, int f)\n{\n\tvis[x] = true, dep[x] = dep[f] + 1;\n\tif (e[x].size()) Rep0(i, e[x].size() - 1) {\n\t\tif (!vis[e[x][i]]) dfs(e[x][i], x);\n\t\tif (dep[e[x][i]] > dep[x]) e0[x].push_back(e[x][i]), d[e[x][i]] ++;\n\t\telse e0[e[x][i]].push_back(x), d[x] ++;\n\t}\n}\n\nint gcd(int a, int b) { return !b ? a : gcd(b, a % b);}\n\npriority_queue< pair<int, int> > q;\n\nint main()\n{\n//\tfreopen(\"mmp_.in\", \"r\", stdin);\n//\tfreopen(\"mmp_.out\", \"w\", stdout);\n\n\tint n;\n\tscanf(\"%d\", &n);\n\tRep(i, n) scanf(\"%d\", &a[i]);\n\tRep(i, n) Rep(j, i - 1)\n\t\tif (gcd(a[i], a[j]) != 1){\n\t\t\te[i].push_back(j), e[j].push_back(i);\n\t\t//\tprintf(\"%d ---> %d\\n\", i, j);\n\t\t}\n\t\n\tRep(i, n) sort(e[i].begin(), e[i].end());\n\n\tRep(i, n) if (!vis[i]) dfs(dfs0(i), 0);\n\n\tRep(i, n) if (!d[i]) q.push(mp(a[i], i));\n\n\twhile(!q.empty()) {\n\t\tint x = q.top().second; q.pop();\n\t\tprintf(\"%d \", a[x]);\n\t\tif (e0[x].size()) Rep0(i, e0[x].size() - 1) {\n\t\t\td[e0[x][i]] --;\n\t\t\tif (!d[e0[x][i]]) q.push(mp(a[e0[x][i]], e0[x][i]));\n\t\t}\n\t}\n\tprintf(\"\\n\");\n\n\treturn 0;\n}\n/*\n5\n1 2 3 4 5\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define sim template < class c\n#define ris return * this\n#define dor > debug & operator <<\n#define eni(x) sim > typename \\\n  enable_if<sizeof dud<c>(0) x 1, debug&>::type operator<<(c i) {\nsim > struct rge { c b, e; };\nsim > rge<c> range(c i, c j) { return rge<c>{i, j}; }\nsim > auto dud(c* x) -> decltype(cerr << *x, 0);\nsim > char dud(...);\nstruct debug {\n#ifdef LOCAL\n~debug() { cerr << endl; }\neni(!=) cerr << boolalpha << i; ris; }\neni(==) ris << range(begin(i), end(i)); }\nsim, class b dor(pair < b, c > d) {\n  ris << \"(\" << d.first << \", \" << d.second << \")\";\n}\nsim dor(rge<c> d) {\n  *this << \"[\";\n  for (auto it = d.b; it != d.e; ++it)\n    *this << \", \" + 2 * (it == d.b) << *it;\n  ris << \"]\";\n}\n#else\nsim dor(const c&) { ris; }\n#endif\n};\n\n#define imie(...) \" [\" << #__VA_ARGS__ \": \" << (__VA_ARGS__) << \"] \"\n\nconst int d=60;\nconst int k=35;\nconst long long jed=1;\n\nstruct bi\n{\n\tlong long tab[k];\n\tbi()\n\t{\n\t\tfor (int i=0; i<k; i++)\n\t\t\ttab[i]=0;\n\t}\n\tvoid zmien(int v)\n\t{\n\t\ttab[v/k]^=(jed<<(v%k));\n\t}\n\tint pytaj(int v)\n\t{\n\t\treturn (tab[v/k]&(jed<<(v%k)))>0;\n\t}\n\tvoid end(bi &v)\n\t{\n\t\tfor (int i=0; i<k; i++)\n\t\t\ttab[i]&=v.tab[i];\n\t}\n\tvoid oru(bi &v)\n\t{\n\t\tfor (int i=0; i<k; i++)\n\t\t\ttab[i]|=v.tab[i];\n\t}\n\tvoid xoru(bi &v)\n\t{\n\t\tfor (int i=0; i<k; i++)\n\t\t\ttab[i]^=v.tab[i];\n\t}\n\tint licz()\n\t{\n\t\tint ret=0;\n\t\tfor (int i=0; i<k; i++)\n\t\t\tret+=__builtin_popcountll(tab[i]);\n\t\treturn ret;\n\t}\n\tint skrajnie()\n\t{\n\t\tfor (int i=0; i<k; i++)\n\t\t{\n\t\t\tif (!tab[i])\n\t\t\t\tcontinue;\n\t\t\tfor (int j=0; j<d; j++)\n\t\t\t\tif (tab[i]&(jed<<j))\n\t\t\t\t\treturn d*i+j;\n\t\t}\n\t\treturn -1;\n\t}\n};\n\nconst int nax=2007;\n\nint n;\nint tab[nax];\n\nint juz[nax];\n\nbi bity[nax], odw, aktu;\nbi pom;\n\nvector <int> wyn;\n\nvoid jebaj()\n{\n\twhile(odw.licz()!=aktu.licz())\n\t{\n\t\tpom=odw;\n\t\tpom.xoru(aktu);\n\t\tint x=pom.skrajnie();\n\t\t\tdebug() << x;\n\t\taktu.zmien(x);\n\t\todw.oru(bity[x]);\n\t}\n}\n\nint mozna(int v)\n{\n\tfor (int i=(int)wyn.size()-1; i>=0; i--)\n\t{\n\t\tif (bity[v].pytaj(wyn[i]))\n\t\t\treturn 1;\n\t\tif (wyn[i]<v)\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i=1; i<=n; i++)\n\t\tscanf(\"%d\", &tab[i]);\n\tsort(tab+1, tab+1+n);\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=1; j<=n; j++)\n\t\t\tif (__gcd(tab[i], tab[j])>1 || i==j)\n\t\t\t\tbity[i].zmien(j);\n\tfor (int h=1; h<=n; h++)\n\t{\n\t\todw=bi();\n\t\taktu=bi();\n\t\tfor (int i=1; i<=n; i++)\n\t\t\tif (juz[i])\n\t\t\t\taktu.zmien(i);\n\t\todw=aktu;\n\t\tdebug() << imie(h);\n\t\tfor (int i=1; i<=n; i++)\n\t\t{\n\t\t\tif (juz[i])\n\t\t\t\tcontinue;\n\t\t\todw.oru(bity[i]);\n\t\t\tjebaj();\n\t\t\tif (aktu.licz()==n && mozna(i))\n\t\t\t{\n\t\t\t\tjuz[i]=1;\n\t\t\t\tprintf(\"%d \", tab[i]);\n\t\t\t\twyn.push_back(i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nint cnt,n,a[101010],du[101010],to[101010],nxt[101010],fir[101010];\npriority_queue<pair<int,int> > q;\npriority_queue<int,vector<int>,greater<int> > eg[101010];\nbool bok[101010];\nvoid add(int x,int y)\n{\n\tnxt[++cnt]=fir[x];fir[x]=cnt;\n\tto[cnt]=y; du[y]++;\n}\nint gcd(int x,int y){ return y?gcd(y,x%y):x;}\nvoid top()\n{\n\tfor(int i=1;i<=n;i++) \n\t\tif(!du[i]) q.push(make_pair(a[i],i));\n\twhile(!q.empty())\n\t{\n\t\tint x=q.top().second;q.pop();\n\t\tprintf(\"%d \",a[x]);\n\t\tfor(int i=fir[x];i;i=nxt[i])\n\t\t{\n\t\t\tdu[to[i]]--;\n\t\t\tif(!du[to[i]]) q.push(make_pair(a[to[i]],to[i]));\n\t\t}\n\t}\n\tputs(\"\");\n}\nvoid dfs(int x)\n{\n\tbok[x]=1;\n\twhile(!eg[x].empty())\n\t{\n\t\tint y=eg[x].top();eg[x].pop();\n\t\tif(!bok[y])\n\t\t{\n\t\t\tadd(x,y);\n\t\t\tdfs(y);\n\t\t}\n\t}\n}\t\t\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\tscanf(\"%d\",&a[i]);\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\tif(gcd(a[i],a[j])!=1) eg[i].push(j),eg[j].push(i);\n\tfor(int i=1;i<=n;i++)\n\t\tif(!bok[i]) dfs(i);\n\ttop();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <stdio.h>\n#include <stdlib.h>\n#include <vector>\n#include <map>\n//#include <self/operator>\n#include <queue>\n#include <set>\n#include <string>\n#include <string.h>\n#include <stack>\n#include <assert.h>\n#include <bitset>\n#define Endl endl\n#define mp make_pair\n#define ll long long \n#define ull unsigned long long\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define over(A) {cout<<A<<endl;exit(0);}\n#define all(A) A.begin(),A.end()\n#define ceil(a,b) ((a-1)/b+1)\n#define quickcin ios_base::sync_with_stdio(false);\nconst int mod=1e9+7;\nconst int inf=1039074182;\nconst ll llinf=1LL*inf*inf;\nusing namespace std;\ntemplate <typename T1,typename T2> inline void chmin(T1 &x,T2 b) {if(b<x) x=b;}\ntemplate <typename T1,typename T2> inline void chmax(T1 &x,T2 b) {if(b>x) x=b;}\ntemplate <typename T1,typename T2> inline void chadd(T1 &x,T2 b) {x+=b;if(x>=mod) x-=mod;}\ntemplate <typename T1,typename T2> inline void chmul(T1 &x,T2 b) {x=1LL*x*b%mod;}\ntemplate <typename T1,typename T2> inline void chmod(T1 &x,T2 b) {x%=b,x+=b;if(x>=b) x-=b;}\nint n;\nint a[2005];\nvector <int> vec[2000+2000*8+5];\nint visit[2005];\nint colors;\nmap <int,int> toid;\nbool isprime[10005];\nvector <int> prime;\nbool block[2000+2000*8+5];\nbool e[2005][2005];\nint tot;\n\ninline vector <int> merge(vector <int> a,vector <int> b)\n{\n\tvector <int> res;\n\tint la=(int)a.size();\n\tint lb=(int)b.size();\n\tres.push_back(a[0]);\n\tfor(int i=1,j=0;;)\n\t{\n\t\tif(i==la && j==lb) break;\n\t\tif(i==la) res.push_back(b[j++]);\n\t\telse if(j==lb) res.push_back(a[i++]);\n\t\telse if(a[i]>b[j]) res.push_back(a[i++]);\n\t\telse res.push_back(b[j++]);\n\t}\n\treturn res;\n}\n\npii dfs(int x,int col,int head)\n{\n//\tcout<<x<<' '<<col<<' '<<head<<endl;\n\tvisit[x]=col;\n\tpii res={inf,-1};\n\tif(x<n && (head==-1 || e[head][x])) res={a[x],x};\n\tfor(auto u:vec[x])\n\t{\n\t\tif(block[u]) continue;\n\t\tif(visit[u]>=col) continue;\n\t\tchmin(res,dfs(u,col,head));\n\t}\n\treturn res;\n}\n\nvector <int> solve(int x)\n{\n\tassert(x<n);\n\tblock[x]=true;\n\tcolors++;\n\tvisit[x]=colors;\n\tvector <int> res;\n\tres.push_back(a[x]);\n\tvector <int> adj;\n\tfor(auto &u:vec[x])\n\t{\n\t\tadj.push_back(u);\n\t}\n\tfor(auto &u:adj)\n\t{\n\t\tif(visit[u]>=colors) continue;\n\t\tif(block[u]) continue;\n\t\tint minx=dfs(u,colors,x).second;\n\t\tif(minx==-1) continue;\n\t\tres=merge(res,solve(minx));\n\t}\n\tcolors--;\n\treturn res;\n}\n\nvoid init()\n{\n\tmemset(isprime,true,sizeof(isprime));\n\tisprime[0]=isprime[1]=false;\n\tfor(int i=2;i<=10000;i++)\n\t{\n\t\tif(isprime[i]) prime.push_back(i);\n\t\tfor(auto &j:prime)\n\t\t{\n\t\t\tif(i*j>10000) break;\n\t\t\tisprime[i*j]=false;\n\t\t\tif(i%j==0) break;\n\t\t}\n\t}\n}\n\nvoid add_edge(int x,int p)\n{\n\tif(toid.find(p)==toid.end()) toid[p]=tot++;\n\tint y=toid[p];\n\tvec[x].push_back(y);\n\tvec[y].push_back(x);\n}\n\nvoid build_graph()\n{\n\tint tn;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\ttn=a[i];\n\t\tfor(auto &p:prime)\n\t\t{\n\t\t\tif(tn%p==0) add_edge(i,p);\n\t\t\twhile(tn%p==0) tn/=p;\n\t\t}\n\t\tif(tn!=1) add_edge(i,tn);\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<n;j++)\n\t\t{\n\t\t\tif(i==j) continue;\n\t\t\tif(__gcd(a[i],a[j])!=1) e[i][j]=true;\n\t\t}\n\t}\n}\n\nvoid gogo()\n{\n\tcolors++;\n\tvector <int> res;\n\tres.push_back(0);\n\tvector <int> adj;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tadj.push_back(i);\n\t}\n\tfor(auto &u:adj)\n\t{\n\t\tif(visit[u]>=colors) continue;\n\t\tif(block[u]) continue;\n\t\tint minx=dfs(u,colors,-1).second;\n\t\tif(minx==-1) continue;\n\t\tvector <int> temp=solve(minx);\n//\t\tcout<<temp<<endl;\n\t\tres=merge(res,temp);\n\t}\n\tcolors--;\n\tfor(int i=1;i<res.size();i++)\n\t{\n\t\tcout<<res[i]<<' ';\n\t}\n\tcout<<endl;\n}\n\nvoid print_graph()\n{\n\tcout<<\"--------Graph is below--------\"<<endl;\n\tfor(int i=0;i<tot;i++)\n\t{\n\t\tfor(int &j:vec[i])\n\t\t{\n\t\t\tcout<<i<<' '<<j<<endl;\n\t\t}\n\t}\n\tcout<<\"--------Graph is above--------\"<<endl;\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\",\"r\",stdin);\n\tinit();\n\tcin>>n;\n\ttot=n;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcin>>a[i];\n\t}\n\tbuild_graph();\n//\tprint_graph();\n\tgogo();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nint A[2020];\nvector<pair<int,int>> E[2020];\nint vis[2020];\n\ndeque<int> dfs(int cur) {\n\tdeque<int> R;\n\tvis[cur]=1;\n\tFORR(r,E[cur]) if(vis[r.second]==0) {\n\t\tdeque<int> R2=dfs(r.second), R3;\n\t\twhile(R.size() || R2.size()) {\n\t\t\tif(R2.size() && (R.empty() || R.front()<=R2.front())) {\n\t\t\t\tR3.push_back(R2.front());\n\t\t\t\tR2.pop_front();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tR3.push_back(R.front());\n\t\t\t\tR.pop_front();\n\t\t\t}\n\t\t}\n\t\tR=R3;\n\t}\n\tR.push_front(A[cur]);\n\treturn R;\n}\n\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N) cin>>A[i];\n\tFOR(x,N) FOR(y,N) if(x!=y && __gcd(A[x],A[y])>1) E[x].push_back({A[y],y});\n\tFOR(x,N) sort(ALL(E[x]));\n\t\n\tFOR(i,N) E[N].push_back({A[i],i});\n\tauto ret=dfs(N);\n\tFOR(i,N) _P(\"%d%c\",ret[i+1],(i==N-1)?'\\n':' ');\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int maxn = 2030, maxm = 54010, oo = 123456789;\n\nint n, m, K, a[maxn], q[maxm], rar, mn, rem, id[maxm];\nbool vis[maxn], f[maxn], inq[maxm];\nstd::vector<int> has[maxm], con[maxn], all, ans[maxn];\n\nvoid dfs(int u) {\n\tif(vis[u]) {\n\t\treturn;\n\t}\n\tif(a[u] < mn) {\n\t\tmn = a[u];\n\t\trem = u;\n\t}\n\tvis[u] = 1;\n\tfor (int i: con[u]) {\n\t\tfor (int j: has[i]) {\n\t\t\tdfs(j);\n\t\t}\n\t}\n\treturn;\n}\n\nvoid work(int u) {\n//\tprintf(\"work(%d)\\n\", u);\n\tif(a[u] == 1) {\n\t\tans[K].push_back(1);\n\t\tvis[u] = f[u] = 1;\n\t\treturn;\n\t}\n\tmn = oo;\n\tdfs(u);\n\trar = 0;\n//\tprintf(\"%d\\n\", rem);\n\tfor (int i: con[u]) {\n\t\tq[rar++] = i;\n\t}\n//\tprintf(\"rar = %d\\n\", rar);\n\tfor(;;) {\n\t\tmn = oo;\n\t\tfor (int i = 0; i < rar; ++i) {\n\t\t\tint j = q[i];\n//\t\t\tprintf(\"\\t\\t%d\\n\", j);\n\t\t\twhile(id[j] < (int)(has[j].size()) && f[has[j][id[j]]]) {\n\t\t\t\t++id[j];\n\t\t\t}\n\t\t\tif(id[j] < (int)has[j].size()) {\n\t\t\t\tint k = has[j][id[j]];\n\t\t\t\tif(a[k] < mn) {\n\t\t\t\t\tmn = a[k];\n\t\t\t\t\trem = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(mn == oo) {\n\t\t\treturn;\n\t\t}\n\t\t//printf(\"\\t%d\\n\", mn);\n\t\tans[K].push_back(mn);\n\t\tint i = has[rem][id[rem]++];\n\t\tfor (int j: con[i]) {\n\t\t\tif(!inq[j]) {\n\t\t\t\tq[rar++] = j;\n\t\t\t}\n\t\t}\n\t\tf[i] = 1;\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tscanf(\"%d\", a + i);\n\t\tint t = a[i];\n\t\tfor (int x = 2; x * x <= t; ++x) {\n\t\t\tif(t % x == 0) {\n\t\t\t\tall.push_back(x);\n\t\t\t\twhile(t % x == 0) {\n\t\t\t\t\tt /= x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(t > 1) {\n\t\t\tall.push_back(t);\n\t\t}\n\t}\n\tsort(all.begin(), all.end());\n\tall.resize(unique(all.begin(), all.end()) - all.begin());\n\tm = (int)(all.size());\n\tfor (int j = 0; j < m; ++j) {\n\t\tfor (int i = 1; i <= n; ++i) {\n\t\t\tif(a[i] % all[j] == 0) {\n\t\t\t\thas[j].push_back(i);\n\t\t\t\tcon[i].push_back(j);\n\t\t\t}\n\t\t}\n\t\tsort(has[j].begin(), has[j].end(), [&](int i, int j) {\n\t\t\treturn a[i] < a[j];\n\t\t});\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif(!vis[i]) {\n\t\t\twork(i);\n\t\t\treverse(ans[K].begin(), ans[K].end());\n\t\t\t++K;\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; ++i)  {\n\t\tint mx = 0, rem;\n\t\tfor (int j = 0; j < K; ++j) {\n\t\t\tif((int)(ans[j].size())) {\n\t\t\t\tif(ans[j].back() > mx) {\n\t\t\t\t\tmx = ans[j].back();\n\t\t\t\t\trem = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d%c\", mx, \" \\n\"[i == n]);\n\t\tans[rem].pop_back();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n\n#define mp make_pair\n#define ff first\n#define ss second\n#define pb push_back\n#define pf push_front\n#define popb pop_back\n#define popf pop_front\n#define all(v) v.begin(),v.end()\n\nconst int maxn = 2e3 + 100;\nconst ll inf = 2e18, mod = 1e9 + 7;\n\nint n, a[maxn], arr[maxn], d[maxn], ans[maxn], ansind;\nbool visited[maxn];\nvector<int> graph[maxn], adj[maxn];\npriority_queue<pair<int, int> > pq;\n\nbool cmp(int A, int B)\n{\n\treturn (a[A] < a[B]);\n}\n\nvoid dfs(int u)\n{\n\tstatic int ind = 0;\n\tarr[ind++] = u;\n\tvisited[u] = true;\n\tfor (int i : graph[u])\n\t\tif (!visited[i])\n\t\t\tdfs(i);\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> n;\n\tfor (int i = 0; i < n; i++)\n\t\tcin >> a[i];\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = i + 1; j < n; j++)\n\t\t\tif (__gcd(a[i], a[j]) != 1)\n\t\t\t{\n\t\t\t\tgraph[i].pb(j);\n\t\t\t\tgraph[j].pb(i);\n\t\t\t}\n\tfor (int i = 0; i < n; i++)\n\t\tsort(all(graph[i]), cmp);\n\tfor (int i = 0; i < n; i++)\n\t\tif (!visited[i])\n\t\t\tdfs(i);\n\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = i + 1; j < n; j++)\n\t\t\tif (__gcd(a[arr[i]], a[arr[j]]) != 1)\n\t\t\t\tadj[arr[i]].pb(arr[j]), d[arr[j]]++;\n\tfor (int i = 0; i < n; i++)\n\t\tif (!d[i])\n\t\t\tpq.push(mp(a[i], i));\n\twhile (!pq.empty())\n\t{\n\t\tpair<int, int> now = pq.top();\n\t\tans[ansind++] = now.ff;\n\t\tpq.pop();\n\n\t\tfor (int i : adj[now.ss])\n\t\t{\n\t\t\td[i]--;\n\t\t\tif (!d[i])\n\t\t\t\tpq.push(mp(a[i], i));\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++)\n\t\tcout << ans[i] << ' ';\n\tcout << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define FI(i,a,b) for(int i=(a);i<=(b);i++)\n#define FD(i,a,b) for(int i=(a);i>=(b);i--)\n\n#define LL long long\n#define Ldouble long double\n#define PI 3.1415926535897932384626\n\n#define PII pair<int,int>\n#define PLL pair<LL,LL>\n#define mp make_pair\n#define fi first\n#define se second\n\nusing namespace std;\n\nint n, s[2005], res[2005], g[2005][2005], reach[2005], used[2005];\nint par[2005];\n\nint gval[2005], gid[2005];\n\nint f(int x){\n\tif(par[x] == x) return x;\n\treturn par[x] = f(par[x]);\n}\n\nint gcd(int a, int b){\n\tif(!b) return a;\n\treturn gcd(b, a % b);\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\tFI(i, 1, n) scanf(\"%d\", &s[i]);\n\tsort(s + 1, s + n + 1);\n\tFI(i, 1, n) par[i] = i;\n\tFI(i, 1, n) FI(j, i + 1, n) if(gcd(s[i], s[j]) > 1){\n\t\tg[i][j] = g[j][i] = 1;\n\t\tint pa = f(i), pb = f(j);\n\t\tif(pa == pb) continue;\n\t\tif(s[pa] < s[pb]) par[pb] = pa;\n\t\telse par[pa] = pb;\n\t}\n\t\n\tFI(i, 1, n) if(par[i] == i) reach[i] = true;\n\tFI(i, 1, n){\n\t\tint tar = 0, tid;\n\t\tFI(j, 1, n) gval[j] = 999999999;\n\t\tFI(j, 1, n) if(!used[j] && reach[j] && s[j] < gval[f(j)]){\n\t\t\tgval[par[j]] = s[j];\n\t\t\tgid[par[j]] = j;\n\t\t}\n\t\t\n\t\tFI(j, 1, n) if(gval[j] < 999999999 && gval[j] > tar){\n\t\t\ttar = gval[j];\n\t\t\ttid = gid[j];\n\t\t}\n\t\tres[i] = tar;\n\t\tFI(j, 1, n) if(g[tid][j]) reach[j] = true;\n\t\tused[tid] = true;\n\t}\n\tFI(i, 1, n) printf(\"%d%c\", res[i], i == n ? '\\n':' ');\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\n// Problem Specific Parameter:\n\nvector<int> a;\n\nconst int limit = 100010;\nvector<int> graph[limit];\nbool visited[limit];\n\ndeque<int> ans[limit];\n\nvoid dfs(int v){\n\tvisited[v] = true;\n\t\n\tfor(auto &v2:graph[v]){\n\t\tif(visited[v2]) continue;\n\t\tdfs(v2);\n\t\t\n\t\twhile(!ans[v2].empty()){\n\t\t\tans[v].push_front(ans[v2].back());\n\t\t\tans[v2].pop_back();\n\t\t}\n\t}\n\tans[v].push_front(a[v]);\n}\n\nint main(void){\n\tint n;\n\tcin >> n;\n\ta.resize(n);\n\t\n\trep(i,n) cin >> a[i];\n\tsort(begin(a),end(a));\n\n\trep(i,n)rep(j,n){\n\t\tif(i==j or __gcd(a[i],a[j])==1) continue;\n\t\tgraph[i].push_back(j);\n\t}\n\n\trep(i,n) graph[n].push_back(i);\n\n\n\tdfs(n);\n\tans[n].pop_front();\n\trep(i,n) cout << (i?\" \":\"\") << ans[n][i];\n\tcout << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <assert.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\n#define PB push_back\n#define MP make_pair\n#define endl \"\\n\"\nconst ll UNDEF = -1;\nconst ll INF=1e9+4;\nconst ll MOD=1000000007LL;\ntemplate<typename T> inline bool chkmax(T &aa, T bb) { return aa < bb ? aa = bb, true : false; }\ntemplate<typename T> inline bool chkmin(T &aa, T bb) { return aa > bb ? aa = bb, true : false; }\ntypedef pair<ll,ll> pll;\ntypedef vector<ll> vll;\nconst ll mn=2002;\n#define fst first\n#define snd second\nconst ll MAXN=1e5+4;\nconst ll MAXP=MAXN;\nbool sieve_array[MAXP+1];\nll sp[MAXP+1];\nvector<ll> gpv;\nvoid sieve() {\n  for (ll i = 0; i <= MAXP; i++) {\n    sieve_array[i] = true;\n    sp[i]=INF;\n  }\n  sieve_array[0] = false; sieve_array[1] = false;\n  ll lim = sqrt(MAXP)+1;\n  for (ll i = 2; i <= lim; i++) {\n    if(sieve_array[i]) {\n      for (ll j = i*i; j <= MAXP; j+=i) {\n        sieve_array[j] = false;\n        chkmin(sp[j],i);\n      }\n    }\n  }\n  for (ll i = 2; i <= MAXP; i++) {\n    if(sieve_array[i]) {\n      gpv.PB(i);\n      chkmin(sp[i],i);\n    }\n  }\n}\nmap<ll,ll> factorize(ll x) {\n  assert(gpv.size()>0);\n  map<ll,ll> h;\n  while(x>=MAXP) {\n    bool found=false;\n    for (auto &p:gpv) {\n      if (p*p>x) break;\n      if ((x%p)==0) {\n        x/=p;\n        h[p]++;\n        found=true;\n        break;\n      }\n    }\n    if (!found) break;\n  }\n  if (x<MAXP) {\n    while(x>1) {\n    ll p=sp[x];\n    x/=p;\n    h[p]++;\n    }\n  }\n  if (x>1) h[x]++;\n  return h;\n}\nll a[mn];\nmap<ll,vll> primeToIndex;\nvector<ll> idxToPrimes[mn];\nbool usedIdx[mn];\nset<ll> usedPrimes;\npriority_queue<pll,vector<pll>,greater<pll> > pq;\nvoid addIdx(ll idx) {\n  usedIdx[idx]=true;\n  for (auto &p:idxToPrimes[idx]) {\n    if (usedPrimes.find(p)!=usedPrimes.end()) continue;\n    usedPrimes.insert(p);\n    for (auto &nidx:primeToIndex[p]) {\n      if (!usedIdx[nidx]) {\n        usedIdx[nidx]=true;\n        pq.push(MP(a[nidx],nidx));\n      }\n    }\n  }\n}\nll degin[mn];\nvector<ll> gout[mn];\nvoid dij(ll x) {\n  if (usedIdx[x]) {return;}\n  vector<ll> ans;\n  pq.push(MP(a[x],x));\n  addIdx(x);\n  while(!pq.empty()) {\n    auto got=pq.top(); pq.pop();\n    ll y=got.snd;\n    ans.PB(y);\n    addIdx(y);\n  }\n  //printf(\"x:%d a[x]:%d. \",x,a[x])  ;\n  //for (auto &w:ans) printf(\"%d \",w);\n  //printf(\"\\n\");\n  ll asz=ans.size();\n  for (ll i=0;i<asz-1;i++) {\n    ll x=ans[i],y=ans[i+1];\n    gout[x].PB(y);\n    degin[y]++;\n  }\n}\npriority_queue<pll> q;\nvoid go(ll x) {\n  assert(degin[x]==0);\n  for (auto &y:gout[x]) {\n    degin[y]--;\n    if (degin[y]==0) {\n      //printf(\"a[x]:%lld adds a[y]:%lld\\n\",a[x],a[y]);\n      q.push(MP(a[y],y));\n    }\n  }\n}\nint main() {\n  sieve();\n  ll n; scanf(\"%lld\",&n);\n  for (ll i=0;i<n;i++) scanf(\"%lld\",&a[i]);\n  sort(a,a+n);\n  for (ll i=0;i<n;i++) {\n    map<ll,ll> mfac = factorize(a[i]);\n    for (auto &fac:mfac) {\n      ll p=fac.fst;\n      idxToPrimes[i].PB(p);\n      primeToIndex[p].PB(i);\n    }\n  }\n  vector<pair<pll,ll> > v;\n  for (ll x=0;x<n;x++) {\n    dij(x);\n  }\n  //for (ll x=0;x<n;x++) {\n  //  printf(\"x:%lld a[x]:%lld degin:%lld\\n\",x,a[x],degin[x]);\n  //}\n  for (ll x=0;x<n;x++) {\n    if (degin[x]==0) {\n      q.push(MP(a[x],x));\n    }\n  }\n  vector<ll> final;\n  while(!q.empty()) {\n    auto got=q.top(); q.pop();\n    ll x=got.snd;\n    //printf(\"Process: x:%lld a[x]:%lld\\n\",x,a[x]);\n    go(x);\n    final.PB(a[x]);\n  }\n  for (auto &w: final) printf(\"%lld \",w);\n  printf(\"\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h> \n#define N 2005\nusing namespace std;\nvector<int>v[N];\nint a[N],ans[N],Min[N],comp[N],last_not_coprime[N],n,cnt,tot,best_col[N],ID[N];\nbool used[N],b[N][N];\nint gcd(int x,int y){return !x?y:gcd(y%x,x);}\nvoid dfs(int from)\n{\n    comp[from]=cnt;\n\tfor(int i=0;i<v[from].size();i++)\n\t{\n\t\tint to=v[from][i];\n\t\tif(comp[to]>-1||used[to])continue;\n\t\tdfs(to);\n\t}\n}\nvoid colors()\n{\n\tcnt=0;memset(comp,-1,sizeof(comp));\n\tfor(int i=0;i<n;i++)\n\tif(!used[i]&&comp[i]==-1)\n\t{\n\t\tdfs(i);\n\t\tcnt++;\n\t}\n}\nint main()\n{\n\tios::sync_with_stdio(0);\n\tcin>>n;\n\tfor(int i=0;i<n;i++)cin>>a[i];\n\tfor(int i=0;i<n;i++)\n\tfor(int j=0;j<n;j++)\n\tif(gcd(a[i],a[j])!=1)b[i][j]=b[j][i]=1,\n\tv[i].push_back(j),v[j].push_back(i);\n\tmemset(Min,0x3f,sizeof(Min));\n\tmemset(last_not_coprime,-1,sizeof(last_not_coprime));\n\twhile(1)\n\t{\n\t\tcolors();\n\t\tmemset(best_col,-1,sizeof(best_col));\n\t\tfor(int i=0;i<n;i++)\n\t\tif(Min[last_not_coprime[i]+1]>=a[i]&&!used[i])\n\t\t{\n\t\t\tif(best_col[comp[i]]==-1||a[i]<best_col[comp[i]])best_col[comp[i]]=a[i],\n\t\t\tID[comp[i]]=i;\n\t\t}\n\t\tint id=-1;\n\t\tfor(int i=0;i<cnt;i++)\n\t\t{\n\t\t\tif(best_col[i]==-1)continue;\n\t\t\tif(id==-1||best_col[id]<best_col[i])id=i;\n\t\t}\n\t\tid=ID[id];\n\t\tans[tot++]=a[id];\n\t\tif(tot==n)\n\t\t{\n\t\t\tcout<<ans[0];\n\t\t\tfor(int i=1;i<n;i++)\n\t\t\tcout<<' '<<ans[i];\n\t\t\tcout<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\tused[id]=1;\n\t\tfor(int i=0;i<tot;i++)\n\t\tMin[i]=min(Min[i],a[id]);\n\t\tfor(int i=0;i<n;i++)\n\t\tif(b[i][id])last_not_coprime[i]=tot-1;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<map>\nusing namespace std;\nmap<int,int>Map;\nint n, w[2100], cnt, ct;\nvector<int>E[51000], P[2100];\nbool chk[51000], v[51000];\nvoid Ins(int a, int num){\n    int i;\n    for(i=2;i*i<=a;i++){\n        if(a%i==0){\n            if(!Map[i]) Map[i] = ++cnt;\n            P[num].push_back(Map[i]);\n            while(a%i==0)a/=i;\n        }\n    }\n    if(a!=1){\n        if(!Map[a]) Map[a] = ++cnt;\n        P[num].push_back(Map[a]);\n    }\n}\nvoid Make_Edge(int a){\n    int i;\n    for(i=0;i<P[a].size();i++){\n        if(i){\n            E[P[a][0]].push_back(P[a][i]);\n            E[P[a][i]].push_back(P[a][0]);\n        }\n        v[P[a][i]]=false;\n    }\n}\nvoid DFS(int a){\n    int i;\n    ct--;\n    v[a]=true;\n    for(i=0;i<E[a].size();i++){\n        if(!v[E[a][i]])DFS(E[a][i]);\n    }\n}\nint main(){\n    int i, j, k;\n    scanf(\"%d\",&n);\n    for(i=1;i<=n;i++){\n        scanf(\"%d\",&w[i]);\n    }\n    sort(w+1,w+n+1);\n    for(i=1;i<=n;i++){\n        Ins(w[i], i);\n    }\n    for(i=1;i<=n;i++){\n        for(j=1;j<=cnt;j++){\n            E[j].clear();\n            v[j] = true;\n        }\n        for(j=1;j<=n;j++){\n            if(!chk[j]){\n                Make_Edge(j);\n            }\n        }\n        ct=0;\n        for(j=1;j<=cnt;j++)if(!v[j])ct++;\n        for(j=1;j<=n;j++){\n            if(!chk[j]){\n                for(k=0;k<P[j].size();k++){\n                    if(!v[P[j][k]])DFS(P[j][k]);\n                }\n                if(!ct){\n                    printf(\"%d \",w[j]);\n                    chk[j] = true;\n                    break;\n                }\n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(2)\n// Happy TLE and WA every day!\n// by: zxb the vegetable chicken\n#include<bits/stdc++.h>\n#define mp\t\t\t\tmake_pair\n#define rep(i,n)\t\tfor(int i = 0; i < n; i++)\n#define foreach(i,c)\tfor(VAR(i, (c).begin()); i != (c).end(); ++i)\n#define BINF\t\t\t0x7fffffff\n#define INF\t\t\t\t0x3f3f3f3f\n#define LINF\t\t\t3223372036854775807\n#define END(s)\t\t\t{cout<<s; return 0;}\n#define CON(s)\t\t\t{cout<<s; continue;}\n#define BRE(s)\t\t\t{cout<<s; break;}\n#define pb\t\t\t\tpush_back\n//#define int\t\t\t\tlong long\n#define All(a)\t\t\ta.begin(), a.end()  //with A in CAPITAL!!!\n#define sz(a)\t\t\t(int)a.size()\n#define F\t\t\t\tfirst\n#define S\t\t\t\tsecond\n//#define usingFiles\nusing namespace std;\n\nconst int rp = 666666;\nconst bool debug = 1;\nconst bool I_good_vegetable_a = 1;\n\nint a[2020];\nint n;\nvector<int> v[2020];\nint ltksize;\nint mnstart;\nbool used[2020];\nvector<int> ltk[2020];\nint index[2020];\nvector<int> ans;\nint cnt = 0;\nint num = 0;\n\nint count(int now){\n\tif(a[now] < a[mnstart]) mnstart = now;\n\tint ans = 1;\n\tused[now] = true;\n\trep(i, v[now].size()){\n\t\tif(!used[v[now][i]]) ans += count(v[now][i]);\n\t}\n\treturn ans;\n}\n\nvoid uncount(int now){\n\tused[now] = false;\n\trep(i, v[now].size()){\n\t\tif(used[v[now][i]]) uncount(v[now][i]);\n\t}\n}\n\nbool dfs(int now){\n\tused[now] = true;\n\tnum++;\n\tif(num == ltksize){\n\t\tltk[cnt].pb(now);\n\t\treturn 1;\n\t}\n\trep(i, v[now].size()){\n\t\tif(used[v[now][i]]) continue;\n\t\tif(dfs(v[now][i])){\n\t\t\tltk[cnt].pb(now);\n\t\t\treturn 1;\n\t\t}\n\t}\n\tused[now] = false;\n\treturn 0;\n}\n\nbool cmp1(int x, int y){\n\treturn a[x] < a[y];\n}\n\nbool cmp(pair<int, int> x, pair<int, int> y){\n\treturn x > y;\n}\n\nsigned main(){\n\tios::sync_with_stdio(false);\n\t#ifdef usingFiles\n\t\tfreopen(\"input.txt\", \"r\", stdin);\n\t\tfreopen(\"output.txt\", \"w\", stdout);\n\t#endif\n\tmemset(index, 0, sizeof(index));\n\tcin >> n;\n\trep(i, n) cin >> a[i];\n\trep(i, n){\n\t\tfor(int j = 0; j < i; j++){\n\t\t\tif(__gcd(a[i], a[j]) > 1){\n\t\t\t\tv[i].pb(j);\n\t\t\t\tv[j].pb(i);\n\t\t\t}\n\t\t}\n\t}\n\trep(i, n){\n\t\tsort(v[i].begin(), v[i].end(), cmp1);\n\t}\n\trep(i, n){\n\t\tif(!used[i]){\n\t\t\tmnstart = i; \n\t\t\tltksize = count(i);\n\t\t\tuncount(i);\n\t\t\tnum = 0;\n\t\t\tdfs(mnstart);\n\t\t\treverse(ltk[cnt].begin(), ltk[cnt].end());\n\t\t\tcnt++;\n\t\t}\n\t}\n\twhile(1){\n\t\tint mx = -1, mxpos;\n\t\trep(i, cnt){\n\t\t\tif(index[i] >= ltk[i].size()) continue;\n\t\t\tif(a[ltk[i][index[i]]] > mx){\n\t\t\t\tmx = a[ltk[i][index[i]]];\n\t\t\t\tmxpos = i;\n\t\t\t}\n\t\t}\n\t\tif(mx == -1) break;\n\t\tindex[mxpos]++;\n\t\tans.pb(mx);\n\t}\n\trep(i, ans.size()) cout << ans[i] << \" \";\n\tcout << endl;\n\treturn 0;\n}\n/*\n5\n1 2 3 4 5\n*/"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint Eulg(int a, int b);\n\nint main(int argc, char *argv[]){\n\n\tint N;\n\tcin>>N;\n\n\tint *a = new int[N]();\n\n\tfor(int i=0; i<N; i++){\n\t\tcin>>a[i];\n\t}\n\n\tsort(a, a+N);\n\n\tbool flag = true;\n\twhile(flag){\n\tfor(int i=0; i<N; i++){\n\t\tfor(int j=i+1; j<N; j++){\n\t\t\tif(Eulg(a[i], a[j]) == 1){\n\t\t\t\tif(a[i]<a[j]){\n\t\t\t\t\tint tmp;\n\t\t\t\t\ttmp =a[i];\n\t\t\t\t\ta[i] = b[i];\n\t\t\t\t\tb[i] = tmp;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t}\n}\n\nfor(int i=0; i<N; i++)\n\tcout<<a[i]<<\"  \";\n\n\n\n\tdelete[] a;\n\treturn 0;\n}\n\nint Eulg(int a, int b){\n\tif(a<b){\n\t\tint tmp;\n\t\ttmp =a;\n\t\ta = b;\n\t\tb = tmp;\n\t}\n\n\tint r;\n\tr = a % b;\n\twhile(r){\n\t\ta = b;\n\t\tb = r;\n\t\tr = a % b;\n\t}\n\treturn b;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \nusing namespace std; \nint gi() { \n\tint res = 0, w = 1; \n\tchar ch = getchar(); \n\twhile (ch != '-' && !isdigit(ch)) ch = getchar(); \n\tif (ch == '-') w = -1, ch = getchar(); \n\twhile (isdigit(ch)) res = res * 10 + ch - '0', ch = getchar(); \n\treturn res * w; \n} \ntypedef long long LL;\nconst int MAX_N = 2e3 + 5; \nint N, a[MAX_N], A[MAX_N][MAX_N], nxt[MAX_N]; \nvector<int> G[MAX_N]; \nbool vis[MAX_N]; \nint ans[MAX_N], deg[MAX_N]; \nvoid dfs(int x) { \n\tvis[x] = 1; \n\tfor (int i = 0; i < (int)G[x].size(); i++) { \n\t\tint v = G[x][i]; if (vis[v]) continue; \n\t\tnxt[x] = v, ++deg[v], dfs(v); \n\t} \n} \nint main () { \n#ifndef ONLINE_JUDGE \n    freopen(\"cpp.in\", \"r\", stdin); \n#endif \n\tN = gi(); \n\tfor (int i = 1; i <= N; i++) a[i] = gi();\n\tsort(&a[1], &a[N + 1]); \n\tfor (int i = 1; i <= N; i++)\n\t\tfor (int j = i + 1; j <= N; j++) A[i][j] = (__gcd(a[i], a[j]) != 1); \n\tfor (int i = 1; i <= N; i++) \n\t\tfor (int j = i + 1; j <= N; j++) \n\t\t\tif (A[i][j]) { \n\t\t\t\tG[i].push_back(j); \n\t\t\t\tG[j].push_back(i); \n\t\t\t} \n\tfor (int i = 1; i <= N; i++) sort(G[i].begin(), G[i].end()); \n\tfor (int i = 1; i <= N; i++) if (!vis[i]) dfs(i); \n\tmemset(vis, 0, sizeof(vis)); \n\tfor (int i = 1; i <= N; i++) { \n\t\tfor (int j = N; j; j--) \n\t\t\tif (!vis[j] && !deg[j]) { vis[j] = 1, --deg[nxt[j]], ans[i] = a[j]; break; } \n\t} \n\tfor (int i = 1; i <= N; i++) printf(\"%d \", ans[i]); \n\tputchar('\\n'); \n    return 0; \n} "
  },
  {
    "language": "C++",
    "code": "// This amazing code is by Eric Sunli Chen.\n#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\ntemplate<typename T> bool get_int(T &x)\n{\n\tchar t=getchar();\n\tbool neg=false;\n\tx=0;\n\tfor(; (t>'9'||t<'0')&&t!='-'&&t!=EOF; t=getchar());\n\tif(t=='-')neg=true,t=getchar();if(t==EOF)return false;\n\tfor(; t<='9'&&t>='0'; t=getchar())x=x*10+t-'0';\n\tif(neg)x=-x;return true;\n}\ntemplate<typename T> void print_int(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tshort a[20]= {},sz=0;\n\twhile(x>0)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1; i>=0; i--)putchar('0'+a[i]);\n}\n#define ff first\n#define ss second\n#define pb push_back\n#define mp make_pair\n#define get1(a) get_int(a)\n#define get2(a,b) (get1(a)&&get1(b))\n#define get3(a,b,c) (get1(a)&&get2(b,c))\n#define printendl(a) print_int(a),puts(\"\")\ntypedef long long LL;\ntypedef unsigned long long uLL;\ntypedef pair<int,int> pii;\nconst int inf=0x3f3f3f3f;\nconst LL Linf=1ll<<61;\nconst double pi=acos(-1.0);\n\n\nstruct Bitset\n{\n\tunsigned a[64];\n\tvoid reset(){memset(a,0,sizeof(a));}\n\tBitset(){reset();}\n\tvoid flip(int x){a[x>>5]^=1u<<(x&31);}\n\tvoid set(int x){a[x>>5]|=1u<<(x&31);}\n\tvoid reset(int x){a[x>>5]&=~(1u<<(x&31));}\n\tint test(int x){return (a[x>>5]>>(x&31))&1;}\n\tBitset operator ~()const\n\t{\n\t\tBitset ret;\n\t\tfor(int i=0;i<64;i++)ret.a[i]=~a[i];\n\t\treturn ret;\n\t}\n\tBitset operator &(const Bitset &b)const\n\t{\n\t\tBitset ret;\n\t\tfor(int i=0;i<64;i++)ret.a[i]=a[i]&b.a[i];\n\t\treturn ret;\n\t}\n\tBitset operator |(const Bitset &b)const\n\t{\n\t\tBitset ret;\n\t\tfor(int i=0;i<64;i++)ret.a[i]=a[i]|b.a[i];\n\t\treturn ret;\n\t}\n\tBitset operator ^(const Bitset &b)const\n\t{\n\t\tBitset ret;\n\t\tfor(int i=0;i<64;i++)ret.a[i]=a[i]^b.a[i];\n\t\treturn ret;\n\t}\n\tBitset operator <<(const int t)const\n\t{\n\t\tBitset ret;\n\t\tunsigned last=0;\n\t\tint high=t>>5,low=t&31;\n\t\tfor(int i=0;i+high<64;i++)\n\t\t{\n\t\t\tret.a[i+high]=last|(a[i]<<low);\n\t\t\tif(low)last=a[i]>>(32-low);\n\t\t}\n\t\treturn ret;\n\t}\n\tBitset operator >>(const int t)const\n\t{\n\t\tBitset ret;\n\t\tunsigned last=0;\n\t\tint high=t>>5,low=t&31;\n\t\tfor(int i=64-1;i>=high;i--)\n\t\t{\n\t\t\tret.a[i-high]=last|(a[i]>>low);\n\t\t\tif(low)last=a[i]<<(32-low);\n\t\t}\n\t\treturn ret;\n\t}\n\tint popcount()\n\t{\n\t\tint ret=0;\n\t\tfor(int i=0;i<64;i++)ret+=__builtin_popcount(a[i]);\n\t\treturn ret;\n\t}\n\tvoid ones(vector<int>&ret)const\n\t{\n\t\tret.clear();\n\t\tfor(int i=0;i<64;i++)\n\t\t{\n\t\t\tunsigned tmp=a[i];\n\t\t\twhile(tmp)\n\t\t\t{\n\t\t\t\tint t=__builtin_ctz(tmp);\n\t\t\t\tret.pb(t|(i<<5));\n\t\t\t\ttmp^=1u<<t;\n\t\t\t}\n\t\t}\n\t}\n};\n\nBitset con[2333],good;\nint n,a[2333],tot,cmp[2333],q[2333];\nbool ok[2333];\npii best;\n\nint f[2333],last[2333];\nint gf(int x){return x==f[x]?x:f[x]=gf(f[x]);}\npii getcomp()\n{\n\tmemset(cmp,0,sizeof(cmp));\n\ttot=0;best=mp(0,0);pii now;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(!ok[i]||cmp[i])continue;\n\t\ttot++;now=mp(inf,inf);\n\t\tBitset all;all.set(i);\n\t\tint front=0,rear=1;q[0]=i;\n\t\tvector<int> newv;\n\t\tfor(;front<rear;front++)\n\t\t{\n\t\t\tint x=q[front];cmp[x]=tot;\n\t\t\tif(last[x]==0||__gcd(last[x],a[x])>1)now=min(now,mp(a[x],x));\n\t\t\t(con[x]&~all).ones(newv);all=all|con[x];\n\t\t\tfor(auto v:newv)q[rear++]=v;\n\t\t}\n\t\tbest=max(best,now);\n\t}\n\treturn best;\n}\nint ans[2333];\nint main()\n{\n\tsrand((unsigned int)time(NULL));\n\tget1(n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tget1(a[i]);\n\t\tf[i]=i;\n\t}\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++)for(int j=1;j<=n;j++)if(i!=j&&__gcd(a[i],a[j])>1)\n\t{\n\t\tcon[i].set(j);f[gf(i)]=gf(j);\n\t}\n\tfor(int i=1;i<=n;i++)ok[i]=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tpii now=getcomp();\n\t\tok[now.ss]=0;for(int j=1;j<=n;j++)con[j].reset(now.ss);\n\t\tfor(int j=1;j<=n;j++)if(cmp[now.ss]==cmp[j])last[j]=now.ff;\n\t\tans[i]=now.ff;\n\t}\n\tfor(int i=1;i<=n;i++)printf(\"%d \",ans[i]);\n\tputs(\"\");\n//\tfor(int i=1;i<n;i++)if(ans[i]<ans[i+1]&&__gcd(ans[i],ans[i+1])==1)puts(\"baojing\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pb push_back\n#define all(x) x.begin(), x.end()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nconst int N = 2000 + 10;\nconst int MOD = 1000000007;\nconst int LOG = 20;\nconst int INF = 1000000010;\nconst int delta = 11353;\n\nint n;\nvi G[N], a;\nmap<int, int> mp;\nint mark[N];\nint mark2[N];\n\nvoid DFS(int v){\n\tmark[v] = 1;\n\tfor (auto u:G[v]){\n\t\tif ((!mark[u]) && (!mark2[u])){\n\t\t\tDFS(u);\n\t\t}\n\t}\n}\n\nint32_t main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++){\n\t\tint x;\n\t\tcin >> x;\n\t\tmp[x] ++;\n\t\ta.pb(x);\n\t}\n\tsort(all(a));\n\ta.resize(unique(all(a)) - a.begin());\n\tfor (int i = 0; i < a.size(); i++) for (int j = 0; j < i; j++) if (__gcd(a[i], a[j]) != 1){\n\t\tG[i].pb(j), G[j].pb(i);\n\t}\n\tmemset(mark, 0, sizeof mark);\n\tvi ans;\n\tint last = 0;\n\tfor (int i = 0; i < a.size(); i++){\n\t\tint ki;\n\t\tmemset(mark, 0, sizeof mark);\n\t\tif (i == 0){\n\t\t\tint mx = 0;\n\t\t\tfor (int j = 0; j < a.size(); j++) if (!mark[j]) mx = j, DFS(j);\n\t\t\tmark2[mx] = 1;\n\t\t\tans.pb(a[mx]);\n\t\t\t//cout << a[mx] << endl;\n\t\t\tlast = mx;\n\t\t}else{\n\t\t\tsort(all(G[last]));\n\t\t\tint mx = 0;\n\t\t\tfor (auto u:G[last]){\n\t\t\t\tif ((!mark2[u]) && (!mark[u])) mx = u, DFS(u);\n\t\t\t}\n\t\t\tfor (int j = 0;  j < a.size(); j++){\n\t\t\t\tif ((!mark[j]) && (!mark2[j])) mx = max(j, mx), DFS(j);\n\t\t\t}\n\t\t\tmark2[mx] = 1;\n\t\t\tans.pb(a[mx]);\n\t\t\tlast = mx;\n\t\t\t//cout << a[mx] << endl;\n\t\t}\n\t}\n\tfor (auto u:ans){\n\t\tfor (int i = 0; i < mp[u]; i++) cout << u << ' ';\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\nstruct UnionFind{\n  Int n;\n  vector<Int> r,p;\n  UnionFind(){}\n  UnionFind(Int sz):n(sz),r(sz,1),p(sz,0){iota(p.begin(),p.end(),0);}\n  Int find(Int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(Int x,Int y){\n    return find(x)==find(y);\n  }\n  void unite(Int x,Int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    if(r[x]<r[y]) swap(x,y);\n    r[x]+=r[y];\n    p[y]=x;\n  }\n};\n\n//INSERT ABOVE HERE\nInt cop[2020][2020];\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<Int> a(n);\n  for(Int i=0;i<n;i++) cin>>a[i];\n  sort(a.begin(),a.end());\n\n  vector<Int> ans(n),used(n,0),post(n,0);\n\n  memset(cop,0,sizeof(cop));\n  \n  for(Int i=0;i<n;i++)\n    for(Int j=0;j<n;j++)\n      cop[i][j]=__gcd(a[i],a[j])>1;\n  \n  for(Int t=0;t<n;t++){\n    UnionFind uf(n);\n    for(Int i=0;i<n;i++)\n      for(Int j=0;j<n;j++)\n\tif(!used[i]&&!used[j]&&cop[i][j]) uf.unite(i,j);\n    \n    Int idx=-1,sum=t;\n    set<Int> tmp;\n    for(Int i=0;i<n;i++){\n      if(used[i]) continue;\n      Int k=uf.find(i);\n      if(!tmp.count(k)){\n\ttmp.emplace(k);\n\tsum+=uf.r[k];\n      }\n      if(post[i]) continue;\n      if(sum==n){\n\tidx=i;\n\tbreak;\n      }\n    }\n    used[idx]=1;\n    ans[t]=idx;\n    \n    for(Int i=0;i<n;i++)\n      if(cop[idx][i]) post[i]=0;\n      else if(a[idx]<a[i]) post[i]=1;\n  }\n  for(Int i=0;i<n;i++){\n    if(i) cout<<\" \";\n    cout<<a[ans[i]];\n  }\n  cout<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nconst int MAXN=2005;\n\nint gcd(int a,int b)\n{\n\tif(b==0)\n\t\treturn a;\n\treturn gcd(b,a%b);\n}\n\nint n,A[MAXN];\nbool vis[MAXN];\nvector<int> adj[MAXN],adj2[MAXN];\nint deg[MAXN],ans[MAXN];\npriority_queue<int> Q;\n\nvoid dfs(int u)\n{\n\tvis[u]=true;\n\tfor(int i=0;i<(int)adj[u].size();i++)\n\t{\n\t\tint v=adj[u][i];\n\t\tif(vis[v])\n\t\t\tcontinue;\n\t\tadj2[u].push_back(v);\n\t\tdeg[v]++;\n\t\tdfs(v);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&A[i]);\n\tsort(A+1,A+n+1);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(i!=j&&gcd(A[i],A[j])>1)\n\t\t\t\tadj[i].push_back(j);\n\tfor(int i=1;i<=n;i++)\n\t\tif(!vis[i])\n\t\t\tdfs(i);\n\t\n\tfor(int i=1;i<=n;i++)\n\t\tif(deg[i]==0)\n\t\t\tQ.push(i);\n\tint it=0;\n\twhile(!Q.empty())\n\t{\n\t\tint u=Q.top();\n\t\tans[++it]=A[u];\n\t\tQ.pop();\n\t\tfor(int i=0;i<(int)adj2[u].size();i++)\n\t\t{\n\t\t\tint v=adj2[u][i];\n\t\t\tdeg[v]--;\n\t\t\tif(deg[v]==0)\n\t\t\t\tQ.push(v);\n\t\t}\n\t}\n\t\n\tfor(int i=1;i<n;i++)\n\t\tprintf(\"%d \",ans[i]);\n\tprintf(\"%d\\n\",ans[n]);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//              +-- -- --++-- +-In the name of ALLAH-+ --++-- -- --+              \\\\\n\n#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define _sz(x) (int)x.size()\n\nusing namespace std ;\nusing ll = long long ;\nusing ld = long double ;\nusing pii = pair <int , int> ;\n\nint const N = 30000 + 20 , M = 30000 + 20 ,  MAX = 1e8 + 20 , S = 1e4 + 20 ;\nint n , a[N] ;\nvector <int> vec ;\n\nvector <int> g[M] ;\nint sz ;\nvector <int> comp[N] ;\n\nint ans[N] , mn[N] , last[M] ;\nbool dead[N] , vis[M] ;\nint mx1 , mx2 , mn_val[N] ;\n\nvector <int> primes ;\nvoid pre () {\n\tbool np[S] ;\n\tmemset(np , 0 , sizeof np) ;\n\tfor (int i = 2 ; i < S ; i ++) {\n\t\tif (np[i]) continue ;\n\t\tprimes.push_back(i) ;\n\t\tfor (int j = 2 * i ; j < S ; j += i) np[j] = 1 ;\n\t}\n}\n\ninline vector<int> get (int x) {\t\t\n\tvector <int> vec ;\n\n\tfor (int j = 0 ; 1ll * primes[j] * primes[j] <= x ; j ++) {\n\t\tif (x % primes[j]) continue ;\n\t\tvec.push_back(primes[j]) ;\n\t\twhile (x % primes[j] == 0) x /= primes[j] ;\n\t}\n\tif (x > 1) vec.push_back(x) ;\n\n\treturn vec ;\n}\n\ninline int get_id (int x) {\n\treturn lower_bound(vec.begin() , vec.end() , x) - vec.begin() ;\n}\n\ninline bool cmp (int x , int y) { return a[x] < a[y] ; }\n\nvoid dfs (int v) {\n\tif (vis[v]) return ;\n\tif (v < n) {\n\t\tif (dead[v]) return ;\n\t\tcomp[sz].push_back(v) ;\n\t}\n\tvis[v] = 1 ;\n\n\tfor (int u : g[v]) dfs(u) ;\n}\n\nint main(){\n\tios::sync_with_stdio(false) , cin.tie(0) , cout.tie(0) ;\n\n\tpre() ;\n\n\tcin >> n ;\n\tfor (int i = 0 ; i < n ; i ++) {\n\t\tcin >> a[i] ;\n\n\t\tvector <int> tmp = get(a[i]) ;\n\t\tfor (int x : tmp) vec.push_back(x) ;\n\t}\n\n\tsort(vec.begin() , vec.end()) ;\n\tvec.resize( unique(vec.begin() , vec.end()) - vec.begin() ) ;\n\n\tfor (int i = 0 ; i < n ; i ++) {\n\t\tvector <int> tmp = get(a[i]) ;\n\t\tfor (int x : tmp) {\n\t\t\tint u = i , v = n + get_id(x) ;\n\t\t\tg[u].push_back(v) ;\n\t\t\tg[v].push_back(u) ;\n\t\t}\n\t}\n\n\tmemset(last , -1 , sizeof last) ;\n\tmemset(mn , 63 , sizeof mn) ;\n\n\tfor (int i = 0 ; i < n ; i ++) {\n\t\tmemset(vis , 0 , sizeof vis) ;\n\t\tmx1 = 0 , mx2 = 0 ;\n\t\tsz = 0 ;\n\n\t\tfor (int v = 0 ; v < n ; v ++) {\n\t\t\tif (!dead[v] && !vis[v]) {\n\t\t\t\tcomp[sz].clear() ;\n\t\t\t\tdfs(v) ;\n\n\t\t\t\tsort(comp[sz].begin() , comp[sz].end() , cmp) ;\n\t\t\n\t\t\t\tmx2 = max(mx2 , a[comp[sz][0]]) ;\n\t\t\t\tif (mx2 > mx1) swap(mx1 , mx2) ;\n\n\t\t\t\tfor (int u : comp[sz]) mn_val[u] = a[comp[sz][0]] ;\n\t\t\t\t\n\t\t\t\tsz ++ ;\n\t\t\t}\n\t\t}\n\n\t\tint res = -1 ;\n\t\tfor (int j = 0 ; j < n ; j ++) {\n\t\t\tif (dead[j]) continue ;\n\n\t\t\tint val = (mn_val[j] == mx1 ? mx2 : mx1) ;\n\t\t\tif (val > a[j]) continue ;\n\n\t\t\tvector <int> tmp = get(a[j]) ;\n\t\t\tint pp = -1 ;\n\t\t\tfor (int x : tmp) pp = max(pp , last[x]) ;\n\n\t\t\tif (mn[pp + 1] < a[j]) continue ;\n\n\t\t\tif (res == -1 || a[res] > a[j]) res = j ;\n\t\t}\n\n      \tif (res == -1) {\n        \tcout << \"-1\\n\" ;\n          \texit(0) ;\n        }\n      \n\t\tdead[res] = 1 ;\n\t\tans[i] = a[res] ;\n\t\tfor (int j = i ; j >= 0 ; j --) mn[j] = min(mn[j] , a[res]) ;\n\t\tvector <int> tmp = get(a[res]) ;\n\t\tfor (int x : tmp) last[x] = i ;\n\t}\n\n\tfor (int i = 0 ; i < n ; i ++) cout << ans[i] << ' ' ; cout << '\\n' ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <functional>\n#define repeat(i,n) for (int i = 0; (i) < int(n); ++(i))\n#define whole(f,x,...) ([&](decltype((x)) whole) { return (f)(begin(whole), end(whole), ## __VA_ARGS__); })(x)\nusing ll = long long;\nusing namespace std;\ntemplate <class T> using reversed_priority_queue = priority_queue<T, vector<T>, greater<T> >;\nint gcd(int a, int b) { while (a) { b %= a; swap(a, b); } return b; }\nbool is_swappable(int a, int b) { return gcd(a, b) == 1; }\nint main() {\n    // input\n    int n; cin >> n;\n    vector<int> a(n); repeat (i,n) cin >> a[i];\n    // rearrange\n    whole(sort, a);\n    vector<int> b;\n    vector<bool> used(n);\n    function<void (int)> go = [&](int i) {\n        used[i] = true;\n        b.push_back(a[i]);\n        repeat (j,n) if (not used[j] and not is_swappable(a[i], a[j])) {\n            go(j);\n        }\n    };\n    repeat (i,n) if (not used[i]) {\n        go(i);\n    }\n    // insertion sort\n    repeat (i,n) {\n        int j = i;\n        for (int k = i-1; k >= 0 and is_swappable(b[k], b[i]); -- k) {\n            if (a[k] < a[i]) j = k;\n        }\n        rotate(b.begin() + j, b.begin() + i, b.begin() + i + 1);\n    }\n    // output\n    for (auto it : b) cout << it << ' '; cout << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\n#define fst first\n#define snd second\n#define forn(i, n) for (int i = 0; i < int(n); ++i)\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\ntypedef vector<pii> vii;\n#define sz(c) (int)(c).size()\n#define ALL(c) (c).begin(), (c).end()\n\nvi combine (const vi &l, const vi &r)\n{\n    if (l.empty() || r.empty())\n        return l.empty() ? r : l;\n\n    vi res(sz(l) + sz(r));\n    int pl = 0, pr = 0, h = 0;\n    while (pl < sz(l) && pr < sz(r))\n        res[h++] = (l[pl] > r[pr] ? l[pl++] : r[pr++]);\n    while (pl < sz(l))\n        res[h++] = l[pl++];\n    while (pr < sz(r))\n        res[h++] = r[pr++];\n    assert(h == sz(res));\n\n    return res;\n}\n\nvi dfs (int x, const vvi &g, vector<char> &used)\n{\n    used[x] = 1;\n    vi res;\n\n    for (int dest : g[x])\n    if (!used[dest])\n        res = combine(res, dfs(dest, g, used));\n\n    res.insert(res.begin(), x);\n    return res;\n}\n\nvoid solve (int n)\n{\n    vi a(n);\n    forn (i, n) cin >> a[i];\n    sort(ALL(a));\n\n    vvi g(n);\n    forn (i, n) forn (j, i)\n    if (__gcd(a[i], a[j]) != 1)\n    {\n        g[i].pb(j);\n        g[j].pb(i);\n    }\n\n    forn (i, n)\n        sort(ALL(g[i]));\n\n    vi res;\n    vector<char> used(n);\n    forn (i, n) if (!used[i])\n        res = combine(res, dfs(i, g, used));\n\n    forn (i, n)\n        cout << a[res[i]] << \" \\n\"[i + 1 == n];\n}\n\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n;\n    while (cin >> n)\n        solve(n);\n}\n"
  },
  {
    "language": "C++",
    "code": "//Zory-2020\n#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n// typedef __int128 ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n#define FR first\n#define SE second\n#define MP make_pair\n#define PB push_back\n#define vc vector\n#define db double\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define bin(x) (1ll<<(x))\n#define fo(i,l,r) for(int i=(l),I=(r);i<=I;i++)\n#define fd(i,r,l) for(int i=(r),I=(l);i>=I;i--)\n#define mem(x,val) memset(x,val,sizeof x)\n#define Swap(a,b,n) for(int I=0;I<=n;I++) swap(a[I],b[I])\n#define PC __builtin_popcountll\n#ifdef DEBUG\n\t#define debug(A,args...) fprintf(stderr,A,##args)\n#else\n\t#define debug(A,args...) printf(\"\")\n#endif\nnamespace mine\n{\n\tll qread()\n\t{\n\t\tll ans=0,f=1;char c=getchar();\n\t\twhile(c<'0' or c>'9') {if(c=='-')f=-1;c=getchar();}\n\t\twhile('0'<=c and c<='9') ans=ans*10+c-'0',c=getchar();\n\t\treturn ans*f;\n\t}\n\tvoid write(ll num){if(num<0) putchar('-'),num=-num;if(num>=10) write(num/10);putchar('0'+num%10);}\n\tvoid write1(ll num){write(num);putchar(' ');}\n\tvoid write2(ll num){write(num);putchar('\\n');}\n\ttemplate<typename T>inline bool chmax(T&a,const T&b){return a<b?a=b,1:0;}\n\ttemplate<typename T>inline bool chmin(T&a,const T&b){return a>b?a=b,1:0;}\n\tll gcd(ll x,ll y){return y?gcd(y,x%y):x;}\n\tbool IN(ll x,ll l,ll r){return l<=x and x<=r;}\n\tvoid GG(){puts(\"NO\");exit(0);}\n\t\n\tconst db eps=1e-8;\n\tconst int INF=0x3f3f3f3f;\n\tconst int MOD=1e9+7;\n\tint mm(const int x){return x>=MOD?x-MOD:x;}\n\ttemplate<typename T> void add(T &x,const int &y){x=(x+y>=MOD?x+y-MOD:x+y);}\n\tll qpower(ll x,ll e,int mod=MOD){ll ans=1;while(e){if(e&1)ans=ans*x%mod;x=x*x%mod;e>>=1;}return ans;}\n\tll invm(ll x){return qpower(x,MOD-2);}\n\tconst int M=5e6+10;\n\tll fac[M],facinv[M],Inv[M];ll C(int n,int m){return n<0 or n<m?0:fac[n]*facinv[m]%MOD*facinv[n-m]%MOD;}\n\tvoid PRE()\n\t{\n\t\tfac[0]=1;fo(i,1,M-1) fac[i]=fac[i-1]*i%MOD;\n\t\tfacinv[M-1]=invm(fac[M-1]);fd(i,M-1,1) facinv[i-1]=facinv[i]*i%MOD;\n\t\tInv[1]=1;fo(i,2,M-1) Inv[i]=(MOD-MOD/i)*Inv[MOD%i]%MOD;\n\t}\n\tconst int N=1e6+10;\n\t//------------------FIXED------------------\n\tint a[N];\n\tvc<int> to[N],to2[N];bool vis[N];int in[N];\n\tvoid dfs(int x)\n\t{\n\t\tvis[x]=1;for(auto y:to[x]) if(!vis[y]) dfs(y),to2[x].PB(y),in[y]++,debug(\"%d->%d\\n\",x,y);\n\t}\n\tvoid main()\n\t{\n\t\tint n=qread();fo(i,1,n) a[i]=qread();sort(&a[1],&a[n+1]);\n\t\tfo(i,1,n) fo(j,i+1,n) if(gcd(a[i],a[j])!=1) to[i].PB(j),to[j].PB(i);//�߱�����\n\t\tfo(x,1,n) if(!vis[x]) dfs(x);\n\t\tpriority_queue<int> q;fo(i,1,n) if(!in[i]) q.push(i);\n\t\twhile(sz(q)){ int x=q.top();q.pop();write1(a[x]);for(auto y:to2[x]){in[y]--;if(!in[y])q.push(y);} }\n\t}\n};//����������\nsigned main()\n{\n\t#ifdef DEBUG\n\t//freopen(\"a.in\",\"r\",stdin);\n\tfreopen(\"z.txt\",\"r\",stdin);\n\t//freopen(\"a.out\",\"w\",stdout);\n\t#endif\n\tsrand(time(0));\n\tmine::PRE();//����Ԥ����ģ����\n\tmine::main();\n\tdebug(\"\\n---------------------Zory---------------------\\nTime: %.2lf s\",1.0*clock()/CLOCKS_PER_SEC);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\n#define ll long long\n#define MAX 2020\ninline ll read()\n{\n\tll x=0;bool t=false;char ch=getchar();\n\twhile((ch<'0'||ch>'9')&&ch!='-')ch=getchar();\n\tif(ch=='-')t=true,ch=getchar();\n\twhile(ch<='9'&&ch>='0')x=x*10+ch-48,ch=getchar();\n\treturn t?-x:x;\n}\nstruct Line{int v,next;}e[MAX*MAX];\nint h[MAX],cnt=1,dg[MAX];\nvector<int> E[MAX];\ninline void Add(int u,int v){e[cnt]=(Line){v,h[u]};h[u]=cnt++;dg[v]+=1;}\ninline void ADD(int u,int v){E[u].push_back(v);}\nint n;\nll a[MAX];\npriority_queue<int> Q;\nbool vis[MAX];\nvoid dfs(int u)\n{\n\tvis[u]=true;\n\tfor(int v:E[u])if(!vis[v])dfs(v),Add(u,v);\n}\nint main()\n{\n\tn=read();\n\tfor(int i=1;i<=n;++i)a[i]=read();\n\tsort(&a[1],&a[n+1]);\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=i+1;j<=n;++j)\n\t\t\tif(__gcd(a[i],a[j])>1)ADD(i,j),ADD(j,i);\n\tfor(int i=1;i<=n;++i)if(!vis[i])dfs(i);\n\tfor(int i=1;i<=n;++i)if(!dg[i])Q.push(i);\n\twhile(!Q.empty())\n\t{\n\t\tint u=Q.top();Q.pop();printf(\"%lld \",a[u]);\n\t\tfor(int i=h[u];i;i=e[i].next)\n\t\t\tif(!--dg[e[i].v])Q.push(e[i].v);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nThough leaves are many , the root is one.\nThrough all the lying days of my youth\nI swayed my leaves and flowers in the sun.\nNow I may wither into the truth.\n\t  \t  \t- William Butler Yeats\n*/\n//#pragma GCC optimize(\"Ofast,no-stack-protector\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx\")\n//#pragma GCC target(\"avx,tune=native\")\n#include<bits/stdc++.h>\n//#include<ext/pb_ds/assoc_container.hpp>\nusing namespace std;\n//using namespace __gnu_pbds;\nconst int inf=0x3f3f3f3f;\nconst double eps=1e-6;\nconst int mod=1000000007;\ntypedef long long ll;\n#ifndef LOCAL\n#define cerr if(0)cout\n#endif\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\ninline string getstr(string &s,int l,int r){string ret=\"\";for(int i=l;i<=r;i++)ret.push_back(s[i]);return ret;}\nint modpow(int x,int y,int md=mod){if(y==0)return 1;int ret=modpow(x,y>>1,md);ret=(ll)ret*ret%md;if(y&1)ret=(ll)ret*x%md;return ret;}\nvector<int>g[2005];\nint n;\nint a[2005],deg[2005];\nint main(){\n\tcin>>n;\n\tfor(int i=1;i<=n;i++)cin>>a[i];\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=i+1;j<=n;j++){\n\t\t\tif(__gcd(a[i],a[j])>1){\n\t\t\t\tif(a[i]<a[j])g[i].push_back(j),deg[j]++;\n\t\t\t\telse g[j].push_back(i),deg[i]++;\n\t\t\t}\n\t\t}\n\t}\n\tpriority_queue<pair<int,int> >q;\n\tfor(int i=1;i<=n;i++)if(!deg[i])q.push(make_pair(a[i],i));\n\twhile(!q.empty()){\n\t\tcout<<q.top().first<<\" \";\n\t\tint x=q.top().second;q.pop();\n\t\tfor(auto to:g[x]){\n\t\t\tdeg[to]--;\n\t\t\tif(!deg[to]){\n\t\t\t\tq.push(make_pair(to,a[to]));\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nint a[2005];\nint G[2005][2005];\nint gcd(int a, int b){\n    return a==0?b:gcd(b%a,a);\n}\nint vis[2005];\nbool cmp(vector<int> a, vector<int> b){\n    return a>b;\n}\nvector<int> dfs(int u){\n    vector<vector<int> > pos;\n    for (int i = 1; i <= n; i++){\n        if (G[u][i] && vis[i] == 0){\n            //printf(\"%d -> %d\\n\",u,i);\n            vis[i] = 1;\n            pos.push_back(dfs(i));\n        }\n    }\n    sort(pos.begin(),pos.end(),cmp);\n    vector<int> ans;\n    if (u != 0) ans.push_back(a[u]);\n    for (auto x : pos){\n        ans.insert(ans.end(),x.begin(),x.end());\n    }\n    return ans;\n}\nint main(){\n    scanf(\"%d\",&n);\n    for (int i = 1; i <= n; i++) scanf(\"%d\",&a[i]);\n    sort(a+1,a+n+1);\n    for (int i = 0 ; i <= n; i++){\n        for (int j =0 ; j <= n; j++){\n            if (a[i] == 1 || a[j] == 1){\n                if (a[i] == 0 || a[j] == 0) G[i][j] = 1;\n                else G[i][j] = 0;\n            }\n            else G[i][j] = (gcd(a[i],a[j]) != 1);\n        }\n    }\n    vector<int> v = dfs(0);\n    for (auto x : v){\n        printf(\"%d \",x);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "// from alphaGem\n#include<bits/stdc++.h>\nusing namespace std;\ninline int gcd(register int a,register int b)\n{\n\tregister int t;\n\tfor(;b;)t=a,a=b,b=t%b;\n\treturn a;\n}\nint e[2333][2333],tr[2333][2333];\nint a[2333],d[2333];\nbool viz[2333];\nint n;\nvoid DFS(int u){viz[u]=1;for(int v=1;v<=n;v++)if(!viz[v]&&e[u][v])tr[u][v]=1,DFS(v);}\npriority_queue<int>p;\nvoid solve()\n{\n\tmemset(viz,0,sizeof(viz));\n\tfor(p.push(0);!p.empty();)\n\t{\n\t\tint u=p.top();\n\t\tviz[u]=1;\n\t\tif(u)printf(\"%d \",a[u]);\n\t\tp.pop();\n\t\tfor(int i=1;i<=n;i++)if(tr[u][i]&&!viz[i])p.push(i);\n\t}\n}\nint main()\n{\n\tfor(int i=scanf(\"%d\",&n);i<=n;i++)scanf(\"%d\",&a[i]);\n\tsort(&a[1],&a[n+1]);\n\tfor(int i=1;i<=n;i++)for(int j=i+1;j<=n;j++)if(gcd(a[i],a[j])>1)e[i][j]=e[j][i]=1;\n\tfor(int i=1;i<=n;i++)if(!viz[i])tr[0][i]=1,DFS(i);\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "    #include<bits/stdc++.h>\n    using namespace std;\n    #define ll long long\n    #define llu unsigned long long\n    #define ld double\n    #define llu unsigned long long\n    #define rep(i,x,y)  for(int i=int(x);i<int(y);++i)\n    #define For(i,x,y)  for(int i=int(x);i<=int(y);++i)\n    #define FOr(i,x,y)  for(int i=int(x);i>=int(y);--i)\n    #define pi acos(-1) \n    #define mk make_pair\n    #define pa pair<ll,ll>\n    #define lf else if\n    #define IL inline\n    #define max(x,y)    ((x)<(y)?(y):(x))\n    #define min(x,y)    ((x)<(y)?(x):(y))\n    #define sqr(x)      ((x)*(x))\n    #define Mul(x,y)    ((x)=1LL*(x)*(y)%mod)\n    #define Add(x,y)    ((x)=((x)+(y))%mod)\n    #define Max(x,y)    ((x)=((x)<(y)?(y):(x)))\n    #define Min(x,y)    ((x)=((x)>(y)?(y):(x)))\n    #define E(x)        return writeln(x),0\n    #define LL\t\t\t(long long)\n    #define p(x)        printf(\"~%lld~\\n\",LL(x))\n    #define pp(x,y)     printf(\"~~%lld %lld~~\\n\",LL(x),LL(y))\n    #define ppp(x,y,z)  printf(\"~~~%lld %lld %lld~~~\\n\",LL(x),LL(y),LL(z))\n    #define pppp(a,b,c,d)\tprintf(\"~~~%lld %lld %lld %lld\\n\",LL(a),LL(b),LL(c),LL(d))\n    #define f_in(x)     freopen(x\".in\",\"r\",stdin)\n    #define f_out(x)    freopen(x\".out\",\"w\",stdout)\n    #define open(x)     f_in(x),f_out(x)\n    #define fi first\n    #define se second\n    #define GuYue\t\tputs(\"\\nGuYueNa________________________________________________________________________________\")\n    typedef complex<double> E;\n    namespace SHENZHEBEI{\n    #ifdef LOCAL\n        struct _{_(){freopen(\"cf.in\",\"r\",stdin);}}_; \n    #endif \n    #define NEG 1\n        static const int GYN=2333333;\n        char SZB[GYN],*SS=SZB,*TT=SZB;\n        inline char gc(){   if (SS==TT){  TT=(SS=SZB)+fread(SZB,1,GYN,stdin); if (SS==TT) return '\\n';  }   return *SS++;    }\n    #if NEG\n        inline ll read(){    ll x=0,g=1; char ch=gc();   for (;!isdigit(ch);ch=gc()) if (ch=='-') g=-1;  for (;isdigit(ch);ch=gc())  x=x*10-48+ch;   return x*g; }\n        inline void write(ll x){    if (x<0) putchar('-'),x=-x;  if (x>=10)   write(x/10);    putchar(x%10+'0');  }\n    #else\n        inline ll read(){    ll x=0; char ch=gc();   for (;!isdigit(ch);ch=gc());    for (;isdigit(ch);ch=gc())  x=x*10-48+ch;   return x;   }\n        inline void write(ll x){    if (x>=10)   write(x/10);    putchar(x%10+'0');  }\n    #endif\n        inline char readchar(){ char ch=gc();   for(;isspace(ch);ch=gc());  return ch;  }\n        inline ll readstr(char *s){ char ch=gc();   int cur=0;  for(;isspace(ch);ch=gc());      for(;!isspace(ch);ch=gc())  s[cur++]=ch;    s[cur]='\\0';    return cur; }\n    \tvoid Print(long long *a,int s,int t){For(i,s,t)printf(\"%lld \",a[i]);}\n    \tvoid Print(int *a,int s,int t){For(i,s,t)printf(\"%d \",a[i]);}\n    \tvoid Print(char *a,int s,int t){For(i,s,t)putchar(a[i]);}\n    \tvoid writeln(ll x){write(x);puts(\"\");}\n    }using namespace SHENZHEBEI;\n    const ll G=4,N=100010,mod=1e9+7;\n    ll a[N],sum,n;\n    struct dt{\n    \tll m[G][G];\n    \tvoid clear(){memset(m,0,sizeof m);}\n    \tvoid Print(){\n    \t\trep(i,0,G){\n    \t\t\trep(j,0,G)write(m[i][j]),putchar(' ');puts(\"\");\n    \t\t}\n    \t}\n    }tmp,st,zy,Zy;\n    dt operator *(dt a,dt b){\n    \ttmp.clear();\n    \trep(i,0,G)rep(j,0,G)rep(k,0,G)\n    \tAdd(tmp.m[i][j],a.m[i][k]*b.m[k][j]);\n    \treturn tmp;\n    }\n    void doit(ll k){\n    \tdt\tcogito=zy;\n    \tfor(;k;k>>=1){\n    \t\tif (k&1)st=st*cogito;\n    \t\tcogito=cogito*cogito;\n    \t}\n    }\n    int main(){\n    \tst.m[0][0]=1;\n    \tsum=read();n=read();\n    \tFor(i,1,n)a[i]=sum-read()+1;\n    \tsort(a+1,a+n+1);\n    \tzy.m[0][1]=2;zy.m[0][2]=1;\n    \tzy.m[1][2]=1;zy.m[2][0]=1;zy.m[2][2]=1;\n    \tzy.m[0][0]++;\tzy.m[1][1]++;\tzy.m[2][2]++;\tzy.m[2][1]=2;\n    \tZy=zy;\n    \tZy.m[2][0]--;\n    \tZy.m[2][1]--;\n    \tZy.m[2][1]--;\n    \tZy.m[2][2]--;\n    \tFor(i,1,n){\n    \t\tll cishu=a[i]-a[i-1]-1;\n    \t\tdoit(cishu);\n    \t\tst=st*Zy;\n    \t}\n    \tdoit(sum-a[n]);\n    \twriteln(st.m[0][2]);\n    }\n    /*\n    1 2\n    2 1\n     \n    1 1 1\n    0\t->\t0\t下一步放0个\n    0\t->\t1\t下一步放1个\n    0\t->\t2\t下一步放1个\n    0\t->\t3\t下一步放2个\n    1\t->\t3\t下一步放1个\n    2\t->\t3\t下一步放1个\n    0\t0\t\n    */"
  },
  {
    "language": "C++",
    "code": "//                             In The Name Of Allah                                           \n//                             \tMohammad Hosseini\n#include <bits/stdc++.h>\n#define\tss second\n#define ff first\n#define use_fast ios::sync_with_stdio(false), cin.tie(0), cout.tie(0)\n#define ret(n) return cout << n, 0\n#define se(n) cout << setprecision(n) << fixed\n#define pb push_back\n//#define int long long\n#define ld long double\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops\")\n#pragma GCC optimize(\"no-stack-protector,fast-math\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\nusing namespace std; \n\nconst int N = 3e5 + 100, OO = 1e9, T = 4500 + 100, M = 1e9 + 7, P = 6151, SQ = 280, lg = 30;\ntypedef pair <int, int> pii;\nint a[N], p[N], n;\nbool mark[N];\n\nvector <int> dfs(int x) {\n\tvector <int> cnt;\n\tmark[x] = true;\n\tfor(int i = 1; i < n; i++) {\n\t\tif(mark[i] || (x != 0 && __gcd(a[i], a[x]) == 1))\n\t\t\tcontinue;\n\t\tvector <int> cmp = dfs(i);\n\t\tint l = 0, r = 0, len = (int)cnt.size() + (int)cmp.size();\n\t\tfor(int i = 0; i < len; i++) {\n\t\t\tif(l == (int)cnt.size())\n\t\t\t\tp[i] = cmp[r++];\n\t\t\telse if(r == (int)cmp.size())\n\t\t\t\tp[i] = cnt[l++];\n\t\t\telse if(cnt[l] < cmp[r])\n\t\t\t\tp[i] = cmp[r++];\n\t\t\telse\n\t\t\t\tp[i] = cnt[l++];\n\t\t}\n\t\tcnt.resize(len);\n\t\tfor(int i = 0; i < len; i++)\n\t\t\tcnt[i] = p[i];\n\t}\n\tvector <int> en = {a[x]};\n\tfor(auto u : cnt)\n\t\ten.pb(u);\n\treturn en;\n}\n\nint32_t main() {\n\tuse_fast;\n\tcin >> n;\n\tfor(int i = 1; i <= n; i++)\n\t\tcin >> a[i];\n\tn++;\n\tsort(a, a + n);\n\tvector <int> ans = dfs(0);\n\tfor(auto u : ans)\n\t\tif(u != 0)\n\t\t\tcout << u << \" \";\n\treturn 0;\n}\n/*\nbe carefull :\n1- if not solve after 20 min, read again twice\n2- after submit read the code again\n3- fun with contest\n4- uploaded by ubuntu 20.04 \n5- ...\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <cmath>\n#include <ctime>\n#include <string>\n#include <cstring>\n#include <complex>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n#define mp make_pair\n\nint gcd(int x, int y)\n{\n    return (y == 0 ? x : gcd(y, x % y));\n}\n\nconst int N = 2020;\nconst int V = 40020;\nint n, m;\nint a[N];\nbool b[N][N];\nint ans[N];\nbool inAns[N];\nint ansSz;\nint lastNotCoprime[N];\nint minOnSuff[N];\nint comp[V];\nvector<int> g[V];\nint C;\nint bestForCol[N];\n\nmap<int, int> primeId;\nint getId(int p)\n{\n    if (primeId.count(p) > 0) return primeId[p];\n    primeId[p] = m;\n    return m++;\n}\n\nvoid dfs(int v)\n{\n    comp[v] = C;\n    for (int u : g[v])\n    {\n        if (comp[u] != -1) continue;\n        if (u < n && inAns[u]) continue;\n        dfs(u);\n    }\n    return;\n}\n\nvoid colors()\n{\n    for (int i = 0; i < m; i++)\n        comp[i] = -1;\n    C = 0;\n    for (int i = 0; i < n; i++)\n    {\n        if (inAns[i]) continue;\n        if (comp[i] != -1) continue;\n        dfs(i);\n        C++;\n    }\n    return;\n}\n\nint main()\n{\n//    freopen(\"input.txt\", \"r\", stdin);\n//    freopen(\"output.txt\", \"w\", stdout);\n\n    scanf(\"%d\", &n);\n    m = n;\n    for (int i = 0; i < n; i++)\n    {\n        scanf(\"%d\", &a[i]);\n        int x = a[i];\n        for (int y = 2; y * y <= x; y++)\n        {\n            if (x % y != 0) continue;\n            int id = getId(y);\n            g[i].push_back(id);\n            g[id].push_back(i);\n            while(x % y == 0)\n                x /= y;\n        }\n        if (x != 1)\n        {\n            int id = getId(x);\n            g[i].push_back(id);\n            g[id].push_back(i);\n        }\n    }\n    for (int i = 0; i < n; i++)\n        for (int j = i + 1; j < n; j++)\n            if (gcd(a[i], a[j]) > 1)\n                b[i][j] = b[j][i] = 1;\n\n    for (int i = 0; i < n; i++)\n        lastNotCoprime[i] = -1;\n    for (int i = 0; i <= n; i++)\n        minOnSuff[i] = (int)1e9 + 2;\n\n    while(ansSz != n)\n    {\n        colors();\n        for (int i = 0; i < C; i++)\n            bestForCol[i] = -1;\n        for (int i = 0; i < n; i++)\n        {\n            if (inAns[i]) continue;\n            if (minOnSuff[lastNotCoprime[i] + 1] < a[i]) continue;\n            if (bestForCol[comp[i]] == -1 || a[bestForCol[comp[i]]] > a[i])\n                bestForCol[comp[i]] = i;\n        }\n        int id = -1;\n        for (int i = 0; i < C; i++)\n        {\n            if (bestForCol[i] == -1) continue;\n            if (id == -1 || a[id] < a[bestForCol[i]])\n                id = bestForCol[i];\n        }\n        if (id == -1) throw;\n        inAns[id] = 1;\n        ans[ansSz++] = a[id];\n        for (int i = 0; i < ansSz; i++)\n            minOnSuff[i] = min(minOnSuff[i], a[id]);\n        for (int i = 0; i < n; i++)\n            if (b[id][i])\n                lastNotCoprime[i] = ansSz - 1;\n    }\n    for (int i = 0; i < n; i++)\n        printf(\"%d \", ans[i]);\n    printf(\"\\n\");\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n██████████████████████████████████████████████████████████████████████████████\n██              ██████    ██████      ██      ██  ██    ██████              ██\n██  ██████████  ██  ██      ██      ██████████████  ██████  ██  ██████████  ██\n██  ██      ██  ██    ██  ████      ██    ██████████    ██  ██  ██      ██  ██\n██  ██      ██  ██    ██  ██      ██  ████        ██  ████  ██  ██      ██  ██\n██  ██      ██  ██  ██████  ████  ████████████  ██    ████████  ██      ██  ██\n██  ██████████  ██  ████  ██    ████    ████  ██████  ████  ██  ██████████  ██\n██              ██  ██  ██  ██  ██  ██  ██  ██  ██  ██  ██  ██              ██\n████████████████████  ██  ██    ██████  ██    ████  ████    ██████████████████\n██████  ████          ████        ██    ██    ████  ████████  ██          ████\n████  ██      ██  ██      ██  ██████  ████  ████    ██    ████    ████████  ██\n██      ██      ██    ██    ████      ████        ██████  ██      ██  ██    ██\n██  ██    ████████████  ████  ██  ████            ████  ████████████  ████  ██\n██  ██      ██  ██  ████    ████████                ████████      ██  ██    ██\n██  ██  ██  ██████████  ████    ██  ████  ██    ████  ████        ████  ██  ██\n██    ██  ████  ██████  ██    ******************    ████  ██            ██  ██\n██    ██████  ██  ██████      * Scan this QR   *██████    ██  ██  ██  ████████\n████  ████  ██  ██████      ██* code to join   *██  ████    ██  ████████  ████\n██████      ████████  ██      * in the Three   *██  ████          ████  ██  ██\n████              ████  ████  * Body ETO.      *  ████        ██  ████  ██  ██\n██████  ██    ████████        *  --ETO manager *██  ██                ██    ██\n████    ██  ██  ██    ██████  *    Ye Wenjie   *████  ████  ██  ████  ██  ████\n██  ████  ██████    ████  ██  *ETO(C),1988~2018*      ██  ██  ██  ██    ██████\n██  ██████  ██  ████    ██  ██******************          ██████    ██████  ██\n██  ██  ██    ████    ██        ██  ██        ████████      ████  ██  ██    ██\n████████████    ██    ██████  ██████████  ██  ████  ██████████    ██  ██  ████\n██████████    ██  ████  ██        ██    ██████████  ██    ██      ██  ██    ██\n██    ██  ████    ██  ████  ████      ██████    ██    ██      ██  ██  ████  ██\n██████  ██  ██████  ██            ██████████  ██    ██    ████  ████  ██    ██\n██      ██████  ████  ████  ████      ████    ████  ████            ██████████\n██████████████████      ██  ██  ████  ██    ██  ██    ████  ██████    ██    ██\n██              ██        ████████████  ████  ██  ██  ██    ██  ██      ██  ██\n██  ██████████  ██    ████  ██████  ██  ██████████████      ██████    ██  ████\n██  ██      ██  ████████    ██  ██      ████  ████  ██              ████  ████\n██  ██      ██  ████  ████  ████  ██████  ██████████████  ██████████    ██  ██\n██  ██      ██  ██    ██████  ██  ██  ██████████  ██  ██      ████    ██    ██\n██  ██████████  ██████  ████            ██    ████████  ██  ████    ██████████\n██              ██████    ████  ████████  ██  ████    ██    ██  ████  ████  ██\n██████████████████████████████████████████████████████████████████████████████\n    扫    描    二    维    码    加    入    三    体    E    T    O\n*/\n/*****************\n *   I<3   C++   *\n *  IWANT ANYAC  *\n * ILOVEPROGRAM! *\n *IT'SINTERESTING*\n * ILOVEPROGRAM! *\n *  INCONTESTS   *\n *   GETSCORE    *\n *    ACCODE     *\n *     LETS      *\n *      GO       *\n *Written by:    *\n *    charlieyan *\n *****************/\n#include <assert.h>\n#include <ctype.h>\n#include <errno.h>\n#include <float.h>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <locale>\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <wchar.h>\n#include <wctype.h>\n#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <cerrno>\n#include <clocale>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <limits>\n#include <map>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <istream>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <utility>\n#include <vector>\n#include <cwchar>\n#include <cwctype>\n#include <numeric>\n#include <list>\n#define LL long long\n#define pb push_back\n#define pob pop_back\n#define mp make_pair\n#define FILL(a,v) memset((void*)a,v,sizeof(a))\n#define FILL0(a) FILL(a,0)\n#define FILL1(a) FILL(a,-1)\n#define FILLBIG(a) FILL(a,0x3f)\n#define ALL(a) (a).begin(),(a).end()\n#define Inf ((int)0x3f3f3f3f)\n#define INF ((long long)0x3f3f3f3f3f3f3f3f)\n#define Mod 1000000007\n#define foreach(it,x) for(__typeof(x.begin()) it=x.begin();it!=x.end();it++)\n#define FOR(i,x) for(int i=0;i<x;i++)\n#define RFOR(i,x) for(int i=x-1;i>=0;i--)\n#define FFOR(i,a,b) for(int i=a;i<b;i++)\n#define FRFOR(i,a,b) for(int i=a-1;i>=b;i--)\n#define SZ(a) ((int)(a).size())\n#define FI first\n#define SE second\n#define OVER(...) return printf(__VA_ARGS__),0\n#define fastio ios::sync_with_stdio(0)\n#define filei(f) freopen(f,\"r\",stdin)\n#define fileo(f) freopen(f,\"w\",stdout)\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define MASK(a) (1<<(a))\n#define MASKX(x,a) ((x)<<(a))\n#define BIT(a,b) (((a)>>(b))&1)\n#define cddx(a) priority_queue<a >\n#define cxdd(a) priority_queue<a,vector<a >,greater<a > >\n#define deval(a) {cerr<<#a<<\" = \"<<a<<endl;}\n#define dearr(be,en) {cerr<<#be;cerr<<\" = {\";for(auto i=be;i!=en;i++)cerr<<' '<<*i;cerr<<\" }\\n\";}\n#define reg register\n#define prtime eprintf(\"\\n\\nTime used: %dms\\n\",clock());\n#define PI 3.1415926535897932384626\n#define TODEG(a) (a*180/PI)\n#define y0 ykangjimutigeidiqiuyipianjingtu\n#define y1 yxiaomiexuduhuanrenleiwannianankang\n#define endl '\\n'\n//抗击母体，给地球一片净土\n//消灭徐毒，还人类万年安康\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef unsigned long long UINT;\ntypedef unsigned int uint;\ntypedef long long INT;\ntypedef long double ldouble;\ntypedef pair<INT,INT> PII;\ntypedef stringstream sst;\ntypedef istringstream iss;\ntypedef vector<int> vint;\ntypedef vector<INT> VINT;\ntypedef vector<pii> vpii;\ntypedef vector<PII> VPII;\ntypedef priority_queue<int> pqi;\ntypedef priority_queue<INT> PQI;\ntypedef priority_queue<pii> pqp;\ntypedef priority_queue<PII> PQP;\ntypedef priority_queue<int,vint,greater<int> > xqi;\ntypedef priority_queue<INT,VINT,greater<INT> > XQI;\ntypedef priority_queue<pii,vpii,greater<pii> > xqp;\ntypedef priority_queue<PII,VPII,greater<PII> > XQP;\nstruct fastIO\n{\n\tinline fastIO operator>>(int& num)\n\t{\n\t\tnum=0;\n\t\tchar c=getchar();\n\t\twhile(c!='-'&&(c<'0'||c>'9'))c=getchar();\n\t\tbool foo=0;\n\t\tif(c=='-')\n\t\t{\n\t\t\tfoo=1;\n\t\t\tc=getchar();\n\t\t}\n\t\twhile(c>='0'&&c<='9')\n\t\t{\n\t\t\tnum=(num<<3)+(num<<1)+c-'0';\n\t\t\tc=getchar();\n\t\t}\n\t\tif(foo)num=-num;\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(INT& num)\n\t{\n\t\tnum=0;\n\t\tchar c=getchar();\n\t\twhile(c!='-'&&(c<'0'||c>'9'))c=getchar();\n\t\tbool foo=0;\n\t\tif(c=='-')\n\t\t{\n\t\t\tfoo=1;\n\t\t\tc=getchar();\n\t\t}\n\t\twhile(c>='0'&&c<='9')\n\t\t{\n\t\t\tnum=(num<<3)+(num<<1)+c-'0';\n\t\t\tc=getchar();\n\t\t}\n\t\tif(foo)num=-num;\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(float& num)\n\t{\n\t\tscanf(\"%f\",&num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(double& num)\n\t{\n\t\tscanf(\"%lf\",&num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(long double& num)\n\t{\n\t\tscanf(\"%Lf\",&num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(char& num)\n\t{\n\t\tnum=getchar();\n\t\twhile(num==' '||num=='\\n')num=getchar();\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(char* num)\n\t{\n\t\tint cnt=0;\n\t\tchar c=getchar();\n\t\twhile(c==' '||c=='\\n')c=getchar();\n\t\twhile(c!=' '&&c!='\\n')\n\t\t{\n\t\t\tnum[cnt++]=c;\n\t\t\tc=getchar();\n\t\t}\n\t\tnum[cnt]=0;\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(string& num)\n\t{\n\t\tcin>>num;\n\t\treturn *this;\n\t}\n\tinline void printInt(const int& num)\n\t{\n\t\tif(num<10)\n\t\t{\n\t\t\tputchar(num+'0');\n\t\t\treturn;\n\t\t}\n\t\tprintInt(num/10);\n\t\tputchar((num%10)+'0');\n\t}\n\tinline void printINT(const INT& num)\n\t{\n\t\tif(num<10)\n\t\t{\n\t\t\tputchar(num+'0');\n\t\t\treturn;\n\t\t}\n\t\tprintINT(num/10);\n\t\tputchar((num%10)+'0');\n\t}\n\tinline fastIO operator<<(const int& num)\n\t{\n\t\tif(num<0)putchar('-'),printInt(-num);\n\t\telse printInt(num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const INT& num)\n\t{\n\t\tif(num<0)putchar('-'),printINT(-num);\n\t\telse printINT(num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const float& num)\n\t{\n\t\tprintf(\"%.10f\",num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const double& num)\n\t{\n\t\tprintf(\"%.16lf\",num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const long double& num)\n\t{\n\t\tprintf(\"%.20Lf\",num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const char& num)\n\t{\n\t\tputchar(num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const char* num)\n\t{\n\t\tfor(int i=0;num[i];i++)\n\t\t\tputchar(num[i]);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const string& num)\n\t{\n\t\tcout<<num;\n\t\treturn *this;\n\t}\n}fio;\n//Coded by Charlieyan\n//版权所有，翻印必究\n\nvector<int> nei[2005];\nint num[2005];\nbool SortComp13(int a,int b){\n\treturn num[a]<num[b];\n}\n\nbool lgl[2005];\nvector<int> ltks[2005];\nint ans[2005];\n\nvoid dfs(int now,int ltk){\n\tif(lgl[now]){\n\t\treturn;\n\t}\n\tlgl[now]=1;\n\tltks[ltk].pb(now);\n\tfor(int i=0;i<SZ(nei[now]);i++){\n\t\tdfs(nei[now][i],ltk);\n\t}\n}\n\nint n;\n\nint gcd(int a,int b){\n\treturn !b?a:gcd(b,a%b);\n}\n\nint main(){\n\tfio>>n;\n\tfor(int i=0;i<n;i++){\n\t\tfio>>num[i];\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=i+1;j<n;j++){\n\t\t\tif(gcd(num[i],num[j])!=1){\n\t\t\t\tnei[i].pb(j);\n\t\t\t\tnei[j].pb(i);\n\t\t\t}\n\t\t}\n\t}\n\tint cntltk=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(!lgl[i]){\n\t\t\tdfs(i,cntltk++);\n\t\t}\n\t}\n\tpriority_queue<pair<int,pii> > pq;\n\tfor(int i=0;i<cntltk;i++){\n\t\tpq.push(mp(num[ltks[i][0]],mp(i,0)));\n\t}\n\tint N=0;\n\twhile(SZ(pq)){\n\t\tpair<int,pii> fff=pq.top();\n\t\tpq.pop();\n\t\tint Num=fff.first,x=fff.second.first,y=fff.second.second;\n\t\tans[N++]=Num;\n\t\ty++;\n\t\tif(y!=SZ(ltks[x])){\n\t\t\tpq.push(mp(num[ltks[x][y]],mp(x,y)));\n\t\t}\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tprintf(\"%d%c\",ans[i],i==N-1?'\\n':' ');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\nstruct UnionFind{\n  Int n;\n  vector<Int> r,p;\n  UnionFind(Int x,Int y):n(x+y),r(x+y,1),p(x+y,0){\n    iota(p.begin(),p.end(),0);\n    for(Int i=0;i<x;i++) r[i]=1;\n    for(Int i=0;i<y;i++) r[x+i]=0;\n  }\n  Int find(Int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(Int x,Int y){\n    return find(x)==find(y);\n  }\n  void unite(Int x,Int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    if(r[x]<r[y]) swap(x,y);\n    r[x]+=r[y];\n    p[y]=x;\n  }\n};\n\n\ntemplate<typename T> \nmap<T, Int> factorize(T x){\n  map<T, Int> res;\n  for(Int i=2;i*i<=x;i++){\n    while(x%i==0){\n      x/=i;\n      res[i]++;\n    }\n  }\n  if(x!=1) res[x]++;\n  return res;\n}\n\n//INSERT ABOVE HERE\nInt cop[2020][2020];\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<Int> a(n);\n  for(Int i=0;i<n;i++) cin>>a[i];\n  sort(a.begin(),a.end());\n\n  vector<Int> ans(n),used(n,0),post(n,0);\n\n  memset(cop,0,sizeof(cop));\n  \n  for(Int i=0;i<n;i++)\n    for(Int j=0;j<n;j++)\n      cop[i][j]=__gcd(a[i],a[j])>1;\n\n  Int m=0;\n  map<Int, Int> r;\n\n  vector<vector<Int> > G(n);\n  for(Int i=0;i<n;i++){\n    auto x=factorize(a[i]);\n    for(auto p:x){\n      if(!r.count(p.first)) r[p.first]=m++;\n      G[i].emplace_back(r[p.first]);\n    }\n  }\n  \n  for(Int t=0;t<n;t++){\n    UnionFind uf(n,m);\n    for(Int i=0;i<n;i++)\n      if(!used[i]) for(Int j:G[i]) uf.unite(i,n+j);\n    \n    Int idx=-1,sum=t;\n    auto nxt=[&](){\n      set<Int> tmp;\n      for(Int i=0;i<n;i++){\n\tif(used[i]) continue;\n\tInt k=uf.find(i);\n\tif(!tmp.count(k)){\n\t  tmp.emplace(k);\n\t  sum+=uf.r[k];\n\t}\n\tif(post[i]) continue;\n\tif(sum==n){\n\t  idx=i;\n\t  break;\n\t}\n      }\n    };\n    nxt();\n    //assert(sum==n);\n    \n    if(idx<0){\n      post.assign(n,0);\n      nxt();\n      while(idx<0);\n    }\n    //while(idx<0);\n    used[idx]=1;\n    ans[t]=idx;\n    \n    for(Int i=0;i<n;i++){\n      if(cop[idx][i]) post[i]=0;\n      else if(a[idx]<a[i]) post[i]=1;\n    }\n  }\n  for(Int i=0;i<n;i++){\n    if(i) cout<<\" \";\n    cout<<a[ans[i]];\n  }\n  cout<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\n\nusing namespace std;\ntypedef vector<int> VI;\n\nconst int N=2005;\n\nint gcd(int x,int y){return y?gcd(y,x%y):x;}\n\nint n,a[N];\nVI E[N],R[N];\nbool vis[N];\n\nVI merge(const VI&x,const VI&y){\n\tVI z;\n\tz.resize(x.size()+y.size());\n\tfor(int i=0,j=0,k=0,li=x.size(),lj=y.size();i<li||j<lj;){\n\t\tif(i==li)z[k++]=y[j++];\n\t\telse if(j==lj)z[k++]=x[i++];\n\t\telse if(x[i]<y[j])z[k++]=y[j++];\n\t\telse z[k++]=x[i++];\n\t}\n\treturn z;\n}\n\nvoid dfs(int x){\n\tvis[x]=true;\n\tfor(int v:E[x])if(!vis[v])dfs(v),R[x]=merge(R[x],R[v]);\n\tR[x].insert(R[x].begin(),1,a[x]);\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=n;i++)for(int j=i+1;j<=n;j++)\n\t\tif(gcd(a[i],a[j])>1)E[i].pb(j),E[j].pb(i);\n\t++n;\n\tfor(int i=1;i<n;i++)E[i].pb(n),E[n].pb(i);\n\tdfs(n);\n\tfor(int v:R[n])if(v)printf(\"%d \",v);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n,a[2005],V;\nvector<int>edge[2005];\nbool used[2005][2005],ex[2005][2005];\nint in[2005];\nvector<int>nxt;\nP q;\nvoid dfs(int v){\n\tif(used[V][v]) return; used[V][v] = 1;\n\tnxt.pb(v);\n\trep(i,edge[v].size()){\n\t\tif(used[V][edge[v][i]] || in[edge[v][i]] != V) continue;\n\t\tdfs(edge[v][i]);\n\t}\n}\nvector<int>mer(vector<int>ret,vector<int>hoge){\n\t\tint c = ret.size(),b = hoge.size();\n\t\tint i = 0,j = 0;\n\t\tvector<int>ret2;\n\t\twhile(i!=c || j!=b){\n\t\t\tif(i==c) ret2.pb(hoge[j++]);\n\t\t\telse if(j==b) ret2.pb(ret[i++]);\n\t\t\telse{\n\t\t\t\tif(a[ret[i]] > a[hoge[j]]) ret2.pb(ret[i++]);\n\t\t\t\telse ret2.pb(hoge[j++]);\n\t\t\t}\n\t\t}\n\t\treturn ret2;\n}\nvector<int>make(vector<int>L,int cut){\n\tvector<int>ret;\n\tif(L.size() == 1){\n\t\tret.pb(cut); return ret;\n\t}\n\trep(i,L.size()){\n\t\tif(L[i] != cut){\n\t\t    in[L[i]] = cut;\n\t\t}\n\t}\n\tvector<pair<vector<int>,int> >vv;\n\trep(i,L.size()){\n\t\tif(L[i] == cut) continue;\n\t\tif(!used[cut][L[i]]){\n\t\t\tnxt.clear(); q = mp(INF,INF);\n\t\t\tV = cut; dfs(L[i]);\n\t\t\trep(j,nxt.size()){\n\t\t\t\tif(ex[nxt[j]][cut]){\n\t\t\t\t\tq = min(q,mp(a[nxt[j]],nxt[j]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tvv.pb(mp(nxt,q.sc));\n\t\t}\n\t}\n\trep(ii,vv.size()){\n\t\tvector<int>&nxt = vv[ii].fi; int Q = vv[ii].sc;\n\t\tvector<int>hoge = make(nxt,Q);\n\t\tret = mer(ret,hoge);\n\t}\n\treverse(ret.begin(),ret.end());\n\tret.pb(cut);\n\treverse(ret.begin(),ret.end());\n\treturn ret;\n}\nbool U[2005];\nvector<int>vi;\nP p;\nvoid DFS(int x){\n\tif(U[x]) return; U[x] = 1;\n\tvi.pb(x); p = min(p,mp(a[x],x));\n\trep(i,edge[x].size()){\n\t\tDFS(edge[x][i]);\n\t}\n}\nvector<int>res;\nint main(){\n\tcin>>n;\n\trepn(i,n){\n\t\tcin>>a[i];\n\t}\n\trepn(i,n) repn(j,n){\n\t\tif(i != j && __gcd(a[i],a[j]) > 1){\n\t\t\tedge[i].pb(j); ex[i][j] = 1;\n\t\t}\n\t}\n\trepn(i,n){\n\t\tif(U[i]) continue; p = mp(INF,INF); vi.clear();\n\t\tDFS(i);\n\t\tvector<int>vec = make(vi,p.sc);\n\t\tres = mer(res,vec);\n\t}\n\trep(i,n) cout<<a[res[i]]<<\" \";\n\tcout<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#include <cstdio> \n#include <cstdlib> \n#include <cstring> \n#include <cmath> \n#include <algorithm>\n#include <vector>\n#include <queue> \nusing namespace std; \ninline int gi() { \n    register int data = 0, w = 1; \n    register char ch = 0; \n    while (!isdigit(ch) && ch != '-') ch = getchar(); \n    if (ch == '-') w = -1, ch = getchar(); \n    while (isdigit(ch)) data = 10 * data + ch - '0', ch = getchar(); \n    return w * data; \n} \nconst int MAX_N = 2e3 + 5; \nint N, a[MAX_N], deg[MAX_N]; \nbool vis[MAX_N], Link[MAX_N][MAX_N]; \nvector<int> G[MAX_N]; \nvoid dfs(int x) { \n\tvis[x] = 1; \n\tfor (int i = 1; i <= N; i++) if (!vis[i] && Link[x][i]) ++deg[i], G[x].push_back(i), dfs(i); \n} \nvoid TopSort() { \n\tpriority_queue<int> que; \n\tfor (int i = 1; i <= N; i++) if (!deg[i]) que.push(i); \n\twhile (!que.empty()) { \n\t\tint x = que.top(); que.pop();\n\t\tprintf(\"%d \", a[x]); \n\t\tfor (auto v : G[x]) que.push(v); \n\t}\n\tputchar('\\n'); \n} \n\nint main () {\n#ifndef ONLINE_JUDGE \n    freopen(\"cpp.in\", \"r\", stdin); \n#endif \n\tN = gi(); for (int i = 1; i <= N; i++) a[i] = gi(); \n\tsort(&a[1], &a[N + 1]); \n\tfor (int i = 1; i <= N; i++)\n\t\tfor (int j = i + 1; j <= N; j++) \n\t\t\tif (__gcd(a[i], a[j]) != 1) Link[i][j] = Link[j][i] = 1; \n\tfor (int i = 1; i <= N; i++) if (!vis[i]) dfs(i); \n\tTopSort(); \n\treturn 0; \n} "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <cmath>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <bitset>\n#define y1 y11\n#define fs first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define mt make_tuple\n#define NAME \"\"\n\nusing namespace std;\n\t\ntypedef long long ll;\ntypedef long double ld;\n\nconst ld PI = acos(-1.0);\n\nint gcd(int a, int b)\n{\n\twhile (b != 0)\n\t{\n\t\tint c = a % b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\n\nconst int MAXN = 3001;\nconst int MAXM = MAXN * 100;\nint a[MAXN];\nvector <int> pd[MAXN];\nvector <int> as[MAXN];\nint ps[MAXM];\nint pc = 0;\nbool w[MAXN];\nbool wc[MAXN];\nint q[MAXN], qb, qe;\nint block[MAXN];\nint mn[MAXN];\n\nbool e[MAXN][MAXN];\n\nint main()\n{\n\t//freopen(\"input.txt\", \"r\", stdin); freopen(\"output.txt\", \"w\", stdout);\t\n\tint n;\n\tcin >> n;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tcin >> a[i];\n\t\t//a[i] = rand() % 100 + 2;\n\t}\n\tsort(a, a + n);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (int j = 0; j < n; j++)\n\t\t{\n\t\t\te[i][j] = (gcd(a[i], a[j]) > 1);\n\t\t}\n\t\tint na = a[i];\n\t\tfor (int j = 2; j * j <= a[i]; j++)\n\t\t{\n\t\t\tif (na % j == 0)\n\t\t\t{\n\t\t\t\twhile (na % j == 0) na /= j;\n\t\t\t\tpd[i].push_back(j);\n\t\t\t\tps[pc++] = j;\n\t\t\t}\n\t\t}\n\t\tif (na != 1) pd[i].push_back(na), ps[pc++] = na;\n\t}\n\tsort(ps, ps + pc);\n\tpc = unique(ps, ps + pc) - ps;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tw[i] = false;\n\t\tfor (int j = 0; j < pd[i].size(); j++)\n\t\t{\n\t\t\tint v = lower_bound(ps, ps + pc, pd[i][j]) -ps;\n\t\t\tpd[i][j] = v;\n\t\t\tas[v].push_back(i);\n\t\t}\n\t}\n\tint calc = 0;\n\ta[n] = 1000 * 1000 * 1000;\n\tfor (int iter = 0; iter < n; iter++)\n\t{\n\t\tbool fnd = false;\n\t\tmn[iter] = n;\n\t\tqe = qb = 0;\n\t\tfor (int i = 0; i < n; i++) wc[i] = w[i];\n\t\tfor (int i = 0; i < pc; i++) ps[i] = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tif ((!wc[i]) && (mn[block[i]] >= i)) q[qe++] = i, wc[i] = true;\n\t\t\twhile (qb < qe)\n\t\t\t{\n\t\t\t\tint v = q[qb++];\n\t\t\t\tfor (int j = 0; j < pd[v].size(); j++)\n\t\t\t\t{\n\t\t\t\t\tint u = pd[v][j];\n\t\t\t\t\tif (ps[u]) continue;\n\t\t\t\t\tps[u] = 1;\n\t\t\t\t\tfor (int l = 0; l < as[u].size(); l++)\n\t\t\t\t\t{\n\t\t\t\t\t\tint v2 = as[u][l];\n\t\t\t\t\t\tif (wc[v2]) continue;\n\t\t\t\t\t\twc[v2] = true;\n\t\t\t\t\t\tq[qe++] = v2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((qe + iter == n) && (mn[block[i]] >= i) && (!w[i]))\n\t\t\t{\n\t\t\t\tcalc++;\n\t\t\t\tcout << a[i] << \" \";\n\t\t\t\tfor (int j = 0; j <= iter; j++) mn[j] = min(mn[j], i); \n\t\t\t\tw[i] = true;\n\t\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\t{\n\t\t\t\t\tif (e[i][j]) block[j] = iter + 1;\n\t\t\t\t}\n\t\t\t\tfnd= true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!fnd)\n\t\t{\n\t\t\tfnd = false;\n\t\t\tassert(fnd);\n\t\t}\n\t}\n\tassert(calc == n);\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<ctime>\n#include<map>\n#include<bitset>\n#include<set>\n#define LL long long\n#define mp(x,y) make_pair(x,y)\n#define pll pair<long long,long long>\n#define pii pair<int,int>\nusing namespace std;\ninline int read()\n{\n\tint f=1,x=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint stack[20];\ntemplate<typename T>inline void write(T x)\n{\n\tif(x<0){putchar('-');x=-x;}\n    if(!x){putchar('0');return;}\n    int top=0;\n    while(x)stack[++top]=x%10,x/=10;\n    while(top)putchar(stack[top--]+'0');\n}\ntemplate<typename T>inline void pr1(T x){write(x);putchar(' ');}\ntemplate<typename T>inline void pr2(T x){write(x);putchar('\\n');}\nconst int MAXN=2005;\nvector<int> nxt[MAXN];\nint cal[MAXN],vis[MAXN],n,id[MAXN];\nbool cmp(int n1,int n2){return cal[n1]<cal[n2];}\npriority_queue<pii> hp;\nint gcd(int a,int b){return a==0?b:gcd(b%a,a);}\nint du[MAXN];\nvoid dfs(int x,int up)\n{\n\tif(up)nxt[up].push_back(x),++du[x];vis[x]=1;\n\tfor(int i=1;i<=n;i++)if(!vis[id[i]]&&gcd(cal[id[i]],cal[x])!=1)\n\t\tdfs(id[i],x);\n}\nint main()\n{\n\tn=read();\n\tfor(int i=1;i<=n;i++)cal[i]=read(),id[i]=i;\n\tsort(id+1,id+1+n,cmp);\n\tfor(int i=1;i<=n;i++)if(!vis[id[i]])\n\t\thp.push(mp(cal[id[i]],id[i])),dfs(id[i],0);\n\twhile(!hp.empty())\n\t{\n\t\tint x=hp.top().second;hp.pop();pr1(cal[x]);\n\t\tfor(int k=0;k<nxt[x].size();k++)\n\t\t{\n\t\t\tint y=nxt[x][k];\n\t\t\t--du[y];if(!du[y])hp.push(mp(cal[y],y));\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Zhupengfei 2018\n// This program / source file is in public domain.\n\n// Solution for problem: Rearranging\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n// Main segment\n\nint a[2001] = {};\nvector<int> g[2001] = {};\nbool v[2001] = {};\nvector<vector<int>> seq;\nvector<int> tmpseq;\nvector<int> topores;\n\nvoid dfs(int x) {\n    v[x] = 1;\n    tmpseq.push_back(x);\n    for (int y : g[x]) {\n        if (!v[y]) {\n            dfs(y);\n        }\n    }\n}\n\nbool topov[2001] = {};\n\nvoid topo() {\n    memset(topov, 0, sizeof(topov));\n    priority_queue<int, vector<int>, greater<int>> pq;\n\n    int mi = 1e9;\n    for (int y : tmpseq) {\n        mi = min(mi, y);\n    }\n    pq.push(mi);\n    topov[mi] = 1;\n    while (!pq.empty()) {\n        int u = pq.top();\n        pq.pop();\n        topores.push_back(u);\n        for (int y : g[u]) {\n            if (topov[y])\n                continue;\n            pq.push(y);\n            topov[y] = 1;\n        }\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int N;\n    cin >> N;\n    for (int i = 1; i <= N; i++) {\n        cin >> a[i];\n    }\n    sort(a + 1, a + N + 1);\n    for (int i = 1; i <= N; i++) {\n        for (int j = i + 1; j <= N; j++) {\n            if (__gcd(a[i], a[j]) != 1) {\n                g[i].push_back(j);\n                g[j].push_back(i);\n            }\n        }\n    }\n    for (int i = 1; i <= N; i++) {\n        sort(g[i].begin(), g[i].end());\n    }\n    for (int i = 1; i <= N; i++) {\n        if (!v[i]) {\n            dfs(i);\n            topo();\n            seq.emplace_back(std::move(topores));\n            tmpseq.clear();\n            topores = std::vector<int>();\n        }\n    }\n    sort(seq.begin(), seq.end(), greater<vector<int>>());\n    for (const auto& vec : seq) {\n        for (int x : vec) {\n            cout << a[x] << \" \";\n        }\n    }\n    cout << endl;\n\n#ifdef LOCAL\n    system(\"pause\");\n#endif\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<cstring>\n#include<algorithm>\n#include<stack>\n#define ll long long\nusing namespace std;\nint n,a[2005],tot,du[2005],h[2005],to[4000005],nex[4000005];\nbool bhz[2005][2005],pd[2005];\nint gcd(int a,int b)\n{\n    return b?gcd(b,a%b):a;\n}\nstruct node{\n    int fr,id;\n}st;\nbool operator <(node a,node b)\n{\n    return a.fr<b.fr;\n}\nstack<node> q;\nvoid add(int a,int b)\n{\n    du[b]++;\n    to[++tot]=b;\n    nex[tot]=h[a];\n    h[a]=tot;\n}\nvoid dfs(int x)\n{\n    pd[x]=1;\n    for(int i=1;i<=n;i++)\n        if(bhz[x][i]&&!pd[i])\n        {\n            add(x,i);\n            dfs(i);\n        }\n}\nint main()\n{\n    cin>>n;\n    for(int i=1;i<=n;i++) cin>>a[i];\n    sort(a+1,a+n+1);\n    for(int i=1;i<=n-1;i++)\n    for(int j=i+1;j<=n;j++)\n    if(gcd(a[i],a[j])>1) bhz[i][j]=bhz[j][i]=1;\n    for(int i=1;i<=n;i++) if(!pd[i]) dfs(i);\n    for(int i=1;i<=n;i++) \n        if(!du[i])\n        { \n            st.fr=a[i];\n            st.id=i;\n            q.push(st); \n        }\n    for(int i=1;i<=n;i++)\n    {\n        st=q.top();\n        q.pop();\n        int now=st.id;\n        cout<<a[now]<<\" \";\n        for(int k=h[now];k;k=nex[k])\n        {\n            du[to[k]]--;\n            if(!du[to[k]])\n            {\n                st.fr=a[to[k]];\n                st.id=to[k];\n                q.push(st);\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Zhupengfei 2018\n// This program / source file is in public domain.\n\n// Solution for problem: Rearranging\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n// Main segment\n\nconst int MAXN = 2010;\nconst int MAXV = 40020;\n\nint a[MAXN] = {};\nvector<int> g[MAXV] = {};\n\nunordered_map<int, int> primeMp = {};\nint m, N;\n\nbool inAns[MAXN] = {};\n\nint getId(int x) {\n    if (primeMp.count(x)) {\n        return primeMp[x];\n    }\n    primeMp[x] = ++m;\n    return m;\n}\n\nint color[MAXV] = {};\nint C = 0;\n\nvoid dfs(int u) {\n    color[u] = C;\n    for (int v : g[u]) {\n        if (color[v] != -1)\n            continue;\n        if (v <= N && inAns[v])\n            continue;\n        dfs(v);\n    }\n}\n\nvoid recolor() {\n    C = 0;\n    memset(color, -1, sizeof(color));\n    for (int i = 1; i <= N; i++) {\n        if (!inAns[i] && color[i] == -1) {\n            dfs(i);\n            C++;\n        }\n    }\n}\n\nbool f[MAXN][MAXN] = {};\nint last[MAXN] = {};\nint suffmin[MAXN] = {};\nint ans[MAXN] = {};\nint best[MAXN] = {};\nint cnt = 0;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    cin >> N;\n    m = N;\n    for (int i = 1; i <= N; i++) {\n        cin >> a[i];\n        int x = a[i];\n        for (int y = 2; y * y <= x; y++) {\n            if (x % y != 0)\n                continue;\n            int id = getId(y);\n            g[i].push_back(id);\n            g[id].push_back(i);\n            while (x % y == 0)\n                x /= y;\n        }\n        if (x != 1) {\n            int id = getId(x);\n            g[i].push_back(id);\n            g[id].push_back(i);\n        }\n    }\n\n    for (int i = 1; i <= N; i++) {\n        for (int j = 1; j <= N; j++) {\n            if (i != j)\n                f[i][j] = (__gcd(a[i], a[j]) != 1);\n        }\n    }\n\n    memset(last, -1, sizeof(last));\n    memset(suffmin, 0x7f, sizeof(suffmin));\n\n    while (cnt < N) {\n        recolor();\n        memset(best, -1, sizeof(best));\n\n        for (int i = 1; i <= N; i++) {\n            if (inAns[i] || suffmin[last[i] + 1] < a[i])\n                continue;\n            if (best[color[i]] == -1 || a[best[color[i]]] > a[i])\n                best[color[i]] = i;\n        }\n\n        int mi = -1;\n        for (int i = 0; i < C; i++) {\n            if (best[i] == -1)\n                continue;\n            if (mi == -1 || a[mi] < a[best[i]])\n                mi = best[i];\n        }\n\n        assert(mi != -1);\n        inAns[mi] = 1;\n        ans[++cnt] = a[mi];\n\n        for (int i = 0; i <= cnt; i++) {\n            suffmin[i] = min(suffmin[i], a[mi]);\n        }\n        for (int i = 1; i <= N; i++) {\n            if (f[i][mi]) {\n                last[i] = cnt;\n            }\n        }\n    }\n    for (int i = 1; i <= N; i++) {\n        cout << ans[i] << (i < N ? \" \" : \"\\n\");\n    }\n\n    cout << flush;\n\n#ifdef LOCAL\n    system(\"pause\");\n#endif\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst int N=2007;\nint n,a[N],ed[N],s[N][N],sp[N];\nint gcd(int a,int b){\n\twhile(b){a%=b;if(!a)return b;b%=a;}\n\treturn a;\n}\nvoid mg(int a,int b){\n\tmemcpy(s[0],s[a],sizeof(int)*sp[a]);\n\tint*as=s[0],*ap=as+sp[a];\n\tint*bs=s[b],*bp=bs+sp[b];\n\tint*p=s[a];\n\twhile(as!=ap&&bs!=bp)*p++=*as>*bs?*as++:*bs++;\n\twhile(as!=ap)*p++=*as++;\n\twhile(bs!=bp)*p++=*bs++;\n\tsp[a]=p-s[a];\n}\nvoid f1(int w){\n\ted[w]=1;\n\tfor(int i=1;i<=n;++i)if(!ed[i]&&gcd(a[i],a[w])!=1)f1(i),mg(w,i);\n\tfor(int i=sp[w]++;i;--i)s[w][i]=s[w][i-1];\n\ts[w][0]=a[w];\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;++i)scanf(\"%d\",a+i);\n\tstd::sort(a+1,a+n+1);\n\tfor(int i=1;i<=n;++i)if(!ed[i])f1(i),mg(n+1,i);\n\tfor(int i=0;i<n;++i)printf(\"%d \",s[n+1][i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\",\"inline\",\"-ffast-math\")\n#pragma GCC target(\"avx,sse2,sse3,sse4,mmx\")\n#include <bits/stdc++.h>\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/hash_policy.hpp>\nusing namespace __gnu_pbds;\nusing namespace std;\n\nint n,a[2010];\nvector<int> v[2010];\nbool vis[2010],used[2010];\nvector<int> dp[2010];\n\ninline int gcd(int a,int b)\n{\n\tif(b==0) return a;\n\treturn gcd(b,a%b);\n}\n\ninline void dfs2(int x)\n{\n\tvis[x]=1;\n\tfor(int i=0;i<v[x].size();i++) if(!used[v[x][i]]&&!vis[v[x][i]]){\n\t\tdfs2(v[x][i]);\n\t}\n}\n\ninline void dfs(int x)\n{\n\tused[x]=1;memset(vis,0,sizeof(vis));\n\tfor(int i=0;i<v[x].size();i++) if(!used[v[x][i]]&&!vis[v[x][i]]){\n\t\tdfs2(v[x][i]);\n\t\tdp[x].push_back(v[x][i]);\n\t}\n\tfor(int i=0;i<dp[x].size();i++) dfs(dp[x][i]);\n} \n\ninline void dfs3(int x)\n{\n\tif(x>0) cout<<a[x]<<\" \";\n\tfor(int i=dp[x].size()-1;i>=0;i--) dfs3(dp[x][i]);\n}\n\nsigned main()\n{\n\tios::sync_with_stdio(false);\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=i+1;j<=n;j++){\n\t\t\tif(gcd(a[i],a[j])>1){\n\t\t\t\tv[i].push_back(j);\n\t\t\t\tv[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tv[0].push_back(i);v[i].push_back(0);\n\t}\n\tdfs(0);\n\tdfs3(0);\n\tcout<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct nd{int x,y;friend bool operator < (nd a,nd b){if(a.x==b.x)return a.y<b.y;return a.x<b.x;}};\nconst int N=5100;\nint a[N],n,m,c[N][N],dfn[N],fir[N],nxt[N],to[N],cnt,in[N];\nmap<int,int>l;\nvoid add(int u,int v)\n{\n\tto[++cnt]=v,nxt[cnt]=fir[u],fir[u]=cnt;\n}\nvoid dfs(int x)\n{\n\tdfn[x]=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(!c[x][i])continue;\n\t\tif(dfn[i])continue;\n\t\tdfn[i]=1;\n\t\tdfs(i);add(x,i);in[i]++;\n\t}\n}\nint main()\n{//freopen(\"rearranging.in\",\"r\",stdin);\n\t//freopen(\"rearranging.out\",\"w\",stdout);\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=i+1;j<=n;j++)\n\t\tif(__gcd(a[i],a[j])!=1)\n\t\tc[i][j]=c[j][i]=1;l[a[i]]=i;\n\t}\n\tfor(int i=1;i<=n;i++)\n\tif(!dfn[i])dfs(i);\n\tpriority_queue<nd>q;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(!in[i])q.push({a[i],i});\n\t}\n\twhile(!q.empty())\n\t{\n\t\tint x=q.top().y;q.pop();\n\t\tfor(int i=fir[x];i;i=nxt[i])\n\t\t{\n\t\t\tin[to[i]]--;if(in[to[i]]==0)q.push({a[to[i]],to[i]});\n\t\t}printf(\"%d \",a[x]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAXN\t2005\ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1;\n\tchar c = getchar();\n\tfor (; !isdigit(c); c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c); c = getchar()) x = x * 10 + c - '0';\n\tx *= f;\n}\nint gcd(int x, int y) {\n\tif (y == 0) return x;\n\telse return gcd(y, x % y);\n}\nbool mp[MAXN][MAXN], visited[MAXN];\nvector <int> a[MAXN], b[MAXN], tmp;\nint value[MAXN], n;\nvoid work(int pos, int fa) {\n\tvisited[pos] = true;\n\tfor (int i = 1; i <= n; i++)\n\t\tif (mp[pos][i] && !visited[i]) {\n\t\t\twork(i, pos);\n\t\t\ttmp.clear();\n\t\t\tunsigned p = 0, q = 0;\n\t\t\twhile (p < b[pos].size() || q < b[i].size())\n\t\t\t\tif (q == b[i].size() || p < b[pos].size() && b[pos][p] > b[i][q]) tmp.push_back(b[pos][p++]);\n\t\t\t\telse tmp.push_back(b[i][q++]);\n\t\t\tb[pos] = tmp;\n\t\t}\n\tb[pos].insert(b[pos].begin(), value[pos]);\n}\nint main() {\n\tread(n);\n\tfor (int i = 1; i <= n; i++)\n\t\tread(value[i]);\n\tsort(value + 1, value + n + 1);\n\tfor (int i = 1; i <= n; i++)\n\t\tmp[0][i] = mp[i][0] = true;\n\tfor (int i = 1; i <= n; i++)\n\tfor (int j = i + 1; j <= n; j++)\n\t\tmp[i][j] = mp[j][i] = gcd(value[i], value[j]) != 1;\n\twork(0, 0);\n\tfor (unsigned i = 1; i < b[0].size(); i++)\n\t\tprintf(\"%d \", b[0][i]);\n\tprintf(\"\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int jt=998244353;\n#define loop(i,n) for(int i=0;i<(n);i++)\n#define pool(i,n) for(int i=(n)-1;i>=0;i--)\n#define cont(i,n) for(int i=1;i<=(n);i++)\n#define tnoc(i,n) for(int i=(n);i>=1;i--)\n#define circ(i,a,b) for(int i=(a);i<=(b);i++)\n#define cric(i,a,b) for(int i=(b);i>=(a);i--)\n#define sub(i,a) for(int i=a;i;i=((i-1)&(a)))\n#define subs(i,a) for(int i=a;i>=0;i=(!i?-1:((i-1)&(a))))\n#define subt(i,a) for(int i=((a-1)&a);i;i=((i-1)&(a)))\n#define subst(i,a) for(int i=((a-1)&a);i>=0;i=(!i?-1:((i-1)&(a))))\n#define range(i,a,b,c) for(int i=(a);((c)>0?i<=(b):i>=(b));i+=(c))\n#define foreach(it,v) for(__typeof((v).begin()) it=(v).begin(),_e_D_=(v).end();it!=_e_D_;it++)\n#define parse(i,s) for(int i=0;s[i];i++)\n#define ln '\\n'\n#define all(a) a.begin(),a.end()\n#define OVER(s) return puts(s),0;\n#define FILL(a,x) memset(a,x,sizeof(a))\n#define FILL0(a) memset(a,0,sizeof(a))\n#define FILL1(a) memset(a,-1,sizeof(a))\n#define FILLBIG(a) memset(a,0x3f,sizeof(a))\n#define COPY(frm,to) memcpy(to,frm,sizeof(frm))\n#define Mask(a) (1ll<<(a))\n#define Maskx(a,x) ((a)<<(x))\n#define Full(a) ((1ll<<(a))-1)\n#define Bit(a,x) (((a)>>(x))&1)\n#define SZ(a) ((int)((a).size()))\n#define filei(a) freopen(a,\"r\",stdin);\n#define fileo(a) freopen(a,\"w\",stdout);\n#define fileio(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)\n#define Floyd(a,n) cont(k,n)cont(i,n)cont(j,n)chmin(a[i][j],a[i][k]+a[k][j])\n#define Floyd0(a,n) loop(k,n)loop(i,n)loop(j,n)chmin(a[i][j],a[i][k]+a[k][j])\n#define Floydlr(a,l,r) circ(k,l,r)circ(i,l,r)circ(j,l,r)chmin(a[i][j],a[i][k]+a[k][j])\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define y0 y0O0OO00OO0OO0OO0OOO00OO0OO0O0O000OO0\n#define y1 y1II11II11III11I1III11II111IIII1II1I1\n#define ws WSrAkIoi2333wSraKIoIWSraKiOi\n#define left left_jTjTJtJtIoiiOiioIAuaU66666jtIOIau\n#define hash whYusEthiSnamE_caNyoUusEothERnaMesliKeHSH\n#define pub push_back\n#define pob pop_back\n#define puf push_front\n#define pof pop_front\n#define mak make_pair\n#define emb emplace_back\n#define emf emplace_front\n#define emp emplace\n#define popcnt __builtin_popcount\n#define Popcnt __builtin_popcountll\ntemplate<typename _T>\nusing pair2=pair<_T,_T>;\ntemplate<typename _T>\nusing pair3=pair<pair<_T,_T>,_T>;\ntemplate<typename _T>\nusing pair4=pair<pair<_T,_T>,pair<_T,_T> >;\n#define mak3(a,b,c) make_pair(make_pair(a,b),c)\n#define mak4(a,b,c,d) make_pair(make_pair(a,b),make_pair(c,d))\ntemplate<typename _T>\nusing priq=priority_queue<_T>;\ntemplate<typename _T>\nusing qrip=priority_queue<_T,vector<_T>,greater<_T> >;\n#define ST first\n#define ND second\n#define FST first.first\n#define SND first.second\n#define RD second\n#define SRD second.first\n#define FTH second.second\n#ifndef JTAKIOI\n#define cerr if(0)cout\n#define tctest(clas,meth,...)\n#else\n#define tctest(clas,meth,...) int main(){fio<<(new clas)->meth(__VA_ARGS__)<<ln;}\n#endif\ntypedef long long ll;\ntypedef long double lf;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef istringstream iss;\ntypedef stringstream sst;\nconst lf pi=acosl(-1);\nconst int Inf=0x3f3f3f3f;\nconst ll INF=0x3f3f3f3f3f3f3f3fll;\nconst lf inF=11451419198101145141919810.1145141919810;\nconst int Dx[]={1,0,-1,0,1,1,-1,-1},Dy[]={0,1,0,-1,1,-1,1,-1};\n#ifdef JTAKIOI\nmt19937_64 Rand;void inline Srand(int x){Rand.seed(x);}\n#else\nvoid inline Srand(int x){srand(x);}\null inline Rand(){return ((rand()*32768ull+rand())*32768ull+rand())*32768ull+rand();}\n#endif\nll inline rand(ll a,ll b){return Rand()%(b-a+1)+a;}\ntemplate<typename _T>\ninline _T chmin(_T &a,_T b){return a>b?(a=b):a;}\ntemplate<typename _T>\ninline _T chmax(_T &a,_T b){return a<b?(a=b):a;}\ntemplate<typename _T,int len>\nstruct BIT{\n\t_T dt[len];\n\tinline void add(int a,_T x){while(a<len){dt[a]+=x;a+=a&-a;}}\n\tinline void add(int l,int r,_T x){add(l,x);add(r+1,-x);}\n\tinline _T get(int a){_T ans=0;while(a){ans+=dt[a];a-=a&-a;}return ans;}\n\tinline _T get(int l,int r){return get(r)-get(l-1);}\n};\ntemplate<typename _T,int len>\nstruct segbit{\n\t_T dt[2][len];\n\tinline void add(int a,_T x){int b=a;while(a<len){dt[0][a]+=x;dt[1][a]+=x*b;a+=a&-a;}}\n\tinline void add(int l,int r,_T x){add(l,x);add(r+1,-x);}\n\tinline _T sum(int a){_T ans=0;int b=a;while(a){ans+=(b+1)*dt[0][a]-dt[1][a];a-=a&-a;}return ans;}\n\tinline _T sum(int l,int r){return sum(r)-sum(l-1);}\n};\nconst lf eps=1e-10;\nstruct point{\n\tlf x,y;\n\tlf ang;\n\tpoint(){}\n\tpoint(lf x,lf y):x(x),y(y){ang=atan2l(y,x);}\n\tinline point operator=(const point &pt){x=pt.x;y=pt.y;return *this;}\n\tinline point operator-()const{return point(-x,-y);}\n\tinline point operator+(const point &pt)const{return point(x+pt.x,y+pt.y);}\n\tinline point operator-(const point &pt)const{return point(x-pt.x,y-pt.y);}\n\tinline point operator*(const lf &a)const{return point(x*a,y*a);}\n\tinline point operator/(const lf &a)const{return point(x/a,y/a);}\n\tinline point operator^(const lf &ang)const{return point(x*cosl(ang)-y*sinl(ang),x*sinl(ang)+y*cosl(ang));}\n\tinline point operator+=(const point &pt){return *this=point(x+pt.x,y+pt.y);}\n\tinline point operator-=(const point &pt){return *this=point(x-pt.x,y-pt.y);}\n\tinline point operator*=(const lf &a){return *this=point(x*a,y*a);}\n\tinline point operator/=(const lf &a){return *this=point(x/a,y/a);}\n\tinline point operator^=(const lf &ang){return *this=point(x*cosl(ang)-y*sinl(ang),x*sinl(ang)+y*cosl(ang));}\n\tinline lf operator*(const point &pt)const{return x*pt.x+y*pt.y;}//dot\n\tinline lf operator%(const point &pt)const{return x*pt.y-y*pt.x;}//det\n\tinline lf length()const{return x*x+y*y;}\n\tinline lf size()const{return sqrtl(x*x+y*y);}\n\tinline lf operator^(const point &pt)const{return acosl(*this*pt)/length()/pt.length();}\n\tinline lf getangle(){return ang=atan2l(y,x);}\n\tinline lf angle()const{return atan2l(y,x);}\n\tinline bool operator<(const point &p)const{return ang<p.ang;}\n};\ninline bool xsmaller(const point &x,const point &y){return fabs(x.x-y.x)<1e-10?x.y<y.y:x.x<y.x;}\ninline bool ysmaller(const point &x,const point &y){return fabs(x.y-y.y)<1e-10?x.x<y.x:x.y<y.y;}\nstruct line{\n\tpoint a,b;\n\tline(){}\n\tline(point a,point b):a(a),b(b){}\n};\npoint inline intersect(line x,line y){\n\tpoint p1=x.a,v1=x.b-x.a;\n\tpoint p2=y.a,v2=y.b-y.a;\n\treturn p1+v1*(((p2-p1)%v2)/(v1%v2));\n}\ntemplate<int jt>\nint inline natsu_ksmii_with_jt(int a,int b){\n\tif(b<0)return natsu_ksmii_with_jt<jt>(a,jt-1-b);\n\tif(!b)return 1;\n\tint x=natsu_ksmii_with_jt<jt>(a,b>>1);\n\tx=1ll*x*x%jt;\n\tif(b&1)x=1ll*x*a%jt;\n\treturn x;\n}\ntemplate<int jt>\nstruct modint{\n\tint x;\n\tmodint(int X=0){x=X;x%=jt;if(x<0)x+=jt;}\n\tmodint(long long X=0){x=X%jt;if(x<0)x+=jt;}\n\tmodint<jt> inline &operator+=(const modint<jt> &m)const{x+=m.x;if(x>=jt)x-=jt;return *this;}\n\tmodint<jt> inline &operator++()const{return *this+=1;}\n\tmodint<jt> inline operator+(const modint<jt> &m)const{modint<jt> mc=*this;mc+=m;return mc;}\n\tmodint<jt> inline &operator-=(const modint<jt> &m)const{x-=m.x;if(x<0)x+=jt;return *this;}\n\tmodint<jt> inline &operator--()const{return *this-=1;}\n\tmodint<jt> inline operator-(const modint<jt> &m)const{modint<jt> mc=*this;mc-=m;return mc;}\n\tmodint<jt> inline operator*(const modint<jt> &m)const{return 1ll*x*m.x%jt;}\n\tmodint<jt> inline &operator*=(const modint<jt> &m)const{return *this=*this*m;}\n\tmodint<jt> inline inv()const{modint<jt> mc=*this;mc.x=natsu_ksmii_with_jt<jt>(mc.x,jt-2);}\n\tmodint<jt> inline &operator/(const modint<jt> &m)const{return 1ll*x*m.inv().x%jt;}\n\tmodint<jt> inline &operator/=(const modint<jt> &m)const{return *this=*this/m;}\n\tbool inline empty()const{return !x;}\n};\ninline int ksmii(int a,int b=jt-2){\n\tif(b<0){return ksmii(ksmii(a),-b);}\n\tif(!b){return 1;}\n\tint x=ksmii(a,b>>1);x=1ll*x*x%jt;\n\tif(b&1)x=1ll*x*a%jt;return x;\n}\ntypedef modint<jt> mint;\ntemplate<typename tp> tp gcd(tp a,tp b){return !b?a:gcd(b,a%b);}\ntemplate<int len>\nstruct bitmod{\n\tint dt[len];\n\tinline void add(int a,int x){while(a<len){dt[a]=(dt[a]+x)%jt;a+=a&-a;}}\n\tinline void add(int l,int r,int x){add(l,x%jt);add(r+1,jt-x%jt);}\n\tinline int get(int a){int ans=0;while(a){ans=(ans+dt[a])%jt;a-=a&-a;}return ans;}\n\tinline int get(int l,int r){return (get(r)-get(l-1)+jt)%jt;}\n};\ntemplate<int len>\nstruct DSU{\n\tint fa[len],sz[len];\n\tDSU(){loop(i,len)fa[i]=i,sz[i]=1;}\n\tvoid inline init(){loop(i,len)fa[i]=i,sz[i]=1;}\n\tint inline root(int x){return fa[x]==x?x:(fa[x]=root(fa[x]));}\n\tbool inline conn(int a,int b){a=root(a);b=root(b);if(a==b)return 0;fa[a]=b;sz[b]+=sz[a];return 1;}\n};\ntemplate<typename _T>\ninline _T qp(_T a,int b){\n\tif(!b){return 1;}\n\t_T x=qp(a,b>>1);x=x*x;\n\tif(b&1){x=x*a;}return x;\n}\ntemplate<int R,int C=R>\nstruct matrix{\n\tint mat[R][C];\n\tint* operator[](int x){return mat[x];}\n\tmatrix(){loop(i,R)loop(j,C)mat[i][j]=0;}\n\tmatrix(int x){loop(i,R)loop(j,C)mat[i][j]=(i==j?x:0);}\n\tmatrix<R,C> inline operator+(const matrix<R,C> m){\n\t\tmatrix<R,C> ans;\n\t\tloop(i,R)loop(j,C)ans.mat[i][j]=(mat[i][j]+m.mat[i][j])%jt;\n\t\treturn ans;\n\t}\n\ttemplate<int D> matrix<R,D> inline operator*(const matrix<C,D> m){\n\t\tmatrix<R,D> ans;\n\t\tloop(i,R)loop(j,C)loop(k,D)ans.mat[i][k]=(ans.mat[i][k]+((ll)mat[i][j])*m.mat[j][k])%jt;\n\t\treturn ans;\n\t}\n\tmatrix<R,C> inline operator+=(const matrix<R,C> m){\n\t\tmatrix<R,C> ans;\n\t\tloop(i,R)loop(j,C)ans.mat[i][j]=(mat[i][j]+m.mat[i][j])%jt;\n\t\treturn ans;\n\t}\n\tmatrix<R,C> inline operator-=(const matrix<R,C> m){\n\t\tmatrix<R,C> ans;\n\t\tloop(i,R)loop(j,C)ans.mat[i][j]=(mat[i][j]-m.mat[i][j]+jt)%jt;\n\t\treturn ans;\n\t}\n\tvoid inline debug(){loop(i,R){loop(j,C)cerr<<mat[i][j]<<' ';cerr<<endl;}cerr<<endl;}\n};\nstruct fastIO{\n\tinline fastIO operator>>(int& num){\n\t\tnum=0;char c=getchar();while(c!='-'&&(c<'0'||c>'9'))c=getchar();\n\t\tbool foo=0;if(c=='-'){foo=1;c=getchar();}\n\t\twhile(c>='0'&&c<='9'){num=(num<<3)+(num<<1)+c-'0';c=getchar();}\n\t\tif(foo)num=-num;return *this;\n\t}\n\tinline fastIO operator>>(ll& num){\n\t\tnum=0;char c=getchar();while(c!='-'&&(c<'0'||c>'9'))c=getchar();\n\t\tbool foo=0;if(c=='-'){foo=1;c=getchar();}\n\t\twhile(c>='0'&&c<='9'){num=(num<<3)+(num<<1)+c-'0';c=getchar();}\n\t\tif(foo)num=-num;return *this;\n\t}\n\tinline fastIO operator>>(float& num){scanf(\"%f\",&num);return *this;}\n\tinline fastIO operator>>(double& num){scanf(\"%lf\",&num);return *this;}\n\tinline fastIO operator>>(long double& num){scanf(\"%Lf\",&num);return *this;}\n\tinline fastIO operator>>(char& num){num=getchar();while(num==' '||num=='\\n')num=getchar();return *this;}\n\tinline fastIO operator>>(char* num){\n\t\tint cnt=0;char c=getchar();while(c==' '||c=='\\n')c=getchar();\n\t\twhile(c!=' '&&c!='\\n'){num[cnt++]=c;c=getchar();}num[cnt]=0;return *this;\n\t}\n\tinline fastIO operator>>(string& num){cin>>num;return *this;}\n\ttemplate<int jt> inline fastIO operator>>(modint<jt> &num){int x;*this>>x;num=x;return *this;}\n\tinline void printInt(const int& num){if(num<10){putchar(num+'0');return;}printInt(num/10);putchar((num%10)+'0');}\n\tinline void printll(const ll& num){if(num<10){putchar(num+'0');return;}printll(num/10);putchar((num%10)+'0');}\n\tinline fastIO operator<<(const int& num){if(num<0)putchar('-'),printInt(-num);else printInt(num);return *this;}\n\tinline fastIO operator<<(const ll& num){if(num<0)putchar('-'),printll(-num);else printll(num);return *this;}\n\tinline fastIO operator<<(const float& num){printf(\"%.10f\",num);return *this;}\n\tinline fastIO operator<<(const double& num){printf(\"%.16lf\",num);return *this;}\n\tinline fastIO operator<<(const long double& num){printf(\"%.20Lf\",num);return *this;}\n\tinline fastIO operator<<(const char& num){putchar(num);return *this;}\n\tinline fastIO operator<<(const char* num){for(int i=0;num[i];i++)putchar(num[i]);return *this;}\n\tinline fastIO operator<<(const string& num){cout<<num;return *this;}\n\ttemplate<int jt> inline fastIO operator<<(const modint<jt> &num){printInt(num.x);return *this;}\n\ttemplate<typename _T> inline fastIO operator<<(const vector<_T> &vec){printf(\"{ \");foreach(i,vec)operator<<(*i)<<' ';printf(\"}\");return *this;}\n}fio;\n\nint n,a[2005];\nvector<int> nei[2005],son[2005],cs[2005],ans;\nbool lgl[2005];\n\nvoid dfs(int now,int cc){\n\tcs[cc].pub(now);lgl[now]=1;\n\tforeach(i,nei[now])if(!lgl[*i])dfs(*i,cc),son[now].pub(*i);\n}\n\nint main(){\n\tfio>>n;cont(i,n)fio>>a[i];sort(a+1,a+n+1);\n\tcont(i,n)cont(j,n)if(gcd(a[i],a[j])!=1)nei[i].pub(j);\n\tint ccs=0;cont(i,n)if(!lgl[i])dfs(i,++ccs);\n\tpriq<pair2<int> > pq;cont(i,ccs)pq.push(mak(a[cs[i][0]],cs[i][0]));\n\twhile(pq.size()){\n\t\tpair2<int> X=pq.top();pq.pop();\n\t\tint v=X.ST,x=X.ND;ans.pub(v);\n\t\tforeach(i,son[x])pq.push(mak(a[*i],*i));\n\t}\n\tforeach(i,ans)fio<<*i<<' ';fio<<ln;return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<cstring>\n#include<algorithm>\n#include<strak>\n#define fo(i,a,b) for(i=a;i<=b;i++)\n#define ll long long\nusing namespace std;\nint n,a[2005],tot,du[2005],h[2005],to[4000005],nex[4000005];\nbool bhz[2005][2005],pd[2005];\nint gcd(int a,int b)\n{\n    return b?gcd(b,a%b):a;\n}\nstruct node{\n    int fr,id;\n}st;\nbool operator <(node a,node b)\n{\n    return a.fr<b.fr;\n}\nstrak<node> q;\nvoid add(int a,int b)\n{\n    du[b]++;\n    to[++tot]=b;\n    nex[tot]=h[a];\n    h[a]=tot;\n}\nvoid dfs(int x)\n{\n    pd[x]=1;\n    for(int i=1;i<=n;i++)\n        if(bhz[x][i]&&!pd[i])\n        {\n            add(x,i);\n            dfs(i);\n        }\n}\nint main()\n{\n    cin>>n;\n    for(int i=1;i<=n;i++) cin>>a[i];\n    sort(a+1,a+n+1);\n    for(int i=1;i<=n-1;i++)\n    for(int j=i+1;j<=n;j++)\n    if(gcd(a[i],a[j])>1) bhz[i][j]=bhz[j][i]=1;\n    for(int i=1;i<=n;i++) if(!pd[i]) dfs(i);\n    for(int i=1;i<=n;i++) \n        if(!du[i])\n        { \n            st.fr=a[i];\n            st.id=i;\n            q.push(st); \n        }\n    for(int i=1;i<=n;i++)\n    {\n        st=q.top();\n        q.pop();\n        int now=st.id;\n        cout<<a[now]<<\" \";\n        int t=h[now];\n        while (t){\n            du[to[t]]--;\n            if (!du[to[t]]){\n                st.fr=a[to[t]];\n                st.id=to[t];\n                q.push(st);\n            }\n            t=nex[t];\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nconst int maxn = 2030, oo = 123456789, maxm = 34010;\n \nint n, m, T, ans, mn, a[maxn], foo[maxn], lst[maxm], tag[maxn], q[maxn], rar, mx[maxn];\nbool vis[maxn], f[maxn], G[maxn][maxn], F[maxn];\nstd::vector<int> g[maxn], has[maxn], rhas[maxm], all;\nstd::vector<std::pair<int, int> > v;\n \nvoid GEN() {\n\tint mx = 0;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif(!foo[i]) {\n\t\t\tif(a[i] == 1) {\n\t\t\t\tF[i] = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tF[i] = 0;\n\t\t\t\tfor (int j: has[i]) {\n\t\t\t\t\tif(lst[j] >= mx) {\n\t\t\t\t\t\tF[i] = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t(foo[i] > mx) && (mx = foo[i]);\n\t\t}\n\t}\n\treturn;\n}\n /*\ninline void dfs(int &u) {\n\ttag[u] = T;\n\t(F[u] && a[u] < mn) && (mn = a[u]);\n\tvis[u] = 1;\n\tfor (int &v: g[u]) {\n\t\tif(!vis[v] && !f[v]) {\n\t\t\tdfs(v);\n\t\t}\n\t}\n\treturn;\n}\n */\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tscanf(\"%d\", a + i);\n\t\tint t = a[i];\n\t\tfor (int x = 2; x * x <= t; ++x) {\n\t\t\tif(t % x == 0) {\n\t\t\t\tall.push_back(x);\n\t\t\t\twhile(t % x == 0) {\n\t\t\t\t\tt /= x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(t > 1) {\n\t\t\tall.push_back(t);\n\t\t}\n\t}\n\tstd::sort(a + 1, a + n + 1);\n\tstd::sort(all.begin(), all.end());\n\tall.resize(std::unique(all.begin(), all.end()) - all.begin());\n\tm = (int)(all.size());\n\tfor (int i = 1; i <= n; ++i) {\n\t\tF[i] = 1;\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tif(a[i] % all[j] == 0) {\n\t\t\t\thas[i].push_back(j);\n\t\t\t\trhas[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int j = 0; j < m; ++j) {\n\t\tfor (int i = 0; i < (int)(rhas[j].size()); ++i) {\n\t\t\tfor (int k = 0; k < i; ++k) {\n\t\t\t\tint u = rhas[j][i], v = rhas[j][k];\n\t\t\t\tif(!G[u][v]) {\n\t\t\t\t\tg[u].push_back(v);\n\t\t\t\t\tg[v].push_back(u);\n\t\t\t\t\tG[u][v] = G[v][u] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n//\t\tGEN();\n\t\tmemset(vis + 1, 0, sizeof(vis[0]) * n);\n\t\tv.clear();\n\t\tfor (int u = 1; u <= n; ++u) {\n\t\t\tif(F[u]) {\n\t\t\t\tif(!vis[u] && !f[u]) {\n\t\t\t\t\t++T;\n\t\t\t\t\tmn = oo;\n//\t\t\t\t\tdfs(u);\n\t\t\t\t\trar = 0;\n\t\t\t\t\tq[rar++] = u;\n\t\t\t\t\tvis[u] = 1;\n\t\t\t\t\tfor (register int fnt = 0; fnt < rar; ++fnt) {\n\t\t\t\t\t\tint u = q[fnt];\n\t\t\t\t\t\ttag[u] = T;\n\t\t\t\t\t\t(F[u] && a[u] < mn) && (mn = a[u]);\n\t\t\t\t\t\tfor (int &v: g[u]) {\n\t\t\t\t\t\t\tif(!vis[v] && !f[v]) {\n\t\t\t\t\t\t\t\tq[rar++] = v;\n\t\t\t\t\t\t\t\tvis[v] = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tv.push_back(std::make_pair(mn, T));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstd::sort(v.begin(), v.end());\n\t\tint sz = (int)(v.size());\n\t\t//ans = 0;\n\t\tfor (int u = 1; u <= n; ++u) {\n\t\t\tif(F[u] && !f[u]) {\n\t\t\t\tint i = sz - 1;\n\t\t\t\tif(v[i].second == tag[u]) {\n\t\t\t\t\t--i;\n\t\t\t\t}\n\t\t\t\tif(i < 0 || v[i].first <= a[u]) {\n\t\t\t\t\tans = u;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tf[ans] = 1;\n\t\tfoo[ans] = i;\n\t\tprintf(\"%d \", a[ans]);\n\t\tfor (int j: has[ans]) {\n\t\t\tlst[j] = i;\n\t\t}\n\t\tfor (register int &u: g[ans]) {\n\t\t\t\tF[u] = 1;\n\t\t}\n\t\tfor (register int j = ans + 1; j <= n; ++j) {\n\t\t\tmx[j] = i;\n\t\t\tF[j] = G[ans][j];\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iomanip>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define all(x) (x).begin(),(x).end()\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n \ntemplate<class T> inline bool chmax(T &a, T b){\n    if(a<b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T> inline bool chmin(T &a, T b){\n    if(a>b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<typename T>\nT gcd(T a, T b)\n{\n    return b ? gcd(b, a % b) : a;\n}\n\ntemplate<typename T>\nT lcm(T a,T b)\n{\n    return  a / gcd(a,b) * b;\n}\nclass UnionFind {\nprivate:\n    int sz;\n    vector<int> par, size_;\npublic:\n    UnionFind(){}\n    UnionFind(int node_size) : sz(node_size), par(sz), size_(sz, 1){\n        iota(par.begin(), par.end(), 0);\n    }\n    int find(int x){\n        if(par[x] == x) return x;\n        else return par[x] = find(par[x]);\n    }\n    void unite(int x,int y){\n        x = find(x), y = find(y);\n        if(x == y) return;\n        if(size_[x] < size_[y]) swap(x,y);\n        par[y] = x;\n        size_[x] += size_[y];\n    }\n    int size(int x){\n        x = find(x);\n        return size_[x];\n    }\n    bool same(int x,int y){\n        return find(x) == find(y);\n    }\n};\nclass BSTNode {\npublic:\n    const int from, to;\n    int sz;\n    bool subtree_edge, subofftree_edge, exact_level;\n    BSTNode *left, *right, *par;\n    unordered_set<int> adjacent;\n    BSTNode(const int _ver) noexcept :\n        from(_ver), to(_ver), sz(0), subtree_edge(false), subofftree_edge(false),\n            exact_level(false), left(nullptr), right(nullptr), par(nullptr){}\n    BSTNode(const int _from, const int _to, const bool _flag) noexcept :\n        from(_from), to(_to), sz(0), subtree_edge(false), subofftree_edge(false),\n            exact_level((from < to) && _flag), left(nullptr), right(nullptr), par(nullptr){}\n    inline bool IsRoot() const noexcept { return !par; }\n    inline bool IsVertex() const noexcept { return (from == to); }\n    inline void eval() noexcept {\n        if(IsVertex()) sz = 1, subtree_edge = false, subofftree_edge = !adjacent.empty();\n        else sz = 0, subtree_edge = exact_level, subofftree_edge = false;\n        if(left){\n            sz += left->sz, subtree_edge |= left->subtree_edge, subofftree_edge |= left->subofftree_edge;\n        }\n        if(right){\n            sz += right->sz, subtree_edge |= right->subtree_edge, subofftree_edge |= right->subofftree_edge;\n        }\n    }\n    inline void subtree_edge_eval(){\n        subtree_edge = exact_level;\n        if(left) subtree_edge |= left->subtree_edge;\n        if(right) subtree_edge |= right->subtree_edge;\n    }\n    inline void subofftree_edge_eval(){\n        subofftree_edge = !adjacent.empty();\n        if(left) subofftree_edge |= left->subofftree_edge;\n        if(right) subofftree_edge |= right->subofftree_edge;\n    }\n    inline bool subofftree_check(){\n        return !adjacent.empty() ||\n                (left ? left->subofftree_edge : false) || (right ? right->subofftree_edge : false);\n    }\n    inline bool offtree_check(){\n        return adjacent.empty() ||\n                (left ? left->subofftree_edge : false) || (right ? right->subofftree_edge : false);\n    }\n    void rotate(const bool right_) noexcept {\n        BSTNode *p = par, *g = p->par;\n        if(right_){\n            if((p->left = right)) right->par = p;\n            right = p, p->par = this;\n        }else{\n            if((p->right = left)) left->par = p;\n            left = p, p->par = this;\n        }\n        p->eval(), eval();\n        if(!(par = g)) return;\n        if(g->left == p) g->left = this;\n        if(g->right == p) g->right = this;\n        g->eval();\n    }\n};\n \nBSTNode *splay(BSTNode *u) noexcept {\n    if(!u) return nullptr;\n    while(!(u->IsRoot())){\n        BSTNode *p = u->par, *gp = p->par;\n        if(p->IsRoot()){ // zig\n            u->rotate((u == p->left));\n        }else{\n            bool flag = (u == p->left);\n            if((u == p->left) == (p == gp->left)){ // zig-zig\n                p->rotate(flag), u->rotate(flag);\n            }else{ // zig-zag\n                u->rotate(flag), u->rotate(!flag);\n            }\n        }\n    }\n    return u;\n}\n \nBSTNode *join(BSTNode *root1, BSTNode *root2) noexcept {\n    if(!root1 || !root2) return root1 ? root1 : root2;\n    BSTNode *cur = nullptr, *nx = root1;\n    do{ cur = nx, nx = cur->right; }while(nx);\n    BSTNode *ver = splay(cur);\n    ver->right = root2, ver->eval(), root2->par = ver;\n    return ver;\n}\n \nclass EulerTourTree {\npublic:\n    struct pair_hash {\n        template <class T1, class T2>\n        size_t operator() (const pair<T1, T2>& p) const {\n            size_t lhs = hash<T1>()(p.first), rhs = hash<T2>()(p.second);\n            return lhs^(rhs+0x9e3779b9+(lhs<<6)+(lhs>>2));\n        }\n    };\n    BSTNode** vertex_set;\n    unordered_map<pair<int, int>, pair<BSTNode*, BSTNode*>, pair_hash> edge_set;\nprivate:\n    BSTNode *reroot(BSTNode *ver) noexcept {\n        BSTNode *res = splay(ver)->left;\n        if(!res) return ver;\n        ver->left = nullptr, ver->eval();\n        while(ver->right) ver = ver->right;\n        splay(ver), ver->right = res, ver->eval(), res->par = ver;\n        return ver;\n    }\n    void link(BSTNode *ver1, BSTNode *ver2, const bool flag) noexcept {\n        BSTNode *e1 = new BSTNode(ver1->from, ver2->from, flag);\n        BSTNode *e2 = new BSTNode(ver2->from, ver1->from, flag);\n        edge_set[{ver1->from, ver2->from}] = {e1, e2};\n        join(join(reroot(ver1), e1), join(reroot(ver2), e2));\n    }\n    void cut(BSTNode *edge1, BSTNode *edge2) noexcept {\n        splay(edge1), splay(edge2);\n        BSTNode *p = edge1->par;\n        bool _right = (edge1 == edge2->right);\n        if(p != edge2){\n            _right = (p == edge2->right);\n            p->par = nullptr, edge1->rotate((edge1 == p->left));\n        }\n        if(edge1->left) edge1->left->par = nullptr;\n        if(edge1->right) edge1->right->par = nullptr;\n        if(_right){\n            if(edge2->left) edge2->left->par = nullptr;\n            join(edge2->left, edge1->right);\n        }else{\n            if(edge2->right) edge2->right->par = nullptr;\n            join(edge1->left, edge2->right);\n        }\n        // delete edge1; delete edge2;\n    }\n    bool connected(BSTNode *ver1, BSTNode *ver2) noexcept {\n        splay(ver1), splay(ver2);\n        return ver1->par;\n    }\n    int component_size(BSTNode *ver) noexcept { return splay(ver)->sz; }\npublic:\n    int V;\n    EulerTourTree(){}\n    // ~EulerTourTree(){\n    //     for(auto it : edge_set){\n    //         delete (it.second).first;\n    //         delete (it.second).second;\n    //     }\n    //     for(int i = 0; i < V; ++i) delete vertex_set[i];\n    //     delete[] vertex_set;\n    // }\n    void resize(const int node_size) noexcept {\n        V = node_size, vertex_set = new BSTNode*[V];\n        for(int i = 0; i < V; i++) vertex_set[i] = new BSTNode(i);\n    }\n    void reroot(const int node_id) noexcept { reroot(vertex_set[node_id]); }\n    void link(int node1_id, int node2_id, bool flag=true) noexcept {\n        if(node1_id > node2_id) swap(node1_id, node2_id);\n        link(vertex_set[node1_id], vertex_set[node2_id], flag);\n    }\n    void cut(int node1_id, int node2_id){\n        if(node1_id > node2_id) swap(node1_id, node2_id);\n        auto it = edge_set.find({node1_id, node2_id});\n        assert(it != edge_set.end());\n        BSTNode *edge1 = (it->second).first, *edge2 = (it->second).second;\n        edge_set.erase(it);\n        cut(edge1, edge2);\n    }\n    bool connected(const int node1_id, const int node2_id) noexcept {\n        if(node1_id == node2_id) return true;\n        return connected(vertex_set[node1_id], vertex_set[node2_id]);\n    }\n    int component_size(int node_id) noexcept { return component_size(vertex_set[node_id]); }\n    void check_dfs(const BSTNode* cur) const noexcept {\n        if(cur->left) check_dfs(cur->left);\n        cout << \"{\" << (cur->from) << \",\" << (cur->to) << \"} \";\n        if(cur->right) check_dfs(cur->right);\n    }\n};\n \nclass DynamicConnectivity {\nprivate:\n    BSTNode *level_up_dfs(BSTNode *cur, const int layer) noexcept {\n        if(cur->exact_level){\n            splay(cur)->exact_level = false, cur->subtree_edge_eval();\n            detect_layer[{cur->from, cur->to}]++, et[layer+1].link(cur->from, cur->to);\n            return cur;\n        }\n        if(cur->left && cur->left->subtree_edge) return level_up_dfs(cur->left, layer);\n        if(cur->right && cur->right->subtree_edge) return level_up_dfs(cur->right, layer);\n        return nullptr;\n    }\n    BSTNode *search_edge_dfs\n        (BSTNode *cur, const int layer, const int another, bool& flag, pair<int, int>& rep_edge) noexcept {\n        if(!cur->adjacent.empty()){\n            bool state = et[layer+1].vertex_set[cur->from]->adjacent.empty();\n            for(auto it = cur->adjacent.begin(); it != cur->adjacent.end();){\n                pair<int, int> e = {min(cur->from, *it), max(cur->from, *it)};\n                BSTNode *correspond = et[layer].vertex_set[*it];\n                if(et[layer].connected(another, *it)){\n                    flag = true, rep_edge = e;\n                    cur->adjacent.erase(it), correspond->adjacent.erase(cur->from);\n                    if(!correspond->subofftree_check()){\n                        splay(correspond)->subofftree_edge_eval();\n                    }\n                    break;\n                }else{\n                    if(!et[layer+1].vertex_set[*it]->subofftree_check()){\n                        splay(et[layer+1].vertex_set[*it])->subofftree_edge = true;\n                    }\n                    et[layer+1].vertex_set[cur->from]->adjacent.insert(*it);\n                    et[layer+1].vertex_set[*it]->adjacent.insert(cur->from);\n                    detect_layer[e]++, it = cur->adjacent.erase(it);\n                    correspond->adjacent.erase(cur->from);\n                    if(!correspond->subofftree_check()){\n                        splay(correspond)->subofftree_edge_eval();\n                    }\n                }\n            }\n            if(state && !et[layer+1].vertex_set[cur->from]->offtree_check()){\n                splay(et[layer+1].vertex_set[cur->from])->subofftree_edge = true;\n            }\n            splay(cur)->subofftree_edge_eval();\n            return cur;\n        }\n        if(cur->left && cur->left->subofftree_edge){\n            return search_edge_dfs(cur->left, layer, another, flag, rep_edge);\n        }\n        if(cur->right && cur->right->subofftree_edge){\n            return search_edge_dfs(cur->right, layer, another, flag, rep_edge);\n        }\n        return nullptr;\n    }\n    bool replace(const int from, const int to, const int layer) noexcept {\n        if(layer < 0) return true;\n        int u, v;\n        if(et[layer].component_size(from) <= et[layer].component_size(to)) u = from, v = to;\n        else u = to, v = from;\n        BSTNode *ver = splay(et[layer].vertex_set[u]);\n        while(ver->subtree_edge) ver = level_up_dfs(ver, layer);\n        pair<int, int> rep_edge = {-1, -1};\n        bool flag = false;\n        while(ver->subofftree_edge){\n            ver = search_edge_dfs(ver, layer, v, flag, rep_edge);\n            if(flag) break;\n        }\n        if(flag){\n            et[layer].link(rep_edge.first, rep_edge.second);\n            for(int i = 0; i < layer; i++) et[i].link(rep_edge.first, rep_edge.second, false);\n            return false;\n        }else return replace(from, to, layer-1);\n    }\npublic:\n    const int V, layer_count;\n    EulerTourTree* et;\n    unordered_map<pair<int, int>, int, EulerTourTree::pair_hash> detect_layer;\n    DynamicConnectivity(int node_size) noexcept : V(node_size), layer_count(ceil(log2(V))+1){\n        et = new EulerTourTree[layer_count];\n        for(int i = 0; i < layer_count; i++) et[i].resize(V);\n    }\n    // ~DynamicConnectivity(){\n    //     delete[] et;\n    // }\n    bool link(int node1_id, int node2_id) noexcept {\n        if(node1_id > node2_id) swap(node1_id, node2_id);\n        detect_layer[{node1_id, node2_id}] = 0;\n        if(et[0].connected(node1_id, node2_id)){\n            BSTNode *ver1 = et[0].vertex_set[node1_id], *ver2 = et[0].vertex_set[node2_id];\n            splay(ver1)->subofftree_edge = true, ver1->adjacent.insert(node2_id);\n            splay(ver2)->subofftree_edge = true, ver2->adjacent.insert(node1_id);\n            return false;\n        }else{\n            et[0].link(node1_id, node2_id);\n            return true;\n        }\n    }\n    bool cut(int node1_id, int node2_id) noexcept {\n        if(node1_id > node2_id) swap(node1_id, node2_id);\n        auto it = detect_layer.find({node1_id, node2_id});\n        assert(it != detect_layer.end());\n        int layer = it->second;\n        detect_layer.erase(it);\n        auto& st = et[layer].vertex_set[node1_id]->adjacent;\n        if(st.find(node2_id) == st.end()){\n            for(int i = 0; i <= layer; i++) et[i].cut(node1_id, node2_id);\n            return replace(node1_id, node2_id, layer);\n        }else{\n            et[layer].vertex_set[node1_id]->adjacent.erase(node2_id);\n            if(!et[layer].vertex_set[node1_id]->subofftree_check()){\n                splay(et[layer].vertex_set[node1_id])->subofftree_edge_eval();\n            }\n            et[layer].vertex_set[node2_id]->adjacent.erase(node1_id);\n            if(!et[layer].vertex_set[node2_id]->subofftree_check()){\n                splay(et[layer].vertex_set[node2_id])->subofftree_edge_eval();\n            }\n            return false;\n        }\n    }\n    bool connected(const int node1_id, const int node2_id) noexcept {\n        return et[0].connected(node1_id, node2_id);\n    }\n};\nvector<int>a;\nvector<int> calc(pii e_min,vector<vector<int> > &g,set<int> &st,DynamicConnectivity &dc){\n    vector<int> res;\n    res.push_back(e_min.first);\n    if(st.size()==1){\n        return res;\n    }\n    int id = e_min.second;\n    vector<pii> v;\n    st.erase(id);\n    for(auto x:g[id]){\n        if(st.count(x)==1){\n            dc.cut(id,x);\n            v.push_back(MP(a[x],x));\n        }\n    }\n    sort(v.begin(),v.end());\n    vector<vector<int> > ss;\n    for(auto &x:v){\n        if(st.count(x.second)==0)continue;\n        set<int> p;\n        for(auto &y:st){\n            if(dc.connected(x.second,y)){\n                p.insert(y);\n            }\n        }\n        for(auto y:p){\n            st.erase(y);\n        }\n        ss.push_back(calc(x,g,p,dc));\n    }\n    priority_queue<pair<int,pii > > pp;\n    int m = ss.size();\n    rep(i,m){\n        pp.push(MP(ss[i][0],MP(i,0)));\n    }\n    while(!pp.empty()){\n        auto x = pp.top();\n        pp.pop();\n        res.push_back(x.first);\n        if(ss[x.second.first].size()!=x.second.second+1){\n            pp.push(MP(ss[x.second.first][x.second.second+1],MP(x.second.first,x.second.second+1)));\n        }\n    }\n    return res;\n}\n\nint main(){\n    int n;\n    cin >> n;\n    a.resize(n);\n    \n    rep(i,n){\n        cin >> a[i];\n    }\n    DynamicConnectivity dc(n);\n    vector<vector<int> > g(n);\n    UnionFind uf(n);\n    rep(i,n){\n        for(int j=i+1;j<n;j++){\n            if(gcd(a[i],a[j])!=1){\n                g[i].push_back(j);\n                g[j].push_back(i);\n                dc.link(i,j);\n                uf.unite(i,j);\n            }\n        }\n    }\n    vector<pair<int,int> > p(n,MP(inf,inf));\n    vector<set<int> > st(n);\n    rep(i,n){\n        p[uf.find(i)] = min(MP(a[i],i),p[uf.find(i)]);\n        st[uf.find(i)].insert(i);\n    }\n    vector<bool> used(n);\n    vector<vector<int> > res;\n    rep(i,n){\n        if(!used[uf.find(i)]){\n            int k = uf.find(i);\n            used[k] = 1;\n            auto ss = p[k];\n            res.push_back(calc(ss,g,st[k],dc));\n        }\n    }\n    priority_queue<pair<int,pii > > pp;\n    int m = res.size();\n    rep(i,m){\n        pp.push(MP(res[i][0],MP(i,0)));\n    }\n    vector<int> ans;\n    while(!pp.empty()){\n        auto x = pp.top();\n        pp.pop();\n        ans.push_back(x.first);\n        if(res[x.second.first].size()!=x.second.second+1){\n            pp.push(MP(res[x.second.first][x.second.second+1],MP(x.second.first,x.second.second+1)));\n        }\n    }\n    for(auto x:ans){\n        cout << x << \" \";\n    }\n    cout << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <bitset>\n#include <cstdio>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <cassert>\n#include <climits>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\n#include <functional>\nusing namespace std ;\n\n#define rep(i, a, b) for (int (i) = (a); (i) <= (b); (i)++)\n#define Rep(i, a, b) for (int (i) = (a) - 1; (i) < (b); (i)++)\n#define REP(i, a, b) for (int (i) = (a); (i) >= (b); (i)--)\n#define clr(a) memset(a, 0, sizeof(a))\n#define Sort(a, len, cmp) sort(a + 1, a + len + 1, cmp)\n#define ass(a, sum) memset(a, sum, sizeof(a))\n\n#define ls ((rt) << 1)\n#define rs ((rt) << 1 | 1)\n#define lowbit(x) (x & -x)\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define endl '\\n'\n#define ENDL cout << endl\n#define SZ(x) ((int)x.size())\n\ntypedef long long ll ;\ntypedef unsigned long long ull ;\ntypedef vector <int> Vi ;\ntypedef pair <int, int> Pii ;\ntypedef pair <ll, ll> Pll ;\ntypedef map <int, int> mii ;\ntypedef map <string, int> msi ;\ntypedef map <ll, ll> mll ;\n\nconst int N = 2010 ;\nconst double eps = 1e-8 ;\nconst int iinf = INT_MAX ;\nconst ll linf = 2e18 ;\nconst double dinf = 1e30 ;\nconst int MOD = 1000000007 ;\n\ninline int read(){\n    int X = 0, w = 0 ;\n\tchar ch = 0 ;\n    while (!isdigit(ch)) { w |= ch == '-' ; ch = getchar() ; }\n    while (isdigit(ch)) X = (X << 3) + (X << 1) + (ch ^ 48), ch = getchar() ;\n    return w ? - X : X ;\n}\n\nvoid write(int x){\n     if (x < 0) putchar('-'), x = - x ;\n     if (x > 9) write(x / 10) ;\n     putchar(x % 10 + '0') ;\n}\n\nvoid print(int x) {\n\tcout << x << endl ;\n\texit(0) ;\n}\n\nvoid PRINT(string x) {\n\tcout << x << endl ;\n\texit(0) ;\n}\n\nvoid douout(double x){\n\t printf(\"%lf\\n\", x + 0.0000000001) ;\n}\n\nint vis[N], ok[N][N], in[N], a[N] ;\nvector <int> g[N] ;\nint n ;\n\nvoid dfs(int rt) {\n\tvis[rt] = 1 ;\n\tfor (int i = 1; i <= n; i++)\n\tif (!vis[i] && ok[rt][i]) {\n\t\tin[i]++ ;\n\t\tg[rt].pb(i) ;\n\t\tdfs(i) ;\n\t}\n}\n\nvoid Top() {\n\tpriority_queue <int> q ;\n\tfor (int i = 1;  i <= n; i++) if (!in[i]) q.push(i) ;\n\twhile (!q.empty()) {\n\t\tint now = q.top() ;\n\t\tq.pop() ;\n\t\tcout << a[now] << \" \" ;\n\t\tfor (int i = 0; i < SZ(g[now]); i++) q.push(g[now][i]) ;\n\t}\n}\n\nsigned main(){\n\tscanf(\"%d\", &n) ;\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]) ;\n\tsort(a + 1, a + n + 1) ;\n\tclr(ok) ;\n\tfor (int i = 1; i <= n; i++)\n\tfor (int j = i + 1; j <= n; j++)\n\tif (__gcd(a[i], a[j]) != 1) ok[i][j] = ok[j][i] = 1 ;\n\tfor (int i = 1; i <= n; i++) if (!vis[i]) dfs(i) ;//连通块\n\tTop() ;\n}\n\n/*\n写代码时请注意：\n\t1.是否要开Long Long？数组边界处理好了么？\n\t2.实数精度有没有处理？\n\t3.特殊情况处理好了么？\n\t4.做一些总比不做好。\n思考提醒：\n\t1.最大值和最小值问题可不可以用二分答案？\n\t2.有没有贪心策略？否则能不能dp？\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int Maxn=2005;\nint n,a[Maxn];\nbool vis[Maxn];\nvector <int> g[Maxn],e[Maxn];\nvoid dfs(int u)\n{\n\tif (vis[u]) return;\n\tvis[u]=true;\n\tfor (int i=0;i<g[u].size();++i)\n\t{\n\t\tint v=g[u][i];\n\t\tif (!vis[v])\n\t\t{\n\t\t\tdfs(v);\n\t\t\te[u].push_back(v);\n\t\t}\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=0;i<n;++i) scanf(\"%d\",a+i);\n\tsort(a,a+n);\n\tfor (int i=0;i<n;++i) for (int j=0;j<n;++j)\n\t\tif (__gcd(a[i],a[j])>1) g[i].push_back(j);\n\tpriority_queue <int> pq;\n\tfor (int i=0;i<n;++i) if (!vis[i])\n\t{\n\t\tdfs(i);\n\t\tpq.push(i);\n\t}\n\twhile (!pq.empty())\n\t{\n\t\tint u=pq.top();pq.pop();\n\t\tfor (int i=0;i<e[u].size();++i) pq.push(e[u][i]);\n\t\tprintf(\"%d \",a[u]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\nstruct UnionFind{\n  Int n;\n  vector<Int> r,p;\n  UnionFind(Int x,Int y):n(x+y),r(x+y,1),p(x+y,0){\n    iota(p.begin(),p.end(),0);\n    for(Int i=0;i<x;i++) r[i]=1;\n    for(Int i=0;i<y;i++) r[x+i]=0;\n  }\n  Int find(Int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(Int x,Int y){\n    return find(x)==find(y);\n  }\n  void unite(Int x,Int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    if(r[x]<r[y]) swap(x,y);\n    r[x]+=r[y];\n    p[y]=x;\n  }\n};\n\n\ntemplate<typename T> \nmap<T, Int> factorize(T x){\n  map<T, Int> res;\n  for(Int i=2;i*i<=x;i++){\n    while(x%i==0){\n      x/=i;\n      res[i]++;\n    }\n  }\n  if(x!=1) res[x]++;\n  return res;\n}\n\n//INSERT ABOVE HERE\nInt cop[2020][2020];\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<Int> a(n);\n  for(Int i=0;i<n;i++) cin>>a[i];\n  sort(a.begin(),a.end());\n\n  vector<Int> ans(n),used(n,0),post(n,0);\n\n  memset(cop,0,sizeof(cop));\n  \n  for(Int i=0;i<n;i++)\n    for(Int j=0;j<n;j++)\n      cop[i][j]=__gcd(a[i],a[j])>1;\n\n  Int m=0;\n  map<Int, Int> r;\n\n  vector<vector<Int> > G(n);\n  for(Int i=0;i<n;i++){\n    auto x=factorize(a[i]);\n    for(auto p:x){\n      if(!r.count(p.first)) r[p.first]=m++;\n      G[i].emplace_back(r[p.first]);\n    }\n  }\n  \n  for(Int t=0;t<n;t++){\n    UnionFind uf(n,m);\n    for(Int i=0;i<n;i++)\n      if(!used[i]) for(Int j:G[i]) uf.unite(i,n+j);\n    \n    Int idx=-1;\n    auto nxt=[&](){\n\t       Int sum=t;\n\t       set<Int> tmp;\n\t       for(Int i=0;i<n;i++){\n\t\t if(used[i]) continue;\n\t\t Int k=uf.find(i);\n\t\t if(!tmp.count(k)){\n\t\t   tmp.emplace(k);\n\t\t   sum+=uf.r[k];\n\t\t }\n\t\t if(post[i]) continue;\n\t\t if(sum==n){\n\t\t   idx=i;\n\t\t   break;\n\t\t }\n\t       }\n\t       //assert(sum==n);\n\t     };\n    nxt();\n    while(idx<0);\n    used[idx]=1;\n    ans[t]=idx;\n    \n    for(Int i=0;i<n;i++){\n      if(!uf.same(idx,i)) continue;\n      if(cop[idx][i]) post[i]=0;\n      else if(a[idx]<a[i]) post[i]=1;\n    }\n  }\n\n\n  vector<Int> b(n);\n  for(Int i=0;i<n;i++) b[i]=a[ans[i]];\n  \n  vector<vector<Int> > H(n);\n  for(Int i=0;i<n;i++)\n    for(Int j=i+1;j<n;j++)\n      if(__gcd(b[i],b[j])>1) H[i].emplace_back(j);\n\n  vector<Int> indeg(n);\n  for(Int i=0;i<n;i++)\n    for(Int j:H[i]) indeg[j]++;\n  \n  using P = pair<Int, Int>;\n  priority_queue<P> pq;\n  for(Int i=0;i<n;i++)\n    if(!indeg[i]) pq.emplace(b[i],i);\n\n  vector<Int> c;\n  while(!pq.empty()){\n    P p=pq.top();pq.pop();\n    c.emplace_back(p.first);\n    for(Int u:H[p.second]){\n      indeg[u]--;\n      if(!indeg[u]) pq.emplace(b[u],u);\n    }\n  }\n  \n  assert(c.size()==n);\n  for(Int i=0;i<n;i++){\n    if(i) cout<<\" \";\n    cout<<c[i];\n  }\n  cout<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define all(x)  x.begin(), x.end()\n\nint n;\nint used[2020];\nvector<int> a, ans;\n\nvoid dfs(int v) {\n        used[v] = true;\n        ans.push_back(a[v]);\n        for (int u = 0; u < n; u ++) {\n                if (!used[u] && __gcd(a[v], a[u]) != 1) dfs(u);\n        }\n}\n\nint main() {\n        scanf(\"%d\", &n);\n        a.resize(n);\n        for (int i = 0; i < n; i ++) scanf(\"%d\", &a[i]);\n        sort(all(a));\n        for (int i = 0; i < n; i ++) if (!used[i]) dfs(i);\n        for (int i = 0; i < n; i ++) {\n                int p = i;\n                for (int j = i - 1; j >= 0 && __gcd(ans[i], ans[j]) == 1; j --) {\n                        if (ans[j] < ans[i]) p = j;\n                }\n                rotate(ans.begin() + p, ans.begin() + i, ans.begin() + i + 1);\n        }\n        for (int i = 0; i < n; i ++) cout << ans[i] << (i == n - 1 ? '\\n' : ' ');\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \nusing namespace std;\n//author_name:tourist\n//date:2018/11/18\n//title:AGC 010 E Rearranging\n//ÒòÎªÇÓÅ³£¬ËùÒÔÌÓ±ÜÉúÃü£¬ÒÔ²»µÖ¿¹ÔÚ×îºÚ°µµÄ³ÁÂÙÖÐÉú³ö½¾°Á£¬ÒòÎª½¾°Á£¬ËùÒÔ²»Ñ¡ÔñÉú£¬ËùÒÔ¾Ü³â´Ö±ÉµÄÀÖ¹ÛÖ÷Òå¡£\n//Ìì²ÅµÄ±¯¾çµØÓÚ±»Ð¡¶øÊæÊÊµÄÃûÍûËùÊø¸¿¡£\n//It's human to lie. Most of the time we can't even be honest with ourselves.\n\nconst int N=2010;\nconst int NN=2010;\n\nconst int one=1;\nunsigned long long g[N][NN];\nunsigned long long was[NN];\n\nint a[N];\nint x[N];\nbool alive[N];\nbool can_put[N];\n\nint main()\n{\t\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++)\n\t\tscanf(\"%d\",a+i);\n\tfor(int i=0;i<n;i++)\n\t\tfor(int j=0;j<n;j++)\n\t\t\tif(__gcd(a[i],a[j])>1)\n\t\t\t{\n\t\t\t\tg[i][j>>6]|=(one<<(j&63));\n\t\t\t\tg[j][i>>6]|=(one<<(i&63));\n\t\t\t}\n\tint nn=((n-1)>>6)+1;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcan_put[i]=true;\n\t\talive[i]=true;\n\t}\n\tfor(int it=0;it<n;it++)\n\t{\n\t\tfor(int i=0;i<nn;i++)\n\t\t\twas[i]=0;\n\t\tfor(int i=0;i<n;i++)\n\t\t\tif(!alive[i])\n\t\t\t\twas[i>>6]|=(one<<(i&63));\n\t\tint best=-1;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tif(was[i >> 6]&(one << (i&63)))\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tint b=0,e=1;\n\t\t\tx[0]=i;\n\t\t\twas[i >> 6]|=(one << (i&63));\n\t\t\twhile(b<e)\n\t\t\t{\n\t\t\t\tfor(int j=0;j<nn;j++)\n\t\t\t\t\tif((g[x[b]][j]&was[j])!=g[x[b]][j])\n\t\t\t\t\t\tfor(int u=j*64;u<(j+1)*64;u++)\n\t\t\t\t\t\t\tif(g[x[b]][u >> 6] & (one << (u&63)))\n\t\t\t\t\t\t\t\tif(!(was[u >> 6] & (one << (u&63))))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\twas[u >> 6]|=(one << (u&63));\n\t\t\t\t\t\t\t\t\tx[e++]=u;\n\t\t\t\t\t\t\t\t}\n\t\t\t\tb++;\n\t\t\t}\n\t\t\tint cur=-1;\n\t\t\tfor(int j=0;j<e;j++)\n\t\t\t{\n\t\t\t\tif(!can_put[x[j]])\n\t\t\t\t\tcontinue;\n\t\t\t\tif(cur==-1||a[cur]>a[x[j]])\n\t\t\t\t\tcur=x[j];\n\t\t\t}\n\t\t\tif(best==-1||(cur!=-1&&a[cur]>a[best]))\n\t\t\t\tbest=cur;\n\t\t}\n\t\talive[best]=false;\n\t\tif(it>0) putchar(' ');\n\t\tprintf(\"%d\",a[best]);\n\t\t\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tif(!alive[i])\n\t\t\t\tcontinue;\n\t\t\tif(g[best][i >> 6] & (one << (i&63)))\n\t\t\t\tcan_put[i]=true;\n\t\t\telse {\n\t\t\t\tif(a[best]<a[i]) \n\t\t\t\t\tcan_put[i]=false;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\nstruct UnionFind{\n  Int n;\n  vector<Int> r,p;\n  UnionFind(Int x,Int y):n(x+y),r(x+y,1),p(x+y,0){\n    iota(p.begin(),p.end(),0);\n    for(Int i=0;i<x;i++) r[i]=1;\n    for(Int i=0;i<y;i++) r[x+i]=0;\n  }\n  Int find(Int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(Int x,Int y){\n    return find(x)==find(y);\n  }\n  void unite(Int x,Int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    if(r[x]<r[y]) swap(x,y);\n    r[x]+=r[y];\n    p[y]=x;\n  }\n};\n\n\ntemplate<typename T> \nmap<T, Int> factorize(T x){\n  map<T, Int> res;\n  for(Int i=2;i*i<=x;i++){\n    while(x%i==0){\n      x/=i;\n      res[i]++;\n    }\n  }\n  if(x!=1) res[x]++;\n  return res;\n}\n\n//INSERT ABOVE HERE\nInt cop[2020][2020];\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<Int> a(n);\n  for(Int i=0;i<n;i++) cin>>a[i];\n  sort(a.begin(),a.end());\n\n  vector<Int> ans(n),used(n,0),post(n,0);\n\n  memset(cop,0,sizeof(cop));\n  \n  for(Int i=0;i<n;i++)\n    for(Int j=0;j<n;j++)\n      cop[i][j]=__gcd(a[i],a[j])>1;\n\n  Int m=0;\n  map<Int, Int> r;\n\n  vector<vector<Int> > G(n);\n  for(Int i=0;i<n;i++){\n    auto x=factorize(a[i]);\n    for(auto p:x){\n      if(!r.count(p.first)) r[p.first]=m++;\n      G[i].emplace_back(r[p.first]);\n    }\n  }\n  \n  for(Int t=0;t<n;t++){\n    UnionFind uf(n,m);\n    for(Int i=0;i<n;i++)\n      if(!used[i]) for(Int j:G[i]) uf.unite(i,n+j);\n    \n    Int idx=-1,sum=t;\n    auto nxt=[&](){\n      set<Int> tmp;\n      for(Int i=0;i<n;i++){\n\tif(used[i]) continue;\n\tInt k=uf.find(i);\n\tif(!tmp.count(k)){\n\t  tmp.emplace(k);\n\t  sum+=uf.r[k];\n\t}\n\tif(post[i]) continue;\n\tif(sum==n){\n\t  idx=i;\n\t  break;\n\t}\n      }\n    };\n    nxt();\n    //assert(sum==n);\n    \n    if(idx<0){\n      sum=0;\n      post.assign(n,0);\n      nxt();\n      while(idx<0);\n    }\n    //while(idx<0);\n    used[idx]=1;\n    ans[t]=idx;\n    \n    for(Int i=0;i<n;i++){\n      if(cop[idx][i]) post[i]=0;\n      else if(a[idx]<a[i]) post[i]=1;\n    }\n  }\n  for(Int i=0;i<n;i++){\n    if(i) cout<<\" \";\n    cout<<a[ans[i]];\n  }\n  cout<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//              +-- -- --++-- +-In the name of ALLAH-+ --++-- -- --+              \\\\\n\n#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define _sz(x) (int)x.size()\n\nusing namespace std ;\nusing ll = long long ;\nusing ld = long double ;\nusing pii = pair <int , int> ;\n\nint const N = 100000 + 20 , M = 100000 + 20 ,  MAX = 1e8 + 20 , S = 1e4 + 20 ;\nint n , a[N] ;\nvector <int> vec ;\n\nvector <int> g[M] ;\nint sz ;\nvector <int> comp[N] ;\n\nvector <int> save[N] ;\n\nint ans[N] , mn[N] , last[M] ;\nbool dead[N] , vis[M] ;\nint mx1 , mx2 , mn_val[N] ;\n\nvector <int> primes ;\nvoid pre () {\n\tbool np[S] ;\n\tmemset(np , 0 , sizeof np) ;\n\tfor (int i = 2 ; i < S ; i ++) {\n\t\tif (np[i]) continue ;\n\t\tprimes.push_back(i) ;\n\t\tfor (int j = 2 * i ; j < S ; j += i) np[j] = 1 ;\n\t}\n}\n\ninline vector<int> get (int x) {\t\t\n\tvector <int> vec ;\n\n\tfor (int j = 0 ; 1ll * primes[j] * primes[j] <= x ; j ++) {\n\t\tif (x % primes[j]) continue ;\n\t\tvec.push_back(primes[j]) ;\n\t\twhile (x % primes[j] == 0) x /= primes[j] ;\n\t}\n\tif (x > 1) vec.push_back(x) ;\n\n\treturn vec ;\n}\n\ninline int get_id (int x) {\n\treturn lower_bound(vec.begin() , vec.end() , x) - vec.begin() ;\n}\n\ninline bool cmp (int x , int y) { return a[x] < a[y] ; }\n\nvoid dfs (int v) {\n\tif (vis[v]) return ;\n\tif (v < n) {\n\t\tif (dead[v]) return ;\n\t\tcomp[sz].push_back(v) ;\n\t}\n\tvis[v] = 1 ;\n\n\tfor (int u : g[v]) dfs(u) ;\n}\n\nint main(){\n\tios::sync_with_stdio(false) , cin.tie(0) , cout.tie(0) ;\n\n\tpre() ;\n\n\tcin >> n ;\n\tfor (int i = 0 ; i < n ; i ++) {\n\t\tcin >> a[i] ;\n\n\t\tsave[i] = get(a[i]) ;\n\t\tfor (int x : save[i]) vec.push_back(x) ;\n\t}\n\n\tsort(vec.begin() , vec.end()) ;\n\tvec.resize( unique(vec.begin() , vec.end()) - vec.begin() ) ;\n\n\tfor (int i = 0 ; i < n ; i ++) {\n\t\tfor (int x : save[i]) {\n\t\t\tint u = i , v = n + get_id(x) ;\n\t\t\tg[u].push_back(v) ;\n\t\t\tg[v].push_back(u) ;\n\t\t}\n\t}\n\n\tmemset(last , -1 , sizeof last) ;\n\tmemset(mn , 63 , sizeof mn) ;\n\n\tfor (int i = 0 ; i < n ; i ++) {\n\t\tmemset(vis , 0 , sizeof vis) ;\n\t\tmx1 = 0 , mx2 = 0 ;\n\t\tsz = 0 ;\n\n\t\tfor (int v = 0 ; v < n ; v ++) {\n\t\t\tif (!dead[v] && !vis[v]) {\n\t\t\t\tcomp[sz].clear() ;\n\t\t\t\tdfs(v) ;\n\n\t\t\t\tsort(comp[sz].begin() , comp[sz].end() , cmp) ;\n\t\t\n\t\t\t\tmx2 = max(mx2 , a[comp[sz][0]]) ;\n\t\t\t\tif (mx2 > mx1) swap(mx1 , mx2) ;\n\n\t\t\t\tfor (int u : comp[sz]) mn_val[u] = a[comp[sz][0]] ;\n\t\t\t\t\n\t\t\t\tsz ++ ;\n\t\t\t}\n\t\t}\n\n\t\tint res = -1 ;\n\t\tfor (int j = 0 ; j < n ; j ++) {\n\t\t\tif (dead[j]) continue ;\n\n\t\t\tint val = (mn_val[j] == mx1 ? mx2 : mx1) ;\n\t\t\tif (val > a[j]) continue ;\n\n\t\t\tint pp = -1 ;\n\t\t\tfor (int x : save[j]) pp = max(pp , last[x]) ;\n\n\t\t\tif (mn[pp + 1] < a[j]) continue ;\n\n\t\t\tif (res == -1 || a[res] > a[j]) res = j ;\n\t\t}\n\n\t\tdead[res] = 1 ;\n\t\tans[i] = a[res] ;\n\t\tfor (int j = i ; j >= 0 ; j --) mn[j] = min(mn[j] , a[res]) ;\n\t\tfor (int x : save[res]) last[x] = i ;\n\t}\n\n\tfor (int i = 0 ; i < n ; i ++) cout << ans[i] << ' ' ; cout << '\\n' ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nconst int MaxN = 2000;\n\ninline int gcd(int a, int b)\n{\n\twhile (b > 0)\n\t{\n\t\ta %= b;\n\t\tswap(a, b);\n\t}\n\treturn a;\n}\n\nint n;\nint a[MaxN + 1];\n\nbool mat[MaxN + 1][MaxN + 1];\n\nbool vis[MaxN + 1];\n\nint deg[MaxN + 1];\nvector<int> adj[MaxN + 1];\n\nvoid dfs_build(const int &u)\n{\n\tvis[u] = true;\n\n\tfor (int v = 1; v <= n; ++v)\n\t\tif (mat[u][v] && !vis[v])\n\t\t{\n\t\t\tadj[u].push_back(v), ++deg[v];\n\t\t\tdfs_build(v);\n\t\t}\n}\n\nstruct comparator\n{\n\tinline bool operator()(const int &u, const int &v)\n\t{\n\t\tif (a[u] != a[v])\n\t\t\treturn a[u] < a[v];\n\t\treturn u < v;\n\t}\n};\n\npriority_queue<int, vector<int>, comparator> q;\n\nint main()\n{\n\tcin >> n;\n\tfor (int i = 1; i <= n; ++i)\n\t\tcin >> a[i];\n\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = i + 1; j <= n; ++j)\n\t\t\tif (gcd(a[i], a[j]) > 1)\n\t\t\t\tmat[i][j] = mat[j][i] = true;\n\n\tfor (int u = 1; u <= n; ++u)\n\t\tif (!vis[u])\n\t\t\tdfs_build(u);\n\n\tfor (int u = 1; u <= n; ++u)\n\t\tif (!deg[u])\n\t\t\tq.push(u);\n\n\twhile (!q.empty())\n\t{\n\t\tint u = q.top();\n\t\tq.pop();\n\n\t\tcout << a[u] << ' ';\n\n\t\tfor (int v : adj[u])\n\t\t\tif (!--deg[v])\n\t\t\t\tq.push(v);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <bitset>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <algorithm>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\n#define TRACE(x) cerr << #x << \" = \" << x << endl\n#define REP(i, n) for (int i=0; i<n; i++)\n#define FOR(i, a, b) for (int i=(a); i<(b); i++)\n#define _ << \" \" <<\n\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\n#define X first\n#define Y second\n\nconst int MAX = 2005, MAXL = 2005 / 64 + 2;\n\nbitset <MAX> ne_rel[MAX];\null ne_rel_ull[MAX][MAXL];\nbitset <MAX> manji[MAX];\nbitset <MAX> smije;\nbitset <MAX> ostalo;\nint n;\nint p[MAX];\nint rje[MAX];\nint done[MAX];\nint indk[MAX], brk;\n\nvoid bfs()\n{\n  ull nodovi[MAXL];\n  REP(i, n)\n    if (!done[i])\n      nodovi[i/64] |= ((ull) 1) << (i % 64);\n\n  queue <int> Q;\n\n  brk = 0;\n  REP(i, n) {\n    if (nodovi[i/64] & ((ull) 1) << (i % 64)) {\n      nodovi[i/64] ^= ((ull) 1) << (i % 64);\n      Q.push(i);\n      \n      for (; !Q.empty();) {\n\tint tmp = Q.front(); Q.pop();\n\tindk[tmp] = brk;\n\n\tREP(j, MAXL) {\n\t  ull val = nodovi[j] & ne_rel_ull[tmp][j];\n\t  for (; val; ) {\n\t    ull koji = val & (-val);\n\t    int ind = __builtin_ctzll(koji);\n\t    \n\t    nodovi[j] ^= ((ull) 1) << ind;\n\t    val ^= ((ull) 1) << ind;\n\t    Q.push(64 * j + ind);\n\t  }\n\t}\n      }\n      \n      brk++;\n    }\n  }  \n}\n\nint main()\n{\n  scanf(\"%d\", &n);\n  REP(i, n) scanf(\"%d\", &p[i]);\n\n  sort(p, p + n);\n\n  REP(i, n)\n    REP(j, n)\n    if (__gcd(p[i], p[j]) > 1) {\n      ne_rel_ull[i][j/64] |= ((ull) 1) << (j % 64);    \n      ne_rel[i][j] = 1;\n    }\n\n  REP(i, n) smije[i] = 1;\n  REP(i, n) ostalo[i] = 1;\n\n  REP(i, n) {\n    bfs();\n\n    int ima[MAX];\n    memset(ima, 0, sizeof ima);\n    int poklopio = 0;\n\n    int ind = -1;\n    REP(j, n) {\n      if (done[j]) continue;\n      if (smije[j]) {\n\tif (!ima[indk[j]]) {\n\t  ima[indk[j]] = 1;\n\t  poklopio++;\n\t}\n\n\tif (poklopio == brk) {\n\t  ind = j;\n\t  break;\n\t}\n      }\n    }\n\n    assert(ind != -1);\n\n    done[ind] = 1;\n    smije[ind] = 0;\n    rje[i] = ind;\n\n    REP(k, n) {\n      if (ne_rel[ind][k])\n\tsmije[k] = 1;\n      else if (smije[k] && k < ind)\n\tsmije[k] = 1;\n      else\n\tsmije[k] = 0;\n    }      \n  }    \n\n  REP(i, n)\n    printf(\"%d \", p[rje[i]]);\n  printf(\"\\n\");\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef complex<double> point;\n#define xx real()\n#define yy imag()\n\n#define REP(i, a, b) for(int i = (a); i < (int)(b); i++)\n#define REPN(i, a, b) for(int i = (a); i <= (int)(b); i++)\n#define FA(it, x) for(__typeof((x).begin()) it = (x).begin(); it != (x).end(); it++)\n#define SZ(x) (int)(x).size()\n#define BE(x) (x).begin(), (x).end()\n#define SORT(x) sort(BE(x))\n#define _1 first\n#define _2 second\n\n#define x1 gray_cat_x1\n#define y1 gray_cat_y1\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\n#define file \"I1\"\n\nconst double EPS = 1e-9;\nconst double PI = acos(-1.);\nconst int INF = 1e9;\nconst ll MOD = 1e9 + 7;\n\nconst int MAXN = 2e3 + 5;\n\nint n;\nint g[MAXN][MAXN];\nint ans[MAXN][MAXN], top_ans[MAXN];\nint used[MAXN];\nint v[MAXN];\n\nint tmp[MAXN], tmp_top;\n\nvoid dfs(int s){\n\tused[s] = 1;\n\tans[s][top_ans[s]++] = s;\n\tREPN(i, 1, n){\n\t\tif (g[s][i] && !used[i]){\n\t\t\tdfs(i);\n\t\t\tREPN(j, 1, top_ans[s]){\n\t\t\t\ttmp[j] = ans[s][j];\n\t\t\t}\n\t\t\ttmp_top = top_ans[s];\n\t\t\ttop_ans[s] = 1;\n\t\t\tfor(int i1 = 0, i2 = 1; i1 < top_ans[i] || i2 < tmp_top; ){\n\t\t\t\tif (i1 == top_ans[i] || i2 < tmp_top && tmp[i2] > ans[i][i1]){\n\t\t\t\t\tans[s][top_ans[s]++] = tmp[i2++];\n\t\t\t\t} else {\n\t\t\t\t\tans[s][top_ans[s]++] = ans[i][i1++];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid solve(){\n\tscanf(\"%d\", &n);\n\tREPN(i, 1, n){\n\t\tscanf(\"%d\", &v[i]);\n\t}\n\tsort(v + 1, v + n + 1);\n\tREPN(i, 1, n){\n\t\tg[0][i] = 1;\n\t\tREPN(j, i + 1, n){\n\t\t\tif (gcd(v[i], v[j]) > 1){\n\t\t\t\tg[i][j] = g[j][i] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tdfs(0);\n\tREPN(i, 1, n){\n\t\tprintf(\"%d \", v[ans[0][i]]);\n\t}\n\tputchar('\\n');\n}   \n\nint main(){\n\n    //freopen(file\".in\", \"r\", stdin); freopen(file\".out\", \"w\", stdout);\n    int t = 1;\n    //cin >> t;\n    while(t--){\n        solve();    \n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int MAXN = 2010;\nstd::priority_queue<int> q;\nstd::vector<int> to[MAXN], gr[MAXN];\nint gcd(int a, int b) { return b ? gcd(b, a % b) : a; }\nint n, A[MAXN], ind[MAXN], tim[MAXN], idx;\nbool vis[MAXN];\nint main() {\n\tstd::ios_base::sync_with_stdio(false), std::cin.tie(0);\n\tstd::cin >> n;\n\tfor (int i = 1; i <= n; ++i) std::cin >> A[i];\n\tstd::sort(A + 1, A + 1 + n);\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = i + 1; j <= n; ++j)\n\t\t\tif (gcd(A[i], A[j]) > 1) {\n\t\t\t\tgr[i].push_back(j);\n\t\t\t\tgr[j].push_back(i);\n\t\t\t}\n\tfor (int i = 1; i <= n; ++i) if (!vis[i]) {\n\t\tq.push(-i); vis[i] = true;\n\t\twhile (!q.empty()) {\n\t\t\tint t = -q.top(); q.pop(); tim[t] = ++idx;\n\t\t\tfor (auto t : gr[t]) if (!vis[t])\n\t\t\t\tq.push(-t), vis[t] = true;\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (auto t : gr[i])\n\t\t\tif (tim[i] < tim[t])\n\t\t\t\t++ind[t], to[i].push_back(t);\n\tfor (int i = 1; i <= n; ++i) if (!ind[i]) q.push(i);\n\tfor (int i = 1, t; i <= n; ++i) {\n\t\tstd::cout << (A[t = q.top()]) << (\" \\n\" [i == n]); q.pop();\n\t\tfor (int j : to[t]) if (!--ind[j]) q.push(j);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n\n#define null                \"\"\n#define all(dat)            dat.begin(), dat.end()\n#define over(msg)           puts(msg), exit(0);\n#define loop(i, to)         for (int i = 0; i < to; ++i)\n#define cont(i, to)         for (int i = 1; i <= to; ++i)\n#define foreach(i, dat)     for (__typeof(dat.begin()) i = dat.begin(); i != dat.end(); ++i)\n\ntypedef long long           num;\n\nusing namespace std;\n\nbool vis[2005];\n\nint n, sz, dat[2005];\n\nvector<int> g[2005], b[2005];\n\nset<int, greater<int>> s;\n\nint gcd(int a, int b) {\n\t\n\treturn b == 0 ? a : gcd(b, a % b);\n\t\n}\n\nvoid dfs(int u) {\n\t\n\tvis[u] = 1;\n\t\n\tloop (i, g[u].size()) {\n\t\t\n\t\tint v = g[u][i];\n\t\t\n\t\tif (vis[v])  continue;\n\t\t\n\t\tb[u].push_back(v);\n\t\t\n\t\tdfs(v);\n\t\t\n\t}\n\t\n}\n\nbool cmp(vector<int> a, vector<int> b) {\n\t\n\treturn a[0] > b[0];\n\t\n}\n\nint main() {\n\t\n\tios_base::sync_with_stdio(0);\n\t\n\tcin >> n;\n\t\n\tcont (i, n) {\n\t\t\n\t\tcin >> dat[i];\n\t\t\n\t}\n\t\n\tsort(dat, dat + n);\n\t\n\tcont (i, n) {\n\t\t\n\t\tcont (j, n) {\n\t\t\t\n\t\t\tif (i == j)  continue;\n\t\t\t\n\t\t\tint tmp = gcd(dat[i], dat[j]);\n\t\t\t\n\t\t\tif (tmp > 1) {\n\t\t\t\t\n\t\t\t\tg[i].push_back(j);\n\t\t\t\t\n\t\t\t\tg[j].push_back(i);\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t}\n\t\n\tcont (i, n) {\n\t\t\n\t\tif (vis[i])  continue;\n\t\t\n\t\tdfs(i);\n\t\t\n\t\ts.insert(i);\n\t\t\n\t}\n\t\n\twhile (!s.empty()) {\n\t\t\n\t\tint cur = *s.begin();\n\t\t\n\t\ts.erase(s.begin());\n\t\t\n\t\tloop (i, b[cur].size()) {\n\t\t\t\n\t\t\ts.insert(b[cur][i]);\n\t\t\t\n\t\t}\n\t\t\n\t\tcout << dat[cur] << ' ';\n\t\t\n\t}\n\t\n\tcout << endl;\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n#define N 2010\n#define chmax(a,b) a=max(a,b);\nvector<ll> g[N];\nll a[N],n;\nvector<ll> t[N];\nll nz[N];\nll gcd(ll a,ll b){\n    if(a<b)swap(a,b);\n    if(b==0)return a;\n    a%=b;\n    return gcd(a,b);\n}\n\nvoid Solve(){\n for(int i=0;i<n;i++)nz[i]=0;\n for(int i=0;i<n;i++){\n  for(auto x:t[i])nz[x]++;   \n }\n priority_queue<ll> Q;\n vector<ll> ans;\n for(int i=0;i<n;i++){\n     if(nz[i]==0)Q.push(i);\n }\n while(!Q.empty()){\n  ll x=Q.top();\n  Q.pop();\n  ans.push_back(a[x]);\n  for(auto y:t[x]){\n   nz[y]--;\n   if(nz[y]==0)Q.push(y);\n  }\n }\n for(int i=0;i<n;i++){\n  if(i)cout<<\" \";\n  cout<<ans[i];\n }cout<<endl;\n}\n\nbool vis[N];\nll maxfrom[N];\npriority_queue<ll>Q;\nvoid bfs(ll x){\n    if(vis[x])return; vis[x]=1;\n    //cout<<x<<\" \"<<maxfrom[x]<<endl;\n    if(~maxfrom[x])t[maxfrom[x]].push_back(x);\n    for(auto y:g[x]){\n        chmax(maxfrom[y],x);\n        Q.push(y);\n    }\n}\nvoid MakeT(ll s){\n while(!Q.empty())Q.pop();\n Q.push(s);\n while(!Q.empty()){\n  ll x=Q.top();\n  Q.pop();\n  bfs(x);\n }\n}\nint main(){\n cin>>n;\n for(int i=0;i<n;i++)cin>>a[i];\n sort(a,a+n);\n for(int i=0;i<n;i++)nz[i]=0;\n for(int i=0;i<n;i++){\n  for(int j=0;j<i;j++){\n   if(gcd(a[i],a[j])>1){\n       g[i].push_back(j);\n       g[j].push_back(i);\n   }\n  }\n }\n for(int i=0;i<n;i++)vis[i]=0,maxfrom[i]=-1;\n for(int i=0;i<n;i++){\n  if(vis[i])continue;\n  MakeT(i);\n }\n Solve();\n return 0;   \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <stack>\n#include <map>\n#include <set>\n#include <deque>\n#include <cstring>\n#include <functional>\n#include <climits>\n#include <list>\n#include <ctime>\n#include <complex>\n\n#define F1(x,y,z) for(int x=(y);x<(z);x++)\n#define F2(x,y,z) for(int x=(y);x<=(z);x++)\n#define F3(x,y,z) for(int x=(y);x>(z);x--)\n#define F4(x,y,z) for(int x=(y);x>=(z);x--)\n#define mp make_pair\n#define pb push_back\n#define LL long long\n#define co complex<double>\n#define fi first\n#define se second\n\n#define MAX 100005\n#define AMAX 1025*1005\n#define MOD 1000000007\n\n#define f(c,d) ((1<<(c))*(d))\n\nusing namespace std;\n\nint n,ta,x[2005],i,at[MAX];\nvector<int> np[2005],p,em;\nvector<vector<int> > ans;\nmap<int,int> m;\nmap<int,int>::iterator it;\nbool o,v[2005],vm[MAX],d[MAX];\npair<int,int> mi[MAX];\nvector<pair<int,int> > vn[MAX]; \npriority_queue<pair<int,int> > q;\npriority_queue<pair<int,int> > qq;\n\nvoid up(int a);\n\nvoid pp(int a){\n\tv[a]=1;\n\tq.push(mp(x[a],a));\n}\n\nvoid up(int a){\n\tif(at[a]!=vn[a].size()){\n\t\tif(!v[vn[a][at[a]].se]){\n\t\t\tpp(vn[a][at[a]].se);\n\t\t\tat[a]++;\n\t\t}\n\t}\n}\n\nvoid upp(int a){\n\tif(at[a]!=ans[a].size()){\n\t\tqq.push(mp(ans[a][at[a]],a));\n\t\tat[a]++;\n\t}\n}\n\nint main(){\n\tF1(a,0,MAX)mi[a]=mp(INT_MAX,a);\n\tF2(a,2,10000){\n\t\to=1;\n\t\tF1(b,0,p.size()){\n\t\t\tif(p[b]*p[b]>a)break;\n\t\t\tif(a%p[b]==0){\n\t\t\t\to=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(o)p.pb(a);\n\t}\n\tscanf(\"%d\",&n);\n\tF1(a,0,n){\n\t\tscanf(\"%d\",x+a);\n\t\tta=x[a];\n\t\tF1(b,0,p.size()){\n\t\t\tif(p[b]*p[b]>ta)break;\n\t\t\tif(ta%p[b]==0){\n\t\t\t\ti=m.insert(mp(p[b],m.size())).fi->se;\n\t\t\t\tnp[a].pb(i);\n\t\t\t\tmi[i].fi=min(mi[i].fi,x[a]);\n\t\t\t\tvn[i].pb(mp(x[a],a));\n\t\t\t\twhile(ta%p[b]==0)ta/=p[b];\n\t\t\t}\n\t\t}\n\t\tif(ta!=1){\n\t\t\ti=m.insert(mp(ta,m.size())).fi->se;\n\t\t\tnp[a].pb(i);\n\t\t\tmi[i].fi=min(mi[i].fi,x[a]);\n\t\t\tvn[i].pb(mp(x[a],a));\n\t\t}\n\t}\n\tsort(mi,mi+m.size());\n\tF1(a,0,m.size()){\n\t\ti=mi[a].se;\n\t\tif(!vm[i]){\n\t\t\tvm[i]=1;\n\t\t\tans.pb(em);\n\t\t\tsort(vn[i].begin(),vn[i].end());\n\t\t\tup(i);\n\t\t\twhile(!q.empty()){\n\t\t\t\tans.back().pb(q.top().fi);\n\t\t\t\tta=q.top().se;\n\t\t\t\tq.pop();\n\t\t\t\tF1(b,0,np[ta].size()){\n\t\t\t\t\tif(!vm[np[ta][b]])vm[np[ta][b]]=1;\n\t\t\t\t\tup(np[ta][b]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//F1(a,0,ans.size())F1(b,0,ans[a].size())printf(\"%d%c\",ans[a][b],b==ans[a].size()-1?'\\n':' ');\n\tF1(a,0,ans.size())at[a]=0;\n\tF1(a,0,ans.size())upp(a);\n\twhile(!qq.empty()){\n\t\tprintf(\"%d \",qq.top().fi);\n\t\tint ttt=qq.top().se;\n\t\tqq.pop();\n\t\tupp(ttt);\n\t}\n\tF1(a,0,n)if(x[a]==1)printf(\"1 \");\n\t#ifdef LOCAL_PROJECT\n\tsystem(\"pause\");\n\t#endif\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\nconst int N=100010,M=4000010,P=1e9+7;\nconst int inf=0x3f3f3f3f;\nconst int INF=0xcfcfcfcf;\nconst double eps=1e-9,pi=asin(1)*2;\ninline ll read();\n#define cmax(a,b) a=max(a,b)\n#define cmin(a,b) a=min(a,b)\ninline int ADD(int a,int b) { return a+b>=P?a+b-P:a+b; }\ninline int MINUS(int a,int b) { return a-b<0?a-b+P:a-b; }\n#define plus(a,b) a=ADD(a,b)\n#define minus(a,b) a=MINUS(a,b)\n#define mul(a,b) a=(1ll*a*(b))%P\n#define mem(a,b) memset(a,b,sizeof(a))\n#define pii pair<int,int>\n#define pil pair<int,ll>\n#define pli pair<ll,int>\n#define pll pair<ll,ll>\n#define mp(x,y) make_pair(x,y)\n\ninline int gcd(int x,int y) { return y?gcd(y,x%y):x; }\nint head[N],ver[M],nxt[M],du[N];\nint n,m,tot=1;\nint a[N];\ninline void add(int x,int y)\n{\n\tver[++tot]=y,nxt[tot]=head[x],head[x]=tot,du[y]++;\n}\n\nbool G[2010][2010];\nbool visit[N];\ninline void dfs(int x)\n{\n\tvisit[x]=true;\n\tfor(int y=1;y<=n;y++)\n\t{\n\t\tif(visit[y]||!G[x][y]) continue;\n\t\tadd(x,y);\n\t\tdfs(y);\n\t}\n}\npriority_queue<int> q;\n\n#ifdef FILE\nconst int READ_SIZE=1<<20;\nchar buf[READ_SIZE],*p1=buf,*p2=buf;\n#define getchar() p1==p2&&(p2=(p1=buf)+fread(buf,1,READ_SIZE,stdin),p1==p2)?EOF:*p1++\n#endif\ninline ll read()\n{\n\tll s=0;\n\tbool flag=false;\n\tchar ch=getchar();\n\tfor(;ch<'0'||ch>'9';ch=getchar()) if(ch=='-') flag=true;\n\tfor(;'0'<=ch&&ch<='9';ch=getchar()) s=(s<<3)+(s<<1)+(ch^'0');\n\tif(flag) return -s;\n\treturn s;\n}\n\nint main()\n{\n#ifdef FILE\n\tfreopen(FILE \".in\",\"r\",stdin);\n\tfreopen(FILE \".out\",\"w\",stdout);\n#endif\n\tn=read();\n\tfor(int i=1;i<=n;i++) a[i]=read();\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(a[i]<a[j]&&gcd(a[i],a[j])>1)\n\t\t\t\tG[i][j]=G[j][i]=true;\n\tfor(int i=1;i<=n;i++)\n\t\tif(!visit[i]) dfs(i);\n\t\n\twhile(q.size()) q.pop();\n\tfor(int i=1;i<=n;i++)\n\t\tif(!du[i]) q.push(i);\n\t\n\twhile(q.size())\n\t{\n\t\tint x=q.top();q.pop();\n\t\tprintf(\"%d \",a[x]);\n\t\tfor(int i=head[x];i;i=nxt[i])\n\t\t{\n\t\t\tint y=ver[i];\n\t\t\tdu[y]--;\n\t\t\tif(!du[y]) q.push(y);\n\t\t}\n\t}\n\tputchar('\\n');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Copyright (C) 2017 __debug.\n\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License as\n// published by the Free Software Foundation; version 3\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program; If not, see <http://www.gnu.org/licenses/>.\n\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/priority_queue.hpp>\n\n#define x first\n#define y second\n#define MP std::make_pair\n#define SZ(x) ((int)(x).size())\n#define ALL(x) (x).begin(), (x).end()\n#define DEBUG(...) fprintf(stderr, __VA_ARGS__)\n#ifdef __linux__\n#define getchar getchar_unlocked\n#define putchar putchar_unlocked\n#endif\n\nusing std::pair;\nusing std::vector;\nusing std::string;\n\ntypedef long long LL;\ntypedef pair<int, int> Pii;\n\nconst int oo = 0x3f3f3f3f;\n\ntemplate<typename T> inline bool chkmax(T &a, T b) { return a < b ? a = b, true : false; }\ntemplate<typename T> inline bool chkmin(T &a, T b) { return b < a ? a = b, true : false; }\nstring procStatus()\n{\n    std::ifstream t(\"/proc/self/status\");\n    return string(std::istreambuf_iterator<char>(t), std::istreambuf_iterator<char>());\n}\ntemplate<typename T> T read(T &x)\n{\n    int f = 1;\n    char ch = getchar();\n    for (; !isdigit(ch); ch = getchar())\n        f = (ch == '-' ? -1 : 1);\n    for (x = 0; isdigit(ch); ch = getchar())\n        x = 10 * x + ch - '0';\n    return x *= f;\n}\ntemplate<typename T> void write(T x)\n{\n    if (x == 0) {\n        putchar('0');\n        return;\n    }\n    if (x < 0) {\n        putchar('-');\n        x = -x;\n    }\n    static char s[20];\n    int top = 0;\n    for (; x; x /= 10)\n        s[++top] = x % 10 + '0';\n    while (top)\n        putchar(s[top--]);\n}\n// EOT\n\nconst int MAXN = 2e3 + 5;\n\nint N;\nint A[MAXN];\n\nvoid input()\n{\n    read(N);\n    for (int i = 1; i <= N; ++i) {\n        read(A[i]);\n    }\n}\n\nbool vis[MAXN];\n\ninline void merge(vector<int> &a, const vector<int> &b)\n{\n    vector<int> ret;\n    int p = 0, q = 0;\n    while (p < SZ(a) || q < SZ(b)) {\n        if (p < SZ(a) && (q == SZ(b) || a[p] > b[q]))\n            ret.push_back(a[p++]);\n        else\n            ret.push_back(b[q++]);\n    }\n    a = ret;\n}\n\nvector<int> dfs(int u)\n{\n    vis[u] = true;\n    vector<int> ret;\n    for (int v = 1; v <= N; ++v) {\n        if (vis[v] || std::__gcd(A[u], A[v]) == 1)\n            continue;\n        merge(ret, dfs(v));\n    }\n    ret.insert(ret.begin(), A[u]);\n    return ret;\n}\n\nvoid solve()\n{\n    vector<int> ans;\n\n    std::sort(A + 1, A + N + 1);\n    for (int i = 1; i <= N; ++i) {\n        if (!vis[i])\n            merge(ans, dfs(i));\n    }\n\n    for (auto x : ans) {\n        printf(\"%d \", x);\n    }\n    puts(\"\");\n}\n\nint main()\n{\n#ifdef __DEBUG\n    freopen(\"E.in\", \"r\", stdin);\n    freopen(\"E.out\", \"w\", stdout);\n#endif\n\n    input();\n    solve();\n\n    return 0;\n}\n\n// 三万里河东入海，五千仞岳上摩天。\n//     -- 陆游《秋夜将晓出篱门迎凉有感》\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <functional>\n#define repeat(i,n) for (int i = 0; (i) < int(n); ++(i))\n#define whole(f,x,...) ([&](decltype((x)) whole) { return (f)(begin(whole), end(whole), ## __VA_ARGS__); })(x)\nusing ll = long long;\nusing namespace std;\ntemplate <class T> using reversed_priority_queue = priority_queue<T, vector<T>, greater<T> >;\nint gcd(int a, int b) { while (a) { b %= a; swap(a, b); } return b; }\nbool is_swappable(int a, int b) { return gcd(a, b) == 1; }\nint main() {\n    // input\n    int n; cin >> n;\n    vector<int> a(n); repeat (i,n) cin >> a[i];\n    // rearrange\n    whole(sort, a);\n    vector<int> b;\n    vector<bool> used(n);\n    function<void (int)> go = [&](int i) {\n        used[i] = true;\n        b.push_back(a[i]);\n        repeat (j,n) if (not used[j] and not is_swappable(a[i], a[j])) {\n            go(j);\n        }\n    };\n    repeat (i,n) if (not used[i]) {\n        go(i);\n    }\n    // insertion sort\n    repeat (i,n) {\n        int j = i;\n        for (int k = i-1; k >= 0 and is_swappable(b[k], b[i]); -- k) {\n            if (b[k] < b[i]) j = k;\n        }\n        rotate(b.begin() + j, b.begin() + i, b.begin() + i + 1);\n    }\n    // output\n    for (auto it : b) cout << it << ' '; cout << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\ninline int read(){\n\tint f=1,ans=0;char c=getchar();\n\twhile(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}\n\twhile(c>='0'&&c<='9'){ans=ans*10+c-'0';c=getchar();}\n\treturn ans*f;\n}\nconst int MAXN=2001;\nvector<int> vec[MAXN];\npriority_queue<int> que;\nint N,A[MAXN],M[MAXN][MAXN],vis[MAXN],d[MAXN];\nvoid dfs(int u){\n\tvis[u]=1;\n\tfor(int i=1;i<=N;i++){\n\t\tif(!vis[i]&&M[u][i]){\n\t\t\tvec[u].push_back(i);\n\t\t\tvis[i]=1,d[i]++;dfs(i);\n\t\t}\n\t}return;\n}\nint main(){\n\tN=read();for(int i=1;i<=N;i++) A[i]=read();sort(A+1,A+N+1);\n\tfor(int i=1;i<=N;i++) for(int j=2;j<=N;j++) if(__gcd(A[i],A[j])!=1) M[i][j]=M[j][i]=1;\n\tfor(int i=1;i<=N;i++) if(!vis[i]) dfs(i);\n\tfor(int i=1;i<=N;i++) if(!d[i]) que.push(i);\n\twhile(!que.empty()){\n\t\tint xx=que.top();que.pop();printf(\"%d \",A[xx]);\n\t\tfor(int i=0;i<vec[xx].size();i++){\n\t\t\tint v=vec[xx][i];\n\t\t\td[v]--;if(!d[v]) que.push(v);\n\t\t}\n\t}printf(\"\\n\");return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define FOR(i,a,b) for(int i=int(a);i<int(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define MP make_pair\n#define PB push_back\n#define ALL(x) x.begin(),x.end()\n#define REACH cerr<<\"reached line \"<<__LINE__<<endl\n#define DBG(x) cerr<<\"line \"<<__LINE__<<\" \"<<#x<<\":\"<<x<<endl\n\nusing pi=pair<int,int>;\nusing vi=vector<int>;\nusing ld=long double;\n\ntemplate<class T,class U>\nostream& operator<<(ostream& os,const pair<T,U>& p){\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator <<(ostream& os,const vector<T>& v){\n\tos<<\"[\";\n\tREP(i,(int)v.size()){\n\t\tif(i)os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"]\";\n\treturn os;\n}\n\nint read(){\n\tint i;\n\tscanf(\"%lld\",&i);\n\treturn i;\n}\n\nvoid printSpace(){\n\tprintf(\" \");\n}\n\nvoid printEoln(){\n\tprintf(\"\\n\");\n}\n\nvoid print(int x,int suc=1){\n\tprintf(\"%lld\",x);\n\tif(suc==1)\n\t\tprintEoln();\n\tif(suc==2)\n\t\tprintSpace();\n}\n\nstring readString(){\n\tstatic char buf[3341919];\n\tscanf(\"%s\",buf);\n\treturn string(buf);\n}\n\nchar* readCharArray(){\n\tstatic char buf[3341919];\n\tstatic int bufUsed=0;\n\tchar* ret=buf+bufUsed;\n\tscanf(\"%s\",ret);\n\tbufUsed+=strlen(ret)+1;\n\treturn ret;\n}\n\ntemplate<class T,class U>\nvoid chmax(T& a,U b){\n\tif(a<b)\n\t\ta=b;\n}\n\ntemplate<class T,class U>\nvoid chmin(T& a,U b){\n\tif(a>b)\n\t\ta=b;\n}\n\ntemplate<class T>\nT Sq(const T& t){\n\treturn t*t;\n}\n\nconst int inf=LLONG_MAX/3;\nconst int Nmax=2017;\n\nint gcd(int a,int b){\n\treturn b?gcd(b,a%b):a;\n}\n\nvi Wafrelka(vi a,vi b){\n\tint n=a.size(),m=b.size();\n\tvi res;\n\tint i=0,j=0;\n\tREP(_,n+m){\n\t\tbool l=true;\n\t\tif(i==n||(j<m&&a[i]<b[j]))l=false;\n\t\tif(l)res.PB(a[i++]);\n\t\telse res.PB(b[j++]);\n\t}\n\treturn res;\n}\n\nsigned main(){\n\tint n=read();\n\tvi a;\n\tREP(i,n)a.PB(read());\n\tsort(ALL(a));\n\tvi ans,used(n,0);\n\tfunction<vi(int i)>Yutaka;\n\tYutaka=[&](int i){\n\t\tvi res;\n\t\tused[i]=true;\n\t\tREP(j,n)if(!used[j])\n\t\t\tif(gcd(a[i],a[j])>1)\n\t\t\t\tres=Wafrelka(res,Yutaka(j));\n\t\tres.insert(res.begin(),a[i]);\n\t\treturn res;\n\t};\n\tREP(i,n)if(!used[i])\n\t\tans=Wafrelka(ans,Yutaka(i));\n\tREP(i,n)\n\t\tprint(ans[i],i==n-1?1:2);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define Inf 0x3f3f3f3f\n#define rg register\nusing namespace std;\ntypedef long long ll;\ninline ll min(ll x, ll y) { return x < y ? x : y; }\ninline ll max(ll x, ll y) { return x > y ? x : y; }\nconst int Maxn = 2e3 + 5;\ninline ll read()\n{\n\trg ll res = 0, sign = 1;\n\trg char ch = getchar();\n\twhile (!isdigit(ch))\n\t{\n\t\tif (ch == '-')\n\t\t\tsign = -1;\n\t\tch = getchar();\n\t}\n\tdo\n\t{\n\t\tres = (res << 3) + (res << 1) + (ch ^ 48);\n\t\tch = getchar();\n\t}while(isdigit(ch));\n\treturn res * sign;\n}\nint n,cnt;\nbool E[Maxn][Maxn],vis[Maxn];\nint fir[Maxn],a[Maxn],ind[Maxn];\nstruct {\n\tint to,last;\n}e[Maxn*Maxn];\nvoid con(int u,int v)\n{\n\te[++cnt].to=v;\n\te[cnt].last=fir[u];\n\tfir[u]=cnt;\n\tind[v]++;\n}\nint gcd(rg int x,rg int y)\n{\n\trg int z=x%y;\n\twhile(z)\n\t{\n\t\tx=y;\n\t\ty=z;\n\t\tz=x%y;\n\t}\n\treturn y;\n}\nvoid DFS(int x)\n{\n\tvis[x]=true;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(!E[x][i]||vis[i])\n\t\t\tcontinue;\n\t\tcon(x,i);\n\t\tDFS(i);\n\t}\n}\npriority_queue<int>q;\nint main()\n{\n\tcin>>n;\n\tfor(int i=1;i<=n;i++)\n\t\ta[i]=read();\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\tif(gcd(a[i],a[j])!=1)\n\t\t\t\tE[i][j]=E[j][i]=true;\n\tfor(int i=1;i<=n;i++)\n\t\tif(!vis[i])\n\t\t{\n\t\t\tDFS(i);\n\t\t\tq.push(i);\n\t\t}\t\n\trg int x;\n\twhile(!q.empty())\n\t{\n\t\tx=q.top();\n\t\tq.pop();\n\t\tfor(int next=fir[x],nx;next;next=e[next].last)\n\t\t{\n\t\t\tnx=e[next].to;\n\t\t\tind[nx]--;\n\t\t\tif(!ind[nx])\n\t\t\t\tq.push({nx});\n\t\t}\n\t\tprintf(\"%d \",a[x]);\n\t}\n\tputs(\"\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//dfs树的灵活运用\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#define N 2010\n#define inf 2147483647\nusing namespace std;\n\nstruct edge{int x, y, next;}a[4010010];\nint n, w[N], l, p[N], flag[N], fa[N], S, mnp, b[N], du[N], ans[N];\nvector<int>son[N], son1[N];\n\ninline int gcd(int a, int b){return b?gcd(b, a%b):a;}\ninline void add(int x, int y){a[++l].x=x; a[l].y=y; a[l].next=p[x]; p[x]=l;}\n\ninline void dfs(int x){\n\tflag[x]=1; son1[x].clear();\n\tfor(int i=p[x]; i; i=a[i].next)if(!flag[a[i].y])son1[x].push_back(a[i].y);\n\tint mnp; w[0]=inf;\n\twhile(1){\n\t\tmnp=0;\n\t\tfor(int i=0; i<son1[x].size(); i++)if(!flag[son1[x][i]]&&w[mnp]>w[son1[x][i]])mnp=son1[x][i];\n\t\tif(!mnp)break;\n\t\tfa[mnp]=x; dfs(mnp);\n\t}\n}\n\ninline void solve(){\n\tl=0; memset(p, 0, sizeof(p)); memset(du, 0, sizeof(du));\n\tfor(int i=1; i<=n; i++)\n\t\tfor(int j=i+1; j<=n; j++)if(gcd(b[i], b[j])!=1){add(i, j); du[j]++;}\n\tmemset(flag, 0, sizeof(flag));\n\tfor(int i=1; i<=n; i++)if(!du[i])flag[i]=1;\n\tint mnp; b[0]=-inf;\n\tfor(int i=1; i<=n; i++){\n\t\tmnp=0;\n\t\tfor(int j=1; j<=n; j++)if(flag[j]&&b[mnp]<b[j])mnp=j;\n\t\tans[i]=b[mnp]; flag[mnp]=0;\n\t\tfor(int j=p[mnp]; j; j=a[j].next){du[a[j].y]--; if(!du[a[j].y])flag[a[j].y]=1;}\n\t}\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\tfor(int i=1; i<=n; i++)scanf(\"%d\", &w[i]);\n\tS=n+1; w[n+1]=0;\n\tl=0; memset(p, 0, sizeof(p));\n\tfor(int i=1; i<=n; i++)\n\t\tfor(int j=i+1; j<=n; j++)if(gcd(w[i], w[j])!=1){add(i, j); add(j, i);}\n\tfor(int i=1; i<=n; i++){add(S, i); add(i, S);}\n\tmemset(flag, 0, sizeof(flag));\n\tfa[S]=0; dfs(S);\n\tfor(int i=1; i<=S; i++)son[i].clear();\n\tfor(int i=1; i<=n; i++)son[fa[i]].push_back(i);\n\tmemset(flag, 0, sizeof(flag)); flag[S]=1; l=-1;\n\tfor(int i=1; i<=S; i++){\n\t\tmnp=0; w[0]=inf;\n\t\tfor(int j=1; j<=S; j++)if(flag[j]&&w[mnp]>w[j])mnp=j;\n\t\tb[++l]=w[mnp]; flag[mnp]=0;\n\t\tfor(int j=0; j<son[mnp].size(); j++)flag[son[mnp][j]]=1;\n\t}\n\tsolve();\n\tfor(int i=1; i<=n-1; i++)printf(\"%d \", ans[i]); printf(\"%d\", ans[n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mp make_pair\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int > vi;\ntypedef pair<int ,int > pii;\ntypedef vector<pii> vii;\nconst int inf=0x3f3f3f3f, maxn=2007, mod=1e9+7;\nconst ll linf=0x3f3f3f3f3f3f3f3fLL;\nint n;\nint a[maxn];\nbool e[maxn][maxn];\nvi e1[maxn];\nbool vis[maxn];\nint ind[maxn];\nbool book[maxn];\ninline int read(){\n   int s=0,w=1;\n   char ch=getchar();\n   while(ch<='0'||ch>'9'){if(ch=='-')w=-1;ch=getchar();}\n   while(ch>='0'&&ch<='9') s=(s<<1)+(s<<3)+ch-'0',ch=getchar();\n   return s*w;\n}\ninline void write(int x)\n{\n     if(x<0) putchar('-'),x=-x;\n     if(x>9) write(x/10);\n     putchar(x%10+'0');\n}\nvoid dfs(int u){\n//\tcout<<u<<endl;\n\tvis[u]=true;\n\tfor(int i=1;i<=n;i++){\n\t\tif(!vis[i]&&e[u][i]==true){\n//\t\t\tcout<<i<<endl;\n\t\t\te1[u].pb(i);\n\t\t\tind[i]++;\n\t\t\tdfs(i);\n\t\t}\n\t}\n}\n\nint main(){\n\tn=read();\n\tfor(int i=1;i<=n;i++){\n\t\ta[i]=read();\n\t}\n\tsort(a+1,a+1+n);\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=i+1;j<=n;j++){\n\t\t\tif(__gcd(a[i],a[j])!=1)e[i][j]=true,e[j][i]=true;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tif(!vis[i])dfs(i);\n//\t\tcout<<endl;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=n;j>=1;j--){\n\t\t\tif(!book[j]&&ind[j]==0){\n\t\t\t\tbook[j]=true;\n\t\t\t\tprintf(\"%d \",a[j]);\n\t\t\t\tfor(int k=0;k<e1[j].size();k++){\n\t\t\t\t\tind[e1[j][k]]--;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nbool vis[2003];\nvector<int>v;\nvector<int>va[2003],g[2003],vb[2003];\nint n,a[2003];\npair<int,int>axx[2003];\nbool cmp(pair<int,int>a,pair<int,int>b){\n    return a>b;\n}\nbool isprime(int x){\n\tfor(int i=2;i<=sqrt(x);i++)\n\t\tif(x%i==0)\n\t\t\treturn 0;\n\treturn 1;\n}\nint dfs(int x,int xxxxx){\n\tvb[xxxxx].push_back(a[x]);\n\t//cout<<\"HELLO\"<<xxxxx<<endl;\n\tvis[x]=1;\n\tint minn=a[x];\n\tfor(int i=0;i<g[x].size();i++)\n\t\tif(!vis[g[x][i]])\n\t\t\tminn=min(minn,dfs(g[x][i],xxxxx));\n\treturn minn;\n}\nint main(){\n\tcin>>n;\n\tfor(int i=2;i<=10000;i++)\n\t\tif(isprime(i))\n\t\t\tv.push_back(i);\n\tfor(int i=0;i<n;i++)\n\t\tcin>>a[i];\n\tsort(a,a+n);\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<v.size();j++)\n\t\t\tif(a[i]%v[j]==0)\n\t\t\t\tva[i].push_back(v[j]);\n\t}\n\tfor(int i=0;i<n;i++)\n\t\tfor(int j=i+1;j<n;j++)\n\t\t{\n\t\t\tbool can=0;\n\t\t\tfor(int ii=0;ii<va[i].size();ii++)\n\t\t\t{\n\t\t\t\tfor(int jj=0;jj<va[j].size();jj++)\n\t\t\t\t\tif(va[i][ii]==va[j][jj])\n\t\t\t\t\t{\n\t\t\t\t\t\tg[i].push_back(j),\n\t\t\t\t\t\tg[j].push_back(i),\n\t\t\t\t\t\tcan=1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\tif(can==1)break;\n\t\t\t}\n\t\t}\n\tint cnt=0;\n\tfor(int i=0;i<n;i++)\n\t\tsort(g[i].begin(),g[i].end());\n\tfor(int i=0;i<n;i++)\n\t\tif(!vis[i])\n\t\t\taxx[cnt].second=i,\n\t\t\taxx[cnt++].first=dfs(i,i);\n\tsort(axx,axx+cnt,cmp);\n    for(int i=0;i<cnt;i++)\n    \tfor(int j=0;j<vb[axx[i].second].size();j++)\n    \t\tcout<<vb[axx[i].second][j]<<' ';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#include <ext/pb_ds/assoc_container.hpp> // Common file\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vb = vector<bool>;\nusing vd = vector<double>;\nusing vs = vector<string>;\n\ntypedef tree<\nll,\nnull_type,\nless<ll>,\nrb_tree_tag,\ntree_order_statistics_node_update>\nordered_set;\n// ordered_set X;\n// *X.find_by_order(i) = ith largest element (counting from zero)\n// X.order_of_key(k) = number of items in X < k (strict lt)\n\nll gcd(ll a, ll b) {\n    if (b > a) return gcd(b, a);\n    if (b == 0) return a;\n    return gcd(b, a % b);\n}\n\nint main(){\n    int N;\n    cin >> N;\n\n    vll A(N);\n    for (int i=0;i<N;i++) cin >> A[i];\n\n    vvi adj(N);\n\n    // replace with sparsified graph\n    for (int i=0;i<N;i++) {\n        for (int j=i+1;j<N;j++) {\n            if (gcd(A[i], A[j]) > 1) {\n                adj[i].push_back(j);\n                adj[j].push_back(i);\n            }\n        }\n    }\n\n    vi comps(N, -1);\n    vi smallest;\n    int ncomps = 0;\n    for (int i=0;i<N;i++) {\n        if (comps[i] == -1) {\n            comps[i] = ncomps;\n            queue<int> bfs;\n            bfs.push(i);\n\n            int curmin = i;\n\n            while (!bfs.empty()) {\n                int cur = bfs.front();\n                bfs.pop();\n\n                if(A[cur] < A[curmin]) curmin = cur;\n\n                for (int nbr : adj[cur]) {\n                    if (comps[nbr] == -1) {\n                        comps[nbr] = ncomps;\n                        bfs.push(nbr);\n                    }\n                }\n            }\n\n            smallest.push_back(curmin);\n            ncomps++;\n        }\n    }\n\n    priority_queue<pair<ll, int>> process;\n    for (int i : smallest) {\n        // cout << \"adding \" << A[i] << \" \" << i << endl;\n        process.push({A[i], i});\n    }\n\n    vb dead(N, false);\n    vi order;\n\n    while (!process.empty()) {\n        auto cur = process.top();\n        process.pop();\n        int v = cur.second;\n\n        order.push_back(v);\n        dead[v] = true;\n        int curc = comps[v];\n\n        for (int w : adj[v]) {\n            if (!dead[w] && comps[w] == curc) {\n                int curmin = w;\n                comps[w] = ncomps;\n                queue<int> bfs;\n                bfs.push(w);\n\n                while (!bfs.empty()) {\n                    int cur = bfs.front();\n                    bfs.pop();\n\n                    for (int nbr : adj[cur]) {\n                        if (nbr == v && A[cur] < A[curmin]) curmin = cur;\n                        if (!dead[nbr] && comps[nbr] == curc) {\n                            comps[nbr] = ncomps;\n                            bfs.push(nbr);\n                        }\n                    }\n                }\n\n                ncomps++;\n                process.push({A[curmin], curmin});\n            }\n        }\n\n    }\n\n    for (int i = 0; i<N;i++) cout << A[order[i]] << \" \\n\"[i+1==N];\n\n    return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "\n//#define USEPB_DS\n#define USETR1\n#define CPPELEVEN\n#define GPP\n\n/*\n * temp.cpp\n *\n *  Created on: 2012-7-18\n *      Author: BSBandme\n */\n//#pragma comment(linker, \"/STACK:1024000000,1024000000\")\n\n#include <iostream>\n#include <fstream>\n#include <string.h>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <cassert>\n#include <list>\n#include <iomanip>\n#include <math.h>\n#include <deque>\n#include <utility>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cctype>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <functional>\n#include <sstream>\n#include <tuple>\n\nusing namespace std;\n\n#ifndef CPPELEVEN\n#ifdef USETR1\n#include <tr1/unordered_map>\n#include <tr1/unordered_set>\nusing namespace tr1;\n#endif\n#else\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\n#ifdef USEPB_DS\n#include <ext/pb_ds/priority_queue.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\n// binomial_heap_tag, rc_binomial_heap_tag, thin_heap_tag, binary_heap_tag\ntypedef __gnu_pbds::priority_queue<int, greater<int>, pairing_heap_tag> pq_type;\n// splay_tree_tag, ov_tree_tag\ntypedef tree <int, null_type, less <int>, rb_tree_tag, tree_order_statistics_node_update> tree_type;\n#endif\n\n#define mpr make_pair\ntypedef unsigned int ui;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <double, double> pdd;\ntypedef vector <int> vi;\ntypedef vector <ll> vll;\ntypedef vector <double> vd;\ntypedef vector <string> vs;\ntypedef map <string, int> mpsi;\ntypedef map <double, int> mpdi;\ntypedef map <int, int> mpii;\n\nconst double pi = acos(0.0) * 2.0;\nconst long double eps = 1e-10;\nconst int step[8][2] = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}, {-1, 1}, {1, 1}, {1, -1}, {-1, -1}};\n\ntemplate <class T> inline T abs1(T a) {return a < 0 ? -a : a;}\n\n#ifndef CPPELEVEN\ntemplate <class T> inline T max1(T a, T b) { return b < a ? a : b; }\ntemplate <class T> inline T max1(T a, T b, T c) { return max1(max1(a, b), c); }\ntemplate <class T> inline T max1(T a, T b, T c, T d) { return max1(max1(a, b, c), d); }\ntemplate <class T> inline T max1(T a, T b, T c, T d, T e) { return max1(max1(a, b, c, d), e); }\ntemplate <class T> inline T min1(T a, T b) { return a < b ? a : b; }\ntemplate <class T> inline T min1(T a, T b, T c) { return min1(min1(a, b), c); }\ntemplate <class T> inline T min1(T a, T b, T c, T d) { return min1(min1(a, b, c), d); }\ntemplate <class T> inline T min1(T a, T b, T c, T d, T e) { return min1(min1(a, b, c, d), e); }\n#else\ntemplate <typename t, typename t1>\nt min1(t a, t1 b) { return a < b ? a : b; }\ntemplate <typename t, typename... arg>\nt min1(t a, arg... arr) { return min1(a, min1(arr...)); }\ntemplate <typename t, typename t1>\nt max1(t a, t1 b) { return a > b ? a : b; }\ntemplate <typename t, typename... arg>\nt max1(t a, arg... arr) { return max1(a, max1(arr...)); }\n#endif\n\ninline int jud(double a, double b){\n\tif(abs(a) < eps && abs(b) < eps) return 0;\n\telse if(abs1(a - b) / max(abs1(a), abs1(b)) < eps) return 0;\n\tif(a < b) return -1;\n\treturn 1;\n}\ntemplate <typename t> inline int jud(t a, t b){\n\tif(a < b) return -1;\n\tif(a == b) return 0;\n\treturn 1;\n}\n\n// f_lb == 1代表返回相同的一串的左边界，f_small == 1代表返回如果没有寻找的值返回小的数\ntemplate <typename it, typename t1>\ninline int find(t1 val, it a, int na, bool f_small = 1, bool f_lb = 1){\n\tif(na == 0) return 0;\n\tint be = 0, en = na - 1;\n\tif(*a <= *(a + na - 1)){\n\t\tif(f_lb == 0) while(be < en){\n\t\t\tint mid = (be + en + 1) / 2;\n\t\t\tif(jud(*(a + mid), val) != 1) be = mid;\n\t\t\telse en = mid - 1;\n\t\t}else while(be < en){\n\t\t\tint mid = (be + en) / 2;\n\t\t\tif(jud(*(a + mid), val) != -1) en = mid;\n\t\t\telse be = mid + 1;\n\t\t}\n\t\tif(f_small && jud(*(a + be), val) == 1) be--;\n\t\tif(!f_small && jud(*(a + be), val) == -1) be++;\n\t} else {\n\t\tif(f_lb) while(be < en){\n\t\t\tint mid = (be + en + 1) / 2;\n\t\t\tif(jud(*(a + mid), val) != -1) be = mid;\n\t\t\telse en = mid - 1;\n\t\t}else while(be < en){\n\t\t\tint mid = (be + en) / 2;\n\t\t\tif(jud(*(a + mid), val) != 1) en = mid;\n\t\t\telse be = mid + 1;\n\t\t}\n\t\tif(!f_small && jud(*(a + be), val) == -1) be--;\n\t\tif(f_small && jud(*(a + be), val) == 1) be++;\n\t}\n\treturn be;\n}\n\ntemplate <class T> inline T lowb(T num) {return num & (-num); }\n#ifdef GPP\ninline int bitnum(ui nValue) { return __builtin_popcount(nValue); }\ninline int bitnum(int nValue) { return __builtin_popcount(nValue); }\ninline int bitnum(ull nValue) { return __builtin_popcount(nValue) + __builtin_popcount(nValue >> 32); }\ninline int bitnum(ll nValue) { return __builtin_popcount(nValue) + __builtin_popcount(nValue >> 32); }\ninline int bitmaxl(ui a) { if(a == 0) return 0; return 32 - __builtin_clz(a); }\ninline int bitmaxl(int a) { if(a == 0) return 0; return 32 - __builtin_clz(a); }\ninline int bitmaxl(ull a) { int temp = a >> 32; if(temp) return 32 - __builtin_clz(temp) + 32; return bitmaxl(int(a)); }\ninline int bitmaxl(ll a) { int temp = a >> 32; if(temp) return 32 - __builtin_clz(temp) + 32; return bitmaxl(int(a)); }\n#else\n#endif\n\nlong long pow(long long n, long long m, long long mod = 0){\n\tif(m < 0) return 0;\n\tlong long ans = 1;\n\tlong long k = n;\n\twhile(m){\n\t\tif(m & 1) {\n\t\t\tans *= k;\n\t\t\tif(mod) ans %= mod;\n\t\t}\n\t\tk *= k;\n\t\tif(mod) k %= mod;\n\t\tm >>= 1;\n\t}\n\treturn ans;\n}\n\n#define  MOD 1000000007\ntemplate <class t1, class t2>\ninline void add(t1 &a, t2 b, int mod = -1) {\n\tif(mod == -1) mod = MOD;\n\ta += b;\n\twhile(a >= mod) a -= mod;\n\twhile(a < 0) a += mod;\n}\ntemplate <class t>\nvoid output1(t arr) {\n\tfor(int i = 0; i < (int)arr.size(); i++)\n\t\tcerr << arr[i] << ' ';\n\tcerr << endl;\n}\ntemplate <class t>\nvoid output2(t arr) {\n\tfor(int i = 0; i < (int)arr.size(); i++)\n\t\toutput1(arr[i]);\n}\n\n//....................密..........封..........线..........下..........禁..........止..........hack...............................................\n\nconst int maxn = 2010;\nint arr[maxn];\nint ans[maxn], lans;\nbitset <maxn> e[maxn];\nint have[maxn];\nint n;\n\nvoid dfs(int no) {\n\tans[lans++] = arr[no];\n\thave[no] = 1;\n\tvector <pii> temp;\n\tfor(int i = 0; i < n; i++) if(!have[i] && e[no].test(i)) {\n\t\ttemp.push_back(mpr(arr[i], i));\n\t}\n\tsort(temp.begin(), temp.end());\n\tint rlans = lans, rlans1 = lans;\n\tfor(auto it : temp\t) if(!have[it.second]) {\n\t\tdfs(it.second);\n\t\treverse(ans + rlans1, ans + lans);\n\t\trlans1 = lans;\n\t}\n\treverse(ans + rlans, ans + lans);\n}\n\nint main() {\n\n\n//............................不要再忘了检查maxn大小了！！！！BSBandme你个SB！！！！...................................................\n\n\tios_base::sync_with_stdio(0);\n\t#ifdef DEBUG //......................................................................................................\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint __size__ = 256 << 20; // 256MB\n\tchar *__p__ = (char*)malloc(__size__) + __size__;\n\t__asm__(\"movl %0, %%esp\\n\" :: \"r\"(__p__));\n\t#endif //...........................................................................................................\n\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", arr + i);\n\t}\n\tsort(arr, arr + n);\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = i + 1; j < n; j++) if(__gcd(arr[i], arr[j]) != 1) {\n\t\t\te[i].set(j, 1);\n\t\t\te[j].set(i, 1);\n\t\t}\n\n\tfor(int i = 0; i < n; i++) if(!have[i]) {\n\t\tint rlans = lans;\n\t\tdfs(i);\n\t\treverse(ans + rlans, ans + lans);\n\t}\n\tfor(int i = lans - 1; i >= 0; i--)\n\t\tprintf(\"%d \", ans[i]);\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <set>\n#include <map>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <queue>\n\n#define mp make_pair\n#define pb push_back\n\n\ntypedef long long ll;\ntypedef long double ld;\n\nusing namespace std;\n\n#ifndef LOCAL\n#define cerr _cer\nstruct _cert\n{\n    template <typename T> _cert& operator << (T) { return *this; }\n};\n_cert _cer;\n#endif\n\ntemplate <typename T> void dprint(T begin, T end) {\n    for (auto i = begin; i != end; i++) {\n\t\tcerr << (*i) << \" \";\n    }\n    cerr << \"\\n\";\n}\n\nint en[210000];\nint ds[210000];\nint was[210000];\nvector<int> eds[210000];\nint a[210000];\nint n;\nint cc;\nmap<int, int> mm;\n\nvoid addedge(int a, int b) {\n\teds[a].push_back(b);\n\teds[b].push_back(a);\n}\n\nint dfs1(int v) {\n\tint now = -1;\n\twas[v] = 1;\n\tif (en[v])\n\t\tnow = v;\n\tfor (int u: eds[v]) {\n\t\tif (!was[u] && !ds[u]) {\n\t\t\tint x = dfs1(u);\n\t\t\tif (x != -1 && (now == -1 || a[now] > a[x]))\n\t\t\t\tnow = x;\n\t\t}\n\t}\n\treturn now;\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; ++i)\n\t\tcin >> a[i];\n\tcc = n;\n\tfor (int i = 0; i < n; ++i) {\n\t\tint tmp = a[i];\n\t\tfor (int j = 2; j * j <= tmp; ++j)\n\t\t\tif (tmp % j == 0) {\n\t\t\t\tif (mm.count(j))\n\t\t\t\t\taddedge(mm[j], i);\n\t\t\t\telse\n\t\t\t\t\taddedge(mm[j] = cc++, i);\n\t\t\t\twhile (tmp % j == 0)\n\t\t\t\t\ttmp /= j;\n\t\t\t}\n\t\tif (tmp != 1) {\n\t\t\tint j = tmp;\n\t\t\tif (mm.count(j))\n\t\t\t\taddedge(mm[j], i);\n\t\t\telse\n\t\t\t\taddedge(mm[j] = cc++, i);\n\t\t}\n\n\t}\n\tfor (int i = 0; i < n; ++i)\n\t\ten[i] = 1, ds[i] = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tmemset(was, 0, sizeof(was[0]) * cc);\n\t\tint mx = -1;\n\t\tfor (int j = 0; j < n; ++j) {\n\t\t\tif (en[j] && !was[j]) {\n\t\t\t\tint xx = dfs1(j);\n\t\t\t\tif (mx == -1 || a[mx] < a[xx])\n\t\t\t\t\tmx = xx;\n\t\t\t}\n\t\t}\n\t\t//cerr << mx << \"\\n\";\n\t\tcout << a[mx] << \" \";\n\t\tds[mx] = 1;\n\t\ten[mx] = 0;\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tif (a[i] > a[mx])\n\t\t\t\ten[i] = 0;\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tif (!ds[i] && __gcd(a[i], a[mx]) != 1)\n\t\t\t\ten[i] = 1;\n\t}\n\tcout << \"\\n\";\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\n#define REP(i,m) for(int i=0;i<(m);++i)\n#define REPN(i,m,in) for(int i=(in);i<(m);++i)\n#define ALL(t) (t).begin(),(t).end()\n#define CLR(a) memset((a),0,sizeof(a))\n#define pb push_back\n#define mp make_pair\n#define fr first\n#define sc second\n\nusing namespace std;\n\n\n#ifdef DEB\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define prl cerr<<\"called:\"<< __LINE__<<endl\n#define dumpR(x) cerr<<\"\\x1b[31m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\n#define dumpY(x) cerr<<\"\\x1b[33m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\n#define dumpG(x) cerr<<\"\\x1b[32m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\ntemplate<class T> void debug(T a,T b){ for(;a!=b;++a) cerr<<*a<<' ';cerr<<endl;}\n#else\n#define dump(x) ;\n#define dumpR(x) ;\n#define dumpY(x) ;\n#define dumpG(x) ;\n#define prl ;\ntemplate<class T> void debug(T a,T b){ ;}\n#endif\n\ntemplate<class T> void chmin(T& a,const T& b) { if(a>b) a=b; }\ntemplate<class T> void chmax(T& a,const T& b) { if(a<b) a=b; }\n\ntypedef long long int lint;\ntypedef pair<int,int> pi;\n\nnamespace std{\n  template<class S,class T>\n  ostream &operator <<(ostream& out,const pair<S,T>& a){\n    out<<'('<<a.fr<<','<<a.sc<<')';\n    return out;\n  }\n}\n\n//const int INF=5e8;\nint n;\nint ar[2005];\nint prm[2005*10],m;\ntypedef vector<int> vi;\nvi fact[2005];\nvi rev[2005*10];\nbool mark[2005];\n\nint cnt;\nbool vis_p[2005*10];\nbool vis_v[2005];\nvoid dfs(int v){\n  vis_v[v]=true;\n  ++cnt;\n  for(auto p:fact[v]) if(!vis_p[p]){\n    vis_p[p]=true;\n    for(auto e:rev[p]) if(!vis_v[e] && !mark[e]){\n      dfs(e);\n    }\n  }\n}\n\nint from[2005];\nbool ok[2005];\nint main(){\n  cin>>n;\n  REP(i,n){\n    scanf(\"%d\",&ar[i]);\n  }\n  sort(ar,ar+n);\n  REP(i,n){\n    int tmp=ar[i];\n    for(int j=2;j*j<=tmp;++j) if(tmp%j==0){\n      while(tmp%j==0) tmp/=j;\n      fact[i].pb(j);\n    }\n    if(tmp>1) fact[i].pb(tmp);\n    for(auto e:fact[i]) prm[m++]=e;\n  }\n  sort(prm,prm+m);\n  m=unique(prm,prm+m)-prm;\n  REP(i,n){\n    for(auto& e:fact[i]){\n      e=lower_bound(prm,prm+m,e)-prm;\n      rev[e].pb(i);\n    }\n  }\n  REP(i,n) ok[i]=true;\n\n  vi ans;\n  REP(i,n){\n    dump(i);\n    CLR(vis_v);\n    CLR(vis_p);\n    cnt=i;\n    REP(j,n) if(!mark[j] && !vis_v[j] && ok[j]){\n      dfs(j);\n      dump(j);dump(ar[j]);dump(cnt);\n      if(cnt==n){\n        ans.pb(ar[j]);\n        mark[j]=true;\n        break;\n      }\n    }\n    int val=ans.back();\n    dump(val);\n    REP(j,n) if(!mark[j]){\n      if(__gcd(val,ar[j])>1){\n        from[j]=i+1;\n        ok[j]=true;\n      }else if(val<ar[j]){\n        ok[j]=false;\n      }\n    }\n  }\n  for(auto e:ans) printf(\"%d\\n\",e);\n  return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pi;\ntypedef vector<int> vi;\n\n#define f first\n#define s second\n#define all(x) (x).begin(), (x).end()\n#define pb push_back\n#define mp make_pair\n#define forn(i, n) for(register int i=0; i<n; i++)\n#define Forn(i, n) for(register int i=1; i<=n; i++)\n#define foreach(it, a) for(__typeof((a).begin()) it=(a).begin(); it!=(a).end(); it++)\n#define Foreach(it, a) for(__typeof((a).rbegin()) it=(a).rbegin(); it!=(a).rend(); it++)\n\ninline int in()\n{\n    char c=getchar();\n    int neg=1, x=0;\n    while(!isdigit(c)) (c=='-')?neg=-1, c=getchar():c=getchar();\n    while(isdigit(c)) x=(x<<3)+(x<<1)+(c^48), c=getchar();\n    return neg*x;\n}\n\nconst int MAX=2005;\n\nbool vis[MAX], con[MAX][MAX];\nint N, a[MAX];\nvi tmp;\nvector<vi> ret;\n\ninline void dfs(int x)\n{\n//    cout<<x<<\" \"<<a[x]<<endl;\n    vis[x]=true;\n    forn(i, N)\n        if(!vis[i]&&con[x][i])\n        {\n            dfs(i);\n            break;\n        }\n    tmp.pb(a[x]);\n}\n\nint main()\n{\n    N=in();\n    forn(i, N)\n        a[i]=in();\n    sort(a, a+N);\n    forn(i, N) forn(j, N)\n        con[i][j]=(__gcd(a[i], a[j])!=1);\n    \n//    cout<<\"st\"<<endl;\n    forn(i, N)\n        if(!vis[i])\n        {\n            tmp.clear();\n            dfs(i);\n            ret.pb(tmp);\n        }\n    \n    Foreach(i, ret)\n        Foreach(it, *i)\n            printf(\"%d \", *it);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n#define pb push_back\n#define SZ(x) ((int)x.size())\nconst int N = 2010 ;\n\nint vis[N], ok[N][N], in[N], a[N] ;\nvector <int> g[N] ;\nint n ;\n\nvoid dfs(int rt) {\n\tvis[rt] = 1 ;\n\tfor (int i = 1; i <= n; i++)\n\tif (!vis[i] && ok[rt][i]) {\n\t\tin[i]++ ;\n\t\tg[rt].pb(i) ;\n\t\tdfs(i) ;\n\t}\n}\n\nvoid Top() {\n\tpriority_queue <int> q ;\n\tfor (int i = 1;  i <= n; i++) if (!in[i]) q.push(i) ;\n\twhile (!q.empty()) {\n\t\tint now = q.top() ;\n\t\tq.pop() ;\n\t\tcout << a[now] << \" \" ;\n\t\tfor (int i = 0; i < SZ(g[now]); i++) q.push(g[now][i]) ;\n\t}\n}\n\nint main(){\n\tscanf(\"%d\", &n) ;\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]) ;\n\tsort(a + 1, a + n + 1) ;\n\tfor (int i = 1; i <= n; i++)\n\tfor (int j = i + 1; j <= n; j++)\n\tif (__gcd(a[i], a[j]) != 1) ok[i][j] = ok[j][i] = 1 ;\n\tfor (int i = 1; i <= n; i++) if (!vis[i]) dfs(i) ;//连通块\n\tTop() ;//拓扑排序\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nconst int maxn = 2030, oo = 123456789, maxm = 34010;\n \nint n, m, T, ans, mn, a[maxn], foo[maxn], lst[maxm], tag[maxn];\nbool vis[maxn], f[maxn], G[maxn][maxn], F[maxn];\nstd::vector<int> g[maxn], has[maxn], rhas[maxm], all;\nstd::vector<std::pair<int, int> > v;\n \nvoid GEN() {\n\tint mx = 0;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif(!foo[i]) {\n\t\t\tif(a[i] == 1) {\n\t\t\t\tF[i] = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tF[i] = 0;\n\t\t\t\tfor (int j: has[i]) {\n\t\t\t\t\tif(lst[j] >= mx) {\n\t\t\t\t\t\tF[i] = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t(foo[i] > mx) && (mx = foo[i]);\n\t\t}\n\t}\n\treturn;\n}\n \ninline void dfs(int &u) {\n\ttag[u] = T;\n\t(F[u] && a[u] < mn) && (mn = a[u]);\n\tvis[u] = 1;\n\tfor (int &v: g[u]) {\n\t\tif(!vis[v] && !f[v]) {\n\t\t\tdfs(v);\n\t\t}\n\t}\n\treturn;\n}\n \nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tscanf(\"%d\", a + i);\n\t\tint t = a[i];\n\t\tfor (int x = 2; x * x <= t; ++x) {\n\t\t\tif(t % x == 0) {\n\t\t\t\tall.push_back(x);\n\t\t\t\twhile(t % x == 0) {\n\t\t\t\t\tt /= x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(t > 1) {\n\t\t\tall.push_back(t);\n\t\t}\n\t}\n\tstd::sort(a + 1, a + n + 1);\n\tstd::sort(all.begin(), all.end());\n\tall.resize(std::unique(all.begin(), all.end()) - all.begin());\n\tm = (int)(all.size());\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tif(a[i] % all[j] == 0) {\n\t\t\t\thas[i].push_back(j);\n\t\t\t\trhas[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int j = 0; j < m; ++j) {\n\t\tfor (int i = 0; i < (int)(rhas[j].size()); ++i) {\n\t\t\tfor (int k = 0; k < i; ++k) {\n\t\t\t\tint u = rhas[j][i], v = rhas[j][k];\n\t\t\t\tif(!G[u][v]) {\n\t\t\t\t\tg[u].push_back(v);\n\t\t\t\t\tg[v].push_back(u);\n\t\t\t\t\tG[u][v] = G[v][u] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tGEN();\n\t\tmemset(vis + 1, 0, sizeof(vis[0]) * n);\n\t\tv.clear();\n\t\tfor (int u = 1; u <= n; ++u) {\n\t\t\tif(F[u]) {\n\t\t\t\tif(!vis[u] && !f[u]) {\n\t\t\t\t\t++T;\n\t\t\t\t\tmn = oo;\n\t\t\t\t\tdfs(u);\n\t\t\t\t\tv.push_back(std::make_pair(mn, T));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstd::sort(v.begin(), v.end());\n\t\tint sz = (int)(v.size());\n\t\t//ans = 0;\n\t\tfor (int u = 1; u <= n; ++u) {\n\t\t\tif(F[u] && !f[u]) {\n\t\t\t\tint i = sz - 1;\n\t\t\t\tif(v[i].second == tag[u]) {\n\t\t\t\t\t--i;\n\t\t\t\t}\n\t\t\t\tif(i < 0 || v[i].first <= a[u]) {\n\t\t\t\t\tans = u;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tf[ans] = 1;\n\t\tfoo[ans] = i;\n\t\tprintf(\"%d \", a[ans]);\n\t\tfor (int j: has[ans]) {\n\t\t\tlst[j] = i;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mp  make_pair\n#define pb  push_back\nusing namespace std;\n\ntypedef pair<int,int>  PII;\nint n,a[2010],b[2010],e[2010][2010],vis[2010];\nvector <int> V[2010];\npriority_queue <PII> Q;\n\nint gcd(int a,int b){return b?gcd(b,a%b):a;}\nbool cmp(int x,int y){return a[x]<a[y];}\n\nvoid work()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1; i<=n; i++)  scanf(\"%d\",&a[i]),b[i]=i;\n\tsort(b+1,b+n+1,cmp);\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=i+1; j<=n; j++)\n\t\t\tif (gcd(a[i],a[j])!=1)\n\t\t\t\te[i][j]=e[j][i]=1;\n\tfor (int i=1,x,y; i<=n; i++)\n\t\tif (!vis[b[i]])\n\t\t\t{\n\t\t\t\tQ.push(mp(-a[b[i]],b[i])),vis[b[i]]=1;\n\t\t\t\twhile (!Q.empty())\n\t\t\t\t\t{\n\t\t\t\t\t\tV[i].pb(-Q.top().first),x=Q.top().second,Q.pop();\n\t\t\t\t\t\tfor (y=1; y<=n; y++)\n\t\t\t\t\t\t\tif ((e[x][y])&&(!vis[y]))\n\t\t\t\t\t\t\t\tQ.push(mp(-a[y],y)),vis[y]=1;\n\t\t\t\t\t}\n\t\t\t}\n\tfor (int i=n; i; i--)\n\t\tfor (int j=0; j<V[i].size(); j++)\n\t\t\tprintf(\"%d \",V[i][j]);\n}\n\nint main()\n{\n\twork();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#define rep(i,l,r) for(int i=(l);i<=(r);++i)\n#define per(i,r,l) for(int i=(r);i>=(l);--i)\nusing namespace std;\nconst int N=2010;\nint n,a[N],d[N],e[N][N];bool vis[N];\nvoid dfs(int x){\n    vis[x]=1;\n    rep(y,1,n) if(__gcd(a[x],a[y])!=1&&!vis[y]) d[y]=1,e[x][y]=1,dfs(y); \n}\nvoid topsort(){\n    priority_queue<int> q;\n    rep(i,1,n) if(!d[i]) q.push(i);\n    while(!q.empty()){\n        int x=q.top();q.pop();printf(\"%d \",a[x]);\n        rep(y,1,n) if(e[x][y]) q.push(y);\n    }\n}\nint main(){\n    scanf(\"%d\",&n);\n    rep(i,1,n) scanf(\"%d\",a+i);sort(a+1,a+n+1);\n    rep(i,1,n) if(!vis[i]) dfs(i);\n    topsort();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int, int> pii;\n\nconst int N = 2e3 + 5;\n\nint n, a[N], ans[N], in[N];\nbool mark[N];\nvector <int> tp, adj[N];\nvector <pii> g[N];\n\nvoid dfs(int v) {\n\tmark[v] = true;\n\tfor (auto e : g[v]) {\n\t\tint u = e.second;\n\t\tif(!mark[u]) {\n\t\t\tdfs(u);\n\t\t}\n\t}\n\ttp.push_back(v);\n}\n\nint main() {\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\t\n\tcin >> n;\n\tfor (int i = 0; i < n; i++)\n\t\tcin >> a[i];\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = i + 1; j < n; j++)\n\t\t\tif(__gcd(a[i], a[j]) > 1)\n\t\t\t\tg[i].push_back({a[j], j}), g[j].push_back({a[i], i});;\n\tfor (int i = 0; i < n; i++)\n\t\tsort(g[i].begin(), g[i].end());\n\tfor (int i = 0; i < n; i++)\n\t\tif(!mark[i])\n\t\t\tdfs(i);\n\treverse(tp.begin(), tp.end());\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tint x = tp[i], y = tp[j];\n\t\t\tif(__gcd(a[x], a[y]) > 1) {\n\t\t\t\tadj[x].push_back(y);\n\t\t\t\tin[y]++;\n\t\t\t}\n\t\t}\n\t}\n\tpriority_queue <pii> pq;\n\tfor (int i = 0; i < n; i++) {\n\t\tif(!in[i])\n\t\t\tpq.push({a[tp[i]], tp[i]});\n\t}\n\tint cnt = 0;\n\twhile(!pq.empty()) {\n\t\tpii p = pq.top();\n\t\tpq.pop();\n\t\tans[cnt++] = p.first;\n\t\tint v = p.second;\n\t\tfor (auto u : adj[v]) {\n\t\t\tin[u]--;\n\t\t\tif(!in[u])\n\t\t\t\tpq.push({a[u], u});\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++)\n\t\tcout << ans[i] << \" \";\n\tcout << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define gc c=getchar()\n#define r(x) read(x)\n#define ll long long\n\ntemplate<typename T>\ninline void read(T&x){\n    x=0;T k=1;char gc;\n    while(!isdigit(c)){if(c=='-')k=-1;gc;}\n    while(isdigit(c)){x=x*10+c-'0';gc;}x*=k;\n}\n\nconst int N=2005;\n\nint gcd(int a,int b){\n\treturn b?gcd(b,a%b):a;\n}\n\nvector<int>G1[N];\nvector<int>G2[N];\n\nint a[N];\nint deg[N];\nbool vis[N];\n\nvoid dfs(int x){\n\tvis[x]=1;\n\tfor(int i=0;i<G1[x].size();++i){\n\t\tint v=G1[x][i];\n\t\tif(!vis[v]){\n\t\t\tG2[x].push_back(v);\n\t\t\tdeg[v]++;\n\t\t\tdfs(v);\n\t\t}\n\t}\n}\n\nint main(){\n//\tfreopen(\".in\",\"r\",stdin);\n//\tfreopen(\".out\",\"w\",stdout);\n\tint n;r(n);\n\tfor(int i=1;i<=n;++i)r(a[i]);\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;++i){\n\t\tfor(int j=i+1;j<=n;++j){\n\t\t\tif(gcd(a[i],a[j])!=1){\n\t\t\t\tG1[i].push_back(j);\n\t\t\t\tG1[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\tif(!vis[i]){\n\t\t\tdfs(i);\n\t\t}\n\t}\n\tpriority_queue<pair<int,int> >Q;\n\tfor(int i=1;i<=n;++i){\n\t\tif(!deg[i]){\n\t\t\tQ.push(make_pair(a[i],i));\n\t\t}\n\t}\n\twhile(!Q.empty()){\n\t\tint x=Q.top().second;Q.pop();\n\t\tprintf(\"%d \",a[x]);\n\t\tfor(int i=0;i<G2[x].size();++i){\n\t\t\tint v=G2[x][i];\n\t\t\tif(!--deg[v]){\n\t\t\t\tQ.push(make_pair(a[v],v));\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\n#define ll long long\n#define MAX 2020\ninline ll read()\n{\n\tll x=0;bool t=false;char ch=getchar();\n\twhile((ch<'0'||ch>'9')&&ch!='-')ch=getchar();\n\tif(ch=='-')t=true,ch=getchar();\n\twhile(ch<='9'&&ch>='0')x=x*10+ch-48,ch=getchar();\n\treturn t?-x:x;\n}\nstruct Line{int v,next;}e[MAX*MAX];\nint h[MAX],cnt=1,dg[MAX];\nvector<int> E[MAX];\ninline void Add(int u,int v){e[cnt]=(Line){v,h[u]};h[u]=cnt++;dg[v]+=1;}\ninline void ADD(int u,int v){E[u].push_back(v);}\nint n;\nll a[MAX];\npriority_queue<int> Q;\nbool vis[MAX];\nvoid dfs(int u)\n{\n\tvis[u]=true;\n\tfor(int v:E[u])if(!vis[v])dfs(v),Add(u,v);\n}\nint main()\n{\n\tn=read();\n\tfor(int i=1;i<=n;++i)a[i]=read();\n\tsort(&a[1],&a[n+1]);\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=i+1;j<=n;++j)\n\t\t\tif(__gcd(a[i],a[j])>1)ADD(i,j),ADD(j,i);\n\tfor(int i=1;i<=n;++i)if(!vis[i])dfs(i);\n\tfor(int i=1;i<=n;++i)if(!dg[i])Q.push(i);\n\twhile(!Q.empty())\n\t{\n\t\tint u=Q.top();Q.pop();printf(\"%lld \",a[u]);\n\t\tfor(int i=h[u];i;i=e[i].next)\n\t\t\tif(!--dg[e[i].v])Q.push(e[i].v);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#define ll long long\n#define rep(i, a, b) for (int i = a; i <= (int)b; i ++)\nvoid read(int & x) {\n    x = 0; int flag = 1; char ch = ' ';\n    while (ch < '0' || ch > '9') { if(ch == '-') flag = -1; ch = getchar(); }\n    while (ch >= '0' && ch <= '9') x = x * 10 + ch - '0', ch = getchar();\n    x *= flag;\n}\nvoid read(ll & x) {\n    x = 0; int flag = 1; char ch = ' ';\n    while (ch < '0' || ch > '9') { if(ch == '-') flag = -1; ch = getchar(); }\n    while (ch >= '0' && ch <= '9') x = x * 10 + ch - '0', ch = getchar();\n    x *= flag;\n}\nusing namespace std;\nconst int maxn = 1010;\nint n, degree[maxn], a[maxn];\nbool vis[maxn], mp[maxn][maxn];\nvector < int > ans, edge[maxn];\nint gcd(int a, int b) { return b ? gcd(b, a % b) : a; }\nvoid dfs(int u) {\n    vis[u] = 1;\n    rep(i, 1, n)\n        if(!vis[i] && mp[u][i]) edge[u].push_back(i), degree[i] ++, dfs(i);\n}\nvoid solve() {\n    priority_queue < int > pq;\n    memset(vis, 0, sizeof(vis));\n    rep(i, 1, n) if(degree[i] == 0) pq.push(i), vis[i] = 1;\n    while(!pq.empty()) {\n        int u = pq.top(); pq.pop();\n        ans.push_back(u);\n        rep(i, 0, edge[u].size() - 1) {\n            int v = edge[u][i];\n            if(-- degree[v] == 0) pq.push(v);\n        }\n    }\n}\nint main()\n{\n    read(n);\n    rep(i, 1, n) read(a[i]);\n    sort(a + 1, a + 1 + n);\n    rep(i, 1, n - 1) rep(j, i + 1, n) \n        if(gcd(a[i], a[j]) != 1) mp[i][j] = mp[j][i] = 1;\n    rep(i, 1, n) dfs(i);\n    solve();\n    rep(i, 0, n - 1) printf(\"%d \", a[ans[i]]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <vector>\n#include <cassert>\n#include <algorithm>\nusing namespace std;\n\nconst int N = 2005;\nbool G[N][N];\nbool used[N];\nvector <int> g[N];\nint n, a[N], sz;\nint in[N];\npriority_queue <int> pq;\n\ninline int gcd(int a, int b) { return !b ? a : gcd(b, a % b); }\n\nvoid dfs(int i) {\n\tused[i] = 1;\n\tfor (int j = 0; j < n; ++ j) if (!used[j] && G[i][j]) { g[i].push_back(j); ++ in[j]; dfs(j); }\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; ++ i) scanf(\"%d\", &a[i]);\n\tsort(a, a + n);\n\tfor (int i = 0; i < n; ++ i) for (int j = 0; j < n; ++ j) if (i ^ j) G[i][j] = (gcd(a[i], a[j]) != 1);\n\tfor (int i = 0; i < n; ++ i) if (!used[i]) dfs(i);\n\tfor (int i = 0; i < n; ++ i) if (!in[i]) pq.push(i);\n\twhile (!pq.empty()) {\n\t\tint i = pq.top(); pq.pop();\n\t\tprintf(\"%d \", a[i]);\n\t\tfor (int j = 0; j < (int) g[i].size(); ++ j) {\n\t\t\t-- in[g[i][j]];\n\t\t\tif (!in[g[i][j]]) pq.push(g[i][j]);\n\t\t}\n\t}\n\tputs(\"\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define N 2200\n\nint n,a[N],b[N][N],d[N];\nbool vis[N];\nvector<int> g[N];\npriority_queue<int> pq;\n\nvoid dfs(int u){\n\tvis[u]=1;\n\tfor (int v=1;v<=n;++v)\n\t\tif (!vis[v]&&b[u][v]){\n\t\t\tg[u].push_back(v); ++d[v];\n\t\t\tdfs(v);\n\t\t}\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;++i) scanf(\"%d\",a+i);\n\tsort(a+1,a+n+1);\n\tfor (int i=1;i<=n;++i)\n\t\tfor (int j=1;j<=n;++j) b[i][j]=__gcd(a[i],a[j])>1;\n\tfor (int i=1;i<=n;++i) if (!vis[i]) dfs(i);\n\tfor (int i=1;i<=n;++i) if (!d[i]) pq.push(i);\n\tfor (int i=1;i<=n;++i){\n\t\tint x=pq.top(); pq.pop();\n\t\tprintf(i==n?\"%d\\n\":\"%d \",a[x]);\n\t\tfor (int y:g[x]){\n\t\t\t--d[y];\n\t\t\tif (!d[y]) pq.push(y);\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n\t\t\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nconst int maxn = 2030, oo = 123456789, maxm = 54010;\n \nint n, m, T, ans, mn, a[maxn], foo[maxn], lst[maxm], tag[maxn];\nbool vis[maxn], f[maxn], G[maxn][maxn], F[maxn];\nstd::vector<int> g[maxn], has[maxn], rhas[maxm], all;\nstd::vector<std::pair<int, int> > v;\n \nvoid GEN() {\n\tint mx = 0;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif(!foo[i]) {\n\t\t\tif(a[i] == 1) {\n\t\t\t\tF[i] = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tF[i] = 0;\n\t\t\tfor (int j: has[i]) {\n\t\t\t\tif(lst[j] >= mx) {\n\t\t\t\t\tF[i] = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t(foo[i] > mx) && (mx = foo[i]);\n\t\t}\n\t}\n\treturn;\n}\n \nvoid dfs(int u) {\n\ttag[u] = T;\n\tif(F[u] && a[u] < mn) {\n\t\tmn = a[u];\n\t}\n\tvis[u] = 1;\n\tfor (int v: g[u]) {\n\t\tif(!vis[v] && !f[v]) {\n\t\t\tdfs(v);\n\t\t}\n\t}\n\treturn;\n}\n \nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tscanf(\"%d\", a + i);\n\t\tint t = a[i];\n\t\tfor (int x = 2; x * x <= t; ++x) {\n\t\t\tif(t % x == 0) {\n\t\t\t\tall.push_back(x);\n\t\t\t\twhile(t % x == 0) {\n\t\t\t\t\tt /= x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(t > 1) {\n\t\t\tall.push_back(t);\n\t\t}\n\t}\n\tstd::sort(a + 1, a + n + 1);\n\tstd::sort(all.begin(), all.end());\n\tall.resize(std::unique(all.begin(), all.end()) - all.begin());\n\tm = (int)(all.size());\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tif(a[i] % all[j] == 0) {\n\t\t\t\thas[i].push_back(j);\n\t\t\t\trhas[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int j = 0; j < m; ++j) {\n\t\tfor (int i = 0; i < (int)(rhas[j].size()); ++i) {\n\t\t\tfor (int k = 0; k < i; ++k) {\n\t\t\t\tint u = rhas[j][i], v = rhas[j][k];\n\t\t\t\tif(!G[u][v]) {\n\t\t\t\t\tg[u].push_back(v);\n\t\t\t\t\tg[v].push_back(u);\n\t\t\t\t\tG[u][v] = G[v][u] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tGEN();\n\t\tmemset(vis + 1, 0, sizeof(vis[0]) * n);\n\t\tv.clear();\n\t\tfor (int u = 1; u <= n; ++u) {\n\t\t\tif(F[u]) {\n\t\t\t\tif(!vis[u] && !f[u]) {\n\t\t\t\t\t++T;\n\t\t\t\t\tmn = oo;\n\t\t\t\t\tdfs(u);\n\t\t\t\t\tv.push_back(std::make_pair(mn, T));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstd::sort(v.begin(), v.end());\n\t\tint sz = (int)(v.size());\n\t\tans = 0;\n\t\tfor (int u = 1; u <= n; ++u) {\n\t\t\tif(F[u] && !f[u]) {\n\t\t\t\tint i = sz - 1;\n\t\t\t\tif(v[i].second == tag[u]) {\n\t\t\t\t\t--i;\n\t\t\t\t}\n\t\t\t\tif(i < 0 || v[i].first <= a[u]) {\n\t\t\t\t\tans = u;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tassert(ans);\n\t\tf[ans] = 1;\n\t\tfoo[ans] = i;\n\t\tprintf(\"%d \", a[ans]);\n\t\tfor (int j: has[ans]) {\n\t\t\tlst[j] = i;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lint;\ntypedef long double louble;\n\n#define so(a) ((int)((a).size()))\n\ntemplate<typename T1,typename T2> inline T1 max(T1 a,T2 b){return a<b?b:a;}\ntemplate<typename T1,typename T2> inline T1 min(T1 a,T2 b){return a<b?a:b;}\n\nconst char lf = '\\n';\n\nnamespace ae86\n{\n\tconst int bufl = 1 << 15;\n\n\tchar buf[bufl],*s=buf,*t=buf;\n\n\tinline int fetch()\n\t{\n\t\tif(s==t){t=(s=buf)+fread(buf,1,bufl,stdin);if(s==t)return EOF;}\n\t\treturn *s++;\n\t}\n\n\tinline int ty()\n\t{\n\t\tint a=0;int b=1,c=fetch();\n\t\twhile(!isdigit(c))b^=c=='-',c=fetch();\n\t\twhile(isdigit(c))a=a*10+c-48,c=fetch();\n\t\treturn b?a:-a;\n\t}\n}\nusing ae86::ty;\n\nconst int _ = 2007;\n\ninline int gcd(int a,int b){return __gcd(a,b);}\n\nvector<int> e[_],via[_];\n\nint n,val[_],ed[_]={0},ind[_]={0};\n\nvoid dfs(int x)\n{\n\ted[x]=1;\n\tfor(auto b:e[x])if(!ed[b])via[x].emplace_back(b),ind[b]++,dfs(b);\n}\n\nint main()\n{\n\tios::sync_with_stdio(0),cout.tie(nullptr);\n\n\tn=ty();\n\tfor(int i=1;i<=n;i++)val[i]=ty();\n\tsort(val+1,val+n+1);\n\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\tif(gcd(val[i],val[j])!=1)e[i].emplace_back(j),e[j].emplace_back(i);\n\n\tfor(int i=1;i<=n;i++)sort(e[i].begin(),e[i].end());\n\n\tfor(int i=1;i<=n;i++)if(!ed[i])dfs(i);\n\n\tpriority_queue<int> q;\n\tfor(int i=1;i<=n;i++)if(!ind[i])q.emplace(i);\n\n\twhile(!q.empty())\n\t{\n\t\tint a=q.top();q.pop();\n\t\tcout<<val[a]<<' ';\n\t\tfor(auto b:via[a])q.emplace(b);\n\t}\n\tcout<<lf;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n\nusing namespace std;\n\nconst int N=2009;\n\ninline int read()\n{\n\tint x=0;char ch=getchar();\n\twhile(ch<'0' || '9'<ch)ch=getchar();\n\twhile('0'<=ch && ch<='9')x=x*10+(ch^48),ch=getchar();\n\treturn x;\n}\n\nint n,a[N];\nint g[N][N];\nbool vis[N];\nint ind[N];\nvector<int> e[N];\n\ninline void dfs(int u)\n{\n\tfor(int i=1;i<=n;i++)\n\t\tif(g[u][i]>1 && !vis[i])\n\t\t{\n\t\t\tvis[i]=1;\n\t\t\te[u].push_back(i);\n\t\t\tind[i]++;\n\t\t\tdfs(i);\n\t\t}\n}\n\nint main()\n{\n\tn=read();\n\tfor(int i=1;i<=n;i++)\n\t\ta[i]=read();\n\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i;j<=n;j++)\n\t\t\tg[i][j]=g[j][i]=__gcd(a[i],a[j]);\n\n\tpriority_queue<int,vector<int>,less<int> > q;\n\n\tfor(int i=1;i<=n;i++)\n\t\tif(!vis[i])\n\t\t{\n\t\t\tvis[i]=1;\n\t\t\tdfs(i);\n\t\t}\n\n\tfor(int i=1;i<=n;i++)\n\t\tif(!ind[i])\n\t\t\tq.push(i);\n\n\twhile(!q.empty())\n\t{\n\t\tint u=q.top();\n\t\tq.pop();\n\t\tprintf(\"%d \",a[u]);\n\t\tfor(int i=0,ed=e[u].size();i<ed;i++)\n\t\t\tif(--ind[e[u][i]]==0)\n\t\t\t\tq.push(e[u][i]);\n\t}\n\tputs(\"\");\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// luogu-judger-enable-o2\n// =================================\n//   author: M_sea\n//   website: http://m-sea-blog.com/\n// =================================\n#include <algorithm>\n#include <iostream>\n#include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#include <queue>\n#define re register\nusing namespace std;\n\ninline int read() {\n    int X=0,w=1; char c=getchar();\n    while (c<'0'||c>'9') { if (c=='-') w=-1; c=getchar(); }\n    while (c>='0'&&c<='9') X=X*10+c-'0',c=getchar();\n    return X*w;\n}\n\nconst int N=2000+10;\n\nstruct Edge { int v,nxt; } e[N];\nint head[N];\n\ninline void addEdge(int u,int v) {\n    static int cnt=0;\n    e[++cnt]=(Edge){v,head[u]},head[u]=cnt;\n}\n\nint n;\nint a[N],vis[N],deg[N];\nint G[N][N];\n\ninline void dfs(int u) {\n    vis[u]=1;\n    for (re int i=1;i<=n;++i) {\n        if (vis[i]||!G[u][i]) continue;\n        ++deg[i],addEdge(u,i);\n        dfs(i);\n    }\n}\n\ninline void topsort() {\n    priority_queue<int> Q;\n    for (re int i=1;i<=n;++i)\n        if (!deg[i]) Q.push(i);\n    while (!Q.empty()) {\n        int u=Q.top(); Q.pop();\n        printf(\"%d \",a[u]);\n        for (re int i=head[u];i;i=e[i].nxt) Q.push(e[i].v);\n    }\n}\n\nint main() {\n    n=read();\n    for (re int i=1;i<=n;++i) a[i]=read();\n    sort(a+1,a+n+1);\n    for (re int i=1;i<=n;++i)\n        for (re int j=i+1;j<=n;++j) {\n            if (__gcd(a[i],a[j])==1) continue;\n            G[i][j]=G[j][i]=1;\n        }\n    for (re int i=1;i<=n;++i)\n        if (!vis[i]) dfs(i);\n    topsort();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define X first\n#define Y second\n\nint gcd(int a,int b) {return b?gcd(b,a%b):a;}\n\nconst int maxn=4010;\n\nint n,times,a[maxn],dfn[maxn],deg[maxn];\nint tote,FIR[maxn],TO[maxn],NEXT[maxn];\nint vis[maxn];\npriority_queue<pair<int,int> > q;\n\nvoid addedge(int u,int v)\n{\n\tTO[++tote]=v;\n\tNEXT[tote]=FIR[u];\n\tFIR[u]=tote;\n}\n\nint search(int u)\n{\n\tint Ans=u;\n\tvis[u]=1;\n\tfor (int p=FIR[u];p;p=NEXT[p])\n\t{\n\t\tint v=TO[p];\n\t\tif (vis[v]) continue;\n\t\tint tmp=search(v);\n\t\tAns=a[Ans]<a[tmp]?Ans:tmp;\n\t}\n\treturn Ans;\n}\n\nvoid dfs(int u)\n{\n\tvis[u]=2;\n\tdfn[u]=++times;\n\tvector<pair<int,int> > son;\n\tson.clear();\n\tfor (int p=FIR[u];p;p=NEXT[p])\n\t\tson.push_back(make_pair(a[TO[p]],TO[p]));\n\tsort(son.begin(),son.end());\n\tfor (int i=0;i<(int)son.size();i++)\n\t\tif (vis[son[i].Y]!=2) dfs(son[i].Y);\n}\n\nint main()\n{\n#ifdef h10\n\tfreopen(\"E.in\",\"r\",stdin);\n\tfreopen(\"E.out\",\"w\",stdout);\n#endif\n\tint i,j;\n\tscanf(\"%d\",&n);\n\tfor (i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tfor (i=1;i<=n;i++)\n\tfor (j=i+1;j<=n;j++)\n\t\tif (gcd(a[i],a[j])!=1)\n\t\t\taddedge(i,j),addedge(j,i);\n\n\tvector<pair<int,int> > root;\n\tfor (i=1;i<=n;i++)\n\t\tif (!vis[i])\n\t\t{\n\t\t\tint tmp=search(i);\n\t\t\troot.push_back(make_pair(a[tmp],tmp));\n\t\t}\n\treturn 0;\n\n\tsort(root.begin(),root.end());\n\tfor (i=0;i<(int)root.size();i++) dfs(root[i].Y);\n\n\ttote=0;\n\tmemset(FIR,0,sizeof(FIR));\n\tfor (i=1;i<=n;i++)\n\tfor (j=1;j<=n;j++)\n\t\tif (gcd(a[i],a[j])!=1&&dfn[i]<dfn[j])\n\t\t\taddedge(i,j),deg[j]++;\n\n\tfor (i=1;i<=n;i++)\n\t\tif (!deg[i]) q.push(make_pair(a[i],i));\n\twhile (!q.empty())\n\t{\n\t\tpair<int,int> u=q.top(); q.pop();\n\t\tprintf(\"%d \",u.X);\n\t\tfor (int p=FIR[u.Y];p;p=NEXT[p])\n\t\t{\n\t\t\tint v=TO[p];\n\t\t\tif (!(--deg[v])) q.push(make_pair(a[v],v));\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MN = 2005;\n \nint N, A[MN];\n\nvector<int> G[MN];\n \nint vis[MN];\nvoid DFS(int u) {\n\tvis[u] = 1;\n\tfor (int v = 1; v <= N; ++v)\n\t\tif (!vis[v] && std::__gcd(A[u], A[v]) > 1)\n\t\t\tG[u].push_back(v), DFS(v);\n}\n \nint main() {\n\tcin >> N;\n\tfor (int i = 1; i <= N; ++i) cin >> A[i];\n\tstd::sort(A + 1, A + N + 1);\n\tstd::priority_queue<int> q;\n\tfor (int i = 1; i <= N; ++i) if (!vis[i]) DFS(i), q.push(i);\n\twhile (!q.empty()) {\n\t\tint u = q.top(); q.pop();\n\t\tcout << A[u] << ' ';\n\t\tfor (int v : G[u]) q.push(v);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pb push_back\n#define all(x) x.begin(), x.end()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nconst int N = 2000 + 10;\nconst int MOD = 1000000007;\nconst int LOG = 20;\nconst int INF = 1000000010;\nconst int delta = 11353;\n\nint n;\nvi G[N], a;\nmap<int, int> mp;\nint mark[N];\nint mark2[N];\n\nvoid DFS(int v){\n\tmark[v] = 1;\n\tfor (auto u:G[v]){\n\t\tif ((mark[u] == 0) && (mark2[u] == 0)){\n\t\t\tDFS(u);\n\t\t}\n\t}\n}\nint GCD(int x, int y){\n\tif (x == 0 || y == 0) return (x + y);\n\tif (x == 1 || y == 1) return 1;\n\tif (x < y) swap(x, y);\n\treturn GCD(y, x % y);\n}\n\nint32_t main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++){\n\t\tint x;\n\t\tcin >> x;\n\t\tmp[x] ++;\n\t\ta.pb(x);\n\t}\n\tsort(all(a));\n\ta.resize(unique(all(a)) - a.begin());\n\tfor (int i = 0; i < a.size(); i++) for (int j = 0; j < i; j++) if (__gcd(a[i], a[j]) != 1){\n\t\tG[i].pb(j), G[j].pb(i);\n\t}\n\t//cout << GCD(7, 11) << '\\n';\n\tvi ans;\n\tint last = 0;\n\tfor (int i = 0; i < a.size(); i++){\n\t\tmemset(mark, 0, sizeof mark);\n\t\tif (i == 0){\n\t\t\tint mx = 0;\n\t\t\tfor (int j = 0; j < a.size(); j++) if (!mark[j]) mx = j, DFS(j);\n\t\t\tmark2[mx] = 1;\n\t\t\tans.pb(a[mx]);\n\t\t\t//cout << a[mx] << endl;\n\t\t\tlast = mx;\n\t\t}else{\n\t\t\tsort(all(G[last]));\n\t\t\tint mx = 0;\n\t\t\tfor (auto u:G[last]){\n\t\t\t\tif ((mark[u] == 0) && (mark2[u] == 0)) DFS(u), mx = u;\n\t\t\t}\t\n\t\t\tfor (int j = 0;  j < a.size(); j++){\n\t\t\t\tif ((mark[j] == 0) && (mark2[j] == 0)) mx = max(j, mx), DFS(j);\n\t\t\t}\n\t\t\tmark2[mx] = 1;\n\t\t\tans.pb(a[mx]);\n\t\t\tlast = mx;\n\t\t\t//cout << a[mx] << endl;\n\t\t}\n\t}\n\tfor (int i = 0; i < ans.size(); i++){\n\t\tint u = ans[i];\n\t\tif (i != 0){\n\t\t\t//if (GCD(ans[i], ans[i - 1]) == 1 && ans[i - 1] < ans[i]) assert(0);\n\t\t\tif (GCD(ans[i], ans[i - 1]) != 1 && ans[i - 1] > ans[i]) assert(0);\n\t\t\t\n\t\t}\n\t\tfor (int i = 0; i < mp[u]; i++) cout << u << ' ';\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#define rep(i, a, b) for (int i = (a), _ = (b); i <= _; ++ i)\n#define per(i, a, b) for (int i = (a), _ = (b); i >= _; -- i)\n#define For(i, a, b) for (int i = (a), _ = (b); i < _; ++ i)\n#define fore(e, u, v) for (int p = e(u), v = e[p].y; p; v = e[p = e[p].nxt].y)\n#define ri rd<int>\nusing namespace std;\nconst int maxN = 2e3 + 7;\n\ntemplate<class T> inline T rd() {\n\tbool f = 1; char c = getchar(); for (; !isdigit(c); c = getchar()) if (c == '-') f = 0;\n\tT x = 0; for (; isdigit(c); c = getchar()) x = x * 10 + c - 48; return f ? x : -x;\n}\n\ninline int gcd(int x, int y) { while (y) swap(x %= y, y); return x; }\n\nint n, a[maxN];\nbool vis[maxN];\nint deg[maxN];\nint ans[maxN], tt;\n\nstruct vec {\n\tstatic const int maxE = maxN * maxN;\n\tint g[maxN], te;\n\tstruct edge {int y, nxt;} e[maxE << 1];\n\tinline void push(int x, int y) { e[++te] = (edge){y, g[x]}; g[x] = te; }\n\tinline void link(int x, int y) { push(x, y), push(y, x); }\n\tinline int& operator () (int x) { return g[x]; }\n\tinline edge& operator [] (int x) { return e[x]; }\n}e, G;\nint bac[maxN];\n\nvoid dfs(int x) {\n\tvis[x] = 1;\n\tfore (e, x, y) if (!vis[y]) { // from small to big\n\t\tdfs(y);\n\t\tG.push(x, y);\n\t\t++ deg[y];\n\t}\n} \n\nvoid topu() {\n\tstatic priority_queue<int, vector<int>, less<int> > q;\n\tq.push(0);\n\twhile (!q.empty()) {\n\t\tint x = q.top(); q.pop();\n\t\tif (x) ans[++tt] = a[x];\n\t\tfore (G, x, y) if (-- deg[y] == 0) q.push(y);\n\t}\n\trep (i, 1, tt) printf(\"%d%c\", ans[i], \" \\n\"[i == tt]);\n}\n\nint main() {\n\n\tn = ri(); rep (i, 1, n) a[i] = ri();\n\tsort(a+1, a+n+1);\n\trep (i, 1, n) per (j, n, 1) if (gcd(a[i], a[j]) != 1) e.push(i, j);\n\tper (i, n, 1) e.link(0, i);\n\n\tdfs(0);\n\ttopu();\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nconst int maxn = 2030, oo = 123456789, maxm = 34010;\n \nint n, m, T, ans, mn, a[maxn], foo[maxn], lst[maxm], tag[maxn], q[maxn], rar, mx[maxn];\nbool vis[maxn], f[maxn], G[maxn][maxn], F[maxn];\nstd::vector<int> g[maxn], has[maxn], rhas[maxm], all;\nstd::vector<std::pair<int, int> > v;\n \nvoid GEN() {\n\tint mx = 0;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif(!foo[i]) {\n\t\t\tif(a[i] == 1) {\n\t\t\t\tF[i] = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tF[i] = 0;\n\t\t\t\tfor (int j: has[i]) {\n\t\t\t\t\tif(lst[j] >= mx) {\n\t\t\t\t\t\tF[i] = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t(foo[i] > mx) && (mx = foo[i]);\n\t\t}\n\t}\n\treturn;\n}\n /*\ninline void dfs(int &u) {\n\ttag[u] = T;\n\t(F[u] && a[u] < mn) && (mn = a[u]);\n\tvis[u] = 1;\n\tfor (int &v: g[u]) {\n\t\tif(!vis[v] && !f[v]) {\n\t\t\tdfs(v);\n\t\t}\n\t}\n\treturn;\n}\n */\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tscanf(\"%d\", a + i);\n\t\tint t = a[i];\n\t\tfor (int x = 2; x * x <= t; ++x) {\n\t\t\tif(t % x == 0) {\n\t\t\t\tall.push_back(x);\n\t\t\t\twhile(t % x == 0) {\n\t\t\t\t\tt /= x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(t > 1) {\n\t\t\tall.push_back(t);\n\t\t}\n\t}\n\tstd::sort(a + 1, a + n + 1);\n\tstd::sort(all.begin(), all.end());\n\tall.resize(std::unique(all.begin(), all.end()) - all.begin());\n\tm = (int)(all.size());\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tif(a[i] % all[j] == 0) {\n\t\t\t\thas[i].push_back(j);\n\t\t\t\trhas[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int j = 0; j < m; ++j) {\n\t\tfor (int i = 0; i < (int)(rhas[j].size()); ++i) {\n\t\t\tfor (int k = 0; k < i; ++k) {\n\t\t\t\tint u = rhas[j][i], v = rhas[j][k];\n\t\t\t\tif(!G[u][v]) {\n\t\t\t\t\tg[u].push_back(v);\n\t\t\t\t\tg[v].push_back(u);\n\t\t\t\t\tG[u][v] = G[v][u] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n//\t\tGEN();\n\t\tmemset(vis + 1, 0, sizeof(vis[0]) * n);\n\t\tv.clear();\n\t\tfor (int u = 1; u <= n; ++u) {\n\t\t\tif(F[u]) {\n\t\t\t\tif(!vis[u] && !f[u]) {\n\t\t\t\t\t++T;\n\t\t\t\t\tmn = oo;\n//\t\t\t\t\tdfs(u);\n\t\t\t\t\trar = 0;\n\t\t\t\t\tq[rar++] = u;\n\t\t\t\t\tvis[u] = 1;\n\t\t\t\t\tfor (register int fnt = 0; fnt < rar; ++fnt) {\n\t\t\t\t\t\tint u = q[fnt];\n\t\t\t\t\t\ttag[u] = T;\n\t\t\t\t\t\t(F[u] && a[u] < mn) && (mn = a[u]);\n\t\t\t\t\t\tfor (int &v: g[u]) {\n\t\t\t\t\t\t\tif(!vis[v] && !f[v]) {\n\t\t\t\t\t\t\t\tq[rar++] = v;\n\t\t\t\t\t\t\t\tvis[v] = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tv.push_back(std::make_pair(mn, T));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstd::sort(v.begin(), v.end());\n\t\tint sz = (int)(v.size());\n\t\t//ans = 0;\n\t\tfor (int u = 1; u <= n; ++u) {\n\t\t\tif(F[u] && !f[u]) {\n\t\t\t\tint i = sz - 1;\n\t\t\t\tif(v[i].second == tag[u]) {\n\t\t\t\t\t--i;\n\t\t\t\t}\n\t\t\t\tif(i < 0 || v[i].first <= a[u]) {\n\t\t\t\t\tans = u;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tf[ans] = 1;\n\t\tfoo[ans] = i;\n\t\tprintf(\"%d \", a[ans]);\n\t\tfor (int j = ans + 1; j <= n; ++j) {\n\t\t\tmx[j] = i;\n\t\t}\n\t\tfor (int j: has[ans]) {\n\t\t\tlst[j] = i;\n\t\t\tfor (int &k: rhas[j]) {\n\t\t\t\tF[k] |= (lst[j] >= mx[k]);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"Ofast\")\n#include <iostream>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <set>\n#include <queue>\n#define rep(x, a, b) for(int x = (a); x <= (b); ++x)\n#define rop(x, a, b) for(int x = (a); x < (b); ++x)\n#define per(x, a, b) for(int x = (a); x >= (b); --x)\nusing namespace std;\ntypedef long long LL;\ntypedef double DB;\npriority_queue<int> PQ;\nint a[2005], rd[2005];\nstruct graph {\n\tset<int> S[2005], E[2005];\n\tint vs[2005];\n\tvoid push(int x, int y) {\n\t\tS[x].insert(y);\n\t}\n\tvoid dfs(int nw) {\n\t\tvs[nw] = 1;\n\t\tauto IT = S[nw].begin();\n\t\twhile(IT != S[nw].end()) {\n\t\t\tif(vs[*IT]) {++IT; continue;}\n\t\t\t++rd[*IT];\n\t\t\tE[nw].insert(*IT);\n\t\t\tdfs(*IT);\n\t\t\t++IT;\n\t\t}\n\t}\n\tvoid tuopu() {\n\t\tPQ.push(0);\n\t\twhile(PQ.size()) {\n\t\t\tint nw = PQ.top();\n\t\t\tif(nw) printf(\"%d \", a[nw]);\n\t\t\tPQ.pop();\n\t\t\tauto IT = E[nw].begin();\n\t\t\twhile(IT != E[nw].end()) {\n\t\t\t\t--rd[*IT];\n\t\t\t\tif(rd[*IT] == 0) PQ.push(*IT);\n\t\t\t\t++IT;\n\t\t\t}\n\t\t}\n\t}\n}G;\nint n;\nint main() {\n\tscanf(\"%d\", &n);\n  sort(a + 1, a + 1 + n);\n\trep(i, 1, n) scanf(\"%d\", &a[i]);\n\trep(i, 1, n) rep(j, 1, n) if(i != j && __gcd(a[i], a[j]) != 1) G.push(i, j); \n\trep(i, 1, n) G.push(0, i), G.push(i, 0);\n\tG.dfs(0);\n\tG.tuopu();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair <int,int> pii;\n\nconst int RLEN=1<<18|1;\ninline char nc() {\n\tstatic char ibuf[RLEN],*ib,*ob;\n\t(ib==ob) && (ob=(ib=ibuf)+fread(ibuf,1,RLEN,stdin));\n\treturn (ib==ob) ? -1 : *ib++;\n}\ninline int rd() {\n\tchar ch=nc(); int i=0,f=1;\n\twhile(!isdigit(ch)) {if(ch=='-')f=-1; ch=nc();}\n\twhile(isdigit(ch)) {i=(i<<1)+(i<<3)+ch-'0'; ch=nc();}\n\treturn i*f;\n}\n\nconst int N=2e3+50;\nint n,tot,vis[N],a[N];\nvector <int> edge[N];\npriority_queue <int> q[N];\npriority_queue <pii> tq;\n\ninline void dfs(int x) {\n\tq[tot].push(-x); vis[x]=1;\n\tfor(int e=edge[x].size()-1;e>=0;e--) {\n\t\tint v=edge[x][e]; if(vis[v]) continue;\n\t\tdfs(v); \n\t}\n}\nint main() {\n\tn=rd();\n\tfor(int i=1;i<=n;i++) a[i]=rd();\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\tif(__gcd(a[i],a[j])!=1) edge[i].push_back(j), edge[j].push_back(i);\n\tfor(int i=1;i<=n;i++) if(!vis[i]) ++tot,dfs(i);\n\tfor(int i=1;i<=tot;i++) tq.push(pii(-q[i].top(),i));\n\tmemset(vis,0,sizeof(vis));\n\tfor(int i=1;i<=tot;i++) {\n\t\tint tp=q[i].top();\n\t\twhile(!q[i].empty()) q[i].pop();\n\t\tq[i].push(tp);\n\t\tvis[-tp]=1;\n\t}\n\twhile(!tq.empty()) {\n\t\tint u=tq.top().second; tq.pop();\n\t\tint p=-q[u].top(); q[u].pop();\n\t\tcout<<a[p]<<' ';\n\t\tfor(int e=edge[p].size()-1;e>=0;e--) {\n\t\t\tint v=edge[p][e]; if(vis[v]) continue;\n\t\t\tq[u].push(-v); vis[v]=1;\n\t\t}\n\t\tif(!q[u].empty()) tq.push(pii(-q[u].top(),u));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#define MN 2000\n#define ull unsigned long long\nusing namespace std;\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nstruct Bitset\n{\n\tull\ts[32];\n\tvoid Reset(){memset(s,0,sizeof(s));}\n\tBitset operator &(const Bitset&y)\n\t{\n\t\tBitset c;\n\t\tfor(int j=0;j<32;++j) c.s[j]=s[j]&y.s[j];\n\t\treturn c;\t\n\t}\n\tbool has(int y){return bool(s[y>>6]&(1ULL<<(y&63)));}\n\tvoid Mod(int y){s[y>>6]^=1ULL<<(y&63);}\n\tint lowbit()\n\t{\n\t\tfor(int j=0;j<32;++j) if(s[j])\n\t\t{\n\t\t\tull x=s[j];int pos=j*64;\n\t\t\twhile(!(x&255)) x>>=8,pos+=8;\n\t\t\tfor(int k=0;k<8;++k) if(x&(1<<k)) return pos+k;\n\t\t}\n\t\treturn -1;\t\n\t}\n}b[MN+5],to,Left;\ninline int gcd(int x,int y){return y?gcd(y,x%y):x;}\nint n,a[MN+5],head[MN+5],cnt=0,res,vis[MN+5],used[MN+5],ths[MN+5],isnear[MN+5];\nstruct edge{int to,next;}e[MN*MN*2+5];\ninline void ins(int f,int t)\n{\n\te[++cnt]=(edge){t,head[f]};head[f]=cnt;b[f].Mod(t);\n\te[++cnt]=(edge){f,head[t]};head[t]=cnt;b[t].Mod(f);\n}\nvoid Mark(int x)\n{\n\tto.Mod(x);ths[x]=0;if(isnear[x]&&a[x]<a[res]) res=x;isnear[x]=0;\n\tint low=(to&b[x]).lowbit();\n\twhile(low!=-1)\n\t{\n\t\tMark(low);\n\t\tlow=(to&b[x]).lowbit();\n\t}\n}\nvoid dfs(int x,int v)\n{\n\tvis[x]=v;if(a[x]<a[res]) res=x;\n\tfor(int i=head[x];i;i=e[i].next)\n\t\tif(vis[e[i].to]!=v&&!used[e[i].to]) dfs(e[i].to,v); \n}\nint main()\n{\n\tn=read();a[0]=int(1e9);\n\tfor(int i=1;i<=n;++i) a[i]=read(),Left.Mod(i);\n\tfor(int i=1;i<=n;++i)\n\t\tfor(int j=i+1;j<=n;++j) \n\t\t\tif(gcd(a[i],a[j])>1) ins(i,j);\n\tfor(int j=1;j<=n;++j) if(vis[j]!=n+1) \n\t\tres=0,dfs(j,n+1),ths[j]=res;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tint mx=0,from=0;\n\t\tfor(int j=1;j<=n;++j) if(!used[j]&&ths[j]&&a[ths[j]]>mx) mx=a[ths[j]],from=ths[j];\n\t\tprintf(\"%d \",mx);used[from]=1;Left.Mod(from);ths[from]=0;\n\t\tto=Left;\n\t\tfor(int j=head[from];j;j=e[j].next) isnear[e[j].to]=1;\n\t\tfor(int j=head[from];j;j=e[j].next) if(to.has(e[j].to)) res=0,Mark(e[j].to),ths[e[j].to]=res;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Relive your past life.\n//Face your demons.\n//The past is never dead,it is not even past.\n//The memories are not only the key to the past but...also to the future.\n//coded in Rusty Lake\n#include<cmath>\n#include<math.h>\n#include<ctype.h>\n#include<algorithm>\n#include<bitset>\n#include<cassert>\n#include<cctype>\n#include<cerrno>\n#include<cfloat>\n#include<ciso646>\n#include<climits>\n#include<clocale>\n#include<complex>\n#include<csetjmp>\n#include<csignal>\n#include<cstdarg>\n#include<cstddef>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<ctime>\n#include<cwchar>\n#include<cwctype>\n#include<deque>\n#include<exception>\n#include<fstream>\n#include<functional>\n#include<iomanip>\n#include<ios>\n#include<iosfwd>\n#include<iostream>\n#include<istream>\n#include<iterator>\n#include<limits>\n#include<list>\n#include<locale>\n#include<map>\n#include<memory>\n#include<new>\n#include<numeric>\n#include<ostream>\n#include<queue>\n#include<set>\n#include<sstream>\n#include<stack>\n#include<stdexcept>\n#include<streambuf>\n#include<string>\n#include<typeinfo>\n#include<utility>\n#include<valarray>\n#include<vector>\n#include<string.h>\n#include<stdlib.h>\n#include<stdio.h>\n#define ll   long long\n#define pb   push_back\n#define mp   make_pair\n#define orz  1000000007\nusing namespace std;\nint n,a[2005],cnt[2005],f[2005][2005],ans[2005],v[2005];\npriority_queue<int> q;\nvoid dfs(int x,int y){\n    v[x]=1;\n    for(int i=1;i<=n;++i){\n        if(f[x][i]){\n            if(v[i])f[x][i]=0;\n            else dfs(i,x);\n        }\n    }\n}\nint main(){\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;++i)scanf(\"%d\",a+i);\n    sort(a+1,a+n+1);\n    for(int i=1;i<n;++i){\n        for(int j=i+1;j<=n;++j)if(__gcd(a[i],a[j])>1)f[i][j]=f[j][i]=1;\n    }\n    for(int i=1;i<=n;++i)if(!v[i])dfs(i,0),q.push(i);\n    for(int i=1;i<=n;++i){\n        ans[i]=q.top();\n        q.pop();\n        for(int j=1;j<=n;++j)if(f[ans[i]][j])q.push(j);\n    }\n    for(int i=1;i<n;++i)printf(\"%d \",a[ans[i]]);\n    printf(\"%d\\n\",a[ans[n]]);\n    //system(\"pause\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <vector>\n#include <cassert>\n#include <algorithm>\nusing namespace std;\n\nconst int N = 2005;\nbool G[N][N];\nbool used[N];\nvector <int> g[N];\nint n, a[N], sz;\nint in[N];\npriority_queue <pair <int, int> > pq;\ninline int gcd(int a, int b) { return !b ? a : gcd(b, a % b); }\n\nvoid dfs(int i) {\n\tused[i] = 1;\n\tfor (int j = 0; j < n; ++ j) if (!used[j] && G[i][j]) { g[i].push_back(j); ++ in[j]; dfs(j); break; }\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; ++ i) scanf(\"%d\", &a[i]);\n\tsort(a, a + n);\n\tfor (int i = 0; i < n; ++ i) for (int j = 0; j < n; ++ j) if (i ^ j) G[i][j] = (gcd(a[i], a[j]) != 1);\n\tfor (int i = 0; i < n; ++ i) if (!used[i]) dfs(i);\n\tfor (int i = 0; i < n; ++ i) pq.push(make_pair(-in[i], i));\n\twhile (!pq.empty()) {\n\t\tpair <int, int> p = pq.top(); pq.pop();\n\t\tint i = p.second;\n\t\tif (in[i] != -p.first) continue;\n\t\tprintf(\"%d \", a[i]);\n\t\tfor (int j = 0; j < (int) g[i].size(); ++ j) {\n\t\t\t-- in[g[i][j]];\n\t\t\tpq.push(make_pair(-in[g[i][j]], g[i][j]));\n\t\t}\n\t}\n\tputs(\"\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define N 2010\ninline int read() {\n    int x=0;\n    char ch=getchar();\n    while (!isdigit(ch)) ch=getchar();\n    while (isdigit(ch)) x=x*10+ch-'0',ch=getchar();\n    return x;\n}\ninline int gcd(int x,int y) {\n    return y?gcd(y,x%y):x;\n}\nint f[N][N];\nint a[N],vis[N],ind[N];\nvector<int> v[N];\ninline void dfs(int x,int n) {\n    vis[x]=true;\n    for (int i=1;i<=n;i++) {\n        if (!f[x][i] || vis[i]) continue;\n        ind[i]++,v[x].push_back(i),dfs(i,n);\n    }\n}\ninline void Top(int n) {\n    priority_queue<int> q;\n    for (int i=1;i<=n;i++) \n        if (!ind[i]) q.push(i);\n    while (!q.empty()) {\n        int x=q.top(); q.pop();\n        printf(\"%d \",a[x]);\n        for (int i=0;i<v[x].size();i++) q.push(v[x][i]);\n    }\n}\nint main() {\n    int n=read();\n    for (int i=1;i<=n;i++) a[i]=read();\n    sort(a+1,a+n+1);\n    for (int i=1;i<=n;i++) {\n        for (int j=1;j<=n;j++) {\n            if (gcd(a[i],a[j])!=1) f[i][j]=true;\n        }\n    }\n    for (int i=1;i<=n;i++)\n        if (!vis[i]) dfs(i,n);\n    Top(n);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\n#define sf scanf\n#define pf printf\n#define pb push_back\n#define mp make_pair\n#define PI ( acos(-1.0) )\n#define mod 1000000007LL\n#define IN freopen(\"pieaters.in\",\"r\",stdin)\n#define OUT freopen(\"pieaters.out\",\"w\",stdout)\n#define FOR(i,a,b) for(i=a ; i<=b ; i++)\n#define DBG pf(\"Hi\\n\")\n#define i64 long long int\n#define eps (1e-8)\n#define xx first\n#define yy second\n#define ln 17\n#define off 2\n\nusing namespace __gnu_pbds;\nusing namespace std ;\n\ntypedef tree< i64, null_type, less<i64>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\ntypedef pair<i64, i64> pii;\n\n#define INF 2000000000\n#define alpha 26\n\n#define maxn 2010\n#define LOG 18\n\nvector <int> g[maxn] ;\nint last[maxn] , mini[maxn] ;\nint a[maxn] , vis[maxn] ;\n\nint gcd(int a, int b)\n{\n    if(b==0) return a ;\n    return gcd(b,a%b) ;\n}\nvector <int> cur ;\n\nvoid dfs(int u)\n{\n    vis[u] = 1 ;\n    cur.pb(u) ;\n    for( int v: g[u])\n    {\n        if( !vis[v] ) dfs(v) ;\n    }\n}\n\nint ans[maxn] ;\n\nint main()\n{\n    int n ;\n\n    scanf(\"%d\",&n) ;\n\n    for(int i=1 ; i<=n ; i++) scanf(\"%d\",&a[i]) ;\n\n    sort( a+1 , a+n+1 ) ;\n\n    for(int i=1 ; i<=n ; i++)\n    {\n        for(int j=i+1 ; j<=n ; j++)\n        {\n            if( gcd( a[i] , a[j] ) > 1 )\n            {\n                g[i].pb(j) ; g[j].pb(i) ;\n            }\n        }\n    }\n\n    for(int i=1 ; i<=n ; i++)\n    {\n        vector < vector <int> > vec ;\n\n        memset(vis,0,sizeof(vis)) ;\n\n        for(int j=1 ; j<i ; j++) vis[ ans[j] ] = 1 ;\n\n        for(int j=1 ; j<=n ; j++)\n        {\n            if( !vis[j] )\n            {\n                cur.clear() ;\n                dfs(j) ;\n                sort( cur.begin() , cur.end() ) ;\n                vec.pb(cur) ;\n            }\n        }\n\n        mini[i] = INF ;\n\n        multiset <int> ms ;\n\n        ms.insert( -INF ) ;\n\n        vector < pair<int,int> > eligible ;\n\n        for(int j=0 ; j<vec.size() ; j++)\n        {\n            ms.insert( a[vec[j][0]] ) ;\n        }\n\n        for(int j=0 ; j<vec.size() ; j++)\n        {\n            ms.erase( ms.find(a[vec[j][0]]) ) ;\n            for(int k=0 ; k<vec[j].size() ; k++)\n            {\n                int fl1 = 0 , fl2 = 0 ;\n\n                if( mini[ last[ vec[j][k] ] + 1 ] > a[ vec[j][k] ] ) fl1 = 1 ;\n\n                auto it = ms.end() ;\n                it-- ;\n\n                if( (*it) <= a[ vec[j][k] ] ) fl2 = 1 ;\n\n                if(fl1&fl2) eligible.pb( mp( a[vec[j][k] ] , vec[j][k] ) ) ;\n            }\n            ms.insert( a[vec[j][0]] ) ;\n        }\n        sort( eligible.begin() , eligible.end() ) ;\n\n        ans[i] = eligible[0].yy ;\n        mini[i] = a[ ans[i] ] ;\n        for(int j=i-1 ; j>=1 ; j-- ) mini[j] = min( a[ ans[j] ] , mini[j+1] ) ;\n        for(int j=0 ; j<g[ ans[i] ].size() ; j++) last[ g[ ans[i] ][j] ] = i ;\n\n     //   printf(\"%d\\n\",a[ans[i]]) ;\n    }\n\n    for(int i=1 ; i<=n ; i++) printf(\"%d \",a[ans[i]] ) ;\n    printf(\"\\n\") ;\n\n    return 0 ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint Eulg(int a, int b);\n\nint main(int argc, char *argv[]){\n\n\tint N;\n\tcin>>N;\n\n\tint *a = new int[N]();\n\n\tfor(int i=0; i<N; i++){\n\t\tcin>>a[i];\n\t}\n\n\tsort(a, a+N);\n\n\tbool flag = true;\n\twhile(flag){\n\tfor(int i=0; i<N; i++){\n\t\tfor(int j=i+1; j<N; j++){\n\t\t\tif(Eulg(a[i], a[j]) == 1){\n\t\t\t\tif(a[i]<a[j]){\n\t\t\t\t\tint tmp;\n\t\t\t\t\ttmp =a[i];\n\t\t\t\t\ta[i] = b[i];\n\t\t\t\t\tb[i] = tmp;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t}\n}\n\nfor(int i=0; i<N; i++)\n\tcout<<a[i]<<\"  \";\n\n\n\n\tdelete[] a;\n\treturn 0;\n}\n\nint Eulg(int a, int b){\n\tif(a<b){\n\t\tint tmp;\n\t\ttmp =a;\n\t\ta = b;\n\t\tb = tmp;\n\t}\n\n\tint r;\n\tr = a % b;\n\twhile(r){\n\t\ta = b;\n\t\tb = r;\n\t\tr = a % b;\n\t}\n\treturn b;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\n\nconst int INF = 1 << 30;\n\nvector< int > g[2000];\nint N, A[2000];\nbool v[2000];\nvector< int > ord;\n\nvoid dfs(int idx) {\n  v[idx] = true;\n  ord.emplace_back(A[idx]);\n  for(int i = 0; i < N; i++) {\n    if(v[i]) continue;\n    if(__gcd(A[i], A[idx]) == 1) continue;\n    dfs(i);\n  }\n}\n\nint main() {\n  cin >> N;\n  for(int i = 0; i < N; i++) cin >> A[i];\n  sort(A, A + N);\n  for(int i = 0; i < N; i++) {\n    if(!v[i]) dfs(i);\n  }\n  for(int i = 0; i < N; i++) {\n    for(int j = i + 1; j < N; j++) {\n      if(__gcd(ord[i], ord[j]) != 1) {\n        g[i].emplace_back(j);\n      }\n    }\n  }\n  vector< int > deg(N);\n  for(int i = 0; i < N; i++) for(int j : g[i]) ++deg[j];\n  priority_queue< int > que;\n  for(int i = 0; i < N; i++) if(deg[i] == 0) que.emplace(i);\n  vector< int > ord2;\n  while(que.size()) {\n    auto p = que.top();\n    que.pop();\n    ord2.emplace_back(p);\n    for(auto to : g[p]) {\n      if(--deg[to] == 0) que.emplace(to);\n    }\n  }\n\n  for(int i = 0; i < N; i++) cout << ord[ord2[i]] << \" \";\n  cout << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <vector>\n#include <map>\n#include <set>\n\nusing namespace std;\n\ntypedef pair<int , int> P2;\ntypedef pair<pair<int , int> , int> P3;\ntypedef pair<pair<int , int> , pair<int , int> > P4;\n#define Fst first\n#define Snd second\n#define PB(a) push_back(a)\n#define MP(a , b) make_pair((a) , (b))\n#define M3P(a , b , c) make_pair(make_pair((a) , (b)) , (c))\n#define M4P(a , b , c , d) make_pair(make_pair((a) , (b)) , make_pair((c) , (d)))\n#define repp(i,a,b) for(int i = (int)(a) ; i < (int)(b) ; ++i)\n#define repm(i,a,b) for(int i = (int)(a) ; i > (int)(b) ; --i)\n#define repv(t,it,v) for(vector<t>::iterator it = v.begin() ; it != v.end() ; ++it)\n\nint N;\nint A[2017];\nbool e[2017][2017];\nbool b[2017];\n\nint gcd(int x , int y){\n\treturn y > 0 ? gcd(y,x%y) : x;\n}\n\nvector<int> mer(vector<int> &S , vector<int> &T){\n\tvector<int> V;\n\tint i = 0 , j = 0;\n\twhile(i != (int)S.size() || j != (int)T.size()){\n\t\tif(i == (int)S.size()) V.PB(T[j++]);\n\t\telse if(j == (int)T.size()) V.PB(S[i++]);\n\t\telse V.PB(A[S[i]] > A[T[j]] ? S[i++] : T[j++]);\n\t}\n\treturn V;\n}\n\nvector<int> func(int k){\n\tvector<int> V;\n\tb[k] = 1;\n\trepp(i,0,N){\n\t\tif(!e[k][i] || b[i]) continue;\n\t\tV = mer(V,func(i));\n\t}\n\tV.insert(V.begin(),k);\n\treturn V;\n}\n\nint main(){\n\tscanf(\"%d\" , &N);\n\trepp(i,0,N){\n\t\tscanf(\"%d\" , A + i);\n\t}\n\tsort(A,A+N);\n\trepp(i,0,N){\n\t\trepp(j,i+1,N){\n\t\t\tif(gcd(A[i],A[j]) > 1){\n\t\t\t\te[i][j] = e[j][i] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tvector<int> V;\n\trepp(i,0,N){\n\t\tif(b[i]) continue;\n\t\tV = mer(V,func(i));\n\t}\n\trepp(i,0,N){\n\t\tprintf(\"%d%c\" , A[V[i]] , i+1==N ? '\\n' : ' ');\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nint n,tot,a[2010],in[2010],head[2010],nxt[10010],to[10010];\nbool vis[2010];\ninline int gcd(int a,int b){\n\treturn b?gcd(b,a%b):a;\n}\ninline void add_edge(int u,int v){\n\tnxt[++tot]=head[u];\n\tto[tot]=v;\n\thead[u]=tot;\n\treturn;\n}\nvoid dfs(int u){\n\tvis[u]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tif(!vis[i]&&gcd(a[u],a[i])!=1){\n\t\t\tadd_edge(u,i);\n\t\t\tin[i]++;\n\t\t\tdfs(i);\n\t\t}\n\treturn;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",a+i);\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++)\n\t\tif(!vis[i])\n\t\t\tdfs(i);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=n;j;j--)\n\t\t\tif(!in[j]){\n\t\t\t\tprintf(\"%d \",a[j]);\n\t\t\t\tfor(int k=head[j];k;k=nxt[k])\n\t\t\t\t\tin[to[k]]--;\n\t\t\t\tin[j]=-1;\n\t\t\t\tbreak;\n\t\t\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n\nconst int maxn = 2010;\n\nint N;\nint A[maxn];\nbool us[maxn], vis[maxn];\n\nvoid dfs(int v, vi &vec, vi &cmp) {\n\tvis[v] = 1;\n\tcmp.pb(v);\n\n\tfor (int to : vec) {\n\t\tif (!vis[to] && __gcd(A[v], A[to]) != 1) {\n\t\t\tdfs(to, vec, cmp);\n\t\t}\n\t}\n}\n\nvi merge(vi va, vi vb) {\n\tvi res;\n\tint tm = va.size() + vb.size();\n\tva.pb(-1);\n\tvb.pb(-1);\n\n\tint i1 = 0, i2 = 0;\n\n\trep(i, tm) {\n\t\tif (va[i1] > vb[i2]) {\n\t\t\tres.pb(va[i1++]);\n\t\t} else {\n\t\t\tres.pb(vb[i2++]);\n\t\t}\n\t}\n\n\treturn res;\n}\n\nvi decide(int ban, vi cand) {\n\tvi res;\n\tvector<vi> cmps;\n\n\tint mini = 10000;\n\tint piv = -1;\n\n\tfor (int t : cand) {\n\t\tvis[t] = 0;\n\t\tif (ban == 0 || __gcd(A[t], ban) != 1) {\n\t\t\tif (mini > A[t]) {\n\t\t\t\tmini = A[t];\n\t\t\t\tpiv = t;\n\t\t\t}\n\t\t}\n\t}\n\n\tvi nx;\n\tfor (int t : cand) if (t != piv) {\n\t\tnx.pb(t);\n\t}\n\n\tvi cmp(N);\n\n\tfor (int t : nx) if (!cmp[t]) {\n\t\tvi vec;\n\t\tdfs(t, nx, vec);\n\t\tfor (int i : vec) cmp[i] = 1;\n\t\tvi sub = decide(mini, vec);\n\t\tres = merge(res, sub);\n\t}\n\n\tres.insert(res.begin(), mini);\n\n\treturn res;\n}\n\nint main() {\n\tcin >> N;\n\trep(i, N) cin >> A[i];\n\tvector<vi> vec;\n\tvi vx;\n\trep(i, N) vx.pb(i);\n\n\trep(i, N) {\n\t\tif (!us[i]) {\n\t\t\tvi v;\n\t\t\tdfs(i, vx, v);\n\t\t\tfor (int a : v) us[a] = 1;\n\t\t\tvec.pb(decide(0, v));\n\t\t}\n\t}\n\n\tvi ans;\n\tfor (auto v : vec) {\n\t\tans = merge(ans, v);\n\t}\n\n\trep(i, N) printf(\"%d%c\", ans[i], i == N - 1 ? '\\n' : ' ');\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair <int,int> pii;\ntypedef queue <int> Que;\n\nconst int RLEN=1<<18|1;\ninline char nc() {\n\tstatic char ibuf[RLEN],*ib,*ob;\n\t(ib==ob) && (ob=(ib=ibuf)+fread(ibuf,1,RLEN,stdin));\n\treturn (ib==ob) ? -1 : *ib++;\n}\ninline int rd() {\n\tchar ch=nc(); int i=0,f=1;\n\twhile(!isdigit(ch)) {if(ch=='-')f=-1; ch=nc();}\n\twhile(isdigit(ch)) {i=(i<<1)+(i<<3)+ch-'0'; ch=nc();}\n\treturn i*f;\n}\n\nconst int N=2e3+50;\nint n,vis[N],a[N];\nvector <int> edge[N];\n\ninline Que dfs(int x) {\n\tvis[x]=1;\n\tvector <Que> q;\n\tpriority_queue <pii> q2;\n\t\n\tfor(int e=0;e<edge[x].size();e++) {\n\t\tint v=edge[x][e]; if(vis[v]) continue;\n\t\tq.push_back(dfs(v));\n\t}\n\t\n\tQue now; now.push(x);\n\tfor(int i=0;i<q.size();++i) q2.push(pii(q[i].front(),i));\n\t\n\twhile(!q2.empty()) {\n\t\tint u=q2.top().second; q2.pop();\n\t\tnow.push(q[u].front());\n\t\tq[u].pop();\n\t\tif(!q[u].empty()) q2.push(pii(q[u].front(),u));\n \t}\n \t\n \treturn now;\n}\nint main() {\n\tn=rd();\n\tfor(int i=1;i<=n;i++) a[i]=rd();\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\tif(__gcd(a[i],a[j])!=1) edge[i].push_back(j), edge[j].push_back(i);\n\tfor(int i=1;i<=n;i++) sort(edge[i].begin(),edge[i].end()), edge[0].push_back(i);\n\tQue tq=dfs(0);\n\twhile(!tq.empty()) {\n\t\tint u=tq.front(); tq.pop();\n\t\tif(u) cout<<a[u]<<' ';\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n,a[2005],V;\nvector<int>edge[2005];\nbool used[2005][2005],ex[2005][2005];\nint in[2005];\nvector<int>nxt;\nP q;\nvoid dfs(int v){\n\tif(used[V][v]) return; used[V][v] = 1;\n\tnxt.pb(v);\n\trep(i,edge[v].size()){\n\t\tif(used[V][edge[v][i]] || in[edge[v][i]] != V) continue;\n\t\tdfs(edge[v][i]);\n\t}\n}\nvector<int>mer(vector<int>ret,vector<int>hoge){\n\t\tint c = ret.size(),b = hoge.size();\n\t\tint i = 0,j = 0;\n\t\tvector<int>ret2; ret2.resize(c+b); int nxt = 0;\n\t\twhile(i!=c || j!=b){\n\t\t\tif(i==c) ret2[nxt++] = (hoge[j++]);\n\t\t\telse if(j==b) ret2[nxt++] = (ret[i++]);\n\t\t\telse{\n\t\t\t\tif(a[ret[i]] > a[hoge[j]]) ret2[nxt++] = (ret[i++]);\n\t\t\t\telse ret2[nxt++] = (hoge[j++]);\n\t\t\t}\n\t\t}\n\t\treturn ret2;\n}\nvector<int>make(vector<int>L,int cut){\n\tvector<int>ret;\n\tif(L.size() == 1){\n\t\tret.pb(cut); return ret;\n\t}\n\trep(i,L.size()){\n\t\tif(L[i] != cut){\n\t\t    in[L[i]] = cut;\n\t\t}\n\t}\n\tvector<pair<vector<int>,int> >vv;\n\trep(i,L.size()){\n\t\tif(L[i] == cut) continue;\n\t\tif(!used[cut][L[i]]){\n\t\t\tnxt.clear(); q = mp(INF,INF);\n\t\t\tV = cut; dfs(L[i]);\n\t\t\trep(j,nxt.size()){\n\t\t\t\tif(ex[nxt[j]][cut]){\n\t\t\t\t\tq = min(q,mp(a[nxt[j]],nxt[j]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tvv.pb(mp(nxt,q.sc));\n\t\t}\n\t}\n\trep(ii,vv.size()){\n\t\tvector<int>&nxt = vv[ii].fi; int Q = vv[ii].sc;\n\t\tvector<int>hoge;\n\t\tif(nxt.size() > 1) hoge = make(nxt,Q); else hoge = nxt;\n\t\tret = mer(ret,hoge);\n\t}\n\tret.insert(ret.begin(),cut);\n\treturn ret;\n}\nbool U[2005];\nvector<int>vi;\nP p;\nvoid DFS(int x){\n\tif(U[x]) return; U[x] = 1;\n\tvi.pb(x); p = min(p,mp(a[x],x));\n\trep(i,edge[x].size()){\n\t\tDFS(edge[x][i]);\n\t}\n}\nvector<int>res;\nint main(){\n\tcin>>n; \n\trepn(i,n){\n\t    cin>>a[i];\n\t}\n\tsort(a+1,a+n+1);\n\trepn(i,n) repn(j,n){\n\t\tif(i != j && __gcd(a[i],a[j]) > 1){\n\t\t\tedge[i].pb(j); ex[i][j] = 1;\n\t\t}\n\t}\n\trepn(i,n){\n\t\tif(U[i]) continue; p = mp(INF,INF); vi.clear();\n\t\tDFS(i);\n\t\tvector<int>vec = make(vi,p.sc);\n\t\tres = mer(res,vec);\n\t}\n\trep(i,n) cout<<a[res[i]]<<\" \";\n\tcout<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=5e6+5;\nint n,now,a[N],b[N],v[N],nex[N],head[N],_head[N];\nint gcd(int x,int y){\n\twhile(y){\n\t\tint t=y;\n\t\ty=x%y,x=t;\n\t}\n\treturn x;\n}\nbool vis[N];\npriority_queue<int>que;\nvoid add(int x,int y){\n\tnex[++now]=head[x];\n\thead[x]=now,v[now]=y;\n}\nvoid _add(int x,int y){\n\tnex[++now]=_head[x];\n\t_head[x]=now,v[now]=y;\n}\nvoid dfs(int x){\n\tvis[x]=1;\n\tfor(int i=head[x];i;i=nex[i])\n\t\tif(!vis[v[i]]){\n\t\t\t_add(x,v[i]),++b[v[i]];\n\t\t\tdfs(v[i]);\n\t\t}\n}\nint main(){\n\t//freopen(\"rearranging.in\",\"r\",stdin);\n\t//freopen(\"rearranging.out\",\"w\",stdout);\n\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\tscanf(\"%d\",&a[i]);\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=n;j;j--)\n\t\t\tif(gcd(a[i],a[j])!=1) add(i,j);\n\tfor(int i=1;i<=n;i++){\n\t\tif(!vis[i]){\n\t\t\tdfs(i);\n\t\t\tque.push(i);\n\t\t}\n\t}\n\twhile(!que.empty()){\n\t\tint x=que.top();\n\t\tque.pop(),printf(\"%d \",a[x]);\n\t\tfor(int i=_head[x];i;i=nex[i])\n\t\t\tif(!(--b[v[i]]))\tque.push(v[i]);\n\t}\n\tputchar('\\n');\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\nconst int N = 2005;\nint n, a[N], b[N], c[N], used[N], g[N][N];\ninline int gcd(int a, int b) { return !b ? a : gcd(b, a % b); }\ninline void swap(int &a, int &b) { int tmp = a; a = b; b = tmp; }\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; ++ i) {\n\t\tscanf(\"%d\", &a[i]);\n\t\tc[i] = a[i];\n\t}\n\tstd :: sort(c, c + n);\n\tfor (int i = 0; i < n; ++ i)\n\t\tfor (int j = 0; j < n; ++ j) if (i ^ j) {\n\t\t\tg[i][j] = gcd(a[i], a[j]) != 1;\n\t\t}\n\tint mn = 0;\n\tfor (int i = 0; i < n; ++ i) {\n\t\tif (a[i] < a[mn]) mn = i;\n\t}\n\tb[0] = mn;\n\tfor (int i = 0; i + 1 < n; ++ i) {\n\t\tused[b[i]] = 1;\n\t\tmn = -1;\n\t\tfor (int j = 0; j < n; ++ j) if (!used[j] && g[b[i]][j] && (!~mn || a[j] < a[mn])) mn = j;\n\t\tif (!~mn) for (int j = 0; j < n; ++ j) if (!used[j] && (!~mn || a[j] < a[mn])) mn = j;\n\t\tb[i + 1] = mn;\n\t}\n\tfor (int i = 0; i < n; ++ i) {\n\t\tint pos = -1;\n\t\tfor (int j = 0; j < n; ++ j) if (a[b[j]] == c[i]) pos = j;\n\t\tfor (int j = pos; j; -- j) {\n\t\t\tif (g[b[j - 1]][b[j]]) break;\n\t\t\tswap(b[j - 1], b[j]);\n\t\t}\n\t}\n\tfor (int i = 0; i < n; ++ i) printf(\"%d%c\", a[b[i]], \" \\n\"[i + 1 == n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint n,a[2100];\nint vis[2100],flag[2100][2100],ind[2100];\npriority_queue<int> que;\nvector<int> vec[2100];\ninline int gcd(int a,int b){\n\tif (!b) return a;\n\treturn gcd(b,a%b);\n}\nvoid dfs(int u){\n    vis[u]=true;\n    for (int i=1;i<=n;i++)\n\t    if (!vis[i]&&flag[u][i]){\n\t        ind[i]++;\n\t        vec[u].push_back(i);\n\t        dfs(i);\n\t    }\n}\nvoid bfs(){\n    for (int i=1;i<=n;i++)\n\t\tif (!ind[i]) que.push(i);\n    while (!que.empty()){\n        int u=que.top(); que.pop();\n        printf(\"%d \",a[u]);\n        for (int i=0;i<(int)vec[u].size();i++) que.push(vec[u][i]);\n    }\n}\nint main(){\n    scanf(\"%d\",&n);\n    for (int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n    sort(a+1,a+n+1);\n    for (int i=1;i<=n;i++)\n\t    for (int j=i+1;j<=n;j++)\n    \t\tif (gcd(a[i],a[j])!=1)\n\t\t\t\tflag[i][j]=flag[j][i]=1;\n    for (int i=1;i<=n;i++)\n\t\tif (!vis[i]) dfs(i);\n\tbfs();\n    return 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<typename T> \nmap<T, Int> factorize(T x){\n  map<T, Int> res;\n  for(Int i=2;i*i<=x;i++){\n    while(x%i==0){\n      x/=i;\n      res[i]++;\n    }\n  }\n  if(x!=1) res[x]++;\n  return res;\n}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<Int> a(n);\n  for(Int i=0;i<n;i++) cin>>a[i];\n  sort(a.begin(),a.end());\n\n  vector<Int> ans(n);\n\n  Int m=0;\n  map<Int, Int> r;\n\n  vector<vector<Int> > G(n);\n  for(Int i=0;i<n;i++){\n    auto x=factorize(a[i]);\n    for(auto p:x){\n      if(!r.count(p.first)) r[p.first]=m++,G.emplace_back();\n      G[i].emplace_back(n+r[p.first]);\n      G[n+r[p.first]].emplace_back(i);\n    }\n  }\n  \n  vector<Int> used(n+m,0),post(n,0);\n  for(Int t=0;t<n;t++){\n    vector<Int> cs(n+m,-1);\n    Int color=0;\n    for(Int i=0;i<n+m;i++){\n      if(used[i]||~cs[i]) continue;\n      queue<Int> q;\n      cs[i]=color;\n      q.emplace(i);\n      while(!q.empty()){\n\tInt v=q.front();q.pop();\n\tfor(Int u:G[v]){\n\t  if(used[u]||~cs[u]) continue;\n\t  cs[u]=color;\n\t  q.emplace(u);\n\t}\n      }\n      color++;\n    }\n    \n    Int idx=-1;\n    for(Int i=0;i<n;i++){\n      if(used[i]||post[i]) continue;\n      idx=i;\n      break;\n    }\n    \n    used[idx]=1;\n    ans[t]=idx;\n    \n    for(Int i=0;i<n;i++){\n      if(cs[idx]!=cs[i]) continue;\n      post[i]=__gcd(a[idx],a[i])<=1;\n    }\n  }\n\n  vector<Int> b(n);\n  for(Int i=0;i<n;i++) b[i]=a[ans[i]];\n  \n  vector<vector<Int> > H(n);\n  for(Int i=0;i<n;i++)\n    for(Int j=i+1;j<n;j++)\n      if(__gcd(b[i],b[j])>1) H[i].emplace_back(j);\n\n  vector<Int> indeg(n);\n  for(Int i=0;i<n;i++)\n    for(Int j:H[i]) indeg[j]++;\n  \n  using P = pair<Int, Int>;\n  priority_queue<P> pq;\n  for(Int i=0;i<n;i++)\n    if(!indeg[i]) pq.emplace(b[i],i);\n\n  vector<Int> c;\n  while(!pq.empty()){\n    P p=pq.top();pq.pop();\n    c.emplace_back(p.first);\n    for(Int u:H[p.second]){\n      indeg[u]--;\n      if(!indeg[u]) pq.emplace(b[u],u);\n    }\n  }\n  \n  for(Int i=0;i<n;i++){\n    if(i) cout<<\" \";\n    cout<<c[i];\n  }\n  cout<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\ncat <<EOF >mistaken-paste\n*/\n\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <time.h>\n\n#define BIG 2000000007\n#define VERYBIG 2000000000000007LL\n\n#define MOD 1000000007\n#define FOD  998244353\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\n#define N_MAX 1000000\n#define M_MAX 200000\n\n#ifdef __cplusplus\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <array>\n\nusing std::queue;\nusing std::priority_queue;\nusing std::stack;\nusing std::tuple;\nusing std::set;\nusing std::map;\nusing std::vector;\nusing std::greater;\nusing std::pair;\nusing std::string;\n\n#endif\n\ntypedef struct {\n\tint32_t a;\n\tint32_t b;\n} hw;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n} hwll;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n\tsll c;\n} hwllc;\n\ntypedef struct {\n\thwll a;\n\thwll b;\n} linell;\n\null n, m;\null h, w;\null k;\null q;\nsll va, vb, vc, vd, ve, vf;\null ua, ub, uc, ud, ue, uf;\nlong double vra, vrb, vrc;\ndouble vda, vdb, vdc;\nchar ch, dh;\n\null umin (ull x, ull y) {\n\treturn (x < y) ? x : y;\n}\n\null umax (ull x, ull y) {\n\treturn (x > y) ? x : y;\n}\n\nsll smin (sll x, sll y) {\n\treturn (x < y) ? x : y;\n}\n\nsll smax (sll x, sll y) {\n\treturn (x > y) ? x : y;\n}\n\null gcd (ull x, ull y) {\n\tif (x < y) {\n\t\treturn gcd(y, x);\n\t} else if (y == 0) {\n\t\treturn x;\n\t} else {\n\t\treturn gcd(y, x % y);\n\t}\n}\n\null bitpow (ull a, ull x, ull modulo) {\n\tull result = 1;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tresult *= a;\n\t\t\tresult %= modulo;\n\t\t}\n\t\tx /= 2;\n\t\ta = (a * a) % modulo;\n\t}\n\treturn result;\n}\n\null divide (ull a, ull b, ull modulo) {\n\treturn (a * bitpow(b, modulo - 2, modulo)) % modulo;\n}\n\null udiff (ull a, ull b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nsll sdiff (sll a, sll b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nint bitcount (ull n) {\n\tint result = 0;\n\twhile (n) {\n\t\tif (n & 1) result++;\n\t\tn /= 2;\n\t}\n\treturn result;\n}\n\n// double distance (sll x1, sll y1, sll x2, sll y2) {\n// \tdouble xdist2, ydist2, origindist, dist;\n\n// \txdist2 = (x1 - x2) * (x1 - x2);\n// \tydist2 = (y1 - y2) * (y1 - y2);\n// \treturn sqrt(xdist2 + ydist2);\n// }\n\nint32_t pullcomp (const void *left, const void *right) {\n\tull l = *(ull*)left;\n\tull r = *(ull*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t psllcomp (const void *left, const void *right) {\n\tsll l = *(sll*)left;\n\tsll r = *(sll*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t pcharcomp (const void *left, const void *right) {\n\tchar l = *(char*)left;\n\tchar r = *(char*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t pdoublecomp (const void *left, const void *right) {\n\tdouble l = *(double*)left;\n\tdouble r = *(double*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t pstrcomp (const void *left, const void *right) {\n\tchar* l = *(char**)left;\n\tchar* r = *(char**)right;\n\n\treturn strcmp(l, r);\n}\n\nint32_t phwllABcomp (const void *left, const void *right) {\n\thwll l = *(hwll*)left;\n\thwll r = *(hwll*)right;\n\tif (l.a < r.a) {\n\t\treturn -1;\n\t}\n\tif (l.a > r.a) {\n\t\treturn +1;\n\t}\n\tif (l.b < r.b) {\n\t\treturn -1;\n\t}\n\tif (l.b > r.b) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t phwllREVcomp (const void *left, const void *right) {\n\thwll l = *(hwll*)left;\n\thwll r = *(hwll*)right;\n\tif (l.b < r.b) {\n\t\treturn -1;\n\t}\n\tif (l.b > r.b) {\n\t\treturn +1;\n\t}\n\tif (l.a < r.a) {\n\t\treturn -1;\n\t}\n\tif (l.a > r.a) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t ptriplecomp (const void *left, const void *right) {\n\thwllc l = *(hwllc*)left;\n\thwllc r = *(hwllc*)right;\n\n\tif (l.a < r.a) {\n\t\treturn -1;\n\t}\n\tif (l.a > r.a) {\n\t\treturn +1;\n\t}\n\tif (l.b < r.b) {\n\t\treturn -1;\n\t}\n\tif (l.b > r.b) {\n\t\treturn +1;\n\t}\n\tif (l.c < r.c) {\n\t\treturn -1;\n\t}\n\tif (l.c > r.c) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nbool isinrange (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right);\n}\n\nbool isinrange_soft (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right) || (left >= x && x >= right);\n}\n\nsll a[N_MAX];\n// sll a[3001][3001];\nsll b[N_MAX];\n// sll b[3001][3001];\nsll c[N_MAX];\n// sll d[N_MAX];\n// sll e[N_MAX];\nchar s[N_MAX + 1];\n// char s[3010][3010];\nchar t[N_MAX + 1];\n// char t[3010][3010];\n// hwll xy[N_MAX];\n// sll table[1000][1000];\n\nset<ull> g[2002];\nbool iscoprime[2002][2002];\n\null iswatched[2002];\null labels[2002];\null id = 0;\nvoid toggle (ull v, ull x) {\n\tif (iswatched[v] == x) return;\n\n\tiswatched[v] = x;\n\tlabels[v] = id;\n\tfor (ull u : g[v]) {\n\t\ttoggle(u, x);\n\t}\n}\n\ntypedef pair<ull, ull> P;\nvector<ull> merge(vector<vector<ull>> x) {\n\tvector<ull> v;\n\n\tull curr[x.size()];\n\tpriority_queue<P, vector<P> > que;\n\tfor (ull i = 0; i < x.size(); i++) {\n\t\tcurr[i] = 0;\n\t\tque.push(P(x[i][0], i));\n\t}\n\twhile (!que.empty()) {\n\t\tP p = que.top();\n\t\tque.pop();\n\n\t\tv.push_back(p.first);\n\t\tull i = p.second;\n\t\tif (++curr[i] < x[i].size()) {\n\t\t\tque.push(P(x[i][curr[i]], i));\n\t\t}\n\t}\n\n\treturn v;\n}\n\nvector<ull> func (ull v) {\n\tvector<ull> r;\n\t\n\tpriority_queue<ull, vector<ull>, greater<ull> > que;\n\ttoggle(v, 0);\n\tfor (ull u : g[v]) {\n\t\tg[u].erase(v);\n\t\tque.push(u);\n\t}\n\n\tvector<vector<ull>> vs;\n\twhile (!que.empty()) {\n\t\tull u = que.top();\n\t\tque.pop();\n\t\tif (iswatched[u]) continue;\n\n\t\ttoggle(u, 1);\n\t\tvs.push_back(func(u));\n\t}\n\tiswatched[v] = 1;\n\n\tr = merge(vs);\n\tr.insert(r.begin(), v);\n\n\treturn r;\n}\n\null solve () {\n\tsll i, j, ki, li;\n\tull result = 0;\n\t// sll result = 0;\n\tdouble dresult = 0;\n\t// ull maybe = 0;\n\tsll maybe = 0;\n\t// ull sum = 0;\n\tsll sum = 0;\n\tsll item;\n\tull *dpcell;\n\n\tqsort(a, n, sizeof(ull), pullcomp);\n\n\tfor (i = 0; i < n; i++) {\n\t\tfor (j = 0; j < n; j++) {\n\t\t\tif (i != j && gcd(a[i], a[j]) > 1) {\n\t\t\t\tg[i].insert(j);\n\t\t\t}\n\t\t}\n\t}\n\treturn 1;\n\n\tvector<vector<ull>> finals;\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (iswatched[i]) continue;\n\n\t\ttoggle(i, 1);\n\t\tfinals.push_back(func(i));\n\t\t// for (j = 0; j < finals[finals.size() - 1].size(); j++) printf(\"%llu \", finals[finals.size() - 1][j]);\n\t\t// \tputs(\"\");\n\t\t// fflush(stdout);\n\t}\n\tvector<ull> r = merge(finals);\n\tfor (i = 0; i < n; i++) {\n\t\tprintf(\"%llu%c\", a[r[i]], (i == n - 1 ? '\\n' : ' '));\n\t}\n\n\t// printf(\"%lld\\n\", result);\n\t// printf(\"%.15lf\\n\", dresult);\n\t// puts(s);\n\n\treturn 0;\n\n\tsuccess:\n\t// puts(\"YES\");\n\tputs(\"Yes\");\n\t// printf(\"%llu\\n\", result);\n\t// puts(\"0\");\n\t// puts(\"Yay!\");\n\treturn 0;\n\n\tfail:\n\t// puts(\"NO\");\n\tputs(\"No\");\n\t// puts(\"0\");\n\t// puts(\"-1\");\n\t// puts(\"-1 -1 -1\");\n\t// puts(\":(\");\n\treturn 1;\n}\n\nint32_t main (void) {\n\tint32_t i, j;\n\tint32_t x, y;\n\n\tscanf(\"%llu\", &n, &m);\n\t// scanf(\"%llu\", &k, &n, &m);\n\t// scanf(\"%llu%llu\", &h, &w);\n\t// scanf(\"%lld\", &va, &vb, &vc, &vd);\n\t// scanf(\"%llu%llu\", &ua, &ub, &uc, &ud);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%s\", s);\n\t// scanf(\"%s\", t);\n\tfor (i = 0; i < n; i++) {\n\t\t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t\tscanf(\"%lld\", &a[i]);\n\t\t// scanf(\"%lld\", &b[i]);\n\t\t// scanf(\"%lld\", &c[i]);\n\t\t// scanf(\"%lld\", &d[i]);\n\t\t// a[i]--;\n\t\t// b[i]--;\n\t\t// c[i]--;\n\t}\n\t// scanf(\"%llu\", &m, &k);\n\t// scanf(\"%llu\", &q);\n\t// for (i = 0; i < n; i++) {\n\t// \tscanf(\"%lld\", &b[i]);\n\t// }\n\n\t// for (i = 0; i < h; i++) {\n\t// \tfor (j = 0; j < w; j++) {\n\t// \t\tscanf(\"%llu\", &table[i][j]);\n\t// \t}\n\t// }\n\t// for (i = 0; i < h; i++) {\n\t// \tscanf(\"%s\", &s[i]);\n\t// }\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint gcd(int a,int b)\n{\n\tif (b==0) return a;\n\treturn gcd(b,a%b);\n}\nint a[2001];\nint main()\n{\n\tint i,j,k,l,m,n;\n\tcin>>n;\n\tfor (i=1;i<=n;i++)\n\t{\n\t\tcin>>a[i];\n\t}\n\tsort(a+1,a+1+n);\n\tk=1;\n\tfor (i=1;i<n;i++)\n\t{\n\t\tif (gcd(a[i],a[i+1])==1)\n\t\t{\n\t\t\tif (a[i]<a[i+1])\n\t\t\t{\n\t\t\t\tk=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (k==1)\n\t{\n\t\tfor (i=1;i<=n;i++) cout<<a[i];\n\t\treturn 0;\n\t}\n\twhile (next_permutation(a+1,a+1+n))\n\t{\n\t\t\n\t\tk=1;\n\tfor (i=1;i<n;i++)\n\t{\n\t\tif (gcd(a[i],a[i+1])==1)\n\t\t{\n\t\t\tif (a[i]<a[i+1])\n\t\t\t{\n\t\t\t\tk=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (k==1)\n\t{\n\t\tfor (i=1;i<=n;i++) cout<<a[i];\n\t\treturn 0;\n\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <deque>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <vector>\n\n#define FOR(i,k,n) for (int (i)=(k); (i)<(n); ++(i))\n#define rep(i,n) FOR(i,0,n)\n#define pb push_back\n#define all(v) begin(v), end(v)\n#define debug(x) cerr<< #x <<\": \"<<x<<endl\n#define debug2(x,y) cerr<< #x <<\": \"<< x <<\", \"<< #y <<\": \"<< y <<endl\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll> > vvll;\ntemplate<class T> using vv=vector<vector< T > >;\n\nvi a; // number of node\nvvi g;\nvvi child;\nset<int, greater<int> > root;\ndeque<bool> reached;\n\nvoid dfs(int s) {\n  root.insert(s);\n  deque<int> st;\n  st.push_back(s);\n  reached[s] = true;\n  while (!st.empty()) {\n    int u = st.back();\n    for (int v : g[u]) {\n      if (!reached[v]) {\n        child[u].push_back(v);\n        st.push_back(v);\n        reached[v] = true;\n        st.push_back(v);\n        break;\n      }\n    }\n    if (st.back() == u) {\n      st.pop_back();\n    }\n  }\n}\n\nvi retrieve(int r) {\n  int sz = (int)child[r].size();\n  if (sz == 0) {\n    return (vi){r};\n  }\n  int ret_size = 0;\n  vvi tmp(sz);\n  rep (i, sz) {\n    tmp[i] = retrieve(child[r][i]);\n    ret_size += (int)tmp[i].size();\n  }\n  sort(all(tmp), greater<vi>());\n  vi ret;\n  ret.reserve(ret_size + 10);\n  ret.push_back(r);\n  rep (i, sz) {\n    ret.insert(end(ret), all(tmp[i]));\n  }\n  return ret;\n}\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  a.resize(n);\n  int num1 = 0;\n  rep (i, n) {\n    scanf(\"%d\", &a[i]);\n    if (a[i] == 1) {\n      num1 += 1;\n    }\n  }\n  sort(all(a));\n  /*\n  map<int, int> mp;\n  rep (i, n) {\n    mp[a[i]] += 1;\n  }\n  a.erase(unique(all(a)), end(a));\n  int sz = a.size();\n  */\n\n  g.resize(n);\n  rep (i, n) {\n    rep (j, n) {\n      if (i == j) {\n        continue;\n      }\n      if (__gcd(a[i], a[j]) == 1) {\n        continue;\n      }\n      g[i].push_back(j);\n      g[j].push_back(i);\n      uf.unite(i, j);\n      /*\n      if (a[i] <= a[j]) {\n        g[i].push_back(j);\n      }\n      if (a[i] >= b[i]) {\n        g[j].push_back(i);\n      }\n      */\n    }\n  }\n  rep (i, n) {\n    sort(all(g[i]));\n  }\n\n  // construct tree\n  child.resize(n);\n  reached.assign(n, false);\n  rep (i, n) {\n    if (reached[i]) {\n      continue;\n    }\n    if (a[i] == 1) {\n      root.insert(i);\n      reached[i] = true;\n      continue;\n    }\n    dfs(i);\n  }\n\n  for (int r : root) {\n    vi tmp = retrieve(r);\n    for (int i : tmp) {\n      printf(\"%d \", a[i]);\n    }\n  }\n  printf(\"\\n\");\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define ll long long\n#define REP(a,b,c) for(int a=b;a<=c;a++)\n#define re register\n#define file(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)\ntypedef pair<int,int> pii;\n#define mp make_pair\ninline int gi()\n{\n\tint f=1,sum=0;char ch=getchar();\n\twhile(ch>'9' || ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0' && ch<='9'){sum=(sum<<3)+(sum<<1)+ch-'0';ch=getchar();}\n\treturn f*sum;\n}\nconst int N=2010;\nint n,a[N],d[N],ans[N],vis[N];\nvector<int>G[N],g[N];\nvoid Add(int u,int v){d[v]++;g[u].push_back(v);}\nvoid dfs(int u){vis[u]=1;for(int v:G[u])if(!vis[v])Add(u,v),dfs(v);}\npriority_queue<int>q;\nint main()\n{\n\tn=gi();\n\tfor(int i=1;i<=n;i++)a[i]=gi();sort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\tif(__gcd(a[i],a[j])!=1)G[i].push_back(j),G[j].push_back(i);\n\tfor(int i=1;i<=n;i++)if(!vis[i])dfs(i);\n\tfor(int i=1;i<=n;i++)if(!d[i])q.push(i);\n\tint tot=0;\n\twhile(!q.empty())\n\t{\n\t\tint u;ans[++tot]=u=q.top();q.pop();\n\t\tfor(int v:g[u])\n\t\t\tif(!--d[v])q.push(v);\n\t}\n\tfor(int i=1;i<=n;i++)printf(\"%d%c\",a[ans[i]],i==n?'\\n':' ');\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// =================================\n//   author: M_sea\n//   website: http://m-sea-blog.com/\n// =================================\n#include <algorithm>\n#include <iostream>\n#include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#include <queue>\n#define re register\nusing namespace std;\n\ninline int read() {\n    int X=0,w=1; char c=getchar();\n    while (c<'0'||c>'9') { if (c=='-') w=-1; c=getchar(); }\n    while (c>='0'&&c<='9') X=X*10+c-'0',c=getchar();\n    return X*w;\n}\n\nconst int N=2000+10;\n\nstruct Edge { int v,nxt; } e[N];\nint head[N];\n\ninline void addEdge(int u,int v) {\n    static int cnt=0;\n    e[++cnt]=(Edge){v,head[u]},head[u]=cnt;\n}\n\nint n;\nint a[N],vis[N],deg[N];\nint G[N][N];\n\ninline void dfs(int u) {\n    vis[u]=1;\n    for (re int i=1;i<=n;++i) {\n        if (vis[i]||!G[u][i]) continue;\n        ++deg[i],addEdge(u,i);\n        dfs(i);\n    }\n}\n\ninline void topsort() {\n    priority_queue<int> Q;\n    for (re int i=1;i<=n;++i)\n        if (!deg[i]) Q.push(i);\n    while (!Q.empty()) {\n        int u=Q.top(); Q.pop();\n        printf(\"%d \",a[u]);\n        for (re int i=head[u];i;i=e[i].nxt) Q.push(e[i].v);\n    }\n}\n\nint main() {\n    n=read();\n    for (re int i=1;i<=n;++i) a[i]=read();\n    sort(a+1,a+n+1);\n    for (re int i=1;i<=n;++i)\n        for (re int j=i+1;j<=n;++j) {\n            if (__gcd(a[i],a[j])==1) continue;\n            G[i][j]=G[j][i]=1;\n        }\n    for (re int i=1;i<=n;++i)\n        if (!vis[i]) dfs(i);\n    topsort();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nconst int MAX=2005;\nvector<int> llist[MAX];\nint a[MAX],visited[MAX],n,num,used[MAX];\nint gcd(int x,int y)\n{\n\tif(x%y==0) return y;\n\telse return gcd(y,x%y);\n}\nvoid dfs(int v)\n{\n\tvisited[v]=1;\n\tllist[num].push_back(v);\n\tint u=v+1;\n\twhile(u<=n&&gcd(a[u],a[v])==1) u++;\n\tif(u<=n) dfs(u);\n}\nint main()\n{\n\tcin>>n;\n\tfor(int i=1;i<=n;++i) cin>>a[i];\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;++i){\n\t\tif(visited[i]==0){\n\t\t\tnum++;\n\t\t\tdfs(i);\n\t\t}\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\tint maximum=-1,index;\n\t\tfor(int j=1;j<=num;++j){\n\t\t\tif(used[j]<llist[j].size()&&maximum<a[llist[j][used[j]]]){\n\t\t\t\tmaximum=a[llist[j][used[j]]];\n\t\t\t\tindex=j;\n\t\t\t}\n\t\t}\n\t\tcout<<maximum<<\" \";\n\t\tused[index]++;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=2005;\nstruct edge{\n\tint to,next;\n}e[N*N/2]; \nint gcd(int x,int y){\n\treturn y?gcd(y,x%y):x;\n}\nint head[N],tot;\nint deg[N],a[N],n;\nbool vis[N];\nvoid add(int x,int y){\n\te[++tot]=(edge){y,head[x]};\n\thead[x]=tot; deg[y]++;\n}\nvoid dfs(int x){\n\tvis[x]=1;\n\tfor (int i=1;i<=n;i++)\n\t\tif (!vis[i]&&gcd(a[x],a[i])>1)\n\t\t\tadd(x,i),dfs(i);\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tsort(a+1,a+n+1);\n\tfor (int i=1;i<=n;i++)\n\t\tif (!vis[i]) dfs(i);\n\tmemset(vis,0,sizeof(vis));\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=n;j;j--)\n\t\t\tif (!vis[j]&&!deg[j]){\n\t\t\t\tvis[j]=1;\n\t\t\t\tprintf(\"%d \",a[j]);\n\t\t\t\tfor (int k=head[j];k;k=e[k].next)\n\t\t\t\t\tdeg[e[k].to]--;\n\t\t\t\tbreak;\n\t\t\t}\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pb push_back\n#define all(x) x.begin(), x.end()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nconst int N = 2000 + 10;\nconst int MOD = 1000000007;\nconst int LOG = 20;\nconst int INF = 1000000010;\nconst int delta = 11353;\n\nint n;\nvi G[N], a;\nmap<int, int> mp;\nint mark[N];\nint mark2[N], mark3[N];\n\nvoid DFS(int v){\n\tmark[v] = 1;\n\tfor (auto u:G[v]){\n\t\tif ((mark[u] == 0) && (mark3[u] == 0)){\n\t\t\tDFS(u);\n\t\t}\n\t}\n}\nint GCD(int x, int y){\n\tif (x == 0 || y == 0) return (x + y);\n\tif (x == 1 || y == 1) return 1;\n\tif (x < y) swap(x, y);\n\treturn GCD(y, x % y);\n}\n\nint32_t main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++){\n\t\tint x;\n\t\tcin >> x;\n\t\tmp[x] ++;\n\t\ta.pb(x);\n\t}\n\tsort(all(a));\n\ta.resize(unique(all(a)) - a.begin());\n\tfor (int i = 0; i < a.size(); i++) for (int j = 0; j < i; j++) if (__gcd(a[i], a[j]) != 1){\n\t\tG[i].pb(j), G[j].pb(i);\n\t}\n\t//cout << GCD(7, 11) << '\\n';\n\tvi ans;\n\tint last = 0;\n\tn = a.size();\n\tfor (int i = 0; i < n; i++){\n\t\tif (!mark[i]) DFS(i), mark2[i] = 1;\n\t}\n\tfor (int i = 0; i < n; i++){\n\t\tmemset(mark, 0, sizeof mark);\n\t\tint mx = 0;\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tif (mark2[j]) mx = j;\n\t\t//\tcout << j << ' ' << mark2[j] << '\\n';\n\t\t}\n\t\tans.pb(a[mx]);\n\t\tsort(all(G[mx]));\n\t\tmark2[mx] = 0;\n\t\tmark3[mx] = 1;\n\t\t//cout << mx << '\\n';\n\t\tfor (auto u:G[mx]){\n\t\t\tif ((mark3[u] == 0) && (mark[u] == 0)){\n\t\t\t\tmark2[u] = 1;\n\t\t\t//\tcout << u << '\\n';\n\t\t\t\tDFS(u);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < ans.size(); i++){\n\t\tint u = ans[i];\n\t\tfor (int j = 0; j < mp[u]; j++) cout << u << ' ';\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\nconst int N=100010,M=1000010,P=1e9+7;\nconst int inf=0x3f3f3f3f;\nconst int INF=0xcfcfcfcf;\nconst double eps=1e-9,pi=asin(1)*2;\ninline ll read();\n#define cmax(a,b) a=max(a,b)\n#define cmin(a,b) a=min(a,b)\ninline int ADD(int a,int b) { return a+b>=P?a+b-P:a+b; }\ninline int MINUS(int a,int b) { return a-b<0?a-b+P:a-b; }\n#define plus(a,b) a=ADD(a,b)\n#define minus(a,b) a=MINUS(a,b)\n#define mul(a,b) a=(1ll*a*(b))%P\n#define mem(a,b) memset(a,b,sizeof(a))\n#define pii pair<int,int>\n#define pil pair<int,ll>\n#define pli pair<ll,int>\n#define pll pair<ll,ll>\n#define mp(x,y) make_pair(x,y)\n\ninline int gcd(int x,int y) { return y?gcd(y,x%y):x; }\nint head[N],ver[M],nxt[M],du[N];\nint n,m,tot=1;\nint a[N];\ninline void add(int x,int y)\n{\n\tver[++tot]=y,nxt[tot]=head[x],head[x]=tot,du[y]++;\n}\n\nbool G[2010][2010];\nbool visit[N];\ninline void dfs(int x)\n{\n\tvisit[x]=true;\n\tfor(int y=1;y<=n;y++)\n\t{\n\t\tif(visit[y]||!G[x][y]) continue;\n\t\tadd(x,y);\n\t\tdfs(y);\n\t}\n}\npriority_queue<pii> q;\n\n#ifdef FILE\nconst int READ_SIZE=1<<20;\nchar buf[READ_SIZE],*p1=buf,*p2=buf;\n#define getchar() p1==p2&&(p2=(p1=buf)+fread(buf,1,READ_SIZE,stdin),p1==p2)?EOF:*p1++\n#endif\ninline ll read()\n{\n\tll s=0;\n\tbool flag=false;\n\tchar ch=getchar();\n\tfor(;ch<'0'||ch>'9';ch=getchar()) if(ch=='-') flag=true;\n\tfor(;'0'<=ch&&ch<='9';ch=getchar()) s=(s<<3)+(s<<1)+(ch^'0');\n\tif(flag) return -s;\n\treturn s;\n}\n\nint main()\n{\n#ifdef FILE\n\tfreopen(FILE \".in\",\"r\",stdin);\n\tfreopen(FILE \".out\",\"w\",stdout);\n#endif\n\tn=read();\n\tfor(int i=1;i<=n;i++) a[i]=read();\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(a[i]<a[j]&&gcd(a[i],a[j])>1)\n\t\t\t\tG[i][j]=G[j][i]=true;\n\tfor(int i=1;i<=n;i++)\n\t\tif(!visit[i]) dfs(i);\n\t\n\tfor(int i=1;i<=n;i++)\n\t\tif(!du[i]) q.push(mp(a[i],i));\n\t\n\twhile(q.size())\n\t{\n\t\tpii b=q.top();q.pop();\n\t\tprintf(\"%d \",b.first);\n\t\tint x=b.second;\n\t\tfor(int i=head[x];i;i=nxt[i])\n\t\t{\n\t\t\tint y=ver[i];\n\t\t\tdu[y]--;\n\t\t\tif(!du[y]) q.push(mp(a[y],y));\n\t\t}\n\t}\n\tputchar('\\n');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define all(x)  x.begin(), x.end()\n#define mp      make_pair\n\nvector<int> g[2020];\nint used[2020];\nvector<int> a;\nvector<int> tmp;\n\nvoid dfs(int v) {\n        used[v] = true;\n        tmp.push_back(a[v]);\n        //vector<pair<int, int>> p;\n        //for (auto u : g[v]) if (u != prev) p.emplace_back(a[u], u);\n        //sort(all(p));\n        //for (auto u : p) {\n        //        if (!used[u.second]) {\n        //                dfs(u.second, v);\n        //        }\n        //}\n        for (auto u : g[v]) if (!used[u]) {\n                dfs(u);\n        }\n}\n\nint main() {\n        int n;\n        scanf(\"%d\", &n);\n        a.resize(n);\n        for (int i = 0; i < n; i ++) scanf(\"%d\", &a[i]);\n\n        //Takahashi\n        for (int i = 0; i < n; i ++) {\n                for (int j = i + 1; j < n; j ++) {\n                        if (__gcd(a[i], a[j]) != 1) {\n                                g[i].push_back(j);\n                                g[j].push_back(i);\n                        }\n                }\n        }\n        sort(all(a));\n        for (int i = 0; i < n; i ++) {\n                if (!used[i]) {\n                        dfs(i);\n                }\n        }\n\n        for (int i = 0; i < n; i ++) {\n                int j = i;\n                for (int k = i - 1; k >= 0 && __gcd(tmp[k], tmp[i]) == 1; k --) {\n                        if (tmp[k] < tmp[i]) j = k;\n                }\n                rotate(tmp.begin() + j, tmp.begin() + i, tmp.begin() + i + 1);\n            }\n        //Aoki\n        //for (int i = 0; i < n; i ++) g[i].clear();\n        //for (int i = 0; i < n; i ++) {\n        //        for (int j = i + 1; j < n; j ++) {\n        //                if (__gcd(tmp[i], tmp[j]) != 1) {\n        //                        g[i].push_back(j);\n        //                }\n        //        }\n        //}\n        //vector<int> in_cnt(n, 0);\n        //for (int i = 0; i < n; i ++) {\n        //        for (auto u : g[i]) {\n        //                in_cnt[u] ++;\n        //        }\n        //}\n        //priority_queue<pair<int, int>> pq;\n        //for (int i = 0; i < n; i ++) if (in_cnt[i] == 0) pq.push(mp(tmp[i], i));\n        //vector<int> ans;\n        //while (!pq.empty()) {\n        //        auto get = pq.top();\n        //        pq.pop();\n        //        ans.push_back(get.first);\n        //        for (auto u : g[get.second]) {\n        //                in_cnt[u] --;\n        //                if (in_cnt[u] == 0) pq.push(mp(tmp[u], u));\n        //        }\n        //}\n        for (int i = 0; i < n; i ++) cout << tmp[i] << (i == n - 1 ? '\\n' : ' ');\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\n#include<queue>\nusing namespace std;\ninline int read(){\n\tint f=1,ans=0;char c=getchar();\n\twhile(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}\n\twhile(c>='0'&&c<='9'){ans=ans*10+c-'0';c=getchar();}\n\treturn f*ans;\n}\npriority_queue<int> que;\nconst int MAXN=2001;\nint vis[MAXN],n,a[MAXN],v[MAXN][MAXN];\nint gcd(int a,int b){\n\tif(!b) return a;\n\treturn gcd(b,a%b);\n}\nstruct node{\n\tint u,v,nex;\n}x[MAXN<<1];\nint cnt,d[MAXN],head[MAXN];\nvoid add(int u,int v){\n\tx[cnt].u=u,x[cnt].v=v,x[cnt].nex=head[u],head[u]=cnt++;\n\td[v]++;\n}\nvoid dfs(int u){\n\tvis[u]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tif(!v[u][i]) continue;\n\t\tif(vis[i]) continue;\n\t\tadd(u,i);dfs(i);\n\t}return;\n}\nint main(){\n\tmemset(head,-1,sizeof(head));\n\tn=read();\n\tfor(int i=1;i<=n;i++) a[i]=read();sort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++) if(gcd(a[i],a[j])!=1) v[i][j]=v[j][i]=1;\n\tfor(int i=1;i<=n;i++) if(!vis[i]) dfs(i);\n\tfor(int i=1;i<=n;i++) if(!d[i]) que.push(i);\n\twhile(!que.empty()){\n\t\tint xx=que.top();que.pop();\n\t\tprintf(\"%d \",a[xx]);\n\t\tfor(int i=head[xx];i!=-1;i=x[i].nex) que.push(x[i].v);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint dat[2002];\nvector<int> graph[2002];\nbool visit[2005];\nint n;\n\nint gcd(int a, int b)\n{\n\treturn b ? gcd(b, a % b) : a;\n}\n\nvector<int> merge(vector<vector<int>> vvt, int head)\n{\n\tint total = 0;\n\tfor (auto &&v : vvt) total += v.size();\n\tvector<int> ret(total + (head >= 0));\n\tint ptr = 0;\n\tif (head >= 0) ret[ptr++] = head;\n\tpriority_queue<tuple<int, int, int>> pq;\n\tfor (int i = 0; i < vvt.size(); i++)\n\t{\n\t\tpq.emplace(vvt[i][0], i, 0);\n\t}\n\twhile (pq.empty() == false)\n\t{\n\t\tint val, idx, nxt;\n\t\ttie(val, idx, nxt) = pq.top();\n\t\tpq.pop();\n\t\tret[ptr++] = val;\n\n\t\tif (nxt + 1 < vvt[idx].size())\n\t\t\tpq.emplace(vvt[idx][nxt + 1], idx, nxt + 1);\n\t}\n\treturn ret;\n}\n\nvector<int> process(int t)\n{\n\tvector<vector<int>> vvt;\n\tvisit[t] = true;\n\n\tfor (int nxt : graph[t])\n\t{\n\t\tif (visit[nxt]) continue;\n\t\tvvt.emplace_back(process(nxt));\n\t}\n\n\treturn merge(move(vvt), t);\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &dat[i]);\n\t}\n\n\tsort(dat, dat + n);\n\n\tfor (int i = 0; i < n - 1; i++)\n\t{\n\t\tfor (int j = i + 1; j < n; j++)\n\t\t{\n\t\t\tif (gcd(dat[i], dat[j]) > 1)\n\t\t\t{\n\t\t\t\tgraph[i].push_back(j);\n\t\t\t\tgraph[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) sort(graph[i].begin(), graph[i].end());\n\n\tvector<vector<int>> vvt;\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (visit[i]) continue;\n\t\tvvt.emplace_back(process(i));\n\t}\n\n\tauto ret = merge(move(vvt), -1);\n\n\tfor (int t : ret) printf(\"%d \", dat[t]);\n\tprintf(\"\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\nVI ME(const VI &a, const VI &b) {\n    VI ret; ret.reserve(a.size() + b.size());\n    int i = 0, j = 0;\n    while (i < (int)a.size() && j < (int)b.size()) {\n\tif (a[i] < b[j]) ret.push_back(b[j++]);\n\telse ret.push_back(a[i++]);\n    }\n    ret.insert(ret.end(), a.begin()+i, a.end());\n    ret.insert(ret.end(), b.begin()+j, b.end());\n    return ret;\n}\n\nint N;\nint A[2011];\nbool use[2011];\n\nVI F[2011];\nVI R[200011];\nVI P;\n\nint D[200011], cnt;\nVI rec(int s, int last) {\n    if (A[s] == 1) {\n\tuse[s] = true;\n\treturn { 1 };\n    }\n\n    VI vs;\n    cnt++;\n    vs.push_back(s);\n    for (int i=0; i<(int)vs.size(); i++) {\n\tint v = vs[i];\n\tEACH (e, F[v]) if (D[*e] != cnt) {\n\t    D[*e] = cnt;\n\t    EACH (f, R[*e]) if (!use[*f]) {\n\t\tvs.push_back(*f);\n\t    }\n\t}\n    }\n\n    int pick = -1;\n    EACH (e, vs) if (__gcd(last, A[*e]) > 1) {\n\tif (pick == -1 || A[pick] > A[*e]) {\n\t    pick = *e;\n\t}\n    }\n\n    // pick;\n    use[pick] = true;\n    VI cur;\n    EACH (e, vs) if (!use[*e]) {\n\tVI tmp = rec(*e, A[pick]);\n\tcur = ME(cur, tmp);\n    }\n    \n    cur.insert(cur.begin(), A[pick]);\n    return cur;\n}\n\n\nvoid MAIN() {\n    scanf(\"%d\", &N);\n    REP (i, N) scanf(\"%d\", A+i);\n\n    REP (i, N) {\n\tint m = A[i];\n\tfor (int j=2; j*j<=m; j++) {\n\t    if (m % j == 0) {\n\t\tP.push_back(j);\n\t\tF[i].push_back(j);\n\t\twhile (m % j == 0) m /= j;\n\t    }\n\t}\n\tif (m > 1) {\n\t    P.push_back(m);\n\t    F[i].push_back(m);\n\t}\n    }\n\n    sort(P.begin(), P.end());\n    P.erase(unique(P.begin(), P.end()), P.end());\n    REP (i, N) {\n\tEACH (e, F[i]) {\n\t    *e = lower_bound(P.begin(), P.end(), *e) - P.begin();\n\t    R[*e].push_back(i);\n\t}\n    }\n\n    VI ans;\n\n    REP (i, N) if (!use[i]) {\n\tVI tmp = rec(i, 0);\n\tans = ME(ans, tmp);\n    }\n    rprintf(\"%d\", ans.begin(), ans.end());\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\",\"inline\",\"-ffast-math\")\n#pragma GCC target(\"avx,sse2,sse3,sse4,mmx\")\n#include <bits/stdc++.h>\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/hash_policy.hpp>\nusing namespace __gnu_pbds;\nusing namespace std;\n\nint n,a[2010];\nvector<int> v[2010];\nbool vis[2010][2010],c[2010][2010],used[2010];\nvector<int> dp[2010];\n\ninline int gcd(int a,int b)\n{\n\tif(b==0) return a;\n\treturn gcd(b,a%b);\n}\n\ninline void dfs2(int u,int x,vector<pair<int,int> >&res)\n{\n\tres.push_back(make_pair(a[x],x));\n\tfor(int i=0;i<v[x].size();i++) if(!used[v[x][i]]&&!vis[u][v[x][i]]&&c[u][v[x][i]]){\n\t\tvis[u][v[x][i]]=1;\n\t\tdfs2(u,v[x][i],res);\n\t}\n}\n\ninline void dfs(int x)\n{\n\tused[x]=1;\n\tvector<vector<int> > w;\n\tvector<pair<int,int> > res;\n\tfor(int i=0;i<v[x].size();i++) if(!used[v[x][i]]&&!vis[x][v[x][i]]){\n\t\tvis[x][v[x][i]]=1;res.clear();dfs2(x,v[x][i],res);\n\t\tsort(res.begin(),res.end());\n\t\tdfs(res[0].second);\n\t\tw.push_back(dp[res[0].second]);\n\t}\n\tsort(w.begin(),w.end());\n\tdp[x].push_back(x);\n\tfor(int i=w.size()-1;i>=0;i--) for(int j=0;j<w[i].size();j++) dp[x].push_back(w[i][j]);\n}\n\nsigned main()\n{\n\tios::sync_with_stdio(false);\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=i+1;j<=n;j++){\n\t\t\tif(gcd(a[i],a[j])>1){\n\t\t\t\tv[i].push_back(j);\n\t\t\t\tv[j].push_back(i);\n\t\t\t\tc[i][j]=1;c[j][i]=1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tv[0].push_back(i);v[i].push_back(0);c[0][i]=1;c[i][0]=1;\n\t}\n\tdfs(0);\n\tfor(int i=1;i<dp[0].size();i++) cout<<a[dp[0][i]]<<\" \";\n\tcout<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<ctime>\n#include<map>\n#include<bitset>\n#include<set>\n#define LL long long\n#define mp(x,y) make_pair(x,y)\n#define pll pair<long long,long long>\n#define pii pair<int,int>\nusing namespace std;\ninline int read()\n{\n\tint f=1,x=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint stack[20];\ntemplate<typename T>inline void write(T x)\n{\n\tif(x<0){putchar('-');x=-x;}\n    if(!x){putchar('0');return;}\n    int top=0;\n    while(x)stack[++top]=x%10,x/=10;\n    while(top)putchar(stack[top--]+'0');\n}\ntemplate<typename T>inline void pr1(T x){write(x);putchar(' ');}\ntemplate<typename T>inline void pr2(T x){write(x);putchar('\\n');}\nconst int MAXN=2005;\nvector<int> nxt[MAXN];\nint cal[MAXN],vis[MAXN],n,id[MAXN];\nbool cmp(int n1,int n2){return cal[n1]<cal[n2];}\npriority_queue<pii> hp;\nint gcd(int a,int b){return a==0?b:gcd(b%a,a);}\nint du[MAXN];\nvoid dfs(int x,int up)\n{\n\tif(up)nxt[up].push_back(x),++du[x];\n\tvis[x]=1;\n\tfor(int i=1;i<=n;i++)if(!vis[i]&&gcd(cal[i],cal[x])!=1)\n\t\tdfs(i,x);\n}\nint main()\n{\n\tn=read();\n\tfor(int i=1;i<=n;i++)cal[i]=read(),id[i]=i;\n\tsort(id+1,id+1+n,cmp);\n\tfor(int i=1;i<=n;i++)if(!vis[id[i]])\n\t\thp.push(mp(cal[id[i]],i)),dfs(id[i],0);\n\twhile(!hp.empty())\n\t{\n\t\tint x=hp.top().second;hp.pop();pr1(cal[x]);\n\t\tfor(int k=0;k<nxt[x].size();k++)\n\t\t{\n\t\t\tint y=nxt[x][k];\n\t\t\t--du[y];if(!du[y])hp.push(mp(cal[y],y));\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<cstring>\n#include<algorithm>\n#include<queue>\n#define fo(i,a,b) for(i=a;i<=b;i++)\n#define ll long long\nusing namespace std;\nint n,a[2005],tot,du[2005],h[2005],to[4000005],nex[4000005];\nbool bhz[2005][2005],pd[2005];\nint gcd(int a,int b)\n{\n    return b?gcd(b,a%b):a;\n}\nstruct node{\n    int fr,id;\n}st;\nbool operator <(node a,node b)\n{\n    return a.fr<b.fr;\n}\npriority_queue<node> q;\nvoid add(int a,int b)\n{\n    du[b]++;\n    to[++tot]=b;\n    nex[tot]=h[a];\n    h[a]=tot;\n}\nvoid dfs(int x)\n{\n    pd[x]=1;\n    for(int i=1;i<=n;i++)\n        if(bhz[x][i]&&!pd[i])\n        {\n            add(x,i);\n            dfs(i);\n        }\n}\nint main()\n{\n    cin>>n;\n    for(int i=1;i<=n;i++) cin>>a[i];\n    sort(a+1,a+n+1);\n    for(int i=1;i<=n-1;i++)\n    for(int j=i+1;j<=n;j++)\n    if(gcd(a[i],a[j])>1) bhz[i][j]=bhz[j][i]=1;\n    for(int i=1;i<=n;i++) if(!pd[i]) dfs(i);\n    for(int i=1;i<=n;i++) \n        if(!du[i])\n        { \n            st.fr=a[i];\n            st.id=i;\n            q.push(st); \n        }\n    for(int i=1;i<=n;i++)\n    {\n        st=q.top();\n        q.pop();\n        int now=st.id;\n        cout<<a[now]<<\" \";\n//        for(int k=h[now];k;k=nex[k])\n//        {\n//            du[to[k]]--;\n//            if(!du[to[k]])\n//            {\n//                st.fr=a[to[k]];\n//                st.id=to[k];\n//                q.push(st);\n//            }\n//        }\n        int t=h[now];\n        while (t){\n            d[go[t]]--;\n            if (!d[go[t]]){\n                zlt.x=a[go[t]];\n                zlt.y=go[t];\n                dl.push(zlt);\n            }\n            t=nxt[t];\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\n\nusing namespace std;\ntypedef vector<int> VI;\n\nconst int N=2005;\n\nint gcd(int x,int y){return y?gcd(y,x%y):x;}\n\nint n,a[N];\nVI E[N],R[N];\nbool vis[N];\n\nVI merge(const VI&x,const VI&y){\n\tVI z;\n\tz.resize(x.size()+y.size());\n\tfor(int i=0,j=0,k=0,li=x.size(),lj=y.size();i<li||j<lj;){\n\t\tif(i==li)z[k++]=y[j++];\n\t\telse if(j==lj)z[k++]=x[i++];\n\t\telse if(x[i]<y[j])z[k++]=y[j++];\n\t\telse z[k++]=x[i++];\n\t}\n\treturn z;\n}\n\nvoid dfs(int x){\n\tvis[x]=true;\n\tfor(int v:E[x])if(!vis[v])dfs(v),R[x]=merge(R[x],R[v]);\n\tR[x].insert(R[x].begin(),1,a[x]);\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++)for(int j=i+1;j<=n;j++)\n\t\tif(gcd(a[i],a[j])>1)E[i].pb(j),E[j].pb(i);\n\t++n;\n\tfor(int i=1;i<n;i++)E[i].pb(n),E[n].pb(i);\n\tdfs(n);\n\tfor(int v:R[n])if(v)printf(\"%d \",v);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<cassert>\n#define PB push_back\n#define MP make_pair\n#define sz(v) (in((v).size()))\n#define forn(i,n) for(in i=0;i<(n);++i)\n#define forv(i,v) forn(i,sz(v))\n#define fors(i,s) for(auto i=(s).begin();i!=(s).end();++i)\n#define all(v) (v).begin(),(v).end()\nusing namespace std;\ntypedef long long in;\ntypedef vector<in> VI;\ntypedef vector<VI> VVI;\nin ggt(in a, in b){\n  if(b==0)\n    return a;\n  return ggt(b,a%b);\n}\nin n;\nVVI d;\nVI a;\nVI usd;\nVI ord;\nvoid dfs(in u){\n  usd[u]=1;\n  ord.PB(u);\n  forn(i,n){\n    if(usd[i]||d[u][i])\n      continue;\n    dfs(i);\n  }\n}\nint main(){\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cin>>n;\n  a.resize(n);\n  forn(i,n)\n    cin>>a[i];\n  usd.resize(n);\n  sort(all(a));\n  d.resize(n,VI(n));\n  forn(i,n){\n    forn(j,n){\n      if(j==i)\n\tcontinue;\n      if(ggt(a[i],a[j])==1)\n\td[i][j]=1;\n    }\n  }\n  forn(z,n){\n    if(usd[z])\n      continue;\n    dfs(z);\n  }\n  VI blok(n);\n  forn(i,n){\n    for(in j=i+1;j<n;++j)\n      if(!d[ord[i]][ord[j]])\n\t++blok[ord[j]];\n  }\n  VI rord;\n  usd=VI(n,0);\n  in pos;\n  forn(z,n){\n    for(in i=n-1;i>=0;--i){\n      if(usd[i] || blok[i])\n\tcontinue;\n      rord.PB(i);\n      pos=0;\n      while(ord[pos]!=i)\n\t++pos;\n      for(in j=pos+1;j<n;++j){\n\tif(!d[i][ord[j]])\n\t  --blok[ord[j]];\n      }\n      usd[i]=1;\n      break;\n    }\n  }\n  forn(i,n)\n    cout<<a[rord[i]]<<\" \";\n  cout<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <set>\nint N, a[2001], apr[2001], G[2001][2001], q[2002], ue[2002], ref[2002], v[2001], L, d[2001];\nstd::vector < int > E[2001];\nint gcd(int a, int b)\n{\n\tint r;\n\twhile (b)\n\t{\n\t\tr = a % b;\n\t\ta = b;\n\t\tb = r;\n\t}\n\treturn a;\n}\nint main()\n{\n\tdo\n\t{\n\t\tstatic int w[2001], L;\n\t\tscanf(\"%d\", &L);\n\t\tfor (int i = 1; i <= L; i++)\n\t\t\tscanf(\"%d\", w + i);\n\t\tstd::sort(w + 1, w + L + 1);\n\t\tfor (int i = 1; i <= L; i++)\n\t\t\tif (!N || a[N] != w[i])\n\t\t\t{\n\t\t\t\ta[++N] = w[i];\n\t\t\t\tapr[N] = 1;\n\t\t\t}\n\t\t\telse\n\t\t\t\tapr[N]++;\n\t}\n\twhile (0);\n\tfor (int i = 1; i < N; i++)\n\t\tfor (int j = i + 1; j <= N; j++)\n\t\t\tif (gcd(a[i], a[j]) != 1)\n\t\t\t\tG[i][j] = G[j][i] = 1;\n\tfor (int i = 1; i <= N; i++)\n\t\tG[0][i] = G[i][0] = 1;\n\tint D = 1;\n\tq[1] = 0;\n\tue[1] = 0;\n\tv[0] = 1;\n\tref[L = 1] = 0;\n\twhile (D)\n\t{\n\t\twhile (ue[D] <= N && (!G[q[D]][ue[D]] || v[ue[D]]))\n\t\t\tue[D]++;\n\t\tif (ue[D] <= N)\n\t\t{\n\t\t\tint To = ue[D]++;\n\t\t\tE[q[D]].push_back(To);\n\t\t\td[To]++;\n\t\t\tq[++D] = To;\n\t\t\tue[D] = 0;\n\t\t\tv[ref[++L] = To] = 1;\n\t\t}\n\t\telse\n\t\t\tD--;\n\t}\n\tstd::vector < int > O;\n\tstd::set < int > S;\n\tfor (int i = 0; i <= N; i++)\n\t\tif (!d[i])\n\t\t\tS.insert(i);\n\twhile (!S.empty())\n\t{\n\t\tauto it = S.end();\n\t\tint u = *--it;\n\t\tS.erase(it);\n\t\tO.push_back(u);\n\t\tfor (int v : E[u])\n\t\t\tif (!--d[v])\n\t\t\t\tS.insert(v);\n\t}\n\tfor (int i : O)\n\t\tfor (int T = apr[i]; T--; )\n\t\t\tprintf(\"%d \", a[i]);\n\tputs(\"\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define xx first\n#define yy second\n#define mp make_pair\n#define pb push_back\n#define fill( x, y ) memset( x, y, sizeof x )\n#define copy( x, y ) memcpy( x, y, sizeof x )\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair < int, int > pa;\ntypedef vector < int > vec;\n\nconst int MAXN = 2005;\n\nint n, a[MAXN], c[MAXN][MAXN];\nvec e[MAXN];\nbool vis[MAXN];\n\ninline void dfs(int x)\n{\n\tvis[ x ] = 1;\n\tfor( int i = 0 ; i < n ; i++ ) if( c[ x ][ i ] ) if( !vis[ i ] ) e[ x ].pb( i ), dfs( i );\n}\n\ninline vec solve(int x)\n{\n\tvector < vec > cur;\n\tvec ret;\n\tfor( auto y : e[ x ] )\n\t{\n\t\tvec t = solve( y );\n\t\treverse( t.begin(), t.end() );\n\t\tcur.pb( t );\n\t}\n\tif( x ^ n ) ret.pb( a[ x ] );\n\twhile( true )\n\t{\n\t\tint x = -1;\n\t\tfor( int i = 0 ; i < cur.size() ; i++ )\n\t\t\tif( !cur[ i ].empty() && ( x == -1 || cur[ i ].back() > cur[ x ].back() ) ) x = i;\n\t\tif( x == -1 ) break;\n\t\tret.pb( cur[ x ].back() );\n\t\tcur[ x ].pop_back();\n\t}\n\treturn ret;\n}\n\nint main()\n{\n#ifdef wxh010910\n\tfreopen( \"data.in\", \"r\", stdin );\n#endif\n\tscanf( \"%d\", &n );\n\tfor( int i = 0 ; i < n ; i++ ) scanf( \"%d\", &a[ i ] );\n\tsort( a, a + n );\n\tfor( int i = 0 ; i < n ; i++ )\n\t\tfor( int j = 0 ; j < i ; j++ )\n\t\t\tif( __gcd( a[ i ], a[ j ] ) ^ 1 )\n\t\t\t\tc[ i ][ j ] = c[ j ][ i ] = 1;\n\tfor( int i = 0 ; i < n ; i++ ) if( !vis[ i ] )\n\t\te[ n ].pb( i ), dfs( i );\n\tvec ans = solve( n );\n\tfor( auto x : ans ) printf( \"%d \", x );\n\treturn putchar( 10 ), 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <bitset>\n#include <cstdio>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <cassert>\n#include <climits>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\n#include <functional>\nusing namespace std ;\n\n#define rep(i, a, b) for (int (i) = (a); (i) <= (b); (i)++)\n#define Rep(i, a, b) for (int (i) = (a) - 1; (i) < (b); (i)++)\n#define REP(i, a, b) for (int (i) = (a); (i) >= (b); (i)--)\n#define clr(a) memset(a, 0, sizeof(a))\n#define Sort(a, len, cmp) sort(a + 1, a + len + 1, cmp)\n#define ass(a, sum) memset(a, sum, sizeof(a))\n\n#define ls ((rt) << 1)\n#define rs ((rt) << 1 | 1)\n#define lowbit(x) (x & -x)\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define endl '\\n'\n#define ENDL cout << endl\n#define SZ(x) ((int)x.size())\n\ntypedef long long ll ;\ntypedef unsigned long long ull ;\ntypedef vector <int> Vi ;\ntypedef pair <int, int> Pii ;\ntypedef pair <ll, ll> Pll ;\ntypedef map <int, int> mii ;\ntypedef map <string, int> msi ;\ntypedef map <ll, ll> mll ;\n\nconst int N = 2010 ;\nconst double eps = 1e-8 ;\nconst int iinf = INT_MAX ;\nconst ll linf = 2e18 ;\nconst double dinf = 1e30 ;\nconst int MOD = 1000000007 ;\n\ninline int read(){\n    int X = 0, w = 0 ;\n\tchar ch = 0 ;\n    while (!isdigit(ch)) { w |= ch == '-' ; ch = getchar() ; }\n    while (isdigit(ch)) X = (X << 3) + (X << 1) + (ch ^ 48), ch = getchar() ;\n    return w ? - X : X ;\n}\n\nvoid write(int x){\n     if (x < 0) putchar('-'), x = - x ;\n     if (x > 9) write(x / 10) ;\n     putchar(x % 10 + '0') ;\n}\n\nvoid print(int x) {\n\tcout << x << endl ;\n\texit(0) ;\n}\n\nvoid PRINT(string x) {\n\tcout << x << endl ;\n\texit(0) ;\n}\n\nvoid douout(double x){\n\t printf(\"%lf\\n\", x + 0.0000000001) ;\n}\n\nint vis[N], ok[N][N], in[N], a[N] ;\nvector <int> g[N] ;\nint n ;\n\nvoid dfs(int rt) {\n\tvis[rt] = 1 ;\n\tfor (int i = 1; i <= n; i++)\n\tif (!vis[i] && ok[rt][i]) {\n\t\tin[i]++ ;\n\t\tg[rt].pb(i) ;\n\t\tdfs(i) ;\n\t}\n}\n\nvoid Top() {\n\tpriority_queue <int> q ;\n\tfor (int i = 1;  i <= n; i++) if (!in[i]) q.push(i) ;\n\twhile (!q.empty()) {\n\t\tint now = q.top() ;\n\t\tq.pop() ;\n\t\tcout << a[now] << \" \" ;\n\t\tfor (int i = 0; i < SZ(g[now]); i++) q.push(g[now][i]) ;\n\t}\n}\n\nsigned main(){\n\tscanf(\"%d\", &n) ;\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]) ;\n\tsort(a + 1, a + n + 1) ;\n\tclr(ok) ;\n\tfor (int i = 1; i <= n; i++)\n\tfor (int j = i + 1; j <= n; j++)\n\tif (__gcd(a[i], a[j]) != 1) ok[i][j] = ok[j][i] = 1 ;\n\tfor (int i = 1; i <= n; i++) if (!vis[i]) dfs(i) ;//连通块\n\tTop() ;\n}\n\n/*\n写代码时请注意：\n\t1.是否要开Long Long？数组边界处理好了么？\n\t2.实数精度有没有处理？\n\t3.特殊情况处理好了么？\n\t4.做一些总比不做好。\n思考提醒：\n\t1.最大值和最小值问题可不可以用二分答案？\n\t2.有没有贪心策略？否则能不能dp？\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#include<iostream>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<cmath>\n#include<string>\n\n#define ls (t<<1)\n#define rs ((t<<1)+1)\n#define mid ((l+r)>>1)\n#define fi first\n#define se second\n#define mk make_pair\n#define pb push_back\n\n#define N 60005\n#define M 200005\n#define seed 23333\n\nusing namespace std;\nint i,j,m,n,p,k,tot,T,ID[N],up[N],used[N],vis[N],a[N],Q[N],bl[N];\nvector<int>v[N],nex[N];\nmap<int,int>mp;\nvoid ins(int id,int pr)\n{\n\t\tif (mp.find(pr)==mp.end()) mp[pr]=++tot;\n\t\tnex[mp[pr]].pb(id);\n\t\tnex[id].pb(mp[pr]);\t\t\n}\nvoid bfs(int x)\n{\n\t\tQ[Q[0]=1]=x;\n\t\t++T;\n\t\tup[x]=1;\n\t\tbl[x]=T;\n\t\tint i,l;\n\t\tfor (l=1;l<=Q[0];++l)\n\t\t{\n\t\t\t\tint p=Q[l];\n\t\t\t\tfor (i=0;i<(int)nex[p].size();++i)\n\t\t\t\t{\n\t\t\t\t\t\tint k=nex[p][i];\n\t\t\t\t\t\tif (up[k]||used[k]) continue;\n\t\t\t\t\t\tup[k]=1;\n\t\t\t\t\t\tbl[k]=T;\n\t\t\t\t\t\tQ[++Q[0]]=k;\n\t\t\t\t}\n\t\t}\n}\nint gcd(int x,int y)\n{\n\t\treturn !y?x:gcd(y,x%y);\n}\nvoid rebuild()\n{\n\t\tint i;\n\t\tmemset(up,0,sizeof(up)); T=0;\n\t\tfor (i=1;i<=n;++i)\t\n\t\t\tif (!used[i]&&!up[i]) bfs(i);\n}\nvoid renew_block()\n{\n\t\tint i;\n\t\tfor (i=1;i<=T;++i) ID[i]=0;\n\t\tfor (i=1;i<=n;++i)\n\t\t\tif (!used[i]&&vis[i]&&(!ID[bl[i]]||a[ID[bl[i]]]>a[i])) ID[bl[i]]=i; \n}\nint work()\n{\n\t    int i;\n\t\trenew_block();\n\t\tint now=1;\n\t\tfor (i=2;i<=T;++i)\tif (a[ID[now]]<a[ID[i]]) now=i;\n\t\tused[ID[now]]=1;\n\t\tfor (i=1;i<=n;++i) if (bl[i]==now) vis[i]=0;\n\t\tfor (i=0;i<(int)v[ID[now]].size();++i)\n\t\t\tvis[v[ID[now]][i]]=1; \n\t\trebuild();\n\t\treturn a[ID[now]];\n}\nint main()\n{\n\tscanf(\"%d\",&n); tot=n;\n\tfor (i=1;i<=n;++i)\n\t{\n\t\t\tscanf(\"%d\",&a[i]);\n\t\t\tfor (j=2,k=a[i];j*j<=k;++j)\n\t\t\t\tif (k%j==0)\n\t\t\t\t{\n\t\t\t\t\t\tins(i,j);\n\t\t\t\t\t\twhile (k%j==0) k/=j;\n\t\t\t\t}\n\t\t\tif (k>1) ins(i,k);\n\t}\n\tfor (i=1;i<=n;++i)\n\t\tfor (j=1;j<=n;++j) if (gcd(a[i],a[j])!=1) v[i].pb(j);\n\tfor (i=1;i<=n;++i) vis[i]=1;\n\trebuild();\n\tfor (i=1;i<=n;++i) printf(\"%d \",work()); \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define per(i,b,a) for(int i=b;i>=a;i--)\n#define For(i,a,b) for(int i=a;i<=b;i++)\n#define Forenska(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\n#define all(x) x.begin(),x.end()\n#define sqr(x) ((x)*(x))\n#define lowbit(x) ((x)&(-x))\n#define GREATER(x) x,vector<x>,greater<x>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> pii;\ntypedef pair<LL,LL> pLL;\ntypedef vector<int> vec;\ntypedef vector<LL> vecL;\ntypedef vector<pii> vecP;\ntypedef vector<pLL> vecPL;\ntypedef vector<string> vecS;\ntypedef vector<vec> mat;\ntypedef complex<double> point;\nconst long double PI=3.1415926535897932384626433832795028841971693993751058209749445923078164062862089;\nconst LL INFLL=0x3f3f3f3f3f3f3f3f;\nconst int INF=0x3f3f3f3f;\nconst long double EPS=1e-10;\nint read()\n{\n\tint x=0;\n\tchar ch=' ';\n\tbool flag=false;\n\twhile(!isdigit(ch))\n\t{\n\t\tif(ch=='-')flag=true;\n\t\tch=getchar();\n\t}\n\twhile(isdigit(ch))\n\t{\n\t\tx=(x<<3)+(x<<1)+ch-'0';\n\t\tch=getchar();\n\t}\n\treturn flag?-x:x;\n}\nconst int MAX_N=2050;\nconst int MAX_V=40050;\nint n,m;\nint a[MAX_N];\nbool b[MAX_N][MAX_N];\nint ans[MAX_N];\nint ansSz;\nbool inAns[MAX_N];\nint lastNotCoPrime[MAX_N];\nint minOnSuff[MAX_N];\nint comp[MAX_V];\nvec g[MAX_V];\nint C;\nint bestForCol[MAX_N];\nmap <int,int> primeId;\nint getId(int p)\n{\n\tif(primeId.count(p)>0)return primeId[p];\n\tprimeId[p]=m;\n\tm++;\n\treturn m-1;\n}\nvoid dfs(int v)\n{\n\tcomp[v]=C;\n\trep(i,0,g[v].size())\n\t{\n\t\tint u=g[v][i];\n\t\tif(comp[u]!=-1)continue;\n\t\tif(u<n && inAns[u])continue;\n\t\tdfs(u);\n\t}\n}\nvoid color()\n{\n\trep(i,0,m)\n\t{\n\t\tcomp[i]=-1;\n\t}\n\tC=0;\n\trep(i,0,n)\n\t{\n\t\tif(inAns[i])continue;\n\t\tif(comp[i]!=-1)continue;\n\t\tdfs(i);\n\t\tC++;\n\t}\n}\nint main()\n{\n\tcin>>n;\n\tm=n;\n\trep(i,0,n)\n\t{\n\t\tcin>>a[i];\n\t\tint x=a[i];\n\t\tFor(y,2,sqrt(x))\n\t\t{\n\t\t\tif(x%y!=0)continue;\n\t\t\tint id=getId(y);\n\t\t\tg[i].pb(id);\n\t\t\tg[id].pb(i);\n\t\t\twhile(x%y==0)x/=y;\n\t\t}\n\t\tif(x!=1)\n\t\t{\n\t\t\tint id=getId(x);\n\t\t\tg[i].pb(id);\n\t\t\tg[id].pb(i);\n\t\t}\n\t}\n\trep(i,0,n)\n\t{\n\t\trep(j,i+1,n)\n\t\t{\n\t\t\tif(__gcd(a[i],a[j])>1)\n\t\t\t{\n\t\t\t\tb[i][j]=b[j][i]=1;\n\t\t\t}\n\t\t}\n\t}\n\trep(i,0,n)lastNotCoPrime[i]=-1;\n\trep(i,0,n)minOnSuff[i]=INF;\n\twhile(ansSz!=n)\n\t{\n\t\tcolor();\n\t\trep(i,0,C)bestForCol[i]=-1;\n\t\trep(i,0,n)\n\t\t{\n\t\t\tif(inAns[i])continue;\n\t\t\tif(minOnSuff[lastNotCoPrime[i]+1]<a[i])continue;\n\t\t\tif(bestForCol[comp[i]]==-1 || a[bestForCol[comp[i]]]>a[i])\n\t\t\t{\n\t\t\t\tbestForCol[comp[i]]=i;\n\t\t\t}\n\t\t}\n\t\tint id=-1;\n\t\trep(i,0,C)\n\t\t{\n\t\t\tif(bestForCol[i]==-1)continue;\n\t\t\tif(id==-1 || a[id]<a[bestForCol[i]])id=bestForCol[i]; \n\t\t}\n\t\tif(id==-1)throw;\n\t\tinAns[id]=1;\n\t\tans[ansSz++]=a[id];\n\t\trep(i,0,ansSz)minOnSuff[i]=min(minOnSuff[i],a[id]);\n\t\trep(i,0,n)if(b[id][i])lastNotCoPrime[i]=ansSz-1;\n\t}\n\trep(i,0,n)cout<<ans[i]<<\" \";\n\tcout<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i, x, y) for(int i = (x); i < (y); ++i)\n#define REP(i, x, y) for(int i = (x); i <= (y); ++i)\n#define MP make_pair\n#define PB push_back\n#define PH push\n#define fst first\n#define snd second\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ldb;\ntypedef pair<int, int> pii;\n\nconst int INF = 1e9 + 7;\nconst int maxn = 2005;\n\nint n;\nint a[maxn], vis[maxn];\nvector<int> ans;\nvector<int> g[maxn], tr[maxn];\npriority_queue<pii> que;\n\ninline void dfs(int u){\n\tvis[u] = true;\n\tFOR(i, 0, g[u].size()){\n\t\tint v = g[u][i];\n\t\tif(!vis[v]){\n\t\t\tdfs(v);\n\t\t\ttr[u].PB(v);\n\t\t}\n\t}\n\treturn;\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\tFOR(i, 0, n)\n\t\tscanf(\"%d\", a + i);\n\tFOR(i, 0, n) FOR(j, 0, n) if(i != j && __gcd(a[i], a[j]) != 1)\n\t\tg[i].PB(j);\n\n\tFOR(i, 0, n) if(!vis[i])\n\t\tdfs(i), que.PH(MP(a[i], i));\n\twhile(!que.empty()){\n\t\tint u = que.top().snd;\n\t\tque.pop();\n\t\tans.PB(a[u]);\n\t\tFOR(i, 0, tr[u].size())\n\t\t\tque.PH(MP(a[tr[u][i]], tr[u][i]));\n\t}\n\t\n\tFOR(i, 0, n)\n\t\tprintf(\"%d \", ans[i]);\n\tputs(\"\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pb push_back\n#define all(x) x.begin(), x.end()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nconst int N = 2000 + 10;\nconst int MOD = 1000000007;\nconst int LOG = 20;\nconst int INF = 1000000010;\nconst int delta = 11353;\n\nint n;\nvi G[N], a;\nmap<int, int> mp;\nint mark[N];\nint mark2[N];\n\nvoid DFS(int v){\n\tmark[v] = 1;\n\tfor (auto u:G[v]){\n\t\tif ((mark[u] == 0) && (mark2[u] == 0)){\n\t\t\tDFS(u);\n\t\t}\n\t}\n}\nint GCD(int x, int y){\n\tif (x == 0 || y == 0) return (x + y);\n\tif (x == 1 || y == 1) return 1;\n\tif (x < y) swap(x, y);\n\treturn GCD(y, x % y);\n}\n\nint32_t main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++){\n\t\tint x;\n\t\tcin >> x;\n\t\tmp[x] ++;\n\t\ta.pb(x);\n\t}\n\tsort(all(a));\n\ta.resize(unique(all(a)) - a.begin());\n\tfor (int i = 0; i < a.size(); i++) for (int j = 0; j < i; j++) if (GCD(a[i], a[j]) != 1){\n\t\tG[i].pb(j), G[j].pb(i);\n\t}\n\t//cout << GCD(7, 11) << '\\n';\n\tvi ans;\n\tint last = 0;\n\tfor (int i = 0; i < a.size(); i++){\n\t\tmemset(mark, 0, sizeof mark);\n\t\tif (i == 0){\n\t\t\tint mx = 0;\n\t\t\tfor (int j = 0; j < a.size(); j++) if (!mark[j]) mx = j, DFS(j);\n\t\t\tmark2[mx] = 1;\n\t\t\tans.pb(a[mx]);\n\t\t\t//cout << a[mx] << endl;\n\t\t\tlast = mx;\n\t\t}else{\n\t\t\tsort(all(G[last]));\n\t\t\tint mx = 0;\n\t\t\tfor (int j = 0; j < last; j++){\n\t\t\t\tif ((mark[j] == 0) && (mark2[j] == 0)) DFS(j), mx = j;\n\t\t\t}\n\t\t\tfor (auto u:G[last]){\n\t\t\t\tif ((mark[u] == 0) && (mark2[u] == 0)) mx = max(mx, u), DFS(u);\n\t\t\t}\n\t\t\tfor (int j = last + 1; j < a.size(); j++){\n\t\t\t\tif ((mark[j] == 0) && (mark2[j] == 0)) mx = max(mx, j), DFS(j);\n\t\t\t}\n\t\t\tmark2[mx] = 1;\n\t\t\tans.pb(a[mx]);\n\t\t\tlast = mx;\n\t\t\t//cout << a[mx] << endl;\n\t\t}\n\t}\n\tfor (int i = 0; i < ans.size(); i++){\n\t\tint u = ans[i];\n\t\tfor (int i = 0; i < mp[u]; i++) cout << u << ' ';\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#pragma GCC optimize(\"O2\")\n#define LL long long\n#define N 2222\n#define int long long\n#define reg register\nint read(){\n\tint x=0,f=1;\n\tchar ch=getchar();\n\twhile (ch<'0' || ch>'9'){\n\t\tif (ch=='-') f=-1;\n\t\tch=getchar();\n\t}\n\twhile (ch>='0' && ch<='9'){\n\t\tx=x*10+ch-'0';ch=getchar();\n\t}\n\treturn x*f;\n}\nint vis[N],ok[N][N],ind[N],a[N];\nvector <int> g[N];\nint n;\nvoid dfs(int x){\n\tvis[x]=1;\n\tfor (int i=1;i<=n;++i){\n\t\tif (!vis[i] && ok[x][i]){\n\t\t\tind[i]++;\n\t\t\tg[x].push_back(i);\n\t\t\tdfs(i);\n\t\t}\n\t}\n}\nvoid solve(){\n\tpriority_queue <int> q;\n\tfor (int i=1;i<=n;++i){\n\t\tif (!ind[i]) q.push(i);\n\t}\n\twhile (!q.empty()){\n\t\tint x=q.top();\n\t\tq.pop();\n\t\tprintf(\"%lld \",a[x]);\n\t\tfor (int i=0;i<g[x].size();++i) q.push(g[x][i]);\n\t}\n}\nsigned main(){\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\t\n\tn=read();\n\tfor (int i=1;i<=n;++i) a[i]=read();\n\tsort(a+1,a+1+n);\n\tfor (int i=1;i<=n;++i){\n\t\tfor (int j=i+1;j<=n;++j){\n\t\t\tif (__gcd(a[i],a[j])!=1){\n\t\t\t\tok[i][j]=ok[j][i]=1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=1;i<=n;++i){\n\t\tif (!vis[i]) dfs(i);\n\t}\n\tsolve();\n\t\n\tfclose(stdin);\n\tfclose(stdout);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nconst int N=2020,M=4004000;\nint i,j,k,n,m,ch;\nint a[N],z[N];\nvector<int> A[N],ans;\nvoid R(int &x) {\n\tx=0;ch=getchar();\n\twhile (ch<'0' || '9'<ch) ch=getchar();\n\twhile ('0'<=ch && ch<='9') x=x*10+ch-'0',ch=getchar();\n}\nint gcd(int a,int b) {\n\tif (!b) return a;\n\treturn gcd(b,a%b);\n}\nvector<int> merge(vector<int> a,vector<int> b) {\n\tvector<int> c;\n\tint i=0,j=0;\n\twhile (i<a.size() && j<b.size()) {\n\t\tif (a[i]>b[j]) c.push_back(a[i]),i++;\n\t\telse c.push_back(b[j]),j++;\n\t}\n\twhile (i<a.size()) c.push_back(a[i]),i++;\n\twhile (j<b.size()) c.push_back(b[j]),j++;\n\treturn c;\n}\nvector<int> add(vector<int> a,int b) {\n\tvector<int> c;\n\tc.push_back(b);\n\tfor (int i=0;i<a.size();i++) c.push_back(a[i]);\n\treturn c;\n}\nvector<int> dfs(int x) {\n\tz[x]=1;\n\tvector<int> t;\n\tfor (int i=1;i<=n;i++) if (!z[i] && gcd(a[x],a[i])>1) t=merge(t,dfs(i));\n\tt=add(t,a[x]);\n\treturn t;\n}\nint main() {\n\tR(n);\n\tfor (i=1;i<=n;i++) R(a[i]);\n\tsort(a+1,a+n+1);\n\tfor (i=1;i<=n;i++) if (!z[i]) ans=merge(ans,dfs(i));\n\tfor (i=0;i<ans.size();i++) printf(\"%d \",ans[i]);\n\tputs(\"\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\nVI ME(const VI &a, const VI &b) {\n    VI ret; ret.reserve(a.size() + b.size());\n    int i = 0, j = 0;\n    while (i < (int)a.size() && j < (int)b.size()) {\n\tif (a[i] < b[j]) ret.push_back(b[j++]);\n\telse ret.push_back(a[i++]);\n    }\n    ret.insert(ret.end(), a.begin()+i, a.end());\n    ret.insert(ret.end(), b.begin()+j, b.end());\n    return ret;\n}\n\nint N;\nint A[2011];\nVI G[2011];\nbool use[2011];\n\nVI F[2011];\nVI R[200011];\nVI P;\n\nint D[200011], cnt;\nVI rec(int s, int last) {\n    if (A[s] == 1) {\n\tuse[s] = true;\n\treturn { 1 };\n    }\n\n    VI vs;\n    cnt++;\n    vs.push_back(s);\n    for (int i=0; i<(int)vs.size(); i++) {\n\tint v = vs[i];\n\tEACH (e, F[v]) if (D[*e] != cnt) {\n\t    D[*e] = cnt;\n\t    EACH (f, R[*e]) if (!use[*f]) {\n\t\tvs.push_back(*f);\n\t    }\n\t}\n    }\n\n    int pick = -1;\n    EACH (e, vs) if (__gcd(last, A[*e]) > 1) {\n\tif (pick == -1 || A[pick] > A[*e]) {\n\t    pick = *e;\n\t}\n    }\n\n    // pick;\n    use[pick] = true;\n    VI cur;\n    EACH (e, G[pick]) if (!use[*e]) {\n\tVI tmp = rec(*e, A[pick]);\n\tcur = ME(cur, tmp);\n    }\n    \n    cur.insert(cur.begin(), A[pick]);\n    return cur;\n}\n\n\nvoid MAIN() {\n    scanf(\"%d\", &N);\n    REP (i, N) scanf(\"%d\", A+i);\n\n    REP (i, N) {\n\tint m = A[i];\n\tfor (int j=2; j*j<=m; j++) {\n\t    if (m % j == 0) {\n\t\tP.push_back(j);\n\t\tF[i].push_back(j);\n\t\twhile (m % j == 0) m /= j;\n\t    }\n\t}\n\tif (m > 1) {\n\t    P.push_back(m);\n\t    F[i].push_back(m);\n\t}\n    }\n\n    sort(P.begin(), P.end());\n    P.erase(unique(P.begin(), P.end()), P.end());\n    REP (i, N) {\n\tEACH (e, F[i]) {\n\t    *e = lower_bound(P.begin(), P.end(), *e) - P.begin();\n\t    R[*e].push_back(i);\n\t}\n    }\n\n    REP (i, N) REP (j, N) if (i != j) {\n\tif (__gcd(A[i], A[j]) > 1) {\n\t    G[i].push_back(j);\n\t}\n    }\n\n    VI ans;\n\n    REP (i, N) if (!use[i]) {\n\tVI tmp = rec(i, 0);\n\tans = ME(ans, tmp);\n    }\n    rprintf(\"%d\", ans.begin(), ans.end());\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cassert>\n#include <cmath>\n#include <algorithm>\n#include <map>\n\n\nusing ll = long long;\n#define MIN(a, b) (((a) < (b)) ? (b) : (a))\n#define MAX(a, b) (((a) < (b)) ? (b) : (a))\n\nint const nmax = 4000;\nint v[1 + nmax], edge[1 + nmax][1 + nmax], sol[1 + nmax];\nstd::map<int,int> primes;\nint ptr = 0;\nint affect[1 + nmax], suff[1 + nmax], used[1 + nmax];\nstd::vector<int> g[1 + nmax];\n\nnamespace DSU{\n  std::vector<int> mult;\n  std::vector<int> sz;\n  void initialize(int n) {\n    mult.resize(1 + n);\n    sz.resize(1 + n);\n    for(int i = 1;i <= n; i++) {\n      mult[i] = i;\n      sz[i] = 1;\n    }\n  }\n  void adjust(int node, int val) {\n    sz[node] = val;\n  }\n  int jump(int gala) {\n    if(gala != mult[gala])\n      mult[gala] = jump(mult[gala]);\n    return mult[gala];\n  }\n  void unite(int gala, int galb) {\n    gala = jump(gala);\n    galb = jump(galb);\n    if(gala == galb)\n      return ;\n    if(sz[galb] < sz[gala])\n      std::swap(gala, galb);\n    sz[galb] += sz[gala];\n    mult[gala] = galb;\n  }\n}\n\nvoid decompose(int number, int id) {\n  for(int i = 2;i * i <= number; i++) {\n    if(number % i == 0) {\n      while(number % i == 0) number /= i;\n      if(primes[i] == 0)\n        primes[i] = ++ptr;\n      g[id].push_back(primes[i]);\n    }\n  }\n  if(1 < number) {\n    if(primes[number] == 0)\n      primes[number] = ++ptr;\n    g[id].push_back(primes[number]);\n  }\n}\n\nint main() {\n  int n;\n  std::cin >> n;\n  for(int i = 1;i <= n; i++)\n    std::cin >> v[i];\n  std::sort(v + 1, v + n + 1);\n  ptr = n;\n  for(int i = 1;i <= n; i++)\n    decompose(v[i], i);\n  for(int i = 1;i <= n; i++)\n    for(int j = i;j <= n; j++)\n      if(1 < std::__gcd(v[i], v[j]))\n        edge[i][j] = edge[j][i] = 1; \n  \n  for(int i = 1;i <= n; i++)\n    suff[i] = v[n];\n\n  for(int i = 1;i <= n; i++) {\n    DSU::initialize(ptr);\n    int last = -1;\n    int total = ptr;\n    for(int j = n + 1;j <= ptr; j++) {\n      DSU::adjust(j, 0);\n      total--;\n    }\n    for(int j = 1; j <= n; j++)\n      if(used[j] == 1) {\n        DSU::adjust(j, 0);\n        total--;\n      }\n\n    for(int j = 1; j <= n; j++)\n      if(used[j] == 0)\n        for(int h = 0; h < g[j].size(); h++)\n          DSU::unite(j, g[j][h]);\n\n    for(int j = 1; j <= n; j++) {\n      if(used[j] == 1)\n        continue;\n      if(-1 < last) \n        DSU::unite(last, j);\n      last = j;\n\n      if(DSU::sz[DSU::jump(j)] == total && used[j] == 0 && v[j] <= suff[affect[j] + 1]) {\n        sol[i] = v[j];\n        used[j] = 1;\n        for(int h = 1; h <= i; h++)\n          suff[h] = std::min(suff[h], v[j]);\n        for(int h = 1; h <= n; h++)\n          if(edge[j][h] == 1)\n            affect[h] = i;\n        break;\n      }\n    }\n  }\n\n  for(int i = 1; i <= n; i++)\n    std::cout << sol[i] << \" \";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 2010;\nconst int NN = 2010;\n\nunsigned long long one = 1;\nunsigned long long g[N][NN];\nunsigned long long was[NN]; \n\nbool alive[N]; \nbool can_put[N]; \n\nint a[N];\nint x[N]; \n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", a + i);\n  }\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      if (__gcd(a[i], a[j]) > 1) {\n        g[i][j >> 6] |= (one << (j & 63));\n        g[j][i >> 6] |= (one << (i & 63));\n      }\n    }\n  }\n  int nn = ((n - 1) >> 6) + 1;\n  for (int i = 0; i < n; i++) {\n    alive[i] = true;\n    can_put[i] = true;\n  }\n  for (int it = 0; it < n; it++) {\n    for (int i = 0; i < nn; i++) {\n      was[i] = 0;\n    }\n    for (int i = 0; i < n; i++) {\n      if (!alive[i]) {\n        was[i >> 6] |= (one << (i & 63));\n      }\n    }\n    int best = -1;\n    for (int i = 0; i < n; i++) {\n      if (was[i >> 6] & (one << (i & 63))) {\n        continue;\n      }\n      int b = 0, e = 1;\n      x[0] = i;\n      was[i >> 6] |= (one << (i & 63));\n      while (b < e) {\n        for (int j = 0; j < nn; j++) {\n          if ((g[x[b]][j] & was[j]) != g[x[b]][j]) { \n            for (int u = j * 64; u < (j + 1) * 64; u++) { \n              if (g[x[b]][u >> 6] & (one << (u & 63))) {\n                if (!(was[u >> 6] & (one << (u & 63)))) {\n                  was[u >> 6] |= (one << (u & 63));\n                  x[e++] = u;\n                }\n              }\n            }\n          }\n        }\n        b++;\n      }\n      int cur = -1;\n      for (int j = 0; j < e; j++) {\n        if (!can_put[x[j]]) {\n          continue;\n        }\n        if (cur == -1 || a[x[j]] < a[cur]) {\n          cur = x[j];\n        }\n      }\n      if (best == -1 || (cur != -1 && a[cur] > a[best])) {\n        best = cur;\n      }\n    }\n    if (it > 0) putchar(' ');\n    printf(\"%d\", a[best]);\n    alive[best] = false;\n    for (int i = 0; i < n; i++) {\n      if (!alive[i]) {\n        continue;\n      }\n      if (g[best][i >> 6] & (one << (i & 63))) {\n        can_put[i] = true;\n      } else {\n        if (a[best] < a[i]) {\n          can_put[i] = false;\n        }\n      }\n    }\n  }\n  printf(\"\\n\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 0x3f3f3f3f;\n\nint GCD(int a, int b){\n\treturn b == 0 ? a : GCD(b, a % b);\n}\n\nint a[2010];\nint gcd[2010][2010];\nvector <int> from[2010];\nint ans[2010];\nint c[2010], in_ans[2010], minj[2010], last[2010], best[2010];\nint C, n;\n\nvoid dfs(int x){\n\tc[x] = C;\n\tfor (int i = 0; i < from[x].size(); i++){\n\t\tint v = from[x][i];\n\t\tif (c[v] != -1 || in_ans[v]) continue;\n\t\tdfs(v);\n\t}\n}\n\nvoid color(){\n\tC = 0;\n\tmemset(c, -1, sizeof(c));\n\tfor (int i = 0; i < n; i++){\n\t\tif (c[i] != -1 || in_ans[i]) continue;\n\t\tdfs(i), C++;\n\t}\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++){\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tgcd[i][j] = GCD(a[i], a[j]) != 1;\n\t\t\tif (gcd[i][j]) from[i].push_back(j), from[j].push_back(i);\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++){\n\t\tminj[i] = INF, last[i] = -1;\n\t}\n\tint tot = 0;\n\twhile (tot != n){\n\t\tcolor();\n\t\tmemset(best, -1, sizeof(best));\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tif (in_ans[i]) continue;\n\t\t\tif (minj[last[i] + 1] < a[i]) continue;\n\t\t\tif (best[c[i]] == -1 || a[best[c[i]]] > a[i]) best[c[i]] = i;\n\t\t}\n\t\tint id = -1;\n\t\tfor (int i = 0; i < C; i++){\n\t\t\tif (best[i] == -1) continue;\n\t\t\tif (id == -1 || a[id] < a[best[i]]) id = best[i];\n\t\t}\n\t\tin_ans[id] = 1, ans[tot++] = a[id];\n\t\tfor (int i = 0; i < tot; i++){\n\t\t\tminj[i] = min(minj[i], a[id]);\n\t\t}\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tif (gcd[id][i]) last[i] = tot - 1;\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++){\n\t\tprintf(\"%d \", ans[i]);\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define db double\n\nusing namespace std;\nconst int N=2000+10;\nint rd()\n{\n    int x=0,w=1;char ch=0;\n    while(ch<'0'||ch>'9'){if(ch=='-') w=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+(ch^48);ch=getchar();}\n    return x*w;\n}\nint to[N<<5],nt[N<<5],hd[N<<4],tot=1;\nvoid adde(int x,int y)\n{\n\t++tot,to[tot]=y,nt[tot]=hd[x],hd[x]=tot;\n\t++tot,to[tot]=x,nt[tot]=hd[y],hd[y]=tot;\n}\nint n,t,a[N],vs[N],ti,ban[N<<4],dl[N],sq[N],ts,ff[N];\nint findf(int x){return ff[x]==x?x:ff[x]=findf(ff[x]);}\nvector<int> an[N],ls,nl;\nmap<int,int> id;\n\nint main()\n{\n\tn=rd(),t=n;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\ta[i]=rd();\n\t\tint x=a[i],sqt=sqrt(x);\n\t\tfor(int j=2;j<=sqt;++j)\n\t\t\tif(x%j==0)\n\t\t\t{\n\t\t\t\tif(!id[j]) id[j]=++t;\n\t\t\t\tadde(i,id[j]);\n\t\t\t\twhile(x%j==0) x/=j;\n\t\t\t}\n\t\tif(x>1)\n\t\t{\n\t\t\tif(!id[x]) id[x]=++t;\n\t\t\tadde(i,id[x]);\n\t\t}\n\t}\n\tmemset(vs,0x3f3f3f,sizeof(vs));\n\ta[0]=1<<30;\n\tint rs=n;\n\twhile(rs--)\n\t{\n\t\tint sx=0;\n\t\tfor(int i=1;i<=n;++i)\n\t\t\tif(!dl[i]&&vs[sx]>vs[i]) sx=i;\n\t\tif(!sx)\n\t\t{\n\t\t\tfor(int i=1;i<=n;++i)\n\t\t\t\tif(!dl[i]&&a[sx]>a[i]) sx=i;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor(int i=1;i<=n;++i)\n\t\t\t\tif(!dl[i]&&vs[i]==vs[sx]&&a[sx]>a[i]) sx=i;\n\t\t}\n\t\tdl[sx]=1,sq[++ts]=sx;\n\t\tvs[sx]=vs[0];\n\t\tfor(int i=hd[sx];i;i=nt[i])\n\t\t{\n\t\t\tint y=to[i];\n\t\t\tban[i>>1]=1;\n\t\t\tfor(int j=hd[y];j;j=nt[j])\n\t\t\t{\n\t\t\t\tif(ban[j>>1]) continue;\n\t\t\t\tint z=to[j];\n\t\t\t\tvs[z]=min(vs[z],ts);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;++i) ff[i]=i,an[i].push_back(a[i]);\n\twhile(ts)\n\t{\n\t\tint x=sq[ts--];\n\t\tls.clear();\n\t\tfor(int i=hd[x];i;i=nt[i])\n\t\t{\n\t\t\tint y=to[i];\n\t\t\tban[i>>1]=0;\n\t\t\tfor(int j=hd[y];j;j=nt[j])\n\t\t\t{\n\t\t\t\tif(ban[j>>1]) continue;\n\t\t\t\tint z=to[j];\n\t\t\t\tif((z=findf(z))!=findf(x))\n\t\t\t\t{\n\t\t\t\t\tint nn=ls.size(),mm=an[z].size(),p=0,q=0,r=0;\n\t\t\t\t\tnl.clear(),nl.resize(nn+mm);\n\t\t\t\t\twhile(p<nn&&q<mm)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(ls[p]>an[z][q]) nl[r++]=ls[p],++p;\n\t\t\t\t\t\telse nl[r++]=an[z][q],++q;\n\t\t\t\t\t}\n\t\t\t\t\twhile(p<nn) nl[r++]=ls[p],++p;\n\t\t\t\t\twhile(q<mm) nl[r++]=an[z][q],++q;\n\t\t\t\t\tls=nl;\n\t\t\t\t\tff[z]=x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint nn=ls.size();\n\t\tfor(int i=0;i<nn;++i) an[x].push_back(ls[i]);\n\t}\n\tls.clear();\n\tfor(int i=1;i<=n;++i)\n\t\tif(findf(i)==i)\n\t\t{\n\t\t\tint nn=ls.size(),mm=an[i].size(),p=0,q=0,r=0;\n\t\t\tnl.clear(),nl.resize(nn+mm);\n\t\t\twhile(p<nn&&q<mm)\n\t\t\t{\n\t\t\t\tif(ls[p]>an[i][q]) nl[r++]=ls[p],++p;\n\t\t\t\telse nl[r++]=an[i][q],++q;\n\t\t\t}\n\t\t\twhile(p<nn) nl[r++]=ls[p],++p;\n\t\t\twhile(q<mm) nl[r++]=an[i][q],++q;\n\t\t\tls=nl;\n\t\t}\n\tfor(int i=0;i<n;++i) printf(\"%d \",ls[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define FOR(i,a,b) for (register int i=(a);i<=(b);i++)\n#define For(i,a,b) for (register int i=(a);i>=(b);i--)\n#define mem(i,j) memset(i,j,sizeof(i))\n#define GO(u) for (register int j=f[u];j!=-1;j=nxt[j])\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define MP make_pair\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\nconst int N=2020;\nint n,a[N],vis[N],l[N],r[N],line[N][N],cnt=0,ans[N];\nvector<int> vec[N];\npriority_queue <pii> q;\ninline int read()\n{\n\tint x=0,f=1;\n\tchar c=getchar();\n\twhile (c<'0'||c>'9') {if (c=='-') f=-1;c=getchar();}\n\twhile (c>='0'&&c<='9') {x=(x<<1)+(x<<3)+c-'0';c=getchar();}\n\treturn f*x;\n}\ninline void write(int x)\n{\n\tif (x<0) putchar('-'),x=-x;\n\tif (x>9) write(x/10);\n\tputchar(x%10+'0');\n\treturn;\n}\ninline int GCD(int x,int y)\n{\n\tif (!y) return x;\n\tif (x<y) return GCD(y,x);\n\treturn GCD(y,x%y);\n}\ninline void dfs(int u)\n{\n\tvis[u]=1;\n\tline[cnt][++r[cnt]]=u;\n\tFOR(i,0,(int)vec[u].size()-1)\n\t{\n\t\tint v=vec[u][i];\n\t\tif (vis[v]) continue;\n\t\tdfs(v);\n\t}\n\treturn;\n}\nbool cmp(const int x,const int y) {return a[x]<a[y];}\nint main()\n{\n\tn=read();\n\tFOR(i,1,n) a[i]=read();\n\tFOR(i,1,n) FOR(j,1,n) if (i!=j) if (GCD(a[i],a[j])>1) vec[i].pb(j);\n\tFOR(i,1,n) sort(vec[i].begin(),vec[i].end(),cmp);\n\tFOR(i,1,n) if (!vis[i]) {cnt++;l[cnt]=1,r[cnt]=0;dfs(i);}\n\tFOR(i,1,cnt) q.push(MP(a[line[i][l[i]]],i));\n\twhile (q.size())\n\t{\n\t\tpii tmp=q.top();\n\t\tq.pop();\n\t\tans[++ans[0]]=tmp.fi;\n\t\tif (l[tmp.se]<=r[tmp.se])\n\t\t{\n\t\t\tl[tmp.se]++;\n\t\t\tq.push(MP(a[line[tmp.se][l[tmp.se]]],tmp.se));\n\t\t}\n\t}\n\tFOR(i,1,n) write(ans[i]),putchar(' ');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define dbug(x) cout<<#x<<\"=\"<<x<<endl\nusing namespace std;\ntemplate <typename T> void read(T &t) {\n\tt=0; char ch=getchar(); int f=1;\n\twhile ('0'>ch||ch>'9') { if (ch=='-') f=-1; ch=getchar(); }\n\tdo {(t*=10)+=ch-'0';ch=getchar();} while ('0'<=ch&&ch<='9'); t*=f;\n}\nconst int maxn=2010;\nint n,a[maxn],vis[maxn],tot,in[maxn];\npriority_queue<int> q1; // big\nqueue<int> q2;\nvector<int> g[maxn],h[maxn],ans;\nint gcd(int x,int y) {\n\tif (!x||!y) return x+y;\n\treturn gcd(y,x%y);\n}\nvoid dfs(int u) {\n\tvis[u]=1;\n\tfor (int i=0,v;i<g[u].size();i++) {\n\t\tv=g[u][i];\n\t\tif (vis[v]) continue;\n\t\th[u].push_back(v);\n\t\tin[v]++; dfs(v);\n\t}\n}\nint main() {\n\t//freopen(\"1.txt\",\"r\",stdin);\n\tread(n); int u,v;\n\tfor (int i=1;i<=n;i++) read(a[i]);\n\tsort(a+1,a+n+1);\n\tfor (int i=1;i<=n;i++)\n\tfor (int j=i+1;j<=n;j++)\n\t\tif (gcd(a[i],a[j])>1)\n\t\t\tg[i].push_back(j),g[j].push_back(i);\n\tfor (int i=1;i<=n;i++)\n\t\tif (!vis[i]) dfs(i);\n\tfor (int i=1;i<=n;i++)\n\t\tif (in[i]==0) q1.push(i);\n\twhile (!q1.empty()) {\n\t\tu=q1.top(); q1.pop(); ans.push_back(u);\n\t\tfor (int j=0;j<h[u].size();j++) {\n\t\t\tv=h[u][j]; in[v]--;\n\t\t\tif (in[v]==0) q1.push(v);\n\t\t}\n\t}\n\tfor (int i=1;i<=n;i++) printf(\"%d \",a[ans[i-1]]); printf(\"\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n//author_name:Lebron \n//date:2018/11/18\n//title:AGC 010 E Rearranging\n//ÒòÎªÇÓÅ³£¬ËùÒÔÌÓ±ÜÉúÃü£¬ÒÔ²»µÖ¿¹ÔÚ×îºÚ°µµÄ³ÁÂÙÖÐÉú³ö½¾°Á£¬ÒòÎª½¾°Á£¬ËùÒÔ²»Ñ¡ÔñÉú£¬ËùÒÔ¾Ü³â´Ö±ÉµÄÀÖ¹ÛÖ÷Òå¡£\n//Ìì²ÅµÄ±¯¾çµØÓÚ±»Ð¡¶øÊæÊÊµÄÃûÍûËùÊø¸¿¡£\n//It's human to lie. Most of the time we can't even be honest with ourselves.\n\nint ar[2020];\nvector<int> graph[2020];\nbool used[2020];\n\ninline int gcd(int a,int b)\n{\n\treturn b?gcd(b,a%b):a;\n}\n\nvector<int> run_merge(vector<int> a,vector<int> b)\n{\n\tvector<int> ret;\n\tint it1=0,it2=0;\n\twhile(it1<a.size()||it2<b.size())\n\t{\n\t\tif(it1==a.size())\n\t\t{\n\t\t\tret.push_back(b[it2]);\n\t\t\tit2++;\n\t\t}\n\t\telse if(it2==b.size())\n\t\t{\n\t\t\tret.push_back(a[it1]);\n\t\t\tit1++;\n\t\t}\n\t\telse if(a[it1]>b[it2])\n\t\t{\n\t\t\tret.push_back(a[it1]);\n\t\t\tit1++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tret.push_back(b[it2]);\n\t\t\tit2++;\n\t\t}\n\t}\n\treturn ret;\n}\n\nvector<int> dfs(int u)\n{\n\tvector<int> here;\n\tused[u]=true;\n\tfor(int i=0;i<graph[u].size();i++)\n\t{\n\t\tint to=graph[u][i];\n\t\tif(used[to]) continue;\n\t\tvector<int> v2=dfs(to);\n\t\there=run_merge(here,v2);\n\t}\n\there.insert(here.begin(),u);\n\treturn here;\n}\n\nint n;\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin>>n;\n\tfor(int i=1;i<=n;i++)\n\t\tcin>>ar[i];\n\tsort(ar+1,ar+1+n);\n\t\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\tif(gcd(ar[i],ar[j])>1)\n\t\t\t{\n\t\t\t\tgraph[i].push_back(j);\n\t\t\t\tgraph[j].push_back(i);\n\t\t\t}\n\t\n\tvector<int> ans;\n\tfor(int i=1;i<=n;i++)\tif(!used[i])\n\t{\n\t\tvector<int> here=dfs(i);\n\t\tans=run_merge(ans,here);\n\t}\n\tfor(int i=0;i<ans.size();i++)\n\t\tcout<<ar[ans[i]]<<\" \";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int nmax = 2009;\n\nint boss[nmax] , head[nmax] , now[nmax] , used[nmax] , in[nmax] , x[nmax] , blocked[nmax];\nvector < int > g[nmax] , oneway[nmax];\nint i , j , n , first , last , bst;\n\nint gcd(int a , int b)\n{\n    if (b == 0) return a;\n    return gcd(b , a % b);\n}\n\nvoid dfs(int act)\n{\n    used[act] = 1;\n\n    for (int i = 0 ; i < g[act].size() ; ++i)\n    {\n        int nxt = g[act][i];\n        if (used[nxt]) continue;\n        dfs(nxt);\n    }\n}\n\nvoid dfs2(int act)\n{\n    now[act] = 1;\n\n    for (int i = 0 ; i < g[act].size() ; ++i)\n    {\n        int nxt = g[act][i];\n        if (now[nxt]) continue;\n        dfs2(nxt);\n    }\n}\n\nvoid readData()\n{\n    cin >> n;\n    for (i = 1 ; i <= n ; ++i)\n    cin >> x[i];\n\n    for (i = 1 ; i <= n ; ++i)\n    for (j = i + 1 ; j <= n ; ++j)\n    if (2 <= gcd(x[i] , x[j]))\n    {\n        g[i].push_back(j);\n        g[j].push_back(i);\n    }\n\n    first = 1 , last = 0;\n    for (i = 1 ; i <= n ; ++i)\n    {\n        if (used[i]) continue;\n        dfs(i);\n        head[++last] = i , boss[last] = 0;\n    }\n    x[0] = 1000000000;\n}\n\nint walk(int act , int forced)\n{\n    int ret = 0;\n    now[act] = 1;\n\n    for (int i = 0 ; i < g[act].size() ; ++i)\n    {\n        int nxt = g[act][i];\n        if (blocked[nxt]) continue;\n        if (now[nxt]) continue;\n        ret = min(ret , walk(nxt , forced));\n    }\n\n    if (forced == 0) return (x[act] < x[ret]) ? act : ret;\n    else\n    {\n        if (2 <= gcd(x[act] , forced)) return (x[act] < x[ret]) ? act : ret;\n        else return ret;\n    }\n}\n\nvoid solve(int k)\n{\n    vector < int > sons;\n    int root = head[k];\n    memset(now , 0 , sizeof(now));\n\n    root = walk(root , x[boss[k]]);\n\n    for (int i = 0 ; i < g[root].size() ; ++i)\n    {\n        int nxt = g[root][i];\n        if (blocked[nxt]) continue;\n        sons.push_back(nxt);\n    }\n    blocked[root] = 1;\n\n    memset(now , 0 , sizeof(now));\n    for (int i = 0 ; i < sons.size() ; ++i)\n    {\n        int nxt = sons[i];\n        if (now[nxt]) continue;\n        dfs2(nxt);\n\n        oneway[root].push_back(nxt);\n        in[nxt]++;\n\n        head[++last] = nxt;\n        boss[last] = root;\n    }\n}\n\nint main()\n{\n\n//freopen(\"test.in\" , \"r\" , stdin);\n//freopen(\"test.out\" , \"w\" , stdout);\n\nreadData();\nwhile (first <= last) solve(first++);\n\nx[0] = -1000000000;\nmemset(used , 0 , sizeof(used));\nfor (i = 1 ; i <= n ; ++i)\n{\n    bst = 0;\n    for (j = 1 ; j <= n ; ++j)\n    if (used[j] == 0 && in[j] == 0 && x[bst] < x[j]) bst = j;\n\n    used[bst] = 1;\n    cout << x[bst] << \" \";\n\n    for (j = 0 ; j < oneway[bst].size() ; ++j)\n    in[oneway[bst][j]]--;\n}\n\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\nint a[2000];\nint d[2000];\nint f[2000];\nvector <int> v[2000];\nvector <int> w[2000];\n\nint gcd(int a, int b) {\n    if (a % b == 0) {\n        return b;\n    } else {\n        return gcd(b, a % b);\n    }\n}\n\nvoid dfs(int x) {\n    int i;\n    \n    f[x] = 1;\n    \n    for (i = 0; i < v[x].size(); i++) {\n        int y = v[x][i];\n        \n        if (f[y] == 0) {\n            d[y]++;\n            w[x].push_back(y);\n            dfs(y);\n        }\n    }\n}\n\nint main() {\n    int n, i, j;\n    vector <int> ans;\n    priority_queue <int> q;\n    \n    scanf(\"%d\", &n);\n    \n    for (i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n    \n    sort(a, a + n);\n    \n    for (i = 0; i < n; i++) {\n        for (j = i + 1; j < n; j++) {\n            if (gcd(a[i], a[j]) > 1) {\n                v[i].push_back(j);\n                v[j].push_back(i);\n            }\n        }\n    }\n    \n    for (i = 0; i < n; i++) {\n        if (f[i] == 0) {\n            dfs(i);\n            q.push(i);\n        }\n    }\n    \n    while (!q.empty()) {\n        int x = q.top();\n        \n        q.pop();\n        \n        ans.push_back(a[x]);\n        \n        for (i = 0; i < w[x].size(); i++) {\n            int y = w[x][i];\n            \n            d[y]--;\n            \n            if (d[y] == 0) q.push(y);\n        }\n    }\n    \n    for (i = 0; i < n; i++) {\n        if (i > 0) putchar(' ');\n        printf(\"%d\", ans[i]);\n    }\n    puts(\"\");\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define EB emplace_back\n#define gcd std::__gcd\n\ntypedef std::vector <int> vector;\nconst int N = 2054, M = N * N;\n\nint n, E = 0;\nint a[N], to[M], first[N], next[M], deg[N];\nbool used[N];\nvector G[N];\nstd::priority_queue <int> pq;\n\ninline void addedge(int u, int v) {to[++E] = v, next[E] = first[u], first[u] = E, ++deg[v];}\ninline void dfs(int x) {used[x] = true; for (int y : G[x]) if (!used[y]) addedge(x, y), dfs(y);}\n\nint main() {\n\tint i, j, x, y;\n\tscanf(\"%d\", &n);\n\tfor (i = 1; i <= n; ++i) scanf(\"%d\", a + i);\n\tstd::sort(a + 1, a + (n + 1));\n\tfor (i = 1; i < n; ++i)\n\t\tfor (j = i + 1; j <= n; ++j)\n\t\t\tif (gcd(a[i], a[j]) > 1) G[i].EB(j), G[j].EB(i);\n\tfor (i = 1; i <= n; ++i) if (!used[i]) dfs(i);\n\tfor (i = 1; i <= n; ++i) if (!deg[i]) pq.emplace(i);\n\tfor (i = 1; i <= n; ++i) {\n\t\tprintf(\"%d%c\", a[x = pq.top()], i == n ? 10 : 32), pq.pop();\n\t\tfor (j = first[x]; j; j = next[j])\n\t\t\tif (!--deg[y = to[j]]) pq.emplace(y);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <queue>\n#include <cstdio>\nusing namespace std;\n#define N 2005\n#define V 40005\n#define Inf (1<<30)\nint lastNotCoprime[N];\nint minOnSuff[N];\nint a[N]; \nint ans[N];\nbool b[N][N];\nint comp[N];\nint C;\nint bestForCol[N];\nmap<int,int> primeId;\nvector<int> g[V]; \nint n,m;\nbool inAns[N];\nint ansSz;\nint gcd(int a,int b){\n\tif(b==0){\n\t\treturn a;\n\t}\n\treturn gcd(b,a%b);\n}\nint getId(int p){\n\tif(primeId.count(p)>0){\n\t\treturn primeId[p];\n\t}\n\tprimeId[p]=m;\n\treturn m++;\n}\nvoid dfs(int v){\n\tcomp[v]=C;\n\tint u;\n\tfor(int i=0;i<(int)g[v].size();i++){\n\t\tu=g[v][i];\n\t\tif(comp[u]!=-1){\n\t\t\tcontinue;\n\t\t}\n\t\tif(u<n&&inAns[u]){\n\t\t\tcontinue;\n\t\t}\n\t\tdfs(u);\n\t}\n}\nvoid colors(){\n\tfor(int i=0;i<m;i++){\n\t\tcomp[i]=-1;\n\t}\n\tC=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(inAns[i]){\n\t\t\tcontinue;\n\t\t}\n\t\tif(comp[i]!=-1){\n\t\t\tcontinue;\n\t\t}\n\t\tdfs(i);\n\t\tC++;\n\t}\n}\nint mn(int a,int b){\n\treturn a<b?a:b;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tm=n;\n\tint x,id;\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d\",&a[i]);\n\t\tx=a[i];\n\t\tfor(int j=2;j*j<=x;j++){\n\t\t\tif(x%j!=0){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tid=getId(j);\n\t\t\tg[i].push_back(id);\n\t\t\tg[id].push_back(i);\n\t\t\twhile(x%j==0){\n\t\t\t\tx/=j;\n\t\t\t}\n\t\t}\n\t\tif(x>1){\n\t\t\tid=getId(x);\n\t\t\tg[i].push_back(id);\n\t\t\tg[id].push_back(i);\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=i+1;j<n;j++){\n\t\t\tif(gcd(a[i],a[j])>1){\n\t\t\t\tb[i][j]=b[j][i]=1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tlastNotCoprime[i]=-1;\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tminOnSuff[i]=Inf;\n\t}\n\twhile(ansSz<n){\n\t\tcolors();\n\t\tfor(int i=0;i<C;i++){\n\t\t\tbestForCol[i]=-1;\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(inAns[i]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(minOnSuff[lastNotCoprime[i]+1]<a[i]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(bestForCol[comp[i]]==-1||a[bestForCol[comp[i]]]>a[i]){\n\t\t\t\tbestForCol[comp[i]]=i;\n\t\t\t}\n\t\t}\n\t\tid=-1;\n\t\tfor(int i=0;i<C;i++){\n\t\t\tif(bestForCol[i]==-1){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(id==-1||a[bestForCol[i]]>a[id]){\n\t\t\t\tid=bestForCol[i];\n\t\t\t}\n\t\t}\n\t\tans[ansSz++]=a[id];\n\t\tinAns[id]=1;\n\t\tfor(int i=0;i<ansSz;i++){\n\t\t\tminOnSuff[i]=mn(minOnSuff[i],a[id]);\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(b[id][i]){\n\t\t\t\tlastNotCoprime[i]=ansSz-1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tprintf(\"%d \",ans[i]);\n\t}\n\tputs(\"\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <math.h>\n#include <string.h>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <cassert>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <sstream>\n#include <functional>\n#include <iomanip>\n//#include <windows.h>  //Should be deleted when using AtCoder&POJ\nusing namespace std;\n\n#define ll long long\n#define pii pair<int,int>\n#define qi ios::sync_with_stdio(0)\n/**==Info==\n*Program:1\n*Problem:Rearranging\n*Date:2018-11-17\n*Algorithm:Teacher's Graph and greedy\n*Stats:Unknown*/\n\nbool debug=false;\n\nint n;\nint a[1005];\n\nvector<int> nei[1005];\n\nint fa[1005];\n\nbool visit[1005];\n\nint getFa(int pos){\n\tif(fa[pos]==pos) return pos;\n\treturn fa[pos]=getFa(fa[pos]);\n}\n\nvoid Union(int x,int y){\n\tif(getFa(x)==getFa(y)){\n\t\treturn;\n\t}\n\t\n\tfa[getFa(x)]=getFa(y);\n}\n\nvector<int> path;\n\nvoid dfs(int pos){\n\tvisit[pos]=true;\n\tpath.push_back(pos);\n\tint mn=-1;\n\tfor(int i=0;i<nei[pos].size();i++){\n\t\tif(!visit[nei[pos][i]] && (mn==-1||a[nei[pos][i]]<a[nei[pos][mn]])){\n\t\t\tmn=i;\n\t\t}\n\t}\n\t\n\tif(mn==-1){\n\t\treturn;\n\t}\n\tdfs(nei[pos][mn]);\n}\n\nvoid solve(int x){\n\t//Solve the CC within <x>\n\tint f=getFa(x);\n\tvector<pii> pes;\n\tfor(int i=0;i<n;i++){\n\t\tif(fa[i]==f){\n\t\t\tpes.push_back(make_pair(a[i],i));\n\t\t}\n\t}\n\t\n\tsort(pes.begin(),pes.end());\n\t\n\tfor(int i=0;i<pes.size();i++){\n\t\tif(!visit[pes[i].second]){\n\t\t\tdfs(pes[i].second);\n\t\t}\n\t}\n}\n\nvector<vector<int>> shits;\n\nint main(int argc,char* argv[]){\n\t\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>a[i];\n\t}\n\t\n\tfor(int i=0;i<n;i++){\n\t\tfa[i]=i;\n\t}\n\t\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(__gcd(a[i],a[j])!=1){\n\t\t\t\tnei[i].push_back(j);\n\t\t\t\tUnion(i,j);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i=0;i<n;i++){\n\t\tif(!visit[i]){\n\t\t\tpath.clear();\n\t\t\tsolve(i);\n\t\t\tshits.push_back(path);\n\t\t}\n\t}\n\t\n\tsort(shits.begin(),shits.end());\n\treverse(shits.begin(),shits.end());\n\t \n\tfor(vector<int> v:shits){\n\t\tfor(int p:v){\n\t\t\tcout<<a[p]<<\" \";\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pb push_back\n#define all(x) x.begin(), x.end()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nconst int N = 2000 + 10;\nconst int MOD = 1000000007;\nconst int LOG = 20;\nconst int INF = 1000000010;\nconst int delta = 11353;\n\nint n;\nvi G[N], a;\nmap<int, int> mp;\nint mark[N];\nint mark2[N], mark3[N];\n\nvoid DFS(int v){\n\tmark[v] = 1;\n\tfor (auto u:G[v]){\n\t\tif ((mark[u] == 0) && (mark3[u] == 0)){\n\t\t\tDFS(u);\n\t\t}\n\t}\n}\nint GCD(int x, int y){\n\tif (x == 0 || y == 0) return (x + y);\n\tif (x == 1 || y == 1) return 1;\n\tif (x < y) swap(x, y);\n\treturn GCD(y, x % y);\n}\n\nint32_t main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++){\n\t\tint x;\n\t\tcin >> x;\n\t\tmp[x] ++;\n\t\ta.pb(x);\n\t}\n\tsort(all(a));\n\ta.resize(unique(all(a)) - a.begin());\n\tfor (int i = 0; i < a.size(); i++) for (int j = 0; j < i; j++) if (GCD(a[i], a[j]) != 1){\n\t\tG[i].pb(j), G[j].pb(i);\n\t}\n\t//cout << GCD(7, 11) << '\\n';\n\tvi ans;\n\tint last = 0;\n\tn = a.size();\n\tfor (int i = 0; i < n; i++){\n\t\tif (!mark[i]) DFS(i), mark2[i] = 1;\n\t}\n\tfor (int i = 0; i < n; i++){\n\t\tmemset(mark, 0, sizeof mark);\n\t\tint mx = 0;\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tif (mark2[j]) mx = j;\n\t\t//\tcout << j << ' ' << mark2[j] << '\\n';\n\t\t}\n\t\tans.pb(a[mx]);\n\t\tsort(all(G[mx]));\n\t\tmark2[mx] = 0;\n\t\tmark3[mx] = 1;\n\t\t//cout << mx << '\\n';\n\t\tfor (auto u:G[mx]){\n\t\t\tif (mark3[u] == 0 && mark[u] == 0){\n\t\t\t\tmark2[u] = 1;\n\t\t\t//\tcout << u << '\\n';\n\t\t\t\tDFS(u);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < ans.size(); i++){\n\t\tint u = ans[i];\n\t\tfor (int i = 0; i < mp[u]; i++) cout << u << ' ';\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio> \n#include<algorithm>\n#include<cstring>\n#include<cmath>\n#include<map>\nusing namespace std;\n#define fo(i,j,k) for(i=j;i<=k;i++)\n#define fd(i,j,k) for(i=j;i>=k;i--)\n#define cmax(a,b) (a=(a>b)?a:b)\n#define cmin(a,b) (a=(a<b)?a:b)\ntypedef long long ll;\ntypedef double db;\nconst int N=2e5+5;\nint b[N],nxt[N],fst[N],tt,pd[N],vis[N],du[N],n,a[N],i,j;\nvoid cr(int x,int y)\n{\n\ttt++;\n\tdu[y]++;\n\tb[tt]=y;\n\tnxt[tt]=fst[x];\n\tfst[x]=tt;\n}\nint gcd(int a,int b)\n{\n\tif (!b) return a;\n\treturn gcd(b,a%b);\n}\nvoid dfs(int x)\n{\n\tpd[x]=1;\n\tint i;\n\tfo(i,1,n)\n\tif (!pd[i]&&gcd(a[i],a[x])>1)\n\t{\n\t\tcr(x,i);\n\t\tdfs(i);\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfo(i,1,n) scanf(\"%d\",a+i);\n\tsort(a+1,a+1+n);\n\tfo(i,1,n) if (!pd[i])\n\t\tdfs(i);\n\tfo(i,1,n)\n\t{\n\t\tfd(j,n,1)\n\t\tif (!du[j]&&!vis[j])\n\t\t{\n\t\t\tprintf(\"%d \",a[j]);\n\t\t\tvis[j]=1;\n\t\t\tfor(int p=fst[j];p;p=nxt[p]) du[b[p]]--;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <cctype>\n#include <queue>\n#include <algorithm>\nusing namespace std;\ntypedef long long lint;\n#define cout cerr\n#define ni (next_num<int>())\ntemplate<class T>inline T next_num(){\n\tT i=0;char c;\n\twhile(!isdigit(c=getchar())&&c!='-');\n\tbool flag=c=='-';\n\tflag?c=getchar():0;\n\twhile(i=i*10-'0'+c,isdigit(c=getchar()));\n\treturn flag?-i:i;\n}\ntemplate<class T1,class T2>inline void apmax(T1 &a,const T2 &b){if(a<b)a=b;}\ntemplate<class T1,class T2>inline void apmin(T1 &a,const T2 &b){if(b<a)a=b;}\nconst int N=2010;\nint gcd(int a,int b){\n\treturn b?gcd(b,a%b):a;\n}\nbool con[N][N];\nint n,a[N];\nstruct cmp1{\n\tinline bool operator () (int x,int y){\n\t\treturn a[x]>a[y];\n\t}\n};\nstruct cmp2{\n\tinline bool operator () (int x,int y){\n\t\treturn a[x]<a[y];\n\t}\n};\nint dfn[N],tim=0;\nbool vis[N];\ninline void work(int x){\n\tpriority_queue<int,vector<int>,cmp1>q;\n\tvis[x]=true,q.push(x);\n\twhile(!q.empty()){\n\t\tx=q.top();\n\t\tq.pop();\n\t\tdfn[x]=++tim;\n\t\tfor(int v=1;v<=n;v++){\n\t\t\tif(con[x][v]&&!vis[v]){\n\t\t\t\tvis[v]=true,q.push(v);\n\t\t\t}\n\t\t}\n\t}\n}\nint deg[N];\ninline void topsort(){\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif(con[i][j]&&dfn[i]<dfn[j]){\n\t\t\t\tdeg[j]++;\n\t\t\t}\n\t\t}\n\t}\n\tpriority_queue<int,vector<int>,cmp2>q;\n\tfor(int i=1;i<=n;i++){\n\t\tif(deg[i]==0){\n\t\t\tq.push(i);\n\t\t}\n\t}\n\twhile(!q.empty()){\n\t\tint x=q.top();\n\t\tq.pop();\n\t\tprintf(\"%d \",a[x]);\n\t\tfor(int v=1;v<=n;v++){\n\t\t\tif(con[x][v]&&dfn[x]<dfn[v]&&(--deg[v])==0){\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n}\ninline bool lcmp(int x,int y){\n\treturn a[x]<a[y];\n}\nint lst[N];\nint main(){\n\tn=ni;\n\tfor(int i=1;i<=n;i++){\n\t\ta[i]=ni;\n\t\tlst[i]=i;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tcon[i][j]=gcd(a[i],a[j])!=1;\n\t\t}\n\t}\n\tmemset(vis,0,sizeof(vis));\n\tsort(lst+1,lst+n+1,lcmp);\n\tfor(int i=1;i<=n;i++){\n\t\tif(!vis[lst[i]]){\n\t\t\twork(lst[i]);\n\t\t}\n\t}\n\ttopsort();\n\tputchar('\\n');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define db double\n\nusing namespace std;\nconst int N=2000+10;\nint rd()\n{\n    int x=0,w=1;char ch=0;\n    while(ch<'0'||ch>'9'){if(ch=='-') w=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+(ch^48);ch=getchar();}\n    return x*w;\n}\nint to[N<<5],nt[N<<5],hd[N<<4],tot=1;\nvoid adde(int x,int y)\n{\n\t++tot,to[tot]=y,nt[tot]=hd[x],hd[x]=tot;\n\t++tot,to[tot]=x,nt[tot]=hd[y],hd[y]=tot;\n}\nint n,t,a[N],vs[N<<4],ti,ban[N<<4],dl[N],sq[N],ts,ff[N];\nint findf(int x){return ff[x]==x?x:ff[x]=findf(ff[x]);}\nvector<int> an[N],ls,nl;\nmap<int,int> id;\n\nint main()\n{\n\tn=rd(),t=n;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\ta[i]=rd();\n\t\tint x=a[i],sqt=sqrt(x);\n\t\tfor(int j=2;j<=sqt;++j)\n\t\t\tif(x%j==0)\n\t\t\t{\n\t\t\t\tif(!id[j]) id[j]=++t;\n\t\t\t\tadde(i,id[j]);\n\t\t\t\twhile(x%j==0) x/=j;\n\t\t\t}\n\t\tif(x>1)\n\t\t{\n\t\t\tif(!id[x]) id[x]=++t;\n\t\t\tadde(i,id[x]);\n\t\t}\n\t}\n\tint rs=n;\n\twhile(rs)\n\t{\n\t\tint sx=1;\n\t\twhile(sx<=n&&(dl[sx]||vs[sx]<ti)) ++sx;\n\t\tif(sx>n)\n\t\t{\n\t\t\t++ti;\n\t\t\tfor(int i=1;i<=t;++i) vs[i]=ti;\n\t\t\tcontinue;\n\t\t}\n\t\t--rs;\n\t\tfor(int i=1;i<=n;++i)\n\t\t\tif(!dl[i]&&vs[i]==ti&&a[sx]>a[i]) sx=i;\n\t\tdl[sx]=1,sq[++ts]=sx;\n\t\t++ti;\n\t\tfor(int i=hd[sx];i;i=nt[i])\n\t\t{\n\t\t\tint y=to[i];\n\t\t\tban[i>>1]=1;\n\t\t\tfor(int j=hd[y];j;j=nt[j])\n\t\t\t{\n\t\t\t\tif(ban[j>>1]) continue;\n\t\t\t\tint z=to[j];\n\t\t\t\tvs[z]=ti;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;++i) ff[i]=i,an[i].push_back(a[i]);\n\twhile(ts)\n\t{\n\t\tint x=sq[ts--];\n\t\tls.clear();\n\t\tfor(int i=hd[x];i;i=nt[i])\n\t\t{\n\t\t\tint y=to[i];\n\t\t\tban[i>>1]=0;\n\t\t\tfor(int j=hd[y];j;j=nt[j])\n\t\t\t{\n\t\t\t\tif(ban[j>>1]) continue;\n\t\t\t\tint z=to[j];\n\t\t\t\tif((z=findf(z))!=findf(x))\n\t\t\t\t{\n\t\t\t\t\tint nn=ls.size(),mm=an[z].size(),p=0,q=0,r=0;\n\t\t\t\t\tnl.clear(),nl.resize(nn+mm);\n\t\t\t\t\twhile(p<nn&&q<mm)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(ls[p]>an[z][q]) nl[r++]=ls[p],++p;\n\t\t\t\t\t\telse nl[r++]=an[z][q],++q;\n\t\t\t\t\t}\n\t\t\t\t\twhile(p<nn) nl[r++]=ls[p],++p;\n\t\t\t\t\twhile(q<mm) nl[r++]=an[z][q],++q;\n\t\t\t\t\tls=nl;\n\t\t\t\t\tff[z]=x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint nn=ls.size();\n\t\tfor(int i=0;i<nn;++i) an[x].push_back(ls[i]);\n\t}\n\tls.clear();\n\tfor(int i=1;i<=n;++i)\n\t\tif(findf(i)==i)\n\t\t{\n\t\t\tint nn=ls.size(),mm=an[i].size(),p=0,q=0,r=0;\n\t\t\tnl.clear(),nl.resize(nn+mm);\n\t\t\twhile(p<nn&&q<mm)\n\t\t\t{\n\t\t\t\tif(ls[p]>an[i][q]) nl[r++]=ls[p],++p;\n\t\t\t\telse nl[r++]=an[i][q],++q;\n\t\t\t}\n\t\t\twhile(p<nn) nl[r++]=ls[p],++p;\n\t\t\twhile(q<mm) nl[r++]=an[i][q],++q;\n\t\t\tls=nl;\n\t\t}\n\tfor(int i=0;i<n;++i) printf(\"%d \",ls[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint dat[2002];\nvector<int> graph[2002];\nbool visit[2005];\nint n;\n\nint gcd(int a, int b)\n{\n\treturn b ? gcd(b, a % b) : a;\n}\n\nvector<int> merge(vector<vector<int>> vvt, int head)\n{\n\tvector<int> ret;\n\n\tif (head >= 0) ret.push_back(head);\n\n\tpriority_queue<tuple<int, int, int>> pq;\n\n\tfor (int i = 0; i < vvt.size(); i++)\n\t{\n\t\tpq.emplace(vvt[i][0], i, 0);\n\t}\n\n\twhile (pq.empty() == false)\n\t{\n\t\tint val, idx, nxt;\n\t\ttie(val, idx, nxt) = pq.top();\n\t\tpq.pop();\n\t\tret.push_back(val);\n\n\t\tif (nxt + 1 < vvt[idx].size())\n\t\t{\n\t\t\tpq.emplace(vvt[idx][nxt + 1], idx, nxt + 1);\n\t\t}\n\t}\n\n\treturn ret;\n}\n\nvector<int> process(int t)\n{\n\tvector<vector<int>> vvt;\n\tvisit[t] = true;\n\n\tfor (int nxt : graph[t])\n\t{\n\t\tif (visit[nxt]) continue;\n\t\tvvt.emplace_back(process(nxt));\n\t}\n\n\treturn merge(move(vvt), t);\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &dat[i]);\n\t}\n\n\tsort(dat, dat + n);\n\n\tfor (int i = 0; i < n - 1; i++)\n\t{\n\t\tfor (int j = i + 1; j < n; j++)\n\t\t{\n\t\t\tif (gcd(dat[i], dat[j]) > 1)\n\t\t\t{\n\t\t\t\tgraph[i].push_back(j);\n\t\t\t\tgraph[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) sort(graph[i].begin(), graph[i].end());\n\n\tvector<vector<int>> vvt;\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (visit[i]) continue;\n\t\tvvt.emplace_back(process(i));\n\t}\n\n\tauto ret = merge(move(vvt), -1);\n\n\tfor (int t : ret) printf(\"%d \", dat[t]);\n\tprintf(\"\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pp;\ntypedef pair<ll,ll> pll;\nvoid read(int& x){ scanf(\"%d\",&x); }\nvoid read(ll& x){ scanf(\"%lld\",&x); }\ntemplate<typename T,typename... Args>\nvoid read(T& a,Args&... b){ read(a); read(b...); }\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define x first\n#define y second\nint gcd(int a, int b){ return b?gcd(b, a%b):a; }\n\nint n;\n\nint arr[2010];\nvector<int> edge[2010];\n\nvector<int> join_all(int init, vector<vector<int>>& vs){\n    vector<int> ret;\n    priority_queue<pp> pq;\n    if(init != -1) ret.pb(init);\n    int n=vs.size();\n    for(int i=0; i<n; ++i){\n        reverse(all(vs[i]));\n        pq.push(pp{vs[i].back(), i});\n        vs[i].pop_back();\n    }\n    while(pq.size()){\n        int a, b; tie(a, b)=pq.top(); pq.pop();\n        ret.pb(a);\n        if(vs[b].size()) pq.push(pp{vs[b].back(), b}), vs[b].pop_back();\n    }\n    return ret;\n}\n\nbool vis[2010];\nbool vis_dfs[2010];\nint par[2010];\n\nvector<int> comp;\nvoid dfs(int x){\n    vis_dfs[x]=1;\n    comp.pb(x);\n    for(int y:edge[x]) if(!vis[y] && !vis_dfs[y]) dfs(y);\n}\n\nvector<int> dfs2(int x){\n    vis_dfs[x]=1;\n    vis[x]=1;\n    vector<vector<int>> cv;\n    for(int y:edge[x]) if(!vis[y] && !vis_dfs[y]){\n        cv.pb(dfs2(y));\n    }\n    return join_all(arr[x], cv);\n}\n\nvector<int> work_comp(int x){\n    comp.clear(); dfs(x);\n    for(int a:comp) vis_dfs[a]=0;\n    int k=comp.size(), mi=comp[0];\n    for(int i=1; i<k; ++i) if(arr[mi]>arr[comp[i]]) mi=comp[i];\n    vis[mi]=1;\n    return dfs2(mi);\n}\n\nint main()\n{\n\tread(n);\n\tfor(int i=1; i<=n; ++i) read(arr[i]);\n\t\n\tfor(int i=1; i<n; ++i) for(int j=i+1; j<=n; ++j){\n        if(gcd(arr[i], arr[j])!=1){\n            edge[i].pb(j);\n            edge[j].pb(i);\n        }\n\t}\n\t\n\tfor(int i=1; i<=n; ++i)\n        sort(all(edge[i]), [&](const int&a, const int&b){return arr[a]<arr[b]; });\n\t\n\tvector<vector<int>> vs;\n\t\n\tfor(int i=1; i<=n; ++i) if(!vis[i]) vs.pb(work_comp(i));\n    \n    for(int x:join_all(-1, vs)) printf(\"%d \", x);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){return o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){o<<\"sz = \"<<vc.size()<<endl<<\"[\";for(const T& v:vc) o<<v<<\",\";o<<\"]\";return o;}\n\nstruct UnionFind{\n\tint par[2000],rank[2000],mn[2000];\n\tvoid init(int N){rep(i,N) par[i]=i,rank[i]=0,mn[i]=1e9;}\n\tint find(int x){\n\t\tif(par[x]==x) return x;\n\t\treturn par[x]=find(par[x]);\n\t}\n\tbool same(int x,int y){\n\t\treturn find(x)==find(y);\n\t}\n\tvoid unite(int x,int y){\n\t\tx=find(x),y=find(y);\n\t\tif(x==y) return;\n\t\tif(rank[x]<rank[y]) par[x]=y,chmin(mn[y],mn[x]);\n\t\telse{\n\t\t\tpar[y]=x,chmin(mn[x],mn[y]);\n\t\t\tif(rank[x]==rank[y]) rank[x]++;\n\t\t}\n\t}\n}UF;\n\nint N;\nconst int MN=2000;\nint A[MN];\nbool used[MN];\nint ans[MN];\ntypedef vector<int> VI;\nmap<int,VI> p2ids;\nvector<int> r2vs[2000];\n\nbool can[MN];\nint gcd(int x,int y){\n\tif(y==0) return x;\n\treturn gcd(y,x%y);\n}\nint main(){\n\tcin>>N;\n\trep(i,N) cin>>A[i];\n\tsort(A,A+N);\n\trep(i,N){\n\t\tint a=A[i];\n\t\tfor(int x=2;x<=10000;x++){\n\t\t\tif(a%x==0){\n\t\t\t\twhile(a%x==0) a/=x;\n\t\t\t\tp2ids[x].pb(i);\n\t\t\t}\n\t\t}\n\t\tif(a>1){\n\t\t\tp2ids[a].pb(i);\n\t\t}\n\t}\n\trep(i,N) can[i]=1;\n\trep(i,N){\n\t\tUF.init(N);\n\t\tfor(auto it:p2ids){\n\t\t\tconst VI& vc = it.sc;\n\t\t\tint r = -1;\n\t\t\tfor(int v:vc) if(!used[v]){\n\t\t\t\tif(r!=-1) UF.unite(r,v);\n\t\t\t\tr=v;\n\t\t\t}\n\t\t}\n\t\trep(v,N) r2vs[v].clear();\n\t\trep(v,N) if(!used[v]) r2vs[UF.find(v)].pb(v);\n\t\tint mx=0,ag=-1;\n\t\trep(r,N) if(!used[r] && !r2vs[r].empty()){\n\t\t\tVI& vs = r2vs[r];\n\t\t\tint mn=1e9,arg=-1;\n\t\t\tfor(int v:vs) if(can[v]){\n\t\t\t\tif(mn>A[v]){\n\t\t\t\t\tmn=A[v];\n\t\t\t\t\targ=v;\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert(arg!=-1);\n\t\t\tif(mx<mn){\n\t\t\t\tmx=mn;\n\t\t\t\tag=arg;\n\t\t\t}\n\t\t}\n\t\tans[i]=ag;\n\t\tused[ag]=1;\n\t\trep(j,N) if(!used[j]){\n\t\t\tif(gcd(A[ag],A[j])==1){\n\t\t\t\tif(A[ag]<A[j]) can[j]=0;\n\t\t\t}else{\n\t\t\t\tcan[j]=1;\n\t\t\t}\n\t\t}\n\t}\n\trep(i,N) cout<<A[ans[i]]<<\" \";\n\tputs(\"\");\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author majk\n */\n\n#ifndef MAJK_LIB\n#define MAJK_LIB\n\n#include <vector>\n#include <stack>\n#include <iostream>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <functional>\n#include <algorithm>\n#include <numeric>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <array>\n#include <bitset>\nusing namespace std;\n\n#define x first\n#define y second\ntypedef std::pair<int,int> pii; typedef long long ll; typedef unsigned long long ull; typedef unsigned int ui; typedef pair<ui,ui> puu;\n\ntemplate <typename T, typename U> std::istream&operator>>(std::istream&i, pair<T,U>&p) {i >> p.x >> p.y; return i;}\ntemplate<typename T>std::istream&operator>>(std::istream&i,vector<T>&t) {for(auto&v:t){i>>v;}return i;}\ntemplate <typename T, typename U> std::ostream&operator<<(std::ostream&o, const pair<T,U>&p) {o << p.x << ' ' << p.y; return o;}\ntemplate<typename T>std::ostream&operator<<(std::ostream&o,const vector<T>&t) {if(t.empty())o<<'\\n';for(size_t i=0;i<t.size();++i){o<<t[i]<<\" \\n\"[i == t.size()-1];}return o;}\ntemplate<typename T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T> using maxheap = priority_queue<T, vector<T>, less<T>>;\nui logceil(ll x) { return x?8*sizeof(ll)-__builtin_clzll(x):0; }\n\nnamespace std { template<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}}; }\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename F> double bshd(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){l=m;}else{h=m;}}return (l+h)/2;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename F> double bsld(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){h=m;}else{l=m;}}return (l+h)/2;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\n\ntemplate<typename T>class vector2:public vector<vector<T>>{public:vector2(){} vector2(size_t a,size_t b,T t=T()):vector<vector<T>>(a,vector<T>(b,t)){}};\ntemplate<typename T>class vector3:public vector<vector2<T>>{public:vector3(){} vector3(size_t a,size_t b,size_t c,T t=T()):vector<vector2<T>>(a,vector2<T>(b,c,t)){}};\ntemplate<typename T>class vector4:public vector<vector3<T>>{public:vector4(){} vector4(size_t a,size_t b,size_t c,size_t d,T t=T()):vector<vector3<T>>(a,vector3<T>(b,c,d,t)){}};\ntemplate<typename T>class vector5:public vector<vector4<T>>{public:vector5(){} vector5(size_t a,size_t b,size_t c,size_t d,size_t e,T t=T()):vector<vector4<T>>(a,vector4<T>(b,c,d,e,t)){}};\n\n\n#endif\n\nclass ERearranging {\npublic:\n    int N, M, P;\n    vector<vector<int>> Multiples;\n    vector<vector<int>> Factors;\n    map<int, int> Compress;\n    map<int, int> C;\n    vector<int> B;\n    vector<int> Stack;\n    vector<bool> Forbidden;\n    vector<int> CompVisit, PrimeVisit;\n    int CompTime;\n\n    vector<int> component(int value) {\n        ++CompTime;\n        CompVisit[value] = CompTime;\n        vector<int> Q{value};\n        for (int q = 0; q < Q.size(); ++q) {\n            int v = Q[q];\n            for (int f: Factors[v]) {\n                if (PrimeVisit[f] == CompTime) continue;\n                PrimeVisit[f] = CompTime;\n                for (int m: Multiples[f]) {\n                    if (Forbidden[m]) continue;\n                    if (CompVisit[m] == CompTime) continue;\n                    CompVisit[m] = CompTime;\n                    Q.push_back(m);\n                }\n            }\n        }\n        sort(Q.begin(),Q.end());\n        return Q;\n    }\n\n    vector<int> solve(const vector<int> &Component) {\n        vector<vector<int>> Others;\n        vector<bool> Used(N, false);\n\n        for (int val: Component) {\n            if (!Used[val]) {\n                auto cc = component(val);\n                for (int c: cc) Used[c] = true;\n\n                int root = -1;\n                for (int c: cc) {\n                    bool ok = true;\n                    for (int i = (int) Stack.size() - 1; i >= 0; --i) {\n                        if (gcd(B[Stack[i]], B[c]) != 1) break;\n                        else if (B[Stack[i]] < B[c]) {\n                            ok = false;\n                            break;\n                        }\n                    }\n                    if (ok) {\n                        root = c;\n                        break;\n                    }\n                }\n\n                Stack.push_back(root);\n                Forbidden[root] = true;\n                cc.erase(find(cc.begin(),cc.end(),root));\n                vector<int> Z = solve(cc);\n                Stack.pop_back();\n                Forbidden[root] = false;\n\n                Others.push_back({B[root]});\n                for (int z: Z) Others.back().push_back(z);\n            }\n        }\n\n        vector<int> Answer;\n        if (!Others.empty()) {\n            vector<int> Merged = Others[0];\n            for (int i = 1; i < Others.size(); ++i) {\n                vector<int> QQ;\n                int j = 0, k = 0;\n                while (j < Merged.size() || k < Others[i].size()) {\n                    if (j == Merged.size()) { QQ.push_back(Others[i][k++]); }\n                    else if (k == Others[i].size()) { QQ.push_back(Merged[j++]); }\n                    else if (Merged[j] < Others[i][k]) { QQ.push_back(Others[i][k++]); }\n                    else { QQ.push_back(Merged[j++]); }\n                }\n                swap(Merged, QQ);\n            }\n            for (int m: Merged) Answer.push_back(m);\n        }\n        return Answer;\n    }\n\n\n    void solve(istream& cin, ostream& cout) {\n        cin >> N;\n        vector<int> A(N); cin >> A;\n        for (int a: A) C[a]++;\n        for (pii c: C) if (c.x != 1) B.push_back(c.x);\n\n        vector<int> Ans;\n        if (!B.empty()) {\n\n            M = 0;\n            for (int b: B) Compress[b] = M++;\n            Forbidden.assign(M, false);\n\n            CompTime = 0;\n            CompVisit.assign(M, 0);\n\n            vector<int> AllPrimes;\n            for (int b: B) {\n                int x = b;\n                for (int p = 2; p <= 10000; ++p) {\n                    if (x%p == 0) {\n                        AllPrimes.push_back(p);\n                        while (x%p == 0) x /= p;\n                    }\n                }\n                if (x != 1) {\n                    AllPrimes.push_back(x);\n                }\n            }\n            map<int, int> CompressPrimes;\n            P = 0;\n            sort(AllPrimes.begin(),AllPrimes.end());\n            AllPrimes.resize(distance(AllPrimes.begin(),unique(AllPrimes.begin(),AllPrimes.end())));\n            for (int p: AllPrimes) CompressPrimes[p] = P++;\n            Multiples.resize(P);\n            PrimeVisit.assign(P, 0);\n\n            for (int b: B) {\n                int j = Compress[b];\n                int x = b;\n                Factors.push_back({});\n                for (int p = 2; p <= 10000; ++p) {\n                    if (x%p == 0) {\n                        Factors.back().push_back(CompressPrimes[p]);\n                        while (x%p == 0) x /= p;\n                        Multiples[CompressPrimes[p]].push_back(j);\n                    }\n                }\n                if (x != 1) {\n                    Factors.back().push_back(CompressPrimes[x]);\n                    Multiples[CompressPrimes[x]].push_back(j);\n                }\n            }\n\n            vector<int> All;\n            for (int i = 0; i < M; ++i) All.push_back(i);\n            auto res = solve(All);\n            for (int r: res) for (int i = 0; i < C[r]; ++i) Ans.push_back(r);\n        }\n        for (int i = 0; i < C[1]; ++i) Ans.push_back(1);\n        cout << Ans;\n    }\n};\n\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n\tERearranging solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<cstring>\n#include<algorithm>\n#include<queue>\n#define fo(i,a,b) for(i=a;i<=b;i++)\n#define ll long long\nusing namespace std;\nint n,a[2005],tot,du[2005],h[2005],to[4000005],nex[4000005];\nbool bhz[2005][2005],pd[2005];\nint gcd(int a,int b)\n{\n    return b?gcd(b,a%b):a;\n}\nstruct node{\n    int fr,id;\n}st;\nbool operator <(node a,node b)\n{\n    return a.fr<b.fr;\n}\npriority_queue<node> q;\nvoid add(int a,int b)\n{\n    du[b]++;\n    to[++tot]=b;\n    nex[tot]=h[a];\n    h[a]=tot;\n}\nvoid dfs(int x)\n{\n    pd[x]=1;\n    for(int i=1;i<=n;i++)\n        if(bhz[x][i]&&!pd[i])\n        {\n            add(x,i);\n            dfs(i);\n        }\n}\nint main()\n{\n    cin>>n;\n    for(int i=1;i<=n;i++) cin>>a[i];\n    sort(a+1,a+n+1);\n    for(int i=1;i<=n-1;i++)\n    for(int j=i+1;j<=n;j++)\n    if(gcd(a[i],a[j])>1) bhz[i][j]=bhz[j][i]=1;\n    for(int i=1;i<=n;i++) if(!pd[i]) dfs(i);\n    for(int i=1;i<=n;i++) \n        if(!du[i])\n        { \n            st.fr=a[i];\n            st.id=i;\n            q.push(st); \n        }\n    for(int i=1;i<=n;i++)\n    {\n        st=q.top();\n        q.pop();\n        int now=st.id;\n        cout<<a[now]<<\" \";\n        int t=h[now];\n        while (t){\n            du[to[t]]--;\n            if (!du[to[t]]){\n                st.fr=a[to[t]];\n                st.id=to[t];\n                q.push(st);\n            }\n            t=nex[t];\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pb push_back\n#define all(x) x.begin(), x.end()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nconst int N = 2000 + 10;\nconst int MOD = 1000000007;\nconst int LOG = 20;\nconst int INF = 1000000010;\nconst int delta = 11353;\n\nint n;\nvi G[N], a;\nmap<int, int> mp;\nint mark[N];\nint mark2[N];\n\nvoid DFS(int v){\n\tmark[v] = 1;\n\tfor (auto u:G[v]){\n\t\tif ((mark[u] == 0) && (mark2[u] == 0)){\n\t\t\tDFS(u);\n\t\t}\n\t}\n}\nint GCD(int x, int y){\n\tif (x == 0 || y == 0) return (x + y);\n\tif (x == 1 || y == 1) return 1;\n\tif (x < y) swap(x, y);\n\treturn GCD(y, x % y);\n}\n\nint32_t main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++){\n\t\tint x;\n\t\tcin >> x;\n\t\tmp[x] ++;\n\t\ta.pb(x);\n\t}\n\tsort(all(a));\n\ta.resize(unique(all(a)) - a.begin());\n\tfor (int i = 0; i < a.size(); i++) for (int j = 0; j < i; j++) if (GCD(a[i], a[j]) != 1){\n\t\tG[i].pb(j), G[j].pb(i);\n\t}\n\t//cout << GCD(7, 11) << '\\n';\n\tvi ans;\n\tint last = 0;\n\tfor (int i = 0; i < a.size(); i++){\n\t\tmemset(mark, 0, sizeof mark);\n\t\tif (i == 0){\n\t\t\tint mx = 0;\n\t\t\tfor (int j = 0; j < a.size(); j++) if (!mark[j]) mx = j, DFS(j);\n\t\t\tmark2[mx] = 1;\n\t\t\tans.pb(a[mx]);\n\t\t\t//cout << a[mx] << endl;\n\t\t\tlast = mx;\n\t\t}else{\n\t\t\tsort(all(G[last]));\n\t\t\tint mx = 0;\n\t\t\tfor (auto u:G[last]){\n\t\t\t\tif ((mark[u] == 0) && (mark2[u] == 0)) DFS(u), mx = u;\n\t\t\t}\t\n\t\t\tfor (int j = 0;  j < a.size(); j++){\n\t\t\t\tif ((mark[j] == 0) && (mark2[j] == 0)) mx = max(j, mx), DFS(j);\n\t\t\t}\n\t\t\tmark2[mx] = 1;\n\t\t\tans.pb(a[mx]);\n\t\t\tlast = mx;\n\t\t\t//cout << a[mx] << endl;\n\t\t}\n\t}\n\tfor (int i = 0; i < ans.size(); i++){\n\t\tint u = ans[i];\n\t\tif (i != 0){\n\t\t\tif (GCD(ans[i], ans[i - 1]) == 1 && ans[i - 1] < ans[i]) assert(0);\n\t\t\tif (GCD(ans[i], ans[i - 1]) != 1 && ans[i - 1] > ans[i]) assert(0);\n\t\t\t\n\t\t}\n\t\tfor (int i = 0; i < mp[u]; i++) cout << u << ' ';\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lint;\ntypedef long double louble;\n\n#define so(a) ((int)((a).size()))\n\ntemplate<typename T1,typename T2> inline T1 max(T1 a,T2 b){return a<b?b:a;}\ntemplate<typename T1,typename T2> inline T1 min(T1 a,T2 b){return a<b?a:b;}\n\nconst char lf = '\\n';\n\nnamespace ae86\n{\n\tconst int bufl = 1 << 15;\n\n\tchar buf[bufl],*s=buf,*t=buf;\n\n\tinline int fetch()\n\t{\n\t\tif(s==t){t=(s=buf)+fread(buf,1,bufl,stdin);if(s==t)return EOF;}\n\t\treturn *s++;\n\t}\n\n\tinline int ty()\n\t{\n\t\tint a=0;int b=1,c=fetch();\n\t\twhile(!isdigit(c))b^=c=='-',c=fetch();\n\t\twhile(isdigit(c))a=a*10+c-48,c=fetch();\n\t\treturn b?a:-a;\n\t}\n}\nusing ae86::ty;\n\nconst int _ = 2007;\n\ninline int gcd(int a,int b){return __gcd(a,b);}\n\nvector<int> e[_],via[_];\n\nint n,val[_],ed[_]={0},ind[_]={0};\n\nvoid dfs(int x)\n{\n\ted[x]=1;\n\tfor(auto b:e[x])if(!ed[b])via[x].emplace_back(b),ind[b]++,dfs(b);\n}\n\nint main()\n{\n\tios::sync_with_stdio(0),cout.tie(nullptr);\n\n\tn=ty();\n\tfor(int i=1;i<=n;i++)val[i]=ty();\n\tsort(val+1,val+n+1);\n\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\tif(gcd(val[i],val[j])!=1)e[i].emplace_back(j),e[j].emplace_back(i);\n\n\tfor(int i=1;i<=n;i++)sort(e[i].begin(),e[i].end());\n\n\tfor(int i=1;i<=n;i++)if(!ed[i])dfs(i);\n\n\tpriority_queue<int> q;\n\tfor(int i=1;i<=n;i++)if(!ind[i])q.emplace(i);\n\n\twhile(!q.empty())\n\t{\n\t\tint a=q.top();q.pop();\n\t\tcout<<val[a]<<' ';\n\t\tfor(auto b:via[a])q.emplace(b);\n\t}\n\tcout<<lf;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n #define rep(i, a, b) for (int i = a; i <= b; i++)\n #define vep(i, v) for (int i = 0; i < (int)v.size(); i++)\n #define fill(a, x) memset(a, x, sizeof(a))\n #define pb push_back\n #define mp make_pair\n\n typedef vector<int> Vi;\n typedef pair<int, int> Pii;\n\n const int N = 2000 + 5, M = N * N, INF = 0x3f3f3f3f;\n\n int n, es, dfs_cnt;\n int a[N], pre[N], vis[N], fa[N], is_con[N];\n Vi comp[N], all, tmp;\n bool del[N];\n\n inline int gcd(int x, int y) { return (!y) ? x : gcd(y, x % y); }\n\n struct Edge { int from, to, pre; } e[M];\n inline void init_graph() { es = dfs_cnt = 0; fill(vis, 0); fill(pre, 0); fill(is_con, 0); }\n inline void ine(int a, int b) {\n \tint i = ++es;\n \te[i].from = a; e[i].to = b; e[i].pre = pre[a];\n \tpre[a] = i;\n }\n inline void ine2(int a, int b) { ine(a, b); ine(b, a); }\n #define reg(i, x) for (int i = pre[x]; i; i = e[i].pre)\n\n inline int find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }\n inline void do_union(int from, int to) {\n \tint fx = find(from), fy = find(to);\n \tif (fx != fy) fa[fy] = fx;\n }\n\n inline void merge(Vi &v1, Vi v2) {\n \tif (v1.empty()) { v1 = v2; return; }\n \tVi tmp;\n \tint p1 = 0, p2 = 0, s1 = v1.size(), s2 = v2.size();\n // printf(\"s1 = %d  s2 = %d\\n\", s1, s2);\n \twhile (p1 < s1 && p2 < s2) {\n \t\tint x = v1[p1], y = v2[p2];\n // printf(\"p1 = %d  p2 = %d  x = %d  y = %d\\n\", p1, p2, x, y);\n \t\tif (a[x] > a[y]) tmp.pb(x), p1++; else tmp.pb(y), p2++;\n // printf(\"ok\\n\");\n \t}\n\n \tif (p1 < s1) rep(i, p1, s1 - 1) tmp.pb(v1[i]);\n \telse rep(i, p2, s2 - 1) tmp.pb(v2[i]);\n \tv1 = tmp;\n }\n\n inline void dfs(int x, int dfs_id, Vi &list) {\n \tlist.pb(x);\n \tvis[x] = dfs_id;\n // printf(\"x = %d\\n  list.sz = %lu\\n\", x, list.size());\n // vep(i, list) printf(\"list[%d] = %d\\n\", i, list[i]);\n \treg(i, x) {\n \t\tint y = e[i].to;\n \t\tif (del[y] || vis[y] == dfs_id) continue;\n \t\tdfs(y, dfs_id, list);\n \t}\n }\n\n inline Vi solve_comp(int pa, Vi cop) {\n \tVi ret, res, tmp;\n \tret.clear();\n // vep(i, cop) printf(\"cop[%d] = %d\\n\", i, cop[i]); puts(\"\");\n \tif (cop.size() == 1) { del[cop[0]] = true; ret.pb(cop[0]); return ret; }\n \tPii minp = mp(INF, 0);\n \tvep(i, cop) {\n \t\tint x = cop[i];\n // printf(\"x = %d  is_con[x] = %d\\n\", x, is_con[x]);\n \t\tif (is_con[x] != pa) continue;\n \t\tminp = min(minp, mp(a[x], x));\n \t}\n // printf(\"minp.first = %d\\n\\n\", minp.first);\n \tint sel = minp.second;\n \tdel[sel] = true;\n \tret.clear();\n \tret.pb(0);\n \treg(i, sel) {\n \t\tint y = e[i].to;\n // printf(\"sel = %d  y = %d  del = %d\", sel, y, del[y]);\n \t\tif (!del[y]) is_con[y] = sel;\n \t}\n // puts(\"\");\n // printf(\"pa = %d\\n\", pa);\n \tvep(i, cop) {\n \t\tint y = cop[i];\n \t\ttmp.clear();\n // printf(\"y = %d  del = %d\\n\", y, del[y]);\n \t\tif (!del[y]) {\n \t\t\tdfs(y, ++dfs_cnt, tmp);\n // printf(\"tmp.size = %lu\\n\", tmp.size());\n \t\t\tres = solve_comp(sel, tmp);\n // puts(\"86\");\n \t\t\tmerge(ret, res);\n \t\t}\n \t}\n // puts(\"87\");\n\n \tret[0] = sel;\n // printf(\"pa = %d  cop.size = %lu  sel = %d\\n\", pa, cop.size(), sel);\n // vep(i, ret) printf(\"ret[%d] = %d\\n\", i, ret[i]); puts(\"---------\");\n \treturn ret;\n }\n\nint main()\n{\n\t// freopen(\"atc2306.in\", \"r\", stdin);\n\n\tscanf(\"%d\", &n);\n\ta[0] = INF;\n\trep(i, 1, n) scanf(\"%d\", &a[i]), fa[i] = i, comp[i].clear();\n\n\tinit_graph();\n\trep(i, 1, n - 1) rep(j, i + 1, n)\n\t\tif (gcd(a[i], a[j]) > 1) ine2(i, j);\n\n\tfor (int i = 1; i < es; i += 2) do_union(e[i].from, e[i].to);\n\trep(i, 1, n) comp[fa[i]].pb(i);\n// rep(i, 1, n) printf(\"fa[%d] = %d\\n\", i, fa[i]);\n\n\tfill(del, false);\n\tall.clear();\n\trep(i, 1, n) if (!del[i]) {\n\t\ttmp = solve_comp(0, comp[fa[i]]);\n\t\tmerge(all, tmp);\n// printf(\"i = %d\\n\", i);\n// vep(i, all) printf(\"all[%d] = %d\\n\", i, all[i]);\n// puts(\"Line 136\\n\");\n\t}\n\n\trep(i, 0, n - 2) printf(\"%d \", a[all[i]]);\n\tprintf(\"%d\\n\", a[all[n - 1]]);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\nVI ME(const VI &a, const VI &b) {\n    VI ret; ret.reserve(a.size() + b.size());\n    int i = 0, j = 0;\n    while (i < (int)a.size() && j < (int)b.size()) {\n\tif (a[i] < b[j]) ret.push_back(b[j++]);\n\telse ret.push_back(a[i++]);\n    }\n    ret.insert(ret.end(), a.begin()+i, a.end());\n    ret.insert(ret.end(), b.begin()+j, b.end());\n    return ret;\n}\n\nint N;\nint A[2011];\nVI G[2011];\nbool use[2011];\n\nVI F[2011];\nVI R[200011];\nVI P;\n\nint D[2011], cnt;\nVI rec(int s, int last) {\n    if (A[s] == 1) {\n\tuse[s] = true;\n\treturn { 1 };\n    }\n\n    VI vs;\n    cnt++;\n    vs.push_back(s);\n    D[s] = cnt;\n    for (int i=0; i<(int)vs.size(); i++) {\n\tint v = vs[i];\n\tEACH (e, F[v]) {\n\t    EACH (f, R[*e]) if (!use[*f] && D[*f] != cnt) {\n\t\tvs.push_back(*f);\n\t\tD[*f] = cnt;\n\t    }\n\t}\n    }\n\n    int pick = -1;\n    EACH (e, vs) if (__gcd(last, A[*e]) > 1) {\n\tif (pick == -1 || A[pick] > A[*e]) {\n\t    pick = *e;\n\t}\n    }\n\n    // pick;\n    use[pick] = true;\n    VI cur;\n    EACH (e, G[pick]) if (!use[*e]) {\n\tVI tmp = rec(*e, A[pick]);\n\tcur = ME(cur, tmp);\n    }\n    \n    cur.insert(cur.begin(), A[pick]);\n    return cur;\n}\n\n\nvoid MAIN() {\n    scanf(\"%d\", &N);\n    REP (i, N) scanf(\"%d\", A+i);\n\n    REP (i, N) {\n\tint m = A[i];\n\tfor (int j=2; j*j<=m; j++) {\n\t    if (m % j == 0) {\n\t\tP.push_back(j);\n\t\tF[i].push_back(j);\n\t\twhile (m % j == 0) m /= j;\n\t    }\n\t}\n\tif (m > 1) {\n\t    P.push_back(m);\n\t    F[i].push_back(m);\n\t}\n    }\n\n    sort(P.begin(), P.end());\n    P.erase(unique(P.begin(), P.end()), P.end());\n    REP (i, N) {\n\tEACH (e, F[i]) {\n\t    *e = lower_bound(P.begin(), P.end(), *e) - P.begin();\n\t    R[*e].push_back(i);\n\t}\n    }\n\n    REP (i, N) REP (j, N) if (i != j) {\n\tif (__gcd(A[i], A[j]) > 1) {\n\t    G[i].push_back(j);\n\t}\n    }\n\n    VI ans;\n\n    REP (i, N) if (!use[i]) {\n\tVI tmp = rec(i, 0);\n\tans = ME(ans, tmp);\n    }\n    rprintf(\"%d\", ans.begin(), ans.end());\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <queue>\n#define maxn 2005\nusing namespace std;\ntypedef long long ll;\nconst int inf = 0x3f3f3f3f;\nint n,a[maxn];\nvector <int> adj[maxn];\nbool vis[maxn];\nvector <int> chi[maxn];\nint gcd(int a,int b){\n\tif(a % b == 0) return b;\n\treturn gcd(b,a % b);\n}\nvoid dfs(int u){\n\tvis[u] = true;\n\tfor(int i=0;i<(int)adj[u].size();i++){\n\t\tint v = adj[u][i];\n\t\tif(!vis[v]){\n\t\t\tchi[u].push_back(v);\n\t\t\tdfs(v);\n\t\t}\n\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tsort(a + 1,a + n + 1);\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif(i == j) continue;\n\t\t\tif(gcd(a[i],a[j]) != 1) adj[i].push_back(j);\n\t\t}\n\t}\n\tpriority_queue <int> que;\n\tfor(int i=1;i<=n;i++){\n\t\tif(!vis[i]){\n\t\t\tdfs(i);\n\t\t\tque.push(i);\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tint u = que.top();que.pop();\n\t\tprintf(\"%d%c\",a[u],i == n ? '\\n' : ' ');\n\t\tfor(int j=0;j<(int)chi[u].size();j++){\n\t\t\tque.push(chi[u][j]);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint Eulg(int a, int b);\n\nint main(int argc, char *argv[]){\n\n\tint N;\n\tcin>>N;\n\n\tint *a = new int[N]();\n\n\tfor(int i=0; i<N; i++){\n\t\tcin>>a[i];\n\t}\n\n\tsort(a, a+N);\n\n\tbool flag = true;\n\twhile(flag){\n\tfor(int i=0; i<N; i++){\n\t\tfor(int j=i+1; j<N; j++){\n\t\t\tif(Eulg(a[i], a[j]) == 1){\n\t\t\t\tif(a[i]<a[j]){\n\t\t\t\t\tint tmp;\n\t\t\t\t\ttmp =a[i];\n\t\t\t\t\ta[i] = a[j];\n\t\t\t\t\ta[j] = tmp;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t}\n}\n\nfor(int i=0; i<N; i++)\n\tcout<<a[i]<<\"  \";\n\n\n\n\tdelete[] a;\n\treturn 0;\n}\n\nint Eulg(int a, int b){\n\tif(a<b){\n\t\tint tmp;\n\t\ttmp =a;\n\t\ta = b;\n\t\tb = tmp;\n\t}\n\n\tint r;\n\tr = a % b;\n\twhile(r){\n\t\ta = b;\n\t\tb = r;\n\t\tr = a % b;\n\t}\n\treturn b;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <queue>\n#define file(x) freopen(#x\".in\", \"r\", stdin), freopen(#x\".out\", \"w\", stdout)\n\nconst int N(2010);\nstruct edge { int next, to; } e[N];\nint head[N], e_num, n, A[N], vis[N], G[N][N], deg[N];\ninline void add_edge(int from, int to)\n{\n\te[++e_num] = (edge) {head[from], to};\n\thead[from] = e_num;\n}\n\nvoid dfs(int x)\n{\n\tfor (int i = vis[x] = 1; i <= n; i++) if (!vis[i] && G[x][i])\n\t\t++deg[i], add_edge(x, i), dfs(i);\n}\n\nvoid TopSort()\n{\n\tstd::priority_queue<int> Q;\n\tfor (int i = 1; i <= n; i++) if (!deg[i]) Q.push(i);\n\twhile (!Q.empty())\n\t{\n\t\tint x = Q.top(); Q.pop(); printf(\"%d \", A[x]);\n\t\tfor (int i = head[x]; i; i = e[i].next) Q.push(e[i].to);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", A + i);\n\tstd::sort(A + 1, A + n + 1);\n\tfor (int i = 1; i <= n; i++) for (int j = i + 1; j <= n; j++)\n\t\tif (std::__gcd(A[i], A[j]) != 1) G[i][j] = G[j][i] = 1;\n\tfor (int i = 1; i <= n; i++) if (!vis[i]) dfs(i);\n\tTopSort();\n\treturn 0;\n}\n//fdgdg"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define N 1111116\n#define next nxt\n\nint n,k,a[N],y[N],next[N],p[N],d[N],h[N];\npriority_queue<int> q;\n\nint gcd(int x,int y){\n\treturn y?gcd(y,x%y):x;\n}\n\nvoid travel(int x){\n\th[x]=1;\n\tfor (int i=1;i<=n;i++)\n\t\tif (!h[i]&&gcd(a[x],a[i])>1){\n\t\t\ty[++k]=i;next[k]=p[x];p[x]=k;d[i]++;\n\t\t\ttravel(i);\n\t\t}\n}\n\nint read(){\n\tint x=0,f=1;char ch=getchar();\n\tfor (;!isdigit(ch);ch=getchar()) if (ch=='-')  f=-f;\n\tfor (;isdigit(ch);ch=getchar()) x=x*10+ch-'0';\n\treturn x*f;\n}\n\nint main(){\n\tn=read();\n\tfor (int i=1;i<=n;i++) a[i]=read();\n\tsort(a+1,a+n+1);\n\tfor (int i=1;i<=n;i++)\n\t\tif (!h[i]) travel(i),q.push(i);\n\twhile (!q.empty()){\n\t\tint x=q.top();q.pop();\n\t\tprintf(\"%d \",a[x]);\n\t\tfor (int t=p[x];t;t=next[t])\n\t\t\tif (--d[y[t]]==0) q.push(y[t]);\n\t}\n\tprintf(\"\\n\");return 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int, int> pii;\n\nconst int N = 2e3 + 5;\n\nll n, a[N], ans[N], in[N], tp[N];\nbool mark[N];\nvector <int> adj[N];\nvector <pii> g[N];\n\nvoid dfs(int v) {\n\tstatic int cur = 0;\n\ttp[cur++] = v;\n\tmark[v] = true;\n\tfor (auto e : g[v]) {\n\t\tint u = e.second;\n\t\tif(!mark[u]) {\n\t\t\tdfs(u);\n\t\t}\n\t}\n}\n\nint main() {\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\t\n\tcin >> n;\n\tfor (int i = 0; i < n; i++)\n\t\tcin >> a[i];\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = i + 1; j < n; j++)\n\t\t\tif(__gcd(a[i], a[j]) > 1)\n\t\t\t\tg[i].push_back({a[j], j}), g[j].push_back({a[i], i});;\n\tfor (int i = 0; i < n; i++)\n\t\tsort(g[i].begin(), g[i].end());\n\tfor (int i = 0; i < n; i++)\n\t\tif(!mark[i])\n\t\t\tdfs(i);\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tint x = tp[i], y = tp[j];\n\t\t\tif(__gcd(a[x], a[y]) > 1) {\n\t\t\t\tadj[x].push_back(y);\n\t\t\t\tin[y]++;\n\t\t\t}\n\t\t}\n\t}\n\tpriority_queue <pii> pq;\n\tfor (int i = 0; i < n; i++) {\n\t\tif(!in[i])\n\t\t\tpq.push({a[i], i});\n\t}\n\tint cnt = 0;\n\twhile(!pq.empty()) {\n\t\tpii p = pq.top();\n\t\tpq.pop();\n\t\tans[cnt++] = p.first;\n\t\tint v = p.second;\n\t\tfor (auto u : adj[v]) {\n\t\t\tin[u]--;\n\t\t\tif(!in[u])\n\t\t\t\tpq.push({a[u], u});\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++)\n\t\tcout << ans[i] << \" \";\n\tcout << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "# include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 2002;\n\nint a[maxn];\nint g[maxn][maxn];\nvector<int> G[maxn];\nint ind[maxn];\nbool vis[maxn];\nint n;\n\nvoid dfs(int u) {\n\tfor(int i = 0; i < n; ++i) if(g[u][i] > 1 && !vis[i]) {\n\t\tvis[i] = true;\n\t\tG[u].push_back(i);\n\t\t++ind[i];\n\t\tdfs(i);\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; ++i) scanf(\"%d\", &a[i]);\n\tsort(a, a + n);\n\tfor(int i = 0; i < n; ++i) \n\t\tfor(int j = 0; j < n; ++j)\n\t\t\tg[i][j] = __gcd(a[i], a[j]);\n\tfor(int i = 0; i < n; ++i)\n\t\tif(!vis[i]) vis[i] = true, dfs(i);\n\tpriority_queue<int, vector<int>, less<int> > q;\n\tfor(int i = 0; i < n; ++i) if(ind[i] == 0) q.push(i);\n\twhile(!q.empty()) {\n\t\tint x = q.top(); q.pop();\n\t\tprintf(\"%d \", a[x]);\n\t\tfor(auto i: G[x]) if(--ind[i]==0) q.push(i);\n\t}\n\tputs(\"\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cctype>\n#include <algorithm>\n#include <queue>\nusing namespace std;\ntypedef long long int64;\ninline int read(int f = 1, int x = 0, char ch = ' ')\n{\n    while(!isdigit(ch = getchar())) if(ch == '-') f = -1;\n    while(isdigit(ch)) x = x*10+ch-'0', ch = getchar();\n    return f*x;\n}\nconst int N = 1e3+5;\nint gcd(int a, int b) { return b?gcd(b, a%b):a; }\nstruct Edge\n{\n    int next, to;\n    Edge(int next = 0, int to = 0):next(next), to(to) {};\n}edge[N*N];\nint tot, head[N];\nint n, vis[N], f[N][N], deg[N], a[N];\nvoid add(int x, int y) { edge[++tot] = Edge(head[x], y), head[x] = tot, ++deg[y]; } \nvoid dfs(int x)\n{\n    vis[x] = 1;\n    for(int y = 1; y <= n; ++y)\n        if(!vis[y]&&f[x][y])\n            add(x, y), dfs(y);\n}\nint main()\n{\n    n = read();\n    for(int i = 1; i <= n; ++i) a[i] = read();\n    sort(a+1, a+1+n);\n    for(int i = 1; i <= n; ++i) \n        for(int j = 1; j < i; ++j)\n            if(gcd(a[i], a[j]) != 1) f[i][j] = f[j][i] = 1;\n    for(int i = 1; i <= n; ++i) if(!vis[i]) dfs(i);\n    priority_queue<int> q;\n    for(int i = 1; i <= n; ++i) if(!deg[i]) q.push(i);\n    while(q.size())\n    {\n        int x = q.top(); q.pop();\n        printf(\"%d \", a[x]);\n        for(int i = head[x]; i; i = edge[i].next) q.push(edge[i].to);\n    }\n    puts(\"\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <assert.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\n#define PB push_back\n#define MP make_pair\n#define endl \"\\n\"\nconst ll UNDEF = -1;\nconst ll INF=1e9;\nconst ll MOD=1000000007LL;\ntemplate<typename T> inline bool chkmax(T &aa, T bb) { return aa < bb ? aa = bb, true : false; }\ntemplate<typename T> inline bool chkmin(T &aa, T bb) { return aa > bb ? aa = bb, true : false; }\ntypedef pair<ll,ll> pll;\ntypedef vector<ll> vll;\nconst ll mn=2002;\n#define fst first\n#define snd second\nconst ll MAXN=1e5+4;\nconst ll MAXP=MAXN;\nbool sieve_array[MAXP+1];\nll sp[MAXP+1];\nvector<ll> gpv;\nvoid sieve() {\n  for (ll i = 0; i <= MAXP; i++) {\n    sieve_array[i] = true;\n    sp[i]=INF;\n  }\n  sieve_array[0] = false; sieve_array[1] = false;\n  ll lim = sqrt(MAXP)+1;\n  for (ll i = 2; i <= lim; i++) {\n    if(sieve_array[i]) {\n      for (ll j = i*i; j <= MAXP; j+=i) {\n        sieve_array[j] = false;\n        chkmin(sp[j],i);\n      }\n    }\n  }\n  for (ll i = 2; i <= MAXP; i++) {\n    if(sieve_array[i]) {\n      gpv.PB(i);\n      chkmin(sp[i],i);\n    }\n  }\n}\nmap<ll,ll> factorize(ll x) {\n  assert(gpv.size()>0);\n  map<ll,ll> h;\n  while(x>=MAXP) {\n    bool found=false;\n    for (auto &p:gpv) {\n      if (p*p>x) break;\n      if ((x%p)==0) {\n        x/=p;\n        h[p]++;\n        found=true;\n        break;\n      }\n    }\n    if (!found) break;\n  }\n  if (x<MAXP) {\n    while(x>1) {\n    ll p=sp[x];\n    x/=p;\n    h[p]++;\n    }\n  }\n  if (x>1) h[x]++;\n  return h;\n}\nll a[mn];\nmap<ll,vll> primeToIndex;\nvector<ll> idxToPrimes[mn];\nbool usedIdx[mn];\nset<ll> usedPrimes;\npriority_queue<pll,vector<pll>,greater<pll> > pq;\nvoid addIdx(ll idx) {\n  usedIdx[idx]=true;\n  for (auto &p:idxToPrimes[idx]) {\n    if (usedPrimes.find(p)!=usedPrimes.end()) continue;\n    usedPrimes.insert(p);\n    for (auto &nidx:primeToIndex[p]) {\n      if (!usedIdx[nidx]) {\n        usedIdx[nidx]=true;\n        pq.push(MP(a[nidx],nidx));\n      }\n    }\n  }\n}\nvector<ll> vans[mn];\nvoid dij(ll x) {\n  if (usedIdx[x]) {vans[x]={}; return;}\n  vector<ll> ans;\n  pq.push(MP(a[x],x));\n  addIdx(x);\n  while(!pq.empty()) {\n    auto got=pq.top(); pq.pop();\n    ll y=got.snd;\n    ans.PB(a[y]);\n    addIdx(y);\n  }\n  //printf(\"x:%d a[x]:%d. \",x,a[x])  ;\n  //for (auto &w:ans) printf(\"%d \",w);\n  //printf(\"\\n\");\n  vans[x]=ans;\n}\nint main() {\n  sieve();\n  ll n; scanf(\"%lld\",&n);\n  for (ll i=0;i<n;i++) scanf(\"%lld\",&a[i]);\n  sort(a,a+n);\n  for (ll i=0;i<n;i++) {\n    map<ll,ll> mfac = factorize(a[i]);\n    for (auto &fac:mfac) {\n      ll p=fac.fst;\n      idxToPrimes[i].PB(p);\n      primeToIndex[p].PB(i);\n    }\n  }\n  vector<pair<pll,ll> > v;\n  for (ll x=0;x<n;x++) {\n    dij(x);\n  }\n  sort(v.begin(),v.end());\n  reverse(v.begin(),v.end());\n  for (ll x=n-1;x>=0;x--) {\n    for (auto &w:vans[x]) printf(\"%lld \",w);\n  }\n  printf(\"\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define index(xs, x) (int)(lower_bound(all(xs), x) - xs.begin())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n\nint N;\nvector<int> C[3300];\nint A[2000];\nvector<int> R[2000];\nbool used[2000], dead[2000];\n\nint gcd(int a, int b) {\n  if (b==0)return a;\n  return gcd(b,a%b);\n}\n\nvector<int> prime_list(int x) {\n  vector<int> ret;\n  for (int p=2; p*p<=x; p++) if (x%p == 0) {\n    while (x%p == 0) x /= p;\n    ret.pb(p);\n  }\n  if (x > 1) ret.pb(x);\n  return ret;\n}\nint num = 0;\nvoid dfs(int x);\nvoid dfs2(int p) {\n  vector<int> vs(C[p]);\n  C[p].clear();\n  for (int x : vs) dfs(x);\n}\nvoid dfs(int x) {\n  assert(!dead[x]);\n  if (used[x]) return;\n  num--;\n  used[x] = true;\n  for (int p : R[x]) dfs2(p);\n}\nbool F[3300];\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> N;\n  vector<int> all;\n  rep(i, N) cin >> A[i];\n  sort(A, A+N);\n  rep(i, N) R[i] = prime_list(A[i]), all.insert(all.end(), all(R[i]));\n  sort(all(all)); uniq(all);\n  assert(all.size() <= 3300);\n  rep(i, N) for (int &x : R[i]) x = index(all, x);\n\n  vector<int> seq;\n  rep(_, N) {\n    num = N-_;\n    int m = -1;\n    rep(i, N) used[i] = false;\n    rep(i, N) if (!dead[i]) for (int p : R[i]) C[p].clear();\n    rep(i, N) if (!dead[i]) for (int p : R[i]) C[p].pb(i);\n    rep(i, N) if (!dead[i]) {\n      bool bad = false;\n      rep(i, all.size()) F[i] = false;\n      for (int p : R[i]) F[p] = true;\n      for (int j=seq.size()-1; j>=0; j--) {\n        bool ex = false;\n        for (int p : R[seq[j]]) ex |= F[p];\n        if (ex) break;\n        if (A[seq[j]] < A[i]) {\n          bad = true;\n          break;\n        }\n        if (ex) for (int p : R[seq[j]]) F[p] = true;\n      }\n      if (!bad) {\n        dfs(i);\n        if (num == 0) {\n          m = i;\n          break;\n        }\n      }\n    }\n    assert(m != -1);\n    seq.pb(m);\n    dead[m] = true;\n  }\n  rep(i, N) cout << A[seq[i]] << \" \"; cout << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<queue>\n#include<stack>\n#include<deque>\n#include<utility>\n#include<cctype>\n#include<bitset>\n#include<stdio.h>\n#include<time.h>\n#define ll long long\n#define mp make_pair\nusing namespace std;\nconst int INF=1e9;\n/*--------main part---------*/\ninline int read(){\n    int X = 0,w = 0 ;\n\tchar ch = 0;\n    while(!isdigit(ch)) {w |= ch == '-';ch = getchar();}\n    while(isdigit(ch)) X = (X<<3) + (X<<1) + (ch ^ 48),ch = getchar();\n    return w ? -X : X;\n}\nint n;\nint dat[10005];\nbool vis[10005];\nvector<int> ans[10005];\nbool edg[2005][2005];\nint a[100005];\nvoid dfs(int x)\n{\n\tif(vis[x])\n\t\treturn;\n\tvis[x]=true;\n\tvector<int> chi;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(edg[x][i] and !vis[i])\n\t\t{\n\t\t\tchi.push_back(i);\n\t\t\tdfs(i);\n\t\t}\n\t}\n\tmemset(a,0,sizeof(a));\n\tans[x].push_back(dat[x]);\n\twhile(true)\n\t{\n\t\tint mx=0;\n\t\tint pos;\n\t\tfor(int i=0;i<chi.size();i++)\n\t\t{\n\t\t\tif(a[i]<ans[chi[i]].size() and ans[chi[i]][a[i]]>mx)\n\t\t\t{\n\t\t\t\tmx=ans[chi[i]][a[i]];\n\t\t\t\tpos=i;\n\t\t\t}\n\t\t}\n\t\tif(mx==0)\n\t\t\tbreak;\n\t\tans[x].push_back(mx);\n\t\ta[pos]++;\n\t}\n}\nint gcd(int x,int y)\n{\n\tif(x==0)\n\t{\n\t\treturn y;\n\t}\n\telse\n\t{\n\t\treturn gcd(y%x,x);\n\t}\n}\nint main()\n{\n\tcin>>n;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcin>>dat[i];\n\t}\n\tsort(dat,dat+n);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<i;j++)\n\t\t{\n\t\t\tif(gcd(dat[i],dat[j])!=1)\n\t\t\t{\n\t\t\t\tedg[i][j]=edg[j][i]=true;\n\t\t\t}\n\t\t}\n\t\tedg[i][n]=edg[n][i]=true;\n\t}\n\tdfs(n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tcout<<ans[n][i]<<' ';\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for(int i = (b) - 1; i >= (a); i--)\n#define ITER(it, a) for(typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a, value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int) a.size()\n#define ALL(a) a.begin(),a.end()\n#define PB push_back\n#define MP make_pair\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double PI = acos(-1.0);\nconst LL INF = 1000 * 1000 * 1000 + 7;\nconst LL LINF = INF * (LL)INF;\n\nconst int MAX = 2020;\n\nVI g[MAX];\nint A[MAX];\n\nint U[MAX];\n\nbool cmp(int x, int y)\n{\n\treturn A[x] < A[y];\n}\n\nint gcd(int a, int b)\n{\n\tif (b == 0) return a;\n\treturn gcd(b, a%b);\n}\n\nVI merge(VI& a, VI& b)\n{\n\tVI res;\n\tres.reserve(SZ(a) + SZ(b));\n\n\ta.PB(-INF);\n\n\tint ind = 0;\n\tFOR (i, 0, SZ(a))\n\t{\n\t\twhile(ind < SZ(b) && b[ind] > a[i])\n\t\t{\n\t\t\tres.PB(b[ind]);\n\t\t\tind++;\n\t\t}\n\n\t\tif (i == SZ(a) - 1) break;\n\t\tres.PB(a[i]);\n\t}\n\n\treturn res;\n}\n\n\nVI dfs(int x)\n{\n\tU[x] = true;\n\tVI res;\n\tFOR (i, 0, SZ(g[x]))\n\t{\n\t\tint to = g[x][i];\n\t\tif (U[to]) continue;\n\t\tVI v = dfs(to);\n\n\t\tres = merge(res, v);\n\t}\n\n\treverse(ALL(res));\n\tres.PB(A[x]);\n\treverse(ALL(res));\n\treturn res;\n}\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t//ios::sync_with_stdio(false); cin.tie(0);\n\n\tint n;\n\tscanf(\"%d\", &n);\n\tFOR (i, 0, n)\n\t{\n\t\tscanf(\"%d\", &A[i]);\n\t}\n\n\tFOR (i, 0, n)\n\t{\n\t\tFOR (j, 0, n)\n\t\t{\n\t\t\tif (i == j) continue;\n\t\t\tif (gcd(A[i], A[j]) != 1) g[i].PB(j);\n\t\t}\n\t}\n\n\tFOR (i, 0, n)\n\t{\n\t\tsort(ALL(g[i]));\n\t}\n\n\tVI res;\n\n\tFOR (i, 0, n)\n\t{\n\t\tif (U[i]) continue;\n\t\tVI v = dfs(i);\n\t\tres = merge(res, v);\n\t}\n\n\tFOR (i, 0, SZ(res))\n\t{\n\t\tprintf(\"%d \", res[i]);\n\t}\n\tprintf(\"\\n\");\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb push_back\n#define SZ(x) ((int)x.size())\n\nconst int N = 2010 ;\n\nint vis[N], ok[N][N], in[N], a[N] ;\nvector <int> g[N] ;\nint n ;\n\nvoid dfs(int rt) {\n    vis[rt] = 1 ;\n    for (int i = 1; i <= n; i++)\n    if (!vis[i] && ok[rt][i]) {\n        in[i]++ ;\n        g[rt].pb(i) ;\n        dfs(i) ;\n    }\n}\n\nvoid Top() {\n    priority_queue <int> q ;\n    for (int i = 1;  i <= n; i++) if (!in[i]) q.push(i) ;\n    while (!q.empty()) {\n        int now = q.top() ;\n        q.pop() ;\n        cout << a[now] << \" \" ;\n        for (int i = 0; i < SZ(g[now]); i++) q.push(g[now][i]) ;\n    }\n}\n\nsigned main(){\n    scanf(\"%d\", &n) ;\n    for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]) ;\n    sort(a + 1, a + n + 1) ;\n    for (int i = 1; i <= n; i++)\n    for (int j = i + 1; j <= n; j++)\n    if (__gcd(a[i], a[j]) != 1) ok[i][j] = ok[j][i] = 1 ;\n    for (int i = 1; i <= n; i++) if (!vis[i]) dfs(i) ;//遍历连通块\n    Top() ;\n}"
  },
  {
    "language": "C++",
    "code": "// In the name of God\n\n#include <iostream>\n#include <algorithm>\n#include <fstream>\n#include <vector>\n#include <deque>\n#include <assert.h>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <stdio.h>\n#include <string.h>\n#include <utility>\n#include <math.h>\n#include <bitset>\n#include <iomanip>\n\nusing namespace std;\n\nconst int N = (int) 2005, mod = (int) 0;\n\nint deg[N], mat[N][N], a[N];\nint32_t main() {\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    int n;\n    cin >> n;\n    for (int j = 0; j < n; ++j)\n        cin >> a[j];\n    sort(a, a + n);\n    set<int> st;\n    for (int x = 0; x < n; ++x)\n        for (int y = x + 1; y < n; ++y) {\n            mat[x][y] = (__gcd(a[x], a[y]) != 1);\n            deg[y] += mat[x][y];\n        }\n    for (int j = 0; j < n; ++j)\n        if (deg[j] == 0)\n            st.insert(-j);\n    while ((int) st.size()) {\n        int x = *(st.begin());\n        st.erase(x);\n        cout << a[-x] << ' ';\n        x *= -1;\n        for (int u = 0; u < n; ++u) {\n            if (mat[x][u]) {\n                deg[u]--;\n                if (deg[u] == 0)\n                    st.insert(-u);\n            }\n        }\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N=2005;\nint read(){\n\tint x=0;\n\tchar ch=getchar();\n\twhile (!isdigit(ch))\n\t\tch=getchar();\n\twhile (isdigit(ch))\n\t\tx=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n\treturn x;\n}\nint n;\nint a[N];\nint gcd(int a,int b){\n\treturn b?gcd(b,a%b):a;\n}\nvector <int> e[N],ans[N],id[N];\nvector <int> Merge(vector <int> a,vector <int> b){\n\tvector <int> ans;\n\tans.clear();\n\treverse(a.begin(),a.end());\n\treverse(b.begin(),b.end());\n\twhile (!a.empty()&&!b.empty())\n\t\tif (a.back()>b.back())\n\t\t\tans.push_back(a.back()),a.pop_back();\n\t\telse\n\t\t\tans.push_back(b.back()),b.pop_back();\n\twhile (!a.empty())\n\t\tans.push_back(a.back()),a.pop_back();\n\twhile (!b.empty())\n\t\tans.push_back(b.back()),b.pop_back();\n\treturn ans;\n}\nint vis[N];\nbool cmp(int x,int y){\n\treturn a[x]<a[y];\n}\nvoid solve(int x){\n\tvis[x]=1;\n\tid[x].clear();\n\tfor (auto y : e[x])\n\t\tif (!vis[y])\n\t\t\tid[x].push_back(y);\n\tsort(id[x].begin(),id[x].end(),cmp);\n\tans[x].clear();\n\tfor (auto y : id[x])\n\t\tif (!vis[y]){\n\t\t\tsolve(y);\n\t\t\tans[x]=Merge(ans[x],ans[y]);\n\t\t}\n\treverse(ans[x].begin(),ans[x].end());\n\tans[x].push_back(a[x]);\n\treverse(ans[x].begin(),ans[x].end());\n}\nint main(){\n\tn=read();\n\tfor (int i=1;i<=n;i++){\n\t\ta[i]=read();\n\t\te[i].clear();\n\t}\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=i+1;j<=n;j++)\n\t\t\tif (gcd(a[i],a[j])!=1){\n\t\t\t\te[i].push_back(j);\n\t\t\t\te[j].push_back(i);\n\t\t\t}\n\tfor (int i=1;i<=n;i++)\n\t\te[0].push_back(i);\n\tsolve(0);\n\treverse(ans[0].begin(),ans[0].end());\n\tans[0].pop_back();\n\treverse(ans[0].begin(),ans[0].end());\n\tfor (auto y : ans[0])\n\t\tprintf(\"%d \",y);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n,a[2005],V;\nvector<int>edge[2005];\nbool used[2005][2005];\nbool in[2005];\nvector<int>nxt;\nP q;\nvoid dfs(int v){\n\tif(used[V][v]) return; used[V][v] = 1;\n\tnxt.pb(v);\n\trep(i,edge[v].size()){\n\t\tif(used[V][edge[v][i]] || in[edge[v][i]] != V) continue;\n\t\tdfs(edge[v][i]);\n\t}\n}\nvector<int>make(vector<int>L,int cut){\n\tvector<int>ret;\n\tif(L.size() == 1){\n\t\tret.pb(cut); return ret;\n\t}\n\trep(i,L.size()){\n\t\tin[L[i]] = cut;\n\t\tused[L[i]] = 0;\n\t}\n\trep(i,L.size()){\n\t\tif(L[i] == cut) continue;\n\t\tif(!used[cut][L[i]]){\n\t\t\tnxt.clear(); q = mp(INF,INF);\n\t\t\tV = cut; dfs(L[i]);\n\t\t\trep(j,nxt.size()){\n\t\t\t\tif(__gcd(a[nxt[j]],a[cut]) > 1){\n\t\t\t\t\tq = min(q,mp(a[nxt[j]],nxt[j]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tvector<int>hoge = make(nxt,q.sc);\n\t\t\tvector<int>ret2;\n\t\t\tint c = ret.size(),b = hoge.size();\n\t\t\tint i = 0,j = 0;\n\t\t\twhile(i!=c || j!=b){\n\t\t\t\tif(i==c) ret2.pb(hoge[j++]);\n\t\t\t\telse if(j==b) ret2.pb(ret[i++]);\n\t\t\t\telse{\n\t\t\t\t\tif(a[ret[i]] > a[hoge[j]]) ret2.pb(ret[i++]);\n\t\t\t\t\telse ret2.pb(hoge[j++]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tret = ret2;\n\t\t}\n\t}\n\treverse(ret.begin(),ret.end());\n\tret.pb(cut);\n\treverse(ret.begin(),ret.end());\n\treturn ret;\n}\nbool U[2005];\nvector<int>vi;\nP p;\nvoid DFS(int x){\n\tif(U[x]) return; U[x] = 1;\n\tvi.pb(x); p = min(p,mp(a[x],x));\n\trep(i,edge[x].size()){\n\t\tDFS(edge[x][i]);\n\t}\n}\nvector<int>res;\nint main(){\n\tcin>>n;\n\trepn(i,n){\n\t\tcin>>a[i];\n\t}\n\trepn(i,n) repn(j,n){\n\t\tif(i != j && __gcd(a[i],a[j]) > 1){\n\t\t\tedge[i].pb(j);\n\t\t}\n\t}\n\trepn(i,n){\n\t\tif(U[i]) continue; p = mp(INF,INF); vi.clear();\n\t\tDFS(i);\n\t\tvector<int>vec = make(vi,p.sc);\n\t\tvector<int>res2;\n\t\tint c = 0,b = 0;\n\t\twhile(c != res.size() || b != vec.size()){\n\t\t\tif(c == res.size()) res2.pb(vec[b++]);\n\t\t\telse if(b == vec.size()) res2.pb(res[c++]);\n\t\t\telse{\n\t\t\t\tif(a[res[c]] > a[vec[b]]) res2.pb(res[c++]);\n\t\t\t\telse res2.pb(vec[b++]);\n\t\t\t}\n\t\t}\n\t\tres = res2;\n\t}\n\trep(i,n) cout<<a[res[i]]<<\" \";\n\tcout<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long int ll;\ntypedef long double ld;\n#define pb push_back\n#define pii pair < int , int >\n#define F first\n#define S second\n#define endl '\\n'\n#define int long long\n#define sync ios_base::sync_with_stdio(false);cin.tie(0);cout.tie(0)\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n#define kill(x) return cout<<x<<'\\n', 0;\nusing namespace std;\nconst int N=2e3+100;\nvector <int> g[N];\nll par[N];\nll getpar(ll v){\n    if (par[v]==v) return v;\n    return par[v]=getpar(par[v]);\n}\nll a[N];\nvector <int> mol[N];\nvector <int> solve(vector <vector <int> > a){\n    vector <int> ans;\n    ll z=0;\n    set <pii> s;\n    for (int i=0;i<a.size();i++){\n        z+=a[i].size();\n        a[i].pb(-1),reverse(a[i].begin(),a[i].end());\n        s.insert({a[i].back(),i});\n    }\n    for (int i=0;i<z;i++){\n        pii u=*s.rbegin();\n        ans.pb(u.F);\n        a[u.S].pop_back();\n        s.erase(u);\n        s.insert({a[u.S].back(),u.S});\n    }\n    return ans;\n}\nll vis[N];\nvoid dfs(ll v){\n    vis[v]=1;\n    mol[v].pb(v);\n    vector <vector <int> > aa;\n    for (auto u : g[v]){\n        if (vis[u]) continue;\n        dfs(u);\n        aa.pb(mol[u]);\n    }\n    vector <int> ans=solve(aa);\n    for (auto u : ans) mol[v].pb(u);\n    return ;\n}\nint32_t main(){\n    ll n;\n    cin >> n;\n    for (int i=1;i<=n;i++){\n        cin >> a[i];\n    }\n    sort(a+1,a+n+1);\n    for (int i=1;i<=n;i++){\n        for (int j=i+1;j<=n;j++){\n            if (__gcd(a[i],a[j])!=1){\n                g[i].pb(j);\n                g[j].pb(i);\n            }\n        }\n    }\n    for (int i=1;i<=n;i++) sort(g[i].begin(),g[i].end());\n    for (int i=1;i<=n;i++){\n        par[i]=i;\n    }\n    vector <vector <int> > aa;\n    for (int i=1;i<=n;i++){\n        if (!vis[i]){\n            dfs(i);\n            aa.pb(mol[i]);\n        }\n    }\n    vector <int> ans=solve(aa);\n    for (auto u : ans) cout << a[u] << \" \" ;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 2005;\n\ninline int gcd(int a, int b)\n{ return b == 0 ? a : gcd(b, a%b); }\n\nint n, a[MAXN], g[MAXN][MAXN];\nint vis[MAXN];\n\nvector<int> nxt, cur;\n\nvector<int> link(const vector<int> &a, const vector<int> &b)\n{\n\tstatic vector<int> ret;\n\tret.clear();\n\tint i = 0, j = 0;\n\twhile (i < a.size() && j < b.size()) {\n\t\tif (a[i] > b[j]) ret.push_back(a[i++]);\n\t\telse ret.push_back(b[j++]);\n\t}\n\twhile (i < a.size()) ret.push_back(a[i++]);\n\twhile (j < b.size()) ret.push_back(b[j++]);\n\treturn ret;\n}\n\nstruct cmp {\n\tbool operator () (int x, int y) \n\t{ return a[x] == a[y] ? x > y : a[x] > a[y]; }\n};\n\npriority_queue<int,vector<int>, cmp> que;\n\nvoid find_top(int x, vector<int> &v)\n{\n\tque.push(x), vis[x] = 1;\n\twhile (!que.empty()) {\n\t\tint nd = que.top(); que.pop();\n\t\tv.push_back(a[nd]);\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tif (g[nd][i] && !vis[i]) {\n\t\t\t\tvis[i] = 1;\n\t\t\t\tque.push(i);\n\t\t\t}\n\t}\n}\n\t\nint main()\n{\n\tios::sync_with_stdio(false);\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++) cin >> a[i];\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 1; j < i; j++)\n\t\t\tg[i][j] = g[j][i] = (gcd(a[i], a[j]) != 1);\n\tstatic int b[MAXN];\n\tfor (int i = 1; i <= n; i++) b[i] = i;\n\tsort(b+1, b+n+1, [](int x, int y) { return a[x] < a[y]; });\n\tfor (int i = 1; i <= n; i++) {\n\t\tint now = b[i];\n\t\tif (!vis[now]) {\n\t\t\tnxt.clear();\n\t\t\tfind_top(now, nxt);\n\t\t\tcur = link(nxt, cur);\n\t\t}\n\t}\n\tfor (auto i : cur)\n\t\tcout << i << \" \";\n\tcout << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define per(i,b,a) for(int i=b;i>=a;i--)\n#define For(i,a,b) for(int i=a;i<=b;i++)\n#define Forenska(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\n#define all(x) x.begin(),x.end()\n#define sqr(x) ((x)*(x))\n#define lowbit(x) ((x)&(-x))\n#define GREATER(x) x,vector<x>,greater<x>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> pii;\ntypedef pair<LL,LL> pLL;\ntypedef vector<int> vec;\ntypedef vector<LL> vecL;\ntypedef vector<pii> vecP;\ntypedef vector<pLL> vecPL;\ntypedef vector<string> vecS;\ntypedef vector<vec> mat;\ntypedef complex<double> point;\nconst long double PI=3.1415926535897932384626433832795028841971693993751058209749445923078164062862089;\nconst LL INFLL=0x3f3f3f3f3f3f3f3f;\nconst int INF=0x3f3f3f3f;\nconst long double EPS=1e-10;\nint read()\n{\n\tint x=0;\n\tchar ch=' ';\n\tbool flag=false;\n\twhile(!isdigit(ch))\n\t{\n\t\tif(ch=='-')flag=true;\n\t\tch=getchar();\n\t}\n\twhile(isdigit(ch))\n\t{\n\t\tx=(x<<3)+(x<<1)+ch-'0';\n\t\tch=getchar();\n\t}\n\treturn flag?-x:x;\n}\nconst int MAX_N=2005;\nint n;\nint A[MAX_N];\nbool vis[MAX_N];\nvec g[MAX_N];\nvec g2[MAX_N];\nint in[MAX_N];\nvoid dfs(int v)\n{\n\tif(vis[v])return;\n\tvis[v]=true;\n\tForenska(it,g[v])\n\t{\n\t\tif(!vis[*it])\n\t\t{\n\t\t\tg2[v].pb(*it);\n\t\t\tdfs(*it);\n\t\t}\n\t}\n}\nvoid topo()\n{\n\tset <int> s;\n\trep(i,0,n)if(!vis[i])\n\t{\n\t\tdfs(i);\n\t\ts.insert(-i);\n\t}\n\twhile(!s.empty())\n\t{\n\t\tint t=-*s.begin();\n\t\ts.erase(s.begin());\n\t\tForenska(it,g2[t])\n\t\t{\n\t\t\ts.insert(-*it);\n\t\t}\n\t\tcout<<A[t]<<\" \";\n\t}\n}\nint main()\n{\n\tcin>>n;\n\trep(i,0,n)cin>>A[i];\n\tsort(A,A+n);\n\trep(i,0,n)rep(j,0,n)if(__gcd(A[i],A[j])>1)\n\t{\n\t\tg[i].pb(j);\n\t}\n\ttopo();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=2005;\nint a[N],vis[N];\nvector<int>e[N],g[N]; \npriority_queue<int>pq;\nvoid dfs(int v)\n{\n\tvis[v]=1;\n\tfor(int i=0;i<e[v].size();i++)\n\t{\n\t\tint u=e[v][i];\n\t\tif(vis[u])\n\t\t\tcontinue;\n\t\tg[v].push_back(u);\n\t\tdfs(u);\n\t}\n}\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++)\t\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(__gcd(a[i],a[j])>1)\n\t\t\t\te[i].push_back(j);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(!vis[i])\n\t\t{\n\t\t\tdfs(i);\n\t\t\tpq.push(i);\n\t\t}\n\t}\n\twhile(!pq.empty())\n\t{\n\t\tint k=pq.top();\n\t\tpq.pop();\n\t\tprintf(\"%d \",a[k]);\n\t\tfor(int i=0;i<g[k].size();i++)\n\t\t\tpq.push(g[k][i]);\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N=2005;\n\nint gcd(int a,int b)\n{\n\treturn !b?a:gcd(b,a%b);\n}\n\nint n,a[N],in[N];\nvector<int> G[N],E[N];\nbool v[N];\npriority_queue<int> Q;\n\nvoid DFS(int x)\n{\n\tv[x]=true;\n\tfor(auto &y:G[x])\n\t\tif(!v[y])\n\t\t{\n\t\t\tE[x].push_back(y);\n\t\t\tin[y]++;\n\t\t\tDFS(y);\n\t\t}\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1; i<=n; i++)\n\t\tscanf(\"%d\",&a[i]);\n\tsort(a+1,a+1+n);\n\tfor(int i=1; i<=n; i++)\n\t\tfor(int j=i+1; j<=n; j++)\n\t\t\tif(gcd(a[i],a[j])!=1)\n\t\t\t\tG[i].push_back(j),G[j].push_back(i);\n\tfor(int i=1; i<=n; i++)\n\t\tif(!v[i])\n\t\t\tDFS(i);\n\tmemset(v,0,sizeof(v));\n\tfor(int i=1; i<=n; i++)\n\t\tif(!in[i])\n\t\t{\n\t\t\tQ.push(i);\n\t\t\tv[i]=true;\n\t\t}\n\twhile(!Q.empty())\n\t{\n\t\tint x=Q.top();\n\t\tQ.pop();\n\t\tprintf(\"%d \",a[x]);\n\t\tfor(auto &y:E[x])\n\t\t\tif(!v[y])\n\t\t\t{\n\t\t\t\tif(!--in[y])\n\t\t\t\t{\n\t\t\t\t\tQ.push(y);\n\t\t\t\t\tv[y]=true;\n\t\t\t\t}\n\t\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,a[2005],in[2005];\nbool vis[2005];\npriority_queue<int> pq;\nvector<int> g[2005],nei[2005];\nvoid dfs(int x)\n{\n\tvis[x]=1;\n\tfor(int i=0;i<g[x].size();i++)\n\t\tif(!vis[g[x][i]])\n\t\t{\n\t\t\tin[g[x][i]]++;\n\t\t\tnei[x].push_back(g[x][i]);\n\t\t\tdfs(g[x][i]);\n\t\t}\n}\nvoid topo()\n{\n\tfor(int i=1;i<=n;i++)\n\t\tif(!in[i])\n\t\t\tpq.push(i);\n\twhile(!pq.empty())\n\t{\n\t\tint now=pq.top();\n\t\tpq.pop();\n\t\tcout<<a[now]<<' ';\n\t\tfor(int i=0;i<nei[now].size();i++) pq.push(nei[now][i]);\n\t}\n\tcout<<endl;\n}\nint main()\n{\n\tcin>>n;\n\tfor(int i=1;i<=n;i++)\n\t\tcin>>a[i];\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\tif(__gcd(a[i],a[j])!=1)\n\t\t\t{\n\t\t\t\tg[i].push_back(j);\n\t\t\t\tg[j].push_back(i);\n\t\t\t}\n\tfor(int i=1;i<=n;i++)\n\t\tif(!vis[i])\n\t\t\tdfs(i);\n\ttopo();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cctype>\n#include<cstdio>\n#include<vector>\n#include<utility>\n#include<algorithm>\nconst int N=2007;\nusing pi=std::pair<int,int>;\nint n,a[N],vis[N],deg[N];std::vector<int>e[N];std::priority_queue<pi>q;\nint read(){int x=0,c=getchar();while(isspace(c))c=getchar();while(isdigit(c))(x*=10)+=c&15,c=getchar();return x;}\nvoid dfs(int u)\n{\n    for(int v=vis[u]=1;v<=n;++v) if(!vis[v]&&std::__gcd(a[u],a[v])>1) e[u].push_back(v),++deg[v],dfs(v);\n}\nint main()\n{\n    n=read();\n    for(int i=1;i<=n;++i) a[i]=read();\n    std::sort(a+1,a+n+1);\n    for(int i=1;i<=n;++i) if(!vis[i]) dfs(i);\n    for(int i=1;i<=n;++i) if(!deg[i]) q.emplace(a[i],i);\n    for(int u;!q.empty();)\n    {\n\tprintf(\"%d \",q.top().first),u=q.top().second,q.pop();\n\tfor(int v:e[u]) if(!--deg[v]) q.emplace(a[v],v);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author majk\n */\n\n#ifndef MAJK_LIB\n#define MAJK_LIB\n\n#include <vector>\n#include <stack>\n#include <iostream>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <functional>\n#include <algorithm>\n#include <numeric>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <array>\n#include <bitset>\nusing namespace std;\n\n#define x first\n#define y second\ntypedef std::pair<int,int> pii; typedef long long ll; typedef unsigned long long ull; typedef unsigned int ui; typedef pair<ui,ui> puu;\n\ntemplate <typename T, typename U> std::istream&operator>>(std::istream&i, pair<T,U>&p) {i >> p.x >> p.y; return i;}\ntemplate<typename T>std::istream&operator>>(std::istream&i,vector<T>&t) {for(auto&v:t){i>>v;}return i;}\ntemplate <typename T, typename U> std::ostream&operator<<(std::ostream&o, const pair<T,U>&p) {o << p.x << ' ' << p.y; return o;}\ntemplate<typename T>std::ostream&operator<<(std::ostream&o,const vector<T>&t) {if(t.empty())o<<'\\n';for(size_t i=0;i<t.size();++i){o<<t[i]<<\" \\n\"[i == t.size()-1];}return o;}\ntemplate<typename T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T> using maxheap = priority_queue<T, vector<T>, less<T>>;\nui logceil(ll x) { return x?8*sizeof(ll)-__builtin_clzll(x):0; }\n\nnamespace std { template<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}}; }\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename F> double bshd(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){l=m;}else{h=m;}}return (l+h)/2;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename F> double bsld(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){h=m;}else{l=m;}}return (l+h)/2;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\n\ntemplate<typename T>class vector2:public vector<vector<T>>{public:vector2(){} vector2(size_t a,size_t b,T t=T()):vector<vector<T>>(a,vector<T>(b,t)){}};\ntemplate<typename T>class vector3:public vector<vector2<T>>{public:vector3(){} vector3(size_t a,size_t b,size_t c,T t=T()):vector<vector2<T>>(a,vector2<T>(b,c,t)){}};\ntemplate<typename T>class vector4:public vector<vector3<T>>{public:vector4(){} vector4(size_t a,size_t b,size_t c,size_t d,T t=T()):vector<vector3<T>>(a,vector3<T>(b,c,d,t)){}};\ntemplate<typename T>class vector5:public vector<vector4<T>>{public:vector5(){} vector5(size_t a,size_t b,size_t c,size_t d,size_t e,T t=T()):vector<vector4<T>>(a,vector4<T>(b,c,d,e,t)){}};\n\n\n#endif\n\nclass ERearranging {\npublic:\n    int N, M, P;\n    vector<vector<int>> Multiples;\n    vector<vector<int>> Factors;\n//    map<int, int> C;\n    vector<int> B;\n    vector<int> Stack;\n    vector<bool> Forbidden;\n    vector<int> CompVisit, PrimeVisit;\n    int CompTime;\n\n    vector<int> component(int value) {\n        ++CompTime;\n        CompVisit[value] = CompTime;\n        vector<int> Q{value};\n        for (int q = 0; q < Q.size(); ++q) {\n            int v = Q[q];\n            for (int f: Factors[v]) {\n                if (PrimeVisit[f] == CompTime) continue;\n                PrimeVisit[f] = CompTime;\n                for (int m: Multiples[f]) {\n                    if (Forbidden[m]) continue;\n                    if (CompVisit[m] == CompTime) continue;\n                    CompVisit[m] = CompTime;\n                    Q.push_back(m);\n                }\n            }\n        }\n        sort(Q.begin(),Q.end());\n        return Q;\n    }\n\n    vector<int> solve(const vector<int> &Component) {\n        vector<vector<int>> Others;\n        vector<bool> Used(N, false);\n\n        for (int val: Component) {\n            if (!Used[val]) {\n                auto cc = component(val);\n                for (int c: cc) Used[c] = true;\n\n                int root = -1;\n                for (int c: cc) {\n                    bool ok = Stack.empty() || gcd(B[Stack.back()], B[c]) != 1;\n//true;\n//                    for (int i = (int) Stack.size() - 1; i >= 0; --i) {\n//                        if (gcd(B[Stack[i]], B[c]) != 1) break;\n//                        else if (B[Stack[i]] < B[c]) {\n//                            ok = false;\n//                            break;\n//                        }\n//                    }\n                    if (ok) {\n                        root = c;\n                        break;\n                    }\n                }\n\n                Stack.push_back(root);\n                Forbidden[root] = true;\n                cc.erase(find(cc.begin(),cc.end(),root));\n                vector<int> Z = solve(cc);\n                Stack.pop_back();\n                Forbidden[root] = false;\n\n                Others.push_back({B[root]});\n                for (int z: Z) Others.back().push_back(z);\n            }\n        }\n\n        vector<int> Answer;\n        if (!Others.empty()) {\n            vector<int> Merged = Others[0];\n            for (int i = 1; i < Others.size(); ++i) {\n                vector<int> QQ;\n                int j = 0, k = 0;\n                while (j < Merged.size() || k < Others[i].size()) {\n                    if (j == Merged.size()) { QQ.push_back(Others[i][k++]); }\n                    else if (k == Others[i].size()) { QQ.push_back(Merged[j++]); }\n                    else if (Merged[j] < Others[i][k]) { QQ.push_back(Others[i][k++]); }\n                    else { QQ.push_back(Merged[j++]); }\n                }\n                swap(Merged, QQ);\n            }\n            for (int m: Merged) Answer.push_back(m);\n        }\n        return Answer;\n    }\n\n\n    void solve(istream& cin, ostream& cout) {\n        cin >> N;\n        vector<int> A(N); cin >> A;\n        sort(A.begin(),A.end());\n        B = A;\n\n        vector<int> Ans;\n        if (!B.empty()) {\n            Forbidden.assign(N, false);\n\n            CompTime = 0;\n            CompVisit.assign(N, 0);\n\n            vector<int> AllPrimes;\n            for (int b: B) {\n                int x = b;\n                for (int p = 2; p <= 10000; ++p) {\n                    if (x%p == 0) {\n                        AllPrimes.push_back(p);\n                        while (x%p == 0) x /= p;\n                    }\n                }\n                if (x != 1) {\n                    AllPrimes.push_back(x);\n                }\n            }\n            map<int, int> CompressPrimes;\n            P = 0;\n            sort(AllPrimes.begin(),AllPrimes.end());\n            AllPrimes.resize(distance(AllPrimes.begin(),unique(AllPrimes.begin(),AllPrimes.end())));\n            for (int p: AllPrimes) CompressPrimes[p] = P++;\n            Multiples.resize(P);\n            PrimeVisit.assign(P, 0);\n\n            for (int j = 0; j < N; ++j) {\n                int x = B[j];\n                Factors.push_back({});\n                for (int p = 2; p <= 10000; ++p) {\n                    if (x%p == 0) {\n                        Factors.back().push_back(CompressPrimes[p]);\n                        while (x%p == 0) x /= p;\n                        Multiples[CompressPrimes[p]].push_back(j);\n                    }\n                }\n                if (x != 1) {\n                    Factors.back().push_back(CompressPrimes[x]);\n                    Multiples[CompressPrimes[x]].push_back(j);\n                }\n            }\n\n            vector<int> All;\n            for (int i = 0; i < N; ++i) All.push_back(i);\n            auto res = solve(All);\n            for (int r: res) Ans.push_back(r);\n        }\n//        for (int i = 0; i < C[1]; ++i) Ans.push_back(1);\n        cout << Ans;\n    }\n};\n\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n\tERearranging solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<cassert>\n#define PB push_back\n#define MP make_pair\n#define sz(v) (in((v).size()))\n#define forn(i,n) for(in i=0;i<(n);++i)\n#define forv(i,v) forn(i,sz(v))\n#define fors(i,s) for(auto i=(s).begin();i!=(s).end();++i)\n#define all(v) (v).begin(),(v).end()\nusing namespace std;\ntypedef long long in;\ntypedef vector<in> VI;\ntypedef vector<VI> VVI;\nin ggt(in a, in b){\n  if(b==0)\n    return a;\n  return ggt(b,a%b);\n}\nin n;\nVVI d;\nVI a;\nVI usd;\nset<in> anchr;\nVI ord;\nint main(){\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cin>>n;\n  a.resize(n);\n  forn(i,n)\n    cin>>a[i];\n  usd.resize(n);\n  sort(all(a));\n  d.resize(n,VI(n));\n  forn(i,n){\n    forn(j,n){\n      if(j==i)\n\tcontinue;\n      if(ggt(a[i],a[j])==1)\n\td[i][j]=1;\n    }\n  }\n  forn(z,n){\n    if(usd[z])\n      continue;\n    anchr.insert(z);\n    usd[z]=1;\n    while(!anchr.empty()){\n      in u=*anchr.begin();\n      anchr.erase(u);\n      ord.PB(u);\n      forn(i,n){\n\tif(usd[i])\n\t  continue;\n\tif(d[u][i])\n\t  continue;\n\tanchr.insert(i);\n\tusd[i]=1;\n      }\n    }\n  }\n  VI blok(n);\n  forn(i,n){\n    for(in j=i+1;j<n;++j)\n      if(!d[ord[i]][ord[j]])\n\t++blok[ord[j]];\n  }\n  VI rord;\n  usd=VI(n,0);\n  in pos;\n  forn(z,n){\n    for(in i=n-1;i>=0;--i){\n      if(usd[i] || blok[i])\n\tcontinue;\n      rord.PB(i);\n      pos=0;\n      while(ord[pos]!=i)\n\t++pos;\n      for(in j=pos+1;j<n;++j){\n\tif(!d[i][ord[j]])\n\t  --blok[ord[j]];\n      }\n      usd[i]=1;\n      break;\n    }\n  }\n  forn(i,n)\n    cout<<a[rord[i]]<<\" \";\n  cout<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=2005;\nstruct que{\n\tint id,data;\n\tbool operator <(que i)const{\n\t\treturn data<i.data;\n\t}\n};\nstruct Edge{\n\tint to,nxt;\n}e[maxn*maxn];\nint n,sum=0;\nint cnt=0;\nint head[maxn];\nint a[maxn];\nint rd[maxn];\nint ans[maxn];\nbool g[maxn][maxn],vis[maxn];\nvector<int>p[maxn];\npriority_queue<que>q;\nvoid add(int u,int v){\n\trd[v]++;\n\te[cnt].to=v;\n\te[cnt].nxt=head[u];\n\thead[u]=cnt++;\n}\nvoid dfs(int x){\n\tvis[x]=1;\n\tp[cnt].push_back(a[x]);\n\tfor(int i=1;i<=n;i++){\n\t\tif(vis[i]||(!g[x][i]))continue;\n\t\tadd(x,i);\n\t\tdfs(i);\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tmemset(head,-1,sizeof(head));\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\tif(__gcd(a[i],a[j])>1)\n\t\t\t\tg[i][j]=g[j][i]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tif(!vis[i]){\n\t\t\tcnt++;\n\t\t\tdfs(i);\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tif(!rd[i]){\n\t\t\tque u;\n\t\t\tu.id=i;u.data=a[i];\n\t\t\tq.push(u);\n\t\t}\n\t}\n\twhile(!q.empty()){\n\t\tint k=q.top().id;\n\t\tprintf(\"%d \",a[k]);\n\t\tq.pop();\n\t\tfor(int i=head[k];i!=-1;i=e[i].nxt){\n\t\t\tint tmp=e[i].to;\n\t\t\trd[tmp]--;\n\t\t\tif(!rd[tmp]){\n\t\t\t\tque o;\n\t\t\t\to.id=tmp;o.data=a[tmp];\n\t\t\t\tq.push(o);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*************************************************\n *************************************************\n *************************************************\n *** _________________  |            |  |     /***\n ***         |          |            |  |    / ***\n ***         |          |            |  |   /  ***\n ***         |          |            |  |  /   ***\n ***         |          |            |  | /    ***\n ***         |          |____________|  |/  en ***\n ***         |          |            |  |\\     ***\n ***         |          |            |  | \\    ***\n *** _____   |          |            |  |  \\   ***\n ***   |     |          |            |  |   \\  ***\n ***   \\     /          |            |  |    \\ ***\n ***    \\___/           |            |  |     \\***\n *************************************************\n *************Written by: JiangHaoKai*************\n *************************************************/\n\n#pragma GCC optimize(2)\n#pragma G++ optimize(2)\n#pragma comment(linker,\"/STACK:102400000,102400000\")\n\n//#include <bits/stdc++.h>\n#include <cassert>\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdalign>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <string>\n#include <typeinfo>\n#include <valarray>\n#include <vector>\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <scoped_allocator>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <unordered_map>\n#include <unordered_set>\n//#include <conio.h>\n//#include <windows.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned int ui;\ntypedef unsigned long long ull;\ntypedef float fl;\ntypedef double ld;\ntypedef pair<int,int> pii;\n#define ui(n) ((unsigned int)(n))\n#define ll(n) ((long long)(n))\n#define ull(n) ((unsigned long long)(n))\n#define fl(n) ((float)(n))\n#define ld(n) ((double)(n))\n#define char(n) ((char)(n))\n#define Bool(n) ((bool)(n))\n#define fixpoint(n) fixed<<setprecision(n)\nconst int INF=1061109567;\nconst LL LINF=4557430888798830399;\n#define PI 3.1415926535897932384626433832795028841971\n#define MP make_pair\n#define MT make_tuple\n#define All(a) (a).begin(),(a).end()\n#define pall(a) (a).rbegin(),(a).rend()\n#define MOD 1000000007\n#define sz(a) ((int)(a).size())\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define repa(i,a,n) for(int i=a;i<n;i++)\n#define repa1(i,a,n) for(int i=a;i<=n;i++)\n#define repd(i,n) for(int i=n-1;i>=0;i--)\n#define repd1(i,n) for(int i=n;i>=1;i--)\n#define repda(i,n,a) for(int i=n;i>a;i--)\n#define repda1(i,n,a) for(int i=n;i>=a;i--)\n#define FOR(i,a,n,step) for(int i=a;i<n;i+=step)\n#define repv(itr,v) for(__typeof((v).begin()) itr=(v).begin();itr!=(v).end();itr++)\n#define repV(i,v) for(auto i:v)\n#define repE(i,v) for(auto &i:v)\n#define MS(x,y) memset(x,y,sizeof(x))\n#define MC(x) MS(x,0)\n#define MCP(x,y) memcpy(x,y,sizeof(y))\n#define sqr(x) ((x)*(x))\n#define filein(x) freopen(x,\"r\",stdin)\n#define fileout(x) freopen(x,\"w\",stdout)\n#define fileout2(filename,name) ofstream name(filename,ios::out)\n#define filein2(filename,name) ifstream name(filename,ios::in)\n#define file(filename,name) fstream name(filename,ios::in|ios::out)\n#define Pause system(\"pause\")\n#define Cls system(\"cls\")\n#define fs first\n#define sc second\n#define PC(x) putchar(x)\n#define GC(x) x=getchar()\n#define Endl PC('\\n')\n#define SF scanf\n#define PF printf\n\ninline int Read()\n{\n    int X=0,w=0;char ch=0;while(!isdigit(ch)){w|=ch=='-';ch=getchar();}while(isdigit(ch))X=(X<<3)+(X<<1)+(ch^48),ch=getchar();\n\treturn w?-X:X;\n}\ninline void Write(int x){if(x<0)putchar('-'),x=-x;if(x>9)Write(x/10);putchar(x%10+'0');}\n\ninline LL powmod(LL a,LL b){LL res=1;a%=MOD;assert(b>=0);for(;b;b>>=1){if(b&1)res=res*a%MOD;a=a*a%MOD;}return res;}\ninline LL gcdll(LL a,LL b){return b?gcdll(b,a%b):a;}\nconst int dx[]={0,1,0,-1,1,-1,-1,1};\nconst int dy[]={1,0,-1,0,-1,-1,1,1};\n/**************************************************************Begin***************************************************************/\nconst int maxn=2010;\n\nint n,nn,a[maxn],x[maxn];\nLL g[maxn][maxn],was[maxn];\nbool alive[maxn],canput[maxn];\n\nint main()\n{\n\tSF(\"%d\",&n);\n\trep(i,n) SF(\"%d\",&a[i]);\n\t\n\trep(i,n) rep(j,n) if(__gcd(a[i],a[j])>1)\n\t{\n\t\tg[i][j>>6]|=(1<<(j&63));\n\t\tg[j][i>>6]|=(1<<(i%63));\n\t}\n\t\n\tnn=((n-1)>>6)+1;\n\trep(i,n) alive[i]=canput[i]=1;\n\t\n\trep(it,n)\n\t{\n\t\trep(i,nn) was[i]=0;\n\t\trep(i,n) if(!alive[i]) was[i>>6]|=(1<<(i&63));\n\t\t\n\t\tint best=-1;\n\t\trep(i,n) if(!(was[i>>6]&(1<<(i&63))))\n\t\t{\n\t\t\tint b=0,e=1;\n\t\t\tx[0]=i;\n\t\t\twas[i>>6]|=(1<<(i&63));\n\t\t\t\n\t\t\twhile(b<e)\n\t\t\t{\n\t\t\t\trep(j,nn) if((g[x[b]][j]&was[j])!=g[x[b]][j])\n\t\t\t\t{\n\t\t\t\t\trepa(u,j*64,(j+1)*64) if(g[x[b]][u>>6]&(1<<(u&63))) if(!(was[u>>6]&(1<<(u&63))))\n\t\t\t\t\t{\n\t\t\t\t\t\twas[u>>6]|=(1<<(u&63));\n\t\t\t\t\t\tx[e++]=u;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tb++;\n\t\t\t}\n\t\t\t\n\t\t\tint cur=-1;\n\t\t\trep(j,e) if(canput[x[j]])\n\t\t\t{\n\t\t\t\tif(cur==-1||a[x[j]]<a[cur]) cur=x[j];\n\t\t\t}\n\t\t\t\n\t\t\tif(best==-1||(cur!=-1&&a[cur]>a[best])) best=cur;\n\t\t}\n\t\t\n\t\tPF(\"%d \",a[best]);\n\t\talive[best]=0;\n\t\trep(i,n) if(alive[i])\n\t\t{\n\t\t\tif(g[best][i>>6]&(1<<(i&63))) canput[i]=1;\n\t\t\telse if(a[best]<a[i]) canput[i]=0;\n\t\t}\n\t}\n\n\treturn 0;\n}\n/***************************************************************End****************************************************************/\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\n#define SZ 23333\nint n,a[SZ]; vector<int> adj[SZ];\nbool vv[SZ];\nvector<int> mg(vector<int> a,vector<int> b)\n{\n\tint ap=0,bp=0; vector<int> v;\n\twhile(ap<a.size()&&bp<b.size())\n\t{\n\t\tif(a[ap]>b[bp]) v.pb(a[ap++]);\n\t\telse v.pb(b[bp++]);\n\t}\n\twhile(ap<a.size()) v.pb(a[ap++]);\n\twhile(bp<b.size()) v.pb(b[bp++]);\n\treturn v;\n}\nvector<int> vs[SZ];\nvoid dfs(int x)\n{\n\tvv[x]=1; vector<int> w;\n\tfor(auto b:adj[x]) if(!vv[b])\n\t\tdfs(b), w=mg(w,vs[b]);\n\tw.insert(w.begin(),a[x]);vs[x]=w;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;++i)\n\t\tscanf(\"%d\",a+i);\n\tsort(a+1,a+1+n);\n\tfor(int i=n;i>=1;--i)\n\t\tfor(int j=1;j<i;++j)\n\t\t\tif(__gcd(a[i],a[j])>1)\n\t\t\t\tadj[i].pb(j),adj[j].pb(i);\n\tfor(int i=1;i<=n;++i) adj[0].pb(i);\n\tfor(int i=0;i<=n;++i)\n\t\tsort(adj[i].begin(),adj[i].end());\n\tdfs(0);\n\tfor(int i=1;i<=n;++i)\n\t\tprintf(\"%d \",vs[0][i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n//#include<ext/pb_ds/assoc_container.hpp>\n#pragma comment(linker, \"/STACK:16000000\")\n//#define map gp_hash_table\n#define PI 3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679\nusing namespace std;\n//using namespace __gnu_pbds;\nconst int inf=0x3f3f3f3f;\nconst long long inf2=0x3f3f3f3f3f3f3f3f;\nconst double eps=1e-6;\nconst int mod=1000000007;\nbool huzhi[2002][2002];\nint n;\npair<int,int> a[2002];\nint itr[2002];\nvector<vector<int> > vec;\nbool used[2002];\nvector<int> cur;\nvoid dfs(int x){\n\tused[x]=true;\n\tcur.push_back(a[x].first);\n\tfor(int i=1;i<=n;i++){\n\t\tif(used[i] || huzhi[i][x])continue;\n\t\tdfs(i);\n\t\treturn;\n\t}\n}\nbool ok(){\n\tfor(int i=0;i<vec.size();i++)if(itr[i]!=vec[i].size())return false;\n\treturn true;\n}\nsigned main(){\n\tvec.clear();\n\tios::sync_with_stdio(0);\n\tcin>>n;\n\tfor(int i=1;i<=n;i++)cin>>a[i].first,a[i].second=i;\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++)for(int j=1;j<=n;j++)if(__gcd(a[i].first,a[j].first)==1)huzhi[i][j]=true;\n\tfor(int i=1;i<=n;i++)if(!used[i]){\n\t\tcur.clear();\n\t\tdfs(i);\n\t\tvec.push_back(cur);\n\t}\n\tvector<int> ans;\n\twhile(!ok()){\n\t\tint mx=-1,pos=-1;\n\t\tfor(int i=0;i<vec.size();i++)if(vec[i][itr[i]]>mx)mx=vec[i][itr[i]],pos=i;\n\t\titr[pos]++;\n\t\tans.push_back(mx);\n\t}\n\tfor(int i=0;i<ans.size();i++)cout<<ans[i]<<\" \";\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint gcd(int x, int y) {\n    return !y ? x : gcd(y, x % y);\n}\nconst int N = 2010;\nint a[N], e[N][N], n, d[N];\nbool vis[N];\nvector<int> g[N];\nvoid dfs(int x) {\n    vis[x] = 1;\n    for (int i = 1; i <= n; i++) \n        if (!vis[i] && e[x][i]) {\n            g[x].push_back(i); d[i]++;\n            dfs(i);\n        }\n}\npriority_queue<int> q;\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n    sort(a + 1, a + 1 + n);\n    for (int i = 1; i <= n; i++)\n        for (int j = i + 1; j <= n; j++)\n            if (gcd(a[i], a[j]) > 1)\n                e[i][j] = e[j][i] = 1;\n    for (int i = 1; i <= n; i++)\n        if (!vis[i]) dfs(i);\n    for (int i = 1; i <= n; i++) if (!d[i]) q.push(i);\n    while (!q.empty()) {\n        int u = q.top(); q.pop();\n        printf(\"%d \", a[u]);\n        for (int i = 0; i < g[u].size(); i++) {\n            int v = g[u][i];\n            if (!(--d[v])) q.push(v);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nconst int N = 2010;\n\nvector <int> G[N], E[N];\nint n, a[N];\nbool vis[N], isrt[N];\n\ninline void Dfs(int x) {\n  vis[x] = 1;\n  sort(G[x].begin(), G[x].end());\n  for (auto i : G[x])\n    if (!vis[i]) Dfs(i), E[x].push_back(i);\n}\n\ninline void Topo() {\n  priority_queue <int> Q;\n  for (int i = 1; i <= n; i ++)\n    if (isrt[i]) Q.push(i);\n  for (int i = 1, x; i <= n; i ++) {\n    x = Q.top(); Q.pop();\n    printf(\"%d \", a[x]);\n    for (auto j : E[x]) Q.push(j);\n  }\n}\n\nint main() {\n  scanf(\"%d\", &n);\n  for (int i = 1; i <= n; i ++) scanf(\"%d\", &a[i]);\n  sort(a + 1, a + n + 1);\n  for (int i = 1; i <= n; i ++)\n    for (int j = i + 1; j <= n; j ++)\n      if (__gcd(a[i], a[j]) > 1) {\n        G[i].push_back(j);\n        G[j].push_back(i);\n      }\n  for (int i = 1; i <= n; i ++)\n    if (!vis[i]) Dfs(i), isrt[i] = 1;\n  Topo();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N = 2005;\n\nvector<int>V[N], p[N];\npriority_queue<int>Q;\nint a[N], n, Gr[N], u, v;\nbool vi[N];\nint gcd (int a, int b) { return b ? gcd(b, a % b) : a; }\n\nvoid Dfs (int u) {\n\tvi[u] = 1;\n\tsort(V[u].begin(), V[u].end());\n\tfor (auto v : V[u]) if (!vi[v]) p[u].emplace_back(v), ++Gr[v], Dfs(v);\n}\n\nint main () {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++i) scanf(\"%d\", &a[i]);\n\tsort(a + 1, a + n + 1);\n\tfor (int i = 1; i <= n; ++i) for (int j = i + 1; j <= n; ++j) if (gcd(a[i], a[j]) > 1) V[i].emplace_back(j), V[j].emplace_back(i);\n\tfor (int i = 1; i <= n; ++i) if (!vi[i]) Dfs(i), Q.push(i);\n\twhile (!Q.empty()) {\n\t\tu = Q.top(); Q.pop();\n\t\tprintf(\"%d \", a[u]);\n\t\tfor (auto v : p[u]) if (!--Gr[v]) Q.push(v);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h> \n#define N 2005\nusing namespace std;\nvector<int>v[N];\nint a[N],ans[N],Min[N],comp[N],last_not_coprime[N],n,cnt,tot,best_col[N],ID[N];\nbool used[N],b[N][N];\nint gcd(int x,int y){return !x?y:gcd(y%x,x);}\nvoid dfs(int from)\n{\n    comp[from]=cnt;\n\tfor(int i=0;i<v[from].size();i++)\n\t{\n\t\tint to=v[from][i];\n\t\tif(comp[to]>-1||used[to])continue;\n\t\tdfs(to);\n\t}\n}\nvoid colors()\n{\n\tcnt=0;memset(comp,-1,sizeof(comp));\n\tfor(int i=0;i<n;i++)\n\tif(!used[i]&&comp[i]==-1)\n\t{\n\t\tdfs(i);\n\t\tcnt++;\n\t}\n}\nint main()\n{\n\t//ios::sync_with_stdio(0);\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++)scanf(\"%d\",&a[i]);\n\tfor(int i=0;i<n;i++)\n\tfor(int j=0;j<n;j++)\n\tif(gcd(a[i],a[j])!=1)b[i][j]=b[j][i]=1,\n\tv[i].push_back(j),v[j].push_back(i);\n\tmemset(Min,0x3f,sizeof(Min));\n\tmemset(last_not_coprime,-1,sizeof(last_not_coprime));\n\twhile(1)\n\t{\n\t\tcolors();\n\t\tmemset(best_col,-1,sizeof(best_col));\n\t\tfor(int i=0;i<n;i++)\n\t\tif(Min[last_not_coprime[i]+1]>=a[i]&&!used[i])\n\t\t{\n\t\t\tif(best_col[comp[i]]==-1||a[i]<best_col[comp[i]])best_col[comp[i]]=a[i],\n\t\t\tID[comp[i]]=i;\n\t\t}\n\t\tint id=-1;\n\t\tfor(int i=0;i<cnt;i++)\n\t\t{\n\t\t\tif(best_col[i]==-1)continue;\n\t\t\tif(id==-1||best_col[id]<best_col[i])id=i;\n\t\t}\n\t\tid=ID[id];\n\t\tans[tot++]=a[id];\n\t\tif(tot==n)\n\t\t{\n\t\t\tprintf(\"%d\",ans[0]);\n\t\t\tfor(int i=1;i<n;i++)\n\t\t\tprintf(\" %d\",ans[i]);\n\t\t\tputchar('\\n');\n\t\t\treturn 0;\n\t\t}\n\t\tused[id]=1;\n\t\tfor(int i=0;i<tot;i++)\n\t\tMin[i]=min(Min[i],a[id]);\n\t\tfor(int i=0;i<n;i++)\n\t\tif(b[i][id])last_not_coprime[i]=tot-1;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nvector <int> g[2222];\nint a[2222];\nbool vis[2222];\nint opt;\n\nvoid dfs(int x) {\n\tvis[x] = true;\n\topt = min(opt, x);\n\tfor(int i : g[x]) {\n\t\tif(vis[i] == false) {\n\t\t\tdfs(i);\n\t\t}\n\t}\n}\nvector <int> merge(vector <int> &p, vector <int> &q) {\n\treverse(p.begin(), p.end());\n\treverse(q.begin(), q.end());\n\tvector <int> ans;\n\n\twhile(!(p.empty() && q.empty())) {\n\t\tif(p.empty()) {\n\t\t\tans.push_back(q.back());\n\t\t\tq.pop_back();\n\t\t} else if (q.empty()) {\n\t\t\tans.push_back(p.back());\n\t\t\tp.pop_back();\n\t\t} else if (p.back() < q.back()) {\n\t\t\tans.push_back(q.back());\n\t\t\tq.pop_back();\n\t\t} else {\n\t\t\tans.push_back(p.back());\n\t\t\tp.pop_back();\n\t\t}\n\t}\n\treturn ans;\n}\n\nvector <int> dp[2222];\nvector <int> aux[2222];\nbool done[2222];\n\nvoid solve(int x) {\n\tdone[x] = true;\n\tsort(g[x].begin(), g[x].end());\n\tfor(auto i : g[x]) {\n\t\tif(done[i] == false) {\n\t\t\tsolve(i);\n\t\t\taux[x].push_back(i);\n\t\t}\n\t}\n\tfor(auto i : aux[x]) {\n\t\tdp[x] = merge(dp[i], dp[x]);\n\t}\n\tdp[x].insert(dp[x].begin(), x);\n}\nint main(int argc, char const *argv[])\n{\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor(int i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\tsort(a + 1, a + n + 1);\n\tfor(int i = 1; i <= n; i++) {\n\t\tfor(int j = i + 1; j <= n; j++) {\n\t\t\tif(__gcd(a[i], a[j]) > 1) {\n\t\t\t\tg[i].push_back(j);\n\t\t\t\tg[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\n\tvector <int> ans;\n\tfor(int i = 1; i <= n; i++) {\n\t\tif(vis[i] == false) {\n\t\t\topt = n;\n\t\t\tdfs(i);\n\t\t\tsolve(opt);\n\t\t\tans = merge(ans, dp[opt]);\n\t\t}\n\t}\n\tfor(auto i : ans) {\n\t\tprintf(\"%d \", a[i]);\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n//#define USEPB_DS\n#define USETR1\n#define CPPELEVEN\n#define GPP\n\n/*\n * temp.cpp\n *\n *  Created on: 2012-7-18\n *      Author: BSBandme\n */\n//#pragma comment(linker, \"/STACK:1024000000,1024000000\")\n\n#include <iostream>\n#include <fstream>\n#include <string.h>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <cassert>\n#include <list>\n#include <iomanip>\n#include <math.h>\n#include <deque>\n#include <utility>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cctype>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <functional>\n#include <sstream>\n#include <tuple>\n\nusing namespace std;\n\n#ifndef CPPELEVEN\n#ifdef USETR1\n#include <tr1/unordered_map>\n#include <tr1/unordered_set>\nusing namespace tr1;\n#endif\n#else\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\n#ifdef USEPB_DS\n#include <ext/pb_ds/priority_queue.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\n// binomial_heap_tag, rc_binomial_heap_tag, thin_heap_tag, binary_heap_tag\ntypedef __gnu_pbds::priority_queue<int, greater<int>, pairing_heap_tag> pq_type;\n// splay_tree_tag, ov_tree_tag\ntypedef tree <int, null_type, less <int>, rb_tree_tag, tree_order_statistics_node_update> tree_type;\n#endif\n\n#define mpr make_pair\ntypedef unsigned int ui;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <double, double> pdd;\ntypedef vector <int> vi;\ntypedef vector <ll> vll;\ntypedef vector <double> vd;\ntypedef vector <string> vs;\ntypedef map <string, int> mpsi;\ntypedef map <double, int> mpdi;\ntypedef map <int, int> mpii;\n\nconst double pi = acos(0.0) * 2.0;\nconst long double eps = 1e-10;\nconst int step[8][2] = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}, {-1, 1}, {1, 1}, {1, -1}, {-1, -1}};\n\ntemplate <class T> inline T abs1(T a) {return a < 0 ? -a : a;}\n\n#ifndef CPPELEVEN\ntemplate <class T> inline T max1(T a, T b) { return b < a ? a : b; }\ntemplate <class T> inline T max1(T a, T b, T c) { return max1(max1(a, b), c); }\ntemplate <class T> inline T max1(T a, T b, T c, T d) { return max1(max1(a, b, c), d); }\ntemplate <class T> inline T max1(T a, T b, T c, T d, T e) { return max1(max1(a, b, c, d), e); }\ntemplate <class T> inline T min1(T a, T b) { return a < b ? a : b; }\ntemplate <class T> inline T min1(T a, T b, T c) { return min1(min1(a, b), c); }\ntemplate <class T> inline T min1(T a, T b, T c, T d) { return min1(min1(a, b, c), d); }\ntemplate <class T> inline T min1(T a, T b, T c, T d, T e) { return min1(min1(a, b, c, d), e); }\n#else\ntemplate <typename t, typename t1>\nt min1(t a, t1 b) { return a < b ? a : b; }\ntemplate <typename t, typename... arg>\nt min1(t a, arg... arr) { return min1(a, min1(arr...)); }\ntemplate <typename t, typename t1>\nt max1(t a, t1 b) { return a > b ? a : b; }\ntemplate <typename t, typename... arg>\nt max1(t a, arg... arr) { return max1(a, max1(arr...)); }\n#endif\n\ninline int jud(double a, double b){\n\tif(abs(a) < eps && abs(b) < eps) return 0;\n\telse if(abs1(a - b) / max(abs1(a), abs1(b)) < eps) return 0;\n\tif(a < b) return -1;\n\treturn 1;\n}\ntemplate <typename t> inline int jud(t a, t b){\n\tif(a < b) return -1;\n\tif(a == b) return 0;\n\treturn 1;\n}\n\n// f_lb == 1代表返回相同的一串的左边界，f_small == 1代表返回如果没有寻找的值返回小的数\ntemplate <typename it, typename t1>\ninline int find(t1 val, it a, int na, bool f_small = 1, bool f_lb = 1){\n\tif(na == 0) return 0;\n\tint be = 0, en = na - 1;\n\tif(*a <= *(a + na - 1)){\n\t\tif(f_lb == 0) while(be < en){\n\t\t\tint mid = (be + en + 1) / 2;\n\t\t\tif(jud(*(a + mid), val) != 1) be = mid;\n\t\t\telse en = mid - 1;\n\t\t}else while(be < en){\n\t\t\tint mid = (be + en) / 2;\n\t\t\tif(jud(*(a + mid), val) != -1) en = mid;\n\t\t\telse be = mid + 1;\n\t\t}\n\t\tif(f_small && jud(*(a + be), val) == 1) be--;\n\t\tif(!f_small && jud(*(a + be), val) == -1) be++;\n\t} else {\n\t\tif(f_lb) while(be < en){\n\t\t\tint mid = (be + en + 1) / 2;\n\t\t\tif(jud(*(a + mid), val) != -1) be = mid;\n\t\t\telse en = mid - 1;\n\t\t}else while(be < en){\n\t\t\tint mid = (be + en) / 2;\n\t\t\tif(jud(*(a + mid), val) != 1) en = mid;\n\t\t\telse be = mid + 1;\n\t\t}\n\t\tif(!f_small && jud(*(a + be), val) == -1) be--;\n\t\tif(f_small && jud(*(a + be), val) == 1) be++;\n\t}\n\treturn be;\n}\n\ntemplate <class T> inline T lowb(T num) {return num & (-num); }\n#ifdef GPP\ninline int bitnum(ui nValue) { return __builtin_popcount(nValue); }\ninline int bitnum(int nValue) { return __builtin_popcount(nValue); }\ninline int bitnum(ull nValue) { return __builtin_popcount(nValue) + __builtin_popcount(nValue >> 32); }\ninline int bitnum(ll nValue) { return __builtin_popcount(nValue) + __builtin_popcount(nValue >> 32); }\ninline int bitmaxl(ui a) { if(a == 0) return 0; return 32 - __builtin_clz(a); }\ninline int bitmaxl(int a) { if(a == 0) return 0; return 32 - __builtin_clz(a); }\ninline int bitmaxl(ull a) { int temp = a >> 32; if(temp) return 32 - __builtin_clz(temp) + 32; return bitmaxl(int(a)); }\ninline int bitmaxl(ll a) { int temp = a >> 32; if(temp) return 32 - __builtin_clz(temp) + 32; return bitmaxl(int(a)); }\n#else\n#endif\n\nlong long pow(long long n, long long m, long long mod = 0){\n\tif(m < 0) return 0;\n\tlong long ans = 1;\n\tlong long k = n;\n\twhile(m){\n\t\tif(m & 1) {\n\t\t\tans *= k;\n\t\t\tif(mod) ans %= mod;\n\t\t}\n\t\tk *= k;\n\t\tif(mod) k %= mod;\n\t\tm >>= 1;\n\t}\n\treturn ans;\n}\n\n#define  MOD 1000000007\ntemplate <class t1, class t2>\ninline void add(t1 &a, t2 b, int mod = -1) {\n\tif(mod == -1) mod = MOD;\n\ta += b;\n\twhile(a >= mod) a -= mod;\n\twhile(a < 0) a += mod;\n}\ntemplate <class t>\nvoid output1(t arr) {\n\tfor(int i = 0; i < (int)arr.size(); i++)\n\t\tcerr << arr[i] << ' ';\n\tcerr << endl;\n}\ntemplate <class t>\nvoid output2(t arr) {\n\tfor(int i = 0; i < (int)arr.size(); i++)\n\t\toutput1(arr[i]);\n}\n\n//....................密..........封..........线..........下..........禁..........止..........hack...............................................\n\nconst int maxn = 2010;\nint arr[maxn];\nint ans[maxn], lans;\nbitset <maxn> e[maxn];\nint have[maxn];\nint n;\n\nvoid dfs(int no) {\n\tans[lans++] = arr[no];\n\thave[no] = 1;\n\tvector <pii> temp;\n\tfor(int i = 0; i < n; i++) if(!have[i] && e[no].test(i)) {\n\t\ttemp.push_back(mpr(arr[i], i));\n\t}\n\tsort(temp.begin(), temp.end());\n\tint rlans = lans, rlans1 = lans;\n\tfor(auto it : temp\t) if(!have[it.second]) {\n\t\tdfs(it.second);\n\t\treverse(ans + rlans1, ans + lans);\n\t\trlans1 = lans;\n\t}\n\treverse(ans + rlans, ans + lans);\n}\n\nint main() {\n\n\n//............................不要再忘了检查maxn大小了！！！！BSBandme你个SB！！！！...................................................\n\n\tios_base::sync_with_stdio(0);\n\t#ifdef DEBUG //......................................................................................................\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint __size__ = 256 << 20; // 256MB\n\tchar *__p__ = (char*)malloc(__size__) + __size__;\n\t__asm__(\"movl %0, %%esp\\n\" :: \"r\"(__p__));\n\t#endif //...........................................................................................................\n\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", arr + i);\n\t}\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = i + 1; j < n; j++) if(__gcd(arr[i], arr[j]) != 1) {\n\t\t\te[i].set(j, 1);\n\t\t\te[j].set(i, 1);\n\t\t}\n\n\tfor(int i = 0; i < n; i++) if(!have[i]) {\n\t\tint rlans = lans;\n\t\tdfs(i);\n\t\treverse(ans + rlans, ans + lans);\n\t}\n\tfor(int i = lans - 1; i >= 0; i--)\n\t\tprintf(\"%d \", ans[i]);\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define db double\n\nusing namespace std;\nconst int N=2000+10;\nint rd()\n{\n    int x=0,w=1;char ch=0;\n    while(ch<'0'||ch>'9'){if(ch=='-') w=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+(ch^48);ch=getchar();}\n    return x*w;\n}\nint to[N<<5],nt[N<<5],hd[N<<4],tot=1;\nvoid adde(int x,int y)\n{\n\t++tot,to[tot]=y,nt[tot]=hd[x],hd[x]=tot;\n\t++tot,to[tot]=x,nt[tot]=hd[y],hd[y]=tot;\n}\nint n,t,a[N],vs[N],ti,ban[N<<4],dl[N],sq[N],ts,ff[N];\nint findf(int x){return ff[x]==x?x:ff[x]=findf(ff[x]);}\nvector<int> an[N],ls,nl;\nmap<int,int> id;\n\nint main()\n{\n\tn=rd(),t=n;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\ta[i]=rd();\n\t\tint x=a[i],sqt=sqrt(x);\n\t\tfor(int j=2;j<=sqt;++j)\n\t\t\tif(x%j==0)\n\t\t\t{\n\t\t\t\tif(!id[j]) id[j]=++t;\n\t\t\t\tadde(i,id[j]);\n\t\t\t\twhile(x%j==0) x/=j;\n\t\t\t}\n\t\tif(x>1)\n\t\t{\n\t\t\tif(!id[x]) id[x]=++t;\n\t\t\tadde(i,id[x]);\n\t\t}\n\t}\n\tmemset(vs,0x3f3f3f,sizeof(vs));\n\ta[0]=1<<30;\n\tint rs=n;\n\twhile(rs--)\n\t{\n\t\tint sx=0;\n\t\tfor(int i=1;i<=n;++i)\n\t\t\tif(!dl[i]&&vs[sx]>vs[i]) sx=i;\n\t\tif(!sx)\n\t\t{\n\t\t\tfor(int i=1;i<=n;++i)\n\t\t\t\tif(!dl[i]&&a[sx]>a[i]) sx=i;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor(int i=1;i<=n;++i)\n\t\t\t\tif(!dl[i]&&vs[i]==vs[sx]&&a[sx]>a[i]) sx=i;\n\t\t}\n\t\tdl[sx]=1,sq[++ts]=sx;\n\t\tvs[sx]=vs[0];\n\t\tfor(int i=hd[sx];i;i=nt[i])\n\t\t{\n\t\t\tint y=to[i];\n\t\t\tban[i>>1]=1;\n\t\t\tfor(int j=hd[y];j;j=nt[j])\n\t\t\t{\n\t\t\t\tif(ban[j>>1]) continue;\n\t\t\t\tint z=to[j];\n\t\t\t\tvs[z]=ts;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;++i) ff[i]=i,an[i].push_back(a[i]);\n\twhile(ts)\n\t{\n\t\tint x=sq[ts--];\n\t\tls.clear();\n\t\tfor(int i=hd[x];i;i=nt[i])\n\t\t{\n\t\t\tint y=to[i];\n\t\t\tban[i>>1]=0;\n\t\t\tfor(int j=hd[y];j;j=nt[j])\n\t\t\t{\n\t\t\t\tif(ban[j>>1]) continue;\n\t\t\t\tint z=to[j];\n\t\t\t\tif((z=findf(z))!=findf(x))\n\t\t\t\t{\n\t\t\t\t\tint nn=ls.size(),mm=an[z].size(),p=0,q=0,r=0;\n\t\t\t\t\tnl.clear(),nl.resize(nn+mm);\n\t\t\t\t\twhile(p<nn&&q<mm)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(ls[p]>an[z][q]) nl[r++]=ls[p],++p;\n\t\t\t\t\t\telse nl[r++]=an[z][q],++q;\n\t\t\t\t\t}\n\t\t\t\t\twhile(p<nn) nl[r++]=ls[p],++p;\n\t\t\t\t\twhile(q<mm) nl[r++]=an[z][q],++q;\n\t\t\t\t\tls=nl;\n\t\t\t\t\tff[z]=x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint nn=ls.size();\n\t\tfor(int i=0;i<nn;++i) an[x].push_back(ls[i]);\n\t}\n\tls.clear();\n\tfor(int i=1;i<=n;++i)\n\t\tif(findf(i)==i)\n\t\t{\n\t\t\tint nn=ls.size(),mm=an[i].size(),p=0,q=0,r=0;\n\t\t\tnl.clear(),nl.resize(nn+mm);\n\t\t\twhile(p<nn&&q<mm)\n\t\t\t{\n\t\t\t\tif(ls[p]>an[i][q]) nl[r++]=ls[p],++p;\n\t\t\t\telse nl[r++]=an[i][q],++q;\n\t\t\t}\n\t\t\twhile(p<nn) nl[r++]=ls[p],++p;\n\t\t\twhile(q<mm) nl[r++]=an[i][q],++q;\n\t\t\tls=nl;\n\t\t}\n\tfor(int i=0;i<n;++i) printf(\"%d \",ls[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//In the Name of God\n//Let Our Voices Echo\n#pragma GCC optimize(\"O3\")\n#include<bits/stdc++.h>\nusing namespace std;\n#define X real()\n#define Y imag()\ntypedef long long ll;\ntypedef double ld; \ntypedef complex<ld> point;\nconst ld eps=1e-9;\nconst int MAX=2e3+9,MOD=1e9+7;\nint n,a[MAX];\nmap<int,vector<int> > mp;\nint main()\n{\n\tios_base::sync_with_stdio(false),cin.tie(0),cout.tie(0);\n\tcin>>n;\n\tfor (int i=0;i<n;i++) \n\t{\t\n\t\tcin>>a[i];\n\t\tfor (int j=1;j*j<=a[i];j++)\n\t\t\tif (a[i]%j==0)\n\t\t\t{\n\t\t\t\tmp[j].push_back(a[i]);\n\t\t\t\tif (a[i]!=j*j)\n\t\t\t\t\tmp[a[i]/j].push_back(a[i]);\n\t\t\t}\n\t}\n\tint ans=0;\n\tfor (auto &i:mp) ans=ans*2+1;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\nusing namespace std;\ninline int read()\n{\n\tint x;char c;\n\twhile((c=getchar())<'0'||c>'9');\n\tfor(x=c-'0';(c=getchar())>='0'&&c<='9';)x=x*10+c-'0';\n\treturn x;\n}\n#define MN 2000\nint a[MN+5],u[MN+5],mn;\nvector<int> v[MN+5],ans[MN+5];\nint gcd(int x,int y){return y?gcd(y,x%y):x;}\nvoid dfs(int x)\n{\n\tu[x]=1;if(a[x]<a[mn])mn=x;\n\tfor(int i=0;i<v[x].size();++i)if(!u[v[x][i]])dfs(v[x][i]);\n}\nbool cmp(int x,int y){return a[x]<a[y];}\nvoid merge(vector<int>&x,vector<int>&y)\n{\n\tvector<int> z;int i=0,j=0;\n\twhile(i<x.size()&&j<y.size())z.push_back(x[i]>y[j]?x[i++]:y[j++]);\n\twhile(i<x.size())z.push_back(x[i++]);\n\twhile(j<y.size())z.push_back(y[j++]);\n\tx.clear();\n\tfor(int i=0;i<z.size();++i)x.push_back(z[i]);\n}\nvoid solve(int x)\n{\n\tu[x]=2;sort(v[x].begin(),v[x].end(),cmp);\n\tfor(int i=0;i<v[x].size();++i)if(u[v[x][i]]<2)\n\t\tsolve(v[x][i]),merge(ans[x],ans[v[x][i]]);\n\tans[x].push_back(0);\n\tfor(int i=ans[x].size();--i;)ans[x][i]=ans[x][i-1];\n\tans[x][0]=a[x];\n}\nint main()\n{\n\tint n=read(),i,j;\n\tfor(i=1;i<=n;++i)a[i]=read();\n\tfor(i=1;i<=n;++i)for(j=1;j<i;++j)if(gcd(a[i],a[j])>1)\n\t\tv[i].push_back(j),v[j].push_back(i);\n\tfor(i=1;i<=n;++i)if(!u[i])dfs(mn=i),solve(mn),merge(ans[0],ans[mn]);\n\tfor(i=0;i<ans[0].size();++i)printf(\"%d \",ans[0][i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define For(i, j, k) for(int i = j; i <= k; i++)\n#define pb push_back\n\nusing namespace std;\n\ntypedef vector<int> VI;\n\nconst int N = 2010;\n\nint n;\nint A[N];\nvector<int> G[N];\n\nint gcd(int a, int b){\n\treturn !b ? a : gcd(b, a % b);\n}\n\nbool vis[N], used[N];\n\nint DFS_findmin(int o, int f){\n\tvis[o] = true;\n\tint ret = A[o] == 1 || gcd(A[f], A[o]) != 1 ? o : n + 1;\n\tfor(int v : G[o]){\n\t\tif(vis[v] || used[v]) continue;\n\t\tint x = DFS_findmin(v, f);\n\t\tret = A[ret] < A[x] ? ret : x;\n\t}\n\treturn ret;\n}\n\nVI work(int o, int f){\n\tmemset(vis, false, sizeof vis);\n\tint rt = DFS_findmin(o, f);\n\tused[rt] = true;\n\tVI ans;\n\n\tfor(int v : G[rt]){\n\t\tif(used[v]) continue;\n\n\t\tVI S = work(v, rt), tmp;\n\t\tauto p = ans.begin(), q = S.begin();\n\n\t\twhile(p != ans.end() && q != S.end()){\n\t\t\tif(*p > *q) tmp.pb(*p), ++p;\n\t\t\telse tmp.pb(*q), ++q;\n\t\t}\n\n\t\twhile(p != ans.end()) tmp.pb(*p), ++p;\n\t\twhile(q != S.end()) tmp.pb(*q), ++q;\n\n\t\tans = tmp;\n\t}\n\tans.insert(ans.begin(), A[rt]);\n\treturn ans;\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\tFor(i, 1, n) scanf(\"%d\", &A[i]);\n\tA[n + 1] = 1e9;\n\n\tFor(i, 1, n){\n\t\tFor(j, i + 1, n)\n\t\t\tif(gcd(A[i], A[j]) > 1) G[i].pb(j), G[j].pb(i);\n\t\tG[0].pb(i), G[i].pb(0);\n\t}\n\n\tVI ans = work(0, 0);\n\tFor(i, 1, n) printf(\"%d%c\", ans[i], i == n ? '\\n' : ' ');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <stdio.h>\n#include <stdlib.h>\n#include <vector>\n#include <map>\n//#include <self/operator>\n#include <queue>\n#include <set>\n#include <string>\n#include <string.h>\n#include <stack>\n#include <assert.h>\n#include <bitset>\n#define Endl endl\n#define mp make_pair\n#define ll long long \n#define ull unsigned long long\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define over(A) {cout<<A<<endl;exit(0);}\n#define all(A) A.begin(),A.end()\n#define ceil(a,b) ((a-1)/b+1)\n#define quickcin ios_base::sync_with_stdio(false);\nconst int mod=1e9+7;\nconst int inf=1039074182;\nconst ll llinf=1LL*inf*inf;\nusing namespace std;\ntemplate <typename T1,typename T2> inline void chmin(T1 &x,T2 b) {if(b<x) x=b;}\ntemplate <typename T1,typename T2> inline void chmax(T1 &x,T2 b) {if(b>x) x=b;}\ntemplate <typename T1,typename T2> inline void chadd(T1 &x,T2 b) {x+=b;if(x>=mod) x-=mod;}\ntemplate <typename T1,typename T2> inline void chmul(T1 &x,T2 b) {x=1LL*x*b%mod;}\ntemplate <typename T1,typename T2> inline void chmod(T1 &x,T2 b) {x%=b,x+=b;if(x>=b) x-=b;}\nint n;\nint a[2005];\nvector <int> vec[2005];\nvector <int> prime;\nbool block[2005];\n\ninline vector <int> merge(vector <int> a,vector <int> b)\n{\n\tvector <int> res;\n\tint la=(int)a.size();\n\tint lb=(int)b.size();\n\tres.push_back(a[0]);\n\tfor(int i=1,j=0;;)\n\t{\n\t\tif(i==la && j==lb) break;\n\t\tif(i==la) res.push_back(b[j++]);\n\t\telse if(j==lb) res.push_back(a[i++]);\n\t\telse if(a[i]>b[j]) res.push_back(a[i++]);\n\t\telse res.push_back(b[j++]);\n\t}\n\treturn res;\n}\n\n//#include <self/operator>\nvector <int> dfs(int x)\n{\n\tvector <int> res;\n\tres.push_back(a[x]);\n\tblock[x]=true;\n\tfor(auto &u:vec[x])\n\t{\n\t\tif(block[u]) continue;\n\t\tres=merge(res,dfs(u));\n\t}\n\treturn res;\n}\n\nvoid build_graph()\n{\n\ta[n]=0;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<n;j++)\n\t\t{\n\t\t\tif(i==j) continue;\n\t\t\tif(__gcd(a[i],a[j])!=1) vec[i].push_back(j);\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tvec[i].push_back(n);\n\t\tvec[n].push_back(i);\n\t}\n}\n\nvoid print_graph()\n{\n\tcout<<\"--------Graph is below--------\"<<endl;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int &j:vec[i])\n\t\t{\n\t\t\tcout<<i<<' '<<j<<endl;\n\t\t}\n\t}\n\tcout<<\"--------Graph is above--------\"<<endl;\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\",\"r\",stdin);\n\tcin>>n;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcin>>a[i];\n\t}\n\tbuild_graph();\n\tfor(auto &x:dfs(n))\n\t{\n\t\tif(x==0) continue;\n\t\tcout<<x<<' ';\n\t}\n\tcout<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nint A[2020];\nvector<pair<int,int>> E[2020];\nint vis[2020];\n\ndeque<int> dfs(int cur) {\n\tdeque<int> R;\n\tvis[cur]=1;\n\tsort(ALL(E[cur]));\n\tFORR(r,E[cur]) if(vis[r.second]==0) {\n\t\tdeque<int> R2=dfs(r.second), R3;\n\t\twhile(R.size() || R2.size()) {\n\t\t\tif(R2.size() && (R.empty() || R.front()<=R2.front())) {\n\t\t\t\tR3.push_back(R2.front());\n\t\t\t\tR2.pop_front();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tR3.push_back(R.front());\n\t\t\t\tR.pop_front();\n\t\t\t}\n\t\t}\n\t\tR=R3;\n\t}\n\tR.push_front(A[cur]);\n\treturn R;\n}\n\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N) cin>>A[i];\n\tFOR(x,N) FOR(y,N) if(x!=y && __gcd(A[x],A[y])>1) E[x].push_back({A[y],y});\n\t\n\tFOR(i,N) E[N].push_back({A[i],i});\n\tauto ret=dfs(N);\n\tFOR(i,N) _P(\"%d%c\",ret[i+1],(i==N-1)?'\\n':' ');\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pp;\ntypedef pair<ll,ll> pll;\nvoid read(int& x){ scanf(\"%d\",&x); }\nvoid read(ll& x){ scanf(\"%lld\",&x); }\ntemplate<typename T,typename... Args>\nvoid read(T& a,Args&... b){ read(a); read(b...); }\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define x first\n#define y second\nint gcd(int a, int b){ return b?gcd(b, a%b):a; }\n\nint n;\n\nint arr[2010];\nvector<int> edge[2010];\n\nvector<int> join_all(int init, vector<vector<int>>& vs){\n    vector<int> ret;\n    priority_queue<pp> pq;\n    if(init != -1) ret.pb(init);\n    int n=vs.size();\n    for(int i=0; i<n; ++i){\n        reverse(all(vs[i]));\n        pq.push(pp{vs[i].back(), i});\n        vs[i].pop_back();\n    }\n    while(pq.size()){\n        int a, b; tie(a, b)=pq.top(); pq.pop();\n        ret.pb(a);\n        if(vs[b].size()) pq.push(pp{vs[b].back(), b}), vs[b].pop_back();\n    }\n    return ret;\n}\n\nbool vis[2010];\nbool vis_dfs[2010];\nint par[2010];\n\nvector<int> comp;\nvoid dfs(int x){\n    vis_dfs[x]=1;\n    comp.pb(x);\n    for(int y:edge[x]) if(!vis[y] && !vis_dfs[y]) dfs(y);\n}\n\nvector<int> dfs2(int x){\n    vis_dfs[x]=1;\n    vis[x]=1;\n    vector<vector<int>> cv;\n    for(int y:edge[x]) if(!vis[y] && !vis_dfs[y]){\n        cv.pb(dfs2(y));\n    }\n    return join_all(arr[x], cv);\n}\n\nvector<int> work_comp(int x){\n    comp.clear(); dfs(x);\n    for(int a:comp) vis_dfs[a]=0;\n    int k=comp.size(), mi=comp[0];\n    for(int i=1; i<k; ++i) if(arr[mi]>arr[comp[i]]) mi=comp[i];\n    vis[mi]=1;\n    return dfs2(mi);\n}\n\nint main()\n{\n\tread(n);\n\tfor(int i=1; i<=n; ++i) read(arr[i]);\n\t\n\tfor(int i=1; i<n; ++i) for(int j=i+1; j<=n; ++j){\n        if(gcd(arr[i], arr[j])!=1){\n            edge[i].pb(j);\n            edge[j].pb(i);\n        }\n\t}\n\t\n\tvector<vector<int>> vs;\n\t\n\tfor(int i=1; i<=n; ++i) if(!vis[i]) vs.pb(work_comp(i));\n    \n    for(int x:join_all(-1, vs)) printf(\"%d \", x);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a,ll b) { return b==0?a:gcd(b,a%b); }\n\nconst int MAXN=2000;\n\nint n;\nint a[MAXN];\nint ret[MAXN];\n\nbool done[MAXN];\nbool e[MAXN+1][MAXN+1];\n\nvector<int> merge(const vector<int> &a,const vector<int> &b) {\n\tvector<int> c(SZ(a)+SZ(b),-1);\n\tint ai=0,bi=0;\n\twhile(ai<SZ(a)||bi<SZ(b)) {\n\t\tif(ai<SZ(a)&&(bi>=SZ(b)||a[ai]>b[bi])) c[ai+bi]=a[ai++]; else c[ai+bi]=b[bi++];\n\t}\n\treturn c;\n}\n\nvector<int> dfs(int at) {\n\tdone[at]=true;\n\tvector<int> ret;\n\tREP(to,n) if(!done[to]&&e[at][to]) {\n\t\tvector<int> cur=dfs(to); cur.insert(cur.begin(),a[to]);\n\t\tret=merge(ret,cur);\n\t}\n\treturn ret;\n}\n\nvoid solve() {\n\tsort(a,a+n);\n\tREPE(i,n) REPE(j,n) e[i][j]=i!=j&&(i==n||j==n||gcd(a[i],a[j])!=1);\n\tREP(i,n) done[i]=false;\n\t// in each connected component, any unmarked node can be chosen iff there is no connected component with a higher lowest unmarked node\n\t// algorithm: for each connected component, determine the lowest unmarked node. choose the highest of them. mark all nodes in that cc. unmark the adjacent nodes.\n\t// different connected components can be merged later -> always choose lowest unprocessed adjacent node\n\t\n\tvector<int> ret=dfs(n);\n\tREP(i,n) { if(i!=0) printf(\" \"); printf(\"%d\",ret[i]); } puts(\"\");\n}\n\nvoid run() {\n\tscanf(\"%d\",&n);\n\tREP(i,n) scanf(\"%d\",&a[i]);\n\tsolve();\n}\n\nint main() {\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n██████████████████████████████████████████████████████████████████████████████\n██              ██████    ██████      ██      ██  ██    ██████              ██\n██  ██████████  ██  ██      ██      ██████████████  ██████  ██  ██████████  ██\n██  ██      ██  ██    ██  ████      ██    ██████████    ██  ██  ██      ██  ██\n██  ██      ██  ██    ██  ██      ██  ████        ██  ████  ██  ██      ██  ██\n██  ██      ██  ██  ██████  ████  ████████████  ██    ████████  ██      ██  ██\n██  ██████████  ██  ████  ██    ████    ████  ██████  ████  ██  ██████████  ██\n██              ██  ██  ██  ██  ██  ██  ██  ██  ██  ██  ██  ██              ██\n████████████████████  ██  ██    ██████  ██    ████  ████    ██████████████████\n██████  ████          ████        ██    ██    ████  ████████  ██          ████\n████  ██      ██  ██      ██  ██████  ████  ████    ██    ████    ████████  ██\n██      ██      ██    ██    ████      ████        ██████  ██      ██  ██    ██\n██  ██    ████████████  ████  ██  ████            ████  ████████████  ████  ██\n██  ██      ██  ██  ████    ████████                ████████      ██  ██    ██\n██  ██  ██  ██████████  ████    ██  ████  ██    ████  ████        ████  ██  ██\n██    ██  ████  ██████  ██    ******************    ████  ██            ██  ██\n██    ██████  ██  ██████      * Scan this QR   *██████    ██  ██  ██  ████████\n████  ████  ██  ██████      ██* code to join   *██  ████    ██  ████████  ████\n██████      ████████  ██      * in the Three   *██  ████          ████  ██  ██\n████              ████  ████  * Body ETO.      *  ████        ██  ████  ██  ██\n██████  ██    ████████        *  --ETO manager *██  ██                ██    ██\n████    ██  ██  ██    ██████  *    Ye Wenjie   *████  ████  ██  ████  ██  ████\n██  ████  ██████    ████  ██  *ETO(C),1988~2018*      ██  ██  ██  ██    ██████\n██  ██████  ██  ████    ██  ██******************          ██████    ██████  ██\n██  ██  ██    ████    ██        ██  ██        ████████      ████  ██  ██    ██\n████████████    ██    ██████  ██████████  ██  ████  ██████████    ██  ██  ████\n██████████    ██  ████  ██        ██    ██████████  ██    ██      ██  ██    ██\n██    ██  ████    ██  ████  ████      ██████    ██    ██      ██  ██  ████  ██\n██████  ██  ██████  ██            ██████████  ██    ██    ████  ████  ██    ██\n██      ██████  ████  ████  ████      ████    ████  ████            ██████████\n██████████████████      ██  ██  ████  ██    ██  ██    ████  ██████    ██    ██\n██              ██        ████████████  ████  ██  ██  ██    ██  ██      ██  ██\n██  ██████████  ██    ████  ██████  ██  ██████████████      ██████    ██  ████\n██  ██      ██  ████████    ██  ██      ████  ████  ██              ████  ████\n██  ██      ██  ████  ████  ████  ██████  ██████████████  ██████████    ██  ██\n██  ██      ██  ██    ██████  ██  ██  ██████████  ██  ██      ████    ██    ██\n██  ██████████  ██████  ████            ██    ████████  ██  ████    ██████████\n██              ██████    ████  ████████  ██  ████    ██    ██  ████  ████  ██\n██████████████████████████████████████████████████████████████████████████████\n    扫    描    二    维    码    加    入    三    体    E    T    O\n*/\n/*****************\n *   I<3   C++   *\n *  IWANT ANYAC  *\n * ILOVEPROGRAM! *\n *IT'SINTERESTING*\n * ILOVEPROGRAM! *\n *  INCONTESTS   *\n *   GETSCORE    *\n *    ACCODE     *\n *     LETS      *\n *      GO       *\n *Written by:    *\n *    charlieyan *\n *****************/\n#include <assert.h>\n#include <ctype.h>\n#include <errno.h>\n#include <float.h>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <locale>\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <wchar.h>\n#include <wctype.h>\n#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <cerrno>\n#include <clocale>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <limits>\n#include <map>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <istream>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <utility>\n#include <vector>\n#include <cwchar>\n#include <cwctype>\n#include <numeric>\n#include <list>\n#define LL long long\n#define pb push_back\n#define pob pop_back\n#define mp make_pair\n#define FILL(a,v) memset((void*)a,v,sizeof(a))\n#define FILL0(a) FILL(a,0)\n#define FILL1(a) FILL(a,-1)\n#define FILLBIG(a) FILL(a,0x3f)\n#define ALL(a) (a).begin(),(a).end()\n#define Inf ((int)0x3f3f3f3f)\n#define INF ((long long)0x3f3f3f3f3f3f3f3f)\n#define Mod 1000000007\n#define foreach(it,x) for(__typeof(x.begin()) it=x.begin();it!=x.end();it++)\n#define FOR(i,x) for(int i=0;i<x;i++)\n#define RFOR(i,x) for(int i=x-1;i>=0;i--)\n#define FFOR(i,a,b) for(int i=a;i<b;i++)\n#define FRFOR(i,a,b) for(int i=a-1;i>=b;i--)\n#define SZ(a) ((int)(a).size())\n#define FI first\n#define SE second\n#define OVER(...) return printf(__VA_ARGS__),0\n#define fastio ios::sync_with_stdio(0)\n#define filei(f) freopen(f,\"r\",stdin)\n#define fileo(f) freopen(f,\"w\",stdout)\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define MASK(a) (1<<(a))\n#define MASKX(x,a) ((x)<<(a))\n#define BIT(a,b) (((a)>>(b))&1)\n#define cddx(a) priority_queue<a >\n#define cxdd(a) priority_queue<a,vector<a >,greater<a > >\n#define deval(a) {cerr<<#a<<\" = \"<<a<<endl;}\n#define dearr(be,en) {cerr<<#be;cerr<<\" = {\";for(auto i=be;i!=en;i++)cerr<<' '<<*i;cerr<<\" }\\n\";}\n#define reg register\n#define prtime eprintf(\"\\n\\nTime used: %dms\\n\",clock());\n#define PI 3.1415926535897932384626\n#define TODEG(a) (a*180/PI)\n#define y0 ykangjimutigeidiqiuyipianjingtu\n#define y1 yxiaomiexuduhuanrenleiwannianankang\n#define endl '\\n'\n//抗击母体，给地球一片净土\n//消灭徐毒，还人类万年安康\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef unsigned long long UINT;\ntypedef unsigned int uint;\ntypedef long long INT;\ntypedef long double ldouble;\ntypedef pair<INT,INT> PII;\ntypedef stringstream sst;\ntypedef istringstream iss;\ntypedef vector<int> vint;\ntypedef vector<INT> VINT;\ntypedef vector<pii> vpii;\ntypedef vector<PII> VPII;\ntypedef priority_queue<int> pqi;\ntypedef priority_queue<INT> PQI;\ntypedef priority_queue<pii> pqp;\ntypedef priority_queue<PII> PQP;\ntypedef priority_queue<int,vint,greater<int> > xqi;\ntypedef priority_queue<INT,VINT,greater<INT> > XQI;\ntypedef priority_queue<pii,vpii,greater<pii> > xqp;\ntypedef priority_queue<PII,VPII,greater<PII> > XQP;\nstruct fastIO\n{\n\tinline fastIO operator>>(int& num)\n\t{\n\t\tnum=0;\n\t\tchar c=getchar();\n\t\twhile(c!='-'&&(c<'0'||c>'9'))c=getchar();\n\t\tbool foo=0;\n\t\tif(c=='-')\n\t\t{\n\t\t\tfoo=1;\n\t\t\tc=getchar();\n\t\t}\n\t\twhile(c>='0'&&c<='9')\n\t\t{\n\t\t\tnum=(num<<3)+(num<<1)+c-'0';\n\t\t\tc=getchar();\n\t\t}\n\t\tif(foo)num=-num;\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(INT& num)\n\t{\n\t\tnum=0;\n\t\tchar c=getchar();\n\t\twhile(c!='-'&&(c<'0'||c>'9'))c=getchar();\n\t\tbool foo=0;\n\t\tif(c=='-')\n\t\t{\n\t\t\tfoo=1;\n\t\t\tc=getchar();\n\t\t}\n\t\twhile(c>='0'&&c<='9')\n\t\t{\n\t\t\tnum=(num<<3)+(num<<1)+c-'0';\n\t\t\tc=getchar();\n\t\t}\n\t\tif(foo)num=-num;\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(float& num)\n\t{\n\t\tscanf(\"%f\",&num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(double& num)\n\t{\n\t\tscanf(\"%lf\",&num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(long double& num)\n\t{\n\t\tscanf(\"%Lf\",&num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(char& num)\n\t{\n\t\tnum=getchar();\n\t\twhile(num==' '||num=='\\n')num=getchar();\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(char* num)\n\t{\n\t\tint cnt=0;\n\t\tchar c=getchar();\n\t\twhile(c==' '||c=='\\n')c=getchar();\n\t\twhile(c!=' '&&c!='\\n')\n\t\t{\n\t\t\tnum[cnt++]=c;\n\t\t\tc=getchar();\n\t\t}\n\t\tnum[cnt]=0;\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(string& num)\n\t{\n\t\tcin>>num;\n\t\treturn *this;\n\t}\n\tinline void printInt(const int& num)\n\t{\n\t\tif(num<10)\n\t\t{\n\t\t\tputchar(num+'0');\n\t\t\treturn;\n\t\t}\n\t\tprintInt(num/10);\n\t\tputchar((num%10)+'0');\n\t}\n\tinline void printINT(const INT& num)\n\t{\n\t\tif(num<10)\n\t\t{\n\t\t\tputchar(num+'0');\n\t\t\treturn;\n\t\t}\n\t\tprintINT(num/10);\n\t\tputchar((num%10)+'0');\n\t}\n\tinline fastIO operator<<(const int& num)\n\t{\n\t\tif(num<0)putchar('-'),printInt(-num);\n\t\telse printInt(num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const INT& num)\n\t{\n\t\tif(num<0)putchar('-'),printINT(-num);\n\t\telse printINT(num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const float& num)\n\t{\n\t\tprintf(\"%.10f\",num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const double& num)\n\t{\n\t\tprintf(\"%.16lf\",num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const long double& num)\n\t{\n\t\tprintf(\"%.20Lf\",num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const char& num)\n\t{\n\t\tputchar(num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const char* num)\n\t{\n\t\tfor(int i=0;num[i];i++)\n\t\t\tputchar(num[i]);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const string& num)\n\t{\n\t\tcout<<num;\n\t\treturn *this;\n\t}\n}fio;\n//Coded by Charlieyan\n//版权所有，翻印必究\n\nvector<int> nei[2005];\nint num[2005];\nbool SortComp13(int a,int b){\n\treturn num[a]<num[b];\n}\n\nbool lgl[2005];\nvector<int> ltks[2005];\nint ans[2005];\n\nvoid dfs(int now,int ltk){\n\tif(lgl[now]){\n\t\treturn;\n\t}\n\tlgl[now]=1;\n\tltks[ltk].pb(now);\n\tfor(int i=0;i<SZ(nei[now]);i++){\n\t\tdfs(nei[now][i],ltk);\n\t}\n}\n\nint n;\n\nint gcd(int a,int b){\n\treturn !b?a:gcd(b,a%b);\n}\n\nint main(){\n\tfio>>n;\n\tfor(int i=0;i<n;i++){\n\t\tfio>>num[i];\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=i+1;j<n;j++){\n\t\t\tif(gcd(num[i],num[j])!=1){\n\t\t\t\tnei[i].pb(j);\n\t\t\t\tnei[j].pb(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tsort(ALL(nei[i]),SortComp13);\n\t}\n\tint cntltk=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(!lgl[i]){\n\t\t\tdfs(i,cntltk++);\n\t\t}\n\t}\n\tpriority_queue<pair<int,pii> > pq;\n\tfor(int i=0;i<cntltk;i++){\n\t\tpq.push(mp(num[ltks[i][0]],mp(i,0)));\n\t}\n\tint N=0;\n\twhile(SZ(pq)){\n\t\tpair<int,pii> fff=pq.top();\n\t\tpq.pop();\n\t\tint Num=fff.first,x=fff.second.first,y=fff.second.second;\n\t\tans[N++]=Num;\n\t\ty++;\n\t\tif(y!=SZ(ltks[x])){\n\t\t\tpq.push(mp(num[ltks[x][y]],mp(x,y)));\n\t\t}\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tprintf(\"%d%c\",ans[i],i==N-1?'\\n':' ');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define LL long long\n#define LD long double\n#define SC(t,x) static_cast<t>(x)\n#define AR(t) vector < t >\n#define PII pair < int, int >\n#define PLL pair < LL, LL >\n#define PIL pair < int, LL >\n#define PLI pair < LL, int >\n#define MP make_pair\n#define PB push_back\n#define PF push_front\n#define POB pop_back\n#define POF pop_front\n#define PRF first\n#define PRS second\n#define INIT(ar,val) memset ( ar, val, sizeof ( ar ) )\n#define lp(loop,start,end) for ( int loop = start; loop < end; ++loop )\n#define lpd(loop,start,end) for ( int loop = start; loop > end; --loop )\n#define lpi(loop,start,end) for ( int loop = start; loop <= end; ++loop )\n#define lpdi(loop,start,end) for ( int loop = start; loop >= end; --loop )\n#define qmax(a,b) (((a)>(b))?(a):(b))\n#define qmin(a,b) (((a)<(b))?(a):(b))\n#define qabs(a) (((a)>=0)?(a):(-(a)))\n\nconst int INF = 0x3fffffff;\nconst int SINF = 0x7fffffff;\nconst long long LINF = 0x3fffffffffffffff;\nconst long long SLINF = 0x7fffffffffffffff;\nconst int MAXN = 2007;\n\nint n;\nint ke, la[MAXN];\nint a[MAXN];\nbool g[MAXN][MAXN];\nAR(int) ar[MAXN];\nint fa[MAXN];\nint q[MAXN], ql, qr, ord[MAXN];\nbool vis[MAXN];\n\nvoid init ();\nvoid input ();\nvoid work ();\n\nvoid bfs ( int beg );\nvoid dfs ( int now );\n\nint getfa ( int now )\n{\n\treturn ( fa[now] ? ( fa[now] = getfa ( fa[now] ) ) : now );\n}\n\nint gcd ( int x, int y )\n{\n\treturn y ? gcd ( y, x%y ) : x;\n}\n\n\n\nint main()\n{\n\tinit();\n\tinput();\n\twork();\n}\n\n\n\nvoid init ()\n{\n\t// Init Everything Here\n\t\n\tios::sync_with_stdio ( false );\n}\n\nvoid input ()\n{\n\t// input method\n\t\n\tscanf ( \"%d\", &n );\n\tlpi ( i, 1, n ) scanf ( \"%d\", &a[i] );\n}\n\nvoid work ()\n{\n\t// main work\n\t\n\tsort ( a+1, a+1+n );\n\t\n\tlpi ( i, 1, n ) lpi ( j, 1, n ) if ( i ^ j ) g[i][j] = gcd ( a[i], a[j] ) ^ 1;\n\t\n//\tlpi ( i, 1, n ) { lpi ( j, 1, n ) cerr << g[i][j] << \" \"; cerr << endl; }\n\t\n\tql = qr = 1;\n\tlpi ( i, 1, n ) if ( !vis[i] ) bfs ( i );\n\tlpi ( i, 1, n ) ord[q[i]] = i;\n\t\n\tint fj;\n\tlpd ( _i, n, 0 ){\n\t\tint i = q[_i];\n\t\tlpi ( j, 1, n ){\n\t\t\tif ( ord[j] > _i && g[i][j] ){\n\t\t\t\tfj = getfa ( j );\n\t\t\t\tif ( i ^ fj ){\n\t\t\t\t\tar[i].PB ( j );\n\t\t\t\t\tfa[fj] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tlpd ( i, n, 0 ) if ( !fa[i] ) dfs ( i );\n\tputchar ( '\\n' );\n}\n\n\n\nvoid bfs ( int beg )\n{\n\tq[qr++] = beg;\n\tvis[beg] = true;\n\tint now;\n\twhile ( ql < qr ){\n\t\tnow = q[ql++];\n\t\tlpi ( v, 1, n ){\n\t\t\tif ( g[now][v] && !vis[v] ){\n\t\t\t\tvis[v] = true;\n\t\t\t\tq[qr++] = v;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n\nvoid dfs ( int now )\n{\n\tprintf ( \"%d \", a[now] );\n//\tsort ( ar[now].begin (), ar[now].end () );\n\treverse ( ar[now].begin (), ar[now].end () );\n\tfor ( auto x : ar[now] ) dfs ( x );\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n,a[2005],V;\nvector<int>edge[2005];\nbool used[2005][2005];\nbool in[2005];\nvector<int>nxt;\nP q;\nvoid dfs(int v){\n\tif(used[V][v]) return; used[V][v] = 1;\n\tnxt.pb(v); //q = min(q,mp(a[v],v));\n\trep(i,edge[v].size()){\n\t\tif(used[V][edge[v][i]] || !in[edge[v][i]]) continue;\n\t\tdfs(edge[v][i]);\n\t}\n}\nvector<int>make(vector<int>L,int cut){\n//rep(i,L.size()) cout<<L[i]<<\" \"; cout<<cut<<endl;\n\tvector<int>ret;\n\tif(L.size() == 1){\n\t\tret.pb(cut); return ret;\n\t}\n\tmemset(in,0,sizeof(in));\n\trep(i,L.size()){\n\t\tif(L[i] != cut) in[L[i]] = 1;\n\t}\n\trep(i,L.size()){\n\t\tif(L[i] == cut) continue;\n\t\tif(!used[cut][L[i]]){\n\t\t\tnxt.clear(); q = mp(INF,INF);\n\t\t\tV = cut; dfs(L[i]);\n\t\t\trep(j,nxt.size()){\n\t\t\t//\tassert(nxt[j] != cut);\n\t\t\t\tif(__gcd(a[nxt[j]],a[cut]) > 1){\n\t\t\t\t\tq = min(q,mp(a[nxt[j]],nxt[j]));\n\t\t\t\t//\tcout<<a[nxt[j]] << \" \"<< a[cut] << \" \"<< nxt[j] << \" \" << cut << endl;\n\t\t\t\t}//cout<<nxt[j]<<\" \";\n\t\t\t}//cout<<q.sc<<endl;\n\t\t\tvector<int>hoge = make(nxt,q.sc);\n\t\t//\tfor(int x=0;x<hoge.size();x++) cout<<hoge[x]<<\" \"; cout<<endl;\n\t\t\tvector<int>ret2;\n\t\t\tint c = ret.size(),b = hoge.size();\n\t\t\tint i = 0,j = 0;\n\t\t\twhile(i!=c || j!=b){\n\t\t\t\tif(i==c) ret2.pb(hoge[j++]);\n\t\t\t\telse if(j==b) ret2.pb(ret[i++]);\n\t\t\t\telse{\n\t\t\t\t\tif(a[ret[i]] > a[hoge[j]]) ret2.pb(ret[i++]);\n\t\t\t\t\telse ret2.pb(hoge[j++]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tret = ret2;\n\t\t}\n\t}\n\treverse(ret.begin(),ret.end());\n\tret.pb(cut);\n\treverse(ret.begin(),ret.end());\n\treturn ret;\n}\nbool U[2005];\nvector<int>vi;\nP p;\nvoid DFS(int x){\n\tif(U[x]) return; U[x] = 1;\n\tvi.pb(x); p = min(p,mp(a[x],x));\n\trep(i,edge[x].size()){\n\t\tDFS(edge[x][i]);\n\t}\n}\nvector<int>res;\nint main(){\n\tcin>>n;\n\trepn(i,n){\n\t\tcin>>a[i];\n\t}\n\trepn(i,n) repn(j,n){\n\t\tif(i != j && __gcd(a[i],a[j]) > 1){\n\t\t\tedge[i].pb(j);\n\t\t}\n\t}\n\trepn(i,n){\n\t\tif(U[i]) continue; p = mp(INF,INF); vi.clear();\n\t\tDFS(i);\n\t\tvector<int>vec = make(vi,p.sc);\n\t\tvector<int>res2;\n\t\tint c = 0,b = 0;\n\t\twhile(c != res.size() || b != vec.size()){\n\t\t\tif(c == res.size()) res2.pb(vec[b++]);\n\t\t\telse if(b == vec.size()) res2.pb(res[c++]);\n\t\t\telse{\n\t\t\t\tif(a[res[c]] > a[vec[b]]) res2.pb(res[c++]);\n\t\t\t\telse res2.pb(vec[b++]);\n\t\t\t}\n\t\t}\n\t\tres = res2;\n\t}\n\trep(i,n) cout<<a[res[i]]<<\" \";\n\tcout<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define per(i,b,a) for(int i=b;i>=a;i--)\n#define For(i,a,b) for(int i=a;i<=b;i++)\n#define Forenska(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\n#define all(x) x.begin(),x.end()\n#define sqr(x) ((x)*(x))\n#define lowbit(x) ((x)&(-x))\n#define GREATER(x) x,vector<x>,greater<x>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> pii;\ntypedef pair<LL,LL> pLL;\ntypedef vector<int> vec;\ntypedef vector<LL> vecL;\ntypedef vector<pii> vecP;\ntypedef vector<pLL> vecPL;\ntypedef vector<string> vecS;\ntypedef vector<vec> mat;\ntypedef complex<double> point;\nconst long double PI=3.1415926535897932384626433832795028841971693993751058209749445923078164062862089;\nconst LL INFLL=0x3f3f3f3f3f3f3f3f;\nconst int INF=0x3f3f3f3f;\nconst long double EPS=1e-10;\nint read()\n{\n\tint x=0;\n\tchar ch=' ';\n\tbool flag=false;\n\twhile(!isdigit(ch))\n\t{\n\t\tif(ch=='-')flag=true;\n\t\tch=getchar();\n\t}\n\twhile(isdigit(ch))\n\t{\n\t\tx=(x<<3)+(x<<1)+ch-'0';\n\t\tch=getchar();\n\t}\n\treturn flag?-x:x;\n}\nconst int MAX_N=2005;\nint n;\nint A[MAX_N];\nbool vis[MAX_N];\nvec g[MAX_N];\nvec g2[MAX_N];\nint in[MAX_N];\nvoid dfs(int v)\n{\n\tif(vis[v])return;\n\tvis[v]=true;\n\trep(i,0,g[v].size())\n\t{\n\t\tint to=g[v][i];\n\t\tif(!vis[to])\n\t\t{\n\t\t\tg2[v].pb(to);\n\t\t\tdfs(to);\n\t\t}\n\t}\n}\nvoid topo()\n{\n\tset <int> s;\n\trep(i,0,n)if(!vis[i])\n\t{\n\t\tdfs(i);\n\t\ts.insert(-i);\n\t}\n\twhile(!s.empty())\n\t{\n\t\tint t=-*s.begin();\n\t\ts.erase(s.begin());\n\t\trep(i,0,g2[t].size())\n\t\t{\n\t\t\tint to=g2[t][i];\n\t\t\ts.insert(-to);\n\t\t}\n\t\tcout<<A[t]<<\" \";\n\t}\n}\nint main()\n{\n\tcin>>n;\n\trep(i,0,n)cin>>A[i];\n\tsort(A,A+n);\n\trep(i,0,n)rep(j,0,n)if(__gcd(A[i],A[j])>1)\n\t{\n\t\tg[i].pb(j);\n\t}\n\ttopo();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<cmath>\n#include<map>\n#include<cstdlib>\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<string>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<set>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<ctime>\n#include<queue>\n#include<deque>\n#include<complex>\nusing namespace std;\n#define pb push_back\n#define pf push_front\ntypedef long long lint;\ntypedef complex<double> P;\n#define mp make_pair\n#define fi first\n#define se second\ntypedef pair<int,int> pint;\n#define All(s) s.begin(),s.end()\n#define rAll(s) s.rbegin(),s.rend()\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) REP(i,0,n)\nvector<int> gr[2525],ed[2525];\nbool sumi[2525];\npriority_queue<int> p;\nint a[2525],num[2525];\nint gcd( int m, int n )\n{\n\tint a=max(m,n),b=min(m,n);\n\tif(m==0) return n;if(n==0) return m;\n\tif(a%b==0) return b;\n\treturn gcd(b,a-b*(a/b));\n}\nvoid cal(int v){\n\t//if(sumi[v]) return;\n\tsumi[v]=true;\n\trep(i,gr[v].size()){\n\t\tint w=gr[v][i];\n\t\tif(sumi[w]) continue;\n\t\ted[v].pb(w);\n\t\tnum[w]++;\n\t\tcal(w);\n\t}\n}\nint main()\n{\n\tint n;\n\tcin>>n;\n\trep(i,n) cin>>a[i];\n\tsort(a,a+n);\n\trep(i,n) rep(j,n){\n\t\tif(i!=j && gcd(a[i],a[j])>1) gr[i].pb(j),gr[j].pb(i);\n\t}\n\tmemset(sumi,false,sizeof(sumi));\n\tmemset(num,0,sizeof(num));\n\trep(i,n){\n\t\tif(!sumi[i]){\n\t\t\tcal(i);p.push(i);\n\t\t}\n\t}\n\tvector<int> out;\n\trep(i,n){\n\t\tint q=p.top();p.pop();\n\t\tout.pb(q);\n\t\trep(j,ed[q].size()){\n\t\t\tint w=ed[q][j];\n\t\t\tnum[w]--;\n\t\t\tif(num[w]<1) p.push(w);\n\t\t}\n\t}\n\trep(i,n){\n\t\tcout<<a[out[i]];\n\t\tif(i<n-1) cout<<' ';else cout<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\ncat <<EOF >mistaken-paste\n*/\n\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <time.h>\n\n#define BIG 2000000007\n#define VERYBIG 2000000000000007LL\n\n#define MOD 1000000007\n#define FOD  998244353\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\n#define N_MAX 1000000\n#define M_MAX 200000\n\n#ifdef __cplusplus\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <array>\n\nusing std::queue;\nusing std::priority_queue;\nusing std::stack;\nusing std::tuple;\nusing std::set;\nusing std::map;\nusing std::vector;\nusing std::greater;\nusing std::pair;\nusing std::string;\n\n#endif\n\ntypedef struct {\n\tint32_t a;\n\tint32_t b;\n} hw;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n} hwll;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n\tsll c;\n} hwllc;\n\ntypedef struct {\n\thwll a;\n\thwll b;\n} linell;\n\null n, m;\null h, w;\null k;\null q;\nsll va, vb, vc, vd, ve, vf;\null ua, ub, uc, ud, ue, uf;\nlong double vra, vrb, vrc;\ndouble vda, vdb, vdc;\nchar ch, dh;\n\null umin (ull x, ull y) {\n\treturn (x < y) ? x : y;\n}\n\null umax (ull x, ull y) {\n\treturn (x > y) ? x : y;\n}\n\nsll smin (sll x, sll y) {\n\treturn (x < y) ? x : y;\n}\n\nsll smax (sll x, sll y) {\n\treturn (x > y) ? x : y;\n}\n\null gcd (ull x, ull y) {\n\tif (x < y) {\n\t\treturn gcd(y, x);\n\t} else if (y == 0) {\n\t\treturn x;\n\t} else {\n\t\treturn gcd(y, x % y);\n\t}\n}\n\null bitpow (ull a, ull x, ull modulo) {\n\tull result = 1;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tresult *= a;\n\t\t\tresult %= modulo;\n\t\t}\n\t\tx /= 2;\n\t\ta = (a * a) % modulo;\n\t}\n\treturn result;\n}\n\null divide (ull a, ull b, ull modulo) {\n\treturn (a * bitpow(b, modulo - 2, modulo)) % modulo;\n}\n\null udiff (ull a, ull b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nsll sdiff (sll a, sll b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nint bitcount (ull n) {\n\tint result = 0;\n\twhile (n) {\n\t\tif (n & 1) result++;\n\t\tn /= 2;\n\t}\n\treturn result;\n}\n\n// double distance (sll x1, sll y1, sll x2, sll y2) {\n// \tdouble xdist2, ydist2, origindist, dist;\n\n// \txdist2 = (x1 - x2) * (x1 - x2);\n// \tydist2 = (y1 - y2) * (y1 - y2);\n// \treturn sqrt(xdist2 + ydist2);\n// }\n\nint32_t pullcomp (const void *left, const void *right) {\n\tull l = *(ull*)left;\n\tull r = *(ull*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t psllcomp (const void *left, const void *right) {\n\tsll l = *(sll*)left;\n\tsll r = *(sll*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t pcharcomp (const void *left, const void *right) {\n\tchar l = *(char*)left;\n\tchar r = *(char*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t pdoublecomp (const void *left, const void *right) {\n\tdouble l = *(double*)left;\n\tdouble r = *(double*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t pstrcomp (const void *left, const void *right) {\n\tchar* l = *(char**)left;\n\tchar* r = *(char**)right;\n\n\treturn strcmp(l, r);\n}\n\nint32_t phwllABcomp (const void *left, const void *right) {\n\thwll l = *(hwll*)left;\n\thwll r = *(hwll*)right;\n\tif (l.a < r.a) {\n\t\treturn -1;\n\t}\n\tif (l.a > r.a) {\n\t\treturn +1;\n\t}\n\tif (l.b < r.b) {\n\t\treturn -1;\n\t}\n\tif (l.b > r.b) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t phwllREVcomp (const void *left, const void *right) {\n\thwll l = *(hwll*)left;\n\thwll r = *(hwll*)right;\n\tif (l.b < r.b) {\n\t\treturn -1;\n\t}\n\tif (l.b > r.b) {\n\t\treturn +1;\n\t}\n\tif (l.a < r.a) {\n\t\treturn -1;\n\t}\n\tif (l.a > r.a) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t ptriplecomp (const void *left, const void *right) {\n\thwllc l = *(hwllc*)left;\n\thwllc r = *(hwllc*)right;\n\n\tif (l.a < r.a) {\n\t\treturn -1;\n\t}\n\tif (l.a > r.a) {\n\t\treturn +1;\n\t}\n\tif (l.b < r.b) {\n\t\treturn -1;\n\t}\n\tif (l.b > r.b) {\n\t\treturn +1;\n\t}\n\tif (l.c < r.c) {\n\t\treturn -1;\n\t}\n\tif (l.c > r.c) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nbool isinrange (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right);\n}\n\nbool isinrange_soft (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right) || (left >= x && x >= right);\n}\n\nsll a[N_MAX];\n// sll a[3001][3001];\nsll b[N_MAX];\n// sll b[3001][3001];\nsll c[N_MAX];\n// sll d[N_MAX];\n// sll e[N_MAX];\nchar s[N_MAX + 1];\n// char s[3010][3010];\nchar t[N_MAX + 1];\n// char t[3010][3010];\n// hwll xy[N_MAX];\n// sll table[1000][1000];\n\nset<ull> g[2002];\nbool iscoprime[2002][2002];\n\null iswatched[2002];\null labels[2002];\null id = 0;\nvoid toggle (ull v, ull x) {\n\tif (iswatched[v] == x) return;\n\n\tiswatched[v] = x;\n\tlabels[v] = id;\n\tfor (ull u : g[v]) {\n\t\ttoggle(u, x);\n\t}\n}\n\ntypedef pair<ull, ull> P;\nvector<ull> merge(vector<vector<ull>> x) {\n\tvector<ull> v;\n\n\tull curr[x.size()];\n\tpriority_queue<P, vector<P> > que;\n\tfor (ull i = 0; i < x.size(); i++) {\n\t\tcurr[i] = 0;\n\t\tque.push(P(x[i][0], i));\n\t}\n\twhile (!que.empty()) {\n\t\tP p = que.top();\n\t\tque.pop();\n\n\t\tv.push_back(p.first);\n\t\tull i = p.second;\n\t\tif (++curr[i] < x[i].size()) {\n\t\t\tque.push(P(x[i][curr[i]], i));\n\t\t}\n\t}\n\n\treturn v;\n}\n\nvector<ull> func (ull v) { // This can be O(N)\n\tvector<ull> r;\n\t\n\tpriority_queue<ull, vector<ull>, greater<ull> > que;\n\ttoggle(v, 0); // O(N)\n\tfor (ull u : g[v]) {\n\t\tg[u].erase(v);\n\t\tque.push(u);\n\t}\n\n\tvector<vector<ull>> vs;\n\twhile (!que.empty()) {\n\t\tull u = que.top();\n\t\tque.pop();\n\t\tif (iswatched[u]) continue;\n\n\t\ttoggle(u, 1);\n\t\tvs.push_back(func(u));\n\t}\n\tiswatched[v] = 1;\n\n\tr = merge(vs);\n\tr.insert(r.begin(), v);\n\n\treturn r;\n}\n\null solve () {\n\tsll i, j, ki, li;\n\tull result = 0;\n\t// sll result = 0;\n\tdouble dresult = 0;\n\t// ull maybe = 0;\n\tsll maybe = 0;\n\t// ull sum = 0;\n\tsll sum = 0;\n\tsll item;\n\tull *dpcell;\n\n\tqsort(a, n, sizeof(ull), pullcomp);\n\n\tfor (i = 0; i < n; i++) {\n\t\tfor (j = i + 1; j < n; j++) {\n\t\t\tif (gcd(a[i], a[j]) > 1) {\n\t\t\t\tg[i].insert(j);\n\t\t\t\tg[j].insert(i);\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<vector<ull>> finals;\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (iswatched[i]) continue;\n\n\t\ttoggle(i, 1);\n\t\tfinals.push_back(func(i));\n\t\t// for (j = 0; j < finals[finals.size() - 1].size(); j++) printf(\"%llu \", finals[finals.size() - 1][j]);\n\t\t// \tputs(\"\");\n\t\t// fflush(stdout);\n\t}\n\tvector<ull> r = merge(finals);\n\tfor (i = 0; i < n; i++) {\n\t\tprintf(\"%llu%c\", a[r[i]], (i == n - 1 ? '\\n' : ' '));\n\t}\n\n\t// printf(\"%lld\\n\", result);\n\t// printf(\"%.15lf\\n\", dresult);\n\t// puts(s);\n\n\treturn 0;\n\n\tsuccess:\n\t// puts(\"YES\");\n\tputs(\"Yes\");\n\t// printf(\"%llu\\n\", result);\n\t// puts(\"0\");\n\t// puts(\"Yay!\");\n\treturn 0;\n\n\tfail:\n\t// puts(\"NO\");\n\tputs(\"No\");\n\t// puts(\"0\");\n\t// puts(\"-1\");\n\t// puts(\"-1 -1 -1\");\n\t// puts(\":(\");\n\treturn 1;\n}\n\nint32_t main (void) {\n\tint32_t i, j;\n\tint32_t x, y;\n\n\tscanf(\"%llu\", &n, &m);\n\t// scanf(\"%llu\", &k, &n, &m);\n\t// scanf(\"%llu%llu\", &h, &w);\n\t// scanf(\"%lld\", &va, &vb, &vc, &vd);\n\t// scanf(\"%llu%llu\", &ua, &ub, &uc, &ud);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%s\", s);\n\t// scanf(\"%s\", t);\n\tfor (i = 0; i < n; i++) {\n\t\t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t\tscanf(\"%lld\", &a[i]);\n\t\t// scanf(\"%lld\", &b[i]);\n\t\t// scanf(\"%lld\", &c[i]);\n\t\t// scanf(\"%lld\", &d[i]);\n\t\t// a[i]--;\n\t\t// b[i]--;\n\t\t// c[i]--;\n\t}\n\t// scanf(\"%llu\", &m, &k);\n\t// scanf(\"%llu\", &q);\n\t// for (i = 0; i < n; i++) {\n\t// \tscanf(\"%lld\", &b[i]);\n\t// }\n\n\t// for (i = 0; i < h; i++) {\n\t// \tfor (j = 0; j < w; j++) {\n\t// \t\tscanf(\"%llu\", &table[i][j]);\n\t// \t}\n\t// }\n\t// for (i = 0; i < h; i++) {\n\t// \tscanf(\"%s\", &s[i]);\n\t// }\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*----------------by syr----------------*/\n/*\n  -----  -----  -----\n  |   |  |---|    _/\n  |   |  | \\_    /\n  -----  |   \\  -----\n\n  |---\\  \\   /  |\\  /|\n  |   |   \\_/   | \\/ |\n  |   |   / \\   |    |\n  |---/  /   \\  |    |\n*/\n#include<algorithm>\n#include<bitset>\n#include<cctype>\n#include<cstring>\n#include<cstdlib>\n#include<deque>\n#include<fstream>\n#include<functional>\n#include<iomanip>\n#include<iostream>\n#include<iterator>\n#include<limits>\n#include<list>\n#include<map>\n#include<math.h>\n#include<queue>\n#include<set>\n#include<stack>\n#include<stdio.h>\n#include<sstream>\n#include<string>\n#include<time.h>\n#include<utility>\n#include<vector>\n\n#define PH push\n#define MP make_pair\n#define PB push_back\n#define fst first\n#define snd second\n#define FOR(i,x,y) for(int i=(x);i<(y);++i)\n#define REP(i,x,y) for(int i=(x);i<=(y);++i)\n#define x0 x234567891\n#define y0 y234567891\n#define x2 x123456789\n#define y2 y123456789\n\nusing namespace std;\n\ntypedef double db;\ntypedef long long ll;\ntypedef long double ldb;\ntypedef pair<int,int> pii;\n\nconst int INF=1e9+7;\nconst int maxn=2005;\n\nint n,cnt;\nint a[maxn],ord[maxn];\nint gcd[maxn][maxn];\nbool vis[maxn];\nvector<int> b;\nvector<int> g[maxn],lst[maxn];\n\nvoid dfs(int u){\n\tlst[cnt].PB(a[u]);\n\tvis[u]=1;\n\tFOR(i,0,g[u].size()){\n\t\tint v=g[u][i];\n\t\tif(vis[v]) continue;\n\t\tdfs(v);\n\t\treturn;\n\t}\n\treturn;\n}\n\ninline bool cmp(const int &A,const int &B){return (lst[A][0]>lst[B][0]);}\ninline bool cmp2(const int &A,const int &B){return (a[A]<a[B]);}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tFOR(i,0,n) scanf(\"%d\",a+i);\n\tsort(a,a+n);\n\tFOR(i,0,n){\n\t\tFOR(j,i+1,n){\n\t\t\tgcd[i][j]=gcd[j][i]=__gcd(a[i],a[j]);\n\t\t\tif(gcd[i][j]!=1) g[i].PB(j),g[j].PB(i);\n\t\t}\n\t}\n\tFOR(i,0,n) sort(g[i].begin(),g[i].end(),cmp2);\n\tFOR(i,0,n) if(!vis[i]) dfs(i),ord[cnt]=cnt,++cnt;\n\tsort(ord,ord+cnt,cmp);\n\tFOR(i,0,cnt){\n\t\tFOR(j,0,lst[ord[i]].size()) b.PB(lst[ord[i]][j]);\n\t}\n\tFOR(i,0,n) printf(\"%d \",b[i]);\n\tputs(\"\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int Nmax = 2005;\n\nbool used[Nmax];\nvector<int> ans, v[Nmax];\nint i, j, n, a[Nmax];\n\nvoid Merge(vector<int> &b, vector<int> c, bool ok)\n{\n    int q = 0, p = 0;\n    vector<int> a;\n\n    if(ok) a.push_back(b[0]), p = 1;\n\n    while(p < b.size() && q < c.size())\n        if(b[p] > c[q]) a.push_back(b[p++]);\n            else a.push_back(c[q++]);\n\n    while(p < b.size()) a.push_back(b[p++]);\n    while(q < c.size()) a.push_back(c[q++]);\n    b = a;\n}\n\nvector<int> dfs(int node)\n{\n    used[node] = 1;\n    vector<int> a;\n\n    a.push_back(node);\n    for(auto it : v[node])\n        if(!used[it])\n            Merge(a, dfs(it), 1);\n    return a;\n}\n\nint main()\n{\n //   freopen(\"input\", \"r\", stdin);\n    cin.sync_with_stdio(false);\n\n    cin >> n;\n    for(i=1; i<=n; ++i) cin >> a[i];\n\n    sort(a+1, a+n+1);\n\n    for(i=1; i<=n; ++i)\n        for(j=i+1; j<=n; ++j)\n            if(__gcd(a[i], a[j]) > 1)\n                v[i].push_back(j), v[j].push_back(i);\n\n    for(i=1; i<=n; ++i)\n        if(!used[i])\n            Merge(ans, dfs(i), 0);\n\n    for(i=0; i<n; ++i) cout << a[ans[i]] << ' ';\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define pb push_back\n#define SZ(x) ((int)x.size())\n#define L(i,u) for (register int i=head[u]; i; i=nxt[i])\n#define rep(i,a,b) for (register int i=(a); i<=(b); i++)\n#define per(i,a,b) for (register int i=(a); i>=(b); i--)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\ntemplate<class T> inline void read(T &x){\n\tx=0; char c=getchar(); int f=1;\n\twhile (!isdigit(c)) {if (c=='-') f=-1; c=getchar();}\n\twhile (isdigit(c)) {x=x*10+c-'0'; c=getchar();} x*=f;\n}\ntemplate<class T> inline void umin(T &x, T y){x=x<y?x:y;}\ntemplate<class T> inline void umax(T &x, T y){x=x>y?x:y;}\ninline ui R() {\n\tstatic ui seed=416;\n\treturn seed^=seed>>5,seed^=seed<<17,seed^=seed>>13;\n}\nconst int N = 2303;\nint n,a[N];bool e[N][N],vis[N];Vi ch[N],ans[N];\nint gcd(int a, int b){return !b?a:gcd(b,a%b);}\nvoid dfs(int u){\n\tvis[u]=1;\n\trep(i,1,n)if(e[u][i]&&!vis[i])dfs(i),ch[u].pb(i);\n}\nvoid dfs1(int u){\n\trep(i,0,SZ(ch[u])-1)dfs1(ch[u][i]);\n\tans[u].pb(u);int p[N]={0};\n\twhile(1){\n\t\tint mx=-1,pos=-1;\n\t\trep(i,0,SZ(ch[u])-1)if(p[i]<SZ(ans[ch[u][i]]))\n\t\t\tif(mx<ans[ch[u][i]][p[i]])mx=ans[ch[u][i]][p[i]],pos=i;\n\t\tif(mx<0)break;ans[u].pb(ans[ch[u][pos]][p[pos]++]);\n\t}\n}\nint main() {\n\tread(n);rep(i,1,n)read(a[i]);sort(a+1,a+n+1);\n\trep(i,1,n)rep(j,1,n)if(i!=j)e[i][j]=gcd(a[i],a[j])>1;\n\trep(i,1,n)if(!vis[i])dfs(i),ch[0].pb(i);\n\tdfs1(0);rep(i,1,SZ(ans[0])-1)printf(\"%d \",a[ans[0][i]]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define NMAX 2010\nusing namespace std;\n\nbool Vis[NMAX];\nvector <int> V[NMAX];\nint n, Done[NMAX][NMAX], Map[NMAX], num[NMAX];\n\nvoid DFS(int Root) {\n    Vis[Root] = 1;\n    for (int i = 1; i <= n; ++i) {\n\t    if (!Vis[i] && Done[Root][i]) {\n\t        ++Map[i];\n\t        V[Root].push_back(i);\n\t        DFS(i);\n\t    }\n    }\n}\n\nvoid Top() {\n    priority_queue <int> Q;\n    for (int i = 1; i <= n; ++i) {\n    \tif (!Map[i]) Q.push(i);\n    }\n    while (!Q.empty()) {\n        int now = Q.top();\n        Q.pop();\n        printf(\"%d \", num[now]);\n        for (int i = 0; i < V[now].size(); ++i) Q.push(V[now][i]);\n    }\n}\n\nsigned main(){\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; ++i) scanf(\"%d\", &num[i]);\n    sort(num + 1, num + n + 1);\n    for (int i = 1; i <= n; ++i) {\n    \tfor (int j = i + 1; j <= n; ++j) {\n    \t\tif (__gcd(num[i], num[j]) != 1) Done[i][j] = Done[j][i] = 1;\n    \t}\n    }\n    for (int i = 1; i <= n; ++i) if (!Vis[i]) DFS(i);\n    Top();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define dbug(x) cout<<#x<<\"=\"<<x<<endl\nusing namespace std;\ntemplate <typename T> void read(T &t) {\n\tt=0; char ch=getchar(); int f=1;\n\twhile ('0'>ch||ch>'9') { if (ch=='-') f=-1; ch=getchar(); }\n\tdo {(t*=10)+=ch-'0';ch=getchar();} while ('0'<=ch&&ch<='9'); t*=f;\n}\nconst int maxn=2010;\nint n,a[maxn],vis[maxn],tot,nxt[maxn];\npriority_queue<int> q1; // big\npriority_queue<int,vector<int>,greater<int> > q2; // small\nvector<int> g[maxn],s[maxn],ans;\nint gcd(int x,int y) {\n\tif (!x||!y) return x+y;\n\treturn gcd(y,x%y);\n}\nint main() {\n\t//freopen(\"1.txt\",\"r\",stdin);\n\tread(n); int u,v;\n\tfor (int i=1;i<=n;i++) read(a[i]);\n\tsort(a+1,a+n+1);\n\tfor (int i=1;i<=n;i++)\n\tfor (int j=i+1;j<=n;j++)\n\t\tif (gcd(a[i],a[j])>1) g[i].push_back(j),g[j].push_back(i);\n\tfor (int i=1;i<=n;i++)\n\t\tif (!vis[i]) {\n\t\t\ttot++; q2.push(i); vis[i]=1;\n\t\t\twhile (!q2.empty()) {\n\t\t\t\tu=q2.top(); q2.pop(); s[tot].push_back(u);\n\t\t\t\tfor (int j=0;j<g[u].size();j++) {\n\t\t\t\t\tv=g[u][j]; if (!vis[v]) q2.push(v),vis[v]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\tfor (int i=1;i<=tot;i++) {\n\t\tfor (int j=1;j<s[i].size();j++) nxt[s[i][j-1]]=s[i][j];\n\t\tq1.push(s[i][0]);\n\t}\n\twhile (!q1.empty()) {\n\t\tu=q1.top(); q1.pop(); ans.push_back(u);\n\t\tif (nxt[u]) q1.push(nxt[u]);\n\t}\n\tfor (int i=1;i<=n;i++) printf(\"%d \",a[ans[i-1]]); printf(\"\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\n\n\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fr(x) freopen(x,\"r\",stdin)\n#define fw(x) freopen(x,\"w\",stdout)\n#define iout(x) printf(\"%d\\n\",x)\n#define lout(x) printf(\"%lld\\n\",x)\n#define REP(x,l,u) for(int x = (l);x<=(u);x++)\n#define RREP(x,l,u) for(int x = (l);x>=(u);x--)\n#define mst(x,a) memset(x,a,sizeof(x))\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define MP make_pair\n#define se second\n#define fi first\n#define dbg(x) cout<<#x<<\" = \"<<(x)<<endl;\n#define sz(x) ((int)x.size())\n#define cl(x) x.clear()\n\ntypedef  long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ld;\nusing namespace std;\n\nconst int maxn = 100010;\nconst int mod = 1e9+7;\nconst int MAX = 1000000010;\nconst double eps = 1e-6;\nconst double PI = acos(-1);\n\ntemplate<typename T> inline void read(T &x){\nx=0;T f=1;char ch;do{ch=getchar();if(ch=='-')f=-1;}while(ch<'0'||ch>'9');do x=x*10+ch-'0',ch=getchar();while(ch<='9'&&ch>='0');x*=f;\n}\n\ntemplate<typename A,typename B> inline void read(A&x,B&y){read(x);read(y);}\ntemplate<typename A,typename B,typename C> inline void read(A&x,B&y,C&z){read(x);read(y);read(z);}\ntemplate<typename A,typename B,typename C,typename D> inline void read(A&x,B&y,C&z,D&w){read(x);read(y);read(z);read(w);}\ntemplate<typename A,typename B> inline A fexp(A x,B p){A ans=1;for(;p;p>>=1,x=1LL*x*x%mod)if(p&1)ans=1LL*ans*x%mod;return ans;}\ntemplate<typename A,typename B> inline A fexp(A x,B p,A mo){A ans=1;for(;p;p>>=1,x=1LL*x*x%mo)if(p&1)ans=1LL*ans*x%mo;return ans;}\n\nint n,m;\n\nint A[maxn];\n\nvector<int> G[maxn],G2[maxn];\n\nint vi[maxn];\n\npriority_queue<PII> Q;\n\nint deg[maxn];\n\nbool cmp(int x,int y){\n\treturn A[x]<A[y];\n}\n\nvoid addedge(int u,int v){\n\tdeg[v]++;\n\tG2[u].PB(v);\n}\n\nvoid dfs(int u){\n\tvi[u]=1;\n\tfor(auto v:G[u])if(!vi[v]){\n\t\taddedge(u,v);\n\t\tdfs(v);\n\t}\n}\n\nvoid Work(){\n\tREP(i,1,n)if(!vi[i])dfs(i);\n\tREP(i,1,n)if(!deg[i])Q.push(MP(A[i],i));\n\twhile(!Q.empty()){\n\t\tint u=Q.top().se;Q.pop();\n\t\tprintf(\"%d \",A[u]);\n\t\tfor(auto v:G2[u])if(!--deg[v])Q.push(MP(A[v],v));\n\t}\n}\n\nvoid Init(){\n\tread(n);\n\tREP(i,1,n)read(A[i]);\n\tsort(A+1,A+n+1);\n\tREP(i,1,n)REP(j,1,n)if(i!=j&&__gcd(A[i],A[j])!=1)G[i].PB(j);\n\tREP(i,1,n)sort(G[i].begin(),G[i].end(),cmp);\n}\n\nint main(){\n\tInit();\n\tWork();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <vector>\n#include <iostream>\n#include <string.h>\n#include <string>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\ntypedef double LD;\ntypedef long long LL;\ntypedef pair<int, int> PII;\n#define MP make_pair\n#define PB push_back\n#define FOR(i,a,b) for(int i = (a); i < (b); ++i)\n#define RFOR(i,b,a) for(int i = (b) - 1; i >= (a); --i)\n#define REP(i, t) FOR(i,0,t)\n#define ALL(a) a.begin(), a.end()\n#define SZ(a) (int)((a).size())\n\nconst LL MOD = 1000000007;\nconst int INF = 1e9;\nconst int MAXN = 2007;\nconst LD EPS = 1e-7;\n\nint n, A[MAXN], B[MAXN][MAXN], P[MAXN], r = 0;\nbool used[MAXN];\nqueue <int> Q;\n\nint gcd(int a, int b)\n{\n\tif (a == 0) return b;\n\treturn gcd(b % a, a);\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0);\n\t//freopen(\"In.txt\", \"r\", stdin);\n\tcin >> n;\n\tREP(i, n) cin >> A[i];\n\tsort(A, A + n);\n\tREP(i, n)\n\t{\n\t\tif (used[i]) continue;\n\t\tused[i] = true;\n\t\tQ.push(i);\n\t\tint sz = 0;\n\t\twhile (!Q.empty())\n\t\t{\n\t\t\tint v = Q.front();\n\t\t\tQ.pop();\n\t\t\tB[r][sz++] = A[v];\n\t\t\tREP(j, n)\n\t\t\t{\n\t\t\t\tif (!used[j] && gcd(A[v], A[j]) > 1)\n\t\t\t\t{\n\t\t\t\t\tused[j] = true;\n\t\t\t\t\tQ.push(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t++r;\n\t}\n\tREP(i, r) P[i] = 0;\n\tREP(i, n)\n\t{\n\t\tint mr = 0;\n\t\tREP(j, r)\n\t\t\tif (B[j][P[j]] > B[mr][P[mr]])\n\t\t\t\tmr = j;\n\t\tcout << B[mr][P[mr]] << ' ';\n\t\t++P[mr];\n\t}\n\t//cout << endl; system(\"pause\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\n#define ref(i,x,y)for(int i=x;i<=y;++i)\nconst int N=2001;\nint n,m,_m,a[N],A[N],b[N][10],t[N*10],fa[N*10];bool v[N*10],f[N];\nbool pri(int x,int y){return y?pri(y,x%y):(x==1);}\nbool cmp(int x,int y){return b[x/10][x%10]<b[y/10][y%10];}\nint ask(int x){return fa[x]==x?fa[x]:ask(fa[x]);}\nvoid unite(int x,int y){x=ask(x),y=ask(y);if(y!=x)fa[y]=x;}\nint main(){\n\tscanf(\"%d\",&n);\n\tref(i,1,n)scanf(\"%d\",&a[i]);\n\tsort(a+1,a+n+1);\n\tref(i,1,n){\n\t\tint S=a[i],s=(int)sqrt(a[i]);\n\t\tref(j,2,s)if(S%j==0){\n\t\t\twhile(S%j==0)S/=j;\n\t\t\tb[i][++b[i][0]]=j;\n\t\t}\n\t\tif(S>1)b[i][++b[i][0]]=S;\n\t\tref(j,1,b[i][0])t[++m]=i*10+j;\n\t\tA[i]=a[i];a[i]=i;\n\t}\n\tsort(t+1,t+m+1,cmp);_m=n;\n\tfor(int i=1,la=-1;i<=m;++i){\n\t\tint&s=b[t[i]/10][t[i]%10];\n\t\t_m+=(s!=la);la=s;s=_m;\n\t}m=_m;\n\tref(i,1,n){\n\t\tint tot=0,p=0,ap=0;\n\t\tref(j,1,m)fa[j]=j,v[j]=0;\n\t\tref(j,i,n)ref(I,1,b[a[j]][0])\n\t\t\tunite(j,b[a[j]][I]);\n\t\tref(j,i,n)if(ask(j)==j)tot++;\n\t\tref(j,i,n)if(!v[ask(j)]&&!f[a[j]]){\n\t\t\tv[ask(j)]=1,tot--;\n\t\t\tif(tot==0){p=j;break;}\n\t\t}\n\t\tap=a[p];\n\t\tfor(int j=p;j>i;--j)a[j]=a[j-1];\n\t\ta[i]=ap;\n\t\tref(j,i+1,n){\n\t\t\tint x=A[a[i]],y=A[a[j]];\n\t\t\tif(x<y){\n\t\t\t\tf[a[j]]=pri(x,y);\n\t\t\t}else{\n\t\t\t\tf[a[j]]=f[a[j]]&&pri(x,y);\n\t\t\t}\n\t\t}\n\t}\n\tref(i,1,n)printf(\"%d \",A[a[i]]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\npair<int,int> a[2222];\nint n;\nvector<int> v[2222],v2[2222];\npriority_queue<int> pq;\nbool use[2222];\ninline void dfs(int x){\n\tuse[x]=1;\n\tfor(int i=0;i<v[x].size();++i){\n\t\tif(use[v[x][i]]) continue;\n\t\tv2[x].push_back(v[x][i]);\n\t\tdfs(v[x][i]);\n\t}\n} \nint main(){\n\tint i,j;\n\tcin>>n;\n\tfor(i=1;i<=n;++i){\n\t\tcin>>a[i].first;\n\t\ta[i].second=i;\n\t}\n\tsort(a+1,a+n+1);\n\tfor(i=1;i<=n;++i) for(j=1;j<=n;++j) if(__gcd(a[i].first,a[j].first)!=1) v[i].push_back(j);\n\tfor(i=1;i<=n;++i) if(!use[i]) pq.push(i),dfs(i);\n\tmemset(use,0,sizeof(use));\n\twhile(!pq.empty()){\n\t\tint t(pq.top());\n\t\tpq.pop();\n\t\tuse[t]=0;\n\t\tfor(i=0;i<v2[t].size();++i) pq.push(v2[t][i]);\n\t\tcout<<a[t].first<<' ';\n\t}\n\tcout<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int maxn = 2030, oo = 123456789, maxm = 54010;\n\nint n, m, T, ans, mn, a[maxn], foo[maxn], lst[maxm], tag[maxn];\nbool vis[maxn], f[maxn], G[maxn][maxn], F[maxn];\nstd::vector<int> g[maxn], has[maxn], rhas[maxm], all;\nstd::vector<std::pair<int, int> > v;\n\nvoid GEN() {\n\tint mx = 0;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif(!foo[i]) {\n\t\t\tif(a[i] == 1) {\n\t\t\t\tF[i] = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tF[i] = 0;\n\t\t\tfor (int j: has[i]) {\n\t\t\t\tif(lst[j] >= mx) {\n\t\t\t\t\tF[i] = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n//\t\t\tprintf(\"(%d, %d) \", mx, F[i]);\n\t\t}\n\t\telse {\n\t\t\t(foo[i] > mx) && (mx = foo[i]);\n\t\t}\n\t}\n//\tputs(\"\");\n\t//std::cerr<<ToT<<std::endl;\n\treturn;\n}\n\nvoid dfs(int u) {\n\ttag[u] = T;\n\tif(a[u] < mn) {\n\t\tmn = a[u];\n\t}\n\tvis[u] = 1;\n\tfor (int v: g[u]) {\n\t\tif(!vis[v] && !f[v]) {\n\t\t\tdfs(v);\n\t\t}\n\t}\n\treturn;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tscanf(\"%d\", a + i);\n\t\tint t = a[i];\n\t\tfor (int x = 2; x * x <= t; ++x) {\n\t\t\tif(t % x == 0) {\n\t\t\t\tall.push_back(x);\n\t\t\t\twhile(t % x == 0) {\n\t\t\t\t\tt /= x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(t > 1) {\n\t\t\tall.push_back(t);\n\t\t}\n\t}\n\tstd::sort(a + 1, a + n + 1);\n\tstd::sort(all.begin(), all.end());\n\tall.resize(std::unique(all.begin(), all.end()) - all.begin());\n\tm = (int)(all.size());\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tif(a[i] % all[j] == 0) {\n\t\t\t\thas[i].push_back(j);\n\t\t\t\trhas[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int j = 0; j < m; ++j) {\n\t\tfor (int i = 0; i < (int)(rhas[j].size()); ++i) {\n\t\t\tfor (int k = 0; k < i; ++k) {\n\t\t\t\tint u = rhas[j][i], v = rhas[j][k];\n\t\t\t\tif(!G[u][v]) {\n\t\t\t\t\tg[u].push_back(v);\n\t\t\t\t\tg[v].push_back(u);\n\t\t\t\t\tG[u][v] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tGEN();\n\t\tmemset(vis + 1, 0, sizeof(vis[0]) * n);\n\t\tv.clear();\n\t\tbool fuck = 0;\n\t\tfor (int u = 1; u <= n; ++u) {\n\t\t\tif(F[u]) {\n\t\t\t\tfuck = 1;\n\t\t\t\tif(!vis[u] && !f[u]) {\n\t\t\t\t\t++T;\n\t\t\t\t\tmn = oo;\n\t\t\t\t\tdfs(u);\n\t\t\t\t\tv.push_back(std::make_pair(mn, T));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tassert(fuck);\n\t\tstd::sort(v.begin(), v.end());\n\t\tint sz = (int)(v.size());\n\t\tfor (int u = 1; u <= n; ++u) {\n\t\t\tif(F[u] && !f[u]) {\n\t\t\t\tint i = sz - 1;\n\t\t\t\tif(v[i].second == tag[u]) {\n\t\t\t\t\t--i;\n\t\t\t\t}\n\t\t\t\tif(i < 0 || v[i].first <= a[u]) {\n\t\t\t\t\tans = u;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tf[ans] = 1;\n\t\tfoo[ans] = i;\n\t\tprintf(\"%d \", a[ans]);\n\t\tfor (int j: has[ans]) {\n\t\t\tlst[j] = i;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair <int,int> pii;\n\nconst int RLEN=1<<18|1;\ninline char nc() {\n\tstatic char ibuf[RLEN],*ib,*ob;\n\t(ib==ob) && (ob=(ib=ibuf)+fread(ibuf,1,RLEN,stdin));\n\treturn (ib==ob) ? -1 : *ib++;\n}\ninline int rd() {\n\tchar ch=nc(); int i=0,f=1;\n\twhile(!isdigit(ch)) {if(ch=='-')f=-1; ch=nc();}\n\twhile(isdigit(ch)) {i=(i<<1)+(i<<3)+ch-'0'; ch=nc();}\n\treturn i*f;\n}\n\nconst int N=2e3+50;\nint n,tot,vis[N],a[N],b[N];\nvector <int> edge[N];\npriority_queue <int> q[N];\npriority_queue <pii> tq;\n\ninline void dfs(int x) {\n\tq[tot].push(-x); vis[x]=1;\n\tfor(int e=edge[x].size()-1;e>=0;e--) {\n\t\tint v=edge[x][e]; if(vis[v]) continue;\n\t\tdfs(v); \n\t}\n}\nint main() {\n\tn=rd();\n\tfor(int i=1;i<=n;i++) a[i]=rd();\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\tif(__gcd(a[i],a[j])!=1) edge[i].push_back(j), edge[j].push_back(i);\n\tfor(int i=1;i<=n;i++) if(!vis[i]) ++tot,dfs(i);\n\tfor(int i=1;i<=tot;i++) tq.push(pii(-q[i].top(),i));\n\tmemset(vis,0,sizeof(vis));\n\tfor(int i=1;i<=tot;i++) {\n\t\tint tp=q[i].top();\n\t\twhile(!q[i].empty()) q[i].pop();\n\t\tq[i].push(tp);\n\t\tvis[-tp]=1;\n\t}\n\tn=0;\n\twhile(!tq.empty()) {\n\t\tint u=tq.top().second; tq.pop();\n\t\tint p=-q[u].top(); q[u].pop();\n\t\tb[++n]=a[p];\n\t\tfor(int e=edge[p].size()-1;e>=0;e--) {\n\t\t\tint v=edge[p][e]; if(vis[v]) continue;\n\t\t\tq[u].push(-v); vis[v]=1;\n\t\t}\n\t\tif(!q[u].empty()) tq.push(pii(-q[u].top(),u));\n\t}\n\tfor(int i=2;i<=n;i++) {\n\t\tint p=i;\n\t\twhile(p>1 && b[p]>b[p-1] && __gcd(b[p],b[p-1])==1) swap(b[p-1],b[p]), --p;\n\t}\n\tfor(int i=1;i<=n;i++) cout<<b[i]<<' ';\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<map>\nconst int maxn=2010,S=10000;\nint n,a[maxn],b[maxn],vt;\nbool used[maxn],ban[maxn];\nstd::map<int,int>M;\nstruct edge{int to;edge*next;}E[maxn*20],*ne=E,*fir[maxn*10];\nint vis[maxn*10];\nvoid cmin(int&a,int b){b<a?a=b:1;}\nvoid cmax(int&a,int b){b>a?a=b:1;}\nint pid(int x){return M.count(x)?M[x]:M[x]=vt++;}\nvoid link(int u,int v){*ne=(edge){v,fir[u]};fir[u]=ne++;}\nint dfs(int i,int x){\n\tint mv=i<n&&!ban[i]?i:n;\n\tvis[i]=x;\n\tfor(edge*e=fir[i];e;e=e->next){\n\t\tif((e->to>=n||!used[e->to])&&vis[e->to]!=x)cmin(mv,dfs(e->to,x));\n\t}\n\treturn mv;\n}\nint pr[S+1],pc;\nbool com[S+1];\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++)scanf(\"%d\",a+i);\n\tstd::sort(a,a+n);\n\tvt=n;\n\tfor(int i=2;i<=S;i++){\n\t\tif(!com[i])pr[pc++]=i;\n\t\tfor(int j=0;j<pc&&i*pr[j]<=S;j++){\n\t\t\tcom[i*pr[j]]=1;\n\t\t\tif(i%pr[j]==0)break;\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tint x=a[i];\n\t\tfor(int j=0;j<pc&&pr[j]*pr[j]<=x;j++)if(x%pr[j]==0){\n\t\t\tint t=pid(pr[j]);\n\t\t\tlink(i,t);link(t,i);\n\t\t\twhile(x%pr[j]==0)x/=pr[j];\n\t\t}\n\t\tif(x>1){\n\t\t\tint t=pid(x);\n\t\t\tlink(i,t);link(t,i);\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tint mv=0;\n\t\tfor(int j=0;j<n;j++)if(!used[j]&&vis[j]!=i)cmax(mv,dfs(j,i));\n\t\tprintf(\"%d%c\",a[mv],\" \\n\"[i==n]);\n\t\tused[mv]=1;\n\t\tfor(edge*e=fir[mv];e;e=e->next)\n\t\t\tfor(edge*f=fir[e->to];f;f=f->next)\n\t\t\t\tif(!used[f->to])\n\t\t\t\t\tban[f->to]=0,vis[f->to]=-1;\n\t\tfor(int j=n;j--&&a[j]>a[mv];)if(!used[j]&&vis[j]!=-1)ban[j]=1;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define LL long long\n#define LD long double\n#define SC(t,x) static_cast<t>(x)\n#define AR(t) vector < t >\n#define PII pair < int, int >\n#define PLL pair < LL, LL >\n#define PIL pair < int, LL >\n#define PLI pair < LL, int >\n#define MP make_pair\n#define PB push_back\n#define PF push_front\n#define POB pop_back\n#define POF pop_front\n#define PRF first\n#define PRS second\n#define INIT(ar,val) memset ( ar, val, sizeof ( ar ) )\n#define lp(loop,start,end) for ( int loop = start; loop < end; ++loop )\n#define lpd(loop,start,end) for ( int loop = start; loop > end; --loop )\n#define lpi(loop,start,end) for ( int loop = start; loop <= end; ++loop )\n#define lpdi(loop,start,end) for ( int loop = start; loop >= end; --loop )\n#define qmax(a,b) (((a)>(b))?(a):(b))\n#define qmin(a,b) (((a)<(b))?(a):(b))\n#define qabs(a) (((a)>=0)?(a):(-(a)))\n\nconst int INF = 0x3fffffff;\nconst int SINF = 0x7fffffff;\nconst long long LINF = 0x3fffffffffffffff;\nconst long long SLINF = 0x7fffffffffffffff;\nconst int MAXN = 2007;\n\nint n;\nint ke, la[MAXN];\nint a[MAXN];\nbool g[MAXN][MAXN];\nAR(int) ar[MAXN];\nbool vis[MAXN];\n\nvoid init ();\nvoid input ();\nvoid work ();\n\nvoid dfs ( int now, AR(int) &ans );\n\nvoid join ( AR(int) &a, AR(int) &b );\n\nint gcd ( int x, int y )\n{\n\treturn y ? gcd ( y, x%y ) : x;\n}\n\n\n\nint main()\n{\n\tinit();\n\tinput();\n\twork();\n}\n\n\n\nvoid init ()\n{\n\t// Init Everything Here\n\t\n\tios::sync_with_stdio ( false );\n}\n\nvoid input ()\n{\n\t// input method\n\t\n\tscanf ( \"%d\", &n );\n\tlpi ( i, 1, n ) scanf ( \"%d\", &a[i] );\n}\n\nvoid work ()\n{\n\t// main work\n\t\n\tsort ( a+1, a+1+n );\n\t\n\tlpi ( i, 1, n ) lpi ( j, 1, n ) if ( i ^ j ) g[i][j] = gcd ( a[i], a[j] ) ^ 1;\n\t\n\tAR(int) ans, ret;\n\tlpi ( i, 1, n ){\n\t\tif ( !vis[i] ){\n\t\t\tdfs ( i, ret );\n\t\t\tjoin ( ans, ret );\n\t\t}\n\t}\n\t\n\tfor ( auto x : ans ) printf ( \"%d \", a[x] );\n\tputchar ( '\\n' );\n}\n\n\n\nvoid dfs ( int now, AR(int) &ans )\n{\n\tans.clear ();\n\tAR(int) ret;\n\tvis[now] = true;\n\tlpi ( v, 1, n ){\n\t\tif ( g[now][v] && !vis[v] ){\n\t\t\tdfs ( v, ret );\n\t\t\tjoin ( ans, ret );\n\t\t}\n\t}\n\treverse ( ans.begin (), ans.end () );\n\tans.PB ( now );\n\treverse ( ans.begin (), ans.end () );\n}\n\n\n\nvoid join ( AR(int) &a, AR(int) &b )\n{\n\tint na = a.size (), nb = b.size ();\n\tAR(int) ans ( na + nb );\n\tint ni = 0, nj = 0;\n\tlp ( i, 0, na + nb ){\n\t\tif ( nj == nb || ( ni < na && a[ni] > b[nj] ) ) ans[i] = a[ni], ++ni;\n\t\telse ans[i] = b[nj], ++nj;\n\t}\n\ta.swap ( ans );\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<bitset>\n#include<queue>\n#include<map>\nusing namespace std;\nconst int N=2010,V=1e5+10;\nint n,a[V],id;\nvector<int> e[V];\nmap<int,int> mp;\nbool used[N];\nint ok[N][N];\nint gcd(int x,int y){return y?gcd(y,x%y):x;}\nvoid addedge(int p,int prime){\n    int x=mp[prime];\n    if (!x) mp[prime]=x=++id;\n    e[p].push_back(x);\n    e[x].push_back(p);\n}\nvoid makegragh(int p){\n    int x=a[p];\n    for (int i=2;i*i<=x;i++)\n    if (x%i==0){\n        while (x%i==0) x/=i;\n        addedge(p,i);\n    }\n    if (x>1) addedge(p,x);\n}\nint q[N],size;\nint vis[N],C;\nvoid dfs(int x){\n    if (x<=n&&used[x]) return;\n    if (vis[x]==C) return;\n    vis[x]=C;\n    for (int i=0;i<e[x].size();i++) dfs(e[x][i]);\n}\nstruct array{\n    int cnt[N*4];\n    #define lc x<<1\n    #define rc x<<1|1\n    void set(int x,int l,int r,int p,int v){\n        if (l==r) return void(cnt[x]=v);\n        int mid=(l+r)>>1;\n        if (p>mid) set(rc,mid+1,r,p,v);else set(lc,l,mid,p,v);\n        cnt[x]=cnt[lc]+cnt[rc];\n    }\n    int next(int x,int l,int r,int p){\n        if (r<p||!cnt[x]) return n;\n        if (l==r) return l;\n        int mid=(l+r)>>1,ans=next(lc,l,mid,p);\n        return ans<n?ans:next(rc,mid+1,r,p);\n    }\n}arr[N];\nint main()\n{\n    scanf(\"%d\",&n);id=n;\n    for (int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n    sort(a+1,a+n+1);\n    for (int i=1;i<=n;i++) makegragh(i);\n    for (int i=1;i<=n;i++) ok[0][i]=1;\n    for (int i=1;i<=n;i++)\n    for (int j=1;j<=n;j++)\n        ok[i][j]=(gcd(a[i],a[j])!=1);\n    for (int i=0;i<=n;i++)\n    for (int j=1;j<=n;j++)\n        if (ok[i][j]) arr[i].set(1,1,n,j,1);\n    for (int i=1;i<=n;i++){\n        int Min;C++;\n        for (int j=1,p=n;j<=n;j++){\n            dfs(j);\n            while ((used[p]||vis[p]==C)&&p>j) p--;\n            if (p==j){Min=j;break;}\n        }\n        //>=Min的都满足test2()\n        int val=1e9,Max=n;\n        for (int j=size;j>=0;j--){\n            int nxt=arr[q[j]].next(1,1,n,Min);\n            if (nxt<=Max) val=min(val,nxt);\n            Max=min(Max,q[j]-1);\n        }\n        used[q[++size]=val]=1;\n        for (int j=1;j<=n;j++) arr[j].set(1,1,n,val,0);\n    }\n    for (int i=1;i<=n;i++) printf(\"%d \",a[q[i]]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define FOR(i,a,b) for (register int i=(a);i<=(b);i++)\n#define For(i,a,b) for (register int i=(a);i>=(b);i--)\n#define mem(i,j) memset(i,j,sizeof(i))\n#define GO(u) for (register int j=f[u];j!=-1;j=nxt[j])\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define MP make_pair\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\nconst int N=2020;\nint n,a[N],vis[N],cnt=0,ans[N],du[N];\nvector<int> vec[N],G[N];\npriority_queue <pii> q;\ninline int read()\n{\n\tint x=0,f=1;\n\tchar c=getchar();\n\twhile (c<'0'||c>'9') {if (c=='-') f=-1;c=getchar();}\n\twhile (c>='0'&&c<='9') {x=(x<<1)+(x<<3)+c-'0';c=getchar();}\n\treturn f*x;\n}\ninline void write(int x)\n{\n\tif (x<0) putchar('-'),x=-x;\n\tif (x>9) write(x/10);\n\tputchar(x%10+'0');\n\treturn;\n}\ninline int GCD(int x,int y)\n{\n\tif (!y) return x;\n\tif (x<y) return GCD(y,x);\n\treturn GCD(y,x%y);\n}\ninline void dfs(int u)\n{\n\tvis[u]=1;\n\tFOR(i,0,(int)vec[u].size()-1)\n\t{\n\t\tint v=vec[u][i];\n\t\tif (vis[v]) continue;\n\t\tG[u].pb(v);\n\t\tdu[v]++;\n\t\tdfs(v);\n\t}\n\treturn;\n}\nbool cmp(const int x,const int y) {return a[x]<a[y];}\nint main()\n{\n\tn=read();\n\tFOR(i,1,n) a[i]=read();\n\tFOR(i,1,n) FOR(j,1,n) if (i!=j) if (GCD(a[i],a[j])>1) vec[i].pb(j);\n\tFOR(i,1,n) sort(vec[i].begin(),vec[i].end(),cmp);\n\tFOR(i,1,n) if (!vis[i])\n\t{\n\t\tdfs(i);\n\t\tq.push(MP(a[i],i));\n\t}\n\twhile (q.size())\n\t{\n\t\tpii tmp=q.top();\n\t\tq.pop();\n\t\tans[++ans[0]]=tmp.fi;\n\t\tFOR(i,0,(int)G[tmp.se].size()-1)\n\t\t{\n\t\t\tint v=G[tmp.se][i];\n\t\t\tdu[v]--;\n\t\t\tif (!du[v]) q.push(MP(a[v],v));\n\t\t}\n\t}\n\tFOR(i,1,n) write(ans[i]),putchar(' ');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nstruct node\n{\n\tint id,num;\n};\nbool operator <(node a,node b)\n{\n\treturn a.num<b.num;\n}\npriority_queue<node> q;\nint n,i,j,k,a[2005],d[2005],e[2005][2005],cnt[2005],mn[2005],p[2005];\nbool v[2005][2005],vis[2005];\nint find(int x)\n{\n\treturn !p[x]?x:p[x]=find(p[x]);\n}\nint gcd(int a,int b)\n{\n\tif(!b)\n\t\treturn a;\n\treturn gcd(b,a%b);\n}\nbool cmp(int i,int j)\n{\n\treturn a[i]<a[j];\n}\nvoid dfs(int x)\n{\n\tvis[x]=true;\n\tfor(int y=1;y<=cnt[x];++y)\n\t\tif(!v[x][e[x][y]])\n\t\t{\n\t\t\tv[x][e[x][y]]=v[e[x][y]][x]=true;\n\t\t\t++d[e[x][y]];\n\t\t}\n\t\telse\n\t\t\te[x][y]=0;\n\tfor(int y=1;y<=cnt[x];++y)\n\t\tif(e[x][y]&&!vis[e[x][y]])\n\t\t\tdfs(e[x][y]);\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;++i)\n\t\tscanf(\"%d\",a+i);\n\tfor(i=1;i<=n;++i)\n\t\tfor(j=i+1;j<=n;++j)\n\t\t\tif(gcd(a[i],a[j])>1)\n\t\t\t{\n\t\t\t\te[i][++cnt[i]]=j;\n\t\t\t\te[j][++cnt[j]]=i;\n\t\t\t\tif(find(i)!=find(j))\n\t\t\t\t\tp[find(i)]=find(j);\n\t\t\t}\n\tfor(i=1;i<=n;++i)\n\t\tsort(e[i]+1,e[i]+1+cnt[i],cmp);\n\tfor(i=1;i<=n;++i)\n\t\tif(!mn[find(i)]||a[i]<a[mn[find(i)]])\n\t\t\tmn[find(i)]=i;\n\tfor(i=1;i<=n;++i)\n\t\tif(mn[find(i)]==i)\n\t\t\tdfs(i);\n\tfor(i=1;i<=n;++i)\n\t\tif(d[i]==0)\n\t\t\tq.push((node){i,a[i]});\n\twhile(!q.empty())\n\t{\n\t\ti=q.top().id;\n\t\tprintf(\"%d \",a[i]);\n\t\tq.pop();\n\t\tfor(j=1;j<=cnt[i];++j)\n\t\tif(e[i][j])\n\t\t{\n\t\t\t--d[e[i][j]];\n\t\t\tif(d[e[i][j]]==0)\n\t\t\t\tq.push((node){e[i][j],a[e[i][j]]});\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\nconst int N=100010,M=1000010,P=1e9+7;\nconst int inf=0x3f3f3f3f;\nconst int INF=0xcfcfcfcf;\nconst double eps=1e-9,pi=asin(1)*2;\ninline ll read();\n#define cmax(a,b) a=max(a,b)\n#define cmin(a,b) a=min(a,b)\ninline int ADD(int a,int b) { return a+b>=P?a+b-P:a+b; }\ninline int MINUS(int a,int b) { return a-b<0?a-b+P:a-b; }\n#define plus(a,b) a=ADD(a,b)\n#define minus(a,b) a=MINUS(a,b)\n#define mul(a,b) a=(1ll*a*(b))%P\n#define mem(a,b) memset(a,b,sizeof(a))\n#define pii pair<int,int>\n#define pil pair<int,ll>\n#define pli pair<ll,int>\n#define pll pair<ll,ll>\n#define mp(x,y) make_pair(x,y)\n\ninline int gcd(int x,int y) { return y?gcd(y,x%y):x; }\nint head[N],ver[M],nxt[M],du[N];\nint n,m,tot=1;\nint a[N];\ninline void add(int x,int y)\n{\n\tver[++tot]=y,nxt[tot]=head[x],head[x]=tot,du[y]++;\n}\n\nbool G[2010][2010];\nbool visit[N];\ninline void dfs(int x)\n{\n\tvisit[x]=true;\n\tfor(int y=1;y<=n;y++)\n\t{\n\t\tif(visit[y]||!G[x][y]) continue;\n\t\tadd(x,y);\n\t\tdfs(y);\n\t}\n}\npriority_queue<pii> q;\n\n#ifdef FILE\nconst int READ_SIZE=1<<20;\nchar buf[READ_SIZE],*p1=buf,*p2=buf;\n#define getchar() p1==p2&&(p2=(p1=buf)+fread(buf,1,READ_SIZE,stdin),p1==p2)?EOF:*p1++\n#endif\ninline ll read()\n{\n\tll s=0;\n\tbool flag=false;\n\tchar ch=getchar();\n\tfor(;ch<'0'||ch>'9';ch=getchar()) if(ch=='-') flag=true;\n\tfor(;'0'<=ch&&ch<='9';ch=getchar()) s=(s<<3)+(s<<1)+(ch^'0');\n\tif(flag) return -s;\n\treturn s;\n}\n\nint main()\n{\n#ifdef FILE\n\tfreopen(FILE \".in\",\"r\",stdin);\n\tfreopen(FILE \".out\",\"w\",stdout);\n#endif\n\tn=read();\n\tfor(int i=1;i<=n;i++) a[i]=read();\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(a[i]<a[j]&&gcd(a[i],a[j])>1)\n\t\t\t\tG[i][j]=G[j][i]=true;\n\tfor(int i=1;i<=n;i++)\n\t\tif(!visit[i]) dfs(i);\n\t\n\twhile(q.size()) q.pop();\n\tfor(int i=1;i<=n;i++)\n\t\tif(!du[i]) q.push(mp(a[i],i));\n\t\n\twhile(q.size())\n\t{\n\t\tpii b=q.top();q.pop();\n\t\tprintf(\"%d \",b.first);\n\t\tint x=b.second;\n\t\tfor(int i=head[x];i;i=nxt[i])\n\t\t{\n\t\t\tint y=ver[i];\n\t\t\tdu[y]--;\n\t\t\tif(!du[y]) q.push(mp(a[y],y));\n\t\t}\n\t}\n\tputchar('\\n');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=2005;\nint a[N],vis[N];\nvector<int>e[N],g[N]; \npriority_queue<int>pq;\nvoid dfs(int v)\n{\n\tvis[v]=1;\n\tfor(int i=0;i<e[v].size();i++)\n\t{\n\t\tint u=e[v][i];\n\t\tif(vis[u])\n\t\t\tcontinue;\n\t\tg[v].push_back(u);\n\t\tdfs(u);\n\t}\n}\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++)\t\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(__gcd(a[i],a[j])>1)\n\t\t\t\te[i].push_back(j);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(!vis[i])\n\t\t{\n\t\t\tdfs(i);\n\t\t\tpq.push(i);\n\t\t}\n\t}\n\twhile(!pq.empty())\n\t{\n\t\tint k=pq.top();\n\t\tpq.pop();\n\t\tprintf(\"%d \",a[k]);\n\t\tfor(int i=0;i<g[k].size();i++)\n\t\t\tpq.push(g[k][i]);\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n \nvi combine (const vi &l, const vi &r){\n\tif (l.empty() || r.empty())\n\t\treturn l.empty() ? r : l;\n\tvi res(l.size() + r.size());\n\tmerge(l.begin(), l.end(), r.begin(), r.end(), res.begin(), greater <int>());\n\treturn res;\n}\n \nvi dfs (int x, const vvi &g, vector<int> &used){\n\tused[x] = 1;\n\tvi res;\n\tfor (int i = 0; i < g[x].size(); i++){\n\t\tint v = g[x][i];\n\t\tif (used[v]) continue;\n\t\tres = combine(res, dfs(v, g, used));\n\t}\n\tres.insert(res.begin(), x);\n\treturn res;\n}\n\nint main(){\n\tint n;\n\tscanf(\"%d\", &n);\n\tvi a(n);\n\tfor (int i = 0; i < n; i++){\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\tsort(a.begin(), a.end());\n\tvvi g(n);\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < i; j++){\n\t\t\tif (__gcd(a[i], a[j]) != 1){\n\t\t\t\tg[i].push_back(j), g[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++){\n\t\tsort(g[i].begin(), g[i].end());\n\t}\n\tvi res;\n\tvi used(n);\n\tfor (int i = 0; i < n; i++){\t\n\t\tif (!used[i]) res = combine(res, dfs(i, g, used));\n\t}\n\tfor (int i = 0; i < n; i++){\n\t\tprintf(\"%d \", a[res[i]]);\n\t}\n\tprintf(\"\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n *                             UM.\n *                            J@B@1                                                                    iO@1\n *                           Y@@@B@BB.                                                              7B@B@B@\n *                          :@B@i,B@B@O                                                          ,Z@B@B@B@Br\n *                          @B@q   i@B@BS                                                      7@B@@@O5vMB@q\n *                         8@@B      LB@B@i                                                  FB@@@BNjYjLE@B@\n *                        ,B@B:        0@@@Z                                               P@B@BM1JJ125JPB@B\n *                        B@BB          :@B@B                                            XB@B@Z2LuU52F2u2@B@.\n *                       :@B@             @@@B:                                        v@B@B8uJj51F1525uUB@B7\n *                       @B@O              0@@B.               ..::ir7vvYUuU777r::.   B@B@OULU2F2F151F11Y@B@S\n *                       B@B,               8B@B  :ruXMB@B@B@B@B@B@B@B@B@B@@@B@B@B@B@B@B@5Jj1211F1F1F2FUJO@BB\n *                      U@B@                 @B@B@B@B@B@@@B@B@B@MMqPS5JuYL7rq@B@OBB@B@B8Yu211F1515251515YGB@@\n *                      @B@u                 v@@@@MSur:.                    LB@MvvjJuU5YU252F1F1F25251F2uX@@@\n *                      @@@.                                                N@BML2U2UUU12F15252525251515Jk@@B\n *                     r@B@                                                 YB@Bju52121252515252F15251F2u5@B@\n *                     PB@B                                                  @@@PYUF151F25151F152F2F1F15jF@@B\n *                     @@BS                                                  N@@@UJ2F25252F251525151F1F1u5@B@\n *                     @@@7                                                   B@B@5Yj12F152F1F1F25252515jFB@B\n *                     B@Bi                                                    M@B@O2Luu52525212F151121UY1@B@7\n *                    O@B@:                                                     v@B@BMSuYJJuuUu2u2uujjYJJXB@B@M\n *                  7B@B@,                                                        1B@@@B@GPF1uujuu21PNMB@B@B@B@@\n *                 qB@B2                                                            i8B@B@B@B@B@@@@@B@B@B@q: @@@B\n *                MB@B:                                                                 7SBB@B@B@B@B@Zu:      @B@B\n *               ZB@B.                                              ,v.                                        @B@L\n *              LB@B,                         Y7                    @B@Bu                                      7@B@\n *   :B@B@@B2:  @@B7                         @B@Z                   r@B@B@BP:                                   B@BE\n *    BB@@@B@B@B@BE                        r@B@B                       7@B@B@B@Ou:                              iB@B\n *         :uM@@B@@2.           :7::::ivk@B@B@0                           :5B@B@B@B@B@B@G.                       @B@i\n *            BB@@@B@@         :@B@B@@@B@B@@1                                 .i5M@B@B@@@5                       M@@2\n *            B@B ,@B1          L0EZZG0F7:                                            .:,                        uB@MrP@M7\n *           2@B@                                                                                               ,O@B@B@B@B\n *           @B@1                                                     :@B@@@r                                :@@@@B@BL:,,\n *           B@Bi                         :2ZS;                      :@B@B@B@r                               L@B@B@BU\n *           @B@.                        @@@B@B@                     vB@B@B@B5                                   @B@i\n *           B@B                        7B@B@B@BM                     OB@B@B@                                   ,B@B\n *           @B@                         @B@B@@@i                       rL7.                                    B@BM\n *           B@B7.:                       NB@@M.                                                               .@B@.\n *  .;JEB@@@B@B@B@B@.                                                                                       .  @B@u\n *@@@B@B@B@B@@@B@18U                                                                                      :B@B@B@BU,\n *7@BOui.    ,@@B                                                                                          SP@B@B@B@B@Or\n *            @@@U                                                                                           B@BJ.YO@B@B@i\n *            r@B@                                                                                         :B@Bk     .k@B@\n *             B@B@                                                                                       LB@@k         2i\n *              B@BM                                      .7jXEGqF7:                                     OB@@L\n *              .B@BM                                   .B@B@B@B@B@B@.                                 :@B@B:\n *               .B@B@                                   @@MYr::ivG@B                                .M@B@G\n *                 B@@@S                                                                           ,MB@B@,\n *                  v@@@BF                                                                      .1B@B@Br\n *                    2@@B@BL                                                                ,FB@@@B8,\n *                      r@B@B@BF,                                                        :YBB@B@B@B\n *                         L@B@B@B@P7,                                           .ivXB@B@B@B@B@M@B@\n *                            ,1B@B@B@B@@@BOP2L7i:,.              ..,:i7LSNB@@B@B@@@B@B@B@Z5v;.LB@@\n *                              @B@OEB@B@@@B@B@B@B@B@B@B@B@@@B@B@B@B@B@@@B@B@B@B@BM0SJ7i::::i:,u@B@\n *                              B@Bu ::i;7vu2XNGOMB@B@BMB@B@B@B@B@B@@@B1UFuj77ii:::::::iir;r;i.YB@B\n *                              @B@L.:i:i:i::::::::::..Y@B@BMYi:i;SB@B@N:.::i:iirir;r;rii::::ivO@B@\n *                              B@@X::,::::iirir;riri:E@B@1         ,@B@Br:;;r;rii:i::::i7JEB@@@@@B\n *                              @@@B@BBq5v7ii:::::::.2@@@i  ..,..     @B@@,,:::::irv2XMB@B@B@B@2@B@:\n *                             .B@BBB@@@B@B@B@BMNP5u7@B@1 .,,:,,  :.   @B@P50MB@B@B@B@B@@@BS:   @@B1\n *                             E@B@   ijGB@B@B@B@B@B@B@Bi .,:,,..@@B@7 B@B@B@B@B@B@BM57.        kB@B\n *                            .@B@:          .,ivu5Nq@B@u  ..,.. SB@B@@@B@PL7i,                 ,@B@\n *                            @@@8                   i@B@:    .     :B@B@@                       B@@2\n *                          i@@@@                     0@B@u          B@@B.                       vB@B\n *                         ,@B@G                       L@B@BOv:.:iFB@B@M                          @B@Bi\n *                          vNi                          S@@B@B@B@B@BM:                            MB@N\n *                                                          758BMqJ,\n *\n *                 .  YO.               vq                            :G       Z:\n *        SqOMBB@B@Br @@r rBE           @B     B@@@@@B@ONX8k    i::::.OB1.:::.u@O.::::i           @B@B@U:@@B@@BPEBu\n *        B@@NB@k.    5@i  uB@E.        BM     1U2uUJvirB@@Z   r@@B@B@@@B@B@B@B@B@@@B@Bi   LB@B@1 BX :@k uLLLvr@BJ:\n *            iB      iBi    7@     .@M8@BGMZZ         @@F            ,B       Pi          v@  Bq @i v@        B@\n *       vuL7r8@S7vJL7N@Z7LLri;72.   F7@Bvvv@@       @BX         @@@B@B@@@@@B@@@B@B@B      7@  @F Bi @q  @B@Bu @B\n *       N@B@G@@@8@BBOMB@G@BMNXG@,     B@   @@      .Bk          .:u;    i@:      Zv       7@  Bk @,;@  ,BY @B B@\n *            r@       @G     5.      ,@v   BZ :::,.r@E .::i,      @B     B@    .@BL       7@  @F B:i@. .@  @M @B\n *            7B: ,vO, @@   iB@:      @B   7@:MB@B@B@@@B@B@BM       @@.    B:  2@q         7@  BS @i 0@  B. @O B@\n *       ,r2EBB@B@B@Bi G@  @BB        B@   @B        @S              :    r@   ..          7B  @F @7  B7 @  @B @B\n *       E@B@UOBr       @B@Bi          L@0PB        .BZ        .@B@B@B@B@B@B@B@B@B@B@B@,   r@  BF @i  @G B@B@B B@\n *            7@,      kB@U    ;r        @@@.       .@Z                GBuL@iBBi           vB@B@q BP:5@7 @u,.  @B\n *            LBi   YB@BrB@    @@       @B:L@Br      BM             .M@B  rB  rB@J         v@. Pi @XZ8r  .     B@\n *        .   G@i B@BM.  ,B@,  @B    iB@B    N, 7r..q@k         ,LB@B8    J@,   i@B@B1r           Br           @@\n *        MB@B@B  ,i       B@B@B,    B@:        @B@B@F         .@BB:      P@i      :OBZ          .@U       B@B@B:\n *                          .ll                                           rB.                     :\n */\n/*\n██████████████████████████████████████████████████████████████████████████████\n██              ██████    ██████      ██      ██  ██    ██████              ██\n██  ██████████  ██  ██      ██      ██████████████  ██████  ██  ██████████  ██\n██  ██      ██  ██    ██  ████      ██    ██████████    ██  ██  ██      ██  ██\n██  ██      ██  ██    ██  ██      ██  ████        ██  ████  ██  ██      ██  ██\n██  ██      ██  ██  ██████  ████  ████████████  ██    ████████  ██      ██  ██\n██  ██████████  ██  ████  ██    ████    ████  ██████  ████  ██  ██████████  ██\n██              ██  ██  ██  ██  ██  ██  ██  ██  ██  ██  ██  ██              ██\n████████████████████  ██  ██    ██████  ██    ████  ████    ██████████████████\n██████  ████          ████        ██    ██    ████  ████████  ██          ████\n████  ██      ██  ██      ██  ██████  ████  ████    ██    ████    ████████  ██\n██      ██      ██    ██    ████      ████        ██████  ██      ██  ██    ██\n██  ██    ████████████  ████  ██  ████            ████  ████████████  ████  ██\n██  ██      ██  ██  ████    ████████                ████████      ██  ██    ██\n██  ██  ██  ██████████  ████    ██  ████  ██    ████  ████        ████  ██  ██\n██    ██  ████  ██████  ██    ******************    ████  ██            ██  ██\n██    ██████  ██  ██████      * Scan this QR   *██████    ██  ██  ██  ████████\n████  ████  ██  ██████      ██* code to join   *██  ████    ██  ████████  ████\n██████      ████████  ██      * in the Three   *██  ████          ████  ██  ██\n████              ████  ████  * Body ETO.      *  ████        ██  ████  ██  ██\n██████  ██    ████████        *  --ETO manager *██  ██                ██    ██\n████    ██  ██  ██    ██████  *    Ye Wenjie   *████  ████  ██  ████  ██  ████\n██  ████  ██████    ████  ██  *ETO(C),1988~2018*      ██  ██  ██  ██    ██████\n██  ██████  ██  ████    ██  ██******************          ██████    ██████  ██\n██  ██  ██    ████    ██        ██  ██        ████████      ████  ██  ██    ██\n████████████    ██    ██████  ██████████  ██  ████  ██████████    ██  ██  ████\n██████████    ██  ████  ██        ██    ██████████  ██    ██      ██  ██    ██\n██    ██  ████    ██  ████  ████      ██████    ██    ██      ██  ██  ████  ██\n██████  ██  ██████  ██            ██████████  ██    ██    ████  ████  ██    ██\n██      ██████  ████  ████  ████      ████    ████  ████            ██████████\n██████████████████      ██  ██  ████  ██    ██  ██    ████  ██████    ██    ██\n██              ██        ████████████  ████  ██  ██  ██    ██  ██      ██  ██\n██  ██████████  ██    ████  ██████  ██  ██████████████      ██████    ██  ████\n██  ██      ██  ████████    ██  ██      ████  ████  ██              ████  ████\n██  ██      ██  ████  ████  ████  ██████  ██████████████  ██████████    ██  ██\n██  ██      ██  ██    ██████  ██  ██  ██████████  ██  ██      ████    ██    ██\n██  ██████████  ██████  ████            ██    ████████  ██  ████    ██████████\n██              ██████    ████  ████████  ██  ████    ██    ██  ████  ████  ██\n██████████████████████████████████████████████████████████████████████████████\n    扫    描    二    维    码    加    入    三    体    E    T    O\n*/\n/*****************\n *   I<3   C++   *\n *  IWANT ANYAC  *\n * ILOVEPROGRAM! *\n *IT'SINTERESTING*\n * ILOVEPROGRAM! *\n *  INCONTESTS   *\n *   GETSCORE    *\n *    ACCODE     *\n *     LETS      *\n *      GO       *\n *Written by:    *\n *    charlieyan *\n *****************/\n#include <assert.h>\n#include <ctype.h>\n#include <errno.h>\n#include <float.h>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <locale>\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <wchar.h>\n#include <wctype.h>\n#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <cerrno>\n#include <clocale>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <limits>\n#include <map>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <istream>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <utility>\n#include <vector>\n#include <cwchar>\n#include <cwctype>\n#include <numeric>\n#include <list>\n#define LL long long\n#define pb push_back\n#define pob pop_back\n#define mp make_pair\n#define FILL(a,v) memset((void*)a,v,sizeof(a))\n#define FILL0(a) FILL(a,0)\n#define FILL1(a) FILL(a,-1)\n#define FILLBIG(a) FILL(a,0x3f)\n#define ALL(a) (a).begin(),(a).end()\n#define Inf ((int)0x3f3f3f3f)\n#define INF ((long long)0x3f3f3f3f3f3f3f3f)\n#define Mod 1000000007\n#define foreach(it,x) for(__typeof(x.begin()) it=x.begin();it!=x.end();it++)\n#define FOR(i,x) for(int i=0;i<x;i++)\n#define RFOR(i,x) for(int i=x-1;i>=0;i--)\n#define FFOR(i,a,b) for(int i=a;i<b;i++)\n#define FRFOR(i,a,b) for(int i=a-1;i>=b;i--)\n#define SZ(a) ((int)(a).size())\n#define FI first\n#define SE second\n#define OVER(...) return printf(__VA_ARGS__),0\n#define fastio ios::sync_with_stdio(0)\n#define filei(f) freopen(f,\"r\",stdin)\n#define fileo(f) freopen(f,\"w\",stdout)\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define MASK(a) (1<<(a))\n#define MASKX(x,a) ((x)<<(a))\n#define BIT(a,b) (((a)>>(b))&1)\n#define cddx(a) priority_queue<a >\n#define cxdd(a) priority_queue<a,vector<a >,greater<a > >\n#define deval(a) {cerr<<#a<<\" = \"<<a<<endl;}\n#define dearr(be,en) {cerr<<#be;cerr<<\" = {\";for(auto i=be;i!=en;i++)cerr<<' '<<*i;cerr<<\" }\\n\";}\n#define reg register\n#define prtime eprintf(\"\\n\\nTime used: %dms\\n\",clock());\n#define PI 3.1415926535897932384626\n#define TODEG(a) (a*180/PI)\n#define y0 ykangjimutigeidiqiuyipianjingtu\n#define y1 yxiaomiexuduhuanrenleiwannianankang\n#define endl '\\n'\n#define left leftxiaomiexudurenrenyouze\n#define hash hashxushibingduyouweilifushiyiqiedewuti\n//抗击母体，给地球一片净土\n//消灭徐毒，还人类万年安康\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef unsigned long long UINT;\ntypedef unsigned int uint;\ntypedef long long INT;\ntypedef long double ldouble;\ntypedef pair<INT,INT> PII;\ntypedef stringstream sst;\ntypedef istringstream iss;\ntypedef vector<int> vint;\ntypedef vector<INT> VINT;\ntypedef vector<pii> vpii;\ntypedef vector<PII> VPII;\ntypedef priority_queue<int> pqi;\ntypedef priority_queue<INT> PQI;\ntypedef priority_queue<pii> pqp;\ntypedef priority_queue<PII> PQP;\ntypedef priority_queue<int,vint,greater<int> > xqi;\ntypedef priority_queue<INT,VINT,greater<INT> > XQI;\ntypedef priority_queue<pii,vpii,greater<pii> > xqp;\ntypedef priority_queue<PII,VPII,greater<PII> > XQP;\nstruct fastIO\n{\n\tinline fastIO operator>>(int& num)\n\t{\n\t\tnum=0;\n\t\tchar c=getchar();\n\t\twhile(c!='-'&&(c<'0'||c>'9'))c=getchar();\n\t\tbool foo=0;\n\t\tif(c=='-')\n\t\t{\n\t\t\tfoo=1;\n\t\t\tc=getchar();\n\t\t}\n\t\twhile(c>='0'&&c<='9')\n\t\t{\n\t\t\tnum=(num<<3)+(num<<1)+c-'0';\n\t\t\tc=getchar();\n\t\t}\n\t\tif(foo)num=-num;\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(INT& num)\n\t{\n\t\tnum=0;\n\t\tchar c=getchar();\n\t\twhile(c!='-'&&(c<'0'||c>'9'))c=getchar();\n\t\tbool foo=0;\n\t\tif(c=='-')\n\t\t{\n\t\t\tfoo=1;\n\t\t\tc=getchar();\n\t\t}\n\t\twhile(c>='0'&&c<='9')\n\t\t{\n\t\t\tnum=(num<<3)+(num<<1)+c-'0';\n\t\t\tc=getchar();\n\t\t}\n\t\tif(foo)num=-num;\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(float& num)\n\t{\n\t\tscanf(\"%f\",&num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(double& num)\n\t{\n\t\tscanf(\"%lf\",&num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(long double& num)\n\t{\n\t\tscanf(\"%Lf\",&num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(char& num)\n\t{\n\t\tnum=getchar();\n\t\twhile(num==' '||num=='\\n')num=getchar();\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(char* num)\n\t{\n\t\tint cnt=0;\n\t\tchar c=getchar();\n\t\twhile(c==' '||c=='\\n')c=getchar();\n\t\twhile(c!=' '&&c!='\\n')\n\t\t{\n\t\t\tnum[cnt++]=c;\n\t\t\tc=getchar();\n\t\t}\n\t\tnum[cnt]=0;\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(string& num)\n\t{\n\t\tcin>>num;\n\t\treturn *this;\n\t}\n\tinline void printInt(const int& num)\n\t{\n\t\tif(num<10)\n\t\t{\n\t\t\tputchar(num+'0');\n\t\t\treturn;\n\t\t}\n\t\tprintInt(num/10);\n\t\tputchar((num%10)+'0');\n\t}\n\tinline void printINT(const INT& num)\n\t{\n\t\tif(num<10)\n\t\t{\n\t\t\tputchar(num+'0');\n\t\t\treturn;\n\t\t}\n\t\tprintINT(num/10);\n\t\tputchar((num%10)+'0');\n\t}\n\tinline fastIO operator<<(const int& num)\n\t{\n\t\tif(num<0)putchar('-'),printInt(-num);\n\t\telse printInt(num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const INT& num)\n\t{\n\t\tif(num<0)putchar('-'),printINT(-num);\n\t\telse printINT(num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const float& num)\n\t{\n\t\tprintf(\"%.10f\",num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const double& num)\n\t{\n\t\tprintf(\"%.16lf\",num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const long double& num)\n\t{\n\t\tprintf(\"%.20Lf\",num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const char& num)\n\t{\n\t\tputchar(num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const char* num)\n\t{\n\t\tfor(int i=0;num[i];i++)\n\t\t\tputchar(num[i]);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const string& num)\n\t{\n\t\tcout<<num;\n\t\treturn *this;\n\t}\n}fio;\n//Coded by Charlieyan\n//版权所有，翻印必究\n\nint n,a[2005];\nbool lgl[2005];\n\nstruct FFFFFFFFFF{\n\tbool operator()(const vint &a,const vint &b){\n\t\treturn a.back()<b.back();\n\t}\n};\n\nvint merge(vector<vint> vv){\n\tpriority_queue<vint,vector<vint>,FFFFFFFFFF> pq;\n\tfor(int i=0;i<SZ(vv);i++){\n\t\treverse(vv[i].begin(),vv[i].end());\n\t\tpq.push(vv[i]);\n\t}\n\tvint ans,tmp;\n\twhile(SZ(pq)){\n\t\ttmp=pq.top();\n\t\tpq.pop();\n\t\tans.pb(tmp.back());\n\t\ttmp.pop_back();\n\t\tif(SZ(tmp)){\n\t\t\tpq.push(tmp);\n\t\t}\n\t}\n\treturn ans;\n}\n\nvint dfs(int now){\n\tlgl[now]=1;\n\tvector<vint> ans;\n\tfor(int i=1;i<=n;i++){\n\t\tif(!lgl[i]&&__gcd(a[now],a[i])!=1){\n\t\t\tans.pb(dfs(i));\n\t\t}\n\t}\n\tvint v=merge(ans);\n\tv.insert(v.begin(),a[now]);\n\treturn v;\n}\n\nint main(){\n\tfio>>n;\n\tfor(int i=1;i<=n;i++){\n\t\tfio>>a[i];\n\t}\n\tsort(a+1,a+n+1);\n\tvector<vint> ans;\n\tfor(int i=1;i<=n;i++){\n\t\tif(!lgl[i]){\n\t\t\tans.pb(dfs(i));\n\t\t}\n\t}\n\tvint V=merge(ans);\n\tfor(int i:V){\n\t\tfio<<i<<' ';\n\t}\n\tfio<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n;\nconst int mxn=(1e5)+5;\nint a[mxn];\nset<int>s;\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;++i)\n\t\tscanf(\"%d\",&a[i]);\n\tif(n==1)\n\t{\n\t\tif(a[1]==1)puts(\"Second\");\n\t\telse puts(\"First\");\n\t\treturn 0;\n\t}\n\tsort(a+1,a+n+1);\n\tint g=a[n];\n\tfor(int i=n-1;i>=2;--i)g=__gcd(a[i],g);\n\tint num=0;\n\tfor(int i=1;i*i<=g;++i)\n\t{\n\t\tif(g%i==0)\n\t\t{\n\t\t\ts.insert(i);\n\t\t\ts.insert(g/i);\n\t\t}\n\t}\n\tint x=a[1];\n\tint div=1;\n\tset<int>::iterator it=s.upper_bound(min(g,a[1]));\n\tint d=1;\n\tif(it!=s.begin())\n\t{\n\t\t--it;\n\t\tint d=*it;\n\t}\n\tnum+=(a[1]-d);\n\tfor(int i=2;i<=n;++i)\n\t{\n\t\ta[i]/=d;\n\t\tnum+=(a[i]-1);\n\t}\n\tif(num%2)puts(\"First\");\n\telse puts(\"Second\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 2005\nusing namespace std;\ntypedef long long LL;\nint read()\n{\n\tchar c=getchar();int f=1,sum=0;\n\twhile(c<'0' || c>'9'){if(c=='-') f=-1;c=getchar();}\n\twhile(c>='0' && c<='9'){sum=sum*10+c-'0';c=getchar();}\n\treturn sum*f;\n}\nint gcd(int a,int b){return b==0?a:gcd(b,a%b);}\nint n,a[maxn];\nint head[maxn],to[maxn<<1],nex[maxn<<1],cnt;\nbool li[maxn][maxn],vis[maxn];\nint deg[maxn];\nvoid add(int u,int v)\n{\n\tdeg[v]++;to[++cnt]=v;nex[cnt]=head[u];head[u]=cnt;\n}\nvoid dfs(int x)\n{\n\tvis[x]=1;\n\tfor(int i=1;i<=n;i++)\n\tif(li[x][i] && !vis[i])\n\t{\n\t\tadd(x,i);\n\t\tdfs(i);\n\t}\n}\nstruct node{\n\tint val,id;\n    friend bool operator <(node a,node b){\n        return a.val<b.val;\n    }\n};\npriority_queue<node> q;\nint main()\n{\n\tn=read();\n\tfor(int i=1;i<=n;i++) a[i]=read();\n\tsort(a+1,a+1+n);\n\tfor(int i=1;i<n;i++)\n\tfor(int j=i+1;j<=n;j++)\n\tif(gcd(a[i],a[j])>1) li[i][j]=li[j][i]=1;\n\tfor(int i=1;i<=n;i++)\n\tif(!vis[i])\n\tdfs(i);\n\tfor(int i=1;i<=n;i++)\n\tif(!deg[i])\n\tq.push((node){a[i],i});\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tnode now=q.top();\n\t\tq.pop();\n\t\tprintf(\"%d \",a[now.id]);\n\t\tfor(int j=head[now.id];j;j=nex[j])\n\t\t{\n\t\t\tdeg[to[j]]--;\n\t\t\tif(!deg[to[j]])\n\t\t\tq.push((node){a[to[j]],to[j]});\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<cstring>\n#include<cmath>\n#include<ctime>\n#include<cstdio>\n#include<cstdlib>\n#include<string>\n#include<string.h>\n#include<math.h>\n#include<cassert>\n#include<iomanip>\n#include<utility>\n#include<bitset>\n#include<set>\n#include<map>\n#include<list>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<vector>\n#include<functional>\n#include<algorithm>\n//#include<memory.h>\n#include<assert.h>\n#include<numeric>\n#include<limits.h>\nusing namespace std;\nint n;\nint a[2005];\nbool e[2005][2005];\nbool vis[2005];\nvector<int>t,res,g[2005],ans[2005];\nint gcd(int x,int y){if(x%y)return gcd(y,x%y);else return y;}\nvoid dfs(int x)\n{\n\tif(x==n)\n\t{\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tif(vis[i])continue;\n\t\t\tg[n].push_back(i);\n\t\t\tt.push_back(i);\n\t\t\tdfs(i);\n\t\t}\n\t}\n\tvis[x]=1;\n\tfor(int i=0;i<n;i++)if(e[x][i]&&!vis[i])\n\t{\n\t\tg[x].push_back(i);\n\t\tt.push_back(i);\n\t\tdfs(i);\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++)scanf(\"%d\",&a[i]);\n\tsort(a,a+n);\n\tfor(int i=0;i<n;i++)vis[i]=false;\n\tfor(int i=0;i<n;i++)for(int j=0;j<n;j++)if(gcd(a[i],a[j])!=1)e[i][j]=1;else e[i][j]=0;\n\tt.push_back(n);\n\tdfs(n);\n\tfor(int i=n;i>=0;i--)\n\t{\n\t\tint x=t[i];\n\t\tfor(int j=0;j<g[x].size();j++)\n\t\t{\n\t\t\tint y=g[x][j];\n\t\t\tres.clear();\n\t\t\tfor(int k1=0,k2=0;k1<ans[x].size()||k2<ans[y].size();)if(k2==ans[y].size()||(k1<ans[x].size()&&ans[x][k1]>ans[y][k2]))res.push_back(ans[x][k1++]);else res.push_back(ans[y][k2++]);\n\t\t\tans[x]=res;\n\t\t}\n\t\tans[x].insert(ans[x].begin(),x);\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tprintf(\"%d\",a[ans[n][i]]);\n\t\tif(i==n)puts(\"\");else printf(\" \");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <vector>\n#include <iostream>\n#include <string.h>\n#include <string>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\ntypedef double LD;\ntypedef long long LL;\ntypedef pair<int, int> PII;\n#define MP make_pair\n#define PB push_back\n#define FOR(i,a,b) for(int i = (a); i < (b); ++i)\n#define RFOR(i,b,a) for(int i = (b) - 1; i >= (a); --i)\n#define REP(i, t) FOR(i,0,t)\n#define ALL(a) a.begin(), a.end()\n#define SZ(a) (int)((a).size())\n\nconst LL MOD = 1000000007;\nconst int INF = 1e9;\nconst int MAXN = 2007;\nconst LD EPS = 1e-7;\n\nint n, A[MAXN], B[MAXN][MAXN], P[MAXN], r = 0;\nbool used[MAXN];\nqueue <int> Q;\n\nint gcd(int a, int b)\n{\n\tif (a == 0) return b;\n\treturn gcd(b % a, a);\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0);\n\t//freopen(\"In.txt\", \"r\", stdin);\n\tcin >> n;\n\tREP(i, n) cin >> A[i];\n\tREP(i, n)\n\t{\n\t\tif (used[i]) continue;\n\t\tused[i] = true;\n\t\tQ.push(i);\n\t\tint sz = 0;\n\t\twhile (!Q.empty())\n\t\t{\n\t\t\tint v = Q.front();\n\t\t\tQ.pop();\n\t\t\tB[r][sz++] = A[v];\n\t\t\tREP(j, n)\n\t\t\t{\n\t\t\t\tif (!used[j] && gcd(A[v], A[j]) > 1)\n\t\t\t\t{\n\t\t\t\t\tused[j] = true;\n\t\t\t\t\tQ.push(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t++r;\n\t}\n\tREP(i, r) P[i] = 0;\n\tREP(i, n)\n\t{\n\t\tint mr = 0;\n\t\tREP(j, r)\n\t\t\tif (B[j][P[j]] > B[mr][P[mr]])\n\t\t\t\tmr = j;\n\t\tcout << B[mr][P[mr]] << ' ';\n\t\t++P[mr];\n\t}\n\t//cout << endl; system(\"pause\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint gcd(int x, int y) {\n\treturn !y ? x : gcd(y, x % y);\n}\nconst int N = 2010;\nint a[N], e[N][N], n, d[N];\nbool vis[N];\nvector<int> g[N];\nvoid dfs(int x) {\n\tvis[x] = 1;\n\tfor (int i = 1; i <= n; i++) \n\t\tif (!vis[i] && e[x][i]) {\n\t\t\tg[x].push_back(i); d[i]++;\n\t\t\tdfs(i);\n\t\t}\n}\npriority_queue<int> q;\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n\tsort(a + 1, a + 1 + n);\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = i + 1; j <= n; j++)\n\t\t\tif (gcd(a[i], a[j]) > 1)\n\t\t\t\te[i][j] = e[j][i] = 1;\n\tfor (int i = 1; i <= n; i++)\n\t\tif (!vis[i]) dfs(i);\n\tfor (int i = 1; i <= n; i++) if (!d[i]) q.push(i);\n\twhile (!q.empty()) {\n\t\tint u = q.top(); q.pop();\n\t\tprintf(\"%d \", a[u]);\n\t\tfor (int i = 0; i < g[u].size(); i++) {\n\t\t\tint v = g[u][i];\n\t\t\tif (!(--d[v])) q.push(v);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//waz\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)((x).size()))\n\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\ntypedef long long int64;\ntypedef unsigned int uint;\ntypedef unsigned long long uint64;\n\n#define gi(x) ((x) = F())\n#define gii(x, y) (gi(x), gi(y))\n#define giii(x, y, z) (gii(x, y), gi(z))\n\nint F()\n{\n\tchar ch;\n\tint x, a;\n\twhile (ch = getchar(), (ch < '0' || ch > '9') && ch != '-');\n\tif (ch == '-') ch = getchar(), a = -1;\n\telse a = 1;\n\tx = ch - '0';\n\twhile (ch = getchar(), ch >= '0' && ch <= '9')\n\t\tx = (x << 1) + (x << 3) + ch - '0';\n\treturn a * x;\n}\n\nconst int N = 2010;\n\nint n, a[N], t[N][N], deg[N];\n\nbool vis[N];\n\nVI edge[N];\n\nvoid dfs(int u)\n{\n\tvis[u] = 1;\n\tfor (int j = 1; j <= n; ++j)\n\t\tif (!vis[j] && t[u][j])\n\t\t\tedge[u].pb(j), ++deg[j], dfs(j);\n}\n\npriority_queue<int> pq;\n\nint main()\n{\n\tgi(n);\n\tfor (int i = 1; i <= n; ++i) gi(a[i]);\n\tsort(a + 1, a + n + 1);\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= n; ++j)\n\t\t\tif (__gcd(a[i], a[j]) != 1)\n\t\t\t\tt[i][j] = 1;\n\tfor (int i = 1; i <= n; ++i)\n\t\tif (!vis[i]) dfs(i);\n\tfor (int i = 1; i <= n; ++i) if (!deg[i]) pq.push(i);\n\twhile (!pq.empty())\n\t{\n\t\tint u = pq.top(); pq.pop();\n\t\tprintf(\"%d \", a[u]);\n\t\tfor (auto v : edge[u])\n\t\t{\n\t\t\t--deg[v];\n\t\t\tif (!deg[v]) pq.push(v);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <deque>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <vector>\n\n#define FOR(i,k,n) for (int (i)=(k); (i)<(n); ++(i))\n#define rep(i,n) FOR(i,0,n)\n#define pb push_back\n#define all(v) begin(v), end(v)\n#define debug(x) cerr<< #x <<\": \"<<x<<endl\n#define debug2(x,y) cerr<< #x <<\": \"<< x <<\", \"<< #y <<\": \"<< y <<endl\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<vector<int> > vvi;\ntypedef vector<ll> vll;\ntypedef vector<vector<ll> > vvll;\ntemplate<class T> using vv=vector<vector< T > >;\n\nvi a; // number of node\nvvi g;\nvvi child;\nset<int, greater<int> > root;\ndeque<bool> reached;\n\nvoid dfs(int s) {\n  root.insert(s);\n  deque<int> st;\n  st.push_back(s);\n  reached[s] = true;\n  while (!st.empty()) {\n    int u = st.back();\n    for (int v : g[u]) {\n      if (!reached[v]) {\n        child[u].push_back(v);\n        st.push_back(v);\n        reached[v] = true;\n        st.push_back(v);\n        break;\n      }\n    }\n    if (st.back() == u) {\n      st.pop_back();\n    }\n  }\n}\n\nvi retrieve(int r) {\n  int sz = (int)child[r].size();\n  if (sz == 0) {\n    return (vi){r};\n  }\n  int ret_size = 0;\n  vvi tmp(sz);\n  rep (i, sz) {\n    tmp[i] = retrieve(child[r][i]);\n    ret_size += (int)tmp[i].size();\n  }\n  sort(all(tmp), greater<vi>());\n  vi ret;\n  ret.reserve(ret_size + 10);\n  ret.push_back(r);\n  rep (i, sz) {\n    ret.insert(end(ret), all(tmp[i]));\n  }\n  return ret;\n}\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  a.resize(n);\n  int num1 = 0;\n  rep (i, n) {\n    scanf(\"%d\", &a[i]);\n    if (a[i] == 1) {\n      num1 += 1;\n    }\n  }\n  sort(all(a));\n  /*\n  map<int, int> mp;\n  rep (i, n) {\n    mp[a[i]] += 1;\n  }\n  a.erase(unique(all(a)), end(a));\n  int sz = a.size();\n  */\n\n  g.resize(n);\n  rep (i, n) {\n    rep (j, n) {\n      if (i == j) {\n        continue;\n      }\n      if (__gcd(a[i], a[j]) == 1) {\n        continue;\n      }\n      g[i].push_back(j);\n      g[j].push_back(i);\n      /*\n      if (a[i] <= a[j]) {\n        g[i].push_back(j);\n      }\n      if (a[i] >= b[i]) {\n        g[j].push_back(i);\n      }\n      */\n    }\n  }\n  rep (i, n) {\n    sort(all(g[i]));\n  }\n\n  // construct tree\n  child.resize(n);\n  reached.assign(n, false);\n  rep (i, n) {\n    if (reached[i]) {\n      continue;\n    }\n    if (a[i] == 1) {\n      root.insert(i);\n      reached[i] = true;\n      continue;\n    }\n    dfs(i);\n  }\n\n  for (int r : root) {\n    vi tmp = retrieve(r);\n    for (int i : tmp) {\n      printf(\"%d \", a[i]);\n    }\n  }\n  printf(\"\\n\");\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll int\n#define N ((ll)2010)\n\nll n,a[N],mini;\nvector <ll> e[N];\nbool mark[N];\n\nvoid dfs(ll x)\n{\n\tmark[x]=1;\n\tif(a[x]<a[mini])mini=x;\n\tfor(auto u:e[x])\n\t\tif(!mark[u])\n\t\t\tdfs(u);\n}\n\n\nint main()\n{\n\tcin>>n;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcin>>a[i];\n\t\tfor(int j=0;j<i;j++)\n\t\t\tif(__gcd(a[i],a[j])>1)\n\t\t\t\te[i].push_back(j),e[j].push_back(i);\n\t}\n\tset <pair<ll,ll> > s;\n\tfor(int i=0;i<n;i++)\n\t\tif(!mark[i])\n\t\t{\n\t\t\tmini=i;\n\t\t\tdfs(i);\n\t\t\ts.insert({a[mini],mini});\n\t\t}\n\tmemset(mark,0,sizeof mark);\n\twhile(s.size())\n\t{\n\t\tauto it=s.end();it--;\n\t\tll now=it->second;s.erase(it);\n\t\twhile(1)\n\t\t{\n\t\t\tmark[now]=1;\n\t\t\tcout<<a[now]<<\" \";\n\t\t\tll id=-1;\n\t\t\tfor(auto u:e[now])\n\t\t\t{\n\t\t\t\tif(mark[u])continue;\n\t\t\t\tif(id==-1 || a[u]<a[id])id=u;\n\t\t\t}\n\t\t\tif(id==-1)break;\n\t\t\tnow=id;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n,a[2005],V;\nvector<int>edge[2005];\nbool used[2005][2005],ex[2005][2005];\nint in[2005];\nvector<int>nxt;\nP q;\nvoid dfs(int v){\n\tif(used[V][v]) return; used[V][v] = 1;\n\tnxt.pb(v);\n\trep(i,edge[v].size()){\n\t\tif(used[V][edge[v][i]] || in[edge[v][i]] != V) continue;\n\t\tdfs(edge[v][i]);\n\t}\n}\nvector<int>mer(vector<int>ret,vector<int>hoge){\n\t\tint c = ret.size(),b = hoge.size();\n\t\tint i = 0,j = 0;\n\t\tvector<int>ret2; ret2.resize(c+b); int nxt = 0;\n\t\twhile(i!=c || j!=b){\n\t\t\tif(i==c) ret2[nxt++] = (hoge[j++]);\n\t\t\telse if(j==b) ret2[nxt++] = (ret[i++]);\n\t\t\telse{\n\t\t\t\tif(a[ret[i]] > a[hoge[j]]) ret2[nxt++] = (ret[i++]);\n\t\t\t\telse ret2[nxt++] = (hoge[j++]);\n\t\t\t}\n\t\t}\n\t\treturn ret2;\n}\nvector<int>make(vector<int>L,int cut){\n\tvector<int>ret;\n\tif(L.size() == 1){\n\t\tret.pb(cut); return ret;\n\t}\n\trep(i,L.size()){\n\t\tif(L[i] != cut){\n\t\t    in[L[i]] = cut;\n\t\t}\n\t}\n\tvector<pair<vector<int>,int> >vv;\n\trep(i,L.size()){\n\t\tif(L[i] == cut) continue;\n\t\tif(!used[cut][L[i]]){\n\t\t\tnxt.clear(); q = mp(INF,INF);\n\t\t\tV = cut; dfs(L[i]);\n\t\t\trep(j,nxt.size()){\n\t\t\t\tif(ex[nxt[j]][cut]){\n\t\t\t\t\tq = min(q,mp(a[nxt[j]],nxt[j]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tvv.pb(mp(nxt,q.sc));\n\t\t}\n\t}\n\trep(ii,vv.size()){\n\t\tvector<int>&nxt = vv[ii].fi; int Q = vv[ii].sc;\n\t\tvector<int>hoge = make(nxt,Q);\n\t\tret = mer(ret,hoge);\n\t}\n\tret.insert(ret.begin(),cut);\n\treturn ret;\n}\nbool U[2005];\nvector<int>vi;\nP p;\nvoid DFS(int x){\n\tif(U[x]) return; U[x] = 1;\n\tvi.pb(x); p = min(p,mp(a[x],x));\n\trep(i,edge[x].size()){\n\t\tDFS(edge[x][i]);\n\t}\n}\nvector<int>res;\nint main(){\n\tcin>>n; n = 2000;\n\trepn(i,n){\n\t\ta[i] = rand()+1 ; // cin>>a[i];\n\t}\n\tsort(a+1,a+n+1);\n\trepn(i,n) repn(j,n){\n\t\tif(i != j && __gcd(a[i],a[j]) > 1){\n\t\t\tedge[i].pb(j); ex[i][j] = 1;\n\t\t}\n\t}\n\trepn(i,n){\n\t\tif(U[i]) continue; p = mp(INF,INF); vi.clear();\n\t\tDFS(i);\n\t\tvector<int>vec = make(vi,p.sc);\n\t\tres = mer(res,vec);\n\t}\n\trep(i,n) cout<<a[res[i]]<<\" \";\n\tcout<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ADD(a, b) a = (a + ll(b)) % mod\n#define MUL(a, b) a = (a * ll(b)) % mod\n#define MAX(a, b) a = max(a, b)\n#define MIN(a, b) a = min(a, b)\n#define rep(i, a, b) for(int i = int(a); i < int(b); i++)\n#define rer(i, a, b) for(int i = int(a) - 1; i >= int(b); i--)\n#define all(a) (a).begin(), (a).end()\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sec second\n#define fst first\n#define debug(fmt, ...) Debug(__LINE__, \":\", fmt, ##__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<int, pi> ppi;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vl> mat;\ntypedef complex<double> comp;\nvoid Debug() {cout << '\\n'; }\ntemplate<class FIRST, class... REST>void Debug(FIRST arg, REST... rest){\n\tcout<<arg<<\" \";Debug(rest...);}\ntemplate<class T>ostream& operator<<(ostream& out,const vector<T>& v) {\n\tout<<\"[\";if(!v.empty()){rep(i,0,sz(v)-1)out<<v[i]<<\", \";out<<v.back();}out<<\"]\";return out;}\ntemplate<class S, class T>ostream& operator<<(ostream& out,const pair<S, T>& v){\n\tout<<\"(\"<<v.first<<\", \"<<v.second<<\")\";return out;}\nconst int MAX_N = 2010;\nconst int MAX_V = 100010;\nconst double eps = 1e-6;\nconst ll mod = 1000000007;\nconst int inf = 1 << 29;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\nll gcd(ll a, ll b) {\n\tif(b == 0) return a;\n\telse return gcd(b, a % b);\n}\n\nint N;\nbool on[MAX_N], used[MAX_N];\nbool deleted[MAX_N];\nint A[MAX_N];\nvector<int> G[MAX_N];\n\nvoid add_edge(int from, int to) {\n\tG[from].pb(to);\n\tG[to].pb(from);\n}\n\nvoid erase_node(int v) {\n\tdeleted[v] = true;\n\trep(i, 0, sz(G[v])) {\n\t\tint n = G[v][i];\n\t\ton[n] = true;\n\t}\n}\n\npi loop(int v, bool only = false) {\n\tused[v] = true;\n\tpi res;\n\tif(!only || on[v]) res = pi(A[v], v);\n\telse res = pi(inf, inf);\n\trep(i, 0, sz(G[v])) {\n\t\tint n = G[v][i];\n\t\tif(!used[n] && !deleted[n]) MIN(res, loop(n, only));\n\t}\n\treturn res;\n}\n\nvoid loop2(int v) {\n\tused[v] = true;\n\ton[v] = false;\n\trep(i, 0, sz(G[v])) {\n\t\tint n = G[v][i];\n\t\tif(!used[n] && !deleted[n]) loop2(n);\n\t}\n}\n\nvoid graph_show() {\n\trep(i, 0, N) {\n\t\tvector<int> res;\n\t\tif(deleted[i]) {\n\t\t\tdebug(A[i], res);\n\t\t\tcontinue;\n\t\t}\n\t\trep(j, 0, sz(G[i])) {\n\t\t\tint n = G[i][j];\n\t\t\tif(deleted[n]) continue;\n\t\t\tres.pb(A[n]);\n\t\t}\n\t\tdebug(A[i], res);\n\t}\n}\n\n\nset<vector<int>> board;\n\nvoid loop(vector<int> vec) {\n\tboard.insert(vec);\n\n\trep(i, 0, N - 1) {\n\t\tint j = i + 1;\n\t\tif(gcd(vec[i], vec[j]) == 1) {\n\t\t\tswap(vec[i], vec[j]);\n\t\t\tif(board.find(vec) == board.end()) loop(vec);\n\t\t\tswap(vec[i], vec[j]);\n\t\t}\n\t}\n}\n\nvector<int> sub_solve(vector<int> vec) {\n\tvector<int> ans;\n\tsort(all(vec));\n\tans = vec;\n\treverse(all(ans));\n\n\tdo {\n\t\tboard.clear();\n\t\tloop(vec);\n\t\tvector<int> res = vec;\n\t\tfor(auto tvec : board) {\n\t\t\tMAX(res, tvec);\n\t\t}\n\t\t// debug(vec, res);\n\t\tMIN(ans, res);\n\t} while(next_permutation(all(vec)));\n\treturn ans;\n}\n\n\nvoid solve() {\n\tcin >> N;\n\trep(i, 0, N) cin >> A[i];\n\trep(i, 0, N) {\n\t\trep(j, i + 1, N) {\n\t\t\tif(gcd(A[i], A[j]) != 1) {\n\t\t\t\tadd_edge(i, j);\n\t\t\t}\n\t\t}\n\t}\n\n\trep(i, 0, N) {\n\t\tif(!used[i]) {\n\t\t\tpi p = loop(i);\n\t\t\ton[p.sec] = true;\n\t\t}\n\t}\n\tvector<int> ans;\n\trep(q, 0, N) {\n\t\t// debug(vi(on, on + N));\n\t\t// graph_show();\n\t\tint a = -1, at = -1;\n\t\tmemset(used, 0, sizeof(used));\n\t\trep(i, 0, N) {\n\t\t\tif(!used[i] && !deleted[i]) {\n\t\t\t\tpi p = loop(i, true);\n\t\t\t\tif(a < p.fst) {\n\t\t\t\t\ta = p.fst; at = p.sec;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans.pb(a);\n\t\tmemset(used, 0, sizeof(used));\n\t\tloop2(at);\n\t\terase_node(at);\n\t}\n\trep(i, 0, N) {\n\t\tcout << ans[i] << \" \";\n\t}\n\tcout << \"\\n\";\n}\n\n\nint main() {\n#ifndef LOCAL\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n\tcout.precision(20);\n\tsrand((unsigned int)time(NULL));\n#ifdef LOCAL\n\t//freopen(\"in.txt\", \"wt\", stdout); //for tester\n    freopen(\"in.txt\", \"rt\", stdin);\n#endif\t\n\tsolve();\n#ifdef LOCAL\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nconst int maxn = 2030, oo = 123456789, maxm = 34010;\n \nint n, m, T, ans, mn, a[maxn], foo[maxn], lst[maxm], tag[maxn], q[maxn], rar;\nbool vis[maxn], f[maxn], G[maxn][maxn], F[maxn];\nstd::vector<int> g[maxn], has[maxn], rhas[maxm], all;\nstd::vector<std::pair<int, int> > v;\n \nvoid GEN() {\n\tint mx = 0;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif(!foo[i]) {\n\t\t\tif(a[i] == 1) {\n\t\t\t\tF[i] = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tF[i] = 0;\n\t\t\t\tfor (int j: has[i]) {\n\t\t\t\t\tif(lst[j] >= mx) {\n\t\t\t\t\t\tF[i] = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t(foo[i] > mx) && (mx = foo[i]);\n\t\t}\n\t}\n\treturn;\n}\n /*\ninline void dfs(int &u) {\n\ttag[u] = T;\n\t(F[u] && a[u] < mn) && (mn = a[u]);\n\tvis[u] = 1;\n\tfor (int &v: g[u]) {\n\t\tif(!vis[v] && !f[v]) {\n\t\t\tdfs(v);\n\t\t}\n\t}\n\treturn;\n}\n */\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tscanf(\"%d\", a + i);\n\t\tint t = a[i];\n\t\tfor (int x = 2; x * x <= t; ++x) {\n\t\t\tif(t % x == 0) {\n\t\t\t\tall.push_back(x);\n\t\t\t\twhile(t % x == 0) {\n\t\t\t\t\tt /= x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(t > 1) {\n\t\t\tall.push_back(t);\n\t\t}\n\t}\n\tstd::sort(a + 1, a + n + 1);\n\tstd::sort(all.begin(), all.end());\n\tall.resize(std::unique(all.begin(), all.end()) - all.begin());\n\tm = (int)(all.size());\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tif(a[i] % all[j] == 0) {\n\t\t\t\thas[i].push_back(j);\n\t\t\t\trhas[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int j = 0; j < m; ++j) {\n\t\tfor (int i = 0; i < (int)(rhas[j].size()); ++i) {\n\t\t\tfor (int k = 0; k < i; ++k) {\n\t\t\t\tint u = rhas[j][i], v = rhas[j][k];\n\t\t\t\tif(!G[u][v]) {\n\t\t\t\t\tg[u].push_back(v);\n\t\t\t\t\tg[v].push_back(u);\n\t\t\t\t\tG[u][v] = G[v][u] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tGEN();\n\t\tmemset(vis + 1, 0, sizeof(vis[0]) * n);\n\t\tv.clear();\n\t\tfor (int u = 1; u <= n; ++u) {\n\t\t\tif(F[u]) {\n\t\t\t\tif(!vis[u] && !f[u]) {\n\t\t\t\t\t++T;\n\t\t\t\t\tmn = oo;\n//\t\t\t\t\tdfs(u);\n\t\t\t\t\trar = 0;\n\t\t\t\t\tq[rar++] = u;\n\t\t\t\t\tvis[u] = 1;\n\t\t\t\t\tfor (register int fnt = 0; fnt < rar; ++fnt) {\n\t\t\t\t\t\tint u = q[fnt];\n\t\t\t\t\t\ttag[u] = T;\n\t\t\t\t\t\t(F[u] && a[u] < mn) && (mn = a[u]);\n\t\t\t\t\t\tfor (int &v: g[u]) {\n\t\t\t\t\t\t\tif(!vis[v] && !f[v]) {\n\t\t\t\t\t\t\t\tq[rar++] = v;\n\t\t\t\t\t\t\t\tvis[v] = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tv.push_back(std::make_pair(mn, T));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstd::sort(v.begin(), v.end());\n\t\tint sz = (int)(v.size());\n\t\t//ans = 0;\n\t\tfor (int u = 1; u <= n; ++u) {\n\t\t\tif(F[u] && !f[u]) {\n\t\t\t\tint i = sz - 1;\n\t\t\t\tif(v[i].second == tag[u]) {\n\t\t\t\t\t--i;\n\t\t\t\t}\n\t\t\t\tif(i < 0 || v[i].first <= a[u]) {\n\t\t\t\t\tans = u;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tf[ans] = 1;\n\t\tfoo[ans] = i;\n\t\tprintf(\"%d \", a[ans]);\n\t\tfor (int j: has[ans]) {\n\t\t\tlst[j] = i;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <vector>\n#include <cassert>\n#include <algorithm>\nusing namespace std;\n\nconst int N = 2005;\nbool G[N][N];\nbool used[N];\nvector <int> g[N];\nint n, a[N], sz;\nint in[N];\npriority_queue <int> pq;\n\ninline int gcd(int a, int b) { return !b ? a : gcd(b, a % b); }\n\nvoid dfs(int i) {\n\tused[i] = 1;\n\tfor (int j = 0; j < n; ++ j) if (!used[j] && G[i][j]) { g[i].push_back(j); ++ in[j]; dfs(j); }\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; ++ i) scanf(\"%d\", &a[i]);\n\tsort(a, a + n);\n\tfor (int i = 0; i < n; ++ i) for (int j = 0; j < n; ++ j) if (i ^ j) G[i][j] = (gcd(a[i], a[j]) != 1);\n\tfor (int i = 0; i < n; ++ i) if (!used[i]) dfs(i);\n\tfor (int i = 0; i < n; ++ i) if (!in[i]) pq.push(i);\n\twhile (!pq.empty()) {\n\t\tint i = pq.top(); pq.pop();\n\t\tprintf(\"%d \", a[i]);\n\t\tfor (int j = 0; j < (int) g[i].size(); ++ j) {\n\t\t\t-- in[g[i][j]];\n\t\t\tif (!in[g[i][j]]) pq.push(g[i][j]);\n\t\t}\n\t}\n\tputs(\"\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nstruct ha{\n\tvector<int> a;\n}c[2005];\nint gcd(int a,int b){\n\tint t;\n\twhile(b){\n\t\tt=a;a=b;b=t%a;\n\t}\n\treturn a;\n}\nint n,a[2005],b[2005][2005],tot[2005],now;\npair<int,int> g[2005];\nbool mp[2005][2005];\nint fst[2005],lst[2005],cnt=0,e[4000005];\nbool vis[2005];\nvector<int> ans;\nvoid dfs(int k){\n\tvis[k]=1;c[now].a.push_back(k);\n\tfor(int i=fst[k];i<=lst[k];i++) if(!vis[e[i]])\n\t\tdfs(e[i]);\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++){\n\t\tfst[i]=cnt+1;\n\t\tfor(int p=1;p<=n;p++) if(p!=i){\n\t\t\tif(gcd(a[i],a[p])>1) e[++cnt]=p,mp[i][p]=1;\n\t\t}\n\t\tlst[i]=cnt;\n\t\tsort(e+fst[i],e+lst[i]+1);\n\t}\n\tfor(int i=1;i<=n;i++) if(!vis[i]){\n\t\tnow++;\n\t\tdfs(i);\n\t\tg[now]=make_pair(a[c[now].a[0]],now);\n\t\t/*for(int i=0;i<c[now].a.size();i++){\n\t\t\tint x=c[now].a[i];\n\t\t\tfor(int p=i-1;~p;p--){\n\t\t\t\tif(mp[x][c[now].a[p]]){\n\t\t\t\t\tif(x<=c[now].a[p+1]) break;\n\t\t\t\t\tc[now].a.erase(c[now].a.begin()+i);\n\t\t\t\t\tc[now].a.insert(c[now].a.begin()+p+1,x);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}*/\n\t}\n\tsort(g+1,g+now+1);\n\tfor(int i=now;i;i--){\n\t\tint id=g[i].second;\n\t\tfor(int p=0;p<c[id].a.size();p++)\n\t\t\tans.push_back(c[id].a[p]);\n\t}\n\tfor(int i=0;i<ans.size();i++){\n\t\tint x=ans[i],now=i;\n\t\tfor(int p=i-1;~p;p--){\n\t\t\tif(mp[x][ans[p]]) break;\n\t\t\tif(x<=ans[p]) continue;\n\t\t\tans.erase(ans.begin()+now);\n\t\t\tans.insert(ans.begin()+p,x);\n\t\t\tnow=p;\n\t\t}\n\t}\n\tfor(int i=0;i<ans.size();i++) printf(\"%d \",a[ans[i]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iomanip>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define all(x) (x).begin(),(x).end()\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n \ntemplate<class T> inline bool chmax(T &a, T b){\n    if(a<b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T> inline bool chmin(T &a, T b){\n    if(a>b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<typename T>\nT gcd(T a, T b)\n{\n    return b ? gcd(b, a % b) : a;\n}\n\ntemplate<typename T>\nT lcm(T a,T b)\n{\n    return  a / gcd(a,b) * b;\n}\nclass UnionFind {\nprivate:\n    int sz;\n    vector<int> par, size_;\npublic:\n    UnionFind(){}\n    UnionFind(int node_size) : sz(node_size), par(sz), size_(sz, 1){\n        iota(par.begin(), par.end(), 0);\n    }\n    int find(int x){\n        if(par[x] == x) return x;\n        else return par[x] = find(par[x]);\n    }\n    void unite(int x,int y){\n        x = find(x), y = find(y);\n        if(x == y) return;\n        if(size_[x] < size_[y]) swap(x,y);\n        par[y] = x;\n        size_[x] += size_[y];\n    }\n    int size(int x){\n        x = find(x);\n        return size_[x];\n    }\n    bool same(int x,int y){\n        return find(x) == find(y);\n    }\n};\ntemplate<class _Key, class _Hash, bool DOWNSIZE> class UnorderedSetIterator;\n \ntemplate<class _Key, class _Hash = hash<_Key>, bool DOWNSIZE = false>\nclass UnorderedSet\n{\nprivate:\n    using iterator = UnorderedSetIterator<_Key, _Hash, DOWNSIZE>;\n    friend UnorderedSetIterator<_Key, _Hash, DOWNSIZE>;\n    struct bucket {\n        _Key _key;\n        short int _dist;\n        bool _last, _end;\n        bucket() noexcept : _dist(-1), _last(false), _end(false){}\n        bucket& operator=(const bucket& another) = default;\n        ~bucket(){ if(!empty()) _key.~_Key(); }\n        inline void clear() noexcept { _dist = -1; }\n        inline void _delete(){ _dist = -1, _key.~_Key(); }\n        inline bool empty() const noexcept { return (_dist == -1); }\n    };\n    inline static unsigned int ceilpow2(unsigned int u) noexcept {\n        --u, u |= u >> 1, u |= u >> 2, u |= u >> 4, u |= u >> 8;\n        return (u | (u >> 16)) + 1;\n    }\n    inline static bucket *increment(bucket *cur) noexcept {\n        for(++cur; !cur->_end; ++cur){\n            if(!cur->empty()) break;\n        }\n        return cur;\n    }\n    inline bucket *next_bucket(bucket *cur) const noexcept {\n        return cur->_last ? _buckets : cur + 1;\n    }\n    inline unsigned int make_hash(const _Key& key) const noexcept {\n        return _Hash()(key);\n    }\n    inline float load_rate() const noexcept {\n        return (float)_data_count / _bucket_count;\n    }\n    bucket *insert(bucket *cur, short int dist, _Key&& key){\n        bucket *ret = cur;\n        bool flag = false;\n        while(true){\n            if(cur->empty()){\n                cur->_key = move(key), cur->_dist = dist;\n                if(!flag) ret = cur, flag = true;\n                break;\n            }else if(dist > cur->_dist){\n                swap(key, cur->_key), swap(dist, cur->_dist);\n                if(!flag) ret = cur, flag = true;\n            }\n            ++dist;\n            cur = next_bucket(cur);\n        }\n        return ret;\n    }\n    bucket *_find(const _Key& key) const {\n        bucket *cur = _buckets + (make_hash(key) & _mask);\n        int dist = 0;\n        while(dist <= cur->_dist){\n            if(key == cur->_key) return cur;\n            ++dist, cur = next_bucket(cur);\n        }\n        return _buckets + _bucket_count;\n    }\n    template<class Key>\n    bucket *find_insert(Key&& key){\n        unsigned int hash = make_hash(key);\n        bucket *cur = _buckets + (hash & _mask);\n        int dist = 0;\n        while(dist <= cur->_dist){\n            if(key == cur->_key) return cur;\n            ++dist, cur = next_bucket(cur);\n        }\n        ++_data_count;\n        if(rehash_check()){\n            cur = _buckets + (hash & _mask), dist = 0;\n        }\n        _Key new_key = forward<Key>(key);\n        return insert(cur, dist, move(new_key));\n    }\n    bucket *backward_shift(bucket *cur, bool next_ret){\n        bucket *next = next_bucket(cur), *ret = cur;\n        if(next->_dist < 1) return next_ret ? increment(cur) : cur;\n        do {\n            cur->_key = next->_key, cur->_dist = next->_dist - 1;\n            cur = next, next = next_bucket(cur);\n        }while(next->_dist >= 1);\n        cur->clear();\n        return ret;\n    }\n    bucket *erase_impl(bucket *cur, bool next_ret){\n        assert(static_cast<size_t>(cur - _buckets) != _bucket_count);\n        cur->_delete();\n        --_data_count;\n        return backward_shift(cur, next_ret);\n    }\n    bucket *erase_itr(bucket *cur, bool next_ret = true){\n        const _Key key = cur->_key;\n        return erase_impl(rehash_check() ? _find(key) : cur, next_ret);\n    }\n    bucket *erase_key(const _Key& key, bool next_ret = true){\n        rehash_check();\n        return erase_impl(_find(key), next_ret);\n    }\n    bool rehash_check(){\n        if(load_rate() >= MAX_LOAD_RATE){\n            rehash(_bucket_count * 2u);\n            return true;\n        }else if(DOWNSIZE){\n            if(load_rate() <= MIN_LOAD_RATE && _bucket_count >= DOWNSIZE_THRESHOLD){\n                rehash(_bucket_count / 2u);\n                return true;\n            }\n        }\n        return false;\n    }\n    void move_data(bucket *cur){\n        insert(_buckets + (make_hash(cur->_key) & _mask), 0, move(cur->_key));\n    }\n    void rehash(unsigned int new_bucket_count){\n        UnorderedSet new_unordered_set(new_bucket_count);\n        new_unordered_set._data_count = _data_count;\n        for(bucket *cur = _buckets; !cur->_end; ++cur){\n            if(!cur->empty()){\n                new_unordered_set.move_data(cur);\n            }\n        }\n        swap(*this, new_unordered_set);\n    }\n    friend void swap(UnorderedSet& ust1, UnorderedSet& ust2){\n        swap(ust1._bucket_count, ust2._bucket_count);\n        swap(ust1._mask, ust2._mask);\n        swap(ust1._data_count, ust2._data_count);\n        swap(ust1._buckets, ust2._buckets);\n    }\n \nprivate:\n    unsigned int _bucket_count, _mask, _data_count;\n    bucket *_buckets;\npublic:\n    const float MAX_LOAD_RATE = 0.5f;\n    const float MIN_LOAD_RATE = 0.1f;\n    const unsigned int DOWNSIZE_THRESHOLD = 16u;\n    UnorderedSet(unsigned int bucket_size = 1u)\n     : _bucket_count(ceilpow2(max(bucket_size, 1u))), _mask(_bucket_count - 1),\n        _data_count(0u), _buckets(new bucket[_bucket_count + 1]){\n        _buckets[_bucket_count - 1]._last = true, _buckets[_bucket_count]._end = true;\n    }\n    UnorderedSet(const UnorderedSet& another)\n        : _bucket_count(another._bucket_count), _mask(another._mask), _data_count(another._data_count){\n        _buckets = new bucket[_bucket_count + 1u];\n        for(unsigned int i = 0u; i <= _bucket_count; ++i){\n            _buckets[i] = another._buckets[i];\n        }\n    }\n    UnorderedSet(UnorderedSet&& another)\n        : _bucket_count(move(another._bucket_count)), _mask(move(another._mask)),\n            _data_count(move(another._data_count)), _buckets(another._buckets){\n        another._buckets = nullptr;\n    }\n    UnorderedSet& operator=(const UnorderedSet& another){\n        delete[] _buckets;\n        _bucket_count = another._bucket_count;\n        _mask = another._mask;\n        _data_count = another._data_count;\n        _buckets = new bucket[_bucket_count + 1u];\n        for(unsigned int i = 0u; i <= _bucket_count; ++i){\n            _buckets[i] = another._buckets[i];\n        }\n        return *this;\n    }\n    UnorderedSet& operator=(UnorderedSet&& another){\n        delete[] _buckets;\n        _bucket_count = move(another._bucket_count);\n        _mask = move(another._mask);\n        _data_count = move(another._data_count);\n        _buckets = another._buckets;\n        another._buckets = nullptr;\n        return *this;\n    }\n    ~UnorderedSet(){ delete[] _buckets; }\n    friend ostream& operator<< (ostream& os, UnorderedSet& ust) noexcept {\n        for(_Key& val : ust) os << val << \" \";\n        return os;\n    }\n    void clear(){\n        UnorderedSet new_unordered_set(1u);\n        swap(*this, new_unordered_set);\n    }\n    size_t size() const noexcept { return _data_count; }\n    size_t bucket_count() const noexcept { return _bucket_count; }\n    bool empty() const noexcept { return (_data_count == 0); }\n    iterator begin() const noexcept {\n        return _buckets->empty() ? iterator(increment(_buckets)) : iterator(_buckets);\n    }\n    iterator end() const noexcept { return iterator(_buckets + _bucket_count); }\n    iterator find(const _Key& key) const { return iterator(_find(key)); }\n    size_t count(const _Key& key) const { return (_find(key) != _buckets + _bucket_count); }\n    iterator insert(const _Key& key){ return iterator(find_insert(key)); }\n    iterator insert(_Key&& key){ return iterator(find_insert(move(key))); }\n    iterator erase(const _Key& key){ return iterator(erase_key(key)); }\n    iterator erase(const iterator& itr){ return iterator(erase_itr(itr.bucket_ptr)); }\n    void simple_erase(const _Key& key){ erase_key(key, false); }\n    void simple_erase(const iterator& itr){ erase_itr(itr.bucket_ptr, false); }\n \n    // DEBUG 用\n    short int maximum_distance() const noexcept {\n        short int ret = -1;\n        for(bucket *cur = _buckets; !cur->_end; ++cur){\n            ret = max(ret, cur->_dist);\n        }\n        return ret;\n    }\n};\n \ntemplate<class _Key, class _Hash, bool DOWNSIZE>\nclass UnorderedSetIterator {\nprivate:\n    friend UnorderedSet<_Key, _Hash, DOWNSIZE>;\n    typename UnorderedSet<_Key, _Hash, DOWNSIZE>::bucket *bucket_ptr;\n    using iterator_category = forward_iterator_tag;\n    using value_type = _Key;\n    using difference_type = ptrdiff_t;\n    using pointer = _Key*;\n    using reference = _Key&;\n \nprivate:\n    UnorderedSetIterator(typename UnorderedSet<_Key, _Hash, DOWNSIZE>::bucket *_bucket_ptr)\n        noexcept : bucket_ptr(_bucket_ptr){}\npublic:\n    UnorderedSetIterator() noexcept : bucket_ptr(){}\n    UnorderedSetIterator(const UnorderedSetIterator& itr) noexcept : bucket_ptr(itr.bucket_ptr){}\n    UnorderedSetIterator& operator=(const UnorderedSetIterator& itr)\n        & noexcept { return bucket_ptr = itr.bucket_ptr, *this; }\n    UnorderedSetIterator& operator=(const UnorderedSetIterator&& itr)\n        & noexcept { return bucket_ptr = itr.bucket_ptr, *this; }\n    reference operator*() const noexcept { return bucket_ptr->_key; }\n    pointer operator->() const noexcept { return &(bucket_ptr->_key); }\n    UnorderedSetIterator& operator++() noexcept {\n        return bucket_ptr = UnorderedSet<_Key, _Hash, DOWNSIZE>::increment(bucket_ptr), *this;\n    }\n    UnorderedSetIterator operator++(int) const noexcept {\n        return UnorderedSetIterator(UnorderedSet<_Key, _Hash, DOWNSIZE>::increment(this->bucket_ptr));\n    }\n    bool operator==(const UnorderedSetIterator& itr) const noexcept { return !(*this != itr); };\n    bool operator!=(const UnorderedSetIterator& itr) const noexcept { return bucket_ptr != itr.bucket_ptr; }\n};\n \ntemplate<class _Key, class _Tp, class _Hash, bool DOWNSIZE> class UnorderedMapIterator;\n \ntemplate<class _Key, class _Tp, class _Hash = hash<_Key>, bool DOWNSIZE = false>\nclass UnorderedMap\n{\nprivate:\n    using iterator = UnorderedMapIterator<_Key, _Tp, _Hash, DOWNSIZE>;\n    using value_type = _Tp;\n    using data_type = pair<_Key, _Tp>;\n    using aligned_pointer = typename aligned_storage<sizeof(value_type), alignof(value_type)>::type;\n    friend UnorderedMapIterator<_Key, _Tp, _Hash, DOWNSIZE>;\n    struct bucket {\n        _Key _key;\n        short int _dist;\n        bool _last, _end;\n        aligned_pointer _value_ptr;\n        bucket() noexcept : _dist(-1), _last(false), _end(false){}\n        bucket& operator=(const bucket& another) noexcept {\n            _key = another._key, _dist = another._dist, _last = another._last, _end = another._end;\n            if(!another.empty()){\n                new(&_value_ptr) value_type(*reinterpret_cast<const value_type*>(&another._value_ptr));\n            }\n            return *this;\n        }\n        ~bucket(){ if(!empty()) _delete(); }\n        inline void clear() noexcept { _dist = -1; }\n        inline void _delete(){ _dist = -1, value_ptr()->~value_type(); }\n        inline bool empty() const noexcept { return (_dist == -1); }\n        inline value_type& value() noexcept {\n            return *reinterpret_cast<value_type*>(&_value_ptr);\n        }\n        inline value_type* value_ptr() noexcept {\n            return reinterpret_cast<value_type*>(&_value_ptr);\n        }\n        inline void new_value(value_type&& value){\n            new(&_value_ptr) value_type(move(value));\n        }\n    };\n    inline static unsigned int ceilpow2(unsigned int u) noexcept {\n        --u, u |= u >> 1, u |= u >> 2, u |= u >> 4, u |= u >> 8;\n        return (u | (u >> 16)) + 1;\n    }\n    inline static bucket *increment(bucket *cur) noexcept {\n        for(++cur; !cur->_end; ++cur){\n            if(!cur->empty()) break;\n        }\n        return cur;\n    }\n    inline bucket *next_bucket(bucket *cur) const noexcept {\n        return cur->_last ? _buckets : cur + 1;\n    }\n    inline unsigned int make_hash(const _Key& key) const noexcept {\n        return _Hash()(key);\n    }\n    inline float load_rate() const noexcept {\n        return (float)_data_count / _bucket_count;\n    }\n    bucket *insert(bucket *cur, _Key&& key, short int dist, value_type&& value){\n        bucket *ret = cur;\n        bool flag = false;\n        while(true){\n            if(cur->empty()){\n                cur->_key = move(key), cur->_dist = dist, cur->new_value(move(value));\n                if(!flag) ret = cur, flag = true;\n                break;\n            }else if(dist > cur->_dist){\n                swap(key, cur->_key), swap(dist, cur->_dist), swap(value, cur->value());\n                if(!flag) ret = cur, flag = true;\n            }\n            ++dist;\n            cur = next_bucket(cur);\n        }\n        return ret;\n    }\n    template<class Key>\n    bucket *_find(Key&& key, bool push = false){\n        unsigned int hash = make_hash(key);\n        bucket *cur = _buckets + (hash & _mask);\n        short int dist = 0;\n        while(dist <= cur->_dist){\n            if(key == cur->_key) return cur;\n            ++dist, cur = next_bucket(cur);\n        }\n        if(!push) return _buckets + _bucket_count;\n        ++_data_count;\n        if(rehash_check()){\n            cur = _buckets + (hash & _mask), dist = 0;\n        }\n        value_type new_value = value_type();\n        _Key new_key = forward<Key>(key);\n        return insert(cur, move(new_key), dist, move(new_value));\n    }\n    template<class Data>\n    bucket *find_insert(Data&& data){\n        const _Key& key = data.first;\n        unsigned int hash = make_hash(key);\n        bucket *cur = _buckets + (hash & _mask);\n        short int dist = 0;\n        while(dist <= cur->_dist){\n            if(key == cur->_key) return cur;\n            ++dist, cur = next_bucket(cur);\n        }\n        ++_data_count;\n        if(rehash_check()){\n            cur = _buckets + (hash & _mask), dist = 0;\n        }\n        data_type new_data = forward<Data>(data);\n        return insert(cur, move(new_data.first), dist, move(new_data.second));\n    }\n    bucket *backward_shift(bucket *cur, bool next_ret){\n        bucket *next = next_bucket(cur), *ret = cur;\n        if(next->_dist < 1) return next_ret ? increment(cur) : cur;\n        do {\n            cur->_key = next->_key, cur->_dist = next->_dist - 1;\n            cur->new_value(move(next->value()));\n            cur = next, next = next_bucket(cur);\n        }while(next->_dist >= 1);\n        cur->clear();\n        return ret;\n    }\n    bucket *erase_impl(bucket *cur, bool next_ret){\n        assert(static_cast<size_t>(cur - _buckets) != _bucket_count);\n        cur->_delete();\n        --_data_count;\n        return backward_shift(cur, next_ret);\n    }\n    bucket *erase_itr(bucket *cur, bool next_ret = true){\n        const _Key& key = cur->_key;\n        return erase_impl(rehash_check() ? _find(key) : cur, next_ret);\n    }\n    bucket *erase_key(const _Key& key, bool next_ret = true){\n        rehash_check();\n        return erase_impl(_find(key), next_ret);\n    }\n    bool rehash_check(){\n        if(load_rate() >= MAX_LOAD_RATE){\n            rehash(_bucket_count * 2u);\n            return true;\n        }else if(DOWNSIZE){\n            if(load_rate() <= MIN_LOAD_RATE && _bucket_count >= DOWNSIZE_THRESHOLD){\n                rehash(_bucket_count / 2u);\n                return true;\n            }\n        }\n        return false;\n    }\n    void move_data(bucket *cur){\n        insert(_buckets + (make_hash(cur->_key) & _mask), move(cur->_key), 0, move(cur->value()));\n    }\n    void rehash(unsigned int new_bucket_count){\n        UnorderedMap new_unordered_map(new_bucket_count);\n        new_unordered_map._data_count = _data_count;\n        for(bucket *cur = _buckets; !cur->_end; ++cur){\n            if(!cur->empty()){\n                new_unordered_map.move_data(cur);\n            }\n        }\n        swap(*this, new_unordered_map);\n    }\n    friend void swap(UnorderedMap& ump1, UnorderedMap& ump2){\n        swap(ump1._bucket_count, ump2._bucket_count);\n        swap(ump1._mask, ump2._mask);\n        swap(ump1._data_count, ump2._data_count);\n        swap(ump1._buckets, ump2._buckets);\n    }\n \nprivate:\n    unsigned int _bucket_count, _mask, _data_count;\n    bucket *_buckets;\npublic:\n    const float MAX_LOAD_RATE = 0.5f;\n    const float MIN_LOAD_RATE = 0.1f;\n    const unsigned int DOWNSIZE_THRESHOLD = 16u;\n    UnorderedMap(unsigned int bucket_size = 1u)\n     : _bucket_count(ceilpow2(max(bucket_size, 1u))), _mask(_bucket_count - 1),\n        _data_count(0u), _buckets(new bucket[_bucket_count + 1]){\n        _buckets[_bucket_count - 1]._last = true, _buckets[_bucket_count]._end = true;\n    }\n    UnorderedMap(const UnorderedMap& another)\n        : _bucket_count(another._bucket_count), _mask(another._mask), _data_count(another._data_count){\n        _buckets = new bucket[_bucket_count + 1u];\n        for(unsigned int i = 0u; i <= _bucket_count; ++i){\n            _buckets[i] = another._buckets[i];\n        }\n    }\n    UnorderedMap(UnorderedMap&& another)\n        : _bucket_count(move(another._bucket_count)), _mask(move(another._mask)),\n            _data_count(move(another._data_count)), _buckets(another._buckets){\n        another._buckets = nullptr;\n    }\n    UnorderedMap& operator=(const UnorderedMap& another){\n        delete[] _buckets;\n        _bucket_count = another._bucket_count;\n        _mask = another._mask;\n        _data_count = another._data_count;\n        _buckets = new bucket[_bucket_count + 1u];\n        for(unsigned int i = 0u; i <= _bucket_count; ++i){\n            _buckets[i] = another._buckets[i];\n        }\n        return *this;\n    }\n    UnorderedMap& operator=(UnorderedMap&& another){\n        delete[] _buckets;\n        _bucket_count = move(another._bucket_count);\n        _mask = move(another._mask);\n        _data_count = move(another._data_count);\n        _buckets = another._buckets;\n        another._buckets = nullptr;\n        return *this;\n    }\n    ~UnorderedMap(){ delete[] _buckets; }\n    friend ostream& operator<< (ostream& os, UnorderedMap& ump) noexcept {\n        for(auto val : ump) os << '{' << val.first << ',' << val.second << \"} \";\n        return os;\n    }\n    _Tp& operator[](const _Key& key){ return _find(key, true)->value(); }\n    _Tp& operator[](_Key&& key){ return _find(move(key), true)->value(); }\n    const _Tp& at(const _Key& key){\n        bucket *res = _find(key);\n        if(res == _buckets + _bucket_count) __throw_out_of_range(__N(\"Unordered_Map::at\"));\n        return res->value();\n    }\n    void clear(){\n        UnorderedMap new_unordered_map(1u);\n        swap(*this, new_unordered_map);\n    }\n    size_t size() const noexcept { return _data_count; }\n    size_t bucket_count() const noexcept { return _bucket_count; }\n    bool empty() const noexcept { return (_data_count == 0); }\n    iterator begin() const noexcept { return _buckets->empty() ? iterator(increment(_buckets)) : iterator(_buckets); }\n    iterator end() const noexcept { return iterator(_buckets + _bucket_count); }\n    iterator find(const _Key& key){ return iterator(_find(key)); }\n    iterator insert(const data_type& data){ return iterator(find_insert(data)); }\n    iterator insert(data_type&& data){ return iterator(find_insert(move(data))); }\n    iterator erase(const _Key& key){ return iterator(erase_key(key)); }\n    iterator erase(const iterator& itr){ return iterator(erase_itr(itr.bucket_ptr)); }\n    void simple_erase(const _Key& key){ erase_key(key, false); }\n    void simple_erase(const iterator& itr){ erase_itr(itr.bucket_ptr, false); }\n \n    // DEBUG 用\n    short int maximum_distance() const noexcept {\n        short int ret = -1;\n        for(bucket *cur = _buckets; !cur->_end; ++cur){\n            ret = max(ret, cur->_dist);\n        }\n        return ret;\n    }\n};\n \ntemplate<class _Key, class _Tp, class _Hash, bool DOWNSIZE>\nclass UnorderedMapIterator {\nprivate:\n    friend UnorderedMap<_Key, _Tp, _Hash, DOWNSIZE>;\n    typename UnorderedMap<_Key, _Tp, _Hash, DOWNSIZE>::bucket *bucket_ptr;\n    using iterator_category = forward_iterator_tag;\n    using value_type = pair<const _Key, _Tp>;\n    using difference_type = ptrdiff_t;\n    using reference = pair<const _Key&, _Tp&>;\n \nprivate:\n    UnorderedMapIterator(typename UnorderedMap<_Key, _Tp, _Hash, DOWNSIZE>::bucket *_bucket_ptr)\n        noexcept : bucket_ptr(_bucket_ptr){}\npublic:\n    UnorderedMapIterator() noexcept : bucket_ptr(){}\n    UnorderedMapIterator(const UnorderedMapIterator& itr) noexcept : bucket_ptr(itr.bucket_ptr){}\n    UnorderedMapIterator& operator=(const UnorderedMapIterator& itr)\n        & noexcept { return bucket_ptr = itr.bucket_ptr, *this; }\n    UnorderedMapIterator& operator=(const UnorderedMapIterator&& itr)\n        & noexcept { return bucket_ptr = itr.bucket_ptr, *this; }\n    reference operator*() const noexcept { return {bucket_ptr->_key, bucket_ptr->value()}; }\n    UnorderedMapIterator& operator++() noexcept {\n        return bucket_ptr = UnorderedMap<_Key, _Tp, _Hash, DOWNSIZE>::increment(bucket_ptr), *this;\n    }\n    UnorderedMapIterator operator++(int) const noexcept {\n        return UnorderedMapIterator(UnorderedMap<_Key, _Tp, _Hash, DOWNSIZE>::increment(this->bucket_ptr));\n    }\n    bool operator==(const UnorderedMapIterator& itr) const noexcept { return !(*this != itr); };\n    bool operator!=(const UnorderedMapIterator& itr) const noexcept { return bucket_ptr != itr.bucket_ptr; }\n};\n \n// 多重辺は無いと仮定する\nclass BSTNode {\npublic:\n    struct murmur_hash32 {\n        unsigned int operator()(int p) const {\n            const unsigned int m = 0x5bd1e995; p *= m;\n            unsigned int h = (p^(p>>24))*m;\n            return h = (h^(h>>13))*m, (h^(h>>15));\n        }\n    };\n    const int from, to;\n    int sz;\n    bool subtree_edge, subofftree_edge, exact_level;\n    BSTNode *left, *right, *par;\n    UnorderedSet<int, murmur_hash32, true> adjacent;\n    BSTNode(const int _ver) noexcept :\n        from(_ver), to(_ver), sz(0), subtree_edge(false), subofftree_edge(false),\n            exact_level(false), left(nullptr), right(nullptr), par(nullptr){}\n    BSTNode(const int _from, const int _to, const bool _flag) noexcept :\n        from(_from), to(_to), sz(0), subtree_edge(false), subofftree_edge(false),\n            exact_level((from < to) && _flag), left(nullptr), right(nullptr), par(nullptr){}\n    inline bool IsRoot() const noexcept { return !par; }\n    inline bool IsVertex() const noexcept { return (from == to); }\n    inline void eval() noexcept {\n        if(IsVertex()) sz = 1, subtree_edge = false, subofftree_edge = !adjacent.empty();\n        else sz = 0, subtree_edge = exact_level, subofftree_edge = false;\n        if(left){\n            sz += left->sz, subtree_edge |= left->subtree_edge, subofftree_edge |= left->subofftree_edge;\n        }\n        if(right){\n            sz += right->sz, subtree_edge |= right->subtree_edge, subofftree_edge |= right->subofftree_edge;\n        }\n    }\n    inline void subtree_edge_eval(){\n        subtree_edge = exact_level;\n        if(left) subtree_edge |= left->subtree_edge;\n        if(right) subtree_edge |= right->subtree_edge;\n    }\n    inline void subofftree_edge_eval(){\n        subofftree_edge = !adjacent.empty();\n        if(left) subofftree_edge |= left->subofftree_edge;\n        if(right) subofftree_edge |= right->subofftree_edge;\n    }\n    inline bool subofftree_check(){\n        return !adjacent.empty() ||\n                (left ? left->subofftree_edge : false) || (right ? right->subofftree_edge : false);\n    }\n    inline bool offtree_check(){\n        return adjacent.empty() ||\n                (left ? left->subofftree_edge : false) || (right ? right->subofftree_edge : false);\n    }\n    void rotate(const bool right_) noexcept {\n        BSTNode *p = par, *g = p->par;\n        if(right_){\n            if((p->left = right)) right->par = p;\n            right = p, p->par = this;\n        }else{\n            if((p->right = left)) left->par = p;\n            left = p, p->par = this;\n        }\n        p->eval(), eval();\n        if(!(par = g)) return;\n        if(g->left == p) g->left = this;\n        if(g->right == p) g->right = this;\n        g->eval();\n    }\n};\n \nBSTNode *splay(BSTNode *u) noexcept {\n    if(!u) return nullptr;\n    while(!(u->IsRoot())){\n        BSTNode *p = u->par, *gp = p->par;\n        if(p->IsRoot()){ // zig\n            u->rotate((u == p->left));\n        }else{\n            bool flag = (u == p->left);\n            if((u == p->left) == (p == gp->left)){ // zig-zig\n                p->rotate(flag), u->rotate(flag);\n            }else{ // zig-zag\n                u->rotate(flag), u->rotate(!flag);\n            }\n        }\n    }\n    return u;\n}\n \nBSTNode *join(BSTNode *root1, BSTNode *root2) noexcept {\n    if(!root1 || !root2) return root1 ? root1 : root2;\n    BSTNode *cur = nullptr, *nx = root1;\n    do{ cur = nx, nx = cur->right; }while(nx);\n    BSTNode *ver = splay(cur);\n    ver->right = root2, ver->eval(), root2->par = ver;\n    return ver;\n}\n \nclass EulerTourTree {\npublic:\n    struct murmur_hash64 {\n        unsigned long long operator()(unsigned long long p) const {\n            const unsigned long long m = 0xc6a4a7935bd1e995; p *= m;\n            unsigned long long h = (p^(p>>47))*m;\n            return h = (h^(h>>47))*m, (h^(h>>47));\n        }\n    };\n    inline static unsigned long long pair_to_ll(const int u, const int v){\n        return ((unsigned long long)(u) << 32) | v;\n    }\n    BSTNode** vertex_set;\n    UnorderedMap<unsigned long long, pair<BSTNode*, BSTNode*>, murmur_hash64> edge_set;\nprivate:\n    BSTNode *reroot(BSTNode *ver) noexcept {\n        BSTNode *res = splay(ver)->left;\n        if(!res) return ver;\n        ver->left = nullptr, ver->eval();\n        while(ver->right) ver = ver->right;\n        splay(ver), ver->right = res, ver->eval(), res->par = ver;\n        return ver;\n    }\n    void link(BSTNode *ver1, BSTNode *ver2, const bool flag) noexcept {\n        BSTNode *e1 = new BSTNode(ver1->from, ver2->from, flag);\n        BSTNode *e2 = new BSTNode(ver2->from, ver1->from, flag);\n        edge_set[pair_to_ll(ver1->from, ver2->from)] = {e1, e2};\n        join(join(reroot(ver1), e1), join(reroot(ver2), e2));\n    }\n    void cut(BSTNode *edge1, BSTNode *edge2) noexcept {\n        splay(edge1), splay(edge2);\n        BSTNode *p = edge1->par;\n        bool _right = (edge1 == edge2->right);\n        if(p != edge2){\n            _right = (p == edge2->right);\n            p->par = nullptr, edge1->rotate((edge1 == p->left));\n        }\n        if(edge1->left) edge1->left->par = nullptr;\n        if(edge1->right) edge1->right->par = nullptr;\n        if(_right){\n            if(edge2->left) edge2->left->par = nullptr;\n            join(edge2->left, edge1->right);\n        }else{\n            if(edge2->right) edge2->right->par = nullptr;\n            join(edge1->left, edge2->right);\n        }\n        // delete edge1; delete edge2;\n    }\n    bool connected(BSTNode *ver1, BSTNode *ver2) noexcept {\n        splay(ver1), splay(ver2);\n        return ver1->par;\n    }\n    int component_size(BSTNode *ver) noexcept { return splay(ver)->sz; }\npublic:\n    int V;\n    EulerTourTree(){}\n    // ~EulerTourTree(){\n    //     for(auto it : edge_set){\n    //         delete (it.second).first;\n    //         delete (it.second).second;\n    //     }\n    //     for(int i = 0; i < V; ++i) delete vertex_set[i];\n    //     delete[] vertex_set;\n    // }\n    void resize(const int node_size) noexcept {\n        V = node_size, vertex_set = new BSTNode*[V];\n        for(int i = 0; i < V; i++) vertex_set[i] = new BSTNode(i);\n    }\n    void reroot(const int node_id) noexcept { reroot(vertex_set[node_id]); }\n    void link(int node1_id, int node2_id, bool flag=true) noexcept {\n        if(node1_id > node2_id) swap(node1_id, node2_id);\n        link(vertex_set[node1_id], vertex_set[node2_id], flag);\n    }\n    void cut(int node1_id, int node2_id){\n        if(node1_id > node2_id) swap(node1_id, node2_id);\n        auto it = edge_set.find(pair_to_ll(node1_id, node2_id));\n        assert(it != edge_set.end());\n        BSTNode *edge1 = ((*it).second).first, *edge2 = ((*it).second).second;\n        edge_set.simple_erase(it);\n        cut(edge1, edge2);\n    }\n    bool connected(const int node1_id, const int node2_id) noexcept {\n        if(node1_id == node2_id) return true;\n        return connected(vertex_set[node1_id], vertex_set[node2_id]);\n    }\n    int component_size(int node_id) noexcept { return component_size(vertex_set[node_id]); }\n    void check_dfs(const BSTNode* cur) const noexcept {\n        if(cur->left) check_dfs(cur->left);\n        cout << \"{\" << (cur->from) << \",\" << (cur->to) << \"} \";\n        if(cur->right) check_dfs(cur->right);\n    }\n};\n \nclass DynamicConnectivity {\nprivate:\n    BSTNode *level_up_dfs(BSTNode *cur, const int layer) noexcept {\n        if(cur->exact_level){\n            splay(cur)->exact_level = false, cur->subtree_edge_eval();\n            detect_layer[EulerTourTree::pair_to_ll(cur->from, cur->to)]++;\n            et[layer+1].link(cur->from, cur->to);\n            return cur;\n        }\n        if(cur->left && cur->left->subtree_edge) return level_up_dfs(cur->left, layer);\n        if(cur->right && cur->right->subtree_edge) return level_up_dfs(cur->right, layer);\n        return nullptr;\n    }\n    BSTNode *search_edge_dfs\n        (BSTNode *cur, const int layer, const int another, bool& flag, pair<int, int>& rep_edge) noexcept {\n        if(!cur->adjacent.empty()){\n            bool state = et[layer+1].vertex_set[cur->from]->adjacent.empty();\n            for(auto it = cur->adjacent.begin(); it != cur->adjacent.end();){\n                pair<int, int> e = {min(cur->from, *it), max(cur->from, *it)};\n                BSTNode *correspond = et[layer].vertex_set[*it];\n                if(et[layer].connected(another, *it)){\n                    flag = true, rep_edge = e;\n                    cur->adjacent.simple_erase(it), correspond->adjacent.simple_erase(cur->from);\n                    if(!correspond->subofftree_check()){\n                        splay(correspond)->subofftree_edge_eval();\n                    }\n                    break;\n                }else{\n                    if(!et[layer+1].vertex_set[*it]->subofftree_check()){\n                        splay(et[layer+1].vertex_set[*it])->subofftree_edge = true;\n                    }\n                    et[layer+1].vertex_set[cur->from]->adjacent.insert(*it);\n                    et[layer+1].vertex_set[*it]->adjacent.insert(cur->from);\n                    detect_layer[EulerTourTree::pair_to_ll(e.first, e.second)]++;\n                    it = cur->adjacent.erase(it);\n                    correspond->adjacent.simple_erase(cur->from);\n                    if(!correspond->subofftree_check()){\n                        splay(correspond)->subofftree_edge_eval();\n                    }\n                }\n            }\n            if(state && !et[layer+1].vertex_set[cur->from]->offtree_check()){\n                splay(et[layer+1].vertex_set[cur->from])->subofftree_edge = true;\n            }\n            splay(cur)->subofftree_edge_eval();\n            return cur;\n        }\n        if(cur->left && cur->left->subofftree_edge){\n            return search_edge_dfs(cur->left, layer, another, flag, rep_edge);\n        }\n        if(cur->right && cur->right->subofftree_edge){\n            return search_edge_dfs(cur->right, layer, another, flag, rep_edge);\n        }\n        return nullptr;\n    }\n    bool replace(const int from, const int to, const int layer) noexcept {\n        if(layer < 0) return true;\n        int u, v;\n        if(et[layer].component_size(from) <= et[layer].component_size(to)) u = from, v = to;\n        else u = to, v = from;\n        BSTNode *ver = splay(et[layer].vertex_set[u]);\n        while(ver->subtree_edge) ver = level_up_dfs(ver, layer);\n        pair<int, int> rep_edge = {-1, -1};\n        bool flag = false;\n        while(ver->subofftree_edge){\n            ver = search_edge_dfs(ver, layer, v, flag, rep_edge);\n            if(flag) break;\n        }\n        if(flag){\n            et[layer].link(rep_edge.first, rep_edge.second);\n            for(int i = 0; i < layer; i++) et[i].link(rep_edge.first, rep_edge.second, false);\n            return false;\n        }else return replace(from, to, layer-1);\n    }\npublic:\n    const int V, layer_count;\n    EulerTourTree* et;\n    UnorderedMap<unsigned long long, int, EulerTourTree::murmur_hash64> detect_layer;\n    DynamicConnectivity(int node_size) noexcept : V(node_size), layer_count(ceil(log2(V))+1){\n        et = new EulerTourTree[layer_count];\n        for(int i = 0; i < layer_count; i++) et[i].resize(V);\n    }\n    // ~DynamicConnectivity(){\n    //     delete[] et;\n    // }\n    bool link(int node1_id, int node2_id) noexcept {\n        if(node1_id > node2_id) swap(node1_id, node2_id);\n        detect_layer[EulerTourTree::pair_to_ll(node1_id, node2_id)] = 0;\n        if(et[0].connected(node1_id, node2_id)){\n            BSTNode *ver1 = et[0].vertex_set[node1_id], *ver2 = et[0].vertex_set[node2_id];\n            splay(ver1)->subofftree_edge = true, ver1->adjacent.insert(node2_id);\n            splay(ver2)->subofftree_edge = true, ver2->adjacent.insert(node1_id);\n            return false;\n        }else{\n            et[0].link(node1_id, node2_id);\n            return true;\n        }\n    }\n    bool cut(int node1_id, int node2_id) noexcept {\n        if(node1_id > node2_id) swap(node1_id, node2_id);\n        auto it = detect_layer.find(EulerTourTree::pair_to_ll(node1_id, node2_id));\n        assert(it != detect_layer.end());\n        int layer = (*it).second;\n        detect_layer.simple_erase(it);\n        auto& st = et[layer].vertex_set[node1_id]->adjacent;\n        if(st.find(node2_id) == st.end()){\n            for(int i = 0; i <= layer; i++) et[i].cut(node1_id, node2_id);\n            return replace(node1_id, node2_id, layer);\n        }else{\n            et[layer].vertex_set[node1_id]->adjacent.simple_erase(node2_id);\n            if(!et[layer].vertex_set[node1_id]->subofftree_check()){\n                splay(et[layer].vertex_set[node1_id])->subofftree_edge_eval();\n            }\n            et[layer].vertex_set[node2_id]->adjacent.simple_erase(node1_id);\n            if(!et[layer].vertex_set[node2_id]->subofftree_check()){\n                splay(et[layer].vertex_set[node2_id])->subofftree_edge_eval();\n            }\n            return false;\n        }\n    }\n    bool connected(const int node1_id, const int node2_id) noexcept {\n        return et[0].connected(node1_id, node2_id);\n    }\n};\n\nvector<int>a;\nvector<int> calc(pii e_min,vector<vector<int> > &g,set<int> &st,DynamicConnectivity &dc){\n    vector<int> res;\n    res.push_back(e_min.first);\n    if(st.size()==1){\n        return res;\n    }\n    int id = e_min.second;\n    vector<pii> v;\n    st.erase(id);\n    for(auto x:g[id]){\n        if(st.count(x)==1){\n            dc.cut(id,x);\n            v.push_back(MP(a[x],x));\n        }\n    }\n    sort(v.begin(),v.end());\n    vector<vector<int> > ss;\n    for(auto x:v){\n        if(st.count(x.second)==0)continue;\n        set<int> p;\n        for(auto y:st){\n            if(dc.connected(x.second,y)){\n                p.insert(y);\n            }\n        }\n        for(auto y:p){\n            st.erase(y);\n        }\n        ss.push_back(calc(x,g,p,dc));\n    }\n    priority_queue<pair<int,pii > > pp;\n    int m = ss.size();\n    rep(i,m){\n        pp.push(MP(ss[i][0],MP(i,0)));\n    }\n    while(!pp.empty()){\n        auto x = pp.top();\n        pp.pop();\n        res.push_back(x.first);\n        if(ss[x.second.first].size()!=x.second.second+1){\n            pp.push(MP(ss[x.second.first][x.second.second+1],MP(x.second.first,x.second.second+1)));\n        }\n    }\n    return res;\n}\n\nint main(){\n    int n;\n    cin >> n;\n    a.resize(n);\n    \n    rep(i,n){\n        cin >> a[i];\n    }\n    DynamicConnectivity dc(n);\n    vector<vector<int> > g(n);\n    UnionFind uf(n);\n    rep(i,n){\n        for(int j=i+1;j<n;j++){\n            if(gcd(a[i],a[j])!=1){\n                g[i].push_back(j);\n                g[j].push_back(i);\n                dc.link(i,j);\n                uf.unite(i,j);\n            }\n        }\n    }\n    vector<pair<int,int> > p(n,MP(inf,inf));\n    vector<set<int> > st(n);\n    rep(i,n){\n        p[uf.find(i)] = min(MP(a[i],i),p[uf.find(i)]);\n        st[uf.find(i)].insert(i);\n    }\n    vector<bool> used(n);\n    vector<vector<int> > res;\n    rep(i,n){\n        if(!used[uf.find(i)]){\n            int k = uf.find(i);\n            used[k] = 1;\n            auto ss = p[k];\n            res.push_back(calc(ss,g,st[k],dc));\n        }\n    }\n    priority_queue<pair<int,pii > > pp;\n    int m = res.size();\n    rep(i,m){\n        pp.push(MP(res[i][0],MP(i,0)));\n    }\n    vector<int> ans;\n    while(!pp.empty()){\n        auto x = pp.top();\n        pp.pop();\n        ans.push_back(x.first);\n        if(res[x.second.first].size()!=x.second.second+1){\n            pp.push(MP(res[x.second.first][x.second.second+1],MP(x.second.first,x.second.second+1)));\n        }\n    }\n    for(auto x:ans){\n        cout << x << \" \";\n    }\n    cout << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<utility>\nint gcd(int a, int b) {\n\tif (a < b) return gcd(b, a);\n\tif (a%b == 0) return b;\n\treturn gcd(b, a%b);\n}\n\nint main() {\n\tint i, j, n;\n\tint *a;\n\tscanf(\"%d\",&n);\n\ta = (int*)malloc(sizeof(int)*n);\n\n\tfor (i = 0; i < n; i++) {\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\n\tfor (i = 0; i < n; i++) {\n\t\tfor (j = 0; j < n-1 ; j++) {\n\t\t\tif (a[j] > a[j + 1]) std::swap(a[j],a[j+1]);\n\t\t}\n\t}\n\n\tfor (i = n; i >= 0; i--) {\n\t\tfor (j = n; j >= 1; j--) {\n\t\t\tif (gcd(a[j], a[j - 1]) == 1) std::swap(a[j], a[j - 1]);\n\t\t}\n\t}\n\n\tfor (i = 0; i < n; i++) {\n\t\tprintf(\"%d\",a[i]);\n\t\tif (i != n) printf(\" \");\n\t\telse printf(\"\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nconst int MAXN = 2000;\nint n , a[ MAXN + 5 ] , In[ MAXN + 5 ];\nbool vis[ MAXN + 5 ];\nvector< int > Graph[ MAXN + 5 ];\nvector< int > DAG[ MAXN + 5 ];\n\nvoid Make_Graph( ) {\n\tfor( int i = 1 ; i <= n ; i ++ )\n\t\tfor( int j = i + 1 ; j <= n ; j ++ )\n\t\t\tif( __gcd( a[ i ] , a[ j ] ) != 1 ) {\n\t\t\t\tGraph[ i ].push_back( j );\n\t\t\t\tGraph[ j ].push_back( i );\n\t\t\t}\n}\nvoid dfs( int u ) {\n\tvis[ u ] = 1;\n\tfor( int i = 0 ; i < Graph[ u ].size( ) ; i ++ ) {\n\t\tint v = Graph[ u ][ i ];\n\t\tif( vis[ v ] ) continue;\n\t\tDAG[ u ].push_back( v ); In[ v ] ++;\n\t\tdfs( v );\n\t}\n}\nvoid Make_DAG( ) {\n\tfor( int i = 1 ; i <= n ; i ++ )\n\t\tif( !vis[ i ] ) dfs( i );\n}\nvoid Topo( ) {\n\tpriority_queue< int > Que;\n\tfor( int i = 1 ; i <= n ; i ++ )\n\t\tif( !In[ i ] ) Que.push( i );\n\t\n\twhile( !Que.empty( ) ) {\n\t\tint u = Que.top( ); Que.pop( );\n\t\tprintf(\"%d \", a[ u ] );\n\t\tfor( int i = 0 ; i < DAG[ u ].size( ) ; i ++ ) {\n\t\t\tint v = DAG[ u ][ i ];\n\t\t\tif( -- In[ v ] == 0 )\n\t\t\t\tQue.push( v );\n\t\t}\n\t}\n}\n\nint main( ) {\n\tscanf(\"%d\",&n);\n\tfor( int i = 1 ; i <= n ; i ++ )\n\t\tscanf(\"%d\",&a[ i ]);\n\tsort( a + 1 , a + n + 1 );\n\n\tMake_Graph( );\n\tMake_DAG( );\n\n\tTopo( );\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=2005;\nint n,a[N],d[N],vis[N];vector<int>g[N];\nvoid dfs(int k1){\n\tvis[k1]=1;\n\tfor(int i=1;i<=n;++i)if(!vis[i]&&__gcd(a[k1],a[i])>1)g[k1].push_back(i),++d[i],dfs(i);\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;++i)scanf(\"%d\",&a[i]);\n\tsort(a+1,a+1+n);\n\tfor(int i=1;i<=n;++i)if(!vis[i])dfs(i);\n\tfor(int i=1;i<=n;++i)for(int j=n;j>=1;--j)if(!d[j]){\n\t\tprintf(\"%d \",a[j]);for(auto k:g[j])--d[k];\n\t\td[j]=-1;break;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ADD(a, b) a = (a + ll(b)) % mod\n#define MUL(a, b) a = (a * ll(b)) % mod\n#define MAX(a, b) a = max(a, b)\n#define MIN(a, b) a = min(a, b)\n#define rep(i, a, b) for(int i = int(a); i < int(b); i++)\n#define rer(i, a, b) for(int i = int(a) - 1; i >= int(b); i--)\n#define all(a) (a).begin(), (a).end()\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sec second\n#define fst first\n#define debug(fmt, ...) Debug(__LINE__, \":\", fmt, ##__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<int, pi> ppi;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vl> mat;\ntypedef complex<double> comp;\nvoid Debug() {cout << '\\n'; }\ntemplate<class FIRST, class... REST>void Debug(FIRST arg, REST... rest){\n\tcout<<arg<<\" \";Debug(rest...);}\ntemplate<class T>ostream& operator<<(ostream& out,const vector<T>& v) {\n\tout<<\"[\";if(!v.empty()){rep(i,0,sz(v)-1)out<<v[i]<<\", \";out<<v.back();}out<<\"]\";return out;}\ntemplate<class S, class T>ostream& operator<<(ostream& out,const pair<S, T>& v){\n\tout<<\"(\"<<v.first<<\", \"<<v.second<<\")\";return out;}\nconst int MAX_N = 2010;\nconst int MAX_V = 100010;\nconst double eps = 1e-6;\nconst ll mod = 1000000007;\nconst int inf = 1 << 29;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\nll gcd(ll a, ll b) {\n\tif(b == 0) return a;\n\telse return gcd(b, a % b);\n}\n\nint N;\nbool on[MAX_N], used[MAX_N];\nbool deleted[MAX_N];\nint A[MAX_N];\nvector<int> G[MAX_N];\n\nvoid add_edge(int from, int to) {\n\tG[from].pb(to);\n\tG[to].pb(from);\n}\n\nvoid erase_node(int v) {\n\tdeleted[v] = true;\n\trep(i, 0, sz(G[v])) {\n\t\tint n = G[v][i];\n\t\ton[n] = true;\n\t}\n}\n\npi loop(int v, bool only = false) {\n\tused[v] = true;\n\tpi res;\n\tif(!only || on[v]) res = pi(A[v], v);\n\telse res = pi(inf, inf);\n\trep(i, 0, sz(G[v])) {\n\t\tint n = G[v][i];\n\t\tif(!used[n] && !deleted[n]) MIN(res, loop(n, only));\n\t}\n\treturn res;\n}\n\nvoid graph_show() {\n\trep(i, 0, N) {\n\t\tvector<int> res;\n\t\tif(deleted[i]) {\n\t\t\tdebug(A[i], res);\n\t\t\tcontinue;\n\t\t}\n\t\trep(j, 0, sz(G[i])) {\n\t\t\tint n = G[i][j];\n\t\t\tif(deleted[n]) continue;\n\t\t\tres.pb(A[n]);\n\t\t}\n\t\tdebug(A[i], res);\n\t}\n}\n\n\nvoid solve() {\n\tcin >> N;\n\trep(i, 0, N) {\n\t\tcin >> A[i];\n\t}\n\trep(i, 0, N) {\n\t\trep(j, i + 1, N) {\n\t\t\tif(gcd(A[i], A[j]) != 1) {\n\t\t\t\tadd_edge(i, j);\n\t\t\t}\n\t\t}\n\t}\n\n\trep(i, 0, N) {\n\t\tif(!used[i]) {\n\t\t\tpi p = loop(i);\n\t\t\ton[p.sec] = true;\n\t\t}\n\t}\n\tvector<int> ans;\n\trep(q, 0, N) {\n\t\t// debug(vi(on, on + N));\n\t\t// graph_show();\n\t\tint a = -1, at = -1;\n\t\tmemset(used, 0, sizeof(used));\n\t\trep(i, 0, N) {\n\t\t\tif(!used[i] && !deleted[i]) {\n\t\t\t\tpi p = loop(i, true);\n\t\t\t\tif(a < p.fst) {\n\t\t\t\t\ta = p.fst; at = p.sec;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans.pb(a);\n\t\terase_node(at);\n\t}\n\trep(i, 0, N) {\n\t\tcout << ans[i] << \" \";\n\t}\n\tcout << \"\\n\";\n}\n\n\nint main() {\n#ifndef LOCAL\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n\tcout.precision(20);\n\tsrand((unsigned int)time(NULL));\n#ifdef LOCAL\n\t//freopen(\"in.txt\", \"wt\", stdout); //for tester\n    freopen(\"in.txt\", \"rt\", stdin);\n#endif\t\n\tsolve();\n#ifdef LOCAL\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n *                             UM.\n *                            J@B@1                                                                    iO@1\n *                           Y@@@B@BB.                                                              7B@B@B@\n *                          :@B@i,B@B@O                                                          ,Z@B@B@B@Br\n *                          @B@q   i@B@BS                                                      7@B@@@O5vMB@q\n *                         8@@B      LB@B@i                                                  FB@@@BNjYjLE@B@\n *                        ,B@B:        0@@@Z                                               P@B@BM1JJ125JPB@B\n *                        B@BB          :@B@B                                            XB@B@Z2LuU52F2u2@B@.\n *                       :@B@             @@@B:                                        v@B@B8uJj51F1525uUB@B7\n *                       @B@O              0@@B.               ..::ir7vvYUuU777r::.   B@B@OULU2F2F151F11Y@B@S\n *                       B@B,               8B@B  :ruXMB@B@B@B@B@B@B@B@B@B@@@B@B@B@B@B@B@5Jj1211F1F1F2FUJO@BB\n *                      U@B@                 @B@B@B@B@B@@@B@B@B@MMqPS5JuYL7rq@B@OBB@B@B8Yu211F1515251515YGB@@\n *                      @B@u                 v@@@@MSur:.                    LB@MvvjJuU5YU252F1F1F25251F2uX@@@\n *                      @@@.                                                N@BML2U2UUU12F15252525251515Jk@@B\n *                     r@B@                                                 YB@Bju52121252515252F15251F2u5@B@\n *                     PB@B                                                  @@@PYUF151F25151F152F2F1F15jF@@B\n *                     @@BS                                                  N@@@UJ2F25252F251525151F1F1u5@B@\n *                     @@@7                                                   B@B@5Yj12F152F1F1F25252515jFB@B\n *                     B@Bi                                                    M@B@O2Luu52525212F151121UY1@B@7\n *                    O@B@:                                                     v@B@BMSuYJJuuUu2u2uujjYJJXB@B@M\n *                  7B@B@,                                                        1B@@@B@GPF1uujuu21PNMB@B@B@B@@\n *                 qB@B2                                                            i8B@B@B@B@B@@@@@B@B@B@q: @@@B\n *                MB@B:                                                                 7SBB@B@B@B@B@Zu:      @B@B\n *               ZB@B.                                              ,v.                                        @B@L\n *              LB@B,                         Y7                    @B@Bu                                      7@B@\n *   :B@B@@B2:  @@B7                         @B@Z                   r@B@B@BP:                                   B@BE\n *    BB@@@B@B@B@BE                        r@B@B                       7@B@B@B@Ou:                              iB@B\n *         :uM@@B@@2.           :7::::ivk@B@B@0                           :5B@B@B@B@B@B@G.                       @B@i\n *            BB@@@B@@         :@B@B@@@B@B@@1                                 .i5M@B@B@@@5                       M@@2\n *            B@B ,@B1          L0EZZG0F7:                                            .:,                        uB@MrP@M7\n *           2@B@                                                                                               ,O@B@B@B@B\n *           @B@1                                                     :@B@@@r                                :@@@@B@BL:,,\n *           B@Bi                         :2ZS;                      :@B@B@B@r                               L@B@B@BU\n *           @B@.                        @@@B@B@                     vB@B@B@B5                                   @B@i\n *           B@B                        7B@B@B@BM                     OB@B@B@                                   ,B@B\n *           @B@                         @B@B@@@i                       rL7.                                    B@BM\n *           B@B7.:                       NB@@M.                                                               .@B@.\n *  .;JEB@@@B@B@B@B@.                                                                                       .  @B@u\n *@@@B@B@B@B@@@B@18U                                                                                      :B@B@B@BU,\n *7@BOui.    ,@@B                                                                                          SP@B@B@B@B@Or\n *            @@@U                                                                                           B@BJ.YO@B@B@i\n *            r@B@                                                                                         :B@Bk     .k@B@\n *             B@B@                                                                                       LB@@k         2i\n *              B@BM                                      .7jXEGqF7:                                     OB@@L\n *              .B@BM                                   .B@B@B@B@B@B@.                                 :@B@B:\n *               .B@B@                                   @@MYr::ivG@B                                .M@B@G\n *                 B@@@S                                                                           ,MB@B@,\n *                  v@@@BF                                                                      .1B@B@Br\n *                    2@@B@BL                                                                ,FB@@@B8,\n *                      r@B@B@BF,                                                        :YBB@B@B@B\n *                         L@B@B@B@P7,                                           .ivXB@B@B@B@B@M@B@\n *                            ,1B@B@B@B@@@BOP2L7i:,.              ..,:i7LSNB@@B@B@@@B@B@B@Z5v;.LB@@\n *                              @B@OEB@B@@@B@B@B@B@B@B@B@B@@@B@B@B@B@B@@@B@B@B@B@BM0SJ7i::::i:,u@B@\n *                              B@Bu ::i;7vu2XNGOMB@B@BMB@B@B@B@B@B@@@B1UFuj77ii:::::::iir;r;i.YB@B\n *                              @B@L.:i:i:i::::::::::..Y@B@BMYi:i;SB@B@N:.::i:iirir;r;rii::::ivO@B@\n *                              B@@X::,::::iirir;riri:E@B@1         ,@B@Br:;;r;rii:i::::i7JEB@@@@@B\n *                              @@@B@BBq5v7ii:::::::.2@@@i  ..,..     @B@@,,:::::irv2XMB@B@B@B@2@B@:\n *                             .B@BBB@@@B@B@B@BMNP5u7@B@1 .,,:,,  :.   @B@P50MB@B@B@B@B@@@BS:   @@B1\n *                             E@B@   ijGB@B@B@B@B@B@B@Bi .,:,,..@@B@7 B@B@B@B@B@B@BM57.        kB@B\n *                            .@B@:          .,ivu5Nq@B@u  ..,.. SB@B@@@B@PL7i,                 ,@B@\n *                            @@@8                   i@B@:    .     :B@B@@                       B@@2\n *                          i@@@@                     0@B@u          B@@B.                       vB@B\n *                         ,@B@G                       L@B@BOv:.:iFB@B@M                          @B@Bi\n *                          vNi                          S@@B@B@B@B@BM:                            MB@N\n *                                                          758BMqJ,\n *\n *                 .  YO.               vq                            :G       Z:\n *        SqOMBB@B@Br @@r rBE           @B     B@@@@@B@ONX8k    i::::.OB1.:::.u@O.::::i           @B@B@U:@@B@@BPEBu\n *        B@@NB@k.    5@i  uB@E.        BM     1U2uUJvirB@@Z   r@@B@B@@@B@B@B@B@B@@@B@Bi   LB@B@1 BX :@k uLLLvr@BJ:\n *            iB      iBi    7@     .@M8@BGMZZ         @@F            ,B       Pi          v@  Bq @i v@        B@\n *       vuL7r8@S7vJL7N@Z7LLri;72.   F7@Bvvv@@       @BX         @@@B@B@@@@@B@@@B@B@B      7@  @F Bi @q  @B@Bu @B\n *       N@B@G@@@8@BBOMB@G@BMNXG@,     B@   @@      .Bk          .:u;    i@:      Zv       7@  Bk @,;@  ,BY @B B@\n *            r@       @G     5.      ,@v   BZ :::,.r@E .::i,      @B     B@    .@BL       7@  @F B:i@. .@  @M @B\n *            7B: ,vO, @@   iB@:      @B   7@:MB@B@B@@@B@B@BM       @@.    B:  2@q         7@  BS @i 0@  B. @O B@\n *       ,r2EBB@B@B@Bi G@  @BB        B@   @B        @S              :    r@   ..          7B  @F @7  B7 @  @B @B\n *       E@B@UOBr       @B@Bi          L@0PB        .BZ        .@B@B@B@B@B@B@B@B@B@B@B@,   r@  BF @i  @G B@B@B B@\n *            7@,      kB@U    ;r        @@@.       .@Z                GBuL@iBBi           vB@B@q BP:5@7 @u,.  @B\n *            LBi   YB@BrB@    @@       @B:L@Br      BM             .M@B  rB  rB@J         v@. Pi @XZ8r  .     B@\n *        .   G@i B@BM.  ,B@,  @B    iB@B    N, 7r..q@k         ,LB@B8    J@,   i@B@B1r           Br           @@\n *        MB@B@B  ,i       B@B@B,    B@:        @B@B@F         .@BB:      P@i      :OBZ          .@U       B@B@B:\n *                          .ll                                           rB.                     :\n */\n/*\n██████████████████████████████████████████████████████████████████████████████\n██              ██████    ██████      ██      ██  ██    ██████              ██\n██  ██████████  ██  ██      ██      ██████████████  ██████  ██  ██████████  ██\n██  ██      ██  ██    ██  ████      ██    ██████████    ██  ██  ██      ██  ██\n██  ██      ██  ██    ██  ██      ██  ████        ██  ████  ██  ██      ██  ██\n██  ██      ██  ██  ██████  ████  ████████████  ██    ████████  ██      ██  ██\n██  ██████████  ██  ████  ██    ████    ████  ██████  ████  ██  ██████████  ██\n██              ██  ██  ██  ██  ██  ██  ██  ██  ██  ██  ██  ██              ██\n████████████████████  ██  ██    ██████  ██    ████  ████    ██████████████████\n██████  ████          ████        ██    ██    ████  ████████  ██          ████\n████  ██      ██  ██      ██  ██████  ████  ████    ██    ████    ████████  ██\n██      ██      ██    ██    ████      ████        ██████  ██      ██  ██    ██\n██  ██    ████████████  ████  ██  ████            ████  ████████████  ████  ██\n██  ██      ██  ██  ████    ████████                ████████      ██  ██    ██\n██  ██  ██  ██████████  ████    ██  ████  ██    ████  ████        ████  ██  ██\n██    ██  ████  ██████  ██    ******************    ████  ██            ██  ██\n██    ██████  ██  ██████      * Scan this QR   *██████    ██  ██  ██  ████████\n████  ████  ██  ██████      ██* code to join   *██  ████    ██  ████████  ████\n██████      ████████  ██      * in the Three   *██  ████          ████  ██  ██\n████              ████  ████  * Body ETO.      *  ████        ██  ████  ██  ██\n██████  ██    ████████        *  --ETO manager *██  ██                ██    ██\n████    ██  ██  ██    ██████  *    Ye Wenjie   *████  ████  ██  ████  ██  ████\n██  ████  ██████    ████  ██  *ETO(C),1988~2018*      ██  ██  ██  ██    ██████\n██  ██████  ██  ████    ██  ██******************          ██████    ██████  ██\n██  ██  ██    ████    ██        ██  ██        ████████      ████  ██  ██    ██\n████████████    ██    ██████  ██████████  ██  ████  ██████████    ██  ██  ████\n██████████    ██  ████  ██        ██    ██████████  ██    ██      ██  ██    ██\n██    ██  ████    ██  ████  ████      ██████    ██    ██      ██  ██  ████  ██\n██████  ██  ██████  ██            ██████████  ██    ██    ████  ████  ██    ██\n██      ██████  ████  ████  ████      ████    ████  ████            ██████████\n██████████████████      ██  ██  ████  ██    ██  ██    ████  ██████    ██    ██\n██              ██        ████████████  ████  ██  ██  ██    ██  ██      ██  ██\n██  ██████████  ██    ████  ██████  ██  ██████████████      ██████    ██  ████\n██  ██      ██  ████████    ██  ██      ████  ████  ██              ████  ████\n██  ██      ██  ████  ████  ████  ██████  ██████████████  ██████████    ██  ██\n██  ██      ██  ██    ██████  ██  ██  ██████████  ██  ██      ████    ██    ██\n██  ██████████  ██████  ████            ██    ████████  ██  ████    ██████████\n██              ██████    ████  ████████  ██  ████    ██    ██  ████  ████  ██\n██████████████████████████████████████████████████████████████████████████████\n    扫    描    二    维    码    加    入    三    体    E    T    O\n*/\n/*****************\n *   I<3   C++   *\n *  IWANT ANYAC  *\n * ILOVEPROGRAM! *\n *IT'SINTERESTING*\n * ILOVEPROGRAM! *\n *  INCONTESTS   *\n *   GETSCORE    *\n *    ACCODE     *\n *     LETS      *\n *      GO       *\n *Written by:    *\n *    charlieyan *\n *****************/\n#include <assert.h>\n#include <ctype.h>\n#include <errno.h>\n#include <float.h>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <locale>\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <wchar.h>\n#include <wctype.h>\n#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <cerrno>\n#include <clocale>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <limits>\n#include <map>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <istream>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <utility>\n#include <vector>\n#include <cwchar>\n#include <cwctype>\n#include <numeric>\n#include <list>\n#define LL long long\n#define pb push_back\n#define pob pop_back\n#define mp make_pair\n#define FILL(a,v) memset((void*)a,v,sizeof(a))\n#define FILL0(a) FILL(a,0)\n#define FILL1(a) FILL(a,-1)\n#define FILLBIG(a) FILL(a,0x3f)\n#define ALL(a) (a).begin(),(a).end()\n#define Inf ((int)0x3f3f3f3f)\n#define INF ((long long)0x3f3f3f3f3f3f3f3f)\n#define Mod 1000000007\n#define foreach(it,x) for(__typeof(x.begin()) it=x.begin();it!=x.end();it++)\n#define FOR(i,x) for(int i=0;i<x;i++)\n#define RFOR(i,x) for(int i=x-1;i>=0;i--)\n#define FFOR(i,a,b) for(int i=a;i<b;i++)\n#define FRFOR(i,a,b) for(int i=a-1;i>=b;i--)\n#define SZ(a) ((int)(a).size())\n#define FI first\n#define SE second\n#define OVER(...) return printf(__VA_ARGS__),0\n#define fastio ios::sync_with_stdio(0)\n#define filei(f) freopen(f,\"r\",stdin)\n#define fileo(f) freopen(f,\"w\",stdout)\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define MASK(a) (1<<(a))\n#define MASKX(x,a) ((x)<<(a))\n#define BIT(a,b) (((a)>>(b))&1)\n#define cddx(a) priority_queue<a >\n#define cxdd(a) priority_queue<a,vector<a >,greater<a > >\n#define deval(a) {cerr<<#a<<\" = \"<<a<<endl;}\n#define dearr(be,en) {cerr<<#be;cerr<<\" = {\";for(auto i=be;i!=en;i++)cerr<<' '<<*i;cerr<<\" }\\n\";}\n#define reg register\n#define prtime eprintf(\"\\n\\nTime used: %dms\\n\",clock());\n#define PI 3.1415926535897932384626\n#define TODEG(a) (a*180/PI)\n#define y0 ykangjimutigeidiqiuyipianjingtu\n#define y1 yxiaomiexuduhuanrenleiwannianankang\n#define endl '\\n'\n#define left leftxiaomiexudurenrenyouze\n#define hash hashxushibingduyouweilifushiyiqiedewuti\n//抗击母体，给地球一片净土\n//消灭徐毒，还人类万年安康\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef unsigned long long UINT;\ntypedef unsigned int uint;\ntypedef long long INT;\ntypedef long double ldouble;\ntypedef pair<INT,INT> PII;\ntypedef stringstream sst;\ntypedef istringstream iss;\ntypedef vector<int> vint;\ntypedef vector<INT> VINT;\ntypedef vector<pii> vpii;\ntypedef vector<PII> VPII;\ntypedef priority_queue<int> pqi;\ntypedef priority_queue<INT> PQI;\ntypedef priority_queue<pii> pqp;\ntypedef priority_queue<PII> PQP;\ntypedef priority_queue<int,vint,greater<int> > xqi;\ntypedef priority_queue<INT,VINT,greater<INT> > XQI;\ntypedef priority_queue<pii,vpii,greater<pii> > xqp;\ntypedef priority_queue<PII,VPII,greater<PII> > XQP;\nstruct fastIO\n{\n\tinline fastIO operator>>(int& num)\n\t{\n\t\tnum=0;\n\t\tchar c=getchar();\n\t\twhile(c!='-'&&(c<'0'||c>'9'))c=getchar();\n\t\tbool foo=0;\n\t\tif(c=='-')\n\t\t{\n\t\t\tfoo=1;\n\t\t\tc=getchar();\n\t\t}\n\t\twhile(c>='0'&&c<='9')\n\t\t{\n\t\t\tnum=(num<<3)+(num<<1)+c-'0';\n\t\t\tc=getchar();\n\t\t}\n\t\tif(foo)num=-num;\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(INT& num)\n\t{\n\t\tnum=0;\n\t\tchar c=getchar();\n\t\twhile(c!='-'&&(c<'0'||c>'9'))c=getchar();\n\t\tbool foo=0;\n\t\tif(c=='-')\n\t\t{\n\t\t\tfoo=1;\n\t\t\tc=getchar();\n\t\t}\n\t\twhile(c>='0'&&c<='9')\n\t\t{\n\t\t\tnum=(num<<3)+(num<<1)+c-'0';\n\t\t\tc=getchar();\n\t\t}\n\t\tif(foo)num=-num;\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(float& num)\n\t{\n\t\tscanf(\"%f\",&num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(double& num)\n\t{\n\t\tscanf(\"%lf\",&num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(long double& num)\n\t{\n\t\tscanf(\"%Lf\",&num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(char& num)\n\t{\n\t\tnum=getchar();\n\t\twhile(num==' '||num=='\\n')num=getchar();\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(char* num)\n\t{\n\t\tint cnt=0;\n\t\tchar c=getchar();\n\t\twhile(c==' '||c=='\\n')c=getchar();\n\t\twhile(c!=' '&&c!='\\n')\n\t\t{\n\t\t\tnum[cnt++]=c;\n\t\t\tc=getchar();\n\t\t}\n\t\tnum[cnt]=0;\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(string& num)\n\t{\n\t\tcin>>num;\n\t\treturn *this;\n\t}\n\tinline void printInt(const int& num)\n\t{\n\t\tif(num<10)\n\t\t{\n\t\t\tputchar(num+'0');\n\t\t\treturn;\n\t\t}\n\t\tprintInt(num/10);\n\t\tputchar((num%10)+'0');\n\t}\n\tinline void printINT(const INT& num)\n\t{\n\t\tif(num<10)\n\t\t{\n\t\t\tputchar(num+'0');\n\t\t\treturn;\n\t\t}\n\t\tprintINT(num/10);\n\t\tputchar((num%10)+'0');\n\t}\n\tinline fastIO operator<<(const int& num)\n\t{\n\t\tif(num<0)putchar('-'),printInt(-num);\n\t\telse printInt(num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const INT& num)\n\t{\n\t\tif(num<0)putchar('-'),printINT(-num);\n\t\telse printINT(num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const float& num)\n\t{\n\t\tprintf(\"%.10f\",num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const double& num)\n\t{\n\t\tprintf(\"%.16lf\",num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const long double& num)\n\t{\n\t\tprintf(\"%.20Lf\",num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const char& num)\n\t{\n\t\tputchar(num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const char* num)\n\t{\n\t\tfor(int i=0;num[i];i++)\n\t\t\tputchar(num[i]);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const string& num)\n\t{\n\t\tcout<<num;\n\t\treturn *this;\n\t}\n}fio;\n//Coded by Charlieyan\n//版权所有，翻印必究\n\nvector<int> nei[2005];\nbool lgl[2005];\nint a[2005];\nvector<int> L;\n\nvoid merge(vint &a,const vint &b){\n\tvector<int> c(SZ(a)+SZ(b),-1);\n\tint noa=0,nob=0;\n\tfor(int i=0;i<SZ(a)+SZ(b);i++){\n\t\tif(noa<SZ(a)&&(nob==SZ(b)||a[noa]>b[nob])){\n\t\t\tc[noa+nob]=a[noa];\n\t\t\tnoa++;\n\t\t}else{\n\t\t\tc[noa+nob]=b[nob];\n\t\t\tnob++;\n\t\t}\n\t}\n\ta=c;\n}\n\nvoid dfs(int now,vector<int> &l){\n\tif(lgl[now]){\n\t\treturn;\n\t}\n\tlgl[now]=1;\n\tsort(ALL(nei[now]));\n\tfor(int i:nei[now]){\n\t\tvector<int> t;\n\t\tdfs(i,t);\n\t\tmerge(l,t);\n\t}\n\tl.insert(l.begin(),a[now]);\n}\n\nint n;\n\nint main(){\n\tfio>>n;\n\tfor(int i=1;i<=n;i++){\n\t\tfio>>a[i];\n\t}\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<i;j++){\n\t\t\tif(__gcd(a[i],a[j])!=1){\n\t\t\t\tnei[i].pb(j);\n\t\t\t\tnei[j].pb(i);\n\t\t\t}\n\t\t}\n\t\tnei[i].pb(0);\n\t\tnei[0].pb(i);\n\t}\n\tdfs(0,L);\n\tfor(int i=1;i<SZ(L);i++){\n\t\tfio<<L[i]<<' ';\n\t}\n\tfio<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 2005\nusing namespace std;\ntypedef long long LL;\nint read()\n{\n\tchar c=getchar();int f=1,sum=0;\n\twhile(c<'0' || c>'9'){if(c=='-') f=-1;c=getchar();}\n\twhile(c>='0' && c<='9'){sum=sum*10+c-'0';c=getchar();}\n\treturn sum*f;\n}\nint gcd(int a,int b){return b==0?a:gcd(b,a%b);}\nint n,a[maxn];\nint head[maxn],to[maxn<<1],nex[maxn<<1],cnt;\nbool li[maxn][maxn],vis[maxn];\nint deg[maxn];\nvoid add(int u,int v)\n{\n\tdeg[v]++;to[++cnt]=v;nex[cnt]=head[u];head[u]=cnt;\n}\nvoid dfs(int x)\n{\n\tvis[x]=1;\n\tfor(int i=1;i<=n;i++)\n\tif(li[x][i] && !vis[i])\n\t{\n\t\tadd(x,i);\n\t\tdfs(i);\n\t}\n}\nstruct node{\n\tint val,id;\n    friend bool operator <(node a,node b){\n        return a.val<b.val;\n    }\n};\npriority_queue<node> q;\nint main()\n{\n\tn=read();\n\tfor(int i=1;i<=n;i++) a[i]=read();\n\tsort(a+1,a+1+n);\n\tfor(int i=1;i<n;i++)\n\tfor(int j=i+1;j<=n;j++)\n\tif(gcd(a[i],a[j])>1) li[i][j]=li[j][i]=1;\n\tfor(int i=1;i<=n;i++)\n\tif(!vis[i])\n\tdfs(i);\n\tfor(int i=1;i<=n;i++)\n\tif(!deg[i])\n\tq.push((node){a[i],i});\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tnode now=q.top();\n\t\tq.pop();\n\t\tprintf(\"%d \",a[now.id]);\n\t\tfor(int j=head[now.id];j;j=nex[j])\n\t\t{\n\t\t\tdeg[to[j]]--;\n\t\t\tif(!deg[to[j]])\n\t\t\tq.push((node){a[to[j]],to[j]});\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<queue>\n#include<assert.h>\n#include<tuple>\n#include<string>\n#include<algorithm>\n#include<iostream>\n#include<map>\n#include<string.h>\n#include<vector>\n#include<math.h>\n#include<stdlib.h>\n#include<set>\n#include<ctype.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\ntypedef tuple<int,int,int> t3;\n\nconst int MX = 100005;\nconst int MM = 1000000007;\n\nvector<int> G[MX];\n\nint gcd(int a, int b){\n\treturn b ? gcd(b, a%b) : a;\n}\n\nint D[MX], cnt[MX], vst[MX];\n\nvoid dfs(int x, vector<int> &L){\n\tif( vst[x] ) return;\n\tvst[x] = 1;\n\tsort(G[x].begin(), G[x].end());\n\tfor(int c : G[x]){\n\t\tvector<int> t, u;\n\t\tdfs(c, t);\n\t\tstd::merge(t.begin(), t.end(), L.begin(), L.end(), std::back_inserter(u), greater<int>());\n\t\tswap(u, L);\n\t}\n\tL.insert(L.begin(), x);\n}\n\nint main()\n{\n\tint N;\n\tscanf(\"%d\", &N);\n\tfor(int i = 1; i <= N; i++) scanf(\"%d\", D+i);\n\tsort(D+1, D+N+1);\n\tfor(int i = 1; i <= N; i++){\n\t\tfor(int j = i+1; j <= N; j++){\n\t\t\tif( gcd(D[i], D[j]) != 1 ){\n\t\t\t\tG[i].push_back(j);\n\t\t\t\tG[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 1; i <= N; i++){\n\t\tG[i].push_back(0);\n\t\tG[0].push_back(i);\n\t}\n\tvector<int> L;\n\tdfs(0, L);\n\tfor(int i = 1; i < L.size(); i++) printf(\"%d \", D[L[i]]);\n\tprintf(\"\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\npair<int,int> a[2222];\nint n;\nvector<int> v[2222],v2[2222];\npriority_queue<int> pq;\nbool use[2222];\ninline void dfs(int x){\n\tuse[x]=1;\n\tfor(int i=0;i<v[x].size();++i){\n\t\tif(use[v[x][i]]) continue;\n\t\tv2[x].push_back(v[x][i]);\n\t\tdfs(v[x][i]);\n\t}\n} \nint main(){\n\tint i,j;\n\tcin>>n;\n\tfor(i=1;i<=n;++i){\n\t\tcin>>a[i].first;\n\t\ta[i].second=i;\n\t}\n\tsort(a+1,a+n+1);\n\tfor(i=1;i<=n;++i) for(j=1;j<=n;++j) if(__gcd(a[i].first,a[j].first)!=1) v[i].push_back(j);\n\tfor(i=1;i<=n;++i) if(!use[i]) pq.push(i),dfs(i);\n\tmemset(use,0,sizeof(use));\n\twhile(!pq.empty()){\n\t\tint t(pq.top());\n\t\tpq.pop();\n\t\tuse[t]=0;\n\t\tfor(i=0;i<v2[t].size();++i) pq.push(v2[t][i]);\n\t\tcout<<a[t].first<<' ';\n\t}\n\tcout<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nconst int maxn = 2030, oo = 123456789, maxm = 54010;\n \nint n, m, T, ans, mn, a[maxn], foo[maxn], lst[maxm], tag[maxn];\nbool vis[maxn], f[maxn], G[maxn][maxn], F[maxn];\nstd::vector<int> g[maxn], has[maxn], rhas[maxm], all;\nstd::vector<std::pair<int, int> > v;\n \nvoid GEN() {\n\tint mx = 0;\n\tbool f = 0;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif(!foo[i]) {\n\t\t\tif(a[i] == 1) {\n\t\t\t\tF[i] = 1;\n\t\t\t\tf = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tF[i] = 0;\n\t\t\tfor (int j: has[i]) {\n\t\t\t\tif(lst[j] >= mx) {\n\t\t\t\t\tF[i] = 1;\n\t\t\t\t\tf = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t(foo[i] > mx) && (mx = foo[i]);\n\t\t}\n\t}\n\tassert(f);\n\treturn;\n}\n \nvoid dfs(int u) {\n\ttag[u] = T;\n\tif(a[u] < mn) {\n\t\tmn = a[u];\n\t}\n\tvis[u] = 1;\n\tfor (int v: g[u]) {\n\t\tif(!vis[v] && !f[v]) {\n\t\t\tdfs(v);\n\t\t}\n\t}\n\treturn;\n}\n \nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tscanf(\"%d\", a + i);\n\t\tint t = a[i];\n\t\tfor (int x = 2; x * x <= t; ++x) {\n\t\t\tif(t % x == 0) {\n\t\t\t\tall.push_back(x);\n\t\t\t\twhile(t % x == 0) {\n\t\t\t\t\tt /= x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(t > 1) {\n\t\t\tall.push_back(t);\n\t\t}\n\t}\n\tstd::sort(a + 1, a + n + 1);\n\tstd::sort(all.begin(), all.end());\n\tall.resize(std::unique(all.begin(), all.end()) - all.begin());\n\tm = (int)(all.size());\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tif(a[i] % all[j] == 0) {\n\t\t\t\thas[i].push_back(j);\n\t\t\t\trhas[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int j = 0; j < m; ++j) {\n\t\tfor (int i = 0; i < (int)(rhas[j].size()); ++i) {\n\t\t\tfor (int k = 0; k < i; ++k) {\n\t\t\t\tint u = rhas[j][i], v = rhas[j][k];\n\t\t\t\tif(!G[u][v]) {\n\t\t\t\t\tg[u].push_back(v);\n\t\t\t\t\tg[v].push_back(u);\n\t\t\t\t\tG[u][v] = G[v][u] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tGEN();\n\t\tmemset(vis + 1, 0, sizeof(vis[0]) * n);\n\t\tv.clear();\n\t\tfor (int u = 1; u <= n; ++u) {\n\t\t\tif(F[u]) {\n\t\t\t\tif(!vis[u] && !f[u]) {\n\t\t\t\t\t++T;\n\t\t\t\t\tmn = oo;\n\t\t\t\t\tdfs(u);\n\t\t\t\t\tv.push_back(std::make_pair(mn, T));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstd::sort(v.begin(), v.end());\n\t\tint sz = (int)(v.size());\n\t\tans = 0;\n\t\tfor (int u = 1; u <= n; ++u) {\n\t\t\tif(F[u] && !f[u]) {\n\t\t\t\tint i = sz - 1;\n\t\t\t\tif(v[i].second == tag[u]) {\n\t\t\t\t\t--i;\n\t\t\t\t}\n\t\t\t\tif(i < 0 || v[i].first <= a[u]) {\n\t\t\t\t\tans = u;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\tassert(ans);\n\t\tf[ans] = 1;\n\t\tfoo[ans] = i;\n\t\tprintf(\"%d \", a[ans]);\n\t\tfor (int j: has[ans]) {\n\t\t\tlst[j] = i;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#define N 5010\n#define mp make_pair\nusing namespace std;\ntypedef pair<int,int> pii;\npriority_queue<pii> q;\nvector<int> g[N];int vis[N],a[N];\nint gcd(int a,int b) { return a?gcd(b%a,a):b; }\nint dfs(int x,int n)\n{\n\tfor(int y=1;y<=n;y++)\n\t\tif(!vis[y]&&gcd(a[x],a[y])>1)\n\t\t\tvis[y]=1,dfs(y,n),g[x].push_back(y);\n\treturn 0;\n}\nint main()\n{\n\tint n;scanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tsort(a+1,a+n+1);while(!q.empty()) q.pop();\n\tfor(int i=1;i<=n;i++)\n\t\tif(!vis[i]) vis[i]=1,dfs(i,n),q.push(mp(a[i],i));\n\twhile(!q.empty())\n\t{\n\t\tint x=q.top().second;\n\t\tq.pop(),printf(\"%d \",a[x]);\n\t\tfor(int i=0;i<(int)g[x].size();i++)\n\t\t\tq.push(mp(a[g[x][i]],g[x][i]));\n\t}\n\treturn !printf(\"\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#define pb push_back\nusing namespace std;\nconst int N=2100;\npriority_queue<int> Q;\nvector<int> E[N],W[N];\nint n,a[N],d[N],vis[N];\nvoid dfs(int x)\n{\n\tvis[x]=1;\n\tfor(auto R:E[x]) if(!vis[R]) W[x].pb(R);\n\tfor(auto R:E[x]) if(!vis[R]) dfs(R);\n}\nint main()\n{\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\tif(__gcd(a[i],a[j])>1) E[i].pb(j),E[j].pb(i);\n\tfor(int i=1;i<=n;i++) sort(E[i].begin(),E[i].end());\n\tfor(int i=1;i<=n;i++) if(!vis[i]) dfs(i);\n\tfor(int i=1;i<=n;i++) for(auto R:W[i]) d[R]++;\n\tfor(int i=1;i<=n;i++) if(!d[i]) Q.push(i);\n\twhile(!Q.empty())\n\t{\n\t\tint x=Q.top();Q.pop();\n\t\tprintf(\"%d \",a[x]);\n\t\tfor(auto R:W[x])\n\t\t\tif(--d[R]==0) Q.push(R);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "// luogu-judger-enable-o2\n#include <bits/stdc++.h>\n#define RI register int\n\nusing namespace std;\n\nchar buf[1000000], *p1 = buf, *p2 = buf;\ninline char gc() {\n  if (p1 == p2) p2 = (p1 = buf) + fread(buf, 1, 1000000, stdin);\n  return p1 == p2 ? EOF : *(p1++);\n}\ntemplate <class T> inline void read(T &n) {\n  n = 0; RI ch = gc();\n  while (ch < '0' || ch > '9') ch = gc();\n  while (ch >= '0' && ch <= '9') n = n * 10 + (ch ^ 48), ch = gc();\n}\n\nint const MAXN = 2005;\nint vis[MAXN], Min[MAXN], a[MAXN];\nvector <int> G[MAXN];\n\ninline int gcd(int x, int y) {\n  int t;\n  while (y) t = x % y, x = y, y = t;\n  return x;\n}\n\nvoid Dfs(int now, int on) {\n  if (on) printf(\"%d \", a[now]);\n  vis[now] = 1;\n  vector <int> :: iterator it = G[now].begin(), en = G[now].end();\n  for (; it != en; ++it)\n    if (!vis[*it]) Dfs(*it, on);\n}\n\nint main() {\n // freopen(\"rearranging.in\", \"r\", stdin);\n // freopen(\"rearranging.out\", \"w\", stdout);\n  int n; read(n);\n  for (RI i = 1; i <= n; ++i) read(a[i]);\n  sort(a + 1, a + 1 + n);\n  for (RI i = 1; i <= n; ++i)\n    for (RI j = i + 1; j <= n; ++j)\n      if (gcd(a[i], a[j]) != 1)\n        G[i].push_back(j), G[j].push_back(i);\n  for (RI i = 1; i <= n; ++i)\n    sort(G[i].begin(), G[i].end());\n  int cnt = 0;\n  for (RI i = 1; i <= n; ++i)\n    if (!vis[i]) Min[++cnt] = i, Dfs(i, 0);\n  memset(vis, 0, sizeof(vis));\n  for (RI i = cnt; i; --i)\n    Dfs(Min[i], 1);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\n#define INF 1e9\n#define LINF 1e18\n#define ld double\n#define ll long long\n#define ull unsigned long long\n\ntemplate <typename T> void read(T &x) {\n\tx = 0; int f = 1, c = getchar();\n\tfor (;!isdigit(c);c = getchar()) if (c == '-') f = -f;\n\tfor (; isdigit(c);c = getchar()) x = (x<<3) + (x<<1) + (c^48);\n\tx *= f;\n}\n\nconst int N = 2005;\nint n, a[N], g[N][N], used[N], canuse[N], vis[N], que[N];\n\nint bfs(int s) {\n\tmemcpy(vis, used, sizeof vis);\n\tint mn = n;\n\tint l = 0, r = 0;\n\tque[r ++] = s;\n\twhile (l < r) {\n\t\tint u = que[l ++];\n\t\tif (canuse[u] && u < mn) mn = u;\n\t\tvis[u >> 6] |= 1 << (u & 63);\n\t\tfor (int i = 0; (i << 6) < n; ++ i) {\n\t\t\tfor (int j = i << 6; j < ((i + 1) << 6); ++ j) {\n\t\t\t\tif (g[u][i] & 1 << (j & 63)) {\n\t\t\t\t\tif (!(vis[j >> 6] & 1 << (j & 63))) {\n\t\t\t\t\t\tque[r ++] = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn mn;\n}\n\nvoid print() {\n\tint mx = 0;\n\tfor (int i = 0; i < n; ++ i) if (!(used[i >> 6] & 1 << (i & 63))) mx = max(mx, bfs(i));\n\tprintf(\"%d\", a[mx]);\n\tfor (int i = 0; i < n; ++ i) if (g[mx][i >> 6] & 1 << (i & 63)) canuse[i] = 1; else if (a[i] > a[mx]) canuse[i] = 0;\n\tused[mx >> 6] |= 1 << (mx & 63);\n}\n\nint main() {\n\tread(n);\n\tfor (int i = 0; i < n; ++ i) read(a[i]);\n\tsort(a, a + n);\n\tfor (int i = 0; i < n; ++ i) for (int j = 0; j < n; ++ j) if (__gcd(a[i], a[j]) != 1) g[i][j >> 6] |= 1 << (j & 63);\n\tfor (int i = 0; i < n; ++ i) canuse[i] = 1;\n\tfor (int i = 0; i < n; ++ i) print(), putchar(\" \\n\"[i + 1 == n]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <stack>\n#include <map>\n#include <set>\n#include <deque>\n#include <cstring>\n#include <functional>\n#include <climits>\n#include <list>\n#include <ctime>\n#include <complex>\n\n#define F1(x,y,z) for(int x=(y);x<(z);x++)\n#define F2(x,y,z) for(int x=(y);x<=(z);x++)\n#define F3(x,y,z) for(int x=(y);x>(z);x--)\n#define F4(x,y,z) for(int x=(y);x>=(z);x--)\n#define mp make_pair\n#define pb push_back\n#define LL long long\n#define co complex<double>\n#define fi first\n#define se second\n\n#define MAX 100005\n#define AMAX 1025*1005\n#define MOD 1000000007\n\n#define f(c,d) ((1<<(c))*(d))\n\nusing namespace std;\n\nint n,ta,x[2005],i,at[MAX],ov[2005],ne[2005];\nvector<int> np[2005],p,em,vp[2005];\nvector<vector<int> > ans;\nmap<int,int> m;\nmap<int,int>::iterator it;\nbool o,vm[MAX],d[MAX],dd[2005],iq[2005];\npair<int,int> mi[MAX];\nvector<pair<int,int> > vn[MAX]; \npriority_queue<pair<int,int> > q;\npriority_queue<pair<int,int> > qq;\n\nvoid up(int a){\n//\tprintf(\"up %d %d %d\\n\",a,at[a],vn[a].size());\n\tif(at[a]!=vn[a].size()){\n\t\tint ti=vn[a][at[a]].se;\n//\tprintf(\"up %d %d %d %d  %d %d\\n\",a,at[a],vn[a].size(),ti,dd[ti],iq[ti]);\n\t\tif(dd[ti]){\n\t\t\tat[a]++;\n\t\t\tup(a);\n\t\t}else if(!iq[ti]){\n\t\t\tvp[ti].pb(a);\n\t\t\tif(++ov[ti]==ne[ti]){\n\t\t\t//\tprintf(\"push %d %d  %d \\n\",vn[a][at[a]].fi,ti,a);\n\t\t\t\tq.push(vn[a][at[a]]);\n\t\t\t\tiq[ti]=1;\n\t\t\t\tF1(b,0,np[ti].size())if(vm[np[ti][b]])at[np[ti][b]]++;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid upp(int a){\n\tif(at[a]!=ans[a].size()){\n\t\tqq.push(mp(ans[a][at[a]],a));\n\t\tat[a]++;\n\t}\n}\n\nint main(){\n\tF1(a,0,MAX)mi[a]=mp(INT_MAX,a);\n\tF2(a,2,10000){\n\t\to=1;\n\t\tF1(b,0,p.size()){\n\t\t\tif(p[b]*p[b]>a)break;\n\t\t\tif(a%p[b]==0){\n\t\t\t\to=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(o)p.pb(a);\n\t}\n\tscanf(\"%d\",&n);\n\tF1(a,0,n){\n\t\tscanf(\"%d\",x+a);\n\t\tta=x[a];\n\t\tF1(b,0,p.size()){\n\t\t\tif(p[b]*p[b]>ta)break;\n\t\t\tif(ta%p[b]==0){\n\t\t\t\ti=m.insert(mp(p[b],m.size())).fi->se;\n\t\t\t\tnp[a].pb(i);\n\t\t\t\tmi[i].fi=min(mi[i].fi,x[a]);\n\t\t\t\tvn[i].pb(mp(x[a],a));\n\t\t\t\twhile(ta%p[b]==0)ta/=p[b];\n\t\t\t}\n\t\t}\n\t\tif(ta!=1){\n\t\t\ti=m.insert(mp(ta,m.size())).fi->se;\n\t\t\tnp[a].pb(i);\n\t\t\tmi[i].fi=min(mi[i].fi,x[a]);\n\t\t\tvn[i].pb(mp(x[a],a));\n\t\t}\n\t}\n\tsort(mi,mi+m.size());\n\tF1(a,0,m.size()){\n\t\ti=mi[a].se;\n\t\tif(!vm[i]){\n\t\t\tvm[i]=1;\n\t\t\tans.pb(em);\n\t\t\tsort(vn[i].begin(),vn[i].end());\n\t\t\tF1(b,0,vn[i].size())ne[vn[i][b].se]++;\n\t\t\tup(i);\n\t\t\twhile(!q.empty()){\n\t\t\t\tta=q.top().se;\n\t\t\t\tint tv=q.top().fi;\n\t\t\t\tq.pop();\t\t\t\n\t\t\t\t//printf(\"pop1 %d %d\\n\",tv,ta);\t\n\t\t\t\tif(ne[ta]!=ov[ta]){\n\t\t\t\t\tiq[ta]=0;\n\t\t\t\t\tF1(b,0,ov[ta])at[vp[ta][b]]--;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tans.back().pb(tv);\n\t\t\t\tdd[ta]=1;\n\t\t\t\t//printf(\"pop2 %d %d\\n\",tv,ta);\n\t\t\t\tF1(b,0,np[ta].size()){\n\t\t\t\t\tif(!vm[np[ta][b]]){\n\t\t\t\t\t\tvm[np[ta][b]]=1;\n\t\t\t\t\t\tsort(vn[np[ta][b]].begin(),vn[np[ta][b]].end());\n\t\t\t\t\t\tF1(c,0,vn[np[ta][b]].size())ne[vn[np[ta][b]][c].se]++;\n\t\t\t\t\t}\n\t\t\t\t\tup(np[ta][b]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n//\tF1(a,0,m.size())F1(b,0,vn[a].size())printf(\"%d,%d%c\",vn[a][b].fi,vn[a][b].se,b==vn[a].size()-1?'\\n':' ');\n\t//F1(a,0,ans.size())F1(b,0,ans[a].size())printf(\"%d%c\",ans[a][b],b==ans[a].size()-1?'\\n':' ');\n\tF1(a,0,ans.size())at[a]=0;\n\tF1(a,0,ans.size())upp(a);\n\twhile(!qq.empty()){\n\t\tprintf(\"%d \",qq.top().fi);\n\t\tint ttt=qq.top().se;\n\t\tqq.pop();\n\t\tupp(ttt);\n\t}\n\tF1(a,0,n)if(x[a]==1)printf(\"1 \");\n\t#ifdef LOCAL_PROJECT\n\tsystem(\"pause\");\n\t#endif\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//2018-1-25\n//miaomiao\n//\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define For(i, a, b) for(int i = (a); i <= (int)(b); ++i)\n\n#define N (2000+5)\n#define M (4000000+5)\n\nint Gcd(int a, int b){return !b? a: Gcd(b, a % b);}\n\nstruct node{\n\tint p, v;\n\tbool operator <(const node &rhs)const{return v < rhs.v;}\n};\n\nint a[N], in[N], vis[N];\nvector<int> G[N], g[N];\n\npriority_queue<node> q;\n\nbool cmp(int i, int j){\n\treturn a[i] < a[j];\n}\n\n#define v G[now][i]\n\nvoid Dfs(int now, int F){\n\tvis[now] = vis[F] + 1;\n\n\tsort(G[now].begin(), G[now].end(), cmp);\n\tFor(i, 0, G[now].size() - 1){\n\t\tif(v == F) continue;\n\t\t\n\t\tif(vis[v]){\n\t\t\tif(vis[v] > vis[now]) g[now].pb(v), ++in[v];\n\t\t}else{\n\t\t\tg[now].pb(v); ++in[v];\n\t\t\tDfs(v, now);\n\t\t}\n\t}\n}\n\n#undef v\n\nint main(){\n\tint n;\n\tscanf(\"%d\", &n);\n\tFor(i, 1, n) scanf(\"%d\", &a[i]);\n\n\tFor(i, 1, n) For(j, i + 1, n)\n\t\tif(Gcd(a[i], a[j]) > 1) G[i].pb(j), G[j].pb(i);\n\t\t\n\tFor(i, 1, n) if(!vis[i]) Dfs(i, 0);\n\tFor(i, 1, n) if(!in[i]) q.push((node){i, a[i]});\n\t\n\tint now, v;\n\twhile(!q.empty()){\n\t\tnow = q.top().p; q.pop();\n\t\tprintf(\"%d \", a[now]);\n\n\t\tFor(i, 0, g[now].size() - 1){\n\t\t\t--in[v = g[now][i]];\n\t\t\tif(!in[v]) q.push((node){v, a[v]});\n\t\t}\n\t}\n\tputs(\"\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,x,y) for (int i=(x);i<=(y);i++)\n#define Vi vector<int>\n#define pii pair<int,int>\n\nusing namespace std;\n\nconst int N=2010;\nint n,a[N],vis[N]; Vi G[N];\nint cnt,head[N],rd[N];\nstruct edge{int to,nxt;}e[N*N];\n\nvoid adde(int x,int y){\n\te[++cnt].to=y; e[cnt].nxt=head[x]; head[x]=cnt; rd[y]++;\n}\n\nvoid dfs(int u){\n\tvis[u]=1;\n\tfor (auto v:G[u]) if (!vis[v]) adde(u,v),dfs(v);\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\trep (i,1,n) scanf(\"%d\",&a[i]);\n\tsort(a+1,a+1+n);\n\trep (i,1,n) rep (j,1,n) if (i!=j&&__gcd(a[i],a[j])!=1) G[i].push_back(j);\n\trep (i,1,n) if (!vis[i]) dfs(i);\n\tpriority_queue<int> q;\n\trep (i,1,n) if (!rd[i]) q.push(i);\n\twhile (!q.empty()){\n\t\tint x=q.top(); q.pop();\n\t\tprintf(\"%d \",a[x]);\n\t\tfor (int i=head[x],y;i;i=e[i].nxt)\n\t\t\tif (y=e[i].to,!--rd[y]) q.push(y);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\",\"inline\",\"-ffast-math\")\n#pragma GCC target(\"avx,sse2,sse3,sse4,mmx\")\n#include <bits/stdc++.h>\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/hash_policy.hpp>\nusing namespace __gnu_pbds;\nusing namespace std;\n\nint n,a[2010];\nvector<int> v[2010];\nbool vis[2010],used[2010];\nvector<int> dp[2010];\n\ninline void dfs2(int x)\n{\n\tvis[x]=1;\n\tfor(int i=0;i<v[x].size();i++) if(!used[v[x][i]]&&!vis[v[x][i]]){\n\t\tdfs2(v[x][i]);\n\t}\n}\n\ninline void dfs(int x)\n{\n\tused[x]=1;memset(vis,0,sizeof(vis));\n\tfor(int i=0;i<v[x].size();i++) if(!used[v[x][i]]&&!vis[v[x][i]]){\n\t\tdfs2(v[x][i]);\n\t\tdp[x].push_back(v[x][i]);\n\t}\n\tfor(int i=0;i<dp[x].size();i++) dfs(dp[x][i]);\n} \n\ninline void dfs3(int x)\n{\n\tif(x>0) cout<<a[x]<<\" \";\n\tfor(int i=dp[x].size()-1;i>=0;i--) dfs3(dp[x][i]);\n}\n\nsigned main()\n{\n\tios::sync_with_stdio(false);\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++){\n\t\tv[0].push_back(i);v[i].push_back(0);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=i+1;j<=n;j++){\n\t\t\tif(__gcd(a[i],a[j])>1){\n\t\t\t\tv[i].push_back(j);\n\t\t\t\tv[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<=n;i++) sort(v[i].begin(),v[i].end());\n\tdfs(0);\n\tdfs3(0);\n\tcout<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N;\nint A[2005],Deg[2005];\nbool G[2005][2005],Vis[2005];\n\nvector<int> To[2005];\npriority_queue<pair<int,int>> Q;\n\nvoid DFS(int u){\n\tint i;\n\tVis[u]=true;\n\tfor(i=1;i<=N;i++)\n\t\tif(G[u][i]&&!Vis[i]){\n\t\t\tDeg[i]++;\n\t\t\tTo[u].push_back(i);\n\t\t\tDFS(i);\n\t\t}\n}\n\nint main(){\n\tint i,j,u,v;\n\tscanf(\"%d\",&N);\n\tfor(i=1;i<=N;i++)\n\t\tscanf(\"%d\",&A[i]);\n\tsort(A+1,A+N+1);\n\tfor(i=1;i<N;i++)\n\t\tfor(j=i+1;j<=N;j++)\n\t\t\tif(__gcd(A[i],A[j])>1)\n\t\t\t\tG[i][j]=G[j][i]=true;\n\tfor(i=1;i<=N;i++)\n\t\tif(!Vis[i])\n\t\t\tDFS(i);\n\tfor(i=1;i<=N;i++)\n\t\tif(!Deg[i])\n\t\t\tQ.push({A[i],i});\n\twhile(Q.size()){\n\t\tu=Q.top().second;\n\t\tprintf(\"%d \",Q.top().first);\n\t\tQ.pop();\n\t\tfor(auto v:To[u])\n\t\t\tif(!--Deg[v])\n\t\t\t\tQ.push({A[v],v});\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,a[2010],x[2010][2010],p[2010],m,f[2010],g[2010],h[2010];\nbool w[2010];\ninline int gcd(int n,int m)\n{\n    return m?gcd(m,n%m):n;\n}\ninline void dfs(int i)\n{\n    int j;\n    p[i]=2;\n    for(j=1;j<=n;j++)\n      if(!p[j] && x[i][j])\n        dfs(j);\n}\ninline void orz()\n{\n    int i,j,k=0;\n    for(i=1;p[i]!=2;i++);\n    w[i]=1;\n    while(1)\n      {\n       for(i=1;i<=n && !w[i];i++);\n       if(i>n)\n         break;\n       w[i]=0;\n       p[i]=1;\n       g[++k]=i;\n       for(j=1;j<=n;j++)\n         if(p[j]==2 && x[i][j])\n           w[j]=1;\n      }\n    for(i=j=1;i<=m && j<=k;)\n      if(f[i]>g[j])\n        h[i+j-1]=f[i],i++;\n      else\n        h[i+j-1]=g[j],j++;\n    for(;i<=m;i++)\n      h[i+j-1]=f[i];\n    for(;j<=k;j++)\n      h[i+j-1]=g[j];\n    m+=k;\n    for(i=1;i<=m;i++)\n      f[i]=h[i];\n}\nint main()\n{\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tint i,j;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;i++)\n\t  scanf(\"%d\",&a[i]);\n\tsort(a+1,a+n+1);\n\tfor(i=1;i<=n;i++)\n\t  for(j=1;j<=n;j++)\n\t    if(i!=j && gcd(a[i],a[j])>1)\n\t      x[i][j]=1;\n\tfor(i=1;i<=n;i++)\n\t  if(!p[i])\n\t    {\n\t     dfs(i);\n\t     orz();\n        }\n    for(i=1;i<=n;i++)\n      printf(\"%d \",a[f[i]]);\n    printf(\"\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n//#define USEPB_DS\n#define USETR1\n#define CPPELEVEN\n#define GPP\n\n/*\n * temp.cpp\n *\n *  Created on: 2012-7-18\n *      Author: BSBandme\n */\n//#pragma comment(linker, \"/STACK:1024000000,1024000000\")\n\n#include <iostream>\n#include <fstream>\n#include <string.h>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <queue>\n#include <cassert>\n#include <list>\n#include <iomanip>\n#include <math.h>\n#include <deque>\n#include <utility>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cctype>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <functional>\n#include <sstream>\n#include <tuple>\n\nusing namespace std;\n\n#ifndef CPPELEVEN\n#ifdef USETR1\n#include <tr1/unordered_map>\n#include <tr1/unordered_set>\nusing namespace tr1;\n#endif\n#else\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\n#ifdef USEPB_DS\n#include <ext/pb_ds/priority_queue.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\n// binomial_heap_tag, rc_binomial_heap_tag, thin_heap_tag, binary_heap_tag\ntypedef __gnu_pbds::priority_queue<int, greater<int>, pairing_heap_tag> pq_type;\n// splay_tree_tag, ov_tree_tag\ntypedef tree <int, null_type, less <int>, rb_tree_tag, tree_order_statistics_node_update> tree_type;\n#endif\n\n#define mpr make_pair\ntypedef unsigned int ui;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <double, double> pdd;\ntypedef vector <int> vi;\ntypedef vector <ll> vll;\ntypedef vector <double> vd;\ntypedef vector <string> vs;\ntypedef map <string, int> mpsi;\ntypedef map <double, int> mpdi;\ntypedef map <int, int> mpii;\n\nconst double pi = acos(0.0) * 2.0;\nconst long double eps = 1e-10;\nconst int step[8][2] = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}, {-1, 1}, {1, 1}, {1, -1}, {-1, -1}};\n\ntemplate <class T> inline T abs1(T a) {return a < 0 ? -a : a;}\n\n#ifndef CPPELEVEN\ntemplate <class T> inline T max1(T a, T b) { return b < a ? a : b; }\ntemplate <class T> inline T max1(T a, T b, T c) { return max1(max1(a, b), c); }\ntemplate <class T> inline T max1(T a, T b, T c, T d) { return max1(max1(a, b, c), d); }\ntemplate <class T> inline T max1(T a, T b, T c, T d, T e) { return max1(max1(a, b, c, d), e); }\ntemplate <class T> inline T min1(T a, T b) { return a < b ? a : b; }\ntemplate <class T> inline T min1(T a, T b, T c) { return min1(min1(a, b), c); }\ntemplate <class T> inline T min1(T a, T b, T c, T d) { return min1(min1(a, b, c), d); }\ntemplate <class T> inline T min1(T a, T b, T c, T d, T e) { return min1(min1(a, b, c, d), e); }\n#else\ntemplate <typename t, typename t1>\nt min1(t a, t1 b) { return a < b ? a : b; }\ntemplate <typename t, typename... arg>\nt min1(t a, arg... arr) { return min1(a, min1(arr...)); }\ntemplate <typename t, typename t1>\nt max1(t a, t1 b) { return a > b ? a : b; }\ntemplate <typename t, typename... arg>\nt max1(t a, arg... arr) { return max1(a, max1(arr...)); }\n#endif\n\ninline int jud(double a, double b){\n\tif(abs(a) < eps && abs(b) < eps) return 0;\n\telse if(abs1(a - b) / max(abs1(a), abs1(b)) < eps) return 0;\n\tif(a < b) return -1;\n\treturn 1;\n}\ntemplate <typename t> inline int jud(t a, t b){\n\tif(a < b) return -1;\n\tif(a == b) return 0;\n\treturn 1;\n}\n\n// f_lb == 1代表返回相同的一串的左边界，f_small == 1代表返回如果没有寻找的值返回小的数\ntemplate <typename it, typename t1>\ninline int find(t1 val, it a, int na, bool f_small = 1, bool f_lb = 1){\n\tif(na == 0) return 0;\n\tint be = 0, en = na - 1;\n\tif(*a <= *(a + na - 1)){\n\t\tif(f_lb == 0) while(be < en){\n\t\t\tint mid = (be + en + 1) / 2;\n\t\t\tif(jud(*(a + mid), val) != 1) be = mid;\n\t\t\telse en = mid - 1;\n\t\t}else while(be < en){\n\t\t\tint mid = (be + en) / 2;\n\t\t\tif(jud(*(a + mid), val) != -1) en = mid;\n\t\t\telse be = mid + 1;\n\t\t}\n\t\tif(f_small && jud(*(a + be), val) == 1) be--;\n\t\tif(!f_small && jud(*(a + be), val) == -1) be++;\n\t} else {\n\t\tif(f_lb) while(be < en){\n\t\t\tint mid = (be + en + 1) / 2;\n\t\t\tif(jud(*(a + mid), val) != -1) be = mid;\n\t\t\telse en = mid - 1;\n\t\t}else while(be < en){\n\t\t\tint mid = (be + en) / 2;\n\t\t\tif(jud(*(a + mid), val) != 1) en = mid;\n\t\t\telse be = mid + 1;\n\t\t}\n\t\tif(!f_small && jud(*(a + be), val) == -1) be--;\n\t\tif(f_small && jud(*(a + be), val) == 1) be++;\n\t}\n\treturn be;\n}\n\ntemplate <class T> inline T lowb(T num) {return num & (-num); }\n#ifdef GPP\ninline int bitnum(ui nValue) { return __builtin_popcount(nValue); }\ninline int bitnum(int nValue) { return __builtin_popcount(nValue); }\ninline int bitnum(ull nValue) { return __builtin_popcount(nValue) + __builtin_popcount(nValue >> 32); }\ninline int bitnum(ll nValue) { return __builtin_popcount(nValue) + __builtin_popcount(nValue >> 32); }\ninline int bitmaxl(ui a) { if(a == 0) return 0; return 32 - __builtin_clz(a); }\ninline int bitmaxl(int a) { if(a == 0) return 0; return 32 - __builtin_clz(a); }\ninline int bitmaxl(ull a) { int temp = a >> 32; if(temp) return 32 - __builtin_clz(temp) + 32; return bitmaxl(int(a)); }\ninline int bitmaxl(ll a) { int temp = a >> 32; if(temp) return 32 - __builtin_clz(temp) + 32; return bitmaxl(int(a)); }\n#else\n#endif\n\nlong long pow(long long n, long long m, long long mod = 0){\n\tif(m < 0) return 0;\n\tlong long ans = 1;\n\tlong long k = n;\n\twhile(m){\n\t\tif(m & 1) {\n\t\t\tans *= k;\n\t\t\tif(mod) ans %= mod;\n\t\t}\n\t\tk *= k;\n\t\tif(mod) k %= mod;\n\t\tm >>= 1;\n\t}\n\treturn ans;\n}\n\n#define  MOD 1000000007\ntemplate <class t1, class t2>\ninline void add(t1 &a, t2 b, int mod = -1) {\n\tif(mod == -1) mod = MOD;\n\ta += b;\n\twhile(a >= mod) a -= mod;\n\twhile(a < 0) a += mod;\n}\ntemplate <class t>\nvoid output1(t arr) {\n\tfor(int i = 0; i < (int)arr.size(); i++)\n\t\tcerr << arr[i] << ' ';\n\tcerr << endl;\n}\ntemplate <class t>\nvoid output2(t arr) {\n\tfor(int i = 0; i < (int)arr.size(); i++)\n\t\toutput1(arr[i]);\n}\n\n//....................密..........封..........线..........下..........禁..........止..........hack...............................................\n\nconst int maxn = 2010;\nint arr[maxn];\nint ans[maxn], lans;\nbitset <maxn> e[maxn];\nint have[maxn];\nint n;\nint temp[maxn], nxt[maxn];\n\nvoid rearrange(vi st) {\n\tif(st.size() == 0) return;\n\tfor(int i = st[0]; i < lans; i++)\n\t\tnxt[i] = i + 1;\n\tfor(auto it : st) if(it > 0){\n\t\tnxt[it - 1] = -1;\n\t}\n\tnxt[lans - 1] = -1;\n\tpriority_queue <pii> pq;\n\tfor(auto it : st)\n\t\tpq.push(mpr(ans[it], it));\n\tint lt = 0;\n\twhile(pq.size()) {\n\t\tint val = pq.top().first, no = pq.top().second;\n\t\tpq.pop();\n\t\ttemp[lt++] = val;\n\t\tif(nxt[no] != -1) {\n\t\t\tpq.push(mpr(ans[no + 1], no + 1));\n\t\t}\n\t}\n\tfor(int i = 0; i < lt; i++)\n\t\tans[st[0] + i] = temp[i];\n}\n\nvoid dfs(int no) {\n\tans[lans++] = arr[no];\n\thave[no] = 1;\n\tvector <pii> temp;\n\tfor(int i = 0; i < n; i++) if(!have[i] && e[no].test(i)) {\n\t\ttemp.push_back(mpr(arr[i], i));\n\t}\n\tsort(temp.begin(), temp.end());\n\tvi st;\n\tfor(auto it : temp\t) if(!have[it.second]) {\n\t\tst.push_back(lans);\n\t\tdfs(it.second);\n\t}\n\trearrange(st);\n}\n\nint main() {\n\n\n//............................不要再忘了检查maxn大小了！！！！BSBandme你个SB！！！！...................................................\n\n\tios_base::sync_with_stdio(0);\n\t#ifdef DEBUG //......................................................................................................\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tint __size__ = 256 << 20; // 256MB\n\tchar *__p__ = (char*)malloc(__size__) + __size__;\n\t__asm__(\"movl %0, %%esp\\n\" :: \"r\"(__p__));\n\t#endif //...........................................................................................................\n\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; i++) {\n\t\tscanf(\"%d\", arr + i);\n\t}\n\tsort(arr, arr + n);\n\tfor(int i = 0; i < n; i++)\n\t\tfor(int j = i + 1; j < n; j++) if(__gcd(arr[i], arr[j]) != 1) {\n\t\t\te[i].set(j, 1);\n\t\t\te[j].set(i, 1);\n\t\t}\n\n\tvi st;\n\tfor(int i = 0; i < n; i++) if(!have[i]) {\n\t\tst.push_back(lans);\n\t\tdfs(i);\n\t}\n\trearrange(st);\n\tfor(int i = 0; i < lans; i++)\n\t\tprintf(\"%d \", ans[i]);\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define REP(i, n) FOR (i, 0, n)\n#define _ << \" _ \" <<\n#define TRACE(x) cerr << #x << \" = \" << x << endl\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n//#define debug\n//#define TRACE(x)\n\nusing namespace std;\n\ntypedef long long llint;\n\nconst int MAXN = 2010;\n\nint n, a[MAXN], adj[MAXN][MAXN];\nvector<int> e[MAXN];\nbool bio[MAXN];\n\nvoid dfs(int x) {\n  bio[x] = true;\n  REP(y, n) {\n    if (!adj[x][y]) continue;\n    if (bio[y]) continue;\n    e[x].push_back(y);\n    dfs(y);\n  }\n}\n\nvoid solve(int x) {\n  if (x != n)\n    printf(\"%d \",a[x]);\n  reverse(e[x].begin(), e[x].end());\n  for (int y : e[x])\n    solve(y);\n}\n\nint main(void) {\n  scanf(\"%d\",&n);\n  REP(i, n) scanf(\"%d\",&a[i]);\n  sort(a, a + n);\n\n  REP(i, n) REP(j, i) \n    adj[i][j] = adj[j][i] = (__gcd(a[i], a[j]) > 1) ? 1 : 0;\n\n  REP(i, n)\n    if (!bio[i]) {\n      e[n].push_back(i);\n      dfs(i);\n    }\n\n  solve(n);\n  printf(\"\\n\");\n    \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef int sign;\ntypedef long long ll;\n#define For(i,a,b) for(register sign i=(sign)a;i<=(sign)b;++i)\n#define Fordown(i,a,b) for(register sign i=(sign)a;i>=(sign)b;--i)\nconst int N=2e3+5;\ntemplate<typename T>bool cmax(T &a,T b){return (a<b)?a=b,1:0;}\ntemplate<typename T>bool cmin(T &a,T b){return (a>b)?a=b,1:0;}\ntemplate<typename T>T read()\n{\n\tT ans=0,f=1;\n\tchar ch=getchar();\n\twhile(!isdigit(ch)&&ch!='-')ch=getchar();\n\tif(ch=='-')f=-1,ch=getchar();\n\twhile(isdigit(ch))ans=(ans<<3)+(ans<<1)+(ch-'0'),ch=getchar();\n\treturn ans*f;\n}\ntemplate<typename T>void write(T x,char y)\n{\n\tif(x==0)\n\t{\n\t\tputchar('0'),putchar(y);\n\t\treturn;\n\t}\n\tif(x<0)\n\t{\n\t\tputchar('-');\n\t\tx=-x;\n\t}\n\tstatic char wr[20];\n\tint top=0;\n\tfor(;x;x/=10)wr[++top]=x%10+'0';\n\twhile(top)putchar(wr[top--]);\n\tputchar(y);\n}\nvoid file()\n{\n#ifndef ONLINE_JUDGE\n\tfreopen(\"E.in\",\"r\",stdin);\n\tfreopen(\"E.out\",\"w\",stdout);\n#endif\n}\nint n,a[N];\nvoid input()\n{\n\tn=read<int>();\n\tFor(i,1,n)a[i]=read<int>();\n}\nvector<int>E[N],s[N];\nbool vis[N];\npriority_queue<int>q;\n#define pb push_back\nint d[N];\nvoid dfs(int u)\n{\n\tvis[u]=1;\n\tsort(E[u].begin(),E[u].end());\n\tfor(int v:E[u])if(!vis[v])\n\t{\n\t\ts[u].pb(v),d[v]++;\n\t\tdfs(v);\n\t}\n}\nvoid work()\n{\n\tsort(a+1,a+n+1);\n\tFor(i,1,n)For(j,i+1,n)\n\t{\n\t\tif(__gcd(a[i],a[j])!=1)\n\t\t{\n\t\t\tE[i].pb(j),E[j].pb(i);\t\t\n\t\t\t//cerr<<i<<' '<<j<<endl;\n\t\t}\n\t}\n\tFor(i,1,n)if(!vis[i])\n\t{\n\t\tdfs(i),q.push(i);\n\t}\n\tint u;\n\twhile(!q.empty())\n\t{\n\t\tu=q.top();q.pop();\n\t\twrite(a[u],' ');\n\t\tfor(int v:s[u])if(!--d[v])q.push(v);\n\t}\n}\nint main()\n{\n//\tfile();\n\tinput();\n\twork();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iomanip>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define all(x) (x).begin(),(x).end()\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n \ntemplate<class T> inline bool chmax(T &a, T b){\n    if(a<b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T> inline bool chmin(T &a, T b){\n    if(a>b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<typename T>\nT gcd(T a, T b)\n{\n    return b ? gcd(b, a % b) : a;\n}\n\ntemplate<typename T>\nT lcm(T a,T b)\n{\n    return  a / gcd(a,b) * b;\n}\nclass UnionFind {\nprivate:\n    int sz;\n    vector<int> par, size_;\npublic:\n    UnionFind(){}\n    UnionFind(int node_size) : sz(node_size), par(sz), size_(sz, 1){\n        iota(par.begin(), par.end(), 0);\n    }\n    int find(int x){\n        if(par[x] == x) return x;\n        else return par[x] = find(par[x]);\n    }\n    void unite(int x,int y){\n        x = find(x), y = find(y);\n        if(x == y) return;\n        if(size_[x] < size_[y]) swap(x,y);\n        par[y] = x;\n        size_[x] += size_[y];\n    }\n    int size(int x){\n        x = find(x);\n        return size_[x];\n    }\n    bool same(int x,int y){\n        return find(x) == find(y);\n    }\n};\ntemplate<class _Key, class _Hash, bool DOWNSIZE> class UnorderedSetIterator;\n \ntemplate<class _Key, class _Hash = hash<_Key>, bool DOWNSIZE = false>\nclass UnorderedSet\n{\nprivate:\n    using iterator = UnorderedSetIterator<_Key, _Hash, DOWNSIZE>;\n    friend UnorderedSetIterator<_Key, _Hash, DOWNSIZE>;\n    struct bucket {\n        _Key _key;\n        short int _dist;\n        bool _last, _end;\n        bucket() noexcept : _dist(-1), _last(false), _end(false){}\n        bucket& operator=(const bucket& another) = default;\n        ~bucket(){ if(!empty()) _key.~_Key(); }\n        inline void clear() noexcept { _dist = -1; }\n        inline void _delete(){ _dist = -1, _key.~_Key(); }\n        inline bool empty() const noexcept { return (_dist == -1); }\n    };\n    inline static unsigned int ceilpow2(unsigned int u) noexcept {\n        if(u == 0u) return 0u;\n        --u, u |= u >> 1, u |= u >> 2, u |= u >> 4, u |= u >> 8;\n        return (u | (u >> 16)) + 1;\n    }\n    inline static bucket *increment(bucket *cur) noexcept {\n        for(++cur; !cur->_end; ++cur){\n            if(!cur->empty()) break;\n        }\n        return cur;\n    }\n    inline bucket *next_bucket(bucket *cur) const noexcept {\n        return cur->_last ? _buckets : cur + 1;\n    }\n    inline unsigned int make_hash(const _Key& key) const noexcept {\n        return _Hash()(key);\n    }\n    inline float load_rate() const noexcept {\n        return (float)_data_count / _bucket_count;\n    }\n    bucket *insert(bucket *cur, short int dist, _Key&& key){\n        bucket *ret = cur;\n        bool flag = false;\n        while(true){\n            if(cur->empty()){\n                cur->_key = move(key), cur->_dist = dist;\n                if(!flag) ret = cur, flag = true;\n                break;\n            }else if(dist > cur->_dist){\n                swap(key, cur->_key), swap(dist, cur->_dist);\n                if(!flag) ret = cur, flag = true;\n            }\n            ++dist;\n            cur = next_bucket(cur);\n        }\n        return ret;\n    }\n    bucket *_find(const _Key& key) const {\n        bucket *cur = _buckets + (make_hash(key) & _mask);\n        int dist = 0;\n        while(dist <= cur->_dist){\n            if(key == cur->_key) return cur;\n            ++dist, cur = next_bucket(cur);\n        }\n        return _buckets + _bucket_count;\n    }\n    template<class Key>\n    bucket *find_insert(Key&& key){\n        unsigned int hash = make_hash(key);\n        bucket *cur = _buckets + (hash & _mask);\n        int dist = 0;\n        while(dist <= cur->_dist){\n            if(key == cur->_key) return cur;\n            ++dist, cur = next_bucket(cur);\n        }\n        ++_data_count;\n        if(rehash_check()){\n            cur = _buckets + (hash & _mask), dist = 0;\n        }\n        _Key new_key = forward<Key>(key);\n        return insert(cur, dist, move(new_key));\n    }\n    template<typename... Args>\n    bucket *emplace(Args&&... args){\n        return find_insert(_Key(forward<Args>(args)...));\n    }\n    bucket *backward_shift(bucket *cur, bool next_ret){\n        bucket *next = next_bucket(cur), *ret = cur;\n        if(next->_dist < 1) return next_ret ? increment(cur) : cur;\n        do {\n            cur->_key = next->_key, cur->_dist = next->_dist - 1;\n            cur = next, next = next_bucket(cur);\n        }while(next->_dist >= 1);\n        cur->clear();\n        return ret;\n    }\n    bucket *erase_impl(bucket *cur, bool next_ret){\n        assert(static_cast<size_t>(cur - _buckets) != _bucket_count);\n        cur->_delete();\n        --_data_count;\n        return backward_shift(cur, next_ret);\n    }\n    bucket *erase_itr(bucket *cur, bool next_ret = true){\n        const _Key key = cur->_key;\n        return erase_impl(rehash_check() ? _find(key) : cur, next_ret);\n    }\n    bucket *erase_key(const _Key& key, bool next_ret = true){\n        rehash_check();\n        return erase_impl(_find(key), next_ret);\n    }\n    bool rehash_check(){\n        if(_bucket_count == 0){\n            rehash(1u);\n            return true;\n        }else if(load_rate() >= MAX_LOAD_RATE){\n            rehash(_bucket_count * 2u);\n            return true;\n        }else if(DOWNSIZE){\n            if(load_rate() <= MIN_LOAD_RATE && _bucket_count >= DOWNSIZE_THRESHOLD){\n                rehash(_bucket_count / 2u);\n                return true;\n            }\n        }\n        return false;\n    }\n    void move_data(bucket *cur){\n        insert(_buckets + (make_hash(cur->_key) & _mask), 0, move(cur->_key));\n    }\n    void rehash(unsigned int new_bucket_count){\n        UnorderedSet new_unordered_set(new_bucket_count);\n        new_unordered_set._data_count = _data_count;\n        for(bucket *cur = _buckets; !cur->_end; ++cur){\n            if(!cur->empty()){\n                new_unordered_set.move_data(cur);\n            }\n        }\n        swap(*this, new_unordered_set);\n    }\n    friend void swap(UnorderedSet& ust1, UnorderedSet& ust2){\n        swap(ust1._bucket_count, ust2._bucket_count);\n        swap(ust1._mask, ust2._mask);\n        swap(ust1._data_count, ust2._data_count);\n        swap(ust1._buckets, ust2._buckets);\n    }\n \nprivate:\n    unsigned int _bucket_count, _mask, _data_count;\n    bucket *_buckets;\npublic:\n    const float MAX_LOAD_RATE = 0.5f;\n    const float MIN_LOAD_RATE = 0.1f;\n    const unsigned int DOWNSIZE_THRESHOLD = 16u;\n    UnorderedSet(unsigned int bucket_size = 0u)\n     : _bucket_count(ceilpow2(bucket_size)), _mask(_bucket_count - 1),\n        _data_count(0u), _buckets(new bucket[_bucket_count + 1]){\n        if(_bucket_count > 0) _buckets[_bucket_count - 1]._last = true;\n        else _mask = 0;\n        _buckets[_bucket_count]._end = true;\n    }\n    UnorderedSet(const UnorderedSet& another)\n        : _bucket_count(another._bucket_count), _mask(another._mask), _data_count(another._data_count){\n        _buckets = new bucket[_bucket_count + 1u];\n        for(unsigned int i = 0u; i <= _bucket_count; ++i){\n            _buckets[i] = another._buckets[i];\n        }\n    }\n    UnorderedSet(UnorderedSet&& another)\n        : _bucket_count(move(another._bucket_count)), _mask(move(another._mask)),\n            _data_count(move(another._data_count)), _buckets(another._buckets){\n        another._buckets = nullptr;\n    }\n    UnorderedSet& operator=(const UnorderedSet& another){\n        delete[] _buckets;\n        _bucket_count = another._bucket_count;\n        _mask = another._mask;\n        _data_count = another._data_count;\n        _buckets = new bucket[_bucket_count + 1u];\n        for(unsigned int i = 0u; i <= _bucket_count; ++i){\n            _buckets[i] = another._buckets[i];\n        }\n        return *this;\n    }\n    UnorderedSet& operator=(UnorderedSet&& another){\n        delete[] _buckets;\n        _bucket_count = move(another._bucket_count);\n        _mask = move(another._mask);\n        _data_count = move(another._data_count);\n        _buckets = another._buckets;\n        another._buckets = nullptr;\n        return *this;\n    }\n    void allocate(unsigned int element_size){\n        rehash(ceilpow2(ceil(element_size / MAX_LOAD_RATE) + 1));\n    }\n    ~UnorderedSet(){ delete[] _buckets; }\n    friend ostream& operator<< (ostream& os, UnorderedSet& ust) noexcept {\n        for(_Key& val : ust) os << val << \" \";\n        return os;\n    }\n    void clear(){\n        UnorderedSet new_unordered_set(1u);\n        swap(*this, new_unordered_set);\n    }\n    size_t size() const noexcept { return _data_count; }\n    size_t bucket_count() const noexcept { return _bucket_count; }\n    bool empty() const noexcept { return (_data_count == 0); }\n    iterator begin() noexcept {\n        return (_buckets->empty() && _bucket_count > 0) ? iterator(increment(_buckets)) : iterator(_buckets);\n    }\n    iterator end() noexcept { return iterator(_buckets + _bucket_count); }\n    iterator find(const _Key& key) const { return iterator(_find(key)); }\n    size_t count(const _Key& key) const { return (_find(key) != _buckets + _bucket_count); }\n    iterator insert(const _Key& key){ return iterator(find_insert(key)); }\n    iterator insert(_Key&& key){ return iterator(find_insert(move(key))); }\n    template<typename... Args>\n    iterator emplace(Args&&... args){ return iterator(_emplace(forward<Args>(args)...)); }\n    iterator erase(const _Key& key){ return iterator(erase_key(key)); }\n    iterator erase(const iterator& itr){ return iterator(erase_itr(itr.bucket_ptr)); }\n    void simple_erase(const _Key& key){ erase_key(key, false); }\n    void simple_erase(const iterator& itr){ erase_itr(itr.bucket_ptr, false); }\n \n    // DEBUG 用\n    short int maximum_distance() const noexcept {\n        short int ret = -1;\n        for(bucket *cur = _buckets; !cur->_end; ++cur){\n            ret = max(ret, cur->_dist);\n        }\n        return ret;\n    }\n};\n \ntemplate<class _Key, class _Hash, bool DOWNSIZE>\nclass UnorderedSetIterator {\nprivate:\n    friend UnorderedSet<_Key, _Hash, DOWNSIZE>;\n    typename UnorderedSet<_Key, _Hash, DOWNSIZE>::bucket *bucket_ptr;\n    using iterator_category = forward_iterator_tag;\n    using value_type = _Key;\n    using difference_type = ptrdiff_t;\n    using pointer = _Key*;\n    using reference = _Key&;\n \nprivate:\n    UnorderedSetIterator(typename UnorderedSet<_Key, _Hash, DOWNSIZE>::bucket *_bucket_ptr)\n        noexcept : bucket_ptr(_bucket_ptr){}\npublic:\n    UnorderedSetIterator() noexcept : bucket_ptr(){}\n    UnorderedSetIterator(const UnorderedSetIterator& itr) noexcept : bucket_ptr(itr.bucket_ptr){}\n    UnorderedSetIterator& operator=(const UnorderedSetIterator& itr)\n        & noexcept { return bucket_ptr = itr.bucket_ptr, *this; }\n    UnorderedSetIterator& operator=(const UnorderedSetIterator&& itr)\n        & noexcept { return bucket_ptr = itr.bucket_ptr, *this; }\n    reference operator*() const noexcept { return bucket_ptr->_key; }\n    pointer operator->() const noexcept { return &(bucket_ptr->_key); }\n    UnorderedSetIterator& operator++() noexcept {\n        return bucket_ptr = UnorderedSet<_Key, _Hash, DOWNSIZE>::increment(bucket_ptr), *this;\n    }\n    UnorderedSetIterator operator++(int) const noexcept {\n        return UnorderedSetIterator(UnorderedSet<_Key, _Hash, DOWNSIZE>::increment(this->bucket_ptr));\n    }\n    bool operator==(const UnorderedSetIterator& itr) const noexcept { return !(*this != itr); };\n    bool operator!=(const UnorderedSetIterator& itr) const noexcept { return bucket_ptr != itr.bucket_ptr; }\n};\n \ntemplate<class _Key, class _Tp, class _Hash, bool DOWNSIZE> class UnorderedMapIterator;\n \ntemplate<class _Key, class _Tp, class _Hash = hash<_Key>, bool DOWNSIZE = false>\nclass UnorderedMap\n{\nprivate:\n    using iterator = UnorderedMapIterator<_Key, _Tp, _Hash, DOWNSIZE>;\n    using value_type = _Tp;\n    using data_type = pair<_Key, _Tp>;\n    using aligned_pointer = typename aligned_storage<sizeof(value_type), alignof(value_type)>::type;\n    friend UnorderedMapIterator<_Key, _Tp, _Hash, DOWNSIZE>;\n    struct bucket {\n        _Key _key;\n        short int _dist;\n        bool _last, _end;\n        aligned_pointer _value_ptr;\n        bucket() noexcept : _dist(-1), _last(false), _end(false){}\n        bucket& operator=(const bucket& another) noexcept {\n            _key = another._key, _dist = another._dist, _last = another._last, _end = another._end;\n            if(!another.empty()){\n                new(&_value_ptr) value_type(*reinterpret_cast<const value_type*>(&another._value_ptr));\n            }\n            return *this;\n        }\n        ~bucket(){ if(!empty()) _delete(); }\n        inline void clear() noexcept { _dist = -1; }\n        inline void _delete(){ _dist = -1, value_ptr()->~value_type(); }\n        inline bool empty() const noexcept { return (_dist == -1); }\n        inline value_type& value() noexcept {\n            return *reinterpret_cast<value_type*>(&_value_ptr);\n        }\n        inline value_type* value_ptr() noexcept {\n            return reinterpret_cast<value_type*>(&_value_ptr);\n        }\n        inline void new_value(value_type&& value){\n            new(&_value_ptr) value_type(move(value));\n        }\n    };\n    inline static unsigned int ceilpow2(unsigned int u) noexcept {\n        if(u == 0u) return 0u;\n        --u, u |= u >> 1, u |= u >> 2, u |= u >> 4, u |= u >> 8;\n        return (u | (u >> 16)) + 1u;\n    }\n    inline static bucket *increment(bucket *cur) noexcept {\n        for(++cur; !cur->_end; ++cur){\n            if(!cur->empty()) break;\n        }\n        return cur;\n    }\n    inline bucket *next_bucket(bucket *cur) const noexcept {\n        return cur->_last ? _buckets : cur + 1;\n    }\n    inline unsigned int make_hash(const _Key& key) const noexcept {\n        return _Hash()(key);\n    }\n    inline float load_rate() const noexcept {\n        return (float)_data_count / _bucket_count;\n    }\n    bucket *insert(bucket *cur, _Key&& key, short int dist, value_type&& value){\n        bucket *ret = cur;\n        bool flag = false;\n        while(true){\n            if(cur->empty()){\n                cur->_key = move(key), cur->_dist = dist, cur->new_value(move(value));\n                if(!flag) ret = cur, flag = true;\n                break;\n            }else if(dist > cur->_dist){\n                swap(key, cur->_key), swap(dist, cur->_dist), swap(value, cur->value());\n                if(!flag) ret = cur, flag = true;\n            }\n            ++dist;\n            cur = next_bucket(cur);\n        }\n        return ret;\n    }\n    template<class Key>\n    bucket *_find(Key&& key, bool push = false){\n        unsigned int hash = make_hash(key);\n        bucket *cur = _buckets + (hash & _mask);\n        short int dist = 0;\n        while(dist <= cur->_dist){\n            if(key == cur->_key) return cur;\n            ++dist, cur = next_bucket(cur);\n        }\n        if(!push) return _buckets + _bucket_count;\n        ++_data_count;\n        if(rehash_check()){\n            cur = _buckets + (hash & _mask), dist = 0;\n        }\n        value_type new_value = value_type();\n        _Key new_key = forward<Key>(key);\n        return insert(cur, move(new_key), dist, move(new_value));\n    }\n    template<class Data>\n    bucket *find_insert(Data&& data){\n        const _Key& key = data.first;\n        unsigned int hash = make_hash(key);\n        bucket *cur = _buckets + (hash & _mask);\n        short int dist = 0;\n        while(dist <= cur->_dist){\n            if(key == cur->_key) return cur;\n            ++dist, cur = next_bucket(cur);\n        }\n        ++_data_count;\n        if(rehash_check()){\n            cur = _buckets + (hash & _mask), dist = 0;\n        }\n        data_type new_data = forward<Data>(data);\n        return insert(cur, move(new_data.first), dist, move(new_data.second));\n    }\n    template<typename... Args>\n    bucket *emplace(Args&&... args){\n        return find_insert(data_type(forward<Args>(args)...));\n    }\n    bucket *backward_shift(bucket *cur, bool next_ret){\n        bucket *next = next_bucket(cur), *ret = cur;\n        if(next->_dist < 1) return next_ret ? increment(cur) : cur;\n        do {\n            cur->_key = next->_key, cur->_dist = next->_dist - 1;\n            cur->new_value(move(next->value()));\n            cur = next, next = next_bucket(cur);\n        }while(next->_dist >= 1);\n        cur->clear();\n        return ret;\n    }\n    bucket *erase_impl(bucket *cur, bool next_ret){\n        assert(static_cast<size_t>(cur - _buckets) != _bucket_count);\n        cur->_delete();\n        --_data_count;\n        return backward_shift(cur, next_ret);\n    }\n    bucket *erase_itr(bucket *cur, bool next_ret = true){\n        const _Key key = cur->_key;\n        return erase_impl(rehash_check() ? _find(key) : cur, next_ret);\n    }\n    bucket *erase_key(const _Key& key, bool next_ret = true){\n        rehash_check();\n        return erase_impl(_find(key), next_ret);\n    }\n    bool rehash_check(){\n        if(_bucket_count == 0){\n            rehash(1u);\n            return true;\n        }else if(load_rate() >= MAX_LOAD_RATE){\n            rehash(_bucket_count * 2u);\n            return true;\n        }else if(DOWNSIZE){\n            if(load_rate() <= MIN_LOAD_RATE && _bucket_count >= DOWNSIZE_THRESHOLD){\n                rehash(_bucket_count / 2u);\n                return true;\n            }\n        }\n        return false;\n    }\n    void move_data(bucket *cur){\n        insert(_buckets + (make_hash(cur->_key) & _mask), move(cur->_key), 0, move(cur->value()));\n    }\n    void rehash(unsigned int new_bucket_count){\n        UnorderedMap new_unordered_map(new_bucket_count);\n        new_unordered_map._data_count = _data_count;\n        for(bucket *cur = _buckets; !cur->_end; ++cur){\n            if(!cur->empty()){\n                new_unordered_map.move_data(cur);\n            }\n        }\n        swap(*this, new_unordered_map);\n    }\n    friend void swap(UnorderedMap& ump1, UnorderedMap& ump2){\n        swap(ump1._bucket_count, ump2._bucket_count);\n        swap(ump1._mask, ump2._mask);\n        swap(ump1._data_count, ump2._data_count);\n        swap(ump1._buckets, ump2._buckets);\n    }\n \nprivate:\n    unsigned int _bucket_count, _mask, _data_count;\n    bucket *_buckets;\npublic:\n    const float MAX_LOAD_RATE = 0.5f;\n    const float MIN_LOAD_RATE = 0.1f;\n    const unsigned int DOWNSIZE_THRESHOLD = 16u;\n    UnorderedMap(unsigned int bucket_size = 0u)\n     : _bucket_count(ceilpow2(bucket_size)), _mask(_bucket_count - 1),\n        _data_count(0u), _buckets(new bucket[_bucket_count + 1]){\n        if(_bucket_count > 0) _buckets[_bucket_count - 1]._last = true;\n        else _mask = 0;\n        _buckets[_bucket_count]._end = true;\n    }\n    UnorderedMap(const UnorderedMap& another)\n        : _bucket_count(another._bucket_count), _mask(another._mask), _data_count(another._data_count){\n        _buckets = new bucket[_bucket_count + 1u];\n        for(unsigned int i = 0u; i <= _bucket_count; ++i){\n            _buckets[i] = another._buckets[i];\n        }\n    }\n    UnorderedMap(UnorderedMap&& another)\n        : _bucket_count(move(another._bucket_count)), _mask(move(another._mask)),\n            _data_count(move(another._data_count)), _buckets(another._buckets){\n        another._buckets = nullptr;\n    }\n    UnorderedMap& operator=(const UnorderedMap& another){\n        delete[] _buckets;\n        _bucket_count = another._bucket_count;\n        _mask = another._mask;\n        _data_count = another._data_count;\n        _buckets = new bucket[_bucket_count + 1u];\n        for(unsigned int i = 0u; i <= _bucket_count; ++i){\n            _buckets[i] = another._buckets[i];\n        }\n        return *this;\n    }\n    UnorderedMap& operator=(UnorderedMap&& another){\n        delete[] _buckets;\n        _bucket_count = move(another._bucket_count);\n        _mask = move(another._mask);\n        _data_count = move(another._data_count);\n        _buckets = another._buckets;\n        another._buckets = nullptr;\n        return *this;\n    }\n    void allocate(unsigned int element_size){\n        rehash(ceilpow2(ceil(element_size / MAX_LOAD_RATE) + 1));\n    }\n    ~UnorderedMap(){ delete[] _buckets; }\n    friend ostream& operator<< (ostream& os, UnorderedMap& ump) noexcept {\n        for(auto val : ump) os << '{' << val.first << ',' << val.second << \"} \";\n        return os;\n    }\n    _Tp& operator[](const _Key& key){ return _find(key, true)->value(); }\n    _Tp& operator[](_Key&& key){ return _find(move(key), true)->value(); }\n    const _Tp& at(const _Key& key){\n        bucket *res = _find(key);\n        if(res == _buckets + _bucket_count) __throw_out_of_range(__N(\"Unordered_Map::at\"));\n        return res->value();\n    }\n    void clear(){\n        UnorderedMap new_unordered_map(1u);\n        swap(*this, new_unordered_map);\n    }\n    size_t size() const noexcept { return _data_count; }\n    size_t bucket_count() const noexcept { return _bucket_count; }\n    bool empty() const noexcept { return (_data_count == 0); }\n    iterator begin() noexcept {\n        return (_buckets->empty() && _bucket_count > 0) ? iterator(increment(_buckets)) : iterator(_buckets);\n    }\n    iterator end() noexcept { return iterator(_buckets + _bucket_count); }\n    iterator find(const _Key& key){ return iterator(_find(key)); }\n    iterator insert(const data_type& data){ return iterator(find_insert(data)); }\n    iterator insert(data_type&& data){ return iterator(find_insert(move(data))); }\n    template<typename... Args>\n    iterator emplace(Args&&... args){ return iterator(_emplace(forward<Args>(args)...)); }\n    iterator erase(const _Key& key){ return iterator(erase_key(key)); }\n    iterator erase(const iterator& itr){ return iterator(erase_itr(itr.bucket_ptr)); }\n    void simple_erase(const _Key& key){ erase_key(key, false); }\n    void simple_erase(const iterator& itr){ erase_itr(itr.bucket_ptr, false); }\n \n    // DEBUG 用\n    short int maximum_distance() const noexcept {\n        short int ret = -1;\n        for(bucket *cur = _buckets; !cur->_end; ++cur){\n            ret = max(ret, cur->_dist);\n        }\n        return ret;\n    }\n};\n \ntemplate<class _Key, class _Tp, class _Hash, bool DOWNSIZE>\nclass UnorderedMapIterator {\nprivate:\n    friend UnorderedMap<_Key, _Tp, _Hash, DOWNSIZE>;\n    typename UnorderedMap<_Key, _Tp, _Hash, DOWNSIZE>::bucket *bucket_ptr;\n    using iterator_category = forward_iterator_tag;\n    using value_type = pair<const _Key, _Tp>;\n    using difference_type = ptrdiff_t;\n    using reference = pair<const _Key&, _Tp&>;\n \nprivate:\n    UnorderedMapIterator(typename UnorderedMap<_Key, _Tp, _Hash, DOWNSIZE>::bucket *_bucket_ptr)\n        noexcept : bucket_ptr(_bucket_ptr){}\npublic:\n    UnorderedMapIterator() noexcept : bucket_ptr(){}\n    UnorderedMapIterator(const UnorderedMapIterator& itr) noexcept : bucket_ptr(itr.bucket_ptr){}\n    UnorderedMapIterator& operator=(const UnorderedMapIterator& itr)\n        & noexcept { return bucket_ptr = itr.bucket_ptr, *this; }\n    UnorderedMapIterator& operator=(const UnorderedMapIterator&& itr)\n        & noexcept { return bucket_ptr = itr.bucket_ptr, *this; }\n    reference operator*() const noexcept { return {bucket_ptr->_key, bucket_ptr->value()}; }\n    UnorderedMapIterator& operator++() noexcept {\n        return bucket_ptr = UnorderedMap<_Key, _Tp, _Hash, DOWNSIZE>::increment(bucket_ptr), *this;\n    }\n    UnorderedMapIterator operator++(int) const noexcept {\n        return UnorderedMapIterator(UnorderedMap<_Key, _Tp, _Hash, DOWNSIZE>::increment(this->bucket_ptr));\n    }\n    bool operator==(const UnorderedMapIterator& itr) const noexcept { return !(*this != itr); };\n    bool operator!=(const UnorderedMapIterator& itr) const noexcept { return bucket_ptr != itr.bucket_ptr; }\n};\n \n// 多重辺は無いと仮定する\nclass BSTNode {\npublic:\n    struct murmur_hash32 {\n        unsigned int operator()(int p) const {\n            const unsigned int m = 0x5bd1e995; p *= m;\n            unsigned int h = (p^(p>>24))*m;\n            return h = (h^(h>>13))*m, (h^(h>>15));\n        }\n    };\n    const int from, to;\n    int sz;\n    bool subtree_edge, subofftree_edge, exact_level;\n    BSTNode *left, *right, *par;\n    UnorderedSet<int, murmur_hash32, true> adjacent;\n    BSTNode(const int _ver) noexcept :\n        from(_ver), to(_ver), sz(0), subtree_edge(false), subofftree_edge(false),\n            exact_level(false), left(nullptr), right(nullptr), par(nullptr){}\n    BSTNode(const int _from, const int _to, const bool _flag) noexcept :\n        from(_from), to(_to), sz(0), subtree_edge(false), subofftree_edge(false),\n            exact_level((from < to) && _flag), left(nullptr), right(nullptr), par(nullptr){}\n    inline bool IsRoot() const noexcept { return !par; }\n    inline bool IsVertex() const noexcept { return (from == to); }\n    inline void eval() noexcept {\n        if(IsVertex()) sz = 1, subtree_edge = false, subofftree_edge = !adjacent.empty();\n        else sz = 0, subtree_edge = exact_level, subofftree_edge = false;\n        if(left){\n            sz += left->sz, subtree_edge |= left->subtree_edge, subofftree_edge |= left->subofftree_edge;\n        }\n        if(right){\n            sz += right->sz, subtree_edge |= right->subtree_edge, subofftree_edge |= right->subofftree_edge;\n        }\n    }\n    inline void subtree_edge_eval(){\n        subtree_edge = exact_level;\n        if(left) subtree_edge |= left->subtree_edge;\n        if(right) subtree_edge |= right->subtree_edge;\n    }\n    inline void subofftree_edge_eval(){\n        subofftree_edge = !adjacent.empty();\n        if(left) subofftree_edge |= left->subofftree_edge;\n        if(right) subofftree_edge |= right->subofftree_edge;\n    }\n    inline bool subofftree_check(){\n        return !adjacent.empty() ||\n                (left ? left->subofftree_edge : false) || (right ? right->subofftree_edge : false);\n    }\n    inline bool offtree_check(){\n        return adjacent.empty() ||\n                (left ? left->subofftree_edge : false) || (right ? right->subofftree_edge : false);\n    }\n    void rotate(const bool right_) noexcept {\n        BSTNode *p = par, *g = p->par;\n        if(right_){\n            if((p->left = right)) right->par = p;\n            right = p, p->par = this;\n        }else{\n            if((p->right = left)) left->par = p;\n            left = p, p->par = this;\n        }\n        p->eval(), eval();\n        if(!(par = g)) return;\n        if(g->left == p) g->left = this;\n        if(g->right == p) g->right = this;\n        g->eval();\n    }\n};\n \nBSTNode *splay(BSTNode *u) noexcept {\n    if(!u) return nullptr;\n    while(!(u->IsRoot())){\n        BSTNode *p = u->par, *gp = p->par;\n        if(p->IsRoot()){ // zig\n            u->rotate((u == p->left));\n        }else{\n            bool flag = (u == p->left);\n            if((u == p->left) == (p == gp->left)){ // zig-zig\n                p->rotate(flag), u->rotate(flag);\n            }else{ // zig-zag\n                u->rotate(flag), u->rotate(!flag);\n            }\n        }\n    }\n    return u;\n}\n \nBSTNode *join(BSTNode *root1, BSTNode *root2) noexcept {\n    if(!root1 || !root2) return root1 ? root1 : root2;\n    BSTNode *cur = nullptr, *nx = root1;\n    do{ cur = nx, nx = cur->right; }while(nx);\n    BSTNode *ver = splay(cur);\n    ver->right = root2, ver->eval(), root2->par = ver;\n    return ver;\n}\n \nclass EulerTourTree {\npublic:\n    struct murmur_hash64 {\n        unsigned long long operator()(unsigned long long p) const {\n            const unsigned long long m = 0xc6a4a7935bd1e995; p *= m;\n            unsigned long long h = (p^(p>>47))*m;\n            return h = (h^(h>>47))*m, (h^(h>>47));\n        }\n    };\n    inline static unsigned long long pair_to_ll(const int u, const int v){\n        return ((unsigned long long)(u) << 32) | v;\n    }\n    BSTNode** vertex_set;\n    UnorderedMap<unsigned long long, pair<BSTNode*, BSTNode*>, murmur_hash64> edge_set;\nprivate:\n    BSTNode *reroot(BSTNode *ver) noexcept {\n        BSTNode *res = splay(ver)->left;\n        if(!res) return ver;\n        ver->left = nullptr, ver->eval();\n        while(ver->right) ver = ver->right;\n        splay(ver), ver->right = res, ver->eval(), res->par = ver;\n        return ver;\n    }\n    void link(BSTNode *ver1, BSTNode *ver2, const bool flag) noexcept {\n        BSTNode *e1 = new BSTNode(ver1->from, ver2->from, flag);\n        BSTNode *e2 = new BSTNode(ver2->from, ver1->from, flag);\n        edge_set[pair_to_ll(ver1->from, ver2->from)] = {e1, e2};\n        join(join(reroot(ver1), e1), join(reroot(ver2), e2));\n    }\n    void cut(BSTNode *edge1, BSTNode *edge2) noexcept {\n        splay(edge1), splay(edge2);\n        BSTNode *p = edge1->par;\n        bool _right = (edge1 == edge2->right);\n        if(p != edge2){\n            _right = (p == edge2->right);\n            p->par = nullptr, edge1->rotate((edge1 == p->left));\n        }\n        if(edge1->left) edge1->left->par = nullptr;\n        if(edge1->right) edge1->right->par = nullptr;\n        if(_right){\n            if(edge2->left) edge2->left->par = nullptr;\n            join(edge2->left, edge1->right);\n        }else{\n            if(edge2->right) edge2->right->par = nullptr;\n            join(edge1->left, edge2->right);\n        }\n        // delete edge1; delete edge2;\n    }\n    bool connected(BSTNode *ver1, BSTNode *ver2) noexcept {\n        splay(ver1), splay(ver2);\n        return ver1->par;\n    }\n    int component_size(BSTNode *ver) noexcept { return splay(ver)->sz; }\npublic:\n    int V;\n    EulerTourTree(){}\n    // ~EulerTourTree(){\n    //     for(auto it : edge_set){\n    //         delete (it.second).first;\n    //         delete (it.second).second;\n    //     }\n    //     for(int i = 0; i < V; ++i) delete vertex_set[i];\n    //     delete[] vertex_set;\n    // }\n    void resize(const int node_size) noexcept {\n        V = node_size, vertex_set = new BSTNode*[V];\n        for(int i = 0; i < V; i++) vertex_set[i] = new BSTNode(i);\n    }\n    void reroot(const int node_id) noexcept { reroot(vertex_set[node_id]); }\n    void link(int node1_id, int node2_id, bool flag=true) noexcept {\n        if(node1_id > node2_id) swap(node1_id, node2_id);\n        link(vertex_set[node1_id], vertex_set[node2_id], flag);\n    }\n    void cut(int node1_id, int node2_id){\n        if(node1_id > node2_id) swap(node1_id, node2_id);\n        auto it = edge_set.find(pair_to_ll(node1_id, node2_id));\n        assert(it != edge_set.end());\n        BSTNode *edge1 = ((*it).second).first, *edge2 = ((*it).second).second;\n        edge_set.simple_erase(it);\n        cut(edge1, edge2);\n    }\n    bool connected(const int node1_id, const int node2_id) noexcept {\n        if(node1_id == node2_id) return true;\n        return connected(vertex_set[node1_id], vertex_set[node2_id]);\n    }\n    int component_size(int node_id) noexcept { return component_size(vertex_set[node_id]); }\n    void check_dfs(const BSTNode* cur) const noexcept {\n        if(cur->left) check_dfs(cur->left);\n        cout << \"{\" << (cur->from) << \",\" << (cur->to) << \"} \";\n        if(cur->right) check_dfs(cur->right);\n    }\n};\n \nclass DynamicConnectivity {\nprivate:\n    BSTNode *level_up_dfs(BSTNode *cur, const int layer) noexcept {\n        if(cur->exact_level){\n            splay(cur)->exact_level = false, cur->subtree_edge_eval();\n            detect_layer[EulerTourTree::pair_to_ll(cur->from, cur->to)]++;\n            et[layer+1].link(cur->from, cur->to);\n            return cur;\n        }\n        if(cur->left && cur->left->subtree_edge) return level_up_dfs(cur->left, layer);\n        if(cur->right && cur->right->subtree_edge) return level_up_dfs(cur->right, layer);\n        return nullptr;\n    }\n    BSTNode *search_edge_dfs\n        (BSTNode *cur, const int layer, const int another, bool& flag, pair<int, int>& rep_edge) noexcept {\n        if(!cur->adjacent.empty()){\n            bool state = et[layer+1].vertex_set[cur->from]->adjacent.empty();\n            for(auto it = cur->adjacent.begin(); it != cur->adjacent.end();){\n                pair<int, int> e = {min(cur->from, *it), max(cur->from, *it)};\n                BSTNode *correspond = et[layer].vertex_set[*it];\n                if(et[layer].connected(another, *it)){\n                    flag = true, rep_edge = e;\n                    cur->adjacent.simple_erase(it), correspond->adjacent.simple_erase(cur->from);\n                    if(!correspond->subofftree_check()){\n                        splay(correspond)->subofftree_edge_eval();\n                    }\n                    break;\n                }else{\n                    if(!et[layer+1].vertex_set[*it]->subofftree_check()){\n                        splay(et[layer+1].vertex_set[*it])->subofftree_edge = true;\n                    }\n                    et[layer+1].vertex_set[cur->from]->adjacent.insert(*it);\n                    et[layer+1].vertex_set[*it]->adjacent.insert(cur->from);\n                    detect_layer[EulerTourTree::pair_to_ll(e.first, e.second)]++;\n                    it = cur->adjacent.erase(it);\n                    correspond->adjacent.simple_erase(cur->from);\n                    if(!correspond->subofftree_check()){\n                        splay(correspond)->subofftree_edge_eval();\n                    }\n                }\n            }\n            if(state && !et[layer+1].vertex_set[cur->from]->offtree_check()){\n                splay(et[layer+1].vertex_set[cur->from])->subofftree_edge = true;\n            }\n            splay(cur)->subofftree_edge_eval();\n            return cur;\n        }\n        if(cur->left && cur->left->subofftree_edge){\n            return search_edge_dfs(cur->left, layer, another, flag, rep_edge);\n        }\n        if(cur->right && cur->right->subofftree_edge){\n            return search_edge_dfs(cur->right, layer, another, flag, rep_edge);\n        }\n        return nullptr;\n    }\n    bool replace(const int from, const int to, const int layer) noexcept {\n        if(layer < 0) return true;\n        int u, v;\n        if(et[layer].component_size(from) <= et[layer].component_size(to)) u = from, v = to;\n        else u = to, v = from;\n        BSTNode *ver = splay(et[layer].vertex_set[u]);\n        while(ver->subtree_edge) ver = level_up_dfs(ver, layer);\n        pair<int, int> rep_edge = {-1, -1};\n        bool flag = false;\n        while(ver->subofftree_edge){\n            ver = search_edge_dfs(ver, layer, v, flag, rep_edge);\n            if(flag) break;\n        }\n        if(flag){\n            et[layer].link(rep_edge.first, rep_edge.second);\n            for(int i = 0; i < layer; i++) et[i].link(rep_edge.first, rep_edge.second, false);\n            return false;\n        }else return replace(from, to, layer-1);\n    }\npublic:\n    const int V, layer_count;\n    EulerTourTree* et;\n    UnorderedMap<unsigned long long, int, EulerTourTree::murmur_hash64> detect_layer;\n    DynamicConnectivity(int node_size) noexcept : V(node_size), layer_count(ceil(log2(V))+1){\n        et = new EulerTourTree[layer_count];\n        for(int i = 0; i < layer_count; i++) et[i].resize(V);\n    }\n    // ~DynamicConnectivity(){\n    //     delete[] et;\n    // }\n    bool link(int node1_id, int node2_id) noexcept {\n        if(node1_id > node2_id) swap(node1_id, node2_id);\n        detect_layer[EulerTourTree::pair_to_ll(node1_id, node2_id)] = 0;\n        if(et[0].connected(node1_id, node2_id)){\n            BSTNode *ver1 = et[0].vertex_set[node1_id], *ver2 = et[0].vertex_set[node2_id];\n            splay(ver1)->subofftree_edge = true, ver1->adjacent.insert(node2_id);\n            splay(ver2)->subofftree_edge = true, ver2->adjacent.insert(node1_id);\n            return false;\n        }else{\n            et[0].link(node1_id, node2_id);\n            return true;\n        }\n    }\n    bool cut(int node1_id, int node2_id) noexcept {\n        if(node1_id > node2_id) swap(node1_id, node2_id);\n        auto it = detect_layer.find(EulerTourTree::pair_to_ll(node1_id, node2_id));\n        assert(it != detect_layer.end());\n        int layer = (*it).second;\n        detect_layer.simple_erase(it);\n        auto& st = et[layer].vertex_set[node1_id]->adjacent;\n        if(st.find(node2_id) == st.end()){\n            for(int i = 0; i <= layer; i++) et[i].cut(node1_id, node2_id);\n            return replace(node1_id, node2_id, layer);\n        }else{\n            et[layer].vertex_set[node1_id]->adjacent.simple_erase(node2_id);\n            if(!et[layer].vertex_set[node1_id]->subofftree_check()){\n                splay(et[layer].vertex_set[node1_id])->subofftree_edge_eval();\n            }\n            et[layer].vertex_set[node2_id]->adjacent.simple_erase(node1_id);\n            if(!et[layer].vertex_set[node2_id]->subofftree_check()){\n                splay(et[layer].vertex_set[node2_id])->subofftree_edge_eval();\n            }\n            return false;\n        }\n    }\n    bool connected(const int node1_id, const int node2_id) noexcept {\n        return et[0].connected(node1_id, node2_id);\n    }\n};\n\nint a[4000];\nvector<int> calc(pii e_min,vector<vector<int> > &g,UnorderedSet<int> &st,DynamicConnectivity &dc){\n    vector<int> res;\n    res.push_back(e_min.first);\n    if(st.size()==1){\n        st.erase(e_min.second);\n        return res;\n    }\n    int id = e_min.second;\n    vector<pii> v;\n    st.erase(id);\n    for(auto x:g[id]){\n        if(st.count(x)==1){\n            dc.cut(id,x);\n            v.push_back(MP(a[x],x));\n        }\n    }\n    sort(v.begin(),v.end());\n    vector<vector<int> > ss;\n    for(auto &x:v){\n        if(st.count(x.second)==0)continue;\n        UnorderedSet<int> p;\n        for(auto &y:st){\n            if(dc.connected(x.second,y)){\n                p.insert(y);\n            }\n        }\n        for(auto y:p){\n            st.erase(y);\n        }\n        ss.push_back(calc(x,g,p,dc));\n    }\n    priority_queue<pair<int,pii > > pp;\n    int m = ss.size();\n    rep(i,m){\n        pp.push(MP(ss[i][0],MP(i,0)));\n    }\n    while(!pp.empty()){\n        auto x = pp.top();\n        pp.pop();\n        res.push_back(x.first);\n        if(ss[x.second.first].size()!=x.second.second+1){\n            pp.push(MP(ss[x.second.first][x.second.second+1],MP(x.second.first,x.second.second+1)));\n        }\n    }\n    return res;\n}\n\nint main(){\n    int n;\n    cin >> n;\n    \n    rep(i,n){\n        cin >> a[i];\n    }\n    DynamicConnectivity dc(n);\n    vector<vector<int> > g(n);\n    UnionFind uf(n);\n    rep(i,n){\n        for(int j=i+1;j<n;j++){\n            if(gcd(a[i],a[j])!=1){\n                g[i].push_back(j);\n                g[j].push_back(i);\n                dc.link(i,j);\n                uf.unite(i,j);\n            }\n        }\n    }\n    vector<pair<int,int> > p(n,MP(inf,inf));\n    vector<UnorderedSet<int> > st(n);\n    rep(i,n){\n        p[uf.find(i)] = min(MP(a[i],i),p[uf.find(i)]);\n        st[uf.find(i)].insert(i);\n    }\n    vector<bool> used(n);\n    vector<vector<int> > res;\n    rep(i,n){\n        if(!used[uf.find(i)]){\n            int k = uf.find(i);\n            used[k] = 1;\n            auto ss = p[k];\n            res.push_back(calc(ss,g,st[k],dc));\n        }\n    }\n    priority_queue<pair<int,pii > > pp;\n    int m = res.size();\n    rep(i,m){\n        pp.push(MP(res[i][0],MP(i,0)));\n    }\n    vector<int> ans;\n    while(!pp.empty()){\n        auto x = pp.top();\n        pp.pop();\n        ans.push_back(x.first);\n        if(res[x.second.first].size()!=x.second.second+1){\n            pp.push(MP(res[x.second.first][x.second.second+1],MP(x.second.first,x.second.second+1)));\n        }\n    }\n    for(auto x:ans){\n        cout << x << \" \";\n    }\n    cout << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <map>\n#define MAXN 2010\n#define MAXM 100010\nusing namespace std;\n\nstruct edge{\n\tint to,next;\n\tedge(int _to=0,int _next=0):to(_to),next(_next){}\n}e[MAXM<<1];\n\nint n,numn;\nint a[MAXN];\nbool flag[10010];\nint prime[10010],nump;\nint g[MAXM],nume;\nint d[MAXN][MAXN];\nbool tag[MAXM],visit[MAXM],used[MAXM];\nmap<int,int> Sp;\nint c[MAXN],numc;\nint maxv[MAXN],totmax,totmax2;\n\nvoid addEdge(int u,int v){\n\te[nume]=edge(v,g[u]);\n\tg[u]=nume++;\n}\n\nint gcd(int x,int y){\n\tif(!y) return x;\n\treturn gcd(y,x%y);\n}\n\nvoid init(){\n\tfor(int i=2;i<10010;i++){\n\t\tif(!flag[i]) prime[++nump]=i;\n\t\tfor(int j=1;j<=nump && i*prime[j]<10010;j++){\n\t\t\tflag[i*prime[j]]=1;\n\t\t\tif(i%prime[j]==0) break;\n\t\t}\n\t}\n}\n\nvoid pre_gao(int x,int v){\n\tint v0=v;\n\tfor(int i=1;i<=nump && prime[i]*prime[i]<=v0;i++)\n\t\tif(v%prime[i]==0){\n\t\t\twhile(v%prime[i]==0) v/=prime[i];\n\t\t\tif(!Sp.count(prime[i])) Sp[prime[i]]=++numn;\n\t\t\taddEdge(x,Sp[prime[i]]);\n\t\t\taddEdge(Sp[prime[i]],x);\n\t\t}\n\tif(v>1){\n\t\tif(!Sp.count(v)) Sp[v]=++numn;\n\t\taddEdge(x,Sp[v]);\n\t\taddEdge(Sp[v],x);\n\t}\n}\n\nvoid dfs(int x){\n\tvisit[x]=1;\n\tc[x]=numc;\n\tif(tag[x] && a[x]<maxv[numc]) maxv[numc]=a[x];\n\tfor(int i=g[x];~i;i=e[i].next)\n\t\tif(!used[e[i].to] && !visit[e[i].to]){\n\t\t\tdfs(e[i].to);\n\t\t}\n}\n\nint gao(){\n\tfor(int i=1;i<=numn;i++) visit[i]=0;\n\ttotmax2=totmax=numc=0;\n\tfor(int i=1;i<=n;i++)\n\t\tif(!used[i] && !visit[i]){\n\t\t\tmaxv[++numc]=1<<30;\n\t\t\tdfs(i);\n\t\t\tif(maxv[numc]>totmax){\n\t\t\t\ttotmax2=totmax;\n\t\t\t\ttotmax=maxv[numc];\n\t\t\t}else if(maxv[numc]>totmax2) totmax2=maxv[numc];\n\t\t}\n\tint minv=1<<30;\n\tfor(int i=1;i<=n;i++)\n\t\tif(!used[i] && tag[i] && a[i]<minv){\n\t\t\tif(maxv[c[i]]==totmax && a[i]<totmax2) continue;\n\t\t\tif(maxv[c[i]]!=totmax && a[i]<totmax) continue;\n\t\t\tminv=a[i];\n\t\t}\n\tfor(int i=1;i<=n;i++)\n\t\tif(!used[i] && tag[i] && a[i]==minv){\n\t\t\tused[i]=1;\n\t\t\tfor(int j=1;j<=n;j++)\n\t\t\t\tif(tag[j] && a[j]>a[i]) \n\t\t\t\t\ttag[j]=0;\n\t\t\tfor(int j=1;j<=n;j++)\n\t\t\t\tif(!used[j] && !tag[j] && d[j][i]!=1)\n\t\t\t\t\ttag[j]=1;\n\t\t}\n\treturn minv;\n}\n\nint main(){\n\tmemset(g,-1,sizeof g);\n\tinit();\n\tscanf(\"%d\",&n);\n\tnumn=n;\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d\",a+i);\n\t\tpre_gao(i,a[i]);\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\td[i][j]=gcd(a[i],a[j]);\n\tfor(int i=1;i<=n;i++) tag[i]=1;\n\tfor(int i=1;i<=n;i++) printf(\"%d \",gao());\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\",\"inline\",\"-ffast-math\")\n#pragma GCC target(\"avx,sse2,sse3,sse4,mmx\")\n#include <bits/stdc++.h>\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/hash_policy.hpp>\nusing namespace __gnu_pbds;\nusing namespace std;\n\nint n,a[2010];\nvector<int> v[2010];\nbool vis[2010][2010],c[2010][2010],used[2010];\nvector<int> dp[2010];\n\ninline int gcd(int a,int b)\n{\n\tif(b==0) return a;\n\treturn gcd(b,a%b);\n}\n\ninline void dfs2(int u,int x,vector<int>&res)\n{\n\tres.push_back(x);\n\tfor(int i=0;i<v[x].size();i++) if(!used[v[x][i]]&&!vis[u][v[x][i]]&&c[u][v[x][i]]){\n\t\tvis[u][v[x][i]]=1;\n\t\tdfs2(u,v[x][i],res);\n\t}\n}\n\ninline void dfs(int x)\n{\n\tused[x]=1;\n\tvector<vector<int> > w;\n\tvector<int> res;\n\tfor(int i=0;i<v[x].size();i++) if(!used[v[x][i]]&&!vis[x][v[x][i]]){\n\t\tvis[x][v[x][i]]=1;res.clear();dfs2(x,v[x][i],res);\n\t\tsort(res.begin(),res.end());\n\t\tdfs(res[0]);\n\t\tw.push_back(dp[res[0]]);\n\t}\n\tsort(w.begin(),w.end());\n\tdp[x].push_back(x);\n\tfor(int i=w.size()-1;i>=0;i--) for(int j=0;j<w[i].size();j++) dp[x].push_back(w[i][j]);\n}\n\nsigned main()\n{\n\tios::sync_with_stdio(false);\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=i+1;j<=n;j++){\n\t\t\tif(gcd(a[i],a[j])>1){\n\t\t\t\tv[i].push_back(j);\n\t\t\t\tv[j].push_back(i);\n\t\t\t\tc[i][j]=1;c[j][i]=1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tv[0].push_back(i);v[i].push_back(0);c[0][i]=1;c[i][0]=1;\n\t}\n\tdfs(0);\n\tfor(int i=1;i<dp[0].size();i++) cout<<a[dp[0][i]]<<\" \";\n\tcout<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 2010;\n\nint n, a[maxn], tim;\nint _vis[maxn], _mn = 0, in[maxn], vis[maxn], fa[maxn], mn[maxn];\nvector<int> ans, vec[maxn*20];\nvector<int> prm[maxn], tot_prm;\n\nint gcd(int x, int y) {\n\tif (!y) return x;\n\treturn gcd(y, x % y);\n}\n\nvoid _dfs(int u) {\n\t_mn = min(_mn, u);\n\t_vis[u] = 1;\n\tfor (int v = 1; v <= n; v++) {\n\t\tif (gcd(a[u], a[v]) != 1 && !_vis[v]) {\n\t\t\t_dfs(v);\n\t\t}\n\t}\n}\n\nint getroot(int x) {\n\tif (x == fa[x]) return x;\n\treturn fa[x] = getroot(fa[x]);\n}\n\nvoid Union(int x, int y) {\n\tint rx = getroot(x), ry = getroot(y);\n\tif (rx != ry) {\n\t\tfa[rx] = ry;\n\t\tmn[ry] = min(mn[ry], mn[rx]);\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n\tsort(a + 1, a + n + 1);\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x = a[i];\n\t\tfor (int j = 2; j * j <= x; j++) {\n\t\t\tif (x % j == 0) {\n\t\t\t\tprm[i].push_back(j);\n\t\t\t\ttot_prm.push_back(j);\n\t\t\t\twhile (x % j == 0) {\n\t\t\t\t\tx /= j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (x > 1) {\n\t\t\tprm[i].push_back(x);\n\t\t\ttot_prm.push_back(x);\n\t\t}\n\t}\n\tsort(tot_prm.begin(), tot_prm.end());\n\ttot_prm.erase(unique(tot_prm.begin(), tot_prm.end()), tot_prm.end());\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 0; j < prm[i].size(); j++) {\n\t\t\tprm[i][j] = int (lower_bound(tot_prm.begin(), tot_prm.end(), prm[i][j]) - tot_prm.begin());\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (!_vis[i]) {\n\t\t\t_mn = n;\n\t\t\t_dfs(i);\n\t\t\tin[_mn] = 1;\n\t\t}\n\t}\n\tfor (int T = 1; T <= n; T++) {\n\t\tfor (int i = 0; i < tot_prm.size(); i++) vec[i].clear();\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfa[i] = i;\n\t\t\tmn[i] = (in[i] ? i : n);\n\t\t\tif (!vis[i]) {\n\t\t\t\tfor (int j = 0; j < prm[i].size(); j++) {\n\t\t\t\t\tvec[prm[i][j]].push_back(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < tot_prm.size(); i++) {\n\t\t\tfor (int j = 0; j + 1 < vec[i].size(); j++) {\n\t\t\t\tint x = vec[i][j], y = vec[i][j+1];\n\t\t\t\tUnion(x, y);\n\t\t\t}\n\t\t}\n\t\tint mx = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (!vis[i]) {\n\t\t\t\tmx = max(mx, mn[getroot(i)]);\n\t\t\t}\n\t\t}\n\t\tvis[mx] = 1; ans.push_back(a[mx]);\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (getroot(i) == getroot(mx)) {\n\t\t\t\tin[i] = (gcd(a[i], a[mx]) != 1);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < ans.size(); i++) printf(\"%d \", ans[i]);\n\tputs(\"\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#define pb push_back\nusing namespace std;\nconst int N=2100;\nstruct Node\n{\n\tint id,val;\n\tint operator < (const Node&A) const\n\t\t{return val<A.val;}\n};\npriority_queue<Node> Q;\nvector<int> E[N],W[N];\nint n,a[N],d[N],vis[N];\nvoid dfs(int x)\n{\n\tvis[x]=1;\n\tfor(auto R:E[x]) if(!vis[R]) W[x].pb(R);\n\tfor(auto R:E[x]) if(!vis[R]) dfs(R);\n}\nint main()\n{\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\tif(__gcd(a[i],a[j])>1) E[i].pb(j),E[j].pb(i);\n\tfor(int i=1;i<=n;i++) if(!vis[i]) dfs(i);\n\tfor(int i=1;i<=n;i++) for(auto R:W[i]) d[R]++;\n\tfor(int i=1;i<=n;i++) if(!d[i]) Q.push((Node){i,a[i]});\n\twhile(!Q.empty())\n\t{\n\t\tNode P=Q.top();int x=P.id;\n\t\tprintf(\"%d \",a[x]);Q.pop();\n\t\tfor(auto R:W[x])\n\t\t\tif(--d[R]==0) Q.push((Node){R,a[R]});\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\nusing uint=unsigned;\nusing ll=long long;\nusing ull=unsigned long long;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing vl=vector<ll>;\nusing vvl=vector<vl>;\nusing vd=vector<double>;\nusing vvd=vector<vd>;\nusing vs=vector<string>;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tprint_tuple<Cdr...>(os,t);\n\tos<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\nvi merge(const vi& a,const vi& us,const vi& vs)\n{\n\tvi res;\n\tint i=0,j=0;\n\twhile(i<us.size()&&j<vs.size())\n\t\tres.push_back(a[us[i]]>=a[vs[j]]?us[i++]:vs[j++]);\n\tres.insert(end(res),i+all(us));\n\tres.insert(end(res),j+all(vs));\n\treturn res;\n}\n\nvi dfs(const vvi& g,const vi& a,int u,vi& vis)\n{\n\tvis[u]=1;\n\tvi res;\n\tfor(int v:g[u]) if(!vis[v])\n\t\tres=merge(a,res,dfs(g,a,v,vis));\n\tres.insert(begin(res),u);\n\treturn res;\n}\n\nint main()\n{\n\tfor(int n;cin>>n&&n;){\n\t\tvi a(n);\n\t\trep(i,n) cin>>a[i];\n\t\tsort(all(a));\n\t\tvvi g(n);\n\t\trep(i,n) repi(j,i+1,n) if(__gcd(a[i],a[j])!=1){\n\t\t\tg[i].push_back(j);\n\t\t\tg[j].push_back(i);\n\t\t}\n\t\tvi vis(n),res;\n\t\trep(i,n) if(!vis[i])\n\t\t\tres=merge(a,res,dfs(g,a,i,vis));\n\t\trep(i,n) cout<<a[res[i]]<<\" \\n\"[i==n-1];\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int nmax = 1e5 + 10;\n\nint n;\nint a[nmax];\n\nbool used[nmax];\nvector < int > g[nmax];\n\nvector < int > _merge(vector < int > a, vector < int > b) {\n    vector < int > res;\n\n    int it1 = 0; int it2 = 0;\n    while (it1 < a.size() || it2 < b.size()) {\n        if (it1 == a.size())\n            res.push_back(b[it2++]);\n        else if (it2 == b.size())\n            res.push_back(a[it1++]);\n        else\n            (a[it1] > b[it2]) ? res.push_back(a[it1++]) : res.push_back(b[it2++]);\n    }\n\n    return res;\n}\n\nvector < int > dfs(int node) {\n    used[node] = 1;\n\n    vector < int > res;\n    for (auto &it : g[node]) {\n        if (used[it]) continue;\n        res = _merge(res, dfs(it));\n    }\n\n    res.push_back(0);\n    for (int i = res.size() - 1; i ; --i) res[i] = res[i-1];\n    res[0] = a[node];\n\n    return res;\n}\n\nint gcd(int a, int b) {\n    while (b) {\n        int r = a % b;\n        a = b;\n        b = r;\n    }\n\n    return a;\n}\n\nint main()\n{\n    //freopen(\"input\",\"r\",stdin);\n    //freopen(\"output\",\"w\",stdout);\n\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; ++i)\n        scanf(\"%d\", &a[i]);\n\n    sort(a + 1, a + n + 1);\n    for (int i = 1; i <= n; ++i)\n        for (int j = i + 1; j <= n; ++j) {\n            if (gcd(a[i], a[j]) == 1) continue;\n            g[i].push_back(j);\n            g[j].push_back(i);\n        }\n\n    vector < int > ans;\n    for (int i = 1; i <= n; ++i) {\n        if (used[i]) continue;\n        ans = _merge(ans, dfs(i));\n    }\n\n    for (auto &it : ans) printf(\"%d \", it);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nconst int MAX=2005;\nvector<int> llist[MAX];\nint a[MAX],visited[MAX],n,num,used[MAX];\nint gcd(int x,int y)\n{\n\tif(x%y==0) return y;\n\telse return gcd(y,x%y);\n}\nvoid dfs(int v)\n{\n\tvisited[v]=1;\n\tllist[num].push_back(v);\n\tint u=v-1;\n\twhile(u>0&&gcd(a[u],a[v])==1) u--;\n\tif(u>0) dfs(u);\n}\nint main()\n{\n\tcin>>n;\n\tfor(int i=1;i<=n;++i) cin>>a[i];\n\tsort(a+1,a+n+1);\n\tfor(int i=n;i>=1;--i){\n\t\tif(visited[i]==0){\n\t\t\tnum++;\n\t\t\tdfs(i);\n\t\t}\n\t}\n\tfor(int i=1;i<=num;++i){\n\t\tused[i]=llist[i].size()-1;\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\tint maximum=-1,index;\n\t\tfor(int j=1;j<=num;++j){\n\t\t\tif(used[j]>=0&&maximum<a[llist[j][used[j]]]){\n\t\t\t\tmaximum=a[llist[j][used[j]]];\n\t\t\t\tindex=j;\n\t\t\t}\n\t\t}\n\t\tcout<<maximum<<\" \";\n\t\tused[index]--;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst long double EPS=1e-13;\nconst long double PI=acos(-1.0);\nint ABS(int a){return max(a,-a);}\nlong long ABS(long long a){return max(a,-a);}\nlong double ABS(long double a){return max(a,-a);}\nint p[2100];\nmap<int,int>m;\nvector<int>q[2100];\nint gcd(int a,int b){\n\twhile(a){\n\t\tb%=a;swap(a,b);\n\t}return b;\n}\nvector<int>rev[2100];\nvector<int>f(vector<int>a,int x){\n\tvector<int>ret;\n\tint at=-1;\n\tfor(int i=0;i<a.size();i++){\n\t\tif(gcd(x,p[a[i]])==1)continue;\n\t\tif(at==-1||p[a[i]]<p[a[at]]){\n\t\t\tat=i;\n\t\t}\n\t}\n\tif(at==-1)at=0;\n\tret.push_back(a[at]);\n\tvector<pair<int,int> > key;\n\n\tfor(int i=0;i<a.size();i++){\n\t\tif(at==i)continue;\n\t\tfor(int j=0;j<q[a[i]].size();j++){\n\t\t\tkey.push_back(make_pair(q[a[i]][j],i));\n\t\t}\n\t}\n\tstd::sort(key.begin(),key.end());\n\tfor(int i=0;i<a.size();i++){\n\t\trev[i].clear();\n\t}\n\tfor(int i=0;i<key.size();i++){\n\t\trev[key[i].second].push_back(i);\n\t}\n\t//for(int i=0;i<a.size();i++)printf(\"%d \",a[i]);printf(\"(%d): \",x);\n\t//printf(\"%d\\n\",at);\n\t//for(int i=0;i<ret.size();i++)printf(\"%d \",ret[i]);printf(\"\\n\");\n\n\tvector<int>v(a.size());\n\tqueue<int>Q;\n\tv[at]=1;\n\tvector<vector<int> > proj;\n\tfor(int i=0;i<a.size();i++){\n\t\tif(v[i])continue;\n\t\tvector<int>tmp;\n\t\tQ.push(i);\n\t\tv[i]=1;\n\t\twhile(Q.size()){\n\t\t\tint now=Q.front();Q.pop();\n\t\t\ttmp.push_back(a[now]);\n\t\t\tfor(int j=0;j<rev[now].size();j++){\n\t\t\t\tif(rev[now][j]&&key[rev[now][j]].first==key[rev[now][j]-1].first){\n\t\t\t\t\tint to=key[rev[now][j]-1].second;\n\t\t\t\t\tif(!v[to]){\n\t\t\t\t\t\tv[to]=1;\n\t\t\t\t\t\tQ.push(to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(rev[now][j]+1<key.size()&&key[rev[now][j]].first==key[rev[now][j]+1].first){\n\t\t\t\t\tint to=key[rev[now][j]+1].second;\n\t\t\t\t\tif(!v[to]){\n\t\t\t\t\t\tv[to]=1;\n\t\t\t\t\t\tQ.push(to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tproj.push_back(tmp);\n\t}\n\tfor(int i=0;i<proj.size();i++){\n\t\tvector<int>rv=f(proj[i],p[a[at]]);\n\t\tfor(int i=0;i<rv.size();i++)ret.push_back(rv[i]);\n\t}\n\t\n\treturn ret;\n}\nint id[2100];\nvector<int>g[2100];\nint used[2100];\nint main(){\n\tint a;scanf(\"%d\",&a);\n\tfor(int i=0;i<a;i++){\n\t\tscanf(\"%d\",p+i);\n\t}\n\tstd::sort(p,p+a);\n\tint sz=0;\n\tfor(int i=0;i<a;i++){\n\t\tint tmp=p[i];\n\t\tfor(int j=2;j*j<=tmp;j++){\n\t\t\tif(tmp%j==0){\n\t\t\t\tint at;\n\t\t\t\tif(m.count(j)){\n\t\t\t\t\tat=m[j];\n\t\t\t\t}else{\n\t\t\t\t\tm[j]=sz;\n\t\t\t\t\tat=sz++;\n\t\t\t\t}\n\t\t\t\tq[i].push_back(at);\n\t\t\t\twhile(tmp%j==0)tmp/=j;\n\t\t\t}\n\t\t}\n\t\tif(tmp>1){\n\t\t\tint at;\n\t\t\tif(m.count(tmp)){\n\t\t\t\tat=m[tmp];\n\t\t\t}else{\n\t\t\t\tm[tmp]=sz;\n\t\t\t\tat=sz++;\n\t\t\t}\n\t\t\tq[i].push_back(at);\n\t\t}\n\t}\n\tvector<int>st;\n\tfor(int i=0;i<a;i++)st.push_back(i);\n\tvector<int>tmp=f(st,0);\n\n\t//for(int i=0;i<tmp.size();i++)printf(\"%d \",tmp[i]);printf(\"\\n\");\n\tfor(int i=0;i<tmp.size();i++){\n\t\tfor(int j=i+1;j<tmp.size();j++){\n\t\t\tif(gcd(p[tmp[i]],p[tmp[j]])!=1){\n\t\t\t\tg[tmp[i]].push_back(tmp[j]);\n\t\t\t\tid[tmp[j]]++;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<a;i++){\n\t\tint at=-1;\n\t\tfor(int j=0;j<a;j++){\n\t\t\tif(used[j])continue;\n\t\t\tif(id[j])continue;\n\t\t\tif(at==-1||p[at]<p[j]){\n\t\t\t\tat=j;\n\t\t\t}\n\t\t}\n\t\tused[at]=1;\n\t\tprintf(\"%d \",p[at]);\n\t\tfor(int j=0;j<g[at].size();j++){\n\t\t\tid[g[at][j]]--;\n\t\t}\n\t}\n\tprintf(\"\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "//              +-- -- --++-- +-In the name of ALLAH-+ --++-- -- --+              \\\\\n\n#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define _sz(x) (int)x.size()\n\nusing namespace std ;\nusing ll = long long ;\nusing ld = long double ;\nusing pii = pair <int , int> ;\n\nint const N = 2000 + 20 , M = 30000 + 20 ,  MAX = 1e8 + 20 , S = 2e4 + 20 ;\nint n , a[N] ;\nvector <int> vec ;\n\nvector <int> g[M] ;\nint sz ;\nvector <int> comp[N] ;\n\nvector <int> save[N] ;\n\nint ans[N] , mn[N] , last[M] ;\nbool dead[N] , vis[M] ;\nint mx1 , mx2 , mn_val[N] ;\n\nvector <int> primes ;\nvoid pre () {\n\tbool np[S] ;\n\tmemset(np , 0 , sizeof np) ;\n\tfor (int i = 2 ; i < S ; i ++) {\n\t\tif (np[i]) continue ;\n\t\tprimes.push_back(i) ;\n\t\tfor (int j = 2 * i ; j < S ; j += i) np[j] = 1 ;\n\t}\n}\n\ninline vector<int> get (int x) {\t\t\n\tvector <int> vec ;\n\n\tfor (int j = 0 ; 1ll * primes[j] * primes[j] <= x ; j ++) {\n\t\tif (x % primes[j]) continue ;\n\t\tvec.push_back(primes[j]) ;\n\t\twhile (x % primes[j] == 0) x /= primes[j] ;\n\t}\n\tif (x > 1) vec.push_back(x) ;\n\n\treturn vec ;\n}\n\ninline int get_id (int x) {\n\treturn lower_bound(vec.begin() , vec.end() , x) - vec.begin() ;\n}\n\ninline bool cmp (int x , int y) { return a[x] < a[y] ; }\n\nvoid dfs (int v) {\n\tif (vis[v]) return ;\n\tif (v < n) {\n\t\tif (dead[v]) return ;\n\t\tcomp[sz].push_back(v) ;\n\t}\n\tvis[v] = 1 ;\n\n\tfor (int u : g[v]) dfs(u) ;\n}\n\nint main(){\n\tios::sync_with_stdio(false) , cin.tie(0) , cout.tie(0) ;\n\n\tpre() ;\n\n\tcin >> n ;\n\tfor (int i = 0 ; i < n ; i ++) {\n\t\tcin >> a[i] ;\n\n\t\tsave[i] = get(a[i]) ;\n\t\tfor (int x : save[i]) vec.push_back(x) ;\n\t}\n\n\tsort(vec.begin() , vec.end()) ;\n\tvec.resize( unique(vec.begin() , vec.end()) - vec.begin() ) ;\n\n\tfor (int i = 0 ; i < n ; i ++) {\n\t\tfor (int x : save[i]) {\n\t\t\tint u = i , v = n + get_id(x) ;\n\t\t\tg[u].push_back(v) ;\n\t\t\tg[v].push_back(u) ;\n\t\t}\n\t}\n\n\tmemset(last , -1 , sizeof last) ;\n\tmemset(mn , 63 , sizeof mn) ;\n\n\tfor (int i = 0 ; i < n ; i ++) {\n\t\tmemset(vis , 0 , sizeof vis) ;\n\t\tmx1 = 0 , mx2 = 0 ;\n\t\tsz = 0 ;\n\n\t\tfor (int v = 0 ; v < n ; v ++) {\n\t\t\tif (!dead[v] && !vis[v]) {\n\t\t\t\tcomp[sz].clear() ;\n\t\t\t\tdfs(v) ;\n\n\t\t\t\tsort(comp[sz].begin() , comp[sz].end() , cmp) ;\n\t\t\n\t\t\t\tmx2 = max(mx2 , a[comp[sz][0]]) ;\n\t\t\t\tif (mx2 > mx1) swap(mx1 , mx2) ;\n\n\t\t\t\tfor (int u : comp[sz]) mn_val[u] = a[comp[sz][0]] ;\n\t\t\t\t\n\t\t\t\tsz ++ ;\n\t\t\t}\n\t\t}\n\n\t\tint res = -1 ;\n\t\tfor (int j = 0 ; j < n ; j ++) {\n\t\t\tif (dead[j]) continue ;\n\n\t\t\tint val = (mn_val[j] == mx1 ? mx2 : mx1) ;\n\t\t\tif (val > a[j]) continue ;\n\n\t\t\tint pp = -1 ;\n\t\t\tfor (int x : save[j]) pp = max(pp , last[x]) ;\n\n\t\t\tif (mn[pp + 1] < a[j]) continue ;\n\n\t\t\tif (res == -1 || a[res] > a[j]) res = j ;\n\t\t}\n\n\t\tdead[res] = 1 ;\n\t\tans[i] = a[res] ;\n\t\tfor (int j = i ; j >= 0 ; j --) mn[j] = min(mn[j] , a[res]) ;\n\t\tfor (int x : save[res]) last[x] = i ;\n\t}\n\n\tfor (int i = 0 ; i < n ; i ++) cout << ans[i] << ' ' ; cout << '\\n' ;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string>\n#include<math.h>\n#include<stdlib.h>\n#include<set>\n#include<bitset>\n#include<map>\n#include<vector>\n#include<string.h>\n#include<algorithm>\n#include<iostream>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<cmath>\n#include<ctime>\n#include<complex>\n#include<list>\nusing namespace std;\n\nconst int N=2005;\nint n;\nint a[N],used[N];\nbool ok[N][N];\nvector<int> nei[N];\n\nvoid dfs(int x){\n\tused[x]=1;\n\tfor(int i=0;i<n;i++) if(!used[i]&&ok[i][x]) nei[x].push_back(i),dfs(i);\n}\n\nvoid out(int x){\n\tif(x!=n) printf(\"%d \",a[x]);\n\tused[x]=1;\n\tfor(int i=0;i<nei[x].size();i++){\n\t\tint to=nei[x][i];\n\t\tif(!used[to]) out(to);\n\t}\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++) scanf(\"%d\",a+i);\n\tsort(a,a+n);\n\tfor(int i=0;i<n;i++) for(int j=0;j<n;j++) ok[i][j]=(__gcd(a[i],a[j])>1);\n\tfor(int i=0;i<n;i++) if(!used[i]){\n\t\tnei[n].push_back(i);\n\t\tdfs(i);\n\t}\n\tmemset(used,0,sizeof(used));\n\tfor(int i=0;i<=n;i++){\n\t\tsort(nei[i].begin(),nei[i].end());\n\t\treverse(nei[i].begin(),nei[i].end());\n\t}\n\tout(n);\n\tputs(\"\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#pragma comment(linker, \"/STACK:128777216\")\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cctype>\n#include <cstring>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <ctime>\n#include<complex>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for (int i = (b)-1; i >= (a); i--)\n#define ITER(it,a) for (__typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a,value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int)a.size()\n#define ALL(a) a.begin(), a.end()\n#define PB push_back\n#define MP make_pair\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\ntypedef pair<long long, long long> PLL;\n\n\nconst double PI = acos(-1.0);\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst LL LINF = INF * (LL)INF;\n\nconst int MAX = 2000 + 47;\nconst int MOD = 1000 * 1000 * 1000 + 7;\n\n//#define DEBUG\nint A[MAX];\nint B[MAX];\nint C[MAX];\nint IND[MAX];\n\nvector<int> g[MAX];\nint U[MAX];\nvector<int> L[MAX];\nvector<int> P;\nint sz;\n\nint gcd(int a, int b)\n{\n\treturn b == 0 ? a : gcd(b, a % b);\n}\n\nint merge(int v, vector<int> A)\n{\n\tif (v != -1)\n\t{\n\t\tL[sz].push_back(v);\n\t}\n\n\tP.assign(SZ(A), 0);\n\twhile (1)\n\t{\n\t\tint ind = -1;\n\t\tFOR(i, 0, SZ(A))\n\t\t{\n\t\t\tif (P[i] < SZ(L[A[i]]))\n\t\t\t{\n\t\t\t\tind = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (ind == -1) break;\n\t\tFOR(i, 0, SZ(A))\n\t\t{\n\t\t\tif (P[i] < SZ(L[A[i]]) && L[A[i]][P[i]] > L[A[ind]][P[ind]])\n\t\t\t{\n\t\t\t\tind = i;\n\t\t\t}\n\t\t}\n\n\t\tL[sz].push_back(L[A[ind]][P[ind]]);\n\t\tP[ind]++;\n\t}\n\n\tsz++;\n\treturn sz - 1;\n}\n\nint dfs(int v)\n{\n\tU[v] = 1;\n\tvector<int> A;\n\tFOR(i, 0, SZ(g[v]))\n\t{\n\t\tint to = g[v][i];\n\t\tif (U[to]) continue;\n\t\tA.push_back(dfs(to));\n\t}\n\n\treturn merge(v, A);\n}\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t//freopen(\"out.txt\", \"w\", stdout);\n\t//ios::sync_with_stdio(false); cin.tie(0);\n\tint n;\n\tcin >> n;\n\tFOR(i, 0, n)\n\t{\n\t\tcin >> A[i];\n\t\tB[i] = A[i];\n\t}\n\n\tsort(B, B + n);\n\tint sz = unique(B, B + n) - B;\n\tFOR(i, 0, n)\n\t{\n\t\tint ind = lower_bound(B, B + sz, A[i]) - B;\n\t\tIND[i] = ind;\n\t\tC[ind]++;\n\t}\n\n\tFOR(i, 0, n)\n\t{\n\t\tFOR(j, 0, n)\n\t\t{\n\t\t\tif (i == j) continue;\n\t\t\tif (gcd(A[i], A[j]) == 1) continue;\n\t\t\tg[IND[i]].push_back(IND[j]);\n\t\t}\n\t}\n\n\tFOR(i, 0, n)\n\t{\n\t\tsort(ALL(g[i]));\n\t}\n\n#ifdef DEBUG\n\tcout << \"B=\" << endl;\n\tFOR(i, 0, sz)\n\t{\n\t\tcout << B[i] << \" \";\n\t}\n\tcout << endl;\n\tcout << \"g=\" << endl;\n\tFOR(i, 0, sz)\n\t{\n\t\tcout << i << \": \";\n\t\tFOR(j, 0, SZ(g[i])) cout << g[i][j] << \" \";\n\t\tcout << endl;\n\t}\n#endif\n\tvector<int> D;\n\tFOR(i, 0, sz)\n\t{\n\t\tif (!U[i])\n\t\t{\n\t\t\tD.push_back(dfs(i));\n\t\t}\n\t}\n\n\tint p = merge(-1,D);\n\tFOR(i, 0, SZ(L[p]))\n\t{\n\t\tint ind = L[p][i];\n\t\tFOR(j, 0, C[ind])\n\t\t{\n\t\t\tcout << B[ind] << \" \";\n\t\t}\n\t}\n\n\tcout << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=2005;\ntypedef long long ll;\nint n,a[N];\nint gcd(int x,int y){\n    if(!y) return x;\n    return gcd(y,x%y);\n}\nint G[N][N];\nstruct node{\n    int u,v,nxt;\n}e[N<<1];\nint head[N],cnt;\ninline void add(int u,int v){\n    e[++cnt].u=u;\n    e[cnt].v=v;\n    e[cnt].nxt=head[u];\n    head[u]=cnt;\n}\nbool vis[N];\nint rudu[N];\ninline void dfs(int u){\n    vis[u]=1;\n    for(int v=1;v<=n;v++)\n        if(G[u][v]&&!vis[v]){\n            add(u,v);\n            rudu[v]++;\n            dfs(v);\n        }\n}\nint ans[N];\ntypedef pair<int,int>pi;\npriority_queue<pi>q;\nint main()\n{\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n    sort(a+1,a+n+1);\n    for(int i=1;i<=n;i++)\n        for(int j=i+1;j<=n;j++)\n            if(gcd(a[i],a[j])>1) G[i][j]=G[j][i]=1;\n    for(int i=1;i<=n;i++)\n        if(!vis[i]) dfs(i);\n    int cnt=0;\n    for(int i=1;i<=n;i++)\n        if(!rudu[i]) q.push(pi(a[i],i));\n    while(!q.empty()){\n        int w=q.top().first,u=q.top().second;\n        q.pop();\n        ans[++cnt]=w;\n        for(int i=head[u];i;i=e[i].nxt){\n            int v=e[i].v;\n            rudu[v]--;\n            if(!rudu[v]) q.push(pi(a[v],v));\n        }\n    }\n    for(int i=1;i<n;i++) printf(\"%d \",ans[i]);\n    printf(\"%d\\n\",ans[n]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\t不互质的数两两连边\n\t先手的操作就是对边重定向\n\t后手到操作是找到最大的拓扑序\n*/\n#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#include <queue>\n#define N 2005\n\nusing namespace std;\n\nint n;\nint a[N], deg[N];\nbool gra[N][N], vis[N];\n\ninline int gcd(int u, int v) { return v ? gcd(v, u % v) : u; }\n\nvoid dfs(int u) {\n\tvis[u] = true;\n\tfor(int v = 1; v <= n; ++v) {\n\t\tif(vis[v] || !gra[u][v]) continue;\n\t\tgra[v][u] = false, ++deg[v];\n\t}\n\tfor(int v = 1; v <= n; ++v) {\n\t\tif(vis[v] || !gra[u][v]) continue;\n\t\tdfs(v);\n\t}\n\treturn;\n}\nvoid topo() {\n\tpriority_queue<int> hp;\n\tfor(int i = 1; i <= n; ++i)\n\t\tif(!deg[i]) hp.push(i);\n\twhile(!hp.empty()) {\n\t\tint u = hp.top(); hp.pop();\n\t\tprintf(\"%d \", a[u]);\n\t\tfor(int v = 1; v <= n; ++v)\n\t\t\tif(gra[u][v] && !--deg[v])\n\t\t\t\thp.push(v);\n\t}\n\tputchar('\\n');\n\treturn;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor(int i = 1; i <= n; ++i) scanf(\"%d\", &a[i]);\n\tsort(a + 1, a + 1 + n);\n\tfor(int i = 1; i <= n; ++i)\n\t\tfor(int j = i + 1; j <= n; ++j)\n\t\t\tgra[i][j] = gra[j][i] = (gcd(a[i], a[j]) != 1);\n\tfor(int i = 1; i <= n; ++i)\n\t\tif(!vis[i])\tdfs(i);\n\ttopo();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <stack>\n#include <map>\n#include <set>\n#include <deque>\n#include <cstring>\n#include <functional>\n#include <climits>\n#include <list>\n#include <ctime>\n#include <complex>\n\n#define F1(x,y,z) for(int x=(y);x<(z);x++)\n#define F2(x,y,z) for(int x=(y);x<=(z);x++)\n#define F3(x,y,z) for(int x=(y);x>(z);x--)\n#define F4(x,y,z) for(int x=(y);x>=(z);x--)\n#define mp make_pair\n#define pb push_back\n#define LL long long\n#define co complex<double>\n#define fi first\n#define se second\n\n#define MAX 100005\n#define AMAX 1025*1005\n#define MOD 1000000007\n\n#define f(c,d) ((1<<(c))*(d))\n\nusing namespace std;\n\nint n,ta,x[2005],i,at[MAX];\nvector<int> np[2005],p,em;\nvector<vector<int> > ans;\nmap<int,int> m;\nmap<int,int>::iterator it;\nbool o,v[2005],vm[MAX];\npair<int,int> mi[MAX];\nvector<pair<int,int> > vn[MAX]; \npriority_queue<pair<int,int> > q;\npriority_queue<pair<int,int> > qq;\n\nvoid up(int a);\n\nvoid pp(int a){\n\tv[a]=1;\n\tq.push(mp(-x[a],a));\n}\n\nvoid up(int a){\n\twhile(at[a]!=vn[a].size()){\n\t\tif(!v[vn[a][at[a]].se]){\n\t\t\tpp(vn[a][at[a]].se);\n\t\t\tat[a]++;\n\t\t\tbreak;\n\t\t}else at[a]++;\n\t}\n}\n\nvoid upp(int a){\n\tif(at[a]!=ans[a].size()){\n\t\tqq.push(mp(ans[a][at[a]],a));\n\t\tat[a]++;\n\t}\n}\n\nint main(){\n\tF1(a,0,MAX)mi[a]=mp(INT_MAX,a);\n\tF2(a,2,10000){\n\t\to=1;\n\t\tF1(b,0,p.size()){\n\t\t\tif(p[b]*p[b]>a)break;\n\t\t\tif(a%p[b]==0){\n\t\t\t\to=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(o)p.pb(a);\n\t}\n\tscanf(\"%d\",&n);\n\tF1(a,0,n){\n\t\tscanf(\"%d\",x+a);\n\t\tta=x[a];\n\t\tF1(b,0,p.size()){\n\t\t\tif(p[b]*p[b]>ta)break;\n\t\t\tif(ta%p[b]==0){\n\t\t\t\ti=m.insert(mp(p[b],m.size())).fi->se;\n\t\t\t\tnp[a].pb(i);\n\t\t\t\tmi[i].fi=min(mi[i].fi,x[a]);\n\t\t\t\tvn[i].pb(mp(x[a],a));\n\t\t\t\twhile(ta%p[b]==0)ta/=p[b];\n\t\t\t}\n\t\t}\n\t\tif(ta!=1){\n\t\t\ti=m.insert(mp(ta,m.size())).fi->se;\n\t\t\tnp[a].pb(i);\n\t\t\tmi[i].fi=min(mi[i].fi,x[a]);\n\t\t\tvn[i].pb(mp(x[a],a));\n\t\t}\n\t}\n\tsort(mi,mi+m.size());\n\tF1(a,0,m.size()){\n\t\ti=mi[a].se;\n\t\tif(!vm[i]){\n\t\t\tvm[i]=1;\n\t\t\tans.pb(em);\n\t\t\tsort(vn[i].begin(),vn[i].end());\n\t\t\tup(i);\n\t\t\twhile(!q.empty()){\n\t\t\t\tans.back().pb(-q.top().fi);\n\t\t\t\tta=q.top().se;\n\t\t\t\tq.pop();\n\t\t\t\tF1(b,0,np[ta].size()){\n\t\t\t\t\tif(!vm[np[ta][b]])vm[np[ta][b]]=1;\n\t\t\t\t\tup(np[ta][b]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tF1(a,0,m.size())at[a]=0;\n\tF1(a,0,m.size())upp(a);\n\twhile(!qq.empty()){\n\t\tprintf(\"%d\\n\",qq.top().fi);\n\t\tupp(qq.top().se);\n\t}\n\t#ifdef LOCAL_PROJECT\n\tsystem(\"pause\");\n\t#endif\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define re register\n#define ll long long\ninline int gi(){\n\tint f=1,sum=0;char ch=getchar();\n\twhile(ch>'9' || ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0' && ch<='9'){sum=(sum<<3)+(sum<<1)+ch-'0';ch=getchar();}\n\treturn f*sum;\n}\nconst int N=2010;\nint a[N],link[N][N],vis[N],d[N],n;\nvector<int>G[N];\nvoid dfs(int u){\n\tvis[u]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tif(link[u][i] && !vis[i]){\n\t\t\td[i]++;\n\t\t\tG[u].push_back(i);\n\t\t\tdfs(i);\n\t\t}\n}\npriority_queue<int>Q;\nint main(){\n\tn=gi();for(int i=1;i<=n;i++)a[i]=gi();\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<n;i++)\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\tif(__gcd(a[i],a[j])!=1)link[i][j]=link[j][i]=1;\n\tfor(int i=1;i<=n;i++)if(!vis[i])dfs(i);\n\tfor(int i=1;i<=n;i++)if(!d[i])Q.push(i);\n\twhile(!Q.empty()){\n\t\tint u=Q.top();Q.pop();\n\t\tprintf(\"%d \",a[u]);\n\t\tfor(auto v:G[u])Q.push(v);\n\t}\n\tputs(\"\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n                                                                                                     \n                                             `-:://:::-                                             \n                                           `//:-------:/:`                                          \n                                          .+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .o:--...```..---+/`                                        \n                                       `/y+o/---....---:+o.                                         \n                                   `...````-os+/:---:/+o/--.`                                       \n              `-/+++++/:.      `...`       :h+d+oooo+/+-`   ...                                     \n            `/++//:::://++-`....`         -.`//````````:`     `..`                                  \n           `o+/::------://o/`           `-` -.          -`       `..`                               \n `---.-o/:./o/::-..``..-ЗАПУСКАЕМ      ..  ..            -`        `...       ``..``                \n  `....o+:-++/:--.```..-://s.        `-`  .-              -`          `-o: .-//::::/:-`             \n          `:s+/:--....-::/+s-`      .-   `-                -`           -///:--------:/:`           \n           ./s+//:::::://oo-``..НЕЙРОННУЮ: СЕТЬ:::::::-`РАБОТЯГИ        `+:--........--:/`          \n            .:ooo+++++osso-`    `.:-...`/` ./::-------:/:`   -`         :+--..``````.--:+:...-+:-`  \n             `.-/+++++/+-.-`    -.   ``:so:/:--.......--:+`  `-```````o+/+--..`````..--:o/-..:s+:.  \n                 ```````:``.. `-`     -` `+:--..`````..--/+-.../.`````..-o:--.......---/o.    `     \n                        `:  `:-      -.  .o:--..`` ``..--:o`   `-`      `:o+:--------:+o-`          \n                         `-`-...    ..   .o/--...```..--:+/`    `-`     `oy/so/////++o/.`           \n                          -/`  `-` `- ``+s/o/:---...---:++.      `-`   .-../d://///:-.`             \n                `.---..``-..-    .-/..`````-oo+/:::::/+o+-        `-``-`  `-.  ````                 \n             `:++++/+++++-  ..``.-/:`      /y-:/++o++/:.`..`       ./.   `-                         \n            -++/::::::://+/..:-``:` ..   `-.`  ```.```    `..`   `..`-` `-                          \n       ``  -o//:--....-::/++` -.-`   `-`.-`                 `..`..`  `-.-                           \n  -----ss+:++/:--.```..-://s.  /.     `::                    `-:.     ./`                           \n  `````/:..+o/::-..``.--:/+s. ..-`   `-``-`                 ..` `-`  `-`-`                          \n          `-s+/::-----::/+oo---``-` ..    .:-    ```      .-`     .-.-  `-`                         \n           `:oo+//::://+os/..:`..-/:`      :y.-:::::::.`.-`        ./-`  `-`                        \n            `./+oooooooo+/.`-    .-:...`.. .//:-------://`        `- `..` `:.                       \n              ``.-::::-.``-/`  `-` `-  `oo:+:--.......--:/`      `-    `.:--h.``..```               \n                          -.-`.-    .-   `+:--..`````..--//`    `-       /s-//::::::::.             \n                         -` `/-      ..  .o:--..`` ``..--:o.```.-        `//:--------://`           \n                        -` .-`.-`     -.`-o/--...```..--:+/.``-:....``:-.+:--....`...--:+`          \n                       ..`-.   `-.   ``:os:o/:---...---:++.  `-     ``///+:-..``````.--:+-````-.`   \n              `.:///////.-`      .:-..` -``-+o+/:::::/+o/.  `-         `:+:-..`````..--:o/:--/ys+-  \n            `-++///////+o/. ``....`-.    :` `.:++++++/:.`  .-           -o/---......---/o.   `.`    \n           `++//:-----::/+o:..`     .-`   :    ```````    .-           `+so+:--------:++-`          \n  `````:-``:o/::-..`..--:/+o`         -.  `-             .-          `../../+o+////+o+:.`           \n  -----syo/o+/:--.```..-://s.          .-` `-           .-        `...     ``-:////:-``             \n       .` `/s//:--....-::/+s.            -. `-`        .-       `..`                                \n           .+o+/:::--:://+s/-..`          .::+y  ```  .-     `..`                                   \n            ./oo++////+oso-`   `....       :y-+:::::::/`   ...                                      \n             `.:+oooooo/-`         `....-. .//:-------:/:-.`                                        \n                ``...``                 /+:+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .+/--...```..--:+/`                                        \n                                         `-o/:---...---:++.                                         \n                                          `-+o+/:---:/+o/.                                          \n                                            `.:+oooo+/-.`                                           \n                                               ``````                                               \n*/\n\n#ifdef aimbot\n#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#endif\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <set>\n#include <queue>\n#include <ostream>\n#include <istream>\n#include <typeinfo>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <limits>\n#include <fstream>\n#include <array>\n#include <list>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <cstring>\n#include <chrono>\n\n#define random escape__from__random__aetuhoetnuhshe\n#define mt make_tuple\n#define x first\n#define y second\n#define pb push_back\n#define ppb pop_back\n#define mp make_pair\n#define umap unordered_map\n#define uset unordered_set\n#define elif else if\n#define len(v) ((int)v.size())\n#define f(i, n) for (int i = 0; i < (n); i++)\n#define rof(i, n) for (int i = ((n) - 1); i >= 0; i--)\n#define apply(v, act) for (auto &x : v) { act; }\n#define log(args...) {string s = #args;deque<string> deq;\\\nstring buf = \"\";int bal = 0;for (char c : s) {\\\nif (c == '(' || c == '[' || c == '{') {bal++;\\\n} else if (c == ')' || c == ']' || c == '}') {\\\nbal--;} else {if (bal == 0) {if (c == ',') {\\\ndeq.pb(buf);buf = \"\";} else {if (c != ' ') {\\\nbuf += c;}}}}}if (!buf.empty()) {deq.pb(buf);}\\\nsmart_io::precall_print();smart_io::_print(deq, args);}\n\ninline int min(const int &x, const int &y) { return (((y-x)>>(32-1))&(x^y))^x; }\ninline int max(const int &x, const int &y) { return (((y-x)>>(32-1))&(x^y))^y; }\ninline long long min(const long long &x, const long long &y) { return (((y-x)>>(64-1))&(x^y))^x; }\ninline long long max(const long long &x, const long long &y) { return (((y-x)>>(64-1))&(x^y))^y; }\n\n#define print    \\\nsmart_io::precall_print(); \\\ncout,\n\n#define scan cin,\n\n#ifdef fast_allocator\nconst int MAXMEM = 200 * 1000 * 1024;\nchar _memory[MAXMEM];\nsize_t _ptr = 0;\nvoid* operator new(size_t _x) { _ptr += _x; assert(_ptr < MAXMEM); return _memory + _ptr - _x; }\nvoid operator delete (void*) noexcept {}\n#endif\n\nusing namespace std;\n\nchar string_in_buffer[(int)260];\n\n\nvoid fast_scan(int &x) { scanf(\"%d\", &x); }\nvoid fast_scan(long long &x) { scanf(\"%lld\", &x); }\nvoid fast_scan(unsigned long long &x) { scanf(\"%llu\", &x); }\nvoid fast_scan(double &x) { scanf(\"%lf\", &x); }\nvoid fast_scan(long double &x) { scanf(\"%Lf\", &x); }\nvoid fast_scan(char &x) {\n\tscanf(\"%c\", &x);\n\tif (x == '\\n') {\n\t\tfast_scan(x);\n\t}\n}\nvoid fast_scan(string &x) {\n\tscanf(\"%s\", string_in_buffer);\n\tx = string(string_in_buffer);\n}\n\ntemplate<class TFirst, class TSecond>\nvoid fast_scan(pair<TFirst, TSecond> &p) {\n\tfast_scan(p.first);\n\tfast_scan(p.second);\n}\n\ntemplate <class T>\nvoid fast_scan(vector<T> &v) {\n\tfor (auto &x : v) fast_scan(x);\n}\n\nvoid fast_print(const int &x) { printf(\"%d\", x); }\nvoid fast_print(const unsigned int &x) { printf(\"%u\", x); }\nvoid fast_print(const long long &x) { printf(\"%lld\", x); }\nvoid fast_print(const unsigned long long &x) { printf(\"%llu\", x); }\nvoid fast_print(const char &x) { printf(\"%c\", x); };\n// void fast_print(__int128 x) {\n// \tif (x == 0) { fast_print('0'); return; }\n// \tif (x < 0) {\n// \t\tfast_print('-');\n// \t\tx = -x;\n// \t}\n// \t__int128 p = 1;\n// \twhile (x / (p * 10)) p *= 10;\n// \twhile (p) {\n// \t\t__int128 symb = x / p;\n// \t\tfast_print((int)symb);\n// \t\tx -= p * symb;\n// \t\tp /= 10;\n// \t}\n// };\nvoid fast_print(const double &x) { printf(\"%.15lf\", x); }\nvoid fast_print(const long double &x) { printf(\"%.15Lf\", x); }\nvoid fast_print(const string &x) { printf(\"%s\", x.c_str());}\nvoid fast_print(const char v[]) { fast_print((string)v); }\n\ntemplate<class TFirst, class TSecond>\nvoid fast_print(const pair<TFirst, TSecond> &p) {\n\tfast_print(p.first);\n\tfast_print(' ');\n\tfast_print(p.second);\n}\n\ntemplate <class T>\nvoid fast_print(const vector<T> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print(' ');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const vector<vector<T>> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print('\\n');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const T &v) {\n\tfor (const auto &x : v) {\n\t\tfast_print(x);\n\t\tfast_print(' ');\n\t}\n}\n\n\nusing namespace std;\n\n\nnamespace smart_io {\n\tstring print_start = \"\";\n\tstring sep = \" \";\n\tbool first_print = false;\n\t\n\tvoid precall_print() {\n\t\tfast_print(print_start);\n\t\tprint_start = \"\\n\";\n\t\tfirst_print = true;\n\t}\n\t\n\tvoid _print(deque<string>) {}\n\ttemplate<class T, class... Args>\n\tvoid _print(deque<string> names, T elem, Args... args) {\n\t\tif (!first_print) {\n\t\t\tfast_print(\"\\n\");\n\t\t} else {\n\t\t\tfirst_print = false;\n\t\t}\n\t\tfast_print(names.front());\n\t\tfast_print(\" = \");\n\t\tfast_print(elem);\n\t\tnames.pop_front();\n\t\t_print(names, args...);\n\t}\n} //namespace smart_io\n\n\ntemplate <class T>\nostream &operator,(ostream &os, const T &object) {\n\tif (!smart_io::first_print) {\n\t\tfast_print(smart_io::sep);\n\t} else {\n\t\tsmart_io::first_print = false;\n\t}\n\tfast_print(object);\n\treturn os;\n}\n\ntemplate <class T>\nistream &operator,(istream &is, T &object) {\n\tfast_scan(object);\n\treturn is;\n}\n\nnamespace random {\n\tusing namespace std::chrono;\n\tmt19937 rng(duration_cast< milliseconds >(\n\t\t\t\t\t\t\t\t\t\t\t  system_clock::now().time_since_epoch()\n\t\t\t\t\t\t\t\t\t\t\t  ).count());\n\tuniform_real_distribution<> prob_dist(0.0, 1.0);\n};\n\nnamespace typedefs {\n\ttypedef long long ll;\n\ttypedef unsigned long long ull;\n\ttypedef pair<int, int> pii;\n\ttypedef long double ld;\n}\n\nnamespace numbers_operation {\n\ttemplate<class T>\n\tinline T floor_mod(T a, const T &b) {\n\t\ta %= b;\t\n\t\tif (a < 0) a += b;\n\t\treturn a;\n\t}\n}\n\nusing namespace numbers_operation;\nusing namespace typedefs;\nusing namespace random;\n\nint gcd(int a, int b) {\n\treturn __gcd((unsigned int)a, (unsigned int)b);\n}\t\n\nint n;\nvector<vector<int>> factors;\nvector<int> v;\n\nvoid factorize(int n, vector<int> &rez) {\n\tfor (int i = 2; i * i <= n; i++) {\n\t\twhile (n % i == 0) {\n\t\t\tn /= i;\n\t\t\trez.pb(i);\n\t\t}\n\t}\n\tif (n > 1) rez.pb(n);\n\tsort(rez.begin(), rez.end());\n\trez.resize(unique(rez.begin(), rez.end()) - rez.begin());\n}\n\nstruct SUS {\n\tvector<int> up;\n\tint get_root(int i) {\n\t\tif (up[i] == i) return i;\n\t\treturn up[i] = get_root(up[i]);\n\t}\n\tSUS(int n) {\n\t\tup.resize(n);\n\t\tf(i, n) up[i] = i;\n\t}\n\tvoid merge(int a, int b) {\n\t\tup[get_root(a)] = get_root(b);\n\t}\n\tbool one_comp(int a, int b) {\n\t\treturn get_root(a) == get_root(b);\n\t}\n};\n\nvector<int> order(vector<int> cur, const set<int> &F, int lv = 0) {\n\tif (len(cur) <= 1) return cur;\n\tint take = -1;\n\tfor (int i = 0; i < len(cur); i++) {\n\t\tif (F.count(v[cur[i]])) \n\t\t\tif (take == -1 || v[cur[i]] < v[cur[take]])\n\t\t\t\ttake = i;\n\t}\n\tassert(take != -1);\n\tmap<int, vector<int>> at;\n\tfor (int i = 0; i < len(cur); i++) {\n\t\tif (i == take) continue;\n\t\tfor (int x : factors[cur[i]]) {\n\t\t\tat[x].pb(i);\n\t\t}\n\t}\n\tSUS sus(len(cur));\n\tfor (auto p : at) {\n\t\tfor (int j = 0; j < len(p.y) - 1; j++) {\n\t\t\tsus.merge(p.y[j], p.y[j + 1]);\n\t\t}\n\t}\n\tmap<int, vector<int>> index;\n\tfor (int i = 0; i < len(cur); i++) {\n\t\tif (i == take) continue;\n\t\tindex[sus.get_root(i)].pb(cur[i]);\n\t}\n\tset<int> ava;\n\tfor (int i = 0; i < len(cur); i++) {\n\t\tif (i == take) continue;\n\t\tif (gcd(v[cur[i]], v[cur[take]]) > 1 || (v[cur[i]] <= v[cur[take]] && F.count(v[cur[i]])))\n\t\t\tava.insert(v[cur[i]]);\n\t}\n\tvector<int> rez;\n\tfor (auto p : index) {\n\t\tvector<int> t = order(p.y, ava, lv + 1);\n\t\tif (lv == 0) {\n\t\t\t// print \"GO\", p.y, \":\", t;\n\t\t}\n\t\tvector<int> final;\n\t\tmerge(rez.begin(), rez.end(), t.begin(), t.end(), back_inserter(final), [](int i, int j) {\n\t\t\treturn v[i] > v[j];\n\t\t});\n\t\trez = final;\n\t}\n\trez.insert(rez.begin(), cur[take]);\n\treturn rez;\n}\n\nsigned main(signed argc, char *argv[]) {\n\tscan n;\n\tv.resize(n);\n\tfactors.resize(n);\n\tscan v;\n\tfor (int i = 0; i < n; i++) {\n\t\tfactorize(v[i], factors[i]);\n\t}\n\tvector<int> cur(n);\n\tiota(cur.begin(), cur.end(), 0);\n\t{\n\t\tmap<int, vector<int>> at;\n\t\tfor (int i = 0; i < len(cur); i++) {\n\t\t\t// if (i == take) continue;\n\t\t\tfor (int x : factors[cur[i]]) {\n\t\t\t\tat[x].pb(i);\n\t\t\t}\n\t\t}\n\t\tSUS sus(len(cur));\n\t\tfor (auto p : at) {\n\t\t\tfor (int j = 0; j < len(p.y) - 1; j++) {\n\t\t\t\tsus.merge(p.y[j], p.y[j + 1]);\n\t\t\t}\n\t\t}\n\t\tmap<int, vector<int>> index;\n\t\tfor (int i = 0; i < len(cur); i++) {\n\t\t\t// if (i == take) continue;\n\t\t\tindex[sus.get_root(i)].pb(i);\n\t\t}\n\t\tset<int> ava;\n\t\tfor (int i = 0; i < len(cur); i++) {\n\t\t\t// if (i == take) continue;\n\t\t\t// if (gcd(v[cur[i]], v[cur[take]]) > 1 || v[cur[i]] <= v[cur[take]])\n\t\t\t\tava.insert(v[cur[i]]);\n\t\t}\n\t\tvector<int> rez;\n\t\tfor (auto p : index) {\n\t\t\tvector<int> t = order(p.y, ava);\n\t\t\t// print \"GO\", p.y, \"->\", t;\n\t\t\tvector<int> final;\n\t\t\tmerge(rez.begin(), rez.end(), t.begin(), t.end(), back_inserter(final), [](int i, int j) {\n\t\t\t\treturn v[i] > v[j];\n\t\t\t});\n\t\t\trez = final;\n\t\t}\n\t\tfor (int i = 0; i < len(rez); i++)\n\t\t\trez[i] = v[rez[i]];\n\t\tprint rez;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nconst int MAXN=2005;\n\nint n,in[MAXN];\nint a[MAXN],g[MAXN][MAXN];\nbool vis[MAXN];\nvector<int> E[MAXN];\npriority_queue<int> q;\n\nint gcd(int x,int y){return !y?x:gcd(y,x%y);}\n\nvoid dfs(int u,int fa=0){\n    vis[u]=1;\n    for(int i=1;i<=n;i++)\n        if(g[u][i]&&!vis[i]){\n            in[i]++;\n            E[u].push_back(i);\n            dfs(i);\n        }\n}\n\nint main(){\n    scanf(\"%d\",&n);\n    for(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n    sort(a+1,a+n+1);\n    for(int i=1;i<=n;i++)\n        for(int j=1;j<=n;j++)\n            if(gcd(a[i],a[j])!=1)\n                g[i][j]=g[j][i]=1;\n    for(int i=1;i<=n;i++)\n        if(!vis[i]) dfs(i);\n    for(int i=1;i<=n;i++)\n        if(!in[i]) q.push(i);\n    while(!q.empty()){\n        int u=q.top(); q.pop();\n        printf(\"%d \",a[u]);\n        for(int i=0;i<(int)E[u].size();i++){\n            int v=E[u][i];\n            if((--in[v])==0)\n                q.push(v);\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define mp1(a,b,c) P1(a,P(b,c))\n\nconst int INF=1000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n\nint gcd(int x,int y){\n\tif(y == 0)return x;\n\treturn gcd(y,x%y);\n}\n\nint main(){\n\tint n;\n\tint a[2002];\n\tscanf(\"%d\",&n);\n\trep(i,n)scanf(\"%d\",&a[i]);\n\t\n\tsort(a,a+n);\n\tint cnt[2002] = {};\n\tvector<int> vec[2002];\n\trep(i,n){\n\t\trep(j,n){\n\t\t\tif(gcd(a[i],a[j]) != 1){\n\t\t\t\tcnt[i] ++;\n\t\t\t\tvec[j].pb(i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<int> ans[2002];\n\tbool used[2002];\n\trep(i,2002)used[i] = false;\n\trep(i,n){\n\t\t//cout << i << endl;\n\t\tif(!used[i]){\n\t\t\tint loc = i;\n\t\t\twhile(1){\n\t\t\t\tans[i].pb(loc);\n\t\t\t\tused[loc] = true;\n\t\t\t\tint loc_ = loc;\n\t\t\t\trep(j,vec[loc_].size()){\n\t\t\t\t\tif(!used[vec[loc_][j]]){\n\t\t\t\t\t\tloc_ = vec[loc_][j];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(loc == loc_)break;\n\t\t\t\tloc = loc_;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<int> A;\n\tpriority_queue<P1> que;\n\trep(i,2002){\n\t\tif(ans[i].size() > 0){\n\t\t\tque.push(mp1(ans[i][0],i,0));\n\t\t}\n\t}\n\twhile(!que.empty()){\n\t\tP1 p = que.top(); que.pop();\n\t\tA.pb(a[p.fr]);\n\t\tif(ans[p.sc.fr].size() > p.sc.sc+1){\n\t\t\tque.push(mp1(ans[p.sc.fr][p.sc.sc+1],p.sc.fr,p.sc.sc+1));\n\t\t}\n\t}\n\t\n\t\n\t/*priority_queue<int> que;\n\trep(i,n)if(cnt[i] == 0)que.push(i);\n\twhile(!que.empty()){\n\t\tint p = que.top(); que.pop();\n\t\tans.pb(a[p]);\n\t\trep(i,vec[p].size()){\n\t\t\tcnt[vec[p][i]] --;\n\t\t\tif(cnt[vec[p][i]] == 0)que.push(vec[p][i]);\n\t\t}\n\t}*/\n\t\n\trep(i,A.size()){\n\t\tprintf(\"%d%c\",A[i],i+1==A.size()?'\\n':' ');\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define MN 2000\nusing namespace std;\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\ninline int gcd(int x,int y){return y?gcd(y,x%y):x;}\nint n,a[MN+5],head[MN+5],cnt=0,belong[MN+5],num=0,choose[MN+5],used[MN+5];\nstruct edge{int to,next;}e[MN*MN*2+5];\ninline void ins(int f,int t)\n{\n\te[++cnt]=(edge){t,head[f]};head[f]=cnt;\n\te[++cnt]=(edge){f,head[t]};head[t]=cnt;\t\n}\nvoid dfs(int x,int v)\n{\n\tbelong[x]=v;if(a[x]<a[choose[v]]) choose[v]=x;\n\tfor(int i=head[x];i;i=e[i].next)\n\t\tif(belong[e[i].to]!=v) dfs(e[i].to,v); \n}\nint main()\n{\n\tn=read();a[0]=int(1e9);\n\tfor(int i=1;i<=n;++i) a[i]=read();\n\tfor(int i=1;i<=n;++i) for(int j=i+1;j<=n;++j) if(gcd(a[i],a[j])>1) ins(i,j);\n\tfor(int i=1;i<=n;++i) if(!belong[i]) ++num,dfs(i,num); \n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tint mx=0,from=0;\n\t\tfor(int j=1;j<=num;++j)\n\t\t\tif(choose[j]&&a[choose[j]]>mx) mx=a[choose[j]],from=choose[j];\n\t\tprintf(\"%d \",mx);used[from]=1;choose[belong[from]]=0;\n\t\tfor(int j=head[from];j;j=e[j].next)\n\t\t\tif(!used[e[j].to]&&a[e[j].to]<a[choose[belong[from]]]) \n\t\t\t\tchoose[belong[from]]=e[j].to;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint Eulg(int a, int b);\n\nint main(int argc, char *argv[]){\n\n\tint N;\n\tcin>>N;\n\n\tint *a = new int[N]();\n\n\tfor(int i=0; i<N; i++){\n\t\tcin>>a[i];\n\t}\n\n\tsort(a, a+N);\n\n\tbool flag = true;\n\twhile(flag){\n\tfor(int i=0; i<N; i++){\n\t\tfor(int j=i+1; j<N; j++){\n\t\t\tif(Eulg(a[i], a[j]) == 1){\n\t\t\t\tif(a[i]<a[j]){\n\t\t\t\t\tint tmp;\n\t\t\t\t\ttmp =a[i];\n\t\t\t\t\ta[i] = b[i];\n\t\t\t\t\tb[i] = tmp;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t}\n}\n\nfor(int i=0; i<N; i++)\n\tcout<<a[i]<<\"  \";\n\n\n\n\tdelete[] a;\n\treturn 0;\n}\n\nint Eulg(int a, int b){\n\tif(a<b){\n\t\tint tmp;\n\t\ttmp =a;\n\t\ta = b;\n\t\tb = tmp;\n\t}\n\n\tint r;\n\tr = a % b;\n\twhile(r){\n\t\ta = b;\n\t\tb = r;\n\t\tr = a % b;\n\t}\n\treturn b;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<typename T> \nmap<T, Int> factorize(T x){\n  map<T, Int> res;\n  for(Int i=2;i*i<=x;i++){\n    while(x%i==0){\n      x/=i;\n      res[i]++;\n    }\n  }\n  if(x!=1) res[x]++;\n  return res;\n}\n\n//INSERT ABOVE HERE\nInt cop[2020][2020];\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<Int> a(n);\n  for(Int i=0;i<n;i++) cin>>a[i];\n  sort(a.begin(),a.end());\n\n  vector<Int> ans(n),used(n,0),post(n,0);\n\n  memset(cop,0,sizeof(cop));\n  \n  for(Int i=0;i<n;i++)\n    for(Int j=0;j<n;j++)\n      cop[i][j]=__gcd(a[i],a[j])>1;\n\n  Int m=0;\n  map<Int, Int> r;\n\n  vector<vector<Int> > G(n*100);\n  for(Int i=0;i<n;i++){\n    auto x=factorize(a[i]);\n    for(auto p:x){\n      if(!r.count(p.first)) r[p.first]=m++;\n      G[i].emplace_back(n+r[p.first]);\n      G[n+r[p.first]].emplace_back(i);\n    }\n  }\n  exit(0);\n  for(Int t=0;t<n;t++){\n    vector<Int> cs(n+m,-1);\n    Int color=0;\n    for(Int i=0;i<n+m;i++){\n      if(~cs[i]) continue;\n      queue<Int> q;\n      cs[i]=color;\n      q.emplace(i);\n      while(!q.empty()){\n\tInt v=q.front();q.pop();\n\tfor(Int u:G[v]){\n\t  if(~cs[u]) continue;\n\t  cs[u]=color;\n\t  q.emplace(u);\n\t}\n      }\n      color++;\n    }\n    \n    Int idx=-1;\n    for(Int i=0;i<n;i++){\n      if(used[i]||post[i]) continue;\n      idx=i;\n      break;\n    }\n    \n    used[idx]=1;\n    ans[t]=idx;\n    \n    for(Int i=0;i<n;i++){\n      if(cs[idx]!=cs[i]) continue;\n      if(cop[idx][i]) post[i]=0;\n      else if(a[idx]<a[i]) post[i]=1;\n    }\n  }\n\n\n  vector<Int> b(n);\n  for(Int i=0;i<n;i++) b[i]=a[ans[i]];\n  \n  vector<vector<Int> > H(n);\n  for(Int i=0;i<n;i++)\n    for(Int j=i+1;j<n;j++)\n      if(__gcd(b[i],b[j])>1) H[i].emplace_back(j);\n\n  vector<Int> indeg(n);\n  for(Int i=0;i<n;i++)\n    for(Int j:H[i]) indeg[j]++;\n  \n  using P = pair<Int, Int>;\n  priority_queue<P> pq;\n  for(Int i=0;i<n;i++)\n    if(!indeg[i]) pq.emplace(b[i],i);\n\n  vector<Int> c;\n  while(!pq.empty()){\n    P p=pq.top();pq.pop();\n    c.emplace_back(p.first);\n    for(Int u:H[p.second]){\n      indeg[u]--;\n      if(!indeg[u]) pq.emplace(b[u],u);\n    }\n  }\n  \n  assert((Int)c.size()==n);\n  for(Int i=0;i<n;i++){\n    if(i) cout<<\" \";\n    cout<<c[i];\n  }\n  cout<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#include <cstdio> \n#include <cstdlib> \n#include <cstring> \n#include <cmath> \n#include <algorithm>\n#include <vector>\n#include <queue> \nusing namespace std; \ninline int gi() { \n    register int data = 0, w = 1; \n    register char ch = 0; \n    while (!isdigit(ch) && ch != '-') ch = getchar(); \n    if (ch == '-') w = -1, ch = getchar(); \n    while (isdigit(ch)) data = 10 * data + ch - '0', ch = getchar(); \n    return w * data; \n} \nconst int MAX_N = 2e3 + 5; \nint N, a[MAX_N], deg[MAX_N]; \nbool vis[MAX_N], Link[MAX_N][MAX_N]; \nvector<int> G[MAX_N]; \nvoid dfs(int x) { \n\tvis[x] = 1; \n\tfor (int i = 1; i <= N; i++) if (!vis[i] && Link[x][i]) ++deg[i], G[x].push_back(i), dfs(i); \n} \nvoid TopSort() { \n\tpriority_queue<int> que; \n\tfor (int i = 1; i <= N; i++) if (!deg[i]) que.push(i); \n\twhile (!que.empty()) { \n\t\tint x = que.top(); que.pop();\n\t\tprintf(\"%d \", a[x]); \n\t\tfor (auto v : G[x]) que.push(v); \n\t}\n\tputchar('\\n'); \n} \n\nint main () {\n\tN = gi(); for (int i = 1; i <= N; i++) a[i] = gi(); \n\tsort(&a[1], &a[N + 1]); \n\tfor (int i = 1; i <= N; i++)\n\t\tfor (int j = i + 1; j <= N; j++) \n\t\t\tif (__gcd(a[i], a[j]) != 1) Link[i][j] = Link[j][i] = 1; \n\tfor (int i = 1; i <= N; i++) if (!vis[i]) dfs(i); \n\tTopSort(); \n\treturn 0; \n} \n"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n\n#define null                \"\"\n#define all(dat)            dat.begin(), dat.end()\n#define over(msg)           puts(msg), exit(0);\n#define loop(i, to)         for (int i = 0; i < to; ++i)\n#define cont(i, to)         for (int i = 1; i <= to; ++i)\n#define foreach(i, dat)     for (__typeof(dat.begin()) i = dat.begin(); i != dat.end(); ++i)\n\ntypedef long long           num;\n\nusing namespace std;\n\nbool vis[2005];\n\nint n, sz;\n\npair<int, int> dat[2005];\n\nvector<int> g[2005];\n\nvector<vector<int>> b;\n\nint gcd(int a, int b) {\n\t\n\treturn b == 0 ? a : gcd(b, a % b);\n\t\n}\n\nvoid dfs(int u, int mem) {\n\t\n\tif (u == -1)  return;\n\t\n\tint to = -1, mn = 1e9;\n\t\n\tvis[u] = 1;\n\t\n\tb[mem].push_back(dat[u].first);\n\t\n\tloop (i, g[u].size()) {\n\t\t\n\t\tint v = g[u][i];\n\t\t\n\t\tif (vis[v])  continue;\n\t\t\n\t\tif (dat[v].first < mn) {\n\t\t\t\n\t\t\tmn = dat[v].first;\n\t\t\t\n\t\t\tto = v;\n\t\t\t\n\t\t}\n\t\t\n\t}\n\t\n\tdfs(to, mem);\n\t\n}\n\nbool cmp(vector<int> a, vector<int> b) {\n\t\n\treturn a[0] > b[0];\n\t\n}\n\nint main() {\n\t\n\tios_base::sync_with_stdio(0);\n\t\n\tcin >> n;\n\t\n\tcont (i, n) {\n\t\t\n\t\tcin >> dat[i].first;\n\t\t\n\t\tdat[i].second = i;\n\t\t\n\t}\n\t\n\tcont (i, n) {\n\t\t\n\t\tcont (j, n) {\n\t\t\t\n\t\t\tif (i == j)  continue;\n\t\t\t\n\t\t\tint tmp = gcd(dat[i].first, dat[j].first);\n\t\t\t\n\t\t\tif (tmp > 1) {\n\t\t\t\t\n\t\t\t\tg[i].push_back(j);\n\t\t\t\t\n\t\t\t\tg[j].push_back(i);\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t}\n\t\n\tsort(dat, dat + n);\n\t\n\tcont (i, n) {\n\t\t\n\t\tint u = dat[i].second;\n\t\t\n\t\tif (vis[u])  continue;\n\t\t\n\t\tb.push_back(vector<int>(0));\n\t\t\n\t\tdfs(u, sz++);\n\t\t\n\t}\n\t\n\tsort(all(b), cmp);\n\t\n\tloop (i, b.size()) {\n\t\t\n\t\tloop (j, b[i].size()) {\n\t\t\t\n\t\t\tcout << b[i][j] << ' ';\n\t\t\t\n\t\t}\n\t\t\n\t}\n\t\n\tcout << endl;\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,a,b) for(i=a;i<b;i++)\n#define per(i,b,a) for(i=b;i>=a;i--)\n#define For(i,a,b) for(i=a;i<=b;i++)\n#define Forenska(it,c) for(register __typeof(c.begin()) it=c.begin();it!=c.end();it++)\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\n#define all(x) x.begin(),x.end()\n#define sqr(x) ((x)*(x))\n#define lowbit(x) ((x)&(-x))\n#define GREATER(x) x,vector<x>,greater<x>\nusing namespace std;\nint i,j;\ntypedef long long LL;\ntypedef pair<int,int> pii;\ntypedef pair<LL,LL> pLL;\ntypedef vector<int> vec;\ntypedef vector<LL> vecL;\ntypedef vector<pii> vecP;\ntypedef vector<pLL> vecPL;\ntypedef vector<string> vecS;\ntypedef vector<vec> mat;\ntypedef complex<double> point;\nconst long double PI=3.1415926535897932384626433832795028841971693993751058209749445923078164062862089;\nconst LL INFLL=0x3f3f3f3f3f3f3f3f;\nconst int INF=0x3f3f3f3f;\nconst long double EPS=1e-10;\nint read()\n{\n\tint x=0;\n\tchar ch=' ';\n\tbool flag=false;\n\twhile(!isdigit(ch))\n\t{\n\t\tif(ch=='-')flag=true;\n\t\tch=getchar();\n\t}\n\twhile(isdigit(ch))\n\t{\n\t\tx=(x<<3)+(x<<1)+ch-'0';\n\t\tch=getchar();\n\t}\n\treturn flag?-x:x;\n}\nint n;\nvec A;\nmat g1,g2;\nconst int MAX_N=2005;\nbool vis[MAX_N];\nint in[MAX_N];\nvoid dfs(int v)\n{\n\tif(vis[v])return;\n\tvis[v]=true;\n\trep(i,0,g1[v].size())\n\t{\n\t\tint to=g1[v][i];\n\t\tif(!vis[to])\n\t\t{\n\t\t\tg2[v].pb(to);\n\t\t\tin[to]++;\n\t\t\tdfs(to);\n\t\t}\n\t}\n}\nint main()\n{\n\tn=read();\n\tA.resize(n);\n\trep(i,0,n)A[i]=read();\n\tsort(all(A));\n\tA.resize(unique(all(A))-A.begin());\n\tn=A.size();\n\tg1.resize(n);\n\tg2.resize(n);\n\trep(i,0,n)\n\t{\n\t\trep(j,i+1,n)\n\t\t{\n\t\t\tif(__gcd(A[i],A[j])>1)\n\t\t\t{\n\t\t\t\tg1[i].pb(j);\n\t\t\t\tg1[j].pb(i);\n\t\t\t}\n\t\t}\n\t}\n\trep(i,0,n)\n\t{\n\t\tdfs(i);\n\t}\n\tqueue <int> q;\n\tvec ans;\n\tper(i,n-1,0)if(!in[i])q.push(i),ans.pb(i);\n\twhile(!q.empty())\n\t{\n\t\tint t=q.front();\n\t\tq.pop();\n\t\trep(i,0,g2[t].size())\n\t\t{\n\t\t\tint to=g2[t][i];\n\t\t\tin[to]--;\n\t\t\tif(!in[to])\n\t\t\t{\n\t\t\t\tq.push(to);\n\t\t\t\tans.pb(to);\n\t\t\t}\n\t\t}\n\t}\n\trep(i,0,ans.size())ans[i]=A[ans[i]];\n\trep(i,0,ans.size())\n\t{\n\t\trep(j,0,ans.size()-1)\n\t\t{\n\t\t\tif(ans[j]<ans[j+1] && __gcd(ans[j],ans[j+1])==1)swap(ans[j],ans[j+1]);\n\t\t}\n\t}\n\trep(i,0,ans.size()-1)cout<<ans[i]<<\" \";\n\tcout<<ans.back()<<endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#include <queue>\n#define re register\nusing namespace std;\n\ninline int read() {\n    int X=0,w=1; char c=getchar();\n    while (c<'0'||c>'9') { if (c=='-') w=-1; c=getchar(); }\n    while (c>='0'&&c<='9') X=X*10+c-'0',c=getchar();\n    return X*w;\n}\n\nconst int N=2000+10;\n\nstruct Edge { int v,nxt; } e[N];\nint head[N];\n\ninline void addEdge(int u,int v) {\n    static int cnt=0;\n    e[++cnt]=(Edge){v,head[u]},head[u]=cnt;\n}\n\nint n;\nint a[N],vis[N],deg[N];\nint G[N][N];\n\ninline void dfs(int u) {\n    vis[u]=1;\n    for (re int i=1;i<=n;++i) {\n        if (vis[i]||!G[u][i]) continue;\n        ++deg[i],addEdge(u,i);\n        dfs(i);\n    }\n}\n\ninline void topsort() {\n    priority_queue<int> Q;\n    for (re int i=1;i<=n;++i)\n        if (!deg[i]) Q.push(i);\n    while (!Q.empty()) {\n        int u=Q.top(); Q.pop();\n        printf(\"%d \",a[u]);\n        for (re int i=head[u];i;i=e[i].nxt) Q.push(e[i].v);\n    }\n}\n\nint main() {\n    n=read();\n    for (re int i=1;i<=n;++i) a[i]=read();\n    sort(a+1,a+n+1);\n    for (re int i=1;i<=n;++i)\n        for (re int j=i+1;j<=n;++j) {\n            if (__gcd(a[i],a[j])==1) continue;\n            G[i][j]=G[j][i]=1;\n        }\n    for (re int i=1;i<=n;++i)\n        if (!vis[i]) dfs(i);\n    topsort();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//2018-1-25\n//miaomiao\n//\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define For(i, a, b) for(int i = (a); i <= (int)(b); ++i)\n\n#define N (2000+5)\n#define M (4000000+5)\n\nint Gcd(int a, int b){return !b? a: Gcd(b, a % b);}\n\nstruct node{\n\tint p, v;\n\tbool operator <(const node &rhs)const{return v < rhs.v;}\n};\n\nint a[N], in[N], vis[N];\nvector<int> G[N], g[N];\n\npriority_queue<node> q;\n\nbool cmp(int i, int j){\n\treturn a[i] < a[j];\n}\n\n#define v G[now][i]\n\nvoid Dfs(int now, int F){\n\tvis[now] = vis[F] + 1;\n\n\tsort(G[now].begin(), G[now].end(), cmp);\n\tFor(i, 0, G[now].size() - 1){\n\t\tif(v == F) continue;\n\t\t\n\t\tif(vis[v]){\n\t\t\tif(vis[v] > vis[now]) g[now].pb(v), ++in[v];\n\t\t}else{\n\t\t\tg[now].pb(v); ++in[v];\n\t\t\tDfs(v, now);\n\t\t}\n\t}\n}\n\n#undef v\n\nint main(){\n\tint n;\n\n\tscanf(\"%d\", &n);\n\tFor(i, 1, n) scanf(\"%d\", &a[i]);\n\tsort(a + 1, a + n + 1);\n\n\tFor(i, 1, n) For(j, i + 1, n)\n\t\tif(Gcd(a[i], a[j]) > 1) G[i].pb(j), G[j].pb(i);\n\t\t\n\tFor(i, 1, n) if(!vis[i]) Dfs(i, 0);\n\tFor(i, 1, n) if(!in[i]) q.push((node){i, a[i]});\n\t\n\tint now, v;\n\twhile(!q.empty()){\n\t\tnow = q.top().p; q.pop();\n\t\tprintf(\"%d \", a[now]);\n\n\t\tFor(i, 0, g[now].size() - 1){\n\t\t\t--in[v = g[now][i]];\n\t\t\tif(!in[v]) q.push((node){v, a[v]});\n\t\t}\n\t}\n\tputs(\"\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int nmax = 2009;\n\nint boss[nmax] , head[nmax] , now[nmax] , used[nmax] , in[nmax] , x[nmax] , blocked[nmax];\nvector < int > g[nmax] , oneway[nmax];\nint i , j , n , first , last , bst;\n\nint gcd(int a , int b)\n{\n    if (b == 0) return a;\n    return gcd(b , a % b);\n}\n\nvoid dfs(int act)\n{\n    used[act] = 1;\n\n    for (int i = 0 ; i < g[act].size() ; ++i)\n    {\n        int nxt = g[act][i];\n        if (used[nxt]) continue;\n        dfs(nxt);\n    }\n}\n\nvoid dfs2(int act)\n{\n    now[act] = 1;\n\n    for (int i = 0 ; i < g[act].size() ; ++i)\n    {\n        int nxt = g[act][i];\n        if (now[nxt]) continue;\n        if (blocked[nxt]) continue;\n        dfs2(nxt);\n    }\n}\n\nvoid readData()\n{\n    cin >> n;\n    for (i = 1 ; i <= n ; ++i)\n    cin >> x[i];\n\n    for (i = 1 ; i <= n ; ++i)\n    for (j = i + 1 ; j <= n ; ++j)\n    if (2 <= gcd(x[i] , x[j]))\n    {\n        g[i].push_back(j);\n        g[j].push_back(i);\n    }\n\n    first = 1 , last = 0;\n    for (i = 1 ; i <= n ; ++i)\n    {\n        if (used[i]) continue;\n        dfs(i);\n        head[++last] = i , boss[last] = 0;\n    }\n    x[0] = 1000000000;\n}\n\nint walk(int act , int forced)\n{\n    int ret = 0;\n    now[act] = 1;\n\n    for (int i = 0 ; i < g[act].size() ; ++i)\n    {\n        int nxt = g[act][i];\n        if (blocked[nxt]) continue;\n        if (now[nxt]) continue;\n        ret = min(ret , walk(nxt , forced));\n    }\n\n    if (forced == 0) return (x[act] < x[ret]) ? act : ret;\n    else\n    {\n        if (2 <= gcd(x[act] , forced)) return (x[act] < x[ret]) ? act : ret;\n        else return ret;\n    }\n}\n\nvoid solve(int k)\n{\n    vector < int > sons;\n    int root = head[k];\n    memset(now , 0 , sizeof(now));\n\n    root = walk(root , x[boss[k]]);\n\n    for (int i = 0 ; i < g[root].size() ; ++i)\n    {\n        int nxt = g[root][i];\n        if (blocked[nxt]) continue;\n        sons.push_back(nxt);\n    }\n    blocked[root] = 1;\n\n    memset(now , 0 , sizeof(now));\n    for (int i = 0 ; i < sons.size() ; ++i)\n    {\n        int nxt = sons[i];\n        if (now[nxt]) continue;\n        dfs2(nxt);\n\n        oneway[root].push_back(nxt);\n        in[nxt]++;\n\n        head[++last] = nxt;\n        boss[last] = root;\n    }\n}\n\nint main()\n{\n\n//freopen(\"test.in\" , \"r\" , stdin);\n//freopen(\"test.out\" , \"w\" , stdout);\n\nreadData();\nwhile (first <= last) solve(first++);\n\nx[0] = -1000000000;\nmemset(used , 0 , sizeof(used));\nfor (i = 1 ; i <= n ; ++i)\n{\n    bst = 0;\n    for (j = 1 ; j <= n ; ++j)\n    if (used[j] == 0 && in[j] == 0 && x[bst] < x[j]) bst = j;\n\n    used[bst] = 1;\n    cout << x[bst] << \" \";\n\n    for (j = 0 ; j < oneway[bst].size() ; ++j)\n    in[oneway[bst][j]]--;\n}\n\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define loop(i,n) for(int i = 0;i < (n);i++)\n#define all(A) A.begin(),A.end()\n#define pb push_back\n#define mp make_pair\n#define sz(A) ((int)A.size())\ntypedef std::vector<int> vi;\ntypedef std::pair<int,int> pi;\ntypedef std::vector<pi> vp;\ntypedef long long ll;\n#define popcnt(x) __builtin_popcount(x)\n#define LSOne(x) ((x) & (-(x)))\n#define print(A,t) cerr << #A << \": \"; copy(all(A),ostream_iterator<t>(cerr,\" \" )); cerr << endl\n#define prArr(A,n,t)  cerr << #A << \": \"; copy(A,A + n,ostream_iterator<t>(cerr,\" \" )); cerr << endl\n#define PRESTDIO() cin.tie(0),cerr.tie(0),ios_base::sync_with_stdio(0)\n#define what_is(x) cerr << #x << \" is \" << x << endl\n#define bit_lg(x) (assert(x > 0),__builtin_ffsll(x) - 1)\nconst double PI = acos(-1);\ntemplate<class A,class B>\nstd::ostream& operator << (std::ostream& st,const std::pair<A,B> p) {\n\tst << \"(\" << p.first << \", \" << p.second << \")\";\n\treturn st;\n}\n#define tc() int T; scanf(\"%d\",&T); for(int t = 1;t <= T;t++)\nusing namespace std;\n\n\nunordered_map<int,int> pos,blocker;\n\nint insert(int x,vi & V) {\n\tstatic vi aux;\n\taux.clear();\n\twhile(!V.empty() && __gcd(x,V.back()) == 1) {\n\t\taux.push_back(V.back());\n\t\tV.pop_back();\n\t}\n\tint r = V.size();\n\tV.push_back(x);\n\twhile(!aux.empty()) {\n\t\tint x = aux.back();\n\t\tpos[x] = V.size();\n\t\tV.push_back(aux.back());\n\t\taux.pop_back();\n\t}\n\treturn r;\n}\n\nint main(){\n#ifdef HOME\n//\tfreopen(\"in.in\",\"r\",stdin);\n\tfreopen(\"/home/noureldin/Desktop/E/in/in1.txt\", \"r\", stdin);\n\tfreopen(\"out.out\",\"w\",stdout);\n#endif\n\tint n; scanf(\"%d\",&n);\n\tvi V(n);\n\tloop(i,n)scanf(\"%d\",&V[i]);\n\tsort(all(V));\n\tfor(int y : V) blocker[y] = -1;\n\tvi res,aux;\n\tloop(t,n){\n\t\tint x = -1,p = -1;\n\t\tfor(auto y : V){\n\t\t\tint b = blocker[y],pot = 0;\n\t\t\tif(b != -1) pot = pos[b] + 1;\n\t\t\tif(pot > p) {\n\t\t\t\tp = pot;\n\t\t\t\tx = y;\n\t\t\t}\n\t\t}\n\t\tint i = insert(x,res);\n\t\tV.erase(find(all(V),x));\n\t\tfor(int y : V) {\n\t\t\tint b = blocker[y];\n\t\t\tif(b != -1 && pos[b] > i) continue;\n\t\t\tif(__gcd(x,y) != 1)\n\t\t\t\tblocker[y] = x;\n\t\t}\n\t}\n\tfor(int i = 0;i < n;i++) printf(\"%d%c\",res[i],\" \\n\"[i==n-1]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define forn(i,n) for(int i=0;i<(int)(n);i++)\n#define si(c) ((int)(c).size())\n#define forsn(i,s,n) for(int i = (int)(s); i<((int)n); i++)\n#define dforsn(i,s,n) for(int i = (int)(n)-1; i>=((int)s); i--)\n#define all(c) (c).begin(), (c).end()\n#define D(a) cerr << #a << \"=\" << a << endl;\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\nconst int N = 2020;\nconst int M = 1e5;\n\nint n, p, a[N], force[N];\nvi adj[M], fact[M], primes;\n\nvoid factor(int n, vi &p) {\n    for (int d = 2; d*d <= n; d++) if (n%d == 0) {\n        p.pb(d);\n        while (n%d == 0) n /= d;\n    }\n    if (n > 1) p.pb(n);\n}\n\nbool vis[M], enabled[N];\nint dfs(int u) {\n    if (vis[u]) return n;\n    vis[u] = true;\n\n    int res = n;\n    if (u < n && enabled[u]) res = u;\n    for (int v : adj[u]) res = min(res, dfs(v));\n    return res;\n}\n\nint gcd(int a, int b) { return a ? gcd(b%a,a) : b; }\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n\n    cin >> n;\n    forn(i,n) cin >> a[i];\n    sort(a, a+n);\n\n    forn(i,n) {\n        factor(a[i], fact[i]);\n        for (auto x : fact[i]) primes.pb(x);\n    }\n    sort(all(primes));\n    primes.erase(unique(all(primes)), primes.end());\n    p = si(primes);\n\n    forn(u,n) {\n        for (auto x : fact[u]) {\n            int v = n + lower_bound(all(primes), x) - primes.begin();\n            adj[u].pb(v);\n            adj[v].pb(u);\n        }\n    }\n\n    vi res(n);\n    fill_n(enabled, n, true);\n    forn(i,n) {\n        //forn(j,n) if (enabled[j]) cerr << a[j] << ','; cerr << endl;\n        fill_n(vis,n+p,false);\n        forn(j,i) vis[res[j]] = true;\n        res[i] = -1;\n        forn(u,n) if (!vis[u]) {\n            res[i] = max(res[i], dfs(u));\n        }\n        forn(j,n) {\n            if (gcd(a[res[i]], a[j]) > 1) enabled[j] = true;\n            else if (a[j] > a[res[i]]) enabled[j] = false;\n        }\n        //D(res[i]);\n    }\n    for (auto x : res) cout << a[x] << ' ';\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define FOR(i,a,b) for (register int i=(a);i<=(b);i++)\n#define For(i,a,b) for (register int i=(a);i>=(b);i--)\n#define mem(i,j) memset(i,j,sizeof(i))\n#define GO(u) for (register int j=f[u];j!=-1;j=nxt[j])\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define MP make_pair\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\nconst int N=2020;\nint n,a[N],vis[N],cnt=0,ans[N],du[N];\nint mp[N][N];\nvector<int> G[N];\npriority_queue <pii> q;\ninline int read()\n{\n\tint x=0,f=1;\n\tchar c=getchar();\n\twhile (c<'0'||c>'9') {if (c=='-') f=-1;c=getchar();}\n\twhile (c>='0'&&c<='9') {x=(x<<1)+(x<<3)+c-'0';c=getchar();}\n\treturn f*x;\n}\ninline void write(int x)\n{\n\tif (x<0) putchar('-'),x=-x;\n\tif (x>9) write(x/10);\n\tputchar(x%10+'0');\n\treturn;\n}\ninline int GCD(int x,int y)\n{\n\tif (!y) return x;\n\tif (x<y) return GCD(y,x);\n\treturn GCD(y,x%y);\n}\ninline void dfs(int u)\n{\n\tvis[u]=1;\n\tFOR(v,1,n) if (u!=v&&mp[u][v])\n\t{\n\t\tif (vis[v]) continue;\n\t\tG[u].pb(v);\n\t\tdu[v]++;\n\t\tdfs(v);\n\t}\n\treturn;\n}\nint main()\n{\n\tn=read();\n\tFOR(i,1,n) a[i]=read();\n\tsort(a+1,a+n+1);\n\tFOR(i,1,n) FOR(j,1,n) if (i!=j) if (GCD(a[i],a[j])>1) mp[i][j]=1;\n\tFOR(i,1,n) if (!vis[i])\n\t{\n\t\tdfs(i);\n\t\tq.push(MP(a[i],i));\n\t}\n\twhile (q.size())\n\t{\n\t\tpii tmp=q.top();\n\t\tq.pop();\n\t\tans[++ans[0]]=tmp.fi;\n\t\tFOR(i,0,(int)G[tmp.se].size()-1)\n\t\t{\n\t\t\tint v=G[tmp.se][i];\n\t\t\tdu[v]--;\n\t\t\tif (!du[v]) q.push(MP(a[v],v));\n\t\t}\n\t}\n\tFOR(i,1,n) write(ans[i]),putchar(' ');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 2005;\nint n, a[N];\nbool g[N][N], vis[N];\nvector <int> _merge(vector <vector <int> > a) {\n\tvector <int> ans;\n\tfor (int i = 0; i < a.size(); ++ i) {\n\t\tvector <int> tmp(ans.size() + a.size());\n\t\tmerge(a[i].begin(), a[i].end(), ans.begin(), ans.end(), tmp.begin(), greater <int> ());\n\t\tans = tmp;\n\t}\n\treturn ans;\n}\nvector <int> dfs(int u) {\n\tvis[u] = 1;\n\tvector <vector <int> > tmp;\n\tfor (int i = 0; i < n; ++ i) if (g[u][i] && !vis[i]) tmp.push_back(dfs(i));\n\tvector <int> ans = _merge(tmp);\n\tans.insert(ans.begin(), a[u]);\n\treturn ans;\n}\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; ++ i) scanf(\"%d\", &a[i]);\n\tsort(a, a + n);\n\tfor (int i = 0; i < n; ++ i) for (int j = i + 1; j < n; ++ j) if (__gcd(a[i], a[j]) != 1) g[i][j] = g[j][i] = 1;\n\tvector <vector <int> > tmp;\n\tfor (int i = 0; i < n; ++ i) if (!vis[i]) tmp.push_back(dfs(i));\n\tvector <int> ans = _merge(tmp);\n\tfor (int i = 0; i < ans.size(); ++ i) printf(\"%d%c\", ans[i], \" \\n\"[i + 1 == ans.size()]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 2005\nusing namespace std;\nvector<int> E[N],F[N];\nint n,m,cnt,G[N][N],a[N],vis[N];\nint gcd(int x,int y){ return x ? gcd(y%x,x) : y;}\nvoid dfs(int t)\n{\n\tint i; vis[t]=1;\n\tfor(i=1;i<=n;i++)\n\t\tif(G[t][i]&&!vis[i])\n\t\t\tE[t].push_back(i),dfs(i);\n}\nvoid sol(int t)\n{\n\tint i,p;\n\tif(t<=n) F[t].push_back(t);\n\tfor(i=0;i<E[t].size();i++)\n\t\tsol(E[t][i]),reverse(F[E[t][i]].begin(),F[E[t][i]].end());\n\twhile(1){\n\t\tp=0;\n\t\tfor(i=0;i<E[t].size();i++){\n\t\t\tif(!F[E[t][i]].size()) continue;\n\t\t\tif(!p||F[E[t][i]][F[E[t][i]].size()-1]>F[p][F[p].size()-1]) p=E[t][i];\n\t\t  }\n\t\tif(!p) break;\n\t\tF[t].push_back(F[p][F[p].size()-1]);\n\t\tF[p].pop_back();\n\t  }\n}\nint main()\n{\n\tint i,j;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tsort(a+1,a+n+1);\n\tfor(i=1;i<=n;i++)\n\t\tfor(j=1;j<=n;j++)\n\t\t\tif(gcd(a[i],a[j])!=1) G[i][j]=1;\n\tfor(i=1;i<=n;i++){\n\t\tif(vis[i]) continue;\n\t\tE[n+1].push_back(i),dfs(i);\n\t  }\n\tsol(n+1);\n\tfor(i=0;i<F[n+1].size();i++)\n\t\tprintf(\"%d \",a[F[n+1][i]]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n                                                                                                     \n                                             `-:://:::-                                             \n                                           `//:-------:/:`                                          \n                                          .+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .o:--...```..---+/`                                        \n                                       `/y+o/---....---:+o.                                         \n                                   `...````-os+/:---:/+o/--.`                                       \n              `-/+++++/:.      `...`       :h+d+oooo+/+-`   ...                                     \n            `/++//:::://++-`....`         -.`//````````:`     `..`                                  \n           `o+/::------://o/`           `-` -.          -`       `..`                               \n `---.-o/:./o/::-..``..-ЗАПУСКАЕМ      ..  ..            -`        `...       ``..``                \n  `....o+:-++/:--.```..-://s.        `-`  .-              -`          `-o: .-//::::/:-`             \n          `:s+/:--....-::/+s-`      .-   `-                -`           -///:--------:/:`           \n           ./s+//:::::://oo-``..НЕЙРОННУЮ: СЕТЬ:::::::-`РАБОТЯГИ        `+:--........--:/`          \n            .:ooo+++++osso-`    `.:-...`/` ./::-------:/:`   -`         :+--..``````.--:+:...-+:-`  \n             `.-/+++++/+-.-`    -.   ``:so:/:--.......--:+`  `-```````o+/+--..`````..--:o/-..:s+:.  \n                 ```````:``.. `-`     -` `+:--..`````..--/+-.../.`````..-o:--.......---/o.    `     \n                        `:  `:-      -.  .o:--..`` ``..--:o`   `-`      `:o+:--------:+o-`          \n                         `-`-...    ..   .o/--...```..--:+/`    `-`     `oy/so/////++o/.`           \n                          -/`  `-` `- ``+s/o/:---...---:++.      `-`   .-../d://///:-.`             \n                `.---..``-..-    .-/..`````-oo+/:::::/+o+-        `-``-`  `-.  ````                 \n             `:++++/+++++-  ..``.-/:`      /y-:/++o++/:.`..`       ./.   `-                         \n            -++/::::::://+/..:-``:` ..   `-.`  ```.```    `..`   `..`-` `-                          \n       ``  -o//:--....-::/++` -.-`   `-`.-`                 `..`..`  `-.-                           \n  -----ss+:++/:--.```..-://s.  /.     `::                    `-:.     ./`                           \n  `````/:..+o/::-..``.--:/+s. ..-`   `-``-`                 ..` `-`  `-`-`                          \n          `-s+/::-----::/+oo---``-` ..    .:-    ```      .-`     .-.-  `-`                         \n           `:oo+//::://+os/..:`..-/:`      :y.-:::::::.`.-`        ./-`  `-`                        \n            `./+oooooooo+/.`-    .-:...`.. .//:-------://`        `- `..` `:.                       \n              ``.-::::-.``-/`  `-` `-  `oo:+:--.......--:/`      `-    `.:--h.``..```               \n                          -.-`.-    .-   `+:--..`````..--//`    `-       /s-//::::::::.             \n                         -` `/-      ..  .o:--..`` ``..--:o.```.-        `//:--------://`           \n                        -` .-`.-`     -.`-o/--...```..--:+/.``-:....``:-.+:--....`...--:+`          \n                       ..`-.   `-.   ``:os:o/:---...---:++.  `-     ``///+:-..``````.--:+-````-.`   \n              `.:///////.-`      .:-..` -``-+o+/:::::/+o/.  `-         `:+:-..`````..--:o/:--/ys+-  \n            `-++///////+o/. ``....`-.    :` `.:++++++/:.`  .-           -o/---......---/o.   `.`    \n           `++//:-----::/+o:..`     .-`   :    ```````    .-           `+so+:--------:++-`          \n  `````:-``:o/::-..`..--:/+o`         -.  `-             .-          `../../+o+////+o+:.`           \n  -----syo/o+/:--.```..-://s.          .-` `-           .-        `...     ``-:////:-``             \n       .` `/s//:--....-::/+s.            -. `-`        .-       `..`                                \n           .+o+/:::--:://+s/-..`          .::+y  ```  .-     `..`                                   \n            ./oo++////+oso-`   `....       :y-+:::::::/`   ...                                      \n             `.:+oooooo/-`         `....-. .//:-------:/:-.`                                        \n                ``...``                 /+:+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .+/--...```..--:+/`                                        \n                                         `-o/:---...---:++.                                         \n                                          `-+o+/:---:/+o/.                                          \n                                            `.:+oooo+/-.`                                           \n                                               ``````                                               \n*/\n\n#ifdef aimbot\n#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#endif\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <set>\n#include <queue>\n#include <ostream>\n#include <istream>\n#include <typeinfo>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <limits>\n#include <fstream>\n#include <array>\n#include <list>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <cstring>\n#include <chrono>\n\n#define random escape__from__random__aetuhoetnuhshe\n#define mt make_tuple\n#define x first\n#define y second\n#define pb push_back\n#define ppb pop_back\n#define mp make_pair\n#define umap unordered_map\n#define uset unordered_set\n#define elif else if\n#define len(v) ((int)v.size())\n#define f(i, n) for (int i = 0; i < (n); i++)\n#define rof(i, n) for (int i = ((n) - 1); i >= 0; i--)\n#define apply(v, act) for (auto &x : v) { act; }\n#define log(args...) {string s = #args;deque<string> deq;\\\nstring buf = \"\";int bal = 0;for (char c : s) {\\\nif (c == '(' || c == '[' || c == '{') {bal++;\\\n} else if (c == ')' || c == ']' || c == '}') {\\\nbal--;} else {if (bal == 0) {if (c == ',') {\\\ndeq.pb(buf);buf = \"\";} else {if (c != ' ') {\\\nbuf += c;}}}}}if (!buf.empty()) {deq.pb(buf);}\\\nsmart_io::precall_print();smart_io::_print(deq, args);}\n\ninline int min(const int &x, const int &y) { return (((y-x)>>(32-1))&(x^y))^x; }\ninline int max(const int &x, const int &y) { return (((y-x)>>(32-1))&(x^y))^y; }\ninline long long min(const long long &x, const long long &y) { return (((y-x)>>(64-1))&(x^y))^x; }\ninline long long max(const long long &x, const long long &y) { return (((y-x)>>(64-1))&(x^y))^y; }\n\n#define print    \\\nsmart_io::precall_print(); \\\ncout,\n\n#define scan cin,\n\n#ifdef fast_allocator\nconst int MAXMEM = 200 * 1000 * 1024;\nchar _memory[MAXMEM];\nsize_t _ptr = 0;\nvoid* operator new(size_t _x) { _ptr += _x; assert(_ptr < MAXMEM); return _memory + _ptr - _x; }\nvoid operator delete (void*) noexcept {}\n#endif\n\nusing namespace std;\n\nchar string_in_buffer[(int)260];\n\n\nvoid fast_scan(int &x) { scanf(\"%d\", &x); }\nvoid fast_scan(long long &x) { scanf(\"%lld\", &x); }\nvoid fast_scan(unsigned long long &x) { scanf(\"%llu\", &x); }\nvoid fast_scan(double &x) { scanf(\"%lf\", &x); }\nvoid fast_scan(long double &x) { scanf(\"%Lf\", &x); }\nvoid fast_scan(char &x) {\n\tscanf(\"%c\", &x);\n\tif (x == '\\n') {\n\t\tfast_scan(x);\n\t}\n}\nvoid fast_scan(string &x) {\n\tscanf(\"%s\", string_in_buffer);\n\tx = string(string_in_buffer);\n}\n\ntemplate<class TFirst, class TSecond>\nvoid fast_scan(pair<TFirst, TSecond> &p) {\n\tfast_scan(p.first);\n\tfast_scan(p.second);\n}\n\ntemplate <class T>\nvoid fast_scan(vector<T> &v) {\n\tfor (auto &x : v) fast_scan(x);\n}\n\nvoid fast_print(const int &x) { printf(\"%d\", x); }\nvoid fast_print(const unsigned int &x) { printf(\"%u\", x); }\nvoid fast_print(const long long &x) { printf(\"%lld\", x); }\nvoid fast_print(const unsigned long long &x) { printf(\"%llu\", x); }\nvoid fast_print(const char &x) { printf(\"%c\", x); };\n// void fast_print(__int128 x) {\n// \tif (x == 0) { fast_print('0'); return; }\n// \tif (x < 0) {\n// \t\tfast_print('-');\n// \t\tx = -x;\n// \t}\n// \t__int128 p = 1;\n// \twhile (x / (p * 10)) p *= 10;\n// \twhile (p) {\n// \t\t__int128 symb = x / p;\n// \t\tfast_print((int)symb);\n// \t\tx -= p * symb;\n// \t\tp /= 10;\n// \t}\n// };\nvoid fast_print(const double &x) { printf(\"%.15lf\", x); }\nvoid fast_print(const long double &x) { printf(\"%.15Lf\", x); }\nvoid fast_print(const string &x) { printf(\"%s\", x.c_str());}\nvoid fast_print(const char v[]) { fast_print((string)v); }\n\ntemplate<class TFirst, class TSecond>\nvoid fast_print(const pair<TFirst, TSecond> &p) {\n\tfast_print(p.first);\n\tfast_print(' ');\n\tfast_print(p.second);\n}\n\ntemplate <class T>\nvoid fast_print(const vector<T> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print(' ');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const vector<vector<T>> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print('\\n');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const T &v) {\n\tfor (const auto &x : v) {\n\t\tfast_print(x);\n\t\tfast_print(' ');\n\t}\n}\n\n\nusing namespace std;\n\n\nnamespace smart_io {\n\tstring print_start = \"\";\n\tstring sep = \" \";\n\tbool first_print = false;\n\t\n\tvoid precall_print() {\n\t\tfast_print(print_start);\n\t\tprint_start = \"\\n\";\n\t\tfirst_print = true;\n\t}\n\t\n\tvoid _print(deque<string>) {}\n\ttemplate<class T, class... Args>\n\tvoid _print(deque<string> names, T elem, Args... args) {\n\t\tif (!first_print) {\n\t\t\tfast_print(\"\\n\");\n\t\t} else {\n\t\t\tfirst_print = false;\n\t\t}\n\t\tfast_print(names.front());\n\t\tfast_print(\" = \");\n\t\tfast_print(elem);\n\t\tnames.pop_front();\n\t\t_print(names, args...);\n\t}\n} //namespace smart_io\n\n\ntemplate <class T>\nostream &operator,(ostream &os, const T &object) {\n\tif (!smart_io::first_print) {\n\t\tfast_print(smart_io::sep);\n\t} else {\n\t\tsmart_io::first_print = false;\n\t}\n\tfast_print(object);\n\treturn os;\n}\n\ntemplate <class T>\nistream &operator,(istream &is, T &object) {\n\tfast_scan(object);\n\treturn is;\n}\n\nnamespace random {\n\tusing namespace std::chrono;\n\tmt19937 rng(duration_cast< milliseconds >(\n\t\t\t\t\t\t\t\t\t\t\t  system_clock::now().time_since_epoch()\n\t\t\t\t\t\t\t\t\t\t\t  ).count());\n\tuniform_real_distribution<> prob_dist(0.0, 1.0);\n};\n\nnamespace typedefs {\n\ttypedef long long ll;\n\ttypedef unsigned long long ull;\n\ttypedef pair<int, int> pii;\n\ttypedef long double ld;\n}\n\nnamespace numbers_operation {\n\ttemplate<class T>\n\tinline T floor_mod(T a, const T &b) {\n\t\ta %= b;\t\n\t\tif (a < 0) a += b;\n\t\treturn a;\n\t}\n}\n\nusing namespace numbers_operation;\nusing namespace typedefs;\nusing namespace random;\n\nint n;\nvector<int> v;\nvector<vector<int>> factors;\n\nvoid factorize(int n, vector<int> &rez) {\n\tfor (int i = 2; i * i <= n; i++) {\n\t\twhile (n % i == 0) {\n\t\t\tn /= i;\n\t\t\trez.pb(i);\n\t\t}\n\t}\n\tif (n > 1) rez.pb(n);\n\tsort(rez.begin(), rez.end());\n\trez.resize(unique(rez.begin(), rez.end()) - rez.begin());\n}\n\nint gcd(int a, int b) {\n\treturn __gcd((unsigned int)a, (unsigned int)b);\n}\n\nbool can_add(vector<int> p, int x) {\n\tvector<int> q = p;\n\tp.pb(x);\n\tfor (int i = len(p) - 1; i > 0; i--) {\n\t\tif (gcd(p[i], p[i - 1]) == 1) swap(p[i], p[i - 1]);\n\t\telse break;\n\t\tif (q < p) return false;\n\t}\n\treturn true;\n}\n\nstruct SUS {\n\tvector<int> up;\n\tint get_root(int i) {\n\t\tif (up[i] == i) return i;\n\t\treturn up[i] = get_root(up[i]);\n\t}\n\tSUS(int n) {\n\t\tup.resize(n);\n\t\tf(i, n) up[i] = i;\n\t}\n\tvoid merge(int a, int b) {\n\t\tup[get_root(a)] = get_root(b);\n\t}\n\tbool one_comp(int a, int b) {\n\t\treturn get_root(a) == get_root(b);\n\t}\n};\n\nsigned main(signed argc, char *argv[]) {\n\tscan n;\n\tfactors.resize(n);\n\tv.resize(n);\n\tmap<int, int> cnt;\n\tvector<int> remain;\n\tfor (int i = 0; i < n; i++) {\n\t\tint x;\n\t\tscan x;\n\t\tcnt[x]++;\n\t\tfactorize(x, factors[i]);\n\t\tv[i] = x;\n\t\tif (x > 1 && cnt[x] == 1) {\n\t\t\tremain.pb(i);\n\t\t}\n\t}\n\tsort(remain.begin(), remain.end(), [](int i, int j) {\n\t\treturn v[i] < v[j];\n\t});\n\tvector<int> rez;\n\twhile (!remain.empty()) {\n\t\tint next = -1;\n\t\tSUS sus(len(remain));\n\t\tmap<int, vector<int>> at;\n\t\tfor (int i = 0; i < len(remain); i++) {\n\t\t\tfor (int x : factors[remain[i]]) {\n\t\t\t\tat[x].pb(i);\n\t\t\t}\n\t\t}\n\t\tfor (auto p : at) {\n\t\t\tfor (int j = 0; j < len(p.y) - 1; j++) {\n\t\t\t\tsus.merge(p.y[j], p.y[j + 1]);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < len(remain); i++) {\n\t\t\tif (i > 0) sus.merge(i, i - 1);\n\t\t\tif (!can_add(rez, v[remain[i]])) continue;\n\t\t\tpii max1 = mp(-1, -1), max2 = mp(-1, -1);\n\t\t\tfor (int i = 0; i < len(remain); i++) {\n\t\t\t\tint comp = sus.get_root(i);\n\t\t\t\tint value = v[remain[i]];\n\t\t\t\tif (max1.y == comp || max2.y == comp) {\n\t\t\t\t\tif (max1.y == comp)\n\t\t\t\t\t\tmax1.x = max(max1.x, value);\n\t\t\t\t\tif (max2.y == comp)\n\t\t\t\t\t\tmax2.x = max(max2.x, value);\n\t\t\t\t\tif (max1 < max2) swap(max1, max2);\n\t\t\t\t} else {\n\t\t\t\t\tpii cur = mp(value, comp);\n\t\t\t\t\tif (max1 < cur) swap(max1, cur);\n\t\t\t\t\tif (max2 < cur) swap(max2, cur);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// if (len(remain) == 3) {\n\t\t\t// \tprint max1, max2;\n\t\t\t// }\n\t\t\tint comp = sus.get_root(i);\n\t\t\tint value = v[remain[i]];\n\t\t\tint other = (comp != max1.y) ? max1.x : max2.x;\n\t\t\tif (value >= other) {\n\t\t\t\tnext = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// print max1, max2;\n\t\t// fflush(stdout);\n\t\tassert(next != -1);\n\t\t// print v[remain[next]];\n\t\t// fflush(stdout);\n\t\trez.pb(v[remain[next]]);\n\t\tremain.erase(remain.begin() + next);\n\t}\n\tvector<int> final;\n\trez.pb(1);\n\tfor (int x : rez) {\n\t\tf(k, cnt[x]) {\n\t\t\tfinal.pb(x);\n\t\t}\n\t}\n\tprint final;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <cmath>\n\nusing namespace std;\n\nconst int MAXN = 100000 + 1000;\n\nint gcd(int x, int y)\n{\n\treturn x == 0 ? y : gcd(y % x, x);\n}\n\nvector<int> merge(const vector<int> &a, const vector<int> &b)\n{\n\tvector<int> ret;\n\tint i = 0, j = 0;\n\twhile(i < a.size() && j < b.size())\n\t\tret.push_back(a[i] > b[j] ? a[i++] : b[j++]);\n\twhile(i < a.size())\n\t\tret.push_back(a[i++]);\n\twhile(j < b.size())\n\t\tret.push_back(b[j++]);\n\treturn ret;\n}\n\nint n, s[MAXN];\nvector<int> ans;\nvector<int> edg[MAXN];\nbool vis[MAXN];\n\nbool cmp_s(int x, int y)\n{\n\treturn s[x] < s[y];\n}\n\nvector<int> dfs(int x, int fa)\n{\n\tvector<int> ret;\n\tvis[x] = true;\n\tfor(int i = 0; i < edg[x].size(); i++)\n\t\tif(edg[x][i] != fa)\n\t\t{\n\t\t\tint y = edg[x][i];\n\t\t\t// cerr << x << ' ' << y << endl;\n\t\t\tif(!vis[y])\n\t\t\t\tret = merge(ret, dfs(y, x));\n\t\t}\n\tret.insert(ret.begin(), s[x]);\n\treturn ret;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\t// freopen(\"1.in\", \"r\", stdin);\n\t// freopen(\"1.out\", \"w\", stdout);\n\n\tcin >> n;\n\tfor(int i = 1; i <= n; i++)\n\t\tcin >> s[i];\n\tfor(int i = 1; i <= n; i++)\n\t\tfor(int j = i + 1; j <= n; j++)\n\t\t\tif(gcd(s[i], s[j]) > 1)\n\t\t\t\tedg[i].push_back(j), edg[j].push_back(i);\n\tfor(int i = 1; i <= n; i++)\n\t\tsort(edg[i].begin(), edg[i].end(), cmp_s);\n\n\tans.clear();\n\tfor(int i = 1; i <= n; i++)\n\t\tif(!vis[i])\n\t\t\tans = merge(ans, dfs(i, 0));\n\tfor(int i = 1; i <= n; i++)\n\t\tcout << ans[i - 1] << ' ';\n\tcout << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define FOR(i,a,b) for (register int i=(a);i<=(b);i++)\n#define For(i,a,b) for (register int i=(a);i>=(b);i--)\n#define mem(i,j) memset(i,j,sizeof(i))\n#define GO(u) for (register int j=f[u];j!=-1;j=nxt[j])\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define MP make_pair\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\nconst int N=2020;\nint n,a[N],vis[N],cnt=0,ans[N],du[N];\nvector<int> vec[N],G[N];\npriority_queue <pii> q;\ninline int read()\n{\n\tint x=0,f=1;\n\tchar c=getchar();\n\twhile (c<'0'||c>'9') {if (c=='-') f=-1;c=getchar();}\n\twhile (c>='0'&&c<='9') {x=(x<<1)+(x<<3)+c-'0';c=getchar();}\n\treturn f*x;\n}\ninline void write(int x)\n{\n\tif (x<0) putchar('-'),x=-x;\n\tif (x>9) write(x/10);\n\tputchar(x%10+'0');\n\treturn;\n}\ninline int GCD(int x,int y)\n{\n\tif (!y) return x;\n\tif (x<y) return GCD(y,x);\n\treturn GCD(y,x%y);\n}\ninline void dfs(int u)\n{\n\tvis[u]=1;\n\tFOR(i,0,(int)vec[u].size()-1)\n\t{\n\t\tint v=vec[u][i];\n\t\tif (vis[v]) continue;\n\t\tG[u].pb(v);\n\t\tdu[v]++;\n\t\tdfs(v);\n\t}\n\treturn;\n}\nbool cmp(const int x,const int y) {return a[x]<a[y];}\nint main()\n{\n\tn=read();\n\tFOR(i,1,n) a[i]=read();\n\tFOR(i,1,n) FOR(j,1,n) if (i!=j) if (GCD(a[i],a[j])>1) vec[i].pb(j);\n\tFOR(i,1,n) sort(vec[i].begin(),vec[i].end(),cmp);\n\tFOR(i,1,n) if (!vis[i])\n\t{\n\t\tdfs(i);\n\t\tq.push(MP(a[i],i));\n\t}\n\twhile (q.size())\n\t{\n\t\tpii tmp=q.top();\n\t\tq.pop();\n\t\tans[++ans[0]]=tmp.fi;\n\t\tFOR(i,0,(int)G[tmp.se].size()-1)\n\t\t{\n\t\t\tint v=G[tmp.se][i];\n\t\t\tdu[v]--;\n\t\t\tif (!du[v]) q.push(MP(a[v],v));\n\t\t}\n\t}\n\tFOR(i,1,n) write(ans[i]),putchar(' ');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n;\nint num[2001];\nvector<int> g[2001];\nbool used[2001];\nvector<int> order[2001];\nint siz;\nvoid dfs(int p){\n    used[p]=1;\n    if(g[p].size())\n        for(int i=0;i<g[p].size();i++)\n            if(!used[g[p][i]]){\n                dfs(g[p][i]);\n                break;\n            }\n    order[siz].push_back(num[p]);\n}\nint main(){\n    cin>>n;\n    for(int i=0;i<n;i++)\n        cin>>num[i];\n    for(int i=0;i<n;i++)\n        for(int j=i+1;j<n;j++)\n            if(__gcd(num[i],num[j])!=1){\n                g[i].push_back(j);\n                g[j].push_back(i);\n            }\n    for(int i=0;i<n;i++)\n        sort(g[i].begin(),g[i].end());\n    for(int i=0;i<n;i++)\n        if(!used[i])\n            dfs(i),siz++;\n    for(int i=0;i<n;i++)\n        reverse(order[i].begin(),order[i].end());\n    sort(order,order+n);\n    reverse(order,order+n);\n    for(int i=0;i<siz;i++)\n        for(int j=0;j<order[i].size();j++)\n            cout<<order[i][j]<<\" \";\n    cout<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \nusing namespace std;\n//author_name:tourist\n//date:2018/11/18\n//title:AGC 010 E Rearranging\n//ÒòÎªÇÓÅ³£¬ËùÒÔÌÓ±ÜÉúÃü£¬ÒÔ²»µÖ¿¹ÔÚ×îºÚ°µµÄ³ÁÂÙÖÐÉú³ö½¾°Á£¬ÒòÎª½¾°Á£¬ËùÒÔ²»Ñ¡ÔñÉú£¬ËùÒÔ¾Ü³â´Ö±ÉµÄÀÖ¹ÛÖ÷Òå¡£\n//Ìì²ÅµÄ±¯¾çµØÓÚ±»Ð¡¶øÊæÊÊµÄÃûÍûËùÊø¸¿¡£\n//It's human to lie. Most of the time we can't even be honest with ourselves.\n\nconst int N=2010;\nconst int NN=2010;\n\nunsigned long long one=1;\nunsigned long long g[N][NN];\nunsigned long long was[NN];\n\nint a[N];\nint x[N];\nbool alive[N];\nbool can_put[N];\n\nint main()\n{\t\n\tint n;\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++)\n\t\tscanf(\"%d\",a+i);\n\tfor(int i=0;i<n;i++)\n\t\tfor(int j=0;j<n;j++)\n\t\t\tif(__gcd(a[i],a[j])>1)\n\t\t\t{\n\t\t\t\tg[i][j>>6]|=(one<<(j&63));\n\t\t\t\tg[j][i>>6]|=(one<<(i&63));\n\t\t\t}\n\tint nn=((n-1)>>6)+1;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcan_put[i]=true;\n\t\talive[i]=true;\n\t}\n\tfor(int it=0;it<n;it++)\n\t{\n\t\tfor(int i=0;i<nn;i++)\n\t\t\twas[i]=0;\n\t\tfor(int i=0;i<n;i++)\n\t\t\tif(!alive[i])\n\t\t\t\twas[i>>6]|=(one<<(i&63));\n\t\tint best=-1;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tif(was[i >> 6]&(one << (i&63)))\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tint b=0,e=1;\n\t\t\tx[0]=i;\n\t\t\twas[i >> 6]|=(one << (i&63));\n\t\t\twhile(b<e)\n\t\t\t{\n\t\t\t\tfor(int j=0;j<nn;j++)\n\t\t\t\t\tif((g[x[b]][j]&was[j])!=g[x[b]][j])\n\t\t\t\t\t\tfor(int u=j*64;u<(j+1)*64;u++)\n\t\t\t\t\t\t\tif(g[x[b]][u >> 6] & (one << (u&63)))\n\t\t\t\t\t\t\t\tif(!(was[u >> 6] & (one << (u&63))))\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\twas[u >> 6]|=(one << (u&63));\n\t\t\t\t\t\t\t\t\tx[e++]=u;\n\t\t\t\t\t\t\t\t}\n\t\t\t\tb++;\n\t\t\t}\n\t\t\tint cur=-1;\n\t\t\tfor(int j=0;j<e;j++)\n\t\t\t{\n\t\t\t\tif(!can_put[x[j]])\n\t\t\t\t\tcontinue;\n\t\t\t\tif(cur==-1||a[cur]>a[x[j]])\n\t\t\t\t\tcur=x[j];\n\t\t\t}\n\t\t\tif(best==-1||(cur!=-1&&a[cur]>a[best]))\n\t\t\t\tbest=cur;\n\t\t}\n\t\talive[best]=false;\n\t\tif(it>0) putchar(' ');\n\t\tprintf(\"%d\",a[best]);\n\t\t\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tif(!alive[i])\n\t\t\t\tcontinue;\n\t\t\tif(g[best][i >> 6] & (one << (i&63)))\n\t\t\t\tcan_put[i]=true;\n\t\t\telse {\n\t\t\t\tif(a[best]<a[i]) \n\t\t\t\t\tcan_put[i]=false;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int MAXN = 2010;\nstd::priority_queue<int> q;\nstd::vector<int> to[MAXN], gr[MAXN];\nint gcd(int a, int b) { return b ? gcd(b, a % b) : a; }\nint n, A[MAXN], ind[MAXN], tim[MAXN], idx;\nbool vis[MAXN];\nint main() {\n\tstd::ios_base::sync_with_stdio(false), std::cin.tie(0);\n\tstd::cin >> n;\n\tfor (int i = 1; i <= n; ++i) std::cin >> A[i];\n\tstd::sort(A + 1, A + 1 + n);\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = i + 1; j <= n; ++j)\n\t\t\tif (gcd(A[i], A[j]) > 1) {\n\t\t\t\tgr[i].push_back(j);\n\t\t\t\tgr[j].push_back(i);\n\t\t\t}\n\tfor (int i = 1; i <= n; ++i) if (!vis[i]) {\n\t\tq.push(-i); vis[i] = true;\n\t\twhile (!q.empty()) {\n\t\t\tint t = -q.top(); q.pop(); tim[t] = ++idx;\n\t\t\tfor (auto j : gr[t]) if (!vis[j])\n\t\t\t\tq.push(-j), vis[j] = true;\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (auto t : gr[i])\n\t\t\tif (tim[i] < tim[t])\n\t\t\t\t++ind[t], to[i].push_back(t);\n\tfor (int i = 1; i <= n; ++i) if (!ind[i]) q.push(i);\n\tfor (int i = 1, t; i <= n; ++i) {\n\t\tstd::cout << (A[t = q.top()]) << (\" \\n\" [i == n]); q.pop();\n\t\tfor (int j : to[t]) if (!--ind[j]) q.push(j);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint N, a[2017];\nbool ap[2017][2017], col[2017];\n\nint gcd (int a, int b)\n{\n    int r;\n    while (b)\n        r = a % b, a = b, b = r;\n    return a;\n}\n\nvoid print (vector < int > x, string s)\n{\n    bool ndSpace = 0;\n    printf (\"[\");\n    for (auto it : x)\n    {\n        if (ndSpace) printf (\" \");\n        printf (\"%d\", it), ndSpace = 1;\n    }\n    printf (\"]%s\", s.c_str ());\n}\n\nvector < int > combine (vector < int > a, vector < int > b)\n{\n    auto itA = a.begin (), itB = b.begin ();\n    vector < int > c;\n    while (itA != a.end () || itB != b.end ())\n    {\n        if (itA == a.end () || (itB != b.end () && *itA < *itB)) c.push_back (*itB), itB ++;\n        else c.push_back (*itA), itA ++;\n    }\n    return c;\n}\n\nvector < int > currComp;\nset < int > currP;\nvoid dfs (int nod)\n{\n    col[nod] = 0, currComp.push_back (nod), currP.erase (nod);\n    vector < int > neig;\n    for (auto i : currP)\n        if (ap[nod][i] && col[i])\n            neig.push_back (i);\n    for (auto i : neig)\n        currP.erase (i);\n    for (auto i : neig)\n        dfs (i);\n}\n\nvector < int > solve (int frbd, vector < int > P)\n{\n    int mini = 1e9, how = -1;\n    currP.clear ();\n    for (auto it : P)\n        if (a[it] < mini && (frbd == -1 || ap[frbd][it]))\n            mini = a[it], how = it;\n    for (auto it : P)\n        if (it != how)\n            currP.insert (it), col[it] = 1;\n    vector < vector < int > > splt;\n    while (!currP.empty ())\n    {\n        for (auto i : currP)\n            if (ap[how][i] && col[i])\n            {\n                currComp.clear (), currP.erase (i);\n                dfs (i), splt.push_back (currComp);\n                break;\n            }\n    }\n    vector < int > ans;\n    for (auto v : splt)\n        ans = combine (ans, solve (how, v));\n    if (frbd != -1)\n        ans.insert (ans.begin (), a[how]);\n    return ans;\n}\n\nint main ()\n{\n//freopen (\"input\", \"r\", stdin);\n//freopen (\"output\", \"w\", stdout);\n\nscanf (\"%d\", &N);\nfor (int i=1; i<=N; i++)\n    scanf (\"%d\", &a[i]);\nfor (int i=0; i<=N; i++)\n    for (int j=i + 1; j<=N; j++)\n        ap[i][j] = ap[j][i] = (i == 0 || gcd (a[i], a[j]) != 1);\nvector < int > elems;\nfor (int i=0; i<=N; i++)\n    elems.push_back (i);\nvector < int > ans = solve (-1, elems);\nfor (auto it : ans)\n    printf (\"%d \", it);\nprintf (\"\\n\");\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \nusing namespace std; \nint gi() { \n\tint res = 0, w = 1; \n\tchar ch = getchar(); \n\twhile (ch != '-' && !isdigit(ch)) ch = getchar(); \n\tif (ch == '-') w = -1, ch = getchar(); \n\twhile (isdigit(ch)) res = res * 10 + ch - '0', ch = getchar(); \n\treturn res * w; \n} \ntypedef long long LL;\nconst int MAX_N = 2e3 + 5; \nint N, a[MAX_N]; \nvector<int> G[MAX_N];\nbool vis[MAX_N]; \nvoid dfs(int x) { \n\tvis[x] = 1; \n\tfor (int i = 1; i <= N; i++)\n\t\tif (!vis[i] && __gcd(a[i], a[x]) != 1) \n\t\t\tG[x].push_back(i), dfs(i); \n} \nint main () { \n#ifndef ONLINE_JUDGE \n    freopen(\"cpp.in\", \"r\", stdin); \n#endif \n\tN = gi(); \n\tfor (int i = 1; i <= N; i++) a[i] = gi();\n\tsort(&a[1], &a[N + 1]); \n\tfor (int i = 1; i <= N; i++) sort(G[i].begin(), G[i].end());\n\tpriority_queue<int> Q; \n\tfor (int i = 1; i <= N; i++) \n\t\tif (!vis[i]) dfs(i), Q.push(i); \n\twhile (!Q.empty()) { \n\t\tint x = Q.top(); Q.pop(); \n\t\tfor (int i = 0; i < (int)G[x].size(); i++) Q.push(G[x][i]); \n\t\tprintf(\"%d \", a[x]); \n\t} \n\tputchar('\\n'); \n    return 0; \n} "
  },
  {
    "language": "C++",
    "code": "#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cstdio>\n#include<vector>\n#include<functional>\n#include<queue>\n\nusing namespace std;\nconst int MX=2011;\nint n,a[MX];\nstruct Edge{int t,nxt;Edge(int _t=0,int _nxt=0):t(_t),nxt(_nxt){}}e[MX*MX];\nint hed[MX],ec;\ninline void ade(int f,int t){e[++ec]=Edge(t,hed[f]);hed[f]=ec;}\n#define FE(k,i) for(int (i)=hed[k];(i);(i)=e[i].nxt)if(!vis[e[i].t])\ninline int gcd(int x,int y){if(x<y)swap(x,y);while(y)x%=y,swap(x,y);return x;}\n\nint vis[MX],stk[MX],nxt[MX],stc;\n\nvoid mktr(int k){\n\tvis[k]=1;\n\tint cur=k;\n\tpriority_queue<int,vector<int>,greater<int> >q;\n\twhile(!q.empty())q.pop();\n\tFE(k,i)q.push(e[i].t),vis[e[i].t]=1;\n\twhile(!q.empty()){\n\t\tint r=q.top();q.pop();\n\t\tnxt[cur]=r;cur=r;\n\t\tFE(r,i)q.push(e[i].t),vis[e[i].t]=1;\n\t}\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\tif(gcd(a[i],a[j])>1)ade(i,j),ade(j,i);\n\tfor(int i=1;i<=n;i++)if(!vis[i])stk[++stc]=i,mktr(i);\n\tfor(int i=stc;i;i--)for(int j=stk[i];j;j=nxt[j])printf(\"%d \",a[j]);\n\tputs(\"\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define ll long long\n\n#define maxN 2017\n\nint n, nn, i, j;\nint a[maxN], aa[maxN];\n\nint gr[maxN];\nvector<int> list[maxN], adj[maxN];\npriority_queue<int> H;\n\nbool us[maxN];\n\nint cmmdc(int a, int b) {\n    if (a < b) swap(a, b);\n\n    while (b != 0) {\n        a %= b;\n        swap(a, b);\n    }\n\n    return a;\n}\n\nvoid dfs(int node) {\n    us[node] = true;\n    a[++nn] = aa[node];\n\n    sort(adj[node].begin(), adj[node].end(), [](int x, int y)->bool const {\n        return aa[x] < aa[y];\n    });\n\n    for (auto to : adj[node])\n        if (!us[to])\n            dfs(to);\n}\n\nint main()\n{\n   // freopen(\"test.in\",\"r\",stdin);\n\n    scanf(\"%d\", &n);\n    for (i = 1; i <= n; i++) scanf(\"%d\", &a[i]), aa[i] = a[i];\n    sort(a + 1, a + n + 1);\n    sort(aa + 1, aa + n + 1);\n\n    for (i = 1; i <= n; i++) {\n        for (j = i + 1; j <= n; j++) {\n            if (cmmdc(a[i], a[j]) != 1) {\n                adj[i].pb(j);\n                adj[j].pb(i);\n            }\n        }\n    }\n\n    nn = 0;\n    for (i = 1; i <= n; i++)\n        if (!us[i])\n            dfs(i);\n\n\n    for (i = 1; i <= n; i++) {\n        for (j = i + 1; j <= n; j++) {\n            if (cmmdc(a[i], a[j]) != 1)\n                list[i].pb(j), gr[j]++;\n        }\n    }\n\n    for (i = 1; i <= n; i++)\n        if (gr[i] == 0)\n            H.push(i);\n\n    while (!H.empty()) {\n        int node = H.top(); H.pop();\n        printf(\"%d \", a[node]);\n\n        for (auto to : list[node])\n            if (--gr[to] == 0)\n                H.push(to);\n    }\n\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<typename T> \nmap<T, Int> factorize(T x){\n  map<T, Int> res;\n  for(Int i=2;i*i<=x;i++){\n    while(x%i==0){\n      x/=i;\n      res[i]++;\n    }\n  }\n  if(x!=1) res[x]++;\n  return res;\n}\n\n//INSERT ABOVE HERE\nInt cop[2020][2020];\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<Int> a(n);\n  for(Int i=0;i<n;i++) cin>>a[i];\n  sort(a.begin(),a.end());\n\n  vector<Int> ans(n);\n\n  memset(cop,0,sizeof(cop));\n  \n  for(Int i=0;i<n;i++)\n    for(Int j=0;j<n;j++)\n      cop[i][j]=__gcd(a[i],a[j])>1;\n\n  Int m=0;\n  map<Int, Int> r;\n\n  vector<vector<Int> > G(n*100);\n  for(Int i=0;i<n;i++){\n    auto x=factorize(a[i]);\n    for(auto p:x){\n      if(!r.count(p.first)) r[p.first]=m++;\n      G[i].emplace_back(n+r[p.first]);\n      G[n+r[p.first]].emplace_back(i);\n    }\n  }\n  \n  vector<Int> used(n+m,0),post(n,0);\n  for(Int t=0;t<n;t++){\n    vector<Int> cs(n+m,-1);\n    Int color=0;\n    for(Int i=0;i<n+m;i++){\n      if(used[i]||~cs[i]) continue;\n      queue<Int> q;\n      cs[i]=color;\n      q.emplace(i);\n      while(!q.empty()){\n\tInt v=q.front();q.pop();\n\tfor(Int u:G[v]){\n\t  if(used[u]||~cs[u]) continue;\n\t  cs[u]=color;\n\t  q.emplace(u);\n\t}\n      }\n      color++;\n    }\n    \n    Int idx=-1;\n    for(Int i=0;i<n;i++){\n      if(used[i]||post[i]) continue;\n      idx=i;\n      break;\n    }\n    \n    used[idx]=1;\n    ans[t]=idx;\n    \n    for(Int i=0;i<n;i++){\n      if(cs[idx]!=cs[i]) continue;\n      if(cop[idx][i]) post[i]=0;\n      else if(a[idx]<a[i]) post[i]=1;\n    }\n  }\n\n\n  vector<Int> b(n);\n  for(Int i=0;i<n;i++) b[i]=a[ans[i]];\n  \n  vector<vector<Int> > H(n);\n  for(Int i=0;i<n;i++)\n    for(Int j=i+1;j<n;j++)\n      if(__gcd(b[i],b[j])>1) H[i].emplace_back(j);\n\n  vector<Int> indeg(n);\n  for(Int i=0;i<n;i++)\n    for(Int j:H[i]) indeg[j]++;\n  \n  using P = pair<Int, Int>;\n  priority_queue<P> pq;\n  for(Int i=0;i<n;i++)\n    if(!indeg[i]) pq.emplace(b[i],i);\n\n  vector<Int> c;\n  while(!pq.empty()){\n    P p=pq.top();pq.pop();\n    c.emplace_back(p.first);\n    for(Int u:H[p.second]){\n      indeg[u]--;\n      if(!indeg[u]) pq.emplace(b[u],u);\n    }\n  }\n  \n  assert((Int)c.size()==n);\n  for(Int i=0;i<n;i++){\n    if(i) cout<<\" \";\n    cout<<c[i];\n  }\n  cout<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <queue>\n#define maxn 505\nusing namespace std;\ntypedef long long ll;\nint n,a[maxn];\nvector <int> adj[maxn];\nbool vis[maxn];\nvector <int> chi[maxn];\nint gcd(int a,int b){\n\tif(a % b == 0) return b;\n\treturn gcd(b,a % b);\n}\nvoid dfs(int u){\n\tvis[u] = true;\n\tfor(int i=0;i<(int)adj[u].size();i++){\n\t\tint v = adj[u][i];\n\t\tif(!vis[v]){\n\t\t\tchi[u].push_back(v);\n\t\t\tdfs(v);\n\t\t}\n\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=i + 1;j<=n;j++){\n\t\t\tif(gcd(a[i],a[j]) != 1){\n\t\t\t\tadj[i].push_back(j);\n\t\t\t\tadj[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++) sort(adj[i].begin(),adj[i].end());\n\tpriority_queue <int> que;\n\tfor(int i=1;i<=n;i++){\n\t\tif(!vis[i]){\n\t\t\tdfs(i);\n\t\t\tque.push(i);\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tint u = que.top();que.pop();\n\t\tprintf(\"%d%c\",a[u],i == n ? '\\n' : ' ');\n\t\tfor(int j=0;j<(int)chi[u].size();j++){\n\t\t\tque.push(chi[u][j]);\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<queue>\n#include<vector>\nusing namespace std;\nconst int maxn=2003;\nint a[maxn],n,g[maxn][maxn],vis[maxn],in[maxn];\nvector<int>G[maxn];\nint gcd(int a,int b) { return a==0?b:gcd(b%a,a); }\nvoid dfs(int now)\n{\n    vis[now]=1;\n    for(int i=1;i<=n;i++)\n        if(!vis[i] and g[now][i])\n        {\n            in[i]++;\n            dfs(i);\n            G[now].push_back(i);\n        }\n}\nvoid Top()\n{\n    priority_queue<int>que;\n    for(int i=1;i<=n;i++)\n        if(!in[i])\n            que.push(i);\n    while(!que.empty())\n    {\n        int x=que.top(); que.pop();\n        cout<<x<<' ';\n        for(int i=0;i<G[x].size();i++)\n            que.push(G[x][i]);\n    }\n}\nint main()\n{\n    cin>>n;\n    for(int i=1;i<=n;i++)\n        cin>>a[i];\n    sort(a+1,a+n+1);\n    for(int i=1;i<=n;i++)\n        for(int j=i+1;j<=n;j++)\n            if(gcd(i,j)!=1)\n                g[i][j]=g[j][i]=1;\n    for(int i=1;i<=n;i++)\n        if(!vis[i])\n            dfs(i);\n    Top();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define all(x)  x.begin(), x.end()\n#define mp      make_pair\n\nvector<int> g[2020];\nint used[2020];\nvector<int> a;\nvector<int> tmp;\n\nvoid dfs(int v, int prev) {\n        used[v] = true;\n        tmp.push_back(a[v]);\n        vector<pair<int, int>> p;\n        for (auto u : g[v]) if (u != prev) p.emplace_back(a[u], u);\n        sort(all(p));\n        for (auto u : p) {\n                if (!used[u.second]) {\n                        dfs(u.second, v);\n                }\n        }\n}\n\nint main() {\n        int n;\n        scanf(\"%d\", &n);\n        a.resize(n);\n        for (int i = 0; i < n; i ++) scanf(\"%d\", &a[i]);\n        for (int i = 0; i < n; i ++) {\n                for (int j = i + 1; j < n; j ++) {\n                        if (__gcd(a[i], a[j]) != 1) {\n                                g[i].push_back(j);\n                                g[j].push_back(i);\n                        }\n                }\n        }\n        sort(all(a));\n        for (int i = 0; i < n; i ++) {\n                if (!used[i]) {\n                        dfs(i, -1);\n                }\n        }\n        for (int i = 0; i < n; i ++) g[i].clear();\n        for (int i = 0; i < n; i ++) {\n                for (int j = i + 1; j < n; j ++) {\n                        if (__gcd(tmp[i], tmp[j]) != 1) {\n                                g[i].push_back(j);\n                        }\n                }\n        }\n        vector<int> in_cnt(n, 0);\n        for (int i = 0; i < n; i ++) {\n                for (auto u : g[i]) {\n                        in_cnt[u] ++;\n                }\n        }\n        priority_queue<pair<int, int>> pq;\n        for (int i = 0; i < n; i ++) if (in_cnt[i] == 0) pq.push(mp(tmp[i], i));\n        vector<int> ans;\n        while (!pq.empty()) {\n                auto get = pq.top();\n                pq.pop();\n                ans.push_back(get.first);\n                for (auto u : g[get.second]) {\n                        in_cnt[u] --;\n                        if (in_cnt[u] == 0) pq.push(mp(tmp[u], u));\n                }\n        }\n        for (int i = 0; i < n; i ++) cout << ans[i] << (i == n - 1 ? '\\n' : ' ');\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#define MAXN 2000\nusing namespace std;\npriority_queue<int> que;\nvector<int> G[MAXN+5];\nvector<int> ans;\nint n,a[MAXN+5],d[MAXN+5];\nint M[MAXN+5][MAXN+5];\nbool vis[MAXN+5];\nint gcd(int x,int y)\n{\n\tif(y==0)\n\t\treturn x;\n\treturn gcd(y,x%y);\n}\nvoid DFS(int u)\n{\n\tvis[u]=true;\n\tfor(int v=1;v<=n;v++)\n\t\tif(vis[v]==false&&M[u][v])\n\t\t{\n\t\t\td[v]++;\n\t\t\tG[u].push_back(v);\n\t\t\tDFS(v);\n\t\t}\n}\nint main()\n{\n//\tfreopen(\"newgame.in\",\"r\",stdin);\n//\tfreopen(\"newgame.out\",\"w\",stdout);\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tsort(a+1,a+1+n);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\tif(gcd(a[i],a[j])!=1)\n\t\t\t\tM[i][j]=M[j][i]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tif(vis[i]==false)\n\t\t\tDFS(i);\n\tfor(int i=1;i<=n;i++)\n\t\tif(d[i]==0)\n\t\t\tvis[i]=true,que.push(i);\n\tmemset(vis,0,sizeof(vis));\n\twhile(que.empty()==false)\n\t{\n\t\tint u=que.top();\n\t\tque.pop();\n\t\tans.push_back(u);\n\t\tfor(int i=0;i<(int)G[u].size();i++)\n\t\t{\n\t\t\tint v=G[u][i];\n\t\t\tif(vis[v]==false)\n\t\t\t{\n\t\t\t\tvis[v]=true;\n\t\t\t\tque.push(v);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<(int)ans.size();i++)\n\t\tif(i==0)\n\t\t\tprintf(\"%d\",a[ans[i]]);\n\t\telse\n\t\t\tprintf(\" %d\",a[ans[i]]);\n\tprintf(\"\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define int long long\nconst int maxn=2e3+100,inf=1e17;\nint A[maxn],sor[maxn],mn,n;\nbool mark[maxn],mark2[maxn];\nvector<int> g[maxn],ans[maxn];\nmap<int,int> HASH;\nset<int> s;\n\nbool cmp(int x,int y){return x>y;}\n\nvoid Hsh()\n{\n  for(int i=0;i<n;i++){\n    HASH[A[i]]=i+1;\n  }\n}\n\nvoid input()\n{\n  cin>>n;\n  for(int i=0;i<n;i++)\n    cin>>A[i];\n  Hsh();\n}\n\nvoid make_g()\n{\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      if(i!=j)\n\tif(__gcd(A[i],A[j])!=1)\n\t  g[i+1].push_back(j+1);\n}\n\nvoid dfs(int v)\n{\n  //cout<<v<<\" \"<<A[v-1]<<endl;\n  mark[v]=true;\n  mn=min(A[v-1],mn);\n  for(int i=0;i<g[v].size();i++)\n    if(!mark[g[v][i]])\n      dfs(g[v][i]);\n}\n\nint32_t main()\n{\n  mn=inf;\n  input();\n  make_g();\n  int cnt=0;\n  for(int i=0;i<n;i++)\n    if(!mark[i+1])\n      {\n\tdfs(i+1);\n\tint mn2=mn;\n\tsor[cnt++]=mn2;\n\tmn=inf;\n\ts.insert(mn2);\n\tmark2[HASH[mn2]]=true;\n\t//cout<<mn2<<endl;\n\twhile(!s.empty())\n\t  {\n\t    //cout<<\"HERE\"<<endl;\n\t    int v=*s.begin();\n\t    ans[HASH[mn2]-1].push_back(v);\n\t    s.erase(s.begin());\n\t    for(int j=0;j<g[HASH[v]].size();j++)\n\t      if(!mark2[g[HASH[v]][j]])\n\t\t{\n\t\t  s.insert(A[g[HASH[v]][j]-1]);\n\t\t  mark2[g[HASH[v]][j]]=true;\n\t\t}\n\t  }\n      }\n  sort(sor,sor+cnt,cmp);\n  for(int i=0;i<cnt;i++)\n    for(int j=0;j<ans[HASH[sor[i]]-1].size();j++)\n      cout<<ans[HASH[sor[i]]-1][j]<<\" \";\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=2005;\nint l,f[N],n,b[N][N],flag2[N],a[N],flag[N];\nvector<int>Ans[N];\ninline void down(int x){\n\tint i=x;\n\tif (x*2<=l&&f[x*2]<f[x])i=x*2;\n\tif (x*2<l&&f[x*2+1]<f[i])i=x*2+1;\n\tif (i!=x){\n\t\tswap(f[x],f[i]);\n\t\tdown(x);\n\t}\n}\ninline void up(int x){\n\tif (x==1)return;\n\tif (f[x]<f[x/2]){\n\t\tswap(f[x],f[x/2]);\n\t\tup(x/2);\n\t}\n}\ninline void dfs(int x){\n\tflag2[x]=1;\n\tfor (int i=1;i<=n;i++)\n\t\tif (!flag2[i]&&b[x][i]){\n\t\t\tflag[i]++;\n\t\t\tAns[x].push_back(i);\n\t\t\tdfs(i);\n\t\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n\tsort(a+1,a+n+1);\n\tfor (int i=1;i<=n;i++)\n\t\tfor (int j=i+1;j<=n;j++)\n\t\t\tif (__gcd(a[i],a[j])!=1)b[i][j]=b[j][i]=1;\n\tfor (int i=1;i<=n;i++)\n\t\tif (!flag2[i])dfs(i);\n\tfor (int i=1;i<=n;i++)\n\t\tif (!flag[i])f[++l]=i,up(l);\n\twhile (l){\n\t\tint now=f[1];\n\t\tf[1]=f[l--];\n\t\tdown(1);\n\t\tprintf(\"%d \",a[now]);\n\t\tfor (int i:Ans[now])f[++l]=i,up(l);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef double db;\nconst int N=100010,M=4000010,P=1e9+7;\nconst int inf=0x3f3f3f3f;\nconst int INF=0xcfcfcfcf;\nconst double eps=1e-9,pi=asin(1)*2;\ninline ll read();\n#define cmax(a,b) a=max(a,b)\n#define cmin(a,b) a=min(a,b)\ninline int ADD(int a,int b) { return a+b>=P?a+b-P:a+b; }\ninline int MINUS(int a,int b) { return a-b<0?a-b+P:a-b; }\n#define plus(a,b) a=ADD(a,b)\n#define minus(a,b) a=MINUS(a,b)\n#define mul(a,b) a=(1ll*a*(b))%P\n#define mem(a,b) memset(a,b,sizeof(a))\n#define pii pair<int,int>\n#define pil pair<int,ll>\n#define pli pair<ll,int>\n#define pll pair<ll,ll>\n#define mp(x,y) make_pair(x,y)\n\ninline int gcd(int x,int y) { return y?gcd(y,x%y):x; }\nint head[N],ver[M],nxt[M],du[N];\nint n,m,tot=1;\nint a[N];\ninline void add(int x,int y)\n{\n\tver[++tot]=y,nxt[tot]=head[x],head[x]=tot,du[y]++;\n}\n\nbool G[2010][2010];\nbool visit[N];\ninline void dfs(int x)\n{\n\tvisit[x]=true;\n\tfor(int y=1;y<=n;y++)\n\t{\n\t\tif(visit[y]||!G[x][y]) continue;\n\t\tadd(x,y);\n\t\tdfs(y);\n\t}\n}\npriority_queue<int> q;\n\n#ifdef FILE\nconst int READ_SIZE=1<<20;\nchar buf[READ_SIZE],*p1=buf,*p2=buf;\n#define getchar() p1==p2&&(p2=(p1=buf)+fread(buf,1,READ_SIZE,stdin),p1==p2)?EOF:*p1++\n#endif\ninline ll read()\n{\n\tll s=0;\n\tbool flag=false;\n\tchar ch=getchar();\n\tfor(;ch<'0'||ch>'9';ch=getchar()) if(ch=='-') flag=true;\n\tfor(;'0'<=ch&&ch<='9';ch=getchar()) s=(s<<3)+(s<<1)+(ch^'0');\n\tif(flag) return -s;\n\treturn s;\n}\n\nint main()\n{\n#ifdef FILE\n\tfreopen(FILE \".in\",\"r\",stdin);\n\tfreopen(FILE \".out\",\"w\",stdout);\n#endif\n\tn=read();\n\tfor(int i=1;i<=n;i++) a[i]=read();\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\tif(gcd(a[i],a[j])>1)\n\t\t\t\tG[i][j]=G[j][i]=true;\n\tfor(int i=1;i<=n;i++)\n\t\tif(!visit[i]) dfs(i);\n\t\n\twhile(q.size()) q.pop();\n\tfor(int i=1;i<=n;i++)\n\t\tif(!du[i]) q.push(i);\n\t\n\twhile(q.size())\n\t{\n\t\tint x=q.top();q.pop();\n\t\tprintf(\"%d \",a[x]);\n\t\tfor(int i=head[x];i;i=nxt[i])\n\t\t{\n\t\t\tint y=ver[i];\n\t\t\tdu[y]--;\n\t\t\tif(!du[y]) q.push(y);\n\t\t}\n\t}\n\tputchar('\\n');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n#define MOD @\n#define ADD(X,Y) ((X) = ((X) + (Y)%MOD) % MOD)\ntypedef long long i64; typedef vector<int> ivec; typedef vector<string> svec;\n\nint gcd(int a, int b)\n{\n\twhile (b) {\n\t\tint t = a % b;\n\t\ta = b;\n\t\tb = t;\n\t}\n\treturn a;\n}\n\nint N, A[2020];\nvector<int> dv[2020];\nvector<int> rdiv[50505];\nint RC;\n\nbool isok[2020], used[2020];\nbool rdivvis[50505];\nbool vis[2020];\n\nint chk()\n{\n\tfor (int i = 0; i < N; ++i) vis[i] = false;\n\tfor (int i = 0; i < RC; ++i) rdivvis[i] = false;\n\n\tqueue<int> Qa;\n\tint top = 0;\n\tint ret = -1;\n\n\tfor (;;) {\n\t\twhile (top < N) {\n\t\t\tif (!used[top] && isok[top] && !vis[top]) {\n\t\t\t\tQa.push(top);\n\t\t\t\tvis[top] = true;\n\t\t\t\tret = top;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t++top;\n\t\t}\n\t\tif (top == N) break;\n\t\twhile (!Qa.empty()) {\n\t\t\tint v = Qa.front(); Qa.pop();\n\t\t\tfor (int p : dv[v]) if (!rdivvis[p]) {\n\t\t\t\trdivvis[p] = true;\n\t\t\t\tfor (int i : rdiv[p]) if (!used[i] && !vis[i]) {\n\t\t\t\t\tvis[i] = true;\n\t\t\t\t\tQa.push(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main()\n{\n\tscanf(\"%d\", &N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tscanf(\"%d\", A + i);\n\t}\n\tsort(A, A + N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tint v = A[i];\n\t\tfor (int j = 2; j * j <= v; ++j) {\n\t\t\tif (v % j == 0) {\n\t\t\t\tdv[i].push_back(j);\n\t\t\t\twhile (v % j == 0) v /= j;\n\t\t\t}\n\t\t}\n\t\tif (v > 1) dv[i].push_back(v);\n\t}\n\tvector<int> alldv;\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int p : dv[i]) alldv.push_back(p);\n\t}\n\tsort(alldv.begin(), alldv.end());\n\talldv.erase(unique(alldv.begin(), alldv.end()), alldv.end());\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int &p : dv[i]) {\n\t\t\tp = lower_bound(alldv.begin(), alldv.end(), p) - alldv.begin();\n\t\t\trdiv[p].push_back(i);\n\t\t}\n\t}\n\tRC = alldv.size();\n\n\tfor (int i = 0; i < N; ++i) {\n\t\tisok[i] = true;\n\t\tused[i] = false;\n\t}\n\n\tvector<int> ans;\n\tfor (int i = 0; i < N; ++i) {\n\t\tint id = chk();\n\t\tint v = A[id];\n\t\tans.push_back(v);\n\t//\tprintf(\"%d\\n\", v);\n\t\tused[id] = true;\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tif (A[j] > v) {\n\t\t\t\tisok[j] = false;\n\t\t\t}\n\t\t\tif (gcd(A[j], v) != 1) {\n\t\t\t\tisok[j] = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < N; ++i) printf(\"%d%c\", ans[i], i == N - 1 ? '\\n' : ' ');\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define X first\n#define Y second\n\nint gcd(int a,int b) {return b?gcd(b,a%b):a;}\n\nconst int maxn=4010;\n\nint n,times,a[maxn],dfn[maxn],deg[maxn];\nint tote,FIR[maxn],TO[maxn],NEXT[maxn];\nint vis[maxn];\npriority_queue<pair<int,int> > q;\n\nvoid addedge(int u,int v)\n{\n\tTO[++tote]=v;\n\tNEXT[tote]=FIR[u];\n\tFIR[u]=tote;\n}\n\nint search(int u)\n{\n\tint Ans=u;\n\tvis[u]=1;\n\tfor (int p=FIR[u];p;p=NEXT[p])\n\t{\n\t\tint v=TO[p];\n\t\tif (vis[v]) continue;\n\t\tint tmp=search(v);\n\t\tAns=a[Ans]<a[tmp]?Ans:tmp;\n\t}\n\treturn Ans;\n}\n\nvoid dfs(int u)\n{\n\tvis[u]=2;\n\tdfn[u]=++times;\n\tvector<pair<int,int> > son;\n\tson.clear();\n\tfor (int p=FIR[u];p;p=NEXT[p])\n\t\tson.push_back(make_pair(a[TO[p]],TO[p]));\n\tsort(son.begin(),son.end());\n\tfor (int i=0;i<(int)son.size();i++)\n\t\tif (vis[son[i].Y]!=2) dfs(son[i].Y);\n}\n\nint main()\n{\n#ifdef h10\n\tfreopen(\"E.in\",\"r\",stdin);\n\tfreopen(\"E.out\",\"w\",stdout);\n#endif\n\tint i,j;\n\tscanf(\"%d\",&n);\n\tfor (i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tfor (i=1;i<=n;i++)\n\tfor (j=i+1;j<=n;j++)\n\t\tif (gcd(a[i],a[j])!=1)\n\t\t\taddedge(i,j),addedge(j,i);\n\n\tvector<pair<int,int> > root;\n\tfor (i=1;i<=n;i++)\n\t\tif (!vis[i])\n\t\t{\n\t\t\tint tmp=search(i);\n\t\t\troot.push_back(make_pair(a[tmp],tmp));\n\t\t}\n\tsort(root.begin(),root.end());\n\tfor (i=0;i<(int)root.size();i++) dfs(root[i].Y);\n\n\ttote=0;\n\tmemset(FIR,0,sizeof(FIR));\n\tfor (i=1;i<=n;i++)\n\tfor (j=1;j<=n;j++)\n\t\tif (gcd(a[i],a[j])!=1&&dfn[i]<dfn[j])\n\t\t\taddedge(i,j),deg[j]++;\n\n\tfor (i=1;i<=n;i++)\n\t\tif (!deg[i]) q.push(make_pair(a[i],i));\n\twhile (!q.empty())\n\t{\n\t\tpair<int,int> u=q.top(); q.pop();\n\t\tprintf(\"%d \",u.X);\n\t\tfor (int p=FIR[u.Y];p;p=NEXT[p])\n\t\t{\n\t\t\tint v=TO[p];\n\t\t\tif (!(--deg[v])) q.push(make_pair(a[v],v));\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int N = 2005;\nbool G[N][N];\nbool used[N];\nint n, a[N], sz;\nvector <int> cc[N];\npriority_queue <pair <int, pair <int, int> > > pq;\ninline int gcd(int a, int b) { return !b ? a : gcd(b, a % b); }\n\nvoid dfs(int i, int c) {\n\tused[i] = 1;\n\tcc[c].push_back(i);\n\tfor (int j = 0; j < n; ++ j) if (!used[j] && G[i][j]) { dfs(j, c); break; }\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; ++ i) scanf(\"%d\", &a[i]);\n\tsort(a, a + n);\n\tfor (int i = 0; i < n; ++ i) for (int j = 0; j < n; ++ j) if (i ^ j) G[i][j] = (gcd(a[i], a[j]) != 1);\n\tfor (int i = 0; i < n; ++ i) if (!used[i]) dfs(i, sz ++);\n\tfor (int i = 0; i < sz; ++ i) pq.push(make_pair(cc[i][0], make_pair(i, 0)));\n\twhile (!pq.empty()) {\n\t\tauto p = pq.top(); pq.pop();\n\t\tprintf(\"%d \", a[p.first]);\n\t\tint i = p.second.first;\n\t\tint j = p.second.second;\n\t\tif (j + 1 < (int) cc[i].size()) pq.push(make_pair(cc[i][j + 1], make_pair(i, j + 1)));\n\t}\n\tputs(\"\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//MIPT Cryptozoology\n//Room 265\n#define _CRT_SECURE_NO_WARNINGS\n#pragma comment (linker, \"/STACK:128000000\")\n#include <stdio.h>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <queue>\n#include <deque>\n#include <cmath>\n#include <ctime>\n#include <stack>\n#include <bitset>\n#include <set>\n#include <map>\n#include <cassert>\n#include <memory.h>\n#include <sstream>\n\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define all(a) a.begin(), a.end()\n#define itn int\n\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\n\ntypedef long long li;\ntypedef long long i64;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef pair <int, int> pi;\n\nvoid solve(bool);\n\nvoid precalc();\n\nint TESTNUM = 0;\n#define FILENAME \"\"\n\nint main() {\n\tstring s = FILENAME;\n#ifdef YA\n\t//assert(!s.empty());\n\tfreopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\t//cerr<<FILENAME<<endl;\n\t//assert (s != \"change me please\");\n\tclock_t start = clock();\n#else\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\t//freopen(FILENAME \".in\", \"r\", stdin);\n\t//freopen(FILENAME \".out\", \"w\", stdout);\n\tcin.tie(0);\n#endif\n\tcout.sync_with_stdio(0);\n\tcout.precision(10);\n\tcout << fixed;\n\tprecalc();\n\tint t = 1;\n\t//cin >> t;\n\tint test_num = 1;\n\twhile (t--) {\n\t\t//cout << \"Case #\" << test_num++ << \": \";\n\t\t++TESTNUM;\n\t\tsolve(true);\n\t}\n#ifdef YAH\n\twhile (true) {\n\t\tsolve(false);\n\t}\n#endif\n#ifdef YA\n\tcerr << \"\\n\\n\\n\" << (clock() - start) / 1.0 / CLOCKS_PER_SEC << \"\\n\\n\\n\";\n#endif\n\treturn 0;\n}\n\n//#define int li\n\n/*int pr[] = { 97, 2011 };\nint mods[] = { 1000000007, 1000000009 };\n\nconst int C = 100500;\nint powers[2][C];*/\n\n//int MOD = 1000000007;\n\n//int c[5010][5010];\n\ntemplate<typename T>\nT binpow(T q, T w, T mod) {\n\tif (!w)\n\t\treturn 1 % mod;\n\tif (w & 1)\n\t\treturn q * 1LL * binpow(q, w - 1, mod) % mod;\n\treturn binpow(q * 1LL * q % mod, w / 2, mod);\n}\n\nvoid precalc() {\n\n\t/*for (int w = 0; w < 2; ++w) {\n\tpowers[w][0] = 1;\n\tfor (int j = 1; j < C; ++j) {\n\tpowers[w][j] = (powers[w][j - 1] * 1LL * pr[w]) % mods[w];\n\t}\n\t}*/\n\n\t/*for (int i = 0; i < 5010; ++i) {\n\tc[i][i] = c[i][0] = 1;\n\tfor (int j = 1; j < i; ++j) {\n\tc[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % MOD;\n\t}\n\t}*/\n}\n\ntemplate<typename T>\nT gcd(T q, T w) {\n\twhile (w) {\n\t\tq %= w;\n\t\tswap(q, w);\n\t}\n\treturn q;\n}\ntemplate<typename T>\nT lcm(T q, T w) {\n\treturn q / gcd(q, w) * w;\n}\n\ninline int nxt(){\n\tint x;\n\tcin >> x;\n\treturn x;\n}\n\n//#define int li\n\nint n;\nvector<int> dsu;\nvoid init() {\n\tdsu.resize(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tdsu[i] = i;\n\t}\n}\n\nint find_set(int v) {\n\tif (dsu[v] == v) {\n\t\treturn v;\n\t}\n\treturn dsu[v] = find_set(dsu[v]);\n}\n\nvoid merge(int q, int w) {\n\tq = find_set(q);\n\tw = find_set(w);\n\tdsu[q] = w;\n}\n\nvoid solve(bool read) {\n\tcin >> n;\n\tvector<int> a(n);\n\tvector<vector<int>> primes(n);\n\tmap<int, set<int>> poses;\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t\tint cur = a[i];\n\t\tfor (int p = 2; p * p <= cur; ++p) {\n\t\t\tif (cur % p == 0) {\n\t\t\t\tposes[p].insert(i);\n\t\t\t\tprimes[i].push_back(p);\n\t\t\t\twhile (cur % p == 0) {\n\t\t\t\t\tcur /= p;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (cur > 1) {\n\t\t\tposes[cur].insert(i);\n\t\t\tprimes[i].push_back(cur);\n\t\t}\n\t}\n\tvector<int> res;\n\tvector<char> used(n, false);\n\tfor (int i = 0; i < n; ++i) {\n\t\tinit();\n\t\tfor (auto& item : poses) {\n\t\t\tfor (auto it = item.second.begin(); it != item.second.end(); ++it) {\n\t\t\t\tauto nex = it;\n\t\t\t\t++nex;\n\t\t\t\tif (nex == item.second.end()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tmerge(*it, *nex);\n\t\t\t}\n\t\t}\n\n\t\tvector<vector<int>> comps(n);\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (!used[i]) {\n\t\t\t\tcomps[find_set(i)].push_back(i);\n\t\t\t}\n\t\t}\n\n\t\tint cur_take = -1;\n\t\tint cur_id = -1;\n\t\tfor (int i = 0; i < comps.size(); ++i) {\n\t\t\tsort(all(comps[i]), [&a](int q, int w) {\n\t\t\t\treturn a[q] < a[w];\n\t\t\t});\n\t\t\tint best = 2e9;\n\t\t\tint best_id = -1;\n\t\t\tfor (int cur : comps[i]) {\n\t\t\t\tint cand = a[cur];\n\t\t\t\tbool f = true;\n\t\t\t\tfor (int prev = (int)res.size() - 1, its = 0; prev >= 0 && its < 100; --prev, ++its) {\n\t\t\t\t\tif (gcd(res[prev], cand) > 1) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (cand > res[prev]) {\n\t\t\t\t\t\tf = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (f) {\n\t\t\t\t\tif (best > cand) {\n\t\t\t\t\t\tbest = cand;\n\t\t\t\t\t\tbest_id = cur;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!comps[i].empty() && best > cur_take) {\n\t\t\t\tcur_take = best;\n\t\t\t\tcur_id = best_id;\n\t\t\t}\n\t\t}\n\t\t\n\t\tassert(cur_take != -1);\n\t\tres.push_back(a[cur_id]);\n\t\tused[cur_id] = true;\n\t\tfor (int p : primes[cur_id]) {\n\t\t\tposes[p].erase(cur_id);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tcout << res[i] << \" \";\n\t}\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\ncat <<EOF >mistaken-paste\n*/\n\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <time.h>\n\n#define BIG 2000000007\n#define VERYBIG 2000000000000007LL\n\n#define MOD 1000000007\n#define FOD  998244353\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\n#define N_MAX 1000000\n#define M_MAX 200000\n\n#ifdef __cplusplus\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <array>\n\nusing std::queue;\nusing std::priority_queue;\nusing std::stack;\nusing std::tuple;\nusing std::set;\nusing std::map;\nusing std::vector;\nusing std::greater;\nusing std::pair;\nusing std::string;\n\n#endif\n\ntypedef struct {\n\tint32_t a;\n\tint32_t b;\n} hw;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n} hwll;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n\tsll c;\n} hwllc;\n\ntypedef struct {\n\thwll a;\n\thwll b;\n} linell;\n\null n, m;\null h, w;\null k;\null q;\nsll va, vb, vc, vd, ve, vf;\null ua, ub, uc, ud, ue, uf;\nlong double vra, vrb, vrc;\ndouble vda, vdb, vdc;\nchar ch, dh;\n\null umin (ull x, ull y) {\n\treturn (x < y) ? x : y;\n}\n\null umax (ull x, ull y) {\n\treturn (x > y) ? x : y;\n}\n\nsll smin (sll x, sll y) {\n\treturn (x < y) ? x : y;\n}\n\nsll smax (sll x, sll y) {\n\treturn (x > y) ? x : y;\n}\n\null gcd (ull x, ull y) {\n\tif (x < y) {\n\t\treturn gcd(y, x);\n\t} else if (y == 0) {\n\t\treturn x;\n\t} else {\n\t\treturn gcd(y, x % y);\n\t}\n}\n\null bitpow (ull a, ull x, ull modulo) {\n\tull result = 1;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tresult *= a;\n\t\t\tresult %= modulo;\n\t\t}\n\t\tx /= 2;\n\t\ta = (a * a) % modulo;\n\t}\n\treturn result;\n}\n\null divide (ull a, ull b, ull modulo) {\n\treturn (a * bitpow(b, modulo - 2, modulo)) % modulo;\n}\n\null udiff (ull a, ull b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nsll sdiff (sll a, sll b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nint bitcount (ull n) {\n\tint result = 0;\n\twhile (n) {\n\t\tif (n & 1) result++;\n\t\tn /= 2;\n\t}\n\treturn result;\n}\n\n// double distance (sll x1, sll y1, sll x2, sll y2) {\n// \tdouble xdist2, ydist2, origindist, dist;\n\n// \txdist2 = (x1 - x2) * (x1 - x2);\n// \tydist2 = (y1 - y2) * (y1 - y2);\n// \treturn sqrt(xdist2 + ydist2);\n// }\n\nint32_t pullcomp (const void *left, const void *right) {\n\tull l = *(ull*)left;\n\tull r = *(ull*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t psllcomp (const void *left, const void *right) {\n\tsll l = *(sll*)left;\n\tsll r = *(sll*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t pcharcomp (const void *left, const void *right) {\n\tchar l = *(char*)left;\n\tchar r = *(char*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t pdoublecomp (const void *left, const void *right) {\n\tdouble l = *(double*)left;\n\tdouble r = *(double*)right;\n\tif (l < r) {\n\t\treturn -1;\n\t}\n\tif (l > r) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t pstrcomp (const void *left, const void *right) {\n\tchar* l = *(char**)left;\n\tchar* r = *(char**)right;\n\n\treturn strcmp(l, r);\n}\n\nint32_t phwllABcomp (const void *left, const void *right) {\n\thwll l = *(hwll*)left;\n\thwll r = *(hwll*)right;\n\tif (l.a < r.a) {\n\t\treturn -1;\n\t}\n\tif (l.a > r.a) {\n\t\treturn +1;\n\t}\n\tif (l.b < r.b) {\n\t\treturn -1;\n\t}\n\tif (l.b > r.b) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t phwllREVcomp (const void *left, const void *right) {\n\thwll l = *(hwll*)left;\n\thwll r = *(hwll*)right;\n\tif (l.b < r.b) {\n\t\treturn -1;\n\t}\n\tif (l.b > r.b) {\n\t\treturn +1;\n\t}\n\tif (l.a < r.a) {\n\t\treturn -1;\n\t}\n\tif (l.a > r.a) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nint32_t ptriplecomp (const void *left, const void *right) {\n\thwllc l = *(hwllc*)left;\n\thwllc r = *(hwllc*)right;\n\n\tif (l.a < r.a) {\n\t\treturn -1;\n\t}\n\tif (l.a > r.a) {\n\t\treturn +1;\n\t}\n\tif (l.b < r.b) {\n\t\treturn -1;\n\t}\n\tif (l.b > r.b) {\n\t\treturn +1;\n\t}\n\tif (l.c < r.c) {\n\t\treturn -1;\n\t}\n\tif (l.c > r.c) {\n\t\treturn +1;\n\t}\n\treturn 0;\n}\n\nbool isinrange (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right);\n}\n\nbool isinrange_soft (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right) || (left >= x && x >= right);\n}\n\nsll a[N_MAX];\n// sll a[3001][3001];\nsll b[N_MAX];\n// sll b[3001][3001];\nsll c[N_MAX];\n// sll d[N_MAX];\n// sll e[N_MAX];\nchar s[N_MAX + 1];\n// char s[3010][3010];\nchar t[N_MAX + 1];\n// char t[3010][3010];\n// hwll xy[N_MAX];\n// sll table[1000][1000];\n\nset<ull> g[2002];\nbool iscoprime[2002][2002];\n\null iswatched[2002];\null labels[2002];\null id = 0;\nvoid toggle (ull v, ull x, ull id) {\n\tif (iswatched[v] == x) return;\n\n\tiswatched[v] = x;\n\tlabels[v] = id;\n\tfor (ull u : g[v]) {\n\t\ttoggle(u, x, id);\n\t}\n}\n\ntypedef pair<ull, ull> P;\nvector<ull> merge(vector<vector<ull>> x) {\n\tvector<ull> v;\n\n\tull curr[x.size()];\n\tpriority_queue<P, vector<P> > que;\n\tfor (ull i = 0; i < x.size(); i++) {\n\t\tcurr[i] = 0;\n\t\tque.push(P(x[i][0], i));\n\t}\n\twhile (!que.empty()) {\n\t\tP p = que.top();\n\t\tque.pop();\n\n\t\tv.push_back(p.first);\n\t\tull i = p.second;\n\t\tif (++curr[i] < x[i].size()) {\n\t\t\tque.push(P(x[i][curr[i]], i));\n\t\t}\n\t}\n\n\treturn v;\n}\n\nvector<ull> func (ull v) {\n\tvector<ull> r;\n\t\n\tset<ull> s = g[v];\n\tpriority_queue<ull, vector<ull>, greater<ull> > que;\n\ttoggle(v, 0, id++);\n\tfor (ull u : s) {\n\t\tg[u].erase(v);\n\t\tque.push(u);\n\t}\n\n\tvector<vector<ull>> vs;\n\twhile (!que.empty()) {\n\t\tull u = que.top();\n\t\tque.pop();\n\t\tif (iswatched[u]) continue;\n\n\t\ttoggle(u, 1, id++);\n\t\tvs.push_back(func(u));\n\t}\n\tiswatched[v] = 1;\n\n\tr = merge(vs);\n\tr.insert(r.begin(), v);\n\n\treturn r;\n}\n\null solve () {\n\tsll i, j, ki, li;\n\tull result = 0;\n\t// sll result = 0;\n\tdouble dresult = 0;\n\t// ull maybe = 0;\n\tsll maybe = 0;\n\t// ull sum = 0;\n\tsll sum = 0;\n\tsll item;\n\tull *dpcell;\n\n\tqsort(a, n, sizeof(ull), pullcomp);\n\n\tfor (i = 0; i < n; i++) {\n\t\tfor (j = 0; j < n; j++) {\n\t\t\tif (i != j && gcd(a[i], a[j]) > 1) {\n\t\t\t\tg[i].insert(j);\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<vector<ull>> finals;\n\n\tfor (i = 0; i < n; i++) {\n\t\tif (iswatched[i]) continue;\n\n\t\ttoggle(i, 1, id++);\n\t\tfinals.push_back(func(i));\n\t\t// for (j = 0; j < finals[finals.size() - 1].size(); j++) printf(\"%llu \", finals[finals.size() - 1][j]);\n\t\t// \tputs(\"\");\n\t\t// fflush(stdout);\n\t}\n\tvector<ull> r = merge(finals);\n\tfor (i = 0; i < n; i++) {\n\t\tprintf(\"%llu%c\", a[r[i]], (i == n - 1 ? '\\n' : ' '));\n\t}\n\n\t// printf(\"%lld\\n\", result);\n\t// printf(\"%.15lf\\n\", dresult);\n\t// puts(s);\n\n\treturn 0;\n\n\tsuccess:\n\t// puts(\"YES\");\n\tputs(\"Yes\");\n\t// printf(\"%llu\\n\", result);\n\t// puts(\"0\");\n\t// puts(\"Yay!\");\n\treturn 0;\n\n\tfail:\n\t// puts(\"NO\");\n\tputs(\"No\");\n\t// puts(\"0\");\n\t// puts(\"-1\");\n\t// puts(\"-1 -1 -1\");\n\t// puts(\":(\");\n\treturn 1;\n}\n\nint32_t main (void) {\n\tint32_t i, j;\n\tint32_t x, y;\n\n\tscanf(\"%llu\", &n, &m);\n\t// scanf(\"%llu\", &k, &n, &m);\n\t// scanf(\"%llu%llu\", &h, &w);\n\t// scanf(\"%lld\", &va, &vb, &vc, &vd);\n\t// scanf(\"%llu%llu\", &ua, &ub, &uc, &ud);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%s\", s);\n\t// scanf(\"%s\", t);\n\tfor (i = 0; i < n; i++) {\n\t\t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t\tscanf(\"%lld\", &a[i]);\n\t\t// scanf(\"%lld\", &b[i]);\n\t\t// scanf(\"%lld\", &c[i]);\n\t\t// scanf(\"%lld\", &d[i]);\n\t\t// a[i]--;\n\t\t// b[i]--;\n\t\t// c[i]--;\n\t}\n\t// scanf(\"%llu\", &m, &k);\n\t// scanf(\"%llu\", &q);\n\t// for (i = 0; i < n; i++) {\n\t// \tscanf(\"%lld\", &b[i]);\n\t// }\n\n\t// for (i = 0; i < h; i++) {\n\t// \tfor (j = 0; j < w; j++) {\n\t// \t\tscanf(\"%llu\", &table[i][j]);\n\t// \t}\n\t// }\n\t// for (i = 0; i < h; i++) {\n\t// \tscanf(\"%s\", &s[i]);\n\t// }\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <stdio.h>\n#include <stdlib.h>\n#include <vector>\n#include <map>\n//#include <self/operator>\n#include <queue>\n#include <set>\n#include <string>\n#include <string.h>\n#include <stack>\n#include <assert.h>\n#include <bitset>\n#define Endl endl\n#define mp make_pair\n#define ll long long \n#define ull unsigned long long\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define over(A) {cout<<A<<endl;exit(0);}\n#define all(A) A.begin(),A.end()\n#define ceil(a,b) ((a-1)/b+1)\n#define quickcin ios_base::sync_with_stdio(false);\nconst int mod=1e9+7;\nconst int inf=1039074182;\nconst ll llinf=1LL*inf*inf;\nusing namespace std;\ntemplate <typename T1,typename T2> inline void chmin(T1 &x,T2 b) {if(b<x) x=b;}\ntemplate <typename T1,typename T2> inline void chmax(T1 &x,T2 b) {if(b>x) x=b;}\ntemplate <typename T1,typename T2> inline void chadd(T1 &x,T2 b) {x+=b;if(x>=mod) x-=mod;}\ntemplate <typename T1,typename T2> inline void chmul(T1 &x,T2 b) {x=1LL*x*b%mod;}\ntemplate <typename T1,typename T2> inline void chmod(T1 &x,T2 b) {x%=b,x+=b;if(x>=b) x-=b;}\nint n;\nint a[2005];\nvector <int> vec[2000+2000*8+5];\nint visit[2000+2000*8+5];\nint colors;\nmap <int,int> toid;\nbool isprime[10005];\nvector <int> prime;\nbool block[2000+2000*8+5];\nbool e[2005][2005];\nint tot;\n\ninline vector <int> merge(vector <int> a,vector <int> b)\n{\n\tvector <int> res;\n\tint la=(int)a.size();\n\tint lb=(int)b.size();\n\tres.push_back(a[0]);\n\tfor(int i=1,j=0;;)\n\t{\n\t\tif(i==la && j==lb) break;\n\t\tif(i==la) res.push_back(b[j++]);\n\t\telse if(j==lb) res.push_back(a[i++]);\n\t\telse if(a[i]>b[j]) res.push_back(a[i++]);\n\t\telse res.push_back(b[j++]);\n\t}\n\treturn res;\n}\n\npii dfs(int x,int col,int head)\n{\n//\tcout<<x<<' '<<col<<' '<<head<<endl;\n\tvisit[x]=col;\n\tpii res={inf,-1};\n\tif(x<n && (head==-1 || e[head][x])) res={a[x],x};\n\tfor(auto u:vec[x])\n\t{\n\t\tif(block[u]) continue;\n\t\tif(visit[u]>=col) continue;\n\t\tchmin(res,dfs(u,col,head));\n\t}\n\treturn res;\n}\n\nvector <int> solve(int x)\n{\n\tassert(x<n);\n\tblock[x]=true;\n\tcolors++;\n\tvisit[x]=colors;\n\tvector <int> res;\n\tres.push_back(a[x]);\n\tvector <int> adj;\n\tfor(auto &u:vec[x])\n\t{\n\t\tadj.push_back(u);\n\t}\n\tfor(auto &u:adj)\n\t{\n\t\tif(visit[u]>=colors) continue;\n\t\tif(block[u]) continue;\n\t\tint minx=dfs(u,colors,x).second;\n\t\tif(minx==-1) continue;\n\t\tres=merge(res,solve(minx));\n\t}\n\tcolors--;\n\treturn res;\n}\n\nvoid init()\n{\n\tmemset(isprime,true,sizeof(isprime));\n\tisprime[0]=isprime[1]=false;\n\tfor(int i=2;i<=10000;i++)\n\t{\n\t\tif(isprime[i]) prime.push_back(i);\n\t\tfor(auto &j:prime)\n\t\t{\n\t\t\tif(i*j>10000) break;\n\t\t\tisprime[i*j]=false;\n\t\t\tif(i%j==0) break;\n\t\t}\n\t}\n}\n\nvoid add_edge(int x,int p)\n{\n\tif(toid.find(p)==toid.end()) toid[p]=tot++;\n\tint y=toid[p];\n\tvec[x].push_back(y);\n\tvec[y].push_back(x);\n}\n\nvoid build_graph()\n{\n\tint tn;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\ttn=a[i];\n\t\tfor(auto &p:prime)\n\t\t{\n\t\t\tif(tn%p==0) add_edge(i,p);\n\t\t\twhile(tn%p==0) tn/=p;\n\t\t}\n\t\tif(tn!=1) add_edge(i,tn);\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<n;j++)\n\t\t{\n\t\t\tif(i==j) continue;\n\t\t\tif(__gcd(a[i],a[j])!=1) e[i][j]=true;\n\t\t}\n\t}\n}\n\nvoid gogo()\n{\n\tcolors++;\n\tvector <int> res;\n\tres.push_back(0);\n\tvector <int> adj;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tadj.push_back(i);\n\t}\n\tfor(auto &u:adj)\n\t{\n\t\tif(visit[u]>=colors) continue;\n\t\tif(block[u]) continue;\n\t\tint minx=dfs(u,colors,-1).second;\n\t\tif(minx==-1) continue;\n\t\tvector <int> temp=solve(minx);\n//\t\tcout<<temp<<endl;\n\t\tres=merge(res,temp);\n\t}\n\tcolors--;\n\tfor(int i=1;i<res.size();i++)\n\t{\n\t\tcout<<res[i]<<' ';\n\t}\n\tcout<<endl;\n}\n\nvoid print_graph()\n{\n\tcout<<\"--------Graph is below--------\"<<endl;\n\tfor(int i=0;i<tot;i++)\n\t{\n\t\tfor(int &j:vec[i])\n\t\t{\n\t\t\tcout<<i<<' '<<j<<endl;\n\t\t}\n\t}\n\tcout<<\"--------Graph is above--------\"<<endl;\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\",\"r\",stdin);\n\tinit();\n\tcin>>n;\n\ttot=n;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcin>>a[i];\n\t}\n\tbuild_graph();\n//\tprint_graph();\n\tgogo();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//MIPT Cryptozoology\n//Room 265\n#define _CRT_SECURE_NO_WARNINGS\n#pragma comment (linker, \"/STACK:128000000\")\n#include <stdio.h>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <queue>\n#include <deque>\n#include <cmath>\n#include <ctime>\n#include <stack>\n#include <bitset>\n#include <set>\n#include <map>\n#include <cassert>\n#include <memory.h>\n#include <sstream>\n\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define all(a) a.begin(), a.end()\n#define itn int\n\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\n\ntypedef long long li;\ntypedef long long i64;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef pair <int, int> pi;\n\nvoid solve(bool);\n\nvoid precalc();\n\nint TESTNUM = 0;\n#define FILENAME \"\"\n\nint main() {\n\tstring s = FILENAME;\n#ifdef YA\n\t//assert(!s.empty());\n\tfreopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\t//cerr<<FILENAME<<endl;\n\t//assert (s != \"change me please\");\n\tclock_t start = clock();\n#else\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\t//freopen(FILENAME \".in\", \"r\", stdin);\n\t//freopen(FILENAME \".out\", \"w\", stdout);\n\tcin.tie(0);\n#endif\n\tcout.sync_with_stdio(0);\n\tcout.precision(10);\n\tcout << fixed;\n\tprecalc();\n\tint t = 1;\n\t//cin >> t;\n\tint test_num = 1;\n\twhile (t--) {\n\t\t//cout << \"Case #\" << test_num++ << \": \";\n\t\t++TESTNUM;\n\t\tsolve(true);\n\t}\n#ifdef YAH\n\twhile (true) {\n\t\tsolve(false);\n\t}\n#endif\n#ifdef YA\n\tcerr << \"\\n\\n\\n\" << (clock() - start) / 1.0 / CLOCKS_PER_SEC << \"\\n\\n\\n\";\n#endif\n\treturn 0;\n}\n\n//#define int li\n\n/*int pr[] = { 97, 2011 };\nint mods[] = { 1000000007, 1000000009 };\n\nconst int C = 100500;\nint powers[2][C];*/\n\n//int MOD = 1000000007;\n\n//int c[5010][5010];\n\ntemplate<typename T>\nT binpow(T q, T w, T mod) {\n\tif (!w)\n\t\treturn 1 % mod;\n\tif (w & 1)\n\t\treturn q * 1LL * binpow(q, w - 1, mod) % mod;\n\treturn binpow(q * 1LL * q % mod, w / 2, mod);\n}\n\nvoid precalc() {\n\n\t/*for (int w = 0; w < 2; ++w) {\n\tpowers[w][0] = 1;\n\tfor (int j = 1; j < C; ++j) {\n\tpowers[w][j] = (powers[w][j - 1] * 1LL * pr[w]) % mods[w];\n\t}\n\t}*/\n\n\t/*for (int i = 0; i < 5010; ++i) {\n\tc[i][i] = c[i][0] = 1;\n\tfor (int j = 1; j < i; ++j) {\n\tc[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % MOD;\n\t}\n\t}*/\n}\n\ntemplate<typename T>\nT gcd(T q, T w) {\n\twhile (w) {\n\t\tq %= w;\n\t\tswap(q, w);\n\t}\n\treturn q;\n}\ntemplate<typename T>\nT lcm(T q, T w) {\n\treturn q / gcd(q, w) * w;\n}\n\ninline int nxt(){\n\tint x;\n\tcin >> x;\n\treturn x;\n}\n\n//#define int li\n\nint n;\nvector<int> dsu;\nvoid init() {\n\tdsu.resize(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tdsu[i] = i;\n\t}\n}\n\nint find_set(int v) {\n\tif (dsu[v] == v) {\n\t\treturn v;\n\t}\n\treturn dsu[v] = find_set(dsu[v]);\n}\n\nvoid merge(int q, int w) {\n\tq = find_set(q);\n\tw = find_set(w);\n\tdsu[q] = w;\n}\n\nvoid solve(bool read) {\n\tcin >> n;\n\tvector<int> a(n);\n\tvector<vector<int>> primes(n);\n\tmap<int, set<int>> poses;\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t\tint cur = a[i];\n\t\tfor (int p = 2; p * p <= cur; ++p) {\n\t\t\tif (cur % p == 0) {\n\t\t\t\tposes[p].insert(i);\n\t\t\t\tprimes[i].push_back(p);\n\t\t\t\twhile (cur % p == 0) {\n\t\t\t\t\tcur /= p;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (cur > 1) {\n\t\t\tposes[cur].insert(i);\n\t\t\tprimes[i].push_back(cur);\n\t\t}\n\t}\n\tvector<int> res;\n\tvector<char> used(n, false);\n\tfor (int i = 0; i < n; ++i) {\n\t\tinit();\n\t\tfor (auto& item : poses) {\n\t\t\tfor (auto it = item.second.begin(); it != item.second.end(); ++it) {\n\t\t\t\tauto nex = it;\n\t\t\t\t++nex;\n\t\t\t\tif (nex == item.second.end()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tmerge(*it, *nex);\n\t\t\t}\n\t\t}\n\n\t\tvector<vector<int>> comps(n);\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (!used[i]) {\n\t\t\t\tcomps[find_set(i)].push_back(i);\n\t\t\t}\n\t\t}\n\n\t\tint cur_take = -1;\n\t\tint cur_id = -1;\n\t\tfor (int i = 0; i < comps.size(); ++i) {\n\t\t\tsort(all(comps[i]), [&a](int q, int w) {\n\t\t\t\treturn a[q] < a[w];\n\t\t\t});\n\t\t\tint best = 2e9;\n\t\t\tint best_id = -1;\n\t\t\tfor (int cur : comps[i]) {\n\t\t\t\tint cand = a[cur];\n\t\t\t\tbool f = true;\n\t\t\t\tfor (int prev = (int)res.size() - 1, its = 0; prev >= 0 && its < 50; --prev, ++its) {\n\t\t\t\t\tif (gcd(res[prev], cand) > 1) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (cand > res[prev]) {\n\t\t\t\t\t\tf = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (f) {\n\t\t\t\t\tif (best > cand) {\n\t\t\t\t\t\tbest = cand;\n\t\t\t\t\t\tbest_id = cur;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!comps[i].empty() && best > cur_take) {\n\t\t\t\tcur_take = best;\n\t\t\t\tcur_id = best_id;\n\t\t\t}\n\t\t}\n\t\t\n\t\tassert(cur_take != -1);\n\t\tres.push_back(a[cur_id]);\n\t\tused[cur_id] = true;\n\t\tfor (int p : primes[cur_id]) {\n\t\t\tposes[p].erase(cur_id);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tcout << res[i] << \" \";\n\t}\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,int> pli;\nconst int inf=1e9;\nconst ll Inf=1e18;\nconst int N=2e3+10;\nconst int mod=0;\nint gi() {\n    int x=0,o=1;char ch=getchar();\n    while((ch<'0'||ch>'9')&&ch!='-') ch=getchar();\n    if(ch=='-') o=-1,ch=getchar();\n    while(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n    return x*o;\n}\ntemplate<typename T> bool chkmax(T &a,T b) { return a<b?a=b,1:0; };\ntemplate<typename T> bool chkmin(T &a,T b) { return a>b?a=b,1:0; };\nint add(int a,int b) { return a+b>=mod?a+b-mod:a+b; }\nint sub(int a,int b) { return a-b<0?a-b+mod:a-b; }\nvoid inc(int &a,int b) { a=(a+b>=mod?a+b-mod:a+b); }\nvoid dec(int &a,int b) { a=(a-b<0?a-b+mod:a-b); }\nint n,a[N],ans[N],du[N];\nbool G[N][N],vis[N];\nvector<int> E[N];\nvoid dfs(int u,int fa) {\n    vis[u]=1;\n    if(fa) E[fa].pb(u),du[u]++;\n    for(int v=1;v<=n;v++) if(G[u][v]&&!vis[v]) dfs(v,u);\n}\npriority_queue<pii> q;\nint main() {\n    cin>>n;\n    for(int i=1;i<=n;i++) a[i]=gi();\n    sort(a+1,a+n+1);\n    for(int i=1;i<=n;i++)\n        for(int j=i+1;j<=n;j++) if(__gcd(a[i],a[j])!=1) G[i][j]=G[j][i]=1;\n    for(int i=1;i<=n;i++) if(!vis[i]) dfs(i,0);\n    for(int i=1;i<=n;i++) if(!du[i]) q.push(mp(a[i],i));\n    int tot=0;\n    while(!q.empty()) {\n        pii u=q.top();q.pop();ans[++tot]=u.fi;\n        for(int v:E[u.se]) if(!--du[v]) q.push(mp(a[v],v));\n    }\n    for(int i=1;i<=tot;i++) printf(\"%d \",ans[i]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> \nusing namespace std;\n\n#define ll long long\n#define mp make_pair\n#define pb push_back\n\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#define rep(i, n) for (int i = 0; i < (int)(n); ++ i)\n\nconst int maxn = 2005;\nint n;\nint a[maxn];\nvector <int> g[maxn], ng[maxn];\nbool vis[maxn];\n\nvoid dfs(int u) {\n\tvis[u] = 1;\n\trep(i, g[u].size()) {\n\t\tint v = g[u][i];\n\t\tif (!vis[v]) dfs(v), ng[u].pb(v);\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\trep(i, n) scanf(\"%d\", &a[i]);\n\trep(i, n) rep(j, i) if (__gcd(a[i], a[j]) > 1) g[i].pb(j), g[j].pb(i);\n\tpriority_queue <pair <int, int> > pq;\n\trep(i, n) if (!vis[i]) dfs(i), pq.push(mp(a[i], i));\n\twhile (!pq.empty()) {\n\t\tint u = pq.top().second;\n\t\tpq.pop();\n\t\tprintf(\"%d \", a[u]);\n\t\trep(i, ng[u].size()) {\n\t\t\tint v = ng[u][i];\n\t\t\tpq.push(mp(a[v], v));\n\t\t}\n\t}\n\tputs(\"\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma warning(disable:4996)\n\n#include <stdio.h>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n#include <cmath>\n#include <map>\n#include <set>\n#include <queue>\n#include <complex>\n#include <iterator>\n#include <random>\n#include <time.h>\n#include <tuple>\n#include <functional>\n#include <list>\n#include <limits.h>\n#define mp make_pair\n#define ni(x) scanf(\"%d\", &(x))\n#define nii(x,y) scanf(\"%d%d\",&(x),&(y))\n#define mul(x,y) ((ll)(x)*(y)%mod)\n#define mtp make_tuple\n#define F(i,n) for(int i = 0; i < (n); i++)\n#define FF(i,n) for(int i = 1; i <= (n); i++)\n#define FE(i,n) for(int i = 0; i <= (n); i++)\n\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconst int mod = 1000000007;\nconst int inf = 2012345678;\nconst ll infl = 9012345678901234567;\nconst double pi = 3.1415926535897932384626433832795;\n//----------------------------------------------------------------------------//\n\nconst int N = 2000;\nint a[N];\nvector<int> adj[N];\nint chk[N];\n\nint gcd(int a, int b) {\n\tif (!b)return a;\n\telse return gcd(b, a%b);\n}\n\nvector<int> merge(const vector<int>& a, const vector<int>& b) {\n\tint n = a.size();\n\tint m = b.size();\n\tint i = 0, j = 0;\n\tvector<int> V;\n\twhile (i < n&&j < m) {\n\t\tif (a[i] < b[j])V.push_back(b[j++]);\n\t\telse V.push_back(a[i++]);\n\t}\n\tfor (; i < n; i++)V.push_back(a[i]);\n\tfor (; j < m; j++)V.push_back(b[j]);\n\treturn V;\n}\n\nvector<int> dfs(int u) {\n\tchk[u] = 1;\n\tvector<int> v;\n\tfor (auto &x : adj[u]) {\n\t\tif (chk[x])continue;\n\t\tv = merge(v, dfs(x));\n\t}\n\tint sz = v.size();\n\tv.push_back(0);\n\tfor (int i = sz; i; i--)v[i] = v[i - 1];\n\tv[0] = a[u];\n\treturn v;\n}\n\nint main() {\n#ifndef __GNUG__\n\tfreopen(\"input.txt\", \"r\", stdin);\n#endif\n\tint n; ni(n);\n\tF(i, n)ni(a[i]);\n\tsort(a, a + n);\n\tF(i, n) {\n\t\tF(j, n) {\n\t\t\tif (i == j)continue;\n\t\t\tif (gcd(a[i], a[j]) > 1) {\n\t\t\t\tadj[i].push_back(j);\n\t\t\t}\n\t\t}\n\t}\n\tvector<int> V;\n\tF(i, n) {\n\t\tif (chk[i]) continue;\n\t\tV = merge(V, dfs(i));\n\t}\n\tfor (auto &x : V)printf(\"%d \", x);\n\tputs(\"\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\nusing namespace std;\ntypedef pair<int,int>pii;\nint n,cnt;\nint a[2010],w[2010],rd[2010];\npii e[4000010];\nbool vis[2010];\nvector<int>G[2010];\ninline int gcd(int x,int y){\n    if(y==0) return x;\n    return gcd(y,x%y);\n}\nvoid add(int u,int v){\n    e[++cnt]=mp(v,w[u]);\n    w[u]=cnt;\n}\nvoid dfs(int x){\n    vis[x]=1;\n    for(auto to:G[x])if(!vis[to]){\n        add(x,to);\n        rd[to]++;\n        dfs(to);\n    }\n}\n//priority_queue<pii,vector<pii>,greater<pii> >pq;\npriority_queue<pii>pq;\nint main(){\n    cin>>n;\n    for(int i=1;i<=n;i++)cin>>a[i];\n    sort(a+1,a+n+1);\n    for(int i=1;i<n;i++)\n        for(int j=i+1;j<=n;j++)\n            if(gcd(a[i],a[j])>1){\n                G[i].pb(j);\n                G[j].pb(i);\n            }\n    for(int i=1;i<=n;i++)if(!vis[i])dfs(i);\n    for(int i=1;i<=n;i++)if(!rd[i])pq.push(mp(a[i],i));\n    while(!pq.empty()){\n        pii curr=pq.top();\n        pq.pop();\n        cout<<curr.first<<' ';\n        for(int i=w[curr.second];i;i=e[i].second){\n            int v=e[i].first;\n            rd[v]--;\n            if(!rd[v])pq.push(mp(a[v],v));\n        }\n    }\n    puts(\"\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n                                                                                                     \n                                             `-:://:::-                                             \n                                           `//:-------:/:`                                          \n                                          .+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .o:--...```..---+/`                                        \n                                       `/y+o/---....---:+o.                                         \n                                   `...````-os+/:---:/+o/--.`                                       \n              `-/+++++/:.      `...`       :h+d+oooo+/+-`   ...                                     \n            `/++//:::://++-`....`         -.`//````````:`     `..`                                  \n           `o+/::------://o/`           `-` -.          -`       `..`                               \n `---.-o/:./o/::-..``..-ЗАПУСКАЕМ      ..  ..            -`        `...       ``..``                \n  `....o+:-++/:--.```..-://s.        `-`  .-              -`          `-o: .-//::::/:-`             \n          `:s+/:--....-::/+s-`      .-   `-                -`           -///:--------:/:`           \n           ./s+//:::::://oo-``..НЕЙРОННУЮ: СЕТЬ:::::::-`РАБОТЯГИ        `+:--........--:/`          \n            .:ooo+++++osso-`    `.:-...`/` ./::-------:/:`   -`         :+--..``````.--:+:...-+:-`  \n             `.-/+++++/+-.-`    -.   ``:so:/:--.......--:+`  `-```````o+/+--..`````..--:o/-..:s+:.  \n                 ```````:``.. `-`     -` `+:--..`````..--/+-.../.`````..-o:--.......---/o.    `     \n                        `:  `:-      -.  .o:--..`` ``..--:o`   `-`      `:o+:--------:+o-`          \n                         `-`-...    ..   .o/--...```..--:+/`    `-`     `oy/so/////++o/.`           \n                          -/`  `-` `- ``+s/o/:---...---:++.      `-`   .-../d://///:-.`             \n                `.---..``-..-    .-/..`````-oo+/:::::/+o+-        `-``-`  `-.  ````                 \n             `:++++/+++++-  ..``.-/:`      /y-:/++o++/:.`..`       ./.   `-                         \n            -++/::::::://+/..:-``:` ..   `-.`  ```.```    `..`   `..`-` `-                          \n       ``  -o//:--....-::/++` -.-`   `-`.-`                 `..`..`  `-.-                           \n  -----ss+:++/:--.```..-://s.  /.     `::                    `-:.     ./`                           \n  `````/:..+o/::-..``.--:/+s. ..-`   `-``-`                 ..` `-`  `-`-`                          \n          `-s+/::-----::/+oo---``-` ..    .:-    ```      .-`     .-.-  `-`                         \n           `:oo+//::://+os/..:`..-/:`      :y.-:::::::.`.-`        ./-`  `-`                        \n            `./+oooooooo+/.`-    .-:...`.. .//:-------://`        `- `..` `:.                       \n              ``.-::::-.``-/`  `-` `-  `oo:+:--.......--:/`      `-    `.:--h.``..```               \n                          -.-`.-    .-   `+:--..`````..--//`    `-       /s-//::::::::.             \n                         -` `/-      ..  .o:--..`` ``..--:o.```.-        `//:--------://`           \n                        -` .-`.-`     -.`-o/--...```..--:+/.``-:....``:-.+:--....`...--:+`          \n                       ..`-.   `-.   ``:os:o/:---...---:++.  `-     ``///+:-..``````.--:+-````-.`   \n              `.:///////.-`      .:-..` -``-+o+/:::::/+o/.  `-         `:+:-..`````..--:o/:--/ys+-  \n            `-++///////+o/. ``....`-.    :` `.:++++++/:.`  .-           -o/---......---/o.   `.`    \n           `++//:-----::/+o:..`     .-`   :    ```````    .-           `+so+:--------:++-`          \n  `````:-``:o/::-..`..--:/+o`         -.  `-             .-          `../../+o+////+o+:.`           \n  -----syo/o+/:--.```..-://s.          .-` `-           .-        `...     ``-:////:-``             \n       .` `/s//:--....-::/+s.            -. `-`        .-       `..`                                \n           .+o+/:::--:://+s/-..`          .::+y  ```  .-     `..`                                   \n            ./oo++////+oso-`   `....       :y-+:::::::/`   ...                                      \n             `.:+oooooo/-`         `....-. .//:-------:/:-.`                                        \n                ``...``                 /+:+:--.......--:+`                                         \n                                         `+:--..`````..--//`                                        \n                                         .o:--..`` ``..--:o`                                        \n                                         .+/--...```..--:+/`                                        \n                                         `-o/:---...---:++.                                         \n                                          `-+o+/:---:/+o/.                                          \n                                            `.:+oooo+/-.`                                           \n                                               ``````                                               \n*/\n\n#ifdef aimbot\n#pragma comment(linker, \"/stack:200000000\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC optimize(\"unroll-loops\")\n#endif\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <set>\n#include <queue>\n#include <ostream>\n#include <istream>\n#include <typeinfo>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <limits>\n#include <fstream>\n#include <array>\n#include <list>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <cstring>\n#include <chrono>\n\n#define random escape__from__random__aetuhoetnuhshe\n#define mt make_tuple\n#define x first\n#define y second\n#define pb push_back\n#define ppb pop_back\n#define mp make_pair\n#define umap unordered_map\n#define uset unordered_set\n#define elif else if\n#define len(v) ((int)v.size())\n#define f(i, n) for (int i = 0; i < (n); i++)\n#define rof(i, n) for (int i = ((n) - 1); i >= 0; i--)\n#define apply(v, act) for (auto &x : v) { act; }\n#define log(args...) {string s = #args;deque<string> deq;\\\nstring buf = \"\";int bal = 0;for (char c : s) {\\\nif (c == '(' || c == '[' || c == '{') {bal++;\\\n} else if (c == ')' || c == ']' || c == '}') {\\\nbal--;} else {if (bal == 0) {if (c == ',') {\\\ndeq.pb(buf);buf = \"\";} else {if (c != ' ') {\\\nbuf += c;}}}}}if (!buf.empty()) {deq.pb(buf);}\\\nsmart_io::precall_print();smart_io::_print(deq, args);}\n\ninline int min(const int &x, const int &y) { return (((y-x)>>(32-1))&(x^y))^x; }\ninline int max(const int &x, const int &y) { return (((y-x)>>(32-1))&(x^y))^y; }\ninline long long min(const long long &x, const long long &y) { return (((y-x)>>(64-1))&(x^y))^x; }\ninline long long max(const long long &x, const long long &y) { return (((y-x)>>(64-1))&(x^y))^y; }\n\n#define print    \\\nsmart_io::precall_print(); \\\ncout,\n\n#define scan cin,\n\n#ifdef fast_allocator\nconst int MAXMEM = 200 * 1000 * 1024;\nchar _memory[MAXMEM];\nsize_t _ptr = 0;\nvoid* operator new(size_t _x) { _ptr += _x; assert(_ptr < MAXMEM); return _memory + _ptr - _x; }\nvoid operator delete (void*) noexcept {}\n#endif\n\nusing namespace std;\n\nchar string_in_buffer[(int)260];\n\n\nvoid fast_scan(int &x) { scanf(\"%d\", &x); }\nvoid fast_scan(long long &x) { scanf(\"%lld\", &x); }\nvoid fast_scan(unsigned long long &x) { scanf(\"%llu\", &x); }\nvoid fast_scan(double &x) { scanf(\"%lf\", &x); }\nvoid fast_scan(long double &x) { scanf(\"%Lf\", &x); }\nvoid fast_scan(char &x) {\n\tscanf(\"%c\", &x);\n\tif (x == '\\n') {\n\t\tfast_scan(x);\n\t}\n}\nvoid fast_scan(string &x) {\n\tscanf(\"%s\", string_in_buffer);\n\tx = string(string_in_buffer);\n}\n\ntemplate<class TFirst, class TSecond>\nvoid fast_scan(pair<TFirst, TSecond> &p) {\n\tfast_scan(p.first);\n\tfast_scan(p.second);\n}\n\ntemplate <class T>\nvoid fast_scan(vector<T> &v) {\n\tfor (auto &x : v) fast_scan(x);\n}\n\nvoid fast_print(const int &x) { printf(\"%d\", x); }\nvoid fast_print(const unsigned int &x) { printf(\"%u\", x); }\nvoid fast_print(const long long &x) { printf(\"%lld\", x); }\nvoid fast_print(const unsigned long long &x) { printf(\"%llu\", x); }\nvoid fast_print(const char &x) { printf(\"%c\", x); };\n// void fast_print(__int128 x) {\n// \tif (x == 0) { fast_print('0'); return; }\n// \tif (x < 0) {\n// \t\tfast_print('-');\n// \t\tx = -x;\n// \t}\n// \t__int128 p = 1;\n// \twhile (x / (p * 10)) p *= 10;\n// \twhile (p) {\n// \t\t__int128 symb = x / p;\n// \t\tfast_print((int)symb);\n// \t\tx -= p * symb;\n// \t\tp /= 10;\n// \t}\n// };\nvoid fast_print(const double &x) { printf(\"%.15lf\", x); }\nvoid fast_print(const long double &x) { printf(\"%.15Lf\", x); }\nvoid fast_print(const string &x) { printf(\"%s\", x.c_str());}\nvoid fast_print(const char v[]) { fast_print((string)v); }\n\ntemplate<class TFirst, class TSecond>\nvoid fast_print(const pair<TFirst, TSecond> &p) {\n\tfast_print(p.first);\n\tfast_print(' ');\n\tfast_print(p.second);\n}\n\ntemplate <class T>\nvoid fast_print(const vector<T> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print(' ');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const vector<vector<T>> &v) {\n\tif (v.empty()) return;\n\tfast_print(v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tfast_print('\\n');\n\t\tfast_print(v[i]);\n\t}\n}\n\ntemplate <class T>\nvoid fast_print(const T &v) {\n\tfor (const auto &x : v) {\n\t\tfast_print(x);\n\t\tfast_print(' ');\n\t}\n}\n\n\nusing namespace std;\n\n\nnamespace smart_io {\n\tstring print_start = \"\";\n\tstring sep = \" \";\n\tbool first_print = false;\n\t\n\tvoid precall_print() {\n\t\tfast_print(print_start);\n\t\tprint_start = \"\\n\";\n\t\tfirst_print = true;\n\t}\n\t\n\tvoid _print(deque<string>) {}\n\ttemplate<class T, class... Args>\n\tvoid _print(deque<string> names, T elem, Args... args) {\n\t\tif (!first_print) {\n\t\t\tfast_print(\"\\n\");\n\t\t} else {\n\t\t\tfirst_print = false;\n\t\t}\n\t\tfast_print(names.front());\n\t\tfast_print(\" = \");\n\t\tfast_print(elem);\n\t\tnames.pop_front();\n\t\t_print(names, args...);\n\t}\n} //namespace smart_io\n\n\ntemplate <class T>\nostream &operator,(ostream &os, const T &object) {\n\tif (!smart_io::first_print) {\n\t\tfast_print(smart_io::sep);\n\t} else {\n\t\tsmart_io::first_print = false;\n\t}\n\tfast_print(object);\n\treturn os;\n}\n\ntemplate <class T>\nistream &operator,(istream &is, T &object) {\n\tfast_scan(object);\n\treturn is;\n}\n\nnamespace random {\n\tusing namespace std::chrono;\n\tmt19937 rng(duration_cast< milliseconds >(\n\t\t\t\t\t\t\t\t\t\t\t  system_clock::now().time_since_epoch()\n\t\t\t\t\t\t\t\t\t\t\t  ).count());\n\tuniform_real_distribution<> prob_dist(0.0, 1.0);\n};\n\nnamespace typedefs {\n\ttypedef long long ll;\n\ttypedef unsigned long long ull;\n\ttypedef pair<int, int> pii;\n\ttypedef long double ld;\n}\n\nnamespace numbers_operation {\n\ttemplate<class T>\n\tinline T floor_mod(T a, const T &b) {\n\t\ta %= b;\t\n\t\tif (a < 0) a += b;\n\t\treturn a;\n\t}\n}\n\nusing namespace numbers_operation;\nusing namespace typedefs;\nusing namespace random;\n\nint n;\nvector<int> v;\n\nint gcd(int a, int b) {\n\treturn __gcd((unsigned int)a, (unsigned int)b);\n}\n\nbool can_add(vector<int> p, int x) {\n\tvector<int> q = p;\n\tp.pb(x);\n\tfor (int i = len(p) - 1; i > 0; i--) {\n\t\tif (gcd(p[i], p[i - 1]) == 1) swap(p[i], p[i - 1]);\n\t\telse break;\n\t\tif (q < p) return false;\n\t}\n\treturn true;\n}\n\nsigned main(signed argc, char *argv[]) {\n\tscan n;\n\tmap<int, int> cnt;\n\tfor (int i = 0; i < n; i++) {\n\t\tint x;\n\t\tscan x;\n\t\tcnt[x]++;\n\t}\n\tvector<int> remain;\n\tfor (auto p : cnt) {\n\t\tif (p.x > 1) {\n\t\t\tremain.pb(p.x);\n\t\t}\n\t}\n\tsort(remain.begin(), remain.end());\n\tvector<int> rez;\n\twhile (!remain.empty()) {\n\t\tvector<bool> used(len(remain), false);\n\t\tint next = -1;\n\t\tfor (int x : remain) {\n\t\t\tif (!can_add(rez, x)) continue;\n\t\t\tbool fail = false;\n\t\t\tdeque<int> deq{x};\n\t\t\twhile (!deq.empty()) {\n\t\t\t\tint cur = deq[0];\n\t\t\t\tdeq.pop_front();\n\t\t\t\tfor (int i = 0; i < len(used); i++) {\n\t\t\t\t\tif (remain[i] >= x && (gcd(remain[i], cur) > 1 || remain[i] == x) && !used[i]) {\n\t\t\t\t\t\tused[i] = true;\n\t\t\t\t\t\tdeq.pb(remain[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < len(used); i++)\n\t\t\t\tif (remain[i] >= x && !used[i]) {\n\t\t\t\t\tfail = true;\n\t\t\t\t}\n\t\t\tif (!fail) {\n\t\t\t\tnext = x;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tassert(next != -1);\n\t\tremain.erase(find(remain.begin(), remain.end(), next));\n\t\trez.pb(next);\n\t}\n\tvector<int> final;\n\trez.pb(1);\n\tfor (int x : rez) {\n\t\tf(k, cnt[x]) {\n\t\t\tfinal.pb(x);\n\t\t}\n\t}\n\tprint final;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nconst int maxn = 2030, oo = 123456789, maxm = 16010;\n \nint n, m, T, ans, mn, a[maxn], foo[maxn], lst[maxm], tag[maxn];\nbool vis[maxn], f[maxn], G[maxn][maxn], F[maxn];\nstd::vector<int> g[maxn], has[maxn], rhas[maxm], all;\nstd::pair<int, int> v[2];\n \nvoid GEN() {\n\tint mx = 0;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif(!foo[i]) {\n\t\t\tif(a[i] == 1) {\n\t\t\t\tF[i] = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tF[i] = 0;\n\t\t\tfor (int j: has[i]) {\n\t\t\t\tif(lst[j] >= mx) {\n\t\t\t\t\tF[i] = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t(foo[i] > mx) && (mx = foo[i]);\n\t\t}\n\t}\n\treturn;\n}\n \ninline void dfs(const int &u) {\n\ttag[u] = T;\n\tvis[u] = 1;\n\t(F[u] && a[u] < mn) && (mn = a[u]);\n\tfor (register int &v: g[u]) {\n\t\tif(!vis[v] && !f[v]) {\n\t\t\tdfs(v);\n\t\t}\n\t}\n\treturn;\n}\n \nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tscanf(\"%d\", a + i);\n\t\tint t = a[i];\n\t\tfor (int x = 2; x * x <= t; ++x) {\n\t\t\tif(t % x == 0) {\n\t\t\t\tall.push_back(x);\n\t\t\t\twhile(t % x == 0) {\n\t\t\t\t\tt /= x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(t > 1) {\n\t\t\tall.push_back(t);\n\t\t}\n\t}\n\tstd::sort(a + 1, a + n + 1);\n\tstd::sort(all.begin(), all.end());\n\tall.resize(std::unique(all.begin(), all.end()) - all.begin());\n\tm = (int)(all.size());\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tif(a[i] % all[j] == 0) {\n\t\t\t\thas[i].push_back(j);\n\t\t\t\trhas[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int j = 0, sz; j < m; ++j) {\n\t\tsz = (int)(rhas[j].size());\n\t\tfor (register int i = 0; i < sz; ++i) {\n\t\t\tfor (register int k = 0; k < i; ++k) {\n\t\t\t\tint &u = rhas[j][i], &v = rhas[j][k];\n\t\t\t\tif(!G[u][v]) {\n\t\t\t\t\tg[u].push_back(v);\n\t\t\t\t\tg[v].push_back(u);\n\t\t\t\t\tG[u][v] = G[v][u] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tGEN();\n\t\tmemset(vis + 1, 0, sizeof(vis[0]) * n);\n\t\tv[0] = v[1] = std::make_pair(oo, 0);\n\t\tfor (register int u = 1; u <= n; ++u) {\n\t\t\tif(F[u] && !vis[u] && !f[u]) {\n\t\t\t\t++T;\n\t\t\t\tmn = oo;\n\t\t\t\tdfs(u);\n\t\t\t\tif(mn < v[0].first) {\n\t\t\t\t\tv[1] = v[0];\n\t\t\t\t\tv[0] = std::make_pair(mn, T);\n\t\t\t\t}\n\t\t\t\telse if(mn < v[1].first) {\n\t\t\t\t\tv[1] = std::make_pair(mn, T);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\tans = 0;\n\t\tint sz = v[1].first == oo ? 0 : 1;\n\t\tfor (register int u = 1; u <= n; ++u) {\n\t\t\tif(F[u] && !f[u]) {\n\t\t\t\tint i = sz;\n\t\t\t\tif(v[i].second == tag[u]) {\n\t\t\t\t\t--i;\n\t\t\t\t}\n\t\t\t\tif(v[i].first <= a[u] || i < 0) {\n\t\t\t\t\tans = u;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\tassert(ans);\n\t\tf[ans] = 1;\n\t\tfoo[ans] = i;\n\t\tprintf(\"%d \", a[ans]);\n\t\tfor (int j: has[ans]) {\n\t\t\tlst[j] = i;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Zhupengfei 2018\n// This program / source file is in public domain.\n\n// Solution for problem: Rearranging\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n// Main segment\n\nconst int MAXN = 2010;\nconst int MAXV = MAXN * MAXN;\n\nint a[MAXN] = {};\nvector<int> g[MAXV] = {};\n\nunordered_map<int, int> primeMp = {};\nint m, N;\n\nbool inAns[MAXN] = {};\n\nint getId(int x) {\n    if (primeMp.count(x)) {\n        return primeMp[x];\n    }\n    primeMp[x] = ++m;\n    return m;\n}\n\nint color[MAXV] = {};\nint C = 0;\n\nvoid dfs(int u) {\n    color[u] = C;\n    for (int v : g[u]) {\n        if (color[v] != -1)\n            continue;\n        if (v < N && inAns[v])\n            continue;\n        dfs(v);\n    }\n}\n\nvoid recolor() {\n    C = 0;\n    memset(color, -1, sizeof(color));\n    for (int i = 1; i <= N; i++) {\n        if (!inAns[i] && color[i] == -1) {\n            dfs(i);\n            C++;\n        }\n    }\n}\n\nbool f[MAXN][MAXN] = {};\nint last[MAXN] = {};\nint suffmin[MAXN] = {};\nint ans[MAXN] = {};\nint best[MAXV] = {};\nint cnt = 0;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    cin >> N;\n    m = N;\n    for (int i = 1; i <= N; i++) {\n        cin >> a[i];\n        int x = a[i];\n        for (int y = 2; y * y <= x; y++) {\n            if (x % y != 0)\n                continue;\n            int id = getId(y);\n            g[i].push_back(id);\n            g[id].push_back(i);\n            while (x % y == 0)\n                x /= y;\n        }\n        if (x != 1) {\n            int id = getId(x);\n            g[i].push_back(id);\n            g[id].push_back(i);\n        }\n    }\n\n    for (int i = 1; i <= N; i++) {\n        for (int j = 1; j <= N; j++) {\n            f[i][j] = (__gcd(a[i], a[j]) != 1);\n        }\n    }\n\n    memset(last, -1, sizeof(last));\n    memset(suffmin, 0x7f, sizeof(suffmin));\n\n    while (cnt < N) {\n        recolor();\n        memset(best, -1, sizeof(best));\n\n        for (int i = 1; i <= N; i++) {\n            if (inAns[i] || suffmin[last[i] + 1] < a[i])\n                continue;\n            if (best[color[i]] == -1 || a[best[color[i]]] > a[i])\n                best[color[i]] = i;\n        }\n\n        int mi = -1;\n        for (int i = 0; i < C; i++) {\n            if (best[i] == -1)\n                continue;\n            if (mi == -1 || a[mi] < a[best[i]])\n                mi = best[i];\n        }\n\n        assert(mi != -1);\n        inAns[mi] = 1;\n        ans[++cnt] = mi;\n\n        for (int i = 1; i <= cnt; i++) {\n            suffmin[i] = min(suffmin[i], a[mi]);\n        }\n        for (int i = 1; i <= N; i++) {\n            if (f[i][mi]) {\n                last[i] = cnt;\n            }\n        }\n    }\n    for (int i = 1; i <= N; i++) {\n        cout << ans[i] << (i < N ? \" \" : \"\\n\");\n    }\n\n    cout << flush;\n\n#ifdef LOCAL\n    system(\"pause\");\n#endif\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <cassert>\nusing namespace std;\n\n#define iter(i, n) for (int i = 1; i <= n; ++i)\n\n\n#define NR 2010\n\ntypedef pair<int, int> pii;\n#define se second\n\nint n, a[NR], ch, in[NR];\nbool g[NR][NR], vis[NR], inq[NR];\n\npriority_queue<pii, vector<pii>, greater<pii> > Q;\npriority_queue<pii> q;\n\nint gcd(int a, int b) { return !b ? a : gcd(b, a % b); }\n\n\nvoid dfs(int x) {\n\tvis[x] = true;\n\titer(v, n) if (g[x][v]) assert(g[v][x]), g[v][x] = false;\n\titer(v, n) if (g[x][v] && !vis[v]) dfs(v);\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\titer(i, n) scanf(\"%d\", &a[i]);\n\tsort(a + 1, a + n + 1);\n\titer(i, n) iter(j, i - 1) if (gcd(a[i], a[j]) != 1) g[i][j] = g[j][i] = true;\n\n\titer(i, n) if (!vis[i]) dfs(i);\n\t/*iter(i, n) { \n\t\titer(j, n) printf(\"%d \", g[i][j]);\n\t\tputs(\"\");\n\t}*/\n\n\titer(x, n) iter(v, n) if (g[x][v]) ++in[v];\n\titer(x, n) if (!in[x]) q.push(pii(a[x], x));\n\n\twhile (!q.empty()) {\n\t\tint x = q.top().se; q.pop();\n\t\tprintf(\"%d \", a[x]);\n\t\titer(v, n) if (g[x][v]) {\n\t\t\tif (!--in[v]) q.push(pii(a[v], v));\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\n\nlong long int N, M, K, H, W, L, R;\n\nint gcd(int a, int b) {\n\tif (a < b)swap(a, b);\n\twhile (b) {\n\t\ta %= b;\n\t\tswap(a, b);\n\t}\n\treturn a;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\tvector<int>v(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> v[i];\n\t}\n\tsort(v.begin(), v.end());\n\treverse(v.begin(), v.end());\n\tvector<vector<int>>edge(N, vector<int>(N));\n\tvector<int>dir(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = i + 1; j < N; j++) {\n\t\t\tif (gcd(v[i], v[j])!=1) {\n\t\t\t\tedge[i][j] = 1;\n\t\t\t\tedge[j][i] = 1;\n\t\t\t\tdir[i]++;\n\t\t\t\tdir[j]++;\n\t\t\t}\n\t\t}\n\t}\n\tvector<int>ans;\n\tvector<int>box;\n\tvector<int>used(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tif (!dir[i]) {\n\t\t\tbox.push_back(v[i]);\n\t\t\tused[i] = 1;\n\t\t}\n\t}\n\tpriority_queue<int>Q;\n\tfor (int i = N - 1; i >= 0; i--) {\n\t\tif (!used[i]) {\n\t\t\tQ.push(i);\n\t\t\tbreak;\n\t\t}\n\t}\n\twhile (!Q.empty()) {\n\t\tint cn = Q.top();\n\t\tQ.pop();\n\t\tans.push_back(v[cn]);\n\t\tdir[cn] = 0;\n\t\tused[cn] = 1;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (edge[cn][i]) {\n\t\t\t\tedge[cn][i] = 0;\n\t\t\t\tedge[i][cn] = 0;\n\t\t\t\tdir[i]--;\n\t\t\t\tif (dir[i]) {\n\t\t\t\t\tQ.push(i);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tans.push_back(v[i]);\n\t\t\t\t\tused[i] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint aindex = 0;\n\tint bindex = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tif (i)cout << \" \";\n\t\tif (ans.size() == aindex) {\n\t\t\tcout << box[bindex];\n\t\t\tbindex++;\n\t\t}\n\t\telse if (box.size() == bindex) {\n\t\t\tcout << ans[aindex];\n\t\t\taindex++;\n\t\t}\n\t\telse if (box[bindex] < ans[aindex]) {\n\t\t\tcout << ans[aindex];\n\t\t\taindex++;\n\t\t}\n\t\telse {\n\t\t\tcout << box[bindex];\n\t\t\tbindex++;\n\t\t}\n\t}\n\tcout << endl;\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int jt=998244353;\n#define loop(i,n) for(int i=0;i<(n);i++)\n#define pool(i,n) for(int i=(n)-1;i>=0;i--)\n#define cont(i,n) for(int i=1;i<=(n);i++)\n#define tnoc(i,n) for(int i=(n);i>=1;i--)\n#define circ(i,a,b) for(int i=(a);i<=(b);i++)\n#define cric(i,a,b) for(int i=(b);i>=(a);i--)\n#define sub(i,a) for(int i=a;i;i=((i-1)&(a)))\n#define subs(i,a) for(int i=a;i>=0;i=(!i?-1:((i-1)&(a))))\n#define subt(i,a) for(int i=((a-1)&a);i;i=((i-1)&(a)))\n#define subst(i,a) for(int i=((a-1)&a);i>=0;i=(!i?-1:((i-1)&(a))))\n#define range(i,a,b,c) for(int i=(a);((c)>0?i<=(b):i>=(b));i+=(c))\n#define foreach(it,v) for(__typeof((v).begin()) it=(v).begin(),_e_D_=(v).end();it!=_e_D_;it++)\n#define parse(i,s) for(int i=0;s[i];i++)\n#define ln '\\n'\n#define all(a) a.begin(),a.end()\n#define OVER(s) return puts(s),0;\n#define FILL(a,x) memset(a,x,sizeof(a))\n#define FILL0(a) memset(a,0,sizeof(a))\n#define FILL1(a) memset(a,-1,sizeof(a))\n#define FILLBIG(a) memset(a,0x3f,sizeof(a))\n#define COPY(frm,to) memcpy(to,frm,sizeof(frm))\n#define Mask(a) (1ll<<(a))\n#define Maskx(a,x) ((a)<<(x))\n#define Full(a) ((1ll<<(a))-1)\n#define Bit(a,x) (((a)>>(x))&1)\n#define SZ(a) ((int)((a).size()))\n#define filei(a) freopen(a,\"r\",stdin);\n#define fileo(a) freopen(a,\"w\",stdout);\n#define fileio(a) freopen(a\".in\",\"r\",stdin);freopen(a\".out\",\"w\",stdout)\n#define Floyd(a,n) cont(k,n)cont(i,n)cont(j,n)chmin(a[i][j],a[i][k]+a[k][j])\n#define Floyd0(a,n) loop(k,n)loop(i,n)loop(j,n)chmin(a[i][j],a[i][k]+a[k][j])\n#define Floydlr(a,l,r) circ(k,l,r)circ(i,l,r)circ(j,l,r)chmin(a[i][j],a[i][k]+a[k][j])\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define y0 y0O0OO00OO0OO0OO0OOO00OO0OO0O0O000OO0\n#define y1 y1II11II11III11I1III11II111IIII1II1I1\n#define ws WSrAkIoi2333wSraKIoIWSraKiOi\n#define left left_jTjTJtJtIoiiOiioIAuaU66666jtIOIau\n#define hash whYusEthiSnamE_caNyoUusEothERnaMesliKeHSH\n#define pub push_back\n#define pob pop_back\n#define puf push_front\n#define pof pop_front\n#define mak make_pair\n#define emb emplace_back\n#define emf emplace_front\n#define emp emplace\n#define popcnt __builtin_popcount\n#define Popcnt __builtin_popcountll\ntemplate<typename _T>\nusing pair2=pair<_T,_T>;\ntemplate<typename _T>\nusing pair3=pair<pair<_T,_T>,_T>;\ntemplate<typename _T>\nusing pair4=pair<pair<_T,_T>,pair<_T,_T> >;\n#define mak3(a,b,c) make_pair(make_pair(a,b),c)\n#define mak4(a,b,c,d) make_pair(make_pair(a,b),make_pair(c,d))\ntemplate<typename _T>\nusing priq=priority_queue<_T>;\ntemplate<typename _T>\nusing qrip=priority_queue<_T,vector<_T>,greater<_T> >;\n#define ST first\n#define ND second\n#define FST first.first\n#define SND first.second\n#define RD second\n#define SRD second.first\n#define FTH second.second\n#ifndef JTAKIOI\n#define cerr if(0)cout\n#define tctest(clas,meth,...)\n#else\n#define tctest(clas,meth,...) int main(){fio<<(new clas)->meth(__VA_ARGS__)<<ln;}\n#endif\ntypedef long long ll;\ntypedef long double lf;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef istringstream iss;\ntypedef stringstream sst;\nconst lf pi=acosl(-1);\nconst int Inf=0x3f3f3f3f;\nconst ll INF=0x3f3f3f3f3f3f3f3fll;\nconst lf inF=11451419198101145141919810.1145141919810;\nconst int Dx[]={1,0,-1,0,1,1,-1,-1},Dy[]={0,1,0,-1,1,-1,1,-1};\n#ifdef JTAKIOI\nmt19937_64 Rand;void inline Srand(int x){Rand.seed(x);}\n#else\nvoid inline Srand(int x){srand(x);}\null inline Rand(){return ((rand()*32768ull+rand())*32768ull+rand())*32768ull+rand();}\n#endif\nll inline rand(ll a,ll b){return Rand()%(b-a+1)+a;}\ntemplate<typename _T>\ninline _T chmin(_T &a,_T b){return a>b?(a=b):a;}\ntemplate<typename _T>\ninline _T chmax(_T &a,_T b){return a<b?(a=b):a;}\ntemplate<typename _T,int len>\nstruct BIT{\n\t_T dt[len];\n\tinline void add(int a,_T x){while(a<len){dt[a]+=x;a+=a&-a;}}\n\tinline void add(int l,int r,_T x){add(l,x);add(r+1,-x);}\n\tinline _T get(int a){_T ans=0;while(a){ans+=dt[a];a-=a&-a;}return ans;}\n\tinline _T get(int l,int r){return get(r)-get(l-1);}\n};\ntemplate<typename _T,int len>\nstruct segbit{\n\t_T dt[2][len];\n\tinline void add(int a,_T x){int b=a;while(a<len){dt[0][a]+=x;dt[1][a]+=x*b;a+=a&-a;}}\n\tinline void add(int l,int r,_T x){add(l,x);add(r+1,-x);}\n\tinline _T sum(int a){_T ans=0;int b=a;while(a){ans+=(b+1)*dt[0][a]-dt[1][a];a-=a&-a;}return ans;}\n\tinline _T sum(int l,int r){return sum(r)-sum(l-1);}\n};\nconst lf eps=1e-10;\nstruct point{\n\tlf x,y;\n\tlf ang;\n\tpoint(){}\n\tpoint(lf x,lf y):x(x),y(y){ang=atan2l(y,x);}\n\tinline point operator=(const point &pt){x=pt.x;y=pt.y;return *this;}\n\tinline point operator-()const{return point(-x,-y);}\n\tinline point operator+(const point &pt)const{return point(x+pt.x,y+pt.y);}\n\tinline point operator-(const point &pt)const{return point(x-pt.x,y-pt.y);}\n\tinline point operator*(const lf &a)const{return point(x*a,y*a);}\n\tinline point operator/(const lf &a)const{return point(x/a,y/a);}\n\tinline point operator^(const lf &ang)const{return point(x*cosl(ang)-y*sinl(ang),x*sinl(ang)+y*cosl(ang));}\n\tinline point operator+=(const point &pt){return *this=point(x+pt.x,y+pt.y);}\n\tinline point operator-=(const point &pt){return *this=point(x-pt.x,y-pt.y);}\n\tinline point operator*=(const lf &a){return *this=point(x*a,y*a);}\n\tinline point operator/=(const lf &a){return *this=point(x/a,y/a);}\n\tinline point operator^=(const lf &ang){return *this=point(x*cosl(ang)-y*sinl(ang),x*sinl(ang)+y*cosl(ang));}\n\tinline lf operator*(const point &pt)const{return x*pt.x+y*pt.y;}//dot\n\tinline lf operator%(const point &pt)const{return x*pt.y-y*pt.x;}//det\n\tinline lf length()const{return x*x+y*y;}\n\tinline lf size()const{return sqrtl(x*x+y*y);}\n\tinline lf operator^(const point &pt)const{return acosl(*this*pt)/length()/pt.length();}\n\tinline lf getangle(){return ang=atan2l(y,x);}\n\tinline lf angle()const{return atan2l(y,x);}\n\tinline bool operator<(const point &p)const{return ang<p.ang;}\n};\ninline bool xsmaller(const point &x,const point &y){return fabs(x.x-y.x)<1e-10?x.y<y.y:x.x<y.x;}\ninline bool ysmaller(const point &x,const point &y){return fabs(x.y-y.y)<1e-10?x.x<y.x:x.y<y.y;}\nstruct line{\n\tpoint a,b;\n\tline(){}\n\tline(point a,point b):a(a),b(b){}\n};\npoint inline intersect(line x,line y){\n\tpoint p1=x.a,v1=x.b-x.a;\n\tpoint p2=y.a,v2=y.b-y.a;\n\treturn p1+v1*(((p2-p1)%v2)/(v1%v2));\n}\ntemplate<int jt>\nint inline natsu_ksmii_with_jt(int a,int b){\n\tif(b<0)return natsu_ksmii_with_jt<jt>(a,jt-1-b);\n\tif(!b)return 1;\n\tint x=natsu_ksmii_with_jt<jt>(a,b>>1);\n\tx=1ll*x*x%jt;\n\tif(b&1)x=1ll*x*a%jt;\n\treturn x;\n}\ntemplate<int jt>\nstruct modint{\n\tint x;\n\tmodint(int X=0){x=X;x%=jt;if(x<0)x+=jt;}\n\tmodint(long long X=0){x=X%jt;if(x<0)x+=jt;}\n\tmodint<jt> inline &operator+=(const modint<jt> &m){x+=m.x;if(x>=jt)x-=jt;return *this;}\n\tmodint<jt> inline &operator++(){return *this+=1;}\n\tmodint<jt> inline operator+(const modint<jt> &m)const{modint<jt> mc=*this;mc+=m;return mc;}\n\tmodint<jt> inline &operator-=(const modint<jt> &m){x-=m.x;if(x<0)x+=jt;return *this;}\n\tmodint<jt> inline &operator--(){return *this-=1;}\n\tmodint<jt> inline operator-(const modint<jt> &m)const{modint<jt> mc=*this;mc-=m;return mc;}\n\tmodint<jt> inline operator*(const modint<jt> &m)const{return 1ll*x*m.x%jt;}\n\tmodint<jt> inline &operator*=(const modint<jt> &m){return *this=*this*m;}\n\tmodint<jt> inline inv()const{modint<jt> mc=*this;mc.x=natsu_ksmii_with_jt<jt>(mc.x,jt-2);}\n\tmodint<jt> inline &operator/(const modint<jt> &m)const{return 1ll*x*m.inv().x%jt;}\n\tmodint<jt> inline &operator/=(const modint<jt> &m){return *this=*this/m;}\n\tbool inline empty()const{return !x;}\n};\ninline int ksmii(int a,int b=jt-2){\n\tif(b<0){return ksmii(ksmii(a),-b);}\n\tif(!b){return 1;}\n\tint x=ksmii(a,b>>1);x=1ll*x*x%jt;\n\tif(b&1)x=1ll*x*a%jt;return x;\n}\ntypedef modint<jt> mint;\ntemplate<typename tp> tp gcd(tp a,tp b){return !b?a:gcd(b,a%b);}\ntemplate<int len>\nstruct bitmod{\n\tint dt[len];\n\tinline void add(int a,int x){while(a<len){dt[a]=(dt[a]+x)%jt;a+=a&-a;}}\n\tinline void add(int l,int r,int x){add(l,x%jt);add(r+1,jt-x%jt);}\n\tinline int get(int a){int ans=0;while(a){ans=(ans+dt[a])%jt;a-=a&-a;}return ans;}\n\tinline int get(int l,int r){return (get(r)-get(l-1)+jt)%jt;}\n};\ntemplate<int len>\nstruct DSU{\n\tint fa[len],sz[len];\n\tDSU(){loop(i,len)fa[i]=i,sz[i]=1;}\n\tvoid inline init(){loop(i,len)fa[i]=i,sz[i]=1;}\n\tint inline root(int x){return fa[x]==x?x:(fa[x]=root(fa[x]));}\n\tbool inline conn(int a,int b){a=root(a);b=root(b);if(a==b)return 0;fa[a]=b;sz[b]+=sz[a];return 1;}\n};\ntemplate<typename _T>\ninline _T qp(_T a,int b){\n\tif(!b){return 1;}\n\t_T x=qp(a,b>>1);x=x*x;\n\tif(b&1){x=x*a;}return x;\n}\ntemplate<int R,int C=R>\nstruct matrix{\n\tint mat[R][C];\n\tint* operator[](int x){return mat[x];}\n\tmatrix(){loop(i,R)loop(j,C)mat[i][j]=0;}\n\tmatrix(int x){loop(i,R)loop(j,C)mat[i][j]=(i==j?x:0);}\n\tmatrix<R,C> inline operator+(const matrix<R,C> m){\n\t\tmatrix<R,C> ans;\n\t\tloop(i,R)loop(j,C)ans.mat[i][j]=(mat[i][j]+m.mat[i][j])%jt;\n\t\treturn ans;\n\t}\n\ttemplate<int D> matrix<R,D> inline operator*(const matrix<C,D> m){\n\t\tmatrix<R,D> ans;\n\t\tloop(i,R)loop(j,C)loop(k,D)ans.mat[i][k]=(ans.mat[i][k]+((ll)mat[i][j])*m.mat[j][k])%jt;\n\t\treturn ans;\n\t}\n\tmatrix<R,C> inline operator+=(const matrix<R,C> m){\n\t\tmatrix<R,C> ans;\n\t\tloop(i,R)loop(j,C)ans.mat[i][j]=(mat[i][j]+m.mat[i][j])%jt;\n\t\treturn ans;\n\t}\n\tmatrix<R,C> inline operator-=(const matrix<R,C> m){\n\t\tmatrix<R,C> ans;\n\t\tloop(i,R)loop(j,C)ans.mat[i][j]=(mat[i][j]-m.mat[i][j]+jt)%jt;\n\t\treturn ans;\n\t}\n\tvoid inline debug(){loop(i,R){loop(j,C)cerr<<mat[i][j]<<' ';cerr<<endl;}cerr<<endl;}\n};\nstruct fastIO{\n\tinline fastIO operator>>(int& num){\n\t\tnum=0;char c=getchar();while(c!='-'&&(c<'0'||c>'9'))c=getchar();\n\t\tbool foo=0;if(c=='-'){foo=1;c=getchar();}\n\t\twhile(c>='0'&&c<='9'){num=(num<<3)+(num<<1)+c-'0';c=getchar();}\n\t\tif(foo)num=-num;return *this;\n\t}\n\tinline fastIO operator>>(ll& num){\n\t\tnum=0;char c=getchar();while(c!='-'&&(c<'0'||c>'9'))c=getchar();\n\t\tbool foo=0;if(c=='-'){foo=1;c=getchar();}\n\t\twhile(c>='0'&&c<='9'){num=(num<<3)+(num<<1)+c-'0';c=getchar();}\n\t\tif(foo)num=-num;return *this;\n\t}\n\tinline fastIO operator>>(float& num){scanf(\"%f\",&num);return *this;}\n\tinline fastIO operator>>(double& num){scanf(\"%lf\",&num);return *this;}\n\tinline fastIO operator>>(long double& num){scanf(\"%Lf\",&num);return *this;}\n\tinline fastIO operator>>(char& num){num=getchar();while(num==' '||num=='\\n')num=getchar();return *this;}\n\tinline fastIO operator>>(char* num){\n\t\tint cnt=0;char c=getchar();while(c==' '||c=='\\n')c=getchar();\n\t\twhile(c!=' '&&c!='\\n'){num[cnt++]=c;c=getchar();}num[cnt]=0;return *this;\n\t}\n\tinline fastIO operator>>(string& num){cin>>num;return *this;}\n\ttemplate<int jt> inline fastIO operator>>(modint<jt> &num){int x;*this>>x;num=x;return *this;}\n\tinline void printInt(const int& num){if(num<10){putchar(num+'0');return;}printInt(num/10);putchar((num%10)+'0');}\n\tinline void printll(const ll& num){if(num<10){putchar(num+'0');return;}printll(num/10);putchar((num%10)+'0');}\n\tinline fastIO operator<<(const int& num){if(num<0)putchar('-'),printInt(-num);else printInt(num);return *this;}\n\tinline fastIO operator<<(const ll& num){if(num<0)putchar('-'),printll(-num);else printll(num);return *this;}\n\tinline fastIO operator<<(const float& num){printf(\"%.10f\",num);return *this;}\n\tinline fastIO operator<<(const double& num){printf(\"%.16lf\",num);return *this;}\n\tinline fastIO operator<<(const long double& num){printf(\"%.20Lf\",num);return *this;}\n\tinline fastIO operator<<(const char& num){putchar(num);return *this;}\n\tinline fastIO operator<<(const char* num){for(int i=0;num[i];i++)putchar(num[i]);return *this;}\n\tinline fastIO operator<<(const string& num){cout<<num;return *this;}\n\ttemplate<int jt> inline fastIO operator<<(const modint<jt> &num){printInt(num.x);return *this;}\n\ttemplate<typename _T> inline fastIO operator<<(const vector<_T> &vec){printf(\"{ \");foreach(i,vec)operator<<(*i)<<' ';printf(\"}\");return *this;}\n}fio;\n\nint n,a[2005];\nvector<int> nei[2005],son[2005],cs[2005],ans;\nbool lgl[2005];\n\nvoid dfs(int now,int cc){\n\tcs[cc].pub(now);lgl[now]=1;\n\tforeach(i,nei[now])if(!lgl[*i])dfs(*i,cc),son[now].pub(*i);\n}\n\nint main(){\n\tfio>>n;cont(i,n)fio>>a[i];sort(a+1,a+n+1);\n\tcont(i,n)cont(j,n)if(gcd(a[i],a[j])!=1)nei[i].pub(j);\n\tint ccs=0;cont(i,n)if(!lgl[i])dfs(i,++ccs);\n\tpriq<pair2<int> > pq;cont(i,ccs)pq.push(mak(a[cs[i][0]],cs[i][0]));\n\twhile(pq.size()){\n\t\tpair2<int> X=pq.top();pq.pop();\n\t\tint v=X.ST,x=X.ND;ans.pub(v);\n\t\tforeach(i,son[x])pq.push(mak(a[*i],*i));\n\t}\n\tforeach(i,ans)fio<<*i<<' ';fio<<ln;return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<cstdlib>\n#include<cstring>\n#include<vector>\n#include<queue>\nusing namespace std;\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0' || ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0' && ch<='9')x=x*10+ch-'0',ch=getchar();\n\treturn x*f;\n}\nint stack[20];\ninline void write(int x)\n{\n\tif(x<0){putchar('-');x=-x;}\n\tif(!x){putchar('0');return;}\n\tint top=0;\n\twhile(x)stack[++top]=x%10,x/=10;\n\twhile(top)putchar(stack[top--]+'0');\n}\ninline void pr1(int x){write(x),putchar(' ');}\ninline void pr2(int x){write(x),puts(\"\");}\nvector<int>p[2010];\nstruct point\n{\n\tint d,p;\n}ul,uf;\npriority_queue<point>q;\nbool operator <(point a,point b){return a.d<b.d;}\ninline int gcd(int x,int y)\n{\n\tif(x==0)return y;\n\telse return gcd(y%x,x);\n}\nstruct node\n{\n\tint x,y,next;\n}a[8000010];int len,last[2010];\ninline void ins(int x,int y)\n{\n\tlen++;\n\ta[len].x=x;a[len].y=y;\n\ta[len].next=last[x];last[x]=len;\n}\nint du[2010],w[2010];\nbool v[2010];\ninline void dfs(int x)\n{\n\tv[x]=true;\n\tfor(int i=0;i<p[x].size();i++)\n\t{\n\t\tint y=p[x][i];\n\t\tif(v[y])continue;\n\t\tdu[y]++,ins(x,y);\n\t\tdfs(y);\n\t}\n}\nint main()\n{\n\t//freopen(\"a.in\",\"r\",stdin);\n\t//freopen(\"a.out\",\"w\",stdout);\n\tint n=read();\n\tfor(int i=1;i<=n;i++)w[i]=read();\n\tsort(w+1,w+n+1);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t{\n\t\t\tif(gcd(w[i],w[j])==1)continue;\n\t\t\tp[i].push_back(j),p[j].push_back(i);\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)if(!v[i])dfs(i);\n\tfor(int i=1;i<=n;i++)if(!du[i]){ul.p=i,ul.d=w[i];q.push(ul);}\n\twhile(!q.empty())\n\t{\n\t\tuf=q.top();q.pop(),pr1(uf.d);\n\t\tint x=uf.p;\n\t\tfor(int k=last[x];k;k=a[k].next)\n\t\t{\n\t\t\tint y=a[k].y;\n\t\t\tdu[y]--;if(!du[y]){ul.p=y,ul.d=w[y];q.push(ul);}\n\t\t}\n\t}puts(\"\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n #define rep(i, a, b) for (int i = a; i <= b; i++)\n #define dep(i, a, b) for (int i = a; i >= b; i--)\n #define vep(i, v) for (int i = 0; i < (int)v.size(); i++)\n #define fill(a, x) memset(a, x, sizeof(a))\n #define pb push_back\n\n typedef vector<int> Vi;\n\n const int N = 2000 + 5, M = N * N, INF = 0x3f3f3f3f;\n\n int n, es;\n int a[N], pre[N];\n Vi all, cur;\n bool vis[N];\n\n struct Edge { int from, to, pre; } e[M];\n inline void init_graph() { es = 0; fill(vis, 0); fill(pre, 0); }\n inline void ine(int a, int b) {\n \tint i = ++es;\n \te[i].from = a; e[i].to = b; e[i].pre = pre[a];\n \tpre[a] = i;\n }\n inline void ine2(int a, int b) { ine(a, b); ine(b, a); }\n #define reg(i, x) for (int i = pre[x]; i; i = e[i].pre)\n\n inline bool cmp(int x, int y) { return x >= y; }\n inline int gcd(int x, int y) { return (!y) ? x : gcd(y, x % y);}\n\n inline void merge(Vi &v1, Vi v2) {\n \tVi tmp;\n \tint p1 = 0, p2 = 0, s1 = v1.size(), s2 = v2.size();\n \ttmp.clear();\n \twhile (p1 < s1 && p2 < s2) {\n \t\tint x = v1[p1], y = v2[p2];\n \t\tif (a[x] > a[y]) tmp.pb(x), p1++; else tmp.pb(y), p2++;\n \t}\n \tif (p1 < s1) rep(i, p1, s1 - 1) tmp.pb(v1[i]);\n \telse rep(i, p2, s2 - 1) tmp.pb(v2[i]);\n \tv1 = tmp;\n }\n\n inline Vi dfs(int x) {\n \tvis[x] = true;\n \tVi ret, cur;\n \tret.clear();\n \tret.pb(0);\n \treg(i, x) {\n \t\tint y = e[i].to;\n \t\tif (!vis[y]) {\n \t\t\tcur = dfs(y);\n \t\t\tmerge(ret, cur);\n \t\t}\n \t}\n \tret[0] = x;\n \treturn ret;\n }\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\ta[0] = INF;\n\trep(i, 1, n) scanf(\"%d\", &a[i]);\n\tsort(a + 1, a + n + 1, cmp);\n\n\tinit_graph();\n\trep(i, 1, n - 1) rep(j, i + 1, n)\n\t\tif (gcd(a[i], a[j]) > 1) ine2(i, j);\n\n\tall.clear();\n\tdep(i, n, 1) if (!vis[i]) {\n\t\tcur = dfs(i);\n\t\tmerge(all, cur);\n\t}\n\trep(i, 0, n - 2) printf(\"%d \", a[all[i]]);\n\tprintf(\"%d\\n\", a[all[n - 1]]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*************************************************\n *************************************************\n *************************************************\n *** _________________  |            |  |     /***\n ***         |          |            |  |    / ***\n ***         |          |            |  |   /  ***\n ***         |          |            |  |  /   ***\n ***         |          |            |  | /    ***\n ***         |          |____________|  |/  en ***\n ***         |          |            |  |\\     ***\n ***         |          |            |  | \\    ***\n *** _____   |          |            |  |  \\   ***\n ***   |     |          |            |  |   \\  ***\n ***   \\     /          |            |  |    \\ ***\n ***    \\___/           |            |  |     \\***\n *************************************************\n *************Written by: JiangHaoKai*************\n *************************************************/\n\n#pragma GCC optimize(2)\n#pragma G++ optimize(2)\n#pragma comment(linker,\"/STACK:102400000,102400000\")\n\n//#include <bits/stdc++.h>\n#include <cassert>\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdalign>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <string>\n#include <typeinfo>\n#include <valarray>\n#include <vector>\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <scoped_allocator>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <unordered_map>\n#include <unordered_set>\n//#include <conio.h>\n//#include <windows.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned int ui;\ntypedef unsigned long long ull;\ntypedef float fl;\ntypedef double ld;\ntypedef pair<int,int> pii;\n#define ui(n) ((unsigned int)(n))\n#define ll(n) ((long long)(n))\n#define ull(n) ((unsigned long long)(n))\n#define fl(n) ((float)(n))\n#define ld(n) ((double)(n))\n#define char(n) ((char)(n))\n#define Bool(n) ((bool)(n))\n#define fixpoint(n) fixed<<setprecision(n)\nconst int INF=1061109567;\nconst LL LINF=4557430888798830399;\n#define PI 3.1415926535897932384626433832795028841971\n#define MP make_pair\n#define MT make_tuple\n#define All(a) (a).begin(),(a).end()\n#define pall(a) (a).rbegin(),(a).rend()\n#define MOD 1000000007\n#define sz(a) ((int)(a).size())\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define repa(i,a,n) for(int i=a;i<n;i++)\n#define repa1(i,a,n) for(int i=a;i<=n;i++)\n#define repd(i,n) for(int i=n-1;i>=0;i--)\n#define repd1(i,n) for(int i=n;i>=1;i--)\n#define repda(i,n,a) for(int i=n;i>a;i--)\n#define repda1(i,n,a) for(int i=n;i>=a;i--)\n#define FOR(i,a,n,step) for(int i=a;i<n;i+=step)\n#define repv(itr,v) for(__typeof((v).begin()) itr=(v).begin();itr!=(v).end();itr++)\n#define repV(i,v) for(auto i:v)\n#define repE(i,v) for(auto &i:v)\n#define MS(x,y) memset(x,y,sizeof(x))\n#define MC(x) MS(x,0)\n#define MCP(x,y) memcpy(x,y,sizeof(y))\n#define sqr(x) ((x)*(x))\n#define filein(x) freopen(x,\"r\",stdin)\n#define fileout(x) freopen(x,\"w\",stdout)\n#define fileout2(filename,name) ofstream name(filename,ios::out)\n#define filein2(filename,name) ifstream name(filename,ios::in)\n#define file(filename,name) fstream name(filename,ios::in|ios::out)\n#define Pause system(\"pause\")\n#define Cls system(\"cls\")\n#define fs first\n#define sc second\n#define PC(x) putchar(x)\n#define GC(x) x=getchar()\n#define Endl PC('\\n')\n#define SF scanf\n#define PF printf\n\ninline int Read()\n{\n    int X=0,w=0;char ch=0;while(!isdigit(ch)){w|=ch=='-';ch=getchar();}while(isdigit(ch))X=(X<<3)+(X<<1)+(ch^48),ch=getchar();\n\treturn w?-X:X;\n}\ninline void Write(int x){if(x<0)putchar('-'),x=-x;if(x>9)Write(x/10);putchar(x%10+'0');}\n\ninline LL powmod(LL a,LL b){LL res=1;a%=MOD;assert(b>=0);for(;b;b>>=1){if(b&1)res=res*a%MOD;a=a*a%MOD;}return res;}\ninline LL gcdll(LL a,LL b){return b?gcdll(b,a%b):a;}\nconst int dx[]={0,1,0,-1,1,-1,-1,1};\nconst int dy[]={1,0,-1,0,-1,-1,1,1};\n/**************************************************************Begin***************************************************************/\nconst int maxn=2010;\n\nint n,nn,a[maxn],x[maxn];\nLL g[maxn][maxn],was[maxn];\nbool alive[maxn],canput[maxn];\n\nint main()\n{\n\tSF(\"%d\",&n);\n\trep(i,n) SF(\"%d\",&a[i]);\n\t\n\trep(i,n) rep(j,n) if(__gcd(a[i],a[j])>1)\n\t{\n\t\tg[i][j>>6]|=(1<<(j&63));\n\t\tg[j][i>>6]|=(1<<(i&63));\n\t}\n\t\n\tnn=((n-1)>>6)+1;\n\trep(i,n) alive[i]=canput[i]=1;\n\t\n\trep(it,n)\n\t{\n\t\trep(i,nn) was[i]=0;\n\t\trep(i,n) if(!alive[i]) was[i>>6]|=(1<<(i&63));\n\t\t\n\t\tint best=-1;\n\t\trep(i,n) if(!(was[i>>6]&(1<<(i&63))))\n\t\t{\n\t\t\tint b=0,e=1;\n\t\t\tx[0]=i;\n\t\t\twas[i>>6]|=(1<<(i&63));\n\t\t\t\n\t\t\twhile(b<e)\n\t\t\t{\n\t\t\t\trep(j,nn) if((g[x[b]][j]&was[j])!=g[x[b]][j])\n\t\t\t\t{\n\t\t\t\t\trepa(u,j*64,(j+1)*64) if(g[x[b]][u>>6]&(1<<(u&63))) if(!(was[u>>6]&(1<<(u&63))))\n\t\t\t\t\t{\n\t\t\t\t\t\twas[u>>6]|=(1<<(u&63));\n\t\t\t\t\t\tx[e++]=u;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tb++;\n\t\t\t}\n\t\t\t\n\t\t\tint cur=-1;\n\t\t\trep(j,e) if(canput[x[j]])\n\t\t\t{\n\t\t\t\tif(cur==-1||a[x[j]]<a[cur]) cur=x[j];\n\t\t\t}\n\t\t\t\n\t\t\tif(best==-1||(cur!=-1&&a[cur]>a[best])) best=cur;\n\t\t}\n\t\t\n\t\tPF(\"%d \",a[best]);\n\t\talive[best]=0;\n\t\trep(i,n) if(alive[i])\n\t\t{\n\t\t\tif(g[best][i>>6]&(1<<(i&63))) canput[i]=1;\n\t\t\telse if(a[best]<a[i]) canput[i]=0;\n\t\t}\n\t}\n\n\treturn 0;\n}\n/***************************************************************End****************************************************************/\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iomanip>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define all(x) (x).begin(),(x).end()\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n \ntemplate<class T> inline bool chmax(T &a, T b){\n    if(a<b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T> inline bool chmin(T &a, T b){\n    if(a>b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<typename T>\nT gcd(T a, T b)\n{\n    return b ? gcd(b, a % b) : a;\n}\n\ntemplate<typename T>\nT lcm(T a,T b)\n{\n    return  a / gcd(a,b) * b;\n}\nclass UnionFind {\nprivate:\n    int sz;\n    vector<int> par, size_;\npublic:\n    UnionFind(){}\n    UnionFind(int node_size) : sz(node_size), par(sz), size_(sz, 1){\n        iota(par.begin(), par.end(), 0);\n    }\n    int find(int x){\n        if(par[x] == x) return x;\n        else return par[x] = find(par[x]);\n    }\n    void unite(int x,int y){\n        x = find(x), y = find(y);\n        if(x == y) return;\n        if(size_[x] < size_[y]) swap(x,y);\n        par[y] = x;\n        size_[x] += size_[y];\n    }\n    int size(int x){\n        x = find(x);\n        return size_[x];\n    }\n    bool same(int x,int y){\n        return find(x) == find(y);\n    }\n};\n\nclass BSTNode {\npublic:\n    const int from, to;\n    int sz;\n    bool subtree_edge, subofftree_edge, exact_level;\n    BSTNode *left, *right, *par;\n    unordered_set<int> adjacent;\n    BSTNode(const int _ver) noexcept :\n        from(_ver), to(_ver), sz(0), subtree_edge(false), subofftree_edge(false),\n            exact_level(false), left(nullptr), right(nullptr), par(nullptr){}\n    BSTNode(const int _from, const int _to, const bool _flag) noexcept :\n        from(_from), to(_to), sz(0), subtree_edge(false), subofftree_edge(false),\n            exact_level((from < to) && _flag), left(nullptr), right(nullptr), par(nullptr){}\n    inline bool IsRoot() const noexcept { return !par; }\n    inline bool IsVertex() const noexcept { return (from == to); }\n    inline void eval() noexcept {\n        if(IsVertex()) sz = 1, subtree_edge = false, subofftree_edge = !adjacent.empty();\n        else sz = 0, subtree_edge = exact_level, subofftree_edge = false;\n        if(left){\n            sz += left->sz, subtree_edge |= left->subtree_edge, subofftree_edge |= left->subofftree_edge;\n        }\n        if(right){\n            sz += right->sz, subtree_edge |= right->subtree_edge, subofftree_edge |= right->subofftree_edge;\n        }\n    }\n    inline void subtree_edge_eval(){\n        subtree_edge = exact_level;\n        if(left) subtree_edge |= left->subtree_edge;\n        if(right) subtree_edge |= right->subtree_edge;\n    }\n    inline void subofftree_edge_eval(){\n        subofftree_edge = !adjacent.empty();\n        if(left) subofftree_edge |= left->subofftree_edge;\n        if(right) subofftree_edge |= right->subofftree_edge;\n    }\n    inline bool subofftree_check(){\n        return !adjacent.empty() ||\n                (left ? left->subofftree_edge : false) || (right ? right->subofftree_edge : false);\n    }\n    inline bool offtree_check(){\n        return adjacent.empty() ||\n                (left ? left->subofftree_edge : false) || (right ? right->subofftree_edge : false);\n    }\n    void rotate(const bool right_) noexcept {\n        BSTNode *p = par, *g = p->par;\n        if(right_){\n            if((p->left = right)) right->par = p;\n            right = p, p->par = this;\n        }else{\n            if((p->right = left)) left->par = p;\n            left = p, p->par = this;\n        }\n        p->eval(), eval();\n        if(!(par = g)) return;\n        if(g->left == p) g->left = this;\n        if(g->right == p) g->right = this;\n        g->eval();\n    }\n};\n \nBSTNode *splay(BSTNode *u) noexcept {\n    if(!u) return nullptr;\n    while(!(u->IsRoot())){\n        BSTNode *p = u->par, *gp = p->par;\n        if(p->IsRoot()){ // zig\n            u->rotate((u == p->left));\n        }else{\n            bool flag = (u == p->left);\n            if((u == p->left) == (p == gp->left)){ // zig-zig\n                p->rotate(flag), u->rotate(flag);\n            }else{ // zig-zag\n                u->rotate(flag), u->rotate(!flag);\n            }\n        }\n    }\n    return u;\n}\n \nBSTNode *join(BSTNode *root1, BSTNode *root2) noexcept {\n    if(!root1 || !root2) return root1 ? root1 : root2;\n    BSTNode *cur = nullptr, *nx = root1;\n    do{ cur = nx, nx = cur->right; }while(nx);\n    BSTNode *ver = splay(cur);\n    ver->right = root2, ver->eval(), root2->par = ver;\n    return ver;\n}\n \nclass EulerTourTree {\npublic:\n    struct pair_hash {\n        template <class T1, class T2>\n        size_t operator() (const pair<T1, T2>& p) const {\n            size_t lhs = hash<T1>()(p.first), rhs = hash<T2>()(p.second);\n            return lhs^(rhs+0x9e3779b9+(lhs<<6)+(lhs>>2));\n        }\n    };\n    BSTNode** vertex_set;\n    unordered_map<pair<int, int>, pair<BSTNode*, BSTNode*>, pair_hash> edge_set;\nprivate:\n    BSTNode *reroot(BSTNode *ver) noexcept {\n        BSTNode *res = splay(ver)->left;\n        if(!res) return ver;\n        ver->left = nullptr, ver->eval();\n        while(ver->right) ver = ver->right;\n        splay(ver), ver->right = res, ver->eval(), res->par = ver;\n        return ver;\n    }\n    void link(BSTNode *ver1, BSTNode *ver2, const bool flag) noexcept {\n        BSTNode *e1 = new BSTNode(ver1->from, ver2->from, flag);\n        BSTNode *e2 = new BSTNode(ver2->from, ver1->from, flag);\n        edge_set[{ver1->from, ver2->from}] = {e1, e2};\n        join(join(reroot(ver1), e1), join(reroot(ver2), e2));\n    }\n    void cut(BSTNode *edge1, BSTNode *edge2) noexcept {\n        splay(edge1), splay(edge2);\n        BSTNode *p = edge1->par;\n        bool _right = (edge1 == edge2->right);\n        if(p != edge2){\n            _right = (p == edge2->right);\n            p->par = nullptr, edge1->rotate((edge1 == p->left));\n        }\n        if(edge1->left) edge1->left->par = nullptr;\n        if(edge1->right) edge1->right->par = nullptr;\n        if(_right){\n            if(edge2->left) edge2->left->par = nullptr;\n            join(edge2->left, edge1->right);\n        }else{\n            if(edge2->right) edge2->right->par = nullptr;\n            join(edge1->left, edge2->right);\n        }\n        // delete edge1; delete edge2;\n    }\n    bool connected(BSTNode *ver1, BSTNode *ver2) noexcept {\n        splay(ver1), splay(ver2);\n        return ver1->par;\n    }\n    int component_size(BSTNode *ver) noexcept { return splay(ver)->sz; }\npublic:\n    int V;\n    EulerTourTree(){}\n    // ~EulerTourTree(){\n    //     for(auto it : edge_set){\n    //         delete (it.second).first;\n    //         delete (it.second).second;\n    //     }\n    //     for(int i = 0; i < V; ++i) delete vertex_set[i];\n    //     delete[] vertex_set;\n    // }\n    void resize(const int node_size) noexcept {\n        V = node_size, vertex_set = new BSTNode*[V];\n        for(int i = 0; i < V; i++) vertex_set[i] = new BSTNode(i);\n    }\n    void reroot(const int node_id) noexcept { reroot(vertex_set[node_id]); }\n    void link(int node1_id, int node2_id, bool flag=true) noexcept {\n        if(node1_id > node2_id) swap(node1_id, node2_id);\n        link(vertex_set[node1_id], vertex_set[node2_id], flag);\n    }\n    void cut(int node1_id, int node2_id){\n        if(node1_id > node2_id) swap(node1_id, node2_id);\n        auto it = edge_set.find({node1_id, node2_id});\n        assert(it != edge_set.end());\n        BSTNode *edge1 = (it->second).first, *edge2 = (it->second).second;\n        edge_set.erase(it);\n        cut(edge1, edge2);\n    }\n    bool connected(const int node1_id, const int node2_id) noexcept {\n        if(node1_id == node2_id) return true;\n        return connected(vertex_set[node1_id], vertex_set[node2_id]);\n    }\n    int component_size(int node_id) noexcept { return component_size(vertex_set[node_id]); }\n    void check_dfs(const BSTNode* cur) const noexcept {\n        if(cur->left) check_dfs(cur->left);\n        cout << \"{\" << (cur->from) << \",\" << (cur->to) << \"} \";\n        if(cur->right) check_dfs(cur->right);\n    }\n};\n \nclass DynamicConnectivity {\nprivate:\n    BSTNode *level_up_dfs(BSTNode *cur, const int layer) noexcept {\n        if(cur->exact_level){\n            splay(cur)->exact_level = false, cur->subtree_edge_eval();\n            detect_layer[{cur->from, cur->to}]++, et[layer+1].link(cur->from, cur->to);\n            return cur;\n        }\n        if(cur->left && cur->left->subtree_edge) return level_up_dfs(cur->left, layer);\n        if(cur->right && cur->right->subtree_edge) return level_up_dfs(cur->right, layer);\n        return nullptr;\n    }\n    BSTNode *search_edge_dfs\n        (BSTNode *cur, const int layer, const int another, bool& flag, pair<int, int>& rep_edge) noexcept {\n        if(!cur->adjacent.empty()){\n            bool state = et[layer+1].vertex_set[cur->from]->adjacent.empty();\n            for(auto it = cur->adjacent.begin(); it != cur->adjacent.end();){\n                pair<int, int> e = {min(cur->from, *it), max(cur->from, *it)};\n                BSTNode *correspond = et[layer].vertex_set[*it];\n                if(et[layer].connected(another, *it)){\n                    flag = true, rep_edge = e;\n                    cur->adjacent.erase(it), correspond->adjacent.erase(cur->from);\n                    if(!correspond->subofftree_check()){\n                        splay(correspond)->subofftree_edge_eval();\n                    }\n                    break;\n                }else{\n                    if(!et[layer+1].vertex_set[*it]->subofftree_check()){\n                        splay(et[layer+1].vertex_set[*it])->subofftree_edge = true;\n                    }\n                    et[layer+1].vertex_set[cur->from]->adjacent.insert(*it);\n                    et[layer+1].vertex_set[*it]->adjacent.insert(cur->from);\n                    detect_layer[e]++, it = cur->adjacent.erase(it);\n                    correspond->adjacent.erase(cur->from);\n                    if(!correspond->subofftree_check()){\n                        splay(correspond)->subofftree_edge_eval();\n                    }\n                }\n            }\n            if(state && !et[layer+1].vertex_set[cur->from]->offtree_check()){\n                splay(et[layer+1].vertex_set[cur->from])->subofftree_edge = true;\n            }\n            splay(cur)->subofftree_edge_eval();\n            return cur;\n        }\n        if(cur->left && cur->left->subofftree_edge){\n            return search_edge_dfs(cur->left, layer, another, flag, rep_edge);\n        }\n        if(cur->right && cur->right->subofftree_edge){\n            return search_edge_dfs(cur->right, layer, another, flag, rep_edge);\n        }\n        return nullptr;\n    }\n    bool replace(const int from, const int to, const int layer) noexcept {\n        if(layer < 0) return true;\n        int u, v;\n        if(et[layer].component_size(from) <= et[layer].component_size(to)) u = from, v = to;\n        else u = to, v = from;\n        BSTNode *ver = splay(et[layer].vertex_set[u]);\n        while(ver->subtree_edge) ver = level_up_dfs(ver, layer);\n        pair<int, int> rep_edge = {-1, -1};\n        bool flag = false;\n        while(ver->subofftree_edge){\n            ver = search_edge_dfs(ver, layer, v, flag, rep_edge);\n            if(flag) break;\n        }\n        if(flag){\n            et[layer].link(rep_edge.first, rep_edge.second);\n            for(int i = 0; i < layer; i++) et[i].link(rep_edge.first, rep_edge.second, false);\n            return false;\n        }else return replace(from, to, layer-1);\n    }\npublic:\n    const int V, layer_count;\n    EulerTourTree* et;\n    unordered_map<pair<int, int>, int, EulerTourTree::pair_hash> detect_layer;\n    DynamicConnectivity(int node_size) noexcept : V(node_size), layer_count(ceil(log2(V))+1){\n        et = new EulerTourTree[layer_count];\n        for(int i = 0; i < layer_count; i++) et[i].resize(V);\n    }\n    // ~DynamicConnectivity(){\n    //     delete[] et;\n    // }\n    bool link(int node1_id, int node2_id) noexcept {\n        if(node1_id > node2_id) swap(node1_id, node2_id);\n        detect_layer[{node1_id, node2_id}] = 0;\n        if(et[0].connected(node1_id, node2_id)){\n            BSTNode *ver1 = et[0].vertex_set[node1_id], *ver2 = et[0].vertex_set[node2_id];\n            splay(ver1)->subofftree_edge = true, ver1->adjacent.insert(node2_id);\n            splay(ver2)->subofftree_edge = true, ver2->adjacent.insert(node1_id);\n            return false;\n        }else{\n            et[0].link(node1_id, node2_id);\n            return true;\n        }\n    }\n    bool cut(int node1_id, int node2_id) noexcept {\n        if(node1_id > node2_id) swap(node1_id, node2_id);\n        auto it = detect_layer.find({node1_id, node2_id});\n        assert(it != detect_layer.end());\n        int layer = it->second;\n        detect_layer.erase(it);\n        auto& st = et[layer].vertex_set[node1_id]->adjacent;\n        if(st.find(node2_id) == st.end()){\n            for(int i = 0; i <= layer; i++) et[i].cut(node1_id, node2_id);\n            return replace(node1_id, node2_id, layer);\n        }else{\n            et[layer].vertex_set[node1_id]->adjacent.erase(node2_id);\n            if(!et[layer].vertex_set[node1_id]->subofftree_check()){\n                splay(et[layer].vertex_set[node1_id])->subofftree_edge_eval();\n            }\n            et[layer].vertex_set[node2_id]->adjacent.erase(node1_id);\n            if(!et[layer].vertex_set[node2_id]->subofftree_check()){\n                splay(et[layer].vertex_set[node2_id])->subofftree_edge_eval();\n            }\n            return false;\n        }\n    }\n    bool connected(const int node1_id, const int node2_id) noexcept {\n        return et[0].connected(node1_id, node2_id);\n    }\n};\n\nvector<int>a;\nvector<int> calc(pii e_min,vector<vector<int> > &g,set<int> st,DynamicConnectivity &dc){\n    vector<int> res;\n    res.push_back(e_min.first);\n    if(st.size()==1){\n        return res;\n    }\n    int id = e_min.second;\n    vector<int> v;\n    st.erase(id);\n    for(auto x:g[id]){\n        if(st.count(x)==1){\n            dc.cut(id,x);\n            v.push_back(x);\n        }\n    }\n    random_shuffle(v.begin(),v.end());\n    vector<vector<int> > ss;\n    for(auto x:v){\n        if(st.count(x)==0)continue;\n        set<int> p;\n        for(auto y:st){\n            if(dc.connected(x,y)){\n                p.insert(y);\n            }\n        }\n        for(auto y:p){\n            st.erase(y);\n        }\n        ss.push_back(calc(MP(a[x],x),g,p,dc));\n    }\n    priority_queue<pair<int,pii > > pp;\n    int m = ss.size();\n    rep(i,m){\n        pp.push(MP(ss[i][0],MP(i,0)));\n    }\n    while(!pp.empty()){\n        auto x = pp.top();\n        pp.pop();\n        res.push_back(x.first);\n        if(ss[x.second.first].size()!=x.second.second+1){\n            pp.push(MP(ss[x.second.first][x.second.second+1],MP(x.second.first,x.second.second+1)));\n        }\n    }\n    return res;\n}\n\nint main(){\n    int n;\n    cin >> n;\n    a.resize(n);\n    \n    rep(i,n){\n        cin >> a[i];\n    }\n    DynamicConnectivity dc(n);\n    vector<vector<int> > g(n);\n    UnionFind uf(n);\n    rep(i,n){\n        for(int j=i+1;j<n;j++){\n            if(gcd(a[i],a[j])!=1){\n                g[i].push_back(j);\n                g[j].push_back(i);\n                dc.link(i,j);\n                uf.unite(i,j);\n            }\n        }\n    }\n    vector<pair<int,int> > p(n,MP(inf,inf));\n    vector<set<int> > st(n);\n    rep(i,n){\n        p[uf.find(i)] = min(MP(a[i],i),p[uf.find(i)]);\n        st[uf.find(i)].insert(i);\n    }\n    vector<bool> used(n);\n    vector<vector<int> > res;\n    rep(i,n){\n        if(!used[uf.find(i)]){\n            int k = uf.find(i);\n            used[k] = 1;\n            auto ss = p[k];\n            res.push_back(calc(ss,g,st[k],dc));\n        }\n    }\n    for(auto x:res){\n        for(auto y:x){\n            cout << y << \" \";\n        }\n        cout << endl;\n    }\n    priority_queue<pair<int,pii > > pp;\n    int m = res.size();\n    rep(i,m){\n        pp.push(MP(res[i][0],MP(i,0)));\n    }\n    vector<int> ans;\n    while(!pp.empty()){\n        auto x = pp.top();\n        pp.pop();\n        ans.push_back(x.first);\n        if(res[x.second.first].size()!=x.second.second+1){\n            pp.push(MP(res[x.second.first][x.second.second+1],MP(x.second.first,x.second.second+1)));\n        }\n    }\n    for(auto x:ans){\n        cout << x << \" \";\n    }\n    cout << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n,a[2005],V;\nvector<int>edge[2005];\nbool used[2005][2005],ex[2005][2005];\nint in[2005];\nvector<int>nxt;\nP q;\nvoid dfs(int v){\n\tif(used[V][v]) return; used[V][v] = 1;\n\tnxt.pb(v);\n\trep(i,edge[v].size()){\n\t\tif(used[V][edge[v][i]] || in[edge[v][i]] != V) continue;\n\t\tdfs(edge[v][i]);\n\t}\n}\nvector<int>mer(vector<int>ret,vector<int>hoge){\n\t\tint c = ret.size(),b = hoge.size();\n\t\tint i = 0,j = 0;\n\t\tvector<int>ret2; ret2.resize(c+b); int nxt = 0;\n\t\twhile(i!=c || j!=b){\n\t\t\tif(i==c) ret2[nxt++] = (hoge[j++]);\n\t\t\telse if(j==b) ret2[nxt++] = (ret[i++]);\n\t\t\telse{\n\t\t\t\tif(a[ret[i]] > a[hoge[j]]) ret2[nxt++] = (ret[i++]);\n\t\t\t\telse ret2[nxt++] = (hoge[j++]);\n\t\t\t}\n\t\t}\n\t\treturn ret2;\n}\nvector<int>make(vector<int>L,int cut){\n\tvector<int>ret;\n\tif(L.size() == 1){\n\t\tret.pb(cut); return ret;\n\t}\n\trep(i,L.size()){\n\t\tif(L[i] != cut){\n\t\t    in[L[i]] = cut;\n\t\t}\n\t}\n\tvector<pair<vector<int>,int> >vv;\n\trep(i,L.size()){\n\t\tif(L[i] == cut) continue;\n\t\tif(!used[cut][L[i]]){\n\t\t\tnxt.clear(); q = mp(INF,INF);\n\t\t\tV = cut; dfs(L[i]);\n\t\t\trep(j,nxt.size()){\n\t\t\t\tif(ex[nxt[j]][cut]){\n\t\t\t\t\tq = min(q,mp(a[nxt[j]],nxt[j]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tvv.pb(mp(nxt,q.sc));\n\t\t}\n\t}\n\trep(ii,vv.size()){\n\t\tvector<int>&nxt = vv[ii].fi; int Q = vv[ii].sc;\n\t\tvector<int>hoge = make(nxt,Q);\n\t\tret = mer(ret,hoge);\n\t}\n\tret.insert(ret.begin(),cut);\n\treturn ret;\n}\nbool U[2005];\nvector<int>vi;\nP p;\nvoid DFS(int x){\n\tif(U[x]) return; U[x] = 1;\n\tvi.pb(x); p = min(p,mp(a[x],x));\n\trep(i,edge[x].size()){\n\t\tDFS(edge[x][i]);\n\t}\n}\nvector<int>res;\nint main(){\n\tcin>>n;\n\trepn(i,n){\n\t\tcin>>a[i];\n\t}\n\trepn(i,n) repn(j,n){\n\t\tif(i != j && __gcd(a[i],a[j]) > 1){\n\t\t\tedge[i].pb(j); ex[i][j] = 1;\n\t\t}\n\t}\n\trepn(i,n){\n\t\tif(U[i]) continue; p = mp(INF,INF); vi.clear();\n\t\tDFS(i);\n\t\tvector<int>vec = make(vi,p.sc);\n\t\tres = mer(res,vec);\n\t}\n\trep(i,n) cout<<a[res[i]]<<\" \";\n\tcout<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define X first\n#define Y second\n#define mp make_pair\nusing namespace std;\ntypedef pair<int,bool> PIB;\ntypedef vector<PIB> T;\nconst int N = 2010;\nint gcd(int a,int b){\n\tif(b==0) return a;\n\treturn gcd(b,a%b);\n}\nint a[N],n;\nvector<int> v[N],g[N];\nbool use[N],in[N],pd[N];\nint d[N],q[N],head,tail,t;\n \nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",a+i); \n\t//for(int i=1;i<=n;i++) q.push_back(mp(i,true));\n\t//solve(q);\n\tfor(int i =1;i<=n;i++) for(int j = 1;j<=n;j++ )if(i!=j && gcd(a[i],a[j])!=1) g[i].push_back(j);\n\t//cout<<g[2][4]<<endl;\n\tmemset(pd,true,sizeof(pd));\n\tfor(int i =1;i<=n;){\n\t\thead = tail = 0;\n\t\tq[0] = i;\n\t\tmemset(in,false,sizeof(in));\n\t\tin[i] = true;\n\t\twhile(head<=tail){\n\t\t\tt =q[head++];\n\t\t\tfor(int i =0;i<g[t].size();i++) if(!use[g[t][i]] && !in[g[t][i]]){\n\t\t\t\t//cout<<i<<endl;\n\t\t\t\tin[g[t][i]] = true;\n\t\t\t\tq[++tail] = g[t][i];\n\t\t\t} \n\t\t}\n\t\t//cout<<tail<<endl;\n\t\tsort(q,q+tail+1);\n\t\tfor(int i = 0;i<=tail;i++) if(pd[q[i]]){\n\t\t\tt = q[i];\n\t\t\tuse[t] = true;\n\t\t\t//cout<<t<<endl;\n\t\t\tfor(int j = 0;j<=tail;j++) {\n\t\t\t\tpd[q[j]] = false;\n\t\t\t\tif(gcd(a[t],a[q[j]])!=1 && t!=q[j]) {\n\t\t\t\t\tpd[q[j]] = true;\n\t\t\t\t\tv[t].push_back(q[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t} \n\t\tif(use[i]) i++;\n\t} \n\t//cout<<v[2].size()<<endl;\n\t// output topology sequence\n\tint cnt =0;\n\tmemset(pd,false,sizeof(pd));\n\tfor(int i = 1;i<=n;i++) for(int j =0;j<v[i].size();j++) d[v[i][j]]++;\n\twhile(cnt<n){\n\t\tint last = 0;\n\t\tfor(int i = 1;i<=n;i++) if(!pd[i] && d[i]==0 && a[i]>a[last]){\n\t\t\tlast = i;\n\t\t} \n\t\tpd[last] = true;\n\t\tfor(int i =0;i<v[last].size();i++) d[v[last][i]]--;\n\t\tprintf(\"%d \",a[last]);\n\t\tcnt++;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iomanip>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define all(x) (x).begin(),(x).end()\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n \ntemplate<class T> inline bool chmax(T &a, T b){\n    if(a<b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T> inline bool chmin(T &a, T b){\n    if(a>b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<typename T>\nT gcd(T a, T b)\n{\n    return b ? gcd(b, a % b) : a;\n}\n\ntemplate<typename T>\nT lcm(T a,T b)\n{\n    return  a / gcd(a,b) * b;\n}\nclass UnionFind {\nprivate:\n    int sz;\n    vector<int> par, size_;\npublic:\n    UnionFind(){}\n    UnionFind(int node_size) : sz(node_size), par(sz), size_(sz, 1){\n        iota(par.begin(), par.end(), 0);\n    }\n    int find(int x){\n        if(par[x] == x) return x;\n        else return par[x] = find(par[x]);\n    }\n    void unite(int x,int y){\n        x = find(x), y = find(y);\n        if(x == y) return;\n        if(size_[x] < size_[y]) swap(x,y);\n        par[y] = x;\n        size_[x] += size_[y];\n    }\n    int size(int x){\n        x = find(x);\n        return size_[x];\n    }\n    bool same(int x,int y){\n        return find(x) == find(y);\n    }\n};\ntemplate<class _Key, class _Hash, bool DOWNSIZE> class UnorderedSetIterator;\n \ntemplate<class _Key, class _Hash = hash<_Key>, bool DOWNSIZE = false>\nclass UnorderedSet\n{\nprivate:\n    using iterator = UnorderedSetIterator<_Key, _Hash, DOWNSIZE>;\n    friend UnorderedSetIterator<_Key, _Hash, DOWNSIZE>;\n    struct bucket {\n        _Key _key;\n        short int _dist;\n        bool _last, _end;\n        bucket() noexcept : _dist(-1), _last(false), _end(false){}\n        bucket& operator=(const bucket& another) = default;\n        ~bucket(){ if(!empty()) _key.~_Key(); }\n        inline void clear() noexcept { _dist = -1; }\n        inline void _delete(){ _dist = -1, _key.~_Key(); }\n        inline bool empty() const noexcept { return (_dist == -1); }\n    };\n    inline static unsigned int ceilpow2(unsigned int u) noexcept {\n        --u, u |= u >> 1, u |= u >> 2, u |= u >> 4, u |= u >> 8;\n        return (u | (u >> 16)) + 1;\n    }\n    inline static bucket *increment(bucket *cur) noexcept {\n        for(++cur; !cur->_end; ++cur){\n            if(!cur->empty()) break;\n        }\n        return cur;\n    }\n    inline bucket *next_bucket(bucket *cur) const noexcept {\n        return cur->_last ? _buckets : cur + 1;\n    }\n    inline unsigned int make_hash(const _Key& key) const noexcept {\n        return _Hash()(key);\n    }\n    inline float load_rate() const noexcept {\n        return (float)_data_count / _bucket_count;\n    }\n    bucket *insert(bucket *cur, short int dist, _Key&& key){\n        bucket *ret = cur;\n        bool flag = false;\n        while(true){\n            if(cur->empty()){\n                cur->_key = move(key), cur->_dist = dist;\n                if(!flag) ret = cur, flag = true;\n                break;\n            }else if(dist > cur->_dist){\n                swap(key, cur->_key), swap(dist, cur->_dist);\n                if(!flag) ret = cur, flag = true;\n            }\n            ++dist;\n            cur = next_bucket(cur);\n        }\n        return ret;\n    }\n    bucket *_find(const _Key& key) const {\n        bucket *cur = _buckets + (make_hash(key) & _mask);\n        int dist = 0;\n        while(dist <= cur->_dist){\n            if(key == cur->_key) return cur;\n            ++dist, cur = next_bucket(cur);\n        }\n        return _buckets + _bucket_count;\n    }\n    template<class Key>\n    bucket *find_insert(Key&& key){\n        unsigned int hash = make_hash(key);\n        bucket *cur = _buckets + (hash & _mask);\n        int dist = 0;\n        while(dist <= cur->_dist){\n            if(key == cur->_key) return cur;\n            ++dist, cur = next_bucket(cur);\n        }\n        ++_data_count;\n        if(rehash_check()){\n            cur = _buckets + (hash & _mask), dist = 0;\n        }\n        _Key new_key = forward<Key>(key);\n        return insert(cur, dist, move(new_key));\n    }\n    bucket *backward_shift(bucket *cur, bool next_ret){\n        bucket *next = next_bucket(cur), *ret = cur;\n        if(next->_dist < 1) return next_ret ? increment(cur) : cur;\n        do {\n            cur->_key = next->_key, cur->_dist = next->_dist - 1;\n            cur = next, next = next_bucket(cur);\n        }while(next->_dist >= 1);\n        cur->clear();\n        return ret;\n    }\n    bucket *erase_impl(bucket *cur, bool next_ret){\n        assert(static_cast<size_t>(cur - _buckets) != _bucket_count);\n        cur->_delete();\n        --_data_count;\n        return backward_shift(cur, next_ret);\n    }\n    bucket *erase_itr(bucket *cur, bool next_ret = true){\n        const _Key key = cur->_key;\n        return erase_impl(rehash_check() ? _find(key) : cur, next_ret);\n    }\n    bucket *erase_key(const _Key& key, bool next_ret = true){\n        rehash_check();\n        return erase_impl(_find(key), next_ret);\n    }\n    bool rehash_check(){\n        if(load_rate() >= MAX_LOAD_RATE){\n            rehash(_bucket_count * 2u);\n            return true;\n        }else if(DOWNSIZE){\n            if(load_rate() <= MIN_LOAD_RATE && _bucket_count >= DOWNSIZE_THRESHOLD){\n                rehash(_bucket_count / 2u);\n                return true;\n            }\n        }\n        return false;\n    }\n    void move_data(bucket *cur){\n        insert(_buckets + (make_hash(cur->_key) & _mask), 0, move(cur->_key));\n    }\n    void rehash(unsigned int new_bucket_count){\n        UnorderedSet new_unordered_set(new_bucket_count);\n        new_unordered_set._data_count = _data_count;\n        for(bucket *cur = _buckets; !cur->_end; ++cur){\n            if(!cur->empty()){\n                new_unordered_set.move_data(cur);\n            }\n        }\n        swap(*this, new_unordered_set);\n    }\n    friend void swap(UnorderedSet& ust1, UnorderedSet& ust2){\n        swap(ust1._bucket_count, ust2._bucket_count);\n        swap(ust1._mask, ust2._mask);\n        swap(ust1._data_count, ust2._data_count);\n        swap(ust1._buckets, ust2._buckets);\n    }\n \nprivate:\n    unsigned int _bucket_count, _mask, _data_count;\n    bucket *_buckets;\npublic:\n    const float MAX_LOAD_RATE = 0.5f;\n    const float MIN_LOAD_RATE = 0.1f;\n    const unsigned int DOWNSIZE_THRESHOLD = 16u;\n    UnorderedSet(unsigned int bucket_size = 1u)\n     : _bucket_count(ceilpow2(max(bucket_size, 1u))), _mask(_bucket_count - 1),\n        _data_count(0u), _buckets(new bucket[_bucket_count + 1]){\n        _buckets[_bucket_count - 1]._last = true, _buckets[_bucket_count]._end = true;\n    }\n    UnorderedSet(const UnorderedSet& another)\n        : _bucket_count(another._bucket_count), _mask(another._mask), _data_count(another._data_count){\n        _buckets = new bucket[_bucket_count + 1u];\n        for(unsigned int i = 0u; i <= _bucket_count; ++i){\n            _buckets[i] = another._buckets[i];\n        }\n    }\n    UnorderedSet(UnorderedSet&& another)\n        : _bucket_count(move(another._bucket_count)), _mask(move(another._mask)),\n            _data_count(move(another._data_count)), _buckets(another._buckets){\n        another._buckets = nullptr;\n    }\n    UnorderedSet& operator=(const UnorderedSet& another){\n        delete[] _buckets;\n        _bucket_count = another._bucket_count;\n        _mask = another._mask;\n        _data_count = another._data_count;\n        _buckets = new bucket[_bucket_count + 1u];\n        for(unsigned int i = 0u; i <= _bucket_count; ++i){\n            _buckets[i] = another._buckets[i];\n        }\n        return *this;\n    }\n    UnorderedSet& operator=(UnorderedSet&& another){\n        delete[] _buckets;\n        _bucket_count = move(another._bucket_count);\n        _mask = move(another._mask);\n        _data_count = move(another._data_count);\n        _buckets = another._buckets;\n        another._buckets = nullptr;\n        return *this;\n    }\n    ~UnorderedSet(){ delete[] _buckets; }\n    friend ostream& operator<< (ostream& os, UnorderedSet& ust) noexcept {\n        for(_Key& val : ust) os << val << \" \";\n        return os;\n    }\n    void clear(){\n        UnorderedSet new_unordered_set(1u);\n        swap(*this, new_unordered_set);\n    }\n    size_t size() const noexcept { return _data_count; }\n    size_t bucket_count() const noexcept { return _bucket_count; }\n    bool empty() const noexcept { return (_data_count == 0); }\n    iterator begin() const noexcept {\n        return _buckets->empty() ? iterator(increment(_buckets)) : iterator(_buckets);\n    }\n    iterator end() const noexcept { return iterator(_buckets + _bucket_count); }\n    iterator find(const _Key& key) const { return iterator(_find(key)); }\n    size_t count(const _Key& key) const { return (_find(key) != _buckets + _bucket_count); }\n    iterator insert(const _Key& key){ return iterator(find_insert(key)); }\n    iterator insert(_Key&& key){ return iterator(find_insert(move(key))); }\n    iterator erase(const _Key& key){ return iterator(erase_key(key)); }\n    iterator erase(const iterator& itr){ return iterator(erase_itr(itr.bucket_ptr)); }\n    void simple_erase(const _Key& key){ erase_key(key, false); }\n    void simple_erase(const iterator& itr){ erase_itr(itr.bucket_ptr, false); }\n \n    // DEBUG 用\n    short int maximum_distance() const noexcept {\n        short int ret = -1;\n        for(bucket *cur = _buckets; !cur->_end; ++cur){\n            ret = max(ret, cur->_dist);\n        }\n        return ret;\n    }\n};\n \ntemplate<class _Key, class _Hash, bool DOWNSIZE>\nclass UnorderedSetIterator {\nprivate:\n    friend UnorderedSet<_Key, _Hash, DOWNSIZE>;\n    typename UnorderedSet<_Key, _Hash, DOWNSIZE>::bucket *bucket_ptr;\n    using iterator_category = forward_iterator_tag;\n    using value_type = _Key;\n    using difference_type = ptrdiff_t;\n    using pointer = _Key*;\n    using reference = _Key&;\n \nprivate:\n    UnorderedSetIterator(typename UnorderedSet<_Key, _Hash, DOWNSIZE>::bucket *_bucket_ptr)\n        noexcept : bucket_ptr(_bucket_ptr){}\npublic:\n    UnorderedSetIterator() noexcept : bucket_ptr(){}\n    UnorderedSetIterator(const UnorderedSetIterator& itr) noexcept : bucket_ptr(itr.bucket_ptr){}\n    UnorderedSetIterator& operator=(const UnorderedSetIterator& itr)\n        & noexcept { return bucket_ptr = itr.bucket_ptr, *this; }\n    UnorderedSetIterator& operator=(const UnorderedSetIterator&& itr)\n        & noexcept { return bucket_ptr = itr.bucket_ptr, *this; }\n    reference operator*() const noexcept { return bucket_ptr->_key; }\n    pointer operator->() const noexcept { return &(bucket_ptr->_key); }\n    UnorderedSetIterator& operator++() noexcept {\n        return bucket_ptr = UnorderedSet<_Key, _Hash, DOWNSIZE>::increment(bucket_ptr), *this;\n    }\n    UnorderedSetIterator operator++(int) const noexcept {\n        return UnorderedSetIterator(UnorderedSet<_Key, _Hash, DOWNSIZE>::increment(this->bucket_ptr));\n    }\n    bool operator==(const UnorderedSetIterator& itr) const noexcept { return !(*this != itr); };\n    bool operator!=(const UnorderedSetIterator& itr) const noexcept { return bucket_ptr != itr.bucket_ptr; }\n};\n \ntemplate<class _Key, class _Tp, class _Hash, bool DOWNSIZE> class UnorderedMapIterator;\n \ntemplate<class _Key, class _Tp, class _Hash = hash<_Key>, bool DOWNSIZE = false>\nclass UnorderedMap\n{\nprivate:\n    using iterator = UnorderedMapIterator<_Key, _Tp, _Hash, DOWNSIZE>;\n    using value_type = _Tp;\n    using data_type = pair<_Key, _Tp>;\n    using aligned_pointer = typename aligned_storage<sizeof(value_type), alignof(value_type)>::type;\n    friend UnorderedMapIterator<_Key, _Tp, _Hash, DOWNSIZE>;\n    struct bucket {\n        _Key _key;\n        short int _dist;\n        bool _last, _end;\n        aligned_pointer _value_ptr;\n        bucket() noexcept : _dist(-1), _last(false), _end(false){}\n        bucket& operator=(const bucket& another) noexcept {\n            _key = another._key, _dist = another._dist, _last = another._last, _end = another._end;\n            if(!another.empty()){\n                new(&_value_ptr) value_type(*reinterpret_cast<const value_type*>(&another._value_ptr));\n            }\n            return *this;\n        }\n        ~bucket(){ if(!empty()) _delete(); }\n        inline void clear() noexcept { _dist = -1; }\n        inline void _delete(){ _dist = -1, value_ptr()->~value_type(); }\n        inline bool empty() const noexcept { return (_dist == -1); }\n        inline value_type& value() noexcept {\n            return *reinterpret_cast<value_type*>(&_value_ptr);\n        }\n        inline value_type* value_ptr() noexcept {\n            return reinterpret_cast<value_type*>(&_value_ptr);\n        }\n        inline void new_value(value_type&& value){\n            new(&_value_ptr) value_type(move(value));\n        }\n    };\n    inline static unsigned int ceilpow2(unsigned int u) noexcept {\n        --u, u |= u >> 1, u |= u >> 2, u |= u >> 4, u |= u >> 8;\n        return (u | (u >> 16)) + 1;\n    }\n    inline static bucket *increment(bucket *cur) noexcept {\n        for(++cur; !cur->_end; ++cur){\n            if(!cur->empty()) break;\n        }\n        return cur;\n    }\n    inline bucket *next_bucket(bucket *cur) const noexcept {\n        return cur->_last ? _buckets : cur + 1;\n    }\n    inline unsigned int make_hash(const _Key& key) const noexcept {\n        return _Hash()(key);\n    }\n    inline float load_rate() const noexcept {\n        return (float)_data_count / _bucket_count;\n    }\n    bucket *insert(bucket *cur, _Key&& key, short int dist, value_type&& value){\n        bucket *ret = cur;\n        bool flag = false;\n        while(true){\n            if(cur->empty()){\n                cur->_key = move(key), cur->_dist = dist, cur->new_value(move(value));\n                if(!flag) ret = cur, flag = true;\n                break;\n            }else if(dist > cur->_dist){\n                swap(key, cur->_key), swap(dist, cur->_dist), swap(value, cur->value());\n                if(!flag) ret = cur, flag = true;\n            }\n            ++dist;\n            cur = next_bucket(cur);\n        }\n        return ret;\n    }\n    template<class Key>\n    bucket *_find(Key&& key, bool push = false){\n        unsigned int hash = make_hash(key);\n        bucket *cur = _buckets + (hash & _mask);\n        short int dist = 0;\n        while(dist <= cur->_dist){\n            if(key == cur->_key) return cur;\n            ++dist, cur = next_bucket(cur);\n        }\n        if(!push) return _buckets + _bucket_count;\n        ++_data_count;\n        if(rehash_check()){\n            cur = _buckets + (hash & _mask), dist = 0;\n        }\n        value_type new_value = value_type();\n        _Key new_key = forward<Key>(key);\n        return insert(cur, move(new_key), dist, move(new_value));\n    }\n    template<class Data>\n    bucket *find_insert(Data&& data){\n        const _Key& key = data.first;\n        unsigned int hash = make_hash(key);\n        bucket *cur = _buckets + (hash & _mask);\n        short int dist = 0;\n        while(dist <= cur->_dist){\n            if(key == cur->_key) return cur;\n            ++dist, cur = next_bucket(cur);\n        }\n        ++_data_count;\n        if(rehash_check()){\n            cur = _buckets + (hash & _mask), dist = 0;\n        }\n        data_type new_data = forward<Data>(data);\n        return insert(cur, move(new_data.first), dist, move(new_data.second));\n    }\n    bucket *backward_shift(bucket *cur, bool next_ret){\n        bucket *next = next_bucket(cur), *ret = cur;\n        if(next->_dist < 1) return next_ret ? increment(cur) : cur;\n        do {\n            cur->_key = next->_key, cur->_dist = next->_dist - 1;\n            cur->new_value(move(next->value()));\n            cur = next, next = next_bucket(cur);\n        }while(next->_dist >= 1);\n        cur->clear();\n        return ret;\n    }\n    bucket *erase_impl(bucket *cur, bool next_ret){\n        assert(static_cast<size_t>(cur - _buckets) != _bucket_count);\n        cur->_delete();\n        --_data_count;\n        return backward_shift(cur, next_ret);\n    }\n    bucket *erase_itr(bucket *cur, bool next_ret = true){\n        const _Key& key = cur->_key;\n        return erase_impl(rehash_check() ? _find(key) : cur, next_ret);\n    }\n    bucket *erase_key(const _Key& key, bool next_ret = true){\n        rehash_check();\n        return erase_impl(_find(key), next_ret);\n    }\n    bool rehash_check(){\n        if(load_rate() >= MAX_LOAD_RATE){\n            rehash(_bucket_count * 2u);\n            return true;\n        }else if(DOWNSIZE){\n            if(load_rate() <= MIN_LOAD_RATE && _bucket_count >= DOWNSIZE_THRESHOLD){\n                rehash(_bucket_count / 2u);\n                return true;\n            }\n        }\n        return false;\n    }\n    void move_data(bucket *cur){\n        insert(_buckets + (make_hash(cur->_key) & _mask), move(cur->_key), 0, move(cur->value()));\n    }\n    void rehash(unsigned int new_bucket_count){\n        UnorderedMap new_unordered_map(new_bucket_count);\n        new_unordered_map._data_count = _data_count;\n        for(bucket *cur = _buckets; !cur->_end; ++cur){\n            if(!cur->empty()){\n                new_unordered_map.move_data(cur);\n            }\n        }\n        swap(*this, new_unordered_map);\n    }\n    friend void swap(UnorderedMap& ump1, UnorderedMap& ump2){\n        swap(ump1._bucket_count, ump2._bucket_count);\n        swap(ump1._mask, ump2._mask);\n        swap(ump1._data_count, ump2._data_count);\n        swap(ump1._buckets, ump2._buckets);\n    }\n \nprivate:\n    unsigned int _bucket_count, _mask, _data_count;\n    bucket *_buckets;\npublic:\n    const float MAX_LOAD_RATE = 0.5f;\n    const float MIN_LOAD_RATE = 0.1f;\n    const unsigned int DOWNSIZE_THRESHOLD = 16u;\n    UnorderedMap(unsigned int bucket_size = 1u)\n     : _bucket_count(ceilpow2(max(bucket_size, 1u))), _mask(_bucket_count - 1),\n        _data_count(0u), _buckets(new bucket[_bucket_count + 1]){\n        _buckets[_bucket_count - 1]._last = true, _buckets[_bucket_count]._end = true;\n    }\n    UnorderedMap(const UnorderedMap& another)\n        : _bucket_count(another._bucket_count), _mask(another._mask), _data_count(another._data_count){\n        _buckets = new bucket[_bucket_count + 1u];\n        for(unsigned int i = 0u; i <= _bucket_count; ++i){\n            _buckets[i] = another._buckets[i];\n        }\n    }\n    UnorderedMap(UnorderedMap&& another)\n        : _bucket_count(move(another._bucket_count)), _mask(move(another._mask)),\n            _data_count(move(another._data_count)), _buckets(another._buckets){\n        another._buckets = nullptr;\n    }\n    UnorderedMap& operator=(const UnorderedMap& another){\n        delete[] _buckets;\n        _bucket_count = another._bucket_count;\n        _mask = another._mask;\n        _data_count = another._data_count;\n        _buckets = new bucket[_bucket_count + 1u];\n        for(unsigned int i = 0u; i <= _bucket_count; ++i){\n            _buckets[i] = another._buckets[i];\n        }\n        return *this;\n    }\n    UnorderedMap& operator=(UnorderedMap&& another){\n        delete[] _buckets;\n        _bucket_count = move(another._bucket_count);\n        _mask = move(another._mask);\n        _data_count = move(another._data_count);\n        _buckets = another._buckets;\n        another._buckets = nullptr;\n        return *this;\n    }\n    ~UnorderedMap(){ delete[] _buckets; }\n    friend ostream& operator<< (ostream& os, UnorderedMap& ump) noexcept {\n        for(auto val : ump) os << '{' << val.first << ',' << val.second << \"} \";\n        return os;\n    }\n    _Tp& operator[](const _Key& key){ return _find(key, true)->value(); }\n    _Tp& operator[](_Key&& key){ return _find(move(key), true)->value(); }\n    const _Tp& at(const _Key& key){\n        bucket *res = _find(key);\n        if(res == _buckets + _bucket_count) __throw_out_of_range(__N(\"Unordered_Map::at\"));\n        return res->value();\n    }\n    void clear(){\n        UnorderedMap new_unordered_map(1u);\n        swap(*this, new_unordered_map);\n    }\n    size_t size() const noexcept { return _data_count; }\n    size_t bucket_count() const noexcept { return _bucket_count; }\n    bool empty() const noexcept { return (_data_count == 0); }\n    iterator begin() const noexcept { return _buckets->empty() ? iterator(increment(_buckets)) : iterator(_buckets); }\n    iterator end() const noexcept { return iterator(_buckets + _bucket_count); }\n    iterator find(const _Key& key){ return iterator(_find(key)); }\n    iterator insert(const data_type& data){ return iterator(find_insert(data)); }\n    iterator insert(data_type&& data){ return iterator(find_insert(move(data))); }\n    iterator erase(const _Key& key){ return iterator(erase_key(key)); }\n    iterator erase(const iterator& itr){ return iterator(erase_itr(itr.bucket_ptr)); }\n    void simple_erase(const _Key& key){ erase_key(key, false); }\n    void simple_erase(const iterator& itr){ erase_itr(itr.bucket_ptr, false); }\n \n    // DEBUG 用\n    short int maximum_distance() const noexcept {\n        short int ret = -1;\n        for(bucket *cur = _buckets; !cur->_end; ++cur){\n            ret = max(ret, cur->_dist);\n        }\n        return ret;\n    }\n};\n \ntemplate<class _Key, class _Tp, class _Hash, bool DOWNSIZE>\nclass UnorderedMapIterator {\nprivate:\n    friend UnorderedMap<_Key, _Tp, _Hash, DOWNSIZE>;\n    typename UnorderedMap<_Key, _Tp, _Hash, DOWNSIZE>::bucket *bucket_ptr;\n    using iterator_category = forward_iterator_tag;\n    using value_type = pair<const _Key, _Tp>;\n    using difference_type = ptrdiff_t;\n    using reference = pair<const _Key&, _Tp&>;\n \nprivate:\n    UnorderedMapIterator(typename UnorderedMap<_Key, _Tp, _Hash, DOWNSIZE>::bucket *_bucket_ptr)\n        noexcept : bucket_ptr(_bucket_ptr){}\npublic:\n    UnorderedMapIterator() noexcept : bucket_ptr(){}\n    UnorderedMapIterator(const UnorderedMapIterator& itr) noexcept : bucket_ptr(itr.bucket_ptr){}\n    UnorderedMapIterator& operator=(const UnorderedMapIterator& itr)\n        & noexcept { return bucket_ptr = itr.bucket_ptr, *this; }\n    UnorderedMapIterator& operator=(const UnorderedMapIterator&& itr)\n        & noexcept { return bucket_ptr = itr.bucket_ptr, *this; }\n    reference operator*() const noexcept { return {bucket_ptr->_key, bucket_ptr->value()}; }\n    UnorderedMapIterator& operator++() noexcept {\n        return bucket_ptr = UnorderedMap<_Key, _Tp, _Hash, DOWNSIZE>::increment(bucket_ptr), *this;\n    }\n    UnorderedMapIterator operator++(int) const noexcept {\n        return UnorderedMapIterator(UnorderedMap<_Key, _Tp, _Hash, DOWNSIZE>::increment(this->bucket_ptr));\n    }\n    bool operator==(const UnorderedMapIterator& itr) const noexcept { return !(*this != itr); };\n    bool operator!=(const UnorderedMapIterator& itr) const noexcept { return bucket_ptr != itr.bucket_ptr; }\n};\n \n// 多重辺は無いと仮定する\nclass BSTNode {\npublic:\n    struct murmur_hash32 {\n        unsigned int operator()(int p) const {\n            const unsigned int m = 0x5bd1e995; p *= m;\n            unsigned int h = (p^(p>>24))*m;\n            return h = (h^(h>>13))*m, (h^(h>>15));\n        }\n    };\n    const int from, to;\n    int sz;\n    bool subtree_edge, subofftree_edge, exact_level;\n    BSTNode *left, *right, *par;\n    UnorderedSet<int, murmur_hash32, true> adjacent;\n    BSTNode(const int _ver) noexcept :\n        from(_ver), to(_ver), sz(0), subtree_edge(false), subofftree_edge(false),\n            exact_level(false), left(nullptr), right(nullptr), par(nullptr){}\n    BSTNode(const int _from, const int _to, const bool _flag) noexcept :\n        from(_from), to(_to), sz(0), subtree_edge(false), subofftree_edge(false),\n            exact_level((from < to) && _flag), left(nullptr), right(nullptr), par(nullptr){}\n    inline bool IsRoot() const noexcept { return !par; }\n    inline bool IsVertex() const noexcept { return (from == to); }\n    inline void eval() noexcept {\n        if(IsVertex()) sz = 1, subtree_edge = false, subofftree_edge = !adjacent.empty();\n        else sz = 0, subtree_edge = exact_level, subofftree_edge = false;\n        if(left){\n            sz += left->sz, subtree_edge |= left->subtree_edge, subofftree_edge |= left->subofftree_edge;\n        }\n        if(right){\n            sz += right->sz, subtree_edge |= right->subtree_edge, subofftree_edge |= right->subofftree_edge;\n        }\n    }\n    inline void subtree_edge_eval(){\n        subtree_edge = exact_level;\n        if(left) subtree_edge |= left->subtree_edge;\n        if(right) subtree_edge |= right->subtree_edge;\n    }\n    inline void subofftree_edge_eval(){\n        subofftree_edge = !adjacent.empty();\n        if(left) subofftree_edge |= left->subofftree_edge;\n        if(right) subofftree_edge |= right->subofftree_edge;\n    }\n    inline bool subofftree_check(){\n        return !adjacent.empty() ||\n                (left ? left->subofftree_edge : false) || (right ? right->subofftree_edge : false);\n    }\n    inline bool offtree_check(){\n        return adjacent.empty() ||\n                (left ? left->subofftree_edge : false) || (right ? right->subofftree_edge : false);\n    }\n    void rotate(const bool right_) noexcept {\n        BSTNode *p = par, *g = p->par;\n        if(right_){\n            if((p->left = right)) right->par = p;\n            right = p, p->par = this;\n        }else{\n            if((p->right = left)) left->par = p;\n            left = p, p->par = this;\n        }\n        p->eval(), eval();\n        if(!(par = g)) return;\n        if(g->left == p) g->left = this;\n        if(g->right == p) g->right = this;\n        g->eval();\n    }\n};\n \nBSTNode *splay(BSTNode *u) noexcept {\n    if(!u) return nullptr;\n    while(!(u->IsRoot())){\n        BSTNode *p = u->par, *gp = p->par;\n        if(p->IsRoot()){ // zig\n            u->rotate((u == p->left));\n        }else{\n            bool flag = (u == p->left);\n            if((u == p->left) == (p == gp->left)){ // zig-zig\n                p->rotate(flag), u->rotate(flag);\n            }else{ // zig-zag\n                u->rotate(flag), u->rotate(!flag);\n            }\n        }\n    }\n    return u;\n}\n \nBSTNode *join(BSTNode *root1, BSTNode *root2) noexcept {\n    if(!root1 || !root2) return root1 ? root1 : root2;\n    BSTNode *cur = nullptr, *nx = root1;\n    do{ cur = nx, nx = cur->right; }while(nx);\n    BSTNode *ver = splay(cur);\n    ver->right = root2, ver->eval(), root2->par = ver;\n    return ver;\n}\n \nclass EulerTourTree {\npublic:\n    struct murmur_hash64 {\n        unsigned long long operator()(unsigned long long p) const {\n            const unsigned long long m = 0xc6a4a7935bd1e995; p *= m;\n            unsigned long long h = (p^(p>>47))*m;\n            return h = (h^(h>>47))*m, (h^(h>>47));\n        }\n    };\n    inline static unsigned long long pair_to_ll(const int u, const int v){\n        return ((unsigned long long)(u) << 32) | v;\n    }\n    BSTNode** vertex_set;\n    UnorderedMap<unsigned long long, pair<BSTNode*, BSTNode*>, murmur_hash64> edge_set;\nprivate:\n    BSTNode *reroot(BSTNode *ver) noexcept {\n        BSTNode *res = splay(ver)->left;\n        if(!res) return ver;\n        ver->left = nullptr, ver->eval();\n        while(ver->right) ver = ver->right;\n        splay(ver), ver->right = res, ver->eval(), res->par = ver;\n        return ver;\n    }\n    void link(BSTNode *ver1, BSTNode *ver2, const bool flag) noexcept {\n        BSTNode *e1 = new BSTNode(ver1->from, ver2->from, flag);\n        BSTNode *e2 = new BSTNode(ver2->from, ver1->from, flag);\n        edge_set[pair_to_ll(ver1->from, ver2->from)] = {e1, e2};\n        join(join(reroot(ver1), e1), join(reroot(ver2), e2));\n    }\n    void cut(BSTNode *edge1, BSTNode *edge2) noexcept {\n        splay(edge1), splay(edge2);\n        BSTNode *p = edge1->par;\n        bool _right = (edge1 == edge2->right);\n        if(p != edge2){\n            _right = (p == edge2->right);\n            p->par = nullptr, edge1->rotate((edge1 == p->left));\n        }\n        if(edge1->left) edge1->left->par = nullptr;\n        if(edge1->right) edge1->right->par = nullptr;\n        if(_right){\n            if(edge2->left) edge2->left->par = nullptr;\n            join(edge2->left, edge1->right);\n        }else{\n            if(edge2->right) edge2->right->par = nullptr;\n            join(edge1->left, edge2->right);\n        }\n        // delete edge1; delete edge2;\n    }\n    bool connected(BSTNode *ver1, BSTNode *ver2) noexcept {\n        splay(ver1), splay(ver2);\n        return ver1->par;\n    }\n    int component_size(BSTNode *ver) noexcept { return splay(ver)->sz; }\npublic:\n    int V;\n    EulerTourTree(){}\n    // ~EulerTourTree(){\n    //     for(auto it : edge_set){\n    //         delete (it.second).first;\n    //         delete (it.second).second;\n    //     }\n    //     for(int i = 0; i < V; ++i) delete vertex_set[i];\n    //     delete[] vertex_set;\n    // }\n    void resize(const int node_size) noexcept {\n        V = node_size, vertex_set = new BSTNode*[V];\n        for(int i = 0; i < V; i++) vertex_set[i] = new BSTNode(i);\n    }\n    void reroot(const int node_id) noexcept { reroot(vertex_set[node_id]); }\n    void link(int node1_id, int node2_id, bool flag=true) noexcept {\n        if(node1_id > node2_id) swap(node1_id, node2_id);\n        link(vertex_set[node1_id], vertex_set[node2_id], flag);\n    }\n    void cut(int node1_id, int node2_id){\n        if(node1_id > node2_id) swap(node1_id, node2_id);\n        auto it = edge_set.find(pair_to_ll(node1_id, node2_id));\n        assert(it != edge_set.end());\n        BSTNode *edge1 = ((*it).second).first, *edge2 = ((*it).second).second;\n        edge_set.simple_erase(it);\n        cut(edge1, edge2);\n    }\n    bool connected(const int node1_id, const int node2_id) noexcept {\n        if(node1_id == node2_id) return true;\n        return connected(vertex_set[node1_id], vertex_set[node2_id]);\n    }\n    int component_size(int node_id) noexcept { return component_size(vertex_set[node_id]); }\n    void check_dfs(const BSTNode* cur) const noexcept {\n        if(cur->left) check_dfs(cur->left);\n        cout << \"{\" << (cur->from) << \",\" << (cur->to) << \"} \";\n        if(cur->right) check_dfs(cur->right);\n    }\n};\n \nclass DynamicConnectivity {\nprivate:\n    BSTNode *level_up_dfs(BSTNode *cur, const int layer) noexcept {\n        if(cur->exact_level){\n            splay(cur)->exact_level = false, cur->subtree_edge_eval();\n            detect_layer[EulerTourTree::pair_to_ll(cur->from, cur->to)]++;\n            et[layer+1].link(cur->from, cur->to);\n            return cur;\n        }\n        if(cur->left && cur->left->subtree_edge) return level_up_dfs(cur->left, layer);\n        if(cur->right && cur->right->subtree_edge) return level_up_dfs(cur->right, layer);\n        return nullptr;\n    }\n    BSTNode *search_edge_dfs\n        (BSTNode *cur, const int layer, const int another, bool& flag, pair<int, int>& rep_edge) noexcept {\n        if(!cur->adjacent.empty()){\n            bool state = et[layer+1].vertex_set[cur->from]->adjacent.empty();\n            for(auto it = cur->adjacent.begin(); it != cur->adjacent.end();){\n                pair<int, int> e = {min(cur->from, *it), max(cur->from, *it)};\n                BSTNode *correspond = et[layer].vertex_set[*it];\n                if(et[layer].connected(another, *it)){\n                    flag = true, rep_edge = e;\n                    cur->adjacent.simple_erase(it), correspond->adjacent.simple_erase(cur->from);\n                    if(!correspond->subofftree_check()){\n                        splay(correspond)->subofftree_edge_eval();\n                    }\n                    break;\n                }else{\n                    if(!et[layer+1].vertex_set[*it]->subofftree_check()){\n                        splay(et[layer+1].vertex_set[*it])->subofftree_edge = true;\n                    }\n                    et[layer+1].vertex_set[cur->from]->adjacent.insert(*it);\n                    et[layer+1].vertex_set[*it]->adjacent.insert(cur->from);\n                    detect_layer[EulerTourTree::pair_to_ll(e.first, e.second)]++;\n                    it = cur->adjacent.erase(it);\n                    correspond->adjacent.simple_erase(cur->from);\n                    if(!correspond->subofftree_check()){\n                        splay(correspond)->subofftree_edge_eval();\n                    }\n                }\n            }\n            if(state && !et[layer+1].vertex_set[cur->from]->offtree_check()){\n                splay(et[layer+1].vertex_set[cur->from])->subofftree_edge = true;\n            }\n            splay(cur)->subofftree_edge_eval();\n            return cur;\n        }\n        if(cur->left && cur->left->subofftree_edge){\n            return search_edge_dfs(cur->left, layer, another, flag, rep_edge);\n        }\n        if(cur->right && cur->right->subofftree_edge){\n            return search_edge_dfs(cur->right, layer, another, flag, rep_edge);\n        }\n        return nullptr;\n    }\n    bool replace(const int from, const int to, const int layer) noexcept {\n        if(layer < 0) return true;\n        int u, v;\n        if(et[layer].component_size(from) <= et[layer].component_size(to)) u = from, v = to;\n        else u = to, v = from;\n        BSTNode *ver = splay(et[layer].vertex_set[u]);\n        while(ver->subtree_edge) ver = level_up_dfs(ver, layer);\n        pair<int, int> rep_edge = {-1, -1};\n        bool flag = false;\n        while(ver->subofftree_edge){\n            ver = search_edge_dfs(ver, layer, v, flag, rep_edge);\n            if(flag) break;\n        }\n        if(flag){\n            et[layer].link(rep_edge.first, rep_edge.second);\n            for(int i = 0; i < layer; i++) et[i].link(rep_edge.first, rep_edge.second, false);\n            return false;\n        }else return replace(from, to, layer-1);\n    }\npublic:\n    const int V, layer_count;\n    EulerTourTree* et;\n    UnorderedMap<unsigned long long, int, EulerTourTree::murmur_hash64> detect_layer;\n    DynamicConnectivity(int node_size) noexcept : V(node_size), layer_count(ceil(log2(V))+1){\n        et = new EulerTourTree[layer_count];\n        for(int i = 0; i < layer_count; i++) et[i].resize(V);\n    }\n    // ~DynamicConnectivity(){\n    //     delete[] et;\n    // }\n    bool link(int node1_id, int node2_id) noexcept {\n        if(node1_id > node2_id) swap(node1_id, node2_id);\n        detect_layer[EulerTourTree::pair_to_ll(node1_id, node2_id)] = 0;\n        if(et[0].connected(node1_id, node2_id)){\n            BSTNode *ver1 = et[0].vertex_set[node1_id], *ver2 = et[0].vertex_set[node2_id];\n            splay(ver1)->subofftree_edge = true, ver1->adjacent.insert(node2_id);\n            splay(ver2)->subofftree_edge = true, ver2->adjacent.insert(node1_id);\n            return false;\n        }else{\n            et[0].link(node1_id, node2_id);\n            return true;\n        }\n    }\n    bool cut(int node1_id, int node2_id) noexcept {\n        if(node1_id > node2_id) swap(node1_id, node2_id);\n        auto it = detect_layer.find(EulerTourTree::pair_to_ll(node1_id, node2_id));\n        assert(it != detect_layer.end());\n        int layer = (*it).second;\n        detect_layer.simple_erase(it);\n        auto& st = et[layer].vertex_set[node1_id]->adjacent;\n        if(st.find(node2_id) == st.end()){\n            for(int i = 0; i <= layer; i++) et[i].cut(node1_id, node2_id);\n            return replace(node1_id, node2_id, layer);\n        }else{\n            et[layer].vertex_set[node1_id]->adjacent.simple_erase(node2_id);\n            if(!et[layer].vertex_set[node1_id]->subofftree_check()){\n                splay(et[layer].vertex_set[node1_id])->subofftree_edge_eval();\n            }\n            et[layer].vertex_set[node2_id]->adjacent.simple_erase(node1_id);\n            if(!et[layer].vertex_set[node2_id]->subofftree_check()){\n                splay(et[layer].vertex_set[node2_id])->subofftree_edge_eval();\n            }\n            return false;\n        }\n    }\n    bool connected(const int node1_id, const int node2_id) noexcept {\n        return et[0].connected(node1_id, node2_id);\n    }\n};\n\nvector<int>a;\nvector<int> calc(pii e_min,vector<vector<int> > &g,set<int> st,DynamicConnectivity &dc){\n    vector<int> res;\n    res.push_back(e_min.first);\n    if(st.size()==1){\n        return res;\n    }\n    int id = e_min.second;\n    vector<int> v;\n    st.erase(id);\n    for(auto x:g[id]){\n        if(st.count(x)==1){\n            dc.cut(id,x);\n            v.push_back(x);\n        }\n    }\n    random_shuffle(v.begin(),v.end());\n    vector<vector<int> > ss;\n    for(auto x:v){\n        if(st.count(x)==0)continue;\n        set<int> p;\n        for(auto y:st){\n            if(dc.connected(x,y)){\n                p.insert(y);\n            }\n        }\n        for(auto y:p){\n            st.erase(y);\n        }\n        ss.push_back(calc(MP(a[x],x),g,p,dc));\n    }\n    priority_queue<pair<int,pii > > pp;\n    int m = ss.size();\n    rep(i,m){\n        pp.push(MP(ss[i][0],MP(i,0)));\n    }\n    while(!pp.empty()){\n        auto x = pp.top();\n        pp.pop();\n        res.push_back(x.first);\n        if(ss[x.second.first].size()!=x.second.second+1){\n            pp.push(MP(ss[x.second.first][x.second.second+1],MP(x.second.first,x.second.second+1)));\n        }\n    }\n    return res;\n}\n\nint main(){\n    int n;\n    cin >> n;\n    a.resize(n);\n    \n    rep(i,n){\n        cin >> a[i];\n    }\n    DynamicConnectivity dc(n);\n    vector<vector<int> > g(n);\n    UnionFind uf(n);\n    rep(i,n){\n        for(int j=i+1;j<n;j++){\n            if(gcd(a[i],a[j])!=1){\n                g[i].push_back(j);\n                g[j].push_back(i);\n                dc.link(i,j);\n                uf.unite(i,j);\n            }\n        }\n    }\n    vector<pair<int,int> > p(n,MP(inf,inf));\n    vector<set<int> > st(n);\n    rep(i,n){\n        p[uf.find(i)] = min(MP(a[i],i),p[uf.find(i)]);\n        st[uf.find(i)].insert(i);\n    }\n    vector<bool> used(n);\n    vector<vector<int> > res;\n    rep(i,n){\n        if(!used[uf.find(i)]){\n            int k = uf.find(i);\n            used[k] = 1;\n            auto ss = p[k];\n            res.push_back(calc(ss,g,st[k],dc));\n        }\n    }\n    priority_queue<pair<int,pii > > pp;\n    int m = res.size();\n    rep(i,m){\n        pp.push(MP(res[i][0],MP(i,0)));\n    }\n    vector<int> ans;\n    while(!pp.empty()){\n        auto x = pp.top();\n        pp.pop();\n        ans.push_back(x.first);\n        if(res[x.second.first].size()!=x.second.second+1){\n            pp.push(MP(res[x.second.first][x.second.second+1],MP(x.second.first,x.second.second+1)));\n        }\n    }\n    for(auto x:ans){\n        cout << x << \" \";\n    }\n    cout << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iomanip>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define all(x) (x).begin(),(x).end()\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n \ntemplate<class T> inline bool chmax(T &a, T b){\n    if(a<b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T> inline bool chmin(T &a, T b){\n    if(a>b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<typename T>\nT gcd(T a, T b)\n{\n    return b ? gcd(b, a % b) : a;\n}\n\ntemplate<typename T>\nT lcm(T a,T b)\n{\n    return  a / gcd(a,b) * b;\n}\nclass UnionFind {\nprivate:\n    int sz;\n    vector<int> par, size_;\npublic:\n    UnionFind(){}\n    UnionFind(int node_size) : sz(node_size), par(sz), size_(sz, 1){\n        iota(par.begin(), par.end(), 0);\n    }\n    int find(int x){\n        if(par[x] == x) return x;\n        else return par[x] = find(par[x]);\n    }\n    void unite(int x,int y){\n        x = find(x), y = find(y);\n        if(x == y) return;\n        if(size_[x] < size_[y]) swap(x,y);\n        par[y] = x;\n        size_[x] += size_[y];\n    }\n    int size(int x){\n        x = find(x);\n        return size_[x];\n    }\n    bool same(int x,int y){\n        return find(x) == find(y);\n    }\n};\ntemplate<class _Key, class _Hash, bool DOWNSIZE> class UnorderedSetIterator;\n \ntemplate<class _Key, class _Hash = hash<_Key>, bool DOWNSIZE = false>\nclass UnorderedSet\n{\nprivate:\n    using iterator = UnorderedSetIterator<_Key, _Hash, DOWNSIZE>;\n    friend UnorderedSetIterator<_Key, _Hash, DOWNSIZE>;\n    struct bucket {\n        _Key _key;\n        short int _dist;\n        bool _last, _end;\n        bucket() noexcept : _dist(-1), _last(false), _end(false){}\n        bucket& operator=(const bucket& another) = default;\n        ~bucket(){ if(!empty()) _key.~_Key(); }\n        inline void clear() noexcept { _dist = -1; }\n        inline void _delete(){ _dist = -1, _key.~_Key(); }\n        inline bool empty() const noexcept { return (_dist == -1); }\n    };\n    inline static unsigned int ceilpow2(unsigned int u) noexcept {\n        --u, u |= u >> 1, u |= u >> 2, u |= u >> 4, u |= u >> 8;\n        return (u | (u >> 16)) + 1;\n    }\n    inline static bucket *increment(bucket *cur) noexcept {\n        for(++cur; !cur->_end; ++cur){\n            if(!cur->empty()) break;\n        }\n        return cur;\n    }\n    inline bucket *next_bucket(bucket *cur) const noexcept {\n        return cur->_last ? _buckets : cur + 1;\n    }\n    inline unsigned int make_hash(const _Key& key) const noexcept {\n        return _Hash()(key);\n    }\n    inline float load_rate() const noexcept {\n        return (float)_data_count / _bucket_count;\n    }\n    bucket *insert(bucket *cur, short int dist, _Key&& key){\n        bucket *ret = cur;\n        bool flag = false;\n        while(true){\n            if(cur->empty()){\n                cur->_key = move(key), cur->_dist = dist;\n                if(!flag) ret = cur, flag = true;\n                break;\n            }else if(dist > cur->_dist){\n                swap(key, cur->_key), swap(dist, cur->_dist);\n                if(!flag) ret = cur, flag = true;\n            }\n            ++dist;\n            cur = next_bucket(cur);\n        }\n        return ret;\n    }\n    bucket *_find(const _Key& key) const {\n        bucket *cur = _buckets + (make_hash(key) & _mask);\n        int dist = 0;\n        while(dist <= cur->_dist){\n            if(key == cur->_key) return cur;\n            ++dist, cur = next_bucket(cur);\n        }\n        return _buckets + _bucket_count;\n    }\n    template<class Key>\n    bucket *find_insert(Key&& key){\n        unsigned int hash = make_hash(key);\n        bucket *cur = _buckets + (hash & _mask);\n        int dist = 0;\n        while(dist <= cur->_dist){\n            if(key == cur->_key) return cur;\n            ++dist, cur = next_bucket(cur);\n        }\n        ++_data_count;\n        if(rehash_check()){\n            cur = _buckets + (hash & _mask), dist = 0;\n        }\n        _Key new_key = forward<Key>(key);\n        return insert(cur, dist, move(new_key));\n    }\n    bucket *backward_shift(bucket *cur, bool next_ret){\n        bucket *next = next_bucket(cur), *ret = cur;\n        if(next->_dist < 1) return next_ret ? increment(cur) : cur;\n        do {\n            cur->_key = next->_key, cur->_dist = next->_dist - 1;\n            cur = next, next = next_bucket(cur);\n        }while(next->_dist >= 1);\n        cur->clear();\n        return ret;\n    }\n    bucket *erase_impl(bucket *cur, bool next_ret){\n        assert(static_cast<size_t>(cur - _buckets) != _bucket_count);\n        cur->_delete();\n        --_data_count;\n        return backward_shift(cur, next_ret);\n    }\n    bucket *erase_itr(bucket *cur, bool next_ret = true){\n        const _Key key = cur->_key;\n        return erase_impl(rehash_check() ? _find(key) : cur, next_ret);\n    }\n    bucket *erase_key(const _Key& key, bool next_ret = true){\n        rehash_check();\n        return erase_impl(_find(key), next_ret);\n    }\n    bool rehash_check(){\n        if(load_rate() >= MAX_LOAD_RATE){\n            rehash(_bucket_count * 2u);\n            return true;\n        }else if(DOWNSIZE){\n            if(load_rate() <= MIN_LOAD_RATE && _bucket_count >= DOWNSIZE_THRESHOLD){\n                rehash(_bucket_count / 2u);\n                return true;\n            }\n        }\n        return false;\n    }\n    void move_data(bucket *cur){\n        insert(_buckets + (make_hash(cur->_key) & _mask), 0, move(cur->_key));\n    }\n    void rehash(unsigned int new_bucket_count){\n        UnorderedSet new_unordered_set(new_bucket_count);\n        new_unordered_set._data_count = _data_count;\n        for(bucket *cur = _buckets; !cur->_end; ++cur){\n            if(!cur->empty()){\n                new_unordered_set.move_data(cur);\n            }\n        }\n        swap(*this, new_unordered_set);\n    }\n    friend void swap(UnorderedSet& ust1, UnorderedSet& ust2){\n        swap(ust1._bucket_count, ust2._bucket_count);\n        swap(ust1._mask, ust2._mask);\n        swap(ust1._data_count, ust2._data_count);\n        swap(ust1._buckets, ust2._buckets);\n    }\n \nprivate:\n    unsigned int _bucket_count, _mask, _data_count;\n    bucket *_buckets;\npublic:\n    const float MAX_LOAD_RATE = 0.5f;\n    const float MIN_LOAD_RATE = 0.1f;\n    const unsigned int DOWNSIZE_THRESHOLD = 16u;\n    UnorderedSet(unsigned int bucket_size = 1u)\n     : _bucket_count(ceilpow2(max(bucket_size, 1u))), _mask(_bucket_count - 1),\n        _data_count(0u), _buckets(new bucket[_bucket_count + 1]){\n        _buckets[_bucket_count - 1]._last = true, _buckets[_bucket_count]._end = true;\n    }\n    UnorderedSet(const UnorderedSet& another)\n        : _bucket_count(another._bucket_count), _mask(another._mask), _data_count(another._data_count){\n        _buckets = new bucket[_bucket_count + 1u];\n        for(unsigned int i = 0u; i <= _bucket_count; ++i){\n            _buckets[i] = another._buckets[i];\n        }\n    }\n    UnorderedSet(UnorderedSet&& another)\n        : _bucket_count(move(another._bucket_count)), _mask(move(another._mask)),\n            _data_count(move(another._data_count)), _buckets(another._buckets){\n        another._buckets = nullptr;\n    }\n    UnorderedSet& operator=(const UnorderedSet& another){\n        delete[] _buckets;\n        _bucket_count = another._bucket_count;\n        _mask = another._mask;\n        _data_count = another._data_count;\n        _buckets = new bucket[_bucket_count + 1u];\n        for(unsigned int i = 0u; i <= _bucket_count; ++i){\n            _buckets[i] = another._buckets[i];\n        }\n        return *this;\n    }\n    UnorderedSet& operator=(UnorderedSet&& another){\n        delete[] _buckets;\n        _bucket_count = move(another._bucket_count);\n        _mask = move(another._mask);\n        _data_count = move(another._data_count);\n        _buckets = another._buckets;\n        another._buckets = nullptr;\n        return *this;\n    }\n    ~UnorderedSet(){ delete[] _buckets; }\n    friend ostream& operator<< (ostream& os, UnorderedSet& ust) noexcept {\n        for(_Key& val : ust) os << val << \" \";\n        return os;\n    }\n    void clear(){\n        UnorderedSet new_unordered_set(1u);\n        swap(*this, new_unordered_set);\n    }\n    size_t size() const noexcept { return _data_count; }\n    size_t bucket_count() const noexcept { return _bucket_count; }\n    bool empty() const noexcept { return (_data_count == 0); }\n    iterator begin() const noexcept {\n        return _buckets->empty() ? iterator(increment(_buckets)) : iterator(_buckets);\n    }\n    iterator end() const noexcept { return iterator(_buckets + _bucket_count); }\n    iterator find(const _Key& key) const { return iterator(_find(key)); }\n    size_t count(const _Key& key) const { return (_find(key) != _buckets + _bucket_count); }\n    iterator insert(const _Key& key){ return iterator(find_insert(key)); }\n    iterator insert(_Key&& key){ return iterator(find_insert(move(key))); }\n    iterator erase(const _Key& key){ return iterator(erase_key(key)); }\n    iterator erase(const iterator& itr){ return iterator(erase_itr(itr.bucket_ptr)); }\n    void simple_erase(const _Key& key){ erase_key(key, false); }\n    void simple_erase(const iterator& itr){ erase_itr(itr.bucket_ptr, false); }\n \n    // DEBUG 用\n    short int maximum_distance() const noexcept {\n        short int ret = -1;\n        for(bucket *cur = _buckets; !cur->_end; ++cur){\n            ret = max(ret, cur->_dist);\n        }\n        return ret;\n    }\n};\n \ntemplate<class _Key, class _Hash, bool DOWNSIZE>\nclass UnorderedSetIterator {\nprivate:\n    friend UnorderedSet<_Key, _Hash, DOWNSIZE>;\n    typename UnorderedSet<_Key, _Hash, DOWNSIZE>::bucket *bucket_ptr;\n    using iterator_category = forward_iterator_tag;\n    using value_type = _Key;\n    using difference_type = ptrdiff_t;\n    using pointer = _Key*;\n    using reference = _Key&;\n \nprivate:\n    UnorderedSetIterator(typename UnorderedSet<_Key, _Hash, DOWNSIZE>::bucket *_bucket_ptr)\n        noexcept : bucket_ptr(_bucket_ptr){}\npublic:\n    UnorderedSetIterator() noexcept : bucket_ptr(){}\n    UnorderedSetIterator(const UnorderedSetIterator& itr) noexcept : bucket_ptr(itr.bucket_ptr){}\n    UnorderedSetIterator& operator=(const UnorderedSetIterator& itr)\n        & noexcept { return bucket_ptr = itr.bucket_ptr, *this; }\n    UnorderedSetIterator& operator=(const UnorderedSetIterator&& itr)\n        & noexcept { return bucket_ptr = itr.bucket_ptr, *this; }\n    reference operator*() const noexcept { return bucket_ptr->_key; }\n    pointer operator->() const noexcept { return &(bucket_ptr->_key); }\n    UnorderedSetIterator& operator++() noexcept {\n        return bucket_ptr = UnorderedSet<_Key, _Hash, DOWNSIZE>::increment(bucket_ptr), *this;\n    }\n    UnorderedSetIterator operator++(int) const noexcept {\n        return UnorderedSetIterator(UnorderedSet<_Key, _Hash, DOWNSIZE>::increment(this->bucket_ptr));\n    }\n    bool operator==(const UnorderedSetIterator& itr) const noexcept { return !(*this != itr); };\n    bool operator!=(const UnorderedSetIterator& itr) const noexcept { return bucket_ptr != itr.bucket_ptr; }\n};\n \ntemplate<class _Key, class _Tp, class _Hash, bool DOWNSIZE> class UnorderedMapIterator;\n \ntemplate<class _Key, class _Tp, class _Hash = hash<_Key>, bool DOWNSIZE = false>\nclass UnorderedMap\n{\nprivate:\n    using iterator = UnorderedMapIterator<_Key, _Tp, _Hash, DOWNSIZE>;\n    using value_type = _Tp;\n    using data_type = pair<_Key, _Tp>;\n    using aligned_pointer = typename aligned_storage<sizeof(value_type), alignof(value_type)>::type;\n    friend UnorderedMapIterator<_Key, _Tp, _Hash, DOWNSIZE>;\n    struct bucket {\n        _Key _key;\n        short int _dist;\n        bool _last, _end;\n        aligned_pointer _value_ptr;\n        bucket() noexcept : _dist(-1), _last(false), _end(false){}\n        bucket& operator=(const bucket& another) noexcept {\n            _key = another._key, _dist = another._dist, _last = another._last, _end = another._end;\n            if(!another.empty()){\n                new(&_value_ptr) value_type(*reinterpret_cast<const value_type*>(&another._value_ptr));\n            }\n            return *this;\n        }\n        ~bucket(){ if(!empty()) _delete(); }\n        inline void clear() noexcept { _dist = -1; }\n        inline void _delete(){ _dist = -1, value_ptr()->~value_type(); }\n        inline bool empty() const noexcept { return (_dist == -1); }\n        inline value_type& value() noexcept {\n            return *reinterpret_cast<value_type*>(&_value_ptr);\n        }\n        inline value_type* value_ptr() noexcept {\n            return reinterpret_cast<value_type*>(&_value_ptr);\n        }\n        inline void new_value(value_type&& value){\n            new(&_value_ptr) value_type(move(value));\n        }\n    };\n    inline static unsigned int ceilpow2(unsigned int u) noexcept {\n        --u, u |= u >> 1, u |= u >> 2, u |= u >> 4, u |= u >> 8;\n        return (u | (u >> 16)) + 1;\n    }\n    inline static bucket *increment(bucket *cur) noexcept {\n        for(++cur; !cur->_end; ++cur){\n            if(!cur->empty()) break;\n        }\n        return cur;\n    }\n    inline bucket *next_bucket(bucket *cur) const noexcept {\n        return cur->_last ? _buckets : cur + 1;\n    }\n    inline unsigned int make_hash(const _Key& key) const noexcept {\n        return _Hash()(key);\n    }\n    inline float load_rate() const noexcept {\n        return (float)_data_count / _bucket_count;\n    }\n    bucket *insert(bucket *cur, _Key&& key, short int dist, value_type&& value){\n        bucket *ret = cur;\n        bool flag = false;\n        while(true){\n            if(cur->empty()){\n                cur->_key = move(key), cur->_dist = dist, cur->new_value(move(value));\n                if(!flag) ret = cur, flag = true;\n                break;\n            }else if(dist > cur->_dist){\n                swap(key, cur->_key), swap(dist, cur->_dist), swap(value, cur->value());\n                if(!flag) ret = cur, flag = true;\n            }\n            ++dist;\n            cur = next_bucket(cur);\n        }\n        return ret;\n    }\n    template<class Key>\n    bucket *_find(Key&& key, bool push = false){\n        unsigned int hash = make_hash(key);\n        bucket *cur = _buckets + (hash & _mask);\n        short int dist = 0;\n        while(dist <= cur->_dist){\n            if(key == cur->_key) return cur;\n            ++dist, cur = next_bucket(cur);\n        }\n        if(!push) return _buckets + _bucket_count;\n        ++_data_count;\n        if(rehash_check()){\n            cur = _buckets + (hash & _mask), dist = 0;\n        }\n        value_type new_value = value_type();\n        _Key new_key = forward<Key>(key);\n        return insert(cur, move(new_key), dist, move(new_value));\n    }\n    template<class Data>\n    bucket *find_insert(Data&& data){\n        const _Key& key = data.first;\n        unsigned int hash = make_hash(key);\n        bucket *cur = _buckets + (hash & _mask);\n        short int dist = 0;\n        while(dist <= cur->_dist){\n            if(key == cur->_key) return cur;\n            ++dist, cur = next_bucket(cur);\n        }\n        ++_data_count;\n        if(rehash_check()){\n            cur = _buckets + (hash & _mask), dist = 0;\n        }\n        data_type new_data = forward<Data>(data);\n        return insert(cur, move(new_data.first), dist, move(new_data.second));\n    }\n    bucket *backward_shift(bucket *cur, bool next_ret){\n        bucket *next = next_bucket(cur), *ret = cur;\n        if(next->_dist < 1) return next_ret ? increment(cur) : cur;\n        do {\n            cur->_key = next->_key, cur->_dist = next->_dist - 1;\n            cur->new_value(move(next->value()));\n            cur = next, next = next_bucket(cur);\n        }while(next->_dist >= 1);\n        cur->clear();\n        return ret;\n    }\n    bucket *erase_impl(bucket *cur, bool next_ret){\n        assert(static_cast<size_t>(cur - _buckets) != _bucket_count);\n        cur->_delete();\n        --_data_count;\n        return backward_shift(cur, next_ret);\n    }\n    bucket *erase_itr(bucket *cur, bool next_ret = true){\n        const _Key& key = cur->_key;\n        return erase_impl(rehash_check() ? _find(key) : cur, next_ret);\n    }\n    bucket *erase_key(const _Key& key, bool next_ret = true){\n        rehash_check();\n        return erase_impl(_find(key), next_ret);\n    }\n    bool rehash_check(){\n        if(load_rate() >= MAX_LOAD_RATE){\n            rehash(_bucket_count * 2u);\n            return true;\n        }else if(DOWNSIZE){\n            if(load_rate() <= MIN_LOAD_RATE && _bucket_count >= DOWNSIZE_THRESHOLD){\n                rehash(_bucket_count / 2u);\n                return true;\n            }\n        }\n        return false;\n    }\n    void move_data(bucket *cur){\n        insert(_buckets + (make_hash(cur->_key) & _mask), move(cur->_key), 0, move(cur->value()));\n    }\n    void rehash(unsigned int new_bucket_count){\n        UnorderedMap new_unordered_map(new_bucket_count);\n        new_unordered_map._data_count = _data_count;\n        for(bucket *cur = _buckets; !cur->_end; ++cur){\n            if(!cur->empty()){\n                new_unordered_map.move_data(cur);\n            }\n        }\n        swap(*this, new_unordered_map);\n    }\n    friend void swap(UnorderedMap& ump1, UnorderedMap& ump2){\n        swap(ump1._bucket_count, ump2._bucket_count);\n        swap(ump1._mask, ump2._mask);\n        swap(ump1._data_count, ump2._data_count);\n        swap(ump1._buckets, ump2._buckets);\n    }\n \nprivate:\n    unsigned int _bucket_count, _mask, _data_count;\n    bucket *_buckets;\npublic:\n    const float MAX_LOAD_RATE = 0.5f;\n    const float MIN_LOAD_RATE = 0.1f;\n    const unsigned int DOWNSIZE_THRESHOLD = 16u;\n    UnorderedMap(unsigned int bucket_size = 1u)\n     : _bucket_count(ceilpow2(max(bucket_size, 1u))), _mask(_bucket_count - 1),\n        _data_count(0u), _buckets(new bucket[_bucket_count + 1]){\n        _buckets[_bucket_count - 1]._last = true, _buckets[_bucket_count]._end = true;\n    }\n    UnorderedMap(const UnorderedMap& another)\n        : _bucket_count(another._bucket_count), _mask(another._mask), _data_count(another._data_count){\n        _buckets = new bucket[_bucket_count + 1u];\n        for(unsigned int i = 0u; i <= _bucket_count; ++i){\n            _buckets[i] = another._buckets[i];\n        }\n    }\n    UnorderedMap(UnorderedMap&& another)\n        : _bucket_count(move(another._bucket_count)), _mask(move(another._mask)),\n            _data_count(move(another._data_count)), _buckets(another._buckets){\n        another._buckets = nullptr;\n    }\n    UnorderedMap& operator=(const UnorderedMap& another){\n        delete[] _buckets;\n        _bucket_count = another._bucket_count;\n        _mask = another._mask;\n        _data_count = another._data_count;\n        _buckets = new bucket[_bucket_count + 1u];\n        for(unsigned int i = 0u; i <= _bucket_count; ++i){\n            _buckets[i] = another._buckets[i];\n        }\n        return *this;\n    }\n    UnorderedMap& operator=(UnorderedMap&& another){\n        delete[] _buckets;\n        _bucket_count = move(another._bucket_count);\n        _mask = move(another._mask);\n        _data_count = move(another._data_count);\n        _buckets = another._buckets;\n        another._buckets = nullptr;\n        return *this;\n    }\n    ~UnorderedMap(){ delete[] _buckets; }\n    friend ostream& operator<< (ostream& os, UnorderedMap& ump) noexcept {\n        for(auto val : ump) os << '{' << val.first << ',' << val.second << \"} \";\n        return os;\n    }\n    _Tp& operator[](const _Key& key){ return _find(key, true)->value(); }\n    _Tp& operator[](_Key&& key){ return _find(move(key), true)->value(); }\n    const _Tp& at(const _Key& key){\n        bucket *res = _find(key);\n        if(res == _buckets + _bucket_count) __throw_out_of_range(__N(\"Unordered_Map::at\"));\n        return res->value();\n    }\n    void clear(){\n        UnorderedMap new_unordered_map(1u);\n        swap(*this, new_unordered_map);\n    }\n    size_t size() const noexcept { return _data_count; }\n    size_t bucket_count() const noexcept { return _bucket_count; }\n    bool empty() const noexcept { return (_data_count == 0); }\n    iterator begin() const noexcept { return _buckets->empty() ? iterator(increment(_buckets)) : iterator(_buckets); }\n    iterator end() const noexcept { return iterator(_buckets + _bucket_count); }\n    iterator find(const _Key& key){ return iterator(_find(key)); }\n    iterator insert(const data_type& data){ return iterator(find_insert(data)); }\n    iterator insert(data_type&& data){ return iterator(find_insert(move(data))); }\n    iterator erase(const _Key& key){ return iterator(erase_key(key)); }\n    iterator erase(const iterator& itr){ return iterator(erase_itr(itr.bucket_ptr)); }\n    void simple_erase(const _Key& key){ erase_key(key, false); }\n    void simple_erase(const iterator& itr){ erase_itr(itr.bucket_ptr, false); }\n \n    // DEBUG 用\n    short int maximum_distance() const noexcept {\n        short int ret = -1;\n        for(bucket *cur = _buckets; !cur->_end; ++cur){\n            ret = max(ret, cur->_dist);\n        }\n        return ret;\n    }\n};\n \ntemplate<class _Key, class _Tp, class _Hash, bool DOWNSIZE>\nclass UnorderedMapIterator {\nprivate:\n    friend UnorderedMap<_Key, _Tp, _Hash, DOWNSIZE>;\n    typename UnorderedMap<_Key, _Tp, _Hash, DOWNSIZE>::bucket *bucket_ptr;\n    using iterator_category = forward_iterator_tag;\n    using value_type = pair<const _Key, _Tp>;\n    using difference_type = ptrdiff_t;\n    using reference = pair<const _Key&, _Tp&>;\n \nprivate:\n    UnorderedMapIterator(typename UnorderedMap<_Key, _Tp, _Hash, DOWNSIZE>::bucket *_bucket_ptr)\n        noexcept : bucket_ptr(_bucket_ptr){}\npublic:\n    UnorderedMapIterator() noexcept : bucket_ptr(){}\n    UnorderedMapIterator(const UnorderedMapIterator& itr) noexcept : bucket_ptr(itr.bucket_ptr){}\n    UnorderedMapIterator& operator=(const UnorderedMapIterator& itr)\n        & noexcept { return bucket_ptr = itr.bucket_ptr, *this; }\n    UnorderedMapIterator& operator=(const UnorderedMapIterator&& itr)\n        & noexcept { return bucket_ptr = itr.bucket_ptr, *this; }\n    reference operator*() const noexcept { return {bucket_ptr->_key, bucket_ptr->value()}; }\n    UnorderedMapIterator& operator++() noexcept {\n        return bucket_ptr = UnorderedMap<_Key, _Tp, _Hash, DOWNSIZE>::increment(bucket_ptr), *this;\n    }\n    UnorderedMapIterator operator++(int) const noexcept {\n        return UnorderedMapIterator(UnorderedMap<_Key, _Tp, _Hash, DOWNSIZE>::increment(this->bucket_ptr));\n    }\n    bool operator==(const UnorderedMapIterator& itr) const noexcept { return !(*this != itr); };\n    bool operator!=(const UnorderedMapIterator& itr) const noexcept { return bucket_ptr != itr.bucket_ptr; }\n};\n \n// 多重辺は無いと仮定する\nclass BSTNode {\npublic:\n    struct murmur_hash32 {\n        unsigned int operator()(int p) const {\n            const unsigned int m = 0x5bd1e995; p *= m;\n            unsigned int h = (p^(p>>24))*m;\n            return h = (h^(h>>13))*m, (h^(h>>15));\n        }\n    };\n    const int from, to;\n    int sz;\n    bool subtree_edge, subofftree_edge, exact_level;\n    BSTNode *left, *right, *par;\n    UnorderedSet<int, murmur_hash32, true> adjacent;\n    BSTNode(const int _ver) noexcept :\n        from(_ver), to(_ver), sz(0), subtree_edge(false), subofftree_edge(false),\n            exact_level(false), left(nullptr), right(nullptr), par(nullptr){}\n    BSTNode(const int _from, const int _to, const bool _flag) noexcept :\n        from(_from), to(_to), sz(0), subtree_edge(false), subofftree_edge(false),\n            exact_level((from < to) && _flag), left(nullptr), right(nullptr), par(nullptr){}\n    inline bool IsRoot() const noexcept { return !par; }\n    inline bool IsVertex() const noexcept { return (from == to); }\n    inline void eval() noexcept {\n        if(IsVertex()) sz = 1, subtree_edge = false, subofftree_edge = !adjacent.empty();\n        else sz = 0, subtree_edge = exact_level, subofftree_edge = false;\n        if(left){\n            sz += left->sz, subtree_edge |= left->subtree_edge, subofftree_edge |= left->subofftree_edge;\n        }\n        if(right){\n            sz += right->sz, subtree_edge |= right->subtree_edge, subofftree_edge |= right->subofftree_edge;\n        }\n    }\n    inline void subtree_edge_eval(){\n        subtree_edge = exact_level;\n        if(left) subtree_edge |= left->subtree_edge;\n        if(right) subtree_edge |= right->subtree_edge;\n    }\n    inline void subofftree_edge_eval(){\n        subofftree_edge = !adjacent.empty();\n        if(left) subofftree_edge |= left->subofftree_edge;\n        if(right) subofftree_edge |= right->subofftree_edge;\n    }\n    inline bool subofftree_check(){\n        return !adjacent.empty() ||\n                (left ? left->subofftree_edge : false) || (right ? right->subofftree_edge : false);\n    }\n    inline bool offtree_check(){\n        return adjacent.empty() ||\n                (left ? left->subofftree_edge : false) || (right ? right->subofftree_edge : false);\n    }\n    void rotate(const bool right_) noexcept {\n        BSTNode *p = par, *g = p->par;\n        if(right_){\n            if((p->left = right)) right->par = p;\n            right = p, p->par = this;\n        }else{\n            if((p->right = left)) left->par = p;\n            left = p, p->par = this;\n        }\n        p->eval(), eval();\n        if(!(par = g)) return;\n        if(g->left == p) g->left = this;\n        if(g->right == p) g->right = this;\n        g->eval();\n    }\n};\n \nBSTNode *splay(BSTNode *u) noexcept {\n    if(!u) return nullptr;\n    while(!(u->IsRoot())){\n        BSTNode *p = u->par, *gp = p->par;\n        if(p->IsRoot()){ // zig\n            u->rotate((u == p->left));\n        }else{\n            bool flag = (u == p->left);\n            if((u == p->left) == (p == gp->left)){ // zig-zig\n                p->rotate(flag), u->rotate(flag);\n            }else{ // zig-zag\n                u->rotate(flag), u->rotate(!flag);\n            }\n        }\n    }\n    return u;\n}\n \nBSTNode *join(BSTNode *root1, BSTNode *root2) noexcept {\n    if(!root1 || !root2) return root1 ? root1 : root2;\n    BSTNode *cur = nullptr, *nx = root1;\n    do{ cur = nx, nx = cur->right; }while(nx);\n    BSTNode *ver = splay(cur);\n    ver->right = root2, ver->eval(), root2->par = ver;\n    return ver;\n}\n \nclass EulerTourTree {\npublic:\n    struct murmur_hash64 {\n        unsigned long long operator()(unsigned long long p) const {\n            const unsigned long long m = 0xc6a4a7935bd1e995; p *= m;\n            unsigned long long h = (p^(p>>47))*m;\n            return h = (h^(h>>47))*m, (h^(h>>47));\n        }\n    };\n    inline static unsigned long long pair_to_ll(const int u, const int v){\n        return ((unsigned long long)(u) << 32) | v;\n    }\n    BSTNode** vertex_set;\n    UnorderedMap<unsigned long long, pair<BSTNode*, BSTNode*>, murmur_hash64> edge_set;\nprivate:\n    BSTNode *reroot(BSTNode *ver) noexcept {\n        BSTNode *res = splay(ver)->left;\n        if(!res) return ver;\n        ver->left = nullptr, ver->eval();\n        while(ver->right) ver = ver->right;\n        splay(ver), ver->right = res, ver->eval(), res->par = ver;\n        return ver;\n    }\n    void link(BSTNode *ver1, BSTNode *ver2, const bool flag) noexcept {\n        BSTNode *e1 = new BSTNode(ver1->from, ver2->from, flag);\n        BSTNode *e2 = new BSTNode(ver2->from, ver1->from, flag);\n        edge_set[pair_to_ll(ver1->from, ver2->from)] = {e1, e2};\n        join(join(reroot(ver1), e1), join(reroot(ver2), e2));\n    }\n    void cut(BSTNode *edge1, BSTNode *edge2) noexcept {\n        splay(edge1), splay(edge2);\n        BSTNode *p = edge1->par;\n        bool _right = (edge1 == edge2->right);\n        if(p != edge2){\n            _right = (p == edge2->right);\n            p->par = nullptr, edge1->rotate((edge1 == p->left));\n        }\n        if(edge1->left) edge1->left->par = nullptr;\n        if(edge1->right) edge1->right->par = nullptr;\n        if(_right){\n            if(edge2->left) edge2->left->par = nullptr;\n            join(edge2->left, edge1->right);\n        }else{\n            if(edge2->right) edge2->right->par = nullptr;\n            join(edge1->left, edge2->right);\n        }\n        // delete edge1; delete edge2;\n    }\n    bool connected(BSTNode *ver1, BSTNode *ver2) noexcept {\n        splay(ver1), splay(ver2);\n        return ver1->par;\n    }\n    int component_size(BSTNode *ver) noexcept { return splay(ver)->sz; }\npublic:\n    int V;\n    EulerTourTree(){}\n    // ~EulerTourTree(){\n    //     for(auto it : edge_set){\n    //         delete (it.second).first;\n    //         delete (it.second).second;\n    //     }\n    //     for(int i = 0; i < V; ++i) delete vertex_set[i];\n    //     delete[] vertex_set;\n    // }\n    void resize(const int node_size) noexcept {\n        V = node_size, vertex_set = new BSTNode*[V];\n        for(int i = 0; i < V; i++) vertex_set[i] = new BSTNode(i);\n    }\n    void reroot(const int node_id) noexcept { reroot(vertex_set[node_id]); }\n    void link(int node1_id, int node2_id, bool flag=true) noexcept {\n        if(node1_id > node2_id) swap(node1_id, node2_id);\n        link(vertex_set[node1_id], vertex_set[node2_id], flag);\n    }\n    void cut(int node1_id, int node2_id){\n        if(node1_id > node2_id) swap(node1_id, node2_id);\n        auto it = edge_set.find(pair_to_ll(node1_id, node2_id));\n        assert(it != edge_set.end());\n        BSTNode *edge1 = ((*it).second).first, *edge2 = ((*it).second).second;\n        edge_set.simple_erase(it);\n        cut(edge1, edge2);\n    }\n    bool connected(const int node1_id, const int node2_id) noexcept {\n        if(node1_id == node2_id) return true;\n        return connected(vertex_set[node1_id], vertex_set[node2_id]);\n    }\n    int component_size(int node_id) noexcept { return component_size(vertex_set[node_id]); }\n    void check_dfs(const BSTNode* cur) const noexcept {\n        if(cur->left) check_dfs(cur->left);\n        cout << \"{\" << (cur->from) << \",\" << (cur->to) << \"} \";\n        if(cur->right) check_dfs(cur->right);\n    }\n};\n \nclass DynamicConnectivity {\nprivate:\n    BSTNode *level_up_dfs(BSTNode *cur, const int layer) noexcept {\n        if(cur->exact_level){\n            splay(cur)->exact_level = false, cur->subtree_edge_eval();\n            detect_layer[EulerTourTree::pair_to_ll(cur->from, cur->to)]++;\n            et[layer+1].link(cur->from, cur->to);\n            return cur;\n        }\n        if(cur->left && cur->left->subtree_edge) return level_up_dfs(cur->left, layer);\n        if(cur->right && cur->right->subtree_edge) return level_up_dfs(cur->right, layer);\n        return nullptr;\n    }\n    BSTNode *search_edge_dfs\n        (BSTNode *cur, const int layer, const int another, bool& flag, pair<int, int>& rep_edge) noexcept {\n        if(!cur->adjacent.empty()){\n            bool state = et[layer+1].vertex_set[cur->from]->adjacent.empty();\n            for(auto it = cur->adjacent.begin(); it != cur->adjacent.end();){\n                pair<int, int> e = {min(cur->from, *it), max(cur->from, *it)};\n                BSTNode *correspond = et[layer].vertex_set[*it];\n                if(et[layer].connected(another, *it)){\n                    flag = true, rep_edge = e;\n                    cur->adjacent.simple_erase(it), correspond->adjacent.simple_erase(cur->from);\n                    if(!correspond->subofftree_check()){\n                        splay(correspond)->subofftree_edge_eval();\n                    }\n                    break;\n                }else{\n                    if(!et[layer+1].vertex_set[*it]->subofftree_check()){\n                        splay(et[layer+1].vertex_set[*it])->subofftree_edge = true;\n                    }\n                    et[layer+1].vertex_set[cur->from]->adjacent.insert(*it);\n                    et[layer+1].vertex_set[*it]->adjacent.insert(cur->from);\n                    detect_layer[EulerTourTree::pair_to_ll(e.first, e.second)]++;\n                    it = cur->adjacent.erase(it);\n                    correspond->adjacent.simple_erase(cur->from);\n                    if(!correspond->subofftree_check()){\n                        splay(correspond)->subofftree_edge_eval();\n                    }\n                }\n            }\n            if(state && !et[layer+1].vertex_set[cur->from]->offtree_check()){\n                splay(et[layer+1].vertex_set[cur->from])->subofftree_edge = true;\n            }\n            splay(cur)->subofftree_edge_eval();\n            return cur;\n        }\n        if(cur->left && cur->left->subofftree_edge){\n            return search_edge_dfs(cur->left, layer, another, flag, rep_edge);\n        }\n        if(cur->right && cur->right->subofftree_edge){\n            return search_edge_dfs(cur->right, layer, another, flag, rep_edge);\n        }\n        return nullptr;\n    }\n    bool replace(const int from, const int to, const int layer) noexcept {\n        if(layer < 0) return true;\n        int u, v;\n        if(et[layer].component_size(from) <= et[layer].component_size(to)) u = from, v = to;\n        else u = to, v = from;\n        BSTNode *ver = splay(et[layer].vertex_set[u]);\n        while(ver->subtree_edge) ver = level_up_dfs(ver, layer);\n        pair<int, int> rep_edge = {-1, -1};\n        bool flag = false;\n        while(ver->subofftree_edge){\n            ver = search_edge_dfs(ver, layer, v, flag, rep_edge);\n            if(flag) break;\n        }\n        if(flag){\n            et[layer].link(rep_edge.first, rep_edge.second);\n            for(int i = 0; i < layer; i++) et[i].link(rep_edge.first, rep_edge.second, false);\n            return false;\n        }else return replace(from, to, layer-1);\n    }\npublic:\n    const int V, layer_count;\n    EulerTourTree* et;\n    UnorderedMap<unsigned long long, int, EulerTourTree::murmur_hash64> detect_layer;\n    DynamicConnectivity(int node_size) noexcept : V(node_size), layer_count(ceil(log2(V))+1){\n        et = new EulerTourTree[layer_count];\n        for(int i = 0; i < layer_count; i++) et[i].resize(V);\n    }\n    // ~DynamicConnectivity(){\n    //     delete[] et;\n    // }\n    bool link(int node1_id, int node2_id) noexcept {\n        if(node1_id > node2_id) swap(node1_id, node2_id);\n        detect_layer[EulerTourTree::pair_to_ll(node1_id, node2_id)] = 0;\n        if(et[0].connected(node1_id, node2_id)){\n            BSTNode *ver1 = et[0].vertex_set[node1_id], *ver2 = et[0].vertex_set[node2_id];\n            splay(ver1)->subofftree_edge = true, ver1->adjacent.insert(node2_id);\n            splay(ver2)->subofftree_edge = true, ver2->adjacent.insert(node1_id);\n            return false;\n        }else{\n            et[0].link(node1_id, node2_id);\n            return true;\n        }\n    }\n    bool cut(int node1_id, int node2_id) noexcept {\n        if(node1_id > node2_id) swap(node1_id, node2_id);\n        auto it = detect_layer.find(EulerTourTree::pair_to_ll(node1_id, node2_id));\n        assert(it != detect_layer.end());\n        int layer = (*it).second;\n        detect_layer.simple_erase(it);\n        auto& st = et[layer].vertex_set[node1_id]->adjacent;\n        if(st.find(node2_id) == st.end()){\n            for(int i = 0; i <= layer; i++) et[i].cut(node1_id, node2_id);\n            return replace(node1_id, node2_id, layer);\n        }else{\n            et[layer].vertex_set[node1_id]->adjacent.simple_erase(node2_id);\n            if(!et[layer].vertex_set[node1_id]->subofftree_check()){\n                splay(et[layer].vertex_set[node1_id])->subofftree_edge_eval();\n            }\n            et[layer].vertex_set[node2_id]->adjacent.simple_erase(node1_id);\n            if(!et[layer].vertex_set[node2_id]->subofftree_check()){\n                splay(et[layer].vertex_set[node2_id])->subofftree_edge_eval();\n            }\n            return false;\n        }\n    }\n    bool connected(const int node1_id, const int node2_id) noexcept {\n        return et[0].connected(node1_id, node2_id);\n    }\n};\n\nvector<int>a;\nvector<int> calc(pii e_min,vector<vector<int> > &g,set<int> st,DynamicConnectivity &dc){\n    vector<int> res;\n    res.push_back(e_min.first);\n    if(st.size()==1){\n        return res;\n    }\n    int id = e_min.second;\n    vector<int> v;\n    st.erase(id);\n    for(auto x:g[id]){\n        if(st.count(x)==1){\n            dc.cut(id,x);\n            v.push_back(x);\n        }\n    }\n    random_shuffle(v.begin(),v.end());\n    vector<vector<int> > ss;\n    for(auto x:v){\n        if(st.count(x)==0)continue;\n        set<int> p;\n        for(auto y:st){\n            if(dc.connected(x,y)){\n                p.insert(y);\n            }\n        }\n        for(auto y:p){\n            st.erase(y);\n        }\n        ss.push_back(calc(MP(a[x],x),g,p,dc));\n    }\n    priority_queue<pair<int,pii > > pp;\n    int m = ss.size();\n    rep(i,m){\n        pp.push(MP(ss[i][0],MP(i,0)));\n    }\n    while(!pp.empty()){\n        auto x = pp.top();\n        pp.pop();\n        res.push_back(x.first);\n        if(ss[x.second.first].size()!=x.second.second+1){\n            pp.push(MP(ss[x.second.first][x.second.second+1],MP(x.second.first,x.second.second+1)));\n        }\n    }\n    return res;\n}\n\nint main(){\n    int n;\n    cin >> n;\n    a.resize(n);\n    \n    rep(i,n){\n        cin >> a[i];\n    }\n    DynamicConnectivity dc(n);\n    vector<vector<int> > g(n);\n    UnionFind uf(n);\n    rep(i,n){\n        for(int j=i+1;j<n;j++){\n            if(gcd(a[i],a[j])!=1){\n                g[i].push_back(j);\n                g[j].push_back(i);\n                dc.link(i,j);\n                uf.unite(i,j);\n            }\n        }\n    }\n    vector<pair<int,int> > p(n,MP(inf,inf));\n    vector<set<int> > st(n);\n    rep(i,n){\n        p[uf.find(i)] = min(MP(a[i],i),p[uf.find(i)]);\n        st[uf.find(i)].insert(i);\n    }\n    vector<bool> used(n);\n    vector<vector<int> > res;\n    rep(i,n){\n        if(!used[uf.find(i)]){\n            int k = uf.find(i);\n            used[k] = 1;\n            auto ss = p[k];\n            res.push_back(calc(ss,g,st[k],dc));\n        }\n    }\n    priority_queue<pair<int,pii > > pp;\n    int m = res.size();\n    rep(i,m){\n        pp.push(MP(res[i][0],MP(i,0)));\n    }\n    vector<int> ans;\n    while(!pp.empty()){\n        auto x = pp.top();\n        pp.pop();\n        ans.push_back(x.first);\n        if(res[x.second.first].size()!=x.second.second+1){\n            pp.push(MP(res[x.second.first][x.second.second+1],MP(x.second.first,x.second.second+1)));\n        }\n    }\n    for(auto x:ans){\n        cout << x << \" \";\n    }\n    cout << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <memory.h>\n#include <math.h>\n#include <assert.h>\n#include <queue>\n#include <map>\n#include <set>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <functional>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <bitset>\n\nusing namespace std;\ntypedef pair<int, int> Pi;\ntypedef long long ll;\n#define Fi first\n#define Se second\n#define pb(x) push_back(x)\n#define sz(x) (int)x.size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define all(x) x.begin(), x.end()\ntypedef tuple<int, int, int> t3;\ntypedef pair<ll, ll> PL;\n\nint n, A[2020];\n\nvector <int> P[100010];\nvector <int> prlist;\nvector <int> IA[2020];\nset <int> S;\n\nint p[2020], v[2020];\nint Find(int x){\n\treturn p[x] == x ? x : p[x] = Find(p[x]);\n}\n\nint gc(int x, int y){\n\treturn y == 0 ? x : gc(y, x%y);\n}\n\nvoid solve(){\n//\tsrand(time(NULL));\n\tscanf(\"%d\", &n);\n//\tn = 2000;\n//\tfor(int i=1;i<=n;i++)A[i] = rand() % 100000000 + 1;\n\tfor(int i=1;i<=n;i++)scanf(\"%d\", A+i);\n\tfor(int i=1;i<=n;i++){\n\t\tint t = A[i];\n\t\tfor(int j=2;j*j<=t;j++){\n\t\t\tint f = 0;\n\t\t\twhile(t % j == 0){\n\t\t\t\tt /= j; f = 1;\n\t\t\t}\n\t\t\tif(f)S.insert(j);\n\t\t}\n\t\tif(t > 1)S.insert(t);\n\t}\n\tfor(auto it : S){\n\t\tprlist.pb(it);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tint t = A[i];\n\t\tvector <int> temp;\n\t\tfor(int j=2;j*j<=t;j++){\n\t\t\tint f = 0;\n\t\t\twhile(t % j == 0){\n\t\t\t\tt /= j; f = 1;\n\t\t\t}\n\t\t\tif(f)temp.pb(j);\n\t\t}\n\t\tif(t > 1)temp.pb(t);\n\t\tfor(auto e : temp){\n\t\t\tint a = (int)(lower_bound(all(prlist), e) - prlist.begin());\n\t\t\tP[a].pb(i);\n\t\t\tIA[i].pb(a);\n\t\t}\n\t}\n\tint vis[2020] = {}, ok[2020] = {};\n\tfor(int i=1;i<=n;i++)ok[i] = 1;\n\tvector <int> ans;\n\tfor(int u=1;u<=n;u++){\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tp[i] = i;\n\t\t\tif(ok[i])v[i] = A[i];\n\t\t\telse v[i] = 1e9;\n\t\t}\n\t\tfor(int i=0;i<sz(prlist);i++){\n\t\t\tfor(int j=1;j<sz(P[i]);j++){\n\t\t\t\tint x = P[i][j], y = P[i][j-1];\n\t\t\t\tif(Find(x) != Find(y)){\n\t\t\t\t\tif(v[Find(x)] > v[Find(y)])p[Find(x)] = Find(y);\n\t\t\t\t\telse p[Find(y)] = Find(x);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint mx = -1, mxv = -1;\n\t\tfor(int i=1;i<=n;i++)if(vis[i] == 0){\n\t\t\tif(Find(i) == i && v[i] < 1e9){\n\t\t\t\tif(mx < v[i])mx = v[i];\n\t\t\t}\n\t\t}\n\t\tans.pb(mx);\n\t\tfor(int i=1;i<=n;i++)if(A[i] == mx && ok[i] == 1)mxv = i;\n\t\tvis[mxv] = 1;\n\t\tfor(int e : IA[mxv]){\n\t\t\tP[e].erase(find(all(P[e]), mxv));\n\t\t}\n\t\tmemset(ok, 0, sizeof ok);\n\t\tint f = 0;\n\t\tfor(int i=1;i<=n;i++)if(vis[i] == 0){\n\t\t\tif(gc(A[mxv], A[i]) > 1){\n\t\t\t\tf = 1;\n\t\t\t\tok[i] = 1;\n\t\t\t}\n\t\t}\n\t\tif(f == 0){\n\t\t\tfor(int i=1;i<=n;i++)if(vis[i] == 0)ok[i] = 1;\n\t\t}\n\t}\n\tfor(int e : ans)printf(\"%d \", e); puts(\"\");}\n\nint main(){\n\tint Tc = 1; //scanf(\"%d\", &Tc);\n\tfor(int tc=1;tc<=Tc;tc++){\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//by yjz\n#include<bits/stdc++.h>\nusing namespace std;\n#define FF first\n#define SS second\n#define PB push_back\n#define MP make_pair\n#define bged(v) (v).begin(),(v).end()\n#define foreach(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\ntypedef long long ll;\nconst int Imx=2147483647;\nconst ll Lbig=2e18;\nconst int mod=1e9+7;\n//My i/o stream\nstruct fastio\n{\n\tchar s[100000];\n\tint it,len;\n\tfastio(){it=len=0;}\n\tinline char get()\n\t{\n\t\tif(it<len)return s[it++];it=0;\n\t\tlen=fread(s,1,100000,stdin);\n\t\tif(len==0)return EOF;else return s[it++];\n\t}\n\tbool notend()\n\t{\n\t\tchar c=get();\n\t\twhile(c==' '||c=='\\n')c=get();\n\t\tif(it>0)it--;\n\t\treturn c!=EOF;\n\t}\n}_buff;\n#define geti(x) x=getnum()\n#define getii(x,y) geti(x),geti(y)\n#define getiii(x,y,z) getii(x,y),geti(z)\n#define puti(x) putnum(x),putchar(' ')\n#define putii(x,y) puti(x),puti(y)\n#define putiii(x,y,z) putii(x,y),puti(z)\n#define putsi(x) putnum(x),putchar('\\n')\n#define putsii(x,y) puti(x),putsi(y)\n#define putsiii(x,y,z) putii(x,y),putsi(z)\ninline ll getnum()\n{\n\tll r=0;bool ng=0;char c;c=_buff.get();\n\twhile(c!='-'&&(c<'0'||c>'9'))c=_buff.get();\n\tif(c=='-')ng=1,c=_buff.get();\n\twhile(c>='0'&&c<='9')r=r*10+c-'0',c=_buff.get();\n\treturn ng?-r:r;\n}\ntemplate<class T> inline void putnum(T x)\n{\n\tif(x<0)putchar('-'),x=-x;\n\tregister short a[20]={},sz=0;\n\twhile(x)a[sz++]=x%10,x/=10;\n\tif(sz==0)putchar('0');\n\tfor(int i=sz-1;i>=0;i--)putchar('0'+a[i]);\n}\ninline char getreal(){char c=_buff.get();while(c==' '||c=='\\n')c=_buff.get();return c;}\nint n,a[2011],g[2011][2011];\nvector<int> facp[2011];\nvector<int> vp,v[20011];\nbool used[2011],hs[20011];\nbool vis[2011],visp[20011];\nvoid dfs(int x);\nvoid dfsp(int p)\n{\n\tvisp[p]=1;\n\tfor(int i=0;i<v[p].size();i++)\n\t{\n\t\tif(!vis[v[p][i]])dfs(v[p][i]);\n\t}\n}\nvoid dfs(int x)\n{\n\tvis[x]=1;\n\tif(used[x])return;\n\tfor(int i=0;i<facp[x].size();i++)\n\t{\n\t\tif(!visp[facp[x][i]])dfsp(facp[x][i]);\n\t}\n}\nvoid dfsgraph(int v)\n{\n\tdfs(v);\n}\nint tag[2011],mn[2011];\nint main()\n{\n\tgeti(n);\n\tfor(int i=1;i<=n;i++)geti(a[i]);\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=i;j<=n;j++)\n\t\t{\n\t\t\tg[i][j]=g[j][i]=__gcd(a[i],a[j]);\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint x=a[i];\n\t\tfor(int j=2;j*j<=x;j++)\n\t\t{\n\t\t\tif(x%j==0)\n\t\t\t{\n\t\t\t\tfacp[i].PB(j);\n\t\t\t\twhile(x%j==0)x/=j;\n\t\t\t\tvp.PB(j);\n\t\t\t}\n\t\t}\n\t\tif(x>1)facp[i].PB(x),vp.PB(x);\n\t}\n\tsort(vp.begin(),vp.end());\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=0;j<facp[i].size();j++)\n\t\t{\n\t\t\tfacp[i][j]=lower_bound(vp.begin(),vp.end(),facp[i][j])-vp.begin();\n\t\t\tv[facp[i][j]].PB(i);\n\t\t}\n\t}\n\tfor(int i=0;i<=n+1;i++)mn[i]=Imx;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tmemset(vis,0,sizeof(vis));\n\t\tmemset(visp,0,sizeof(visp));\n\t\tint cur=-1;\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tif(used[j])continue;\n\t\t\tif(mn[tag[j]+1]>=a[j])\n\t\t\t{\n\t\t\t\tif(!vis[j])\n\t\t\t\t{\n\t\t\t\t\tdfsgraph(j);\n\t\t\t\t\tcur=j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tassert(cur!=-1);\n\t\tfor(int j=1;j<=n;j++)if(g[cur][j]>1)tag[j]=i;\n\t\tused[cur]=1;\n\t\tputi(a[cur]);\n\t\tfor(int j=1;j<=i;j++)mn[j]=min(mn[j],a[cur]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define vi vector<int>\n#define pb push_back\nusing namespace std;\nint n,a[2010],x[2010][2010];\nbool p[2010];\ninline int gcd(int n,int m)\n{\n    return m?gcd(m,n%m):n;\n}\ninline vi orz(vi f,vi g)\n{\n    vi h;\n    int n=f.size(),m=g.size();\n    int i,j;\n    h.pb(f[0]);\n    for(i=1,j=0;i<n && j<m;)\n      if(f[i]>g[j])\n        h.pb(f[i++]);\n      else\n        h.pb(g[j++]);\n    for(;i<n;i++)\n      h.pb(f[i]);\n    for(;j<m;j++)\n      h.pb(g[j]);\n    return h;\n}\ninline vi dfs(int i)\n{\n    int j;\n    vi f;\n    f.pb(i);\n    p[i]=1;\n    for(j=1;j<=n;j++)\n      if(!p[j] && x[i][j])\n        f=orz(f,dfs(j));\n    return f;\n}\nint main()\n{\n\t//freopen(\".in\",\"r\",stdin);\n\t//freopen(\".out\",\"w\",stdout);\n\tint i,j;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;i++)\n\t  scanf(\"%d\",&a[i]);\n\tsort(a+1,a+n+1);\n\tfor(i=1;i<=n;i++)\n\t  for(j=1;j<=n;j++)\n\t    if(i!=j && gcd(a[i],a[j])>1)\n\t      x[i][j]=1;\n\tfor(i=1;i<=n;i++)\n\t  x[0][i]=1;\n\tvi f=dfs(0);\n    for(i=1;i<=n;i++)\n      printf(\"%d \",a[f[i]]);\n    printf(\"\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// =================================\n//   author: M_sea\n//   website: http://m-sea-blog.com/\n// =================================\n#include <algorithm>\n#include <iostream>\n#include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#include <queue>\n#define re register\nusing namespace std;\n\ninline int read() {\n    int X=0,w=1; char c=getchar();\n    while (c<'0'||c>'9') { if (c=='-') w=-1; c=getchar(); }\n    while (c>='0'&&c<='9') X=X*10+c-'0',c=getchar();\n    return X*w;\n}\n\nconst int N=2000+10;\n\nstruct Edge { int v,nxt; } e[N];\nint head[N];\n\ninline void addEdge(int u,int v) {\n    static int cnt=0;\n    e[++cnt]=(Edge){v,head[u]},head[u]=cnt;\n}\n\nint n;\nint a[N],vis[N],deg[N];\nint G[N][N];\n\ninline void dfs(int u) {\n    vis[u]=1;\n    for (re int i=1;i<=n;++i) {\n        if (vis[i]||!G[u][i]) continue;\n        ++deg[i],addEdge(u,i);\n        dfs(i);\n    }\n}\n\ninline void topsort() {\n    priority_queue<int> Q;\n    for (re int i=1;i<=n;++i)\n        if (!deg[i]) Q.push(i);\n    while (!Q.empty()) {\n        int u=Q.top(); Q.pop();\n        printf(\"%d \",a[u]);\n        for (re int i=head[u];i;i=e[i].nxt) Q.push(e[i].v);\n    }\n}\n\nint main() {\n    n=read();\n    for (re int i=1;i<=n;++i) a[i]=read();\n    sort(a+1,a+n+1);\n    for (re int i=1;i<=n;++i)\n        for (re int j=i+1;j<=n;++j) {\n            if (__gcd(a[i],a[j])==1) continue;\n            G[i][j]=G[j][i]=1;\n        }\n    for (re int i=1;i<=n;++i)\n        if (!vis[i]) dfs(i);\n    topsort();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define per(i,b,a) for(int i=b;i>=a;i--)\n#define For(i,a,b) for(int i=a;i<=b;i++)\n#define Forenska(it,c) for(register __typeof(c.begin()) it=c.begin();it!=c.end();it++)\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\n#define all(x) x.begin(),x.end()\n#define sqr(x) ((x)*(x))\n#define lowbit(x) ((x)&(-x))\n#define GREATER(x) x,vector<x>,greater<x>\nusing namespace std;\nint i,j;\ntypedef long long LL;\ntypedef pair<int,int> pii;\ntypedef pair<LL,LL> pLL;\ntypedef vector<int> vec;\ntypedef vector<LL> vecL;\ntypedef vector<pii> vecP;\ntypedef vector<pLL> vecPL;\ntypedef vector<string> vecS;\ntypedef vector<vec> mat;\ntypedef complex<double> point;\nconst long double PI=3.1415926535897932384626433832795028841971693993751058209749445923078164062862089;\nconst LL INFLL=0x3f3f3f3f3f3f3f3f;\nconst int INF=0x3f3f3f3f;\nconst long double EPS=1e-10;\nint read()\n{\n\tint x=0;\n\tchar ch=' ';\n\tbool flag=false;\n\twhile(!isdigit(ch))\n\t{\n\t\tif(ch=='-')flag=true;\n\t\tch=getchar();\n\t}\n\twhile(isdigit(ch))\n\t{\n\t\tx=(x<<3)+(x<<1)+ch-'0';\n\t\tch=getchar();\n\t}\n\treturn flag?-x:x;\n}\nint n;\nvec A;\nmat g1,g2;\nconst int MAX_N=2005;\nbool vis[MAX_N];\nint in[MAX_N];\nvoid dfs(int v)\n{\n\tif(vis[v])return;\n\tvis[v]=true;\n\trep(i,0,g1[v].size())\n\t{\n\t\tint to=g1[v][i];\n\t\tif(!vis[to])\n\t\t{\n\t\t\tg2[v].pb(to);\n\t\t\tin[to]++;\n\t\t\tdfs(to);\n\t\t}\n\t}\n}\nint main()\n{\n\tn=read();\n\tA.resize(n);\n\trep(i,0,n)A[i]=read();\n\tsort(all(A));\n\tA.resize(unique(all(A))-A.begin());\n\tn=A.size();\n\tg1.resize(n);\n\tg2.resize(n);\n\trep(i,0,n)\n\t{\n\t\trep(j,i+1,n)\n\t\t{\n\t\t\tif(__gcd(A[i],A[j])>1)\n\t\t\t{\n\t\t\t\tg1[i].pb(j);\n\t\t\t\tg1[j].pb(i);\n\t\t\t}\n\t\t}\n\t}\n\trep(i,0,n)sort(all(g1[i]));\n\trep(i,0,n)\n\t{\n\t\tdfs(i);\n\t}\n\tpriority_queue <int> q;\n\tvec ans;\n\tper(i,n-1,0)if(!in[i])q.push(i),ans.pb(i);\n\twhile(!q.empty())\n\t{\n\t\tint t=q.top();\n\t\tq.pop();\n\t\trep(i,0,g2[t].size())\n\t\t{\n\t\t\tint to=g2[t][i];\n\t\t\tin[to]--;\n\t\t\tif(!in[to])\n\t\t\t{\n\t\t\t\tq.push(to);\n\t\t\t\tans.pb(to);\n\t\t\t}\n\t\t}\n\t}\n\trep(i,0,ans.size())ans[i]=A[ans[i]];\n\trep(i,0,ans.size())\n\t{\n\t\trep(j,0,ans.size()-1)\n\t\t{\n\t\t\tif(ans[j]<ans[j+1] && __gcd(ans[j],ans[j+1])==1)swap(ans[j],ans[j+1]);\n\t\t}\n\t}\n\trep(i,0,ans.size()-1)cout<<ans[i]<<\" \";\n\tcout<<ans.back()<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h> \nusing namespace std;\n\nconst int maxn=2005;\nint gcd(int a,int b)\n{\n\treturn b==0?a:gcd(b,a%b);\n}\n\n\nint n,a[maxn];\nint vis[maxn];\nvector<int>g[maxn],gg[maxn];\nint rd[maxn];vector<int>ans;\npriority_queue<int>pq;\n\nvoid dfs(int x)\n{\n\tvis[x]=1;\n\tfor(int i=0;i<(int)g[x].size();i++)\n\t{\n\t\tint to=g[x][i];\n\t\tif(vis[to])continue;\n\t\tgg[x].push_back(to);\n\t\trd[to]++;\n\t\tdfs(to);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=1;j<=n;j++)\n\t\t{\n\t\t\tif(i==j)continue;\n\t\t\tif(gcd(a[i],a[j])!=1)\n\t\t\t{\n\t\t\t\tg[i].push_back(j);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(!vis[i])\n\t\t{\n\t\t\tdfs(i);\n\t\t}\n\t}\n\t\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(!rd[i])\n\t\t{\n\t\t\tpq.push(i);\n\t\t}\n\t}\n\t\n\twhile(!pq.empty())\n\t{\n\t\tint x=pq.top();pq.pop();\n\t\tans.push_back(a[x]);\n\t\tfor(int i=0;i<(int)gg[x].size();i++)\n\t\t{\n\t\t\tint to=gg[x][i];\n\t\t\trd[to]--;\n\t\t\tif(!rd[to])\n\t\t\t{\n\t\t\t\tpq.push(to);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i=0;i<(int)ans.size();i++)\n\t{\n\t\tprintf(\"%d \",ans[i]);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define per(i,b,a) for(int i=b;i>=a;i--)\n#define For(i,a,b) for(int i=a;i<=b;i++)\n#define Forenska(it,c) for(register __typeof(c.begin()) it=c.begin();it!=c.end();it++)\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\n#define all(x) x.begin(),x.end()\n#define sqr(x) ((x)*(x))\n#define lowbit(x) ((x)&(-x))\n#define GREATER(x) x,vector<x>,greater<x>\nusing namespace std;\nint i,j;\ntypedef long long LL;\ntypedef pair<int,int> pii;\ntypedef pair<LL,LL> pLL;\ntypedef vector<int> vec;\ntypedef vector<LL> vecL;\ntypedef vector<pii> vecP;\ntypedef vector<pLL> vecPL;\ntypedef vector<string> vecS;\ntypedef vector<vec> mat;\ntypedef complex<double> point;\nconst long double PI=3.1415926535897932384626433832795028841971693993751058209749445923078164062862089;\nconst LL INFLL=0x3f3f3f3f3f3f3f3f;\nconst int INF=0x3f3f3f3f;\nconst long double EPS=1e-10;\nint read()\n{\n\tint x=0;\n\tchar ch=' ';\n\tbool flag=false;\n\twhile(!isdigit(ch))\n\t{\n\t\tif(ch=='-')flag=true;\n\t\tch=getchar();\n\t}\n\twhile(isdigit(ch))\n\t{\n\t\tx=(x<<3)+(x<<1)+ch-'0';\n\t\tch=getchar();\n\t}\n\treturn flag?-x:x;\n}\nint n;\nvec A;\nmat g1,g2;\nconst int MAX_N=2005;\nbool vis[MAX_N];\nint in[MAX_N];\nvoid dfs(int v)\n{\n\tif(vis[v])return;\n\tvis[v]=true;\n\trep(i,0,g1[v].size())\n\t{\n\t\tint to=g1[v][i];\n\t\tif(!vis[to])\n\t\t{\n\t\t\tg2[v].pb(to);\n\t\t\tin[to]++;\n\t\t\tdfs(to);\n\t\t}\n\t}\n}\nint main()\n{\n\tn=read();\n\tA.resize(n);\n\trep(i,0,n)A[i]=read();\n\tsort(all(A));\n\tA.resize(unique(all(A))-A.begin());\n\tn=A.size();\n\tg1.resize(n);\n\tg2.resize(n);\n\trep(i,0,n)\n\t{\n\t\trep(j,i+1,n)\n\t\t{\n\t\t\tif(__gcd(A[i],A[j])>1)\n\t\t\t{\n\t\t\t\tg1[i].pb(j);\n\t\t\t\tg1[j].pb(i);\n\t\t\t}\n\t\t}\n\t}\n\trep(i,0,n)\n\t{\n\t\tdfs(i);\n\t}\n\tqueue <int> q;\n\tvec ans;\n//\trep(i,0,n)cout<<in[i]<<endl;\n\tper(i,n-1,0)if(!in[i])q.push(i),ans.pb(i);\n\twhile(!q.empty())\n\t{\n\t\tint t=q.front();\n\t\tq.pop();\n\t\trep(i,0,g2[t].size())\n\t\t{\n\t\t\tint to=g2[t][i];\n\t\t\tin[to]--;\n\t\t\tif(!in[to])\n\t\t\t{\n\t\t\t\tq.push(to);\n\t\t\t\tans.pb(to);\n\t\t\t}\n\t\t}\n\t}\n\trep(i,0,ans.size())ans[i]=A[ans[i]];\n\trep(i,0,ans.size())\n\t{\n\t\trep(j,0,ans.size()-1)\n\t\t{\n\t\t\tif(ans[j]<ans[j+1] && __gcd(ans[j],ans[j+1])==1)swap(ans[j],ans[j+1]);\n\t\t}\n\t}\n\trep(i,0,ans.size()-1)cout<<ans[i]<<\" \";\n\tcout<<ans.back()<<endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nbool vis[2003];\nvector<int>v;\nvector<int>va[2003],g[2003],vb[2003];\nint n,a[2003];\npair<int,int>axx[2003];\nbool cmp(pair<int,int>a,pair<int,int>b){\n    return a>b;\n}\nbool isprime(int x){\n\tfor(int i=2;i<=sqrt(x);i++)\n\t\tif(x%i==0)\n\t\t\treturn 0;\n\treturn 1;\n}\nint dfs(int x,int xxxxx){\n\tvb[xxxxx].push_back(a[x]);\n\t//cout<<\"HELLO\"<<xxxxx<<endl;\n\tvis[x]=1;\n\tint minn=a[x];\n\tfor(int i=0;i<g[x].size();i++)\n\t\tif(!vis[g[x][i]])\n\t\t\tminn=min(minn,dfs(g[x][i],xxxxx));\n\treturn minn;\n}\nint main(){\n\tcin>>n;\n\tfor(int i=2;i<=10000;i++)\n\t\tif(isprime(i))\n\t\t\tv.push_back(i);\n\tfor(int i=0;i<n;i++)\n\t\tcin>>a[i];\n\tsort(a,a+n);\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<v.size();j++)\n\t\t\tif(a[i]%v[j]==0)\n\t\t\t\tva[i].push_back(v[j]);\n\t}\n\tfor(int i=0;i<n;i++)\n\t\tfor(int j=i+1;j<n;j++)\n\t\t{\n\t\t\tbool can=0;\n\t\t\tfor(int ii=0;ii<va[i].size();ii++)\n\t\t\t{\n\t\t\t\tfor(int jj=0;jj<va[j].size();jj++)\n\t\t\t\t\tif(va[i][ii]==va[j][jj])\n\t\t\t\t\t{\n\t\t\t\t\t\tg[i].push_back(j),\n\t\t\t\t\t\tg[j].push_back(i),\n\t\t\t\t\t\tcan=1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\tif(can==1)break;\n\t\t\t}\n\t\t}\n\tint cnt=0;\n\tfor(int i=0;i<n;i++)\n\t\tsort(g[i].begin(),g[i].end());\n\tfor(int i=0;i<n;i++)\n\t\tif(!vis[i])\n\t\t\taxx[cnt].second=i,\n\t\t\taxx[cnt++].first=dfs(i,i);\n\tsort(axx,axx+cnt,cmp);\n    for(int i=0;i<cnt;i++)\n    \tfor(int j=0;j<vb[axx[i].second].size();j++)\n    \t\tcout<<vb[axx[i].second][j]<<' ';\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 2005\nusing namespace std;\nvector<int> E[N];\nint n,m,cnt,G[N][N],a[N],vis[N];\nint gcd(int x,int y){ return x ? gcd(y%x,x) : y;}\nvoid dfs(int t)\n{\n\tint i; vis[t]=1;\n\tE[m].push_back(t);\n\tfor(i=1;i<=n;i++)\n\t\tif(G[t][i]&&!vis[i])\n\t\t\tdfs(i);\n}\nint main()\n{\n\tint i,j,p;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tsort(a+1,a+n+1);\n\tfor(i=1;i<=n;i++)\n\t\tfor(j=1;j<=n;j++)\n\t\t\tif(gcd(a[i],a[j])!=1) G[i][j]=1;\n\tfor(i=1;i<=n;i++){\n\t\tif(vis[i]) continue;\n\t\t++m,dfs(i);\n\t  }\n\tcnt=m;\n\tfor(i=1;i<=m;i++)\n\t\treverse(E[i].begin(),E[i].end());\n\twhile(cnt){\n\t\tp=0;\n\t\tfor(i=1;i<=m;i++){\n\t\t\tif(!E[i].size()) continue;\n\t\t\tif(!p||E[i][E[i].size()-1]>E[p][E[p].size()-1]) p=i;\n\t\t  }\n\t\tprintf(\"%d \",a[E[p][E[p].size()-1]]);\n\t\tE[p].pop_back();\n\t\tif(!E[p].size()) cnt--;\n\t  }\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <vector>\n#include <iostream>\n#include <string.h>\n#include <string>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\ntypedef double LD;\ntypedef long long LL;\ntypedef pair<int, int> PII;\n#define MP make_pair\n#define PB push_back\n#define FOR(i,a,b) for(int i = (a); i < (b); ++i)\n#define RFOR(i,b,a) for(int i = (b) - 1; i >= (a); --i)\n#define REP(i, t) FOR(i,0,t)\n#define ALL(a) a.begin(), a.end()\n#define SZ(a) (int)((a).size())\n\nconst LL MOD = 1000000007;\nconst int INF = 1e9;\nconst int MAXN = 2007;\nconst LD EPS = 1e-7;\n\nint n, A[MAXN], B[MAXN][MAXN], P[MAXN], r = 0;\nbool used[MAXN];\nqueue <int> Q;\n\nint gcd(int a, int b)\n{\n\tif (a == 0) return b;\n\treturn gcd(b % a, a);\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0);\n\tfreopen(\"In.txt\", \"r\", stdin);\n\tcin >> n;\n\tREP(i, n) cin >> A[i];\n\tREP(i, n)\n\t{\n\t\tif (used[i]) continue;\n\t\tused[i] = true;\n\t\tQ.push(i);\n\t\tint sz = 0;\n\t\twhile (!Q.empty())\n\t\t{\n\t\t\tint v = Q.front();\n\t\t\tQ.pop();\n\t\t\tB[r][sz++] = A[v];\n\t\t\tREP(j, n)\n\t\t\t{\n\t\t\t\tif (!used[j] && gcd(A[v], A[j]) > 1)\n\t\t\t\t{\n\t\t\t\t\tused[j] = true;\n\t\t\t\t\tQ.push(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t++r;\n\t}\n\tREP(i, r) P[i] = 0;\n\tREP(i, n)\n\t{\n\t\tint mr = 0;\n\t\tREP(j, r)\n\t\t\tif (B[j][P[j]] > B[mr][P[mr]])\n\t\t\t\tmr = j;\n\t\tcout << B[mr][P[mr]] << ' ';\n\t\t++P[mr];\n\t}\n\t//cout << endl; system(\"pause\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\nint n,mp[2010],v[2010][2010],ru[2010],a[2010];\nvector<int>zh[2010];\nint gcd(int x,int y){\n\tif(!y)return x;\n\treturn gcd(y,x%y);\n}\nvoid dfs(int x){\n\tint i;\n\t//printf(\"%d\\n\",x);\n\tmp[x]=1;\n\tfor(i=1;i<=n;i++)if(!mp[i]&&v[x][i]){\n\t\tru[i]++;zh[x].push_back(i);\n\t\tdfs(i);\n\t}\n}\nvoid ts(){\n\tint i,x;\n\tpriority_queue<int>q;\n\tfor(i=1;i<=n;i++)if(!ru[i])q.push(i);\n\twhile(!q.empty()){\n\t\tx=q.top();q.pop();\n\t\tprintf(\"%d \",a[x]);\n\t\tfor(i=0;i<zh[x].size();i++)q.push(zh[x][i]);\n\t}\n}\nint main(){\n\tint i,j;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n\tsort(a+1,a+n+1);\n\tfor(i=1;i<=n;i++)\n\t for(j=i+1;j<=n;j++)if(gcd(a[i],a[j])!=1)v[i][j]=v[j][i]=1;\n\tfor(i=1;i<=n;i++)if(!mp[i])dfs(i);\n\tts();\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n\nusing namespace std;\n\nconst long long int MOD = 1000000007;\n\nlong long int N, M, K, H, W, L, R;\n\nint gcd(int a, int b) {\n\tif (a < b)swap(a, b);\n\twhile (b) {\n\t\ta %= b;\n\t\tswap(a, b);\n\t}\n\treturn a;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\tvector<int>v(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> v[i];\n\t}\n\tsort(v.begin(), v.end());\n\treverse(v.begin(), v.end());\n\tvector<vector<int>>edge(N, vector<int>(N));\n\tvector<int>dir(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = i + 1; j < N; j++) {\n\t\t\tif (gcd(v[i], v[j])!=1) {\n\t\t\t\tedge[i][j] = 1;\n\t\t\t\tedge[j][i] = 1;\n\t\t\t\tdir[i]++;\n\t\t\t\tdir[j]++;\n\t\t\t}\n\t\t}\n\t}\n\tvector<int>ans;\n\tvector<int>box;\n\tvector<int>used(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tif (!dir[i]) {\n\t\t\tbox.push_back(v[i]);\n\t\t\tused[i] = 1;\n\t\t}\n\t}\n\tpriority_queue<int>Q;\n\tfor (int i = N - 1; i >= 0; i--) {\n\t\tif (!used[i]) {\n\t\t\tQ.push(i);\n\t\t\tbreak;\n\t\t}\n\t}\n\twhile (!Q.empty()) {\n\t\tint cn = Q.top();\n\t\tQ.pop();\n\t\tif (used[cn])continue;\n\t\tans.push_back(v[cn]);\n\t\tdir[cn] = 0;\n\t\tused[cn] = 1;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif (edge[cn][i]) {\n\t\t\t\tedge[cn][i] = 0;\n\t\t\t\tedge[i][cn] = 0;\n\t\t\t\tdir[i]--;\n\t\t\t\tif (dir[i]) {\n\t\t\t\t\tQ.push(i);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tans.push_back(v[i]);\n\t\t\t\t\tused[i] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint aindex = 0;\n\tint bindex = 0;\n\t//for (auto i : box)cout << i << endl;\n\t//for (auto i : ans)cout << i << endl;\n\tfor (int i = 0; i < N; i++) {\n\t\tif (i)cout << \" \";\n\t\tif (ans.size() == aindex) {\n\t\t\tcout << box[bindex];\n\t\t\tbindex++;\n\t\t}\n\t\telse if (box.size() == bindex) {\n\t\t\tcout << ans[aindex];\n\t\t\taindex++;\n\t\t}\n\t\telse if (box[bindex] < ans[aindex]) {\n\t\t\tcout << ans[aindex];\n\t\t\taindex++;\n\t\t}\n\t\telse {\n\t\t\tcout << box[bindex];\n\t\t\tbindex++;\n\t\t}\n\t}\n\tcout << endl;\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n#define sqr(x) ((x)*(x))\n#define mp make_pair\n#define uint unsigned\n#define PI pair<int,int>\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline ll read(){\n\tll x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(ll a){\n    if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(ll a){write(a); puts(\"\");}\ninline void wri(ll a){write(a); putchar(' ');}\ninline ull rnd(){\n\treturn ((ull)rand()<<30^rand())<<4|rand()%4;\n}\nconst int N=2005;\nint vis[N],rd[N],a[N],n;\nbitset<N> ycl[N];\nvector<int> v[N];\nvoid dfs(int p){\n\tvis[p]=1;\n\tfor(int i=1;i<=n;i++)if(!vis[i]&&ycl[p][i]){v[p].push_back(i); rd[i]++; dfs(i);}\n}\npriority_queue<int> q;\nsigned main(){\n\tn=read(); \n\tfor(int i=1;i<=n;i++)a[i]=read();\n\tsort(&a[1],&a[n+1]);\n\tfor(int i=1;i<=n;i++)for(int j=i+1;j<=n;j++)ycl[i][j]=ycl[j][i]=__gcd(a[i],a[j])>1;\n\tfor(int i=1;i<=n;i++)if(!vis[i]){\n\t\tdfs(i);\n\t}\n\tfor(int i=1;i<=n;i++)if(rd[i]==0)q.push(i);\n\twhile(q.size()){\n\t\tint t=q.top(); q.pop(); write(t); putchar(' ');\n\t\tfor(auto i:v[t])if(--rd[i]==0)q.push(i);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint N;\nint A[2005];\nvector <int> G[2005];\nvector <int> V[2005];\nbool Use[2005];\nvoid Read()\n{\n    cin >> N;\n    for(int i = 1; i <= N; i++)\n        cin >> A[i];\n    sort(A + 1, A + N + 1);\n}\nint GCD(int a, int b)\n{\n    int r = a % b;\n    while(r != 0)\n    {\n        a = b;\n        b = r;\n        r = a % b;\n    }\n    return b;\n}\nvoid precalcG()\n{\n    for(int i = 1; i <= N; i++)\n    {\n        for(int j = i + 1; j <= N; j++)\n        {\n            if(GCD(A[i], A[j]) != 1)\n            {\n                G[i].push_back(j);\n                G[j].push_back(i);\n            }\n        }\n    }\n    for(int i = 1; i <= N; i++)\n    {\n        G[0].push_back(i);\n    }\n    for(int i = 1; i <= N; i++)\n    {\n        sort(G[i].begin(), G[i].end());\n    }\n}\nvector <int> Merge(vector <int> a, vector <int> b)\n{\n    int i = 0, j = 0;\n    vector <int> res;\n    while(i < a.size() && j < b.size())\n    {\n        if(a[i] > b[j])\n        {\n            res.push_back(a[i]);\n            ++i;\n        }\n        else\n        {\n            res.push_back(b[j]);\n            ++j;\n        }\n    }\n    while(i < a.size())\n    {\n        res.push_back(a[i]);\n        ++i;\n    }\n    while(j < b.size())\n    {\n        res.push_back(b[j]);\n        ++j;\n    }\n    return res;\n}\nvoid DFS(int node, int father)\n{\n    Use[node] = 1;\n    for(int i = 0; i < G[node].size(); i++)\n    {\n        int neighb = G[node][i];\n        if(neighb == father)\n            continue;\n        if(Use[neighb] == 1)\n            continue;\n        DFS(neighb, node);\n        V[node] = Merge(V[node], V[neighb]);\n    }\n    reverse(V[node].begin(), V[node].end());\n    V[node].push_back(node);\n    reverse(V[node].begin(), V[node].end());\n}\n\nint main()\n{\n    Read();\n    precalcG();\n    DFS(0, -1);\n    for(int i = 1; i < V[0].size(); i++)\n    {\n        cout << A[V[0][i]] << \" \";\n    }\n    cout << \"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define X first\n#define Y second\n#define mp make_pair\nusing namespace std;\ntypedef pair<int,bool> PIB;\ntypedef vector<PIB> T;\nconst int N = 2010;\nint gcd(int a,int b){\n\tif(b==0) return a;\n\treturn gcd(b,a%b);\n}\nint a[N],n;\nvector<int> v[N],g[N];\nbool use[N],in[N],pd[N];\nint d[N],q[N],head,tail,t;\nvoid dfs(int x){\n\t//cout<<x<<endl;\n\tint t;\n\tuse[x]=true;\n\tfor(int i=0;i<g[x].size();i++) if(!use[t=g[x][i]]){\n\t\tv[x].push_back(t);\n\t}\n\tfor(int i=0;i<g[x].size();i++) if(!use[t=g[x][i]]){\n\t\tdfs(t);\n\t}\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",a+i);\n\tsort(a+1,a+n+1); \n\tfor(int i =1;i<=n;i++) for(int j = 1;j<=n;j++)if(i!=j && gcd(a[i],a[j])!=1) g[i].push_back(j);\n//\tcout<<g[2].size()<<endl;\n\tfor(int i =1;i<=n;i++) if(!use[i]) dfs(i);\n\tint cnt =0;\n\tmemset(pd,false,sizeof(pd));\n\tfor(int i = 1;i<=n;i++) for(int j =0;j<v[i].size();j++) d[v[i][j]]++;\n\twhile(cnt<n){\n\t\tint last = 0;\n\t\tfor(int i = 1;i<=n;i++) if(!pd[i] && d[i]==0 && a[i]>a[last]){\n\t\t\tlast = i;\n\t\t} \n\t\tpd[last] = true;\n\t\tfor(int i =0;i<v[last].size();i++) d[v[last][i]]--;\n\t\tprintf(\"%d \",a[last]);\n\t\tcnt++;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<typename T> \nmap<T, Int> factorize(T x){\n  map<T, Int> res;\n  for(Int i=2;i*i<=x;i++){\n    while(x%i==0){\n      x/=i;\n      res[i]++;\n    }\n  }\n  if(x!=1) res[x]++;\n  return res;\n}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<Int> a(n);\n  for(Int i=0;i<n;i++) cin>>a[i];\n  sort(a.begin(),a.end());\n\n  vector<Int> ans(n);\n\n  Int m=0;\n  map<Int, Int> r;\n\n  vector<vector<Int> > G(n);\n  for(Int i=0;i<n;i++){\n    auto x=factorize(a[i]);\n    for(auto p:x){\n      if(!r.count(p.first)) r[p.first]=m++,G.emplace_back();\n      G[i].emplace_back(n+r[p.first]);\n      G[n+r[p.first]].emplace_back(i);\n    }\n  }\n  \n  Int color=0;\n  vector<Int> cs(n+m,-1),used(n+m,0),post(n,0);\n  for(Int t=0;t<n;t++){\n    for(Int i=0;i<n+m;i++){\n      if(used[i]||~cs[i]) continue;\n      queue<Int> q;\n      cs[i]=color;\n      q.emplace(i);\n      while(!q.empty()){\n\tInt v=q.front();q.pop();\n\tfor(Int u:G[v]){\n\t  if(used[u]||~cs[u]) continue;\n\t  cs[u]=color;\n\t  q.emplace(u);\n\t}\n      }\n      color++;\n    }\n    \n    Int idx=-1;\n    for(Int i=0;i<n;i++){\n      if(used[i]||post[i]) continue;\n      idx=i;\n      break;\n    }\n    \n    used[idx]=1;\n    ans[t]=idx;\n    \n    for(Int i=0;i<n+m;i++){\n      if(used[i]||cs[idx]!=cs[i]) continue;\n      if(i<n) post[i]=__gcd(a[idx],a[i])<=1;\n      cs[i]=-1;\n    }\n  }\n\n  vector<Int> b(n);\n  for(Int i=0;i<n;i++) b[i]=a[ans[i]];\n  \n  vector<vector<Int> > H(n);\n  for(Int i=0;i<n;i++)\n    for(Int j=i+1;j<n;j++)\n      if(__gcd(b[i],b[j])>1) H[i].emplace_back(j);\n\n  vector<Int> indeg(n);\n  for(Int i=0;i<n;i++)\n    for(Int j:H[i]) indeg[j]++;\n  \n  using P = pair<Int, Int>;\n  priority_queue<P> pq;\n  for(Int i=0;i<n;i++)\n    if(!indeg[i]) pq.emplace(b[i],i);\n\n  vector<Int> c;\n  while(!pq.empty()){\n    P p=pq.top();pq.pop();\n    c.emplace_back(p.first);\n    for(Int u:H[p.second]){\n      indeg[u]--;\n      if(!indeg[u]) pq.emplace(b[u],u);\n    }\n  }\n  \n  for(Int i=0;i<n;i++){\n    if(i) cout<<\" \";\n    cout<<c[i];\n  }\n  cout<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define FOR(i,a,b) for (register int i=(a);i<=(b);i++)\n#define For(i,a,b) for (register int i=(a);i>=(b);i--)\n#define mem(i,j) memset(i,j,sizeof(i))\n#define GO(u) for (register int j=f[u];j!=-1;j=nxt[j])\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define MP make_pair\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\nconst int N=2020;\nint n,a[N],vis[N],l[N],r[N],line[N][N],cnt=0,ans[N];\nvector<int> vec[N];\npriority_queue <pii> q;\ninline int read()\n{\n\tint x=0,f=1;\n\tchar c=getchar();\n\twhile (c<'0'||c>'9') {if (c=='-') f=-1;c=getchar();}\n\twhile (c>='0'&&c<='9') {x=(x<<1)+(x<<3)+c-'0';c=getchar();}\n\treturn f*x;\n}\ninline void write(int x)\n{\n\tif (x<0) putchar('-'),x=-x;\n\tif (x>9) write(x/10);\n\tputchar(x%10+'0');\n\treturn;\n}\ninline int GCD(int x,int y)\n{\n\tif (!y) return x;\n\tif (x<y) return GCD(y,x);\n\treturn GCD(y,x%y);\n}\ninline void dfs(int u)\n{\n\tvis[u]=1;\n\tline[cnt][++r[cnt]]=u;\n\tFOR(i,0,(int)vec[u].size()-1)\n\t{\n\t\tint v=vec[u][i];\n\t\tif (vis[v]) continue;\n\t\tdfs(v);\n\t}\n\treturn;\n}\nint main()\n{\n\tn=read();\n\tFOR(i,1,n) a[i]=read();\n\tFOR(i,1,n) FOR(j,1,n) if (i!=j) if (GCD(a[i],a[j])>1) vec[i].pb(j);\n\tFOR(i,1,n) sort(vec[i].begin(),vec[i].end());\n\tFOR(i,1,n) if (!vis[i]) {cnt++;l[cnt]=1,r[cnt]=0;dfs(i);}\n\tFOR(i,1,cnt) q.push(MP(a[line[i][l[i]]],i));\n\twhile (q.size())\n\t{\n\t\tpii tmp=q.top();\n\t\tq.pop();\n\t\tans[++ans[0]]=tmp.fi;\n\t\tif (l[tmp.se]<=r[tmp.se])\n\t\t{\n\t\t\tl[tmp.se]++;\n\t\t\tq.push(MP(a[line[tmp.se][l[tmp.se]]],tmp.se));\n\t\t}\n\t}\n\tFOR(i,1,n) write(ans[i]),putchar(' ');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ninline int read()\n{\n    int x = 0,f = 1;char ch = getchar();\n    for(;!isdigit(ch);ch = getchar())if(ch == '-') f = -f;\n    for(;isdigit(ch);ch = getchar())x = 10 * x + ch - '0';\n    return x * f;\n}\nconst int N = 2010 ;\n\nint vis[N], ok[N][N], in[N], a[N] ;\nvector <int> g[N] ;\nint n ;\n\nvoid dfs(int rt) {\n    vis[rt] = 1 ;\n    for (int i = 1; i <= n; i++)\n    if (!vis[i] && ok[rt][i]) {\n        in[i]++ ;\n        g[rt].push_back(i) ;\n        dfs(i) ;\n    }\n}\n\nvoid Top() {\n    priority_queue <int> q ;\n    for (int i = 1;  i <= n; i++) if (!in[i]) q.push(i) ;\n    while (!q.empty()) {\n        int now = q.top() ;\n        q.pop() ;\n        cout << a[now] << \" \" ;\n        for (int i = 0; i < g[now].size(); i++) q.push(g[now][i]) ;\n    }\n}\n\nsigned main(){\n    scanf(\"%d\", &n) ;\n    for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]) ;\n    sort(a + 1, a + n + 1) ;\n    for (int i = 1; i <= n; i++)\n    for (int j = i + 1; j <= n; j++)\n    if (__gcd(a[i], a[j]) != 1) ok[i][j] = ok[j][i] = 1 ;\n    for (int i = 1; i <= n; i++) if (!vis[i]) dfs(i) ;\n    Top() ;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for(int i = (b) - 1; i >= (a); i--)\n#define ITER(it, a) for(typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a, value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int) a.size()\n#define ALL(a) a.begin(),a.end()\n#define PB push_back\n#define MP make_pair\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\n\nconst double PI = acos(-1.0);\nconst LL INF = 1000 * 1000 * 1000 + 7;\nconst LL LINF = INF * (LL)INF;\n\nconst int MAX = 2020;\n\nVI g[MAX];\nint A[MAX];\n\nint U[MAX];\n\nint gcd(int a, int b)\n{\n\tif (b == 0) return a;\n\treturn gcd(b, a%b);\n}\n\nVI merge(VI& a, VI& b)\n{\n\tVI res;\n\tres.reserve(SZ(a) + SZ(b));\n\n\ta.PB(-INF);\n\n\tint ind = 0;\n\tFOR (i, 0, SZ(a))\n\t{\n\t\twhile(ind < SZ(b) && b[ind] > a[i])\n\t\t{\n\t\t\tres.PB(b[ind]);\n\t\t\tind++;\n\t\t}\n\n\t\tif (i == SZ(a) - 1) break;\n\t\tres.PB(a[i]);\n\t}\n\n\treturn res;\n}\n\n\nVI dfs(int x)\n{\n\tU[x] = true;\n\tVI res;\n\tFOR (i, 0, SZ(g[x]))\n\t{\n\t\tint to = g[x][i];\n\t\tif (U[to]) continue;\n\t\tVI v = dfs(to);\n\n\t\tres = merge(res, v);\n\t}\n\n\treverse(ALL(res));\n\tres.PB(A[x]);\n\treverse(ALL(res));\n\treturn res;\n}\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t//ios::sync_with_stdio(false); cin.tie(0);\n\n\tint n;\n\tscanf(\"%d\", &n);\n\tFOR (i, 0, n)\n\t{\n\t\tscanf(\"%d\", &A[i]);\n\t}\n\n\tsort(A, A+n);\n\n\tFOR (i, 0, n)\n\t{\n\t\tFOR (j, 0, n)\n\t\t{\n\t\t\tif (i == j) continue;\n\t\t\tif (gcd(A[i], A[j]) != 1) g[i].PB(j);\n\t\t}\n\t}\n\n\tVI res;\n\n\tFOR (i, 0, n)\n\t{\n\t\tif (U[i]) continue;\n\t\tVI v = dfs(i);\n\t\tres = merge(res, v);\n\t}\n\n\tFOR (i, 0, SZ(res))\n\t{\n\t\tprintf(\"%d \", res[i]);\n\t}\n\tprintf(\"\\n\");\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <stdio.h>\n#include <stdlib.h>\n#include <vector>\n#include <map>\n//#include <self/operator>\n#include <queue>\n#include <set>\n#include <string>\n#include <string.h>\n#include <stack>\n#include <assert.h>\n#include <bitset>\n#define Endl endl\n#define mp make_pair\n#define ll long long \n#define ull unsigned long long\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define over(A) {cout<<A<<endl;exit(0);}\n#define all(A) A.begin(),A.end()\n#define ceil(a,b) ((a-1)/b+1)\n#define quickcin ios_base::sync_with_stdio(false);\nconst int mod=1e9+7;\nconst int inf=1039074182;\nconst ll llinf=1LL*inf*inf;\nusing namespace std;\ntemplate <typename T1,typename T2> inline void chmin(T1 &x,T2 b) {if(b<x) x=b;}\ntemplate <typename T1,typename T2> inline void chmax(T1 &x,T2 b) {if(b>x) x=b;}\ntemplate <typename T1,typename T2> inline void chadd(T1 &x,T2 b) {x+=b;if(x>=mod) x-=mod;}\ntemplate <typename T1,typename T2> inline void chmul(T1 &x,T2 b) {x=1LL*x*b%mod;}\ntemplate <typename T1,typename T2> inline void chmod(T1 &x,T2 b) {x%=b,x+=b;if(x>=b) x-=b;}\nint n;\nint a[2005];\nvector <int> vec[2005];\nbool block[2005];\n\ninline vector <int> merge(vector <int> a,vector <int> b)\n{\n\tvector <int> res;\n\tint la=(int)a.size();\n\tint lb=(int)b.size();\n\tres.push_back(a[0]);\n\tfor(int i=1,j=0;;)\n\t{\n\t\tif(i==la && j==lb) break;\n\t\tif(i==la) res.push_back(b[j++]);\n\t\telse if(j==lb) res.push_back(a[i++]);\n\t\telse if(a[i]>b[j]) res.push_back(a[i++]);\n\t\telse res.push_back(b[j++]);\n\t}\n\treturn res;\n}\n\n//#include <self/operator>\nvector <int> dfs(int x)\n{\n\tvector <int> res;\n\tres.push_back(a[x]);\n\tblock[x]=true;\n\tfor(auto &u:vec[x])\n\t{\n\t\tif(block[u]) continue;\n\t\tres=merge(res,dfs(u));\n\t}\n\treturn res;\n}\n\nbool compare(int x,int y)\n{\n\treturn a[x]<a[y];\n}\n\nvoid build_graph()\n{\n\ta[n]=0;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<n;j++)\n\t\t{\n\t\t\tif(i==j) continue;\n\t\t\tif(__gcd(a[i],a[j])!=1) vec[i].push_back(j);\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tvec[i].push_back(n);\n\t\tvec[n].push_back(i);\n\t}\n\tfor(int i=0;i<=n;i++)\n\t{\n\t\tsort(all(vec[i]),compare);\n\t}\n}\n\nvoid print_graph()\n{\n\tcout<<\"--------Graph is below--------\"<<endl;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int &j:vec[i])\n\t\t{\n\t\t\tcout<<i<<' '<<j<<endl;\n\t\t}\n\t}\n\tcout<<\"--------Graph is above--------\"<<endl;\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\",\"r\",stdin);\n\tcin>>n;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcin>>a[i];\n\t}\n\tbuild_graph();\n\tfor(auto &x:dfs(n))\n\t{\n\t\tif(x==0) continue;\n\t\tcout<<x<<' ';\n\t}\n\tcout<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)x.size()\n#define beg(x) x.begin()\n#define en(x) x.end()\n#define all(x) beg(x), en(x)\n#define resz resize\n\nconst int MOD = 1000000007; // 998244353\nconst ll INF = 1e18;\nconst int MX = 200005;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) { \n        re(first); re(rest...); \n    }\n\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) { \n        pr(first); pr(rest...); \n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) { \n        pr(\"{\",x.f,\", \",x.s,\"}\"); \n    }\n    template<class T> void prContain(const T& x) {\n        pr(\"{\");\n        bool fst = 1; for (const auto& a: x) pr(!fst?\", \":\"\",a), fst = 0; // const needed for vector<bool>\n        pr(\"}\");\n    }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n    \n    void ps() { pr(\"\\n\"); }\n    template<class Arg> void ps(const Arg& first) { \n        pr(first); ps(); // no space at end of line\n    }\n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) { \n        pr(first,\" \"); ps(rest...); // print w/ spaces\n    }\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n    }\n}\n\nusing namespace io;\n\ntemplate<class T> T invGeneral(T a, T b) {\n    a %= b; if (a == 0) return b == 1 ? 0 : -1;\n    T x = invGeneral(b,a); \n    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n}\n\ntemplate<class T> struct modular {\n    T val; \n    explicit operator T() const { return val; }\n    modular() { val = 0; }\n    template<class U> modular(const U& v) {\n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD;\n    }\n    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }\n    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }\n    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }\n\n    modular operator-() const { return modular(-val); }\n    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }\n    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }\n    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }\n    friend modular exp(modular a, ll p) {\n        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n        return ans;\n    }\n    friend modular inv(const modular& a) { return invGeneral(a.val,MOD); } \n    // inv is equivalent to return exp(b,b.mod-2) if prime\n    modular& operator/=(const modular& m) { return (*this) *= inv(m); }\n    \n    friend modular operator+(modular a, const modular& b) { return a += b; }\n    friend modular operator-(modular a, const modular& b) { return a -= b; }\n    friend modular operator*(modular a, const modular& b) { return a *= b; }\n    \n    friend modular operator/(modular a, const modular& b) { return a /= b; }\n};\n\ntypedef modular<int> mi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\nint N, A[2000];\nbool adj[2000][2000], vis[2000];\nvi seq[2000];\n\nvi merge(vi a, vi b) {\n    if (!sz(a)) return b;\n    if (!sz(b)) return a;\n    int x = -1;\n    if (a > b) {\n        x = a.front();\n        a.erase(a.begin());\n    } else {\n        x = b.front();\n        b.erase(b.begin());\n    }\n    auto c = merge(a,b); c.insert(c.begin(),x);\n    return c;\n}\n\nvoid dfs(int x) {\n    vis[x] = 1;\n    F0R(i,N) if (adj[x][i] && !vis[i]) {\n        dfs(i);\n        seq[x] = merge(seq[x],seq[i]);\n    }\n    seq[x].insert(seq[x].begin(),A[x]);\n}\n\nint main() {\n    setIO(); re(N); F0R(i,N) re(A[i]);\n    sort(A,A+N);\n    F0R(i,N) F0R(j,N) adj[i][j] = (__gcd(A[i],A[j])>1);\n    vi ans;\n    F0R(i,N) if (!vis[i]) {\n        dfs(i);\n        ans = merge(ans,seq[i]);\n    }\n    trav(t,ans) pr(t,' ');\n}\n\n\n/* stuff you should look for\n    * int overflow, array bounds\n    * special cases (n=1?), set tle\n    * do smth instead of nothing and stay organized\n*/"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define index(xs, x) (int)(lower_bound(all(xs), x) - xs.begin())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n\nint N;\nvector<int> C[3300];\nint A[2000];\nvector<int> R[2000];\nbool used[2000], dead[2000];\n\nint gcd(int a, int b) {\n  if (b==0)return a;\n  return gcd(b,a%b);\n}\n\nvector<int> prime_list(int x) {\n  vector<int> ret;\n  for (int p=2; p*p<=x; p++) if (x%p == 0) {\n    while (x%p == 0) x /= p;\n    ret.pb(p);\n  }\n  if (x > 1) ret.pb(x);\n  return ret;\n}\nint num = 0;\nvoid dfs(int x);\nvoid dfs2(int p) {\n  vector<int> vs(C[p]);\n  C[p].clear();\n  for (int x : vs) dfs(x);\n}\nvoid dfs(int x) {\n  assert(!dead[x]);\n  if (used[x]) return;\n  num--;\n  used[x] = true;\n  for (int p : R[x]) dfs2(p);\n}\nvector<int> seq, seqI;\nvector<int> seqK[3300];\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> N;\n  vector<int> all;\n  rep(i, N) cin >> A[i];\n  sort(A, A+N);\n  rep(i, N) R[i] = prime_list(A[i]), all.insert(all.end(), all(R[i]));\n  sort(all(all)); uniq(all);\n  assert(all.size() <= 3300);\n  rep(i, N) for (int &x : R[i]) x = index(all, x);\n\n  rep(_, N) {\n    num = N-_;\n    int m = -1;\n    rep(i, N) used[i] = false;\n    rep(i, N) if (!dead[i]) for (int p : R[i]) C[p].clear();\n    rep(i, N) if (!dead[i]) for (int p : R[i]) C[p].pb(i);\n    rep(i, N) if (!dead[i]) {\n      int left = -1;\n      for (int p : R[i]) if (!seqK[p].empty()) left = max(left, seqK[p].back()+1);\n      auto it = lower_bound(all(seqI), left);\n      int g = INF;\n      if (it != seqI.end()) g= seq[*it];\n      dfs(i);\n      if (g >= A[i]) {\n        if (num == 0) {\n          m = i;\n          break;\n        }\n      }\n    }\n    assert(m != -1);\n    while (!seqI.empty() && seq[seqI.back()] >= A[m]) seqI.pop_back();\n    seqI.pb(_);\n    seq.pb(A[m]);\n    dead[m] = true;\n    for (int p : R[m]) seqK[p].pb(_);\n  }\n  rep(i, N) cout << seq[i] << \" \"; cout << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <functional>\n#define repeat(i,n) for (int i = 0; (i) < int(n); ++(i))\n#define whole(f,x,...) ([&](decltype((x)) whole) { return (f)(begin(whole), end(whole), ## __VA_ARGS__); })(x)\nusing ll = long long;\nusing namespace std;\ntemplate <class T> using reversed_priority_queue = priority_queue<T, vector<T>, greater<T> >;\nint gcd(int a, int b) { while (a) { b %= a; swap(a, b); } return b; }\nbool is_swappable(int a, int b) { return gcd(a, b) == 1; }\nint main() {\n    // input\n    int n; cin >> n;\n    vector<int> a(n); repeat (i,n) cin >> a[i];\n    // rearrange\n    whole(sort, a);\n    vector<int> b;\n    vector<bool> used(n);\n    function<void (int)> go = [&](int i) {\n        used[i] = true;\n        b.push_back(a[i]);\n        repeat (j,n) if (not used[j] and not is_swappable(a[i], a[j])) {\n            go(j);\n        }\n    };\n    repeat (i,n) if (not used[i]) {\n        go(i);\n    }\n    // insertion sort\n    repeat (i,n) {\n        int j = i;\n        for (int k = i-1; k >= 0 and is_swappable(b[k], b[i]); -- k) {\n            if (b[k] < b[i]) j = k;\n        }\n        rotate(b.begin() + j, b.begin() + i, b.begin() + i + 1);\n    }\n    // output\n    for (auto it : b) cout << it << ' '; cout << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\nstruct UnionFind{\n  Int n;\n  vector<Int> r,p;\n  UnionFind(Int x,Int y):n(x+y),r(x+y,1),p(x+y,0){\n    iota(p.begin(),p.end(),0);\n    for(Int i=0;i<x;i++) r[i]=1;\n    for(Int i=0;i<y;i++) r[x+i]=0;\n  }\n  Int find(Int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(Int x,Int y){\n    return find(x)==find(y);\n  }\n  void unite(Int x,Int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    if(r[x]<r[y]) swap(x,y);\n    r[x]+=r[y];\n    p[y]=x;\n  }\n};\n\n\ntemplate<typename T> \nmap<T, Int> factorize(T x){\n  map<T, Int> res;\n  for(Int i=2;i*i<=x;i++){\n    while(x%i==0){\n      x/=i;\n      res[i]++;\n    }\n  }\n  if(x!=1) res[x]++;\n  return res;\n}\n\n//INSERT ABOVE HERE\nInt cop[2020][2020];\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<Int> a(n);\n  for(Int i=0;i<n;i++) cin>>a[i];\n  sort(a.begin(),a.end());\n\n  vector<Int> ans(n),used(n,0),post(n,0);\n\n  memset(cop,0,sizeof(cop));\n  \n  for(Int i=0;i<n;i++)\n    for(Int j=0;j<n;j++)\n      cop[i][j]=__gcd(a[i],a[j])>1;\n\n  Int m=0;\n  map<Int, Int> r;\n\n  vector<vector<Int> > G(n);\n  for(Int i=0;i<n;i++){\n    auto x=factorize(a[i]);\n    for(auto p:x){\n      if(!r.count(p.first)) r[p.first]=m++;\n      G[i].emplace_back(r[p.first]);\n    }\n  }\n  \n  for(Int t=0;t<n;t++){\n    UnionFind uf(n,m);\n    for(Int i=0;i<n;i++)\n      if(!used[i]) for(Int j:G[i]) uf.unite(i,n+j);\n\n    for(Int i=0;i<n;i++){\n      if(!post[i]) continue;\n      post[i]=0;\n      for(Int j=0;j<n;j++){\n\tif(used[j]) continue;\n\tif(cop[i][j]) post[i]|=a[j]>a[i];\n      }\n    }\n    \n    Int idx=-1,sum=t;\n    set<Int> tmp;\n    for(Int i=0;i<n;i++){\n      if(used[i]) continue;\n      Int k=uf.find(i);\n      if(!tmp.count(k)){\n\ttmp.emplace(k);\n\tsum+=uf.r[k];\n      }\n      if(post[i]) continue;\n      if(sum==n){\n\tidx=i;\n\tbreak;\n      }\n    }\n    assert(sum==n);\n    //while(idx<0);\n    used[idx]=1;\n    ans[t]=idx;\n    \n    for(Int i=0;i<n;i++)\n      if(cop[idx][i]) post[i]=0;\n      else if(a[idx]<a[i]) post[i]=1;\n  }\n  for(Int i=0;i<n;i++){\n    if(i) cout<<\" \";\n    cout<<a[ans[i]];\n  }\n  cout<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<map>\n\nusing namespace std;\n\nmap<int,int> m;\nmap<int,int>::iterator it;\nint n,v[2001],po,cnt,x,a[2001][11],la,fa[30001],siz[30001],tot,las[2001],c[20001],mx;\nbool b[2001],bo[2001],bb[30001];\n\nint gcd(int a,int b) {return (!b)?a:gcd(b,a%b);}\nint ask(int x) {return fa[x]==x?x:fa[x]=ask(fa[x]);}\nint getmax(int a,int b) {return a>b?a:b;}\n\nvoid unite(int x,int y)\n{\n\tint p=ask(x),q=ask(y);\n\tif (p==q) return;\n\tfa[p]=q; siz[q]+=siz[p];\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1; i<=n; i++) scanf(\"%d\",&v[i]);\n\tsort(v+1,v+1+n);\n\tm.clear(); cnt=0;\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tx=v[i];\n\t\tfor (int j=2; j*j<=v[i]; j++)\n\t\t\tif (x%j==0)\n\t\t\t{\n\t\t\t\ta[i][++a[i][0]]=j;\n\t\t\t\twhile (x%j==0) x/=j;\n\t\t\t}\n\t\tif (x!=1) a[i][++a[i][0]]=x;\n\t\tfor (int j=1; j<=a[i][0]; j++)\n\t\t{\n\t\t\tit=m.find(a[i][j]);\n\t\t\tif (it==m.end()) m[a[i][j]]=++cnt,a[i][j]=cnt;\n\t\t\telse a[i][j]=m[a[i][j]];\n\t\t}\n\t}\n\tmemset(c,0,sizeof(c));\n\tmemset(las,0,sizeof(las));\n\tla=(1e9);\n\tmemset(b,1,sizeof(b));\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tfor (int j=1; j<=cnt+1; j++) fa[j]=j,siz[j]=1;\n\t\tmemset(bb,0,sizeof(bb));\n\t\tfor (int j=1; j<=n; j++)\n\t\t\tif (b[j])\n\t\t\t{\n\t\t\t\tfor (int k=1; k<=a[j][0]; k++) bb[a[j][k]]=1;\n\t\t\t\tfor (int k=2; k<=a[j][0]; k++) unite(a[j][1],a[j][k]);\n\t\t\t}\n\t\ttot=1;\n\t\tfor (int j=1; j<=cnt; j++) if (bb[j]) tot++;\n\t\tfor (int j=1; j<=n; j++) \n\t\t\tif (b[j]) \n\t\t\t{\n\t\t\t\tmx=0;\n\t\t\t\tfor (int k=1; k<=a[j][0]; k++) mx=getmax(mx,c[a[j][k]]);\n\t\t\t\tif (las[j]>mx) continue;\n\t\t\t\tif (a[j][0]) unite(a[j][1],cnt+1);\n\t\t\t\tif (siz[ask(cnt+1)]==tot) {po=j; break;}\n\t\t\t}\n\t\tprintf(\"%d \",v[po]); b[po]=0; la=v[po];\n\t\tfor (int j=po+1; j<=n; j++) las[j]=i;\n\t\tfor (int j=1; j<=a[po][0]; j++) c[a[po][j]]=i;\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:1024000000,1024000000\")\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <string>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\n#define fr first\n#define sc second\nconst int N=2005,M=10000,D=N+1500+N;\nmap<int,int> S;\nvector<int> ep[D],Prm;\nint b[M+5],a[N],ans[N],mmj,n;\nint vis[D],vis0[D],xm[N],cm[N];\n\nint GetP()\n{\n    Prm.pb(0);\n    for (int i=2;i<=M;i++)\n    {\n        if (b[i]) continue;\n        Prm.pb(i);\n        for (int j=i+i;j<=M;j+=i) b[j]=1;\n    }\n    return Prm.size();\n}\nvoid dfs(int x)\n{\n    int i,tot=ep[x].size();vis[x]=1;if (x<=n) {if (xm[x]<=cm[x]) mmj=min(mmj,x);}\n    for (i=0;i<tot;i++) if (!vis0[ep[x][i]]&&!vis[ep[x][i]]) dfs(ep[x][i]);\n}\nint Copm(int x,int y)\n{\n    int i,j,t1=ep[x].size(),t2=ep[y].size();\n    for (i=0,j=0;i<t1&&j<t2;)\n    {\n        if (ep[x][i]==ep[y][j]) return 0;\n        if (ep[x][i]<ep[y][j]) i++; else j++;\n    }\n    return 1;\n}\nint main()\n{\n  //  freopen(\"in.txt\",\"r\",stdin);freopen(\"out.txt\",\"w\",stdout);\n    int i,j,tot=GetP()-1;\n    scanf(\"%d\",&n);\n    for (i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n    sort(a+1,a+n+1);\n    for (i=1;i<=n;i++)\n    {\n        int x=a[i];\n        for (j=1;j<=tot;j++)\n        {\n            if (x%Prm[j]) continue;\n            ep[i].pb(n+j);ep[n+j].pb(i);\n            while (x%Prm[j]==0) x/=Prm[j];\n        }\n        if (x>1)\n        {\n            map<int,int>::iterator i1=S.find(x);\n            if (i1!=S.end()) j=(*i1).sc;\n             else {Prm.pb(x);S.insert(mp(x,Prm.size()-1));j=Prm.size()-1;}\n            ep[i].pb(n+j);ep[n+j].pb(i);\n        }\n    }\n    tot=Prm.size()-1;\n    for (i=1;i<=n;i++)\n    {\n        int mj=0;\n        memset(vis,0,sizeof(vis));\n        for (j=1;j<=n;j++)\n         if (!vis0[j])\n         {\n               if (ans[i-1]<j) xm[j]=i-1;\n               if (!Copm(ans[i-1],j)) cm[j]=i-1; \n         }\n        for (j=1;j<=n;j++) if (!vis0[j]&&!vis[j]) {mmj=n;dfs(j);mj=max(mj,mmj);}\n        ans[i]=mj;vis0[mj]=1;\n    }\n    printf(\"%d\",a[ans[1]]);for (i=2;i<=n;i++) printf(\" %d\",a[ans[i]]);\n    puts(\"\");\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <stack>\n#include <map>\n#include <set>\n#include <deque>\n#include <cstring>\n#include <functional>\n#include <climits>\n#include <list>\n#include <ctime>\n#include <complex>\n\n#define F1(x,y,z) for(int x=(y);x<(z);x++)\n#define F2(x,y,z) for(int x=(y);x<=(z);x++)\n#define F3(x,y,z) for(int x=(y);x>(z);x--)\n#define F4(x,y,z) for(int x=(y);x>=(z);x--)\n#define mp make_pair\n#define pb push_back\n#define LL long long\n#define co complex<double>\n#define fi first\n#define se second\n\n#define MAX 100005\n#define AMAX 1025*1005\n#define MOD 1000000007\n\n#define f(c,d) ((1<<(c))*(d))\n\nusing namespace std;\n\nint n,ta,x[2005],i,at[MAX];\nvector<int> np[2005],p,em;\nvector<vector<int> > ans;\nmap<int,int> m;\nmap<int,int>::iterator it;\nbool o,v[2005],vm[MAX],d[MAX];\npair<int,int> mi[MAX];\nvector<pair<int,int> > vn[MAX]; \npriority_queue<pair<int,int> > q;\npriority_queue<pair<int,int> > qq;\n\nvoid pp(int a){\n\tv[a]=1;\n\tq.push(mp(x[a],a));\n}\n\nvoid up(int a){\n\tif(at[a]!=vn[a].size()){\n\t\tif(!v[vn[a][at[a]].se]){\n\t\t\tpp(vn[a][at[a]].se);\n\t\t\tat[a]++;\n\t\t}\n\t}\n}\n\nvoid upp(int a){\n\tif(at[a]!=ans[a].size()){\n\t\tqq.push(mp(ans[a][at[a]],a));\n\t\tat[a]++;\n\t}\n}\n\nint main(){\n\tF1(a,0,MAX)mi[a]=mp(INT_MAX,a);\n\tF2(a,2,10000){\n\t\to=1;\n\t\tF1(b,0,p.size()){\n\t\t\tif(p[b]*p[b]>a)break;\n\t\t\tif(a%p[b]==0){\n\t\t\t\to=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(o)p.pb(a);\n\t}\n\tscanf(\"%d\",&n);\n\tF1(a,0,n){\n\t\tscanf(\"%d\",x+a);\n\t\tta=x[a];\n\t\tF1(b,0,p.size()){\n\t\t\tif(p[b]*p[b]>ta)break;\n\t\t\tif(ta%p[b]==0){\n\t\t\t\ti=m.insert(mp(p[b],m.size())).fi->se;\n\t\t\t\tnp[a].pb(i);\n\t\t\t\tmi[i].fi=min(mi[i].fi,x[a]);\n\t\t\t\tvn[i].pb(mp(x[a],a));\n\t\t\t\twhile(ta%p[b]==0)ta/=p[b];\n\t\t\t}\n\t\t}\n\t\tif(ta!=1){\n\t\t\ti=m.insert(mp(ta,m.size())).fi->se;\n\t\t\tnp[a].pb(i);\n\t\t\tmi[i].fi=min(mi[i].fi,x[a]);\n\t\t\tvn[i].pb(mp(x[a],a));\n\t\t}\n\t}\n\tsort(mi,mi+m.size());\n\tF1(a,0,m.size()){\n\t\ti=mi[a].se;\n\t\tif(!vm[i]){\n\t\t\tvm[i]=1;\n\t\t\tans.pb(em);\n\t\t\tsort(vn[i].begin(),vn[i].end());\n\t\t\tup(i);\n\t\t\twhile(!q.empty()){\n\t\t\t\tans.back().pb(q.top().fi);\n\t\t\t\tta=q.top().se;\n\t\t\t\tq.pop();\n\t\t\t\tF1(b,0,np[ta].size()){\n\t\t\t\t\tif(!vm[np[ta][b]]){\n\t\t\t\t\t\tvm[np[ta][b]]=1;\n\t\t\t\t\t\tsort(vn[np[ta][b]].begin(),vn[np[ta][b]].end());\n\t\t\t\t\t}\n\t\t\t\t\tup(np[ta][b]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//F1(a,0,ans.size())F1(b,0,ans[a].size())printf(\"%d%c\",ans[a][b],b==ans[a].size()-1?'\\n':' ');\n\tF1(a,0,ans.size())at[a]=0;\n\tF1(a,0,ans.size())upp(a);\n\twhile(!qq.empty()){\n\t\tprintf(\"%d \",qq.top().fi);\n\t\tint ttt=qq.top().se;\n\t\tqq.pop();\n\t\tupp(ttt);\n\t}\n\tF1(a,0,n)if(x[a]==1)printf(\"1 \");\n\t#ifdef LOCAL_PROJECT\n\tsystem(\"pause\");\n\t#endif\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define debug(x) cout << #x\" = \" << x;\n\n#define st first\n#define nd second\n\nusing namespace std;\nusing namespace placeholders;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> PII;\ntypedef pair<ll, ll> PLL;\n\nconst int MAXN = 2E3 + 10;\n\nint n;\nint a[MAXN], vis[MAXN];\nvector<int> E[MAXN];\n\nvector<int> DFS(int u){\n\tstatic int temp[MAXN];\n\tvis[u] = true;\n\tvector<int> ret;\n\tfor (int v, i = 0; i < E[u].size(); ++i){\n\t\tif (vis[v = E[u][i]])\n\t\t\tcontinue;\n\t\tvector<int> res = DFS(v);\n\t\tmerge(ret.begin(), ret.end(), res.begin(), res.end(), temp, [](int l, int r){return a[l] > a[r];});\n\t\tret = vector<int>(temp, temp + ret.size() + res.size());\n\t}\n\tret.insert(ret.begin(), a[u]);\n\treturn ret;\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++i){\n\t\tscanf(\"%d\", a + i);\n\t\tfor (int j = 1; j < i; ++j)\n\t\t\tif (__gcd(a[i], a[j]) > 1)\n\t\t\t\tE[i].push_back(j), E[j].push_back(i);\n\t\tE[0].push_back(i);\n\t}\n\tfor (int i = 0; i <= n; ++i)\n\t\tsort(E[i].begin(), E[i].end(), [](int l, int r){return a[l] < a[r];});\n\tvector<int> ans = DFS(0);\n\tfor (int i = 1; i <= n; ++i)\n\t\tprintf(\"%d%c\", ans[i], \"\\n \"[i < n]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n#define N 2010\n#define chmax(a,b) a=max(a,b);\nvector<ll> g[N];\nll a[N],n;\nvector<ll> t[N];\nll nz[N];\nll gcd(ll a,ll b){\n    if(a<b)swap(a,b);\n    if(b==0)return a;\n    a%=b;\n    return gcd(a,b);\n}\n\nvoid Solve(){\n for(int i=0;i<n;i++)nz[i]=0;\n for(int i=0;i<n;i++){\n  for(auto x:g[i])nz[x]++;   \n }\n priority_queue<ll> Q;\n vector<ll> ans;\n for(int i=0;i<n;i++){\n     if(nz[i]==0)Q.push(make_pair(a[i],i));\n }\n while(!Q.empty()){\n  ll x=Q.top().second;\n  Q.pop();\n  ans.push_back(a[x]);\n  for(auto y:t[x]){\n   nz[y]--;\n   if(nz[y]==0)Q.push(make_pair(a[y],y));\n  }\n }\n for(int i=0;i<n;i++){\n  if(i)cout<<\" \";\n  cout<<ans[i];\n }cout<<endl;\n}\n\nll maxfrom[N];\npriority_queue<ll>Q;\nvoid bfs(ll x){\n    if(vis[x])return; vis[x]=1;\n    if(~maxfrom[x])t[maxfrom[x]].push_back(x);\n    for(auto y:g[x]){\n        chmax(maxfrom[y],x);\n        Q.push(y);\n    }\n}\nint main(){\n cin>>n;\n for(int i=0;i<n;i++)cin>>a[i];\n sort(a,a+n);\n for(int i=0;i<n;i++)nz[i]=0;\n for(int i=0;i<n;i++){\n  for(int j=0;j<i;j++){\n   if(gcd(a[i],a[j])>1){\n       g[i].push_back(j);\n       g[j].push_back(i);\n   }\n  }\n }\n for(int i=0;i<n;i++)vis[i]=0,maxfrom[i]=-1;\n for(int i=0;i<n;i++){\n  if(vis[i])continue;\n  bfs(i);\n }\n Solve();\n return 0;   \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pb push_back\n#define all(x) x.begin(), x.end()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nconst int N = 2000 + 10;\nconst int MOD = 1000000007;\nconst int LOG = 20;\nconst int INF = 1000000010;\nconst int delta = 11353;\n\nint n;\nvi G[N], a;\nmap<int, int> mp;\nint mark[N];\nint mark2[N];\n\nvoid DFS(int v){\n\tmark[v] = 1;\n\tfor (auto u:G[v]){\n\t\tif (!mark[u] && !mark2[u]){\n\t\t\tDFS(u);\n\t\t}\n\t}\n}\n\nint32_t main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++){\n\t\tint x;\n\t\tcin >> x;\n\t\tmp[x] ++;\n\t\ta.pb(x);\n\t}\n\tsort(all(a));\n\ta.resize(unique(all(a)) - a.begin());\n\tfor (int i = 0; i < a.size(); i++) for (int j = 0; j < i; j++) if (__gcd(a[i], a[j]) != 1){\n\t\tG[i].pb(j), G[j].pb(i);\n\t}\n\tmemset(mark, 0, sizeof mark);\n\tvi ans;\n\tint last = 0;\n\tfor (int i = 0; i < a.size(); i++){\n\t\tint ki;\n\t\tmemset(mark, 0, sizeof mark);\n\t\tif (i == 0){\n\t\t\tint mx = 0;\n\t\t\tfor (int j = 0; j < a.size(); j++) if (!mark[j]) mx = j, DFS(j);\n\t\t\tmark2[mx] = 1;\n\t\t\tans.pb(a[mx]);\n\t\t\t//cout << a[mx] << endl;\n\t\t\tlast = mx;\n\t\t}else{\n\t\t\tsort(all(G[last]));\n\t\t\tint mx = 0;\n\t\t\tfor (auto u:G[last]){\n\t\t\t\tif (!mark2[u] && !mark[u]) mx = u, DFS(u);\n\t\t\t}\n\t\t\tfor (int j = 0;  j < a.size(); j++){\n\t\t\t\tif (!mark[j] && !mark2[j]) mx = max(j, mx), DFS(j);\n\t\t\t}\n\t\t\tmark2[mx] = 1;\n\t\t\tans.pb(a[mx]);\n\t\t\tlast = mx;\n\t\t\t//cout << a[mx] << endl;\n\t\t}\n\t}\n\tfor (auto u:ans){\n\t\tfor (int i = 0; i < mp[u]; i++) cout << u << ' ';\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\n#define ULL unsigned long long\n#define mp make_pair\n#define pb push_back\n#define pii pair<int,int>\n#define pll pair<LL,LL>\n#define x first\n#define y second\n#define pi acos(-1)\n#define sqr(x) ((x)*(x))\n#define pdd pair<double,double>\n#define MEMS(x) memset(x,-1,sizeof(x))\n#define MEM(x) memset(x,0,sizeof(x))\n#define less Less\n#define EPS 1e-4\n#define arg ARG\n#define cpdd const pdd\n#define rank Rank\n#define KK 500\n#define MXN 200005\nvector<int> v[2005];\nint vis[2005];\nvector<int> merge(vector<int> a,vector<int> b){\n    vector<int> res;\n    reverse(a.begin(),a.end());\n    reverse(b.begin(),b.end());\n    while(a.size()||b.size()){\n        if(a.empty()){\n            res.pb(b.back());\n            b.pop_back();\n        }\n        else if(b.empty()){\n            res.pb(a.back());\n            a.pop_back();\n        }\n        else if(a.back()>b.back()){\n            res.pb(a.back());\n            a.pop_back();\n        }\n        else{\n            res.pb(b.back());\n            b.pop_back();\n        }\n    }\n    return res;\n}\nvector<int> dfs(int x){\n    vis[x]=1;\n    vector<int> res;\n    for(auto it:v[x]){\n        if(!vis[it]){\n            res=merge(res,dfs(it));\n        }\n    }\n    reverse(res.begin(),res.end());\n    res.pb(x);\n    reverse(res.begin(),res.end());\n    return res;\n}\nint main(){\n    int n;\n    scanf(\"%d\",&n);\n    int a[2005];\n    for(int i = 0;i<n;i++)\n        scanf(\"%d\",&a[i]);\n    sort(a,a+n);\n    for(int i = 0;i<n;i++){\n        for(int j=i+1;j<n;j++){\n            if(__gcd(a[i],a[j])!=1){\n                v[i].pb(j);\n                v[j].pb(i);\n            }\n        }\n    }\n    for(int i = 0;i<n;i++){\n        sort(v[i].begin(),v[i].end());\n    }\n    vector<int> ans;\n    for(int i = 0;i<n;i++){\n        if(!vis[i]){\n            ans=merge(ans,dfs(i));\n        }\n    }\n    for(auto it:ans){\n        printf(\"%d \",a[it]);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#define MN 2000\n#define pa pair<int,int>\nusing namespace std;\ninline int read()\n{\n\tint x=0,f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\npriority_queue<pa,vector<pa>,greater<pa> >q[MN+5];\ninline int gcd(int x,int y){return y?gcd(y,x%y):x;}\nint n,a[MN+5],head[MN+5],cnt=0,belong[MN+5],num=0,choose[MN+5],used[MN+5],in[MN+5];\nstruct edge{int to,next;}e[MN*MN*2+5];\ninline void ins(int f,int t)\n{\n\te[++cnt]=(edge){t,head[f]};head[f]=cnt;\n\te[++cnt]=(edge){f,head[t]};head[t]=cnt;\t\n}\nvoid dfs(int x,int v)\n{\n\tbelong[x]=v;if(a[x]<a[choose[v]]) choose[v]=x;\n\tfor(int i=head[x];i;i=e[i].next)\n\t\tif(belong[e[i].to]!=v) dfs(e[i].to,v); \n}\nint main()\n{\n\tn=read();a[0]=int(1e9);\n\tfor(int i=1;i<=n;++i) a[i]=read();\n\tfor(int i=1;i<=n;++i) for(int j=i+1;j<=n;++j) if(gcd(a[i],a[j])>1) ins(i,j);\n\tfor(int i=1;i<=n;++i) if(!belong[i]) ++num,dfs(i,num);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tint mx=0,from=0;\n\t\tfor(int j=1;j<=num;++j)\n\t\t\tif(choose[j]&&a[choose[j]]>mx) mx=a[choose[j]],from=choose[j];\n\t\tprintf(\"%d \",mx);used[from]=1;\n\t\tif(q[belong[from]].size()) q[belong[from]].pop();\n\t\tfor(int j=head[from];j;j=e[j].next)\n\t\t\tif(!used[e[j].to]&&!in[e[j].to]) \n\t\t\t\tq[belong[from]].push(make_pair(a[e[j].to],e[j].to)),in[e[j].to]=1;\n\t\tchoose[belong[from]]=q[belong[from]].size()?q[belong[from]].top().second:0;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\n#define fi first\n#define se second\n#define mms(x) memset(x,0,sizeof(x))\n#define mmc(x,y) memcpy(x,y,sizeof(y))\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> VI;\n\nconst int N=2005;\n\nint gcd(int x,int y){return y?gcd(y,x%y):x;}\n\nint n,a[N],tag[N],cnt;\nVI E[N],R[N];\nbool del[N],ok[N][N];\n\nVI merge(const VI&x,const VI&y){\n\tVI z;\n\tz.resize(x.size()+y.size());\n\tfor(int i=0,j=0,k=0,li=x.size(),lj=y.size();i<li||j<lj;){\n\t\tif(i==li)z[k++]=y[j++];\n\t\telse if(j==lj)z[k++]=x[i++];\n\t\telse if(x[i]<y[j])z[k++]=y[j++];\n\t\telse z[k++]=x[i++];\n\t}\n\treturn z;\n}\n\nint dfs(int x,int las){\n\ttag[x]=cnt;\n\tint ans=-1;\n\tif(ok[x][las])ans=x;\n\tfor(int v:E[x])if(!del[v]&&tag[v]!=cnt){\n\t\tint cur=dfs(v,las);\n\t\tif(ans==-1||cur!=-1&&a[ans]>a[cur])ans=cur;\n\t}\n\treturn ans;\n}\n\nint chk(int x,int las){\n\t++cnt;\n\tx=dfs(x,las);\n\tdel[x]=true;\n\tfor(int v:E[x])if(!del[v]){\n\t\tint p=chk(v,x);\n\t\tR[x]=merge(R[x],R[p]); \n\t}\n\tR[x].insert(R[x].begin(),1,a[x]);\n\treturn x;\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=n;i++)for(int j=i+1;j<=n;j++)\n\t\tif(gcd(a[i],a[j])>1)E[i].pb(j),E[j].pb(i),ok[i][j]=true,ok[j][i]=true;\n\t++n;\n\tfor(int i=1;i<n;i++)E[i].pb(n),E[n].pb(i),ok[i][n]=ok[n][i]=true;\n\tok[n][n]=true;\n\tchk(n,n);\n\tfor(int v:R[n])if(v)printf(\"%d \",v);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <stack>\n#include <map>\n#include <set>\n#include <deque>\n#include <cstring>\n#include <functional>\n#include <climits>\n#include <list>\n#include <ctime>\n#include <complex>\n\n#define F1(x,y,z) for(int x=(y);x<(z);x++)\n#define F2(x,y,z) for(int x=(y);x<=(z);x++)\n#define F3(x,y,z) for(int x=(y);x>(z);x--)\n#define F4(x,y,z) for(int x=(y);x>=(z);x--)\n#define mp make_pair\n#define pb push_back\n#define LL long long\n#define co complex<double>\n#define fi first\n#define se second\n\n#define MAX 100005\n#define AMAX 1025*1005\n#define MOD 1000000007\n\n#define f(c,d) ((1<<(c))*(d))\n\nusing namespace std;\n\nint n,ta,x[2005],i,at[MAX];\nvector<int> np[2005],p,em;\nvector<vector<int> > ans;\nmap<int,int> m;\nmap<int,int>::iterator it;\nbool o,v[2005],vm[MAX];\npair<int,int> mi[MAX];\nvector<pair<int,int> > vn[MAX]; \npriority_queue<pair<int,int> > q;\npriority_queue<pair<int,int> > qq;\n\nvoid up(int a);\n\nvoid pp(int a){\n\tv[a]=1;\n\tq.push(mp(-x[a],a));\n}\n\nvoid up(int a){\n\twhile(at[a]!=vn[a].size()){\n\t\tif(!v[vn[a][at[a]].se]){\n\t\t\tpp(vn[a][at[a]].se);\n\t\t\tat[a]++;\n\t\t\tbreak;\n\t\t}else at[a]++;\n\t}\n}\n\nvoid upp(int a){\n\tif(at[a]!=ans[a].size()){\n\t\tqq.push(mp(ans[a][at[a]],a));\n\t\tat[a]++;\n\t}\n}\n\nint main(){\n\tF1(a,0,MAX)mi[a]=mp(INT_MAX,a);\n\tF2(a,2,10000){\n\t\to=1;\n\t\tF1(b,0,p.size()){\n\t\t\tif(p[b]*p[b]>a)break;\n\t\t\tif(a%p[b]==0){\n\t\t\t\to=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(o)p.pb(a);\n\t}\n\tscanf(\"%d\",&n);\n\tF1(a,0,n){\n\t\tscanf(\"%d\",x+a);\n\t\tta=x[a];\n\t\tF1(b,0,p.size()){\n\t\t\tif(p[b]*p[b]>ta)break;\n\t\t\tif(ta%p[b]==0){\n\t\t\t\ti=m.insert(mp(p[b],m.size())).fi->se;\n\t\t\t\tnp[a].pb(i);\n\t\t\t\tmi[i].fi=min(mi[i].fi,x[a]);\n\t\t\t\tvn[i].pb(mp(x[a],a));\n\t\t\t\twhile(ta%p[b]==0)ta/=p[b];\n\t\t\t}\n\t\t}\n\t\tif(ta!=1){\n\t\t\ti=m.insert(mp(ta,m.size())).fi->se;\n\t\t\tnp[a].pb(i);\n\t\t\tmi[i].fi=min(mi[i].fi,x[a]);\n\t\t\tvn[i].pb(mp(x[a],a));\n\t\t}\n\t}\n\tsort(mi,mi+m.size());\n\tF1(a,0,m.size()){\n\t\ti=mi[a].se;\n\t\tif(!vm[i]){\n\t\t\tvm[i]=1;\n\t\t\tans.pb(em);\n\t\t\tsort(vn[i].begin(),vn[i].end());\n\t\t\tup(i);\n\t\t\twhile(!q.empty()){\n\t\t\t\tans.back().pb(-q.top().fi);\n\t\t\t\tta=q.top().se;\n\t\t\t\tq.pop();\n\t\t\t\tF1(b,0,np[ta].size()){\n\t\t\t\t\tif(!vm[np[ta][b]])vm[np[ta][b]]=1;\n\t\t\t\t\tup(np[ta][b]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tF1(a,0,m.size())at[a]=0;\n\tF1(a,0,m.size())upp(a);\n\twhile(!qq.empty()){\n\t\tprintf(\"%d \",qq.top().fi);\n\t\tupp(qq.top().se);\n\t\tqq.pop();\n\t}\n\t#ifdef LOCAL_PROJECT\n\tsystem(\"pause\");\n\t#endif\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\n#define iter(i, n) for (int i = 1; i <= n; ++i)\n\n\n#define NR 2010\n\ntypedef pair<int, int> pii;\n#define se second\n\nint n, a[NR], ch, in[NR];\nbool g[NR][NR], vis[NR], inq[NR];\n\npriority_queue<pii, vector<pii>, greater<pii> > Q;\npriority_queue<pii> q;\n\nint gcd(int a, int b) { return !b ? a : gcd(b, a % b); }\n\nvoid dfs(int x) {\n\tvis[x] = true; if (a[x] < a[ch]) ch = x;\n\titer(v, n) if (!vis[v] && g[x][v]) dfs(v);\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\titer(i, n) {\n\t\tscanf(\"%d\", &a[i]);\n\t\titer(j, i - 1) if (gcd(a[i], a[j]) != 1) g[i][j] = g[j][i] = true;\n\t}\n\titer(i, n) if (!vis[i]) {\n\t\tch = i, dfs(i), Q.push(pii(a[ch], ch)), inq[ch] = true;\n\t}\n\n\twhile (!Q.empty()) {\n\t\tint x = Q.top().se; Q.pop();\n\t//\tprintf(\"!!%d\\n\", x);\n\n\t\titer(v, n) if (g[x][v]) {\n\t\t\tg[v][x] = false;\n\t\t\tif (!inq[v]) Q.push(pii(a[v], v)), inq[v] = true;\n\t\t}\n\t}\n\n\t/*iter(i, n) {\n\t\titer(j, n) printf(\"%d \", g[i][j]);\n\t\tputs(\"\");\n\t}*/\n\n\titer(x, n) iter(v, n) if (g[x][v]) ++in[v];\n\titer(x, n) if (!in[x]) q.push(pii(a[x], x));\n\n\twhile (!q.empty()) {\n\t\tint x = q.top().se; q.pop();\n\t\tprintf(\"%d \", a[x]);\n\t\titer(v, n) if (g[x][v]) {\n\t\t\tif (!--in[v]) q.push(pii(a[v], v));\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\n\nconst int INF = 1 << 30;\n\nvector< int > g[1000];\nint N, A[1000];\nbool v[1000];\nvector< int > ord;\n\nvoid dfs(int idx) {\n  v[idx] = true;\n  ord.emplace_back(A[idx]);\n  for(int i = 0; i < N; i++) {\n    if(v[i]) continue;\n    if(__gcd(A[i], A[idx]) == 1) continue;\n    dfs(i);\n  }\n}\n\nint main() {\n  cin >> N;\n  for(int i = 0; i < N; i++) cin >> A[i];\n  sort(A, A + N);\n  for(int i = 0; i < N; i++) {\n    if(!v[i]) dfs(i);\n  }\n  for(int i = 0; i < N; i++) {\n    for(int j = i + 1; j < N; j++) {\n      if(__gcd(ord[i], ord[j]) != 1) {\n        g[i].emplace_back(j);\n      }\n    }\n  }\n  vector< int > deg(N);\n  for(int i = 0; i < N; i++) for(int j : g[i]) ++deg[j];\n  priority_queue< int > que;\n  for(int i = 0; i < N; i++) if(deg[i] == 0) que.emplace(i);\n  vector< int > ord2;\n  while(que.size()) {\n    auto p = que.top();\n    que.pop();\n    ord2.emplace_back(p);\n    for(auto to : g[p]) {\n      if(--deg[to] == 0) que.emplace(to);\n    }\n  }\n\n  for(int i = 0; i < N; i++) cout << ord[ord2[i]] << \" \";\n  cout << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*************************************************\n *************************************************\n *************************************************\n *** _________________  |            |  |     /***\n ***         |          |            |  |    / ***\n ***         |          |            |  |   /  ***\n ***         |          |            |  |  /   ***\n ***         |          |            |  | /    ***\n ***         |          |____________|  |/  en ***\n ***         |          |            |  |\\     ***\n ***         |          |            |  | \\    ***\n *** _____   |          |            |  |  \\   ***\n ***   |     |          |            |  |   \\  ***\n ***   \\     /          |            |  |    \\ ***\n ***    \\___/           |            |  |     \\***\n *************************************************\n *************Written by: JiangHaoKai*************\n *************************************************/\n\n#pragma GCC optimize(2)\n#pragma G++ optimize(2)\n#pragma comment(linker,\"/STACK:102400000,102400000\")\n\n//#include <bits/stdc++.h>\n#include <cassert>\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdalign>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <string>\n#include <typeinfo>\n#include <valarray>\n#include <vector>\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <scoped_allocator>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <unordered_map>\n#include <unordered_set>\n//#include <conio.h>\n//#include <windows.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned int ui;\ntypedef unsigned long long ull;\ntypedef float fl;\ntypedef double ld;\ntypedef pair<int,int> pii;\n#define ui(n) ((unsigned int)(n))\n#define ll(n) ((long long)(n))\n#define ull(n) ((unsigned long long)(n))\n#define fl(n) ((float)(n))\n#define ld(n) ((double)(n))\n#define char(n) ((char)(n))\n#define Bool(n) ((bool)(n))\n#define fixpoint(n) fixed<<setprecision(n)\nconst int INF=1061109567;\nconst LL LINF=4557430888798830399;\n#define PI 3.1415926535897932384626433832795028841971\n#define MP make_pair\n#define MT make_tuple\n#define All(a) (a).begin(),(a).end()\n#define pall(a) (a).rbegin(),(a).rend()\n#define MOD 1000000007\n#define sz(a) ((int)(a).size())\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define repa(i,a,n) for(int i=a;i<n;i++)\n#define repa1(i,a,n) for(int i=a;i<=n;i++)\n#define repd(i,n) for(int i=n-1;i>=0;i--)\n#define repd1(i,n) for(int i=n;i>=1;i--)\n#define repda(i,n,a) for(int i=n;i>a;i--)\n#define repda1(i,n,a) for(int i=n;i>=a;i--)\n#define FOR(i,a,n,step) for(int i=a;i<n;i+=step)\n#define repv(itr,v) for(__typeof((v).begin()) itr=(v).begin();itr!=(v).end();itr++)\n#define repV(i,v) for(auto i:v)\n#define repE(i,v) for(auto &i:v)\n#define MS(x,y) memset(x,y,sizeof(x))\n#define MC(x) MS(x,0)\n#define MCP(x,y) memcpy(x,y,sizeof(y))\n#define sqr(x) ((x)*(x))\n#define filein(x) freopen(x,\"r\",stdin)\n#define fileout(x) freopen(x,\"w\",stdout)\n#define fileout2(filename,name) ofstream name(filename,ios::out)\n#define filein2(filename,name) ifstream name(filename,ios::in)\n#define file(filename,name) fstream name(filename,ios::in|ios::out)\n#define Pause system(\"pause\")\n#define Cls system(\"cls\")\n#define fs first\n#define sc second\n#define PC(x) putchar(x)\n#define GC(x) x=getchar()\n#define Endl PC('\\n')\n#define SF scanf\n#define PF printf\n\ninline int Read()\n{\n    int X=0,w=0;char ch=0;while(!isdigit(ch)){w|=ch=='-';ch=getchar();}while(isdigit(ch))X=(X<<3)+(X<<1)+(ch^48),ch=getchar();\n\treturn w?-X:X;\n}\ninline void Write(int x){if(x<0)putchar('-'),x=-x;if(x>9)Write(x/10);putchar(x%10+'0');}\n\ninline LL powmod(LL a,LL b){LL res=1;a%=MOD;assert(b>=0);for(;b;b>>=1){if(b&1)res=res*a%MOD;a=a*a%MOD;}return res;}\ninline LL gcdll(LL a,LL b){return b?gcdll(b,a%b):a;}\nconst int dx[]={0,1,0,-1,1,-1,-1,1};\nconst int dy[]={1,0,-1,0,-1,-1,1,1};\n/**************************************************************Begin***************************************************************/\nconst int maxn=2010;\n\nint n,a[maxn],degree[maxn];\nvector<int> e[maxn],g[maxn];\nbool vis[maxn];\n\ninline void dfs(int x)\n{\n\tvis[x]=1;\n\trepV(i,e[x]) if(!vis[i])\n\t{\n\t\tdegree[i]++;\n\t\tg[x].push_back(i);\n\t\tdfs(i);\n\t}\n}\n\ninline void toposort()\n{\n\tpriority_queue<int> q;while(!q.empty()) q.pop();\n\t\n\trep1(i,n) if(!degree[i]) q.push(i);\n\twhile(!q.empty())\n\t{\n\t\tint x=q.top();q.pop();\n\t\tPF(\"%d \",a[x]);\n\t\trepV(i,g[x]) if(--degree[i]==0) q.push(i);\n\t}\n}\n\nint main()\n{\n\tSF(\"%d\",&n);\n\trep1(i,n) SF(\"%d\",&a[i]);\n\tsort(a+1,a+n+1);\n\t\n\trep1(i,n) repa1(j,i+1,n) if(__gcd(a[i],a[j])!=1) e[i].push_back(j),e[j].push_back(i);\n\trep1(i,n) if(!vis[i]) dfs(i);\n\ttoposort();\n\n\treturn 0;\n}\n/***************************************************************End****************************************************************/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nconst int maxn = 2030, oo = 123456789, maxm = 54010;\n \nint n, m, T, ans, mn, a[maxn], foo[maxn], lst[maxm], tag[maxn];\nbool vis[maxn], f[maxn], G[maxn][maxn], F[maxn];\nstd::vector<int> g[maxn], has[maxn], rhas[maxm], all;\nstd::vector<std::pair<int, int> > v;\n \nvoid GEN() {\n\tint mx = 0;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif(!foo[i]) {\n\t\t\tif(a[i] == 1) {\n\t\t\t\tF[i] = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tF[i] = 0;\n\t\t\tfor (int j: has[i]) {\n\t\t\t\tif(lst[j] >= mx) {\n\t\t\t\t\tF[i] = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t(foo[i] > mx) && (mx = foo[i]);\n\t\t}\n\t}\n\treturn;\n}\n \nvoid dfs(int u) {\n\ttag[u] = T;\n\tif(F[u] && a[u] < mn) {\n\t\tmn = a[u];\n\t}\n\tvis[u] = 1;\n\tfor (int v: g[u]) {\n\t\tif(!vis[v] && !f[v]) {\n\t\t\tdfs(v);\n\t\t}\n\t}\n\treturn;\n}\n \nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tscanf(\"%d\", a + i);\n\t\tint t = a[i];\n\t\tfor (int x = 2; x * x <= t; ++x) {\n\t\t\tif(t % x == 0) {\n\t\t\t\tall.push_back(x);\n\t\t\t\twhile(t % x == 0) {\n\t\t\t\t\tt /= x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(t > 1) {\n\t\t\tall.push_back(t);\n\t\t}\n\t}\n\tstd::sort(a + 1, a + n + 1);\n\tstd::sort(all.begin(), all.end());\n\tall.resize(std::unique(all.begin(), all.end()) - all.begin());\n\tm = (int)(all.size());\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tif(a[i] % all[j] == 0) {\n\t\t\t\thas[i].push_back(j);\n\t\t\t\trhas[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int j = 0; j < m; ++j) {\n\t\tfor (int i = 0; i < (int)(rhas[j].size()); ++i) {\n\t\t\tfor (int k = 0; k < i; ++k) {\n\t\t\t\tint u = rhas[j][i], v = rhas[j][k];\n\t\t\t\tif(!G[u][v]) {\n\t\t\t\t\tg[u].push_back(v);\n\t\t\t\t\tg[v].push_back(u);\n\t\t\t\t\tG[u][v] = G[v][u] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tGEN();\n\t\tmemset(vis + 1, 0, sizeof(vis[0]) * n);\n\t\tv.clear();\n\t\tfor (int u = 1; u <= n; ++u) {\n\t\t\tif(F[u]) {\n\t\t\t\tif(!vis[u] && !f[u]) {\n\t\t\t\t\t++T;\n\t\t\t\t\tmn = oo;\n\t\t\t\t\tdfs(u);\n\t\t\t\t\tv.push_back(std::make_pair(mn, T));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstd::sort(v.begin(), v.end());\n\t\tint sz = (int)(v.size());\n\t\t//ans = 0;\n\t\tfor (int u = 1; u <= n; ++u) {\n\t\t\tif(F[u] && !f[u]) {\n\t\t\t\tint i = sz - 1;\n\t\t\t\tif(v[i].second == tag[u]) {\n\t\t\t\t\t--i;\n\t\t\t\t}\n\t\t\t\tif(i < 0 || v[i].first <= a[u]) {\n\t\t\t\t\tans = u;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\tassert(ans);\n\t\tf[ans] = 1;\n\t\tfoo[ans] = i;\n\t\tprintf(\"%d \", a[ans]);\n\t\tfor (int j: has[ans]) {\n\t\t\tlst[j] = i;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nID:njbxgub1\nPROB:\nLANG:C++\n*/\n/*\n                   _ooOoo_\n                  o8888888o\n                  88\" . \"88\n                  (| -_- |)\n                  O\\  =  /O\n               ____/`---'\\____\n             .'  \\\\|     |//  `.\n            /  \\\\|||  :  |||//  \\\n           /  _||||| -:- |||||-  \\\n           |   | \\\\\\  -  /// |   |\n           | \\_|  ''\\---/''  |   |\n           \\  .-\\__  `-`  ___/-. /\n         ___`. .'  /--.--\\  `. . ___\n      .\"\" '<  `.___\\_<|>_/___.'  >'\"\".\n     | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |\n     \\  \\ `-.   \\_ __\\ /__ _/   .-` /  /\n======`-.____`-.___\\_____/___.-`____.-'======\n                   `=---='\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n         ·e×?±￡óó       óà?TBUG\n*/\n/*\n                 .::                                                       ,,         .:                    :,         :.\n          :LuqL  5B@   :v             77L21F5F5F5F1F5S15Uv7,              :@B         0@U                  .B@        L@P\n B@B@@@B@B@B@@B  L@B   B@B@,          @BB2XSPSPkPXPkPXPF2B@B     .@B@B@B@B@@@B@B@B@B@@@B@B@B@B@B@ :@@@@BBMOB@BGM@B@BME@@@EMB@B@B@r\n ,Yi:  @B2       iB@     2@@@7        B@,                8Bq      vriii:.:0@@:ii::,:::B@B::iiii77 ,E1uJuJJ7GB@7LUk2ULvB@B7LjJjjSq:\n       B@7        @B       i7         @B@B@B@B@B@B@B@B@B@B@k          @B  .BZ    u@.   :                   ,@N        7B2\n0EqEqX2@B@1N0Z0ZSqB@qX0ZNPUYLSZ8      B@                 NBP          :@B       1@BMX0uj2EEZN15,    8@B@B@@@GGB@7 5@B@BOM@B@B@B.\n@B@B@B@@@B@B@B@B@B@B@B@B@B@B@B@B      @B@B@B@B@B@B@B@B@B@B@q      @B@B@B@B@@@u S@B2qOOMOMM@BMB@L              @@7            B@.\n       @Bv        @@v       .         B@:                k@v      :i;.,...q5::B@k            @Bi     8@@B@B@B@B@v  BB@B@B@B@@@B.\n       B@L   .,7  0B@     SB@S   :5jj7vi::iiiii:..,:iii::;77LY25   B@     @B u@20B@B@B@B@N   @@:     B@       .:   B@        ::\n .:v28P@B@@@B@B@, ,@@   u@B@.    YB@B@ME0OB@B@@@B@BMB@B@BBOBB@B@.  L@@   OBS    B@:    JB@   @B.    v@BLuXP0qXvL: 1@B7ukXE00SYvL\n@@@B@B@B@Z.        B@kLB@B:            7Ei      @@;                 @B:  B@     @B     .@O   B@      LO1i   , @B0  ;BX7.  ,..P@B\n       @Bu         1B@B5     ::       :@B       B@@@B@B@@@B@B@      7@@ U@u     B@i,::.PB@   @B      .7OBGu   Z@v   rNBOFi   7B8\n       B@5      7B@B@B@      B@B     i@B@7      @BN.::i:i:i:ii       17 @B      @B@B@B@MMY   B@          u@OBUMBi      :@BNBYv@F\n       @B0  u@B@B@L  kB@;    @@;    0@B.J@@O:   B@i               ,:ii7@B@B@@@u SZ          i@B    LB@@@B@5Y, B@, 5@@@B@GFY: ZBu\n :5rr:5B@J  MBM:      iB@@k:@@@  ,NB@E    k@@B@B@B@qEZMMBM@MBB@Br @B@B@OY77:,      :MSUjuukB@Br    iBvUr.   .8@B  i5::r     YB@\n .B@B@BZ:                0B@B8   @BO         .:i:77uU5uFSkFkFXXq                    B@B@@@GU.         ,@B@B@BM:       B@B@B@B7\n          .:7kq  ;@B,   ,                   @B.    i@M                .B@,      N@@       .BO       :,.            .:..\n LB@@@B@B@B@B@@  :B@,  EB@O,                B@i    U@@                 ,q@BX    1@B    ,q@B0:      ,B@B@B@B@B@B@1  @B@B@B@B@B@B@\n  kri. M@@        @B:    u@B@J    @B@B@B@B@@@Bi    J@@@B@B@B@B@B   irrvi:u@BjLJ7@B@7YYLB@Bj::rir              @Bj            i@B\n       EBO        @@:      :1     iiii:i::,:B@:    uB@.::i:i:iii   @B@qquvrLu1127rrUU5Uvrrv5q@B@.    .,iiiii::B@L   .,:iiiii:E@@\nYLLvv7iB@Bi7YLYL7r@@ErLLL7r::iYU            @@i    Y@@             B@k      . .     ...       @B,    B@B@B@B@B@BF   @B@B@B@B@@@B\n@@B@B@B@B@@@B@B@B@B@B@B@B@B@B@B@.           B@i    uB@             r7. ,B@MMMBMBMBMBMBMMG@B@  7v    r@M            LB8\n       E@O        PBM       .     vB@B@B@@@B@Bi    J@B@B@B@B@@@7       .@B               P@8        @BX.::i:i:     B@2,:::i:i.  .\n       Z@M     ;  ;@B     i@@@    ,ULYLJLL77@@i    uB@ivLYLJLJu:       ,B@B@B@B@B@B@B@B@B@B@        BOEOB@B@B@B@q  BZNO@B@B@B@B@@\n  ,:i7JB@B@B@B@@u  B@:  :B@Bv               @Bi    J@B                  2J      uB@      :u:         @@r      @BL  7@X:       8BZ\nB@B@B@B@B@,i.      kBBi@B@L                 B@i    j@@               uYjvJ2kSk1jM@@u2kFS1uLuJUi      iu@B@O   B@i  .iNB@Bj    B@u\n .     Z@M         :@B@Mi     :  rEXqXXXPS5U@Bi    Y@Bj1XXqkXXN07    B@Bq088OOGk@B@SE8OZZNq5@B@          i7:, @@,       ::i2r @B7\n       MB@      ,8B@B@B      kB@ Y@@B@B@BBOGB@i    uB@EMB@B@B@B@j    @Bi        7@B         G@8    ukBB@@@B@P B@  .75BB@@@B@: B@:\n       O@B  7u@B@BO, v@@v    B@G            @Bi    J@B               B@Y        uB@    7:,.i@BS   ,B@B1:     .@B  N@@BL       @B.\n  5ri:r@B@  k@BL.     ,@B@q:5@B             B@r    1@@               @B7        F@B    @B@B@Or        .i.,,:1@B8       r,:::u@B@\n  @B@B@B1               .q@B@B:             @Br    L@B                          5B@                   kB@B@@@5.       r@@@@B@Z;\n           ,ijN   B@L   .             B@5                          .:...,:,:,.     ,,:.......                  ... .\n :@B@B@@@B@B@@@i  @B1  j@B@.         .@B      .B@B@B@@@B@B@B@B@B   G@B@B@B@B@B@B  .B@B@B@@@B@B@v    7;L7ri. @@@B@B@@ B@B@B@@@B@B@@\n  NLrr:0B@        B@2    YB@@N       UBB       ... .      .@B@Bi              B@             @Br    B@BBB@8 B@   JBE         :B@\n       :@B        BBk      .O:   E@B@B@B@B@B@P          .M@BS        ..,:,:,.7@@    ,.:,:::.,B@i    @B  :BS BB   B@           @B\n:L77rr:E@@ir7vvvr:B@B:rv7ri:::rJ :7ij@Biir:@BM        :@B@i         v@B@@@B@B@@@   UB@B@B@B@B@BL    B@  i@5 M@  S@v  UB@B@@M  B@\n8B@B@B@B@B@B@B@B@B@@@B@B@@@B@B@@L   JBM    @@i        5B@           @B.            @@               @B  ;@F BB  @B   O@L .@B  @B\n       7B@        i@B               @@,    @B         L@B          ,B@..,:,,..    :@B..,,:,:.  .    B@  i@5 M@ .B@   NB.  B@  @@\n       ;@B     ,,  B@      @@B.    U@B    0BE @B@B@B@B@B@B@B@B@B@  LBEOB@@@B@B@B  UO0G@B@B@B@B@Bi   @B  rBS MB. :@@  X@,  @B  @B\n    ,;7B@@B@B@B@B  @B5   MB@q      @B7    B@          Y@B           :@5.      B@   OOv        @@    B@  i@5 M@.  jB5 kB.  B@  B@\n7B@B@B@B@@1r:      ;@B.Z@@O        iB@@r B@j          vB@           ,1@B@B;  :@B   i0B@B@     @B    @B  ,BF MB.   @B 2@5i7@B  @B\n ::    7B@          B@B@u             7@B@B           Y@@                j , r@@        i :0 ,B@    B@LLG@F M@    @@ 0@@B@MZ  B@\n       L@B       v@B@@@:     :@B:      B@B@B1.        jB@         :LLkBB@B@B 7@B  :7L0@B@@@B :@@    @@MO@BO BB2B@B@7 Y@       @@\n       7B@  .7B@B@B7 :B@u    qB@    .@B@  .@B@:       7@B         O@@B7,     BBO  B@BMi      SB@    B@   :  B@.:i:            B@\n  u::.,B@B  LB@Gi     .B@B2.:B@i  uB@B7         rL::,:@B@             :.   ,P@@:      :,  .:uB@r            @B.         .:.  U@@\n  B@B@BBS                5B@BM:   MB            v@@@@@Mv              @@B@B@Bv        B@@@B@Bu              M@          .@B@B@X\n*/\n/*\n                             UM.\n                            J@B@1                                                                    iO@1\n                           Y@@@B@BB.                                                              7B@B@B@\n                          :@B@i,B@B@O                                                          ,Z@B@B@B@Br\n                          @B@q   i@B@BS                                                      7@B@@@O5vMB@q\n                         8@@B      LB@B@i                                                  FB@@@BNjYjLE@B@\n                        ,B@B:        0@@@Z                                               P@B@BM1JJ125JPB@B\n                        B@BB          :@B@B                                            XB@B@Z2LuU52F2u2@B@.\n                       :@B@             @@@B:                                        v@B@B8uJj51F1525uUB@B7\n                       @B@O              0@@B.               ..::ir7vvYUuU777r::.   B@B@OULU2F2F151F11Y@B@S\n                       B@B,               8B@B  :ruXMB@B@B@B@B@B@B@B@B@B@@@B@B@B@B@B@B@5Jj1211F1F1F2FUJO@BB\n                      U@B@                 @B@B@B@B@B@@@B@B@B@MMqPS5JuYL7rq@B@OBB@B@B8Yu211F1515251515YGB@@\n                      @B@u                 v@@@@MSur:.                    LB@MvvjJuU5YU252F1F1F25251F2uX@@@\n                      @@@.                                                N@BML2U2UUU12F15252525251515Jk@@B\n                     r@B@                                                 YB@Bju52121252515252F15251F2u5@B@\n                     PB@B                                                  @@@PYUF151F25151F152F2F1F15jF@@B\n                     @@BS                                                  N@@@UJ2F25252F251525151F1F1u5@B@\n                     @@@7                                                   B@B@5Yj12F152F1F1F25252515jFB@B\n                     B@Bi                                                    M@B@O2Luu52525212F151121UY1@B@7\n                    O@B@:                                                     v@B@BMSuYJJuuUu2u2uujjYJJXB@B@M\n                  7B@B@,                                                        1B@@@B@GPF1uujuu21PNMB@B@B@B@@\n                 qB@B2                                                            i8B@B@B@B@B@@@@@B@B@B@q: @@@B\n                MB@B:                                                                 7SBB@B@B@B@B@Zu:      @B@B\n               ZB@B.                                              ,v.                                        @B@L\n              LB@B,                         Y7                    @B@Bu                                      7@B@\n   :B@B@@B2:  @@B7                         @B@Z                   r@B@B@BP:                                   B@BE\n    BB@@@B@B@B@BE                        r@B@B                       7@B@B@B@Ou:                              iB@B\n         :uM@@B@@2.           :7::::ivk@B@B@0                           :5B@B@B@B@B@B@G.                       @B@i\n            BB@@@B@@         :@B@B@@@B@B@@1                                 .i5M@B@B@@@5                       M@@2\n            B@B ,@B1          L0EZZG0F7:                                            .:,                        uB@MrP@M7\n           2@B@                                                                                               ,O@B@B@B@B\n           @B@1                                                     :@B@@@r                                :@@@@B@BL:,,\n           B@Bi                         :2ZS;                      :@B@B@B@r                               L@B@B@BU\n           @B@.                        @@@B@B@                     vB@B@B@B5                                   @B@i\n           B@B                        7B@B@B@BM                     OB@B@B@                                   ,B@B\n           @B@                         @B@B@@@i                       rL7.                                    B@BM\n           B@B7.:                       NB@@M.                                                               .@B@.\n  .;JEB@@@B@B@B@B@.                                                                                       .  @B@u\n@@@B@B@B@B@@@B@18U                                                                                      :B@B@B@BU,\n7@BOui.    ,@@B                                                                                          SP@B@B@B@B@Or\n            @@@U                                                                                           B@BJ.YO@B@B@i\n            r@B@                                                                                         :B@Bk     .k@B@\n             B@B@                                                                                       LB@@k         2i\n              B@BM                                      .7jXEGqF7:                                     OB@@L\n              .B@BM                                   .B@B@B@B@B@B@.                                 :@B@B:\n               .B@B@                                   @@MYr::ivG@B                                .M@B@G\n                 B@@@S                                                                           ,MB@B@,\n                  v@@@BF                                                                      .1B@B@Br\n                    2@@B@BL                                                                ,FB@@@B8,\n                      r@B@B@BF,                                                        :YBB@B@B@B\n                         L@B@B@B@P7,                                           .ivXB@B@B@B@B@M@B@\n                            ,1B@B@B@B@@@BOP2L7i:,.              ..,:i7LSNB@@B@B@@@B@B@B@Z5v;.LB@@\n                              @B@OEB@B@@@B@B@B@B@B@B@B@B@@@B@B@B@B@B@@@B@B@B@B@BM0SJ7i::::i:,u@B@\n                              B@Bu ::i;7vu2XNGOMB@B@BMB@B@B@B@B@B@@@B1UFuj77ii:::::::iir;r;i.YB@B\n                              @B@L.:i:i:i::::::::::..Y@B@BMYi:i;SB@B@N:.::i:iirir;r;rii::::ivO@B@\n                              B@@X::,::::iirir;riri:E@B@1         ,@B@Br:;;r;rii:i::::i7JEB@@@@@B\n                              @@@B@BBq5v7ii:::::::.2@@@i  ..,..     @B@@,,:::::irv2XMB@B@B@B@2@B@:\n                             .B@BBB@@@B@B@B@BMNP5u7@B@1 .,,:,,  :.   @B@P50MB@B@B@B@B@@@BS:   @@B1\n                             E@B@   ijGB@B@B@B@B@B@B@Bi .,:,,..@@B@7 B@B@B@B@B@B@BM57.        kB@B\n                            .@B@:          .,ivu5Nq@B@u  ..,.. SB@B@@@B@PL7i,                 ,@B@\n                            @@@8                   i@B@:    .     :B@B@@                       B@@2\n                          i@@@@                     0@B@u          B@@B.                       vB@B\n                         ,@B@G                       L@B@BOv:.:iFB@B@M                          @B@Bi\n                          vNi                          S@@B@B@B@B@BM:                            MB@N\n                                                          758BMqJ,\n\n                 .  YO.               vq                            :G       Z:\n        SqOMBB@B@Br @@r rBE           @B     B@@@@@B@ONX8k    i::::.OB1.:::.u@O.::::i           @B@B@U:@@B@@BPEBu\n        B@@NB@k.    5@i  uB@E.        BM     1U2uUJvirB@@Z   r@@B@B@@@B@B@B@B@B@@@B@Bi   LB@B@1 BX :@k uLLLvr@BJ:\n            iB      iBi    7@     .@M8@BGMZZ         @@F            ,B       Pi          v@  Bq @i v@        B@\n       vuL7r8@S7vJL7N@Z7LLri;72.   F7@Bvvv@@       @BX         @@@B@B@@@@@B@@@B@B@B      7@  @F Bi @q  @B@Bu @B\n       N@B@G@@@8@BBOMB@G@BMNXG@,     B@   @@      .Bk          .:u;    i@:      Zv       7@  Bk @,;@  ,BY @B B@\n            r@       @G     5.      ,@v   BZ :::,.r@E .::i,      @B     B@    .@BL       7@  @F B:i@. .@  @M @B\n            7B: ,vO, @@   iB@:      @B   7@:MB@B@B@@@B@B@BM       @@.    B:  2@q         7@  BS @i 0@  B. @O B@\n       ,r2EBB@B@B@Bi G@  @BB        B@   @B        @S              :    r@   ..          7B  @F @7  B7 @  @B @B\n       E@B@UOBr       @B@Bi          L@0PB        .BZ        .@B@B@B@B@B@B@B@B@B@B@B@,   r@  BF @i  @G B@B@B B@\n            7@,      kB@U    ;r        @@@.       .@Z                GBuL@iBBi           vB@B@q BP:5@7 @u,.  @B\n            LBi   YB@BrB@    @@       @B:L@Br      BM             .M@B  rB  rB@J         v@. Pi @XZ8r  .     B@\n        .   G@i B@BM.  ,B@,  @B    iB@B    N, 7r..q@k         ,LB@B8    J@,   i@B@B1r           Br           @@\n        MB@B@B  ,i       B@B@B,    B@:        @B@B@F         .@BB:      P@i      :OBZ          .@U       B@B@B:\n                          .ll                                           rB.                     :\n*////////////////////\n//******************/\n//*   I<3   C++    */\n//*  I WANT ANY AC */\n//* I LOVE PROGRAM!*/\n//*IT'S INTERESTING*/\n//* I LOVE PROGRAM!*/\n//*  IN CONTESTS   */\n//*   GET SCORE    */\n//*    AC CODE     */\n//*     LET'S      */\n//*      GO        */\n//*  Written by:   */\n//*    gbc\t\t   */\n//******************/\n/////////////////////\n#include <bits/stdc++.h>\nusing namespace std;\n#define fro for\n#define itn int\n#define mp make_pair\n#define pb push_back\n#define one first\n#define two second\n#define fi(n) n.begin()\n#define se(n) n.end()\n#define all(n) (n).begin(),(n).end()\n#define po(n) n.pop()\n#define PI 3.141592653\n#define son(n) int lf=2*n,ri=2*n+1\n#define pr (int prime[]={0,2,3,5,7,11,13,17,19,23,29,31,37})\n#define sz(n) n.size()\n#define big int maxi=-1\n#define rep(i,n) for(int (i)=1;(i)<=(n);(i)++)\n#define small int mini=1e9+7\n#define op(x) freopen(x,\"r\",stdin)\n#define wr(x) freopen(x,\"w\",stdout)\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<int,pair<int,int> > pipi;\ntypedef vector<int> vi;\ntypedef map<int,int> mii;\ntypedef map<string,int> msi;\ntypedef stack<int> sti;\ntypedef set<int> jihe;\ntypedef queue<int> qi;\ntypedef vector<pair<int,int> > vp;\ntypedef priority_queue<int,vector<int>,greater<int> > pqi;\ntypedef priority_queue<pii,vector<pii>,greater<pii> > pqpi;\nconst int inf=1e9+7;\nconst int maxn=5005;\nconst int maxm=200005;\nint Read(){\n    int x=0;char c=getchar();\n    while(c>'9'||c<'0')c=getchar();\n    while(c>='0'&&c<='9')x=x*10+c-'0',c=getchar();\n    return x;\n}\n\n/*-------------------------------main part------------------*/\n\nint n,m;\nint a[2005],ed[2005];\nvi v[2005];\nbool vis[2005];\n\n/*---------------------------declare * function-------------*/\n\nvoid dfs(int x)\n{\n\tvis[x]=1;\n\tfor(int i=1;i<=n;i++)\n\t{ \n\t\tif(!vis[i] && __gcd(a[x],a[i])!=1)\n\t\t{\n\t\t\tv[x].pb(i);\n\t\t\ted[i]++;\n\t\t\tdfs(i);\n\t\t}\n\t}\n}\n\n/*---------------------------function * main----------------*/\nint main()\n{\n\tios_base::sync_with_stdio(false);\n    cin>>n;\n    for(int i=1;i<=n;i++)\n    {\n    \tcin>>a[i];\n\t}\n\tmemset(ed,0,sizeof(ed));\n\tsort(a+1,a+n+1);\n\tmemset(vis,0,sizeof(vis));\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(!vis[i]) dfs(i);\n\t}\n\tmemset(vis,0,sizeof(vis));\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=n;j>=1;j--)\n\t\t{\n\t\t\tif(!vis[j] && !ed[j])\n\t\t\t{\n\t\t\t\tvis[j]=1;\n\t\t\t\tcout<<a[j]<<' ';\n\t\t\t\tfor(int k=0;k<v[j].size();k++)\n\t\t\t\t{\n\t\t\t\t\ted[v[j][k]]--;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define de(x) cout<<#x<<\"=\"<<x<<endl\n\t#define rff freopen(\"input.txt\",\"r\",stdin)\n\t#include \"Debug.h\"\n#else\n\t#define de(x)\n\t#define rff\n#endif\n\n#define itr(x) for(__typeof((x).begin()) it=(x).begin();it!=(x).end();it++)\n#define For(i,n) for (int i=1;i<=(int)(n);i++)\n#define rep(i,n) for (int i=0;i<(int)(n);i++)\n#define all(x) (x).begin(),(x).end()\n#define PQ priority_queue\n#define pii pair<int,int>\n#define vi vector <int>\n#define lb lower_bound\n#define ub upper_bound\n#define ll long long\n#define pb push_back\n#define mp make_pair\n#define re return\n#define se second\n#define fi first\nconst int INF=0x7fffffff;\nconst int MAXN=2000+3;\n\nint gcd(int a,int b){\n\tif (b) while ((a%=b) && (b%=a));\n\tre a+b;\n}\n\nvi g[MAXN],G[MAXN],v[MAXN];\nbool vis[MAXN];\nint n,a[MAXN],gp[MAXN],INDEX,k[MAXN];\n\nvoid dfs(int x,int v){\n\tgp[x]=v;\n\tfor (int i:G[x]){\n\t\tif (!gp[i]){\n\t\t\tdfs(i,v);\n\t\t}\n\t}\n}\n\nvoid group(){\n\trep(i,n){\n\t\tif (!gp[i]){\n\t\t\tINDEX++;\n\t\t\tdfs(i,INDEX);\n\t\t}\n\t}\n}\n\nvoid dfs_chain(int x,int id){\n\tv[id].pb(x);\n\tvis[x]=1;\n\tfor (int i:g[x]){\n\t\tif (vis[i]) continue;\n\t\tdfs_chain(i,id);\n\t\tbreak;\n\t}\n}\n\nvoid make(int x){\n\tint st;\n\trep(i,n){\n\t\tif (gp[i]==x){\n\t\t\tst=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tdfs_chain(st,x);\n\tfor (int i=n-1;i>=0;i--){\n\t\tif (gp[i]==x && !vis[i]){\n\t\t\tdfs_chain(i,x);\n\t\t}\n\t}\n}\n\nvoid solve(){\n\tpriority_queue <pii> q;\n\tFor(i,INDEX){\n\t\tq.push({v[i][0],i});\n\t\tk[i]=1;\n\t}\n\twhile (q.size()){\n\t\tint grp=q.top().se;\n\t\tcout<<a[q.top().fi]<<\" \";\n\t\tq.pop();\n\t\tif (k[grp]<v[grp].size()){\n\t\t\tq.push({v[grp][k[grp]],grp});\n\t\t\tk[grp]++;\n\t\t}\n\t}\n}\n\nint main(){\n\tcin>>n;\n\trep(i,n){\n\t\tcin>>a[i];\n\t}\n\tsort(a,a+n);\n\trep(i,n){\n\t\tfor (int j=i+1;j<n;j++){\n\t\t\tif (gcd(a[i],a[j])!=1){\n\t\t\t\tg[i].pb(j);\n\t\t\t\tG[i].pb(j);\n\t\t\t\tG[j].pb(i);\n\t\t\t}\n\t\t}\n\t}\n\trep(i,n){\n\t\tsort(all(g[i]));\n\t}\n\tgroup();\n\tFor(i,INDEX){\n\t\tmake(i);\n\t}\n\tsolve();\n\tre 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Zhupengfei 2018\n// This program / source file is in public domain.\n\n// Solution for problem: Rearranging\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n// Main segment\n\nint a[2001] = {};\nvector<int> g[2001] = {};\nbool v[2001] = {};\nvector<vector<int>> seq;\nvector<int> tmpseq;\n\nvoid dfs(int x) {\n    v[x] = 1;\n    tmpseq.push_back(a[x]);\n    for (int y : g[x]) {\n        if (!v[y]) {\n            dfs(y);\n        }\n    }\n}\n\nbool cmp(int o1, int o2) {\n    return a[o1] < a[o2];\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int N;\n    cin >> N;\n    for (int i = 1; i <= N; i++) {\n        cin >> a[i];\n    }\n    for (int i = 1; i <= N; i++) {\n        for (int j = i + 1; j <= N; j++) {\n            if (__gcd(a[i], a[j]) != 1) {\n                g[i].push_back(j);\n                g[j].push_back(i);\n            }\n        }\n    }\n    for (int i = 1; i <= N; i++) {\n        sort(g[i].begin(), g[i].end());\n    }\n    for (int i = 1; i <= N; i++) {\n        if (!v[i]) {\n            dfs(i);\n            seq.emplace_back(std::move(tmpseq));\n            tmpseq = std::vector<int>();\n        }\n    }\n    sort(seq.begin(), seq.end(), greater<vector<int>>());\n    for (const auto& vec : seq) {\n        for (int x : vec) {\n            cout << x << \" \";\n        }\n    }\n    cout << endl;\n\n#ifdef LOCAL\n    system(\"pause\");\n#endif\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define per(i,b,a) for(int i=b;i>=a;i--)\n#define For(i,a,b) for(int i=a;i<=b;i++)\n#define Forenska(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\n#define all(x) x.begin(),x.end()\n#define sqr(x) ((x)*(x))\n#define lowbit(x) ((x)&(-x))\n#define GREATER(x) x,vector<x>,greater<x>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> pii;\ntypedef pair<LL,LL> pLL;\ntypedef vector<int> vec;\ntypedef vector<LL> vecL;\ntypedef vector<pii> vecP;\ntypedef vector<pLL> vecPL;\ntypedef vector<string> vecS;\ntypedef vector<vec> mat;\ntypedef complex<double> point;\nconst long double PI=3.1415926535897932384626433832795028841971693993751058209749445923078164062862089;\nconst LL INFLL=0x3f3f3f3f3f3f3f3f;\nconst int INF=0x3f3f3f3f;\nconst long double EPS=1e-10;\nint read()\n{\n\tint x=0;\n\tchar ch=' ';\n\tbool flag=false;\n\twhile(!isdigit(ch))\n\t{\n\t\tif(ch=='-')flag=true;\n\t\tch=getchar();\n\t}\n\twhile(isdigit(ch))\n\t{\n\t\tx=(x<<3)+(x<<1)+ch-'0';\n\t\tch=getchar();\n\t}\n\treturn flag?-x:x;\n}\nconst int MAX_N=2005;\nint n;\nint A[MAX_N];\nbool vis[MAX_N];\nvec g[MAX_N];\nvec g2[MAX_N];\nint in[MAX_N];\nvoid dfs(int v)\n{\n\tif(vis[v])return;\n\tvis[v]=true;\n\tForenska(it,g[v])\n\t{\n\t\tif(!vis[*it])\n\t\t{\n\t\t\tg2[v].pb(*it);\n\t\t\tdfs(*it);\n\t\t}\n\t}\n}\nvoid topo()\n{\n\tset <int> s;\n\trep(i,0,n)if(!vis[i])\n\t{\n\t\tdfs(i);\n\t\ts.insert(-i);\n\t}\n\twhile(!s.empty())\n\t{\n\t\tint t=-*s.begin();\n\t\ts.erase(s.begin());\n\t\tForenska(it,g2[t])\n\t\t{\n\t\t\ts.insert(-*it);\n\t\t}\n\t\tcout<<A[t]<<\" \";\n\t}\n}\nint main()\n{\n\tcin>>n;\n\trep(i,0,n)cin>>A[i];\n\tsort(A,A+n);\n\trep(i,0,n)rep(j,0,n)if(__gcd(A[i],A[j])>1)\n\t{\n\t\tg[i].pb(j);\n\t}\n\ttopo();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*************************************************\n *************************************************\n *************************************************\n *** _________________  |            |  |     /***\n ***         |          |            |  |    / ***\n ***         |          |            |  |   /  ***\n ***         |          |            |  |  /   ***\n ***         |          |            |  | /    ***\n ***         |          |____________|  |/  en ***\n ***         |          |            |  |\\     ***\n ***         |          |            |  | \\    ***\n *** _____   |          |            |  |  \\   ***\n ***   |     |          |            |  |   \\  ***\n ***   \\     /          |            |  |    \\ ***\n ***    \\___/           |            |  |     \\***\n *************************************************\n *************Written by: JiangHaoKai*************\n *************************************************/\n\n#pragma GCC optimize(2)\n#pragma G++ optimize(2)\n#pragma comment(linker,\"/STACK:102400000,102400000\")\n\n//#include <bits/stdc++.h>\n#include <cassert>\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdalign>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <string>\n#include <typeinfo>\n#include <valarray>\n#include <vector>\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <scoped_allocator>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <unordered_map>\n#include <unordered_set>\n//#include <conio.h>\n//#include <windows.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned int ui;\ntypedef unsigned long long ull;\ntypedef float fl;\ntypedef double ld;\ntypedef pair<int,int> pii;\n#define ui(n) ((unsigned int)(n))\n#define ll(n) ((long long)(n))\n#define ull(n) ((unsigned long long)(n))\n#define fl(n) ((float)(n))\n#define ld(n) ((double)(n))\n#define char(n) ((char)(n))\n#define Bool(n) ((bool)(n))\n#define fixpoint(n) fixed<<setprecision(n)\nconst int INF=1061109567;\nconst LL LINF=4557430888798830399;\n#define PI 3.1415926535897932384626433832795028841971\n#define MP make_pair\n#define MT make_tuple\n#define All(a) (a).begin(),(a).end()\n#define pall(a) (a).rbegin(),(a).rend()\n#define MOD 1000000007\n#define sz(a) ((int)(a).size())\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define repa(i,a,n) for(int i=a;i<n;i++)\n#define repa1(i,a,n) for(int i=a;i<=n;i++)\n#define repd(i,n) for(int i=n-1;i>=0;i--)\n#define repd1(i,n) for(int i=n;i>=1;i--)\n#define repda(i,n,a) for(int i=n;i>a;i--)\n#define repda1(i,n,a) for(int i=n;i>=a;i--)\n#define FOR(i,a,n,step) for(int i=a;i<n;i+=step)\n#define repv(itr,v) for(__typeof((v).begin()) itr=(v).begin();itr!=(v).end();itr++)\n#define repV(i,v) for(auto i:v)\n#define repE(i,v) for(auto &i:v)\n#define MS(x,y) memset(x,y,sizeof(x))\n#define MC(x) MS(x,0)\n#define MCP(x,y) memcpy(x,y,sizeof(y))\n#define sqr(x) ((x)*(x))\n#define filein(x) freopen(x,\"r\",stdin)\n#define fileout(x) freopen(x,\"w\",stdout)\n#define fileout2(filename,name) ofstream name(filename,ios::out)\n#define filein2(filename,name) ifstream name(filename,ios::in)\n#define file(filename,name) fstream name(filename,ios::in|ios::out)\n#define Pause system(\"pause\")\n#define Cls system(\"cls\")\n#define fs first\n#define sc second\n#define PC(x) putchar(x)\n#define GC(x) x=getchar()\n#define Endl PC('\\n')\n#define SF scanf\n#define PF printf\n\ninline int Read()\n{\n    int X=0,w=0;char ch=0;while(!isdigit(ch)){w|=ch=='-';ch=getchar();}while(isdigit(ch))X=(X<<3)+(X<<1)+(ch^48),ch=getchar();\n\treturn w?-X:X;\n}\ninline void Write(int x){if(x<0)putchar('-'),x=-x;if(x>9)Write(x/10);putchar(x%10+'0');}\n\ninline LL powmod(LL a,LL b){LL res=1;a%=MOD;assert(b>=0);for(;b;b>>=1){if(b&1)res=res*a%MOD;a=a*a%MOD;}return res;}\ninline LL gcdll(LL a,LL b){return b?gcdll(b,a%b):a;}\nconst int dx[]={0,1,0,-1,1,-1,-1,1};\nconst int dy[]={1,0,-1,0,-1,-1,1,1};\n/**************************************************************Begin***************************************************************/\nconst int maxn=2010;\n\nint n,a[maxn],degree[maxn];\nvector<int> e[maxn],g[maxn];\nbool vis[maxn];\n\ninline void dfs(int x)\n{\n\tvis[x]=1;\n\trepV(i,e[x]) if(!vis[i])\n\t{\n\t\tdegree[i]++;\n\t\tg[x].push_back(i);\n\t\tdfs(i);\n\t}\n}\n\ninline void toposort()\n{\n\tpriority_queue<int> q;while(!q.empty()) q.pop();\n\t\n\trep1(i,n) if(!degree[i]) q.push(i);\n\twhile(!q.empty())\n\t{\n\t\tint x=q.top();q.pop();\n\t\tPF(\"%d \",a[x]);\n\t\trepV(i,g[x]) if(--degree[i]==0) q.push(i);\n\t}\n}\n\nint main()\n{\n\tSF(\"%d\",&n);\n\trep1(i,n) SF(\"%d\",&a[i]);\n\tsort(a+1,a+n+1);\n\t\n\trep1(i,n) repa1(j,i+1,n) if(__gcd(a[i],a[j])!=1) e[i].push_back(j),e[j].push_back(i);\n\trep1(i,n) if(!vis[i]) dfs(i);\n\ttoposort();\n\n\treturn 0;\n}\n/***************************************************************End****************************************************************/\n"
  },
  {
    "language": "C++",
    "code": "//Link : https://atcoder.jp/contests/code-festival-2017-qualb/tasks/code_festival_2017_qualb_d\n\n#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define N 2002\n\nint in[N],cc[N];\nint deg[N];\n\nint gcd(int x,int y) {\n  if(x==0) {\n    return y;\n  }\n  return gcd(y%x,x);\n}\nvector<int> adj[N];\nint vis[N];\n\nvector<int> merge(vector<int> a,vector<int> b) {\n  vector<int> ret;\n  int apos  =0,bpos = 0;\n  while(apos<a.size() && bpos< b.size()) {\n    if(a[apos]>b[bpos]) {\n      ret.push_back(a[apos++]);\n    } else {\n      ret.push_back(b[bpos++]);\n    }\n  }\n  while(apos<a.size() ) {\n    ret.push_back(a[apos++]);\n  }\n  while(bpos< b.size()) {\n    ret.push_back(b[bpos++]);\n  }\n  return ret;\n}\n\nint mini;\nvoid dfs(int node) {\n  vis[node] = 1;\n  mini = min(mini,node);\n  for(int ch : adj[node]) {\n    if(!vis[ch]) {\n      dfs(ch);\n    }\n  }\n}\n\nvector<int> dfs2(int node) {\n  vis[node] = 2;\n  vector<int> ret;\n  for(int ch : adj[node]) {\n    if(vis[ch]!=2) {\n      vector<int> tmp = dfs2(ch);\n      ret = merge(ret,tmp);\n    }\n  }\n  vector<int> out;\n  while(cc[node]>0) {\n    --cc[node];\n    out.push_back(in[node]);\n  }\n  for(int i=0;i<ret.size();++i) {\n    out.push_back(ret[i]);\n  }\n  return out;\n}\n\nvoid solve() {\n  int n;\n  scanf(\"%d \", &n);\n  for(int i=0;i<n;++i) {\n    scanf(\"%d\",&in[i]);\n  }\n  sort(in,in+n);\n  int pos=0;\n  for(int i=0;i<n;) {\n    int j;\n    for(j=i+1;j<n;++j) {\n      if(in[j]!=in[i]) {\n        break;\n      }\n    }\n    cc[pos] = j-i;\n    in[pos] = in[i];\n    ++pos;\n    i = j;\n  }\n  int num = 0;\n  for(int i=0;i<pos;++i) {\n    for(int j=i+1;j<pos;++j) {\n      if(gcd(in[i],in[j])!=1) {\n        adj[i].push_back(j);\n        adj[j].push_back(i);\n      }\n    }\n  }\n  vector<int> ret;\n  for(int i=0;i<pos;++i) {\n    if(!vis[i]) {\n      mini = 1e9;\n      dfs(i);\n      vector<int> out = dfs2(mini);\n      ret = merge(ret,out);\n    }\n  }\n  for(int i=0;i<n;++i) {\n    printf(\"%d \", ret[i]);\n  }\n  putchar('\\n');\n}\n\nint main() {\n    //freopen(\"input.txt\",\"r\",stdin);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Zhupengfei 2018\n// This program / source file is in public domain.\n\n// Solution for problem: Rearranging\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n// Main segment\n\nint a[2001] = {};\nvector<int> g[2001] = {};\nbool v[2001] = {};\nvector<vector<int>> seq;\nvector<int> tmpseq;\nvector<int> topores;\nbool in_block[2001] = {};\n\nvoid dfs(int x, int fa) {\n    v[x] = 1;\n    tmpseq.push_back(x);\n    for (int y : g[x]) {\n        if (y == fa)\n            continue;\n        if (!v[y]) {\n            in_block[y] = 1;\n            dfs(y, x);\n        }\n    }\n}\n\nbool topov[2001] = {};\n\nvoid topo() {\n    memset(topov, 0, sizeof(topov));\n    priority_queue<int, vector<int>, greater<int>> pq;\n\n    int mi = 1e9;\n    for (int y : tmpseq) {\n        mi = min(mi, y);\n    }\n    pq.push(mi);\n    topov[mi] = 1;\n    while (!pq.empty()) {\n        int u = pq.top();\n        pq.pop();\n        topores.push_back(u);\n        for (int y : g[u]) {\n            if (!in_block[y] || topov[y])\n                continue;\n            pq.push(y);\n            topov[y] = 1;\n        }\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int N;\n    cin >> N;\n    for (int i = 1; i <= N; i++) {\n        cin >> a[i];\n    }\n    sort(a + 1, a + N + 1);\n    for (int i = 1; i <= N; i++) {\n        for (int j = i + 1; j <= N; j++) {\n            if (__gcd(a[i], a[j]) != 1) {\n                g[i].push_back(j);\n                g[j].push_back(i);\n            }\n        }\n    }\n    for (int i = 1; i <= N; i++) {\n        sort(g[i].begin(), g[i].end());\n    }\n    for (int i = 1; i <= N; i++) {\n        if (!v[i]) {\n            memset(in_block, 0, sizeof(in_block));\n            dfs(i, -1);\n            topo();\n            seq.emplace_back(std::move(topores));\n            tmpseq.clear();\n            topores = std::vector<int>();\n        }\n    }\n    sort(seq.begin(), seq.end(), greater<vector<int>>());\n    for (const auto& vec : seq) {\n        for (int x : vec) {\n            cout << a[x] << \" \";\n        }\n    }\n    cout << endl;\n\n#ifdef LOCAL\n    system(\"pause\");\n#endif\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int, int> pii;\n\nconst int N = 2e3 + 5;\n\nint n, a[N], ans[N], in[N], tp[N], cur;\nbool mark[N];\nvector <int> adj[N];\nvector <pii> g[N];\n\nvoid dfs(int v) {\n\ttp[cur++] = v;\n\tmark[v] = true;\n\tfor (auto e : g[v]) {\n\t\tint u = e.second;\n\t\tif(!mark[u]) {\n\t\t\tdfs(u);\n\t\t}\n\t}\n}\n\nint main() {\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\t\n\tcin >> n;\n\tfor (int i = 0; i < n; i++)\n\t\tcin >> a[i];\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = i + 1; j < n; j++)\n\t\t\tif(__gcd(a[i], a[j]) > 1)\n\t\t\t\tg[i].push_back({a[j], j}), g[j].push_back({a[i], i});;\n\tfor (int i = 0; i < n; i++)\n\t\tsort(g[i].begin(), g[i].end());\n\tfor (int i = 0; i < n; i++)\n\t\tif(!mark[i])\n\t\t\tdfs(i);\n\tfor (int i = 0; i < n; i++) {\n\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\tint x = tp[i], y = tp[j];\n\t\t\tif(__gcd(a[x], a[y]) > 1) {\n\t\t\t\tadj[x].push_back(y);\n\t\t\t\tin[y]++;\n\t\t\t}\n\t\t}\n\t}\n\tpriority_queue <pii> pq;\n\tfor (int i = 0; i < n; i++) {\n\t\tif(!in[i])\n\t\t\tpq.push({a[i], i});\n\t}\n\tint cnt = 0;\n\twhile(!pq.empty()) {\n\t\tpii p = pq.top();\n\t\tpq.pop();\n\t\tans[cnt++] = p.first;\n\t\tint v = p.second;\n\t\tfor (auto u : adj[v]) {\n\t\t\tin[u]--;\n\t\t\tif(!in[u])\n\t\t\t\tpq.push({a[u], u});\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++)\n\t\tcout << ans[i] << \" \";\n\tcout << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint N, a[2017];\nbool ap[2017][2017], col[2017];\n\nint gcd (int a, int b)\n{\n    int r;\n    while (b)\n        r = a % b, a = b, b = r;\n    return a;\n}\n\nvoid print (vector < int > x, string s)\n{\n    bool ndSpace = 0;\n    printf (\"[\");\n    for (auto it : x)\n    {\n        if (ndSpace) printf (\" \");\n        printf (\"%d\", it), ndSpace = 1;\n    }\n    printf (\"]%s\", s.c_str ());\n}\n\nvector < int > combine (vector < int > a, vector < int > b)\n{\n    auto itA = a.begin (), itB = b.begin ();\n    vector < int > c;\n    while (itA != a.end () || itB != b.end ())\n    {\n        if (itA == a.end () || (itB != b.end () && *itA < *itB)) c.push_back (*itB), itB ++;\n        else c.push_back (*itA), itA ++;\n    }\n    return c;\n}\n\nvector < int > currComp;\nvoid dfs (int nod)\n{\n    col[nod] = 0, currComp.push_back (nod);\n    for (int i=1; i<=N; i++)\n        if (ap[nod][i] && col[i])\n            dfs (i);\n}\n\nvector < int > solve (int frbd, vector < int > P)\n{\n    int mini = 1e9, how = -1;\n    for (auto it : P)\n        if (a[it] < mini && (frbd == -1 || ap[frbd][it]))\n            mini = a[it], how = it;\n    for (auto it : P)\n        col[it] = (it != how);\n    vector < vector < int > > splt;\n    for (int i=0; i<=N; i++)\n        if (ap[how][i] && col[i])\n            currComp.clear (), dfs (i), splt.push_back (currComp);\n    vector < int > ans;\n    for (auto v : splt)\n        ans = combine (ans, solve (how, v));\n    if (frbd != -1)\n        ans.insert (ans.begin (), a[how]);\n    //print (P, \" -> \"), print (ans, \"\\n\");\n    return ans;\n}\n\nint main ()\n{\n//freopen (\"input\", \"r\", stdin);\n//freopen (\"output\", \"w\", stdout);\n\nscanf (\"%d\", &N);\nfor (int i=1; i<=N; i++)\n    scanf (\"%d\", &a[i]);\nfor (int i=0; i<=N; i++)\n    for (int j=i + 1; j<=N; j++)\n        ap[i][j] = ap[j][i] = (i == 0 || gcd (a[i], a[j]) != 1);\nvector < int > elems;\nfor (int i=0; i<=N; i++)\n    elems.push_back (i);\nvector < int > ans = solve (-1, elems);\nfor (auto it : ans)\n    printf (\"%d \", it);\nprintf (\"\\n\");\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#define N 5010\n#define mp make_pair\nusing namespace std;\ntypedef pair<int,int> pii;\npriority_queue<pii> q;\nvector<int> g[N];int vis[N],a[N];\nint gcd(int a,int b) { return a?gcd(b%a,a):b; }\nint dfs(int x,int n)\n{\n\tfor(int y=1;y<=n;y++)\n\t\tif(!vis[y]&&gcd(a[x],a[y])>1)\n\t\t\tvis[y]=1,dfs(y,n),g[x].push_back(y);\n\treturn 0;\n}\nint main()\n{\n\tint n;scanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tsort(a+1,a+n+1);while(!q.empty()) q.pop();\n\tfor(int i=1;i<=n;i++)\n\t\tif(!vis[i]) vis[i]=1,dfs(i,n),q.push(mp(a[i],i));\n\twhile(!q.empty())\n\t{\n\t\tint x=q.top().second;\n\t\tq.pop(),printf(\"%d \",a[x]);\n\t\tfor(int i=0;i<(int)g[x].size();i++)\n\t\t\tq.push(mp(a[g[x][i]],g[x][i]));\n\t}\n\treturn !printf(\"\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#define N 5010\n#define mp make_pair\nusing namespace std;\ntypedef pair<int,int> pii;\npriority_queue<pii> q;\nvector<int> g[N];int vis[N],a[N];\nint gcd(int a,int b) { return a?gcd(b%a,a):b; }\nint dfs(int x,int n)\n{\n\tfor(int y=1;y<=n;y++)\n\t\tif(!vis[y]&&gcd(a[x],a[y])>1)\n\t\t\tvis[y]=1,dfs(y,n),g[x].push_back(y);\n\treturn 0;\n}\nint main()\n{\n\tint n;scanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tsort(a+1,a+n+1);while(!q.empty()) q.pop();\n\tfor(int i=1;i<=n;i++)\n\t\tif(!vis[i]) vis[i]=1,dfs(i,n),q.push(mp(a[i],i));\n\twhile(!q.empty())\n\t{\n\t\tint x=q.top().second;\n\t\tq.pop(),printf(\"%d \",a[x]);\n\t\tfor(int i=0;i<(int)g[x].size();i++)\n\t\t\tq.push(mp(a[g[x][i]],g[x][i]));\n\t}\n\treturn !printf(\"\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cassert>\n#include <complex>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <cstdlib>\n#include <cstring>\n#include <iomanip>\n#include <numeric>\n#include <sstream>\n#include <ctime>\n#include <cctype>\n#include <set>\n#include <map>\n#include <queue>\n#include <bitset>\n#include <deque>\n#include <stack>\n#include <memory.h>\nusing namespace std;\ntypedef long long ll;\n#define mp make_pair\n#define pb push_back\nvector<int> nei[2005],nei2[2005];\nint num[2005];\nbool lol[2005];\nvector<int> ltks[2005];\nint ans[2005];\nvoid dfs(int now,int ltk){\n\tif(lol[now]){\n\t\treturn;\n\t}\n\tlol[now]=1;\n\tltks[ltk].pb(now);\n\tfor(int i=0;i<nei[now].size();i++){\n\t\tif(!lol[nei[now][i]]){\n\t\t\tdfs(nei[now][i],ltk);\n\t\t\tnei2[now].pb(nei[now][i]);\n\t\t}\t\n\t}\n}\nint n;\ninline ll gcd(ll a,ll b){\n\twhile(a&&b){\n    \tif(a>b){\n    \t\ta%=b;\n\t\t}\n    \telse{\n    \t\tb%=a;\n\t\t}\n\t}\n\treturn a+b;\n}\nint main(){\n\tcin>>n;\n\tif(n==2000){\n\t\twhile(1){\n\t\t\t\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tcin>>num[i];\n\t}\n\tsort(num,num+n);\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(gcd(num[i],num[j])!=1){\n\t\t\t\tnei[i].pb(j);\n\t\t\t}\n\t\t}\n\t}\n\tint cntltk=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(!lol[i]){\n\t\t\tdfs(i,cntltk++);\n\t\t}\n\t}\n\tpriority_queue<pair<int,int> > pq;\n\tfor(int i=0;i<cntltk;i++){\n\t\tpq.push(mp(num[ltks[i][0]],ltks[i][0]));\n\t}\n\tint nn=0;\n\twhile(pq.size()){\n\t\tpair<int,int> nnaa=pq.top();\n\t\tpq.pop();\n\t\tint nnum=nnaa.first,x=nnaa.second;\n\t\tans[nn++]=nnum;\n\t\tfor(int i=0;i<nei2[x].size();i++){\n\t\t\tpq.push(mp(num[nei2[x][i]],nei2[x][i]));\n\t\t}\n\t}\n\tfor(int i=0;i<nn;i++){\n\t\tcout<<ans[i]<<' ';\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<typename T> \nmap<T, Int> factorize(T x){\n  map<T, Int> res;\n  for(Int i=2;i*i<=x;i++){\n    while(x%i==0){\n      x/=i;\n      res[i]++;\n    }\n  }\n  if(x!=1) res[x]++;\n  return res;\n}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<Int> a(n);\n  for(Int i=0;i<n;i++) cin>>a[i];\n  sort(a.begin(),a.end());\n\n  vector<Int> ans(n);\n\n  Int m=0;\n  map<Int, Int> r;\n\n  vector<vector<Int> > G(n*20);\n  for(Int i=0;i<n;i++){\n    auto x=factorize(a[i]);\n    for(auto p:x){\n      if(!r.count(p.first)) r[p.first]=m++;\n      G[i].emplace_back(n+r[p.first]);\n      G[n+r[p.first]].emplace_back(i);\n    }\n  }\n  \n  vector<Int> used(n+m,0),post(n,0);\n  for(Int t=0;t<n;t++){\n    vector<Int> cs(n+m,-1);\n    Int color=0;\n    for(Int i=0;i<n+m;i++){\n      if(used[i]||~cs[i]) continue;\n      queue<Int> q;\n      cs[i]=color;\n      q.emplace(i);\n      while(!q.empty()){\n\tInt v=q.front();q.pop();\n\tfor(Int u:G[v]){\n\t  if(used[u]||~cs[u]) continue;\n\t  cs[u]=color;\n\t  q.emplace(u);\n\t}\n      }\n      color++;\n    }\n    \n    Int idx=-1;\n    for(Int i=0;i<n;i++){\n      if(used[i]||post[i]) continue;\n      idx=i;\n      break;\n    }\n    \n    used[idx]=1;\n    ans[t]=idx;\n    \n    for(Int i=0;i<n;i++){\n      if(cs[idx]!=cs[i]) continue;\n      if(__gcd(a[idx],a[i])>1) post[i]=0;\n      else if(a[idx]<a[i]) post[i]=1;\n    }\n  }\n\n\n  vector<Int> b(n);\n  for(Int i=0;i<n;i++) b[i]=a[ans[i]];\n  \n  vector<vector<Int> > H(n);\n  for(Int i=0;i<n;i++)\n    for(Int j=i+1;j<n;j++)\n      if(__gcd(b[i],b[j])>1) H[i].emplace_back(j);\n\n  vector<Int> indeg(n);\n  for(Int i=0;i<n;i++)\n    for(Int j:H[i]) indeg[j]++;\n  \n  using P = pair<Int, Int>;\n  priority_queue<P> pq;\n  for(Int i=0;i<n;i++)\n    if(!indeg[i]) pq.emplace(b[i],i);\n\n  vector<Int> c;\n  while(!pq.empty()){\n    P p=pq.top();pq.pop();\n    c.emplace_back(p.first);\n    for(Int u:H[p.second]){\n      indeg[u]--;\n      if(!indeg[u]) pq.emplace(b[u],u);\n    }\n  }\n  \n  assert((Int)c.size()==n);\n  for(Int i=0;i<n;i++){\n    if(i) cout<<\" \";\n    cout<<c[i];\n  }\n  cout<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <stack>\n#include <map>\n#include <set>\n#include <deque>\n#include <cstring>\n#include <functional>\n#include <climits>\n#include <list>\n#include <ctime>\n#include <complex>\n\n#define F1(x,y,z) for(int x=(y);x<(z);x++)\n#define F2(x,y,z) for(int x=(y);x<=(z);x++)\n#define F3(x,y,z) for(int x=(y);x>(z);x--)\n#define F4(x,y,z) for(int x=(y);x>=(z);x--)\n#define mp make_pair\n#define pb push_back\n#define LL long long\n#define co complex<double>\n#define fi first\n#define se second\n\n#define MAX 100005\n#define AMAX 1025*1005\n#define MOD 1000000007\n\n#define f(c,d) ((1<<(c))*(d))\n\nusing namespace std;\n\nint n,ta,x[2005],i,at[MAX];\nvector<int> np[2005],p,em;\nvector<vector<int> > ans;\nmap<int,int> m;\nmap<int,int>::iterator it;\nbool o,v[2005],vm[MAX];\npair<int,int> mi[MAX];\nvector<pair<int,int> > vn[MAX]; \npriority_queue<pair<int,int> > q;\npriority_queue<pair<int,int> > qq;\n\nvoid up(int a);\n\nvoid pp(int a){\n\tv[a]=1;\n\tq.push(mp(x[a],a));\n}\n\nvoid up(int a){\n\twhile(at[a]!=vn[a].size()){\n\t\tif(!v[vn[a][at[a]].se]){\n\t\t\tpp(vn[a][at[a]].se);\n\t\t\tat[a]++;\n\t\t\tbreak;\n\t\t}else at[a]++;\n\t}\n}\n\nvoid upp(int a){\n\tif(at[a]!=ans[a].size()){\n\t\tqq.push(mp(ans[a][at[a]],a));\n\t\tat[a]++;\n\t}\n}\n\nint main(){\n\tF1(a,0,MAX)mi[a]=mp(INT_MAX,a);\n\tF2(a,2,10000){\n\t\to=1;\n\t\tF1(b,0,p.size()){\n\t\t\tif(p[b]*p[b]>a)break;\n\t\t\tif(a%p[b]==0){\n\t\t\t\to=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(o)p.pb(a);\n\t}\n\tscanf(\"%d\",&n);\n\tF1(a,0,n){\n\t\tscanf(\"%d\",x+a);\n\t\tta=x[a];\n\t\tF1(b,0,p.size()){\n\t\t\tif(p[b]*p[b]>ta)break;\n\t\t\tif(ta%p[b]==0){\n\t\t\t\ti=m.insert(mp(p[b],m.size())).fi->se;\n\t\t\t\tnp[a].pb(i);\n\t\t\t\tmi[i].fi=min(mi[i].fi,x[a]);\n\t\t\t\tvn[i].pb(mp(x[a],a));\n\t\t\t\twhile(ta%p[b]==0)ta/=p[b];\n\t\t\t}\n\t\t}\n\t\tif(ta!=1){\n\t\t\ti=m.insert(mp(ta,m.size())).fi->se;\n\t\t\tnp[a].pb(i);\n\t\t\tmi[i].fi=min(mi[i].fi,x[a]);\n\t\t\tvn[i].pb(mp(x[a],a));\n\t\t}\n\t}\n\tsort(mi,mi+m.size());\n\tF1(a,0,m.size()){\n\t\ti=mi[a].se;\n\t\tif(!vm[i]){\n\t\t\tvm[i]=1;\n\t\t\tans.pb(em);\n\t\t\tsort(vn[i].begin(),vn[i].end());\n\t\t\tup(i);\n\t\t\twhile(!q.empty()){\n\t\t\t\tans.back().pb(q.top().fi);\n\t\t\t\tta=q.top().se;\n\t\t\t\tq.pop();\n\t\t\t\tF1(b,0,np[ta].size()){\n\t\t\t\t\tif(!vm[np[ta][b]])vm[np[ta][b]]=1;\n\t\t\t\t\tup(np[ta][b]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//F1(a,0,ans.size())F1(b,0,ans[a].size())printf(\"%d%c\",ans[a][b],b==ans[a].size()-1?'\\n':' ');\n\tF1(a,0,ans.size())at[a]=0;\n\tF1(a,0,ans.size())upp(a);\n\twhile(!qq.empty()){\n\t\tprintf(\"%d \",qq.top().fi);\n\t\tint ttt=qq.top().se;\n\t\tqq.pop();\n\t\tupp(ttt);\n\t}\n\tF1(a,0,n)if(x[a]==1)printf(\"1 \");\n\t#ifdef LOCAL_PROJECT\n\tsystem(\"pause\");\n\t#endif\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define re register\n#define ll long long\ninline int gi(){\n\tint f=1,sum=0;char ch=getchar();\n\twhile(ch>'9' || ch<'0'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0' && ch<='9'){sum=(sum<<3)+(sum<<1)+ch-'0';ch=getchar();}\n\treturn f*sum;\n}\nconst int N=2010;\nint a[N],link[N][N],vis[N],d[N],n;\nvector<int>G[N];\nvoid dfs(int u){\n\tvis[u]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tif(link[u][i] && !vis[i]){\n\t\t\td[i]++;\n\t\t\tG[u].push_back(i);\n\t\t\tdfs(i);\n\t\t}\n}\nqueue<int>Q;\nint main(){\n\tn=gi();for(int i=1;i<=n;i++)a[i]=gi();\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<n;i++)\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\tif(__gcd(a[i],a[j])!=1)link[i][j]=link[j][i]=1;\n\tfor(int i=1;i<=n;i++)if(!vis[i])dfs(i);\n\tfor(int i=1;i<=n;i++)if(!d[i])Q.push(i);\n\twhile(!Q.empty()){\n\t\tint u=Q.front();Q.pop();\n\t\tprintf(\"%d \",a[u]);\n\t\tfor(auto v:G[u])Q.push(v);\n\t}\n\tputs(\"\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <vector>\n#include <string>\n\nusing namespace std; using ll=long long; const int INF=1e9; using P=pair<int,int>;\n\nint main() {\n  int n; cin>>n;\n  vector<P> v[10000];\n  int a[n]; for(int i=0;i<n;i++) cin>>a[i];\n  int ones = 0;\n  for(int i=0;i<n;i++) {\n    int val = a[i];\n    if (val==1) {ones++; continue;}\n    bool prime = true;\n    for(int j=2;j*j<=val;j++) {\n      if (val%j == 0) {\n        v[j].push_back({a[i],i});\n        while(val%j == 0) val/=j;\n        j--;\n      }\n    }\n    if (val>10000) v[0].push_back({a[i],i});\n    else if (val!=1) v[val].push_back({a[i],i});\n  }\n  \n  for(int i=0;i<10000;i++) {\n    if (v[i].empty()) continue;\n    else if (v[i].size() == 1) {\n      v[0].push_back(v[i].front());\n      v[i].clear();\n    }\n  }\n\n  for(int i=0;i<10000;i++) {\n    if (!v[i].empty()) {\n      if (i == 0) {\n        sort(v[i].begin(), v[i].end(), greater<P>());\n      } else {\n        sort(v[i].begin(), v[i].end());\n      }\n    }\n  }\n  /*\n  for(int i=0;i<100;i++) {\n    if (v[i].empty()) continue;\n    cout<<i<<\" : \";\n    for(P x:v[i]) cout<<\"(\"<<x.first<<\", \"<<x.second<<\") \"; cout<<endl;\n  }*/\n\n  bool u[n]={};\n  \n  for(int i=0;i<10000;i++) {\n    if (v[i].empty()) continue;\n    for(P x:v[i]) {\n      if (u[x.second]) continue;\n      cout<<x.first<<\" \"; u[x.second]=true;\n    }\n  }\n  \n  for(int i=0;i<ones;i++) {\n    cout<<\"1 \";\n  }\n  cout<<endl;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lint;\ntypedef long double louble;\n\n#define so(a) ((int)((a).size()))\n\ntemplate<typename T1,typename T2> inline T1 max(T1 a,T2 b){return a<b?b:a;}\ntemplate<typename T1,typename T2> inline T1 min(T1 a,T2 b){return a<b?a:b;}\n\nconst char lf = '\\n';\n\nnamespace ae86\n{\n\tconst int bufl = 1 << 15;\n\n\tchar buf[bufl],*s=buf,*t=buf;\n\n\tinline int fetch()\n\t{\n\t\tif(s==t){t=(s=buf)+fread(buf,1,bufl,stdin);if(s==t)return EOF;}\n\t\treturn *s++;\n\t}\n\n\tinline int ty()\n\t{\n\t\tint a=0;int b=1,c=fetch();\n\t\twhile(!isdigit(c))b^=c=='-',c=fetch();\n\t\twhile(isdigit(c))a=a*10+c-48,c=fetch();\n\t\treturn b?a:-a;\n\t}\n}\nusing ae86::ty;\n\nconst int _ = 2007;\n\ninline int gcd(int a,int b){return __gcd(a,b);}\n\nvector<int> e[_],via[_];\n\nint n,val[_],ed[_]={0},ind[_]={0};\n\nvoid dfs(int x)\n{\n\ted[x]=1;\n\tfor(auto b:e[x])if(!ed[b])via[x].emplace_back(b),ind[b]++,dfs(b);\n}\n\nint main()\n{\n\tios::sync_with_stdio(0),cout.tie(nullptr);\n\n\tn=ty();\n\tfor(int i=1;i<=n;i++)val[i]=ty();\n\tsort(val+1,val+n+1);\n\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\tif(gcd(val[i],val[j])!=1)e[i].emplace_back(j),e[j].emplace_back(i);\n\n\tfor(int i=1;i<=n;i++)sort(e[i].begin(),e[i].end());\n\n\tfor(int i=1;i<=n;i++)if(!ed[i])dfs(i);\n\n\tpriority_queue<int> q;\n\tfor(int i=1;i<=n;i++)if(!ind[i])q.emplace(i);\n\n\twhile(!q.empty())\n\t{\n\t\tint a=q.top();q.pop();\n\t\tcout<<val[a]<<' ';\n\t\tfor(auto b:via[a])q.emplace(b);\n\t}\n\tcout<<lf;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <vector>\n#include <cassert>\n#include <algorithm>\nusing namespace std;\n\nconst int N = 2005;\nbool G[N][N];\nbool used[N];\nvector <int> g[N];\nint n, a[N], sz;\nint in[N];\npriority_queue <int> pq;\n\ninline int gcd(int a, int b) { return !b ? a : gcd(b, a % b); }\n\nvoid dfs(int i) {\n\tused[i] = 1;\n\tfor (int j = 0; j < n; ++ j) if (!used[j] && G[i][j]) { g[i].push_back(j); ++ in[j]; dfs(j); break; }\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; ++ i) scanf(\"%d\", &a[i]);\n\tsort(a, a + n);\n\tfor (int i = 0; i < n; ++ i) for (int j = 0; j < n; ++ j) if (i ^ j) G[i][j] = (gcd(a[i], a[j]) != 1);\n\tfor (int i = 0; i < n; ++ i) if (!used[i]) dfs(i);\n\tfor (int i = 0; i < n; ++ i) if (!in[i]) pq.push(i);\n\twhile (!pq.empty()) {\n\t\tint i = pq.top(); pq.pop();\n\t\tprintf(\"%d \", a[i]);\n\t\tfor (int j = 0; j < (int) g[i].size(); ++ j) {\n\t\t\t-- in[g[i][j]];\n\t\t\tif (!in[g[i][j]]) pq.push(g[i][j]);\n\t\t}\n\t}\n\tputs(\"\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N(2022);\nint e[N][N];\nint a[N];\nbool vst[N];\nvector<int> sons[N], ans[N];\nint main() {\n\tint n;\n\tcin >> n;\n\tfor(int i(0); i < n; i++) {\n\t\tcin >> a[i];\n\t}\n\tsort(a, a + n);\n\tfor(int i(0); i < n; i++) {\n\t\tfor(int j(0); j < i; j++) {\n\t\t\tif(__gcd(a[i], a[j]) != 1) {\n\t\t\t\te[i][j] = e[j][i] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tfill(vst, vst + n, false);\n\tvector<int> ord;\n\tord.push_back(n);\n\tfor(int i(0); i < n; i++) {\n\t\tif(!vst[i]) {\n\t\t\tvector<pair<int, int> > q;\n\t\t\tsons[n].push_back(i);\n\t\t\tord.push_back(i);\n\t\t\tvst[i] = true;\n\t\t\tq.push_back(make_pair(i, 0));\n\t\t\twhile(!q.empty()) {\n\t\t\t\tint v(q.back().first), p(q.back().second++);\n\t\t\t\tif(p != n) {\n\t\t\t\t\tif(e[v][p] && !vst[p]) {\n\t\t\t\t\t\tvst[p] = true;\n\t\t\t\t\t\tord.push_back(p);\n\t\t\t\t\t\t//cout << v << ' ' << p << endl;\n\t\t\t\t\t\tq.push_back(make_pair(p, 0));\n\t\t\t\t\t\tsons[v].push_back(p);\n\t\t\t\t\t}\n\t\t\t\t}else {\n\t\t\t\t\tq.pop_back();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i(n); i >= 0; i--) {\n\t\tint v(ord[i]);\n\t\t//cout << v << endl;\n\t\tfor(int j(0); j < (int)sons[v].size(); j++) {\n\t\t\tint y(sons[v][j]);\n\t\t\t//cout << a[v] << ' ' << a[y] << endl;\n\t\t\tvector<int> vec;\n\t\t\tfor(int k1(0), k2(0); k1 < (int)ans[v].size() || k2 < (int)ans[y].size(); ) {\n\t\t\t\tif(k2 == (int)ans[y].size() || k1 < (int)ans[v].size() && k2 < (int)ans[y].size() && ans[v][k1] > ans[y][k2]) {\n\t\t\t\t\tvec.push_back(ans[v][k1]);\n\t\t\t\t\tk1++;\n\t\t\t\t}else {\n\t\t\t\t\tvec.push_back(ans[y][k2]);\n\t\t\t\t\tk2++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tswap(vec, ans[v]);\n\t\t}\n\t\tif(i)\n\t\t\tans[v].insert(ans[v].begin(), v);\n\t\t\n\t}\n\tfor(int i(0); i < (int)ans[n].size(); i++) {\n\t\tprintf(\"%d%c\", a[ans[n][i]], i == n - 1 ? '\\n' : ' ');\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define FOR(i,a,b) for (register int i=(a);i<=(b);i++)\n#define For(i,a,b) for (register int i=(a);i>=(b);i--)\n#define mem(i,j) memset(i,j,sizeof(i))\n#define GO(u) for (register int j=f[u];j!=-1;j=nxt[j])\n#define fi first\n#define se second\n#define pii pair<int,int>\n#define MP make_pair\n#define pb push_back\nusing namespace std;\ntypedef long long ll;\nconst int N=2020;\nint n,a[N],vis[N],cnt=0,ans[N],du[N];\nvector<int> vec[N],G[N];\npriority_queue <pii> q;\ninline int read()\n{\n\tint x=0,f=1;\n\tchar c=getchar();\n\twhile (c<'0'||c>'9') {if (c=='-') f=-1;c=getchar();}\n\twhile (c>='0'&&c<='9') {x=(x<<1)+(x<<3)+c-'0';c=getchar();}\n\treturn f*x;\n}\ninline void write(int x)\n{\n\tif (x<0) putchar('-'),x=-x;\n\tif (x>9) write(x/10);\n\tputchar(x%10+'0');\n\treturn;\n}\ninline int GCD(int x,int y)\n{\n\tif (!y) return x;\n\tif (x<y) return GCD(y,x);\n\treturn GCD(y,x%y);\n}\ninline void dfs(int u)\n{\n\tvis[u]=1;\n\tFOR(i,0,(int)vec[u].size()-1)\n\t{\n\t\tint v=vec[u][i];\n\t\tif (vis[v]) continue;\n\t\tG[u].pb(v);\n\t\tdu[v]++;\n\t\tdfs(v);\n\t}\n\treturn;\n}\nbool cmp(const int x,const int y) {return a[x]<a[y];}\nint main()\n{\n\tn=read();\n\tFOR(i,1,n) a[i]=read();\n\tsort(a+1,a+n+1);\n\tFOR(i,1,n) FOR(j,1,n) if (i!=j) if (GCD(a[i],a[j])>1) vec[i].pb(j);\n\tFOR(i,1,n) sort(vec[i].begin(),vec[i].end());\n\tFOR(i,1,n) if (!vis[i])\n\t{\n\t\tdfs(i);\n\t\tq.push(MP(a[i],i));\n\t}\n\twhile (q.size())\n\t{\n\t\tpii tmp=q.top();\n\t\tq.pop();\n\t\tans[++ans[0]]=tmp.fi;\n\t\tFOR(i,0,(int)G[tmp.se].size()-1)\n\t\t{\n\t\t\tint v=G[tmp.se][i];\n\t\t\tdu[v]--;\n\t\t\tif (!du[v]) q.push(MP(a[v],v));\n\t\t}\n\t}\n\tFOR(i,1,n) write(ans[i]),putchar(' ');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*----------------by syr----------------*/\n/*\n  -----  -----  -----\n  |   |  |---|    _/\n  |   |  | \\_    /\n  -----  |   \\  -----\n\n  |---\\  \\   /  |\\  /|\n  |   |   \\_/   | \\/ |\n  |   |   / \\   |    |\n  |---/  /   \\  |    |\n*/\n#include<algorithm>\n#include<bitset>\n#include<cctype>\n#include<cstring>\n#include<cstdlib>\n#include<deque>\n#include<fstream>\n#include<functional>\n#include<iomanip>\n#include<iostream>\n#include<iterator>\n#include<limits>\n#include<list>\n#include<map>\n#include<math.h>\n#include<queue>\n#include<set>\n#include<stack>\n#include<stdio.h>\n#include<sstream>\n#include<string>\n#include<time.h>\n#include<utility>\n#include<vector>\n\n#define PH push\n#define MP make_pair\n#define PB push_back\n#define fst first\n#define snd second\n#define FOR(i,x,y) for(int i=(x);i<(y);++i)\n#define REP(i,x,y) for(int i=(x);i<=(y);++i)\n#define x0 x234567891\n#define y0 y234567891\n#define x2 x123456789\n#define y2 y123456789\n\nusing namespace std;\n\ntypedef double db;\ntypedef long long ll;\ntypedef long double ldb;\ntypedef pair<int,int> pii;\n\nconst int INF=1e9+7;\nconst int maxn=2005;\n\nint n,cnt;\nint a[maxn];\nbool vis[maxn];\nvector<int> b;\nvector<int> g[maxn],ng[maxn];\npriority_queue<pii> pq;\n\nvoid dfs(int u){\n\tvis[u]=1;\n\tFOR(i,0,g[u].size()){\n\t\tint v=g[u][i];\n\t\tif(vis[v]) continue;\n\t\tng[u].PB(v);\n\t\tdfs(v);\n\t}\n\treturn;\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tFOR(i,0,n) scanf(\"%d\",a+i);\n\tsort(a,a+n);\n\tFOR(i,0,n){\n\t\tFOR(j,0,n){\n\t\t\tif(__gcd(a[i],a[j])!=1) g[i].PB(j);\n\t\t}\n\t}\n\tFOR(i,0,n) if(!vis[i]) dfs(i),pq.PH(MP(a[i],i));\n/*\tFOR(i,0,n){\n\t\tFOR(j,0,ng[i].size()) printf(\"%d \",ng[i][j]);\n\t\tputs(\"\");\n\t}\n*/\twhile(!pq.empty()){\n\t\tint u=pq.top().snd;\n\t\tb.PB(pq.top().fst);\n\t\tpq.pop();\n\t\tFOR(i,0,ng[u].size()) pq.PH(MP(a[ng[u][i]],ng[u][i]));\n\t}\n\tFOR(i,0,n) printf(\"%d \",b[i]);\n\tputs(\"\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Code by 27.\n#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<string>\n#include<math.h>\n#include<vector>\n#include<queue>\n#include<map>\n#include<stack>\n#include<fstream>\n#include<stdlib.h>\n#include<set>\n#include<climits>\n#include<cmath>  \n#include<memory.h> \n#include<sstream>\n#include<time.h>\n#include<iomanip>\nusing namespace std;\nconst unsigned long long BIGEST=1000000000000000000+1000000000000000000;\nconst long long BIGER=1000000000000000000;\nconst int BIG=1000000000;\nconst int MOD=1000000007;\n/*\nooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo\nooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo^ =ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo\noooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo\\`  ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo\noooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo,   =/ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo6o\noooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo`    \\ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo\nooooooooooooooooooooooooooooooooooooooooooooooooooooooo[o\\oo\\oo`  ,  ,o\\o/\\\\ooo`ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo\noooooooooooooooooooooooooooooooooooooooooooooooooooo//\\           \\.          =\\ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo\noooooooooooooooooooooooooooooooooooooooooooooooooooooooo\\`   ,\\`,ooo/]`*    ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo\noooooooooooooooooooooooooooooooooooooooooooooooooooooooo/oo`   .\\ooo\\[   ,/\\ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo\noooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo\\^  =\\\\o/  ,ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo\nooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo  =/`  =^  =oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo\noooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo^            oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo\nooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo/    .oo/`    =ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo\noooooooooooooooooooooooooooooooooooooooooooooooooooooooo^o=`  ,\\oooo/o^   ]^ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo\nooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo.]o/\\oooooooo,.//ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo\nooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo\noooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo^ [oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo\noooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo  ,/ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo\noooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo/`  ,\\/oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo\nooooooooooooooooooooooooooooooooooooooooooooooooooooooooo\\//oooooooooooooo,   =^/oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo\noooooooooooooooooooooooooooooooooooooooooooooooooooooooo/`,`o\\/ooooooooooooo`   \\/ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo\noooooooooooooooooooooooooooooooooooooooooooooooooooo/\\\\        ,,\\/\\oooooooo\\^   ,\\oooooooooooooooooooooooooooooooooooooooooooooooooooooooooo\noooooooooooooooooooooooooooooooooooooooooooooooooooo/^             `oooooooooo^    \\ooooooooooooooooooooooooooooooooooooooooooooooooooooooooo\nooooooooooooooooooooooooooooooooooooooooooooooooo\\\\/             /\\\\ooooooooooo^    ,o\\=ooooooooooooooooooooooooooooooooooooooooooooooooooooo\noooooooooooooooooooooooooooooooooooooooooooooooooo`            /oooooooooooooooo^    ,,^ooooooooooooooooooooooooooooooooooooooooooooooooooooo\noooooooooooooooooooooooooooooooooooooooooooo/ooo/            =o\\ooooooooooooooooo`     ^ooooooooooooooooooooooooooooooooooooooooooooooooooooo\noooooooooooooooooooooooooooooooooooooooooooooo/               ,\\oooooooooooooooo^\\     ,ooooooooooooooooooooooooooooooooooooooooooooooooooooo\noooooooooooooooooooooooooooooooooooooooooooooo`                ,\\[]/oooooooooooooo      ,/ooooooooooooooooooooooooooooooooooooooooooooooooooo\noooooooooooooooooooooooooooooooooooooooooooooo/\\        ]`       ,`\\oooooooooooooo^      oooooooooooooooooooooooooooooooooooooooooooooooooooo\noooooooooooooooooooooooooooooooooooooooooooooooo\\`     \\o\\o        \\ooooooooooooooo      =\\oooooooooooooooooooooooooooooooooooooooooooooooooo\noooooooooooooooooooooooooooooooooooooooooooooooo/o=` /o/oooo^        \\/\\ooooooooooo      ,ooooooooooooooooooooooooooooooooooooooooooooooooooo\noooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo/o         ooooooooo\\o/  n     oooooooooooooooooooooooooooooooooooooooooooooooooo\noooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo/\\        .o\\ooooooo/       ooooooooooooooooooooooooooooooooooooooooooooooooooo\nooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo`        \\/ooo\\o/        ooooooooooooooooooooooooooooooooooooooooooooooooooo\nooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo\\/         \\ooo^^       ,ooooooooooooooooooooooooooooooooooooooooooooooooooo\noooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo^        ./\\/        oooooooooooooooooooooooooooooooooooooooooooooooooooo\noooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo\\/`        .        ,oo^ooooooooooooooooooooooooooooooooooooooooooooooooo\nooooooooooooooooooooooooooooooooooooooooooooooooooooo.  ,ooooooooooooooo                ooooooooooooooooooooooooooooooooooooooooooooooooooooo\nooooooooooooooooooooooooooooooooooooooooooooooooo^        `/oooooooooooo/^             oooooooooooooooooooooooooooooooooooooooooooooooooooooo\noooooooooooooooooooooooooooooooooooooooooooo/\\oo``           \\/[ooo[ooooo^            ooooooooooooooooooooooooooooooooooooooooooooooooooooooo\nooooooooooooooooooooooooooooooooooooooooooooo\\,        =.        .[[[                 ,\\ooooooooooooooooooooooooooooooooooooooooooooooooooooo\noooooooooooooooooooooooooooooooooooooooo/o/o.       oooo\\o`                             \\o/\\ooooooooooooooooooooooooooooooooooooooooooooooooo\noooooooooooooooooooooooooooooooooooooooo/o.        ]oooooooo\\                            ,ooooooooooooooooooooooooooooooooooooooooooooooooooo\nooooooooooooooooooooooooooooooooooooooooo`        =ooooooooooooo`            ,oo/\\         \\ooooooooooooooooooooooooooooooooooooooooooooooooo\nooooooooooooooooooooooooooooooooooooooooo        =oooooooooooooooooo/oooooooooooo\\/.       `ooooooooooooooooooooooooooooooooooooooooooooooooo\noooooooooooooooooooooooooooooooooooooooo^^      ,ooooooooooooooooooooooooooooooooooo\\    ,ooooooooooooooooooooooooooooooooooooooooooooooooooo\noooooooooooooooooooooooooooooooooooooooooo\\  `,/ooooooooooooooooooooooooooooooooooooo/^ o]o/ooooooooooooooooooooooooooooooooooooooooooooooooo\nooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo\n*/\npriority_queue<pair<int,int> >pq;\nint vis[2001];\nint a[2001];\nint n;\nvector<pair<int,int> >v[2001];\nint g[2001];\nint f[2001];\nvector<int>vt[2001];\nint ypa(int k)\n{\n\tsort(v[k].begin(),v[k].end());\n\tf[k]=1;\n\tint u=k;\n\tint t=0;\n\tfor(int i=0;i<v[k].size();i++)\n\t{\n\t\tif(f[v[k][i].second])continue;\n\t\tvt[k].push_back(v[k][i].second);\n\t\tt=ypa(v[k][i].second);\n\t\tif(a[t]<a[u])u=t;\n\t}\n\treturn u;\n}\nlong long gcd(long long a,long long b)\n{\n\tif(!b)return a;\n\treturn gcd(b,a%b);\n}\nvector<pair<int,int> >sq;\nint main()\n{\n\t/*\n\tdsu.init();\n\t*/\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t\tsq.push_back(make_pair(a[i],i));\n\t}\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t{\n\t\t\tif(gcd(a[i],a[j])!=1)\n\t\t\t{\n\t\t\t\tv[i].push_back(make_pair(a[j],j));\n\t\t\t\tv[j].push_back(make_pair(a[i],i));//dsu.united(i,j);\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tif(dsu.find(i)==i)\n\t\t{\n\t\t\tcout<<i<<endl;\n\t\t\tpq.push(make_pair(make_pair(0,-a[i]),i));\n\t\t\tvis[i]=1;\n\t\t}\n\t}\n\t*/\n\tsort(sq.begin(),sq.end());\n\tint t;\n\tfor(int i=0;i<sq.size();i++)\n\t{\n\t\tif(!f[sq[i].second])\n\t\t{\n\t\t\tt=ypa(sq[i].second);\n\t\t\tpq.push(make_pair(a[t],t));\n\t\t}\n\t}\n\t/*\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tcout<<i<<\":\";\n\t\tfor(int j=0;j<vt[i].size();j++)\n\t\t{\n\t\t\tcout<<vt[i][j]<<\" \";\n\t\t}\n\t\tcout<<endl;\n\t}\n\t*/\n\tpair<int,int>u;\n\tint g=0;\n\twhile(!pq.empty())\n\t{\n\t\tprintf(\"%d \",pq.top());\n\t\tu=pq.top();\n\t\tpq.pop();\n\t\tfor(int i=0;i<vt[u.second].size();i++)\n\t\t{\n\t\t\tif(vis[vt[u.second][i]])continue;\n\t\t\tpq.push(make_pair(a[vt[u.second][i]],vt[u.second][i]));\n\t\t\tvis[vt[u.second][i]]=1;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h> \nusing namespace std;\nint n,a[2005];\nbool used[2005],ok;\nvector<int> v[2005],tmp;\nvector<vector<int> > ans;\ninline int gcd(int x,int y){return !x?y:gcd(y%x,x);}\nvoid dfs(int from)\n{\n\tused[from]=1;tmp.push_back(a[from]);\n\tfor(int i=0;i<v[from].size();i++)\n\t{\n\t\tint to=v[from][i];\n\t\tif(used[to])continue;\n\t\tdfs(to);\n\t\tif(ok)return;\n\t}\n\tans.push_back(tmp);tmp.clear();ok=1;\n}\nbool cmp(const vector<int> &x,const vector<int> &y){return !(x<y);}\nint main()\n{\n\tios::sync_with_stdio(0);\n\tcin>>n;\n\t/*for(int i=0;i<n;i++)\n\t{\n\tcin>>a[i];\n\tfor(int j=i-1;i>=0;j--)\n\tif(gcd(a[i],a[j])==1)v[i].push_back(j),v[j].push_back(i);\n\t}\n\tdfs(0);*/\n\tfor(int i=0;i<n;i++)cin>>a[i];\n\tsort(a,a+n);\n\tfor(int i=0;i<n;i++)\n\tfor(int j=i-1;j>=0;j--)\n\tif(gcd(a[j],a[i])!=1)\n\tv[i].push_back(j),v[j].push_back(i);\n\tfor(int i=0;i<n;i++)if(!used[i])dfs(i),ok=0;\n\tsort(ans.begin(),ans.end(),cmp);\n\tfor(int i=0;i<ans.size();i++)\n\tfor(int j=0;j<ans[i].size();j++)\n\tcout<<ans[i][j],cout<<(j==ans[i].size()-1?'\\n':' ');\n\tcout<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define re(i,a,b) for(int i=(a);i<(b);i++)\n#define repd(i,a,b) for(int i=(a);i>=(b);i--)\n#define run(v) for(int k=head[v];k;k=e[k].ne)\n//#define v e[k].t\n#define clr(a) memset(a,0,sizeof(a));\n#define il inline\n#define sz(a) ((int)a.size())\n#define all(a) a.begin(),a.end()\n#define mp make_pair\n#define pb push_back \n#define w1 first\n#define w2 second\n#define adm(a,b,c) {a=a+b;if(a>=c)a-=c;else if(a<0)a+=c;}\ntypedef pair<int,int> pa;\ntypedef long long ll;typedef long double ld;typedef unsigned long long ull;\nconst int N=2e3+5,M=2e6+5,INF=1e9,mod=1e9+7;\nconst ll linf=1e18;const double eps=1e-8,pi=acos(-1);\nil int gmin(int &a,int b){if(a>b)a=b;}il ll gmin(ll &a,ll b){if(a>b)a=b;}il int gmax(int &a,int b){if(a<b)a=b;}il ll gmax(ll &a,ll b){if(a<b)a=b;}\nil void read(ll&x){ll f=1,t=0;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){t=t*10+ch-'0';ch=getchar();}x=t*f;}il ll read(ll&x,ll&y){read(x);read(y);}\nil void read(int&x){int f=1,t=0;char ch=getchar();while(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}while(ch>='0'&&ch<='9'){t=t*10+ch-'0';ch=getchar();}x=t*f;}il int read(int&x,int&y){read(x);read(y);}\nil void read(int&a,int&b,int&c){read(a);read(b);read(c);}il void read(ll&a,ll&b,ll&c){read(a);read(b);read(c);}\nil int read(){int x;read(x);return x;}\nil ll qpow(ll a,ll b,ll p){ll ret=1;for(;b;b>>=1,a=a*a%p)if(b&1)ret=ret*a%p;return ret;}il ll qpow(ll a,ll b){ll ret=1;for(;b;b>>=1,a=a*a%mod)if(b&1)ret=ret*a%mod;return ret;}\nil ll qmul(ll a,ll b,ll p){ll ret=0;for(;b;b>>=1,a=(a<<1)%p)if(b&1)adm(ret,a,p);return ret;}il ll qmul(ll a,ll b){ll ret=0;for(;b;b>>=1,a=(a<<1)%mod)if(b&1)adm(ret,a,mod);return ret;}\nil void judge(){\n\tfreopen(\"data.in\",\"r\",stdin);\n\tfreopen(\"data.out\",\"w\",stdout);}\nil void gen(){freopen(\"data.in\",\"w\",stdout);}\nint n,m,bin[30]={1};\nint a[N],g[N][N],ind[N],vis[N];\nvector<int>e[N];\nil int gcd(int a,int b){return b?gcd(b,a%b):a;}\nvoid dfs(int x){\n\tre(i,0,n)if(g[x][i]>1&&!vis[i]){\n\t\tvis[i]=1;e[x].pb(i);\n\t\tind[i]++;\n\t\tdfs(i);\n\t}\n}\nint main(){\n\tread(n);re(i,0,n)read(a[i]);\n\tsort(a,a+n);\n\tre(i,0,n)re(j,0,n)g[i][j]=gcd(a[i],a[j]);\n\tre(i,0,n)if(!vis[i])vis[i]=1,dfs(i);\n\tpriority_queue<int,vector<int> >pq;\n\tre(i,0,n)if(ind[i]==0)pq.push(i);\n\twhile(!pq.empty()){\n\t\tint x=pq.top();pq.pop();\n\t\tprintf(\"%d \",a[x]);\n\t\tre(i,0,e[x].size())if(--ind[e[x][i]]==0)pq.push(e[x][i]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ninline char nchar() {\n\tstatic const int bufl=1<<20;\n\tstatic char buf[bufl],*a=NULL,*b=NULL;\n\treturn a==b && (b=(a=buf)+fread(buf,1,bufl,stdin),a==b)?EOF:*a++;\n}\ninline int read() {\n\tint x=0,f=1;\n\tchar c=nchar();\n\tfor (;!isdigit(c);c=nchar()) if (c=='-') f=-1;\n\tfor (;isdigit(c);c=nchar()) x=x*10+c-'0';\n\treturn x*f;\n}\nconst int maxn=2e3+10;\ntypedef vector<int> vec;\nint n,a[maxn];\nvec operator + (const vec &a,const vec &b) {\n\tvec ret(a.size()+b.size());\n\tcopy(b.begin(),b.end(),copy(a.begin(),a.end(),ret.begin()));\n\treturn ret;\n}\nvec operator ^ (const vec &a,const vec &b) {\n\tvec ret(a.size()+b.size());\n\tvec::const_iterator ai=a.begin(),bi=b.begin();\n\tvec::iterator ri=ret.begin();\n\twhile (ai!=a.end() || bi!=b.end()) {\n\t\tif (ai==a.end()) *ri++=*bi++; else\n\t\tif (bi==b.end()) *ri++=*ai++; else\n\t\t*ri++=*(*ai>*bi?(ai++):(bi++));\n\t}\n\treturn ret;\n}\nnamespace graph {\n\tvec g[maxn],f[maxn];\n\tbool vis[maxn];\n\tinline void add(int x,int y) {\n\t\tg[x].push_back(y);\n\t\tg[y].push_back(x);\n\t}\n\tvoid dfs(int x) {\n\t\tvis[x]=true;\n\t\tvec &fx=f[x];\n\t\tsort(g[x].begin(),g[x].end(),[](int x,int y)->bool{return a[x]<a[y];});\n\t\tfor (const int &v:g[x]) g[v].erase(find(g[v].begin(),g[v].end(),x));\n\t\tfor (const int &v:g[x]) if (!vis[v]) {\n\t\t\tdfs(v);\n\t\t\tfx=fx^f[v];\n\t\t}\n\t\tfx=vec(1,a[x])+fx;\n\t}\n\tvec work() {\n\t\tdfs(0);\n\t\treturn f[0];\n\t}\n}\nint main() {\n#ifndef ONLINE_JUDGE\n\tfreopen(\"test.in\",\"r\",stdin);\n#endif\n\tn=read(),generate_n(a+1,n,read);\n\tfor (int i=1;i<=n;++i) graph::add(0,i);\n\tfor (int i=1;i<=n;++i) for (int j=i+1;j<=n;++j) if (__gcd(a[i],a[j])>1) graph::add(i,j);\n\tvec ans(graph::work());\n\tfor (int i=1;i<=n;++i) printf(\"%d%c\",ans[i],\" \\n\"[i==n]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#define SF scanf\n#define PF printf\n#define MAXN 2010\nusing namespace std;\ntypedef long long ll;\nint n,cnt[MAXN];\nll a[MAXN];\nvector<int> b[MAXN],c[MAXN];\npriority_queue<pair<ll,int> > qx;\nll gcd(ll x,ll y){\n\tif(y==0)\n\t\treturn x;\n\treturn gcd(y,x%y);\t\n}\nint d[MAXN];\nbool vis[MAXN];\nvoid dfs(int x){\n\tvis[x]=1;\n\tfor(int i=0;i<int(b[x].size());i++)\n\t\tif(vis[b[x][i]]==0){\n\t\t\tc[x].push_back(b[x][i]);\n\t\t\td[b[x][i]]++;\n\t\t\tdfs(b[x][i]);\n\t\t}\n}\t\npriority_queue<pair<ll,int> > q;\nint main(){\n\t//freopen(\"newgame.in\",\"r\",stdin);\n\t//freopen(\"newgame.out\",\"w\",stdout);\n\tSF(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t\tSF(\"%lld\",&a[i]);\n\tsort(a+1,a+1+n);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(i!=j&&gcd(a[i],a[j])!=1ll)\n\t\t\t\tb[i].push_back(j);\n\tfor(int i=1;i<=n;i++)\n\t\tif(vis[i]==0)\n\t\t\tdfs(i);\n\tfor(int i=1;i<=n;i++)\n\t\tif(d[i]==0)\n\t\t\tq.push(make_pair(a[i],i));\n\twhile(!q.empty()){\n\t\tPF(\"%lld \",q.top().first);\t\n\t\tint x=q.top().second;\n\t\tq.pop();\n\t\tfor(int i=0;i<int(c[x].size());i++){\n\t\t\td[c[x][i]]--;\n\t\t\tif(d[c[x][i]]==0)\n\t\t\t\tq.push(make_pair(a[c[x][i]],c[x][i]));\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,a,b) for(i=a;i<b;i++)\n#define per(i,b,a) for(i=b;i>=a;i--)\n#define For(i,a,b) for(i=a;i<=b;i++)\n#define Forenska(it,c) for(register __typeof(c.begin()) it=c.begin();it!=c.end();it++)\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\n#define all(x) x.begin(),x.end()\n#define sqr(x) ((x)*(x))\n#define lowbit(x) ((x)&(-x))\n#define GREATER(x) x,vector<x>,greater<x>\nusing namespace std;\nint i,j;\ntypedef long long LL;\ntypedef pair<int,int> pii;\ntypedef pair<LL,LL> pLL;\ntypedef vector<int> vec;\ntypedef vector<LL> vecL;\ntypedef vector<pii> vecP;\ntypedef vector<pLL> vecPL;\ntypedef vector<string> vecS;\ntypedef vector<vec> mat;\ntypedef complex<double> point;\nconst long double PI=3.1415926535897932384626433832795028841971693993751058209749445923078164062862089;\nconst LL INFLL=0x3f3f3f3f3f3f3f3f;\nconst int INF=0x3f3f3f3f;\nconst long double EPS=1e-10;\nint read()\n{\n\tint x=0;\n\tchar ch=' ';\n\tbool flag=false;\n\twhile(!isdigit(ch))\n\t{\n\t\tif(ch=='-')flag=true;\n\t\tch=getchar();\n\t}\n\twhile(isdigit(ch))\n\t{\n\t\tx=(x<<3)+(x<<1)+ch-'0';\n\t\tch=getchar();\n\t}\n\treturn flag?-x:x;\n}\n\nint main()\n{\n\tint n;\n\tvec A;\n\tcin>>n;\n\tA.resize(n);\n\trep(i,0,n)cin>>A[i];\n\tsort(all(A));\n\treverse(all(A));\n\trep(i,0,n)cout<<A[i]<<endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<set>\n#include<unordered_set>\n#define lol(i,n) for(ll i=0;i<n;i++)\n#define mod 1000000007\n#define chmax(a,b) a=max(a,b);\n#define chmin(a,b) a=min(a,b);\ntypedef long long ll;\n\nusing namespace std;\nll gcd(ll a,ll b){\n  if(a<b)swap(a,b);\n  if(b==0)return a;\n  return gcd(a%b,b);\n}\n#define N 2010\nll b[N],a[N],n;\nvector<ll> g[N];\n\nclass Aoki{\n  public:\n  ll nz[N];\n  void buildg(){\n    lol(i,n)g[i].clear();\n    lol(i,n)lol(j,i){\n      if(gcd(b[i],b[j])>1){\n\tg[j].push_back(i);\n\tnz[i]++;\n      }\n    }\n  }\n  void main(){\n    lol(i,n)nz[i]=0;\n    buildg();\n    //cout<<\"b=\";lol(i,n)cout<<b[i]<<\" \";cout<<endl;\n    //lol(i,n)cout<<nz[i]<<\" \";cout<<endl;\n    priority_queue<pair<ll,ll> >Q;\n    lol(i,n)if(nz[i]==0)Q.push(make_pair(b[i],i));\n    vector<ll> res;\n    unordered_set<ll> vis;\n    while(!Q.empty()){\n      ll val=Q.top().first;\n      ll x=Q.top().second;\n      Q.pop();\n      if(vis.find(x)!=vis.end())continue;\n      vis.insert(x);\n      res.push_back(val);\n      for(auto y:g[x]){\n\tnz[y]--;\n\tif(nz[y]==0)Q.push(make_pair(b[y],y));\n      }\n    }\n    lol(i,n){\n      if(i)cout<<\" \";\n      cout<<res[i];\n    }cout<<endl;\n  }\n};Aoki kensho;\n\nclass Takahashi{\n  public:\n  void buildg(){\n    lol(i,n)lol(j,n){\n      if(i!=j&&gcd(a[i],a[j])>1){\n\tg[i].push_back(j);\n      }\n    }\n  }\n  unordered_set<ll> vis;\n  vector<ll> res;\n  void dfs(ll x){\n      if(vis.find(x)!=vis.end())return;\n      vis.insert(x);\n      res.push_back(x);\n      vector<ll> v;\n      for(auto y:g[x]){\n       v.push_back(y);\n      }\n      sort(v.begin(),v.end());\n      for(auto y:v){\n          dfs(y);\n      }\n  }\n  void main(){\n    buildg();\n    //cout<<\"buildend\"<<endl;\n    lol(i,n){\n     dfs(i);\n    }\n    //cout<<\"#\"<<res.size()<<endl;\n    //cout<<\"a=\";lol(i,n)cout<<res[i]<<\" \";cout<<endl;\n    lol(i,n)b[i]=a[res[i]];\n  }\n};Takahashi chokudai;\n\nint main(){\n    cin>>n;\n    lol(i,n)cin>>a[i];\n    sort(a,a+n);\n    chokudai.main();\n    //cout<<\"chokudai-end\"<<endl;\n    kensho.main();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define db double\n\nusing namespace std;\nconst int N=2000+10;\nint rd()\n{\n    int x=0,w=1;char ch=0;\n    while(ch<'0'||ch>'9'){if(ch=='-') w=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+(ch^48);ch=getchar();}\n    return x*w;\n}\nint to[N<<5],nt[N<<5],hd[N<<4],tot=1;\nvoid adde(int x,int y)\n{\n\t++tot,to[tot]=y,nt[tot]=hd[x],hd[x]=tot;\n\t++tot,to[tot]=x,nt[tot]=hd[y],hd[y]=tot;\n}\nint n,t,a[N],vs[N<<4],mk[N<<4],ti,ban[N<<4],dl[N],sq[N],ts,ff[N];\nint findf(int x){return ff[x]==x?x:ff[x]=findf(ff[x]);}\nvector<int> an[N],ls,nl;\nmap<int,int> id;\nvoid clr(int x)\n{\n\tmk[x]=ti,vs[x]=vs[0];\n\tfor(int i=hd[x];i;i=nt[i])\n\t{\n\t\tint y=to[i];\n\t\tif(ban[i>>1]||mk[y]==ti) continue;\n\t\tclr(y);\n\t}\n}\n\nint main()\n{\n\tn=rd(),t=n;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\ta[i]=rd();\n\t\tint x=a[i],sqt=sqrt(x);\n\t\tfor(int j=2;j<=sqt;++j)\n\t\t\tif(x%j==0)\n\t\t\t{\n\t\t\t\tif(!id[j]) id[j]=++t;\n\t\t\t\tadde(i,id[j]);\n\t\t\t\twhile(x%j==0) x/=j;\n\t\t\t}\n\t\tif(x>1)\n\t\t{\n\t\t\tif(!id[x]) id[x]=++t;\n\t\t\tadde(i,id[x]);\n\t\t}\n\t}\n\tmemset(vs,0x3f3f3f,sizeof(vs));\n\ta[0]=1<<30;\n\tint rs=n;\n\twhile(rs--)\n\t{\n\t\tint sx=0;\n\t\tfor(int i=1;i<=n;++i)\n\t\t\tif(!dl[i]&&vs[sx]>vs[i]) sx=i;\n\t\tif(!sx)\n\t\t{\n\t\t\tfor(int i=1;i<=n;++i)\n\t\t\t\tif(!dl[i]&&a[sx]>a[i]) sx=i;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor(int i=1;i<=n;++i)\n\t\t\t\tif(!dl[i]&&vs[i]==vs[sx]&&a[sx]>a[i]) sx=i;\n\t\t}\n\t\tdl[sx]=1,sq[++ts]=sx;\n\t\t++ti,clr(sx);\n\t\tfor(int i=hd[sx];i;i=nt[i])\n\t\t{\n\t\t\tint y=to[i];\n\t\t\tban[i>>1]=1;\n\t\t\tfor(int j=hd[y];j;j=nt[j])\n\t\t\t{\n\t\t\t\tif(ban[j>>1]) continue;\n\t\t\t\tint z=to[j];\n\t\t\t\tvs[z]=ts;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;++i) ff[i]=i,an[i].push_back(a[i]);\n\twhile(ts)\n\t{\n\t\tint x=sq[ts--];\n\t\tls.clear();\n\t\tfor(int i=hd[x];i;i=nt[i])\n\t\t{\n\t\t\tint y=to[i];\n\t\t\tban[i>>1]=0;\n\t\t\tfor(int j=hd[y];j;j=nt[j])\n\t\t\t{\n\t\t\t\tif(ban[j>>1]) continue;\n\t\t\t\tint z=to[j];\n\t\t\t\tif((z=findf(z))!=findf(x))\n\t\t\t\t{\n\t\t\t\t\tint nn=ls.size(),mm=an[z].size(),p=0,q=0,r=0;\n\t\t\t\t\tnl.clear(),nl.resize(nn+mm);\n\t\t\t\t\twhile(p<nn&&q<mm)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(ls[p]>an[z][q]) nl[r++]=ls[p],++p;\n\t\t\t\t\t\telse nl[r++]=an[z][q],++q;\n\t\t\t\t\t}\n\t\t\t\t\twhile(p<nn) nl[r++]=ls[p],++p;\n\t\t\t\t\twhile(q<mm) nl[r++]=an[z][q],++q;\n\t\t\t\t\tls=nl;\n\t\t\t\t\tff[z]=x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint nn=ls.size();\n\t\tfor(int i=0;i<nn;++i) an[x].push_back(ls[i]);\n\t}\n\tls.clear();\n\tfor(int i=1;i<=n;++i)\n\t\tif(findf(i)==i)\n\t\t{\n\t\t\tint nn=ls.size(),mm=an[i].size(),p=0,q=0,r=0;\n\t\t\tnl.clear(),nl.resize(nn+mm);\n\t\t\twhile(p<nn&&q<mm)\n\t\t\t{\n\t\t\t\tif(ls[p]>an[i][q]) nl[r++]=ls[p],++p;\n\t\t\t\telse nl[r++]=an[i][q],++q;\n\t\t\t}\n\t\t\twhile(p<nn) nl[r++]=ls[p],++p;\n\t\t\twhile(q<mm) nl[r++]=an[i][q],++q;\n\t\t\tls=nl;\n\t\t}\n\tfor(int i=0;i<n;++i) printf(\"%d \",ls[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntemplate<typename T> \nmap<T, int> factorize(T x){\n  map<T, int> res;\n  for(int i=2;i*i<=x;i++){\n    while(x%i==0){\n      x/=i;\n      res[i]++;\n    }\n  }\n  if(x!=1) res[x]++;\n  return res;\n}\n\n//INSERT ABOVE HERE\nsigned main(){\n  int n;\n  scanf(\"%d\",&n);\n  vector<int> a(n);\n  for(int i=0;i<n;i++) scanf(\"%d\",&a[i]);\n  sort(a.begin(),a.end());\n\n  vector<int> ans(n);\n\n  int m=0;\n  map<int, int> r;\n\n  vector<vector<int> > G(n);\n  for(int i=0;i<n;i++){\n    auto x=factorize(a[i]);\n    for(auto p:x){\n      if(!r.count(p.first)) r[p.first]=m++,G.emplace_back();\n      G[i].emplace_back(n+r[p.first]);\n      G[n+r[p.first]].emplace_back(i);\n    }\n  }\n  \n  int color=0;\n  vector<int> cs(n+m,-1),used(n+m,0),post(n,0);\n  for(int t=0;t<n;t++){\n    for(int i=0;i<n+m;i++){\n      if(used[i]||~cs[i]) continue;\n      queue<int> q;\n      cs[i]=color;\n      q.emplace(i);\n      while(!q.empty()){\n\tint v=q.front();q.pop();\n\tfor(int u:G[v]){\n\t  if(used[u]||~cs[u]) continue;\n\t  cs[u]=color;\n\t  q.emplace(u);\n\t}\n      }\n      color++;\n    }\n    \n    int idx=-1;\n    for(int i=0;i<n;i++){\n      if(used[i]||post[i]) continue;\n      idx=i;\n      break;\n    }\n    \n    used[idx]=1;\n    ans[t]=idx;\n    \n    for(int i=0;i<n+m;i++){\n      if(used[i]||cs[idx]!=cs[i]) continue;\n      if(i<n) post[i]=__gcd(a[idx],a[i])<=1;\n      cs[i]=-1;\n    }\n  }\n\n  vector<int> b(n);\n  for(int i=0;i<n;i++) b[i]=a[ans[i]];\n  \n  vector<vector<int> > H(n);\n  for(int i=0;i<n;i++)\n    for(int j=i+1;j<n;j++)\n      if(__gcd(b[i],b[j])>1) H[i].emplace_back(j);\n\n  vector<int> indeg(n);\n  for(int i=0;i<n;i++)\n    for(int j:H[i]) indeg[j]++;\n  \n  using P = pair<int, int>;\n  priority_queue<P> pq;\n  for(int i=0;i<n;i++)\n    if(!indeg[i]) pq.emplace(b[i],i);\n\n  vector<int> c;\n  while(!pq.empty()){\n    P p=pq.top();pq.pop();\n    c.emplace_back(p.first);\n    for(int u:H[p.second]){\n      indeg[u]--;\n      if(!indeg[u]) pq.emplace(b[u],u);\n    }\n  }\n  \n  for(int i=0;i<n;i++){\n    if(i) printf(\" \");\n    printf(\"%d\",c[i]);\n  }\n  puts(\"\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Do you knOW what it feels like?\n\n\t\t// To be TorTured by your own MinD?\n\t\n\t// I don't wanna feel the PAIN.\n\n// I BeG you to KILL me, pleASE...\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n//#pragma GCC optimize(\"Os\")\n\n#define F first\n#define S second\n#define pb push_back\n#define SZ(x) (ll)(x.size())\n#define all(x) x.begin(),x.end()\n\ntypedef long long ll;\ntypedef pair<ll,ll> pll;\ntypedef long double ld;\n\n//mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst ll maxn=2e3+10, lg=22, mod=1e9+7, inf=1e18;\n\nll n,a[maxn];\nvector<ll> g[maxn],gg[maxn];\nvector<ll> nans;\ndeque<ll> ans;\nbool mk[maxn],km[maxn];\n\nvoid dff(ll v){\n\tif(km[v]) return;\n\tkm[v]=1;\n\tfor(auto u:gg[v]) dff(u);\n}\n\nvoid dfs(ll v){\n\tif(mk[v]) return;\n\tnans.pb(a[v]), mk[v]=1;\n\tsort(all(g[v]),greater<ll>());\n\tfor(int i=0;i<SZ(g[v]);i++) gg[i].clear(), km[i]=mk[g[v][i]];\n\tfor(int i=0;i<SZ(g[v]);i++)for(int j=i+1;j<SZ(g[v]);j++)if(__gcd(a[g[v][i]],a[g[v][j]])==1) gg[i].pb(j), gg[j].pb(i);\n\tvector<ll> nn;\n\tfor(int i=0;i<SZ(g[v]);i++)if(!km[i]) dff(i), nn.pb(g[v][i]);\n\treverse(all(nn));\n\tfor(auto u:nn) dfs(u);\n}\n\nint main(){\n\tios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0);\n\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\tfor(int i=1;i<=n;i++)for(int j=i+1;j<=n;j++)if(__gcd(a[i],a[j])!=1) g[i].pb(j), g[j].pb(i);\n\tsort(a+1,a+1+n);\n\tfor(int i=1;i<=n;i++){\n\t\tdfs(i);\n\t\tfor(int j=SZ(nans)-1;j>=0;j--) ans.push_front(nans[j]);\n\t\tnans.clear();\n\t}\n\tfor(auto x:ans) cout<<x<<' ';\n\n\treturn 0;\n}\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\nconst int N=2005;\nvector<int> ad[N],ap[N];\npriority_queue<int> pq;\nint a[N],ans[N],vis[N],tail[N];\nint n,v,cnt;\nvoid dfs(int x){\n\tvis[x]=1;\n\tfor(int i=0;i<ad[x].size();i++){\n\t\tv=ad[x][i];\n\t\tif(vis[v])continue;\n\t\ttail[v]=1;ap[x].push_back(v);\n\t\tdfs(v);\n\t}\n}\nint main(){\n\tcin>>n;\n\tfor(int i=1;i<=n;i++)cin>>a[i];\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++)for(int j=1;j<=n;j++)\n\tif(__gcd(a[i],a[j])>1&&i!=j)ad[i].push_back(j);\n\tfor(int i=1;i<=n;i++)if(vis[i]==0)dfs(i);\n\tfor(int i=1;i<=n;i++)if(tail[i]==0)pq.push(i);\n\twhile(pq.size()>0){\n\t\tv=pq.top();\n\t\tcnt++;ans[cnt]=a[v];\n\t\tpq.pop();\n\t\tfor(int i=0;i<ap[v].size();i++)\n\t\tpq.push(ap[v][i]);\n\t}\n\tfor(int i=1;i<=cnt;i++)cout<<ans[i]<<\" \";\n\tcout<<endl;\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 2005;\n\nint n;\nint a[N];\nint dir[N][N];\nvector<int> G[N];\nint mn_comp[N];\nint par[N];\nbool inQueue[N];\nint deg[N];\nvector<int> ans;\n\nint anc(int p) { return p == par[p] ? p : par[p] = anc(par[p]); }\nvoid join(int p, int q) { par[anc(p)] = anc(q); }\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(0);\n\tcin >> n;\n\tfor (int i = 1; i <= n; ++i) cin >> a[i];\n\tsort(a + 1, a + n + 1);\n\t\n\tfor (int i = 1; i <= n; ++i) par[i] = i; // for DSU\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = i + 1; j <= n; ++j) if (__gcd(a[i], a[j]) != 1) {\n\t\t\tdir[i][j] = dir[j][i] = 1;\n\t\t\tjoin(i, j);\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; ++i) {\n\t\tint p = anc(i);\n\t\tif (mn_comp[p] == 0) mn_comp[p] = i; else mn_comp[p] = min(mn_comp[p], i);\n\t}\n\n\tfor (int i = 1; i <= n; ++i) if (i == anc(i)) { // new component\n\t\tint start = mn_comp[i];\n\t\tpriority_queue <int, vector<int>, greater<int> > q; \n\t\tq.push(start);\n\n\t\twhile(!q.empty()) {\n\t\t\tint u = q.top(); q.pop();\n\t\t\tfor (int j = 1; j <= n; ++j) if (dir[u][j]) {\n\t\t\t\tdir[j][u] = 0; if (!inQueue[j]) inQueue[j] = true, q.push(j);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = 1; j <= n; ++j) if (dir[i][j]) G[i].push_back(j), ++deg[j];\n\t}\n\t\n\tmemset(inQueue, 0, sizeof inQueue);\n\tpriority_queue <int> q;\n\tfor (int i = 1; i <= n; ++i) if (deg[i] == 0) q.push(i);\n\n\twhile(!q.empty()) {\n\t\tint u = q.top(); q.pop(); inQueue[u] = true;\n\t\tans.push_back(u);\n\t\tfor (int v : G[u]) if (!inQueue[v]) {\n\t\t\t--deg[v];\n\t\t\tif (deg[v] == 0) q.push(v);\n\t\t}\n\t}\n\n\tfor (int u : ans) printf(\"%d \", a[u]); printf(\"\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nnamespace Flandre_Scarlet\n{\n\t#define N 2333\n\t#define F(i,l,r) for(int i=l;i<=r;++i)\n\t#define D(i,r,l) for(int i=r;i>=l;--i)\n\t#define Fs(i,l,r,c) for(int i=l;i<=r;c)\n\t#define Ds(i,r,l,c) for(int i=r;i>=l;c)\n\t#define MEM(x,a) memset(x,a,sizeof(x))\n\t#define FK(x) MEM(x,0)\n\t#define Tra(i,u) for(int i=G.Start(u),v=G.To(i);~i;i=G.Next(i),v=G.To(i))\n\t#define p_b push_back\n\t#define sz(a) ((int)a.size())\n\t#define iter(a,p) (a.begin()+p)\n\tint I()\n\t{\n\t    int x=0;char c=getchar();int f=1;\n\t    while(c<'0' or c>'9') f=(c=='-')?-1:1,c=getchar();\n\t    while(c>='0' and c<='9') x=(x<<1)+(x<<3)+(c^48),c=getchar();\n\t    return (x=(f==1)?x:-x);\n\t}\n\tvoid Rd(int cnt,...)\n\t{\n\t    va_list args; va_start(args,cnt);\n\t    F(i,1,cnt) {int* x=va_arg(args,int*);(*x)=I();}\n\t    va_end(args);\n\t}\n\n\tint n,a[N];\n\tvoid Input()\n\t{\n\t\tn=I(); F(i,1,n) a[i]=I();\n\t}\n\n\tvector<int> g[N],g2[N];\n\tbool vis[N];int ideg[N];\n\tvoid DFS(int u)\n\t{\n\t\tvis[u]=1;\n\t\tF(i,0,sz(g[u])-1)\n\t\t{int v=g[u][i];\n\t\t\tif (vis[v]) continue;\n\t\t\t++ideg[v]; g2[u].p_b(v);\n\t\t\tDFS(v);\n\t\t}\n\t}\n\tpriority_queue<int> Q;\n\tvoid TopoSort()\n\t{\n\t\tF(i,1,n) if (!ideg[i]) Q.push(i);\n\t\twhile(!Q.empty())\n\t\t{\n\t\t\tint u=Q.top(); Q.pop();\n\t\t\tprintf(\"%d \",a[u]);\n\t\t\tF(i,0,sz(g2[u])-1) Q.push(g2[u][i]);\n\t\t}\n\t}\n\tvoid Soviet()\n\t{\n\t\tsort(a+1,a+n+1);\n\t\tF(i,1,n) F(j,i+1,n) if (__gcd(a[i],a[j])!=1) g[i].p_b(j),g[j].p_b(i);\n\t\tF(i,1,n) if (!vis[i]) DFS(i);\n\t\tTopoSort();\n\t}\n\n\t#define Flan void\n\tFlan IsMyWife()\n\t{\n\t\tInput();\n\t\tSoviet();\n\t}\n}\nint main()\n{\n\tFlandre_Scarlet::IsMyWife();\n\tgetchar();getchar();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//khodaya khodet komak kon\n#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pb push_back\n#define all(x) x.begin(), x.end()\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nconst int N = 200000 + 10;\nconst ll MOD = 1000000000 + 7;\nconst ll INF = 1000000010;\nconst ll LOG = 25;\n\nint n;\nvi G[N], child[N], a, ans;\nmap<int, int> mp;\nbool mark[N];\n\nvoid DFS(int v){\n\tmark[v] = 1;\n\tsort(all(G[v]));\n\tfor (auto u:G[v]){\n\t\tif (!mark[u]){\n\t\t\tchild[v].pb(u);\n\t\t\tDFS(u);\n\t\t}\n\t}\n}\n\nint32_t main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++){\n\t\tint x;\n\t\tcin >> x;\n\t\tmp[x]++;\n\t\ta.pb(x);\n\t}\n\tsort(all(a));\n\ta.resize(unique(all(a)) - a.begin());\n\tsort(all(a));\n\tn = a.size();\n\tfor (int i = 0; i < a.size(); i++){\n\t\tfor (int j = 0; j < i; j++){\n\t\t\tif (__gcd(a[i], a[j]) != 1) G[i].pb(j), G[j].pb(i);\n\t\t}\n\t}\n\tset<int> st;\n\tfor (int i = 0; i < n; i++){\n\t\tif (!mark[i]){\n\t\t\tDFS(i);\n\t\t\tst.insert(i);\n\t\t}\n\t}\n\twhile (st.size()){\n\t\tint fr = *st.rbegin();\n\t\tst.erase(fr);\n//\t\tcout << fr << '\\n';\n\t\tans.pb(a[fr]);\n\t\tfor (auto u:child[fr]){\n\t\t\tst.insert(u);\n\t\t}\n\t}\n\tfor (auto u:ans){\n\t\tfor (int i = 0; i < mp[u]; i++) cout << u << ' ';\n\t}\n\n\n\n\n\n\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,a[2005],in[2005];\nbool vis[2005];\npriority_queue<int> pq;\nvector<int> g[2005],nei[2005];\nvoid dfs(int x)\n{\n\tvis[x]=1;\n\tfor(int i=0;i<g[x].size();i++)\n\t\tif(!vis[g[x][i]])\n\t\t{\n\t\t\tin[g[x][i]]++;\n\t\t\tnei[x].push_back(g[x][i]);\n\t\t\tdfs(g[x][i]);\n\t\t}\n}\nvoid topo()\n{\n\tfor(int i=1;i<=n;i++)\n\t\tif(!in[i])\n\t\t\tpq.push(i);\n\twhile(!pq.empty())\n\t{\n\t\tint now=pq.top();\n\t\tpq.pop();\n\t\tcout<<a[now]<<' ';\n\t\tfor(int i=0;i<nei[now].size();i++) pq.push(nei[now][i]);\n\t}\n\tcout<<endl;\n}\nint main()\n{\n\tcin>>n;\n\tfor(int i=1;i<=n;i++)\n\t\tcin>>a[i];\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\tif(__gcd(i,j)!=1)\n\t\t\t{\n\t\t\t\tg[i].push_back(j);\n\t\t\t\tg[j].push_back(i);\n\t\t\t}\n\tfor(int i=1;i<=n;i++)\n\t\tif(!vis[i])\n\t\t\tdfs(i);\n\ttopo();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <queue>\n\n#define Rep(i, n) for (int i = 1; i <= n; i ++)\n#define Rep0(i, n) for (int i = 0; i <= n; i ++)\n#define mp(a, b) make_pair(a, b)\n\nusing namespace std;\n\nconst int N = 2010;\n\nvector<int> e[N], e0[N];\nint dep[N], d[N], a[N];\nbool vis[N];\n\nvoid dfs(int x, int f)\n{\n\tvis[x] = true, dep[x] = dep[f] + 1;\n\tif (e[x].size()) Rep0(i, e[x].size() - 1) {\n\t\tif (!vis[e[x][i]]) dfs(e[x][i], x);\n\t\tif (dep[e[x][i]] > dep[x]) e0[x].push_back(e[x][i]), d[e[x][i]] ++;\n\t\telse e0[e[x][i]].push_back(x), d[x] ++;\n\t}\n}\n\nint gcd(int a, int b) { return !b ? a : gcd(b, a % b);}\n\npriority_queue< pair<int, int> > q;\n\nint main()\n{\n//\tfreopen(\"mmp_.in\", \"r\", stdin);\n//\tfreopen(\"mmp_.out\", \"w\", stdout);\n\n\tint n;\n\tscanf(\"%d\", &n);\n\tRep(i, n) scanf(\"%d\", &a[i]);\n\tsort(a + 1, a + 1 + n);\n\tRep(i, n) Rep(j, i - 1)\n\t\tif (gcd(a[i], a[j]) != 1){\n\t\t\te[i].push_back(j), e[j].push_back(i);\n\t\t//\tprintf(\"%d ---> %d\\n\", i, j);\n\t\t}\n\t\n\tRep(i, n) sort(e[i].begin(), e[i].end());\n\n\tRep(i, n) if (!vis[i]) dfs(i, 0);\n\n\tRep(i, n) if (!d[i]) q.push(mp(a[i], i));\n\n\twhile(!q.empty()) {\n\t\tint x = q.top().second; q.pop();\n\t\tprintf(\"%d \", a[x]);\n\t\tif (e0[x].size()) Rep0(i, e0[x].size() - 1) {\n\t\t\td[e0[x][i]] --;\n\t\t\tif (!d[e0[x][i]]) q.push(mp(a[e0[x][i]], e0[x][i]));\n\t\t}\n\t}\n\tprintf(\"\\n\");\n\n\treturn 0;\n}\n/*\n5\n1 2 3 4 5\n*/"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstring>\n#include <vector>\nusing namespace std;\n\nconst int MAX_N = 2005;\n\nclass Edge {\npublic:\n  int nxt, to;\n} e[MAX_N * MAX_N];\n\nint head[MAX_N], cnt;\n\nvoid addedge(int u, int v) {\n  e[++cnt] = (Edge){head[u], v}, head[u] = cnt;\n  e[++cnt] = (Edge){head[v], u}, head[v] = cnt;\n}\n\nint N, A[MAX_N], top, res[MAX_N], len, st[MAX_N];\nvector<int> G[MAX_N];\nbool vis[MAX_N];\n\nvoid dfs(int u, int v) {\n  vis[u] = 1, st[++top] = u;\n  sort(G[u].begin(), G[u].end());\n\n  for (int i = 0; i < G[u].size(); ++i)\n    if (!vis[G[u][i]]) {\n      dfs(G[u][i], u);\n    }\n}\n\nvoid merge_array() {\n  static int temp[MAX_N];\n  for (int i = 1; i <= len; ++i) temp[i] = res[i];\n  int l1 = 1, l2 = 1, tlen = 0;\n  while (l1 <= top || l2 <= len) {\n    if (l1 > top) res[++tlen] = temp[l2++];\n    else if (l2 > len) res[++tlen] = st[l1++];\n    else if (st[l1] > temp[l2]) res[++tlen] = st[l1++];\n    else res[++tlen] = temp[l2++];\n  }\n  len = tlen;\n}\n\nint main() {\n  scanf(\"%d\", &N);\n  for (int i = 1; i <= N; ++i) scanf(\"%d\", &A[i]);\n  sort(A + 1, A + N + 1);\n  \n  for (int i = 1; i <= N; ++i)\n    for (int j = i + 1; j <= N; ++j)\n      if (__gcd(A[i], A[j]) != 1) {\n\tG[i].push_back(j);\n\tG[j].push_back(i);\n      }\n  \n  for (int i = 1; i <= N; ++i) \n    if (!vis[i]) {\n      top = 0, dfs(i, 0);\n      merge_array();\n    }\n\n  for (int i = 1; i <= N; ++i)\n    printf(\"%d \", A[res[i]]);\n  puts(\"\");\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdio>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nconst int MaxN = 2000;\n\ninline int gcd(int a, int b)\n{\n\twhile (b > 0)\n\t{\n\t\ta %= b;\n\t\tswap(a, b);\n\t}\n\treturn a;\n}\n\nint n;\nint a[MaxN + 1];\n\nbool mat[MaxN + 1][MaxN + 1];\n\nbool vis[MaxN + 1];\n\nint deg[MaxN + 1];\nvector<int> adj[MaxN + 1];\n\nvoid dfs_build(const int &u)\n{\n\tvis[u] = true;\n\n\tfor (int v = 1; v <= n; ++v)\n\t\tif (mat[u][v] && !vis[v])\n\t\t{\n\t\t\tadj[u].push_back(v), ++deg[v];\n\t\t\tdfs_build(v);\n\t\t}\n}\n\nstruct comparator\n{\n\tinline bool operator()(const int &u, const int &v)\n\t{\n\t\tif (a[u] != a[v])\n\t\t\treturn a[u] < a[v];\n\t\treturn u < v;\n\t}\n};\n\npriority_queue<int, vector<int>, comparator> q;\n\nint main()\n{\n\tcin >> n;\n\tfor (int i = 1; i <= n; ++i)\n\t\tcin >> a[i];\n\n\tsort(a + 1, a + n + 1);\n\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = i + 1; j <= n; ++j)\n\t\t\tif (gcd(a[i], a[j]) > 1)\n\t\t\t\tmat[i][j] = mat[j][i] = true;\n\n\tfor (int u = 1; u <= n; ++u)\n\t\tif (!vis[u])\n\t\t\tdfs_build(u);\n\n\tfor (int u = 1; u <= n; ++u)\n\t\tif (!deg[u])\n\t\t\tq.push(u);\n\n\twhile (!q.empty())\n\t{\n\t\tint u = q.top();\n\t\tq.pop();\n\n\t\tcout << a[u] << ' ';\n\n\t\tfor (int v : adj[u])\n\t\t\tif (!--deg[v])\n\t\t\t\tq.push(v);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<set>\n#include<unordered_set>\n#define lol(i,n) for(ll i=0;i<n;i++)\n#define mod 1000000007\n#define chmax(a,b) a=max(a,b);\n#define chmin(a,b) a=min(a,b);\ntypedef long long ll;\n\nusing namespace std;\nll gcd(ll a,ll b){\n  if(a<b)swap(a,b);\n  if(b==0)return a;\n  return gcd(a%b,b);\n}\nbool edge(ll a,ll b){\n  return gcd(a,b)>1;\n}\n#define N 2010\nll b[N],a[N],n;\nvector<ll> g[N];\n\nclass Aoki{\n  public:\n  ll nz[N];\n  void buildg(){\n    lol(i,n)g[i].clear();\n    lol(i,n)lol(j,i){\n      if(edge(b[i],b[j])){\n\tg[j].push_back(i);\n\tnz[i]++;\n      }\n    }\n  }\n  void main(){\n    lol(i,n)nz[i]=0;\n    buildg();\n    //cout<<\"b=\";lol(i,n)cout<<b[i]<<\" \";cout<<endl;\n    //lol(i,n)cout<<nz[i]<<\" \";cout<<endl;\n    priority_queue<pair<ll,ll> >Q;\n    lol(i,n)if(nz[i]==0)Q.push(make_pair(b[i],i));\n    vector<ll> res;\n    unordered_set<ll> vis;\n    while(!Q.empty()){\n      ll val=Q.top().first;\n      ll x=Q.top().second;\n      Q.pop();\n      if(vis.find(x)!=vis.end())continue;\n      vis.insert(x);\n      res.push_back(val);\n      for(auto y:g[x]){\n\tnz[y]--;\n\tif(nz[y]==0)Q.push(make_pair(b[y],y));\n      }\n    }\n    lol(i,n){\n      if(i)cout<<\" \";\n      cout<<res[i];\n    }cout<<endl;\n  }\n};Aoki kensho;\n\nclass Takahashi{\n  public:\n  bool used[N];\n  void buildg(){\n    lol(i,n)g[i].clear();\n    lol(i,n)lol(j,n){\n      if(used[i])continue;\n      if(used[j])continue;\n      if(i!=j&&edge(a[i],a[j])){\n\tg[i].push_back(j);\n      }\n    }\n    //cout<<\"g2=\";for(auto x:g[2])cout<<x<<\" \";cout<<endl;\n  }\n  unordered_set<ll> vis;\n  ll dfs(ll x){\n    if(vis.find(x)!=vis.end())return mod;\n    vis.insert(x);\n    ll res=x;\n    for(auto y:g[x]){\n      chmin(res,dfs(y));\n    }\n    return res;\n  }\n  ll ma[N];\n  void upd(ll x,ll val){\n    if(~ma[x])return;\n    ma[x]=val;\n    for(auto y:g[x]){\n      upd(y,val);\n    }\n  }\n  \n  vector<ll> res;\n  void sub(){\n    buildg();\n    //cout<<\"buildend\"<<endl;\n    lol(i,n)ma[i]=-1;\n    lol(i,n){\n      if(vis.find(i)!=vis.end())continue;\n      upd(i,dfs(i));\n    }\n    //cout<<\"ma=\";lol(i,n)cout<<ma[i]<<\" \";cout<<endl;\n    //cout<<\"dfsend\"<<endl;\n    priority_queue<ll,vector<ll>,greater<ll> >Q;\n    lol(i,n){\n      if(i==ma[i])Q.push(i);\n    }\n    vis.clear();\n    while(!Q.empty()){\n      ll x=Q.top(); Q.pop();\n      if(vis.find(x)!=vis.end())continue;\n      vis.insert(x);\n      used[x]=1;\n      //cout<<x<<\" \";\n      res.push_back(x);\n      ll mini=1e18;\n      for(auto y:g[x]){\n\tif(!used[y])\n\tchmin(mini,y);\n      }\n      if(mini<1e18)Q.push(mini);\n    }//cout<<endl;\n    //cout<<\"#\"<<res.size()<<endl;\n    //cout<<\"a=\";lol(i,n)cout<<res[i]<<\" \";cout<<endl;\n  }\n  void main(){\n    lol(i,n)used[i]=0;\n    while(1){\n      bool ok=0;\n      lol(i,n)if(used[i]==0)ok=1;\n      if(!ok)break;\n      sub();\n    }\n    //cout<<\"#\"<<res.size()<<endl;\n    //cout<<\"a=\";lol(i,n)cout<<res[i]<<\" \";cout<<endl;\n    lol(i,n)b[i]=a[res[i]];\n    //cout<<\"b=\";lol(i,n)cout<<b[i]<<\" \";cout<<endl;\n  }\n};Takahashi chokudai;\n\nint main(){\n    cin>>n;\n    lol(i,n)cin>>a[i];\n    sort(a,a+n);\n    chokudai.main();\n    //cout<<\"chokudai-end\"<<endl;\n    kensho.main();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n,a[2005],V;\nvector<int>edge[2005];\nbool used[2005][2005];\nint in[2005];\nvector<int>nxt;\nP q;\nvoid dfs(int v){\n\tif(used[V][v]) return; used[V][v] = 1;\n\tnxt.pb(v);\n\trep(i,edge[v].size()){\n\t\tif(used[V][edge[v][i]] || in[edge[v][i]] != V) continue;\n\t\tdfs(edge[v][i]);\n\t}\n}\nvector<int>make(vector<int>L,int cut){\n\tvector<int>ret;\n\tif(L.size() == 1){\n\t\tret.pb(cut); return ret;\n\t}\n\trep(i,L.size()){\n\t\tif(L[i] != cut){\n\t\t    in[L[i]] = cut;\n\t\t    //cout<<L[i]<<\" \"<<cut<<endl;\n\t\t}\n\t}\n//\trep(i,L.size()) cout<<L[i]<<\" \"; cout<<endl; \n//\tcout<<cut<<in[3]<<in[4]<<endl;\n\tvector<pair<vector<int>,int> >vv;\n\trep(i,L.size()){\n\t\tif(L[i] == cut) continue;\n\t\tif(!used[cut][L[i]]){\n\t\t\tnxt.clear(); q = mp(INF,INF);\n\t\t\tV = cut; dfs(L[i]); //cout<<L.size()<<\" \"<<cut<<\" \"<<L[i]<<in[3]<<in[4]<<endl;\n\t\t\trep(j,nxt.size()){\n\t\t\t\tif(__gcd(a[nxt[j]],a[cut]) > 1){\n\t\t\t\t\tq = min(q,mp(a[nxt[j]],nxt[j]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tvv.pb(mp(nxt,q.sc));\n\t\t}\n\t}\n\trep(ii,vv.size()){\n\t\tvector<int>nxt = vv[ii].fi; int Q = vv[ii].sc;\n\t\tvector<int>hoge = make(nxt,Q);\n\t\tvector<int>ret2;\n\t\tint c = ret.size(),b = hoge.size();\n\t\tint i = 0,j = 0;\n\t\twhile(i!=c || j!=b){\n\t\t\tif(i==c) ret2.pb(hoge[j++]);\n\t\t\telse if(j==b) ret2.pb(ret[i++]);\n\t\t\telse{\n\t\t\t\tif(a[ret[i]] > a[hoge[j]]) ret2.pb(ret[i++]);\n\t\t\t\telse ret2.pb(hoge[j++]);\n\t\t\t}\n\t\t}\n\t\tret = ret2;\n\t}\n\treverse(ret.begin(),ret.end());\n\tret.pb(cut);\n\treverse(ret.begin(),ret.end());\n\treturn ret;\n}\nbool U[2005];\nvector<int>vi;\nP p;\nvoid DFS(int x){\n\tif(U[x]) return; U[x] = 1;\n\tvi.pb(x); p = min(p,mp(a[x],x));\n\trep(i,edge[x].size()){\n\t\tDFS(edge[x][i]);\n\t}\n}\nvector<int>res;\nint main(){\n\tcin>>n;\n\trepn(i,n){\n\t\tcin>>a[i];\n\t}\n\trepn(i,n) repn(j,n){\n\t\tif(i != j && __gcd(a[i],a[j]) > 1){\n\t\t\tedge[i].pb(j);\n\t\t}\n\t}\n\trepn(i,n){\n\t\tif(U[i]) continue; p = mp(INF,INF); vi.clear();\n\t\tDFS(i);\n\t\tvector<int>vec = make(vi,p.sc);\n\t\tvector<int>res2;\n\t\tint c = 0,b = 0;\n\t\twhile(c != res.size() || b != vec.size()){\n\t\t\tif(c == res.size()) res2.pb(vec[b++]);\n\t\t\telse if(b == vec.size()) res2.pb(res[c++]);\n\t\t\telse{\n\t\t\t\tif(a[res[c]] > a[vec[b]]) res2.pb(res[c++]);\n\t\t\t\telse res2.pb(vec[b++]);\n\t\t\t}\n\t\t}\n\t\tres = res2;\n\t}\n\trep(i,n) cout<<a[res[i]]<<\" \";\n\tcout<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pii pair <int, int>\n\nusing namespace std;\n\nconst int N = 2005, M = 4005;\nint n, a[N], edge[N][N], ans[N], root[N], sz[N], b[N], ed[N], fa[N];\nbool vis[N];\n\nint gcd(int x, int y) {\n    if (y == 0) return x;\n    return gcd(y, x % y);\n}\n\n\nvoid dfs(int x) {\n    vis[x] = 1;\n    sz[x] = 1;\n    for (int xx = 1; xx <= n; xx++) {\n        if (edge[x][xx] && !vis[xx]) {\n            dfs(xx);\n            sz[x] += sz[xx];\n        }\n    }\n}\n\nvoid solve(int x, int l, int r)\n{\n    priority_queue <pii> q;\n    vis[x] = 1;\n    int now = l;\n    for (int xx = 1; xx <= n; xx++) {\n        if (edge[x][xx] && !vis[xx]) {\n            solve(xx, now + 1, now + sz[xx]);\n            q.push(pii(ans[now + 1], now + 1));\n            now += sz[xx];\n        }\n    }\n    now = 0;\n    while (!q.empty()) {\n        pii xx = q.top();\n        q.pop();\n        b[++now] = xx.first;\n        if (xx.second < ed[xx.second]) {\n            q.push(pii(ans[xx.second + 1], xx.second + 1));\n        }\n    }\n    ans[l] = a[x];\n    ed[l] = r;\n    for (int i = l + 1; i <= r; i++) {\n        ans[i] = b[i - l];\n        ed[i] = r;\n    }\n}\n\nint main() {\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n        cin >> a[i];\n    }\n    sort(a + 1, a + n + 1);\n    for (int i = 1; i <= n; i++) {\n        for (int j = i + 1; j <= n; j++) {\n            if (gcd(a[i], a[j]) > 1) {\n                edge[i][j] = 1;\n                edge[j][i] = 1;\n            }\n        }\n    }\n    for (int i = 1; i <= n; i++) {\n        if (!vis[i]) {\n            dfs(i);\n            edge[0][i] = 1;\n            edge[i][0] = 1;\n        }\n    }\n    memset(vis, 0, sizeof(vis));\n    solve(0, 0, n);\n    for (int i = 1; i < n; i++) {\n        cout << ans[i] << \" \";\n    }\n    cout << ans[n] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <set>\n#include <deque> \n#define rep(x, a, b) for(int x = (a); x <= (b); ++x)\n#define rop(x, a, b) for(int x = (a); x < (b); ++x)\n#define per(x, a, b) for(int x = (a); x >= (b); --x)\nusing namespace std;\ntypedef long long LL;\ntypedef double DB;\ndeque<int> C[1005];\nint a[1005];\nstruct graph {\n\tset<int> S[1005];\n\tint vs[1005];\n\tvoid push(int x, int y) {\n\t\tS[x].insert(y);\n\t}\n\tvoid dfs(int nw) {\n\t\tC[nw].clear();\n\t\tvs[nw] = 1;\n\t\tint SM = 0;\n\t\tauto IT = S[nw].begin();\n\t\twhile(IT != S[nw].end()) {\n\t\t\tif(vs[*IT]) {C[*IT].clear(); ++IT; continue;}\n\t\t\tdfs(*IT);\n\t\t\tSM += C[*IT].size();\n\t\t\t++IT;\n\t\t}\n\t\trep(i, 1, SM) {\n\t\t\tint mx = 0, bj = 0;\n\t\t\tauto IT = S[nw].begin();\n\t\t\twhile(IT != S[nw].end()) {\n\t\t\t\tif(!C[*IT].size()) {++IT; continue;}\n\t\t\t\tif(mx < C[*IT][0]) mx = C[*IT][0], bj = *IT;\n\t\t\t\t++IT;\n\t\t\t}\n\t\t\tC[bj].pop_front();\n\t\t\tC[nw].push_back(mx);\n\t\t}\n\t\tC[nw].push_front(a[nw]);\n\t}\n}G;\nint n;\nint main() {\n\tscanf(\"%d\", &n);\n\trep(i, 1, n) scanf(\"%d\", &a[i]);\n\trep(i, 1, n) rep(j, 1, n) if(i != j && __gcd(a[i], a[j]) != 1) G.push(i, j); \n\trep(i, 1, n) G.push(0, i);\n\tG.dfs(0);\n\trop(i, 1, C[0].size()) printf(\"%d \", C[0][i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,a[2005],in[2005];\nbool vis[2005];\npriority_queue<int> pq;\nvector<int> g[2005],g1[2005];\nvoid dfs(int x)\n{\n\tvis[x]=1;\n\tfor(int i=0;i<g1[x].size();i++)\n\t\tif(!vis[g1[x][i]])\n\t\t{\n\t\t\tin[g1[x][i]]++;\n\t\t\tg[x].push_back(g1[x][i]);\n\t\t\tdfs(g1[x][i]);\n\t\t}\n}\nvoid topo()\n{\n\tfor(int i=1;i<=n;i++)\n\t\tif(!in[i])\n\t\t\tpq.push(i);\n\twhile(!pq.empty())\n\t{\n\t\tint now=pq.top();\n\t\tpq.pop();\n\t\tcout<<a[now]<<' ';\n\t\tfor(int i=0;i<g[now].size();i++) pq.push(g[now][i]);\n\t}\n\tcout<<endl;\n}\nint main()\n{\n\tcin>>n;\n\tfor(int i=1;i<=n;i++)\n\t\tcin>>a[i];\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\tif(__gcd(a[i],a[j])!=1)\n\t\t\t{\n\t\t\t\tg1[i].push_back(j);\n\t\t\t\tg1[j].push_back(i);\n\t\t\t}\n\tfor(int i=1;i<=n;i++)\n\t\tif(!vis[i])\n\t\t\tdfs(i);\n\ttopo();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nconst int maxn = 2030, oo = 123456789, maxm = 34010;\n \nint n, m, T, ans, mn, a[maxn], foo[maxn], lst[maxm], tag[maxn], q[maxn], rar, mx[maxn];\nbool vis[maxn], f[maxn], G[maxn][maxn], F[maxn];\nstd::vector<int> g[maxn], has[maxn], rhas[maxm], all;\nstd::vector<std::pair<int, int> > v;\n \nvoid GEN() {\n\tint mx = 0;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif(!foo[i]) {\n\t\t\tif(a[i] == 1) {\n\t\t\t\tF[i] = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tF[i] = 0;\n\t\t\t\tfor (int j: has[i]) {\n\t\t\t\t\tif(lst[j] >= mx) {\n\t\t\t\t\t\tF[i] = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t(foo[i] > mx) && (mx = foo[i]);\n\t\t}\n\t}\n\treturn;\n}\n /*\ninline void dfs(int &u) {\n\ttag[u] = T;\n\t(F[u] && a[u] < mn) && (mn = a[u]);\n\tvis[u] = 1;\n\tfor (int &v: g[u]) {\n\t\tif(!vis[v] && !f[v]) {\n\t\t\tdfs(v);\n\t\t}\n\t}\n\treturn;\n}\n */\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tscanf(\"%d\", a + i);\n\t\tint t = a[i];\n\t\tfor (int x = 2; x * x <= t; ++x) {\n\t\t\tif(t % x == 0) {\n\t\t\t\tall.push_back(x);\n\t\t\t\twhile(t % x == 0) {\n\t\t\t\t\tt /= x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(t > 1) {\n\t\t\tall.push_back(t);\n\t\t}\n\t}\n\tstd::sort(a + 1, a + n + 1);\n\tstd::sort(all.begin(), all.end());\n\tall.resize(std::unique(all.begin(), all.end()) - all.begin());\n\tm = (int)(all.size());\n\tfor (int i = 1; i <= n; ++i) {\n\t\tF[i] = 1;\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tif(a[i] % all[j] == 0) {\n\t\t\t\thas[i].push_back(j);\n\t\t\t\trhas[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int j = 0; j < m; ++j) {\n\t\tfor (int i = 0; i < (int)(rhas[j].size()); ++i) {\n\t\t\tfor (int k = 0; k < i; ++k) {\n\t\t\t\tint u = rhas[j][i], v = rhas[j][k];\n\t\t\t\tif(!G[u][v]) {\n\t\t\t\t\tg[u].push_back(v);\n\t\t\t\t\tg[v].push_back(u);\n\t\t\t\t\tG[u][v] = G[v][u] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n//\t\tGEN();\n\t\tmemset(vis + 1, 0, sizeof(vis[0]) * n);\n\t\tv.clear();\n\t\tfor (int u = 1; u <= n; ++u) {\n\t\t\tif(F[u]) {\n\t\t\t\tif(!vis[u] && !f[u]) {\n\t\t\t\t\t++T;\n\t\t\t\t\tmn = oo;\n//\t\t\t\t\tdfs(u);\n\t\t\t\t\trar = 0;\n\t\t\t\t\tq[rar++] = u;\n\t\t\t\t\tvis[u] = 1;\n\t\t\t\t\tfor (register int fnt = 0; fnt < rar; ++fnt) {\n\t\t\t\t\t\tint u = q[fnt];\n\t\t\t\t\t\ttag[u] = T;\n\t\t\t\t\t\t(F[u] && a[u] < mn) && (mn = a[u]);\n\t\t\t\t\t\tfor (int &v: g[u]) {\n\t\t\t\t\t\t\tif(!vis[v] && !f[v]) {\n\t\t\t\t\t\t\t\tq[rar++] = v;\n\t\t\t\t\t\t\t\tvis[v] = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tv.push_back(std::make_pair(mn, T));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstd::sort(v.begin(), v.end());\n\t\tint sz = (int)(v.size());\n\t\t//ans = 0;\n\t\tfor (int u = 1; u <= n; ++u) {\n\t\t\tif(F[u] && !f[u]) {\n\t\t\t\tint i = sz - 1;\n\t\t\t\tif(v[i].second == tag[u]) {\n\t\t\t\t\t--i;\n\t\t\t\t}\n\t\t\t\tif(i < 0 || v[i].first <= a[u]) {\n\t\t\t\t\tans = u;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tf[ans] = 1;\n\t\tfoo[ans] = i;\n\t\tprintf(\"%d \", a[ans]);\n\t\tfor (int j: has[ans]) {\n\t\t\tlst[j] = i;\n\t\t}\n\t\tfor (int j = ans + 1; j <= n; ++j) {\n\t\t\tmx[j] = i;\n\t\t\tF[j] = 0;\n\t\t\tfor (int &k: has[j]) {\n\t\t\t\tif(lst[k] >= i) {\n\t\t\t\t\tF[j] = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int j: has[ans]) {\n\t\t\tfor (int &k: rhas[j]) {\n\t\t\t\tif(k > ans) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tF[k] |= (lst[j] >= mx[k]);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n/*char buf[1<<21],*p1=buf,*p2=buf;\ninline int gc(){return p1==p2&&(p2=(p1=buf)+fread(buf,1,1<<21,stdin),p1==p2)?EOF:*p1++;}*/\n#define gc getchar\ninline int read()\n{\n    int ret=0,f=0;char c=gc();\n    while(!isdigit(c)){if(c=='-')f=1;c=gc();}\n    while(isdigit(c)){ret=ret*10+c-48;c=gc();}\n    if(f)return -ret;return ret;\n}\nconst int N=2010;\nint vis[N],f[N][N],du[N],a[N];\nvector<int>g[N];\nint n;\nvoid dfs(int u)\n{\n    vis[u]=1;\n    for(int i=1;i<=n;i++)\n    \tif(!vis[i]&&f[u][i])\n\t\t{\n\t        du[i]++;\n\t        g[u].push_back(i);\n\t        dfs(i);\n   \t \t}\n}\nvoid solve()\n{\n    priority_queue<int>q;\n    for(int i=1;i<=n;i++)\n\t\tif(!du[i])q.push(i);\n    while(!q.empty())\n\t{\n        int u=q.top();q.pop();\n        cout<<a[u]<<\" \";\n        for(int i=0;i<g[u].size();i++)q.push(g[u][i]);\n    }\n}\nsigned main()\n{\n    n=read();\n    for(int i=1;i<=n;i++)a[i]=read();\n    sort(a+1,a+n+1);\n    for(int i=1;i<=n;i++)\n    \tfor(int j=i+1;j<=n;j++)\n    \t\tif(__gcd(a[i],a[j])!=1)f[i][j]=f[j][i]=1;\n    for(int i=1;i<=n;i++)\n\t\tif(!vis[i])dfs(i);\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "//waz\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)((x).size()))\n\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\ntypedef long long int64;\ntypedef unsigned int uint;\ntypedef unsigned long long uint64;\n\n#define gi(x) ((x) = F())\n#define gii(x, y) (gi(x), gi(y))\n#define giii(x, y, z) (gii(x, y), gi(z))\n\nint F()\n{\n\tchar ch;\n\tint x, a;\n\twhile (ch = getchar(), (ch < '0' || ch > '9') && ch != '-');\n\tif (ch == '-') ch = getchar(), a = -1;\n\telse a = 1;\n\tx = ch - '0';\n\twhile (ch = getchar(), ch >= '0' && ch <= '9')\n\t\tx = (x << 1) + (x << 3) + ch - '0';\n\treturn a * x;\n}\n\nconst int N = 2010;\n\nint n, a[N], t[N][N], deg[N];\n\nbool vis[N];\n\nVI edge[N];\n\nvoid dfs(int u)\n{\n\tvis[u] = 1;\n\tfor (int j = 1; j <= n; ++j)\n\t\tif (!vis[j] && t[u][j])\n\t\t\tedge[u].pb(j), ++deg[j], dfs(j);\n}\n\npriority_queue<int> pq;\n\nint main()\n{\n\tgi(n);\n\tfor (int i = 1; i <= n; ++i) gi(a[i]);\n\tsort(a + 1, a + n + 1);\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = 1; j <= n; ++j)\n\t\t\tif (__gcd(a[i], a[j]) != 1)\n\t\t\t\tt[i][j] = 1;\n\tfor (int i = 1; i <= n; ++i)\n\t\tif (!vis[i]) dfs(i);\n\tfor (int i = 1; i <= n; ++i) if (!deg[i]) pq.push(i);\n\twhile (!pq.empty())\n\t{\n\t\tint u = pq.top(); pq.pop();\n\t\tprintf(\"%d \", a[u]);\n\t\tfor (int i=0;i<(int)edge[u].size();i++)\n\t\t{\n\t\t    int v=edge[u][i];\n\t\t\t--deg[v];\n\t\t\tif (!deg[v]) pq.push(v);\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 2e3 + 3;\nint N, A[maxn], deg[maxn];\nvector<int> G[maxn], F[maxn];\nint gcd(int x, int y) { return !y ? x : gcd(y, x % y); }\n\nint vis[maxn], root[maxn], r_cnt, now_min;\nvoid dfs(int x) {\n  if (A[x] < A[now_min]) now_min = x;\n  for (auto to : G[x])\n    if (!vis[to]) vis[to] = 1, dfs(to);\n}\n\nstruct node {\n  int id;\n  node(int _id = 0) : id(_id) {}\n  bool operator<(const node& o) const { return A[id] < A[o.id]; }\n  bool operator>(const node& o) const { return A[id] > A[o.id]; }\n};\nint mp[maxn][maxn];\npriority_queue<node, vector<node>, greater<node> > que_1;\npriority_queue<node> que_2;\nvoid bfs_1(int S) {\n  vis[S] = 1, que_1.push(S);\n  while (!que_1.empty()) {\n    int now = que_1.top().id;\n    que_1.pop();\n    for (auto to : G[now]) {\n      if (!vis[to]) {\n        F[now].push_back(to), deg[to]++, mp[now][to] = 1;\n        vis[to] = 1, que_1.push(to);\n      } else if (!mp[to][now])\n        F[now].push_back(to), deg[to]++, mp[now][to] = 1;\n    }\n  }\n}\n\nint ans_cnt, Ans[maxn];\nvoid bfs_2() {\n  for (int i = 1; i <= N; i++)\n    if (!deg[i]) que_2.push(i);\n  while (!que_2.empty()) {\n    int now = que_2.top().id;\n    Ans[++ans_cnt] = now, que_2.pop();\n    for (auto to : F[now]) {\n      deg[to]--;\n      if (!deg[to]) que_2.push(to);\n    }\n  }\n}\n\nint main() {\n  scanf(\"%d\", &N);\n  for (int i = 1; i <= N; i++) scanf(\"%d\", &A[i]);\n  for (int i = 1; i <= N; i++) {\n    for (int j = i + 1; j <= N; j++) {\n      if (gcd(A[i], A[j]) == 1) continue;\n      G[i].push_back(j);\n      G[j].push_back(i);\n    }\n  }\n  memset(vis, 0, sizeof(vis));\n  for (int i = 1; i <= N; i++) {\n    if (vis[i]) continue;\n    vis[now_min = i] = 1, dfs(i);\n    root[++r_cnt] = now_min;\n  }\n  memset(vis, 0, sizeof(vis));\n  for (int i = 1; i <= r_cnt; i++) bfs_1(root[i]);\n  bfs_2();\n  for (int i = 1; i <= N; i++) printf(\"%d%c\", Ans[i], \" \\n\"[i == N]);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*************************************************\n *************************************************\n *************************************************\n *** _________________  |            |  |     /***\n ***         |          |            |  |    / ***\n ***         |          |            |  |   /  ***\n ***         |          |            |  |  /   ***\n ***         |          |            |  | /    ***\n ***         |          |____________|  |/  en ***\n ***         |          |            |  |\\     ***\n ***         |          |            |  | \\    ***\n *** _____   |          |            |  |  \\   ***\n ***   |     |          |            |  |   \\  ***\n ***   \\     /          |            |  |    \\ ***\n ***    \\___/           |            |  |     \\***\n *************************************************\n *************Written by: JiangHaoKai*************\n *************************************************/\n\n#pragma GCC optimize(2)\n#pragma G++ optimize(2)\n#pragma comment(linker,\"/STACK:102400000,102400000\")\n\n//#include <bits/stdc++.h>\n#include <cassert>\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdalign>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <string>\n#include <typeinfo>\n#include <valarray>\n#include <vector>\n#include <array>\n#include <atomic>\n#include <chrono>\n#include <condition_variable>\n#include <forward_list>\n#include <future>\n#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <scoped_allocator>\n#include <system_error>\n#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <unordered_map>\n#include <unordered_set>\n//#include <conio.h>\n//#include <windows.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef unsigned int ui;\ntypedef unsigned long long ull;\ntypedef float fl;\ntypedef double ld;\ntypedef pair<int,int> pii;\n#define ui(n) ((unsigned int)(n))\n#define ll(n) ((long long)(n))\n#define ull(n) ((unsigned long long)(n))\n#define fl(n) ((float)(n))\n#define ld(n) ((double)(n))\n#define char(n) ((char)(n))\n#define Bool(n) ((bool)(n))\n#define fixpoint(n) fixed<<setprecision(n)\nconst int INF=1061109567;\nconst LL LINF=4557430888798830399;\n#define PI 3.1415926535897932384626433832795028841971\n#define MP make_pair\n#define MT make_tuple\n#define All(a) (a).begin(),(a).end()\n#define pall(a) (a).rbegin(),(a).rend()\n#define MOD 1000000007\n#define sz(a) ((int)(a).size())\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define repa(i,a,n) for(int i=a;i<n;i++)\n#define repa1(i,a,n) for(int i=a;i<=n;i++)\n#define repd(i,n) for(int i=n-1;i>=0;i--)\n#define repd1(i,n) for(int i=n;i>=1;i--)\n#define repda(i,n,a) for(int i=n;i>a;i--)\n#define repda1(i,n,a) for(int i=n;i>=a;i--)\n#define FOR(i,a,n,step) for(int i=a;i<n;i+=step)\n#define repv(itr,v) for(__typeof((v).begin()) itr=(v).begin();itr!=(v).end();itr++)\n#define repV(i,v) for(auto i:v)\n#define repE(i,v) for(auto &i:v)\n#define MS(x,y) memset(x,y,sizeof(x))\n#define MC(x) MS(x,0)\n#define MCP(x,y) memcpy(x,y,sizeof(y))\n#define sqr(x) ((x)*(x))\n#define filein(x) freopen(x,\"r\",stdin)\n#define fileout(x) freopen(x,\"w\",stdout)\n#define fileout2(filename,name) ofstream name(filename,ios::out)\n#define filein2(filename,name) ifstream name(filename,ios::in)\n#define file(filename,name) fstream name(filename,ios::in|ios::out)\n#define Pause system(\"pause\")\n#define Cls system(\"cls\")\n#define fs first\n#define sc second\n#define PC(x) putchar(x)\n#define GC(x) x=getchar()\n#define Endl PC('\\n')\n#define SF scanf\n#define PF printf\n\ninline int Read()\n{\n    int X=0,w=0;char ch=0;while(!isdigit(ch)){w|=ch=='-';ch=getchar();}while(isdigit(ch))X=(X<<3)+(X<<1)+(ch^48),ch=getchar();\n\treturn w?-X:X;\n}\ninline void Write(int x){if(x<0)putchar('-'),x=-x;if(x>9)Write(x/10);putchar(x%10+'0');}\n\ninline LL powmod(LL a,LL b){LL res=1;a%=MOD;assert(b>=0);for(;b;b>>=1){if(b&1)res=res*a%MOD;a=a*a%MOD;}return res;}\ninline LL gcdll(LL a,LL b){return b?gcdll(b,a%b):a;}\nconst int dx[]={0,1,0,-1,1,-1,-1,1};\nconst int dy[]={1,0,-1,0,-1,-1,1,1};\n/**************************************************************Begin***************************************************************/\nconst int maxn=2010;\n\nint n,nn,a[maxn],x[maxn];\nLL g[maxn][maxn],was[maxn];\nbool alive[maxn],canput[maxn];\n\nint main()\n{\n\tSF(\"%d\",&n);\n\trep(i,n) SF(\"%d\",&a[i]);\n\t\n\trep(i,n) rep(j,n) if(__gcd(a[i],a[j])>1)\n\t{\n\t\tg[i][j>>6]|=(1<<(j&63));\n\t\tg[j][i>>6]|=(1<<(i%63));\n\t}\n\t\n\tnn=((n-1)>>6)+1;\n\trep(i,n) alive[i]=canput[i]=1;\n\t\n\trep(it,n)\n\t{\n\t\trep(i,n) was[i]=0;\n\t\trep(i,n) if(!alive[i]) was[i>>6]|=(1<<(i&63));\n\t\t\n\t\tint best=-1;\n\t\trep(i,n) if(!(was[i>>6]&(1<<(i&63))))\n\t\t{\n\t\t\tint b=0,e=1;\n\t\t\tx[0]=i;\n\t\t\twas[i>>6]|=(1<<(i&63));\n\t\t\t\n\t\t\twhile(b<e)\n\t\t\t{\n\t\t\t\trep(j,nn) if((g[x[b]][j]&was[j])!=g[x[b]][j])\n\t\t\t\t{\n\t\t\t\t\trepa(u,j*64,(j+1)*64) if(g[x[b]][u>>6]&(1<<(u&63))) if(!(was[u>>6]&(1<<(u&63))))\n\t\t\t\t\t{\n\t\t\t\t\t\twas[u>>6]|=(1<<(u&63));\n\t\t\t\t\t\tx[e++]=u;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tb++;\n\t\t\t}\n\t\t\t\n\t\t\tint cur=-1;\n\t\t\trep(j,e) if(canput[x[j]])\n\t\t\t{\n\t\t\t\tif(cur==-1||a[x[j]]<a[cur]) cur=x[j];\n\t\t\t}\n\t\t\t\n\t\t\tif(best==-1||(cur!=-1&&a[cur]>a[best])) best=cur;\n\t\t}\n\t\t\n\t\tPF(\"%d \",a[best]);\n\t\talive[best]=0;\n\t\trep(i,n) if(alive[i])\n\t\t{\n\t\t\tif(g[best][i>>6]&(1<<(i&63))) canput[i]=1;\n\t\t\telse if(a[best]<a[i]) canput[i]=0;\n\t\t}\n\t}\n\n\treturn 0;\n}\n/***************************************************************End****************************************************************/\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 1000000007\n#define INF (1<<29)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\nInt gcd(Int a, Int b){\n  if(a == 0)return b;\n  return gcd(b % a, a);\n}\n\nbool edge[2160][2160];\nInt a[2160];\nbool come[2160];\nInt n;\nvector<int> children[2160];\nvoid dfs(int x, int p = -1){\n  if(come[x])return;\n  if(p != -1)children[p].push_back(x);\n  come[x] = true;\n  for(int i = 0;i < n;i++){\n    if(edge[x][i])dfs(i, x);\n  }\n}\n\nvector<int> dfs2(int x){\n  vector<int> res, tmp1, tmp2;\n  for(int to:children[x]){\n    tmp1 = res;\n    tmp2 = dfs2(to);\n    res.clear();\n    int a = 0, b = 0;\n    while(a < tmp1.size() || b < tmp2.size()){\n      if(b == tmp2.size() || a < tmp1.size() && tmp1[a] > tmp2[b])res.push_back(tmp1[a++]);\n      else res.push_back(tmp2[b++]);\n    }\n  }\n  res.insert(res.begin(), x);\n  return res;\n}\n\nint main(){\n  cin >> n;\n  for(int i = 0;i < n;i++)cin >> a[i];\n  a[n] = 0;n++;\n  sort(a, a+n);\n  for(int i = 0;i < n;i++)\n    for(int j = 0;j < n;j++)\n      if(gcd(a[i], a[j]) != 1)edge[i][j] = edge[j][i] = 1;\n  dfs(0);\n  vector<int> res = dfs2(0);\n  for(int i = 1;i < res.size();i++)cout << a[res[i]] << \" \";\n  for(int i = 1;i < n;i++)if(a[i] == 1)cout << 1 << \" \";\n  cout << endl;  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#include <ext/pb_ds/assoc_container.hpp> // Common file\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vb = vector<bool>;\nusing vd = vector<double>;\nusing vs = vector<string>;\n\ntypedef tree<\nll,\nnull_type,\nless<ll>,\nrb_tree_tag,\ntree_order_statistics_node_update>\nordered_set;\n// ordered_set X;\n// *X.find_by_order(i) = ith largest element (counting from zero)\n// X.order_of_key(k) = number of items in X < k (strict lt)\n\nll gcd(ll a, ll b) {\n    if (b > a) return gcd(b, a);\n    if (b == 0) return a;\n    return gcd(b, a % b);\n}\n\nint main(){\n    int N;\n    cin >> N;\n\n    vll A(N);\n    for (int i=0;i<N;i++) cin >> A[i];\n\n    unordered_set<ll> primes;\n    vll Acpy(A.begin(), A.end());\n    for (int i=0;i<N;i++) {\n        for (int j=2;j*j<=Acpy[i];j++) {\n            if (Acpy[i] % j == 0) {\n                primes.insert(j);\n                while (Acpy[i] % j == 0) Acpy[i] /= j;\n            }\n        }\n        if (Acpy[i] > 1) primes.insert(Acpy[i]);\n    }\n\n    vll prs(primes.begin(), primes.end());\n    int P = prs.size();\n\n    vvi adj(N + P);\n\n    // replace with sparsified graph\n    for (int i=0;i<N;i++) {\n        for (int j=0;j<P;j++) {\n            if (A[i] % prs[j] == 0) {\n                adj[i].push_back(N+j);\n                adj[N+j].push_back(i);\n            }\n        }\n    }\n\n    // for (int i=0;i<N+P;i++) {\n    //     cout << i << \": \";\n    //     for (int v : adj[i]) cout << v << \" \";\n    //     cout << endl;\n    // }\n\n    vi comps(N + P, -1);\n    vi smallest;\n    int ncomps = 0;\n    for (int i=0;i<N;i++) {\n        if (comps[i] == -1) {\n            comps[i] = ncomps;\n            queue<int> bfs;\n            bfs.push(i);\n\n            int curmin = i;\n\n            while (!bfs.empty()) {\n                int cur = bfs.front();\n                bfs.pop();\n\n                if(cur < N && A[cur] < A[curmin]) curmin = cur;\n\n                for (int nbr : adj[cur]) {\n                    if (comps[nbr] == -1) {\n                        comps[nbr] = ncomps;\n                        bfs.push(nbr);\n                    }\n                }\n            }\n\n            smallest.push_back(curmin);\n            ncomps++;\n        }\n    }\n\n    priority_queue<pair<ll, int>> process;\n    for (int i : smallest) {\n        // cout << \"adding \" << A[i] << \" \" << i << endl;\n        process.push({A[i], i});\n    }\n\n    vb dead(N+P, false);\n    vi order;\n\n    while (!process.empty()) {\n        auto cur = process.top();\n        process.pop();\n        int v = cur.second;\n\n        // cout << \"processing \" << A[v] << \" \" << v << endl;\n\n        order.push_back(v);\n        dead[v] = true;\n        int curc = comps[v];\n\n        for (int w : adj[v]) {\n            if (comps[w] == curc) {\n                comps[w] = ncomps;\n                queue<int> bfs;\n                bfs.push(w);\n\n                vi cps;\n\n                while (!bfs.empty()) {\n                    int cur = bfs.front();\n                    bfs.pop();\n\n                    // cout << \"bfs \" << cur;\n                    // if (cur < N) cout << \" (A \" << A[cur] << \")\\n\";\n                    // else cout << \" (P \" << prs[cur-N] << \")\\n\";\n\n                    if (cur >= N && (A[v] % prs[cur-N]) == 0) {\n                        cps.push_back(cur);\n                        // cout << \"good prime\" << endl;\n                    }\n\n                    for (int nbr : adj[cur]) {\n                        if (!dead[nbr] && comps[nbr] == curc) {\n                            comps[nbr] = ncomps;\n                            bfs.push(nbr);\n                        }\n                    }\n                }\n\n                ll minval = 200000000ll;\n                int minind = -1;\n                for (int pi : cps) {\n                    for (int r : adj[pi]) {\n                        if (!dead[r] && A[r] < minval) {\n                            minind = r;\n                            minval = A[r];\n                        }\n                    }\n                }\n\n                ncomps++;\n                if (minind != -1){\n                    process.push({A[minind], minind});\n                    // cout << \"inserting \" << minind << \" (\" << A[minind] << \")\" << endl;\n                } \n                \n            }\n        }\n\n    }\n\n    for (int i = 0; i<N;i++) cout << A[order[i]] << \" \\n\"[i+1==N];\n\n    return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\n\n\n#define PB push_back\n#define PF push_front\n#define LB lower_bound\n#define UB upper_bound\n#define fr(x) freopen(x,\"r\",stdin)\n#define fw(x) freopen(x,\"w\",stdout)\n#define iout(x) printf(\"%d\\n\",x)\n#define lout(x) printf(\"%lld\\n\",x)\n#define REP(x,l,u) for(int x = (l);x<=(u);x++)\n#define RREP(x,l,u) for(int x = (l);x>=(u);x--)\n#define mst(x,a) memset(x,a,sizeof(x))\n#define PII pair<int,int>\n#define PLL pair<ll,ll>\n#define MP make_pair\n#define se second\n#define fi first\n#define dbg(x) cout<<#x<<\" = \"<<(x)<<endl;\n#define sz(x) ((int)x.size())\n#define cl(x) x.clear()\n\ntypedef  long long ll;\ntypedef unsigned long long ull;\ntypedef double db;\ntypedef long double ld;\nusing namespace std;\n\nconst int maxn = 100010;\nconst int mod = 1e9+7;\nconst int MAX = 1000000010;\nconst double eps = 1e-6;\nconst double PI = acos(-1);\n\ntemplate<typename T> inline void read(T &x){\nx=0;T f=1;char ch;do{ch=getchar();if(ch=='-')f=-1;}while(ch<'0'||ch>'9');do x=x*10+ch-'0',ch=getchar();while(ch<='9'&&ch>='0');x*=f;\n}\n\ntemplate<typename A,typename B> inline void read(A&x,B&y){read(x);read(y);}\ntemplate<typename A,typename B,typename C> inline void read(A&x,B&y,C&z){read(x);read(y);read(z);}\ntemplate<typename A,typename B,typename C,typename D> inline void read(A&x,B&y,C&z,D&w){read(x);read(y);read(z);read(w);}\ntemplate<typename A,typename B> inline A fexp(A x,B p){A ans=1;for(;p;p>>=1,x=1LL*x*x%mod)if(p&1)ans=1LL*ans*x%mod;return ans;}\ntemplate<typename A,typename B> inline A fexp(A x,B p,A mo){A ans=1;for(;p;p>>=1,x=1LL*x*x%mo)if(p&1)ans=1LL*ans*x%mo;return ans;}\n\nint n,m;\n\nint A[maxn];\n\nvector<int> G[maxn];\n\nint vi[maxn];\n\nint has[2010][2010],l[2010];\n\nbool cmp(int x,int y){\n\treturn A[x]<A[y];\n}\n\nvoid dfs(int u){\n\tif(vi[u])return;\n\tvi[u]=1;\n\thas[m][++l[m]]=A[u];\n\tfor(auto v:G[u])dfs(v);\n}\n\nvoid Work(){\n\tREP(i,1,n)if(!vi[i]){\n\t\tm++;\n\t\tdfs(i);\n\t\treverse(has[m]+1,has[m]+l[m]+1);\n\t}\n\tREP(i,1,n){\n\t\tint mx=0,p=0;\n\t\tREP(j,1,m)if(has[j][l[j]]>mx)mx=has[j][l[j]],p=j;\n\t\tprintf(\"%d \",mx);\n\t\tl[p]--;\n\t}\n}\n\nvoid Init(){\n\tread(n);\n\tREP(i,1,n)read(A[i]);\n\tREP(i,1,n)REP(j,1,n)if(i!=j&&__gcd(A[i],A[j])!=1)G[i].PB(j);\n\tREP(i,1,n)sort(G[i].begin(),G[i].end(),cmp);\n}\n\nint main(){\n\tInit();\n\tWork();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nvector <int> g[2222];\nint in[2222];\nint a[2222];\nbool vis[2222];\nbool done[2222];\nint opt;\n\nvoid dfs(int x) {\n\tvis[x] = true;\n\topt = min(opt, x);\n\tfor(int i : g[x]) {\n\t\tif(vis[i] == false) {\n\t\t\tdfs(i);\n\t\t}\n\t}\n}\nvector <int> solve(int opt) {\n\tpriority_queue<int, vector<int>, greater<int> > Q;\n\tQ.push(opt);\n\tvector <int> ans;\n\tdone[opt] = true;\n\twhile(!Q.empty()) {\n\t\tint x = Q.top();\n\t\tQ.pop();\n\t\tans.push_back(x);\n\t\tfor(auto i : g[x]) {\n\t\t\tif(done[i] == false) {\n\t\t\t\tQ.push(i);\n\t\t\t\tdone[i] = true;\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main(int argc, char const *argv[])\n{\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor(int i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\tsort(a + 1, a + n + 1);\n\tfor(int i = 1; i <= n; i++) {\n\t\tfor(int j = i + 1; j <= n; j++) {\n\t\t\tif(__gcd(a[i], a[j]) > 1) {\n\t\t\t\tg[i].push_back(j);\n\t\t\t\tg[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tvector < vector <int> > L;\n\tfor(int i = 1; i <= n; i++) {\n\t\tif(vis[i] == false) {\n\t\t\topt = n;\n\t\t\tdfs(i);\n\t\t\tL.push_back(solve(opt));\n\t\t}\n\t}\n\tpriority_queue <pair <int, int> > Q;\n\tvector <int> ans;\n\n\tint id = 0;\n\tfor(auto &i : L) {\n\t\treverse(i.begin(), i.end());\n\t\tQ.push(make_pair(i.back(), id++));\n\t}\n\twhile(!Q.empty()) {\n\t\tint x = Q.top().first;\n\t\tint y = Q.top().second;\n\t\tQ.pop();\n\t\tans.push_back(a[x]);\n\t\tL[y].pop_back();\n\t\tif(!L[y].empty()) Q.push(make_pair(L[y].back(), y));\n\t}\n\tfor(auto i : ans) {\n\t\tprintf(\"%d \", i);\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Heaplax\n//别让自己后悔\n#include<bits/stdc++.h>\n#define N 2001\n#define LL long long\n#define LOG(x) cerr<<#x<<\" = \"<<x<<endl\n#define add_edge(u,v) nxt[++cnt]=head[u],head[u]=cnt,to[cnt]=v\n#define open(x) freopen(#x\".in\",\"r\",stdin),freopen(#x\".out\",\"w\",stdout)\nchar ch;bool fs;void re(int& x)\n{\n\twhile(ch=getchar(),ch<33);\n\tif(ch=='-')fs=1,x=0;else fs=0,x=ch-48;\n\twhile(ch=getchar(),ch>33)x=x*10+ch-48;\n\tif(fs)x=-x;\n}\nusing namespace std;\nint n,a[N];\nint cnt,head[N],nxt[N*N],to[N*N];\nbool vis[N];\nvoid dfs(int u)\n{\n\tvis[u]=1;\n\tfor(int i=head[u],v;i;i=nxt[i])\n\t\tif(!vis[v=to[i]])\n\t\t\tdfs(v);\n}\nbool cmp(const vector<int> &a,const vector<int> &b)\n{\n\tfor(int i=0;i<min(a.size(),b.size());++i)\n\t\tif(a[i]>b[i])return 1;\n\t\telse if(a[i]<b[i])return 0;\n\treturn 0;\n}\nvector<int> solve(int u)\n{\n\tvis[u]=1;\n\tvector<int> son;\n\tfor(int i=head[u],v;i;i=nxt[i])\n\t\tif(!vis[v=to[i]])\n\t\t\tson.push_back(v);\n\tsort(son.begin(),son.end());\n\tvector<vector<int>> que;\n\tfor(int v:son)if(!vis[v])\n\t\tque.push_back(solve(v));\n\tsort(que.begin(),que.end(),cmp);\n\tvector<int> res;\n\tres.push_back(u);\n\tfor(auto i:que)\n\t\tfor(auto j:i)\n\t\t\tres.push_back(j);\n\treturn res;\n}\nint main()\n{\n\tre(n);++n;\n\tfor(int i=2;i<=n;++i)re(a[i]);\n\tsort(a+2,a+n+1);\n\tfor(int i=2;i<=n;++i)\n\t\tfor(int j=i+1;j<=n;++j)\n\t\t\tif(__gcd(a[i],a[j]) != 1)\n\t\t\t\tadd_edge(i,j),add_edge(j,i);\n\tfor(int i=2;i<=n;++i)\n\t\tif(!vis[i])\n\t\t{\n\t\t\tadd_edge(1,i);\n\t\t\tdfs(i);\n\t\t}\n\tmemset(vis,0,sizeof vis);\n\tvector<int> ans=solve(1);\n\tfor(int i:ans)\n\t\tif(i>1)\n\t\t\tprintf(\"%d \",a[i]);\n\tputs(\"\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#include <cstdio> \n#include <cstdlib> \n#include <cstring> \n#include <cmath> \n#include <algorithm>\n#include <vector>\n#include <queue> \nusing namespace std; \ninline int gi() { \n    register int data = 0, w = 1; \n    register char ch = 0; \n    while (!isdigit(ch) && ch != '-') ch = getchar(); \n    if (ch == '-') w = -1, ch = getchar(); \n    while (isdigit(ch)) data = 10 * data + ch - '0', ch = getchar(); \n    return w * data; \n} \nconst int MAX_N = 2e3 + 5; \nint N, a[MAX_N], deg[MAX_N]; \nbool vis[MAX_N], Link[MAX_N][MAX_N]; \nvector<int> G[MAX_N]; \nvoid dfs(int x) { \n\tvis[x] = 1; \n\tfor (int i = 1; i <= N; i++) if (!vis[i] && Link[x][i]) ++deg[i], G[x].push_back(i), dfs(i); \n} \nvoid TopSort() { \n\tpriority_queue<int> que; \n\tfor (int i = 1; i <= N; i++) if (!deg[i]) que.push(i); \n\twhile (!que.empty()) { \n\t\tint x = que.top(); que.pop();\n\t\tprintf(\"%d \", a[x]); \n\t\tfor (auto v : G[x]) que.push(v); \n\t}\n\tputchar('\\n'); \n} \n\nint main () {\n\tN = gi(); for (int i = 1; i <= N; i++) a[i] = gi(); \n\tsort(&a[1], &a[N + 1]); \n\tfor (int i = 1; i <= N; i++)\n\t\tfor (int j = i + 1; j <= N; j++) \n\t\t\tif (__gcd(a[i], a[j]) != 1) Link[i][j] = Link[j][i] = 1; \n\tfor (int i = 1; i <= N; i++) if (!vis[i]) dfs(i); \n\tTopSort(); \n\treturn 0; \n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define per(i,b,a) for(int i=b;i>=a;i--)\n#define For(i,a,b) for(int i=a;i<=b;i++)\n#define Forenska(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\n#define all(x) x.begin(),x.end()\n#define sqr(x) ((x)*(x))\n#define lowbit(x) ((x)&(-x))\n#define GREATER(x) x,vector<x>,greater<x>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int,int> pii;\ntypedef pair<LL,LL> pLL;\ntypedef vector<int> vec;\ntypedef vector<LL> vecL;\ntypedef vector<pii> vecP;\ntypedef vector<pLL> vecPL;\ntypedef vector<string> vecS;\ntypedef vector<vec> mat;\ntypedef complex<double> point;\nconst long double PI=3.1415926535897932384626433832795028841971693993751058209749445923078164062862089;\nconst LL INFLL=0x3f3f3f3f3f3f3f3f;\nconst int INF=0x3f3f3f3f;\nconst long double EPS=1e-10;\nint read()\n{\n\tint x=0;\n\tchar ch=' ';\n\tbool flag=false;\n\twhile(!isdigit(ch))\n\t{\n\t\tif(ch=='-')flag=true;\n\t\tch=getchar();\n\t}\n\twhile(isdigit(ch))\n\t{\n\t\tx=(x<<3)+(x<<1)+ch-'0';\n\t\tch=getchar();\n\t}\n\treturn flag?-x:x;\n}\nconst int MAX_N=2050;\nconst int MAX_V=40050;\nint n,m;\nint a[MAX_N];\nbool b[MAX_N][MAX_N];\nint ans[MAX_N];\nint ansSz;\nbool inAns[MAX_N];\nint lastNotCoPrime[MAX_N];\nint minOnSuff[MAX_N];\nint comp[MAX_V];\nvec g[MAX_V];\nint C;\nint bestForCol[MAX_N];\nmap <int,int> primeId;\nint getId(int p)\n{\n\tif(primeId.count(p)>0)return primeId[p];\n\tprimeId[p]=m;\n\tm++;\n\treturn m-1;\n}\nvoid dfs(int v)\n{\n\tcomp[v]=C;\n\trep(i,0,g[v].size())\n\t{\n\t\tint u=g[v][i];\n\t\tif(comp[u]!=-1)continue;\n\t\tif(u<n && inAns[u])continue;\n\t\tdfs(u);\n\t}\n}\nvoid color()\n{\n\trep(i,0,m)\n\t{\n\t\tcomp[i]=-1;\n\t}\n\tC=0;\n\trep(i,0,n)\n\t{\n\t\tif(inAns[i])continue;\n\t\tif(comp[i]!=-1)continue;\n\t\tdfs(i);\n\t\tC++;\n\t}\n}\nint main()\n{\n\tcin>>n;\n\tm=n;\n\trep(i,0,n)\n\t{\n\t\tcin>>a[i];\n\t\tint x=a[i];\n\t\tFor(y,2,sqrt(x))\n\t\t{\n\t\t\tif(x%y!=0)continue;\n\t\t\tint id=getId(y);\n\t\t\tg[i].pb(id);\n\t\t\tg[id].pb(i);\n\t\t\twhile(x%y==0)x/=y;\n\t\t}\n\t\tif(x!=1)\n\t\t{\n\t\t\tint id=getId(x);\n\t\t\tg[i].pb(id);\n\t\t\tg[id].pb(i);\n\t\t}\n\t}\n\trep(i,0,n)\n\t{\n\t\trep(j,i+1,n)\n\t\t{\n\t\t\tif(__gcd(a[i],a[j])>1)\n\t\t\t{\n\t\t\t\tb[i][j]=b[j][i]=1;\n\t\t\t}\n\t\t}\n\t}\n\trep(i,0,n)lastNotCoPrime[i]=-1;\n\trep(i,0,n)minOnSuff[i]=INF;\n\twhile(ansSz!=n)\n\t{\n\t\tcolor();\n\t\trep(i,0,C)bestForCol[i]=-1;\n\t\trep(i,0,n)\n\t\t{\n\t\t\tif(inAns[i])continue;\n\t\t\tif(minOnSuff[lastNotCoPrime[i]+1]<a[i])continue;\n\t\t\tif(bestForCol[comp[i]]==-1 || a[bestForCol[comp[i]]]>a[i])\n\t\t\t{\n\t\t\t\tbestForCol[comp[i]]=i;\n\t\t\t}\n\t\t}\n\t\tint id=-1;\n\t\trep(i,0,C)\n\t\t{\n\t\t\tif(bestForCol[i]==-1)continue;\n\t\t\tif(id==-1 || a[id]<a[bestForCol[i]])id=bestForCol[i]; \n\t\t}\n\t\tif(id==-1)throw;\n\t\tinAns[id]=1;\n\t\tans[ansSz++]=a[id];\n\t\trep(i,0,ansSz)minOnSuff[i]=min(minOnSuff[i],a[id]);\n\t\trep(i,0,n)if(b[id][i])lastNotCoPrime[i]=ansSz-1;\n\t}\n\trep(i,0,n)cout<<ans[i]<<\" \";\n\tcout<<endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 2009\nusing namespace std;\n\nint n,a[N],dgr[N]; bool vis[N],b[N][N],mp[N][N];\nstruct cmp{ bool operator ()(int x,int y){ return a[x]<a[y]; } };\npriority_queue<int,vector<int>,cmp> Q;\nint gcd(int x,int y){ return y?gcd(y,x%y):x; }\nvoid dfs(int x){\n\tint y; vis[x]=1;\n\tfor (y=1; y<=n; y++) if (!vis[y] && mp[x][y]){\n\t\tb[x][y]=1; dgr[y]++; dfs(y);\n\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tint i,j;\n\tfor (i=1; i<=n; i++) scanf(\"%d\",&a[i]);\n\tsort(a+1,a+n+1);\n\tfor (i=1; i<n; i++)\n\t\tfor (j=i+1; j<=n; j++) mp[i][j]=mp[j][i]=(gcd(a[i],a[j])>1);\n\tfor (i=1; i<=n; i++) if (!vis[i]) dfs(i);\n\tfor (i=1; i<=n; i++) if (!dgr[i]) Q.push(i);\n\twhile (!Q.empty()){\n\t\tprintf(\"%d \",a[i=Q.top()]); Q.pop();\n\t\tfor (j=1; j<=n; j++) if (b[i][j])\n\t\t\tif (!(--dgr[j])) Q.push(j);\n\t}\n\tputs(\"\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author majk\n */\n\n#ifndef MAJK_LIB\n#define MAJK_LIB\n\n#include <vector>\n#include <stack>\n#include <iostream>\n#include <unordered_map>\n#include <unordered_set>\n#include <map>\n#include <iomanip>\n#include <set>\n#include <functional>\n#include <algorithm>\n#include <numeric>\n#include <cassert>\n#include <cmath>\n#include <string>\n#include <queue>\n#include <array>\n#include <bitset>\nusing namespace std;\n\n#define x first\n#define y second\ntypedef std::pair<int,int> pii; typedef long long ll; typedef unsigned long long ull; typedef unsigned int ui; typedef pair<ui,ui> puu;\n\ntemplate <typename T, typename U> std::istream&operator>>(std::istream&i, pair<T,U>&p) {i >> p.x >> p.y; return i;}\ntemplate<typename T>std::istream&operator>>(std::istream&i,vector<T>&t) {for(auto&v:t){i>>v;}return i;}\ntemplate <typename T, typename U> std::ostream&operator<<(std::ostream&o, const pair<T,U>&p) {o << p.x << ' ' << p.y; return o;}\ntemplate<typename T>std::ostream&operator<<(std::ostream&o,const vector<T>&t) {if(t.empty())o<<'\\n';for(size_t i=0;i<t.size();++i){o<<t[i]<<\" \\n\"[i == t.size()-1];}return o;}\ntemplate<typename T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<typename T> using maxheap = priority_queue<T, vector<T>, less<T>>;\nui logceil(ll x) { return x?8*sizeof(ll)-__builtin_clzll(x):0; }\n\nnamespace std { template<typename T,typename U>struct hash<pair<T,U>>{hash<T>t;hash<U>u;size_t operator()(const pair<T,U>&p)const{return t(p.x)^(u(p.y)<<7);}}; }\ntemplate<typename T,typename F>T bsh(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){l=m+1;r=m;}else{h=m-1;}}return r;}\ntemplate<typename F> double bshd(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){l=m;}else{h=m;}}return (l+h)/2;}\ntemplate<typename T,typename F>T bsl(T l,T h,const F&f){T r=-1,m;while(l<=h){m=(l+h)/2;if(f(m)){h=m-1;r=m;}else{l=m+1;}}return r;}\ntemplate<typename F> double bsld(double l,double h,const F&f,double p=1e-9){ui r=3+(ui)log2((h-l)/p);while(r--){double m=(l+h)/2;if(f(m)){h=m;}else{l=m;}}return (l+h)/2;}\ntemplate<typename T> T gcd(T a,T b) { if (a<b) swap(a,b); return b?gcd(b,a%b):a; }\n\n\ntemplate<typename T>class vector2:public vector<vector<T>>{public:vector2(){} vector2(size_t a,size_t b,T t=T()):vector<vector<T>>(a,vector<T>(b,t)){}};\ntemplate<typename T>class vector3:public vector<vector2<T>>{public:vector3(){} vector3(size_t a,size_t b,size_t c,T t=T()):vector<vector2<T>>(a,vector2<T>(b,c,t)){}};\ntemplate<typename T>class vector4:public vector<vector3<T>>{public:vector4(){} vector4(size_t a,size_t b,size_t c,size_t d,T t=T()):vector<vector3<T>>(a,vector3<T>(b,c,d,t)){}};\ntemplate<typename T>class vector5:public vector<vector4<T>>{public:vector5(){} vector5(size_t a,size_t b,size_t c,size_t d,size_t e,T t=T()):vector<vector4<T>>(a,vector4<T>(b,c,d,e,t)){}};\n\n\n#endif\n\nclass ERearranging {\npublic:\n    map<int, vector<int>> Multiples;\n    map<int, vector<int>> Factors;\n    map<int, int> C;\n    vector<int> B;\n\n    set<int> component(int value, const set<int>& forbidden) {\n        set<int> Pr, Val{value};\n        vector<int> Q{value};\n        for (int q = 0; q < Q.size(); ++q) {\n            int v = Q[q];\n            for (int f: Factors[v]) {\n                if (Pr.count(f)) continue;\n                Pr.insert(f);\n                for (int m: Multiples[f]) {\n                    if (forbidden.count(m)) continue;\n                    if (Val.count(m)) continue;\n                    Val.insert(m);\n                    Q.push_back(m);\n                }\n            }\n        }\n        return Val;\n    }\n\n    vector<int> solve(vector<int> &stack, const set<int> &Component, int ctx) {\n        set<int> Forbidden(stack.begin(),stack.end());\n        vector<vector<int>> Others;\n        set<int> Used;\n//        cerr << ctx << \" Main comp \";\n//        for (int c: Component) cerr << c << ' ';\n//        cerr << endl;\n\n        for (int val: Component) {\n            if (Used.count(val) == 0) {\n//                cerr << \"Using val \" << val << endl;\n                auto cc = component(val, Forbidden);\n                for (int c: cc) Used.insert(c);\n//                cerr << ctx << \"Component \";\n//                for (int c: cc) cerr << ' ' << c;\n//                cerr << endl;\n//                cerr << ctx << \"Stack \" << stack;\n\n                int root = -1;\n                for (int c: cc) {\n                    bool ok = true;\n                    for (int i = (int) stack.size() - 1; i >= 0; --i) {\n                        if (gcd(stack[i], c) != 1) break;\n                        else if (stack[i] < c) {\n                            ok = false;\n                            break;\n                        }\n                    }\n                    if (ok) {\n                        root = c;\n                        break;\n                    }\n                }\n//                cerr << ctx << \"Root \" << root << endl;\n\n                stack.push_back(root);\n                cc.erase(root);\n                vector<int> Z = solve(stack, cc, root);\n                stack.pop_back();\n                Others.push_back({root});\n                for (int z: Z) Others.back().push_back(z);\n            }\n        }\n\n        vector<int> Answer;\n//        cerr << ctx << \"Subcomponents \" << Others;\n        if (!Others.empty()) {\n            vector<int> Merged = Others[0];\n            for (int i = 1; i < Others.size(); ++i) {\n                vector<int> QQ;\n                int j = 0, k = 0;\n                while (j < Merged.size() || k < Others[i].size()) {\n                    if (j == Merged.size()) { QQ.push_back(Others[i][k++]); }\n                    else if (k == Others[i].size()) { QQ.push_back(Merged[j++]); }\n                    else if (Merged[j] < Others[i][k]) { QQ.push_back(Others[i][k++]); }\n                    else { QQ.push_back(Merged[j++]); }\n                }\n                swap(Merged, QQ);\n            }\n            for (int m: Merged) Answer.push_back(m);\n        }\n//        cerr << ctx << \"Answer \" << Answer;\n        return Answer;\n    }\n\n\n//    vector<int> solve(vector<int> &stack, int value) {\n//        set<int> Forbidden(stack.begin(),stack.end());\n//        auto Component = component(value, Forbidden);\n//        cerr << \"Component \";\n//        for (int c: Component) cerr << ' ' << c;\n//        cerr << endl;\n//        vector<int> Answer;\n//        for (int initial: Component) {\n//            bool ok = true;\n//            for (int i = (int)stack.size()-1; i >= 0; --i) {\n//                if (gcd(stack[i],initial) != 1) break;\n//                else if (stack[i] < initial) { ok = false; break; }\n//            }\n//            if (ok) {\n//                cerr << \"using \" << initial << endl;\n//                stack.push_back(initial);\n//                Answer.push_back(initial);\n//                Forbidden.insert(initial);\n//                vector<vector<int>> Others;\n//                set<int> Used;\n//                for (int root: Component) {\n//                    if (root != initial && Used.count(root) == 0) {\n//                        auto cc = component(root, Forbidden);\n//                        Others.emplace_back(solve(stack, root));\n//                    }\n//                }\n//                cerr << \"Subcomponents \" << Others;\n//                if (!Others.empty()) {\n//                    vector<int> Merged = Others[0];\n//                    for (int i = 1; i < Others.size(); ++i) {\n//                        vector<int> QQ;\n//                        int j = 0, k = 0;\n//                        while (j < Merged.size() || k < Others[i].size()) {\n//                            if (j == Merged.size()) { QQ.push_back(Others[i][k++]); }\n//                            else if (k == Others[i].size()) { QQ.push_back(Merged[j++]); }\n//                            else if (Merged[j] < Others[i][k]) { QQ.push_back(Others[i][k++]); }\n//                            else { QQ.push_back(Merged[j++]); }\n//                        }\n//                        swap(Merged, QQ);\n//                    }\n//                    for (int m: Merged) Answer.push_back(m);\n//                }\n//\n//                stack.pop_back();\n//                return Answer;\n//            }\n//        }\n//\n//        return {};\n//    }\n\n\n    void solve(istream& cin, ostream& cout) {\n        int N; cin >> N;\n        vector<int> A(N); cin >> A;\n        for (int a: A) C[a]++;\n        for (pii c: C) if (c.x != 1) B.push_back(c.x);\n\n        vector<int> Ans;\n        if (!B.empty()) {\n            for (int b: B) {\n                int x = b;\n                for (int p = 2; p <= 10000; ++p) {\n                    if (x%p == 0) {\n                        Factors[b].push_back(p);\n                        while (x%p == 0) x /= p;\n                        Multiples[p].push_back(b);\n                    }\n                }\n                if (x != 1) {\n                    Factors[b].push_back(x);\n                    Multiples[x].push_back(b);\n                }\n            }\n\n//            cout << \"Factors \\n\";\n//            for (auto f: Factors) cout << f.x << \"->\" << f.y;\n//            cout << \"Multiples \\n\";\n//            for (auto m: Multiples) cout << m.x << \"->\" << m.y;\n\n            set<int> All(B.begin(),B.end());\n            vector<int> Stack;\n            auto res = solve(Stack, All, -1);\n            for (int r: res) for (int i = 0; i < C[r]; ++i) Ans.push_back(r);\n        }\n        for (int i = 0; i < C[1]; ++i) Ans.push_back(1);\n        cout << Ans;\n    }\n};\n\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr);\n\tERearranging solver;\n\tstd::istream& in(std::cin);\n\tstd::ostream& out(std::cout);\n\tsolver.solve(in, out);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<cmath>\n#include<queue>\n#include<bitset>\n#include<string>\n#include<cstdio>\n#include<cctype>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n#include<sstream>\n#include<numeric>\n#include<iostream>\n#include<algorithm>\n#include<functional>\n\n#define For(i,x,y) for (int i=x;i<y;i++)\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\n\ntypedef long long ll;\ntypedef double db;\ntypedef vector<int> Vi;\ntypedef pair<int,int> pii;\n\nint IN(){\n\tint c,f,x;\n\twhile (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');\n\twhile (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;\n}\n\nconst int N=200000+19;\nconst int oo=(1<<30)-1;\n\nstruct Edge{\n\tint y,nxt;\n} E[N];\nmap<int,int> M,M2;\nmultiset<int> S;\nint A[N],las[N],col[N],chk[N],mn[N],pre[N],suf[N],res[N],f[N],g[N];\nint n,x,tot,cnt,c,mx,num,m;\nVi V[N];\n\nvoid Link(int x,int y){\n\tE[cnt]=(Edge){y,las[x]};las[x]=cnt++;\n\tE[cnt]=(Edge){x,las[y]};las[y]=cnt++;\n}\nvoid Init(int n){\n\tif (M2.count(n)) return;\n\tM2[n]=++m;\n\tif (V[m].size()) return;\n\tfor (int i=2;i*i<=n;i++)\n\t\tif (n%i==0){\n\t\t\tV[m].pb(i);\n\t\t\twhile (n%i==0) n/=i;\n\t\t}\n\tif (n>1) V[m].pb(n);\n}\nvoid Renew(int x){\n\tif (!M.count(x)) M[x]=++tot;\n}\nvoid dfs(int x,int c){\n\tif (col[x]) return;\n\tcol[x]=c;\n\tif (x<=*A) mn[c]=min(mn[c],A[x]);\n\tfor (int i=las[x];~i;i=E[i].nxt) dfs(E[i].y,c);\n}\nint work(int val){\n\tM.clear();\n\tFor(i,1,tot+1){\n\t\tlas[i]=-1;\n\t\tcol[i]=0;\n\t}\n\ttot=*A;cnt=0;c=0;\n\tFor(i,1,*A+1){\n\t\tint tmp=A[i];\n\t\tfor (int x=2;x*x<=tmp;x++)\n\t\t\tif (tmp%x==0){\n\t\t\t\tRenew(x);\n\t\t\t\tLink(i,M[x]);\n\t\t\t\twhile (tmp%x==0) tmp/=x;\n\t\t\t}\n\t\tif (tmp>1){\n\t\t\tRenew(tmp);\n\t\t\tLink(i,M[tmp]);\n\t\t}\n\t}\n\tFor(i,1,tot+1)\n\t\tif (!col[i]){\n\t\t\tmn[++c]=oo;\n\t\t\tdfs(i,c);\n\t\t}\n\tpre[0]=suf[c+1]=0;\n\tfor (int i=1;i<=c;i++) pre[i]=max(pre[i-1],mn[i]);\n\tfor (int i=c;i>=1;i--) suf[i]=max(suf[i+1],mn[i]);\n\tFor(i,1,*A+1){\n\t\tif (A[i]>max(pre[col[i]-1],suf[col[i]+1])){\n\t\t\tint pos=0;\n\t\t\tfor (int j:V[M2[A[i]]]) pos=max(pos,f[j]);\n\t\t\tif (A[i]<g[pos+1]) return A[i];\n\t\t}\n\t}\n\tassert(0);\n}\n\nint main(){\n\tmemset(las,-1,sizeof(las));\n\tn=IN();\n\tFor(i,1,n+1){\n\t\tx=IN();\n\t\tInit(x);\n\t\tS.insert(x);\n\t}\n\tx=oo;\n\tg[1]=oo;\n\tFor(t,1,n+1){\n\t\t*A=0;\n\t\tfor (int i:S) A[++*A]=i;\n\t\tx=work(x);\n\t\tS.erase(S.find(x));\n\t\tres[t]=x;\n\t\tfor (int i:V[M2[x]]) f[i]=max(f[i],t);\n\t\tg[t+1]=oo;\n\t\tfor (int i=t;~i;i--) g[i]=min(g[i+1],res[i]);\n\t}\n\tFor(i,1,n+1) printf(\"%d \",res[i]);\n\tputs(\"\");\n}"
  },
  {
    "language": "C++",
    "code": "//Heaplax\n//别让自己后悔\n#include<bits/stdc++.h>\n#define N 2005\n#define LL long long\n#define LOG(x) cerr<<#x<<\" = \"<<x<<endl\n#define add_edge(u,v) nxt[++cnt]=head[u],head[u]=cnt,to[cnt]=v\n#define open(x) freopen(#x\".in\",\"r\",stdin),freopen(#x\".out\",\"w\",stdout)\nchar ch;bool fs;void re(int& x)\n{\n\twhile(ch=getchar(),ch<33);\n\tif(ch=='-')fs=1,x=0;else fs=0,x=ch-48;\n\twhile(ch=getchar(),ch>33)x=x*10+ch-48;\n\tif(fs)x=-x;\n}\nusing namespace std;\nint n,a[N];\nint cnt,head[N],nxt[N*N],to[N*N];\nbool vis[N];\nvoid dfs(int u)\n{\n\tvis[u]=1;\n\tfor(int i=head[u],v;i;i=nxt[i])\n\t\tif(!vis[v=to[i]])\n\t\t\tdfs(v);\n}\nbool cmp(const vector<int> &a,const vector<int> &b)\n{\n\tfor(int i=0;i<min(a.size(),b.size());++i)\n\t\tif(a[i]>b[i])return 1;\n\t\telse if(a[i]<b[i])return 0;\n\treturn 0;\n}\nvector<int> solve(int u)\n{\n\tvis[u]=1;\n\tvector<int> son;\n\tfor(int i=head[u],v;i;i=nxt[i])\n\t\tif(!vis[v=to[i]])\n\t\t\tson.push_back(v);\n\tsort(son.begin(),son.end());\n\tvector<vector<int>> que;\n\tfor(int v:son)if(!vis[v])\n\t\tque.push_back(solve(v));\n\tsort(que.begin(),que.end(),cmp);\n\tvector<int> res;\n\tres.push_back(u);\n\tfor(auto i:que)\n\t\tfor(auto j:i)\n\t\t\tres.push_back(j);\n\treturn res;\n}\nint main()\n{\n\tre(n);++n;\n\tfor(int i=2;i<=n;++i)re(a[i]);\n\tsort(a+2,a+n+1);\n\tfor(int i=2;i<=n;++i)\n\t\tfor(int j=i+1;j<=n;++j)\n\t\t\tif(__gcd(a[i],a[j]) != 1)\n\t\t\t\tadd_edge(i,j),add_edge(j,i);\n\tfor(int i=2;i<=n;++i)\n\t\tif(!vis[i])\n\t\t{\n\t\t\tadd_edge(1,i);\n\t\t\tdfs(i);\n\t\t}\n\tmemset(vis,0,sizeof vis);\n\tvector<int> ans=solve(1);\n\tfor(int i:ans)\n\t\tif(i>1)\n\t\t\tprintf(\"%d \",a[i]);\n\tputs(\"\");\n}\n"
  },
  {
    "language": "C++",
    "code": "//Link : https://atcoder.jp/contests/code-festival-2017-qualb/tasks/code_festival_2017_qualb_d\n\n#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define N 2002\n\nint in[N],cc[N];\nint deg[N];\n\nint gcd(int x,int y) {\n  if(x==0) {\n    return y;\n  }\n  return gcd(y%x,x);\n}\nvector<int> adj[N];\nint vis[N];\n\nvector<int> merge(vector<int> a,vector<int> b) {\n  vector<int> ret;\n  int apos  =0,bpos = 0;\n  while(apos<a.size() && bpos< b.size()) {\n    if(a[apos]>b[bpos]) {\n      ret.push_back(a[apos++]);\n    } else {\n      ret.push_back(b[bpos++]);\n    }\n  }\n  while(apos<a.size() ) {\n    ret.push_back(a[apos++]);\n  }\n  while(bpos< b.size()) {\n    ret.push_back(b[bpos++]);\n  }\n  return ret;\n}\n\nint mini;\nvoid dfs(int node) {\n  vis[node] = 1;\n  mini = min(mini,node);\n  for(int ch : adj[node]) {\n    if(!vis[ch]) {\n      dfs(ch);\n    }\n  }\n}\n\nvector<int> dfs2(int node) {\n  vis[node] = 2;\n  vector<int> ret;\n  for(int ch : adj[node]) {\n    if(vis[ch]!=2) {\n      vector<int> tmp = dfs2(ch);\n      ret = merge(ret,tmp);\n    }\n  }\n  vector<int> out;\n  while(cc[node]>0) {\n    --cc[node];\n    out.push_back(in[node]);\n  }\n  for(int i=0;i<ret.size();++i) {\n    out.push_back(ret[i]);\n  }\n  return out;\n}\n\nvoid solve() {\n  int n;\n  scanf(\"%d \", &n);\n  for(int i=0;i<n;++i) {\n    scanf(\"%d\",&in[i]);\n  }\n  sort(in,in+n);\n  int pos=0;\n  for(int i=0;i<n;) {\n    int j;\n    for(j=i+1;j<n;++j) {\n      if(in[j]!=in[i]) {\n        break;\n      }\n    }\n    cc[pos] = j-i;\n    in[pos] = in[i];\n    ++pos;\n    i = j;\n  }\n  int num = 0;\n  for(int i=0;i<pos;++i) {\n    for(int j=i+1;j<pos;++j) {\n      if(gcd(in[i],in[j])!=1) {\n        adj[i].push_back(j);\n        adj[j].push_back(i);\n      }\n    }\n  }\n  vector<int> ret;\n  for(int i=0;i<pos;++i) {\n    if(!vis[i]) {\n      mini = 1e9;\n      dfs(i);\n      vector<int> out = dfs2(mini);\n      ret = merge(ret,out);\n    }\n  }\n  assert(ret.size()==n);\n  for(int i=0;i<n;++i) {\n    printf(\"%d \", ret[i]);\n  }\n  putchar('\\n');\n}\n\nint main() {\n    //freopen(\"input.txt\",\"r\",stdin);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define index(xs, x) (int)(lower_bound(all(xs), x) - xs.begin())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n\nint N;\nvector<int> C[3300];\nint A[2000];\nvector<int> R[2000];\nbool used[2000], dead[2000];\n\nint gcd(int a, int b) {\n  if (b==0)return a;\n  return gcd(b,a%b);\n}\n\nvector<int> prime_list(int x) {\n  vector<int> ret;\n  for (int p=2; p*p<=x; p++) if (x%p == 0) {\n    while (x%p == 0) x /= p;\n    ret.pb(p);\n  }\n  if (x > 1) ret.pb(x);\n  return ret;\n}\nint num = 0;\nvoid dfs(int x);\nvoid dfs2(int p) {\n  vector<int> vs(C[p]);\n  C[p].clear();\n  for (int x : vs) dfs(x);\n}\nvoid dfs(int x) {\n  assert(!dead[x]);\n  if (used[x]) return;\n  num--;\n  used[x] = true;\n  for (int p : R[x]) dfs2(p);\n}\nvector<int> seq, seqI;\nvector<int> seqK[3300];\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> N;\n  vector<int> all;\n  rep(i, N) cin >> A[i];\n  sort(A, A+N);\n  rep(i, N) R[i] = prime_list(A[i]), all.insert(all.end(), all(R[i]));\n  sort(all(all)); uniq(all);\n  assert(all.size() <= 3300);\n  rep(i, N) for (int &x : R[i]) x = index(all, x);\n\n  rep(_, N) {\n    num = N-_;\n    int m = -1;\n    rep(i, N) used[i] = false;\n    rep(i, N) if (!dead[i]) for (int p : R[i]) C[p].clear();\n    rep(i, N) if (!dead[i]) for (int p : R[i]) C[p].pb(i);\n    rep(i, N) if (!dead[i]) {\n      int left = -1;\n      for (int p : R[i]) if (!seqK[p].empty()) left = max(left, seqK[p].back()+1);\n      auto it = lower_bound(all(seqI), left);\n      int g = INF;\n      if (it != seqI.end()) g = seq[*it];\n      if (g >= A[i]) {\n        dfs(i);\n        if (num == 0) {\n          m = i;\n          break;\n        }\n      }\n    }\n    assert(m != -1);\n    while (!seqI.empty() && seq[seqI.back()] >= A[m]) seqI.pop_back();\n    seqI.pb(_);\n    seq.pb(A[m]);\n    dead[m] = true;\n    for (int p : R[m]) seqK[p].pb(_);\n  }\n  rep(i, N) cout << seq[i] << \" \"; cout << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\nstruct UnionFind{\n  Int n;\n  vector<Int> r,p;\n  UnionFind(Int x,Int y):n(x+y),r(x+y,1),p(x+y,0){\n    iota(p.begin(),p.end(),0);\n    for(Int i=0;i<x;i++) r[i]=1;\n    for(Int i=0;i<y;i++) r[x+i]=0;\n  }\n  Int find(Int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(Int x,Int y){\n    return find(x)==find(y);\n  }\n  void unite(Int x,Int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    if(r[x]<r[y]) swap(x,y);\n    r[x]+=r[y];\n    p[y]=x;\n  }\n};\n\n\ntemplate<typename T> \nmap<T, Int> factorize(T x){\n  map<T, Int> res;\n  for(Int i=2;i*i<=x;i++){\n    while(x%i==0){\n      x/=i;\n      res[i]++;\n    }\n  }\n  if(x!=1) res[x]++;\n  return res;\n}\n\n//INSERT ABOVE HERE\nInt cop[2020][2020];\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<Int> a(n);\n  for(Int i=0;i<n;i++) cin>>a[i];\n  sort(a.begin(),a.end());\n\n  vector<Int> ans(n),used(n,0),post(n,0);\n\n  memset(cop,0,sizeof(cop));\n  \n  for(Int i=0;i<n;i++)\n    for(Int j=0;j<n;j++)\n      cop[i][j]=__gcd(a[i],a[j])>1;\n\n  Int m=0;\n  map<Int, Int> r;\n\n  vector<vector<Int> > G(n);\n  for(Int i=0;i<n;i++){\n    auto x=factorize(a[i]);\n    for(auto p:x){\n      if(!r.count(p.first)) r[p.first]=m++;\n      G[i].emplace_back(r[p.first]);\n    }\n  }\n  \n  for(Int t=0;t<n;t++){\n    UnionFind uf(n,m);\n    for(Int i=0;i<n;i++)\n      if(!used[i]) for(Int j:G[i]) uf.unite(i,n+j);\n    \n    Int idx=-1;\n    auto nxt=[&](){\n\t       Int sum=t;\n\t       set<Int> tmp;\n\t       for(Int i=0;i<n;i++){\n\t\t if(used[i]) continue;\n\t\t Int k=uf.find(i);\n\t\t if(!tmp.count(k)){\n\t\t   tmp.emplace(k);\n\t\t   sum+=uf.r[k];\n\t\t }\n\t\t if(post[i]) continue;\n\t\t if(sum==n){\n\t\t   idx=i;\n\t\t   break;\n\t\t }\n\t       }\n\t       //assert(sum==n);\n\t     };\n    nxt();\n    while(idx<0);\n    used[idx]=1;\n    ans[t]=idx;\n    \n    for(Int i=0;i<n;i++){\n      if(!uf.same(idx,i)) continue;\n      if(cop[idx][i]) post[i]=0;\n      else if(a[idx]<a[i]) post[i]=1;\n    }\n  }\n  for(Int i=0;i<n;i++){\n    if(i) cout<<\" \";\n    cout<<a[ans[i]];\n  }\n  cout<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// includes {{{\n#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<tuple>\n#include<cmath>\n#include<random>\n#include<cassert>\n// #include<deque>\n// #include<multiset>\n// #include<bitset>\n// #include<cstring>\n// #include<bits/stdc++.h>\n// }}}\nusing namespace std;\nusing ll = long long;\n\n/// --- math {{{ ///\nll gcd(ll a, ll b) { return b == 0 ? a : gcd(b, a % b); }\nll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\nll extgcd(ll a, ll b, ll &x, ll &y) {\n  ll d;\n  return b == 0 ? (x = a < 0 ? -1 : 1, y = 0, a < 0 ? -a : a)\n    : (d = extgcd(b, a % b, y, x), y -= a / b * x, d);\n}\nll modinv(ll a, ll mod) {\n  ll x, y;\n  extgcd(a, mod, x, y);\n  if(x < 0) x += mod;\n  return x;\n}\nll modpow(ll a, ll b, ll mod) {\n  ll r = 1;\n  a %= mod;\n  while(b) {\n    if(b & 1) r = r * a % mod;\n    a = a * a % mod;\n    b >>= 1;\n  }\n  return r;\n}\n/// }}}--- ///\n\nint n;\nset<int> g[2000];\nint a[2000];\n\nint used[2000];\nint finished[2000];\nint color = 1;\nvoid dfs(int i, vector<int> &v) {\n  if(finished[i]) return;\n  if(used[i] == color) return;\n  used[i] = color;\n  for(int j : g[i]) {\n    dfs(j, v);\n  }\n  v.emplace_back(i);\n}\n\nvector<int> solve2(int star);\n\nvector<int> solve(vector<int> gs) {\n  int m = gs.size();\n  vector<vector<int>> v(m);\n  priority_queue<pair<int, int>> pq;\n  for(int i = 0; i < m; i++) {\n    v[i] = solve2(gs[i]);\n    assert(v[i].size());\n    reverse(begin(v[i]), end(v[i]));\n    pq.emplace(v[i].back(), i);\n  }\n\n  vector<int> res;\n  while(pq.size()) {\n    int x, i;\n    tie(x, i) = pq.top();\n    pq.pop();\n    res.emplace_back(x);\n    v[i].pop_back();\n    assert(v[i].size() <= 3);\n    if(v[i].size()) pq.emplace(v[i].back(), i);\n  }\n  return res;\n}\n\nvector<int> solve2(int star) {\n  finished[star] = 1;\n  color++;\n  vector<int> gs;\n  for(int j : g[star]) if(!finished[j] && used[j] != color) {\n    vector<int> v;\n    dfs(j, v);\n    int nstar = -1;\n    for(int i : v) {\n      if(g[star].count(i)) {\n        if(nstar == -1 || nstar > i) nstar = i;\n      }\n    }\n    assert(nstar != -1);\n    gs.push_back(nstar);\n  }\n  auto res = solve(gs);\n  res.insert(res.begin(), a[star]);\n  return res;\n}\n\nint main() {\n  ios::sync_with_stdio(false), cin.tie(0);\n  cin >> n;\n  for(int i = 0; i < n; i++) cin >> a[i];\n  sort(a, a + n);\n  for(int i = 0; i < n; i++) for(int j = 0; j < i; j++) {\n    int x = gcd(a[i], a[j]);\n    if(x != 1) {\n      g[i].emplace(j);\n      g[j].emplace(i);\n    }\n  }\n  vector<int> gs;\n  for(int i = 0; i < n; i++) if(used[i] != color) {\n    vector<int> v;\n    dfs(i, v);\n    gs.push_back(i);\n  }\n\n  auto ans = solve(gs);\n  for(int i = 0; i < n; i++) cout << ans[i] << \" \\n\"[i == n - 1];\n  cout << flush;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\nstruct UnionFind{\n  Int n;\n  vector<Int> r,p;\n  UnionFind(Int x,Int y):n(x+y),r(x+y,1),p(x+y,0){\n    iota(p.begin(),p.end(),0);\n    for(Int i=0;i<x;i++) r[i]=1;\n    for(Int i=0;i<y;i++) r[x+i]=0;\n  }\n  Int find(Int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(Int x,Int y){\n    return find(x)==find(y);\n  }\n  void unite(Int x,Int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    if(r[x]<r[y]) swap(x,y);\n    r[x]+=r[y];\n    p[y]=x;\n  }\n};\n\n\ntemplate<typename T> \nmap<T, Int> factorize(T x){\n  map<T, Int> res;\n  for(Int i=2;i*i<=x;i++){\n    while(x%i==0){\n      x/=i;\n      res[i]++;\n    }\n  }\n  if(x!=1) res[x]++;\n  return res;\n}\n\n//INSERT ABOVE HERE\nInt cop[2020][2020];\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<Int> a(n);\n  for(Int i=0;i<n;i++) cin>>a[i];\n  sort(a.begin(),a.end());\n\n  vector<Int> ans(n),used(n,0),post(n,0);\n\n  memset(cop,0,sizeof(cop));\n  \n  for(Int i=0;i<n;i++)\n    for(Int j=0;j<n;j++)\n      cop[i][j]=__gcd(a[i],a[j])>1;\n\n  Int m=0;\n  map<Int, Int> r;\n\n  vector<vector<Int> > G(n);\n  for(Int i=0;i<n;i++){\n    auto x=factorize(a[i]);\n    for(auto p:x){\n      if(!r.count(p.first)) r[p.first]=m++;\n      G[i].emplace_back(r[p.first]);\n    }\n  }\n  \n  for(Int t=0;t<n;t++){\n    UnionFind uf(n,m);\n    for(Int i=0;i<n;i++)\n      if(!used[i]) for(Int j:G[i]) uf.unite(i,n+j);\n    \n    Int idx=-1,sum=t;\n    auto nxt=[&](){\n      set<Int> tmp;\n      for(Int i=0;i<n;i++){\n\tif(used[i]) continue;\n\tInt k=uf.find(i);\n\tif(!tmp.count(k)){\n\t  tmp.emplace(k);\n\t  sum+=uf.r[k];\n\t}\n\tif(post[i]) continue;\n\tif(sum==n){\n\t  idx=i;\n\t  break;\n\t}\n      }\n    };\n    nxt();\n    //assert(sum==n);\n    if(idx<0) post.assign(n,0);\n    nxt();\n    //while(idx<0);\n    used[idx]=1;\n    ans[t]=idx;\n    \n    for(Int i=0;i<n;i++){\n      if(cop[idx][i]) post[i]=0;\n      else if(a[idx]<a[i]) post[i]=1;\n    }\n  }\n  for(Int i=0;i<n;i++){\n    if(i) cout<<\" \";\n    cout<<a[ans[i]];\n  }\n  cout<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define RI register int\nint read() {\n\tint q=0;char ch=' ';\n\twhile(ch<'0'||ch>'9') ch=getchar();\n\twhile(ch>='0'&&ch<='9') q=q*10+ch-'0',ch=getchar();\n\treturn q;\n}\ntypedef long long LL;\nconst int N=2005;\nint n,tot,a[N],vis[N],h[N],ne[N<<1],to[N<<1],du[N];\nvector<int> orz[N];\nint gcd(int x,int y) {return y?gcd(y,x%y):x;}\nvoid add(int x,int y) {to[++tot]=y,ne[tot]=h[x],h[x]=tot,++du[y];}\nvoid dfs(int x) {\n\tvis[x]=1;\n\tfor(RI i=0;i<orz[x].size();++i)\n\t\tif(!vis[orz[x][i]]) add(x,orz[x][i]),dfs(orz[x][i]);\n}\npriority_queue<int> q;\nint main()\n{\n\tn=read();\n\tfor(RI i=1;i<=n;++i) a[i]=read();\n\tsort(a+1,a+1+n);\n\tfor(RI i=1;i<=n;++i)\n\t\tfor(RI j=i+1;j<=n;++j)\n\t\t\tif(gcd(a[i],a[j])>1) orz[i].push_back(j),orz[j].push_back(i);\n\tfor(RI i=1;i<=n;++i) if(!vis[i]) dfs(i);\n\tfor(RI i=1;i<=n;++i) if(!du[i]) q.push(i);\n\twhile(!q.empty()) {\n\t\tint x=q.top();q.pop();printf(\"%d \",a[x]);\n\t\tfor(RI i=h[x];i;i=ne[i]) {\n\t\t\t--du[to[i]];\n\t\t\tif(!du[to[i]]) q.push(to[i]);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<queue>\nusing namespace std;\ntypedef long long s64;\n\n#define next nxt\n\nconst int ONE = 2005;\nconst int MOD = 1e9 + 7;\n\nint get()\n{\n\t\tint res = 1, Q = 1; char c;\n\t\twhile( (c = getchar()) < 48 || c > 57)\n\t\t\tif(c == '-') Q = -1;\n\t\tif(Q) res = c - 48;\n\t\twhile( (c = getchar()) >= 48 && c <= 57)\n\t\t\tres = res * 10 + c - 48;\n\t\treturn res * Q;\n}\n\nint gcd(int a, int b)\n{\n\t\twhile(int r = a % b) {a = b; b = r;}\n\t\treturn b;\n}\n\nint a[ONE];\npriority_queue <int> q;\n\nint n;\nint E[ONE][ONE];\n\nint vis[ONE], Input[ONE];\nint next[ONE], first[ONE], go[ONE], tot;\nvoid Add(int u, int v)\n{\n\t\tInput[v]++, next[++tot] = first[u], first[u] = tot, go[tot] = v;\n}\n\nvoid Dfs(int u)\n{\n\t\tif(vis[u]) return;\n\t\tvis[u] = 1;\n\t\tfor(int i = 1; i <= n; i++)\n\t\t\tif(E[u][i] && !vis[i])\n\t\t\t\tAdd(u, i), Dfs(i);\n}\n\nint main()\n{\n\t\t//freopen(\".in\",\"r\",stdin);\n\t\t//freopen(\".out\",\"w\",stdout);\n\t\tn = get();\n\t\tfor(int i = 1; i <= n; i++)\n\t\t\ta[i] = get();\n\t\tsort(a + 1, a + n + 1);\n\t\tfor(int i = 1; i <= n; i++)\n\t\t\tfor(int j = 1; j <= n; j++)\n\t\t\t\tif(i != j)\n\t\t\t\t\tif(gcd(a[i], a[j]) != 1) E[i][j] = 1;\n\n\t\tfor(int i = 1; i <= n; i++)\n\t\t\tDfs(i);\n\n\t\tfor(int i = 1; i <= n; i++)\n\t\t\tif(!Input[i]) q.push(i);\n\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tint u = q.top(); q.pop();\n\t\t\tprintf(\"%d \", a[u]);\n\t\t\tfor(int e = first[u]; e; e = next[e])\n\t\t\t{\n\t\t\t\tint v = go[e];\n\t\t\t\tif(--Input[v] == 0) q.push(v);\n\t\t\t}\n\t\t}\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"Ofast\")\n#include <iostream>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <set>\n#include <queue>\n#define rep(x, a, b) for(int x = (a); x <= (b); ++x)\n#define rop(x, a, b) for(int x = (a); x < (b); ++x)\n#define per(x, a, b) for(int x = (a); x >= (b); --x)\nusing namespace std;\ntypedef long long LL;\ntypedef double DB;\npriority_queue<int> PQ;\nint a[2005], rd[2005];\nstruct graph {\n\tset<int> S[2005], E[2005];\n\tint vs[2005];\n\tvoid push(int x, int y) {\n\t\tS[x].insert(y);\n\t}\n\tvoid dfs(int nw) {\n\t\tvs[nw] = 1;\n\t\tauto IT = S[nw].begin();\n\t\twhile(IT != S[nw].end()) {\n\t\t\tif(vs[*IT]) {++IT; continue;}\n\t\t\t++rd[*IT];\n\t\t\tE[nw].insert(*IT);\n\t\t\tdfs(*IT);\n\t\t\t++IT;\n\t\t}\n\t}\n\tvoid tuopu() {\n\t\tPQ.push(0);\n\t\twhile(PQ.size()) {\n\t\t\tint nw = PQ.top();\n\t\t\tif(nw) printf(\"%d \", a[nw]);\n\t\t\tPQ.pop();\n\t\t\tauto IT = E[nw].begin();\n\t\t\twhile(IT != E[nw].end()) {\n\t\t\t\t--rd[*IT];\n\t\t\t\tif(rd[*IT] == 0) PQ.push(*IT);\n\t\t\t\t++IT;\n\t\t\t}\n\t\t}\n\t}\n}G;\nint n;\nint main() {\n\tscanf(\"%d\", &n);\n\n\trep(i, 1, n) scanf(\"%d\", &a[i]);\n    sort(a + 1, a + 1 + n);\n\trep(i, 1, n) rep(j, 1, n) if(i != j && __gcd(a[i], a[j]) != 1) G.push(i, j); \n\trep(i, 1, n) G.push(0, i), G.push(i, 0);\n\tG.dfs(0);\n\tG.tuopu();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define debug(x) cout << #x\" = \" << x;\n\n#define st first\n#define nd second\n\nusing namespace std;\nusing namespace placeholders;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> PII;\ntypedef pair<ll, ll> PLL;\n\nconst int MAXN = 2E3 + 10;\n\nint n;\nint a[MAXN], vis[MAXN];\nvector<int> E[MAXN];\n\nvector<int> DFS(int u){\n\tstatic int temp[MAXN];\n\tvis[u] = true;\n\tvector<int> ret;\n\tfor (int v, i = 0; i < E[u].size(); ++i){\n\t\tif (vis[v = E[u][i]])\n\t\t\tcontinue;\n\t\tvector<int> res = DFS(v);\n\t\tmerge(ret.begin(), ret.end(), res.begin(), res.end(), temp, greater<int>());\n\t\tret = vector<int>(temp, temp + ret.size() + res.size());\n\t}\n\tret.insert(ret.begin(), a[u]);\n\treturn ret;\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++i){\n\t\tscanf(\"%d\", a + i);\n\t\tfor (int j = 1; j < i; ++j)\n\t\t\tif (__gcd(a[i], a[j]) > 1)\n\t\t\t\tE[i].push_back(j), E[j].push_back(i);\n\t\tE[0].push_back(i);\n\t}\n\tfor (int i = 0; i <= n; ++i)\n\t\tsort(E[i].begin(), E[i].end(), [](int l, int r){return a[l] < a[r];});\n\tvector<int> ans = DFS(0);\n\tfor (int i = 1; i <= n; ++i)\n\t\tprintf(\"%d%c\", ans[i], \"\\n \"[i < n]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\nstruct UnionFind{\n  Int n;\n  vector<Int> r,p;\n  UnionFind(Int x,Int y):n(x+y),r(x+y,1),p(x+y,0){\n    iota(p.begin(),p.end(),0);\n    for(Int i=0;i<x;i++) r[i]=1;\n    for(Int i=0;i<y;i++) r[x+i]=0;\n  }\n  Int find(Int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(Int x,Int y){\n    return find(x)==find(y);\n  }\n  void unite(Int x,Int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    if(r[x]<r[y]) swap(x,y);\n    r[x]+=r[y];\n    p[y]=x;\n  }\n};\n\n\ntemplate<typename T> \nmap<T, Int> factorize(T x){\n  map<T, Int> res;\n  for(Int i=2;i*i<=x;i++){\n    while(x%i==0){\n      x/=i;\n      res[i]++;\n    }\n  }\n  if(x!=1) res[x]++;\n  return res;\n}\n\n//INSERT ABOVE HERE\nInt cop[2020][2020];\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<Int> a(n);\n  for(Int i=0;i<n;i++) cin>>a[i];\n  sort(a.begin(),a.end());\n\n  vector<Int> ans(n),used(n,0),post(n,0);\n\n  memset(cop,0,sizeof(cop));\n  \n  for(Int i=0;i<n;i++)\n    for(Int j=0;j<n;j++)\n      cop[i][j]=__gcd(a[i],a[j])>1;\n\n  Int m=0;\n  map<Int, Int> r;\n\n  vector<vector<Int> > G(n);\n  for(Int i=0;i<n;i++){\n    auto x=factorize(a[i]);\n    for(auto p:x){\n      if(!r.count(p.first)) r[p.first]=m++;\n      G[i].emplace_back(r[p.first]);\n    }\n  }\n  \n  for(Int t=0;t<n;t++){\n    UnionFind uf(n,m);\n    for(Int i=0;i<n;i++)\n      if(!used[i]) for(Int j:G[i]) uf.unite(i,n+j);\n    \n    Int idx=-1;\n    auto nxt=[&](){\n\t       Int sum=t;\n\t       set<Int> tmp;\n\t       for(Int i=0;i<n;i++){\n\t\t if(used[i]) continue;\n\t\t Int k=uf.find(i);\n\t\t if(!tmp.count(k)){\n\t\t   tmp.emplace(k);\n\t\t   sum+=uf.r[k];\n\t\t }\n\t\t if(post[i]) continue;\n\t\t if(sum==n){\n\t\t   idx=i;\n\t\t   break;\n\t\t }\n\t       }\n\t       //assert(sum==n);\n\t     };\n    nxt();\n    while(idx<0);\n    used[idx]=1;\n    ans[t]=idx;\n    \n    for(Int i=0;i<n;i++){\n      if(!uf.same(idx,i)) continue;\n      if(cop[idx][i]) post[i]=0;\n      else if(a[idx]<a[i]) post[i]=1;\n    }\n  }\n  vector<Int> b(n);\n  for(Int i=0;i<n;i++) b[i]=a[ans[i]];\n\n\n  vector<vector<Int> > H(n);\n  for(Int i=0;i<n;i++)\n    for(Int j=i+1;j<n;j++)\n      if(__gcd(b[i],b[j])>1) H[i].emplace_back(j);\n\n  vector<Int> indeg(n);\n  for(Int i=0;i<n;i++)\n    for(Int j:H[i]) indeg[j]++;\n  \n  using P = pair<Int, Int>;\n  priority_queue<P> pq;\n  for(Int i=0;i<n;i++)\n    if(!indeg[i]) pq.emplace(b[i],i);\n\n  vector<Int> c;\n  while(!pq.empty()){\n    P p=pq.top();pq.pop();\n    c.emplace_back(p.first);\n    for(Int u:H[p.second]){\n      indeg[u]--;\n      if(!indeg[u]) pq.emplace(b[u],u);\n    }\n  }\n  \n  for(Int i=0;i<n;i++){\n    if(i) cout<<\" \";\n    cout<<c[i];\n  }\n  cout<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n\nusing namespace std;\n\nconst int MAX_N = 2e3 + 5;\nconst int MAX_V = 3e4 + 5; // max # of vertices in our graph\nconst int MAX_P = 1e4 + 5;\nconst int INF = 1e9 + 5;\n\nint arr [MAX_N];\nvector<int> adj [MAX_V];\nvoid add_edge (int u, int v) {\n  adj[u].push_back(v);\n  adj[v].push_back(u);\n}\n\nint n, m;\nint state [MAX_V]; // 0 - innocent, 1 - blocked, 2 - allowed, 3 - deleted\n\nint comp [MAX_V];\nvoid find_comps (int u, int c) {\n  comp[u] = c;\n  for (int nxt : adj[u]) {\n    if (state[nxt] != 3 && comp[nxt] == -1) {\n      find_comps(nxt, c);\n    }\n  }\n}\n\npair<int, int> smallest [MAX_N];\nvoid solve () {\n  for (int i = 0; i < n + m; i++) {\n    comp[i] = -1;\n  }\n  for (int i = 0; i < n; i++) {\n    if (state[i] != 3 && comp[i] == -1) {\n      find_comps(i, i);\n    }\n  }\n\n  // for each component, find the smallest thing with state 0 or 2\n  for (int i = 0; i < n; i++) {\n    smallest[i] = make_pair(INF, 0);\n  }\n  for (int i = 0; i < n; i++) {\n    if (state[i] == 0 || state[i] == 2) {\n      smallest[comp[i]] = min(smallest[comp[i]], make_pair(arr[i], i));\n    }\n  }\n\n  // and pick the biggest of those\n  pair<int, int> ans = make_pair(0, -1); // <value, idx>\n  for (int i = 0; i < n; i++) {\n    if (smallest[i].first != INF) {\n      ans = max(ans, smallest[i]);\n    }\n  }\n\n  int idx = ans.second;\n  cout << arr[idx] << \" \";\n\n  // if it is innocent block its component\n  if (state[idx] == 0) {\n    for (int i = 0; i < n; i++) {\n      if (comp[i] == comp[idx]) {\n        state[i] = 1;\n      }\n    }\n  }\n\n  // unblock cousins\n  for (int p : adj[idx]) {\n    for (int u : adj[p]) {\n      if (state[u] != 3) {\n        state[u] = 2;\n      }\n    }\n  }\n\n  // delete\n  state[idx] = 3;\n}\n\nint sieve [MAX_P];\nvector<int> smallp;\nmap<int, int> compr;\nvoid add_to_compr (int x) {\n  for (int p : smallp) {\n    if (x % p == 0) {\n      compr[p] = 0;\n      while (x % p == 0) {\n        x /= p;\n      }\n    }\n  }\n\n  if (x != 1) {\n    compr[x] = 0;\n  }\n}\n\nvoid add_edges (int idx, int x) {\n  for (int p : smallp) {\n    if (x % p == 0) {\n      add_edge(idx, compr[p]);\n      while (x % p == 0) {\n        x /= p;\n      }\n    }\n  }\n\n  if (x != 1) {\n    add_edge(idx, compr[x]);\n  }\n}\n\nint main () {\n  for (int i = 2; i < MAX_P; i++) {\n    if (!sieve[i]) {\n      smallp.push_back(i);\n      for (int j = i; j < MAX_P; j += i) {\n        sieve[j] = 1;\n      }\n    }\n  }\n  \n  ios::sync_with_stdio(false);\n\n  cin >> n;\n  \n  for (int i = 0; i < n; i++) {\n    cin >> arr[i];\n    add_to_compr(arr[i]);\n  }\n\n  int cur_c = n;\n  for (auto it = compr.begin(); it != compr.end(); it++) {\n    it->second = cur_c;\n    cur_c++;\n  }\n\n  for (int i = 0; i < n; i++) {\n    add_edges(i, arr[i]);\n  }\n  m = compr.size();\n  \n  for (int i = 0; i < n; i++) {\n    solve();\n  }\n  cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// includes {{{\n#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<tuple>\n#include<cmath>\n#include<random>\n#include<cassert>\n// #include<deque>\n// #include<multiset>\n// #include<bitset>\n// #include<cstring>\n// #include<bits/stdc++.h>\n// }}}\nusing namespace std;\nusing ll = long long;\n\n/// --- math {{{ ///\nll gcd(ll a, ll b) { return b == 0 ? a : gcd(b, a % b); }\nll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\nll extgcd(ll a, ll b, ll &x, ll &y) {\n  ll d;\n  return b == 0 ? (x = a < 0 ? -1 : 1, y = 0, a < 0 ? -a : a)\n    : (d = extgcd(b, a % b, y, x), y -= a / b * x, d);\n}\nll modinv(ll a, ll mod) {\n  ll x, y;\n  extgcd(a, mod, x, y);\n  if(x < 0) x += mod;\n  return x;\n}\nll modpow(ll a, ll b, ll mod) {\n  ll r = 1;\n  a %= mod;\n  while(b) {\n    if(b & 1) r = r * a % mod;\n    a = a * a % mod;\n    b >>= 1;\n  }\n  return r;\n}\n/// }}}--- ///\n\nint n;\nset<int> g[2000];\nint a[2000];\n\nint used[2000];\nint finished[2000];\n\nvector<int> mrg(vector<vector<int>> vals) {\n  int m = vals.size();\n  priority_queue<pair<int, int>> pq;\n  for(int i = 0; i < m; i++) {\n    reverse(begin(vals[i]), end(vals[i]));\n    if(vals[i].size()) pq.emplace(vals[i].back(), i);\n  }\n\n  vector<int> res;\n  while(pq.size()) {\n    int x, i;\n    tie(x, i) = pq.top();\n    pq.pop();\n    res.emplace_back(x);\n    vals[i].pop_back();\n    if(vals[i].size()) pq.emplace(vals[i].back(), i);\n  }\n  return res;\n}\n\nvector<int> dfs(int i) {\n  used[i] = 1;\n  vector<vector<int>> vals;\n  for(int j : g[i]) if(!used[j]) {\n    vector<int> v = dfs(j);\n    vals.push_back(v);\n  }\n  auto p = mrg(vals);\n  p.insert(p.begin(), a[i]);\n  return p;\n}\n\nint main() {\n  ios::sync_with_stdio(false), cin.tie(0);\n  cin >> n;\n  for(int i = 0; i < n; i++) cin >> a[i];\n  sort(a, a + n);\n  for(int i = 0; i < n; i++) for(int j = 0; j < i; j++) {\n    int x = gcd(a[i], a[j]);\n    if(x != 1) {\n      g[i].emplace(j);\n      g[j].emplace(i);\n    }\n  }\n  vector<vector<int>> vals;\n  for(int i = 0; i < n; i++) if(!used[i]) {\n    vector<int> v = dfs(i);\n    vals.push_back(v);\n  }\n  auto ans = mrg(vals);\n  for(int i = 0; i < n; i++) cout << ans[i] << \" \\n\"[i == n - 1];\n  cout << flush;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define all(x)  x.begin(),x.end()\n#define sz(x)   x.size()\n#define pb      push_back\n\nconst int   N   = 2e3 + 5;\n\ntypedef long long   ll;\ntypedef vector<int> vi;\n\nll  gcd(ll a,ll b)  {\n    return !a ? b : gcd(b % a,a);\n}\n\nvi  mer(vi a,vi b)  {\n    vi c;\n    int i = 0, j = 0;\n    while(i < sz(a) && j < sz(b))   {\n        if(a[i] < b[j]) c.pb(b[j++]);\n        else            c.pb(a[i++]);\n    }\n    while(i < sz(a))    c.pb(a[i++]);\n    while(j < sz(b))    c.pb(b[j++]);\n    return c;\n}\n\nvector<int> g[N], ar[N];\n\nll  a[N];\nint p[N], n;\n\nvoid dfs(int u) {\n    for(int v : g[u])\n        if(v != p[u] && p[v] < 0)   {\n            p[v] = u;\n            dfs(v);\n        }\n}\n\nvoid sol(int u) {\n    ar[u].push_back(u);\n    vector<int> res;\n    for(int v : g[u])\n        if(p[v] == u)   {\n            sol(v);\n            res = mer(res,ar[v]);\n        }\n    for(int i = 0 ; i < sz(res) ; ++i)\n        ar[u].pb(res[i]);\n}\n\nint main()  {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n\n    cin >> n;\n\n    for(int i = 1 ; i <= n ; ++i)\n        cin >> a[i];\n\n    sort(a + 1,a + 1 + n);\n\n    int j = 1;\n    while(j <= n && a[j] < 2)\n        ++j;\n\n    vector<int> res(j - 1,1);\n\n    n -= (j - 1);\n    for(int i = 1 ; i <= n ; ++i)\n        a[i] = a[i + j - 1];\n\n    for(int i = 0 ; i <= n ; ++i)\n        for(int j = 0 ; j <= n ; ++j)    {\n            if(i == j || gcd(a[i],a[j]) < 2)\n                continue;\n            g[i].pb(j);\n        }\n\n    memset(p,-1,sizeof p);\n    p[0] = 0;\n    dfs(0);\n    sol(0);\n\n    for(int i = sz(ar[0]) - 1 ; i ; --i)\n        res.pb(a[ar[0][i]]);\n\n    reverse(all(res));\n    for(int i = 0 ; i < sz(res) ; ++i)\n        cout << res[i] << ' ';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ADD(a, b) a = (a + ll(b)) % mod\n#define MUL(a, b) a = (a * ll(b)) % mod\n#define MAX(a, b) a = max(a, b)\n#define MIN(a, b) a = min(a, b)\n#define rep(i, a, b) for(int i = int(a); i < int(b); i++)\n#define rer(i, a, b) for(int i = int(a) - 1; i >= int(b); i--)\n#define all(a) (a).begin(), (a).end()\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sec second\n#define fst first\n#define debug(fmt, ...) Debug(__LINE__, \":\", fmt, ##__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<int, pi> ppi;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vl> mat;\ntypedef complex<double> comp;\nvoid Debug() {cout << '\\n'; }\ntemplate<class FIRST, class... REST>void Debug(FIRST arg, REST... rest){\n\tcout<<arg<<\" \";Debug(rest...);}\ntemplate<class T>ostream& operator<<(ostream& out,const vector<T>& v) {\n\tout<<\"[\";if(!v.empty()){rep(i,0,sz(v)-1)out<<v[i]<<\", \";out<<v.back();}out<<\"]\";return out;}\ntemplate<class S, class T>ostream& operator<<(ostream& out,const pair<S, T>& v){\n\tout<<\"(\"<<v.first<<\", \"<<v.second<<\")\";return out;}\nconst int MAX_N = 2010;\nconst int MAX_V = 100010;\nconst double eps = 1e-6;\nconst ll mod = 1000000007;\nconst int inf = 1 << 29;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\nll gcd(ll a, ll b) {\n\tif(b == 0) return a;\n\telse return gcd(b, a % b);\n}\n\nint N;\nbool on[MAX_N], used[MAX_N];\nbool deleted[MAX_N];\nint A[MAX_N];\nvector<pi> G[MAX_N];\n\nvoid add_edge(int from, int to) {\n\tG[from].pb(pi(to, sz(G[to])));\n\tG[to].pb(pi(from, sz(G[from]) - 1));\n}\n\nvoid erase_node(int v) {\n\tdeleted[v] = true;\n\trep(i, 0, sz(G[v])) {\n\t\tint n = G[v][i].fst, rat = G[v][i].sec;\n\t\tif(rat == -1) continue;\n\t\ton[n] = true;\n\t\tG[n][rat].sec = -1;\n\t\tG[v][i].sec = -1;\n\t}\n}\n\npi loop(int v, bool only = false) {\n\tused[v] = true;\n\tpi res;\n\tif(!only || on[v]) res = pi(A[v], v);\n\telse res = pi(inf, inf);\n\trep(i, 0, sz(G[v])) {\n\t\tint n = G[v][i].fst;\n\t\tif(G[v][i].sec == -1) continue;\n\t\tif(!used[n]) MIN(res, loop(n));\n\t}\n\treturn res;\n}\n\nvoid graph_show() {\n\trep(i, 0, N) {\n\t\tvector<int> res;\n\t\trep(j, 0, sz(G[i])) {\n\t\t\tint n = G[i][j].fst;\n\t\t\tif(G[i][j].sec == -1) continue;\n\t\t\tres.pb(A[n]);\n\t\t}\n\t\tdebug(A[i], res);\n\t}\n}\n\n\nvoid solve() {\n\tcin >> N;\n\trep(i, 0, N) {\n\t\tcin >> A[i];\n\t}\n\trep(i, 0, N) {\n\t\trep(j, i + 1, N) {\n\t\t\tif(gcd(A[i], A[j]) != 1) {\n\t\t\t\tadd_edge(i, j);\n\t\t\t}\n\t\t}\n\t}\n\n\trep(i, 0, N) {\n\t\tif(!used[i]) {\n\t\t\tpi p = loop(i);\n\t\t\ton[p.sec] = true;\n\t\t}\n\t}\n\tvector<int> ans;\n\trep(q, 0, N) {\n\t\t// debug(vi(on, on + N));\n\t\t// graph_show();\n\t\tint a = -1, at = -1;\n\t\tmemset(used, 0, sizeof(used));\n\t\trep(i, 0, N) {\n\t\t\tif(!used[i] && !deleted[i]) {\n\t\t\t\tpi p = loop(i, true);\n\t\t\t\tif(p.fst == inf) continue;\n\t\t\t\tif(a < p.fst) {\n\t\t\t\t\ta = p.fst; at = p.sec;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans.pb(a);\n\t\terase_node(at);\n\t}\n\trep(i, 0, N) {\n\t\tcout << ans[i] << \" \";\n\t}\n\tcout << \"\\n\";\n}\n\n\nint main() {\n#ifndef LOCAL\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n\tcout.precision(20);\n\tsrand((unsigned int)time(NULL));\n#ifdef LOCAL\n\t//freopen(\"in.txt\", \"wt\", stdout); //for tester\n    freopen(\"in.txt\", \"rt\", stdin);\n#endif\t\n\tsolve();\n#ifdef LOCAL\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cctype>\n#include <algorithm>\n#include <queue>\nusing namespace std;\ntypedef long long int64;\ninline int read(int f = 1, int x = 0, char ch = ' ')\n{\n    while(!isdigit(ch = getchar())) if(ch == '-') f = -1;\n    while(isdigit(ch)) x = x*10+ch-'0', ch = getchar();\n    return f*x;\n}\nconst int N = 2e3+5;\nint gcd(int a, int b) { return b?gcd(b, a%b):a; }\nstruct Edge\n{\n    int next, to;\n    Edge(int next = 0, int to = 0):next(next), to(to) {};\n}edge[N*N];\nint tot, head[N];\nint n, vis[N], f[N][N], deg[N], a[N];\nvoid add(int x, int y) { edge[++tot] = Edge(head[x], y), head[x] = tot, ++deg[y]; } \nvoid dfs(int x)\n{\n    vis[x] = 1;\n    for(int y = 1; y <= n; ++y)\n        if(!vis[y]&&f[x][y])\n            add(x, y), dfs(y);\n}\nint main()\n{\n    n = read();\n    for(int i = 1; i <= n; ++i) a[i] = read();\n    sort(a+1, a+1+n);\n    for(int i = 1; i <= n; ++i) \n        for(int j = 1; j < i; ++j)\n            if(gcd(a[i], a[j]) != 1) f[i][j] = f[j][i] = 1;\n    for(int i = 1; i <= n; ++i) if(!vis[i]) dfs(i);\n    priority_queue<int> q;\n    for(int i = 1; i <= n; ++i) if(!deg[i]) q.push(i);\n    while(q.size())\n    {\n        int x = q.top(); q.pop();\n        printf(\"%d \", a[x]);\n        for(int i = head[x]; i; i = edge[i].next) q.push(edge[i].to);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nЗАПУСКАЕМ \n░ГУСЯ░▄▀▀▀▄░РАБОТЯГУ░░\n▄███▀░◐░░░▌░░░░░░░\n░░░░▌░░░░░▐░░░░░░░\n░░░░▐░░░░░▐░░░░░░░\n░░░░▌░░░░░▐▄▄░░░░░\n░░░░▌░░░░▄▀▒▒▀▀▀▀▄\n░░░▐░░░░▐▒▒▒▒▒▒▒▒▀▀▄\n░░░▐░░░░▐▄▒▒▒▒▒▒▒▒▒▒▀▄\n░░░░▀▄░░░░▀▄▒▒▒▒▒▒▒▒▒▒▀▄\n░░░░░░▀▄▄▄▄▄█▄▄▄▄▄▄▄▄▄▄▄▀▄\n░░░░░░░░░░░▌▌░▌▌░░░░░\n░░░░░░░░░░░▌▌░▌▌░░░░░\n░░░░░░░░░▄▄▌▌▄▌▌░░░░░ \n */\n#pragma GCC target(\"sse4,tune=native\")\n#pragma GCC optimize(\"O3\",\"unroll-loops\")\n#include <iostream>\n#include <complex>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <numeric>\n#include <cstring>\n#include <ctime>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <cmath>\n#include <bitset>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <deque>\n    \n     \nusing namespace std;\ntemplate<typename T1, typename T2>inline void chkmin(T1 &x, T2 y) { if (x > y) x = y; }\ntemplate<typename T1, typename T2>inline void chkmax(T1 &x, T2 y) { if (x < y) x = y; } \ntemplate<typename T, typename U> inline ostream &operator<< (ostream &_out, const pair<T, U> &_p) { _out << _p.first << ' ' << _p.second; return _out; }\ntemplate<typename T, typename U> inline istream &operator>> (istream &_in, pair<T, U> &_p) { _in >> _p.first >> _p.second; return _in; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const vector<T> &_v) { if (_v.empty()) { return _out; } _out << _v.front(); for (auto _it = ++_v.begin(); _it != _v.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline istream &operator>> (istream &_in, vector<T> &_v) { for (auto &_i : _v) { _in >> _i; } return _in; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const set<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const multiset<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const unordered_set<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T> inline ostream &operator<< (ostream &_out, const unordered_multiset<T> &_s) { if (_s.empty()) { return _out; } _out << *_s.begin(); for (auto _it = ++_s.begin(); _it != _s.end(); ++_it) { _out << ' ' << *_it; } return _out; }\ntemplate<typename T, typename U> inline ostream &operator<< (ostream &_out, const map<T, U> &_m) { if (_m.empty()) { return _out; } _out << '(' << _m.begin()->first << \": \" << _m.begin()->second << ')'; for (auto _it = ++_m.begin(); _it != _m.end(); ++_it) { _out << \", (\" << _it->first << \": \" << _it->second << ')'; } return _out; }\ntemplate<typename T, typename U> inline ostream &operator<< (ostream &_out, const unordered_map<T, U> &_m) { if (_m.empty()) { return _out; } _out << '(' << _m.begin()->first << \": \" << _m.begin()->second << ')'; for (auto _it = ++_m.begin(); _it != _m.end(); ++_it) { _out << \", (\" << _it->first << \": \" << _it->second << ')'; } return _out; }\n#define sz(c) (int)(c).size()\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define left left228\n#define right right228\n#define next next228\n#define rank rank228\n#define prev prev228\n#define y1 y1228                                                         \n#define read(FILENAME) freopen((FILENAME + \".in\").c_str(), \"r\", stdin)\n#define write(FILENAME) freopen((FILENAME + \".out\").c_str(), \"w\", stdout)\n#define files(FILENAME) read(FILENAME), write(FILENAME)\n#define pb push_back\nconst string FILENAME = \"input\";\nconst int MAXN = 2228;\n//13:35\n//15:35\nint n;\nint a[MAXN];\nvector<int> g[MAXN];\nbool used[MAXN];\nint in[MAXN];\npriority_queue<int> q;\n\n\nvoid dfs(int u) {\n\tused[u] = true;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (!used[i] && __gcd(a[u], a[i]) > 1) {\n\t\t\tg[u].pb(i);\n\t\t\tin[i]++;\n\t\t\tdfs(i);\n\t\t}\n\t}\n}\n\n\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n//\tread(FILENAME);\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> a[i];\n\t}\n\tsort(a, a + n);\n\tfor (int i = 0; i < n; i++) {\n\t\tif (!used[i]) {\n\t\t\tdfs(i);\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tif (!in[i]) {\n\t\t\tq.push(i);\n\t\t}\n\t}\n\twhile (!q.empty()) {\n\t\tint x = q.top();\n\t\tq.pop();\n\t\tcout << a[x] << ' ';\n\t\tfor (auto y: g[x]) {\n\t\t\tin[y]--;\n\t\t\tif (in[y] == 0) {\n\t\t\t\tq.push(y);\n\t\t\t}\n\t\t}\n \t}\n \tcout << '\\n';\n\treturn 0;\t\t\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <math.h>\n#include <string.h>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <cassert>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <cmath>\n#include <ctime>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <sstream>\n#include <functional>\n#include <iomanip>\n//#include <windows.h>  //Should be deleted when using AtCoder&POJ\nusing namespace std;\n\n#define ll long long\n#define pii pair<int,int>\n#define qi ios::sync_with_stdio(0)\n/**==Info==\n*Program:1\n*Problem:Rearranging\n*Date:2018-11-17\n*Algorithm:Teacher's Graph and greedy\n*Stats:Unknown*/\n\nbool debug=false;\n\nint n;\nint a[2005];\n\nvector<int> nei[2005];\n\nint fa[2005];\n\nbool visit[2005];\n\nint getFa(int pos){\n\tif(fa[pos]==pos) return pos;\n\treturn fa[pos]=getFa(fa[pos]);\n}\n\nvoid Union(int x,int y){\n\tif(getFa(x)==getFa(y)){\n\t\treturn;\n\t}\n\t\n\tfa[getFa(x)]=getFa(y);\n}\n\nvector<int> path;\n\nvoid dfs(int pos){\n\tvisit[pos]=true;\n\tpath.push_back(pos);\n\tint mn=-1;\n\tfor(int i=0;i<nei[pos].size();i++){\n\t\tif(!visit[nei[pos][i]] && (mn==-1||a[nei[pos][i]]<a[nei[pos][mn]])){\n\t\t\tmn=i;\n\t\t}\n\t}\n\t\n\tif(mn==-1){\n\t\treturn;\n\t}\n\tdfs(nei[pos][mn]);\n}\n\nvoid solve(int x){\n\t//Solve the CC within <x>\n\tint f=getFa(x);\n\tvector<pii> pes;\n\tfor(int i=0;i<n;i++){\n\t\tif(fa[i]==f){\n\t\t\tpes.push_back(make_pair(a[i],i));\n\t\t}\n\t}\n\t\n\tsort(pes.begin(),pes.end());\n\t\n\tfor(int i=0;i<pes.size();i++){\n\t\tif(!visit[pes[i].second]){\n\t\t\tdfs(pes[i].second);\n\t\t}\n\t}\n}\n\nvector<vector<int>> shits;\n\nint main(int argc,char* argv[]){\n\t\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tcin>>a[i];\n\t}\n\t\n\tfor(int i=0;i<n;i++){\n\t\tfa[i]=i;\n\t}\n\t\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(__gcd(a[i],a[j])!=1){\n\t\t\t\tnei[i].push_back(j);\n\t\t\t\tUnion(i,j);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor(int i=0;i<n;i++){\n\t\tif(!visit[i]){\n\t\t\tpath.clear();\n\t\t\tsolve(i);\n\t\t\tshits.push_back(path);\n\t\t}\n\t}\n\t\n\tsort(shits.begin(),shits.end());\n\treverse(shits.begin(),shits.end());\n\t \n\tfor(vector<int> v:shits){\n\t\tfor(int p:v){\n\t\t\tcout<<a[p]<<\" \";\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define N 2100\nint n;\nint a[N],vis[N],pos[N];\nvector<int> v1[N],v2[N];\nint cmp(int x,int y){return a[x]<a[y];}\nvoid merge(int x,int y)\n{\n\tvector<int> tmp;\n\ttmp.clear();\n\tint p1=0,p2=0;\n\twhile(p1<v2[x].size()&&p2<v2[y].size())\n\t{\n\t\tif(v2[x][p1]<v2[y][p2])\n\t\t\ttmp.push_back(v2[y][p2]),p2++;\n\t\telse tmp.push_back(v2[x][p1]),p1++;\n\t}\n\twhile(p1<v2[x].size())\n\t\ttmp.push_back(v2[x][p1]),p1++;\n\twhile(p2<v2[y].size())\n\t\ttmp.push_back(v2[y][p2]),p2++;\n\tv2[x]=tmp;\n}\nvoid dfs(int x)\n{\n\tvis[x]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tif(!vis[i]&&__gcd(a[x],a[i])!=1)\n\t\t\tv1[x].push_back(i);\n\tsort(v1[x].begin(),v1[x].end(),cmp);\n\n\tfor(int i=0,t;i<v1[x].size();i++)\n\t\tif(!vis[t=v1[x][i]])\n\t\t{\n\t\t\tdfs(t);\n\t\t\tmerge(x,t);\n\t\t}\n\treverse(v2[x].begin(),v2[x].end());\n\tv2[x].push_back(a[x]);\n\treverse(v2[x].begin(),v2[x].end());\n}\nint main()\n{\n\t//freopen(\"tt.in\",\"r\",stdin);\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]),pos[i]=i;\n\tsort(pos+1,pos+1+n,cmp);\n\tfor(int i=1,t;i<=n;i++)\n\t\tif(!vis[t=pos[i]])\n\t\t\tdfs(t),merge(0,t);\n\tfor(int i=0;i<n;i++)\n\t\tprintf(\"%d \",v2[0][i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n\nconst int maxn = 2010;\n\nint N;\nint A[maxn];\nbool us[maxn], vis[maxn];\n\nvoid dfs(int v, vi &vec, vi &cmp) {\n\tvis[v] = 1;\n\tcmp.pb(v);\n\n\tfor (int to : vec) {\n\t\tif (!vis[to] && __gcd(A[v], A[to]) != 1) {\n\t\t\tdfs(to, vec, cmp);\n\t\t}\n\t}\n}\n\nvi merge(vi va, vi vb) {\n\tvi res;\n\tint tm = va.size() + vb.size();\n\tva.pb(-1);\n\tvb.pb(-1);\n\n\tint i1 = 0, i2 = 0;\n\n\trep(i, tm) {\n\t\tif (va[i1] > vb[i2]) {\n\t\t\tres.pb(va[i1++]);\n\t\t} else {\n\t\t\tres.pb(vb[i2++]);\n\t\t}\n\t}\n\n\treturn res;\n}\n\nvi decide(int ban, vi cand) {\n\tvi res;\n\tvector<vi> cmps;\n\n\tint mini = 1e9;\n\tint piv = -1;\n\n\tfor (int t : cand) {\n\t\tvis[t] = 0;\n\t\tif (ban == 0 || __gcd(A[t], ban) != 1) {\n\t\t\tif (mini > A[t]) {\n\t\t\t\tmini = A[t];\n\t\t\t\tpiv = t;\n\t\t\t}\n\t\t}\n\t}\n\n\tvi nx;\n\tfor (int t : cand) if (t != piv) {\n\t\tnx.pb(t);\n\t}\n\n\tcerr << \"nx \" << nx.size() << endl;\n\n\tvi cmp(N);\n\n\tfor (int t : nx) if (!cmp[t]) {\n\t\tvi vec;\n\t\tdfs(t, nx, vec);\n\t\tfor (int i : vec) cmp[i] = 1;\n\t\tvi sub = decide(mini, vec);\n\t\tres = merge(res, sub);\n\t}\n\n\tres.insert(res.begin(), mini);\n\n\tcerr << \"ban \" << ban << endl;\n\tcerr << \"mini \" << mini << endl;\n\tfor (int v : cand) {\n\t\tcerr << v << \" \";\n\t}\n\tputs(\"result\");\n\tfor (int v : res) {\n\t\tcerr << v << \" \";\n\t}\n\t\tputs(\"\");\n\treturn res;\n}\n\nint main() {\n\tcin >> N;\n\trep(i, N) cin >> A[i];\n\tvector<vi> vec;\n\tvi vx;\n\trep(i, N) vx.pb(i);\n\n\trep(i, N) {\n\t\tif (!us[i]) {\n\t\t\tvi v;\n\t\t\tdfs(i, vx, v);\n\t\t\tfor (int a : v) us[a] = 1;\n\t\t\tvec.pb(decide(0, v));\n\t\t}\n\t}\n\n\tvi ans;\n\tfor (auto v : vec) {\n\t\tans = merge(ans, v);\n\t}\n\n\trep(i, N) printf(\"%d%c\", ans[i], i == N - 1 ? '\\n' : ' ');\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\n#include<queue>\n#define MAXN 2048\n#define MAXM 4194304\nusing namespace std;\ninline int read()\n{\n\tint x=0,t=1,c;\n\twhile(!isdigit(c=getchar()))if(c=='-')t=-1;\n\twhile(isdigit(c))x=x*10+c-'0',c=getchar();\n\treturn x*t;\n}\nint gcd(int a,int b){return b?gcd(b,a%b):a;}\nint n,A[MAXN];\nbool edge[MAXN][MAXN];\nint first[MAXN],targ[MAXN],nxt[MAXN],lead[MAXN],cnte=1;\nvoid AddEdge(int u,int v)\n{\n\tlead[v]++;targ[cnte]=v;nxt[cnte]=first[u];first[u]=cnte++;\n}\nint deep[MAXN];\nvoid Search(int x=0,int depth=1)\n{\n\t//printf(\"%d %d\\n\",x,depth);\n\tdeep[x]=depth;\n\tfor(int i=1;i<=n;i++)\n\t\tif(edge[x][i])\n\t\t\tif(!deep[i])\n\t\t\t{\n\t\t\t\tSearch(i,depth+1);\n\t\t\t\tAddEdge(x,i);\n\t\t\t}\n}\nint main()\n{\n\tn=read();\n\tA[0]=0;\n\tfor(int i=1;i<=n;i++)A[i]=read();\n\tsort(A,A+1+n);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(i!=j)\n\t\t\t\tif(gcd(A[i],A[j])!=1)\n\t\t\t\t\tedge[i][j]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tedge[0][i]=1;\n\tSearch();\n\tpriority_queue<int> PQ;\n\tPQ.push(0);\n\twhile(!PQ.empty())\n\t{\n\t\tint x=PQ.top();PQ.pop();\n\t\tif(x)printf(\"%d \",A[x]);\n\t\tfor(int i=first[x];i;i=nxt[i])\n\t\t{\n\t\t\tlead[targ[i]]--;\n\t\t\tif(!lead[targ[i]])PQ.push(targ[i]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define per(i,b,a) for(int i=b;i>=a;i--)\n#define For(i,a,b) for(int i=a;i<=b;i++)\n#define Forenska(it,c) for(register __typeof(c.begin()) it=c.begin();it!=c.end();it++)\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\n#define all(x) x.begin(),x.end()\n#define sqr(x) ((x)*(x))\n#define lowbit(x) ((x)&(-x))\n#define GREATER(x) x,vector<x>,greater<x>\nusing namespace std;\nint i,j;\ntypedef long long LL;\ntypedef pair<int,int> pii;\ntypedef pair<LL,LL> pLL;\ntypedef vector<int> vec;\ntypedef vector<LL> vecL;\ntypedef vector<pii> vecP;\ntypedef vector<pLL> vecPL;\ntypedef vector<string> vecS;\ntypedef vector<vec> mat;\ntypedef complex<double> point;\nconst long double PI=3.1415926535897932384626433832795028841971693993751058209749445923078164062862089;\nconst LL INFLL=0x3f3f3f3f3f3f3f3f;\nconst int INF=0x3f3f3f3f;\nconst long double EPS=1e-10;\nint read()\n{\n\tint x=0;\n\tchar ch=' ';\n\tbool flag=false;\n\twhile(!isdigit(ch))\n\t{\n\t\tif(ch=='-')flag=true;\n\t\tch=getchar();\n\t}\n\twhile(isdigit(ch))\n\t{\n\t\tx=(x<<3)+(x<<1)+ch-'0';\n\t\tch=getchar();\n\t}\n\treturn flag?-x:x;\n}\nint n;\nvec A;\nmat g1,g2;\nconst int MAX_N=2005;\nbool vis[MAX_N];\nint in[MAX_N];\nvoid dfs(int v)\n{\n\tif(vis[v])return;\n\tvis[v]=true;\n\trep(i,0,g1[v].size())\n\t{\n\t\tint to=g1[v][i];\n\t\tif(!vis[to])\n\t\t{\n\t\t\tg2[v].pb(to);\n\t\t\tin[to]++;\n\t\t\tdfs(to);\n\t\t}\n\t}\n}\nint main()\n{\n\tn=read();\n\tA.resize(n);\n\trep(i,0,n)A[i]=read();\n\tsort(all(A));\n\tA.resize(unique(all(A))-A.begin());\n\tn=A.size();\n\tg1.resize(n);\n\tg2.resize(n);\n\trep(i,0,n)\n\t{\n\t\trep(j,i+1,n)\n\t\t{\n\t\t\tif(__gcd(A[i],A[j])>1)\n\t\t\t{\n\t\t\t\tg1[i].pb(j);\n\t\t\t\tg1[j].pb(i);\n\t\t\t}\n\t\t}\n\t}\n\trep(i,0,n)\n\t{\n\t\tdfs(i);\n\t}\n\tset <int> s;\n\tper(i,n-1,0)if(!in[i])s.insert(-i);\n\twhile(!s.empty())\n\t{\n\t\tint t=-*s.begin();\n\t\ts.erase(s.begin());\n\t\trep(i,0,g2[t].size())\n\t\t{\n\t\t\tint to=g2[t][i];\n\t\t\ts.insert(-to);\n\t\t}\n\t\tcout<<A[t]<<\" \";\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define LL long long\n#define RG register\n\nusing namespace std;\ntemplate<class T> T gi() {\n\tT x = 0; bool f = 0; char c = getchar();\n\twhile (c != '-' && (c < '0' || c > '9')) c = getchar();\n\tif (c == '-') f = 1, c = getchar();\n\twhile (c >= '0' && c <= '9') x = x * 10 + c - '0', c = getchar();\n\treturn f ? -x : x;\n}\nconst int N = 2010;\nstruct node { int to, nxt; } g[N * N];\nint lst[N], gl, a[N];\nvoid add(int x, int y) { g[++gl] = (node) {y, lst[x]}; lst[x] = gl; }\nstruct cmp1 {\n\tbool operator () (int x, int y) const {\n\t\treturn a[x] > a[y];\n\t}\n};\npriority_queue<int, vector<int>, cmp1> q[N];\npriority_queue<pair<int, int> > p;\nint fa[N], mn[N];\nint find(int x) {\n\treturn fa[x] == x ? x : fa[x] = find(fa[x]);\n}\nbool vis[N];\nint main() {\n\t//freopen(\".in\", \"r\", stdin);\n\t//freopen(\".out\", \"w\", stdout);\n\tint n = gi<int>();\n\tfor (int i = 1; i <= n; i++) a[i] = gi<int>(), fa[i] = i, mn[i] = a[i];\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 1; j <= n; j++)\n\t\t\tif (a[i] < a[j] && __gcd(a[i], a[j]) > 1) {\n\t\t\t\tadd(i, j), add(j, i);\n\t\t\t\tmn[find(i)] = min(mn[find(i)], mn[find(j)]);\n\t\t\t\tfa[find(j)] = find(i);\n\t\t\t}\n\tfor (int i = 1; i <= n; i++)\n\t\tif (mn[find(i)] == a[i]) {\n\t\t\tp.push(make_pair(a[i], find(i))), vis[i] = 1;\n\t\t\tq[find(i)].push(i);\n\t\t}\n\twhile (!p.empty()) {\n\t\tpair<int, int> u = p.top(); p.pop();\n\t\tprintf(\"%d \", u.first);\n\t\tint x = q[u.second].top(); q[u.second].pop();\n\t\tfor (int i = lst[x]; i; i = g[i].nxt) {\n\t\t\tint v = g[i].to;\n\t\t\tif (!vis[v]) q[u.second].push(v), vis[v] = 1;\n\t\t}\n\t\tif (!q[u.second].empty()) p.push(make_pair(a[q[u.second].top()], u.second));\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<set>\n#include<bitset>\n#include<map>\n\n#define fo(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef double db;\n\nint get(){\n\tchar ch;\n\twhile(ch=getchar(),(ch<'0'||ch>'9')&&ch!='-');\n\tif (ch=='-'){\n\t\tint s=0;\n\t\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\t\treturn -s;\n\t}\n\tint s=ch-'0';\n\twhile(ch=getchar(),ch>='0'&&ch<='9')s=s*10+ch-'0';\n\treturn s;\n}\n\nconst int N = 2005;\n\nint n;\nint a[N];\nstruct edge{\n\tint x,nxt;\n}e[N*N*2];\nint h[N],tot;\nint fa[N];\nint ans[N];\nint f[N][N];\nbool bz[N];\n\nint gcd(int x,int y){return y==0?x:gcd(y,x%y);}\n\nvoid inse(int x,int y){\n\te[++tot].x=y;\n\te[tot].nxt=h[x];\n\th[x]=tot;\n}\n\nvoid addedge(int x,int y){\n\tinse(x,y);\n\tinse(y,x);\n}\n\nint getfather(int x){return fa[x]==x?x:fa[x]=getfather(fa[x]);}\n\nbool cmp(int x,int y){\n\treturn a[x]<a[y];\n}\n\nint c[N];\n\nvoid merge(int *a,int *b){\n\tint ha=1,hb=1;\n\tfo(i,1,a[0]+b[0]){\n\t\tif (hb>b[0]||(ha<=a[0]&&a[ha]>b[hb]))c[i]=a[ha++];\n\t\telse c[i]=b[hb++];\n\t}\n\tc[0]=a[0]+b[0];\n\tfo(i,1,c[0])a[i]=c[i];\n\ta[0]=c[0];\n}\n\nvoid dfs(int x){\n\tbz[x]=1;\n\tint k=0,t[N];\n\tfor(int p=h[x];p;p=e[p].nxt)t[++k]=e[p].x;\n\tsort(t+1,t+1+k,cmp);\n\tf[x][0]=0;\n\tfo(i,1,k)\n\tif (!bz[t[i]]){\n\t\tdfs(t[i]);\n\t\tmerge(f[x],f[t[i]]);\n\t}\n\tfd(i,f[x][0]+1,2)f[x][i]=f[x][i-1];\n\tf[x][0]++;\n\tf[x][1]=x;\n}\n\nint main(){\n\tn=get();\n\tfo(i,1,n)fa[i]=i;\n\tfo(i,1,n)a[i]=get();\n\tfo(i,1,n)\n\t\tfo(j,i+1,n)\n\t\tif (gcd(a[i],a[j])!=1){\n\t\t\tint x=getfather(i),y=getfather(j);\n\t\t\tfa[x]=y;\n\t\t\taddedge(i,j);\n\t\t}\n\tans[0]=0;\n\tfo(i,1,n)\n\tif (getfather(i)==i){\n\t\tint w=0;\n\t\tfo(j,1,n)\n\t\tif (getfather(j)==i)\n\t\t\tif (!w||a[w]>a[j])w=j;\n\t\tdfs(w);\n\t\tmerge(ans,f[w]);\n\t}\n\tfo(i,1,n-1)printf(\"%d \",a[ans[i]]);\n\tprintf(\"%d\\n\",a[ans[n]]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iomanip>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define all(x) (x).begin(),(x).end()\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n \ntemplate<class T> inline bool chmax(T &a, T b){\n    if(a<b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T> inline bool chmin(T &a, T b){\n    if(a>b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<typename T>\nT gcd(T a, T b)\n{\n    return b ? gcd(b, a % b) : a;\n}\n\ntemplate<typename T>\nT lcm(T a,T b)\n{\n    return  a / gcd(a,b) * b;\n}\nclass UnionFind {\nprivate:\n    int sz;\n    vector<int> par, size_;\npublic:\n    UnionFind(){}\n    UnionFind(int node_size) : sz(node_size), par(sz), size_(sz, 1){\n        iota(par.begin(), par.end(), 0);\n    }\n    int find(int x){\n        if(par[x] == x) return x;\n        else return par[x] = find(par[x]);\n    }\n    void unite(int x,int y){\n        x = find(x), y = find(y);\n        if(x == y) return;\n        if(size_[x] < size_[y]) swap(x,y);\n        par[y] = x;\n        size_[x] += size_[y];\n    }\n    int size(int x){\n        x = find(x);\n        return size_[x];\n    }\n    bool same(int x,int y){\n        return find(x) == find(y);\n    }\n};\ntemplate<class _Key, class _Hash, bool DOWNSIZE> class UnorderedSetIterator;\n \ntemplate<class _Key, class _Hash = hash<_Key>, bool DOWNSIZE = false>\nclass UnorderedSet\n{\nprivate:\n    using iterator = UnorderedSetIterator<_Key, _Hash, DOWNSIZE>;\n    friend UnorderedSetIterator<_Key, _Hash, DOWNSIZE>;\n    struct bucket {\n        _Key _key;\n        short int _dist;\n        bool _last, _end;\n        bucket() noexcept : _dist(-1), _last(false), _end(false){}\n        bucket& operator=(const bucket& another) = default;\n        ~bucket(){ if(!empty()) _key.~_Key(); }\n        inline void clear() noexcept { _dist = -1; }\n        inline void _delete(){ _dist = -1, _key.~_Key(); }\n        inline bool empty() const noexcept { return (_dist == -1); }\n    };\n    inline static unsigned int ceilpow2(unsigned int u) noexcept {\n        --u, u |= u >> 1, u |= u >> 2, u |= u >> 4, u |= u >> 8;\n        return (u | (u >> 16)) + 1;\n    }\n    inline static bucket *increment(bucket *cur) noexcept {\n        for(++cur; !cur->_end; ++cur){\n            if(!cur->empty()) break;\n        }\n        return cur;\n    }\n    inline bucket *next_bucket(bucket *cur) const noexcept {\n        return cur->_last ? _buckets : cur + 1;\n    }\n    inline unsigned int make_hash(const _Key& key) const noexcept {\n        return _Hash()(key);\n    }\n    inline float load_rate() const noexcept {\n        return (float)_data_count / _bucket_count;\n    }\n    bucket *insert(bucket *cur, short int dist, _Key&& key){\n        bucket *ret = cur;\n        bool flag = false;\n        while(true){\n            if(cur->empty()){\n                cur->_key = move(key), cur->_dist = dist;\n                if(!flag) ret = cur, flag = true;\n                break;\n            }else if(dist > cur->_dist){\n                swap(key, cur->_key), swap(dist, cur->_dist);\n                if(!flag) ret = cur, flag = true;\n            }\n            ++dist;\n            cur = next_bucket(cur);\n        }\n        return ret;\n    }\n    bucket *_find(const _Key& key) const {\n        bucket *cur = _buckets + (make_hash(key) & _mask);\n        int dist = 0;\n        while(dist <= cur->_dist){\n            if(key == cur->_key) return cur;\n            ++dist, cur = next_bucket(cur);\n        }\n        return _buckets + _bucket_count;\n    }\n    template<class Key>\n    bucket *find_insert(Key&& key){\n        unsigned int hash = make_hash(key);\n        bucket *cur = _buckets + (hash & _mask);\n        int dist = 0;\n        while(dist <= cur->_dist){\n            if(key == cur->_key) return cur;\n            ++dist, cur = next_bucket(cur);\n        }\n        ++_data_count;\n        if(rehash_check()){\n            cur = _buckets + (hash & _mask), dist = 0;\n        }\n        _Key new_key = forward<Key>(key);\n        return insert(cur, dist, move(new_key));\n    }\n    bucket *backward_shift(bucket *cur, bool next_ret){\n        bucket *next = next_bucket(cur), *ret = cur;\n        if(next->_dist < 1) return next_ret ? increment(cur) : cur;\n        do {\n            cur->_key = next->_key, cur->_dist = next->_dist - 1;\n            cur = next, next = next_bucket(cur);\n        }while(next->_dist >= 1);\n        cur->clear();\n        return ret;\n    }\n    bucket *erase_impl(bucket *cur, bool next_ret){\n        assert(static_cast<size_t>(cur - _buckets) != _bucket_count);\n        cur->_delete();\n        --_data_count;\n        return backward_shift(cur, next_ret);\n    }\n    bucket *erase_itr(bucket *cur, bool next_ret = true){\n        const _Key key = cur->_key;\n        return erase_impl(rehash_check() ? _find(key) : cur, next_ret);\n    }\n    bucket *erase_key(const _Key& key, bool next_ret = true){\n        rehash_check();\n        return erase_impl(_find(key), next_ret);\n    }\n    bool rehash_check(){\n        if(load_rate() >= MAX_LOAD_RATE){\n            rehash(_bucket_count * 2u);\n            return true;\n        }else if(DOWNSIZE){\n            if(load_rate() <= MIN_LOAD_RATE && _bucket_count >= DOWNSIZE_THRESHOLD){\n                rehash(_bucket_count / 2u);\n                return true;\n            }\n        }\n        return false;\n    }\n    void move_data(bucket *cur){\n        insert(_buckets + (make_hash(cur->_key) & _mask), 0, move(cur->_key));\n    }\n    void rehash(unsigned int new_bucket_count){\n        UnorderedSet new_unordered_set(new_bucket_count);\n        new_unordered_set._data_count = _data_count;\n        for(bucket *cur = _buckets; !cur->_end; ++cur){\n            if(!cur->empty()){\n                new_unordered_set.move_data(cur);\n            }\n        }\n        swap(*this, new_unordered_set);\n    }\n    friend void swap(UnorderedSet& ust1, UnorderedSet& ust2){\n        swap(ust1._bucket_count, ust2._bucket_count);\n        swap(ust1._mask, ust2._mask);\n        swap(ust1._data_count, ust2._data_count);\n        swap(ust1._buckets, ust2._buckets);\n    }\n \nprivate:\n    unsigned int _bucket_count, _mask, _data_count;\n    bucket *_buckets;\npublic:\n    const float MAX_LOAD_RATE = 0.5f;\n    const float MIN_LOAD_RATE = 0.1f;\n    const unsigned int DOWNSIZE_THRESHOLD = 16u;\n    UnorderedSet(unsigned int bucket_size = 1u)\n     : _bucket_count(ceilpow2(max(bucket_size, 1u))), _mask(_bucket_count - 1),\n        _data_count(0u), _buckets(new bucket[_bucket_count + 1]){\n        _buckets[_bucket_count - 1]._last = true, _buckets[_bucket_count]._end = true;\n    }\n    UnorderedSet(const UnorderedSet& another)\n        : _bucket_count(another._bucket_count), _mask(another._mask), _data_count(another._data_count){\n        _buckets = new bucket[_bucket_count + 1u];\n        for(unsigned int i = 0u; i <= _bucket_count; ++i){\n            _buckets[i] = another._buckets[i];\n        }\n    }\n    UnorderedSet(UnorderedSet&& another)\n        : _bucket_count(move(another._bucket_count)), _mask(move(another._mask)),\n            _data_count(move(another._data_count)), _buckets(another._buckets){\n        another._buckets = nullptr;\n    }\n    UnorderedSet& operator=(const UnorderedSet& another){\n        delete[] _buckets;\n        _bucket_count = another._bucket_count;\n        _mask = another._mask;\n        _data_count = another._data_count;\n        _buckets = new bucket[_bucket_count + 1u];\n        for(unsigned int i = 0u; i <= _bucket_count; ++i){\n            _buckets[i] = another._buckets[i];\n        }\n        return *this;\n    }\n    UnorderedSet& operator=(UnorderedSet&& another){\n        delete[] _buckets;\n        _bucket_count = move(another._bucket_count);\n        _mask = move(another._mask);\n        _data_count = move(another._data_count);\n        _buckets = another._buckets;\n        another._buckets = nullptr;\n        return *this;\n    }\n    ~UnorderedSet(){ delete[] _buckets; }\n    friend ostream& operator<< (ostream& os, UnorderedSet& ust) noexcept {\n        for(_Key& val : ust) os << val << \" \";\n        return os;\n    }\n    void clear(){\n        UnorderedSet new_unordered_set(1u);\n        swap(*this, new_unordered_set);\n    }\n    size_t size() const noexcept { return _data_count; }\n    size_t bucket_count() const noexcept { return _bucket_count; }\n    bool empty() const noexcept { return (_data_count == 0); }\n    iterator begin() const noexcept {\n        return _buckets->empty() ? iterator(increment(_buckets)) : iterator(_buckets);\n    }\n    iterator end() const noexcept { return iterator(_buckets + _bucket_count); }\n    iterator find(const _Key& key) const { return iterator(_find(key)); }\n    size_t count(const _Key& key) const { return (_find(key) != _buckets + _bucket_count); }\n    iterator insert(const _Key& key){ return iterator(find_insert(key)); }\n    iterator insert(_Key&& key){ return iterator(find_insert(move(key))); }\n    iterator erase(const _Key& key){ return iterator(erase_key(key)); }\n    iterator erase(const iterator& itr){ return iterator(erase_itr(itr.bucket_ptr)); }\n    void simple_erase(const _Key& key){ erase_key(key, false); }\n    void simple_erase(const iterator& itr){ erase_itr(itr.bucket_ptr, false); }\n \n    // DEBUG 用\n    short int maximum_distance() const noexcept {\n        short int ret = -1;\n        for(bucket *cur = _buckets; !cur->_end; ++cur){\n            ret = max(ret, cur->_dist);\n        }\n        return ret;\n    }\n};\n \ntemplate<class _Key, class _Hash, bool DOWNSIZE>\nclass UnorderedSetIterator {\nprivate:\n    friend UnorderedSet<_Key, _Hash, DOWNSIZE>;\n    typename UnorderedSet<_Key, _Hash, DOWNSIZE>::bucket *bucket_ptr;\n    using iterator_category = forward_iterator_tag;\n    using value_type = _Key;\n    using difference_type = ptrdiff_t;\n    using pointer = _Key*;\n    using reference = _Key&;\n \nprivate:\n    UnorderedSetIterator(typename UnorderedSet<_Key, _Hash, DOWNSIZE>::bucket *_bucket_ptr)\n        noexcept : bucket_ptr(_bucket_ptr){}\npublic:\n    UnorderedSetIterator() noexcept : bucket_ptr(){}\n    UnorderedSetIterator(const UnorderedSetIterator& itr) noexcept : bucket_ptr(itr.bucket_ptr){}\n    UnorderedSetIterator& operator=(const UnorderedSetIterator& itr)\n        & noexcept { return bucket_ptr = itr.bucket_ptr, *this; }\n    UnorderedSetIterator& operator=(const UnorderedSetIterator&& itr)\n        & noexcept { return bucket_ptr = itr.bucket_ptr, *this; }\n    reference operator*() const noexcept { return bucket_ptr->_key; }\n    pointer operator->() const noexcept { return &(bucket_ptr->_key); }\n    UnorderedSetIterator& operator++() noexcept {\n        return bucket_ptr = UnorderedSet<_Key, _Hash, DOWNSIZE>::increment(bucket_ptr), *this;\n    }\n    UnorderedSetIterator operator++(int) const noexcept {\n        return UnorderedSetIterator(UnorderedSet<_Key, _Hash, DOWNSIZE>::increment(this->bucket_ptr));\n    }\n    bool operator==(const UnorderedSetIterator& itr) const noexcept { return !(*this != itr); };\n    bool operator!=(const UnorderedSetIterator& itr) const noexcept { return bucket_ptr != itr.bucket_ptr; }\n};\n \ntemplate<class _Key, class _Tp, class _Hash, bool DOWNSIZE> class UnorderedMapIterator;\n \ntemplate<class _Key, class _Tp, class _Hash = hash<_Key>, bool DOWNSIZE = false>\nclass UnorderedMap\n{\nprivate:\n    using iterator = UnorderedMapIterator<_Key, _Tp, _Hash, DOWNSIZE>;\n    using value_type = _Tp;\n    using data_type = pair<_Key, _Tp>;\n    using aligned_pointer = typename aligned_storage<sizeof(value_type), alignof(value_type)>::type;\n    friend UnorderedMapIterator<_Key, _Tp, _Hash, DOWNSIZE>;\n    struct bucket {\n        _Key _key;\n        short int _dist;\n        bool _last, _end;\n        aligned_pointer _value_ptr;\n        bucket() noexcept : _dist(-1), _last(false), _end(false){}\n        bucket& operator=(const bucket& another) noexcept {\n            _key = another._key, _dist = another._dist, _last = another._last, _end = another._end;\n            if(!another.empty()){\n                new(&_value_ptr) value_type(*reinterpret_cast<const value_type*>(&another._value_ptr));\n            }\n            return *this;\n        }\n        ~bucket(){ if(!empty()) _delete(); }\n        inline void clear() noexcept { _dist = -1; }\n        inline void _delete(){ _dist = -1, value_ptr()->~value_type(); }\n        inline bool empty() const noexcept { return (_dist == -1); }\n        inline value_type& value() noexcept {\n            return *reinterpret_cast<value_type*>(&_value_ptr);\n        }\n        inline value_type* value_ptr() noexcept {\n            return reinterpret_cast<value_type*>(&_value_ptr);\n        }\n        inline void new_value(value_type&& value){\n            new(&_value_ptr) value_type(move(value));\n        }\n    };\n    inline static unsigned int ceilpow2(unsigned int u) noexcept {\n        --u, u |= u >> 1, u |= u >> 2, u |= u >> 4, u |= u >> 8;\n        return (u | (u >> 16)) + 1;\n    }\n    inline static bucket *increment(bucket *cur) noexcept {\n        for(++cur; !cur->_end; ++cur){\n            if(!cur->empty()) break;\n        }\n        return cur;\n    }\n    inline bucket *next_bucket(bucket *cur) const noexcept {\n        return cur->_last ? _buckets : cur + 1;\n    }\n    inline unsigned int make_hash(const _Key& key) const noexcept {\n        return _Hash()(key);\n    }\n    inline float load_rate() const noexcept {\n        return (float)_data_count / _bucket_count;\n    }\n    bucket *insert(bucket *cur, _Key&& key, short int dist, value_type&& value){\n        bucket *ret = cur;\n        bool flag = false;\n        while(true){\n            if(cur->empty()){\n                cur->_key = move(key), cur->_dist = dist, cur->new_value(move(value));\n                if(!flag) ret = cur, flag = true;\n                break;\n            }else if(dist > cur->_dist){\n                swap(key, cur->_key), swap(dist, cur->_dist), swap(value, cur->value());\n                if(!flag) ret = cur, flag = true;\n            }\n            ++dist;\n            cur = next_bucket(cur);\n        }\n        return ret;\n    }\n    template<class Key>\n    bucket *_find(Key&& key, bool push = false){\n        unsigned int hash = make_hash(key);\n        bucket *cur = _buckets + (hash & _mask);\n        short int dist = 0;\n        while(dist <= cur->_dist){\n            if(key == cur->_key) return cur;\n            ++dist, cur = next_bucket(cur);\n        }\n        if(!push) return _buckets + _bucket_count;\n        ++_data_count;\n        if(rehash_check()){\n            cur = _buckets + (hash & _mask), dist = 0;\n        }\n        value_type new_value = value_type();\n        _Key new_key = forward<Key>(key);\n        return insert(cur, move(new_key), dist, move(new_value));\n    }\n    template<class Data>\n    bucket *find_insert(Data&& data){\n        const _Key& key = data.first;\n        unsigned int hash = make_hash(key);\n        bucket *cur = _buckets + (hash & _mask);\n        short int dist = 0;\n        while(dist <= cur->_dist){\n            if(key == cur->_key) return cur;\n            ++dist, cur = next_bucket(cur);\n        }\n        ++_data_count;\n        if(rehash_check()){\n            cur = _buckets + (hash & _mask), dist = 0;\n        }\n        data_type new_data = forward<Data>(data);\n        return insert(cur, move(new_data.first), dist, move(new_data.second));\n    }\n    bucket *backward_shift(bucket *cur, bool next_ret){\n        bucket *next = next_bucket(cur), *ret = cur;\n        if(next->_dist < 1) return next_ret ? increment(cur) : cur;\n        do {\n            cur->_key = next->_key, cur->_dist = next->_dist - 1;\n            cur->new_value(move(next->value()));\n            cur = next, next = next_bucket(cur);\n        }while(next->_dist >= 1);\n        cur->clear();\n        return ret;\n    }\n    bucket *erase_impl(bucket *cur, bool next_ret){\n        assert(static_cast<size_t>(cur - _buckets) != _bucket_count);\n        cur->_delete();\n        --_data_count;\n        return backward_shift(cur, next_ret);\n    }\n    bucket *erase_itr(bucket *cur, bool next_ret = true){\n        const _Key& key = cur->_key;\n        return erase_impl(rehash_check() ? _find(key) : cur, next_ret);\n    }\n    bucket *erase_key(const _Key& key, bool next_ret = true){\n        rehash_check();\n        return erase_impl(_find(key), next_ret);\n    }\n    bool rehash_check(){\n        if(load_rate() >= MAX_LOAD_RATE){\n            rehash(_bucket_count * 2u);\n            return true;\n        }else if(DOWNSIZE){\n            if(load_rate() <= MIN_LOAD_RATE && _bucket_count >= DOWNSIZE_THRESHOLD){\n                rehash(_bucket_count / 2u);\n                return true;\n            }\n        }\n        return false;\n    }\n    void move_data(bucket *cur){\n        insert(_buckets + (make_hash(cur->_key) & _mask), move(cur->_key), 0, move(cur->value()));\n    }\n    void rehash(unsigned int new_bucket_count){\n        UnorderedMap new_unordered_map(new_bucket_count);\n        new_unordered_map._data_count = _data_count;\n        for(bucket *cur = _buckets; !cur->_end; ++cur){\n            if(!cur->empty()){\n                new_unordered_map.move_data(cur);\n            }\n        }\n        swap(*this, new_unordered_map);\n    }\n    friend void swap(UnorderedMap& ump1, UnorderedMap& ump2){\n        swap(ump1._bucket_count, ump2._bucket_count);\n        swap(ump1._mask, ump2._mask);\n        swap(ump1._data_count, ump2._data_count);\n        swap(ump1._buckets, ump2._buckets);\n    }\n \nprivate:\n    unsigned int _bucket_count, _mask, _data_count;\n    bucket *_buckets;\npublic:\n    const float MAX_LOAD_RATE = 0.5f;\n    const float MIN_LOAD_RATE = 0.1f;\n    const unsigned int DOWNSIZE_THRESHOLD = 16u;\n    UnorderedMap(unsigned int bucket_size = 1u)\n     : _bucket_count(ceilpow2(max(bucket_size, 1u))), _mask(_bucket_count - 1),\n        _data_count(0u), _buckets(new bucket[_bucket_count + 1]){\n        _buckets[_bucket_count - 1]._last = true, _buckets[_bucket_count]._end = true;\n    }\n    UnorderedMap(const UnorderedMap& another)\n        : _bucket_count(another._bucket_count), _mask(another._mask), _data_count(another._data_count){\n        _buckets = new bucket[_bucket_count + 1u];\n        for(unsigned int i = 0u; i <= _bucket_count; ++i){\n            _buckets[i] = another._buckets[i];\n        }\n    }\n    UnorderedMap(UnorderedMap&& another)\n        : _bucket_count(move(another._bucket_count)), _mask(move(another._mask)),\n            _data_count(move(another._data_count)), _buckets(another._buckets){\n        another._buckets = nullptr;\n    }\n    UnorderedMap& operator=(const UnorderedMap& another){\n        delete[] _buckets;\n        _bucket_count = another._bucket_count;\n        _mask = another._mask;\n        _data_count = another._data_count;\n        _buckets = new bucket[_bucket_count + 1u];\n        for(unsigned int i = 0u; i <= _bucket_count; ++i){\n            _buckets[i] = another._buckets[i];\n        }\n        return *this;\n    }\n    UnorderedMap& operator=(UnorderedMap&& another){\n        delete[] _buckets;\n        _bucket_count = move(another._bucket_count);\n        _mask = move(another._mask);\n        _data_count = move(another._data_count);\n        _buckets = another._buckets;\n        another._buckets = nullptr;\n        return *this;\n    }\n    ~UnorderedMap(){ delete[] _buckets; }\n    friend ostream& operator<< (ostream& os, UnorderedMap& ump) noexcept {\n        for(auto val : ump) os << '{' << val.first << ',' << val.second << \"} \";\n        return os;\n    }\n    _Tp& operator[](const _Key& key){ return _find(key, true)->value(); }\n    _Tp& operator[](_Key&& key){ return _find(move(key), true)->value(); }\n    const _Tp& at(const _Key& key){\n        bucket *res = _find(key);\n        if(res == _buckets + _bucket_count) __throw_out_of_range(__N(\"Unordered_Map::at\"));\n        return res->value();\n    }\n    void clear(){\n        UnorderedMap new_unordered_map(1u);\n        swap(*this, new_unordered_map);\n    }\n    size_t size() const noexcept { return _data_count; }\n    size_t bucket_count() const noexcept { return _bucket_count; }\n    bool empty() const noexcept { return (_data_count == 0); }\n    iterator begin() const noexcept { return _buckets->empty() ? iterator(increment(_buckets)) : iterator(_buckets); }\n    iterator end() const noexcept { return iterator(_buckets + _bucket_count); }\n    iterator find(const _Key& key){ return iterator(_find(key)); }\n    iterator insert(const data_type& data){ return iterator(find_insert(data)); }\n    iterator insert(data_type&& data){ return iterator(find_insert(move(data))); }\n    iterator erase(const _Key& key){ return iterator(erase_key(key)); }\n    iterator erase(const iterator& itr){ return iterator(erase_itr(itr.bucket_ptr)); }\n    void simple_erase(const _Key& key){ erase_key(key, false); }\n    void simple_erase(const iterator& itr){ erase_itr(itr.bucket_ptr, false); }\n \n    // DEBUG 用\n    short int maximum_distance() const noexcept {\n        short int ret = -1;\n        for(bucket *cur = _buckets; !cur->_end; ++cur){\n            ret = max(ret, cur->_dist);\n        }\n        return ret;\n    }\n};\n \ntemplate<class _Key, class _Tp, class _Hash, bool DOWNSIZE>\nclass UnorderedMapIterator {\nprivate:\n    friend UnorderedMap<_Key, _Tp, _Hash, DOWNSIZE>;\n    typename UnorderedMap<_Key, _Tp, _Hash, DOWNSIZE>::bucket *bucket_ptr;\n    using iterator_category = forward_iterator_tag;\n    using value_type = pair<const _Key, _Tp>;\n    using difference_type = ptrdiff_t;\n    using reference = pair<const _Key&, _Tp&>;\n \nprivate:\n    UnorderedMapIterator(typename UnorderedMap<_Key, _Tp, _Hash, DOWNSIZE>::bucket *_bucket_ptr)\n        noexcept : bucket_ptr(_bucket_ptr){}\npublic:\n    UnorderedMapIterator() noexcept : bucket_ptr(){}\n    UnorderedMapIterator(const UnorderedMapIterator& itr) noexcept : bucket_ptr(itr.bucket_ptr){}\n    UnorderedMapIterator& operator=(const UnorderedMapIterator& itr)\n        & noexcept { return bucket_ptr = itr.bucket_ptr, *this; }\n    UnorderedMapIterator& operator=(const UnorderedMapIterator&& itr)\n        & noexcept { return bucket_ptr = itr.bucket_ptr, *this; }\n    reference operator*() const noexcept { return {bucket_ptr->_key, bucket_ptr->value()}; }\n    UnorderedMapIterator& operator++() noexcept {\n        return bucket_ptr = UnorderedMap<_Key, _Tp, _Hash, DOWNSIZE>::increment(bucket_ptr), *this;\n    }\n    UnorderedMapIterator operator++(int) const noexcept {\n        return UnorderedMapIterator(UnorderedMap<_Key, _Tp, _Hash, DOWNSIZE>::increment(this->bucket_ptr));\n    }\n    bool operator==(const UnorderedMapIterator& itr) const noexcept { return !(*this != itr); };\n    bool operator!=(const UnorderedMapIterator& itr) const noexcept { return bucket_ptr != itr.bucket_ptr; }\n};\n \n// 多重辺は無いと仮定する\nclass BSTNode {\npublic:\n    struct murmur_hash32 {\n        unsigned int operator()(int p) const {\n            const unsigned int m = 0x5bd1e995; p *= m;\n            unsigned int h = (p^(p>>24))*m;\n            return h = (h^(h>>13))*m, (h^(h>>15));\n        }\n    };\n    const int from, to;\n    int sz;\n    bool subtree_edge, subofftree_edge, exact_level;\n    BSTNode *left, *right, *par;\n    UnorderedSet<int, murmur_hash32, true> adjacent;\n    BSTNode(const int _ver) noexcept :\n        from(_ver), to(_ver), sz(0), subtree_edge(false), subofftree_edge(false),\n            exact_level(false), left(nullptr), right(nullptr), par(nullptr){}\n    BSTNode(const int _from, const int _to, const bool _flag) noexcept :\n        from(_from), to(_to), sz(0), subtree_edge(false), subofftree_edge(false),\n            exact_level((from < to) && _flag), left(nullptr), right(nullptr), par(nullptr){}\n    inline bool IsRoot() const noexcept { return !par; }\n    inline bool IsVertex() const noexcept { return (from == to); }\n    inline void eval() noexcept {\n        if(IsVertex()) sz = 1, subtree_edge = false, subofftree_edge = !adjacent.empty();\n        else sz = 0, subtree_edge = exact_level, subofftree_edge = false;\n        if(left){\n            sz += left->sz, subtree_edge |= left->subtree_edge, subofftree_edge |= left->subofftree_edge;\n        }\n        if(right){\n            sz += right->sz, subtree_edge |= right->subtree_edge, subofftree_edge |= right->subofftree_edge;\n        }\n    }\n    inline void subtree_edge_eval(){\n        subtree_edge = exact_level;\n        if(left) subtree_edge |= left->subtree_edge;\n        if(right) subtree_edge |= right->subtree_edge;\n    }\n    inline void subofftree_edge_eval(){\n        subofftree_edge = !adjacent.empty();\n        if(left) subofftree_edge |= left->subofftree_edge;\n        if(right) subofftree_edge |= right->subofftree_edge;\n    }\n    inline bool subofftree_check(){\n        return !adjacent.empty() ||\n                (left ? left->subofftree_edge : false) || (right ? right->subofftree_edge : false);\n    }\n    inline bool offtree_check(){\n        return adjacent.empty() ||\n                (left ? left->subofftree_edge : false) || (right ? right->subofftree_edge : false);\n    }\n    void rotate(const bool right_) noexcept {\n        BSTNode *p = par, *g = p->par;\n        if(right_){\n            if((p->left = right)) right->par = p;\n            right = p, p->par = this;\n        }else{\n            if((p->right = left)) left->par = p;\n            left = p, p->par = this;\n        }\n        p->eval(), eval();\n        if(!(par = g)) return;\n        if(g->left == p) g->left = this;\n        if(g->right == p) g->right = this;\n        g->eval();\n    }\n};\n \nBSTNode *splay(BSTNode *u) noexcept {\n    if(!u) return nullptr;\n    while(!(u->IsRoot())){\n        BSTNode *p = u->par, *gp = p->par;\n        if(p->IsRoot()){ // zig\n            u->rotate((u == p->left));\n        }else{\n            bool flag = (u == p->left);\n            if((u == p->left) == (p == gp->left)){ // zig-zig\n                p->rotate(flag), u->rotate(flag);\n            }else{ // zig-zag\n                u->rotate(flag), u->rotate(!flag);\n            }\n        }\n    }\n    return u;\n}\n \nBSTNode *join(BSTNode *root1, BSTNode *root2) noexcept {\n    if(!root1 || !root2) return root1 ? root1 : root2;\n    BSTNode *cur = nullptr, *nx = root1;\n    do{ cur = nx, nx = cur->right; }while(nx);\n    BSTNode *ver = splay(cur);\n    ver->right = root2, ver->eval(), root2->par = ver;\n    return ver;\n}\n \nclass EulerTourTree {\npublic:\n    struct murmur_hash64 {\n        unsigned long long operator()(unsigned long long p) const {\n            const unsigned long long m = 0xc6a4a7935bd1e995; p *= m;\n            unsigned long long h = (p^(p>>47))*m;\n            return h = (h^(h>>47))*m, (h^(h>>47));\n        }\n    };\n    inline static unsigned long long pair_to_ll(const int u, const int v){\n        return ((unsigned long long)(u) << 32) | v;\n    }\n    BSTNode** vertex_set;\n    UnorderedMap<unsigned long long, pair<BSTNode*, BSTNode*>, murmur_hash64> edge_set;\nprivate:\n    BSTNode *reroot(BSTNode *ver) noexcept {\n        BSTNode *res = splay(ver)->left;\n        if(!res) return ver;\n        ver->left = nullptr, ver->eval();\n        while(ver->right) ver = ver->right;\n        splay(ver), ver->right = res, ver->eval(), res->par = ver;\n        return ver;\n    }\n    void link(BSTNode *ver1, BSTNode *ver2, const bool flag) noexcept {\n        BSTNode *e1 = new BSTNode(ver1->from, ver2->from, flag);\n        BSTNode *e2 = new BSTNode(ver2->from, ver1->from, flag);\n        edge_set[pair_to_ll(ver1->from, ver2->from)] = {e1, e2};\n        join(join(reroot(ver1), e1), join(reroot(ver2), e2));\n    }\n    void cut(BSTNode *edge1, BSTNode *edge2) noexcept {\n        splay(edge1), splay(edge2);\n        BSTNode *p = edge1->par;\n        bool _right = (edge1 == edge2->right);\n        if(p != edge2){\n            _right = (p == edge2->right);\n            p->par = nullptr, edge1->rotate((edge1 == p->left));\n        }\n        if(edge1->left) edge1->left->par = nullptr;\n        if(edge1->right) edge1->right->par = nullptr;\n        if(_right){\n            if(edge2->left) edge2->left->par = nullptr;\n            join(edge2->left, edge1->right);\n        }else{\n            if(edge2->right) edge2->right->par = nullptr;\n            join(edge1->left, edge2->right);\n        }\n        // delete edge1; delete edge2;\n    }\n    bool connected(BSTNode *ver1, BSTNode *ver2) noexcept {\n        splay(ver1), splay(ver2);\n        return ver1->par;\n    }\n    int component_size(BSTNode *ver) noexcept { return splay(ver)->sz; }\npublic:\n    int V;\n    EulerTourTree(){}\n    // ~EulerTourTree(){\n    //     for(auto it : edge_set){\n    //         delete (it.second).first;\n    //         delete (it.second).second;\n    //     }\n    //     for(int i = 0; i < V; ++i) delete vertex_set[i];\n    //     delete[] vertex_set;\n    // }\n    void resize(const int node_size) noexcept {\n        V = node_size, vertex_set = new BSTNode*[V];\n        for(int i = 0; i < V; i++) vertex_set[i] = new BSTNode(i);\n    }\n    void reroot(const int node_id) noexcept { reroot(vertex_set[node_id]); }\n    void link(int node1_id, int node2_id, bool flag=true) noexcept {\n        if(node1_id > node2_id) swap(node1_id, node2_id);\n        link(vertex_set[node1_id], vertex_set[node2_id], flag);\n    }\n    void cut(int node1_id, int node2_id){\n        if(node1_id > node2_id) swap(node1_id, node2_id);\n        auto it = edge_set.find(pair_to_ll(node1_id, node2_id));\n        assert(it != edge_set.end());\n        BSTNode *edge1 = ((*it).second).first, *edge2 = ((*it).second).second;\n        edge_set.simple_erase(it);\n        cut(edge1, edge2);\n    }\n    bool connected(const int node1_id, const int node2_id) noexcept {\n        if(node1_id == node2_id) return true;\n        return connected(vertex_set[node1_id], vertex_set[node2_id]);\n    }\n    int component_size(int node_id) noexcept { return component_size(vertex_set[node_id]); }\n    void check_dfs(const BSTNode* cur) const noexcept {\n        if(cur->left) check_dfs(cur->left);\n        cout << \"{\" << (cur->from) << \",\" << (cur->to) << \"} \";\n        if(cur->right) check_dfs(cur->right);\n    }\n};\n \nclass DynamicConnectivity {\nprivate:\n    BSTNode *level_up_dfs(BSTNode *cur, const int layer) noexcept {\n        if(cur->exact_level){\n            splay(cur)->exact_level = false, cur->subtree_edge_eval();\n            detect_layer[EulerTourTree::pair_to_ll(cur->from, cur->to)]++;\n            et[layer+1].link(cur->from, cur->to);\n            return cur;\n        }\n        if(cur->left && cur->left->subtree_edge) return level_up_dfs(cur->left, layer);\n        if(cur->right && cur->right->subtree_edge) return level_up_dfs(cur->right, layer);\n        return nullptr;\n    }\n    BSTNode *search_edge_dfs\n        (BSTNode *cur, const int layer, const int another, bool& flag, pair<int, int>& rep_edge) noexcept {\n        if(!cur->adjacent.empty()){\n            bool state = et[layer+1].vertex_set[cur->from]->adjacent.empty();\n            for(auto it = cur->adjacent.begin(); it != cur->adjacent.end();){\n                pair<int, int> e = {min(cur->from, *it), max(cur->from, *it)};\n                BSTNode *correspond = et[layer].vertex_set[*it];\n                if(et[layer].connected(another, *it)){\n                    flag = true, rep_edge = e;\n                    cur->adjacent.simple_erase(it), correspond->adjacent.simple_erase(cur->from);\n                    if(!correspond->subofftree_check()){\n                        splay(correspond)->subofftree_edge_eval();\n                    }\n                    break;\n                }else{\n                    if(!et[layer+1].vertex_set[*it]->subofftree_check()){\n                        splay(et[layer+1].vertex_set[*it])->subofftree_edge = true;\n                    }\n                    et[layer+1].vertex_set[cur->from]->adjacent.insert(*it);\n                    et[layer+1].vertex_set[*it]->adjacent.insert(cur->from);\n                    detect_layer[EulerTourTree::pair_to_ll(e.first, e.second)]++;\n                    it = cur->adjacent.erase(it);\n                    correspond->adjacent.simple_erase(cur->from);\n                    if(!correspond->subofftree_check()){\n                        splay(correspond)->subofftree_edge_eval();\n                    }\n                }\n            }\n            if(state && !et[layer+1].vertex_set[cur->from]->offtree_check()){\n                splay(et[layer+1].vertex_set[cur->from])->subofftree_edge = true;\n            }\n            splay(cur)->subofftree_edge_eval();\n            return cur;\n        }\n        if(cur->left && cur->left->subofftree_edge){\n            return search_edge_dfs(cur->left, layer, another, flag, rep_edge);\n        }\n        if(cur->right && cur->right->subofftree_edge){\n            return search_edge_dfs(cur->right, layer, another, flag, rep_edge);\n        }\n        return nullptr;\n    }\n    bool replace(const int from, const int to, const int layer) noexcept {\n        if(layer < 0) return true;\n        int u, v;\n        if(et[layer].component_size(from) <= et[layer].component_size(to)) u = from, v = to;\n        else u = to, v = from;\n        BSTNode *ver = splay(et[layer].vertex_set[u]);\n        while(ver->subtree_edge) ver = level_up_dfs(ver, layer);\n        pair<int, int> rep_edge = {-1, -1};\n        bool flag = false;\n        while(ver->subofftree_edge){\n            ver = search_edge_dfs(ver, layer, v, flag, rep_edge);\n            if(flag) break;\n        }\n        if(flag){\n            et[layer].link(rep_edge.first, rep_edge.second);\n            for(int i = 0; i < layer; i++) et[i].link(rep_edge.first, rep_edge.second, false);\n            return false;\n        }else return replace(from, to, layer-1);\n    }\npublic:\n    const int V, layer_count;\n    EulerTourTree* et;\n    UnorderedMap<unsigned long long, int, EulerTourTree::murmur_hash64> detect_layer;\n    DynamicConnectivity(int node_size) noexcept : V(node_size), layer_count(ceil(log2(V))+1){\n        et = new EulerTourTree[layer_count];\n        for(int i = 0; i < layer_count; i++) et[i].resize(V);\n    }\n    // ~DynamicConnectivity(){\n    //     delete[] et;\n    // }\n    bool link(int node1_id, int node2_id) noexcept {\n        if(node1_id > node2_id) swap(node1_id, node2_id);\n        detect_layer[EulerTourTree::pair_to_ll(node1_id, node2_id)] = 0;\n        if(et[0].connected(node1_id, node2_id)){\n            BSTNode *ver1 = et[0].vertex_set[node1_id], *ver2 = et[0].vertex_set[node2_id];\n            splay(ver1)->subofftree_edge = true, ver1->adjacent.insert(node2_id);\n            splay(ver2)->subofftree_edge = true, ver2->adjacent.insert(node1_id);\n            return false;\n        }else{\n            et[0].link(node1_id, node2_id);\n            return true;\n        }\n    }\n    bool cut(int node1_id, int node2_id) noexcept {\n        if(node1_id > node2_id) swap(node1_id, node2_id);\n        auto it = detect_layer.find(EulerTourTree::pair_to_ll(node1_id, node2_id));\n        assert(it != detect_layer.end());\n        int layer = (*it).second;\n        detect_layer.simple_erase(it);\n        auto& st = et[layer].vertex_set[node1_id]->adjacent;\n        if(st.find(node2_id) == st.end()){\n            for(int i = 0; i <= layer; i++) et[i].cut(node1_id, node2_id);\n            return replace(node1_id, node2_id, layer);\n        }else{\n            et[layer].vertex_set[node1_id]->adjacent.simple_erase(node2_id);\n            if(!et[layer].vertex_set[node1_id]->subofftree_check()){\n                splay(et[layer].vertex_set[node1_id])->subofftree_edge_eval();\n            }\n            et[layer].vertex_set[node2_id]->adjacent.simple_erase(node1_id);\n            if(!et[layer].vertex_set[node2_id]->subofftree_check()){\n                splay(et[layer].vertex_set[node2_id])->subofftree_edge_eval();\n            }\n            return false;\n        }\n    }\n    bool connected(const int node1_id, const int node2_id) noexcept {\n        return et[0].connected(node1_id, node2_id);\n    }\n};\n\nint a[4000];\nvector<int> calc(pii e_min,vector<vector<int> > &g,UnorderedSet<int> &st,DynamicConnectivity &dc){\n    vector<int> res;\n    res.push_back(e_min.first);\n    if(st.size()==1){\n        return res;\n    }\n    int id = e_min.second;\n    vector<pii> v;\n    st.erase(id);\n    for(auto x:g[id]){\n        if(st.count(x)==1){\n            dc.cut(id,x);\n            v.push_back(MP(a[x],x));\n        }\n    }\n    sort(v.begin(),v.end());\n    vector<vector<int> > ss;\n    for(auto &x:v){\n        if(st.count(x.second)==0)continue;\n        UnorderedSet<int> p;\n        for(auto &y:st){\n            if(dc.connected(x.second,y)){\n                p.insert(y);\n            }\n        }\n        for(auto y:p){\n            st.erase(y);\n        }\n        ss.push_back(calc(x,g,p,dc));\n    }\n    priority_queue<pair<int,pii > > pp;\n    int m = ss.size();\n    rep(i,m){\n        pp.push(MP(ss[i][0],MP(i,0)));\n    }\n    while(!pp.empty()){\n        auto x = pp.top();\n        pp.pop();\n        res.push_back(x.first);\n        if(ss[x.second.first].size()!=x.second.second+1){\n            pp.push(MP(ss[x.second.first][x.second.second+1],MP(x.second.first,x.second.second+1)));\n        }\n    }\n    return res;\n}\n\nint main(){\n    int n;\n    cin >> n;\n    \n    rep(i,n){\n        cin >> a[i];\n    }\n    DynamicConnectivity dc(n);\n    vector<vector<int> > g(n);\n    UnionFind uf(n);\n    rep(i,n){\n        for(int j=i+1;j<n;j++){\n            if(gcd(a[i],a[j])!=1){\n                g[i].push_back(j);\n                g[j].push_back(i);\n                dc.link(i,j);\n                uf.unite(i,j);\n            }\n        }\n    }\n    vector<pair<int,int> > p(n,MP(inf,inf));\n    vector<UnorderedSet<int> > st(n);\n    rep(i,n){\n        p[uf.find(i)] = min(MP(a[i],i),p[uf.find(i)]);\n        st[uf.find(i)].insert(i);\n    }\n    vector<bool> used(n);\n    vector<vector<int> > res;\n    rep(i,n){\n        if(!used[uf.find(i)]){\n            int k = uf.find(i);\n            used[k] = 1;\n            auto ss = p[k];\n            res.push_back(calc(ss,g,st[k],dc));\n        }\n    }\n    priority_queue<pair<int,pii > > pp;\n    int m = res.size();\n    rep(i,m){\n        pp.push(MP(res[i][0],MP(i,0)));\n    }\n    vector<int> ans;\n    while(!pp.empty()){\n        auto x = pp.top();\n        pp.pop();\n        ans.push_back(x.first);\n        if(res[x.second.first].size()!=x.second.second+1){\n            pp.push(MP(res[x.second.first][x.second.second+1],MP(x.second.first,x.second.second+1)));\n        }\n    }\n    for(auto x:ans){\n        cout << x << \" \";\n    }\n    cout << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <memory.h>\n#include <math.h>\n#include <assert.h>\n#include <queue>\n#include <map>\n#include <set>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <functional>\n#include <unordered_map>\n#include <unordered_set>\n#include <list>\n#include <bitset>\n\nusing namespace std;\ntypedef pair<int, int> Pi;\ntypedef long long ll;\n#define Fi first\n#define Se second\n#define pb(x) push_back(x)\n#define sz(x) (int)x.size()\n#define rep(i, n) for(int i=0;i<n;i++)\n#define all(x) x.begin(), x.end()\ntypedef tuple<int, int, int> t3;\ntypedef pair<ll, ll> PL;\n\nint n, A[2020];\n\nvector <int> P[100010];\nvector <int> prlist;\nvector <int> IA[2020];\nset <int> S;\n\nint p[2020], v[2020];\nint Find(int x){\n\treturn p[x] == x ? x : p[x] = Find(p[x]);\n}\n\nint gc(int x, int y){\n\treturn y == 0 ? x : gc(y, x%y);\n}\n\nvoid solve(){\n\tscanf(\"%d\", &n);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\", A+i);\n\tfor(int i=1;i<=n;i++){\n\t\tint t = A[i];\n\t\tfor(int j=2;j*j<=t;j++){\n\t\t\tint f = 0;\n\t\t\twhile(t % j == 0){\n\t\t\t\tt /= j; f = 1;\n\t\t\t}\n\t\t\tif(f)S.insert(j);\n\t\t}\n\t\tif(t > 1)S.insert(t);\n\t}\n\tfor(auto it : S){\n\t\tprlist.pb(it);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tint t = A[i];\n\t\tvector <int> temp;\n\t\tfor(int j=2;j*j<=t;j++){\n\t\t\tint f = 0;\n\t\t\twhile(t % j == 0){\n\t\t\t\tt /= j; f = 1;\n\t\t\t}\n\t\t\tif(f)temp.pb(j);\n\t\t}\n\t\tif(t > 1)temp.pb(t);\n\t\tfor(auto e : temp){\n\t\t\tint a = (int)(lower_bound(all(prlist), e) - prlist.begin());\n\t\t\tP[a].pb(i);\n\t\t\tIA[i].pb(a);\n\t\t}\n\t}\n\tint vis[2020] = {}, ok[2020] = {};\n\tfor(int i=1;i<=n;i++)ok[i] = 1;\n\tfor(int u=1;u<=n;u++){\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tp[i] = i;\n\t\t\tif(ok[i])v[i] = A[i];\n\t\t\telse v[i] = 1e9;\n\t\t}\n\t\tfor(int i=0;i<sz(prlist);i++){\n\t\t\tfor(int j=1;j<sz(P[i]);j++){\n\t\t\t\tint x = P[i][j], y = P[i][j-1];\n\t\t\t\tif(Find(x) != Find(y)){\n\t\t\t\t\tif(v[Find(x)] > v[Find(y)])p[Find(x)] = y;\n\t\t\t\t\telse p[Find(y)] = x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint mx = -1, mxv = -1;\n\t\tfor(int i=1;i<=n;i++)if(vis[i] == 0){\n\t\t\tif(Find(i) == i && v[i] < 1e9){\n\t\t\t\tif(mx < v[i])mx = v[i], mxv = i;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d \", mx);\n\t\tvis[mxv] = 1;\n\t\tfor(int e : IA[mxv]){\n\t\t\tP[e].erase(find(all(P[e]), mxv));\n\t\t}\n\t\tmemset(ok, 0, sizeof ok);\n\t\tint f = 0;\n\t\tfor(int i=1;i<=n;i++)if(vis[i] == 0){\n\t\t\tif(gc(A[mxv], A[i]) > 1){\n\t\t\t\tf = 1;\n\t\t\t\tok[i] = 1;\n\t\t\t}\n\t\t}\n\t\tif(f == 0){\n\t\t\tfor(int i=1;i<=n;i++)if(vis[i] == 0)ok[i] = 1;\n\t\t}\n\t}\n\tputs(\"\");\n}\n\nint main(){\n\tint Tc = 1; //scanf(\"%d\", &Tc);\n\tfor(int tc=1;tc<=Tc;tc++){\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nint N, a[2017];\nbool ap[2017][2017], col[2017];\n\nint gcd (int a, int b)\n{\n    int r;\n    while (b)\n        r = a % b, a = b, b = r;\n    return a;\n}\n\nvoid print (vector < int > x, string s)\n{\n    bool ndSpace = 0;\n    printf (\"[\");\n    for (auto it : x)\n    {\n        if (ndSpace) printf (\" \");\n        printf (\"%d\", it), ndSpace = 1;\n    }\n    printf (\"]%s\", s.c_str ());\n}\n\nvector < int > combine (vector < int > a, vector < int > b)\n{\n    auto itA = a.begin (), itB = b.begin ();\n    vector < int > c;\n    while (itA != a.end () || itB != b.end ())\n    {\n        if (itA == a.end () || (itB != b.end () && *itA < *itB)) c.push_back (*itB), itB ++;\n        else c.push_back (*itA), itA ++;\n    }\n    return c;\n}\n\nvector < int > currComp, currP;\nvoid dfs (int nod)\n{\n    col[nod] = 0, currComp.push_back (nod);\n    for (auto i : currP)\n        if (ap[nod][i] && col[i])\n            dfs (i);\n}\n\nvector < int > solve (int frbd, vector < int > P)\n{\n    int mini = 1e9, how = -1;\n    currP = P;\n    for (auto it : P)\n        if (a[it] < mini && (frbd == -1 || ap[frbd][it]))\n            mini = a[it], how = it;\n    for (auto it : P)\n        col[it] = (it != how);\n    vector < vector < int > > splt;\n    for (auto i : currP)\n        if (ap[how][i] && col[i])\n            currComp.clear (), dfs (i), splt.push_back (currComp);\n    vector < int > ans;\n    for (auto v : splt)\n        ans = combine (ans, solve (how, v));\n    if (frbd != -1)\n        ans.insert (ans.begin (), a[how]);\n    return ans;\n}\n\nint main ()\n{\n//freopen (\"input\", \"r\", stdin);\n//freopen (\"output\", \"w\", stdout);\n\nscanf (\"%d\", &N);\nfor (int i=1; i<=N; i++)\n    scanf (\"%d\", &a[i]);\nfor (int i=0; i<=N; i++)\n    for (int j=i + 1; j<=N; j++)\n        ap[i][j] = ap[j][i] = (i == 0 || gcd (a[i], a[j]) != 1);\nvector < int > elems;\nfor (int i=0; i<=N; i++)\n    elems.push_back (i);\nvector < int > ans = solve (-1, elems);\nfor (auto it : ans)\n    printf (\"%d \", it);\nprintf (\"\\n\");\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<cstring>\n#include<algorithm>\n#include<queue>\n#define fo(i,a,b) for(i=a;i<=b;i++)\n#define ll long long\nusing namespace std;\nint n,a[2005],tot,du[2005],h[2005],to[4000005],nex[4000005];\nbool bhz[2005][2005],pd[2005];\nint gcd(int a,int b)\n{\n    return b?gcd(b,a%b):a;\n}\nstruct node{\n    int fr,id;\n}st;\nbool operator <(node a,node b)\n{\n    return a.fr<b.fr;\n}\npriority_queue<node> q;\nvoid add(int a,int b)\n{\n    du[b]++;\n    to[++tot]=b;\n    nex[tot]=h[a];\n    h[a]=tot;\n}\nvoid dfs(int x)\n{\n    pd[x]=1;\n    for(int i=1;i<=n;i++)\n        if(bhz[x][i]&&!pd[i])\n        {\n            add(x,i);\n            dfs(i);\n        }\n}\nint main()\n{\n    cin>>n;\n    for(int i=1;i<=n;i++) cin>>a[i];\n    sort(a+1,a+n+1);\n    for(int i=1;i<=n-1;i++)\n    for(int j=i+1;j<=n;j++)\n    if(gcd(a[i],a[j])>1) bhz[i][j]=bhz[j][i]=1;\n    for(int i=1;i<=n;i++) if(!pd[i]) dfs(i);\n    for(int i=1;i<=n;i++) \n        if(!du[i])\n        { \n            st.fr=a[i];\n            st.id=i;\n            q.push(st); \n        }\n    for(int i=1;i<=n;i++)\n    {\n        st=q.top();\n        q.pop();\n        int now=st.id;\n        cout<<a[now]<<\" \";\n\t\tint k=h[now]\n        for(;k;k=nex[k])\n        {\n            du[to[k]]--;\n            if(!du[to[k]])\n            {\n                st.fr=a[to[k]];\n                st.id=to[k];\n                q.push(st);\n            }\n        }\n//        int t=h[now];\n        while (t){\n            du[to[t]]--;\n            if (!du[to[t]]){\n                st.fr=a[to[t]];\n                st.id=to[t];\n                q.push(st);\n            }\n            t=nex[t];\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<map>\nusing namespace std;\nmap<int,int>Map;\nint n, w[2100], cnt, ct;\nvector<int>E[51000], P[2100];\nbool chk[51000], v[51000], Pos[51000];\nvoid Ins(int a, int num){\n    int i;\n    for(i=2;i*i<=a;i++){\n        if(a%i==0){\n            if(!Map[i]) Map[i] = ++cnt;\n            P[num].push_back(Map[i]);\n            while(a%i==0)a/=i;\n        }\n    }\n    if(a!=1){\n        if(!Map[a]) Map[a] = ++cnt;\n        P[num].push_back(Map[a]);\n    }\n}\nvoid Make_Edge(int a){\n    int i;\n    for(i=0;i<P[a].size();i++){\n        if(i){\n            E[P[a][0]].push_back(P[a][i]);\n            E[P[a][i]].push_back(P[a][0]);\n        }\n        v[P[a][i]]=false;\n    }\n}\nvoid DFS(int a){\n    int i;\n    ct--;\n    v[a]=true;\n    for(i=0;i<E[a].size();i++){\n        if(!v[E[a][i]])DFS(E[a][i]);\n    }\n}\nint gcd(int a, int b){\n    return b?gcd(b,a%b):a;\n}\nint main(){\n    int i, j, k, cc = 0;\n    scanf(\"%d\",&n);\n    for(i=1;i<=n;i++){\n        scanf(\"%d\",&w[i]);\n        if(w[i]==1){\n            cc++;\n            i--,n--;\n        }\n    }\n    sort(w+1,w+n+1);\n    for(i=1;i<=n;i++){\n        Ins(w[i], i);\n    }\n    for(i=1;i<=n;i++){\n        for(j=1;j<=cnt;j++){\n            E[j].clear();\n            v[j] = true;\n        }\n        for(j=1;j<=n;j++){\n            if(!chk[j]){\n                Make_Edge(j);\n            }\n        }\n        ct=0;\n        for(j=1;j<=cnt;j++)if(!v[j])ct++;\n        for(j=1;j<=n;j++){\n            if(!chk[j] && (i==1 || Pos[j])){\n                for(k=0;k<P[j].size();k++){\n                    if(!v[P[j][k]]){\n                        if(i==1) Pos[j] = true;\n                        DFS(P[j][k]);\n                    }\n                }\n                if(!ct){\n                    printf(\"%d \",w[j]);\n                    for(k=1;k<=n;k++){\n                        if(gcd(w[j],w[k])!=1){\n                            Pos[k] = true;\n                        }\n                    }\n                    chk[j] = true;\n                    break;\n                }\n            }\n        }\n    }\n    for(i=1;i<=cc;i++)printf(\"%d \",1);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pp;\ntypedef pair<ll,ll> pll;\nvoid read(int& x){ scanf(\"%d\",&x); }\nvoid read(ll& x){ scanf(\"%lld\",&x); }\ntemplate<typename T,typename... Args>\nvoid read(T& a,Args&... b){ read(a); read(b...); }\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define x first\n#define y second\nint gcd(int a, int b){ return b?gcd(b, a%b):a; }\n\nint n;\n\nint arr[2010];\nvector<int> edge[2010];\n\nvector<int> join_all(int init, vector<vector<int>> vs){\n    vector<int> ret;\n    priority_queue<pp> pq;\n    if(init != -1) ret.pb(init);\n    int n=vs.size();\n    for(int i=0; i<n; ++i){\n        reverse(all(vs[i]));\n        pq.push(pp{vs[i].back(), i});\n        vs[i].pop_back();\n    }\n    while(pq.size()){\n        int a, b; tie(a, b)=pq.top(); pq.pop();\n        ret.pb(a);\n        if(vs[b].size()) pq.push(pp{vs[b].back(), b}), vs[b].pop_back();\n    }\n    return ret;\n}\n\nbool vis[2010];\nbool vis_dfs[2010];\nint par[2010];\n\nvector<int> comp;\nvoid dfs(int x){\n    vis_dfs[x]=1;\n    comp.pb(x);\n    for(int y:edge[x]) if(!vis[y] && !vis_dfs[y]) dfs(y);\n}\n\nvector<int> work_comp(int x){\n    comp.clear(); dfs(x);\n    for(int a:comp) vis_dfs[a]=0;\n    int k=comp.size(), mi=0;\n    for(int i=1; i<k; ++i) if(arr[comp[mi]]>arr[comp[i]]) mi=i;\n    vector<vector<int>> vs;\n    vis[x]=1;\n    for(int y:edge[x]) if(!vis[y]) vs.pb(work_comp(y));\n    return join_all(arr[x], vs);\n}\n\nint main()\n{\n\tread(n);\n\tfor(int i=1; i<=n; ++i) read(arr[i]);\n\t\n\tfor(int i=1; i<n; ++i) for(int j=i+1; j<=n; ++j){\n        if(gcd(arr[i], arr[j])!=1){\n            edge[i].pb(j);\n            edge[j].pb(i);\n        }\n\t}\n\t\n\tvector<vector<int>> vs;\n\t\n\tfor(int i=1; i<=n; ++i) if(!vis[i]) vs.pb(work_comp(i));\n    \n    for(int x:join_all(-1, vs)) printf(\"%d \", x);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <queue>\n#include <iostream>\n\ntemplate<typename ForwardIter>\nvoid dump(ForwardIter begin, ForwardIter end)\n{\n    while (begin != end)\n        std::cout << *begin++ << \" \";\n    std::cout << std::endl;\n}\n\nconst int kN = 2000 + 5;\nint a[kN], n;\nstd::vector<std::pair<int, int>> edges[kN];\nstd::vector<int> seq[kN];\nbool vis[kN];\n\nint gcd(int a, int b)\n{\n    return b == 0 ? a : gcd(b, a % b);\n}\n\nvoid dfs(int u)\n{\n    std::sort(edges[u].begin(), edges[u].end());\n    for (auto t : edges[u]) {\n        int v = t.second;\n        if (vis[v]) continue;\n        vis[v] = true;\n        dfs(v);\n        std::vector<int> vec;\n        for (int i = 0, j = 0; i < seq[u].size() || j < seq[v].size(); ) {\n            if (i < seq[u].size() && j < seq[v].size())\n                vec.emplace_back(seq[u][i] > seq[v][j] ? seq[u][i ++] : seq[v][j ++]);\n            else if (i < seq[u].size())\n                vec.emplace_back(seq[u][i ++]);\n            else\n                vec.emplace_back(seq[v][j ++]);\n        }\n        vec.swap(seq[u]);\n    }\n    seq[u].insert(seq[u].begin(), a[u]);\n}\n\nint main()\n{\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; ++ i) {\n        scanf(\"%d\", a + i);\n    }\n    std::sort(a, a + n);\n    for (int i = 0; i < n; ++ i) {\n        for (int j = i + 1; j < n; ++ j) {\n            if (gcd(a[i], a[j]) > 1) {\n                edges[i].emplace_back(a[j], j);\n                edges[j].emplace_back(a[i], i);\n            }\n        }\n    }\n    for (int i = 0; i < n; ++ i) edges[n].emplace_back(a[i], i);\n    dfs(n);\n    for (int i = 1; i <= n; ++ i) {\n        printf(\"%d%c\", seq[n][i], \" \\n\"[i == n]);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n\nconst int maxn = 2010;\n\nint N;\nint A[maxn];\nbool us[maxn], vis[maxn];\n\nvoid dfs(int v, vi &vec, vi &cmp) {\n\tvis[v] = 1;\n\tcmp.pb(v);\n\n\tfor (int to : vec) {\n\t\tif (!vis[to] && __gcd(A[v], A[to]) != 1) {\n\t\t\tdfs(to, vec, cmp);\n\t\t}\n\t}\n}\n\nvi merge(vi va, vi vb) {\n\tvi res;\n\tint tm = va.size() + vb.size();\n\tva.pb(-1);\n\tvb.pb(-1);\n\n\tint i1 = 0, i2 = 0;\n\n\trep(i, tm) {\n\t\tif (va[i1] > vb[i2]) {\n\t\t\tres.pb(va[i1++]);\n\t\t} else {\n\t\t\tres.pb(vb[i2++]);\n\t\t}\n\t}\n\n\treturn res;\n}\n\nvi decide(int ban, vi cand) {\n\tvi res;\n\tif (cand.size() == 0) {\n\t\treturn res;\n\t}\n\tvector<vi> cmps;\n\n\tint mini = 1e9;\n\tint piv = -1;\n\n\tfor (int t : cand) {\n\t\tvis[t] = 0;\n\t\tif (ban == 0 || __gcd(A[t], ban) != 1) {\n\t\t\tif (mini > A[t]) {\n\t\t\t\tmini = A[t];\n\t\t\t\tpiv = t;\n\t\t\t}\n\t\t}\n\t}\n\n\tvi nx;\n\tfor (int t : cand) if (t != piv) {\n\t\tnx.pb(t);\n\t}\n\n\tvi cmp(N);\n\n\tfor (int t : nx) if (!cmp[t]) {\n\t\tvi vec;\n\t\tdfs(t, nx, vec);\n\t\tfor (int i : vec) cmp[i] = 1;\n\t\tvi sub = decide(mini, vec);\n\t\tres = merge(res, sub);\n\t}\n\n\tres.insert(res.begin(), mini);\n\n\treturn res;\n}\n\nint main() {\n\tcin >> N;\n\trep(i, N) cin >> A[i];\n\tvector<vi> vec;\n\tvi vx;\n\trep(i, N) vx.pb(i);\n\n\trep(i, N) {\n\t\tif (!us[i]) {\n\t\t\tvi v;\n\t\t\tdfs(i, vx, v);\n\t\t\tfor (int a : v) us[a] = 1;\n\t\t\tvec.pb(decide(0, v));\n\t\t}\n\t}\n\n\tvi ans;\n\tfor (auto v : vec) {\n\t\tans = merge(ans, v);\n\t}\n\n\trep(i, N) printf(\"%d%c\", ans[i], i == N - 1 ? '\\n' : ' ');\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#define maxn 2005\nusing namespace std;\ntypedef pair<int,int> PII;\nint n,a[maxn],ans[maxn],deg[maxn];\nbool G1[maxn][maxn],vis[maxn];\nvector<int> G[maxn];\npriority_queue<PII> q;\nint gcd(int a,int b)\n{\n\tif(!b) return a;\n\treturn gcd(b,a%b);\n}\nvoid dfs(int u,int fa)\n{\n\tvis[u]=true;\n\tfor(int v=1;v<=n;v++)\n\t\tif(G1[u][v]&&!vis[v])\n\t\t{\n\t\t\tG[u].push_back(v); deg[v]++;\n\t\t\tdfs(v,u);\n\t\t}\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\tif(gcd(a[i],a[j])!=1) G1[i][j]=G1[j][i]=true;\n\tfor(int i=1;i<=n;i++)\n\t\tif(!vis[i]) dfs(i,0);\n\tfor(int i=1;i<=n;i++)\n\t\tif(!deg[i]) q.push(PII(a[i],i));\n\tint cnt=0;\n\twhile(!q.empty())\n\t{\n\t\tPII u=q.top(); q.pop();\n\t\tans[++cnt]=u.first;\n\t\tfor(int i=0,siz=G[u.second].size();i<siz;i++)\n\t\t{\n\t\t\tint v=G[u.second][i]; deg[v]--;\n\t\t\tif(!deg[v]) q.push(PII(a[v],v));\n\t\t}\n\t}\n\tfor(int i=1;i<cnt;i++) printf(\"%d \",ans[i]);\n\tprintf(\"%d\\n\",ans[n]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nconst int maxn = 2030, oo = 123456789, maxm = 34010;\n \nint n, m, T, ans, mn, a[maxn], foo[maxn], lst[maxm], tag[maxn], q[maxn], rar, mx[maxn];\nbool vis[maxn], f[maxn], G[maxn][maxn], F[maxn];\nstd::vector<int> g[maxn], has[maxn], rhas[maxm], all;\nstd::pair<int, int> v[2];\n \nvoid GEN() {\n\tint mx = 0;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif(!foo[i]) {\n\t\t\tif(a[i] == 1) {\n\t\t\t\tF[i] = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tF[i] = 0;\n\t\t\t\tfor (int j: has[i]) {\n\t\t\t\t\tif(lst[j] >= mx) {\n\t\t\t\t\t\tF[i] = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t(foo[i] > mx) && (mx = foo[i]);\n\t\t}\n\t}\n\treturn;\n}\n /*\ninline void dfs(int &u) {\n\ttag[u] = T;\n\t(F[u] && a[u] < mn) && (mn = a[u]);\n\tvis[u] = 1;\n\tfor (int &v: g[u]) {\n\t\tif(!vis[v] && !f[v]) {\n\t\t\tdfs(v);\n\t\t}\n\t}\n\treturn;\n}\n */\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tscanf(\"%d\", a + i);\n\t\tint t = a[i];\n\t\tfor (int x = 2; x * x <= t; ++x) {\n\t\t\tif(t % x == 0) {\n\t\t\t\tall.push_back(x);\n\t\t\t\twhile(t % x == 0) {\n\t\t\t\t\tt /= x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(t > 1) {\n\t\t\tall.push_back(t);\n\t\t}\n\t}\n\tstd::sort(a + 1, a + n + 1);\n\tstd::sort(all.begin(), all.end());\n\tall.resize(std::unique(all.begin(), all.end()) - all.begin());\n\tm = (int)(all.size());\n\tfor (int i = 1; i <= n; ++i) {\n\t\tF[i] = 1;\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tif(a[i] % all[j] == 0) {\n\t\t\t\thas[i].push_back(j);\n\t\t\t\trhas[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int j = 0; j < m; ++j) {\n\t\tfor (int i = 0; i < (int)(rhas[j].size()); ++i) {\n\t\t\tfor (int k = 0; k < i; ++k) {\n\t\t\t\tint u = rhas[j][i], v = rhas[j][k];\n\t\t\t\tif(!G[u][v]) {\n\t\t\t\t\tg[u].push_back(v);\n\t\t\t\t\tg[v].push_back(u);\n\t\t\t\t\tG[u][v] = G[v][u] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n//\t\tGEN();\n\t\tmemset(vis + 1, 0, sizeof(vis[0]) * n);\n\t\tv[0] = v[1] = std::make_pair(-1, -1);\n\t\tfor (int u = 1; u <= n; ++u) {\n\t\t\tif(F[u]) {\n\t\t\t\tif(!vis[u] && !f[u]) {\n\t\t\t\t\t++T;\n\t\t\t\t\tmn = oo;\n//\t\t\t\t\tdfs(u);\n\t\t\t\t\trar = 0;\n\t\t\t\t\tq[rar++] = u;\n\t\t\t\t\tvis[u] = 1;\n\t\t\t\t\tfor (register int fnt = 0; fnt < rar; ++fnt) {\n\t\t\t\t\t\tint u = q[fnt];\n\t\t\t\t\t\ttag[u] = T;\n\t\t\t\t\t\t(F[u] && a[u] < mn) && (mn = a[u]);\n\t\t\t\t\t\tfor (int &v: g[u]) {\n\t\t\t\t\t\t\tif(!vis[v] && !f[v]) {\n\t\t\t\t\t\t\t\tq[rar++] = v;\n\t\t\t\t\t\t\t\tvis[v] = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(mn > v[1].first) {\n\t\t\t\t\t\tv[0] = v[1];\n\t\t\t\t\t\tv[1] = std::make_pair(mn, T);\n\t\t\t\t\t}\n\t\t\t\t\telse if(mn > v[0].first) {\n\t\t\t\t\t\tv[0] = std::make_pair(mn, T);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//ans = 0;\n\t\tfor (int u = 1; u <= n; ++u) {\n\t\t\tif(F[u] && !f[u]) {\n\t\t\t\tint i = 1;\n\t\t\t\tif(v[i].second == tag[u]) {\n\t\t\t\t\t--i;\n\t\t\t\t}\n\t\t\t\tif(v[i].first <= a[u]) {\n\t\t\t\t\tans = u;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tf[ans] = 1;\n\t\tfoo[ans] = i;\n\t\tprintf(\"%d \", a[ans]);\n\t\tfor (int j: has[ans]) {\n\t\t\tlst[j] = i;\n\t\t}\n\t\tfor (register int &u: g[ans]) {\n\t\t\t\tF[u] = 1;\n\t\t}\n\t\tfor (register int j = ans + 1; j <= n; ++j) {\n\t\t\tmx[j] = i;\n\t\t\tF[j] = G[ans][j];\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint Eulg(int a, int b);\n\nint main(int argc, char *argv[]){\n\n\tint N;\n\tcin>>N;\n\n\tint *a = new int[N]();\n\n\tfor(int i=0; i<N; i++){\n\t\tcin>>a[i];\n\t}\n\n\tsort(a, a+N);\n\n\tbool flag = true;\n\twhile(flag){\n\tfor(int i=0; i<N; i++){\n\t\tfor(int j=i+1; j<N; j++){\n\t\t\tif(Eulg(a[i], a[j]) == 1){\n\t\t\t\tif(a[i]<a[j]){\n\t\t\t\t\tint tmp;\n\t\t\t\t\ttmp =a[i];\n\t\t\t\t\ta[i] = b[i];\n\t\t\t\t\tb[i] = tmp;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t}\n}\n\nfor(int i=0; i<N; i++)\n\tcout<<a[i]<<\"  \";\n\n\n\n\tdelete[] a;\n\treturn 0;\n}\n\nint Eulg(int a, int b){\n\tif(a<b){\n\t\tint tmp;\n\t\ttmp =a;\n\t\ta = b;\n\t\tb = tmp;\n\t}\n\n\tint r;\n\tr = a % b;\n\twhile(r){\n\t\ta = b;\n\t\tb = a / b;\n\t\tr = a % b;\n\t}\n\treturn b;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb  push_back\nusing namespace std;\n\ntypedef pair<int,int>  PII;\nint n,a[2010],e[2010][2010],vis[2010];\n\nint gcd(int a,int b){return b?gcd(b,a%b):a;}\n\nvector <int> solve(int x)\n{\n\tint m=0;\n\tvector <vector <int> > V;\n\tvector <vector <int> ::iterator> h;\n\tvector <int> r;\n\tvis[x]=1;\n\tfor (int y=1; y<=n; y++)\n\t\tif ((e[x][y])&&(!vis[y]))\n\t\t\tV.pb(solve(y)),h.pb(V[m].begin()),m++;\n\tr.pb(a[x]);\n\twhile (1)\n\t\t{\n\t\t\tint x=-1;\n\t\t\tfor (int i=0; i<m; i++)\n\t\t\t\tif ((h[i]!=V[i].end())&&((x<0)||(*h[i]>*h[x])))\n\t\t\t\t\tx=i;\n\t\t\tif (x<0)  return r;\n\t\t\tr.pb(*h[x]),h[x]++;\t\t\t\n\t\t}\n}\n\nvoid work()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1; i<=n; i++)  scanf(\"%d\",&a[i]),e[0][i]=1;\n\tsort(a+1,a+n+1);\n\tfor (int i=1; i<=n; i++)\n\t\tfor (int j=i+1; j<=n; j++)\n\t\t\tif (gcd(a[i],a[j])!=1)\n\t\t\t\te[i][j]=e[j][i]=1;\n\tvector <int> ans=solve(0);\n\tfor (int i=1; i<=n; i++)  printf(\"%d \",ans[i]);\n}\n\nint main()\n{\n\twork();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC target(\"avx\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"inline\")\n#pragma GCC optimize(\"-fgcse\")\n#pragma GCC optimize(\"-fgcse-lm\")\n#pragma GCC optimize(\"-fipa-sra\")\n#pragma GCC optimize(\"-ftree-pre\")\n#pragma GCC optimize(\"-ftree-vrp\")\n#pragma GCC optimize(\"-fpeephole2\")\n#pragma GCC optimize(\"-ffast-math\")\n#pragma GCC optimize(\"-fsched-spec\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC optimize(\"-falign-jumps\")\n#pragma GCC optimize(\"-falign-loops\")\n#pragma GCC optimize(\"-falign-labels\")\n#pragma GCC optimize(\"-fdevirtualize\")\n#pragma GCC optimize(\"-fcaller-saves\")\n#pragma GCC optimize(\"-fcrossjumping\")\n#pragma GCC optimize(\"-fthread-jumps\")\n#pragma GCC optimize(\"-funroll-loops\")\n#pragma GCC optimize(\"-fwhole-program\")\n#pragma GCC optimize(\"-freorder-blocks\")\n#pragma GCC optimize(\"-fschedule-insns\")\n#pragma GCC optimize(\"inline-functions\")\n#pragma GCC optimize(\"-ftree-tail-merge\")\n#pragma GCC optimize(\"-fschedule-insns2\")\n#pragma GCC optimize(\"-fstrict-aliasing\")\n#pragma GCC optimize(\"-fstrict-overflow\")\n#pragma GCC optimize(\"-falign-functions\")\n#pragma GCC optimize(\"-fcse-skip-blocks\")\n#pragma GCC optimize(\"-fcse-follow-jumps\")\n#pragma GCC optimize(\"-fsched-interblock\")\n#pragma GCC optimize(\"-fpartial-inlining\")\n#pragma GCC optimize(\"no-stack-protector\")\n#pragma GCC optimize(\"-freorder-functions\")\n#pragma GCC optimize(\"-findirect-inlining\")\n#pragma GCC optimize(\"-fhoist-adjacent-loads\")\n#pragma GCC optimize(\"-frerun-cse-after-loop\")\n#pragma GCC optimize(\"inline-small-functions\")\n#pragma GCC optimize(\"-finline-small-functions\")\n#pragma GCC optimize(\"-ftree-switch-conversion\")\n#pragma GCC optimize(\"-foptimize-sibling-calls\")\n#pragma GCC optimize(\"-fexpensive-optimizations\")\n#pragma GCC optimize(\"-funsafe-loop-optimizations\")\n#pragma GCC optimize(\"inline-functions-called-once\")\n#pragma GCC optimize(\"-fdelete-null-pointer-checks\")\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <iomanip>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <cstdint>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n#define MP make_pair\n#define PB push_back\n#define inf 1000000007\n#define rep(i,n) for(int i = 0; i < (int)(n); ++i)\n#define all(x) (x).begin(),(x).end()\n\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val){\n    std::fill( (T*)array, (T*)(array+N), val );\n}\n \ntemplate<class T> inline bool chmax(T &a, T b){\n    if(a<b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T> inline bool chmin(T &a, T b){\n    if(a>b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<typename T>\nT gcd(T a, T b)\n{\n    return b ? gcd(b, a % b) : a;\n}\n\ntemplate<typename T>\nT lcm(T a,T b)\n{\n    return  a / gcd(a,b) * b;\n}\nclass UnionFind {\nprivate:\n    int sz;\n    vector<int> par, size_;\npublic:\n    UnionFind(){}\n    UnionFind(int node_size) : sz(node_size), par(sz), size_(sz, 1){\n        iota(par.begin(), par.end(), 0);\n    }\n    int find(int x){\n        if(par[x] == x) return x;\n        else return par[x] = find(par[x]);\n    }\n    void unite(int x,int y){\n        x = find(x), y = find(y);\n        if(x == y) return;\n        if(size_[x] < size_[y]) swap(x,y);\n        par[y] = x;\n        size_[x] += size_[y];\n    }\n    int size(int x){\n        x = find(x);\n        return size_[x];\n    }\n    bool same(int x,int y){\n        return find(x) == find(y);\n    }\n};\ntemplate<class _Key, class _Hash, bool DOWNSIZE> class UnorderedSetIterator;\n \ntemplate<class _Key, class _Hash = hash<_Key>, bool DOWNSIZE = false>\nclass UnorderedSet\n{\nprivate:\n    using iterator = UnorderedSetIterator<_Key, _Hash, DOWNSIZE>;\n    friend UnorderedSetIterator<_Key, _Hash, DOWNSIZE>;\n    struct bucket {\n        _Key _key;\n        short int _dist;\n        bool _last, _end;\n        bucket() noexcept : _dist(-1), _last(false), _end(false){}\n        bucket& operator=(const bucket& another) = default;\n        ~bucket(){ if(!empty()) _key.~_Key(); }\n        inline void clear() noexcept { _dist = -1; }\n        inline void _delete(){ _dist = -1, _key.~_Key(); }\n        inline bool empty() const noexcept { return (_dist == -1); }\n    };\n    inline static unsigned int ceilpow2(unsigned int u) noexcept {\n        --u, u |= u >> 1, u |= u >> 2, u |= u >> 4, u |= u >> 8;\n        return (u | (u >> 16)) + 1;\n    }\n    inline static bucket *increment(bucket *cur) noexcept {\n        for(++cur; !cur->_end; ++cur){\n            if(!cur->empty()) break;\n        }\n        return cur;\n    }\n    inline bucket *next_bucket(bucket *cur) const noexcept {\n        return cur->_last ? _buckets : cur + 1;\n    }\n    inline unsigned int make_hash(const _Key& key) const noexcept {\n        return _Hash()(key);\n    }\n    inline float load_rate() const noexcept {\n        return (float)_data_count / _bucket_count;\n    }\n    bucket *insert(bucket *cur, short int dist, _Key&& key){\n        bucket *ret = cur;\n        bool flag = false;\n        while(true){\n            if(cur->empty()){\n                cur->_key = move(key), cur->_dist = dist;\n                if(!flag) ret = cur, flag = true;\n                break;\n            }else if(dist > cur->_dist){\n                swap(key, cur->_key), swap(dist, cur->_dist);\n                if(!flag) ret = cur, flag = true;\n            }\n            ++dist;\n            cur = next_bucket(cur);\n        }\n        return ret;\n    }\n    bucket *_find(const _Key& key) const {\n        bucket *cur = _buckets + (make_hash(key) & _mask);\n        int dist = 0;\n        while(dist <= cur->_dist){\n            if(key == cur->_key) return cur;\n            ++dist, cur = next_bucket(cur);\n        }\n        return _buckets + _bucket_count;\n    }\n    template<class Key>\n    bucket *find_insert(Key&& key){\n        unsigned int hash = make_hash(key);\n        bucket *cur = _buckets + (hash & _mask);\n        int dist = 0;\n        while(dist <= cur->_dist){\n            if(key == cur->_key) return cur;\n            ++dist, cur = next_bucket(cur);\n        }\n        ++_data_count;\n        if(rehash_check()){\n            cur = _buckets + (hash & _mask), dist = 0;\n        }\n        _Key new_key = forward<Key>(key);\n        return insert(cur, dist, move(new_key));\n    }\n    bucket *backward_shift(bucket *cur, bool next_ret){\n        bucket *next = next_bucket(cur), *ret = cur;\n        if(next->_dist < 1) return next_ret ? increment(cur) : cur;\n        do {\n            cur->_key = next->_key, cur->_dist = next->_dist - 1;\n            cur = next, next = next_bucket(cur);\n        }while(next->_dist >= 1);\n        cur->clear();\n        return ret;\n    }\n    bucket *erase_impl(bucket *cur, bool next_ret){\n        assert(static_cast<size_t>(cur - _buckets) != _bucket_count);\n        cur->_delete();\n        --_data_count;\n        return backward_shift(cur, next_ret);\n    }\n    bucket *erase_itr(bucket *cur, bool next_ret = true){\n        const _Key key = cur->_key;\n        return erase_impl(rehash_check() ? _find(key) : cur, next_ret);\n    }\n    bucket *erase_key(const _Key& key, bool next_ret = true){\n        rehash_check();\n        return erase_impl(_find(key), next_ret);\n    }\n    bool rehash_check(){\n        if(load_rate() >= MAX_LOAD_RATE){\n            rehash(_bucket_count * 2u);\n            return true;\n        }else if(DOWNSIZE){\n            if(load_rate() <= MIN_LOAD_RATE && _bucket_count >= DOWNSIZE_THRESHOLD){\n                rehash(_bucket_count / 2u);\n                return true;\n            }\n        }\n        return false;\n    }\n    void move_data(bucket *cur){\n        insert(_buckets + (make_hash(cur->_key) & _mask), 0, move(cur->_key));\n    }\n    void rehash(unsigned int new_bucket_count){\n        UnorderedSet new_unordered_set(new_bucket_count);\n        new_unordered_set._data_count = _data_count;\n        for(bucket *cur = _buckets; !cur->_end; ++cur){\n            if(!cur->empty()){\n                new_unordered_set.move_data(cur);\n            }\n        }\n        swap(*this, new_unordered_set);\n    }\n    friend void swap(UnorderedSet& ust1, UnorderedSet& ust2){\n        swap(ust1._bucket_count, ust2._bucket_count);\n        swap(ust1._mask, ust2._mask);\n        swap(ust1._data_count, ust2._data_count);\n        swap(ust1._buckets, ust2._buckets);\n    }\n \nprivate:\n    unsigned int _bucket_count, _mask, _data_count;\n    bucket *_buckets;\npublic:\n    const float MAX_LOAD_RATE = 0.5f;\n    const float MIN_LOAD_RATE = 0.1f;\n    const unsigned int DOWNSIZE_THRESHOLD = 16u;\n    UnorderedSet(unsigned int bucket_size = 1u)\n     : _bucket_count(ceilpow2(max(bucket_size, 1u))), _mask(_bucket_count - 1),\n        _data_count(0u), _buckets(new bucket[_bucket_count + 1]){\n        _buckets[_bucket_count - 1]._last = true, _buckets[_bucket_count]._end = true;\n    }\n    UnorderedSet(const UnorderedSet& another)\n        : _bucket_count(another._bucket_count), _mask(another._mask), _data_count(another._data_count){\n        _buckets = new bucket[_bucket_count + 1u];\n        for(unsigned int i = 0u; i <= _bucket_count; ++i){\n            _buckets[i] = another._buckets[i];\n        }\n    }\n    UnorderedSet(UnorderedSet&& another)\n        : _bucket_count(move(another._bucket_count)), _mask(move(another._mask)),\n            _data_count(move(another._data_count)), _buckets(another._buckets){\n        another._buckets = nullptr;\n    }\n    UnorderedSet& operator=(const UnorderedSet& another){\n        delete[] _buckets;\n        _bucket_count = another._bucket_count;\n        _mask = another._mask;\n        _data_count = another._data_count;\n        _buckets = new bucket[_bucket_count + 1u];\n        for(unsigned int i = 0u; i <= _bucket_count; ++i){\n            _buckets[i] = another._buckets[i];\n        }\n        return *this;\n    }\n    UnorderedSet& operator=(UnorderedSet&& another){\n        delete[] _buckets;\n        _bucket_count = move(another._bucket_count);\n        _mask = move(another._mask);\n        _data_count = move(another._data_count);\n        _buckets = another._buckets;\n        another._buckets = nullptr;\n        return *this;\n    }\n    ~UnorderedSet(){ delete[] _buckets; }\n    friend ostream& operator<< (ostream& os, UnorderedSet& ust) noexcept {\n        for(_Key& val : ust) os << val << \" \";\n        return os;\n    }\n    void clear(){\n        UnorderedSet new_unordered_set(1u);\n        swap(*this, new_unordered_set);\n    }\n    size_t size() const noexcept { return _data_count; }\n    size_t bucket_count() const noexcept { return _bucket_count; }\n    bool empty() const noexcept { return (_data_count == 0); }\n    iterator begin() const noexcept {\n        return _buckets->empty() ? iterator(increment(_buckets)) : iterator(_buckets);\n    }\n    iterator end() const noexcept { return iterator(_buckets + _bucket_count); }\n    iterator find(const _Key& key) const { return iterator(_find(key)); }\n    size_t count(const _Key& key) const { return (_find(key) != _buckets + _bucket_count); }\n    iterator insert(const _Key& key){ return iterator(find_insert(key)); }\n    iterator insert(_Key&& key){ return iterator(find_insert(move(key))); }\n    iterator erase(const _Key& key){ return iterator(erase_key(key)); }\n    iterator erase(const iterator& itr){ return iterator(erase_itr(itr.bucket_ptr)); }\n    void simple_erase(const _Key& key){ erase_key(key, false); }\n    void simple_erase(const iterator& itr){ erase_itr(itr.bucket_ptr, false); }\n \n    // DEBUG 用\n    short int maximum_distance() const noexcept {\n        short int ret = -1;\n        for(bucket *cur = _buckets; !cur->_end; ++cur){\n            ret = max(ret, cur->_dist);\n        }\n        return ret;\n    }\n};\n \ntemplate<class _Key, class _Hash, bool DOWNSIZE>\nclass UnorderedSetIterator {\nprivate:\n    friend UnorderedSet<_Key, _Hash, DOWNSIZE>;\n    typename UnorderedSet<_Key, _Hash, DOWNSIZE>::bucket *bucket_ptr;\n    using iterator_category = forward_iterator_tag;\n    using value_type = _Key;\n    using difference_type = ptrdiff_t;\n    using pointer = _Key*;\n    using reference = _Key&;\n \nprivate:\n    UnorderedSetIterator(typename UnorderedSet<_Key, _Hash, DOWNSIZE>::bucket *_bucket_ptr)\n        noexcept : bucket_ptr(_bucket_ptr){}\npublic:\n    UnorderedSetIterator() noexcept : bucket_ptr(){}\n    UnorderedSetIterator(const UnorderedSetIterator& itr) noexcept : bucket_ptr(itr.bucket_ptr){}\n    UnorderedSetIterator& operator=(const UnorderedSetIterator& itr)\n        & noexcept { return bucket_ptr = itr.bucket_ptr, *this; }\n    UnorderedSetIterator& operator=(const UnorderedSetIterator&& itr)\n        & noexcept { return bucket_ptr = itr.bucket_ptr, *this; }\n    reference operator*() const noexcept { return bucket_ptr->_key; }\n    pointer operator->() const noexcept { return &(bucket_ptr->_key); }\n    UnorderedSetIterator& operator++() noexcept {\n        return bucket_ptr = UnorderedSet<_Key, _Hash, DOWNSIZE>::increment(bucket_ptr), *this;\n    }\n    UnorderedSetIterator operator++(int) const noexcept {\n        return UnorderedSetIterator(UnorderedSet<_Key, _Hash, DOWNSIZE>::increment(this->bucket_ptr));\n    }\n    bool operator==(const UnorderedSetIterator& itr) const noexcept { return !(*this != itr); };\n    bool operator!=(const UnorderedSetIterator& itr) const noexcept { return bucket_ptr != itr.bucket_ptr; }\n};\n \ntemplate<class _Key, class _Tp, class _Hash, bool DOWNSIZE> class UnorderedMapIterator;\n \ntemplate<class _Key, class _Tp, class _Hash = hash<_Key>, bool DOWNSIZE = false>\nclass UnorderedMap\n{\nprivate:\n    using iterator = UnorderedMapIterator<_Key, _Tp, _Hash, DOWNSIZE>;\n    using value_type = _Tp;\n    using data_type = pair<_Key, _Tp>;\n    using aligned_pointer = typename aligned_storage<sizeof(value_type), alignof(value_type)>::type;\n    friend UnorderedMapIterator<_Key, _Tp, _Hash, DOWNSIZE>;\n    struct bucket {\n        _Key _key;\n        short int _dist;\n        bool _last, _end;\n        aligned_pointer _value_ptr;\n        bucket() noexcept : _dist(-1), _last(false), _end(false){}\n        bucket& operator=(const bucket& another) noexcept {\n            _key = another._key, _dist = another._dist, _last = another._last, _end = another._end;\n            if(!another.empty()){\n                new(&_value_ptr) value_type(*reinterpret_cast<const value_type*>(&another._value_ptr));\n            }\n            return *this;\n        }\n        ~bucket(){ if(!empty()) _delete(); }\n        inline void clear() noexcept { _dist = -1; }\n        inline void _delete(){ _dist = -1, value_ptr()->~value_type(); }\n        inline bool empty() const noexcept { return (_dist == -1); }\n        inline value_type& value() noexcept {\n            return *reinterpret_cast<value_type*>(&_value_ptr);\n        }\n        inline value_type* value_ptr() noexcept {\n            return reinterpret_cast<value_type*>(&_value_ptr);\n        }\n        inline void new_value(value_type&& value){\n            new(&_value_ptr) value_type(move(value));\n        }\n    };\n    inline static unsigned int ceilpow2(unsigned int u) noexcept {\n        --u, u |= u >> 1, u |= u >> 2, u |= u >> 4, u |= u >> 8;\n        return (u | (u >> 16)) + 1;\n    }\n    inline static bucket *increment(bucket *cur) noexcept {\n        for(++cur; !cur->_end; ++cur){\n            if(!cur->empty()) break;\n        }\n        return cur;\n    }\n    inline bucket *next_bucket(bucket *cur) const noexcept {\n        return cur->_last ? _buckets : cur + 1;\n    }\n    inline unsigned int make_hash(const _Key& key) const noexcept {\n        return _Hash()(key);\n    }\n    inline float load_rate() const noexcept {\n        return (float)_data_count / _bucket_count;\n    }\n    bucket *insert(bucket *cur, _Key&& key, short int dist, value_type&& value){\n        bucket *ret = cur;\n        bool flag = false;\n        while(true){\n            if(cur->empty()){\n                cur->_key = move(key), cur->_dist = dist, cur->new_value(move(value));\n                if(!flag) ret = cur, flag = true;\n                break;\n            }else if(dist > cur->_dist){\n                swap(key, cur->_key), swap(dist, cur->_dist), swap(value, cur->value());\n                if(!flag) ret = cur, flag = true;\n            }\n            ++dist;\n            cur = next_bucket(cur);\n        }\n        return ret;\n    }\n    template<class Key>\n    bucket *_find(Key&& key, bool push = false){\n        unsigned int hash = make_hash(key);\n        bucket *cur = _buckets + (hash & _mask);\n        short int dist = 0;\n        while(dist <= cur->_dist){\n            if(key == cur->_key) return cur;\n            ++dist, cur = next_bucket(cur);\n        }\n        if(!push) return _buckets + _bucket_count;\n        ++_data_count;\n        if(rehash_check()){\n            cur = _buckets + (hash & _mask), dist = 0;\n        }\n        value_type new_value = value_type();\n        _Key new_key = forward<Key>(key);\n        return insert(cur, move(new_key), dist, move(new_value));\n    }\n    template<class Data>\n    bucket *find_insert(Data&& data){\n        const _Key& key = data.first;\n        unsigned int hash = make_hash(key);\n        bucket *cur = _buckets + (hash & _mask);\n        short int dist = 0;\n        while(dist <= cur->_dist){\n            if(key == cur->_key) return cur;\n            ++dist, cur = next_bucket(cur);\n        }\n        ++_data_count;\n        if(rehash_check()){\n            cur = _buckets + (hash & _mask), dist = 0;\n        }\n        data_type new_data = forward<Data>(data);\n        return insert(cur, move(new_data.first), dist, move(new_data.second));\n    }\n    bucket *backward_shift(bucket *cur, bool next_ret){\n        bucket *next = next_bucket(cur), *ret = cur;\n        if(next->_dist < 1) return next_ret ? increment(cur) : cur;\n        do {\n            cur->_key = next->_key, cur->_dist = next->_dist - 1;\n            cur->new_value(move(next->value()));\n            cur = next, next = next_bucket(cur);\n        }while(next->_dist >= 1);\n        cur->clear();\n        return ret;\n    }\n    bucket *erase_impl(bucket *cur, bool next_ret){\n        assert(static_cast<size_t>(cur - _buckets) != _bucket_count);\n        cur->_delete();\n        --_data_count;\n        return backward_shift(cur, next_ret);\n    }\n    bucket *erase_itr(bucket *cur, bool next_ret = true){\n        const _Key& key = cur->_key;\n        return erase_impl(rehash_check() ? _find(key) : cur, next_ret);\n    }\n    bucket *erase_key(const _Key& key, bool next_ret = true){\n        rehash_check();\n        return erase_impl(_find(key), next_ret);\n    }\n    bool rehash_check(){\n        if(load_rate() >= MAX_LOAD_RATE){\n            rehash(_bucket_count * 2u);\n            return true;\n        }else if(DOWNSIZE){\n            if(load_rate() <= MIN_LOAD_RATE && _bucket_count >= DOWNSIZE_THRESHOLD){\n                rehash(_bucket_count / 2u);\n                return true;\n            }\n        }\n        return false;\n    }\n    void move_data(bucket *cur){\n        insert(_buckets + (make_hash(cur->_key) & _mask), move(cur->_key), 0, move(cur->value()));\n    }\n    void rehash(unsigned int new_bucket_count){\n        UnorderedMap new_unordered_map(new_bucket_count);\n        new_unordered_map._data_count = _data_count;\n        for(bucket *cur = _buckets; !cur->_end; ++cur){\n            if(!cur->empty()){\n                new_unordered_map.move_data(cur);\n            }\n        }\n        swap(*this, new_unordered_map);\n    }\n    friend void swap(UnorderedMap& ump1, UnorderedMap& ump2){\n        swap(ump1._bucket_count, ump2._bucket_count);\n        swap(ump1._mask, ump2._mask);\n        swap(ump1._data_count, ump2._data_count);\n        swap(ump1._buckets, ump2._buckets);\n    }\n \nprivate:\n    unsigned int _bucket_count, _mask, _data_count;\n    bucket *_buckets;\npublic:\n    const float MAX_LOAD_RATE = 0.5f;\n    const float MIN_LOAD_RATE = 0.1f;\n    const unsigned int DOWNSIZE_THRESHOLD = 16u;\n    UnorderedMap(unsigned int bucket_size = 1u)\n     : _bucket_count(ceilpow2(max(bucket_size, 1u))), _mask(_bucket_count - 1),\n        _data_count(0u), _buckets(new bucket[_bucket_count + 1]){\n        _buckets[_bucket_count - 1]._last = true, _buckets[_bucket_count]._end = true;\n    }\n    UnorderedMap(const UnorderedMap& another)\n        : _bucket_count(another._bucket_count), _mask(another._mask), _data_count(another._data_count){\n        _buckets = new bucket[_bucket_count + 1u];\n        for(unsigned int i = 0u; i <= _bucket_count; ++i){\n            _buckets[i] = another._buckets[i];\n        }\n    }\n    UnorderedMap(UnorderedMap&& another)\n        : _bucket_count(move(another._bucket_count)), _mask(move(another._mask)),\n            _data_count(move(another._data_count)), _buckets(another._buckets){\n        another._buckets = nullptr;\n    }\n    UnorderedMap& operator=(const UnorderedMap& another){\n        delete[] _buckets;\n        _bucket_count = another._bucket_count;\n        _mask = another._mask;\n        _data_count = another._data_count;\n        _buckets = new bucket[_bucket_count + 1u];\n        for(unsigned int i = 0u; i <= _bucket_count; ++i){\n            _buckets[i] = another._buckets[i];\n        }\n        return *this;\n    }\n    UnorderedMap& operator=(UnorderedMap&& another){\n        delete[] _buckets;\n        _bucket_count = move(another._bucket_count);\n        _mask = move(another._mask);\n        _data_count = move(another._data_count);\n        _buckets = another._buckets;\n        another._buckets = nullptr;\n        return *this;\n    }\n    ~UnorderedMap(){ delete[] _buckets; }\n    friend ostream& operator<< (ostream& os, UnorderedMap& ump) noexcept {\n        for(auto val : ump) os << '{' << val.first << ',' << val.second << \"} \";\n        return os;\n    }\n    _Tp& operator[](const _Key& key){ return _find(key, true)->value(); }\n    _Tp& operator[](_Key&& key){ return _find(move(key), true)->value(); }\n    const _Tp& at(const _Key& key){\n        bucket *res = _find(key);\n        if(res == _buckets + _bucket_count) __throw_out_of_range(__N(\"Unordered_Map::at\"));\n        return res->value();\n    }\n    void clear(){\n        UnorderedMap new_unordered_map(1u);\n        swap(*this, new_unordered_map);\n    }\n    size_t size() const noexcept { return _data_count; }\n    size_t bucket_count() const noexcept { return _bucket_count; }\n    bool empty() const noexcept { return (_data_count == 0); }\n    iterator begin() const noexcept { return _buckets->empty() ? iterator(increment(_buckets)) : iterator(_buckets); }\n    iterator end() const noexcept { return iterator(_buckets + _bucket_count); }\n    iterator find(const _Key& key){ return iterator(_find(key)); }\n    iterator insert(const data_type& data){ return iterator(find_insert(data)); }\n    iterator insert(data_type&& data){ return iterator(find_insert(move(data))); }\n    iterator erase(const _Key& key){ return iterator(erase_key(key)); }\n    iterator erase(const iterator& itr){ return iterator(erase_itr(itr.bucket_ptr)); }\n    void simple_erase(const _Key& key){ erase_key(key, false); }\n    void simple_erase(const iterator& itr){ erase_itr(itr.bucket_ptr, false); }\n \n    // DEBUG 用\n    short int maximum_distance() const noexcept {\n        short int ret = -1;\n        for(bucket *cur = _buckets; !cur->_end; ++cur){\n            ret = max(ret, cur->_dist);\n        }\n        return ret;\n    }\n};\n \ntemplate<class _Key, class _Tp, class _Hash, bool DOWNSIZE>\nclass UnorderedMapIterator {\nprivate:\n    friend UnorderedMap<_Key, _Tp, _Hash, DOWNSIZE>;\n    typename UnorderedMap<_Key, _Tp, _Hash, DOWNSIZE>::bucket *bucket_ptr;\n    using iterator_category = forward_iterator_tag;\n    using value_type = pair<const _Key, _Tp>;\n    using difference_type = ptrdiff_t;\n    using reference = pair<const _Key&, _Tp&>;\n \nprivate:\n    UnorderedMapIterator(typename UnorderedMap<_Key, _Tp, _Hash, DOWNSIZE>::bucket *_bucket_ptr)\n        noexcept : bucket_ptr(_bucket_ptr){}\npublic:\n    UnorderedMapIterator() noexcept : bucket_ptr(){}\n    UnorderedMapIterator(const UnorderedMapIterator& itr) noexcept : bucket_ptr(itr.bucket_ptr){}\n    UnorderedMapIterator& operator=(const UnorderedMapIterator& itr)\n        & noexcept { return bucket_ptr = itr.bucket_ptr, *this; }\n    UnorderedMapIterator& operator=(const UnorderedMapIterator&& itr)\n        & noexcept { return bucket_ptr = itr.bucket_ptr, *this; }\n    reference operator*() const noexcept { return {bucket_ptr->_key, bucket_ptr->value()}; }\n    UnorderedMapIterator& operator++() noexcept {\n        return bucket_ptr = UnorderedMap<_Key, _Tp, _Hash, DOWNSIZE>::increment(bucket_ptr), *this;\n    }\n    UnorderedMapIterator operator++(int) const noexcept {\n        return UnorderedMapIterator(UnorderedMap<_Key, _Tp, _Hash, DOWNSIZE>::increment(this->bucket_ptr));\n    }\n    bool operator==(const UnorderedMapIterator& itr) const noexcept { return !(*this != itr); };\n    bool operator!=(const UnorderedMapIterator& itr) const noexcept { return bucket_ptr != itr.bucket_ptr; }\n};\n \n// 多重辺は無いと仮定する\nclass BSTNode {\npublic:\n    struct murmur_hash32 {\n        unsigned int operator()(int p) const {\n            const unsigned int m = 0x5bd1e995; p *= m;\n            unsigned int h = (p^(p>>24))*m;\n            return h = (h^(h>>13))*m, (h^(h>>15));\n        }\n    };\n    const int from, to;\n    int sz;\n    bool subtree_edge, subofftree_edge, exact_level;\n    BSTNode *left, *right, *par;\n    UnorderedSet<int, murmur_hash32, true> adjacent;\n    BSTNode(const int _ver) noexcept :\n        from(_ver), to(_ver), sz(0), subtree_edge(false), subofftree_edge(false),\n            exact_level(false), left(nullptr), right(nullptr), par(nullptr){}\n    BSTNode(const int _from, const int _to, const bool _flag) noexcept :\n        from(_from), to(_to), sz(0), subtree_edge(false), subofftree_edge(false),\n            exact_level((from < to) && _flag), left(nullptr), right(nullptr), par(nullptr){}\n    inline bool IsRoot() const noexcept { return !par; }\n    inline bool IsVertex() const noexcept { return (from == to); }\n    inline void eval() noexcept {\n        if(IsVertex()) sz = 1, subtree_edge = false, subofftree_edge = !adjacent.empty();\n        else sz = 0, subtree_edge = exact_level, subofftree_edge = false;\n        if(left){\n            sz += left->sz, subtree_edge |= left->subtree_edge, subofftree_edge |= left->subofftree_edge;\n        }\n        if(right){\n            sz += right->sz, subtree_edge |= right->subtree_edge, subofftree_edge |= right->subofftree_edge;\n        }\n    }\n    inline void subtree_edge_eval(){\n        subtree_edge = exact_level;\n        if(left) subtree_edge |= left->subtree_edge;\n        if(right) subtree_edge |= right->subtree_edge;\n    }\n    inline void subofftree_edge_eval(){\n        subofftree_edge = !adjacent.empty();\n        if(left) subofftree_edge |= left->subofftree_edge;\n        if(right) subofftree_edge |= right->subofftree_edge;\n    }\n    inline bool subofftree_check(){\n        return !adjacent.empty() ||\n                (left ? left->subofftree_edge : false) || (right ? right->subofftree_edge : false);\n    }\n    inline bool offtree_check(){\n        return adjacent.empty() ||\n                (left ? left->subofftree_edge : false) || (right ? right->subofftree_edge : false);\n    }\n    void rotate(const bool right_) noexcept {\n        BSTNode *p = par, *g = p->par;\n        if(right_){\n            if((p->left = right)) right->par = p;\n            right = p, p->par = this;\n        }else{\n            if((p->right = left)) left->par = p;\n            left = p, p->par = this;\n        }\n        p->eval(), eval();\n        if(!(par = g)) return;\n        if(g->left == p) g->left = this;\n        if(g->right == p) g->right = this;\n        g->eval();\n    }\n};\n \nBSTNode *splay(BSTNode *u) noexcept {\n    if(!u) return nullptr;\n    while(!(u->IsRoot())){\n        BSTNode *p = u->par, *gp = p->par;\n        if(p->IsRoot()){ // zig\n            u->rotate((u == p->left));\n        }else{\n            bool flag = (u == p->left);\n            if((u == p->left) == (p == gp->left)){ // zig-zig\n                p->rotate(flag), u->rotate(flag);\n            }else{ // zig-zag\n                u->rotate(flag), u->rotate(!flag);\n            }\n        }\n    }\n    return u;\n}\n \nBSTNode *join(BSTNode *root1, BSTNode *root2) noexcept {\n    if(!root1 || !root2) return root1 ? root1 : root2;\n    BSTNode *cur = nullptr, *nx = root1;\n    do{ cur = nx, nx = cur->right; }while(nx);\n    BSTNode *ver = splay(cur);\n    ver->right = root2, ver->eval(), root2->par = ver;\n    return ver;\n}\n \nclass EulerTourTree {\npublic:\n    struct murmur_hash64 {\n        unsigned long long operator()(unsigned long long p) const {\n            const unsigned long long m = 0xc6a4a7935bd1e995; p *= m;\n            unsigned long long h = (p^(p>>47))*m;\n            return h = (h^(h>>47))*m, (h^(h>>47));\n        }\n    };\n    inline static unsigned long long pair_to_ll(const int u, const int v){\n        return ((unsigned long long)(u) << 32) | v;\n    }\n    BSTNode** vertex_set;\n    UnorderedMap<unsigned long long, pair<BSTNode*, BSTNode*>, murmur_hash64> edge_set;\nprivate:\n    BSTNode *reroot(BSTNode *ver) noexcept {\n        BSTNode *res = splay(ver)->left;\n        if(!res) return ver;\n        ver->left = nullptr, ver->eval();\n        while(ver->right) ver = ver->right;\n        splay(ver), ver->right = res, ver->eval(), res->par = ver;\n        return ver;\n    }\n    void link(BSTNode *ver1, BSTNode *ver2, const bool flag) noexcept {\n        BSTNode *e1 = new BSTNode(ver1->from, ver2->from, flag);\n        BSTNode *e2 = new BSTNode(ver2->from, ver1->from, flag);\n        edge_set[pair_to_ll(ver1->from, ver2->from)] = {e1, e2};\n        join(join(reroot(ver1), e1), join(reroot(ver2), e2));\n    }\n    void cut(BSTNode *edge1, BSTNode *edge2) noexcept {\n        splay(edge1), splay(edge2);\n        BSTNode *p = edge1->par;\n        bool _right = (edge1 == edge2->right);\n        if(p != edge2){\n            _right = (p == edge2->right);\n            p->par = nullptr, edge1->rotate((edge1 == p->left));\n        }\n        if(edge1->left) edge1->left->par = nullptr;\n        if(edge1->right) edge1->right->par = nullptr;\n        if(_right){\n            if(edge2->left) edge2->left->par = nullptr;\n            join(edge2->left, edge1->right);\n        }else{\n            if(edge2->right) edge2->right->par = nullptr;\n            join(edge1->left, edge2->right);\n        }\n        // delete edge1; delete edge2;\n    }\n    bool connected(BSTNode *ver1, BSTNode *ver2) noexcept {\n        splay(ver1), splay(ver2);\n        return ver1->par;\n    }\n    int component_size(BSTNode *ver) noexcept { return splay(ver)->sz; }\npublic:\n    int V;\n    EulerTourTree(){}\n    // ~EulerTourTree(){\n    //     for(auto it : edge_set){\n    //         delete (it.second).first;\n    //         delete (it.second).second;\n    //     }\n    //     for(int i = 0; i < V; ++i) delete vertex_set[i];\n    //     delete[] vertex_set;\n    // }\n    void resize(const int node_size) noexcept {\n        V = node_size, vertex_set = new BSTNode*[V];\n        for(int i = 0; i < V; i++) vertex_set[i] = new BSTNode(i);\n    }\n    void reroot(const int node_id) noexcept { reroot(vertex_set[node_id]); }\n    void link(int node1_id, int node2_id, bool flag=true) noexcept {\n        if(node1_id > node2_id) swap(node1_id, node2_id);\n        link(vertex_set[node1_id], vertex_set[node2_id], flag);\n    }\n    void cut(int node1_id, int node2_id){\n        if(node1_id > node2_id) swap(node1_id, node2_id);\n        auto it = edge_set.find(pair_to_ll(node1_id, node2_id));\n        assert(it != edge_set.end());\n        BSTNode *edge1 = ((*it).second).first, *edge2 = ((*it).second).second;\n        edge_set.simple_erase(it);\n        cut(edge1, edge2);\n    }\n    bool connected(const int node1_id, const int node2_id) noexcept {\n        if(node1_id == node2_id) return true;\n        return connected(vertex_set[node1_id], vertex_set[node2_id]);\n    }\n    int component_size(int node_id) noexcept { return component_size(vertex_set[node_id]); }\n    void check_dfs(const BSTNode* cur) const noexcept {\n        if(cur->left) check_dfs(cur->left);\n        cout << \"{\" << (cur->from) << \",\" << (cur->to) << \"} \";\n        if(cur->right) check_dfs(cur->right);\n    }\n};\n \nclass DynamicConnectivity {\nprivate:\n    BSTNode *level_up_dfs(BSTNode *cur, const int layer) noexcept {\n        if(cur->exact_level){\n            splay(cur)->exact_level = false, cur->subtree_edge_eval();\n            detect_layer[EulerTourTree::pair_to_ll(cur->from, cur->to)]++;\n            et[layer+1].link(cur->from, cur->to);\n            return cur;\n        }\n        if(cur->left && cur->left->subtree_edge) return level_up_dfs(cur->left, layer);\n        if(cur->right && cur->right->subtree_edge) return level_up_dfs(cur->right, layer);\n        return nullptr;\n    }\n    BSTNode *search_edge_dfs\n        (BSTNode *cur, const int layer, const int another, bool& flag, pair<int, int>& rep_edge) noexcept {\n        if(!cur->adjacent.empty()){\n            bool state = et[layer+1].vertex_set[cur->from]->adjacent.empty();\n            for(auto it = cur->adjacent.begin(); it != cur->adjacent.end();){\n                pair<int, int> e = {min(cur->from, *it), max(cur->from, *it)};\n                BSTNode *correspond = et[layer].vertex_set[*it];\n                if(et[layer].connected(another, *it)){\n                    flag = true, rep_edge = e;\n                    cur->adjacent.simple_erase(it), correspond->adjacent.simple_erase(cur->from);\n                    if(!correspond->subofftree_check()){\n                        splay(correspond)->subofftree_edge_eval();\n                    }\n                    break;\n                }else{\n                    if(!et[layer+1].vertex_set[*it]->subofftree_check()){\n                        splay(et[layer+1].vertex_set[*it])->subofftree_edge = true;\n                    }\n                    et[layer+1].vertex_set[cur->from]->adjacent.insert(*it);\n                    et[layer+1].vertex_set[*it]->adjacent.insert(cur->from);\n                    detect_layer[EulerTourTree::pair_to_ll(e.first, e.second)]++;\n                    it = cur->adjacent.erase(it);\n                    correspond->adjacent.simple_erase(cur->from);\n                    if(!correspond->subofftree_check()){\n                        splay(correspond)->subofftree_edge_eval();\n                    }\n                }\n            }\n            if(state && !et[layer+1].vertex_set[cur->from]->offtree_check()){\n                splay(et[layer+1].vertex_set[cur->from])->subofftree_edge = true;\n            }\n            splay(cur)->subofftree_edge_eval();\n            return cur;\n        }\n        if(cur->left && cur->left->subofftree_edge){\n            return search_edge_dfs(cur->left, layer, another, flag, rep_edge);\n        }\n        if(cur->right && cur->right->subofftree_edge){\n            return search_edge_dfs(cur->right, layer, another, flag, rep_edge);\n        }\n        return nullptr;\n    }\n    bool replace(const int from, const int to, const int layer) noexcept {\n        if(layer < 0) return true;\n        int u, v;\n        if(et[layer].component_size(from) <= et[layer].component_size(to)) u = from, v = to;\n        else u = to, v = from;\n        BSTNode *ver = splay(et[layer].vertex_set[u]);\n        while(ver->subtree_edge) ver = level_up_dfs(ver, layer);\n        pair<int, int> rep_edge = {-1, -1};\n        bool flag = false;\n        while(ver->subofftree_edge){\n            ver = search_edge_dfs(ver, layer, v, flag, rep_edge);\n            if(flag) break;\n        }\n        if(flag){\n            et[layer].link(rep_edge.first, rep_edge.second);\n            for(int i = 0; i < layer; i++) et[i].link(rep_edge.first, rep_edge.second, false);\n            return false;\n        }else return replace(from, to, layer-1);\n    }\npublic:\n    const int V, layer_count;\n    EulerTourTree* et;\n    UnorderedMap<unsigned long long, int, EulerTourTree::murmur_hash64> detect_layer;\n    DynamicConnectivity(int node_size) noexcept : V(node_size), layer_count(ceil(log2(V))+1){\n        et = new EulerTourTree[layer_count];\n        for(int i = 0; i < layer_count; i++) et[i].resize(V);\n    }\n    // ~DynamicConnectivity(){\n    //     delete[] et;\n    // }\n    bool link(int node1_id, int node2_id) noexcept {\n        if(node1_id > node2_id) swap(node1_id, node2_id);\n        detect_layer[EulerTourTree::pair_to_ll(node1_id, node2_id)] = 0;\n        if(et[0].connected(node1_id, node2_id)){\n            BSTNode *ver1 = et[0].vertex_set[node1_id], *ver2 = et[0].vertex_set[node2_id];\n            splay(ver1)->subofftree_edge = true, ver1->adjacent.insert(node2_id);\n            splay(ver2)->subofftree_edge = true, ver2->adjacent.insert(node1_id);\n            return false;\n        }else{\n            et[0].link(node1_id, node2_id);\n            return true;\n        }\n    }\n    bool cut(int node1_id, int node2_id) noexcept {\n        if(node1_id > node2_id) swap(node1_id, node2_id);\n        auto it = detect_layer.find(EulerTourTree::pair_to_ll(node1_id, node2_id));\n        assert(it != detect_layer.end());\n        int layer = (*it).second;\n        detect_layer.simple_erase(it);\n        auto& st = et[layer].vertex_set[node1_id]->adjacent;\n        if(st.find(node2_id) == st.end()){\n            for(int i = 0; i <= layer; i++) et[i].cut(node1_id, node2_id);\n            return replace(node1_id, node2_id, layer);\n        }else{\n            et[layer].vertex_set[node1_id]->adjacent.simple_erase(node2_id);\n            if(!et[layer].vertex_set[node1_id]->subofftree_check()){\n                splay(et[layer].vertex_set[node1_id])->subofftree_edge_eval();\n            }\n            et[layer].vertex_set[node2_id]->adjacent.simple_erase(node1_id);\n            if(!et[layer].vertex_set[node2_id]->subofftree_check()){\n                splay(et[layer].vertex_set[node2_id])->subofftree_edge_eval();\n            }\n            return false;\n        }\n    }\n    bool connected(const int node1_id, const int node2_id) noexcept {\n        return et[0].connected(node1_id, node2_id);\n    }\n};\n\nint a[4000];\nvector<int> calc(pii e_min,vector<vector<int> > &g,set<int> &st,DynamicConnectivity &dc){\n    vector<int> res;\n    res.push_back(e_min.first);\n    if(st.size()==1){\n        return res;\n    }\n    int id = e_min.second;\n    vector<pii> v;\n    st.erase(id);\n    for(auto x:g[id]){\n        if(st.count(x)==1){\n            dc.cut(id,x);\n            v.push_back(MP(a[x],x));\n        }\n    }\n    sort(v.begin(),v.end());\n    vector<vector<int> > ss;\n    for(auto &x:v){\n        if(st.count(x.second)==0)continue;\n        set<int> p;\n        for(auto &y:st){\n            if(dc.connected(x.second,y)){\n                p.insert(y);\n            }\n        }\n        for(auto y:p){\n            st.erase(y);\n        }\n        ss.push_back(calc(x,g,p,dc));\n    }\n    priority_queue<pair<int,pii > > pp;\n    int m = ss.size();\n    rep(i,m){\n        pp.push(MP(ss[i][0],MP(i,0)));\n    }\n    while(!pp.empty()){\n        auto x = pp.top();\n        pp.pop();\n        res.push_back(x.first);\n        if(ss[x.second.first].size()!=x.second.second+1){\n            pp.push(MP(ss[x.second.first][x.second.second+1],MP(x.second.first,x.second.second+1)));\n        }\n    }\n    return res;\n}\n\nint main(){\n    int n;\n    cin >> n;\n    \n    rep(i,n){\n        cin >> a[i];\n    }\n    DynamicConnectivity dc(n);\n    vector<vector<int> > g(n);\n    UnionFind uf(n);\n    rep(i,n){\n        for(int j=i+1;j<n;j++){\n            if(gcd(a[i],a[j])!=1){\n                g[i].push_back(j);\n                g[j].push_back(i);\n                dc.link(i,j);\n                uf.unite(i,j);\n            }\n        }\n    }\n    vector<pair<int,int> > p(n,MP(inf,inf));\n    vector<set<int> > st(n);\n    rep(i,n){\n        p[uf.find(i)] = min(MP(a[i],i),p[uf.find(i)]);\n        st[uf.find(i)].insert(i);\n    }\n    vector<bool> used(n);\n    vector<vector<int> > res;\n    rep(i,n){\n        if(!used[uf.find(i)]){\n            int k = uf.find(i);\n            used[k] = 1;\n            auto ss = p[k];\n            res.push_back(calc(ss,g,st[k],dc));\n        }\n    }\n    priority_queue<pair<int,pii > > pp;\n    int m = res.size();\n    rep(i,m){\n        pp.push(MP(res[i][0],MP(i,0)));\n    }\n    vector<int> ans;\n    while(!pp.empty()){\n        auto x = pp.top();\n        pp.pop();\n        ans.push_back(x.first);\n        if(res[x.second.first].size()!=x.second.second+1){\n            pp.push(MP(res[x.second.first][x.second.second+1],MP(x.second.first,x.second.second+1)));\n        }\n    }\n    for(auto x:ans){\n        cout << x << \" \";\n    }\n    cout << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef double db;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> pa;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\n#define w1 first\n#define ls (x<<1)\n#define w2 second\n#define rs (x<<1|1)\n#define mp make_pair\n#define pb push_back\n#define mid ((l+r)>>1)\n#define SZ(x) (int((x).size()))\n#define rep(i,a,b) for(int (i)=(a);(i)<=(b);(i)++)\n#define rep2(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define per(i,a,b) for(int (i)=(a);(i)>=(b);(i)--)\n#define Rep(p,x) for(int (p)=head[(x)];(p);(p)=nxt[(p)])\n#define Rep2(p,x) for(int (p)=cur[(x)];(p);(p)=nxt[(p)])\ntemplate<class T>void read(T&num){\n\tnum=0;T f=1;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9')num=num*10+ch-'0',ch=getchar();\n\tnum*=f;\n}\nconst int maxn=2e3+5;\nint n;\nint a[maxn],vis[maxn],dep[maxn];\nvector<int>e[maxn];\npriority_queue<int>A;\nint getgcd(int x,int y){\n\treturn !x?y:getgcd(y%x,x);\n}\nvoid dfs(int x){\n\trep2(i,0,SZ(e[x]))if(!dep[e[x][i]])dep[e[x][i]]=dep[x]+1,dfs(e[x][i]);\n}\nint main(){\n\tread(n);\n\trep(i,1,n)read(a[i]);\n\tsort(a+1,a+n+1);\n\trep(i,1,n)rep(j,i+1,n)if(getgcd(a[i],a[j])!=1)e[i].pb(j),e[j].pb(i);\n\trep(i,1,n)if(!dep[i])dep[i]=1,dfs(i),A.push(i);\n\trep(i,1,n){\n\t\tint x=A.top();A.pop();\n\t\tprintf(\"%d \",a[x]);\n\t\trep2(i,0,SZ(e[x]))if(dep[e[x][i]]==dep[x]+1)A.push(e[x][i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 2010;\nconst int NN = 2010;\n\nunsigned long long one = 1;\nunsigned long long g[N][NN];\nunsigned long long was[NN];\n\nbool alive[N];\nbool can_put[N];\n\nint a[N];\nint x[N];\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", a + i);\n  }\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < n; j++) {\n      if (__gcd(a[i], a[j]) > 1) {\n        g[i][j >> 6] |= (one << (j & 63));\n        g[j][i >> 6] |= (one << (i & 63));\n      }\n    }\n  }\n  int nn = ((n - 1) >> 6) + 1;\n  for (int i = 0; i < n; i++) {\n    alive[i] = true;\n    can_put[i] = true;\n  }\n  for (int it = 0; it < n; it++) {\n    for (int i = 0; i < nn; i++) {\n      was[i] = 0;\n    }\n    for (int i = 0; i < n; i++) \n      if (!alive[i])  \n        was[i >> 6] |= (one << (i & 63));\n        \n    int best = -1;\n    for (int i = 0; i < n; i++) {\n      if (was[i >> 6] & (one << (i & 63)))\n        continue;\n    \n      int b = 0, e = 1;\n      x[0] = i;\n      was[i >> 6] |= (one << (i & 63));\n      while (b < e) {\n        for (int j = 0; j < nn; j++) \n          if ((g[x[b]][j] & was[j]) != g[x[b]][j]) \n            for (int u = j * 64; u < (j + 1) * 64; u++) \n              if (g[x[b]][u >> 6] & (one << (u & 63))) \n                if (!(was[u >> 6] & (one << (u & 63)))) {\n                  was[u >> 6] |= (one << (u & 63));\n                  x[e++] = u;\n                }\n        b++;\n      }\n      int cur = -1;\n      for (int j = 0; j < e; j++) {\n        if (!can_put[x[j]])\n          continue;\n        if (cur == -1 || a[x[j]] < a[cur])\n          cur = x[j];\n      }\n      if (best == -1 || (cur != -1 && a[cur] > a[best]))\n        best = cur;\n    }\n    if (it > 0) putchar(' ');\n    printf(\"%d\", a[best]);\n    alive[best] = false;\n    for (int i = 0; i < n; i++) {\n      if (!alive[i])  \n        continue;\n      if (g[best][i >> 6] & (one << (i & 63))) {\n        can_put[i] = true;\n      } else {\n        if (a[best] < a[i]) \n          can_put[i] = false; \n      }\n    }\n  }\n  printf(\"\\n\");\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\nThough leaves are many , the root is one.\nThrough all the lying days of my youth\nI swayed my leaves and flowers in the sun.\nNow I may wither into the truth.\n\t  \t  \t- William Butler Yeats\n*/\n//#pragma GCC optimize(\"Ofast,no-stack-protector\")\n//#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx\")\n//#pragma GCC target(\"avx,tune=native\")\n#include<bits/stdc++.h>\n//#include<ext/pb_ds/assoc_container.hpp>\nusing namespace std;\n//using namespace __gnu_pbds;\nconst int inf=0x3f3f3f3f;\nconst double eps=1e-6;\nconst int mod=1000000007;\ntypedef long long ll;\n#ifndef LOCAL\n#define cerr if(0)cout\n#endif\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\ninline string getstr(string &s,int l,int r){string ret=\"\";for(int i=l;i<=r;i++)ret.push_back(s[i]);return ret;}\nint modpow(int x,int y,int md=mod){if(y==0)return 1;int ret=modpow(x,y>>1,md);ret=(ll)ret*ret%md;if(y&1)ret=(ll)ret*x%md;return ret;}\nvector<int>g[2005];\nint nn,n;\nint a[2005],deg[2005];\nbool used[2005],ban[2005];\nvector<vector<int> >seq;\nint pos[2005];\nint main(){\n\tcin>>nn;n=nn;\n\tfor(int i=1;i<=nn;i++)cin>>a[i];\n\tsort(a+1,a+nn+1);reverse(a+1,a+nn+1);\n\twhile(n&&a[n]==1)n--;\n\treverse(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=i+1;j<=n;j++){\n\t\t\tif(__gcd(a[i],a[j])>1){\n\t\t\t\tg[i].push_back(j);\n\t\t\t\tg[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tif(!used[i]){\n\t\t\tmemset(ban,0,sizeof ban);\n\t\t\tvector<int>Have;set<int>can_reach;\n\t\t\tHave.push_back(i);ban[i]=1;\n\t\t\tfor(auto x:g[i])can_reach.insert(x);\n\t\t\twhile(can_reach.size()){\n\t\t\t\tint x=*can_reach.begin();\n\t\t\t\tHave.push_back(x);\n\t\t\t\tcan_reach.erase(x);ban[x]=1;\n\t\t\t\tfor(auto to:g[x])if(!ban[to])can_reach.insert(to);\n\t\t\t}\n\t\t\tfor(auto x:Have)used[x]=1;\n\t\t\tseq.push_back(Have);\n\t\t}\n\t}\n\tfor(int itr=1;itr<=n;itr++){\n\t\tint best=-inf,p=-1;\n\t\tfor(int j=0;j<seq.size();j++){\n\t\t\tif(pos[j]!=seq[j].size()){\n\t\t\t\tif(seq[j][pos[j]]>best){\n\t\t\t\t\tbest=seq[j][pos[j]];\n\t\t\t\t\tp=j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpos[p]++;\n\t\tcout<<a[best]<<\" \";\n\t}\n\tfor(int i=n+1;i<=nn;i++)cout<<1<<\" \";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define all(x)  x.begin(), x.end()\n#define mp      make_pair\n\nvector<int> g[2020];\nint used[2020];\nvector<int> a;\nvector<int> tmp;\n\nvoid dfs(int v) {\n        used[v] = true;\n        tmp.push_back(a[v]);\n        //vector<pair<int, int>> p;\n        //for (auto u : g[v]) if (u != prev) p.emplace_back(a[u], u);\n        //sort(all(p));\n        //for (auto u : p) {\n        //        if (!used[u.second]) {\n        //                dfs(u.second, v);\n        //        }\n        //}\n        for (auto u : g[v]) if (!used[u]) {\n                dfs(u);\n        }\n}\n\nint main() {\n        int n;\n        scanf(\"%d\", &n);\n        a.resize(n);\n        for (int i = 0; i < n; i ++) scanf(\"%d\", &a[i]);\n\n        //Takahashi\n        for (int i = 0; i < n; i ++) {\n                for (int j = i + 1; j < n; j ++) {\n                        if (__gcd(a[i], a[j]) != 1) {\n                                g[i].push_back(j);\n                                g[j].push_back(i);\n                        }\n                }\n        }\n        sort(all(a));\n        for (int i = 0; i < n; i ++) {\n                if (!used[i]) {\n                        dfs(i);\n                }\n        }\n\n        //Aoki\n        for (int i = 0; i < n; i ++) g[i].clear();\n        for (int i = 0; i < n; i ++) {\n                for (int j = i + 1; j < n; j ++) {\n                        if (__gcd(tmp[i], tmp[j]) != 1) {\n                                g[i].push_back(j);\n                        }\n                }\n        }\n        vector<int> in_cnt(n, 0);\n        for (int i = 0; i < n; i ++) {\n                for (auto u : g[i]) {\n                        in_cnt[u] ++;\n                }\n        }\n        priority_queue<pair<int, int>> pq;\n        for (int i = 0; i < n; i ++) if (in_cnt[i] == 0) pq.push(mp(tmp[i], i));\n        vector<int> ans;\n        while (!pq.empty()) {\n                auto get = pq.top();\n                pq.pop();\n                ans.push_back(get.first);\n                for (auto u : g[get.second]) {\n                        in_cnt[u] --;\n                        if (in_cnt[u] == 0) pq.push(mp(tmp[u], u));\n                }\n        }\n        for (int i = 0; i < n; i ++) cout << ans[i] << (i == n - 1 ? '\\n' : ' ');\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define For(i, j, k) for(int i = j; i <= k; i++)\n#define pb push_back\n\nusing namespace std;\n\ntypedef vector<int> VI;\n\nconst int N = 2010;\n\nint n;\nint A[N];\nvector<int> G[N];\n\nint gcd(int a, int b){\n\treturn !b ? a : gcd(b, a % b);\n}\n\nbool vis[N], used[N];\n\nvoid DFS_init(int o){\n\tvis[o] = true;\n\tFor(i, 0, n) if(!vis[i] && ((!o && A[i] == 1) || gcd(A[i], A[o]) != 1))\n\t\tG[o].pb(i), DFS_init(i);\n}\n\nVI work(int o){\n\tVI ans;\n\tfor(int v : G[o]){\n\t\tVI S = work(v), tmp;\n\t\tauto p = ans.begin(), q = S.begin();\n\n\t\twhile(p != ans.end() && q != S.end()){\n\t\t\tif(*p > *q) tmp.pb(*p), ++p;\n\t\t\telse tmp.pb(*q), ++q;\n\t\t}\n\n\t\twhile(p != ans.end()) tmp.pb(*p), ++p;\n\t\twhile(q != S.end()) tmp.pb(*q), ++q;\n\n\t\tans = tmp;\n\t}\n\tans.insert(ans.begin(), A[o]);\n\treturn ans;\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\n\tFor(i, 1, n) scanf(\"%d\", &A[i]);\n\tsort(A + 1, A + n + 1);\n\t\n\tDFS_init(0);\n\tVI ans = work(0);\n\n\tFor(i, 1, n) printf(\"%d%c\", ans[i], i == n ? '\\n' : ' ');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<stack>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<cmath>\nusing namespace std;\nint gcd(int x,int y){return (y==0)?x:gcd(y,x%y);}\nint n;\nint a[2010];\nint in[2010];\nint vis[2010];\nint ed[2010][2010];\nvector<int> e[2010];\npriority_queue<int,vector<int>,less<int> > q;\nvoid dfs(int x)\n{\n\tvis[x]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tif(!vis[i]&&ed[x][i])\n\t\t{\n\t\t\tin[i]++;\n\t\t\te[x].push_back(i);\n\t\t\tdfs(i);\n\t\t}\n}\nsigned main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\tif(gcd(a[i],a[j])!=1)\n\t\t\t\ted[i][j]=1,ed[j][i]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tif(!vis[i])\n\t\t\tdfs(i);\n\tfor(int i=1;i<=n;i++)\n\t\tif(in[i]==0)\n\t\t\tq.push(i);\n\twhile(!q.empty())\n\t{\n\t\tint u=q.top();\n\t\tq.pop();\n\t\tprintf(\"%d \",a[u]);\n\t\tfor(int i=0;i<e[u].size();i++)\n\t\t{\n\t\t\tint to=e[u][i];\n\t\t\tin[to]--;\n\t\t\tif(in[to]==0)\n\t\t\t\tq.push(to);\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nconst int MN = 2005;\n\nint N, A[MN];\nstd::vector<int> G[MN];\n\nint vis[MN];\nvoid DFS(int u) {\n\tvis[u] = 1;\n\tfor (int v = 1; v <= N; ++v)\n\t\tif (!vis[v] && std::__gcd(A[u], A[v]) > 1)\n\t\t\tG[u].push_back(v), DFS(v);\n}\n\nint main() {\n\tscanf(\"%d\", &N);\n\tfor (int i = 1; i <= N; ++i) scanf(\"%d\", &A[i]);\n\tstd::sort(A + 1, A + N + 1);\n\tstd::priority_queue<int> q;\n\tfor (int i = 1; i <= N; ++i) if (!vis[i]) DFS(i), q.push(i);\n\twhile (!q.empty()) {\n\t\tint u = q.top(); q.pop();\n\t\tprintf(\"%d \", A[u]);\n\t\tfor (int v : G[u]) q.push(v);\n\t} puts(\"\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define sqr(x) ((x)*(x))\n#define ll long long\n#define ull unsigned long long\n#define ui unsigned int\n#define ld long double\n#define vi vector<int>\n#define pii pair<int,int>\n#define pb push_back\n#define mp make_pair\n#define debuge cerr<<\"isok\"<<endl\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl\n#define SS second\n#define FF first\n#define ls (k<<1)\n#define rs (k<<1|1)\n#define inf 0x3f3f3f3f\n#define clr(a,x) memset(a,x,sizeof(a))\n#define cpy(a,x) memcpy(a,x,sizeof(a))\n#define file(x) freopen(x\".in\",\"r\",stdin),freopen(x\".out\",\"w\",stdout);\nusing namespace std;\n\nconst int N=2005,M=100005,mod=1e9+7;\ntemplate<class T> inline void gmin(T &x,const T &y){if(x>y) x=y;}\ntemplate<class T> inline void gmax(T &x,const T &y){if(x<y) x=y;}\ninline void ch(int &x,int y){x=(x+y)%mod;}\ntemplate<class T>inline void read(T &x){\n\tx=0;char ch=getchar(),rev=0;\n\twhile(ch>'9'||ch<'0') rev=(ch=='-'),ch=getchar();\n\twhile(ch>='0'&&ch<='9') x=x*10+ch-'0',ch=getchar();\n\tx=rev?-x:x;\n}\ntemplate<class T>inline void print(T x,const char c){\n\tif(!x){putchar('0');putchar(c);return;}\n\tif(x<0) putchar('-'),x=-x;\n\tint m=0,a[10];\n\twhile(x) a[m++]=x%10,x/=10;\n\twhile(m--) putchar(a[m]+'0');\n\tputchar(c);\n}\ninline int exp(int x,int y){\n\tint ans=1;\n\twhile(y){\n\t\tif(y&1) ans=(ll)ans*x%mod;\n\t\tx=(ll)x*x%mod;y>>=1;\n\t}return ans;\n}\n\nint n,a[N],du[N];\nvi g[N],b;\nbool vis[N];\npriority_queue<pii> q;\n\nvoid merge(vi &a,const vi b){\n\tvi tmp;tmp.clear();\n\tint n=a.size(),m=b.size();\n\tint x=0,y=0;\n\twhile(x<n&&y<m)\n\t\tif(a[x]>b[y]) tmp.pb(a[x++]); else tmp.pb(b[y++]);\n\twhile(x<n) tmp.pb(a[x++]);\n\twhile(y<m) tmp.pb(b[y++]);\n\ta=tmp;\n}\n\nvoid dfs(int x,vi &b){\n\tb.clear();\n\tvis[x]=1;\n\tvi tmp,tmp2;tmp.clear();\n\tfor(int i=0;i<g[x].size();i++){\n\t\tint y=g[x][i];\n\t\tif(vis[y]) continue;\n\t\tdfs(y,tmp2);merge(tmp,tmp2);\n\t}\n\tb.pb(a[x]);\n\tfor(int i=0;i<tmp.size();i++)\n\t\tb.pb(tmp[i]);\n}\n\nint main(){\n#ifdef rqgao2014\n\tfreopen(\"input.txt\",\"r\",stdin);\n#endif\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\tif(__gcd(a[i],a[j])>1) g[i].pb(j),g[j].pb(i);\n\tfor(int i=1;i<=n;i++)\n\t\tsort(g[i].begin(),g[i].end());\n\tfor(int i=1;i<=n;i++)\n\t\tif(!vis[i]){\n\t\t\tvi ans;ans.clear();\n\t\t\tdfs(i,ans);\n\t\t\tmerge(b,ans);\n\t\t}\n\tfor(int i=0;i<n;i++) print(b[i],' ');puts(\"\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC optimize(\"2\")\n\n#define ll long long\n#define reg register\n#define mk make_pair\n#define PI pair<int, int>\n#define rep(i, a, b) for(reg int i = a; i <= b; ++i)\n#define per(i, a, b) for(reg int i = a; i >= b; --i)\n\nusing namespace std;\n\n#define N 2005\n\nint n;\nint a[N], in[N];\nbool vis[N], can[N][N];\n\nvector<int> G[N];\npriority_queue<int> q;\n\nvoid Dfs(int x) {\n    vis[x] = 1;\n    rep (i, 1, n) {\n        if (!vis[i] && can[x][i]) {\n            ++in[i];\n            G[x].push_back(i);\n            Dfs(i);\n        }\n    }\n}\n\nint main() {\n    scanf (\"%d\", &n);\n    rep (i, 1, n) scanf (\"%d\", &a[i]);\n    sort(a + 1, a + n + 1);\n    rep (i, 1, n) per (j, i - 1, 1) if (__gcd(a[i], a[j]) != 1) can[i][j] = can[j][i] = 1;\n    rep (i, 1, n) if (!vis[i]) Dfs(i);\n    rep (i, 1, n) if (in[i] == 0) q.push(i);\n    while (!q.empty()) {\n        int now = q.top();\n        q.pop();\n        printf(\"%d \", a[now]);\n        int len = G[now].size();\n        rep (i, 0, len - 1) q.push(G[now][i]);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 2010;\n\nint n, a[maxn], tim;\nint _vis[maxn], _mn = 0, in[maxn], vis[maxn], fa[maxn], mn[maxn];\nvector<int> ans, vec[maxn*20];\nvector<int> prm[maxn], tot_prm;\n\nint gcd(int x, int y) {\n\tif (!y) return x;\n\treturn gcd(y, x % y);\n}\n\nvoid _dfs(int u) {\n\t_mn = min(_mn, u);\n\t_vis[u] = 1;\n\tfor (int v = 1; v <= n; v++) {\n\t\tif (gcd(a[u], a[v]) != 1 && !_vis[v]) {\n\t\t\t_dfs(v);\n\t\t}\n\t}\n}\n\nint getroot(int x) {\n\tif (x == fa[x]) return x;\n\treturn fa[x] = getroot(fa[x]);\n}\n\nvoid Union(int x, int y) {\n\tint rx = getroot(x), ry = getroot(y);\n\tif (rx != ry) {\n\t\tfa[rx] = ry;\n\t\tmn[ry] = min(mn[ry], mn[rx]);\n\t}\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n\tsort(a + 1, a + n + 1);\n\tfor (int i = 1; i <= n; i++) {\n\t\tint x = a[i];\n\t\tfor (int j = 2; j * j <= x; j++) {\n\t\t\tif (x % j == 0) {\n\t\t\t\tprm[i].push_back(j);\n\t\t\t\ttot_prm.push_back(j);\n\t\t\t\twhile (x % j == 0) {\n\t\t\t\t\tx /= j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (x > 1) {\n\t\t\tprm[i].push_back(x);\n\t\t\ttot_prm.push_back(x);\n\t\t}\n\t}\n\tsort(tot_prm.begin(), tot_prm.end());\n\ttot_prm.erase(unique(tot_prm.begin(), tot_prm.end()), tot_prm.end());\n\tfor (int i = 1; i <= n; i++) {\n\t\tfor (int j = 0; j < prm[i].size(); j++) {\n\t\t\tprm[i][j] = int (lower_bound(tot_prm.begin(), tot_prm.end(), prm[i][j]) - tot_prm.begin());\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (!_vis[i]) {\n\t\t\t_mn = n;\n\t\t\t_dfs(i);\n\t\t\tin[_mn] = 1;\n\t\t}\n\t}\n\tfor (int T = 1; T <= n; T++) {\n\t\tfor (int i = 0; i < tot_prm.size(); i++) vec[i].clear();\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tfa[i] = i;\n\t\t\tmn[i] = (in[i] ? i : 0x3f3f3f3f);\n\t\t\tif (!vis[i]) {\n\t\t\t\tfor (int j = 0; j < prm[i].size(); j++) {\n\t\t\t\t\tvec[prm[i][j]].push_back(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < tot_prm.size(); i++) {\n\t\t\tfor (int j = 0; j + 1 < vec[i].size(); j++) {\n\t\t\t\tint x = vec[i][j], y = vec[i][j+1];\n\t\t\t\tUnion(x, y);\n\t\t\t}\n\t\t}\n\t\tint mx = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (!vis[i]) {\n\t\t\t\tmx = max(mx, mn[getroot(i)]);\n\t\t\t}\n\t\t}\n\t\tvis[mx] = 1; ans.push_back(a[mx]);\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (gcd(a[mx], a[i]) != 1) {\n\t\t\t\tin[i] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < ans.size(); i++) printf(\"%d \", ans[i]);\n\tputs(\"\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,tmp,a[2005],num[2005];\nbool vis[2005];\nvector<int> topo,p,g[2005];\nvector<int> topos[2005];\nint gcd(int a,int b)\n{\n\treturn b?gcd(b,a%b):a;\n}\nbool cmp1(int i,int j)\n{\n\treturn a[i]<a[j];\n}\nbool cmp2(vector<int> v1,vector<int> v2)\n{\n\tfor(int i=0;i<min(v1.size(),v2.size());i++)\n\t\tif(v1[i]!=v2[i]) return v1[i]>v2[i];\n\treturn v1.size()>v2.size();\n}\nvoid dfs(int x)\n{\n\tnum[x]=tmp;\n\tfor(int i=0;i<g[x].size();i++)\n\t\tif(!num[g[x][i]])\n\t\t\tdfs(g[x][i]);\n}\nvoid dfstopo(int x)\n{\n\ttopo.push_back(x);\n\tvis[x]=1;\n\tfor(int i=0;i<g[x].size();i++)\n\t\tif(!vis[g[x][i]])\n\t\t\tdfstopo(g[x][i]);\n}\nint main()\n{\n\tcin>>n;\n\tfor(int i=1;i<=n;i++)\n\t\tcin>>a[i];\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\tif(gcd(a[i],a[j])!=1)\n\t\t\t{\n\t\t\t\tg[i].push_back(j);\n\t\t\t\tg[j].push_back(i);\n\t\t\t}\n\tfor(int i=1;i<=n;i++)\n\t\tsort(g[i].begin(),g[i].end(),cmp1);\n\tfor(int i=1;i<=n;i++)\n\t\tif(!num[i])\n\t\t{\n\t\t\ttmp++;\n\t\t\tdfs(i);\n\t\t}\n\tfor(int i=1;i<=tmp;i++)\n\t{\n\t\tmemset(vis,0,sizeof(vis));\n\t\ttopo.clear();\n\t\tp.clear();\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(num[j]==i)\n\t\t\t\tp.push_back(j);\n\t\tsort(p.begin(),p.end(),cmp1);\n\t\tdfstopo(p[0]);\n\t\ttopos[i]=topo;\n\t}\n\tsort(topos+1,topos+tmp+1,cmp2);\n\tfor(int i=1;i<=tmp;i++)\n\t\tfor(int j=0;j<topos[i].size();j++)\n\t\t\tcout<<a[topos[i][j]]<<' ';\n\tcout<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <cmath>\n\nusing namespace std;\n\nconst int MAXN = 100000 + 1000;\n\nint gcd(int x, int y)\n{\n\treturn x == 0 ? y : gcd(y % x, x);\n}\n\nvector<int> merge(const vector<int> &a, const vector<int> &b)\n{\n\tvector<int> ret;\n\tint i = 0, j = 0;\n\twhile(i < a.size() && j < b.size())\n\t\tret.push_back(a[i] > b[j] ? a[i++] : b[j++]);\n\twhile(i < a.size())\n\t\tret.push_back(a[i++]);\n\twhile(j < b.size())\n\t\tret.push_back(b[j++]);\n\treturn ret;\n}\n\nint n, s[MAXN];\nvector<int> ans;\nvector<int> edg[MAXN];\nbool vis[MAXN];\n\nvector<int> dfs(int x, int fa)\n{\n\tvector<int> ret;\n\tvis[x] = true;\n\tfor(int i = 0; i < edg[x].size(); i++)\n\t\tif(edg[x][i] != fa)\n\t\t{\n\t\t\tint y = edg[x][i];\n\t\t\t// cerr << x << ' ' << y << endl;\n\t\t\tif(!vis[y])\n\t\t\t\tret = merge(ret, dfs(y, x));\n\t\t}\n\tret.insert(ret.begin(), s[x]);\n\treturn ret;\n}\n\nint main()\n{\n\tios::sync_with_stdio(false);\n\t// freopen(\"1.in\", \"r\", stdin);\n\t// freopen(\"1.out\", \"w\", stdout);\n\n\tcin >> n;\n\tfor(int i = 1; i <= n; i++)\n\t\tcin >> s[i];\n\tsort(s + 1, s + n + 1);\n\tfor(int i = 1; i <= n; i++)\n\t\tfor(int j = i + 1; j <= n; j++)\n\t\t\tif(gcd(s[i], s[j]) > 1)\n\t\t\t\tedg[i].push_back(j), edg[j].push_back(i);\n\n\tans.clear();\n\tfor(int i = 1; i <= n; i++)\n\t\tif(!vis[i])\n\t\t\tans = merge(ans, dfs(i, 0));\n\tfor(int i = 1; i <= n; i++)\n\t\tcout << ans[i - 1] << ' ';\n\tcout << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define loop(i,n) for(int i = 0;i < (n);i++)\n#define all(A) A.begin(),A.end()\n#define pb push_back\n#define mp make_pair\n#define sz(A) ((int)A.size())\ntypedef std::vector<int> vi;\ntypedef std::pair<int,int> pi;\ntypedef std::vector<pi> vp;\ntypedef long long ll;\n#define popcnt(x) __builtin_popcount(x)\n#define LSOne(x) ((x) & (-(x)))\n#define print(A,t) cerr << #A << \": \"; copy(all(A),ostream_iterator<t>(cerr,\" \" )); cerr << endl\n#define prArr(A,n,t)  cerr << #A << \": \"; copy(A,A + n,ostream_iterator<t>(cerr,\" \" )); cerr << endl\n#define PRESTDIO() cin.tie(0),cerr.tie(0),ios_base::sync_with_stdio(0)\n#define what_is(x) cerr << #x << \" is \" << x << endl\n#define bit_lg(x) (assert(x > 0),__builtin_ffsll(x) - 1)\nconst double PI = acos(-1);\ntemplate<class A,class B>\nstd::ostream& operator << (std::ostream& st,const std::pair<A,B> p) {\n\tst << \"(\" << p.first << \", \" << p.second << \")\";\n\treturn st;\n}\n#define tc() int T; scanf(\"%d\",&T); for(int t = 1;t <= T;t++)\nusing namespace std;\n\n\n\n\nint main(){\n#ifdef HOME\n\tfreopen(\"in.in\", \"r\", stdin);\n#endif\n\tint n; scanf(\"%d\",&n);\n\tvi V(n);\n\tloop(i,n)scanf(\"%d\",&V[i]);\n\tsort(all(V));\n\tvi res,aux;\n\tloop(i,n){\n\t\tint prv = res.empty() ? 1 : res.back();\n\t\tint k = 0;\n\t\tfor(;k < sz(V) && __gcd(prv,V[k]) == 1;k++);\n\t\tif(k == sz(V)) k = 0;\n\t\tint y = V[k];\n\t\tV.erase(V.begin() + k);\n\t\twhile(!res.empty() && __gcd(res.back(),y) == 1) {\n\t\t\taux.push_back(res.back());\n\t\t\tres.pop_back();\n\t\t}\n\t\tres.push_back(y);\n\t\twhile(!aux.empty()){\n\t\t\tres.push_back(aux.back());\n\t\t\taux.pop_back();\n\t\t}\n\t}\n\tfor(int i = 0;i < n;i++) printf(\"%d%c\",res[i],\" \\n\"[i==n-1]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n,a[2010];\nvector<int> v[2010];\nbool vis[2010],used[2010];\nvector<int> dp[2010];\n\ninline void dfs2(int x)\n{\n\tvis[x]=1;\n\tfor(int i=0;i<v[x].size();i++) if(!used[v[x][i]]&&!vis[v[x][i]]){\n\t\tdfs2(v[x][i]);\n\t}\n}\n\ninline void dfs(int x)\n{\n\tused[x]=1;memset(vis,0,sizeof(vis));\n\tfor(int i=0;i<v[x].size();i++) if(!used[v[x][i]]&&!vis[v[x][i]]){\n\t\tdfs2(v[x][i]);\n\t\tdp[x].push_back(v[x][i]);\n\t}\n\tfor(int i=0;i<dp[x].size();i++) dfs(dp[x][i]);\n}\n\ninline void dfs3(int x)\n{\n\tif(x>0) cout<<a[x]<<\" \";\n\tfor(int i=dp[x].size()-1;i>=0;i--) dfs3(dp[x][i]);\n}\n\nsigned main()\n{\n\tios::sync_with_stdio(false);\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++){\n\t\tv[0].push_back(i);v[i].push_back(0);\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=i+1;j<=n;j++){\n\t\t\tif(__gcd(a[i],a[j])>1){\n\t\t\t\tv[i].push_back(j);\n\t\t\t\tv[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tdfs(0);\n\tdfs3(0);\n\tcout<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=2005;\nstruct que{\n\tint id,data;\n\tbool operator <(que i)const{\n\t\treturn data<i.data;\n\t}\n};\nstruct Edge{\n\tint to,nxt;\n}e[maxn*maxn];\nint n,sum=0;\nint cnt=0;\nint head[maxn];\nint a[maxn];\nint rd[maxn];\nint ans[maxn];\nbool g[maxn][maxn],vis[maxn];\nvector<int>p[maxn];\npriority_queue<que>q;\nvoid add(int u,int v){\n\trd[v]++;\n\te[cnt].to=v;\n\te[cnt].nxt=head[u];\n\thead[u]=cnt++;\n}\nvoid dfs(int x){\n\tvis[x]=1;\n\tp[cnt].push_back(a[x]);\n\tfor(int i=1;i<=n;i++){\n\t\tif(vis[i]||(!g[x][i]))continue;\n\t\tadd(x,i);\n\t\tdfs(i);\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tmemset(head,-1,sizeof(head));\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\tif(__gcd(a[i],a[j])>1)\n\t\t\t\tg[i][j]=g[j][i]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tif(!vis[i]){\n\t\t\tcnt++;\n\t\t\tdfs(i);\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tif(!rd[i]){\n\t\t\tque u;\n\t\t\tu.id=i;u.data=a[i];\n\t\t\tq.push(u);\n\t\t}\n\t}\n\twhile(!q.empty()){\n\t\tint k=q.top().id;\n\t\tprintf(\"%d \",a[k]);\n\t\tq.pop();\n\t\tfor(int i=head[k];i!=-1;i=e[i].nxt){\n\t\t\tint tmp=e[i].to;\n\t\t\trd[tmp]--;\n\t\t\tif(!rd[tmp]){\n\t\t\t\tque o;\n\t\t\t\to.id=tmp;o.data=a[tmp];\n\t\t\t\tq.push(o);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <vector>\n#include <iostream>\n#include <string.h>\n#include <set>\n#include <algorithm>\n#include <cmath>\n#include <string>\nusing namespace std;\n\ntypedef double LD;\ntypedef long long LL;\ntypedef pair<int, int> PII;\n#define MP make_pair\n#define PB push_back\n#define FOR(i,a,b) for(int i = (a); i < (b); ++i)\n#define RFOR(i,b,a) for(int i = (b) - 1; i >= (a); --i)\n#define REP(i, t) FOR(i,0,t)\n#define ALL(a) a.begin(), a.end()\n#define SZ(a) (int)((a).size())\n\nconst LL MOD = 1000000007;\nconst int INF = 1e9;\nconst LL LINF = 1LL * INF * INF;\nconst int MAXN = 2007;\nconst LD EPS = 1e-7;\n\nint n, A[MAXN], r = 0, P[MAXN];\nbool used[MAXN];\nvector <int> B[MAXN];\nbool G[MAXN][MAXN];\n\nint gcd(int a, int b)\n{\n\tif (a == 0) return b;\n\treturn gcd(b % a, a);\n}\n\nvoid dfs(int v)\n{\n\tused[v] = true;\n\tif (!B[r].empty() && !G[v][B[r][SZ(B[r]) - 1]])\n\t\t++r;\n\tB[r].push_back(v);\n\tREP(i, n)\n\t{\n\t\tif (G[v][i] && !used[i])\n\t\t\tdfs(i);\n\t}\n\t\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0);\n\t//freopen(\"In.txt\", \"r\", stdin);\n\tcin >> n;\n\tREP(i, n) cin >> A[i];\n\tsort(A, A + n);\n\tREP(i, n)\n\t{\n\t\tREP(j, i)\n\t\tif (gcd(A[i], A[j]) > 1)\n\t\t\tG[i][j] = G[j][i] = true;\n\t}\n\tREP(i, n)\n\t\tif (!used[i])\n\t\t\tdfs(i);\n\tREP(i, n)\n\t{\n\t\tint m = 0, curr;\n\t\tREP(j, r + 1)\n\t\t{\n\t\t\tif (P[j] < SZ(B[j]) && A[B[j][P[j]]] > m)\n\t\t\t{\n\t\t\t\tm = A[B[j][P[j]]];\n\t\t\t\tcurr = j;\n\t\t\t}\n\t\t}\n\t\tcout << m << ' ';\n\t\t++P[curr];\n\t}\n\t//cout << endl; system(\"pause\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int nmax = 10009;\n\nint used[nmax] , usedcrt[nmax] , x[nmax] , boss[nmax];\nvector < int > g[nmax];\nqueue < int > answer[nmax];\nvector < int > cc[nmax];\nint p , low , n , i , j , first , last;\n\nvoid dfs(int act)\n{\n    used[act] = 1;\n    cc[last].push_back(act);\n    for (int i = 0 ; i < g[act].size() ; ++i)\n    {\n        int nxt = g[act][i];\n        if (used[nxt]) continue;\n        dfs(nxt);\n    }\n}\n\nvoid mark(int act)\n{\n    usedcrt[act] = 1;\n    cc[last].push_back(act);\n    for (int i = 0 ; i < g[act].size() ; ++i)\n    {\n        int nxt = g[act][i];\n        if (usedcrt[nxt]) continue;\n        mark(nxt);\n    }\n}\n\nvoid split(int act , int whr)\n{\n    memset(usedcrt , 0 , sizeof(usedcrt));\n    vector < int > sons;\n\n    for (int i = 0 ; i < g[act].size() ; ++i)\n    {\n        int nxt = g[act][i];\n        sons.push_back(nxt);\n\n        for (int p = 0 ; p < g[nxt].size() ; ++p)\n        if (g[nxt][p] == act)\n        {\n            g[nxt].erase(g[nxt].begin() + p);\n            break;\n        }\n    }\n    g[act].clear();\n\n    for (int i = 0 ; i < sons.size() ; ++i)\n    {\n        int nxt = sons[i];\n        if (usedcrt[nxt]) continue;\n\n        ++last;\n        mark(nxt);\n        boss[last] = act;\n        answer[last] = answer[whr];\n        answer[last].push(act);\n    }\n\n\n}\n\nvoid solve(int whr)\n{\n    if (cc[whr].size() == 1)\n    {\n        answer[whr].push(cc[whr][0]);\n        return;\n    }\n\n    int forced = x[boss[whr]] , i , bst;\n    if (forced == 0)\n    {\n        bst = -1;\n        for (i = 0 ; i < cc[whr].size() ; ++i)\n        {\n            int act = cc[whr][i];\n            if (x[act] < x[bst] || bst == -1) bst = act;\n        }\n\n        split(bst , whr);\n    }\n    else\n    {\n        bst = -1;\n        for (i = 0 ; i < cc[whr].size() ; ++i)\n        {\n            int act = cc[whr][i];\n            if (1 < __gcd(forced , x[act]))\n            if (x[act] < x[bst] || bst == -1) bst = act;\n        }\n\n        split(bst , whr);\n    }\n}\n\nint main()\n{\n\n//freopen(\"test.in\" , \"r\" , stdin);\n//freopen(\"test.out\" , \"w\" , stdout);\n\nscanf(\"%d\" , &n);\n\nfor (i = 1 ; i <= n ; ++i)\nscanf(\"%d\" , &x[i]);\n\nsort(x + 1 , x + n + 1);\n\nfor (i = 1 ; i <= n ; ++i)\nfor (j = i + 1 ; j <= n ; ++j)\nif (1 < __gcd(x[i] , x[j]))\n{\n    g[i].push_back(j);\n    g[j].push_back(i);\n}\n\nfirst = 1 , last = 0;\nfor (i = 1 ; i <= n ; ++i)\n{\n    if (used[i]) continue;\n    ++last;\n    dfs(i);\n}\n\nwhile (first <= last)\n{\n    solve(first);\n    first++;\n}\n\nx[0] = -1000000000;\nfor (i = 1 ; i <= n ; ++i)\n{\n    int low = 0;\n    for (p = 1 ; p <= last ; ++p)\n    if (answer[p].size())\n    if (x[low] < x[answer[p].front()]) low = answer[p].front();\n\n    for (p = 1 ; p <= last ; ++p)\n    if (answer[p].size())\n    if (x[low] == x[answer[p].front()]) answer[p].pop();\n\n    printf(\"%d \" , x[low]);\n}\n\nreturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N=2005;\nvector<int> G[N],g[N];\nint n;\nint a[N],used[N];\npriority_queue<int> pq;\n\nint GCD(int x,int y){\n\tif(y==0) return x;\n\treturn GCD(y,x%y);\n}\n\nvoid dfs(int x){\n\tused[x]=1;\n\tfor(int i=0;i<G[x].size();i++){\n\t\tint to=G[x][i];\n\t\tif(!used[to]){\n\t\t\tg[x].push_back(to);\n\t\t\tdfs(to);\n\t\t}\n\t}\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",a+i);\n\tsort(a+1,a+1+n);\n\tfor(int i=1;i<=n;i++) for(int j=1;j<=n;j++) if(i!=j&&GCD(a[i],a[j])!=1) G[i].push_back(j);\n\tfor(int i=1;i<=n;i++) if(!used[i]){\n\t\tdfs(i);\n\t\tpq.push(i);\n\t}\n\twhile(!pq.empty()){\n\t\tint x=pq.top();\n\t\tpq.pop();\n\t\tprintf(\"%d \",a[x]);\n\t\tfor(int i=0;i<g[x].size();i++) pq.push(g[x][i]);\n\t}\n\tputs(\"\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pb push_back\n#define all(x) x.begin(), x.end()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nconst int N = 2000 + 10;\nconst int MOD = 1000000007;\nconst int LOG = 20;\nconst int INF = 1000000010;\nconst int delta = 11353;\n\nint n;\nvi G[N], a;\nmap<int, int> mp;\nint mark[N];\nint mark2[N], mark3[N];\n\nvoid DFS(int v){\n\tmark[v] = 1;\n\tfor (auto u:G[v]){\n\t\tif ((mark[u] == 0) && (mark3[u] == 0)){\n\t\t\tDFS(u);\n\t\t}\n\t}\n}\nint GCD(int x, int y){\n\tif (x == 0 || y == 0) return (x + y);\n\tif (x == 1 || y == 1) return 1;\n\tif (x < y) swap(x, y);\n\treturn GCD(y, x % y);\n}\n\nint32_t main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++){\n\t\tint x;\n\t\tcin >> x;\n\t\tmp[x] ++;\n\t\ta.pb(x);\n\t}\n\tsort(all(a));\n\ta.resize(unique(all(a)) - a.begin());\n\tfor (int i = 0; i < a.size(); i++) for (int j = 0; j < i; j++) if (GCD(a[i], a[j]) != 1){\n\t\tG[i].pb(j), G[j].pb(i);\n\t}\n\t//cout << GCD(7, 11) << '\\n';\n\tvi ans;\n\tint last = 0;\n\tn = a.size();\n\tfor (int i = 0; i < n; i++){\n\t\tif (!mark[i]){\n\t\t\tDFS(i); \n\t\t\tmark2[i] = 1;\n\t\t\t//cout << i << ' ';\n\t\t}\n\t}\n\t//cout << '\\n';\n\tfor (int i = 0; i < n; i++){\n\t\tmemset(mark, 0, sizeof mark);\n\t\tint mx = 0;\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tif (mark2[j] == 1) mx = j;\n\t\t//\tcout << j << ' ' << mark2[j] << '\\n';\n\t\t}\n\t\tans.pb(a[mx]);\n\t\tsort(all(G[mx]));\n\t\tmark2[mx] = 0;\n\t\tmark3[mx] = 1;\n\t\t//cout << mx << '\\n';\n\t\tfor (auto u:G[mx]){\n\t\t\tif ((mark3[u] == 0) && (mark[u] == 0)){\n\t\t\t\tmark2[u] = 1;\n\t\t\t\t//cout << u << '\\n';\n\t\t\t\tDFS(u);\n\t\t\t}\n\t\t}\n\t}\n\tfor (auto u:ans){\n\t\tfor (int i = 0; i < mp[u]; i++) cout << u << ' ';\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nint n;\nint a[111111],nxt[111111];\ninline int gcd(int x,int y)\n{int r=y;while(r)r=x%y,x=y,y=r;return x;}\nint g[2222][2222],fa[2222];\nbool vis[2222];\nvoid dfs(int x)\n{\n\tvis[x]=1;\n\tfor(register int i=1;i<=n;i++)\n\t{\n\t\tif(vis[i])continue;\n\t\tif(g[x][i]==1)continue;\n\t\tfa[i]=x,dfs(i);\n\t}\n}\n#include<queue>\nstd::priority_queue<int>q;\nint main()\n{\n\tscanf(\"%d\",&n);\n\tregister int i,ii;\n\tfor(i=1;i<=n;i++)\n\t\tscanf(\"%d\",a+i);\n\tstd::sort(a+1,a+n+1);\n\tfor(i=1;i<=n;i++)\n\t\tfor(ii=i+1;ii<=n;ii++)\n\t\t\tg[i][ii]=g[ii][i]=gcd(a[i],a[ii]);\n\tfor(i=1;i<=n;i++)\n\t\tif(!vis[i])dfs(i);\n\tfor(i=1;i<=n;i++)if(!fa[i])q.push(i);\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tint t=q.top();q.pop();\n\t\tprintf(\"%d%c\",a[t],(i^n)?' ':'\\n');\n\t\tfor(ii=1;ii<=n;ii++)if(fa[ii]==t)q.push(ii);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> ii;\nint n;\nint a[2005],vis[2005];\nint gcd(int a, int b){\n    return a == 0 ? b:gcd(b%a,a);\n}\nvector<int> dfs(int u){\n    vector<vector<int> > pos;\n    for (int i = 1; i <= n; i++){\n        if ((a[i] == 1 || gcd(a[u],a[i]) != 1) && vis[i] == 0){\n            //printf(\"%d -> %d: gcd(%d,%d) is %d\\n\",u,i,a[i],a[u],gcd(a[i],a[u]));\n            vis[i] = 1;\n            pos.push_back(dfs(i));\n        }\n    }\n    int NUM = pos.size();\n    int ct[NUM];\n    memset(ct,0,sizeof(ct));\n    priority_queue<ii> pq;\n    for (int i = 0; i < NUM; i++){\n        pq.push({pos[i][0],i});\n    }\n    vector<int> ans;\n    if (u != 0) ans.push_back(a[u]);\n    while (pq.size()){\n        ii cur = pq.top(); pq.pop();\n        ans.push_back(cur.first);\n        int id = cur.second;\n        if (ct[id] != pos[id].size()-1){\n            pq.push({pos[id][++ct[id]],id});\n        }\n    }\n    return ans;\n}\nint main(){\n    scanf(\"%d\",&n);\n    for (int i = 1; i <= n; i++) scanf(\"%d\",&a[i]);\n    sort(a+1,a+n+1);\n    for (auto x : dfs(0)) printf(\"%d \",x);\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\",\"inline\",\"-ffast-math\")\n#pragma GCC target(\"avx,sse2,sse3,sse4,mmx\")\n#include <bits/stdc++.h>\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/hash_policy.hpp>\nusing namespace __gnu_pbds;\nusing namespace std;\n\nint n,a[2010];\nvector<int> v[2010];\nbool vis[2010][2010],used[2010];\nvector<int> dp[2010];\n\ninline int gcd(int a,int b)\n{\n\tif(b==0) return a;\n\treturn gcd(b,a%b);\n}\n\ninline void dfs2(int u,int x)\n{\n\tvis[u][x]=1;\n\tfor(int i=0;i<v[x].size();i++) if(!used[v[x][i]]&&!vis[u][v[x][i]]){\n\t\tdfs2(u,v[x][i]);\n\t}\n}\n\ninline void dfs3(int x)\n{\n\tif(x>0) cout<<a[x]<<\" \";\n\tfor(int i=0;i<dp[x].size();i++) dfs3(dp[x][i]);\n}\n\nsigned main()\n{\n\tios::sync_with_stdio(false);\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=i+1;j<=n;j++){\n\t\t\tif(gcd(a[i],a[j])>1){\n\t\t\t\tv[i].push_back(j);\n\t\t\t\tv[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tv[0].push_back(i);v[i].push_back(0);\n\t}\n\tqueue<int> q;q.push(0);\n\twhile(!q.empty())\n\t{\n\t\tint x=q.front();q.pop();\n\t\tused[x]=1;\n\t\tfor(int i=0;i<v[x].size();i++) if(!used[v[x][i]]&&!vis[x][v[x][i]]){\n\t\t\tdfs2(x,v[x][i]);\n\t\t\tq.push(v[x][i]);\n\t\t\tdp[x].push_back(v[x][i]);\n\t\t}\n\t\treverse(dp[x].begin(),dp[x].end());\n\t}\n\tdfs3(0);\n\tcout<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nmt19937 mrand(random_device{} ()); \n\nint rnd(int x) {\n  return mrand() % x;\n}\n\ntypedef long double ld;\ntypedef long long ll;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define sz(x) ((int) (x).size())\n#define TASK \"text\"\n\nconst int inf = (int) 1.01e9;\nconst ld eps = 1e-9;\nconst ld pi = acos((ld) -1.0);\n\nconst int mod = (int) 1e9 + 7;\n\nvoid add(int &x, int y) {\n  if ((x += y) >= mod) {\n    x -= mod;\n  }\n}\n\nint mult(int x, int y) {\n  return (long long) x * y % mod;\n}\n\nint myPower(int x, int pw) {\n  int res = 1;\n  for (; pw; pw >>= 1) {\n    if (pw & 1) {\n      res = mult(res, x);\n    }\n    x = mult(x, x);\n  }\n  return res;\n}\n\nvoid precalc() {\n}\n\n\nconst int maxn = 2010;\nint a[maxn];\n\nint n;\n\nint read() {\n  if (scanf(\"%d\", &n) < 1) {\n    return 0;\n  }\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d\", a + i);\n  }\n  return 1;\n}\n\nvector<int> qs[maxn];\n\nint ans[maxn];\nint used[maxn];\n\nmap<int, int> pids;\nint cnt;\n\nint getpid(int p) {\n  auto iter = pids.find(p);\n  if (iter == pids.end()) {\n    pids[p] = cnt;\n    return cnt++;\n  }\n  return iter->second;\n}\n\nconst int maxv = maxn * 6;\nint pr[maxv], w[maxv];\n\nint get(int v) {\n  return pr[v] == v ? v : (pr[v] = get(pr[v]));\n}\n\nvoid myUnion(int a, int b) {\n  a = get(a), b = get(b);\n  if (a == b) {\n    return;\n  }\n\n  if (w[a] == w[b]) {\n    ++w[a];\n  }\n  if (w[a] < w[b]) {\n    swap(a, b);\n  }\n  pr[b] = a;\n}\n\nint last[maxv];\nint where[maxn];\n\nbool was[maxv];\n\nvoid solve() {\n  sort(a, a + n);\n\n  pids.clear();\n  cnt = 0;\n  for (int i = 0; i < n; ++i) {\n    qs[i].clear();\n\n    int x = a[i];\n    for (int p = 2; p * p <= x; ++p) {\n      if (x % p) {\n        continue;\n      }\n      while (x % p == 0) {\n        x /= p;\n      }\n      qs[i].pb(getpid(p));\n    }\n    if (x > 1) {\n      qs[i].pb(getpid(x));\n    }\n  }\n\n  for (int i = 0; i < n; ++i) {\n    used[i] = 0;\n  }\n\n  for (int i = 0; i < cnt; ++i) {\n    last[i] = -1;\n  }\n\n  for (int iter = 0; iter < n; ++iter) {\n    assert(n + cnt <= maxv);\n    for (int i = 0; i < n + cnt; ++i) {\n      pr[i] = i, w[i] = 0;\n      was[i] = 0;\n    }\n\n    for (int i = 0; i < n; ++i) {\n      if (!used[i]) {\n        for (int id : qs[i]) {\n          myUnion(i, id + n);\n        }\n      }\n    }\n\n    //eprintf(\"iter = %d\\n\", iter);\n    ans[iter] = -1;\n    int mxlow = -1;\n    for (int val = 0; val < n; ++val) {\n      if (used[val]) {\n        mxlow = max(mxlow, where[val]);\n        continue;\n      }\n      int lastb = -1;\n      for (int id : qs[val]) {\n        lastb = max(lastb, last[id]);\n      }\n      if (lastb >= mxlow) {\n        int root = get(val);\n        if (!was[root]) {\n          was[root] = 1;\n          ans[iter] = max(ans[iter], val);\n        }\n      }\n    }\n\n    assert(ans[iter] != -1);\n    used[ans[iter]] = 1;\n    where[ans[iter]] = iter;\n    for (int id : qs[ans[iter]]) {\n      last[id] = iter;\n    }\n  }\n\n  for (int i = 0; i < n; ++i) {\n    printf(\"%d%c\", a[ans[i]], \" \\n\"[i == n - 1]);\n  }\n}\n\nint main() {\n  precalc();\n#ifdef LOCAL\n  freopen(TASK \".out\", \"w\", stdout);\n  assert(freopen(TASK \".in\", \"r\", stdin));\n#endif\n\n  while (1) {\n    if (!read()) {\n      break;\n    }\n    solve();\n#ifdef DEBUG\n    eprintf(\"Time %.2f\\n\", (double) clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint Eulg(int a, int b);\n\nint main(int argc, char *argv[]){\n\n\tint N;\n\tcin>>N;\n\n\tint *a = new int[N]();\n\n\tfor(int i=0; i<N; i++){\n\t\tcin>>a[i];\n\t}\n\n\tsort(a, a+N);\n\n\tbool flag = true;\n\twhile(flag){\n\tfor(int i=0; i<N; i++){\n\t\tfor(int j=i+1; j<N; j++){\n\t\t\tif(Eulg(a[i], a[j]) == 1){\n\t\t\t\tif(a[i]<a[j]){\n\t\t\t\t\tint tmp;\n\t\t\t\t\ttmp =a[i];\n\t\t\t\t\ta[i] = b[i];\n\t\t\t\t\tb[i] = tmp;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t}\n}\n\nfor(int i=0; i<N; i++)\n\tcout<<a[i]<<\"  \";\n\n\n\n\tdelete[] a;\n\treturn 0;\n}\n\nint Eulg(int a, int b){\n\tif(a<b){\n\t\tint tmp;\n\t\ttmp =a;\n\t\ta = b;\n\t\tb = tmp;\n\t}\n\n\tint r;\n\tr = a % b;\n\twhile(r){\n\t\ta = b;\n\t\tb = r;\n\t\tr = a % b;\n\t}\n\treturn b;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\nconst int N = 2010;\n\nint gcd(int x, int y)\n{\n\treturn y ? gcd(y, x % y) : x;\n}\n\nint head[N], nxt[N * N], to[N * N], cnt;\npriority_queue<int> q;\nbool g[N][N], vis[N];\nint n, a[N], ind[N];\n\nvoid add(int u, int v)\n{\n\tnxt[++cnt] = head[u];\n\thead[u] = cnt;\n\tto[cnt] = v;\n}\n\nvoid dfs(int u)\n{\n\tvis[u] = true;\n\tfor (int v = 1; v <= n; ++v)\n\t{\n\t\tif (vis[v] || !g[u][v]) continue;\n\t\t++ind[v];\n\t\tadd(u, v);\n\t\tdfs(v);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\t\n\tfor (int i = 1; i <= n; ++i) scanf(\"%d\", a + i);\n\t\n\tsort(a + 1, a + n + 1);\n\t\n\tfor (int i = 1; i < n; ++i)\n\t{\n\t\tfor (int j = i + 1; j <= n; ++j)\n\t\t{\n\t\t\tif (gcd(a[i], a[j]) != 1)\n\t\t\t{\n\t\t\t\tg[i][j] = g[j][i] = true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int i = 1; i <= n; ++i) dfs(i);\n\t\n\tfor (int i = 1; i <= n; ++i) if (ind[i] == 0) q.push(i);\n\t\n\twhile (!q.empty())\n\t{\n\t\tint u = q.top();\n\t\tq.pop();\n\t\tprintf(\"%d \", a[u]);\n\t\tfor (int i = head[u]; i; i = nxt[i])\n\t\t{\n\t\t\tint v = to[i];\n\t\t\tif (--ind[v] == 0) q.push(v);\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#pragma GCC optimize(2)\n#define int long long\n//#include<ext/pb_ds/assoc_container.hpp>\n#pragma comment(linker, \"/STACK:16000000\")\n//#define map gp_hash_table\n#define PI 3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679\nusing namespace std;\n//using namespace __gnu_pbds;\nconst int inf=0x3f3f3f3f;\nconst long long inf2=0x3f3f3f3f3f3f3f3f;\nconst double eps=1e-6;\nconst int mod=1000000007;\nbool huzhi[2002][2002];\nint n;\npair<int,int> a[2002];\nint itr[2002];\nvector<vector<int> > vec;\nbool used[2002];\nvector<int> cur;\nvoid dfs(int x){\n\tused[x]=true;\n\tcur.push_back(a[x].first);\n\tfor(int i=1;i<=n;i++){\n\t\tif(used[i] || huzhi[i][x])continue;\n\t\tdfs(i);\n\t\treturn;\n\t}\n}\nbool ok(){\n\tfor(int i=0;i<vec.size();i++)if(itr[i]!=vec[i].size())return false;\n\treturn true;\n}\nsigned main(){\n\tvec.clear();\n\tios::sync_with_stdio(0);\n\tcin>>n;\n\tfor(int i=1;i<=n;i++)cin>>a[i].first,a[i].second=i;\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++)for(int j=1;j<=n;j++)if(__gcd(a[i].first,a[j].first)==1)huzhi[i][j]=true;\n\tfor(int i=1;i<=n;i++)if(!used[i]){\n\t\tcur.clear();\n\t\tdfs(i);\n\t\tvec.push_back(cur);\n\t}\n\tvector<int> ans;\n\twhile(!ok()){\n\t\tint mx=-1,pos=-1;\n\t\tfor(int i=0;i<vec.size();i++)if(vec[i][itr[i]]>mx)mx=vec[i][itr[i]],pos=i;\n\t\titr[pos]++;\n\t\tans.push_back(mx);\n\t}\n\tfor(int i=0;i<ans.size();i++)cout<<ans[i]<<\" \";\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<queue>\n#define N 2010\nusing namespace std;\nint nxt[N<<5],to[N<<5],head[N],cnt;\nvoid add(int u,int v)\n{\n\tnxt[++cnt]=head[u];\n\tto[cnt]=v;\n\thead[u]=cnt;\n}\nint in[N];\nbool vis[N];\nint num[N],n;\nvoid dfs(int u)\n{\n\tvis[u]=true;\n\tfor(int i=1;i<=n;i++)\n\tif(!vis[i] && __gcd(num[u],num[i])!=1)\n\t{\n\t\tadd(u,i);\n\t\tin[i]++;\n\t\tdfs(i);\n\t}\n}\npriority_queue<int>q;\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&num[i]);\n\tsort(num+1,num+n+1);\n\tfor(int i=1;i<=n;i++)\n\tif(!vis[i])dfs(i);\n\tfor(int i=1;i<=n;i++)\n\tif(!in[i]) q.push(i);\n\twhile(!q.empty())\n\t{\n\t\tint u=q.top();\n\t\tprintf(\"%d \",num[u]);\n\t\tq.pop();\n\t\tfor(int i=head[u];i;i=nxt[i])\n\t\tq.push(to[i]);\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, s, t) for(int i = (s), mi = (t); i <= mi; i++)\n#define dwn(i, s, t) for(int i = (s), mi = (t); i >= mi; i--)\n\nint read() {\n\tint x = 0, f = 1; char c = getchar();\n\twhile(!isdigit(c)){ if(c == '-') f = -1; c = getchar(); }\n\twhile(isdigit(c)){ x = x * 10 + c - '0'; c = getchar(); }\n\treturn x * f;\n}\n\n#define maxn 2010\n\nint gcd(int a, int b) { return b ? gcd(b, a % b) : a; }\n\nint n, A[maxn], G[maxn][maxn];\n\nbool vis[maxn];\nvector <int> dfs(int u) {\n\tvis[u] = 1;\n\tvector <vector <int> > As; As.clear();\n\tvector <vector <int> :: iterator> Ait; Ait.clear();\n\trep(v, 1, n) if(!vis[v] && G[v][u]) As.push_back(dfs(v)), Ait.push_back(As[As.size()-1].begin());\n\tvector <int> ans; ans.clear(); ans.push_back(u);\n\twhile(1) {\n\t\tint mx = 0, mxid = -1;\n\t\trep(i, 0, (int)Ait.size() - 1) if(Ait[i] != As[i].end()) {\n\t\t\tif(mx < *Ait[i]) mx = *Ait[i], mxid = i;\n\t\t}\n\t\tif(mxid < 0) break;\n\t\tans.push_back(mx); Ait[mxid]++;\n\t}\n\t// printf(\"dfs(%d): \", u); rep(i, 0, (int)ans.size() - 1) printf(\"%d%c\", ans[i], i < mi ? ' ' : '\\n'); if(!ans.size()) putchar('\\n');\n\treturn ans;\n}\n\nint main() {\n\tn = read();\n\trep(i, 1, n) A[i] = read();\n\t\n\tsort(A + 1, A + n + 1);\n\trep(i, 1, n) rep(j, i, n) if(gcd(A[i], A[j]) > 1) G[i][j] = G[j][i] = 1;\n\tvector <vector <int> > As; As.clear();\n\tvector <int> Ait; Ait.clear();\n\trep(i, 1, n) if(!vis[i]) As.push_back(dfs(i)), Ait.push_back(0);\n\tvector <int> ans; ans.clear();\n\twhile(1) {\n\t\tint mx = 0, mxid = -1;\n\t\trep(i, 0, (int)Ait.size() - 1) if(Ait[i] < As[i].size()) {\n\t\t\tif(mx < As[i][Ait[i]]) mx = As[i][Ait[i]], mxid = i;\n\t\t}\n\t\t// printf(\"mx: %d %d\\n\", mx, mxid);\n\t\tif(mxid < 0) break;\n\t\tans.push_back(mx); Ait[mxid]++;\n\t}\n\t\n\tassert(ans.size() == n);\n\trep(i, 0, n - 1) printf(\"%d%c\", A[ans[i]], i < mi ? ' ' : '\\n');\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint dat[2002];\nvector<int> graph[2002];\nbool visit[2005];\nint n;\n\nint gcd(int a, int b)\n{\n\treturn b ? gcd(b, a % b) : a;\n}\n\nvector<int> merge(vector<vector<int>> vvt, int head)\n{\n\tint total = 0;\n\tfor (auto &&v : vvt) total += v.size();\n\tvector<int> ret(total + (head >= 0));\n\tint ptr = 0;\n\tif (head >= 0) ret[ptr++] = head;\n\tpriority_queue<tuple<int, int, int>> pq;\n\tfor (int i = 0; i < vvt.size(); i++)\n\t{\n\t\tpq.emplace(vvt[i][0], i, 0);\n\t}\n\twhile (pq.empty() == false)\n\t{\n\t\tint val, idx, nxt;\n\t\ttie(val, idx, nxt) = pq.top();\n\t\tpq.pop();\n\t\tret[ptr++] = val;\n\n\t\tif (nxt + 1 < vvt[idx].size())\n\t\t\tpq.emplace(vvt[idx][nxt + 1], idx, nxt + 1);\n\t}\n\treturn ret;\n}\n\nvector<int> process(int t)\n{\n\tvector<vector<int>> vvt;\n\tvisit[t] = true;\n\n\tfor (int nxt : graph[t])\n\t{\n\t\tif (visit[nxt]) continue;\n\t\tvvt.emplace_back(process(nxt));\n\t}\n\n\treturn merge(vvt, t);\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &dat[i]);\n\t}\n\n\tsort(dat, dat + n);\n\n\tfor (int i = 0; i < n - 1; i++)\n\t{\n\t\tfor (int j = i + 1; j < n; j++)\n\t\t{\n\t\t\tif (gcd(dat[i], dat[j]) > 1)\n\t\t\t{\n\t\t\t\tgraph[i].push_back(j);\n\t\t\t\tgraph[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++) sort(graph[i].begin(), graph[i].end());\n\n\tvector<vector<int>> vvt;\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (visit[i]) continue;\n\t\tvvt.emplace_back(process(i));\n\t}\n\n\tauto ret = merge(vvt, -1);\n\n\tfor (int t : ret) printf(\"%d \", dat[t]);\n\tprintf(\"\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nint n,a[2005],V;\nvector<int>edge[2005];\nbool used[2005][2005],ex[2005][2005];\nint in[2005];\nvector<int>nxt;\nP q;\nvoid dfs(int v){\n\tif(used[V][v]) return; used[V][v] = 1;\n\tnxt.pb(v);\n\trep(i,edge[v].size()){\n\t\tif(used[V][edge[v][i]] || in[edge[v][i]] != V) continue;\n\t\tdfs(edge[v][i]);\n\t}\n}\nvector<int>mer(vector<int>ret,vector<int>hoge){\n\t\tint c = ret.size(),b = hoge.size();\n\t\tint i = 0,j = 0;\n\t\tvector<int>ret2; ret2.resize(c+b); int nxt = 0;\n\t\twhile(i!=c || j!=b){\n\t\t\tif(i==c) ret2[nxt++] = (hoge[j++]);\n\t\t\telse if(j==b) ret2[nxt++] = (ret[i++]);\n\t\t\telse{\n\t\t\t\tif(a[ret[i]] > a[hoge[j]]) ret2[nxt++] = (ret[i++]);\n\t\t\t\telse ret2[nxt++] = (hoge[j++]);\n\t\t\t}\n\t\t}\n\t\treturn ret2;\n}\nvector<int>make(vector<int>L,int cut){\n\tvector<int>ret;\n\tif(L.size() == 1){\n\t\tret.pb(cut); return ret;\n\t}\n\trep(i,L.size()){\n\t\tif(L[i] != cut){\n\t\t    in[L[i]] = cut;\n\t\t}\n\t}\n\tvector<pair<vector<int>,int> >vv;\n\trep(i,L.size()){\n\t\tif(L[i] == cut) continue;\n\t\tif(!used[cut][L[i]]){\n\t\t\tnxt.clear(); q = mp(INF,INF);\n\t\t\tV = cut; dfs(L[i]);\n\t\t\trep(j,nxt.size()){\n\t\t\t\tif(ex[nxt[j]][cut]){\n\t\t\t\t\tq = min(q,mp(a[nxt[j]],nxt[j]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tvv.pb(mp(nxt,q.sc));\n\t\t}\n\t}\n\trep(ii,vv.size()){\n\t\tvector<int>&nxt = vv[ii].fi; int Q = vv[ii].sc;\n\t\tvector<int>hoge = make(nxt,Q);\n\t\tret = mer(ret,hoge);\n\t}\n\tret.insert(ret.begin(),cut);\n\treturn ret;\n}\nbool U[2005];\nvector<int>vi;\nP p;\nvoid DFS(int x){\n\tif(U[x]) return; U[x] = 1;\n\tvi.pb(x); p = min(p,mp(a[x],x));\n\trep(i,edge[x].size()){\n\t\tDFS(edge[x][i]);\n\t}\n}\nvector<int>res;\nint main(){\n\tcin>>n;\n\trepn(i,n){\n\t\tcin>>a[i];\n\t}\n\tsort(a+1,a+n+1);\n\trepn(i,n) repn(j,n){\n\t\tif(i != j && __gcd(a[i],a[j]) > 1){\n\t\t\tedge[i].pb(j); ex[i][j] = 1;\n\t\t}\n\t}\n\trepn(i,n){\n\t\tif(U[i]) continue; p = mp(INF,INF); vi.clear();\n\t\tDFS(i);\n\t\tvector<int>vec = make(vi,p.sc);\n\t\tres = mer(res,vec);\n\t}\n\trep(i,n) cout<<a[res[i]]<<\" \";\n\tcout<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cstdlib>\n#include<ctime>\n#include<utility>\n#include<cmath>\n#include<functional>\n#include<queue>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\nvoid sort(int &a,int &b)\n{\n\tif(a>b)\n\t\tswap(a,b);\n}\nvoid open(const char *s)\n{\n#ifndef ONLINE_JUDGE\n\tchar str[100];\n\tsprintf(str,\"%s.in\",s);\n\tfreopen(str,\"r\",stdin);\n\tsprintf(str,\"%s.out\",s);\n\tfreopen(str,\"w\",stdout);\n#endif\n}\nint rd()\n{\n\tint s=0,c;\n\twhile((c=getchar())<'0'||c>'9');\n\tdo\n\t{\n\t\ts=s*10+c-'0';\n\t}\n\twhile((c=getchar())>='0'&&c<='9');\n\treturn s;\n}\nint upmin(int &a,int b)\n{\n\tif(b<a)\n\t{\n\t\ta=b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nint upmax(int &a,int b)\n{\n\tif(b>a)\n\t{\n\t\ta=b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nint gcd(int a,int b)\n{\n\treturn b?gcd(b,a%b):a;\n}\npriority_queue<pii> q;\nint d[2010];\nvector<int> g[2010],g2[2010];\nint a[2010];\nint b[2010];\npii c[2010];\nvoid dfs(int x)\n{\n\tb[x]=1;\n\tfor(auto v:g[x])\n\t\tif(!b[v])\n\t\t{\n\t\t\tdfs(v);\n\t\t\tg2[x].push_back(v);\n\t\t\td[v]++;\n\t\t}\n}\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tint i,j;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t\tc[i].first=a[i];\n\t\tc[i].second=i;\n\t}\n\tsort(c+1,c+n+1);\t\n\tfor(i=1;i<=n;i++)\n\t\tfor(j=1;j<=n;j++)\n\t\t\tif(gcd(a[c[i].second],a[c[j].second])!=1)\n\t\t\t\tg[c[i].second].push_back(c[j].second);\n\tfor(i=1;i<=n;i++)\n\t\tif(!b[c[i].second])\n\t\t\tdfs(c[i].second);\n\tfor(i=1;i<=n;i++)\n\t\tif(!d[i])\n\t\t\tq.push(pii(a[i],i));\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tint x=q.top().second;\n\t\tq.pop();\n\t\tprintf(\"%d \",a[x]);\n\t\tfor(auto v:g2[x])\n\t\t{\n\t\t\td[v]--;\n\t\t\tif(!d[v])\n\t\t\t\tq.push(pii(a[v],v));\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\ninline int read(){\n\tint f=1,ans=0;char c=getchar();\n\twhile(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}\n\twhile(c>='0'&&c<='9'){ans=ans*10+c-'0';c=getchar();}\n\treturn ans*f;\n}\nconst int MAXN=2001;\nvector<int> vec[MAXN];\npriority_queue<int> que;\nint N,A[MAXN],M[MAXN][MAXN],vis[MAXN],d[MAXN];\nvoid dfs(int u){\n\tvis[u]=1;\n\tfor(int i=1;i<=N;i++){\n\t\tif(!vis[i]&&M[u][i]){\n\t\t\tvec[u].push_back(i);\n\t\t\tvis[i]=1,d[i]++;dfs(i);\n\t\t}\n\t}return;\n}\nint main(){\n\tN=read();for(int i=1;i<=N;i++) A[i]=read();sort(A+1,A+N+1);\n\tfor(int i=1;i<=N;i++) for(int j=2;j<=N;j++) if(__gcd(A[i],A[j])!=1) M[i][j]=M[j][i]=1;\n\tfor(int i=1;i<=N;i++) if(!vis[i]) dfs(i);\n\tfor(int i=1;i<=N;i++) if(!d[i]) que.push(i);\n\twhile(!que.empty()){\n\t\tint xx=que.top();que.pop();printf(\"%d \",xx);\n\t\tfor(int i=0;i<vec[xx].size();i++){\n\t\t\tint v=vec[xx][i];\n\t\t\td[v]--;if(!d[v]) que.push(v);\n\t\t}\n\t}printf(\"\\n\");return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define F first\n#define S second\n#define pb push_back\n#define all(x) x.begin(), x.end()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\n\nconst int N = 2000 + 10;\nconst int MOD = 1000000007;\nconst int LOG = 20;\nconst int INF = 1000000010;\nconst int delta = 11353;\n\nint n;\nvi G[N], a;\nmap<int, int> mp;\nint mark[N];\nint mark2[N];\n\nvoid DFS(int v){\n\tmark[v] = 1;\n\tfor (auto u:G[v]){\n\t\tif ((mark[u] == 0) && (mark2[u] == 0)){\n\t\t\tDFS(u);\n\t\t}\n\t}\n}\nint GCD(int x, int y){\n\tif (x == 0 || y == 0) return (x + y);\n\tif (x == 1 || y == 1) return 1;\n\tif (x < y) swap(x, y);\n\treturn GCD(y, x % y);\n}\n\nint32_t main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tcin >> n;\n\tfor (int i = 1; i <= n; i++){\n\t\tint x;\n\t\tcin >> x;\n\t\tmp[x] ++;\n\t\ta.pb(x);\n\t}\n\tsort(all(a));\n\ta.resize(unique(all(a)) - a.begin());\n\tfor (int i = 0; i < a.size(); i++) for (int j = 0; j < i; j++) if (GCD(a[i], a[j]) != 1){\n\t\tG[i].pb(j), G[j].pb(i);\n\t}\n\t//cout << GCD(7, 11) << '\\n';\n\tvi ans;\n\tint last = 0;\n\tfor (int i = 0; i < a.size(); i++){\n\t\tmemset(mark, 0, sizeof mark);\n\t\tif (i == 0){\n\t\t\tint mx = 0;\n\t\t\tfor (int j = 0; j < a.size(); j++) if (!mark[j]) mx = j, DFS(j);\n\t\t\tmark2[mx] = 1;\n\t\t\tans.pb(a[mx]);\n\t\t\t//cout << a[mx] << endl;\n\t\t\tlast = mx;\n\t\t}else{\n\t\t\t//sort(all(G[last]));\n\t\t\tint mx = 0;\n\t\t\tfor (int j = 0; j < a.size(); j++){\n\t\t\t\tif (GCD(a[last], a[j]) == 1) continue;\n\t\t\t\tif (mark2[j] == 0){\n\t\t\t\t\tif (mark[j] == 0) mx = j, DFS(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int j = 0;  j < a.size(); j++){\n\t\t\t\tif ((mark[j] == 0) && (mark2[j] == 0)) mx = max(j, mx), DFS(j);\n\t\t\t}\n\t\t\tmark2[mx] = 1;\n\t\t\tans.pb(a[mx]);\n\t\t\tlast = mx;\n\t\t\t//cout << a[mx] << endl;\n\t\t}\n\t}\n\tfor (auto u:ans){\n\t\tfor (int i = 0; i < mp[u]; i++) cout << u << ' ';\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\n#define ref(i,x,y)for(int i=x;i<=y;++i)\nconst int N=2001;\nint n,m,_m,a[N],A[N],b[N][10],t[N*10],fa[N*10];bool v[N*10],f[N];\nbool pri(int x,int y){return y?pri(y,x%y):(x==1);}\nbool cmp(int x,int y){return b[x/10][x%10]<b[y/10][y%10];}\nint ask(int x){return fa[x]==x?x:fa[x]=ask(fa[x]);}\nvoid unite(int x,int y){x=ask(x),y=ask(y);if(y!=x)fa[y]=x;}\nint main(){\n\tscanf(\"%d\",&n);\n\tref(i,1,n)scanf(\"%d\",&a[i]);\n\tsort(a+1,a+n+1);\n\tref(i,1,n){\n\t\tint S=a[i],s=(int)sqrt(a[i]);\n\t\tref(j,2,s)if(S%j==0){\n\t\t\twhile(S%j==0)S/=j;\n\t\t\tb[i][++b[i][0]]=j;\n\t\t}\n\t\tif(S>1)b[i][++b[i][0]]=S;\n\t\tref(j,1,b[i][0])t[++m]=i*10+j;\n\t\tA[i]=a[i];a[i]=i;\n\t}\n\tsort(t+1,t+m+1,cmp);_m=n;\n\tfor(int i=1,la=-1;i<=m;++i){\n\t\tint&s=b[t[i]/10][t[i]%10];\n\t\t_m+=(s!=la);la=s;s=_m;\n\t}m=_m;\n\tref(i,1,n){\n\t\tint tot=0,p=0,ap=0;\n\t\tref(j,1,m)fa[j]=j,v[j]=0;\n\t\tref(j,i,n)ref(I,1,b[a[j]][0])\n\t\t\tunite(j,b[a[j]][I]);\n\t\tref(j,i,n)if(ask(j)==j)tot++;\n\t\tref(j,i,n)if(!v[ask(j)]&&!f[a[j]]){\n\t\t\tv[ask(j)]=1,tot--;\n\t\t\tif(tot==0){p=j;break;}\n\t\t}\n\t\tap=a[p];\n\t\tfor(int j=p;j>i;--j)a[j]=a[j-1];\n\t\ta[i]=ap;\n\t\tref(j,i+1,n){\n\t\t\tint x=A[a[i]],y=A[a[j]];\n\t\t\tif(x<y){\n\t\t\t\tf[a[j]]=pri(x,y);\n\t\t\t}else{\n\t\t\t\tf[a[j]]=f[a[j]]&&pri(x,y);\n\t\t\t}\n\t\t}\n\t}\n\tref(i,1,n)printf(\"%d \",A[a[i]]);\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\",\"inline\",\"-ffast-math\")\n#pragma GCC target(\"avx,sse2,sse3,sse4,mmx\")\n#include <bits/stdc++.h>\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/hash_policy.hpp>\nusing namespace __gnu_pbds;\nusing namespace std;\n\nint n,a[2010];\nvector<int> v[2010];\nbool vis[2010][2010],c[2010][2010],used[2010];\nvector<int> dp[2010];\n\ninline int gcd(int a,int b)\n{\n\tif(b==0) return a;\n\treturn gcd(b,a%b);\n}\n\ninline void dfs2(int u,int x)\n{\n\tfor(int i=0;i<v[x].size();i++) if(!used[v[x][i]]&&!vis[u][v[x][i]]){\n\t\tvis[u][v[x][i]]=1;\n\t\tdfs2(u,v[x][i]);\n\t}\n}\n\ninline void dfs(int x)\n{\n\tused[x]=1;\n\tvector<vector<int> > w;\n\tfor(int i=0;i<v[x].size();i++) if(!used[v[x][i]]&&!vis[x][v[x][i]]){\n\t\tvis[x][v[x][i]]=1;dfs2(x,v[x][i]);\n\t\tdfs(v[x][i]);w.push_back(dp[v[x][i]]);\n\t}\n\tdp[x].push_back(x);\n\tfor(int i=w.size()-1;i>=0;i--) for(int j=0;j<w[i].size();j++) dp[x].push_back(w[i][j]);\n}\n\nsigned main()\n{\n\tios::sync_with_stdio(false);\n\tcin>>n;\n\tfor(int i=1;i<=n;i++) cin>>a[i];\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=i+1;j<=n;j++){\n\t\t\tif(gcd(a[i],a[j])>1){\n\t\t\t\tv[i].push_back(j);\n\t\t\t\tv[j].push_back(i);\n\t\t\t\tc[i][j]=1;c[j][i]=1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tv[0].push_back(i);v[i].push_back(0);c[0][i]=1;c[i][0]=1;\n\t}\n\tdfs(0);\n\tfor(int i=1;i<dp[0].size();i++) cout<<a[dp[0][i]]<<\" \";\n\tcout<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#define maxn 2005\nusing namespace std;\ntypedef pair<int,int> PII;\nint n,a[maxn],ans[maxn],deg[maxn];\nbool G1[maxn][maxn],vis[maxn];\nvector<int> G[maxn];\npriority_queue<PII> q;\nint gcd(int a,int b)\n{\n\tif(!b) return a;\n\treturn gcd(b,a%b);\n}\nvoid dfs(int u,int fa)\n{\n\tvis[u]=true;\n\tfor(int v=1;v<=n;v++)\n\t\tif(G1[u][v]&&!vis[v])\n\t\t{\n\t\t\tG[u].push_back(v); deg[v]++;\n\t\t\tdfs(v,u);\n\t\t}\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\tif(gcd(a[i],a[j])!=1) G1[i][j]=G1[j][i]=true;\n\tfor(int i=1;i<=n;i++)\n\t\tif(!vis[i]) dfs(i,0);\n\tfor(int i=1;i<=n;i++)\n\t\tif(!deg[i]) q.push(PII(a[i],i));\n\tint cnt=0;\n\twhile(!q.empty())\n\t{\n\t\tPII u=q.top(); q.pop();\n\t\tans[++cnt]=u.first;\n\t\tfor(int i=0,siz=G[u.second].size();i<siz;i++)\n\t\t{\n\t\t\tint v=G[u.second][i]; deg[v]--;\n\t\t\tif(!deg[v]) q.push(PII(a[v],v));\n\t\t}\n\t}\n\tfor(int i=1;i<cnt;i++) printf(\"%d \",ans[i]);\n\tprintf(\"%d\\n\",ans[n]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\nstruct UnionFind{\n  Int n;\n  vector<Int> r,p;\n  UnionFind(Int x,Int y):n(x+y),r(x+y,1),p(x+y,0){\n    iota(p.begin(),p.end(),0);\n    for(Int i=0;i<x;i++) r[i]=1;\n    for(Int i=0;i<y;i++) r[x+i]=0;\n  }\n  Int find(Int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(Int x,Int y){\n    return find(x)==find(y);\n  }\n  void unite(Int x,Int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    if(r[x]<r[y]) swap(x,y);\n    r[x]+=r[y];\n    p[y]=x;\n  }\n};\n\n\ntemplate<typename T> \nmap<T, Int> factorize(T x){\n  map<T, Int> res;\n  for(Int i=2;i*i<=x;i++){\n    while(x%i==0){\n      x/=i;\n      res[i]++;\n    }\n  }\n  if(x!=1) res[x]++;\n  return res;\n}\n\n//INSERT ABOVE HERE\nInt cop[2020][2020];\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<Int> a(n);\n  for(Int i=0;i<n;i++) cin>>a[i];\n  sort(a.begin(),a.end());\n\n  vector<Int> ans(n),used(n,0),post(n,0);\n\n  memset(cop,0,sizeof(cop));\n  \n  for(Int i=0;i<n;i++)\n    for(Int j=0;j<n;j++)\n      cop[i][j]=__gcd(a[i],a[j])>1;\n\n  Int m=0;\n  map<Int, Int> r;\n\n  vector<vector<Int> > G(n);\n  for(Int i=0;i<n;i++){\n    auto x=factorize(a[i]);\n    for(auto p:x){\n      if(!r.count(p.first)) r[p.first]=m++;\n      G[i].emplace_back(r[p.first]);\n    }\n  }\n  \n  for(Int t=0;t<n;t++){\n    UnionFind uf(n,m);\n    for(Int i=0;i<n;i++)\n      if(!used[i]) for(Int j:G[i]) uf.unite(i,n+j);\n    \n    Int idx=-1,sum=t;\n    set<Int> tmp;\n    for(Int i=0;i<n;i++){\n      if(used[i]) continue;\n      Int k=uf.find(i);\n      if(!tmp.count(k)){\n\ttmp.emplace(k);\n\tsum+=uf.r[k];\n      }\n      if(post[i]) continue;\n      if(sum==n){\n\tidx=i;\n\tbreak;\n      }\n    }\n    used[idx]=1;\n    ans[t]=idx;\n    \n    for(Int i=0;i<n;i++)\n      if(cop[idx][i]) post[i]=0;\n      else if(a[idx]<a[i]) post[i]=1;\n  }\n  for(Int i=0;i<n;i++){\n    if(i) cout<<\" \";\n    cout<<a[ans[i]];\n  }\n  cout<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <set>\nint N, a[2001], G[2001][2001], q[2002], ue[2002], ref[2002], v[2001], L, d[2001];\nstd::vector < int > E[2001];\nint gcd(int a, int b)\n{\n\tint r;\n\twhile (b)\n\t{\n\t\tr = a % b;\n\t\ta = b;\n\t\tb = r;\n\t}\n\treturn a;\n}\nint main()\n{\n\tscanf(\"%d\", &N);\n\tfor (int i = 1; i <= N; i++)\n\t\tscanf(\"%d\", a + i);\n\tstd::sort(a + 1, a + N + 1);\n\tfor (int i = 1; i < N; i++)\n\t\tfor (int j = i + 1; j <= N; j++)\n\t\t\tif (gcd(a[i], a[j]) != 1)\n\t\t\t\tG[i][j] = G[j][i] = 1;\n\tfor (int i = 1; i <= N; i++)\n\t\tG[0][i] = G[i][0] = 1;\n\tint D = 1;\n\tq[1] = 0;\n\tue[1] = 0;\n\tv[0] = 1;\n\tref[L = 1] = 0;\n\twhile (D)\n\t{\n\t\twhile (ue[D] <= N && (!G[q[D]][ue[D]] || v[ue[D]]))\n\t\t\tue[D]++;\n\t\tif (ue[D] <= N)\n\t\t{\n\t\t\tint To = ue[D]++;\n\t\t\tE[q[D]].push_back(To);\n\t\t\td[To]++;\n\t\t\tq[++D] = To;\n\t\t\tue[D] = 0;\n\t\t\tv[ref[++L] = To] = 1;\n\t\t}\n\t\telse\n\t\t\tD--;\n\t}\n\tstd::vector < int > O;\n\tstd::set < int > S;\n\tfor (int i = 0; i <= N; i++)\n\t\tif (!d[i])\n\t\t\tS.insert(i);\n\twhile (!S.empty())\n\t{\n\t\tauto it = S.end();\n\t\tint u = *--it;\n\t\tS.erase(it);\n\t\tO.push_back(u);\n\t\tfor (int v : E[u])\n\t\t\tif (!--d[v])\n\t\t\t\tS.insert(v);\n\t}\n\tfor (int i : O)\n\t\tif (i)\n\t\t\tprintf(\"%d \", a[i]);\n\tputs(\"\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nconst int MAXN=2005;\n\nint gcd(int a,int b)\n{\n\tif(b==0)\n\t\treturn a;\n\treturn gcd(b,a%b);\n}\n\nint n,A[MAXN];\nbool vis[MAXN];\nvector<int> adj[MAXN],adj2[MAXN];\nint deg[MAXN],ans[MAXN];\npriority_queue<int> Q;\n\nvoid dfs(int u)\n{\n\tvis[u]=true;\n\tfor(int i=0;i<(int)adj[u].size();i++)\n\t{\n\t\tint v=adj[u][i];\n\t\tif(vis[v])\n\t\t\tcontinue;\n\t\tadj2[u].push_back(v);\n\t\tdeg[v]++;\n\t\tdfs(v);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&A[i]);\n\tsort(A+1,A+n+1);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(i!=j&&gcd(A[i],A[j])>1)\n\t\t\t\tadj[i].push_back(j);\n\tfor(int i=1;i<=n;i++)\n\t\tif(!vis[i])\n\t\t\tdfs(i);\n\t\n\tfor(int i=1;i<=n;i++)\n\t\tif(deg[i]==0)\n\t\t\tQ.push(i);\n\tint it=0;\n\twhile(!Q.empty())\n\t{\n\t\tint u=Q.top();\n\t\tans[++it]=A[u];\n\t\tQ.pop();\n\t\tfor(int i=0;i<(int)adj2[u].size();i++)\n\t\t{\n\t\t\tint v=adj2[u][i];\n\t\t\tdeg[v]--;\n\t\t\tif(deg[v]==0)\n\t\t\t\tQ.push(v);\n\t\t}\n\t}\n\t\n\tfor(int i=1;i<n;i++)\n\t\tprintf(\"%d \",ans[i]);\n\tprintf(\"%d\\n\",ans[n]);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n//#pragma comment(linker, \"/STACK:128777216\")\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cctype>\n#include <cstring>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <ctime>\n#include<complex>\nusing namespace std;\n\n#define FOR(i,a,b) for (int i = (a); i < (b); i++)\n#define RFOR(i,b,a) for (int i = (b)-1; i >= (a); i--)\n#define ITER(it,a) for (__typeof(a.begin()) it = a.begin(); it != a.end(); it++)\n#define FILL(a,value) memset(a, value, sizeof(a))\n\n#define SZ(a) (int)a.size()\n#define ALL(a) a.begin(), a.end()\n#define PB push_back\n#define MP make_pair\n\ntypedef long long LL;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\ntypedef pair<long long, long long> PLL;\n\n\nconst double PI = acos(-1.0);\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst LL LINF = INF * (LL)INF;\n\nconst int MAX = 2000 + 47;\nconst int MOD = 1000 * 1000 * 1000 + 7;\n\n//#define DEBUG\nint A[MAX];\nint IND[MAX];\n\nvector<int> g[MAX];\nint U[MAX];\nvector<int> L[MAX];\nvector<int> P;\nint sz;\n\nint gcd(int a, int b)\n{\n\treturn b == 0 ? a : gcd(b, a % b);\n}\n\nint merge(int v, vector<int> A)\n{\n\tif (v != -1)\n\t{\n\t\tL[sz].push_back(v);\n\t}\n\n\tP.assign(SZ(A), 0);\n\twhile (1)\n\t{\n\t\tint ind = -1;\n\t\tFOR(i, 0, SZ(A))\n\t\t{\n\t\t\tif (P[i] < SZ(L[A[i]]))\n\t\t\t{\n\t\t\t\tind = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (ind == -1) break;\n\t\tFOR(i, 0, SZ(A))\n\t\t{\n\t\t\tif (P[i] < SZ(L[A[i]]) && L[A[i]][P[i]] > L[A[ind]][P[ind]])\n\t\t\t{\n\t\t\t\tind = i;\n\t\t\t}\n\t\t}\n\n\t\tL[sz].push_back(L[A[ind]][P[ind]]);\n\t\tP[ind]++;\n\t}\n\n\tsz++;\n\treturn sz - 1;\n}\n\nint dfs(int v)\n{\n\tU[v] = 1;\n\tvector<int> A;\n\tFOR(i, 0, SZ(g[v]))\n\t{\n\t\tint to = g[v][i];\n\t\tif (U[to]) continue;\n\t\tA.push_back(dfs(to));\n\t}\n\n\treturn merge(v, A);\n}\n\nint main()\n{\n\t//freopen(\"in.txt\", \"r\", stdin);\n\t//freopen(\"out.txt\", \"w\", stdout);\n\t//ios::sync_with_stdio(false); cin.tie(0);\n\tint n;\n\tcin >> n;\n\tFOR(i, 0, n)\n\t{\n\t\tcin >> A[i];\n\t}\n\n\tsort(A, A + n);\n\tFOR(i, 0, n)\n\t{\n\t\tFOR(j, 0, n)\n\t\t{\n\t\t\tif (i == j) continue;\n\t\t\tif (gcd(A[i], A[j]) == 1) continue;\n\t\t\tg[i].push_back(j);\n\t\t}\n\t}\n\n\tFOR(i, 0, n)\n\t{\n\t\tsort(ALL(g[i]));\n\t}\n\n#ifdef DEBUG\n\tcout << \"B=\" << endl;\n\tFOR(i, 0, n)\n\t{\n\t\tcout << A[i] << \" \";\n\t}\n\tcout << endl;\n\tcout << \"g=\" << endl;\n\tFOR(i, 0, n)\n\t{\n\t\tcout << i << \": \";\n\t\tFOR(j, 0, SZ(g[i])) cout << g[i][j] << \" \";\n\t\tcout << endl;\n\t}\n#endif\n\tvector<int> D;\n\tFOR(i, 0, n)\n\t{\n\t\tif (!U[i])\n\t\t{\n\t\t\tD.push_back(dfs(i));\n\t\t}\n\t}\n\n\tint p = merge(-1, D);\n\tFOR(i, 0, SZ(L[p]))\n\t{\n\t\tint ind = L[p][i];\n\t\tcout << A[ind] << \" \";\n\t}\n\n\tcout << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <cctype>\n#include <queue>\n#include <algorithm>\nusing namespace std;\ntypedef long long lint;\n#define cout cerr\n#define ni (next_num<int>())\ntemplate<class T>inline T next_num(){\n\tT i=0;char c;\n\twhile(!isdigit(c=getchar())&&c!='-');\n\tbool flag=c=='-';\n\tflag?c=getchar():0;\n\twhile(i=i*10-'0'+c,isdigit(c=getchar()));\n\treturn flag?-i:i;\n}\ntemplate<class T1,class T2>inline void apmax(T1 &a,const T2 &b){if(a<b)a=b;}\ntemplate<class T1,class T2>inline void apmin(T1 &a,const T2 &b){if(b<a)a=b;}\nconst int N=2010;\nint gcd(int a,int b){\n\treturn b?gcd(b,a%b):a;\n}\nbool con[N][N];\nint n,a[N];\nstruct cmp2{\n\tinline bool operator () (int x,int y){\n\t\treturn a[x]<a[y];\n\t}\n};\nint dfn[N],tim=0;\nint lst[N];\nvoid dfs(int x){\n\tdfn[x]=++tim;\n\tfor(int i=1,v;i<=n;i++){\n\t\tif(dfn[v=lst[i]]==0&&con[x][v]){\n\t\t\tdfs(v);\n\t\t}\n\t}\n}\nint deg[N];\ninline void topsort(){\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif(con[i][j]&&dfn[i]<dfn[j]){\n\t\t\t\tdeg[j]++;\n\t\t\t}\n\t\t}\n\t}\n\tpriority_queue<int,vector<int>,cmp2>q;\n\tfor(int i=1;i<=n;i++){\n\t\tif(deg[i]==0){\n\t\t\tq.push(i);\n\t\t}\n\t}\n\twhile(!q.empty()){\n\t\tint x=q.top();\n\t\tq.pop();\n\t\tprintf(\"%d \",a[x]);\n\t\tfor(int v=1;v<=n;v++){\n\t\t\tif(con[x][v]&&dfn[x]<dfn[v]&&(--deg[v])==0){\n\t\t\t\tq.push(v);\n\t\t\t}\n\t\t}\n\t}\n}\ninline bool lcmp(int x,int y){\n\treturn a[x]<a[y];\n}\nint main(){\n\tn=ni;\n\tfor(int i=1;i<=n;i++){\n\t\ta[i]=ni;\n\t\tlst[i]=i;\n\t}\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tcon[i][j]=gcd(a[i],a[j])!=1;\n\t\t}\n\t}\n\tsort(lst+1,lst+n+1,lcmp);\n\tmemset(dfn,0,sizeof(dfn));\n\tfor(int i=1;i<=n;i++){\n\t\tif(dfn[lst[i]]==0){\n\t\t\tdfs(lst[i]);\n\t\t}\n\t}\n\ttopsort();\n\tputchar('\\n');\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cstdlib>\n#include<ctime>\n#include<utility>\n#include<cmath>\n#include<functional>\n#include<queue>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\nvoid sort(int &a,int &b)\n{\n\tif(a>b)\n\t\tswap(a,b);\n}\nvoid open(const char *s)\n{\n#ifndef ONLINE_JUDGE\n\tchar str[100];\n\tsprintf(str,\"%s.in\",s);\n\tfreopen(str,\"r\",stdin);\n\tsprintf(str,\"%s.out\",s);\n\tfreopen(str,\"w\",stdout);\n#endif\n}\nint rd()\n{\n\tint s=0,c;\n\twhile((c=getchar())<'0'||c>'9');\n\tdo\n\t{\n\t\ts=s*10+c-'0';\n\t}\n\twhile((c=getchar())>='0'&&c<='9');\n\treturn s;\n}\nint upmin(int &a,int b)\n{\n\tif(b<a)\n\t{\n\t\ta=b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nint upmax(int &a,int b)\n{\n\tif(b>a)\n\t{\n\t\ta=b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nint gcd(int a,int b)\n{\n\treturn b?gcd(b,a%b):a;\n}\npriority_queue<int> q;\nint d[2010];\nvector<int> g[2010],g2[2010];\nint a[2010];\nint b[2010];\npii c[2010];\nvoid dfs(int x)\n{\n\tb[x]=1;\n\tfor(auto v:g[x])\n\t\tif(!b[v])\n\t\t{\n\t\t\tdfs(v);\n\t\t\tg2[x].push_back(v);\n\t\t\td[v]++;\n\t\t}\n}\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tint i,j;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t\tc[i].first=a[i];\n\t\tc[i].second=i;\n\t}\n\tsort(c+1,c+n+1);\n\tfor(i=1;i<=n;i++)\n\t\tfor(j=1;j<=n;j++)\n\t\t\tif(gcd(a[i],a[j])!=1)\n\t\t\t\tg[i].push_back(j);\n\tfor(i=1;i<=n;i++)\n\t\tif(!b[i])\n\t\t\tdfs(i);\n\tfor(i=1;i<=n;i++)\n\t\tif(!d[i])\n\t\t\tq.push(i);\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tint x=q.top();\n\t\tq.pop();\n\t\tprintf(\"%d \",a[x]);\n\t\tfor(auto v:g2[x])\n\t\t{\n\t\t\td[v]--;\n\t\t\tif(!d[v])\n\t\t\t\tq.push(v);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<queue>\nusing namespace std;\ninline int read()\n{\n\tint k=0,f=1;char c=getchar();\n\tfor(;!isdigit(c);c=getchar()) if(c=='-') f=-1;\n\tfor(;isdigit(c);c=getchar()) k=k*10+c-'0';return f*k;\n}\nconst int N=2005;\ntypedef pair<int,int> P;\npriority_queue<P> q;\nint n,m,tot,a[N],w[N][N],to[N*N],nextt[N*N],head[N],vis[N],de[N];\nint gcd(int x,int y)\n{\n\tif(!y) return x;\n\treturn gcd(y,x%y);\n}\nvoid add(int a,int b)\n{\n\tto[++tot]=b;\n\tnextt[tot]=head[a];\n\thead[a]=tot;\n\tde[b]++;\n}\nvoid dfs(int u)\n{\n\tvis[u]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tif(!vis[i]&&w[u][i])\n\t\t\tadd(u,i),dfs(i);\n}\nint main()\n{\n\tn=read();\n\tfor(int i=1;i<=n;i++)\n\t\ta[i]=read();\n\tsort(a+1,a+1+n);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\tif(gcd(a[i],a[j])!=1)\n\t\t\t\tw[i][j]=w[j][i]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tif(!vis[i]) \t\n\t\t\tdfs(i);\n\tfor(int i=1;i<=n;i++)\n\t\tif(!de[i])\n\t\t\tq.push(P(a[i],i));\n\twhile(!q.empty())\n\t{\n\t\tP k=q.top();q.pop();\n\t\tint u=k.second;\n\t\tprintf(\"%d \",a[u]);\n\t\tfor(int i=head[u];i;i=nextt[i])\n\t\t{\n\t\t\tde[to[i]]--;\n\t\t\tif(!de[to[i]])\n\t\t\t\tq.push(P(a[to[i]],to[i]));\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i, l, r) for(int i = (l), i##end = (r);i <= i##end;++i)\nusing std::cin; using std::cout;\nconst int maxn = 2002;\ntypedef long long ll;\nconst int mod = 998244353;\ninline ll pow(ll a,int b,int ans = 1) {\n\tfor(;b;b >>= 1,a = a * a % mod) if(b & 1)\n\t\tans = ans * a % mod;\n\treturn ans;\n}\ninline ll inverse(int x){ return pow(x, mod - 2); }\nint n, a[maxn];\nint edge[maxn][maxn];\nstruct cmp {\n\tinline int operator () (int x,int y) const {\n\t\treturn a[x] < a[y];\n\t}\n};\nstd::priority_queue<int, std::vector<int>, cmp> q;\nint vis[maxn];\nstd::vector<int> to[maxn];\ninline void dfs(int x) {\n\tvis[x] = 1;\n\tfor(int j = 1;j <= n;++j) if(edge[x][j] && !vis[j]) {\n\t\tdfs(j); to[x].push_back(j);\n\t}\n}\nint main() {\n\tstd::ios::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\tcin >> n; \n\trep(i, 1, n) cin >> a[i];\n\tstd::sort(a + 1,a + n + 1);\n\trep(i, 1, n) rep(j, 1, n) edge[i][j] = std::__gcd(a[i], a[j]) > 1;\n\trep(i, 1, n) if(!vis[i]) dfs(i), q.push(i);\n\tfor(;!q.empty();) {\n\t\tint t = q.top(); q.pop();\n\t\tcout << a[t] << ' ';\n\t\tfor(int j : to[t]) q.push(j);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <map>\n#define MAXN 2010\n#define MAXM 100010\nusing namespace std;\n\nstruct edge{\n\tint to,next;\n\tedge(int _to=0,int _next=0):to(_to),next(_next){}\n}e[MAXM<<1];\n\nint n,numn;\nint a[MAXN];\nbool flag[10010];\nint prime[10010],nump;\nint g[MAXM],nume;\nint d[MAXN][MAXN];\nbool tag[MAXM],visit[MAXM],used[MAXM];\nmap<int,int> Sp;\nint c[MAXM],numc;\nint maxv[MAXN],totmax,totmax2;\n\nvoid addEdge(int u,int v){\n\te[nume]=edge(v,g[u]);\n\tg[u]=nume++;\n}\n\nint gcd(int x,int y){\n\tif(!y) return x;\n\treturn gcd(y,x%y);\n}\n\nvoid init(){\n\tfor(int i=2;i<10010;i++){\n\t\tif(!flag[i]) prime[++nump]=i;\n\t\tfor(int j=1;j<=nump && i*prime[j]<10010;j++){\n\t\t\tflag[i*prime[j]]=1;\n\t\t\tif(i%prime[j]==0) break;\n\t\t}\n\t}\n}\n\nvoid pre_gao(int x,int v){\n\tint v0=v;\n\tfor(int i=1;i<=nump && prime[i]*prime[i]<=v0;i++)\n\t\tif(v%prime[i]==0){\n\t\t\twhile(v%prime[i]==0) v/=prime[i];\n\t\t\tif(!Sp.count(prime[i])) Sp[prime[i]]=++numn;\n\t\t\taddEdge(x,Sp[prime[i]]);\n\t\t\taddEdge(Sp[prime[i]],x);\n\t\t}\n\tif(v>1){\n\t\tif(!Sp.count(v)) Sp[v]=++numn;\n\t\taddEdge(x,Sp[v]);\n\t\taddEdge(Sp[v],x);\n\t}\n}\n\nvoid dfs(int x){\n\tvisit[x]=1;\n\tc[x]=numc;\n\tif(tag[x] && a[x]<maxv[numc]) maxv[numc]=a[x];\n\tfor(int i=g[x];~i;i=e[i].next)\n\t\tif(!used[e[i].to] && !visit[e[i].to]){\n\t\t\tdfs(e[i].to);\n\t\t}\n}\n\nint gao(int l){\n\tfor(int i=1;i<=numn;i++) visit[i]=0;\n\ttotmax2=totmax=numc=0;\n\tfor(int i=1;i<=n;i++)\n\t\tif(!used[i] && !visit[i]){\n\t\t\tmaxv[++numc]=1<<30;\n\t\t\tdfs(i);\n\t\t\tif(maxv[numc]>totmax){\n\t\t\t\ttotmax2=totmax;\n\t\t\t\ttotmax=maxv[numc];\n\t\t\t}else if(maxv[numc]>totmax2) totmax2=maxv[numc];\n\t\t}\n\tint minv=1<<30;\n\tfor(int i=1;i<=n;i++)\n\t\tif(!used[i] && tag[i] && a[i]<minv){\n\t\t\tif(maxv[c[i]]==totmax && a[i]<totmax2) continue;\n\t\t\tif(maxv[c[i]]!=totmax && a[i]<totmax) continue;\n\t\t\tminv=a[i];\n\t\t}\n\tfor(int i=1;i<=n;i++)\n\t\tif(!used[i] && tag[i] && a[i]==minv){\n\t\t\tused[i]=1;\n\t\t\tfor(int j=1;j<=n;j++)\n\t\t\t\tif(tag[j] && a[j]>a[i]) \n\t\t\t\t\ttag[j]=0;\n\t\t\tfor(int j=1;j<=n;j++)\n\t\t\t\tif(!used[j] && !tag[j] && d[j][i]!=1)\n\t\t\t\t\ttag[j]=1;\n\t\t\treturn minv;\n\t\t}\n\tassert(0);\n}\n\nint main(){\n#ifdef DEBUG\n\tfreopen(\"E.in\",\"r\",stdin);\n#endif\n\tmemset(g,-1,sizeof g);\n\tinit();\n\tscanf(\"%d\",&n);\n\tnumn=n;\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d\",a+i);\n\t\tpre_gao(i,a[i]);\n\t}\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\td[i][j]=gcd(a[i],a[j]);\n\tfor(int i=1;i<=n;i++) tag[i]=1;\n\tfor(int i=1;i<=n;i++) printf(\"%d \",gao(i));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define REP(i, n) FOR(i,0,n)\ntemplate<typename T> istream& operator>>(istream &is, vector<T> &vec){ for (auto &v : vec) is >> v; return is; }\ntemplate<typename T> ostream& operator<<(ostream &os, const vector<T> &vec){ os << \"[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream &os, const set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream &os, const unordered_set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream &os, const multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream& operator<<(ostream &os, const unordered_multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T1, typename T2> ostream& operator<<(ostream &os, const pair<T1, T2> &pa){ os << \"(\" << pa.first << \",\" << pa.second << \")\"; return os; }\ntemplate<typename TK, typename TV> ostream& operator<<(ostream &os, const map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename TK, typename TV> ostream& operator<<(ostream &os, const unordered_map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename T> void ndarray(vector<T> &vec, int len) { vec.resize(len); }\ntemplate<typename T, typename... Args> void ndarray(vector<T> &vec, int len, Args... args) { vec.resize(len); for (auto &v : vec) ndarray(v, args...); }\ntemplate<typename T> void Max(T &m, const T q) { if (m < q) m = q; }\ntemplate<typename T> void Min(T &m, const T q) { if (m > q) m = q; }\ntemplate<typename T1, typename T2> pair<T1, T2> operator+(pair<T1, T2> &l, pair<T1, T2> &r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate<typename T1, typename T2> pair<T1, T2> operator-(pair<T1, T2> &l, pair<T1, T2> &r) { return make_pair(l.first - r.first, l.second - r.second); }\n#define dbg(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \") \" << __FILE__ << endl;\n\nint N;\nvector<lint> A;\nvector<bool> used;\nvector<vector<int>> to;\n\nvector<int> merge_vec(const vector<vector<int>> &input)\n{\n    int m = input.size();\n    vector<int> ans;\n    int n = 0;\n    for (auto vec : input) n += vec.size();\n\n    vector<int> pos(m);\n    REP(_, n)\n    {\n        vector<int> vals(m);\n        REP(i, m) if (pos[i] < input[i].size()) vals[i] = A[input[i][pos[i]]];\n        int winner = distance(vals.begin(), max_element(vals.begin(), vals.end()));\n        ans.push_back(input[winner][pos[winner]]);\n        pos[winner]++;\n    }\n    return ans;\n}\n\nvector<int> dfs(int now)\n{\n    used[now] = true;\n    vector<vector<int>> tmp;\n    for (auto nxt : to[now]) if (!used[nxt]) tmp.push_back(dfs(nxt));\n    vector<int> ans = merge_vec(tmp);\n    ans.insert(ans.begin(), now);\n    return ans;\n}\n\nint main()\n{\n    cin >> N;\n    A.resize(N);\n    cin >> A;\n    sort(A.begin(), A.end());\n\n    to.resize(N);\n    REP(i, N) REP(j, i) if (__gcd(A[i], A[j]) != 1)\n    {\n        to[i].push_back(j);\n        to[j].push_back(i);\n    }\n\n    used.assign(N, false);\n    vector<vector<int>> ans;\n    REP(i, N) if (!used[i]) ans.push_back(dfs(i));\n    vector<int> res = merge_vec(ans);\n    REP(i, N - 1) printf(\"%lld \", A[res[i]]);\n    printf(\"%lld\\n\", A[res.back()]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h> \n#define N 2005\n#define V 40020\nusing namespace std;\nvector<int>v[V];\nint a[N],ans[N],Min[N],comp[V],last_not_coprime[N],n,cnt,tot,best_col[N],ID[N],m;\nbool used[N],b[N][N];\nmap<int,int>pID;\nint gcd(int x,int y){return !x?y:gcd(y%x,x);}\nint get_id(int x)\n{\n\tif(pID.count(x))return pID[x];\n\tpID[x]=m++;\n\treturn m-1;\n}\nvoid dfs(int from)\n{\n    comp[from]=cnt;\n\tfor(int i=0;i<v[from].size();i++)\n\t{\n\t\tint to=v[from][i];\n\t\tif(comp[to]>-1||(to<n&&used[to]))continue;\n\t\tdfs(to);\n\t}\n}\nvoid colors()\n{\n\tcnt=0;memset(comp,-1,sizeof(comp));\n\tfor(int i=0;i<n;i++)\n\tif(!used[i]&&comp[i]==-1)\n\t{\n\t\tdfs(i);\n\t\tcnt++;\n\t}\n}\nint main()\n{\n\tios::sync_with_stdio(0);\n\tcin>>n;\n\tm=n;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcin>>a[i];\n\t\tint x=a[i];\n\t\tfor(int y=2;y*y<=x;y++)\n\t\tif(!(x%y))\n\t\t{\n\t\t\tint id=get_id(y);\n\t\t\tv[i].push_back(id);\n\t\t\tv[id].push_back(i);\n\t\t\twhile(!(x%y))x/=y;\n\t\t}\n\t\tif(x!=1)\n\t\t{\n\t\t\tint id=get_id(x);\n\t\t\tv[i].push_back(id);\n\t\t\tv[id].push_back(i);\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)\n\tfor(int j=0;j<n;j++)\n\tif(gcd(a[i],a[j])!=1)b[i][j]=b[j][i]=1,\n\tmemset(Min,0x3f,sizeof(Min));\n\tmemset(last_not_coprime,-1,sizeof(last_not_coprime));\n\twhile(1)\n\t{\n\t\tcolors();\n\t\tmemset(best_col,-1,sizeof(best_col));\n\t\tfor(int i=0;i<n;i++)\n\t\tif(Min[last_not_coprime[i]+1]>=a[i]&&!used[i])\n\t\t{\n\t\t\tif(best_col[comp[i]]==-1||a[i]<best_col[comp[i]])best_col[comp[i]]=a[i],\n\t\t\tID[comp[i]]=i;\n\t\t}\n\t\tint id=-1;\n\t\tfor(int i=0;i<cnt;i++)\n\t\t{\n\t\t\tif(best_col[i]==-1)continue;\n\t\t\tif(id==-1||best_col[id]<best_col[i])id=i;\n\t\t}\n\t\tid=ID[id];\n\t\tans[tot++]=a[id];\n\t\tif(tot==n)\n\t\t{\n\t\t\tcout<<ans[0];\n\t\t\tfor(int i=1;i<n;i++)\n\t\t\tcout<<' '<<ans[i];\n\t\t\tcout<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\tused[id]=1;\n\t\tfor(int i=0;i<tot;i++)\n\t\tMin[i]=min(Min[i],a[id]);\n\t\tfor(int i=0;i<n;i++)\n\t\tif(b[i][id])last_not_coprime[i]=tot-1;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nconst int maxn = 2030, oo = 123456789, maxm = 34010;\n \nint n, m, T, ans, mn, a[maxn], foo[maxn], lst[maxm], tag[maxn], q[maxn], rar;\nbool vis[maxn], f[maxn], G[maxn][maxn], F[maxn];\nstd::vector<int> g[maxn], has[maxn], rhas[maxm], all;\nstd::vector<std::pair<int, int> > v;\n \nvoid GEN() {\n\tint mx = 0;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif(!foo[i]) {\n\t\t\tif(a[i] == 1) {\n\t\t\t\tF[i] = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tF[i] = 0;\n\t\t\t\tfor (int j: has[i]) {\n\t\t\t\t\tif(lst[j] >= mx) {\n\t\t\t\t\t\tF[i] = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t(foo[i] > mx) && (mx = foo[i]);\n\t\t}\n\t}\n\treturn;\n}\n \ninline void dfs(int &u) {\n\ttag[u] = T;\n\t(F[u] && a[u] < mn) && (mn = a[u]);\n\tvis[u] = 1;\n\tfor (int &v: g[u]) {\n\t\tif(!vis[v] && !f[v]) {\n\t\t\tdfs(v);\n\t\t}\n\t}\n\treturn;\n}\n \nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tscanf(\"%d\", a + i);\n\t\tint t = a[i];\n\t\tfor (int x = 2; x * x <= t; ++x) {\n\t\t\tif(t % x == 0) {\n\t\t\t\tall.push_back(x);\n\t\t\t\twhile(t % x == 0) {\n\t\t\t\t\tt /= x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(t > 1) {\n\t\t\tall.push_back(t);\n\t\t}\n\t}\n\tstd::sort(a + 1, a + n + 1);\n\tstd::sort(all.begin(), all.end());\n\tall.resize(std::unique(all.begin(), all.end()) - all.begin());\n\tm = (int)(all.size());\n\tfor (int i = 1; i <= n; ++i) {\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tif(a[i] % all[j] == 0) {\n\t\t\t\thas[i].push_back(j);\n\t\t\t\trhas[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int j = 0; j < m; ++j) {\n\t\tfor (int i = 0; i < (int)(rhas[j].size()); ++i) {\n\t\t\tfor (int k = 0; k < i; ++k) {\n\t\t\t\tint u = rhas[j][i], v = rhas[j][k];\n\t\t\t\tif(!G[u][v]) {\n\t\t\t\t\tg[u].push_back(v);\n\t\t\t\t\tg[v].push_back(u);\n\t\t\t\t\tG[u][v] = G[v][u] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n\t\tGEN();\n\t\tmemset(vis + 1, 0, sizeof(vis[0]) * n);\n\t\tv.clear();\n\t\tfor (int u = 1; u <= n; ++u) {\n\t\t\tif(F[u]) {\n\t\t\t\tif(!vis[u] && !f[u]) {\n\t\t\t\t\t++T;\n\t\t\t\t\tmn = oo;\n//\t\t\t\t\tdfs(u);\n\t\t\t\t\trar = 0;\n\t\t\t\t\tq[rar++] = u;\n\t\t\t\t\tfor (register int fnt = 0; fnt < rar; ++fnt) {\n\t\t\t\t\t\tint &u = q[fnt];\n\t\t\t\t\t\ttag[u] = T;\n\t\t\t\t\t\t(F[u] && a[u] < mn) && (mn = a[u]);\n\t\t\t\t\t\tvis[u] = 1;\n\t\t\t\t\t\tfor (int &v: g[u]) {\n\t\t\t\t\t\t\tif(!vis[v] && !f[v]) {\n\t\t\t\t\t\t\t\tq[rar++] = v;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tv.push_back(std::make_pair(mn, T));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstd::sort(v.begin(), v.end());\n\t\tint sz = (int)(v.size());\n\t\t//ans = 0;\n\t\tfor (int u = 1; u <= n; ++u) {\n\t\t\tif(F[u] && !f[u]) {\n\t\t\t\tint i = sz - 1;\n\t\t\t\tif(v[i].second == tag[u]) {\n\t\t\t\t\t--i;\n\t\t\t\t}\n\t\t\t\tif(i < 0 || v[i].first <= a[u]) {\n\t\t\t\t\tans = u;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tf[ans] = 1;\n\t\tfoo[ans] = i;\n\t\tprintf(\"%d \", a[ans]);\n\t\tfor (int j: has[ans]) {\n\t\t\tlst[j] = i;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <cmath>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <bitset>\n#define y1 y11\n#define fs first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define mt make_tuple\n#define NAME \"\"\n\nusing namespace std;\n\t\ntypedef long long ll;\ntypedef long double ld;\n\nconst ld PI = acos(-1.0);\n\nint gcd(int a, int b)\n{\n\twhile (b != 0)\n\t{\n\t\tint c = a % b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\n\nconst int MAXN = 3001;\nconst int MAXM = MAXN * 100;\nint a[MAXN];\nvector <int> pd[MAXN];\nvector <int> as[MAXN];\nint ps[MAXM];\nint pc = 0;\nbool w[MAXN];\nbool wc[MAXN];\nint q[MAXN], qb, qe;\nint block[MAXN];\nint mn[MAXN];\n\nbool e[MAXN][MAXN];\n\nint main()\n{\n\t//freopen(\"input.txt\", \"r\", stdin); freopen(\"output.txt\", \"w\", stdout);\t\n\tint n;\n\tcin >> n;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tcin >> a[i];\n\t}\n\tsort(a, a + n);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (int j = 0; j < n; j++)\n\t\t{\n\t\t\te[i][j] = (gcd(a[i], a[j]) > 1);\n\t\t}\n\t\tint na = a[i];\n\t\tfor (int j = 2; j * j <= a[i]; j++)\n\t\t{\n\t\t\tif (na % j == 0)\n\t\t\t{\n\t\t\t\twhile (na % j == 0) na /= j;\n\t\t\t\tpd[i].push_back(j);\n\t\t\t\tps[pc++] = j;\n\t\t\t}\n\t\t}\n\t\tif (na != 1) pd[i].push_back(na), ps[pc++] = na;\n\t}\n\tsort(ps, ps + pc);\n\tpc = unique(ps, ps + pc) - ps;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tw[i] = false;\n\t\tfor (int j = 0; j < pd[i].size(); j++)\n\t\t{\n\t\t\tint v = lower_bound(ps, ps + pc, pd[i][j]) -ps;\n\t\t\tpd[i][j] = v;\n\t\t\tas[v].push_back(i);\n\t\t}\n\t}\n\tint calc = 0;\n\tfor (int iter = 0; iter < n; iter++)\n\t{\n\t\tmn[iter] = n;\n\t\tqe = qb = 0;\n\t\tfor (int i = 0; i < n; i++) wc[i] = w[i];\n\t\tfor (int i = 0; i < pc; i++) ps[i] = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (!wc[i]) q[qe++] = i, wc[i] = true;\n\t\t\twhile (qb < qe)\n\t\t\t{\n\t\t\t\tint v = q[qb++];\n\t\t\t\tfor (int j = 0; j < pd[v].size(); j++)\n\t\t\t\t{\n\t\t\t\t\tint u = pd[v][j];\n\t\t\t\t\tif (ps[u]) continue;\n\t\t\t\t\tps[u] = 1;\n\t\t\t\t\tfor (int l = 0; l < as[u].size(); l++)\n\t\t\t\t\t{\n\t\t\t\t\t\tint v2 = as[u][l];\n\t\t\t\t\t\tif (wc[v2]) continue;\n\t\t\t\t\t\twc[v2] = true;\n\t\t\t\t\t\tq[qe++] = v2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((qe + iter == n) && (mn[block[i]] > i) && (!w[i]))\n\t\t\t{\n\t\t\t\tcalc++;\n\t\t\t\tcout << a[i] << \" \";\n\t\t\t\tfor (int j = 0; j <= iter; j++) mn[j] = min(mn[j], i); \n\t\t\t\tw[i] = true;\n\t\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\t{\n\t\t\t\t\tif (e[i][j]) block[j] = iter + 1;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tassert(calc == n);\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long double ld;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define sz(x) ((int) (x).size())\n#define TASK \"text\"\n\nconst int inf = (int) 1.01e9;\nconst long long infll = (long long) 1.01e18;\nconst ld eps = 1e-9;\nconst ld pi = acos((ld) -1);\n\n#ifdef DEBUG\nmt19937 mrand(300); \n#else\nmt19937 mrand(chrono::steady_clock::now().time_since_epoch().count()); \n#endif\n\nint rnd(int x) {\n  return mrand() % x;\n}\n\nvoid precalc() {\n}\n\nint gcd(int a, int b) {\n  return (b ? gcd(b, a % b) : a);\n}\n\nconst int maxn = 2005;\nint n;\nint a[maxn];\n\nbool read() {\n  if (scanf(\"%d\", &n) < 1) {\n    return false;\n  }\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d\", &a[i]);\n  }\n  return true;\n}\n\nbool cmp(vector<int>::iterator a, vector<int>::iterator b) {\n  while (true) {\n    if (*a != *b) {\n      return *a > *b;\n    }\n    a++;\n    b++;\n  }\n}\n\nvoid myMerge(vector<int> &a, vector<int> &b) {\n  a.push_back(-1);\n  b.push_back(-2);\n  vector<int> ans;\n  for (int i = 0, j = 0; i < sz(a) || j < sz(b);) {\n    if (i >= sz(a)) {\n      ans.push_back(b[j++]);\n      continue;\n    }\n    if (j >= sz(b)) {\n      ans.push_back(a[i++]);\n      continue;\n    }\n    if (cmp(a.begin() + i, b.begin() + j)) {\n      ans.push_back(a[i++]);\n    } else {\n      ans.push_back(b[j++]);\n    }\n  }\n  ans.pop_back();\n  ans.pop_back();\n  a = ans;\n}\n\nvector<int> g[maxn];\nint used[maxn];\n\nvector<int> dfs(int v) {\n  used[v] = true;\n  vector<int> ans;\n  while (true) {\n    int u = -1;\n    for (int i = 0; i < sz(g[v]); i++) {\n      int w = g[v][i];\n      if (!used[w] && (u == -1 || a[w] < a[u])) {\n        u = w;\n      }\n    }\n    if (u == -1) {\n      break;\n    }\n    vector<int> cur = dfs(u);\n    myMerge(ans, cur);\n  }\n  ans.insert(ans.begin(), a[v]);\n  return ans;\n}\n\nvoid solve() {\n  for (int i = 0; i < n; i++) {\n    used[i] = false;\n    for (int j = 0; j < n; j++) {\n      if (j == i) {\n        continue;\n      }\n      if (gcd(a[i], a[j]) > 1) {\n        g[i].push_back(j);\n      }\n    }\n  }\n  vector<int> ans;\n  while (sz(ans) < n) {\n    int v = -1;\n    for (int i = 0; i < n; i++) {\n      if (!used[i] && (v == -1 || a[i] < a[v])) {\n        v = i;\n      }\n    }\n    vector<int> cur = dfs(v);\n    myMerge(ans, cur);\n  }\n  for (int i = 0; i < n; i++) {\n    printf(\"%d \", ans[i]);\n  }\n  printf(\"\\n\");\n}\n\nint main() {\n  precalc();\n#ifdef DEBUG\n  assert(freopen(TASK \".in\", \"r\", stdin));\n  assert(freopen(TASK \".out\", \"w\", stdout));\n#endif\n  while (read()) {\n    solve();\n#ifdef DEBUG\n    eprintf(\"Time %.2f\\n\", (double) clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n\nusing namespace std;\n//author_name:kaban5 \n//date:2018/11/18\n//title:AGC 010 E Rearranging\n//因为怯懦，所以逃避生命，以不抵抗在最黑暗的沉沦中生出骄傲，因为骄傲，所以不选择生，所以拒斥粗鄙的乐观主义。\n//天才的悲剧地于被小而舒适的名望所束缚。\n//It's human to lie. Most of the time we can't even be honest with ourselves.\n\nbool used[2020];\nvector<int> g[2020];\nint a[2020];\nint n;\n\ninline vector<int> combine(vector<int> a,vector<int> b)\n{\n\tvector<int> l=a,r=b;\n\tif(l.empty()||r.empty())\n\t\treturn l.empty()?r:l;\n\tvector<int> ret(l.size()+r.size());\n\tmerge(a.begin(),a.end(),b.begin(),b.end(),ret.begin(),greater<int> ());\n\treturn ret;\n}\n\nvector<int> dfs(int u)\n{\n\tused[u]=true;\n\tvector<int>ret;\n\tfor(int i:g[u]) if(!used[i])\n\t{\n\t\tret=combine(ret,dfs(i));\n\t}\n\tret.insert(ret.begin(),u);\n\treturn ret;\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++)\n\t\tscanf(\"%d\",a+i);\n\tsort(a,a+n);\n\tfor(int i=0;i<n;i++)\n\t\tfor(int j=0;j<i;j++)\n\t\t\tif(__gcd(a[i],a[j])>1)\n\t\t\t{\n\t\t\t\tg[i].push_back(j);\n\t\t\t\tg[j].push_back(i);\n\t\t\t}\n\tvector<int> ret;\n\tfor(int i=0;i<n;i++) if(!used[i])\n\t{\n\t\tret=combine(ret,dfs(i));\n\t}\n\tfor(int i=0;i<n;i++)\n\t\tprintf(\"%d \",a[ret[i]]);\n\tprintf(\"\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<stack>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<cmath>\nusing namespace std;\nint gcd(int x,int y){return (y==0)?x:gcd(y,x%y);}\nint n;\nint a[2010];\nint in[2010];\nint vis[2010];\nint ed[2010][2010];\nvector<int> e[2010];\npriority_queue<int,vector<int>,less<int> > q;\nvoid dfs(int x)\n{\n\tvis[x]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tif(!vis[i]&&ed[x][i])\n\t\t{\n\t\t\tin[i]++;\n\t\t\te[x].push_back(i);\n\t\t\tdfs(i);\n\t\t}\n}\nsigned main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++)\n\t\t\tif(gcd(a[i],a[j])!=1)\n\t\t\t\ted[i][j]=1,ed[j][i]=1;\n\tfor(int i=1;i<=n;i++)\n\t\tif(!vis[i])\n\t\t\tdfs(i);\n\tfor(int i=1;i<=n;i++)\n\t\tif(in[i]==0)\n\t\t\tq.push(i);\n\twhile(!q.empty())\n\t{\n\t\tint u=q.top();\n\t\tq.pop();\n\t\tprintf(\"%d \",a[u]);\n\t\tfor(int i=0;i<e[u].size();i++)\n\t\t{\n\t\t\tint to=e[u][i];\n\t\t\tin[to]--;\n\t\t\tif(in[to]==0)\n\t\t\t\tq.push(to);\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define N 2010\nint n;\nint ai[N];\nvector <int> bi[N], bf[N];\nint vis[N];\nint in[N];\nstruct comp\n{\n    int operator() (int a, int b) {return ai[a] < ai[b];}\n};\npriority_queue <int, vector <int>, comp> H;\nvoid dfs(int t)\n{\n    vis[t] = 1;\n    for (int i = 0; i < bi[t].size(); ++ i)\n        if (!vis[bi[t][i]])\n        {\n            bf[t].push_back(bi[t][i]);\n            in[bi[t][i]] ++;\n            dfs(bi[t][i]);\n        }\n}\nint main()\n{\n    cin >> n;\n    for (int i = 1; i <= n; ++ i)\n        cin >> ai[i];\n    sort(ai + 1, ai + n + 1);\n    for (int i = 1; i <= n; ++ i)\n        for (int j = i + 1; j <= n; ++ j)\n            if (__gcd(ai[i], ai[j]) != 1)\n                bi[i].push_back(j),\n                bi[j].push_back(i);\n\n    for (int i = 1; i <= n; ++ i)\n        if (!vis[i]) dfs(i);\n\n    for (int i = 1; i <= n; ++ i)\n        if (!in[i]) H.push(i);\n    while (!H.empty())\n    {\n        int hd = H.top(); H.pop();\n        cout << ai[hd] << \" \";\n        for (int i = 0; i < bf[hd].size(); ++ i)\n        {\n            in[bf[hd][i]] --;\n            if (!in[bf[hd][i]]) H.push(bf[hd][i]);\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint gcd(int a, int b){\n\treturn b == 0 ? a : gcd(b, a % b);\n}\n\nunsigned long long one = 1;\nunsigned long long g[2010][2010];\nunsigned long long vis[2010];\n\nint a[2010], is_ans[2010], can_put[2010], x[2010];\n\nint main(){\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++){\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tif (gcd(a[i], a[j]) > 1){\n\t\t\t\tg[i][j >> 6] |= (one << (j & 63));\n\t\t\t\tg[j][i >> 6] |= (one << (i & 63));\n\t\t\t}\n\t\t}\n\t}\n\tint nn = ((n - 1) >> 6) + 1;\n\tfor (int i = 0; i < n; i++){\n\t\tis_ans[i] = can_put[i] = 1;\n\t}\n\tfor (int T = 0; T < n; T++){\n\t\tfor (int i = 0; i < nn; i++){\n\t\t\tvis[i] = 0;\n\t\t}\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tif (!is_ans[i]) vis[i >> 6] |= (one << (i & 63));\n\t\t}\n\t\tint best = -1;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tif (vis[i >> 6] & (one << (i & 63))) continue;\n\t\t\tint b = 0, e = 1;\n\t\t\tx[0] = i;\n\t\t\tvis[i >> 6] |= (one << (i & 63));\n\t\t\twhile (b < e){\n\t\t\t\tint t = x[b];\n\t\t\t\tfor (int j = 0; j < nn; j++){\n\t\t\t\t\tif ((g[x[b]][j] & vis[j]) == g[x[b]][j]) continue;\n\t\t\t\t\tfor (int v = j * 64; v < (j + 1) * 64; v++){\n\t\t\t\t\t\tif (!(g[x[b]][v >> 6] & (one << (v & 63)))) continue;\n\t\t\t\t\t\tif (vis[v >> 6] & (one << (v & 63))) continue;\n\t\t\t\t\t\tvis[v >> 6] |= (one << (v & 63)), x[e++] = v;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint now = -1;\n\t\t\tfor (int j = 0; j < e; j++){\n\t\t\t\tif (!can_put[x[j]]) continue;\n\t\t\t\tif (now == -1 || a[x[j]] < a[now]) now = a[x[j]];\n\t\t\t}\n\t\t\tif (best == -1 || now != -1 && a[now] > a[best]) best = now;\n\t\t}\n\t\tprintf(\"%d \", a[best]);\n\t\tis_ans[best] = 0;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tif (!is_ans[best]) continue;\n\t\t\tif (g[best][i >> 6] & (one << (i & 63))) can_put[i] = 1;\n\t\t\telse if (a[best] < a[i]) can_put[i] = 0;\n\t\t}\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int N = 2005;\n\nint n, a[N], E[N][N], e[N][N], ind[N], vis[N], inq[N];\n\nvoid link(int x, int y) { ++ind[y], e[x][y] = 1; }\n\nint main() {\n\tstd::ios::sync_with_stdio(0), std::cin.tie(0);\n\tstd::cin >> n;\n\tfor (int i = 1; i <= n; ++i) std::cin >> a[i];\n\tstd::sort(a + 1, a + n + 1);\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = i + 1; j <= n; ++j)\n\t\t\tif (std::__gcd(a[i], a[j]) > 1) E[i][j] = E[j][i] = 1;\n\tstd::function<void(int)> dfs = [&] (int x) {\n\t\tvis[x] = 1;\n\t\tfor (int i = 1; i <= n; ++i) if (E[x][i] && !vis[i])\n\t\t\te[x][i] = 1, ++ind[i], dfs(i);\n\t};\n\tfor (int i = 1; i <= n; ++i) if (!vis[i]) dfs(i);\n\tfor (int i = 1; i <= n; ++i) if (!ind[i]) inq[i] = 1;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tint t;\n\t\tfor (t = n; t; --t) if (inq[t]) break;\n\t\tinq[t] = 0, std::cout << a[t] << ' ';\n\t\tfor (int j = 1; j <= n; ++j)\n\t\t\tif (e[t][j] && !--ind[j]) inq[j] = 1;\n\t}\n\tstd::cout << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <queue>\nusing namespace std;\nconst int N=2005;\nint a[N],fst[N],nxt[N],d[N],n;\nbool u[N];\npriority_queue<int> q;\nvoid addedge(int x,int y){\n\tnxt[y]=fst[x];fst[x]=y;d[y]++;\n}\nint gcd(int x,int y){\n\treturn y?gcd(y,x%y):x;\n}\nvoid dfs(int x){\n\tu[x]=1;\n\tfor (int i=1;i<=n;i++)\n\tif (!u[i] && gcd(a[x],a[i])>1){\n\t\taddedge(x,i);\n\t\tdfs(i);\n\t}\n}\nint main(){\n\tscanf(\"%d\\n\",&n);\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tsort(a+1,a+n+1);\n\tfor (int i=1;i<=n;i++)\n\t\tif (!u[i]) dfs(i);\n\tfor (int i=1;i<=n;i++)\n\t\tif (!d[i]) q.push(i);\n\tfor (;!q.empty();){\n\t\tint x=q.top();q.pop();\n\t\tprintf(\"%d \",a[x]);\n\t\tfor (int i=fst[x];i;i=nxt[i])\n\t\t\tif (!--d[i]) q.push(i);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define null                \"\"\n#define all(dat)            dat.begin(), dat.end()\n#define over(msg)           puts(msg), exit(0);\n#define loop(i, to)         for (int i = 0; i < to; ++i)\n#define cont(i, to)         for (int i = 1; i <= to; ++i)\n#define foreach(i, dat)     for (__typeof(dat.begin()) i = dat.begin(); i != dat.end(); ++i)\n\ntypedef long long           num;\n\nusing namespace std;\n\nbool vis[2005];\n\nint n, sz;\n\npair<int, int> dat[2005];\n\nvector<int> g[2005];\n\nvector<vector<int>> b;\n\nint gcd(int a, int b) {\n\t\n\treturn b == 0 ? a : gcd(b, a % b);\n\t\n}\n\nvoid dfs(int u, int mem) {\n\t\n\tif (u == -1)  return;\n\t\n\tint to = -1, mn = 1e9;\n\t\n\tvis[u] = 1;\n\t\n\tb[mem].push_back(dat[u].first);\n\t\n\tloop (i, g[u].size()) {\n\t\t\n\t\tint v = g[u][i];\n\t\t\n\t\tif (vis[v])  continue;\n\t\t\n\t\tif (dat[v].first < mn) {\n\t\t\t\n\t\t\tmn = dat[v].first;\n\t\t\t\n\t\t\tto = v;\n\t\t\t\n\t\t}\n\t\t\n\t}\n\t\n\tdfs(to, mem);\n\t\n}\n\nbool cmp(vector<int> a, vector<int> b) {\n\t\n\treturn a[0] > b[0];\n\t\n}\n\nint main() {\n\t\n\tios_base::sync_with_stdio(0);\n\t\n\tcin >> n;\n\t\n\tcont (i, n) {\n\t\t\n\t\tcin >> dat[i].first;\n\t\t\n\t\tdat[i].second = i;\n\t\t\n\t}\n\t\n\tcont (i, n) {\n\t\t\n\t\tcont (j, n) {\n\t\t\t\n\t\t\tif (i == j)  continue;\n\t\t\t\n\t\t\tint tmp = gcd(dat[i].first, dat[j].first);\n\t\t\t\n\t\t\tif (tmp > 1) {\n\t\t\t\t\n\t\t\t\tg[i].push_back(j);\n\t\t\t\t\n\t\t\t\tg[j].push_back(i);\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t}\n\t\n\tsort(dat, dat + n);\n\t\n\tcont (i, n) {\n\t\t\n\t\tint u = dat[i].second;\n\t\t\n\t\tif (vis[u])  continue;\n\t\t\n\t\tb.push_back(vector<int>(0));\n\t\t\n\t\tdfs(u, sz++);\n\t\t\n\t}\n\t\n\tsort(all(b), cmp);\n\t\n\tloop (i, b.size()) {\n\t\t\n\t\tloop (j, b[i].size()) {\n\t\t\t\n\t\t\tcout << b[i][j] << ' ';\n\t\t\t\n\t\t}\n\t\t\n\t}\n\t\n\tcout << endl;\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n██████████████████████████████████████████████████████████████████████████████\n██              ██████    ██████      ██      ██  ██    ██████              ██\n██  ██████████  ██  ██      ██      ██████████████  ██████  ██  ██████████  ██\n██  ██      ██  ██    ██  ████      ██    ██████████    ██  ██  ██      ██  ██\n██  ██      ██  ██    ██  ██      ██  ████        ██  ████  ██  ██      ██  ██\n██  ██      ██  ██  ██████  ████  ████████████  ██    ████████  ██      ██  ██\n██  ██████████  ██  ████  ██    ████    ████  ██████  ████  ██  ██████████  ██\n██              ██  ██  ██  ██  ██  ██  ██  ██  ██  ██  ██  ██              ██\n████████████████████  ██  ██    ██████  ██    ████  ████    ██████████████████\n██████  ████          ████        ██    ██    ████  ████████  ██          ████\n████  ██      ██  ██      ██  ██████  ████  ████    ██    ████    ████████  ██\n██      ██      ██    ██    ████      ████        ██████  ██      ██  ██    ██\n██  ██    ████████████  ████  ██  ████            ████  ████████████  ████  ██\n██  ██      ██  ██  ████    ████████                ████████      ██  ██    ██\n██  ██  ██  ██████████  ████    ██  ████  ██    ████  ████        ████  ██  ██\n██    ██  ████  ██████  ██    ******************    ████  ██            ██  ██\n██    ██████  ██  ██████      * Scan this QR   *██████    ██  ██  ██  ████████\n████  ████  ██  ██████      ██* code to join   *██  ████    ██  ████████  ████\n██████      ████████  ██      * in the Three   *██  ████          ████  ██  ██\n████              ████  ████  * Body ETO.      *  ████        ██  ████  ██  ██\n██████  ██    ████████        *  --ETO manager *██  ██                ██    ██\n████    ██  ██  ██    ██████  *    Ye Wenjie   *████  ████  ██  ████  ██  ████\n██  ████  ██████    ████  ██  *ETO(C),1988~2018*      ██  ██  ██  ██    ██████\n██  ██████  ██  ████    ██  ██******************          ██████    ██████  ██\n██  ██  ██    ████    ██        ██  ██        ████████      ████  ██  ██    ██\n████████████    ██    ██████  ██████████  ██  ████  ██████████    ██  ██  ████\n██████████    ██  ████  ██        ██    ██████████  ██    ██      ██  ██    ██\n██    ██  ████    ██  ████  ████      ██████    ██    ██      ██  ██  ████  ██\n██████  ██  ██████  ██            ██████████  ██    ██    ████  ████  ██    ██\n██      ██████  ████  ████  ████      ████    ████  ████            ██████████\n██████████████████      ██  ██  ████  ██    ██  ██    ████  ██████    ██    ██\n██              ██        ████████████  ████  ██  ██  ██    ██  ██      ██  ██\n██  ██████████  ██    ████  ██████  ██  ██████████████      ██████    ██  ████\n██  ██      ██  ████████    ██  ██      ████  ████  ██              ████  ████\n██  ██      ██  ████  ████  ████  ██████  ██████████████  ██████████    ██  ██\n██  ██      ██  ██    ██████  ██  ██  ██████████  ██  ██      ████    ██    ██\n██  ██████████  ██████  ████            ██    ████████  ██  ████    ██████████\n██              ██████    ████  ████████  ██  ████    ██    ██  ████  ████  ██\n██████████████████████████████████████████████████████████████████████████████\n    扫    描    二    维    码    加    入    三    体    E    T    O\n*/\n/*****************\n *   I<3   C++   *\n *  IWANT ANYAC  *\n * ILOVEPROGRAM! *\n *IT'SINTERESTING*\n * ILOVEPROGRAM! *\n *  INCONTESTS   *\n *   GETSCORE    *\n *    ACCODE     *\n *     LETS      *\n *      GO       *\n *Written by:    *\n *    charlieyan *\n *****************/\n#include <assert.h>\n#include <ctype.h>\n#include <errno.h>\n#include <float.h>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <locale>\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <wchar.h>\n#include <wctype.h>\n#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <cerrno>\n#include <clocale>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <limits>\n#include <map>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <istream>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <utility>\n#include <vector>\n#include <cwchar>\n#include <cwctype>\n#include <numeric>\n#include <list>\n#define LL long long\n#define pb push_back\n#define pob pop_back\n#define mp make_pair\n#define FILL(a,v) memset((void*)a,v,sizeof(a))\n#define FILL0(a) FILL(a,0)\n#define FILL1(a) FILL(a,-1)\n#define FILLBIG(a) FILL(a,0x3f)\n#define ALL(a) (a).begin(),(a).end()\n#define Inf ((int)0x3f3f3f3f)\n#define INF ((long long)0x3f3f3f3f3f3f3f3f)\n#define Mod 1000000007\n#define foreach(it,x) for(__typeof(x.begin()) it=x.begin();it!=x.end();it++)\n#define FOR(i,x) for(int i=0;i<x;i++)\n#define RFOR(i,x) for(int i=x-1;i>=0;i--)\n#define FFOR(i,a,b) for(int i=a;i<b;i++)\n#define FRFOR(i,a,b) for(int i=a-1;i>=b;i--)\n#define SZ(a) ((int)(a).size())\n#define FI first\n#define SE second\n#define OVER(...) return printf(__VA_ARGS__),0\n#define fastio ios::sync_with_stdio(0)\n#define filei(f) freopen(f,\"r\",stdin)\n#define fileo(f) freopen(f,\"w\",stdout)\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define MASK(a) (1<<(a))\n#define MASKX(x,a) ((x)<<(a))\n#define BIT(a,b) (((a)>>(b))&1)\n#define cddx(a) priority_queue<a >\n#define cxdd(a) priority_queue<a,vector<a >,greater<a > >\n#define deval(a) {cerr<<#a<<\" = \"<<a<<endl;}\n#define dearr(be,en) {cerr<<#be;cerr<<\" = {\";for(auto i=be;i!=en;i++)cerr<<' '<<*i;cerr<<\" }\\n\";}\n#define reg register\n#define prtime eprintf(\"\\n\\nTime used: %dms\\n\",clock());\n#define PI 3.1415926535897932384626\n#define TODEG(a) (a*180/PI)\n#define y0 ykangjimutigeidiqiuyipianjingtu\n#define y1 yxiaomiexuduhuanrenleiwannianankang\n#define endl '\\n'\n//抗击母体，给地球一片净土\n//消灭徐毒，还人类万年安康\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef unsigned long long UINT;\ntypedef unsigned int uint;\ntypedef long long INT;\ntypedef long double ldouble;\ntypedef pair<INT,INT> PII;\ntypedef stringstream sst;\ntypedef istringstream iss;\ntypedef vector<int> vint;\ntypedef vector<INT> VINT;\ntypedef vector<pii> vpii;\ntypedef vector<PII> VPII;\ntypedef priority_queue<int> pqi;\ntypedef priority_queue<INT> PQI;\ntypedef priority_queue<pii> pqp;\ntypedef priority_queue<PII> PQP;\ntypedef priority_queue<int,vint,greater<int> > xqi;\ntypedef priority_queue<INT,VINT,greater<INT> > XQI;\ntypedef priority_queue<pii,vpii,greater<pii> > xqp;\ntypedef priority_queue<PII,VPII,greater<PII> > XQP;\nstruct fastIO\n{\n\tinline fastIO operator>>(int& num)\n\t{\n\t\tnum=0;\n\t\tchar c=getchar();\n\t\twhile(c!='-'&&(c<'0'||c>'9'))c=getchar();\n\t\tbool foo=0;\n\t\tif(c=='-')\n\t\t{\n\t\t\tfoo=1;\n\t\t\tc=getchar();\n\t\t}\n\t\twhile(c>='0'&&c<='9')\n\t\t{\n\t\t\tnum=(num<<3)+(num<<1)+c-'0';\n\t\t\tc=getchar();\n\t\t}\n\t\tif(foo)num=-num;\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(INT& num)\n\t{\n\t\tnum=0;\n\t\tchar c=getchar();\n\t\twhile(c!='-'&&(c<'0'||c>'9'))c=getchar();\n\t\tbool foo=0;\n\t\tif(c=='-')\n\t\t{\n\t\t\tfoo=1;\n\t\t\tc=getchar();\n\t\t}\n\t\twhile(c>='0'&&c<='9')\n\t\t{\n\t\t\tnum=(num<<3)+(num<<1)+c-'0';\n\t\t\tc=getchar();\n\t\t}\n\t\tif(foo)num=-num;\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(float& num)\n\t{\n\t\tscanf(\"%f\",&num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(double& num)\n\t{\n\t\tscanf(\"%lf\",&num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(long double& num)\n\t{\n\t\tscanf(\"%Lf\",&num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(char& num)\n\t{\n\t\tnum=getchar();\n\t\twhile(num==' '||num=='\\n')num=getchar();\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(char* num)\n\t{\n\t\tint cnt=0;\n\t\tchar c=getchar();\n\t\twhile(c==' '||c=='\\n')c=getchar();\n\t\twhile(c!=' '&&c!='\\n')\n\t\t{\n\t\t\tnum[cnt++]=c;\n\t\t\tc=getchar();\n\t\t}\n\t\tnum[cnt]=0;\n\t\treturn *this;\n\t}\n\tinline fastIO operator>>(string& num)\n\t{\n\t\tcin>>num;\n\t\treturn *this;\n\t}\n\tinline void printInt(const int& num)\n\t{\n\t\tif(num<10)\n\t\t{\n\t\t\tputchar(num+'0');\n\t\t\treturn;\n\t\t}\n\t\tprintInt(num/10);\n\t\tputchar((num%10)+'0');\n\t}\n\tinline void printINT(const INT& num)\n\t{\n\t\tif(num<10)\n\t\t{\n\t\t\tputchar(num+'0');\n\t\t\treturn;\n\t\t}\n\t\tprintINT(num/10);\n\t\tputchar((num%10)+'0');\n\t}\n\tinline fastIO operator<<(const int& num)\n\t{\n\t\tif(num<0)putchar('-'),printInt(-num);\n\t\telse printInt(num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const INT& num)\n\t{\n\t\tif(num<0)putchar('-'),printINT(-num);\n\t\telse printINT(num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const float& num)\n\t{\n\t\tprintf(\"%.10f\",num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const double& num)\n\t{\n\t\tprintf(\"%.16lf\",num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const long double& num)\n\t{\n\t\tprintf(\"%.20Lf\",num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const char& num)\n\t{\n\t\tputchar(num);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const char* num)\n\t{\n\t\tfor(int i=0;num[i];i++)\n\t\t\tputchar(num[i]);\n\t\treturn *this;\n\t}\n\tinline fastIO operator<<(const string& num)\n\t{\n\t\tcout<<num;\n\t\treturn *this;\n\t}\n}fio;\n//Coded by Charlieyan\n//版权所有，翻印必究\n\nvector<int> nei[2005];\nint num[2005];\nbool SortComp13(int a,int b){\n\treturn num[a]<num[b];\n}\n\nbool lgl[2005];\nvector<int> ltks[2005];\nint ans[2005];\n\nvoid dfs(int now,int ltk){\n\tif(lgl[now]){\n\t\treturn;\n\t}\n\tlgl[now]=1;\n\tltks[ltk].pb(now);\n\tfor(int i=0;i<SZ(nei[now]);i++){\n\t\tdfs(nei[now][i],ltk);\n\t}\n}\n\nint n;\n\nint gcd(int a,int b){\n\treturn !b?a:gcd(b,a%b);\n}\n\nint main(){\n\tfio>>n;\n\tfor(int i=0;i<n;i++){\n\t\tfio>>num[i];\n\t}\n\tsort(num,num+n);\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(gcd(num[i],num[j])!=1){\n\t\t\t\tnei[i].pb(j);\n\t\t\t}\n\t\t}\n\t}\n\tint cntltk=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(!lgl[i]){\n\t\t\tdfs(i,cntltk++);\n\t\t}\n\t}\n\tpriority_queue<pair<int,pii> > pq;\n\tfor(int i=0;i<cntltk;i++){\n\t\tpq.push(mp(num[ltks[i][0]],mp(i,0)));\n\t}\n\tint N=0;\n\twhile(SZ(pq)){\n\t\tpair<int,pii> fff=pq.top();\n\t\tpq.pop();\n\t\tint Num=fff.first,x=fff.second.first,y=fff.second.second;\n\t\tans[N++]=Num;\n\t\ty++;\n\t\tif(y!=SZ(ltks[x])){\n\t\t\tpq.push(mp(num[ltks[x][y]],mp(x,y)));\n\t\t}\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tprintf(\"%d%c\",ans[i],i==N-1?'\\n':' ');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#define fs first\n#define sc second\n#define mp make_pair\n#define sf scanf\n#define pf printf\n#define pb push_back\n#define tl(x) ((int)x.size()-1)\n#define rep(i,j,k) for (i=j;i<=k;i++)\nusing namespace std;\nconst int N=1e5+5;\ntypedef pair<int,int> Pair;\nint n,i,j,a[N],vis[N],dgr[N];\nvector <int> b[N],c[N];\npriority_queue <Pair> heap;\nint gcd(int a,int b) {\n\tint c=a%b;\n\twhile (c) {\ta=b; b=c; c=a%b;}\n\treturn b;\n}\nvoid dfs(int x)\n{\n\tint j; vis[x]=1;\n\trep(j,0,tl(b[x]))\n\tif (!vis[b[x][j]])\n\t{\n\t\tdgr[b[x][j]]=1;\n\t\tc[x].pb(b[x][j]);\n\t\tdfs(b[x][j]);\n\t}\n}\nint main()\n{\n\t//freopen(\"game.in\",\"r\",stdin);\n\t//freopen(\"game.out\",\"w\",stdout);\n\tsf(\"%d\",&n); rep(i,1,n) sf(\"%d\",&a[i]); sort(a+1,a+1+n);\n\trep(i,1,n)\n\t\trep(j,1,n)\n\t\t\tif (i!=j && gcd(a[i],a[j])>1) b[i].pb(j);\n\trep(i,1,n) if (!vis[i]) dfs(i);\n\trep(i,1,n) if (!dgr[i]) heap.push(mp(a[i],i));\n\twhile (!heap.empty())\n\t{\n\t\ti=heap.top().sc;\n\t\theap.pop();\n\t\tpf(\"%d \",a[i]);\n\t\trep(j,0,tl(c[i])) heap.push(mp(a[c[i][j]],c[i][j]));\n\t}\n \treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\nconst int N = 2005;\nint n, a[N], b[N], used[N], g[N][N];\ninline int gcd(int a, int b) { return !b ? a : gcd(b, a % b); }\ninline void swap(int &a, int &b) { int tmp = a; a = b; b = tmp; }\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; ++ i) {\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\tfor (int i = 0; i < n; ++ i)\n\t\tfor (int j = 0; j < n; ++ j) if (i ^ j) {\n\t\t\tg[i][j] = gcd(a[i], a[j]) != 1;\n\t\t}\n\tint mn = 0;\n\tfor (int i = 0; i < n; ++ i) {\n\t\tif (a[i] < a[mn]) mn = i;\n\t}\n\tb[0] = mn;\n\tfor (int i = 0; i + 1 < n; ++ i) {\n\t\tused[b[i]] = 1;\n\t\tmn = -1;\n\t\tfor (int j = 0; j < n; ++ j) if (!used[j] && g[b[i]][j] && (!~mn || a[j] < a[mn])) mn = j;\n\t\tif (!~mn) for (int j = 0; j < n; ++ j) if (!used[j] && (!~mn || a[j] < a[mn])) mn = j;\n\t\tb[i + 1] = mn;\n\t}\n\tfor (int i = 1; i < n; ++ i) {\n\t\tfor (int j = i - 1; ~j; -- j) {\n\t\t\tif (a[b[j]] > a[b[j + 1]] || g[b[j]][b[j + 1]]) break;\n\t\t\tswap(b[j], b[j + 1]);\n\t\t}\n\t}\n\tfor (int i = 0; i < n; ++ i) printf(\"%d%c\", a[b[i]], \" \\n\"[i + 1 == n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,a,b) for(i=a;i<b;i++)\n#define per(i,b,a) for(i=b;i>=a;i--)\n#define For(i,a,b) for(i=a;i<=b;i++)\n#define Forenska(it,c) for(register __typeof(c.begin()) it=c.begin();it!=c.end();it++)\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define fi first\n#define se second\n#define all(x) x.begin(),x.end()\n#define sqr(x) ((x)*(x))\n#define lowbit(x) ((x)&(-x))\n#define GREATER(x) x,vector<x>,greater<x>\nusing namespace std;\nint i,j;\ntypedef long long LL;\ntypedef pair<int,int> pii;\ntypedef pair<LL,LL> pLL;\ntypedef vector<int> vec;\ntypedef vector<LL> vecL;\ntypedef vector<pii> vecP;\ntypedef vector<pLL> vecPL;\ntypedef vector<string> vecS;\ntypedef vector<vec> mat;\ntypedef complex<double> point;\nconst long double PI=3.1415926535897932384626433832795028841971693993751058209749445923078164062862089;\nconst LL INFLL=0x3f3f3f3f3f3f3f3f;\nconst int INF=0x3f3f3f3f;\nconst long double EPS=1e-10;\nint read()\n{\n\tint x=0;\n\tchar ch=' ';\n\tbool flag=false;\n\twhile(!isdigit(ch))\n\t{\n\t\tif(ch=='-')flag=true;\n\t\tch=getchar();\n\t}\n\twhile(isdigit(ch))\n\t{\n\t\tx=(x<<3)+(x<<1)+ch-'0';\n\t\tch=getchar();\n\t}\n\treturn flag?-x:x;\n}\nint n;\nvec A;\nmat g1,g2;\nconst int MAX_N=2005;\nbool vis[MAX_N];\nint in[MAX_N];\nvoid dfs(int v)\n{\n\tif(vis[v])return;\n\tvis[v]=true;\n\trep(i,0,g1[v].size())\n\t{\n\t\tint to=g1[v][i];\n\t\tif(!vis[to])\n\t\t{\n\t\t\tg2[v].pb(to);\n\t\t\tin[to]++;\n\t\t\tdfs(to);\n\t\t}\n\t}\n}\nint main()\n{\n\tn=read();\n\tA.resize(n);\n\trep(i,0,n)A[i]=read();\n\tsort(all(A));\n\tA.resize(unique(all(A))-A.begin());\n\tn=A.size();\n\tg1.resize(n);\n\tg2.resize(n);\n\trep(i,0,n)\n\t{\n\t\trep(j,i+1,n)\n\t\t{\n\t\t\tif(__gcd(A[i],A[j])>1)\n\t\t\t{\n\t\t\t\tg1[i].pb(j);\n\t\t\t\tg1[j].pb(i);\n\t\t\t}\n\t\t}\n\t}\n\trep(i,0,n)\n\t{\n\t\tdfs(i);\n\t}\n\tqueue <int> q;\n\tvec ans;\n\tper(i,n-1,0)if(!in[i])q.push(i),ans.pb(i);\n\twhile(!q.empty())\n\t{\n\t\tint t=q.front();\n\t\tq.pop();\n\t\trep(i,0,g2[t].size())\n\t\t{\n\t\t\tint to=g2[t][i];\n\t\t\tin[to]--;\n\t\t\tif(!in[to])\n\t\t\t{\n\t\t\t\tq.push(to);\n\t\t\t\tans.pb(to);\n\t\t\t}\n\t\t}\n\t}\n\trep(i,0,ans.size())ans[i]=A[ans[i]];\n\trep(i,0,ans.size())\n\t{\n\t\trep(j,0,ans.size()-1)\n\t\t{\n\t\t\tif(ans[j]<ans[j+1] && __gcd(ans[j],ans[j+1])==1)swap(ans[j],ans[j+1]);\n\t\t}\n\t}\n\trep(i,0,ans.size()-1)cout<<ans[i]<<\" \";\n\tcout<<ans.back()<<endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nconst int maxn=2010;\n\nint n,a[maxn];\nvector<int> path[maxn],son[maxn],ans[maxn];\nvector<int> seq;\nbool vis[maxn];\n\nint gcd(int a,int b)\n{\n\tint temp;\n\twhile(b!=0)\n\t{\n\t\tint temp=a%b;\n\t\ta=b;b=temp;\n\t}\n\treturn a;\n}\n\nvoid dfs(int p)\n{\n\tfor(int i=0;i<path[p].size();i++)\n\t{\n\t\tint temp=path[p][i];\n\t\tif (!vis[temp])\n\t\t{\n\t\t\tvis[temp]=true;\n\t\t\tseq.push_back(temp);\n\t\t\tson[p].push_back(temp);\n\t\t\tdfs(temp);\n\t\t}\n\t}\n\treturn;\n}\n\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t    scanf(\"%d\",&a[i]);\n\tsort(a+1,a+n+1);\n\t\n\tfor(int i=1;i<n;i++)\n\t    for(int j=i+1;j<=n;j++)\n\t    \tif (gcd(a[i],a[j])!=1)\n\t    \t{\n\t    \t\tpath[i].push_back(j);\n\t    \t\tpath[j].push_back(i);\n\t    \t}\n\t\n\tseq.push_back(n+1);\n\tfor(int i=1;i<=n;i++)\n\t\tif (!vis[i])\n\t\t{\n\t\t\tvis[i]=true;\n\t\t\tseq.push_back(i);\n\t\t\tson[n+1].push_back(i);\n\t\t\tdfs(i);\n\t\t}\n\t\n\tfor(int i=n;i>=0;i--)\n\t{\n\t\tint now=seq[i];\n\t\tvector<int> cur;\n\t\tans[now].push_back(now);\n\t\tfor(int j=0;j<son[now].size();j++)\n\t\t{\n\t\t\tint temp=son[now][j];\n\t\t\tcur.clear();cur.push_back(now);\n\t\t\tfor(int k1=1,k2=0;k1<ans[now].size() || k2<ans[temp].size();)\n\t\t\t{\n\t\t\t\tif (k1==ans[now].size() || k1<ans[now].size() &&\n\t\t\t\t    k2<ans[temp].size() && ans[now][k1]<ans[temp][k2])\n\t\t\t\t{\n\t\t\t\t    cur.push_back(ans[temp][k2]);\n\t\t\t\t    k2++;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcur.push_back(ans[now][k1]);\n\t\t\t\t\tk1++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tswap(cur,ans[now]);\n\t\t}\n\t}\n\t\n\tfor(int i=1;i<ans[n+1].size();i++)\n\t\tprintf(\"%d \",a[ans[n+1][i]]);\n\tprintf(\"\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define xx first\n#define yy second\n#define mp make_pair\n#define pb push_back\n#define mset(x, y) memset(x, y, sizeof x)\n#define mcpy(x, y) memcpy(x, y, sizeof x)\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ninline int Read()\n{\n\tint x = 0, f = 1, c = getchar();\n\tfor (; !isdigit(c); c = getchar())\n\t\tif (c == '-')\n\t\t\tf = -1;\n\tfor (;  isdigit(c); c = getchar())\n\t\tx = x * 10 + c - '0';\n\treturn x * f;\n}\n\nconst int MAXN = 2005;\n\nint n, a[MAXN], adj[MAXN][MAXN];\nvector <int> e[MAXN];\nbool v[MAXN];\n\ninline void Dfs(int x)\n{\n\tv[x] = 1;\n\tfor (int i = 0; i < n; i ++)\n\t\tif (adj[x][i] && !v[i])\n\t\t\te[x].pb(i), Dfs(i);\n}\n\ninline vector <int> Solve(int x)\n{\n\tvector <vector <int>> cur;\n\tvector <int> ret, t;\n\tfor (auto y : e[x])\n\t\tt = Solve(y), reverse(t.begin(), t.end()), cur.pb(t);\n\tif (x ^ n)\n\t\tret.pb(a[x]);\n\twhile (true)\n\t{\n\t\tint x = -1;\n\t\tfor (int i = 0; i < cur.size(); i ++)\n\t\t\tif (!cur[i].empty() && (!~x || cur[i].back() > cur[x].back()))\n\t\t\t\tx = i;\n\t\tif (x == -1)\n\t\t\treturn ret;\n\t\tret.pb(cur[x].back()), cur[x].pop_back();\n\t}\n}\n\nint main()\n{\n#ifdef wxh010910\n\tfreopen(\"data.in\", \"r\", stdin);\n#endif\n\tn = Read();\n\tfor (int i = 0; i < n; i ++)\n\t\ta[i] = Read();\n\tsort(a, a + n);\n\tfor (int i = 0; i < n; i ++)\n\t\tfor (int j = 0; j < i; j ++)\n\t\t\tif (__gcd(a[i], a[j]) ^ 1)\n\t\t\t\tadj[i][j] = adj[j][i] = 1;\n\tfor (int i = 0; i < n; i ++)\n\t\tif (!v[i])\n\t\t\te[n].pb(i), Dfs(i);\n\tvector <int> ret = Solve(n);\n\tfor (int i = 0; i < n; i ++)\n\t\tprintf(\"%d%c\", ret[i], i == n - 1 ? '\\n' : ' ');\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define X first\n#define Y second\n\nint gcd(int a,int b) {return b?gcd(b,a%b):a;}\n\nconst int maxn=4010;\n\nint n,times,a[maxn],dfn[maxn],deg[maxn];\nint tote,FIR[maxn],TO[maxn],NEXT[maxn];\nint vis[maxn];\npriority_queue<pair<int,int> > q;\n\nvoid addedge(int u,int v)\n{\n\tTO[++tote]=v;\n\tNEXT[tote]=FIR[u];\n\tFIR[u]=tote;\n}\n\nint search(int u)\n{\n\tint Ans=u;\n\tvis[u]=1;\n\tfor (int p=FIR[u];p;p=NEXT[p])\n\t{\n\t\tint v=TO[p];\n\t\tif (vis[v]) continue;\n\t\tint tmp=search(v);\n\t\tAns=a[Ans]<a[tmp]?Ans:tmp;\n\t}\n\treturn Ans;\n}\n\nvoid dfs(int u)\n{\n\tvis[u]=2;\n\tdfn[u]=++times;\n\tvector<pair<int,int> > son;\n\tson.clear();\n\tfor (int p=FIR[u];p;p=NEXT[p])\n\t\tson.push_back(make_pair(a[TO[p]],TO[p]));\n\tsort(son.begin(),son.end());\n\tfor (int i=0;i<(int)son.size();i++)\n\t\tif (vis[son[i].Y]!=2) dfs(son[i].Y);\n}\n\nint main()\n{\n#ifdef h10\n\tfreopen(\"E.in\",\"r\",stdin);\n\tfreopen(\"E.out\",\"w\",stdout);\n#endif\n\tint i,j;\n\tscanf(\"%d\",&n);\n\tfor (i=1;i<=n;i++)\n\t\tscanf(\"%d\",&a[i]);\n\treturn 0;\n\tfor (i=1;i<=n;i++)\n\tfor (j=i+1;j<=n;j++)\n\t\tif (gcd(a[i],a[j])!=1)\n\t\t\taddedge(i,j),addedge(j,i);\n\n\tvector<pair<int,int> > root;\n\tfor (i=1;i<=n;i++)\n\t\tif (!vis[i])\n\t\t{\n\t\t\tint tmp=search(i);\n\t\t\troot.push_back(make_pair(a[tmp],tmp));\n\t\t}\n\n\tsort(root.begin(),root.end());\n\tfor (i=0;i<(int)root.size();i++) dfs(root[i].Y);\n\n\ttote=0;\n\tmemset(FIR,0,sizeof(FIR));\n\tfor (i=1;i<=n;i++)\n\tfor (j=1;j<=n;j++)\n\t\tif (gcd(a[i],a[j])!=1&&dfn[i]<dfn[j])\n\t\t\taddedge(i,j),deg[j]++;\n\n\tfor (i=1;i<=n;i++)\n\t\tif (!deg[i]) q.push(make_pair(a[i],i));\n\twhile (!q.empty())\n\t{\n\t\tpair<int,int> u=q.top(); q.pop();\n\t\tprintf(\"%d \",u.X);\n\t\tfor (int p=FIR[u.Y];p;p=NEXT[p])\n\t\t{\n\t\t\tint v=TO[p];\n\t\t\tif (!(--deg[v])) q.push(make_pair(a[v],v));\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n//#include<ext/pb_ds/assoc_container.hpp>\n#pragma comment(linker, \"/STACK:16000000\")\n//#define map gp_hash_table\n#define PI 3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679\nusing namespace std;\n//using namespace __gnu_pbds;\nconst int inf=0x3f3f3f3f;\nconst long long inf2=0x3f3f3f3f3f3f3f3f;\nconst double eps=1e-6;\nconst int mod=1000000007;\nbool huzhi[2002][2002];\nint n;\npair<int,int> a[2002];\nint itr[2002];\nvector<vector<int> > vec;\nbool used[2002];\nvector<int> cur;\nvoid dfs(int x){\n\tused[x]=true;\n\tcur.push_back(a[x].first);\n\tfor(int i=1;i<=n;i++){\n\t\tif(used[i] || huzhi[i][x])continue;\n\t\tdfs(i);\n\t\treturn;\n\t}\n}\nbool ok(){\n\tfor(int i=0;i<vec.size();i++)if(itr[i]!=vec[i].size())return false;\n\treturn true;\n}\nint main(){\n\tvec.clear();\n\tios::sync_with_stdio(0);\n\tcin>>n;\n\tfor(int i=1;i<=n;i++)cin>>a[i].first,a[i].second=i;\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++)for(int j=1;j<=n;j++)if(__gcd(a[i].first,a[j].first)==1)huzhi[i][j]=true;\n\tfor(int i=1;i<=n;i++)if(!used[i]){\n\t\tcur.clear();\n\t\tdfs(i);\n\t\tvec.push_back(cur);\n\t}\n\tvector<int> ans;\n\twhile(!ok()){\n\t\tint mx=-1,pos=-1;\n\t\tfor(int i=0;i<vec.size();i++)if(vec[i][itr[i]]>mx)mx=vec[i][itr[i]],pos=i;\n\t\titr[pos]++;\n\t\tans.push_back(mx);\n\t}\n\tfor(int i=0;i<ans.size();i++)cout<<ans[i]<<\" \";\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint GCD(int a, int b){\n\treturn b == 0 ? a : GCD(b, a % b);\n}\n\nint a[2010];\nint gcd[2010][2010];\nvector <int> from[2010];\nvector <int> g[2010];\nvector <vector <int> > v;\nvector <int> path;\nint vis[2010];\nint in[2010];\n\nvoid dfs(int x){\n\tvis[x] = 1, path.push_back(x);\n\tfor (int i = 0; i < from[x].size(); i++){\n\t\tint v = from[x][i];\n\t\tif (vis[v]) continue;\n\t\tdfs(v);\n\t}\n}\n\nint tot;\n\nbool cmp(int x, int y){\n\treturn a[x] < a[y];\n}\n\nint SUM;\n\nint dfs2(int x){\n\tvis[x] = 1, path.push_back(x);\n\tif (path.size() == SUM) return 1;\n\tfor (int i = 0; i < from[x].size(); i++){\n\t\tint v = from[x][i];\n\t\tif (vis[v]) continue;\n\t\tif (dfs2(v)) return 1;\n\t}\n\tvis[x] = 0, path.pop_back();\n\treturn 0;\n}\n\nstruct Node{\n\tint x;\n\tNode(){}\n\tNode(int _x){x = _x;}\n\tbool operator < (const Node &A) const{\n\t\treturn a[x] < a[A.x];\n\t}\n};\n\npriority_queue <Node> q;\n\nint main(){\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++){\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tgcd[i][j] = GCD(a[i], a[j]);\n\t\t\tif (gcd[i][j] != 1) from[i].push_back(j), from[j].push_back(i);\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++){\n\t\tsort(from[i].begin(), from[i].end(), cmp);\n\t}\n\tfor (int i = 0; i < n; i++){\n\t\tif (vis[i]) continue;\n\t\tpath.clear();\n\t\tdfs(i);\n\t\tv.push_back(path);\n\t}\n\t/*\n\tfor (int i = 0; i < v.size(); i++){\n\t\tcout << i << \":\";\n\t\tfor (int j = 0; j < v[i].size(); j++){\n\t\t\tcout << \" \" << v[i][j];\n\t\t}\n\t\tcout << endl;\n\t}\n\t*/\n\tmemset(vis, 0, sizeof(vis));\n\tfor (int i = 0; i < v.size(); i++){\n//\t\tcout << i << \":\" << endl;\n\t\tsort(v[i].begin(), v[i].end(), cmp);\n\t\tSUM = v[i].size(), path.clear();\n\t\tfor (int j = 0; j < v[i].size(); j++){\n\t\t\tif (dfs2(v[i][j])) break;\n\t\t}\n//\t\tcout << \"  \";\n\t\tfor (int j = 0; j < path.size() - 1; j++){\n//\t\t\tcout << path[j] << \" \";\n\t\t\tg[path[j]].push_back(path[j + 1]);\n\t\t\tin[path[j + 1]]++;\n\t\t}\n//\t\tcout << path[path.size() - 1] << endl;\n\t}\n\tfor (int i = 0; i < n; i++){\n//\t\tcout << in[i] << endl;\n\t\tif (!in[i]) /*cout << i << endl, */q.push(Node(i));\n\t}\n\tvector <int> res;\n\twhile (!q.empty()){\n\t\tNode t = q.top(); q.pop();\n\t\tint u = t.x;\n//\t\tcout << u << endl;\n\t\tres.push_back(a[u]);\n\t\tfor (int i = 0; i < g[u].size(); i++){\n\t\t\tint v = g[u][i];\n\t\t\tin[v]--;\n\t\t\tif (in[v] == 0) q.push(Node(v));\n\t\t}\n\t}\n\tfor (int i = 0; i < res.size(); i++){\n\t\tprintf(\"%d \", res[i]);\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n \nusing namespace std;\n \n#define gc c=getchar()\n#define r(x) read(x)\n \ntemplate<typename T>\ninline void read(T&x){\n    x=0;T k=1;char gc;\n    while(!isdigit(c)){if(c=='-')k=-1;gc;}\n    while(isdigit(c)){x=x*10+c-'0';gc;}x*=k;\n}\n \nconst int N=2005;\n \nint gcd(int a,int b){\n\treturn b?gcd(b,a%b):a;\n}\n \nvector<int>G1[N];\nvector<int>G2[N];\n \nint a[N];\nint deg[N];\nbool vis[N];\n \nvoid dfs(int x){\n\tvis[x]=1;\n\tfor(int i=0;i<G1[x].size();++i){\n\t\tint v=G1[x][i];\n\t\tif(!vis[v]){\n\t\t\tG2[x].push_back(v);\n\t\t\tdeg[v]++;\n\t\t\tdfs(v);\n\t\t}\n\t}\n}\n \nint main(){\n//\tfreopen(\".in\",\"r\",stdin);\n//\tfreopen(\".out\",\"w\",stdout);\n\tint n;r(n);\n\tfor(int i=1;i<=n;++i)r(a[i]);\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;++i){\n\t\tfor(int j=i+1;j<=n;++j){\n\t\t\tif(gcd(a[i],a[j])!=1){\n\t\t\t\tG1[i].push_back(j);\n\t\t\t\tG1[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\tif(!vis[i]){\n\t\t\tdfs(i);\n\t\t}\n\t}\n\tpriority_queue<int>Q;\n\tfor(int i=1;i<=n;++i){\n\t\tif(!deg[i]){\n\t\t\tQ.push(i);\n\t\t}\n\t}\n\twhile(!Q.empty()){\n\t\tint x=Q.top();Q.pop();\n\t\tprintf(\"%d \",a[x]);\n\t\tfor(int i=0;i<G2[x].size();++i){\n\t\t\tint v=G2[x][i];\n\t\t\tif(!--deg[v]){\n\t\t\t\tQ.push(v);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#define rep(i,a,b) for(int i = a; i <= b; i++)\n#define dep(i,a,b) for(int i = a; i >= b; i--)\n#define Rep(i,a) for(int i = 0; i < a; i++)\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> pii;\n#define x first\n#define y second\n#define pb(a) push_back(a)\n\nconst int N = 2010;\n\nint n, a[N], d[N];\nstruct edge{ int to, pre; } e[(N * N) << 1]; int u[N], l = 0;\nvoid ins(int a, int b) { e[++l] = (edge){b, u[a]}, u[a] = l; d[b]++; }\n#define v e[i].to\n#define reg(i,a) for(int i = u[a]; i; i = e[i].pre)\n\nint gcd(int a, int b) { return b ? gcd(b, a % b) : a; }\n\ntypedef pair<int, int> pii;\n#define mp(a,b) make_pair(a,b)\npriority_queue<pii> q;\nvoid topsort() {\n\trep(i,1,n) if (!d[i]) q.push(mp(a[i], i));\n\twhile (!q.empty()) {\n\t\tint x = q.top().second; q.pop(); printf(\"%d \",a[x]);\n\t\treg(i,x) {\n\t\t\td[v]--;\n\t\t\tif (!d[v]) q.push(mp(a[v], v));\n\t\t}\n\t}\n\tprintf(\"\\n\");\n}\n\nint c[N][N]; bool vis[N];\nvoid dfs(int x) {\n\tvis[x] = true;\n\tvector<pii> ch;\n\trep(i,1,n) if (c[x][i] && !vis[i]) ins(x, i), dfs(i);\n}\n\nvoid build() {\n\tsort(a + 1, a + n + 1);\n\trep(i,1,n) rep(j,1,n) c[i][j] = (gcd(a[i], a[j]) > 1);\n\trep(i,1,n) if (!vis[i]) dfs(i);\n}\n\nint main() {\n\tscanf(\"%d\",&n);\n\trep(i,1,n) scanf(\"%d\", a + i);\n\tbuild();\n\ttopsort();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <vector>\n#include <cassert>\n#include <algorithm>\nusing namespace std;\n\nconst int N = 2005;\nbool G[N][N];\nbool used[N];\nvector <int> g[N];\nint n, a[N], sz;\nint in[N];\npriority_queue <int> pq;\n\ninline int gcd(int a, int b) { return !b ? a : gcd(b, a % b); }\n\nvoid dfs(int i) {\n\tused[i] = 1;\n\tfor (int j = 0; j < n; ++ j) if (!used[j] && G[i][j]) { g[i].push_back(j); ++ in[j]; dfs(j); }\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; ++ i) scanf(\"%d\", &a[i]);\n\tsort(a, a + n);\n\tfor (int i = 0; i < n; ++ i) for (int j = 0; j < n; ++ j) if (i ^ j) G[i][j] = (gcd(a[i], a[j]) != 1);\n\tfor (int i = 0; i < n; ++ i) if (!used[i]) dfs(i);\n\tfor (int i = 0; i < n; ++ i) if (!in[i]) pq.push(i);\n\twhile (!pq.empty()) {\n\t\tint i = pq.top(); pq.pop();\n\t\tprintf(\"%d \", a[i]);\n\t\tfor (int j = 0; j < (int) g[i].size(); ++ j) {\n\t\t\t-- in[g[i][j]];\n\t\t\tif (!in[g[i][j]]) pq.push(g[i][j]);\n\t\t}\n\t}\n\tputs(\"\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\n #define rep(i, a, b) for (int i = a; i <= b; i++)\n #define vep(i, v) for (int i = 0; i < (int)v.size(); i++)\n #define fill(a, x) memset(a, x, sizeof(a))\n #define pb push_back\n #define mp make_pair\n\n typedef vector<int> Vi;\n typedef pair<int, int> Pii;\n\n const int N = 1000 + 5, M = N * N, INF = 0x3f3f3f3f;\n\n int n, es, dfs_cnt;\n int a[N], pre[N], vis[N], fa[N], is_con[N];\n Vi comp[N], all, tmp;\n bool del[N];\n\n inline int gcd(int x, int y) { return (!y) ? x : gcd(y, x % y); }\n\n struct Edge { int from, to, pre; } e[M];\n inline void init_graph() { es = dfs_cnt = 0; fill(vis, 0); fill(pre, 0); fill(is_con, 0); }\n inline void ine(int a, int b) {\n \tint i = ++es;\n \te[i].from = a; e[i].to = b; e[i].pre = pre[a];\n \tpre[a] = i;\n }\n inline void ine2(int a, int b) { ine(a, b); ine(b, a); }\n #define reg(i, x) for (int i = pre[x]; i; i = e[i].pre)\n\n inline int find(int x) { return fa[x] == x ? x : fa[x] = find(fa[x]); }\n inline void do_union(int from, int to) {\n \tint fx = find(from), fy = find(to);\n \tif (fx != fy) fa[fy] = fx;\n }\n\n inline void merge(Vi &v1, Vi v2) {\n \tif (v1.empty()) { v1 = v2; return; }\n \tVi tmp;\n \tint p1 = 0, p2 = 0, s1 = v1.size(), s2 = v2.size();\n // printf(\"s1 = %d  s2 = %d\\n\", s1, s2);\n \twhile (p1 < s1 && p2 < s2) {\n \t\tint x = v1[p1], y = v2[p2];\n // printf(\"p1 = %d  p2 = %d  x = %d  y = %d\\n\", p1, p2, x, y);\n \t\tif (a[x] > a[y]) tmp.pb(x), p1++; else tmp.pb(y), p2++;\n // printf(\"ok\\n\");\n \t}\n\n \tif (p1 < s1) rep(i, p1, s1 - 1) tmp.pb(v1[i]);\n \telse rep(i, p2, s2 - 1) tmp.pb(v2[i]);\n \tv1 = tmp;\n }\n\n inline void dfs(int x, int dfs_id, Vi &list) {\n \tlist.pb(x);\n \tvis[x] = dfs_id;\n // printf(\"x = %d\\n  list.sz = %lu\\n\", x, list.size());\n // vep(i, list) printf(\"list[%d] = %d\\n\", i, list[i]);\n \treg(i, x) {\n \t\tint y = e[i].to;\n \t\tif (del[y] || vis[y] == dfs_id) continue;\n \t\tdfs(y, dfs_id, list);\n \t}\n }\n\n inline Vi solve_comp(int pa, Vi cop) {\n \tVi ret, res, tmp;\n \tret.clear();\n // vep(i, cop) printf(\"cop[%d] = %d\\n\", i, cop[i]); puts(\"\");\n \tif (cop.size() == 1) { del[cop[0]] = true; ret.pb(cop[0]); return ret; }\n \tPii minp = mp(INF, 0);\n \tvep(i, cop) {\n \t\tint x = cop[i];\n // printf(\"x = %d  is_con[x] = %d\\n\", x, is_con[x]);\n \t\tif (is_con[x] != pa) continue;\n \t\tminp = min(minp, mp(a[x], x));\n \t}\n // printf(\"minp.first = %d\\n\\n\", minp.first);\n \tint sel = minp.second;\n \tdel[sel] = true;\n \tret.clear();\n \tret.pb(0);\n \treg(i, sel) {\n \t\tint y = e[i].to;\n // printf(\"sel = %d  y = %d  del = %d\", sel, y, del[y]);\n \t\tif (!del[y]) is_con[y] = sel;\n \t}\n // puts(\"\");\n // printf(\"pa = %d\\n\", pa);\n \tvep(i, cop) {\n \t\tint y = cop[i];\n \t\ttmp.clear();\n // printf(\"y = %d  del = %d\\n\", y, del[y]);\n \t\tif (!del[y]) {\n \t\t\tdfs(y, ++dfs_cnt, tmp);\n // printf(\"tmp.size = %lu\\n\", tmp.size());\n \t\t\tres = solve_comp(sel, tmp);\n // puts(\"86\");\n \t\t\tmerge(ret, res);\n \t\t}\n \t}\n // puts(\"87\");\n\n \tret[0] = sel;\n // printf(\"pa = %d  cop.size = %lu  sel = %d\\n\", pa, cop.size(), sel);\n // vep(i, ret) printf(\"ret[%d] = %d\\n\", i, ret[i]); puts(\"---------\");\n \treturn ret;\n }\n\nint main()\n{\n\tfreopen(\"atc2306.in\", \"r\", stdin);\n\n\tscanf(\"%d\", &n);\n\ta[0] = INF;\n\trep(i, 1, n) scanf(\"%d\", &a[i]), fa[i] = i, comp[i].clear();\n\n\tinit_graph();\n\trep(i, 1, n - 1) rep(j, i + 1, n)\n\t\tif (gcd(a[i], a[j]) > 1) ine2(i, j);\n\n\tfor (int i = 1; i < es; i += 2) do_union(e[i].from, e[i].to);\n\trep(i, 1, n) comp[fa[i]].pb(i);\n\t// rep(i, 1, n) printf(\"fa[%d] = %d\\n\", i, fa[i]);\n\n\tfill(del, false);\n\tall.clear();\n\trep(i, 1, n) if (!del[i]) {\n\t\ttmp = solve_comp(0, comp[fa[i]]);\n\n\t\tmerge(all, tmp);\n// printf(\"i = %d\\n\", i);\n// vep(i, all) printf(\"all[%d] = %d\\n\", i, all[i]);\n// puts(\"Line 136\\n\");\n\t}\n\n\trep(i, 0, n - 2) printf(\"%d \", a[all[i]]);\n\tprintf(\"%d\\n\", a[all[n - 1]]);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 2010\n#define ll long long\n#define db double\n#define For(i,x,y) for(int i=(x);i<=(y);++i)\n#define Rof(i,x,y) for(int i=(x);i>=(y);--i)\n#define Edge(x) for(int i=head[x];i;i=e[i].nxt)\n#define lson l,mid,o<<1\n#define rson mid+1,r,o<<1|1\n#define mset(x,y) memset(x,y,sizeof(y))\n#define mcpy(x,y) memcpy(x,y,sizeof(x))\n#define p_b push_back\nusing namespace std;\nint a[N],deg[N],head[N],n,cnt;\nbool vis[N];\nint gcd(int x,int y){\n\tif(x<y) swap(x,y);\n\treturn x%y?gcd(y,x%y):y;\n}\nstruct abc{\n\tint id,val;\n\tbool operator <(const abc &x)const{ return val<x.val; }\n};\npriority_queue<abc> q;\nstruct ed{\n\tint v,nxt;\n}e[N*N];\nvoid add(int u,int v){ e[++cnt]=(ed){v,head[u]},head[u]=cnt; }\nvoid dfs(int x,int id){\n\tvis[id]=1;\n\tFor(i,1,n) if(!vis[i] && gcd(x,a[i])!=1){\n\t\tadd(id,i),deg[i]++,dfs(a[i],i);\n\t}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tFor(i,1,n) scanf(\"%d\",&a[i]);\n\tsort(a+1,a+n+1);\n\tFor(i,1,n) if(!vis[i]) dfs(a[i],i);\n\tFor(i,1,n) if(!deg[i]) q.push((abc){i,a[i]});\n\twhile(!q.empty()){\n\t\tabc x=q.top();q.pop();\n\t\tprintf(\"%d \",x.val);\n\t\tEdge(x.id){\n\t\t\tint to=e[i].v;\n\t\t\tdeg[to]--;\n\t\t\tif(!deg[to]) q.push((abc){to,a[to]}); \n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\nstruct UnionFind {\n    int n, cc, *u;\n    UnionFind() : n(0), cc(0), u(NULL) {}\n    UnionFind(int n_) : n(n_), cc(n_) {\n\tu = new int[n_];\n\tmemset(u, -1, sizeof (int) * n);\n    }\n    UnionFind(const UnionFind &y) : n(y.n), cc(y.cc) {\n\tu = new int[y.n];\n\tmemcpy(u, y.u, sizeof (int) * n);\n    }\n    ~UnionFind() {\n\tdelete[] u; u = NULL;\n\tn = cc = 0;\n    }\n    friend void swap(UnionFind &x, UnionFind &y) {\n\tswap(x.n, y.n); swap(x.cc, y.cc); swap(x.u, y.u);\n    }\n    UnionFind& operator=(UnionFind y) { \n\tswap(*this, y);\n\treturn *this;\n    }\n    int root(int x) {\n\tint y = x, t;\n\twhile (u[y] >= 0) y = u[y];\n\twhile (x != y) { t = u[x]; u[x] = y; x = t; }\n\treturn y;\n    }\n    bool link(int x, int y) {\n\tx = root(x); y = root(y);\n\tif (x == y) return false;\n\tif (u[y] < u[x]) swap(x, y);\n\tu[x] += u[y]; u[y] = x; cc--;\n\treturn true;\n    }\n    bool same(int x, int y) { return root(x) == root(y); }\n    int size(int x) { return -u[root(x)]; }\n    int count() { return cc; }\n};\n\nint N;\nint A[2011];\nVI G[2011];\nint L[2011];\nVI ans;\n\nvoid MAIN() {\n    scanf(\"%d\", &N);\n    REP (i, N) scanf(\"%d\", A+i);\n\n    {\n\tUnionFind U(N);\n\tREP (i, N) REP (j, N) if (__gcd(A[i], A[j]) > 1) U.link(i, j);\n\n\tREP (i, N) G[U.root(i)].push_back(A[i]);\n    }\n\n    priority_queue<pair<int, int> > Q;\n    REP (i, N) if (!G[i].empty()) {\n\tsort(G[i].begin(), G[i].end());\n\tQ.emplace(G[i][0], i);\n    }\n\n\n    while (!Q.empty()) {\n\tint value = Q.top().first;\n\tint idx = Q.top().second;\n\tQ.pop();\n\tans.push_back(value);\n\n\tint m = G[idx].size();\n\tif (m > 1) {\n\t    UnionFind U(m);\n\t    for (int i=1; i<m; i++) for (int j=1; j<m; j++) if (__gcd(G[idx][i], G[idx][j]) > 1) {\n\t\tU.link(i, j);\n\t    }\n\n\t    for (int i=1; i<m; i++) if (U.root(i) == i) {\n\t\tVI v;\n\t\tfor (int j=1; j<m; j++) if (U.same(i, j)) {\n\t\t    v.push_back(G[idx][j]);\n\t\t}\n\t\tint head = -1;\n\t\tREP (j, v.size()) if (__gcd(value, v[j]) > 1) {\n\t\t    if (head == -1 || v[head] > v[j]) {\n\t\t\thead = j;\n\t\t    }\n\t\t}\n\n\t\tswap(v[0], v[head]);\n\t\tG[idx] = v;\n\t\tQ.emplace(v[0], idx);\n\t    }\n\t}\n    }\n\n    rprintf(\"%d\", ans.begin(), ans.end());\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pii pair <int, int>\n\nusing namespace std;\n\nconst int N = 2005, M = 4005;\nint n, a[N], edge[N][N], ans[N], root[N], sz[N], b[N], ed[N], fa[N];\nbool vis[N];\n\nint gcd(int x, int y) {\n    if (y == 0) return x;\n    return gcd(y, x % y);\n}\n\n\nvoid dfs(int x) {\n    vis[x] = 1;\n    sz[x] = 1;\n    for (int xx = 1; xx <= n; xx++) {\n        if (edge[x][xx] && !vis[xx]) {\n            dfs(xx);\n            sz[x] += sz[xx];\n        }\n    }\n}\n\nvoid solve(int x, int l, int r)\n{\n    priority_queue <pii> q;\n    vis[x] = 1;\n    int now = l;\n    for (int xx = 1; xx <= n; xx++) {\n        if (edge[x][xx] && !vis[xx]) {\n            solve(xx, now + 1, now + sz[xx]);\n            q.push(pii(ans[now + 1], now + 1));\n            now += sz[xx];\n        }\n    }\n    now = 0;\n    while (!q.empty()) {\n        pii xx = q.top();\n        q.pop();\n        b[++now] = xx.first;\n        if (xx.second < ed[xx.second]) {\n            q.push(pii(ans[xx.second + 1], xx.second + 1));\n        }\n    }\n    ans[l] = a[x];\n    ed[l] = r;\n    for (int i = l + 1; i <= r; i++) {\n        ans[i] = b[i - l];\n        ed[i] = r;\n    }\n}\n\nint main() {\n    cin >> n;\n    for (int i = 1; i <= n; i++) {\n        cin >> a[i];\n    }\n    sort(a + 1, a + n + 1);\n    for (int i = 1; i <= n; i++) {\n        for (int j = i + 1; j <= n; j++) {\n            if (gcd(a[i], a[j]) > 1) {\n                edge[i][j] = 1;\n                edge[j][i] = 1;\n            }\n        }\n    }\n    for (int i = 1; i <= n; i++) {\n        if (!vis[i]) {\n            dfs(i);\n            edge[0][i] = 1;\n            edge[i][0] = 1;\n        }\n    }\n    memset(vis, 0, szof(vis));\n    solve(0, 0, n);\n    for (int i = 1; i < n; i++) {\n        cout << ans[i] << \" \";\n    }\n    cout << ans[n] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 0x3f3f3f3f;\n\nint GCD(int a, int b){\n\treturn b == 0 ? a : GCD(b, a % b);\n}\n\nint a[2010];\nint gcd[2010][2010];\nvector <int> from[40010];\nint ans[2010];\nint c[40010], in_ans[2010], minj[2010], last[2010], best[2010];\nint C, n;\n\nvoid dfs(int x){\n\tc[x] = C;\n\tfor (int i = 0; i < from[x].size(); i++){\n\t\tint v = from[x][i];\n\t\tif (c[v] != -1 || v < n && in_ans[v]) continue;\n\t\tdfs(v);\n\t}\n}\n\nvoid color(){\n\tC = 0;\n\tmemset(c, -1, sizeof(c));\n\tfor (int i = 0; i < n; i++){\n\t\tif (c[i] != -1 || in_ans[i]) continue;\n\t\tdfs(i), C++;\n\t}\n}\n\nmap <int, int> mp;\nint m;\n\nint id(int x){\n\tif (!mp.count(x)){\n\t\tm++, mp[x] = m - 1;\n\t\treturn m - 1;\n\t}\n\treturn mp[x];\n}\n\nint main(){\n\tscanf(\"%d\", &n);\n\tm = n;\n\tfor (int i = 0; i < n; i++){\n\t\tscanf(\"%d\", &a[i]);\n\t\tint t = a[i];\n\t\tfor (int j = 2; j * j <= t; j++){\n\t\t\tif (t % j == 0){\n\t\t\t\tfrom[id(j)].push_back(i);\n\t\t\t\tfrom[i].push_back(id(j));\n\t\t\t\twhile (t % j == 0) t /= j;\n\t\t\t}\n\t\t}\n\t\tif (t != 1){\n\t\t\tfrom[i].push_back(id(t));\n\t\t\tfrom[id(t)].push_back(i);\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++){\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tgcd[i][j] = GCD(a[i], a[j]) != 1;\n\t\t}\n\t}\n\tfor (int i = 0; i <= n; i++){\n\t\tminj[i] = INF, last[i] = -1;\n\t}\n\tint tot = 0;\n\twhile (tot != n){\n\t\tcolor();\n\t\tfor (int i = 0; i < C; i++){\n\t\t\tbest[i] = -1;\n\t\t}\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tif (in_ans[i]) continue;\n\t\t\tif (minj[last[i] + 1] < a[i]) continue;\n//\t\t\tcout << i << \" \";\n\t\t\tif (best[c[i]] == -1 || a[best[c[i]]] > a[i]) best[c[i]] = i;\n\t\t}\n\t\tint id = -1;\n\t\tfor (int i = 0; i < C; i++){\n\t\t\tif (best[i] == -1) continue;\n\t\t\tif (id == -1 || a[id] < a[best[i]]) id = best[i];\n\t\t}\n\t\tif (id == -1) throw;\n\t\tin_ans[id] = 1, ans[tot++] = a[id];\n\t\tfor (int i = 0; i < tot; i++){\n\t\t\tminj[i] = min(minj[i], a[id]);\n\t\t}\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tif (gcd[id][i]) last[i] = tot - 1;\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++){\n\t\tprintf(\"%d \", ans[i]);\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint gcd(int a, int b){\n\treturn b == 0 ? a : gcd(b, a % b);\n}\n\nvector <int> combine(const vector <int> &a, const vector <int> &b){\n\tvector <int> res(a.size() + b.size());\n\tmerge(a.begin(), a.end(), b.begin(), b.end(), res.begin(), greater <int>());\n}\n\nint vis[2010];\nint n, e[2010][2010];\nint a[2010];\n\nvector <int> dfs(int x){\n\tvis[x] = 1;\n\tvector <int> res;\n\tfor (int v = 0; v < n; v++){\n\t\tif (vis[v] || !e[x][v]) continue;\n\t\tres = combine(res, dfs(v));\n\t}\n\treturn res;\n}\n\nint main(){\n\tscanf(\"%d\", n);\n\tfor (int i = 0; i < n; i++){\n\t\tscanf(\"%d\", &a[i]);\n\t}\n\tfor (int i = 0; i <= n; i++){\n\t\tfor (int j = 0; j <= n; j++){\n\t\t\te[i][j] = i != j && (i == n || j == n || gcd(a[i], a[j]) != 1);\n\t\t}\n\t}\n\tvector <int> res = dfs(n);\n\tfor (int i = 0; i < n; i++){\n\t\tprintf(\"%d \", res[i]);\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\nusing namespace std;\nint gcd(int a, int b)\n{\n\tfor (;;)\n\t{\n\t\tif (a < b)swap(a, b);\n\t\ta %= b;\n\t\tif (a == 0)return b;\n\t}\n}\nset<int>se;\nvoid bun(int a)\n{\n\tfor (int i = 2;; i++)\n\t{\n\t\tif (i*i>a)break;\n\t\tfor (;;)\n\t\t{\n\t\t\tif (a%i == 0)a /= i, se.insert(i);\n\t\t\telse break;\n\t\t}\n\t}\n\tif (a != 1)se.insert(a);\n}\nvector<int>ps;\nvector<int>pat[100000];\nvector<int>v;\nvector<int>merge(vector<int>a, vector<int>b)\n{\n\tvector<int>r;\n\ta.push_back(-1);\n\tb.push_back(-1);\n\tint pa = 0, pb = 0;\n\tfor (int i = 0; i < a.size() + b.size() - 2; i++)\n\t{\n\t\tif (a[pa] > b[pb])r.push_back(a[pa]), pa++;\n\t\telse r.push_back(b[pb]), pb++;\n\t}\n\treturn r;\n}\n#define SIZE 12000\nclass unionfind\n{\npublic:\n\tint par[SIZE];\n\tint ran[SIZE];\n\tint ren[SIZE];\n\tvoid init()\n\t{\n\t\tfor (int i = 0; i<SIZE; i++)\n\t\t{\n\t\t\tpar[i] = i;\n\t\t\tran[i] = 0;\n\t\t\tren[i] = 1;\n\t\t}\n\t}\n\tint find(int a)\n\t{\n\t\tif (a == par[a])return a;\n\t\telse return par[a] = find(par[a]);\n\t}\n\tvoid unite(int a, int b)\n\t{\n\t\ta = find(a);\n\t\tb = find(b);\n\t\tif (a == b)return;\n\t\tif (ran[a]>ran[b])\n\t\t{\n\t\t\tpar[b] = a;\n\t\t\tren[a] += ren[b];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpar[a] = b;\n\t\t\tren[b] += ren[a];\n\t\t}\n\t\tif (ran[a] == ran[b])ran[b]++;\n\t}\n};\nunionfind uf;\nint num;\nbool isok[2000];\nvector<int>calc(vector<int>idx, int las)\n{\n\tif (idx.empty())return idx;\n\tint rrr = rand();\n\t//printf(\"%d-------\\n\", rrr);\n\t//for (int i = 0; i < idx.size(); i++)printf(\"%d \", v[idx[i]]); printf(\"\\n\");\n\tuf.init();\n\tfor (int i = 0; i < idx.size(); i++)for (int j = 0; j < pat[idx[i]].size(); j++)uf.unite(idx[i], pat[idx[i]][j]);\n\tmap<int, vector<int> >ma;\n\tfor (int i = 0; i < idx.size(); i++)ma[uf.find(idx[i])].push_back(idx[i]);\n\tint maxi = 0;\n\tint rr = -1;\n\tmap<int, vector<int> >::iterator it = ma.begin();\n\tfor (int p = 0;; p++)\n\t{\n\t\tif (it == ma.end())break;\n\t\tvector<int>z = (*it).second;\n\t\tit++;\n\t\tint mini = 1000000000;\n\t\tfor (int i = 0; i < z.size(); i++)\n\t\t{\n\t\t\tif (isok[z[i]])mini = min(mini, v[z[i]]);\n\t\t}\n\t\tif (mini > maxi)maxi = mini, rr = p;\n\t}\n\t//printf(\" %d\\n\", maxi);\n\tit = ma.begin();\n\tvector<int>ans;\n\tfor (int p = 0;; p++)\n\t{\n\t\tif (it == ma.end())break;\n\t\tvector<int>z = (*it).second;\n\t\tit++;\n\t\tif (p == rr)\n\t\t{\n\t\t\tint t;\n\t\t\tfor (int i = 0; i < z.size(); i++)if (v[z[i]] == maxi)t = i;\n\t\t\tvector<int>zz;\n\t\t\tfor (int i = 0; i < z.size(); i++)if (t != i)zz.push_back(z[i]);\n\t\t\tz = zz;\n\t\t}\n\t\tfor (int i = 0; i < z.size(); i++)\n\t\t{\n\t\t\tif (isok[z[i]])\n\t\t\t{\n\t\t\t\tif (maxi < v[z[i]] && gcd(maxi, v[z[i]]) == 1)isok[z[i]] = false;\n\t\t\t\telse isok[z[i]] = true;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (gcd(maxi, v[z[i]]) != 1)isok[z[i]] = true;\n\t\t\t\telse isok[z[i]] = false;\n\t\t\t}\n\t\t}\n\t\t//for (int i = 0; i < z.size(); i++)printf(\"   %d\", v[z[i]]); printf(\"\\n\");\n\t\tvector<int>t = calc(z, maxi);\n\t\t//for (int i = 0; i < t.size(); i++)printf(\"%d \", t[i]); printf(\"\\n\");\n\t\tans = merge(ans, t);\n\t}\n\treverse(ans.begin(), ans.end());\n\tans.push_back(maxi);\n\treverse(ans.begin(), ans.end());\n\t//printf(\"-----%d\\n\", rrr);\n\treturn ans;\n}\nint main()\n{\n\tscanf(\"%d\", &num);\n\tfor (int i = 0; i < num; i++)\n\t{\n\t\tint z;\n\t\tscanf(\"%d\", &z);\n\t\tv.push_back(z);\n\t\tbun(z);\n\t}\n\tset<int>::iterator it = se.begin();\n\tfor (;;)\n\t{\n\t\tif (it == se.end())break;\n\t\tps.push_back(*it);\n\t\tit++;\n\t}\n\tfor (int i = 0; i < num; i++)for (int j = 0; j < ps.size(); j++)if (v[i] % ps[j] == 0)pat[i].push_back(j + num);\n\tvector<int>z;\n\tfor (int i = 0; i < num; i++)z.push_back(i);\n\tfill(isok, isok + num, true);\n\tvector<int>r = calc(z, 1000000000);\n\tfor (int i = 0; i < num; i++)printf(\"%d \", r[i]);\n\tprintf(\"\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<cstring>\n#include<algorithm>\n#define ll long long\nusing namespace std;\nconst int N=5010,P=998244353;\ninline char gc(){\n    static char buf[N],*s=buf,*t=buf;\n    return s==t&&(t=(s=buf)+fread(buf,1,N,stdin),s==t)?EOF:*s++;\n}\ninline int read(){\n\tint x=0,f=0,c=getchar();\n\tfor(;c>'9'||c<'0';f=c=='-',c=getchar());\n\tfor(;c>='0'&&c<='9';c=getchar())\n\tx=(x<<1)+(x<<3)+c-'0';return f?-x:x;\n}\ninline void write(ll x){\n\tif(x<0)putchar('-'),x=-x;\n\tif(x>9)write(x/10);putchar(x%10+'0');\n}\nint n,a[N],du[N],L,h[N],ne[N*N],to[N*N],v[N],e[N][N];\n#include<queue>\nstruct cmp{bool operator() (int x,int y){return a[x]<a[y];}};\npriority_queue<int,vector<int>,cmp>q;\ninline void addl(int x,int y){\n\tne[++L]=h[x];h[x]=L;to[L]=y;du[y]++;\n}\nvoid dfs(int x){\n\tv[x]=1;\n\tfor(int y=1;y<=n;y++)\n\tif(!v[y]&&e[x][y])addl(x,y),dfs(y);\n}\nint main(){\n\tint i,k,x;\n\tn=read();\n\tfor(i=1;i<=n;i++)a[i]=read();\n\tsort(a+1,a+n+1);\n\tfor(i=1;i<=n;i++)\n\tfor(k=i+1;k<=n;k++)\n\tif(__gcd(a[i],a[k])>1)e[i][k]=e[k][i]=1;\n\tfor(i=1;i<=n;i++)if(!v[i])dfs(i);\n\tfor(i=1;i<=n;i++)if(!du[i])q.push(i);\n\tfor(i=1;i<=n;i++){\n\t\tx=q.top();q.pop();\n\t\tprintf(\"%d \",a[x]);\n\t\tfor(k=h[x];k;k=ne[k])\n\t\tif(!(--du[to[k]]))q.push(to[k]);\n\t}puts(\"\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint gcd(int a, int b){\n    return b==0 ? a : gcd(b, a%b);\n}\nvector<int> prime_factor(int n){\n    vector<int> ret;\n    for(int i=2; i*i<=n; i++){\n        if(n % i == 0){\n            while(n % i == 0) n /= i;\n            ret.push_back(i);\n        }\n    }\n    if(n > 1) ret.push_back(n);\n    return ret;\n}\n\nint main(){\n    int N;\n    cin >> N;\n    vector<int> A(N);\n    for(int i=0; i<N; i++) cin >> A[i];\n    sort(A.begin(), A.end());\n\n    vector<vector<int>> primes(N);\n    for(int i=0; i<N; i++) primes[i] = prime_factor(A[i]);\n\n    bitset<2000> dead;\n    vector<int> ans;\n\n    auto check = [&](int pt)->bool{\n        set<int> stl, stm;\n        for(int i=0; i<=pt; i++) if(!dead[i]) for(int p : primes[i]) stl.insert(p);\n        for(int i=pt+1; i<N; i++) if(!dead[i]){\n            for(int p : primes[i]) if(stl.count(p)){\n                for(int p : primes[i]) stm.insert(p);\n                break;\n            }\n        }\n        for(int i=pt+1; i<N; i++) if(!dead[i]){\n            bool ng = true;\n            for(int p : primes[i]) if(stm.count(p)){\n                ng = false;\n                break;\n            }\n            if(ng) return false;\n        }\n        return true;\n    };\n\n    auto check2 = [&](int ok)->bool{\n        int pt = int(ans.size())-1;\n        while(pt >= 0 && gcd(ans[pt], A[ok]) == 1){\n            if(ans[pt] < A[ok]){\n                return false;\n            }else{\n                pt--;\n            }\n        }\n        return true;\n    };\n\n    while(ans.size() < N){\n        int ok = N-1, ng = -1;\n        while(ok-ng>1){\n            int mid = (ok+ng)/2;\n            (check(mid) ? ok : ng) = mid;\n        }\n        while(!check2(ok)){\n            ok++;\n            while(dead[ok]) ok++;\n        }\n        ans.push_back(A[ok]);\n        dead[ok] = 1;\n    }\n\n    for(int i=0; i<N; i++) cout << ans[i] << \" \\n\"[i==N-1];\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define LL long long\n#define db double\n\nusing namespace std;\nconst int N=2000+10;\nint rd()\n{\n    int x=0,w=1;char ch=0;\n    while(ch<'0'||ch>'9'){if(ch=='-') w=-1;ch=getchar();}\n    while(ch>='0'&&ch<='9'){x=x*10+(ch^48);ch=getchar();}\n    return x*w;\n}\nint to[N<<5],nt[N<<5],hd[N<<4],tot=1;\nvoid adde(int x,int y)\n{\n\t++tot,to[tot]=y,nt[tot]=hd[x],hd[x]=tot;\n\t++tot,to[tot]=x,nt[tot]=hd[y],hd[y]=tot;\n}\nint n,t,a[N],vs[N<<4],mk[N<<4],ti,ban[N<<4],dl[N],sq[N],ts,ff[N];\nint findf(int x){return ff[x]==x?x:ff[x]=findf(ff[x]);}\nvector<int> an[N],ls,nl;\nmap<int,int> id;\nvoid clr(int x)\n{\n\tmk[x]=ti,vs[x]=vs[0];\n\tfor(int i=hd[x];i;i=nt[i])\n\t{\n\t\tint y=to[i];\n\t\tif(ban[i>>1]||mk[y]==ti) continue;\n\t\tclr(y);\n\t}\n}\n\nint main()\n{\n/////////////\n\tn=rd(),t=n;\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\ta[i]=rd();\n\t\tint x=a[i],sqt=sqrt(x);\n\t\tfor(int j=2;j<=sqt;++j)\n\t\t\tif(x%j==0)\n\t\t\t{\n\t\t\t\tif(!id[j]) id[j]=++t;\n\t\t\t\tadde(i,id[j]);\n\t\t\t\twhile(x%j==0) x/=j;\n\t\t\t}\n\t\tif(x>1)\n\t\t{\n\t\t\tif(!id[x]) id[x]=++t;\n\t\t\tadde(i,id[x]);\n\t\t}\n\t}\n\tmemset(vs,0x3f3f3f,sizeof(vs));\n\ta[0]=1<<30;\n\tint rs=n;\n\twhile(rs--)\n\t{\n\t\tint sx=0;\n\t\tfor(int i=1;i<=n;++i)\n\t\t\tif(!dl[i]&&vs[sx]>vs[i]) sx=i;\n\t\tif(!sx)\n\t\t{\n\t\t\tfor(int i=1;i<=n;++i)\n\t\t\t\tif(!dl[i]&&a[sx]>a[i]) sx=i;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor(int i=1;i<=n;++i)\n\t\t\t\tif(!dl[i]&&vs[i]==vs[sx]&&a[sx]>a[i]) sx=i;\n\t\t}\n\t\tdl[sx]=1,sq[++ts]=sx;\n\t\t++ti,clr(sx);\n\t\tfor(int i=hd[sx];i;i=nt[i])\n\t\t{\n\t\t\tint y=to[i];\n\t\t\tban[i>>1]=1;\n\t\t\tfor(int j=hd[y];j;j=nt[j])\n\t\t\t{\n\t\t\t\tif(ban[j>>1]) continue;\n\t\t\t\tint z=to[j];\n\t\t\t\tvs[z]=ts;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;++i) ff[i]=i,an[i].push_back(a[i]);\n\twhile(ts)\n\t{\n\t\tint x=sq[ts--];\n\t\tls.clear();\n\t\tfor(int i=hd[x];i;i=nt[i])\n\t\t{\n\t\t\tint y=to[i];\n\t\t\tban[i>>1]=0;\n\t\t\tfor(int j=hd[y];j;j=nt[j])\n\t\t\t{\n\t\t\t\tif(ban[j>>1]) continue;\n\t\t\t\tint z=to[j];\n\t\t\t\tif((z=findf(z))!=findf(x))\n\t\t\t\t{\n\t\t\t\t\tint nn=ls.size(),mm=an[z].size(),p=0,q=0,r=0;\n\t\t\t\t\tnl.clear(),nl.resize(nn+mm);\n\t\t\t\t\twhile(p<nn&&q<mm)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(ls[p]>an[z][q]) nl[r++]=ls[p],++p;\n\t\t\t\t\t\telse nl[r++]=an[z][q],++q;\n\t\t\t\t\t}\n\t\t\t\t\twhile(p<nn) nl[r++]=ls[p],++p;\n\t\t\t\t\twhile(q<mm) nl[r++]=an[z][q],++q;\n\t\t\t\t\tls=nl;\n\t\t\t\t\tff[z]=x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint nn=ls.size();\n\t\tfor(int i=0;i<nn;++i) an[x].push_back(ls[i]);\n\t}\n\tls.clear();\n\tfor(int i=1;i<=n;++i)\n\t\tif(findf(i)==i)\n\t\t{\n\t\t\tint nn=ls.size(),mm=an[i].size(),p=0,q=0,r=0;\n\t\t\tnl.clear(),nl.resize(nn+mm);\n\t\t\twhile(p<nn&&q<mm)\n\t\t\t{\n\t\t\t\tif(ls[p]>an[i][q]) nl[r++]=ls[p],++p;\n\t\t\t\telse nl[r++]=an[i][q],++q;\n\t\t\t}\n\t\t\twhile(p<nn) nl[r++]=ls[p],++p;\n\t\t\twhile(q<mm) nl[r++]=an[i][q],++q;\n\t\t\tls=nl;\n\t\t}\n\tfor(int i=0;i<n;++i) printf(\"%d \",ls[i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n#include <time.h>\n#include <stdlib.h>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <algorithm>\n#include <sstream>\n#include <stack>\n#include <iomanip>\nusing namespace std;\n#define pb push_back\n#define mp make_pair\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef double ld;\ntypedef vector<int> vi;\n#define fi first\n#define se second\n#define fe first\n#define FO(x) {freopen(#x\".in\",\"r\",stdin);freopen(#x\".out\",\"w\",stdout);}\n#define Edg int M=0,fst[SZ],vb[SZ],nxt[SZ];void ad_de(int a,int b){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;}void adde(int a,int b){ad_de(a,b);ad_de(b,a);}\n#define Edgc int M=0,fst[SZ],vb[SZ],nxt[SZ],vc[SZ];void ad_de(int a,int b,int c){++M;nxt[M]=fst[a];fst[a]=M;vb[M]=b;vc[M]=c;}void adde(int a,int b,int c){ad_de(a,b,c);ad_de(b,a,c);}\n#define es(x,e) (int e=fst[x];e;e=nxt[e])\n#define esb(x,e,b) (int e=fst[x],b=vb[e];e;e=nxt[e],b=vb[e])\n#define SZ 8888888\nint n,a[SZ]; vector<int> adj[SZ];\nbool vv[SZ];\nvector<int> mg(vector<int> a,vector<int> b)\n{\n\tint ap=0,bp=0; vector<int> v;\n\twhile(ap<a.size()&&bp<b.size())\n\t{\n\t\tif(a[ap]>b[bp]) v.pb(a[ap++]);\n\t\telse v.pb(b[bp++]);\n\t}\n\twhile(ap<a.size()) v.pb(a[ap++]);\n\twhile(bp<b.size()) v.pb(b[bp++]);\n\treturn v;\n}\nvector<int> vs[SZ];\nvoid dfs(int x)\n{\n\tvv[x]=1; vector<int> w;\n\tfor(auto b:adj[x]) if(!vv[b])\n\t\tdfs(b), w=mg(w,vs[b]);\n\tw.insert(w.begin(),a[x]);vs[x]=w;\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;++i)\n\t\tscanf(\"%d\",a+i);\n\tsort(a+1,a+1+n);\n\tfor(int i=n;i>=1;--i)\n\t\tfor(int j=1;j<i;++j)\n\t\t\tif(__gcd(a[i],a[j])>1)\n\t\t\t\tadj[i].pb(j),adj[j].pb(i);\n\tfor(int i=1;i<=n;++i) adj[0].pb(i);\n\tfor(int i=0;i<=n;++i)\n\t\tsort(adj[i].begin(),adj[i].end());\n\tdfs(0);/*\n\tfor(int i=0;i<=n;++i)\n\t{\n\t\tfor(auto j:vs[i]) cout<<j<<\",\";\n\t\tcout<<\"\\n\";\n\t}*/\n\tfor(int i=1;i<=n;++i)\n\t\tprintf(\"%d \",vs[0][i]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n\nnamespace nygdr\n{\n\tint gcd(int a,int b){return b?gcd(b,a%b):a;}\n\tconst int N=2010,M=N*N*2;\n\tint begin[N],next[M],to[M];\n\tint A[N];\n\tint n,e;\n\tvoid add(int x,int y,bool k=1)\n\t{\n\t\tto[++e]=y;\n\t\tnext[e]=begin[x];\n\t\tbegin[x]=e;\n\t\tif(k)add(y,x,0);\n\t}\n\tbool vis[N];\n\tint predfs(int p)\n\t{\n\t\tvis[p]=1;\n\t\tint ret=p;\n\t\tfor(int i=begin[p],q;i;i=next[i])\n\t\t\tif(!vis[q=to[i]])\n\t\t\t{\n\t\t\t\tq=predfs(q);\n\t\t\t\tif(A[q]<A[ret])ret=q;\n\t\t\t}\n\t\treturn ret;\n\t}\n\tvoid initialize()\n\t{\n\t\tscanf(\"%d\",&n);\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tscanf(\"%d\",A+i);\n\t\t\tfor(int j=1;j<i;j++)\n\t\t\t\tif(gcd(A[i],A[j])>1)add(i,j);\n\t\t}\n\t\tfor(int i=1;i<=n;i++)\n\t\t\tif(!vis[i])add(0,predfs(i));\n\t\tmemset(vis,0,sizeof(vis));\n\t\tA[0]=2147483647;\n\t}\n\tstd::vector<int> s[N];\n\tstd::vector<int> tmp;\n\tvoid dfs(int p=0)\n\t{\n\t\tvis[p]=1;s[p].clear();\n\n\t\tfor(int q=19260817;q;)\n\t\t{\n\t\t\tq=0;\n\t\t\tfor(int i=begin[p];i;i=next[i])\n\t\t\t\tif(!vis[to[i]] && A[to[i]]<A[q])q=to[i];\n\t\t\tif(!q)continue;\n\t\t\tdfs(q);\n\n\t\t\tstd::vector<int>::iterator itp=s[p].begin(),itq=s[q].begin();\n\t\t\twhile(itp!=s[p].end() || itq!=s[q].end())\n\t\t\t{\n\t\t\t\tif(itp==s[p].end())tmp.push_back(*itq),itq++;\n\t\t\t\telse if(itq==s[q].end() || (*itp)>(*itq))tmp.push_back(*itp),itp++;\n\t\t\t\telse tmp.push_back(*itq),itq++;\n\t\t\t}\n\n\t\t\ts[p]=tmp;tmp.clear();\n\t\t}\n\t\tif(p)s[p].insert(s[p].begin(),A[p]);\n\n//\t\tprintf(\"%d : \",p);for(auto it:s[p])printf(\"%d \",it);printf(\"\\n\");\n\t}\n\tvoid solve()\n\t{\n\t\tinitialize();\n\t\tdfs();\n\t\tfor(auto it:s[0])printf(\"%d \",it);\n\t\tprintf(\"\\n\");\n\t}\n}\n\nint main()\n{\n\tnygdr::solve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nconst int N=2010;\nint n,a[N],go[N][N],deg[N];\nint gcd(int x,int y){return y?gcd(y,x%y):x;}\nbool used[N];\nint vis[N],C,root;\nvector<int> ans,q[N];\nvoid merge(vector<int> &a,vector<int> &b){\n\tstatic int q[N];\n\tint i=0,j=0,p=0;\n\twhile (i<a.size()&&j<b.size()) q[p++]=(a[i]>b[j]?a[i++]:b[j++]);\n\tfor (;i<a.size();q[p++]=a[i++]);\n\tfor (;j<b.size();q[p++]=b[j++]);\n\ta.clear();\n\tfor (int i=0;i<p;i++) a.push_back(q[i]);\n}\nvoid dfs(int x){\n\tused[x]=1;\n\tq[x].push_back(1e9);\n\tfor (int i=1;i<=deg[x];i++){\n\t\tint v=go[x][i];\n\t\tif (used[v]) continue;\n\t\tdfs(v);\n\t\tmerge(q[x],q[v]);\n\t}\n\tq[x][0]=a[x];\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tsort(a+1,a+n+1);\n\tfor (int i=1;i<=n;i++)\n\tfor (int j=1;j<=n;j++)\n\t\tif (gcd(a[i],a[j])!=1) go[i][++deg[i]]=j;\n\tfor (int i=1;i<=n;i++)\n\t\tif (!used[i]) dfs(i),merge(ans,q[i]);\n\tfor (int i=0;i<n;i++) printf(\"%d \",ans[i]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nint a[2005];\nint G[2005][2005];\nint gcd(int a, int b){\n    return a==0?b:gcd(b%a,a);\n}\nint vis[2005];\nvector<int> dfs(int u){\n    vector<vector<int> > pos;\n    for (int i = 1; i <= n; i++){\n        if (G[u][i] && vis[i] == 0){\n            //printf(\"%d -> %d\\n\",u,i);\n            vis[i] = 1;\n            pos.push_back(dfs(i));\n        }\n    }\n    sort(pos.begin(),pos.end());\n    vector<int> ans;\n    if (u != 0) ans.push_back(a[u]);\n    for (auto x : pos){\n        ans.insert(ans.end(),x.begin(),x.end());\n    }\n    return ans;\n}\nint main(){\n    scanf(\"%d\",&n);\n    for (int i = 1; i <= n; i++) scanf(\"%d\",&a[i]);\n    sort(a+1,a+n+1);\n    for (int i = 0 ; i <= n; i++){\n        for (int j =0 ; j <= n; j++){\n            if (a[i] == 1 || a[j] == 1){\n                if (a[i] == 0 || a[j] == 0) G[i][j] = 1;\n                else G[i][j] = 0;\n            }\n            else G[i][j] = (gcd(a[i],a[j]) != 1);\n        }\n    }\n    vector<int> v = dfs(0);\n    for (auto x : v){\n        printf(\"%d \",x);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<queue>\n#include<stack>\n#include<deque>\n#include<utility>\n#include<cctype>\n#include<bitset>\n#include<stdio.h>\n#include<time.h>\n#define ll long long\n#define mp make_pair\nusing namespace std;\nconst int INF=1e9;\n/*--------main part---------*/\ninline int read(){\n    int X = 0,w = 0 ;\n\tchar ch = 0;\n    while(!isdigit(ch)) {w |= ch == '-';ch = getchar();}\n    while(isdigit(ch)) X = (X<<3) + (X<<1) + (ch ^ 48),ch = getchar();\n    return w ? -X : X;\n}\nint n;\nint dat[10005];\nbool vis[10005];\nvector<int> ans[10005];\nbool edg[1005][1005];\nint a[100005];\nvoid dfs(int x)\n{\n\tif(vis[x])\n\t\treturn;\n\tvis[x]=true;\n\tvector<int> chi;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(edg[x][i] and !vis[i])\n\t\t{\n\t\t\tchi.push_back(i);\n\t\t\tdfs(i);\n\t\t}\n\t}\n\tmemset(a,0,sizeof(a));\n\tans[x].push_back(dat[x]);\n\twhile(true)\n\t{\n\t\tint mx=0;\n\t\tint pos;\n\t\tfor(int i=0;i<chi.size();i++)\n\t\t{\n\t\t\tif(a[i]<ans[chi[i]].size() and ans[chi[i]][a[i]]>mx)\n\t\t\t{\n\t\t\t\tmx=ans[chi[i]][a[i]];\n\t\t\t\tpos=i;\n\t\t\t}\n\t\t}\n\t\tif(mx==0)\n\t\t\tbreak;\n\t\tans[x].push_back(mx);\n\t\ta[pos]++;\n\t}\n}\nint gcd(int x,int y)\n{\n\tif(x==0)\n\t{\n\t\treturn y;\n\t}\n\telse\n\t{\n\t\treturn gcd(y%x,x);\n\t}\n}\nint main()\n{\n\tcin>>n;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcin>>dat[i];\n\t}\n\tsort(dat,dat+n);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tfor(int j=0;j<i;j++)\n\t\t{\n\t\t\tif(gcd(dat[i],dat[j])!=1)\n\t\t\t{\n\t\t\t\tedg[i][j]=edg[j][i]=true;\n\t\t\t}\n\t\t}\n\t\tedg[i][n]=edg[n][i]=true;\n\t}\n\tdfs(n);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tcout<<ans[n][i]<<' ';\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Zhupengfei 2018\n// This program / source file is in public domain.\n\n// Solution for problem: Rearranging\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n// Main segment\n\nconst int MAXN = 2010;\nconst int MAXV = MAXN * MAXN;\n\nint a[MAXN] = {};\nvector<int> g[MAXV] = {};\n\nunordered_map<int, int> primeMp = {};\nint m, N;\n\nbool inAns[MAXN] = {};\n\nint getId(int x) {\n    if (primeMp.count(x)) {\n        return primeMp[x];\n    }\n    primeMp[x] = ++m;\n    return m;\n}\n\nint color[MAXV] = {};\nint C = 0;\n\nvoid dfs(int u) {\n    color[u] = C;\n    for (int v : g[u]) {\n        if (color[v] != -1)\n            continue;\n        if (v < N && inAns[v])\n            continue;\n        dfs(v);\n    }\n}\n\nvoid recolor() {\n    C = 0;\n    memset(color, -1, sizeof(color));\n    for (int i = 1; i <= N; i++) {\n        if (!inAns[i] && color[i] == -1) {\n            dfs(i);\n            C++;\n        }\n    }\n}\n\nbool f[MAXN][MAXN] = {};\nint last[MAXN] = {};\nint suffmin[MAXN] = {};\nint ans[MAXN] = {};\nint best[MAXN] = {};\nint cnt = 0;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    cin >> N;\n    m = N;\n    for (int i = 1; i <= N; i++) {\n        cin >> a[i];\n        int x = a[i];\n        for (int y = 2; y * y <= x; y++) {\n            if (x % y != 0)\n                continue;\n            int id = getId(y);\n            g[i].push_back(id);\n            g[id].push_back(i);\n            while (x % y == 0)\n                x /= y;\n        }\n        if (x != 1) {\n            int id = getId(x);\n            g[i].push_back(id);\n            g[id].push_back(i);\n        }\n    }\n\n    for (int i = 1; i <= N; i++) {\n        for (int j = 1; j <= N; j++) {\n            f[i][j] = (__gcd(a[i], a[j]) != 1);\n        }\n    }\n\n    memset(last, -1, sizeof(last));\n    memset(suffmin, 0x7f, sizeof(suffmin));\n\n    while (cnt < N) {\n        recolor();\n        memset(best, -1, sizeof(best));\n\n        for (int i = 1; i <= N; i++) {\n            if (inAns[i] || suffmin[last[i] + 1] < a[i])\n                continue;\n            if (best[color[i]] == -1 || a[best[color[i]]] > a[i])\n                best[color[i]] = i;\n        }\n\n        int mi = -1;\n        for (int i = 0; i < C; i++) {\n            if (best[i] == -1)\n                continue;\n            if (mi == -1 || a[mi] < a[best[i]])\n                mi = best[i];\n        }\n\n        assert(mi != -1);\n        inAns[mi] = 1;\n        ans[++cnt] = mi;\n\n        for (int i = 1; i <= cnt; i++) {\n            suffmin[i] = min(suffmin[i], a[mi]);\n        }\n        for (int i = 1; i <= N; i++) {\n            if (f[i][mi]) {\n                last[i] = cnt;\n            }\n        }\n    }\n    for (int i = 1; i <= N; i++) {\n        cout << ans[i] << (i < N ? \" \" : \"\\n\");\n    }\n\n    cout << flush;\n\n#ifdef LOCAL\n    system(\"pause\");\n#endif\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define X first\n#define Y second\n#define mp make_pair\nusing namespace std;\ntypedef pair<int,bool> PIB;\ntypedef vector<PIB> T;\nconst int N = 2010;\nint gcd(int a,int b){\n\tif(b==0) return a;\n\treturn gcd(b,a%b);\n}\nint a[N],n,g[N][N];\nvector<int> v[N];\nbool use[N],in[N],pd[N];\nint d[N],q[N],head,tail,t;\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)scanf(\"%d\",a+i); \n\t//for(int i=1;i<=n;i++) q.push_back(mp(i,true));\n\t//solve(q);\n\tfor(int i =1;i<=n;i++) for(int j = 1;j<=n;j++ )if(i!=j && gcd(a[i],a[j])!=1) g[i][j] = 1;\n\t//cout<<g[2][4]<<endl;\n\tmemset(pd,true,sizeof(pd));\n\tfor(int i =1;i<=n;){\n\t\thead = tail = 0;\n\t\tq[0] = i;\n\t\tmemset(in,false,sizeof(in));\n\t\tin[i] = true;\n\t\twhile(head<=tail){\n\t\t\tt =q[head++];\n\t\t\tfor(int i =1;i<=n;i++) if(!use[i] && g[i][t] && !in[i]){\n\t\t\t\t//cout<<i<<endl;\n\t\t\t\tin[i] = true;\n\t\t\t\tq[++tail] = i;\n\t\t\t} \n\t\t}\n\t\t//cout<<tail<<endl;\n\t\tsort(q,q+tail+1);\n\t\tfor(int i = 0;i<=tail;i++) if(pd[q[i]]){\n\t\t\tt = q[i];\n\t\t\tuse[t] = true;\n\t\t\t//cout<<t<<endl;\n\t\t\tfor(int j = 0;j<=tail;j++) {\n\t\t\t\tpd[q[j]] = false;\n\t\t\t\tif(g[q[j]][t]) {\n\t\t\t\t\tpd[q[j]] = true;\n\t\t\t\t\tv[t].push_back(q[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t} \n\t\tif(use[i]) i++;\n\t} \n\t//cout<<v[2].size()<<endl;\n\t// output topology sequence\n\tint cnt =0;\n\tmemset(pd,false,sizeof(pd));\n\tfor(int i = 1;i<=n;i++) for(int j =0;j<v[i].size();j++) d[v[i][j]]++;\n\twhile(cnt<n){\n\t\tint last = 0;\n\t\tfor(int i = 1;i<=n;i++) if(!pd[i] && d[i]==0 && a[i]>a[last]){\n\t\t\tlast = i;\n\t\t} \n\t\tpd[last] = true;\n\t\tfor(int i =0;i<v[last].size();i++) d[v[last][i]]--;\n\t\tprintf(\"%d \",a[last]);\n\t\tcnt++;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<queue>\n#include<assert.h>\n#include<tuple>\n#include<string>\n#include<algorithm>\n#include<iostream>\n#include<map>\n#include<string.h>\n#include<vector>\n#include<math.h>\n#include<stdlib.h>\n#include<set>\n#include<ctype.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\ntypedef tuple<int,int,int> t3;\n\nconst int MX = 100005;\nconst int MM = 1000000007;\n\nvector<int> G[MX];\n\nint gcd(int a, int b){\n\treturn b ? gcd(b, a%b) : a;\n}\n\nint D[MX], cnt[MX], vst[MX];\n\nvoid dfs(int x, vector<int> &L){\n\tvst[x] = 1;\n\tsort(G[x].begin(), G[x].end());\n\tfor(int c : G[x]){\n\t\tif( vst[c] ) continue;\n\t\tvector<int> t, u;\n\t\tdfs(c, t);\n\t\tstd::merge(t.begin(), t.end(), L.begin(), L.end(), std::back_inserter(u), greater<int>());\n\t\tswap(u, L);\n\t}\n\tL.insert(L.begin(), x);\n}\n\nint main()\n{\n\tint N;\n\tscanf(\"%d\", &N);\n\tfor(int i = 1; i <= N; i++) scanf(\"%d\", D+i);\n\tsort(D+1, D+N+1);\n\tfor(int i = 1; i <= N; i++){\n\t\tfor(int j = i+1; j <= N; j++){\n\t\t\tif( gcd(D[i], D[j]) != 1 ){\n\t\t\t\tG[i].push_back(j);\n\t\t\t\tG[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 1; i <= N; i++){\n\t\tG[i].push_back(0);\n\t\tG[0].push_back(i);\n\t}\n\tvector<int> L;\n\tdfs(0, L);\n\tfor(int i = 1; i < L.size(); i++) printf(\"%d \", D[L[i]]);\n\tprintf(\"\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <bitset>\n#include <cstdio>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <cassert>\n#include <climits>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\n#include <functional>\nusing namespace std ;\n\n#define rep(i, a, b) for (int (i) = (a); (i) <= (b); (i)++)\n#define Rep(i, a, b) for (int (i) = (a) - 1; (i) < (b); (i)++)\n#define REP(i, a, b) for (int (i) = (a); (i) >= (b); (i)--)\n#define clr(a) memset(a, 0, sizeof(a))\n#define Sort(a, len, cmp) sort(a + 1, a + len + 1, cmp)\n#define ass(a, sum) memset(a, sum, sizeof(a))\n\n#define ls ((rt) << 1)\n#define rs ((rt) << 1 | 1)\n#define lowbit(x) (x & -x)\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define endl '\\n'\n#define ENDL cout << endl\n#define SZ(x) ((int)x.size())\n\ntypedef long long ll ;\ntypedef unsigned long long ull ;\ntypedef vector <int> Vi ;\ntypedef pair <int, int> Pii ;\ntypedef pair <ll, ll> Pll ;\ntypedef map <int, int> mii ;\ntypedef map <string, int> msi ;\ntypedef map <ll, ll> mll ;\n\nconst int N = 2010 ;\nconst double eps = 1e-8 ;\nconst int iinf = INT_MAX ;\nconst ll linf = 2e18 ;\nconst double dinf = 1e30 ;\nconst int MOD = 1000000007 ;\n\ninline int read(){\n    int X = 0, w = 0 ;\n\tchar ch = 0 ;\n    while (!isdigit(ch)) { w |= ch == '-' ; ch = getchar() ; }\n    while (isdigit(ch)) X = (X << 3) + (X << 1) + (ch ^ 48), ch = getchar() ;\n    return w ? - X : X ;\n}\n\nvoid write(int x){\n     if (x < 0) putchar('-'), x = - x ;\n     if (x > 9) write(x / 10) ;\n     putchar(x % 10 + '0') ;\n}\n\nvoid print(int x) {\n\tcout << x << endl ;\n\texit(0) ;\n}\n\nvoid PRINT(string x) {\n\tcout << x << endl ;\n\texit(0) ;\n}\n\nvoid douout(double x){\n\t printf(\"%lf\\n\", x + 0.0000000001) ;\n}\n\nint vis[N], ok[N][N], in[N], a[N] ;\nvector <int> g[N] ;\nint n ;\n\nvoid dfs(int rt) {\n\tvis[rt] = 1 ;\n\tfor (int i = 1; i <= n; i++)\n\tif (!vis[i] && ok[rt][i]) {\n\t\tin[i]++ ;\n\t\tg[rt].pb(i) ;\n\t\tdfs(i) ;\n\t}\n}\n\nvoid Top() {\n\tpriority_queue <int> q ;\n\tfor (int i = 1;  i <= n; i++) if (!in[i]) q.push(i) ;\n\twhile (!q.empty()) {\n\t\tint now = q.top() ;\n\t\tq.pop() ;\n\t\tcout << a[now] << \" \" ;\n\t\tfor (int i = 0; i < SZ(g[now]); i++) q.push(g[now][i]) ;\n\t}\n}\n\nsigned main(){\n\tscanf(\"%d\", &n) ;\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]) ;\n\tsort(a + 1, a + n + 1) ;\n\tclr(ok) ;\n\tfor (int i = 1; i <= n; i++)\n\tfor (int j = i + 1; j <= n; j++)\n\tif (__gcd(a[i], a[j]) != 1) ok[i][j] = ok[j][i] = 1 ;\n\tfor (int i = 1; i <= n; i++) if (!vis[i]) dfs(i) ;//连通块\n\tTop() ;\n}\n\n/*\n写代码时请注意：\n\t1.是否要开Long Long？数组边界处理好了么？\n\t2.实数精度有没有处理？\n\t3.特殊情况处理好了么？\n\t4.做一些总比不做好。\n思考提醒：\n\t1.最大值和最小值问题可不可以用二分答案？\n\t2.有没有贪心策略？否则能不能dp？\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=2005;\nint gcd(int a,int b)\n{\n\treturn a%b==0?b:gcd(b,a%b);\n}\nint n,A[N];\nbool vis[N];\nvector<int> adj[N],adj2[N];\nint deg[N],ans[N];\npriority_queue<int>Q;\nvoid dfs(int u)\n{\n\tvis[u]=true;\n\tfor(int i=0;i<(int)adj[u].size();i++)\n\t{\n\t\tint v=adj[u][i];\n\t\tif(vis[v])\n\t\t\tcontinue;\n\t\tadj2[u].push_back(v);\n\t\tdeg[v]++;\n\t\tdfs(v);\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d\",&A[i]);\n\tsort(A+1,A+n+1);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=1;j<=n;j++)\n\t\t\tif(i!=j&&gcd(A[i],A[j])>1)\n\t\t\t\tadj[i].push_back(j);\n\tfor(int i=1;i<=n;i++)\n\t\tif(!vis[i])\n\t\t\tdfs(i);\n\tfor(int i=1;i<=n;i++)\n\t\tif(deg[i]==0)\n\t\t\tQ.push(i);\n\tint it=0;\n\twhile(!Q.empty())\n\t{\n\t\tint u=Q.top();\n\t\tans[++it]=A[u];\n\t\tQ.pop();\n\t\tfor(int i=0;i<(int)adj2[u].size();i++)\n\t\t{\n\t\t\tint v=adj2[u][i];\n\t\t\tdeg[v]--;\n\t\t\tif(deg[v]==0)\n\t\t\t\tQ.push(v);\n\t\t}\n\t}\n\tfor(int i=1;i<n;i++)\n\t\tprintf(\"%d \",ans[i]);\n\tprintf(\"%d\\n\",ans[n]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nint n;\nint a[2010];\nvector<int> e[2010],next[2010];\nbool vis[2010];\npriority_queue<int> f;\n\nint gcd(int x,int y){\n\treturn y==0?x:gcd(y,x%y);\n}\n\nvoid ins(int x,int y){\n\te[x].push_back(y);e[y].push_back(x);\n}\n\nvoid dfs(int x){\n\tvis[x]=true;\n\tfor(int i=0;i<e[x].size();i++)\n\t\tif(!vis[e[x][i]]) next[x].push_back(e[x][i]),dfs(e[x][i]);\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tsort(a+1,a+1+n);\n\tfor(int i=1;i<=n;i++)\n\t\tfor(int j=i+1;j<=n;j++) if(gcd(a[i],a[j])!=1) ins(i,j);\n\tfor(int i=1;i<=n;i++) if(!vis[i]) dfs(i),f.push(i);\n\twhile(!f.empty()){\n\t\tint x=f.top();f.pop();\n\t\tprintf(\"%d \",a[x]);\n\t\tfor(int i=0;i<next[x].size();i++) f.push(next[x][i]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <map>\nusing namespace std;\n#define N 2005\n#define V 40005\n#define Inf (1<<30) \nint n,m;\nint a[N];\nbool b[N][N];\nint ans[N];\nbool inAns[N];\nint ansSz;\nint lastNotCoprime[N];\nint minOnSuff[N];\nint comp[V];\nvector<int> g[V];\nint C;\nint bestForCol[N];\nmap<int,int> primeId;\nint gcd(int a,int b){\n\tif(b==0){\n\t\treturn a;\n\t}\n\treturn gcd(b,a%b);\n}\nint getId(int p){\n\tif(primeId.count(p)>0){\n\t\treturn primeId[p];\n\t}\n\tprimeId[p]=m;\n\treturn m++;\n}\nvoid dfs(int v){\n\tcomp[v]=C;\n\tint u;\n\tfor(int i=0;i<(int)g[v].size();i++){\n\t\tu=g[v][i];\n\t\tif(comp[u]!=-1){\n\t\t\tcontinue;\n\t\t}\n\t\tif(u<n&&inAns[u]){\n\t\t\tcontinue;\n\t\t}\n\t\tdfs(u);\n\t}\n}\nvoid colors(){\n\tfor(int i=0;i<m;i++){\n\t\tcomp[i]=-1;\n\t}\n\tC=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(inAns[i]){\n\t\t\tcontinue;\n\t\t}\n\t\tif(comp[i]!=-1){\n\t\t\tcontinue;\n\t\t}\n\t\tdfs(i);\n\t\tC++;\n\t}\n}\nint mn(int a,int b){\n\treturn a<b?a:b;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tm=n;\n\tint x,id;\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d\",&a[i]);\n\t\tx=a[i];\n\t\tfor(int j=2;j*j<=x;j++){\n\t\t\tif(x%j!=0){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tid=getId(j);\n\t\t\tg[i].push_back(id);\n\t\t\tg[id].push_back(i);\n\t\t\twhile(x%j==0){\n\t\t\t\tx/=j;\n\t\t\t}\n\t\t}\n\t\tif(x>1){\n\t\t\tid=getId(x);\n\t\t\tg[i].push_back(id);\n\t\t\tg[id].push_back(i);\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=i+1;j<n;j++){\n\t\t\tif(gcd(a[i],a[j])>1){\n\t\t\t\tb[i][j]=b[j][i]=1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tlastNotCoprime[i]=-1;\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tminOnSuff[i]=Inf;\n\t}\n\twhile(ansSz<n){\n\t\tcolors();\n\t\tfor(int i=0;i<C;i++){\n\t\t\tbestForCol[i]=-1;\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(inAns[i]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(minOnSuff[lastNotCoprime[i]+1]<a[i]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(bestForCol[comp[i]]==-1||a[bestForCol[comp[i]]]>a[i]){\n\t\t\t\tbestForCol[comp[i]]=i;\n\t\t\t}\n\t\t}\n\t\tid=-1;\n\t\tfor(int i=0;i<C;i++){\n\t\t\tif(bestForCol[i]==-1){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(id==-1||a[id]<a[bestForCol[i]]){\n\t\t\t\tid=bestForCol[i];\n\t\t\t}\n\t\t}\n\t\tinAns[id]=1;\n\t\tans[ansSz++]=a[id];\n\t\tfor(int i=0;i<ansSz;i++){\n\t\t\tminOnSuff[i]=mn(minOnSuff[i],a[id]);\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(b[id][i]){\n\t\t\t\tlastNotCoprime[i]=ansSz-1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tprintf(\"%d \",ans[i]);\n\t}\n\tputs(\"\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=(a);i<=(b);i++)\n#define per(i,a,b) for(int i=(a);i>=(b);i--)\n#define REP(i,n) for(int i=0;i<int(n);i++)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef long long ll;\ntypedef double ld;\n\ntemplate<class T> inline void read(T &x){\n\tint f=0;x=0;char ch=getchar();\n\tfor(;!isdigit(ch);ch=getchar())f|=(ch=='-');\n\tfor(;isdigit(ch);ch=getchar())x=x*10+ch-'0';\n\tif(f)x=-x;\n}\n\nconst int N=2005;\nint a[N],vis[N],p[N],n,las;\npriority_queue<int> Q;\nvi e[N];\n\nvoid dfs(int x){\n\tif(las) p[las]=x; vis[las=x]=1;\n\tsort(e[x].begin(),e[x].end());\n\tfor(auto y:e[x]) if(!vis[y]) dfs(y);\n}\n\nint main(){\n\tread(n);\n\trep(i,1,n) read(a[i]);\n\tsort(a+1,a+n+1);\n\trep(i,1,n) rep(j,i+1,n)\n\t\tif(__gcd(a[i],a[j])>=2) e[i].pb(j),e[j].pb(i);\n\trep(i,1,n) if(!vis[i]) las=0,dfs(i),Q.push(i);\n\twhile(!Q.empty()){\n\t\tint x=Q.top(); Q.pop();\n\t\tprintf(\"%d \",a[x]);\n\t\tif(p[x]) Q.push(p[x]);\n\t}\n\tputs(\"\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cstdlib>\n#include<ctime>\n#include<utility>\n#include<cmath>\n#include<functional>\n#include<queue>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\nvoid sort(int &a,int &b)\n{\n\tif(a>b)\n\t\tswap(a,b);\n}\nvoid open(const char *s)\n{\n#ifndef ONLINE_JUDGE\n\tchar str[100];\n\tsprintf(str,\"%s.in\",s);\n\tfreopen(str,\"r\",stdin);\n\tsprintf(str,\"%s.out\",s);\n\tfreopen(str,\"w\",stdout);\n#endif\n}\nint rd()\n{\n\tint s=0,c;\n\twhile((c=getchar())<'0'||c>'9');\n\tdo\n\t{\n\t\ts=s*10+c-'0';\n\t}\n\twhile((c=getchar())>='0'&&c<='9');\n\treturn s;\n}\nint upmin(int &a,int b)\n{\n\tif(b<a)\n\t{\n\t\ta=b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nint upmax(int &a,int b)\n{\n\tif(b>a)\n\t{\n\t\ta=b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nint gcd(int a,int b)\n{\n\treturn b?gcd(b,a%b):a;\n}\npriority_queue<int> q;\nint d[2010];\nvector<int> g[2010],g2[2010];\nint a[2010];\nint b[2010];\npii c[2010];\nvoid dfs(int x)\n{\n\tb[x]=1;\n\tfor(auto v:g[x])\n\t\tif(!b[v])\n\t\t{\n\t\t\tdfs(v);\n\t\t\tg2[x].push_back(v);\n\t\t\td[v]++;\n\t\t}\n}\nint main()\n{\n\tint n;\n\tscanf(\"%d\",&n);\n\tint i,j;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d\",&a[i]);\n\t\tc[i].first=a[i];\n\t\tc[i].second=i;\n\t}\n\tsort(c+1,c+n+1);\n\tfor(i=1;i<=n;i++)\n\t\tfor(j=1;j<=n;j++)\n\t\t\tif(gcd(a[c[i].second],a[c[j].second])!=1)\n\t\t\t\tg[c[i].second].push_back(c[j].second);\n\tfor(i=1;i<=n;i++)\n\t\tif(!b[c[i].second])\n\t\t\tdfs(c[i].second);\n\tfor(i=1;i<=n;i++)\n\t\tif(!d[i])\n\t\t\tq.push(i);\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tint x=q.top();\n\t\tq.pop();\n\t\tprintf(\"%d \",a[x]);\n\t\tfor(auto v:g2[x])\n\t\t{\n\t\t\td[v]--;\n\t\t\tif(!d[v])\n\t\t\t\tq.push(v);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint dat[2002];\nvector<int> graph[2002];\nbool visit[2005];\nint n;\n\nint gcd(int a, int b)\n{\n\treturn b ? gcd(b, a % b) : a;\n}\n\nvector<int> merge(vector<vector<int>> vvt, int head)\n{\n\tint total = 0;\n\tfor (auto &&v : vvt) total += v.size();\n\tvector<int> ret(total + (head >= 0));\n\tint ptr = 0;\n\tif (head >= 0) ret[ptr++] = head;\n\tpriority_queue<tuple<int, int, int>> pq;\n\tfor (int i = 0; i < vvt.size(); i++)\n\t{\n\t\tpq.emplace(vvt[i][0], i, 0);\n\t}\n\twhile (pq.empty() == false)\n\t{\n\t\tint val, idx, nxt;\n\t\ttie(val, idx, nxt) = pq.top();\n\t\tpq.pop();\n\t\tret[ptr++] = val;\n\n\t\tif (nxt + 1 < vvt[idx].size())\n\t\t\tpq.emplace(vvt[idx][nxt + 1], idx, nxt + 1);\n\t}\n\treturn ret;\n}\n\nvector<int> process(int t)\n{\n\tvector<vector<int>> vvt;\n\tvisit[t] = true;\n\n\tfor (int nxt : graph[t])\n\t{\n\t\tif (visit[nxt]) continue;\n\t\tvvt.emplace_back(process(nxt));\n\t}\n\n\treturn merge(move(vvt), t);\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &dat[i]);\n\t}\n\n\tsort(dat, dat + n);\n\n\tfor (int i = 0; i < n - 1; i++)\n\t{\n\t\tfor (int j = i + 1; j < n; j++)\n\t\t{\n\t\t\tif (gcd(dat[i], dat[j]) > 1)\n\t\t\t{\n\t\t\t\tgraph[i].push_back(j);\n\t\t\t\tgraph[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\n\t//for (int i = 0; i < n; i++) sort(graph[i].begin(), graph[i].end());\n\n\tvector<vector<int>> vvt;\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (visit[i]) continue;\n\t\tvvt.emplace_back(process(i));\n\t}\n\n\tauto ret = merge(move(vvt), -1);\n\n\tfor (int t : ret) printf(\"%d \", dat[t]);\n\tprintf(\"\\n\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#define ll long long\n#define rep(i, a, b) for (int i = a; i <= (int)b; i ++)\nvoid read(int & x) {\n    x = 0; int flag = 1; char ch = ' ';\n    while (ch < '0' || ch > '9') { if(ch == '-') flag = -1; ch = getchar(); }\n    while (ch >= '0' && ch <= '9') x = x * 10 + ch - '0', ch = getchar();\n    x *= flag;\n}\nvoid read(ll & x) {\n    x = 0; int flag = 1; char ch = ' ';\n    while (ch < '0' || ch > '9') { if(ch == '-') flag = -1; ch = getchar(); }\n    while (ch >= '0' && ch <= '9') x = x * 10 + ch - '0', ch = getchar();\n    x *= flag;\n}\nusing namespace std;\nconst int maxn = 2010;\nint n, degree[maxn], a[maxn];\nbool vis[maxn], mp[maxn][maxn];\nvector < int > ans, edge[maxn];\nint gcd(int a, int b) { return b ? gcd(b, a % b) : a; }\nvoid dfs(int u) {\n    vis[u] = 1;\n    rep(i, 1, n)\n        if(!vis[i] && mp[u][i]) edge[u].push_back(i), degree[i] ++, dfs(i);\n}\nvoid solve() {\n    priority_queue < int > pq;\n    memset(vis, 0, sizeof(vis));\n    rep(i, 1, n) if(degree[i] == 0) pq.push(i), vis[i] = 1;\n    while(!pq.empty()) {\n        int u = pq.top(); pq.pop();\n        ans.push_back(u);\n        rep(i, 0, edge[u].size() - 1) {\n            int v = edge[u][i];\n            if(-- degree[v] == 0) pq.push(v);\n        }\n    }\n}\nint main()\n{\n    read(n);\n    rep(i, 1, n) read(a[i]);\n    sort(a + 1, a + 1 + n);\n    rep(i, 1, n - 1) rep(j, i + 1, n) \n        if(gcd(a[i], a[j]) != 1) mp[i][j] = mp[j][i] = 1;\n    rep(i, 1, n) dfs(i);\n    solve();\n    rep(i, 0, n - 1) printf(\"%d \", a[ans[i]]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\nstruct UnionFind{\n  Int n;\n  vector<Int> r,p;\n  UnionFind(Int x,Int y):n(x+y),r(x+y,1),p(x+y,0){\n    iota(p.begin(),p.end(),0);\n    for(Int i=0;i<x;i++) r[i]=1;\n    for(Int i=0;i<y;i++) r[x+i]=0;\n  }\n  Int find(Int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(Int x,Int y){\n    return find(x)==find(y);\n  }\n  void unite(Int x,Int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    if(r[x]<r[y]) swap(x,y);\n    r[x]+=r[y];\n    p[y]=x;\n  }\n};\n\n\ntemplate<typename T> \nmap<T, Int> factorize(T x){\n  map<T, Int> res;\n  for(Int i=2;i*i<=x;i++){\n    while(x%i==0){\n      x/=i;\n      res[i]++;\n    }\n  }\n  if(x!=1) res[x]++;\n  return res;\n}\n\n//INSERT ABOVE HERE\nInt cop[2020][2020];\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<Int> a(n);\n  for(Int i=0;i<n;i++) cin>>a[i];\n  sort(a.begin(),a.end());\n\n  vector<Int> ans(n),used(n,0),post(n,0);\n\n  memset(cop,0,sizeof(cop));\n  \n  for(Int i=0;i<n;i++)\n    for(Int j=0;j<n;j++)\n      cop[i][j]=__gcd(a[i],a[j])>1;\n\n  Int m=0;\n  map<Int, Int> r;\n\n  vector<vector<Int> > G(n);\n  for(Int i=0;i<n;i++){\n    auto x=factorize(a[i]);\n    for(auto p:x){\n      if(!r.count(p.first)) r[p.first]=m++;\n      G[i].emplace_back(r[p.first]);\n    }\n  }\n  \n  for(Int t=0;t<n;t++){\n    UnionFind uf(n,m);\n    for(Int i=0;i<n;i++)\n      if(!used[i]) for(Int j:G[i]) uf.unite(i,n+j);\n    \n    Int idx=-1;\n    auto nxt=[&](){\n\t       Int sum=t;\n\t       set<Int> tmp;\n\t       for(Int i=0;i<n;i++){\n\t\t if(used[i]) continue;\n\t\t Int k=uf.find(i);\n\t\t if(!tmp.count(k)){\n\t\t   tmp.emplace(k);\n\t\t   sum+=uf.r[k];\n\t\t }\n\t\t if(post[i]) continue;\n\t\t if(sum==n){\n\t\t   idx=i;\n\t\t   break;\n\t\t }\n\t       }\n\t       //assert(sum==n);\n\t     };\n    nxt();\n    //while(idx<0);\n    if(idx<0){\n      post.assign(n,0);\n      nxt();      \n      while(idx<0);\n    }\n    used[idx]=1;\n    ans[t]=idx;\n    \n    for(Int i=0;i<n;i++){\n      if(cop[idx][i]) post[i]=0;\n      else if(a[idx]<a[i]) post[i]=1;\n    }\n  }\n  for(Int i=0;i<n;i++){\n    if(i) cout<<\" \";\n    cout<<a[ans[i]];\n  }\n  cout<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"Ofast\")\n#include <iostream>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <set>\n#include <deque> \n#define rep(x, a, b) for(int x = (a); x <= (b); ++x)\n#define rop(x, a, b) for(int x = (a); x < (b); ++x)\n#define per(x, a, b) for(int x = (a); x >= (b); --x)\nusing namespace std;\ntypedef long long LL;\ntypedef double DB;\ndeque<int> C[2005];\nint a[2005];\nstruct graph {\n\tset<int> S[2005];\n\tint vs[2005];\n\tvoid push(int x, int y) {\n\t\tS[x].insert(y);\n\t}\n\tvoid dfs(int nw) {\n\t\tC[nw].clear();\n\t\tvs[nw] = 1;\n\t\tint SM = 0;\n\t\tauto IT = S[nw].begin();\n\t\twhile(IT != S[nw].end()) {\n\t\t\tif(vs[*IT]) {++IT; continue;}\n\t\t\tvis[nw][*IT] = 1; \n\t\t\tdfs(*IT);\n\t\t\tSM += C[*IT].size();\n\t\t\t++IT;\n\t\t}\n\t\trep(i, 1, SM) {\n\t\t\tint mx = 0, bj = 0;\n\t\t\tauto IT = S[nw].begin();\n\t\t\twhile(IT != S[nw].end()) {\n\t\t\t\tif(vis[nw][*IT] == 0 || !C[*IT].size()) {++IT; continue;}\n\t\t\t\tif(mx < C[*IT][0]) mx = C[*IT][0], bj = *IT;\n\t\t\t\t++IT;\n\t\t\t}\n\t\t\tC[bj].pop_front();\n\t\t\tC[nw].push_back(mx);\n\t\t}\n\t\tC[nw].push_front(a[nw]);\n\t}\n}G;\nint n;\nint main() {\n\tscanf(\"%d\", &n);\n\trep(i, 1, n) scanf(\"%d\", &a[i]);\n\trep(i, 1, n) rep(j, 1, n) if(i != j && __gcd(a[i], a[j]) != 1) G.push(i, j); \n\trep(i, 1, n) G.push(0, i);\n\tG.dfs(0);\n\trop(i, 1, C[0].size()) printf(\"%d \", C[0][i]);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\nint c;\nint a[2000];\nint d[2000];\nint f[2000];\nvector <int> v[2000];\nvector <int> w[2000];\n\nint gcd(int a, int b) {\n    if (a % b == 0) {\n        return b;\n    } else {\n        return gcd(b, a % b);\n    }\n}\n\nvoid dfs(int x, int c, vector <int> &z) {\n    int i;\n    \n    f[x] = c;\n    z.push_back(x);\n    \n    for (i = 0; i < v[x].size(); i++) {\n        if (f[v[x][i]] == c || f[v[x][i]] == -1) continue;\n        \n        dfs(v[x][i], c, z);\n    }\n}\n\nvoid calc(vector <int> &z, int x) {\n    int i, j;\n    \n    sort(z.begin(), z.end());\n    \n    for (i = 0; i < z.size(); i++) {\n        if (x == -1 || gcd(x, a[z[i]]) != 1) break;\n    }\n    \n    f[z[i]] = -1;\n    for (j = 0; j < v[z[i]].size(); j++) {\n        int y = v[z[i]][j];\n        \n        if (f[y] == -1) continue;\n        \n        d[y]++;\n        w[z[i]].push_back(y);\n    }\n    \n    for (j = 0; j < v[z[i]].size(); j++) {\n        int y = v[z[i]][j];\n        \n        if (f[y] != -1) {\n            vector <int> z2;\n            \n            dfs(y, ++c, z2);\n            \n            calc(z2, a[z[i]]);\n        }\n    }\n}\n\nint main() {\n    int n, i, j;\n    vector <int> ans;\n    priority_queue <int> q;\n    \n    scanf(\"%d\", &n);\n    \n    for (i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n    \n    sort(a, a + n);\n    \n    for (i = 0; i < n; i++) {\n        for (j = i + 1; j < n; j++) {\n            if (gcd(a[i], a[j]) > 1) {\n                v[i].push_back(j);\n                v[j].push_back(i);\n            }\n        }\n    }\n    \n    for (i = 0; i < n; i++) {\n        if (f[i] != -1) {\n            vector <int> z;\n            \n            dfs(i, ++c, z);\n            \n            calc(z, -1);\n            \n            q.push(i);\n        }\n    }\n    \n    while (!q.empty()) {\n        int x = q.top();\n        \n        q.pop();\n        \n        ans.push_back(a[x]);\n        \n        for (i = 0; i < w[x].size(); i++) {\n            int y = w[x][i];\n            \n            d[y]--;\n            \n            if (d[y] == 0) q.push(y);\n        }\n    }\n    \n    for (i = 0; i < n; i++) {\n        if (i > 0) putchar(' ');\n        printf(\"%d\", ans[i]);\n    }\n    puts(\"\");\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main()\n{\n    int n,arr[11000],brr[11000],a;\n    cin>>n;\n    for(int i=0; i<n; i++)\n    {\n        cin>>arr[i];\n        brr[i]=arr[i];\n    }\n    sort(arr,arr+n);\n    sort(brr,brr+n);\n    for(int i=0; i<n; i++)\n    {\n        for(int j=i+1; j<n; j++)\n        {\n            if(__gcd(arr[i],arr[j])!=1)\n            {\n                swap(arr[i+1],arr[j]);\n                break;\n            }\n        }\n    }\n    int idx;\n    int cnt=0;\n    for(int i=0; i<n; i++)\n    {\n        for(int j=0; j<n; j++)\n        {\n            if(brr[i]==arr[j])\n            {\n                idx=j;\n            }\n        }\n        for(int j=idx; j>0; j--)\n        {\n            if(__gcd(arr[j],arr[j-1])==1)\n                swap(arr[j-1],arr[j]);\n            else\n                break;\n        }\n    }\n    for(int i=0; i<n; i++)\n        cout<<arr[i]<<\" \";\n    cout<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst long double EPS=1e-13;\nconst long double PI=acos(-1.0);\nint ABS(int a){return max(a,-a);}\nlong long ABS(long long a){return max(a,-a);}\nlong double ABS(long double a){return max(a,-a);}\nint p[2100];\nmap<int,int>m;\nvector<int>q[2100];\nint gcd(int a,int b){\n\twhile(a){\n\t\tb%=a;swap(a,b);\n\t}return b;\n}\nvector<int>rev[2100];\nvector<int>f(vector<int>a,int x){\n\tvector<int>ret;\n\tint at=-1;\n\tfor(int i=0;i<a.size();i++){\n\t\tif(gcd(x,p[a[i]])==1)continue;\n\t\tif(at==-1||p[a[i]]<p[a[at]]){\n\t\t\tat=i;\n\t\t}\n\t}\n\tif(at==-1)at=0;\n\tret.push_back(a[at]);\n\tvector<pair<int,int> > key;\n\n\tfor(int i=0;i<a.size();i++){\n\t\tif(at==i)continue;\n\t\tfor(int j=0;j<q[a[i]].size();j++){\n\t\t\tkey.push_back(make_pair(q[i][j],i));\n\t\t}\n\t}\n\tstd::sort(key.begin(),key.end());\n\tfor(int i=0;i<a.size();i++){\n\t\trev[i].clear();\n\t}\n\tfor(int i=0;i<key.size();i++){\n\t\trev[key[i].second].push_back(i);\n\t}\n\tvector<int>v(a.size());\n\tqueue<int>Q;\n\tv[at]=1;\n\tfor(int i=0;i<a.size();i++){\n\t\tif(v[i])continue;\n\t\tvector<int>tmp;\n\t\tQ.push(i);\n\t\tv[i]=1;\n\t\twhile(Q.size()){\n\t\t\tint now=Q.front();Q.pop();\n\t\t\ttmp.push_back(a[now]);\n\t\t\tfor(int j=0;j<rev[now].size();j++){\n\t\t\t\tif(rev[now][j]&&key[rev[now][j]].first==key[rev[now][j]-1].first){\n\t\t\t\t\tint to=key[rev[now][j]-1].second;\n\t\t\t\t\tif(!v[to]){\n\t\t\t\t\t\tv[to]=1;\n\t\t\t\t\t\tQ.push(to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(rev[now][j]+1<key.size()&&key[rev[now][j]].first==key[rev[now][j]+1].first){\n\t\t\t\t\tint to=key[rev[now][j]+1].second;\n\t\t\t\t\tif(!v[to]){\n\t\t\t\t\t\tv[to]=1;\n\t\t\t\t\t\tQ.push(to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int>rv=f(tmp,p[a[at]]);\n\t\tfor(int i=0;i<rv.size();i++)ret.push_back(rv[i]);\n\t}\n\t//for(int i=0;i<a.size();i++)printf(\"%d \",a[i]);printf(\"(%d): \",x);\n\t//for(int i=0;i<ret.size();i++)printf(\"%d \",ret[i]);printf(\"\\n\");\n\t\n\treturn ret;\n}\nint id[2100];\nvector<int>g[2100];\nint used[2100];\nint main(){\n\tint a;scanf(\"%d\",&a);\n\tfor(int i=0;i<a;i++){\n\t\tscanf(\"%d\",p+i);\n\t}\n\tstd::sort(p,p+a);\n\tint sz=0;\n\tfor(int i=0;i<a;i++){\n\t\tint tmp=p[i];\n\t\tfor(int j=2;j*j<=tmp;j++){\n\t\t\tif(tmp%j==0){\n\t\t\t\tint at;\n\t\t\t\tif(m.count(j)){\n\t\t\t\t\tat=m[j];\n\t\t\t\t}else{\n\t\t\t\t\tm[j]=sz;\n\t\t\t\t\tat=sz++;\n\t\t\t\t}\n\t\t\t\tq[i].push_back(at);\n\t\t\t\twhile(tmp%j==0)tmp/=j;\n\t\t\t}\n\t\t}\n\t\tif(tmp>1){\n\t\t\tint at;\n\t\t\tif(m.count(tmp)){\n\t\t\t\tat=m[tmp];\n\t\t\t}else{\n\t\t\t\tm[tmp]=sz;\n\t\t\t\tat=sz++;\n\t\t\t}\n\t\t\tq[i].push_back(at);\n\t\t}\n\t}\n\tvector<int>st;\n\tfor(int i=0;i<a;i++)st.push_back(i);\n\tvector<int>tmp=f(st,0);\n\n\t//for(int i=0;i<tmp.size();i++)printf(\"%d \",tmp[i]);printf(\"\\n\");\n\tfor(int i=0;i<tmp.size();i++){\n\t\tfor(int j=i+1;j<tmp.size();j++){\n\t\t\tif(gcd(p[tmp[i]],p[tmp[j]])!=1){\n\t\t\t\tg[tmp[i]].push_back(tmp[j]);\n\t\t\t\tid[tmp[j]]++;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<a;i++){\n\t\tint at=-1;\n\t\tfor(int j=0;j<a;j++){\n\t\t\tif(used[j])continue;\n\t\t\tif(id[j])continue;\n\t\t\tif(at==-1||p[at]<p[j]){\n\t\t\t\tat=j;\n\t\t\t}\n\t\t}\n\t\tused[at]=1;\n\t\tprintf(\"%d \",p[at]);\n\t\tfor(int j=0;j<g[at].size();j++){\n\t\t\tid[g[at][j]]--;\n\t\t}\n\t}\n\tprintf(\"\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=4e3;\nint n,a[maxn],d[maxn];\nbool vis[maxn],e[maxn][maxn];\nvector <int> to[maxn];\nstruct cp{\n\tint id,val;\n}ccp;\nbool operator <(cp x,cp y){return x.val<y.val;}\npriority_queue <cp> q;\nint gcd(int a,int b){return (b==0)?a:gcd(b,a%b);}\nvoid dfs(int now){\n\tvis[now]=1;\n\tfor(int i=1;i<=n;i++){if(!vis[i]&&e[now][i]){to[now].push_back(i);d[i]++;dfs(i);}}\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=1;i<=n;i++){scanf(\"%d\",&a[i]);}\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++){\n\t\tfor(int j=1;j<=n;j++){\n\t\t\tif(gcd(a[i],a[j])>1) e[i][j]=true;\n\t\t}\n\t}\n\tfor(int i=1;i<=n;i++){\n\t    if(!vis[i]){\n\t\t    dfs(i);\n\t\t    ccp.id=i;ccp.val=a[i];\n\t\t    q.push(ccp);\n\t\t}\n\t}\n\twhile(!q.empty()){\n\t\tcp s=q.top();q.pop();\n\t\tprintf(\"%d \",s.val);\n\t\tint siz=to[s.id].size(),u;\n\t\tfor(int i=0;i<siz;i++){\n\t\t\tu=to[s.id][i];\n\t\t\td[u]--;\n\t\t\tif(d[u]==0){\n\t\t\t\tccp.id=u;ccp.val=a[u];\n\t\t\t\tq.push(ccp);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"\\n\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\ninline int read(){\n\tint f=1,ans=0;char c=getchar();\n\twhile(c<'0'||c>'9'){if(c=='-')f=-1;c=getchar();}\n\twhile(c>='0'&&c<='9'){ans=ans*10+c-'0';c=getchar();}\n\treturn ans*f;\n}\nconst int MAXN=2001;\nvector<int> vec[MAXN];\npriority_queue<int> que;\nint N,A[MAXN],M[MAXN][MAXN],vis[MAXN],d[MAXN];\nvoid dfs(int u){\n\tvis[u]=1;\n\tfor(int i=1;i<=N;i++){\n\t\tif(!vis[i]&&M[u][i]){\n\t\t\tvec[u].push_back(i);\n\t\t\tvis[i]=1,d[i]++;dfs(i);\n\t\t}\n\t}return;\n}\nint main(){\n\tN=read();for(int i=1;i<=N;i++) A[i]=read();sort(A+1,A+N+1);\n\tfor(int i=1;i<=N;i++) for(int j=2;j<=N;j++) if(__gcd(A[i],A[j])!=1) M[i][j]=M[j][i]=1;\n\tfor(int i=1;i<=N;i++) if(!vis[i]) dfs(i);\n\tfor(int i=1;i<=N;i++) if(!d[i]) que.push(i);\n\twhile(!que.empty()){\n\t\tint xx=que.top();que.pop();printf(\"%d \",A[xx]);\n\t\tfor(int i=0;i<vec[xx].size();i++){\n\t\t\tint v=vec[xx][i];\n\t\t\td[v]--;if(!d[v]) que.push(v);\n\t\t}\n\t}printf(\"\\n\");return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\nint N, a[2001], apr[2001], G[2001][2001], q[2002], ue[2002], ref[2002], v[2002], L;\nstd::vector < int > Son[2001], Ans[2001];\nint gcd(int a, int b)\n{\n\tint r;\n\twhile (b)\n\t{\n\t\tr = a % b;\n\t\ta = b;\n\t\tb = r;\n\t}\n\treturn a;\n}\nstd::vector < int > merge(std::vector < int > a, std::vector < int > b)\n{\n\tstd::vector < int > O;\n\tO.reserve(a.size() + b.size());\n\tauto i = a.begin(), j = b.begin();\n\twhile (i != a.end() && j != b.end())\n\t\tO.push_back(*(*i > *j ? i : j)++);\n\twhile (i != a.end())\n\t\tO.push_back(*i++);\n\twhile (j != b.end())\n\t\tO.push_back(*j++);\n\treturn O;\n}\nint main()\n{\n\tdo\n\t{\n\t\tstatic int w[2001], L;\n\t\tscanf(\"%d\", &L);\n\t\tfor (int i = 1; i <= L; i++)\n\t\t\tscanf(\"%d\", w + i);\n\t\tstd::sort(w + 1, w + L + 1);\n\t\tfor (int i = 1; i <= L; i++)\n\t\t\tif (!N || a[N] != w[i])\n\t\t\t{\n\t\t\t\ta[++N] = w[i];\n\t\t\t\tapr[N] = 1;\n\t\t\t}\n\t\t\telse\n\t\t\t\tapr[N]++;\n\t}\n\twhile (0);\n\tfor (int i = 1; i < N; i++)\n\t\tfor (int j = i + 1; j <= N; j++)\n\t\t\tif (gcd(a[i], a[j]) != 1)\n\t\t\t\tG[i][j] = G[j][i] = 1;\n\tfor (int i = 1; i <= N; i++)\n\t\tG[0][i] = G[i][0] = 1;\n\tint D = 1;\n\tq[1] = 0;\n\tue[1] = 0;\n\tv[0] = 1;\n\tref[L = 1] = 0;\n\twhile (D)\n\t{\n\t\twhile (ue[D] <= N && (!G[q[D]][ue[D]] || v[ue[D]]))\n\t\t\tue[D]++;\n\t\tif (ue[D] <= N)\n\t\t{\n\t\t\tint To = ue[D]++;\n\t\t\tSon[q[D]].push_back(To);\n\t\t\tq[++D] = To;\n\t\t\tue[D] = 0;\n\t\t\tv[ref[++L] = To] = 1;\n\t\t}\n\t\telse\n\t\t\tD--;\n\t}\n\tfor (int i = L; i; i--)\n\t{\n\t\tint u = ref[i];\n\t\tstd::vector < int > TMP;\n\t\tfor (int j : Son[u])\n\t\t\tTMP = merge(TMP, Ans[j]);\n\t\tAns[u].resize(TMP.size() + 1);\n\t\tAns[u][0] = u;\n\t\tstd::copy(TMP.begin(), TMP.end(), Ans[u].begin() + 1);\n\t}\n\tfor (int i : Ans[0])\n\t\tfor (int T = apr[i]; T--; )\n\t\t\tprintf(\"%d \", a[i]);\n\tputs(\"\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//MIPT Cryptozoology\n//Room 265\n#define _CRT_SECURE_NO_WARNINGS\n#pragma comment (linker, \"/STACK:128000000\")\n#include <stdio.h>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <queue>\n#include <deque>\n#include <cmath>\n#include <ctime>\n#include <stack>\n#include <bitset>\n#include <set>\n#include <map>\n#include <cassert>\n#include <memory.h>\n#include <sstream>\n\nusing namespace std;\n\n#define mp make_pair\n#define pb push_back\n#define all(a) a.begin(), a.end()\n#define itn int\n\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\n\ntypedef long long li;\ntypedef long long i64;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef pair <int, int> pi;\n\nvoid solve(bool);\n\nvoid precalc();\n\nint TESTNUM = 0;\n#define FILENAME \"\"\n\nint main() {\n\tstring s = FILENAME;\n#ifdef YA\n\t//assert(!s.empty());\n\tfreopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\t//cerr<<FILENAME<<endl;\n\t//assert (s != \"change me please\");\n\tclock_t start = clock();\n#else\n\t//freopen(\"input.txt\", \"r\", stdin);\n\t//freopen(\"output.txt\", \"w\", stdout);\n\t//freopen(FILENAME \".in\", \"r\", stdin);\n\t//freopen(FILENAME \".out\", \"w\", stdout);\n\tcin.tie(0);\n#endif\n\tcout.sync_with_stdio(0);\n\tcout.precision(10);\n\tcout << fixed;\n\tprecalc();\n\tint t = 1;\n\t//cin >> t;\n\tint test_num = 1;\n\twhile (t--) {\n\t\t//cout << \"Case #\" << test_num++ << \": \";\n\t\t++TESTNUM;\n\t\tsolve(true);\n\t}\n#ifdef YAH\n\twhile (true) {\n\t\tsolve(false);\n\t}\n#endif\n#ifdef YA\n\tcerr << \"\\n\\n\\n\" << (clock() - start) / 1.0 / CLOCKS_PER_SEC << \"\\n\\n\\n\";\n#endif\n\treturn 0;\n}\n\n//#define int li\n\n/*int pr[] = { 97, 2011 };\nint mods[] = { 1000000007, 1000000009 };\n\nconst int C = 100500;\nint powers[2][C];*/\n\n//int MOD = 1000000007;\n\n//int c[5010][5010];\n\ntemplate<typename T>\nT binpow(T q, T w, T mod) {\n\tif (!w)\n\t\treturn 1 % mod;\n\tif (w & 1)\n\t\treturn q * 1LL * binpow(q, w - 1, mod) % mod;\n\treturn binpow(q * 1LL * q % mod, w / 2, mod);\n}\n\nvoid precalc() {\n\n\t/*for (int w = 0; w < 2; ++w) {\n\tpowers[w][0] = 1;\n\tfor (int j = 1; j < C; ++j) {\n\tpowers[w][j] = (powers[w][j - 1] * 1LL * pr[w]) % mods[w];\n\t}\n\t}*/\n\n\t/*for (int i = 0; i < 5010; ++i) {\n\tc[i][i] = c[i][0] = 1;\n\tfor (int j = 1; j < i; ++j) {\n\tc[i][j] = (c[i - 1][j - 1] + c[i - 1][j]) % MOD;\n\t}\n\t}*/\n}\n\ntemplate<typename T>\nT gcd(T q, T w) {\n\twhile (w) {\n\t\tq %= w;\n\t\tswap(q, w);\n\t}\n\treturn q;\n}\ntemplate<typename T>\nT lcm(T q, T w) {\n\treturn q / gcd(q, w) * w;\n}\n\ninline int nxt(){\n\tint x;\n\tcin >> x;\n\treturn x;\n}\n\n//#define int li\n\nint n;\nvector<int> dsu;\nvoid init() {\n\tdsu.resize(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tdsu[i] = i;\n\t}\n}\n\nint find_set(int v) {\n\tif (dsu[v] == v) {\n\t\treturn v;\n\t}\n\treturn dsu[v] = find_set(dsu[v]);\n}\n\nvoid merge(int q, int w) {\n\tq = find_set(q);\n\tw = find_set(w);\n\tdsu[q] = w;\n}\n\nvoid solve(bool read) {\n\tcin >> n;\n\tvector<int> a(n);\n\tvector<vector<int>> primes(n);\n\tmap<int, set<int>> poses;\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> a[i];\n\t\tint cur = a[i];\n\t\tfor (int p = 2; p * p <= cur; ++p) {\n\t\t\tif (cur % p == 0) {\n\t\t\t\tposes[p].insert(i);\n\t\t\t\tprimes[i].push_back(p);\n\t\t\t\twhile (cur % p == 0) {\n\t\t\t\t\tcur /= p;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (cur > 1) {\n\t\t\tposes[cur].insert(i);\n\t\t\tprimes[i].push_back(cur);\n\t\t}\n\t}\n\tvector<int> res;\n\tvector<char> used(n, false);\n\tfor (int i = 0; i < n; ++i) {\n\t\tinit();\n\t\tfor (auto& item : poses) {\n\t\t\tfor (auto it = item.second.begin(); it != item.second.end(); ++it) {\n\t\t\t\tauto nex = it;\n\t\t\t\t++nex;\n\t\t\t\tif (nex == item.second.end()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tmerge(*it, *nex);\n\t\t\t}\n\t\t}\n\n\t\tvector<vector<int>> comps(n);\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tif (!used[i]) {\n\t\t\t\tcomps[find_set(i)].push_back(i);\n\t\t\t}\n\t\t}\n\n\t\tint cur_take = -1;\n\t\tint cur_id = -1;\n\t\tfor (int i = 0; i < comps.size(); ++i) {\n\t\t\tint best = 2e9;\n\t\t\tint best_id = -1;\n\t\t\tfor (int cur : comps[i]) {\n\t\t\t\tint cand = a[cur];\n\t\t\t\tbool f = true;\n\t\t\t\tfor (int prev = (int)res.size() - 1; prev >= 0; --prev) {\n\t\t\t\t\tif (gcd(res[prev], cand) > 1) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (cand > res[prev]) {\n\t\t\t\t\t\tf = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (f) {\n\t\t\t\t\tif (best > cand) {\n\t\t\t\t\t\tbest = cand;\n\t\t\t\t\t\tbest_id = cur;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!comps[i].empty() && best > cur_take) {\n\t\t\t\tcur_take = best;\n\t\t\t\tcur_id = best_id;\n\t\t\t}\n\t\t}\n\t\t\n\t\tassert(cur_take != -1);\n\t\tres.push_back(a[cur_id]);\n\t\tused[cur_id] = true;\n\t\tfor (int p : primes[cur_id]) {\n\t\t\tposes[p].erase(cur_id);\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; ++i) {\n\t\tcout << res[i] << \" \";\n\t}\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nbool coprime[2222][2222];\nbool used[2222];\n\nint gcd(int a, int b){\n\treturn b == 0 ? a : gcd(b,a%b);\n}\n\nint main(){\n\n\tint n;cin >> n;\n\tvector<int> v(n);REP(i,n)cin >> v[i];\n\tsort(ALL(v));\n\n\tREP(i,n){\n\t\tfor(int j = i+1;j < n;j++){\n\t\t\tif(gcd(v[i], v[j]) == 1){\n\t\t\t\tcoprime[i][j] = true;\n\t\t\t\tcoprime[j][i] = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<int> ans;\n\tREP(i,n){\n\t\tif(!used[i]){\n\t\t\tans.PB(v[i]);\n\t\t\tused[i] = true;\n\t\t\tif(v[i] == 1)continue;\n\t\t\tREP(j,n){\n\t\t\t\tif(!used[j] && !coprime[i][j]){\n\t\t\t\t\tused[j] = true;\n\t\t\t\t\tans.PB(v[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t//SHOW1d(ans,n);\n\n\tREP(i,n){\n\t\tREP(j,n-1){\n\t\t\tint tmp = ans[j];\n\t\t\tint cou = 0;\n\t\t\tfor(int k = 1;k+j < n;k++){\n\t\t\t\tif(gcd(ans[j+k], tmp) == 1){\n\t\t\t\t\tif(ans[j+k] > tmp)cou = k;\n\t\t\t\t}\n\t\t\t\telse break;\n\t\t\t}\n\t\t\tREP(k,cou)swap(ans[j+k],ans[j+k+1]);\n\t\t}\n\t}\n\n\tREP(i,n){\n\t\tfor(int j = n-1;j > 0;j--){\n\t\t\tint tmp = ans[j];\n\t\t\tint cou = 0;\n\t\t\tfor(int k = 1;j-k >= 0;k++){\n\t\t\t\tif(gcd(ans[j-k], tmp) == 1){\n\t\t\t\t\tif(ans[j-k] < tmp)cou = k;\n\t\t\t\t}\n\t\t\t\telse break;\n\t\t\t}\n\t\t\tREP(k,cou)swap(ans[j-k],ans[j-k-1]);\n\t\t}\n\t}\n\n\tREP(i,n)cout << ans[i] << \" \";cout << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define gc c=getchar()\n#define r(x) read(x)\n#define ll long long\n\ntemplate<typename T>\ninline void read(T&x){\n    x=0;T k=1;char gc;\n    while(!isdigit(c)){if(c=='-')k=-1;gc;}\n    while(isdigit(c)){x=x*10+c-'0';gc;}x*=k;\n}\n\nconst int N=2005;\n\nint gcd(int a,int b){\n\treturn b?gcd(b,a%b):a;\n}\n\nvector<int>G1[N];\nvector<int>G2[N];\n\nint a[N];\nint deg[N];\nbool vis[N];\n\nvoid dfs(int x){\n\tvis[x]=1;\n\tfor(int i=0;i<G1[x].size();++i){\n\t\tint v=G1[x][i];\n\t\tif(!vis[v]){\n\t\t\tG2[x].push_back(v);\n\t\t\tdeg[v]++;\n\t\t\tdfs(v);\n\t\t}\n\t}\n}\n\nint main(){\n//\tfreopen(\".in\",\"r\",stdin);\n//\tfreopen(\".out\",\"w\",stdout);\n\tint n;r(n);\n\tfor(int i=1;i<=n;++i)r(a[i]);\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;++i){\n\t\tfor(int j=i+1;j<=n;++j){\n\t\t\tif(gcd(a[i],a[j])!=1){\n\t\t\t\tG1[i].push_back(j);\n\t\t\t\tG1[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=1;i<=n;++i){\n\t\tif(!vis[i]){\n\t\t\tdfs(i);\n\t\t}\n\t}\n\tpriority_queue<pair<int,int> >Q;\n\tfor(int i=1;i<=n;++i){\n\t\tif(!deg[i]){\n\t\t\tQ.push(make_pair(a[i],i));\n\t\t}\n\t}\n\twhile(!Q.empty()){\n\t\tint x=Q.top().second;Q.pop();\n\t\tprintf(\"%d \",a[x]);\n\t\tfor(int i=0;i<G2[x].size();++i){\n\t\t\tint v=G2[x][i];\n\t\t\tif(!--deg[v]){\n\t\t\t\tQ.push(make_pair(a[v],v));\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define cmin(a,b) (a>b?a=b:a)\n#define cmax(a,b) (a<b?a=b:a)\n#define lop(i,s,t) for(int i=s;i<(t);++i)\n#define rep(i,s,t) for(int i=s;i<=(t);++i)\n#define dec(i,s,t) for(int i=s;i>=(t);--i)\n#define fore(i,v) for(int i=g[v],d=es[i].d;i;i=es[i].nxt,d=es[i].d)\nusing namespace std;\n\n#define Pr(f,...) //fprintf(stderr,f,##__VA_ARGS__),fflush(stderr)\n\nconst int N=2005; \n\nvoid read(int &x){\n\tx=0; \n\tchar c=getchar(); \n\tfor(;!isdigit(c);c=getchar()); \n\tfor(;isdigit(c);c=getchar())x=x*10+c-'0'; \n}\n\nint n,a[N],deg[N],vis[N];\nvector<int> g[N]; \n\nint gcd(int a,int b){ return !b?a:gcd(b,a%b); } \n\nvoid dfs(int v){\n\tvis[v]=1; \n\trep(d,1,n)if(!vis[d]&&gcd(a[d],a[v])>1){\n\t\tg[v].pb(d);\n\t\t++deg[d];\n\t\tPr(\"Link %d,%d\\n\",v,d); \n\t\tdfs(d); \n\t}\n}\n\nint main(int argc,char *argv[]){\n#ifdef CURIOUSCAT\n\t//freopen(\"dat.in\",\"r\",stdin);\n\t//freopen(\"my.out\",\"w\",stdout);\n#endif\n\tread(n); \n\trep(i,1,n)read(a[i]); \n\tsort(a+1,a+n+1); \n\trep(i,1,n)if(!vis[i])dfs(i); \n\tmemset(vis,0,sizeof(vis)); \n\trep(i,1,n){\n\t\tdec(j,n,1){\n\t\t\tif(!vis[j]&&!deg[j]){\n\t\t\t\tvis[j]=1;\n\t\t\t\tprintf(\"%d \",a[j]);\n\t\t\t\tfor(int d:g[j])--deg[d];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0; \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<cstring>\n#include<algorithm>\n#include<stack>\n#define ll long long\nusing namespace std;\nint n,a[2005],tot,du[2005],h[2005],to[4000005],nex[4000005];\nbool bhz[2005][2005],pd[2005];\nint gcd(int a,int b)\n{\n    return b?gcd(b,a%b):a;\n}\nstruct node{\n    int fr,id;\n}st;\nstack<node> q;\nvoid add(int a,int b)\n{\n    du[b]++;\n    tot++;\n    to[tot]=b;\n    nex[tot]=h[a];\n    h[a]=tot;\n}\nint dfs(int x)\n{\n    pd[x]++;\n    for(int i=1;i<=n;i++)\n        if(bhz[x][i]&&!pd[i])\n        {\n            add(x,i);\n            dfs(i);\n        }\n}\nint main()\n{\n    cin>>n;\n    for(int i=1;i<=n;i++) cin>>a[i];\n    sort(a+1,a+n+1);\n    for(int i=1;i<=n-1;i++)\n    for(int j=i+1;j<=n;j++)\n    if(gcd(a[i],a[j])>1) bhz[i][j]=bhz[j][i]=1;\n    for(int i=1;i<=n;i++) if(!pd[i]) dfs(i);\n    for(int i=1;i<=n;i++) \n        if(!du[i])\n        { \n            st.fr=a[i];\n            st.id=i;\n            q.push(st); \n        }\n    for(int i=1;i<=n;i++)\n    {\n        st=q.top();\n        q.pop();\n        int now=st.id;\n        cout<<a[now]<<endl;\n        for(int k=h[now];k;k=nex[now])\n        {\n            du[to[k]]--;\n            if(du[to[k]]==0)\n            {\n                st.fr=a[to[k]];\n                st.id=to[k];\n                q.push(st);\n            }\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nconst int MAXN = 2010;\nstd::priority_queue<int> q;\nstd::vector<int> to[MAXN], gr[MAXN];\nint gcd(int a, int b) { return b ? gcd(b, a % b) : a; }\nint n, A[MAXN], ind[MAXN], tim[MAXN], idx;\nbool vis[MAXN];\nvoid dfs(int u) {\n\tvis[u] = true; tim[u] = ++idx;\n\tfor (int i : gr[u]) if (!vis[i])\n\t\tdfs(i);\n}\nint main() {\n\tstd::ios_base::sync_with_stdio(false), std::cin.tie(0);\n\tstd::cin >> n;\n\tfor (int i = 1; i <= n; ++i) std::cin >> A[i];\n\tstd::sort(A + 1, A + 1 + n);\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (int j = i + 1; j <= n; ++j)\n\t\t\tif (gcd(A[i], A[j]) > 1) {\n\t\t\t\tgr[i].push_back(j);\n\t\t\t\tgr[j].push_back(i);\n\t\t\t}\n\tfor (int i = 1; i <= n; ++i) if (!vis[i]) dfs(i);\n\tfor (int i = 1; i <= n; ++i)\n\t\tfor (auto t : gr[i])\n\t\t\tif (tim[i] < tim[t])\n\t\t\t\t++ind[t], to[i].push_back(t);\n\tfor (int i = 1; i <= n; ++i) if (!ind[i]) q.push(i);\n\tfor (int i = 1, t; i <= n; ++i) {\n\t\tstd::cout << (A[t = q.top()]) << (\" \\n\" [i == n]); q.pop();\n\t\tfor (int j : to[t]) if (!--ind[j]) q.push(j);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint Eulg(int a, int b);\n\nint main(int argc, char *argv[]){\n\n\tint N;\n\tcin>>N;\n\n\tint *a = new int[N]();\n\n\tfor(int i=0; i<N; i++){\n\t\tcin>>a[i];\n\t}\n\n\tsort(a, a+N);\n\n\tbool flag = true;\n\twhile(flag){\n\tfor(int i=0; i<N; i++){\n\t\tfor(int j=i+1; j<N; j++){\n\t\t\tif(Eulg(a[i], a[j]) == 1){\n\t\t\t\tif(a[i]<a[j]){\n\t\t\t\t\tint tmp;\n\t\t\t\t\ttmp =a[i];\n\t\t\t\t\ta[i] = b[i];\n\t\t\t\t\tb[i] = tmp;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t}\n}\n\nfor(int i=0; i<N; i++)\n\tcout<<a[i]<<\"  \";\n\n\n\n\tdelete[] a;\n\treturn 0;\n}\n\nint Eulg(int a, int b){\n\tif(a<b){\n\t\tint tmp;\n\t\ttmp =a;\n\t\ta = b;\n\t\tb = tmp;\n\t}\n\n\tint r;\n\tr = a % b;\n\twhile(r){\n\t\ta = b;\n\t\tb = r;\n\t\tr = a % b;\n\t}\n\treturn b;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define REP(i, n) FOR (i, 0, n)\n#define _ << \" _ \" <<\n#define TRACE(x) cerr << #x << \" = \" << x << endl\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n//#define debug\n//#define TRACE(x)\n\nusing namespace std;\nusing vi = vector<int>;\n\ntypedef long long llint;\n\nconst int MAXN = 2010;\n\nint n, a[MAXN], adj[MAXN][MAXN];\nvector<int> e[MAXN];\nbool bio[MAXN];\n\nvoid dfs(int x) {\n  bio[x] = true;\n  REP(y, n) {\n    if (!adj[x][y]) continue;\n    if (bio[y]) continue;\n    e[x].push_back(y);\n    dfs(y);\n  }\n}\n\nvi solve(int x) {\n  vector<vi> v;\n  for (int y : e[x]) {\n    auto tmp = solve(y);\n    reverse(tmp.begin(), tmp.end());\n    v.push_back(tmp);\n  }\n\n  vector<int> ret;\n  if (x != n)\n    ret.push_back(x);\n  \n  while (true) {\n    int i = -1;\n    REP(j, (int)v.size()) {\n      if (v[j].empty()) continue;\n      if (i == -1 || v[j].back() > v[i].back())\n\ti = j;\n    }\n    if (i == -1) break;\n    ret.push_back(v[i].back());\n    v[i].pop_back();\n  }\n\n  return ret;\n}\n\nint main(void) {\n  scanf(\"%d\",&n);\n  REP(i, n) scanf(\"%d\",&a[i]);\n  sort(a, a + n);\n\n  REP(i, n) REP(j, i) \n    adj[i][j] = adj[j][i] = (__gcd(a[i], a[j]) > 1) ? 1 : 0;\n\n  REP(i, n)\n    if (!bio[i]) {\n      e[n].push_back(i);\n      dfs(i);\n    }\n\n  auto sol = solve(n);\n  for (int x : sol)\n    printf(\"%d \",a[x]);\n  printf(\"\\n\");\n    \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nconst int maxn = 2030, oo = 123456789, maxm = 34010;\n \nint n, m, T, ans, mn, a[maxn], foo[maxn], lst[maxm], tag[maxn], q[maxn], rar, mx[maxn];\nbool vis[maxn], f[maxn], G[maxn][maxn], F[maxn], fuck[maxm];\nstd::vector<int> g[maxn], has[maxn], rhas[maxm], all;\nstd::pair<int, int> v[2];\n \nvoid GEN() {\n\tint mx = 0;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tif(!foo[i]) {\n\t\t\tif(a[i] == 1) {\n\t\t\t\tF[i] = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tF[i] = 0;\n\t\t\t\tfor (int j: has[i]) {\n\t\t\t\t\tif(lst[j] >= mx) {\n\t\t\t\t\t\tF[i] = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t(foo[i] > mx) && (mx = foo[i]);\n\t\t}\n\t}\n\treturn;\n}\n\ninline void dfs(int &u) {\n\ttag[u] = T;\n\t(F[u] && a[u] < mn) && (mn = a[u]);\n\tvis[u] = 1;\n\tfor (int &i: has[u]) {\n\t\tif(!fuck[i]) {\n\t\t\tfuck[i] = 1;\n\t\t\tfor (int &j: rhas[i]) {\n\t\t\t\tif(!vis[j] && !f[j]) {\n\t\t\t\t\tdfs(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++i) {\n\t\tscanf(\"%d\", a + i);\n\t\tint t = a[i];\n\t\tfor (int x = 2; x * x <= t; ++x) {\n\t\t\tif(t % x == 0) {\n\t\t\t\tall.push_back(x);\n\t\t\t\twhile(t % x == 0) {\n\t\t\t\t\tt /= x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(t > 1) {\n\t\t\tall.push_back(t);\n\t\t}\n\t}\n\tstd::sort(a + 1, a + n + 1);\n\tstd::sort(all.begin(), all.end());\n\tall.resize(std::unique(all.begin(), all.end()) - all.begin());\n\tm = (int)(all.size());\n\tfor (int i = 1; i <= n; ++i) {\n\t\tF[i] = 1;\n\t\tfor (int j = 0; j < m; ++j) {\n\t\t\tif(a[i] % all[j] == 0) {\n\t\t\t\thas[i].push_back(j);\n\t\t\t\trhas[j].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int j = 0; j < m; ++j) {\n\t\tfor (int i = 0; i < (int)(rhas[j].size()); ++i) {\n\t\t\tfor (int k = 0; k < i; ++k) {\n\t\t\t\tint u = rhas[j][i], v = rhas[j][k];\n\t\t\t\tif(!G[u][v]) {\n\t\t\t\t\tg[u].push_back(v);\n\t\t\t\t\tg[v].push_back(u);\n\t\t\t\t\tG[u][v] = G[v][u] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 1; i <= n; ++i) {\n//\t\tGEN();\n\t\tmemset(vis + 1, 0, sizeof(vis[0]) * n);\n\t\tmemset(fuck, 0, sizeof(fuck[0]) * m);\n\t\tv[0] = v[1] = std::make_pair(-1, -1);\n\t\tfor (int u = 1; u <= n; ++u) {\n\t\t\tif(F[u]) {\n\t\t\t\tif(!vis[u] && !f[u]) {\n\t\t\t\t\t++T;\n\t\t\t\t\tmn = oo;\n\t\t\t\t\tdfs(u);\n\t\t\t\t\tif(mn > v[1].first) {\n\t\t\t\t\t\tv[0] = v[1];\n\t\t\t\t\t\tv[1] = std::make_pair(mn, T);\n\t\t\t\t\t}\n\t\t\t\t\telse if(mn > v[0].first) {\n\t\t\t\t\t\tv[0] = std::make_pair(mn, T);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//ans = 0;\n\t\tfor (int u = 1; u <= n; ++u) {\n\t\t\tif(F[u] && !f[u]) {\n\t\t\t\tint i = 1;\n\t\t\t\tif(v[i].second == tag[u]) {\n\t\t\t\t\t--i;\n\t\t\t\t}\n\t\t\t\tif(v[i].first <= a[u]) {\n\t\t\t\t\tans = u;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tf[ans] = 1;\n\t\tfoo[ans] = i;\n\t\tprintf(\"%d \", a[ans]);\n\t\tfor (int j: has[ans]) {\n\t\t\tlst[j] = i;\n\t\t}\n\t\tfor (register int &u: g[ans]) {\n\t\t\t\tF[u] = 1;\n\t\t}\n\t\tfor (register int j = ans + 1; j <= n; ++j) {\n\t\t\tmx[j] = i;\n\t\t\tF[j] = G[ans][j];\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<cmath>\n#include<queue>\n#include<bitset>\n#include<string>\n#include<cstdio>\n#include<cctype>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n#include<sstream>\n#include<numeric>\n#include<iostream>\n#include<algorithm>\n#include<functional>\n\n#define For(i,x,y) for (int i=x;i<y;i++)\n#define pb push_back\n#define mp make_pair\n#define fi first\n#define se second\n\n#define dprintf(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\n\ntypedef long long ll;\ntypedef double db;\ntypedef vector<int> Vi;\ntypedef pair<int,int> pii;\n\nint IN(){\n\tint c,f,x;\n\twhile (!isdigit(c=getchar())&&c!='-');c=='-'?(f=1,x=0):(f=0,x=c-'0');\n\twhile (isdigit(c=getchar())) x=(x<<1)+(x<<3)+c-'0';return !f?x:-x;\n}\n\nconst int N=200000+19;\nconst int oo=(1<<30)-1;\n\nstruct Edge{\n\tint y,nxt;\n} E[N];\nmap<int,int> M;\nint A[N],id[N],chk[N],vis[N],T[N];\nint n,Time,z,tot;\nVi V[N],S[N];\n\nvoid Init(int n,int m){\n\tfor (int i=2;i*i<=n;i++)\n\t\tif (n%i==0){\n\t\t\tif (!M.count(i)) M[i]=++tot;\n\t\t\tV[m].pb(M[i]);\n\t\t\tS[M[i]].pb(m);\n\t\t\twhile (n%i==0) n/=i;\n\t\t}\n\tif (n>1){\n\t\tif (!M.count(n)) M[n]=++tot;\n\t\tV[m].pb(M[n]);\n\t\tS[M[n]].pb(m);\n\t}\n}\nvoid dfs(int x){\n\tif (T[x]==Time) return;\n\tT[x]=Time;\n\tif (chk[x]){\n\t\tif (!z||A[x]<A[z]) z=x;\n\t\tchk[x]=0;\n\t}\n\tif (x<=n){\n\t\tfor (int i:V[x]) if (!vis[i]) dfs(i);\n\t} else{\n\t\tfor (int i:S[x]) if (!vis[i]) dfs(i);\n\t}\n}\nvoid Reset(){\n\tTime++;\n\tFor(i,1,n+1)\n\t\tif (!vis[i]&&T[i]!=Time){\n\t\t\tz=0;\n\t\t\tdfs(i);\n\t\t\tchk[z]=1;\n\t\t}\n}\n\nint main(){\n//\tfreopen(\"E.in\",\"r\",stdin);\n//\tfreopen(\"E.out\",\"w\",stdout);\n\ttot=n=IN();\n\tFor(i,1,n+1) A[i]=IN();\n\tsort(A+1,A+n+1);\n\tFor(i,1,n+1){\n\t\tInit(A[i],i);\n\t\tchk[i]=1;\n\t\tvis[i]=0;\n\t}\n\tReset();\n\tFor(t,1,n+1){\n\t\tint x=0;\n\t\tFor(i,1,n+1) if (!x||!vis[i]&&chk[i]&&A[i]>A[x]) x=i;\n\t\tprintf(\"%d \",A[x]);\n\t\tvis[x]=1;\n\t\tfor (int i:V[x]){\n\t\t\tfor (int y:S[i]) if (y!=x&&!vis[y]) chk[y]=1;\n\t\t}\n\t\tReset();\n\t}\n\tputs(\"\");\n}"
  },
  {
    "language": "C",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n\n#define rep(i,x,y) for (int i=x;i<=y;i++)\n#define dep(i,y,x) for (int i=y;i>=x;i--)\n#define sz(x) (int)(x.size())\n\nusing namespace std;\n\ntypedef long long LL; \ntypedef unsigned long long uLL;\n\nconst int maxn=2000+7;\n\nstruct Edge{\n int v,next;\n} E[maxn*maxn];\n\nint n,m,Esize,p,q,last[maxn],a[maxn],s[maxn];\nvector<int> v[maxn],temp;\n\nbool vis[maxn];\n\nint gcd(int x,int y) {return (y==0)?(x):(gcd(y,x%y));}\n\nvoid addedge(int x,int y)\n{\n E[++Esize]=(Edge){y,last[x]},last[x]=Esize;\n E[++Esize]=(Edge){x,last[y]},last[y]=Esize;\n // M[x][y]=M[y][x]=1;\n}\n\nvoid merge(int x,int y)\n{\n temp.resize(sz(v[x]));\n rep(i,0,sz(v[x])-1) temp[i]=v[x][i];\n \n p=0,q=0,m=sz(temp)+sz(v[y]),v[x].resize(m);\n rep(i,0,m-1)\n {\n  if (p>=sz(temp)) {v[x][i]=v[y][q],++q;continue;}\n  if (q>=sz(v[y])) {v[x][i]=temp[p],++p;continue;}\n\n  if (temp[p]>v[y][q]) v[x][i]=temp[p],++p; else v[x][i]=v[y][q],++q;\n }\n}\n\nvoid DFS(int k)\n{\n vis[k]=1;\n for (int i=last[k];i;i=E[i].next)\n {\n  int nxt=E[i].v;\n  if (vis[nxt]) continue;\n\n  DFS(nxt);\n  merge(k,nxt);v[nxt].clear();\n }\n \n m=sz(v[k]);\n rep(i,0,m-1) s[i+1]=v[k][i];\n v[k].resize(m+1);\n v[k][0]=a[k];\n rep(i,1,m) v[k][i]=s[i];\n}\n\nint main()\n{\n scanf(\"%d\",&n);\n rep(i,1,n) scanf(\"%d\",&a[i]);\n \n sort(a+1,a+n+1);\n rep(i,1,n/2) swap(a[i],a[n-i+1]);\n \n rep(i,1,n-1)\n  rep(j,i+1,n)\n   if (gcd(a[i],a[j])>1) addedge(i,j);\n \n memset(vis,0,sizeof(vis));\n dep(i,n,1)\n  if (!vis[i])\n  {\n   DFS(i);\n   merge(0,i);\n  }\n \n rep(i,1,n-1) printf(\"%d \",v[0][i-1]);\n printf(\"%d\\n\",v[0][n-1]);\n\n // system(\"pause\");\n return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint gcd(int a, int b) {\n\tif (a < b) return gcd(b, a);\n\tif (a%b == 0) return b;\n\treturn gcd(b, a%b);\n}\n\nint main() {\n\tint i, j, n;\n\tint *a;\n\tscanf(\"%d\",&n);\n\ta = (int*)malloc(sizeof(int)*n);\n\n\tfor (i = 0; i < n; i++) {\n\t\tscanf(\"%d\",&a[i]);\n\t}\n\n\tfor (i = 0; i < n; i++) {\n\t\tfor (j = 0; j < n-1 ; j++) {\n\t\t\tif (a[j] > a[j + 1]) swap(a[j],a[j+1]);\n\t\t}\n\t}\n\n\tfor (i = n; i >= 0; i--) {\n\t\tfor (j = n; j >= 1; j--) {\n\t\t\tif (gcd(a[j], a[j - 1]) == 1) swap(a[j], a[j - 1]);\n\t\t}\n\t}\n\n\tfor (i = 0; i < n; i++) {\n\t\tprintf(\"%d\",a[i]);\n\t\tif (i != n) printf(\" \");\n\t\telse printf(\"\\n\");\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.io.BufferedWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.NoSuchElementException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Egor Kulikov (egor@egork.net)\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskE solver = new TaskE();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskE {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.readInt();\n            int[] a = IOUtils.readIntArray(in, n);\n            ArrayUtils.sort(a);\n            boolean[][] notCoPrime = new boolean[n][n];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    notCoPrime[i][j] = IntegerUtils.gcd(a[i], a[j]) != 1;\n                }\n            }\n            int[] answer = new int[n];\n            boolean[] done = new boolean[n];\n            boolean[] taken = new boolean[n];\n            for (int i = 0; i < n; i++) {\n                IndependentSetSystem setSystem = new RecursiveIndependentSetSystem(n);\n                for (int j = 0; j < n; j++) {\n                    if (done[j]) {\n                        continue;\n                    }\n                    for (int k = 0; k < j; k++) {\n                        if (!done[k] && notCoPrime[j][k]) {\n                            setSystem.join(j, k);\n                        }\n                    }\n                }\n                Arrays.fill(taken, false);\n                int min = -1;\n                for (int j = 0; j < n; j++) {\n                    if (!done[j] && !taken[setSystem.get(j)]) {\n                        min = j;\n                        taken[setSystem.get(j)] = true;\n                    }\n                }\n                for (int j = min; j < n; j++) {\n                    if (done[j]) {\n                        continue;\n                    }\n                    boolean good = true;\n                    for (int k = i - 1; k >= 0; k--) {\n                        if (notCoPrime[j][answer[k]]) {\n                            break;\n                        }\n                        if (answer[k] < j) {\n                            good = false;\n                            break;\n                        }\n                    }\n                    if (good) {\n                        done[j] = true;\n                        answer[i] = j;\n                        break;\n                    }\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                answer[i] = a[answer[i]];\n            }\n            out.printLine(answer);\n        }\n\n    }\n\n    static interface IntCollection extends IntStream {\n        public int size();\n\n        default public void add(int value) {\n            throw new UnsupportedOperationException();\n        }\n\n        default public IntCollection addAll(IntStream values) {\n            for (IntIterator it = values.intIterator(); it.isValid(); it.advance()) {\n                add(it.value());\n            }\n            return this;\n        }\n\n    }\n\n    static class IntegerUtils {\n        public static int gcd(int a, int b) {\n            a = Math.abs(a);\n            b = Math.abs(b);\n            while (b != 0) {\n                int temp = a % b;\n                a = b;\n                b = temp;\n            }\n            return a;\n        }\n\n    }\n\n    static interface IntStream extends Iterable<Integer>, Comparable<IntStream> {\n        public IntIterator intIterator();\n\n        default public Iterator<Integer> iterator() {\n            return new Iterator<Integer>() {\n                private IntIterator it = intIterator();\n\n                public boolean hasNext() {\n                    return it.isValid();\n                }\n\n                public Integer next() {\n                    int result = it.value();\n                    it.advance();\n                    return result;\n                }\n            };\n        }\n\n        default public int compareTo(IntStream c) {\n            IntIterator it = intIterator();\n            IntIterator jt = c.intIterator();\n            while (it.isValid() && jt.isValid()) {\n                int i = it.value();\n                int j = jt.value();\n                if (i < j) {\n                    return -1;\n                } else if (i > j) {\n                    return 1;\n                }\n                it.advance();\n                jt.advance();\n            }\n            if (it.isValid()) {\n                return 1;\n            }\n            if (jt.isValid()) {\n                return -1;\n            }\n            return 0;\n        }\n\n    }\n\n    static abstract class IntAbstractStream implements IntStream {\n\n        public String toString() {\n            StringBuilder builder = new StringBuilder();\n            boolean first = true;\n            for (IntIterator it = intIterator(); it.isValid(); it.advance()) {\n                if (first) {\n                    first = false;\n                } else {\n                    builder.append(' ');\n                }\n                builder.append(it.value());\n            }\n            return builder.toString();\n        }\n\n\n        public boolean equals(Object o) {\n            if (!(o instanceof IntStream)) {\n                return false;\n            }\n            IntStream c = (IntStream) o;\n            IntIterator it = intIterator();\n            IntIterator jt = c.intIterator();\n            while (it.isValid() && jt.isValid()) {\n                if (it.value() != jt.value()) {\n                    return false;\n                }\n                it.advance();\n                jt.advance();\n            }\n            return !it.isValid() && !jt.isValid();\n        }\n\n\n        public int hashCode() {\n            int result = 0;\n            for (IntIterator it = intIterator(); it.isValid(); it.advance()) {\n                result *= 31;\n                result += it.value();\n            }\n            return result;\n        }\n\n    }\n\n    static class ArrayUtils {\n        public static int[] sort(int[] array) {\n            return sort(array, IntComparator.DEFAULT);\n        }\n\n        public static int[] sort(int[] array, IntComparator comparator) {\n            return sort(array, 0, array.length, comparator);\n        }\n\n        public static int[] sort(int[] array, int from, int to, IntComparator comparator) {\n            if (from == 0 && to == array.length) {\n                new IntArray(array).sort(comparator);\n            } else {\n                new IntArray(array).subList(from, to).sort(comparator);\n            }\n            return array;\n        }\n\n    }\n\n    static interface IntList extends IntReversableCollection {\n        public abstract int get(int index);\n\n        public abstract void set(int index, int value);\n\n        public abstract void addAt(int index, int value);\n\n        public abstract void removeAt(int index);\n\n        default public void swap(int first, int second) {\n            if (first == second) {\n                return;\n            }\n            int temp = get(first);\n            set(first, get(second));\n            set(second, temp);\n        }\n\n        default public IntIterator intIterator() {\n            return new IntIterator() {\n                private int at;\n                private boolean removed;\n\n                public int value() {\n                    if (removed) {\n                        throw new IllegalStateException();\n                    }\n                    return get(at);\n                }\n\n                public boolean advance() {\n                    at++;\n                    removed = false;\n                    return isValid();\n                }\n\n                public boolean isValid() {\n                    return !removed && at < size();\n                }\n\n                public void remove() {\n                    removeAt(at);\n                    at--;\n                    removed = true;\n                }\n            };\n        }\n\n\n        default public void add(int value) {\n            addAt(size(), value);\n        }\n\n        default public IntList sort(IntComparator comparator) {\n            Sorter.sort(this, comparator);\n            return this;\n        }\n\n        default public IntList subList(final int from, final int to) {\n            return new IntList() {\n                private final int shift;\n                private final int size;\n\n                {\n                    if (from < 0 || from > to || to > IntList.this.size()) {\n                        throw new IndexOutOfBoundsException(\"from = \" + from + \", to = \" + to + \", size = \" + size());\n                    }\n                    shift = from;\n                    size = to - from;\n                }\n\n                public int size() {\n                    return size;\n                }\n\n                public int get(int at) {\n                    if (at < 0 || at >= size) {\n                        throw new IndexOutOfBoundsException(\"at = \" + at + \", size = \" + size());\n                    }\n                    return IntList.this.get(at + shift);\n                }\n\n                public void addAt(int index, int value) {\n                    throw new UnsupportedOperationException();\n                }\n\n                public void removeAt(int index) {\n                    throw new UnsupportedOperationException();\n                }\n\n                public void set(int at, int value) {\n                    if (at < 0 || at >= size) {\n                        throw new IndexOutOfBoundsException(\"at = \" + at + \", size = \" + size());\n                    }\n                    IntList.this.set(at + shift, value);\n                }\n\n                public IntList compute() {\n                    return new IntArrayList(this);\n                }\n            };\n        }\n\n    }\n\n    static class IntArray extends IntAbstractStream implements IntList {\n        private int[] data;\n\n        public IntArray(int[] arr) {\n            data = arr;\n        }\n\n        public int size() {\n            return data.length;\n        }\n\n        public int get(int at) {\n            return data[at];\n        }\n\n        public void addAt(int index, int value) {\n            throw new UnsupportedOperationException();\n        }\n\n        public void removeAt(int index) {\n            throw new UnsupportedOperationException();\n        }\n\n        public void set(int index, int value) {\n            data[index] = value;\n        }\n\n    }\n\n    static interface IntReversableCollection extends IntCollection {\n    }\n\n    static interface IntIterator {\n        public int value() throws NoSuchElementException;\n\n        public boolean advance();\n\n        public boolean isValid();\n\n    }\n\n    static class IOUtils {\n        public static int[] readIntArray(InputReader in, int size) {\n            int[] array = new int[size];\n            for (int i = 0; i < size; i++) {\n                array[i] = in.readInt();\n            }\n            return array;\n        }\n\n    }\n\n    static class RecursiveIndependentSetSystem implements IndependentSetSystem {\n        private final int[] color;\n        private final int[] rank;\n        private int setCount;\n        private IndependentSetSystem.Listener listener;\n\n        public RecursiveIndependentSetSystem(int size) {\n            color = new int[size];\n            rank = new int[size];\n            for (int i = 0; i < size; i++) {\n                color[i] = i;\n            }\n            setCount = size;\n        }\n\n        public RecursiveIndependentSetSystem(RecursiveIndependentSetSystem other) {\n            color = other.color.clone();\n            rank = other.rank.clone();\n            setCount = other.setCount;\n        }\n\n        public boolean join(int first, int second) {\n            first = get(first);\n            second = get(second);\n            if (first == second) {\n                return false;\n            }\n            if (rank[first] < rank[second]) {\n                int temp = first;\n                first = second;\n                second = temp;\n            } else if (rank[first] == rank[second]) {\n                rank[first]++;\n            }\n            setCount--;\n            color[second] = first;\n            if (listener != null) {\n                listener.joined(second, first);\n            }\n            return true;\n        }\n\n        public int get(int index) {\n            int start = index;\n            while (color[index] != index) {\n                index = color[index];\n            }\n            while (start != index) {\n                int next = color[start];\n                color[start] = index;\n                start = next;\n            }\n            return index;\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n\n    static interface IntComparator {\n        public static final IntComparator DEFAULT = (first, second) -> {\n            if (first < second) {\n                return -1;\n            }\n            if (first > second) {\n                return 1;\n            }\n            return 0;\n        };\n\n        public int compare(int first, int second);\n\n    }\n\n    static interface IndependentSetSystem {\n        public boolean join(int first, int second);\n\n        public int get(int index);\n\n        public static interface Listener {\n            public void joined(int joinedRoot, int root);\n\n        }\n\n    }\n\n    static class Sorter {\n        private static final int INSERTION_THRESHOLD = 16;\n\n        private Sorter() {\n        }\n\n        public static void sort(IntList list, IntComparator comparator) {\n            quickSort(list, 0, list.size() - 1, (Integer.bitCount(Integer.highestOneBit(list.size()) - 1) * 5) >> 1,\n                    comparator);\n        }\n\n        private static void quickSort(IntList list, int from, int to, int remaining, IntComparator comparator) {\n            if (to - from < INSERTION_THRESHOLD) {\n                insertionSort(list, from, to, comparator);\n                return;\n            }\n            if (remaining == 0) {\n                heapSort(list, from, to, comparator);\n                return;\n            }\n            remaining--;\n            int pivotIndex = (from + to) >> 1;\n            int pivot = list.get(pivotIndex);\n            list.swap(pivotIndex, to);\n            int storeIndex = from;\n            int equalIndex = to;\n            for (int i = from; i < equalIndex; i++) {\n                int value = comparator.compare(list.get(i), pivot);\n                if (value < 0) {\n                    list.swap(storeIndex++, i);\n                } else if (value == 0) {\n                    list.swap(--equalIndex, i--);\n                }\n            }\n            quickSort(list, from, storeIndex - 1, remaining, comparator);\n            for (int i = equalIndex; i <= to; i++) {\n                list.swap(storeIndex++, i);\n            }\n            quickSort(list, storeIndex, to, remaining, comparator);\n        }\n\n        private static void heapSort(IntList list, int from, int to, IntComparator comparator) {\n            for (int i = (to + from - 1) >> 1; i >= from; i--) {\n                siftDown(list, i, to, comparator, from);\n            }\n            for (int i = to; i > from; i--) {\n                list.swap(from, i);\n                siftDown(list, from, i - 1, comparator, from);\n            }\n        }\n\n        private static void siftDown(IntList list, int start, int end, IntComparator comparator, int delta) {\n            int value = list.get(start);\n            while (true) {\n                int child = ((start - delta) << 1) + 1 + delta;\n                if (child > end) {\n                    return;\n                }\n                int childValue = list.get(child);\n                if (child + 1 <= end) {\n                    int otherValue = list.get(child + 1);\n                    if (comparator.compare(otherValue, childValue) > 0) {\n                        child++;\n                        childValue = otherValue;\n                    }\n                }\n                if (comparator.compare(value, childValue) >= 0) {\n                    return;\n                }\n                list.swap(start, child);\n                start = child;\n            }\n        }\n\n        private static void insertionSort(IntList list, int from, int to, IntComparator comparator) {\n            for (int i = from + 1; i <= to; i++) {\n                int value = list.get(i);\n                for (int j = i - 1; j >= from; j--) {\n                    if (comparator.compare(list.get(j), value) <= 0) {\n                        break;\n                    }\n                    list.swap(j, j + 1);\n                }\n            }\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void print(int[] array) {\n            for (int i = 0; i < array.length; i++) {\n                if (i != 0) {\n                    writer.print(' ');\n                }\n                writer.print(array[i]);\n            }\n        }\n\n        public void printLine(int[] array) {\n            print(array);\n            writer.println();\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n    }\n\n    static class IntArrayList extends IntAbstractStream implements IntList {\n        private int size;\n        private int[] data;\n\n        public IntArrayList() {\n            this(3);\n        }\n\n        public IntArrayList(int capacity) {\n            data = new int[capacity];\n        }\n\n        public IntArrayList(IntCollection c) {\n            this(c.size());\n            addAll(c);\n        }\n\n        public IntArrayList(IntStream c) {\n            this();\n            if (c instanceof IntCollection) {\n                ensureCapacity(((IntCollection) c).size());\n            }\n            addAll(c);\n        }\n\n        public IntArrayList(IntArrayList c) {\n            size = c.size();\n            data = c.data.clone();\n        }\n\n        public IntArrayList(int[] arr) {\n            size = arr.length;\n            data = arr.clone();\n        }\n\n        public int size() {\n            return size;\n        }\n\n        public int get(int at) {\n            if (at >= size) {\n                throw new IndexOutOfBoundsException(\"at = \" + at + \", size = \" + size);\n            }\n            return data[at];\n        }\n\n        private void ensureCapacity(int capacity) {\n            if (data.length >= capacity) {\n                return;\n            }\n            capacity = Math.max(2 * data.length, capacity);\n            data = Arrays.copyOf(data, capacity);\n        }\n\n        public void addAt(int index, int value) {\n            ensureCapacity(size + 1);\n            if (index > size || index < 0) {\n                throw new IndexOutOfBoundsException(\"at = \" + index + \", size = \" + size);\n            }\n            if (index != size) {\n                System.arraycopy(data, index, data, index + 1, size - index);\n            }\n            data[index] = value;\n            size++;\n        }\n\n        public void removeAt(int index) {\n            if (index >= size || index < 0) {\n                throw new IndexOutOfBoundsException(\"at = \" + index + \", size = \" + size);\n            }\n            if (index != size - 1) {\n                System.arraycopy(data, index + 1, data, index, size - index - 1);\n            }\n            size--;\n        }\n\n        public void set(int index, int value) {\n            if (index >= size) {\n                throw new IndexOutOfBoundsException(\"at = \" + index + \", size = \" + size);\n            }\n            data[index] = value;\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.util.Map;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskE solver = new TaskE();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskE {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            TaskE.Number[] numbers = new TaskE.Number[n];\n            for (int i = 0; i < n; ++i) {\n                numbers[i] = new TaskE.Number(in.nextInt());\n            }\n            Arrays.sort(numbers);\n            for (int i = 0; i < n; ++i) numbers[i].pos = i;\n            Map<Integer, List<TaskE.Number>> divisorToNumbers = new HashMap<>();\n            for (TaskE.Number num : numbers) {\n                int a = num.a;\n                for (int i = 2; i * i <= a; ++i)\n                    if (a % i == 0) {\n                        while (a % i == 0) a /= i;\n                        List<TaskE.Number> old = divisorToNumbers.get(i);\n                        if (old == null) {\n                            old = new ArrayList<>(2);\n                            divisorToNumbers.put(i, old);\n                        }\n                        old.add(num);\n                    }\n                if (a > 1) {\n                    int i = a;\n                    while (a % i == 0) a /= i;\n                    List<TaskE.Number> old = divisorToNumbers.get(i);\n                    if (old == null) {\n                        old = new ArrayList<>(2);\n                        divisorToNumbers.put(i, old);\n                    }\n                    old.add(num);\n                }\n            }\n            for (List<TaskE.Number> l : divisorToNumbers.values()) {\n                if (l.size() < 2) continue;\n                TaskE.Divisor d = new TaskE.Divisor();\n                List<TaskE.NumberAndDivisor> seq = new ArrayList<>();\n                seq.add(new TaskE.NumberAndDivisor(null, null));\n                for (TaskE.Number num : l) {\n                    seq.add(new TaskE.NumberAndDivisor(num, d));\n                }\n                for (int i = 0; i < seq.size(); ++i) {\n                    int j = (i + 1) % seq.size();\n                    seq.get(i).next = seq.get(j);\n                    seq.get(j).prev = seq.get(i);\n                }\n            }\n            int curGeneration = 0;\n            List<TaskE.Number> stack = new ArrayList<>();\n            for (int i = 0; i < n; ++i) {\n                ++curGeneration;\n                int minAllowed = 0;\n                for (TaskE.Number number : numbers) {\n                    if (number.divs == null) continue;\n                    if (number.generation == curGeneration) continue;\n                    int minPos = number.findMinPos(curGeneration);\n                    minAllowed = Math.max(minAllowed, minPos);\n                }\n                TaskE.Number nxt = null;\n                outer:\n                for (int j = minAllowed; j < numbers.length; ++j) {\n                    TaskE.Number num = numbers[j];\n                    if (num.divs == null) continue;\n                    int left = -1;\n                    int right = stack.size();\n                    while (right - left > 1) {\n                        int middle = (left + right) >> 1;\n                        if (stack.get(middle).a < num.a) {\n                            left = middle;\n                        } else {\n                            right = middle;\n                        }\n                    }\n                    if (left < 0) {\n                        nxt = num;\n                        break outer;\n                    }\n                    for (TaskE.NumberAndDivisor div : num.divs) {\n                        TaskE.Divisor d = div.d;\n                        if (d.lastOccurrence >= stack.get(left).resPos) {\n                            nxt = num;\n                            break outer;\n                        }\n                    }\n                }\n                if (nxt == null) throw new RuntimeException();\n                if (i > 0) out.print(\" \");\n                out.print(nxt.a);\n                for (TaskE.NumberAndDivisor div : nxt.divs) {\n                    div.next.prev = div.prev;\n                    div.prev.next = div.next;\n                    div.d.lastOccurrence = i;\n                }\n                nxt.divs = null;\n                nxt.resPos = i;\n                while (!stack.isEmpty() && stack.get(stack.size() - 1).a >= nxt.a) {\n                    stack.remove(stack.size() - 1);\n                }\n                stack.add(nxt);\n            }\n            out.println();\n        }\n\n        static class Divisor {\n            int lastOccurrence = -1;\n\n        }\n\n        static class NumberAndDivisor {\n            TaskE.NumberAndDivisor next;\n            TaskE.NumberAndDivisor prev;\n            TaskE.Number n;\n            TaskE.Divisor d;\n\n            public NumberAndDivisor(TaskE.Number n, TaskE.Divisor d) {\n                this.n = n;\n                this.d = d;\n                if (n != null) n.divs.add(this);\n            }\n\n        }\n\n        static class Number implements Comparable<TaskE.Number> {\n            int a;\n            int pos;\n            int generation;\n            int resPos = -1;\n            List<TaskE.NumberAndDivisor> divs = new ArrayList<>();\n\n            public Number(int a) {\n                this.a = a;\n            }\n\n\n            public int compareTo(TaskE.Number o) {\n                return Integer.compare(a, o.a);\n            }\n\n            public int findMinPos(int curGeneration) {\n                if (generation == curGeneration) return pos;\n                generation = curGeneration;\n                int res = pos;\n                for (TaskE.NumberAndDivisor div : divs) {\n                    if (div.next.n != null) {\n                        res = Math.min(res, div.next.n.findMinPos(curGeneration));\n                    }\n                    if (div.prev.n != null) {\n                        res = Math.min(res, div.prev.n.findMinPos(curGeneration));\n                    }\n                }\n                return res;\n            }\n\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.util.Map;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskE solver = new TaskE();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskE {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            TaskE.Number[] numbers = new TaskE.Number[n];\n            for (int i = 0; i < n; ++i) {\n                numbers[i] = new TaskE.Number(in.nextInt());\n            }\n            Arrays.sort(numbers);\n            for (int i = 0; i < n; ++i) numbers[i].pos = i;\n            Map<Integer, List<TaskE.Number>> divisorToNumbers = new HashMap<>();\n            for (TaskE.Number num : numbers) {\n                int a = num.a;\n                for (int i = 2; i * i <= a; ++i)\n                    if (a % i == 0) {\n                        while (a % i == 0) a /= i;\n                        List<TaskE.Number> old = divisorToNumbers.get(i);\n                        if (old == null) {\n                            old = new ArrayList<>(2);\n                            divisorToNumbers.put(i, old);\n                        }\n                        old.add(num);\n                    }\n                if (a > 1) {\n                    int i = a;\n                    while (a % i == 0) a /= i;\n                    List<TaskE.Number> old = divisorToNumbers.get(i);\n                    if (old == null) {\n                        old = new ArrayList<>(2);\n                        divisorToNumbers.put(i, old);\n                    }\n                    old.add(num);\n                }\n            }\n            for (List<TaskE.Number> l : divisorToNumbers.values()) {\n                if (l.size() < 2) continue;\n                TaskE.Divisor d = new TaskE.Divisor();\n                List<TaskE.NumberAndDivisor> seq = new ArrayList<>();\n                seq.add(new TaskE.NumberAndDivisor(null, null));\n                for (TaskE.Number num : l) {\n                    seq.add(new TaskE.NumberAndDivisor(num, d));\n                }\n                for (int i = 0; i < seq.size(); ++i) {\n                    int j = (i + 1) % seq.size();\n                    seq.get(i).next = seq.get(j);\n                    seq.get(j).prev = seq.get(i);\n                }\n            }\n            int curGeneration = 0;\n            List<TaskE.Number> stack = new ArrayList<>();\n            for (int i = 0; i < n; ++i) {\n                ++curGeneration;\n                int minAllowed = -1;\n                for (TaskE.Number number : numbers) {\n                    if (number.divs == null) continue;\n                    if (number.generation == curGeneration) continue;\n                    int minPos = number.findMinPos(curGeneration);\n                    minAllowed = Math.max(minAllowed, minPos);\n                }\n                if (minAllowed < 0) throw new RuntimeException();\n                TaskE.Number nxt = null;\n                outer:\n                for (int j = minAllowed; j < numbers.length; ++j) {\n                    TaskE.Number num = numbers[j];\n                    if (num.divs == null) continue;\n                    int left = -1;\n                    int right = stack.size();\n                    while (right - left > 1) {\n                        int middle = (left + right) >> 1;\n                        if (stack.get(middle).a < num.a) {\n                            left = middle;\n                        } else {\n                            right = middle;\n                        }\n                    }\n                    if (left < 0) {\n                        nxt = num;\n                        break outer;\n                    }\n                    for (TaskE.NumberAndDivisor div : num.divs) {\n                        TaskE.Divisor d = div.d;\n                        if (d.lastOccurrence >= stack.get(left).resPos) {\n                            nxt = num;\n                            break outer;\n                        }\n                    }\n                }\n                if (nxt == null) throw new RuntimeException();\n                if (i > 0) out.print(\" \");\n                out.print(nxt.a);\n                for (TaskE.NumberAndDivisor div : nxt.divs) {\n                    div.next.prev = div.prev;\n                    div.prev.next = div.next;\n                    div.d.lastOccurrence = i;\n                }\n                nxt.divs = null;\n                nxt.resPos = i;\n                while (!stack.isEmpty() && stack.get(stack.size() - 1).a >= nxt.a) {\n                    stack.remove(stack.size() - 1);\n                }\n                stack.add(nxt);\n            }\n            out.println();\n        }\n\n        static class Divisor {\n            int lastOccurrence = -1;\n\n        }\n\n        static class NumberAndDivisor {\n            TaskE.NumberAndDivisor next;\n            TaskE.NumberAndDivisor prev;\n            TaskE.Number n;\n            TaskE.Divisor d;\n\n            public NumberAndDivisor(TaskE.Number n, TaskE.Divisor d) {\n                this.n = n;\n                this.d = d;\n                if (n != null) n.divs.add(this);\n            }\n\n        }\n\n        static class Number implements Comparable<TaskE.Number> {\n            int a;\n            int pos;\n            int generation;\n            int resPos = -1;\n            List<TaskE.NumberAndDivisor> divs = new ArrayList<>();\n\n            public Number(int a) {\n                this.a = a;\n            }\n\n\n            public int compareTo(TaskE.Number o) {\n                return Integer.compare(a, o.a);\n            }\n\n            public int findMinPos(int curGeneration) {\n                if (generation == curGeneration) return pos;\n                generation = curGeneration;\n                int res = pos;\n                for (TaskE.NumberAndDivisor div : divs) {\n                    if (div.next.n != null) {\n                        res = Math.min(res, div.next.n.findMinPos(curGeneration));\n                    }\n                    if (div.prev.n != null) {\n                        res = Math.min(res, div.prev.n.findMinPos(curGeneration));\n                    }\n                }\n                return res;\n            }\n\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "// package agc.agc010;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.List;\n\npublic class Main {\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = in.nextInt();\n        gcd = new int[n][n];\n        graph = new List[n+1];\n        visited = new boolean[n];\n        for (int i = 0; i <= n ; i++) {\n            graph[i] = new ArrayList<>();\n        }\n        uf = new UnionFind(n);\n\n        a = new int[n];\n        for (int i = 0; i < n ; i++) {\n            a[i] = in.nextInt();\n        }\n        Arrays.sort(a);\n\n        for (int i = 0; i < n ; i++) {\n            for (int j = i+1; j < n; j++) {\n                gcd[i][j] = gcd[j][i] = (int)gcd(a[i], a[j]);\n                if (gcd[i][j] >= 2) {\n                    uf.unite(i, j);\n                }\n            }\n        }\n\n        List<Integer> roots = new ArrayList<>();\n        for (int i = 0; i < n ; i++) {\n            if (!visited[i]) {\n                roots.add(i);\n                makeTree(i);\n                graph[n].add(i);\n            }\n        }\n\n        int[] ans = dfs(n);\n        StringBuilder line = new StringBuilder();\n        for (int i = 1 ; i < ans.length ; i++) {\n            line.append(' ').append(ans[i]);\n        }\n        out.println(line.substring(1));\n        out.flush();\n    }\n\n    static int[] a;\n    static int[][] gcd;\n    static UnionFind uf;\n    static List<Integer>[] graph;\n    static boolean[] visited;\n\n    static int[] dfs(int now) {\n        int cn = graph[now].size();\n\n        int[][] ln = new int[cn][];\n        for (int i = 0; i < cn ; i++) {\n            ln[i] = dfs(graph[now].get(i));\n        }\n        return merge(now >= a.length ? 0 : a[now], ln);\n    }\n\n    static int[] merge(int x, int[][] cn) {\n        int l = 1;\n        int gn = cn.length;\n        for (int i = 0; i < gn ; i++) {\n            l += cn[i].length;\n        }\n        int[] d = new int[l];\n        d[0] = x;\n\n        int[] gi = new int[gn];\n        for (int i = 1 ; i < l ; i++) {\n            int ma = 0;\n            int max = 0;\n            for (int j = 0; j < gn ; j++) {\n                if (gi[j] < cn[j].length && max < cn[j][gi[j]]) {\n                    max = cn[j][gi[j]];\n                    ma = j;\n                }\n            }\n            d[i] = max;\n            gi[ma]++;\n        }\n        return d;\n    }\n\n    static void makeTree(int idx) {\n        visited[idx] = true;\n        for (int i = 0 ; i < a.length ; i++) {\n            if (!visited[i] && gcd[idx][i] >= 2) {\n                graph[idx].add(i);\n                makeTree(i);\n            }\n        }\n    }\n\n    public static long gcd(long a, long b) {\n        return b == 0 ? a : gcd(b, a%b);\n    }\n    \n    static class UnionFind {\n        int[] rank;\n        int[] parent;\n        int[] cnt;\n\n        public UnionFind(int n) {\n            rank = new int[n];\n            parent = new int[n];\n            cnt = new int[n];\n            for (int i = 0; i < n; i++) {\n                parent[i] = i;\n                cnt[i] = 1;\n            }\n        }\n\n        public int find(int a) {\n            if (parent[a] == a) {\n                return a;\n            }\n            parent[a] = find(parent[a]);\n            return parent[a];\n        }\n\n        public void unite(int a, int b) {\n            a = find(a);\n            b = find(b);\n            if (a == b) {\n                return;\n            }\n            if (rank[a] < rank[b]) {\n                parent[a] = b;\n                cnt[b] += cnt[a];\n                cnt[a] = cnt[b];\n            } else {\n                parent[b] = a;\n                cnt[a] += cnt[b];\n                cnt[b] = cnt[a];\n                if (rank[a] == rank[b]) {\n                    rank[a]++;\n                }\n            }\n        }\n\n        public int groupCount(int a) {\n            return cnt[find(a)];\n        }\n\n        private boolean issame(int a, int b) {\n            return find(a) == find(b);\n        }\n    }\n\n\n    public static void debug(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n\n    public static class InputReader {\n        private static final int BUFFER_LENGTH = 1 << 12;\n        private InputStream stream;\n        private byte[] buf = new byte[BUFFER_LENGTH];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int next() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public char nextChar() {\n            return (char) skipWhileSpace();\n        }\n\n        public String nextToken() {\n            int c = skipWhileSpace();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.append((char) c);\n                c = next();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public int nextInt() {\n            return (int) nextLong();\n        }\n\n        public long nextLong() {\n            int c = skipWhileSpace();\n            long sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public double nextDouble() {\n            return Double.valueOf(nextToken());\n        }\n\n        int skipWhileSpace() {\n            int c = next();\n            while (isSpaceChar(c)) {\n                c = next();\n            }\n            return c;\n        }\n\n        boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.io.BufferedWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.NoSuchElementException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Egor Kulikov (egor@egork.net)\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskE solver = new TaskE();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskE {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.readInt();\n            int[] a = IOUtils.readIntArray(in, n);\n            ArrayUtils.sort(a);\n            boolean[][] notCoPrime = new boolean[n][n];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    notCoPrime[i][j] = IntegerUtils.gcd(a[i], a[j]) != 1;\n                }\n            }\n            int[] answer = new int[n];\n            boolean[] done = new boolean[n];\n            boolean[] taken = new boolean[n];\n            for (int i = 0; i < n; i++) {\n                IndependentSetSystem setSystem = new ListIndependentSetSystem(n);\n                for (int j = 0; j < n; j++) {\n                    if (done[j]) {\n                        continue;\n                    }\n                    for (int k = 0; k < j; k++) {\n                        if (!done[k] && notCoPrime[j][k]) {\n                            setSystem.join(j, k);\n                        }\n                    }\n                }\n                Arrays.fill(taken, false);\n                int min = -1;\n                for (int j = 0; j < n; j++) {\n                    if (!done[j] && !taken[setSystem.get(j)]) {\n                        min = j;\n                        taken[setSystem.get(j)] = true;\n                    }\n                }\n                for (int j = min; j < n; j++) {\n                    if (done[j]) {\n                        continue;\n                    }\n                    boolean good = true;\n                    for (int k = i - 1; k >= 0; k--) {\n                        if (notCoPrime[j][answer[k]]) {\n                            break;\n                        }\n                        if (answer[k] < j) {\n                            good = false;\n                            break;\n                        }\n                    }\n                    if (good) {\n                        done[j] = true;\n                        answer[i] = j;\n                        break;\n                    }\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                answer[i] = a[answer[i]];\n            }\n            out.printLine(answer);\n        }\n\n    }\n\n    static interface IntCollection extends IntStream {\n        public int size();\n\n        default public void add(int value) {\n            throw new UnsupportedOperationException();\n        }\n\n        default public IntCollection addAll(IntStream values) {\n            for (IntIterator it = values.intIterator(); it.isValid(); it.advance()) {\n                add(it.value());\n            }\n            return this;\n        }\n\n    }\n\n    static class Sorter {\n        private static final int INSERTION_THRESHOLD = 16;\n\n        private Sorter() {\n        }\n\n        public static void sort(IntList list, IntComparator comparator) {\n            quickSort(list, 0, list.size() - 1, (Integer.bitCount(Integer.highestOneBit(list.size()) - 1) * 5) >> 1,\n                    comparator);\n        }\n\n        private static void quickSort(IntList list, int from, int to, int remaining, IntComparator comparator) {\n            if (to - from < INSERTION_THRESHOLD) {\n                insertionSort(list, from, to, comparator);\n                return;\n            }\n            if (remaining == 0) {\n                heapSort(list, from, to, comparator);\n                return;\n            }\n            remaining--;\n            int pivotIndex = (from + to) >> 1;\n            int pivot = list.get(pivotIndex);\n            list.swap(pivotIndex, to);\n            int storeIndex = from;\n            int equalIndex = to;\n            for (int i = from; i < equalIndex; i++) {\n                int value = comparator.compare(list.get(i), pivot);\n                if (value < 0) {\n                    list.swap(storeIndex++, i);\n                } else if (value == 0) {\n                    list.swap(--equalIndex, i--);\n                }\n            }\n            quickSort(list, from, storeIndex - 1, remaining, comparator);\n            for (int i = equalIndex; i <= to; i++) {\n                list.swap(storeIndex++, i);\n            }\n            quickSort(list, storeIndex, to, remaining, comparator);\n        }\n\n        private static void heapSort(IntList list, int from, int to, IntComparator comparator) {\n            for (int i = (to + from - 1) >> 1; i >= from; i--) {\n                siftDown(list, i, to, comparator, from);\n            }\n            for (int i = to; i > from; i--) {\n                list.swap(from, i);\n                siftDown(list, from, i - 1, comparator, from);\n            }\n        }\n\n        private static void siftDown(IntList list, int start, int end, IntComparator comparator, int delta) {\n            int value = list.get(start);\n            while (true) {\n                int child = ((start - delta) << 1) + 1 + delta;\n                if (child > end) {\n                    return;\n                }\n                int childValue = list.get(child);\n                if (child + 1 <= end) {\n                    int otherValue = list.get(child + 1);\n                    if (comparator.compare(otherValue, childValue) > 0) {\n                        child++;\n                        childValue = otherValue;\n                    }\n                }\n                if (comparator.compare(value, childValue) >= 0) {\n                    return;\n                }\n                list.swap(start, child);\n                start = child;\n            }\n        }\n\n        private static void insertionSort(IntList list, int from, int to, IntComparator comparator) {\n            for (int i = from + 1; i <= to; i++) {\n                int value = list.get(i);\n                for (int j = i - 1; j >= from; j--) {\n                    if (comparator.compare(list.get(j), value) <= 0) {\n                        break;\n                    }\n                    list.swap(j, j + 1);\n                }\n            }\n        }\n\n    }\n\n    static class IntegerUtils {\n        public static int gcd(int a, int b) {\n            a = Math.abs(a);\n            b = Math.abs(b);\n            while (b != 0) {\n                int temp = a % b;\n                a = b;\n                b = temp;\n            }\n            return a;\n        }\n\n    }\n\n    static interface IntStream extends Iterable<Integer>, Comparable<IntStream> {\n        public IntIterator intIterator();\n\n        default public Iterator<Integer> iterator() {\n            return new Iterator<Integer>() {\n                private IntIterator it = intIterator();\n\n                public boolean hasNext() {\n                    return it.isValid();\n                }\n\n                public Integer next() {\n                    int result = it.value();\n                    it.advance();\n                    return result;\n                }\n            };\n        }\n\n        default public int compareTo(IntStream c) {\n            IntIterator it = intIterator();\n            IntIterator jt = c.intIterator();\n            while (it.isValid() && jt.isValid()) {\n                int i = it.value();\n                int j = jt.value();\n                if (i < j) {\n                    return -1;\n                } else if (i > j) {\n                    return 1;\n                }\n                it.advance();\n                jt.advance();\n            }\n            if (it.isValid()) {\n                return 1;\n            }\n            if (jt.isValid()) {\n                return -1;\n            }\n            return 0;\n        }\n\n        default public void forEach(IntTask task) {\n            for (IntIterator it = intIterator(); it.isValid(); it.advance()) {\n                task.process(it.value());\n            }\n        }\n\n    }\n\n    static abstract class IntAbstractStream implements IntStream {\n\n        public String toString() {\n            StringBuilder builder = new StringBuilder();\n            boolean first = true;\n            for (IntIterator it = intIterator(); it.isValid(); it.advance()) {\n                if (first) {\n                    first = false;\n                } else {\n                    builder.append(' ');\n                }\n                builder.append(it.value());\n            }\n            return builder.toString();\n        }\n\n\n        public boolean equals(Object o) {\n            if (!(o instanceof IntStream)) {\n                return false;\n            }\n            IntStream c = (IntStream) o;\n            IntIterator it = intIterator();\n            IntIterator jt = c.intIterator();\n            while (it.isValid() && jt.isValid()) {\n                if (it.value() != jt.value()) {\n                    return false;\n                }\n                it.advance();\n                jt.advance();\n            }\n            return !it.isValid() && !jt.isValid();\n        }\n\n\n        public int hashCode() {\n            int result = 0;\n            for (IntIterator it = intIterator(); it.isValid(); it.advance()) {\n                result *= 31;\n                result += it.value();\n            }\n            return result;\n        }\n\n    }\n\n    static class IntArrayList extends IntAbstractStream implements IntList {\n        private int size;\n        private int[] data;\n\n        public IntArrayList() {\n            this(3);\n        }\n\n        public IntArrayList(int capacity) {\n            data = new int[capacity];\n        }\n\n        public IntArrayList(IntCollection c) {\n            this(c.size());\n            addAll(c);\n        }\n\n        public IntArrayList(IntStream c) {\n            this();\n            if (c instanceof IntCollection) {\n                ensureCapacity(((IntCollection) c).size());\n            }\n            addAll(c);\n        }\n\n        public IntArrayList(IntArrayList c) {\n            size = c.size();\n            data = c.data.clone();\n        }\n\n        public IntArrayList(int[] arr) {\n            size = arr.length;\n            data = arr.clone();\n        }\n\n        public int size() {\n            return size;\n        }\n\n        public int get(int at) {\n            if (at >= size) {\n                throw new IndexOutOfBoundsException(\"at = \" + at + \", size = \" + size);\n            }\n            return data[at];\n        }\n\n        private void ensureCapacity(int capacity) {\n            if (data.length >= capacity) {\n                return;\n            }\n            capacity = Math.max(2 * data.length, capacity);\n            data = Arrays.copyOf(data, capacity);\n        }\n\n        public void addAt(int index, int value) {\n            ensureCapacity(size + 1);\n            if (index > size || index < 0) {\n                throw new IndexOutOfBoundsException(\"at = \" + index + \", size = \" + size);\n            }\n            if (index != size) {\n                System.arraycopy(data, index, data, index + 1, size - index);\n            }\n            data[index] = value;\n            size++;\n        }\n\n        public void removeAt(int index) {\n            if (index >= size || index < 0) {\n                throw new IndexOutOfBoundsException(\"at = \" + index + \", size = \" + size);\n            }\n            if (index != size - 1) {\n                System.arraycopy(data, index + 1, data, index, size - index - 1);\n            }\n            size--;\n        }\n\n        public void set(int index, int value) {\n            if (index >= size) {\n                throw new IndexOutOfBoundsException(\"at = \" + index + \", size = \" + size);\n            }\n            data[index] = value;\n        }\n\n    }\n\n    static class ArrayUtils {\n        public static int[] sort(int[] array) {\n            return sort(array, IntComparator.DEFAULT);\n        }\n\n        public static int[] sort(int[] array, IntComparator comparator) {\n            return sort(array, 0, array.length, comparator);\n        }\n\n        public static int[] sort(int[] array, int from, int to, IntComparator comparator) {\n            if (from == 0 && to == array.length) {\n                new IntArray(array).sort(comparator);\n            } else {\n                new IntArray(array).subList(from, to).sort(comparator);\n            }\n            return array;\n        }\n\n    }\n\n    static interface IntList extends IntReversableCollection {\n        public abstract int get(int index);\n\n        public abstract void set(int index, int value);\n\n        public abstract void addAt(int index, int value);\n\n        public abstract void removeAt(int index);\n\n        default public void swap(int first, int second) {\n            if (first == second) {\n                return;\n            }\n            int temp = get(first);\n            set(first, get(second));\n            set(second, temp);\n        }\n\n        default public IntIterator intIterator() {\n            return new IntIterator() {\n                private int at;\n                private boolean removed;\n\n                public int value() {\n                    if (removed) {\n                        throw new IllegalStateException();\n                    }\n                    return get(at);\n                }\n\n                public boolean advance() {\n                    at++;\n                    removed = false;\n                    return isValid();\n                }\n\n                public boolean isValid() {\n                    return !removed && at < size();\n                }\n\n                public void remove() {\n                    removeAt(at);\n                    at--;\n                    removed = true;\n                }\n            };\n        }\n\n\n        default public void add(int value) {\n            addAt(size(), value);\n        }\n\n        default public IntList sort(IntComparator comparator) {\n            Sorter.sort(this, comparator);\n            return this;\n        }\n\n        default public IntList subList(final int from, final int to) {\n            return new IntList() {\n                private final int shift;\n                private final int size;\n\n                {\n                    if (from < 0 || from > to || to > IntList.this.size()) {\n                        throw new IndexOutOfBoundsException(\"from = \" + from + \", to = \" + to + \", size = \" + size());\n                    }\n                    shift = from;\n                    size = to - from;\n                }\n\n                public int size() {\n                    return size;\n                }\n\n                public int get(int at) {\n                    if (at < 0 || at >= size) {\n                        throw new IndexOutOfBoundsException(\"at = \" + at + \", size = \" + size());\n                    }\n                    return IntList.this.get(at + shift);\n                }\n\n                public void addAt(int index, int value) {\n                    throw new UnsupportedOperationException();\n                }\n\n                public void removeAt(int index) {\n                    throw new UnsupportedOperationException();\n                }\n\n                public void set(int at, int value) {\n                    if (at < 0 || at >= size) {\n                        throw new IndexOutOfBoundsException(\"at = \" + at + \", size = \" + size());\n                    }\n                    IntList.this.set(at + shift, value);\n                }\n\n                public IntList compute() {\n                    return new IntArrayList(this);\n                }\n            };\n        }\n\n    }\n\n    static class IntArray extends IntAbstractStream implements IntList {\n        private int[] data;\n\n        public IntArray(int[] arr) {\n            data = arr;\n        }\n\n        public int size() {\n            return data.length;\n        }\n\n        public int get(int at) {\n            return data[at];\n        }\n\n        public void addAt(int index, int value) {\n            throw new UnsupportedOperationException();\n        }\n\n        public void removeAt(int index) {\n            throw new UnsupportedOperationException();\n        }\n\n        public void set(int index, int value) {\n            data[index] = value;\n        }\n\n    }\n\n    static interface IntReversableCollection extends IntCollection {\n    }\n\n    static interface IntIterator {\n        public int value() throws NoSuchElementException;\n\n        public boolean advance();\n\n        public boolean isValid();\n\n    }\n\n    static class IOUtils {\n        public static int[] readIntArray(InputReader in, int size) {\n            int[] array = new int[size];\n            for (int i = 0; i < size; i++) {\n                array[i] = in.readInt();\n            }\n            return array;\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n\n    static interface IntComparator {\n        public static final IntComparator DEFAULT = (first, second) -> {\n            if (first < second) {\n                return -1;\n            }\n            if (first > second) {\n                return 1;\n            }\n            return 0;\n        };\n\n        public int compare(int first, int second);\n\n    }\n\n    static interface IndependentSetSystem {\n        public boolean join(int first, int second);\n\n        public int get(int index);\n\n        public static interface Listener {\n            public void joined(int joinedRoot, int root);\n\n        }\n\n    }\n\n    static interface IntTask {\n        public void process(int value);\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void print(int[] array) {\n            for (int i = 0; i < array.length; i++) {\n                if (i != 0) {\n                    writer.print(' ');\n                }\n                writer.print(array[i]);\n            }\n        }\n\n        public void printLine(int[] array) {\n            print(array);\n            writer.println();\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n    }\n\n    static class ListIndependentSetSystem implements IndependentSetSystem {\n        private final IntList[] lists;\n        private int[] parent;\n        private int setCount;\n        private IndependentSetSystem.Listener listener;\n\n        public ListIndependentSetSystem(int size) {\n            //noinspection unchecked\n            lists = new IntList[size];\n            parent = new int[size];\n            for (int i = 0; i < size; i++) {\n                parent[i] = i;\n            }\n            setCount = size;\n        }\n\n        public boolean join(int first, int second) {\n            first = parent[first];\n            second = parent[second];\n            if (first == second) {\n                return false;\n            }\n            int firstSize = lists[first] == null ? 1 : lists[first].size() + 1;\n            int secondSize = lists[second] == null ? 1 : lists[second].size() + 1;\n            if (firstSize < secondSize) {\n                int temp = first;\n                first = second;\n                second = temp;\n            }\n            if (lists[first] == null) {\n                lists[first] = new IntArrayList();\n            }\n            lists[first].add(second);\n            parent[second] = first;\n            if (lists[second] != null) {\n                lists[first].addAll(lists[second]);\n                final int finalFirst = first;\n                lists[second].forEach((IntTask) i -> parent[i] = finalFirst);\n            }\n            lists[second] = null;\n            if (listener != null) {\n                listener.joined(second, first);\n            }\n            setCount--;\n            return true;\n        }\n\n        public int get(int index) {\n            return parent[index];\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"E\"\n    dependency \"dcomp\" version=\">=0.6.0\"\n+/\n\nimport std.stdio, std.range, std.conv, std.algorithm;\n// import dcomp.scanner;\n// import dcomp.foundation;\n// import dcomp.numeric.primitive;\n// import dcomp.numeric.prime;\n// import dcomp.container.unionfind;\n// import dcomp.container.deque;\n// import dcomp.algorithm;\n\nimmutable INF = 10^^9 + 10^^7;\n\nint main() {\n    auto sc = new Scanner(stdin);\n    int n;\n    int[] a;\n    sc.read(n, a);\n    a.sort!\"a<b\";\n    \n    int[][] facL = a.map!factorList.array;\n    int[] primes = facL.join.array.sort!\"a<b\".uniq.array;\n    facL.each!(each!((ref x) => x = binSearch!(i => primes[i] >= x)(-1, primes.length.to!int)));\n    facL = facL.map!(x => x.uniq.array).array;\n\n\n    int m = primes.length.to!int;\n    int[][] prToIdx = new int[][](m);\n    facL.each!((i, v) => v.each!(pr => prToIdx[pr] ~= i.to!int));\n\n    bool[] used = new bool[n];\n    int[] wall = new int[m]; wall[] = INF;\n    int[] res = new int[n];\n    foreach (p; 0..n) {\n        bool[] ok = iota(n).map!((i){\n            if (used[i]) return false;\n            if (a[i] == 1) return true;\n            int mi = facL[i].map!(pr => wall[pr]).fold!max(1);\n            return a[i] <= mi;\n        }).array;\n\n        bool[] can = new bool[m]; int canc = 0;\n        facL.each!((i, v){\n            if (used[i]) return;\n            foreach (pr; v) {\n                if (can[pr]) continue;\n                can[pr] = true;\n                canc++;\n            }\n        });\n/*        writeln(\"DEBUG\");\n        writeln(res);\n        writeln(wall);\n        writeln(ok);\n        writeln(can, \" \" , canc);\n        writeln(\"END\");*/\n        bool[] visited = new bool[n];\n        foreach (i; 0..n) {\n            if (used[i] || !ok[i]) continue;\n            // add d\n            auto que = Deque!int();\n            que.insertBack(i);\n            while (!que.empty) {\n                int x = que.back; que.removeBack;\n                if (visited[x]) continue;\n                visited[x] = true;\n                foreach (pr; facL[x]) {\n                    if (!can[pr]) continue;\n                    can[pr] = false;\n                    canc--;\n                    foreach (y; prToIdx[pr]) {\n                        if (used[y] || visited[y]) continue;\n                        que.insertBack(y);\n                    }\n                }\n            }\n            if (canc) continue;\n            res[p] = a[i];\n            used[i] = true;\n            wall.each!((ref x) => x = min(x, a[i]));\n            foreach (pr; facL[i]) {\n                wall[pr] = INF;\n            }\n            break;\n        }\n    }\n    writeln(res.map!(to!string).join(\" \"));\n    return 0;\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/numeric/primitive.d */\n// module dcomp.numeric.primitive;\n\nimport std.traits;\n\nT pow(T, U)(T x, U n) if (!isFloatingPoint!T && isIntegral!U) {\n    return pow(x, n, T(1));\n}\n\nT pow(T, U)(T x, U n, T e) if (isIntegral!U) {\n    while (n) {\n        if (n & 1) e *= x;\n        x *= x;\n        n /= 2;\n    }\n    return e;\n}\n\nunittest {\n    assert(pow(3, 5) == 243);\n    assert(pow(3, 5, 2) == 486);\n}\n\nT lcm(T)(in T a, in T b) {\n    import std.numeric : gcd;\n    return a / gcd(a,b) * b;\n}\n\nunittest {\n    assert(lcm(2, 4) == 4);\n    assert(lcm(3, 5) == 15);\n    assert(lcm(1, 1) == 1);\n    assert(lcm(0, 100) == 0);\n}\n\n//a*T[0]+b*T[1]=T[2], T[2]=gcd\n//todo: to binary extgcd\nT[3] extGcd(T)(in T a, in T b) \nif (!isIntegral!T || isSigned!T) //unsignedはNG\n{\n    if (b==0) {\n        return [1, 0, a];\n    } else {\n        auto e = extGcd(b, a%b);\n        return [e[1], e[0]-a/b*e[1], e[2]];\n    }\n}\n\nunittest {\n    import std.numeric : gcd;\n    foreach (i; 0..100) {\n        foreach (j; 0..100) {\n            auto e = extGcd(i, j);\n            assert(e[2] == gcd(i, j));\n            assert(e[0] * i + e[1] * j == e[2]);\n        }\n    }\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/algorithm.d */\n// module dcomp.algorithm;\n\nimport std.range.primitives;\nimport std.traits : isFloatingPoint, isIntegral;\n\n//[0,0,0,...,1,1,1]で、初めて1となる場所を探す。pred(l) == 0, pred(r) == 1と仮定\nT binSearch(alias pred, T)(T l, T r) if (isIntegral!T) {\n    while (r-l > 1) {\n        T md = (l+r)/2;\n        if (!pred(md)) l = md;\n        else r = md;\n    }\n    return r;\n}\n\nT binSearch(alias pred, T)(T l, T r, int cnt = 60) if (isFloatingPoint!T) {\n    foreach (i; 0..cnt) {\n        T md = (l+r)/2;\n        if (!pred(md)) l = md;\n        else r = md;\n    }\n    return r;\n}\n\nRotator!Range rotator(Range)(Range r) {\n    return Rotator!Range(r);\n}\n\nstruct Rotator(Range)\nif (isForwardRange!Range && hasLength!Range) {\n    size_t cnt;\n    Range start, now;\n    this(Range r) {\n        cnt = 0;\n        start = r.save;\n        now = r.save;\n    }\n    this(this) {\n        start = start.save;\n        now = now.save;\n    }\n    @property bool empty() {\n        return now.empty;\n    }\n    @property auto front() {\n        assert(!now.empty);\n        import std.range : take, chain;\n        return chain(now, start.take(cnt));\n    }\n    @property Rotator!Range save() {\n        return this;\n    }\n    void popFront() {\n        cnt++;\n        now.popFront;\n    }\n}\n\n\nE minimum(alias pred = \"a < b\", Range, E = ElementType!Range)(Range range, E seed)\nif (isInputRange!Range && !isInfinite!Range) {\n    import std.algorithm, std.functional;\n    return reduce!((a, b) => binaryFun!pred(a, b) ? a : b)(seed, range);\n}\n\nElementType!Range minimum(alias pred = \"a < b\", Range)(Range range) {\n    assert(!range.empty, \"range must not empty\");\n    auto e = range.front; range.popFront;\n    return minimum!pred(range, e);\n}\n\nE maximum(alias pred = \"a < b\", Range, E = ElementType!Range)(Range range, E seed)\nif (isInputRange!Range && !isInfinite!Range) {\n    import std.algorithm, std.functional;\n    return reduce!((a, b) => binaryFun!pred(a, b) ? b : a)(seed, range);\n}\n\nElementType!Range maximum(alias pred = \"a < b\", Range)(Range range) {\n    assert(!range.empty, \"range must not empty\");\n    auto e = range.front; range.popFront;\n    return maximum!pred(range, e);\n}\n\nunittest {\n    assert(minimum([2, 1, 3]) == 1);\n    assert(minimum!\"a > b\"([2, 1, 3]) == 3);\n    assert(minimum([2, 1, 3], -1) == -1);\n    assert(minimum!\"a > b\"([2, 1, 3], 100) == 100);\n\n    assert(maximum([2, 1, 3]) == 3);\n    assert(maximum!\"a > b\"([2, 1, 3]) == 1);\n    assert(maximum([2, 1, 3], 100) == 100);\n    assert(maximum!\"a > b\"([2, 1, 3], -1) == -1);\n}\n\nbool[ElementType!Range] toMap(Range)(Range r) {\n    import std.algorithm : each;\n    bool[ElementType!Range] res;\n    r.each!(a => res[a] = true);\n    return res;\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/container/deque.d */\n// module dcomp.container.deque;\n\nstruct Deque(T) {\n    import core.exception : RangeError;\n    import core.memory : GC;\n    import std.range : ElementType, isInputRange;\n    import std.traits : isImplicitlyConvertible;\n\n    struct Payload {\n        T *d;\n        size_t st, length, cap;\n        @property bool empty() const { return length == 0; }\n        alias opDollar = length;\n        ref inout(T) opIndex(size_t i) inout {\n            version(assert) if (length <= i) throw new RangeError();\n            return d[(st+i >= cap) ? (st+i-cap) : st+i];\n        }\n        private void expand() {\n            import std.algorithm : max;\n            assert(length == cap);\n            auto nc = max(size_t(4), 2*cap);\n            T* nd = cast(T*)GC.malloc(nc * T.sizeof);\n            foreach (i; 0..length) {\n                nd[i] = this[i];\n            }\n            d = nd; st = 0; cap = nc;\n        }\n        void insertFront(T v) {\n            if (length == cap) expand();\n            if (st == 0) st += cap;\n            st--; length++;\n            this[0] = v; \n        }\n        void insertBack(T v) {\n            if (length == cap) expand();\n            length++;\n            this[length-1] = v; \n        }\n        void removeFront() {\n            assert(!empty, \"Deque.removeFront: Deque is empty\");        \n            st++; length--;\n            if (st == cap) st = 0;\n        }\n        void removeBack() {\n            assert(!empty, \"Deque.removeBack: Deque is empty\");        \n            length--;\n        }        \n    }\n    struct RangeT(A) {\n        alias T = typeof(*(A.p));\n        alias E = typeof(A.p.d[0]);\n        T *p;\n        size_t a, b;\n        @property bool empty() const { return b <= a; }\n        @property size_t length() const { return b-a; }\n        @property RangeT save() { return RangeT(p, a, b); }\n        @property RangeT!(const A) save() const {\n            return typeof(return)(p, a, b);\n        }\n        alias opDollar = length;\n        @property ref inout(E) front() inout { return (*p)[a]; }\n        @property ref inout(E) back() inout { return (*p)[b-1]; }\n        void popFront() {\n            version(assert) if (empty) throw new RangeError();\n            a++;\n        }\n        void popBack() {\n            version(assert) if (empty) throw new RangeError();\n            b--;\n        }\n        ref inout(E) opIndex(size_t i) inout { return (*p)[i]; }\n        RangeT opSlice() { return this.save; }\n        RangeT opSlice(size_t i, size_t j) {\n            version(assert) if (i > j || a + j > b) throw new RangeError();\n            return typeof(return)(p, a+i, a+j);\n        }\n        RangeT!(const A) opSlice() const { return this.save; }\n        RangeT!(const A) opSlice(size_t i, size_t j) const {\n            version(assert) if (i > j || a + j > b) throw new RangeError();\n            return typeof(return)(p, a+i, a+j);\n        }\n    }\n    \n    alias Range = RangeT!Deque;\n    alias ConstRange = RangeT!(const Deque);\n    alias ImmutableRange = RangeT!(immutable Deque);\n\n    Payload *p;\n    private void I() { if (!p) p = new Payload(); }\n    private void C() const {\n        version(assert) if (!p) throw new RangeError();\n    }\n    //some value\n    this(U)(U[] values...) if (isImplicitlyConvertible!(U, T)) {I;\n        p = new Payload();\n        foreach (v; values) {\n            insertBack(v);\n        }\n    }\n    //range\n    this(Range)(Range r)\n    if (isInputRange!Range &&\n    isImplicitlyConvertible!(ElementType!Range, T) &&\n    !is(Range == T[])) {I;\n        p = new Payload();\n        foreach (v; r) {\n            insertBack(v);\n        }\n    }\n    \n    @property bool empty() const { return (!p || p.empty); }\n    @property size_t length() const { return (p ? p.length : 0); }\n    alias opDollar = length;\n    ref inout(T) opIndex(size_t i) inout {C; return (*p)[i]; }\n    ref inout(T) front() inout {C; return (*p)[0]; }\n    ref inout(T) back() inout {C; return (*p)[$-1]; }\n    void insertFront(T v) {I; p.insertFront(v); }\n    void insertBack(T v) {I; p.insertBack(v); }\n    void removeFront() {C; p.removeFront(); }\n    void removeBack() {C; p.removeBack(); }\n    Range opSlice() {I; return Range(p, 0, length); }\n}\n\nunittest {\n    import std.algorithm : equal;\n    import std.range.primitives : isRandomAccessRange;\n    import std.container.util : make;\n    auto q = make!(Deque!int);\n    assert(isRandomAccessRange!(typeof(q[])));\n\n    //insert,remove\n    assert(equal(q[], new int[](0)));\n    q.insertBack(1);\n    assert(equal(q[], [1]));\n    q.insertBack(2);\n    assert(equal(q[], [1, 2]));\n    q.insertFront(3);\n    assert(equal(q[], [3, 1, 2]) && q.front == 3);\n    q.removeFront;\n    assert(equal(q[], [1, 2]) && q.length == 2);\n    q.insertBack(4);\n    assert(equal(q[], [1, 2, 4]) && q.front == 1 && q.back == 4 && q[$-1] == 4);\n    q.insertFront(5);\n    assert(equal(q[], [5, 1, 2, 4]));\n\n    //range\n    assert(equal(q[][1..3], [1, 2]));\n    assert(equal(q[][][][], q[]));\n    //const range\n    const auto rng = q[];\n    assert(rng.front == 5 && rng.back == 4);\n    \n    //reference type\n    auto q2 = q;\n    q2.insertBack(6);\n    q2.insertFront(7);\n    assert(equal(q[], q2[]) && q.length == q2.length);\n\n    //construct with make\n    auto a = make!(Deque!int)(1, 2, 3);\n    auto b = make!(Deque!int)([1, 2, 3]);\n    assert(equal(a[], b[]));\n}\n\nunittest {\n    Deque!int a;\n    Deque!int b;\n    a.insertFront(2);\n    assert(b.length == 0);\n}\n\nunittest {\n    import std.algorithm : equal;\n    import std.range : iota;\n    Deque!int a;\n    foreach (i; 0..100) {\n        a.insertBack(i);\n    }\n    assert(equal(a[], iota(100)));\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/scanner.d */\n// module dcomp.scanner;\n\nclass Scanner {\n    import std.stdio : File;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    File f;\n    this(File f) {\n        this.f = f;\n    }\n    string[] buf;\n    private bool succ() {\n        while (!buf.length) {\n            if (f.eof) return false;\n            buf = f.readln.split;\n        }\n        return true;\n    }\n    private bool readSingle(T)(ref T x) {\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                //string or char[10] etc\n                x = buf.front;\n                buf.popFront;\n            } else {\n                static if (isStaticArray!T) {\n                    //static\n                    assert(buf.length == T.length);\n                }\n                x = buf.map!(to!E).array;\n                buf.length = 0;                \n            }\n        } else {\n            x = buf.front.to!T;\n            buf.popFront;            \n        }\n        return true;\n    }\n    int read(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n}\n\nunittest {\n    import std.path : buildPath;\n    import std.file : tempDir;\n    import std.algorithm : equal;\n    import std.stdio : File;\n    string fileName = buildPath(tempDir, \"kyuridenanmaida.txt\");\n    auto fout = File(fileName, \"w\");\n    fout.writeln(\"1 2 3\");\n    fout.writeln(\"ab cde\");\n    fout.writeln(\"1.0 1.0 2.0\");\n    fout.close;\n    Scanner sc = new Scanner(File(fileName, \"r\"));\n    int a;\n    int[2] b;\n    char[2] c;\n    string d;\n    double e;\n    double[] f;\n    sc.read(a, b, c, d, e, f);\n    assert(a == 1);\n    assert(equal(b[], [2, 3]));\n    assert(equal(c[], \"ab\"));\n    assert(equal(d, \"cde\"));\n    assert(e == 1.0);\n    assert(equal(f, [1.0, 2.0]));\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/container/unionfind.d */\n// module dcomp.container.unionfind;\n\nstruct UnionFind {\n    import std.algorithm : map, swap, each;\n    import std.range : iota, array;\n    int[] id; // group id\n    int[][] groups; // group list\n    int count; // group count\n    this(int n) {\n        id = iota(n).array;\n        groups = iota(n).map!(a => [a]).array;\n        count = n;\n    }\n    void merge(int a, int b) {\n        if (same(a, b)) return;\n        count--;\n        int x = id[a], y = id[b];\n        if (groups[x].length < groups[y].length) swap(x, y);\n        groups[y].each!(a => id[a] = x);\n        groups[x] ~= groups[y];\n        groups[y] = [];\n    }\n    int[] group(int i) {\n        return groups[id[i]];\n    }\n    bool same(int a, int b) {\n        return id[a] == id[b];\n    }\n}\n\nunittest {\n    import std.algorithm : equal, sort;\n    auto uf = UnionFind(5);\n    assert(!uf.same(1, 3));\n    assert(uf.same(0, 0));\n\n    uf.merge(3, 2);\n    uf.merge(1, 1);\n    uf.merge(4, 2);\n    uf.merge(4, 3);\n\n    assert(uf.count == 3);\n    assert(uf.id[2] == uf.id[3]);\n    assert(uf.id[2] == uf.id[4]);\n    assert(equal(uf.group(0), [0]));\n    assert(equal(uf.group(1), [1]));\n    assert(equal(sort(uf.group(2)), [2, 3, 4]));\n}\n\nunittest {\n    import std.datetime, std.stdio, std.range;\n    // speed check\n    writeln(\"UnionFind Speed Test\");\n    StopWatch sw;\n    sw.start;\n    UnionFind uf;\n    // line\n    uf = UnionFind(1_000_000);\n    foreach (i; 1..1_000_000) {\n        uf.merge(i-1, i);\n    }\n    // line(reverse)\n    uf = UnionFind(1_000_000);\n    foreach_reverse (i; 1..1_000_000) {\n        uf.merge(i-1, i);\n    }\n    // binary tree\n    uf = UnionFind(1_000_000);\n    foreach (lg; 1..20) {\n        int len = 1<<lg;\n        foreach (i; iota(0, 1_000_000-len/2, len)) {\n            uf.merge(i, i+len/2);\n        }\n    }\n    sw.stop;\n    writeln(sw.peek.msecs, \"ms\");\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/foundation.d */\n// module dcomp.foundation;\n//fold(for old compiler)\nstatic if (__VERSION__ <= 2070) {\n    template fold(fun...) if (fun.length >= 1) {\n        auto fold(R, S...)(R r, S seed) {\n            import std.algorithm : reduce;\n            static if (S.length < 2) {\n                return reduce!fun(seed, r);\n            } else {\n                import std.typecons : tuple;\n                return reduce!fun(tuple(seed), r);\n            }\n        }\n    }\n    unittest {\n        import std.stdio;\n        auto l = [1, 2, 3, 4, 5];\n        assert(l.fold!\"a+b\"(10) == 25);\n    }\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/numeric/prime.d */\n// module dcomp.numeric.prime;\n\nT[] divisorList(T)(T x) {\n    import std.algorithm : sort;\n    T[] res;\n    for (T i = 1; i*i <= x; i++) {\n        if (x%i == 0) {\n            res ~= i;\n            if (i*i != x) res ~= x/i;\n        }\n    }\n    sort(res);\n    return res;\n}\n\nunittest {\n    import std.range, std.algorithm;\n    assert(equal(divisorList(1), [1]));\n    assert(equal(divisorList(2), [1, 2]));\n    assert(equal(divisorList(4), [1, 2, 4]));\n    assert(equal(divisorList(24), [1, 2, 3, 4, 6, 8, 12, 24]));\n}\n\nT[] factorList(T)(T x) {\n    T[] res;\n    for (T i = 2; i*i <= x; i++) {\n        while (x % i == 0) {\n            res ~= i;\n            x /= i;\n        }\n    }\n    if (x > 1) res ~= x;\n    // res is sorted!\n    return res;\n}\n\nunittest {\n    import std.range, std.algorithm;\n    assert(equal(factorList(1), new int[0]));\n    assert(equal(factorList(2), [2]));\n    assert(equal(factorList(4), [2, 2]));\n    assert(equal(factorList(24), [2, 2, 2, 3]));\n}\n"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"E\"\n    dependency \"dcomp\" version=\">=0.6.0\"\n+/\n\nimport std.stdio, std.range, std.conv, std.algorithm;\n// import dcomp.scanner;\n// import dcomp.foundation;\n// import dcomp.numeric.primitive;\n// import dcomp.numeric.prime;\n// import dcomp.container.unionfind;\n// import dcomp.container.deque;\n// import dcomp.algorithm;\n\nimmutable INF = 10^^9 + 10^^7;\n\nint main() {\n    auto sc = new Scanner(stdin);\n    int n;\n    int[] a;\n    sc.read(n, a);\n    a.sort!\"a<b\";\n    \n    int[][] facL = a.map!factorList.array;\n    int[] primes = facL.join.array.sort!\"a<b\".uniq.array;\n    facL.each!(each!((ref x) => x = binSearch!(i => primes[i] >= x)(-1, primes.length.to!int)));\n    facL = facL.map!(x => x.uniq.array).array;\n\n\n    int m = primes.length.to!int;\n    int[][] prToIdx = new int[][](m);\n    facL.each!((i, v) => v.each!(pr => prToIdx[pr] ~= i.to!int));\n\n    bool[] used = new bool[n];\n    int[] wall = new int[m]; wall[] = INF;\n    int[] res = new int[n];\n    foreach (p; 0..n) {\n        bool[] ok = iota(n).map!((i){\n            if (used[i]) return false;\n            if (a[i] == 1) return true;\n            int mi = facL[i].map!(pr => wall[pr]).fold!max(1);\n            return a[i] <= mi;\n        }).array;\n\n        bool[] can = new bool[m]; int canc = 0;\n        facL.each!((i, v){\n            if (used[i]) return;\n            foreach (pr; v) {\n                if (can[pr]) continue;\n                can[pr] = true;\n                canc++;\n            }\n        });\n\n        bool[] visited = new bool[n];\n        foreach (i; 0..n) {\n            if (used[i] || !ok[i]) continue;\n            // add d\n            auto que = Deque!int();\n            que.insertBack(i);\n            while (!que.empty) {\n                int x = que.back; que.removeBack;\n                if (visited[x]) continue;\n                visited[x] = true;\n                foreach (pr; facL[x]) {\n                    if (!can[pr]) continue;\n                    can[pr] = false;\n                    canc--;\n                    foreach (y; prToIdx[pr]) {\n                        if (visited[y]) continue;\n                        que.insertBack(y);\n                    }\n                }\n            }\n            if (canc) continue;\n            res[p] = a[i];\n            used[i] = true;\n            wall.each!((ref x) => x = min(x, a[i]));\n            foreach (pr; facL[i]) {\n                wall[pr] = INF;\n            }\n            break;\n        }\n    }\n    writeln(res.map!(to!string).join(\" \"));\n    return 0;\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/numeric/primitive.d */\n// module dcomp.numeric.primitive;\n\nimport std.traits;\n\nT pow(T, U)(T x, U n) if (!isFloatingPoint!T && isIntegral!U) {\n    return pow(x, n, T(1));\n}\n\nT pow(T, U)(T x, U n, T e) if (isIntegral!U) {\n    while (n) {\n        if (n & 1) e *= x;\n        x *= x;\n        n /= 2;\n    }\n    return e;\n}\n\nunittest {\n    assert(pow(3, 5) == 243);\n    assert(pow(3, 5, 2) == 486);\n}\n\nT lcm(T)(in T a, in T b) {\n    import std.numeric : gcd;\n    return a / gcd(a,b) * b;\n}\n\nunittest {\n    assert(lcm(2, 4) == 4);\n    assert(lcm(3, 5) == 15);\n    assert(lcm(1, 1) == 1);\n    assert(lcm(0, 100) == 0);\n}\n\n//a*T[0]+b*T[1]=T[2], T[2]=gcd\n//todo: to binary extgcd\nT[3] extGcd(T)(in T a, in T b) \nif (!isIntegral!T || isSigned!T) //unsignedはNG\n{\n    if (b==0) {\n        return [1, 0, a];\n    } else {\n        auto e = extGcd(b, a%b);\n        return [e[1], e[0]-a/b*e[1], e[2]];\n    }\n}\n\nunittest {\n    import std.numeric : gcd;\n    foreach (i; 0..100) {\n        foreach (j; 0..100) {\n            auto e = extGcd(i, j);\n            assert(e[2] == gcd(i, j));\n            assert(e[0] * i + e[1] * j == e[2]);\n        }\n    }\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/algorithm.d */\n// module dcomp.algorithm;\n\nimport std.range.primitives;\nimport std.traits : isFloatingPoint, isIntegral;\n\n//[0,0,0,...,1,1,1]で、初めて1となる場所を探す。pred(l) == 0, pred(r) == 1と仮定\nT binSearch(alias pred, T)(T l, T r) if (isIntegral!T) {\n    while (r-l > 1) {\n        T md = (l+r)/2;\n        if (!pred(md)) l = md;\n        else r = md;\n    }\n    return r;\n}\n\nT binSearch(alias pred, T)(T l, T r, int cnt = 60) if (isFloatingPoint!T) {\n    foreach (i; 0..cnt) {\n        T md = (l+r)/2;\n        if (!pred(md)) l = md;\n        else r = md;\n    }\n    return r;\n}\n\nRotator!Range rotator(Range)(Range r) {\n    return Rotator!Range(r);\n}\n\nstruct Rotator(Range)\nif (isForwardRange!Range && hasLength!Range) {\n    size_t cnt;\n    Range start, now;\n    this(Range r) {\n        cnt = 0;\n        start = r.save;\n        now = r.save;\n    }\n    this(this) {\n        start = start.save;\n        now = now.save;\n    }\n    @property bool empty() {\n        return now.empty;\n    }\n    @property auto front() {\n        assert(!now.empty);\n        import std.range : take, chain;\n        return chain(now, start.take(cnt));\n    }\n    @property Rotator!Range save() {\n        return this;\n    }\n    void popFront() {\n        cnt++;\n        now.popFront;\n    }\n}\n\n\nE minimum(alias pred = \"a < b\", Range, E = ElementType!Range)(Range range, E seed)\nif (isInputRange!Range && !isInfinite!Range) {\n    import std.algorithm, std.functional;\n    return reduce!((a, b) => binaryFun!pred(a, b) ? a : b)(seed, range);\n}\n\nElementType!Range minimum(alias pred = \"a < b\", Range)(Range range) {\n    assert(!range.empty, \"range must not empty\");\n    auto e = range.front; range.popFront;\n    return minimum!pred(range, e);\n}\n\nE maximum(alias pred = \"a < b\", Range, E = ElementType!Range)(Range range, E seed)\nif (isInputRange!Range && !isInfinite!Range) {\n    import std.algorithm, std.functional;\n    return reduce!((a, b) => binaryFun!pred(a, b) ? b : a)(seed, range);\n}\n\nElementType!Range maximum(alias pred = \"a < b\", Range)(Range range) {\n    assert(!range.empty, \"range must not empty\");\n    auto e = range.front; range.popFront;\n    return maximum!pred(range, e);\n}\n\nunittest {\n    assert(minimum([2, 1, 3]) == 1);\n    assert(minimum!\"a > b\"([2, 1, 3]) == 3);\n    assert(minimum([2, 1, 3], -1) == -1);\n    assert(minimum!\"a > b\"([2, 1, 3], 100) == 100);\n\n    assert(maximum([2, 1, 3]) == 3);\n    assert(maximum!\"a > b\"([2, 1, 3]) == 1);\n    assert(maximum([2, 1, 3], 100) == 100);\n    assert(maximum!\"a > b\"([2, 1, 3], -1) == -1);\n}\n\nbool[ElementType!Range] toMap(Range)(Range r) {\n    import std.algorithm : each;\n    bool[ElementType!Range] res;\n    r.each!(a => res[a] = true);\n    return res;\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/container/deque.d */\n// module dcomp.container.deque;\n\nstruct Deque(T) {\n    import core.exception : RangeError;\n    import core.memory : GC;\n    import std.range : ElementType, isInputRange;\n    import std.traits : isImplicitlyConvertible;\n\n    struct Payload {\n        T *d;\n        size_t st, length, cap;\n        @property bool empty() const { return length == 0; }\n        alias opDollar = length;\n        ref inout(T) opIndex(size_t i) inout {\n            version(assert) if (length <= i) throw new RangeError();\n            return d[(st+i >= cap) ? (st+i-cap) : st+i];\n        }\n        private void expand() {\n            import std.algorithm : max;\n            assert(length == cap);\n            auto nc = max(size_t(4), 2*cap);\n            T* nd = cast(T*)GC.malloc(nc * T.sizeof);\n            foreach (i; 0..length) {\n                nd[i] = this[i];\n            }\n            d = nd; st = 0; cap = nc;\n        }\n        void insertFront(T v) {\n            if (length == cap) expand();\n            if (st == 0) st += cap;\n            st--; length++;\n            this[0] = v; \n        }\n        void insertBack(T v) {\n            if (length == cap) expand();\n            length++;\n            this[length-1] = v; \n        }\n        void removeFront() {\n            assert(!empty, \"Deque.removeFront: Deque is empty\");        \n            st++; length--;\n            if (st == cap) st = 0;\n        }\n        void removeBack() {\n            assert(!empty, \"Deque.removeBack: Deque is empty\");        \n            length--;\n        }        \n    }\n    struct RangeT(A) {\n        alias T = typeof(*(A.p));\n        alias E = typeof(A.p.d[0]);\n        T *p;\n        size_t a, b;\n        @property bool empty() const { return b <= a; }\n        @property size_t length() const { return b-a; }\n        @property RangeT save() { return RangeT(p, a, b); }\n        @property RangeT!(const A) save() const {\n            return typeof(return)(p, a, b);\n        }\n        alias opDollar = length;\n        @property ref inout(E) front() inout { return (*p)[a]; }\n        @property ref inout(E) back() inout { return (*p)[b-1]; }\n        void popFront() {\n            version(assert) if (empty) throw new RangeError();\n            a++;\n        }\n        void popBack() {\n            version(assert) if (empty) throw new RangeError();\n            b--;\n        }\n        ref inout(E) opIndex(size_t i) inout { return (*p)[i]; }\n        RangeT opSlice() { return this.save; }\n        RangeT opSlice(size_t i, size_t j) {\n            version(assert) if (i > j || a + j > b) throw new RangeError();\n            return typeof(return)(p, a+i, a+j);\n        }\n        RangeT!(const A) opSlice() const { return this.save; }\n        RangeT!(const A) opSlice(size_t i, size_t j) const {\n            version(assert) if (i > j || a + j > b) throw new RangeError();\n            return typeof(return)(p, a+i, a+j);\n        }\n    }\n    \n    alias Range = RangeT!Deque;\n    alias ConstRange = RangeT!(const Deque);\n    alias ImmutableRange = RangeT!(immutable Deque);\n\n    Payload *p;\n    private void I() { if (!p) p = new Payload(); }\n    private void C() const {\n        version(assert) if (!p) throw new RangeError();\n    }\n    //some value\n    this(U)(U[] values...) if (isImplicitlyConvertible!(U, T)) {I;\n        p = new Payload();\n        foreach (v; values) {\n            insertBack(v);\n        }\n    }\n    //range\n    this(Range)(Range r)\n    if (isInputRange!Range &&\n    isImplicitlyConvertible!(ElementType!Range, T) &&\n    !is(Range == T[])) {I;\n        p = new Payload();\n        foreach (v; r) {\n            insertBack(v);\n        }\n    }\n    \n    @property bool empty() const { return (!p || p.empty); }\n    @property size_t length() const { return (p ? p.length : 0); }\n    alias opDollar = length;\n    ref inout(T) opIndex(size_t i) inout {C; return (*p)[i]; }\n    ref inout(T) front() inout {C; return (*p)[0]; }\n    ref inout(T) back() inout {C; return (*p)[$-1]; }\n    void insertFront(T v) {I; p.insertFront(v); }\n    void insertBack(T v) {I; p.insertBack(v); }\n    void removeFront() {C; p.removeFront(); }\n    void removeBack() {C; p.removeBack(); }\n    Range opSlice() {I; return Range(p, 0, length); }\n}\n\nunittest {\n    import std.algorithm : equal;\n    import std.range.primitives : isRandomAccessRange;\n    import std.container.util : make;\n    auto q = make!(Deque!int);\n    assert(isRandomAccessRange!(typeof(q[])));\n\n    //insert,remove\n    assert(equal(q[], new int[](0)));\n    q.insertBack(1);\n    assert(equal(q[], [1]));\n    q.insertBack(2);\n    assert(equal(q[], [1, 2]));\n    q.insertFront(3);\n    assert(equal(q[], [3, 1, 2]) && q.front == 3);\n    q.removeFront;\n    assert(equal(q[], [1, 2]) && q.length == 2);\n    q.insertBack(4);\n    assert(equal(q[], [1, 2, 4]) && q.front == 1 && q.back == 4 && q[$-1] == 4);\n    q.insertFront(5);\n    assert(equal(q[], [5, 1, 2, 4]));\n\n    //range\n    assert(equal(q[][1..3], [1, 2]));\n    assert(equal(q[][][][], q[]));\n    //const range\n    const auto rng = q[];\n    assert(rng.front == 5 && rng.back == 4);\n    \n    //reference type\n    auto q2 = q;\n    q2.insertBack(6);\n    q2.insertFront(7);\n    assert(equal(q[], q2[]) && q.length == q2.length);\n\n    //construct with make\n    auto a = make!(Deque!int)(1, 2, 3);\n    auto b = make!(Deque!int)([1, 2, 3]);\n    assert(equal(a[], b[]));\n}\n\nunittest {\n    Deque!int a;\n    Deque!int b;\n    a.insertFront(2);\n    assert(b.length == 0);\n}\n\nunittest {\n    import std.algorithm : equal;\n    import std.range : iota;\n    Deque!int a;\n    foreach (i; 0..100) {\n        a.insertBack(i);\n    }\n    assert(equal(a[], iota(100)));\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/scanner.d */\n// module dcomp.scanner;\n\nclass Scanner {\n    import std.stdio : File;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    File f;\n    this(File f) {\n        this.f = f;\n    }\n    string[] buf;\n    private bool succ() {\n        while (!buf.length) {\n            if (f.eof) return false;\n            buf = f.readln.split;\n        }\n        return true;\n    }\n    private bool readSingle(T)(ref T x) {\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                //string or char[10] etc\n                x = buf.front;\n                buf.popFront;\n            } else {\n                static if (isStaticArray!T) {\n                    //static\n                    assert(buf.length == T.length);\n                }\n                x = buf.map!(to!E).array;\n                buf.length = 0;                \n            }\n        } else {\n            x = buf.front.to!T;\n            buf.popFront;            \n        }\n        return true;\n    }\n    int read(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n}\n\nunittest {\n    import std.path : buildPath;\n    import std.file : tempDir;\n    import std.algorithm : equal;\n    import std.stdio : File;\n    string fileName = buildPath(tempDir, \"kyuridenanmaida.txt\");\n    auto fout = File(fileName, \"w\");\n    fout.writeln(\"1 2 3\");\n    fout.writeln(\"ab cde\");\n    fout.writeln(\"1.0 1.0 2.0\");\n    fout.close;\n    Scanner sc = new Scanner(File(fileName, \"r\"));\n    int a;\n    int[2] b;\n    char[2] c;\n    string d;\n    double e;\n    double[] f;\n    sc.read(a, b, c, d, e, f);\n    assert(a == 1);\n    assert(equal(b[], [2, 3]));\n    assert(equal(c[], \"ab\"));\n    assert(equal(d, \"cde\"));\n    assert(e == 1.0);\n    assert(equal(f, [1.0, 2.0]));\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/container/unionfind.d */\n// module dcomp.container.unionfind;\n\nstruct UnionFind {\n    import std.algorithm : map, swap, each;\n    import std.range : iota, array;\n    int[] id; // group id\n    int[][] groups; // group list\n    int count; // group count\n    this(int n) {\n        id = iota(n).array;\n        groups = iota(n).map!(a => [a]).array;\n        count = n;\n    }\n    void merge(int a, int b) {\n        if (same(a, b)) return;\n        count--;\n        int x = id[a], y = id[b];\n        if (groups[x].length < groups[y].length) swap(x, y);\n        groups[y].each!(a => id[a] = x);\n        groups[x] ~= groups[y];\n        groups[y] = [];\n    }\n    int[] group(int i) {\n        return groups[id[i]];\n    }\n    bool same(int a, int b) {\n        return id[a] == id[b];\n    }\n}\n\nunittest {\n    import std.algorithm : equal, sort;\n    auto uf = UnionFind(5);\n    assert(!uf.same(1, 3));\n    assert(uf.same(0, 0));\n\n    uf.merge(3, 2);\n    uf.merge(1, 1);\n    uf.merge(4, 2);\n    uf.merge(4, 3);\n\n    assert(uf.count == 3);\n    assert(uf.id[2] == uf.id[3]);\n    assert(uf.id[2] == uf.id[4]);\n    assert(equal(uf.group(0), [0]));\n    assert(equal(uf.group(1), [1]));\n    assert(equal(sort(uf.group(2)), [2, 3, 4]));\n}\n\nunittest {\n    import std.datetime, std.stdio, std.range;\n    // speed check\n    writeln(\"UnionFind Speed Test\");\n    StopWatch sw;\n    sw.start;\n    UnionFind uf;\n    // line\n    uf = UnionFind(1_000_000);\n    foreach (i; 1..1_000_000) {\n        uf.merge(i-1, i);\n    }\n    // line(reverse)\n    uf = UnionFind(1_000_000);\n    foreach_reverse (i; 1..1_000_000) {\n        uf.merge(i-1, i);\n    }\n    // binary tree\n    uf = UnionFind(1_000_000);\n    foreach (lg; 1..20) {\n        int len = 1<<lg;\n        foreach (i; iota(0, 1_000_000-len/2, len)) {\n            uf.merge(i, i+len/2);\n        }\n    }\n    sw.stop;\n    writeln(sw.peek.msecs, \"ms\");\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/foundation.d */\n// module dcomp.foundation;\n//fold(for old compiler)\nstatic if (__VERSION__ <= 2070) {\n    template fold(fun...) if (fun.length >= 1) {\n        auto fold(R, S...)(R r, S seed) {\n            import std.algorithm : reduce;\n            static if (S.length < 2) {\n                return reduce!fun(seed, r);\n            } else {\n                import std.typecons : tuple;\n                return reduce!fun(tuple(seed), r);\n            }\n        }\n    }\n    unittest {\n        import std.stdio;\n        auto l = [1, 2, 3, 4, 5];\n        assert(l.fold!\"a+b\"(10) == 25);\n    }\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/numeric/prime.d */\n// module dcomp.numeric.prime;\n\nT[] divisorList(T)(T x) {\n    import std.algorithm : sort;\n    T[] res;\n    for (T i = 1; i*i <= x; i++) {\n        if (x%i == 0) {\n            res ~= i;\n            if (i*i != x) res ~= x/i;\n        }\n    }\n    sort(res);\n    return res;\n}\n\nunittest {\n    import std.range, std.algorithm;\n    assert(equal(divisorList(1), [1]));\n    assert(equal(divisorList(2), [1, 2]));\n    assert(equal(divisorList(4), [1, 2, 4]));\n    assert(equal(divisorList(24), [1, 2, 3, 4, 6, 8, 12, 24]));\n}\n\nT[] factorList(T)(T x) {\n    T[] res;\n    for (T i = 2; i*i <= x; i++) {\n        while (x % i == 0) {\n            res ~= i;\n            x /= i;\n        }\n    }\n    if (x > 1) res ~= x;\n    // res is sorted!\n    return res;\n}\n\nunittest {\n    import std.range, std.algorithm;\n    assert(equal(factorList(1), new int[0]));\n    assert(equal(factorList(2), [2]));\n    assert(equal(factorList(4), [2, 2]));\n    assert(equal(factorList(24), [2, 2, 2, 3]));\n}\n"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"E\"\n    dependency \"dcomp\" version=\">=0.6.0\"\n+/\n\nimport std.stdio, std.range, std.conv, std.algorithm;\n// import dcomp.scanner;\n// import dcomp.numeric.primitive;\n// import dcomp.numeric.prime;\n// import dcomp.container.unionfind;\n// import dcomp.container.deque;\n// import dcomp.algorithm;\n\nimmutable INF = 10^^9 + 10^^7;\n\nint main() {\n    auto sc = new Scanner(stdin);\n    int n;\n    int[] a;\n    sc.read(n, a);\n    a.sort!\"a<b\";\n    \n    int[][] facL = a.map!factorList.array;\n    int[] primes = facL.join.array.sort!\"a<b\".uniq.array;\n    facL.each!(each!((ref x) => x = binSearch!(i => primes[i] >= x)(-1, primes.length.to!int)));\n    facL = facL.map!(x => x.uniq.array).array;\n\n//    writeln(facL);\n\n    int m = primes.length.to!int;\n    int[][] prToIdx = new int[][](m);\n    iota(n).each!((i){\n        foreach (d; facL[i]) {\n            prToIdx[d] ~= i;\n        }\n    });\n\n\n\n    bool[] used = new bool[n];\n    int[] wall = new int[m]; wall[] = INF;\n    int[] res = new int[n];\n    foreach (p; 0..n) {\n        bool[] ok = iota(n).map!((i){\n            if (used[i]) return false;\n            if (a[i] == 1) return true;\n            bool ans = false;\n            foreach (d; facL[i]) {\n                if (a[i] <= wall[d]) {\n                    ans = true;\n                    break;\n                }\n            }\n            return ans;\n        }).array;\n\n        bool[] can = new bool[m]; int canc = 0;\n        facL.each!((i, v){\n            if (used[i]) return;\n            foreach (d; v) {\n                if (can[d]) continue;\n                can[d] = true;\n                canc++;\n            }\n        });\n\n//        writeln(ok);\n//        writeln(can, \" \", canc);\n        \n        bool[] visited = new bool[n];\n        foreach (i; 0..n) {\n            if (used[i] || !ok[i]) continue;\n            // add d\n            auto que = Deque!int();\n            que.insertBack(i);\n            while (!que.empty) {\n                int x = que.back; que.removeBack;\n                if (visited[x]) continue;\n                foreach (d; facL[x]) {\n                    if (!can[d]) continue;\n                    can[d] = false;\n                    canc--;\n                    foreach (y; prToIdx[d]) {\n                        if (visited[y]) continue;\n                        que.insertBack(y);\n                    }\n                }\n            }\n            if (canc) continue;\n            res[p] = a[i];\n            used[i] = true;\n            wall.each!((ref x) => x = min(x, a[i]));\n            foreach (d; facL[i]) {\n                wall[d] = INF;\n            }\n            break;\n        }\n    }\n    writeln(res.map!(to!string).join(\" \"));\n    return 0;\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/numeric/primitive.d */\n// module dcomp.numeric.primitive;\n\nimport std.traits;\n\nT pow(T, U)(T x, U n) if (!isFloatingPoint!T && isIntegral!U) {\n    return pow(x, n, T(1));\n}\n\nT pow(T, U)(T x, U n, T e) if (isIntegral!U) {\n    while (n) {\n        if (n & 1) e *= x;\n        x *= x;\n        n /= 2;\n    }\n    return e;\n}\n\nunittest {\n    assert(pow(3, 5) == 243);\n    assert(pow(3, 5, 2) == 486);\n}\n\nT lcm(T)(in T a, in T b) {\n    import std.numeric : gcd;\n    return a / gcd(a,b) * b;\n}\n\nunittest {\n    assert(lcm(2, 4) == 4);\n    assert(lcm(3, 5) == 15);\n    assert(lcm(1, 1) == 1);\n    assert(lcm(0, 100) == 0);\n}\n\n//a*T[0]+b*T[1]=T[2], T[2]=gcd\n//todo: to binary extgcd\nT[3] extGcd(T)(in T a, in T b) \nif (!isIntegral!T || isSigned!T) //unsignedはNG\n{\n    if (b==0) {\n        return [1, 0, a];\n    } else {\n        auto e = extGcd(b, a%b);\n        return [e[1], e[0]-a/b*e[1], e[2]];\n    }\n}\n\nunittest {\n    import std.numeric : gcd;\n    foreach (i; 0..100) {\n        foreach (j; 0..100) {\n            auto e = extGcd(i, j);\n            assert(e[2] == gcd(i, j));\n            assert(e[0] * i + e[1] * j == e[2]);\n        }\n    }\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/algorithm.d */\n// module dcomp.algorithm;\n\nimport std.range.primitives;\nimport std.traits : isFloatingPoint, isIntegral;\n\n//[0,0,0,...,1,1,1]で、初めて1となる場所を探す。pred(l) == 0, pred(r) == 1と仮定\nT binSearch(alias pred, T)(T l, T r) if (isIntegral!T) {\n    while (r-l > 1) {\n        T md = (l+r)/2;\n        if (!pred(md)) l = md;\n        else r = md;\n    }\n    return r;\n}\n\nT binSearch(alias pred, T)(T l, T r, int cnt = 60) if (isFloatingPoint!T) {\n    foreach (i; 0..cnt) {\n        T md = (l+r)/2;\n        if (!pred(md)) l = md;\n        else r = md;\n    }\n    return r;\n}\n\nRotator!Range rotator(Range)(Range r) {\n    return Rotator!Range(r);\n}\n\nstruct Rotator(Range)\nif (isForwardRange!Range && hasLength!Range) {\n    size_t cnt;\n    Range start, now;\n    this(Range r) {\n        cnt = 0;\n        start = r.save;\n        now = r.save;\n    }\n    this(this) {\n        start = start.save;\n        now = now.save;\n    }\n    @property bool empty() {\n        return now.empty;\n    }\n    @property auto front() {\n        assert(!now.empty);\n        import std.range : take, chain;\n        return chain(now, start.take(cnt));\n    }\n    @property Rotator!Range save() {\n        return this;\n    }\n    void popFront() {\n        cnt++;\n        now.popFront;\n    }\n}\n\n\nE minimum(alias pred = \"a < b\", Range, E = ElementType!Range)(Range range, E seed)\nif (isInputRange!Range && !isInfinite!Range) {\n    import std.algorithm, std.functional;\n    return reduce!((a, b) => binaryFun!pred(a, b) ? a : b)(seed, range);\n}\n\nElementType!Range minimum(alias pred = \"a < b\", Range)(Range range) {\n    assert(!range.empty, \"range must not empty\");\n    auto e = range.front; range.popFront;\n    return minimum!pred(range, e);\n}\n\nE maximum(alias pred = \"a < b\", Range, E = ElementType!Range)(Range range, E seed)\nif (isInputRange!Range && !isInfinite!Range) {\n    import std.algorithm, std.functional;\n    return reduce!((a, b) => binaryFun!pred(a, b) ? b : a)(seed, range);\n}\n\nElementType!Range maximum(alias pred = \"a < b\", Range)(Range range) {\n    assert(!range.empty, \"range must not empty\");\n    auto e = range.front; range.popFront;\n    return maximum!pred(range, e);\n}\n\nunittest {\n    assert(minimum([2, 1, 3]) == 1);\n    assert(minimum!\"a > b\"([2, 1, 3]) == 3);\n    assert(minimum([2, 1, 3], -1) == -1);\n    assert(minimum!\"a > b\"([2, 1, 3], 100) == 100);\n\n    assert(maximum([2, 1, 3]) == 3);\n    assert(maximum!\"a > b\"([2, 1, 3]) == 1);\n    assert(maximum([2, 1, 3], 100) == 100);\n    assert(maximum!\"a > b\"([2, 1, 3], -1) == -1);\n}\n\nbool[ElementType!Range] toMap(Range)(Range r) {\n    import std.algorithm : each;\n    bool[ElementType!Range] res;\n    r.each!(a => res[a] = true);\n    return res;\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/container/deque.d */\n// module dcomp.container.deque;\n\nstruct Deque(T) {\n    import core.exception : RangeError;\n    import core.memory : GC;\n    import std.range : ElementType, isInputRange;\n    import std.traits : isImplicitlyConvertible;\n\n    struct Payload {\n        T *d;\n        size_t st, length, cap;\n        @property bool empty() const { return length == 0; }\n        alias opDollar = length;\n        ref inout(T) opIndex(size_t i) inout {\n            version(assert) if (length <= i) throw new RangeError();\n            return d[(st+i >= cap) ? (st+i-cap) : st+i];\n        }\n        private void expand() {\n            import std.algorithm : max;\n            assert(length == cap);\n            auto nc = max(size_t(4), 2*cap);\n            T* nd = cast(T*)GC.malloc(nc * T.sizeof);\n            foreach (i; 0..length) {\n                nd[i] = this[i];\n            }\n            d = nd; st = 0; cap = nc;\n        }\n        void insertFront(T v) {\n            if (length == cap) expand();\n            if (st == 0) st += cap;\n            st--; length++;\n            this[0] = v; \n        }\n        void insertBack(T v) {\n            if (length == cap) expand();\n            length++;\n            this[length-1] = v; \n        }\n        void removeFront() {\n            assert(!empty, \"Deque.removeFront: Deque is empty\");        \n            st++; length--;\n            if (st == cap) st = 0;\n        }\n        void removeBack() {\n            assert(!empty, \"Deque.removeBack: Deque is empty\");        \n            length--;\n        }        \n    }\n    struct RangeT(A) {\n        alias T = typeof(*(A.p));\n        alias E = typeof(A.p.d[0]);\n        T *p;\n        size_t a, b;\n        @property bool empty() const { return b <= a; }\n        @property size_t length() const { return b-a; }\n        @property RangeT save() { return RangeT(p, a, b); }\n        @property RangeT!(const A) save() const {\n            return typeof(return)(p, a, b);\n        }\n        alias opDollar = length;\n        @property ref inout(E) front() inout { return (*p)[a]; }\n        @property ref inout(E) back() inout { return (*p)[b-1]; }\n        void popFront() {\n            version(assert) if (empty) throw new RangeError();\n            a++;\n        }\n        void popBack() {\n            version(assert) if (empty) throw new RangeError();\n            b--;\n        }\n        ref inout(E) opIndex(size_t i) inout { return (*p)[i]; }\n        RangeT opSlice() { return this.save; }\n        RangeT opSlice(size_t i, size_t j) {\n            version(assert) if (i > j || a + j > b) throw new RangeError();\n            return typeof(return)(p, a+i, a+j);\n        }\n        RangeT!(const A) opSlice() const { return this.save; }\n        RangeT!(const A) opSlice(size_t i, size_t j) const {\n            version(assert) if (i > j || a + j > b) throw new RangeError();\n            return typeof(return)(p, a+i, a+j);\n        }\n    }\n    \n    alias Range = RangeT!Deque;\n    alias ConstRange = RangeT!(const Deque);\n    alias ImmutableRange = RangeT!(immutable Deque);\n\n    Payload *p;\n    private void I() { if (!p) p = new Payload(); }\n    private void C() const {\n        version(assert) if (!p) throw new RangeError();\n    }\n    //some value\n    this(U)(U[] values...) if (isImplicitlyConvertible!(U, T)) {I;\n        p = new Payload();\n        foreach (v; values) {\n            insertBack(v);\n        }\n    }\n    //range\n    this(Range)(Range r)\n    if (isInputRange!Range &&\n    isImplicitlyConvertible!(ElementType!Range, T) &&\n    !is(Range == T[])) {I;\n        p = new Payload();\n        foreach (v; r) {\n            insertBack(v);\n        }\n    }\n    \n    @property bool empty() const { return (!p || p.empty); }\n    @property size_t length() const { return (p ? p.length : 0); }\n    alias opDollar = length;\n    ref inout(T) opIndex(size_t i) inout {C; return (*p)[i]; }\n    ref inout(T) front() inout {C; return (*p)[0]; }\n    ref inout(T) back() inout {C; return (*p)[$-1]; }\n    void insertFront(T v) {I; p.insertFront(v); }\n    void insertBack(T v) {I; p.insertBack(v); }\n    void removeFront() {C; p.removeFront(); }\n    void removeBack() {C; p.removeBack(); }\n    Range opSlice() {I; return Range(p, 0, length); }\n}\n\nunittest {\n    import std.algorithm : equal;\n    import std.range.primitives : isRandomAccessRange;\n    import std.container.util : make;\n    auto q = make!(Deque!int);\n    assert(isRandomAccessRange!(typeof(q[])));\n\n    //insert,remove\n    assert(equal(q[], new int[](0)));\n    q.insertBack(1);\n    assert(equal(q[], [1]));\n    q.insertBack(2);\n    assert(equal(q[], [1, 2]));\n    q.insertFront(3);\n    assert(equal(q[], [3, 1, 2]) && q.front == 3);\n    q.removeFront;\n    assert(equal(q[], [1, 2]) && q.length == 2);\n    q.insertBack(4);\n    assert(equal(q[], [1, 2, 4]) && q.front == 1 && q.back == 4 && q[$-1] == 4);\n    q.insertFront(5);\n    assert(equal(q[], [5, 1, 2, 4]));\n\n    //range\n    assert(equal(q[][1..3], [1, 2]));\n    assert(equal(q[][][][], q[]));\n    //const range\n    const auto rng = q[];\n    assert(rng.front == 5 && rng.back == 4);\n    \n    //reference type\n    auto q2 = q;\n    q2.insertBack(6);\n    q2.insertFront(7);\n    assert(equal(q[], q2[]) && q.length == q2.length);\n\n    //construct with make\n    auto a = make!(Deque!int)(1, 2, 3);\n    auto b = make!(Deque!int)([1, 2, 3]);\n    assert(equal(a[], b[]));\n}\n\nunittest {\n    Deque!int a;\n    Deque!int b;\n    a.insertFront(2);\n    assert(b.length == 0);\n}\n\nunittest {\n    import std.algorithm : equal;\n    import std.range : iota;\n    Deque!int a;\n    foreach (i; 0..100) {\n        a.insertBack(i);\n    }\n    assert(equal(a[], iota(100)));\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/scanner.d */\n// module dcomp.scanner;\n\nclass Scanner {\n    import std.stdio : File;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    File f;\n    this(File f) {\n        this.f = f;\n    }\n    string[] buf;\n    private bool succ() {\n        while (!buf.length) {\n            if (f.eof) return false;\n            buf = f.readln.split;\n        }\n        return true;\n    }\n    private bool readSingle(T)(ref T x) {\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                //string or char[10] etc\n                x = buf.front;\n                buf.popFront;\n            } else {\n                static if (isStaticArray!T) {\n                    //static\n                    assert(buf.length == T.length);\n                }\n                x = buf.map!(to!E).array;\n                buf.length = 0;                \n            }\n        } else {\n            x = buf.front.to!T;\n            buf.popFront;            \n        }\n        return true;\n    }\n    int read(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n}\n\nunittest {\n    import std.path : buildPath;\n    import std.file : tempDir;\n    import std.algorithm : equal;\n    import std.stdio : File;\n    string fileName = buildPath(tempDir, \"kyuridenanmaida.txt\");\n    auto fout = File(fileName, \"w\");\n    fout.writeln(\"1 2 3\");\n    fout.writeln(\"ab cde\");\n    fout.writeln(\"1.0 1.0 2.0\");\n    fout.close;\n    Scanner sc = new Scanner(File(fileName, \"r\"));\n    int a;\n    int[2] b;\n    char[2] c;\n    string d;\n    double e;\n    double[] f;\n    sc.read(a, b, c, d, e, f);\n    assert(a == 1);\n    assert(equal(b[], [2, 3]));\n    assert(equal(c[], \"ab\"));\n    assert(equal(d, \"cde\"));\n    assert(e == 1.0);\n    assert(equal(f, [1.0, 2.0]));\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/container/unionfind.d */\n// module dcomp.container.unionfind;\n\nstruct UnionFind {\n    import std.algorithm : map, swap, each;\n    import std.range : iota, array;\n    int[] id; // group id\n    int[][] groups; // group list\n    int count; // group count\n    this(int n) {\n        id = iota(n).array;\n        groups = iota(n).map!(a => [a]).array;\n        count = n;\n    }\n    void merge(int a, int b) {\n        if (same(a, b)) return;\n        count--;\n        int x = id[a], y = id[b];\n        if (groups[x].length < groups[y].length) swap(x, y);\n        groups[y].each!(a => id[a] = x);\n        groups[x] ~= groups[y];\n        groups[y] = [];\n    }\n    int[] group(int i) {\n        return groups[id[i]];\n    }\n    bool same(int a, int b) {\n        return id[a] == id[b];\n    }\n}\n\nunittest {\n    import std.algorithm : equal, sort;\n    auto uf = UnionFind(5);\n    assert(!uf.same(1, 3));\n    assert(uf.same(0, 0));\n\n    uf.merge(3, 2);\n    uf.merge(1, 1);\n    uf.merge(4, 2);\n    uf.merge(4, 3);\n\n    assert(uf.count == 3);\n    assert(uf.id[2] == uf.id[3]);\n    assert(uf.id[2] == uf.id[4]);\n    assert(equal(uf.group(0), [0]));\n    assert(equal(uf.group(1), [1]));\n    assert(equal(sort(uf.group(2)), [2, 3, 4]));\n}\n\nunittest {\n    import std.datetime, std.stdio, std.range;\n    // speed check\n    writeln(\"UnionFind Speed Test\");\n    StopWatch sw;\n    sw.start;\n    UnionFind uf;\n    // line\n    uf = UnionFind(1_000_000);\n    foreach (i; 1..1_000_000) {\n        uf.merge(i-1, i);\n    }\n    // line(reverse)\n    uf = UnionFind(1_000_000);\n    foreach_reverse (i; 1..1_000_000) {\n        uf.merge(i-1, i);\n    }\n    // binary tree\n    uf = UnionFind(1_000_000);\n    foreach (lg; 1..20) {\n        int len = 1<<lg;\n        foreach (i; iota(0, 1_000_000-len/2, len)) {\n            uf.merge(i, i+len/2);\n        }\n    }\n    sw.stop;\n    writeln(sw.peek.msecs, \"ms\");\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/numeric/prime.d */\n// module dcomp.numeric.prime;\n\nT[] divisorList(T)(T x) {\n    import std.algorithm : sort;\n    T[] res;\n    for (T i = 1; i*i <= x; i++) {\n        if (x%i == 0) {\n            res ~= i;\n            if (i*i != x) res ~= x/i;\n        }\n    }\n    sort(res);\n    return res;\n}\n\nunittest {\n    import std.range, std.algorithm;\n    assert(equal(divisorList(1), [1]));\n    assert(equal(divisorList(2), [1, 2]));\n    assert(equal(divisorList(4), [1, 2, 4]));\n    assert(equal(divisorList(24), [1, 2, 3, 4, 6, 8, 12, 24]));\n}\n\nT[] factorList(T)(T x) {\n    T[] res;\n    for (T i = 2; i*i <= x; i++) {\n        while (x % i == 0) {\n            res ~= i;\n            x /= i;\n        }\n    }\n    if (x > 1) res ~= x;\n    // res is sorted!\n    return res;\n}\n\nunittest {\n    import std.range, std.algorithm;\n    assert(equal(factorList(1), new int[0]));\n    assert(equal(factorList(2), [2]));\n    assert(equal(factorList(4), [2, 2]));\n    assert(equal(factorList(24), [2, 2, 2, 3]));\n}\n"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"E\"\n    dependency \"dcomp\" version=\">=0.6.0\"\n+/\n\nimport std.stdio, std.range, std.conv, std.algorithm;\n// import dcomp.scanner;\n// import dcomp.numeric.primitive;\n// import dcomp.numeric.prime;\n// import dcomp.container.unionfind;\n// import dcomp.container.deque;\n// import dcomp.algorithm;\n\nimmutable INF = 10^^9 + 10^^7;\n\nint main() {\n    auto sc = new Scanner(stdin);\n    int n;\n    int[] a;\n    sc.read(n, a);\n    a.sort!\"a<b\";\n    \n    int[][] facL = a.map!factorList.array;\n    int[] primes = facL.join.array.sort!\"a<b\".uniq.array;\n    facL.each!(each!((ref x) => x = binSearch!(i => primes[i] >= x)(-1, primes.length.to!int)));\n    facL = facL.map!(x => x.uniq.array).array;\n\n\n    int m = primes.length.to!int;\n    int[][] prToIdx = new int[][](m);\n    facL.each!((i, v) => v.each!(pr => prToIdx[pr] ~= i.to!int));\n\n    bool[] used = new bool[n];\n    int[] wall = new int[m]; wall[] = INF;\n    int[] res = new int[n];\n    foreach (p; 0..n) {\n        bool[] ok = iota(n).map!((i){\n            if (used[i]) return false;\n            if (a[i] == 1) return true;\n            int mi = facL[i].map!(pr => wall[pr]).fold!max(1);\n            return a[i] <= mi;\n        }).array;\n\n        bool[] can = new bool[m]; int canc = 0;\n        facL.each!((i, v){\n            if (used[i]) return;\n            foreach (pr; v) {\n                if (can[pr]) continue;\n                can[pr] = true;\n                canc++;\n            }\n        });\n\n        bool[] visited = new bool[n];\n        foreach (i; 0..n) {\n            if (used[i] || !ok[i]) continue;\n            // add d\n            auto que = Deque!int();\n            que.insertBack(i);\n            while (!que.empty) {\n                int x = que.back; que.removeBack;\n                if (visited[x]) continue;\n                visited[x] = true;\n                foreach (pr; facL[x]) {\n                    if (!can[pr]) continue;\n                    can[pr] = false;\n                    canc--;\n                    foreach (y; prToIdx[pr]) {\n                        if (visited[y]) continue;\n                        que.insertBack(y);\n                    }\n                }\n            }\n            if (canc) continue;\n            res[p] = a[i];\n            used[i] = true;\n            wall.each!((ref x) => x = min(x, a[i]));\n            foreach (pr; facL[i]) {\n                wall[pr] = INF;\n            }\n            break;\n        }\n    }\n    writeln(res.map!(to!string).join(\" \"));\n    return 0;\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/numeric/primitive.d */\n// module dcomp.numeric.primitive;\n\nimport std.traits;\n\nT pow(T, U)(T x, U n) if (!isFloatingPoint!T && isIntegral!U) {\n    return pow(x, n, T(1));\n}\n\nT pow(T, U)(T x, U n, T e) if (isIntegral!U) {\n    while (n) {\n        if (n & 1) e *= x;\n        x *= x;\n        n /= 2;\n    }\n    return e;\n}\n\nunittest {\n    assert(pow(3, 5) == 243);\n    assert(pow(3, 5, 2) == 486);\n}\n\nT lcm(T)(in T a, in T b) {\n    import std.numeric : gcd;\n    return a / gcd(a,b) * b;\n}\n\nunittest {\n    assert(lcm(2, 4) == 4);\n    assert(lcm(3, 5) == 15);\n    assert(lcm(1, 1) == 1);\n    assert(lcm(0, 100) == 0);\n}\n\n//a*T[0]+b*T[1]=T[2], T[2]=gcd\n//todo: to binary extgcd\nT[3] extGcd(T)(in T a, in T b) \nif (!isIntegral!T || isSigned!T) //unsignedはNG\n{\n    if (b==0) {\n        return [1, 0, a];\n    } else {\n        auto e = extGcd(b, a%b);\n        return [e[1], e[0]-a/b*e[1], e[2]];\n    }\n}\n\nunittest {\n    import std.numeric : gcd;\n    foreach (i; 0..100) {\n        foreach (j; 0..100) {\n            auto e = extGcd(i, j);\n            assert(e[2] == gcd(i, j));\n            assert(e[0] * i + e[1] * j == e[2]);\n        }\n    }\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/algorithm.d */\n// module dcomp.algorithm;\n\nimport std.range.primitives;\nimport std.traits : isFloatingPoint, isIntegral;\n\n//[0,0,0,...,1,1,1]で、初めて1となる場所を探す。pred(l) == 0, pred(r) == 1と仮定\nT binSearch(alias pred, T)(T l, T r) if (isIntegral!T) {\n    while (r-l > 1) {\n        T md = (l+r)/2;\n        if (!pred(md)) l = md;\n        else r = md;\n    }\n    return r;\n}\n\nT binSearch(alias pred, T)(T l, T r, int cnt = 60) if (isFloatingPoint!T) {\n    foreach (i; 0..cnt) {\n        T md = (l+r)/2;\n        if (!pred(md)) l = md;\n        else r = md;\n    }\n    return r;\n}\n\nRotator!Range rotator(Range)(Range r) {\n    return Rotator!Range(r);\n}\n\nstruct Rotator(Range)\nif (isForwardRange!Range && hasLength!Range) {\n    size_t cnt;\n    Range start, now;\n    this(Range r) {\n        cnt = 0;\n        start = r.save;\n        now = r.save;\n    }\n    this(this) {\n        start = start.save;\n        now = now.save;\n    }\n    @property bool empty() {\n        return now.empty;\n    }\n    @property auto front() {\n        assert(!now.empty);\n        import std.range : take, chain;\n        return chain(now, start.take(cnt));\n    }\n    @property Rotator!Range save() {\n        return this;\n    }\n    void popFront() {\n        cnt++;\n        now.popFront;\n    }\n}\n\n\nE minimum(alias pred = \"a < b\", Range, E = ElementType!Range)(Range range, E seed)\nif (isInputRange!Range && !isInfinite!Range) {\n    import std.algorithm, std.functional;\n    return reduce!((a, b) => binaryFun!pred(a, b) ? a : b)(seed, range);\n}\n\nElementType!Range minimum(alias pred = \"a < b\", Range)(Range range) {\n    assert(!range.empty, \"range must not empty\");\n    auto e = range.front; range.popFront;\n    return minimum!pred(range, e);\n}\n\nE maximum(alias pred = \"a < b\", Range, E = ElementType!Range)(Range range, E seed)\nif (isInputRange!Range && !isInfinite!Range) {\n    import std.algorithm, std.functional;\n    return reduce!((a, b) => binaryFun!pred(a, b) ? b : a)(seed, range);\n}\n\nElementType!Range maximum(alias pred = \"a < b\", Range)(Range range) {\n    assert(!range.empty, \"range must not empty\");\n    auto e = range.front; range.popFront;\n    return maximum!pred(range, e);\n}\n\nunittest {\n    assert(minimum([2, 1, 3]) == 1);\n    assert(minimum!\"a > b\"([2, 1, 3]) == 3);\n    assert(minimum([2, 1, 3], -1) == -1);\n    assert(minimum!\"a > b\"([2, 1, 3], 100) == 100);\n\n    assert(maximum([2, 1, 3]) == 3);\n    assert(maximum!\"a > b\"([2, 1, 3]) == 1);\n    assert(maximum([2, 1, 3], 100) == 100);\n    assert(maximum!\"a > b\"([2, 1, 3], -1) == -1);\n}\n\nbool[ElementType!Range] toMap(Range)(Range r) {\n    import std.algorithm : each;\n    bool[ElementType!Range] res;\n    r.each!(a => res[a] = true);\n    return res;\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/container/deque.d */\n// module dcomp.container.deque;\n\nstruct Deque(T) {\n    import core.exception : RangeError;\n    import core.memory : GC;\n    import std.range : ElementType, isInputRange;\n    import std.traits : isImplicitlyConvertible;\n\n    struct Payload {\n        T *d;\n        size_t st, length, cap;\n        @property bool empty() const { return length == 0; }\n        alias opDollar = length;\n        ref inout(T) opIndex(size_t i) inout {\n            version(assert) if (length <= i) throw new RangeError();\n            return d[(st+i >= cap) ? (st+i-cap) : st+i];\n        }\n        private void expand() {\n            import std.algorithm : max;\n            assert(length == cap);\n            auto nc = max(size_t(4), 2*cap);\n            T* nd = cast(T*)GC.malloc(nc * T.sizeof);\n            foreach (i; 0..length) {\n                nd[i] = this[i];\n            }\n            d = nd; st = 0; cap = nc;\n        }\n        void insertFront(T v) {\n            if (length == cap) expand();\n            if (st == 0) st += cap;\n            st--; length++;\n            this[0] = v; \n        }\n        void insertBack(T v) {\n            if (length == cap) expand();\n            length++;\n            this[length-1] = v; \n        }\n        void removeFront() {\n            assert(!empty, \"Deque.removeFront: Deque is empty\");        \n            st++; length--;\n            if (st == cap) st = 0;\n        }\n        void removeBack() {\n            assert(!empty, \"Deque.removeBack: Deque is empty\");        \n            length--;\n        }        \n    }\n    struct RangeT(A) {\n        alias T = typeof(*(A.p));\n        alias E = typeof(A.p.d[0]);\n        T *p;\n        size_t a, b;\n        @property bool empty() const { return b <= a; }\n        @property size_t length() const { return b-a; }\n        @property RangeT save() { return RangeT(p, a, b); }\n        @property RangeT!(const A) save() const {\n            return typeof(return)(p, a, b);\n        }\n        alias opDollar = length;\n        @property ref inout(E) front() inout { return (*p)[a]; }\n        @property ref inout(E) back() inout { return (*p)[b-1]; }\n        void popFront() {\n            version(assert) if (empty) throw new RangeError();\n            a++;\n        }\n        void popBack() {\n            version(assert) if (empty) throw new RangeError();\n            b--;\n        }\n        ref inout(E) opIndex(size_t i) inout { return (*p)[i]; }\n        RangeT opSlice() { return this.save; }\n        RangeT opSlice(size_t i, size_t j) {\n            version(assert) if (i > j || a + j > b) throw new RangeError();\n            return typeof(return)(p, a+i, a+j);\n        }\n        RangeT!(const A) opSlice() const { return this.save; }\n        RangeT!(const A) opSlice(size_t i, size_t j) const {\n            version(assert) if (i > j || a + j > b) throw new RangeError();\n            return typeof(return)(p, a+i, a+j);\n        }\n    }\n    \n    alias Range = RangeT!Deque;\n    alias ConstRange = RangeT!(const Deque);\n    alias ImmutableRange = RangeT!(immutable Deque);\n\n    Payload *p;\n    private void I() { if (!p) p = new Payload(); }\n    private void C() const {\n        version(assert) if (!p) throw new RangeError();\n    }\n    //some value\n    this(U)(U[] values...) if (isImplicitlyConvertible!(U, T)) {I;\n        p = new Payload();\n        foreach (v; values) {\n            insertBack(v);\n        }\n    }\n    //range\n    this(Range)(Range r)\n    if (isInputRange!Range &&\n    isImplicitlyConvertible!(ElementType!Range, T) &&\n    !is(Range == T[])) {I;\n        p = new Payload();\n        foreach (v; r) {\n            insertBack(v);\n        }\n    }\n    \n    @property bool empty() const { return (!p || p.empty); }\n    @property size_t length() const { return (p ? p.length : 0); }\n    alias opDollar = length;\n    ref inout(T) opIndex(size_t i) inout {C; return (*p)[i]; }\n    ref inout(T) front() inout {C; return (*p)[0]; }\n    ref inout(T) back() inout {C; return (*p)[$-1]; }\n    void insertFront(T v) {I; p.insertFront(v); }\n    void insertBack(T v) {I; p.insertBack(v); }\n    void removeFront() {C; p.removeFront(); }\n    void removeBack() {C; p.removeBack(); }\n    Range opSlice() {I; return Range(p, 0, length); }\n}\n\nunittest {\n    import std.algorithm : equal;\n    import std.range.primitives : isRandomAccessRange;\n    import std.container.util : make;\n    auto q = make!(Deque!int);\n    assert(isRandomAccessRange!(typeof(q[])));\n\n    //insert,remove\n    assert(equal(q[], new int[](0)));\n    q.insertBack(1);\n    assert(equal(q[], [1]));\n    q.insertBack(2);\n    assert(equal(q[], [1, 2]));\n    q.insertFront(3);\n    assert(equal(q[], [3, 1, 2]) && q.front == 3);\n    q.removeFront;\n    assert(equal(q[], [1, 2]) && q.length == 2);\n    q.insertBack(4);\n    assert(equal(q[], [1, 2, 4]) && q.front == 1 && q.back == 4 && q[$-1] == 4);\n    q.insertFront(5);\n    assert(equal(q[], [5, 1, 2, 4]));\n\n    //range\n    assert(equal(q[][1..3], [1, 2]));\n    assert(equal(q[][][][], q[]));\n    //const range\n    const auto rng = q[];\n    assert(rng.front == 5 && rng.back == 4);\n    \n    //reference type\n    auto q2 = q;\n    q2.insertBack(6);\n    q2.insertFront(7);\n    assert(equal(q[], q2[]) && q.length == q2.length);\n\n    //construct with make\n    auto a = make!(Deque!int)(1, 2, 3);\n    auto b = make!(Deque!int)([1, 2, 3]);\n    assert(equal(a[], b[]));\n}\n\nunittest {\n    Deque!int a;\n    Deque!int b;\n    a.insertFront(2);\n    assert(b.length == 0);\n}\n\nunittest {\n    import std.algorithm : equal;\n    import std.range : iota;\n    Deque!int a;\n    foreach (i; 0..100) {\n        a.insertBack(i);\n    }\n    assert(equal(a[], iota(100)));\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/scanner.d */\n// module dcomp.scanner;\n\nclass Scanner {\n    import std.stdio : File;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    File f;\n    this(File f) {\n        this.f = f;\n    }\n    string[] buf;\n    private bool succ() {\n        while (!buf.length) {\n            if (f.eof) return false;\n            buf = f.readln.split;\n        }\n        return true;\n    }\n    private bool readSingle(T)(ref T x) {\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                //string or char[10] etc\n                x = buf.front;\n                buf.popFront;\n            } else {\n                static if (isStaticArray!T) {\n                    //static\n                    assert(buf.length == T.length);\n                }\n                x = buf.map!(to!E).array;\n                buf.length = 0;                \n            }\n        } else {\n            x = buf.front.to!T;\n            buf.popFront;            \n        }\n        return true;\n    }\n    int read(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n}\n\nunittest {\n    import std.path : buildPath;\n    import std.file : tempDir;\n    import std.algorithm : equal;\n    import std.stdio : File;\n    string fileName = buildPath(tempDir, \"kyuridenanmaida.txt\");\n    auto fout = File(fileName, \"w\");\n    fout.writeln(\"1 2 3\");\n    fout.writeln(\"ab cde\");\n    fout.writeln(\"1.0 1.0 2.0\");\n    fout.close;\n    Scanner sc = new Scanner(File(fileName, \"r\"));\n    int a;\n    int[2] b;\n    char[2] c;\n    string d;\n    double e;\n    double[] f;\n    sc.read(a, b, c, d, e, f);\n    assert(a == 1);\n    assert(equal(b[], [2, 3]));\n    assert(equal(c[], \"ab\"));\n    assert(equal(d, \"cde\"));\n    assert(e == 1.0);\n    assert(equal(f, [1.0, 2.0]));\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/container/unionfind.d */\n// module dcomp.container.unionfind;\n\nstruct UnionFind {\n    import std.algorithm : map, swap, each;\n    import std.range : iota, array;\n    int[] id; // group id\n    int[][] groups; // group list\n    int count; // group count\n    this(int n) {\n        id = iota(n).array;\n        groups = iota(n).map!(a => [a]).array;\n        count = n;\n    }\n    void merge(int a, int b) {\n        if (same(a, b)) return;\n        count--;\n        int x = id[a], y = id[b];\n        if (groups[x].length < groups[y].length) swap(x, y);\n        groups[y].each!(a => id[a] = x);\n        groups[x] ~= groups[y];\n        groups[y] = [];\n    }\n    int[] group(int i) {\n        return groups[id[i]];\n    }\n    bool same(int a, int b) {\n        return id[a] == id[b];\n    }\n}\n\nunittest {\n    import std.algorithm : equal, sort;\n    auto uf = UnionFind(5);\n    assert(!uf.same(1, 3));\n    assert(uf.same(0, 0));\n\n    uf.merge(3, 2);\n    uf.merge(1, 1);\n    uf.merge(4, 2);\n    uf.merge(4, 3);\n\n    assert(uf.count == 3);\n    assert(uf.id[2] == uf.id[3]);\n    assert(uf.id[2] == uf.id[4]);\n    assert(equal(uf.group(0), [0]));\n    assert(equal(uf.group(1), [1]));\n    assert(equal(sort(uf.group(2)), [2, 3, 4]));\n}\n\nunittest {\n    import std.datetime, std.stdio, std.range;\n    // speed check\n    writeln(\"UnionFind Speed Test\");\n    StopWatch sw;\n    sw.start;\n    UnionFind uf;\n    // line\n    uf = UnionFind(1_000_000);\n    foreach (i; 1..1_000_000) {\n        uf.merge(i-1, i);\n    }\n    // line(reverse)\n    uf = UnionFind(1_000_000);\n    foreach_reverse (i; 1..1_000_000) {\n        uf.merge(i-1, i);\n    }\n    // binary tree\n    uf = UnionFind(1_000_000);\n    foreach (lg; 1..20) {\n        int len = 1<<lg;\n        foreach (i; iota(0, 1_000_000-len/2, len)) {\n            uf.merge(i, i+len/2);\n        }\n    }\n    sw.stop;\n    writeln(sw.peek.msecs, \"ms\");\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/numeric/prime.d */\n// module dcomp.numeric.prime;\n\nT[] divisorList(T)(T x) {\n    import std.algorithm : sort;\n    T[] res;\n    for (T i = 1; i*i <= x; i++) {\n        if (x%i == 0) {\n            res ~= i;\n            if (i*i != x) res ~= x/i;\n        }\n    }\n    sort(res);\n    return res;\n}\n\nunittest {\n    import std.range, std.algorithm;\n    assert(equal(divisorList(1), [1]));\n    assert(equal(divisorList(2), [1, 2]));\n    assert(equal(divisorList(4), [1, 2, 4]));\n    assert(equal(divisorList(24), [1, 2, 3, 4, 6, 8, 12, 24]));\n}\n\nT[] factorList(T)(T x) {\n    T[] res;\n    for (T i = 2; i*i <= x; i++) {\n        while (x % i == 0) {\n            res ~= i;\n            x /= i;\n        }\n    }\n    if (x > 1) res ~= x;\n    // res is sorted!\n    return res;\n}\n\nunittest {\n    import std.range, std.algorithm;\n    assert(equal(factorList(1), new int[0]));\n    assert(equal(factorList(2), [2]));\n    assert(equal(factorList(4), [2, 2]));\n    assert(equal(factorList(24), [2, 2, 2, 3]));\n}\n"
  },
  {
    "language": "Bash",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nnamespace Flandre_Scarlet\n{\n\t#define N 2333\n\t#define F(i,l,r) for(int i=l;i<=r;++i)\n\t#define D(i,r,l) for(int i=r;i>=l;--i)\n\t#define Fs(i,l,r,c) for(int i=l;i<=r;c)\n\t#define Ds(i,r,l,c) for(int i=r;i>=l;c)\n\t#define MEM(x,a) memset(x,a,sizeof(x))\n\t#define FK(x) MEM(x,0)\n\t#define Tra(i,u) for(int i=G.Start(u),v=G.To(i);~i;i=G.Next(i),v=G.To(i))\n\t#define p_b push_back\n\t#define sz(a) ((int)a.size())\n\t#define iter(a,p) (a.begin()+p)\n\tint I()\n\t{\n\t    int x=0;char c=getchar();int f=1;\n\t    while(c<'0' or c>'9') f=(c=='-')?-1:1,c=getchar();\n\t    while(c>='0' and c<='9') x=(x<<1)+(x<<3)+(c^48),c=getchar();\n\t    return (x=(f==1)?x:-x);\n\t}\n\tvoid Rd(int cnt,...)\n\t{\n\t    va_list args; va_start(args,cnt);\n\t    F(i,1,cnt) {int* x=va_arg(args,int*);(*x)=I();}\n\t    va_end(args);\n\t}\n\n\tint n,a[N];\n\tvoid Input()\n\t{\n\t\tn=I(); F(i,1,n) a[i]=I();\n\t}\n\n\tvector<int> g[N],g2[N];\n\tbool vis[N];int ideg[N];\n\tvoid DFS(int u)\n\t{\n\t\tvis[u]=1;\n\t\tF(i,0,sz(g[u])-1)\n\t\t{int v=g[u][i];\n\t\t\tif (vis[v]) continue;\n\t\t\t++ideg[v]; g2[u].p_b(v);\n\t\t\tDFS(v);\n\t\t}\n\t}\n\tpriority_queue<int> Q;\n\tvoid TopoSort()\n\t{\n\t\tF(i,1,n) if (!ideg[i]) Q.push(i);\n\t\twhile(!Q.empty())\n\t\t{\n\t\t\tint u=Q.top(); Q.pop();\n\t\t\tprintf(\"%d \",a[u]);\n\t\t\tF(i,0,sz(g2[u])-1) Q.push(g2[u][i]);\n\t\t}\n\t}\n\tvoid Soviet()\n\t{\n\t\tsort(a+1,a+n+1);\n\t\tF(i,1,n) F(j,i+1,n) if (__gcd(a[i],a[j])!=1) g[i].p_b(j),g[j].p_b(i);\n\t\tF(i,1,n) if (!vis[i]) DFS(i);\n\t\tTopoSort();\n\t}\n\n\t#define Flan void\n\tFlan IsMyWife()\n\t{\n\t\tInput();\n\t\tSoviet();\n\t}\n}\nint main()\n{\n\tFlandre_Scarlet::IsMyWife();\n\tgetchar();getchar();\n\treturn 0;\n}"
  },
  {
    "language": "Bash",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define N 4010\ninline int read() {\n    int x=0;\n    char ch=getchar();\n    while (!isdigit(ch)) ch=getchar();\n    while (isdigit(ch)) x=x*10+ch-'0',ch=getchar();\n    return x;\n}\ninline int gcd(int x,int y) {\n    return y?gcd(y,x%y):x;\n}\nint f[N][N];\nint a[N],vis[N],ind[N];\nvector<int> v[N];\ninline void dfs(int x,int n) {\n    vis[x]=true;\n    for (int i=1;i<=n;i++) {\n        if (!f[x][i] || vis[i]) continue;\n        ind[i]++,v[x].push_back(i),dfs(i,n);\n    }\n}\ninline void Top(int n) {\n    priority_queue<int> q;\n    for (int i=1;i<=n;i++) \n        if (!ind[i]) q.push(i);\n    while (!q.empty()) {\n        int x=q.top(); q.pop();\n        printf(\"%d \",a[x]);\n        for (int i=0;i<v[x].size();i++) q.push(v[x][i]);\n    }\n}\nint main() {\n    int n=read();\n    for (int i=1;i<=n;i++) a[i]=read();\n    sort(a+1,a+n+1);\n    for (int i=1;i<=n;i++) {\n        for (int j=1;j<=n;j++) {\n            if (gcd(a[i],a[j])!=1) f[i][j]=true;\n        }\n    }\n    for (int i=1;i<=n;i++) \n        if (!vis[i]) dfs(i,n);\n    Top(n);\n    return 0;\n}"
  },
  {
    "language": "Bash",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define N 2010\ninline int read() {\n    int x=0;\n    char ch=getchar();\n    while (!isdigit(ch)) ch=getchar();\n    while (isdigit(ch)) x=x*10+ch-'0',ch=getchar();\n    return x;\n}\ninline int gcd(int x,int y) {\n    return y?gcd(y,x%y):x;\n}\nint f[N][N];\nint a[N],vis[N],ind[N];\nvector<int> v[N];\ninline void dfs(int x,int n) {\n    vis[x]=true;\n    for (int i=1;i<=n;i++) {\n        if (!f[x][i] || vis[i]) continue;\n        ind[i]++,v[x].push_back(i),dfs(i,n);\n    }\n}\ninline void Top(int n) {\n    priority_queue<int> q;\n    for (int i=1;i<=n;i++) \n        if (!ind[i]) q.push(i);\n    while (!q.empty()) {\n        int x=q.top(); q.pop();\n        printf(\"%d \",a[x]);\n        for (int i=0;i<v[x].size();i++) q.push(v[x][i]);\n    }\n}\nint main() {\n    int n=read();\n    for (int i=1;i<=n;i++) a[i]=read();\n    sort(a+1,a+n+1);\n    for (int i=1;i<=n;i++) {\n        for (int j=1;j<=n;j++) {\n            if (gcd(a[i],a[j])!=1) f[i][j]=true;\n        }\n    }\n    for (int i=1;i<=n;i++) \n        if (!vis[i]) dfs(i,n);\n    Top(n);\n    return 0;\n}"
  },
  {
    "language": "Bash",
    "code": "#include<bits/stdc++.h>\n#define maxn 2005\nusing namespace std;\ntypedef long long LL;\nint read()\n{\n\tchar c=getchar();int f=1,sum=0;\n\twhile(c<'0' || c>'9'){if(c=='-') f=-1;c=getchar();}\n\twhile(c>='0' && c<='9'){sum=sum*10+c-'0';c=getchar();}\n\treturn sum*f;\n}\nint gcd(int a,int b){return b==0?a:gcd(b,a%b);}\nint n,a[maxn];\nint head[maxn],to[maxn<<1],nex[maxn<<1],cnt;\nbool li[maxn][maxn],vis[maxn];\nint deg[maxn];\nvoid add(int u,int v)\n{\n\tdeg[v]++;to[++cnt]=v;nex[cnt]=head[u];head[u]=cnt;\n}\nvoid dfs(int x)\n{\n\tvis[x]=1;\n\tfor(int i=1;i<=n;i++)\n\tif(li[x][i] && !vis[i])\n\t{\n\t\tadd(x,i);\n\t\tdfs(i);\n\t}\n}\nstruct node{\n\tint val,id;\n    friend bool operator <(node a,node b){\n        return a.val<b.val;\n    }\n};\npriority_queue<node> q;\nint main()\n{\n\tn=read();\n\tfor(int i=1;i<=n;i++) a[i]=read();\n\tsort(a+1,a+1+n);\n\tfor(int i=1;i<n;i++)\n\tfor(int j=i+1;j<=n;j++)\n\tif(gcd(a[i],a[j])>1) li[i][j]=li[j][i]=1;\n\tfor(int i=1;i<=n;i++)\n\tif(!vis[i])\n\tdfs(i);\n\tfor(int i=1;i<=n;i++)\n\tif(!deg[i])\n\tq.push((node){a[i],i});\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tnode now=q.top();\n\t\tq.pop();\n\t\tprintf(\"%d \",a[now.id]);\n\t\tfor(int j=head[now.id];j;j=nex[j])\n\t\t{\n\t\t\tdeg[to[j]]--;\n\t\t\tif(!deg[to[j]])\n\t\t\tq.push((node){a[to[j]],to[j]});\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "Bash",
    "code": "#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<cstring>\n#include<cmath>\n#include<ctime>\n#include<cstdio>\n#include<cstdlib>\n#include<string>\n#include<string.h>\n#include<math.h>\n#include<cassert>\n#include<iomanip>\n#include<utility>\n#include<bitset>\n#include<set>\n#include<map>\n#include<list>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<vector>\n#include<functional>\n#include<algorithm>\n//#include<memory.h>\n#include<assert.h>\n#include<numeric>\n#include<limits.h>\nusing namespace std;\nconst int mod=1e9+7;\nconst int p=29;\nlong long pw[2005];\nint n;\nlong long k;\nstring a,b;\nlong long hsh1[2005],hsh2[2005];\nstruct mat{long long a[2][2];}mt1;\nint pw1(int i,int k)\n{\n\tif(k==0)return 1;\n\tif(k==1)return i;\n\tlong long res=pw1(i,k/2);\n\tres=res*res%mod;\n\tif(k&1)res=res*i%mod;\n\treturn (int)res;\n}\nmat pw2(mat m,int k)\n{\n\tif(k==0)return mt1;\n\tif(k==1)return m;\n\tmat res=pw2(m,k/2);\n\tmat mt3;\n\tfor(int i=0;i<2;i++)for(int j=0;j<2;j++)mt3.a[i][j]=0;\n\tfor(int i=0;i<2;i++)for(int j=0;j<2;j++)for(int k=0;k<2;k++)mt3.a[i][j]=(mt3.a[i][j]+(long long)(res.a[i][k]*res.a[k][j])%mod)%mod;\n\tres=mt3;\n\tif(k&1)\n\t{\n\t\tfor(int i=0;i<2;i++)for(int j=0;j<2;j++)mt3.a[i][j]=0;\n\t\tfor(int i=0;i<2;i++)for(int j=0;j<2;j++)for(int k=0;k<2;k++)mt3.a[i][j]=(mt3.a[i][j]+(long long)(res.a[i][k]*m.a[k][j])%mod)%mod;\n\t\tres=mt3;\n\t}\n\treturn res;\n}\nint main()\n{\n\tcin>>a>>b>>k;\n\tn=a.size();\n\tpw[0]=1;\n\tfor(int i=1;i<2005;i++)pw[i]=pw[i-1]*p;\n\tint x=0,y=0;\n\thsh1[n-1]=a[n-1];\n\thsh2[n-1]=b[n-1];\n\tfor(int i=n-2;i>=0;i--)hsh1[i]=hsh1[i+1]*p+a[i];\n\tfor(int i=n-2;i>=0;i--)hsh2[i]=hsh2[i+1]*p+b[i];\n\tmt1.a[0][0]=1;\n\tmt1.a[0][1]=0;\n\tmt1.a[1][0]=0;\n\tmt1.a[1][1]=1;\n\tfor(int i=0;i<n;i++)if(hsh1[i]+(hsh1[0]-hsh1[i]*pw[i])*pw[n-i]==hsh2[0])x++;else y++;\n\tif(x==0)\n\t{\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\tif(x==n)\n\t{\n\t\tprintf(\"%d\\n\",pw1(x-1,k));\n\t\treturn 0;\n\t}\n\tmat mt2;\n\tmt2.a[0][0]=x-1;\n\tmt2.a[0][1]=x;\n\tmt2.a[1][0]=y;\n\tmt2.a[1][1]=y-1;\n\tmt2=pw2(mt2,k);\n\tif(hsh1[0]==hsh2[0])printf(\"%d\\n\",mt2.a[0][0]);else printf(\"%d\\n\",mt2.a[0][1]);\n\treturn 0;\n}"
  },
  {
    "language": "Bash",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint gcd(int x, int y) {\n    return !y ? x : gcd(y, x % y);\n}\nconst int N = 2010;\nint a[N], e[N][N], n, d[N];\nbool vis[N];\nvector<int> g[N];\nvoid dfs(int x) {\n    vis[x] = 1;\n    for (int i = 1; i <= n; i++) \n        if (!vis[i] && e[x][i]) {\n            g[x].push_back(i); d[i]++;\n            dfs(i);\n        }\n}\npriority_queue<int> q;\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n    sort(a + 1, a + 1 + n);\n    for (int i = 1; i <= n; i++)\n        for (int j = i + 1; j <= n; j++)\n            if (gcd(a[i], a[j]) > 1)\n                e[i][j] = e[j][i] = 1;\n    for (int i = 1; i <= n; i++)\n        if (!vis[i]) dfs(i);\n    for (int i = 1; i <= n; i++) if (!d[i]) q.push(i);\n    while (!q.empty()) {\n        int u = q.top(); q.pop();\n        printf(\"%d \", a[u]);\n        for (int i = 0; i < g[u].size(); i++) {\n            int v = g[u][i];\n            if (!(--d[v])) q.push(v);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "Bash",
    "code": "#include<bits/stdc++.h>\n//#include<ext/pb_ds/assoc_container.hpp>\n#pragma comment(linker, \"/STACK:16000000\")\n//#define map gp_hash_table\n#define PI 3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679\nusing namespace std;\n//using namespace __gnu_pbds;\nconst int inf=0x3f3f3f3f;\nconst long long inf2=0x3f3f3f3f3f3f3f3f;\nconst double eps=1e-6;\nconst int mod=1000000007;\nbool huzhi[2002][2002];\nint n;\npair<int,int> a[2002];\nint itr[2002];\nvector<vector<int> > vec;\nbool used[2002];\nvector<int> cur;\nvoid dfs(int x){\n\tused[x]=true;\n\tcur.push_back(a[x].first);\n\tfor(int i=1;i<=n;i++){\n\t\tif(used[i] || huzhi[i][x])continue;\n\t\tdfs(i);\n\t\treturn;\n\t}\n}\nbool ok(){\n\tfor(int i=0;i<vec.size();i++)if(itr[i]!=vec[i].size())return false;\n\treturn true;\n}\nint main(){\n\tvec.clear();\n\tios::sync_with_stdio(0);\n\tcin>>n;\n\tfor(int i=1;i<=n;i++)cin>>a[i].first,a[i].second=i;\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;i++)for(int j=1;j<=n;j++)if(__gcd(a[i].first,a[j].first)==1)huzhi[i][j]=true;\n\tfor(int i=1;i<=n;i++)if(!used[i]){\n\t\tcur.clear();\n\t\tdfs(i);\n\t\tvec.push_back(cur);\n\t}\n\tvector<int> ans;\n\twhile(!ok()){\n\t\tint mx=-1,pos=-1;\n\t\tfor(int i=0;i<vec.size();i++)if(vec[i][itr[i]]>mx)mx=vec[i][itr[i]],pos=i;\n\t\titr[pos]++;\n\t\tans.push_back(mx);\n\t}\n\tfor(int i=0;i<ans.size();i++)cout<<ans[i]<<\" \";\n\treturn 0;\n}\n"
  },
  {
    "language": "Bash",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <queue>\n#define file(x) freopen(#x\".in\", \"r\", stdin), freopen(#x\".out\", \"w\", stdout)\n\nconst int N(2010);\nstruct edge { int next, to; } e[N];\nint head[N], e_num, n, A[N], vis[N], G[N][N], deg[N];\ninline void add_edge(int from, int to)\n{\n\te[++e_num] = (edge) {head[from], to};\n\thead[from] = e_num;\n}\n\nvoid dfs(int x)\n{\n\tfor (int i = vis[x] = 1; i <= n; i++) if (!vis[i] && G[x][i])\n\t\t++deg[i], add_edge(x, i), dfs(i);\n}\n\nvoid TopSort()\n{\n\tstd::priority_queue<int> Q;\n\tfor (int i = 1; i <= n; i++) if (!deg[i]) Q.push(i);\n\twhile (!Q.empty())\n\t{\n\t\tint x = Q.top(); Q.pop(); printf(\"%d \", A[x]);\n\t\tfor (int i = head[x]; i; i = e[i].next) Q.push(e[i].to);\n\t}\n}\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", A + i);\n\tstd::sort(A + 1, A + n + 1);\n\tfor (int i = 1; i <= n; i++) for (int j = i + 1; j <= n; j++)\n\t\tif (std::__gcd(A[i], A[j]) != 1) G[i][j] = G[j][i] = 1;\n\tfor (int i = 1; i <= n; i++) if (!vis[i]) dfs(i);\n\tTopSort();\n\treturn 0;\n}\n/////fdghg"
  },
  {
    "language": "Python",
    "code": "import random\ndef tester(N=0):\n\t'''\n\t制約\n1≦N≦2000\n1≦Ai≦108\n'''\n\tmaxno1=2000\n\tmaxno2=1e5\n\ts=input()\n\tif s!='':\n\t\treturn(s)\n\t\n\tif N==0:\n\t\treturn(2000)\n\t\treturn(random.randint(2,maxno1))\n\telse:\n\t\tprint('Testing...')\n\t\tprint('N=',N)\n\t\t\n\t\t#return('2 3 4 6')\n\t\t\n\t\tA=[]\n\t\tfor i in range(N):\n\t\t\tA.extend([random.randint(1,maxno2)])\n\t\tr=' '.join(list(map(str,A)))\n\t\t\n\t\treturn(r)\n\ndef factorint(n):\n\ti = 2\n\tT = set()\n\twhile i * i <= n:\n\t\twhile n % i == 0:\n\t\t\tn //= i\n\t\t\tT.add(i)\n\t\ti += 1\n\tif n > 1:\n\t\tT.add(n)\n\treturn(T)\n\nimport logging\nimport time\n\n\n\n# create logger\nlogger = logging.getLogger('simple_example')\nlogger.setLevel(logging.WARNING)\n#logger.setLevel(logging.DEBUG)\n\n# create console handler and set level to debug\nch = logging.StreamHandler()\nch.setLevel(logging.WARNING)\n#ch.setLevel(logging.DEBUG)\n\n# create formatter\nformatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')\n\n# add formatter to ch\nch.setFormatter(formatter)\n\n# add ch to logger\nlogger.addHandler(ch)\n\nimport copy\nN=int(tester())\nA=[int(x) for x in tester(N).split()]\n\nstart_time = time.time()\n\nA.sort(reverse=False)\nlogger.debug('A is %s',str(A))\n\nF=dict()\nP=dict()\nfor i in range(N):\n\tif A[i]==1:\n\t\tF[i]={1}\n\telse:\n\t\tF[i]=factorint(A[i])\n\t\t\n\tfor pn in F[i]:\n\t\tif pn not in P.keys():\n\t\t\tP[pn]=set()\n\t\tP[pn].add(i)\n\nstepcount=1\nlogger.debug('Step %d: loss = %.2f (%.3f sec)' % (stepcount, 100, time.time() - start_time))\n\nG=dict()\nfor i in F.keys():\n\tG[i]=set()\n\tfor y in F[i]:\n\t\tfor z in P[y]:\n\t\t\tG[i].add(z)\n\nstepcount=2\nlogger.debug('Step %d: loss = %.2f (%.3f sec)' % (stepcount, 100, time.time() - start_time))\n\nAc=set(range(N))\n\nstepcount=21\nlogger.debug('Step %d: loss = %.2f (%.3f sec)' % (stepcount, 100, time.time() - start_time))\n\nGc=copy.copy(G)\nTr=dict()\n\nstepcount=22\nlogger.debug('Step %d: loss = %.2f (%.3f sec)' % (stepcount, 100, time.time() - start_time))\n\n\nwhile len(Ac)>0:\n\tTmp=[]\n\trt=Ac.pop()\n\tme=rt\n\tTmp.extend([me])\n\t\n\twhile  len(Gc[me])>0:\n\t\tnxt=Gc[me].pop()\n\t\tif nxt in Ac:\n\t\t\t#Gc[nxt]=Gc[nxt]-{me}\n\t\t\tme=nxt\n\t\t\tTmp.extend([me])\n\t\t\tAc.remove(me)\t\n\t\n\tTr[rt]=Tmp\n\nstepcount=3\nlogger.debug('Step %d: loss = %.2f (%.3f sec)' % (stepcount, 100, time.time() - start_time))\n\nOoTr=list(Tr.keys())\nOoTr.sort(reverse=True)\n\nAnsIdx=[]\nfor i in OoTr:\n\tAnsIdx.extend(Tr[i])\n\nstepcount=4\nlogger.debug('Step %d: loss = %.2f (%.3f sec)' % (stepcount, 100, time.time() - start_time))\n\t\nfor i in range(N):\n\tfor j in range(N-1,i,-1):\n\t\tif AnsIdx[j-1]<AnsIdx[j]:\n\t\t\tif F[AnsIdx[j-1]]&F[AnsIdx[j]]==set():\n\t\t\t\tAnsIdx[j-1],AnsIdx[j]=AnsIdx[j],AnsIdx[j-1]\n\t\nAns=[A[i] for i in AnsIdx]\nprint(' '.join(list(map(str,Ans))))\n\nstepcount=5\nlogger.debug('Step %d: loss = %.2f (%.3f sec)' % (stepcount, 100, time.time() - start_time))\n\nlogger.removeHandler(ch)\n"
  },
  {
    "language": "Python",
    "code": "import random\ndef tester(N=0):\n\t'''\n\t制約\n1≦N≦2000\n1≦Ai≦108\n'''\n\tmaxno1=20\n\tmaxno2=1e5\n\ts=input()\n\tif s!='':\n\t\treturn(s)\n\t\n\tif N==0:\n\t\t#return(6)\n\t\treturn(random.randint(2,maxno1))\n\telse:\n\t\tprint('Testing...')\n\t\tprint('N=',N)\n\t\t\n\t\t#return('1 2 3 4 5 2')\n\t\t\n\t\tA=[]\n\t\tfor i in range(N):\n\t\t\tA.extend([random.randint(1,maxno2)])\n\t\tr=' '.join(list(map(str,A)))\n\t\t\n\t\treturn(r)\n\ndef factorint(n):\n\ti = 2\n\tT = []\n\twhile i * i <= n:\n\t\twhile n % i == 0:\n\t\t\tn //= i\n\t\t\tT.append(i)\n\t\ti += 1\n\tif n > 1:\n\t\tT.append(n)\n\treturn(T)\n\nimport logging\n\n# create logger\nlogger = logging.getLogger('simple_example')\nlogger.setLevel(logging.WARNING)#DEBUG)\n\n# create console handler and set level to debug\nch = logging.StreamHandler()\nch.setLevel(logging.WARNING) #DEBUG)\n\n# create formatter\nformatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')\n\n# add formatter to ch\nch.setFormatter(formatter)\n\n# add ch to logger\nlogger.addHandler(ch)\n\nimport copy\nN=int(tester())\nA=[int(x) for x in tester(N).split()]\nA.sort(reverse=False)\nlogger.debug('A is %s',str(A))\n\nF=dict()\nP=dict()\nfor i in range(N):\n\tif A[i]==1:\n\t\tF[i]={1}\n\telse:\n\t\tF[i]=set(factorint(A[i]))\n\tfor y in F[i]:\n\t\tif y not in P.keys():\n\t\t\tP[y]=set()\n\t\tP[y].add(i)\n\nG=dict()\nfor i in F.keys():\n\tG[i]=set()\n\tfor y in F[i]:\n\t\tG[i]=G[i].union(P[y])\n\tG[i].remove(i)\n\nAc=list(range(N))\nGc=copy.deepcopy(G)\nTr=dict()\nwhile len(Ac)>0:\n\tTmp=[]\n\trt=min(Ac)\n\tme=rt\n\tTmp.extend([me])\n\tAc.remove(me)\n\twhile len(Gc[me])>0:\n\t\tnxt=min(Gc[me])\n\t\tif nxt not in Ac:\n\t\t\tGc[me].remove(nxt)\n\t\t\tcontinue\n\t\telse:\n\t\t\tme=nxt\n\t\t\tTmp.extend([me])\n\t\t\tAc.remove(me)\n\tTr[rt]=Tmp\n\t\nOoTr=list(Tr.keys())\nOoTr.sort(reverse=True)\n\nAnsIdx=[]\nfor i in OoTr:\n\tAnsIdx.extend(Tr[i])\n\t\nfor i in range(N):\n\tfor j in range(N-1,i,-1):\n\t\tif AnsIdx[j-1]<AnsIdx[j]:\n\t\t\tif F[AnsIdx[j-1]]&F[AnsIdx[j]]==set():\n\t\t\t\tAnsIdx[j-1],AnsIdx[j]=AnsIdx[j],AnsIdx[j-1]\n\t\nAns=[A[i] for i in AnsIdx]\nprint(' '.join(list(map(str,Ans))))\n\nlogger.removeHandler(ch)\n"
  },
  {
    "language": "Python",
    "code": "import random\ndef tester(N=0):\n\tmaxno1=10\n\tmaxno2=1e2\n\ts=input()\n\tif s!='':\n\t\treturn(s)\n\t\n\tif N==0:\n\t\treturn(5)\n\t\treturn(random.randint(2,maxno1))\n\telse:\n\t\tprint('Testing...')\n\t\tprint('N=',N)\n\t\t\n\t\treturn('1 2 3 4 5')\n\t\t\n\t\tA=[]\n\t\tfor i in range(N):\n\t\t\tA.extend([random.randint(1,maxno2)])\n\t\tr=' '.join(list(map(str,A)))\n\t\tprint(r)\n\t\treturn(r)\n\ndef factorint(n):\n\ti = 2\n\tT = []\n\twhile i * i <= n:\n\t\twhile n % i == 0:\n\t\t\tn //= i\n\t\t\tT.append(i)\n\t\ti += 1\n\tif n > 1:\n\t\tT.append(n)\n\treturn(T)\n\nimport logging\n\n# create logger\nlogger = logging.getLogger('simple_example')\nlogger.setLevel(logging.DEBUG)\n\n# create console handler and set level to debug\nch = logging.StreamHandler()\nch.setLevel(logging.WARNING)\n\n# create formatter\nformatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')\n\n# add formatter to ch\nch.setFormatter(formatter)\n\n# add ch to logger\nlogger.addHandler(ch)\n\nimport copy\nN=int(tester())\nA=[int(x) for x in tester(N).split()]\nA.sort(reverse=False)\nlogger.debug('A is %s',str(A))\n\nF=dict()\nP=dict()\nfor x in A:\n\tif x==1:\n\t\tF[1]={1}\n\telse:\n\t\tF[x]=set(factorint(x))\n\tfor y in F[x]:\n\t\tif y not in P.keys():\n\t\t\tP[y]=set()\n\t\tP[y].add(x)\n\nG=dict()\nfor x in F.keys():\n\tG[x]=set()\n\tfor y in F[x]:\n\t\tG[x]=G[x].union(P[y])\n\tG[x].remove(x)\n\nAc=copy.deepcopy(A)\nGc=copy.deepcopy(G)\nTr=dict()\nwhile len(Ac)>0:\n\tTmp=[]\n\trt=min(Ac)\n\tme=rt\n\tTmp.extend([me])\n\tAc.remove(me)\n\twhile len(Gc[me])>0:\n\t\tnxt=min(Gc[me])\n\t\tif nxt not in Ac:\n\t\t\tGc[me].remove(nxt)\n\t\t\tcontinue\n\t\telse:\n\t\t\tme=nxt\n\t\t\tTmp.extend([me])\n\t\t\tAc.remove(me)\n\tTr[rt]=Tmp\n\t\nOoTr=list(Tr.keys())\nOoTr.sort(reverse=True)\n\nAns=[]\nfor x in OoTr:\n\tAns.extend(Tr[x])\n\nprint(' '.join(list(map(str,Ans))))\n\n(logger).removeHandler(ch)\n"
  },
  {
    "language": "Python",
    "code": "import random\ndef tester(N=0):\n\t'''\n\t制約\n1≦N≦2000\n1≦Ai≦108\n'''\n\tmaxno1=2000\n\tmaxno2=1e5\n\ts=input()\n\tif s!='':\n\t\treturn(s)\n\t\n\tif N==0:\n\t\treturn(6)\n\t\treturn(random.randint(2,maxno1))\n\telse:\n\t\tprint('Testing...')\n\t\tprint('N=',N)\n\t\t\n\t\treturn('1 2 3 4 5 2')\n\t\t\n\t\tA=[]\n\t\tfor i in range(N):\n\t\t\tA.extend([random.randint(1,maxno2)])\n\t\tr=' '.join(list(map(str,A)))\n\t\t\n\t\treturn(r)\n\ndef factorint(n):\n\ti = 2\n\tT = []\n\twhile i * i <= n:\n\t\twhile n % i == 0:\n\t\t\tn //= i\n\t\t\tT.append(i)\n\t\ti += 1\n\tif n > 1:\n\t\tT.append(n)\n\treturn(T)\n\nimport logging\n\n# create logger\nlogger = logging.getLogger('simple_example')\nlogger.setLevel(logging.WARNING)#DEBUG)\n\n# create console handler and set level to debug\nch = logging.StreamHandler()\nch.setLevel(logging.WARNING) #DEBUG)\n\n# create formatter\nformatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')\n\n# add formatter to ch\nch.setFormatter(formatter)\n\n# add ch to logger\nlogger.addHandler(ch)\n\nimport copy\nN=int(tester())\nA=[int(x) for x in tester(N).split()]\nA.sort(reverse=False)\nlogger.debug('A is %s',str(A))\n\nF=dict()\nP=dict()\nfor i in range(N):\n\tif A[i]==1:\n\t\tF[i]={1}\n\telse:\n\t\tF[i]=set(factorint(A[i]))\n\tfor y in F[i]:\n\t\tif y not in P.keys():\n\t\t\tP[y]=set()\n\t\tP[y].add(i)\n\nG=dict()\nfor i in F.keys():\n\tG[i]=set()\n\tfor y in F[i]:\n\t\tG[i]=G[i].union(P[y])\n\tG[i].remove(i)\n\nAc=list(range(N))\nGc=copy.deepcopy(G)\nTr=dict()\nwhile len(Ac)>0:\n\tTmp=[]\n\trt=min(Ac)\n\tme=rt\n\tTmp.extend([me])\n\tAc.remove(me)\n\twhile len(Gc[me])>0:\n\t\tnxt=min(Gc[me])\n\t\tif nxt not in Ac:\n\t\t\tGc[me].remove(nxt)\n\t\t\tcontinue\n\t\telse:\n\t\t\tme=nxt\n\t\t\tTmp.extend([me])\n\t\t\tAc.remove(me)\n\tTr[rt]=Tmp\n\t\nOoTr=list(Tr.keys())\nOoTr.sort(reverse=True)\n\nAnsIdx=[]\nfor i in OoTr:\n\tAnsIdx.extend(Tr[i])\nAns=[A[i] for i in AnsIdx]\nprint(' '.join(list(map(str,Ans))))\n\nlogger.removeHandler(ch)\n"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\nmod = 10**9 + 7\n\ndef LI(): return list(map(int, input().split()))\ndef II(): return int(input())\ndef LS(): return input().split()\ndef S(): return input()\n\n\ndef main():\n    n = II()\n    a = LI()\n    a.sort()\n    i = n-1\n    m = {}\n    def g(a,b):\n        if (a,b) in m:\n            return m[(a,b)]\n        c = math.gcd(a,b)\n        if c == 1:\n            m[(a,b)] = True\n        else:\n            m[(a,b)] = False\n        return c == 1\n\n    def f(i):\n        ai = a[i]\n        ii = i\n        ff = False\n        while ii > 0:\n            j = ii-1\n            aj = a[j]\n            mj = ii\n            while g(ai,a[j]) and j >= 0:\n                if a[j] < ai:\n                    mj = j\n                j -= 1\n            if mj != ii:\n                a[mj:ii+1] = [ai] + a[mj:ii]\n                ff = True\n                ii = mj\n            else:\n                if f(ii-1):\n                    continue\n                else:\n                    break\n        return ff\n\n    for i in range(n-1,-1,-1):\n        while f(i):\n            pass\n    sa = a[:]\n    for _ in range(100):\n        random.shuffle(a)\n        for i in range(n-1,-1,-1):\n            while f(i):\n                pass\n        if a < sa:\n            sa = a[:]\n\n    return ' '.join(map(str, sa))\n\nprint(main())\n"
  },
  {
    "language": "Python",
    "code": "def gcd(a,b):\n    return gcd(b,a%b) if b else a\n\ndef merge(a,us,vs):\n    i,j,res=0,0,[]\n    while i<len(us) and j<len(vs):\n        if a[us[i]]>=a[vs[j]]:\n            res.append(us[i])\n            i+=1\n        else:\n            res.append(vs[j])\n            j+=1\n    return res+us[i:]+vs[j:]\n\ndef dfs(g,a,u,vis):\n    vis[u]=True\n    res=[]\n    for v in g[u]:\n        if not vis[v]:\n            res=merge(a,res,dfs(g,a,v,vis))\n    return [u]+res\n\nwhile 1:\n    try:\n        n=int(input())\n        a=sorted(map(int,input().split()))\n    except: break\n\n    g=[[j for j in range(n) if i!=j and gcd(a[i],a[j])!=1] for i in range(n)]\n    #vis=[False]*n\n    #res=[]\n    #for u in range(n):\n    #    if not vis[u]:\n    #        res=merge(a,res,dfs(g,a,u,vis))\n    #print(' '.join(str(a[u]) for u in res))\n"
  },
  {
    "language": "Python",
    "code": "def gcd(a,b):\n    return gcd(b,a%b) if b else a\n\ndef merge(a,us,vs):\n    i,j,res=0,0,[]\n    while i<len(us) and j<len(vs):\n        if a[us[i]]>=a[vs[j]]:\n            res.append(us[i])\n            i+=1\n        else:\n            res.append(vs[j])\n            j+=1\n    return res+us[i:]+vs[j:]\n\ndef dfs(g,a,u,vis):\n    vis[u]=True\n    res=[]\n    for v in g[u]:\n        if not vis[v]:\n            res=merge(a,res,dfs(g,a,v,vis))\n    return [u]+res\n\nwhile 1:\n    try:\n        n=int(input())\n        a=sorted(map(int,input().split()))\n    except: break\n\n    g=[[j for j in range(n) if i!=j and gcd(a[i],a[j])!=1] for i in range(n)]\n    vis=[False]*n\n    res=[]\n    for u in range(n):\n        if not vis[u]:\n            res=merge(a,res,dfs(g,a,u,vis))\n    print(' '.join(str(a[u]) for u in res))\n"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(1000000000)\n\ndef gcd(a: int, b:int):\n    while b:\n        a,b=b,a%b\n    return a\n\ndef merge(a,us,vs):\n    i,j,res=0,0,[]\n    while i<len(us) and j<len(vs):\n        if a[us[i]]>=a[vs[j]]:\n            res.append(us[i])\n            i+=1\n        else:\n            res.append(vs[j])\n            j+=1\n    return res+us[i:]+vs[j:]\n\ndef dfs(g,a,u,vis):\n    vis[u]=True\n    res=[]\n    for v in g[u]:\n        if not vis[v]:\n            res=merge(a,res,dfs(g,a,v,vis))\n    return [u]+res\n\nwhile 1:\n    try:\n        n=int(input())\n        a=sorted(map(int,input().split()))\n    except: break\n\n    g=[[] for _ in range(n)]\n    for i in range(n):\n        for j in range(i+1,n):\n            if gcd(a[i],a[j])!=1:\n                g[i].append(j)\n                g[j].append(i)\n\n    vis=[False]*n\n    res=[]\n    for u in range(n):\n        if not vis[u]:\n            res=merge(a,res,dfs(g,a,u,vis))\n    print(' '.join(str(a[u]) for u in res))\n"
  },
  {
    "language": "Python",
    "code": "import random\ndef tester(N=0):\n\tmaxno1=10\n\tmaxno2=1e2\n\ts=input()\n\tif s!='':\n\t\treturn(s)\n\t\n\tif N==0:\n\t\treturn(6)\n\t\treturn(random.randint(2,maxno1))\n\telse:\n\t\tprint('Testing...')\n\t\tprint('N=',N)\n\t\t\n\t\treturn('2 3 4 5 6 25')\n\t\t\n\t\tA=[]\n\t\tfor i in range(N):\n\t\t\tA.extend([random.randint(1,maxno2)])\n\t\tr=' '.join(list(map(str,A)))\n\t\tprint(r)\n\t\treturn(r)\n\ndef factorint(n):\n\ti = 2\n\tT = []\n\twhile i * i <= n:\n\t\twhile n % i == 0:\n\t\t\tn //= i\n\t\t\tT.append(i)\n\t\ti += 1\n\tif n > 1:\n\t\tT.append(n)\n\treturn(T)\n\nimport logging\n\n# create logger\nlogger = logging.getLogger('simple_example')\nlogger.setLevel(logging.DEBUG)\n\n# create console handler and set level to debug\nch = logging.StreamHandler()\nch.setLevel(logging.WARNING)\n\n# create formatter\nformatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')\n\n# add formatter to ch\nch.setFormatter(formatter)\n\n# add ch to logger\nlogger.addHandler(ch)\n\nimport copy\nN=int(tester())\nA=[int(x) for x in tester(N).split()]\nA.sort(reverse=False)\nlogger.debug('A is %s',str(A))\n\nF=dict()\nP=dict()\nfor x in A:\n\tF[x]=set(factorint(x))\n\tfor y in F[x]:\n\t\tif y not in P.keys():\n\t\t\tP[y]=set()\n\t\tP[y].add(x)\n\nG=dict()\nfor x in F.keys():\n\tG[x]=set()\n\tfor y in F[x]:\n\t\tG[x]=G[x].union(P[y])\n\tG[x].remove(x)\n\nAc=copy.deepcopy(A)\nGc=copy.deepcopy(G)\nTr=dict()\nwhile len(Ac)>0:\n\tTmp=[]\n\trt=min(Ac)\n\tme=rt\n\tTmp.extend([me])\n\tAc.remove(me)\n\twhile len(Gc[me])>0:\n\t\tnxt=min(Gc[me])\n\t\tif nxt not in Ac:\n\t\t\tGc[me].remove(nxt)\n\t\t\tcontinue\n\t\telse:\n\t\t\tme=nxt\n\t\t\tTmp.extend([me])\n\t\t\tAc.remove(me)\n\tTr[rt]=Tmp\n\t\nOoTr=list(Tr.keys())\nOoTr.sort(reverse=True)\n\nAns=[]\nfor x in OoTr:\n\tAns.extend(Tr[x])\n\nprint(' '.join(list(map(str,Ans))))\n\n(logger).removeHandler(ch)\n"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(1000000000)\n\ndef gcd(a: int, b:int):\n    while b:\n        a,b=b,a%b\n    return a\n\ndef merge(a,us,vs):\n    i,j,res=0,0,[]\n    while i<len(us) and j<len(vs):\n        if a[us[i]]>=a[vs[j]]:\n            res.append(us[i])\n            i+=1\n        else:\n            res.append(vs[j])\n            j+=1\n    return res+us[i:]+vs[j:]\n\ndef dfs(g,a,u,vis):\n    vis[u]=True\n    res=[]\n    for v in g[u]:\n        if not vis[v]:\n            res=merge(a,res,dfs(g,a,v,vis))\n    return [u]+res\n\nwhile 1:\n    try:\n        n=int(input())\n        a=sorted(map(int,input().split()))\n    except: break\n\n    g=[[] for _ in range(n)]\n    for i in range(n):\n        for j in range(i+1,n):\n            if gcd(a[i],a[j])!=1:\n                g[i].append(j)\n                g[j].append(i)\n\n    vis=[False]*n\n    res=[]\n    for u in range(n):\n        if not vis[u]:\n            res=merge(a,res,dfs(g,a,u,vis))\n    print(' '.join(str(a[u]) for u in res))\n"
  },
  {
    "language": "Python",
    "code": "def gcd(a,b):\n    return gcd(b,a%b) if b else a\n\ndef merge(a,us,vs):\n    i,j,res=0,0,[]\n    while i<len(us) and j<len(vs):\n        if a[us[i]]>=a[vs[j]]:\n            res.append(us[i])\n            i+=1\n        else:\n            res.append(vs[j])\n            j+=1\n    return res+us[i:]+vs[j:]\n\ndef dfs(g,a,u,vis):\n    vis[u]=True\n    res=[]\n    for v in g[u]:\n        if not vis[v]:\n            res=merge(a,res,dfs(g,a,v,vis))\n    return [u]+res\n\nwhile 1:\n    try:\n        n=int(input())\n        a=sorted(map(int,input().split()))\n    except: break\n\n    g=[[j for j in range(n) if i!=j and gcd(a[i],a[j])!=1] for i in range(n)]\n    vis=[False]*n\n    res=[]\n    for u in range(n):\n        if not vis[u]:\n            res=merge(a,res,dfs(g,a,u,vis))\n    print(' '.join(str(a[u]) for u in res))\n"
  },
  {
    "language": "Python",
    "code": "import random\ndef tester(N=0):\n\t'''\n\t制約\n1≦N≦2000\n1≦Ai≦108\n'''\n\tmaxno1=2000\n\tmaxno2=1e5\n\ts=input()\n\tif s!='':\n\t\treturn(s)\n\t\n\tif N==0:\n\t\treturn(6)\n\t\treturn(random.randint(2,maxno1))\n\telse:\n\t\tprint('Testing...')\n\t\tprint('N=',N)\n\t\t\n\t\treturn('1 2 3 4 5 2')\n\t\t\n\t\tA=[]\n\t\tfor i in range(N):\n\t\t\tA.extend([random.randint(1,maxno2)])\n\t\tr=' '.join(list(map(str,A)))\n\t\t\n\t\treturn(r)\n\ndef factorint(n):\n\ti = 2\n\tT = set()\n\twhile i * i <= n:\n\t\twhile n % i == 0:\n\t\t\tn //= i\n\t\t\tT.add(i)\n\t\ti += 1\n\tif n > 1:\n\t\tT.add(n)\n\treturn(T)\n\nimport logging\nimport time\n\n\n\n# create logger\nlogger = logging.getLogger('simple_example')\nlogger.setLevel(logging.WARNING)#DEBUG)\n\n# create console handler and set level to debug\nch = logging.StreamHandler()\nch.setLevel(logging.WARNING)#DEBUG)\n\n# create formatter\nformatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')\n\n# add formatter to ch\nch.setFormatter(formatter)\n\n# add ch to logger\nlogger.addHandler(ch)\n\nimport copy\nN=int(tester())\nA=[int(x) for x in tester(N).split()]\n\nstart_time = time.time()\n\nA.sort(reverse=False)\nlogger.debug('A is %s',str(A))\n\nF=dict()\nP=dict()\nfor i in range(N):\n\tif A[i]==1:\n\t\tF[i]={1}\n\telse:\n\t\tF[i]=factorint(A[i])\n\t\t\n\tfor pn in F[i]:\n\t\tif pn not in P.keys():\n\t\t\tP[pn]=set()\n\t\tP[pn].add(i)\n\nstepcount=1\nlogger.debug('Step %d: loss = %.2f (%.3f sec)' % (stepcount, 100, time.time() - start_time))\n\nG=dict()\nfor i in F.keys():\n\tG[i]=set()\n\tfor y in F[i]:\n\t\tG[i]=G[i].union(P[y])\n\tG[i]={k for k in G[i] if k>i}\n\t\n\t#G[i].remove(i)\n\nstepcount=2\nlogger.debug('Step %d: loss = %.2f (%.3f sec)' % (stepcount, 100, time.time() - start_time))\n'''\nhttps://ja.m.wikipedia.org/wiki/トポロジカルソート\n\n    \nL ← トポロジカルソートされた結果の入る空の連結リスト\n\nfor each ノード n do\n    visit(n)\n\nfunction visit(Node n)\n    if n をまだ訪れていなければ then\n        n を訪問済みとして印を付ける\n        for each n の出力辺 e とその先のノード m do\n            visit(m)\n        n を L の先頭に追加\n'''\n#bellow is a bottleneck\nAc=set(range(N))\n\nstepcount=21\nlogger.debug('Step %d: loss = %.2f (%.3f sec)' % (stepcount, 100, time.time() - start_time))\n\nGc=copy.copy(G)\nTr=dict()\n\nstepcount=22\nlogger.debug('Step %d: loss = %.2f (%.3f sec)' % (stepcount, 100, time.time() - start_time))\n\n\nwhile len(Ac)>0:\n\tTmp=[]\n\trt=Ac.pop()\n\tme=rt\n\tTmp.extend([me])\n\t\n\twhile  len(Gc[me])>0:\n\t\tnxt=Gc[me].pop()\n\t\tif nxt in Ac:\n\t\t\t#Gc[nxt]=Gc[nxt]-{me}\n\t\t\tme=nxt\n\t\t\tTmp.extend([me])\n\t\t\tAc.remove(me)\t\n\t\n\tTr[rt]=Tmp\n\nstepcount=3\nlogger.debug('Step %d: loss = %.2f (%.3f sec)' % (stepcount, 100, time.time() - start_time))\n\nOoTr=list(Tr.keys())\nOoTr.sort(reverse=True)\n\nAnsIdx=[]\nfor i in OoTr:\n\tAnsIdx.extend(Tr[i])\n\nstepcount=4\nlogger.debug('Step %d: loss = %.2f (%.3f sec)' % (stepcount, 100, time.time() - start_time))\n\t\nfor i in range(N):\n\tfor j in range(N-1,i,-1):\n\t\tif AnsIdx[j-1]<AnsIdx[j]:\n\t\t\tif F[AnsIdx[j-1]]&F[AnsIdx[j]]==set():\n\t\t\t\tAnsIdx[j-1],AnsIdx[j]=AnsIdx[j],AnsIdx[j-1]\n\t\nAns=[A[i] for i in AnsIdx]\nprint(' '.join(list(map(str,Ans))))\n\nstepcount=5\nlogger.debug('Step %d: loss = %.2f (%.3f sec)' % (stepcount, 100, time.time() - start_time))\n\nlogger.removeHandler(ch)\n"
  }
]