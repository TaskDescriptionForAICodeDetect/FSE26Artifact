[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\nint gcd(int a, int b) {\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\nvoid swap(int *a, int *b) {\n    int temp = *a;\n    *a = *b;\n    *b = temp;\n}\n\nvoid solve(int N, int *A) {\n    // Sort for Takahashi's optimal lexicographically smallest arrangement\n    for (int i = 0; i < N - 1; i++) {\n        for (int j = 0; j < N - i - 1; j++) {\n            if (A[j] > A[j + 1]) {\n                swap(&A[j], &A[j + 1]);\n            }\n        }\n    }\n\n    // Simulate Aoki's swaps\n    bool swapped;\n    do {\n        swapped = false;\n        for (int i = 0; i < N - 1; i++) {\n            if (gcd(A[i], A[i + 1]) == 1) {\n                if (A[i] < A[i + 1]) {\n                    swap(&A[i], &A[i + 1]);\n                    swapped = true;\n                }\n            }\n        }\n    } while (swapped);\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    \n    int *A = malloc(N * sizeof(int));\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n    \n    solve(N, A);\n    \n    for (int i = 0; i < N; i++) {\n        printf(\"%d \", A[i]);\n    }\n    printf(\"\\n\");\n    \n    free(A);\n    return 0;\n}",
    "timestamp": "2025-08-05 23:26:18"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\nint gcd(int a, int b) {\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\nbool are_connected(int a, int b, int *parent, int size) {\n    int root_a = a;\n    while (parent[root_a] != root_a) {\n        parent[root_a] = parent[parent[root_a]];\n        root_a = parent[root_a];\n    }\n    int root_b = b;\n    while (parent[root_b] != root_b) {\n        parent[root_b] = parent[parent[root_b]];\n        root_b = parent[root_b];\n    }\n    return root_a == root_b;\n}\n\nvoid union_sets(int a, int b, int *parent, int *rank, int size) {\n    int root_a = a;\n    while (parent[root_a] != root_a) {\n        parent[root_a] = parent[parent[root_a]];\n        root_a = parent[root_a];\n    }\n    int root_b = b;\n    while (parent[root_b] != root_b) {\n        parent[root_b] = parent[parent[root_b]];\n        root_b = parent[root_b];\n    }\n    if (root_a == root_b) return;\n    if (rank[root_a] < rank[root_b]) {\n        parent[root_a] = root_b;\n    } else if (rank[root_a] > rank[root_b]) {\n        parent[root_b] = root_a;\n    } else {\n        parent[root_b] = root_a;\n        rank[root_a]++;\n    }\n}\n\nint compare(const void *a, const void *b) {\n    return (*(int *)a - *(int *)b);\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    int A[N];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n\n    int parent[N];\n    int rank[N];\n    for (int i = 0; i < N; i++) {\n        parent[i] = i;\n        rank[i] = 0;\n    }\n\n    for (int i = 0; i < N; i++) {\n        for (int j = i + 1; j < N; j++) {\n            if (gcd(A[i], A[j]) != 1) {\n                union_sets(i, j, parent, rank, N);\n            }\n        }\n    }\n\n    int components[N];\n    for (int i = 0; i < N; i++) {\n        int root = i;\n        while (parent[root] != root) {\n            parent[root] = parent[parent[root]];\n            root = parent[root];\n        }\n        components[i] = root;\n    }\n\n    int component_sizes[N];\n    for (int i = 0; i < N; i++) {\n        component_sizes[i] = 0;\n    }\n    for (int i = 0; i < N; i++) {\n        component_sizes[components[i]]++;\n    }\n\n    int component_indices[N];\n    int component_pos = 0;\n    for (int i = 0; i < N; i++) {\n        if (component_sizes[i] > 0) {\n            component_indices[component_pos++] = i;\n        }\n    }\n\n    int result[N];\n    int pos = 0;\n    for (int i = 0; i < component_pos; i++) {\n        int current_component = component_indices[i];\n        int temp[component_sizes[current_component]];\n        int temp_pos = 0;\n        for (int j = 0; j < N; j++) {\n            if (components[j] == current_component) {\n                temp[temp_pos++] = A[j];\n            }\n        }\n        qsort(temp, temp_pos, sizeof(int), compare);\n        for (int j = 0; j < temp_pos; j++) {\n            result[pos++] = temp[j];\n        }\n    }\n\n    for (int i = 0; i < N; i++) {\n        printf(\"%d \", result[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}",
    "timestamp": "2025-08-05 23:26:55"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint gcd(int a, int b) {\n    return b == 0 ? a : gcd(b, a % b);\n}\n\nint main() {\n    int N;\n    cin >> N;\n    vector<int> A(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> A[i];\n    }\n\n    sort(A.begin(), A.end());\n\n    vector<bool> used(N, false);\n    vector<int> result;\n\n    for (int i = 0; i < N; ++i) {\n        if (used[i]) continue;\n        result.push_back(A[i]);\n        used[i] = true;\n        int last = A[i];\n        for (int j = i + 1; j < N; ++j) {\n            if (!used[j] && gcd(last, A[j]) == 1) {\n                result.push_back(A[j]);\n                used[j] = true;\n                last = A[j];\n            }\n        }\n    }\n\n    for (int num : result) {\n        cout << num << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 23:27:07"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.util.stream.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int[] A = new int[N];\n        for (int i = 0; i < N; i++) {\n            A[i] = scanner.nextInt();\n        }\n        \n        Arrays.sort(A);\n        List<Integer> result = new ArrayList<>();\n        boolean[] used = new boolean[N];\n        \n        for (int i = 0; i < N; i++) {\n            if (!used[i]) {\n                result.add(A[i]);\n                used[i] = true;\n                for (int j = i + 1; j < N; j++) {\n                    if (!used[j] && gcd(A[i], A[j]) != 1) {\n                        result.add(A[j]);\n                        used[j] = true;\n                    }\n                }\n            }\n        }\n        \n        for (int num : result) {\n            System.out.print(num + \" \");\n        }\n    }\n    \n    private static int gcd(int a, int b) {\n        while (b != 0) {\n            int temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return a;\n    }\n}",
    "timestamp": "2025-08-05 23:27:57"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Solution {\n    public static int[] solve(int[] A) {\n        int N = A.length;\n        \n        // Sort Takahashi's initial arrangement to be lexicographically smallest\n        Arrays.sort(A);\n        \n        // Check if Aoki can swap\n        boolean canSwap = false;\n        for (int i = 0; i < N - 1; i++) {\n            if (gcd(A[i], A[i+1]) == 1) {\n                canSwap = true;\n                break;\n            }\n        }\n        \n        // If no coprime adjacent integers, return sorted array\n        if (!canSwap) {\n            return A;\n        }\n        \n        // Aoki will make lexicographically largest sequence\n        return getMaxSequence(A);\n    }\n    \n    private static int[] getMaxSequence(int[] A) {\n        int N = A.length;\n        int[] result = Arrays.copyOf(A, N);\n        boolean changed;\n        \n        do {\n            changed = false;\n            for (int i = 0; i < N - 1; i++) {\n                if (gcd(result[i], result[i+1]) == 1 && result[i] < result[i+1]) {\n                    // Swap\n                    int temp = result[i];\n                    result[i] = result[i+1];\n                    result[i+1] = temp;\n                    changed = true;\n                }\n            }\n        } while (changed);\n        \n        return result;\n    }\n    \n    private static int gcd(int a, int b) {\n        while (b != 0) {\n            int temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return a;\n    }\n}",
    "timestamp": "2025-08-05 23:28:05"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n\nusing namespace std;\n\nint gcd(int a, int b) {\n    return b == 0 ? a : gcd(b, a % b);\n}\n\nint main() {\n    int N;\n    cin >> N;\n    vector<int> A(N);\n    for (int i = 0; i < N; i++) {\n        cin >> A[i];\n    }\n\n    // Takahashi's move: sort in ascending order\n    sort(A.begin(), A.end());\n\n    // Aoki's move: maximize through coprime swaps\n    for (int i = 0; i < N - 1; i++) {\n        for (int j = 0; j < N - 1 - i; j++) {\n            if (gcd(A[j], A[j+1]) == 1 && A[j] < A[j+1]) {\n                swap(A[j], A[j+1]);\n            }\n        }\n    }\n\n    // Output final sequence\n    for (int i = 0; i < N; i++) {\n        cout << A[i] << \" \";\n    }\n    cout << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 23:28:17"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from math import gcd\n\ndef optimal_sequence(n, a):\n    def is_coprime(x, y):\n        return gcd(x, y) == 1\n\n    # Sort the array to get Takahashi's optimal start\n    a.sort()\n    \n    # Scan the sorted array with Aoki's optimal swaps\n    for i in range(n - 1):\n        for j in range(n - 1, i, -1):\n            if is_coprime(a[j], a[j - 1]) and a[j] > a[j - 1]:\n                a[j], a[j - 1] = a[j - 1], a[j]\n    \n    return a\n\n# Example usage:\nn = 5\na = [4, 3, 2, 8, 6]\nresult = optimal_sequence(n, a)\nprint(result)",
    "timestamp": "2025-08-13 15:21:24"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int[] A = new int[N];\n        for (int i = 0; i < N; i++) {\n            A[i] = scanner.nextInt();\n        }\n\n        Arrays.sort(A);\n        int[] result = optimizedLargestSequence(A);\n        \n        for (int num : result) {\n            System.out.print(num + \" \");\n        }\n    }\n\n    private static int[] optimizedLargestSequence(int[] arr) {\n        List<Integer> list = new ArrayList<>();\n        for (int num : arr) {\n            list.add(num);\n        }\n\n        for (int i = 0; i < list.size() - 1; ) {\n            if (gcd(list.get(i), list.get(i + 1)) == 1) {\n                if (list.get(i) < list.get(i + 1)) {\n                    Collections.swap(list, i, i + 1);\n                    if (i > 0) {\n                        i--;\n                    }\n                } else {\n                    i++;\n                }\n            } else {\n                i++;\n            }\n        }\n\n        int[] result = new int[list.size()];\n        for (int i = 0; i < list.size(); i++) {\n            result[i] = list.get(i);\n        }\n\n        return result;\n    }\n\n    private static int gcd(int a, int b) {\n        while (b != 0) {\n            int temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return a;\n    }\n}",
    "timestamp": "2025-08-13 15:21:29"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint gcd(int a, int b) {\n    while (b != 0) {\n        int temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a) - (*(int*)b);\n}\n\nvoid optimalArrangement(int arr[], int n) {\n    qsort(arr, n, sizeof(int), compare);\n}\n\nvoid swapAdjacentCoprime(int arr[], int n) {\n    int swapped;\n    do {\n        swapped = 0;\n        for (int i = 0; i < n - 1; i++) {\n            if (gcd(arr[i], arr[i + 1]) == 1 && arr[i] < arr[i + 1]) {\n                int temp = arr[i];\n                arr[i] = arr[i + 1];\n                arr[i + 1] = temp;\n                swapped = 1;\n            }\n        }\n    } while (swapped);\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    int A[N];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &A[i]);\n    }\n\n    optimalArrangement(A, N);\n    swapAdjacentCoprime(A, N);\n\n    for (int i = 0; i < N; i++) {\n        printf(\"%d \", A[i]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}",
    "timestamp": "2025-08-13 15:21:32"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n\nbool areCoprime(int a, int b) {\n    return std::gcd(a, b) == 1;\n}\n\nstd::vector<int> optimalTakahashi(const std::vector<int>& A) {\n    std::vector<int> sortedA = A;\n    std::sort(sortedA.begin(), sortedA.end());\n    return sortedA;\n}\n\nstd::vector<int> optimalAoki(std::vector<int>& sequence) {\n    bool swapped;\n    do {\n        swapped = false;\n        for (size_t i = 0; i < sequence.size() - 1; ++i) {\n            if (areCoprime(sequence[i], sequence[i + 1]) && sequence[i] < sequence[i + 1]) {\n                std::swap(sequence[i], sequence[i + 1]);\n                swapped = true;\n            }\n        }\n    } while (swapped);\n    return sequence;\n}\n\nint main() {\n    int N;\n    std::cin >> N;\n    std::vector<int> A(N);\n    for (int i = 0; i < N; ++i) {\n        std::cin >> A[i];\n    }\n\n    std::vector<int> takahashiSequence = optimalTakahashi(A);\n    std::vector<int> aokiSequence = optimalAoki(takahashiSequence);\n\n    for (int num : aokiSequence) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 15:21:36"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef are_coprime(a, b):\n    return gcd(a, b) == 1\n\ndef solve(N, A):\n    # Sort A initially to help find the lexicographically smallest sequence\n    A.sort()\n    \n    # Try all possible permutations of A \n    from itertools import permutations\n    \n    best_sequence = None\n    \n    for perm in permutations(A):\n        current = list(perm)\n        \n        # Check if current sequence can be maximized by Aoki\n        changed = True\n        while changed:\n            changed = False\n            for j in range(len(current) - 1):\n                if are_coprime(current[j], current[j+1]):\n                    # Check if swapping would make sequence lexicographically larger\n                    if current[j] < current[j+1]:\n                        current[j], current[j+1] = current[j+1], current[j]\n                        changed = True\n        \n        # Update best sequence if current is lexicographically smaller\n        if best_sequence is None or current < best_sequence:\n            best_sequence = current\n    \n    return best_sequence\n\n# Read input\nN = int(input())\nA = list(map(int, input().split()))\n\n# Get and print result\nresult = solve(N, A)\nprint(' '.join(map(str, result)))",
    "timestamp": "2025-08-13 15:21:42"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nimport math\n\ndef solve():\n    N = int(sys.stdin.readline())\n    A = list(map(int, sys.stdin.readline().split()))\n    \n    # We need to find the lex smallest sequence Takahashi can arrange,\n    # knowing that Aoki will swap adjacent coprime pairs to make it lex largest.\n    # The key observation is that Takahashi can arrange the numbers in such a way\n    # that no adjacent pair is coprime (gcd > 1), preventing Aoki from making any swaps.\n    # Then the sequence remains as Takahashi arranged it, which is the lex smallest possible.\n    \n    # So the solution is to sort the array in lex order, but ensuring that adjacent elements are not coprime.\n    # To achieve this, we can use a greedy approach where we try to place the smallest possible number next,\n    # but ensuring it's not coprime with the previous one.\n    \n    A_sorted = sorted(A)\n    used = [False] * N\n    res = []\n    \n    # Start with the smallest number\n    res.append(A_sorted[0])\n    used[0] = True\n    \n    last = A_sorted[0]\n    remaining = N - 1\n    \n    while remaining > 0:\n        found = -1\n        # Try to find the smallest unused number not coprime with 'last'\n        for i in range(N):\n            if not used[i] and math.gcd(last, A_sorted[i]) > 1:\n                found = i\n                break\n        if found == -1:\n            # No such number, pick the smallest remaining\n            for i in range(N):\n                if not used[i]:\n                    found = i\n                    break\n        res.append(A_sorted[found])\n        used[found] = True\n        last = A_sorted[found]\n        remaining -= 1\n    \n    print(' '.join(map(str, res)))\n\nsolve()",
    "timestamp": "2025-08-13 15:21:53"
  }
]