[
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define all(v) (v).begin(),(v).end()\n#define pb push_back\n#define ppb pop_back\n#define mp make_pair\n#define ri(x) scanf(\"%d\",&(x))\n#define ri2(x,y) scanf(\"%d %d\",&(x),&(y))\n#define ri3(x,y,z) scanf(\"%d %d %d\",&(x),&(y),&(z))\n#define rll(x) scanf(\"%lld\",&(x))\n#define rll2(x,y) scanf(\"%lld %lld\",&(x),&(y))\n#define rll3(x,y,z) scanf(\"%lld %lld %lld\",&(x),&(y),&(z))\n#define gc(x) ((x) = getchar())\nusing namespace::std;\n\nconst long double PI = acos(-1);\nconst long long MOD = 1000000000 +7;\n\ntypedef long long ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<ll,pll> tll;\ntypedef pair<int,int> ii;\ntypedef pair<int,ii> iii;\ntypedef vector<int> vi;\ntypedef vector<ii> vii;\ntypedef vector<iii> viii;\ntypedef vector<ll> vll;\ntypedef vector<pll> vpll;\ntypedef vector<tll> vtll;\ntypedef vector<string> vs;\ntypedef set<int> si;\ntypedef set<ii> sii;\ntypedef set<iii> siii;\n\nll gcd(ll a, ll b){ return b==0?a:gcd(b,a%b);}\n\nll add(ll a, ll b, ll m = MOD){\n\tif(a >= m) a %= m;\n\tif(b >= m) b %= m;\n\tif(a < 0) a += m;\n\tif(b < 0) b += m;\n\tll res = a+b;\n\tif(res >= m or res <= -m) res %= m;\n\tif(res < 0) res += m;\n\treturn res;\n}\n\nll mul(ll a, ll b, ll m = MOD){\n\tif(a >= m) a %= m;\n\tif(b >= m) b %= m;\n\tif(a < 0) a += m;\n\tif(b < 0) b += m;\n\tll res = a*b;\n\tif(res >= m or res <= -m) res %= m;\n\tif(res < 0) res += m;\n\treturn res;\n}\n\nll pow_mod(ll a, ll b, ll m = MOD){\n\tll res = 1LL;\n\ta = a%m;\n\twhile(b){\n\t\tif(b&1) res = mul(res,a,m);\n\t\tb >>= 1;\n\t\ta = mul(a,a,m);\n\t}\n\treturn res;\n}\n\nll fastexp(ll a, ll b){\n\tll res = 1LL;\n\twhile(b){\n\t\tif(b&1) res = res*a;\n\t\tb >>= 1;\n\t\ta *= a;\n\t}\n\treturn res;\n}\n\nint gcdExtendido(int a, int b, int *x, int *y){\n\tif(a == 0){\n\t\t*x = 0;\n\t\t*y = 1;\n\t\treturn b;\n\t}\n\tint x1, y1;\n\tint gcd = gcdExtendido(b%a,a,&x1,&y1);\n\t\n\t*x = y1-(b/a)*x1;\n\t*y = x1;\n\treturn gcd;\n}\n\nint modInverso(int a, int m){\n\tint x, y;\n\tint g = gcdExtendido(a,m,&x,&y);\n\tif(g!=1) return -1;\n\telse return (x%m + m)%m;\n}\n\n/****************************************\n*************P*L*A*N*T*I*L*L*A************\n*****************************************/\n\nconst int N = 100000+5;\n\nint S;\nint frec[N];\nvi divisors;\n\nll f(int x){\n\treturn 1LL * x * (x + 1) / 2LL;\n}\n\nbool find(int x, int limit){\n\tll prefix = 1LL * limit * (limit + 1) / 2LL;\n\tint lo = 0, hi = limit - 1;\n\twhile(lo < hi){\n\t\tint mi = lo + (hi - lo + 1) / 2;\n\t\tif(prefix - f(mi) < x) hi = mi-1;\n\t\telse lo = mi;\n\t}\n\treturn prefix - f(lo) == x;\n}\n\nint main(){\n\tri(S);\n\tfor(int i=1; i * i <= S; i++){\n\t\tif(S % i == 0){\n\t\t\tdivisors.emplace_back(i);\n\t\t\tif(i * i != S) divisors.emplace_back(S / i);\n\t\t}\n\t}\n\tfor(int i=1; i <= S; i++){\n\t\tfor(int d : divisors){\n\t\t\tfrec[d] += find(d, i);\n\t\t}\n\t}\n\tll ans = 0LL;\n\tfor(int d : divisors){\n\t\tans += 1LL * frec[d] * frec[S / d];\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\nusing namespace std;\nint S;\nmain()\n{\n\tcin>>S;\n\tmap<int,int>M;\n\tfor(int i=1;i<=S;i++)\n\t{\n\t\tint t=i;\n\t\tfor(int j=i;j<=S;j+=++t)M[j]++;\n\t}\n\tlong ans=0;\n\tfor(int i=1;i<=S;i++)\n\t{\n\t\tif(S%i==0)\n\t\t{\n\t\t\tans+=1L*M[i]*M[S/i];\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define FOR(i, m, n) for (int i = (m); i < (n); ++i)\n#define rrep(i, n) for (int i = (n) - 1; i >= 0; --i)\n#define rfor(i, m, n) for (int i = (m); i >= (n); --i)\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n#define range_it(a, l, r) (a).begin() + (l), (a).begin() + (r)\n\nusing namespace std;\nusing ll = long long;\t\tusing ld = long double;\nusing VB = vector<bool>;\tusing VVB = vector<VB>;\nusing VI = vector<int>;\t\tusing VVI = vector<VI>;\nusing VL = vector<ll>;\t\tusing VVL = vector<VL>;\nusing VS = vector<string>;\tusing VD = vector<ld>;\nusing PII = pair<int, int>;\tusing VP = vector<PII>;\nusing PLL = pair<ll, ll>;\tusing VPL = vector<PLL>;\ntemplate<class T>using PQ = priority_queue<T>;\ntemplate<class T>using PQS = priority_queue<T, vector<T>, greater<T>>;\nconstexpr int inf = (int)1e9;\nconstexpr ll inf_ll = (ll)1e18, MOD = 1000000007;\nconstexpr ld PI = M_PI, EPS = 1e-12;\n\n// --- input --- //\n#ifdef _WIN32\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#define fwrite_unlocked fwrite\n#define fflush_unlocked _fflush_nolock\n#endif\ninline int gc() { return getchar_unlocked(); }\ntemplate<class T>inline void InputF(T& v) { cin >> v; }\ninline void InputF(char& v) { while (isspace(v = gc())); }\ninline void InputF(bool& v) { char c; InputF(c); v = c != '0'; }\ninline void InputF(string& v) {\n\tv.clear(); char c; for (InputF(c); !isspace(c); c = gc())v += c;\n}\ninline void InputF(int& v) {\n\tbool neg = false; v = 0; char c; InputF(c);\n\tif (c == '-') { neg = true; c = gc(); }\n\tfor (; isdigit(c); c = gc())v = v * 10 + (c - '0');\n\tif (neg)v = -v;\n}\ninline void InputF(long long& v) {\n\tbool neg = false; v = 0; char c; InputF(c);\n\tif (c == '-') { neg = true; c = gc(); }\n\tfor (; isdigit(c); c = gc())v = v * 10 + (c - '0');\n\tif (neg)v = -v;\n}\ninline void InputF(double& v) {\n\tdouble dp = 1; bool neg = false, adp = false; v = 0; char c; InputF(c);\n\tif (c == '-') { neg = true; c = gc(); }\n\tfor (; isdigit(c) || c == '.'; c = gc()) {\n\t\tif (c == '.')adp = true;\n\t\telse if (adp)v += (c - '0') * (dp *= 0.1);\n\t\telse v = v * 10 + (c - '0');\n\t}\n\tif (neg)v = -v;\n}\ntemplate<class T, class U>inline void InputF(pair<T, U>& v) {\n\tInputF(v.first); InputF(v.second);\n}\ntemplate<class T>inline void InputF(vector<T>& v) {\n\tfor (auto& e : v)InputF(e);\n}\ntemplate<class T>inline T InputF() { T v; InputF(v); return v; }\ninline string GetLine() {\n\tstring v; char c; for (InputF(c); c != '\\n' && c != '\\0'; c = gc())v += c; return v;\n}\nstruct InputV {\n\tint n, m;\n\tInputV(int N) :n(N), m(0) {}\n\tInputV(pair<int, int> N) :n(N.first), m(N.second) {}\n\ttemplate<class T>operator vector<T>() {\n\t\tvector<T> v(n); InputF(v); return v;\n\t}\n\ttemplate<class T>operator vector<vector<T>>() {\n\t\tvector<vector<T>> v(n, vector<T>(m)); InputF(v); return v;\n\t}\n};\nstruct Input {\n\ttemplate<class T>operator T() { return InputF<T>(); }\n\tint operator--(int) { int v; InputF(v); v--; return v; }\n\tInputV operator[](int n) { return InputV(n); }\n\tInputV operator[](pair<int, int> n) { return InputV(n); }\n\tvoid operator()() {}\n\ttemplate<class H, class...T>void operator()(H&& h, T&& ...t) {\n\t\tInputF(h); operator()(forward<T>(t)...);\n\t}\n\ttemplate<class T>Input& operator,(T&& v) {\n\t\tInputF(v); return *this;\n\t}\n}in;\n#define input(T) InputF<T>()\n#define ini input(int)\n#define inl input(ll)\n#define ins input(string)\n#define inputs(T, ...) T __VA_ARGS__; in(__VA_ARGS__)\n#define INT(...) inputs(int, __VA_ARGS__)\n#define LL(...) inputs(ll, __VA_ARGS__)\n#define STR(...) inputs(string, __VA_ARGS__)\n\n// --- output --- //\nstruct BoolStr {\n\tconst char* t, * f; BoolStr(const char* _t, const char* _f) :t(_t), f(_f) {}\n}Yes(\"Yes\", \"No\"), yes(\"yes\", \"no\"), YES(\"YES\", \"NO\"), Int(\"1\", \"0\");\nstruct DivStr {\n\tconst char* d, * l; DivStr(const char* _d, const char* _l) :d(_d), l(_l) {}\n}spc(\" \", \"\\n\"), no_spc(\"\", \"\\n\"), end_line(\"\\n\", \"\\n\"), comma(\",\", \"\\n\"), no_endl(\" \", \"\");\nclass Output {\n\tBoolStr B{ Yes }; DivStr D{ spc };\n\tvoid p(int v) {\n\t\tif (v < 0)putchar_unlocked('-'), v = -v;\n\t\tchar b[10]; int i = 0;\n\t\twhile (v)b[i++] = '0' + v % 10, v /= 10;\n\t\tif (!i)b[i++] = '0';\n\t\twhile (i--)putchar_unlocked(b[i]);\n\t}\n\tvoid p(ll v) {\n\t\tif (v < 0)putchar_unlocked('-'), v = -v;\n\t\tchar b[20]; int i = 0;\n\t\twhile (v)b[i++] = '0' + v % 10, v /= 10;\n\t\tif (!i)b[i++] = '0';\n\t\twhile (i--)putchar_unlocked(b[i]);\n\t}\n\tvoid p(bool v) { p(v ? B.t : B.f); }\n\tvoid p(char v) { putchar_unlocked(v); }\n\tvoid p(const char* v) { fwrite_unlocked(v, 1, strlen(v), stdout); }\n\tvoid p(double v) { printf(\"%.20f\", v); }\n\tvoid p(ld v) { printf(\"%.20Lf\", v); }\n\ttemplate<class T> void p(const T& v) { cout << v; }\n\ttemplate<class T, class U>void p(const pair<T, U>& v) { p(v.first); p(D.d); p(v.second); }\n\ttemplate<class T>void p(const vector<T>& v) { rep(i, sz(v)) { if (i)p(D.d); p(v[i]); } }\n\ttemplate<class T>void p(const vector<vector<T>>& v) { rep(i, sz(v)) { if (i)p(D.l); p(v[i]); } }\npublic:\n\tOutput& operator()() { p(D.l); return *this; }\n\ttemplate<class H>Output& operator()(H&& h) { p(h); p(D.l); return *this; }\n\ttemplate<class H, class...T>Output& operator()(H&& h, T&& ...t) {\n\t\tp(h); p(D.d); return operator()(forward<T>(t)...);\n\t}\n\ttemplate<class...T>void exit(T&& ...t) { operator()(forward<T>(t)...); std::exit(EXIT_SUCCESS); }\n\tOutput& flush() { fflush_unlocked(stdout); return *this; }\n\tOutput& set(const BoolStr& b) { B = b; return *this; }\n\tOutput& set(const DivStr& d) { D = d; return *this; }\n\tOutput& set(const char* t, const char* f) { B = BoolStr(t, f); return *this; }\n}out;\n\n// --- step --- //\ntemplate<class T>struct Step {\n\tclass It {\n\t\tT a, b, c;\n\tpublic:\n\t\tconstexpr It() : a(T()), b(T()), c(T()) {}\n\t\tconstexpr It(T _b, T _c, T _s) : a(_b), b(_c), c(_s) {}\n\t\tconstexpr It& operator++() { --b; a += c; return *this; }\n\t\tconstexpr It operator++(int) { It tmp = *this; --b; a += c; return tmp; }\n\t\tconstexpr const T& operator*()const { return a; }\n\t\tconstexpr const T* operator->()const { return &a; }\n\t\tconstexpr bool operator==(const It& i)const { return b == i.b; }\n\t\tconstexpr bool operator!=(const It& i)const { return !(b == i.b); }\n\t\tconstexpr T start()const { return a; }\n\t\tconstexpr T count()const { return b; }\n\t\tconstexpr T step()const { return c; }\n\t};\n\tconstexpr Step(T b, T c, T s) : be(b, c, s) {}\n\tconstexpr It begin()const { return be; }\n\tconstexpr It end()const { return en; }\n\tconstexpr T start()const { return be.start(); }\n\tconstexpr T count()const { return be.count(); }\n\tconstexpr T step()const { return be.step(); }\n\tconstexpr T sum()const { return start() * count() + step() * (count() * (count() - 1) / 2); }\n\toperator vector<T>()const { return as_vector(); }\n\tvector<T> as_vector()const {\n\t\tvector<T> res; res.reserve(count()); each([&](T i) {res.push_back(i); }); return res;\n\t}\n\ttemplate<class F>void each(const F& f)const { for (T i : *this)f(i); }\n\ttemplate<class F>auto map(const F& f)const {\n\t\tvector<decay_t<result_of_t<F(T)>>> res; res.reserve(count());\n\t\teach([&](T i) {res.push_back(f(i)); }); return res;\n\t}\n\ttemplate<class F>int count_if(const F& f)const {\n\t\tint res = 0; each([&](T i) {res += static_cast<bool>(f(i)); }); return res;\n\t}\n\ttemplate<class F>vector<T> select(const F& f)const {\n\t\tvector<T> res; each([&](T i) {if (f(i))res.push_back(i); }); return res;\n\t}\n\ttemplate<class F>auto max(const F& f)const {\n\t\tauto v = map(f); return *max_element(v.begin(), v.end());\n\t}\n\ttemplate<class F>auto min(const F& f)const {\n\t\tauto v = map(f); return *min_element(v.begin(), v.end());\n\t}\n\ttemplate<class F, class U = decay_t<result_of_t<F(T)>>>auto sum(const F& f)const {\n\t\tU res = 0; each([&](T i) {res += static_cast<U>(f(i)); }); return res;\n\t}\n\tusing value_type = T;\n\tusing iterator = It;\nprivate:\n\tIt be, en;\n};\ntemplate<class T>inline constexpr auto step(T a) { return Step<T>(0, a, 1); }\ntemplate<class T>inline constexpr auto step(T a, T b) { return Step<T>(a, b - a, 1); }\ntemplate<class T>inline constexpr auto step(T a, T b, T c) { return Step<T>(a, a < b ? (b - a - 1) / c + 1 : 0, c); }\n\n// --- functions --- //\ninline namespace {\n\ttemplate<class T>inline void Sort(T& a) { sort(all(a)); }\n\ttemplate<class T>inline void RSort(T& a) { sort(rall(a)); }\n\ttemplate<class T>inline T Sorted(T a) { Sort(a); return a; }\n\ttemplate<class T>inline T RSorted(T a) { RSort(a); return a; }\n\ttemplate<class T, class F>inline void Sort(T& a, const F& f) {\n\t\tsort(all(a), [&](const auto& x, const auto& y) {return f(x) < f(y); });\n\t}\n\ttemplate<class T, class F>inline void RSort(T& a, const F& f) {\n\t\tsort(rall(a), [&](const auto& x, const auto& y) {return f(x) < f(y); });\n\t}\n\ttemplate<class T>inline void Reverse(T& a) { reverse(all(a)); }\n\ttemplate<class T>inline void Unique(T& a) { a.erase(unique(all(a)), a.end()); }\n\ttemplate<class T>inline void Rotate(T& a, int left) { rotate(a.begin(), a.begin() + left, a.end()); }\n\ttemplate<class T>inline T Reversed(T a) { Reverse(a); return a; }\n\ttemplate<class T>inline T Uniqued(T a) { Unique(a); return a; }\n\ttemplate<class T>inline T Rotated(T a, int left) { Rotate(a, left); return a; }\n\ttemplate<class T>inline auto Max(const T& a) { return *max_element(all(a)); }\n\ttemplate<class T>inline auto Min(const T& a) { return *min_element(all(a)); }\n\ttemplate<class T>inline int MaxPos(const T& a) { return max_element(all(a)) - a.begin(); }\n\ttemplate<class T>inline int MinPos(const T& a) { return min_element(all(a)) - a.begin(); }\n\ttemplate<class T, class F>inline auto Max(const T& a, const F& f) {\n\t\treturn *max_element(all(a), [&](const auto& x, const auto& y) {return f(x) < f(y); });\n\t}\n\ttemplate<class T, class F>inline auto Min(const T& a, const F& f) {\n\t\treturn *min_element(all(a), [&](const auto& x, const auto& y) {return f(x) < f(y); });\n\t}\n\ttemplate<class T, class U>inline int Count(const T& a, const U& v) { return count(all(a), v); }\n\ttemplate<class T, class F>inline int CountIf(const T& a, const F& f) { return count_if(all(a), f); }\n\ttemplate<class T, class U>inline int Find(const T& a, const U& v) { return find(all(a), v) - a.begin(); }\n\ttemplate<class T, class F>inline int FindIf(const T& a, const F& f) { return find_if(all(a), f) - a.begin(); }\n\ttemplate<class T, class U = typename T::value_type>inline U Sum(const T& a) { return accumulate(all(a), U()); }\n\ttemplate<class T, class F>inline auto Sum(const T& v, const F& f) {\n\t\treturn accumulate(next(v.begin()), v.end(), f(v.front()), [&](auto a, auto b) {return a + f(b); });\n\t}\n\ttemplate<class T, class U>inline int Lower(const T& a, const U& v) { return lower_bound(all(a), v) - a.begin(); }\n\ttemplate<class T, class U>inline int Upper(const T& a, const U& v) { return upper_bound(all(a), v) - a.begin(); }\n\ttemplate<class T, class F>inline void RemoveIf(T& a, const F& f) { a.erase(remove_if(all(a), f), a.end()); }\n\ttemplate<class F>inline auto Vector(size_t size, const F& f) {\n\t\tvector<decay_t<result_of_t<F(size_t)>>> res(size); for (size_t i = 0; i < size; ++i)res[i] = f(i); return res;\n\t}\n\ttemplate<class T>inline auto Grid(size_t h, size_t w, const T& v = T()) { return vector<vector<T>>(h, vector<T>(w, v)); }\n\ttemplate<class T>inline auto Slice(const T& v, size_t i, size_t len) {\n\t\treturn i < v.size() ? T(v.begin() + i, v.begin() + min(i + len, v.size())) : T();\n\t}\n\ttemplate<class T, class F>inline auto Each(const T& v, const F& f) { for (auto& i : v)f(i); }\n\ttemplate<class T, class F>inline auto Select(const T& v, const F& f) {\n\t\tT res; for (const auto& e : v)if (f(e))res.push_back(e); return res;\n\t}\n\ttemplate<class T, class F>inline auto Map(const T& v, const F& f) {\n\t\tvector<decay_t<result_of_t<F(typename T::value_type)>>> res(v.size());\n\t\tsize_t i = 0; for (const auto& e : v)res[i++] = f(e); return res;\n\t}\n\ttemplate<class T, class F>inline auto MapIndex(const T& v, const F& f) {\n\t\tvector<decay_t<result_of_t<F(size_t, typename T::value_type)>>> res(v.size());\n\t\tsize_t i = 0; for (auto it = v.begin(); it != v.end(); ++it, ++i)res[i] = f(i, *it); return res;\n\t}\n\ttemplate<class T, class F>inline auto TrueIndex(const T& v, const F& f) {\n\t\tvector<size_t> res; for (size_t i = 0; i < v.size(); ++i)if (f(v[i]))res.push_back(i); return res;\n\t}\n\tinline string operator*(string s, size_t n) { string ret; for (size_t i = 0; i < n; ++i)ret += s; return ret; }\n\ttemplate<class T>inline T Ceil(T n, T m) { return (n + m - 1) / m; }\n\ttemplate<class T>inline T Ceil2(T n, T m) { return Ceil(n, m) * m; }\n\ttemplate<class T>inline T Tri(T n) { return (n & 1) ? (n + 1) / 2 * n : n / 2 * (n + 1); }\n\ttemplate<class T>inline T nC2(T n) { return (n & 1) ? (n - 1) / 2 * n : n / 2 * (n - 1); }\n\ttemplate<class T>inline T Mid(const T& l, const T& r) { return l + (r - l) / 2; }\n\tinline int pop_count(int n) { return bitset<32>(n).count(); }\n\tinline int pop_count(ll n) { return bitset<64>(n).count(); }\n\ttemplate<class T>inline bool chmax(T& a, const T& b) { if (a < b) { a = b; return true; } return false; }\n\ttemplate<class T>inline bool chmin(T& a, const T& b) { if (a > b) { a = b; return true; } return false; }\n\ttemplate<class T>inline bool inRange(const T& v, const T& min, const T& max) { return min <= v && v < max; }\n\ttemplate<class T = ll>inline T BIT(int b) { return T(1) << b; }\n\ttemplate<class T>inline T Gcd(T n, T m) { return m ? Gcd(m, n % m) : n; }\n\ttemplate<class T>inline T Lcm(T n, T m) { return n / Gcd(n, m) * m; }\n\ttemplate<class T, class U = typename T::value_type>inline U Gcdv(const T& v) {\n\t\treturn accumulate(next(v.begin()), v.end(), U(*v.begin()), Gcd<U>);\n\t}\n\ttemplate<class T, class U = typename T::value_type>inline U Lcmv(const T& v) {\n\t\treturn accumulate(next(v.begin()), v.end(), U(*v.begin()), Lcm<U>);\n\t}\n\ttemplate<class T>inline T Pow(T a, T n) { T r = 1; while (n > 0) { if (n & 1)r *= a; a *= a; n /= 2; } return r; }\n\ttemplate<class T>inline T Powmod(T a, T n, T m = MOD) {\n\t\tT r = 1; while (n > 0) { if (n & 1)r = r * a % m, n--; else a = a * a % m, n /= 2; }return r;\n\t}\n}\n\n// --- dump --- //\n#if __has_include(\"dump.hpp\")\n#include \"dump.hpp\"\n#else\n#define dump(...) ((void)0)\n#endif\n\n// ---------------------------------------------------------------- //\n\ntemplate<class T>vector<T> Divisor(T n) {\n\tassert(0 < n);\n\tvector<T> res; T m = 1;\n\tfor (; m * m < n; ++m)\n\t\tif (n % m == 0)res.push_back(m);\n\tbool flag = m * m == n;\n\tif (flag)res.push_back(m);\n\tfor (int i = res.size() - 1 - flag; i >= 0; --i)\n\t\tres.push_back(n / res[i]);\n\treturn res;\n}\ntemplate<class T>vector<pair<T, T>> DivisorPair(T n) {\n\tassert(0 < n);\n\tvector<pair<T, T>> res;\n\tfor (T i = 1; i * i <= n; ++i)\n\t\tif (n % i == 0)res.emplace_back(i, n / i);\n\tfor (int i = res.size() - 1 - (res.back().first == res.back().second); i >= 0; --i)\n\t\tres.emplace_back(res[i].second, res[i].first);\n\treturn res;\n}\ntemplate<class T>int DivCnt(T n) {\n\tassert(0 < n);\n\tint cnt = 0; T sq = (T)sqrt(n);\n\tfor (T i = 1; i <= sq; ++i)cnt += (n % i == 0);\n\treturn cnt * 2 - (sq * sq == n);\n}\ntemplate<class T>T DivSum(T n) {\n\tassert(0 < n);\n\tT i = 1, res = 0;\n\tfor (; i * i < n; ++i)if (n % i == 0)res += i + n / i;\n\treturn res + i * (i * i == n);\n}\n\nll calc_num(ll s) {\n\ts *= 2;\n\tll res = 0;\n\tfor (ll m : Divisor(s)) {\n\t\tll n = s / m;\n\t\tif (n < m)break;\n\t\tll y = (n + m - 1) / 2;\n\t\tll x = n - y;\n\t\tif ((n + m - 1) % 2 == 0 && 0 < x && 0 < y && x <= y)\n\t\t\tres++;\n\t}\n\treturn res;\n}\n\nint main() {\n\tint n = in;\n\tll ans = 0;\n\tfor (ll d : Divisor(n)) {\n\t\tll d2 = n / d;\n\t\tans += calc_num(d) * calc_num(d2);\n\t}\n\tout(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#if __has_include(\"../library/Basic/Debug.hpp\")\n\n#include \"../library/Basic/Debug.hpp\"\n\n#else\n\n/* ----- Header Files ----- */\n// IO\n#include <cstdio>\n#include <iomanip>\n#include <ios>\n#include <iostream>\n\n// algorithm\n#include <algorithm>\n#include <cmath>\n#include <numeric>\n\n// container\n#include <vector>\n#include <string>\n#include <tuple>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n\n// others\n#include <random>\n#include <limits>\n#include <functional>\n#include <ctime>\n#include <cassert>\n#include <cstdint>\n\n\n/* ----- Type Alias ----- */\nusing Int = long long int;\nusing Real = long double;\nusing String = std::string;\ntemplate <class... Ts>\nusing Tuple = std::tuple<Ts...>;\n\ntemplate <class T>\nusing Vector = std::vector<T>;\ntemplate <class T>\nusing Queue = std::queue<T>;\ntemplate <class T>\nusing Stack = std::stack<T>;\ntemplate <class T>\nusing Deque = std::deque<T>;\n\ntemplate <class T>\nusing MaxHeap = std::priority_queue<T>;\ntemplate <class T>\nusing MinHeap = std::priority_queue<T, std::vector<T>, std::greater<T>>;\ntemplate <class T>\nusing Set = std::set<T>;\ntemplate <class T, class U>\nusing Map = std::map<T, U>;\n\ntemplate <class T, class... Us>\nusing Func = std::function<T(Us...)>;\n\ntemplate <class T>\nT genv(T v) { return v; }\n\ntemplate <class T, class... Ts>\nauto genv(size_t l, Ts... ts) {\n    return Vector<decltype(genv<T>(ts...))>(l, Vector<T>(ts...));\n}\n\ntemplate <class Cost = Int>\nstruct Edge {\n    Int src, dst;\n    Cost cost;\n    Edge(Int src = -1, Int dst = -1, Cost cost = 1)\n        : src(src), dst(dst), cost(cost){};\n\n    bool operator<(const Edge<Cost>& e) const { return this->cost < e.cost; }\n    bool operator>(const Edge<Cost>& e) const { return this->cost > e.cost; }\n};\n\ntemplate <class Cost = Int>\nusing Edges = Vector<Edge<Cost>>;\ntemplate <class Cost = Int>\nusing Graph = Vector<Vector<Edge<Cost>>>;\n\n#endif\n\n/* ----- Misc ----- */\nvoid fastio() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n}\n\nstruct Fout {\n    Int precision;\n    Fout(Int precision) : precision(precision) {}\n};\nstd::ostream& operator<<(std::ostream& os, const Fout& fio) {\n    os << std::fixed << std::setprecision(fio.precision);\n    return os;\n}\n\n\n/* ----- Constants ----- */\n// constexpr Int INF = std::numeric_limits<Int>::max() / 3;\n// constexpr Int MOD = 1000000007;\n// constexpr Real PI = acos(-1);\n// constexpr Real EPS = 1e-10;\n// std::mt19937 mt(int(std::time(nullptr)));\n\nint main() {\n    Int s;\n    std::cin >> s;\n\n    Vector<Int> sum(s + 1);\n    sum[0] = 0;\n    for (Int i = 1; i <= s; ++i) {\n        sum[i] = sum[i - 1] + i;\n    }\n\n    Int ans = 0;\n    for (Int x = 1; x * x <= s; ++x) {\n        if (s % x != 0) continue;\n\n        Vector<Int> d({x, s / x});\n        Int pat = 1;\n        for (auto a : d) {\n            Int cnt = 0;\n            for (Int i = 0; i < s; ++i) {\n                Int r = a + sum[i];\n                if (*std::lower_bound(sum.begin(), sum.end(), r) == r) ++cnt;\n            }\n            pat *= cnt;\n        }\n\n        if (x * x != s) pat *= 2;\n        ans += pat;\n    }\n\n    std::cout << ans << std::endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#pragma warning(disable:4996)\nusing namespace std;\n\nvector<long long int> divisor(long long int n) {\n\tvector<long long int> res;\n\tfor (long long int i = 1; i * i <= n; ++i) {\n\t\tif (n % i == 0) {\n\t\t\tres.push_back(i);\n\t\t\tif (i * i != n) res.push_back(n / i);\n\t\t}\n\t}\n\tsort(begin(res), end(res));\n\treturn res;\n}\n\nint main() {\n\tint S; cin >> S;\n\tS *= 4;\n\tint ans=0;\n\tfor (int h = 1; h <= 1000; ++h) {\n\t\tint min_row_sum=h*h/2+1;\n\t\tfor (int w = 1; w < S / min_row_sum + 2; ++w) {\n\t\t\tif (S % (w*h)==0) {\n\t\t\t\tint cent_num=S/h/w;\n\n\t\t\t\tauto divs(divisor(cent_num));\n\n\t\t\t\tfor (int y_id = 0; y_id< divs.size(); ++y_id) {\n\t\t\t\t\tint x_id=divs.size()-1-y_id;\n\n\t\t\t\t\tconst int y=divs[y_id];\n\t\t\t\t\tconst int x=divs[x_id];\n\n\t\t\t\t\tif(y%2==h%2)continue;\n\t\t\t\t\tif(x%2==w%2)continue;\n\n\t\t\t\t\tif(h>y)continue;\n\t\t\t\t\tif(w>x)continue;\n\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n} \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define SZ(x) (int)(x.size())\n#define REP(i, n) for(int i=0;i<(n);++i)\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RREP(i, n) for(int i=(int)(n);i>=0;--i)\n#define RFOR(i, a, b) for(int i=(int)(a);i>=(int)(b);--i)\n#define ALL(a) (a).begin(),(a).end()\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define DEBUG(x) cerr<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<< endl;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing P = pair<int, int>;\n\nconst double eps = 1e-8;\nconst ll MOD = 1000000007;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\n\ntemplate <typename T1, typename T2>\nbool chmax(T1 &a, const T2 &b) {\n  if(a < b) {a = b; return true;}\n  return false;\n}\n\ntemplate <typename T1, typename T2>\nbool chmin(T1 &a, const T2 &b) {\n  if(a > b) {a = b; return true;}\n  return false;\n}\n\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream &os, const pair<T1, T2> p) {\n  os << p.first << \":\" << p.second;\n  return os;\n}\n\ntemplate<class T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n  REP(i, SZ(v)) {\n    if(i) os << \" \";\n    os << v[i];\n  }\n  return os;\n}\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n\n  int s; cin >> s;\n  int sz = 1000000;\n  vll a(sz+1);\n  REP(i, sz) {\n    a[i+1] = a[i] + i + 1;\n  }\n\n  vll yaku = {1};\n  for(ll i=2;i*i<=s;++i) {\n    if(s % i == 0) {\n      yaku.push_back(i);\n      if(i * i != s) yaku.push_back(s/i);\n    }\n  }\n  yaku.push_back(s);\n\n  map<ll, ll> mp;\n  REP(i, SZ(yaku)) {\n    ll k = yaku[i];\n    ll cnt = 0;\n    for(auto it=a.begin();it!=a.end();++it) {\n      //if(*it < 100) cout << *it << endl;\n      auto it2 = lower_bound(it, a.end(), *it+k);\n      if(it2 != a.end() && *it2 == *it + k) {\n        cnt++;\n      }\n    }\n    mp[k] = cnt;\n  }\n\n  ll ans = 0;\n  map<ll, bool> sel;\n  for(auto &e: mp) {\n    ans += e.second * mp[s/e.first];\n  }\n  cout << ans << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nusing ll = long long int;\n\nint main() {\n    int S; cin >> S;\n\n    int ans = 0;\n    for(ll i=1; i<=S; i++) {\n        for(ll j=1; i*j<=S; j++) {\n            ll sum = 0;\n\n            // [i, k], [j, ?]\n            for(ll k=i; sum+k*j<=S; sum += k*j, k++) {\n                ll nsum = sum + k * j;\n                ll base = k*(k+1)/2 - i*(i-1)/2;\n\n                ll ub = S, lb = j-1;\n                while(ub - lb > 1) {\n                    ll mid = (ub + lb) / 2;\n                    ll val = nsum * (mid - j + 1) + base * (mid - j) * (mid - j + 1) / 2;\n                    if(val >= S) ub = mid;\n                    else lb = mid;\n                }\n\n                ll val = nsum * (ub - j + 1) + base * (ub - j) * (ub - j + 1) / 2;\n                if(val == S) {\n                    ans++;\n                }\n            }\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n\nsigned main(){\n  int s;\n  cin>>s;\n  int ans=0;\n  for(int i=1;i*i<=s;i++){\n    if(s%i)continue;\n    int p=s/i,q=i;\n    int l=1,r=1,sum=0,cnt1=0,cnt2=0;\n    for(;l<=p;l++){\n      for(;;r++){\n\tif(sum>=p)break;\n\tsum+=r;\n      }\n      if(sum==p)cnt1++;\n      sum-=l;\n    }\n    l=1,r=1,sum=0;\n    for(;l<=q;l++){\n      for(;;r++){\n\tif(sum>=q)break;\n\tsum+=r;\n      }\n      if(sum==q)cnt2++;\n      sum-=l;\n    }\n    ans+=cnt1*cnt2*(i*i==s?1:2);\n  }\n  cout<<ans<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-11;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nint main(){\n\tll n,res=0;\n\tcin>>n;\n\tmap<ll,ll> mp;\n\tvl a;\n\tfor(ll i=1;i<=n;i++) for(ll j=i;(i+j)*(j-i+1)/2<=n;j++){\n\t\tll t=(i+j)*(j-i+1)/2;\n\t\tmp[t]++;\n\t\ta.push_back(t);\n\t}\n\tfor(auto i:a) if(n%i==0) res+=mp[n/i];\n\tcout<<res<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\n\nint x;\nint ada[300005];\n\nvoid pre(){\n\tfor(int i=1;i<=100000;i++){\n\t\tint tmp = 0;\n\t\tint idx = -1;\n\t\tfor(int j=i;tmp<=100000;j++){\n\t\t\ttmp+=j;\n\t\t\tada[tmp]++;\n\t\t\tidx = j;\n//\t\t\tif(i>=3663) cout << tmp << endl;\n\t\t}\n//\t\tcout << i << \" \" << idx << endl;\n\t}\n\treturn;\n}\n\nint main(){\n\tpre();\n\tscanf(\"%d\",&x);\n\tLL ans = 0;\n\tfor(int i=1;i*i<=x;i++){\n\t\tif(x%i == 0){\n\t\t\tint cur = i;\n\t\t\tint bagi = x/i;\n\t\t\tans += (LL)(ada[cur])*(LL)(ada[bagi]);\n\t\t\tif(i*i==x) continue;\n\t\t\tans += (LL)(ada[cur])*(LL)(ada[bagi]);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nsigned main(){\n\n  int S;\n  int ans = 0, con = 0;\n  map<int,int> mp;\n  \n  cin>>S;\n\n  for(int i = 1; i <= S; i++){\n    for(int j = i, sum = i; sum <= S; j++){\n      mp[sum]++;\n      // cout<<\"i \"<<i<<\" j \"<<j<<\" \"<<sum<<endl;\n      sum += j+1;\n      \n      con++;\n    }\n  }\n\n  // cout<<con<<endl;\n\n   for(int i = 1; i <= S; i++){\n     if(S%i) continue;\n     int a = mp[i], b = mp[S/i];\n\n     // if(i == S/i) b--;\n\n      if(a < 0 || b < 0) continue;\n\n     ans += a * b;\n   }\n\n   cout<<ans<<endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(int)(a); (i)<(int)(b); ++(i))\n#define rFor(i, a, b) for(int (i)=(int)(a)-1; (i)>=(int)(b); --(i))\n#define rep(i, n) For((i), 0, (n))\n#define rrep(i, n) rFor((i), (n), 0)\n#define fi first\n#define se second\n#define double long double\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> pii;\ntypedef pair<lint, lint> pll;\ntemplate<class T> bool chmax(T &a, const T &b){if(a<b){a=b; return true;} return false;}\ntemplate<class T> bool chmin(T &a, const T &b){if(a>b){a=b; return true;} return false;}\ntemplate<class T> T div_floor(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>=0 ? a/b : (a+1)/b-1;\n}\ntemplate<class T> T div_ceil(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>0 ? (a-1)/b+1 : a/b;\n}\n\nconstexpr lint mod = 1e9+7;\nconstexpr lint INF = mod * mod;\nconstexpr int MAX = 200010;\n\nlint f(lint n){\n    n *= 2;\n    lint ret = 0;\n    for(lint s=1; s*s<n; ++s)if(n%s == 0){\n        lint t = n / s;\n        if(s%2 != t%2) ++ret;\n    }\n    return ret;\n}\n\nint main(){\n    lint s;\n    scanf(\"%lld\", &s);\n    lint ans = 0;\n    for(lint x=1; x*x<=s; ++x)if(s%x == 0){\n        lint tmp = f(x) * f(s/x);\n        ans += tmp * (x*x == s ? 1 : 2);\n    }\n    printf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n#define abs(a) max((a),-(a))\n\ntypedef long long LL;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n\nconst ll mod=1000000007;\nconst ll INF=mod*mod;\n\nint main(){\n  ll s;cin>>s;\n  vector<P> v;\n  for(ll i=1;i<=s;i++){\n    if(s%i==0){\n      v.push_back({i,s/i});\n    }\n  }\n  int len=v.size();int out=0;\n  for(ll i=1;i<=1000;i++){\n    for(ll j=1;j<=1000;j++){\n      rep(k,len){\n        ll le=v[k].first;ll ri=v[k].second;\n        le-=i*(i-1)/2;ri-=j*(j-1)/2;\n        if(le<=0||ri<=0||le%i||ri%j)continue;\n        out++;\n      }\n    }\n  }\n  cout<<out<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef long long int lli;\n\nint main(){\n\tint s;\n\tcin >> s;\n\tlli ans = 0;\n\tfor(int i=1; i<1000; i++){\n\t\tlli si = i *(i+1) /2;\n\t\tfor(int j=1; j<1000; j++){\n\t\t\tlli sj = j *(j+1) /2;\n\t\t\tif(si*sj > s) break;\n\t\t\tfor(int k=0; ; k++){\n\t\t\t\tlli curr = si*sj +k*sj*i;\n\t\t\t\tif(curr > s) break;\n\t\t\t\tif((s-curr) %((si+k*i)*j) == 0){\n\t\t\t\t\tans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=1000000007,MAX=10005,INF=1<<29;\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int N;cin>>N;\n    vector<int> cnt(N+1);\n    \n    for(int i=1;i<=N;i++){\n        for(int j=i;(i+j)*(j-i+1)/2<=N;j++){\n            cnt[(i+j)*(j-i+1)/2]++;\n        }\n    }\n    \n    ll ans=0;\n    \n    for(int i=1;i<=N;i++){\n        if(N%i==0) ans+=cnt[i]*cnt[N/i];\n    }\n    \n    cout<<ans<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"ctime\"\n\nusing namespace std;\n\nconstexpr long long int MOD = 1000000007;\n//constexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-12;\n\n//int N, M, K, T, H, W, L, R;\nlong long int N, M, K, T, H, W, L, R;\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\tint ans = 0;\n\tvector<int>dp(N + 1);\n\tfor (int i = 1; i <= N; i++) {\n\t\tfor (int j = 1; j <= i; j++) {\n\t\t\tint minus = j * (j - 1) / 2;\n\t\t\tif (minus >= i)break;\n\t\t\tif ((i - minus) % j)continue;\n\t\t\tdp[i]++;\n\t\t}\n\t}\n\tfor (int i = 1; i <= N; i++) {\n\t\tif (N%i)continue;\n\t\tans += dp[i] * dp[N / i];\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 100000\n\nll ruisekiwa[NUM+1];\nll table[NUM+1];\n\n\nint main(){\n\n\tfor(int i = 0; i <= NUM; i++){\n\t\ttable[i] = 0;\n\t}\n\n\truisekiwa[0] = 0;\n\truisekiwa[1] = 1;\n\n\tfor(int i = 2; i <= NUM; i++){\n\t\truisekiwa[i] = i;\n\t\truisekiwa[i] += ruisekiwa[i-1];\n\t}\n\n\tll left,right,mid,tmp;\n\tint max_add;\n\n\tfor(ll i = 1; i <= NUM; i++){\n\n\t\tleft = 0,right = NUM-i,mid = (left+right)/2;\n\n\t\twhile(left <= right){\n\t\t\ttmp = ruisekiwa[i+mid]-ruisekiwa[i-1];\n\n\t\t\tif(tmp <= NUM){\n\t\t\t\tmax_add = mid;\n\t\t\t\tleft = mid+1;\n\t\t\t}else{\n\t\t\t\tright = mid-1;\n\t\t\t}\n\t\t\tmid = (left+right)/2;\n\t\t}\n\n\t\tfor(int add = 0; add <= max_add; add++){\n\n\t\t\ttable[ruisekiwa[i+add]-ruisekiwa[i-1]]++;\n\t\t}\n\t}\n\n\tll S;\n\n\tscanf(\"%lld\",&S);\n\n\tll ans = 0;\n\n\tfor(ll i = 1; i <= S; i++){\n\t\tif(S%i != 0)continue;\n\n\t\tans += table[i]*table[S/i];\n\t}\n\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int s; cin >> s;\n    s *= 4;\n    vector<int> vs;\n    for(int i = 1; i <= s; ++i) {\n        if(s % i != 0) continue;\n        vs.push_back(i);\n    }\n    const int n = vs.size();\n    int ans = 0;\n    for(int i = 0; i < n; ++i) {\n        for(int j = 0; j < n; ++j) {\n            for(int k = 0; k < n; ++k) {\n                const int w = vs[i], x = vs[j], y = vs[k];\n                if(s % (w * x * y) != 0) continue;\n                const int z = s / w / x / y;\n                const int a = (w - x + 1) / 2, b = (w + x - 1) / 2;\n                const int c = (y - z + 1) / 2, d = (y + z - 1) / 2;\n                if(a <= 0 || b <= 0 || c <= 0 || d <= 0) continue;\n                ans += s == (b + a) * (b - a + 1) * (d + c) * (d - c + 1);\n            }\n        }\n    }\n\n    cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint main() {\n    ll s, ans = 0;\n    cin >> s;\n    s *= 4;  // s = (a+b)(b-a+1)(c+d)(d-c+1)/4\n    // 約数列挙\n    vector<int> divisor;\n    for(int i=1;i*i<=s;i++){\n        if(s%i==0){\n            divisor.push_back(i);\n            if(s/i != i) divisor.push_back(s/i);\n        }\n    }\n    sort(divisor.begin(), divisor.end());\n    for(auto x : divisor){\n        for(auto y : divisor){\n            if(s%(x*y)!=0 || (x+y)%2==0) continue;\n            if(x<y) break;\n            for(auto z : divisor){\n                if(s%(x*y*z)!=0) continue;\n                ll w = s/(x*y*z);\n                if((z+w)%2==0)continue;\n                if(z<w)continue;\n                ans++;\n            }\n        }\n    }\n    cout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\nsigned main(){\n\n  int S;\n  int ans = 0, con = 0;\n  map<int,int> mp;\n  \n  cin>>S;\n\n  for(int i = 1; i <= S; i++){\n    for(int j = i, sum = i; sum <= S; j++){\n      mp[sum]++;\n      // cout<<\"i \"<<i<<\" j \"<<j<<\" \"<<sum<<endl;\n      sum += j+1;\n      \n      con++;\n    }\n  }\n\n  // cout<<con<<endl;\n\n   for(int i = 1; i <= S; i++){\n     if(S%i) continue;\n     int a = mp[i], b = mp[S/i];\n\n     // if(i == S/i) b--;\n\n      if(a < 0 || b < 0) continue;\n\n     ans += a * b;\n   }\n\n   cout<<ans<<endl;\n\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nint main()\n{\n\tint S;\n\tcin >> S;\n\tvector<ll> cnt(S + 1);\n\tfor (int i = 1; i <= S; i++) if (S % i == 0) {\n\t\tfor (int j = 1; j <= i; j++) {\n\t\t\tif (j % 2 == 0) {\n\t\t\t\tif (i % j != 0 && i % (j >> 1) == 0) {\n\t\t\t\t\tint x = i / j + 1;\n\t\t\t\t\tif (1 <= x - (j >> 1)) {\n\t\t\t\t\t\t++cnt[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (i % j == 0) {\n\t\t\t\tint x = i / j;\n\t\t\t\tif (1 <= x - (j >> 1)) {\n\t\t\t\t\t++cnt[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tll res = 0;\n\tfor (int i = 1; i <= S; i++) if (S % i == 0) {\n\t\tres += cnt[i] * cnt[S / i];\n\t}\n\tcout << res << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  using ll = long long;\n\n  set< ll > st;\n  vector< ll > rs(100001, 0);\n  for (ll i = 0; i < rs.size(); ++i) {\n    st.insert(i * (i + 1));\n    rs[i] = i * (i + 1);\n  }\n\n  ll s;\n  cin >> s;\n\n  vector< ll > div;\n  for (ll i  = 1; i * i <= s; ++i) {\n    if (i * i == s) {\n      div.push_back(i);\n      continue;\n    }\n\n    if (s % i == 0) {\n      div.push_back(i);\n      div.push_back(s / i);\n    }\n  }\n\n  ll ans = 0;\n  for (auto d: div) {\n    ll rc = 0, lc = 0;\n    for (ll r = 1; r <= s; ++r) {\n      if (st.count(r * (r + 1) - 2 * d)) {\n\trc++;\n      }\n    }\n\n    int nd = s / d;\n    for (ll r = 1; r <= s; ++r) {\n      if (st.count(r * (r + 1) - 2 * nd)) {\n\tlc++;\n      }\n    }\n    \n    ans += lc * rc;\n  }\n\n  cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-11L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n\n#define MOD 998244353LL\n#define seg_size 262144*2LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\nunsigned long xor128() {\n\tstatic unsigned long x = 123456789, y = 362436069, z = 521288629, w = time(NULL);\n\tunsigned long t = (x ^ (x << 11));\n\tx = y; y = z; z = w;\n\treturn (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\n\nvoid init() {\n\tiostream::sync_with_stdio(false);\n\tcout << fixed << setprecision(20);\n}\n#define int ll\n\nvoid solve() {\n\tint s;\n\tcin >> s;\n\tmap<ll,ll> gogo;\n\tfor (int i = 1; i <= 100000; ++i) {\n\t\tll now = 0;\n\t\tfor (int q = i;; ++q) {\n\t\t\tnow += q;\n\t\t\tgogo[now]++;\n\t\t\tif (now > 1e5) break;\n\t\t}\n\t}\n\tll ans = 0;\n\tfor (int i = 1; i <= 100000; ++i) {\n\t\tll now = 0;\n\t\tfor (int q = i;; ++q) {\n\t\t\tnow += q;\n\t\t\tif (s % now == 0) {\n\t\t\t\tans += gogo[s / now];\n\t\t\t}\n\t\t\tif (now > 1e5) break;\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n\n#undef int\nint main() {\n\tinit();\n\tsolve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <stack>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <tuple>\n#include <assert.h>\n#include <deque>\n#include <bitset>\n#include <iomanip>\n#include <limits>\n#include <chrono>\n#include <random>\n#include <array>\n#include <unordered_map>\n#include <functional>\n#include <complex>\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\nconstexpr long long MAX = 5100000;\nconstexpr long long INF = 1LL << 60;\nconstexpr int inf = 1 << 28;\n//constexpr long long mod = 1000000007LL;\n//constexpr long long mod = 998244353LL;\n\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef long long ll;\n\n\nint main()\n{\n\t/*\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\t*/\n\n\tll S; scanf(\"%lld\", &S);\n\tvector<ll> cnt(S + 1);\n\tfor (int i = 1; i <= S; i++) {\n\t\tll sum = 0;\n\t\tfor (int j = i; j <= S; j++) {\n\t\t\tsum += j;\n\t\t\tif (sum > S) break;\n\t\t\tcnt[sum]++;\n\t\t}\n\t}\n\tll res = 0;\n\tfor (ll i = 1; i <= S; i++) {\n\t\tif (S % i != 0) continue;\n\t\t//cout << i << \" \" << cnt[i] << \" \" << S / i << \" \" << cnt[S / i] << endl;\n\t\tres += cnt[i] * cnt[S / i];\n\t}\n\tcout << res << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*  -*- coding: utf-8 -*-\n *\n * 2912.cc: Sum of QQ\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_S = 100000;\n\n/* typedef */\n\n/* global variables */\n\nint ps[500], cs[MAX_S + 1];\n\n/* subroutines */\n\nint countp(int k) {\n  int c = 0;\n  for (int i = 1; ps[i] <= k; i++)\n    if ((k - ps[i]) % i == 0) c++;\n  return c;\n}\n\n/* main */\n\nint main() {\n  int s;\n  scanf(\"%d\", &s);\n\n  int pn = 1;\n  while ((ps[pn] = pn * (pn + 1) / 2) <= s) pn++;\n  //printf(\"pn=%d:\", pn);\n  //for (int i = 1; i <= pn; i++) printf(\" %d\", ps[i]); putchar('\\n');\n\n  int cnt = 0;\n  for (int x = 1; x <= s; x++)\n    if (s % x == 0) {\n      int y = s / x;\n      if (! cs[x]) cs[x] = countp(x);\n      if (! cs[y]) cs[y] = countp(y);\n      cnt += cs[x] * cs[y];\n      //printf(\"(%d,%d) = %dx%d\\n\", x, y, cs[x], cs[y]);\n    }\n\n  printf(\"%d\\n\", cnt);\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n  int S;\n  cin >> S;\n  vector<long long> A(S + 1);\n  for (int i = 0; i <= S; i++){\n    A[i] = (long long) i * (i + 1) / 2;\n  }\n  int N = A.size();\n  map<int, int> mp;\n  for (int i = 1; i < N; i++){\n    for (int j = i - 1; j >= 0; j--){\n      int sum = A[i] - A[j];\n      if (sum <= S){\n        mp[sum]++;\n      } else {\n        break;\n      }\n    }\n  }\n  int ans = 0;\n  for (int i = 1; i <= S; i++){\n    if (S % i == 0){\n      ans += mp[i] * mp[S / i];\n    }\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    int s;\n    cin>>s;\n    map<int,int> mp;\n    for (int i = 1; i <= s; ++i) {\n        int ini=(1+i)*i/2;\n        if(ini*ini>s)break;\n        while(ini*ini<=s) {\n            //cout<<ini<<endl;\n            ++mp[ini];\n            ini+=i;\n        }\n    }\n    long long ans=0;\n    for(auto i:mp){\n        if(s%i.first==0){\n            for (int j = 1; j <= s/i.first; ++j) {//区間の長さ\n                int ini=(1+j)*j/2;\n                if(s/i.first<ini)break;\n                if((s/i.first-ini)%j==0){\n                    //cout<<i.first<<\" \"<<j<<endl;\n                    ans+=i.second;\n                    if(i.first*i.first!=s)ans+=i.second;\n                }\n            }\n        }\n    }\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int s;\n    cin >> s;\n    vector<int> v;\n    for (int i = 1; i * i <= s; ++i) {\n        if (s % i == 0) {\n            v.push_back(i);\n            if (i != s / i)\n                v.push_back(s / i);\n        }\n    }\n    sort(v.begin(), v.end());\n    vector<int> cnt(s + 1);\n    for (int i : v) {\n        int a = i * 2;\n        for (int j = 1; j * j <= a; ++j)\n            if (a % j == 0 && a / j % 2 != j % 2)\n                ++cnt[i];\n    }\n    int ans = 0;\n    for (int i : v) {\n        if (i > s / i) break;\n        ans += cnt[i] * cnt[s / i] * (i == s / i ? 1 : 2);\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//typedef\n//-------------------------#include <bits/stdc++.h>\n\nconst double pi = 3.141592653589793238462643383279;\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s)\n{\n  int v;\n  istringstream sin(s);\n  sin >> v;\n  return v;\n}\ntemplate <class T>\ninline string toString(T x)\n{\n  ostringstream sout;\n  sout << x;\n  return sout.str();\n}\ninline int readInt()\n{\n  int x;\n  scanf(\"%d\", &x);\n  return x;\n}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<long long, long long> PLL;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\n\n//container util\n\n//------------------------------------------\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SQ(a) ((a) * (a))\n#define EACH(i, c) for (typeof((c).begin()) i = (c).begin(); i != (c).end(); ++i)\n#define EXIST(s, e) ((s).find(e) != (s).end())\n#define SORT(c) sort((c).begin(), (c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i, s, n) for (int i = s; i < (int)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define MOD 1000000007\n\n#define rep(i, a, b) for (int i = a; i < (b); ++i)\n#define trav(a, x) for (auto &a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\nconst double EPS = 1E-8;\n\n#define chmin(x, y) x = min(x, y)\n#define chmax(x, y) x = max(x, y)\n\nclass UnionFind\n{\npublic:\n  vector<int> par;\n  vector<int> siz;\n\n  UnionFind(int sz_) : par(sz_), siz(sz_, 1)\n  {\n    for (ll i = 0; i < sz_; ++i)\n      par[i] = i;\n  }\n  void init(int sz_)\n  {\n    par.resize(sz_);\n    siz.assign(sz_, 1LL);\n    for (ll i = 0; i < sz_; ++i)\n      par[i] = i;\n  }\n\n  int root(int x)\n  {\n    while (par[x] != x)\n    {\n      x = par[x] = par[par[x]];\n    }\n    return x;\n  }\n\n  bool merge(int x, int y)\n  {\n    x = root(x);\n    y = root(y);\n    if (x == y)\n      return false;\n    if (siz[x] < siz[y])\n      swap(x, y);\n    siz[x] += siz[y];\n    par[y] = x;\n    return true;\n  }\n\n  bool issame(int x, int y)\n  {\n    return root(x) == root(y);\n  }\n\n  int size(int x)\n  {\n    return siz[root(x)];\n  }\n};\n\nll modPow(ll x, ll n, ll mod = MOD)\n{\n  ll res = 1;\n  while (n)\n  {\n    if (n & 1)\n      res = (res * x) % mod;\n\n    res %= mod;\n    x = x * x % mod;\n    n >>= 1;\n  }\n  return res;\n}\n\n#define SIEVE_SIZE 5000000 + 10\nbool sieve[SIEVE_SIZE];\nvoid makeSieve()\n{\n  for (int i = 0; i < SIEVE_SIZE; ++i)\n    sieve[i] = true;\n  sieve[0] = sieve[1] = false;\n  for (int i = 2; i * i < SIEVE_SIZE; ++i)\n    if (sieve[i])\n      for (int j = 2; i * j < SIEVE_SIZE; ++j)\n        sieve[i * j] = false;\n}\n\nbool isprime(ll n)\n{\n  if (n == 0 || n == 1)\n    return false;\n  for (ll i = 2; i * i <= n; ++i)\n    if (n % i == 0)\n      return false;\n  return true;\n}\n\nconst int MAX = 2000010;\nlong long fac[MAX], finv[MAX], inv[MAX];\n\n// テーブルを作る前処理\nvoid COMinit()\n{\n  fac[0] = fac[1] = 1;\n  finv[0] = finv[1] = 1;\n  inv[1] = 1;\n  for (int i = 2; i < MAX; i++)\n  {\n    fac[i] = fac[i - 1] * i % MOD;\n    inv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;\n    finv[i] = finv[i - 1] * inv[i] % MOD;\n  }\n}\n\n// 二項係数計算\nlong long COM(int n, int k)\n{\n  if (n < k)\n    return 0;\n  if (n < 0 || k < 0)\n    return 0;\n  return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n\nlong long extGCD(long long a, long long b, long long &x, long long &y)\n{\n  if (b == 0)\n  {\n    x = 1;\n    y = 0;\n    return a;\n  }\n  long long d = extGCD(b, a % b, y, x);\n  y -= a / b * x;\n  return d;\n}\n// 負の数にも対応した mod (a = -11 とかでも OK)\ninline long long mod(long long a, long long m)\n{\n  return (a % m + m) % m;\n}\n\n// 逆元計算 (ここでは a と m が互いに素であることが必要)\nlong long modinv(long long a, long long m)\n{\n  long long x, y;\n  extGCD(a, m, x, y);\n  return mod(x, m); // 気持ち的には x % m だが、x が負かもしれないので\n}\nll GCD(ll a, ll b)\n{\n\n  if (b == 0)\n    return a;\n  return GCD(b, a % b);\n}\n\ntypedef vector<ll> vec;\ntypedef vector<vec> mat;\n\nmat mul(mat &A, mat &B)\n{\n  mat C(A.size(), vec((int)B[0].size()));\n  for (int i = 0; i < A.size(); ++i)\n  {\n    for (int k = 0; k < B.size(); ++k)\n    {\n      for (int j = 0; j < B[0].size(); ++j)\n      {\n        C[i][j] = (C[i][j] + A[i][k] % MOD * B[k][j] % MOD) % MOD;\n      }\n    }\n  }\n  return C;\n}\nmat matPow(mat A, ll n)\n{\n  mat B(A.size(), vec((int)A.size()));\n\n  for (int i = 0; i < A.size(); ++i)\n  {\n    B[i][i] = 1;\n  }\n\n  while (n > 0)\n  {\n    if (n & 1)\n      B = mul(B, A);\n    A = mul(A, A);\n    n >>= 1;\n  }\n  return B;\n}\n\nmap<int, int> mp;\nint cnt[100010];\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  //cout << fixed << setprecision(20);\n\n  int S;\n  cin >> S;\n\n  set<int> st;\n  for (ll i = 1; i * i <= S; i++)\n  {\n    if (S % i == 0)\n    {\n      st.insert(i);\n      st.insert(S / i);\n    }\n  }\n  // for (auto e : st)\n  // {\n  //   cout << e << endl;\n  // }\n  map<ll, ll> mp;\n\n  for (auto e : st)\n  {\n    for (ll i = 1; i <= 200000; i++)\n    {\n      bool ok = false;\n      ll lb = i - 1, ub = 2000000;\n\n      while (ub - lb > 1)\n      {\n\n        ll mid = (lb + ub) / 2;\n\n        if (mid * (mid + 1) / 2 == e + i * (i - 1) / 2)\n        {\n          ok = true;\n          lb = mid;\n        }\n        else if (mid * (mid + 1) / 2 > e + i * (i - 1) / 2)\n        {\n          ub = mid;\n        }\n        else\n        {\n          lb = mid;\n        }\n      }\n      //cout << lb << \" \" << ub << endl;\n      if (ok)\n      {\n        //eに対する解の数\n        mp[e]++;\n      }\n    }\n  }\n\n  // for (auto e : mp)\n  // {\n  //   cout << e.first << \" \" << e.second << endl;\n  // }\n  ll ans = 0;\n\n  for (int i = 1; i * i <= S; i++)\n  {\n    if (S % i == 0)\n    {\n      if (i != S / i)\n      {\n        ans += mp[i] * mp[S / i] * 2;\n      }\n      else\n      {\n        ans += mp[i] * mp[S / i];\n      }\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define llint long long\n\nusing namespace std;\n\nllint S;\nllint a[100005];\n\nint main(void)\n{\n  cin >> S;\n  for(int i = 1; i <= S; i++){\n    llint sum = 0;\n    for(int j = i; sum <= S; j++){\n      sum += j;\n      if(sum <= S) a[sum]++;\n    }\n  }\n\n  llint ans = 0;\n  for(int i = 1; i <= S; i++){\n    if(S % i) continue;\n    ans += a[i] * a[S/i];\n  }\n  cout << ans << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define endl '\\n'\n#define int long long\n#define lint long long\n#define pii pair<int,int>\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define SZ(v) ((int)v.size())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define MINF(a) memset(a,0x3f,sizeof(a))\n#define POW(n) (1LL<<(n))\n#define POPCNT(n) (__builtin_popcount(n))\n#define IN(i,a,b) (a <= i && i <= b)\nusing namespace std;\ntemplate <typename T> inline bool CHMIN(T& a,T b) { if(a>b) { a=b; return 1; } return 0; }\ntemplate <typename T> inline bool CHMAX(T& a,T b) { if(a<b) { a=b; return 1; } return 0; }\ntemplate <typename T> inline void SORT(T& a) { sort(ALL(a)); }\ntemplate <typename T> inline void REV(T& a) { reverse(ALL(a)); }\ntemplate <typename T> inline void UNI(T& a) { sort(ALL(a)); a.erase(unique(ALL(a)),a.end()); }\ntemplate <typename T> inline T LB(vector<T>& v, T a) { return *lower_bound(ALL(v),a); }\ntemplate <typename T> inline int LBP(vector<T>& v, T a) { return lower_bound(ALL(v),a) - v.begin(); }\ntemplate <typename T> inline T UB(vector<T>& v, T a) { return *upper_bound(ALL(v),a); }\ntemplate <typename T> inline int UBP(vector<T>& v, T a) { return upper_bound(ALL(v),a) - v.begin(); }\ntemplate <typename T1, typename T2> ostream& operator<< (ostream& os, const pair<T1,T2>& p) { os << p.first << \" \" << p.second; return os; }\ntemplate <typename T1, typename T2> istream& operator>> (istream& is, pair<T1,T2>& p) { is >> p.first >> p.second; return is; }\ntemplate <typename T> ostream& operator<< (ostream& os, const vector<T>& v) { REP(i,v.size()) { if (i) os << \" \"; os << v[i]; } return os; }\ntemplate <typename T> istream& operator>> (istream& is, vector<T>& v) { for(T& in : v) is >> in; return is; }\ntemplate <typename T = int> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate <typename T, typename... Ts> auto make_v(size_t a, Ts... ts) { return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...)); }\ntemplate <typename T, typename V> typename enable_if<is_class<T>::value == 0>::type fill_v(T &t, const V &v) { t = v; }\ntemplate <typename T, typename V> typename enable_if<is_class<T>::value != 0>::type fill_v(T &t, const V &v) { for(auto &e : t) fill_v(e,v); }\nconst lint MOD = 1000000007;\nconst lint INF = 0x3f3f3f3f3f3f3f3f;\nconst double EPS = 1e-10;\n\nvoid _main() {\n    int S;\n    cin >> S;\n    int ans = 0;\n    for (int u = 2; u <= 4 * S; ++u) {\n        for (int v = 1; v <= (4 * S / u); ++v) {\n            if (u % 2 != (v - 1) % 2) continue;\n            if (4 * S % (u * v) != 0) continue;\n            int S2 = 4 * S / (u * v);\n            for (int w = 1; w * w <= S2; ++w) {\n                if (S2 % w != 0) continue;\n                int P = S2 / w, Q = w;\n                if (P % 2 != (Q - 1) % 2) continue;\n                if (P >= Q + 1) {\n                    int a = (u - v + 1) / 2;\n                    int b = (u + v - 1) / 2;\n                    int c = (P - Q + 1) / 2;\n                    int d = (P + Q - 1) / 2;\n                    ans += (a >= 1 && b >= a && c >= 1 && d >= c);\n                }\n            }\n        }\n    }\n    cout << ans << endl;\n}\n\nsigned main(signed argc, char **argv) {\n    if (argc > 1) {\n        if (strchr(argv[1], 'i'))\n            freopen(\"input.txt\", \"r\", stdin);\n        if (strchr(argv[1], 'o'))\n            freopen(\"output.txt\", \"w\", stdout);\n    }\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n    _main();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<ll,ll> mp;\nll inf =  1e9;\n#define N 1e5+10\nvector<ll> yaku(ll n ){\n    set<ll> res;\n    vector<ll> tmp;\n    for(ll i=1;i*i<=n;i++){\n\tif( n%i == 0 ){\n\t    res.insert( i );\n\t    res.insert( n/i );\n\t}\n    }\n    for(auto i:res)tmp.push_back( i );\n    return tmp;\n}\n\nint main(){\n    vector<ll> cnt(N, 0 );\n    ll s;\n    cin>>s;\n    for(ll i=1;i<N;i++){\n\tll sum = i;\n\tfor(ll j=1;sum <N ;j++){\n\t    cnt[sum]++;\n\t    sum += i+j;\n\t}\n    }\n    vector<ll> Y = yaku( s );\n    ll res = 0;\n    //cout<<\"OK\"<<endl;\n    for(auto i:Y ){\n\t\n\tif( i == s/i ){\n\t    res += cnt[i]*cnt[i];\n\t}else{\n\t    res += cnt[i]*cnt[s/i];\n\t}\n\t\n    }\n    cout<<res<<endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\nusing ll = long long;\n#define REP(i, n) for (int i = 0; i < n; ++i)\n#define ALL(v) v.begin(), v.end()\n\nint main() {\n  int s;\n  cin >> s;\n  map<ll, ll> mp;\n  auto calc = [&](int a) {\n    for (int i = 1;; ++i) {\n      if (i * (i + 1) / 2 > a) break;\n      int tmp = (a - i * (i + 1) / 2);\n\n      if (tmp % i == 0) {\n        mp[a]++;\n      }\n    }\n  };\n  ll ans = 0;\n  for (int i = 1; i * i <= s; ++i) {\n    if (s % i == 0) {\n      calc(i);\n      if (i * i != s) calc(s / i);\n      ans += mp[i] * mp[s / i];\n      if (i * i != s) ans += mp[i] * mp[s / i];\n    }\n  }\n  cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nint calc(int X)\n{\n\tint res=0;\n\tfor(int i=1;i*i<=X;i++) if(X%i==0){\n\t\tint j=X/i;\n\t\tif((i+j)%2==1) res++;\n\t}\n\treturn res;\n}\n\nsigned main()\n{\n\tint S; cin>>S;\n\tS*=4;\n\tint ans=0;\n\tfor(int i=1;i*i<=S;i++) if(S%i==0){\n\t\tint X=i, Y=S/i;\n\t\tans+=calc(X)*calc(Y);\n\t\tif(X!=Y) ans+=calc(X)*calc(Y);\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nvector<int> divisor(int n){\n    vector<int> d;\n    for(int i=1; i*i<=n; ++i)if(n%i==0){\n        d.pb(i);\n        if(n/i != i) d.pb(n/i);\n    }\n    return d;\n}\n\nint main(){\n    int s;\n    cin >>s;\n\n    vector<ll> a(s+1);\n    for(int i=1; i<=s; ++i){\n        int now = 0;\n        for(int j=i; j<=s; ++j){\n            now += j;\n            if(now > s) break;\n            ++a[now];\n        }\n    }\n\n    ll ans = 0;\n    for(int x:divisor(s)) ans += a[x]*a[s/x];\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <queue>\n#include <cstdio>\n#include <ctime>\n#include <assert.h>\n#include <chrono>\n#include <random>\n#include <numeric>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned long long ull;\n\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\nll myRand(ll B) {\n\treturn (ull)rng() % B;\n}\n\nint main(){\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    ll c; cin >> c;\n    vector<ll> cnt(c+1,0LL);\n    for(int i=1;i<=c;i++){\n        int sum=0;\n        for(int j=i;j<=c;j++){\n            sum+=j;\n            if(sum>c)break;\n            cnt[sum]++;\n        }\n    }\n    ll res=0;\n    vector<int> div;\n    for(int i=1;i*i<=c;i++){\n        if(c%i==0){\n            div.push_back(i);\n            if(c/i!=i)div.push_back(c/i);\n        }\n    }\n    for(int d:div){\n        res+=cnt[d]*cnt[c/d];\n    }\n    cout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> table(100001);\n\nint pr2() {\n  int sum = 0;\n  int cnt = 0;\n  for (int i = 1; i < table.size(); i++) {\n    sum = 0;\n    for (int j = i; ; j++){\n      sum += j;\n      if (sum >= table.size()) break;\n      table[sum]++;\n    }\n  }\n  return (cnt);\n}\n\nint process(int a, int b) {\n  return table[a] * table[b];\n}\n\nint main() {\n  int S; cin >> S;\n  pr2();\n  for (int i = 1; i < 10; i++){\n    // cout << table[i] << endl;\n  }\n  long long ans = 0;\n  for (int a = 1; a <= S; a++) {\n    if (S%a == 0) {\n      int b = S/a;\n      ans += process(a, b);\n    }\n  }\n  cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint calc(int64_t n) {\n  int64_t ok = 0, ng = 10000000;\n  while (ng - ok > 1) {\n    int64_t m = (ok + ng) / 2;\n    if (m * (m + 1) > n)\n      ng = m;\n    else\n      ok = m;\n  }\n  return ok;\n}\n\nint main() {\n  int s;\n  cin >> s;\n\n  int ans = 0;\n  for (int64_t a = 1; a <= s; ++a) {\n    for (int64_t b = a; (b * b + a + b - a * a) / 2 <= s; ++b) {\n      int64_t t = (b * b + a + b - a * a) / 2;\n      for (int64_t c = 1; t * c <= s; ++c) {\n        int64_t d = calc((2 * s) / t + c * c - c);\n        if (t * (d * d + c + d - c * c) == 2 * s) ans++;\n      }\n    }\n  }\n\n  cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "    #include <bits/stdc++.h>\n\n                                            //    #include <boost/multiprecision/cpp_int.hpp>\n \n                               \t//       #define int long long\n                                                #define inf  1000000007\n                                              #define pa pair<int,int>\n                                               #define pad pair<double,double>\n                                                #define ll long long\n                                                #define pal pair<double,double>\n                                                #define ppap pair<pa,int>\n                                          #define PI 3.14159265358979323846\n                                                #define paa pair<pa,pa>\n                                                #define  mp make_pair\n                                                #define  pb push_back\n                                                #define EPS (1e-10)\n                                                #define equals(a,b) (fabs((a)-(b))<EPS)\n                                            //    #define double long double\n        int dx[4]={0,-1,0,1};\n        int dy[4]={1,0,-1,0};\n                                                using namespace std;\n                                       \t\t\tclass pa3{\n                                                \tpublic:\n                                                \tint x,y,z;\n                                                \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                                \tbool operator < (const pa3 &p) const{\n                                                \t\tif(x!=p.x) return x<p.x;\n                                                \t\tif(y!=p.y) return y<p.y;\n                                                \t\t return z<p.z;\n                                                \t\t//return x != p.x ? x<p.x: y<p.y;\n                                                \t}\n                                       \t\t\t\tbool operator > (const pa3 &p) const{\n                                                \t\tif(x!=p.x) return x>p.x;\n                                                \t\tif(y!=p.y) return y>p.y;\n                                                \t\t return z>p.z;\n                                                \t\t//return x != p.x ? x<p.x: y<p.y;\n                                                \t}\n                                                \tbool operator == (const pa3 &p) const{\n                                                \t\treturn x==p.x && y==p.y && z==p.z;\n                                                \t}\n                                                \t\tbool operator != (const pa3 &p) const{\n                                                \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                                \t}\n                                                \n                                                };\n                                                \n                                                class pa4{\n                                                \tpublic:\n                                                \tint x;\n                                                \tint y,z,w;\n                                                \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                                \tbool operator < (const pa4 &p) const{\n                                                \t\tif(x!=p.x) return x<p.x;\n                                                \t\tif(y!=p.y) return y<p.y;\n                                                \t\tif(z!=p.z)return z<p.z;\n                                                \t\treturn w<p.w;\n                                                \t\t//return x != p.x ? x<p.x: y<p.y;\n                                                \t}\n                                                \tbool operator > (const pa4 &p) const{\n                                                \t\tif(x!=p.x) return x>p.x;\n                                                \t\tif(y!=p.y) return y>p.y;\n                                                \t\tif(z!=p.z)return z>p.z;\n                                                \t\treturn w>p.w;\n                                                \t\t//return x != p.x ? x<p.x: y<p.y;\n                                                \t}\n                                                \tbool operator == (const pa4 &p) const{\n                                                \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                                \t}\n                                                \t\n                                                \tbool operator != (const pa4 &p) const{\n                                                \t\treturn !(x==p.x && y==p.y && z==p.z &&w==p.w);\n                                                \t}\n                                                \t\t\n                                                \n                                                };\n                                                class pa2{\n                                                \tpublic:\n                                                \tint x,y;\n                                                \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                                \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                                \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                                \tbool operator < (const pa2 &p) const{\n                                                \t\treturn x!= p.x ? x<p.x: y<p.y;\n                                                \t}\n                                                \tbool operator > (const pa2 &p) const{\n                                                \t\treturn x != p.x ? x>p.x: y>p.y;\n                                                \t}\n                                                \tbool operator == (const pa2 &p) const{\n                                                \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                                \t}\n                                                \tbool operator != (const pa2 &p) const{\n                                                \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                                \t}\n                                                \t\t\n                                                \n                                                };\n                                                \n                                              \n                                                \n                                                       #define ppa pair<int,pas>\n                                                class Point{\n                                                \tpublic:\n                                                \tdouble x,y;\n                                                \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                                \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                                \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                                \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                                \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                                \tdouble absv() {return sqrt(norm());}\n                                                \tdouble norm() {return x*x+y*y;}\n                                                \tbool operator < (const Point &p) const{\n                                                \t\treturn x != p.x ? x<p.x: y<p.y;\n                                                \t}\n                                                \tbool operator == (const Point &p) const{\n                                                \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                                \t}\n                                                };\n                                                typedef Point Vector;\n                                         #define pl pair<int,pas>\n                                                struct Segment{\n                                                Point p1,p2;\n                                                };\n                                                 double dot(Vector a,Vector b){\n                                                \treturn a.x*b.x+a.y*b.y;\n                                                }\n                                                double cross(Vector a,Vector b){\n                                                \treturn a.x*b.y-a.y*b.x;\n                                                }\n                                            \n                    bool parareru(Point a,Point b,Point c,Point d){\n                    //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                    \treturn abs(cross(a-b,d-c))<EPS;\n                    }\n                    double distance_ls_p(Point a, Point b, Point c) {\n                      if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                      if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                      return abs(cross(b-a, c-a)) / (b-a).absv();\n                    }\n                    bool is_intersected_ls(Segment a,Segment b) {\n                    \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return 1;\n                    \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                    //\t\tcout<<\"sss\"<<endl;\n                    \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                    \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                    \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                    \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                    \t\treturn false;\n                    \t}\n                      else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                    }\n                     \n                    double segment_dis(Segment a,Segment b){\n                    \tif(is_intersected_ls(a,b))return 0;\n                    \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                    \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                    \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                    \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                    \treturn r;\n                    }\n                    Point intersection_ls(Segment a, Segment b) {\n                      Point ba = b.p2-b.p1;\n                      double d1 = abs(cross(ba, a.p1-b.p1));\n                      double d2 = abs(cross(ba, a.p2-b.p1));\n                      double t = d1 / (d1 + d2);\n                     \n                      return a.p1 + (a.p2-a.p1) * t;\n                    }\n                     \n                                    string itos( int i ) {\n                                    ostringstream s ;\n                                    s << i ;\n                                    return s.str() ;\n                                    }\n                                     \n                                    int gcd(int v,int b){\n                                    \tif(v==0) return b;\n                                    \tif(v>b) return gcd(b,v);\n                                    \tif(v==b) return b;\n                                    \tif(b%v==0) return v;\n                                    \treturn gcd(v,b%v);\n                                    }\n                     \n                                    double distans(double x1,double y1,double x2,double y2){\n                                    \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                    \treturn sqrt(rr);\n                                    \t\n                                    }\n                                                        /*\n        double bekid(double w,int r){\n        \tif(r==0) return 1.0;\n        \tif(r==1) return w;\n        \tif(r%2) return bekid(w,r-1)*w;\n        \tdouble f=bekid(w,r/2);\n        \treturn f*f;\n        }*/\n                                    int mod;\n                    int beki(int wa,int rr,int warukazu){\n                    \tif(rr==0) return 1%warukazu;\n                    \tif(rr==1) return wa%warukazu;\n                    \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n                    \tint zx=beki(wa,rr/2,warukazu);\n                    \treturn (zx*zx)%warukazu;\n                    }\n                          /*          \n                    int pr[401000];\n                    int inv[401000];\n                   \n                   \n\n                  \n        \t\t\tint comb(int nn,int rr){\n        \t\t\t\tint r=pr[nn]*inv[rr];\n        \t\t\t\tr%=mod;\n        \t\t\t\tr*=inv[nn-rr];\n        \t\t\t\tr%=mod;\n        \t\t\t\t\n        \t\t\t\treturn r;\n        \t\t\t}\n                  \n                    void gya(int ert){\n                    \tpr[0]=1;\n                    \tfor(int i=1;i<ert;i++){\n                    \t\tpr[i]=(pr[i-1]*i)%mod;\n                    \t}\n                    \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],mod-2,mod);\n                    \t\n                    }\n                    */\n                    \n                  //   cin.tie(0);\n        \t\t//\tios::sync_with_stdio(false);\n        \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                     //sort(ve.begin(),ve.end(),greater<int>());\n\nint  cnt[100010]={0};\n  signed main(){\n \t              cin.tie(0);\n   \t\tios::sync_with_stdio(false);\n\n  \tfor(int i=1;i<=100000;i++){\n  \t\tint ima=0;\n  \t\tfor(int j=i;;j++){\n  \t\t\tima+=j;\n  \t\t\tif(ima>100000)break;\n  \t\t\tcnt[ima]++;\n  \t\t}\n  \t}\n  \tint s;\ncin>>s;\n  \tint ans=0;\n  \tfor(int i=1;i<=s;i++)if(s%i==0){\n  \t\tans+=cnt[i]*cnt[s/i];\n  \t}\n  \tcout<<ans<<endl;\n  \treturn 0;\n  \t\n               }\n                \n                \n                \n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\ntypedef long long ll;\n\nint main(){\n    int s;\n    cin >> s;\n    vector<int> v(s+1, 0);\n    // O(S logS)\n    for(int i = 1; i <= s; i++){\n        if(s%i) continue;\n        for(int j = 1; j*(j+1)/2 <= i; j++){\n            if((i-j*(j+1)/2)%j == 0)    v[i]++;\n        }\n    }\n    ll ans = 0;\n    for(int i = 1; i <= s; i++){\n        ans += v[i]*v[s/i];\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef long double D;\ntypedef complex<D> P;\n#define F first\n#define S second\nconst ll MOD=1000000007;\n//const ll MOD=998244353;\n\ntemplate<typename T,typename U>istream & operator >> (istream &i,pair<T,U> &A){i>>A.F>>A.S; return i;}\ntemplate<typename T>istream & operator >> (istream &i,vector<T> &A){for(auto &I:A){i>>I;} return i;}\ntemplate<typename T,typename U>ostream & operator << (ostream &o,const pair<T,U> &A){o<<A.F<<\" \"<<A.S; return o;}\ntemplate<typename T>ostream & operator << (ostream &o,const vector<T> &A){ll i=A.size(); for(auto &I:A){o<<I<<(--i?\" \":\"\");} return o;}\n\n\nll count(ll s){\n  ll ret=0;\n  for(ll i=1;i*(i+1)/2<=s;i++){\n    if(i&1){\n      if(s%i!=0){continue;}\n      ll m=s/i;\n      if(m-i/2>0){ret++;}\n    }\n    else{\n      if(s*2%i!=0){continue;}\n      ll m=s*2/i;\n      if(m%2!=1){continue;}\n      if(m-i>0){ret++;}\n    }\n  }\n  return ret;\n}\n\nint main(){\n  ll s;\n  cin>>s;\n  ll ans=0;\n  for(ll i=1;i<=s;i++){\n    if(s%i==0){\n      ans+=count(i)*count(s/i);\n    }\n  }\n  cout<<ans<<endl;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing PII = pair<ll, ll>;\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\ntemplate<typename T> void chmin(T &a, const T &b) { a = min(a, b); }\ntemplate<typename T> void chmax(T &a, const T &b) { a = max(a, b); }\nstruct FastIO {FastIO() { cin.tie(0); ios::sync_with_stdio(0); }}fastiofastio;\n#ifdef DEBUG_ \n#include \"../program_contest_library/memo/dump.hpp\"\n#else\n#define dump(...)\n#endif\nconst ll INF = 1LL<<60;\n\nint main(void) {\n    ll s;\n    cin >> s;\n\n    vector<ll> div;\n    for(ll i=1; i*i<=s; ++i) {\n        if(s%i==0) {\n            div.push_back(i);\n            if(s/i != i) div.push_back(s/i);\n        }\n    }\n\n    ll ret = 0;\n    for(auto x: div) {\n        ll y = s/x;\n\n        // 2xの約数\n        ll cnt1;\n        {\n            set<PII> st;\n            for(ll p=1; p*p<=2*x; ++p) {\n                if(2*x%p == 0) {\n                    ll q = 2*x/p;\n                    if((p+q)%2 == 0) continue;\n                    ll i = (q-p+1)/2;\n                    ll j = (p+q-1)/2;\n                    if(i>j) swap(i,j);\n                    st.insert({i,j});\n                }\n            }\n            dump(2*x, st);\n            cnt1 = st.size();\n        }\n\n        // 2yの約数\n        ll cnt2;\n        {\n            set<PII> st;\n            for(ll p=1; p*p<=2*y; ++p) {\n                if(2*y%p == 0) {\n                    ll q = 2*y/p;\n                    if((p+q)%2 == 0) continue;\n                    ll i = (q-p+1)/2;\n                    ll j = (p+q-1)/2;\n                    if(i>j) swap(i,j);\n                    st.insert({i,j});\n                }\n            }\n            dump(2*y, st);\n            cnt2 = st.size();\n        }\n\n        ret += cnt1 * cnt2;\n    }\n    cout << ret << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nInt wwwcalc(Int x){\n  map<Int, Int> mp;\n  for(Int i=2;i*i<=x;i++){\n    if(x%i) continue;\n    mp[i]=1;\n    while(x%i==0) x/=i,mp[i]++;\n  }\n  if(x!=1) mp[x]=2;\n  Int res=1;\n  for(auto p:mp) res*=p.second;\n  return res;\n}\n\n\nInt calc(Int x){\n  x*=2;\n  using P = pair<Int, Int>;\n  set<P> sp;\n  for(Int i=1;i*i<=x;i++){\n    if(x%i) continue;\n    {\n      Int c=i;\n      Int d=x/i;\n      if((c+d-1)%2==0){\n\tInt b=(c+d-1)/2;\n\tInt a=c-b;\n\tif(1<=a&&a<=b) sp.emplace(a,b);\n      }\n    }\n    {\n      Int c=x/i;\n      Int d=i;\n      if((c+d-1)%2==0){\n\tInt b=(c+d-1)/2;\n\tInt a=c-b;\n\tif(1<=a&&a<=b) sp.emplace(a,b);\n      }\n    }\n  }\n  //cout<<x/2<<\":\"<<sp.size()<<endl;\n  return (Int)sp.size();\n}\n\nsigned main(){\n  Int s;\n  cin>>s;\n  Int ans=0;\n  for(Int i=1;i*i<=s;i++){\n    if(s%i) continue;\n    Int x=i,y=s/i;\n    ans+=calc(x)*calc(y);\n    if(x!=y) ans+=calc(x)*calc(y);\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "/*\n  filename:A2912.c\n  @kankichi57301\n*/\n#include<stdio.h>\n\nint p[10],e[10];\nint nc3table[]={1,4,10,20,35,56,84,120,165,220,286,364};\n\nint factorize(int v)\n{\n  int a=v,i,j,k;\n  k=0;\n  for(j=2; j<=v/2 && 1<a; j+=1+(j&1))\n    {for(i=0;a%j==0;i++)\n\ta/=j;\n      if(i)\n\t{ p[k]=j;\n\t  e[k]=i;\n\t  k++;\n\t}\n    }\n  return k;\n}\n\nint main()\n{\n  int i,n,n2,c,ret;\n\n  scanf(\"%d\",&n);\n  c=factorize(n);\n  \n  ret=1;\n  if(p[0]==2)\n    {\n      ret = e[0]+1;\n      for(i=1;i<c;i++)\n\tret *= nc3table[e[i]];\n    }\n  else\n    {\n      ret=1; \n      for(i=0;i<c;i++) \n\tret *= nc3table[e[i]];\n    }  \n  printf(\"%d\\n\",ret);\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "/*\n  filename:A2912.c\n  @kankichi57301\n*/\n#include<stdio.h>\n\nint p[10],e[10];\nint nc3table[]={1,4,10,20,35,56,84,120,165,220,286,364};\n\nint factorize(int v)\n{\n  int a=v,i,j,k;\n  k=0;\n  for(j=2; j<=v/2 && 1<a; j+=1+(j&1))\n    {for(i=0;a%j==0;i++)\n\ta/=j;\n      if(i)\n\t{ p[k]=j;\n\t  e[k]=i;\n\t  k++;\n\t}\n    }\n  return k;\n}\n\nint main()\n{\n  int i,n,n2,c,ret;\n\n  scanf(\"%d\",&n);\n  c=factorize(n);\n  \n  ret=1;\n  if(c==0)\n     ret=4;\n  else if(p[0]==2)\n    {\n      ret = e[0]+1;\n      for(i=1;i<c;i++)\n\tret *= nc3table[e[i]];\n    }\n  else\n    {\n      ret=1; \n      for(i=0;i<c;i++) \n\tret *= nc3table[e[i]];\n    }  \n  printf(\"%d\\n\",ret);\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "/*\n  filename:factr3.c\n*/\n#include<stdio.h>\n\n\nint p[10],e[10];\nint nc3table[]={1,4,10,20,35,56,84,120,165,220,286,364};\n\nint factorize(int v)\n{\n  int a=v,i,j,k;\n  k=0;\n  for(j=2; j<=v/2 && 1<a; j+=1+(j&1))\n    {for(i=0;a%j==0;i++)\n\ta/=j;\n      if(i)\n\t{ p[k]=j;\n\t  e[k]=i;\n\t  k++;\n\t}\n    }\n  return k;\n}\n\nint main()\n{\n  int i,n,n2,c,ret;\n\n  scanf(\"%d\",&n);\n  c=factorize(n);\n  //for(i=0;i<c;i++)\n  //  printf(\"%d^%d\\n\",p[i],e[i]);\n  ret=1;\n  if(c==0)\n    ret=4;\n  else if(p[0]==2)\n    {\n      ret = e[0]+1;\n      for(i=1;i<c;i++)\n\tret *= nc3table[e[i]];\n    }\n  else\n    {\n      ret=1; \n      for(i=0;i<c;i++) \n\tret *= nc3table[e[i]];\n    }  \n  printf(\"%d\\n\",ret);\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "/*\n  filename:A2912.c\n*/\n#include<stdio.h>\n\n\nint p[10],e[10];\nint nc3table[]={1,4,10,20,35,56,84,120,165,220,286,364};\n\nint factorize(int v)\n{\n  int a=v,i,j,k;\n  k=0;\n  for(j=2; j<=v/2 && 1<a; j+=1+(j&1))\n    {for(i=0;a%j==0;i++)\n\ta/=j;\n      if(i)\n\t{ p[k]=j;\n\t  e[k]=i;\n\t  k++;\n\t}\n    }\n  return k;\n}\n\nint main()\n{\n  int i,n,n2,c,ret;\n\n  scanf(\"%d\",&n);\n  c=factorize(n);\n  //for(i=0;i<c;i++)\n  //  printf(\"%d^%d\\n\",p[i],e[i]);\n  \n  if(c==0)\n    { \n    if(n==1)\n      ret=1;\n    else\n      ret=4;\n    }\n  else if(p[0]==2)\n    {\n      ret = e[0]+1;\n      for(i=1;i<c;i++)\n\tret *= nc3table[e[i]];\n    }\n  else\n    {\n      ret=1; \n      for(i=0;i<c;i++) \n\tret *= nc3table[e[i]];\n    }  \n  printf(\"%d\\n\",ret);\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "// AOJ 2912: Sum of QQ\n// 2019.2.23 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\nint combi(int b)\n{\n\tint p, q, ans;\n\n\tb <<= 1, ans = 0;\n\tfor (p = (int)sqrt(b); p > 0; p--) {\n\t\tif (b % p == 0) {\n\t\t\tq = b / p;\n\t\t\tif ((p + q) & 1) ans++;\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tint S, x, y, lim, ans;\n\n\tscanf(\"%d\", &S);\n\tans = 0;\n\tlim = (int)sqrt(S);\n\tfor (x = 1; x <= lim; x++) {\n\t\tif (S % x == 0) {\n\t\t\ty = S / x;\n\t\t\tif (x == y) {\n\t\t\t\tint k = combi(x);\n\t\t\t\tans += k * k;\n\t\t\t} else ans += 2 * combi(x)*combi(y);\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "fun binarySearch(array: LongArray, target: Long): Boolean {\n    var left = 0\n    var right = array.size\n    while(left < right){\n        val mid = (left + right) / 2\n        if (array[mid] == target) return true\n        if (array[mid] < target) {\n            left = mid + 1\n        }else {\n            right = mid\n        }\n    }\n    return false\n}\nfun main(args: Array<String>?): Unit {\n    val s = readLine()!!.trim().toInt()\n    val sum = LongArray(s + 1){it * (it + 1L) / 2}\n    val divisors = (2 .. s).filter{s % it == 0}\n    val count = IntArray(s + 1){0}.also{it[1] = 1}\n    for (n in sum) {\n        for (d in divisors) {\n            if (n >= d && binarySearch(sum, n - d)) {\n                count[d]++\n            }\n        }\n    }\n    println(\n            (divisors + 1).map{d -> count[d].toLong() * count[s / d]}.sum()\n    )\n}\n"
  },
  {
    "language": "Python",
    "code": "#!usr/bin/env python3\nfrom collections import defaultdict,deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef I(): return int(sys.stdin.readline())\ndef LS():return [list(x) for x in sys.stdin.readline().split()]\ndef S(): return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    return [I() for i in range(n)]\ndef LIR(n):\n    return [LI() for i in range(n)]\ndef SR(n):\n    return [S() for i in range(n)]\ndef LSR(n):\n    return [LS() for i in range(n)]\n\nsys.setrecursionlimit(1000000)\nmod = 1000000007\n\ndef solve():\n    def sum(a,b):\n        return ((b+a)*(b-a+1)) >> 1\n    def fact(n):\n        if n < 4:\n            return [1,n]\n        res = [1]\n        i = 2\n        while i**2 <= n:\n            if n%i == 0:\n                res.append(i)\n                m = n//i\n                if i != m:\n                    res.append(m)\n            i += 1\n        res.append(n)\n        return res\n    s = I()\n    if s == 1:\n        print(1)\n        return\n    lis = fact(s)\n    f = defaultdict(lambda : 0)\n    p = defaultdict(lambda : 1)\n    lis.sort()\n    for k in lis:\n        for a in range(1,k+1):\n            b = k-a\n            if a <= b:\n                if p[(a,b)]:\n                    f[sum(a,b)] += 1\n                    p[(a,b)] = 0\n                    \n        for a in range(1,s+1):\n            b = k+a-1\n            if p[(a,b)]:\n                s_ = sum(a,b)\n                if s_ > s:\n                    break\n                f[s_] += 1\n                p[(a,b)] = 0\n    ans = 0\n    for k in lis:\n        ans += f[k]*f[s//k]\n    print(ans)\n    return\n\n#Solve\nif __name__ == \"__main__\":\n    solve()\n\n"
  },
  {
    "language": "Rust",
    "code": "extern crate core;\n\nuse std::str::FromStr;\nuse std::fmt;\nuse std::cmp::{Ordering, max};\nuse std::fmt::{Display, Error, Formatter};\nuse std::ops::{Range, Add};\n\nstruct InputStream {\n    line: Vec<String>,\n    position: usize\n}\ntype Parse<T: FromStr> = Result<T, T::Err>;\nimpl InputStream {\n    fn new() -> InputStream {\n        InputStream {line:vec![], position: 0}\n    }\n    fn read_word(&mut self) -> &String {\n        if self.position == self.line.len() {\n            let mut line= String::new();\n            std::io::stdin().read_line(&mut line).ok();\n            self.line = line.split_whitespace().map(|x|x.to_string()).collect();\n            self.position = 0\n        }\n        let result = &self.line[self.position];\n        self.position += 1;\n        result\n    }\n    fn read<T: FromStr>(&mut self) -> Parse<T> {\n        self.read_word().parse()\n    }\n    fn get<T: FromStr>(&mut self) -> T {self.read().ok().unwrap()}\n    fn read_int(&mut self) -> i32 {self.get()}\n    fn read_long(&mut self) -> i64 {self.get()}\n    fn read_double(&mut self) -> f64 {self.get()}\n    fn read_usize(&mut self) -> usize {self.get()}\n}\nmacro_rules! read_line{\n    () => {{\n        let mut line = String::new();\n        std::io::stdin().read_line(&mut line).ok();\n        line\n    }};\n    (delimiter: ' ') => {\n        read_line!().split_whitespace().map(|x|x.to_string()).collect::<Vec<_>>()\n    };\n    (delimiter: $p:expr) => {\n        read_line!().split($p).map(|x|x.to_string()).collect::<Vec<_>>()\n    };\n    (' ') => {\n        read_line!(delimiter: ' ')\n    };\n    ($delimiter:expr) => {\n        read_line!(delimiter: $delimiter)\n    };\n    (' '; $ty:ty) => {\n        read_line!().split_whitespace().map(|x|x.parse::<$ty>().ok().unwrap()).collect::<Vec<$ty>>()\n    };\n    ($delimiter:expr; $ty:ty) => {\n        read_line!($delimiter).into_iter().map(|x|x.parse::<$ty>().ok().unwrap()).collect::<Vec<$ty>>()\n    };\n}\n\nmacro_rules! let_all {\n    ($($n:ident:$t:ty),*) => {\n        let line = read_line!(delimiter: ' ');\n        let mut iter = line.iter();\n        $(let $n:$t = iter.next().unwrap().parse().ok().unwrap();)*\n    };\n}\nmacro_rules! repeat {\n    ($count:expr; $($statement:tt)+) => {\n        for _ in 0 .. $count {\n            $($statement)*\n        }\n    };\n}\n\nmacro_rules! yields {\n    ($count:expr; $block:block) => {{\n        let mut vec = Vec::with_capacity($count);\n        for _ in 0 .. $count {\n            vec.push($block);\n        }\n        vec\n    }}\n}\nmacro_rules! array {\n    ($factor: expr; ) => {$factor};\n    ($factor: expr; $dimension: expr) => {{\n        let size = $dimension;\n        let mut vec = Vec::with_capacity(size);\n        for _ in 0 .. size {\n            vec.push($factor)\n        }\n        vec\n    }};\n    ($factor:expr; $dimension:expr, $($r:expr),*) => {{\n        let size = $dimension;\n        let mut vec = Vec::with_capacity(size);\n        for _ in 0 .. size{\n            let factor = array!($factor; $($r),*);\n            vec.push(factor)\n        }\n        vec\n    }};\n}\nfn tabulate<F, R>(count: usize, mut generator: F) -> Vec<R> where F : FnMut(usize) -> R {\n    let mut result = Vec::<R>::with_capacity(count);\n    for f in 0..count {\n        result.push(generator(f));\n    }\n    result\n}\nfn binary_search(vec: &Vec<i64>, target: i64) -> bool {\n    let mut left = 0;\n    let mut right = vec.len();\n    while left < right {\n        let mid = (left + right) / 2;\n        if vec[mid] == target {\n            return true\n        }\n        if vec[mid] < target {\n            left = mid + 1;\n        }else {\n            right = mid;\n        }\n    }\n    return false\n}\nfn main() {\n    let_all!(s: usize);\n    let sum = tabulate(s + 1, |x|{(x as i64) * (x as i64 + 1) / 2});\n    let divisors: Vec<usize> = (2 as usize..s + 1).filter(|x|s % x == 0).collect();\n    let mut count = vec![0; s + 1];\n    count[1] = 1;\n    for &n in &sum {\n        for &d in &divisors {\n            if n >= d as i64 && binary_search(&sum, n - d as i64) {\n                count[d] += 1;\n            }\n        }\n    }\n    let mut result = count[1] * count[s];\n    for d in divisors{\n        result += count[d] * count[s / d]\n    }\n    println!(\"{}\", result)\n}\n\n"
  }
]