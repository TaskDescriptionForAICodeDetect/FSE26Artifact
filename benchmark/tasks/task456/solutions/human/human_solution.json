[
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n\nclass Requirement{\npublic:\n  int upper;\n  int lower;\n  Requirement() : upper(INF),lower(0) {}\n  Requirement(int _u,int _l) : upper(_u),lower(_l) {}\n};\n\nint total_commands;\nint total_skills;\n\nbool check_path(int from_command,int to_command,\n\t\tRequirement requirement[101][101]){\n  for(int skill_id = 1; skill_id <= total_skills;skill_id++){\n    if(requirement[from_command][skill_id].lower\n       > requirement[to_command][skill_id].upper){\n      return false;\n    }\n    if(requirement[from_command][skill_id].upper\n       < requirement[to_command][skill_id].lower){\n      return false;\n    }\n  }\n  return true;\n}\n\nint main(){\n  while(~scanf(\"%d %d\",&total_commands,&total_skills)){\n    Requirement requirement[101][101];    \n    for(int command_idx = 0; command_idx < total_commands; command_idx++){\n      int total_conditions;\n      scanf(\"%d\",&total_conditions);\n      for(int condition_idx = 0; condition_idx < total_conditions; condition_idx++){\n\tint skill_id;\n\tstring symbol;\n\tint required_point;\n\tcin >> skill_id >> symbol >> required_point;\n\tif(symbol == \">=\") {\n\t  requirement[command_idx][skill_id].lower\n\t    = max(required_point,requirement[command_idx][skill_id].lower);\n\t}\n\telse if(symbol == \"<=\"){\n\t  requirement[command_idx][skill_id].upper\n\t    = min(required_point,requirement[command_idx][skill_id].lower);\n\t}\n      }\n    }\n\n    \n    bool edge[total_commands][total_commands];\n    //init\n    for(int from = 0; from < total_commands; from++){\n      for(int to = 0; to < total_commands; to++){\n\tedge[from][to] = check_path(from,to,requirement);\n      }\n    }\n\n    bool isok = false;\n    bool used[total_commands];\n    fill(used,used+total_commands,false);\n\n    int count = 0;\n    for(int round = 0;round < total_commands;round++){\n      for(int from = 0;from < total_commands;from++){\n\tfor(int to = 0; to < total_commands; to++){\n\t  if(edge[from][to] && !used[from] && !used[to]){\n\t    used[from] = true;\n\t    count++;\n\t    goto next;\n\t  }\n\t}\n      }\n    next:;\n    }\n    \n    if(count == total_commands){\n      isok = true;\n    }\n\n    printf(\"%s\\n\",isok ? \"Yes\" : \"No\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\nusing namespace std;\ntypedef pair<int,int> P;\n\nint m, n;\nvector<P> v[100][2];\nvector<int> e[100];\nbool saw[100];\n\nbool f(int x, int ori){\n\tif(x == ori && saw[x] == true) return false;\n\tif(saw[x]) return true;\n\tsaw[x] = true;\n\trep(i,e[x].size()){\n\t\tif(!f(e[x][i],ori)) return false;\n\t}\n\treturn true;\n}\n\nint main(){\n\tcin >> m >> n;\n\trep(i,m){\n\t\tint k; cin >> k;\n\t\trep(j,k){\n\t\t\tint s ,t;\n\t\t\tstring cond;\n\t\t\tcin >> s >> cond >> t;\n\t\t\ts--;\n\t\t\tif(cond[0] == '>'){\n\t\t\t\tv[s][0].push_back(P(t,i));\n\t\t\t} else{\n\t\t\t\tv[s][1].push_back(P(t,i));\n\t\t\t}\n\t\t}\n\t}\n\trep(i,n){\n\t\trep(j,v[i][0].size()){\n\t\t\tP p1 = v[i][0][j];\n\t\t\trep(k,v[i][1].size()){\n\t\t\t\tP p2 = v[i][1][k];\n\t\t\t\tif(p1.first > p2.first){\n\t\t\t\t\tif(p2.second == p1.second){\n\t\t\t\t\t\tputs(\"No\");\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\te[p2.second].push_back(p1.second);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\trep(i,m) sort(e[i].begin(),e[i].end());\n\trep(i,m) e[i].erase(unique(e[i].begin(),e[i].end()),e[i].end());\n\trep(i,m){\n\t\trep(j,100) saw[j] = false;\n\t\tif(!f(i,i)){\n\t\t\tputs(\"No\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tputs(\"Yes\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF INT_MAX/3\n\nint n,m;\nint minc[111][111],maxc[111][111];\nbool es[111][111];\nbool used[111];\n\nint main(){\n\tcin.sync_with_stdio(false);\n  cin>>m>>n;\n  rep(i,m)rep(j,n){\n    minc[i][j]=0;\n    maxc[i][j]=INF;\n  }\n  rep(i,m){\n    int k;\n    cin>>k;\n    rep(hoge,k){\n      int s,t;\n      string cond;\n      cin>>s>>cond>>t;\n      s--;\n      if(cond==\"<=\"){\n        minch(maxc[i][s],t);\n        //dbg(maxc[i][s]);\n      }else{\n        maxch(minc[i][s],t);\n        //dbg(minc[i][s]);\n      }\n    }\n  }\n  rep(i,m)rep(j,n){\n    if(maxc[i][j]<minc[i][j]){\n      cout<<\"No\"<<endl;\n      return 0;\n    }\n  }\n  rep(i,m)rep(j,m){\n    if(i==j)continue;\n    bool ok=true;\n    rep(k,n){\n      if(minc[i][k]>maxc[j][k]){\n        ok=false;\n      }\n    }\n    if(ok)es[i][j]=true;\n  }\n  //rep(i,m)rep(j,m)dbg(es[i][j]);\n  rep(hoge,m){\n    rep(i,m){\n      if(used[i])continue;\n      bool ok=true;\n      rep(j,m){\n        if(i==j||used[j])continue;\n        if(!es[i][j])ok=false;\n      }\n      if(ok)used[i]=true;\n    }\n  }\n  rep(i,m){\n    if(!used[i]){\n      cout<<\"No\"<<endl;\n      return 0;\n    }\n  }\n  cout<<\"Yes\"<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nbool f = 1, e[100][100];\nint n;\n\nvoid dfs(int now, int par, VI &visit){\n    if (visit[now]){\n        if (now == par) f = 0;\n        return;\n    }\n    visit[now] = 1;\n    REP(i,n){\n        if (e[now][i]) dfs(i, par, visit);\n    }\n}\n\nint main() {\n    int m;\n    cin >> n >> m;\n    VVI h(n, VI(m, 1000)), l(n, VI(m));\n    REP(i,n){\n        int k;\n        cin >> k;\n        while (k--){\n            int j, x;\n            string s;\n            cin >> j >> s >> x;\n            if (s == \">=\") l[i][j-1] = max(l[i][j-1], x);\n            else h[i][j-1] = min(h[i][j-1], x);\n        }\n    }\n    REP(i,n) REP(j,m) if (l[i][j] > h[i][j]) f = 0;\n    REP(i,n) REP(j,n){\n        bool g = 0;\n        REP(k,m) if (l[i][k] > h[j][k]) g = 1;\n        e[i][j] = g;\n    }\n\n    REP(i,n){\n        VI visit(n);\n        dfs(i, i, visit);\n    }\n\n    cout << (f ? \"Yes\" : \"No\") << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n\nusing namespace std;\n\nint dfs(vector< vector<int> > &G, vector<bool> &visited, int s){\n  int ret = 0;\n  for(int i = 0; i < G[s].size(); ++i){\n    if(visited[G[s][i]]) continue;\n    visited[G[s][i]] = true;\n    ret = max(ret, dfs(G, visited, G[s][i]) + 1);\n    visited[G[s][i]] = false;\n  }\n  return ret;\n}\n\nint main(){\n  int M, N;\n  cin >> M >> N;\n  vector< vector< pair<int, int> > > V(M, vector< pair<int,int> >(N,pair<int,int>(1,100)));\n  for(int i = 0; i < M; ++i){\n    int K;\n    cin >> K;\n    for(int j = 0; j < K; ++j){\n      int s, t;\n      string c;\n      cin >> s >> c >> t;\n      --s;\n      if(c == \">=\"){\n        if(V[i][s].second < t){\n          cout << \"No\" << endl;\n          return 0;\n        }\n        V[i][s].first = t;\n      }else{\n        if(V[i][s].first > t){\n          cout << \"No\" << endl;\n          return 0;\n        }\n        V[i][s].second = t;\n      }\n    }\n  }\n  vector< vector<int> > G(M);\n  for(int i = 0; i < M; ++i){\n    for(int j = 0; j < M; ++j){\n      bool f = true;\n      for(int k = 0; k < N; ++k){\n        if(V[i][k].first > V[j][k].second){\n          f = false;\n          break;\n        }\n      }\n      if(f) G[i].push_back(j);\n    }\n  }\n  int l = 0;\n  vector<bool> visited(M, false);\n  for(int i = 0; i < M; ++i){\n    visited[i] = true;\n    l = max(l, dfs(G, visited, i));\n    visited[i] = false;\n  }\n  if(l == M - 1) cout << \"Yes\" << endl;\n  else cout << \"No\" << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define chmax(a,b) (a<(b)?(a=b,1):0)\n#define chmin(a,b) (a>(b)?(a=b,1):0)\n#define valid(y,x,h,w) (0<=y&&y<h&&0<=x&&x<w)\nconst int INF = 1<<29;\nconst double EPS = 1e-8;\nconst double PI = acos(-1);\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\nbool g[100][100];\nint lower[100][100];\nint upper[100][100];\n\nint main() {\n  int m,n;\n  while(cin >> m >> n) {\n    REP(i,m)REP(j,n){\n      lower[i][j] = -1;\n      upper[i][j] = 101;\n    }\n    REP(i,m) {\n      int k;\n      cin >> k;\n      REP(j,k) {\n        int s,t;\n        string cond;\n        cin >> s >> cond >> t;\n        s--;\n        if (cond == \">=\") {\n          chmax(lower[i][s], t);\n        } else {\n          chmin(upper[i][s], t);\n        }\n      }\n    }\n    memset(g,0,sizeof(g));\n    bool ng = 0;\n    REP(i,n) {\n      REP(j,m) {\n        if (lower[j][i] > upper[j][i]) ng = 1;\n        REP(k,m) {\n          if (j==k) continue;\n          if (upper[j][i] < lower[k][i]) {\n            g[j][k] = 1;\n          }\n        }\n      }\n    }\n    REP(k,m)REP(i,m)REP(j,m)g[i][j]|=g[i][k]&g[k][j];\n    REP(i,m)ng|=g[i][i];\n    puts(ng?\"No\":\"Yes\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\nint M, N, ub[111][111], lb[111][111], skill[111];\nbool learned[111];\n\nbool all_learned() {\n\tfor_(i,0,M) if (!learned[i]) return false;\n\treturn true;\n}\n\nint main() {\n\tcin >> M >> N;\n\t\n\tfor_(i,0,M) for_(j,0,N) {\n\t\tub[i][j] = 100;\n\t\tlb[i][j] = 0;\n\t}\n\t\n\tfor_(i,0,M) {\n\t\tint K;\n\t\tcin >> K;\n\t\t\n\t\tfor_(j,0,K) {\n\t\t\tint s, t;\n\t\t\tstring cnd;\n\t\t\tcin >> s >> cnd >> t;\n\t\t\t--s;\n\t\t\t\n\t\t\tif (cnd == \">=\") lb[i][s] = max(lb[i][s], t);\n\t\t\telse ub[i][s] = min(ub[i][s], t);\n\t\t}\n\t}\n\t\n\tmemset(skill, 0, sizeof(skill));\n\tmemset(learned, 0, sizeof(learned));\n\t\n\tfor_(i,0,M) {\n\t\tbool learn = true;\n\t\tfor_(j,0,N) learn &= (lb[i][j] <= skill[j] && skill[j] <= ub[i][j]);\n\t\tif (learn) learned[i] = true;\n\t}\n\t\t\n\twhile (!all_learned()) {\n\t\tint tar = -1;\n\t\t\n\t\tfor_(i,0,N) {\n\t\t\tbool isok = true;\n\t\t\t\n\t\t\tfor_(j,0,M) {\n\t\t\t\tif (learned[j]) continue;\n\t\t\t\tisok &= (skill[i] + 1 <= ub[j][i]);\n\t\t\t}\n\t\t\t\n\t\t\tif (isok) {\n\t\t\t\ttar = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (tar == -1) {\n\t\t\tcout << \"No\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\t++skill[tar];\n\t\t\n\t\tfor_(i,0,M) {\n\t\t\tbool learn = true;\n\t\t\tfor_(j,0,N) learn &= (lb[i][j] <= skill[j] && skill[j] <= ub[i][j]);\n\t\t\tif (learn) learned[i] = true;\n\t\t}\n\t}\n\t\n\tcout << \"Yes\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nstruct skill{\n  int c,t;\n  skill(){}\n  skill(int c,int t):c(c),t(t){}\n};\nvector<vector<int> > G;\nbool used[111];\nbool dfs(int v,int d){\n  if(d>111) return 0;\n  used[v]=1;\n  bool f=1;\n  for(int i=0;f&&(i<(int)G[v].size());i++)\n    if(!used[G[v][i]]) f&=dfs(G[v][i],d+1);\n  return f;\n}\nbool solve(int m){\n  bool f=1;\n  for(int i=0;f&&(i<m);i++) {\n    if(!used[i]) f&=dfs(i,0);\n    //cout<<i<<endl;\n  }\n  return f;\n}\nint main(){\n  int m,n;\n  cin>>m>>n;\n  vector<skill> ss[m][n];\n  for(int i=0;i<m;i++){\n    int k;\n    cin>>k;\n    for(int j=0;j<k;j++){\n      int s,t;\n      string c;\n      cin>>s>>c>>t;\n      ss[i][s-1].push_back(skill(c==\"<=\",t));\n    }\n  }\n  bool ff=0;\n  G.resize(m);\n  for(int i=0;i<m;i++){\n    for(int j=0;j<m;j++){\n      bool f=0;\n      for(int k=0;k<n;k++){\n\tfor(int x=0;x<(int)ss[i][k].size();x++){\n\t  for(int y=0;y<(int)ss[j][k].size();y++){\n\t    if(ss[i][k][x].t<=ss[j][k][y].t){\n\t      f|=(ss[i][k][x].c==1&&ss[j][k][y].c==0);\n\t    }\n\t  }\n\t}\n      }\n      if(f) G[j].push_back(i);\n      ff|=((i==j)&&f);\n      //if(f) cout<<i<<\":\"<<j<<endl;\n    }\n  }\n  cout<<(!ff&&solve(m)?\"Yes\":\"No\")<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nstruct skill{\n    int max,min;\n    skill(){\n        max=100;\n        min=1;\n    }\n};\n\nint main(){\n    int M,N;\n    cin>>M>>N;\n    skill S[100][100];\n    for(int i=0;i<M;i++){\n        int K;\n        cin>>K;\n        for(int j=0;j<K;j++){\n            int s,t;\n            string cond;\n            cin>>s>>cond>>t;\n            s--;\n            if(cond==\"<=\"){//SP<=t\n                if(t<S[i][s].min){\n                    cout<<\"No\"<<endl;\n                    return 0;\n                }else if(t<S[i][s].max){\n                    S[i][s].max=t;\n                }\n            }else{//t<=SP\n                if(t>S[i][s].max){\n                    cout<<\"No\"<<endl;\n                    return 0;\n                }else if(t>S[i][s].min){\n                    S[i][s].min=t;\n                }\n            }\n        }\n    }\n    for(int i=0;i<M;i++){\n        for(int j=i+1;j<M;j++){\n            int i_over_j=0;\n            for(int k=0;k<N;k++){\n                if(S[i][k].min>S[j][k].max){\n                    if(i_over_j==-1){\n                        cout<<\"No\"<<endl;\n                        return 0;\n                    }else{\n                        i_over_j=1;\n                    }\n                }\n                if(S[i][k].max<S[j][k].min){\n                    if(i_over_j==1){\n                        cout<<\"No\"<<endl;\n                        return 0;\n                    }else{\n                        i_over_j=-1;\n                    }\n                }\n            }\n        }\n    }\n    cout<<\"Yes\"<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint main(){\n  int n,m,k;\n  int id,val;\n  string gl;\n  int skill[2][110][110];\n  bool use[110];\n\n  cin >> m >> n;\n  for(int i=0;i<m;i++){\n    use[i] = false;\n    for(int j=0;j<n;j++)skill[0][i][j] = skill[1][i][j] = -1;\n  }\n\n  for(int i=0;i<m;i++){\n    cin >> k;\n    for(int j=0;j<k;j++){\n      cin >> id >> gl >> val; id--;\n      if(gl == \">=\"){\n\tif(skill[0][i][id]<0 || skill[0][i][id]<val)skill[0][i][id] = val;\n      }else{\n\tif(skill[1][i][id]<0 || skill[1][i][id]>val)skill[1][i][id] = val;\n      }\n    }\n  }\n  \n  int low[110];\n  for(int cnt = 0;cnt<m;cnt++){\n    for(int i=0;i<n;i++)low[i] = 10000;\n\n    for(int i=0;i<m;i++){\n      if(use[i])continue;\n      for(int j=0;j<n;j++){\n\tif(skill[1][i][j]>=0)low[j] = min(low[j],skill[1][i][j]);\n      }\n    }\n\n    int num = -1;\n    for(int i=0;i<m;i++){\n      if(use[i])continue;\n      bool f = true;\n      for(int j=0;j<n;j++){\n\tif(low[j] < skill[0][i][j]){\n\t  f = false; break;\n\t}\n      }\n      if(f){num = i; break;}\n    }\n    if(num<0){\n      cout << \"No\\n\"; return 0;\n    }\n    use[num] = true;\n  }\n  cout << \"Yes\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define ALL(a) (a).begin(), (a).end()\n#define ll long long\n\nusing namespace std;\n\nsigned main(){\n    const string GL = \">=\";\n    int n,m; cin >> m >> n;\n    vector<vector<int> > g(m, vector<int>(n,0));\n    vector<vector<int> > l(m, vector<int>(n,100));\n    for(int i = 0; i < m; i++){\n        int k; cin >> k;\n        for(int j = 0; j < k; j++){\n            int s,t; string c;\n            cin >> s >> c >> t;\n            s--;\n            if(c == GL){\n                g[i][s] = max(g[i][s], t);\n            }\n            else{\n                l[i][s] = min(l[i][s], t);\n            }\n        }\n    }\n    vector<bool> isget(m, false);\n    vector<int> skill(n, 0);\n    for(int i = 0; i < m; i++){\n        for(int j = 0; j < m+1; j++){\n            if(j == m){\n                cout << \"No\" << endl;\n                return 0;\n            }\n            if(isget[j])continue;\n            vector<int> st = skill;\n            for(int k = 0; k < n; k++){\n                if(st[k] < g[j][k])st[k] = g[j][k];\n            }\n            bool flag = true;\n            for(int k = 0; k < m; k++){\n                if(isget[j])continue;\n                for(int p = 0; p < n; p++){\n                    if(st[p] > l[k][p]){\n                        flag = false;\n                        k = m;\n                        break;\n                    }\n                }\n            }\n            if(flag){\n                swap(skill, st);\n                break;\n            }\n        }\n    }\n    cout << \"Yes\" << endl;\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define Fi first\n#define Se second\n#define INF (1<<29)\n#define EPS 1e-10\n#define MOD 1000000007\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint M, N;\nvector<pii>S[128];\nvector<int>G[128];\nvector<int>tpo[128];\n\nint is_edge(int src, int dist)\n{\n  map<int, int>Map;\n  rep(i, S[src].size()) Map[S[src][i].first] = i;\n\n  for(auto x:S[dist]){\n    int s = x.first, c = x.second.first, d = x.second.second;\n    if(!Map.count(s)) continue;\n    pi op = S[src][Map[s]].second;\n    if(!c && op.first && d < op.second) return 0;\n  }\n  return 1;\n}\n\nint dfs(int v, set<int>& sc)\n{\n  if(sc.size() == M && tpo[v].size() == M-1) return 1;\n  for(auto next: G[v]){\n    if(sc.count(next)) continue;\n    sc.insert(next);\n    if(dfs(next, sc)) return 1;\n    sc.erase(next);\n  }\n  return 0;\n}\n\nint solve()\n{\n  rep(i, M){\n    set<int>sc; sc.insert(i);\n    if(dfs(i, sc)) return 1;\n  }\n  return 0;\n}\n\n\nint main()\n{\n  cin >> M >> N;\n  rep(i, M){\n    int K;  cin >> K;\n    rep(j, K){\n      int s, t; string cond;\n      cin >> s >> cond >> t;\n      int c = 0;\n      if(cond == \">=\") c = 1;\n      S[i].push_back(pii(s, pi(c, t)));\n    }\n  }\n\n  rep(i, M) rep(j, S[i].size()) rep(k, S[i].size()){\n    if(j==k) continue;\n    if(S[i][j].first != S[i][k].first) continue;\n    pi a = S[i][j].second, b = S[i][k].second;\n    if(!a.first && b.first && a.second < b.second){\n      cout << \"No\\n\";\n      return 0;\n    }\n  }\n\n  rep(i, M) rep(j, M){\n    if(i == j) continue;\n    if(is_edge(i, j)){\n      G[i].push_back(j);\n      tpo[j].push_back(i);\n      //      cout << i << \" \" << j << endl;\n    }\n  }\n\n  cout << (solve()?\"Yes\":\"No\") << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define INF (1<<26)\nint M,N;\nint K[100];\nint s[100][100];\nstring cond[100][100];\nint t[100][100];\n\nint A[100][100];\nint B[100];\n\nint check(int a,int b){\n  int L[100],R[100];\n  for(int i=0;i<100;i++){\n    L[i]=0;\n    R[i]=INF;\n  }\n  for(int i=0;i<K[a];i++){\n    if(cond[a][i]==\">=\"){\n      L[s[a][i]]=max(L[s[a][i]],t[a][i]);\n    }else{\n      R[s[a][i]]=min(R[s[a][i]],t[a][i]);\n    }\n  }\n\n  for(int i=0;i<100;i++)\n    if(L[i]>R[i])return 0;\n  \n  for(int i=0;i<K[b];i++){\n    if(cond[b][i]==\">=\"){\n      L[s[b][i]]=max(L[s[b][i]],t[b][i]);\n    }else{\n      R[s[b][i]]=min(R[s[b][i]],t[b][i]);\n      if(L[s[b][i]] > R[s[b][i]])return 0;\n    }\n  }\n\n\n  return 1;\n}\n\nint main(){\n  cin>>M>>N;\n  for(int i=0;i<M;i++){\n    cin>>K[i];\n    for(int j=0;j<K[i];j++){\n      cin>>s[i][j]>>cond[i][j]>>t[i][j];\n      s[i][j]--;\n    }\n  }\n  \n  for(int i=0;i<M;i++){\n    for(int j=0;j<M;j++){\n      A[i][j]=check(i,j);\n      B[i]+=check(i,j);\n    }\n  }\n\n  sort(B,B+M);\n  reverse(B,B+M);\n  \n  bool flg=true;\n  for(int i=0;i<M;i++){\n    if(B[i]<M-i)flg=false;\n  }\n\n  cout<<(flg?\"Yes\":\"No\")<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\nint M,N;\n\nstruct state{\n  int k;\n  int maxi[101],mini[101];\n  void init(){\n    for(int j=1;j<=N;j++){\n      maxi[j] = 100;\n      mini[j] = 0;\n    }\n  }\n  bool check(){\n    for(int i=1;i<=N;i++){\n      if( maxi[i] < mini[i] ) return false;\n    }\n    return true;\n  }\n};\n\nstate S[101];\n\nbool check(const state &s1, const state &s2){\n  for(int i=1;i<=N;i++){\n    if( s1.mini[i] > s2.maxi[i] ) return false;\n  }\n  return true;\n}\n\nvector<int> G[101];\nint nG[101];\n\n\n\nint main(){\n  cin >> M >> N;\n  bool f = true;\n  for(int i=0;i<M;i++){\n    S[i].init();\n    cin >> S[i].k;\n    for(int j=0;j<S[i].k;j++){\n      int s,t;string c;\n      cin >> s >> c >> t;\n      if( c == \"<=\" ){\n        S[i].maxi[s] = min(S[i].maxi[s],t);\n      } else {\n        S[i].mini[s] = max(S[i].mini[s],t);\n      }\n    }\n    if( !S[i].check() ) f = false;\n  }\n\n  if( !f ) {\n    cout << \"No\" << endl;\n    return 0;\n  }\n\n  for(int i=0;i<M;i++){\n    for(int j=0;j<M;j++){\n      if( i == j ) continue;\n      if( check(S[i],S[j]) )\n        G[i].push_back( j );\n    }\n  }\n\n  //kokomade_\n\n  for(int i=0;i<M;i++) nG[i] = G[i].size();\n  int T = M-1;\n  bool used[111]={};\n  while( T ){\n    vector<P> pr;\n    for(int i=0;i<M;i++){\n      if(!used[i]) pr.push_back( P(nG[i],i) );    \n    }\n    sort(pr.begin(),pr.end());\n\n    if( pr.back().first >= T ){\n      used[pr.back().second] = true;\n      for(int i=0;i<M;i++){\n        for(int j=0;j<(int)G[i].size();j++){\n          int to = G[i][j];\n          if( to == pr.back().second ) {\n            nG[i]--;\n          }\n        }\n      }\n    } else {\n      f = false;\n      break;\n    }\n    --T;\n  }\n  if( f ) cout << \"Yes\" << endl;\n  else cout << \"No\" << endl;\n\n  \n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<string>\n#include<iomanip>\n#pragma comment(linker, \"/STACK:1024000000,1024000000\")\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<list>\n\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\n#define rep(i,k,n) for(int i=(k);i<=(n);i++)\n#define red(i,k,n) for(int i=(k);i>=(n);i--)\n#define sqr(x) ((x)*(x))\n#define clr(x,y) memset((x),(y),sizeof(x))\n#define mod 1000000007\n#define MAX(a,b) ((a)>(b)?(a):(b))\n#define MIN(a,b) ((a)>(b)?(b):(a))\n//const int maxn = ;\n\nint n,m;\nint skl[110][110];\nint skr[110][110];\nint in[110];\nbool vis[110];\nvector<int> e[110];\nqueue<int> q;\n\nchar s[10];\n\nbool solve()\n{\n    int kk,num,p,v;\n    rep(i,1,n)rep(j,1,m)skl[i][j]=0,skr[i][j]=100;\n    bool flag=false;\n    rep(i,1,n)\n    {\n        scanf(\"%d\",&kk);\n        rep(j,1,kk)\n        {\n            scanf(\"%d%s%d\",&num,s,&p);\n            if(s[0]=='>')\n            {\n                if(skl[i][num]<p)\n                {\n                    if(skr[i][num]<p) flag=true;\n                    else skl[i][num]=p;\n                }\n            }\n            else if(s[0]=='<')\n            {\n                if(skr[i][num]>p)\n                {\n                    if(skl[i][num]>p) flag=true;\n                    else skr[i][num]=p;\n                }\n            }\n        }\n        e[i].clear();\n    }\n\n    if(flag)return 0;\n\n    clr(in,0);\n    for(int i=1;i<=n;i++)\n    {\n        for(int j=1;j<=n;j++)\n        {\n            bool flag=false;\n            rep(k,1,m)\n            {\n                if(skr[i][k]<skl[j][k]){flag=true;break;}\n            }\n            if(flag)\n            {\n                e[j].push_back(i);\n                in[i]++;\n            }\n        }\n    }\n\n    clr(vis,0);\n    int cnt=0;\n    rep(i,1,n)if(in[i]==0)\n    {\n        q.push(i);\n        vis[i]=1;\n        cnt++;\n    }\n    while(!q.empty())\n    {\n        int p=q.front();q.pop();\n        if(!e[p].empty())rep(i,0,e[p].size()-1)\n        {\n            v=e[p][i];\n            if(vis[v])continue;\n            if(--in[v]==0)\n            {\n                q.push(v);\n                vis[v]=1;\n                cnt++;\n            }\n        }\n    }\n\n    return cnt==n;\n}\n\nint main()\n{\n//#define LOCAL\n#ifdef LOCAL\n    freopen(\"e:\\\\read.txt\",\"r\",stdin);\n    //freopen(\"e:\\\\write.txt\",\"w\",stdout);\n#endif\n    while(cin>>n>>m)\n    {\n        if(solve())puts(\"Yes\");\n        else puts(\"No\");\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\nstruct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nbool isDAG(vector<vector<int>>& G) {\n  int N = G.size();\n  vector<bool> vis(N);\n\n  std::function<bool(int)> dfs = [&](int curr) {\n    for(auto e: G[curr]) {\n      if(vis[e]) return false;\n      vis[e] = 1;\n      if(!dfs(e)) return false;\n      vis[e] = 0;\n    }\n    return true;\n  };\n\n  rep(i, N) {\n    vis[i] = 1;\n    if(!dfs(i)) return false;\n    vis[i] = 0;\n  }\n  return true;\n}\n\nint main() {\n\n  int M, N; cin >> M >> N;\n\n  // テ・ツ青?」ツつケテ」ツつュテ」ツδォテヲツッツ偲」ツ?ォテ」ツつウテ」ツδ榲」ツδウテ」ツδ嘉」ツ?ョテ・ツ個コテゥツ鳴禿」ツつ津ヲツ個?」ツ?、\n  vector<vector<pair<int, int>>> cmd_sect(N, vector<pair<int, int>>(M, {0, inf}));\n\n  rep(cmd_idx, M) {\n    int K; cin >> K;\n    rep(_, K) {\n      int skill; cin >> skill; skill--;\n      string op; cin >> op;\n      int threshold; cin >> threshold;\n      if(op == \">=\") {\n        cmd_sect[skill][cmd_idx].first = max(cmd_sect[skill][cmd_idx].first, threshold);\n      } else {\n        cmd_sect[skill][cmd_idx].second = min(cmd_sect[skill][cmd_idx].second, threshold);\n      }\n      if(cmd_sect[skill][cmd_idx].first > cmd_sect[skill][cmd_idx].second) {\n        cout << \"No\" << endl;\n        return 0;\n      }\n    }\n  }\n\n  vector<vector<int>> G(M);\n  \n  rep(i, N) {\n    rep(a, M) rep(b, M) {\n      if(a == b) continue;\n      if(cmd_sect[i][a].second < cmd_sect[i][b].first)\n        G[a].push_back(b);\n    }\n  }\n\n  cout << (isDAG(G) ? \"Yes\" : \"No\") << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nbool solve()\n{\n  int M, N, K;\n  cin >> M >> N;\n  vector< vector<P> > conds(M);\n  bool ans = false;\n  for(int i = 0; i < M; i++) {\n    int K; cin >> K;\n    conds[i].resize(N, P(111, -1));\n    for(int j = 0; j < K; j++) {\n      int s, t; string cond;\n      cin >> s >> cond >> t; --s;\n      if(cond == \"<=\") {\n\tconds[i][s].first = min(conds[i][s].first, t);\n      } else if(cond == \">=\") {\n\tconds[i][s].second = max(conds[i][s].second, t);\n      }\n      if(conds[i][s].second > conds[i][s].first) ans = true;\n    }\n  }\n\n  if(ans) return true;\n\n  bool G[111][111] = {{false}};\n  for(int i = 0; i < M; i++) {\n    for(int j = 0; j < M; j++) {\n      if(i == j) continue;\n      for(int k = 0; k < N; k++) {\n\tG[i][j] |= (conds[i][k].first < conds[j][k].second);\n      }\n    }\n  }\n  \n  for(int i = 0; i < M; i++) {\n    for(int j = 0; j < M; j++) {\n      for(int k = 0; k < M; k++) G[j][k] |= (G[j][i] & G[i][k]);\n    }\n  }\n  \n  for(int i = 0; i < M; i++) ans |= G[i][i];\n\n  return ans;\n}\n\nint main()\n{\n\n  cout << (solve() ? \"No\" : \"Yes\") << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1<<29\nusing namespace std;\n\nint n,m,K,a,b;\nstring s,ans=\"Yes\";\nint skill[101][101][2];\nvector<int> v[101];\nbool checked[101]={},visited[101]={};\n\nvoid init(){\n  for(int i=0;i<101;i++){\n    for(int j=0;j<101;j++){\n      skill[i][j][0]=inf;\n      skill[i][j][1]=inf;\n    }\n  }\n}\n\nvoid dfs(int num){\n  if(visited[num]){\n    ans=\"No\";\n    return;\n  }\n  visited[num]=true;\n  for(int i=0;i<v[num].size();i++){\n    if(!checked[v[num][i]])dfs(v[num][i]);\n  }\n  checked[num]=true;\n  visited[num]=false;\n}\n\nint main()\n{\n  init();\n  cin>>m>>n;\n  for(int i=0;i<m;i++){\n    cin>>K;\n    for(int j=0;j<K;j++){\n      cin>>a>>s>>b;\n      a--;\n      if(s[0]=='>')skill[i][a][0]=b;\n      else skill[i][a][1]=b;\n    }\n  }\n  for(int i=0;i<m;i++){\n    for(int j=0;j<m;j++){\n      bool flag=false;\n      for(int k=0;k<n;k++){\n\tif(skill[i][k][1]==inf)continue;\n\tif(skill[j][k][0]!=inf && skill[i][k][1]<=skill[j][k][0])flag=true;\n\t//if(skill[j][k][1]!=inf && skill[j][k][1]<skill[i][k][1])flag=true;\n      }\n      if(flag)v[i].push_back(j);\n    }\n  }\n  for(int i=0;i<m;i++){\n    if(!checked[i])dfs(i);\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\nstruct Skill{\n    const int INF = 100000000;\n    static const int N = 100;\n    array<int, N> begin;\n    array<int, N> end;\n    Skill(){\n        begin.fill(-INF);\n        end.fill(INF);\n    }\n    bool operator < (const Skill& s) const {\n        for(int i = 0; i < N; i++){\n            if(end[i] < s.begin[i]) return true;\n        }\n        return false;\n    }\n};\n\nint main(){\n    int M, N;\n    while(cin >> M >> N){\n        vector<Skill> skills(M);\n        REP(i, M){\n            int K;\n            cin >> K;\n            while(K--){\n                int s, t;\n                string cond;\n                cin >> s >> cond >> t;\n                if(cond == \">=\"){\n                    int& x = skills[i].begin[s - 1];\n                    x = max(x, t);\n                }else{\n                    int& y = skills[i].end[s - 1];\n                    y = min(y, t);\n                }\n            }\n        }\n        bool d[100][100] = {};\n        REP(i, M) REP(j, M) if(skills[i] < skills[j]) d[i][j] = true;\n        REP(k, M) REP(i, M) REP(j, M) d[i][j] |= d[i][k] && d[k][j];\n        bool ans = true;\n        REP(i, M) if(d[i][i]) ans = false;\n        cout << (ans ? \"Yes\" : \"No\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#define r(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n#define F first\n#define S second\ntypedef pair<int,int>P;\nint n,m,x,y,K,a[102][102],flag,amin[102][102],amax[102][102];\nstring s;\nvector<P>v1[102],v2[102];\nbool ch(){\n  r(i,m){\n    r(j,v1[i].size()){\n      r(k,v2[i].size()){\n\tif(v1[i][j].F==v2[i][k].F&&v1[i][j].S<v2[i][k].S) return 1;\n      }\n    }\n  }\n  return 0;\n}\nvoid make_Graph(){\n  r(i,102)r(j,102)amax[i][j]=1e8;\n  r(i,m){\n    r(j,v1[i].size())amax[i][v1[i][j].F]=min(amax[i][v1[i][j].F],v1[i][j].S);\n    r(j,v2[i].size())amin[i][v2[i][j].F]=max(amin[i][v2[i][j].F],v2[i][j].S);\n    r(j,102)amin[i][j]=min(amin[i][j],amax[i][j]);\n  }\n  r(i,m)r(j,m)r(k,102)if(amax[i][k]<amin[j][k])a[i][j]=-1;\n}\nint main(){\n  cin>>m>>n;\n  r(i,m){\n    cin>>K;\n    r(j,K){\n      cin>>x>>s>>y;\n      if(s==\"<=\")v1[i].push_back(P(x,y));\n      else v2[i].push_back(P(x,y));\n    }\n  }\n  if(ch())cout<<\"No\"<<endl;\n  else{\n    r(i,102)r(j,102)a[i][j]=(i==j?0:1e8);\n    make_Graph();\n    n++;\n    r(o,m)r(i,m)r(j,m)a[i][j]=min(a[i][j],a[i][o]+a[o][j]);\n    r(i,102)if(a[i][i]<0)flag++;\n    cout<<(flag?\"No\":\"Yes\")<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n\ntypedef struct Cond{\n  int kind;\n  int arrow;\n  int bound;\n}cond;\n\nbool sr(const cond& l, const cond& r){\n  return l.kind==r.kind ? l.arrow < r.arrow : l.kind < r.kind;\n}\n\nclass Graph{\npublic:\n  int v;\n  vector<int> visited,visiting;\n  vector<int> e[100];\n  Graph(int m){\n    v = m;\n    visited = vector<int>(v);\n    visiting = vector<int>(v);\n  }\n  void addEdge(int e1,int e2){\n    if (find(e[e1].begin(),e[e1].end(),e2)==e[e1].end()){\n      e[e1].push_back(e2);\n    }\n  }\n  int dfs(int vv){\n    int ret = 0;\n    visited[vv] = 1;\n    visiting[vv] = 1;\n    rep(i,e[vv].size()){\n      if(!visited[e[vv][i]]){\n        ret += dfs(e[vv][i]);\n      } else if (visiting[e[vv][i]]==1){\n        return 1;\n      }\n    }\n    visiting[vv] = 0;\n    return ret;\n  }\n\n  int isDAG(){\n    rep(i,v){\n      int m = dfs(i);\n      if (m>0){\n        return 0;\n      }\n    }\n    return 1;\n  }\n\n};\n\n\nint main(){\n\n  int m,n;\n  cin >> m >> n;\n  vector<int> k(m);\n  vector<cond> conditions[100];\n  pair<int,int> sections[100][100];\n\n  rep(i,m){\n    cin >> k[i];\n    conditions[i] = vector<cond>(k[i]);\n    rep(j,k[i]){\n      string c;\n      cin >> conditions[i][j].kind >> c >> conditions[i][j].bound;\n      conditions[i][j].kind--;\n      if (c==\">=\"){\n        conditions[i][j].arrow = 0;\n      } else {\n        conditions[i][j].arrow = 1;\n      }\n    }\n    sort(conditions[i].begin(),conditions[i].end(),sr);\n    //commandの条件内で矛盾を探す\n    rep(j,100){sections[i][j].first=0;sections[i][j].second=101;}\n    rep(j,conditions[i].size()){\n      int k = conditions[i][j].kind;\n      if (conditions[i][j].arrow == 0){\n        sections[i][k].first = max(sections[i][k].first,conditions[i][j].bound);\n      } else {\n        sections[i][k].second = min(sections[i][k].second,conditions[i][j].bound);\n      }\n    }\n    rep(j,n){\n      if(sections[i][j].first>sections[i][j].second){\n        cout << \"No\" << endl;\n        return 0;\n      }\n    }\n  }\n  //sections[i][j]: i番目のcommand,j番目のskillポイントがfirst以上second以下\n  //skillポイントを固定して条件を見ていって，区間に交わりがない場合は小→大へ辺を張る\n  Graph g(m);\n  rep(skill,n){\n    rep(com1,m){\n      rep(com2,m){\n        if (com1!=com2){\n          int com1l = sections[com1][skill].first;\n          int com1r = sections[com1][skill].second;\n          int com2l = sections[com2][skill].first;\n          int com2r = sections[com2][skill].second;\n          if (com2r < com1l){\n            g.addEdge(com2,com1);\n          } else if (com1r < com2l){\n            g.addEdge(com1,com2);\n          }\n        }\n      }\n    }\n  }\n  //閉路判定\n  int result = g.isDAG();\n  if (result == 1){\n    cout << \"Yes\" << endl;\n  } else {\n    cout << \"No\" << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<iomanip>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<queue>\n\nusing namespace std;\n\n#define int long long\n#define rep(i,n) for(int i = 0; i < (n); i++)\n#define INF ((long long)1e18)\n#define MOD ((int)1e9+7)\n#define endl \"\\n\"\n\n#define yn(f) ((f)?\"Yes\":\"No\")\n#define YN(f) ((f)?\"YES\":\"NO\")\n\n#define MAX 110\n\nint M, N;\nint K[MAX], sp[MAX], point[MAX], con;\nbool can[MAX];\nvector<vector<int>> llim(MAX,vector<int>(MAX,0));\n// vector<pair<int,int>> ulim[MAX];\npriority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> ulim[MAX];\n\nbool check(int n){\n\tif(can[n]) return false;\n\t\n\tfor(int i = 1; i <= N; i++){\n\t\tif(llim[n][i] > sp[i]) return false;\n\t}\n\t\n\tcan[n] = true;\n\tcon++;\n\treturn true;\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout<<fixed<<setprecision(10);\n\t\n\tint s, t;\n\tstring cond;\n\t\n\tcin>>M>>N;\n\t\n\tfor(int i = 1; i <= M; i++){\n\t\tcin>>K[i];\n\t\tfor(int j = 1; j <= K[i]; j++){\n\t\t\tcin>>s>>cond>>t;\n\t\t\tif(cond == \">=\"){\n\t\t\t\tllim[i][s] = max(llim[i][s], t);\n\t\t\t} else if(cond == \"<=\"){\n\t\t\t\tulim[s].push(make_pair(t,i));\n\t\t\t}\n\t\t\tulim[s].push(make_pair(INF,i));\n\t\t}\n\t\t\n\t}\n\t\n\t// for(int i = 1; i <= N; i++){\n\t\t// sort(ulim[i].begin(), ulim[i].end());\n\t// }\n\t// cout<<\"XXXX\"<<endl;\n\twhile(true){\n\t\tbool flag = false;\n\t\t\n\t\tfor(int i = 1; i <= N; i++){\n\t\t\twhile(!ulim[i].empty()){\n\t\t\t\tpair<int,int> p = ulim[i].top(); ulim[i].pop();\n\t\t\t\tif(can[p.second] == false){\n\t\t\t\t\tsp[i] = p.first;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// cout<<i<<\" \"<<sp[i]<<endl;\n\t\t}\n\t\t\n\t\tfor(int i = 1; i <= M; i++){\n\t\t\tif(check(i)) flag = true;\n\t\t}\n\t\tif(!flag){\n\t\t\tcout<<\"NO\"<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\tif(con == M)break;\n\t}\n\t\n\tcout<<\"YES\"<<endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define l first\n#define r second\n#define INF (1e9)\nusing namespace std;\ntypedef pair <int,int> P;\nint ans=1,m,n,used[101],memo[101][101];\nP cmd[101][101];\n\nint check(int a,int b){\n  if(memo[a][b]!=-1) return memo[a][b];\n  for(int i=0;i<n;i++)\n    if(cmd[a][i].l>cmd[b][i].r) return memo[a][b]=0;\n  return memo[a][b]=1;\n}\n\nint solve(){\n  memset(memo,-1,sizeof(memo));\n  int cnt=0;\n  for(int i=0;i<m;i++){\n    int j=0;\n    while(!used[i]&&j<m&&(used[j]||check(i,j)))j++;\n    if(j==m) used[i]=1,cnt++,i=-1;\n  }\n  return cnt/m;\n}\n\nint main(){\n  for(int i=0;i<101;i++)\n    for(int j=0;j<101;j++)cmd[i][j]=P(-INF,INF);\n\n  cin>>m>>n;\n  for(int i=0,k;i<m;i++){\n    cin>>k;\n    while(k--){\n      string cond;\n      int s,t;\n      cin>>s>>cond>>t;\n      s--;\n      if(cond==\"<=\")cmd[i][s].r=min(cmd[i][s].r,t);\n      if(cond==\">=\")cmd[i][s].l=max(cmd[i][s].l,t);\n      if(cmd[i][s].l>cmd[i][s].r)ans=0;\n    }\n  }\n\n  cout << (ans*solve()? \"Yes\":\"No\")<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <cmath>\n#include <queue>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int maxn = 1e5+7;\nvector<int> V[maxn], W[maxn], ind[maxn];\nint n, m, x, y, z, f[maxn], head[maxn], sonson[maxn], dep[maxn], Q[maxn], size[maxn], belong[maxn], cnt, id[maxn],\nfz[maxn<<1];\nint find( int x ){\n    return ( x == f[x] ) ? f[x] : ( f[x] = find( f[x] ) );\n}\nstruct Edge{\n    int u, v, w, id;\n    bool vis;\n    void in( int ID ){\n        scanf( \"%d %d %d\" , &u , &v , &w );\n        id = ID;\n        vis = false;\n    }\n}edge[maxn<<1];\nbool operator < ( const Edge &a , const Edge &b ){\n    return a.w < b.w;\n}\nbool cmp( const Edge &a , const Edge &b ){\n    return a.id < b.id;\n}\nvoid split(){\n    int l = 0, r = 1;\n    dep[Q[r]=1]=1;\n    f[1] = -1;\n    while( l < r ){\n        int x = Q[++l];\n        if( V[x].empty() )\n            continue;\n        for( int j = V[x].size() - 1 ; j >= 0 ; j -- ){\n            int y = V[x][j];\n            if( y == f[x] )\n                continue;\n            dep[Q[++r]=y] = dep[x] + 1;\n            fz[W[x][j]] = y;\n            f[y] = x;\n        }\n    }\n    for( int i = n ; i ; i -- ){\n        int x = Q[i], p = -1;\n        size[x] = 1;\n        if( V[x].empty() )\n            continue;\n        for( int j = V[x].size() - 1 ; j >= 0 ; j -- ){\n            int y = V[x][j];\n            if( y == f[x] )\n                continue;\n            size[x] += size[y];\n            if( p == -1 || ( p > 0 && size[y] > size[p] ) )\n                p = y;\n        }\n        if( p == -1 ){\n            sonson[++cnt] = x;\n            belong[head[cnt]=x] = cnt;\n        }else{\n            belong[x] = belong[p];\n            head[belong[x]] = x;\n        }\n    }\n}\nvoid doit( int a , int b , int hehe ){\n    int ida = belong[a], idb = belong[b], ha = head[iad],\n    hb = head[idb];\n    while( ida != idb ){\n        if( dep[ha] > dep[hb] ){\n            modify( id[a] , id[ha] , hehe );\n            a = f[ha];\n        }else{\n            modify( id[a] , id[hb] , hehe );\n            b = f[hb];\n        }\n        ida = belong[a], idb = belong[b], ha= head[ida], hb = head[idb];\n    }\n\n}\nint main(){\n    scanf( \"%d %d\" , &n , &m );\n    for( int i = 1 ; i <= m ; i ++ )\n        edge[i].in( i );\n    for( int i = 1 ; i <= n ; i ++ )\n        f[i] = i;\n    sort( edge + 1 , edge + m + 1 );\n    long long ans = 0;\n    for( int i = 1 ; i <= m ; i ++ ){\n        int u = find( edge[i].u ), v = find( edge[i].v );\n        if( u == v )\n            continue;\n        f[u] = f[v];\n        ans = ans + edge[i].w;\n        u = edge[i].u, v = edge[i].v;\n        V[u].push_back(v);\n        V[v].push_back(u);\n        W[u].push_back( edge[i].id );\n        W[v].push_back( edge[i].id );\n        edge[i].vis = 1;\n    }\n    split();\n    int count = 0;\n//    build( 1 , 1 , n );\n    for( int i = 1 ; i <= cnt ; i ++ ){\n        int y = sonson[i];\n        while( true ){\n            id[y] = ++ count;\n            //\n            if( f[y] == -1 )\n                break;\n            if( belong[y] != belong[f[y]] )\n                break;\n            y = f[y];\n        }\n    }\n    sort( edge + 1 , edge + m + 1 , cmp );\n    for( int i = 1 ; i <= m ; i ++ ){\n        int u = edge[i].u, v = edge[i].v;\n        doit( u , v );\n    }\n    for( int i = 1 ; i <= m ; i ++ ){\n        if( !edge[i].vis ){\n            printf( \"%lld\\n\" , ans );\n            continue;\n        }\n        printf( \"%lld\\n\" , ans - edge[i].w ); //+ query() );\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\n#include <vector>\n\nusing namespace std;\n\n#define MAX 114\n\nvector<int> G[MAX];\nint col[MAX];\nbool found;\n\nvoid dfs(int v)\n{\n    col[v] = 0;\n    for(int i = 0 ; i < (int)G[v].size() ; i++){\n        int to = G[v][i];\n        if(col[to] == -1){\n            dfs(to);\n        }else if(col[to] == 0){\n            found = true;            \n            return;\n        }\n    }\n    col[v] = 1;\n}\n    \nint main()\n{\n    int M, N;\n    cin >> M >> N;\n    \n    auto canGraph = [=](){\n        int l[MAX][MAX], u[MAX][MAX];\n        for(int i = 0 ; i < MAX ; i++){\n            for(int j = 0 ; j < MAX ; j++){\n                l[i][j] = -1;\n                u[i][j] = 101;\n            }\n        }\n        int K, s, t;\n        string c;\n        bool poss = 1;\n        for(int i = 0 ; i < M ; i++){\n            cin >> K;\n            for(int j = 0 ; j < K ; j++){\n                cin >> s >> c >> t;\n                --s;\n                if(c == \">=\"){\n                    l[i][s] = max(l[i][s], t);\n                }else{\n                    u[i][s] = min(u[i][s], t);\n                }\n            }\n            for(int j = 0 ; j < N ; j++){\n                if(l[i][j] > u[i][j]){\n                    poss = 0;\n                    break;\n                }\n            }\n        }\n\n        if(!poss) return false;\n\n        auto isConnect = [=](int from, int to){\n            for(int i = 0 ; i < N ; i++){\n                if(u[from][i] <= l[to][i]){\n                    return true;\n                }\n            }\n            return false;\n        };\n        \n        for(int from = 0 ; from < M ; from++){\n            for(int to = 0 ; to < M ; to++){\n                if(from == to) continue;\n                if(isConnect(from, to)){\n                    G[from].push_back(to);\n                }\n            }\n        }\n        found = false;\n        memset(col, -1, sizeof(col));\n        for(int i = 0 ; i < M ; i++){\n            if(col[i] == -1){\n                dfs(i);\n            }\n        }                                       \n        return !found;\n    };\n    \n    cout << (canGraph() ? \"Yes\" : \"No\") << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nint main()\n{\n\tint m, n;\n\tcin >> m >> n;\n\tvector<vi> graph(n, vi(n));\n\tvector<vector<pii>> v(m, vector<pii>(n, pii(0, INF)));\n\tREP(i, m)\n\t{\n\t\tint k; cin >> k;\n\t\tREP(j, k)\n\t\t{\n\t\t\tint s, t; string con;\n\t\t\tcin >> s >> con >> t;\n\t\t\ts--;\n\t\t\tif (con == \"<=\") chmin(v[i][s].second, t);\n\t\t\telse chmax(v[i][s].first, t);\n\t\t}\n\t}\n\tbool ans = false;\n\tbool ff = true;\n\tREP(i, m)REP(j, n)\n\t{\n\t\tif (v[i][j].first > v[i][j].second) ff = false;\n\t}\n\tif (ff)\n\t{\n\t\tREP(i, n)REP(j, n)\n\t\t{\n\t\t\tif (i == j) continue;\n\t\t\tbool f = true;\n\t\t\tREP(k, n)\n\t\t\t{\n\t\t\t\tif (v[i][k].second < v[j][k].first) f = false;\n\t\t\t}\n\t\t\tif (f) graph[j][i] = 1;\n\t\t}\n\n\t\tset<int> st;\n\t\tREP(j, n) st.insert(j);\n\t\twhile (st.size())\n\t\t{\n\t\t\tbool up = false;\n\t\t\tfor (auto j : st)\n\t\t\t{\n\t\t\t\tbool f = true;\n\t\t\t\tfor (auto k : st)\n\t\t\t\t{\n\t\t\t\t\tif (j == k) continue;\n\t\t\t\t\tif (graph[j][k] == 0) f = false;\n\t\t\t\t}\n\t\t\t\tif (f)\n\t\t\t\t{\n\t\t\t\t\tst.erase(j);\n\t\t\t\t\tup = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!up) break;\n\t\t}\n\t\tif (st.size() == 0) ans = true;\n\t}\n\tputs(ans ? \"Yes\" : \"No\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1<<29\nusing namespace std;\n\nint n,m,K,a,b;\nstring s,ans=\"Yes\";\nint skill[101][101][2];\nvector<int> v[101];\nbool checked[101]={},visited[101]={};\n\nvoid init(){\n  for(int i=0;i<101;i++){\n    for(int j=0;j<101;j++){\n      skill[i][j][0]=inf;\n      skill[i][j][1]=inf;\n    }\n  }\n}\n\nvoid dfs(int num){\n  if(visited[num]){\n    ans=\"No\";\n    return;\n  }\n  visited[num]=true;\n  for(int i=0;i<v[num].size();i++){\n    if(!checked[v[num][i]])dfs(v[num][i]);\n  }\n  checked[num]=true;\n  visited[num]=false;\n}\n\nint main()\n{\n  init();\n  cin>>m>>n;\n  for(int i=0;i<m;i++){\n    cin>>K;\n    for(int j=0;j<K;j++){\n      cin>>a>>s>>b;\n      a--;\n      if(s[0]=='>')skill[i][a][0]=b;\n      else skill[i][a][1]=b;\n    }\n  }\n  for(int i=0;i<m;i++){\n    for(int j=0;j<m;j++){\n      bool flag=false;\n      for(int k=0;k<n;k++){\n\tif(skill[i][k][1]==inf)continue;\n\tif(skill[j][k][0]!=inf && skill[i][k][1]<=skill[j][k][0])flag=true;\n\tif(skill[j][k][1]!=inf && skill[i][k][1]<=skill[j][k][1])flag=true;\n      }\n      if(flag)v[i].push_back(j);\n    }\n  }\n  for(int i=0;i<m;i++){\n    if(!checked[i])dfs(i);\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * Author:  vawait\n * Created Time:  2015/8/22 13:18:34\n * Problem: test.cpp\n */\n#include<cstdio>\n#include<iostream>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<string>\n#include<map>\n#include<set>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<ctime>\nusing namespace std;\n#define rep(i, a, b) for (int i = (a); i <= (b); ++i)\n#define red(i, a, b) for (int i = (a); i >= (b); --i)\n#define clr( x , y ) memset(x,y,sizeof(x))\n#define mp make_pair\n#define pb push_back\n#define x first\n#define y second\n#define sqr(x) ((x) * (x))\ntypedef long long lint;\nint n , m , a[110][110] , mx[110] , mi[110];\nchar s[10];\npair < int , int > g[110][110];\n\nvoid init()\n{\n    int l , r , x;\n    rep(i,1,m) {\n        rep(j,1,n) mx[j] = 110 , mi[j] = 0;\n        scanf(\"%d\",&x);\n        while ( x -- ) {\n            scanf(\"%d%s%d\",&l,s,&r);\n            if ( s[0] == '>' ) mi[l] = max( mi[l] , r );\n            else mx[l] = min( mi[l] , r );\n        }\n        rep(j,1,n) g[i][j] = mp( mi[j] , mx[j] );\n    }\n}\n\nvoid work()\n{\n    rep(i,1,m)\n        rep(j,1,n) if ( g[i][j].x > g[i][j].y ) {\n            puts(\"No\");\n            return;\n        }\n    clr( a , 0 );\n    rep(i,1,m)\n        rep(j,1,m) \n            rep(k,1,n) if ( g[i][k].y < g[j][k].x ) a[i][j] = 1;\n    rep(k,1,m)\n        rep(i,1,m)\n            rep(j,1,m) if ( a[i][k] && a[k][j] ) a[i][j] = 1;\n    rep(i,1,m) if ( a[i][i] ) {\n        puts(\"No\");\n        return;\n    }\n    puts(\"Yes\");\n}\n\nint main()\n{\n    while ( cin >> m >> n ) {\n        init();\n        work();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvector<int>G[100];\nint n,m;\nvector<pair<int,int> >s[100][2];\nint color[100];\nbool dfs(int u)\n{\n\tcolor[u]=1;\n\tbool ans=1;\n\tfor(int v:G[u])\n\t{\n\t\tif(!color[v])ans&=dfs(v);\n\t\telse\n\t\t{\n\t\t\tans&=color[v]==2;\n\t\t}\n\t}\n\tcolor[u]=2;\n\treturn ans;\n}\nmain()\n{\n\tcin>>n>>m;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint k;cin>>k;\n\t\tfor(;k--;)\n\t\t{\n\t\t\tint a,b;string t;\n\t\t\tcin>>a>>t>>b;\n\t\t\ta--;\n\t\t\ts[a][t==\">=\"].push_back(make_pair(b,i));\n\t\t}\n\t}\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tsort(s[i][0].begin(),s[i][0].end());\n\t\tsort(s[i][1].begin(),s[i][1].end());\n\t\tfor(int j=0;j<s[i][0].size();j++)\n\t\t{\n\t\t\tfor(int k=0;k<s[i][1].size();k++)\n\t\t\t{\n\t\t\t\tif(s[i][0][j].first<s[i][1][k].first)\n\t\t\t\t{\n\t\t\t\t\tG[s[i][0][j].second].push_back(s[i][1][k].second);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tbool flag=1;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(!color[i])flag&=dfs(i);\n\t}\n\tcout<<(flag?\"Yes\":\"No\")<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#if __has_include(\"../library/Basic/Debug.hpp\")\n\n#include \"../library/Basic/Debug.hpp\"\n\n#else\n\n/* ----- Header Files ----- */\n// IO\n#include <cstdio>\n#include <iomanip>\n#include <ios>\n#include <iostream>\n\n// algorithm\n#include <algorithm>\n#include <cmath>\n#include <numeric>\n\n// container\n#include <vector>\n#include <string>\n#include <tuple>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n\n// others\n#include <random>\n#include <limits>\n#include <functional>\n#include <ctime>\n#include <cassert>\n#include <cstdint>\n\n\n/* ----- Type Alias ----- */\nusing Bool = bool;\nusing Int = long long int;\nusing Real = long double;\nusing Char = char;\nusing String = std::string;\ntemplate <class... Ts>\nusing Tuple = std::tuple<Ts...>;\n\ntemplate <class T>\nusing Vector = std::vector<T>;\ntemplate <class T>\nusing Matrix = Vector<Vector<T>>;\ntemplate <class T>\nusing Queue = std::queue<T>;\ntemplate <class T>\nusing Stack = std::stack<T>;\ntemplate <class T>\nusing Deque = std::deque<T>;\n\ntemplate <class T>\nusing MaxHeap = std::priority_queue<T>;\ntemplate <class T>\nusing MinHeap = std::priority_queue<T, std::vector<T>, std::greater<T>>;\ntemplate <class T>\nusing Set = std::set<T>;\ntemplate <class T, class U>\nusing Map = std::map<T, U>;\n\ntemplate <class T, class... Us>\nusing Func = std::function<T(Us...)>;\n\ntemplate <class T>\nT genv(T v) { return v; }\n\ntemplate <class T, class... Ts>\nauto genv(size_t l, Ts... ts) {\n    return Vector<decltype(genv<T>(ts...))>(l, genv<T>(ts...));\n}\n\ntemplate <class Cost = Int>\nstruct Edge {\n    Int src, dst;\n    Cost cost;\n    Edge(Int src = -1, Int dst = -1, Cost cost = 1)\n        : src(src), dst(dst), cost(cost){};\n\n    bool operator<(const Edge<Cost>& e) const { return this->cost < e.cost; }\n    bool operator>(const Edge<Cost>& e) const { return this->cost > e.cost; }\n};\n\ntemplate <class Cost = Int>\nusing Edges = Vector<Edge<Cost>>;\ntemplate <class Cost = Int>\nusing Graph = Vector<Vector<Edge<Cost>>>;\n\n#endif\n\n/* ----- Misc ----- */\nvoid fastio() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(nullptr);\n}\n\nstruct Fout {\n    Int precision;\n    Fout(Int precision) : precision(precision) {}\n};\nstd::ostream& operator<<(std::ostream& os, const Fout& fio) {\n    os << std::fixed << std::setprecision(fio.precision);\n    return os;\n}\n\n\n/* ----- Constants ----- */\nconstexpr Int INF = std::numeric_limits<Int>::max() / 3;\n// constexpr Int MOD = 1000000007;\n// constexpr Real PI = acos(-1);\n// constexpr Real EPS = 1e-10;\n// std::mt19937 mt(int(std::time(nullptr)));\n\nint main() {\n    Int m, n;\n    std::cin >> m >> n;\n\n    Matrix<Int> l = genv<Int>(m, n, 0LL),\n                r = genv<Int>(m, n, INF);\n    for (Int i = 0; i < m; ++i) {\n        Int k;\n        std::cin >> k;\n\n        for (Int j = 0; j < k; ++j) {\n            Int s, t;\n            String c;\n            std::cin >> s >> c >> t;\n            --s;\n\n            if (c == \"<=\") {\n                r[i][s] = std::min(r[i][s], t);\n            } else {\n                l[i][s] = std::max(l[i][s], t);\n            }\n        }\n    }\n\n    Edges<Int> edges;\n    for (Int u = 0; u < m; ++u) {\n        for (Int v = 0; v < m; ++v) {\n            // uはvより前に習得しなければならないか\n            Bool judge = false;\n            for (Int i = 0; i < n; ++i) {\n                if (r[u][i] < l[v][i]) judge = true;\n            }\n\n            if (judge) edges.emplace_back(u, v, -1);\n        }\n    }\n\n    Bool ans = true;\n    Vector<Int> pot(m, 0);\n    for (Int i = 0; i < n * 2; ++i) {\n        for (auto e : edges) {\n            if (pot[e.dst] > pot[e.src] + e.cost) {\n                if (i == n * 2 - 1) ans = false;\n                pot[e.dst] = pot[e.src] + e.cost;\n            }\n        }\n    }\n\n    std::cout << (ans ? \"Yes\" : \"No\") << std::endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define l first\n#define r second\n#define INF (1e9)\nusing namespace std;\ntypedef pair <int,int> P;\nint ans=1,m,n,used[101],memo[101][101];\nP cmd[101][101];\n\nint check(int a,int b){\n  if(memo[a][b]!=-1) return memo[a][b];\n  for(int i=0;i<n;i++)\n    if(cmd[a][i].l>cmd[b][i].r) return memo[a][b]=0;\n  return memo[a][b]=1;\n}\n\nint solve(){\n  memset(memo,-1,sizeof(memo));\n  int cnt=0;\n  for(int i=0;i<m;i++){\n    int j=0;\n    while(used[i]&&j<m&&(used[j]||check(i,j)))j++;\n    if(j==m) used[i]=1,cnt++,i=-1;\n  }\n  return cnt/m;\n}\n\nint main(){\n  for(int i=0;i<101;i++)\n    for(int j=0;j<101;j++)cmd[i][j]=P(-INF,INF);\n\n  cin>>m>>n;\n  for(int i=0,k;i<m;i++){\n    cin>>k;\n    while(k--){\n      string cond;\n      int s,t;\n      cin>>s>>cond>>t;\n      s--;\n      if(cond==\"<=\")cmd[i][s].r=min(cmd[i][s].r,t);\n      if(cond==\">=\")cmd[i][s].l=max(cmd[i][s].l,t);\n      if(cmd[i][s].l>cmd[i][s].r)ans=0;\n    }\n  }\n\n  cout << (ans*solve()? \"Yes\":\"No\")<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\n//??????A[a,b]??¨??????B[c,d]?????¢???\nint intervalState(int a, int b, int c, int d){\n    if(a < c && b < c) return 0;            //A < B\n    else if(a > d && b > d) return 1;       //A > B\n    else if(a <= c && d <= b) return 2;     //A -> B\n    else if(c < a && b < d) return 3;       //B -> A\n    else if(a <= c && b < d) return 4;      //A <= B\n    else if(c < a && d <= b) return 5;      //A >= B\n    return -1;\n}\n\n//Give input directly to vector<pair<int, int>> in\nvector<pair<int, int>> JoinInterval(vector<pair<int,int>> in){\n    vector<pair<int, int>> v;\n    rep(i,in.size()) in[i].second *= -1;\n    sort(all(in));\n    rep(i,in.size()) in[i].second *= -1;\n\n    rep(i,in.size()){\n        if(v.empty()) v.emplace_back(in[i]);\n        else{\n            pair<int, int> &u = v.back();\n            int tmp = intervalState(in[i].first,in[i].second,u.first,u.second);\n            switch (tmp){\n                case 0:\n                case 1:\n                    v.emplace_back(in[i]);\n                    break;\n                case 2:\n                    u.first = in[i].first;\n                    u.second = in[i].second;\n                    break;\n                case 3:\n                    break;\n                case 4:\n                case 5:\n                    u.first = max(u.first, in[i].first);\n                    u.second = min(u.second, in[i].second);\n                    break;\n                case -1:\n                    assert(0);\n            }\n        }\n    }\n    sort(all(v));\n    return v;\n}\n\nint isBigger(vector<pair<int, int>> a, vector<pair<int, int>> b){\n    bool ret[6] = {0};\n    rep(i,101){\n        int tmp = intervalState(a[i].first,a[i].second,b[i].first,b[i].second);\n        assert(tmp <= 5);\n        ret[tmp] = true;\n    }\n    return ret[0] && ret[1];\n}\n\nint main(){\n    int m,n;\n    vector<pair<int,int>> v[105]; //v[i] := i??????????????????????????¶\n    rep(i,105) v[i] = vector<pair<int,int>>(105);\n    rep(i,105) rep(j,105) v[i][j] = make_pair(0,105);\n\n    cin >> m >> n;\n    rep(i,m){\n        int k;\n        cin >> k;\n        map<int,vector<pair<int, int>>> m;\n        rep(j,k){\n            int num, point;\n            string s;\n            cin >> num >> s >> point;\n            num--;\n\n            pair<int, int> p;\n            if(s[0] == '<') p = make_pair(0,point);\n            else p = make_pair(point,105);\n            m[num].emplace_back(p);\n        }\n        for(auto it : m){\n            vector<pair<int, int>> in = JoinInterval(it.second);\n            if(in.size() >= 2){\n                cout << \"No\" << endl;\n                return 0;\n            }\n            v[i][it.first] = in[0];\n        }\n    }\n    //rep(i,5){ rep(j,5){ cout << v[i][j].first << ' ' << v[i][j].second << endl; } cout << endl; } cout << endl;\n    rep(i,n){\n        rep(j,n - 1){\n            switch (isBigger(v[j],v[j + 1])) {\n                case 0:\n                    break;\n                case 1:\n                    cout << \"No\" << endl;\n                    return 0;\n                default:\n                    assert(1);\n            }\n        }\n    }\n    cout << \"Yes\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntemplate<typename T>\nstruct Edge {\n    int from, to;\n    T cost;\n    Edge(int from, int to, T cost) {\n        this->from = from;\n        this->to = to;\n        this->cost = cost;\n    }\n};\nbool operator == (Edge<int> e1, Edge<int> e2) {\n    return e1.from == e2.from &&\n            e1.to == e2.to &&\n            e1.cost == e2.cost;\n}\ntemplate<typename T>\nusing Edges = std::vector<Edge<T>>;\ntemplate<typename T>\nusing Graph = std::vector<Edges<T>>;\ntemplate<typename T>\nstd::vector<int> topological_sort(const Graph<T> &graph) {\n    Graph<T> g = graph;\n    int n = g.size();\n    std::vector<int> res;\n    std::queue<int> que;\n    std::vector<int> in(n);\n    std::vector<bool> used(n, false);\n    for(int i=0;i<n;++i) {\n        for(int j=0;j<(int)(g[i].size());++j) {\n            in[g[i][j].to]++;\n        }\n    }\n    for(int i=0;i<n;++i) {\n        if(in[i] == 0) que.push(i);\n    }\n    if((int)(que.size()) == 0) res.push_back(-1);\n    while(!que.empty()) {\n        int now = que.front(); que.pop();\n        if(used[now]) {\n            res.clear();\n            res.push_back(-1);\n            return res;\n        }\n        used[now] = true;\n        res.push_back(now);\n        for(int i=0;i<(int)(g[now].size());++i) {\n            int next = g[now][i].to;\n            if(in[next] == 1) {\n                que.push(next);\n        }\n            in[next]--;\n        }\n    }\n    return res;\n}\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nconst double eps = 1e-10;\nconst int MOD = 1000000007;\nconst int INF = 1000000000;\nconst ll LINF = 1ll<<50;\ntemplate<typename T>\nvoid printv(const vector<T>& s) {\n  for(int i=0;i<(int)(s.size());++i) {\n    cout << s[i];\n    if(i == (int)(s.size())-1) cout << endl;\n    else cout << \" \";\n  }\n}\nint main() {\n  cin.tie(0);\n  cout << fixed << setprecision(10);\n  int m, n; cin >> m >> n;\n  vector<vector<P>> v(m, vector<P>(n, {-1, INF}));\n  for(int i=0;i<m;++i) {\n    int k; cin >> k;\n    for(int j=0;j<k;++j) {\n      int s, t; string cond; cin >> s >> cond >> t;\n      s--;\n      if(cond == \"<=\") {\n        v[i][s] = {max(v[i][s].first, 0), min(v[i][s].second, t)};\n      } else {\n        v[i][s] = {max(v[i][s].first, t), min(v[i][s].second, 100)};\n      }\n    }\n  }\n  Graph<int> g(m);\n  bool ok = true;\n  for(int i=0;i<m;++i) {\n    if(!ok) break;\n    for(int j=0;j<n;++j) {\n      if(v[i][j].first > v[i][j].second) {\n        ok = false;\n        break;\n      }\n    }\n    if(!ok) break;\n    for(int j=i+1;j<m;++j) {\n      if(!ok) break;\n      int val = 0;\n      for(int k=0;k<n;++k) {\n        if(v[i][k].first == -1 || v[j][k].first == -1) continue;\n        if(v[i][k].first > v[j][k].second) {\n          if(val == 0) {\n            val = 1;\n          } else if(val == -1) {\n            ok = false;\n            break;\n          }\n        } else if(v[j][k].first > v[i][k].second) {\n          if(val == 0) {\n            val = -1;\n          } else if(val == 1) {\n            ok = false;\n            break;\n          }\n        }\n      }\n      if(val == 1) {\n        g[j].push_back(Edge<int>(j, i, 1));\n      } else if(val == -1) {\n        g[i].push_back(Edge<int>(i, j, 1));\n      }\n    }\n  }\n  if(ok) {\n    vector<int> tmp = topological_sort(g);\n    if((int)(tmp.size()) < m || tmp[0] == -1) {\n      cout << \"No\" << endl;\n    } else {\n      cout << \"Yes\" << endl;\n    }\n  } else {\n    cout << \"No\" << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nstruct skill{\n    int max,min;\n    skill(){\n        max=100;\n        min=1;\n    }\n};\n\ntypedef vector<int> V;\nvector<V> G(100);\nbool isVisited[100];\nbool isChecked[100];\n\nbool rec(int i){\n    isVisited[i]=true;\n    isChecked[i]=true;\n    for(auto&e:G[i]){\n        if(isVisited[e]){\n            return true;\n        }else if(!isChecked[e]){\n            if(rec(e)){\n                return true;\n            }\n        }\n    }\n    isVisited[i]=false;\n    return false;\n}\n\nint main(){\n    int M,N;\n    cin>>M>>N;\n    skill S[100][100];\n    for(int i=0;i<M;i++){\n        int K;\n        cin>>K;\n        for(int j=0;j<K;j++){\n            int s,t;\n            string cond;\n            cin>>s>>cond>>t;\n            s--;\n            if(cond==\"<=\"){//SP<=t\n                if(t<S[i][s].min){\n                    cout<<\"No\"<<endl;\n                    return 0;\n                }else if(t<S[i][s].max){\n                    S[i][s].max=t;\n                }\n            }else{//t<=SP\n                if(t>S[i][s].max){\n                    cout<<\"No\"<<endl;\n                    return 0;\n                }else if(t>S[i][s].min){\n                    S[i][s].min=t;\n                }\n            }\n        }\n    }\n    for(int i=0;i<M;i++){\n        for(int j=i+1;j<M;j++){\n            int i_over_j=0;\n            for(int k=0;k<N;k++){\n                if(S[i][k].min>S[j][k].max){\n                    if(i_over_j==-1){\n                        cout<<\"No\"<<endl;\n                        return 0;\n                    }else{\n                        i_over_j=1;\n                    }\n                }\n                if(S[i][k].max<S[j][k].min){\n                    if(i_over_j==1){\n                        cout<<\"No\"<<endl;\n                        return 0;\n                    }else{\n                        i_over_j=-1;\n                    }\n                }\n            }\n            if(i_over_j==1){\n                // cout<<i<<\"->\"<<j<<endl;\n                G[i].push_back(j);\n            }\n            if(i_over_j==-1){\n                // cout<<i<<\"<-\"<<j<<endl;\n                G[j].push_back(i);\n            }\n        }\n    }\n    for(int i=0;i<M;i++){\n        fill(isVisited,isVisited+100,false);\n        fill(isChecked,isChecked+100,false);\n        if(rec(i)){\n            cout<<\"No\"<<endl;\n        }\n    }\n    cout<<\"Yes\"<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\nint M,N,K[100],lb[100][100],ub[100][100];\nbool cant(int a,int b){\n\trep(i,N){\n\t\tif(lb[a][i]>ub[b][i]) return 1;\n\t}\n\treturn 0;\n}\nbool e[100][100];\nint main(){\n\tcin>>M>>N;\n\trep(i,M) rep(j,N) ub[i][j]=1e9;\n\trep(i,M){\n\t\tcin>>K[i];\n\t\trep(j,K[i]){\n\t\t\tint s,t;\n\t\t\tstring st;\n\t\t\tcin>>s>>st>>t;\n\t\t\tif(st[0]=='>') chmax(lb[i][s-1],t);\n\t\t\telse chmin(ub[i][s-1],t);\n\t\t}\n\t\trep(j,N){\n\t\t\tif(lb[i][j]>ub[i][j]){\n\t\t\t\tputs(\"No\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\trep(i,M) rep(j,M){\n\t\tif(i!=j&&cant(i,j)) e[i][j]=1;\n\t}\n\trep(i,M) rep(j,M) rep(k,M) if(e[j][i]&&e[i][k]) e[j][k]=1;\n\trep(i,M) if(e[i][i]){\n\t\tputs(\"No\");\n\t\treturn 0;\n\t}\n\tputs(\"Yes\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\n//??????A[a,b]??¨??????B[c,d]?????¢???\nint intervalState(int a, int b, int c, int d){\n    if(a < c && b < c) return 0;            //A < B\n    else if(a > d && b > d) return 1;       //A > B\n    else if(a <= c && d <= b) return 2;     //A -> B\n    else if(c < a && b < d) return 3;       //B -> A\n    else if(a <= c && b < d) return 4;      //A <= B\n    else if(c < a && d <= b) return 5;      //A >= B\n    return -1;\n}\n\n//Give input directly to vector<pair<int, int>> in\nvector<pair<int, int>> JoinInterval(vector<pair<int,int>> in){\n    vector<pair<int, int>> v;\n    rep(i,in.size()) in[i].second *= -1;\n    sort(all(in));\n    rep(i,in.size()) in[i].second *= -1;\n\n    rep(i,in.size()){\n        if(v.empty()) v.emplace_back(in[i]);\n        else{\n            pair<int, int> &u = v.back();\n            int tmp = intervalState(in[i].first,in[i].second,u.first,u.second);\n            switch (tmp){\n                case 0:\n                case 1:\n                    v.emplace_back(in[i]);\n                    break;\n                case 2:\n                    u.first = in[i].first;\n                    u.second = in[i].second;\n                    break;\n                case 3:\n                    break;\n                case 4:\n                case 5:\n                    u.first = max(u.first, in[i].first);\n                    u.second = min(u.second, in[i].second);\n                    break;\n                case -1:\n                    assert(0);\n            }\n        }\n    }\n    sort(all(v));\n    return v;\n}\n\nint isBigger(vector<pair<int, int>> a, vector<pair<int, int>> b){\n    rep(i,105) if(a[i].first < b[i].first) return 1;\n    rep(i,105) if(a[i].first > b[i].first) return 0;\n    rep(i,105) if(a[i].second < b[i].second) return 1;\n    rep(i,105) if(a[i].second > b[i].second) return 0;\n    return 0;\n}\n\nint main(){\n    int m,n;\n    vector<pair<int,int>> v[105]; //v[i] := i??????????????????????????¶\n    rep(i,105) v[i] = vector<pair<int,int>>(105);\n    rep(i,105) rep(j,105) v[i][j] = make_pair(0,105);\n\n    cin >> m >> n;\n    rep(i,m){\n        int k;\n        cin >> k;\n        map<int,vector<pair<int, int>>> m;\n        rep(j,k){\n            int num, point;\n            string s;\n            cin >> num >> s >> point;\n            num--;\n\n            pair<int, int> p;\n            if(s[0] == '<') p = make_pair(0,point);\n            else p = make_pair(point,105);\n            m[num].emplace_back(p);\n        }\n        for(auto it : m){\n            vector<pair<int, int>> in = JoinInterval(it.second);\n            if(in.size() >= 2){\n                cout << \"No\" << endl;\n                return 0;\n            }\n            v[i][it.first] = in[0];\n        }\n    }\n\n    rep(i,m){\n        rep(j,m - 1){\n            switch (isBigger(v[j],v[j + 1])) {\n                case 0:\n                    swap(v[j],v[j + 1]);\n                    //g[j][j + 1] = 1;\n                    break;\n                case 1:\n                    //g[j + 1][j] = 1;\n                    break;\n                case 2:\n                    break;\n                case -1:\n                    cout << \"No\" << endl;\n                    return 0;\n\n                default:\n                    assert(1);\n            }\n        }\n    }\n\n    //rep(i,m){ rep(j,n){ cout << v[i][j].first << ' ' << v[i][j].second << endl; } cout << endl; } cout << endl;\n    int point[105] = {0};\n    rep(i,m){\n        rep(j,n){\n            int tmp = intervalState(point[j], point[j], v[i][j].first, v[i][j].second);\n            switch (tmp) {\n                case 1:\n                    cout << \"No\" << endl;\n                    return 0;\n                case 0:\n                    point[j] = v[i][j].first;\n            }\n            //show(point[j])\n        }\n        //cout << endl;\n    }\n    cout << \"Yes\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\n#include <vector>\n\nusing namespace std;\n\n#define MAX 114\n\nvector<int> G[MAX];\nint col[MAX];\nbool found;\n\nvoid dfs(int v)\n{\n    col[v] = 0;\n    for(int i = 0 ; i < (int)G[v].size() ; i++){\n        int to = G[v][i];\n        if(col[to] == -1){\n            dfs(to);\n        }else if(col[to] == 0){\n            found = true;            \n            return;\n        }\n    }\n    col[v] = 1;\n}\n    \nint main()\n{\n    int M, N;\n    cin >> M >> N;\n    \n    auto canGraph = [=](){\n        int lb[MAX][MAX], ub[MAX][MAX];\n        for(int i = 0 ; i < MAX ; i++){\n            for(int j = 0 ; j < MAX ; j++){\n                lb[i][j] = -1;\n                ub[i][j] = 101;\n            }\n        }\n        int K, s, t;\n        string cond;\n        bool possible = 1;\n        for(int i = 0 ; i < M ; i++){\n            cin >> K;\n            for(int j = 0 ; j < K ; j++){\n                cin >> s >> cond >> t;\n                --s;\n                if(cond == \">=\"){\n                    lb[i][s] = max(lb[i][s], t);\n                }else{\n                    ub[i][s] = min(ub[i][s], t);\n                }\n            }\n            for(int j = 0 ; j < N ; j++){\n                if(lb[i][j] > ub[i][j]){\n                    possible = 0;\n                    break;\n                }\n            }\n        }\n\n        if(!possible) return false;\n\n        auto isConnect = [=](int from, int to){\n            for(int i = 0 ; i < N ; i++){\n                if(ub[from][i] < lb[to][i]){\n                    return true;\n                }\n            }\n            return false;\n        };\n        \n        for(int from = 0 ; from < M ; from++){\n            for(int to = 0 ; to < M ; to++){\n                if(from == to) continue;\n                if(isConnect(from, to)){\n                    G[from].push_back(to);\n                }\n            }\n        }\n        found = false;\n        memset(col, -1, sizeof(col));\n        for(int i = 0 ; i < M ; i++){\n            if(col[i] == -1){\n                dfs(i);\n            }\n        }                                       \n        return !found;\n    };\n    \n    cout << (canGraph() ? \"Yes\" : \"No\") << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define Fi first\n#define Se second\n#define INF (1<<29)\n#define EPS 1e-10\n#define MOD 1000000007\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint M, N;\nmap<int, pi>S[128];\nvector<int>G[128];\nvector<int>tpo[128];\n\nint is_edge(int src, int dist)\n{\n  for(auto x:S[src]){\n    int s = x.first, l = x.second.first, u = x.second.second;\n    if(!S[dist].count(s)) continue;\n    pi op = S[dist][s];\n    if(op.second < l) return 0;\n  }\n  return 1;\n}\n\nint dfs(int v, set<int>& sc)\n{\n  if(sc.size() == M && tpo[v].size() == M-1) return 1;\n  for(auto next: G[v]){\n    if(sc.count(next)) continue;\n    sc.insert(next);\n    if(dfs(next, sc)) return 1;\n    sc.erase(next);\n  }\n  return 0;\n}\n\nint solve()\n{\n  rep(i, M){\n    set<int>sc; sc.insert(i);\n    if(dfs(i, sc)) return 1;\n  }\n  return 0;\n}\n\n\nint main()\n{\n  cin >> M >> N;\n  rep(i, M){\n    int K;  cin >> K;\n    rep(j, K){\n      int s, t; string cond;\n      cin >> s >> cond >> t;\n      int c = 0;\n      if(cond == \"<=\") c = 1;\n      if(!S[i].count(s)) S[i][s] = pi(0, INF);\n      pi p = S[i][s];\n      if(c) S[i][s] = pi(p.first, min(t, p.second));\n      else  S[i][s] = pi(max(t, p.first), p.second);\n    }\n  }\n\n  rep(i, M) for(auto x:S[i]){\n    pi p = x.second;\n    //    cout << p.first << \" \" << p.second << endl;\n    if(p.first > p.second){\n      cout << \"No\\n\";\n      return 0;\n    }\n  }\n\n  rep(i, M) rep(j, M){\n    if(i == j) continue;\n    if(is_edge(i, j)){\n      G[i].push_back(j);\n      tpo[j].push_back(i);\n      //      cout << i << \" \" << j << endl;\n    }\n  }\n\n  cout << (solve()?\"Yes\":\"No\") << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\n\nint M, N;\nint K[110];\nint s[110][110], t[110][110];\nstring cond[110][110];\nvector<int> G[110];\nint indeg[110];\n\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  \n  cin >> M >> N;\n  for (int i = 0; i < M; i++) {\n    cin >> K[i];\n    for (int j = 0; j < K[i]; j++) {\n      cin >> s[i][j] >> cond[i][j] >> t[i][j];\n    }\n  }  \n  bool no = false;\n  for (int i = 0; i < M; i++) {\n    for (int j = 0; j < K[i]; j++) {\n      for (int k = 0; k < K[i]; k++) {\n        if (s[i][j] != s[i][k] || cond[i][j] == cond[i][k]) {\n          continue;\n        }\n        if (cond[i][j] == \">=\") {\n          no |= t[i][j] > t[i][k];\n        } else {\n          no |= t[i][j] < t[i][k];\n        }\n      }\n    }\n  }\n  if (no) {\n    cout << \"No\" << endl;\n    return 0;\n  }\n  for (int i = 0; i < M; i++) {\n    for (int j = 0; j < M; j++) {\n      if (i == j) continue;\n      for (int k = 0; k < K[i]; k++) {\n        for (int l = 0; l < K[j]; l++) {\n          if (s[i][k] != s[j][l] || cond[i][k] == cond[j][l]) {\n            continue;\n          }\n          if (cond[i][k] == \"<=\" && t[i][k] < t[j][l]) {\n            G[i].emplace_back(j);\n            indeg[j]++;\n          }\n        }\n      }\n    }\n  }\n  stack<int> st;\n  for (int i = 0; i < M; i++) {\n    if (!indeg[i]) st.emplace(i);\n  }\n  map<int, int> mp;\n  while (!st.empty()) {\n    int cur = st.top();\n    st.pop();\n    mp[cur]++;\n    for (int nxt : G[cur]) {\n      if (--indeg[nxt]) continue;\n      st.emplace(nxt);\n    }\n  }\n  cout << (mp.size() == M ? \"Yes\" : \"No\") << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n\nclass Requirement{\npublic:\n  int upper;\n  int lower;\n  Requirement() : upper(INF),lower(0) {}\n  Requirement(int _u,int _l) : upper(_u),lower(_l) {}\n};\n\nint total_commands;\nint total_skills;\n\nbool check_path(int from_command,int to_command,\n\t\tRequirement requirement[101][101]){\n  for(int skill_id = 1; skill_id <= total_skills;skill_id++){\n    if(requirement[from_command][skill_id].lower\n       > requirement[to_command][skill_id].upper){\n      return false;\n    }\n    // if(requirement[from_command][skill_id].upper\n    //    < requirement[to_command][skill_id].lower){\n    //   return false;\n    // }\n  }\n  return true;\n}\n\nint main(){\n  while(~scanf(\"%d %d\",&total_commands,&total_skills)){\n    Requirement requirement[101][101];\n\n    bool is_valid[101];\n    memset(is_valid,true,sizeof(is_valid));\n    for(int command_idx = 0; command_idx < total_commands; command_idx++){\n      int total_conditions;\n      scanf(\"%d\",&total_conditions);\n      for(int condition_idx = 0; condition_idx < total_conditions; condition_idx++){\n\tint skill_id;\n\tstring symbol;\n\tint required_point;\n\tcin >> skill_id >> symbol >> required_point;\n\tif(symbol == \">=\") {\n\t  requirement[command_idx][skill_id].lower\n\t    = max(required_point,requirement[command_idx][skill_id].lower);\n\t}\n\telse if(symbol == \"<=\"){\n\t  requirement[command_idx][skill_id].upper\n\t    = min(required_point,requirement[command_idx][skill_id].lower);\n\t}\n\t\n\tif(requirement[command_idx][skill_id].lower\n\t   > requirement[command_idx][skill_id].upper){\n\t  is_valid[command_idx] = false;\n\t}\n      }\n    }\n\n    \n    bool edge[101][101];\n    //init\n    for(int from = 0; from < total_commands; from++){\n      for(int to = 0; to < total_commands; to++){\n\tedge[from][to] = check_path(from,to,requirement);\n      }\n    }\n\n    bool used[101];\n    memset(used,false,sizeof(used));\n\n    for(int round = 0; round < total_commands; round++){\n      for(int start = 0; start < total_commands; start++){\n\tif(!is_valid[start]) continue;\n\t\n\tbool select = true;\n\tfor(int to = 0; to < total_commands; to++){\n\t  if(!edge[start][to] && !used[to]){\n\t    select = false;\n\t  }\n\t}\n\t\n\tif(select){\n\t  used[start] = true;\n\t}\n      }\n    }\n    \n    int count = 0;\n    for(int command_idx=0;command_idx<total_commands;command_idx++){\n      if(used[command_idx]) count++;\n    }\n    printf(\"%s\\n\",(count == total_commands) ? \"Yes\" : \"No\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\nint M, N, ub[111][111], lb[111][111], skill[111];\n\nint main() {\n\tcin >> M >> N;\n\t\n\tfor_(i,0,M) for_(j,0,N) {\n\t\tub[i][j] = 100;\n\t\tlb[i][j] = 0;\n\t}\n\t\n\tfor_(i,0,M) {\n\t\tint K;\n\t\tcin >> K;\n\t\t\n\t\tfor_(j,0,K) {\n\t\t\tint s, t;\n\t\t\tstring cnd;\n\t\t\tcin >> s >> cnd >> t;\n\t\t\t--s;\n\t\t\t\n\t\t\tif (cnd == \">=\") lb[i][s] = max(lb[i][s], t);\n\t\t\telse ub[i][s] = min(ub[i][s], t);\n\t\t}\n\t\t\n\t\tfor_(j,0,N) if (ub[i][j] < lb[i][j]) {\n\t\t\tcout << \"No\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tmemset(skill, 0, sizeof(skill));\n\t\n\tunordered_set< int > learned;\n\t\n\twhile ((int)learned.size() < N) {\n\t\tint tar = -1;\n\t\t\n\t\tfor_(i,0,N) {\n\t\t\tbool isok = true;\n\t\t\t\n\t\t\tfor_(j,0,M) {\n\t\t\t\tif (learned.count(j)) continue;\n\t\t\t\tisok &= (skill[i] + 1 <= ub[j][i]);\n\t\t\t}\n\t\t\t\n\t\t\tif (isok) {\n\t\t\t\ttar = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (tar == -1) {\n\t\t\tcout << \"No\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\t++skill[tar];\n\t\t\n\t\tfor_(i,0,M) {\n\t\t\tbool learn = true;\n\t\t\tfor_(j,0,N) learn &= (lb[i][j] <= skill[j] && skill[j] <= ub[i][j]);\n\t\t\tif (learn) learned.insert(i);\n\t\t}\n\t}\n\t\n\tcout << \"Yes\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\ntypedef pair<int,int> pii;\n#define mkp make_pair\nint INF=INT_MAX/2;\nint m,n;\nvector<vector<pii>> v;\nvector<vector<int>> vv;\nvector<int> used;\nbool foo(int a){\n    // cout<<\"a \"<<a<<endl;\n    if(used[a]) return false;\n    used[a]=1;\n    for(int x:vv[a]){\n        // cout<<\"x \"<<x<<endl;\n        if(!foo(x)){\n            used[a]=0;\n            return false; \n        }\n    }\n    used[a]=0;\n    return true;\n}\nint main(){\n    cin>>m>>n;\n    used=vector<int>(m,0);\n    v=vector<vector<pii>>(m,vector<pii>(n,pii(0,INF)));\n    rep(i,m){\n        int K;\n        cin>>K;\n        rep(j,K){\n            int a,b;\n            string s;\n            cin>>a>>s>>b;\n            if(s==\">=\"){\n                v[i][a-1].first=b;\n            }\n            else{\n                v[i][a-1].second=b;\n            }\n        }\n    }\n    vv=vector<vector<int>>(m);\n    rep(i,m){\n        rep(j,m){\n            bool f=false;\n            rep(k,n){\n                if(v[i][k].first>v[j][k].second) f=true;\n            }\n            if(f){\n                // cout<<i<<\" \"<<j<<endl;\n                vv[i].push_back(j);\n            }\n        }\n    }\n    // return 0;\n    bool f=true;\n    rep(i,m){\n        if(!foo(i)) f=false;\n    }\n    if(f) cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\nstruct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nbool isDAG(vector<vector<int>>& G) {\n  int N = G.size();\n  vector<bool> vis(N);\n\n  std::function<bool(int, unordered_set<int>&)> dfs = [&](int curr, unordered_set<int>& st) {\n    for(auto&& e: G[curr]) {\n      if(st.count(e)) return false;\n      if(vis[e]) continue;\n      st.insert(e);\n      vis[e] = 1;\n      if(!dfs(e, st)) return false;\n      st.erase(e);\n    }\n    return true;\n  };\n\n  vector<int> deg(N);\n\n  rep(i, N)\n    for(auto&& e: G[i])\n      deg[e]++;\n\n  vector<int> starts;\n\n  rep(i, N)\n    if(deg[i] == 0)\n      starts.push_back(i);\n\n  if(starts.empty()) return false;\n\n  for(auto&& e: starts) {\n    vis[e] = 1;\n    unordered_set<int> st;\n    if(!dfs(e, st)) return false;\n  }\n  return true;\n}\n\nint main() {\n\n  int M, N; cin >> M >> N;\n\n  // テ・ツ青?」ツつケテ」ツつュテ」ツδォテヲツッツ偲」ツ?ォテ」ツつウテ」ツδ榲」ツδウテ」ツδ嘉」ツ?ョテ・ツ個コテゥツ鳴禿」ツつ津ヲツ個?」ツ?、\n  vector<vector<pair<int, int>>> cmd_sect(N, vector<pair<int, int>>(M, {0, inf}));\n\n  rep(cmd_idx, M) {\n    int K; cin >> K;\n    rep(_, K) {\n      int skill; cin >> skill; skill--;\n      string op; cin >> op;\n      int threshold; cin >> threshold;\n      if(op == \">=\") {\n        cmd_sect[skill][cmd_idx].first = max(cmd_sect[skill][cmd_idx].first, threshold);\n      } else {\n        cmd_sect[skill][cmd_idx].second = min(cmd_sect[skill][cmd_idx].second, threshold);\n      }\n      if(cmd_sect[skill][cmd_idx].first > cmd_sect[skill][cmd_idx].second) {\n        cout << \"No\" << endl;\n        return 0;\n      }\n    }\n  }\n\n  vector<vector<int>> G(M);\n  \n  rep(i, N) {\n    rep(a, M) rep(b, M) {\n      if(a == b) continue;\n      if(cmd_sect[i][a].second < cmd_sect[i][b].first)\n        G[a].push_back(b);\n    }\n  }\n\n  rep(i, M) {\n    sort(all(G[i]));\n    G[i].erase(unique(all(G[i])), G[i].end());\n  }\n\n  cout << (isDAG(G) ? \"Yes\" : \"No\") << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n//repetition\n#define FOR(i,a,b) for(ll i=(a);i<(b);++i)\n#define rep(i, n) for(ll i = 0; i < (ll)(n); i++)\n\n//container util\n#define all(x) (x).begin(),(x).end()\n\n//typedef\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<ll, ll> PLL;\n\n//const value\n//const ll MOD = 1e9 + 7;\n//const int dx[] = {0,1,0,-1};//{0,0,1,1,1,-1,-1,-1};\n//const int dy[] = {1,0,-1,0};//{1,-1,0,1,-1,0,1,-1};\n\n//conversion\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ninline ll toLL(string s) {ll v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\nint n,m;\nvector<PII> USkills[101];\nvector<PII> DSkills[101];\nbool used[101];\n\nbool check(int idx, vector<PII>& current){\n  vector<PII> cc(n,{0,1e9});\n  for(PII p : USkills[idx]){\n    int s = p.first;\n    cc[s].first = max(cc[s].first,p.second);\n  }\n\n  for(PII p : DSkills[idx]){\n    int s = p.first;\n    cc[s].second = min(p.second,cc[s].second);\n    if(cc[s].second < cc[s].first) return false;\n  }\n\n  used[idx] = true;\n  bool pass = true;\n  // cout << \"cc\" << endl;\n  // rep(i,m){\n  //   cout << cc[i].first << \" \" << cc[i].second << endl;\n  // }\n  // cout << \"cc end------------\" << endl;\n\n  rep(i,m){\n    if(used[i] == true) continue;\n    // for(PII p : USkills[i]){\n    //   int s = p.first;\n    //   // cout << cc[s].first << \" <= \" << p.second << \" <= \" <<  cc[s].second << endl;\n    //   if(cc[s].first <= p.second) continue;\n    //   else{\n    //     pass = false;\n    //     break;\n    //   }\n    // }\n\n    for(PII p : DSkills[i]){\n      int s = p.first;\n      if(p.second >= cc[s].first) continue;\n      else{\n        pass = false;\n        break;\n      }\n    }\n\n    if(pass == false) break;\n  }\n\n  if(pass == false) {\n    used[idx] = false;\n    return false;\n  }\n\n  current = cc;\n  return true;\n}\n\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  cin >> m >> n;\n\n  rep(i,m){\n    int k;\n    cin >> k;\n    int s,t;\n    string cmd;\n\n    rep(j,k){\n      cin >> s >> cmd >> t;\n      s--;\n      if(cmd == \"<=\"){\n        DSkills[i].push_back({s,t});\n      }else if(cmd == \">=\"){\n        USkills[i].push_back({s,t});\n      }\n    }\n  }\n\n  int okCnt = 0;\n  vector<PII> current(n,{0,1e9});\n  while(okCnt < m){\n    bool flag = false;\n    rep(i,m){\n      if(used[i] == false && check(i,current)){\n        // cout << \"used \" << i << endl;\n        flag = true;\n        break;\n      }\n    }\n    if(flag == false) {\n      cout << \"No\" << \"\\n\";\n      return 0;\n    }\n    okCnt++;\n  }\n\n  cout << \"Yes\" << \"\\n\";\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint m,n;\nint k[101];\nint data[101][101][2];\nint s[101][101],cond[101][101],t[101][101];\nvector<int> G[101];\nvector<int> rG[101];\nvector<int> vs;\nbool used[101];\nint cmp[101];\nint now[101][101];\n\nvoid add_edge(int f,int t){\n\tG[f].push_back(t);\n\tG[t].push_back(f);\n}\n\nvoid dfs(int v){\n\tused[v]=true;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tif(!used[G[v][i]])dfs(G[v][i]);\n\t}\n\tvs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n\tused[v]=true;\n\tcmp[v]=k;\n\tfor(int i=0;i<rG[v].size();i++){\n\t\tif(!used[rG[v][i]])rdfs(rG[v][i],k);\n\t}\n}\n\nvoid cdfs(int v){\n\tused[v]=true;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tif(!used[G[v][i]] && cmp[v]+1>=cmp[G[v][i]])cdfs(G[v][i]);\n\t}\n}\n\nbool scc(){\n\tmemset(used,0,sizeof(used));\n\tfor(int i=0;i<m;i++){\n\t\tif(!used[i])dfs(i);\n\t}\n\tmemset(used,0,sizeof(used));\n\tint k=0;\n\tfor(int i=vs.size()-1;i>=0;i--){\n\t\tif(!used[vs[i]])rdfs(vs[i],k++);\n\t}\n\tmemset(used,0,sizeof(used));\n\tcdfs(vs[vs.size()-1]);\n\tfor(int i=0;i<m;i++){\n\t\tif(!used[i])return false;\n\t}\n\treturn true;\n}\n\nbool ddfs(int v,int depth){\n\tif(v>=0)used[v]=true;\n\tif(depth==m)return true;\n\tif(v==-1){\n\t\tfor(int i=0;i<m;i++){\n\t\t\tif(used[i])continue;\n\t\t\tint k;\n\t\t\tfor(k=1;k<=n;k++){\n\t\t\t\tif(now[depth][k]>data[i][k][1])break;\n\t\t\t\tif(now[depth][k]<data[i][k][0])now[depth+1][k]=data[i][k][0];\n\t\t\t\telse now[depth+1][k]=now[depth][k];\n\t\t\t}\n\t\t\tif(k==n+1){\n\t\t\t\tif(ddfs(i,depth+1))return true;\n\t\t\t}\n\t\t}\n\t}else{\n\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\tif(used[G[v][i]])continue;\n\t\t\tint k;\n\t\t\tfor(k=1;k<=n;k++){\n\t\t\t\tif(now[depth][k]>data[G[v][i]][k][1])break;\n\t\t\t\tif(now[depth][k]<data[G[v][i]][k][0])now[depth+1][k]=data[G[v][i]][k][0];\n\t\t\t\telse now[depth+1][k]=now[depth][k];\n\t\t\t}\n\t\t\tif(k==n+1){\n\t\t\t\tif(ddfs(G[v][i],depth+1))return true;\n\t\t\t}\n\t\t}\n\t}\n\tif(v>=0)used[v]=false;\n\treturn false;\n}\n\nint main(void){\n\tscanf(\"%d %d\",&m,&n);\n\tfor(int i=0;i<=100;i++){\n\t\tfor(int j=0;j<=100;j++){\n\t\t\tdata[i][j][0]=0;\n\t\t\tdata[i][j][1]=101;\n\t\t}\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tscanf(\"%d\",&k[i]);\n\t\tfor(int j=0;j<k[i];j++){\n\t\t\tchar d;\n\t\t\tscanf(\"%d %c%*c %d\",&s[i][j],&d,&t[i][j]);\n\t\t\tif(d=='<')cond[i][j]=0;\n\t\t\telse cond[i][j]=1;\n\t\t}\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tfor(int j=0;j<k[i];j++){\n\t\t\tif(cond[i][j]==0)data[i][s[i][j]][1]=min(t[i][j],data[i][s[i][j]][1]);\n\t\t\tif(cond[i][j]==1)data[i][s[i][j]][0]=max(t[i][j],data[i][s[i][j]][0]);\n\t\t\tif(data[i][s[i][j]][1]<data[i][s[i][j]][0]){\n\t\t\t\tprintf(\"No\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tfor(int j=0;j<m;j++){\n\t\t\tif(i==j)continue;\n\t\t\tint k;\n\t\t\tfor(k=1;k<=n;k++){\n\t\t\t\tif(data[i][k][0]>data[j][k][1])break;\n\t\t\t}\n\t\t\tif(k==n+1){\n\t\t\t\tadd_edge(i,j);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%s\\n\",ddfs(-1,0)?\"Yes\":\"No\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nconst int My_Inf=2147483647;\nconst long long int My_LInf=9223372036854775807;\n\nint M;\n\nvoid dfs(vector<bool>&transs, const int now,const vector<vector<bool>>&edges) {\n\ttranss[now] = true;\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (edges[now][i] && !transs[i]) {\n\t\t\tdfs(transs, i, edges);\n\t\t}\n\t}\n\treturn;\n}\n\nint main() {\n\tint  N; cin >> M >> N;\n\tvector<vector<vector<pair<bool, int>>>>conds(M, vector<vector<pair<bool, int>>>(N, vector<pair<bool, int>>(2, make_pair(false, 0))));\n\tfor (int i = 0; i < M; ++i) {\n\t\tint K; cin >> K;\n\t\tfor (int j = 0; j < K; ++j) {\n\t\t\tint s, t; string st; cin >> s >> st >> t;\n\t\t\ts--; \n\t\t\tbool ku = (st == \"<=\");\n\t\t\tif (!conds[i][s][ku].first) {\n\t\t\t\tconds[i][s][ku].first = true;\n\t\t\t\tconds[i][s][ku].second = t;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (ku) {\n\t\t\t\t\tconds[i][s][ku].second = min(conds[i][s][ku].second, t);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tconds[i][s][ku].second = max(conds[i][s][ku].second, t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tbool aaok = true;\n\tfor (int i = 0; i < M; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tif (conds[i][j][0].first&&conds[i][j][1].first) {\n\t\t\t\tif (conds[i][j][0].second>conds[i][j][1].second)aaok = false;\n\t\t\t}\n\t\t}\n\t}\n\tif (aaok) {\n\t\tvector<vector<bool>>edges(M, vector<bool>(M));\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tfor (int j = 0; j < M; ++j) {\n\t\t\t\tbool ok = true;\n\t\t\t\tfor (int k = 0; k < N; ++k) {\n\t\t\t\t\tif (conds[i][k][0].first&&conds[j][k][1].first) {\n\t\t\t\t\t\tif (conds[i][k][0].second>conds[j][k][1].second)ok = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tedges[i][j] = ok;\n\t\t\t}\n\t\t}\n\t\tbool aok = false;\n\t\tfor (int from = 0; from < M; ++from) {\n\t\t\tvector<bool>transs(M);\n\t\t\tdfs(transs, from, edges);\n\t\t\tif (all_of(transs.begin(), transs.end(), [](const bool b) {return b; })) {\n\t\t\t\taok = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (aok) {\n\t\t\tcout << \"Yes\" << endl;\n\n\t\t}\n\t\telse {\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\t\treturn 0;\n\t}\n\tcout << \"No\" << endl;\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nconst int inf = 1e9;\n\nint main(){\n    int m,n;\n    cin >> m >> n;\n    vector<vector<vector<int> > > cond(m, vector<vector<int> >(n+1, vector<int>(2)));\n    for(int i=0; i<m; i++){\n        for(int j=1; j<=n; j++){\n            cond[i][j][0] = inf;\n            cond[i][j][1] = -1;\n        }\n    }\n    \n    for(int i=0; i<m; i++){\n        int k;\n        cin >> k;\n        for(int j=0; j<k; j++){\n            int s,t;\n            string c;\n            cin >> s >> c >> t;\n            int sl = (c==\"<=\")? 0: 1;\n            if(sl==0){\n                cond[i][s][sl] = min(cond[i][s][sl], t);\n            }else{\n                cond[i][s][sl] = max(cond[i][s][sl], t);\n            }\n        }\n    }\n    for(int i=0; i<m; i++){\n        for(int j=1; j<=n; j++){\n            if(cond[i][j][0] < cond[i][j][1]){\n                cout << \"No\" << endl;\n                return 0;\n            }\n        }\n    }\n\n    vector<vector<int> > adj(m, vector<int>(m, inf));\n    for(int i=0; i<m; i++){\n        for(int j=0; j<m; j++){\n            for(int k=1; k<=n; k++){\n                if(cond[i][k][0] < cond[j][k][1]){\n                    adj[i][j] = 0;\n                    break;\n                }\n            }\n        }\n    }\n\n\tfor(int k=0; k<m; k++){\n\t\tfor(int i=0; i<m; i++){\n\t\t\tfor(int j=0; j<m; j++){\n\t\t\t\tadj[i][j] = min(adj[i][j], adj[i][k]+adj[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tbool flag = true;\n\tfor(int i=0; i<m; i++){\n\t\tfor(int j=i+1; j<m; j++){\n\t\t\tif(adj[i][j]==0 && adj[j][i]==0){\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n    if(flag){\n        cout << \"Yes\" << endl;\n    }else{\n        cout << \"No\" << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n#define INF (1<<26)\nint M,N;\nint K[100];\nint s[100][100];\nstring cond[100][100];\nint t[100][100];\n\nint A[100][100];\nint B[100];\n\nint check(int a,int b){\n  int L[100],R[100];\n  for(int i=0;i<100;i++){\n    L[i]=0;\n    R[i]=INF;\n  }\n  for(int i=0;i<K[a];i++){\n    if(cond[a][i]==\">=\"){\n      L[s[a][i]]=max(L[s[a][i]],t[a][i]);\n    }else{\n      R[s[a][i]]=min(R[s[a][i]],t[a][i]);\n    }\n  }\n\n  for(int i=0;i<100;i++)\n    if(L[i]>R[i])return 0;\n  \n  for(int i=0;i<K[b];i++){\n    if(cond[b][i]==\">=\"){\n      L[s[b][i]]=max(L[s[b][i]],t[b][i]);\n    }else{\n      R[s[b][i]]=min(R[s[b][i]],t[b][i]);\n      if(L[s[b][i]] > R[s[b][i]])return 0;\n    }\n  }\n\n\n  return 1;\n}\n\nint main(){\n  cin>>M>>N;\n  for(int i=0;i<M;i++){\n    cin>>K[i];\n    for(int j=0;j<K[i];j++){\n      cin>>s[i][j]>>cond[i][j]>>t[i][j];\n      s[i][j]--;\n    }\n  }\n\n  \n  for(int i=0;i<M;i++){\n    for(int j=0;j<M;j++){\n      A[i][j]=check(i,j);\n    }\n  }\n\n\n  bool flg=true;\n\n  for(int i=0;i<M;i++){\n    \n    for(int j=0;j<M;j++){\n      B[j]=0;\n      for(int k=0;k<M;k++){\n        B[j]+=A[j][k];\n      }\n    }\n      \n    int id=-1,maxm=-1;\n    for(int j=0;j<M;j++){\n      if(maxm<B[j]){\n        maxm=B[j];\n        id=j;\n      }\n    }\n    \n    if(maxm<M-i)flg=false;\n    \n    for(int j=0;j<M;j++){\n      A[j][id]=0;\n      A[id][j]=0;\n    }\n  \n  }\n\n  cout<<(flg?\"Yes\":\"No\")<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nstruct skill{\n  int c,t;\n  skill(){}\n  skill(int c,int t):c(c),t(t){}\n};\nvector<vector<int> > G;\nbool used[111];\nbool dfs(int v){\n  if(used[v]) return 0;\n  used[v]=1;\n  bool f=1;\n  for(int i=0;i<(int)G[v].size();i++) f&=dfs(G[v][i]);\n  return f;\n}\nint main(){\n  int m,n;\n  cin>>m>>n;\n  vector<skill> ss[m][n];\n  for(int i=0;i<m;i++){\n    int k;\n    cin>>k;\n    for(int j=0;j<k;j++){\n      int s,t;\n      string c;\n      cin>>s>>c>>t;\n      ss[i][s-1].push_back(skill(c==\"<=\",t));\n    }\n  }\n  G.resize(m);\n  for(int i=0;i<m;i++){\n    for(int j=0;j<m;j++){\n      bool f=0;\n      for(int k=0;k<n;k++){\n\tfor(int x=0;x<(int)ss[i][k].size();x++){\n\t  for(int y=0;y<(int)ss[j][k].size();y++){\n\t    if(ss[i][k][x].t<=ss[j][k][y].t){\n\t      f|=(ss[i][k][x].c==1&&ss[j][k][y].c==0);\n\t    }\n\t  }\n\t}\n      }\n      if(f) G[j].push_back(i);\n    }\n  }\n  memset(used,0,sizeof(used));\n  cout<<(dfs(0)?\"Yes\":\"No\")<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n\nclass Requirement{\npublic:\n  int upper;\n  int lower;\n  Requirement() : upper(INF),lower(0) {}\n  Requirement(int _u,int _l) : upper(_u),lower(_l) {}\n};\n\nint total_commands;\nint total_skills;\n\nbool check_path(int from_command,int to_command,\n\t\tRequirement requirement[101][101]){\n  for(int skill_id = 1; skill_id <= total_skills;skill_id++){\n    if(requirement[from_command][skill_id].lower\n       > requirement[to_command][skill_id].upper){\n      return false;\n    }\n    // if(requirement[from_command][skill_id].upper\n    //    < requirement[to_command][skill_id].lower){\n    //   return false;\n    // }\n  }\n  return true;\n}\n\nint main(){\n  while(~scanf(\"%d %d\",&total_commands,&total_skills)){\n    Requirement requirement[101][101];\n\n    bool skill_flag = true;\n    for(int command_idx = 0; command_idx < total_commands; command_idx++){\n      int total_conditions;\n      scanf(\"%d\",&total_conditions);\n      for(int condition_idx = 0; condition_idx < total_conditions; condition_idx++){\n\tint skill_id;\n\tstring symbol;\n\tint required_point;\n\tcin >> skill_id >> symbol >> required_point;\n\tif(symbol == \">=\") {\n\t  requirement[command_idx][skill_id].lower\n\t    = max(required_point,requirement[command_idx][skill_id].lower);\n\t}\n\telse if(symbol == \"<=\"){\n\t  requirement[command_idx][skill_id].upper\n\t    = min(required_point,requirement[command_idx][skill_id].lower);\n\t}\n\t\n\tif(requirement[command_idx][skill_id].lower\n\t   > requirement[command_idx][skill_id].upper){\n\t  skill_flag = false;\n\t}\n      }\n    }\n\n    \n    bool edge[total_commands][total_commands];\n    //init\n    for(int from = 0; from < total_commands; from++){\n      for(int to = 0; to < total_commands; to++){\n\tedge[from][to] = check_path(from,to,requirement);\n      }\n    }\n\n    bool isok = false;\n    bool used[101];\n    memset(used,false,sizeof(used));\n\n    int count = 0;\n    for(int round = 0;round < total_commands;round++){\n      for(int from = 0;from < total_commands;from++){\n\tif(used[from]) continue;\n\n\tbool flag = true;\n\tfor(int to = 0; to < total_commands; to++){\n\t  if(!edge[from][to] && !used[to]){\n\t    flag = false;\n\t  }\n\t}\n\n\tif(flag){\n\t  used[from] = true;\n\t  count++;\n\t  break;\n\t}\n      }\n    }\n    \n    if(count == total_commands){\n      isok = true;\n    }\n\n    printf(\"%s\\n\",(isok && skill_flag) ? \"Yes\" : \"No\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\nint M,N,K[100],lb[100][100],ub[100][100];\nbool can(int a,int b){\n\trep(i,N){\n\t\tif(lb[a][i]>ub[b][i]) return 0;\n\t}\n\treturn 1;\n}\nint main(){\n\tcin>>M>>N;\n\trep(i,M) rep(j,N) ub[i][j]=1e8;\n\trep(i,M){\n\t\tcin>>K[i];\n\t\trep(j,K[i]){\n\t\t\tint s,t;\n\t\t\tstring st;\n\t\t\tcin>>s>>st>>t;\n\t\t\tif(st[0]=='>') chmax(lb[i][s-1],t);\n\t\t\telse chmin(ub[i][s-1],t);\n\t\t}\n\t\trep(j,N){\n\t\t\tif(lb[i][j]>ub[i][j]){\n\t\t\t\tputs(\"No\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\trep(i,M) rep(j,i){\n\t\tif(!can(i,j)&&!can(j,i)){\n\t\t\tputs(\"No\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tputs(\"Yes\");\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n\nclass Requirement{\npublic:\n  int upper;\n  int lower;\n  Requirement() : upper(INF),lower(0) {}\n  Requirement(int _u,int _l) : upper(_u),lower(_l) {}\n};\n\nint total_commands;\nint total_skills;\n\nbool check_path(int from_command,int to_command,\n\t\tRequirement requirement[101][101]){\n  for(int skill_id = 1; skill_id <= total_skills;skill_id++){\n    if(requirement[from_command][skill_id].lower\n       > requirement[to_command][skill_id].upper){\n      return false;\n    }\n    // if(requirement[from_command][skill_id].upper\n    //    < requirement[to_command][skill_id].lower){\n    //   return false;\n    // }\n  }\n  return true;\n}\n\nint main(){\n  while(~scanf(\"%d %d\",&total_commands,&total_skills)){\n    Requirement requirement[101][101];    \n    for(int command_idx = 0; command_idx < total_commands; command_idx++){\n      int total_conditions;\n      scanf(\"%d\",&total_conditions);\n      for(int condition_idx = 0; condition_idx < total_conditions; condition_idx++){\n\tint skill_id;\n\tstring symbol;\n\tint required_point;\n\tcin >> skill_id >> symbol >> required_point;\n\tif(symbol == \">=\") {\n\t  requirement[command_idx][skill_id].lower\n\t    = max(required_point,requirement[command_idx][skill_id].lower);\n\t}\n\telse if(symbol == \"<=\"){\n\t  requirement[command_idx][skill_id].upper\n\t    = min(required_point,requirement[command_idx][skill_id].lower);\n\t}\n      }\n    }\n\n    \n    bool edge[total_commands][total_commands];\n    //init\n    for(int from = 0; from < total_commands; from++){\n      for(int to = 0; to < total_commands; to++){\n\tedge[from][to] = check_path(from,to,requirement);\n      }\n    }\n\n    bool isok = false;\n    bool used[total_commands];\n    fill(used,used+total_commands,false);\n\n    int count = 0;\n    for(int round = 0;round < total_commands;round++){\n      for(int from = 0;from < total_commands;from++){\n\tif(used[from]) continue;\n\n\tbool flag = true;\n\tfor(int to = 0; to < total_commands; to++){\n\t  if(!edge[from][to] && !used[to]){\n\t    flag = false;\n\t  }\n\t}\n\n\tif(flag){\n\t  used[from] = true;\n\t  count++;\n\t  break;\n\t}\n      }\n    }\n    \n    if(count == total_commands){\n      isok = true;\n    }\n\n    printf(\"%s\\n\",isok ? \"Yes\" : \"No\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"ctime\"\n\nusing namespace std;\n\n//constexpr long long int MOD = 1000000007;\n//constexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\nconstexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-9;\n\n//int N, M, K, H, W, L, R;\nlong long int N, M, K, H, W, L, R;\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N >> M;\n\tvector<vector<int>>up(N, vector<int>(M, -1));\n\tvector<vector<int>>down(N, vector<int>(M, MOD));\n\tbool flag = true;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> K;\n\t\twhile (K--) {\n\t\t\tstring s;\n\t\t\tint a, b;\n\t\t\tcin >> a >> s >> b;\n\t\t\ta--;\n\t\t\tif (s[0] == '<')down[i][a] = min(down[i][a], b);\n\t\t\telse up[i][a] = max(up[i][a], b);\n\t\t}\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tif (up[i][j] > down[i][j])flag = false;\n\t\t}\n\t}\n\tvector<vector<int>>edge(N, vector<int>(N));\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = 0; j < N; j++) {\n\t\t\tif (i == j)continue;\n\t\t\tfor (int k = 0; k < M; k++) {\n\t\t\t\tif (down[i][k] < up[j][k])edge[i][j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tvector<int>visit(N);\n\t\tqueue<int>Q;\n\t\tQ.push(i);\n\t\twhile (!Q.empty()) {\n\t\t\tint cn = Q.front();\n\t\t\tQ.pop();\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tif (edge[cn][j] && !visit[j]) {\n\t\t\t\t\tvisit[j] = 1;\n\t\t\t\t\tQ.push(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (visit[i])flag = false;\n\t}\n\tif (flag)cout << \"Yes\\n\";\n\telse cout << \"No\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n\nusing namespace std;\n\nint k , n , m , x , v , l[200][200] , r[200][200];\nchar s[10];\nbool b[200][200];\n\nbool check( int x , int y )\n{\n\tfor( int i = 1 ; i <= n ; i++ )\n\t\tif( l[x][i] > r[y][i] )\n\t\t\treturn 0;\n\treturn 1;\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&m,&n);\n\tfor( int i = 1 ; i <= n ; i++ )\n\t\tfor( int j = 1 ; j <= m ; j++ )\n\t\t{\n\t\t\tl[j][i] = 0;\n\t\t\tr[j][i] = 100;\n\t\t}\n\tfor( int i = 1 ; i <= m ; i++ )\n\t{\n\t\tscanf(\"%d\",&k);\n\t\twhile( k-- )\n\t\t{\n\t\t\tscanf(\"%d%s%d\",&x,s,&v);\n\t\t\tif(s[0]=='<')\n\t\t\t\tr[i][x] = v;\n\t\t\telse\n\t\t\t\tl[i][x] = v;\n\t\t}\n\t}\n\tfor( int i = 1 ; i <= m ; i++ )\n\t\tfor( int j = 1 ; j <= m ; j++ )\n\t\t\tb[i][j] = check( i , j );\n\tbool flag = 1;\n\tfor( int i = 1 ; i <= m ; i++ )\n\t\tfor( int j = 1 ; j <= m ; j++ )\n\t\t\tflag &= b[i][j] | b[j][i];\n\tif( flag )\n\t\tcout<<\"Yes\"<<endl;\n\telse\n\t\tcout<<\"No\"<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nstruct skill{\n  int c,t;\n  skill(){}\n  skill(int c,int t):c(c),t(t){}\n};\nvector<vector<int> > G;\nbool dfs(int v,int d){\n  if(d>111) return 0;\n  bool f=1;\n  for(int i=0;i<(int)G[v].size()&&f;i++) f&=dfs(G[v][i],d+1);\n  return f;\n}\nbool solve(int m){\n  bool f=1;\n  for(int i=0;i<m;i++) f&=dfs(i,0);\n  return f;\n}\nint main(){\n  int m,n;\n  cin>>m>>n;\n  vector<skill> ss[m][n];\n  for(int i=0;i<m;i++){\n    int k;\n    cin>>k;\n    for(int j=0;j<k;j++){\n      int s,t;\n      string c;\n      cin>>s>>c>>t;\n      ss[i][s-1].push_back(skill(c==\"<=\",t));\n    }\n  }\n  bool ff=0;\n  G.resize(m);\n  for(int i=0;i<m;i++){\n    for(int j=0;j<m;j++){\n      bool f=0;\n      for(int k=0;k<n;k++){\n\tfor(int x=0;x<(int)ss[i][k].size();x++){\n\t  for(int y=0;y<(int)ss[j][k].size();y++){\n\t    if(ss[i][k][x].t<=ss[j][k][y].t){\n\t      f|=(ss[i][k][x].c==1&&ss[j][k][y].c==0);\n\t    }\n\t  }\n\t}\n      }\n      if(f) G[j].push_back(i);\n      ff|=((i==j)&&f);\n      //if(f) cout<<i<<\":\"<<j<<endl;\n    }\n  }\n  cout<<(!ff&&solve(m)?\"Yes\":\"No\")<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\n//??????A[a,b]??¨??????B[c,d]?????¢???\nint intervalState(int a, int b, int c, int d){\n    if(a < c && b < c) return 0;            //A < B\n    else if(a > d && b > d) return 1;       //A > B\n    else if(a <= c && d <= b) return 2;     //A -> B\n    else if(c < a && b < d) return 3;       //B -> A\n    else if(a <= c && b < d) return 4;      //A <= B\n    else if(c < a && d <= b) return 5;      //A >= B\n    return -1;\n}\n\n//Give input directly to vector<pair<int, int>> in\nvector<pair<int, int>> JoinInterval(vector<pair<int,int>> in){\n    vector<pair<int, int>> v;\n    rep(i,in.size()) in[i].second *= -1;\n    sort(all(in));\n    rep(i,in.size()) in[i].second *= -1;\n\n    rep(i,in.size()){\n        if(v.empty()) v.emplace_back(in[i]);\n        else{\n            pair<int, int> &u = v.back();\n            int tmp = intervalState(in[i].first,in[i].second,u.first,u.second);\n            switch (tmp){\n                case 0:\n                case 1:\n                    v.emplace_back(in[i]);\n                    break;\n                case 2:\n                    u.first = in[i].first;\n                    u.second = in[i].second;\n                    break;\n                case 3:\n                    break;\n                case 4:\n                case 5:\n                    u.first = max(u.first, in[i].first);\n                    u.second = min(u.second, in[i].second);\n                    break;\n                case -1:\n                    assert(0);\n            }\n        }\n    }\n    sort(all(v));\n    return v;\n}\n\nint isBigger(vector<pair<int, int>> a, vector<pair<int, int>> b){\n    bool ret[6] = {0};\n    rep(i,105){\n        ret[intervalState(a[i].first,a[i].second,b[i].first,b[i].second)] = true;\n    }\n    return ret[0] && ret[1];\n}\n\nint main(){\n    int m,n;\n    vector<pair<int,int>> v[105]; //v[i] := i??????????????????????????¶\n    rep(i,105) v[i] = vector<pair<int,int>>(105);\n    rep(i,105) rep(j,105) v[i][j] = make_pair(0,105);\n    cin >> m >> n;\n    rep(i,m){\n        int k;\n        cin >> k;\n        map<int,vector<pair<int, int>>> m;\n        rep(j,k){\n            int num, point;\n            string s;\n            cin >> num >> s >> point;\n            num--;\n\n            pair<int, int> p;\n            if(s[0] == '<') p = make_pair(0,point);\n            else p = make_pair(point,105);\n            m[num].emplace_back(p);\n\n            for(auto it : m){\n                vector<pair<int, int>> in = JoinInterval(it.second);\n                if(in.size() >= 2){\n                    cout << \"No\" << endl;\n                    return 0;\n                }\n                v[i][it.first] = in[0];\n            }\n        }\n    }\n    //rep(i,5){ rep(j,5){ cout << v[i][j].first << ' ' << v[i][j].second << endl; } cout << endl; } cout << endl;\n    rep(i,n){\n        rep(j,n - 1){\n            switch (isBigger(v[j],v[j + 1])) {\n                case 0:\n                    break;\n                case 1:\n                    cout << \"No\" << endl;\n                    return 0;\n                default:\n                    assert(1);\n            }\n        }\n    }\n    cout << \"Yes\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <set>\n#include <cstdio>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <ctime>\n#include <algorithm>\n#include <tuple>\n#include <algorithm>\n#include <limits>\n#include <map>\n#include <cstring>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\nconst int MN = 110;\nint V;\nvector<int> G[MN];\nvector<int> rG[MN];\nvector<int> vs;\nbool used[MN];\nint cmp[MN];\n\nvoid add_edge(int from, int to) {\n    G[from].push_back(to);\n    rG[to].push_back(from);\n}\n\nvoid dfs(int v) {\n    used[v] = true;\n    for(int i=0;i<G[v].size();i++) {\n        if(!used[G[v][i]]) dfs(G[v][i]);\n    }\n    vs.push_back(v);\n}\n\nvoid rdfs(int v, int k) {\n    used[v] = true;\n    cmp[v] = k;\n    for(int i=0;i<rG[v].size();i++) {\n        if (!used[rG[v][i]]) rdfs(rG[v][i], k);\n    }\n}\n\nint scc() {\n    memset(used, 0, sizeof(used));\n    vs.clear();\n    for(int v=0;v<V;v++) {\n        if (!used[v]) dfs(v);\n    }\n    memset(used, 0, sizeof(used));\n    int k = 0;\n    for(int i=vs.size() - 1; i >= 0; i--) {\n        if (!used[vs[i]]) rdfs(vs[i], k++);\n    }\n    return k;\n}\n\nint g[MN][MN];\nbool solve() {\n    for (int i = 0; i < V; i++) {\n        if (g[i][i]) return false;\n    }\n    for (int i = 0; i < V; i++) {\n        for (int j = 0; j < V; j++) {\n            if (g[i][j]) add_edge(i, j);\n        }\n    }\n    return scc() == V;\n}\n\nint main() {\n    int n;\n    int s[MN][MN][2];\n    for (int i = 0; i < MN; i++) {\n        for (int j = 0; j < MN; j++) {\n            s[i][j][0] = 0;\n            s[i][j][1] = 1000;\n        }\n    }\n    cin >> V >> n;\n    for (int i = 0; i < V; i++) {\n        int k;\n        cin >> k;\n        for (int j = 0; j < k; j++) {\n            int a, b;\n            char c;\n            scanf(\"%d %c= %d\", &a, &c, &b); a--;\n            s[i][a][(c == '<') ? 1 : 0] = b;\n        }\n    }\n    for (int i = 0; i < V; i++) {\n        for (int j = 0; j < V; j++) {\n            bool f = false;\n            for (int k = 0; k < n; k++) {\n                if (s[i][k][0] > s[j][k][1]) {\n                    f = true;\n                }\n            }\n            g[i][j] = f ? 1 : 0;\n        }\n    }\n    if (solve()) {\n        printf(\"Yes\\n\");\n    } else {\n        printf(\"No\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1<<29\nusing namespace std;\n\nint n,m,K,a,b;\nstring s,ans=\"Yes\";\nint skill[101][101][2];\nvector<int> v[101];\nbool checked[101]={},visited[101]={};\n\nvoid init(){\n  for(int i=0;i<101;i++){\n    for(int j=0;j<101;j++){\n      skill[i][j][0]=inf;\n      skill[i][j][1]=inf;\n    }\n  }\n}\n\nvoid dfs(int num){\n  if(visited[num]){\n    ans=\"No\";\n    return;\n  }\n  visited[num]=true;\n  for(int i=0;i<v[num].size();i++){\n    if(!checked[v[num][i]])dfs(v[num][i]);\n  }\n  checked[num]=true;\n  visited[num]=false;\n}\n\nint main()\n{\n  init();\n  cin>>m>>n;\n  for(int i=0;i<m;i++){\n    cin>>K;\n    for(int j=0;j<K;j++){\n      cin>>a>>s>>b;\n      a--;\n      if(s[0]=='>')skill[i][a][0]=b;\n      else skill[i][a][1]=b;\n    }\n  }\n  for(int i=0;i<m;i++){\n    for(int j=0;j<m;j++){\n      bool flag=false;\n      for(int k=0;k<n;k++){\n\tif(skill[i][k][1]==inf)continue;\n\tif(skill[j][k][0]!=inf && skill[i][k][1]<skill[j][k][0])flag=true;\n\tif(skill[j][k][1]!=inf && skill[i][k][1]<skill[j][k][1])flag=true;\n      }\n      if(flag)v[i].push_back(j);\n    }\n  }\n  for(int i=0;i<m;i++){\n    if(!checked[i])dfs(i);\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <set>\n#include <cstdio>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <ctime>\n#include <algorithm>\n#include <tuple>\n#include <algorithm>\n#include <limits>\n#include <map>\n#include <cstring>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\nconst int MN = 110;\nint V;\nvector<int> G[MN];\nvector<int> rG[MN];\nvector<int> vs;\nbool used[MN];\nint cmp[MN];\n\nvoid add_edge(int from, int to) {\n    G[from].push_back(to);\n    rG[to].push_back(from);\n}\n\nvoid dfs(int v) {\n    used[v] = true;\n    for(int i=0;i<G[v].size();i++) {\n        if(!used[G[v][i]]) dfs(G[v][i]);\n    }\n    vs.push_back(v);\n}\n\nvoid rdfs(int v, int k) {\n    used[v] = true;\n    cmp[v] = k;\n    for(int i=0;i<rG[v].size();i++) {\n        if (!used[rG[v][i]]) rdfs(rG[v][i], k);\n    }\n}\n\nint scc() {\n    memset(used, 0, sizeof(used));\n    vs.clear();\n    for(int v=0;v<V;v++) {\n        if (!used[v]) dfs(v);\n    }\n    memset(used, 0, sizeof(used));\n    int k = 0;\n    for(int i=vs.size() - 1; i >= 0; i--) {\n        if (!used[vs[i]]) rdfs(vs[i], k++);\n    }\n    return k;\n}\n\nint g[MN][MN];\nbool solve() {\n    for (int i = 0; i < V; i++) {\n        if (g[i][i]) return false;\n    }\n    for (int i = 0; i < V; i++) {\n        for (int j = 0; j < V; j++) {\n            if (g[i][j]) add_edge(i, j);\n        }\n    }\n    return scc() == V;\n}\n\nint main() {\n    int n;\n    int s[MN][MN][2];\n    for (int i = 0; i < MN; i++) {\n        for (int j = 0; j < MN; j++) {\n            s[i][j][0] = 0;\n            s[i][j][1] = 1000;\n        }\n    }\n    cin >> V >> n;\n    for (int i = 0; i < V; i++) {\n        int k;\n        cin >> k;\n        for (int j = 0; j < k; j++) {\n            int a, b;\n            char c;\n            scanf(\"%d %c= %d\", &a, &c, &b); a--;\n            if (c == '>') {\n                s[i][a][0] = max(s[i][a][0], b);\n            } else {\n                s[i][a][1] = min(s[i][a][1], b);\n            }\n        }\n    }\n    for (int i = 0; i < V; i++) {\n        for (int j = 0; j < V; j++) {\n            bool f = false;\n            for (int k = 0; k < MN; k++) {\n                if (s[i][k][0] > s[j][k][1]) {\n                    f = true;\n                }\n            }\n            g[i][j] = f ? 1 : 0;\n        }\n    }\n    if (solve()) {\n        printf(\"Yes\\n\");\n    } else {\n        printf(\"No\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) rep(i,v.size())cout<<\" \"<<v[i];cout<<endl<<endl;\n#define show2d(v) rep(i,v.size()){rep(j,v[i].size())cout<<\" \"<<v[i][j];cout<<endl;}cout<<endl;\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n// #define mt make_tuple\n// typedef tuple<int,int,int> tp;\n// typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,1,-1,1,-1};//RDLU\nclass TOPO{//out is tsort's return.\n\tpublic:\n\tvvi G;\n\tvi out;\n\tvector<bool>V;\n\tvi indeg;\n\tint n;\n\tTOPO(int size){\n\t\tn=size;\n\t\tG=vvi(n);\n\t\tout=vi(0);\n\t\tV=vector<bool>(n);\n\t\tindeg=vi(n);\n\t}\n\tvoid add_edge(int s,int t){\n\t\tG[s].pb(t);\n\t}\n\tvoid bfs(int s){\n\t\tqueue<int>q;\n\t\tq.push(s);\n\t\tV[s]=true;\n\t\twhile(!q.empty()){\n\t\t\tint u=q.front();q.pop();\n\t\t\tout.pb(u);\n\t\t\trep(i,G[u].size()){\n\t\t\t\tint v=G[u][i];\n\t\t\t\tindeg[v]--;\n\t\t\t\tif(indeg[v]==0&&!V[v]){\n\t\t\t\t\tV[v]=true;\n\t\t\t\t\tq.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvoid tsort(){\n\t\trep(i,n)indeg[i]=0;\n\t\trep(i,n)rep(j,G[i].size()){\n\t\t\tint v=G[i][j];\n\t\t\tindeg[v]++;\n\t\t}\n\t\trep(i,n)if(indeg[i]==0&&!V[i])bfs(i);\n//\t\trep(i,n)cout<<out[i]<<endl;\n\t}\n};\n\nint main(){\n\tint n,m;\n\tcin>>n>>m;\n\tint in[110][110][2];\n\trep(i,110)rep(j,110){\n\t\tin[i][j][0]=inf;\n\t\tin[i][j][1]=-inf;\n\t}\n\tbool h=true;\n\trep(i,n){\n\t\tint q;\n\t\tcin>>q;\n\t\trep(j,q){\n\t\t\tint a,b;\n\t\t\tstring s;\n\t\t\tcin>>a>>s>>b;\n\t\t\tif(s==\"<=\")cmin(in[i][a-1][0],b);\n\t\t\tif(s==\">=\")cmax(in[i][a-1][1],b);\n\t\t}\n\t\trep(j,m)if(in[i][j][0]<in[i][j][1])h=false;\n\t}\n\tif(!h){\n\t\tcout<<\"No\"<<endl;\n\t\treturn 0;\n\t}\n\tTOPO tp(n);\n\trep(i,n)loop(j,i+1,n){\n\t\tint to=-1;\n\t\trep(k,m){\n\t\t\tif(in[i][k][0]!=inf&&in[j][k][1]!=-inf&&in[i][k][0]<in[j][k][1]){\n\t\t\t\tif(to==1)h=false;\n\t\t\t\tto=0;\n\t\t\t}\n\t\t\tif(in[i][k][1]!=-inf&&in[j][k][0]!=inf&&in[j][k][0]<in[i][k][1]){\n\t\t\t\tif(to==0)h=false;\n\t\t\t\tto=1;\n\t\t\t}\n\t\t}\n\t\tif(to==0)tp.add_edge(i,j);\n\t\tif(to==1)tp.add_edge(j,i);\n\t}\n\tif(!h){\n\t\tcout<<\"No\"<<endl;\n\t\treturn 0;\n\t}\n\t\n\ttp.tsort();\n\tif(tp.out.size()==n)cout<<\"Yes\"<<endl;\n\telse cout<<\"No\"<<endl;\n}\n\n/*\nvi fact(10);\ndouble f(double p){\n\treturn (double)fact[8]/(fact[p]*fact[8-p])*pow(0.25,p)*pow(0.75,8-p);\n}\nvs in;\nstring F(string a){\n\tvvi d(4,vi(4));\n\trep(i,4)d[i][3]=i;\n\trep(i,5)rep(j,in[0].size())if(in[i][j]=='-'){\n\t\tint id[2]={i-1,(j-7)/5};\n\t\tint sc[2]={in[i][j-1]-'0',in[i][j+1]-'0'};\n\t\tif(sc[0]>sc[1])d[id[0]][0]-=3,d[id[1]][0]+=3;\n\t\tif(sc[0]<sc[1])d[id[0]][0]+=3,d[id[1]][0]-=3;\n\t\tif(sc[0]==sc[1])d[id[0]][0]-=1,d[id[1]][0]-=1;\n\t\t\n\t\td[id[0]][1]-=sc[0]-sc[1];\n\t\td[id[1]][1]-=sc[1]-sc[0];\n\t\t\n\t\td[id[0]][2]-=sc[0];\n\t\td[id[1]][2]-=sc[1];\n\t}\n\tsort(all(d));\n//\tshow2d(d);\n\tvvi nd;\n\trep(i,4)if(a[d[i][3]]=='1')nd.pb(d[i]);\n\tnd.pb({-inf,-inf,-inf,-1});\n\tstring out=\"\";\n\trep(i,nd.size()){\n\t\tloop(j,i+1,nd.size())if(nd[i][0]!=nd[j][0]||nd[i][1]!=nd[j][1]||nd[i][2]!=nd[j][2]){\n\t\t\tif(j-i==1)out+=(char)('1'+nd[i][3]);\n\t\t\telse if(j-i==nd.size()-1)out+=string('9',j-i);\n\t\t\telse{\n\t\t\t\tstring tmp=\"0000\";\n\t\t\t\tloop(k,i,j)tmp[nd[k][3]]++;\n\t\t\t\tout+=F(tmp);\n\t\t\t\ti=j-1;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn out;\n}\nint main(){\n\tfact[0]=fact[1]=1;\n\tloop(i,2,10)fact[i]=fact[i-1]*i;\n\t\n\tint q;\n\tcin>>q;\n\twhile(q--){\n\t\tin=vs(5);\n\t\trep(i,5)cin>>in[i];\n\t\tint t=0;\n\t\tint pos[2][2];\n\t\trep(i,in.size())rep(j,in[0].size()-1)if(in[i][j]=='-'&&in[i][j+1]=='_'){\n\t\t\tpos[t][0]=i;\n\t\t\tpos[t][1]=j;\n\t\t\tt++;\n\t\t}\n\t\tchar c=-1;\n\t\trep(i,5)if(in[i][0]=='*')c='0'+i;\n\t\tdouble out=0;\n\t\trep(i,9)rep(j,9)rep(k,9)rep(l,9){\n\t\t\tin[pos[0][0]][pos[0][1]-1]='0'+i;\n\t\t\tin[pos[0][0]][pos[0][1]+1]='0'+j;\n\t\t\tin[pos[1][0]][pos[1][1]-1]='0'+k;\n\t\t\tin[pos[1][0]][pos[1][1]+1]='0'+l;\n\t\t\t\n\t\t\tdouble now=f(i)*f(j)*f(k)*f(l);\n\t\t\tstring w=F(\"1111\");\n//\t\t\tcout<<w<<endl;\n\t\t\tint co1=0,co2=0;\n\t\t\trep(e,4)if(w[e]=='9')co2++;\n\t\t\trep(e,2)if(w[e]=='9')co1++;\n\t\t\tint to=5;\n\t\t\trep(_,4)if(w[_]==c)to=_;\n\t\t\tif(to<2)out+=now;\n\t\t\tif(to==5&&(w[0]=='9'||w[1]=='9'))\n\t\t\t\tout+=now*co1/co2;\n\t\t}\n\t\tcout<<shosu(10)<<out<<endl;\n\t}\n\t\n}\n*/\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <cmath>\n#include <queue>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int INF = 1e9 +7;\nconst int maxn = 1e5+7;\nvector<int> V[maxn], W[maxn], ind[maxn];\nint n, m, x, y, z, f[maxn], head[maxn], sonson[maxn], dep[maxn], Q[maxn], size[maxn], belong[maxn], cnt, id[maxn],\nfz[maxn<<1];\n\n\nint Min[maxn<<2] , sett[maxn<<2];\n\nvoid pushup ( int rt ) {\n    Min[rt] = min ( Min[rt<<1] , Min[rt<<1|1] );\n}\n\nvoid pushdown ( int rt ) {\n    if ( sett[rt] != INF ) {\n        sett[rt<<1] = min ( sett[rt<<1] , sett[rt] );\n        sett[rt<<1|1] = min ( sett[rt<<1|1] , sett[rt] );\n        Min[rt<<1] = min ( Min[rt<<1] , sett[rt<<1] );\n        Min[rt<<1|1] = min ( Min[rt<<1|1] , sett[rt<<1|1] );\n        sett[rt] = INF;\n    }\n}\n\nvoid modify ( int rt , int l , int r , int L , int R , int x ) {\n    if ( L <= l && r <= R ) {\n        Min[rt] = min ( Min[rt] , x );\n        sett[rt] = min ( sett[rt] , x );\n        return;\n    }\n    pushdown(rt);\n    int m = ( l + r ) >> 1;\n    if ( L <= m ) modify ( rt << 1 , l , m , L , R , x );\n    if ( m < R ) modify( rt << 1 | 1 , m + 1 , r , L , R , x);\n    pushup(rt);\n}\n\nint query ( int rt , int l , int r , int pos ) {\n    if ( l == r ) {\n        return Min[rt];\n    }\n    pushdown ( rt );\n    int m = ( l +r ) >> 1;\n    int ret = INF;\n    if ( pos <= m ) ret = min ( ret , query ( rt <<1 , l , m , pos ) );\n    if ( m < pos ) ret = min ( ret , query ( rt <<1|1 , m + 1 , r , pos ));\n    return ret;\n}\nvoid build ( int rt , int l , int r ) {\n    Min[rt] = sett[rt] = INF;\n    if ( l == r ) {\n        return ;\n    }\n    int m = ( l +r ) >> 1;\n    build  ( rt <<1 , l , m );\n    build ( rt << 1 | 1 , m +1 , r);\n    //pushup(rt);\n}\nint find( int x ){\n    return ( x == f[x] ) ? f[x] : ( f[x] = find( f[x] ) );\n}\nstruct Edge{\n    int u, v, w, id;\n    bool vis;\n    void in( int ID ){\n        scanf( \"%d %d %d\" , &u , &v , &w );\n        id = ID;\n        vis = false;\n    }\n}edge[maxn<<1];\nbool operator < ( const Edge &a , const Edge &b ){\n    return a.w < b.w;\n}\nbool cmp( const Edge &a , const Edge &b ){\n    return a.id < b.id;\n}\nvoid split(){\n    int l = 0, r = 1;\n    dep[Q[r]=1]=1;\n    f[1] = -1;\n    while( l < r ){\n        int x = Q[++l];\n        if( V[x].empty() )\n            continue;\n        for( int j = V[x].size() - 1 ; j >= 0 ; j -- ){\n            int y = V[x][j];\n            if( y == f[x] )\n                continue;\n            dep[Q[++r]=y] = dep[x] + 1;\n            fz[W[x][j]] = y;\n            f[y] = x;\n        }\n    }\n    for( int i = n ; i ; i -- ){\n        int x = Q[i], p = -1;\n        size[x] = 1;\n        if( V[x].empty() )\n            continue;\n        for( int j = V[x].size() - 1 ; j >= 0 ; j -- ){\n            int y = V[x][j];\n            if( y == f[x] )\n                continue;\n            size[x] += size[y];\n            if( p == -1 || ( p > 0 && size[y] > size[p] ) )\n                p = y;\n        }\n        if( p == -1 ){\n            sonson[++cnt] = x;\n            belong[head[cnt]=x] = cnt;\n        }else{\n            belong[x] = belong[p];\n            head[belong[x]] = x;\n        }\n    }\n}\nvoid doit( int a , int b , int hehe ){\n    int ida = belong[a], idb = belong[b], ha = head[ida],\n    hb = head[idb];\n    while( ida != idb ){\n        if( dep[ha] > dep[hb] ){\n            modify( 1 , 1 , n , id[a] , id[ha] , hehe );\n            a = f[ha];\n        }else{\n            modify( 1 , 1 ,  n , id[b] , id[hb] , hehe );\n            b = f[hb];\n        }\n        ida = belong[a], idb = belong[b], ha= head[ida], hb = head[idb];\n    }\n    if( dep[a] > dep[b] )\n        modify( 1 , 1 , n , id[a] , id[b] , hehe );\n    else\n        modify( 1, 1 , n ,id[b] , id[a] , hehe );\n\n}\nint main(){\n    scanf( \"%d %d\" , &n , &m );\n    for( int i = 1 ; i <= m ; i ++ )\n        edge[i].in( i );\n    for( int i = 1 ; i <= n ; i ++ )\n        f[i] = i;\n    sort( edge + 1 , edge + m + 1 );\n    long long ans = 0;\n    for( int i = 1 ; i <= m ; i ++ ){\n        int u = find( edge[i].u ), v = find( edge[i].v );\n        if( u == v )\n            continue;\n        f[u] = f[v];\n        ans = ans + edge[i].w;\n        u = edge[i].u, v = edge[i].v;\n        V[u].push_back(v);\n        V[v].push_back(u);\n        W[u].push_back( edge[i].id );\n        W[v].push_back( edge[i].id );\n        edge[i].vis = 1;\n    }\n    split();\n    int count = 0;\n    build( 1 , 1 , n );\n    for( int i = 1 ; i <= cnt ; i ++ ){\n        int y = sonson[i];\n        while( true ){\n            id[y] = ++ count;\n            //\n            if( f[y] == -1 )\n                break;\n            if( belong[y] != belong[f[y]] )\n                break;\n            y = f[y];\n        }\n    }\n    sort( edge + 1 , edge + m + 1 , cmp );\n    for( int i = 1 ; i <= m ; i ++ ){\n        int u = edge[i].u, v = edge[i].v;\n        doit( u , v , edge[i].w );\n    }\n    for( int i = 1 ; i <= m ; i ++ ){\n        if( !edge[i].vis ){\n            printf( \"%lld\\n\" , ans );\n            continue;\n        }\n        int x = query( 1 , 1 , n , fz[i] );\n        if( x == INF )\n            puts( \"-1\" );\n        else\n        printf( \"%lld\\n\" , ans - edge[i].w + x  );\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n\nusing namespace std;\n\nint dfs(vector< vector<int> > &G, vector<bool> &visited, int s){\n  int ret = 0;\n  for(int i = 0; i < G[s].size(); ++i){\n    if(visited[G[s][i]]) continue;\n    visited[G[s][i]] = true;\n    ret = max(ret, dfs(G, visited, G[s][i]) + 1);\n    visited[G[s][i]] = false;\n  }\n  return ret;\n}\n\nint main(){\n  int M, N;\n  cin >> M >> N;\n  vector< vector< pair<int, int> > > V(M, vector< pair<int,int> >(N,pair<int,int>(1,100)));\n  for(int i = 0; i < M; ++i){\n    int K;\n    cin >> K;\n    for(int j = 0; j < K; ++j){\n      int s, t;\n      string c;\n      cin >> s >> c >> t;\n      --s;\n      if(c == \">=\"){\n        if(V[i][s].second < t){\n          cout << \"No\" << endl;\n          return 0;\n        }\n        V[i][s].first = t;\n      }else{\n        if(V[i][s].first > t){\n          cout << \"No\" << endl;\n          return 0;\n        }\n        V[i][s].second = t;\n      }\n    }\n  }\n  vector< vector<bool> > G(M, vector<bool>(M,false));\n  for(int i = 0; i < M; ++i){\n    for(int j = 0; j < M; ++j){\n      bool f = true;\n      for(int k = 0; k < N; ++k){\n        if(V[i][k].first > V[j][k].second){\n          f = false;\n          break;\n        }\n      }\n      G[i][j] = f;\n    }\n  }\n  /*\n  int l = 0;\n  vector<bool> visited(M, false);\n  for(int i = 0; i < M; ++i){\n    visited[i] = true;\n    l = max(l, dfs(G, visited, i));\n    visited[i] = false;\n  }\n  if(l == M - 1) cout << \"Yes\" << endl;\n  else cout << \"No\" << endl;\n  */\n  vector<int> D(M,0);\n  for(int i = 0; i < M; ++i){\n    bool f = true;\n    for(int j = 0; j < M; ++j){\n      int d = M - i;\n      for(int k = 0; k < M; ++k){\n        d -= G[j][k];\n      }\n      if(!d){\n        f = false;\n        for(int k = 0; k < M; ++k){\n          G[j][k] = false;\n          G[k][j] = false;\n        }\n        break;\n      }\n    }\n    if(f){\n      cout << \"No\" << endl;\n      return 0;\n    }\n  }\n  cout << \"Yes\" << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing pi = pair<int,int>;\n\nconst int N = 100;\nconst int INF = 1919;\n\nvector<int> G[N];\nint vis[N]={};\nbool valid = true;\nvoid dfs(int v)\n{\n    if(vis[v]==1) return;\n\n    vis[v]=2;\n    for(const auto &x:G[v])\n    {\n        if(vis[x]==0) dfs(x);\n        if(vis[x]==2) valid=false;\n    }\n    vis[v]=1;\n}\n\nstring solve()\n{\n    int m,n;\n    cin >>m >>n;\n\n    vector<vector<pi>> c(m,vector<pi>(n,pi(0,INF)));\n    rep(i,m)\n    {\n        int k;\n        cin >>k;\n        while(k--)\n        {\n            int s,t;\n            string cond;\n            cin >>s >>cond >>t;\n            --s;\n            if(cond[0]=='>') c[i][s].fi = max(c[i][s].fi, t);\n            else c[i][s].se = min(c[i][s].se, t);\n        }\n    }\n\n    // check self contradiction\n    rep(i,m)rep(j,n)if(c[i][j].fi>c[i][j].se) return \"No\";\n\n    // check i->j\n    rep(i,m)rep(j,m)if(i!=j)\n    {\n        bool make = false;\n        rep(k,n)if(c[i][k].se<c[j][k].fi) make = true;\n        if(make) G[i].pb(j);\n    }\n\n    rep(i,m) dfs(i);\n    return (valid?\"Yes\":\"No\");\n}\n\nint main()\n{\n    cout << solve() << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\nstruct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nbool isDAG(vector<vector<int>>& G) {\n  int N = G.size();\n  vector<bool> vis(N);\n\n  std::function<bool(int)> dfs = [&](int curr) {\n    for(auto&& e: G[curr]) {\n      if(vis[e]) return false;\n      vis[e] = 1;\n      if(!dfs(e)) return false;\n      vis[e] = 0;\n    }\n    return true;\n  };\n\n  vector<int> deg(N);\n\n  rep(i, N)\n    for(auto&& e: G[i])\n      deg[e]++;\n\n  vector<int> starts;\n\n  rep(i, N)\n    if(deg[i] == 0)\n      starts.push_back(i);\n\n  if(starts.empty()) return false;\n\n  for(auto&& e: starts) {\n    vis[e] = 1;\n    if(!dfs(e)) return false;\n    vis[e] = 0;\n  }\n  return true;\n}\n\nint main() {\n\n  int M, N; cin >> M >> N;\n\n  // テ・ツ青?」ツつケテ」ツつュテ」ツδォテヲツッツ偲」ツ?ォテ」ツつウテ」ツδ榲」ツδウテ」ツδ嘉」ツ?ョテ・ツ個コテゥツ鳴禿」ツつ津ヲツ個?」ツ?、\n  vector<vector<pair<int, int>>> cmd_sect(N, vector<pair<int, int>>(M, {0, inf}));\n\n  rep(cmd_idx, M) {\n    int K; cin >> K;\n    rep(_, K) {\n      int skill; cin >> skill; skill--;\n      string op; cin >> op;\n      int threshold; cin >> threshold;\n      if(op == \">=\") {\n        cmd_sect[skill][cmd_idx].first = max(cmd_sect[skill][cmd_idx].first, threshold);\n      } else {\n        cmd_sect[skill][cmd_idx].second = min(cmd_sect[skill][cmd_idx].second, threshold);\n      }\n      if(cmd_sect[skill][cmd_idx].first > cmd_sect[skill][cmd_idx].second) {\n        cout << \"No\" << endl;\n        return 0;\n      }\n    }\n  }\n\n  vector<vector<int>> G(M);\n  \n  rep(i, N) {\n    rep(a, M) rep(b, M) {\n      if(a == b) continue;\n      if(cmd_sect[i][a].second < cmd_sect[i][b].first)\n        G[a].push_back(b);\n    }\n  }\n\n  cout << (isDAG(G) ? \"Yes\" : \"No\") << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\nusing namespace std;\n\nconst int MAX = 105;\nint m, n, up[MAX][MAX], down[MAX][MAX];\n\nvoid input()\n{\n    for(int i = 0; i < m; i++)\n    {\n        for(int j = 1; j <= n; j++)\n            up[i][j] = MAX;\n    }\n    memset(down, 0, sizeof(down));\n    int cnt, id, value;\n    char s[5];\n    for(int i = 0; i < m; i++)\n    {\n        scanf(\"%d\", &cnt);\n        while(cnt--)\n        {\n            scanf(\"%d%s%d\", &id, s, &value);\n            if(s[0] == '>')\n                down[i][id] = max(down[i][id], value);\n            else\n                up[i][id] = min(up[i][id], value);\n        }\n    }\n}\n\nbool judge_self(int m1)\n{\n    for(int i = 1; i <= n; i++)\n    {\n        if(up[m1][i] < down[m1][i])\n            return false;\n    }\n    return true;\n}\n\nbool judge_commands(int m1, int m2)\n{\n    for(int i = 1; i <= n; i++)\n    {\n        if(i < n)\n        {\n            bool flag1, flag2;\n            flag1 = (up[m1][i] > down[m2][i] && up[m1][i + 1] < down[m2][i + 1]) || (up[m1][i] < down[m2][i] && up[m1][i + 1] > down[m2][i + 1]);\n            flag2 = (down[m1][i] > up[m2][i] && down[m1][i + 1] < up[m2][i + 1]) || (down[m1][i] < up[m2][i] && down[m1][i + 1] > up[m2][i + 1]);\n            if(flag1 && flag2)\n                return false;\n        }\n    }\n    return true;\n}\n\nvoid solve()\n{\n    for(int i = 0; i < m; i++)\n    {\n        if(!judge_self(i))\n        {\n            printf(\"No\\n\");\n            return;\n        }\n        for(int j = i + 1; j < m; j++)\n        {\n            if(!judge_commands(i, j))\n            {\n                printf(\"No\\n\");\n                return;\n            }\n        }\n    }\n    printf(\"Yes\\n\");\n}\n\nint main()\n{\n    while(scanf(\"%d%d\", &m, &n) != EOF)\n    {\n        input();\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nint M,N;\nint R[111];\nbool used[111];\nint main(){\n  vector<P> L[101];\n  vector<P> U[101];\n  cin >> M >> N;\n  for(int i=0;i<M;i++){\n    int K; cin >> K;\n    for(int j=0;j<K;j++){\n      int s,t; string c;\n      cin >> s >> c >> t;\n      if( c[0] == '<' )\n        L[i].push_back( P(s,t) );\n      else \n        U[i].push_back( P(s,t) );      \n    }    \n  }\n  \n  for(int cnt=0;cnt<M;cnt++){\n    int tmp[111];\n    for(int i=0;i<N;i++)\n      tmp[i] = R[i];\n    for(int i=0;i<M;i++){\n      if(used[i]) continue;\n      for(int j=0;j<(int)U[i].size();j++)\n        tmp[U[i][j].first] = max( tmp[U[i][j].first], U[i][j].second );\n      bool ok = true;\n      for(int j=0;j<M;j++){\n        if( used[j] ) continue;\n        if( j == i ) continue;\n        for(int k=0;k<(int)L[j].size();k++)\n          if( tmp[L[j][k].first] > L[j][k].second ) {\n            ok = false; break;\n          }\n        if( !ok ) break;\n      }\n      if( ok ){\n        for(int j=0;j<N;j++){\n          used[i] = true;\n          R[j] = tmp[j];\n          break;\n        }\n      }\n    }\n  }\n  for(int i=0;i<N;i++)\n    if( !used[i] ) {\n      cout << \"No\" << endl; return 0;\n    }\n  cout << \"Yes\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\ntypedef pair<int,int> pii;\n#define mkp make_pair\nint INF=INT_MAX/2;\nint m,n;\nvector<vector<pii>> v;\nvector<vector<int>> vv;\nvector<int> used;\nbool foo(int a){\n    // cout<<\"a \"<<a<<endl;\n    if(used[a]) return false;\n    used[a]=1;\n    for(int x:vv[a]){\n        // cout<<\"x \"<<x<<endl;\n        if(!foo(x)){\n            used[a]=0;\n            return false; \n        }\n    }\n    used[a]=0;\n    return true;\n}\nint main(){\n    cin>>m>>n;\n    used=vector<int>(m,0);\n    v=vector<vector<pii>>(m,vector<pii>(n,pii(0,INF)));\n    rep(i,m){\n        int K;\n        cin>>K;\n        rep(j,K){\n            int a,b;\n            string s;\n            cin>>a>>s>>b;\n            if(s==\">=\"){\n                v[i][a-1].first=max(v[i][a-1].first,b);\n            }\n            else{\n                v[i][a-1].second=min(v[i][a-1].second,b);\n            }\n        }\n    }\n    vv=vector<vector<int>>(m);\n    rep(i,m){\n        rep(j,m){\n            bool f=false;\n            rep(k,n){\n                if(v[i][k].first>v[j][k].second) f=true;\n            }\n            if(f){\n                // cout<<i<<\" \"<<j<<endl;\n                vv[i].push_back(j);\n            }\n        }\n    }\n    // return 0;\n    bool f=true;\n    rep(i,m){\n        if(!foo(i)) f=false;\n    }\n    if(f) cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n  int M, N;\n  cin >> M >> N;\n  vector<vector<int>> mn(M, vector<int>(N, 0));\n  vector<vector<int>> mx(M, vector<int>(N, 100));\n  for (int i = 0; i < M; i++){\n    int K;\n    cin >> K;\n    for (int j = 0; j < K; j++){\n      int s;\n      string cond;\n      int t;\n      cin >> s >> cond >> t;\n      s--;\n      if (cond == \"<=\"){\n        mx[i][s] = min(mx[i][s], t);\n      }\n      if (cond == \">=\"){\n        mn[i][s] = max(mn[i][s], t);\n      }\n    }\n  }\n  bool ok = true;\n  for (int i = 0; i < M; i++){\n    for (int j = 0; j < N; j++){\n      if (mn[i][j] > mx[i][j]){\n        ok = false;\n      }\n    }\n  }\n  vector<vector<int>> E(M);\n  for (int i = 0; i < M; i++){\n    for (int j = 0; j < M; j++){\n      if (i != j){\n        bool edge = false;\n        for (int k = 0; k < N; k++){\n          if (mx[i][k] < mn[j][k]){\n            edge = true;\n          }\n        }\n        if (edge){\n          E[i].push_back(j);\n        }\n      }\n    }\n  }\n  vector<int> deg(M, 0);\n  for (int i = 0; i < M; i++){\n    for (int j : E[i]){\n      deg[j]++;\n    }\n  }\n  queue<int> Q;\n  for (int i = 0; i < M; i++){\n    if (deg[i] == 0){\n      Q.push(i);\n    }\n  }\n  while (!Q.empty()){\n    int v = Q.front();\n    Q.pop();\n    for (int w : E[v]){\n      deg[w]--;\n      if (deg[w] == 0){\n        Q.push(w);\n      }\n    }\n  }\n  for (int i = 0; i < M; i++){\n    if (deg[i] != 0){\n      ok = false;\n    }\n  }\n  if (ok){\n    cout << \"Yes\" << endl;\n  } else {\n    cout << \"No\" << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n\nusing namespace std;\n\nbool isOK2after1(vector<int> &com1Inf, vector<int> &com2Sup){\n    for(int i=0; i < com1Inf.size() ; i++){\n        if( com1Inf[i] >  com2Sup[i]) return false;\n    }\n    return true;\n}\nvoid condition(vector<int> &comInf, vector<int> &com2Inf){\n    for(int i=0 ; i< comInf.size() ; i++){\n        comInf[i] = max(comInf[i],com2Inf[i]);\n    }\n}\n\nint main() {\n    int M,N;\n    cin >> M >> N;\n    int K, s, t;\n    string cnd;\n    vector<vector<int>> comInf(M,vector<int>(N,0));\n    vector<vector<int>> comSup(M,vector<int>(N,100));\n    vector<int> sp(N,0);\n\n    for(int i=0; i<M ; i++){\n        cin >> K;\n        for(int j=0; j<K ; j++){\n            cin >> s >> cnd >> t;\n            s--;\n            if(cnd == \">=\"){\n                comInf[i][s] = t;\n            }else{\n                comSup[i][s] = t;\n            }\n        }\n    }\n    for(int i=0 ; i< M ; i++){\n        vector<int> ansInf(N,0);\n        if(!isOK2after1(comInf[i],comSup[i])){\n            cout << \"No\" << endl;\n            return 0;\n        }\n        vector<bool> isOK(N,false);\n        for(int j=0; j<i ; j++){\n            if(isOK2after1(comInf[j], comSup[i])) {\n                isOK[j] = true;\n                condition(ansInf, comInf[j]);\n            }else{\n                if(!isOK2after1(comInf[i],comSup[j])){\n                    cout << \"No\" << endl;\n                    return 0;\n                }\n            }\n        }\n        condition(ansInf,comInf[i]);\n        for(int j=0; j<i ; j++){\n            if(!isOK[j]){\n                if(!isOK2after1(ansInf,comSup[j])){\n                    cout << \"No\" << endl;\n                    return 0;\n                }\n            }\n        }\n    }\n    cout << \"Yes\" << endl; \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\n\nstruct Cond {\n\tvector<int>more;\n\tvector<int>less;\n\tCond(const int _num) :more(_num, 0), less(_num, 200) {\n\n\t}\n};\nint main() {\n\tint M, N; cin >> M >> N;\n\tvector<Cond>conds;\n\tfor (int i = 0; i < M; ++i) {\n\t\tCond acond(N);\n\t\tint K; cin >> K;\n\t\twhile (K--) {\n\t\t\tint s, t;string  st; cin >> s >> st >> t;\n\t\t\ts--;\n\t\t\tif (st == \"<=\") {\n\t\t\t\tacond.less[s] = min(acond.less[s], t);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tacond.more[s] = max(acond.more[s], t);\n\t\t\t}\n\t\t}\n\t\tconds.push_back(acond);\n\t}\n\t{\n\t\tbool ok = true;\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tfor (int skill = 0; skill < N; ++skill) {\n\t\t\t\tif (conds[i].less[skill]<conds[i].more[skill])ok = false;\n\t\t\t}\n\t\t}\n\t\tif (!ok) {\n\t\t\tcout << \"No\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tvector<vector<int>>edges(M);\n\tvector<int>toedgesnums(M);\n\tfor (int i = 0; i < M; ++i) {\n\t\tfor (int j = i+1; j < M; ++j) {\n\t\t\tif (i == j)continue;\n\t\t\tbool itoj = false;\n\t\t\tfor (int skill = 0; skill < N; ++skill) {\n\t\t\t\tif (conds[i].less[skill] < conds[j].more[skill])itoj = true;\n\t\t\t}\n\t\t\tbool jtoi = false;\n\t\t\tfor (int skill = 0; skill < N; ++skill) {\n\t\t\t\tif (conds[j].less[skill] < conds[i].more[skill])jtoi = true;\n\t\t\t}\n\t\t\tif (itoj&&jtoi) {\n\t\t\t\tcout << \"No\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (itoj) {\n\t\t\t\tedges[i].push_back(j);\n\t\t\t\ttoedgesnums[j]++;\n\t\t\t}\n\t\t\telse if (jtoi) {\n\t\t\t\tedges[j].push_back(i);\n\t\t\t\ttoedgesnums[i]++;\n\t\t\t}\n\t\t}\n\t}\n\tqueue<int>canget;\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (!toedgesnums[i]) {\n\t\t\tcanget.emplace(i);\n\t\t}\n\t}\n\tint getnum = 0;\n\twhile (!canget.empty()) {\n\t\tgetnum++;\n\t\tconst int atop(canget.front());\n\t\tcanget.pop();\n\t\t\n\t\tfor (auto e : edges[atop]) {\n\t\t\ttoedgesnums[e]--;\n\t\t\tif (!toedgesnums[e]) {\n\t\t\t\tcanget.emplace(e);\n\t\t\t}\n\t\t}\n\t}\n\tif (getnum == M) {\n\t\tcout << \"Yes\" << endl;\n\n\t}\n\telse {\n\t\tcout << \"No\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<cstdio>\n#include<algorithm>\n#define maxn 105\nusing namespace std;\n\nint n,m,l[maxn][maxn],r[maxn][maxn];\nbool a[maxn][maxn],vis[maxn];\n\nbool dfs(int x)\n{\n    vis[x]=true;\n    for (int i=1;i<=m;i++)\n    {\n        if (a[x][i]&&vis[i]) return false;\n        if (a[x][i]&&!vis[i]&&!dfs(i)) return false;\n    }\n    vis[x]=false;\n    return true;\n}\n\nint main()\n{\n    while (cin>>m>>n)\n    {\n        int i,j,k;\n        for (i=1;i<=m;i++)\n            for (j=1;j<=n;j++)\n        {\n            l[i][j]=0;\n            r[i][j]=100;\n        }\n        bool flag=true;\n        for (i=1;i<=m;i++)\n        {\n            scanf(\"%d\",&k);\n            for (j=1;j<=k;j++)\n            {\n                int x,y;\n                char c,d;\n                scanf(\"%d\",&x);\n                scanf(\"%c%c%c%c\",&d,&c,&d,&d);\n                scanf(\"%d\",&y);\n           //     cout<<x<<'*'<<c<<'*'<<y<<endl;\n                if (c=='>') l[i][x]=max(y,l[i][x]);\n                else r[i][x]=min(r[i][x],y);\n                if (l[i][x]>r[i][x]) flag=false;\n            }\n        }\n        if (!flag)\n        {\n            cout<<\"No\\n\";\n            continue;\n        }\n   //     cout<<\"?\\n\";\n        memset(a,0,sizeof(a));\n        for (i=1;i<=n;i++)\n            for (j=1;j<=m;j++)\n                for (k=1;k<=m;k++)\n                    if (j!=k)\n                {\n                    if (l[k][i]>r[j][i])\n                    {\n                        a[j][k]=1;\n                //        cout<<i<<' '<<j<<' '<<l[j][i]<<'*'<<r[j][i]<<endl;\n            //            cout<<i<<' '<<k<<' '<<l[k][i]<<'#'<<r[k][i]<<endl;\n                    }\n                }\n   /*     for (i=1;i<=m;i++)\n        {\n            for (j=1;j<=m;j++)\n                cout<<a[i][j];\n            cout<<endl;\n        }\n        for (i=1;i<=m;i++)\n            for (j=1;j<=n;j++)\n                cout<<i<<' '<<j<<' '<<l[i][j]<<'*'<<r[i][j]<<endl;*/\n        memset(vis,0,sizeof(vis));\n        flag=true;\n        for (i=1;i<=m;i++)\n            a[m+1][i]=true;\n\n  /*          if (!deg[k])\n        {\n            if (!dfs(k))\n            {\n                flag=false;\n                break;\n            }\n        }*/\n        if (!dfs(m+1)) cout<<\"No\\n\";else cout<<\"Yes\\n\";\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nstruct skill{\n  int c,t;\n  skill(){}\n  skill(int c,int t):c(c),t(t){}\n};\nvector<vector<int> > G;\nbool dfs(int v,int d){\n  if(d>111) return 0;\n  bool f=1;\n  for(int i=0;i<(int)G[v].size()&&f;i++) f&=dfs(G[v][i],d+1);\n  return f;\n}\nbool solve(int m){\n  bool f=1;\n  for(int i=0;i<m;i++) f&=dfs(i,0);\n  return f;\n}\nint main(){\n  int m,n;\n  cin>>m>>n;\n  vector<skill> ss[m][n];\n  for(int i=0;i<m;i++){\n    int k;\n    cin>>k;\n    for(int j=0;j<k;j++){\n      int s,t;\n      string c;\n      cin>>s>>c>>t;\n      ss[i][s-1].push_back(skill(c==\"<=\",t));\n    }\n  }\n  bool ff=0;\n  G.resize(m);\n  for(int i=0;i<m;i++){\n    for(int j=0;j<m;j++){\n      bool f=0;\n      for(int k=0;k<n;k++){\n\tfor(int x=0;x<(int)ss[i][k].size();x++){\n\t  for(int y=0;y<(int)ss[j][k].size();y++){\n\t    if(ss[i][k][x].t<=ss[j][k][y].t){\n\t      f|=(ss[i][k][x].c==1&&ss[j][k][y].c==0);\n\t    }\n\t  }\n\t}\n      }\n      if(f) G[j].push_back(i);\n      ff|=(i==j)&&f;\n      //if(f) cout<<i<<\":\"<<j<<endl;\n    }\n  }\n  cout<<(ff&&solve(m)?\"Yes\":\"No\")<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<list>\n#include<cmath>\n#include<ctime>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#define ll long long\nusing namespace std;\nconst int INF=100;\n\nint n,m;\nstruct range{int l,r;};\nrange a[500][500]={};\nint order[500][500]={};\n\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    cin>>n>>m;\n    for(int i=1;i<=n;i++)\n    {\n        for(int j=1;j<=m;j++)\n        {\n            a[i][j].l=0;\n            a[i][j].r=100;\n        }\n    }\n\n    for(int i=1;i<=n;i++)\n    {\n        int k;\n        cin>>k;\n        while(k--)\n        {\n            int x,y;\n            string s;\n            int flag=0;\n            cin>>x>>s>>y;\n            if(s[0]=='>')a[i][x].l=max(a[i][x].l,y);\n            else a[i][x].r=min(a[i][x].r,y);\n        }\n    }\n\n    for(int i=1;i<=n;i++)\n    {\n        for(int j=1;j<=m;j++)\n        {\n            if(a[i][j].l>a[i][j].r)\n            {\n                cout<<\"No\";\n                return 0;\n            }\n        }\n    }\n\n    for(int t=1;t<=m;t++)\n    {\n        for(int i=1;i<=n;i++)\n        {\n            for(int j=i+1;j<=n;j++)\n            {\n                if(a[i][t].l>a[j][t].r)\n                {\n                    if(order[i][j]==0||order[i][j]==2)\n                        order[i][j]=2;\n                    else\n                    {\n                        cout<<\"No\";\n                        return 0;\n                    }\n                }\n                if(a[i][t].r<a[j][t].l)\n                {\n                    if(order[i][j]==0||order[i][j]==1)\n                        order[i][j]=1;\n                    else\n                    {\n                        cout<<\"No\";\n                        return 0;\n                    }\n                }\n            }\n        }\n    }\n\n    cout<<\"Yes\";\n    return 0;\n}\n/*\n     ^          ^\n    / \\        / )\n   /  |       / /       ^\n   |  | ____<  /      /  >\n   |           |     /  /\n   |           \\    /  /\n   |  >     <   |  <  /\n  ( O    ^    O  )  | <\n   > ________   /  / /\n   / ^     /  / \\  \\\\\n   \\_/    (_/    | / /\n    \\            /_/ /\n    <___/--<____/___/\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<class T> inline void chmax(T &a, const T &b) { if(a < b) a = b; }\ntemplate<class T> inline void chmin(T &a, const T &b) { if(a > b) a = b; }\n\ntypedef vector<vector<int>> graph;\n\ninline bool check(const vector<pair<int, int>> &range1, const vector<pair<int, int>> &range2) {\n\tconst int m = range1.size();\n\tfor(int i = 0; i < m; ++i) {\n\t\tif(range1[i].second < range2[i].first) return true;\n\t}\n\treturn false;\n}\n\nbool find_loop(const graph &G) {\n\tconst int n = G.size();\n\n\tvector<int> in_degree(n, 0);\n\tfor(int v = 0; v < n; ++v) {\n\t\tfor(const auto &to : G[v]) {\n\t\t\t++in_degree[to];\n\t\t}\n\t}\n\n\tqueue<int> que;\n\tfor(int v = 0; v < n; ++v) {\n\t\tif(in_degree[v] == 0) que.push(v);\n\t}\n\n\tint cnt = 0;\n\twhile(!que.empty()) {\n\t\tconst int v = que.front();\n\t\tque.pop();\n\n\t\t++cnt;\n\n\t\tfor(const auto &to : G[v]) {\n\t\t\tif(--in_degree[to] == 0) que.push(to);\n\t\t}\n\t}\n\n\treturn cnt < n;\n}\n\nbool solve() {\n\tint n, m;\n\tcin >> n >> m;\n\n\tvector<vector<pair<int, int>>> range(n, vector<pair<int, int>>(m, pair<int, int>(0, 100)));\n\n\tfor(int i = 0; i < n; ++i) {\n\t\tint k;\n\t\tcin >> k;\n\n\t\tfor(int j = 0; j < k; ++j) {\n\t\t\tint a, b;\n\t\t\tstring s;\n\t\t\tcin >> a >> s >> b;\n\n\t\t\tif(s[0] == '>') {\n\t\t\t\tchmax(range[i][a - 1].first, b);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tchmin(range[i][a - 1].second, b);\n\t\t\t}\n\t\t}\n\n\t\tfor(int j = 0; j < m; ++j) {\n\t\t\tif(range[i][j].first > range[i][j].second) return false;\n\t\t}\n\t}\n\n\tgraph G(n);\n\tfor(int i = 0; i < n; ++i) {\n\t\tfor(int j = 0; j < n; ++j) {\n\t\t\tif(i == j) continue;\n\t\t\tif(check(range[i], range[j])) G[i].emplace_back(j);\n\t\t}\n\t}\n\n\treturn !find_loop(G);\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tcout << (solve() ? \"Yes\" : \"No\") << endl;\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<list>\n#include<cmath>\n#include<ctime>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\n#define ll long long\nusing namespace std;\nconst int INF=100;\n\nint n,m;\nstruct range{int l,r;};\nrange a[500][500]={};\nint order[500][500]={};\n\nint main()\n{\n    std::ios::sync_with_stdio(false);\n    cin>>n>>m;\n    for(int i=1;i<=n;i++)\n    {\n        for(int j=1;j<=m;j++)\n        {\n            a[i][j].l=0;\n            a[i][j].r=100;\n        }\n    }\n\n    for(int i=1;i<=n;i++)\n    {\n        int k;\n        cin>>k;\n        while(k--)\n        {\n            int x,y;\n            string s;\n            int flag=0;\n            cin>>x>>s>>y;\n            if(s[0]=='>')a[i][x].l=max(a[i][x].l,y);\n            else a[i][x].r=min(a[i][x].r,y);\n        }\n    }\n\n    for(int i=1;i<=n;i++)\n    {\n        for(int j=1;j<=m;j++)\n        {\n            if(a[i][j].l>a[i][j].r)\n            {\n                cout<<\"No\"<<endl;\n                return 0;\n            }\n        }\n    }\n\n    for(int t=1;t<=m;t++)\n    {\n        for(int i=1;i<=n;i++)\n        {\n            for(int j=i+1;j<=n;j++)\n            {\n                if(a[i][t].l>a[j][t].r)\n                {\n                    if(order[i][j]==0||order[i][j]==2)\n                        order[i][j]=2;\n                    else\n                    {\n                        cout<<\"No\"<<endl;\n                        return 0;\n                    }\n                }\n                if(a[i][t].r<a[j][t].l)\n                {\n                    if(order[i][j]==0||order[i][j]==1)\n                        order[i][j]=1;\n                    else\n                    {\n                        cout<<\"No\"<<endl;\n                        return 0;\n                    }\n                }\n            }\n        }\n    }\n\n    cout<<\"Yes\"<<endl;\n    return 0;\n}\n/*\n     ^          ^\n    / \\        / )\n   /  |       / /       ^\n   |  | ____<  /      /  >\n   |           |     /  /\n   |           \\    /  /\n   |  >     <   |  <  /\n  ( O    ^    O  )  | <\n   > ________   /  / /\n   / ^     /  / \\  \\\\\n   \\_/    (_/    | / /\n    \\            /_/ /\n    <___/--<____/___/\n*/"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-11L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n\n#define MOD 998244353LL\n#define seg_size 262144 * 4LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\nunsigned long xor128() {\n\tstatic unsigned long x = 123456789, y = 362436069, z = 521288629, w = time(NULL);\n\tunsigned long t = (x ^ (x << 11));\n\tx = y; y = z; z = w;\n\treturn (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\nvoid init() {\n\tiostream::sync_with_stdio(false);\n\tcout << fixed << setprecision(20);\n}\n\n#define int ll\n\nvoid solve(){\n\twhile (true){\n\t\tint n, m;\n\t\tcin >> m >> n;\n\t\tvector<vector<tuple<int, int, int>>> inputs;\n\t\tREP(i, m) {\n\t\t\tint a;\n\t\t\tcin >> a;\n\t\t\tvector<tuple<int, int, int>> e;\n\t\t\tREP(q, a) {\n\t\t\t\tint b;\n\t\t\t\tstring c;\n\t\t\t\tint d;\n\t\t\t\tcin >> b >> c >> d;\n\t\t\t\tb--;\n\t\t\t\tif (c == \">=\") {\n\t\t\t\t\te.push_back(make_tuple(b, d, 0LL));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\te.push_back(make_tuple(b, d, 1LL));\n\t\t\t\t}\n\t\t\t}\n\t\t\tinputs.push_back(e);\n\t\t}\n\t\tint erased = 1;\n\t\twhile (erased) {\n\t\t\terased = 0;\n\t\t\tvector<int> cnt(n, 100000);\n\t\t\tREP(q, inputs.size()) {\n\t\t\t\tREP(t, inputs[q].size()) {\n\t\t\t\t\tif (get<2>(inputs[q][t]) == 1) {\n\t\t\t\t\t\tcnt[get<0>(inputs[q][t])] = min(cnt[get<0>(inputs[q][t])], get<1>(inputs[q][t]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tREP(q, inputs.size()) {\n\t\t\t\tint ok = 1;\n\t\t\t\tREP(j, inputs[q].size()) {\n\t\t\t\t\tif (get<2>(inputs[q][j]) == 0) {\n\t\t\t\t\t\tif (cnt[get<0>(inputs[q][j])] < get<1>(inputs[q][j])) {\n\t\t\t\t\t\t\tok = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ok == 1) {\n\t\t\t\t\terased = 1;\n\t\t\t\t\tinputs.erase(inputs.begin() + q);\n\t\t\t\t\tq--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (inputs.empty() == true) {\n\t\t\tcout << \"Yes\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\t\treturn;\n\t}\n}\n\n#undef int\n\nint main() {\n\tinit();\n\tsolve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\n//??????A[a,b]??¨??????B[c,d]?????¢???\nint intervalState(int a, int b, int c, int d){\n    if(a < c && b < c) return 0;            //A < B\n    else if(a > d && b > d) return 1;       //A > B\n    else if(a <= c && d <= b) return 2;     //A -> B\n    else if(c < a && b < d) return 3;       //B -> A\n    else if(a <= c && b < d) return 4;      //A <= B\n    else if(c < a && d <= b) return 5;      //A >= B\n    return -1;\n}\n\n//Give input directly to vector<pair<int, int>> in\nvector<pair<int, int>> JoinInterval(vector<pair<int,int>> in){\n    vector<pair<int, int>> v;\n    rep(i,in.size()) in[i].second *= -1;\n    sort(all(in));\n    rep(i,in.size()) in[i].second *= -1;\n\n    rep(i,in.size()){\n        if(v.empty()) v.emplace_back(in[i]);\n        else{\n            pair<int, int> &u = v.back();\n            int tmp = intervalState(in[i].first,in[i].second,u.first,u.second);\n            switch (tmp){\n                case 0:\n                case 1:\n                    v.emplace_back(in[i]);\n                    break;\n                case 2:\n                    u.first = in[i].first;\n                    u.second = in[i].second;\n                    break;\n                case 3:\n                    break;\n                case 4:\n                case 5:\n                    u.first = max(u.first, in[i].first);\n                    u.second = min(u.second, in[i].second);\n                    break;\n                case -1:\n                    assert(0);\n            }\n        }\n    }\n    sort(all(v));\n    return v;\n}\n\nint f1(vector<pair<int, int>> a, vector<pair<int, int>> b){\n    rep(i,105) if(a[i].first > b[i].first) return 1;\n    rep(i,105) if(a[i].second > b[i].second) return 1;\n    return 0;\n}\n\nint f2(vector<pair<int, int>> a, vector<pair<int, int>> b){\n    rep(i,105) if(a[i].first > b[i].second) return 1;\n    //rep(i,105) if(a[i].second > b[i].second) return 1;\n    return 0;\n}\n\nint main(){\n    int m,n;\n    vector<pair<int,int>> v[105]; //v[i] := i??????????????????????????¶\n    rep(i,105) v[i] = vector<pair<int,int>>(105);\n    rep(i,105) rep(j,105) v[i][j] = make_pair(0,105);\n\n    cin >> m >> n;\n    rep(i,m){\n        int k;\n        cin >> k;\n        map<int,vector<pair<int, int>>> m;\n        rep(j,k){\n            int num, point;\n            string s;\n            cin >> num >> s >> point;\n            num--;\n\n            pair<int, int> p;\n            if(s[0] == '<') p = make_pair(0,point);\n            else p = make_pair(point,105);\n            m[num].emplace_back(p);\n        }\n        for(auto it : m){\n            vector<pair<int, int>> in = JoinInterval(it.second);\n            if(in.size() >= 2){\n                cout << \"No\" << endl;\n                return 0;\n            }\n            v[i][it.first] = in[0];\n        }\n    }\n\n    rep(i,m + 1) rep(j,m - 1) if(f1(v[j],v[j + 1])) swap(v[j],v[j + 1]);\n    rep(i,m + 1) rep(j,m - 1) if(f2(v[j],v[j + 1])) swap(v[j],v[j + 1]);\n\n    //rep(i,m){ rep(j,n){ cout << v[i][j].first << ' ' << v[i][j].second << endl; } cout << endl; } cout << endl;\n    int point[105] = {0};\n    rep(i,m){\n        rep(j,n){\n            int tmp = intervalState(point[j], point[j], v[i][j].first, v[i][j].second);\n            switch (tmp) {\n                case 1:\n                    cout << \"No\" << endl;\n                    return 0;\n                case 0:\n                    point[j] = v[i][j].first;\n            }\n            //show(point[j])\n        }\n       //cout << endl;\n    }\n    cout << \"Yes\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#define r(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n#define F first\n#define S second\ntypedef pair<int,int>P;\nint n,m,x,y,K,a[102][102],flag,amin[102][102],amax[102][102];\nstring s;\nvector<P>v1[102],v2[102];\nbool ch(){\n  r(i,m){\n    r(j,v1[i].size()){\n      r(k,v2[i].size()){\n\tif(v1[i][j].F==v2[i][k].F&&v1[i][j].S<v2[i][k].S) return 1;\n      }\n    }\n  }\n  return 0;\n}\nvoid make_Graph(){\n  r(i,102)r(j,102)amax[i][j]=1e8;\n  r(i,m){\n    r(j,v1[i].size())amax[i][v1[i][j].F]=min(amax[i][v1[i][j].F],v1[i][j].S);\n    r(j,v2[i].size())amin[i][v2[i][j].F]=max(amin[i][v2[i][j].F],v2[i][j].S);\n    r(j,102)amin[i][j]=min(amin[i][j],amax[i][j]);\n  }\n  r(i,m)r(j,m)r(k,102)if(amax[i][k]<amin[j][k])a[i][j]=-1;\n}\nint main(){\n  cin>>m>>n;\n  r(i,m){\n    cin>>K;\n    r(j,K){\n      cin>>x>>s>>y;\n      if(s==\"<=\")v1[i].push_back(P(x,y));\n      else v2[i].push_back(P(x,y));\n    }\n  }\n  if(ch())cout<<\"No\"<<endl;\n  else{\n    r(i,102)r(j,102)a[i][j]==(i==j?0:100);\n    make_Graph();\n    n++;\n    r(o,m)r(i,m)r(j,m)a[i][m]=min(a[i][j],a[i][o]+a[o][j]);\n    r(i,102)if(a[i][i]<0)flag++;\n    cout<<(flag?\"No\":\"Yes\")<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\n#include <vector>\n\nusing namespace std;\n\n#define MAX 114\n\nvector<int> G[MAX];\nint col[MAX];\nbool found;\n\nvoid dfs(int v)\n{\n    col[v] = 0;\n    for(int i = 0 ; i < (int)G[v].size() ; i++){\n        int to = G[v][i];\n        if(col[to] == -1){\n            dfs(to);\n        }else if(col[to] == 0){\n            found = true;            \n            return;\n        }\n    }\n    col[v] = 1;\n}\n    \nint main()\n{\n    int M, N;\n    cin >> M >> N;\n    \n    auto canGraph = [=](){\n        int l[MAX][MAX], u[MAX][MAX];\n        for(int i = 0 ; i < MAX ; i++){\n            for(int j = 0 ; j < MAX ; j++){\n                l[i][j] = -1;\n                u[i][j] = 101;\n            }\n        }\n        int K, s, t;\n        string c;\n        bool poss = 1;\n        for(int i = 0 ; i < M ; i++){\n            cin >> K;\n            for(int j = 0 ; j < K ; j++){\n                cin >> s >> c >> t;\n                --s;\n                if(c == \">=\"){\n                    l[i][s] = max(l[i][s], t);\n                }else{\n                    u[i][s] = min(u[i][s], t);\n                }\n            }\n            for(int j = 0 ; j < N ; j++){\n                if(l[i][j] > u[i][j]){\n                    poss = 0;\n                    break;\n                }\n            }\n        }\n\n        if(!poss) return false;\n\n        auto isConnect = [=](int from, int to){\n            for(int i = 0 ; i < N ; i++){\n                if(u[from][i] <= l[to][i]){\n                    return true;\n                }\n            }\n            return false;\n        };\n        \n        for(int from = 0 ; from < M ; from++){\n            for(int to = 0 ; to < M ; to++){\n                if(from == to) continue;\n                if(isConnect(from, to)){\n                    G[from].push_back(to);\n                }\n            }\n        }\n        found = false;\n        memset(col, -1, sizeof(col));\n        for(int i = 0 ; i < M ; i++){\n            if(col[i] == -1){\n                dfs(i);\n            }\n        }                                       \n        return !found;\n    };\n    \n    cout << (canGraph() ? \"Yes\" : \"No\") << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#define r(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n#define F first\n#define S second\ntypedef pair<int,int>P;\nint n,m,x,y,K,a[102][102],flag,amin[102],amax[102];\nstring s;\nvector<P>v1[102],v2[102];\nbool ch(){\n  r(i,m){\n    r(j,v1[i].size()){\n      r(k,v2[i].size()){\n\tif(v1[i][j].F==v2[i][k].F&&v1[i][j].S<v2[i][k].S) return 1;\n      }\n    }\n  }\n  return 0;\n}\nvoid make_Graph(){\n  r(i,102)amax[i]=1e8;\n  r(i,m){\n    r(j,v1[i].size())amax[i]=min(amax[i],v1[i][j].S);\n    r(j,v2[i].size())amin[i]=max(amin[i],v2[i][j].S);\n    amin[i]=min(amin[i],amax[i]);\n  }\n  r(i,m)r(j,m)if(amax[i]<amin[j])a[i][j]=-1;\n}\nint main(){\n  cin>>m>>n;\n  r(i,m){\n    cin>>K;\n    r(j,K){\n      cin>>x>>s>>y;\n      if(s==\"<=\")v1[i].push_back(P(x,y));\n      else v2[i].push_back(P(x,y));\n    }\n  }\n  if(ch())cout<<\"No\"<<endl;\n  else{\n    r(i,102)r(j,102)a[i][j]==(i==j?0:100);\n    make_Graph();\n    n++;\n    r(o,m)r(i,m)r(j,m)a[i][m]=min(a[i][j],a[i][o]+a[o][j]);\n    r(i,102)if(a[i][i]<0)flag++;\n    cout<<(flag?\"No\":\"Yes\")<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define l first\n#define r second\n#define INF (1e9)\nusing namespace std;\ntypedef pair <int,int> P;\nint m,n,used[101],memo[101][101];\nP cmd[101][101];\n\nint check(int a,int b){\n\n  if(memo[a][b]!=-1) return memo[a][b];\n  for(int i=0;i<n;i++)\n    if(cmd[a][i].l>cmd[b][i].r)return memo[a][b]=0;\n  return memo[a][b]=1;\n}\n\nint solve(){\n  memset(memo,-1,sizeof(memo));\n  int flg=1;\n  while(flg){\n    flg=0;\n    for(int i=0,j;i<m&&!flg;i++){\n      if(used[i]) continue;\n      j=0;\n      for(j=0;j<m;j++)if(!used[j]&&!check(i,j))break;\n      if(j==m) flg=used[i]=1;\n    }\n  }\n  for(int i=0;i<m;i++) if(!used[i]) return 0;\n  return 1;\n}\n\nint main(){\n  int ans=1;\n  for(int i=0;i<101;i++)\n    for(int j=0;j<101;j++)cmd[i][j]=P(-INF,INF);\n\n  cin>>m>>n;\n  for(int i=0;i<m;i++){\n    int k;\n    cin>>k;\n    while(k--){\n      string cond;\n      int s,t;\n      cin>>s>>cond>>t;\n      s--;\n      if(cond==\"<=\")cmd[i][s].r=min(cmd[i][s].r,t);\n      if(cond==\">=\")cmd[i][s].l=max(cmd[i][s].l,t);\n      if(cmd[i][s].l>cmd[i][s].r)ans=0;\n    }\n  }\n\n  cout << (ans*solve()? \"Yes\":\"No\")<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define Fi first\n#define Se second\n#define INF (1<<29)\n#define EPS 1e-10\n#define MOD 1000000007\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint M, N;\nmap<int, pi>S[128];\nvector<int>G[128];\nvector<int>tpo[128];\n\nint is_edge(int src, int dist)\n{\n  for(auto x:S[src]){\n    int s = x.first, l = x.second.first, u = x.second.second;\n    if(!S[dist].count(s)) continue;\n    pi op = S[dist][s];\n    if(op.second < l) return 0;\n  }\n  return 1;\n}\n\nint dfs(int v, set<int>& sc, vector<int> crd)\n{\n  if(sc.size() == M){\n    //    cout << v << endl;\n    return 1;\n  }\n\n  //  for(auto x: sc){\n    vector<int>temp;    \n    set_intersection(crd.begin(), crd.end(), G[v].begin(), G[v].end(),\n\t\t     back_inserter(temp));\n    //    crd.swap(temp);\n    //  }\n  for(auto next: temp){\n    if(sc.count(next)) continue;\n    sc.insert(next);\n    if(dfs(next, sc, temp)) return 1;\n    sc.erase(next);\n  }\n  return 0;\n}\n\nint solve()\n{\n  rep(i, M){\n    //    cout << i << endl;\n    set<int>sc; sc.insert(i);\n    vector<int>crd; rep(j,M) crd.push_back(j);    \n    if(dfs(i, sc, crd)) return 1;\n  }\n  return 0;\n}\n\n\nint main()\n{\n  cin >> M >> N;\n  rep(i, M){\n    int K;  cin >> K;\n    rep(j, K){\n      int s, t; string cond;\n      cin >> s >> cond >> t;\n      int c = 0;\n      if(cond == \"<=\") c = 1;\n      if(!S[i].count(s)) S[i][s] = pi(0, INF);\n      pi p = S[i][s];\n      if(c) S[i][s] = pi(p.first, min(t, p.second));\n      else  S[i][s] = pi(max(t, p.first), p.second);\n    }\n  }\n\n  rep(i, M) for(auto x:S[i]){\n    pi p = x.second;\n    //    cout << p.first << \" \" << p.second << endl;\n    if(p.first > p.second){\n      cout << \"No\\n\";\n      return 0;\n    }\n  }\n\n  rep(i, M) rep(j, M){\n    if(i == j) continue;\n    if(is_edge(i, j)){\n      G[i].push_back(j);\n      tpo[j].push_back(i);\n      //      cout << i << \" \" << j << endl;\n    }\n  }\n\n  rep(i, M) sort(G[i].begin(), G[i].end());\n\n  cout << (solve()?\"Yes\":\"No\") << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint m,n;\nint k[101];\nint data[101][101][2];\nint s[101][101],cond[101][101],t[101][101];\nvector<int> G[101];\nvector<int> rG[101];\nvector<int> vs;\nbool used[101];\nint cmp[101];\n\nvoid add_edge(int f,int t){\n\tG[f].push_back(t);\n\tG[t].push_back(f);\n}\n\nvoid dfs(int v){\n\tused[v]=true;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tif(!used[G[v][i]])dfs(G[v][i]);\n\t}\n\tvs.push_back(v);\n}\n\nvoid rdfs(int v,int k){\n\tused[v]=true;\n\tcmp[v]=k;\n\tfor(int i=0;i<rG[v].size();i++){\n\t\tif(!used[rG[v][i]])rdfs(rG[v][i],k);\n\t}\n}\n\nvoid cdfs(int v){\n\tused[v]=true;\n\tfor(int i=0;i<G[v].size();i++){\n\t\tif(!used[G[v][i]] && cmp[v]+1>=cmp[G[v][i]])cdfs(G[v][i]);\n\t}\n}\n\nbool scc(){\n\tmemset(used,0,sizeof(used));\n\tfor(int i=0;i<m;i++){\n\t\tif(!used[i])dfs(i);\n\t}\n\tmemset(used,0,sizeof(used));\n\tint k=0;\n\tfor(int i=vs.size()-1;i>=0;i--){\n\t\tif(!used[vs[i]])rdfs(vs[i],k++);\n\t}\n\tmemset(used,0,sizeof(used));\n\tcdfs(vs[vs.size()-1]);\n\tfor(int i=0;i<m;i++){\n\t\tif(!used[i])return false;\n\t}\n\treturn true;\n}\n\nint main(void){\n\tscanf(\"%d %d\",&m,&n);\n\tfor(int i=0;i<=100;i++){\n\t\tfor(int j=0;j<=100;j++){\n\t\t\tdata[i][j][0]=0;\n\t\t\tdata[i][j][1]=101;\n\t\t}\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tscanf(\"%d\",&k[i]);\n\t\tfor(int j=0;j<k[i];j++){\n\t\t\tchar d;\n\t\t\tscanf(\"%d %c%*c %d\",&s[i][j],&d,&t[i][j]);\n\t\t\tif(d=='<')cond[i][j]=0;\n\t\t\telse cond[i][j]=1;\n\t\t}\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tfor(int j=0;j<k[i];j++){\n\t\t\tif(cond[i][j]==0)data[i][s[i][j]][1]=min(t[i][j],data[i][s[i][j]][1]);\n\t\t\tif(cond[i][j]==1)data[i][s[i][j]][0]=max(t[i][j],data[i][s[i][j]][0]);\n\t\t\tif(data[i][s[i][j]][1]<data[i][s[i][j]][0]){\n\t\t\t\tprintf(\"No\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tfor(int j=0;j<m;j++){\n\t\t\tif(i==j)continue;\n\t\t\tint k;\n\t\t\tfor(k=1;k<=n;k++){\n\t\t\t\tif(data[i][k][0]>data[j][k][1])break;\n\t\t\t}\n\t\t\tif(k==n+1){\n\t\t\t\tadd_edge(i,j);\n\t\t\t\t//printf(\"%d %d\\n\",i,j);\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%s\\n\",scc()?\"Yes\":\"No\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <set>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define PRIME1 99999883\n#define PRIME2 99999893\n#define EPS 0.00000001\nusing namespace std;\n\nenum Type{\n\tNone,\n\tGreaterEqual,\n\tSmallerEqual,\n};\n\nstruct Data{\n\tType type;\n\tint number;\n};\n\nstruct Info{\n\tData data[101];\n\tbool used;\n};\n\nint main(){\n\n\tint num_of_SC,num_of_skill,K;\n\tscanf(\"%d %d\",&num_of_SC,&num_of_skill);\n\tInfo info[num_of_SC];\n\tfor(int i = 0; i < num_of_SC; i++){\n\t\tinfo[i].used = false;\n\t\tfor(int a = 1; a <= num_of_skill;a++)info[i].data[a].type = None;\n\t}\n\n\tint skill_code,skill_level;\n\n\tchar eq[4];\n\tbool FLG = true;\n\n\t//??????????????\\???\n\tfor(int i = 0; i < num_of_SC; i++){\n\t\tscanf(\"%d\",&K);\n\t\tfor(int a = 0; a < K; a++){\n\t\t\tscanf(\"%d %s %d\",&skill_code,eq,&skill_level);\n\t\t\tif(info[i].data[skill_code].type == None){\n\t\t\t\tinfo[i].data[skill_code].number = skill_level;\n\t\t\t\tif(eq[0] == '>'){\n\t\t\t\t\tinfo[i].data[skill_code].type = GreaterEqual;\n\t\t\t\t}else{\n\t\t\t\t\tinfo[i].data[skill_code].type = SmallerEqual;\n\t\t\t\t}\n\t\t\t}else{ //??????????????§?????????????????????????????§??????!!!\n\t\t\t\tif(info[i].data[skill_code].type == GreaterEqual){\n\t\t\t\t\tif(eq[0] == '>'){\n\t\t\t\t\t\t//Do nothing <?¨????????§??????????????????§?°??????????????????????????????????????????????????????????>\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(info[i].data[skill_code].number > skill_level){\n\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(eq[0] == '>'){\n\t\t\t\t\t\tif(info[i].data[skill_code].number < skill_level){\n\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif(!FLG){\n\t\tprintf(\"No\\n\");\n\t\treturn 0;\n\t}\n\n\tint count = 0;\n\tstack<int> S;\n\n\twhile(true){\n\n\t\t//???????????????????????????????????§???????????????special skill???1????????????special skill?????¢???<?????????????????????????????????special skill??????????????????FLG???false?????????>\n\t\tfor(int i = 0; i < num_of_SC; i++){ //??????????????????\n\t\t\tif(info[i].used == true)continue;\n\n\t\t\tFLG = true;\n\t\t\tfor(int a = 0; a < num_of_SC; a++){ //????????????????±?????????????\n\t\t\t\tif(i == a || info[a].used == true)continue;\n\n\t\t\t\tfor(int b = 1; b <= num_of_skill;b++){ //skill????????????\n\n\t\t\t\t\tswitch(info[a].data[b].type){\n\t\t\t\t\tcase None:\n\t\t\t\t\t\t//Do nothing\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase GreaterEqual:\n\n\t\t\t\t\t\t/*if(info[i].data[b].type == GreaterEqual && info[i].data[b].number > info[a].data[b].number){\n\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t}*/\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SmallerEqual:\n\t\t\t\t\t\tif(info[i].data[b].type == GreaterEqual && info[i].data[b].number > info[a].data[b].number){\n\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!FLG)break;\n\t\t\t}\n\t\t\tif(FLG){\n\t\t\t\tS.push(i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(S.empty())break;\n\n\t\twhile(!S.empty()){\n\t\t\tinfo[S.top()].used = true;\n\t\t\tcount++;\n\t\t\tS.pop();\n\t\t}\n\t}\n\n\tif(count == num_of_SC){\n\t\tprintf(\"Yes\\n\");\n\t}else{\n\t\tprintf(\"No\\n\");\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <set>\n#include <cstdio>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <ctime>\n#include <algorithm>\n#include <tuple>\n#include <algorithm>\n#include <limits>\n#include <map>\n#include <cstring>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\nconst int MN = 110;\nint V;\nvector<int> G[MN];\nvector<int> rG[MN];\nvector<int> vs;\nbool used[MN];\nint cmp[MN];\n\nvoid add_edge(int from, int to) {\n    G[from].push_back(to);\n    rG[to].push_back(from);\n}\n\nvoid dfs(int v) {\n    used[v] = true;\n    for(int i=0;i<G[v].size();i++) {\n        if(!used[G[v][i]]) dfs(G[v][i]);\n    }\n    vs.push_back(v);\n}\n\nvoid rdfs(int v, int k) {\n    used[v] = true;\n    cmp[v] = k;\n    for(int i=0;i<rG[v].size();i++) {\n        if (!used[rG[v][i]]) rdfs(rG[v][i], k);\n    }\n}\n\nint scc() {\n    memset(used, 0, sizeof(used));\n    vs.clear();\n    for(int v=0;v<V;v++) {\n        if (!used[v]) dfs(v);\n    }\n    memset(used, 0, sizeof(used));\n    int k = 0;\n    for(int i=vs.size() - 1; i >= 0; i--) {\n        if (!used[vs[i]]) rdfs(vs[i], k++);\n    }\n    return k;\n}\nint m;\nint g[MN][MN];\nbool solve() {\n    for (int i = 0; i < m; i++) {\n        if (g[i][i]) return false;\n    }\n    V = m;\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < m; j++) {\n            if (g[i][j]) add_edge(i, j);\n        }\n    }\n    return scc() == m;\n}\n\nint main() {\n    int n;\n    int s[MN][MN][2];\n    for (int i = 0; i < MN; i++) {\n        for (int j = 0; j < MN; j++) {\n            s[i][j][0] = 0;\n            s[i][j][1] = 1000;\n        }\n    }\n    cin >> m >> n;\n    for (int i = 0; i < m; i++) {\n        int k;\n        cin >> k;\n        for (int j = 0; j < k; j++) {\n            int a, b;\n            char c;\n            scanf(\"%d %c= %d\", &a, &c, &b); a--;\n            s[i][a][(c == '<') ? 1 : 0] = b;\n        }\n    }\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < m; j++) {\n            bool f = false;\n            for (int k = 0; k < MN; k++) {\n                if (s[i][k][0] > s[j][k][1]) {\n                    f = true;\n                }\n            }\n            g[i][j] = f ? 1 : 0;\n        }\n    }\n    if (solve()) {\n        printf(\"No\\n\");\n    } else {\n        printf(\"No\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <set>\n#include <cstdio>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <ctime>\n#include <algorithm>\n#include <tuple>\n#include <algorithm>\n#include <limits>\n#include <map>\n#include <cstring>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\nconst int MN = 1100;\nint V;\nvector<int> G[MN];\nvector<int> rG[MN];\nvector<int> vs;\nbool used[MN];\nint cmp[MN];\n\nvoid add_edge(int from, int to) {\n    G[from].push_back(to);\n    rG[to].push_back(from);\n}\n\nvoid dfs(int v) {\n    used[v] = true;\n    for(int i=0;i<G[v].size();i++) {\n        if(!used[G[v][i]]) dfs(G[v][i]);\n    }\n    vs.push_back(v);\n}\n\nvoid rdfs(int v, int k) {\n    used[v] = true;\n    cmp[v] = k;\n    for(int i=0;i<rG[v].size();i++) {\n        if (!used[rG[v][i]]) rdfs(rG[v][i], k);\n    }\n}\n\nint scc() {\n    memset(used, 0, sizeof(used));\n    vs.clear();\n    for(int v=0;v<V;v++) {\n        if (!used[v]) dfs(v);\n    }\n    memset(used, 0, sizeof(used));\n    int k = 0;\n    for(int i=vs.size() - 1; i >= 0; i--) {\n        if (!used[vs[i]]) rdfs(vs[i], k++);\n    }\n    return k;\n}\nint m;\nint g[MN][MN];\nbool solve() {\n    for (int i = 0; i < m; i++) {\n        if (g[i][i]) return false;\n    }\n    V = m;\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < m; j++) {\n            if (g[i][j]) add_edge(i, j);\n        }\n    }\n    return scc() == m;\n}\n\nint main() {\n    int n;\n    int s[MN][MN][2];\n    for (int i = 0; i < MN; i++) {\n        for (int j = 0; j < MN; j++) {\n            s[i][j][0] = 0;\n            s[i][j][1] = 1000;\n        }\n    }\n    cin >> m >> n;\n    for (int i = 0; i < m; i++) {\n        int k;\n        cin >> k;\n        for (int j = 0; j < k; j++) {\n            int a, b;\n            char c;\n            scanf(\"%d %c= %d\", &a, &c, &b); a--;\n            s[i][a][(c == '<') ? 1 : 0] = b;\n        }\n    }\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < m; j++) {\n            bool f = false;\n            for (int k = 0; k < MN; k++) {\n                if (s[i][k][0] > s[j][k][1]) {\n                    f = true;\n                }\n            }\n            g[i][j] = f ? 1 : 0;\n        }\n    }\n    if (solve()) {\n        printf(\"Yes\\n\");\n    } else {\n        printf(\"No\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nstruct skill{\n  int c,t;\n  skill(){}\n  skill(int c,int t):c(c),t(t){}\n};\nvector<vector<int> > G;\nbool dfs(int v,int d){\n  if(d>111) return 0;\n  bool f=1;\n  for(int i=0;i<(int)G[v].size()&&f;i++) f&=dfs(G[v][i],d+1);\n  return f;\n}\nbool solve(int m){\n  bool f=1;\n  for(int i=0;i<m;i++) f&=dfs(i,0);\n  return f;\n}\nint main(){\n  int m,n;\n  cin>>m>>n;\n  vector<skill> ss[m][n];\n  for(int i=0;i<m;i++){\n    int k;\n    cin>>k;\n    for(int j=0;j<k;j++){\n      int s,t;\n      string c;\n      cin>>s>>c>>t;\n      ss[i][s-1].push_back(skill(c==\"<=\",t));\n    }\n  }\n  G.resize(m);\n  for(int i=0;i<m;i++){\n    for(int j=0;j<m;j++){\n      bool f=0;\n      for(int k=0;k<n;k++){\n\tfor(int x=0;x<(int)ss[i][k].size();x++){\n\t  for(int y=0;y<(int)ss[j][k].size();y++){\n\t    if(ss[i][k][x].t<=ss[j][k][y].t){\n\t      f|=(ss[i][k][x].c==1&&ss[j][k][y].c==0);\n\t    }\n\t  }\n\t}\n      }\n      if(f) G[j].push_back(i);\n      //if(f) cout<<i<<\":\"<<j<<endl;\n    }\n  }\n  cout<<(solve(m)?\"Yes\":\"No\")<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n\nclass Requirement{\npublic:\n  int upper;\n  int lower;\n  Requirement() : upper(INF),lower(0) {}\n  Requirement(int _u,int _l) : upper(_u),lower(_l) {}\n};\n\nint total_commands;\nint total_skills;\n\nbool check_path(int from_command,int to_command,\n\t\tRequirement requirement[101][101]){\n  for(int skill_id = 1; skill_id <= total_skills;skill_id++){\n    if(requirement[from_command][skill_id].lower\n       > requirement[to_command][skill_id].upper){\n      return false;\n    }\n    // if(requirement[from_command][skill_id].upper\n    //    < requirement[to_command][skill_id].lower){\n    //   return false;\n    // }\n  }\n  return true;\n}\n\nbool dfs(bool edge[101][101],bool used[101],int current,\n\t int count,int total_commands){\n  if(count == total_commands){\n    return true;\n  }\n\n  used[current] = true;\n  bool res = false;\n\n  for(int to=0;to<total_commands;to++){\n    if(current == to) continue;\n\n    if(edge[current][to] && !used[to]){\n      res |= dfs(edge,used,to,count+1,total_commands);\n    }\n  }\n\n  return res;\n}\n\nint main(){\n  while(~scanf(\"%d %d\",&total_commands,&total_skills)){\n    Requirement requirement[101][101];\n\n    bool skill_flag = true;\n    for(int command_idx = 0; command_idx < total_commands; command_idx++){\n      int total_conditions;\n      scanf(\"%d\",&total_conditions);\n      for(int condition_idx = 0; condition_idx < total_conditions; condition_idx++){\n\tint skill_id;\n\tstring symbol;\n\tint required_point;\n\tcin >> skill_id >> symbol >> required_point;\n\tif(symbol == \">=\") {\n\t  requirement[command_idx][skill_id].lower\n\t    = max(required_point,requirement[command_idx][skill_id].lower);\n\t}\n\telse if(symbol == \"<=\"){\n\t  requirement[command_idx][skill_id].upper\n\t    = min(required_point,requirement[command_idx][skill_id].lower);\n\t}\n\t\n\tif(requirement[command_idx][skill_id].lower\n\t   > requirement[command_idx][skill_id].upper){\n\t  skill_flag = false;\n\t}\n      }\n    }\n\n    \n    bool edge[101][101];\n    //init\n    for(int from = 0; from < total_commands; from++){\n      for(int to = 0; to < total_commands; to++){\n\tedge[from][to] = check_path(from,to,requirement);\n      }\n    }\n\n    bool isok = false;\n    for(int start = 0; start < total_commands; start++){\n      bool used[101];\n      memset(used,false,sizeof(used));\n      isok |= dfs(edge,used,start,1,total_commands);\n    }\n    printf(\"%s\\n\",(isok && skill_flag) ? \"Yes\" : \"No\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<iomanip>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<queue>\n\nusing namespace std;\n\n#define int long long\n#define rep(i,n) for(int i = 0; i < (n); i++)\n#define INF ((long long)1e18)\n#define MOD ((int)1e9+7)\n#define endl \"\\n\"\n\n#define yn(f) ((f)?\"Yes\":\"No\")\n#define YN(f) ((f)?\"YES\":\"NO\")\n\n#define MAX 110\n\nint M, N;\nint K[MAX], sp[MAX], point[MAX], con;\nbool can[MAX];\nvector<vector<int>> llim(MAX,vector<int>(MAX,0));\n// vector<pair<int,int>> ulim[MAX];\npriority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> ulim[MAX];\n\nbool check(int n){\n\tif(can[n]) return false;\n\t\n\tfor(int i = 1; i <= N; i++){\n\t\tif(llim[n][i] > sp[i]) return false;\n\t}\n\t\n\tcan[n] = true;\n\tcon++;\n\t\n\treturn true;\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout<<fixed<<setprecision(10);\n\t\n\tint s, t;\n\tstring cond;\n\t\n\tcin>>M>>N;\n\t\n\tfor(int i = 1; i <= M; i++){\n\t\tcin>>K[i];\n\t\tfor(int j = 1; j <= K[i]; j++){\n\t\t\tcin>>s>>cond>>t;\n\t\t\tif(cond == \">=\"){\n\t\t\t\tllim[i][s] = max(llim[i][s], t);\n\t\t\t} else if(cond == \"<=\"){\n\t\t\t\tulim[s].push(make_pair(t,i));\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t}\n\tfor(int i = 1; i <= N; i++){\n\t\tulim[i].push(make_pair(INF,0));\n\t}\n\t\n\twhile(true){\n\t\tbool flag = false;\n\t\t\n\t\tfor(int i = 1; i <= N; i++){\n\t\t\twhile(!ulim[i].empty()){\n\t\t\t\tpair<int,int> p = ulim[i].top(); ulim[i].pop();\n\t\t\t\tif(can[p.second] == false){\n\t\t\t\t\tsp[i] = p.first;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// cout<<i<<\" \"<<sp[i]<<endl;\n\t\t}\n\t\t\n\t\tfor(int i = 1; i <= M; i++){\n\t\t\tif(check(i)) flag = true;\n\t\t}\n\t\tif(!flag){\n\t\t\tcout<<\"NO\"<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\tif(con == M)break;\n\t}\n\t\n\tcout<<\"YES\"<<endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n\nusing namespace std;\n\nbool isOK2after1(vector<int> &com1Inf, vector<int> &com2Sup){\n    for(int i=0; i < com1Inf.size() ; i++){\n        if( com1Inf[i] >  com2Sup[i]) return false;\n    }\n    return true;\n}\nvoid condition(vector<int> &comInf, vector<int> &com2Inf){\n    for(int i=0 ; i< comInf.size() ; i++){\n        comInf[i] = max(comInf[i],com2Inf[i]);\n    }\n}\nvoid conditionSup(vector<int> &comInf, vector<int> &com2Inf){\n    for(int i=0 ; i< comInf.size() ; i++){\n        comInf[i] = min(comInf[i],com2Inf[i]);\n    }\n}\n\nint main() {\n    int M,N;\n    cin >> M >> N;\n    int K, s, t;\n    string cnd;\n    vector<vector<int>> comInf(M,vector<int>(N,0));\n    vector<vector<int>> comSup(M,vector<int>(N,100));\n    vector<int> sp(N,0);\n\n    for(int i=0; i<M ; i++){\n        cin >> K;\n        for(int j=0; j<K ; j++){\n            cin >> s >> cnd >> t;\n            s--;\n            if(cnd == \">=\"){\n                comInf[i][s] = max(comInf[i][s],t);\n            }else{\n                comSup[i][s] = min(comSup[i][s],t);\n            }\n        }\n    }\n    for(int i=0 ; i< M ; i++){\n        vector<int> ansInf(N,0);\n        vector<int> ansSup(N,100);\n        if(!isOK2after1(comInf[i],comSup[i])){\n            cout << \"No\" << endl;\n            return 0;\n        }\n        vector<bool> isOK(M,false);\n        for(int j=0; j<i ; j++){\n            if(isOK2after1(comInf[i], comSup[j])) {\n                if(!isOK2after1(comInf[j],comSup[i])){\n                    conditionSup(ansSup, comSup[j]);\n                }\n            }else{\n                condition(ansInf, comInf[j]);\n                if(!isOK2after1(comInf[j],comSup[i])){\n                    cout << \"No\" << endl;\n                    return 0;\n                }\n            }\n        }\n        condition(ansInf,comInf[i]);\n        /*\n        for(int j=0; j<i ; j++){\n            if(isOK[j]){\n                if(!isOK2after1(ansInf,comSup[j])){\n                    cout << \"No\" << endl;\n                    return 0;\n                }\n            }\n        }\n        */\n        if(!isOK2after1(ansInf,ansSup)){\n            cout << \"No\" << endl;\n            return 0;\n        }\n    }\n    cout << \"Yes\" << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#define llint long long\n#define inf 1e18\n\nusing namespace std;\ntypedef pair<llint, llint> P;\n\nllint m, n;\nllint lb[105][105], ub[105][105];\nvector<llint> G[105];\nvector<llint> topo;\nbool used[105];\n\nvoid tpsort(int v)\n{\n\tused[v] = true;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tif(!used[G[v][i]]) tpsort(G[v][i]);\n\t}\n\ttopo.push_back(v);\n}\n\nint main(void)\n{\n\tcin >> m >> n;\n\tllint x, s, t; string c;\n\tfor(int i = 1; i <= m; i++){\n\t\tfor(int j = 1; j <= n; j++) ub[i][j] = inf, lb[i][j] = -inf;\n\t\tcin >> x;\n\t\tfor(int j = 0; j < x; j++){\n\t\t\tcin >> s >> c >> t;\n\t\t\tif(c == \"<=\") ub[i][s] = min(ub[i][s], t);\n\t\t\telse lb[i][s] = max(lb[i][s], t);\n\t\t}\n\t}\n\t\n\tfor(int i = 1; i <= m; i++){\n\t\tfor(int j = 1; j <= n; j++){\n\t\t\tif(ub[i][j] < lb[i][j]){\n\t\t\t\tcout << \"No\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 1; i <= m; i++){\n\t\tfor(int j = 1; j <= m; j++){\n\t\t\tfor(int k = 1; k <= n; k++){\n\t\t\t\tif(ub[i][k] < lb[j][k]){\n\t\t\t\t\tG[i].push_back(j);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t\n\tfor(int i = 1; i <= m; i++) if(!used[i]) tpsort(i);\n\treverse(topo.begin(), topo.end());\n\t\n\tfor(int i = 1; i <= m; i++) used[i] = false;\n\tfor(int i = 0; i < topo.size(); i++){\n\t\tint v = topo[i];\n\t\tused[v] = true;\n\t\tfor(int j = 0; j < G[v].size(); j++){\n\t\t\tif(used[G[v][j]]){\n\t\t\t\tcout << \"No\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"Yes\" << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nint M,N;\nint R[111];\nbool used[111];\nint main(){\n  vector<P> L[101];\n  vector<P> U[101];\n  cin >> M >> N;\n  for(int i=0;i<M;i++){\n    int K; cin >> K;\n    for(int j=0;j<K;j++){\n      int s,t; string c;\n      cin >> s >> c >> t;\n      --s;\n      if( c[0] == '<' )\n        L[i].push_back( P(s,t) );\n      else \n        U[i].push_back( P(s,t) );      \n    }    \n  }\n  \n  for(int cnt=0;cnt<M;cnt++){\n    int tmp[111];\n    for(int i=0;i<N;i++)\n      tmp[i] = R[i];    \n\n    for(int i=0;i<M;i++){\n      if(used[i]) continue;\n      for(int j=0;j<(int)U[i].size();j++)\n        tmp[U[i][j].first] = max( tmp[U[i][j].first], U[i][j].second );\n      bool ok = true;\n      for(int j=0;j<M;j++){\n        if( used[j] ) continue;\n        for(int k=0;k<(int)L[j].size();k++)\n          if( tmp[L[j][k].first] > L[j][k].second ) {\n            ok = false; break;\n          }\n        if( !ok ) break;\n      }\n      if( ok ){\n        used[i] = true;\n        for(int j=0;j<N;j++){\n          R[j] = tmp[j];\n        }\n        break;\n      }\n    }\n  }\n  for(int i=0;i<M;i++)\n    if( !used[i] ) {\n      cout << \"No\" << endl; return 0;\n    }\n  cout << \"Yes\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nusing graph = vector<vector<int>>;\n\n\nbool dfs(graph const& g, int v, vector<int>& flag) {\n    bool res = true;\n    if(flag[v] == 1) {\n        res = false;\n    } else if(flag[v] == 0) {\n        flag[v] = 1;\n        for(int i=0; i<g[v].size(); ++i) {\n            res &= dfs(g, g[v][i], flag);\n        }\n        flag[v] = 2;\n    }\n    return res;\n}\n\nint main() {\n    int M, N;\n    cin >> M >> N;\n    vector<vector<int>> ul(M, vector<int>(N, -1)), ll(M, vector<int>(N, -1));\n    bool ok = true;\n    for(int i=0; i<M; ++i) {\n        int K;\n        cin >> K;\n        for(int j=0; j<K; ++j) {\n            int s, t;\n            string cond;\n            cin >> s >> cond >> t;\n            --s;\n            if(cond == \"<=\") {\n                if(ll[i][s] > t) {\n                    ok = false;\n                }\n                if(ul[i][s] == -1) {\n                    ul[i][s] = t;\n                } else {\n                    ul[i][s] = min(ul[i][s], t);\n                }\n            } else {\n                if(ul[i][s] != -1 && ul[i][s] < t) {\n                    ok = false;\n                }\n                if(ll[i][s] == -1) {\n                    ll[i][s] = t;\n                } else {\n                    ll[i][s] = max(ll[i][s], t);\n                }\n            }\n        }\n    }\n\n    if(ok) {\n        graph g(M);\n        vector<int> flag(M, 0);\n        for(int i=0; i<M; ++i) {\n            for(int j=0; j<M; ++j) {\n                if(i == j) {\n                    continue;\n                }\n                bool ok = false;\n                for(int k=0; k<N; ++k) {\n                    ok |= (ul[i][k] < ll[j][k]) && ul[i][k] != -1 && ll[j][k] != -1;\n                }\n                if(ok) {\n                    g[i].push_back(j);\n                }\n            }\n        }\n        for(int i=0; i<M; ++i) {\n            if(flag[i] == 0) {\n                if(!dfs(g, i, flag)) {\n                    ok = false;\n                    break;\n                }\n            }\n        }\n    }\n    cout << (ok ? \"Yes\" : \"No\") << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n\ntypedef struct Cond{\n  int kind;\n  int arrow;\n  int bound;\n}cond;\n\nbool sr(const cond& l, const cond& r){\n  return l.kind==r.kind ? l.arrow < r.arrow : l.kind < r.kind;\n}\n\nclass Graph{\npublic:\n  int v;\n  vector<int> visited,visiting;\n  vector<int> e[100];\n  Graph(int m){\n    v = m;\n    visited = vector<int>(v);\n    visiting = vector<int>(v);\n  }\n  void addEdge(int e1,int e2){\n    if (find(e[e1].begin(),e[e1].end(),e2)==e[e1].end()){\n      e[e1].push_back(e2);\n    }\n  }\n  int dfs(int vv){\n    int ret = 0;\n    visited[vv] = 1;\n    visiting[vv] = 1;\n    rep(i,e[vv].size()){\n      if(!visited[e[vv][i]]){\n        ret += dfs(e[vv][i]);\n      } else if (visiting[e[vv][i]]==1){\n        return 1;\n      }\n    }\n    visiting[vv] = 0;\n    return 0;\n  }\n};\n\n\nint main(){\n\n  int m,n;\n  cin >> m >> n;\n  vector<int> k(m);\n  vector<cond> conditions[100];\n  pair<int,int> sections[100][100];\n\n  rep(i,m){\n    cin >> k[i];\n    conditions[i] = vector<cond>(k[i]);\n    rep(j,k[i]){\n      string c;\n      cin >> conditions[i][j].kind >> c >> conditions[i][j].bound;\n      conditions[i][j].kind--;\n      if (c==\">=\"){\n        conditions[i][j].arrow = 0;\n      } else {\n        conditions[i][j].arrow = 1;\n      }\n    }\n    sort(conditions[i].begin(),conditions[i].end(),sr);\n    //commandの条件内で矛盾を探す\n    rep(j,101){sections[i][j].first=0;sections[i][j].second=101;}\n    rep(j,conditions[i].size()){\n      int k = conditions[i][j].kind;\n      if (conditions[i][j].arrow == 0){\n        sections[i][k].first = max(sections[i][k].first,conditions[i][j].bound);\n      } else {\n        sections[i][k].second = min(sections[i][k].second,conditions[i][j].bound);\n      }\n    }\n    rep(j,n){\n      if(sections[i][j].first>sections[i][j].second){\n        cout << \"No\" << endl;\n        return 0;\n      }\n    }\n  }\n  //sections[i][j]: i番目のcommand,j番目のskillポイントがfirst以上second以下\n  //skillポイントを固定して条件を見ていって，区間に交わりがない場合は小→大へ辺を張る\n  Graph g(m);\n  rep(skill,n){\n    rep(com1,m){\n      rep(com2,m){\n        if (com1!=com2){\n          int com1l = sections[com1][skill].first;\n          int com1r = sections[com1][skill].second;\n          int com2l = sections[com2][skill].first;\n          int com2r = sections[com2][skill].second;\n          if (com2r < com1l){\n            g.addEdge(com2,com1);\n          } else if (com1r < com2l){\n            g.addEdge(com1,com2);\n          }\n        }\n      }\n    }\n  }\n  //閉路判定\n  int result = g.dfs(0);\n  if (result == 0){\n    cout << \"Yes\" << endl;\n  } else {\n    cout << \"No\" << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\nusing namespace std;\n\nint m,n;\nint k[101];\nint data[101][101][2];\nint s[101][101],cond[101][101],t[101][101];\nint now[101];\nint next[101];\nbool used[101];\n\nint main(void){\n\tscanf(\"%d %d\",&m,&n);\n\tfor(int i=0;i<=100;i++){\n\t\tfor(int j=0;j<=100;j++){\n\t\t\tdata[i][j][0]=0;\n\t\t\tdata[i][j][1]=101;\n\t\t}\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tscanf(\"%d\",&k[i]);\n\t\tfor(int j=0;j<k[i];j++){\n\t\t\tchar d;\n\t\t\tscanf(\"%d %c%*c %d\",&s[i][j],&d,&t[i][j]);\n\t\t\tif(d=='<')cond[i][j]=0;\n\t\t\telse cond[i][j]=1;\n\t\t}\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tfor(int j=0;j<k[i];j++){\n\t\t\tif(cond[i][j]==0)data[i][s[i][j]][1]=min(t[i][j],data[i][s[i][j]][1]);\n\t\t\tif(cond[i][j]==1)data[i][s[i][j]][0]=max(t[i][j],data[i][s[i][j]][0]);\n\t\t\tif(data[i][s[i][j]][1]<data[i][s[i][j]][0]){\n\t\t\t\tprintf(\"No\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tmemset(used,false,sizeof(used));\n\tfor(int i=1;i<=n;i++)now[i]=100;\n\tint i;\n\tfor(i=0;i<m;i++){\n\t\tint nec=-1;\n\t\tint j;\n\t\tfor(j=0;j<m;j++){\n\t\t\tif(used[j])continue;\n\t\t\tfor(int k=1;k<=n;k++){\n\t\t\t\tif(now[k]<data[j][k][0]){\n\t\t\t\t\tprintf(\"No\\n\");\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t\tif(now[k]>data[j][k][1])next[k]=data[j][k][1];\n\t\t\t\telse next[k]=now[k];\n\t\t\t}\n\t\t\tbool flag=true;\n\t\t\tfor(int k=0;k<m;k++){\n\t\t\t\tif(used[k])continue;\n\t\t\t\tfor(int l=1;l<=n;l++){\n\t\t\t\t\tif(next[l]<data[k][l][0]){\n\t\t\t\t\t\tflag=false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag){\n\t\t\t\tnec=j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(nec==-1)break;\n\t\tused[nec]=true;\n\t\tfor(int j=1;j<=n;j++)now[j]=next[j];\n\t}\n\tprintf(\"%s\\n\",i==m?\"Yes\":\"No\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\n//??????A[a,b]??¨??????B[c,d]?????¢???\nint intervalState(int a, int b, int c, int d){\n    if(a < c && b < c) return 0;            //A < B\n    else if(a > d && b > d) return 1;       //A > B\n    else if(a <= c && d <= b) return 2;     //A -> B\n    else if(c < a && b < d) return 3;       //B -> A\n    else if(a <= c && b < d) return 4;      //A <= B\n    else if(c < a && d <= b) return 5;      //A >= B\n    return -1;\n}\n\n//Give input directly to vector<pair<int, int>> in\nvector<pair<int, int>> JoinInterval(vector<pair<int,int>> in){\n    vector<pair<int, int>> v;\n    rep(i,in.size()) in[i].second *= -1;\n    sort(all(in));\n    rep(i,in.size()) in[i].second *= -1;\n\n    rep(i,in.size()){\n        if(v.empty()) v.emplace_back(in[i]);\n        else{\n            pair<int, int> &u = v.back();\n            int tmp = intervalState(in[i].first,in[i].second,u.first,u.second);\n            switch (tmp){\n                case 0:\n                case 1:\n                    v.emplace_back(in[i]);\n                    break;\n                case 2:\n                    u.first = in[i].first;\n                    u.second = in[i].second;\n                    break;\n                case 3:\n                    break;\n                case 4:\n                case 5:\n                    u.first = max(u.first, in[i].first);\n                    u.second = min(u.second, in[i].second);\n                    break;\n                case -1:\n                    assert(0);\n            }\n        }\n    }\n    sort(all(v));\n    return v;\n}\n\nint isBigger(vector<pair<int, int>> a, vector<pair<int, int>> b){\n    bool ret[6] = {0};\n    rep(i,101){\n        int tmp = intervalState(a[i].first,a[i].second,b[i].first,b[i].second);\n        assert(tmp <= 5);\n        ret[tmp] = true;\n    }\n    if(ret[0] && ret[1]) return -1;\n    else if(ret[0]) return 0;\n    else if(ret[1]) return 1;\n    else return 2;\n}\n\nint main(){\n    int m,n;\n    vector<pair<int,int>> v[105]; //v[i] := i??????????????????????????¶\n    rep(i,105) v[i] = vector<pair<int,int>>(105);\n    rep(i,105) rep(j,105) v[i][j] = make_pair(0,105);\n\n    cin >> m >> n;\n    rep(i,m){\n        int k;\n        cin >> k;\n        map<int,vector<pair<int, int>>> m;\n        rep(j,k){\n            int num, point;\n            string s;\n            cin >> num >> s >> point;\n            num--;\n\n            pair<int, int> p;\n            if(s[0] == '<') p = make_pair(0,point);\n            else p = make_pair(point,105);\n            m[num].emplace_back(p);\n        }\n        for(auto it : m){\n            vector<pair<int, int>> in = JoinInterval(it.second);\n            if(in.size() >= 2){\n                cout << \"No\" << endl;\n                return 0;\n            }\n            v[i][it.first] = in[0];\n        }\n    }\n\n    rep(i,n){\n    //rep(i,m){ rep(j,n){ cout << v[i][j].first << ' ' << v[i][j].second << endl; } cout << endl; } cout << endl;\n        rep(j,n- 1){\n            switch (isBigger(v[j],v[j + 1])) {\n                case 0:\n                    //g[j][j + 1] = 1;\n                    break;\n                case 1:\n                    swap(v[j],v[j + 1]);\n                    //g[j + 1][j] = 1;\n                    break;\n                case 2:\n                    break;\n                case -1:\n                    cout << \"No\" << endl;\n                    return 0;\n\n                default:\n                    assert(1);\n            }\n        }\n    }\n\n    int point[105] = {0};\n    rep(i,n){\n        rep(j,m){\n            if(point[j] >= v[i][j].first && point[j] <= v[i][j].second) continue;\n            if(point[j] < v[i][j].first){\n                point[j] = v[i][j].first;\n            }else if(point[j] > v[i][j].first){\n                cout << \"No\" << endl;\n                return 0;\n            }\n            //show(point[j])\n        }\n        //cout << endl;\n    }\n    cout << \"Yes\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n\nclass Requirement{\npublic:\n  int upper;\n  int lower;\n  Requirement() : upper(INF),lower(0) {}\n  Requirement(int _u,int _l) : upper(_u),lower(_l) {}\n};\n\nint total_commands;\nint total_skills;\n\nbool check_path(int from_command,int to_command,\n\t\tRequirement requirement[101][101]){\n  for(int skill_id = 1; skill_id <= total_skills;skill_id++){\n    if(requirement[from_command][skill_id].lower\n       > requirement[to_command][skill_id].upper){\n      return false;\n    }\n    // if(requirement[from_command][skill_id].upper\n    //    < requirement[to_command][skill_id].lower){\n    //   return false;\n    // }\n  }\n  return true;\n}\n\nint main(){\n  while(~scanf(\"%d %d\",&total_commands,&total_skills)){\n    Requirement requirement[101][101];\n\n    bool is_valid[101];\n    memset(is_valid,true,sizeof(is_valid));\n    for(int command_idx = 0; command_idx < total_commands; command_idx++){\n      int total_conditions;\n      scanf(\"%d\",&total_conditions);\n      for(int condition_idx = 0; condition_idx < total_conditions; condition_idx++){\n\tint skill_id;\n\tstring symbol;\n\tint required_point;\n\tcin >> skill_id >> symbol >> required_point;\n\tif(symbol == \">=\") {\n\t  requirement[command_idx][skill_id].lower\n\t    = max(required_point,requirement[command_idx][skill_id].lower);\n\t}\n\telse if(symbol == \"<=\"){\n\t  requirement[command_idx][skill_id].upper\n\t    = min(required_point,requirement[command_idx][skill_id].lower);\n\t}\n\t\n\tif(requirement[command_idx][skill_id].lower\n\t   > requirement[command_idx][skill_id].upper){\n\t  is_valid[command_idx] = false;\n\t}\n      }\n    }\n\n    \n    bool edge[101][101];\n    //init\n    for(int from = 0; from < total_commands; from++){\n      for(int to = 0; to < total_commands; to++){\n\tedge[from][to] = check_path(from,to,requirement);\n      }\n    }\n\n    bool used[101];\n    memset(used,false,sizeof(used));\n\n    for(int round = 0; round < total_commands; round++){\n      for(int start = 0; start < total_commands; start++){\n\tif(!is_valid[start]) continue;\n\t\n\tbool select = true;\n\tfor(int to = 0; to < total_commands; to++){\n\t  if(!edge[start][to] && !used[to]){\n\t    select = false;\n\t    break;\n\t  }\n\t  if(!is_valid[to]){\n\t    select = false;\n\t    break;\n\t  }\n\t}\n\t\n\tif(select){\n\t  used[start] = true;\n\t}\n      }\n    }\n    \n    int count = 0;\n    for(int command_idx=0;command_idx<total_commands;command_idx++){\n      if(used[command_idx]) count++;\n    }\n    printf(\"%s\\n\",(count == total_commands) ? \"Yes\" : \"No\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\n#include<bitset>\n#include<stack>\n#include<memory>\nusing namespace std;\nusing namespace std::chrono;\ntypedef long long int llint;\ntypedef double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n/*cout<<fixed<<setprecision(20);cin.tie(0);ios::sync_with_stdio(false);*/\nconst llint mod=998244353;\nconst llint big=2.19e15+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-15;\ntemplate <class T,class U>bool mineq(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool maxeq(T& a,U b){if(a<b){a=b;return true;}return false;}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){if(a==0){return b;}return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>llint LBI(vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>llint UBI(vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\nint main(void){\n\tint n,m,i,j,k;cin>>m>>n;\n\tstatic int uL[100][100];\n\tstatic int dL[100][100];\n\tfor(i=0;i<m;i++){\n\t\tfor(j=0;j<n;j++){\n\t\t\tuL[i][j]=mod;\n\t\t\tdL[i][j]=0;\n\t\t}\n\t}\n\tfor(i=0;i<m;i++){\n\t\tint K;cin>>K;\n\t\twhile(K--){\n\t\t\tint s,t;\n\t\t\tstring cond;\n\t\t\tcin>>s>>cond>>t;s--;\n\t\t\tif(cond==\"<=\"){mineq(uL[i][s],t);}\n\t\t\telse{maxeq(dL[i][s],t);}\n\t\t}\n\t}\n\tfor(i=0;i<m;i++){\n\t\tfor(j=0;j<n;j++){\n\t\t\tif(uL[i][j]<dL[i][j]){cout<<\"No\"<<endl;return 0;}\n\t\t}\n\t}\n\tvector<vector<int>>go(m);\n\tvector<int>zi(m);\n\tfor(i=0;i<m;i++){\n\t\tfor(j=0;j<m;j++){\n\t\t\tbool aru=false;\n\t\t\tfor(k=0;k<n;k++){\n\t\t\t\tif(uL[i][k]<dL[j][k]){aru=true;break;}\n\t\t\t}\n\t\t\tif(aru){go[i].pub(j);zi[j]++;}\n\t\t}\n\t}\n\tqueue<int>que;\n\tfor(i=0;i<m;i++){if(zi[i]==0){que.push(i);}}\n\tint toru=0;\n\twhile(que.size()){\n\t\ttoru++;\n\t\tint x=que.front();\n\t\tque.pop();\n\t\tfor(auto it:go[x]){\n\t\t\tzi[it]--;\n\t\t\tif(zi[it]==0){que.push(it);}\n\t\t}\n\t}\n\tcout<<(toru==m?\"Yes\":\"No\")<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n\nint const inf = 1<<29;\n\nbool isDAG(vector<vector<int>>& G) {\n  int N = G.size();\n  vector<bool> vis(N);\n\n  std::function<bool(int, unordered_set<int>&)> dfs = [&](int curr, unordered_set<int>& st) {\n    for(auto&& e: G[curr]) {\n      if(st.count(e)) return false;\n      if(vis[e]) continue;\n      st.insert(e);\n      vis[e] = 1;\n      if(!dfs(e, st)) return false;\n      st.erase(e);\n    }\n    return true;\n  };\n\n  rep(e, N) {\n    vis[e] = 1;\n    unordered_set<int> st = {e};\n    if(!dfs(e, st)) return false;\n  }\n  return true;\n}\n\nint main() {\n\n  int M, N; cin >> M >> N;\n  vector<vector<pair<int, int>>> cmd_sect(N, vector<pair<int, int>>(M, {0, inf}));\n\n  rep(cmd_idx, M) {\n    int K; cin >> K;\n    rep(_, K) {\n      int skill; cin >> skill; skill--;\n      string op; cin >> op;\n      int threshold; cin >> threshold;\n      if(op == \">=\") {\n        cmd_sect[skill][cmd_idx].first = max(cmd_sect[skill][cmd_idx].first, threshold);\n      } else {\n        cmd_sect[skill][cmd_idx].second = min(cmd_sect[skill][cmd_idx].second, threshold);\n      }\n      if(cmd_sect[skill][cmd_idx].first > cmd_sect[skill][cmd_idx].second) {\n        cout << \"No\" << endl;\n        return 0;\n      }\n    }\n  }\n\n  vector<vector<int>> G(M);\n  \n  rep(i, N) {\n    rep(a, M) REP(b, a+1, M) {\n      if(cmd_sect[i][a].second < cmd_sect[i][b].first)\n        G[a].push_back(b);\n      if(cmd_sect[i][a].second > cmd_sect[i][b].first)\n        G[b].push_back(a);\n    }\n  }\n\n  rep(i, M) {\n    sort(all(G[i]));\n    G[i].erase(unique(all(G[i])), G[i].end());\n  }\n\n  cout << (isDAG(G) ? \"Yes\" : \"No\") << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n\nclass Requirement{\npublic:\n  int upper;\n  int lower;\n  Requirement() : upper(INF),lower(0) {}\n  Requirement(int _u,int _l) : upper(_u),lower(_l) {}\n};\n\nint total_commands;\nint total_skills;\n\nbool check_path(int from_command,int to_command,\n\t\tRequirement requirement[101][101]){\n  for(int skill_id = 0; skill_id < total_skills;skill_id++){\n    if(requirement[from_command][skill_id].lower\n       > requirement[to_command][skill_id].upper){\n      return false;\n    }\n    // if(requirement[from_command][skill_id].upper\n    //    < requirement[to_command][skill_id].lower){\n    //   return false;\n    // }\n  }\n  return true;\n}\n\nint main(){\n  while(~scanf(\"%d %d\",&total_commands,&total_skills)){\n    Requirement requirement[101][101];\n\n    bool is_valid[101];\n    memset(is_valid,true,sizeof(is_valid));\n    for(int command_idx = 0; command_idx < total_commands; command_idx++){\n      int total_conditions;\n      scanf(\"%d\",&total_conditions);\n      for(int condition_idx = 0; condition_idx < total_conditions; condition_idx++){\n\tint skill_id;\n\tstring symbol;\n\tint required_point;\n\tcin >> skill_id >> symbol >> required_point;\n\tskill_id--;\n\tif(symbol == \">=\") {\n\t  requirement[command_idx][skill_id].lower\n\t    = max(required_point,requirement[command_idx][skill_id].lower);\n\t}\n\telse if(symbol == \"<=\"){\n\t  requirement[command_idx][skill_id].upper\n\t    = min(required_point,requirement[command_idx][skill_id].upper);\n\t}\n\t\n\tif(requirement[command_idx][skill_id].lower\n\t   > requirement[command_idx][skill_id].upper){\n\t  is_valid[command_idx] = false;\n\t}\n      }\n    }\n\n    \n    bool edge[101][101];\n    //init\n    for(int from = 0; from < total_commands; from++){\n      for(int to = 0; to < total_commands; to++){\n\tedge[from][to] = check_path(from,to,requirement);\n      }\n    }\n\n    bool used[101];\n    memset(used,false,sizeof(used));\n\n    for(int round = 0; round < total_commands; round++){\n      for(int start = 0; start < total_commands; start++){\n\tif(!is_valid[start]) continue;\n\tif(used[start]) continue;\n\n\tbool select = true;\n\tfor(int to = 0; to < total_commands; to++){\n\t  if(!edge[start][to] && !used[to]){\n\t    select = false;\n\t    break;\n\t  }\n\t  if(!is_valid[to]){\n\t    select = false;\n\t    break;\n\t  }\n\t}\n\t\n\tif(select){\n\t  used[start] = true;\n\t}\n      }\n    }\n    \n    int count = 0;\n    for(int command_idx=0;command_idx<total_commands;command_idx++){\n      if(used[command_idx]) count++;\n    }\n    printf(\"%s\\n\",(count == total_commands) ? \"Yes\" : \"No\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define ALL(a) (a).begin(), (a).end()\n#define ll long long\n\nusing namespace std;\n\nsigned main(){\n    const string GL = \">=\";\n    int n,m; cin >> m >> n;\n    vector<vector<int> > g(m, vector<int>(n,0));\n    vector<vector<int> > l(m, vector<int>(n,100));\n    for(int i = 0; i < m; i++){\n        int k; cin >> k;\n        for(int j = 0; j < k; j++){\n            int s,t; string c;\n            cin >> s >> c >> t;\n            s--;\n            if(c == GL){\n                g[i][s] = max(g[i][s], t);\n            }\n            else{\n                l[i][s] = min(l[i][s], t);\n            }\n        }\n    }\n    vector<bool> isget(m, false);\n    vector<int> skill(n, 0);\n    for(int i = 0; i < m; i++){\n        for(int j = 0; j < m+1; j++){\n            if(j == m){\n                cout << \"No\" << endl;\n                return 0;\n            }\n            if(isget[j])continue;\n            vector<int> st = skill;\n            for(int k = 0; k < n; k++){\n                if(st[k] < g[j][k])st[k] = g[j][k];\n            }\n            bool flag = true;\n            for(int k = 0; k < m; k++){\n                if(isget[k])continue;\n                for(int p = 0; p < n; p++){\n                    if(st[p] > l[k][p]){\n                        flag = false;\n                        k = m;\n                        break;\n                    }\n                }\n            }\n            if(flag){\n                swap(skill, st);\n                isget[j] = true;\n                break;\n            }\n        }\n    }\n    cout << \"Yes\" << endl;\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nint M,N;\nint R[111];\nbool used[111];\nint main(){\n  vector<P> L[101];\n  vector<P> U[101];\n  cin >> M >> N;\n  for(int i=0;i<M;i++){\n    int K; cin >> K;\n    for(int j=0;j<K;j++){\n      int s,t; string c;\n      cin >> s >> c >> t;\n      --s;\n      if( c[0] == '<' )\n        L[i].push_back( P(s,t) );\n      else \n        U[i].push_back( P(s,t) );      \n    }    \n  }\n  \n  for(int cnt=0;cnt<M;cnt++){\n    int tmp[111];\n    for(int i=0;i<N;i++)\n      tmp[i] = R[i];    \n\n    for(int i=0;i<M;i++){\n      if(used[i]) continue;\n      for(int j=0;j<(int)U[i].size();j++)\n        tmp[U[i][j].first] = max( tmp[U[i][j].first], U[i][j].second );\n      bool ok = true;\n      for(int j=0;j<M;j++){\n        if( used[j] ) continue;\n        if( j == i ) continue;\n        for(int k=0;k<(int)L[j].size();k++)\n          if( tmp[L[j][k].first] > L[j][k].second ) {\n            ok = false; break;\n          }\n        if( !ok ) break;\n      }\n      if( ok ){\n        used[i] = true;\n        for(int j=0;j<N;j++){\n          R[j] = tmp[j];\n        }\n        break;\n      }\n    }\n  }\n  for(int i=0;i<M;i++)\n    if( !used[i] ) {\n      cout << \"No\" << endl; return 0;\n    }\n  cout << \"Yes\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define range(i, a, n) for(int (i) = (a); (i) < (n); (i)++)\n#define rep(i, n) for(int (i) = 0; (i) < (n); (i)++)\nusing namespace std;\n\nint n, m;\n\nint main(void){\n    cin >> m >> n;\n\n    vector<vector<pair<int, int>>> rng(m, vector<pair<int, int>>(n, make_pair(-100, 200)));\n    rep(i, m){\n        int K; cin >> K;\n        rep(loop, K){\n            int s, t; string cond; cin >> s >> cond >> t;\n            s--;\n\n            if(cond == \">=\"){\n                rng[i][s].first = max(rng[i][s].first, t);\n            }\n            else {\n                rng[i][s].second = min(rng[i][s].second, t);\n            }\n        }\n\n        rep(j, n){\n            if(rng[i][j].first > rng[i][j].second){\n                cout << \"NO\" << endl;\n                return 0;\n            }\n        }\n    }\n\n    int cnt = 0;\n    while(cnt < m){\n        bool ok1 = false;\n        [&]{\n            rep(a, m){\n                bool ok2 = true;\n                [&]{\n                    rep(b, m){\n                        if(a == b) continue;\n                        rep(i, n){\n                            if(rng[b][i].second < rng[a][i].first){\n                                ok2 = false;\n                                return;\n                            }\n                        }\n                    }\n                }();\n                if(ok2){\n                    cnt++;\n                    ok1 = true;\n                    return;\n                }\n            }\n        }();\n        \n        if(not ok1) break;\n    }\n\n    cout << (cnt == m ? \"YES\":\"NO\") << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1<<29\nusing namespace std;\n\nint n,m,K,a,b;\nstring s,ans=\"Yes\";\nint skill[101][101][2];\nvector<int> v[101];\nbool checked[101]={},visited[101]={};\n\nvoid init(){\n  for(int i=0;i<101;i++){\n    for(int j=0;j<101;j++){\n      skill[i][j][0]=inf;\n      skill[i][j][1]=inf;\n    }\n  }\n}\n\nvoid dfs(int num){\n  if(visited[num]){\n    ans=\"No\";\n    return;\n  }\n  visited[num]=true;\n  for(int i=0;i<v[num].size();i++){\n    if(!checked[v[num][i]])dfs(v[num][i]);\n  }\n  checked[num]=true;\n  visited[num]=false;\n}\n\nint main()\n{\n  init();\n  cin>>m>>n;\n  for(int i=0;i<m;i++){\n    cin>>K;\n    for(int j=0;j<K;j++){\n      cin>>a>>s>>b;\n      a--;\n      if(s[0]=='>')skill[i][a][0]=b;\n      else skill[i][a][1]=b;\n    }\n  }\n  for(int i=0;i<m;i++){\n    for(int j=0;j<m;j++){\n      bool flag=false;\n      for(int k=0;k<n;k++){\n\tif(skill[i][k][1]==inf)continue;\n\tif(skill[j][k][1]!=inf && skill[j][k][0]<=skill[i][k][1])flag=true;\n\tif(skill[j][k][0]!=inf && skill[j][k][1]<=skill[i][k][0])flag=true;\n      }\n      if(flag)v[i].push_back(j);\n    }\n  }\n  for(int i=0;i<m;i++){\n    if(!checked[i])dfs(i);\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#define r(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n#define F first\n#define S second\ntypedef pair<int,int>P;\nint n,m,x,y,K,a[102][102],flag,amin[102],amax[102];\nstring s;\nvector<P>v1[102],v2[102];\nbool ch(){\n  r(i,m){\n    r(j,v1[i].size()){\n      r(k,v2[i].size()){\n\tif(v1[i][j].F==v2[i][k].F&&v1[i][j].S<v2[i][k].S) return 1;\n      }\n    }\n  }\n  return 0;\n}\nvoid make_Graph(){\n  r(i,102)amax[i]=1e8;\n  r(i,m){\n    r(j,v1[i].size())amax[i]=min(amax[i],v1[i][j].S);\n    r(j,v2[i].size())amin[i]=max(amin[i],v2[i][j].S);\n  }\n  r(i,m)r(j,m)if(amax[i]<amin[j])a[i][j]=-1;\n}\nint main(){\n  cin>>m>>n;\n  r(i,m){\n    cin>>K;\n    r(j,K){\n      cin>>x>>s>>y;\n      if(s==\"<=\")v1[i].push_back(P(x,y));\n      else v2[i].push_back(P(x,y));\n    }\n  }\n  if(ch())cout<<\"No\"<<endl;\n  else{\n    r(i,102)r(j,102)a[i][j]==(i==j?0:100);\n    make_Graph();\n    n++;\n    r(o,m)r(i,m)r(j,m)a[i][m]=min(a[i][j],a[i][o]+a[o][j]);\n    r(i,102)if(a[i][i]<0)flag++;\n    cout<<(flag?\"No\":\"Yes\")<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define range(i, a, n) for(int (i) = (a); (i) < (n); (i)++)\n#define rep(i, n) for(int (i) = 0; (i) < (n); (i)++)\nusing namespace std;\n\nint n, m;\n\nint main(void){\n    cin >> m >> n;\n\n    vector<vector<pair<int, int>>> rng(m, vector<pair<int, int>>(n, make_pair(-100, 200)));\n    rep(i, m){\n        int K; cin >> K;\n        rep(loop, K){\n            int s, t; string cond; cin >> s >> cond >> t;\n            s--;\n\n            if(cond == \">=\"){\n                rng[i][s].first = max(rng[i][s].first, t);\n            }\n            else {\n                rng[i][s].second = min(rng[i][s].second, t);\n            }\n        }\n\n        rep(j, n){\n            if(rng[i][j].first > rng[i][j].second){\n                cout << \"No\" << endl;\n                return 0;\n            }\n        }\n    }\n\n    int cnt = 0;\n    while(cnt < m){\n        bool ok1 = false;\n        [&]{\n            rep(a, m){\n                bool ok2 = true;\n                [&]{\n                    rep(b, m){\n                        if(a == b) continue;\n                        rep(i, n){\n                            if(rng[b][i].second < rng[a][i].first){\n                                ok2 = false;\n                                return;\n                            }\n                        }\n                    }\n                }();\n                if(ok2){\n                    cnt++;\n                    ok1 = true;\n                    return;\n                }\n            }\n        }();\n        \n        if(not ok1) break;\n    }\n\n    cout << (cnt == m ? \"Yes\":\"No\") << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\nstruct Skill{\n    static const int INF = 100000000;\n    static const int N = 100;\n    array<int, N> begin;\n    array<int, N> end;\n    Skill(){\n        begin.fill(-INF);\n        end.fill(INF);\n    }\n    bool operator < (const Skill& s) const {\n        for(int i = 0; i < N; i++){\n            if(end[i] < s.begin[i]) return true;\n        }\n        return false;\n    }\n};\n\nint main(){\n    int M, N;\n    while(cin >> M >> N){\n        vector<Skill> skills(M);\n        REP(i, M){\n            int K;\n            cin >> K;\n            while(K--){\n                int s, t;\n                string cond;\n                cin >> s >> cond >> t;\n                if(cond == \">=\"){\n                    int& x = skills[i].begin[s - 1];\n                    x = max(x, t);\n                }else{\n                    int& y = skills[i].end[s - 1];\n                    y = min(y, t);\n                }\n            }\n        }\n        bool d[100][100] = {};\n        REP(i, M) REP(j, M) if(skills[i] < skills[j]) d[i][j] = true;\n        REP(k, M) REP(i, M) REP(j, M) d[i][j] |= d[i][k] && d[k][j];\n        bool ans = true;\n        REP(i, M) if(d[i][i]) ans = false;\n        cout << (ans ? \"Yes\" : \"No\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\nint M, N, ub[111][111], lb[111][111], skill[111];\n\nint main() {\n\tcin >> M >> N;\n\t\n\tfor_(i,0,M) for_(j,0,N) {\n\t\tub[i][j] = 100;\n\t\tlb[i][j] = 0;\n\t}\n\t\n\tfor_(i,0,M) {\n\t\tint K;\n\t\tcin >> K;\n\t\t\n\t\tfor_(j,0,K) {\n\t\t\tint s, t;\n\t\t\tstring cnd;\n\t\t\tcin >> s >> cnd >> t;\n\t\t\t--s;\n\t\t\t\n\t\t\tif (cnd == \">=\") lb[i][s] = max(lb[i][s], t);\n\t\t\telse ub[i][s] = min(ub[i][s], t);\n\t\t}\n\t\t\n\t\tfor_(j,0,N) if (ub[i][j] < lb[i][j]) {\n\t\t\tcout << \"No\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tmemset(skill, 0, sizeof(skill));\n\t\n\tset< int > learned;\n\t\n\twhile ((int)learned.size() < N) {\n\t\tint tar = -1;\n\t\t\n\t\tfor_(i,0,N) {\n\t\t\tbool isok = true;\n\t\t\t\n\t\t\tfor_(j,0,M) {\n\t\t\t\tif (learned.count(j)) continue;\n\t\t\t\tisok &= (skill[i] + 1 <= ub[j][i]);\n\t\t\t}\n\t\t\t\n\t\t\tif (isok) {\n\t\t\t\ttar = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (tar == -1) {\n\t\t\tcout << \"No\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\t++skill[tar];\n\t\t\n\t\tfor_(i,0,M) {\n\t\t\tbool learn = true;\n\t\t\tfor_(j,0,N) learn &= (lb[i][j] <= skill[j] && skill[j] <= ub[i][j]);\n\t\t\tif (learn) learned.insert(i);\n\t\t}\n\t}\n\t\n\tcout << \"Yes\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair< int, int > Pi;\n\nstruct edge\n{\n  int to, cost;\n};\n\nint N;\nvector< edge > g[100000];\nint depth[100000];\nint childmax[100000];\nint outmax[100000]; // depth????????£?????¨??????????????????max\n\nvoid dfs(int idx, int par = -1)\n{\n  if(g[idx].size() == 1) return;\n\n  priority_queue< Pi, vector< Pi >, greater< Pi > > que1, que2;\n  for(auto& e : g[idx]) {\n    if(e.to == par) continue;\n    dfs(e.to, idx);\n    depth[idx] = max(depth[idx], depth[e.to] + e.cost);\n    que1.emplace(depth[e.to] + e.cost, e.to);\n    while(que1.size() > 1) que1.pop();\n    childmax[idx] = max({childmax[idx], childmax[e.to], e.cost});\n    que2.emplace(max(childmax[e.to], e.cost), e.to);\n    while(que2.size() > 2) que2.pop();\n  }\n  int cnt = 0;\n  for(auto& e : g[idx]) {\n    if(e.to == par) continue;\n    cnt += depth[idx] == depth[e.to] + e.cost;\n  }\n  if(cnt > 1) {\n    outmax[idx] = que2.top().first;\n  } else {\n    auto object = que1.top();\n    auto dump2 = que2.top();\n    que2.pop();\n    auto dump1 = que2.empty() ? dump2 : que1.top();\n    if(que1.empty()) dump2.first = 0;\n    if(object.first == dump1.first) outmax[idx] = max(outmax[object.first], dump2.first);\n    else outmax[idx] = max(outmax[object.first], dump1.first);\n  }\n}\n\nint rec(int idx, int dep = 0, int outer = 0, int route_outer = 0, int par = -1)\n{\n  priority_queue< Pi, vector< Pi >, greater< Pi > > que1, que2;\n  que1.emplace(dep, -1);\n  que2.emplace(route_outer, -1);\n  for(auto& e : g[idx]) {\n    if(e.to == par) continue;\n    que1.emplace(depth[e.to] + e.cost, e.to);\n    que2.emplace(max(childmax[e.to], e.cost), e.to);\n    while(que1.size() > 2) que1.pop();\n    while(que2.size() > 3) que2.pop();\n  }\n  auto object2 = que1.top();  // (child_max_length, idx)\n  que1.pop();\n  auto object1 = que1.empty() ? object2 : que1.top();\n\n  vector< Pi > rev;\n  while(!que2.empty()) {\n    rev.push_back(que2.top());\n    que2.pop();\n  }\n  while(rev.size() < 3) {\n    rev.emplace_back(0, -2);\n  }\n  sort(begin(rev), end(rev));\n  auto dump3 = rev[0];\n  auto dump2 = rev[1];\n  auto dump1 = rev[2];\n\n  int ret = 0;\n\n  for(edge& e : g[idx]) {\n    if(e.to == par) continue;\n    auto object = object1.second == e.to ? object2 : object1;\n\n    if(object.second == -1) {\n      if(dump1.second == -1) {\n        ret = max(ret, rec(e.to, object.first + e.cost, max(outer, dump2.first), max(route_outer, e.cost), idx));\n      } else {\n        if(dump1.second == e.to)\n          ret = max(ret, rec(e.to, object.first + e.cost, max(outer, dump2.first),\n                             max(route_outer, e.cost), idx));\n        else ret = max(ret, rec(e.to, object.first + e.cost, max(outer, dump1.first), max(route_outer, e.cost), idx));\n      }\n    } else {\n      if(dump1.second == object.second) {\n        if(dump2.second == e.to) {\n          ret = max(ret, rec(e.to, object.first + e.cost, max({outer, route_outer, dump3.first, outmax[object.first]}),\n                             max(childmax[object.second], e.cost), idx));\n        } else {\n          ret = max(ret, rec(e.to, object.first + e.cost, max({outer, route_outer, dump2.first, outmax[object.first]}),\n                             max(childmax[object.second], e.cost), idx));\n        }\n      } else {\n        if(dump1.second == e.to) {\n          if(dump2.second == object.second) {\n            ret = max(ret,\n                      rec(e.to, object.first + e.cost, max({outer, route_outer, dump3.first, outmax[object.first]}),\n                          max(childmax[object.second], e.cost), idx));\n          } else {\n            ret = max(ret,\n                      rec(e.to, object.first + e.cost, max({outer, route_outer, dump2.first, outmax[object.first]}),\n                          max(childmax[object.second], e.cost), idx));\n          }\n        } else {\n          ret = max(ret, rec(e.to, object.first + e.cost, max({outer, route_outer, dump1.first, outmax[object.first]}),\n                             max(childmax[object.second], e.cost), idx));\n        }\n      }\n    }\n  }\n  return (max(ret, outer + dep));\n}\n\nint main()\n{\n  scanf(\"%d\", &N);\n  for(int i = 1; i < N; i++) {\n    int P, W;\n    scanf(\"%d %d\", &P, &W);\n    g[P].push_back((edge) {i, W});\n    g[i].push_back((edge) {P, W});\n  }\n  dfs(0);\n  cout << rec(0) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=1000000007,MAX=203,INF=1<<30;\n\nint V,cmp[MAX];\nvector<int> G[MAX],rG[MAX],vs;//vsがトポソの逆順になってる\nbool used[MAX];\n\nvoid add_edge(int from,int to){\n    G[from].push_back(to);\n    rG[to].push_back(from);\n}\n\nvoid DFS(int v){\n    used[v]=1;\n    for(int i=0;i<G[v].size();i++){\n        if(used[G[v][i]]==0) DFS(G[v][i]);\n    }\n    vs.push_back(v);\n}\n\nvoid rDFS(int v,int k){\n    used[v]=1;\n    cmp[v]=k;\n    for(int i=0;i<rG[v].size();i++){\n        if(used[rG[v][i]]==0) rDFS(rG[v][i],k);\n    }\n}\n\nint scc(){\n    memset(used,0,sizeof(used));\n    vs.clear();\n    for(int v=0;v<V;v++){\n        if(used[v]==0) DFS(v);\n    }\n    \n    memset(used,0,sizeof(used));\n    int k=0;\n    for(int i=vs.size()-1;i>=0;i--){\n        if(used[vs[i]]==0) rDFS(vs[i],k++);\n    }\n    return k;\n}\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int M,N;\n    cin>>M>>N;\n    V=M;\n    \n    bool ok=true;\n    \n    vector<vector<int>> S(M,vector<int>(2*N));\n    \n    for(int i=0;i<M;i++){\n        for(int j=N;j<2*N;j++) S[i][j]=100;\n        int k;cin>>k;\n        for(int j=0;j<k;j++){\n            int a,c;string b;cin>>a>>b>>c;\n            a--;\n            if(b[0]=='>'){\n                S[i][a]=max(S[i][a],c);\n            }else{\n                S[i][a+N]=min(S[i][a+N],c);\n            }\n        }\n        \n        for(int j=0;j<N;j++){\n            if(S[i][j]==0||S[i][j+N]==0) continue;\n            \n            if(S[i][j]>S[i][j+N]) ok=false;\n        }\n    }\n    \n    for(int i=0;i<M;i++){\n        for(int j=i+1;j<M;j++){\n            for(int k=0;k<N;k++){\n                int le1=0,ri1=100,le2=0,ri2=100;\n                le1=max(le1,S[i][k]);\n                ri1=min(ri1,S[i][k+N]);\n                \n                le2=max(le2,S[j][k]);\n                ri2=min(ri2,S[j][k+N]);\n                \n                if(ri1<le2) add_edge(i,j);\n                if(ri2<le1) add_edge(j,i);\n                \n                //cout<<i<<\" \"<<j<<\" \"<<k<<\" \"<<le1<<\" \"<<ri1<<\" \"<<le2<<\" \"<<ri2<<endl;\n            }\n        }\n    }\n    \n    int k=scc();\n    \n    if(k==M&&ok) cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n    \n    \n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nstruct skill{\n  int c,t;\n  skill(){}\n  skill(int c,int t):c(c),t(t){}\n};\nvector<vector<int> > G;\nbool used[111];\nbool dfs(int v){\n  if(used[v]) return 0;\n  used[v]=1;\n  bool f=1;\n  for(int i=0;i<(int)G[v].size();i++) f&=dfs(G[v][i]);\n  return f;\n}\nbool solve(int m){\n  bool f=1;\n  for(int i=0;i<m;i++){\n    memset(used,0,sizeof(used));\n    f&=dfs(i);\n  }\n  return f;\n}\nint main(){\n  int m,n;\n  cin>>m>>n;\n  vector<skill> ss[m][n];\n  for(int i=0;i<m;i++){\n    int k;\n    cin>>k;\n    for(int j=0;j<k;j++){\n      int s,t;\n      string c;\n      cin>>s>>c>>t;\n      ss[i][s-1].push_back(skill(c==\"<=\",t));\n    }\n  }\n  G.resize(m);\n  for(int i=0;i<m;i++){\n    for(int j=0;j<m;j++){\n      bool f=0;\n      for(int k=0;k<n;k++){\n\tfor(int x=0;x<(int)ss[i][k].size();x++){\n\t  for(int y=0;y<(int)ss[j][k].size();y++){\n\t    if(ss[i][k][x].t<=ss[j][k][y].t){\n\t      f|=(ss[i][k][x].c==1&&ss[j][k][y].c==0);\n\t    }\n\t  }\n\t}\n      }\n      if(f) G[j].push_back(i);\n      //if(f) cout<<i<<\":\"<<j<<endl;\n    }\n  }\n  cout<<(solve(m)?\"Yes\":\"No\")<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nint M,N;\nint R[111];\nbool used[111];\nint main(){\n  vector<P> L[101];\n  vector<P> U[101];\n  cin >> M >> N;\n  for(int i=0;i<M;i++){\n    int K; cin >> K;\n    for(int j=0;j<K;j++){\n      int s,t; string c;\n      cin >> s >> c >> t;\n      --s;\n      if( c[0] == '<' )\n        L[i].push_back( P(s,t) );\n      else \n        U[i].push_back( P(s,t) );      \n    }    \n  }\n  \n  for(int cnt=0;cnt<M;cnt++){\n    int tmp[111];\n    for(int i=0;i<M;i++){\n      if(used[i]) continue;\n      for(int j=0;j<N;j++)\n        tmp[j] = R[j];    \n      for(int j=0;j<(int)U[i].size();j++)\n        tmp[U[i][j].first] = max( tmp[U[i][j].first], U[i][j].second );\n      bool ok = true;\n      for(int j=0;j<M;j++){\n        if( used[j] ) continue;\n        for(int k=0;k<(int)L[j].size();k++)\n          if( tmp[L[j][k].first] > L[j][k].second ) {\n            ok = false; break;\n          }\n        if( !ok ) break;\n      }\n      if( ok ){\n        used[i] = true;\n        for(int j=0;j<N;j++){\n          R[j] = tmp[j];\n        }\n        break;\n      }\n    }\n  }\n  for(int i=0;i<M;i++)\n    if( !used[i] ) {\n      cout << \"No\" << endl; return 0;\n    }\n  cout << \"Yes\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <stack>\n#include <algorithm>\n#include <string>\n#define rep(i,a,n) for(int i=a; i<n; i++)\nusing namespace std;\n\n// 移動元と行先と辺のコストを記録する構造体\ntemplate <typename T>\nstruct Edge {\n    int from, to;\n    T cost;\n    Edge(int s, T d) : to(s), cost(d) {}\n    Edge(int f, int s, T d) : from(f), to(s), cost(d) {}\n\n    bool operator<(const Edge &e) const {\n        return cost < e.cost;\n    }\n    bool operator>(const Edge &e) const {\n        return cost > e.cost;\n    }\n};\n\ntemplate <typename T>\nusing Graph = vector< vector< Edge<T> > >;\n\ntemplate <typename T>\nvector<int> tpsort_Kahn(const vector< vector< Edge<T> > > &g) {\n    const int V = g.size();\n    vector<int> indeg(V, 0);\n    stack<int> S;\n\n    rep(i,0,V) rep(j,0,g[i].size())\n        indeg[ g[i][j].to ]++;\n    rep(i,0,V) if(indeg[i] == 0) S.push(i);\n\n    vector<int> ans;\n    while(S.size() > 0) {\n        int u = S.top(); S.pop();\n        ans.push_back(u);\n        rep(i,0,g[u].size()) {\n            indeg[ g[u][i].to ]--;\n            if(indeg[ g[u][i].to ] ==  0)\n                S.push( g[u][i].to );\n        }\n    }\n    return ans;\n}\n\nconst int INF = 1 << 28;\nint lb[110][110], ub[110][110];\n\nint main() {\n    int M, N; cin >> M >> N;\n    for(int i=0; i<M; i++) {\n        fill(lb[i], lb[i] + N, INF);\n        fill(ub[i], ub[i] + N,  -1);\n    }\n\n    Graph<int> G(M);\n    bool ok = true;\n    for(int i=0; i<M; i++) {\n        int K; cin >> K;\n        for(int k=0; k<K; k++) {\n            int s, t;\n            string cond;\n            cin >> s >> cond >> t; s--;\n            if(cond == \"<=\") ub[i][s] = t;\n            if(cond == \">=\") lb[i][s] = t;\n        }\n        for(int k=0; k<N; k++) {\n            if(lb[i][k] == INF || ub[i][k] == -1) continue;\n            if(lb[i][k] > ub[i][k]) ok = false;\n        }\n    }\n\n    for(int i=0; i<M; i++) {\n        for(int j=0; j<M; j++) {\n            if(i == j) continue;\n            for(int k=0; k<N; k++) {\n                // i より j の方が後でなければならない条件\n                if(ub[i][k] == -1 || lb[j][k] == INF) continue;\n                if(ub[i][k] < lb[j][k]) {\n                    G[i].push_back(Edge<int>(j, 1));\n                }\n            }\n        }\n    }\n\n    if(tpsort_Kahn(G).size() != M) ok = false;\n    cout << (ok ? \"Yes\" : \"No\") << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\ntypedef pair<LL, LL> PLL;\n\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N, M; cin >> M >> N;\n  vector<vector<PII>> R(M, vector<PII>(N,PII(0,1000)));\n  bool valid = true;\n  REP(i,M){\n\tint K; cin >> K;\n\tREP(j,K){\n\t  int s, t; string c;\n\t  cin >> s >> c >> t;\n\t  --s;\n\t  if(c == \"<=\")\n\t\tR[i][s].SS = min(R[i][s].SS, t);\n\t  else\n\t\tR[i][s].FF = max(R[i][s].FF, t);\n\t  if(R[i][s].FF > R[i][s].SS) valid = false;\n\t}\n  }\n  if(!valid){\n\tcout << \"No\" << endl;\n\treturn 0;\n  }\n  \n  VVI G(M);\n  REP(i,M) REP(j,M){\n\tif(i == j) continue;\n\tbool ok = true;\n\tREP(s,N){\n\t  if(R[j][s].SS < R[i][s].FF) ok = false;\n\t}\n\tif(!ok) G[i].PB(j);\n  }\n\n  vector<bool> use(M);\n  bool up = true;\n  while(up){\n\tup = false;\n\tREP(i,M){\n\t  if(use[i]) continue;\n\t  bool ok = true;\n\t  for(int to: G[i])\n\t\tif(!use[to])\n\t\t  ok = false;\n\t  if(ok) use[i] = up = true;\n\t}\n  }\n  cout << (all_of(ALL(use),[](bool x){return x;})? \"Yes\": \"No\") << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<list>\n#include<cmath>\n#include<queue>\n#include<ctime>\n#include<stack>\n#include<string>\n#include<vector>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint n,m;\nstruct range{int l,r;};\nrange a[110][110]={};\nint order[110][110]={};\n\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1;i<=n;i++)\n    {\n        for(int j=1;j<=m;j++)\n        {\n            a[i][j].l=0;\n            a[i][j].r=100;\n        }\n    }\n\n    for(int i=1;i<=n;i++)\n    {\n        int k;\n        scanf(\"%d\",&k);\n        while(k--)\n        {\n            int x,y;\n            char s;\n            int flag=0;\n            scanf(\"%d\",&x);\n            scanf(\" %c\",&s);\n            if(s=='>')\n                flag=1;\n            scanf(\" %c\",&s);\n            scanf(\"%d\",&y);\n\n            if(flag)\n                a[i][x].l=max(a[i][x].l,y);\n            else\n                a[i][x].r=min(a[i][x].r,y);\n        }\n    }\n\n    for(int i=1;i<=n;i++)\n    {\n        for(int j=1;j<=m;j++)\n        {\n            if(a[i][j].l>a[i][j].r)\n            {\n                printf(\"No\");\n                return 0;\n            }\n        }\n    }\n\n    for(int t=1;t<=m;t++)\n    {\n        for(int i=1;i<=n;i++)\n        {\n            for(int j=i+1;j<=n;j++)\n            {\n                if(a[i][t].l>a[j][t].r)\n                {\n                    if(order[i][j]==0||order[i][j]==2)\n                        order[i][j]=2;\n                    else\n                    {\n                        printf(\"No\");\n                        return 0;\n                    }\n                }\n                if(a[i][t].r<a[j][t].l)\n                {\n                    if(order[i][j]==0||order[i][j]==1)\n                        order[i][j]=1;\n                    else\n                    {\n                        printf(\"No\");\n                        return 0;\n                    }\n                }\n            }\n        }\n    }\n\n    printf(\"Yes\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define ALL(a) (a).begin(), (a).end()\n#define ll long long\n\nusing namespace std;\n\nsigned main(){\n    const string GL = \">=\";\n    int n,m; cin >> m >> n;\n    vector<vector<int> > g(m, vector<int>(n,0));\n    vector<vector<int> > l(m, vector<int>(n,100));\n    for(int i = 0; i < m; i++){\n        int k; cin >> k;\n        for(int j = 0; j < k; j++){\n            int s,t; string c;\n            cin >> s >> c >> t;\n            s--;\n            if(c == GL){\n                g[i][s] = t;\n            }\n            else{\n                l[i][s] = t;\n            }\n        }\n    }\n    vector<bool> isget(m, false);\n    vector<int> skill(n, 0);\n    for(int i = 0; i < m; i++){\n        for(int j = 0; j < m+1; j++){\n            if(j == m){\n                cout << \"No\" << endl;\n                return 0;\n            }\n            if(isget[j])continue;\n            vector<int> st = skill;\n            for(int k = 0; k < n; k++){\n                if(st[k] < g[j][k])st[k] = g[j][k];\n            }\n            bool flag = true;\n            for(int k = 0; k < m; k++){\n                if(isget[j])continue;\n                for(int p = 0; p < n; p++){\n                    if(st[p] > l[k][p]){\n                        flag = false;\n                        k = m;\n                        break;\n                    }\n                }\n            }\n            if(flag){\n                swap(skill, st);\n                break;\n            }\n        }\n    }\n    cout << \"Yes\" << endl;\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n#define INF (1<<26)\nint M,N;\nint K[100];\nint s[100][100];\nstring cond[100][100];\nint t[100][100];\n\nint A[100][100];\nint B[100];\n\nint check(int a,int b){\n  int L[100],R[100];\n  for(int i=0;i<100;i++){\n    L[i]=0;\n    R[i]=INF;\n  }\n  for(int i=0;i<K[a];i++){\n    if(cond[a][i]==\">=\"){\n      L[s[a][i]]=max(L[s[a][i]],t[a][i]);\n    }else{\n      R[s[a][i]]=min(R[s[a][i]],t[a][i]);\n    }\n  }\n\n  for(int i=0;i<100;i++)\n    if(L[i]>R[i])return 0;\n  \n  for(int i=0;i<K[b];i++){\n    if(cond[b][i]==\">=\"){\n      L[s[b][i]]=max(L[s[b][i]],t[b][i]);\n    }else{\n      R[s[b][i]]=min(R[s[b][i]],t[b][i]);\n      if(L[s[b][i]] > R[s[b][i]])return 0;\n    }\n  }\n\n\n  return 1;\n}\n\nint main(){\n  cin>>M>>N;\n  for(int i=0;i<M;i++){\n    cin>>K[i];\n    for(int j=0;j<K[i];j++){\n      cin>>s[i][j]>>cond[i][j]>>t[i][j];\n      s[i][j]--;\n    }\n  }\n  \n  for(int i=0;i<M;i++){\n    for(int j=0;j<M;j++){\n      A[i][j]=check(i,j);\n      B[i]+=check(i,j);\n    }\n  }\n\n  priority_queue<P> Q;\n  for(int i=0;i<M;i++){\n    Q.push(P(B[i],i));\n  }\n  \n  bool flg=true;\n  int cnt=0;\n  while(cnt<M){\n    P p=Q.top();Q.pop();\n    if(B[p.second]!=p.first)continue;\n    if(p.first<M-cnt)flg=false;\n    cnt++;\n    for(int i=0;i<M;i++){\n      if(A[i][p.second]==1){\n        B[i]--;\n        Q.push(P(B[i],i));\n        A[i][p.second]=0;\n      }\n    }\n  }\n\n  cout<<(flg?\"Yes\":\"No\")<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_set>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\n#include<tuple>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\nint main(){\n    ll m,n;\n    cin>>m>>n;\n    vector<vector<pll>> A(n);\n    vector<ll> com(m+1,0);\n    for(int i=1;i<=m;i++){\n        ll k;\n        cin>>k; com[i]=k;\n        for(int t=0;t<k;t++){\n            ll ty,T;\n            string s;\n            cin>>ty>>s>>T;\n            ty--;\n            if(s[0]=='<'){\n                com[i]--;\n                A[ty].push_back({T,i});\n            }\n            else{\n                if(T==0){com[i]--;}\n                else{A[ty].push_back({T,-i});}\n            }\n        }\n    }\n    for(auto &I:A){sort(I.begin(),I.end(),greater<pll>());}\n    bool j=true;\n    while(j){\n        j=false;\n        for(int i=0;i<n;i++){\n            while(!A[i].empty() && com[abs(A[i].back().S)]==0){A[i].pop_back();}\n            while(!A[i].empty() && A[i].back().S<0){\n                com[abs(A[i].back().S)]--;\n                A[i].pop_back();\n                j=true;\n            }\n        }\n    }\n    for(auto &I:com){\n        if(I!=0){cout<<\"No\"<<endl; return 0;}\n    }\n    cout<<\"Yes\"<<endl;\n    \n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int INF=1<<29;\n\nint main(){\n\tint m,n; scanf(\"%d%d\",&m,&n);\n\tint lo[100][100],up[100][100]; // lower, upper\n\trep(u,m){\n\t\trep(i,n){\n\t\t\tlo[u][i]=-INF;\n\t\t\tup[u][i]=+INF;\n\t\t}\n\t\tint k; scanf(\"%d\",&k);\n\t\twhile(k--){\n\t\t\tint skill;\n\t\t\tchar c;\n\t\t\tint val; scanf(\"%d %c%*c%d\",&skill,&c,&val); skill--;\n\t\t\tif(c=='<'){\n\t\t\t\tup[u][skill]=min(up[u][skill],val);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tlo[u][skill]=max(lo[u][skill],val);\n\t\t\t}\n\t\t}\n\t}\n\n\tbool G[100][100]={};\n\trep(u,m) rep(v,m) rep(i,n) if(up[u][i]<lo[v][i]) G[u][v]=true;\n\n\t// Warshall-Floyd\n\trep(w,m) rep(u,m) rep(v,m) G[u][v]|=G[u][w]&G[w][v];\n\n\trep(u,m) if(G[u][u]) return puts(\"No\"),0;\n\tputs(\"Yes\");\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\nstruct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nbool isDAG(vector<vector<int>>& G) {\n  int N = G.size();\n  vector<bool> vis(N);\n\n  std::function<bool(int, unordered_set<int>&)> dfs = [&](int curr, unordered_set<int>& st) {\n    for(auto&& e: G[curr]) {\n      if(st.count(e)) return false;\n      if(vis[e]) continue;\n      st.insert(e);\n      vis[e] = 1;\n      if(!dfs(e, st)) return false;\n      st.erase(e);\n    }\n    return true;\n  };\n\n  vector<int> deg(N);\n\n  rep(i, N)\n    for(auto&& e: G[i])\n      deg[e]++;\n\n  vector<int> starts;\n\n  rep(i, N)\n    if(deg[i] == 0)\n      starts.push_back(i);\n\n  if(starts.empty()) return false;\n\n  for(auto&& e: starts) {\n    vis[e] = 1;\n    unordered_set<int> st = {e};\n    if(!dfs(e, st)) return false;\n  }\n  return true;\n}\n\nint main() {\n\n  int M, N; cin >> M >> N;\n\n  // テ・ツ青?」ツつケテ」ツつュテ」ツδォテヲツッツ偲」ツ?ォテ」ツつウテ」ツδ榲」ツδウテ」ツδ嘉」ツ?ョテ・ツ個コテゥツ鳴禿」ツつ津ヲツ個?」ツ?、\n  vector<vector<pair<int, int>>> cmd_sect(N, vector<pair<int, int>>(M, {0, inf}));\n\n  rep(cmd_idx, M) {\n    int K; cin >> K;\n    rep(_, K) {\n      int skill; cin >> skill; skill--;\n      string op; cin >> op;\n      int threshold; cin >> threshold;\n      if(op == \">=\") {\n        cmd_sect[skill][cmd_idx].first = max(cmd_sect[skill][cmd_idx].first, threshold);\n      } else {\n        cmd_sect[skill][cmd_idx].second = min(cmd_sect[skill][cmd_idx].second, threshold);\n      }\n      if(cmd_sect[skill][cmd_idx].first > cmd_sect[skill][cmd_idx].second) {\n        cout << \"No\" << endl;\n        return 0;\n      }\n    }\n  }\n\n  vector<vector<int>> G(M);\n  \n  rep(i, N) {\n    rep(a, M) rep(b, M) {\n      if(a == b) continue;\n      if(cmd_sect[i][a].second < cmd_sect[i][b].first)\n        G[a].push_back(b);\n    }\n  }\n\n  rep(i, M) {\n    sort(all(G[i]));\n    G[i].erase(unique(all(G[i])), G[i].end());\n  }\n\n  cout << (isDAG(G) ? \"Yes\" : \"No\") << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\n//??????A[a,b]??¨??????B[c,d]?????¢???\nint intervalState(int a, int b, int c, int d){\n    if(a < c && b < c) return 0;            //A < B\n    else if(a > d && b > d) return 1;       //A > B\n    else if(a <= c && d <= b) return 2;     //A -> B\n    else if(c < a && b < d) return 3;       //B -> A\n    else if(a <= c && b < d) return 4;      //A <= B\n    else if(c < a && d <= b) return 5;      //A >= B\n    return -1;\n}\n\n//Give input directly to vector<pair<int, int>> in\nvector<pair<int, int>> JoinInterval(vector<pair<int,int>> in){\n    vector<pair<int, int>> v;\n    rep(i,in.size()) in[i].second *= -1;\n    sort(all(in));\n    rep(i,in.size()) in[i].second *= -1;\n\n    rep(i,in.size()){\n        if(v.empty()) v.emplace_back(in[i]);\n        else{\n            pair<int, int> &u = v.back();\n            int tmp = intervalState(in[i].first,in[i].second,u.first,u.second);\n            switch (tmp){\n                case 0:\n                case 1:\n                    v.emplace_back(in[i]);\n                    break;\n                case 2:\n                    u.first = in[i].first;\n                    u.second = in[i].second;\n                    break;\n                case 3:\n                    break;\n                case 4:\n                case 5:\n                    u.first = max(u.first, in[i].first);\n                    u.second = min(u.second, in[i].second);\n                    break;\n                case -1:\n                    assert(0);\n            }\n        }\n    }\n    sort(all(v));\n    return v;\n}\n\nint f1(pair<int, int> a, pair<int, int> b){\n    if(a.first > b.second) return 1;\n    return 0;\n}\nint f2(vector<pair<int, int>> a, vector<pair<int, int>> b){\n    return 0;\n}\nint f3(vector<pair<int, int>> a, vector<pair<int, int>> b){\n    //rep(i,105) if(a[i].second > b[i].second) return 1;\n    return 0;\n}\n\nint main(){\n    int m,n;\n    vector<pair<int,int>> v[105]; //v[i] := i??????????????????????????¶\n    rep(i,105) v[i] = vector<pair<int,int>>(105);\n    rep(i,105) rep(j,105) v[i][j] = make_pair(0,105);\n\n    cin >> m >> n;\n    rep(i,m){\n        int k;\n        cin >> k;\n        map<int,vector<pair<int, int>>> m;\n        rep(j,k){\n            int num, point;\n            string s;\n            cin >> num >> s >> point;\n            num--;\n\n            pair<int, int> p;\n            if(s[0] == '<') p = make_pair(0,point);\n            else p = make_pair(point,105);\n            m[num].emplace_back(p);\n        }\n        for(auto it : m){\n            vector<pair<int, int>> in = JoinInterval(it.second);\n            if(in.size() >= 2){\n                cout << \"No\" << endl;\n                return 0;\n            }\n            v[i][it.first] = in[0];\n        }\n    }\n\n    rep(k,m + 1) rep(i,m + 1) rep(j,m - 1) if(f1(v[j][k],v[j + 1][k])) swap(v[j],v[j + 1]);\n    rep(i,m + 1) rep(j,m - 1) if(f2(v[j],v[j + 1])) swap(v[j],v[j + 1]);\n    rep(i,m + 1) rep(j,m - 1) if(f3(v[j],v[j + 1])) swap(v[j],v[j + 1]);\n\n    int point[105] = {0};\n    rep(i,m){\n        rep(j,n){\n            int tmp = intervalState(point[j], point[j], v[i][j].first, v[i][j].second);\n            //cout << v[i][j].first << ' ' << v[i][j].second << endl;\n            //show(point[j])\n            switch (tmp) {\n                case 1:\n                    cout << \"No\" << endl;\n                    return 0;\n                case 0:\n                    point[j] = v[i][j].first;\n            }\n        }\n    }\n    cout << \"Yes\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1<<29\nusing namespace std;\n\nint n,m,K,a,b;\nstring s,ans=\"Yes\";\nint skill[101][101][2];\nvector<int> v[101];\nbool checked[101]={},visited[101]={};\n\nvoid init(){\n  for(int i=0;i<101;i++){\n    for(int j=0;j<101;j++){\n      skill[i][j][0]=-1;\n      skill[i][j][1]=inf;\n    }\n  }\n}\n\nvoid dfs(int num){\n  if(visited[num]){\n    ans=\"No\";\n    return;\n  }\n  visited[num]=true;\n  for(int i=0;i<v[num].size();i++){\n    if(!checked[v[num][i]])dfs(v[num][i]);\n  }\n  checked[num]=true;\n  visited[num]=false;\n}\n\nint main()\n{\n  init();\n  cin>>m>>n;\n  for(int i=0;i<m;i++){\n    cin>>K;\n    for(int j=0;j<K;j++){\n      cin>>a>>s>>b;\n      a--;\n      if(s[0]=='>')skill[i][a][0]=max(b,skill[i][a][0]);\n      else skill[i][a][1]=min(b,skill[i][a][1]);\n    }\n  }\n  for(int i=0;i<m;i++){\n    for(int j=0;j<m;j++){\n      for(int k=0;k<n;k++){\n\tif(skill[i][k][1]==inf || skill[j][k][0]==-1)continue;\n\tif(skill[i][k][1]<skill[j][k][0]){\n\t  v[i].push_back(j);\n\t  break;\n\t}\n      }\n    }\n  }\n  for(int i=0;i<m;i++){\n    if(!checked[i])dfs(i);\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nbool f = 1, e[100][100];\nint n;\n\nvoid dfs(int now, int par, VI visit){\n    if (visit[now]){\n        if (now == par) f = 0;\n        return;\n    }\n    visit[now] = 1;\n    REP(i,n){\n        if (e[now][i]) dfs(i, par, visit);\n    }\n}\n\nint main() {\n    int m;\n    cin >> n >> m;\n    VVI h(n, VI(m, 1000)), l(n, VI(m));\n    REP(i,n){\n        int k;\n        cin >> k;\n        while (k--){\n            int j, x;\n            string s;\n            cin >> j >> s >> x;\n            if (s == \">=\") l[i][j-1] = max(l[i][j-1], x);\n            else h[i][j-1] = min(h[i][j-1], x);\n        }\n    }\n    REP(i,n) REP(j,m) if (l[i][j] > h[i][j]) f = 0;\n    REP(i,n) REP(j,n){\n        bool g = 0;\n        REP(k,m) if (l[i][k] > h[j][k]) g = 1;\n        e[i][j] = g;\n    }\n\n    REP(i,n){\n        VI visit(n);\n        dfs(i, i, visit);\n    }\n\n    cout << (f ? \"Yes\" : \"No\") << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define Fi first\n#define Se second\n#define INF (1<<29)\n#define EPS 1e-10\n#define MOD 1000000007\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint M, N;\nvector<pii>S[128];\nvector<int>G[128];\n\nint is_edge(int src, int dist)\n{\n  map<int, int>Map;\n  rep(i, S[src].size()) Map[S[src][i].first] = i;\n\n  for(auto x:S[dist]){\n    int s = x.first, c = x.second.first, d = x.second.second;\n    if(!Map.count(s)) continue;\n    pi op = S[src][Map[s]].second;\n    if(!c && op.first && d < op.second) return 0;\n  }\n  return 1;\n}\n\nint dfs(int v, set<int>& sc)\n{\n  if(sc.size() == M) return 1;\n  for(auto next: G[v]){\n    if(sc.count(next)) continue;\n    sc.insert(next);\n    if(dfs(next, sc)) return 1;\n    sc.erase(next);\n  }\n  return 0;\n}\n\nint solve()\n{\n  rep(i, M){\n    set<int>sc; sc.insert(i);\n    if(dfs(i, sc)) return 1;\n  }\n  return 0;\n}\n\n\nint main()\n{\n  cin >> M >> N;\n  rep(i, M){\n    int K;  cin >> K;\n    rep(j, K){\n      int s, t; string cond;\n      cin >> s >> cond >> t;\n      int c = 0;\n      if(cond == \">=\") c = 1;\n      S[i].push_back(pii(s, pi(c, t)));\n    }\n  }\n\n  rep(i, M) rep(j, S[i].size()) rep(k, S[i].size()){\n    if(j==k) continue;\n    if(S[i][j].first != S[i][k].first) continue;\n    pi a = S[i][j].second, b = S[i][k].second;\n    if(!a.first && b.first && a.second < b.second){\n      cout << \"No\\n\";\n      return 0;\n    }\n  }\n\n  rep(i, M) rep(j, M){\n    if(i == j) continue;\n    if(is_edge(i, j)){\n      G[i].push_back(j);\n      //      cout << i << \" \" << j << endl;\n    }\n  }\n\n  cout << (solve()?\"Yes\":\"No\") << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\n#include <vector>\n\nusing namespace std;\n\n#define MAX 114\n\nvector<int> G[MAX];\nint col[MAX];\nbool found;\n\nvoid dfs(int v)\n{\n    col[v] = 0;\n    for(int i = 0 ; i < (int)G[v].size() ; i++){\n        int to = G[v][i];\n        if(col[to] == -1){\n            dfs(to);\n        }else if(col[to] == 0){\n            found = true;            \n            return;\n        }\n    }\n    col[v] = 1;\n}\n    \nint main()\n{\n    int M, N;\n    cin >> M >> N;\n    \n    auto canGraph = [=](){\n        int lb[MAX][MAX], ub[MAX][MAX];\n        for(int i = 0 ; i < MAX ; i++){\n            for(int j = 0 ; j < MAX ; j++){\n                lb[i][j] = -1;\n                ub[i][j] = 101;\n            }\n        }\n        int K, s, t;\n        string cond;\n        bool possible = 1;\n        for(int i = 0 ; i < M ; i++){\n            cin >> K;\n            for(int j = 0 ; j < K ; j++){\n                cin >> s >> cond >> t;\n                --s;\n                if(cond == \">=\"){\n                    lb[i][s] = max(lb[i][s], t);\n                }else{\n                    ub[i][s] = min(ub[i][s], t);\n                }\n            }\n            for(int j = 0 ; j < N ; j++){\n                if(lb[i][j] > ub[i][j]){\n                    possible = 0;\n                    break;\n                }\n            }\n        }\n\n        if(!possible) return false;\n\n        auto isConnect = [=](int from, int to){\n            for(int i = 0 ; i < N ; i++){\n                if(ub[from][i] <= lb[to][i]){\n                    return true;\n                }\n            }\n            return false;\n        };\n        \n        for(int from = 0 ; from < M ; from++){\n            for(int to = 0 ; to < M ; to++){\n                if(from == to) continue;\n                if(isConnect(from, to)){\n                    G[from].push_back(to);\n                }\n            }\n        }\n        found = false;\n        memset(col, -1, sizeof(col));\n        for(int i = 0 ; i < M ; i++){\n            if(col[i] == -1){\n                dfs(i);\n            }\n        }                                       \n        return !found;\n    };\n    \n    cout << (canGraph() ? \"Yes\" : \"No\") << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma comment(linker, \"/STACK:1000000000\")\n#include <bits/stdc++.h>\n#define LL long long\n#define INF 0x3f3f3f3f\n#define IN freopen(\"in.txt\",\"r\",stdin);\n#define OUT freopen(\"out.txt\", \"w\", stdout);\nusing namespace std;\n#define MAXN 105\n#define MAXM 25005\n\nbool dayu[MAXN][MAXN], vis[MAXN];\nint in[MAXN];\nqueue<int> Q;\nint gao[MAXN][MAXN], di[MAXN][MAXN];\nint main()\n{\n        //IN;\n        int m, n, k, x, y;\n        char s[5];\n        scanf(\"%d%d\", &m, &n);\n        memset(di, 0, sizeof(di));\n        memset(gao, INF, sizeof(gao));\n        for(int i = 1; i <= m; i++){\n            scanf(\"%d\", &k);\n            for(int j = 1; j <= k; j++){\n                scanf(\"%d%s%d\", &x, &s, &y);\n                if(s[0] == '<'){\n                    gao[i][x] = min(gao[i][x], y);\n                }\n                else{\n                    di[i][x] = max(di[i][x], y);\n                }\n            }\n        }\n        for(int i = 1; i <= m; i++){\n            for(int j = 1; j <= n; j++){\n                if(di[i][j] > gao[i][j]){\n                    printf(\"No\\n\");\n                    return 0;\n                }\n            }\n        }\n        memset(dayu, 0, sizeof(dayu));\n        memset(in, 0, sizeof(in));\n        for(int i = 1; i <= m; i++){\n            for(int j = 1; j <= m; j++){\n                if(i == j) continue;\n                bool flag = false;\n                for(int k = 1; k <= n; k++){\n                    if(di[i][k] > gao[j][k]){\n                        flag = true;\n                        break;\n                    }\n                }\n                if(!flag){\n                    dayu[i][j] = true;\n                    in[j]++;\n                }\n            }\n        }\n        bool noans = false;\n        for(int i = 1; i <= m; i++){\n            for(int j = 1; j <= m; j++){\n                    if(i == j) continue;\n                if(!dayu[i][j] && !dayu[j][i]){\n                    printf(\"No\\n\");\n                    return 0;\n                }\n            }\n        }\n        memset(vis, 0, sizeof(vis));\n        while(!Q.empty()){\n            Q.pop();\n        }\n        for(int i = 1; i <= m; i++){\n            bool flag = false;\n            for(int j = 1; j <= m; j++){\n                if(dayu[i][j] || i == j) continue;\n                flag = true;\n                break;\n            }\n            if(!flag){\n                Q.push(i);\n                vis[i] = true;\n            }\n        }\n        int ans = 0;\n\n        while(!Q.empty()){\n            int s = Q.front();\n            vis[s] = true;\n            ans++;\n            Q.pop();\n            for(int i = 1; i <= m; i++){\n                if(dayu[s][i]){\n                    in[i]--;\n                    if(in[i] == 0 && !vis[i]){\n                        Q.push(i);\n                    }\n                }\n            }\n        }\n        if(ans == m){\n            printf(\"Yes\\n\");\n        }\n        else{\n            printf(\"No\\n\");\n        }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define l first\n#define r second\n#define INF (1e9)\nusing namespace std;\ntypedef pair <int,int> P;\nint m,n,used[101],memo[101][101];\nP cmd[101][101];\n\nint check(int a,int b){\n  if(used[b]) return 1;\n  if(memo[a][b]!=-1) return memo[a][b];\n  for(int i=0;i<m;i++){\n    if(cmd[a][i].l>cmd[b][i].r)return memo[a][b]=0;\n  }\n  return memo[a][b]=1;\n}\n\nint solve(){\n  memset(memo,-1,sizeof(memo));\n  int flg=1;\n  while(flg){\n    flg=0;\n    for(int i=0,j;i<m&&!flg;i++){\n      if(used[i]) continue;\n      j=0;\n      for(j=0;j<m;j++)if(!check(i,j))break;\n      if(j==m) flg=used[i]=1;\n    }\n  }\n  for(int i=0;i<m;i++) if(!used[i]) return 0;\n  return 1;\n}\n\nint main(){\n  int ans=1;\n  for(int i=0;i<101;i++)\n    for(int j=0;j<101;j++)cmd[i][j]=P(-INF,INF);\n\n  cin>>m>>n;\n  for(int i=0;i<m;i++){\n    int k;\n    cin>>k;\n    while(k--){\n      string cond;\n      int s,t;\n      cin>>s>>cond>>t;\n      s--;\n      if(cond==\"<=\")cmd[i][s].r=min(cmd[i][s].r,t);\n      if(cond==\">=\")cmd[i][s].l=max(cmd[i][s].l,t);\n      if(cmd[i][s].l>cmd[i][s].r)ans=0;\n    }\n  }\n\n  cout << (ans*solve()? \"Yes\":\"No\")<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <set>\n#include <cstdio>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <ctime>\n#include <algorithm>\n#include <tuple>\n#include <algorithm>\n#include <limits>\n#include <map>\n#include <cstring>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\nconst int MN = 110;\nint V;\nvector<int> G[MN];\nvector<int> rG[MN];\nvector<int> vs;\nbool used[MN];\nint cmp[MN];\n\nvoid add_edge(int from, int to) {\n    G[from].push_back(to);\n    rG[to].push_back(from);\n}\n\nvoid dfs(int v) {\n    used[v] = true;\n    for(int i=0;i<G[v].size();i++) {\n        if(!used[G[v][i]]) dfs(G[v][i]);\n    }\n    vs.push_back(v);\n}\n\nvoid rdfs(int v, int k) {\n    used[v] = true;\n    cmp[v] = k;\n    for(int i=0;i<rG[v].size();i++) {\n        if (!used[rG[v][i]]) rdfs(rG[v][i], k);\n    }\n}\n\nint scc() {\n    memset(used, 0, sizeof(used));\n    vs.clear();\n    for(int v=0;v<V;v++) {\n        if (!used[v]) dfs(v);\n    }\n    memset(used, 0, sizeof(used));\n    int k = 0;\n    for(int i=vs.size() - 1; i >= 0; i--) {\n        if (!used[vs[i]]) rdfs(vs[i], k++);\n    }\n    return k;\n}\nint m;\nint g[MN][MN];\nbool solve() {\n    for (int i = 0; i < m; i++) {\n        if (g[i][i]) return false;\n    }\n    V = m;\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < m; j++) {\n            if (g[i][j]) add_edge(i, j);\n        }\n    }\n    scc();\n    int c[MN] = {};\n    for (int i = 0; i < m; i++) {\n        c[cmp[i]]++;\n    }\n    for (int i = 0; i < MN; i++) {\n        if (c[i] > 1) return false;\n    }\n    return true;\n}\n\nint main() {\n    int n;\n    int s[MN][MN][2];\n    for (int i = 0; i < MN; i++) {\n        for (int j = 0; j < MN; j++) {\n            s[i][j][0] = 0;\n            s[i][j][1] = 1000;\n        }\n    }\n    cin >> m >> n;\n    for (int i = 0; i < m; i++) {\n        int k;\n        cin >> k;\n        for (int j = 0; j < k; j++) {\n            int a, b;\n            char c;\n            scanf(\"%d %c= %d\", &a, &c, &b);\n            s[i][a][(c == '<') ? 1 : 0] = b;\n        }\n    }\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < m; j++) {\n            bool f = false;\n            for (int k = 0; k < MN; k++) {\n                if (s[i][k][0] > s[j][k][1]) {\n                    f = true;\n                }\n            }\n            g[i][j] = f ? 1 : 0;\n        }\n    }\n    if (solve()) {\n        printf(\"Yes\\n\");\n    } else {\n        printf(\"No\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define N 101\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\nint m,n,k1,s,t,flag;\nvector<int> ei[N],eo[N];\nstring cond;\nvector<P1> v[N];\nmap<int,P> pam[N];\n\nint main(){\n  cin>>m>>n;\n  for(int i=0;i<m;i++){\n    cin>>k1;\n    for(int j=0;j<k1;j++){\n      cin>>s>>cond>>t;\n      if(cond[0]=='>')v[i].push_back(P1(s,P(t,INF)));\n      else v[i].push_back(P1(s,P(0,t)));\n    }\n    sort(v[i].begin(),v[i].end());\n  }\n  for(int i=0;i<m;i++){\n    for(int j=0;j<v[i].size()-1;j++){\n      if(v[i][j].first!=v[i][j+1].first)continue;\n      int min1=v[i][j].second.first;\n      int max1=v[i][j].second.second;\n      int min2=v[i][j+1].second.first;\n      int max2=v[i][j+1].second.second;\n      if(max1<min2)flag=1;\n      else{\n\tv[i][j]=P1(v[i][j+1].first,P(max(min1,min2),min(max1,max2)));\n\tv[i].erase(v[i].begin()+j+1);\n\tj--;\n      }\n    }\n  }\n  for(int i=0;i<m;i++)\n    for(int j=0;j<v[i].size();j++){\n      int t1=v[i][j].first;\n      int t2=v[i][j].second.first;\n      int t3=v[i][j].second.second;\n      pam[i].insert(make_pair(t1,P(t2,t3)));\n    }\n  for(int i=1;i<=n;i++){\n    for(int j=0;j<m;j++){\n      if(pam[j].find(i)==pam[j].end())continue;\n      map<int,P>::iterator ite1=pam[j].find(i);\n      for(int k=j+1;k<m;k++){\n\tif(pam[k].find(i)==pam[k].end())continue;\n\tif(j==k)continue;\n\tmap<int,P>::iterator ite2=pam[k].find(i);\n\tint min1=(*ite1).second.first;\n\tint max1=(*ite1).second.second;\n\tint min2=(*ite2).second.first;\n\tint max2=(*ite2).second.second;\n\tif(max1<min2){\n\t  eo[j].push_back(k);\n\t  ei[k].push_back(j);\n\t}\n\tif(max2<min1){\n\t  eo[k].push_back(j);\n\t  ei[j].push_back(k);\n\t}\n      }\n    }\n  }\n  queue<int> S,L;\n  for(int i=0;i<m;i++)\n    if(!ei[i].size())S.push(i);\n  while(!S.empty()){\n    int t=S.front(); S.pop();\n    L.push(t);\n    for(int i=0;i<eo[t].size();i++){\n      int out=eo[t][i];\n      for(int k=0;k<ei[out].size();k++)\n\tif(ei[out][k]==t)ei[out].erase(ei[out].begin()+k);\n      eo[t].erase(eo[t].begin()+i);\n      i--;\n      if(!ei[out].size())S.push(out);\n    }\n  }\n  for(int i=0;i<m;i++)\n    if(ei[i].size()||eo[i].size())flag=1;\n  if(flag)cout<<\"No\"<<endl;\n  else cout<<\"Yes\"<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int INF = 1 << 30;\nbool check()\n{\n  int M, N;\n  int low[101][101] = {{}}, hig[101][101];\n  bool graph[101][101] = {{}};\n  fill_n(*hig, 101 * 101, INF);\n  \n  cin >> M >> N;\n  for(int i = 0; i < M; i++) {\n    int K;\n    cin >> K;\n    while(K--) {\n      int s, t;\n      string cond;\n      cin >> s >> cond >> t;\n      --s;\n      if(cond == \">=\") low[i][s] = max(low[i][s], t);\n      else             hig[i][s] = min(hig[i][s], t);\n      if(low[i][s] > hig[i][s]) return(false);\n    }\n  }\n  for(int i = 0; i < M; i++) {\n    for(int j = 0; j < M; j++) {\n      if(i == j) continue;\n      for(int k = 0; k < N; k++) graph[i][j] |= low[i][k] > hig[j][k];\n    }\n  }\n  for(int k = 0; k < M; k++) {\n    for(int i = 0; i < M; i++) {\n      for(int j = 0; j < M; j++) {\n        graph[i][j] |= graph[i][k] & graph[k][j];\n      }\n      if(graph[i][i]) return(false);\n    }\n  }\n  return(true);              \n}\n\nint main()\n{\n  cout << (check() ? \"Yes\" : \"No\") << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <stack>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <tuple>\n#include <assert.h>\n#include <deque>\n#include <bitset>\n#include <iomanip>\n#include <limits>\n#include <chrono>\n#include <random>\n#include <array>\n#include <unordered_map>\n#include <functional>\n#include <complex>\n#include <numeric>\n#include <cctype>\n\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n//constexpr long long MAX = 5100000;\nconstexpr long long INF = 1LL << 60;\nconstexpr int inf = 1000000007;\nconstexpr long long mod = 1000000007LL;\n//constexpr long long mod = 998244353LL;\nconst long double PI = acos((long double)(-1));\n\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n\n\nvector<int> topological(vector<vector<int>>& g) {\n\tvector<int> topo;\n\tint n = g.size();\n\tvector<int> deg(n);\n\tfor (int i = 0; i < n; i++) for (auto next : g[i]) deg[next]++;\n\tqueue<int> q;\n\tfor (int i = 0; i < n; i++) if (deg[i] == 0) q.push(i), topo.push_back(i);\n\twhile (!q.empty()) {\n\t\tint cur = q.front();\n\t\tq.pop();\n\t\tfor (auto next : g[cur]) {\n\t\t\tdeg[next]--;\n\t\t\tif (deg[next] == 0) {\n\t\t\t\tq.emplace(next);\n\t\t\t\ttopo.push_back(next);\n\t\t\t}\n\t\t}\n\t}\n\treturn topo;\n}\nint main()\n{\n\t\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\t\n\n\tint m, n; cin >> m >> n;\n\tvector<vector<int>> g(m);\n\tvector<vector<int>> l(m, vector<int>(n)), r(m, vector<int>(n, inf));\n\tfor (int i = 0; i < m; i++) {\n\t\tint k; cin >> k;\n\t\tfor (int j = 0; j < k; j++) {\n\t\t\tint s, t;\n\t\t\tstring str;\n\t\t\tcin >> s >> str >> t;\n\t\t\ts--;\n\t\t\tif (str == \">=\") {\n\t\t\t\tchmax(l[i][s], t);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tchmin(r[i][s], t);\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (l[i][j] > r[i][j]) {\n\t\t\t\tcout << \"No\" << \"\\n\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < m; i++) {\n\t\tfor (int j = i + 1; j < m; j++) {\n\t\t\tbool lr = false;\n\t\t\tbool rl = false;\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tif (r[i][k] < l[j][k]) {\n\t\t\t\t\tlr = true;\n\t\t\t\t}\n\t\t\t\tif (r[j][k] < l[i][k]) {\n\t\t\t\t\trl = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (lr and rl) {\n\t\t\t\tcout << \"No\" << \"\\n\";\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (lr) g[i].emplace_back(j);\n\t\t\tif (rl) g[j].emplace_back(i);\n\t\t}\n\t}\n\tauto t = topological(g);\n\tif (t.size() == m) cout << \"Yes\" << \"\\n\";\n\telse cout << \"No\" << \"\\n\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <iostream>\n#include <set>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define PRIME1 99999883\n#define PRIME2 99999893\n#define EPS 0.00000001\nusing namespace std;\n\nenum Type{\n\tNone,\n\tGreaterEqual,\n\tSmallerEqual,\n};\n\nstruct Data{\n\tType type;\n\tint number;\n};\n\nstruct Info{\n\tData data[101];\n\tbool used;\n};\n\nint main(){\n\n\tint num_of_SC,num_of_skill,K;\n\tscanf(\"%d %d\",&num_of_SC,&num_of_skill);\n\tInfo info[num_of_SC];\n\tfor(int i = 0; i < num_of_SC; i++){\n\t\tinfo[i].used = false;\n\t\tfor(int a = 1; a <= num_of_skill;a++)info[i].data[a].type = None;\n\t}\n\n\tint skill_code,skill_level;\n\n\tchar eq[4];\n\tbool FLG = true;\n\n\tfor(int i = 0; i < num_of_SC; i++){\n\t\tscanf(\"%d\",&K);\n\t\tfor(int a = 0; a < K; a++){\n\t\t\tscanf(\"%d %s %d\",&skill_code,eq,&skill_level);\n\t\t\tif(info[i].data[skill_code].type == None){\n\t\t\t\tinfo[i].data[skill_code].number = skill_level;\n\t\t\t\tif(eq[0] == '>'){\n\t\t\t\t\tinfo[i].data[skill_code].type = GreaterEqual;\n\t\t\t\t}else{\n\t\t\t\t\tinfo[i].data[skill_code].type = SmallerEqual;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(info[i].data[skill_code].type == GreaterEqual){\n\t\t\t\t\tif(eq[0] == '>'){\n\t\t\t\t\t\t//Do nothing\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(info[i].data[skill_code].number > skill_level){\n\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(eq[0] == '>'){\n\t\t\t\t\t\tif(info[i].data[skill_code].number < skill_level){\n\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif(!FLG){\n\t\tprintf(\"No\\n\");\n\t\treturn 0;\n\t}\n\n\tint count = 0;\n\tstack<int> S;\n\n\twhile(true){\n\n\t\tfor(int i = 0; i < num_of_SC; i++){\n\t\t\tif(info[i].used == true)continue;\n\n\t\t\tFLG = true;\n\t\t\tfor(int a = 0; a < num_of_SC; a++){\n\t\t\t\tif(i == a || info[a].used == true)continue;\n\n\t\t\t\tfor(int b = 1; b <= num_of_skill;b++){\n\n\t\t\t\t\tswitch(info[a].data[b].type){\n\t\t\t\t\tcase None:\n\t\t\t\t\t\t//Do nothing\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase GreaterEqual:\n\t\t\t\t\t\t//Do nothing\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase SmallerEqual:\n\t\t\t\t\t\tif(info[i].data[b].type == GreaterEqual && info[i].data[b].number > info[a].data[b].number){\n\t\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!FLG)break;\n\t\t\t}\n\t\t\tif(FLG){\n\t\t\t\tS.push(i);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif(S.empty())break;\n\n\t\twhile(!S.empty()){\n\t\t\tinfo[S.top()].used = true;\n\t\t\tcount++;\n\t\t\tS.pop();\n\t\t}\n\t}\n\n\tif(count == num_of_SC){\n\t\tprintf(\"Yes\\n\");\n\t}else{\n\t\tprintf(\"No\\n\");\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define inf 1<<29\nusing namespace std;\n\nint n,m,K,a,b;\nstring s,ans=\"Yes\";\nint skill[101][101][2];\nvector<int> v[101];\nbool checked[101]={},visited[101]={};\n\nvoid init(){\n  for(int i=0;i<101;i++){\n    for(int j=0;j<101;j++){\n      skill[i][j][0]=inf;\n      skill[i][j][1]=inf;\n    }\n  }\n}\n\nvoid dfs(int num){\n  if(visited[num]){\n    ans=\"No\";\n    return;\n  }\n  visited[num]=true;\n  for(int i=0;i<v[num].size();i++){\n    if(!checked[v[num][i]])dfs(v[num][i]);\n  }\n  checked[num]=true;\n  visited[num]=false;\n}\n\nint main()\n{\n  init();\n  cin>>m>>n;\n  for(int i=0;i<m;i++){\n    cin>>K;\n    for(int j=0;j<K;j++){\n      cin>>a>>s>>b;\n      a--;\n      if(s[0]=='>')skill[i][a][0]=b;\n      else skill[i][a][1]=b;\n    }\n  }\n  for(int i=0;i<m;i++){\n    for(int j=0;j<m;j++){\n      bool flag=false;\n      for(int k=0;k<n;k++){\n\tif(skill[i][k][1]==inf)continue;\n\tif(skill[j][k][1]!=inf && skill[j][k][0]<=skill[i][k][1])flag=true;\n\tif(skill[j][k][0]!=inf && skill[j][k][1]<=skill[i][k][1])flag=true;\n      }\n      if(flag)v[i].push_back(j);\n    }\n  }\n  for(int i=0;i<m;i++){\n    if(!checked[i])dfs(i);\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<iomanip>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<queue>\n\nusing namespace std;\n\n#define int long long\n#define rep(i,n) for(int i = 0; i < (n); i++)\n#define INF ((long long)1e18)\n#define MOD ((int)1e9+7)\n#define endl \"\\n\"\n\n#define yn(f) ((f)?\"Yes\":\"No\")\n#define YN(f) ((f)?\"YES\":\"NO\")\n\n#define MAX 110\n\nint M, N;\nint K[MAX], sp[MAX], point[MAX], con;\nbool can[MAX];\nvector<vector<int>> llim(MAX,vector<int>(MAX,0));\n// vector<pair<int,int>> ulim[MAX];\npriority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> ulim[MAX];\n\nbool check(int n){\n\tif(can[n]) return false;\n\t\n\tfor(int i = 1; i <= N; i++){\n\t\tif(llim[n][i] > sp[i]) return false;\n\t}\n\t\n\tcan[n] = true;\n\tcon++;\n\t\n\treturn true;\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout<<fixed<<setprecision(10);\n\t\n\tint s, t;\n\tstring cond;\n\t\n\tcin>>M>>N;\n\t\n\tfor(int i = 1; i <= M; i++){\n\t\tcin>>K[i];\n\t\tfor(int j = 1; j <= K[i]; j++){\n\t\t\tcin>>s>>cond>>t;\n\t\t\tif(cond == \">=\"){\n\t\t\t\tllim[i][s] = max(llim[i][s], t);\n\t\t\t} else if(cond == \"<=\"){\n\t\t\t\tulim[s].push(make_pair(t,i));\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t}\n\tfor(int i = 1; i <= N; i++){\n\t\tulim[i].push(make_pair(INF,0));\n\t}\n\t\n\twhile(true){\n\t\tbool flag = false;\n\t\t\n\t\tfor(int i = 1; i <= N; i++){\n\t\t\twhile(!ulim[i].empty()){\n\t\t\t\tpair<int,int> p = ulim[i].top();\n\t\t\t\tif(can[p.second] == false){\n\t\t\t\t\tsp[i] = p.first;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tulim[i].pop();\n\t\t\t}\n\t\t\t// cout<<i<<\" \"<<sp[i]<<endl;\n\t\t}\n\t\t\n\t\tfor(int i = 1; i <= M; i++){\n\t\t\tif(check(i)) flag = true;\n\t\t}\n\t\tif(!flag){\n\t\t\tcout<<\"NO\"<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\tif(con == M)break;\n\t}\n\t\n\tcout<<\"YES\"<<endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\n#include <vector>\n\nusing namespace std;\n\n#define MAX 114\n\nvector<int> G[MAX];\nint visited[MAX];\nbool found;\n\nvoid dfs(int v)\n{\n    visited[v] = 0;\n    for(int i = 0 ; i < (int)G[v].size() ; i++){\n\tint to = G[v][i];\n\tif(visited[to] == -1){\n\t    dfs(to);\n\t}else if(visited[to] == 0){\n            found = true;            \n\t    return;\n\t}\n    }\n    visited[v] = 1;\n}\n    \nint main()\n{\n    int M, N;\n    cin >> M >> N;\n    \n    auto canGraph = [=](){\n        int lb[MAX][MAX], ub[MAX][MAX];\n        for(int i = 0 ; i < MAX ; i++){\n            for(int j = 0 ; j < MAX ; j++){\n                lb[i][j] = -1;\n                ub[i][j] = 101;\n            }\n        }\n        int K, s, t;\n        string cond;\n        bool possible = 1;\n        for(int i = 0 ; i < M ; i++){\n            cin >> K;\n            for(int j = 0 ; j < K ; j++){\n                cin >> s >> cond >> t;\n                --s;\n                if(cond == \">=\"){\n                    lb[i][s] = max(lb[i][s], t);\n                }else{\n                    ub[i][s] = min(ub[i][s], t);\n                }\n            }\n            for(int j = 0 ; j < N ; j++){\n                if(lb[i][j] > ub[i][j]){\n                    possible = 0;\n                    break;\n                }\n            }\n        }\n\n        if(!possible) return false;\n\n        auto isConnect = [=](int from, int to){\n            for(int i = 0 ; i < N ; i++){\n                if(ub[from][i] < lb[to][i]){\n                    return true;\n                }\n            }\n            return false;\n        };\n        \n        for(int from = 0 ; from < M ; from++){\n            for(int to = 0 ; to < M ; to++){\n                if(from == to) continue;\n                if(isConnect(from, to)){\n                    G[from].push_back(to);\n                }\n            }\n        }\n        found = false;\n        memset(visited, -1, sizeof(visited));\n        for(int i = 0 ; i < M ; i++){\n            if(visited[i] == -1){\n                dfs(i);\n            }\n        }                                       \n        return !found;\n    };\n    \n    cout << (canGraph() ? \"Yes\" : \"No\") << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(int)(a); (i)<(int)(b); ++(i))\n#define rFor(i, a, b) for(int (i)=(int)(a)-1; (i)>=(int)(b); --(i))\n#define rep(i, n) For((i), 0, (n))\n#define rrep(i, n) rFor((i), (n), 0)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> pii;\ntypedef pair<lint, lint> pll;\ntemplate<class T> bool chmax(T &a, const T &b){if(a<b){a=b; return true;} return false;}\ntemplate<class T> bool chmin(T &a, const T &b){if(a>b){a=b; return true;} return false;}\ntemplate<class T> T div_floor(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>=0 ? a/b : (a+1)/b-1;\n}\ntemplate<class T> T div_ceil(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>0 ? (a-1)/b+1 : a/b;\n}\n\nconstexpr lint mod = 1000000007;\nconstexpr lint INF = mod * mod;\nconstexpr int MAX = 200010;\n \ntemplate<typename T> struct edge{\n    int from, to; T cost;\n    edge(int f, int t, T c): from(f), to(t), cost(c){}\n};\n \ntemplate<typename T> struct Graph{\n    vector<vector<edge<T>>> G;\n    int n;\n \n    Graph(int n_): n(n_){\n        G.resize(n);\n    }\n \n    void add_edge(int f, int t, T c){\n        G[f].emplace_back(f, t, c);\n    }\n};\n\ntemplate<typename T> \npair<bool, vector<int>> topological_sort(Graph<T> &gr){\n    vector<int> ret(gr.n, -1), in(gr.n, 0);\n    rep(i, gr.n)for(edge<T> &e: gr.G[i]) ++in[e.to];\n    int cur = 0;\n    stack<int> st;\n    rep(i, gr.n)if(!in[i]) st.push(i);\n    if(st.empty()) return make_pair(false, ret);\n    while(!st.empty()){\n        int v = st.top(); st.pop();\n        ret[cur++] = v;\n        for(edge<T> &e: gr.G[v]){\n            if(!in[e.to]) return make_pair(false, ret);\n            --in[e.to];\n            if(!in[e.to]) st.push(e.to);\n        }\n    }\n    return make_pair(cur == gr.n, ret);\n}\n\ntemplate<typename T> \nbool has_cycle(Graph<T> &gr){\n    return !topological_sort(gr).fi;\n}\n\nint main(){\n    int m, n;\n    scanf(\"%d%d\", &m, &n);\n    int lb[m][n], ub[m][n];\n    rep(i, m)rep(j, n) lb[i][j] = -1, ub[i][j] = mod;\n    rep(i, m){\n        int K;\n        scanf(\"%d\", &K);\n        rep(_, K){\n            int s; string cond; int t;\n            cin >> s >> cond >> t;\n            --s;\n            if(cond == \">=\") chmax(lb[i][s], t);\n            else chmin(ub[i][s], t);\n            if(lb[i][s] > ub[i][s]){\n                puts(\"No\");\n                return 0;\n            }\n        }\n    }\n\n    Graph<int> gr(m);\n    rep(i, m)For(j, i+1, m){\n        int dir = 0; // 1: i -> j, 0: no edge, -1: i <- j\n        rep(k, n){\n            if(ub[i][k] < lb[j][k]){\n                if(dir == -1){\n                    puts(\"No\");\n                    return 0;\n                }\n                dir = 1;\n            }\n            else if(ub[j][k] < lb[i][k]){\n                if(dir == 1){\n                    puts(\"No\");\n                    return 0;\n                }\n                dir = -1;\n            }\n        }\n        if(dir == 1) gr.add_edge(i, j, 1);\n        else if(dir == -1) gr.add_edge(j, i, 1);\n    }\n\n    puts(!has_cycle(gr) ? \"Yes\" : \"No\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<string>\n#include<iomanip>\n#pragma comment(linker, \"/STACK:1024000000,1024000000\")\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<list>\n\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\n#define rep(i,k,n) for(int i=(k);i<=(n);i++)\n#define red(i,k,n) for(int i=(k);i>=(n);i--)\n#define sqr(x) ((x)*(x))\n#define clr(x,y) memset((x),(y),sizeof(x))\n#define mod 1000000007\n#define MAX(a,b) ((a)>(b)?(a):(b))\n#define MIN(a,b) ((a)>(b)?(b):(a))\n//const int maxn = ;\n\nint n,m;\nint skl[110][110];\nint skr[110][110];\nint in[110];\nbool vis[110];\nvector<int> e[110];\nqueue<int> q;\n\nchar s[10];\n\nbool solve()\n{\n    int kk,num,p,v;\n    rep(i,1,n)rep(j,1,m)skl[i][j]=0,skr[i][j]=100;\n    rep(i,1,n)\n    {\n        scanf(\"%d\",&kk);\n        rep(j,1,kk)\n        {\n            scanf(\"%d%s%d\",&num,s,&p);\n            if(s[0]=='>')\n            {\n                if(skl[i][num]<p)\n                {\n                    if(skr[i][num]<p)\n                    {\n                        return 0;\n                    }\n                    else skl[i][num]=p;\n                }\n            }\n            else if(s[0]=='<')\n            {\n                if(skr[i][num]>p)\n                {\n                    if(skl[i][num]>p)\n                    {\n                        return 0;\n                    }\n                    else skr[i][num]=p;\n                }\n            }\n\n        }\n        e[i].clear();\n    }\n\n    clr(in,0);\n    for(int i=1;i<=n;i++)\n    {\n        for(int j=1;j<=n;j++)\n        {\n            if(i==j)continue;\n            bool flag=false;\n            rep(k,1,m)\n            {\n                if(skr[i][k]<skl[j][k]){flag=true;break;}\n            }\n            if(flag)\n            {\n                e[i].push_back(j);\n                in[j]++;\n            }\n        }\n    }\n\n    clr(vis,0);\n    int cnt=0;\n    rep(i,1,n)if(in[i]==0)\n    {\n        q.push(i);\n        vis[i]=1;\n        cnt++;\n    }\n    while(!q.empty())\n    {\n        int p=q.front();q.pop();\n        if(!e[p].empty())rep(i,0,e[p].size()-1)\n        {\n            v=e[p][i];\n            if(vis[v])continue;\n            if(--in[v]==0)\n            {\n                q.push(v);\n                vis[v]=1;\n                cnt++;\n            }\n        }\n    }\n\n    return cnt==n;\n}\n\nint main()\n{\n//#define LOCAL\n#ifdef LOCAL\n    freopen(\"e:\\\\read.txt\",\"r\",stdin);\n    //freopen(\"e:\\\\write.txt\",\"w\",stdout);\n#endif\n    while(cin>>n>>m)\n    {\n        if(solve())puts(\"Yes\");\n        else puts(\"No\");\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n\nusing namespace std;\n\nbool isOK2after1(vector<int> &com1Inf, vector<int> &com2Sup){\n    for(int i=0; i < com1Inf.size() ; i++){\n        if( com1Inf[i] >  com2Sup[i]) return false;\n    }\n    return true;\n}\nvoid condition(vector<int> &comInf, vector<int> &com2Inf){\n    for(int i=0 ; i< comInf.size() ; i++){\n        comInf[i] = max(comInf[i],com2Inf[i]);\n    }\n}\n\nint main() {\n    int M,N;\n    cin >> M >> N;\n    int K, s, t;\n    string cnd;\n    vector<vector<int>> comInf(M,vector<int>(N,0));\n    vector<vector<int>> comSup(M,vector<int>(N,100));\n    vector<int> sp(N,0);\n\n    for(int i=0; i<M ; i++){\n        cin >> K;\n        for(int j=0; j<K ; j++){\n            cin >> s >> cnd >> t;\n            s--;\n            if(cnd == \">=\"){\n                comInf[i][s] = max(comInf[i][s],t);\n            }else{\n                comSup[i][s] = min(comSup[i][s],t);\n            }\n        }\n    }\n    for(int i=0 ; i< M ; i++){\n        vector<int> ansInf(N,0);\n        if(!isOK2after1(comInf[i],comSup[i])){\n            cout << \"No\" << endl;\n            return 0;\n        }\n        vector<bool> isOK(N,false);\n        for(int j=0; j<i ; j++){\n            if(isOK2after1(comInf[j], comSup[i])) {\n                isOK[j] = true;\n                condition(ansInf, comInf[j]);\n            }else{\n                if(!isOK2after1(comInf[i],comSup[j])){\n                    cout << \"No\" << endl;\n                    return 0;\n                }\n            }\n        }\n        condition(ansInf,comInf[i]);\n        for(int j=0; j<i ; j++){\n            if(!isOK[j]){\n                if(!isOK2after1(ansInf,comSup[j])){\n                    cout << \"No\" << endl;\n                    return 0;\n                }\n            }\n        }\n    }\n    cout << \"Yes\" << endl; \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\nint M, N, ub[111][111], lb[111][111], skill[111];\nbool learned[111];\n\nbool all_learned() {\n\tfor_(i,0,M) if (!learned[i]) return false;\n\treturn true;\n}\n\nint main() {\n\tcin >> M >> N;\n\t\n\tfor_(i,0,M) for_(j,0,N) {\n\t\tub[i][j] = 100;\n\t\tlb[i][j] = 0;\n\t}\n\t\n\tfor_(i,0,M) {\n\t\tint K;\n\t\tcin >> K;\n\t\t\n\t\tfor_(j,0,K) {\n\t\t\tint s, t;\n\t\t\tstring cnd;\n\t\t\tcin >> s >> cnd >> t;\n\t\t\t--s;\n\t\t\t\n\t\t\tif (cnd == \">=\") lb[i][s] = max(lb[i][s], t);\n\t\t\telse ub[i][s] = min(ub[i][s], t);\n\t\t}\n\t\t\n\t\tfor_(j,0,N) if (ub[i][j] < lb[i][j]) {\n\t\t\tcout << \"No\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tmemset(skill, 0, sizeof(skill));\n\tmemset(learned, 0, sizeof(learned));\n\t\n\twhile (!all_learned()) {\n\t\tint tar = -1;\n\t\t\n\t\tfor_(i,0,N) {\n\t\t\tbool isok = true;\n\t\t\t\n\t\t\tfor_(j,0,M) {\n\t\t\t\tif (learned[j]) continue;\n\t\t\t\tisok &= (skill[i] + 1 <= ub[j][i]);\n\t\t\t}\n\t\t\t\n\t\t\tif (isok) {\n\t\t\t\ttar = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (tar == -1) {\n\t\t\tcout << \"No\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\t++skill[tar];\n\t\t\n\t\tfor_(i,0,M) {\n\t\t\tbool learn = true;\n\t\t\tfor_(j,0,N) learn &= (lb[i][j] <= skill[j] && skill[j] <= ub[i][j]);\n\t\t\tif (learn) learned[i] = true;\n\t\t}\n\t}\n\t\n\tcout << \"Yes\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define N 101\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\nint m,n,k1,s,t,flag;\nvector<int> ei[N],eo[N];\nstring cond;\nvector<P1> v[N];\nmap<int,P> pam[N];\n\nint main(){\n  cin>>m>>n;\n  for(int i=0;i<m;i++){\n    cin>>k1;\n    for(int j=0;j<k1;j++){\n      cin>>s>>cond>>t;\n      if(cond[0]=='>')v[i].push_back(P1(s,P(t,INF)));\n      else v[i].push_back(P1(s,P(0,t)));\n    }\n    sort(v[i].begin(),v[i].end());\n  }\n  for(int i=0;i<m;i++){\n    for(int j=0;j<v[i].size()-1;j++){\n      if(v[i][j].first!=v[i][j+1].first)continue;\n      int min1=v[i][j].second.first;\n      int max1=v[i][j].second.second;\n      int min2=v[i][j+1].second.first;\n      int max2=v[i][j+1].second.second;\n      if(max1<min2)flag=1;\n      else{\n\tv[i][j]=P1(v[i][j+1].first,P(min1,max2));\n\tv[i].erase(v[i].begin()+j+1);\n\tj--;\n      }\n    }\n  }\n  for(int i=0;i<m;i++)\n    for(int j=0;j<v[i].size();j++){\n      int t1=v[i][j].first;\n      int t2=v[i][j].second.first;\n      int t3=v[i][j].second.second;\n      pam[i].insert(make_pair(t1,P(t2,t3)));\n    }\n  for(int i=1;i<=n;i++){\n    for(int j=0;j<m;j++){\n      if(pam[j].find(i)==pam[j].end())continue;\n      map<int,P>::iterator ite1=pam[j].find(i);\n      for(int k=j+1;k<m;k++){\n\tif(pam[k].find(i)==pam[k].end())continue;\n\tif(j==k)continue;\n\tmap<int,P>::iterator ite2=pam[k].find(i);\n\tint min1=(*ite1).second.first;\n\tint max1=(*ite1).second.second;\n\tint min2=(*ite2).second.first;\n\tint max2=(*ite2).second.second;\n\tif(max1<min2){\n\t  eo[j].push_back(k);\n\t  ei[k].push_back(j);\n\t}\n\tif(max2<min1){\n\t  eo[k].push_back(j);\n\t  ei[j].push_back(k);\n\t}\n      }\n    }\n  }\n  queue<int> S,L;\n  for(int i=0;i<m;i++)\n    if(!ei[i].size())S.push(i);\n  while(!S.empty()){\n    int t=S.front(); S.pop();\n    L.push(t);\n    for(int i=0;i<eo[t].size();i++){\n      int out=eo[t][i];\n      for(int k=0;k<ei[out].size();k++)\n\tif(ei[out][k]==t)ei[out].erase(ei[out].begin()+k);\n      eo[t].erase(eo[t].begin()+i);\n      i--;\n      if(!ei[out].size())S.push(out);\n    }\n  }\n  for(int i=0;i<m;i++)\n    if(ei[i].size()||eo[i].size())flag=1;\n  if(flag)cout<<\"No\"<<endl;\n  else cout<<\"Yes\"<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define N 101\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\nint m,n,k1,s,t,flag;\nvector<int> ei[N],eo[N];\nstring cond;\nvector<P1> v[N];\nmap<int,P> pam[N];\n\nint main(){\n  cin>>m>>n;\n  for(int i=0;i<m;i++){\n    cin>>k1;\n    for(int j=0;j<k1;j++){\n      cin>>s>>cond>>t;\n      if(cond[0]=='>')v[i].push_back(P1(s,P(t,INF)));\n      else v[i].push_back(P1(s,P(0,t)));\n    }\n    sort(v[i].begin(),v[i].end());\n  }\n  \n  for(int i=0;i<m;i++){\n    for(int j=0;j<(int)v[i].size()-1;j++){\n      if(v[i][j].first!=v[i][j+1].first)continue;\n      int min1=v[i][j].second.first;\n      int max1=v[i][j].second.second;\n      int min2=v[i][j+1].second.first;\n      int max2=v[i][j+1].second.second;\n      if(max1<min2)flag=1;\n      else{\n\tv[i][j]=P1(v[i][j+1].first,P(max(min1,min2),min(max1,max2)));\n\tv[i].erase(v[i].begin()+j+1);\n\tj--;\n      }\n    }\n  }\n  for(int i=0;i<m;i++)\n    for(int j=0;j<(int)v[i].size();j++){\n      int t1=v[i][j].first;\n      int t2=v[i][j].second.first;\n      int t3=v[i][j].second.second;\n      pam[i].insert(make_pair(t1,P(t2,t3)));\n    }\n  for(int i=1;i<=n;i++){\n    for(int j=0;j<m;j++){\n      if(pam[j].find(i)==pam[j].end())continue;\n      map<int,P>::iterator ite1=pam[j].find(i);\n      for(int k=j+1;k<m;k++){\n\tif(pam[k].find(i)==pam[k].end())continue;\n\tif(j==k)continue;\n\tmap<int,P>::iterator ite2=pam[k].find(i);\n\tint min1=(*ite1).second.first;\n\tint max1=(*ite1).second.second;\n\tint min2=(*ite2).second.first;\n\tint max2=(*ite2).second.second;\n\tif(max1<min2){\n\t  eo[j].push_back(k);\n\t  ei[k].push_back(j);\n\t}\n\tif(max2<min1){\n\t  eo[k].push_back(j);\n\t  ei[j].push_back(k);\n\t}\n      }\n    }\n  }\n  queue<int> S,L;\n  for(int i=0;i<m;i++)\n    if(!ei[i].size())S.push(i);\n  while(!S.empty()){\n    int t=S.front(); S.pop();\n    L.push(t);\n    for(int i=0;i<eo[t].size();i++){\n      int out=eo[t][i];\n      for(int k=0;k<ei[out].size();k++)\n\tif(ei[out][k]==t)ei[out].erase(ei[out].begin()+k);\n      eo[t].erase(eo[t].begin()+i);\n      i--;\n      if(!ei[out].size())S.push(out);\n    }\n  }\n  for(int i=0;i<m;i++)\n    if(ei[i].size()||eo[i].size())flag=1;\n  if(flag)cout<<\"No\"<<endl;\n  else cout<<\"Yes\"<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <set>\n#include <cstdio>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <ctime>\n#include <algorithm>\n#include <tuple>\n#include <algorithm>\n#include <limits>\n#include <map>\n#include <cstring>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\nconst int MN = 110;\nint V;\nvector<int> G[MN];\nvector<int> rG[MN];\nvector<int> vs;\nbool used[MN];\nint cmp[MN];\n\nvoid add_edge(int from, int to) {\n    G[from].push_back(to);\n    rG[to].push_back(from);\n}\n\nvoid dfs(int v) {\n    used[v] = true;\n    for(int i=0;i<G[v].size();i++) {\n        if(!used[G[v][i]]) dfs(G[v][i]);\n    }\n    vs.push_back(v);\n}\n\nvoid rdfs(int v, int k) {\n    used[v] = true;\n    cmp[v] = k;\n    for(int i=0;i<rG[v].size();i++) {\n        if (!used[rG[v][i]]) rdfs(rG[v][i], k);\n    }\n}\n\nint scc() {\n    memset(used, 0, sizeof(used));\n    vs.clear();\n    for(int v=0;v<V;v++) {\n        if (!used[v]) dfs(v);\n    }\n    memset(used, 0, sizeof(used));\n    int k = 0;\n    for(int i=vs.size() - 1; i >= 0; i--) {\n        if (!used[vs[i]]) rdfs(vs[i], k++);\n    }\n    return k;\n}\nint m;\nint g[MN][MN];\nbool solve() {\n    for (int i = 0; i < m; i++) {\n        if (g[i][i]) return false;\n    }\n    V = m;\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < m; j++) {\n            if (g[i][j]) add_edge(i, j);\n        }\n    }\n    return scc() == m;\n}\n\nint main() {\n    int n;\n    int s[MN][MN][2];\n    for (int i = 0; i < MN; i++) {\n        for (int j = 0; j < MN; j++) {\n            s[i][j][0] = 0;\n            s[i][j][1] = 1000;\n        }\n    }\n    cin >> m >> n;\n    for (int i = 0; i < m; i++) {\n        int k;\n        cin >> k;\n        for (int j = 0; j < k; j++) {\n            int a, b;\n            char c;\n            scanf(\"%d %c= %d\", &a, &c, &b);\n            s[i][a][(c == '<') ? 1 : 0] = b;\n        }\n    }\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < m; j++) {\n            bool f = false;\n            for (int k = 0; k < MN; k++) {\n                if (s[i][k][0] > s[j][k][1]) {\n                    f = true;\n                }\n            }\n            g[i][j] = f ? 1 : 0;\n        }\n    }\n    if (solve()) {\n        printf(\"Yes\\n\");\n    } else {\n        printf(\"No\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\nint M, N, ub[111][111], lb[111][111], skill[111];\nbool learned[111];\n\nbool all_learned() {\n\tfor_(i,0,M) if (!learned[i]) return false;\n\treturn true;\n}\n\nint main() {\n\tcin >> M >> N;\n\t\n\tfor_(i,0,M) for_(j,0,N) {\n\t\tub[i][j] = 100;\n\t\tlb[i][j] = 0;\n\t}\n\t\n\tfor_(i,0,M) {\n\t\tint K;\n\t\tcin >> K;\n\t\t\n\t\tfor_(j,0,K) {\n\t\t\tint s, t;\n\t\t\tstring cnd;\n\t\t\tcin >> s >> cnd >> t;\n\t\t\t--s;\n\t\t\t\n\t\t\tif (cnd == \">=\") lb[i][s] = max(lb[i][s], t);\n\t\t\telse ub[i][s] = min(ub[i][s], t);\n\t\t}\n\t\t\n\t\tbool learn = true;\n\t\tfor_(j,0,N) learn &= lb[i][j] <= 0 && 0 <= ub[i][j];\n\t\tlearned[i] = learn;\n\t}\n\t\n\tmemset(skill, 0, sizeof(skill));\n\t\t\n\twhile (!all_learned()) {\n\t\tint tar = -1;\n\t\t\n\t\tfor_(i,0,N) {\n\t\t\tbool isok = true;\n\t\t\t\n\t\t\tfor_(j,0,M) {\n\t\t\t\tif (learned[j]) continue;\n\t\t\t\tisok &= (skill[i] + 1 <= ub[j][i]);\n\t\t\t}\n\t\t\t\n\t\t\tif (isok) {\n\t\t\t\ttar = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (tar == -1) {\n\t\t\tcout << \"No\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t\t\n\t\t++skill[tar];\n\t\t\n\t\tfor_(i,0,M) {\n\t\t\tbool learn = true;\n\t\t\tfor_(j,0,N) learn &= (lb[i][j] <= skill[j] && skill[j] <= ub[i][j]);\n\t\t\tif (learn) learned[i] = true;\n\t\t}\n\t}\n\t\n\tcout << \"Yes\" << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define chmax(a,b) (a<(b)?(a=b,1):0)\n#define chmin(a,b) (a>(b)?(a=b,1):0)\n#define valid(y,x,h,w) (0<=y&&y<h&&0<=x&&x<w)\nconst int INF = 1<<29;\nconst double EPS = 1e-8;\nconst double PI = acos(-1);\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\nbool g[100][100];\nint lower[100][100];\nint upper[100][100];\n\nint main() {\n  int m,n;\n  while(cin >> m >> n) {\n    REP(i,m)REP(j,n){\n      lower[i][j] = -1;\n      upper[i][j] = 101;\n    }\n    REP(i,m) {\n      int k;\n      cin >> k;\n      REP(j,k) {\n        int s,t;\n        string cond;\n        cin >> s >> cond >> t;\n        s--;\n        if (cond == \">=\") {\n          chmax(lower[i][s], t);\n        } else {\n          chmin(upper[i][s], t);\n        }\n      }\n    }\n    memset(g,0,sizeof(g));\n    bool ng = 0;\n    REP(i,n) {\n      REP(j,m) {\n        if (lower[j][i] > upper[j][i]) ng = 1;\n        REP(k,m) {\n          if (j==k) continue;\n          if (upper[j][i] < lower[k][i]) {\n            g[j][k] = 1;\n          }\n        }\n      }\n    }\n    REP(k,n)REP(i,n)REP(j,n)g[i][j]|=g[i][k]&g[k][j];\n    REP(i,n)ng|=g[i][i];\n    puts(ng?\"No\":\"Yes\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\nstruct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nbool isDAG(vector<vector<int>>& G) {\n  int N = G.size();\n  vector<bool> vis(N);\n\n  std::function<bool(int, unordered_set<int>&)> dfs = [&](int curr, unordered_set<int>& st) {\n    for(auto&& e: G[curr]) {\n      if(st.count(e)) return false;\n      if(vis[e]) continue;\n      st.insert(e);\n      vis[e] = 1;\n      if(!dfs(e, st)) return false;\n      st.erase(e);\n    }\n    return true;\n  };\n\n  rep(e, N) {\n    vis[e] = 1;\n    unordered_set<int> st = {e};\n    if(!dfs(e, st)) return false;\n  }\n  return true;\n}\n\nint main() {\n\n  int M, N; cin >> M >> N;\n\n  // テ・ツ青?」ツつケテ」ツつュテ」ツδォテヲツッツ偲」ツ?ォテ」ツつウテ」ツδ榲」ツδウテ」ツδ嘉」ツ?ョテ・ツ個コテゥツ鳴禿」ツつ津ヲツ個?」ツ?、\n  vector<vector<pair<int, int>>> cmd_sect(N, vector<pair<int, int>>(M, {0, inf}));\n\n  rep(cmd_idx, M) {\n    int K; cin >> K;\n    rep(_, K) {\n      int skill; cin >> skill; skill--;\n      string op; cin >> op;\n      int threshold; cin >> threshold;\n      if(op == \">=\") {\n        cmd_sect[skill][cmd_idx].first = max(cmd_sect[skill][cmd_idx].first, threshold);\n      } else {\n        cmd_sect[skill][cmd_idx].second = min(cmd_sect[skill][cmd_idx].second, threshold);\n      }\n      if(cmd_sect[skill][cmd_idx].first > cmd_sect[skill][cmd_idx].second) {\n        cout << \"No\" << endl;\n        return 0;\n      }\n    }\n  }\n\n  vector<vector<int>> G(M);\n  \n  rep(i, N) {\n    rep(a, M) rep(b, M) {\n      if(a == b) continue;\n      if(cmd_sect[i][a].second < cmd_sect[i][b].first)\n        G[a].push_back(b);\n    }\n  }\n\n  rep(i, M) {\n    sort(all(G[i]));\n    G[i].erase(unique(all(G[i])), G[i].end());\n  }\n\n  cout << (isDAG(G) ? \"Yes\" : \"No\") << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <stack>\n#include <algorithm>\n#include <string>\n#define rep(i,a,n) for(int i=a; i<n; i++)\nusing namespace std;\n\n// 移動元と行先と辺のコストを記録する構造体\ntemplate <typename T>\nstruct Edge {\n    int from, to;\n    T cost;\n    Edge(int s, T d) : to(s), cost(d) {}\n    Edge(int f, int s, T d) : from(f), to(s), cost(d) {}\n\n    bool operator<(const Edge &e) const {\n        return cost < e.cost;\n    }\n    bool operator>(const Edge &e) const {\n        return cost > e.cost;\n    }\n};\n\ntemplate <typename T>\nusing Graph = vector< vector< Edge<T> > >;\n\ntemplate <typename T>\nvector<int> tpsort_Kahn(const vector< vector< Edge<T> > > &g) {\n    const int V = g.size();\n    vector<int> indeg(V, 0);\n    stack<int> S;\n\n    rep(i,0,V) rep(j,0,g[i].size())\n        indeg[ g[i][j].to ]++;\n    rep(i,0,V) if(indeg[i] == 0) S.push(i);\n\n    vector<int> ans;\n    while(S.size() > 0) {\n        int u = S.top(); S.pop();\n        ans.push_back(u);\n        rep(i,0,g[u].size()) {\n            indeg[ g[u][i].to ]--;\n            if(indeg[ g[u][i].to ] ==  0)\n                S.push( g[u][i].to );\n        }\n    }\n    return ans;\n}\n\nconst int INF = 1 << 28;\nint lb[110][110], ub[110][110];\n\nint main() {\n    int M, N; cin >> M >> N;\n    for(int i=0; i<M; i++) {\n        fill(lb[i], lb[i] + N,  -1);\n        fill(ub[i], ub[i] + N, INF);\n    }\n\n    Graph<int> G(M);\n    bool ok = true;\n    for(int i=0; i<M; i++) {\n        int K; cin >> K;\n        for(int k=0; k<K; k++) {\n            int s, t;\n            string cond;\n            cin >> s >> cond >> t; s--;\n            if(cond == \"<=\") ub[i][s] = min(ub[i][s], t);\n            if(cond == \">=\") lb[i][s] = max(lb[i][s], t);\n        }\n        for(int k=0; k<N; k++) {\n            if(lb[i][k] > ub[i][k]) ok = false;\n        }\n    }\n\n    for(int i=0; i<M; i++) {\n        for(int j=0; j<M; j++) {\n            if(i == j) continue;\n            for(int k=0; k<N; k++) {\n                // i より j の方が後でなければならない条件\n                if(ub[i][k] == INF || lb[j][k] == -1) continue;\n                if(ub[i][k] < lb[j][k]) {\n                    G[i].push_back(Edge<int>(j, 1));\n                }\n            }\n        }\n    }\n\n    if(tpsort_Kahn(G).size() != M) ok = false;\n    cout << (ok ? \"Yes\" : \"No\") << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\nstruct SCC{\n  Int n;\n  vector<vector<Int> > G,rG,T,C;\n  vector<Int> vs,used,blg;\n  SCC(){}\n  SCC(Int n):n(n),G(n),rG(n),used(n),blg(n){}\n  \n  void add_edge(Int from,Int to){\n    G[from].emplace_back(to);\n    rG[to].emplace_back(from);\n  }\n  \n  void dfs(Int v){\n    used[v]=1;\n    for(Int u:G[v])\n      if(!used[u]) dfs(u);\n    vs.emplace_back(v);\n  }\n  \n  void rdfs(Int v,Int k){\n    used[v]=1;\n    blg[v]=k;\n    C[k].emplace_back(v);\n    for(Int u:rG[v])\n      if(!used[u]) rdfs(u,k);\n  }\n  \n  Int build(){\n    for(Int v=0;v<n;v++)\n      if(!used[v]) dfs(v);\n    \n    fill(used.begin(),used.end(),0);\n    Int k=0;\n    for(Int i=vs.size()-1;i>=0;i--){\n      if(!used[vs[i]]){\n        T.emplace_back();\n        C.emplace_back();\n        rdfs(vs[i],k++);\n      }\n    }\n    for(Int v=0;v<n;v++)\n      for(Int u:G[v])\n        if(blg[v]!=blg[u])\n          T[blg[v]].push_back(blg[u]);\n    \n    for(Int i=0;i<k;i++){\n      sort(T[i].begin(),T[i].end());\n      T[i].erase(unique(T[i].begin(),T[i].end()),T[i].end());\n    }\n    return k;\n  }\n};\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int m,n;\n  cin>>m>>n;\n  \n  struct Skill{\n    vector<Int> s,t;\n    vector<string> cond;\n    Skill(Int k):s(k),t(k),cond(k){}\n  };\n  \n  vector<Skill> vs;\n  for(Int i=0;i<m;i++){\n    Int k;\n    cin>>k;\n    vs.emplace_back(k);\n    for(Int j=0;j<k;j++)\n      cin>>vs[i].s[j]>>vs[i].cond[j]>>vs[i].t[j],vs[i].s[j]--;\n  }\n  \n  auto check=\n    [&](Int x,Int y)->Int{\n      auto &vx=vs[x];\n      auto &vy=vs[y];\n      vector<Int> va(n,0);\n      \n      for(Int i=0;i<(Int)vx.s.size();i++){\n        if(vx.cond[i]==\">=\")\n          chmax(va[vx.s[i]],vx.t[i]);\n      }\n      \n      for(Int i=0;i<(Int)vy.s.size();i++){\n        if(vy.cond[i]==\"<=\"){\n          if(va[vy.s[i]]>vy.t[i]) return 1;\n        }\n      }\n      \n      return 0;\n    };\n  \n  auto NG=[](){cout<<\"No\"<<endl;exit(0);};  \n  for(Int i=0;i<m;i++) if(check(i,i)) NG();\n\n  SCC scc(m);\n  for(Int i=0;i<m;i++)\n    for(Int j=0;j<m;j++)\n      if(check(i,j)) scc.add_edge(j,i);\n  \n  if(scc.build()!=m) NG();\n  \n  cout<<\"Yes\"<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define ALL(a) (a).begin(), (a).end()\n#define ll long long\n\nusing namespace std;\n\nsigned main(){\n    const string GL = \">=\";\n    int n,m; cin >> m >> n;\n    vector<vector<int> > g(m, vector<int>(n,0));\n    vector<vector<int> > l(m, vector<int>(n,100));\n    for(int i = 0; i < m; i++){\n        int k; cin >> k;\n        for(int j = 0; j < k; j++){\n            int s,t; string c;\n            cin >> s >> c >> t;\n            s--;\n            if(c == GL){\n                g[i][s] = max(g[i][s], t);\n            }\n            else{\n                l[i][s] = min(l[i][s], t);\n            }\n        }\n    }\n    vector<bool> isget(m, false);\n    vector<int> skill(n, 0);\n    for(int i = 0; i < m; i++){\n        for(int j = 0; j < m+1; j++){\n            if(j == m){\n                cout << \"No\" << endl;\n                return 0;\n            }\n            if(isget[j])continue;\n            vector<int> st = skill;\n            for(int k = 0; k < n; k++){\n                if(st[k] < g[j][k])st[k] = g[j][k];\n            }\n            bool flag = true;\n            for(int k = 0; k < m; k++){\n                if(isget[j])continue;\n                for(int p = 0; p < n; p++){\n                    if(st[p] > l[k][p]){\n                        flag = false;\n                        k = m;\n                        break;\n                    }\n                }\n            }\n            if(flag){\n                swap(skill, st);\n                isget[j] = true;\n                break;\n            }\n        }\n    }\n    cout << \"Yes\" << endl;\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 1<<28;\nconst int MAXM = 101;\nconst int MAXN = 101;\nint M, N;\nint low[MAXM][MAXN], high[MAXM][MAXN];\n\nint main() {\n  for(; cin >> M >> N; ) {\n    fill(low[0], low[MAXM], -INF);\n    fill(high[0], high[MAXM], INF);\n    for(int i = 0; i < M; ++i) {\n      int K; cin >> K;\n      for(int j = 0; j < K; ++j) {\n        int s, v; string op;\n        cin >> s >> op >> v;\n        --s;\n        if(op == \"<=\") high[i][s] = min(high[i][s], v);\n        if(op == \">=\") low[i][s] = max(low[i][s], v);\n      }\n    }\n\n    try {\n      vector<int> s, t;\n      for(int i = 0; i < M; ++i) {\n        for(int k = 0; k < N; ++k) {\n          if(low[i][k] > high[i][k]) throw \"No\";\n        }\n        for(int j = 0; j < M; ++j) {\n          if(i == j) continue;\n          for(int k = 0; k < N; ++k) {\n            if(high[i][k] < low[j][k]) {\n              s.push_back(i);\n              t.push_back(j);\n            }\n          }\n        }\n      }\n      \n      vector<int> w(M, 0);\n      for(int k = 0; k < M; ++k) {\n        bool update = false;\n        for(int i = 0; i < s.size(); ++i) {\n          if(w[t[i]] > w[s[i]] - 1) {\n            w[t[i]] = w[s[i]] - 1;\n            update = true;\n          }\n        }\n        if(!update) throw \"Yes\";\n        if(k+1 == M) throw \"No\";\n      } \n    } catch(const char *s) {\n      cout << s << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * Author: NICK WONG\n * Created Time:  2015/8/22 13:40:04\n * File Name: \n */\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<vector>\n#include<list>\n#include<deque>\n#include<queue>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cctype>\n#include<cmath>\n#include<ctime>\n#include<iomanip>\nusing namespace std;\n#define out(x) cout<<#x<<\": \"<<x<<endl\nconst double eps(1e-8);\nconst int maxn=110;\nconst long long maxint=-1u>>1;\nconst long long maxlong=maxint*maxint;\ntypedef long long lint;\nint m,n,ans;\nbool com[maxn][maxn],used[maxn];\nint sum[maxn],match[maxn];\nstruct node\n{\n    int type,l,r;\n} lim[maxn][maxn];\nint a[maxn],b[maxn];\n\nvoid init()\n{\n    memset(used,false,sizeof(used));\n    memset(com,false,sizeof(com));\n    memset(lim,0,sizeof(lim));\n    memset(match,0,sizeof(match));\n    memset(a,0,sizeof(a));\n    memset(b,0,sizeof(b));\n    for (int i=1; i<=m; i++)\n    {\n        cin>>sum[i];\n        for (int j=1; j<=n; j++) { lim[i][j].type=233; lim[i][j].r=100; }\n        if (sum[i]==0) { used[i]=true; ans++; }\n        for (int j=1; j<=sum[i]; j++)\n        {\n            int x,y;\n            string s;\n            cin>>x>>s>>y;       \n            b[x]=max(b[x],y);//\n            if (s[0]=='<')\n            {\n                lim[i][x].r=min(lim[i][x].r,y);\n                lim[i][x].type=0; \n                /*com[i][x]=true;\n                match[i]++;\n                if (match[i]==sum[i]) { used[i]=true; ans++; }*/\n            } else\n            {\n                lim[i][x].type=1;\n                lim[i][x].l=max(lim[i][x].l,y);\n            }\n        }\n    }\n    \n}\n\nvoid work()\n{\n    ans=0;\n    for (int i=1; i<=m; i++)\n        for (int j=1; j<=n; j++)\n            if (lim[i][j].type!=233 && lim[i][j].l==0)\n            {\n                com[i][j]=true;\n                match[i]++;\n                if (match[i]==sum[i]) { used[i]=true; ans++; }\n            }\n    for (int i=1; i<=m; i++)\n    {\n        for (int j=1; j<=n; j++) \n        {\n            if (lim[i][j].type!=233 && lim[i][j].l>lim[i][j].r) \n            {\n                cout<<\"No\"<<endl;\n                return;\n            }\n            //cout<<i<<\" \"<<j<<\" \"<<lim[i][j].l<<\" \"<<lim[i][j].r<<endl;\n        }\n    }\n    //for (int i=1; i<=m; i++)\n        //cout<<i<<\" \"<<match[i]<<endl;\n    //out(ans);\n    //start\n    bool flag=true;\n    int st=1;\n    while(flag)\n    {\n        int tmp=st;\n        bool check=false;\n        flag=false;\n        while(!check)\n        {\n            check=true;\n            if (a[st]!=b[st])\n            {\n                for (int i=1; i<=m; i++)\n                    if (!used[i] && a[st]+1>lim[i][st].r) { check=false; break; }\n            } else check=false;\n            if (check) break;\n            st++;\n            if (st>n) st=1;\n            if (st==tmp) break;\n        }\n        if (check)\n        {\n            flag=true;\n            a[st]++;\n            for (int i=1; i<=m; i++)\n                if (!used[i] && a[st]>=lim[i][st].l && !com[i][st]) \n                { \n                    com[i][st]=true; \n                    match[i]++;\n                    if (match[i]==sum[i]) { used[i]=true; ans++; }\n                }\n        }\n        if (ans==m) break;    \n    }\n    \n    //for (int i=1; i<=m; i++)\n    //{\n        //cout<<a[i]<<endl;\n        //out(used[i]);\n    //}\n    if (ans==m) cout<<\"Yes\"<<endl; else cout<<\"No\"<<endl;\n}\n\nint main()\n{\n    while(cin>>m>>n)\n    {\n    init();\n    work();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n \nusing namespace std;\nchar str[3];\npair<int,int> v[100][100];\nint g[100][100];\nint main(){\n\tint a,b;\n\tscanf(\"%d%d\",&a,&b);\n\tfor(int i=0;i<a;i++){\n\t\tint c;\n\t\tscanf(\"%d\",&c);\n\t\tfor(int j=0;j<b;j++)v[i][j]=make_pair(0,100);\n\t\tfor(int j=0;j<c;j++){\n\t\t\tint d,e;\n\t\t\tscanf(\"%d%s%d\",&d,str,&e);\n\t\t\td--;\n\t\t\tif(str[0]=='>'){\n\t\t\t\tv[i][d].first=max(v[i][d].first,e);\n\t\t\t}else v[i][d].second=min(v[i][d].second,e);\n\t\t}\n\t}\n\tbool ok=true;\n\tfor(int i=0;i<a;i++)\n\t\tfor(int j=0;j<b;j++)\n\t\t\tif(v[i][j].first>v[i][j].second)ok=false;\n\tfor(int i=0;i<a;i++)\n\t\tfor(int j=0;j<a;j++){\n\t\t\tfor(int k=0;k<b;k++)if(v[i][k].second<v[j][k].first)g[i][j]=1;\n\t\t}\n\tfor(int k=0;k<a;k++)\n\t\tfor(int i=0;i<a;i++)\n\t\t\tfor(int j=0;j<a;j++)\n\t\t\t\tg[i][j]|=(g[i][k]&g[k][j]);\n\tfor(int i=0;i<a;i++)if(g[i][i])ok=false;\n\tfor(int i=0;ok&&i<a;i++){\n\t\tfor(int j=0;ok&&j<a;j++){\n\t\t\tfor(int k=0;ok&&k<b;k++){\n\t\t\t\tfor(int l=0;ok&&l<b;l++){\n\t\t\t\t\tif(v[i][k].second<v[j][k].first&&v[j][l].second<v[i][l].first)ok=false;\n\t\t\t\t\tif(v[j][k].second<v[i][k].first&&v[i][l].second<v[j][l].first)ok=false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(ok)printf(\"Yes\\n\");\n\telse printf(\"No\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\nint M,N;\n\nstruct state{\n  int k;\n  int maxi[101],mini[101];\n  void init(){\n    for(int j=1;j<=N;j++){\n      maxi[j] = 100;\n      mini[j] = 0;\n    }\n  }\n  bool check(){\n    for(int i=1;i<=N;i++){\n      if( maxi[i] < mini[i] ) return false;\n    }\n    return true;\n  }\n};\n\nstate S[101];\n\nbool check(const state &s1, const state &s2){\n  for(int i=1;i<=N;i++){\n    if( s1.mini[i] > s2.maxi[i] ) return false;\n  }\n  return true;\n}\n\nvector<int> G[101];\nint nG[101];\n\n\n\nint main(){\n  cin >> M >> N;\n  bool f = true;\n  for(int i=0;i<M;i++){\n    S[i].init();\n    cin >> S[i].k;\n    for(int j=0;j<S[i].k;j++){\n      int s,t;string c;\n      cin >> s >> c >> t;\n      if( c == \"<=\" ){\n        S[i].maxi[s] = t;\n      } else {\n        S[i].mini[s] = t;\n      }\n    }\n    if( !S[i].check() ) f = false;\n  }\n\n  if( !f ) {\n    cout << \"No\" << endl;\n    return 0;\n  }\n\n  for(int i=0;i<M;i++){\n    for(int j=0;j<M;j++){\n      if( i == j ) continue;\n      if( check(S[i],S[j]) )\n        G[i].push_back( j );\n    }\n  }\n\n  //kokomade_\n\n  for(int i=0;i<M;i++) nG[i] = G[i].size();\n  int T = M-1;\n  bool used[111]={};\n  while( T ){\n    vector<P> pr;\n    for(int i=0;i<M;i++){\n      if(!used[i]) pr.push_back( P(nG[i],i) );    \n    }\n    sort(pr.begin(),pr.end());\n\n    if( pr.back().first >= T ){\n      used[pr.back().second] = true;\n      for(int i=0;i<M;i++){\n        for(int j=0;j<(int)G[i].size();j++){\n          int to = G[i][j];\n          if( to == pr.back().second ) {\n            nG[i]--;\n          }\n        }\n      }\n    } else {\n      f = false;\n      break;\n    }\n    --T;\n  }\n  if( f ) cout << \"Yes\" << endl;\n  else cout << \"No\" << endl;\n\n  \n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n\n    int m, n; cin >> m >> n;     //m　コマンド数　n スキル数    \n\n    //コマンドiを取得するための条件　各スキルjに対して\n    //l[i][j] <= skill_point[j] <= u[i][j]\n    vector<vector<int> > u(m, vector<int> (n, 101));\n    vector<vector<int> > l(m, vector<int> (n, -1));\n    \n    vector<bool> isGet(m, false);\n    vector<int> skill_point(n, 0);\n\n\n    for(int i = 0; i < m; i++){\n        int k; cin >> k;\n        for(int j = 0; j < k; j++){\n            int s, t;\n            string cond; cin >> s >> cond >> t;\n            s--;\n            if(cond == \"<=\") u[i][s] = min(u[i][s], t);\n            else l[i][s] = max(l[i][s], t);\n        }\n    }\n\n    //例外処理\n    for(int i = 0; i < m; i++){\n        for(int j = 0; j < n; j++){\n            if(l[i][j] > u[i][j]){\n                cout << \"No\" << endl;\n                return 0;\n            }\n        }\n    }\n\n\n    for(int c = 0; c < m; c++){\n\n        //取れるコマンドを探す\n        bool ok = false;\n        for(int i = 0; i < m; i++){\n            \n            //すでに取得済みなら\n            if(isGet[i]) continue;\n\n            vector<int> tmp_skill_point(n);\n            for(int j = 0; j < n; j++){\n                tmp_skill_point[j] = max(skill_point[j], l[i][j]);\n            }\n\n            //未だとってないコマンドが、iの後にとれるか\n            bool i_ok = true;\n            for(int k = 0; k < m; k++){\n\n                //iかもうすでに取っていたら\n                if(k == i || isGet[k]) continue;\n\n                //kは大丈夫？\n                bool k_ok = true;\n                for(int j = 0; j < n; j++){\n                    if(tmp_skill_point[j] > u[k][j]){\n                        k_ok = false;\n                        break;\n                    }\n                }\n\n                if(!k_ok){\n                    i_ok = false;\n                    break;\n                }\n            }\n\n            //iが取れるなら、とる\n            if(i_ok){\n                isGet[i] = true;\n                ok = true;\n                for(int j = 0; j < n; j++) skill_point[j] = tmp_skill_point[j];\n                break;\n            }\n\n        }\n\n        if(!ok){\n            cout << \"No\" << endl;\n            return 0;\n        }\n\n    }\n\n    cout << \"Yes\" << endl;\n    return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\nstruct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nbool isDAG(vector<vector<int>>& G) {\n  int N = G.size();\n  vector<bool> vis(N);\n\n  std::function<bool(int)> dfs = [&](int curr) {\n    for(auto&& e: G[curr]) {\n      if(vis[e]) return false;\n      vis[e] = 1;\n      if(!dfs(e)) return false;\n      vis[e] = 0;\n    }\n    return true;\n  };\n\n  vector<int> deg(N);\n\n  rep(i, N)\n    for(auto&& e: G[i])\n      deg[e]++;\n\n  vector<int> starts;\n\n  rep(i, N)\n    if(deg[i] == 0)\n      starts.push_back(i);\n\n  if(starts.empty()) return false;\n\n  for(auto&& e: starts) {\n    vis[e] = 1;\n    if(!dfs(e)) return false;\n    vis[e] = 0;\n  }\n  return true;\n}\n\nint main() {\n\n  int M, N; cin >> M >> N;\n\n  // テ・ツ青?」ツつケテ」ツつュテ」ツδォテヲツッツ偲」ツ?ォテ」ツつウテ」ツδ榲」ツδウテ」ツδ嘉」ツ?ョテ・ツ個コテゥツ鳴禿」ツつ津ヲツ個?」ツ?、\n  vector<vector<pair<int, int>>> cmd_sect(N, vector<pair<int, int>>(M, {0, inf}));\n\n  rep(cmd_idx, M) {\n    int K; cin >> K;\n    rep(_, K) {\n      int skill; cin >> skill; skill--;\n      string op; cin >> op;\n      int threshold; cin >> threshold;\n      if(op == \">=\") {\n        cmd_sect[skill][cmd_idx].first = max(cmd_sect[skill][cmd_idx].first, threshold);\n      } else {\n        cmd_sect[skill][cmd_idx].second = min(cmd_sect[skill][cmd_idx].second, threshold);\n      }\n      if(cmd_sect[skill][cmd_idx].first > cmd_sect[skill][cmd_idx].second) {\n        cout << \"No\" << endl;\n        return 0;\n      }\n    }\n  }\n\n  vector<vector<int>> G(M);\n  \n  rep(i, N) {\n    rep(a, M) rep(b, M) {\n      if(a == b) continue;\n      if(cmd_sect[i][a].second < cmd_sect[i][b].first)\n        G[a].push_back(b);\n    }\n  }\n\n  rep(i, M) {\n    sort(all(G[i]));\n    G[i].erase(unique(all(G[i])), G[i].end());\n  }\n\n  cout << (isDAG(G) ? \"Yes\" : \"No\") << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <set>\n#include <cstdio>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <ctime>\n#include <algorithm>\n#include <tuple>\n#include <algorithm>\n#include <limits>\n#include <map>\n#include <cstring>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\nconst int MN = 110;\nint V;\nvector<int> G[MN];\nvector<int> rG[MN];\nvector<int> vs;\nbool used[MN];\nint cmp[MN];\n\nvoid add_edge(int from, int to) {\n    G[from].push_back(to);\n    rG[to].push_back(from);\n}\n\nvoid dfs(int v) {\n    used[v] = true;\n    for(int i=0;i<G[v].size();i++) {\n        if(!used[G[v][i]]) dfs(G[v][i]);\n    }\n    vs.push_back(v);\n}\n\nvoid rdfs(int v, int k) {\n    used[v] = true;\n    cmp[v] = k;\n    for(int i=0;i<rG[v].size();i++) {\n        if (!used[rG[v][i]]) rdfs(rG[v][i], k);\n    }\n}\n\nint scc() {\n    memset(used, 0, sizeof(used));\n    vs.clear();\n    for(int v=0;v<V;v++) {\n        if (!used[v]) dfs(v);\n    }\n    memset(used, 0, sizeof(used));\n    int k = 0;\n    for(int i=vs.size() - 1; i >= 0; i--) {\n        if (!used[vs[i]]) rdfs(vs[i], k++);\n    }\n    return k;\n}\nint m;\nint g[MN][MN];\nbool solve() {\n    for (int i = 0; i < m; i++) {\n        if (g[i][i]) return false;\n    }\n    V = m;\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < m; j++) {\n            if (g[i][j]) add_edge(i, j);\n        }\n    }\n    return scc() == m;\n}\n\nint main() {\n    int n;\n    int s[MN][MN][2];\n    for (int i = 0; i < MN; i++) {\n        for (int j = 0; j < MN; j++) {\n            s[i][j][0] = 0;\n            s[i][j][1] = 1000;\n        }\n    }\n    cin >> m >> n;\n    for (int i = 0; i < m; i++) {\n        int k;\n        cin >> k;\n        for (int j = 0; j < k; j++) {\n            int a, b;\n            char c;\n            scanf(\"%d %c= %d\", &a, &c, &b); a--;\n            s[i][a][(c == '<') ? 1 : 0] = b;\n        }\n    }\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < m; j++) {\n            bool f = false;\n            for (int k = 0; k < MN; k++) {\n                if (s[i][k][0] > s[j][k][1]) {\n                    f = true;\n                }\n            }\n            g[i][j] = f ? 1 : 0;\n        }\n    }\n    if (solve()) {\n        printf(\"Yes\\n\");\n    } else {\n        printf(\"Yes\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n \nusing namespace std;\nchar str[10];\npair<int,int> v[110][110];\nint g[110][110];\nint main(){\n\tint a,b;\n\tscanf(\"%d%d\",&a,&b);\n\tfor(int i=0;i<a;i++){\n\t\tint c;\n\t\tscanf(\"%d\",&c);\n\t\tfor(int j=0;j<b;j++)v[i][j]=make_pair(0,100);\n\t\tfor(int j=0;j<c;j++){\n\t\t\tint d,e;\n\t\t\tscanf(\"%d%s%d\",&d,str,&e);\n\t\t\td--;\n\t\t\tif(str[0]=='>'){\n\t\t\t\tv[i][d].first=max(v[i][d].first,e);\n\t\t\t}else v[i][d].second=min(v[i][d].second,e);\n\t\t}\n\t}\n\tbool ok=true;\n\tfor(int i=0;i<a;i++)\n\t\tfor(int j=0;j<b;j++)\n\t\t\tif(v[i][j].first>v[i][j].second)ok=false;\n\tfor(int i=0;i<a;i++)\n\t\tfor(int j=0;j<a;j++){\n\t\t\tfor(int k=0;k<b;k++)if(v[i][k].second<v[j][k].first)g[i][j]=1;\n\t\t}\n\tfor(int k=0;k<a;k++)\n\t\tfor(int i=0;i<a;i++)\n\t\t\tfor(int j=0;j<a;j++)\n\t\t\t\tg[i][j]|=(g[i][k]&g[k][j]);\n\tfor(int i=0;i<a;i++)if(g[i][i])ok=false;\n\tfor(int i=0;ok&&i<a;i++){\n\t\tfor(int j=0;ok&&j<a;j++){\n\t\t\tfor(int k=0;ok&&k<b;k++){\n\t\t\t\tfor(int l=0;ok&&l<b;l++){\n\t\t\t\t\tif(v[i][k].second<v[j][k].first&&v[j][l].second<v[i][l].first)ok=false;\n\t\t\t\t\tif(v[j][k].second<v[i][k].first&&v[i][l].second<v[j][l].first)ok=false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif(ok)printf(\"Yes\\n\");\n\telse printf(\"No\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\nstruct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nbool isDAG(vector<vector<int>>& G) {\n  int N = G.size();\n  vector<bool> vis(N);\n\n  std::function<bool(int)> dfs = [&](int curr) {\n    for(auto e: G[curr]) {\n      if(vis[e]) return false;\n      vis[e] = 1;\n      if(!dfs(e)) return false;\n      vis[e] = 0;\n    }\n    return true;\n  };\n\n  rep(i, N) {\n    vis[i] = 1;\n    if(!dfs(i)) return false;\n    vis[i] = 0;\n  }\n  return true;\n}\n\nint main() {\n\n  int M, N; cin >> M >> N;\n\n  // テ・ツ青?」ツつケテ」ツつュテ」ツδォテヲツッツ偲」ツ?ォテ」ツつウテ」ツδ榲」ツδウテ」ツδ嘉」ツ?ョテ・ツ個コテゥツ鳴禿」ツつ津ヲツ個?」ツ?、\n  vector<vector<pair<int, int>>> cmd_sect(N, vector<pair<int, int>>(M, {-inf, inf}));\n\n  rep(cmd_idx, M) {\n    int K; cin >> K;\n    rep(_, K) {\n      int skill; cin >> skill; skill--;\n      string op; cin >> op;\n      int threshold; cin >> threshold;\n      if(op == \">=\") {\n        cmd_sect[skill][cmd_idx].first = max(cmd_sect[skill][cmd_idx].first, threshold);\n      } else {\n        cmd_sect[skill][cmd_idx].second = min(cmd_sect[skill][cmd_idx].second, threshold);\n      }\n      if(cmd_sect[skill][cmd_idx].first > cmd_sect[skill][cmd_idx].second) {\n        cout << \"No\" << endl;\n        return 0;\n      }\n    }\n  }\n\n  // OK\n\n  vector<vector<int>> G(N);\n  \n  rep(i, N) {\n    rep(a, M) REP(b, a+1, M) {\n      if(cmd_sect[i][a].second < cmd_sect[i][b].first) {\n//        if(cmd_sect[i][a].second == 3 && cmd_sect[i][b].first == 5 ) {cout << i << \" valid\" << endl;}\n        G[a].push_back(b);\n      }\n      if(cmd_sect[i][b].second < cmd_sect[i][a].first) {\n        G[b].push_back(a);\n      }\n    }\n  }\n\n  cout << (isDAG(G) ? \"Yes\" : \"No\") << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n\nusing namespace std;\n\nbool isOK2after1(vector<int> &com1Inf, vector<int> &com2Sup){\n    for(int i=0; i < com1Inf.size() ; i++){\n        if( com1Inf[i] >  com2Sup[i]) return false;\n    }\n    return true;\n}\nvoid condition(vector<int> &comInf, vector<int> &com2Inf){\n    for(int i=0 ; i< comInf.size() ; i++){\n        comInf[i] = max(comInf[i],com2Inf[i]);\n    }\n}\n\nint main() {\n    int M,N;\n    cin >> M >> N;\n    int K, s, t;\n    string cnd;\n    vector<vector<int>> comInf(M,vector<int>(N,0));\n    vector<vector<int>> comSup(M,vector<int>(N,100));\n    vector<int> sp(N,0);\n\n    for(int i=0; i<M ; i++){\n        cin >> K;\n        for(int j=0; j<K ; j++){\n            cin >> s >> cnd >> t;\n            s--;\n            if(cnd == \">=\"){\n                comInf[i][s] = max(comInf[i][s],t);\n            }else{\n                comSup[i][s] = min(comSup[i][s],t);\n            }\n        }\n    }\n    for(int i=0 ; i< M ; i++){\n        vector<int> ansInf(N,0);\n        if(!isOK2after1(comInf[i],comSup[i])){\n            cout << \"No\" << endl;\n            return 0;\n        }\n        vector<bool> isOK(N,false);\n        for(int j=0; j<i ; j++){\n            if(isOK2after1(comInf[i], comSup[j])) {\n                isOK[j] = true;\n            }else{\n                condition(ansInf, comInf[j]);\n                if(!isOK2after1(comInf[j],comSup[i])){\n                    cout << \"No\" << endl;\n                    return 0;\n                }\n            }\n        }\n        condition(ansInf,comInf[i]);\n        for(int j=0; j<i ; j++){\n            if(isOK[j]){\n                if(!isOK2after1(ansInf,comSup[j])){\n                    cout << \"No\" << endl;\n                    return 0;\n                }\n            }\n        }\n    }\n    cout << \"Yes\" << endl; \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nint M,N;\nint S[100][100];\nint T[100][100];\n\nconst int INF=1001001001;\nint D[100][100];\nsigned main(){\n    cin>>M>>N;\n    rep(i,M)rep(j,N)S[i][j]=0,T[i][j]=100;\n    rep(i,M){\n        int K;cin>>K;\n        while(K--){\n            int s,t;\n            string c;\n            cin>>s>>c>>t;s--;\n            if(c==\"<=\")chmin(T[i][s],t);\n            else chmax(S[i][s],t);\n        }\n    }\n    rep(i,M)rep(j,N)if(S[i][j]>T[i][j]){\n        cout<<\"No\"<<endl;\n        return 0;\n    }\n\n    fill_n(*D,100*100,INF);\n    rep(i,M)D[i][i]=0;\n    rep(i,M)rep(j,M)if(i!=j){\n        bool flag=false;\n        rep(k,N)if(T[i][k]<S[j][k])flag=true;\n        if(flag)D[i][j]=0;\n    }\n\n    rep(k,M)rep(i,M)rep(j,M)chmin(D[i][j],D[i][k]+D[k][j]);\n\n    rep(i,M)rep(j,M)if(i!=j&&D[i][j]!=INF&&D[j][i]!=INF){\n        cout<<\"No\"<<endl;\n        return 0;\n    }\n    cout<<\"Yes\"<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\ntypedef pair<int,int> pii;\n#define mkp make_pair\nint INF=INT_MAX/2;\nint m,n;\nvector<vector<pii>> v;\nvector<vector<int>> vv;\nvector<int> used;\nbool foo(int a){\n    // cout<<\"a \"<<a<<endl;\n    if(used[a]==1) return false;\n    if(used[a]==2) return true;\n    used[a]=1;\n    for(int x:vv[a]){\n        // cout<<\"x \"<<x<<endl;\n        if(!foo(x)){\n            used[a]=0;\n            return false; \n        }\n    }\n    used[a]=2;\n    return true;\n}\nint main(){\n    cin>>m>>n;\n    used=vector<int>(m,0);\n    v=vector<vector<pii>>(m,vector<pii>(n,pii(0,INF)));\n    rep(i,m){\n        int K;\n        cin>>K;\n        rep(j,K){\n            int a,b;\n            string s;\n            cin>>a>>s>>b;\n            if(s==\">=\"){\n                v[i][a-1].first=max(v[i][a-1].first,b);\n            }\n            else{\n                v[i][a-1].second=min(v[i][a-1].second,b);\n            }\n        }\n    }\n    vv=vector<vector<int>>(m);\n    rep(i,m){\n        rep(j,m){\n            bool f=false;\n            rep(k,n){\n                if(v[i][k].first>v[j][k].second) f=true;\n            }\n            if(f){\n                // cout<<i<<\" \"<<j<<endl;\n                vv[i].push_back(j);\n            }\n        }\n    }\n    // return 0;\n    bool f=true;\n    rep(i,m){\n        if(!foo(i)) f=false;\n    }\n    if(f) cout<<\"Yes\"<<endl;\n    else cout<<\"No\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cctype>\n#include <cstring>\n#include <ctime>\n#include <iterator>\n#include <bitset>\n#include <numeric>\n#include <list>\nusing namespace std;\n\n\ntypedef long long LL;\ntypedef pair<int,int> pii;\ntypedef pair<LL,LL> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n\tv.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n\tstringstream ss;\n\tss << f;\n\tss >> t;\n}\n\n\n#define REP(i,n) for(int i=0;i<int(n);++i)\n#define ALL(v) (v).begin(),(v).end()\n#define RALL(v) (v).rbegin(),(v).rend()\n#define PB push_back\n#define ITR ::iterator\n\n\n#define MOD 1000000009LL\n#define EPS 1e-8\n\nvvint G;\nvint vis;\n\nvoid dfs(int v){\n\tif(vis[v] == 1){ throw v; }\n\tif(vis[v] == 0){\n\t\tvis[v] = 1;\n\t\tfor(int i = 0; i < G[v].size(); ++i){\n\t\t\tdfs(G[v][i]);\n\t\t}\n\t\tvis[v] = 2;\n\t}\n}\n\nint main(){\n\tint n, m, k, s, t;\n\tchar rel[8] = \"\";\n\tscanf(\"%d%d\", &n, &m);\n\tG.resize(n);\n\tvis.resize(n);\n\n\tvvint a, b;\n\tinitvv(a, n, m, 0);\n\tinitvv(b, n, m, 100);\n\n\tfor(int i = 0; i < n; ++i){\n\t\tscanf(\"%d\", &k);\n\t\tfor(int j = 0; j < k; ++j){\n\t\t\tscanf(\"%d %s %d\", &s, rel, &t);\n\t\t\t--s;\n\t\t\t\n\t\t\tif(rel[0] == '>'){\n\t\t\t\ta[i][s] = max(a[i][s], t);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tb[i][s] = min(b[i][s], t);\n\t\t\t}\n\t\t}\n\t}\n\n\tbool ok = false;\n\ttry{\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tfor(int k = 0; k < m; ++k){\n\t\t\t\tfor(int j = 0; j < n; ++j){\n\t\t\t\t\tif(b[i][k] < a[j][k]){\n\t\t\t\t\t\tG[i].push_back(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tdfs(i);\n\t\t}\n\t\t\n\t\tok = true;\n\t}catch(...){}\n\t\n\tputs(ok ? \"Yes\" : \"No\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 998244353;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-11;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\nint main() {\n\tvector<int> G[100];\n\tP need[100][100];\n\tint m, n; cin >> m >> n;\n\trep(i, m) {\n\t\trep(j, n) {\n\t\t\tneed[i][j] = { -1,101 };\n\t\t}\n\t}\n\tint s; string o; int c; int K;\n\trep(i, m) {\n\t\tcin >> K;\n\t\trep(j, K) {\n\t\t\tcin >> s >> o >> c; s--;\n\t\t\tif (o == \">=\") {\n\t\t\t\tneed[i][s].first = c;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tneed[i][s].second = c;\n\t\t\t}\n\t\t}\n\t}\n\tint used[100][100] = {};\n\trep(i, m) {\n\t\tRep(j,i, m) {\n\t\t\trep(k, n) {\n\t\t\t\tif (need[i][k].second < need[j][k].first&&!used[i][j]) {\n\t\t\t\t\tG[i].push_back(j); used[i][j] = 1;\n\t\t\t\t}\n\t\t\t\tif (need[j][k].second < need[i][k].first && !used[j][i]) {\n\t\t\t\t\tG[j].push_back(i); used[j][i] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tbool f = false;\n\trep(i, m) {\n\t\tint cyc[100] = {};\n\t\tqueue<int> q; q.push(i); cyc[i] = 1;\n\t\twhile (!q.empty()) {\n\t\t\tint now = q.front(); q.pop();\n\t\t\tint len = G[now].size();\n\t\t\trep(j, len) {\n\t\t\t\tint v = G[now][j];\n\t\t\t\tif (v == i)f = true;\n\t\t\t\tif (!cyc[v]) {\n\t\t\t\t\tcyc[v] = 1; q.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (f)cout << \"No\" << endl;\n\telse cout << \"Yes\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n\ntypedef struct Cond{\n  int kind;\n  int arrow;\n  int bound;\n}cond;\n\nbool sr(const cond& l, const cond& r){\n  return l.kind==r.kind ? l.arrow < r.arrow : l.kind < r.kind;\n}\n\nclass Graph{\npublic:\n  int v;\n  vector<int> visited,visiting;\n  vector<int> e[100];\n  Graph(int m){\n    v = m;\n    visited = vector<int>(v);\n    visiting = vector<int>(v);\n  }\n  void addEdge(int e1,int e2){\n    if (find(e[e1].begin(),e[e1].end(),e2)==e[e1].end()){\n      e[e1].push_back(e2);\n    }\n  }\n  int dfs(int vv){\n    int ret = 0;\n    visited[vv] = 1;\n    visiting[vv] = 1;\n    rep(i,e[vv].size()){\n      if(!visited[e[vv][i]]){\n        ret += dfs(e[vv][i]);\n      } else if (visiting[e[vv][i]]==1){\n        return 1;\n      }\n    }\n    visiting[vv] = 0;\n    return ret;\n  }\n\n  int isDAG(){\n    rep(i,v){\n      int m = dfs(i);\n      if (m>0){\n        return 1;\n      }\n    }\n    return 0;\n  }\n\n};\n\n\nint main(){\n\n  int m,n;\n  cin >> m >> n;\n  vector<int> k(m);\n  vector<cond> conditions[100];\n  pair<int,int> sections[100][100];\n\n  rep(i,m){\n    cin >> k[i];\n    conditions[i] = vector<cond>(k[i]);\n    rep(j,k[i]){\n      string c;\n      cin >> conditions[i][j].kind >> c >> conditions[i][j].bound;\n      conditions[i][j].kind--;\n      if (c==\">=\"){\n        conditions[i][j].arrow = 0;\n      } else {\n        conditions[i][j].arrow = 1;\n      }\n    }\n    sort(conditions[i].begin(),conditions[i].end(),sr);\n    //commandの条件内で矛盾を探す\n    rep(j,100){sections[i][j].first=0;sections[i][j].second=101;}\n    rep(j,conditions[i].size()){\n      int k = conditions[i][j].kind;\n      if (conditions[i][j].arrow == 0){\n        sections[i][k].first = max(sections[i][k].first,conditions[i][j].bound);\n      } else {\n        sections[i][k].second = min(sections[i][k].second,conditions[i][j].bound);\n      }\n    }\n    rep(j,n){\n      if(sections[i][j].first>sections[i][j].second){\n        cout << \"No\" << endl;\n        return 0;\n      }\n    }\n  }\n  //sections[i][j]: i番目のcommand,j番目のskillポイントがfirst以上second以下\n  //skillポイントを固定して条件を見ていって，区間に交わりがない場合は小→大へ辺を張る\n  Graph g(m);\n  rep(skill,n){\n    rep(com1,m){\n      rep(com2,m){\n        if (com1!=com2){\n          int com1l = sections[com1][skill].first;\n          int com1r = sections[com1][skill].second;\n          int com2l = sections[com2][skill].first;\n          int com2r = sections[com2][skill].second;\n          if (com2r < com1l){\n            g.addEdge(com2,com1);\n          } else if (com1r < com2l){\n            g.addEdge(com1,com2);\n          }\n        }\n      }\n    }\n  }\n  //閉路判定\n  int result = g.dfs(0);\n  if (result == 0){\n    cout << \"Yes\" << endl;\n  } else {\n    cout << \"No\" << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing PII = pair<ll, ll>;\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\ntemplate<typename T> void chmin(T &a, const T &b) { a = min(a, b); }\ntemplate<typename T> void chmax(T &a, const T &b) { a = max(a, b); }\nstruct FastIO {FastIO() { cin.tie(0); ios::sync_with_stdio(0); }}fastiofastio;\n#ifdef DEBUG_ \n#include \"../program_contest_library/memo/dump.hpp\"\n#else\n#define dump(...)\n#endif\nconst ll INF = 1LL<<60;\n\nint main(void) {\n    ll m, n;\n    cin >> m >> n;\n    vector<vector<ll>> lb(m, vector<ll>(n, -INF)), ub(m, vector<ll>(n, INF));\n    REP(i, m) {\n        ll k;\n        cin >> k;\n        REP(j, k) {\n            ll s, t;\n            string cond;\n            cin >> s >> cond >> t;\n            s--;\n\n            if(cond == \">=\") chmax(lb[i][s], t);\n            else chmin(ub[i][s], t);\n        }\n    }\n\n    REP(i, m) REP(j, n) {\n        if(lb[i][j] > ub[i][j]) {\n            cout << \"No\" << endl;\n            return 0;\n        }\n    }\n\n    vector<ll> deg(m);\n    vector<vector<ll>> g(m);\n    REP(i, m) REP(j, m) {\n        if(i == j) continue;\n        bool flag = true;\n        REP(k, n) if(lb[i][k] > ub[j][k]) flag = false;\n        if(flag) {\n            dump(i, j);\n            deg[i]++;\n            g[j].push_back(i);\n        }\n    }\n\n    ll need = m-1;\n    stack<ll> st;\n    vector<bool> del(m);\n    REP(i, m) if(deg[i] >= need) st.push(i);\n    while(st.size()) {\n        ll t = st.top(); st.pop();\n        if(del[t]) continue;\n        need--;\n        del[t] = true;\n        for(auto to: g[t]) {\n            deg[to]--;\n        }\n        REP(i, m) if(deg[i] >= need && !del[i]) st.push(i);\n    }\n\n    bool ret = true;\n    REP(i, m) if(!del[i]) ret = false;\n    if(ret) cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cout<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cout<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 1120000000\n#define long long long // for codeforces\n\nint num[105];\nvector<int> tree[105];\npair<int,int> range[105][105];\n\nbool dfs(int v){\n  num[v] = 1;\n  for(int to : tree[v]){\n    if(num[to]==-1){ if(!dfs(to)) return false; }\n    else if(num[to]==1) return false;\n  }\n  num[v]=0;\n  return true;\n}\n\nbool solve(){\n  int m,n;\n  cin>>m>>n;\n  rep(i,m){\n    int k;\n    cin>>k;\n    rep(j,n) range[i][j] = mp(0,101);\n    rep(j,k){\n      int s,t;\n      string str;\n      cin>>s>>str>>t;\n      s--;\n      if(str[0]=='>') range[i][s].fi = max(range[i][s].fi, t);\n      else range[i][s].se = min(range[i][s].se, t+1);\n    }\n    rep(j,n) if(range[i][j].se - range[i][j].fi <= 0) return false;\n  }\n\n  rep(i,m) rep(j,i){\n    rep(k,n){\n      if(range[i][k].se <= range[j][k].fi) tree[i].pb(j);\n      if(range[j][k].se <= range[i][k].fi) tree[j].pb(i);\n    }\n  }\n\n  fill(num, num+m, -1);\n\n  rep(i,m) if(num[i]==-1){\n    if(!dfs(i)) return false;\n  }\n\n  return true;\n}\n\nint main(){\n  if(solve()) cout << \"Yes\" << endl;\n  else cout << \"No\" << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define SZ(x) (int)(x.size())\n#define REP(i, n) for(int i=0;i<(n);++i)\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RREP(i, n) for(int i=(int)(n)-1;i>=0;--i)\n#define RFOR(i, a, b) for(int i=(int)(b)-1;i>=(a);--i)\n#define ALL(a) a.begin(),a.end()\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define DEBUG(x) cerr<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<< endl;\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing P = pair<int, int>;\nconst double eps = 1e-8;\nconst ll MOD = 1000000007;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\ntemplate <typename T1, typename T2>\nbool chmax(T1 &a, const T2 &b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate <typename T1, typename T2>\nbool chmin(T1 &a, const T2 &b) {\n    if (a > b) { a = b; return true; }\n    return false;\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2> &p) {\n    os << p.first << \":\" << p.second;\n    return os;\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const map<T1, T2> &mp) {\n    os << \"{\";\n    int a = 0;\n    for (auto &tp : mp) {\n        if (a) os << \", \"; a = 1;\n        os << tp;\n    }\n    return os << \"}\";\n}\ntemplate<typename T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n    os << \"[\";\n    REP(i, SZ(v)) {\n        if (i) os << \", \";\n        os << v[i];\n    }\n    return os << \"]\";\n}\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    int M, N; cin >> M >> N;\n    vector<vector<pair<int,int>>> condLess(N), condGreater(N);\n    REP(i, M) {\n        int K; cin >> K;\n        REP(j, K) {\n            int s, t; string cond;\n            cin >> s >> cond >> t; --s;\n            if (cond == \"<=\") condLess[s].emplace_back(i, t);\n            else condGreater[s].emplace_back(i, t);\n        }\n    }\n    vvi graph(M);\n    REP(i, N) {\n        for (auto &a : condGreater[i]) {\n            for (auto &b : condLess[i]) {\n                if (a.second > b.second) {\n                    graph[b.first].push_back(a.first);\n                }\n            }\n        }\n    }\n\n    vi deg(M);\n    REP(i, M) {\n        for (int u : graph[i]) ++deg[u];\n    }\n    queue<int> que;\n    REP(i, M) if (deg[i] == 0) que.push(i);\n    vi used(M);\n\n    while (!que.empty()) {\n        int v = que.front(); que.pop();\n        used[v] = 1;\n        for (int u : graph[v]) {\n            if (--deg[u] == 0) que.push(u);\n        }\n    }\n    cout << (accumulate(ALL(used), 0) == M ? \"Yes\" : \"No\") << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nint main()\n{\n\tint m, n;\n\tcin >> m >> n;\n\tvector<vi> graph(m, vi(m));\n\tvector<vector<pii>> v(m, vector<pii>(n, pii(0, INF)));\n\tREP(i, m)\n\t{\n\t\tint k; cin >> k;\n\t\tREP(j, k)\n\t\t{\n\t\t\tint s, t; string con;\n\t\t\tcin >> s >> con >> t;\n\t\t\ts--;\n\t\t\tif (con == \"<=\") chmin(v[i][s].second, t);\n\t\t\telse chmax(v[i][s].first, t);\n\t\t}\n\t}\n\tbool ans = false;\n\tbool ff = true;\n\tREP(i, m)REP(j, n)\n\t{\n\t\tif (v[i][j].first > v[i][j].second) ff = false;\n\t}\n\tif (ff)\n\t{\n\t\tREP(i, m)REP(j, m)\n\t\t{\n\t\t\tif (i == j) continue;\n\t\t\tbool f = true;\n\t\t\tREP(k, n)\n\t\t\t{\n\t\t\t\tif (v[i][k].second < v[j][k].first) f = false;\n\t\t\t}\n\t\t\tif (f) graph[j][i] = 1;\n\t\t}\n\n\t\tset<int> st;\n\t\tREP(j, m) st.insert(j);\n\t\twhile (st.size())\n\t\t{\n\t\t\tbool up = false;\n\t\t\tfor (auto j : st)\n\t\t\t{\n\t\t\t\tbool f = true;\n\t\t\t\tfor (auto k : st)\n\t\t\t\t{\n\t\t\t\t\tif (j == k) continue;\n\t\t\t\t\tif (graph[j][k] == 0) f = false;\n\t\t\t\t}\n\t\t\t\tif (f)\n\t\t\t\t{\n\t\t\t\t\tst.erase(j);\n\t\t\t\t\tup = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!up) break;\n\t\t}\n\t\tif (st.size() == 0) ans = true;\n\t}\n\tputs(ans ? \"Yes\" : \"No\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define LINF (ll)INF*INF\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define loop(i,a,n) for(int i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\n#define int ll //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vp;\n\nint gcd(int a, int b){\n    if(b==0) return a;\n    return gcd(b,a%b);\n}\nint lcm(int a, int b){\n    return a/gcd(a,b)*b;\n}\n\nvector<vi> g;\nbool ans = true;\nvi used;\nvoid dfs(int now,int t){\n    rep(i,g[now].size()){\n        if(g[now][i] == t)ans = false;\n        if(used[g[now][i]])return;\n        used[now]++;\n        dfs(g[now][i],t);\n    }\n}\n\nsigned main(void) {\n    int m,n;\n    cin >> m >> n;\n    vector<vp> v(m);\n    bool c = true;\n    rep(i,m){\n        int k;\n        cin >> k;\n        vp in(n,pii(-1,-1));\n        rep(j,k){\n            int a,b;\n            string s;\n            cin >> a >> s >> b;\n            a--;\n            if(s == \">=\"){//first\n                if(in[a].first == -1) in[a].first = b;\n                else in[a].first = max(in[a].first, b);\n            }else{//second\n                if(in[a].second == -1) in[a].second = b;\n                else in[a].second = min(in[a].second, b);\n            }\n        }\n        rep(j,n){\n            int l = in[j].first, r = in[j].second;\n            if(l != -1 && r != -1 && l > r){\n                c = false;\n                break;\n            }\n        }\n        v[i] = in;\n    }\n\n    if(c == false){\n        cout << \"No\" << endl;\n        return 0;\n    }\n\n    g = vector<vi>(m);\n    rep(i,m)rep(j,m)if(i != j){// i -> j ?\n        int c = 0;\n        rep(k,n){\n            if(v[j][k].second != -1 && v[i][k].first != -1 && v[j][k].second < v[i][k].first){\n                if(c == 1) ans = false;\n                else c = -1;\n            }\n            if(v[i][k].second != -1 && v[j][k].first != -1 && v[i][k].second < v[j][k].first){\n                if(c == -1)ans = false;\n                else c = 1;\n            }\n        }\n        //cout << i << \" \" << j << \" \" << c << \" \" << ans << endl;\n        if(c == 1)g[i].push_back(j);//,cout << i << \" \" << j << endl;\n    }\n    //グラフの閉路検出\n    rep(i,m)if(ans){\n        used = vi(m,0);\n        used[i]++;\n        dfs(i,i);\n    }\n\n    if(ans){\n        cout << \"Yes\" << endl;\n    }else{\n        cout << \"No\" << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nstruct skill{\n    int max,min;\n    skill(){\n        max=100;\n        min=1;\n    }\n};\n\ntypedef vector<int> V;\nvector<V> G(100);\nbool used[100];\n\nvoid rec(int v){\n    if(used[v]){\n        cout<<\"No\"<<endl;\n        exit(0);\n    }\n    used[v]=true;\n    for(auto& e:G[v]){\n        rec(e);\n    }\n    return;\n}\n\nint main(){\n    int M,N;\n    cin>>M>>N;\n    skill S[100][100];\n    for(int i=0;i<M;i++){\n        int K;\n        cin>>K;\n        for(int j=0;j<K;j++){\n            int s,t;\n            string cond;\n            cin>>s>>cond>>t;\n            s--;\n            if(cond==\"<=\"){//SP<=t\n                if(t<S[i][s].min){\n                    cout<<\"No\"<<endl;\n                    return 0;\n                }else if(t<S[i][s].max){\n                    S[i][s].max=t;\n                }\n            }else{//t<=SP\n                if(t>S[i][s].max){\n                    cout<<\"No\"<<endl;\n                    return 0;\n                }else if(t>S[i][s].min){\n                    S[i][s].min=t;\n                }\n            }\n        }\n    }\n    for(int i=0;i<M;i++){\n        for(int j=i+1;j<M;j++){\n            int i_over_j=0;\n            for(int k=0;k<N;k++){\n                if(S[i][k].min>S[j][k].max){\n                    if(i_over_j==-1){\n                        cout<<\"No\"<<endl;\n                        return 0;\n                    }else{\n                        i_over_j=1;\n                    }\n                }\n                if(S[i][k].max<S[j][k].min){\n                    if(i_over_j==1){\n                        cout<<\"No\"<<endl;\n                        return 0;\n                    }else{\n                        i_over_j=-1;\n                    }\n                }\n            }\n            if(i_over_j==1){\n                G[i].push_back(j);\n            }\n            if(i_over_j==-1){\n                G[j].push_back(i);\n            }\n        }\n    }\n    for(int i=0;i<M;i++){\n        fill(used,used+100,false);\n        rec(i);\n    }\n    cout<<\"Yes\"<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <set>\n#include <cstdio>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <ctime>\n#include <algorithm>\n#include <tuple>\n#include <algorithm>\n#include <limits>\n#include <map>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\nconst int MN = 110;\nint V;\nvector<int> G[MN];\nvector<int> rG[MN];\nvector<int> vs;\nbool used[MN];\nint cmp[MN];\n\nvoid add_edge(int from, int to) {\n    G[from].push_back(to);\n    rG[to].push_back(from);\n}\n\nvoid dfs(int v) {\n    used[v] = true;\n    for(int i=0;i<G[v].size();i++) {\n        if(!used[G[v][i]]) dfs(G[v][i]);\n    }\n    vs.push_back(v);\n}\n\nvoid rdfs(int v, int k) {\n    used[v] = true;\n    cmp[v] = k;\n    for(int i=0;i<rG[v].size();i++) {\n        if (!used[rG[v][i]]) rdfs(rG[v][i], k);\n    }\n}\n\nint scc() {\n    memset(used, 0, sizeof(used));\n    vs.clear();\n    for(int v=0;v<V;v++) {\n        if (!used[v]) dfs(v);\n    }\n    memset(used, 0, sizeof(used));\n    int k = 0;\n    for(int i=vs.size() - 1; i >= 0; i--) {\n        if (!used[vs[i]]) rdfs(vs[i], k++);\n    }\n    return k;\n}\nint m;\nint g[MN][MN];\nbool solve() {\n    for (int i = 0; i < m; i++) {\n        if (g[i][i]) return false;\n    }\n    V = m;\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < m; j++) {\n            if (g[i][j]) add_edge(i, j);\n        }\n    }\n    scc();\n    int c[MN] = {};\n    for (int i = 0; i < m; i++) {\n        c[cmp[i]]++;\n    }\n    for (int i = 0; i < MN; i++) {\n        if (c[i] > 1) return false;\n    }\n    return true;\n}\n\nint main() {\n    int n;\n    int s[MN][MN][2];\n    for (int i = 0; i < MN; i++) {\n        for (int j = 0; j < MN; j++) {\n            s[i][j][0] = 0;\n            s[i][j][1] = 1000;\n        }\n    }\n    cin >> m >> n;\n    for (int i = 0; i < m; i++) {\n        int k;\n        cin >> k;\n        for (int j = 0; j < k; j++) {\n            int a, b;\n            char c;\n            scanf(\"%d %c= %d\", &a, &c, &b);\n            s[i][a][(c == '<') ? 1 : 0] = b;\n        }\n    }\n    for (int i = 0; i < m; i++) {\n        for (int j = 0; j < m; j++) {\n            bool f = false;\n            for (int k = 0; k < MN; k++) {\n                if (s[i][k][0] > s[j][k][1]) {\n                    f = true;\n                }\n            }\n            g[i][j] = f ? 1 : 0;\n        }\n    }\n    if (solve()) {\n        printf(\"Yes\\n\");\n    } else {\n        printf(\"No\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#define r(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n#define F first\n#define S second\ntypedef pair<int,int>P;\nint n,m,x,y,K,a[102][102],flag,amin[102],amax[102];\nstring s;\nvector<P>v1[102],v2[102];\nbool ch(){\n  r(i,m){\n    r(j,v1[i].size()){\n      r(k,v2[i].size()){\n\tif(v1[i][j].S<v2[i][k].S) return 1;\n      }\n    }\n  }\n  return 0;\n}\nvoid make_Graph(){\n  r(i,102)amax[i]=1e8;\n  r(i,m){\n    r(j,v1[i].size())amax[i]=min(amax[i],v1[i][j].S);\n    r(j,v2[i].size())amin[i]=max(amin[i],v2[i][j].S);\n    amin[i]=min(amin[i],amax[i]);\n  }\n  r(i,m)r(j,m)if(amax[i]<amin[j])a[i][j]=-1;\n}\nint main(){\n  cin>>m>>n;\n  r(i,m){\n    cin>>K;\n    r(j,K){\n      cin>>x>>s>>y;\n      if(s==\"<=\")v1[i].push_back(P(x,y));\n      else v2[i].push_back(P(x,y));\n    }\n  }\n  if(ch())cout<<\"No\"<<endl;\n  else{\n    r(i,102)r(j,102)a[i][j]==(i==j?0:100);\n    make_Graph();\n    n++;\n    r(o,m)r(i,m)r(j,m)a[i][m]=min(a[i][j],a[i][o]+a[o][j]);\n    r(i,102)if(a[i][i]<0)flag++;\n    cout<<(flag?\"No\":\"Yes\")<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nconst int My_Inf=2147483647;\nconst long long int My_LInf=9223372036854775807;\n\nint M;\n\nvoid dfs(vector<bool>&transs, const int now,const vector<vector<bool>>&edges) {\n\ttranss[now] = true;\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (edges[now][i] && !transs[i]) {\n\t\t\tdfs(transs, i, edges);\n\t\t}\n\t}\n\treturn;\n}\n\nint main() {\n\tint  N; cin >> M >> N;\n\tvector<vector<vector<pair<bool, int>>>>conds(M, vector<vector<pair<bool, int>>>(N, vector<pair<bool, int>>(2, make_pair(false, 0))));\n\tfor (int i = 0; i < M; ++i) {\n\t\tint K; cin >> K;\n\t\tfor (int j = 0; j < K; ++j) {\n\t\t\tint s, t; string st; cin >> s >> st >> t;\n\t\t\ts--; \n\t\t\tbool ku = (st == \"<=\");\n\t\t\tif (!conds[i][s][ku].first) {\n\t\t\t\tconds[i][s][ku].first = true;\n\t\t\t\tconds[i][s][ku].second = t;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (ku) {\n\t\t\t\t\tconds[i][s][ku].second = min(conds[i][s][ku].second, t);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tconds[i][s][ku].second = max(conds[i][s][ku].second, t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tbool aaok = true;\n\tfor (int i = 0; i < M; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tif (conds[i][j][0].first&&conds[i][j][1].first) {\n\t\t\t\tif (conds[i][j][0].second>conds[i][j][1].second)aaok = false;\n\t\t\t}\n\t\t}\n\t}\n\tif (aaok) {\n\t\tvector<vector<bool>>edges(M, vector<bool>(M));\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tfor (int j = 0; j < M; ++j) {\n\t\t\t\tbool ok = true;\n\t\t\t\tfor (int k = 0; k < N; ++k) {\n\t\t\t\t\tif (conds[i][k][0].first&&conds[j][k][1].first) {\n\t\t\t\t\t\tif (conds[i][k][0].second>conds[j][k][1].second)ok = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tedges[i][j] = ok;\n\t\t\t}\n\t\t}\n\t\tbool aok = false;\n\t\tfor (int from = 0; from < M; ++from) {\n\t\t\tvector<bool>transs(M);\n\t\t\tdfs(transs, from, edges);\n\t\t\tif (all_of(transs.begin(), transs.end(), [](const bool b) {return b; })) {\n\t\t\t\taok = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (aok) {\n\t\t\tcout << \"Yes\" << endl;\n\n\t\t}\n\t\telse {\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\t\treturn 0;\n\t}\n\tcout << \"No\" << endl;\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\nint M,N;\n\nstruct state{\n  int k;\n  int maxi[101],mini[101];\n  void init(){\n    for(int j=1;j<=N;j++){\n      maxi[j] = 100;\n      mini[j] = 0;\n    }\n  }\n  bool check(){\n    for(int i=1;i<=N;i++){\n      if( maxi[i] < mini[i] ) return false;\n    }\n    return true;\n  }\n};\n\nstate S[101];\n\nbool check(const state &s1, const state &s2){\n  for(int i=1;i<=N;i++){\n    if( s1.mini[i] > s2.maxi[i] ) return false;\n  }\n  return true;\n}\n\nvector<int> G[101];\nint nG[101];\n\n\n\nint main(){\n  cin >> M >> N;\n  bool f = true;\n  for(int i=0;i<M;i++){\n    S[i].init();\n    cin >> S[i].k;\n    for(int j=0;j<S[i].k;j++){\n      int s,t;string c;\n      cin >> s >> c >> t;\n      if( c == \"<=\" ){\n        S[i].maxi[s] = t;\n      } else {\n        S[i].mini[s] = t;\n      }\n    }\n    if( !S[i].check() ) f = false;\n  }\n\n  if( !f ) {\n    cout << \"No\" << endl;\n    return 0;\n  }\n\n  for(int i=0;i<M;i++){\n    for(int j=0;j<M;j++){\n      if( i == j ) continue;\n      if( check(S[i],S[j]) )\n        G[i].push_back( j );\n    }\n  }\n\n  //kokomade_\n\n  for(int i=0;i<M;i++) nG[i] = G[i].size();\n  int T = M-1;\n  bool used[111]={};\n  while( T ){\n    vector<P> pr;\n    for(int i=0;i<M;i++){\n      if(!used[i]) pr.push_back( P(nG[i],i) );    \n    }\n    sort(pr.begin(),pr.end());\n    \n    if( pr.back().first >= T ){\n      pr.clear();\n      used[pr.back().second] = true;\n      for(int i=0;i<M;i++){\n        for(int j=0;j<(int)G[i].size();j++){\n          int to = G[i][j];\n          if( to == pr.back().second ) {\n            nG[i]--;\n          }\n        }\n      }\n    } else {\n      f = false;\n      break;\n    }\n    --T;\n  }\n  if( f ) cout << \"Yes\" << endl;\n  else cout << \"No\" << endl;\n\n  \n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing pii = pair<int, int>;\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint M, N;\n\tcin >> M >> N;\n\tbool ok = true;\n\tvector<vector<pii>> ran(M, vector<pii>(N, pii(0, 100)));\n\tfor (int i = 0; i < M; i++) {\n\t\tint K;\n\t\tcin >> K;\n\t\tfor (int j = 0; j < K; j++) {\n\t\t\tint s, t;\n\t\t\tstring cond;\n\t\t\tcin >> s >> cond >> t; --s;\n\t\t\tif (cond == \"<=\") {\n\t\t\t\tran[i][s].second = min(ran[i][s].second, t);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tran[i][s].first = max(ran[i][s].first, t);\n\t\t\t}\n\t\t}\n\t}\n\tvector<vector<int>> d(M, vector<int>(M, 1e9));\n\tfor (int i = 0; i < M; i++) {\n\t\tfor (int j = 0; j < M; j++) {\n\t\t\tbool flag = false;\n\t\t\tfor (int k = 0; k < N; k++) {\n\t\t\t\tif (ran[i][k].second < ran[j][k].first) {\n\t\t\t\t\tflag = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag) {\n\t\t\t\td[i][j] = -1;\n\t\t\t}\n\t\t}\n\t}\n\tfor (int k = 0; k < M; k++) {\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tfor (int j = 0; j < M; j++) {\n\t\t\t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i < M; i++) {\n\t\tif (d[i][i] < 0) {\n\t\t\tok = false;\n\t\t}\n\t}\n\tputs(ok ? \"Yes\" : \"No\");\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<iomanip>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<queue>\n\nusing namespace std;\n\n#define int long long\n#define rep(i,n) for(int i = 0; i < (n); i++)\n#define INF ((long long)1e18)\n#define MOD ((int)1e9+7)\n#define endl \"\\n\"\n\n#define yn(f) ((f)?\"Yes\":\"No\")\n#define YN(f) ((f)?\"YES\":\"NO\")\n\n#define MAX 110\n\nint M, N;\nint K, sp[MAX], con;\nbool can[MAX];\nvector<vector<int>> llim(MAX,vector<int>(MAX,0));\npriority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> ulim[MAX];\n\nbool check(int n){\n\tif(can[n]) return false;\n\t\n\tfor(int i = 1; i <= N; i++){\n\t\tif(llim[n][i] > sp[i]) return false;\n\t}\n\t\n\tcan[n] = true;\n\tcon++;\n\t\n\treturn true;\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout<<fixed<<setprecision(10);\n\t\n\tint s, t;\n\tstring cond;\n\t\n\tcin>>M>>N;\n\t\n\tfor(int i = 1; i <= M; i++){\n\t\tcin>>K;\n\t\tfor(int j = 1; j <= K; j++){\n\t\t\tcin>>s>>cond>>t;\n\t\t\tif(cond == \">=\"){\n\t\t\t\tllim[i][s] = max(llim[i][s], t);\n\t\t\t} else if(cond == \"<=\"){\n\t\t\t\tulim[s].push(make_pair(t,i));\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t}\n\tfor(int i = 1; i <= N; i++){\n\t\tulim[i].push(make_pair(INF,0));\n\t}\n\t\n\twhile(true){\n\t\t// cout<<\"WHIEL \"<<endl;\n\t\tbool flag = false;\n\t\t\n\t\tfor(int i = 1; i <= N; i++){\n\t\t\twhile(!ulim[i].empty()){\n\t\t\t\tpair<int,int> p = ulim[i].top();\n\t\t\t\tif(can[p.second] == false){\n\t\t\t\t\tsp[i] = p.first;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tulim[i].pop();\n\t\t\t}\n\t\t\t// cout<<i<<\" \"<<sp[i]<<endl;\n\t\t}\n\t\t\n\t\tfor(int i = 1; i <= M; i++){\n\t\t\tif(check(i)) flag = true;\n\t\t}\n\t\t\n\t\t// cout<<\"con -> \"<<con<<endl;\n\t\tif(con == M)break;\n\t\t\n\t\tif(!flag){\n\t\t\tcout<<\"No\"<<endl;\n\t\t\treturn 0;\n\t\t}\n\t\n\t}\n\t\n\tcout<<\"Yes\"<<endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = uint32_t;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\nint main() {\n    int m, n;\n    cin >> m >> n;\n    vector<vector<pair<int, int>>> upper(n), lower(n);\n    for (int i = 0; i < m; ++i) {\n        int k;\n        cin >> k;\n        for (int j = 0; j < k; ++j) {\n            int a, b; string s;\n            cin >> a >> s >> b;\n            a--;\n            if(s == \">=\") lower[a].emplace_back(b, i);\n            else upper[a].emplace_back(b, i);\n        }\n    }\n    vector<vector<int>> G(m);\n    vector<int> in(m);\n    for (int i = 0; i < n; ++i) {\n        for (auto &&j : upper[i]) {\n            for (auto &&k : lower[i]) {\n                if(j.first < k.first){\n                    G[j.second].emplace_back(k.second);\n                    in[k.second]++;\n                }\n            }\n        }\n    }\n    queue<int> q;\n    for (int i = 0; i < m; ++i) {\n        if(!in[i]) q.emplace(i);\n    }\n    while(!q.empty()){\n        int i = q.front(); q.pop();\n        for (auto &&j : G[i]) {\n            in[j]--;\n            if(!in[j]) q.emplace(j);\n        }\n        G[i].clear();\n    }\n    for (int i = 0; i < m; ++i) {\n        if(in[i]) {\n            puts(\"No\");\n            return 0;\n        }\n    }\n    puts(\"Yes\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n\nclass Requirement{\npublic:\n  int upper;\n  int lower;\n  Requirement() : upper(INF),lower(0) {}\n  Requirement(int _u,int _l) : upper(_u),lower(_l) {}\n};\n\nint total_commands;\nint total_skills;\n\nbool check_path(int from_command,int to_command,\n\t\tRequirement requirement[101][101]){\n  for(int skill_id = 1; skill_id <= total_skills;skill_id++){\n    if(requirement[from_command][skill_id].lower\n       > requirement[to_command][skill_id].upper){\n      return false;\n    }\n    if(requirement[from_command][skill_id].upper\n       < requirement[to_command][skill_id].lower){\n      return false;\n    }\n  }\n  return true;\n}\n\nint main(){\n  while(~scanf(\"%d %d\",&total_commands,&total_skills)){\n    Requirement requirement[101][101];    \n    for(int command_idx = 0; command_idx < total_commands; command_idx++){\n      int total_conditions;\n      scanf(\"%d\",&total_conditions);\n      for(int condition_idx = 0; condition_idx < total_conditions; condition_idx++){\n\tint skill_id;\n\tstring symbol;\n\tint required_point;\n\tcin >> skill_id >> symbol >> required_point;\n\tif(symbol == \">=\") {\n\t  requirement[command_idx][skill_id].lower\n\t    = max(required_point,requirement[command_idx][skill_id].lower);\n\t}\n\telse if(symbol == \"<=\"){\n\t  requirement[command_idx][skill_id].upper\n\t    = min(required_point,requirement[command_idx][skill_id].lower);\n\t}\n      }\n    }\n\n    \n    bool edge[total_commands][total_commands];\n    //init\n    for(int from = 0; from < total_commands; from++){\n      for(int to = 0; to < total_commands; to++){\n\tedge[from][to] = check_path(from,to,requirement);\n      }\n    }\n\n    bool isok = false;\n    bool used[total_commands];\n    fill(used,used+total_commands,false);\n\n    int count = 0;\n    for(int round = 0;round < total_commands;round++){\n      for(int from = 0;from < total_commands;from++){\n\tfor(int to = 0; to < total_commands; to++){\n\t  if(edge[from][to] && !used[from]){\n\t    used[from] = true;\n\t    count++;\n\t    goto next;\n\t  }\n\t}\n      }\n    next:;\n    }\n    \n    if(count == total_commands){\n      isok = true;\n    }\n\n    printf(\"%s\\n\",isok ? \"Yes\" : \"No\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n) { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x) { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\n\nint main() {\n\tint m, n;\n\tcin >> m >> n;\n\tvector<vector<pair<int, int>>> skills(m, vector<pair<int, int>>(n, pair<int, int>(0, 100)));\n\tREP(i, m) {\n\t\tint a;\n\t\tcin >> a;\n\t\tREP(j, a) {\n\t\t\tint b;\n\t\t\tstring c;\n\t\t\tint d;\n\t\t\tcin >> b >> c >> d;\n\t\t\tb--;\n\t\t\tif (c == \"<=\") {\n\t\t\t\tskills[i][b] = { skills[i][b].first,min(skills[i][b].second,d) };\n\t\t\t}\n\t\t\telse {\n\t\t\t\tskills[i][b] = { max(skills[i][b].first,d),skills[i][b].second };\n\t\t\t}\n\t\t}\n\t}\n\tvi point(n, 100);\n\tvb get(m, false);\n\tbool change = false;\n\n\tdo {\n\t\tREP(i, n)\n\t\t\tpoint[i] = 100;\n\t\tchange = false;\n\t\tREP(i, m) {\n\t\t\tif (!get[i]) {\n\t\t\t\tREP(j, n) {\n\t\t\t\t\tpoint[j] = min(point[j], skills[i][j].second);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tREP(i, m) {\n\t\t\tif (!get[i]) {\n\t\t\t\tbool clear = true;\n\t\t\t\tREP(j, n) {\n\t\t\t\t\tif (skills[i][j].first <= point[j] && point[j] <= skills[i][j].second) {\n\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tclear = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (clear) {\n\t\t\t\t\tget[i] = true;\n\t\t\t\t\tchange = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} while (change);\n\tstring ans = \"Yes\";\n\tREP(i, m)\n\t\tif (!get[i]) {\n\t\t\tans = \"No\";\n\t\t\tbreak;\n\t\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 998244353;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-11;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\nint main() {\n\tvector<int> G[100];\n\tP need[100][100];\n\tint m, n; cin >> m >> n;\n\trep(i, m) {\n\t\trep(j, n) {\n\t\t\tneed[i][j] = { -1,101 };\n\t\t}\n\t}\n\tint s; string o; int c; int K;\n\trep(i, m) {\n\t\tcin >> K;\n\t\trep(j, K) {\n\t\t\tcin >> s >> o >> c; s--;\n\t\t\tif (o == \">=\") {\n\t\t\t\tneed[i][s].first = max(need[i][s].first, c);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tneed[i][s].second = min(need[i][s].second, c);\n\t\t\t}\n\t\t}\n\t}\n\tint used[100][100] = {};\n\trep(i, m) {\n\t\tRep(j,i, m) {\n\t\t\trep(k, n) {\n\t\t\t\tif (need[i][k].second < need[j][k].first&&!used[i][j]) {\n\t\t\t\t\tG[i].push_back(j); used[i][j] = 1;\n\t\t\t\t}\n\t\t\t\tif (need[j][k].second < need[i][k].first && !used[j][i]) {\n\t\t\t\t\tG[j].push_back(i); used[j][i] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tbool f = false;\n\trep(i, m) {\n\t\tint cyc[100] = {};\n\t\tqueue<int> q; q.push(i); cyc[i] = 1;\n\t\twhile (!q.empty()) {\n\t\t\tint now = q.front(); q.pop();\n\t\t\tint len = G[now].size();\n\t\t\trep(j, len) {\n\t\t\t\tint v = G[now][j];\n\t\t\t\tif (v == i)f = true;\n\t\t\t\tif (!cyc[v]) {\n\t\t\t\t\tcyc[v] = 1; q.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (f)cout << \"No\" << endl;\n\telse cout << \"Yes\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n\nclass Requirement{\npublic:\n  int upper;\n  int lower;\n  Requirement() : upper(INF),lower(0) {}\n  Requirement(int _u,int _l) : upper(_u),lower(_l) {}\n};\n\nint total_commands;\nint total_skills;\n\nbool check_path(int from_command,int to_command,\n\t\tRequirement requirement[101][101]){\n  for(int skill_id = 1; skill_id <= total_skills;skill_id++){\n    if(requirement[from_command][skill_id].lower\n       > requirement[to_command][skill_id].upper){\n      return false;\n    }\n    // if(requirement[from_command][skill_id].upper\n    //    < requirement[to_command][skill_id].lower){\n    //   return false;\n    // }\n  }\n  return true;\n}\n\nint main(){\n  while(~scanf(\"%d %d\",&total_commands,&total_skills)){\n    Requirement requirement[101][101];\n\n    bool skill_flag = true;\n    for(int command_idx = 0; command_idx < total_commands; command_idx++){\n      int total_conditions;\n      scanf(\"%d\",&total_conditions);\n      for(int condition_idx = 0; condition_idx < total_conditions; condition_idx++){\n\tint skill_id;\n\tstring symbol;\n\tint required_point;\n\tcin >> skill_id >> symbol >> required_point;\n\tif(symbol == \">=\") {\n\t  requirement[command_idx][skill_id].lower\n\t    = max(required_point,requirement[command_idx][skill_id].lower);\n\t}\n\telse if(symbol == \"<=\"){\n\t  requirement[command_idx][skill_id].upper\n\t    = min(required_point,requirement[command_idx][skill_id].lower);\n\t}\n\t\n\tif(requirement[command_idx][skill_id].lower\n\t   > requirement[command_idx][skill_id].upper){\n\t  skill_flag = false;\n\t}\n      }\n    }\n\n    \n    bool edge[total_commands][total_commands];\n    //init\n    for(int from = 0; from < total_commands; from++){\n      for(int to = 0; to < total_commands; to++){\n\tedge[from][to] = check_path(from,to,requirement);\n      }\n    }\n\n    bool isok = false;\n    bool used[total_commands];\n    fill(used,used+total_commands,false);\n\n    int count = 0;\n    for(int round = 0;round < total_commands;round++){\n      for(int from = 0;from < total_commands;from++){\n\tif(used[from]) continue;\n\n\tbool flag = true;\n\tfor(int to = 0; to < total_commands; to++){\n\t  if(!edge[from][to] && !used[to]){\n\t    flag = false;\n\t  }\n\t}\n\n\tif(flag){\n\t  used[from] = true;\n\t  count++;\n\t  break;\n\t}\n      }\n    }\n    \n    if(count == total_commands){\n      isok = true;\n    }\n\n    printf(\"%s\\n\",(isok && skill_flag) ? \"Yes\" : \"No\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n\nusing namespace std;\n\nint dfs(vector< vector<int> > &G, vector<bool> &visited, int s){\n  int ret = 0;\n  for(int i = 0; i < G[s].size(); ++i){\n    if(visited[G[s][i]]) continue;\n    visited[G[s][i]] = true;\n    ret = max(ret, dfs(G, visited, G[s][i]) + 1);\n    visited[G[s][i]] = false;\n  }\n  return ret;\n}\n\nint main(){\n  int M, N;\n  cin >> M >> N;\n  vector< vector< pair<int, int> > > V(M, vector< pair<int,int> >(N,pair<int,int>(1,100)));\n  for(int i = 0; i < M; ++i){\n    int K;\n    cin >> K;\n    for(int j = 0; j < K; ++j){\n      int s, t;\n      string c;\n      cin >> s >> c >> t;\n      --s;\n      if(c == \">=\"){\n        if(V[i][s].second < t){\n          cout << \"No\" << endl;\n          return 0;\n        }\n        V[i][s].first = max(t, V[i][s].first);\n      }else{\n        if(V[i][s].first > t){\n          cout << \"No\" << endl;\n          return 0;\n        }\n        V[i][s].second = min(t, V[i][s].second);\n      }\n    }\n  }\n  vector< vector<bool> > G(M, vector<bool>(M,false));\n  for(int i = 0; i < M; ++i){\n    for(int j = 0; j < M; ++j){\n      bool f = true;\n      for(int k = 0; k < N; ++k){\n        if(V[i][k].first > V[j][k].second){\n          f = false;\n          break;\n        }\n      }\n      G[i][j] = f;\n    }\n  }\n  /*\n  int l = 0;\n  vector<bool> visited(M, false);\n  for(int i = 0; i < M; ++i){\n    visited[i] = true;\n    l = max(l, dfs(G, visited, i));\n    visited[i] = false;\n  }\n  if(l == M - 1) cout << \"Yes\" << endl;\n  else cout << \"No\" << endl;\n  */\n  vector<int> D(M,0);\n  for(int i = 0; i < M; ++i){\n    bool f = true;\n    for(int j = 0; j < M; ++j){\n      int d = M - i;\n      for(int k = 0; k < M; ++k){\n        d -= G[j][k];\n      }\n      if(!d){\n        f = false;\n        for(int k = 0; k < M; ++k){\n          G[j][k] = false;\n          G[k][j] = false;\n        }\n        break;\n      }\n    }\n    if(f){\n      cout << \"No\" << endl;\n      return 0;\n    }\n  }\n  cout << \"Yes\" << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct Restrict{\n    int v;\n    int idx;\n    int t;\n    bool isLess;\n};\n\nbool l_to_r(Restrict lhs,Restrict rhs){\n    return lhs.idx==rhs.idx &&\n            lhs.isLess && !rhs.isLess  &&\n            lhs.t<rhs.t;\n}\n\nusing Graph=vector<vector<int>>;\n\nbool isDAG(Graph &g){\n    int n=g.size();\n    vector<int> d(n);\n    for(int i=0;i<n;i++)for(int j=0;j<g[i].size();j++) d[g[i][j]]++;\n    queue<int> que;\n    for(int i=0;i<n;i++) if(d[i]==0) que.push(i);\n    int cnt=0;\n    while(!que.empty()){\n        int v=que.front(); que.pop();\n        cnt++;\n        for(int i=0;i<g[v].size();i++){\n            d[g[v][i]]--;\n            if(d[g[v][i]]==0){\n                que.push(g[v][i]);\n            }\n        }\n    }\n    return cnt==n;\n}\nint main(){\n    int n,m;\n    cin>>n>>m;\n    vector<Restrict> rvec;\n    for(int i=0;i<n;i++){\n        int k;\n        cin>>k;\n        for(int j=0;j<k;j++){\n            int s,t;\n            string cond;\n            cin>>s>>cond>>t;\n            s--;\n            bool isLess=(cond==\"<=\");\n            rvec.push_back(Restrict{i,s,t,isLess});\n        }\n    }\n    Graph g(n);\n    for(int i=0;i<rvec.size();i++){\n        for(int j=0;j<rvec.size();j++){\n            if(l_to_r(rvec[i],rvec[j])){\n                g[rvec[i].v].push_back(rvec[j].v);\n            }\n        }\n    }\n    cout<<(isDAG(g) ? \"Yes\" : \"No\")<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define Fi first\n#define Se second\n#define INF (1<<29)\n#define EPS 1e-10\n#define MOD 1000000007\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint M, N;\nmap<int, pi>S[128];\nvector<int>G[128];\nvector<int>tpo[128];\n\nint is_edge(int src, int dist)\n{\n  for(auto x:S[src]){\n    int s = x.first, l = x.second.first, u = x.second.second;\n    if(!S[dist].count(s)) continue;\n    pi op = S[dist][s];\n    if(op.second < l) return 0;\n  }\n  return 1;\n}\n\nint dfs(set<int>& sc)\n{\n  if(sc.size() == M){\n    //    cout << v << endl;\n    return 1;\n  }\n  vector<int>crd; rep(i,M) crd.push_back(i);\n  for(auto x: sc){\n    vector<int>temp;\n    set_intersection(crd.begin(), crd.end(), G[x].begin(), G[x].end(),\n\t\t     back_inserter(temp));\n    crd.swap(temp);\n  }\n\n  for(auto next: crd){\n    if(sc.count(next)) continue;\n    sc.insert(next);\n    if(dfs(sc)) return 1;\n    sc.erase(next);\n  }\n  return 0;\n}\n\nint solve()\n{\n  rep(i, M){\n    //    cout << i << endl;\n    set<int>sc; sc.insert(i);\n    if(dfs(sc)) return 1;\n  }\n  return 0;\n}\n\n\nint main()\n{\n  cin >> M >> N;\n  rep(i, M){\n    int K;  cin >> K;\n    rep(j, K){\n      int s, t; string cond;\n      cin >> s >> cond >> t;\n      int c = 0;\n      if(cond == \"<=\") c = 1;\n      if(!S[i].count(s)) S[i][s] = pi(0, INF);\n      pi p = S[i][s];\n      if(c) S[i][s] = pi(p.first, min(t, p.second));\n      else  S[i][s] = pi(max(t, p.first), p.second);\n    }\n  }\n\n  rep(i, M) for(auto x:S[i]){\n    pi p = x.second;\n    //    cout << p.first << \" \" << p.second << endl;\n    if(p.first > p.second){\n      cout << \"No\\n\";\n      return 0;\n    }\n  }\n\n  rep(i, M) rep(j, M){\n    if(i == j) continue;\n    if(is_edge(i, j)){\n      G[i].push_back(j);\n      tpo[j].push_back(i);\n      //      cout << i << \" \" << j << endl;\n    }\n  }\n\n  rep(i, M) sort(G[i].begin(), G[i].end());\n\n  cout << (solve()?\"Yes\":\"No\") << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n#define INF (1<<26)\nint M,N;\nint K[100];\nint s[100][100];\nstring cond[100][100];\nint t[100][100];\n\nint A[100][100];\nint B[100];\n\nint check(int a,int b){\n  int L[100],R[100];\n  for(int i=0;i<100;i++){\n    L[i]=0;\n    R[i]=INF;\n  }\n  for(int i=0;i<K[a];i++){\n    if(cond[a][i]==\">=\"){\n      L[s[a][i]]=max(L[s[a][i]],t[a][i]);\n    }else{\n      R[s[a][i]]=min(R[s[a][i]],t[a][i]);\n    }\n  }\n\n  for(int i=0;i<100;i++)\n    if(L[i]>R[i])return 0;\n  \n  for(int i=0;i<K[b];i++){\n    if(cond[b][i]==\">=\"){\n      L[s[b][i]]=max(L[s[b][i]],t[b][i]);\n    }else{\n      R[s[b][i]]=min(R[s[b][i]],t[b][i]);\n      if(L[s[b][i]] > R[s[b][i]])return 0;\n    }\n  }\n\n\n  return 1;\n}\n\nint main(){\n  cin>>M>>N;\n  for(int i=0;i<M;i++){\n    cin>>K[i];\n    for(int j=0;j<K[i];j++){\n      cin>>s[i][j]>>cond[i][j]>>t[i][j];\n      s[i][j]--;\n    }\n  }\n\n  \n  for(int i=0;i<M;i++){\n    for(int j=0;j<M;j++){\n      A[i][j]=check(i,j);\n    }\n  }\n\n  for(int j=0;j<M;j++){\n    B[j]=0;\n    for(int k=0;k<M;k++){\n      B[j]+=A[j][k];\n    }\n  }\n  \n  bool flg=true;\n\n  for(int i=0;i<M;i++){\n    \n \n      \n    int id=-1,maxm=-1;\n    for(int j=0;j<M;j++){\n      if(maxm<B[j]){\n        maxm=B[j];\n        id=j;\n      }\n    }\n    \n    if(maxm<M-i)flg=false;\n    \n    for(int j=0;j<M;j++){\n      if(A[j][id]==1){\n        B[j]--;\n      }\n      A[j][id]=0;\n      A[id][j]=0;\n    }\n    B[id]=0;\n  }\n\n  cout<<(flg?\"Yes\":\"No\")<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nstruct skill{\n    int max,min;\n    skill(){\n        max=100;\n        min=0;\n    }\n};\n\ntypedef vector<int> V;\nvector<V> G(100);\nbool isVisited[100];\nbool isChecked[100];\n\nbool rec(int i){\n    isVisited[i]=true;\n    isChecked[i]=true;\n    for(auto&e:G[i]){\n        if(isVisited[e]){\n            return true;\n        }else if(!isChecked[e]){\n            if(rec(e)){\n                return true;\n            }\n        }\n    }\n    isVisited[i]=false;\n    return false;\n}\n\nint main(){\n    int M,N;\n    cin>>M>>N;\n    skill S[100][100];\n    for(int i=0;i<M;i++){\n        int K;\n        cin>>K;\n        for(int j=0;j<K;j++){\n            int s,t;\n            string cond;\n            cin>>s>>cond>>t;\n            s--;\n            if(cond==\"<=\"){//SP<=t\n                if(t<S[i][s].min){\n                    cout<<\"No\"<<endl;\n                    return 0;\n                }else if(t<S[i][s].max){\n                    S[i][s].max=t;\n                }\n            }else{//t<=SP\n                if(t>S[i][s].max){\n                    cout<<\"No\"<<endl;\n                    return 0;\n                }else if(t>S[i][s].min){\n                    S[i][s].min=t;\n                }\n            }\n        }\n    }\n    for(int i=0;i<M;i++){\n        for(int j=i+1;j<M;j++){\n            int i_over_j=0;\n            for(int k=0;k<N;k++){\n                if(S[i][k].min>S[j][k].max){\n                    if(i_over_j==-1){\n                        cout<<\"No\"<<endl;\n                        return 0;\n                    }else{\n                        i_over_j=1;\n                    }\n                }\n                if(S[i][k].max<S[j][k].min){\n                    if(i_over_j==1){\n                        cout<<\"No\"<<endl;\n                        return 0;\n                    }else{\n                        i_over_j=-1;\n                    }\n                }\n            }\n            if(i_over_j==1){\n                // cout<<i<<\"->\"<<j<<endl;\n                G[i].push_back(j);\n            }\n            if(i_over_j==-1){\n                // cout<<i<<\"<-\"<<j<<endl;\n                G[j].push_back(i);\n            }\n        }\n    }\n    for(int i=0;i<M;i++){\n        fill(isVisited,isVisited+100,false);\n        fill(isChecked,isChecked+100,false);\n        if(rec(i)){\n            cout<<\"No\"<<endl;\n            return 0;\n        }\n    }\n    cout<<\"Yes\"<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<map>\n#include<list>\n#include<cmath>\n#include<queue>\n#include<ctime>\n#include<stack>\n#include<string>\n#include<vector>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nconst int INF=1<<29;\n\nint n,m;\nstruct range{int l,r;};\nrange a[110][110];\n\nint order[110][110];\n\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n    for(int i=1;i<=n;i++)\n    {\n        for(int j=1;j<=m;j++)\n        {\n            a[i][j].l=-INF;\n            a[i][j].r=INF;\n        }\n    }\n\n    for(int i=1;i<=n;i++)\n    {\n        int k;\n        scanf(\"%d\",&k);\n        while(k--)\n        {\n            int x,y;\n            char s[2];\n            scanf(\"%d\",&x);\n            scanf(\"%s\",s);\n            scanf(\"%d\",&y);\n\n            if(s[0]=='>')\n                a[i][x].l=max(a[i][x].l,y);\n            else\n                a[i][x].r=min(a[i][x].r,y);\n        }\n    }\n\n    for(int i=1;i<=n;i++)\n    {\n        for(int j=1;j<=m;j++)\n        {\n            if(a[i][j].l>a[i][j].r)\n            {\n                printf(\"No\\n\");\n                return 0;\n            }\n        }\n    }\n\n    for(int t=1;t<=m;t++)\n    {\n        for(int i=1;i<=n;i++)\n        {\n            for(int j=i+1;j<=n;j++)\n            {\n                if(a[i][t].l>a[j][t].r)\n                {\n                    if(order[i][j]==0||order[i][j]==2)\n                        order[i][j]=2;\n                    else\n                    {\n                        printf(\"No\\n\");\n                        return 0;\n                    }\n                }\n                if(a[i][t].r<a[j][t].l)\n                {\n                    if(order[i][j]==0||order[i][j]==1)\n                        order[i][j]=1;\n                    else\n                    {\n                        printf(\"No\\n\");\n                        return 0;\n                    }\n                }\n            }\n        }\n    }\n\n    printf(\"Yes\\n\");\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define l first\n#define r second\n#define INF (1e9)\nusing namespace std;\ntypedef pair <int,int> P;\nint ans=1,m,n,used[101],memo[101][101];\nP cmd[101][101];\n\nint check(int a,int b){\n  if(memo[a][b]!=-1) return memo[a][b];\n  for(int i=0;i<n;i++)\n    if(cmd[a][i].l>cmd[b][i].r) return memo[a][b]=0;\n  return memo[a][b]=1;\n}\n\nint solve(){\n  memset(memo,-1,sizeof(memo));\n  int flg=1,cnt=0;\n  while(flg--)\n    for(int i=0,j;i<m&&!flg;i++){\n      for(j=0;j<m&&!used[i];j++)if(!used[j]&&!check(i,j))break;\n      if(j==m) flg=used[i]=1,cnt++;\n    }\n  return cnt/m;\n}\n\nint main(){\n  for(int i=0;i<101;i++)\n    for(int j=0;j<101;j++)cmd[i][j]=P(-INF,INF);\n\n  cin>>m>>n;\n  for(int i=0,k;i<m;i++){\n    cin>>k;\n    while(k--){\n      string cond;\n      int s,t;\n      cin>>s>>cond>>t;\n      s--;\n      if(cond==\"<=\")cmd[i][s].r=min(cmd[i][s].r,t);\n      if(cond==\">=\")cmd[i][s].l=max(cmd[i][s].l,t);\n      if(cmd[i][s].l>cmd[i][s].r)ans=0;\n    }\n  }\n\n  cout << (ans*solve()? \"Yes\":\"No\")<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#define r(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n#define F first\n#define S second\ntypedef pair<int,int>P;\nint n,m,x,y,K,a[102][102],flag,amin[102][102],amax[102][102];\nstring s;\nvector<P>v1[102],v2[102];\nbool ch(){\n  r(i,m){\n    r(j,v1[i].size()){\n      r(k,v2[i].size()){\n\tif(v1[i][j].F==v2[i][k].F&&v1[i][j].S<v2[i][k].S) return 1;\n      }\n    }\n  }\n  return 0;\n}\nvoid make_Graph(){\n  r(i,102)r(j,102)amax[i][j]=1e8;\n  r(i,m){\n    r(j,v1[i].size())amax[i][v1[i][j].F]=min(amax[i][v1[i][j].F],v1[i][j].S);\n    r(j,v2[i].size())amin[i][v2[i][j].F]=max(amin[i][v2[i][j].F],v2[i][j].S);\n    r(j,102)amin[i][j]=min(amin[i][j],amax[i][j]);\n  }\n  r(i,m)r(j,m)r(k,102)if(amax[i][k]<amin[j][k])a[i][j]=-1;\n}\nint main(){\n  cin>>m>>n;\n  r(i,m){\n    cin>>K;\n    r(j,K){\n      cin>>x>>s>>y;\n      if(s==\"<=\")v1[i].push_back(P(x,y));\n      else v2[i].push_back(P(x,y));\n    }\n  }\n  if(ch())cout<<\"No\"<<endl;\n  else{\n    //r(i,102)r(j,102)a[i][j]==(i==j?0:100);\n    make_Graph();\n    n++;\n    r(o,102)r(i,102)r(j,102)a[i][j]=min(a[i][j],a[i][o]+a[o][j]);\n    r(i,102)if(a[i][i]<0)flag++;\n    cout<<(flag?\"No\":\"Yes\")<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\n#define INF (1<<26)\nint M,N;\nint K[100];\nint s[100][100];\nstring cond[100][100];\nint t[100][100];\n\nint A[100][100];\nint B[100];\n\nint check(int a,int b){\n  int L[100],R[100];\n  for(int i=0;i<100;i++){\n    L[i]=0;\n    R[i]=INF;\n  }\n  for(int i=0;i<K[a];i++){\n    if(cond[a][i]==\">=\"){\n      L[s[a][i]]=max(L[s[a][i]],t[a][i]);\n    }else{\n      R[s[a][i]]=min(R[s[a][i]],t[a][i]);\n    }\n  }\n\n  for(int i=0;i<100;i++)\n    if(L[i]>R[i])return 0;\n  \n  for(int i=0;i<K[b];i++){\n    if(cond[b][i]==\">=\"){\n      L[s[b][i]]=max(L[s[b][i]],t[b][i]);\n    }else{\n      R[s[b][i]]=min(R[s[b][i]],t[b][i]);\n      if(L[s[b][i]] > R[s[b][i]])return 0;\n    }\n  }\n\n\n  return 1;\n}\n\nint main(){\n  cin>>M>>N;\n  for(int i=0;i<M;i++){\n    cin>>K[i];\n    for(int j=0;j<K[i];j++){\n      cin>>s[i][j]>>cond[i][j]>>t[i][j];\n      s[i][j]--;\n    }\n  }\n\n  \n  for(int i=0;i<M;i++){\n    for(int j=0;j<M;j++){\n      A[i][j]=check(i,j);\n    }\n  }\n\n  for(int j=0;j<M;j++){\n    B[j]=0;\n    for(int k=0;k<M;k++){\n      B[j]+=A[j][k];\n    }\n  }\n  \n  bool flg=true;\n\n  for(int i=0;i<M;i++){\n    \n \n      \n    int id=-1,maxm=-1;\n    for(int j=0;j<M;j++){\n      if(maxm<B[j]){\n        maxm=B[j];\n        id=j;\n      }\n    }\n    \n    if(maxm<M-i)flg=false;\n    \n    for(int j=0;j<M;j++){\n      if(A[j][id]==1){\n        B[j]--;\n      }\n      A[j][id]=0;\n      A[id][j]=0;\n    }\n  \n  }\n\n  cout<<(flg?\"Yes\":\"No\")<<endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * Author: NICK WONG\n * Created Time:  2015/8/22 13:40:04\n * File Name: \n */\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<vector>\n#include<list>\n#include<deque>\n#include<queue>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cctype>\n#include<cmath>\n#include<ctime>\n#include<iomanip>\nusing namespace std;\n#define out(x) cout<<#x<<\": \"<<x<<endl\nconst double eps(1e-8);\nconst int maxn=110;\nconst long long maxint=-1u>>1;\nconst long long maxlong=maxint*maxint;\ntypedef long long lint;\nint m,n,ans;\nbool com[maxn][maxn],used[maxn];\nint sum[maxn],match[maxn];\nstruct node\n{\n    int type,l,r;\n} lim[maxn][maxn];\nint a[maxn],b[maxn];\n\nvoid init()\n{\n    memset(used,false,sizeof(used));\n    memset(com,false,sizeof(com));\n    memset(lim,0,sizeof(lim));\n    memset(match,0,sizeof(match));\n    memset(a,0,sizeof(a));\n    memset(b,0,sizeof(b));\n    ans=0;\n    for (int i=1; i<=m; i++)\n    {\n        cin>>sum[i];\n        for (int j=1; j<=n; j++) { lim[i][j].type=233; lim[i][j].r=100; }\n        //if (sum[i]==0) { used[i]=true; ans++; }\n        for (int j=1; j<=sum[i]; j++)\n        {\n            int x,y;\n            string s;\n            cin>>x>>s>>y;       \n            b[x]=max(b[x],y);//\n            if (s[0]=='<')\n            {\n                lim[i][x].r=min(lim[i][x].r,y);\n                lim[i][x].type=0; \n                /*com[i][x]=true;\n                match[i]++;\n                if (match[i]==sum[i]) { used[i]=true; ans++; }*/\n            } else\n            {\n                lim[i][x].type=1;\n                lim[i][x].l=max(lim[i][x].l,y);\n            }\n        }\n    }\n    \n}\n\nvoid work()\n{\n    for (int i=1; i<=m; i++)\n    {\n        sum[i]=0;\n        for (int j=1; j<=n; j++)\n            if (lim[i][j].type!=233) sum[i]++;\n    }\n    /*\n    for (int i=1; i<=m; i++)\n        for (int j=1; j<=n; j++)\n            if (lim[i][j].type!=233 && lim[i][j].l==0)\n            {\n                com[i][j]=true;\n                match[i]++;\n                if (match[i]==sum[i]) { used[i]=true; ans++; }\n            }*/\n    for (int i=1; i<=m; i++)\n    {\n        for (int j=1; j<=n; j++) \n        {\n            if (lim[i][j].type!=233 && lim[i][j].l>lim[i][j].r) \n            {\n                cout<<\"No\"<<endl;\n                return;\n            }\n            //if (lim[i][j].type!=233) cout<<i<<\" \"<<j<<\" \"<<lim[i][j].l<<\" \"<<lim[i][j].r<<endl;\n        }\n    }\n    //for (int i=1; i<=m; i++)\n        //cout<<i<<\" \"<<match[i]<<endl;\n    //out(ans);\n    bool flag=true;\n    int now=1;\n    while(flag)\n    {\n        //int tmp=st;\n        bool check=false;\n        flag=false;\n        for (int k=1; k<=n; k++)\n        {\n            check=true;\n            if (a[k]!=b[k])\n            {\n                for (int i=1; i<=m; i++)\n                    if (!used[i] && a[k]+1>lim[i][k].r) { check=false; break; }\n            } else check=false;\n            if (check) \n            {\n                now=k;\n                break;\n            }\n        }\n        if (check)\n        {\n            flag=true;\n            a[now]++;\n            for (int i=1; i<=m; i++)\n                if (!used[i] && a[now]>=lim[i][now].l && !com[i][now]) \n                { \n                    com[i][now]=true; \n                    match[i]++;\n                    if (match[i]==sum[i]) { used[i]=true; ans++; }\n                }\n        }\n        if (ans==m) break;    \n    }\n    \n    //for (int i=1; i<=m; i++)\n    //{\n        //cout<<a[i]<<endl;\n        //out(used[i]);\n    //}\n    if (ans==m) cout<<\"Yes\"<<endl; else cout<<\"No\"<<endl;\n}\n\nint main()\n{\n    while(cin>>m>>n)\n    {\n    init();\n    work();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n\nint n, m, t, si, p, ans, mx[101][101], mn[101][101], g[101][101];\nstring com;\nmain(){\n\tcin >> m >> n;\n\tREP(i, m){\n\t\tREP(j, n) mx[i][j] = 100;\n\t\tcin >> t;\n\t\tREP(j, t){\n\t\t\tcin >> si >> com >> p;\n\t\t\tif(com[0]=='>') mn[i][si-1] = max(mn[i][si-1], p);\n\t\t\telse mx[i][si-1] = min(mx[i][si-1], p);\n\t\t}\n\t}\n\tREP(i, m)REP(j, m)REP(k, n) g[i][j] |= mx[i][k] < mn[j][k];\n\tREP(k, m)REP(i, m)REP(j, m) g[i][j] |= g[i][k] & g[k][j];\n\tREP(i, m) ans |= g[i][i];\n\tcout << (ans ? \"No\" : \"Yes\") << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n\nusing namespace std;\n\nint main(){\n  int M, N;\n  cin >> M >> N;\n  vector< vector< pair<int, int> > > V(M, vector< pair<int,int> >(N,pair<int,int>(0,101)));\n  for(int i = 0; i < M; ++i){\n    int K;\n    cin >> K;\n    for(int j = 0; j < K; ++j){\n      int s, t;\n      string c;\n      cin >> s >> c >> t;\n      --s;\n      if(c == \">=\"){\n        if(V[i][s].second < t){\n          cout << \"No\" << endl;\n          return 0;\n        }\n        V[i][s].first = max(t, V[i][s].first);\n      }else{\n        if(V[i][s].first > t){\n          cout << \"No\" << endl;\n          return 0;\n        }\n        V[i][s].second = min(t, V[i][s].second);\n      }\n    }\n  }\n  vector< vector<bool> > G(M, vector<bool>(M,false));\n  for(int i = 0; i < M; ++i){\n    for(int j = 0; j < M; ++j){\n      bool f = true;\n      for(int k = 0; k < N; ++k){\n        if(V[i][k].first > V[j][k].second){\n          f = false;\n          break;\n        }\n      }\n      G[i][j] = f;\n    }\n  }\n  vector<int> D(M,0);\n  for(int i = 0; i < M; ++i){\n    bool f = true;\n    for(int j = 0; j < M; ++j){\n      int d = M - i;\n      for(int k = 0; k < M; ++k){\n        d -= G[j][k];\n      }\n      if(!d){\n        f = false;\n        for(int k = 0; k < M; ++k){\n          G[j][k] = false;\n          G[k][j] = false;\n        }\n        break;\n      }\n    }\n    if(f){\n      cout << \"No\" << endl;\n      return 0;\n    }\n  }\n  cout << \"Yes\" << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nconst int My_Inf=2147483647;\nconst long long int My_LInf=9223372036854775807;\n\nint M;\n\nvoid dfs(vector<bool>&transs, const int now,const vector<vector<bool>>&edges) {\n\ttranss[now] = true;\n\tfor (int i = 0; i < M; ++i) {\n\t\tif (edges[now][i] && !transs[i]) {\n\t\t\tdfs(transs, i, edges);\n\t\t}\n\t}\n\treturn;\n}\n\nint main() {\n\tint  N; cin >> M >> N;\n\tvector<vector<vector<pair<bool, int>>>>conds(M, vector<vector<pair<bool, int>>>(N, vector<pair<bool, int>>(2, make_pair(false, 0))));\n\tfor (int i = 0; i < M; ++i) {\n\t\tint K; cin >> K;\n\t\tfor (int j = 0; j < K; ++j) {\n\t\t\tint s, t; string st; cin >> s >> st >> t;\n\t\t\ts--; \n\t\t\tbool ku = (st == \"<=\");\n\t\t\tif (!conds[i][s][ku].first) {\n\t\t\t\tconds[i][s][ku].first = true;\n\t\t\t\tconds[i][s][ku].second = t;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (ku) {\n\t\t\t\t\tconds[i][s][ku].second = min(conds[i][s][ku].second, t);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tconds[i][s][ku].second = max(conds[i][s][ku].second, t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tbool aaok = true;\n\tfor (int i = 0; i < M; ++i) {\n\t\tfor (int j = 0; j < N; ++j) {\n\t\t\tif (conds[i][j][0].first&&conds[i][j][1].first) {\n\t\t\t\tif (conds[i][j][0].second>conds[i][j][1].second)aaok = false;\n\t\t\t}\n\t\t}\n\t}\n\tif (aaok) {\n\t\tvector<vector<bool>>edges(M, vector<bool>(M));\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tfor (int j = 0; j < M; ++j) {\n\t\t\t\tbool ok = true;\n\t\t\t\tfor (int k = 0; k < N; ++k) {\n\t\t\t\t\tif (conds[i][k][0].first&&conds[j][k][1].first) {\n\t\t\t\t\t\tif (conds[i][k][0].second>conds[j][k][1].second)ok = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tedges[i][j] = ok;\n\t\t\t}\n\t\t}\n\t\tbool aok = false;\n\t\tfor (int from = 0; from < M; ++from) {\n\t\t\tvector<bool>transs(M);\n\t\t\tdfs(transs, from, edges);\n\t\t\tif (all_of(transs.begin(), transs.end(), [](const bool b) {return b; })) {\n\t\t\t\taok = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (aok) {\n\t\t\tcout << \"Yes\" << endl;\n\n\t\t}\n\t\telse {\n\t\t\tcout << \"No\" << endl;\n\t\t}\n\t\treturn 0;\n\t}\n\tcout << \"No\" << endl;\n\t\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n\ntypedef struct Cond{\n  int kind;\n  int arrow;\n  int bound;\n}cond;\n\nbool sr(const cond& l, const cond& r){\n  return l.kind==r.kind ? l.arrow < r.arrow : l.kind < r.kind;\n}\n\nclass Graph{\npublic:\n  int v;\n  vector<int> visited,visiting;\n  vector<int> e[100];\n  Graph(int m){\n    v = m;\n    visited = vector<int>(v);\n    visiting = vector<int>(v);\n  }\n  void addEdge(int e1,int e2){\n    if (find(e[e1].begin(),e[e1].end(),e2)==e[e1].end()){\n      e[e1].push_back(e2);\n    }\n  }\n  int dfs(int vv){\n    int ret = 0;\n    visited[vv] = 1;\n    visiting[vv] = 1;\n    rep(i,e[vv].size()){\n      if(!visited[e[vv][i]]){\n        ret += dfs(e[vv][i]);\n      } else if (visiting[e[vv][i]]==1){\n        return 1;\n      }\n    }\n    visiting[vv] = 0;\n    return ret;\n  }\n};\n\n\nint main(){\n\n  int m,n;\n  cin >> m >> n;\n  vector<int> k(m);\n  vector<cond> conditions[100];\n  pair<int,int> sections[100][100];\n\n  rep(i,m){\n    cin >> k[i];\n    conditions[i] = vector<cond>(k[i]);\n    rep(j,k[i]){\n      string c;\n      cin >> conditions[i][j].kind >> c >> conditions[i][j].bound;\n      conditions[i][j].kind--;\n      if (c==\">=\"){\n        conditions[i][j].arrow = 0;\n      } else {\n        conditions[i][j].arrow = 1;\n      }\n    }\n    sort(conditions[i].begin(),conditions[i].end(),sr);\n    //commandの条件内で矛盾を探す\n    rep(j,100){sections[i][j].first=0;sections[i][j].second=101;}\n    rep(j,conditions[i].size()){\n      int k = conditions[i][j].kind;\n      if (conditions[i][j].arrow == 0){\n        sections[i][k].first = max(sections[i][k].first,conditions[i][j].bound);\n      } else {\n        sections[i][k].second = min(sections[i][k].second,conditions[i][j].bound);\n      }\n    }\n    rep(j,n){\n      if(sections[i][j].first>sections[i][j].second){\n        cout << \"No\" << endl;\n        return 0;\n      }\n    }\n  }\n  //sections[i][j]: i番目のcommand,j番目のskillポイントがfirst以上second以下\n  //skillポイントを固定して条件を見ていって，区間に交わりがない場合は小→大へ辺を張る\n  Graph g(m);\n  rep(skill,n){\n    rep(com1,m){\n      rep(com2,m){\n        if (com1!=com2){\n          int com1l = sections[com1][skill].first;\n          int com1r = sections[com1][skill].second;\n          int com2l = sections[com2][skill].first;\n          int com2r = sections[com2][skill].second;\n          if (com2r < com1l){\n            g.addEdge(com2,com1);\n          } else if (com1r < com2l){\n            g.addEdge(com1,com2);\n          }\n        }\n      }\n    }\n  }\n  //閉路判定\n  int result = g.dfs(0);\n  if (result == 0){\n    cout << \"Yes\" << endl;\n  } else {\n    cout << \"No\" << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\nconst double eps=1e-9;\nbool zero(double e)\n{return fabs(e)<eps;}\nint sgn(double e)\n{return e<-eps?-1:e>eps;}\nstruct v3{\n    double x,y,z;\n    v3(){}\n    v3(double x,double y,double z):x(x),y(y),z(z){}\n    void s()\n    {\n        scanf(\"%lf%lf%lf\",&x,&y,&z);\n    }\n    void p()\n    {\n        printf(\"%lf %lf %lf\",x,y,z);\n    }\n    double len()\n    {\n        return sqrt(x*x+y*y+z*z);\n    }\n    v3 normalized()\n    {\n        double l=this->len();\n        return v3(x/l,y/l,z/l);\n    }\n};\nv3 operator +(v3 a,v3 b){return v3(a.x+b.x,a.y+b.y,a.z+b.z);}\nv3 operator -(v3 a,v3 b){return v3(a.x-b.x,a.y-b.y,a.z-b.z);}\nv3 operator *(v3 a,double b){return v3(a.x*b,a.y*b,a.z*b);}\nv3 operator /(v3 a,double b){return v3(a.x/b,a.y/b,a.z/b);}\nv3 operator *(double b,v3 a){return v3(a.x*b,a.y*b,a.z*b);}\nv3 Det(v3 a,v3 b)\n{\n    return v3(a.y*b.z-a.z*b.y,a.z*b.x-a.x*b.z,a.x*b.y-a.y*b.x);\n}\ndouble Dot(v3 a,v3 b)\n{\n    return a.x*b.x+a.y*b.y+a.z*b.z;\n}\n\nstruct l3\n{\nv3 a,b;\nl3(){};\nl3(v3 a,v3 b):a(a),b(b){};\n};\nstruct p3\n{\nv3 a,b,c;\np3(){}\np3(v3 a,v3 b,v3 c):a(a),b(b),c(c){}\n};\ndouble vlen(v3 p){return sqrt(Dot(p,p));}\nv3 pvec(v3 s1,v3 s2,v3 s3)\n{\n    return Det(s1-s2,s2-s3);\n}\nv3 pvec(p3 x)\n{return pvec(x.a,x.b,x.c);}\nint parallel(p3 u,p3 v)\n{\n    return vlen(Det(pvec(u),pvec(v)))<eps;\n\n}\nint parallel(v3 a,v3 b,p3 s)\n{\n    return zero(Dot(a-b,pvec(s)));\n}\nv3 intersection(v3 a,v3 b,p3 s)\n{\n    v3 ret=pvec(s);\n    double t=(ret.x*(s.a.x-a.x)+ret.y*(s.a.y-a.y)+ret.z*(s.a.z-a.z))/\n            (ret.x*(b.x-a.x)+ret.y*(b.y-a.y)+ret.z*(b.z-a.z));\n    ret=a+(b-a)*t;\n    return ret;\n\n}\nbool intersection(p3 pl1,p3 pl2,l3& li)\n{\n    if(parallel(pl1,pl2))return false;\n    li.a=parallel(pl2.a,pl2.b,pl1)?intersection(pl2.b,pl2.c,p3(pl1.a,pl1.b,pl1.c)):\n    intersection(pl2.a,pl2.b,p3(pl1.a,pl1.b,pl1.c));\n    v3 fa;\n    fa=Det(pvec(pl1),pvec(pl2));\n    li.b=li.a+fa;\n    return true;\n}\ndouble ptoplane(v3 p,p3 s)\n{\n    return fabs(Dot(pvec(s),p-s.a))/vlen(pvec(s));\n}\nint main()\n{\n    v3 c1;\n    c1.s();\n    v3 d1,d2;\n    d1.s();\n    d2.s();\n    p3 p1=p3(c1,c1+d1,c1+d2);\n\n\n    v3 c2;\n    c2.s();\n    v3 d1p,d2p;\n    d1p.s();\n    d2p.s();\n    p3 p2=p3(c2,c2+d1p,c2+d2p);\n\n    l3 ins;\n    //not parl//\n    if(!intersection(p1,p2,ins)){puts(\"NO\");return 0;}\n\n    v3 l=(ins.b-ins.a).normalized();\n    double r1=ptoplane(c1,p2),r2=ptoplane(c2,p1);\n    if(r1>1+eps||r2>1+eps){puts(\"NO\");return 0;}\n\n    double le1=sqrt(1-r1*r1);\n\n    //projection//\n    v3 pt1=c1+r1*pvec(p2);\n    if(!zero( ptoplane(pt1,p2) ))\n         pt1=c1-r1*pvec(p2);\n    v3 np1=pt1+l*le1,np2=pt1-l*le1;\n   //pt1.p();\n    //np2.p();\n    if(sgn(vlen(np1-c2)-1.0)*sgn(vlen(np2-c2)-1.0)!=-1){puts(\"NO\");return 0;}\n    puts(\"YES\");\n    return 0;\n\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define range(i, a, n) for(int (i) = (a); (i) < (n); (i)++)\n#define rep(i, n) for(int (i) = 0; (i) < (n); (i)++)\nusing namespace std;\n\nint n, m;\nint used[200], lb[200];\n\nint main(void){\n    cin >> m >> n;\n\n    vector<vector<pair<int, int>>> rng(m, vector<pair<int, int>>(n, make_pair(-100, 200)));\n    rep(i, m){\n        int K; cin >> K;\n        rep(loop, K){\n            int s, t; string cond; cin >> s >> cond >> t;\n            s--;\n\n            if(cond == \">=\"){\n                rng[i][s].first = max(rng[i][s].first, t);\n            }\n            else {\n                rng[i][s].second = min(rng[i][s].second, t);\n            }\n        }\n\n        rep(j, n){\n            if(rng[i][j].first > rng[i][j].second){\n                cout << \"No\" << endl;\n                return 0;\n            }\n        }\n    }\n\n    int cnt = 0;\n    while(cnt < m){\n        bool ok1 = false;\n        [&]{\n            rep(a, m){\n                if(used[a]) continue;\n                bool ok2 = true;\n                [&]{\n                    rep(b, m){\n                        if(a == b or used[b]) continue;\n                        rep(i, n){\n                            int cur = max(lb[i], rng[a][i].first);\n                            if(rng[b][i].second < cur){\n                                ok2 = false;\n                                return;\n                            }\n                        }\n                    }\n                }();\n                if(ok2){\n                    cnt++;\n                    used[a] = true;\n                    ok1 = true;\n                    rep(i, n){\n                        lb[i] = max(lb[i], rng[a][i].first);\n                    }\n                    return;\n                }\n            }\n        }();\n        \n        if(not ok1) break;\n    }\n\n    cout << (cnt == m ? \"Yes\":\"No\") << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\nusing namespace std;\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n\nint n, m, t, si, p, ans, mx[101][101], mn[101][101], g[101][101];\nstring com;\nmain(){\n\tcin >> m >> n;\n\tREP(i, m){\n\t\tREP(j, n) mx[i][j] = 100;\n\t\tcin >> t;\n\t\tREP(j, t){\n\t\t\tcin >> si >> com >> p;\n\t\t\t(com[0]=='>' ? mn:mx)[i][si-1] = p;\n\t\t}\n\t}\n\tREP(i, m)REP(j, m)REP(k, n) g[i][j] |= mx[i][k] < mn[j][k];\n\tREP(k, m)REP(i, m)REP(j, m) g[i][j] |= g[i][k] & g[k][j];\n\tREP(i, m) ans |= g[i][i];\n\tcout << (ans ? \"No\" : \"Yes\") << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n\ntypedef struct Cond{\n  int kind;\n  int arrow;\n  int bound;\n}cond;\n\nbool sr(const cond& l, const cond& r){\n  return l.kind==r.kind ? l.arrow < r.arrow : l.kind < r.kind;\n}\n\nclass Graph{\npublic:\n  int v;\n  vector<int> visited,visiting;\n  vector<int> e[100];\n  Graph(int m){\n    v = m;\n    visited = vector<int>(v);\n    visiting = vector<int>(v);\n  }\n  void addEdge(int e1,int e2){\n    if (find(e[e1].begin(),e[e1].end(),e2)==e[e1].end()){\n      e[e1].push_back(e2);\n    }\n  }\n  int dfs(int vv){\n    int ret = 0;\n    visited[vv] = 1;\n    visiting[vv] = 1;\n    rep(i,e[vv].size()){\n      if(!visited[e[vv][i]]){\n        ret += dfs(e[vv][i]);\n      } else if (visiting[e[vv][i]]==1){\n        return 1;\n      }\n    }\n    visiting[vv] = 0;\n    return 0;\n  }\n};\n\n\nint main(){\n\n  int m,n;\n  cin >> m >> n;\n  vector<int> k(m);\n  vector<cond> conditions[100];\n  pair<int,int> sections[100][100];\n\n  rep(i,m){\n    cin >> k[i];\n    conditions[i] = vector<cond>(k[i]);\n    rep(j,k[i]){\n      string c;\n      cin >> conditions[i][j].kind >> c >> conditions[i][j].bound;\n      conditions[i][j].kind--;\n      if (c==\">=\"){\n        conditions[i][j].arrow = 0;\n      } else {\n        conditions[i][j].arrow = 1;\n      }\n    }\n    sort(conditions[i].begin(),conditions[i].end(),sr);\n    //commandの条件内で矛盾を探す\n    rep(j,100){sections[i][j].first=0;sections[i][j].second=101;}\n    rep(j,conditions[i].size()){\n      int k = conditions[i][j].kind;\n      if (conditions[i][j].arrow == 0){\n        sections[i][k].first = max(sections[i][k].first,conditions[i][j].bound);\n      } else {\n        sections[i][k].second = min(sections[i][k].second,conditions[i][j].bound);\n      }\n    }\n    rep(j,n){\n      if(sections[i][j].first>sections[i][j].second){\n        cout << \"No\" << endl;\n        return 0;\n      }\n    }\n  }\n  //sections[i][j]: i番目のcommand,j番目のskillポイントがfirst以上second以下\n  //skillポイントを固定して条件を見ていって，区間に交わりがない場合は小→大へ辺を張る\n  Graph g(m);\n  rep(skill,n){\n    rep(com1,m){\n      rep(com2,m){\n        if (com1!=com2){\n          int com1l = sections[com1][skill].first;\n          int com1r = sections[com1][skill].second;\n          int com2l = sections[com2][skill].first;\n          int com2r = sections[com2][skill].second;\n          if (com2r < com1l){\n            g.addEdge(com2,com1);\n          } else if (com1r < com2l){\n            g.addEdge(com1,com2);\n          }\n        }\n      }\n    }\n  }\n  //閉路判定\n  int result = g.dfs(0);\n  if (result == 0){\n    cout << \"Yes\" << endl;\n  } else {\n    cout << \"No\" << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nconstexpr int INF = numeric_limits<int>::max() / 2;\nusing P = pair<int, int>;\n\ntemplate <typename T>\nvoid printv(const vector<T> &v)\n{\n    int sz = v.size();\n    for (int i = 0; i < sz; i++)\n    {\n        cout << v[i] << \" \\n\"[i == sz - 1];\n    }\n}\n\nclass TopologicalSort\n{\n    using Graph = std::vector<std::vector<int>>;\n    // 頂点数\n    int V;\n    std::vector<std::vector<int>> G;\n    void dfs(int v, std::vector<int> &res, std::vector<int> &used)\n    {\n        used[v] = 1;\n        for (auto to : G[v])\n            if (used[to] == 0)\n            {\n                dfs(to, res, used);\n            }\n        res.push_back(v);\n    }\n\n  public:\n    TopologicalSort(int _v) : V(_v), G(_v) {}\n    void addEdge(int a, int b)\n    {\n        assert(0 <= a && a < V);\n        assert(0 <= b && b < V);\n        G[a].push_back(b);\n    }\n    std::vector<int> topologicalSort()\n    {\n        std::vector<int> ide(V);\n        for (int i = 0; i < V; i++)\n        {\n            for (auto to : G[i])\n            {\n                ide[to]++;\n            }\n        }\n        std::vector<int> res;\n        std::vector<int> used(V);\n        for (int i = V - 1; i >= 0; i--)\n        {\n            if (ide[i] == 0)\n            {\n                dfs(i, res, used);\n            }\n        }\n        if (res.size() == 0)\n            res = {-1};\n        reverse(res.begin(), res.end());\n        return res;\n    }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int M, N;\n    cin >> M >> N;\n    // ma[i][j] = k := i 番目の command を覚えるには skill j が k 以下\n    // mi[i][j] = k :=                                        k 以上\n    vector<vector<int>> ma(M, vector<int>(N, INF)), mi(M, vector<int>(N, -1));\n    for (int i = 0; i < M; i++)\n    {\n        int K;\n        cin >> K;\n        while (K--)\n        {\n            int a, b;\n            string cond;\n            cin >> a >> cond >> b;\n            a--;\n            if (cond == \">=\")\n                mi[i][a] = max(mi[i][a], b);\n            else\n                ma[i][a] = min(ma[i][a], b);\n        }\n    }\n    TopologicalSort ts(M);\n    vector<P> es;\n    for (int i = 0; i < M; i++)\n    {\n        for (int j = i; j < M; j++)\n        {\n            for (int k = 0; k < N; k++)\n            {\n                if (ma[i][k] < mi[j][k])\n                {\n                    es.push_back(P(i, j));\n                    ts.addEdge(i, j);\n                }\n                if (mi[i][k] > ma[j][k])\n                {\n                    es.push_back(P(j, i));\n                    ts.addEdge(j, i);\n                }\n            }\n        }\n    }\n    auto v = ts.topologicalSort();\n    if ((int)v.size() != M)\n    {\n        cout << \"No\" << endl;\n        return 0;\n    }\n    vector<int> pos(M);\n    for (int i = 0; i < M; i++)\n    {\n        pos[v[i]] = i;\n    }\n    for (auto p : es)\n    {\n        int st = p.first, gt = p.second;\n        if (pos[st] >= pos[gt])\n        {\n            cout << \"No\" << endl;\n            return 0;\n        }\n    }\n    cout << \"Yes\" << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\n//??????A[a,b]??¨??????B[c,d]?????¢???\nint intervalState(int a, int b, int c, int d){\n    if(a < c && b < c) return 0;            //A < B\n    else if(a > d && b > d) return 1;       //A > B\n    else if(a <= c && d <= b) return 2;     //A -> B\n    else if(c < a && b < d) return 3;       //B -> A\n    else if(a <= c && b < d) return 4;      //A <= B\n    else if(c < a && d <= b) return 5;      //A >= B\n    return -1;\n}\n\n//Give input directly to vector<pair<int, int>> in\nvector<pair<int, int>> JoinInterval(vector<pair<int,int>> in){\n    vector<pair<int, int>> v;\n    rep(i,in.size()) in[i].second *= -1;\n    sort(all(in));\n    rep(i,in.size()) in[i].second *= -1;\n\n    rep(i,in.size()){\n        if(v.empty()) v.emplace_back(in[i]);\n        else{\n            pair<int, int> &u = v.back();\n            int tmp = intervalState(in[i].first,in[i].second,u.first,u.second);\n            switch (tmp){\n                case 0:\n                case 1:\n                    v.emplace_back(in[i]);\n                    break;\n                case 2:\n                    u.first = in[i].first;\n                    u.second = in[i].second;\n                    break;\n                case 3:\n                    break;\n                case 4:\n                case 5:\n                    u.first = max(u.first, in[i].first);\n                    u.second = min(u.second, in[i].second);\n                    break;\n                case -1:\n                    assert(0);\n            }\n        }\n    }\n    sort(all(v));\n    return v;\n}\n\nint main(){\n    int m,n;\n    vector<pair<int,int>> v[105]; //v[i] := i??????????????????????????¶\n    rep(i,105) v[i] = vector<pair<int,int>>(105);\n    rep(i,105) rep(j,105) v[i][j] = make_pair(0,105);\n\n    cin >> m >> n;\n    rep(i,m){\n        int k;\n        cin >> k;\n        map<int,vector<pair<int, int>>> m;\n        rep(j,k){\n            int num, point;\n            string s;\n            cin >> num >> s >> point;\n            num--;\n\n            pair<int, int> p;\n            if(s[0] == '<') p = make_pair(0,point);\n            else p = make_pair(point,105);\n            m[num].emplace_back(p);\n        }\n        for(auto it : m){\n            vector<pair<int, int>> in = JoinInterval(it.second);\n            if(in.size() >= 2){\n                cout << \"No\" << endl;\n                return 0;\n            }\n            v[i][it.first] = in[0];\n        }\n    }\n\n    auto canTake = [](vector<pair<int, int>> a, vector<pair<int, int>> b){\n        rep(i,105) if(b[i].second < a[i].first) return 0;\n        return 1;\n    };\n\n    bool used[105] = {0};\n    rep(_,m){\n        rep(i,m){\n            if(used[i]) continue;\n            bool f = true;\n            //i??????????????????????¬??????¨?????¨?????????\n            rep(j,m){\n                if(used[j] || i == j) continue;\n                if(not canTake(v[i],v[j])){\n                    f = false;\n                    break;\n                }\n            }\n            used[i] = f;\n        }\n    }\n    //rep(i,m) show(used[i])\n\n    auto check = [](bool used[105], int m){\n        rep(i,m) if(used[i] == 0) return 0;\n        return 1;\n    };\n    cout << (check(used,m) ? \"Yes\" : \"No\") << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nstruct skill{\n  int c,t;\n  skill(){}\n  skill(int c,int t):c(c),t(t){}\n};\nvector<vector<int> > G;\nbool used[111],tmp[111];\nbool dfs(int v,int d){\n  if(d>111) return 0;\n  tmp[v]=1;\n  bool f=1;\n  for(int i=0;f&&(i<(int)G[v].size());i++)\n    if(!used[G[v][i]]) f&=dfs(G[v][i],d+1);\n  return f;\n}\nbool solve(int m){\n  bool f=1;\n  for(int i=0;f&&(i<m);i++) {\n    memset(tmp,0,sizeof(tmp));\n    if(!used[i]) f&=dfs(i,0);\n    for(int j=0;j<m;j++) used[j]|=tmp[j];\n    //cout<<i<<endl;\n  }\n  return f;\n}\nint main(){\n  int m,n;\n  cin>>m>>n;\n  vector<skill> ss[m][n];\n  for(int i=0;i<m;i++){\n    int k;\n    cin>>k;\n    for(int j=0;j<k;j++){\n      int s,t;\n      string c;\n      cin>>s>>c>>t;\n      ss[i][s-1].push_back(skill(c==\"<=\",t));\n    }\n  }\n  bool ff=0;\n  G.resize(m);\n  for(int i=0;i<m;i++){\n    for(int j=0;j<m;j++){\n      bool f=0;\n      for(int k=0;k<n;k++){\n\tfor(int x=0;x<(int)ss[i][k].size();x++){\n\t  for(int y=0;y<(int)ss[j][k].size();y++){\n\t    if(ss[i][k][x].t<=ss[j][k][y].t){\n\t      f|=(ss[i][k][x].c==1&&ss[j][k][y].c==0);\n\t    }\n\t  }\n\t}\n      }\n      if(f) G[j].push_back(i);\n      ff|=((i==j)&&f);\n      //if(f) cout<<i<<\":\"<<j<<endl;\n    }\n  }\n  cout<<(!ff&&solve(m)?\"Yes\":\"No\")<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n\nint const inf = 1<<29;\n\nbool isDAG(vector<vector<int>>& G) {\n  int N = G.size();\n  vector<bool> vis(N);\n\n  std::function<bool(int, unordered_set<int>&)> dfs = [&](int curr, unordered_set<int>& st) {\n    for(auto&& e: G[curr]) {\n      if(st.count(e)) return false;\n      if(vis[e]) continue;\n      st.insert(e);\n      vis[e] = 1;\n      if(!dfs(e, st)) return false;\n      st.erase(e);\n    }\n    return true;\n  };\n\n  rep(e, N) {\n    vis[e] = 1;\n    unordered_set<int> st = {e};\n    if(!dfs(e, st)) return false;\n  }\n  return true;\n}\n\nint main() {\n\n  int M, N; cin >> M >> N;\n  vector<vector<pair<int, int>>> cmd_sect(N, vector<pair<int, int>>(M, {0, inf}));\n\n  rep(cmd_idx, M) {\n    int K; cin >> K;\n    rep(_, K) {\n      int skill; cin >> skill; skill--;\n      string op; cin >> op;\n      int threshold; cin >> threshold;\n      if(op == \">=\") {\n        cmd_sect[skill][cmd_idx].first = max(cmd_sect[skill][cmd_idx].first, threshold);\n      } else {\n        cmd_sect[skill][cmd_idx].second = min(cmd_sect[skill][cmd_idx].second, threshold);\n      }\n      if(cmd_sect[skill][cmd_idx].first > cmd_sect[skill][cmd_idx].second) {\n        cout << \"No\" << endl;\n        return 0;\n      }\n    }\n  }\n\n  vector<vector<int>> G(M);\n  \n  rep(i, N) {\n    rep(a, M) rep(b, M) {\n      if(a == b) continue;\n      if(cmd_sect[i][a].second < cmd_sect[i][b].first)\n        G[a].push_back(b);\n    }\n  }\n\n  rep(i, M) {\n    sort(all(G[i]));\n    G[i].erase(unique(all(G[i])), G[i].end());\n  }\n\n  cout << (isDAG(G) ? \"Yes\" : \"No\") << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define l first\n#define r second\n#define INF (1e9)\nusing namespace std;\ntypedef pair <int,int> P;\nint ans=1,m,n,used[101],memo[101][101];\nP cmd[101][101];\n\nint check(int a,int b){\n  if(memo[a][b]!=-1) return memo[a][b];\n  for(int i=0;i<n;i++)\n    if(cmd[a][i].l>cmd[b][i].r) return memo[a][b]=0;\n  return memo[a][b]=1;\n}\n\nint solve(){\n  memset(memo,-1,sizeof(memo));\n  int cnt=0;\n  for(int i=0;i<m;i++){\n    int j=0;\n    while(j<m&&(used[j]||check(i,j)))j++;\n    if(j==m) used[i]=1,cnt++,i=-1;\n  }\n  return cnt/m;\n}\n\nint main(){\n  for(int i=0;i<101;i++)\n    for(int j=0;j<101;j++)cmd[i][j]=P(-INF,INF);\n\n  cin>>m>>n;\n  for(int i=0,k;i<m;i++){\n    cin>>k;\n    while(k--){\n      string cond;\n      int s,t;\n      cin>>s>>cond>>t;\n      s--;\n      if(cond==\"<=\")cmd[i][s].r=min(cmd[i][s].r,t);\n      if(cond==\">=\")cmd[i][s].l=max(cmd[i][s].l,t);\n      if(cmd[i][s].l>cmd[i][s].r)ans=0;\n    }\n  }\n\n  cout << (ans*solve()? \"Yes\":\"No\")<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * Author: NICK WONG\n * Created Time:  2015/8/22 13:40:04\n * File Name: \n */\n#include<iostream>\n#include<sstream>\n#include<fstream>\n#include<vector>\n#include<list>\n#include<deque>\n#include<queue>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cctype>\n#include<cmath>\n#include<ctime>\n#include<iomanip>\nusing namespace std;\n#define out(x) cout<<#x<<\": \"<<x<<endl\nconst double eps(1e-8);\nconst int maxn=110;\nconst long long maxint=-1u>>1;\nconst long long maxlong=maxint*maxint;\ntypedef long long lint;\nint m,n,ans;\nbool com[maxn][maxn],used[maxn];\nint sum[maxn],match[maxn];\nstruct node\n{\n    int type,l,r;\n} lim[maxn][maxn];\nint a[maxn],b[maxn];\n\nvoid init()\n{\n    memset(used,false,sizeof(used));\n    memset(com,false,sizeof(com));\n    memset(lim,0,sizeof(lim));\n    memset(match,0,sizeof(match));\n    memset(a,0,sizeof(a));\n    memset(b,0,sizeof(b));\n    ans=0;\n    for (int i=1; i<=m; i++)\n    {\n        cin>>sum[i];\n        for (int j=1; j<=n; j++) { lim[i][j].type=233; lim[i][j].r=100; }\n        if (sum[i]==0) { used[i]=true; ans++; }\n        for (int j=1; j<=sum[i]; j++)\n        {\n            int x,y;\n            string s;\n            cin>>x>>s>>y;       \n            b[x]=max(b[x],y);//\n            if (s[0]=='<')\n            {\n                lim[i][x].type=0;\n                lim[i][x].r=min(lim[i][x].r,y);\n            } else\n            {\n                lim[i][x].type=1;\n                lim[i][x].l=max(lim[i][x].l,y);\n            }\n        }\n    }\n}\n\nvoid work()\n{\n    for (int i=1; i<=m; i++)\n    {\n        sum[i]=0;\n        for (int j=1; j<=n; j++)\n            if (lim[i][j].type!=233) sum[i]++;\n    }\n    for (int i=1; i<=m; i++)\n        for (int j=1; j<=n; j++)\n            if (lim[i][j].type!=233 && lim[i][j].l==0)\n            {\n                com[i][j]=true;\n                match[i]++;\n                if (match[i]==sum[i]) { used[i]=true; ans++; }\n            }\n    for (int i=1; i<=m; i++)\n    {\n        for (int j=1; j<=n; j++) \n        {\n            if (lim[i][j].type!=233 && lim[i][j].l>lim[i][j].r) \n            {\n                cout<<\"No\"<<endl;\n                return;\n            }\n            //if (lim[i][j].type!=233) cout<<i<<\" \"<<j<<\" \"<<lim[i][j].l<<\" \"<<lim[i][j].r<<endl;\n        }\n    }\n    //for (int i=1; i<=m; i++)\n        //cout<<i<<\" \"<<match[i]<<endl;\n    //out(ans);\n    bool flag=true;\n    int now=1;\n    while(flag)\n    {\n        bool check=false;\n        flag=false;\n        for (int k=1; k<=n; k++)\n        {\n            check=true;\n            //if (a[k]!=b[k])\n            //{\n                for (int i=1; i<=m; i++)\n                    if (!used[i] && a[k]+1>lim[i][k].r) { check=false; break; }\n            //} else check=false;\n            if (check) \n            {\n                now=k;\n                break;\n            }\n        }\n        if (check)\n        {\n            flag=true;\n            a[now]++;\n            for (int i=1; i<=m; i++)\n                if (!used[i] && a[now]>=lim[i][now].l && !com[i][now]) \n                { \n                    com[i][now]=true; \n                    match[i]++;\n                    if (match[i]==sum[i]) { used[i]=true; ans++; }\n                }\n        }\n        if (ans==m) break;    \n    }\n    \n    //for (int i=1; i<=m; i++)\n    //{\n        //cout<<a[i]<<endl;\n        //out(used[i]);\n    //}\n    if (ans==m) cout<<\"Yes\"; else cout<<\"No\";\n}\n\nint main()\n{\n    while(cin>>m>>n)\n    {\n    init();\n    work();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cout<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cout<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n#define INF 1120000000\n#define long long long // for codeforces\n\nint num[105];\nvector<int> tree[105];\npair<int,int> range[105][105];\n\nbool dfs(int v){\n  num[v] = 1;\n  for(int to : tree[v]){\n    if(num[to]==-1){ if(!dfs(to)) return false; }\n    else if(num[to]==1) return false;\n  }\n  num[v]=0;\n  return true;\n}\n\nbool solve(){\n  int m,n;\n  cin>>m>>n;\n  rep(i,m){\n    int k;\n    cin>>k;\n    rep(j,n) range[i][j] = mp(0,101);\n    rep(j,k){\n      int s,t;\n      string str;\n      cin>>s>>str>>t;\n      s--;\n      if(str[0]=='>') range[i][s].fi = max(range[i][s].fi, t);\n      else range[i][s].se = min(range[i][s].se, t+1);\n    }\n    rep(j,n) if(range[i][j].se - range[i][j].fi <= 0) return false;\n  }\n\n  rep(i,m) rep(j,i){\n    rep(k,n){\n      if(range[i][k].se <= range[j][k].fi){ tree[i].pb(j); break; }\n      if(range[j][k].se <= range[i][k].fi){ tree[j].pb(i); break; }\n    }\n  }\n\n  fill(num, num+m, -1);\n\n  rep(i,m) if(num[i]==-1){\n    if(!dfs(i)) return false;\n  }\n\n  return true;\n}\n\nint main(){\n  if(solve()) cout << \"Yes\" << endl;\n  else cout << \"No\" << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nint main()\n{\n\tint m, n;\n\tcin >> m >> n;\n\tvector<vi> g(n);\n\tvector<vector<pii>> v(m, vector<pii>(n, pii(0, INF)));\n\tREP(i, m)\n\t{\n\t\tint k; cin >> k;\n\t\tREP(j, k)\n\t\t{\n\t\t\tint s, t; string con;\n\t\t\tcin >> s >> con >> t;\n\t\t\ts--;\n\t\t\tif (con == \"<=\") chmin(v[i][s].second, t);\n\t\t\telse chmax(v[i][s].first, t);\n\t\t}\n\t}\t\n\tbool ans = false;\n\tREP(i, m)REP(j, n)\n\t{\n\t\tif (v[i][j].first > v[i][j].second) goto end;\n\t}\n\tREP(i, n)REP(j, n)\n\t{\n\t\tif (i == j) continue;\n\t\tbool f = true;\n\t\tREP(k, n)\n\t\t{\n\t\t\tif (v[i][k].second < v[j][k].first) f = false;\n\t\t}\n\t\tif (f) g[i].push_back(j);\n\t}\n\n\tREP(i, n)\n\t{\n\t\tvector<bool> vis(n);\n\t\tvis[i] = true;\n\t\tqueue<int> que;\n\t\tque.push(i);\n\t\twhile (que.size())\n\t\t{\n\t\t\tint t = que.front();\n\t\t\tque.pop();\n\t\t\tREP(j, g[t].size())\n\t\t\t{\n\t\t\t\tint nx = g[t][j];\n\t\t\t\tif (vis[nx]) continue;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvis[nx] = true;\n\t\t\t\t\tque.push(nx);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (find(ALL(vis), false) == vis.end()) ans = true;\n\t}\nend:;\n\tputs(ans ? \"Yes\" : \"No\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\nusing namespace std;\ntypedef pair<int,int> P;\n\nint m, n;\nvector<P> v[100][2];\nvector<int> e[100];\nbool saw[100];\n\nbool f(int x, int ori){\n\tif(x == ori && saw[x] == true) return false;\n\tif(saw[x]) return true;\n\tsaw[x] = true;\n\trep(i,e[x].size()){\n\t\tif(!f(e[x][i],ori)) return false;\n\t}\n\treturn true;\n}\n\nint main(){\n\tcin >> m >> n;\n\trep(i,m){\n\t\tint k; cin >> k;\n\t\trep(j,k){\n\t\t\tint s ,t;\n\t\t\tstring cond;\n\t\t\tcin >> s >> cond >> t;\n\t\t\ts--;\n\t\t\tif(cond[0] == '>'){\n\t\t\t\tv[s][0].push_back(P(t,i));\n\t\t\t} else{\n\t\t\t\tv[s][1].push_back(P(t,i));\n\t\t\t}\n\t\t}\n\t}\n\trep(i,n){\n\t\trep(j,v[i][0].size()){\n\t\t\tP p1 = v[i][0][j];\n\t\t\trep(k,v[i][1].size()){\n\t\t\t\tP p2 = v[i][1][k];\n\t\t\t\tif(p1.first > p2.first){\n\t\t\t\t\tif(p2.second == p1.second){\n\t\t\t\t\t\tputs(\"No\");\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\te[p2.second].push_back(p1.second);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\trep(i,n) sort(e[i].begin(),e[i].end());\n\trep(i,n) e[i].erase(unique(e[i].begin(),e[i].end()),e[i].end());\n\trep(i,n){\n\t\trep(j,100) saw[j] = false;\n\t\tif(!f(i,i)){\n\t\t\tputs(\"No\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tputs(\"Yes\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nstruct skill{\n    int max,min;\n    skill(){\n        max=100;\n        min=1;\n    }\n};\n\ntypedef vector<int> V;\nvector<V> G(100);\nbool isVisited[100];\nbool isChecked[100];\n\nbool rec(int i){\n    isVisited[i]=true;\n    isChecked[i]=true;\n    for(auto&e:G[i]){\n        if(isVisited[e]){\n            return true;\n        }else if(!isChecked[e]){\n            if(rec(e)){\n                return true;\n            }\n        }\n    }\n    isVisited[i]=false;\n    return false;\n}\n\nint main(){\n    int M,N;\n    cin>>M>>N;\n    skill S[100][100];\n    for(int i=0;i<M;i++){\n        int K;\n        cin>>K;\n        for(int j=0;j<K;j++){\n            int s,t;\n            string cond;\n            cin>>s>>cond>>t;\n            s--;\n            if(cond==\"<=\"){//SP<=t\n                if(t<S[i][s].min){\n                    cout<<\"No\"<<endl;\n                    return 0;\n                }else if(t<S[i][s].max){\n                    S[i][s].max=t;\n                }\n            }else{//t<=SP\n                if(t>S[i][s].max){\n                    cout<<\"No\"<<endl;\n                    return 0;\n                }else if(t>S[i][s].min){\n                    S[i][s].min=t;\n                }\n            }\n        }\n    }\n    for(int i=0;i<M;i++){\n        for(int j=i+1;j<M;j++){\n            int i_over_j=0;\n            for(int k=0;k<N;k++){\n                if(S[i][k].min>S[j][k].max){\n                    if(i_over_j==-1){\n                        cout<<\"No\"<<endl;\n                        return 0;\n                    }else{\n                        i_over_j=1;\n                    }\n                }\n                if(S[i][k].max<S[j][k].min){\n                    if(i_over_j==1){\n                        cout<<\"No\"<<endl;\n                        return 0;\n                    }else{\n                        i_over_j=-1;\n                    }\n                }\n            }\n            if(i_over_j==1){\n                // cout<<i<<\"->\"<<j<<endl;\n                G[i].push_back(j);\n            }\n            if(i_over_j==-1){\n                // cout<<i<<\"<-\"<<j<<endl;\n                G[j].push_back(i);\n            }\n        }\n    }\n    for(int i=0;i<M;i++){\n        fill(isVisited,isVisited+100,false);\n        fill(isChecked,isChecked+100,false);\n        if(rec(i)){\n            cout<<\"No\"<<endl;\n            return 0;\n        }\n    }\n    cout<<\"Yes\"<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <stack>\n#include <algorithm>\n#include <string>\n#define rep(i,a,n) for(int i=a; i<n; i++)\nusing namespace std;\n\n// 移動元と行先と辺のコストを記録する構造体\ntemplate <typename T>\nstruct Edge {\n    int from, to;\n    T cost;\n    Edge(int s, T d) : to(s), cost(d) {}\n    Edge(int f, int s, T d) : from(f), to(s), cost(d) {}\n\n    bool operator<(const Edge &e) const {\n        return cost < e.cost;\n    }\n    bool operator>(const Edge &e) const {\n        return cost > e.cost;\n    }\n};\n\ntemplate <typename T>\nusing Graph = vector< vector< Edge<T> > >;\n\ntemplate <typename T>\nvector<int> tpsort_Kahn(const vector< vector< Edge<T> > > &g) {\n    const int V = g.size();\n    vector<int> indeg(V, 0);\n    stack<int> S;\n\n    rep(i,0,V) rep(j,0,g[i].size())\n        indeg[ g[i][j].to ]++;\n    rep(i,0,V) if(indeg[i] == 0) S.push(i);\n\n    vector<int> ans;\n    while(S.size() > 0) {\n        int u = S.top(); S.pop();\n        ans.push_back(u);\n        rep(i,0,g[u].size()) {\n            indeg[ g[u][i].to ]--;\n            if(indeg[ g[u][i].to ] ==  0)\n                S.push( g[u][i].to );\n        }\n    }\n    return ans;\n}\n\nconst int INF = 1 << 28;\nint lb[110][110], ub[110][110];\n\nint main() {\n    int M, N; cin >> M >> N;\n    for(int i=0; i<M; i++) {\n        fill(lb[i], lb[i] + N, INF);\n        fill(ub[i], ub[i] + N,  -1);\n    }\n\n    Graph<int> G(M);\n    bool ok = true;\n    for(int i=0; i<M; i++) {\n        int K; cin >> K;\n        for(int k=0; k<K; k++) {\n            int s, t;\n            string cond;\n            cin >> s >> cond >> t; s--;\n            if(cond == \"<=\") ub[i][s] = t;\n            if(cond == \">=\") lb[i][s] = t;\n        }\n        for(int k=0; k<N; k++) {\n            if(lb[i][k] == INF || ub[i][k] == -1) continue;\n            if(lb[i][k] > ub[i][k]) ok = false;\n        }\n    }\n\n    for(int i=0; i<M; i++) {\n        for(int j=0; j<M; j++) {\n            if(i == j) continue;\n            for(int k=0; k<N; k++) {\n                // i より j の方が後でなければならない条件\n                if(ub[i][k] == -1 || lb[j][k] == INF) continue;\n                if(ub[i][k] < lb[j][k]) {\n                    G[i].push_back(Edge<int>(j, 1));\n                }\n            }\n        }\n    }\n\n    if(tpsort_Kahn(G).size() != M) ok = false;\n    cout << (ok ? \"Yes\" : \"No\") << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 2555 Everlasting Zero\n// 2018.4.25 bal4u\n\n#include <stdio.h>\n#include <string.h>\n\n// バッファを経ずstdinから数値を得る\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0, c = getchar_unlocked();\n\twhile (c <= ' ') c = getchar_unlocked();\n\tdo n = 10*n + (c & 0xf), c = getchar_unlocked(); while (c >= '0');\n\treturn n;\n}\n \n#define INF 110\nchar min[101][101], max[101][101];\nchar to[101][101], hi[101];\nint q[101], top, end;\nint count[101];\n\nint topological_sort(int n)\n{\n    int i, j, k, f;\n\n//  for (i = 0; i < n; i++) for (j = 0; j < hi[i]; j++) count[to[i][j]]++;\n    top = end = 0, f = 0;\n    for (i = 0; i < n; i++) if (!count[i]) q[end++] = i;\n    while (top < end) {\n\t\ti = q[top++];\n        f++;\n        for (j = 0; j < hi[i]; j++) {\n            k = to[i][j];\n            if (--count[k] == 0) q[end++] = k;\n        }\n    }\n\treturn f == n;\n}\n\nint main()\n{\n\tint M, N, K, s, cond, t, i, j, k;\n\n\tM = in(), N = in();\n\tmemset(max, INF, sizeof(max));\n\tfor (i = 0; i < M; i++) {\n\t\tK = in();\n\t\twhile (K--) {\n\t\t\ts = in()-1;\n\t\t\tcond = (getchar_unlocked() == '<') ;\n\t\t\tgetchar_unlocked(), getchar_unlocked();\n\t\t\tt = in();\n\t\t\tif (cond) {\n\t\t\t\tif (t < max[i][s]) max[i][s] = t;\n\t\t\t} else {\n\t\t\t\tif (t > min[i][s]) min[i][s] = t;\n\t\t\t}\n\t\t\tif (min[i][s] > max[i][s]) { puts(\"No\"); return 0; }\n\t\t}\n\n\n\t}\n\tfor (i = 0; i < N; i++) {\n\t\tfor (j = 0; j < M; j++) for (k = 0; k < M; k++) if (j != k) {\n\t\t\tif (min[j][i] > max[k][i]) to[j][hi[j]++] = k, count[k]++;\n\t\t}\n\t}\n\tputs(topological_sort(M)? \"Yes\": \"No\");\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<string>\n#include<iomanip>\n#pragma comment(linker, \"/STACK:1024000000,1024000000\")\n#include<vector>\n#include<set>\n#include<map>\n#include<queue>\n#include<list>\n\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\n#define rep(i,k,n) for(int i=(k);i<=(n);i++)\n#define red(i,k,n) for(int i=(k);i>=(n);i--)\n#define sqr(x) ((x)*(x))\n#define clr(x,y) memset((x),(y),sizeof(x))\n#define mod 1000000007\n#define MAX(a,b) ((a)>(b)?(a):(b))\n#define MIN(a,b) ((a)>(b)?(b):(a))\n//const int maxn = ;\n\nint n,m;\nint skl[110][110];\nint skr[110][110];\nint in[110];\nint out[110];\nbool vis[110];\nvector<int> e[110];\nqueue<int> q;\n\nchar s[10];\n\nbool solve()\n{\n    int kk,num,p,v;\n    rep(i,1,n)rep(j,1,m)skl[i][j]=0,skr[i][j]=100;\n    rep(i,1,n)\n    {\n        scanf(\"%d\",&kk);\n        rep(j,1,kk)\n        {\n            scanf(\"%d%s%d\",&num,s,&p);\n            if(s[0]=='>')\n            {\n                if(skl[i][num]<p)\n                {\n                    if(skr[i][num]<p)\n                    {\n                        return 0;\n                    }\n                    else skl[i][num]=p;\n                }\n            }\n            else if(s[0]=='<')\n            {\n                if(skr[i][num]>p)\n                {\n                    if(skl[i][num]>p)\n                    {\n                        return 0;\n                    }\n                    else skr[i][num]=p;\n                }\n            }\n\n        }\n        e[i].clear();\n    }\n    clr(in,0);\n    clr(out,0);\n    rep(i,1,n)\n    {\n        rep(j,1,n)\n        {\n            if(i==j)continue;\n            bool flag=true;\n            rep(k,1,m)\n            {\n                if(skr[j][k]<skl[i][k])\n                {\n                    flag=false;\n                    break;\n                }\n            }\n            if(flag)\n            {\n                e[i].push_back(j);\n                in[j]++;\n                out[i]++;\n            }\n        }\n    }\n    int cnt;\n    rep(i,1,n)\n    {\n        clr(vis,0);\n        cnt=0;q.push(i);vis[i]=1;cnt++;\n        while(!q.empty())\n        {\n            p=q.front();\n            q.pop();\n            if(!e[p].empty())\n            {\n                rep(i,0,e[p].size()-1)\n                {\n                    v=e[p][i];\n                    if(vis[v])continue;\n                    q.push(v);\n                    vis[v]=1;\n                    cnt++;\n                }\n            }\n        }\n        if(cnt==n)return 1;\n    }\n    return 0;\n}\n\nint main()\n{\n//#define LOCAL\n#ifdef LOCAL\n    freopen(\"e:\\\\read.txt\",\"r\",stdin);\n    //freopen(\"e:\\\\write.txt\",\"w\",stdout);\n#endif\n    while(cin>>n>>m)\n    {\n        if(solve())puts(\"Yes\");\n        else puts(\"No\");\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint N,M,K,L[105][105],G[105][105],i,j,s,t,gg[105][105],ll[105][105],r=0;\nchar c[5];\n\nint ch(int x,int y)\n{\n\tint i,j;\n\tfor(i=0;i<N;i++)\n\t{\n\t\tif(L[x][i]<G[x][i]||L[y][i]<G[y][i]||G[x][i]>L[y][i])\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&M,&N);\n\tmemset(L,0x7f,sizeof(L));\n\tmemset(G,0xf0,sizeof(G));\n\tfor(i=0;i<M;i++)\n\t{\n\t\tfor(scanf(\"%d\",&K);K--;)\n\t\t{\n\t\t\tscanf(\"%d%s%d\",&s,c,&t);\n\t\t\ts--;\n\t\t\tif(c[0]=='<'&&L[i][s]>t)\n\t\t\t\tL[i][s]=t;\n\t\t\telse if(c[0]=='>'&&G[i][s]<t)\n\t\t\t\tG[i][s]=t;\n\t\t}\n\t}\n\tfor(i=0;i<M;i++)\n\t{\n\t\tfor(j=i;j<M;j++)\n\t\t{\n\t\t\tint fc=ch(i,j),sn=ch(j,i);\n\t\t\tif(fc&&sn);\n\t\t\telse if(fc)\n\t\t\t\tgg[i][j]=1;\n\t\t\telse if(sn)\n\t\t\t\tll[j][i]=1;\n\t\t\telse\n\t\t\t\tgoto e;\n\t\t}\n\t}\n\tfor(i=0;i<M;i++)\n\t\tfor(j=0;j<M;j++)\n\t\t\tif(gg[i][j]&&ll[i][j])\n\t\t\t\tgoto e;\n\tr=1;\ne:\tputs(r?\"Yes\":\"No\");\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint N,M,K,L[105][105],G[105][105],i,j,k,s,t,gg[105][105],ll[105][105],r=0;\nchar c[5];\n\nint ch(int x,int y)\n{\n\tint i,j;\n\tfor(i=0;i<N;i++)\n\t{\n\t\tif(L[x][i]<G[x][i]||L[y][i]<G[y][i]||G[x][i]>L[y][i])\n\t\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nint main()\n{\n\tscanf(\"%d%d\",&M,&N);\n\tmemset(L,0x7f,sizeof(L));\n\tmemset(G,0xf0,sizeof(G));\n\tfor(i=0;i<M;i++)\n\t{\n\t\tfor(scanf(\"%d\",&K);K--;)\n\t\t{\n\t\t\tscanf(\"%d%s%d\",&s,c,&t);\n\t\t\ts--;\n\t\t\tif(c[0]=='<'&&L[i][s]>t)\n\t\t\t\tL[i][s]=t;\n\t\t\telse if(c[0]=='>'&&G[i][s]<t)\n\t\t\t\tG[i][s]=t;\n\t\t}\n\t}\n\tfor(i=0;i<M;i++)\n\t\tfor(j=0;j<M;j++)\n\t\t\tfor(k=0;k<N;k++)\n\t\t\t\tG[i][j]|=gg[i][k]<ll[j][k];\n\tfor(k=0;k<M;k++)\n\t\tfor(i=0;i<M;i++)\n\t\t\tfor(j=0;j<M;j++)\n\t\t\t\tG[i][j]|=G[i][k]&G[k][j];\n\tfor(i=0;i<M;i++)\n\t\tif(G[i][i])\n\t\t\tgoto e;\n\tr=1;\ne:\tputs(r?\"Yes\":\"No\");\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint N,M,K,L[105][105],G[105][105],i,j,k,s,t,f[105][105],r=0;\nchar c[5];\n\n\nint main()\n{\n\tscanf(\"%d%d\",&M,&N);\n\tmemset(L,0xf0,sizeof(L));\n\tmemset(G,0x70,sizeof(G));\n\tfor(i=0;i<M;i++)\n\t{\n\t\tfor(scanf(\"%d\",&K);K--;)\n\t\t{\n\t\t\tscanf(\"%d%s%d\",&s,c,&t);\n\t\t\ts--;\n\t\t\tif(c[0]=='<'&&G[i][s]>t)\n\t\t\t\tG[i][s]=t;\n\t\t\telse if(c[0]=='>'&&L[i][s]<t)\n\t\t\t\tL[i][s]=t;\n\t\t}\n\t}\n\tfor(i=0;i<M;i++)\n\t\tfor(j=0;j<M;j++)\n\t\t\tfor(k=0;k<N;k++)\n\t\t\t\tif(G[i][k]<L[j][k])\n\t\t\t\t\tf[i][j]=1;\n\tfor(k=0;k<M;k++)\n\t\tfor(i=0;i<M;i++)\n\t\t\tfor(j=0;j<M;j++)\n\t\t\t\tf[i][j]|=f[i][k]&f[k][j];\n\tfor(i=0;i<M;i++)\n\t\tif(f[i][i])\n\t\t\tgoto e;\n\tr=1;\ne:\tputs(r?\"Yes\":\"No\");\n\treturn 0;\n}"
  },
  {
    "language": "Kotlin",
    "code": "import java.util.*\n\nfun main(args:Array<String>?): Unit {\n    val (m, n) = readLine()!!.trim().split(' ').map(String::toInt)\n    val lessCount = IntArray(m){0}\n    val greaterNode = Array(m){ Stack<Int>() }\n    val lowerLimit = Array(m){IntArray(n){0}}\n    val upperLimit = Array(m){IntArray(n){100}}\n    repeat(m){special ->\n        val k = readLine()!!.trim().toInt()\n        repeat(k){\n            val (s, cond, t) = readLine()!!.trim().split(' ')\n            if (cond == \"<=\"){\n                if (upperLimit[special][s.toInt() - 1] > t.toInt()) upperLimit[special][s.toInt() - 1] = t.toInt()\n            }else {\n                if (lowerLimit[special][s.toInt() - 1] < t.toInt()) lowerLimit[special][s.toInt() - 1] = t.toInt()\n            }\n        }\n    }\n    if ((0 until m).any{s -> (0 until n).any{lowerLimit[s][it] > upperLimit[s][it]}}) {\n        println(\"No\")\n        return\n    }\n    for (i in 1 until m) for (j in 0 until i){\n        for (k in 0 until n){\n            if (lowerLimit[i][k] > upperLimit[j][k]) {\n                if (greaterNode[j].isEmpty() || greaterNode[j].peek() != i){\n                    greaterNode[j].add(i)\n                    ++lessCount[i]\n                }\n            }\n            if (lowerLimit[j][k] > upperLimit[i][k]) {\n                if (greaterNode[i].isEmpty() || greaterNode[i].peek() != j){\n                    greaterNode[i].add(j)\n                    ++lessCount[j]\n                }\n            }\n        }\n    }\n    val queue: Queue<Int> = LinkedList<Int>()\n    for (i in 0 until m) if (lessCount[i] == 0) queue.add(i)\n    while(queue.isNotEmpty()){\n        val top = queue.poll()\n        for (i in greaterNode[top]) {\n            --lessCount[i]\n            if (lessCount[i] == 0) queue.add(i)\n        }\n    }\n    println(if (lessCount.all{it == 0}) \"Yes\" else \"No\")\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.util.function.Function;\n\n@SuppressWarnings(\"ALL\")\npublic class Main {\n\n    static int M, N;\n    static int[][][] K;\n\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner(System.in);\n        M = sc.nextInt();\n        N = sc.nextInt();\n\n        K = new int[M][][];\n        for (int i = 0; i < M; i++) {\n            int k = sc.nextInt();\n            K[i] = new int[k][3];\n            for (int j = 0; j < k; j++) {\n                int skill = sc.nextInt();\n                String op = sc.next();\n                int point = sc.nextInt();\n                K[i][j][0] = skill;\n                K[i][j][1] = \">=\".equals(op) ? 0 : 1;\n                K[i][j][2] = point;\n            }\n        }\n        System.out.println(solve() ? \"Yes\": \"No\");\n    }\n\n    static boolean solve() {\n        Command[] C = new Command[M];\n        for (int i = 0; i < M; i++) {\n            Command c = new Command();\n            for (int[] input : K[i]) {\n                int skill = input[0];\n                String op = input[1] == 0 ? \">=\" : \"<=\";\n                int point = input[2];\n\n                Range r;\n                if( op.equals(\">=\") ) {\n                    // 以上\n                    r = new Range(point, 100);\n\n                } else {\n                    r = new Range(0, point);\n                }\n                boolean ok = c.add(skill, r);\n                if( !ok ) return false;\n            }\n            C[i] = c;\n        }\n\n        // Aを取った状態ではBを取れない、というのものを A -> Bという辺にする\n        // これが閉路を作ると矛盾\n        List<Edge> E = new ArrayList<>();\n        for (int i = 0; i < M; i++) {\n            for (int j = 0; j < M; j++) {\n                if( i == j ) continue;\n\n                Command c = C[i];\n                Command d = C[j];\n\n                if( !c.canReach(d) ) {\n                    // debug(i, j);\n                    E.add(new Edge(i, j));\n                }\n            }\n        }\n\n        int[][] G = adjD(M, E);\n        return khan(M, G) != null;\n    }\n\n    static class Edge {\n        int a, b;\n\n        public Edge(int a, int b) {\n            this.a = a;\n            this.b = b;\n        }\n    }\n\n    static int[][] adjD(int n, List<Edge> es) {\n        int[][] adj = new int[n][];\n        int[] cnt = new int[n];\n\n        for (Edge e : es) {\n            cnt[e.a]++;\n        }\n        for (int i = 0; i < n; i++) {\n            adj[i] = new int[cnt[i]];\n        }\n        for (Edge e : es) {\n            adj[e.a][--cnt[e.a]] = e.b;\n        }\n        return adj;\n    }\n\n    static int[] khan(int V, int[][] G) {\n        int[] deg = new int[V];\n        for (int[] tos : G) {\n            for (int to : tos) {\n                deg[to]++;\n            }\n        }\n\n        int[] q = new int[V];\n        int a = 0, b = 0;\n        for (int v = 0; v < V; v++) {\n            if( deg[v] == 0 ) q[b++] = v;\n        }\n\n        int[] ret = new int[V];\n        int idx = 0;\n        while( a != b ) {\n            int v = q[a++];\n            ret[idx++] = v;\n            for (int to : G[v]) {\n                deg[to]--;\n                if( deg[to] == 0 ) {\n                    q[b++] = to;\n                }\n            }\n        }\n\n        for (int v = 0; v < V; v++) {\n            if( deg[v] != 0 ) return null;\n        }\n        return ret;\n    }\n\n    static class Command {\n        Map<Integer, Range> contitions = new HashMap<>();\n\n        boolean add(int skill, Range r) {\n            if( contitions.containsKey(skill) ) {\n                Range s = contitions.get(skill);\n                Range t = Range.merge(r, s);\n                if( t == null ) {\n                    return false;\n                } else {\n                    contitions.put(skill, t);\n                    return true;\n                }\n\n\n            } else {\n                contitions.put(skill, r);\n                return true;\n            }\n        }\n\n        boolean canReach(Command c) {\n            for (Integer skill : contitions.keySet()) {\n                if( c.contitions.containsKey(skill) ) {\n                    Range a = contitions.get(skill);\n                    Range b = c.contitions.get(skill);\n\n                    if( a.min > b.max ) return false;\n                }\n            }\n            return true;\n        }\n    }\n\n    // [min, max]\n    static class Range {\n        // [1, 5] [3, 7] -> [3, 5]\n        public static Range merge(Range a, Range b) {\n            int min = Math.max(a.min, b.min);\n            int max = Math.min(a.max, b.max);\n            if( min <= max ) {\n                return new Range(min, max);\n            } else {\n                return null;\n            }\n        }\n\n        int min, max;\n\n        Range(int min, int max) {\n            if( max < min ) throw new IllegalArgumentException(\"wtf \" + min + \" \" + max);\n            this.min = min;\n            this.max = max;\n        }\n    }\n\n    @SuppressWarnings(\"unused\")\n    static class FastScanner {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer;\n\n        FastScanner(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n            tokenizer = null;\n        }\n\n        String next() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        String nextLine() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    return reader.readLine();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken(\"\\n\");\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n\n        int[] nextIntArray(int n, int delta) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt() + delta;\n            return a;\n        }\n\n        long[] nextLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextLong();\n            return a;\n        }\n    }\n\n    static <A> void writeLines(A[] as, Function<A, String> f) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (A a : as) {\n            pw.println(f.apply(a));\n        }\n        pw.flush();\n    }\n\n    static void writeLines(int[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (int a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static void writeLines(long[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (long a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static int max(int... as) {\n        int max = Integer.MIN_VALUE;\n        for (int a : as) max = Math.max(a, max);\n        return max;\n    }\n\n    static int min(int... as) {\n        int min = Integer.MAX_VALUE;\n        for (int a : as) min = Math.min(a, min);\n        return min;\n    }\n\n    static void debug(Object... args) {\n        StringJoiner j = new StringJoiner(\" \");\n        for (Object arg : args) {\n            if (arg instanceof int[]) j.add(Arrays.toString((int[]) arg));\n            else if (arg instanceof long[]) j.add(Arrays.toString((long[]) arg));\n            else if (arg instanceof double[]) j.add(Arrays.toString((double[]) arg));\n            else if (arg instanceof Object[]) j.add(Arrays.toString((Object[]) arg));\n            else j.add(arg.toString());\n        }\n        System.err.println(j.toString());\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nclass Main {\n    public class T{\n        int a,b,c;\n        T(int a,int b,int c){\n            this.a = a;\n            this.b = b;\n            this.c = c;\n        }\n    }\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N,M;\n        N = sc.nextInt();\n        M = sc.nextInt();\nN=100;\n        int[][][] need = new int[M][N][2];\n        for(int i = 0 ; i < M ; i++){\n            for(int j = 0 ; j < N ; j++){\n                need[i][j][0] = 0;\n                need[i][j][1] = (int)1e9;\n            }\n        }\n \n        for(int i = 0 ; i < M ; i++){\n            int K = sc.nextInt();\n            for(int j = 0 ; j < K ; j++){\n                int a = sc.nextInt() - 1;\n                String b = sc.next();\n                int c = sc.nextInt();\n                if( b.equals(\">=\") ){\n                    need[i][a][0] = Math.max(need[i][a][0],c);\n                }else{\n                    need[i][a][1] = Math.min(need[i][a][1],c);\n                }\n            }\n            // mujun\n            for(int j = 0 ; j < N ; j++){\n                if( need[i][j][0] > need[i][j][1] ){\n                    System.out.println(\"No\");\n                    return;\n                }\n            }\n        }\n        int[][] wf = new int[M][M];\n \n        for(int i = 0 ; i < M ; i++){\n            for(int j = 0 ; j < M ; j++){\n                for(int k = 0 ; k < N ; k++){\n                    if( need[i][k][1] < need[j][k][0] ){\n                        wf[i][j] = 1;\n                    }\n                }\n            }\n        }\n        for(int i = 0 ; i < M ; i++){\n            for(int j = 0 ; j < M ; j++ ){\n                for(int k = 0 ; k < M ; k++){\n                    wf[j][k] |= wf[j][i] & wf[i][k];\n                }\n            }\n        }\n        for(int i = 0 ; i < M ; i++)\n            if( wf[i][i] > 0 ){\n                System.out.println(\"No\");\n                return;\n            }\n        System.out.println(\"Yes\");\n        return;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nclass Problem2555 {\n\tpublic class T{\n\t\tint a,b,c;\n\t\tT(int a,int b,int c){\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t\tthis.c = c;\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N,M;\n\t\tM = sc.nextInt();\n\t\tN = sc.nextInt();\n\t\tint[][][] need = new int[M][N][2];\n\t\tfor(int i = 0 ; i < M ; i++){\n\t\t\tfor(int j = 0 ; j < N ; j++){\n\t\t\t\tneed[i][j][0] = 0;\n\t\t\t\tneed[i][j][1] = (int)1e9;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0 ; i < M ; i++){\n\t\t\tint K = sc.nextInt();\n\t\t\tfor(int j = 0 ; j < K ; j++){\n\t\t\t\tint a = sc.nextInt() - 1;\n\t\t\t\tString b = sc.next();\n\t\t\t\tint c = sc.nextInt();\n\t\t\t\tif( b.equals(\">=\") ){\n\t\t\t\t\tneed[i][a][0] = Math.max(need[i][a][0],c);\n\t\t\t\t}else{\n\t\t\t\t\tneed[i][a][1] = Math.min(need[i][a][1],c);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// mujun\n\t\t\tfor(int j = 0 ; j < N ; j++){\n\t\t\t\tif( need[i][j][0] > need[i][j][1] ){\n\t\t\t\t\tSystem.out.println(\"No\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//if(1>0)return;\n\t\tint[][] wf = new int[M][M];\n\n\t\tfor(int i = 0 ; i < M ; i++){\n\t\t\tfor(int j = 0 ; j < M ; j++){\n\t\t\t\tfor(int k = 0 ; k < N ; k++){\n\t\t\t\t\tif( need[i][k][1] < need[j][k][0] ){\n\t\t\t\t\t\twf[i][j] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0 ; i < M ; i++){\n\t\t\tfor(int j = 0 ; j < M ; j++ ){\n\t\t\t\tfor(int k = 0 ; k < M ; k++){\n\t\t\t\t\twf[j][k] |= wf[j][i] & wf[i][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0 ; i < M ; i++)\n\t\t\tif( wf[i][i] > 0 ){\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t\treturn;\n\t\t\t}\n\t\tSystem.out.println(\"Yes\");\n\t\treturn;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nclass Main {\n\tpublic class T{\n\t\tint a,b,c;\n\t\tT(int a,int b,int c){\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t\tthis.c = c;\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N,M;\n\t\tN = sc.nextInt();\n\t\tM = sc.nextInt();\n\t\tint[][][] need = new int[M][N][2];\n\t\tfor(int i = 0 ; i < M ; i++){\n\t\t\tfor(int j = 0 ; j < N ; j++){\n\t\t\t\tneed[i][j][0] = 0;\n\t\t\t\tneed[i][j][1] = (int)1e9;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0 ; i < M ; i++){\n\t\t\tint K = sc.nextInt();\n\t\t\tfor(int j = 0 ; j < K ; j++){\n\t\t\t\tint a = sc.nextInt() - 1;\n\t\t\t\tString b = sc.next();\n\t\t\t\tint c = sc.nextInt();\n\t\t\t\tif( b.equals(\">=\") ){\n\t\t\t\t\tneed[i][a][0] = Math.max(need[i][a][0],c);\n\t\t\t\t}else{\n\t\t\t\t\tneed[i][a][1] = Math.min(need[i][a][1],c);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// mujun\n\t\t\tfor(int j = 0 ; j < N ; j++){\n\t\t\t\tif( need[i][j][0] > need[i][j][1] ){\n\t\t\t\t\tSystem.out.println(\"No\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint[][] wf = new int[M][M];\n\n\t\tfor(int i = 0 ; i < M ; i++){\n\t\t\tfor(int j = 0 ; j < M ; j++){\n\t\t\t\tfor(int k = 0 ; k < N ; k++){\n\t\t\t\t\tif( need[i][k][1] < need[j][k][0] ){\n\t\t\t\t\t\twf[i][j] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0 ; i < M ; i++){\n\t\t\tfor(int j = 0 ; j < M ; j++ ){\n\t\t\t\tfor(int k = 0 ; k < M ; k++){\n\t\t\t\t\twf[j][k] |= wf[j][i] & wf[i][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0 ; i < M ; i++)\n\t\t\tif( wf[i][i] > 0 ){\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t\treturn;\n\t\t\t}\n\t\tSystem.out.println(\"Yes\");\n\t\treturn;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nclass Main {\n\tpublic class T{\n\t\tint a,b,c;\n\t\tT(int a,int b,int c){\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t\tthis.c = c;\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N,M;\n\t\tM = sc.nextInt();\n\t\tN = sc.nextInt();\n\t\tint[][][] need = new int[M][N][2];\n\t\tfor(int i = 0 ; i < M ; i++){\n\t\t\tfor(int j = 0 ; j < N ; j++){\n\t\t\t\tneed[i][j][0] = 0;\n\t\t\t\tneed[i][j][1] = (int)1e9;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0 ; i < M ; i++){\n\t\t\tint K = sc.nextInt();\n\t\t\tfor(int j = 0 ; j < K ; j++){\n\t\t\t\tint a = sc.nextInt() - 1;\n\t\t\t\tString b = sc.next();\n\t\t\t\tint c = sc.nextInt();\n\t\t\t\tif( b.equals(\">=\") ){\n\t\t\t\t\tneed[i][a][0] = Math.max(need[i][a][0],c);\n\t\t\t\t}else{\n\t\t\t\t\tneed[i][a][1] = Math.min(need[i][a][1],c);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// mujun\n\t\t\tfor(int j = 0 ; j < N ; j++){\n\t\t\t\tif( need[i][j][0] > need[i][j][1] ){\n\t\t\t\t\tSystem.out.println(\"No\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//if(1>0)return;\n\t\tint[][] wf = new int[M][M];\n\n\t\tfor(int i = 0 ; i < M ; i++){\n\t\t\tfor(int j = 0 ; j < M ; j++){\n\t\t\t\tfor(int k = 0 ; k < N ; k++){\n\t\t\t\t\tif( need[i][k][1] < need[j][k][0] ){\n\t\t\t\t\t\twf[i][j] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0 ; i < M ; i++){\n\t\t\tfor(int j = 0 ; j < M ; j++ ){\n\t\t\t\tfor(int k = 0 ; k < M ; k++){\n\t\t\t\t\twf[j][k] |= wf[j][i] & wf[i][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0 ; i < M ; i++)\n\t\t\tif( wf[i][i] > 0 ){\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t\treturn;\n\t\t\t}\n\t\tSystem.out.println(\"Yes\");\n\t\treturn;\n\t}\n}"
  },
  {
    "language": "Ruby",
    "code": "# Header {{{\ndef assert(p)\n  raise 'Assertion Failed' unless p\nend\n\n# Constants {{{\nINF = 10**9\n# }}}\n\n# IO {{{\nclass MyIO\n  def initialize\n    @input = $stdin\n    @output = $stdout\n  end\n\n  # @param filename [String]\n  def set_input(filename)\n    @input = File.open(filename, 'r')\n  end\n\n  def set_output(filename)\n    @output = File.open(filename, 'w')\n  end\n\n  def int\n    gets.to_i\n  end\n\n  def ints\n    split.map(&:to_i)\n  end\n\n  def split\n    @input.gets.chomp.split(' ')\n  end\n  alias_method :strings, :split\n\n  def gets\n    @input.gets.chomp\n  end\n\n  def puts(*args)\n    @output.puts(*args)\n  end\nend\n\nio = MyIO.new\n# }}}\n\n# Algorithms {{{\n\ndef lower_bound(arr, val)\n  assert(arr.is_a?(Array))\n  low, high = 0, arr.size\n  while high - low > 1\n    mid = (low + high) / 2\n    if arr[mid] < val\n      low = mid\n    else\n      high = mid\n    end\n  end\n  if arr[low] >= val\n    low\n  else\n    high\n  end\nend\n\ndef upper_bound(arr, val)\n  assert(arr.is_a?(Array))\n  low, high = 0, arr.size\n  while high - low > 1\n    mid = (low + high) / 2\n    if arr[mid] <= val\n      low = mid\n    else\n      high = mid\n    end\n  end\n  if arr[low] > val\n    low\n  else\n    high\n  end\nend\n\n# }}}\n\n# }}}\n\n# io.set_input('inputs/3.txt')\n\ncommands = []\nm, n = io.ints\n\nm.times do\n  conditions = []\n  k = io.int\n  k.times do\n    skill, cond, thresh = io.strings\n    skill = skill.to_i - 1\n    thresh = thresh.to_i\n    conditions << [skill, cond, thresh]\n  end\n  commands << conditions\nend\n\nskills = Array.new(n, 0)\nok = true\nwhile ok\n  skills = Array.new(n, 1e9)\n  commands.each do |conditions|\n    conditions.each do |condition|\n      skill, cond, thresh = condition\n      if cond == '<=' && skills[skill] > thresh\n        skills[skill] = thresh\n      end\n    end\n  end\n\n  ok = false\n  _s = commands.size\n  commands.delete_if do |conditions|\n    conditions.all? do |condition|\n      skill, cond, thresh = condition\n      (cond == '<=' && skills[skill] <= thresh) || (cond == '>=' && skills[skill] >= thresh)\n    end\n  end\n  ok = true if commands.size < _s\nend\n\nif commands.size == 0\n  puts 'Yes'\nelse\n  puts 'No'\nend\n\n# vim: foldmethod=marker"
  },
  {
    "language": "Ruby",
    "code": "m, n = gets.split.map(&:to_i)\n\ndimensions = (0..n).map { (0..m).map { [0, Float::INFINITY] } }\n\n(1..m).each do |i|\n    k = gets.to_i\n    k.times do\n        gets =~ /(\\d+) ([<>])= (\\d+)/\n        d, c, x = $1.to_i, $2, $3.to_i\n        if c == ?<\n            dimensions[d][i][1] = x if x < dimensions[d][i][1]\n        else\n            dimensions[d][i][0] = x if x > dimensions[d][i][0]\n        end\n        if dimensions[d][i][1] < dimensions[d][i][0]\n            puts 'No'\n            exit\n        end\n    end\nend\n\nrequire 'set'\nrequire 'tsort'\n\nclass Hash\n    include TSort\n    alias tsort_each_node each_key\n    def tsort_each_child(u)\n        self[u].each {|v| yield v}\n    end\nend\n\ng = {}\n(1..m).each {|i| g[i] = Set.new}\n\n(1..n).each do |d|\n    (1..m).to_a.combination(2) do |i, j|\n        u, v = dimensions[d][i], dimensions[d][j]\n        g[i] << j if u[1] < v[0]\n        g[j] << i if v[1] < u[0]\n    end\nend\n\nbegin\n    g.tsort\n    puts 'Yes'\nrescue\n    puts 'No'\nend"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    m,n = LI()\n    dp = collections.defaultdict(list)\n    dm = collections.defaultdict(list)\n    for i in range(m):\n        k = I()\n        for _ in range(k):\n            s, c, t = LS()\n            if c == '<=':\n                dm[int(s)].append((int(t), i))\n            else:\n                dp[int(s)].append((int(t), i))\n\n    e = collections.defaultdict(set)\n    for k in list(dm.keys()):\n        ml = dm[k]\n        pl = dp[k]\n        for tm, i in ml:\n            for tp, j in pl:\n                if tm < tp:\n                    e[i].add(j)\n\n    v = collections.defaultdict(int)\n\n    def f(i):\n        if v[i] == 2:\n            return True\n        if v[i] == 1:\n            return False\n        v[i] = 1\n\n        for n in e[i]:\n            if not f(n):\n                return False\n        v[i] = 2\n        return True\n\n    for i in range(m):\n        if not f(i):\n            return 'No'\n\n    return 'Yes'\n\n\n\n\nprint(main())\n\n"
  }
]