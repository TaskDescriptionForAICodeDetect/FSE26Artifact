[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_LEN 200005\n\nchar expr[MAX_LEN];\nint len;\n\nbool evaluate(int* pos, bool want_result);\n\nbool eval_term(int* pos, bool want_result) {\n    if (expr[*pos] == '?') {\n        (*pos)++;\n        return want_result;\n    }\n    \n    (*pos)++;  // skip '('\n    bool result = evaluate(pos, want_result);\n    (*pos)++;  // skip ')'\n    return result;\n}\n\nbool eval_and_expr(int* pos, bool want_result) {\n    bool current = eval_term(pos, want_result);\n    \n    while (*pos < len && expr[*pos] == '&') {\n        (*pos)++;\n        bool next = eval_term(pos, want_result);\n        \n        if (want_result) {\n            current &= next;\n        } else {\n            current &= !next;\n        }\n    }\n    \n    return current;\n}\n\nbool evaluate(int* pos, bool want_result) {\n    bool current = eval_and_expr(pos, want_result);\n    \n    while (*pos < len && expr[*pos] == '|') {\n        (*pos)++;\n        bool next = eval_and_expr(pos, want_result);\n        \n        if (want_result) {\n            current |= next;\n        } else {\n            current |= !next;\n        }\n    }\n    \n    return current;\n}\n\nint count_payments(bool want_result) {\n    int payments = 0;\n    int pos = 0;\n    \n    while (pos < len) {\n        int backup_pos = pos;\n        bool possible0 = false, possible1 = false;\n        \n        pos = backup_pos;\n        if (evaluate(&pos, false) == want_result) {\n            possible0 = true;\n        }\n        \n        pos = backup_pos;\n        if (evaluate(&pos, true) == want_result) {\n            possible1 = true;\n        }\n        \n        if (!possible0 && !possible1) {\n            return -1;\n        }\n        \n        if (!possible0 || !possible1) {\n            payments++;\n            pos = backup_pos;\n        }\n    }\n    \n    return payments;\n}\n\nint main() {\n    scanf(\"%s\", expr);\n    len = strlen(expr);\n    \n    int zero_payments = count_payments(false);\n    int one_payments = count_payments(true);\n    \n    printf(\"%d %d\\n\", zero_payments, one_payments);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:04:41"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define min(a, b) ((a) < (b) ? (a) : (b))\n#define max(a, b) ((a) > (b) ? (a) : (b))\n\ntypedef struct {\n    int cost0, cost1;\n} Node;\n\nNode merge_and(Node a, Node b) {\n    Node res;\n    res.cost0 = min(a.cost0 + b.cost0, min(a.cost0 + b.cost1, a.cost1 + b.cost0));\n    res.cost1 = a.cost1 + b.cost1;\n    return res;\n}\n\nNode merge_or(Node a, Node b) {\n    Node res;\n    res.cost0 = a.cost0 + b.cost0;\n    res.cost1 = min(a.cost1 + b.cost1, min(a.cost1 + b.cost0, a.cost0 + b.cost1));\n    return res;\n}\n\nNode parse_expr(const char **s);\n\nNode parse_term(const char **s) {\n    if (**s == '(') {\n        (*s)++;\n        Node res = parse_expr(s);\n        (*s)++; // skip ')'\n        return res;\n    } else if (**s == '?') {\n        (*s)++;\n        Node res = {1, 1};\n        return res;\n    } else {\n        Node res = {0, 0};\n        return res;\n    }\n}\n\nNode parse_and_expr(const char **s) {\n    Node res = parse_term(s);\n    while (**s == '&') {\n        (*s)++;\n        Node rhs = parse_term(s);\n        res = merge_and(res, rhs);\n    }\n    return res;\n}\n\nNode parse_or_expr(const char **s) {\n    Node res = parse_and_expr(s);\n    while (**s == '|') {\n        (*s)++;\n        Node rhs = parse_and_expr(s);\n        res = merge_or(res, rhs);\n    }\n    return res;\n}\n\nNode parse_expr(const char **s) {\n    return parse_or_expr(s);\n}\n\nint main() {\n    char *expr = NULL;\n    size_t len = 0;\n    getline(&expr, &len, stdin);\n    size_t n = strlen(expr);\n    if (n > 0 && expr[n-1] == '\\n') {\n        expr[n-1] = '\\0';\n    }\n    const char *ptr = expr;\n    Node res = parse_expr(&ptr);\n    printf(\"%d %d\\n\", res.cost0, res.cost1);\n    free(expr);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:05:06"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <algorithm>\nusing namespace std;\n\nstruct Node {\n    char op;\n    int left, right;\n    bool is_term;\n};\n\nvector<Node> nodes;\n\nint parse(const string &s, int &pos) {\n    if (s[pos] == '(') {\n        pos++;\n        int id = parse(s, pos);\n        pos++;\n        return id;\n    } else if (s[pos] == '?') {\n        pos++;\n        nodes.push_back({'?', -1, -1, true});\n        return nodes.size() - 1;\n    } else {\n        int left = parse(s, pos);\n        char op = s[pos++];\n        int right = parse(s, pos);\n        nodes.push_back({op, left, right, false});\n        return nodes.size() - 1;\n    }\n}\n\npair<int, int> dfs(int u, int target) {\n    if (nodes[u].is_term) {\n        if (target == 0) return {0, 1};\n        else return {1, 0};\n    }\n    auto left0 = dfs(nodes[u].left, 0);\n    auto left1 = dfs(nodes[u].left, 1);\n    auto right0 = dfs(nodes[u].right, 0);\n    auto right1 = dfs(nodes[u].right, 1);\n    \n    int cost0 = 0, cost1 = 0;\n    if (nodes[u].op == '&') {\n        if (target == 0) {\n            cost0 = min(left0.first + right0.first, min(left0.first + right1.first, left1.first + right0.first));\n            cost1 = left1.first + right1.first;\n        } else {\n            cost0 = left0.first + right0.first;\n            cost1 = left1.first + right1.first;\n        }\n    } else if (nodes[u].op == '|') {\n        if (target == 0) {\n            cost0 = left0.first + right0.first;\n            cost1 = left1.first + right1.first;\n        } else {\n            cost0 = left0.first + right1.first;\n            cost1 = min(left1.first + right0.first, min(left1.first + right1.first, left0.first + right1.first));\n        }\n    }\n    return {cost0, cost1};\n}\n\nint main() {\n    string s;\n    cin >> s;\n    int pos = 0;\n    int root = parse(s, pos);\n    auto res0 = dfs(root, 0);\n    auto res1 = dfs(root, 1);\n    cout << res0.first << \" \" << res1.first << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 22:05:33"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    static class Result {\n        int cost0, cost1;\n        Result(int cost0, int cost1) {\n            this.cost0 = cost0;\n            this.cost1 = cost1;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String s = scanner.nextLine();\n        Result res = parseOrExpr(new StringBuilder(s));\n        System.out.println(res.cost0 + \" \" + res.cost1);\n    }\n\n    static Result parseOrExpr(StringBuilder s) {\n        Result left = parseAndExpr(s);\n        while (s.length() > 0 && s.charAt(0) == '|') {\n            s.deleteCharAt(0);\n            Result right = parseAndExpr(s);\n            int newCost0 = Math.min(left.cost0, right.cost0);\n            int newCost1 = Math.min(left.cost1 + right.cost1, Math.min(left.cost1, right.cost1));\n            left = new Result(newCost0, newCost1);\n        }\n        return left;\n    }\n\n    static Result parseAndExpr(StringBuilder s) {\n        Result left = parseTerm(s);\n        while (s.length() > 0 && s.charAt(0) == '&') {\n            s.deleteCharAt(0);\n            Result right = parseTerm(s);\n            int newCost0 = Math.min(left.cost0 + right.cost0, Math.min(left.cost0, right.cost0));\n            int newCost1 = Math.min(left.cost1, right.cost1);\n            left = new Result(newCost0, newCost1);\n        }\n        return left;\n    }\n\n    static Result parseTerm(StringBuilder s) {\n        if (s.charAt(0) == '(') {\n            s.deleteCharAt(0);\n            Result res = parseOrExpr(s);\n            s.deleteCharAt(0); // Remove ')'\n            return res;\n        } else {\n            s.deleteCharAt(0); // Remove '?'\n            return new Result(1, 1);\n        }\n    }\n}",
    "timestamp": "2025-08-05 22:05:52"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class ChakkakuEvaluation {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String expression = scanner.nextLine();\n        \n        int[] result = solve(expression);\n        System.out.println(result[0] + \" \" + result[1]);\n    }\n    \n    static int[] solve(String expression) {\n        int minCost0 = dfs(expression, true);\n        int minCost1 = dfs(expression, false);\n        return new int[]{minCost0, minCost1};\n    }\n    \n    static int dfs(String expression, boolean targetResult) {\n        if (expression.length() == 0) return 0;\n        \n        List<String> subExprs = splitExpression(expression);\n        \n        if (subExprs.size() == 1) {\n            return processSimpleExpression(subExprs.get(0), targetResult);\n        }\n        \n        if (expression.contains(\"|\")) {\n            return handleOrExpression(subExprs, targetResult);\n        } else {\n            return handleAndExpression(subExprs, targetResult);\n        }\n    }\n    \n    static int processSimpleExpression(String expr, boolean targetResult) {\n        expr = expr.trim();\n        \n        if (expr.equals(\"?\")) {\n            return targetResult ? 1 : 1;\n        }\n        \n        if (expr.startsWith(\"(\") && expr.endsWith(\")\")) {\n            return dfs(expr.substring(1, expr.length() - 1), targetResult);\n        }\n        \n        return 0;\n    }\n    \n    static int handleOrExpression(List<String> subExprs, boolean targetResult) {\n        if (targetResult) {\n            int minCost = Integer.MAX_VALUE;\n            for (String subExpr : subExprs) {\n                int cost = dfs(subExpr, true);\n                minCost = Math.min(minCost, cost);\n            }\n            return minCost;\n        } else {\n            int totalCost = 0;\n            for (String subExpr : subExprs) {\n                totalCost += dfs(subExpr, false);\n            }\n            return totalCost;\n        }\n    }\n    \n    static int handleAndExpression(List<String> subExprs, boolean targetResult) {\n        if (!targetResult) {\n            int minCost = Integer.MAX_VALUE;\n            for (String subExpr : subExprs) {\n                int cost = dfs(subExpr, false);\n                minCost = Math.min(minCost, cost);\n            }\n            return minCost;\n        } else {\n            int totalCost = 0;\n            for (String subExpr : subExprs) {\n                totalCost += dfs(subExpr, true);\n            }\n            return totalCost;\n        }\n    }\n    \n    static List<String> splitExpression(String expression) {\n        List<String> result = new ArrayList<>();\n        int depth = 0;\n        StringBuilder current = new StringBuilder();\n        \n        for (char c : expression.toCharArray()) {\n            if (c == '(') depth++;\n            if (c == ')') depth--;\n            \n            current.append(c);\n            \n            if (depth == 0 && (c == '|' || c == '&')) {\n                result.add(current.substring(0, current.length() - 1).trim());\n                current = new StringBuilder();\n            }\n        }\n        \n        result.add(current.toString().trim());\n        return result;\n    }\n}",
    "timestamp": "2025-08-05 22:06:04"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint minCost(string s, bool targetResult) {\n    int n = s.length();\n    vector<int> depth(n, 0);\n    int curr = 0;\n    \n    for (int i = 0; i < n; i++) {\n        if (s[i] == '(') curr++;\n        else if (s[i] == ')') curr--;\n        depth[i] = curr;\n    }\n    \n    function<pair<int,int>(int,int,bool)> solve = \n    [&](int l, int r, bool target) -> pair<int,int> {\n        if (l > r) return {0, 0};\n        \n        // Single term case\n        if (l == r) {\n            if (s[l] == '?') return {target ? 1 : 0, target ? 0 : 1};\n            return {s[l] - '0' == target ? 0 : INT_MAX, INT_MAX};\n        }\n        \n        // Find main operator\n        int minDepth = INT_MAX, opIndex = -1;\n        int currMinDepth = INT_MAX;\n        for (int i = l; i <= r; i++) {\n            if (s[i] == '|' || s[i] == '&') {\n                if (depth[i] < minDepth) {\n                    minDepth = depth[i];\n                    opIndex = i;\n                }\n            }\n        }\n        \n        // No operator, parenthesized expression\n        if (opIndex == -1) {\n            if (s[l] == '(' && s[r] == ')') \n                return solve(l+1, r-1, target);\n            \n            if (s[l] == '?') return {target ? 1 : 0, target ? 0 : 1};\n            return {s[l] - '0' == target ? 0 : INT_MAX, INT_MAX};\n        }\n        \n        // Recursive solve for two subexpressions\n        if (s[opIndex] == '|') {\n            if (target) {\n                auto left = solve(l, opIndex-1, true);\n                auto right = solve(opIndex+1, r, true);\n                return {\n                    min(left.first + right.first, \n                        min(left.first + right.second, \n                            left.second + right.first)),\n                    INT_MAX\n                };\n            } else {\n                auto left = solve(l, opIndex-1, false);\n                auto right = solve(opIndex+1, r, false);\n                return {\n                    left.first + right.first,\n                    INT_MAX\n                };\n            }\n        } else { // '&'\n            if (target) {\n                auto left = solve(l, opIndex-1, true);\n                auto right = solve(opIndex+1, r, true);\n                return {\n                    left.first + right.first,\n                    INT_MAX\n                };\n            } else {\n                auto left = solve(l, opIndex-1, false);\n                auto right = solve(opIndex+1, r, false);\n                return {\n                    min(left.first + right.second, \n                        min(left.second + right.first, \n                            left.first + right.first)),\n                    INT_MAX\n                };\n            }\n        }\n    };\n    \n    auto result0 = solve(0, n-1, false);\n    auto result1 = solve(0, n-1, true);\n    \n    return min(result0.first, result1.first) + \n           min(result0.second, result1.second);\n}\n\nint main() {\n    string s;\n    cin >> s;\n    \n    int zeroCost = minCost(s, false);\n    int oneCost = minCost(s, true);\n    \n    cout << zeroCost << \" \" << oneCost << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:06:18"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def min_cost_to_evaluate(expression):\n    def solve(expr, target):\n        stack = []\n        cost = 0\n        for char in expr:\n            if char == ')':\n                temp = []\n                while stack and stack[-1] != '(':\n                    temp.append(stack.pop())\n                stack.pop()  # remove '('\n\n                if len(temp) == 1:\n                    stack.append(temp[0])\n                else:\n                    temp.reverse()\n                    while len(temp) > 1:\n                        a = temp.pop(0)\n                        op = temp.pop(0)\n                        b = temp.pop(0)\n                        if a == '?' or b == '?':\n                            cost += 1\n                            if op == '&':\n                                res = min(a if a != '?' else target, b if b != '?' else target) if target == 1 else 0\n                            else:  # op == '|'\n                                res = max(a if a != '?' else target, b if b != '?' else target) if target == 0 else 1\n                        else:\n                            if op == '&':\n                                res = a & b\n                            else:  # op == '|'\n                                res = a | b\n                        temp.insert(0, res)\n                    stack.append(temp[0])\n            else:\n                stack.append(char if char != '?' else target)\n        return cost\n    \n    cost0 = solve(expression, 0)\n    cost1 = solve(expression, 1)\n    return cost0, cost1\n\nexpression = input().strip()\nresult_0, result_1 = min_cost_to_evaluate(expression)\nprint(result_0, result_1)",
    "timestamp": "2025-08-13 08:55:39"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Stack;\nimport java.util.Scanner;\n\npublic class Main {\n    \n    static int[] evaluate(String s) {\n        Stack<Integer> values = new Stack<>();\n        Stack<Character> operators = new Stack<>();\n\n        int payForTrue = 0;\n        int payForFalse = 0;\n\n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            switch (c) {\n                case ' ':\n                    continue;\n                case '(':\n                    operators.push(c);\n                    break;\n                case '?':\n                    values.push(0);\n                    values.push(1);\n                    payForFalse++;\n                    payForTrue++;\n                    break;\n                case '1':\n                case '0':\n                    values.push(c - '0');\n                    break;\n                case ')':\n                    while (!operators.isEmpty() && operators.peek() != '(') {\n                        applyOperation(values, operators.pop());\n                    }\n                    operators.pop();\n                    break;\n                case '&':\n                case '|':\n                    while (!operators.isEmpty() && precedence(operators.peek()) >= precedence(c)) {\n                        applyOperation(values, operators.pop());\n                    }\n                    operators.push(c);\n                    break;\n            }\n        }\n\n        while (!operators.isEmpty()) {\n            applyOperation(values, operators.pop());\n        }\n\n        int finalValue = values.pop();\n\n        if (finalValue == 1) {\n            payForTrue = Math.min(payForTrue, payForTrue - 1);\n        } else {\n            payForFalse = Math.min(payForFalse, payForFalse - 1);\n        }\n\n        return new int[]{payForFalse, payForTrue};\n    }\n\n    static void applyOperation(Stack<Integer> values, char operator) {\n        int b = values.pop();\n        int a = values.pop();\n        switch (operator) {\n            case '&':\n                values.push(a & b);\n                break;\n            case '|':\n                values.push(a | b);\n                break;\n        }\n    }\n\n    static int precedence(char operator) {\n        switch (operator) {\n            case '&':\n                return 2;\n            case '|':\n                return 1;\n            default:\n                return 0;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String expression = scanner.nextLine();\n        scanner.close();\n\n        int[] results = evaluate(expression);\n\n        System.out.println(results[0] + \" \" + results[1]);\n    }\n}",
    "timestamp": "2025-08-13 08:55:45"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint evaluate_expression(const char *expr, char truthValue, int *cost) {\n    int length = strlen(expr);\n    int result = (truthValue == '1') ? 0 : 1; // 0 for '1', 1 for '0'\n    int stack[length], top = -1, minCost = 0;\n    int opStack[length], opTop = -1; // Operator stack to manage '&' or '|'\n\n    for (int i = 0; i < length; ++i) {\n        char ch = expr[i];\n\n        if (ch == '0' || ch == '1') {\n            stack[++top] = (ch == '1');\n        } else if (ch == '?') {\n            stack[++top] = truthValue == '1';\n            minCost++;\n        } else if (ch == '(') {\n            opStack[++opTop] = -1;\n        } else if (ch == ')') {\n            while (opTop >= 0 && opStack[opTop] != -1) {\n                int operation = opStack[opTop--];\n                int b = stack[top--];\n                int a = stack[top--];\n                stack[++top] = operation ? (a | b) : (a & b);\n            }\n            opTop--; // Pop '(' from op stack\n        } else if (ch == '&' || ch == '|') {\n            int currentOp = (ch == '|');\n            while (opTop >= 0 && opStack[opTop] != -1 && opStack[opTop] <= currentOp) {\n                int operation = opStack[opTop--];\n                int b = stack[top--];\n                int a = stack[top--];\n                stack[++top] = operation ? (a | b) : (a & b);\n            }\n            opStack[++opTop] = currentOp;\n        }\n    }\n\n    while (opTop >= 0) {\n        int operation = opStack[opTop--];\n        int b = stack[top--];\n        int a = stack[top--];\n        stack[++top] = operation ? (a | b) : (a & b);\n    }\n\n    result = stack[top];\n    *cost = minCost;\n    return result;\n}\n\nint main() {\n    char expr[200001];\n    scanf(\"%s\", expr);\n\n    int costTrue = 0, costFalse = 0;\n    evaluate_expression(expr, '0', &costFalse);\n    evaluate_expression(expr, '1', &costTrue);\n    \n    printf(\"%d %d\\n\", costFalse, costTrue);\n    return 0;\n}",
    "timestamp": "2025-08-13 08:55:50"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def evaluate(expr, values):\n    def parse_or(tokens):\n        nodes = [parse_and(tokens)]\n        while tokens and tokens[0] == '|':\n            tokens.pop(0)\n            nodes.append(parse_and(tokens))\n        return nodes\n\n    def parse_and(tokens):\n        nodes = [parse_term(tokens)]\n        while tokens and tokens[0] == '&':\n            tokens.pop(0)\n            nodes.append(parse_term(tokens))\n        return nodes\n\n    def parse_term(tokens):\n        if tokens[0] == '(':\n            tokens.pop(0)\n            node = parse_or(tokens)\n            tokens.pop(0)\n            return node\n        return tokens.pop(0)\n\n    def eval_or(node):\n        return any(eval_and(and_node) for and_node in node)\n\n    def eval_and(node):\n        return all(eval_term(term) for term in node)\n\n    def eval_term(term):\n        if term == '?':\n            return values.get(term, None)\n        elif term in ['0', '1']:\n            return term == '1'\n        else:\n            return eval_or(term)\n\n    tokens = list(expr)\n    return eval_or(parse_or(tokens))\n\ndef solve(expr):\n    def count_undetermined(expr):\n        return expr.count('?')\n\n    def min_cost(target):\n        n_question = count_undetermined(expr)\n        if n_question == 0:\n            result = evaluate(expr, {})\n            return 0 if result == (target == '1') else float('inf')\n\n        min_cost = float('inf')\n        for i in range(1 << n_question):\n            values = {}\n            cost = 0\n            question_index = 0\n\n            for j in range(len(expr)):\n                if expr[j] == '?':\n                    value = '1' if i & (1 << question_index) else '0'\n                    values[expr[j]] = value\n                    question_index += 1\n\n            result = evaluate(expr, values)\n            if result == (target == '1'):\n                min_cost = min(min_cost, bin(i).count('1'))\n\n        return min_cost if min_cost != float('inf') else 0\n\n    return f\"{min_cost('0')} {min_cost('1')}\"\n\n# Read input\nexpr = input().strip()\nprint(solve(expr))",
    "timestamp": "2025-08-13 08:56:04"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\n\ndef solve():\n    s = sys.stdin.readline().strip()\n    n = len(s)\n    \n    # We'll use a stack to evaluate the expression, keeping track of possible values and costs\n    # Each stack element is (val0, cost0, val1, cost1)\n    stack = []\n    \n    for c in s:\n        if c == '?':\n            stack.append((0, 0, 1, 0))\n        elif c == '0':\n            stack.append((0, 0, 0, float('inf')))\n        elif c == '1':\n            stack.append((1, float('inf'), 1, 0))\n        elif c == '&':\n            if len(stack) < 2:\n                continue  # should not happen for valid expressions\n            right = stack.pop()\n            left = stack.pop()\n            # For & operation:\n            # val0: min(left_val0 + right_val0, left_val0 + right_val1, left_val1 + right_val0)\n            # cost0: min(left_cost0 + min(right_cost0, right_cost1), left_cost1 + right_cost0, left_cost0 + right_cost1)\n            # val1: left_val1 & right_val1\n            # cost1: left_cost1 + right_cost1\n            val0 = min(left[0] + right[0], left[0] + right[2], left[2] + right[0])\n            cost0 = min(left[1] + min(right[1], right[3]), left[3] + right[1], left[1] + right[3])\n            val1 = left[2] & right[2]\n            cost1 = left[3] + right[3]\n            stack.append((val0, cost0, val1, cost1))\n        elif c == '|':\n            if len(stack) < 2:\n                continue\n            right = stack.pop()\n            left = stack.pop()\n            # For | operation:\n            # val0: left_val0 | right_val0\n            # cost0: left_cost0 + right_cost0\n            # val1: min(left_val1 + right_val0, left_val1 + right_val1, left_val0 + right_val1)\n            # cost1: min(left_cost1 + min(right_cost1, right_cost0), left_cost0 + right_cost1, left_cost1 + right_cost0)\n            val0 = left[0] | right[0]\n            cost0 = left[1] + right[1]\n            val1 = min(left[2] + right[0], left[2] + right[2], left[0] + right[2])\n            cost1 = min(left[3] + min(right[3], right[1]), left[1] + right[3], left[3] + right[1])\n            stack.append((val0, cost0, val1, cost1))\n        elif c == '(':\n            pass  # no action needed for '('\n        elif c == ')':\n            pass  # no action needed for ')'\n    \n    if not stack:\n        # should not happen for valid expressions\n        print(0, 0)\n        return\n    \n    top = stack[-1]\n    cost0 = top[1] if top[0] == 0 else float('inf')\n    cost1 = top[3] if top[2] == 1 else float('inf')\n    print(cost0, cost1)\n\nsolve()",
    "timestamp": "2025-08-13 08:56:29"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <string>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n// Custom structure to hold results for True and False costs.\nstruct Result {\n    int costToFalse;\n    int costToTrue;\n    Result(int f = 0, int t = 0) : costToFalse(f), costToTrue(t) {}\n};\n\n// Function to evaluate the costs of a subexpression.\nResult evaluate(string &s, int start, int end) {\n    stack<Result> operandStack;\n    stack<char> operatorStack;\n\n    for (int i = start; i <= end; ++i) {\n        char c = s[i];\n\n        if (c == '(') {\n            // Find the matching closing bracket\n            int bracketCount = 0, j;\n            for (j = i; j <= end; ++j) {\n                if (s[j] == '(') bracketCount++;\n                if (s[j] == ')') bracketCount--;\n                if (bracketCount == 0) break;\n            }\n            Result res = evaluate(s, i + 1, j - 1);\n            operandStack.push(res);\n            i = j;\n        } else if (c == '?') {\n            operandStack.push(Result(0, 0)); // For '?', initially zero cost for both true and false since it is uncertain.\n        } else if (c == '&' || c == '|') {\n            operatorStack.push(c);\n        } else if (isdigit(c)) {\n            int value = c - '0';\n            operandStack.push(Result(value == 0 ? 0 : INT_MAX, value == 1 ? 0 : INT_MAX));\n        }\n\n        while (operatorStack.size() > 0 && operandStack.size() >= 2) {\n            char op = operatorStack.top();\n            operatorStack.pop();\n\n            Result right = operandStack.top();\n            operandStack.pop();\n            Result left = operandStack.top();\n            operandStack.pop();\n\n            if (op == '&') {\n                Result newResult;\n                newResult.costToFalse = min(left.costToFalse, right.costToFalse);\n                newResult.costToTrue = min(left.costToTrue + right.costToTrue, \n                                            left.costToTrue + right.costToFalse + 1,\n                                            left.costToFalse + right.costToTrue + 1);\n               operandStack.push(newResult);\n            } else if (op == '|') { \n                Result newResult;\n                newResult.costToFalse = min(left.costToFalse + right.costToFalse,\n                                            left.costToTrue + right.costToFalse + 1,\n                                            left.costToFalse + right.costToTrue + 1);\n                newResult.costToTrue = min(left.costToTrue, right.costToTrue);\n                operandStack.push(newResult);\n            }\n        }\n    }\n    return operandStack.top();\n}\n\nint main() {\n    string expression;\n    cin >> expression;\n    Result res = evaluate(expression, 0, expression.size() - 1);\n    cout << res.costToFalse << \" \" << res.costToTrue << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 11:48:34"
  }
]