[
  {
    "language": "Scala",
    "code": "import scala.annotation.tailrec\nimport scala.io.StdIn._\nobject Main extends App {\n  readLine.trim match {\n    case Formula(f) ⇒\n      println(s\"${f.minCostToBeFalse} ${f.minCostToBeTrue}\")\n    case _ ⇒ ???\n  }\n\n  object Formula {\n    def unapply(arg: String): Option[Formula] = {\n      arg.toList match {\n        case o OrExpression Nil ⇒ Some(o)\n        case _ ⇒ None\n      }\n    }\n  }\n  object OrExpression {\n    def unapply(arg: List[Char]): Option[(OrExpression, List[Char])] = {\n      arg match {\n        case a AndExpression r ⇒ Some(takeAll(r, List(a)))\n        case _ ⇒ None\n      }\n    }\n\n    private def apply(arg: List[AndExpression]): OrExpression = {\n      val trues = arg.map(_.minCostToBeTrue)\n      val falses = arg.map(_.minCostToBeFalse)\n      val (trueCost, falseCost) = falses.zip(trues).foldLeft((Int.MaxValue, 0)){\n        case ((current, left), (f, t)) ⇒ (math.min(left + t, current), left + f)\n      }\n      new Impl(trueCost, falseCost)\n    }\n\n    @tailrec private[this] def takeAll(arg: List[Char], expression: List[AndExpression]): (OrExpression, List[Char]) = {\n      arg match {\n        case '|' :: (o AndExpression r) ⇒ takeAll(r, o :: expression)\n        case _ ⇒ (OrExpression(expression.reverse), arg)\n      }\n    }\n\n    class Impl(override val minCostToBeTrue: Int,\n               override val minCostToBeFalse: Int) extends OrExpression\n  }\n  object AndExpression {\n    def unapply(arg: List[Char]): Option[(AndExpression, List[Char])] = {\n      arg match {\n        case a Term r ⇒ Some(takeAll(r, List(a)))\n        case _ ⇒ None\n      }\n    }\n    private def apply(arg: List[Term]): AndExpression = {\n      val trues = arg.map(_.minCostToBeTrue)\n      val falses = arg.map(_.minCostToBeFalse)\n      val (falseCost, trueCost) = trues.zip(falses).foldLeft((Int.MaxValue, 0)){\n        case ((current, left), (t, f)) ⇒ (math.min(left + f, current), left + t)\n      }\n      new Impl(trueCost, falseCost)\n    }\n    @tailrec private[this] def takeAll(arg: List[Char], expression: List[Term]): (AndExpression, List[Char]) = {\n      arg match {\n        case '&':: (a Term r) ⇒ takeAll(r, a::expression)\n        case _ ⇒ (AndExpression(expression.reverse), arg)\n      }\n    }\n    class Impl(override val minCostToBeTrue: Int,\n               override val minCostToBeFalse: Int) extends AndExpression\n  }\n  object Term {\n    def unapply(arg: List[Char]): Option[(Term, List[Char])] = {\n      arg match {\n        case '('::(o OrExpression ')'::t) ⇒ Some(WithPer(o), t)\n        case '?'::t ⇒ Some(Undefined, t)\n        case _ ⇒ None\n      }\n    }\n  }\n  sealed trait Formula {\n    val minCostToBeTrue: Int\n    val minCostToBeFalse: Int\n  }\n  sealed trait OrExpression extends Formula\n  sealed trait AndExpression extends OrExpression\n  sealed trait Term extends AndExpression\n  case object Undefined extends Term {\n    val minCostToBeTrue: Int = 1\n    val minCostToBeFalse: Int = 1\n  }\n  case class WithPer(inner: Formula) extends Term {\n    val minCostToBeTrue: Int = inner.minCostToBeTrue\n    val minCostToBeFalse: Int = inner.minCostToBeFalse\n  }\n  implicit class Scope[T](val value: T) extends AnyVal {\n    def let[A](@inline func: T ⇒ A): A = func(value)\n    def also(@inline func: T ⇒ Unit): T = {func(value);value}\n    def minOption[A](implicit ev: T ⇒ Iterable[A], ord: Ordering[A]): Option[A] = if (value.isEmpty) None else Some(value.min)\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * \n */\n\n// header {{{\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define CPP_STR(x) CPP_STR_I(x)\n#define CPP_CAT(x,y) CPP_CAT_I(x,y)\n#define CPP_STR_I(args...) #args\n#define CPP_CAT_I(x,y) x ## y\n\n#define SFINAE(pred...) std::enable_if_t<(pred), std::nullptr_t> = nullptr\n\n#define ASSERT(expr...) assert((expr))\n\nusing i8  = int8_t;\nusing u8  = uint8_t;\nusing i16 = int16_t;\nusing u16 = uint16_t;\nusing i32 = int32_t;\nusing u32 = uint32_t;\nusing i64 = int64_t;\nusing u64 = uint64_t;\n\nusing f32 = float;\nusing f64 = double;\nusing f80 = __float80;\n// }}}\n\nconstexpr i64 INF  = INT64_C(1'010'000'000'000'000'017);\nconstexpr f64 FINF = 1e100;\n\nconstexpr i64 MOD = INT64_C(1'000'000'007);\n\nconstexpr f64 EPS = 1e-12;\n\nconstexpr f64 PI = 3.14159265358979323846;\n\n// util {{{\n#define FOR(i, start, end) for(i64 i = (start), CPP_CAT(i,xxxx_end)=(end); i < CPP_CAT(i,xxxx_end); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define ALL(f,c,...) (([&](decltype((c)) cccc) { return (f)(std::begin(cccc), std::end(cccc), ## __VA_ARGS__); })(c))\n\n#define LIFT(f) ([](auto&&... args) -> decltype(auto) { return (f)(std::forward<decltype(args)>(args)...); })\n\ntemplate<typename C>\nconstexpr i64 SIZE(const C& c) noexcept { return static_cast<i64>(c.size()); }\n\ntemplate<typename T, size_t N>\nconstexpr i64 SIZE(const T (&)[N]) noexcept { return static_cast<i64>(N); }\n\ntemplate<typename T, typename U, typename Comp=less<>>\nconstexpr bool chmax(T& xmax, const U& x, Comp comp={}) noexcept {\n    if(comp(xmax, x)) {\n        xmax = x;\n        return true;\n    }\n    return false;\n}\n\ntemplate<typename T, typename U, typename Comp=less<>>\nconstexpr bool chmin(T& xmin, const U& x, Comp comp={}) noexcept {\n    if(comp(x, xmin)) {\n        xmin = x;\n        return true;\n    }\n    return false;\n}\n\ntemplate<typename BinaryFunc, typename UnaryFunc>\nauto ON(BinaryFunc&& bf, UnaryFunc&& uf) {\n    return [bf=forward<BinaryFunc>(bf),uf=forward<UnaryFunc>(uf)](const auto& x, const auto& y) {\n        return bf(uf(x), uf(y));\n    };\n}\n\ntemplate<typename F>\nauto LT_ON(F&& f) {\n    return ON(less<>{}, forward<F>(f));\n}\n\ntemplate<typename F>\nauto GT_ON(F&& f) {\n    return ON(greater<>{}, forward<F>(f));\n}\n\ntemplate<typename F>\nauto EQ_ON(F&& f) {\n    return ON(equal_to<>{}, forward<F>(f));\n}\n\ntemplate<typename F>\nauto NE_ON(F&& f) {\n    return ON(not_equal_to<>{}, forward<F>(f));\n}\n\n// tuple {{{\ntemplate<i64 I=0, typename F, typename... TS, SFINAE(sizeof...(TS) == I)>\nvoid tuple_enumerate(tuple<TS...>&, F&&) {}\n\ntemplate<i64 I=0, typename F, typename... TS, SFINAE(sizeof...(TS) > I)>\nvoid tuple_enumerate(tuple<TS...>& t, F&& f) {\n    f(I, get<I>(t));\n    tuple_enumerate<I+1>(t, forward<F>(f));\n}\n\ntemplate<i64 I=0, typename F, typename... TS, SFINAE(sizeof...(TS) == I)>\nvoid tuple_enumerate(const tuple<TS...>&, F&&) {}\n\ntemplate<i64 I=0, typename F, typename... TS, SFINAE(sizeof...(TS) > I)>\nvoid tuple_enumerate(const tuple<TS...>& t, F&& f) {\n    f(I, get<I>(t));\n    tuple_enumerate<I+1>(t, forward<F>(f));\n}\n// }}}\n\n// container {{{\ntemplate<typename T> struct is_container : false_type {};\ntemplate<typename T, size_t N> struct is_container<array<T,N>> : true_type {};\ntemplate<typename... Args> struct is_container<vector<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<deque<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<list<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<forward_list<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<set<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<multiset<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<unordered_set<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<unordered_multiset<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<map<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<multimap<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<unordered_map<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<unordered_multimap<Args...>> : true_type {};\n\ntemplate<typename T, typename Enable=void>\nstruct ProconHash {\n    size_t operator()(const T& x) const noexcept {\n        return hash<T>{}(x);\n    }\n};\n\ntemplate<typename T>\nsize_t procon_hash_value(const T& x) noexcept {\n    return ProconHash<T>{}(x);\n}\n\nsize_t procon_hash_combine(size_t h1, size_t h2) noexcept {\n    constexpr size_t M = UINT64_C(0xc6a4a7935bd1e995);\n    constexpr int    R = 47;\n\n    h2 *= M;\n    h2 ^= h2 >> R;\n    h2 *= M;\n\n    h1 ^= h2;\n    h1 *= M;\n\n    h1 += 0xe6546b64;\n\n    return h1;\n}\n\ntemplate<typename T1, typename T2>\nstruct ProconHash<pair<T1,T2>> {\n    size_t operator()(const pair<T1,T2>& p) const noexcept {\n        size_t h1 = procon_hash_value(p.first);\n        size_t h2 = procon_hash_value(p.second);\n        return procon_hash_combine(h1, h2);\n    }\n};\n\ntemplate<typename... TS>\nstruct ProconHash<tuple<TS...>> {\n    size_t operator()(const tuple<TS...>& t) const noexcept {\n        size_t h = 0;\n        tuple_enumerate(t, [&h](const auto& e) {\n            h = procon_hash_combine(h, procon_hash_value(e));\n        });\n        return h;\n    }\n};\n\ntemplate<typename C>\nstruct ProconHash<C,enable_if_t<is_container<C>::value>> {\n    size_t operator()(const C& c) const noexcept {\n        size_t h = 0;\n        for(const auto& e : c)\n            h = procon_hash_combine(h, procon_hash_value(e));\n        return h;\n    }\n};\n\ntemplate<typename T, typename Hash=ProconHash<T>, typename Eq=equal_to<T>>\nusing HashSet = unordered_set<T,Hash,Eq>;\ntemplate<typename K, typename V, typename Hash=ProconHash<K>, typename Eq=equal_to<K>>\nusing HashMap = unordered_map<K,V,Hash,Eq>;\ntemplate<typename T, typename Hash=ProconHash<T>, typename Eq=equal_to<T>>\nusing HashMultiset = unordered_multiset<T,Hash,Eq>;\ntemplate<typename K, typename V, typename Hash=ProconHash<K>, typename Eq=equal_to<K>>\nusing HashMultimap = unordered_multimap<K,V,Hash,Eq>;\n\ntemplate<typename T>\nauto vec_make(i64 n, T x) {\n    return vector<T>(n, x);\n}\n\ntemplate<typename T, typename... Args, SFINAE(sizeof...(Args) >= 2)>\nauto vec_make(i64 n, Args... args) {\n    auto inner = vec_make<T>(args...);\n    return vector<decltype(inner)>(n, inner);\n}\n\ntemplate<typename T>\nauto vec_reserve(i64 cap) {\n    vector<T> res;\n    res.reserve(cap);\n    return res;\n}\n\ntemplate<typename T, typename Comp, typename Cont=vector<T>>\nauto priority_queue_make(const Comp& comp, Cont&& cont={}) {\n    return priority_queue<T,remove_reference_t<Cont>,Comp>(comp, forward<Cont>(cont));\n}\n\ntemplate<typename T, typename Comp>\nauto priority_queue_reserve(const Comp& comp, i64 cap) {\n    return priority_queue<T,vector<T>,Comp>(comp, vec_reserve<T>(cap));\n}\n\ntemplate<typename T, size_t N, size_t... NS>\nstruct ArrayType {\n    using type = array<typename ArrayType<T,NS...>::type,N>;\n};\n\ntemplate<typename T, size_t N>\nstruct ArrayType<T,N> {\n    using type = array<T,N>;\n};\n\ntemplate<typename T, size_t... NS>\nusing Array = typename ArrayType<T,NS...>::type;\n\ntemplate<typename T, size_t N>\nT& array_at(Array<T,N>& ary, i64 i) {\n    return ary[i];\n}\n\ntemplate<typename T, size_t N, size_t... NS, typename... Args>\nT& array_at(Array<T,N,NS...>& ary, i64 i, Args... args) {\n    return array_at<T,NS...>(ary[i], args...);\n}\n\ntemplate<typename T, size_t N>\nconst T& array_at(const Array<T,N>& ary, i64 i) {\n    return ary[i];\n}\n\ntemplate<typename T, size_t N, size_t... NS, typename... Args>\nconst T& array_at(const Array<T,N,NS...>& ary, i64 i, Args... args) {\n    return array_at<T,NS...>(ary[i], args...);\n}\n\ntemplate<typename T, typename C>\nT POP(stack<T,C>& stk) {\n    T x = stk.top(); stk.pop();\n    return x;\n}\n\ntemplate<typename T, typename C>\nT POP(queue<T,C>& que) {\n    T x = que.front(); que.pop();\n    return x;\n}\n\ntemplate<typename T, typename C, typename Comp>\nT POP(priority_queue<T,C,Comp>& que) {\n    T x = que.top(); que.pop();\n    return x;\n}\n// }}}\n\n// fixpoint {{{\ntemplate<typename F>\nclass FixPoint {\npublic:\n    explicit constexpr FixPoint(F&& f) : f_(forward<F>(f)) {}\n\n    template<typename... Args>\n    constexpr decltype(auto) operator()(Args&&... args) const {\n        return f_(*this, forward<Args>(args)...);\n    }\n\nprivate:\n    F f_;\n};\n\ntemplate<typename F>\nconstexpr decltype(auto) FIX(F&& f) {\n    return FixPoint<F>(forward<F>(f));\n}\n\ntemplate<typename F, size_t... NS>\nclass FixPointMemo {\npublic:\n    explicit FixPointMemo(F&& f) : f_(forward<F>(f)) {}\n\n    template<typename... Args>\n    decltype(auto) operator()(Args... args) const {\n        using R = decltype(f_(*this,args...));\n        static Array<bool,NS...> done {};\n        static Array<R,NS...>    memo;\n\n        if(!array_at<bool,NS...>(done,args...)) {\n            array_at<R,NS...>(memo,args...) = f_(*this,args...);\n            array_at<bool,NS...>(done,args...) = true;\n        }\n        return array_at<R,NS...>(memo,args...);\n    }\n\nprivate:\n    F f_;\n};\n\ntemplate<size_t... NS, typename F>\ndecltype(auto) FIXMEMO(F&& f) {\n    return FixPointMemo<F,NS...>(forward<F>(f));\n}\n// }}}\n\n// input {{{\ntemplate<typename T, typename Enable=void>\nstruct Scan {\n    static T scan(istream& in) {\n        T res;\n        in >> res;\n        return res;\n    }\n};\n\ntemplate<typename T, typename Enable=void>\nstruct Scan1;\n\ntemplate<typename T>\nstruct Scan1<T,enable_if_t<is_integral<T>::value && !is_same<T,bool>::value>> {\n    static T scan1(istream& in) {\n        return Scan<T>::scan(in) - 1;\n    }\n};\n\ntemplate<typename T=i64>\nT RD() {\n    return Scan<T>::scan(cin);\n}\n\ntemplate<typename T=i64>\nT RD1() {\n    return Scan1<T>::scan1(cin);\n}\n\ntemplate<typename T=i64>\nauto RD_VEC(i64 n) {\n    auto res = vec_reserve<T>(n);\n    REP(_, n) {\n        res.emplace_back(RD<T>());\n    }\n    return res;\n}\n\ntemplate<typename T=i64>\nauto RD1_VEC(i64 n) {\n    auto res = vec_reserve<T>(n);\n    REP(_, n) {\n        res.emplace_back(RD1<T>());\n    }\n    return res;\n}\n// }}}\n\n// output {{{\ntemplate<typename T, typename Enable=void>\nstruct Fmt {\n    static void fmt(ostream& out, const T& x) { out << x; }\n};\n\ntemplate<typename T>\nvoid fmt_write(ostream& out, const T& x) {\n    Fmt<T>::fmt(out, x);\n}\n\ntemplate<typename... TS>\nstruct Fmt<tuple<TS...>> {\n    static void fmt(ostream& out, const tuple<TS...>& t) {\n        tuple_enumerate(t, [&out](i64 i, const auto& e) {\n            if(i != 0) out << ' ';\n            fmt_write(out, e);\n        });\n    }\n};\n\ntemplate<typename T1, typename T2>\nstruct Fmt<pair<T1,T2>> {\n    static void fmt(ostream& out, const pair<T1,T2>& p) {\n        return fmt_write(out, make_tuple(p.first,p.second));\n    }\n};\n\ntemplate<typename C>\nstruct Fmt<C,enable_if_t<is_container<C>::value>> {\n    static void fmt(ostream& out, const C& c) {\n        for(auto it = begin(c); it != end(c); ++it) {\n            if(it != begin(c)) out << ' ';\n            fmt_write(out, *it);\n        }\n    }\n};\n\nvoid PRINT() {}\n\ntemplate<typename T, typename... TS>\nvoid PRINT(const T& x, const TS&... args) {\n    fmt_write(cout, x);\n    if(sizeof...(args) > 0) {\n        cout << ' ';\n        PRINT(args...);\n    }\n}\n\ntemplate<typename... TS>\nvoid PRINTLN(const TS&... args) {\n    PRINT(args...);\n    cout << '\\n';\n}\n// }}}\n\n// debug {{{\ntemplate<typename T, typename Enable=void>\nstruct Dbg {\n    static void dbg(ostream& out, const T& x) { out << x; }\n};\n\ntemplate<typename T>\nvoid dbg_write(ostream& out, const T& x) {\n    return Dbg<T>::dbg(out, x);\n}\n\ntemplate<>\nstruct Dbg<i64> {\n    static void dbg(ostream& out, i64 x) {\n        if(x == INF)\n            out << \"INF\";\n        else if(x == -INF)\n            out << \"-INF\";\n        else\n            out << x;\n    }\n};\n\ntemplate<>\nstruct Dbg<f64> {\n    static void dbg(ostream& out, f64 x) {\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wfloat-equal\"\n        if(x == FINF)\n            out << \"FINF\";\n        else if(x == -FINF)\n            out << \"-FINF\";\n        else\n            out << x;\n#pragma GCC diagnostic pop\n    }\n};\n\ntemplate<typename T, size_t N>\nstruct Dbg<T[N]> {\n    static void dbg(ostream& out, const T (&ary)[N]) {\n        out << \"[\";\n        REP(i, N) {\n            if(i != 0) out << \",\";\n            dbg_write(out, ary[i]);\n        }\n        out << \"]\";\n    }\n};\n\ntemplate<typename... TS>\nstruct Dbg<tuple<TS...>> {\n    static void dbg(ostream& out, const tuple<TS...>& t) {\n        out << \"(\";\n        tuple_enumerate(t, [&out](i64 i, const auto& e) {\n            if(i != 0) out << \",\";\n            dbg_write(out, e);\n        });\n        out << \")\";\n    }\n};\n\ntemplate<typename T1, typename T2>\nstruct Dbg<pair<T1,T2>> {\n    static void dbg(ostream& out, const pair<T1,T2>& p) {\n        return dbg_write(out, make_tuple(p.first,p.second));\n    }\n};\n\ntemplate<typename C>\nstruct Dbg<C,enable_if_t<is_container<C>::value>> {\n    static void dbg(ostream& out, const C& c) {\n        out << \"[\";\n        for(auto it = begin(c); it != end(c); ++it) {\n            if(it != begin(c)) out << \",\";\n            dbg_write(out, *it);\n        }\n        out << \"]\";\n    }\n};\n\ntemplate<typename T>\nvoid DBG_IMPL(i64 line, const char* expr, const T& value) {\n    cerr << \"[L \" << line << \"]: \";\n    cerr << expr << \" = \";\n    dbg_write(cerr, value);\n    cerr << \"\\n\";\n}\n\nvoid DBG_IMPL_HELPER() {}\n\ntemplate<typename T, typename... TS>\nvoid DBG_IMPL_HELPER(const T& x, const TS&... args) {\n    dbg_write(cerr, x);\n    if(sizeof...(args) > 0) {\n        cerr << \",\";\n        DBG_IMPL_HELPER(args...);\n    }\n}\n\ntemplate<typename... TS>\nvoid DBG_IMPL(i64 line, const char* expr, const TS&... value) {\n    cerr << \"[L \" << line << \"]: \";\n    cerr << \"(\" << expr << \") = (\";\n    DBG_IMPL_HELPER(value...);\n    cerr << \")\\n\";\n}\n\ntemplate<size_t N, typename T, SFINAE(rank<T>::value == 0)>\nvoid DBG_DP_IMPL_HELPER(ostream& out, const T& x, const array<i64,N>&, const array<i64,N>&) {\n    dbg_write(out, x);\n}\n\ntemplate<size_t N, typename T, SFINAE(rank<T>::value > 0)>\nvoid DBG_DP_IMPL_HELPER(ostream& out, const T& x, const array<i64,N>& sizes, const array<i64,N>& offs) {\n    i64 k   = N - rank<T>::value;\n    i64 off = offs[k];\n    i64 siz = sizes[k];\n    if(siz == 0) siz = extent<T>::value - off;\n\n    out << \"[\";\n    FOR(i, off, off+siz) {\n        if(i != off) out << \",\";\n        DBG_DP_IMPL_HELPER(out, x[i], sizes, offs);\n    }\n    out << \"]\";\n}\n\ntemplate<typename T, SFINAE(rank<T>::value > 0)>\nvoid DBG_DP_IMPL(i64 line, const char* expr, const T& dp,\n                 const array<i64,rank<T>::value>& sizes={},\n                 const array<i64,rank<T>::value>& offs={})\n{\n    cerr << \"[L \" << line << \"]: \";\n    cerr << expr << \" = \";\n    DBG_DP_IMPL_HELPER<rank<T>::value>(cerr, dp, sizes, offs);\n    cerr << \"\\n\";\n}\n\ntemplate<typename T>\nvoid DBG_GRID_IMPL(i64 line, const char* expr, const vector<T>& grid) {\n    cerr << \"[L \" << line << \"]: \";\n    cerr << expr << \":\\n\";\n    for(const auto& row : grid) {\n        dbg_write(cerr, row);\n        cerr << \"\\n\";\n    }\n    cerr << \"\\n\";\n}\n\n#ifdef PROCON_LOCAL\n    #define DBG(args...) DBG_IMPL(__LINE__, CPP_STR_I(args), args)\n    #define DBG_DP(args...) DBG_DP_IMPL(__LINE__, CPP_STR_I(args), args)\n    #define DBG_GRID(args...) DBG_GRID_IMPL(__LINE__, CPP_STR_I(args), args)\n#else\n    #define DBG(args...)\n    #define DBG_DP(args...)\n    #define DBG_GRID(args...)\n#endif\n// }}}\n\n// modint {{{\ntemplate<i64 P>\nstruct ModPT {\n    static_assert(P >= 2, \"P must be a prime\");\n    i64 v_;  // [0,P)\n\n    ModPT() : v_(0) {}\n    ModPT(i64 v) {\n        i64 r = v % P;\n        v_ = r >= 0 ? r : r+P;\n    }\n\n    ModPT operator-() const {\n        return ModPT(-v_);\n    }\n    ModPT& operator+=(ModPT rhs) {\n        v_ += rhs.v_;\n        v_ %= P;\n        return *this;\n    }\n    ModPT& operator-=(ModPT rhs) {\n        v_ += P;\n        v_ -= rhs.v_;\n        v_ %= P;\n        return *this;\n    }\n    ModPT& operator*=(ModPT rhs) {\n        v_ *= rhs.v_;\n        v_ %= P;\n        return *this;\n    }\n\n    ModPT& operator++() {\n        return *this += 1;\n    }\n    ModPT& operator--() {\n        return *this -= 1;\n    }\n    ModPT operator++(int) {\n        return exchange(*this, *this+1);\n    }\n    ModPT operator--(int) {\n        return exchange(*this, *this-1);\n    }\n\n    explicit operator i64() const { return v_; }\n};\n\ntemplate<i64 P>\nModPT<P> operator+(ModPT<P> lhs, ModPT<P> rhs) { return ModPT<P>(lhs) += rhs; }\ntemplate<i64 P>\nModPT<P> operator+(ModPT<P> lhs, i64 rhs) { return ModPT<P>(lhs) += rhs; }\ntemplate<i64 P>\nModPT<P> operator+(i64 lhs, ModPT<P> rhs) { return ModPT<P>(rhs) += lhs; }\ntemplate<i64 P>\nModPT<P> operator-(ModPT<P> lhs, ModPT<P> rhs) { return ModPT<P>(lhs) -= rhs; }\ntemplate<i64 P>\nModPT<P> operator-(ModPT<P> lhs, i64 rhs) { return ModPT<P>(lhs) -= rhs; }\ntemplate<i64 P>\nModPT<P> operator-(i64 lhs, ModPT<P> rhs) { return ModPT<P>(rhs) -= lhs; }\ntemplate<i64 P>\nModPT<P> operator*(ModPT<P> lhs, ModPT<P> rhs) { return ModPT<P>(lhs) *= rhs; }\ntemplate<i64 P>\nModPT<P> operator*(ModPT<P> lhs, i64 rhs) { return ModPT<P>(lhs) *= rhs; }\ntemplate<i64 P>\nModPT<P> operator*(i64 lhs, ModPT<P> rhs) { return ModPT<P>(rhs) *= lhs; }\n\ntemplate<i64 P>\nbool operator==(ModPT<P> lhs, ModPT<P> rhs) { return lhs.v_ == rhs.v_; }\ntemplate<i64 P>\nbool operator==(ModPT<P> lhs, i64 rhs) { return lhs == ModPT<P>(rhs); }\ntemplate<i64 P>\nbool operator==(i64 lhs, ModPT<P> rhs) { return ModPT<P>(lhs) == rhs; }\ntemplate<i64 P>\nbool operator!=(ModPT<P> lhs, ModPT<P> rhs) { return !(lhs == rhs); }\ntemplate<i64 P>\nbool operator!=(ModPT<P> lhs, i64 rhs) { return !(lhs == rhs); }\ntemplate<i64 P>\nbool operator!=(i64 lhs, ModPT<P> rhs) { return !(lhs == rhs); }\n\ntemplate<i64 P>\nstruct Scan<ModPT<P>> {\n    static ModPT<P> scan(istream& in) {\n        return Scan<i64>::scan(in);\n    }\n};\n\ntemplate<i64 P>\nstruct Fmt<ModPT<P>> {\n    static void fmt(ostream& out, ModPT<P> x) {\n        fmt_write(out, x.v_);\n    }\n};\n\ntemplate<i64 P>\nstruct Dbg<ModPT<P>> {\n    static void dbg(ostream& out, ModPT<P> x) {\n        dbg_write(out, x.v_);\n    }\n};\n\nusing ModP = ModPT<MOD>;\n// }}}\n// }}}\n\n// init {{{\nstruct ProconInit {\n    static constexpr int IOS_PREC = 15;\n    static constexpr bool AUTOFLUSH = false;\n\n    ProconInit() {\n        cin.tie(nullptr);\n        ios::sync_with_stdio(false);\n        cout << fixed << setprecision(IOS_PREC);\n#ifdef PROCON_LOCAL\n        cin.exceptions(ios::failbit | ios::badbit);\n        cerr << fixed << setprecision(IOS_PREC);\n#endif\n        if(AUTOFLUSH)\n            cout << unitbuf;\n    }\n} PROCON_INIT;\n// }}}\n\n//--------------------------------------------------------------------\n\nusing Ptr = const char*;\n\nusing Value = array<i64,2>;\n\nValue expr_or(Ptr& p);\n\nValue term(Ptr& p) {\n    if(*p == '?') {\n        ++p;\n        return { 1, 1 };\n    }\n\n    ASSERT(*p == '(');\n    ++p;  // skip '('\n    Value res = expr_or(p);\n    ASSERT(*p == ')');\n    ++p;  // skip ')'\n\n    return res;\n}\n\nValue expr_and(Ptr& p) {\n    Value lhs = term(p);\n    if(*p != '&') return lhs;\n\n    ++p;  // skip '&'\n    Value rhs = expr_and(p);\n    return {\n        min(lhs[0], lhs[1]+rhs[0]),\n        lhs[1]+rhs[1],\n    };\n}\n\nValue expr_or(Ptr& p) {\n    Value lhs = expr_and(p);\n    if(*p != '|') return lhs;\n\n    ++p;  // skip '|'\n    Value rhs = expr_or(p);\n    return {\n        lhs[0]+rhs[0],\n        min(lhs[1], lhs[0]+rhs[1]),\n    };\n}\n\nvoid solve() {\n    auto S = RD<string>();\n\n    Ptr p = S.c_str();\n    Value ans = expr_or(p);\n\n    PRINTLN(ans);\n}\n\nsigned main() {\n    \n\n    solve();\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*  -*- coding: utf-8 -*-\n *\n * 2962.cc: \n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 200000;\n\n/* typedef */\n\n/* global variables */\n\nchar s[MAX_N + 4];\n\n/* subroutines */\n\ninline void setmin(int &a, int b) { if (a > b) a = b; }\n\nvoid or_expr(char *(&cpt), int &a0, int &a1);\n\nvoid term(char *(&cpt), int &a0, int &a1) {\n  int pos = cpt - s;\n  if (*cpt == '(') {\n    cpt++; // '('\n    or_expr(cpt, a0, a1);\n    cpt++; // ')'\n  }\n  else {\n    cpt++; // '?'\n    a0 = a1 = 1;\n  }\n  //printf(\"term(%d)=(%d,%d)\\n\", pos, a0, a1);\n}\n\nvoid and_expr(char *(&cpt), int &a0, int &a1) {\n  int pos = cpt - s;\n  term(cpt, a0, a1);\n  while (*cpt == '&') {\n    cpt++; // '&'\n    int b0, b1;\n    term(cpt, b0, b1);\n    setmin(a0, a1 + b0);\n    a1 += b1;\n  }\n  //printf(\"and_expr(%d)=(%d,%d)\\n\", pos, a0, a1);\n}\n\nvoid or_expr(char *(&cpt), int &a0, int &a1) {\n  int pos = cpt - s;\n  and_expr(cpt, a0, a1);\n  while (*cpt == '|') {\n    cpt++; // '|'\n    int b0, b1;\n    and_expr(cpt, b0, b1);\n    setmin(a1, a0 + b1);\n    a0 += b0;\n  }\n  //printf(\"or_expr(%d)=(%d,%d)\\n\", pos, a0, a1);\n}\n\n/* main */\n\nint main() {\n  scanf(\"%s\", s);\n\n  char *cpt = s;\n  int a0, a1;\n  or_expr(cpt, a0, a1);\n  printf(\"%d %d\\n\", a0, a1);\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\nint inStackPriority[]={2,4,0,5},outStackPriority[]={1,3,5,0};//| & ( )\n\nint opToIndex[256];\n\nvoid init(){\n    opToIndex['|']=0;\n    opToIndex['&']=1;\n    opToIndex['(']=2;\n    opToIndex[')']=3;\n    opToIndex['\\n']=3;\n}\n\nint main(){\n    stack<int> valueStack[2];//true false\n    stack<int> ops;\n\n    init();\n    ops.push(2);\n    while(!ops.empty()){\n        char c=getchar();\n        if (c=='?'){\n           for(int i=0;i<=1;i++) valueStack[i].push(1);\n        //    puts(\"push ?\");\n        }else{\n            int cIndex=opToIndex[c];\n            while(inStackPriority[ops.top()]>=outStackPriority[cIndex]){\n                // puts(\"pop\");\n                int op=ops.top();\n                ops.pop();\n                if (op==2) break;\n                int tempOperand[2][2];//true false snd fst\n                for(int i=0;i<2;i++) \n                    for(int j=0;j<2;j++) \n                        tempOperand[i][j]=valueStack[i].top(),valueStack[i].pop();\n\n                if (op==0){\n                    valueStack[1].push(tempOperand[1][0]+tempOperand[1][1]);\n                    valueStack[0].push(min(tempOperand[0][1],tempOperand[1][1]+tempOperand[0][0]));\n                }else if (op==1){\n                    valueStack[0].push(tempOperand[0][0]+tempOperand[0][1]);\n                    valueStack[1].push(min(tempOperand[1][1],tempOperand[0][1]+tempOperand[1][0]));\n                }else{\n                    return -1;\n                }\n            }\n\n            if (cIndex!=3) ops.push(cIndex);\n            // puts(\"push op\");\n        }\n\n\n    };\n\n    printf(\"%d %d\\n\",valueStack[1].top(),valueStack[0].top());\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <string>\n#define llint long long\n#define inf 1e18\n\nusing namespace std;\ntypedef pair<llint, llint> P;\n\nstruct node{\n\tchar c;\n\tvector<int> vec;\n\tnode(){}\n\tnode(char c){\n\t\tthis->c = c;\n\t}\n};\n\nstring s;\nvector<node> tree;\nint dp[200005][2];\n\nint parseOR(int &p);\n\nint parseTerm(int &p)\n{\n\tif(s[p] == '('){\n\t\tp++;\n\t\tint ret = parseOR(p);\n\t\tp++;\n\t\treturn ret;\n\t}\n\telse if(s[p] == '?'){\n\t\ttree.push_back(node('?'));\n\t\tp++;\n\t\treturn tree.size()-1;\n\t}\n}\n\nint parseAND(int &p)\n{\n\ttree.push_back(node('&'));\n\tint root = tree.size()-1;\n\t\n\tint res = parseTerm(p);\n\ttree[root].vec.push_back(res);\n\t\n\twhile(1){\n\t\tif(s[p] == '&'){\n\t\t\tp++;\n\t\t\tint res = parseTerm(p);\n\t\t\ttree[root].vec.push_back(res);\n\t\t}\n\t\telse break;\n\t}\n\treturn root;\n}\n\nint parseOR(int &p)\n{\n\ttree.push_back(node('|'));\n\tint root = tree.size()-1;\n\t\n\tint res = parseAND(p);\n\ttree[root].vec.push_back(res);\n\t\n\twhile(1){\n\t\tif(s[p] == '|'){\n\t\t\tp++;\n\t\t\tint res = parseAND(p);\n\t\t\ttree[root].vec.push_back(res);\n\t\t}\n\t\telse break;\n\t}\n\treturn root;\n}\n\nvoid dfs(int v)\n{\n\t//cout << v << endl;\n\tfor(int i = 0; i < tree[v].vec.size(); i++) dfs(tree[v].vec[i]);\n\t\n\tdp[v][0] = dp[v][1] = 1e9;\n\tif(tree[v].c == '?') dp[v][0] = dp[v][1] = 1;\n\tif(tree[v].c == '|'){\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < tree[v].vec.size(); i++){\n\t\t\tint u = tree[v].vec[i];\n\t\t\tdp[v][1] = min(dp[v][1], sum + dp[u][1]);\n\t\t\tsum += dp[u][0];\n\t\t}\n\t\tdp[v][0] = sum;\n\t}\n\tif(tree[v].c == '&'){\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < tree[v].vec.size(); i++){\n\t\t\tint u = tree[v].vec[i];\n\t\t\tdp[v][0] = min(dp[v][0], sum + dp[u][0]);\n\t\t\tsum += dp[u][1];\n\t\t}\n\t\tdp[v][1] = sum;\n\t}\n}\n\nint main(void)\n{\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\t\n\tcin >> s;\n\ts += \"#\";\n\t\n\tint p = 0;\n\tint root = parseOR(p);\n\t\n\t/*for(int i = 0; i < tree.size(); i++){\n\t\tfor(int j = 0; j < tree[i].vec.size(); j++) cout << tree[i].vec[j] << \" \"; cout << endl;\n\t}*/\n\t\n\tdfs(root);\n\tcout << dp[root][0] << \" \" << dp[root][1] << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <algorithm>\n\nusing namespace std;\n\nchar peek(){\n    auto c=getchar();\n    ungetc(c,stdin);\n    return c;\n}\n\npair<int,int> foldor();\n\npair<int,int> foldand();\n\npair<int,int> foldbase();\n\npair<int,int> foldor(){\n    auto res=foldand();\n    while (peek()=='|'){\n        getchar();\n        auto temp=foldand();\n        auto trueCost=min(res.first,res.second+temp.first);\n        auto falseCost=res.second+temp.second;\n        res=pair<int,int>(trueCost,falseCost);\n    }\n\n    return res;\n}\n\npair<int,int> foldand(){\n    auto res=foldbase();\n    while (peek()=='&'){\n        getchar();\n        auto temp=foldbase();\n        auto trueCost=res.first+temp.first;\n        auto falseCost=min(res.second,res.first+temp.second);\n        res=pair<int,int>(trueCost,falseCost);\n    }\n\n    return res;\n}\n\npair<int,int> foldbase(){\n    if (peek()=='('){\n        getchar();\n        auto temp=foldor();\n        getchar();\n        return temp;\n    }\n    getchar();\n    return pair<int,int>(1,1);\n}\n\n\nint main(){\n\n    auto res=foldor();\n\n    printf(\"%d %d\\n\",res.second,res.first);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <stack>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <tuple>\n#include <assert.h>\n#include <deque>\n#include <bitset>\n#include <iomanip>\n#include <limits>\n#include <chrono>\n#include <random>\n#include <array>\n#include <unordered_map>\n#include <functional>\n#include <complex>\n#include <numeric>\n#include <cctype>\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\nconst long long MAX = 5100000;\nconst long long INF = 1LL << 60;\nconst long long mod = 1000000007LL;\n//const long long mod = 998244353LL;\n\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef long long ll;\n\ntypedef string::const_iterator State;\n\npair<int, int> expression(State& begin);\n\nstring s;\n\npair<int, int> factor(State& begin) {\n    if (*begin == '(') {\n        begin++; // '('を飛ばす。\n        auto ret = expression(begin);\n        begin++; // ')'を飛ばす。\n        return ret;\n    }\n    else {\n        begin++;\n        return { 1,1 };\n    }\n}\n\npair<int, int> term(State& begin) {\n    auto ret = factor(begin);\n    for (;begin != s.end();) {\n        //cout << *begin << endl;\n        if (*begin == '&') {\n            begin++;\n            auto p = factor(begin);\n            auto tmp = ret;\n            ret.second += p.second;\n            chmin(ret.first, tmp.second + p.first);\n        }\n        else {\n            break;\n        }\n    }\n\n    return ret;\n}\n\npair<int, int> expression(State& begin) {\n    //cout << *begin << endl;\n    auto ret = term(begin);\n\n    for (;begin != s.end();) {\n        if (*begin == '|') {\n            begin++;\n            auto p = term(begin);\n            auto tmp = ret;\n            ret.first += p.first;\n            chmin(ret.second, tmp.first + p.second);\n        }\n        else {\n            break;\n        }\n    }\n\n    return ret;\n}\n\n\n\nint main()\n{\n\t/*\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\t*/\n    cin >> s;\n    State begin = s.begin();\n    auto p = expression(begin);\n    cout << p.first << \" \" << p.second << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int mod = 1e9 + 7;\n\nconst int64 infll = (1LL << 60) - 1;\nconst int64 infll2 = (1LL << 58) - 1;\nconst int inf = (1 << 30) - 1;\n\n\ntemplate< typename T1, typename T2 >\nostream &operator<<(ostream &os, const pair< T1, T2 > &p) {\n  os << p.first << \" \" << p.second;\n  return os;\n}\n\ntemplate< typename T1, typename T2 >\nistream &operator>>(istream &is, pair< T1, T2 > &p) {\n  is >> p.first >> p.second;\n  return is;\n}\n\ntemplate< typename T >\nostream &operator<<(ostream &os, const vector< T > &v) {\n  for(int i = 0; i < (int) v.size(); i++) {\n    os << v[i] << (i + 1 != v.size() ? \" \" : \"\");\n  }\n  return os;\n}\n\ntemplate< typename T >\nistream &operator>>(istream &is, vector< T > &v) {\n  for(T &in : v) is >> in;\n  return is;\n}\n\ntemplate< typename T1, typename T2 >\ninline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\ntemplate< typename T1, typename T2 >\ninline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\ntemplate< typename T = int64 >\nvector< T > make_v(size_t a) {\n  return vector< T >(a);\n}\n\ntemplate< typename T, typename... Ts >\nauto make_v(size_t a, Ts... ts) {\n  return vector< decltype(make_v< T >(ts...)) >(a, make_v< T >(ts...));\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value == 0 >::type fill_v(T &t, const V &v) {\n  t = v;\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value != 0 >::type fill_v(T &t, const V &v) {\n  for(auto &e : t) fill_v(e, v);\n}\n\nconst int OR = 0;\nconst int AND = 1;\nconst int QUESTION = 3;\n\nmap< int, int > dp[2];\nint latte = 2;\n\nstruct Node {\n  int type;\n  int id;\n  vector< Node * > child;\n\n  Node(int t) : type(t), id(latte++) {}\n\n\n  int dfs(int v) {\n    if(dp[v].count(id)) {\n      return dp[v][id];\n    }\n    int ret = inf;\n\n    if(type == OR) {\n      if(v == 1) {\n        int add = 0;\n        for(auto &t : child) {\n          chmin(ret, t->dfs(v) + add);\n          add += min(t->dfs(0), t->dfs(1));\n        }\n      } else {\n        ret = 0;\n        for(auto &t : child) {\n          ret += t->dfs(v);\n        }\n      }\n    } else if(type == AND) {\n      if(v == 1) {\n        ret = 0;\n        for(auto &t : child) {\n          ret += t->dfs(v);\n        }\n      } else {\n        int add = 0;\n        for(auto &t : child) {\n          chmin(ret, t->dfs(v) + add);\n          add += min(t->dfs(0), t->dfs(1));\n        }\n      }\n    } else if(type == QUESTION) {\n      ret = 1;\n    } else {\n      assert(0);\n    }\n    return dp[v][id] = ret;\n  }\n};\n\nstring S;\nint ptr;\n\nNode *or_expr();\n\nNode *term() {\n  if(S[ptr] == '?') {\n    Node *cur = new Node(QUESTION);\n    ++ptr;\n    return cur;\n  } else if(S[ptr] == '(') {\n    ++ptr;\n    auto ret = or_expr();\n    ++ptr;\n    return ret;\n  } else {\n    assert(0);\n  }\n}\n\nNode *and_expr() {\n  Node *cur = new Node(AND);\n  cur->child.emplace_back(term());\n  while(S[ptr] == '&') {\n    ++ptr;\n    cur->child.emplace_back(term());\n  }\n  return cur;\n}\n\nNode *or_expr() {\n  Node *cur = new Node(OR);\n  cur->child.emplace_back(and_expr());\n  while(S[ptr] == '|') {\n    ++ptr;\n    cur->child.emplace_back(and_expr());\n  }\n  return cur;\n}\n\n\nvoid ushitapunichiakun(string arg) {\n  cin >> S;\n  S += \"$\";\n  auto root = or_expr();\n  cout << root->dfs(0) << \" \" << root->dfs(1) << endl;\n}\n\nint main() {\n  ushitapunichiakun(\"笑\");\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007\ntypedef long long ll;\nusing namespace std;\n\n#define mkp make_pair\ntypedef pair<int,int> P;\ntypedef string::const_iterator State;\n\nstring S;\n\nP formula(State &begin);\nP OrExpr(State &begin);\nP AndExpr(State &begin);\nP term(State &begin);\n\nP formula(State &begin){\n  return OrExpr(begin);\n}\n\nP OrExpr(State &begin){\n  int resa,resb;\n  tie(resa,resb)=AndExpr(begin);\n\n  for(;;){\n    if(*begin=='|'){\n      begin++;\n      int a,b;\n      tie(a,b)=AndExpr(begin);\n      resb=min(resb,resa+b);\n      resa+=a;\n    }else{\n      break;\n    }\n  }\n  return mkp(resa,resb);\n}\n\nP AndExpr(State &begin){\n  int resa,resb;\n  tie(resa,resb)=term(begin);\n\n  for(;;){\n    if(*begin=='&'){\n      begin++;\n      int a,b;\n      tie(a,b)=AndExpr(begin);\n      resa=min(resa,resb+a);\n      resb+=b;\n    }else{\n      break;\n    }\n  }\n  return mkp(resa,resb);\n}\n\nP term(State &begin){\n  int a=0,b=0;\n  if(*begin=='('){\n    begin++;\n    tie(a,b)=OrExpr(begin);\n    begin++;\n  }else{\n    tie(a,b)=mkp(1,1);\n    begin++;\n  }\n  return mkp(a,b);\n}\n\nint main(){\n  cin>>S;\n  State begin=S.begin();\n\n  int a,b;\n  tie(a,b)=formula(begin);\n  cout<<a<<\" \"<<b<<endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define ALL(a) (a).begin(), (a).end()\n#define llong long long\n\nusing namespace std;\nusing PI = pair<int,int>;\nconst int INF = (int)1e9;\n\nstring str;\n\n/*\n * formula \t= expr\n * expr \t= factor\n * \t\t\t| expr \"|\" factor\n * factor\t= term\n * \t\t\t| factor \"&\" term\n * term\t\t= \"(\" expr \")\" \n * \t\t\t| \"?\"\n */\nPI factor(int &i);\nPI term(int &i);\n\nPI expr(int &i){\n\tPI ret(0,INF);\n\n\twhile(i < str.size() && str[i] != ')'){\n\t\tauto tmp = factor(i);\n\t\tret = PI(ret.first + tmp.first, min(ret.second, ret.first + tmp.second));\n\t\tif(str[i] == '|')i++;\n\t}\n\t//\n\treturn ret;\n\t//\n}\n\nPI factor(int &i){\n\tPI ret(INF,0);\n\n\twhile(i < str.size() && str[i] != ')' && str[i] != '|'){\n\t\tauto tmp = term(i);\n\t\tret = PI(min(ret.first, ret.second + tmp.first), tmp.second + ret.second);\n\t\tif(str[i] == '&')i++;\n\t}\n\t//\n\treturn ret;\n}\n\nPI term(int &i){\n\tif(str[i] == '?'){\n\t\ti++;\n\t\treturn PI(1,1);\n\t}\n\tif(str[i] == '('){\n\t\tauto ret = expr(++i);\n\t\tassert(str[i] == ')');\n\t\ti++;\n\t\treturn ret;\n\t}\n\tassert(0);\n\treturn PI(-1,-1);\n}\n\nsigned main(){\n\tcin >> str;\n\tint i = 0;\n\tauto tmp = expr(i);\n\tcout << tmp.first << \" \" << tmp.second << endl;\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct data {\n  long long a, b;\n};\n\nlong long n;\nstring s;\n\nvoid solve();\ndata calcor(int &id);\ndata calcand(int &id);\ndata calcterm(int &id);\n\nint main() {\n  cin >> s;\n  n = s.size();\n  solve();\n  return 0;\n}\n\nvoid solve() {\n  int id = 0;\n  data res = calcor(id);\n  cout << res.a << \" \" << res.b << endl;\n}\n\ndata calcor(int &id) {\n  data res = {0, (long long)1e10};\n  vector<data> v;\n  while(id < n) {\n    v.push_back(calcand(id));\n    if(s[id] == '|')\n      ++id;\n    else\n      break;\n  }\n  for(int i = 0; i < v.size(); ++i) {\n    res.b = min(res.b, res.a + v[i].b);\n    res.a += v[i].a;\n  }\n  return res;\n}\ndata calcand(int &id) {\n  data res = {(long long)(1e10), 0};\n  vector<data> v;\n  while(id < n) {\n    v.push_back(calcterm(id));\n    if(s[id] == '&')\n      ++id;\n    else\n      break;\n  }\n  res.a = v[0].a;\n  for(int i = 0; i < v.size(); ++i) {\n    res.a = min(res.a, res.b + v[i].a);\n    res.b += v[i].b;\n  }\n  return res;\n}\n\ndata calcterm(int &id) {\n  data res = {1, 1};\n  if(s[id] == '(') {\n    res = calcor(++id);\n    assert(s[id] == ')');\n    ++id;\n    return res;\n  }\n  assert(s[id] == '?');\n  ++id;\n  return res;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct X{\n    int zero;\n    int one;\n};\n\nconst int INF=1e9;\nX or_expr(int &p,string& s);\nX and_expr(int &p,string& s);\nX term(int &p,string& s);\n\nX term(int& p,string& s){\n    if(s[p]=='('){\n        p++;\n        X ret=or_expr(p,s);\n        assert(s[p++]==')');\n        return ret;\n    }\n    else{\n        assert(s[p]=='?');\n        p++;\n        return X{1,1};\n    }\n}\nX and_expr(int &p,string& s){\n    vector<X> vec;\n    while(p<s.size() && s[p]!=')' && s[p]!='|'){\n        vec.push_back(term(p,s));\n        if(s[p]=='&') p++;\n    }\n    int zero=INF;\n    int sum=0;\n    for(int i=0;i<vec.size();i++){\n        zero=min(zero,sum+vec[i].zero);\n        sum+=vec[i].one;\n    }\n    int one=0;\n    for(int i=0;i<vec.size();i++){\n        one+=vec[i].one;\n    }\n    return X{zero,one};\n}\n\nX or_expr(int &p,string& s){\n    vector<X> vec;\n    while(p<s.size() && s[p]!=')'){\n        vec.push_back(and_expr(p,s));\n        if(s[p]=='|') p++;\n    }\n    int one=INF;\n    int sum=0;\n    for(int i=0;i<vec.size();i++){\n        one=min(one,sum+vec[i].one);\n        sum+=vec[i].zero;\n    }\n    int zero=0;\n    for(int i=0;i<vec.size();i++){\n        zero+=vec[i].zero;\n    }\n    return X{zero,one};\n}\nint main(){\n    string s;\n    cin>>s;\n    int p=0;\n    auto ret=or_expr(p,s);\n    cout<<ret.zero<<\" \"<<ret.one<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\n#include <complex>\n#include <array>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\ntypedef vector<double> VD;\ntypedef vector<VD> VVD;\n\ntemplate<typename T> void chmin(T &a, T b) { if (a > b) a = b; }\ntemplate<typename T> void chmax(T &a, T b) { if (a < b) a = b; }\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\nstring s;\n\nP calc(int &i){\n    vector<P> pa, po;\n    while (i < s.length() && s[i] != ')'){\n        P p;\n        if (s[i] == '('){\n            i++;\n            p = calc(i);\n        }else{\n            p = make_pair(1, 1);\n        }\n        i++;\n        pa.push_back(p);\n        if (s[i] == ')') break;\n        if (i < s.length() && s[i] == '|'){\n            P tmp(1e9, 0);\n            int s = 0;\n            for (P p : pa){\n                chmin(tmp.first, p.first + s);\n                tmp.second += p.second;\n                s += min(p.first, p.second);\n            }\n            po.push_back(tmp);\n            pa.clear();\n        }\n        i++;\n    }\n    {\n        P tmp(1e9, 0);\n        int s = 0;\n        for (P p : pa){\n            chmin(tmp.first, p.first + s);\n            tmp.second += p.second;\n            s += min(p.first, p.second);\n        }\n        po.push_back(tmp);\n        pa.clear();\n    }\n    P ret(0, 1e9);\n    int s = 0;\n    for (P p : po){\n        ret.first += p.first;\n        chmin(ret.second, p.second + s);\n        s += min(p.first, p.second);\n    }\n    return ret;\n}\n\nint main() {\n    cin >> s;\n    int i = 0;\n    P p = calc(i);\n    cout << p.first << \" \" << p.second << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define stoi stoll\nusing pii=pair<int,int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\n#define all(c) begin(c),end(c)\n#define rall(c) rbegin(c),rend(c)\n#define fore(x,c) for(auto &&x:c)\n#define rep(i,a,n) for(int i=a,i##len=(int)(n);i<i##len;++i)\n#define rrep(i, a, n) for(int i=(int)(n-1);i>=a;--i)\n#define sz(c) ((int)c.size())\n#define contains(c,x) (c.find(x)!=end(c))\n#define inseg(l,x,r) ((l)<=(x)&&(x)<(r))\n#define dump(...)\n#define pb push_back\n#define _ 0\nconst signed INF_=1001001001; const long long INF=1001001001001001001LL;\nconst int DX[9]={0,1,0,-1,1,1,-1,-1,0},DY[9]={-1,0,1,0,-1,1,1,-1,0};\ntemplate<class T> ostream& operator<<(ostream &os,const vector<T> &v) {\n    for (auto i = begin(v); i != end(v); i++) os<<*i<<(i==end(v)-1?\"\":\" \");return os;}\ntemplate<class T> istream& operator>>(istream &is,vector<T> &v) {\n    for (auto i = begin(v); i != end(v); i++) is>>*i;return is;}\ntemplate<class T,class U> istream& operator>>(istream &is, pair<T,U> &p) {\n    is>>p.first>>p.second;return is;}\ntemplate<class T, class U> bool chmax(T &a,const U &b){return a<b?a=b,1:0;}\ntemplate<class T, class U> bool chmin(T &a,const U &b){return a>b?a=b,1:0;}\ntemplate <class T> void psum(T& c) {partial_sum(begin(c), end(c), begin(c));}\ntemplate<class T> using heap=priority_queue<T,vector<T>,greater<T>>;\nstruct before_main_function {\n    before_main_function() {\n        cin.tie(nullptr); ios::sync_with_stdio(0);\n        cout << setprecision(15) << fixed;\n        // #define endl \"\\n\"\n    }\n} before_main_function;\n//------------------8<------------------------------------8<--------------------\n\nstring S;\nstruct State {\n    int i;\n    char check() {\n        if (i == S.size()) return '$';\n        return S[i];\n    }\n    char next() {\n        char ret = check();\n        i++;\n        return ret;\n    }\n};\n\nint or_exp(State &st, int p);\nint and_exp(State &st, int p);\nint term(State &st, int p);\n\npii memo_or[200005][2];\npii memo_and[200005][2];\n\nint or_exp(State &st, int p) {\n    auto &MEMO = memo_or[st.i][p];\n    if (MEMO.first != INF) {\n        st.i = MEMO.second;\n        return MEMO.first;\n    }\n\n    if (p) {\n        // 1\n        State bkup = st;\n        int zero = and_exp(st, 0);\n        st = bkup;\n        int one = and_exp(st, 1);\n        \n        int ret = one;\n        while (st.check() == '|') {\n            st.next();\n            bkup = st;\n            int tmp_z = and_exp(st, 0);\n            st = bkup;\n            int tmp_o = and_exp(st, 1);\n\n            chmin(ret, zero + tmp_o);\n            zero += tmp_z;\n        }\n        MEMO.second = st.i;\n        return MEMO.first = ret;\n    } else {\n        // 0\n        int ret = and_exp(st, 0);\n        while (st.check() == '|') {\n            st.next();\n            ret += and_exp(st, 0);\n        }\n        MEMO.second = st.i;\n        return MEMO.first = ret;\n    }\n}\nint and_exp(State &st, int p) {\n    auto &MEMO = memo_and[st.i][p];\n    if (MEMO.first != INF) {\n        st.i = MEMO.second;\n        return MEMO.first;\n    }\n\n    if (p) {\n        // 1\n        int ret = term(st, 1);\n        while (st.check() == '&') {\n            st.next();\n            ret += term(st, 1);\n        }\n        MEMO.second = st.i;\n        return MEMO.first = ret;\n    } else {\n        // 0\n        State bkup = st;\n        int zero = term(st, 0);\n        st = bkup;\n        int one = term(st, 1);\n        \n        int ret = zero;\n        while (st.check() == '&') {\n            st.next();\n            bkup = st;\n            int tmp_z = term(st, 0);\n            st = bkup;\n            int tmp_o = term(st, 1);\n\n            chmin(ret, one + tmp_z);\n            one += tmp_o;\n        }\n        MEMO.second = st.i;\n        return MEMO.first = ret;\n    }\n}\n\nint term(State &st, int p) {\n    if (st.check() == '(') {\n        st.next();\n        int ret = or_exp(st, p);\n        assert(st.check() == ')');\n        st.next();\n        return ret;\n    } else {\n        assert(st.check() == '?');\n        st.next();\n        return 1;\n    }\n}\n\nsigned main() {\n    rep(i, 0, 200005) rep(j, 0, 2) memo_or[i][j].first = INF;\n    rep(i, 0, 200005) rep(j, 0, 2) memo_and[i][j].first = INF;\n\n    cin >> S;\n    State st = {0};\n    int zero = or_exp(st, 0);\n    st = State {0};\n    int one;\n    one = or_exp(st, 1);\n    cout << zero << \" \" << one << endl;\n    return (0^_^0);\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n#define INF (int64)1e9\n#define REP(i, n) for(int64 i = 0; i < (n); i++)\n#define FOR(i, a, b) for(int64 i = (a); i < (b); i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing int64 = int_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\ntemplate<typename A, typename B> inline void chmin(A &a, B b) { if(a > b) a = b; }\ntemplate<typename A, typename B> inline void chmax(A &a, B b) { if(a < b) a = b; }\n\ntemplate<typename T>\nvector<T> make_v(size_t a) { return vector<T>(a); }\n\ntemplate<typename T, typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value!=0>::type\nfill_v(U &u,const V... v){u=U(v...);}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_v(U &u,const V... v){\n    for(auto &e:u) fill_v<T>(e,v...);\n}\n\nstring s;\n\nint64 om[212345][2], am[212345][2], term_m[212345][2];\nint64 om_s[212345][2], am_s[212345][2], term_m_s[212345][2];\nint64 or_exp(const string&, int64&, int64);\nint64 and_exp(const string&, int64&, int64);\nint64 term(const string&, int64&, int64);\n\nint64 formula(const string& s, int64& p, int64 tar) {\n    return or_exp(s, p, tar);\n}\n\nint64 or_exp(const string& s, int64& p, int64 tar) {\n    if (~om[p][tar]) {\n        int64 q = p;\n        p = om_s[p][tar];\n        return om[q][tar];\n    }\n    int64 q = p;\n    int64 &ret = om[p][tar], &rs = om_s[p][tar];\n    ret = and_exp(s, p, tar);\n//    cout << \"or \" << p << \" \" << q << \": \" << endl;\n    p = q;\n//    cout << \"or (\" << p << \" \" << q << \") \" << endl;\n    int64 sum = and_exp(s, p, 1-tar);\n//    cout << \"or (\" << p << \" \" << q << \") \" << endl;\n    while (p < s.size() && s[p] == '|') {\n        p++;\n        if (tar == 0) {\n            ret += and_exp(s, p, tar);\n        } else {\n            q = p;\n            chmin(ret, sum + and_exp(s, p, tar));\n            p = q;\n            sum += and_exp(s, p, 1-tar);\n        }\n    }\n//    cout << \"or \" << p << \" \" << tar << \" \" << ret << endl;\n    rs = p;\n    return ret;\n}\n\nint64 and_exp(const string& s, int64& p, int64 tar) {\n    if (~am[p][tar]) {\n        int64 q = p;\n        p = am_s[p][tar];\n        return am[q][tar];\n    }\n    int64 &ret = am[p][tar], &rs = am_s[p][tar];\n    int64 q = p;\n    ret = term(s, p, tar);\n    p = q;\n    int64 sum = term(s, p, 1-tar);\n//    cout << \"and (\" << q << \" \" << p << \") \" << endl;\n    while (p < s.size() && s[p] == '&') {\n        p++;\n        if (tar == 1) {\n            ret += term(s, p, tar);\n        } else {\n            q = p;\n            chmin(ret, sum + term(s, p, tar));\n            p = q;\n            sum += term(s, p, 1-tar);\n        }\n    }\n    rs = p;\n    return ret;\n}\n\nint64 term(const string& s, int64& p, int64 tar) {\n    if (~term_m[p][tar]) {\n        int64 q = p;\n        p = term_m_s[p][tar];\n        return term_m[q][tar];\n    }\n    int64& ret = term_m[p][tar], &rs = term_m_s[p][tar];\n    if (s[p] == '(') {\n        p++;\n        ret = or_exp(s, p, tar);\n        p++;\n    } else {\n        p++;\n        ret = 1;\n    }\n    rs = p;\n//    cout << \"term \" << p << \" \" << tar << \" \" << ret << endl;\n    return ret;\n}\n\nint main(void) {\n    memset(om, -1, sizeof om);\n    memset(am, -1, sizeof am);\n    memset(term_m, -1, sizeof term_m);\n    cin >> s;\n    REP(i, 2) {\n        int64 p = 0;\n        cout << formula(s, p, i) << (i == 0 ? \" \" : \"\");\n    }\n\n    cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for (int i = 0; i < n; i++)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<pi, pi> pp;\ntypedef pair<ll, ll> pl;\nconst double EPS = 1e-9;\nconst ll MOD = 1000000007;\nconst int inf = 1 << 30;\nconst ll linf = 1LL << 60;\n\nstring str;\nint to[200001];\n\npi sub(int st, int en) {\n    vector<pi> ands;\n    pi now = pi(0, MOD);\n    for (int i = st; i < en; i++) {\n        if (str[i] == '(') {\n            pi rec = sub(i+1, to[i]);\n            now.second = min(now.second, now.first + rec.second);\n            now.first += rec.first;\n            if (now.second == MOD) now.second = rec.second;\n            i = to[i];\n        } else if (str[i] == '?') {\n            now.second = min(now.second, now.first+1);\n            now.first++;\n        } else if (str[i] == '&') {\n        }\n        if (str[i] == '|' || i == en-1) {\n            ands.push_back(now);\n            now = pi(0,MOD);\n        }\n    }\n    /*\n    if (st == 0) {\n        rep(i,ands.size()) {\n            cout << ands[i].first << \" \" << ands[i].second << endl;\n        }\n    }\n    */\n\n    int one = ands[0].first;\n    int tmp = 0;\n    rep(i,ands.size()) {\n        one = min(one, tmp + ands[i].first);\n        tmp += ands[i].second;\n    }\n    int two = 0;\n    rep(i,ands.size()) {\n        two += ands[i].second;\n    }\n    return pi(one, two);\n}\n\nint main() {\n    cin >> str;\n    stack<int> par;\n    rep(i,str.size()) {\n        if (str[i] == '(') par.push(i);\n        if (str[i] == ')') {\n            to[par.top()] = i;\n            par.pop();\n        }\n    }\n    pi ans = sub(0, str.size());\n    cout << ans.second << \" \" << ans.first << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\nusing ll = long long;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\n\npair<int,int> sum(string& s,int& i);\npair<int,int> mul(string& s,int& i);\npair<int,int> bracket(string& s,int& i);\n\nbool isdigit(char c){\n    return c=='?';\n}\n\npair<int,int> sum(string& s,int& i){\n    pair<int,int> ret=mul(s,i);\n    while(s[i]=='|'){\n        char op=s[i];\n        i++;\n        pair<int,int> res=mul(s,i);\n        pair<int,int> nr;\n        nr.first=ret.first+res.first;\n        nr.second=min(ret.second,res.second+min(ret.first,ret.second));\n        ret=nr;\n    }\n    return ret;\n}\npair<int,int> mul(string&s,int& i){\n    pair<int,int> ret=bracket(s,i);\n    while(s[i]=='&'){\n        char op=s[i];\n        i++;\n        pair<int,int> res=bracket(s,i);\n        pair<int,int> nr;\n        nr.first=min(ret.first,res.first+min(ret.first,ret.second));\n        nr.second=ret.second+res.second;\n       ret=nr;\n    }\n    return ret;\n}\n\npair<int,int> bracket(string& s,int& i){\n    if(isdigit(s[i])){\n        ++i;\n        return {1,1};\n    }\n    i++;\n    pair<int,int> ret=sum(s,i);\n    i++;\n    return ret;\n}\n\n\nint main(){\n    string s;\n    cin>>s;\n    int i=0;\n    auto res = sum(s,i);\n    cout<<res.first<<\" \"<<res.second<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// vvvvvvvvvvvv TEMPLATE vvvvvvvvvvvv\n#include <bits/stdc++.h>\nusing namespace std; using ll = long long; using P = pair<ll, ll>;\nconst ll linf = 1e18; const double eps = 1e-12, pi = acos(-1);\n#define FOR(i,a,b) for (ll i=(a),__last_##i=(b);i<__last_##i;i++)\n#define RFOR(i,a,b) for (ll i=(b)-1,__last_##i=(a);i>=__last_##i;i--)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define __GET_MACRO3(_1, _2, _3, NAME, ...) NAME\n#define each(i,a) for (auto&& i : a)\n#define rep(...) __GET_MACRO3(__VA_ARGS__, FOR, REP)(__VA_ARGS__)\n#define rrep(...) __GET_MACRO3(__VA_ARGS__, RFOR, RREP)(__VA_ARGS__)\n#define pb push_back\n#define eb emplace_back\n#define all(a) begin(a),end(a)\n#define chmin(x,v) x = min(x, v)\n#define chmax(x,v) x = max(x, v)\ntemplate<typename T> ll min(ll a, const T&& b) { return a < b ? a : b; }\ntemplate<typename T> ll min(const T&& a, ll b) { return a < b ? a : b; }\ntemplate<typename T> ll max(ll a, const T&& b) { return a > b ? a : b; }\ntemplate<typename T> ll max(const T&& a, ll b) { return a > b ? a : b; }\ntemplate<typename Head> void out(Head h) { cout << h << endl; } template<typename Head, typename... Tail>void out(Head h, Tail... t) { cout << h << \" \"; out(t...); }\ntemplate<typename T> istream& operator>>(istream& is, vector<T>& v) { each(x,v) is >> x; return is; }\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<T>& v) { rep(i,v.size()) { if (i) os << \" \"; os << v[i]; } return os; }\nostream& operator<<(ostream& os, const vector<string>& v) { rep(i,v.size()) { if (i) os << endl; os << v[i]; } return os; }\ntemplate<typename T> ostream& operator<<(ostream& os, const vector<vector<T>>& v) { rep(i,v.size()) { if (i) os << endl; os << v[i]; } return os; }\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& os, const pair<T1, T2>& p) { return os << \"(\" << p.first << \", \" << p.second << \")\"; }\nstruct yes_no : std::numpunct<char> { string_type do_truename() const { return \"Yes\"; } string_type do_falsename() const { return \"No\"; } };\nvoid solve(); int main() {\n  ios::sync_with_stdio(false); cin.tie(0); locale loc(locale(), new yes_no); cout.imbue(loc); cout << fixed << setprecision(10) << boolalpha;\n  solve();\n}\n// ^^^^^^^^^^^^ TEMPLATE ^^^^^^^^^^^^\n\nstring s;\nll pos = 0;\n\nP parse_or();\n\nchar next_char() {\n  assert(pos < s.size());\n  return s[pos];\n}\nvoid read_char(char c) {\n  assert(s[pos++] == c);\n}\n\nP parse_term() {\n  if (next_char() == '(') {\n    read_char('(');\n    auto res = parse_or();\n    read_char(')');\n    return res;\n  }\n  read_char('?');\n  return P(1, 1);\n}\n\nP parse_and() {\n  P left = parse_term();\n  while (pos < s.size() && next_char() == '&') {\n    read_char('&');\n    P right = parse_term();\n    left = P(min(left.first, left.second + right.first), left.second + right.second);\n  }\n  return left;\n}\n\nP parse_or() {\n  P left = parse_and();\n  while (pos < s.size() && next_char() == '|') {\n    read_char('|');\n    P right = parse_and();\n    left = P(left.first + right.first, min(left.second, left.first + right.second));\n  }\n  return left;\n}\n\nP parse() {\n  return parse_or();\n}\n\nvoid solve() {\n  cin >> s;\n  auto ans = parse();\n  cout << ans.first << \" \" << ans.second << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 998244353;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef pair<ll, ll> LP;\ntypedef vector<int> vec;\ntypedef vector<string> svec;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-8;\n\n\nvec or_expr(string& s, int& i);\nvec and_expr(string& s, int& i);\nvec term(string& s, int& i);\n\nvec or_merge(vec a, vec b) {\n\tvec ret(3,mod);\n\tret[0] = a[0] + b[0];\n\trep(i, 3) {\n\t\tret[1] = min(ret[1], a[1] + b[i]);\n\t}\n\tret[1] = min(ret[1], a[0] + b[1]);\n\tret[2] = min({ ret[2],a[0] + b[2],a[2] + b[2] });\n\treturn ret;\n}\nvec and_merge(vec a, vec b) {\n\tvec ret(3,mod);\n\trep(i, 3) {\n\t\tret[0] = min(ret[0], a[0] + b[i]);\n\t}\n\tret[0] = min(ret[0], a[1] + b[0]);\n\tret[1] = a[1] + b[1];\n\tret[2] = min({ ret[2],a[1] + b[2],a[2] + b[2] });\n\treturn ret;\n}\nvec or_expr(string& s, int& i) {\n\tvec val = and_expr(s, i);\n\twhile (i < s.length() && s[i] == '|') {\n\t\ti++;\n\t\tvec val2 = and_expr(s, i);\n\t\tval = or_merge(val, val2);\n\t}\n\treturn val;\n}\nvec and_expr(string& s, int& i) {\n\tvec val = term(s, i);\n\twhile (i < s.length() && s[i] == '&') {\n\t\ti++;\n\t\tvec val2 = term(s, i);\n\t\tval = and_merge(val, val2);\n\t}\n\treturn val;\n}\nvec term(string& s, int& i) {\n\tif (i<s.length()&&s[i] == '?') {\n\t\ti++;\n\t\treturn vec { 1, 1, 0 };\n\t}\n\ti++;\n\tvec val = or_expr(s, i);\n\ti++;\n\treturn val;\n}\nvoid solve() {\n\tstring s; cin >> s;\n\tint i = 0;\n\tvec ans = or_expr(s, i);\n\tcout << ans[0] << \" \" << ans[1] << endl;\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\t//cout << fixed << setprecision(10);\n\t//init();\n\tsolve();\n\t//stop\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define INF 1001000100010001000\n#define MOD 1000000007\n#define EPS 1e-10\n#define int long long\n#define rep(i, N) for (int i = 0; i < N; i++)\n#define Rep(i, N) for (int i = 1; i < N; i++)\n#define For(i, a, b) for (int i = (a); i < (b); i++)\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define pii pair<int, int>\n#define vi vector<int>\n#define vvi vector<vi >\n#define vb vector<bool>\n#define vvb vector<vb >\n#define vp vector< pii >\n#define all(a) (a).begin(), (a).end()\n#define Int(x) int x; cin >> x;\n#define int2(x, y) Int(x); Int(y);\n#define int3(x, y, z) Int(x); int2(y, z);\n#define in(x, a, b) ((a) <= (x) && (x) < (b))\n#define fir first\n#define sec second\n#define ffir first.first\n#define fsec first.second\n#define sfir second.first\n#define ssec second.second\n#define Decimal fixed << setprecision(10)\n\n//int dxy[5] = {0, 1, 0, -1, 0};\n// cmd\n\nstring st;\nint p;\npii term_calc;\n\npii term();\npii and_expr();\npii or_expr();\n\npii term()\n{\n    pii ret;\n    if (st[p] == '(') {\n        p++;\n        ret = or_expr();\n        p++;\n        return ret;\n    } else if (st[p] == '?') {\n        p++;\n        return term_calc;\n    } else {\n        assert(0);\n        return {-1, -1};\n    }\n}\n\npii and_expr()\n{\n    pii ret = term();\n    int ret_1 = ret.first;\n    int ret_0 = ret.second;\n    int ret_sum = ret.first;\n    while (st[p] == '&') {\n        p++;\n        ret = and_expr();\n        ret_1 += ret.first;\n        ret_0 = min(ret_sum + ret.second, ret_0);\n        ret_sum += ret.first;\n    }\n    return {ret_1, ret_0};\n}\n\npii or_expr()\n{\n    pii ret = and_expr();\n    int ret_0 = ret.second;\n    int ret_1 = ret.first;\n    int ret_sum = ret.second;\n    while (st[p] == '|') {\n        p++;\n        ret = and_expr();\n        ret_0 += ret.second;\n        ret_1 = min(ret_sum + ret.first, ret_1);\n        ret_sum += ret.second;\n    }\n    return {ret_1, ret_0};\n}\n\nsigned main()\n{\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    term_calc = {1, 1};\n    cin >> st;\n    p = 0;\n\n    auto ans = or_expr();\n    std::cout << ans.sec << \" \" << ans.fir << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n#include <deque>\n#include <iomanip>\n#include <cstdio>\n#include <stack>\n#include <numeric>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf 1000000007\n#define mod 1000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\nint n;\nstring s;\n// 四則演算の式をパースして、その評価結果を返す。\npair<int,int> expression(int &begin);\n\n// 乗算除算の式をパースして、その評価結果を返す。\npair<int,int> term(int &begin);\n// 数字の列をパースして、その数を返す。\npair<int,int> number(int &begin);\npair<int,int> number(int &begin) {\n    int ret = 1;\n    begin++;\n    return MP(1,1);\n}\npair<int,int> factor(int &begin) {\n    if (s[begin]== '(') {\n        begin++; // '('を飛ばす。\n        pair<int,int> ret = expression(begin);\n        begin++; // ')'を飛ばす。\n        return ret;\n    } else {\n        return number(begin);\n    }\n}\npair<int,int> term(int &begin) {\n    pair<int,int> ret = factor(begin);\n    vector<pair<int,int> > v;\n    v.push_back(ret);\n    for (;;) {\n        if(begin==n)break;\n        if(s[begin]!='&')break;\n        begin++;\n        pair<int,int> p = factor(begin);\n        v.push_back(p);\n    }\n    pair<int,int> res=MP(inf,inf);\n    int smz = 0;\n    int smo = 0;\n    for(auto x:v){\n        res.first = min(res.first,smo + x.first);\n        smz += x.first;\n        smo += x.second;\n\n    }\n    res.second = min(res.second,smo);\n    \n    return res;\n}\n\npair<int,int> expression(int &begin) {\n    pair<int,int> ret = term(begin);\n    vector<pair<int,int> > v;\n    v.push_back(ret);\n    for (;;) {\n        if(begin==n)break;\n        if (s[begin] != '|') {\n           break;\n        }\n        begin++;\n        pair<int,int> p = term(begin);\n        v.push_back(p);\n    }\n    pair<int,int> res=MP(inf,inf);\n    int smz = 0;\n    int smo = 0;\n    for(auto x:v){\n        res.second = min(res.second,smz + x.second);\n        smz += x.first;\n        smo += x.second;\n\n    }\n    res.first = min(res.first,smz);\n    return res;\n}\nint main(){\n    cin >> s;\n    n = s.size();\n    int id = 0;\n    pair<int,int> res = expression(id);\n    cout << res.first << \" \" << res.second << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1e9 + 7;\nconst ll INF = 1e13;\n\nstruct Node {\n    char type;\n    vector<Node> child;\n    Node(char _type) {\n        type = _type;\n    }\n    void trav(string ind) {\n        cout << ind << type << endl;\n        for(Node node : child)\n            node.trav(ind + \" \");\n    }\n    int need0() {\n        if(type == '&') {\n            return min(child[0].need1() + child[1].need0(), child[0].need0());\n        } else if(type == '|') {\n            return child[0].need0() + child[1].need0();\n        } else {\n            return 1;\n        }\n    }\n    int need1() {\n        if(type == '|') {\n            return min(child[0].need0() + child[1].need1(), child[0].need1());\n        } else if(type == '&') {\n            return child[0].need1() + child[1].need1();\n        } else {\n            return 1;\n        }\n    }\n};\n\nint main() {\n    string S;\n    cin >> S;\n    stack<char> st;\n    vector<Node> nodes;\n    for(int i = 0; i < S.size(); ++i) {\n        char c = S[i];\n        if(c == '&') {\n            while(!st.empty() && st.top() == '&') {\n                nodes.push_back(Node('&'));\n                st.pop();\n            }\n            st.push('&');\n        } else if(c == '|') {\n            while(!st.empty() && st.top() != '(') {\n                nodes.push_back(Node(st.top()));\n                st.pop();\n            }\n            st.push('|');\n        } else if(c == '?') {\n            nodes.push_back(Node(c));\n        } else if(c == '(') {\n            st.push('(');\n        } else {\n            while(!st.empty() && st.top() != '(') {\n                nodes.push_back(Node(st.top()));\n                st.pop();\n            }\n            st.pop();\n        }\n    }\n    while(!st.empty()) {\n        nodes.push_back(Node(st.top()));\n        st.pop();\n    }\n    stack<Node> nst;\n    for(int i = 0; i < nodes.size(); ++i) {\n        Node node = nodes[i];\n        if(node.type == '?') {\n            nst.push(node);\n        } else if(node.type == '&') {\n            Node n2 = nst.top();\n            nst.pop();\n            Node n1 = nst.top();\n            nst.pop();\n            node.child.push_back(n1);\n            node.child.push_back(n2);\n            nst.push(node);\n        } else {\n            Node n2 = nst.top();\n            nst.pop();\n            Node n1 = nst.top();\n            nst.pop();\n            node.child.push_back(n1);\n            node.child.push_back(n2);\n            nst.push(node);\n        }\n    }\n    Node root = nst.top();\n    cout << root.need0() << \" \" << root.need1() << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #define DEBUGGING\n#include <bits/stdc++.h>\nusing namespace std;\n#define endl '\\n'\n#define ALL(V) (V).begin(), (V).end()\n#define ALLR(V) (V).rbegin(), (V).rend()\n\ntemplate <typename T> using V = vector<T>;\ntemplate <typename T> using VV = V<V<T>>;\nusing ll = int64_t;\nusing ull = uint64_t;\nusing PLL = pair<ll, ll>;\n\ntemplate <typename T> const T& var_min(const T &t) { return t; }\ntemplate <typename T> const T& var_max(const T &t) { return t; }\ntemplate <typename T, typename... Tail> const T& var_min(const T &t, const Tail&... tail) { return min(t, var_min(tail...)); }\ntemplate <typename T, typename... Tail> const T& var_max(const T &t, const Tail&... tail) { return max(t, var_max(tail...)); }\ntemplate <typename T, typename... Tail> void chmin(T &t, const Tail&... tail) { t = var_min(t, tail...); }\ntemplate <typename T, typename... Tail> void chmax(T &t, const Tail&... tail) { t = var_max(t, tail...); }\ntemplate <typename T> const T& clamp(const T &t, const T &low, const T &high) { return max(low, min(high, t)); }\ntemplate <typename T> void chclamp(T &t, const T &low, const T &high) { t = clamp(t, low, high); }\n\nnamespace init__ {\n\nstruct InitIO {\n    InitIO() {\n        cin.tie(nullptr);\n        ios_base::sync_with_stdio(false);\n        cout << fixed << setprecision(30);\n    }\n} init_io;\n\n}\n\n#ifdef DEBUGGING\n#include \"../../debug/debug.cpp\"\n#else\n#define DEBUG(...) 0\n#define DEBUG_SEPARATOR_LINE 0\n#endif\n\ntemplate <typename T>\nT make_v(T init) { return init; }\n\ntemplate <typename T, typename... Tail>\nauto make_v(T init, size_t s, Tail... tail) {\n#define rec make_v(init, tail...)\n    return V<decltype(rec)>(s, rec);\n#undef rec\n}\n\nusing Cost = PLL;\n\nvoid eat(const string &S, size_t &idx, char c) {\n    assert(S[idx] == c);\n    idx++;\n}\n\nCost calc_or_stmt(const string &S, size_t &idx);\nCost calc_and_stmt(const string &S, size_t &idx);\n\nCost calc_or_stmt(const string &S, size_t &idx) {\n    Cost ret;\n    bool init = true;\n    while(true) {\n        if(idx < S.size() && S[idx] == '|') eat(S, idx, '|');\n        else if(!init) break;\n\n        Cost res = calc_and_stmt(S, idx);\n        \n        if(init) {\n            ret = res;\n            init = false;\n        } else {\n            chmin(ret.first, ret.second + res.first);\n            ret.second += res.second;\n        }\n    }\n    return ret;\n}\n\nCost calc_and_stmt(const string &S, size_t &idx) {\n    Cost ret;\n    bool init = true;\n    while(true) {\n        if(idx < S.size() && S[idx] == '&') eat(S, idx, '&');\n        else if(!init) break;\n\n        Cost res;\n        if(S[idx] == '(') {\n            eat(S, idx, '(');\n            res = calc_or_stmt(S, idx);\n            eat(S, idx, ')');\n            DEBUG(res);\n        } else {\n            eat(S, idx, '?');\n            res = Cost(1, 1);\n        }\n\n        if(init) {\n            ret = res;\n            init = false;\n        } else {\n            chmin(ret.second, ret.first + res.second);\n            ret.first += res.first;\n        }\n    }\n    DEBUG(ret);\n    return ret;\n}\n\nint main() {\n    string S;\n    cin >> S;\n    size_t idx = 0;\n    auto res = calc_or_stmt(S, idx);\n    cout << res.second << ' ' << res.first << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing pii = pair<int,int>;\nusing pll = pair<ll,ll>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\n\nusing _loop_int = int;\n#define REP(i,n) for(_loop_int i=0; i<(_loop_int)(n); i++)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a); i<(_loop_int)(b); i++)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1; i>=(_loop_int)(a); i--)\n\n#define CHMIN(a,b) (a)=min((a),(b))\n#define CHMAX(a,b) (a)=max((a),(b))\n#define ALL(v) (v).begin(),(v).end()\n\n#define DEBUG(x) cerr<<#x<<\": \"<<(x)<<endl\n#define DEBUG_VEC(v) cerr<<#v<<\": \";REP(__i,(v).size())cerr<<((v)[__i])<<\", \";cerr<<endl\n\nconst ll MOD = 1000000007ll;\n\nchar s[252521];\nint it;\n\npii f_or();\npii f_and();\npii f_term();\n\npii f_or(){\n    pii v = f_and();\n    pii ret(-1, v.second);\n    int sum = v.first;\n    while(s[it]=='|'){\n        it++;\n        pii v = f_and();\n        CHMIN(ret.second, sum+v.second);\n        sum += v.first;\n    }\n    ret.first = sum;\n    return ret;\n}\npii f_and(){\n    pii v = f_term();\n    pii ret(v.first, -1);\n    int sum = v.second;\n    while(s[it]=='&'){\n        it++;\n        pii v = f_term();\n        CHMIN(ret.first, sum+v.first);\n        sum += v.second;\n    }\n    ret.second = sum;\n    return ret;\n}\npii f_term(){\n    if(s[it]=='('){\n        it++;\n        pii ret = f_or();\n        it++;\n        return ret;\n    }else{\n        it++;\n        return pii(1,1);\n    }\n}\n\nint main(){\n    scanf(\"%s\",s);\n    it = 0;\n    pii ans = f_or();\n    printf(\"%d %d\\n\",ans.first,ans.second);\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <complex>\n//#include <deque>\n#include <valarray>\n#include <unordered_map>\n#include <unordered_set>\n#include <array>\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest& ...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int w_=0; w_<n; ++w_){MACRO_VEC_ROW_Scan(w_, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest& ...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest& ...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& R:c)for(auto& w:R)std::cin>>w;\n// output\n#define OUT(dist) std::cout<<(dist);\n#define FOUT(n, dist) std::cout<<std::fixed<<std::setprecision(n)<<(dist);\n#define SOUT(n, c, dist) std::cout<<std::setw(n)<<std::setfill(c)<<(dist);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(w, n) std::cout<<(w + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(dist) {std::cerr << #dist << \"\\t:\" << (dist) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n#define SHOWSTACK(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.top() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(w, a, n) for(int w=(a);w<(n);++w)\n#define RFOR(w, a, n) for(int w=(n)-1;w>=(a);--w)\n#define REP(w, n) for(int w=0;w<int(n);++w)\n#define RREP(w, n) for(int w=int(n)-1;w>=0;--w)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<class T> inline T CHMAX(T & a, const T b) { return a = (a < b) ? b : a; }\ntemplate<class T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n// test\ntemplate<class T> using V = std::vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n#define random_shuffle \"USE std::shuffle!\";\n\n// type/const\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = (1 << 30) - 1;                    // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-10;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T & val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T & val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T> & a, const T & val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>> & a, const T & val) { for (auto& b : a) FILL(b, val); }\n// ------------>8------------------------------------->8------------\n\nusing State = std::string::iterator;\n\nPAIR calc(V<PAIR> a, bool f) { // ()|()|()\n\tPAIR ans;\n\tans.second = INFINT;\n\tint sum = 0;\n\tREP(i, a.size()) {\n\t\tif (!f) std::swap(a[i].first, a[i].second);\n\t\tans.first += a[i].first;\n\t\tCHMIN(ans.second, sum + a[i].second);\n\t\tsum += a[i].first;\n\t}\n\tif (!f) std::swap(ans.first, ans.second);\n\treturn ans;\n}\n\nPAIR expression(State& it);\n\n\nPAIR term(State& it) {\n\tV<PAIR> a;\n\twhile (true) {\n\t\tif (*it == '(') {\n\t\t\t++it;\n\t\t\ta.emplace_back(expression(it));\n\t\t\t++it;\n\t\t}\n\t\telse if (*it == '?') {\n\t\t\t++it;\n\t\t\ta.emplace_back(PAIR(1, 1));\n\t\t}\n\t\telse if (*it == '&') {\n\t\t\t++it;\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn calc(a, false);\n}\n\nPAIR expression(State& it) {\n\tPAIR first(term(it));\n\tV<PAIR> a({ first });\n\twhile (true) {\n\t\tif (*it == '|') {\n\t\t\t++it;\n\t\t\ta.emplace_back(term(it));\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn calc(a, true);\n}\n\nsigned main() {\n\tINIT;\n\n\tVAR(std::string, s);\n\ts += '$';\n\tauto it = s.begin();\n\tPAIR p = expression(it);\n\tOUT(p.first)SP OUT(p.second)BR;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\ntemplate <class T> using treap = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\n#define int long long\n#define REP(i, n) for (long long i = 0, max_i = (n); i < max_i; i++)\n#define REPI(i, a, b) for (long long i = (a), max_i = (b); i < max_i; i++)\n#define ALL(obj) begin(obj), end(obj)\n#define RALL(obj) rbegin(obj), rend(obj)\n#define fi first\n#define se second\nusing ii = pair<int, int>;\nvector<ii> dirs = {\n  {1, 0}, {0, 1}, {-1, 0}, {0, -1},  // 4方向\n  {1, 1}, {-1, 1}, {-1, -1}, {1, -1},  // 斜め\n  {0, 0},  // 自身\n};\ntemplate <class T> inline bool chmax(T& a, const T& b) { if (a < b) { a = b; return true; } return false; }\ntemplate <class T> inline bool chmin(T& a, const T& b) { if (a > b) { a = b; return true; } return false; }\ntemplate <class T, class S> vector<T> make_vec(size_t n, S x) { return vector<T>(n, x); }\ntemplate <class T, class... Ts> auto make_vec(size_t n, Ts... ts) { return vector<decltype(make_vec<T>(ts...))>(n, make_vec<T>(ts...)); }\n\n// debug\ntemplate <class T> ostream& operator<<(ostream& s, vector<T>& d) { REP (i, d.size()) s << d[i] << (i == d.size() - 1 ? \"\" : \" \"); return s; }\ntemplate <class T> ostream& operator<<(ostream& s, vector<vector<T>>& d) { REP (i, d.size()) s << d[i] << (i == d.size() - 1 ? \"\" : \"\\n\"); return s; }\ntemplate <class T, class S> ostream& operator<<(ostream& s, pair<T, S>& p) { s << \"{\" << p.first << \", \" << p.second << \"}\"; return s; }\ntemplate <class T, class S> ostream& operator<<(ostream& s, map<T, S> m) { for (auto it = m.begin(); it != m.end(); it++) { s << *it << (next(it) == m.end() ? \"\" : \"\\n\"); } return s; }\ntemplate <class T, class S> ostream& operator<<(ostream& s, unordered_map<T, S> m) { for (auto it = m.begin(); it != m.end(); it++) { s << *it << (next(it) == m.end() ? \"\" : \"\\n\"); } return s; }\n#ifdef _MY_DEBUG\n  #define dump(...) cerr << \"/* \" << #__VA_ARGS__ << \" :[\" << __LINE__ << \":\" << __FUNCTION__ << \"]\" << endl, dump_func(__VA_ARGS__), cerr << \"*/\\n\\n\";\n#else\n  #define dump(...)\n  #define endl \"\\n\"\n#endif\nvoid dump_func() { cerr << endl; }\ntemplate <class Head, class... Tail> void dump_func(Head&& h, Tail&&... t) { cerr << h << (sizeof...(Tail) == 0 ? \"\" : \", \"), dump_func(forward<Tail>(t)...); }\n\nstruct Fast { Fast() { cin.tie(0); ios::sync_with_stdio(false); } } fast;\nmt19937 rnd(chrono::steady_clock::now().time_since_epoch().count());\nconstexpr int MOD = 1000000007;\n// *************** TEMPLATE END *************** \n\nii exp1(string& s, int& i);\nii exp2(string& s, int& i);\nii exp3(string& s, int& i);\nii exp1(string& s, int& i) {\n  ii acc = exp2(s, i);\n  while (1) {\n    if (s[i] == '|') {\n      ii tmp = exp2(s, ++i);\n      chmin(acc.se, acc.fi + tmp.se);\n      acc.fi += tmp.fi;\n    } else return acc;\n  }\n}\nii exp2(string& s, int& i) {\n  ii acc = exp3(s, i);\n  while (1) {\n    if (s[i] == '&') {\n      ii tmp = exp3(s, ++i);\n      chmin(acc.fi, acc.se + tmp.fi);\n      acc.se += tmp.se;\n    } else return acc;\n  }\n}\nii exp3(string& s, int& i) {\n  if (s[i] == '?') {\n    i++;\n    return {1, 1};\n  } else if (s[i] == '(') {\n    ii ret = exp1(s, ++i);\n    assert(s[i++] == ')');\n    return ret;\n  }\n  assert(0);\n}\n\nsigned main() {\n  string s; cin >> s;\n  int i = 0;\n  ii res = exp1(s, i);\n  cout << res.fi << \" \" << res.se << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring S;\nint pt;\nint target;\n\npair<int, int> calc_or(), calc_and(), calc_term();\n\npair<int, int> calc_or(){\n    vector<int> ret0, ret1;\n    while(true){\n        auto r = calc_and();\n        ret0.push_back(r.first);\n        ret1.push_back(r.second);\n        if(S[pt] == '|'){\n            pt++;\n        }else{\n            break;\n        }\n    }\n\n    int sz = ret0.size();\n    int ans0 = accumulate(ret0.begin(), ret0.end(), 0);\n    int ans1 = ret1[0], sum = 0;\n    for(int i=0; i<sz-1; i++){\n        sum += ret0[i];\n        ans1 = min(ans1, sum + ret1[i+1]);\n    }\n    return {ans0, ans1};\n}\n\npair<int, int> calc_and(){\n    vector<int> ret0, ret1;\n    while(true){\n        auto r = calc_term();\n        ret0.push_back(r.first);\n        ret1.push_back(r.second);\n        if(S[pt] == '&'){\n            pt++;\n        }else{\n            break;\n        }\n    }\n\n    int sz = ret0.size();\n    int ans1 = accumulate(ret1.begin(), ret1.end(), 0);\n    int ans0 = ret0[0], sum = 0;\n    for(int i=0; i<sz-1; i++){\n        sum += ret1[i];\n        ans0 = min(ans0, sum + ret0[i+1]);\n    }\n    return {ans0, ans1};\n}\n\npair<int, int> calc_term(){\n    if(S[pt] == '?'){\n        pt++;\n        return {1, 1};\n    }else{\n        pt++;\n        auto ret = calc_or();\n        pt++;\n        return ret;\n    }\n}\n\nint main(){\n\n    cin >> S;\n    S.push_back('$');\n\n    pt = 0;\n    auto ans = calc_or();\n    cout << ans.first << \" \" << ans.second << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\nstruct P { int c0, c1; };\nP expr(auto& i);\nP num(auto& i) {\n  switch (*i) {\n    case '?': return ++i, P{1, 1};\n    case '(': {\n      P res = expr(++i);\n      return ++i, res;\n    }\n  }\n}\nP term(auto& i) {\n  P res = num(i);\n  int s = min(res.c0, res.c1);\n  while (true) switch (*i) {\n    case '&': {\n      P curr = num(++i);\n      res.c0 = min(res.c0, s + curr.c0);\n      res.c1 += curr.c1;\n      s += min(curr.c0, curr.c1);\n      break;\n    }\n    default: return res;\n  }\n}\nP expr(auto& i) {\n  P res = term(i);\n  int s = min(res.c0, res.c1);\n  while (true) switch (*i) {\n    case '|': {\n      P curr = term(++i);\n      res.c0 += curr.c0;\n      res.c1 = min(res.c1, s + curr.c1);\n      s += min(curr.c0, curr.c1);\n      break;\n    }\n    default: return res;\n  }\n}\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  string s; cin >> s;\n  auto i = begin(s);\n  auto res = expr(i);\n  cout << res.c0 << ' ' << res.c1 << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <string>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <stdio.h>\nusing namespace std;\n#define int long long\nint MOD = 1000000007;\n\nstring S;\npair<int, int> f(int &i) {\n\tpair<int, int> res;\n\tvector <vector<pair<int, int> > > vp(1);\n\twhile (true) {\n\t\tif (i == S.size() || S[i] == ')') {\n\t\t\tvector<int> C(vp.size());\n\t\t\tfor (int x = 0; x < vp.size(); x++) {\n\t\t\t\tint mn = 1000000000;\n\t\t\t\tint t = 0;\n\t\t\t\tfor (int y = 0; y < vp[x].size(); y++) {\n\t\t\t\t\tmn = min(mn, t + vp[x][y].first);\n\t\t\t\t\tt += vp[x][y].second;\n\t\t\t\t}\n\t\t\t\tC[x] = mn;\n\t\t\t\tres.first += mn;\n\t\t\t}\n\t\t\t\n\n\n\n\t\t\t{\n\n\t\t\t\tres.second = 1000000000;\n\t\t\t\tint t = 0;\n\t\t\t\tint tmp = 0;\n\t\t\t\tfor (int x = 0; x < vp.size(); x++) {\n\t\t\t\t\ttmp = 0;\n\t\t\t\t\tfor (int y = 0; y < vp[x].size(); y++) {\n\t\t\t\t\t\ttmp += vp[x][y].second;\n\t\t\t\t\t}\n\t\t\t\t\tres.second = min(res.second, tmp + t);\n\n\t\t\t\t\tt += C[x];\n\t\t\t\t}\n\t\t\t\t\n\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\t\telse if (S[i] == '(') {\n\t\t\ti++;\n\t\t\tvp.back().push_back(f(i));\n\t\t}\n\t\telse if (S[i] == '?') {\n\t\t\tvp.back().emplace_back(1, 1);\n\t\t}\n\t\telse if (S[i] == '|') {\n\t\t\tvp.push_back(vector<pair<int, int> >(0));\n\t\t}\n\t\ti++;\n\t}\n\treturn res;\n}\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcin >> S;\n\tint i = 0;\n\tpair<int, int> res = f(i);\n\tcout << res.first << \" \" << res.second << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nconst int INF = 1010101010;\n\nconst char *p;\n\npii orexpr();\npii andexpr();\npii term();\n\npii orexpr(){\n\tpii a = andexpr();\n\twhile(*p == '|'){\n\t\t++p;\n\t\tpii b = andexpr();\n\t\ta = pii(a.first + b.first, min(a.first + b.second, a.second));\n\t}\n\treturn a;\n}\n\npii andexpr(){\n\tpii a = term();\n\twhile(*p == '&'){\n\t\t++p;\n\t\tpii b = term();\n\t\ta = pii(min(a.second + b.first, a.first), a.second + b.second);\n\t}\n\treturn a;\n}\n\npii term(){\n\tif(*p == '?'){\n\t\t++p;\n\t\treturn pii(1, 1);\n\t}\n\t++p;\n\tpii a = orexpr();\n\t++p;\n\treturn a;\n}\n\nint main(){\n\tstring s;\n\tcin >> s;\n\tp = s.c_str();\n\tpii t = orexpr();\n\tcout << t.first << ' ' << t.second << '\\n';\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<deque>\n#include<iomanip>\n#include<iostream>\n#include<map>\n#include<queue>\n#include<set>\n#include<stack>\n#include<unordered_map>\n#include<unordered_set>\n#include<utility>\n#include<vector>\n\nusing namespace std;\n\nusing lint = long long;\nusing P = pair<int, int>;\nusing LLP = pair<long long, long long>;\n\n#define REP(i, x, n) for(int i = (x), i##_len = int(n) ; i < i##_len ; ++i)\n#define rep(i, n) for(int i = 0, i##_len = int(n) ; i < i##_len ; ++i)\n#define reps(i, n) for(int i = 1, i##_len = int(n) ; i <= i##_len ; ++i)\n#define rrep(i, n) for(int i = int(n) - 1 ; i >= 0 ; --i)\n#define rreps(i, n) for(int i = int(n) ; i > 0 ; --i)\n#define SORT(x) sort((x).begin(), (x).end())\n#define SORT_INV(x) sort((x).rbegin(), (x).rend())\n#define TWINS(x) cout << ((x) ? \"Yay!\" : \":(\") << endl\n\nconst int IINF = (1 << 30) - 1;\nconst long long LLINF = 1LL << 61;\nconst int dx4[] = {1, 0, -1, 0}, dy4[] = {0, 1, 0, -1};\nconst int dx8[] = {1, 1, 0, -1, -1, -1, 0, 1}, dy8[] = {0, -1, -1, -1, 0, 1, 1, 1};\nconst double EPS = 1e-8;\n\ntemplate<typename T>\nbool chmax(T &a, T b){\n    if(a < b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<typename T>\nbool chmin(T &a, T b){\n    if(b < a){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nstack< P > st1;\nstack<char> st2;\n\nP calc(void){\n    P res;\n    P p1 = st1.top();\n    st1.pop();\n    P p2 = st1.top();\n    st1.pop();\n    if(st2.top() == '&'){\n        res.first = min(p2.second + p1.first, p2.first);\n        res.second = p1.second + p2.second;\n    }else if(st2.top() == '|'){\n        res.first = p1.first + p2.first;\n        res.second = min(p2.first + p1.second, p2.second);\n    }\n    return res;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    string s;\n    cin >> s;\n\n    int n = s.size();\n    rep(i, n){\n        if(s[i] == '?'){\n            st1.push({1, 1});\n        }else if(s[i] == '('){\n            st2.push(s[i]);\n        }else if(s[i] == ')'){\n            while(!st2.empty() && st2.top() != '('){\n                st1.push(calc());\n                st2.pop();\n            }\n            st2.pop();\n        }else if(s[i] == '&'){\n            st2.push(s[i]);\n        }else if(s[i] == '|'){\n            while(!st2.empty() && st2.top() == '&'){\n                st1.push(calc());\n                st2.pop();\n            }\n            st2.push(s[i]);\n        }\n    }\n    while(!st2.empty()){\n        st1.push(calc());\n        st2.pop();\n    }\n\n    cout << st1.top().first << \" \" << st1.top().second << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef pair<ll, P> P3;\ntypedef pair<P ,P> PP;\nconstexpr ll MOD = ll(1e9) + 7;\nconstexpr int IINF = INT_MAX;\nconstexpr ll LLINF = LLONG_MAX;\nconstexpr int MAX_N = int(1e5) + 5;\nconstexpr double EPS = 1e-9;\nconstexpr int di[] = {0, 1, 0, -1}, dj[] = {1, 0, -1, 0};\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define REPR(i, n) for (int i = n; i > 0; i--)\n#define SORT(v) sort((v).begin(), (v).end())\n#define SORTR(v) sort((v).rbegin(), (v).rend())\n#define ALL(v) (v).begin(), (v).end()\n\nstring s;\n\nstack<P> st;\nstack<int> ope;  // 0:( 1:) 2:| 3:&\n\nvoid calc(int op){\n    P p1, p2, pr;\n    p1 = st.top(); st.pop();\n    p2 = st.top(); st.pop();\n    // OR\n    if(op == 2){\n        pr.first = p2.first + p1.first;\n        pr.second = min(p2.second, p2.first+p1.second);\n    }\n    // AND\n    if(op == 3){\n        pr.first = min(p2.first ,p2.second+p1.first);\n        pr.second = p2.second + p1.second;\n    }\n    st.push(pr);\n}\n\nint main() {\n    cin >> s;\n    for(int i=0;i<int(s.size());i++){\n        if(s[i] == '?') st.push({1,1});\n        else if(s[i] == '(') ope.push(0);\n        else if(s[i] == ')'){\n            while(ope.top() != 0){\n                calc(ope.top());\n                ope.pop();\n            }\n            ope.pop();\n        }\n        else if(s[i] == '|'){\n            while(!ope.empty() && ope.top() > 2){\n                calc(ope.top());\n                ope.pop();\n            }\n            ope.push(2);\n        }\n        else if(s[i] == '&') ope.push(3);\n    }\n    while(!ope.empty()){\n        calc(ope.top());\n        ope.pop();\n    }\n    cout << st.top().first << \" \" << st.top().second << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\nusing namespace std;\ntypedef string::const_iterator State;\n#define Ma_PI 3.141592653589793\n#define eps 0.00000001\n#define LONG_INF 1e18\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007\n#define MOD 998244353\n#define seg_size 262144\n#define REP(i,n) for(long long i = 0;i < n;++i)\npair<long long, long long> and_expr(State &a);\npair<long long, long long> term(State &a);\npair<long long, long long> or_expr(State &a) {\n\tpair<long long, long long> ans = and_expr(a);\n\twhile (*a != '!') {\n\t\tif (*a == '|') {\n\t\t\ta++;\n\t\t\tpair<long long, long long> now = or_expr(a);\n\t\t\tpair<long long, long long> next_go = make_pair(0, 0);\n\t\t\t//if 0 - 0\n\t\t\tnext_go.first = ans.first + now.first;\n\t\t\t//if 1 - ? or 0 - 1\n\t\t\tnext_go.second = min(ans.second, ans.first + now.second);\n\t\t\tans = next_go;\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ans;\n}\npair<long long, long long> and_expr(State &a) {\n\tpair<long long, long long> ans = term(a);\n\twhile (*a != '!') {\n\t\tif (*a == '&') {\n\t\t\ta++;\n\t\t\tpair<long long, long long> now = and_expr(a);\n\t\t\tpair<long long, long long> next_go = make_pair(0, 0);\n\t\t\t//0 - ? or 1 - 0\n\t\t\tnext_go.first = ans.first;\n\t\t\tnext_go.first = min(next_go.first, ans.second + now.first);\n\t\t\t//1 - 1 is only time to be '1'\n\t\t\tnext_go.second = ans.second + now.second;\n\t\t\tans = next_go;\n\t\t}\n\t\telse {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn ans;\n}\npair<long long, long long> term(State &a) {\n\tif (*a == '(') {\n\t\ta++;\n\t\tpair<int,int> now = or_expr(a);\n\t\ta++;\n\t\treturn now;\n\t}\n\telse if (*a == '?') {\n\t\ta++;\n\t\treturn make_pair(1, 1);\n\t}\n}\nint main() {\n\tstring s;\n\tcin >> s;\n\ts.push_back('!');\n\tState hoge = s.begin();\n\tpair<int, int> ans = or_expr(hoge);\n\tcout << ans.first << \" \" << ans.second << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#ifndef LOCAL\n#define debug(x) ;\n#else\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\ntemplate <typename T1, typename T2>\nostream &operator<<(ostream &out, const pair<T1, T2> &p) {\n  out << \"{\" << p.first << \", \" << p.second << \"}\";\n  return out;\n}\n\ntemplate <typename T>\nostream &operator<<(ostream &out, const vector<T> &v) {\n  out << '{';\n  for (const T &item : v) out << item << \", \";\n  out << \"\\b\\b}\";\n  return out;\n}\n#endif\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 200010\n\n/* 再帰下降法 */\n// char *p = str; res = expr(p);\n\npair<int,int> term(char* &s);\npair<int,int> number(char* &s);\npair<int,int> factor(char* &s);\npair<int,int> expr(char* &s);\n\n//数\npair<int,int> number(char* &s){\n  s++;\n  return {1, 1};\n}\n\n//乗算除算(優先順位:高)\npair<int,int> term(char* &s){\n  pair<int,int> res = factor(s);\n  while(1){\n    if(*s == '&') {\n      auto p = factor(++s);\n      res = {min(res.first, res.second + p.first), res.second + p.second};\n    } else {\n      break;\n    }\n  }\n  return res;\n}\n\n//括弧か数\npair<int,int> factor(char* &s){\n  if(*s != '(') return number(s);\n  pair<int,int> res = expr(++s); s++;\n  return res;\n}\n\n//式(優先順位: 低)\npair<int,int> expr(char* &s){\n  pair<int,int> res = term(s);\n  while(1){\n    if(*s == '|') {\n      auto p = term(++s);\n      res = {res.first + p.first,\n             min(res.second, res.first + p.second)};\n    } else {\n      break;\n    }\n  }\n  return res;\n}\n\nchar S[SIZE];\n\nint main(){\n  scanf(\"%s\", S);\n\n  char *p = S;\n\n  auto ans = expr(p);\n\n  cout << ans.first << \" \" << ans.second << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#define all(x) (x).begin(),(x).end()\n//#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\ntypedef long long ll; const int inf = INT_MAX / 2; const ll infl = 1LL << 60;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a = b; return 1; } return 0; }\n//---------------------------------------------------------------------------------------------------\n/*---------------------------------------------------------------------------------------------------\n　　　　　　　　　　　 ∧＿∧  \n　　　　　 ∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!\n　　　　 （ ´_ゝ`）　/　 ⌒i     @hamayanhamayan\n　　　　／　　　＼　 　  |　|     \n　　　 /　　 /￣￣￣￣/　　|  \n　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿  \n　 　　　＼/＿＿＿＿/　（u　⊃  \n---------------------------------------------------------------------------------------------------*/\n\n\n\n\n\nstring op[2] = { \"|\", \"&\" };\n\npair<int,int> parse(string& s, int& i, int x)\n{\n\tif (x == 2)\n\t{\n\t\tif (s[i] == '(')\n\t\t{\n\t\t\ti++;\n\t\t\tauto ans = parse(s, i, 0);\n\t\t\ti++;\n\t\t\treturn ans;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tchar c = s[i];\n\t\t\ti++;\n\n\t\t\tif (c == '1') return { 201010, 0 };\n\t\t\telse if (c == '0') return { 0, 201010 };\n\t\t\telse return { 1, 1 };\n\t\t}\n\t}\n\telse\n\t{\n\t\tvector<pair<int,int>> history;\n\t\thistory.push_back(parse(s, i, x + 1));\n\n\t\tint flag = 0;\n\n\t\twhile (op[x].find(s[i]) != string::npos)\n\t\t{\n\t\t\tswitch (s[i])\n\t\t\t{\n\t\t\tcase '|': i++; history.push_back(parse(s, i, x + 1)); flag = 1; break;\n\t\t\tcase '&': i++; history.push_back(parse(s, i, x + 1)); flag = 2; break;\n\t\t\t}\n\t\t}\n\n\t\tif (flag == 0) return history.back();\n\t\t\n\t\tif (flag == 1) { // or\n\t\t\tint zero = 0;\n\t\t\tint yasui = 0;\n\t\t\tint one = inf;\n\t\t\tfore(p, history) {\n\t\t\t\tchmin(one, zero + p.second);\n\t\t\t\tzero += p.first;\n\t\t\t}\n\t\t\treturn { zero, one };\n\t\t}\n\n\t\tif (flag == 2) { // and\n\t\t\tint zero = inf;\n\t\t\tint yasui = 0;\n\t\t\tint one = 0;\n\t\t\tfore(p, history) {\n\t\t\t\tchmin(zero, one + p.first);\n\t\t\t\tone += p.second;\n\t\t\t}\n\t\t\treturn { zero, one };\n\t\t}\n\t}\n}\n\n\nstring S;\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n\tcin >> S;\n\tS = S + \"#\";\n\n\tint i = 0;\n\tauto ans = parse(S, i, 0);\n\n\tprintf(\"%d %d\\n\", ans.first, ans.second);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/*\n\nstring op[2] = { \"|\", \"&\" };\n\nint parse(string& s, int& i, int x)\n{\n\tif (x == 2)\n\t{\n\t\tif (s[i] == '(')\n\t\t{\n\t\t\ti++;\n\t\t\tint ans = parse(s, i, 0);\n\t\t\ti++;\n\t\t\treturn ans;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint ret = 0;\n\n\t\t\tif (s[i] == '1') ret = 1;\n\t\t\ti++;\n\n\t\t\treturn ret;\n\t\t}\n\t}\n\telse\n\t{\n\t\tvector<int> history;\n\t\thistory.push_back(parse(s, i, x + 1));\n\n\t\tint flag = 0;\n\n\t\twhile (op[x].find(s[i]) != string::npos)\n\t\t{\n\t\t\tswitch (s[i])\n\t\t\t{\n\t\t\tcase '|': i++; history.push_back(parse(s, i, x + 1)); flag = 1; break;\n\t\t\tcase '&': i++; history.push_back(parse(s, i, x + 1)); flag = 2; break;\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\tif (flag == 0) ans = history.back();\n\t\telse if (flag == 1) {\n\t\t\tans = 0;\n\t\t\tfore(x, history) ans |= x;\n\t\t}\n\t\telse if (flag == 2) {\n\t\t\tans = 1;\n\t\t\tfore(x, history) ans &= x;\n\t\t}\n\n\t\treturn ans;\n\t}\n}\n\nvoid test() {\n\tvector<pair<string, int>> testcase = {\n\t\t{\"0&1\", 0},\n\t\t{\"1&1\", 1},\n\t\t{\"1&0|1\", 1},\n\t\t{\"1&0|1&0\", 0},\n\t\t{\"1&1&0\", 0},\n\t\t{\"(0|0|0|1)&1&(1&0)\", 0}\n\t};\n\n\tfore(p, testcase) {\n\t\tint i = 0;\n\t\tstring s = p.first + \"#\";\n\t\tint actual = parse(s, i, 0);\n\t\tint expect = p.second;\n\t\t\n\t\tif (actual != expect) {\n\t\t\tprintf(\"NG!!! %s = %d : ans %d\\n\", s.c_str(), actual, expect);\n\t\t}\n\t}\n}\n\n\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n\ttest();\n}\n\n\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n)  for(int i = (k);i < (n);++i)\n#define REP(i,n)    FOR(i,0,n)\n#define ALL(x)      begin(x),end(x)\n\nusing namespace std;\nusing vecint = vector<int>;\nusing ll = int64_t;\n\ntuple<int,int,int> or_expr(const string& s, int pos);\n\ntuple<int,int,int> term(const string& s, int pos) {\n  if (s[pos] == '?') {\n    return make_tuple(pos+1, 1, 1);\n  } else {\n    assert(s[pos] == '(');\n    int np, f, t;\n    tie(np, f, t) = or_expr(s, pos+1);\n    assert(s[np] == ')');\n    return make_tuple(np+1, f, t);\n  }\n}\n\ntuple<int,int,int> and_expr(const string& s, int pos) {\n  int np, f0, t0;\n  tie(np, f0, t0) = term(s, pos);\n  while (np < s.size() && s[np] == '&') {\n    pos = np+1;\n    int f1, t1;\n    tie(np, f1, t1) = term(s, pos);\n    f0 = min(f0, t0 + f1);\n    t0 += t1;\n  }\n  return make_tuple(np, f0, t0);\n}\n\ntuple<int,int,int> or_expr(const string& s, int pos) {\n  int np, f0, t0;\n  tie(np, f0, t0) = and_expr(s, pos);\n  while (np < s.size() && s[np] == '|') {\n    pos = np+1;\n    int f1, t1;\n    tie(np, f1, t1) = and_expr(s, pos);\n    t0 = min(t0, f0 + t1);\n    f0 += f1;\n  }\n  return make_tuple(np, f0, t0);\n}\n\npair<int,int> formula(const string& s) {\n  int pos, f, t;\n  tie(pos, f, t) = or_expr(s, 0);\n  return make_pair(f, t);\n}\n\nint main()\n{\n  string s;\n  cin>>s;\n  auto res = formula(s);\n  cout<<res.first<<' '<<res.second<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <class T> inline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntemplate <class T> inline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\ntypedef long long int ll;\n\n#define ALL(v) (v).begin(), (v).end()\n#define RALL(v) (v).rbegin(), (v).rend()\n#define endl \"\\n\"\nconst double EPS = 1e-7;\nconst int INF = 1 << 30;\nconst ll LLINF = 1LL << 60;\nconst double PI = acos(-1);\nconst int MOD = 1000000007;\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\nusing State = string::const_iterator;\nclass ParseError {};\nusing P = pair<int, int>;\n\n//-------------------------------------\n\nP orExpr(State &);\nP andExpr(State &);\nP term(State &);\n\nP orExpr(State &now) {\n    P a = andExpr(now);\n    P res = P(-1, a.second);\n    int tmp = a.first;\n    while(*now == '|') {\n        now++;\n        P aa = andExpr(now);\n        chmin(res.second, tmp + aa.second);\n        tmp += aa.first;\n    }\n    res.first = tmp;\n    return res;\n}\n\nP andExpr(State &now) {\n    P t = term(now);\n    P res = P(t.first, -1);\n    int tmp = t.second;\n    while(*now == '&') {\n        now++;\n        P tt = term(now);\n        chmin(res.first, tmp + tt.first);\n        tmp += tt.second;\n    }\n    res.second = tmp;\n    return res;\n}\n\nP term(State &now) {\n    if(*now == '(') {\n        now++;\n        P res = orExpr(now);\n        now++;\n        return res;\n    } else {\n        now++;\n        return P(1, 1);\n    }\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    string s;\n    cin >> s;\n    State now = s.begin();\n    P ans = orExpr(now);\n    cout << ans.first << ' ' << ans.second << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n// #define int ll\nusing PII = pair<ll, ll>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n\ntemplate<typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\n\ntemplate<typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts) {\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value==0>::type\nfill_v(T &t, const V &v) { t=v; }\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t, const V &v ) { for(auto &e:t) fill_v(e,v); }\n\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')'; return out;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& vec){\n  for(T& x: vec) {is >> x;} return is;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'['; for(T i: a) {out<<i<<',';} out<<']'; return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0}; // DRUL\nconst int INF = 1<<30;\nconst ll LLINF = 1LL<<60;\nconst ll MOD = 998244353;\n\nll pos, n;\nstring s;\n\nPII formula() {\n    vector<PII> ret;\n    vector<char> op;\n    while(pos < n && s[pos] != ')') {\n        if(s[pos] == '(') {\n            pos++;\n            ret.push_back(formula());\n            pos++;\n        } else if(s[pos] == '?') {\n            pos++;\n            ret.push_back(PII(1,1));\n        } else if(s[pos] == '&' || s[pos] == '|') {\n            op.push_back(s[pos]);\n            pos++;\n        } \n    }\n    PII ans(0, INF);\n    ll con = ret[0].second, mi = ret[0].first;\n    REP(i, op.size()) {\n        // cout << i << \" \" << ans << \" \" << con << \" \" << mi << endl;\n        if(op[i] == '&') {\n            chmin(mi, con + ret[i+1].first);\n            con += ret[i+1].second;\n        } else {\n            // cout << mi << endl;\n            chmin(ans.second, ans.first + con);\n            ans.first += mi;\n            mi = ret[i+1].first;\n            con = ret[i+1].second;\n        }\n    }\n    chmin(ans.second, ans.first + con);\n    ans.first += mi;\n    // cout << ret << endl << op << endl << ans << endl;\n    return ans;\n}\n\nsigned main(void)\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    cin >> s;\n    n = s.size();\n\n    PII ret = formula();\n    cout << ret.first << \" \" << ret.second << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace::std;\nusing lint =long long;\n#define rep(i,n) for(lint i=0;i<n;i++)\n#define INF (1LL<<60)\nusing vec=vector<lint>;\nstring s;\npair<int,int> expr(int& i);\npair<int,int> expr2(int& i);\npair<int,int> term(int& i);\npair<int,int> expr(int& i){\n    pair<int,int>res=make_pair(-1,-1);\n    while(i<(int)s.size()){\n        auto e=expr2(i);\n        if(res==make_pair(-1,-1))res=e;\n        else res=make_pair(min(res.first,res.second+e.first),res.second+e.second);\n        if(s[i]==')')break;\n        i++;\n    }\n    return res;\n}\npair<int,int> expr2(int& i){\n    pair<int,int>res=make_pair(-1,-1);\n    while(i<(int)s.size()){\n        auto e=term(i);\n        if(res==make_pair(-1,-1))res=e;\n        else res=make_pair(res.first+e.first,min(res.second,res.first+e.second));\n        if(s[i]=='|')break;\n        if(s[i]==')')break;\n        i++;\n    }\n    return res;\n}\npair<int,int> term(int& i){\n    if(s[i]=='?'){\n        i++;\n        return make_pair(1,1);\n    }else{\n        i++;\n        auto e=expr(i);\n        i++;\n        return e;\n    }\n}\nint main(){\n    cin>>s;\n    int i=0;\n    auto e=expr(i);\n    cout<<e.second<<\" \"<<e.first<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\npair<int, int> or_expr(string &s, int &i);\npair<int, int> and_expr(string &s, int &i);\npair<int, int> term(string &s, int &i);\n\n// 0, 1\npair<int, int> or_expr(string &s, int &i) {\n    if(i >= s.size()) return make_pair(0, 0);\n//    cout << \"or:\" << i << endl;\n    auto a = and_expr(s, i);\n    while(s[i] == '|') {\n        i++;\n        auto b = and_expr(s, i);\n        a = make_pair(a.first + b.first, min(a.first + b.second, a.second));\n    }\n    return a;\n}\n\npair<int, int> and_expr(string &s, int &i) {\n//    cout << \"and:\" << i << endl;\n    auto a = term(s, i);\n    while(s[i] == '&') {\n        i++;\n        auto b = term(s, i);\n        a = make_pair(min(a.second + b.first, a.first), a.second + b.second);\n    }\n    return a;\n}\n\npair<int, int> term(string &s, int &i) {\n//    cout << \"term:\" << i << endl;\n    if(s[i] == '?') {\n        i++;\n        return make_pair(1, 1);\n    }\n    i++; // (\n    auto ret = or_expr(s, i);\n    i++; // )\n    return ret;\n}\n\nint main(){\n    string s;\n    cin >> s;\n    int i = 0;\n    auto ans = or_expr(s, i);\n    cout << ans.first << \" \" << ans.second << endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define REV(i,n) for(ll (i) = (n) - 1;(i) >= 0;--i)\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {REP(WW,n)cerr << v[WW] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,WW,HH) {REP(W_,WW){REP(H_,HH)cerr << v[W_][H_] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define LLINF 1000000000000000000LL\n#define MOD 998244353\n\ntypedef long long ll;\ntypedef pair<int,int> P;\nP orExpr(string &str, int &pla);\n\nP term(string &str, int &pla){\n    //cout << \"in term \" << pla << endl;\n    if(str[pla] == '?'){\n        pla++;\n        return MP(1, 1);\n    }\n    else {\n        pla++;\n        auto ret = orExpr(str, pla);\n        pla++;\n        return ret;\n    }\n}\n\nP andExpr(string &str, int &pla){\n    //cout << \"in andExpr \" << pla << endl;\n    int a = 0, b = INF;\n    int tmp = 0;\n\n    while(1){\n        auto v = term(str, pla);\n        b = min(b, tmp + v.SE);\n        a += v.FI;\n        tmp += v.FI;\n\n        if(str[pla] != '&'){\n            break;\n        }\n        pla++;\n    }\n\n    //cout << \"out andExpr\" << endl;\n    return MP(a, b);\n}\n\nP orExpr(string &str, int &pla) {\n    //cout << \"in orExpr \" << pla << endl;\n    int a = INF, b = 0;\n    int tmp = 0;\n\n    while(1){\n        auto v = andExpr(str, pla);\n        a = min(a, tmp + v.FI);\n        tmp += v.SE;\n        b += v.SE;\n\n        if(str[pla] != '|'){\n            break;\n        }\n        pla++;\n    }\n\n    //cout << \"out orExpr\" << endl;\n    return MP(a, b);\n}\n\nint main(){\n\tcin.tie(0);cout.tie(0);ios::sync_with_stdio(false);\n\n    string str;cin >> str;\n    str = \"(\" + str + \")\";\n    int pla = 1;\n    auto ans = orExpr(str, pla);\n    cout << ans.SE << \" \" << ans.FI << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define SIZE 200005\n\nenum Type{\n    Zero,\n    One,\n};\n\nstruct Info{\n\n\tint ans_ZERO,ans_ONE;\n};\n\nchar buf[SIZE];\nint close_pos[SIZE];\nint LOC;\n\nInfo formula();\nInfo or_expr();\nInfo and_expr();\nInfo term();\n\n\nInfo formula(){\n\n    return or_expr();\n}\n\nInfo or_expr(){\n\n\tInfo ret;\n\n\tret = and_expr();\n\n\tint ZERO = ret.ans_ZERO;\n\tint ONE = ret.ans_ONE;\n\n\tint pre_ZERO,pre_ONE;\n\n\t while(buf[LOC] == '|'){\n\n\t\t pre_ZERO = ZERO;\n\t\t pre_ONE = ONE;\n\n\t\t LOC++;\n\t\t Info tmp = and_expr();\n\n\t\t ret.ans_ZERO += tmp.ans_ZERO; //or連結で0にするには、全ての<and_expr>を0にする必要あり\n\n\t\t //or連結で1にする場合\n\t\t ZERO = pre_ZERO+tmp.ans_ZERO;\n\t\t ONE = min(pre_ONE,pre_ZERO+tmp.ans_ONE);\n\t}\n\n    ret.ans_ONE = ONE;\n\n    return ret;\n}\n\nInfo and_expr(){\n\n\tInfo ret;\n\n\tret = term();\n\n\tint ZERO = ret.ans_ZERO;\n\tint ONE = ret.ans_ONE;\n\n\tint pre_ZERO,pre_ONE;\n\n\t while(buf[LOC] == '&'){\n\n\t\t pre_ZERO = ZERO;\n\t\t pre_ONE = ONE;\n\n\t\t LOC++;\n\t\t Info tmp = term();\n\n\t\t ret.ans_ONE += tmp.ans_ONE; //and連結で1にするには、全ての<term>を1にする必要あり\n\n\t\t //and連結で0にする場合\n\t\t ZERO = min(pre_ZERO,pre_ONE+tmp.ans_ZERO);\n\t\t ONE = pre_ONE+tmp.ans_ONE;\n\t}\n\n\tret.ans_ZERO = ZERO;\n\n\treturn ret;\n}\n\nInfo term(){\n\n    if(buf[LOC] == '?'){\n\n    \tLOC++;\n\n    \tInfo ret;\n    \tret.ans_ZERO = 1;\n    \tret.ans_ONE = 1;\n\n    \treturn ret;\n\n    }else{ //(<or_expr>)\n\n    \tLOC++;\n    \tInfo ret = or_expr();\n    \tLOC++;\n\n    \treturn ret;\n    }\n}\n\n\nint main(){\n\n    scanf(\"%s\",buf);\n\n    Info ans = formula();\n\n    LOC = 0;\n\n    printf(\"%d %d\\n\",ans.ans_ZERO,ans.ans_ONE);\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/* Aa^~ kokoro ga pyonpyon suru n jaa^~\n// ZZZXXkXkkkZ!``` ``` ``` ``` ``` ``` ``` ``` ``` ``` ``` ```?Wfpppbpbbpbbpbbbkbkk\n// ppbbbpbbpVr`` `` ` ` ` ` ```` `` ` ` ``  ` ` ` ` ` ` ` ` `  dppbbkkkkkkkkkkqkqkk\n// HkqqqqqkkWr`` ` ` ``` ``` `?G, ` ` ``.JC!```` ` ` `` `` ````(Wpbkkkkkkkkqkkkkkqk\n// mmmmmqqqqpr` `` `` ```````.+zT=`` `` 7TO-.```````` `` `` ```(yppbkkkkkkkkkkkkkkk\n// ggmgmmqqqH$ ``````````....````` `  ````````.`````` `` ``````.yfpppbbbbkkkkqqqqqH\n// gmmmmmqqqkW<```` `````...`````  .,.`  ````....````` ``````` (Wbqqmgmmgmggggggggg\n// qmmmqqqqkkWk.``````````````````` ;:<`` `````.`````````````-_<-?WHHqmmmmmmgmmgggg\n// @@@@@@@gggHH6- ``````````````` `` _ `` ```````````````` ._~~_.`-?Wkqmmmmmmmggg@g\n// @@@@g@gggHY~.-<_- `````````````````````````````````` ._~~(<-``.`.(WHqqqmmggggmmm\n// @@g@gggHH=.`..._<-___..```````````````````````. .-_~~~_(!``-.``.`` OHHWUWHmqHWXW\n// gggggmqK1.``..~.. _<<+-(____..  ````````  ..__~~_((<<!.`.``` .``.`` j0C1XUHmHIdW\n// ggmmqH0!,_``.>`````` _<<;<v<<<++((((((((((<<<<<<~_. (-.``~``.>..```  jOuWHHqHIdH\n// gmmqkW!`(_ J>`    `` ` _~<`_~~~~<<<<<<<~~__````````` ?1. ._`(__```    zXWHg@HkXH\n// gHHWS{``(lJ<!``.``.```(:+>`._`````.` <..`` - ``. `   _ ?&._.I`_`````` .XyVfppppW\n// HHHSv``.(X:_..... _..(;+<!.(<..-.....-.-_..+_`..<.`.`..`_IJd}  .`..````jqg@@@@@@\n// XHWZ{..<Jk~!.`.. (<.-(+>(_.(1.(_..`.`.`.<_.+<_..<<-..._..-zy>.`_`...```.WH@HHHHH\n// bkWt~.-jCz(_..`.(+<.(;< ._-<=_(<_..-....(_.<1<..(<<.`._..-JUS-._.`...```dHmH9VUH\n// WUUO..(f.(c...__+z<-(+~` _-+<_(><..__.`.(<._.z_.(1;_..__.(C(zT-(..`...``(WHR<+Xk\n// kkkk._(_.->..._(z;:_><.._>_+_<(1>_._<...(v<<.(<.(+z<..-_(Z~_<_j+_..`...`(WHKz1ZW\n// @@gR._+_..~..-<+z<<?<>```_.<_.(+1><_;_..(1_:`.<<??1z--(+Z!..<_.j<....`..(bgHAAQX\n// @@mR.(j:..~.._<z!`.(>~``` ~(_.(+<1><><_.(((_`.<__`.<_.(X>...<_.(<.....`.JUWWWyWW\n// @gmH_(zl..(.._+>```<+_````.~>``(+.<?>>_._(<```(<<``(__<>....<.._<.......dXkkkHHH\n// mmqHl(dk_.(_.-=~`.`.1-..._~-1.``_:`(??<_~(`.--.&_.`.<(;<...._.._<..`..._Xg@@@@@@\n// qHkpk(dX<.(;..j_```.(((JJ&a&-~``````.1<_```-(((e+.-(/`(>...._..(<......(Wmggg@@g\n// HVHbWcz><__+_.(_.(dWWHHH@HHc~````````.+~`` (jHMMMHHHm&.?..._<..(<_..._.(WqqHHmHg\n// 0>vWWkzZwl~<o.__`__~X@@HM@Hb ```.`.``. ```` d@@HHH@@K?76...(<..(<_...(_(ppWWWWHq\n// X0XWHKXXw$<(z<.( `` WHHMHHHH_``````````````.WHHMNMHHH_`(...(<_.(z_..._<(fWVC174W\n// XuXWHHWWz>__+z+.!`..??CZYCOX_`````````````.`~.OvTUZUS_`~.._+?_.(_~_.._zjO=1+~+jy\n// kkkkkkkkX:._<z=1(_`` << ``->``.``.``.``.```` ?<`` (v!`._..(??_.(1._.._=dUOOzzzwX\n// @@@@@@@@H<...1O=v<_...__ -_````````````````.`` `` ~.`` :.~+=?~.(;_(...jdQQQQQkkk\n// H@@@@@@@H~...(==>.~~~~~....`.`````````.`````.`........->.(===~~<<.(...(dg@@@@@@@\n// @@@H@@HHH_.__(=l>~.~~~~~....``.``.``.```..`......~~~~~(<_+=l=~_<.->..~_dqggggg@g\n// @H@@@@MHH_._<(=l>...........```````````````.`...~~~~~~+<(=lz=~((j=z_..~jWqmmgggm\n// @@H@@HHWH_._<(lll-.......```.````.``.`..`````........_z<+llZz~(lOO=<...(VYUUUW9Y\n// @@HMMHWZf>~_=:=llw+.`````````.`.```__~~_``.`````.....(z+llOOz_zllOlz~..~<<1+dW>_\n// MMM#MHHWXl~_=>1ltwOl&.`.``.`````.``````````````.````.(llttwtz(OltwOz<..__zwOwwOz\n// HM#HMHUUI<._1z+ttOZttlt&....``.``.`.````.``...``...(zZtttOktzjttttwlz_._<(Xkkkkk\n// HHHmHSZu:(_~+OztttXtttOZZttO+-..............-(+ztOttwttttd0tOZttttwOl<~.(_dMMHHH\n// rvuuXuuI~~<~(uttttwvOwwwkQQHMMHHHHHHHHHMMMNmgey?OwwwrtttwXOtwttttttXtO-~.((wZyyy\n// HHHHHHK>(~(-(dOrtrrl(QgMHMMMHHHHHHHHHHHHHHHH##HMNkX0rrrrXXrd%`` (Ctwwtz_~.<(Wg@H\n// NNNNNHD(~(zo~zXrrrQdHHMMNMHHHHHHHHHHHHHHHHHHHHHH##HNmyrdKkwZ ` _``-zwrt1~~_<(MNM\n// MMMMM#<<_jwr:(Z4QHHMMHMHHHHHHHHHHHHHHHHHHHHHHHHHHHH###NHSXZ>` ~````.OXtt>~._<?MM\n*/\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define MT make_tuple\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\n\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class T>\nistream& operator>>(istream& is, vector<T>& xs){\n  for(auto& x: xs)\n\tis >> x;\n  return is;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& xs){\n  for(unsigned int i=0;i<xs.size();++i)\n\tos << (i?\" \":\"\") << xs[i];\n  return os;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\nvoid debug(istringstream&){}\ntemplate <char sep=',', class Head, class... Tail>\nvoid debug(istringstream& iss, Head&& head, Tail&&... tail)\n{\n  string name;\n  getline(iss, name, ',');\n  cout << sep << name << \"=\" << head;\n  debug(iss, forward<Tail>(tail)...);\n}\n\n#ifdef PYONPOI\n#define DEBUG(...) \\\n  do{ \\\n    istringstream ss(#__VA_ARGS__); \\\n    debug<' '>(ss, __VA_ARGS__); \\\n    cout<<endl; \\\n  }while(0)\n#else\n#define DEBUG\n#endif\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nconst int MAX = 2e5+10;\nconst int INF = 1e7;\n\nint N;\nstring s;\nint dp[3][MAX][2];\nint to[3][MAX][2];\nint or_(int& i, int f);\nint and_(int& i, int f);\nint term_(int& i, int f);\n\nint or_(int& i, int f){\n  const int id = 0;\n  const int orig_i = i;\n  int& res = dp[id][i][f];\n  int& idx = to[id][i][f];\n\n  if(res < INF){\n    i = idx;\n    return res;\n  }\n\n  if(f == 0){\n    int e = and_(i, 0);\n\n    if(i < N && s[i] == '|'){\n      ++i;\n      e += or_(i, 0);\n    }\n    res = e;\n  }\n  else{ // f == 1\n    int a0 = and_(i, 0);\n    i = orig_i;\n    int a1 = and_(i, 1);\n\n    int b0 = 0, b1 = INF;\n    if(i < N && s[i] == '|'){\n      ++i;\n      int ii = i;\n      b0 = or_(i, 0);\n      i = ii;\n      b1 = or_(i, 1);\n    }\n\n    res = min(a0 + b1, a1);\n  }\n  idx = i;\n  return res;\n}\n\nint and_(int& i, int f){\n  const int id = 1;\n  const int orig_i = i;\n  int& res = dp[id][i][f];\n  int& idx = to[id][i][f];\n\n  if(res < INF){\n    i = idx;\n    return res;\n  }\n\n  if(f == 1){\n    int e = term_(i, 1);\n\n    if(i < N && s[i] == '&'){\n      ++i;\n      e += and_(i, 1);\n    }\n    res = e;\n  }\n  else{ // f == 0\n    int a0 = term_(i, 0);\n    i = orig_i;\n    int a1 = term_(i, 1);\n\n    int b0 = INF, b1 = 0;\n    if(i < N && s[i] == '&'){\n      ++i;\n      int ii = i;\n      b0 = and_(i, 0);\n      i = ii;\n      b1 = and_(i, 1);\n    }\n\n    res = min(a1 + b0, a0);\n  }\n  idx = i;\n  return res;\n}\n\nint term_(int& i, int f){\n  const int id = 2;\n  const int orig_i = i;\n  int& res = dp[id][i][f];\n  int& idx = to[id][i][f];\n\n  if(res < INF){\n    i = idx;\n    return res;\n  }\n\n  if(s[i] == '('){\n    ++i;\n    res = or_(i, f);\n    assert(s[i] == ')');\n\n    ++i;\n    idx = i;\n    return res;\n  }\n  else if(s[i] == '?'){\n    ++i;\n    res = 1;\n    idx = i;\n    return res;\n  }\n\n  assert((printf(\"%d\\n\", i) && false));\n  return -1;\n}\n\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  cin >> s;\n  N = SZ(s);\n  fill((int*)dp, (int*)dp+3*MAX*2, INF);\n  int i = 0, j = 0;\n  cout << or_(i, 0) << \" \" << or_(j, 1) << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O2\")\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <cstdarg>\n#include <cstdio>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <iomanip>\n#include <iostream>\n#include <iterator>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\n#define whlie while\n#define retunr return\n#define reutrn return\n#define reutnr return\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n#define inf 1001001001\n#define infLL (1LL << 61)\n#define MOD 1000000007\n#define FOR(i,a,b) for(int (i)=(int)(a); (i)<(int)(b); (i)++) // [a,b)\n#define rep(i,N) FOR((i), 0, (int)(N)) // [0,N)\n#define FORR(i,a,b) for(int (i)=(int)(b) - 1; (i)>=(int)(a); (i)--)\n#define repr(i,N) FORR((i), 0, (int)(N))\n#define each(x,v) for(auto &x : v)\n#define all(v) (v).begin(),(v).end()\n#define sz(v) ((int)(v).size())\n#define vrep(v,it) for(auto it=v.begin();it!=v.end();it++)\n#define vrepr(v,it) for(auto it=v.rbegin();it!=v.rend();it++)\n#define ini(...) int __VA_ARGS__; in(__VA_ARGS__)\n#define inl(...) ll __VA_ARGS__; in(__VA_ARGS__)\n#define inc(...) char __VA_ARGS__; in(__VA_ARGS__)\n#define ins(...) string __VA_ARGS__; in(__VA_ARGS__)\n#define ind(...) double __VA_ARGS__; in(__VA_ARGS__)\n#define inpii(...) pii __VA_ARGS__; in(__VA_ARGS__)\n#define rand mtrand\n#define randinit random_device seed_gen; mt19937 mtrand(seed_gen()+2)\n\n#ifdef LOCAL  \n  #define trc(...) do { cout << #__VA_ARGS__ << \" = \"; dbg_out(__VA_ARGS__);} while(0)\n  #define stopif(val) assert( !(val) )\n  #define trcv(v,...) do { cout << #v << \" = \"; vector_debug(v , ##__VA_ARGS__);cout << endl;} while(0)\n#else\n  #define trc(...)\n  #define stopif(...)\n  #define trcv(...)\n#endif\n\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int,int>;\nusing pll = pair<ll,ll>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vs = vector<string>;\nusing vpii = vector<pii>;\nusing vvi = vector< vector<int> >;\n\nstruct IoSetupNya {IoSetupNya() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); cerr << fixed << setprecision(15);} } iosetupnya;\n/* \nint gcd(int a, int b){if(a>b) swap(a,b); return a==0 ? b : gcd(b%a,a);} ll gcd(ll a, ll b){if(a>b) swap(a,b); return a==0 ? b : gcd(b%a,a);}\nll lcm(int a, int b){return (1LL * a / gcd(a,b)) * b;} ll lcm(ll a, ll b){return (a / gcd(a,b)) * b;}\n*/\ninline ll pow(int a, int b){ll ans = 1; rep(i,b) ans *= a; return ans;} inline ll pow(ll a, ll b){ll ans = 1; rep(i,b) ans*= a; return ans;}\ninline ll pow(int a, ll b){ll ans = 1; rep(i,b) ans *= a; return ans;} inline ll pow(ll a, int b){ll ans = 1; rep(i,b) ans*= a; return ans;}\ntemplate<typename T, typename U> inline bool amin(T &x, U y) { return (y < x) ? (x = y, true) : false; }\ntemplate<typename T, typename U> inline bool amax(T &x, U y) { return (x < y) ? (x = y, true) : false; }\ntemplate<typename C> inline void _cin(C &c){cin >> c;}\ntemplate<typename T,typename U> inline void _cin(pair<T,U> &p){cin >> p.fi; cin >> p.se;}\ntemplate<typename C> inline void _cout(const C &c){cout << c;}\ntemplate<typename T,typename U> inline void _cout(const pair<T,U> &p){cout << p.fi << ' ' << p.se;}\nvoid in(){} template <typename T,class... U> void in(T &t,U &...u){ _cin(t); in(u...);}\nvoid out(){cout << \"\\n\";} template <typename T,class... U> void out(const T &t,U ...u){ _cout(t); if(sizeof...(u)) cout << ' '; out(u...);}\ntemplate<typename C> inline void in(vector<C> &v,int N=-1){if(sz(v) != 0){int M=(N == -1) ? sz(v) : N; rep(i,M) _cin(v[i]);}else{C c;rep(i,N) v.pb((_cin(c),c));}}\ntemplate<typename C> inline void in(C v[],int N){rep(i,N) _cin(v[i]);}\ntemplate<typename C> inline void out(const vector<C> &v,int N=-1){int M=(N == -1) ? sz(v) : N; rep(i,M) {cout<<( (i)?\" \":\"\" ); _cout(v[i]);} cout<<\"\\n\";}\ntemplate<typename C> inline void out(C v[],int N){rep(i,N) {cout<<( (i)?\" \":\"\" ); _cout(v[i]);} cout<<\"\\n\";}\ntemplate<typename C> inline void vector_debug(const vector<C> &v,int N=-1){cout << \"{\"; int M=(N == -1) ? sz(v) : N; rep(i,M) {cout<<( (i)?\", \":\"\" ); _cout(v[i]);} cout<<\"}\";}\ntemplate<typename C> inline void vector_debug(C v[], int N){cout << \"{\"; rep(i,N) {cout<<((i)?\", \":\"\"); _cout(*(v+i));} cout<<\"}\";}\nvoid dbg_out(){cout << endl;} template <typename T,class... U> void dbg_out(const T &t,U ...u){ _cout(t); if(sizeof...(u)) cout << \", \"; dbg_out(u...);}\ntemplate<typename C,class... U> void dbg_out(const vector<C> &v,U ...u){vector_debug(v); if(sizeof...(u)) cout << \", \"; dbg_out(u...);}\ntemplate<typename C,class... U> void dbg_out(const vector<vector<C>> &v,U ...u){cout << \"{ \"; rep(i,sz(v)) {if(i)cout<<\", \"; vector_debug(v[i]);} cout << \" }\"; if(sizeof...(u)) cout << \", \"; dbg_out(u...);}\ntemplate<typename C> inline C vmax(const vector<C> &v){C n=v[0]; rep(i,sz(v)) amax(n,v[i]); return n;} template<typename C> inline C vmax(C v[], int N){C n=v[0]; rep( i , N ) amax(n,v[i]); return n;}\ntemplate<typename C> inline C vmin(const vector<C> &v){C n=v[0]; rep(i,sz(v)) amin(n,v[i]); return n;} template<typename C> inline C vmin(C v[], int N){C n=v[0]; rep( i , N ) amin(n,v[i]); return n;}\nvoid die(string s){out(s); exit(0);}\n\n////////////\n/// main ///\n////////////\n\nstring S;\nusing P = pair<int , int>;\n// 0のとき　1のとき\nint idx = 0;\nP eval_and();\nP eval_or();\nP eval_kakko();\nP eval_q();\n\nP eval_or(){\n// 最初　あたま　おわり　おわりの次(すなわち文末)\n  trc(\"or\",idx);\n  P ret = P(0 , inf);\n  while(1){\n    P cur;\n    if(S[idx] == '('){\n      cur = eval_and();\n    }\n    else { // アンドに投げる\n      cur = eval_and();\n    }\n    //trc(\"or totyu\" , cur , ret);\n    ret.se = min(ret.se , ( min(ret.fi , ret.se) + cur.se));\n    ret.fi = ret.fi + cur.fi;\n    //trc(\"or totyu\" , ret , idx);\n    if(idx + 1 == sz(S) || S[idx + 1] == ')'){\n      trc(\"or\", idx , ret);\n      return ret;\n    }\n    idx += 2; // '|'のぶん\n  }\n}\n\nP eval_and(){\n  // 最初　あたま　終わり　終わりの次( すなわち | )\n  trc(\"and\",idx);\n  P ret = P(inf , 0);\n  while(1){\n    P cur;\n    if(S[idx] == '('){\n      cur = eval_kakko();\n    }\n    else { // はてなしかない\n      assert(S[idx] == '?');\n      cur = P(1,1);\n    }\n    ret.fi = min( ret.fi , min(ret.fi ,ret.se) + cur.fi);\n    ret.se = ret.se + cur.se;\n    //trc(\"and totyu\",ret , idx);\n    if(idx + 1 == sz(S) || S[idx + 1] == '|' || S[idx + 1] == ')'){\n      trc(\"and\",idx , ret);\n      return ret;\n    }\n    idx += 2;// '&'のぶん\n  }\n}\n\nP eval_kakko(){\n// 最初　左かっこ　終わり　右かっこの次\n// orと同じ処理をして最後にかっこの分だけイテレータを進める\n  idx++;\n  P ret = eval_or();\n  idx++;\n  trc(\"kakko\",idx , ret);\n  return ret;\n}\n\n\n\nint main(){\n  in(S);\n  P ans = eval_or();\n  out(ans);\n\n\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic char[] S;\n\tstatic int pos;\n\n\tpublic static void main(String[] args) {\n\t\tS = sc.next().toCharArray();\n\t\tExprOr formula = parseOr();\n\t\tformula.calcCost();\n\t\tSystem.out.println(formula.cost0 + \" \" + formula.cost1);\n\t}\n\n\tstatic ExprOr parseOr() {\n\t\tExprOr ret = new ExprOr();\n\t\tret.ands.add(parseAnd());\n\t\twhile (pos < S.length && S[pos] == '|') {\n\t\t\tpos++;\n\t\t\tret.ands.add(parseAnd());\n\t\t}\n\t\treturn ret;\n\t}\n\n\tstatic ExprAnd parseAnd() {\n\t\tExprAnd ret = new ExprAnd();\n\t\tret.terms.add(parseTerm());\n\t\twhile (pos < S.length && S[pos] == '&') {\n\t\t\tpos++;\n\t\t\tret.terms.add(parseTerm());\n\t\t}\n\t\treturn ret;\n\t}\n\n\tstatic Term parseTerm() {\n\t\tTerm ret = new Term();\n\t\tif (S[pos] == '(') {\n\t\t\tpos++;\n\t\t\tret.expr = parseOr();\n\t\t}\n\t\tpos++;\n\t\treturn ret;\n\t}\n\n\tstatic abstract class Expr {\n\t\tint cost0, cost1;\n\t}\n\n\tstatic class ExprOr extends Expr {\n\t\tArrayList<ExprAnd> ands = new ArrayList<>();\n\n\t\tvoid calcCost() {\n\t\t\tcost1 = Integer.MAX_VALUE;\n\t\t\tfor (ExprAnd e : ands) {\n\t\t\t\te.calcCost();\n\t\t\t\tcost1 = Math.min(cost1, cost0 + e.cost1);\n\t\t\t\tcost0 += e.cost0;\n\t\t\t}\n//\t\t\tSystem.err.println(\"Or \" + cost0 + \" \" + cost1);\n\t\t}\n\t}\n\n\tstatic class ExprAnd extends Expr {\n\t\tArrayList<Term> terms = new ArrayList<>();\n\n\t\tvoid calcCost() {\n\t\t\tcost0 = Integer.MAX_VALUE;\n\t\t\tfor (Term t : terms) {\n\t\t\t\tt.calcCost();\n\t\t\t\tcost0 = Math.min(cost0, cost1 + t.cost0);\n\t\t\t\tcost1 += t.cost1;\n\t\t\t}\n//\t\t\tSystem.err.println(\"And \" + cost0 + \" \" + cost1);\n\t\t}\n\t}\n\n\n\tstatic class Term extends Expr {\n\t\tExprOr expr;\n\n\t\tvoid calcCost() {\n\t\t\tif (expr != null) {\n\t\t\t\texpr.calcCost();\n\t\t\t\tcost0 = expr.cost0;\n\t\t\t\tcost1 = expr.cost1;\n\t\t\t} else {\n\t\t\t\tcost0 = cost1 = 1;\n\t\t\t}\n//\t\t\tSystem.err.println(\"Term \" + cost0 + \" \" + cost1);\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n// Java8\npublic class Main\n{\n\tstatic Scanner sc = new Scanner(System.in);\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tnew Main().run();\n\t}\n\t\n\tvoid run()\n\t{\n\t\tString s = sc.nextLine();\n\t\tParser parser = new Parser(s);\n\t\tNode node = parser.getFormula();\n\t\tSystem.out.println(node.get0() + \" \" + node.get1());\n\t}\n}\nabstract class Node {\n\tprivate int cost0 = 0;\n\tprivate int cost1 = 0;\n\n\tpublic final int get0() {\n\t\tif(cost0>0) return cost0;\n\t\treturn cost0 = calc0();\n\t}\n\n\tpublic final int get1() {\n\t\tif(cost1>0) return cost1;\n\t\treturn cost1 = calc1();\n\t}\n\n\tabstract int calc0();\n\n\tabstract int calc1();\n}\nclass VarNode extends Node {\n\n\t@Override\n\tint calc0()\n\t{\n\t\treturn 1;\n\t}\n\n\t@Override\n\tint calc1()\n\t{\n\t\treturn 1;\n\t}\n\n\t@Override\n\tpublic String toString()\n\t{\n\t\treturn \"?\";\n\t}\n}\nclass AndNode extends Node {\n\tprivate Node left;\n\tprivate Node right;\n\n\tpublic AndNode(Node l, Node r)\n\t{\n\t\tleft = l;\n\t\tright = r;\n\t}\n\n\t@Override\n\tint calc0()\n\t{\n\t\treturn Math.min(left.get0(), left.get1() + right.get0());\n\t}\n\n\t@Override\n\tint calc1()\n\t{\n\t\treturn left.get1() + right.get1();\n\t}\n\n\t@Override\n\tpublic String toString()\n\t{\n\t\treturn \"(\" + left.toString() + \"&\" + right.toString() + \")\";\n\t}\n}\nclass OrNode extends Node {\n\tprivate Node left;\n\tprivate Node right;\n\n\tpublic OrNode(Node l, Node r)\n\t{\n\t\tleft = l;\n\t\tright = r;\n\t}\n\n\t@Override\n\tint calc0()\n\t{\n\t\treturn left.get0() + right.get0();\n\t}\n\n\t@Override\n\tint calc1()\n\t{\n\t\treturn Math.min(left.get1(), left.get0() + right.get1());\n\t}\n\n\t@Override\n\tpublic String toString()\n\t{\n\t\treturn \"(\" + left.toString() + \"|\" + right.toString() + \")\";\n\t}\n}\nclass Parser {\n\tprivate String text;\n\tint cur;\n\n\tpublic Parser(String s) {\n\t\ttext = s + \"$\";\n\t\tcur = 0;\n\t}\n\n\tpublic Node getTerm() {\n\t\tchar c = text.charAt(cur);\n\t\tif(c=='?') {\n\t\t\tcur++;\n\t\t\treturn new VarNode();\n\t\t}\n\t\tif(c=='(') {\n\t\t\tcur++;\n\t\t\tNode node = getOrExpr();\n\t\t\tassert(text.charAt(cur) == ')');\n\t\t\tcur++;\n\t\t\treturn node;\n\t\t}\n\t\tthrow new IllegalStateException();\n\t}\n\n\tpublic Node getAndExpr() {\n\t\tNode node = getTerm();\n\t\twhile(text.charAt(cur)=='&') {\n\t\t\tcur++;\n\t\t\tNode r = getTerm();\n\t\t\tnode = new AndNode(node, r);\n\t\t}\n\t\treturn node;\n\t}\n\n\tpublic Node getOrExpr() {\n\t\tNode node = getAndExpr();\n\t\twhile(text.charAt(cur)=='|') {\n\t\t\tcur++;\n\t\t\tNode r = getAndExpr();\n\t\t\tnode = new OrNode(node, r);\n\t\t}\n\t\treturn node;\n\t}\n\t\n\tpublic Node getFormula() {\n\t\treturn getOrExpr();\n\t}\n\n}\n"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(2*10**5)\nquestion = 1\nAND = -1\nOR = -2\nleft = -3\nright = -4\n\ntr = {'?': 1, '&': -1, '|': -2, '(': -3, ')': -4}\n\ndef evalor(L):\n    if len(L) == 1:\n        return L[0]\n    x0, x1 = L[0]\n    for i in range(1, len(L)):\n        y0, y1 = L[i]\n        x0, x1 = x0 + y0, min(x1, x0 + y1)\n    return (x0, x1)\n\ndef push(f, s):\n    if f and f[-1] == (AND, AND):\n        f.pop()\n        p = f.pop()\n        return push(f, andeval(p, s))\n    else:\n        f.append(s)\n        return f\n\ndef andeval(p, s):\n    x0, x1 = p\n    y0, y1 = s\n    return (min(x0, x1 + y0), x1 + y1)\n    \n\nS = [tr[s] for s in input().strip()]\nf = []\nfor s in S:\n    if s == question:\n        f = push(f, (s, s))\n    elif s == AND or s == left:\n        f.append((s, s))\n    elif s == right:\n        stack = []\n        while f[-1] != (left, left):\n            sp = f.pop()\n            assert sp[0] > 0 and sp[1] > 0\n            stack.append(sp)\n        assert f.pop() == (left, left)\n        push(f, evalor(stack[::-1]))\nf = evalor(f)\nprint(*f)\n"
  },
  {
    "language": "Python",
    "code": "# from inspect import currentframe\n# from sys import exit, stderr\n\n\n# debug function\n# def debug(*args):\n#     names = {id(v):k for k,v in currentframe().f_back.f_locals.items()}\n#     print(', '.join(names.get(id(arg),'???') + str(id(arg)) +' = '+repr(arg) for arg in args), file=stderr)\n\n\nsrc = list(str(input()))\ntokens = [tok for tok in src if tok != \" \"]\n# debug(tokens)\n\n# \"\" as EOF\ntokens.append(\"\")\ncur = 0\ndef parse_formula():\n    return parse_or()\n\ndef parse_or():\n    global cur\n    lhs = parse_and()\n    if tokens[cur] == \"|\":\n        cur += 1\n        rhs = parse_or()\n        zero = lhs[0] + rhs[0]\n        one = min(lhs[1], lhs[0] + rhs[1])\n        return (zero, one)\n    return lhs\n\ndef parse_and():\n    global cur\n    lhs = parse_term()\n    if tokens[cur] == \"&\":\n        cur += 1\n        rhs = parse_and()\n        zero = min(lhs[0], lhs[1] + rhs[0])\n        one = lhs[1] + rhs[1]\n        return (zero, one)\n    return lhs\n\ndef parse_term():\n    global cur\n    if tokens[cur] == \"?\":\n        cur += 1\n        # debug(cur, 1)\n        return [1, 1]\n    elif tokens[cur] == \"(\":\n        cur += 1\n        # debug(cur, \"or\")\n        res = parse_or()\n        if tokens[cur] != \")\":\n            raise Exception(\"not closed\")\n        cur += 1\n        # debug(cur)\n        return res\nans = parse_formula()\nprint(ans[0], ans[1])\n# debug(cur)\n# print(len(tokens))\n\n"
  },
  {
    "language": "Rust",
    "code": "use std::cmp;\n\nfn main() {\n    let s = std::io::stdin();\n    let mut sc = Scanner { stdin: s.lock() };\n    let s = sc.chars();\n    let result = parse(&s);\n    println!(\"{} {}\", result.0, result.1);\n}\n\nfn read_char(_: &Vec<char>, pos: &mut usize) {\n    *pos += 1;\n}\n\nfn next_char(s: &Vec<char>, pos: &mut usize) -> char {\n    s[*pos]\n}\n\nfn parse_term(s: &Vec<char>, pos: &mut usize) -> (usize, usize) {\n    if next_char(s, pos) == '(' {\n        read_char(s, pos);\n        let result = parse_or(s, pos);\n        read_char(s, pos);\n        result\n    } else {\n        read_char(s, pos);\n        (1, 1)\n    }\n}\n\nfn parse_and(s: &Vec<char>, pos: &mut usize) -> (usize, usize) {\n    let mut left = parse_term(s, pos);\n    while *pos < s.len() && next_char(s, pos) == '&' {\n        read_char(s, pos);\n        let right = parse_term(s, pos);\n        left.0 = cmp::min(left.0, left.1 + right.0);\n        left.1 += right.1;\n    }\n    left\n}\n\nfn parse_or(s: &Vec<char>, pos: &mut usize) -> (usize, usize) {\n    let mut left = parse_and(s, pos);\n    while *pos < s.len() && next_char(s, pos) == '|' {\n        read_char(s, pos);\n        let right = parse_and(s, pos);\n        left.1 = cmp::min(left.1, left.0 + right.1);\n        left.0 += right.0;\n    }\n    left\n}\n\nfn parse(s: &Vec<char>) -> (usize, usize) {\n    parse_or(s, &mut 0)\n}\n\npub struct Scanner<R> {\n    stdin: R,\n}\n\nimpl<R: std::io::Read> Scanner<R> {\n    pub fn read<T: std::str::FromStr>(&mut self) -> T {\n        use std::io::Read;\n        let buf = self\n            .stdin\n            .by_ref()\n            .bytes()\n            .map(|b| b.unwrap())\n            .skip_while(|&b| b == b' ' || b == b'\\n')\n            .take_while(|&b| b != b' ' && b != b'\\n')\n            .collect::<Vec<_>>();\n        unsafe { std::str::from_utf8_unchecked(&buf) }\n            .parse()\n            .ok()\n            .expect(\"Parse error.\")\n    }\n    pub fn vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.read()).collect()\n    }\n    pub fn chars(&mut self) -> Vec<char> {\n        self.read::<String>().chars().collect()\n    }\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "fn calc_term(s: &[char], k: &mut usize) -> (usize, usize) {\n    let op = s[*k];\n    *k += 1;\n    if op == '?' {\n        (1, 1)\n    } else {\n        assert!(op == '(');\n        let ans = calc_or(s, k);\n        assert!(s[*k] == ')');\n        *k += 1;\n        ans\n    }\n}\n\nfn calc_and(s: &[char], k: &mut usize) -> (usize, usize) {\n    let mut ans = calc_term(s, k);\n    while *k < s.len() && s[*k] == '&' {\n        *k += 1;\n        let r = calc_term(s, k);\n        ans.0 = std::cmp::min(ans.0, ans.1 + r.0);\n        ans.1 += r.1;\n    }\n    ans\n}\n\nfn calc_or(s: &[char], k: &mut usize) -> (usize, usize) {\n    let mut ans = calc_and(s, k);\n    while *k < s.len() && s[*k] == '|' {\n        *k += 1;\n        let r = calc_and(s, k);\n        ans.1 = std::cmp::min(ans.1, ans.0 + r.1);\n        ans.0 += r.0;\n    }\n    ans\n}\n\nfn run() {\n    let mut s = String::new();\n    std::io::stdin().read_line(&mut s).unwrap();\n    let s: Vec<char> = s.trim().chars().collect();\n    let ans = calc_or(&s, &mut 0);\n    println!(\"{} {}\", ans.0, ans.1);\n}\n\nfn main() {\n    run();\n}\n\n"
  }
]