[
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cfloat>\n#include<cassert>\n#include<cmath>\n#include<vector>\n#include<queue>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS )\n#define dle(a, b) (equals(a, b) || a < b )\nstatic const double PI = acos(-1);\n\nclass Point{\n    public:\n    double x, y;\n    \n    Point ( double x = 0, double y = 0): x(x), y(y){}\n    \n    Point operator + ( Point p ){ return Point(x + p.x, y + p.y); }\n    Point operator - ( Point p ){ return Point(x - p.x, y - p.y); }\n    Point operator * ( double a ){ return Point(x*a, y*a); }\n    Point operator / ( double a ){ return Point(x/a, y/a); }\n\n    double abs() { return sqrt(norm());}\n    double norm() { return x*x + y*y; }\n\n    bool operator < ( const Point &p ) const {\n\treturn x != p.x ? x < p.x : y < p.y;\n    }\n\n    bool operator == ( const Point &p ) const {\n\treturn fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n    }\n};\n\ntypedef Point Vector;\n\nclass Segment{\n    public:\n    Point p1, p2;\n    Segment(Point s = Point(), Point t = Point()): p1(s), p2(t){}\n};\n\ntypedef Segment Line;\n\ntypedef vector<Point> Polygon;\n\ndouble norm( Vector a ){ return a.x*a.x + a.y*a.y; }\ndouble abs( Vector a ){ return sqrt(norm(a)); }\nPoint polar( double a, double r ){ return Point(cos(r)*a, sin(r)*a);}\ndouble getDistance( Vector a, Vector b ){ return abs(a - b); }\ndouble dot( Vector a, Vector b ){ return a.x*b.x + a.y*b.y; }\ndouble cross( Vector a, Vector b ){ return a.x*b.y - a.y*b.x; }\n\ndouble arg(Vector p){\n    return atan2(p.y, p.x);\n}\n\nPoint project( Segment s, Point p ){\n    Vector base = s.p2 - s.p1;\n    double t = dot(p - s.p1, base)/norm(base);\n    return s.p1 + base*t;\n}\n\nPoint reflect( Segment s, Point p ){\n    return p + (project(s, p) - p)*2.0;\n}\n\nbool isOnSegment( Point a, Point b, Point c){\n    if ( a == c || b == c ) return true;\n    return (abs(a-c) + abs(c-b) < abs(a-b) + EPS );\n}\n\nbool isOrthogonal( Vector a, Vector b ){\n     return equals( dot(a, b), 0.0 );\n}\n\nbool isOrthogonal( Point a1, Point a2, Point b1, Point b2 ){\n    return isOrthogonal( a1 - a2, b1 - b2 );\n}\n\nbool isOrthogonal( Segment s1, Segment s2 ){\n    return equals( dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0 );\n}\n\nbool isParallel( Vector a, Vector b ){\n    return equals( cross(a, b), 0.0 );\n}\n\nbool isParallel( Point a1, Point a2, Point b1, Point b2){\n    return isParallel( a1 - a2, b1 - b2 );\n}\n\nbool isParallel( Segment s1, Segment s2 ){\n    return equals( cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0 );\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw( Point p0, Point p1, Point p2 ){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if ( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n    if ( cross(a, b) < -EPS ) return CLOCKWISE;\n    if ( dot(a, b) < -EPS ) return ONLINE_BACK;\n    if ( norm(a) < norm(b) ) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool isIntersect(Point p1, Point p2, Point p3, Point p4){\n    return ( ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t     ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0 );\n}\n\nbool isIntersect(Segment s1, Segment s2){\n    return isIntersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n\nPoint getCrossPoint(Segment s1, Segment s2){\n    assert( isIntersect(s1, s2) );\n    Vector base = s2.p2 - s2.p1;\n    double d1 = abs(cross(base, s1.p1 - s2.p1));\n    double d2 = abs(cross(base, s1.p2 - s2.p1));\n    double t = d1/(d1 + d2);\n    return s1.p1 + (s1.p2 - s1.p1)*t;\n}\n\nPoint getCrossPointLines( Line s1, Line s2){\n    Vector a = s1.p2 - s1.p1;\n    Vector base = s2.p2 - s2.p1;\n    return s1.p1 + a * cross(base, s2.p1 - s1.p1)/cross(base, a);\n}\n\nPolygon cutPolygon( Polygon P, Line l ){\n    Polygon u;\n    for ( int i = 0; i < P.size(); i++ ){\n\tPoint a = P[i], b = P[(i+1)%P.size()];\n\tif ( ccw(l.p1, l.p2, a) != CLOCKWISE ) u.push_back(a);\n\tif ( ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) == -1 ){\n\t    u.push_back(getCrossPointLines(Segment(a, b), l));\n\t}\n    }\n    return u;\n}\ndouble getArea(Polygon p){\n    double sum = 0.0;\n    for(int i = 0; i < p.size(); i++){\n\tsum += cross(p[i], p[(i+1)%p.size()]);\n    }\n    return abs(sum/2);\n}\n\nLine getCutLine( Point p1, Point p2 ){\n    Vector v = p2 - p1;\n    v = polar(abs(v), arg(v)+PI/2.0);\n    double dx = (p2.x + p1.x)/2.0;\n    double dy = (p2.y + p1.y)/2.0;\n    return Line(Point(dx, dy), Point(v.x+dx, v.y+dy));\n}\n\n#define MAX 10\n\nvector<Polygon> getVoronoi( Polygon base, Point PV[MAX], int n){\n    vector<Polygon> V;\n    for ( int i = 0; i < n; i++ ){\n\tPolygon P = base;\n\tfor ( int j = 0; j < n; j++ ){\n\t    if ( i == j ) continue;\n\t    P = cutPolygon(P, getCutLine(PV[i], PV[j]));\n\t}\n\tV.push_back(P);\n    }\n    return V;\n}\n\n\nint N, M;\n\nint main(){\n    double x, y;\n    while(1){\n\tcin >> N >> M;\n\tif ( N == 0 && M == 0 ) break;\n\tPolygon base;\n\tPoint PV[MAX];\n\tfor ( int i = 0; i < N; i++ ){\n\t    cin >> x >> y;\n\t    base.push_back(Point(x, y));\n\t}\n\tfor ( int i = 0; i < M; i++ ){\n\t    cin >> x >> y;\n\t    PV[i] = Point(x, y);\n\t}\n\tvector<Polygon> v = getVoronoi(base, PV, M);\n\tfor ( int i = 0; i < v.size(); i++ ){\n\t    printf(\"%.8lf\\n\", getArea(v[i]));\n\t}\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 10;\nconst int MAX_M = 10;\n\n/* typedef */\n\ntemplate <typename T>\nstruct Pt {\n  T x, y;\n\n  Pt() {}\n  Pt(T _x, T _y) : x(_x), y(_y) {}\n  Pt(const Pt& pt) : x(pt.x), y(pt.y) {}\n\n  bool operator==(const Pt pt) const { return x == pt.x && y == pt.y; }\n  Pt<T> operator+(const Pt pt) const { return Pt<T>(x + pt.x, y + pt.y); }\n  Pt<T> operator-() const { return Pt<T>(-x, -y); }\n  Pt<T> operator-(const Pt pt) const { return Pt<T>(x - pt.x, y - pt.y); }\n  Pt<T> operator*(T t) const { return Pt<T>(x * t, y * t); }\n  Pt<T> operator/(T t) const { return Pt<T>(x / t, y / t); }\n  T dot(Pt v) const { return x * v.x + y * v.y; }\n  T cross(Pt v) const { return x * v.y - y * v.x; }\n  Pt<T> mid(const Pt pt) { return Pt<T>((x + pt.x) / 2, (y + pt.y) / 2); }\n  T d2() { return x * x + y * y; }\n  double d() { return sqrt(d2()); }\n\n  Pt<T> rot(double th) {\n    double c = cos(th), s = sin(th);\n    return Pt<T>(c * x - s * y, s * x + c * y);\n  }\n\n  Pt<T> rot90() { return Pt<T>(-y, x); }\n\n  bool operator<(const Pt& pt) const {\n    return x < pt.x || (x == pt.x && y < pt.y);\n  }\n\n  void print(string format) {\n    printf((\"(\" + format + \", \" + format + \")\\n\").c_str(), x, y);\n  }\n  void print() { print(\"%.6lf\"); }\n};\n\ntypedef Pt<double> pt;\ntypedef vector<pt> vpt;\n\nstruct CL {\n  pt p;\n  double t0, t1;\n  CL() {}\n  CL(const pt& _p, double _t0, double _t1) : p(_p), t0(_t0), t1(_t1) {}\n};\n\n/* global variables */\n\nint n, m;\npt pts[MAX_N], cpts[MAX_M];\n\n/* subroutines */\n\nbool cross_lines(const pt& a0, const pt& a1, const pt& b0, const pt& b1,\n                 CL& cl) {\n  pt da = a1 - a0;\n  pt db = b1 - b0;\n\n  double op01 = da.cross(db);\n  if (op01 == 0.0) return false; /* need to handle parallel?? */\n\n  pt v = b0 - a0;\n  double op0 = v.cross(da);\n  double op1 = v.cross(db);\n\n  double t0 = op1 / op01;\n  double t1 = op0 / op01;\n\n  cl.p = db * t1 + b0;\n  cl.t0 = t0;\n  cl.t1 = t1;\n  return true;\n}\n\nvoid convex_cut(const vpt& scpol, vpt& dcpol, const pt& pt0, const pt& pt1) {\n  int n = scpol.size();\n  pt v = pt1 - pt0;\n  dcpol.clear();\n\n  for (int i = 0; i < n; i++) {\n    pt cpt0 = scpol[i];\n    double cr0 = v.cross(cpt0 - pt0);\n    if (cr0 >= 0.0) dcpol.push_back(cpt0);\n    \n    pt cpt1 = scpol[(i + 1) % n];\n    double cr1 = v.cross(cpt1 - pt0);\n    if (cr0 * cr1 < 0.0) {\n      CL cl;\n      cross_lines(pt0, pt1, cpt0, cpt1, cl);\n      dcpol.push_back(cl.p);\n    }\n  }\n}\n\ndouble convex_area(vpt& cpol) {\n  int n = cpol.size();\n  if (n < 3) return 0.0;\n\n  pt& p0 = cpol[0], v0 = cpol[1] - p0;\n  double ar = 0.0;\n  \n  for (int i = 2; i < n; i++) {\n    pt v1 = cpol[i] - p0;\n    ar += v0.cross(v1);\n    v0 = v1;\n  }\n\n  return ar / 2;\n}\n\n/* main */\n\nint main() {\n  for (;;) {\n    cin >> n >> m;\n    if (n == 0) break;\n    \n    for (int i = 0; i < n; i++) cin >> pts[i].x >> pts[i].y;\n    for (int i = 0; i < m; i++) cin >> cpts[i].x >> cpts[i].y;\n\n    for (int i = 0; i < m; i++) {\n      vpt cpol0(pts, pts + n), cpol1;\n      pt& cpti = cpts[i];\n\n      for (int j = 0; j < m; j++)\n\tif (i != j) {\n\t  pt p0 = (cpti + cpts[j]) / 2;\n\t  pt v0 = (cpts[j] - cpti).rot90();\n\n\t  convex_cut(cpol0, cpol1, p0, p0 + v0);\n\t  cpol0 = cpol1;\n\t}\n\n      double ar = convex_area(cpol0);\n      printf(\"%.6lf\\n\", ar);\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-5;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\nint sign(double r){ return (r < -EPS) ? -1 : (r > EPS) ? 1 : 0; }\nbool eq(double a, double b){ return abs(b - a) < EPS; }\n\nstruct Point{\n  double x, y;\n  Point() {}\n  Point(double x, double y) : x(x), y(y) {}\n  Point operator+(const Point& b) const { return Point(x + b.x, y + b.y); }\n  Point operator-(const Point& b) const { return Point(x - b.x, y - b.y); }\n  Point operator*(const double b) const { return Point(x * b, y * b); }\n  Point operator*(const Point& b) const { return Point(x * b.x - y * b.y, x * b.y + y * b.x); }\n  Point operator/(const double b) const { return Point(x / b, y / b); }\n  bool operator< (const Point& b) const { return x != b.x ? x < b.x : y < b.y; }\n  bool operator==(const Point& b) const { return eq(x, b.x) && eq(y, b.y); }\n  double norm(){ return x * x + y * y; }\n  double arg(){ return atan2(x, y); }\n  double abs(){ return sqrt(norm()); }\n  Point rotate(double theta){ return Point(cos(theta) * x - sin(theta) * y, sin(theta) * x + cos(theta) * y); }\n  Point rotate90(){ return Point(-y, x); }\n};\n\nostream& operator<<(ostream& os, Point& p){ return os<<\"(\"<<p.x<<\",\"<<p.y<<\")\"; }\nistream& operator>>(istream& is, Point& a){ return is>>a.x>>a.y; }\ndouble dot(const Point& a, const Point& b){ return a.x * b.x + a.y * b.y; }\ndouble cross(const Point& a, const Point& b){ return a.x * b.y - a.y * b.x; }\nPoint polor(double rho, double theta){ return Point(rho * cos(theta), rho * sin(theta)); }\n\nstruct Line : public vector<Point> {\n  Line(const Point& a, const Point& b) {\n    push_back(a); push_back(b);\n  }\n  Point vector() const {\n    return back() - front();\n  }\n};\nstruct Circle : Point {\n  double r;\n  Circle(Point p, double r) : Point(p), r(r) { }\n};\ntypedef vector<Point> Polygon;\nPoint curr(const Polygon& a, int x){ return a[x]; }\nPoint next(const Polygon& a, int x){ return a[(x + 1) % a.size()]; }\nPoint prev(const Polygon& a, int x){ return a[(x - 1 + a.size()) % a.size()]; }\n\n//a->b->c\nint ccw(Point a, Point b, Point c) {\n  b = b - a; c = c - a;\n  if (cross(b, c) > EPS)   return +1; // 反時計回り\n  if (cross(b, c) < -EPS)   return -1; // 時計回り\n  if (dot(b, c) < 0)     return +2; // c--a--b の順番で一直線上\n  if (b.norm() < c.norm()) return -2; // a--b--c の順番で一直線上\n  return 0;                         // a--c--b の順番で一直線上\n}\n// 二直線の交差判定\nbool intersectLL(const Line& l, const Line& m) {\n  return abs(cross(l.vector(), m[1] - m[0])) > EPS || // 傾きが異なる\n         abs(cross(l.vector(), m[0] - l[0])) < EPS;   // 同じ直線である\n}\n// 直線と線分の交差判定\nbool intersectLS(const Line& l, const Line& s) {\n  return cross(l.vector(), s[0] - l[0]) * cross(l.vector(), s[1] - l[0]) < EPS; //直線lについて、線分sの端点が異なる側にある\n}\n// 直線と点の交差判定\nbool intersectLP(const Line& l, const Point& p) {\n  return abs(ccw(l[0], l[1], p)) != 1;\n}\n// 二つの線分の交差判定\nbool intersectSS(const Line& s, const Line& t) {\n  return ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n         ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\n// 線分と点の交差判定\nbool intersectSP(const Line& s, const Point& p) {\n  return ccw(s[0], s[1], p) == 0;\n}\n// 円と点の交差判定(EPS注意)\nbool intersectCP(const Circle& c, const Point& p){\n  return (c - p).abs() < c.r + EPS;\n}\n// 二つの円の交差判定(EPS注意)\nbool intersectCC(const Circle& c, const Circle& d){\n  return (c - d).abs() < c.r + d.r + EPS && (c - d).abs() > abs(c.r - d.r) - EPS;\n}\n// 射影\nPoint projection(const Line& l, const Point& p){\n  double t = dot(p - l[0], l.vector()) / l.vector().norm();\n  return l[0] + l.vector() * t;\n}\n// 反射\nPoint reflection(const Line& l, const Point& p){\n  return p + (projection(l, p) - p) * 2;\n}\n// 直線と点の距離\ndouble distanceLP(const Line& l, const Point& p){\n  return (p - projection(l, p)).abs();\n}\n// 二直線の距離\ndouble distanceLL(const Line& l, const Line& m){\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\n// 直線と線分の距離\ndouble distanceLS(const Line& l, const Line& s){\n  if(intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\n// 線分と点の距離\ndouble distanceSP(const Line& s, const Point& p){\n  const Point r = projection(s, p);\n  if(intersectSP(s, r)) return (r - p).abs(); //垂線が線分に交わるとき\n  return min((s[0] - p).abs(), (s[1] - p).abs());\n}\n// 二つの線分の距離\ndouble distanceSS(const Line& s, const Line& t){\n  if(intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n// 二直線の交点\nPoint crosspointLL(const Line& l, const Line& m){\n  double d = cross(m.vector(), l.vector());\n  if(abs(d) < EPS) assert(false); // 直線が交わらない\n  return l[0] + l.vector() * cross(m.vector(), m[1] - l[0]) * (1.0 / d);\n}\n\nPolygon convex_cut(const Polygon& P, const Line& l){\n  Polygon Q;\n  REP(i, P.size()){\n    Point A = curr(P, i), B = next(P, i);\n    if(ccw(l[0], l[1], A) != -1) Q.push_back(A); //Aが直線lの右側でない\n    if(intersectLS(l, Line(A, B))) \n      Q.push_back(crosspointLL(l, Line(A, B)));\n  }\n  return Q;\n}\nLine median(const Point& a, const Point& b){\n  Point mid((a.x + b.x) / 2.0, (a.y + b.y) / 2.0);\n  Point vec = (mid - a).rotate90();\n  return Line(mid, mid + vec);\n}\n\ndouble area(const Polygon& P) {\n  double A = 0;\n  REP(i, P.size()){\n    A += cross(curr(P, i), next(P, i));\n  }\n  return A / 2.0;\n}\nint main(){\n  int N, M;\n  while(cin>>N>>M){\n    Polygon island(N);\n    REP(i, N) cin>>island[i];\n    vector<Point> castle(M);\n    REP(i, M) cin>>castle[i];\n    REP(i, M){\n      Polygon land = island;\n      REP(j, M) if(i != j){\n        land = convex_cut(land, median(castle[i], castle[j]));\n      }\n      printf(\"%.6lf\\n\", area(land));\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\ntypedef long double ld;\nconst ld PI = acos(-1.0);\nbool eq(ld a, ld b) { return abs(a - b) < EPS; }\ntypedef complex<ld> Point;\ntypedef vector<Point> Polygon;\n\nnamespace std\n{\n\tbool operator < (const Point& a, const Point& b)\n\t{\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\nstruct Line\n{\n\tPoint a, b;\n\tLine(Point p, Point q) :a(p), b(q) {};\n\tLine(ld x1, ld y1, ld x2, ld y2) :a(Point(x1, y1)), b(Point(x2, y2)) {};\n};\n\nstruct Circle\n{\n\tPoint p; ld r;\n\tCircle(Point a, ld b) :p(a), r(b) {};\n};\n\nld dot(Point a, Point b)\n{\n\treturn real(conj(a)*b);\n}\n\nld cross(Point a, Point b)\n{\n\treturn imag(conj(a)*b);\n}\n\nint ccw(Point a, Point b, Point c)\n{\n\tb -= a; c -= a;\n\tif (cross(b, c) > EPS) return 1;    //counter cloclwise\n\tif (cross(b, c) < -EPS) return -1;  //cloclwise\n\tif (dot(b, c) < 0) return 2;        //c--a--b on line \n\tif (norm(b) < norm(c)) return -2;   //a--b--c on line\n\treturn 0;                           //a--c--b on line\n}\n\nbool isis_ll(Line l, Line m)\n{\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > EPS;\n}\n\nbool isis_ls(Line l, Line s)\n{\n\treturn cross(l.b - l.a, s.a - l.a)*cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool isis_ss(Line s, Line t)\n{\n\treturn (ccw(s.a, s.b, t.a)*ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a)*ccw(t.a, t.b, s.b) <= 0);\n}\n\nbool isis_lp(Line l, Point p)\n{\n\treturn (abs(cross(l.b - p, l.a - p)) < EPS);\n}\n\nbool isis_sp(Line s, Point p)\n{\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a)) < EPS;\n}\n\nPoint projection(Line l, Point p)\n{\n\tPoint base = l.b - l.a;\n\tld r = dot(p - l.a, base) / norm(base);\n\treturn l.a + base*r;\n}\n\nPoint mirror(Line l, Point p)\n{\n\treturn Point(2, 0)*projection(l, p) - p;\n}\n\nld dist_lp(Line l, Point p)\n{\n\treturn abs(p - projection(l, p));\n}\n\nld dist_ll(Line l, Line m)\n{\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(Line l, Line s)\n{\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(Line s, Point p)\n{\n\tPoint r = projection(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(Line s, Line t)\n{\n\tif (isis_ss(s, t)) return 0;\n\treturn min(min(dist_sp(s, t.a), dist_sp(s, t.b)), min(dist_sp(t, s.a), dist_sp(t, s.b)));\n}\n\nPoint is_ll(Line s, Line t)\n{\n\tld a = cross(s.b - s.a, t.b - t.a);\n\tld b = cross(s.b - s.a, s.b - t.a);\n\treturn t.a + b / a*(t.b - t.a);\n}\n\nvector<Point> is_cc(Circle c1, Circle c2)\n{\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d*d + pow(c1.r, 2) - pow(c2.r, 2)) / (2 * d);\n\tld dfr = pow(c1.r, 2) - rc*rc;\n\tif (abs(dfr) < EPS) dfr = 0;\n\tif (dfr < 0.0) return res;\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff*Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff*Point(rc, -rs));\n\treturn res;\n}\n\nint isis_cc(Circle c1, Circle c2)\n{\n\tld d = abs(c1.p - c2.p);\n\tif (d - c1.r - c2.r < -EPS) return -2; //separate\n\tif (abs(d - c1.r - c2.r) < EPS) return -1; //circumscribe\n\tif (c1.r < c2.r) swap(c1, c2);\n\tif (abs(d - c1.r + c2.r) < EPS) return 1;//inscribe\n\tif (c1.r - d - c2.r > EPS) return 2;//involve\n\telse return 0;//intersect\n}\n\nbool isis_cl(Circle c, Line l)\n{\n\tld d = dist_lp(l, c.p);\n\treturn d - c.r < -EPS;\n}\n\nvector<Point> is_cl(Circle c, Line l)\n{\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d > c.r + EPS) return res;\n\tld len = (d > c.r) ? 0 : sqrt(c.r*c.r - d*d);\n\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\tres.push_back(projection(l, c.p) + len*nor);\n\tif (abs(len) > EPS) res.push_back(projection(l, c.p - len*nor));\n\treturn res;\n}\n\nvector<Point> is_cs(Circle c, Line s)\n{\n\tvector<Point> v = is_cl(c, s), res;\n\tREP(i, v.size())\n\t{\n\t\tif (ccw(s.a, v[i], s.b) == -2) res.push_back(v[i]);\n\t}\n\treturn res;\n}\n\nvector<Line> tangent_cp(Circle c, Point p)\n{\n\tvector<Line> res;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return res; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tres.push_back(Line(p, p + v1));\n\tif (l < EPS) return res;\n\tres.push_back(Line(p, p + v2));\n\treturn res;\n}\n\nvector<Line> tangent_cc(Circle c1, Circle c2)\n{\n\tvector<Line> res;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -EPS)\n\t{\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tres = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > EPS)\n\t{\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nres = tangent_cp(c1, out);\n\t\tres.insert(res.end(), nres.begin(), nres.end());\n\t}\n\telse\n\t{\n\t\tPoint v = c2.p - c1.p; v /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tres.push_back(Line(q1, q1 + v));\n\t\tres.push_back(Line(q2, q2 + v));\n\t}\n\treturn res;\n}\n\nPolygon ConvexCut(const Polygon& g, const Line l)\n{\n\tPolygon res;\n\tREP(i, g.size())\n\t{\n\t\tPoint a = g[i], b = g[(i + 1) % g.size()];\n\t\tif (ccw(l.a, l.b, a) != -1) res.push_back(a);\n\t\tif (ccw(l.a, l.b, a)*ccw(l.a, l.b, b) < 0) res.push_back(is_ll(Line(a, b), l));\n\t}\n\treturn res;\n}\n\nvector<Line> sui(Point a, Point b)\n{\n\tPoint m = (a + b) / Point(2, 0);\n\tPoint v = b - a;\n\tPoint n1(v.imag(), -v.real()), n2(-v.imag(), v.real());\n\tvector<Line> res = { Line(m, m + n1), Line(m,m + n2) };\n\treturn res;\n}\n\n\nld area(const Polygon& p)\n{\n\tld res = 0;\n\tREP(i, p.size())\n\t{\n\t\tres += cross(p[i], p[(i + 1) % p.size()]);\n\t}\n\treturn res / 2;\n}\n\n\nint main()\n{\n\tint n, m;\n\tcin >> n >> m;\n\tPolygon g;\n\tREP(i, n)\n\t{\n\t\tld x, y;\n\t\tcin >> x >> y;\n\t\tg.emplace_back(x, y);\n\t}\n\tvector<Point> ps;\n\tREP(i, m)\n\t{\n\t\tld x, y;\n\t\tcin >> x >> y;\n\t\tps.emplace_back(x, y);\n\t}\n\tREP(i, m)\n\t{\n\t\tPolygon tmp = g;\n\t\tREP(j, m)\n\t\t{\n\t\t\tif (i == j) continue;\n\t\t\tvector<Line> ls = sui(ps[i], ps[j]);\n\t\t\t\n\t\t\tif (ccw(ls[0].a, ls[0].b, ps[i]) == 1) tmp = ConvexCut(tmp, ls[0]);\n\t\t\telse tmp = ConvexCut(tmp, ls[1]);\n\t\t}\n\t\tcout << D10 << area(tmp) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<cmath>\n#include<vector>\n#include<cstdlib>\n#include<cassert>\n#include<map>\n#include<iomanip>\n#define _A_ true\n#define EPS 1e-10\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\nusing namespace std;\nclass Point{\npublic:\n  double x,y;\n  Point(double x =0,double y=0):x(x),y(y){}\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(x*a,y*a);}\n  Point operator / (double a){return Point(x/a,y/a);} //もし悪を使うなら要確認\n \n  double norm() {return x*x+y*y;}\n  double abs() {return sqrt(norm());}\n \n  bool operator < (const Point &p) const{\n    return x != p.x ? x < p.x : y < p.y; \n  }\n \n  bool operator == (const Point &p) const{\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\ntypedef Point Point;\nstruct Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p = Point(),Point pp = Point()):p1(p),p2(pp){}\n};\n \ntypedef vector<Point> Polygon;\ntypedef Segment Line;\n\nclass Voronoi\n{\npublic:\n  Polygon poly;\n \n  Voronoi(Polygon poly):poly(poly){}\n\n  double norm(Point p){\n    return p.x*p.x+p.y*p.y;\n  }\n \n  double abs(Point p){\n    return sqrt(norm(p));\n  }\n \n  Point polar(double a,double rad){\n    return Point(a*cos(rad),a*sin(rad));\n  }\n \n  double args(Point p){\n    return atan2(p.y,p.x);\n  }\n \n  double dot(Point a,Point b){\n    return a.x*b.x+a.y*b.y;\n  }\n \n  double cross(Point a,Point b){\n    return a.x*b.y-b.x*a.y;\n  }\n \n  Point project(Segment s,Point p){\n    Point base = s.p2 - s.p1;\n    double t = dot(p-s.p1,base)/base.norm();\n    return s.p1+base*t;\n  }\n \n  Point reflect (Segment s, Point p){\n    return p + (project(s,p)-p)*2.0;\n  }\n \n  int ccw(Point p0,Point p1,Point p2){\n    Point a = p1-p0;\n    Point b = p2-p0;\n    if(cross(a,b) > EPS) return COUNTER_CLOCKWISE;\n    if(cross(a,b) < -EPS) return CLOCKWISE;\n    if(dot(a,b) < -EPS) return ONLINE_BACK;\n    if(a.norm() < b.norm() ) return ONLINE_FRONT;\n    return ON_SEGMENT;\n  }\n \n  bool isIntersect(Point p1,Point p2,Point p3,Point p4){\n    return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <= 0 && ccw(p3,p4,p1) * ccw(p3,p4,p2) <= 0 );\n  }\n \n  bool isIntersect(Segment s1,Segment s2){\n    return isIntersect(s1.p1,s1.p2,s2.p1,s2.p2);\n  }\n\n  Point getCrossPointSegments(Segment s1,Segment s2){\n    //assert(isIntersect(s1,s2));\n    Point base = s2.p2 - s2.p1;\n    double d1 = abs(cross(base,s1.p1-s2.p1));\n    double d2 = abs(cross(base,s1.p2-s2.p1));\n    double t = d1/(d1+d2);\n    return s1.p1+(s1.p2-s1.p1)*t;\n  }\n\n\n  Point getCrossPointLines( Line s1, Line s2){\n\n    Point a = s1.p2 - s1.p1;\n    Point base = s2.p2 -s2.p1;\n    return s1.p1 + a * (cross(base, s2.p1 - s1.p1)/cross(base, a));\n  }\n\n  Polygon cutPolygon( Polygon P, Line l ){\n    Polygon u;\n    \n    for ( int i = 0; i < P.size(); i++ ){\n      Point a = P[i], b = P[(i+1)%P.size()];\n\t\n      if ( ccw(l.p1, l.p2, a) != CLOCKWISE ) u.push_back(a);\n      if ( ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) == -1 ){\n\tu.push_back(getCrossPointLines(Segment(a, b), l));\n      }\n    }   \n    return u;\n  } \n \n  Line CreateLine(Point p,Point pp){\n    Point mid = (p+pp)/2;\n    Point sl = pp-p;//原点に5\n    double rad = args(sl);\n    Point ap = polar(abs(sl),rad+M_PI/2)+mid;\n    //ap.x = abs(sl)*cos(rad+M_PI/2)+mid.x;\n    //ap.y = abs(sl)*sin(rad+M_PI/2)+mid.y;\n    return Line(mid,ap);\n  } \n \n  double AreaCalc(Polygon p){\n    double area = 0;\n    for(int i=0;i<p.size();i++)\n      area+=cross(p[i],p[(i+1)%p.size()]);\n    return fabs(area)/2.0;\n  } \n\n  //サイトposに対するボロノイセルV(pos)の面積を返す \n  //pointsは多角形の中に存在するサイトの集合]\n  //posはpoints中の自分の位置\n  double getAreaOfVoronoi(vector<Point>& points,int pos)\n  {\n    Polygon polx = poly;\n    int N = points.size();\n    for(int i=0;i<N;i++)\n      if(i != pos)\n\tpolx = cutPolygon(polx,CreateLine(points[pos],points[i]));\n    return AreaCalc(polx);\n  }  \n\n};\n\nint main(){\n\n  int N,M;\n  while(cin >> N >> M,N|M){\n  \n  vector<Point> l(N);\n  vector<Point> C(M);\n  for(int i=0;i<N;i++)\n    {\n      cin >> l[i].x >> l[i].y;\n      l[i].x += 200,l[i].y += 200;\n    }\n  for(int i=0;i<M;i++)\n    {\n      cin >> C[i].x >> C[i].y;\n      C[i].x += 200,C[i].y += 200;\n    }\n  for(int i=0;i<M;i++)\n    {\n\n      Polygon poly; \n      for(int j=0;j<N;j++)\n\tpoly.push_back(l[j]);\n      Voronoi vor(poly);\n\n      cout << setiosflags(ios::fixed) << setprecision(4) << vor.getAreaOfVoronoi(C,i) << endl;\n\n    }  \n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<complex>\n\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef vector<P> Polygon;\n\ndouble cross(P a,P b){\n  return (conj(a)*b).imag();\n}\n\n//line,line\nP intersection(P a1,P a2,P b1,P b2){\n  P a=a2-a1;\n  P b=b2-b1;\n  return a1+a*cross(b,b1-a1)/cross(b,a);\n}\n\n//a->b keep leftside points\nPolygon cut(P a,P b,const Polygon &p){\n  int n=p.size();\n  vector<double> c(n);\n  for(int i=0;i<n;i++){\n    c[i]=cross(b-a,p[i]-a);\n  }\n  Polygon r;\n  for(int i=0;i<n;i++){\n    if(c[i]>=0){\n      r.push_back(p[i]);\n    }\n    if(c[i]*c[(i+1)%n]<0){\n      r.push_back(intersection(a,b,p[i],p[(i+1)%n]));\n    }\n  }\n  return r;\n}\n\ndouble area(const Polygon &p){\n  double a=0;\n  for(int i=0;i<p.size();i++){\n    a+=cross(p[(i+1)%p.size()],p[i]);\n  }\n  return fabs(a)/2;\n}\n\nint main(){\n  for(int N,M;cin>>N>>M,N;){\n    Polygon p;\n    for(int i=0;i<N;i++){\n      int x,y;\n      cin>>x>>y;\n      p.emplace_back(x,y);\n    }\n    vector<P> c;\n    for(int i=0;i<M;i++){\n      int x,y;\n      cin>>x>>y;\n      c.emplace_back(x,y);\n    }\n    for(int i=0;i<M;i++){\n      Polygon cp=p;\n      for(int j=0;j<M;j++){\n\tif(i==j)continue;\n\tP m=(c[i]+c[j])/2.;\n\tP d=(c[j]-c[i])*P(0,1)+m;\n\tcp=cut(m,d,cp);\n      }\n      cout.precision(9);\n      cout<<fixed<<area(cp)<<endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include <iostream>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <map>\n#include <functional>\n#include <stdio.h>\n#include <array>\n#include <algorithm>\n#include <string>\n#include <string.h>\n#include <assert.h>\n#include <stdio.h>\n#include <queue>\n#include<iomanip>\n#include<bitset>\n#include<stack>\n#include<set>\n#include<limits>\n#include <complex>\n#include<cstdlib>\nusing namespace std;\n\n\n/* 幾何の基本 */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// 点の入力\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// 誤差つき等号判定\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// 内積\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);\n}\n\n// 外積\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n\n// 直線の定義\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num) {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse assert(false);\n\t}\n};\n\n// 円の定義\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // a,b,cが反時計周りの順に並ぶ\n\tif (cross(b, c) < -eps) return -1; // a,b,cが時計周りの順に並ぶ\n\tif (dot(b, c) < 0) return 2;       // c,a,bの順に直線に並ぶ\n\tif (norm(b) < norm(c)) return -2;  // a,b,cの順に直線に並ぶ\n\treturn 0;                          // a,c,bの順に直線に並ぶ\n}\n\n\n/* 交差判定 */\n\n// 直線と直線の交差判定\nbool isis_ll(Line l, Line m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// 直線と線分の交差判定\nbool isis_ls(Line l, Line s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// 線分と線分の交差判定\nbool isis_ss(Line s, Line t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// 点の直線上判定\nbool isis_lp(Line l, Point p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// 点の線分上判定\nbool isis_sp(Line s, Point p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// 垂線の足\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// 直線と直線の交点\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// 直線と点の距離\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n\n// 直線と直線の距離\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// 直線と線分の距離\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// 線分と点の距離\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// 線分と線分の距離\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n/* 円 */\n\n// 円と円の交点\nvector<Point> is_cc(Circle c1, Circle c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n// 円と直線の交点\nvector<Point> is_lc(Circle c, Line l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// 円と線分の距離\nvector<Point> is_sc(Circle c, Line l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// 円と点の接線\nvector<Line> tangent_cp(Circle c, Point p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// 円と円の接線\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\n\n/* 多角形 */\n\ntypedef vector<Point> Polygon;\n\n// 面積\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// 多角形の回転方向\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// 円の内外判定\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_polygon(const Polygon &poly, Point p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n\n// 凸包\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n// 凸カット\nvector<Polygon> convex_cut(const Polygon &ps, const Line l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\treturn vector<Polygon>{Q, R};\n}\n\n\n/* アレンジメント */\nvoid add_point(vector<Point> &ps, Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\n\nstruct Edge { int from, to; Weight weight; };\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, int from, int to, Weight weight) {\n\tg[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, abs(p[from] - p[to]));\n\t\t}\n\t}\n\treturn g;\n}\n\nGraph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n\tint n = p.size(), m = c.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tld angle = vec[j + 1].first - vec[j].first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t\tif (vec.size() >= 2) {\n\t\t\tint from = vec.back().second, to = vec.front().first;\n\t\t\tld angle = vec.front().first - vec.back().first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t}\n\treturn g;\n}\n\n\n/* 双対グラフ */\n\n// 線分集合は既にアレンジメントされていなければならない．\n// 内側の円は時計回りで，外側の円は反時計回りで得られる．\n// 変数 polygon は，vector<int> で表される多角形の集合であり，\n// vector<int> で表される 多角形のi番目は，その頂点の頂点集合pにおける番号である．\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\nGraph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n\tint N = p.size();\n\tpolygon.clear();\n\tREP(i, 1024) REP(j, 1024) seg2p[i][j].clear();\n\tvector<vector<tuple<ld, int, bool>>> tup(N);\n\tREP(i, s.size()) {\n\t\tint a = -1, b = -1;\n\t\tREP(j, N) if (abs(s[i].a - p[j]) < eps) a = j;\n\t\tREP(j, N) if (abs(s[i].b - p[j]) < eps) b = j;\n\t\tassert(a >= 0 && b >= 0);\n\t\ttup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n\t\ttup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n\t}\n\tREP(i, N) sort(ALL(tup[i]));\n\tREP(i, N) {\n\t\tREP(j, tup[i].size()) {\n\t\t\tld angle; int pos = j, from = i, to; bool flag;\n\t\t\ttie(angle, to, flag) = tup[i][j];\n\t\t\tif (flag) continue;\n\t\t\tvector<int> ps;\n\t\t\twhile (!flag) {\n\t\t\t\tps.push_back(from);\n\t\t\t\tget<2>(tup[from][pos]) = true;\n\t\t\t\tseg2p[from][to].push_back(polygon.size());\n\t\t\t\tseg2p[to][from].push_back(polygon.size());\n\t\t\t\tangle += pi + eps;\n\t\t\t\tif (angle > pi) angle -= 2 * pi;\n\t\t\t\tauto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n\t\t\t\tif (it == tup[to].end()) it = tup[to].begin();\n\t\t\t\tfrom = to; tie(angle, to, flag) = *it;\n\t\t\t\tpos = it - tup[from].begin();\n\t\t\t}\n\t\t\tpolygon.push_back(ps);\n\t\t}\n\t}\n\tGraph g(polygon.size());\n\tREP(i, N) REP(j, i) {\n\t\tif (seg2p[i][j].size() == 2) {\n\t\t\tint from = seg2p[i][j][0], to = seg2p[i][j][1];\n\t\t\tg[from].push_back(Edge{ from, to });\n\t\t\tg[to].push_back(Edge{ to, from });\n\t\t}\n\t}\n\treturn g;\n}\n\n\n/* ビジュアライザ */\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(int r, int g, int b) {\n\tfprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\nint cordx(Point p) { return 400 + zoom * (p.real() - centerX); }\nint cordy(Point p) { return 400 - zoom * (p.imag() - centerY); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(Point p) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(Line l) {\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(Line l) {\n\tPoint v = l.b - l.a;\n\tLine m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n\tint n = p.size();\n\tREP(i, n) draw_segment(Line(p[i], p[(i + 1) % n]));\n}\n\nvoid draw_circle(Circle c) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\n\nvector<Polygon>polys;\nvector<int>hs;\nvector<long double>diss;\n\n\nbool check(const long double rad) {\n\tfor (int i = 0; i < hs.size(); ++i) {\n\t\tif (hs[i] > rad) {\n\t\t\tif (diss[i] < rad)return false;\n\t\t}\n\t\telse {\n\t\t\tlong double needdis = sqrt(rad*rad - (rad - hs[i])*(rad - hs[i]));\n\t\t\tif (diss[i] < needdis)return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nint main() {\n\tint N, M; cin >> N >> M;\n\tPolygon island;\n\tfor (int i = 0; i < N; ++i) {\n\t\tint x, y; cin >> x >> y;\n\t\tPoint p(x, y);\n\t\tisland.emplace_back(p);\n\t}\n\tvector<Point>castles;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint x, y; cin >> x >> y;\n\t\tcastles.emplace_back(x,y);\n\t}\n\n\tfor (int mylord = 0; mylord < M; ++mylord) {\n\t\tPolygon myarea(island);\n\t\tfor (int oplord = 0; oplord < M; ++oplord) {\n\t\t\tif (mylord == oplord)continue;\n\t\t\telse {\n\t\t\t\tLine tie(castles[mylord], castles[oplord]);\n\t\t\t\tPoint midp((castles[mylord] + castles[oplord]) / 2.0l);\n\t\t\t\tcomplex<long double>nc((castles[mylord] - castles[oplord])*complex<long double>(0, 1));\n\t\t\t\tPoint verp(midp + nc);\n\t\t\t\tLine perpen(midp, verp);\n\t\t\t\tvector<Polygon> twoislands(convex_cut(myarea, perpen));\n\t\t\t\tif (is_in_polygon(twoislands[0], castles[mylord]) >= 1) {\n\t\t\t\t\tmyarea = twoislands[0];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmyarea = twoislands[1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<setprecision(22)<<area(myarea) << endl;\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<cmath>\n#include<vector>\n#include<cstdlib>\n#include<cassert>\n#include<map>\n#include<iomanip>\n#define _A_ true\n#define EPS 1e-10\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\nusing namespace std;\nclass Point{\npublic:\n  double x,y;\n  Point(double x =0,double y=0):x(x),y(y){}\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(x*a,y*a);}\n  Point operator / (double a){return Point(x/a,y/a);} //もし悪を使うなら要確認\n \n  double norm() {return x*x+y*y;}\n  double abs() {return sqrt(norm());}\n \n  bool operator < (const Point &p) const{\n    return x != p.x ? x < p.x : y < p.y; \n  }\n \n  bool operator == (const Point &p) const{\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\ntypedef Point Point;\nstruct Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p = Point(),Point pp = Point()):p1(p),p2(pp){}\n};\n \ntypedef vector<Point> Polygon;\ntypedef Segment Line;\n \ndouble norm(Point p){\n  return p.x*p.x+p.y*p.y;\n}\n \ndouble abs(Point p){\n  return sqrt(norm(p));\n}\n \nPoint polar(double a,double rad){\n  return Point(a*cos(rad),a*sin(rad));\n}\n \ndouble args(Point p){\n  return atan2(p.y,p.x);\n}\n \ndouble dot(Point a,Point b){\n  return a.x*b.x+a.y*b.y;\n}\n \ndouble cross(Point a,Point b){\n  return a.x*b.y-b.x*a.y;\n}\n \nPoint project(Segment s,Point p){\n  Point base = s.p2 - s.p1;\n  double t = dot(p-s.p1,base)/base.norm();\n  return s.p1+base*t;\n}\n \nPoint reflect (Segment s, Point p){\n  return p + (project(s,p)-p)*2.0;\n}\n \nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CLOCKWISE;\n  if(dot(a,b) < -EPS) return ONLINE_BACK;\n  if(a.norm() < b.norm() ) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n \nbool isIntersect(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <= 0 && ccw(p3,p4,p1) * ccw(p3,p4,p2) <= 0 );\n}\n \nbool isIntersect(Segment s1,Segment s2){\n  return isIntersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nPoint getCrossPointSegments(Segment s1,Segment s2){\n  //assert(isIntersect(s1,s2));\n  Point base = s2.p2 - s2.p1;\n  double d1 = abs(cross(base,s1.p1-s2.p1));\n  double d2 = abs(cross(base,s1.p2-s2.p1));\n  double t = d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n\n\nPoint getCrossPointLines( Line s1, Line s2){\n\n    Point a = s1.p2 - s1.p1;\n    //Point base = Point(s2.p2.x - s2.p1.x,s2.p2.y - s2.p1.y);\n    Point base = s2.p2 -s2.p1;\n    return s1.p1 + a * (cross(base, s2.p1 - s1.p1)/cross(base, a));\n}\n\nPolygon cutPolygon( Polygon P, Line l ){\n    Polygon u;\n    \n    for ( int i = 0; i < P.size(); i++ ){\n        Point a = P[i], b = P[(i+1)%P.size()];\n\t\n\tif ( ccw(l.p1, l.p2, a) != CLOCKWISE ) u.push_back(a);\n\tif ( ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) == -1 ){\n\t  u.push_back(getCrossPointLines(Segment(a, b), l));\n        }\n    }   \n    return u;\n}\n \n \nLine CreateLine(Point p,Point pp){\n  Point mid = (p+pp)/2;\n  Point sl = pp-p;//原点に5\n  double rad = args(sl);\n  Point ap = polar(abs(sl),rad+M_PI/2)+mid;\n  //ap.x = abs(sl)*cos(rad+M_PI/2)+mid.x;\n  //ap.y = abs(sl)*sin(rad+M_PI/2)+mid.y;\n  return Line(mid,ap);\n} \n \ndouble AreaCalc(Polygon p){\n  double area = 0;\n  for(int i=0;i<p.size();i++)\n    area+=cross(p[i],p[(i+1)%p.size()]);\n  return fabs(area)/2.0;\n} \n \nint main(){\n\n  int N,M;\n  while(cin >> N >> M,N|M){\n  \n  vector<Point> l(N);\n  vector<Point> C(M);\n  for(int i=0;i<N;i++)\n    {\n      cin >> l[i].x >> l[i].y;\n      l[i].x += 200,l[i].y += 200;\n    }\n  for(int i=0;i<M;i++)\n    {\n      cin >> C[i].x >> C[i].y;\n      C[i].x += 200,C[i].y += 200;\n    }\n  for(int i=0;i<M;i++)\n    {\n      Polygon poly; \n      for(int j=0;j<N;j++)\n\tpoly.push_back(l[j]);\n\n      for(int j=0;j<M;j++)\n\t{\n\t  if(j == i)\n\t    continue;\n\t  poly = cutPolygon(poly,CreateLine(C[i],C[j]));\n\t}\n      \n      cout << setiosflags(ios::fixed) << setprecision(4) << AreaCalc(poly) << endl;\n\n    }  \n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define inf 1000000000\n#define eps (1e-11)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1,Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nPoint median_Point(Point a,Point b){\n  Vector v=a-b;\n  return b+(v/2);\n}\n\nstatic const int COUNTER_CLOCKWISE=1;\nstatic const int CLOCKWISE=-1;\nstatic const int ONLINE_BACK=2;\nstatic const int ONLINE_FRONT=-2;\nstatic const int ON_SEGMENT=0;\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps)return COUNTER_CLOCKWISE;\n  if(cross(a,b)<-eps)return CLOCKWISE;\n  if(dot(a,b)<-eps)return ONLINE_BACK;\n  if(a.norm()<b.norm())return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nPoint PointRotation(Point base,Point a,double r){\n  Point b=a-base;\n  a.x=b.x*cos((r/180)*M_PI)-b.y*sin((r/180)*M_PI);\n  a.y=b.x*sin((r/180)*M_PI)+b.y*cos((r/180)*M_PI);\n  a=a+base;\n  return a;\n}\n\nLine getPerpendicularBisector(Segment S){\n  Point p1=median_Point(S.p1,S.p2);\n  Point p2=PointRotation(p1,S.p1,90);\n  return Line(p1,p2);\n}\n\nPoint getCrossPointLL(Line a,Line b){\n  double A=cross(a.p2-a.p1,b.p2-b.p1);\n  double B=cross(a.p2-a.p1,a.p2-b.p1);\n  if(abs(A)<eps && abs(B)<eps)return b.p1;\n  return b.p1+(b.p2-b.p1)*(B/A);\n}\n \ndouble getPolygonArea(Polygon p){\n  double area=0.0;\n  int n=p.size();\n  for(int i=0;i<n;i++)area+=cross(p[i%n],p[(i+1)%n]);\n  return area/2;\n}\n\n//  Polygon???Line??§????????????????????????????????????\nPolygon convex_cut(Polygon p,Line l){\n  Polygon ans;\n  for(int i=0;i<p.size();i++){\n    Point A=p[i],B=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,A)!=-1)ans.push_back(A);\n    if(ccw(l.p1,l.p2,A)*ccw(l.p1,l.p2,B)<0)\n      ans.push_back(getCrossPointLL(l,Segment(A,B)));\n  }\n  return ans;\n}\n\nint main()\n{\n  int n,m;\n  Polygon P;\n  vector<Point> vp;\n\n  while(1){\n    cin>>n>>m;\n    if(n+m==0)break;\n    P.clear();vp.clear();\n    P.resize(n);vp.resize(m);\n    for(int i=0;i<n;i++)cin>>P[i].x>>P[i].y;\n    for(int i=0;i<m;i++)cin>>vp[i].x>>vp[i].y;\n\n    for(int i=0;i<m;i++){\n      Line L1=getPerpendicularBisector(Segment(vp[i],vp[(i+1)%m]));\n      swap(L1.p1,L1.p2);\n      Polygon v=convex_cut(P,L1);\n      Line L2=getPerpendicularBisector(Segment(vp[i],vp[(i+m-1)%m]));\n      swap(L2.p1,L2.p2);\n      v=convex_cut(v,L2);\n      printf(\"%.10f\\n\",getPolygonArea(v));\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <memory>\n#include <cstring>\n#include <cassert>\n#include <numeric>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <cctype>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\nusing namespace std;\n\n#define REP2(i, m, n) for (int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(S) (S).begin(), (S).end()\ntypedef long long ll;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line_t;\ntypedef pair<xy_t, double> circle_t;\ntypedef vector<xy_t> poly_t;\n\nnamespace std {\n  bool operator<(const xy_t &a, const xy_t &b){\n    return a.real() == b.real() ? a.imag() < b.imag() : a.real() < b.real();\n  }\n}\n\nconst double EPS = 1e-9;\n\ninline bool equal(double a, double b){\n  return abs(a - b) < EPS;\n}\n\nistream &operator>>(istream &is, xy_t &p)   {\n  double x, y;\n  is >> x >> y;\n  p = xy_t(x, y);\n  return is;\n}\n\nistream &operator>>(istream &is, line_t &l) {\n  return is >> l.first >> l.second;\n}\n\ninline double cross(const xy_t &a, const xy_t &b){\n  return imag(conj(a) * b);\n}\n\ninline double dot(const xy_t &a, const xy_t &b){\n  return real(conj(a) * b);\n}\n\ninline xy_t rotate(const xy_t &a, double theta){\n  return a * polar(1.0, theta);\n}\n\ninline xy_t direction(const line_t &line){\n  return line.second - line.first;\n}\n\nint ccw(const xy_t &a, xy_t b, xy_t c){\n  b -= a;\n  c -= a;\n  if (cross(b, c) > +EPS) return 1;\n  if (cross(b, c) < -EPS) return -1;\n  if (dot(b, c)   < -EPS) return 2;\n  if (norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nint ccw(const line_t &l, const xy_t &a){\n  return ccw(l.first, l.second, a);\n}\n\nline_t bisector(const xy_t &a, const xy_t &b){\n  xy_t v = rotate(b - a, M_PI / 2);\n  xy_t m = (a + b) * 0.5;\n  return line_t (m, m + v);\n};\n\nxy_t crosspoint(const line_t &l, const line_t &m){\n  xy_t l_vec = direction(l);\n  xy_t m_vec = direction(m);\n  double A = cross(l_vec, m_vec);\n  assert(!equal(A, 0));\n  return m.first + cross(l_vec, l.second-m.first) / A * m_vec;\n}\n\ninline size_t next_index(const poly_t &poly, size_t curr){\n  return (curr + 1) % poly.size();\n}\n\ninline size_t prev_index(const poly_t &poly, size_t curr){\n  return (curr + poly.size() - 1)  % poly.size();\n}\n\npoly_t convex_cut(const poly_t &poly, const line_t &line){\n  poly_t new_poly;\n  \n  for (size_t i = 0; i < poly.size(); i++){\n    xy_t a = poly[i];\n    xy_t b = poly[next_index(poly, i)];\n\n    if (ccw(line, a) != -1) new_poly.push_back(a);\n    \n    if (ccw(line, a) * ccw(line, b) < 0){\n      new_poly.push_back(crosspoint(line_t (a, b), line));\n    }\n  }\n  return new_poly;\n}\n\ndouble signed_area(const poly_t &poly){\n  double res = 0;\n  for (size_t i = 0; i < poly.size(); i++){\n    res += cross(poly[i], poly[next_index(poly, i)]);\n  }\n  return res * 0.5;\n}\n\ndouble area(const poly_t &poly){\n  return abs(signed_area(poly));\n}\n\n\nint main(){\n  ios::sync_with_stdio(false);\n  int N, M;\n  while (cin >> N >> M && N + M){\n    poly_t poly(N);\n    REP(i, N){\n      cin >> poly[i];\n    }\n    \n    vector<xy_t> L(M);\n    REP(i, M){\n      cin >> L[i];\n    }\n    \n\n    REP(i, M){\n      poly_t pi = poly;\n      \n      REP(j, M) if (i != j){\n        pi = convex_cut(pi, bisector(L[i], L[j]));\n      }\n      \n      cout << area(pi) << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include <iostream>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <map>\n#include <functional>\n#include <stdio.h>\n#include <array>\n#include <algorithm>\n#include <string>\n#include <string.h>\n#include <assert.h>\n#include <stdio.h>\n#include <queue>\n#include<iomanip>\n#include<bitset>\n#include<stack>\n#include<set>\n#include<limits>\n#include <complex>\n#include<cstdlib>\nusing namespace std;\n\n\n/* 幾何の基本 */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// 点の入力\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// 誤差つき等号判定\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// 内積\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);\n}\n\n// 外積\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n\n// 直線の定義\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num) {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse assert(false);\n\t}\n};\n\n// 円の定義\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // a,b,cが反時計周りの順に並ぶ\n\tif (cross(b, c) < -eps) return -1; // a,b,cが時計周りの順に並ぶ\n\tif (dot(b, c) < 0) return 2;       // c,a,bの順に直線に並ぶ\n\tif (norm(b) < norm(c)) return -2;  // a,b,cの順に直線に並ぶ\n\treturn 0;                          // a,c,bの順に直線に並ぶ\n}\n\n\n/* 交差判定 */\n\n// 直線と直線の交差判定\nbool isis_ll(Line l, Line m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// 直線と線分の交差判定\nbool isis_ls(Line l, Line s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// 線分と線分の交差判定\nbool isis_ss(Line s, Line t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// 点の直線上判定\nbool isis_lp(Line l, Point p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// 点の線分上判定\nbool isis_sp(Line s, Point p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// 垂線の足\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// 直線と直線の交点\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// 直線と点の距離\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n\n// 直線と直線の距離\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// 直線と線分の距離\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// 線分と点の距離\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// 線分と線分の距離\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n/* 円 */\n\n// 円と円の交点\nvector<Point> is_cc(Circle c1, Circle c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n// 円と直線の交点\nvector<Point> is_lc(Circle c, Line l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// 円と線分の距離\nvector<Point> is_sc(Circle c, Line l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// 円と点の接線\nvector<Line> tangent_cp(Circle c, Point p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// 円と円の接線\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\n\n/* 多角形 */\n\ntypedef vector<Point> Polygon;\n\n// 面積\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// 多角形の回転方向\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// 円の内外判定\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_polygon(const Polygon &poly, Point p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n\n// 凸包\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n// 凸カット\nvector<Polygon> convex_cut(const Polygon &ps, const Line l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tvector<Polygon>polys;\n\tif (!Q.empty()) {\n\t\tpolys.push_back(Q);\n\t}\n\tif (!R.empty()) {\n\t\tpolys.push_back(R);\n\t}\n\treturn polys;\n}\n\n\n/* アレンジメント */\nvoid add_point(vector<Point> &ps, Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\n\nstruct Edge { int from, to; Weight weight; };\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, int from, int to, Weight weight) {\n\tg[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, abs(p[from] - p[to]));\n\t\t}\n\t}\n\treturn g;\n}\n\nGraph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n\tint n = p.size(), m = c.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tld angle = vec[j + 1].first - vec[j].first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t\tif (vec.size() >= 2) {\n\t\t\tint from = vec.back().second, to = vec.front().first;\n\t\t\tld angle = vec.front().first - vec.back().first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t}\n\treturn g;\n}\n\n\n/* 双対グラフ */\n\n// 線分集合は既にアレンジメントされていなければならない．\n// 内側の円は時計回りで，外側の円は反時計回りで得られる．\n// 変数 polygon は，vector<int> で表される多角形の集合であり，\n// vector<int> で表される 多角形のi番目は，その頂点の頂点集合pにおける番号である．\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\nGraph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n\tint N = p.size();\n\tpolygon.clear();\n\tREP(i, 1024) REP(j, 1024) seg2p[i][j].clear();\n\tvector<vector<tuple<ld, int, bool>>> tup(N);\n\tREP(i, s.size()) {\n\t\tint a = -1, b = -1;\n\t\tREP(j, N) if (abs(s[i].a - p[j]) < eps) a = j;\n\t\tREP(j, N) if (abs(s[i].b - p[j]) < eps) b = j;\n\t\tassert(a >= 0 && b >= 0);\n\t\ttup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n\t\ttup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n\t}\n\tREP(i, N) sort(ALL(tup[i]));\n\tREP(i, N) {\n\t\tREP(j, tup[i].size()) {\n\t\t\tld angle; int pos = j, from = i, to; bool flag;\n\t\t\ttie(angle, to, flag) = tup[i][j];\n\t\t\tif (flag) continue;\n\t\t\tvector<int> ps;\n\t\t\twhile (!flag) {\n\t\t\t\tps.push_back(from);\n\t\t\t\tget<2>(tup[from][pos]) = true;\n\t\t\t\tseg2p[from][to].push_back(polygon.size());\n\t\t\t\tseg2p[to][from].push_back(polygon.size());\n\t\t\t\tangle += pi + eps;\n\t\t\t\tif (angle > pi) angle -= 2 * pi;\n\t\t\t\tauto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n\t\t\t\tif (it == tup[to].end()) it = tup[to].begin();\n\t\t\t\tfrom = to; tie(angle, to, flag) = *it;\n\t\t\t\tpos = it - tup[from].begin();\n\t\t\t}\n\t\t\tpolygon.push_back(ps);\n\t\t}\n\t}\n\tGraph g(polygon.size());\n\tREP(i, N) REP(j, i) {\n\t\tif (seg2p[i][j].size() == 2) {\n\t\t\tint from = seg2p[i][j][0], to = seg2p[i][j][1];\n\t\t\tg[from].push_back(Edge{ from, to });\n\t\t\tg[to].push_back(Edge{ to, from });\n\t\t}\n\t}\n\treturn g;\n}\n\n\n/* ビジュアライザ */\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(int r, int g, int b) {\n\tfprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\nint cordx(Point p) { return 400 + zoom * (p.real() - centerX); }\nint cordy(Point p) { return 400 - zoom * (p.imag() - centerY); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(Point p) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(Line l) {\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(Line l) {\n\tPoint v = l.b - l.a;\n\tLine m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n\tint n = p.size();\n\tREP(i, n) draw_segment(Line(p[i], p[(i + 1) % n]));\n}\n\nvoid draw_circle(Circle c) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\n\nvector<Polygon>polys;\nvector<int>hs;\nvector<long double>diss;\n\n\nbool check(const long double rad) {\n\tfor (int i = 0; i < hs.size(); ++i) {\n\t\tif (hs[i] > rad) {\n\t\t\tif (diss[i] < rad)return false;\n\t\t}\n\t\telse {\n\t\t\tlong double needdis = sqrt(rad*rad - (rad - hs[i])*(rad - hs[i]));\n\t\t\tif (diss[i] < needdis)return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nint main() {\n\twhile (1) {\n\n\t\t\n\t\tint N, M; cin >> N >> M;\n\t\tif (!N)break;\n\t\tPolygon island;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tPoint p(x, y);\n\t\t\tisland.emplace_back(p);\n\t\t}\n\t\tvector<Point>castles;\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint x, y; cin >> x >> y;\n\t\t\tcastles.emplace_back(x, y);\n\t\t}\n\n\t\tfor (int mylord = 0; mylord < M; ++mylord) {\n\t\t\tPolygon myarea(island);\n\t\t\tfor (int oplord = 0; oplord < M; ++oplord) {\n\t\t\t\tif (mylord == oplord)continue;\n\t\t\t\telse {\n\t\t\t\t\tLine tie(castles[mylord], castles[oplord]);\n\t\t\t\t\tPoint midp((castles[mylord] + castles[oplord]) / 2.0l);\n\t\t\t\t\tcomplex<long double>nc((castles[mylord] - castles[oplord])*complex<long double>(0, 1));\n\t\t\t\t\tPoint verp(midp + nc);\n\t\t\t\t\tLine perpen(midp, verp);\n\t\t\t\t\tvector<Polygon> twoislands(convex_cut(myarea, perpen));\n\t\t\t\t\tif (is_in_polygon(twoislands[0], castles[mylord]) >= 1) {\n\t\t\t\t\t\tmyarea = twoislands[0];\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tmyarea = twoislands[1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << setprecision(22) << abs(area(myarea)) << endl;\n\t\t}\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "/*\nAlgorithm to determine the Voronoi diagrams of a set of points within a convex polygon that bounds the plane.\n\nTime complexity: O((N + M)^2)\nSpace complexity: O(N + M)\n*/\n\n#include <cmath>\n\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n\n#define x first\n#define y second\n\nusing namespace std;\n\ntypedef pair<double, double> Point;\n\nconst double EPS = 1e-9;\nconst double PI = acos(-1.0);\n\nclass Line {\n  public:\n    double a, b, c;\n\n    Line(const double _a = 0.0, const double _b = 0.0, const double _c = 0.0):\n      a(_a),\n      b(_b),\n      c(_c) {}\n\n    Line(const Point &p1, const Point &p2):\n      a(p1.y - p2.y),\n      b(p2.x - p1.x),\n      c(p1.x * p2.y - p1.y * p2.x) {}\n};\n\nvector<Point> Plane, Points;\nvector<double> Areas;\n\ninline double Det(const Point &a, const Point &b, const Point &c) {\n    return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\n}\n\ninline double Alpha(const Point &a, const Point &b, const Point &c) {\n    Point u = Point(a.x - b.x, a.y - b.y), v = Point(c.x - b.x, c.y - b.y);\n    double alpha = acos((u.x * v.x + u.y * v.y) / sqrt((u.x * u.x + u.y * u.y) * (v.x * v.x + v.y * v.y)));\n    if (Det(a, b, c) < -EPS)\n        alpha += 2 * PI;\n    return alpha;\n}\n\ninline Point Dualize(const Line &l) {\n    if (abs(l.c) < EPS)\n        return Point(0.0, 0.0);\n    return Point(l.a / l.c, l.b / l.c);\n}\n\ninline Line Dualize(const Point &p) {\n    return Line(p.x, p.y, 0.0);\n}\n\ninline Point Translate(const Point &p, const Point &shift) {\n    return Point(p.x + shift.x, p.y + shift.y);\n}\n\ninline Line Translate(const Line &l, const Point &shift) {\n    return Line(l.a, l.b, l.c - l.a * shift.x - l.b * shift.y);\n}\n\nvector<Point> GetConvexHull(vector<Point> points) {\n    int n = int(points.size()), origin = 0;\n    for (int i = 1; i < n; ++i)\n        if (points[i] < points[origin])\n            origin = i;\n    swap(points[0], points[origin]);\n    vector<Point> hull;\n    hull.push_back(points[0]);\n    hull.push_back(points[1]);\n    for (int i = 2; i < n; ++i)\n        if (Det(hull[0], hull[1], points[i]) < -EPS)\n            hull[1] = points[i];\n    do {\n        int next = -1;\n        double alpha = -2 * PI;\n        for (int i = 0; i < n; ++i) {\n            double currentAlpha = Alpha(hull[int(hull.size()) - 2], hull[int(hull.size()) - 1], points[i]);\n            if (currentAlpha > alpha) {\n                next = i;\n                alpha = currentAlpha;\n            }\n        }\n        hull.push_back(points[next]);\n    } while (hull.back() != hull.front());\n    hull.pop_back();\n    return hull;\n}\n\nvector< vector<Point> > GetVoronoiDiagrams(const vector<Point> &plane, const vector<Point> &points) {\n    vector< vector<Point> > voronoiDiagrams = vector< vector<Point> >(int(points.size()), vector<Point>());\n    for (int i = 0; i < int(points.size()); ++i) {\n        Point shiftTo = Point(-points[i].x, -points[i].y), shiftFrom = points[i];\n        vector<Point> dualizedLines;\n        for (int j = 0; j < int(plane.size()); ++j)\n            dualizedLines.push_back(Dualize(Translate(Line(plane[j], plane[(j + 1) % int(plane.size())]), shiftTo)));\n        for (int j = 0; j < int(points.size()); ++j) {\n            if (i != j) {\n                Point a = points[i], b = points[j];\n                dualizedLines.push_back(Dualize(Translate(Line(2 * (b.x - a.x), 2 * (b.y - a.y), a.x * a.x + a.y * a.y - b.x * b.x - b.y * b.y), shiftTo)));\n            }\n        }\n        vector<Point> hull = GetConvexHull(dualizedLines);\n        for (int j = 0; j < int(hull.size()); ++j)\n            voronoiDiagrams[i].push_back(Translate(Dualize(Line(hull[j], hull[(j + 1) % int(hull.size())])), shiftFrom));\n    }\n    return voronoiDiagrams;\n}\n\ninline double Area(const vector<Point> &polygon) {\n    double area = 0.0;\n    for (int i = 0; i < int(polygon.size()); ++i)\n        area += polygon[i].x * polygon[(i + 1) % int(polygon.size())].y - polygon[(i + 1) % int(polygon.size())].x * polygon[i].y;\n    area *= 0.5;\n    return abs(area);\n}\n\nvoid Solve() {\n    vector< vector<Point> > voronoiDiagrams = GetVoronoiDiagrams(Plane, Points);\n    Areas = vector<double>(int(Points.size()), 0.0);\n    for (int i = 0; i < int(Points.size()); ++i)\n        Areas[i] = Area(voronoiDiagrams[i]);\n}\n\nbool Read() {\n    int m, n;\n    cin >> m >> n;\n    if (m == 0 && n == 0)\n        return false;\n    Plane = vector<Point>(m);\n    for (int i = 0; i < m; ++i)\n        cin >> Plane[i].x >> Plane[i].y;\n    Points = vector<Point>(n);\n    for (int i = 0; i < n; ++i)\n        cin >> Points[i].x >> Points[i].y;\n    return true;\n}\n\nvoid Print() {\n    for (int i = 0; i < int(Points.size()); ++i)\n        cout << fixed << setprecision(9) << Areas[i] << \"\\n\";\n}\n\nint main() {\n    while (Read()) {\n        Solve();\n        Print();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 10\n\nstruct Point{\n\tPoint(double arg_x,double arg_y){\n\t\tx = arg_x;\n\t\ty = arg_y;\n\t}\n\n\tPoint(){\n\t\tx = y = 0.0;\n\t}\n\n\tPoint operator + (Point p){ return Point(x+p.x,y+p.y); }\n\tPoint operator - (Point p){ return Point(x-p.x,y-p.y);}\n\tPoint operator * (double a){ return Point(a*x,a*y); }\n\tPoint operator / (double a){ return Point(x/a,y/a); }\n\n\tdouble abs(){ return sqrt(norm()); }\n\tdouble norm(){ return x*x + y*y; }\n\n\tbool operator<(const Point &p) const{\n\t\treturn x != p.x? x < p.x: y < p.y;\n\t}\n\n\tbool operator == (const Point &p) const{\n\t\treturn fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n\t}\n\n\tdouble x,y;\n};\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nint N,M;\n\ndouble cross(Vector a,Vector b){\n    return a.x*b.y-a.y*b.x;\n}\n\ndouble dot(Vector a,Vector b){\n    return a.x*b.x + a.y*b.y;\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -1;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0,Point p1,Point p2){\n\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\n\tif(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n\tif(cross(a,b) < -EPS)return CLOCKWISE;\n\tif(dot(a,b) < -EPS)return ONLINE_BACK;\n\tif(a.norm() < b.norm())return ONLINE_FRONT;\n\n\treturn ON_SEGMENT;\n}\n\nPoint calc_Cross_Point(double x1,double x2,double x3,double x4,double y1,double y2,double y3,double y4){\n\tPoint ret;\n\tret.x = ((x2-x1)*(y3*(x4-x3)+x3*(y3-y4))-(x4-x3)*(y1*(x2-x1)+x1*(y1-y2)))/((y2-y1)*(x4-x3)-(y4-y3)*(x2-x1));\n\tif(x1 != x2){\n\t\tret.y = ((y2-y1)*ret.x+y1*(x2-x1)+x1*(y1-y2))/(x2-x1);\n\t}else{\n\t\tret.y = ((y4-y3)*ret.x+y3*(x4-x3)+x3*(y3-y4))/(x4-x3);\n\t}\n\treturn ret;\n}\n\nPoint calc_Cross_Point(Point a,Point b,Point c,Point d){\n\treturn calc_Cross_Point(a.x,b.x,c.x,d.x,a.y,b.y,c.y,d.y);\n}\n\nPolygon ConvexCut(Polygon g,Point a,Point b){\n\n\tPolygon ret;\n\tint N = g.size();\n\n\tfor(int i = 0; i < g.size(); i++){\n\t\tPoint A = g[i], B = g[(i+1)%N];\n\t\tif(ccw(a,b,A) != -1)ret.push_back(A);\n\t\tif(ccw(a,b,A)*ccw(a,b,B) == -1)ret.push_back(calc_Cross_Point(a,b,A,B));\n\t}\n\n\treturn ret;\n}\n\ndouble calc_S(Polygon g){\n\n\tint N = g.size();\n\tdouble ret = 0;\n\n\tfor(int i = 0; i < g.size(); i++){\n\t\tret += cross(g[i],g[(i+1)%N]);\n\t}\n\treturn ret/2.0;\n}\n\nvoid func(){\n\n\tPoint C[NUM];\n\tPolygon L;\n\n\tdouble tmp_x,tmp_y;\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%lf %lf\",&tmp_x,&tmp_y);\n\t\tL.push_back(Point(tmp_x,tmp_y));\n\t}\n\n\tfor(int i = 0; i < M; i++){\n\t\tscanf(\"%lf %lf\",&C[i].x,&C[i].y);\n\t}\n\n\tfor(int i = 0; i < M; i++){\n\t\tPolygon p = L;\n\t\tfor(int k = 0; k < M; k++){\n\t\t\tif(k == i)continue;\n\n\t\t\tPoint from = (C[i]+C[k])/2;\n\t\t\tVector v1 = C[k]-C[i];\n\t\t\tVector v2 = Vector(-v1.y,v1.x);\n\t\t\tPoint to = from+v2;\n\t\t\tp = ConvexCut(p,from,to);\n\t\t}\n\t\tprintf(\"%.10lf\\n\",calc_S(p));\n\t}\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&N,&M);\n\t\tif(N == 0 && M == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define all(a) (a).begin(),(a).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define sz size()\n\nusing namespace std;\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\ntypedef vector<P> Poly;\n\nconst D EPS = 1e-8;\n\ninline pair<P,P> normal(P p){return make_pair(p*P(0,1),p*P(0,-1));}\ninline D dot(P x, P y){return real(conj(x)*y);}\ninline D cross(P x, P y){return imag(conj(x)*y);}\n\nint ccw(P a,P b,P c){\n  b -= a;c -= a;\n  if (cross(b,c)>EPS) return 1;   //counter clockwise\n  if (cross(b,c)<-EPS) return -1; //clockwise\n  if (dot(b, c)<-EPS) return 2;   //c--a--b on line\n  if (abs(b)+EPS<abs(c)) return -2;   //a--b--c on line\n  return 0;                       //on segment\n}\n\ninline P line_cp(L a,L b){\n  return a.fs+(a.sc-a.fs)*cross(b.sc-b.fs,b.fs-a.fs)/cross(b.sc-b.fs,a.sc-a.fs);\n}\n\ninline Poly convex_cut(Poly p,L l){\n  Poly res;\n  rep(i,p.sz){\n    int nxt = (i+1)%p.sz;\n    if(ccw(l.fs,l.sc,p[i]) != -1)res.pb(p[i]);\n    if(ccw(l.fs,l.sc,p[i]) * ccw(l.fs,l.sc,p[nxt]) < 0){\n      res.pb( line_cp(l, L(p[i],p[nxt]) ) );\n    }\n  }\n  return res;\n}\n\ninline vector<Poly> voronoi_partition(Poly p, vector<P> vp){\n  vector<Poly> res(vp.sz);\n  rep(i,vp.sz){\n    res[i] = p;\n    rep(j,vp.sz){\n      if(i!=j){\n\tP mid = (vp[i] + vp[j])/2.0;\n\tL b = L(mid, mid + normal(vp[j]-vp[i]).fs);\n\tres[i] = convex_cut(res[i],b);\n      }\n    }\n  }\n  return res;\n}\n\ninline D area(Poly p){\n  if(p.sz<3)return 0;\n  D res = cross(p[p.sz-1],p[0]);\n  rep(i,p.sz-1)res += cross(p[i],p[i+1]);\n  return res/2;\n}\n\nint main(){\n  int n,m;\n  while(cin >> n >> m){\n    if(n==0 && m==0)break;\n\n    Poly island(n);\n    rep(i,n){\n      int x,y;\n      cin >> x >> y;\n      island[i] = P(x,y);\n    }\n\n    vector<P> castle(m);\n    rep(i,m){\n      int x,y;\n      cin >> x >> y;\n      castle[i] = P(x,y);\n    }\n\n    vector<Poly> ans = voronoi_partition(island,castle);\n    rep(i,ans.sz){\n      cout << fixed << setprecision(9) << area(ans[i]) << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\nconst double eps = 1e-10;\n\n#define RIGHT 1\n#define LEFT -1\n\ntypedef complex<double> P;\ntypedef vector<P> Polygon;\ntypedef pair<P,P> Line;\n\ndouble cross(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\nP intersection_ll(P a1,P a2,P b1,P b2){\n  P a=a2-a1,b=b2-b1;\n  return a1+a*cross(b,b1-a1)/cross(b,a);\n}\n\n\nint ccw(P a,P b){\n  if ( cross(a,b)<0)return RIGHT;\n  else if ( cross(a,b)>0)return LEFT;\n  return 2;\n}\n\nvector<P> Convex_Cut(Polygon in,int n,P a1,P a2,int cutpos){\n  vector<P> ret;\n  rep(i,n){\n    P now = in[i],next=in[(i+1)%n];\n    if( ccw(a1-a2,now-a2)==cutpos)ret.push_back(now);\n    if ( ccw(a1-a2,now-a1)*ccw(a1-a2,next-a2)<0)\n      ret.push_back(intersection_ll(a1,a2,now,next));\n  }\n  return ret;\n}\n\n//cutpos ha mondai izon. which side will remain\nLine make_line(P ori,P b,int cutpos){\n  P tmp=(ori+b);\n  tmp.real()/=2;tmp.imag()/=2;\n  P ret=b-tmp;\n  swap(ret.real(),ret.imag());\n  ret.real()*=-1;\n  if ( ccw(ret,ori-tmp)!= cutpos)return make_pair(tmp,ret+tmp);\n  return make_pair(ret+tmp,tmp);\n}\n\ndouble Polygon_Area(vector<P> a,int n){\n  double sum=0;\n  rep(i,n){\n    sum+=(a[i%n].real()-a[(i+1)%n].real())*(a[i%n].imag()+a[(i+1)%n].imag());\n  }\n  if( sum<0)sum*=-1;\n  return sum/2;\n}\n\n\nvoid solve(int n,int m,Polygon in,vector<P> CutLine){\n  vector<Line> ver;\n  rep(i,CutLine.size())\n    if ( i == m)continue;\n    else ver.push_back(make_line(CutLine[m],CutLine[i],LEFT));\n\n  rep(i,ver.size())\n    in=Convex_Cut(in,in.size(),ver[i].first,ver[i].second,LEFT);\n  \n  printf(\"%.4lf\\n\",Polygon_Area(in,in.size()));\n}\n\nmain(){\n  int n,m;\n  while(cin>>n>>m&&n){\n    Polygon a;\n    vector<P> CutPoint;\n    rep(i,n){\n      P tmp;cin>>tmp.real()>>tmp.imag();a.push_back(tmp);\n    }\n    rep(i,m){\n      P tmp;\n      cin>>tmp.real()>>tmp.imag();\n      CutPoint.push_back(tmp);\n    }\n    \n    rep(i,m)\n      solve(n,i,a,CutPoint);\n    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=a;i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(a>b)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\nusing ld=long double;\nusing cm=complex<ld>;\n#define x real()\n#define y imag()\nconst ld eps=1e-8;\nconst ld PI=acos(ld(-1));\nint sgn(ld a){return a<-eps?-1:(a>eps?1:0);}\nld dot(cm a,cm b){return a.x*b.x+a.y*b.y;}\nld crs(cm a,cm b){return a.x*b.y-a.y*b.x;}\nld crs(cm a,cm b,cm c){return crs(b-a,c-a);}\nint ccw(cm a,cm b){return sgn(crs(a,b));}\nint ccw(cm a,cm b,cm c){return ccw(b-a,c-a);}\nauto cmcmp=[](cm a,cm b){\n\tif(sgn(a.x-b.x))return a.x<b.x;\n\telse return sgn(a.y-b.y)<0;\n};\nbool cmeq(cm a,cm b){\n\treturn sgn(a.x-b.x)==0&&sgn(a.y-b.y)==0;\n};\n//(-pi,0](0,pi]\nint argtype(cm a){\n\tif(sgn(a.y)==0)return a.x<0?1:0;\n\treturn a.y<0?0:1;\n}\nint argcmp(cm a,cm b){\n\tint at=argtype(a),bt=argtype(b);\n\tif(at!=bt)return sgn(at-bt);\n\treturn -ccw(a,b);\n};\n//AOJ1183\nint qeq(ld a,ld b,ld c,ld&d,ld&e){\n\tld f=b*b-4*a*c;\n\tif(sgn(f)<0)return 0;\n\tld g=sqrt(max(f,ld(0)));\n\td=(-b+g)/(2*a);\n\te=(-b-g)/(2*a);\n\treturn sgn(f)+1;\n}\n//(-2)[a,-1](0)[b,1](2)\nint bet(cm a,cm b,cm c){\n\tcm d=b-a;\n\tld e=dot(d,c-a);\n\tif(sgn(e)<=0)return sgn(e)-1;\n\treturn sgn(e-norm(d))+1;\n}\n//AOJ0153\n//0-no,1-edge,2-in\nint cont(cm a,cm b,cm c,cm d){\n\tif(ccw(a,b,c)==-1)\n\t\tswap(b,c);\n\treturn min({ccw(a,b,d),ccw(b,c,d),ccw(c,a,d)})+1;\n}\n//AOJ1183\n//arg between ab\n//assume given lengths are valid\nld arg(ld a,ld b,ld c){\n\treturn acos(min(max((a*a+b*b-c*c)/(2*a*b),ld(-1)),ld(1)));\n}\n//AOJ2233\n//a->b->c と進むときに曲がる角度\n//a-b-cが一直線上にあれば0が帰る\nld turn(cm a,cm b,cm c){\n\treturn arg((c-b)/(b-a));\n}\n\nusing ln=pair<cm,cm>;\ncm dir(ln a){return a.b-a.a;}\ncm eval(ln a,ld b){return a.a+dir(a)*b;}\nint bet(ln a,cm b){return bet(a.a,a.b,b);}\nint ccw(ln a,cm b){return ccw(a.a,a.b,b);}\ncm proj(ln a,cm b){\n\tcm c=dir(a);\n\treturn a.a+c*dot(c,b-a.a)/norm(c);\n}\ncm refl(ln a,cm b){\n\treturn ld(2)*proj(a,b)-b;\n}\n//AOJ0153\nld dsp(ln a,cm b){\n\tcm c=proj(a,b);\n\tif(abs(bet(a.a,a.b,c))<=1)return abs(b-c);\n\treturn min(abs(b-a.a),abs(b-a.b));\n}\n//AOJ1157\n//0-no,1-yes(endpoint),2-yes(innner),3-overelap\nint iss(ln a,ln b){\n\tint c1=ccw(a.a,a.b,b.a),c2=ccw(a.a,a.b,b.b);\n\tint d1=ccw(b.a,b.b,a.a),d2=ccw(b.a,b.b,a.b);\n\tif(c1||c2||d1||d2)return 1-max(c1*c2,d1*d2);\n\tint f=bet(a.a,a.b,b.a),g=bet(a.a,a.b,b.b);\n\tif(max(f,g)==-2||min(f,g)==2)return 0;\n\treturn 3;\n}\n//AOJ1033\ncm cll(ln a,ln b){\n\treturn eval(a,crs(b.a,b.b,a.a)/crs(dir(a),dir(b)));\n}\n//AOJ1157\nld dss(ln a,ln b){\n\tif(iss(a,b))return 0;\n\treturn min({dsp(a,b.a),dsp(a,b.b),dsp(b,a.a),dsp(b,a.b)});\n}\n//反時計回り方向に伸びる垂直二等分線\nln vbis(cm a,cm b){\n\tcm c=(a+b)*ld(0.5),d=b-a;\n\treturn ln(c,cm(c.x-d.y,c.y+d.x));\n}\n\nld area2(const vc<cm>&a){\n\tint n=a.size();\n\tld b=0;\n\trep(i,n)\n\t\tb+=crs(a[i],a[(i+1)%n]);\n\treturn b;\n}\n\n//assume the ansewer is bounded\nvc<cm> halfpint(vc<ln> s){\n\tsort(all(s),[&](ln a,ln b){\n\t\tint c=argcmp(dir(a),dir(b));\n\t\tif(c)return c<0;\n\t\treturn ccw(b,a.a)>0;\n\t});\n\ts.erase(unique(all(s),[&](ln a,ln b){\n\t\treturn argcmp(dir(a),dir(b))==0;\n\t}),s.ed);\n\tint n=s.size();\n\tvi cur;\n\trep(ii,n*2){\n\t\tint i=ii%n,m;\n\t\twhile((m=cur.size())>=2){\n\t\t\tif(ccw(s[i],cll(s[cur[m-2]],s[cur[m-1]]))>0)\n\t\t\t\tbreak;\n\t\t\tcur.pop_back();\n\t\t}\n\t\tcur.pb(i);\n\t}\n\tvi cnt(n);\n\tfor(auto i:cur)cnt[i]++;\n\tvc<ln> t;\n\trep(i,n)if(cnt[i]==2)\n\t\tt.pb(s[i]);\n\tint m=t.size();\n\tvc<cm> res(m);\n\trep(i,m)\n\t\tres[i]=(cll(t[i],t[(i+1)%m]));\n\treturn res;\n}\n\nsigned main(){\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tcout<<fixed<<setprecision(20);\n\t\n\twhile(1){\n\t\tint n,m;cin>>n>>m;\n\t\tif(n==0)break;\n\t\tvc<ln> cv;\n\t\t{\n\t\t\tvc<cm> a;\n\t\t\trep(i,n){\n\t\t\t\tld s,t;\n\t\t\t\tcin>>s>>t;\n\t\t\t\ta.eb(s,t);\n\t\t\t}\n\t\t\trep(i,n)\n\t\t\t\tcv.eb(a[i],a[(i+1)%n]);\n\t\t}\n\t\tvc<cm> pos;\n\t\trep(i,m){\n\t\t\tld s,t;cin>>s>>t;\n\t\t\tpos.eb(s,t);\n\t\t}\n\t\trep(i,m){\n\t\t\tvc<ln> a=cv;\n\t\t\trep(j,m)if(i!=j)\n\t\t\t\ta.pb(vbis(pos[i],pos[j]));\n\t\t\tcout<<area2(halfpint(a))/2<<endl;\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nconst double EPS = 1e-8, PI = acos(-1);\n\ninline bool eq(double a, double b) { return abs(b - a) < EPS; }\n\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define prev(P, i) P[(i+P.size()-1) % P.size()]\nenum\n{\n  OUT, ON, IN\n};\nnamespace Geometory\n{\n  struct Point\n  {\n    double x, y;\n\n    Point() {};\n\n    Point(double x, double y) : x(x), y(y) {};\n\n    Point operator+(const Point &b) const { return Point(x + b.x, y + b.y); }\n\n    Point operator-(const Point &b) const { return Point(x - b.x, y - b.y); }\n\n    Point operator*(const double b) const { return Point(x * b, y * b); }\n\n    Point operator*(const Point &b) const { return Point(x * b.x - y * b.y, x * b.y + y * b.x); }\n\n    Point operator/(const double b) const { return Point(x / b, y / b); }\n\n    bool operator<(const Point &b) const { return x != b.x ? x < b.x : y < b.y; }\n\n    bool operator==(const Point &b) const { return eq(x, b.x) && eq(y, b.y); }\n\n    double norm() { return x * x + y * y; }\n\n    double arg() { return atan2(x, y); }\n\n    double abs() { return sqrt(norm()); }\n\n    Point rotate(double theta) { return Point(cos(theta) * x - sin(theta) * y, sin(theta) * x + cos(theta) * y); }\n\n    Point rotate90() { return Point(-y, x); }\n\n    friend ostream &operator<<(ostream &os, Point &p) { return os << \"(\" << p.x << \",\" << p.y << \")\"; }\n\n    friend istream &operator>>(istream &is, Point &a) { return is >> a.x >> a.y; }\n  };\n\n  struct Line\n  {\n    Point a, b;\n\n    Line() {};\n\n    Line(Point a, Point b) : a(a), b(b) {};\n\n    friend ostream &operator<<(ostream &os, Line &p) { return os << \"(\" << p.a.x << \",\" << p.a.y << \") to (\" << p.b.x << \",\" << p.b.y << \")\"; }\n\n    friend istream &operator>>(istream &is, Line &a) { return is >> a.a.x >> a.a.y >> a.b.x >> a.b.y; }\n  };\n\n  struct Segment\n  {\n    Point a, b;\n\n    Segment() {};\n\n    Segment(Point a, Point b) : a(a), b(b) {};\n\n    friend ostream &operator<<(ostream &os, Segment &p) { return os << \"(\" << p.a.x << \",\" << p.a.y << \") to (\" << p.b.x << \",\" << p.b.y << \")\"; }\n\n    friend istream &operator>>(istream &is, Segment &a) { return is >> a.a.x >> a.a.y >> a.b.x >> a.b.y; }\n  };\n\n  struct Circle\n  {\n    Point p;\n    double r;\n\n    Circle() {};\n\n    Circle(Point p, double r) : p(p), r(r) {};\n  };\n\n  typedef vector< Point > Polygon;\n  typedef vector< Segment > Segments;\n  typedef vector< Line > Lines;\n  typedef vector< Circle > Circles;\n  typedef pair< Point, Point > PointPoint;\n\n  double cross(const Point &a, const Point &b)\n  {\n    return a.x * b.y - a.y * b.x;\n  }\n\n  double dot(const Point &a, const Point &b)\n  {\n    return a.x * b.x + a.y * b.y;\n  }\n\n  int ccw(const Point &a, Point b, Point c)\n  {\n    b = b - a, c = c - a;\n    if(cross(b, c) > EPS) return +1;  // a ??? b ??§ ???????¨??????????????????? c\n    if(cross(b, c) < -EPS) return -1; // a ??? b ??§ ????¨??????????????????? c\n    if(dot(b, c) < 0) return +2;  // c -- a -- b??§?????´??????\n    if(b.norm() < c.norm()) return -2; // a -- b -- c??§?????´??????\n    return 0;  // a -- c -- b??§?????´??????\n  }\n\n  Point Projection(const Line &l, const Point &p)\n  {\n    double t = dot(p - l.a, l.a - l.b) / (l.a - l.b).norm();\n    return l.a + (l.a - l.b) * t;\n  }\n\n  Point Projection(const Segment &l, const Point &p)\n  {\n    double t = dot(p - l.a, l.a - l.b) / (l.a - l.b).norm();\n    return l.a + (l.a - l.b) * t;\n  }\n\n  Point Reflection(const Line &l, const Point &p)\n  {\n    return p + (Projection(l, p) - p) * 2.0;\n  }\n\n  double Distance(const Line &l, const Point &p)\n  {\n    return (p - Projection(l, p)).abs();\n  }\n\n  bool Intersect(const Line &l, const Line &m)\n  {\n    return abs(cross(l.b - l.a, m.b - m.a)) > EPS || abs(cross(l.b - l.a, m.b - l.a)) < EPS;\n  }\n\n  bool Intersect(const Line &l, const Segment &s)\n  {\n    return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n  }\n\n  bool Intersect(const Line &l, const Point &p)\n  {\n    return abs(ccw(l.a, l.b, p)) != -1;\n  }\n\n  bool Intersect(const Segment &s, const Segment &t)\n  {\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n  }\n\n  bool Intersect(const Segment &s, const Point &p)\n  {\n    return ccw(s.a, s.b, p) == 0;\n  }\n\n  bool Intersect(const Circle &c, const Line &l)\n  {\n    return Distance(l, c.p) <= c.r + EPS;\n  }\n\n  bool Intersect(const Circle &c, const Point &p)\n  {\n    return abs((p - c.p).abs() - c.r) < EPS;\n  }\n\n  int Intersect(const Circle &c, const Segment &l)\n  {\n    if((Projection(l, c.p) - c.p).norm() - c.r * c.r > EPS) return 0;\n    const double d1 = (c.p - l.a).abs(), d2 = (c.p - l.b).abs();\n    if(d1 < c.r + EPS && d2 < c.r + EPS) return 0;\n    if(d1 < c.r - EPS && d2 > c.r + EPS || d1 > c.r + EPS && d2 < c.r - EPS) return 1;\n    const Point h = Projection(l, c.p);\n    if(dot(l.a - h, l.b - h) < 0) return 2;\n    return 0;\n  }\n\n  bool Intersect(const Circle &a, const Circle &b)\n  {\n    return ((a.p - b.p).norm() - (a.r + b.r) * (a.r + b.r) < EPS) &&\n           ((a.p - b.p).norm() - (a.r - b.r) * (a.r - b.r) > -EPS);\n  }\n\n  double Distance(const Segment &s, const Point &p)\n  {\n    Point r = Projection(s, p);\n    if(Intersect(s, r)) return (r - p).abs();\n    return min((s.a - p).abs(), (s.b - p).abs());\n  }\n\n  double Distance(const Segment &a, const Segment &b)\n  {\n    if(Intersect(a, b)) return 0;\n    return min(min(Distance(a, b.a), Distance(a, b.b)), min(Distance(b, a.a), Distance(b, a.b)));\n  }\n\n  double Distance(const Line &l, const Line &m)\n  {\n    return Intersect(l, m) ? 0 : Distance(l, m.a);\n  }\n\n  double Distance(const Line &l, const Segment &s)\n  {\n    if(Intersect(l, s)) return 0;\n    return min(Distance(l, s.a), Distance(l, s.b));\n  }\n\n  double Distance(const Point &a, const Point &b)\n  {\n    return (a - b).abs();\n  }\n\n  Point Crosspoint(const Line &l, const Line &m)\n  {\n    double A = cross(l.b - l.a, m.b - m.a);\n    double B = cross(l.b - l.a, l.b - m.a);\n    if(abs(A) < EPS && abs(B) < EPS) return m.a; // same line\n    return m.a + (m.b - m.a) * B / A;\n  }\n\n  Point Crosspoint(const Segment &l, const Segment &m)\n  {\n    double A = cross(l.b - l.a, m.b - m.a);\n    double B = cross(l.b - l.a, l.b - m.a);\n    if(abs(A) < EPS && abs(B) < EPS) return m.a; // same line\n    return m.a + (m.b - m.a) * B / A;\n  }\n\n  PointPoint Crosspoint(const Circle &c, const Line l)\n  {\n    Point hp = Projection(l, c.p), h = hp - c.p;\n    const double d2 = h.norm();\n    Point v = (l.b - l.a) * sqrt(c.r * c.r - d2) / (l.b - l.a).abs();\n    return PointPoint(hp - v, hp + v);\n  }\n\n  PointPoint Crosspoint(const Circle &c, const Segment &l)\n  {\n    Line aa = Line(l.a, l.b);\n    if(Intersect(c, l) == 2) return Crosspoint(c, aa);\n    PointPoint ret = Crosspoint(c, aa);\n    if(dot(l.a - ret.first, l.b - ret.first) < 0) ret.second = ret.first;\n    else ret.first = ret.second;\n    return ret;\n  }\n\n  PointPoint Crosspoint(const Circle &c1, const Circle &c2)\n  { //OK\n    double d = (c1.p - c2.p).abs();\n    double s = (c1.r + c2.r + d) / 2;\n    double S = sqrt(s * (s - c1.r) * (s - c2.r) * (s - d));\n    double h = 2 * S / d;\n    Point v = (c2.p - c1.p) / (c2.p - c1.p).abs();\n    double m = sqrt(c1.r * c1.r - h * h);\n    return PointPoint(c1.p + v * m + Point(0, 1) * h * v, c1.p + v * m - Point(0, 1) * h * v);\n  }\n\n  bool parallel(const Line &a, const Line &b)\n  {\n    return abs(cross(a.b - a.a, b.b - b.a)) < EPS;\n  }\n\n  bool orthogonal(const Line &a, const Line &b)\n  {\n    return abs(dot(a.a - a.b, b.a - b.b)) < EPS;\n  }\n\n  int Contains(const Polygon &Q, const Point &p)\n  {\n    bool in = false;\n    for(int i = 0; i < Q.size(); i++) {\n      Point a = curr(Q, i) - p, b = next(Q, i) - p;\n      if(a.y > b.y) swap(a, b);\n      if(a.y <= 0 && 0 < b.y && cross(a, b) < 0) in = !in;\n      if(cross(a, b) == 0 && dot(a, b) <= 0) return ON;\n    }\n    return in ? IN : OUT;\n  }\n\n  bool Contains(const Circle &c, const Point &p)\n  {\n    return (c.p - p).abs() < c.r + EPS;\n  }\n\n  double Area2(const Polygon &p)\n  { //OK\n    double A = 0;\n    for(int i = 0; i < p.size(); ++i) {\n      A += cross(curr(p, i), next(p, i));\n    }\n    return A;\n  }\n\n  bool IsConvex(const Polygon &p)\n  {\n    for(int i = 0; i < p.size(); i++) {\n      if(ccw(prev(p, i), curr(p, i), next(p, i)) == -1) return false;\n    }\n    return true;\n  }\n\n  Polygon Convex_Hull(Polygon &p)\n  {\n    int n = p.size(), k = 0;\n    if(n >= 3) {\n      sort(p.begin(), p.end());\n      vector< Point > ch(2 * n);\n      for(int i = 0; i < n; ch[k++] = p[i++]) {\n        while(k >= 2 && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n      }\n      for(int i = n - 2, t = k + 1; i >= 0; ch[k++] = p[i--]) {\n        while(k >= t && cross(ch[k - 1] - ch[k - 2], p[i] - ch[k - 1]) < 0) --k;\n      }\n      ch.resize(k - 1);\n      return ch;\n    } else {\n      return p;\n    }\n  }\n\n  double Convex_Diameter(Polygon &p)\n  {\n    int n = p.size();\n    int is = 0, js = 0;\n    for(int i = 1; i < n; i++) {\n      if(p[i].y > p[is].y) is = i;\n      if(p[i].y < p[js].y) js = i;\n    }\n    double maxdis = (p[is] - p[js]).norm();\n\n    int maxi, maxj, i, j;\n    i = maxi = is;\n    j = maxj = js;\n    do {\n      if(cross(next(p, i) - curr(p, i), next(p, j) - curr(p, j)) >= 0) {\n        j = (j + 1) % n;\n      } else {\n        i = (i + 1) % n;\n      }\n      if((p[i] - p[j]).norm() > maxdis) {\n        maxdis = (p[i] - p[j]).norm();\n        maxi = i;\n        maxj = j;\n      }\n    } while(i != is || j != js);\n    return maxdis;\n  }\n\n  Line Bisector(Point a, Point b)\n  {\n    Point c = (a + b) * 0.5;\n    Point p = Point(c.x + (a.y - b.y), c.y + (b.x - a.x));\n    return (Line(c, p));\n  }\n\n  Polygon Convex_Cut(Polygon &U, Line l)\n  {\n    Polygon ret;\n    for(int i = 0; i < U.size(); i++) {\n      Point now = curr(U, i), nxt = next(U, i);\n      if(ccw(l.a, l.b, now) != -1) ret.push_back(now);\n      if(ccw(l.a, l.b, now) * ccw(l.a, l.b, nxt) < 0) {\n        ret.push_back(Crosspoint(Line(now, nxt), l));\n      }\n    }\n    return (ret);\n  }\n};\n\n\nint main()\n{\n  int N, M;\n\n  cout << fixed << setprecision(15);\n\n  while(cin >> N >> M, N) {\n    Geometory::Polygon a(N), b(M);\n    for(int i = 0; i < N; i++) cin >> a[i];\n    for(int i = 0; i < M; i++) cin >> b[i];\n\n    for(int i = 0; i < M; i++) {\n      Geometory::Polygon c(a);\n      for(int j = 0; j < M; j++) {\n        if(i != j) c = Geometory::Convex_Cut(c, Geometory::Bisector(b[i], b[j]));\n      }\n      cout << Geometory::Area2(c) * 0.5 << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <cassert>\n#include <iomanip>\n#include <algorithm>\nusing namespace std;\n\n#define EPS 1e-8\ntypedef complex<double> P;\ntypedef vector<P> G;\n\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\n\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nint ccw(P a, P b, P c)\n{\n\tb -= a; c -= a;\n\tif (cross(b, c) > +EPS) return +1;\n\tif (cross(b, c) < -EPS) return -1;\n\tif (dot(b, c)   < -EPS) return +2;\n\tif (norm(b) < norm(c))  return -2;\n\treturn 0;\n}\n\nbool notleft(P a, P b, P c)\n{\n\treturn (ccw(a,b,c)!=+1);\n}\n\nbool isIntoG(const G& g, const P& p)\n{\n\tsize_t sz = g.size();\n\tfor(size_t i=0; i<sz; i++)\n\t{\n\t\tif( notleft(p, g[i], g[(i+1)%sz]) ) return false;\n\t}\n\treturn true;\n}\n\nbool isfar(G& g, P& p)\n{\n\tfor(int i=0; i<g.size(); i++)\n\t\tif(abs(g[i]-p) < EPS) return false;\n\t\t\n\treturn true;\n}\n\n#define CURR(P, i) P[i]\n#define NEXT(P, i) P[(i+1)%P.size()]\n\nbool ConvexCut(G& g, L& l, vector<G>& ret)\n{\n\tint sp,inp=0;\n\tfor(sp=0; sp<g.size(); sp++)\n\t\tif(intersectLS(l, L(g[sp], g[(sp+1)%g.size()]))) break;\n\t\t\n\tif(sp==g.size()) return false;\n\t\n\tret.resize(2);\n\t\t\n\tP xp=crosspoint(l, L(g[sp], g[(sp+1)%g.size()]));\n\tsp++;\n\t\n\tfor(int i=sp; i<sp+g.size(); i++)\n\t{\n\t\tif(isfar(ret[inp], g[i%g.size()])) ret[inp].push_back(g[i%g.size()]);\n\t\tif(intersectLS(l, L(g[i%g.size()], g[(i+1)%g.size()])))\n\t\t{\n\t\t\tP tx=crosspoint(l, L(g[i%g.size()], g[(i+1)%g.size()]));\n\t\t\tif(abs(tx-xp) < EPS) continue;\n\t\t\t\n\t\t\txp=tx;\n\t\t\tfor(int j=0; j<2; j++)\n\t\t\t{\n\t\t\t\tif(isfar(ret[j], xp)) ret[j].push_back(xp);\n\t\t\t}\n\t\t\t\n\t\t\tinp=(inp+1)%2;\n\t\t}\n\t}\n\t\n\treturn true;\n}\n\nL trans(P a, P b)\n{\n\tP med=(a+b);\n\tmed=P(med.real()/2, med.imag()/2);\n\tP hoge=(a-b);\n\thoge*=P(0,1);\n\t\n\treturn L(med+hoge*P(1000,0), med-hoge*P(1000,0));\n}\n\ndouble Area(G& g)\n{\n\tdouble ret=0;\n\tfor(int i=0; i<g.size(); i++)\n\t\tret+=cross(CURR(g,i), NEXT(g,i))/2;\n\t\t\n\treturn ret;\n}\n\nint main()\n{\n\tcout << setiosflags(ios::fixed) << setprecision(7);\n\t\n\tint N,M;\n\twhile(cin >> N >> M, (N||M))\n\t{\n\tcin >> N >> M;\n\t\tG g,pts;\n\t\tfor(int i=0; i<N; i++)\n\t\t{\n\t\t\tdouble x,y;\n\t\t\tcin >> x >> y;\n\t\t\tg.push_back(P(x,y));\n\t\t}\n\t\tfor(int i=0; i<M; i++)\n\t\t{\n\t\t\tdouble x,y;\n\t\t\tcin >> x >> y;\n\t\t\tpts.push_back(P(x,y));\n\t\t}\n\t\t\n\t\tfor(int i=0; i<M; i++)\n\t\t{\n\t\t\tG f=g;\n\t\t\tfor(int j=0; j<M; j++)\n\t\t\t{\n\t\t\t\tif(i==j) continue;\n\t\t\t\tL divide=trans(pts[i], pts[j]);\n\t\t\t\tvector<G> cut;\n\t\t\t\tif(!ConvexCut(f, divide,cut)) continue;\n\t\t\t\tif(isIntoG(cut[0], pts[i])) f=cut[0];\n\t\t\t\telse f=cut[1];\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tcout << Area(f) << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define FR first\n#define SC second\n#define all(v) (v).begin(), (v).end()\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, f, n) for(int i = (int)(f); i < (int)(n); i++)\n#define each(a, b) for(auto& a : b)\n\ntypedef pair<int, int> P;\n\nconst int inf = 1LL << 55;\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a)-(b)) < EPS)\n#define lt(a, b) ((a) - (b) < -EPS)\n\n// ???/????????????\nstruct Point {\n  double x, y;\n  Point(double x = 0.0, double y = 0.0):x(x), y(y){}\n  \n  Point operator + (Point p) { return Point(x + p.x, y + p.y); }\n  Point operator - (Point p) { return Point(x - p.x, y - p.y); }\n  Point operator * (double a) { return Point(x * a, y * a); }\n  Point operator / (double a) { return Point(x / a, y / a); }\n\n  double abs() { return sqrt(norm()); }\n  double norm() { return x*x + y*y; }\n\n  bool operator < (const Point& p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n  bool operator == (const Point& p) const {\n    return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n  }\n};\ntypedef Point Vector;\n\n// ???\nstruct Circle {\n  Point c;\n  double r;\n  Circle(Point c = Point(), double r = 0.0):c(c), r(r){}\n};\n\n// ????§???¢\ntypedef vector<Point> Polygon;\n\n// ??????/??´???\nstruct Segment {\n  Point p1, p2;\n  Segment(Point p1 = Point(), Point p2 = Point()):p1(p1), p2(p2){}\n};\ntypedef Segment Line;\n\n// ????????????????????????\ndouble norm(Vector v)\n{\n  return v.x*v.x + v.y*v.y;\n}\n// ?????????????????§??????\ndouble abs(Vector v)\n{\n  return sqrt(norm(v));\n}\n// ?????????????????????\ndouble dot(Vector a, Vector b)\n{\n  return a.x*b.x + a.y*b.y;\n}\n// ??????????????????????????§??????\ndouble cross(Vector a, Vector b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n// ??´?????????\nbool isOrthogonal(Vector a, Vector b)\n{\n  return equals(dot(a, b), 0.0);\n}\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2)\n{\n  return isOrthogonal(a1 - a2, b1 - b2);\n}\nbool isOrthogonal(Segment s1, Segment s2)\n{\n  return equals(dot(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n// ????????????\nbool isParallel(Vector a, Vector b)\n{\n  return equals(cross(a, b), 0.0);\n}\nbool isParallel(Point a1, Point a2, Point b1, Point b2)\n{\n  return isParallel(a1 - a2, b1 - b2);\n}\nbool isParallel(Segment s1, Segment s2)\n{\n  return equals(cross(s1.p2 - s1.p1, s2.p2 - s2.p1), 0.0);\n}\n// ?°???±\nPoint project(Segment s, Point p)\n{\n  Vector base = s.p2 - s.p1;\n  double r = dot(p - s.p1, base) / norm(base);\n  return s.p1 + base * r;\n}\n// ????°?\nPoint reflect(Segment s, Point p)\n{\n  return p + (project(s, p) - p) * 2.0;\n}\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE         = -1;\nstatic const int ONLINE_BACK       = 2;\nstatic const int ONLINE_FRONT      = -2;\nstatic const int ON_SEGMENT        = 0;\n// ???????¨???????\nint ccw(Point p0, Point p1, Point p2)\n{\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if(cross(a, b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a, b) < -EPS) return CLOCKWISE;\n  if(dot(a, b) < -EPS) return ONLINE_BACK;\n  if(a.norm() < b.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n// ????????????\nbool intersect(Point p1, Point p2, Point p3, Point p4)\n{\n  return (ccw(p1, p2, p3) * ccw(p1, p2, p4) <= 0 &&\n\t  ccw(p3, p4, p1) * ccw(p3, p4, p2) <= 0);\n}\nbool intersect(Segment s1, Segment s2)\n{\n  return intersect(s1.p1, s1.p2, s2.p1, s2.p2);\n}\n// ?????????????????¢\ndouble getDistance(Point a, Point b)\n{\n  return abs(a - b);\n}\n// ??´?????¨?????¨????????¢\ndouble getDistanceLP(Line l, Point p)\n{\n  return abs(cross(l.p2 - l.p1, p - l.p1) / abs(l.p2 - l.p1));\n}\n// ????????¨?????¨????????¢\ndouble getDistanceSP(Segment s, Point p)\n{\n  if(dot(s.p2 - s.p1, p - s.p1) < 0.0) return abs(p - s.p1);\n  if(dot(s.p1 - s.p2, p - s.p2) < 0.0) return abs(p - s.p2);\n  return getDistanceLP(s, p);\n}\n// ????????????????????¢\ndouble getDistance(Segment s1, Segment s2)\n{\n  if(intersect(s1, s2)) return 0.0;\n  return min(min(getDistanceSP(s1, s2.p1), getDistanceSP(s1, s2.p2)),\n\t     min(getDistanceSP(s2, s1.p1), getDistanceSP(s2, s1.p2)));\n}\n// ???????????????\nPoint getCrossPoint(Segment s1, Segment s2)\n{\n  Vector base = s2.p2 - s2.p1;\n  double d1 = abs(cross(base, s1.p1 - s2.p1));\n  double d2 = abs(cross(base, s1.p2 - s2.p1));\n  double t = d1 / (d1 + d2);\n  return s1.p1 + (s1.p2 - s1.p1) * t;\n}\nPoint getCrossPointLL(Line l1, Line l2)\n{\n  Vector v1 = l1.p2 - l1.p1, v2 = l2.p2 - l2.p1;\n  double d = cross(v2, v1);\n  if(abs(d) < EPS) return l2.p1;\n  return l1.p1 + v1 * cross(v2, l2.p2 - l1.p1) * (1.0 / d);\n}\n// ?????´????????????\nLine getPerpendicularBisector(Point p1, Point p2)\n{\n  Point c = (p1 + p2) / 2.0;\n  Point q = Point(c.x + (p1.y - p2.y), c.y + (p2.x - p1.x));\n  return Line(c, q);\n}\n// ????´?????§???¢?????¢???\ndouble getArea(Polygon p)\n{\n  double ret = 0.0;\n  for(int i = 0; i < (int)p.size(); i++) {\n    ret += cross(p[i], p[(i+1)%p.size()]);\n  }\n  return abs(ret) / 2.0;\n}\n  \n// ????????????\nstatic const int IN_POLYGON = 2;\nstatic const int ON_POLYGON = 1;\nstatic const int OUT_POLYGON = 0;\nint contains(Polygon g, Point p)\n{\n  int n = g.size();\n  bool x = false;\n  for(int i = 0; i < n; i++) {\n    Point a = g[i] - p, b = g[(i+1) % n] - p;\n    if(abs(cross(a, b)) < EPS && dot(a, b) < EPS) return ON_POLYGON;\n    if(a.y > b.y) swap(a, b);\n    if(a.y < EPS && EPS < b.y && cross(a, b) > EPS) x = !x;\n  }\n  return (x ? IN_POLYGON : OUT_POLYGON);\n}\n// ???????§???¢?????????\n// ???????§???¢???????????´?????§???????????????????????´???????????????\nPolygon convexCut(Polygon s, Line l)\n{\n  Polygon t;\n  for(int i = 0; i < (int)s.size(); i++) {\n    Point a = s[i], b = s[(i+1)%s.size()];\n    if(ccw(l.p1, l.p2, a) != -1) t.push_back(a);\n    if(ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0) {\n      t.push_back(getCrossPointLL(Line(a, b), l));\n    }\n  }\n  return t;\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n  int N, M;\n  while(cin >> N >> M, N) {\n    Polygon l(N), C(M);\n    rep(i, N) cin >> l[i].x >> l[i].y;\n    rep(i, M) cin >> C[i].x >> C[i].y;\n    rep(i, M) {\n      Polygon p = l;\n      rep(j, M) if(i != j) p = convexCut(p, getPerpendicularBisector(C[i], C[j]));\n      cout << getArea(p) << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nconstexpr ld EPS = 1e-12;\nconstexpr int INF = numeric_limits<int>::max() / 2;\nconstexpr int MOD = 1e9 + 7;\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define ALL(x) (x).begin(), (x).end()\n\ntemplate <typename T>\nvoid printv(const vector<T> &v)\n{\n    int sz = v.size();\n    for (int i = 0; i < sz; i++)\n    {\n        cout << v[i] << \" \\n\"[i == sz - 1];\n    }\n}\n\nusing Point = complex<ld>;\n\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nnamespace std\n{\nbool operator<(const Point &lhs, const Point &rhs)\n{\n    if (lhs.real() < rhs.real() - eps)\n        return true;\n    if (lhs.real() > rhs.real() + eps)\n        return false;\n    return lhs.imag() < rhs.imag();\n}\n} // namespace std\n\nPoint input_point()\n{\n    ld x, y;\n    cin >> x >> y;\n    return Point(x, y);\n}\n\nbool eq(ld a, ld b)\n{\n    return (abs(a - b) < eps);\n}\n\nld dot(Point a, Point b)\n{\n    return real(conj(a) * b);\n}\n\nld cross(Point a, Point b)\n{\n    return imag(conj(a) * b);\n}\n\nclass Line\n{\n  public:\n    Point a, b;\n    Line() : a(Point(0, 0)), b(Point(0, 0)) {}\n    Line(Point a, Point b) : a(a), b(b) {}\n};\n\nclass Circle\n{\n  public:\n    Point p;\n    ld r;\n    Circle() : p(Point(0, 0)), r(0) {}\n    Circle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW::counter clockwise\nint ccw(Point a, Point b, Point c)\n{\n    b -= a;\n    c -= a;\n    if (cross(b, c) > eps)\n        return 1; // a,b,c : counter-clockwise\n    if (cross(b, c) < -eps)\n        return -1; // a,b,c : clockwise\n    if (dot(b, c) < 0)\n        return 2; // c,a,b : on a line\n    if (norm(b) < norm(c))\n        return -2; // a,b,c : on a line\n    return 0;      // a,c,b : on a line\n}\n\nbool isis_ll(Line l, Line m)\n{\n    return !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// s : line segment\nbool isis_ls(Line l, Line s)\n{\n    return isis_ll(l, s) &&\n           (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_ss(Line s, Line t)\n{\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n           ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nbool isis_lp(Line l, Point p)\n{\n    return (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nbool isis_sp(Line s, Point p)\n{\n    return (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\nPoint proj(Line l, Point p)\n{\n    ld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n    return l.a + t * (l.a - l.b);\n}\n\nPoint is_ll(Line s, Line t)\n{\n    Point sv = s.b - s.a, tv = t.b - t.a;\n    assert(cross(sv, tv) != 0);\n    return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nld dist_lp(Line l, Point p)\n{\n    return abs(p - proj(l, p));\n}\n\nld dist_ll(Line l, Line m)\n{\n    return isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(Line l, Line s)\n{\n    return isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(Line s, Point p)\n{\n    Point r = proj(s, p);\n    return isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(Line s, Line t)\n{\n    if (isis_ss(s, t))\n        return 0;\n    return min({dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b)});\n}\n\nvector<Point> is_cc(Circle c1, Circle c2)\n{\n    vector<Point> res;\n    ld d = abs(c1.p - c2.p);\n    ld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n    ld dfr = c1.r * c1.r - rc * rc;\n    if (abs(dfr) < eps)\n        dfr = 0.0;\n    else if (dfr < 0.0)\n        return res; // no intersection\n    ld rs = sqrt(dfr);\n    Point diff = (c2.p - c1.p) / d;\n    res.push_back(c1.p + diff * Point(rc, rs));\n    if (dfr != 0.0)\n        res.push_back(c1.p + diff * Point(rc, -rs));\n    return res;\n}\n\nvector<Point> is_lc(Circle c, Line l)\n{\n    vector<Point> res;\n    ld d = dist_lp(l, c.p);\n    if (d < c.r + eps)\n    {\n        ld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n        Point nor = (l.a - l.b) / abs(l.a - l.b);\n        res.push_back(proj(l, c.p) + len * nor);\n        res.push_back(proj(l, c.p) - len * nor);\n    }\n    return res;\n}\n\nvector<Point> is_sc(Circle c, Line l)\n{\n    vector<Point> v = is_lc(c, l), res;\n    for (Point p : v)\n        if (isis_sp(l, p))\n            res.push_back(p);\n    return res;\n}\n\nvector<Line> tangent_cp(Circle c, Point p)\n{\n    vector<Line> ret;\n    Point v = c.p - p;\n    ld d = abs(v);\n    ld l = sqrt(norm(v) - c.r * c.r);\n    if (isnan(l))\n    {\n        return ret;\n    }\n    Point v1 = v * Point(l / d, c.r / d);\n    Point v2 = v * Point(l / d, -c.r / d);\n    ret.push_back(Line(p, p + v1));\n    if (l < eps)\n        return ret;\n    ret.push_back(Line(p, p + v2));\n    return ret;\n}\n\nvector<Line> tangent_cc(Circle c1, Circle c2)\n{\n    vector<Line> ret;\n    if (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps)\n    {\n        Point center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n        ret = tangent_cp(c1, center);\n    }\n    if (abs(c1.r - c2.r) > eps)\n    {\n        Point out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n        vector<Line> nret = tangent_cp(c1, out);\n        ret.insert(ret.end(), ALL(nret));\n    }\n    else\n    {\n        Point v = c2.p - c1.p;\n        v /= abs(v);\n        Point q1 = c1.p + v * Point(0, 1) * c1.r;\n        Point q2 = c1.p + v * Point(0, -1) * c1.r;\n        ret.push_back(Line(q1, q1 + v));\n        ret.push_back(Line(q2, q2 + v));\n    }\n    return ret;\n}\n\ntypedef vector<Point> Polygon;\n\nld area(const Polygon &p)\n{\n    ld res = 0;\n    int n = p.size();\n    REP(j, n)\n    res += cross(p[j], p[(j + 1) % n]);\n    return res / 2;\n}\n\nbool is_counter_clockwise(const Polygon &poly)\n{\n    ld angle = 0;\n    int n = poly.size();\n    REP(i, n)\n    {\n        Point a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n        angle += arg((c - b) / (b - a));\n    }\n    return angle > eps;\n}\n\n// -1 => out\n//  0 => on\n//  1 => in\nint is_in_polygon(const Polygon &poly, Point p)\n{\n    ld angle = 0;\n    int n = poly.size();\n    REP(i, n)\n    {\n        Point a = poly[i], b = poly[(i + 1) % n];\n        if (isis_sp(Line(a, b), p))\n            return 1;\n        angle += arg((b - p) / (a - p));\n    }\n    return eq(angle, 0) ? 0 : 2;\n}\n\nPolygon convex_hull(vector<Point> ps)\n{\n    int n = ps.size();\n    int k = 0;\n    sort(ps.begin(), ps.end());\n    Polygon ch(2 * n);\n    for (int i = 0; i < n; ch[k++] = ps[i++])\n        while (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0)\n            --k;\n    for (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n        while (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0)\n            --k;\n    ch.resize(k - 1);\n    return ch;\n}\n\nPolygon convex_cut(const Polygon &ps, Line l)\n{\n    int n = ps.size();\n    Polygon Q;\n    REP(i, n)\n    {\n        Point A = ps[i], B = ps[(i + 1) % n];\n        Line m = Line(A, B);\n        if (ccw(l.a, l.b, A) != -1)\n            Q.push_back(A);\n        if (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m))\n            Q.push_back(is_ll(l, m));\n    }\n    return Q;\n}\n\n// a, b の垂直二等分線. a -> b を90度反時計回り回転\nLine bisector(Point a, Point b)\n{\n    Point mid = (a + b) * Point(0.5, 0);\n    return Line(mid, mid + (b - a) * Point(0, pi / 2));\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int N, M;\n    while (cin >> N >> M, N || M)\n    {\n        Polygon island;\n        for (int i = 0; i < N; i++)\n        {\n            ld x, y;\n            cin >> x >> y;\n            island.push_back(Point(x, y));\n        }\n        vector<Point> castle;\n        for (int i = 0; i < M; i++)\n        {\n            ld x, y;\n            cin >> x >> y;\n            castle.push_back(Point(x, y));\n        }\n        for (int i = 0; i < M; i++)\n        {\n            Polygon p = island;\n            for (int j = 0; j < M; j++)\n            {\n                if (i == j)\n                    continue;\n                Line l = bisector(castle[i], castle[j]);\n                p = convex_cut(p, l);\n            }\n            cout << fixed << setprecision(10) << area(p) << endl;\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <math.h>\n#include <complex>\n#include <vector>\n#include <assert.h>\n\nstatic const double EPS = 1e-5;\nusing namespace std;\n\ntypedef complex<double> Complex;\ntypedef vector<Complex> Polygon;\n\ndouble cross(const Complex a, Complex b) {\n  return imag(conj(a) * b);\n}\n\ndouble dot(Complex a, Complex b) {\n  return real(conj(a) * b);\n}\n\ndouble ccw(Complex a, Complex b) {\n  return a.real() * b.imag() - a.imag() * b.real();\n}\n\nint ccw3(Complex a, Complex b, Complex c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0) return 1;\n  if (cross(b, c) < 0) return -1;\n  if (dot(b, c) < 0) return +2;\n  if (dot(b, c) > 0) return -2;\n  return 0;\n}\n\ndouble area(Complex a, Complex b, Complex c) {\n  Complex v1 = b - a;\n  Complex v2 = c - a;\n  return abs(v1.real() * v2.imag() - v2.real() * v1.imag()) / 2.0;\n}\n\nComplex intersection(const Complex s1, Complex e1, Complex s2, Complex e2) {\n  double a = cross(e1 - s1, e2 - s2);\n  double b = cross(e1 - s1, e1 - s2);\n  if (abs(a) < EPS && abs(b) < EPS) { return s2; }\n  if (abs(a) < EPS) { assert(false); }\n  return s2 + b / a * (e2 - s2);\n}\n\nPolygon convex_cut(const Polygon &P, const Complex s1, const Complex e1) {\n  Polygon Q;\n  for (int i = 0; i < (int)P.size(); i++) {\n    Complex a = P[i];\n    Complex b = P[0];\n    if (i != (int)P.size() - 1) {\n      b = P[i + 1];\n    }\n    if (ccw3(s1, e1, a) != -1) { Q.push_back(a); }\n    if (ccw3(s1, e1, a) * ccw3(s1, e1, b) < EPS) {\n      Q.push_back(intersection(s1, e1, a, b));\n    }\n  }\n  return Q;\n}\n\nvoid tyuusen(Complex a, Complex b, Complex &s1, Complex &e1) {\n  Complex center = (a + b) / 2.0;\n  s1 = center + (b - a) * Complex(0.0, -1000.0);\n  e1 = center + (b - a) * Complex(0.0, 1000.0);\n}\n\nPolygon island;\nComplex point[100];\n\nint main() {\n  int n, m;\n  while (scanf(\"%d %d\", &n, &m), n|m) {\n  island.clear();\n  for (int i = 0; i < n; i++) {\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    island.push_back(Complex(a, b));\n  }\n  for (int i = 0; i < m; i++) {\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    point[i] = Complex(a, b);\n  }\n  for (int i = 0; i < m; i++) {\n    Polygon voronoi = island;\n    for (int j = 0; j < m; j++) {\n      if (i == j) { continue; }\n      Complex a, b;\n      tyuusen(point[i], point[j], a, b);\n      voronoi = convex_cut(voronoi, a, b);\n    }\n    double ans = 0.0;\n    for (int k = 0; k < (int)voronoi.size(); k++) {\n      Complex next = voronoi[0];\n      if (k != (int)voronoi.size() - 1) { next = voronoi[k + 1]; }\n      if (abs(voronoi[k].real() - next.real()) < EPS && abs(voronoi[k].imag() - next.imag()) < EPS) { continue; }\n      ans += area(point[i], voronoi[k], next);\n    }\n    printf(\"%lf\\n\", ans);\n  }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\nconst double eps = 1e-10;\n\n#define RIGHT 1\n#define LEFT -1\n\ntypedef complex<double> P;\ntypedef vector<P> Polygon;\ntypedef pair<P,P> Line;\n\ndouble cross(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\nP intersection_ll(P a1,P a2,P b1,P b2){\n  P a=a2-a1,b=b2-b1;\n  return a1+a*cross(b,b1-a1)/cross(b,a);\n}\n\n\nint ccw(P a,P b){\n  if ( cross(a,b)<0)return RIGHT;\n  else if ( cross(a,b)>0)return LEFT;\n  return 2;\n}\n\nvector<P> Convex_Cut(Polygon in,int n,P a1,P a2,int cutpos){\n  vector<P> ret;\n  rep(i,n){\n    P now = in[i],next=in[(i+1)%n];\n    if( ccw(a1-a2,now-a2)==cutpos)ret.push_back(now);\n    if ( ccw(a1-a2,now-a1)*ccw(a1-a2,next-a2)<0)\n      ret.push_back(intersection_ll(a1,a2,now,next));\n  }\n  return ret;\n}\n\n//cutpos ha mondai izon. which side will remain\nLine make_line(P ori,P b,int cutpos){\n  P tmp=(ori+b);\n  tmp.real()/=2;tmp.imag()/=2;\n  P ret=b-tmp;\n  swap(ret.real(),ret.imag());\n  ret.real()*=-1;\n  if ( ccw(ret,ori-tmp)!= cutpos)return make_pair(tmp,ret+tmp);\n  return make_pair(ret+tmp,tmp);\n}\n\ndouble Polygon_Area(vector<P> a,int n){\n  double sum=0;\n  rep(i,n){\n    sum+=(a[i%n].real()-a[(i+1)%n].real())*(a[i%n].imag()+a[(i+1)%n].imag());\n  }\n  if( sum<0)sum*=-1;\n  return sum/2;\n}\n\n\nvoid solve(int n,int m,Polygon in,vector<P> CutLine){\n  vector<Line> ver;\n  rep(i,CutLine.size())\n    if ( i == m)continue;\n    else ver.push_back(make_line(CutLine[m],CutLine[i],LEFT));\n\n  rep(i,ver.size())\n    in=Convex_Cut(in,in.size(),ver[i].first,ver[i].second,LEFT);\n  \n  printf(\"%.4lf\\n\",Polygon_Area(in,in.size()));\n}\n\nmain(){\n  int n,m;\n  while(cin>>n>>m&&n){\n    Polygon a;\n    vector<P> CutPoint;\n    rep(i,n){\n      P tmp;cin>>tmp.real()>>tmp.imag();a.push_back(tmp);\n    }\n    rep(i,m){\n      P tmp;\n      cin>>tmp.real()>>tmp.imag();\n      CutPoint.push_back(tmp);\n    }\n    \n    rep(i,m)\n      solve(n,i,a,CutPoint);\n    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\ntypedef pair<int,int> pint;\ntypedef pair<ll,ll> pll;\n\n#define FI first\n#define SE second\n#define PB push_back\n#define MP make_pair\n#define ALL(s) (s).begin(),(s).end()\n#define REP(i,n) for (int i = 0; i < (int)(n); ++i)\n#define EACH(i,s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n#define COUT(x) cout<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<<endl\n\ntemplate<class T1, class T2> ostream& operator<<(ostream &s, pair<T1,T2> P){return s<<'<'<<P.first<<\", \"<<P.second<<'>';}\ntemplate<class T> ostream& operator<<(ostream &s, vector<T> P) {s<<\"{ \";for(int i=0;i<P.size();++i){if(i>0)s<<\", \";s<<P[i];}return s<<\" }\"<<endl;}\ntemplate<class T1, class T2> ostream& operator<<(ostream &s, map<T1,T2> P) {s<<\"{ \";for(__typeof__(P.begin()) it=P.begin();it!=P.end();++it){if(it!=P.begin())s<<\", \";s<<'<'<<it->first<<\"->\"<<it->second<<'>';}return s<<\" }\"<<endl;}\n\n\n\ntypedef long double DD;\n\nconst DD INF = 1LL<<29;\nconst DD EPS = 1e-6;\nconst DD PI = acos(-1.0);\nDD torad(int deg) {return (DD)(deg) * PI / 180;}\nDD todeg(DD ang) {return ang * 180 / PI;}\n\nstruct Point {\n    DD x, y;\n    Point(DD x = 0.0, DD y = 0.0) : x(x), y(y) {}\n    friend ostream& operator << (ostream &s, const Point &p) {return s << '(' << p.x << \", \" << p.y << ')';}\n};\n\nPoint operator + (const Point &p, const Point &q) {return Point(p.x + q.x, p.y + q.y);}\nPoint operator - (const Point &p, const Point &q) {return Point(p.x - q.x, p.y - q.y);}\nPoint operator * (const Point &p, DD a) {return Point(p.x * a, p.y * a);}\nPoint operator * (DD a, const Point &p) {return Point(a * p.x, a * p.y);}\nPoint operator * (const Point &p, const Point &q) {return Point(p.x * q.x - p.y * q.y, p.x * q.y + p.y * q.x);}\nPoint operator / (const Point &p, DD a) {return Point(p.x / a, p.y / a);}\nPoint conj(const Point &p) {return Point(p.x, -p.y);}\nPoint rot(const Point &p, DD ang) {return Point(cos(ang) * p.x - sin(ang) * p.y, sin(ang) * p.x + cos(ang) * p.y);}\nPoint rot90(const Point &p) {return Point(-p.y, p.x);}\nDD cross(const Point &p, const Point &q) {return p.x * q.y - p.y * q.x;}\nDD dot(const Point &p, const Point &q) {return p.x * q.x + p.y * q.y;}\nDD norm(const Point &p) {return dot(p, p);}\nDD abs(const Point &p) {return sqrt(dot(p, p));}\nDD amp(const Point &p) {DD res = atan2(p.y, p.x); if (res < 0) res += PI*2; return res;}\nbool eq(const Point &p, const Point &q) {return abs(p - q) < EPS;}\nbool operator < (const Point &p, const Point &q) {return (abs(p.x - q.x) > EPS ? p.x < q.x : p.y < q.y);}\nbool operator > (const Point &p, const Point &q) {return (abs(p.x - q.x) > EPS ? p.x > q.x : p.y > q.y);}\nPoint operator / (const Point &p, const Point &q) {return p * conj(q) / norm(q);}\n\nint ccw(const Point &a, const Point &b, const Point &c) {\n    if (cross(b-a, c-a) > EPS) return 1;\n    if (cross(b-a, c-a) < -EPS) return -1;\n    if (dot(b-a, c-a) < -EPS) return 2;\n    if (norm(b-a) < norm(c-a) - EPS) return -2;\n    return 0;\n}\n\nstruct Line : vector<Point> {\n    Line(Point a = Point(0.0, 0.0), Point b = Point(0.0, 0.0)) {\n        this->push_back(a);\n        this->push_back(b);\n    }\n};\n\ntypedef vector<Point> Polygon;\nvector<Point> crosspoint(const Line &l, const Line &m) {\n    vector<Point> res;\n    DD d = cross(m[1] - m[0], l[1] - l[0]);\n    if (abs(d) < EPS) return vector<Point>();\n    res.push_back(l[0] + (l[1] - l[0]) * cross(m[1] - m[0], m[1] - l[0]) / d);\n    return res;\n}\nPolygon convexcut(const Polygon &pol, const Line &l) {\n    Polygon res;\n    for (int i = 0; i < pol.size(); ++i) {\n        Point p = pol[i], q = pol[(i+1)%pol.size()];\n        if (ccw(l[0], l[1], p) != -1) {\n            if (res.size() == 0) res.push_back(p);\n            else if (!eq(p, res[res.size()-1])) res.push_back(p);\n        }\n        if (ccw(l[0], l[1], p) * ccw(l[0], l[1], q) < 0) {\n            vector<Point> temp = crosspoint(Line(p, q), l);\n            if (temp.size() == 0) continue;\n            else if (res.size() == 0) res.push_back(temp[0]);\n            else if (!eq(temp[0], res[res.size()-1])) res.push_back(temp[0]);\n        }\n    }\n    return res;\n}\n\nLine bisector(const Point &p, const Point &q) {\n    Point c = (p + q) / 2.0L;\n    Point v = (q - p) * Point(0.0L, 1.0L);\n    v = v / abs(v);\n    return Line(c - v, c + v);\n}\nPolygon Voronoi(Polygon pol, const vector<Point> &ps, int ind) {\n    for (int i = 0; i < ps.size(); ++i) {\n        if (i == ind) continue;\n        Line l = bisector(ps[ind], ps[i]);\n        pol = convexcut(pol, l);\n    }\n    return pol;\n}\n\nDD area(const vector<Point> &pol) {\n    DD res = 0.0;\n    for (int i = 0; i < pol.size(); ++i) {\n        res += cross(pol[i], pol[(i+1)%pol.size()]);\n    }\n    return res/2.0L;\n}\n\nint N, M;\nPolygon pol;\nvector<Point> ps;\nvector<Polygon> vol;\ndouble x, y;\n\n\nint main() {\n    while (cin >> N >> M) {\n        if (N == 0) break;\n        pol.clear(); pol.resize(N);\n        for (int i = 0; i < N; ++i) {\n            cin >> x >> y;\n            pol[i] = Point(x, y);\n        }\n        ps.clear(); ps.resize(M);\n        for (int i = 0; i < M; ++i) {\n            cin >> x >> y;\n            ps[i] = Point(x, y);\n        }\n        vol.clear(); vol.resize(M);\n        for (int i = 0; i < M; ++i) {\n            vol[i] = Voronoi(pol, ps, i);\n            DD S = area(vol[i]);\n            cout << fixed << setprecision(5) << S << endl;\n        }\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P, P> L;\ntypedef vector<P> VP;\nconst D EPS = 1e-9;\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\nD dot(P a, P b) {return (conj(a)*b).X; }\nD cross(P a, P b) {  return (conj(a)*b).Y;}\nint ccw(P a, P b, P c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1; \n  if (cross(b,c) < -EPS) return -1;\n  if (dot(b,c)   < -EPS) return +2;\n  if (norm(b) < norm(c)) return -2;  \n  return 0; \n}\nP crosspointLL(P a1, P a2, P b1, P b2) {\n  D d1 = cross(b2-b1, b1-a1);\n  D d2 = cross(b2-b1, a2-a1);\n  if (EQ(d1, 0) && EQ(d2, 0)) return a1;\n  if (EQ(d2, 0)) throw \"kouten ga nai\";\n  return a1 + d1/d2 * (a2-a1);\n}\nVP convexCut(const VP& ps, P a1, P a2) {\n  int n = ps.size();\n  VP ret;\n  rep(i,n) {\n    int ccwc = ccw(a1, a2, ps[i]);\n    if (ccwc != -1) ret.push_back(ps[i]);\n    int ccwn = ccw(a1, a2, ps[(i + 1) % n]);\n    if (ccwc * ccwn == -1) ret.push_back(crosspointLL(a1, a2, ps[i], ps[(i + 1) % n]));\n  }\n  return ret;\n}\nD area(const VP& ps) {\n  D a = 0;\n  rep (i, ps.size()) a += cross(ps[i], ps[(i+1) % ps.size()]);\n  return a / 2;\n}\nVP voronoiCell(P p, const VP& ps, const VP& outer) {\n  VP cl = outer;\n  rep (i, ps.size()) {\n    if (EQ(abs(ps[i]-p), 0)) continue;\n    P h = (p+ps[i])*0.5;\n    cl = convexCut(cl, h, h + (ps[i]-h)*P(0,1) );\n  }\n  return cl;\n}\nint n,m;\nVP v1,v2;\ndouble x,y;\nint main(){\n  while(cin>>n>>m,n){\n    v1.clear();\n    v2.clear();\n    rep(i,n){\n      cin>>x>>y;\n      v1.push_back(P(x,y));\n    }\n    rep(i,m){\n      cin>>x>>y;\n      v2.push_back(P(x,y));\n    }\n    rep(i,m){\n      VP t=voronoiCell(v2[i],v2,v1);\n      printf(\"%.10f\\n\",area(t));\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cstdio>\n#include <utility>\n#include <vector>\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<P,P> L;\ntypedef pair<P,double> C;\ntypedef vector<P> Poly;\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define INF (1e15)\n\n//2D version\nnamespace std{\n  bool operator < (const P& a, const P& b){\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n  bool cmp_y(const P &a, const P &b){\n    return a.Y != b.Y ? a.Y < b.Y : a.X < b.X;\n  }\n  bool operator == (const P& a, const P& b){\n    return abs(a-b) < EPS;\n  }\n}\n\ndouble dot(P a, P b){\n  return a.X * b.X + a.Y * b.Y;\n}\ndouble cross(P a, P b){\n  return a.X * b.Y - a.Y * b.X;\n}\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if( cross(b,c) > EPS ) return +1;\n  if( cross(b,c) < -EPS ) return -1;\n  if( dot(b,c) < 0 ) return +2;\n  if( abs(b) + EPS < abs(c) ) return -2;\n  return 0;\n}\n\nP intersection(L a, L b){\n  //直線aと直線bの交点\n  return a.first + cross(b.second-b.first,a.first-b.first)/(-cross(b.second-b.first,a.second-b.first)+cross(b.second-b.first,a.first-b.first))*(a.second-a.first);\n}\n\nPoly convex_cut(Poly p, L l){\n  Poly ret;\n  int n = p.size();\n  for(int i = 0; i < n; ++i){\n    if(ccw(l.first, l.second, p[i]) != -1) ret.push_back(p[i]);\n    if(ccw(l.first, l.second, p[i]) != -1 ^ ccw(l.first, l.second, p[(i+1)%n]) != -1) ret.push_back(intersection(L(p[i], p[(i+1)%n]), l));\n  }\n  return ret;\n}\n\ndouble area(Poly p){\n  double ret = 0;\n  int n = p.size();\n  for(int i = 0; i < n; ++i){\n    ret += cross(p[i], p[(i+1)%n])/2;\n  }\n  return ret;\n}\n\nint main(){\n  int N, M;\n  while(cin >> N >> M, N||M){\n    Poly I;\n    for(int i = 0; i < N; ++i){\n      double x, y;\n      cin >> x >> y;\n      I.push_back(P(x,y));\n    }\n    Poly p;\n    for(int j = 0; j < M; ++j){\n      double x, y;\n      cin >> x >> y;\n      p.push_back(P(x,y));\n    }\n    for(int i = 0; i < M; ++i){\n      Poly q = I;\n      for(int j = 0; j < M; ++j){\n        if(i == j) continue;\n        L bisector = L((p[i]+p[j])/2.0, (p[i]+p[j])/2.0 + (p[j]-p[i])*P(0,1));\n        q = convex_cut(q, bisector);\n      }\n      cout << area(q) << endl;\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <math.h>\n#include <complex>\n#include <vector>\n#include <assert.h>\n\nstatic const double EPS = 1e-5;\nusing namespace std;\n\ntypedef complex<double> Complex;\ntypedef vector<Complex> Polygon;\n\ndouble cross(const Complex a, Complex b) {\n  return imag(conj(a) * b);\n}\n\ndouble dot(Complex a, Complex b) {\n  return real(conj(a) * b);\n}\n\ndouble ccw(Complex a, Complex b) {\n  return a.real() * b.imag() - a.imag() * b.real();\n}\n\nint ccw3(Complex a, Complex b, Complex c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0) return 1;\n  if (cross(b, c) < 0) return -1;\n  if (dot(b, c) < 0) return +2;\n  if (dot(b, c) > 0) return -2;\n  return 0;\n}\n\ndouble area(Complex a, Complex b, Complex c) {\n  Complex v1 = b - a;\n  Complex v2 = c - a;\n  return abs(v1.real() * v2.imag() - v2.real() * v1.imag()) / 2.0;\n}\n\nComplex intersection(const Complex s1, Complex e1, Complex s2, Complex e2) {\n  double a = cross(e1 - s1, e2 - s2);\n  double b = cross(e1 - s1, e1 - s2);\n  if (abs(a) < EPS && abs(b) < EPS) { return s2; }\n  if (abs(a) < EPS) { assert(false); }\n  return s2 + b / a * (e2 - s2);\n}\n\nPolygon convex_cut(const Polygon &P, const Complex s1, const Complex e1) {\n  Polygon Q;\n  for (int i = 0; i < (int)P.size(); i++) {\n    Complex a = P[i];\n    Complex b = P[0];\n    if (i != (int)P.size() - 1) {\n      b = P[i + 1];\n    }\n    if (ccw3(s1, e1, a) != -1) { Q.push_back(a); }\n    if (ccw3(s1, e1, a) * ccw3(s1, e1, b) < EPS) {\n      Q.push_back(intersection(s1, e1, a, b));\n    }\n  }\n  return Q;\n}\n\nvoid tyuusen(Complex a, Complex b, Complex &s1, Complex &e1) {\n  Complex center = (a + b) / 2.0;\n  s1 = center + (b - a) * Complex(0.0, -1000.0);\n  e1 = center + (b - a) * Complex(0.0, 1000.0);\n}\n\nPolygon island;\nComplex point[100];\n\nint main() {\n  int n, m;\n  scanf(\"%d %d\", &n, &m);\n  for (int i = 0; i < n; i++) {\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    island.push_back(Complex(a, b));\n  }\n  for (int i = 0; i < m; i++) {\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    point[i] = Complex(a, b);\n  }\n  for (int i = 0; i < m; i++) {\n    Polygon voronoi = island;\n    for (int j = 0; j < m; j++) {\n      if (i == j) { continue; }\n      Complex a, b;\n      tyuusen(point[i], point[j], a, b);\n      voronoi = convex_cut(voronoi, a, b);\n    }\n    double ans = 0.0;\n    for (int k = 0; k < (int)voronoi.size(); k++) {\n      Complex next = voronoi[0];\n      if (k != (int)voronoi.size() - 1) { next = voronoi[k + 1]; }\n      if (abs(voronoi[k].real() - next.real()) < EPS && abs(voronoi[k].imag() - next.imag()) < EPS) { continue; }\n      ans += area(point[i], voronoi[k], next);\n    }\n    printf(\"%lf\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<cmath>\n#include<vector>\n#include<cstdlib>\n#include<cassert>\n#include<map>\n#include<iomanip>\n#define _A_ true\n#define EPS 1e-4\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\nusing namespace std;\nclass Point{\npublic:\n  double x,y;\n  Point(double x =0,double y=0):x(x),y(y){}\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(x*a,y*a);}\n  Point operator / (double a){return Point(x/a,y/a);} //もし悪を使うなら要確認\n \n  double norm() {return x*x+y*y;}\n  double abs() {return sqrt(norm());}\n \n  bool operator < (const Point &p) const{\n    return x != p.x ? x < p.x : y < p.y; \n  }\n \n  bool operator == (const Point &p) const{\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\ntypedef Point Point;\nstruct Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p = Point(),Point pp = Point()):p1(p),p2(pp){}\n};\n \ntypedef vector<Point> Polygon;\ntypedef Segment Line;\n \nPoint ACM,IC,PC;\nSegment IC_PC,PC_ACM,ACM_IC;\n \n \n \ndouble norm(Point p){\n  return p.x*p.x+p.y*p.y;\n}\n \ndouble abs(Point p){\n  return sqrt(norm(p));\n}\n \nPoint polar(double a,double rad){\n  return Point(a*cos(rad),a*sin(rad));\n}\n \ndouble args(Point p){\n  return atan2(p.y,p.x);\n}\n \ndouble dot(Point a,Point b){\n  return a.x*b.x+a.y*b.y;\n}\n \ndouble cross(Point a,Point b){\n  return a.x*b.y-b.x*a.y;\n}\n \nPoint project(Segment s,Point p){\n  Point base = s.p2 - s.p1;\n  double t = dot(p-s.p1,base)/base.norm();\n  return s.p1+base*t;\n}\n \nPoint reflect (Segment s, Point p){\n  return p + (project(s,p)-p)*2.0;\n}\n \nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CLOCKWISE;\n  if(dot(a,b) < -EPS) return ONLINE_BACK;\n  if(a.norm() < b.norm() ) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n \nbool isIntersect(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <= 0 && ccw(p3,p4,p1) * ccw(p3,p4,p2) <= 0 );\n}\n \nbool isIntersect(Segment s1,Segment s2){\n  return isIntersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n/*\nPoint getCrossPoint(Segment s1,Segment s2){\n  assert(isIntersect(s1,s2));\n  P base = s2.p2 - s2.p1;\n  double d1 = abs(cross(base,s1.p1-s2.p1));\n  double d2 = abs(cross(base,s1.p2-s2.p1));\n  double t = d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n*/\n \nPoint getCrossPointLines( Line s1, Line s2){\n    Point a = s1.p2 - s1.p1;\n    //cout << \"In getCrossPointLines--------\" << endl;\n    //cout << \"a = \" <<a.x << \",\"  << a.y << endl;\n    Point base = Point(s2.p2.x - s2.p1.x,s2.p2.y - s2.p1.y);\n    //cout <<\"base = \"<< base.x << \",\" << base.y << endl;\n    return s1.p1 + a * cross(base, s2.p1 - s1.p1)/cross(base, a);\n}\n \nPolygon cutPolygon( Polygon P, Line l ){\n    Polygon u;\n    \n    for ( int i = 0; i < P.size(); i++ ){\n        Point a = P[i], b = P[(i+1)%P.size()];\n        if ( ccw(l.p1, l.p2, a) != CLOCKWISE ) u.push_back(a);\n        if ( ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) == -1 ){\n      u.push_back(getCrossPointLines(Segment(a, b), l));\n      \n        }\n    }\n   \n    return u;\n}\n \n \n \nLine CreateLine(Point p,Point pp){\n  Point mid = (p+pp)/2;\n \n  Point sl = pp-p;//原点に5\n  double rad = args(sl);\n  Point ap = polar(abs(sl),rad+M_PI/2)+mid;\n  //ap.x = abs(sl)*cos(rad+M_PI/2)+mid.x;\n  //ap.y = abs(sl)*sin(rad+M_PI/2)+mid.y;\n  return Line(mid,ap);\n}\n \n \ndouble AreaCalc(Polygon p){\n  double area = 0;\n  p.push_back(p[0]);\n  for(int i=0;i<p.size()-1;i++){\n    area+=cross(p[i],p[i+1]);\n  }\n  return abs(area/2);\n}\n \n \n \n \n \nint main(){\n  int N,M;\n  while(cin >> N >> M,N|M){\n  \n  vector<Point> l(N);\n  vector<Point> C(M);\n  for(int i=0;i<N;i++)\n    cin >> l[i].x >> l[i].y;\n  for(int i=0;i<M;i++)\n    cin >> C[i].x >> C[i].y;\n\n  for(int i=0;i<M;i++)\n    {\n      Polygon poly; \n      for(int j=0;j<N;j++)\n\tpoly.push_back(l[j]);\n      for(int j=0;j<M;j++)\n\t{\n\t  if(j == i)\n\t    continue;\n\t  poly = cutPolygon(poly,CreateLine(C[i],C[j]));\n\t}\n      cout << setiosflags(ios::fixed) << setprecision(1) << AreaCalc(poly) << endl;\n\n    }  \n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#define EPS 1e-10\nusing namespace std;\n\nint n,m;\n\ndouble add(double a,double b){\n\tif(fabs(a+b)<EPS*(a+b))return 0.0;\n\treturn a+b;\n}\n\nstruct Point{\n\tdouble x,y;\n\tPoint(){}\n\tPoint(double xx,double yy){\n\t\tx=xx;\n\t\ty=yy;\n\t}\n\tPoint operator +(Point p){\n\t\treturn Point(add(x,p.x),add(y,p.y));\n\t}\n\tPoint operator -(Point p){\n\t\treturn Point(add(x,-p.x),add(y,-p.y));\n\t}\n\tPoint operator *(double d){\n\t\treturn Point(x*d,y*d);\n\t}\n\tPoint operator /(double d){\n\t\treturn Point(x/d,y/d);\n\t}\n};\n\nstruct Segment{\n\tPoint p1,p2;\n\tSegment(){}\n\tSegment(Point pp1,Point pp2){\n\t\tp1=pp1;\n\t\tp2=pp2;\n\t}\n};\ntypedef Point Vector;\ntypedef Segment Line;\n\ntypedef vector<Point> Polygon;\n\ndouble norm(Vector a){\n\treturn add(a.x*a.x,a.y*a.y);\n}\n\ndouble abs(Vector a){\n\treturn sqrt(norm(a));\n}\n\ndouble dot(Vector a,Vector b){\n\treturn add(a.x*b.x,a.y*b.y);\n}\n\ndouble cross(Vector a,Vector b){\n\treturn add(a.x*b.y,-a.y*b.x);\n}\n\nPoint getCrossPoint(Segment s1,Segment s2){\n\tVector base=s2.p2-s2.p1;\n\tdouble d1=abs(cross(base,s1.p1-s2.p1));\n\tdouble d2=abs(cross(base,s1.p2-s2.p1));\n\tdouble t=d1/(d1+d2);\n\treturn s1.p1+(s1.p2-s1.p1)*t;\n}\n\nint ccw(Point p0,Point p1,Point p2){\n\tVector a=p1-p0;\n\tVector b=p2-p0;\n\tif(cross(a,b)>EPS)return 1;\n\tif(cross(a,b)<-EPS)return -1;\n\tif(dot(a,b)<EPS)return 2;\n\tif(norm(a)<norm(b))return -2;\n\treturn 0;\n}\n\nPolygon convex_cut(const Polygon& P,const Line& l){\n\tPolygon Q;\n\tfor(int i=0;i<P.size();i++){\n\t\tPoint A=P[i], B=P[(i+1)%P.size()];\n\t\tif(ccw(l.p1,l.p2,A)!=-1)Q.push_back(A);\n\t\tif(ccw(l.p1,l.p2,A)*ccw(l.p1,l.p2,B)<0){\n\t\t\tQ.push_back(getCrossPoint(Line(A,B),l));\n\t\t}\n\t}\n\treturn Q;\n}\n\ndouble getArea(const Polygon& P){\n\tdouble A=0;\n\tfor(int i=0;i<P.size();i++){\n\t\tA+=cross(P[i],P[(i+1)%P.size()]);\n\t}\n\treturn A/2.0;\n}\n\nPoint c[11];\nPolygon l;\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&n,&m);\n\t\tif(n+m==0)break;\n\t\tl.clear();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tdouble x,y;\n\t\t\tscanf(\"%lf%lf\",&x,&y);\n\t\t\tl.push_back(Point(x,y));\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tscanf(\"%lf%lf\",&c[i].x,&c[i].y);\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tPolygon li=l;\n\t\t\tfor(int j=0;j<m;j++){\n\t\t\t\tif(i==j)continue;\n\t\t\t\tPoint l1=(c[i]+c[j])/2.0;\n\t\t\t\tVector base=c[j]-c[i];\n\t\t\t\tVector base2=Vector(-base.y,base.x);\n\t\t\t\tPoint l2=l1+base2;\n\t\t\t\tli=convex_cut(li,Line(l1,l2));\n\t\t\t}\n\t\t\tprintf(\"%.10f\\n\",getArea(li));\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nusing ld = long double;\nconstexpr ld eps = 1e-8;\n\n\nnamespace geometry2d {\n\n\nusing point = std::complex<long double>;\nusing polygon = std::vector<point>;\n\nbool eq(ld a, ld b) {\n    return (std::abs(a - b) < eps);\n}\n\nlong double dot(point a, point b) {\n    return std::real(std::conj(a) * b);\n}\n\nlong double cross(point a, point b) {\n    return std::imag(std::conj(a) * b);\n}\n\nclass line {\npublic:\n    line()\n        : a(point(0, 0)), b(point(0, 0))\n    {}\n    line(point a_, point b_)\n        : a(a_), b(b_)\n    {}\n\n    point a, b;\n};\n\nint ccw(point a, point b, point c) {\n    b -= a; c -= a;\n    if(cross(b, c) > eps)           return 1;  // a -> b -> c : counterclockwise\n    if(cross(b, c) < -eps)          return -1; // a -> b -> c : clockwise\n    if(dot(b, c) < 0)               return 2;  // c -> a -> b : line\n    if(std::norm(b) < std::norm(c)) return -2; // a -> b -> c : line\n    return 0;                                  // a -> c -> b : line\n}\n\npoint is_ll(line s, line t) {\n    point sv = s.b - s.a, tv = t.b - t.a;\n    assert(cross(sv, tv) != 0);\n    return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n\nld area(polygon const& p) {\n    const int N = p.size();\n    ld res = 0;\n    for(int i=0; i<N; ++i) {\n        res += cross(p[i], p[(i+1)%N]);\n    }\n    return res / 2;\n}\n\n// left side\npolygon convex_cut(polygon const& p, line l) {\n    const int N = p.size();\n    polygon res;\n    for(int i=0; i<N; ++i) {\n        auto a = p[i], b = p[(i+1)%N];\n        if(ccw(l.a, l.b, a) != -1) {\n            res.push_back(a);\n        }\n        if(ccw(l.a, l.b, a) * ccw(l.a, l.b, b) < 0) {\n            res.push_back(is_ll(line(a, b), l));\n        }\n    }\n    return res;\n}\n\n\nline separate(point const& p1, point const& p2) {\n    assert(p1 != p2);\n    auto m = (p1 + p2) * point(0.5, 0);\n    line res;\n    res.a = m + (m - p1) * point(0, 1);\n    res.b = m + (m - p1) * point(0, -1);\n    return res;\n}\n\n\n} // namespace geometry2d\n\nusing namespace geometry2d;\n\n\nint main() {\n    int N, M;\n    while(cin >> N >> M, N) {\n        polygon p;\n        for(int i=0; i<N; ++i) {\n            ld x, y;\n            cin >> x >> y;\n            p.emplace_back(x, y);\n        }\n        vector<point> C;\n        for(int i=0; i<M; ++i) {\n            ld x, y;\n            cin >> x >> y;\n            C.emplace_back(x, y);\n        }\n        for(int i=0; i<M; ++i) {\n            auto p2 = p;\n            for(int j=0; j<M; ++j) {\n                if(i == j) {\n                    continue;\n                }\n                line l = separate(C[i], C[j]);\n                if(ccw(l.a, l.b, C[i]) == -1) {\n                    swap(l.a, l.b);\n                }\n                p2 = convex_cut(p2, l);\n            }\n            cout << fixed << setprecision(10) << area(p2) << endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n  L() {}\n};\ntypedef vector<P> G;\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nG convex_cut(const G& g, const L& l) {\n  G Q;\n  REP(i, g.size()) {\n    P A = curr(g, i), B = next(g, i);\n    if (ccw(l[0], l[1], A) != -1) Q.push_back(A);\n    if (ccw(l[0], l[1], A)*ccw(l[0], l[1], B) < 0)\n      Q.push_back(crosspoint(L(A, B), l));\n  }\n  return Q;\n}\n// 垂直二等分線\nL bisector(const P &a, const P &b) {\n  P A = (a+b)*P(0.5,0);\n  return L(A, A+(b-a)*P(0, PI/2));\n}\n// ボロノイ領域\nG voronoi_cell(G g, const vector<P> &v, int s) {\n  REP(i, v.size())\n    if (i!=s)\n      g = convex_cut(g, bisector(v[s], v[i]));\n  return g;\n}\ndouble area(const G& g) {\n  double A = 0;\n  for (int i = 0; i < g.size(); ++i) {\n    A += cross(g[i], next(g, i));\n  }\n  return A/2;\n}\n\nint main() {\n  int n,m;\n  while(cin>>n>>m) {\n    G g;\n    REP(i,n) {\n      P p;\n      cin >> p.real() >> p.imag();\n      g.push_back(p);\n    }\n    vector<P> v;\n    REP(i,m) {\n      P p;\n      cin >> p.real() >> p.imag();\n      v.push_back(p);\n    }\n    REP(i,m) {\n      double ans = area(voronoi_cell(g, v, i));\n      printf(\"%.6f\\n\", ans);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=a;i<b;i++)\n\n\n\n\n\n\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\ntypedef complex<double> P;\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\ndouble cross(const P& a, const P& b) {\n\treturn imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n\treturn real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n\tL() {}\n\tL(const P &a, const P &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\n\ntypedef vector<P> G;\n\nstruct C {\n\tP p; double r;\n\tC(const P &p, double r) : p(p), r(r) { }\n};\n\n\n\n\n\n\n\n\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;       // counter clockwise\n\tif (cross(b, c) < 0)   return -1;       // clockwise\n\tif (dot(b, c) < 0)     return +2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;       // a--b--c on line\n\treturn 0;\n}\n\nP crosspoint(const L &l, const L &m) {\n\tdouble A = cross(l[1] - l[0], m[1] - m[0]);\n\tdouble B = cross(l[1] - l[0], l[1] - m[0]);\n\tif (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n\tif (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n\treturn m[0] + B / A * (m[1] - m[0]);\n}\n\n\n\n#define curr(PP, i) PP[i]\n#define next(PP, i) PP[(i+1)%PP.size()]\nG convex_cut(const G& g, const L& l) {\n\tG Q;\n\tfor (int i = 0; i < g.size(); ++i) {\n\t\tP A = curr(g, i), B = next(g, i);\n\t\tif (ccw(l[0], l[1], A) != -1) Q.push_back(A);\n\t\tif (ccw(l[0], l[1], A)*ccw(l[0], l[1], B) < 0)\n\t\t\tQ.push_back(crosspoint(L(A, B), l));\n\t}\n\treturn Q;\n}\n\ndouble area2(const G& p) {\n\tdouble A = 0;\n\tfor (int i = 0; i < p.size(); ++i)\n\t\tA += cross(curr(p, i), next(p, i));\n\treturn A / 2.0;\n}\n\nP normal(const P& p)\n{\n\treturn P(-imag(p), real(p));\n}\n\n\n\n\nint N, M;\nG poly;\nP C[10];\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile (cin >> N >> M)\n\t{\n\t\tif (N == 0) return 0;\n\n\t\tpoly.clear();\n\t\trep(i, 0, N)\n\t\t{\n\t\t\tdouble x, y;\n\t\t\tcin >> x >> y;\n\t\t\tpoly.push_back(P(x, y));\n\t\t}\n\n\t\trep(i, 0, M)\n\t\t{\n\t\t\tdouble x, y;\n\t\t\tcin >> x >> y;\n\t\t\tC[i] = P(x, y);\n\t\t}\n\n\t\trep(i, 0, M)\n\t\t{\n\t\t\tG pp = poly;\n\t\t\trep(j, 0, M) if (i != j)\n\t\t\t{\n\t\t\t\tP from = (C[i] + C[j]) / 2.0;\n\t\t\t\tP norm = normal(C[j] - C[i]);\n\t\t\t\tP to = from + norm;\n\n\t\t\t\tpp = convex_cut(pp, L(from, to));\n\t\t\t}\n\t\t\tprintf(\"%.10f\\n\", area2(pp));\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);++i)\n#define rep2(i,a,b) for (int i=(a);i<(b);++i)\n#define rrep(i,n) for (int i=(n)-1;i>=0;--i)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;--i)\n#define chmin(a,b) (a)=min((a),(b));\n#define chmax(a,b) (a)=max((a),(b));\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) cout<<(#v)<<\":\";for(auto(x):(v)){cout<<\" \"<<(x);}cout<<endl;\n#define printVS(vs) cout<<(#vs)<<\":\"<<endl;for(auto(s):(vs)){cout<<(s)<< endl;}\n#define printVV(vv) cout<<(#vv)<<\":\"<<endl;for(auto(v):(vv)){for(auto(x):(v)){cout<<\" \"<<(x);}cout<<endl;}\n#define printP(p) cout<<(#p)<<(p).first<<\" \"<<(p).second<<endl;\n#define printVP(vp) cout<<(#vp)<<\":\"<<endl;for(auto(p):(vp)){cout<<(p).first<<\" \"<<(p).second<<endl;}\n\ninline void output(){ cout << endl; }\ntemplate<typename First, typename... Rest>\ninline void output(const First& first, const Rest&... rest) {\n    cout << first << \" \"; output(rest...);\n}\n\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing TUPLE = tuple<int, int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\nusing Graph = vector<vector<int>>;\n\ntypedef complex<double> P;\ntypedef vector<P> G;\n#define here(g, i) g[i]\n#define next(g, i) g[(i + 1) % g.size()]\n#define prev(g, i) g[(i - 1 + g.size()) % g.size()]\nconst double EPS = 1e-10;\nconst double INF = 1e12;\nconst double PI = acos(-1);\n\nstruct L {\n    P a, b, v;\n    L(){}\n    L(P _a, P _b) : a(_a), b(_b), v(b - a) {}\n    L(double _ax, double _ay, double _bx, double _by) : L(P(_ax, _ay), P(_bx, _by)) {}\n    void reverse() {\n        swap(a, b); v = b - a;\n    }\n};\n\ndouble cross(P a, P b) {\n    return imag(conj(a) * b);\n}\n\ndouble dot(P a, P b) {\n    return real(conj(a) * b);\n}\n\n// signed!!!!!!!!!\ndouble areaG(G g) {\n    int n = g.size();\n    double ret;\n    rep(i, n) {\n        ret += cross(here(g, i), next(g, i));\n    }\n    return ret / 2;\n}\n\nP readP() {\n    double x, y;\n    cin >> x >> y;\n    return P(x, y);\n}\n\nG readG(int n) {\n    // int n;\n    // cin >> n;\n    G g(n);\n    rep(i, n) g[i] = readP();\n    return g;\n}\n\nL PerpendicularBisector(P p, P q) {\n    P c = (p + q) / 2.;\n    P d = (q - p) / 2.;\n    P h = d * P(0, 1);\n    return L(c + h, c - h);\n}\n\nint ccw(P p0, P p1, P p2) {\n    p1 -= p0; p2 -= p0;\n    if (cross(p1, p2) > 0) return +1;       // counter-clockwise\n    if (cross(p1, p2) < 0) return -1;       // clockwise\n    if (dot(p1, p2) < 0) return +2;         // p2 -- p0 -- p1\n    if (norm(p1) < norm(p2)) return -2;     // p0 -- p1 -- p2\n    return 0;                               // p0 -- p2 -- p1\n}\n\nP crosspointLL(L l1, L l2) {\n    return l1.a + l1.v * cross(l2.v, l2.a - l1.a) / cross(l2.v, l1.v);\n}\n\nG convex_cut(G g, L l) {\n    G h;\n    rep(i, (int)g.size()) {\n        P p = here(g, i), q = next(g, i);\n        if (ccw(p, q, l.a) == 0 && ccw(p, q, l.b) == 0) {\n            if (ccw(p, l.b, l.a) == 0) return g;    // p -- l.a -- l.b -- q\n            else return G{};                        // p -- l.b -- l.a -- q\n        }\n        if (ccw(l.a, l.b, p) != -1) h.emplace_back(p);\n        if (ccw(l.a, l.b, p) * ccw(l.a, l.b, q) < 0)\n        h.emplace_back(crosspointLL(L(p, q), l));\n    }\n    return h;\n}\n\nvector<G> Voronoi(G g, vector<P> p) {\n    vector<G> ret;\n    rep(i, p.size()) {\n        G h = g;\n        rep(j, p.size()) {\n            L l = PerpendicularBisector(p[i], p[j]);\n            if (ccw(l.a, l.b, p[i]) == -1) l.reverse();\n            h = convex_cut(h, l);\n        }\n        ret.emplace_back(h);\n    }\n    return ret;\n}\n\nmain() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int n, m;\n    while (cin >> n >> m, n) {\n        G g = readG(n);\n        vector<P> p(m);\n        rep(i, m) p[i] = readP();\n\n        auto vg = Voronoi(g, p);\n        rep(i, vg.size()) {\n            cout << fixed << setprecision(20) << abs(areaG(vg[i])) << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <complex>\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef vector<vector<int> > vii;\ntypedef vector<vector<string> > vss;\ntypedef pair<int, int> pii;\n#define INF 0x7fffffff\n//#define INFLL 0x7fffffffffffffff\n#define INFLL LLONG_MAX\n#define SIZE(v) int((v).size())\n#define ALL(v) (v).begin(), (v).end()\n#define FOR(i,x) for(int i=0;i<x;i++)\n#define FORic(i,y,x) for(int i=y;i<=x;i++)\n#define FORdc(i,y,x) for(int i=y;i>=x;i--)\n#define FILL(a,v) memset(a, v, sizeof(a))\n#define PI 3.14159265358979323846\n\nconst double EPS = 1e-7;\ntypedef complex<double> P; /* _ */\nstruct L {                 /* üª */\n\tdouble angle; // deleteSameLineðgpµÈ¢Àèsv\n\tP p, q;\n\tL(P p, P q) : p(p), q(q), angle(arg(q-p)) {}\n\tbool operator < (const L &l) const {  // deleteSameLineðgpµÈ¢Àèsv\n\t\treturn angle < l.angle;\n    }\n};\ntypedef vector<P> G;\n\n\n// complexÉå¬ÖWªKvÈê\nbool operator < (const P &a, const P &b) {\n\treturn make_pair(real(a),imag(a)) < make_pair(real(b),imag(b));\n}\n\n// àÏEOÏEpx(xNga,bÌZ)\ndouble dot(P a, P b) { return real(conj(a)*b); }\ndouble cross(P a, P b) { return imag(conj(a)*b); }\ndouble angle(P a, P b) { return arg(conj(a)*b); }\n\n// _pÆ_qÌ¼ñªüðÔ·\nL pointBisector(P p, P q) {\n\tP cen = (p+q)*0.5;\n\treturn L(cen, cen+(q-p)*P(0,1));\n}\n\n// Ê½p`gðC2_p, qðÔüªÅØf·é\nG convexCut(G g, P p, P q){\n\tG res;\n\tint n = g.size();\n\tfor(int i=0;i<n;i++){\n\t\tP A(g[i]), B(g[(i+1)%n]);\n\t\tdouble p1 = cross(q-p,A-p);\n\t\tdouble p2 = cross(q-p,B-p);\n\t\tif(p1 > -EPS) res.push_back(A);\n\t\tif(p1*p2 < -EPS)\n\t\t\tres.push_back(A+cross(q-p,q-A)/cross(q-p,B-A)*(B-A));\n\t}\n\treturn res;\n}\n\n// ½p`gÌÊÏðßé\ndouble polygonArea(G g){\n\tdouble res = 0.0;\n\tfor(int i=0;i<g.size();i++)\n\t\tres += cross(g[i],g[(i+1)%g.size()]);\n\treturn abs(0.5*res);\n}\n\nint main(){\n\tint n, m;\n\twhile(cin>>n>>m){\n\t\tif(!n&&!m) break;\n\t\tG island;\n\t\tvector<P> cas;\n\t\tFOR(i, n){\n\t\t\tint a, b;\n\t\t\tcin>>a>>b;\n\t\t\tisland.push_back(P(a,b));\n\t\t}\n\t\tFOR(i, m){\n\t\t\tint a, b;\n\t\t\tcin>>a>>b;\n\t\t\tcas.push_back(P(a,b));\n\t\t}\n\t\tFOR(i, m){\n\t\t\tG temp = island;\n\t\t\tFOR(j, m){\n\t\t\t\tif(j==i) continue;\n\t\t\t\tL nitou = pointBisector(cas[i],cas[j]);\n\t\t\t\tif(cross(nitou.q-nitou.p, cas[i]-nitou.p)>0){\n\t\t\t\t\ttemp = convexCut(temp, nitou.p, nitou.q);\n\t\t\t\t} else {\n\t\t\t\t\ttemp = convexCut(temp, nitou.q, nitou.p);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdouble s = polygonArea(temp);\n\t\t\tprintf(\"%.6f\\n\", s);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing P = pair<int, int>;\nconst double eps = 1e-8;\nconst ll MOD = 1000000007;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\ntemplate <typename T1, typename T2>\nbool chmax(T1 &a, const T2 &b) {\n  if(a < b) {a = b; return true;}\n  return false;\n}\ntemplate <typename T1, typename T2>\nbool chmin(T1 &a, const T2 &b) {\n  if(a > b) {a = b; return true;}\n  return false;\n}\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream &os, const pair<T1, T2> p) {\n  os << p.first << \":\" << p.second;\n  return os;\n}\ntemplate<class T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n  for(int i=0;i<((int)(v.size()));++i) {\n    if(i) os << \" \";\n    os << v[i];\n  }\n  return os;\n}\nusing Real = double;\nconst Real PI = acos(-1);\nusing Point = complex<Real>;\nnamespace std {\n  bool operator<(const Point& a, const Point& b) {\n    if (a.real() == b.real()) return a.imag() < b.imag();\n    return a.real() < b.real();\n  }\n}\nstruct Line {\nPoint a, b;\nLine() {}\nLine(const Point& a, const Point& b) : a(a), b(b) {}\nfriend ostream& operator<<(ostream& os, const Line& l) {\n  return os << \"[\" << l.a << \",\" << l.b << \"]\";\n}\n};\nstruct Segment : Line {\nSegment() {}\nSegment(const Point& a, const Point& b) : Line(a, b) {}\n};\ninline bool eq(Real a, Real b) { return abs(b - a) < eps; }\nReal radian_to_degree(Real r) {\n  return r * 180.0 / PI;\n}\nReal degree_to_radian(Real d) {\n  return d * PI / 180.0;\n}\nPoint rotate(const Point &p, Real theta) {\n  return p * polar((Real)1.0, theta);\n}\nReal cross(const Point& a, const Point& b) {\n  return a.real() * b.imag() - a.imag() * b.real();\n}\nReal dot(const Point& a, const Point& b) {\n  return a.real() * b.real() + a.imag() * b.imag();\n}\nPoint projection(const Line& l, const Point& p) {\n  Real A = dot(l.b - l.a, p - l.a),\n    B = dot(l.a - l.b, p - l.b);\n  return (A * l.b + B * l.a) / (A + B);\n}\nbool parallel(const Line& l1, const Line& l2) {\n  return eq(cross(l1.a - l1.b, l2.a - l2.b), 0.0);\n}\nbool orthogonal(const Line& l1, const Line& l2) {\n  return eq(dot(l1.a - l1.b, l2.a - l2.b), 0.0);\n}\nconst int COUNTER_CLOCKWISE = 1,\n  CLOCKWISE = -1,\n  ONLINE_BACK = 2,\n  ONLINE_FRONT = -2,\n  ON_SEGMENT = 0;\nint ccw(const Point& a, Point b, Point c) {\n  b = b - a, c = c - a;\n  if (cross(b, c) > eps) return COUNTER_CLOCKWISE;\n  if (cross(b, c) < -eps) return CLOCKWISE;\n  if (dot(b, c) < 0) return ONLINE_BACK;\n  if (norm(b) < norm(c)) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\nbool intersected(const Line& l, const Point& p) {\n  return abs(ccw(l.a, l.b, p)) != 1;\n}\nbool intersected(const Segment& s, const Point& p) {\n  return ccw(s.a, s.b, p) == 0;\n}\nbool intersected(const Line& l, const Segment& s) {\n  return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps;\n}\nbool intersected(const Segment& s1, const Segment& s2) {\n  return ccw(s1.a, s1.b, s2.a) * ccw(s1.a, s1.b, s2.b) <= 0 and\n         ccw(s2.a, s2.b, s1.a) * ccw(s2.a, s2.b, s1.b) <= 0;\n}\nPoint crosspoint(const Line& l1, const Line& l2) {\n  Real A = cross(l2.a - l1.a, l2.b - l1.a),\n    B = cross(l2.b - l1.b, l2.a - l1.b);\n  return (A * l1.b + B * l1.a) / (A + B);\n}\nReal distance(const Line& l, const Point& p) {\n  return abs(p - projection(l, p));\n}\nReal distance(const Segment& s, const Point& p) {\n  Point r = projection(s, p);\n  if (intersected(s, r)) return abs(r - p);\n  return min(abs(s.a - p), abs(s.b - p));\n}\nReal distance(const Line &l, const Segment &s) {\n  if (intersected(l, s)) return 0;\n  return min(distance(l, s.a), distance(l, s.b));\n}\nReal distance(const Segment& s1, const Segment& s2) {\n  if (intersected(s1, s2)) return 0.0;\n  return min({ distance(s1, s2.a), distance(s1, s2.b),\n               distance(s2, s1.a), distance(s2, s1.b) });\n}\nstruct Circle {\nPoint p;\nReal r;\nCircle() {}\nCircle(const Point& p, Real r) : p(p), r(r) {}\n};\nint intersected(Circle c1, Circle c2) {\n  if (c1.r < c2.r) swap(c1, c2);\n  Real d = abs(c1.p - c2.p);\n  if (c1.r + c2.r < d) return 4;\n  if (eq(c1.r + c2.r, d)) return 3;\n  if (c1.r - c2.r < d) return 2;\n  if (eq(c1.r - c2.r, d)) return 1;\n  return 0;\n}\npair<Point,Point> crosspoint(const Circle& c, const Line& l) {\n  Real h = distance(l, c.p);\n  Point p = projection(l, c.p);\n  if (eq(h, c.r)) return { p, p };\n  Point u = l.a - l.b; u /= abs(u);\n  Real d = sqrt(c.r * c.r - h * h);\n  return { p + u * d, p - u * d };\n}\npair<Point,Point> crosspoint(const Circle& c1, const Circle& c2) {\n  Real d = abs(c2.p - c1.p), t = arg(c2.p - c1.p);\n  Real a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n  return { c1.p + polar(c1.r, t + a),\n           c1.p + polar(c1.r, t - a) };\n}\npair<Point,Point> tangent(const Point& p, const Circle& c) {\n  return crosspoint(c, Circle(p, sqrt(norm(p - c.p) - c.r * c.r)));\n};\nvector<Line> common_tangent(const Circle& c1, const Circle& c2) {\n  vector<Line> lines;\n  Point u = c2.p - c1.p;\n  Real d = abs(u);\n  if (eq(d, 0.0)) return lines;\n  u /= d;\n  for (Real s : { -1, 1 }) {\n    Real h = (c1.r + s * c2.r) / d;\n    if (eq(abs(h), 1.0)) {\n      lines.emplace_back(\n        c1.p + u * h * c1.r,\n        c1.p + u * h * c1.r + rotate(u, PI / 2.0));\n    } else if (abs(h) < 1) {\n      Real a = acos(h);\n      lines.emplace_back(\n        c1.p + u * polar(c1.r, a),\n        c2.p - s * u * polar(c2.r, a));\n      lines.emplace_back(\n        c1.p + u * polar(c1.r, -a),\n        c2.p - s * u * polar(c2.r, -a));\n    }\n  }\n  return lines;\n}\nusing Polygon = vector<Point>;\nReal area(const Polygon& U) {\n  Real area = 0;\n  for (int i = 0; i < U.size(); ++i) {\n    area += cross(U[i], U[(i + 1) % U.size()]);\n  }\n  return area / 2.0;\n}\nbool is_convex(const Polygon &U) {\n  int n = U.size();\n  for (int i = 0; i < n; ++i) {\n    if (ccw(U[i], U[(i + 1) % n], U[(i + 2) % n]) == -1) return false;\n  }\n  return true;\n}\nconst int OUT = 0,\n  ON = 1,\n  IN = 2;\nint contains(const Polygon &U, const Point &p) {\n  int in = 0;\n  for (int i = 0; i < U.size(); ++i) {\n    Point a = U[i] - p, b = U[(i + 1) % U.size()] - p;\n    if (cross(a, b) == 0 and dot(a, b) <= 0) return ON;\n    if (a.imag() > b.imag()) swap(a, b);\n    if (a.imag() <= 0 and 0 < b.imag() and cross(a, b) < 0) in ^= 1;\n  }\n  return in ? IN : OUT;\n}\nvector<Point> convex_hull(vector<Point>& p, bool includeOnLine = false) {\n  int n = p.size(), k = 0;\n  if (n <= 2) return p;\n  sort(p.begin(), p.end(), [](Point& a, Point& b) {\n    if (a.real() == b.real()) return a.imag() < b.imag();\n    return a.real() < b.real();\n  });\n  vector<Point> ch(n * 2);\n  const Real BOUND = includeOnLine ? -eps : eps;\n  for (int i = 0; i < n; ch[k++] = p[i++]) {\n    while (k >= 2 and cross(ch[k-1] - ch[k-2], p[i] - ch[k-1]) < BOUND) --k;\n  }\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = p[i--]) {\n    while (k >= t and cross(ch[k-1] - ch[k-2], p[i] - ch[k-1]) < BOUND) --k;\n  }\n  ch.resize(k-1);\n  return ch;\n}\nReal convex_diameter(const Polygon &U) {\n  int n = U.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (U[i].imag() > U[is].imag()) is = i;\n    if (U[i].imag() < U[js].imag()) js = i;\n  }\n  Real maxnorm = norm(U[is] - U[js]);\n  int i = is, j = js;\n  do {\n    if (cross(U[(i+1) % n] - U[i], U[(j+1) % n] - U[j]) >= 0) {\n      j = (j+1) % n;\n    } else {\n      i = (i+1) % n;\n    }\n    if (norm(U[i] - U[j]) > maxnorm) {\n      maxnorm = norm(U[i] - U[j]);\n    }\n  } while (i != is or j != js);\n  return sqrt(maxnorm);\n}\nPolygon convex_cut(const Polygon& U, const Line& l) {\n  Polygon ret;\n  for (int i = 0; i < U.size(); ++i) {\n    Point now = U[i], nxt = U[(i + 1) % U.size()];\n    if (ccw(l.a, l.b, now) != -1) ret.push_back(now);\n    if (ccw(l.a, l.b, now) * ccw(l.a, l.b, nxt) == -1) {\n      ret.push_back(crosspoint(Line{ now, nxt }, l));\n    }\n  }\n  return ret;\n}\nbool solve() {\n  int n, m; cin >> n >> m;\n  if(n == 0) return false;\n  Polygon land;\n  for(int i=0;i<(n);++i) {\n    int x, y; cin >> x >> y;\n    land.emplace_back(Point(x, y));\n  }\n  vector<Point> c;\n  for(int i=0;i<(m);++i) {\n    int x, y; cin >> x >> y;\n    c.emplace_back(Point(x, y));\n  }\n  double pi = acos(-1);\n  vector<double> ans(m);\n  for(int i=0;i<(m);++i) {\n    Polygon now = land;\n    for(int j=0;j<(m);++j) {\n      if(i == j) continue;\n      Point p = (c[i] + c[j]) / 2.0;\n      Point d = (c[j] - c[i]);\n      d *= complex<double>(cos(pi/2.0), sin(pi/2.0));\n      Line l(p, p+d);\n      now = convex_cut(now, l);\n    }\n    ans[i] = area(now);\n  }\n  for(int i=0;i<(m);++i) {\n    cout << ans[i] << endl;\n  }\n  return true;\n}\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  while(solve()) {}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#ifndef LOCAL\n#define debug(x) ;\n#else\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\ntemplate <typename T1, typename T2>\nostream &operator<<(ostream &out, const pair<T1, T2> &p) {\n  out << \"{\" << p.first << \", \" << p.second << \"}\";\n  return out;\n}\n\ntemplate <typename T>\nostream &operator<<(ostream &out, const vector<T> &v) {\n  out << '{';\n  for (const T &item : v) out << item << \", \";\n  out << \"\\b\\b}\";\n  return out;\n}\n#endif\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 200010\n\ntypedef double P_type; //座標(integer or real)\ntypedef double G_real; //実数の戻り値(float or double or long double)\ntypedef complex<P_type> P;\nconst G_real P_eps = 1e-8; //整数の時はゼロ\n\nnamespace std{\n  template<class T> bool operator<(const complex<T> &a, const complex<T> &b){\n    return abs(a.real() - b.real()) < P_eps ? a.imag() + P_eps < b.imag() : a.real() + P_eps < b.real();\n  }\n};\n\nP rotate(P p, double theta){\n  return p * P(cos(theta), sin(theta));\n}\n\n//内積\nP_type dot(P a, P b) {\n  return (a * conj(b)).real();\n}\n\n//外積\nP_type cross(P a, P b) {\n  return (conj(a) * b).imag();\n}\n\n//反時計回り\nint ccw(P a, P b, P c){\n  if(cross(b-a, c-a) > P_eps) return 1; //COUNTER_CLOCKWISE(center:a)\n  if(cross(b-a, c-a) < -P_eps) return -1; //CLOCKWISE(center:a)\n  if(dot(b-a, c-a) < -P_eps) return -2; //c -> a -> b\n  if(dot(a-b, c-b) < -P_eps) return 2; //a -> b -> c\n  return 0; //a -> c -> b\n}\n\n/* ベクトルa, bの角度 */\n// ({0, 1}, {1, 0}) => 90, ({0, 1}, {-1, -1}) => -135\nG_real degree(P a, P b) {\n  return atan2(cross(b, a), dot(b, a)) / M_PI * 180;\n}\n\n/* 線分abと点cの距離 */\nG_real distanceSP(P a, P b, P c) {\n  if ( dot(b-a, c-a) < P_eps ) return abs(c-a);\n  if ( dot(a-b, c-b) < P_eps ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\n/* 直線abと点cの距離 */\nG_real distanceLP(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n\n/* 円の点包含判定 */\nbool isContainedCP(P c, P_type r, P p){\n  return abs(c-p) < r - P_eps; //円周上を含まない\n  //return abs(c-p) <= r + P_eps; //円周上を含む\n}\n\n/* 円の円包含判定 (円1の内部に円2が存在するか) */\nbool isContainedCC(P c1, P_type r1, P c2, P_type r2) {\n  return abs(c1 - c2) + r2 < r1 - P_eps; //接する場合を含まない\n  //return abs(c1 - c2) + r2 <= r1 + P_eps; //接する場合を含まない\n}\n\n/* 直線交差判定 */\nbool isIntersectedLL(P a1, P a2, P b1, P b2){\n  return abs(cross(a1-a2, b1-b2)) > P_eps;\n}\n\n/* 線分交差判定 */\nbool isIntersectedSS(P a1, P a2, P b1, P b2){\n\n  //線分a と 直線b\n  int a = ccw(b1, b2, a1);\n  int b = ccw(b1, b2, a2);\n\n  //線分b と 直線a\n  int c = ccw(a1, a2, b1);\n  int d = ccw(a1, a2, b2);\n\n  return a * b <= 0 && c * d <= 0; // T字を除く時は (** < 0)\n}\n\n/* 直線A線分B交差判定 */\nbool isIntersectedLS(P a1, P a2, P b1, P b2){\n  int a = ccw(a1, a2, b1);\n  int b = ccw(a1, a2, b2);\n\n  // 直線上のとき a or b = 0 or -2 or 2\n  return (a % 2) * (b % 2) <= 0; // T字を除く時は (** < 0)\n}\n\n/* 円交差判定 */\nbool isIntersectedCC(P c1, G_real r1, P c2, P_type r2){\n  G_real dist = abs(c1 - c2);\n\n  return abs(r1 - r2) <= dist + P_eps && dist - P_eps <= r1 + r2; //外接内接を含む\n  //return abs(r1 - r2) < dist - P_eps && dist + P_eps < r1 + r2; //外接内接を除く\n}\n\n/* 円直線交差判定 */\nbool isIntersectedCL(P c, G_real r, P a1, P a2){\n  return distanceLP(a1, a2, c) <= r + P_eps; //接する場合を含まない場合 < r - P_eps\n}\n\n/* 円線分交差判定 */\nbool isIntersectedCS(P c, P_type r, P a1, P a2){\n  return (!isContainedCP(c, r, a1) || !isContainedCP(c, r, a2)) &&\n    distanceLP(a1, a2, c) <= r + P_eps; //接する場合を含まない場合 < r - P_eps\n}\n\n/* 直線/線分交点 */\nvector<P> getCrosspointLL(P a1, P a2, P b1, P b2) {\n  //assert(isIntersectedLL(a1, a2, b1, b2));\n  P a = a2 - a1;\n  P b = b2 - b1;\n  return { a1 + a * cross(b, b1 - a1) / cross(b, a) };\n}\n\nvector<P> getCrosspointSS(P a1, P a2, P b1, P b2){\n  //assert(isIntersectedSS(a1, a2, b1, b2));\n  return getCrosspointLL(a1, a2, b1, b2);\n}\n\n/* 円交点 */\nvector<P> getCrosspointCC(P c1, P_type r1, P c2, P_type r2){\n  //assert(isIntersectedCC(c1, r1, c2, r2));\n\n  P_type dist = abs(c1 - c2);\n  P_type a = acos((r1*r1 + dist*dist - r2*r2) / (2 * r1 * dist));\n  return {c1 + polar(r1, arg(c2 - c1) + a), c1 + polar(r1, arg(c2 - c1) - a)};\n}\n\n/* 円直線交点 */\nvector<P> getCrosspointCL(P c, P_type r, P a1, P a2){\n  if(!isIntersectedCL(c, r, a1, a2)) return {};\n\n  P base1 = a2 - a1;\n  P proj = a1 + base1 * dot(c - a1, base1) / norm(base1); //射影\n  P e = (a2 - a1) / abs(a2 - a1);\n  P base2 = sqrt(r*r - norm(proj - c));\n  return {proj - e*base2, proj + e*base2};\n}\n\n/* 円線分交点 */\nvector<P> getCrosspointCS(P c, P_type r, P a1, P a2){\n  if(!isIntersectedCS(c, r, a1, a2)) return {};\n\n  vector<P> res;\n  for(P p : getCrosspointCL(c, r, a1, a2))\n    if(dot(a1-p, a2-p) <= P_eps) res.push_back(p);\n  return res;\n}\n\n/* 多角形-点包含 */\nbool isContainedPolyP(vector<P> &g, P p){\n  int n = g.size();\n  bool f = false;\n  for(int i=0; i<n; i++){\n    P a = g[i] - p, b = g[(i+1)%n] - p;\n    if(abs(cross(a,b)) < P_eps && dot(a,b) < P_eps) return true; //辺上\n    if(a.imag() > b.imag()) swap(a,b);\n    if(a.imag() < P_eps && P_eps < b.imag() && cross(a,b) > P_eps) f = !f;\n  }\n  return f; //内部 or 外部\n}\n\n/* 射影(直線abとpからの垂線との交点) */\nP getProject(P a, P b, P p){\n  P base = b - a;\n  return a + base * dot(p - a, base) / norm(base);\n}\n\n/* 反射(直線abを対称軸としたpの線対称の位置) */\nP getReflection(P a, P b, P p){\n  return p + (getProject(a, b, p) - p) * (P_type)2.0;\n}\n\n/* 多角形面積 */\nG_real getAreaPoly(vector<P> &g){\n  P_type res = 0;\n  for(int i=0; i<(int)g.size(); i++)\n    res += cross(g[i], g[(i+1)%g.size()]);\n  return abs(res / 2.0);\n}\n\n/* 円-直線(中心との三角形) 共通面積 */\nG_real getAreaCS(P c, P_type r, P a1, P a2){\n  if(min({abs(a1 - a2), abs(c - a1), abs(c - a2), r}) <= P_eps) return 0;\n\n  G_real res = 0;\n  vector<P> vec = {a1};\n  for(auto p : getCrosspointCS(c, r, a1, a2)) vec.push_back(p);\n  vec.push_back(a2);\n\n  for(int i=0;i+1<(int)vec.size();i++){\n    P p1 = vec[i] - c, p2 = vec[i+1] - c;\n    if(max(abs(p1), abs(p2)) <= r + P_eps)\n      res += cross(p1, p2) / 2.0;\n    else\n      res += r*r*arg(conj(p1)*p2) / 2.0;\n  }\n\n  return res;\n}\n\n/* 円-多角形共通面積 */\nG_real getAreaPolyC(vector<P> &g, P c, P_type r){\n  G_real res = 0;\n  for(int i=0;i<(int)g.size();i++)\n    res += getAreaCS(c, r, g[i], g[(i+1)%g.size()]);\n  return abs(res);\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=CGL_4_C\n/* 凸多角形の切断 */\n// 直線Aで切断し、a1からa2方向に見たときに直線Aの左側にできる凸多角形を返す\nvector<P> convexCut(const vector<P> &g, P a1, P a2) {\n  vector<P> res;\n  P prev = *g.rbegin();\n  for(P now : g) {\n    if(ccw(a1, a2, prev) != -1) res.push_back(prev);\n    int c = ccw(a1, a2, prev) * ccw(a1, a2, now);\n    if(-4 < c && c < 0) {\n      res.push_back(getCrosspointLL(prev, now, a1, a2)[0]);\n    }\n    prev = now;\n  }\n  return res;\n}\n\n\nbool solve() {\n  int N, M;\n  vector<P> a, b;\n\n  cin >> N >> M;\n\n  if (N == 0) return false;\n\n  for (int i=0; i<N; i++) {\n    int x, y;\n    cin >> x >> y;\n    a.push_back(P(x, y));\n  }\n\n  for (int i=0; i<M; i++) {\n    int x, y;\n    cin >> x >> y;\n    b.push_back(P(x, y));\n  }\n\n  for (int i=0; i<M; i++) {\n    auto g = a;\n\n    for (int j=0; j<M; j++) {\n      if (i == j) continue;\n\n      P t = (b[i] - b[j]) / 2.0 + b[j];\n      P s = rotate(b[i] - b[j], M_PI/2) + t;\n\n      if (ccw(s, t, b[i]) == -1) {\n        g = convexCut(g, t, s);\n      } else {\n        g = convexCut(g, s, t);\n      }\n    }\n\n    printf(\"%.8lf\\n\", getAreaPoly(g));\n  }\n\n  return true;\n}\n\nint main(){\n\n  while(solve());\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-5;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\nint sign(double r){ return (r < -EPS) ? -1 : (r > EPS) ? 1 : 0; }\nbool eq(double a, double b){ return abs(b - a) < EPS; }\n\nstruct Point{\n  double x, y;\n  Point() {}\n  Point(double x, double y) : x(x), y(y) {}\n  Point operator+(const Point& b) const { return Point(x + b.x, y + b.y); }\n  Point operator-(const Point& b) const { return Point(x - b.x, y - b.y); }\n  Point operator*(const double b) const { return Point(x * b, y * b); }\n  Point operator*(const Point& b) const { return Point(x * b.x - y * b.y, x * b.y + y * b.x); }\n  Point operator/(const double b) const { return Point(x / b, y / b); }\n  bool operator< (const Point& b) const { return x != b.x ? x < b.x : y < b.y; }\n  bool operator==(const Point& b) const { return eq(x, b.x) && eq(y, b.y); }\n  double norm(){ return x * x + y * y; }\n  double arg(){ return atan2(x, y); }\n  double abs(){ return sqrt(norm()); }\n  Point rotate(double theta){ return Point(cos(theta) * x - sin(theta) * y, sin(theta) * x + cos(theta) * y); }\n  Point rotate90(){ return Point(-y, x); }\n};\n\nostream& operator<<(ostream& os, Point& p){ return os<<\"(\"<<p.x<<\",\"<<p.y<<\")\"; }\nistream& operator>>(istream& is, Point& a){ return is>>a.x>>a.y; }\ndouble dot(const Point& a, const Point& b){ return a.x * b.x + a.y * b.y; }\ndouble cross(const Point& a, const Point& b){ return a.x * b.y - a.y * b.x; }\nPoint polor(double rho, double theta){ return Point(rho * cos(theta), rho * sin(theta)); }\n\nstruct Line : public vector<Point> {\n  Line(const Point& a, const Point& b) {\n    push_back(a); push_back(b);\n  }\n  Point vector() const {\n    return back() - front();\n  }\n};\nstruct Circle : Point {\n  double r;\n  Circle(Point p, double r) : Point(p), r(r) { }\n};\ntypedef vector<Point> Polygon;\nPoint curr(const Polygon& a, int x){ return a[x]; }\nPoint next(const Polygon& a, int x){ return a[(x + 1) % a.size()]; }\nPoint prev(const Polygon& a, int x){ return a[(x - 1 + a.size()) % a.size()]; }\n\n//a->b->c\nint ccw(Point a, Point b, Point c) {\n  b = b - a; c = c - a;\n  if (cross(b, c) > EPS)   return +1; // 反時計回り\n  if (cross(b, c) < -EPS)   return -1; // 時計回り\n  if (dot(b, c) < 0)     return +2; // c--a--b の順番で一直線上\n  if (b.norm() < c.norm()) return -2; // a--b--c の順番で一直線上\n  return 0;                         // a--c--b の順番で一直線上\n}\n// 二直線の交差判定\nbool intersectLL(const Line& l, const Line& m) {\n  return abs(cross(l.vector(), m.vector())) > EPS || // 傾きが異なる\n         abs(cross(l.vector(), m[0] - l[0])) < EPS;   // 同じ直線である\n}\n// 直線と線分の交差判定\nbool intersectLS(const Line& l, const Line& s) {\n  return cross(l.vector(), s[0] - l[0]) * cross(l.vector(), s[1] - l[0]) < EPS; //直線lについて、線分sの端点が異なる側にある\n}\n// 直線と点の交差判定\nbool intersectLP(const Line& l, const Point& p) {\n  return abs(ccw(l[0], l[1], p)) != 1;\n}\n// 二つの線分の交差判定\nbool intersectSS(const Line& s, const Line& t) {\n  return ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n         ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\n// 線分と点の交差判定\nbool intersectSP(const Line& s, const Point& p) {\n  return ccw(s[0], s[1], p) == 0;\n}\n// 円と点の交差判定(EPS注意)\nbool intersectCP(const Circle& c, const Point& p){\n  return (c - p).abs() < c.r + EPS;\n}\n// 二つの円の交差判定(EPS注意)\nbool intersectCC(const Circle& c, const Circle& d){\n  return (c - d).abs() < c.r + d.r + EPS && (c - d).abs() > abs(c.r - d.r) - EPS;\n}\n// 射影\nPoint projection(const Line& l, const Point& p){\n  double t = dot(p - l[0], l.vector()) / l.vector().norm();\n  return l[0] + l.vector() * t;\n}\n// 反射\nPoint reflection(const Line& l, const Point& p){\n  return p + (projection(l, p) - p) * 2;\n}\n// 直線と点の距離\ndouble distanceLP(const Line& l, const Point& p){\n  return (p - projection(l, p)).abs();\n}\n// 二直線の距離\ndouble distanceLL(const Line& l, const Line& m){\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\n// 直線と線分の距離\ndouble distanceLS(const Line& l, const Line& s){\n  if(intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\n// 線分と点の距離\ndouble distanceSP(const Line& s, const Point& p){\n  const Point r = projection(s, p);\n  if(intersectSP(s, r)) return (r - p).abs(); //垂線が線分に交わるとき\n  return min((s[0] - p).abs(), (s[1] - p).abs());\n}\n// 二つの線分の距離\ndouble distanceSS(const Line& s, const Line& t){\n  if(intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n// 二直線の交点\nPoint crosspointLL(const Line& l, const Line& m){\n  double d = cross(m.vector(), l.vector());\n  if(abs(d) < EPS) assert(false); // 直線が交わらない\n  return l[0] + l.vector() * cross(m.vector(), m[1] - l[0]) * (1.0 / d);\n}\n\nPolygon convex_cut(const Polygon& P, const Line& l){\n  Polygon Q;\n  REP(i, P.size()){\n    Point A = curr(P, i), B = next(P, i);\n    if(ccw(l[0], l[1], A) != -1) Q.push_back(A); //Aが直線lの右側でない\n    if(abs(cross(l.vector(), B - A)) > EPS && intersectLS(l, Line(A, B)))\n      Q.push_back(crosspointLL(l, Line(A, B)));\n  }\n  return Q;\n}\nLine median(const Point& a, const Point& b){\n  Point mid((a.x + b.x) / 2.0, (a.y + b.y) / 2.0);\n  Point vec = (mid - a).rotate90();\n  return Line(mid, mid + vec);\n}\n\ndouble area(const Polygon& P) {\n  double A = 0;\n  REP(i, P.size()){\n    A += cross(curr(P, i), next(P, i));\n  }\n  return A / 2.0;\n}\nint main(){\n  int N, M;\n  while(cin>>N>>M){\n    Polygon island(N);\n    REP(i, N) cin>>island[i];\n    vector<Point> castle(M);\n    REP(i, M) cin>>castle[i];\n    REP(i, M){\n      Polygon land = island;\n      REP(j, M) if(i != j){\n        land = convex_cut(land, median(castle[i], castle[j]));\n      }\n      printf(\"%.6lf\\n\", area(land));\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <vector>\n#include <valarray>\n#include <array>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <random>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\ntypedef long double R;\ntypedef complex<R> P;\n\nconst R EPS = 1e-10;\nconst R PI = acos((R)(-1));\n\n/*\n -1 -> neg\n  0 -> near 0\n  1 -> pos\n  */\nint sgn(R a) {\n    if (a < -EPS) return -1;\n    if (a > EPS) return 1;\n    return 0;\n}\n\n/*\n -1 -> a > b\n 0 -> a near b\n 1 -> a < b\n */\nint sgn(R a, R b) {\n    return sgn(b-a);\n}\n\nbool near(P a, P b) {\n    return !sgn(abs(a-b));\n}\n\nbool lessP(const P &l, const P &r) {\n    if (sgn(l.real(), r.real())) return l.real() < r.real();\n    if (sgn(l.imag(), r.imag())) return l.imag() < r.imag();\n    return false;\n}\n\nR cross(P a, P b) { return a.real()*b.imag() - a.imag()*b.real(); }\nR dot(P a, P b) { return a.real()*b.real() + a.imag()*b.imag(); }\n\n/* 1->cclock\n  -1->clock\n   0->on\n   2->back\n  -2->front\n  */\nint ccw(P a, P b, P c) {\n    assert(!near(a, b));\n    if (near(a, c) || near(b, c)) return 0;\n    int s = sgn(cross(b-a, c-a));\n    if (s) return s;\n    if (dot(b-a, c-a) < 0) return 2;\n    if (dot(a-b, c-b) < 0) return -2;\n    return 0;\n}\n\nR ssqrt(R d) {\n    d = max<R>(0, d);\n    return sqrt(d);\n}\n\nR sacos(R d) {\n    d = max<R>(-1, d);\n    d = min<R>(1, d);\n    return acos(d);\n}\n\nstruct L {\n    P x, y;\n    L() {};\n    L(P x, P y) :x(x), y(y) {};\n};\n\nP vec(const L &l) {\n    return l.y - l.x;\n}\n\nR abs(const L &l) {\n    return abs(vec(l));\n}\n\nint crossLL(const L &l, const L &m, P &r) {\n    L mm = L(m.x - l.x, m.y - l.x);\n    mm.x *= polar<R>(1.0, -arg(vec(l)));\n    mm.y *= polar<R>(1.0, -arg(vec(l)));\n    if (sgn(vec(mm).imag()) == 0) {\n        r = l.x;\n        if (sgn(mm.x.imag()) == 0) return -1;\n        return 0;\n    }\n    r = mm.x - vec(mm) * (mm.x.imag() / vec(mm).imag());\n    r *= polar<R>(1.0, arg(vec(l)));\n    r += l.x;\n    return 1;\n}\n\ntypedef vector<P> Pol;\n\n\nP cu(const Pol &p, int i) { \n    int s = p.size();\n    return p[(i%s+s)%s];\n};\n\nR area(const Pol &p) {\n    R u = 0;\n    for (int i = 0; i < (int)p.size(); i++) {\n        u += cross(cu(p,i), cu(p,i+1));\n    }\n    return abs(u)/2;\n}\n\nPol convex_cut(const Pol &p, const L &l) {\n    Pol q;\n    for (int i = 0; i < (int)p.size(); i++) {\n        P a = cu(p, i), b = cu(p, i+1);\n        if (ccw(l.x, l.y, a) != -1) q.push_back(a);\n        if (ccw(l.x, l.y, a)*ccw(l.x, l.y, b) < 0) {\n            P p;\n            crossLL(l, L(a, b), p);\n            q.push_back(p);\n        }\n    }\n    return q;\n}\n\nbool solve() {\n    int n, m;\n    cin >> n >> m;\n    if (!n) return false;\n    Pol p;\n    for (int i = 0; i < n; i++) {\n        R x, y;\n        cin >> x >> y;\n        p.push_back(P(x, y));\n    }\n    P cm[11];\n    for (int i = 0; i < m; i++) {\n        R x, y;\n        cin >> x >> y;\n        cm[i] = P(x, y);\n    }\n\n\n    for (int i = 0; i < m; i++) {\n        Pol pp = p;\n        for (int j = 0; j < m; j++) {\n            if (i == j) continue;\n            P md = (cm[i]+cm[j])/(R)2.0;\n            P md2 = md + (cm[j]-cm[i])*P(0, 1);\n            pp = convex_cut(pp, L(md, md2));\n        }\n        printf(\"%.20Lf\\n\", area(pp));\n    }\n    return true;\n}\n\nint main() {\n    while (solve()) {}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<cmath>\n#include<vector>\n#include<cstdlib>\n#include<cassert>\n#include<map>\n#include<iomanip>\n#define _A_ true\n#define EPS 1e-10\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\nusing namespace std;\nclass Point{\npublic:\n  double x,y;\n  Point(double x =0,double y=0):x(x),y(y){}\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(x*a,y*a);}\n  Point operator / (double a){return Point(x/a,y/a);} //もし悪を使うなら要確認\n \n  double norm() {return x*x+y*y;}\n  double abs() {return sqrt(norm());}\n \n  bool operator < (const Point &p) const{\n    return x != p.x ? x < p.x : y < p.y; \n  }\n \n  bool operator == (const Point &p) const{\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\ntypedef Point Point;\nstruct Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p = Point(),Point pp = Point()):p1(p),p2(pp){}\n};\n \ntypedef vector<Point> Polygon;\ntypedef Segment Line;\n \ndouble norm(Point p){\n  return p.x*p.x+p.y*p.y;\n}\n \ndouble abs(Point p){\n  return sqrt(norm(p));\n}\n \nPoint polar(double a,double rad){\n  return Point(a*cos(rad),a*sin(rad));\n}\n \ndouble args(Point p){\n  return atan2(p.y,p.x);\n}\n \ndouble dot(Point a,Point b){\n  return a.x*b.x+a.y*b.y;\n}\n \ndouble cross(Point a,Point b){\n  return a.x*b.y-b.x*a.y;\n}\n \nPoint project(Segment s,Point p){\n  Point base = s.p2 - s.p1;\n  double t = dot(p-s.p1,base)/base.norm();\n  return s.p1+base*t;\n}\n \nPoint reflect (Segment s, Point p){\n  return p + (project(s,p)-p)*2.0;\n}\n \nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CLOCKWISE;\n  if(dot(a,b) < -EPS) return ONLINE_BACK;\n  if(a.norm() < b.norm() ) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n \nbool isIntersect(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <= 0 && ccw(p3,p4,p1) * ccw(p3,p4,p2) <= 0 );\n}\n \nbool isIntersect(Segment s1,Segment s2){\n  return isIntersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n/*\nPoint getCrossPoint(Segment s1,Segment s2){\n  assert(isIntersect(s1,s2));\n  P base = s2.p2 - s2.p1;\n  double d1 = abs(cross(base,s1.p1-s2.p1));\n  double d2 = abs(cross(base,s1.p2-s2.p1));\n  double t = d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n*/\n \nPoint getCrossPointLines( Line s1, Line s2){\n    Point a = s1.p2 - s1.p1;\n    Point base = Point(s2.p2.x - s2.p1.x,s2.p2.y - s2.p1.y);\n    return s1.p1 + a * cross(base, s2.p1 - s1.p1)/cross(base, a);\n}\n \nPolygon cutPolygon( Polygon P, Line l ){\n    Polygon u;\n    \n    for ( int i = 0; i < P.size(); i++ ){\n        Point a = P[i], b = P[(i+1)%P.size()];\n        if ( ccw(l.p1, l.p2, a) != CLOCKWISE ) u.push_back(a);\n        if ( ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) == -1 ){\n      u.push_back(getCrossPointLines(Segment(a, b), l));\n      \n        }\n    }\n   \n    return u;\n}\n \n \n \nLine CreateLine(Point p,Point pp){\n  Point mid = (p+pp)/2;\n \n  Point sl = pp-p;//原点に5\n  double rad = args(sl);\n  Point ap = polar(abs(sl),rad+M_PI/2)+mid;\n  //ap.x = abs(sl)*cos(rad+M_PI/2)+mid.x;\n  //ap.y = abs(sl)*sin(rad+M_PI/2)+mid.y;\n  return Line(mid,ap);\n}\n \n \ndouble AreaCalc(Polygon p){\n  double area = 0;\n  p.push_back(p[0]);\n  for(int i=0;i<p.size()-1;i++){\n    area+=cross(p[i],p[i+1]);\n  }\n  return abs(area/2);\n}\n \n \n \n \n \nint main(){\n  int N,M;\n  while(cin >> N >> M,N|M){\n  \n  vector<Point> l(N);\n  vector<Point> C(M);\n  for(int i=0;i<N;i++)\n    {\n      cin >> l[i].x >> l[i].y;\n      l[i].x += 500,l[i].y += 500;\n    }\n  for(int i=0;i<M;i++)\n    {\n      cin >> C[i].x >> C[i].y;\n      C[i].x += 500,C[i].y += 500;\n    }\n  for(int i=0;i<M;i++)\n    {\n      Polygon poly; \n      for(int j=0;j<N;j++)\n\tpoly.push_back(l[j]);\n      for(int j=0;j<M;j++)\n\t{\n\t  if(j == i)\n\t    continue;\n\t  poly = cutPolygon(poly,CreateLine(C[i],C[j]));\n\t}\n      cout << setiosflags(ios::fixed) << setprecision(1) << AreaCalc(poly) << endl;\n\n    }  \n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);++i)\n#define rep2(i,a,b) for (int i=(a);i<(b);++i)\n#define rrep(i,n) for (int i=(n)-1;i>=0;--i)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;--i)\n#define chmin(a,b) (a)=min((a),(b));\n#define chmax(a,b) (a)=max((a),(b));\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) cout<<(#v)<<\":\";for(auto(x):(v)){cout<<\" \"<<(x);}cout<<endl;\n#define printVS(vs) cout<<(#vs)<<\":\"<<endl;for(auto(s):(vs)){cout<<(s)<< endl;}\n#define printVV(vv) cout<<(#vv)<<\":\"<<endl;for(auto(v):(vv)){for(auto(x):(v)){cout<<\" \"<<(x);}cout<<endl;}\n#define printP(p) cout<<(#p)<<(p).first<<\" \"<<(p).second<<endl;\n#define printVP(vp) cout<<(#vp)<<\":\"<<endl;for(auto(p):(vp)){cout<<(p).first<<\" \"<<(p).second<<endl;}\n\ninline void output(){ cout << endl; }\ntemplate<typename First, typename... Rest>\ninline void output(const First& first, const Rest&... rest) {\n    cout << first << \" \"; output(rest...);\n}\n\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing TUPLE = tuple<int, int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\nusing Graph = vector<vector<int>>;\n\ntypedef complex<double> P;\ntypedef vector<P> G;\n#define here(g, i) g[i]\n#define next(g, i) g[(i + 1) % g.size()]\n#define prev(g, i) g[(i - 1 + g.size()) % g.size()]\nconst double EPS = 1e-10;\nconst double INF = 1e12;\nconst double PI = acos(-1);\n\nstruct L {\n    P a, b, v;\n    L(){}\n    L(P _a, P _b) : a(_a), b(_b), v(b - a) {}\n    L(double _ax, double _ay, double _bx, double _by) : L(P(_ax, _ay), P(_bx, _by)) {}\n    void reverse() {\n        swap(a, b); v = b - a;\n    }\n};\n\ndouble cross(P a, P b) {\n    return imag(conj(a) * b);\n}\n\ndouble dot(P a, P b) {\n    return real(conj(a) * b);\n}\n\n// signed!!!!!!!!!\ndouble areaG(G g) {\n    int n = g.size();\n    double ret = 0;\n    rep(i, n) {\n        ret += cross(here(g, i), next(g, i));\n    }\n    return ret / 2;\n}\n\nP readP() {\n    double x, y;\n    cin >> x >> y;\n    return P(x, y);\n}\n\nG readG(int n) {\n    // int n;\n    // cin >> n;\n    G g(n);\n    rep(i, n) g[i] = readP();\n    return g;\n}\n\nL PerpendicularBisector(P p, P q) {\n    P c = (p + q) / 2.;\n    P d = (q - p) / 2.;\n    P h = d * P(0, 1);\n    return L(c + h, c - h);\n}\n\nint ccw(P p0, P p1, P p2) {\n    p1 -= p0; p2 -= p0;\n    if (cross(p1, p2) > 0) return +1;       // counter-clockwise\n    if (cross(p1, p2) < 0) return -1;       // clockwise\n    if (dot(p1, p2) < 0) return +2;         // p2 -- p0 -- p1\n    if (norm(p1) < norm(p2)) return -2;     // p0 -- p1 -- p2\n    return 0;                               // p0 -- p2 -- p1\n}\n\nP crosspointLL(L l1, L l2) {\n    return l1.a + l1.v * cross(l2.v, l2.a - l1.a) / cross(l2.v, l1.v);\n}\n\nG convex_cut(G g, L l) {\n    G h;\n    rep(i, (int)g.size()) {\n        P p = here(g, i), q = next(g, i);\n        if (ccw(p, q, l.a) == 0 && ccw(p, q, l.b) == 0) {\n            if (ccw(p, l.b, l.a) == 0) return g;    // p -- l.a -- l.b -- q\n            else return G{};                        // p -- l.b -- l.a -- q\n        }\n        if (ccw(l.a, l.b, p) != -1) h.emplace_back(p);\n        if (ccw(l.a, l.b, p) * ccw(l.a, l.b, q) < 0)\n        h.emplace_back(crosspointLL(L(p, q), l));\n    }\n    return h;\n}\n\nvector<G> Voronoi(G g, vector<P> p) {\n    vector<G> ret;\n    rep(i, p.size()) {\n        G h = g;\n        rep(j, p.size()) {\n            if (i == j) continue;\n            L l = PerpendicularBisector(p[i], p[j]);\n            if (ccw(l.a, l.b, p[i]) == -1) l.reverse();\n            h = convex_cut(h, l);\n        }\n        ret.emplace_back(h);\n    }\n    return ret;\n}\n\nmain() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int n, m;\n    while (cin >> n >> m, n) {\n        G g = readG(n);\n        vector<P> p(m);\n        rep(i, m) p[i] = readP();\n\n        auto vg = Voronoi(g, p);\n        rep(i, vg.size()) {\n            cout << fixed << setprecision(10) << abs(areaG(vg[i])) << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n    \n    const double EPS = 1e-8;\n\n    struct Point {\n        double x, y;\n        Point() {}\n        Point(double x, double y) : x(x), y(y) {}\n        Point operator+(const Point& p) const { return Point(x + p.x, y + p.y); }\n        Point operator-(const Point& p) const { return Point(x - p.x, y - p.y); }\n        Point operator*(double k) const { return Point(k * x, k * y); }\n        Point operator/(double k) const { return Point(x / k, y / k); }\n    };\n    double dot(const Point& a, const Point& b) { return a.x * b.x + a.y * b.y; }\n    double cross(const Point& a, const Point& b) { return a.x * b.y - a.y * b.x; }\n    double norm(const Point& a) { return sqrt(dot(a, a)); }\n    Point rot90(const Point& p) { return Point(-p.y, p.x); } // 反時計回りに90度回転 \n    double angle(const Point& a) { return atan2(a.y, a.x); } // x軸を反時計回りに何ラジアン回転させれば点aに乗るか\n    ostream& operator<<(ostream& os, const Point& p) { return os << \"(\" << p.x << \",\" << p.y << \")\"; }\n    istream& operator>>(istream& is, Point& p) { return is >> p.x >> p.y; }\n\n    int ccw(Point a, Point b, Point c){\n        b = b - a; c = c - a;\n        if (cross(b, c) > EPS) return +1;      // a,b,cの順に反時計周り\n        if (cross(b, c) < -EPS) return -1;     // a,b,cの順に時計周り\n        if (dot(b, c) < 0) return +2;          // c--a--b 直線\n        if (norm(b) < norm(c)) return -2;      // a--b--c 直線\n        return 0;                              // a--c--b 直線\n    }\n\n    struct Line {\n        Point a, b;\n        Line() {}\n        Line(const Point& a, const Point& b) : a(a), b(b) {}\n    };\n    ostream& operator<<(ostream& os, const Line& l) {\n        return os << \"Line(\" << l.a << \",\" << l.b << \")\";\n    }\n    Point crosspoint(const Line& s, const Line& t) {\n        double d = cross(t.b - t.a, s.b - s.a);\n        assert(abs(d) >= EPS);\n        return s.a + (s.b - s.a) * cross(t.b - t.a, t.b - s.a) / d;\n    }\n    bool parallel(const Line& s, const Line& t) { return abs(cross(s.b - s.a, t.b - t.a)) < EPS; }\n\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n\n    int N, M;\n    vector<Point> V;\n    vector<Point> L;\n    bool input() {\n        cin >> N >> M;\n        if (N == 0 && M == 0) return false;\n        V.clear(); V.resize(N);\n        L.clear(); L.resize(M);\n        for (int i = 0; i < N; i++) cin >> V[i];\n        for (int j = 0; j < M; j++) cin >> L[j];\n        return true;\n    }\n\n    Line midline(Point a, Point b) {\n        Point m = (a + b) / 2;\n        Point v = b - m;\n        return Line(m, m + rot90(v));\n    }\n\n    typedef vector<Point> Polygon;\n    double area(const Polygon& vs) {\n        assert(vs.size() >= 3);\n        double r = 0;\n        for (int i = 0; i < vs.size(); i++) {\n            const Point& a = vs[i];\n            const Point& b = vs[(i + 1) % vs.size()];\n            r += cross(a, b);\n        }\n        return r / 2;\n    }\n\n    struct angle_comp {\n        Point p;\n        angle_comp(Point p) : p(p) {}\n        bool operator()(Point a, Point b) {\n            return angle(a - p) < angle(b - p);\n        }\n    };\n\n    void solve() {\n        for (int i = 0; i < M; i++) {\n            vector<Point> P = V;\n            for (int j = 0; j < M; j++) {\n                if (i == j) continue;\n                Line m = midline(L[i], L[j]);\n                vector<Point> add;\n                int n = P.size();\n                for (int k = 0; k < n; k++) {\n                    Line e(P[k], P[(k + 1) % n]);\n                    if (parallel(m, e)) continue;\n                    Point p = crosspoint(m, e);\n                    if (ccw(e.a, p, e.b) == -2) {\n                        add.push_back(p);\n                    }\n                }\n                //assert(add.size() == 2);\n                vector<Point> nP = add;\n                for (int k = 0; k < n; k++) {\n                    Line c(L[i], P[k]);\n                    if (parallel(c, m)) continue;\n                    if (ccw(L[i], crosspoint(c, m), P[k]) == -2) continue;\n                    nP.push_back(P[k]);\n                }\n                sort(nP.begin(), nP.end(), angle_comp(L[i]));\n                P = nP;\n            }\n            printf(\"%.12lf\\n\", area(P));\n        }\n    }\n}\n\nint main() {\n    while (input()) solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<cmath>\n#include<vector>\n#include<cstdlib>\n#include<cassert>\n#include<map>\n#include<iomanip>\n#define _A_ true\n#define EPS 1e-10\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\nusing namespace std;\nclass Point{\npublic:\n  double x,y;\n  Point(double x =0,double y=0):x(x),y(y){}\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(x*a,y*a);}\n  Point operator / (double a){return Point(x/a,y/a);} //もし悪を使うなら要確認\n \n  double norm() {return x*x+y*y;}\n  double abs() {return sqrt(norm());}\n \n  bool operator < (const Point &p) const{\n    return x != p.x ? x < p.x : y < p.y; \n  }\n \n  bool operator == (const Point &p) const{\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n\n};\ntypedef Point Point;\nstruct Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p = Point(),Point pp = Point()):p1(p),p2(pp){}\n};\n \ntypedef vector<Point> Polygon;\ntypedef Segment Line;\n \ndouble norm(Point p){\n  return p.x*p.x+p.y*p.y;\n}\n \ndouble abs(Point p){\n  return sqrt(norm(p));\n}\n \nPoint polar(double a,double rad){\n  return Point(a*cos(rad),a*sin(rad));\n}\n \ndouble args(Point p){\n  return atan2(p.y,p.x);\n}\n \ndouble dot(Point a,Point b){\n  return a.x*b.x+a.y*b.y;\n}\n \ndouble cross(Point a,Point b){\n  return a.x*b.y-b.x*a.y;\n}\n \nPoint project(Segment s,Point p){\n  Point base = s.p2 - s.p1;\n  double t = dot(p-s.p1,base)/base.norm();\n  return s.p1+base*t;\n}\n \nPoint reflect (Segment s, Point p){\n  return p + (project(s,p)-p)*2.0;\n}\n \nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CLOCKWISE;\n  if(dot(a,b) < -EPS) return ONLINE_BACK;\n  if(a.norm() < b.norm() ) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n \nbool isIntersect(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <= 0 && ccw(p3,p4,p1) * ccw(p3,p4,p2) <= 0 );\n}\n \nbool isIntersect(Segment s1,Segment s2){\n  return isIntersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nPoint getCrossPointSegments(Segment s1,Segment s2){\n  //assert(isIntersect(s1,s2));\n  Point base = s2.p2 - s2.p1;\n  double d1 = abs(cross(base,s1.p1-s2.p1));\n  double d2 = abs(cross(base,s1.p2-s2.p1));\n  double t = d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n\n\nPoint getCrossPointLines( Line s1, Line s2){\n\n    Point a = s1.p2 - s1.p1;\n    //Point base = Point(s2.p2.x - s2.p1.x,s2.p2.y - s2.p1.y);\n    Point base = s2.p2 -s2.p1;\n    return s1.p1 + a * (cross(base, s2.p1 - s1.p1)/cross(base, a));\n}\n\nPolygon cutPolygon( Polygon P, Line l ){\n    Polygon u;\n    \n    for ( int i = 0; i < P.size(); i++ ){\n        Point a = P[i], b = P[(i+1)%P.size()];\n\t\n\tif ( ccw(l.p1, l.p2, a) != CLOCKWISE ) u.push_back(a);\n\tif ( ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) == -1 ){\n\t  u.push_back(getCrossPointLines(Segment(a, b), l));\n        }\n    }   \n    return u;\n}\n \n \nLine CreateLine(Point p,Point pp){\n  Point mid = (p+pp)/2;\n  Point sl = pp-p;//原点に5\n  double rad = args(sl);\n  Point ap = polar(abs(sl),rad+M_PI/2)+mid;\n  //ap.x = abs(sl)*cos(rad+M_PI/2)+mid.x;\n  //ap.y = abs(sl)*sin(rad+M_PI/2)+mid.y;\n  return Line(mid,ap);\n} \n \ndouble AreaCalc(Polygon p){\n  double area = 0;\n  for(int i=0;i<p.size();i++)\n    area+=cross(p[i],p[(i+1)%p.size()]);\n  return fabs(area)/2.0;\n} \n \nint main(){\n\n  int N,M;\n  while(cin >> N >> M,N|M){\n  \n  vector<Point> l(N);\n  vector<Point> C(M);\n  for(int i=0;i<N;i++)\n    {\n      cin >> l[i].x >> l[i].y;\n      l[i].x += 200,l[i].y += 200;\n    }\n  for(int i=0;i<M;i++)\n    {\n      cin >> C[i].x >> C[i].y;\n      C[i].x += 200,C[i].y += 200;\n    }\n  for(int i=0;i<M;i++)\n    {\n      Polygon poly; \n      for(int j=0;j<N;j++)\n\tpoly.push_back(l[j]);\n\n      for(int j=0;j<M;j++)\n\t{\n\t  if(j == i)\n\t    continue;\n\t  poly = cutPolygon(poly,CreateLine(C[i],C[j]));\n\t}\n      \n      cout << setiosflags(ios::fixed) << setprecision(1) << AreaCalc(poly) << endl;\n\n    }  \n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <cassert>\n#include <iomanip>\n#include <algorithm>\nusing namespace std;\n\n#define EPS 1e-8\ntypedef complex<double> P;\ntypedef vector<P> G;\n\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\n\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nint ccw(P a, P b, P c)\n{\n\tb -= a; c -= a;\n\tif (cross(b, c) > +EPS) return +1;\n\tif (cross(b, c) < -EPS) return -1;\n\tif (dot(b, c)   < -EPS) return +2;\n\tif (norm(b) < norm(c))  return -2;\n\treturn 0;\n}\n\nbool notleft(P a, P b, P c)\n{\n\treturn (ccw(a,b,c)!=+1);\n}\n\nbool isIntoG(const G& g, const P& p)\n{\n\tsize_t sz = g.size();\n\tfor(size_t i=0; i<sz; i++)\n\t{\n\t\tif( notleft(p, g[i], g[(i+1)%sz]) ) return false;\n\t}\n\treturn true;\n}\n\nbool isfar(G& g, P& p)\n{\n\tfor(int i=0; i<g.size(); i++)\n\t\tif(abs(g[i]-p) < EPS) return false;\n\t\t\n\treturn true;\n}\n\n#define CURR(P, i) P[i]\n#define NEXT(P, i) P[(i+1)%P.size()]\n\nbool ConvexCut(G& g, L& l, vector<G>& ret)\n{\n\tint sp,inp=0;\n\tfor(sp=0; sp<g.size(); sp++)\n\t\tif(intersectLS(l, L(g[sp], g[(sp+1)%g.size()]))) break;\n\t\t\n\tif(sp==g.size()) return false;\n\t\n\tret.resize(2);\n\t\t\n\tP xp=crosspoint(l, L(g[sp], g[(sp+1)%g.size()]));\n\tsp++;\n\t\n\tfor(int i=sp; i<sp+g.size(); i++)\n\t{\n\t\tif(isfar(ret[inp], g[i%g.size()])) ret[inp].push_back(g[i%g.size()]);\n\t\tif(intersectLS(l, L(g[i%g.size()], g[(i+1)%g.size()])))\n\t\t{\n\t\t\tP tx=crosspoint(l, L(g[i%g.size()], g[(i+1)%g.size()]));\n\t\t\tif(abs(tx-xp) < EPS) continue;\n\t\t\t\n\t\t\txp=tx;\n\t\t\tfor(int j=0; j<2; j++)\n\t\t\t{\n\t\t\t\tif(isfar(ret[j], xp)) ret[j].push_back(xp);\n\t\t\t}\n\t\t\t\n\t\t\tinp=(inp+1)%2;\n\t\t}\n\t}\n\t\n\treturn true;\n}\n\nL trans(P a, P b)\n{\n\tP med=(a+b);\n\tmed=P(med.real()/2, med.imag()/2);\n\tP hoge=(a-b);\n\thoge*=P(0,1);\n\t\n\treturn L(med+hoge*P(1000,0), med-hoge*P(1000,0));\n}\n\ndouble Area(G& g)\n{\n\tdouble ret=0;\n\tfor(int i=0; i<g.size(); i++)\n\t\tret+=cross(CURR(g,i), NEXT(g,i))/2;\n\t\t\n\treturn ret;\n}\n\nint main()\n{\n\tcout << setiosflags(ios::fixed) << setprecision(7);\n\t\n\tint N,M;\n\twhile(cin >> N >> M, (N||M))\n\t{\n\t\tG g,pts;\n\t\tfor(int i=0; i<N; i++)\n\t\t{\n\t\t\tdouble x,y;\n\t\t\tcin >> x >> y;\n\t\t\tg.push_back(P(x,y));\n\t\t}\n\t\tfor(int i=0; i<M; i++)\n\t\t{\n\t\t\tdouble x,y;\n\t\t\tcin >> x >> y;\n\t\t\tpts.push_back(P(x,y));\n\t\t}\n\t\t\n\t\tfor(int i=0; i<M; i++)\n\t\t{\n\t\t\tG f=g;\n\t\t\tfor(int j=0; j<M; j++)\n\t\t\t{\n\t\t\t\tif(i==j) continue;\n\t\t\t\tL divide=trans(pts[i], pts[j]);\n\t\t\t\tvector<G> cut;\n\t\t\t\tif(!ConvexCut(f, divide,cut)) continue;\n\t\t\t\tif(isIntoG(cut[0], pts[i])) f=cut[0];\n\t\t\t\telse f=cut[1];\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tcout << Area(f) << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double mEPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nclass Point{\npublic:\n\tdouble x, y;\n\n\tPoint(double x = 0.0, double y = 0.0) : x(x), y(y){}\n\n\tPoint operator + (Point p){ return Point(x + p.x, y + p.y); }\n\tPoint operator - (Point p){ return Point(x - p.x, y - p.y); }\n\tPoint operator * (double a){ return Point(a*x, a*y); }\n\tPoint operator / (double a){ return Point(x / a, y / a); }\n\n\tdouble abs(){ return sqrt(norm()); }\n\tdouble norm(){ return x*x + y*y; }\n\n\tbool operator < (const Point &p) const{\n\t\treturn x != p.x ? x < p.x : y < p.y;\n\t}\n\n\t//EPS??????????°??????????\n\tbool operator == (const Point &p) const {\n\t\treturn fabs(x - p.x) < mEPS && fabs(y - p.y) < mEPS;\n\t}\n\n};\n\nclass Segment{\npublic:\n\tPoint p1, p2;\n};\n\ntypedef vector<Point> Polygon;\n\n//???????????¨????????±???\ntypedef Point Vector;\n//???????????´?????¨????????±???\ntypedef Segment Line;\n\n//??????\ndouble dot(Vector a, Vector b){\n\treturn a.x*b.x + a.y*b.y;\n}\n\n//???????????§??????\ndouble cross(Vector a, Vector b){\n\treturn a.x*b.y - a.y*b.x;\n}\nint ccw(Point p0, Point p1, Point p2){\n\n\t//p0->p1???p0?§???????p1?????????????????????????????¨????????¨???\n\n\t//p0->p2??????????¨??????????????????¨???\n\tstatic const int COUNTER_CLOCKWISE = 1;\n\t//p0->p2???????¨??????????????????¨???\n\tstatic const int CLOCKWISE = -1;\n\t//p2,p0,p1????????§????????´?????????????????¨???\n\tstatic const int ONLINE_BACK = 2;\n\t//p0,p1,p2 ????????§????????´?????????????????´???\n\tstatic const int ONLINE_FRONT = -2;\n\t//p2 ????????? p0p1 ??????????????´???\n\tstatic const int ON_SEGMENT = 0;\n\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\n\tif (cross(a, b) > mEPS) return COUNTER_CLOCKWISE;\n\tif (cross(a, b) < -mEPS) return CLOCKWISE;\n\tif (dot(a, b) < -mEPS) return ONLINE_BACK;\n\tif (a.norm() < b.norm()) return ONLINE_FRONT;\n\n\treturn ON_SEGMENT;\n\n}\nPoint getCrossPoint(Segment s1, Segment s2){\n\tVector base = s2.p2 - s2.p1;\n\tdouble d1 = abs(cross(base, s1.p1 - s2.p1));\n\tdouble d2 = abs(cross(base, s1.p2 - s2.p1));\n\tdouble t = d1 / (d1 + d2);\n\treturn s1.p1 + (s1.p2 - s1.p1)*t;\n}\ndouble polygon_area(Polygon t){\n  double ans=0.0;\n  for(unsigned int i=0;i<t.size();i++)\n\tans+=cross(t[i] , t[(i+1)%t.size()]);\n  return ans/2;\n}\n\nPolygon convex_cut(const Polygon& pol, const Line& l) {\n  Polygon Q;\n  for (unsigned int i = 0; i < pol.size(); ++i) {\n    Point A = pol[i], B = pol[(i+1)%pol.size()];\n    if (ccw(l.p1, l.p2, A) != -1) Q.push_back(A);\n    if (ccw(l.p1, l.p2, A)*ccw(l.p1, l.p2, B) < 0){\n\t  Line tmp; tmp.p1 = A, tmp.p2 = B;\n      Q.push_back(getCrossPoint(tmp, l));\n\t}\n  }\n  return Q;\n}\n\nPoint rotate(Point p,double angle){\n  return Point(p.x*cos(angle) - p.y*sin(angle),\n\t\t\t   p.x*sin(angle) + p.y*cos(angle));\n}\n\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N, M;\n  while(cin>>N>>M,N){\n\tPolygon pol(N);\n\tREP(i,N) cin >> pol[i].x >> pol[i].y;\n\tvector<Point> ps(M);\n\tREP(i,M) cin >> ps[i].x >> ps[i].y;\n\n\tREP(i,M){\n\t  Polygon tmp = pol;\n\t  REP(j,M){\n\t\tif(i == j) continue;\n\t\tLine l;\n\t\tl.p1 = (ps[i] + ps[j]) / 2;\n\t\tl.p2 = rotate(ps[j] - ps[i], PI / 2) + l.p1;\n\t\ttmp = convex_cut(tmp, l);\n\t  }\n\t  cout << fixed << setprecision(9) << polygon_area(tmp) << endl;\n\t}\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cstdio>\n#include <utility>\n#include <vector>\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<P,P> L;\ntypedef pair<P,double> C;\ntypedef vector<P> Poly;\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define INF (1e15)\n\n//2D version\nnamespace std{\n  bool operator < (const P& a, const P& b){\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n  bool cmp_y(const P &a, const P &b){\n    return a.Y != b.Y ? a.Y < b.Y : a.X < b.X;\n  }\n  bool operator == (const P& a, const P& b){\n    return abs(a-b) < EPS;\n  }\n}\n\ndouble dot(P a, P b){\n  return a.X * b.X + a.Y * b.Y;\n}\ndouble cross(P a, P b){\n  return a.X * b.Y - a.Y * b.X;\n}\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if( cross(b,c) > EPS ) return +1;\n  if( cross(b,c) < -EPS ) return -1;\n  if( dot(b,c) < 0 ) return +2;\n  if( abs(b) + EPS < abs(c) ) return -2;\n  return 0;\n}\n\nP intersection(L a, L b){\n  //直線aと直線bの交点\n  return a.first + cross(b.second-b.first,a.first-b.first)/(-cross(b.second-b.first,a.second-b.first)+cross(b.second-b.first,a.first-b.first))*(a.second-a.first);\n}\n\nPoly convex_cut(Poly p, L l){\n  Poly ret;\n  int n = p.size();\n  for(int i = 0; i < n; ++i){\n    if(ccw(l.first, l.second, p[i]) != -1) ret.push_back(p[i]);\n    if(ccw(l.first, l.second, p[i]) != -1 ^ ccw(l.first, l.second, p[(i+1)%n]) != -1) ret.push_back(intersection(L(p[i], p[(i+1)%n]), l));\n  }\n  return ret;\n}\n\ndouble area(Poly p){\n  double ret = 0;\n  int n = p.size();\n  for(int i = 0; i < n; ++i){\n    ret += cross(p[i], p[(i+1)%n])/2;\n  }\n  return ret;\n}\n\nint main(){\n  int N, M;\n  while(cin >> N >> M, N||M){\n    Poly I;\n    for(int i = 0; i < N; ++i){\n      double x, y;\n      cin >> x >> y;\n      I.push_back(P(x,y));\n    }\n    Poly p;\n    for(int j = 0; j < M; ++j){\n      double x, y;\n      cin >> x >> y;\n      p.push_back(P(x,y));\n    }\n    for(int i = 0; i < M; ++i){\n      Poly q = I;\n      for(int j = 0; j < M; ++j){\n        if(i == j) continue;\n        L bisector = L((p[i]+p[j])/2.0, (p[i]+p[j])/2.0 + (p[j]-p[i])*P(0,1));\n        q = convex_cut(q, bisector);\n      }\n      printf(\"%.12lf\\n\", area(q));\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cassert>\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\n#define x first\n#define y second\n\nusing namespace std;\n\ntypedef pair<double, double> Point;\n\nclass Line {\n  public:\n    double a, b, c;\n\n    Line(const double _a = 0.0, const double _b = 0.0, const double _c = 0.0):\n      a(_a),\n      b(_b),\n      c(_c) {}\n\n    Line(const Point &p1, const Point &p2):\n      a(p1.y - p2.y),\n      b(p2.x - p1.x),\n      c(p1.x * p2.y - p1.y * p2.x) {}\n};\n\nvector<Line> Plane;\nvector<Point> Points;\nvector<double> Areas;\n\ninline double Det(const Point &a, const Point &b, const Point &c) {\n    return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\n}\n\nclass Compare {\n  public:\n    static Point origin;\n\n    bool operator()(const Point &a, const Point &b) const {\n        return Det(origin, a, b) >= 0;\n    }\n};\n\nPoint Compare::origin;\n\nvector<Point> ConvexHull(vector<Point> points) {\n    int n = int(points.size());\n    int origin = 0;\n    for (int i = 1; i < n; ++i)\n        if (points[i] < points[origin])\n            origin = i;\n    swap(points[0], points[origin]);\n    Compare::origin = points[0];\n    sort(points.begin() + 1, points.end(), Compare());\n    points.push_back(points[0]);\n    vector<Point> hull;\n    for (int i = 0; i < int(points.size()); ++i) {\n        while (int(hull.size()) > 1 && Det(hull[int(hull.size()) - 2], hull[int(hull.size()) - 1], points[i]) <= 0)\n            hull.pop_back();\n        hull.push_back(points[i]);\n    }\n    hull.pop_back();\n    return hull;\n}\n\ninline Point Dualize(const Line &l) {\n    if (l.c == 0)\n        return Point(0, 0);\n    else\n        return Point(l.a / l.c, l.b / l.c);\n}\n\ninline Line Dualize(const Point &p) {\n    return Line(p.x, p.y, 1);\n}\n\ninline Point Translate(const Point &p, const Point &shift) {\n    return Point(p.x + shift.x, p.y + shift.y);\n}\n\ninline Line Translate(const Line &l, const Point &shift) {\n    return Line(l.a, l.b, l.c - l.a * shift.x - l.b * shift.y);\n}\n\nvector< vector<Point> > GetVoronoiDiagrams(const vector<Line> &plane, const vector<Point> &points) {\n    int n = int(points.size());\n    vector< vector<Point> > voronoiDiagrams = vector< vector<Point> >(n, vector<Point>());\n    for (int i = 0; i < n; ++i) {\n        Point shift = Point(-points[i].x, -points[i].y);\n        vector<Point> dualizedLines;\n        for (int j = 0; j < int(plane.size()); ++j)\n            dualizedLines.push_back(Dualize(Translate(plane[j], shift)));\n        for (int j = 0; j < n; ++j) {\n            if (i != j) {\n                Point a = points[i], b = points[j];\n                dualizedLines.push_back(Dualize(Translate(Line(2 * (b.x - a.x), 2 * (b.y - a.y), a.x * a.x + a.y * a.y - b.x * b.x - b.y * b.y), shift)));\n            }\n        }\n        vector<Point> hull = ConvexHull(dualizedLines);\n        for (int j = 0; j < int(hull.size()); ++j)\n            voronoiDiagrams[i].push_back(Translate(Dualize(Line(hull[j], hull[(j + 1) % int(hull.size())])), points[i]));\n    }\n    return voronoiDiagrams;\n}\n\ninline double GetArea(const vector<Point> &polygon) {\n    int n = int(polygon.size());\n    double area = 0.0;\n    for (int i = 0; i < n; ++i)\n        area += polygon[i].x * polygon[(i + 1) % n].y - polygon[(i + 1) % n].x * polygon[i].y;\n    area /= 2.0;\n    if (area < 0.0)\n        area = -area;\n    return area;\n}\n\nvoid Solve() {\n    vector< vector<Point> > voronoi = GetVoronoiDiagrams(Plane, Points);\n    Areas = vector<double>(int(Points.size()), 0.0);\n    for (int i = 0; i < int(Points.size()); ++i)\n        Areas[i] = GetArea(voronoi[i]);\n}\n\nbool Read() {\n    int n, m;\n    cin >> n >> m;\n    if (n == 0 && m == 0)\n        return false;\n    vector<Point> planePolygon = vector<Point>(n);\n    for (int i = 0; i < n; ++i)\n        cin >> planePolygon[i].x >> planePolygon[i].y;\n    for (int i = 0; i < n; ++i)\n        Plane.push_back(Line(planePolygon[i], planePolygon[(i + 1) % n]));\n    Points = vector<Point>(m);\n    for (int i = 0; i < m; ++i)\n        cin >> Points[i].x >> Points[i].y;\n    return true;\n}\n\nvoid Print() {\n    for (int i = 0; i < int(Points.size()); ++i)\n        printf(\"%.7lf\\n\", Areas[i]);\n}\n\nint main() {\n    while (Read()) {\n        Solve();\n        Print();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double eps = 1e-8;\n\nbool equals(double a, double b) {\n  return abs(a-b) < eps;\n}\n\ndouble cross(P a, P b) {\n  return a.real()*b.imag() - a.imag()*b.real();\n}\n\ndouble dot(P a, P b) {\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n\nint ccw(P p, P a, P b) {\n  a -= p;\n  b -= p;\n  if(cross(a, b) > eps) return 1;\n  if(cross(a, b) < -eps) return -1;\n  if(dot(a, b) < -eps) return 2;\n  if(norm(b) - norm(a) > eps) return -2;\n  return 0;\n}\n\nP getCrossP(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1;\n  P b = b2 - b1;\n  return a1 + a * cross(b, b1 - a1) / cross(b, a);\n}\n\nvector<P> convex_cut(vector<P> ps, P p1, P p2, int dir = -1) {\n  vector<P> v;\n  for(int i = 0; i < ps.size(); ++i) {\n    P a = ps[i];\n    P b = ps[(i+1)%ps.size()];\n    if(ccw(p1, p2, a) != dir) v.push_back(a);\n    if(ccw(p1, p2, a)*ccw(p1, p2, b) == -1)\n      v.push_back(getCrossP(a, b, p1, p2));\n  }\n  return v;\n}\n\ndouble getArea(const vector<P> &ps) {\n  int n = ps.size();\n  double res = 0;\n  for(int i = 0; i < n; ++i) {\n    res += cross(ps[i], ps[(i+1)%n]);\n  }\n  return res / 2.0;\n}\n\n\nint main() {\n  for(int N, M; cin >> N >> M && (N|M); ) {\n    vector<P> ps(N);\n    for(int i = 0; i < N; ++i) {\n      cin >> ps[i].real() >> ps[i].imag();\n    }\n    if(getArea(ps) < 0.0) reverse(ps.begin(), ps.end());\n    vector<P> C(N);\n    for(int j = 0; j < M; ++j) {\n      cin >> C[j].real() >> C[j].imag();\n    }\n\n\n    for(int i = 0; i < M; ++i) {\n      vector<P> g = ps;\n      for(int j = 0; j < M; ++j) {\n\tif(i == j) continue;\n\tP p1, p2, base, base2;\n\tbase = C[j] - C[i];\n\tbase2 = P(-base.imag(), base.real());\n\tp1 = (C[i] + C[j]) / 2.0;\n\tp2 = p1 + base2;\n\tg = convex_cut(g, p1, p2);\n      }\n      printf(\"%.10f\\n\", getArea(g));\n    }\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P; //Point\ntypedef pair<P,P> L; //Line, Segment\n\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\n\nnamespace std {\n  bool operator < (const P& a, const P& b){\n    return fabs(real(a)-real(b)) < EPS ? imag(a) < imag(b) : real(a) < real(b);\n  }\n}\ndouble dot(P a, P b){ return real(conj(a)*b); }\ndouble cross(P a, P b){ return imag(conj(a)*b); }\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > EPS) return 1;   // ????????????(b-a)????????´???????????????(c-a)????????¨?????????\n  if(cross(b,c) < -EPS) return -1; // ????????????(b-a)????????´???????????????(c-a)????????¨?????????\n  if(dot(b,c) < -EPS) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n\ndouble area(vector<P> v){\n  double sum = 0.0;\n  int n = v.size();\n  for(int i=0;i<n;i++) sum += (real(v[i]) - real(v[(i+1)%n])) * (imag(v[i]) + imag(v[(i+1)%n]));\n  return fabs(sum) / 2;\n};\n\nP crossPoint(L l, L m){\n  double A = cross(l.second - l.first, m.second - m.first);\n  double B = cross(l.second - l.first, l.second - m.first);\n  if(fabs(A) < EPS && fabs(B) < EPS) return m.first;\n  else if(fabs(A) >= EPS) return m.first + B / A * (m.second - m.first);\n}\n\nvector<P> convex_cut(vector<P> G, L l){\n  vector<P> ans;\n  for(int i=0;i<G.size();i++){\n    P A = G[i];\n    P B = G[(i+1)%G.size()];\n    if(ccw(l.first, l.second, A) != -1) ans.push_back(A);\n    if(ccw(l.first, l.second, A) * ccw(l.first, l.second, B) < 0)\n      ans.push_back(crossPoint(L(A,B), l));\n  }\n  return ans;\n}\n\nint n,m;\nvector<P> mp;\ndouble calc(int idx,vector<P>g){\n  for(int i=0;i<m;i++){\n    if(i==idx)continue;\n    P t=mp[idx]-mp[i];\n    P a=P(abs(t)/2,1)*t/abs(t)+mp[i];\n    P b=P(abs(t)/2,-1)*t/abs(t)+mp[i];\n    if(ccw(a,b,mp[idx])<0)swap(a,b);\n    g=convex_cut(g,L(a,b));\n  }\n  return area(g);\n}\n\nint main(){\n  while(1){\n  cin>>n>>m;\n  if(!n&&!m)break;\n  vector<P> pl(n);\n  mp.resize(m);\n  for(int i=0,x,y;i<n;i++)cin>>x>>y,pl[i]=P(x,y);\n  for(int i=0,x,y;i<m;i++)cin>>x>>y,mp[i]=P(x,y);\n  for(int i=0;i<m;i++)printf(\"%.10f\\n\",calc(i,pl));\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <memory>\n#include <cstring>\n#include <cassert>\n#include <numeric>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <cctype>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\nusing namespace std;\n\n#define REP2(i, m, n) for (int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(S) (S).begin(), (S).end()\ntypedef long long ll;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line_t;\ntypedef pair<xy_t, double> circle_t;\ntypedef vector<xy_t> poly_t;\n\nnamespace std {\n  bool operator<(const xy_t &a, const xy_t &b){\n    return a.real() == b.real() ? a.imag() < b.imag() : a.real() < b.real();\n  }\n}\n\nconst double EPS = 1e-9;\n\ninline bool equal(double a, double b){\n  return abs(a - b) < EPS;\n}\n\nistream &operator>>(istream &is, xy_t &p)   {\n  double x, y;\n  is >> x >> y;\n  p = xy_t(x, y);\n  return is;\n}\n\nistream &operator>>(istream &is, line_t &l) {\n  return is >> l.first >> l.second;\n}\n\ninline double cross(const xy_t &a, const xy_t &b){\n  return imag(conj(a) * b);\n}\n\ninline double dot(const xy_t &a, const xy_t &b){\n  return real(conj(a) * b);\n}\n\ninline xy_t rotate(const xy_t &a, double theta){\n  return a * polar(1.0, theta);\n}\n\ninline xy_t direction(const line_t &line){\n  return line.second - line.first;\n}\n\nint ccw(const xy_t &a, xy_t b, xy_t c){\n  b -= a;\n  c -= a;\n  if (cross(b, c) > +EPS) return 1;\n  if (cross(b, c) < -EPS) return -1;\n  if (dot(b, c)   < -EPS) return 2;\n  if (norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nint ccw(const line_t &l, const xy_t &a){\n  return ccw(l.first, l.second, a);\n}\n\nline_t bisector(const xy_t &a, const xy_t &b){\n  xy_t v = rotate(b - a, M_PI / 2);\n  xy_t m = (a + b) * 0.5;\n  return line_t (m, m + v);\n};\n\nxy_t crosspoint(const line_t &l, const line_t &m){\n  xy_t l_vec = direction(l);\n  xy_t m_vec = direction(m);\n  double A = cross(l_vec, m_vec);\n  assert(!equal(A, 0));\n  return m.first + cross(l_vec, l.second-m.first) / A * m_vec;\n}\n\ninline size_t next_index(const poly_t &poly, size_t curr){\n  return (curr + 1) % poly.size();\n}\n\ninline size_t prev_index(const poly_t &poly, size_t curr){\n  return (curr + poly.size() - 1)  % poly.size();\n}\n\npoly_t convex_cut(const poly_t &poly, const line_t &line){\n  poly_t new_poly;\n  \n  for (size_t i = 0; i < poly.size(); i++){\n    xy_t a = poly[i];\n    xy_t b = poly[next_index(poly, i)];\n\n    if (ccw(line, a) != -1) new_poly.push_back(a);\n    \n    if (ccw(line, a) * ccw(line, b) < 0){\n      new_poly.push_back(crosspoint(line_t (a, b), line));\n    }\n  }\n  return new_poly;\n}\n\ndouble signed_area(const poly_t &poly){\n  double res = 0;\n  for (size_t i = 0; i < poly.size(); i++){\n    res += cross(poly[i], poly[next_index(poly, i)]);\n  }\n  return res * 0.5;\n}\n\ndouble area(const poly_t &poly){\n  return abs(signed_area(poly));\n}\n\n\nint main(){\n  ios::sync_with_stdio(false);\n  int N, M;\n  while (cin >> N >> M && N + M){\n    poly_t poly(N);\n    REP(i, N){\n      cin >> poly[i];\n    }\n    \n    vector<xy_t> L(M);\n    REP(i, M){\n      cin >> L[i];\n    }\n    \n\n    REP(i, M){\n      poly_t pi = poly;\n      \n      REP(j, M) if (i != j){\n        pi = convex_cut(pi, bisector(L[i], L[j]));\n      }\n      \n      cout << fixed << setprecision(20) << area(pi) << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<(int)(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nconst ld eps = 1e-8, pi = acos(-1.0);\n\n#define EQ(a,b) (abs((a)-(b))<eps)\n\nnamespace std {\n  bool operator<(const P &lhs, const P &rhs) {\n    return lhs.real() == rhs.real() ? lhs.imag() < rhs.imag()\n                                    : lhs.real() < rhs.real();\n  }\n}\n\nld dot (P a, P b) { return real(conj(a) * b); }\nld cross (P a, P b) { return imag(conj(a) * b); }\n\nstruct L{ P a, b; };\n\nint ccw (P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > eps) return 1;   // counter clockwise\n  if (cross(b, c) < -eps) return -1; // clockwise\n  if (dot(b, c) < 0) return 2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line\n  return 0;                          // a--c--b on line\n}\n\nbool isis_ls(L l, L s) {\n  ld a = cross(l.b - l.a, s.a - l.a);\n  ld b = cross(l.b - l.a, s.b - l.a);\n  return (a * b < eps);\n}\n\nP is_ll(L s, L t){\n  P sv = s.b - s.a, tv = t.b - t.a;\n  return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nld area(const VP &p) {\n  ld res = 0;\n  int n = p.size();\n  REP(j,n) res += cross(p[j], p[(j+1)%n]);\n  return res / 2;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n  bool in = false;\n  int n = g.size();\n  for (int i = 0; i < n; i++) {\n    P a = g[i] - p, b = g[(i+1)%n] - p;\n    if (imag(a) > imag(b)) swap(a, b);\n    if (imag(a) <= 0 && 0 < imag(b))\n      if (cross(a, b) < 0) in = !in;\n    if (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n  }\n  if(in) return 1; // in\n  return -1; // out\n}\n\nint main() {\n  while(1){\n    int n,m;\n    cin>>n>>m;\n    if(!n) break;\n    VP pl,vp;\n    REP(i,n){\n      int x,y;\n      cin>>x>>y;\n      pl.emplace_back(x,y);\n    }\n    REP(i,m){\n      int x,y;\n      cin>>x>>y;\n      vp.emplace_back(x,y);\n    }\n    REP(i,m) {\n      VP poly = pl;\n      REP(j,m) {\n        if (j == i) continue;\n        P pc = (vp[i] + vp[j]) / ld(2.0);\n        P ig(0,1);\n        L l1 = {pc, (vp[j] - pc) * ig + pc};\n        vector<pair<int,P>> is;\n        REP(k,poly.size()) {\n          L l2 = {poly[k], poly[(k+1)%poly.size()]};\n          if (isis_ls(l1, l2)) {\n            is.emplace_back(k, is_ll(l1, l2));\n          }\n        }\n        sort(ALL(is));\n        if (is.size() < 2) continue;\n        do {\n          int k; P p;\n          tie(k, p) = is[0];\n          int l; P q;\n          tie(l, q) = is[1];\n          if (l < k) l += poly.size();\n          VP np;\n          np.push_back(p);\n          FOR(a,k+1,l+1) {\n            np.push_back(poly[a%poly.size()]);\n          }\n          np.push_back(q);\n          if (is_in_Polygon(np, vp[i]) > 0) {\n            poly = np;\n            break;\n          }\n        } while(next_permutation(ALL(is)));\n      }\n      cout <<fixed << setprecision(10)<< area(poly) << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<(int)(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nconst ld eps = 1e-8, pi = acos(-1.0);\n\n#define EQ(a,b) (abs((a)-(b))<eps)\n\nnamespace std {\n  bool operator<(const P &lhs, const P &rhs) {\n    return lhs.real() == rhs.real() ? lhs.imag() < rhs.imag()\n                                    : lhs.real() < rhs.real();\n  }\n}\n\nld dot (P a, P b) { return real(conj(a) * b); }\nld cross (P a, P b) { return imag(conj(a) * b); }\n\nstruct L{ P a, b; };\n\nint ccw (P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > eps) return 1;   // counter clockwise\n  if (cross(b, c) < -eps) return -1; // clockwise\n  if (dot(b, c) < 0) return 2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line\n  return 0;                          // a--c--b on line\n}\n\nbool isis_ls(L l, L s) {\n  ld a = cross(l.b - l.a, s.a - l.a);\n  ld b = cross(l.b - l.a, s.b - l.a);\n  return (a * b < eps);\n}\n\nP is_ll(L s, L t){\n  P sv = s.b - s.a, tv = t.b - t.a;\n  return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nld area(const VP &p) {\n  ld res = 0;\n  int n = p.size();\n  REP(j,n) res += cross(p[j], p[(j+1)%n]);\n  return res / 2;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n  bool in = false;\n  int n = g.size();\n  for (int i = 0; i < n; i++) {\n    P a = g[i] - p, b = g[(i+1)%n] - p;\n    if (imag(a) > imag(b)) swap(a, b);\n    if (imag(a) <= 0 && 0 < imag(b))\n      if (cross(a, b) < 0) in = !in;\n    if (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n  }\n  if(in) return 1; // in\n  return -1; // out\n}\n\nint main() {\n  while(1){\n    int n,m;\n    cin>>n>>m;\n    if(!n) break;\n    VP pl,vp;\n    REP(i,n){\n      int x,y;\n      cin>>x>>y;\n      pl.emplace_back(x,y);\n    }\n    REP(i,m){\n      int x,y;\n      cin>>x>>y;\n      vp.emplace_back(x,y);\n    }\n    REP(i,m) {\n      VP poly = pl;\n      REP(j,m) {\n        if (j == i) continue;\n        P pc = (vp[i] + vp[j]) / ld(2.0);\n        P ig(0,1);\n        L l1 = {pc, (vp[j] - pc) * ig + pc};\n        vector<pair<int,P>> is;\n        REP(k,poly.size()) {\n          L l2 = {poly[k], poly[(k+1)%poly.size()]};\n          if (isis_ls(l1, l2)) {\n            is.emplace_back(k, is_ll(l1, l2));\n          }\n        }\n        sort(ALL(is));\n        do {\n          int k; P p;\n          tie(k, p) = is[0];\n          int l; P q;\n          tie(l, q) = is[1];\n          if (l < k) l += poly.size();\n          VP np;\n          np.push_back(p);\n          FOR(a,k+1,l+1) {\n            np.push_back(poly[a%poly.size()]);\n          }\n          np.push_back(q);\n          if (is_in_Polygon(np, vp[i]) > 0) {\n            poly = np;\n            break;\n          }\n        } while(next_permutation(ALL(is)));\n      }\n      cout <<fixed << setprecision(10)<< area(poly) << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nconst double PI=acos(-1);\n\nint Signum(double x){\n\treturn x<-EPS?-1:x>EPS?1:0;\n}\n\nstruct Point{\n\tdouble x,y;\n\tPoint(){}\n\tPoint(double x,double y):x(x),y(y){}\n\tPoint& operator+=(Point p){\n\t\tx+=p.x,y+=p.y;\n\t\treturn *this;\n\t}\n\tPoint& operator-=(Point p){\n\t\tx-=p.x,y-=p.y;\n\t\treturn *this;\n\t}\n\tPoint& operator*=(double c){\n\t\tx*=c,y*=c;\n\t\treturn *this;\n\t}\n\tPoint& operator/=(double c){\n\t\tx/=c,y/=c;\n\t\treturn *this;\n\t}\n};\nPoint operator+(Point a,Point b){\n\treturn a+=b;\n}\nPoint operator-(Point a,Point b){\n\treturn a-=b;\n}\nPoint operator*(Point a,double c){\n\treturn a*=c;\n}\nPoint operator*(double c,Point a){\n\treturn a*=c;\n}\nPoint operator/(Point a,double c){\n\treturn a/=c;\n}\nbool operator==(Point a,Point b){\n\treturn abs(a.x-b.x)<EPS && abs(a.y-b.y)<EPS;\n}\nbool operator!=(Point a,Point b){\n\treturn !(a==b);\n}\n\ndouble Abs(Point p){\n\treturn sqrt(p.x*p.x+p.y*p.y);\n}\ndouble Abs2(Point p){\n\treturn p.x*p.x+p.y*p.y;\n}\ndouble Arg(Point p){\n\treturn atan2(p.y,p.x);\n}\ndouble Dot(Point a,Point b){\n\treturn a.x*b.x+a.y*b.y;\n}\ndouble Cross(Point a,Point b){\n\treturn a.x*b.y-a.y*b.x;\n}\nPoint Rot(Point p,double t){\n\treturn Point(cos(t)*p.x-sin(t)*p.y,sin(t)*p.x+cos(t)*p.y);\n}\n\nstruct Line{\n\tPoint pos,dir;\n\tLine(){}\n\tLine(Point p,Point d):pos(p),dir(d){}\n\tLine(double px,double py,double dx,double dy):pos(px,py),dir(dx,dy){}\n};\n\nstruct Segment{\n\tPoint pos,dir;\n\tSegment(){}\n\tSegment(Point p,Point d):pos(p),dir(d){}\n\tSegment(double px,double py,double dx,double dy):pos(px,py),dir(dx,dy){}\n\texplicit Segment(Line l):pos(l.pos),dir(l.dir){}\n\texplicit operator Line()const{return Line(pos,dir);}\n};\n\nint CCW(Point a,Point b,Point c){\n\tb-=a,c-=a;\n\tif(int sign=Signum(Cross(b,c)))\n\t\treturn sign; // 1:ccw,-1:cw\n\tif(Dot(b,c)<-EPS)\n\t\treturn -2;   // c-a-b\n\tif(Abs2(b)<Abs2(c)-EPS)\n\t\treturn 2;    // a-b-c\n\treturn 0;        // a-c-b (inclusive)\n}\n\n// aとbは必ず交差していること\n// 同一直線上にある場合，a.posを返す\nPoint InterPointLL(Line a,Line b){\n\tif(abs(Cross(a.dir,b.dir))<EPS) return a.pos;\n\treturn a.pos+Cross(b.pos-a.pos,b.dir)/Cross(a.dir,b.dir)*a.dir;\n}\n// 同一直線上にある場合，s.posを返す\nPoint InterPointLS(Line l,Segment s){\n\treturn InterPointLL(Line(s),l);\n}\n\nvector<Point> ConvexCut(const vector<Point>& ps,Line l){\n\tint n=ps.size();\n\tvector<Point> res;\n\trep(i,n){\n\t\tint c1=CCW(l.pos,l.pos+l.dir,ps[i]);\n\t\tint c2=CCW(l.pos,l.pos+l.dir,ps[(i+1)%n]);\n\t\tif(c1!=-1)\n\t\t\tres.push_back(ps[i]);\n\t\tif(c1*c2==-1)\n\t\t\tres.push_back(InterPointLS(l,Segment(ps[i],ps[(i+1)%n]-ps[i])));\n\t}\n\treturn res;\n}\n\ndouble Area(const vector<Point>& ps){\n\tdouble res=0;\n\trepi(i,2,ps.size())\n\t\tres+=Cross(ps[i-1]-ps[0],ps[i]-ps[0])/2;\n\treturn res;\n}\n\nint main()\n{\n\tfor(int n,m;cin>>n>>m && n|m;){\n\t\tvector<Point> ps(n);\n\t\tfor(auto& p:ps) cin>>p.x>>p.y;\n\t\tvector<Point> cs(m);\n\t\tfor(auto& p:cs) cin>>p.x>>p.y;\n\t\t\n\t\tvd res(m);\n\t\trep(i,m){\n\t\t\tvector<Point> territory=ps;\n\t\t\trep(j,m) if(j!=i){\n\t\t\t\tLine border((cs[i]+cs[j])/2,Rot(cs[j]-cs[i],PI/2));\n\t\t\t\tterritory=ConvexCut(territory,border);\n\t\t\t}\n\t\t\tres[i]=Area(territory);\n\t\t}\n\t\trep(i,m) printf(\"%.10f\\n\",res[i]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cassert>\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\n#define x first\n#define y second\n\nusing namespace std;\n\ntypedef pair<double, double> Point;\n\nconst double PI = acos(-1.0);\nconst double EPS = 1e-9;\n\nclass Line {\n  public:\n    double a, b, c;\n\n    Line(const double _a = 0.0, const double _b = 0.0, const double _c = 0.0):\n      a(_a),\n      b(_b),\n      c(_c) {}\n\n    Line(const Point &p1, const Point &p2):\n      a(p1.y - p2.y),\n      b(p2.x - p1.x),\n      c(p1.x * p2.y - p1.y * p2.x) {}\n};\n\nvector<Line> Plane;\nvector<Point> Points;\nvector<double> Areas;\n\ninline double Det(const Point &a, const Point &b, const Point &c) {\n    return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\n}\n\ninline double GetAlpha(const Point &a, const Point &b, const Point &c) {\n    Point first = Point(a.x - b.x, a.y - b.y), second = Point(c.x - b.x, c.y - b.y);\n    double alpha = acos((first.x * second.x + first.y * second.y) / sqrt((first.x * first.x + first.y * first.y) * (second.x * second.x + second.y * second.y)));\n    if (Det(a, b, c) < -EPS)\n        return alpha + 2 * PI;\n    else\n        return alpha;\n}\n\nvector<Point> ConvexHull(vector<Point> points) {\n    int n = int(points.size());\n    int origin = 0;\n    for (int i = 1; i < n; ++i)\n        if (points[i] < points[origin])\n            origin = i;\n    swap(points[0], points[origin]);\n    vector<Point> hull;\n    hull.push_back(points[0]);\n    hull.push_back(points[1]);\n    for (int i = 2; i < n; ++i)\n        if (Det(hull[0], points[i], hull[1]) >= 0)\n            hull[1] = points[i];\n    do {\n        int next = -1;\n        double alpha = 0.0;\n        for (int i = 0; i < n; ++i) {\n            double currentAlpha = GetAlpha(hull[int(hull.size()) - 2], hull[int(hull.size()) - 1], points[i]);\n            if (currentAlpha > alpha) {\n                next = i;\n                alpha = currentAlpha;\n            }\n        }\n        hull.push_back(points[next]);\n    } while (hull.back() != hull.front());\n    hull.pop_back();\n    return hull;\n}\n\ninline Point Dualize(const Line &l) {\n    if (l.c == 0)\n        return Point(0, 0);\n    else\n        return Point(l.a / l.c, l.b / l.c);\n}\n\ninline Line Dualize(const Point &p) {\n    return Line(p.x, p.y, 1);\n}\n\ninline Point Translate(const Point &p, const Point &shift) {\n    return Point(p.x + shift.x, p.y + shift.y);\n}\n\ninline Line Translate(const Line &l, const Point &shift) {\n    return Line(l.a, l.b, l.c - l.a * shift.x - l.b * shift.y);\n}\n\nvector< vector<Point> > GetVoronoiDiagrams(const vector<Line> &plane, const vector<Point> &points) {\n    int n = int(points.size());\n    vector< vector<Point> > voronoiDiagrams = vector< vector<Point> >(n, vector<Point>());\n    for (int i = 0; i < n; ++i) {\n        Point shift = Point(-points[i].x, -points[i].y);\n        vector<Point> dualizedLines;\n        for (int j = 0; j < int(plane.size()); ++j)\n            dualizedLines.push_back(Dualize(Translate(plane[j], shift)));\n        for (int j = 0; j < n; ++j) {\n            if (i != j) {\n                Point a = points[i], b = points[j];\n                dualizedLines.push_back(Dualize(Translate(Line(2 * (b.x - a.x), 2 * (b.y - a.y), a.x * a.x + a.y * a.y - b.x * b.x - b.y * b.y), shift)));\n            }\n        }\n        vector<Point> hull = ConvexHull(dualizedLines);\n        for (int j = 0; j < int(hull.size()); ++j)\n            voronoiDiagrams[i].push_back(Translate(Dualize(Line(hull[j], hull[(j + 1) % int(hull.size())])), points[i]));\n    }\n    return voronoiDiagrams;\n}\n\ninline double GetArea(const vector<Point> &polygon) {\n    int n = int(polygon.size());\n    double area = 0.0;\n    for (int i = 0; i < n; ++i)\n        area += polygon[i].x * polygon[(i + 1) % n].y - polygon[(i + 1) % n].x * polygon[i].y;\n    area /= 2.0;\n    if (area < 0.0)\n        area = -area;\n    return area;\n}\n\nvoid Solve() {\n    vector< vector<Point> > voronoi = GetVoronoiDiagrams(Plane, Points);\n    Areas = vector<double>(int(Points.size()), 0.0);\n    for (int i = 0; i < int(Points.size()); ++i)\n        Areas[i] = GetArea(voronoi[i]);\n}\n\nbool Read() {\n    int n, m;\n    cin >> n >> m;\n    if (n == 0 && m == 0)\n        return false;\n    vector<Point> planePolygon = vector<Point>(n);\n    for (int i = 0; i < n; ++i)\n        cin >> planePolygon[i].x >> planePolygon[i].y;\n    Plane = vector<Line>(n);\n    for (int i = 0; i < n; ++i)\n        Plane[i] = Line(planePolygon[i], planePolygon[(i + 1) % n]);\n    Points = vector<Point>(m);\n    for (int i = 0; i < m; ++i)\n        cin >> Points[i].x >> Points[i].y;\n    return true;\n}\n\nvoid Print() {\n    for (int i = 0; i < int(Points.size()); ++i)\n        printf(\"%.7lf\\n\", Areas[i]);\n}\n\nint main() {\n    while (Read()) {\n        Solve();\n        Print();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);++i)\n#define rep2(i,a,b) for (int i=(a);i<(b);++i)\n#define rrep(i,n) for (int i=(n)-1;i>=0;--i)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;--i)\n#define chmin(a,b) (a)=min((a),(b));\n#define chmax(a,b) (a)=max((a),(b));\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) cout<<(#v)<<\":\";for(auto(x):(v)){cout<<\" \"<<(x);}cout<<endl;\n#define printVS(vs) cout<<(#vs)<<\":\"<<endl;for(auto(s):(vs)){cout<<(s)<< endl;}\n#define printVV(vv) cout<<(#vv)<<\":\"<<endl;for(auto(v):(vv)){for(auto(x):(v)){cout<<\" \"<<(x);}cout<<endl;}\n#define printP(p) cout<<(#p)<<(p).first<<\" \"<<(p).second<<endl;\n#define printVP(vp) cout<<(#vp)<<\":\"<<endl;for(auto(p):(vp)){cout<<(p).first<<\" \"<<(p).second<<endl;}\n\ninline void output(){ cout << endl; }\ntemplate<typename First, typename... Rest>\ninline void output(const First& first, const Rest&... rest) {\n    cout << first << \" \"; output(rest...);\n}\n\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing TUPLE = tuple<int, int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\nusing Graph = vector<vector<int>>;\n\ntypedef complex<long double> P;\ntypedef vector<P> G;\n#define here(g, i) g[i]\n#define next(g, i) g[(i + 1) % g.size()]\n#define prev(g, i) g[(i - 1 + g.size()) % g.size()]\nconst long double EPS = 1e-10;\nconst long double INF = 1e12;\nconst long double PI = acos(-1);\n\nstruct L {\n    P a, b, v;\n    L(){}\n    L(P _a, P _b) : a(_a), b(_b), v(b - a) {}\n    L(long double _ax, long double _ay, long double _bx, long double _by) : L(P(_ax, _ay), P(_bx, _by)) {}\n    void reverse() {\n        swap(a, b); v = b - a;\n    }\n};\n\nlong double cross(P a, P b) {\n    return imag(conj(a) * b);\n}\n\nlong double dot(P a, P b) {\n    return real(conj(a) * b);\n}\n\n// signed!!!!!!!!!\nlong double areaG(G g) {\n    int n = g.size();\n    long double ret = 0.l;\n    rep(i, n) {\n        ret += cross(here(g, i), next(g, i));\n    }\n    return ret / 2.l;\n}\n\nP readP() {\n    long double x, y;\n    cin >> x >> y;\n    return P(x, y);\n}\n\nG readG(int n) {\n    // int n;\n    // cin >> n;\n    G g(n);\n    rep(i, n) g[i] = readP();\n    return g;\n}\n\nL PerpendicularBisector(P p, P q) {\n    P c = (p + q) / 2.l;\n    P d = (q - p) / 2.l;\n    P h = d * P(0.l, 1.l);\n    return L(c + h, c - h);\n}\n\nint ccw(P p0, P p1, P p2) {\n    p1 -= p0; p2 -= p0;\n    if (cross(p1, p2) > 0.l) return +1;       // counter-clockwise\n    if (cross(p1, p2) < 0.l) return -1;       // clockwise\n    if (dot(p1, p2) < 0.l) return +2;         // p2 -- p0 -- p1\n    if (norm(p1) < norm(p2)) return -2;     // p0 -- p1 -- p2\n    return 0.l;                               // p0 -- p2 -- p1\n}\n\nP crosspointLL(L l1, L l2) {\n    return l1.a + l1.v * cross(l2.v, l2.a - l1.a) / cross(l2.v, l1.v);\n}\n\nG convex_cut(G g, L l) {\n    G h;\n    rep(i, (int)g.size()) {\n        P p = here(g, i), q = next(g, i);\n        if (ccw(p, q, l.a) == 0 && ccw(p, q, l.b) == 0) {\n            if (ccw(p, l.b, l.a) == 0) return g;    // p -- l.a -- l.b -- q\n            else return G{};                        // p -- l.b -- l.a -- q\n        }\n        if (ccw(l.a, l.b, p) != -1) h.emplace_back(p);\n        if (ccw(l.a, l.b, p) * ccw(l.a, l.b, q) < 0)\n        h.emplace_back(crosspointLL(L(p, q), l));\n    }\n    return h;\n}\n\nvector<G> Voronoi(G g, vector<P> p) {\n    vector<G> ret;\n    rep(i, p.size()) {\n        G h = g;\n        rep(j, p.size()) {\n            if (i == j) continue;\n            L l = PerpendicularBisector(p[i], p[j]);\n            if (ccw(l.a, l.b, p[i]) == -1) l.reverse();\n            h = convex_cut(h, l);\n        }\n        ret.emplace_back(h);\n    }\n    return ret;\n}\n\nmain() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int n, m;\n    while (cin >> n >> m, n) {\n        G g = readG(n);\n        vector<P> p(m);\n        rep(i, m) p[i] = readP();\n\n        auto vg = Voronoi(g, p);\n        rep(i, vg.size()) {\n            cout << fixed << setprecision(10) << abs<long double>(areaG(vg[i])) << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include <iostream>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <map>\n#include <functional>\n#include <stdio.h>\n#include <array>\n#include <algorithm>\n#include <string>\n#include <string.h>\n#include <assert.h>\n#include <stdio.h>\n#include <queue>\n#include<iomanip>\n#include<bitset>\n#include<stack>\n#include<set>\n#include<limits>\n#include <complex>\n#include<cstdlib>\nusing namespace std;\n\n\n/* 幾何の基本 */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// 点の入力\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// 誤差つき等号判定\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// 内積\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);\n}\n\n// 外積\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n\n// 直線の定義\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num) {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse assert(false);\n\t}\n};\n\n// 円の定義\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // a,b,cが反時計周りの順に並ぶ\n\tif (cross(b, c) < -eps) return -1; // a,b,cが時計周りの順に並ぶ\n\tif (dot(b, c) < 0) return 2;       // c,a,bの順に直線に並ぶ\n\tif (norm(b) < norm(c)) return -2;  // a,b,cの順に直線に並ぶ\n\treturn 0;                          // a,c,bの順に直線に並ぶ\n}\n\n\n/* 交差判定 */\n\n// 直線と直線の交差判定\nbool isis_ll(Line l, Line m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// 直線と線分の交差判定\nbool isis_ls(Line l, Line s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// 線分と線分の交差判定\nbool isis_ss(Line s, Line t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// 点の直線上判定\nbool isis_lp(Line l, Point p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// 点の線分上判定\nbool isis_sp(Line s, Point p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// 垂線の足\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// 直線と直線の交点\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// 直線と点の距離\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n\n// 直線と直線の距離\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// 直線と線分の距離\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// 線分と点の距離\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// 線分と線分の距離\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n/* 円 */\n\n// 円と円の交点\nvector<Point> is_cc(Circle c1, Circle c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n// 円と直線の交点\nvector<Point> is_lc(Circle c, Line l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// 円と線分の距離\nvector<Point> is_sc(Circle c, Line l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// 円と点の接線\nvector<Line> tangent_cp(Circle c, Point p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// 円と円の接線\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\n\n/* 多角形 */\n\ntypedef vector<Point> Polygon;\n\n// 面積\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// 多角形の回転方向\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// 円の内外判定\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_polygon(const Polygon &poly, Point p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n\n// 凸包\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n// 凸カット\nvector<Polygon> convex_cut(const Polygon &ps, const Line l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tvector<Polygon>polys;\n\tif (!Q.empty()) {\n\t\tpolys.push_back(Q);\n\t}\n\tif (!R.empty()) {\n\t\tpolys.push_back(R);\n\t}\n\treturn polys;\n}\n\n\n/* アレンジメント */\nvoid add_point(vector<Point> &ps, Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\n\nstruct Edge { int from, to; Weight weight; };\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, int from, int to, Weight weight) {\n\tg[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, abs(p[from] - p[to]));\n\t\t}\n\t}\n\treturn g;\n}\n\nGraph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n\tint n = p.size(), m = c.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tld angle = vec[j + 1].first - vec[j].first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t\tif (vec.size() >= 2) {\n\t\t\tint from = vec.back().second, to = vec.front().first;\n\t\t\tld angle = vec.front().first - vec.back().first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t}\n\treturn g;\n}\n\n\n/* 双対グラフ */\n\n// 線分集合は既にアレンジメントされていなければならない．\n// 内側の円は時計回りで，外側の円は反時計回りで得られる．\n// 変数 polygon は，vector<int> で表される多角形の集合であり，\n// vector<int> で表される 多角形のi番目は，その頂点の頂点集合pにおける番号である．\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\nGraph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n\tint N = p.size();\n\tpolygon.clear();\n\tREP(i, 1024) REP(j, 1024) seg2p[i][j].clear();\n\tvector<vector<tuple<ld, int, bool>>> tup(N);\n\tREP(i, s.size()) {\n\t\tint a = -1, b = -1;\n\t\tREP(j, N) if (abs(s[i].a - p[j]) < eps) a = j;\n\t\tREP(j, N) if (abs(s[i].b - p[j]) < eps) b = j;\n\t\tassert(a >= 0 && b >= 0);\n\t\ttup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n\t\ttup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n\t}\n\tREP(i, N) sort(ALL(tup[i]));\n\tREP(i, N) {\n\t\tREP(j, tup[i].size()) {\n\t\t\tld angle; int pos = j, from = i, to; bool flag;\n\t\t\ttie(angle, to, flag) = tup[i][j];\n\t\t\tif (flag) continue;\n\t\t\tvector<int> ps;\n\t\t\twhile (!flag) {\n\t\t\t\tps.push_back(from);\n\t\t\t\tget<2>(tup[from][pos]) = true;\n\t\t\t\tseg2p[from][to].push_back(polygon.size());\n\t\t\t\tseg2p[to][from].push_back(polygon.size());\n\t\t\t\tangle += pi + eps;\n\t\t\t\tif (angle > pi) angle -= 2 * pi;\n\t\t\t\tauto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n\t\t\t\tif (it == tup[to].end()) it = tup[to].begin();\n\t\t\t\tfrom = to; tie(angle, to, flag) = *it;\n\t\t\t\tpos = it - tup[from].begin();\n\t\t\t}\n\t\t\tpolygon.push_back(ps);\n\t\t}\n\t}\n\tGraph g(polygon.size());\n\tREP(i, N) REP(j, i) {\n\t\tif (seg2p[i][j].size() == 2) {\n\t\t\tint from = seg2p[i][j][0], to = seg2p[i][j][1];\n\t\t\tg[from].push_back(Edge{ from, to });\n\t\t\tg[to].push_back(Edge{ to, from });\n\t\t}\n\t}\n\treturn g;\n}\n\n\n/* ビジュアライザ */\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(int r, int g, int b) {\n\tfprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\nint cordx(Point p) { return 400 + zoom * (p.real() - centerX); }\nint cordy(Point p) { return 400 - zoom * (p.imag() - centerY); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(Point p) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(Line l) {\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(Line l) {\n\tPoint v = l.b - l.a;\n\tLine m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n\tint n = p.size();\n\tREP(i, n) draw_segment(Line(p[i], p[(i + 1) % n]));\n}\n\nvoid draw_circle(Circle c) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\n\nvector<Polygon>polys;\nvector<int>hs;\nvector<long double>diss;\n\n\nbool check(const long double rad) {\n\tfor (int i = 0; i < hs.size(); ++i) {\n\t\tif (hs[i] > rad) {\n\t\t\tif (diss[i] < rad)return false;\n\t\t}\n\t\telse {\n\t\t\tlong double needdis = sqrt(rad*rad - (rad - hs[i])*(rad - hs[i]));\n\t\t\tif (diss[i] < needdis)return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nint main() {\n\tint N, M; cin >> N >> M;\n\tPolygon island;\n\tfor (int i = 0; i < N; ++i) {\n\t\tint x, y; cin >> x >> y;\n\t\tPoint p(x, y);\n\t\tisland.emplace_back(p);\n\t}\n\tvector<Point>castles;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint x, y; cin >> x >> y;\n\t\tcastles.emplace_back(x,y);\n\t}\n\n\tfor (int mylord = 0; mylord < M; ++mylord) {\n\t\tPolygon myarea(island);\n\t\tfor (int oplord = 0; oplord < M; ++oplord) {\n\t\t\tif (mylord == oplord)continue;\n\t\t\telse {\n\t\t\t\tLine tie(castles[mylord], castles[oplord]);\n\t\t\t\tPoint midp((castles[mylord] + castles[oplord]) / 2.0l);\n\t\t\t\tcomplex<long double>nc((castles[mylord] - castles[oplord])*complex<long double>(0, 1));\n\t\t\t\tPoint verp(midp + nc);\n\t\t\t\tLine perpen(midp, verp);\n\t\t\t\tvector<Polygon> twoislands(convex_cut(myarea, perpen));\n\t\t\t\tif (is_in_polygon(twoislands[0], castles[mylord]) >= 1) {\n\t\t\t\t\tmyarea = twoislands[0];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmyarea = twoislands[1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<setprecision(22)<<abs(area(myarea)) << endl;\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\ntypedef complex<double> P;\nnamespace std{\n\tbool operator<(const P& a, const P& b){\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\ninline double cross(const P& a, const P& b){ return imag(conj(a)*b); }\ninline double dot(const P& a, const P& b){ return real(conj(a)*b); }\nstruct L : public vector<P>{\n\tL(const P &a, const P &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\ntypedef vector<P> G;\ninline int ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif(cross(b, c) > 0)   return +1;\t\t// counter clockwise\n\tif(cross(b, c) < 0)   return -1;\t\t// clockwise\n\tif(dot(b, c) < 0)     return +2;\t\t// c--a--b on line\n\tif(norm(b) < norm(c)) return -2;\t\t// a--b--c on line\n\treturn 0;\n}\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\ndouble area2(const G& g) {\n  double A = 0;\n  for (int i = 0; i < g.size(); ++i) \n    A += cross(curr(g, i), next(g, i));\n  return A;\n}\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\nG convex_cut(const G& po, const L& l) {\n  G Q;\n  for (int i = 0; i < po.size(); ++i) {\n    P A = curr(po, i), B = next(po, i);\n    if (ccw(l[0], l[1], A) != -1) Q.push_back(A);\n    if (ccw(l[0], l[1], A)*ccw(l[0], l[1], B) < 0)\n      Q.push_back(crosspoint(L(A, B), l));\n  }\n  return Q;\n}\nG voronoi(const G &g, G S, int idx){\n\trep(i, g.size()) if(i != idx){\n\t\tP d = (g[i] - g[idx]) * P(0, 1);\n\t\tP m = (g[i] + g[idx]) * 0.5;\n\t\tL l(m, m + d);\n\t\tS = convex_cut(S, l);\n\t}\n\treturn S;\n}\n\nint main(){\n\tint n, m;\n\twhile(cin >> n >> m, n){\n\t\tG l(n), p(m);\n\t\trep(i, n) cin >> l[i].real() >> l[i].imag();\n\t\trep(i, m) cin >> p[i].real() >> p[i].imag();\n\t\tvector<G> v;\n\t\trep(i, m) printf(\"%.9f\\n\", abs(area2(voronoi(p, l, i)) * 0.5));\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\nint sign(double r){ return (r < -EPS) ? -1 : (r > EPS) ? 1 : 0; }\nbool eq(double a, double b){ return abs(b - a) < EPS; }\n\nstruct Point{\n  double x, y;\n  Point() {}\n  Point(double x, double y) : x(x), y(y) {}\n  Point operator+(const Point& b) const { return Point(x + b.x, y + b.y); }\n  Point operator-(const Point& b) const { return Point(x - b.x, y - b.y); }\n  Point operator*(const double b) const { return Point(x * b, y * b); }\n  Point operator*(const Point& b) const { return Point(x * b.x - y * b.y, x * b.y + y * b.x); }\n  Point operator/(const double b) const { return Point(x / b, y / b); }\n  bool operator< (const Point& b) const { return x != b.x ? x < b.x : y < b.y; }\n  bool operator==(const Point& b) const { return eq(x, b.x) && eq(y, b.y); }\n  double norm(){ return x * x + y * y; }\n  double arg(){ return atan2(x, y); }\n  double abs(){ return sqrt(norm()); }\n  Point rotate(double theta){ return Point(cos(theta) * x - sin(theta) * y, sin(theta) * x + cos(theta) * y); }\n  Point rotate90(){ return Point(-y, x); }\n};\n\nostream& operator<<(ostream& os, Point& p){ return os<<\"(\"<<p.x<<\",\"<<p.y<<\")\"; }\nistream& operator>>(istream& is, Point& a){ return is>>a.x>>a.y; }\ndouble dot(const Point& a, const Point& b){ return a.x * b.x + a.y * b.y; }\ndouble cross(const Point& a, const Point& b){ return a.x * b.y - a.y * b.x; }\nPoint polor(double rho, double theta){ return Point(rho * cos(theta), rho * sin(theta)); }\n\nstruct Line : public vector<Point> {\n  Line(const Point& a, const Point& b) {\n    push_back(a); push_back(b);\n  }\n  Point vector() const {\n    return back() - front();\n  }\n};\nstruct Circle : Point {\n  double r;\n  Circle(Point p, double r) : Point(p), r(r) { }\n};\ntypedef vector<Point> Polygon;\nPoint curr(const Polygon& a, int x){ return a[x]; }\nPoint next(const Polygon& a, int x){ return a[(x + 1) % a.size()]; }\nPoint prev(const Polygon& a, int x){ return a[(x - 1 + a.size()) % a.size()]; }\n\n//a->b->c\nint ccw(Point a, Point b, Point c) {\n  b = b - a; c = c - a;\n  if (cross(b, c) > EPS)   return +1; // 反時計回り\n  if (cross(b, c) < -EPS)   return -1; // 時計回り\n  if (dot(b, c) < 0)     return +2; // c--a--b の順番で一直線上\n  if (b.norm() < c.norm()) return -2; // a--b--c の順番で一直線上\n  return 0;                         // a--c--b の順番で一直線上\n}\n// 二直線の交差判定\nbool intersectLL(const Line& l, const Line& m) {\n  return abs(cross(l.vector(), m[1] - m[0])) > EPS || // 傾きが異なる\n         abs(cross(l.vector(), m[0] - l[0])) < EPS;   // 同じ直線である\n}\n// 直線と線分の交差判定\nbool intersectLS(const Line& l, const Line& s) {\n  return cross(l.vector(), s[0] - l[0]) * cross(l.vector(), s[1] - l[0]) < EPS; //直線lについて、線分sの端点が異なる側にある\n}\n// 直線と点の交差判定\nbool intersectLP(const Line& l, const Point& p) {\n  return abs(ccw(l[0], l[1], p)) != 1;\n}\n// 二つの線分の交差判定\nbool intersectSS(const Line& s, const Line& t) {\n  return ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n         ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\n// 線分と点の交差判定\nbool intersectSP(const Line& s, const Point& p) {\n  return ccw(s[0], s[1], p) == 0;\n}\n// 円と点の交差判定(EPS注意)\nbool intersectCP(const Circle& c, const Point& p){\n  return (c - p).abs() < c.r + EPS;\n}\n// 二つの円の交差判定(EPS注意)\nbool intersectCC(const Circle& c, const Circle& d){\n  return (c - d).abs() < c.r + d.r + EPS && (c - d).abs() > abs(c.r - d.r) - EPS;\n}\n// 射影\nPoint projection(const Line& l, const Point& p){\n  double t = dot(p - l[0], l.vector()) / l.vector().norm();\n  return l[0] + l.vector() * t;\n}\n// 反射\nPoint reflection(const Line& l, const Point& p){\n  return p + (projection(l, p) - p) * 2;\n}\n// 直線と点の距離\ndouble distanceLP(const Line& l, const Point& p){\n  return (p - projection(l, p)).abs();\n}\n// 二直線の距離\ndouble distanceLL(const Line& l, const Line& m){\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\n// 直線と線分の距離\ndouble distanceLS(const Line& l, const Line& s){\n  if(intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\n// 線分と点の距離\ndouble distanceSP(const Line& s, const Point& p){\n  const Point r = projection(s, p);\n  if(intersectSP(s, r)) return (r - p).abs(); //垂線が線分に交わるとき\n  return min((s[0] - p).abs(), (s[1] - p).abs());\n}\n// 二つの線分の距離\ndouble distanceSS(const Line& s, const Line& t){\n  if(intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n// 二直線の交点\nPoint crosspointLL(const Line& l, const Line& m){\n  double d = cross(m.vector(), l.vector());\n  if(abs(d) < EPS) while(true){} // 直線が交わらない\n  return l[0] + l.vector() * cross(m.vector(), m[1] - l[0]) * (1.0 / d);\n}\n\nPolygon convex_cut(const Polygon& P, const Line& l){\n  Polygon Q;\n  REP(i, P.size()){\n    Point A = curr(P, i), B = next(P, i);\n    if(ccw(l[0], l[1], A) != -1) Q.push_back(A); //Aが直線lの右側でない\n    if(intersectLS(l, Line(A, B))) \n      Q.push_back(crosspointLL(l, Line(A, B)));\n  }\n  return Q;\n}\nLine median(const Point& a, const Point& b){\n  Point mid((a.x + b.x) / 2.0, (a.y + b.y) / 2.0);\n  Point vec = (mid - a).rotate90();\n  return Line(mid, mid + vec);\n}\n\ndouble area(const Polygon& P) {\n  double A = 0;\n  REP(i, P.size()){\n    A += cross(curr(P, i), next(P, i));\n  }\n  return A / 2.0;\n}\nint main(){\n  int N, M;\n  while(cin>>N>>M){\n    Polygon island(N);\n    REP(i, N) cin>>island[i];\n    vector<Point> castle(M);\n    REP(i, M) cin>>castle[i];\n    REP(i, M){\n      Polygon land = island;\n      REP(j, M) if(i != j){\n        land = convex_cut(land, median(castle[i], castle[j]));\n      }\n      printf(\"%.6lf\\n\", area(land));\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <math.h>\n#include <complex>\n#include <vector>\n#include <assert.h>\n\nstatic const double EPS = 1e-5;\nusing namespace std;\n\ntypedef complex<double> Complex;\ntypedef vector<Complex> Polygon;\n\ndouble cross(const Complex a, Complex b) {\n  return imag(conj(a) * b);\n}\n\ndouble dot(Complex a, Complex b) {\n  return real(conj(a) * b);\n}\n\ndouble ccw(Complex a, Complex b) {\n  return a.real() * b.imag() - a.imag() * b.real();\n}\n\nint ccw3(Complex a, Complex b, Complex c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0) return 1;\n  if (cross(b, c) < 0) return -1;\n  if (dot(b, c) < 0) return +2;\n  if (dot(b, c) > 0) return -2;\n  return 0;\n}\n\ndouble area(Complex a, Complex b, Complex c) {\n  Complex v1 = b - a;\n  Complex v2 = c - a;\n  return abs(v1.real() * v2.imag() - v2.real() * v1.imag()) / 2.0;\n}\n\nComplex intersection(const Complex s1, Complex e1, Complex s2, Complex e2) {\n  double a = cross(e1 - s1, e2 - s2);\n  double b = cross(e1 - s1, e1 - s2);\n  if (abs(a) < EPS && abs(b) < EPS) { return s2; }\n  if (abs(a) < EPS) { assert(false); }\n  return s2 + b / a * (e2 - s2);\n}\n\nPolygon convex_cut(const Polygon &P, const Complex s1, const Complex e1) {\n  Polygon Q;\n  for (int i = 0; i < (int)P.size(); i++) {\n    Complex a = P[i];\n    Complex b = P[0];\n    if (i != (int)P.size() - 1) {\n      b = P[i + 1];\n    }\n    if (ccw3(s1, e1, a) != -1) { Q.push_back(a); }\n    if (ccw3(s1, e1, a) * ccw3(s1, e1, b) < EPS) {\n      Q.push_back(intersection(s1, e1, a, b));\n    }\n  }\n  return Q;\n}\n\nvoid tyuusen(Complex a, Complex b, Complex &s1, Complex &e1) {\n  Complex center = (a + b) / 2.0;\n  s1 = center + (b - a) * Complex(0.0, -1000.0);\n  e1 = center + (b - a) * Complex(0.0, 1000.0);\n}\n\nPolygon island;\nComplex point[100];\n\nint main() {\n  int n, m;\n  while (scanf(\"%d %d\", &n, &m), n|m) {\n  for (int i = 0; i < n; i++) {\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    island.push_back(Complex(a, b));\n  }\n  for (int i = 0; i < m; i++) {\n    int a, b;\n    scanf(\"%d %d\", &a, &b);\n    point[i] = Complex(a, b);\n  }\n  for (int i = 0; i < m; i++) {\n    Polygon voronoi = island;\n    for (int j = 0; j < m; j++) {\n      if (i == j) { continue; }\n      Complex a, b;\n      tyuusen(point[i], point[j], a, b);\n      voronoi = convex_cut(voronoi, a, b);\n    }\n    double ans = 0.0;\n    for (int k = 0; k < (int)voronoi.size(); k++) {\n      Complex next = voronoi[0];\n      if (k != (int)voronoi.size() - 1) { next = voronoi[k + 1]; }\n      if (abs(voronoi[k].real() - next.real()) < EPS && abs(voronoi[k].imag() - next.imag()) < EPS) { continue; }\n      ans += area(point[i], voronoi[k], next);\n    }\n    printf(\"%lf\\n\", ans);\n  }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\ntypedef complex<double> Point;\ntypedef Point Vector;\nstruct Segment{\t\t\t\t\t//線分を表す構造体\n\tPoint p1, p2;\n\tSegment(Point p1 = Point(), Point p2 = Point()) : p1(p1), p2(p2) {}\n};\ntypedef Segment Line;\t\t\t//直線を表す構造体\ntypedef vector<Point> Polygon;\t//多角形を表す構造体\n\nnamespace std{\n\tbool operator < (const Point &a, const Point &b){\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n\tbool operator == (const Point &a, const Point &b){\n\t\treturn a.real() == b.real() && a.imag() == b.imag();\n\t}\n}\n\nclass Circle{\n\tpublic:\n\t\tPoint p;\n\t\tdouble r;\n\t\tCircle(Point p = Point(), double r = 0.0): p(p), r(r) {}\n};\n\n// 許容する誤差\n#define EPS (1e-10)\n#define INF (1e10)\n\n// ベクトルaの絶対値を求める\n//double length = abs(a);\n\n// 2点a,b間の距離を求める\n//double distance = abs(a-b);\n\n/*\n// ベクトルaの単位ベクトルを求める\nPoint b = a / abs(a);\n\n// ベクトルaの法線ベクトルn1,n2を求める\nPoint n1 = a * Point(0, 1);\nPoint n2 = a * Point(0, -1);\n*/\n\nint ccw(Point, Point, Point);\n\n// 2つのスカラーが等しいかどうか\nbool EQ(double a, double b){\n\treturn (abs(a - b) < EPS);\n}\n\n// 2つのベクトルが等しいかどうか\nbool EQV(Vector a, Vector b){\n\treturn ( EQ(a.real(), b.real()) && EQ(a.imag(), b.imag()) );\n}\n\n// 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(Point a, Point b) {\n\treturn (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// 外積 (cross product) : a×b = |a||b|sinΘ\ndouble cross(Point a, Point b) {\n\treturn (a.real() * b.imag() - a.imag() * b.real());\n}\n\n// 2直線の直交判定 : a⊥b <=> dot(a, b) = 0\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n\treturn EQ( dot(a1-a2, b1-b2), 0.0 );\n}\nbool isOrthogonal(Line s1, Line s2) { return isOrthogonal(s1.p1, s1.p2, s2.p1, s2.p2); }\n\n// 2直線の平行判定 : a//b <=> cross(a, b) = 0\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n\treturn EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isParallel(Line s1, Line s2) { return isParallel(s1.p1, s1.p2, s2.p1, s2.p2); }\n\n// 点cが直線a,b上にあるかないか\nbool isPointOnLine(Point a, Point b, Point c) {\n\treturn EQ( cross(b-a, c-a), 0.0 );\n}\nbool isPointOnLine(Line s, Point c) { return isPointOnLine(s.p1, s.p2, c); }\n\n// 点a,bを通る直線と点cとの距離\ndouble distanceLPoint(Point a, Point b, Point c) {\n\treturn abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLPoint(Line s, Point c) { return distanceLPoint(s.p1, s.p2, c); }\n\n// 点a,bを端点とする線分と点cとの距離\ndouble distanceLsPoint(Point a, Point b, Point c) {\n\tif ( dot(b-a, c-a) < EPS ) return abs(c-a);\n\tif ( dot(a-b, c-b) < EPS ) return abs(c-b);\n\treturn abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLsPoint(Segment s, Point c) { return distanceLsPoint(s.p1, s.p2, c); }\n\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交差判定\n// 端点が重なる場合も、線分が交差しているとみなす\nbool isIntersectedLs(Point a1, Point a2, Point b1, Point b2) {\n\treturn ( ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 &&\n\t\t\tccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0 );\n}\nbool isIntersectedLs(Segment s1, Segment s2) { return isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2); }\n\n// 端点が重なっているかを検出する\nbool isContainSamePoints(Segment s1, Segment s2){\n\tif(abs(s1.p1 - s2.p1) < EPS) return true;\n\tif(abs(s1.p1 - s2.p2) < EPS) return true;\n\tif(abs(s1.p2 - s2.p1) < EPS) return true;\n\tif(abs(s1.p2 - s2.p2) < EPS) return true;\n\treturn false;\n}\n\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交点計算\nPoint intersectionLs(Point a1, Point a2, Point b1, Point b2) {\n\tVector base = b2 - b1;\n\tdouble d1 = abs(cross(base, a1 - b1));\n\tdouble d2 = abs(cross(base, a2 - b1));\n\tdouble t = d1 / (d1 + d2);\n\n\treturn Point(a1 + (a2 - a1) * t);\n}\nPoint intersectionLs(Segment s1, Segment s2) { return intersectionLs(s1.p1, s1.p2, s2.p1, s2.p2); }\n\n// a1,a2を通る直線とb1,b2を通る直線の交差判定\nbool isIntersectedL(Point a1, Point a2, Point b1, Point b2) {\n\treturn !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isIntersectedL(Line l1, Line l2) { return isIntersectedL(l1.p1, l1.p2, l2.p1, l2.p2); }\n\n// a1,a2を通る直線とb1,b2を通る直線の交点計算\nPoint intersectionL(Point a1, Point a2, Point b1, Point b2) {\n\tPoint a = a2 - a1; Point b = b2 - b1;\n\treturn a1 + a * cross(b, b1-a1) / cross(b, a);\n}\nPoint intersectionL(Line l1, Line l2) { return intersectionL(l1.p1, l1.p2, l2.p1, l2.p2); }\n\n// 線分s1と線分s2の距離\ndouble distanceLL(Segment s1, Segment s2){\n\tif(isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2) ) return 0.0;\n\treturn min(\n\t\t\tmin(distanceLsPoint(s1.p1, s1.p2, s2.p1),\n\t\t\t\tdistanceLsPoint(s1.p1, s1.p2, s2.p2)),\n\t\t\tmin(distanceLsPoint(s2.p1, s2.p2, s1.p1),\n\t\t\t\tdistanceLsPoint(s2.p1, s2.p2, s1.p2)) );\n}\ndouble distanceLL(Point p0, Point p1, Point p2, Point p3){\n\tSegment s1 = Segment{p0, p1}, s2 = Segment{p2, p3};\n\treturn distanceLL(s1, s2);\n}\n\n// 線分sに対する点pの射影\nPoint project(Segment s, Point p){\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / norm(base);\n\treturn Point(s.p1 + base * r);\n}\n\n//線分sを対象軸とした点pの線対称の点\nPoint reflect(Segment s, Point p){\n\treturn Point(p + (project(s, p) - p) * 2.0);\n}\n\n//点pをangle分だけ時計回りに回転\nPoint rotation(Point p, double angle){\n\tdouble x, y;\n\tx = p.real() * cos(angle) - p.imag() * sin(angle);\n\ty = p.real() * sin(angle) + p.imag() * cos(angle);\n\treturn Point(x, y);\n}\n\n//円cと線分lの交点\npair<Point, Point> getCrossPoints(Circle c, Line l){\n\tVector pr = project(l, c.p);\n\tVector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\tdouble base = sqrt(c.r * c.r - norm(pr - c.p));\n\treturn make_pair(pr + e * base, pr - e * base);\n}\n\n//円c1と円c2の交点\ndouble arg(Vector p) { return atan2(p.imag(), p.real()); }\nVector polar(double a, double r) { return Point(cos(r) * a, sin(r) *a); }\n\npair<Point, Point> getCrossPoints(Circle c1, Circle c2){\n\tdouble d = abs(c1.p - c2.p);\n\tdouble a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n\tdouble t = arg(c2.p - c1.p);\n\treturn make_pair(Point(c1.p + polar(c1.r, t + a)), Point(c1.p + polar(c1.r, t - a)));\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2){\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n\tif( cross(a, b) < -EPS ) return CLOCKWISE;\n\tif( dot(a, b) < -EPS ) return ONLINE_BACK;\n\tif( abs(a) < abs(b) ) return ONLINE_FRONT;\n\n\treturn ON_SEGMENT;\n}\n\nPoint getCrossPointLL(Line a, Line b){\n\tdouble A = cross(a.p2 - a.p1, b.p2 - b.p1);\n\tdouble B = cross(a.p2 - a.p1, a.p2 - b.p1);\n\tif(abs(A) < EPS && abs(B) < EPS) return b.p1;\n\treturn b.p1 + (b.p2 - b.p1) * (B / A);\n}\n\nPolygon convexCut(Polygon p, Line l) {\n\tPolygon q;\n\trep(i,p.size()){\n\t\tPoint a = p[i], b = p[(i + 1) % p.size()];\n\t\tif (ccw(l.p1, l.p2, a) != -1) q.emplace_back(a);\n\t\tif (ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0){\n\t\t\tq.emplace_back(getCrossPointLL(Line{a, b}, l));\n\t\t}\n\t}\n\treturn q;\n}\n\nLine bisector(Point a, Point b) {\n\tPoint A = (a + b) * Point(0.5, 0);\n\treturn Line(A, A + (b - a) * Point(0, M_PI / 2));\n}\n\nPolygon voronoiCell(Polygon g, vector<Point> v, int s) {\n\trep(i, v.size()){\n\t\tif (i != s) g = convexCut(g, bisector(v[s], v[i]));\n\t}\n\treturn g;\n}\n\n//三角形の面積\ndouble areaOfTriangle(Point a, Point b, Point c){\n\tdouble w, x, y, z;\n\tw = b.real()-a.real();\n\tx = b.imag()-a.imag();\n\ty = c.real()-a.real();\n\tz = c.imag()-a.imag();\n\treturn abs((w * z - x * y) / 2);\n}\n\n//多角形の面積\ndouble areaOfPolygon(Polygon g){\n\tint n = g.size();\n\tdouble ret = 0.0;\n\trep(i,n) ret += cross(g[i], g[ (i + 1) % n ]);\n\treturn abs(ret) / 2.0;\n}\n\nint main(){\n\tint n, m;\n\twhile(cin >> n >> m, n){\n\t\tPolygon g(n);\n\t\trep(i,n){\n\t\t\tdouble a, b;\n\t\t\tcin >> a >> b;\n\t\t\tg[i] = Point(a,b);\n\t\t}\n\n\t\tvector<Point> v(m);\n\t\trep(i,m){\n\t\t\tdouble a, b;\n\t\t\tcin >> a >> b;\n\t\t\tv[i] = Point(a,b);\n\t\t}\n\n\t\trep(i,m){\n\t\t\tcout << fixed << setprecision(5) << areaOfPolygon(voronoiCell(g, v, i)) << endl;\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\nusing namespace std;\ntypedef double D;\nconst D EPS = 1e-8;\nstruct P {\n  D x, y;\n  P() { }\n  P(D x_, D y_) : x(x_), y(y_) { }\n};\nstruct L {\n  P a, b;\n  L() { }\n  L(P a_, P b_) : a(a_), b(b_) { }\n};\nstruct C {\n  P p; D r;\n  C() { }\n  C(P p_, D r_) : p(p_), r(r_) { }\n};\nP operator +(P a, P b) { return P(a.x + b.x, a.y + b.y); }\nP operator -(P a, P b) { return P(a.x - b.x, a.y - b.y); }\nP operator *(P a, D b) { return P(a.x * b, a.y * b); }\nP operator /(P a, D b) { return P(a.x / b, a.y / b); }\nP vec(P from, P to) { return to - from; }\nD inp(P a, P b) { return a.x*b.x + a.y*b.y; }\nD outp(P a, P b) { return a.x*b.y - a.y*b.x; }\nD norm(P p) { return inp(p, p); }\nD abs(P p) { return sqrt(norm(p)); }\nint sig(D a, D b) {\n  if(a < b - EPS) return -1;\n  if(a > b + EPS) return +1;\n  return 0;\n}\n// !!! とりあえずここまで写してください !!!\nD arg(P p) { return atan2(p.y, p.x); }\nP rot90(P p) { return P(-p.y, p.x); }\nP rot(P p, D radian) {\n  P q;\n  q.x = cos(radian)*p.x - sin(radian)*p.y;\n  q.y = sin(radian)*p.x + cos(radian)*p.y;\n  return q;\n}\nint ccw(P a, P b, P c) { // 重なっている点があるとうまく動かないと思われる\n  b = vec(a, b); c = vec(a, c);\n\n  // a - b - c が折れ曲がるとき\n  if(sig(outp(b, c), 0.0) > 0) return +1; // 反時計回り\n  if(sig(outp(b, c), 0.0) < 0) return -1; // 時計回り\n\n  // a - b - c が直線上に並ぶとき\n  if(sig(inp(b, c), 0.0) < 0) return +2; // c - a - b\n  if(norm(b) < norm(c))       return -2; // a - b - c\n  return 0;                              // a - c - b\n}\nP projection(L l, P p) { // 直線lに対する点pの写像\n  P a = vec(l.a, l.b);\n  P b = vec(l.a, p);\n  D t = inp(a, b) / norm(a);\n  return l.a + a * t;\n}\nP reflection(L l, P p) { // 直線lに対する点pの反射\n  return p + vec(p, projection(l, p)) * 2;\n}\n\n// 線分と点\nbool iSP(L s, P p) {\n  return ccw(s.a, s.b, p) == 0;\n}\nD dSP(L s, P p) {\n  P r = projection(s, p);\n  if(iSP(s, r)) return abs(p - r); // 写像がs上にある\n  return min(abs(p - s.a), abs(p - s.b)); // 写像がs上にない\n}\n\n// 直線と点\nbool iLP(L l, P p) {\n  return abs(ccw(l.a, l.b, p)) != 1;\n}\nD dLP(L l, P p) {\n  return abs(p - projection(l, p));\n}\n\n// 線分と線分\nbool iSS(L s, L t) { // 端を含む\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n    ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\nD dSS(L s, L t) {\n  if(iSS(s, t)) return 0;\n  return min(min(dSP(s, t.a), dSP(s, t.b)),\n      min(dSP(t, s.a), dSP(t, s.b)));\n}\n// P cSS(L s, L t) はiSS(s,t)を確認してからcLLを使う\n\n// 直線と直線\nbool iLL(L l, L m) {\n  return sig(outp(vec(l.a, l.b), vec(m.a, m.b)), 0.0) != 0 || // 平行でない\n    sig(outp(vec(l.a, l.b), vec(l.a, m.a)), 0.0) == 0;   // 同じ直線\n}\nD dLL(L l, L m) {\n  return iLL(l, m) ? 0.0 : dLP(l, m.a);\n}\nP cLL(L l, L m) {\n  D d = outp(vec(m.a, m.b), vec(l.a, l.b));\n  return l.a + vec(l.a, l.b) * outp(vec(m.a, m.b), vec(l.a, m.b)) / d;\n}\n\n// 直線と線分\nbool iLS(L l, L s) {\n  return sig(outp(vec(l.a, l.b), vec(l.a, s.a)), 0.0) *\n    sig(outp(vec(l.a, l.b), vec(l.a, s.b)), 0.0) <= 0;\n}\nD dLS(L l, L s) {\n  if(iSS(l, s)) return 0.0;\n  return min(dLP(l, s.a), dLP(l, s.b));\n}\n// P cLS(L s, L t) はiSS(s,t)を確認してからcLLを使う\n\n// 円と直線\nint iCL(C c, L l) {\n  D d = dLP(l, c.p);\n  int s = sig(d, c.r);\n  if(s < 0) return 2;\n  if(s == 0) return 1;\n  return 0;\n}\nvector<P> cCL(C c, L l) {\n  P a = projection(l, c.p);\n  D s = abs(c.p - a);\n  D t = sqrt(c.r*c.r-s*s);\n  P v = vec(l.a,l.b)/abs(l.a-l.b);\n  vector<P> res;\n  res.push_back(a+v*t);\n  res.push_back(a-v*t);\n  return res;\n}\n\n// 円と点\nvector<P> tCP(C c, P p) {\n  vector<P> res;\n  D d = abs(c.p - p);\n  if(sig(d,c.r) < 0) return res;\n  D rc = c.r*c.r/d;\n  D rs = sqrt(max(0.0, c.r*c.r - rc*rc));\n  P v = (p - c.p) / abs(p - c.p);\n  res.emplace_back(c.p + v*rc + rot90(v)*rs);\n  res.emplace_back(c.p + v*rc - rot90(v)*rs);\n  return res;\n}\n\n// 円と線分\nint iCS(C c, L s) {\n  if(sig(abs(c.p - s.a), c.r) <= 0 && sig(abs(c.p - s.b), c.r) <= 0)\n    return -2; // 線分の両端が円の内側にある\n  if(sig(abs(c.p - s.a), c.r) <= 0 || sig(abs(c.p - s.b), c.r) <= 0)\n    return -1; // 線分の端の一方が円の内側、他方が円の外側にある\n  if(sig(dLP(s, c.p), c.r) < 0) // dSPじゃなくてdLPで十分だと思う\n    return +2; // 線分と円周が2点で交わる\n  if(sig(dLP(s, c.p), c.r) == 0)\n    return +1; // 線分と円周が1点で交わる\n  return 0;\n}\n// vector<P> cCS(C c, L s) はiCSの状態によって定義が難しいが、\n// p <- cCL(c,s)からiSP(s,p)==trueのものだけを抜き出せば良い気がする\n\n// 円と円\n// int iCC(C a, C b) はaがbの内側にある場合などもあるので定義が難しい\n// 2点で接していることを確認すること\nvector<P> cCC(C a, C b) {\n  D d = abs(b.p - a.p);\n  D x = (d*d + a.r*a.r - b.r*b.r) / (2*d);\n  D y = sqrt(a.r*a.r - x*x);\n  P v = (b.p - a.p) / d;\n  vector<P> res;\n  res.emplace_back(a.p + v*x + rot90(v)*y);\n  res.emplace_back(a.p + v*x - rot90(v)*y);\n  return res;\n}\n// tCCinに同じ円を食わせたり、\n// tCCoutにどちらかが他方に囲まれている円を食わせたりすると破綻することは分かっているが、\n// そのあたりが厳密にverifyできていない (AOJ 2201でACすることは確認した)\nvector<L> tCCout(C a, C b) {\n  vector<L> res;\n  if(sig(abs(a.r - b.r), abs(a.p - b.p)) >= 0) return res;\n  if(sig(a.r, b.r) == 0) {\n    P v = (b.p - a.p) / abs(b.p - a.p);\n    v = rot90(v);\n    res.emplace_back(a.p + v*a.r, b.p + v*b.r);\n    res.emplace_back(a.p - v*a.r, b.p - v*b.r);\n    return res;\n  }\n  P p = (a.p*b.r - b.p*a.r) / (b.r - a.r);\n  vector<P> at = tCP(a, p);\n  vector<P> bt = tCP(b, p);\n  for(int i = 0; i < (int)min(at.size(), bt.size()); ++i) {\n    res.emplace_back(at[i], bt[i]);\n  }\n  return res;\n}\nvector<L> tCCin(C a, C b) {\n  vector<L> res;\n  if(sig(abs(a.r + b.r), abs(a.p - b.p)) >= 0) return res;\n  P p = (a.p*b.r + b.p*a.r) / (a.r + b.r);\n  vector<P> at = tCP(a, p);\n  vector<P> bt = tCP(b, p);\n  for(int i = 0; i < (int)min(at.size(), bt.size()); ++i) {\n    res.emplace_back(at[i], bt[i]);\n  }\n  return res;\n}\nvector<L> tCC(C a, C b) {\n  vector<L> res;\n  for(L l : tCCout(a, b)) res.push_back(l);\n  for(L l : tCCin(a, b)) res.push_back(l);\n  return res;\n}\n\n// 多角形\ntypedef vector<P> G;\nP at(G g, int i) { return g[i % g.size()]; }\n// 半時計回りを仮定している (時計回りならabsを取る)\nD areaG(G g) {\n  D res = 0.0;\n  for(int i = 0; i < (int)g.size(); i++) {\n    res += outp(at(g, i), at(g, i + 1));\n  }\n  return res / 2.0;\n}\n// ON = 0, IN = 1, OUT = -1\nint containsGP(G g, P p) {\n  int side = -1;\n  for(int i = 0; i < (int)g.size(); i++) {\n    if(ccw(at(g, i), at(g, i + 1), p) == 0) return 0;\n    P a = vec(p, at(g, i));\n    P b = vec(p, at(g, i + 1));\n    if(a.y > b.y) swap(a, b);\n    if(sig(a.y, 0.0) <= 0 && sig(b.y, 0.0) > 0 && sig(outp(a, b), 0.0) > 0) side *= -1;\n  }\n  return side;\n}\nbool operator <(P a, P b) {\n  if(sig(a.x, b.x) != 0) return a.x < b.x;\n  return a.y < b.y;\n}\n// 凸包を構成する点を得る。半時計回り\n// 辺上の点も含めるときは ccw(..) == -1 とすること\nG convex_hull(vector<P> ps) {\n  int N = ps.size();\n  int k = 0; // 凸包を構成する点の数\n  sort(ps.begin(), ps.end());\n  G res(N * 2);\n  for(int i = 0; i < N; i++) {\n    // 時計回りの折れ曲がりがあったら、折れ点を削除\n    while(k >= 2 && ccw(res[k - 2], res[k - 1], ps[i]) <= 0) k--;\n    res[k++] = ps[i];\n  }\n  int t = k + 1;\n  // 右端は取らない (重複するから)\n  // 左端は取る (重複するけど、あとから取り除いたほうが楽)\n  for(int i = N - 2; i >= 0; i--) {\n    while(k >= t && ccw(res[k - 2], res[k - 1], ps[i]) <= 0) k--;\n    res[k++] = ps[i];\n  }\n  res.resize(k - 1);\n  return res;\n}\n// l.a -> l.b の厳密に右側の領域を切り落とす\nG convex_cut(G g, L l) {\n  G res;\n  for(int i = 0; i < (int)g.size(); ++i) {\n    P a = g[i%g.size()];\n    P b = g[(i+1)%g.size()];\n    if(ccw(l.a, l.b, a) != -1) res.push_back(a);\n    // 端の点を含まないiLS\n    if(ccw(l.a, l.b, a)*ccw(l.a, l.b, b) < 0) {\n      res.push_back(cLL(L(a, b), l));\n    }\n  }\n  return res;\n}\n// aとbの垂直二等分線をaが左側に来るように計算する\nL bisector(P a, P b) {\n  P p = (a + b) / 2;\n  return L(p, p + rot90(vec(a,b)));\n}\n// 外枠をgとして点集合vのk番目の点のボロノイ領域を返す\nG voronoi_cell(G g, vector<P> v, int k) {\n  for(int i = 0; i < (int)v.size(); ++i) {\n    if(i == k) continue;\n    g = convex_cut(g, bisector(v[k], v[i]));\n  }\n  return g;\n}\nint main() {\n  while(true) {\n    int N, M; cin >> N >> M;\n    if(N == 0 && M == 0) break;\n    G g;\n    for(int i = 0; i < N; ++i) {\n      int x, y; cin >> x >> y;\n      g.emplace_back(x, y);\n    }\n    vector<P> v;\n    for(int i = 0; i < M; ++i) {\n      int x, y; cin >> x >> y;\n      v.emplace_back(x, y);\n    }\n    cout.setf(ios::fixed);\n    cout.precision(5);\n    for(int i = 0; i < M; ++i) {\n      cout << areaG(voronoi_cell(g, v, i)) << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P; //Point\ntypedef pair<P,P> L; //Line, Segment\n\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\n\nnamespace std {\n  bool operator < (const P& a, const P& b){\n    return fabs(real(a)-real(b)) < EPS ? imag(a) < imag(b) : real(a) < real(b);\n  }\n}\ndouble dot(P a, P b){ return real(conj(a)*b); }\ndouble cross(P a, P b){ return imag(conj(a)*b); }\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > EPS) return 1;   // ????????????(b-a)????????´???????????????(c-a)????????¨?????????\n  if(cross(b,c) < -EPS) return -1; // ????????????(b-a)????????´???????????????(c-a)????????¨?????????\n  if(dot(b,c) < -EPS) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n\ndouble area(vector<P> v){\n  double sum = 0.0;\n  int n = v.size();\n  for(int i=0;i<n;i++) sum += (real(v[i]) - real(v[(i+1)%n])) * (imag(v[i]) + imag(v[(i+1)%n]));\n  return fabs(sum) / 2;\n};\n\nP crossPoint(L l, L m){\n  double A = cross(l.second - l.first, m.second - m.first);\n  double B = cross(l.second - l.first, l.second - m.first);\n  if(fabs(A) < EPS && fabs(B) < EPS) return m.first;\n  else if(fabs(A) >= EPS) return m.first + B / A * (m.second - m.first);\n}\n\nvector<P> convex_cut(vector<P> G, L l){\n  vector<P> ans;\n  for(int i=0;i<G.size();i++){\n    P A = G[i];\n    P B = G[(i+1)%G.size()];\n    if(ccw(l.first, l.second, A) != -1) ans.push_back(A);\n    if(ccw(l.first, l.second, A) * ccw(l.first, l.second, B) < 0)\n      ans.push_back(crossPoint(L(A,B), l));\n  }\n  return ans;\n}\n\nint n,m;\nvector<P> mp;\ndouble calc(int idx,vector<P>g){\n  for(int i=0;i<m;i++){\n    if(i==idx)continue;\n    P t=mp[idx]-mp[i];\n    P a=P(abs(t)/2,1)*t/abs(t)+mp[i];\n    P b=P(abs(t)/2,-1)*t/abs(t)+mp[i];\n    if(ccw(a,b,mp[idx])<0)swap(a,b);\n    g=convex_cut(g,L(a,b));\n  }\n  return area(g);\n}\n\nint main(){\n  while(1){\n  cin>>n>>m;\n  if(!n&&!m)break;\n  vector<P> pl(n);\n  mp.resize(m);\n  for(int i=0,x,y;i<n;i++)cin>>x>>y,pl[i]=P(x,y);\n  for(int i=0,x,y;i<m;i++)cin>>x>>y,mp[i]=P(x,y);\n  for(int i=0;i<m;i++)printf(\"%.10f\\n\",calc(i,pl));\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double eps = 1e-8;\n\nbool equals(double a, double b) {\n  return abs(a-b) < eps;\n}\n\ndouble cross(P a, P b) {\n  return a.real()*b.imag() - a.imag()*b.real();\n}\n\ndouble dot(P a, P b) {\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n\nint ccw(P p, P a, P b) {\n  a -= p;\n  b -= p;\n  if(cross(a, b) > eps) return 1;\n  if(cross(a, b) < -eps) return -1;\n  if(dot(a, b) < -eps) return 2;\n  if(norm(b) - norm(a) > eps) return -2;\n  return 0;\n}\n\nP getCrossP(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1;\n  P b = b2 - b1;\n  return a1 + a * cross(b, b1 - a1) / cross(b, a);\n}\n\nvector<P> convex_cut(vector<P> ps, P p1, P p2, int dir = -1) {\n  vector<P> v;\n  for(int i = 0; i < ps.size(); ++i) {\n    P a = ps[i];\n    P b = ps[(i+1)%ps.size()];\n    if(ccw(p1, p2, a) != dir) v.push_back(a);\n    if(ccw(p1, p2, a)*ccw(p1, p2, b) == -1)\n      v.push_back(getCrossP(a, b, p1, p2));\n  }\n  return v;\n}\n\ndouble getArea(const vector<P> &ps) {\n  int n = ps.size();\n  double res = 0;\n  for(int i = 0; i < n; ++i) {\n    res += cross(ps[i], ps[(i+1)%n]);\n  }\n  return res / 2.0;\n}\n\nint main() {\n  for(int N, M; cin >> N >> M && (N|M); ) {\n    vector<P> ps(N);\n    for(int i = 0; i < N; ++i) {\n      cin >> ps[i].real() >> ps[i].imag();\n    }\n    if(getArea(ps) < 0.0) reverse(ps.begin(), ps.end());\n    vector<P> C(M);\n    for(int j = 0; j < M; ++j) {\n      cin >> C[j].real() >> C[j].imag();\n    }\n\n    for(int i = 0; i < M; ++i) {\n      vector<P> g = ps;\n      for(int j = 0; j < M; ++j) {\n\tif(i == j) continue;\n\tP p1, p2, base, base2;\n\tbase = C[j] - C[i];\n\tbase2 = P(-base.imag(), base.real());\n\tp1 = (C[i] + C[j]) / 2.0;\n\tp2 = p1 + base2;\n\tg = convex_cut(g, p1, p2);\n      }\n      printf(\"%.10f\\n\", getArea(g));\n    }\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n\ntypedef double D;\ntypedef complex<D> P;\n#define X real()\n#define Y imag()\nconst D eps=1e-8;\nconst D inf=1e12;\nstruct L : public vector<P> { // line and segment\n  L(const P& a,const P &b){\n    push_back(a);\n    push_back(b);\n  }\n};\nD cross(P a,P b){ return (conj(a)*b).Y; }\nD dot(P a,P b){ return (conj(a)*b).X; }\nint ccw(P a,P b,P c) {\n  b=b-a;c=c-a;\n  if(cross(b,c)>0) return +1;       // counter clockwise\n  if(cross(b,c)<0) return -1;       // clockwise\n  if(dot(b,c)<0)   return +2;       // c--a--b on line\n  if(norm(b)<norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\nP crosspoint(L l,L m) {\n  D A=cross(l[1]-l[0],m[1]-m[0]);\n  D B=cross(l[1]-l[0],l[1]-m[0]);\n  if (abs(A)<eps&&abs(B)<eps) return m[0]; // same line\n  if (abs(A)<eps) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0]+B/A*(m[1]-m[0]);\n}\n\nvector<P> convex_cut(vector<P>& poly,L l) {\n  vector<P> Q;\n  int sz=poly.size();\n  for (int i = 0; i < sz; i++) {\n    P A = poly[i], B = poly[(i+1)%sz];\n    if(ccw(l[0], l[1], A) != -1)Q.push_back(A);\n    if(ccw(l[0], l[1], A)*ccw(l[0], l[1], B) < 0){\n      Q.push_back(crosspoint(L(A, B), l));\n    }\n  }\n  return Q;\n}\n\nL bisector_line(L l){\n  P hp=0.5*(l[0]+l[1]);\n  P v=l[1]-l[0];\n  return L(hp,hp+P(-v.Y,v.X));\n}\n\nD calc_area(vector<P>& poly) {\n  D res = 0;\n  int sz=poly.size();\n  for (int i = 0; i < sz; i++){\n    res += cross(poly[i], poly[(i+1)%sz]);\n  }\n  return res/2.0;\n}\n\nint main(){\n  while(1){\n    int n,m;\n    vector<P> ps,cs;\n    cin>>n>>m;\n    if(n==0||m==0)break;\n    rep(i,n){\n      D px,py;\n      cin>>px>>py;\n      ps.push_back(P(px,py));\n    }\n    rep(i,m){\n      D cx,cy;\n      cin>>cx>>cy;\n      cs.push_back(P(cx,cy));\n    }\n    rep(i,m){\n      vector<P> tmp=ps;\n      rep(j,m){\n        if(j==i)continue;\n        L l=bisector_line(L(cs[i],cs[j]));\n        tmp=convex_cut(tmp,l);\n      }\n      D res=calc_area(tmp);\n      printf(\"%.10f\\n\", res);\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\nconst double eps = 1e-10;\n\n#define RIGHT 1\n#define LEFT -1\n\ntypedef complex<double> P;\ntypedef vector<P> Polygon;\ntypedef pair<P,P> Line;\n\ndouble cross(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\nP intersection_ll(P a1,P a2,P b1,P b2){\n  P a=a2-a1,b=b2-b1;\n  return a1+a*cross(b,b1-a1)/cross(b,a);\n}\n\n\nint ccw(P a,P b){\n  if ( cross(a,b)<0)return RIGHT;\n  else if ( cross(a,b)>0)return LEFT;\n  return 2;\n}\n\nvector<P> Convex_Cut(Polygon in,int n,P a1,P a2,int cutpos){\n  vector<P> ret;\n  rep(i,n){\n    P now = in[i],next=in[(i+1)%n];\n    if( ccw(a1-a2,now-a2)==cutpos)ret.push_back(now);\n    if ( ccw(a1-a2,now-a2)*ccw(a1-a2,next-a2)<0)\n      ret.push_back(intersection_ll(a1,a2,now,next));\n  }\n  return ret;\n}\n\n//cutpos ha mondai izon. which side will remain\nLine make_line(P ori,P b,int cutpos){\n  P tmp=(ori+b);\n  tmp.real()/=2;tmp.imag()/=2;\n  P ret=b-tmp;\n  swap(ret.real(),ret.imag());\n  ret.real()*=-1;\n  if ( ccw(ret,ori-tmp)!= cutpos)return make_pair(tmp,ret+tmp);\n  return make_pair(ret+tmp,tmp);\n}\n\ndouble Polygon_Area(vector<P> a,int n){\n  double sum=0;\n  rep(i,n){\n    sum+=(a[i%n].real()-a[(i+1)%n].real())*(a[i%n].imag()+a[(i+1)%n].imag());\n  }\n  if( sum<0)sum*=-1;\n  return sum/2;\n}\n\n\nvoid solve(int n,int m,Polygon in,vector<P> CutLine){\n  vector<Line> ver;\n  rep(i,CutLine.size())\n    if ( i == m)continue;\n    else ver.push_back(make_line(CutLine[m],CutLine[i],LEFT));\n\n  rep(i,ver.size())\n    in=Convex_Cut(in,in.size(),ver[i].first,ver[i].second,LEFT);\n  \n  printf(\"%.4lf\\n\",Polygon_Area(in,in.size()));\n}\n\nmain(){\n  int n,m;\n  while(cin>>n>>m&&n){\n    Polygon a;\n    vector<P> CutPoint;\n    rep(i,n){\n      P tmp;cin>>tmp.real()>>tmp.imag();a.push_back(tmp);\n    }\n    rep(i,m){\n      P tmp;\n      cin>>tmp.real()>>tmp.imag();\n      CutPoint.push_back(tmp);\n    }\n    \n    rep(i,m)\n      solve(n,i,a,CutPoint);\n    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "// Enjoy your stay.\n\n#include <bits/stdc++.h>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(auto it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define mt make_tuple\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)(x).size())\n\nusing namespace std;\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<ll,ll> pi;\ntypedef stringstream sst;\ntypedef vector<ll> vi;\n\n// geometry library from hos\n\nconst double PI = acos(-1);\n\nint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\n\nstruct Pt{\n\tdouble x, y;\n\tPt() {}\n\tPt(double x, double y) : x(x), y(y) {}\n\tPt operator+(const Pt &a) const { return Pt(x + a.x, y + a.y); }\n\tPt operator-(const Pt &a) const { return Pt(x - a.x, y - a.y); }\n\tPt operator*(const Pt &a) const { return Pt(x * a.x - y * a.y, x * a.y + y * a.x); }\n\tPt operator-() const { return Pt(-x, -y); }\n\tPt operator*(const double &k) const { return Pt(x * k, y * k); }\n\tPt operator/(const double &k) const { return Pt(x / k, y / k); }\n\tdouble abs() const { return sqrt(x * x + y * y); }\n\tdouble abs2() const { return x * x + y * y; }\n\tdouble arg() const { return atan2(y, x); }\n\tdouble dot(const Pt &a) const { return x * a.x + y * a.y; }\n\tdouble det(const Pt &a) const { return x * a.y - y * a.x; }\n\tbool operator<(const Pt &a) const { return x < a.x || x == a.x && y < a.y; }\n\tbool operator==(const Pt &a) const { return x == a.x && y == a.y; }\n\tbool operator!=(const Pt &a) const { return x != a.x || y != a.y; }\n};\n\nostream &operator<<(ostream &os, const Pt &a) { os << \"(\" << a.x << \", \" << a.y << \")\"; return os; }\n\ndouble tri(const Pt &a, const Pt &b, const Pt &c) { return (b - a).det(c - a); }\n\nint iSP(Pt a, Pt b, Pt c) {\n\tint s = sig((b - a).det(c - a));\n\tif (s) return s; // +1 or -1\n\tif (sig((b - a).dot(c - a)) < 0) return -2; // c-a-b\n\tif (sig((a - b).dot(c - b)) < 0) return +2; // a-b-c\n\treturn 0;\n}\nint iLL(Pt a, Pt b, Pt c, Pt d) {\n\tif (sig((b - a).det(d - c))) return 1; // intersect\n\tif (sig((b - a).det(c - a))) return 0; // parallel\n\treturn -1; // correspond\n}\nbool iLS(Pt a, Pt b, Pt c, Pt d) {\n\treturn (sig(tri(a, b, c)) * sig(tri(a, b, d)) <= 0);\n}\nbool iSS(Pt a, Pt b, Pt c, Pt d) {\n\treturn (iSP(a, b, c) * iSP(a, b, d) <= 0 && iSP(c, d, a) * iSP(c, d, b) <= 0);\n}\nbool iSSstrict(Pt a, Pt b, Pt c, Pt d) {\n\treturn (sig(tri(a, b, c)) * sig(tri(a, b, d)) < 0 && sig(tri(c, d, a)) * sig(tri(c, d, b)) < 0);\n}\nPt pLL(Pt a, Pt b, Pt c, Pt d) { // intersection\n\tb = b - a; d = d - c; return a + b * (c - a).det(d) / b.det(d);\n}\ndouble dLP(Pt a, Pt b, Pt c) {\n\treturn abs(tri(a, b, c)) / (b - a).abs();\n}\ndouble dSP(Pt a, Pt b, Pt c) {\n\tif (sig((b - a).dot(c - a)) <= 0) return (c - a).abs();\n\tif (sig((a - b).dot(c - b)) <= 0) return (c - b).abs();\n\treturn abs(tri(a, b, c)) / (b - a).abs();\n}\ndouble dLL(Pt a, Pt b, Pt c, Pt d) {\n\treturn iLL(a, b, c, d) ? 0 : dLP(a, b, c);\n}\ndouble dLS(Pt a, Pt b, Pt c, Pt d) {\n\treturn iLS(a, b, c, d) ? 0 : min(dLP(a, b, c), dLP(a, b, d));\n}\ndouble dSS(Pt a, Pt b, Pt c, Pt d) {\n\treturn iSS(a, b, c, d) ? 0 : min(min(dSP(a, b, c), dSP(a, b, d)), min(dSP(c, d, a), dSP(c, d, b)));\n}\n\nint iCC(Pt a, double r, Pt b, double s) {\n\tdouble d = (b - a).abs();\n\tif (sig(d) == 0 && sig(r - s) == 0) return -1; // correspond\n\tif (sig(r - s - d) > 0) return +2; // r > s\n\tif (sig(s - r - d) > 0) return -2; // s > r\n\treturn (sig(r + s - d) >= 0) ? 1 : 0;\n}\nbool iCS(Pt a, double r, Pt b, Pt c) {\n\treturn (sig(r - dSP(b, c, a)) >= 0 && sig(r - max((b - a).abs(), (c - a).abs())) <= 0);\n}\npair<Pt,Pt> pCC(Pt a, double r, Pt b, double s) {\n\tdouble d = (b - a).abs();\n\tdouble x = (d * d + r * r - s * s) / (d * 2);\n\tPt e = (b - a) / d, w = e * Pt(0, 1) * sqrt(max(r * r - x * x, 0.0));\n\treturn mp(a + e * x - w, a + e * x + w);\n}\npair<Pt,Pt> pCL(Pt a, double r, Pt b, Pt c) {\n\tPt h = b + (c - b) * (c - b).dot(a - b) / (c - b).abs2();\n\t// perp(b, c, a)\n\tdouble d = (h - a).abs();\n\tdouble y = sqrt(max(r * r - d * d, 0.0));\n\tPt e = (c - b) / (c - b).abs();\n\treturn mp(h - e * y, h + e * y);\n}\npair<Pt,Pt> tCP(Pt a, double r, Pt b) {\n\tdouble d2 = (b - a).abs2();\n\tdouble x = sqrt(max(d2 - r * r, 0.0));\n\tPt h = a + (b - a) * (r * r / d2);\n\tPt w = (b - a) * Pt(0, 1) * (x * r / d2);\n\treturn mp(h - w, h + w);\n}\ndouble aCC(Pt a, double r, Pt b, double s) {\n\tdouble d = (a - b).abs();\n\tif (sig(r - s - d) >= 0) return s * s * PI;\n\tif (sig(s - r - d) >= 0) return r * r * PI;\n\tif (sig(r + s - d) <= 0) return 0;\n\tdouble x = (d * d + r * r - s * s) / (d * 2);\n\tdouble h = sqrt(r * r - x * x);\n\treturn r * r * atan2(h, x) + s * s * atan2(h, d - x) - d * h;\n}\n\nint convexHull(int n, Pt p[], Pt q[]){ // can replace sig&tri, <= with iSP, <\n\tint m=0, i, r;\n\tsort(p, p+n);\n\tfor(i=0;        i<n;  q[m++]=p[i++]) for(; m>1 && sig(tri(q[m-2], q[m-1], p[i])) <= 0; --m);\n\tfor(i=n-2, r=m; i>=0; q[m++]=p[i--]) for(; m>r && sig(tri(q[m-2], q[m-1], p[i])) <= 0; --m);\n\treturn m-1;\n}\n\nint convexCut(int n, Pt p[], Pt a, Pt b, Pt q[]){\n\tint m=0, i;\n\tp[n] = p[0];\n\trep(i, n){\n\t\tif(sig(tri(a, b, p[i])) > 0) q[m++] = p[i];\n\t\tif(sig(tri(a, b, p[i])) * sig(tri(a, b, p[i+1])) < 0) q[m++] = pLL(a, b, p[i], p[i+1]);\n\t}\n\tq[m] = q[0];\n\treturn m;\n}\n\nint sGP(int n, Pt p[], Pt a) {\n\tint side = -1, i;\n\tp[n] = p[0];\n\tfor (i = 0; i < n; ++i) {\n\t\tPt p0 = p[i] - a, p1 = p[i + 1] - a;\n\t\tif (sig(p0.det(p1)) == 0 && sig(p0.dot(p1)) <= 0) return 0;\n\t\tif (p0.y > p1.y) swap(p0, p1);\n\t\tif (sig(p0.y) <= 0 && 0 < sig(p1.y) && sig(p0.det(p1)) > 0) side = -side;\n\t}\n\treturn side;\n}\nint sVP(int n, Pt p[], Pt a) {\n\tPt o = (p[0] + p[n / 2]) / 2;\n\tint lo = 0, ho = n, fl = sig(tri(o, p[lo], a));\n\tp[n] = p[0];\n\tfor (; lo + 1 < ho; ) {\n\t\tint mo = (lo + ho) / 2, fm = sig(tri(o, p[mo], a));\n\t\t(fl - fm - sig(tri(o, p[lo], p[mo])) < 0) ? (lo = mo, fl = fm) : ho = mo;\n\t}\n\treturn sig(tri(p[lo], p[ho], a));\n}\n\nint sAP(Pt a, Pt b, Pt c) {\n\treturn sig(a.det(c)) - sig(b.det(c)) - sig(a.det(b));\n}\n\n// end of library\n\nint N,M;\nPt l[11],c[11];\n\nint main2(){\n\trep(i,M){\n\t\tint n=N;\n\t\tPt p[33],q[33];\n\t\trep(j,n)p[j]=l[j];\n\t\trep(j,M)if(j!=i){\n\t\t\tPt mid = (c[i]+c[j])/2;\n\t\t\tint m = convexCut(n,p,mid,mid+(c[j]-c[i])*Pt(0,1),q);\n\t\t\tn=m;\n\t\t\trep(i,n)p[i]=q[i];\n\t\t}\n\t\tdouble res=0;\n\t\trep(i,n)res+=p[i].det(p[(i+1)%n]);\n\t\tcout<<setprecision(16)<<res/2<<endl;\n\t}\n\treturn 0;\n}\n\nint main(){\n\twhile(cin>>N>>M,N){\n\t\trep(i,N)cin>>l[i].x>>l[i].y;\n\t\trep(i,M)cin>>c[i].x>>c[i].y;\n\t\tmain2();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P; //Point\ntypedef pair<P,P> L; //Line, Segment\nconst double EPS = 1e-8;\n\ndouble dot(P a, P b){ return real(conj(a)*b); }\ndouble cross(P a, P b){ return imag(conj(a)*b); }\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > EPS) return 1;   // ????????????(b-a)????????´???????????????(c-a)????????¨?????????\n  if(cross(b,c) < -EPS) return -1; // ????????????(b-a)????????´???????????????(c-a)????????¨?????????\n  if(dot(b,c) < -EPS) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n\ndouble area(vector<P> v){\n  double sum = 0.0;\n  int n = v.size();\n  for(int i=0;i<n;i++) sum += (real(v[i]) - real(v[(i+1)%n])) * (imag(v[i]) + imag(v[(i+1)%n]));\n  return fabs(sum) / 2;\n}\n\nP crossPoint(L l, L m){\n  double A = cross(l.second - l.first, m.second - m.first);\n  double B = cross(l.second - l.first, l.second - m.first);\n  if(fabs(A) < EPS && fabs(B) < EPS) return m.first;\n  else if(fabs(A) >= EPS) return m.first + B / A * (m.second - m.first);\n}\n\nvector<P> convex_cut(vector<P> G, L l){\n  vector<P> ans;\n  for(int i=0;i<G.size();i++){\n    P A = G[i];\n    P B = G[(i+1)%G.size()];\n    if(ccw(l.first, l.second, A) != -1) ans.push_back(A);\n    if(ccw(l.first, l.second, A) * ccw(l.first, l.second, B) < 0)\n      ans.push_back(crossPoint(L(A,B), l));\n  }\n  return ans;\n}\n\nint n,m;\nvector<P> mp;\ndouble calc(int idx,vector<P>g){\n  for(int i=0;i<m;i++){\n    if(i==idx)continue;\n    P t=mp[idx]-mp[i];\n    P a=P(abs(t)/2,1)*t/abs(t)+mp[i];\n    P b=P(abs(t)/2,-1)*t/abs(t)+mp[i];\n    g=convex_cut(g,L(a,b));\n  }\n  return area(g);\n}\n\nint main(){\n  while(1){\n    cin>>n>>m;\n    if(!n&&!m)break;\n    vector<P> pl(n);\n    mp.resize(m);\n    for(int i=0,x,y;i<n;i++)cin>>x>>y,pl[i]=P(x,y);\n    for(int i=0,x,y;i<m;i++)cin>>x>>y,mp[i]=P(x,y);\n    for(int i=0;i<m;i++)printf(\"%.10f\\n\",calc(i,pl));\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef complex<double> P;\n \nconst double eps = 1e-8;\n \nbool equals(double a, double b) {\n  return abs(a-b) < eps;\n}\n \ndouble cross(P a, P b) {\n  return a.real()*b.imag() - a.imag()*b.real();\n}\n \ndouble dot(P a, P b) {\n  return a.real()*b.real() + a.imag()*b.imag();\n}\n \nint ccw(P p, P a, P b) {\n  a -= p;\n  b -= p;\n  if(cross(a, b) > eps) return 1;\n  if(cross(a, b) < -eps) return -1;\n  if(dot(a, b) < -eps) return 2;\n  if(norm(b) - norm(a) > eps) return -2;\n  return 0;\n}\n \nP getCrossP(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1;\n  P b = b2 - b1;\n  return a1 + a * cross(b, b1 - a1) / cross(b, a);\n}\n \nvector<P> convex_cut(vector<P> ps, P p1, P p2, int dir = -1) {\n  vector<P> v;\n  for(int i = 0; i < ps.size(); ++i) {\n    P a = ps[i];\n    P b = ps[(i+1)%ps.size()];\n    if(ccw(p1, p2, a) != dir) v.push_back(a);\n    if(ccw(p1, p2, a)*ccw(p1, p2, b) == -1)\n      v.push_back(getCrossP(a, b, p1, p2));\n  }\n  return v;\n}\n \ndouble getArea(const vector<P> &ps) {\n  int n = ps.size();\n  double res = 0;\n  for(int i = 0; i < n; ++i) {\n    res += cross(ps[i], ps[(i+1)%n]);\n  }\n  return res / 2.0;\n}\n \nint main() {\n  for(int N, M; cin >> N >> M && (N|M); ) {\n    vector<P> ps(N);\n    for(int i = 0; i < N; ++i) {\n      cin >> ps[i].real() >> ps[i].imag();\n    }\n    if(getArea(ps) < 0.0) reverse(ps.begin(), ps.end());\n    vector<P> C(M);\n    for(int j = 0; j < M; ++j) {\n      cin >> C[j].real() >> C[j].imag();\n    }\n \n    for(int i = 0; i < M; ++i) {\n      vector<P> g = ps;\n      for(int j = 0; j < M; ++j) {\n        if(i == j) continue;\n        P p1, p2, base, base2;\n        base = C[j] - C[i];\n        base2 = P(-base.imag(), base.real());\n        p1 = (C[i] + C[j]) / 2.0;\n        p2 = p1 + base2;\n        g = convex_cut(g, p1, p2);\n      }\n      printf(\"%.10f\\n\", getArea(g));\n    }\n \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<cmath>\n#include<vector>\n#include<cstdlib>\n#include<cassert>\n#include<map>\n#include<iomanip>\n#define _A_ true\n#define EPS 1e-10\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\nusing namespace std;\nclass Point{\npublic:\n  double x,y;\n  Point(double x =0,double y=0):x(x),y(y){}\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(x*a,y*a);}\n  Point operator / (double a){return Point(x/a,y/a);} //もし悪を使うなら要確認\n \n  double norm() {return x*x+y*y;}\n  double abs() {return sqrt(norm());}\n \n  bool operator < (const Point &p) const{\n    return x != p.x ? x < p.x : y < p.y; \n  }\n \n  bool operator == (const Point &p) const{\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\ntypedef Point Point;\nstruct Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p = Point(),Point pp = Point()):p1(p),p2(pp){}\n};\n \ntypedef vector<Point> Polygon;\ntypedef Segment Line;\n \ndouble norm(Point p){\n  return p.x*p.x+p.y*p.y;\n}\n \ndouble abs(Point p){\n  return sqrt(norm(p));\n}\n \nPoint polar(double a,double rad){\n  return Point(a*cos(rad),a*sin(rad));\n}\n \ndouble args(Point p){\n  return atan2(p.y,p.x);\n}\n \ndouble dot(Point a,Point b){\n  return a.x*b.x+a.y*b.y;\n}\n \ndouble cross(Point a,Point b){\n  return a.x*b.y-b.x*a.y;\n}\n \nPoint project(Segment s,Point p){\n  Point base = s.p2 - s.p1;\n  double t = dot(p-s.p1,base)/base.norm();\n  return s.p1+base*t;\n}\n \nPoint reflect (Segment s, Point p){\n  return p + (project(s,p)-p)*2.0;\n}\n \nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CLOCKWISE;\n  if(dot(a,b) < -EPS) return ONLINE_BACK;\n  if(a.norm() < b.norm() ) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n \nbool isIntersect(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <= 0 && ccw(p3,p4,p1) * ccw(p3,p4,p2) <= 0 );\n}\n \nbool isIntersect(Segment s1,Segment s2){\n  return isIntersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n/*\nPoint getCrossPointSegments(Segment s1,Segment s2){\n  assert(isIntersect(s1,s2));\n  Point base = s2.p2 - s2.p1;\n  double d1 = abs(cross(base,s1.p1-s2.p1));\n  double d2 = abs(cross(base,s1.p2-s2.p1));\n  double t = d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n*/\n\nPoint getCrossPointLines( Line s1, Line s2){\n  double A = cross(s1.p2-s2.p1,s2.p2-s2.p1);  \n  double B = cross(s1.p2-s1.p1,s1.p2-s2.p1);\n  if (abs(A) < EPS && abs(B) < EPS) return s2.p1; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n    Point a = s1.p2 - s1.p1;\n    //Point base = Point(s2.p2.x - s2.p1.x,s2.p2.y - s2.p1.y);\n    Point base = s2.p2 -s2.p1;\n    return s1.p1 + a * (cross(base, s2.p1 - s1.p1)/cross(base, a));\n}\n\nPolygon cutPolygon( Polygon P, Line l ){\n    Polygon u;\n    \n    for ( int i = 0; i < P.size(); i++ ){\n        Point a = P[i], b = P[(i+1)%P.size()];\n\t\n\tif ( ccw(l.p1, l.p2, a) != CLOCKWISE ) u.push_back(a);\n\tif ( ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) == -1 ){\n\t  u.push_back(getCrossPointLines(Segment(a, b), l));\n        }\n    }   \n    return u;\n}\n \n \nLine CreateLine(Point p,Point pp){\n  Point mid = (p+pp)/2;\n  Point sl = pp-p;//原点に5\n  double rad = args(sl);\n  Point ap = polar(abs(sl),rad+M_PI/2)+mid;\n  //ap.x = abs(sl)*cos(rad+M_PI/2)+mid.x;\n  //ap.y = abs(sl)*sin(rad+M_PI/2)+mid.y;\n  return Line(mid,ap);\n}\n \n \ndouble AreaCalc(Polygon p){\n  double area = 0;\n  p.push_back(p[0]);\n  for(int i=0;i<p.size()-1;i++){\n    area+=cross(p[i],p[i+1]);\n  }\n  return fabs(area)/2;\n}\n \n  \n \nint main(){\n  int N,M;\n  while(cin >> N >> M,N|M){\n  \n  vector<Point> l(N);\n  vector<Point> C(M);\n  for(int i=0;i<N;i++)\n    {\n      cin >> l[i].x >> l[i].y;\n      l[i].x += 200,l[i].y += 200;\n    }\n  for(int i=0;i<M;i++)\n    {\n      cin >> C[i].x >> C[i].y;\n      C[i].x += 200,C[i].y += 200;\n    }\n  for(int i=0;i<M;i++)\n    {\n      Polygon poly; \n      for(int j=0;j<N;j++)\n\tpoly.push_back(l[j]);\n\n      for(int j=0;j<M;j++)\n\t{\n\t  if(j == i)\n\t    continue;\n\t  poly = cutPolygon(poly,CreateLine(C[i],C[j]));\n\t}\n\n\n      \n      cout << setiosflags(ios::fixed) << setprecision(1) << AreaCalc(poly) << endl;\n\n    }  \n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<cmath>\n#include<vector>\n#include<cstdlib>\n#include<cassert>\n#include<map>\n#include<iomanip>\n#define _A_ true\n#define EPS 1e-10\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\nusing namespace std;\nclass Point{\npublic:\n  double x,y;\n  Point(double x =0,double y=0):x(x),y(y){}\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(x*a,y*a);}\n  Point operator / (double a){return Point(x/a,y/a);} //もし悪を使うなら要確認\n \n  double norm() {return x*x+y*y;}\n  double abs() {return sqrt(norm());}\n \n  bool operator < (const Point &p) const{\n    return x != p.x ? x < p.x : y < p.y; \n  }\n \n  bool operator == (const Point &p) const{\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\ntypedef Point Point;\nstruct Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p = Point(),Point pp = Point()):p1(p),p2(pp){}\n};\n \ntypedef vector<Point> Polygon;\ntypedef Segment Line;\n \nPoint ACM,IC,PC;\nSegment IC_PC,PC_ACM,ACM_IC;\n \n \n \ndouble norm(Point p){\n  return p.x*p.x+p.y*p.y;\n}\n \ndouble abs(Point p){\n  return sqrt(norm(p));\n}\n \nPoint polar(double a,double rad){\n  return Point(a*cos(rad),a*sin(rad));\n}\n \ndouble args(Point p){\n  return atan2(p.y,p.x);\n}\n \ndouble dot(Point a,Point b){\n  return a.x*b.x+a.y*b.y;\n}\n \ndouble cross(Point a,Point b){\n  return a.x*b.y-b.x*a.y;\n}\n \nPoint project(Segment s,Point p){\n  Point base = s.p2 - s.p1;\n  double t = dot(p-s.p1,base)/base.norm();\n  return s.p1+base*t;\n}\n \nPoint reflect (Segment s, Point p){\n  return p + (project(s,p)-p)*2.0;\n}\n \nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CLOCKWISE;\n  if(dot(a,b) < -EPS) return ONLINE_BACK;\n  if(a.norm() < b.norm() ) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n \nbool isIntersect(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <= 0 && ccw(p3,p4,p1) * ccw(p3,p4,p2) <= 0 );\n}\n \nbool isIntersect(Segment s1,Segment s2){\n  return isIntersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n/*\nPoint getCrossPoint(Segment s1,Segment s2){\n  assert(isIntersect(s1,s2));\n  P base = s2.p2 - s2.p1;\n  double d1 = abs(cross(base,s1.p1-s2.p1));\n  double d2 = abs(cross(base,s1.p2-s2.p1));\n  double t = d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n*/\n \nPoint getCrossPointLines( Line s1, Line s2){\n    Point a = s1.p2 - s1.p1;\n    //cout << \"In getCrossPointLines--------\" << endl;\n    //cout << \"a = \" <<a.x << \",\"  << a.y << endl;\n    Point base = Point(s2.p2.x - s2.p1.x,s2.p2.y - s2.p1.y);\n    //cout <<\"base = \"<< base.x << \",\" << base.y << endl;\n    return s1.p1 + a * cross(base, s2.p1 - s1.p1)/cross(base, a);\n}\n \nPolygon cutPolygon( Polygon P, Line l ){\n    Polygon u;\n    \n    for ( int i = 0; i < P.size(); i++ ){\n        Point a = P[i], b = P[(i+1)%P.size()];\n        if ( ccw(l.p1, l.p2, a) != CLOCKWISE ) u.push_back(a);\n        if ( ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) == -1 ){\n      u.push_back(getCrossPointLines(Segment(a, b), l));\n      \n        }\n    }\n   \n    return u;\n}\n \n \n \nLine CreateLine(Point p,Point pp){\n  Point mid = (p+pp)/2;\n \n  Point sl = pp-p;//原点に5\n  double rad = args(sl);\n  Point ap = polar(abs(sl),rad+M_PI/2)+mid;\n  //ap.x = abs(sl)*cos(rad+M_PI/2)+mid.x;\n  //ap.y = abs(sl)*sin(rad+M_PI/2)+mid.y;\n  return Line(mid,ap);\n}\n \n \ndouble AreaCalc(Polygon p){\n  double area = 0;\n  p.push_back(p[0]);\n  for(int i=0;i<p.size()-1;i++){\n    area+=cross(p[i],p[i+1]);\n  }\n  return abs(area/2);\n}\n \n \n \n \n \nint main(){\n  int N,M;\n  while(cin >> N >> M,N|M){\n\n  Line IC_PC,IC_ACM;\n  double area;\n  \n  vector<Point> l(N);\n  vector<Point> C(M);\n  for(int i=0;i<N;i++)\n    cin >> l[i].x >> l[i].y;\n  for(int i=0;i<M;i++)\n    cin >> C[i].x >> C[i].y;\n\n  for(int i=0;i<M;i++)\n    {\n      Polygon poly; \n      for(int j=0;j<N;j++)\n\tpoly.push_back(l[j]);\n      for(int j=0;j<M;j++)\n\t{\n\t  if(j == i)\n\t    continue;\n\t  poly = cutPolygon(poly,CreateLine(C[i],C[j]));\n\t}\n      cout << setiosflags(ios::fixed) << setprecision(1) << AreaCalc(poly) << endl;\n\n    }  \n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i=((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=((int)(b));i>=((int)(a));i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define pque(type) priority_queue<type,vector<type>,greater<type> >\n#define memst(a,b) memset(a,b,sizeof(a))\n#define iter(v,ite) for(auto ite=(v).begin();ite!=(v).end();ite++)\n#define mimunum(v,x) distance((v).begin(),lower_bound((v).begin(),(v).end(),x))\n\n\nstruct makehtml{\n\tvector<string> ss;\n\t\n\tmakehtml(){}\n\t/*\n\tctx.beginPath()\n\tctx.moveTo(50.000000,100.000000);\n\tctx.lineTo(150.000000,100.000000);\n\tctx.stroke();\n\t\n\tctx.fillStyle = \"rgb(0,0,0)\";\n\t\n\tctx.beginPath();\n\tctx.arc(168,59,3,0,360);\n\tctx.fill();\n\n\t*/\n\t\n\tvoid out(const char* name,double mag){\n\t\tchar fname[100];\n\t\tsprintf(fname,\"%s.html\",name);\n\t\tFILE* fp = fopen(fname,\"w\");\n\t\tif(fp==NULL){\n\t\t\teprintf(\"can't open %s\\b\",fname);\n\t\t\texit(-1);\n\t\t}\n\t\tfprintf(fp,\"<html>\\n<head>\\n<title>\");\n\t\tfprintf(fp,\"%s\",name);\n\t\tfprintf(fp,\"</title>\\n</head>\\n<body>\\n\");\n\t\tfprintf(fp,\"<p>name: %s</p>\",name);\n\t\tfprintf(fp,\"<canvas id=\\\"vis\\\" width=\\\"%d\\\" height=\\\"%d\\\"></canvas>\",500,500);\n\t\tfprintf(fp,\"<script>\\n\");\n\t\tfprintf(fp,\"var vis = document.getElementById('vis');\\nvar ctx = vis.getContext('2d');\\n\");\n\t\t\n\t\trep(i,ss.size()){\n\t\t\tfprintf(fp,\"%s\\n\",ss[i].c_str());\n\t\t}\n\t\t\n\t\tfprintf(fp,\"</script>\\n\");\n\t\tfprintf(fp,\"</body>\\n</html>\\n\");\n\t\tfclose(fp);\n\t}\n\n} makehtml_instance;\n\nvoid addhtml(string s){\n\tmakehtml_instance.ss.push_back(s);\n}\n\nvoid outhtml(string s,double mag){\n\tmakehtml_instance.out(s.c_str(),mag);\n}\n\nvoid randcolhtml(){\n\tchar ns[100];\n\tsprintf(ns,\"ctx.fillStyle = \\\"rgb(%d,%d,%d)\\\";\",rand()%128,rand()%128,rand()%128);\n\taddhtml(ns);\n\tsprintf(ns,\"ctx.strokeStyle = \\\"rgb(%d,%d,%d)\\\";\",rand()%128,rand()%128,rand()%128);\n\taddhtml(ns);\n}\n\nvoid inithtml(){\n\tmakehtml_instance.ss.clear();\n}\n\n\nstruct pos{\n\tdouble x,y;\n\tdouble norm,norm2;\n\tpos tov(pos a){\n\t\treturn (a-(*this));\n\t}\n\tpos operator+(pos a)const{\n\t\tpos res=a;\n\t\tres.x+=x; res.y+=y;\n\t\tres=pos(res.x,res.y);\n\t\treturn res;\n\t}\n\tpos operator-(pos a)const{\n\t\tpos res=(*this);\n\t\tres.x-=a.x; res.y-=a.y;\n\t\tres=pos(res.x,res.y);\n\t\treturn res;\n\t}\n\tpos scalar(double a){\n\t\tpos res=(*this);\n\t\tres.x*=a; res.y*=a;\n\t\tres=pos(res.x,res.y);\n\t\treturn res;\n\t}\n\tdouble dot(pos a){\n\t\treturn x*a.x + y*a.y;\n\t}\n\tdouble cross(pos a){\n\t\treturn x*a.y - y*a.x;\n\t}\n\tdouble theta(pos a){\n\t\tdouble nt=dot(a)/(norm*a.norm);\n\t\tnt=acos(max(-1.0,min(1.0,nt)));\n\t\tdouble ns=(cross(a)/(norm*a.norm));\n\t\tif(ns<0)nt*=-1;\n\t\treturn nt;\n\t}\n\tpos(double ix,double iy){\n\t\tx=ix; y=iy;\n\t\tnorm2=x*x+y*y;\n\t\tnorm=sqrt(norm2);\n\t}\n\tpos(){}\n\tstring str(){\n\t\tchar ns[50];\n\t\tsprintf(ns,\"(%lf %lf)\",x,y);\n\t\treturn\tstring(ns);\n\t}\n\tvoid outh(double mag){\n\t\tchar ns[50];\n\t\taddhtml(\"ctx.beginPath();\"); \n\t\tsprintf(ns,\"ctx.arc(%lf,%lf,%lf,0,360);\",x*mag,y*mag,5.0); addhtml(ns);\n\t\taddhtml(\"ctx.fill();\");\n\t}\n\tstatic pos polar(double r,double t){\n\t\treturn pos(r*cos(t),r*sin(t));\n\t}\n\tbool  operator<(pos a) const{\n\t\t//if(x!=a.x)return (x<a.x);\n\t\t//return (y<a.y);\n\t\tif(y!=a.y)return (y<a.y);\n\t\treturn (x<a.x);\n\t}\t\n\tbool operator>(pos a)const{ return (a<(*this)); }\t\n};\nstruct line{\n\tpos p,q;\n\tpos vec;\n\tstring str(){\n\t\treturn (\"(\"+p.str()+\"-\"+q.str()+\")\");\n\t}\n\tvoid outh(double mag){\n\t\tchar ns[50];\n\t\taddhtml(\"ctx.beginPath();\");\n\t\tsprintf(ns,\"ctx.moveTo(%lf,%lf);\",p.x*mag,p.y*mag); addhtml(ns);\n\t\tsprintf(ns,\"ctx.lineTo(%lf,%lf);\",q.x*mag,q.y*mag); addhtml(ns);\n\t\taddhtml(\"ctx.stroke();\");\n\t}\n\tbool iscross(line a){\n\t\tdouble da,db;\n\t\tda=vec.cross( p.tov(a.p) );\n\t\tdb=vec.cross( p.tov(a.q) );\n\t\tif(da*db>=0)return false;\n\t\tda=a.vec.cross( a.p.tov(p) );\n\t\tdb=a.vec.cross( a.p.tov(q) );\n\t\treturn (da*db<0);\n\t}\n\tline(pos ip,pos iq){\n\t\tp=ip; q=iq;\n\t\tvec=p.tov(q);\n\t}\n\tline(){}\n\tdouble dist(pos a){\n\t\tif(p.tov(a).dot( p.tov(q) )<0)return p.tov(a).norm;\n\t\tif(q.tov(a).dot( q.tov(p) )<0)return q.tov(a).norm;\n\t\treturn abs(vec.cross(p.tov(a))/vec.norm);\n\t}\n\tdouble dist(line a){\n\t\tif(iscross(a))return 0;\n\t\treturn min( min(dist(a.p),dist(a.q)) , min(a.dist(this->p),a.dist(this->q)));\n\t}\n\tpos crosspos(line a){\n\t\t/*\n\t\tdouble d1=a.vec.cross(a.p.tov(p))/a.vec.norm;\n\t\tdouble d2=a.vec.cross(a.p.tov(q))/a.vec.norm;\n\t\tbool isc=(d1*d2<0);\n\t\td1=abs(d1); d2=abs(d2);\n\t\tdouble sc;\n\t\tif(!isc){\n\t\t\tif(d1>d2)sc = d1/(d1-d2);\n\t\t\telse sc=d1/(d2-d1);\n\t\t}\n\t\telse sc = d1/(d1+d2);\n\t\treturn (p+vec.scalar(sc));*/\n\t\t\n\t\tdouble t = a.vec.cross(a.p-p)/a.vec.cross(vec);\n\t\treturn (p+vec.scalar(t));\n\t}\n\tline bisection(){//?????´????????????\n\t\t//???????¨??????????90????????£???????????????\n\t\tpos fr=(p+q).scalar(0.5);\n\t\tpos to=fr+pos(-vec.y,vec.x);\n\t\treturn line(fr,to);\n\t}\n};\ndouble lowofcos_getcos(double a,double b,double c){\n\treturn ((a*a+b*b-c*c)/(2*a*b));\n}\nstruct circle{\n\tpos p;\n\tdouble r;\n\tline koten(circle a){\n\t\tpos cv=p.tov(a.p);\n\t\tdouble br=atan2(cv.y,cv.x);\n\t\tdouble dr=acos(lowofcos_getcos( r, cv.norm, a.r));\n\t\tpos p1= p+pos::polar(r,br+dr);\n\t\tpos p2= p+pos::polar(r,br-dr);\n\t\tif(p1>p2)swap(p1,p2);\n\t\treturn line(p1,p2);\n\t}\n\tcircle(pos ip,double ir){\n\t\tp=ip; r=ir;\n\t}\n\tcircle(){}\n\tvoid outh(double mag){\n\t\tchar ns[50];\n\t\taddhtml(\"ctx.beginPath();\"); \n\t\tsprintf(ns,\"ctx.arc(%lf,%lf,%lf,0,360);\",p.x*mag,p.y*mag,r*mag); addhtml(ns);\n\t\t//addhtml(\"ctx.fill();\");\n\t}\n};\nstruct polygon{\n\tvector<pos> ps;\n\tpolygon(){}\n\tvoid outh(double mag){\n\t\tchar ns[50];\n\t\taddhtml(\"ctx.beginPath();\");\n\t\tint ls=ps.size();\n\t\tsprintf(ns,\"ctx.moveTo(%lf,%lf);\",ps[ls-1].x*mag,ps[ls-1].y*mag); addhtml(ns);\n\t\trep(i,ps.size()){\n\t\t\tsprintf(ns,\"ctx.lineTo(%lf,%lf);\",ps[i].x*mag,ps[i].y*mag); addhtml(ns);\n\t\t}\n\t\taddhtml(\"ctx.stroke();\");\n\t}\n\tdouble area(){\n\t\tdouble res=0;\n\t\trep(i,ps.size()){\n\t\t\tpos no=ps[i],to=ps[(i+1)%ps.size()];\n\t\t\tres+=(no.x+to.x)*(no.y-to.y);\n\t\t}\n\t\tif(res<0)reverse(ps.begin(),ps.end());\n\t\treturn abs(res)/2;\n\t}\n\tpolygon(pos a,pos b){\n\t\tps.push_back(a);\n\t\tps.push_back(pos(a.x,b.y));\n\t\tps.push_back(b);\n\t\tps.push_back(pos(b.x,a.y));\n\t}\n\tline gete(int a){\n\t\ta%=ps.size();\n\t\treturn line(ps[a],ps[(a+1)%ps.size()]);\n\t}\n\tint isin(pos a){//?????´??????2,?????£????????????1,?????????0\n\t\tdouble as=0;\n\t\trep(i,ps.size()){\n\t\t\tline ne=gete(i);\n\t\t\tif(ne.dist(a)<=0)return 1;\n\t\t\tpos v1=a.tov(ne.p);\n\t\t\tpos v2=a.tov(ne.q);\n\t\t\tas+=v1.theta(v2);\n\t\t}\n\t\tif(abs(as)<1e-6)return 0;\n\t\treturn 2;\n\t}\n\tpolygon convex_full(){\n\t\tpolygon res;\n\t\tint ns=ps.size();\n\t\tvector<pos> vs(2*ns);\n\t\tsort(ps.begin(),ps.end());\n\t\tint k=0;\n\t\trep(i,ns){\n\t\t\tpos np=ps[i];\n\t\t\twhile(k>1 && vs[k-2].tov(vs[k-1]).cross(vs[k-1].tov(np))<-1e-6)k--;\n\t\t\tvs[k]=np; k++;\n\t\t}\n\t\tint t=k;\n\t\tireg(i,0,ns-2){\n\t\t\tpos np=ps[i];\n\t\t\twhile(k>t && vs[k-2].tov(vs[k-1]).cross(vs[k-1].tov(np))<-1e-6)k--;\n\t\t\tvs[k]=np; k++;\n\t\t}\n\t\tvs.resize(k-1);\n\t\tswap(vs,res.ps);\n\t\treturn res;\n\t}\n\tpolygon cut(line a){//???????????????????????????\n\t\tpolygon res;\n\t\trep(i,ps.size()){\n\t\t\tline ne=gete(i);\n\t\t\tdouble d1=a.vec.cross(a.p.tov(ne.p));\n\t\t\tdouble d2=a.vec.cross(a.p.tov(ne.q));\n\t\t\tif(d1<1e-6)res.ps.push_back(ne.p);\n\t\t\tif(d1*d2<1e-6)res.ps.push_back(a.crosspos(ne));\n\t\t}\n\t\treturn res;\n\t}\n\tvector<polygon> voronoi(vector<pos> ps){\n\t\t/*\n\t\tinithtml();\n\t\trandcolhtml();\n\t\tthis->outh(30);\n\t\t*/\n\t\t\n\t\tvector<polygon> res;\n\t\trep(i,ps.size()){\n\t\t\tpolygon np(*this);\n\t\t\trep(j,ps.size()){\n\t\t\t\tif(i==j)continue;\n\t\t\t\tline nl = line(ps[j],ps[i]).bisection();\n\t\t\t\t\n\t\t\t\tnp = np.cut(nl);\n\t\t\t\t\n\t\t\t\t/*\n\t\t\t\tif(true || (i==0 && j==1)){\n\t\t\t\t\trandcolhtml();\n\t\t\t\t\tnl.outh(30);\n\t\t\t\t\trandcolhtml();\n\t\t\t\t\tnp.outh(30);\n\t\t\t\t}*/\n\t\t\t\t/*\n\t\t\t\tif(j==1){\n\t\t\t\t\tnp.outh(30);\n\t\t\t\t\texit(-1);\n\t\t\t\t}\n\t\t\t\t*/\n\t\t\t}\n\t\t\tres.push_back(np);\n\t\t\t//np.outh(30);\n\t\t}\n\t\t//outhtml(\"o\",30);\n\t\treturn res;\t\t\n\t}\n\tpolygon mult(polygon a){\n\t\treturn a;\n\t}\n};\n\nint main(void){\n\tfor(;;){\n\t\tint n,m;\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tif(n==0)break;\n\t\tpolygon po;\n\t\trep(i,n){\n\t\t\tdouble x,y;\n\t\t\tscanf(\"%lf%lf\",&x,&y);\n\t\t\tpo.ps.push_back(pos(x,y));\n\t\t}\n\t\t\n\t\tvector<pos> tps;\n\t\trep(i,m){\n\t\t\tdouble x,y;\n\t\t\tscanf(\"%lf%lf\",&x,&y);\n\t\t\ttps.push_back(pos(x,y));\n\t\t}\n\t\t\n\t\tvector<polygon> pols = po.voronoi(tps);\n\t\trep(i,m){\n\t\t\tprintf(\"%lf\\n\",pols[i].area());\n\t\t}\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <memory>\n#include <cstring>\n#include <cassert>\n#include <numeric>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <cctype>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\nusing namespace std;\n\n#define REP2(i, m, n) for (int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(S) (S).begin(), (S).end()\ntypedef long long ll;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line_t;\ntypedef pair<xy_t, double> circle_t;\ntypedef vector<xy_t> poly_t;\n\nnamespace std {\n  bool operator<(const xy_t &a, const xy_t &b){\n    return a.real() == b.real() ? a.imag() < b.imag() : a.real() < b.real();\n  }\n}\n\nconst double EPS = 1e-9;\n\ninline bool equal(double a, double b){\n  return abs(a - b) < EPS;\n}\n\nistream &operator>>(istream &is, xy_t &p)   {\n  double x, y;\n  is >> x >> y;\n  p = xy_t(x, y);\n  return is;\n}\n\nistream &operator>>(istream &is, line_t &l) {\n  return is >> l.first >> l.second;\n}\n\ninline double cross(const xy_t &a, const xy_t &b){\n  return imag(conj(a) * b);\n}\n\ninline double dot(const xy_t &a, const xy_t &b){\n  return real(conj(a) * b);\n}\n\ninline xy_t rotate(const xy_t &a, double theta){\n  return a * polar(1.0, theta);\n}\n\ninline xy_t direction(const line_t &line){\n  return line.second - line.first;\n}\n\nint ccw(const xy_t &a, xy_t b, xy_t c){\n  b -= a;\n  c -= a;\n  if (cross(b, c) > 0) return 1;\n  if (cross(b, c) < 0) return -1;\n  if (dot(b, c)   < 0) return 2;\n  if (norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nint ccw(const line_t &l, const xy_t &a){\n  return ccw(l.first, l.second, a);\n}\n\nline_t bisector(const xy_t &a, const xy_t &b){\n  xy_t v = rotate(b - a, M_PI / 2);\n  xy_t m = (a + b) * 0.5;\n  return line_t (m, m + v);\n};\n\nxy_t crosspoint(const line_t &l, const line_t &m){\n  xy_t l_vec = direction(l);\n  xy_t m_vec = direction(m);\n  double A = cross(l_vec, m_vec);\n  assert(!equal(A, 0));\n  return m.first + cross(l_vec, l.second-m.first) / A * m_vec;\n}\n\ninline size_t next_index(const poly_t &poly, size_t curr){\n  return (curr + 1) % poly.size();\n}\n\ninline size_t prev_index(const poly_t &poly, size_t curr){\n  return (curr + poly.size() - 1)  % poly.size();\n}\n\npoly_t convex_cut(const poly_t &poly, const line_t &line){\n  poly_t new_poly;\n  \n  for (size_t i = 0; i < poly.size(); i++){\n    xy_t a = poly[i];\n    xy_t b = poly[next_index(poly, i)];\n\n    if (ccw(line, a) != -1) new_poly.push_back(a);\n\n    if (ccw(line, a) * ccw(line, b) < 0){\n      new_poly.push_back(crosspoint(line_t (a, b), line));\n    }\n  }\n  return new_poly;\n}\n\ndouble signed_area(const poly_t &poly){\n  double res = 0;\n  for (size_t i = 0; i < poly.size(); i++){\n    res += cross(poly[i], poly[next_index(poly, i)]);\n  }\n  return res * 0.5;\n}\n\ndouble area(const poly_t &poly){\n  return abs(signed_area(poly));\n}\n\n\nint main(){\n  ios::sync_with_stdio(false);\n  int N, M;\n  while (cin >> N >> M && N + M){\n    poly_t poly(N);\n    REP(i, N){\n      cin >> poly[i];\n    }\n    \n    vector<xy_t> L(M);\n    REP(i, M){\n      cin >> L[i];\n    }\n    \n\n    REP(i, M){\n      poly_t pi = poly;\n      \n      REP(j, M) if (i != j){\n        pi = convex_cut(pi, bisector(L[i], L[j]));\n      }\n      \n      cout << area(pi) << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define EPS 1e-10\n#define equal(a,b) (fabs(a-b) < EPS)\n#define lt(a,b) (a-b < -EPS)\n\nstruct Point{\n    double x,y;\n\n    Point(){}\n    Point(double x,double y) : x(x),y(y) {}\n\n    Point operator + (const Point &p)const{ return Point(x+p.x,y+p.y); }\n    Point operator - (const Point &p)const{ return Point(x-p.x,y-p.y); }\n    Point operator * (const double &k)const{ return Point(x*k,y*k); }\n};\n\ndouble dot(const Point &a,const Point &b){ return a.x*b.x + a.y*b.y; }\ndouble cross(const Point &a,const Point &b){ return a.x*b.y - b.x*a.y; }\ndouble norm(const Point &p){ return dot(p,p); }\ndouble abs(const Point &p){ return sqrt(norm(p)); }\n\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\ntypedef Point Vector;\n\nint ccw(Point p0,Point p1,Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if(cross(a,b) > EPS) return COUNTER_CLOCKWISE;\n    if(cross(a,b) < -EPS) return CLOCKWISE;\n    if(dot(a,b) < -EPS) return ONLINE_BACK;\n    if(norm(a) < norm(b)) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nstruct Segment{\n    Point s,t;\n    Segment(){}\n    Segment(Point s,Point t) : s(s),t(t) {}\n};\n\ntypedef Segment Line;\n\nLine getPerpendicularBisector(const Point &a,const Point &b){\n    double cx = (a.x + b.x) / 2.0;\n    double cy = (a.y + b.y) / 2.0;\n    Point p = Point(cx + (a.y - b.y), cy + (b.x - a.x));\n    return Line(Point(cx,cy),p);\n}\n\nPoint crosspointLL(const Line &a,const Line &b){\n    Vector va = a.t-a.s, vb = b.t-b.s;\n    double d = cross(vb,va);\n    if(abs(d) < EPS) return b.s;\n    return a.s+va*cross(vb,b.t-a.s)*(1.0/d);\n}\n\n#define prev(G,i) (G[(i-1+G.size())%G.size()])\n#define curr(G,i) (G[i%G.size()])\n#define next(G,i) (G[(i+1)%G.size()])\ntypedef vector<Point> Polygon;\n\nPolygon convex_cut(const Polygon &pg,const Line &l){\n    Polygon res;\n    for(int i = 0 ; i < (int)pg.size() ; i++){\n        Point cp = curr(pg,i), np = next(pg,i);\n        if(ccw(l.s,l.t,cp) != -1) res.push_back(cp);\n        if(ccw(l.s,l.t,cp)*ccw(l.s,l.t,np) < 0){\n            res.push_back(crosspointLL(Line(cp,np),l));\n        }\n    }\n    return res;\n}\n        \ndouble area(const Polygon &pg){\n    double res = 0;\n    for(int i = 0 ; i < (int)pg.size() ; i++){\n        res += cross(pg[i],next(pg,i));\n    }\n    return abs(res)/2.0;\n}\n\nint main(){\n    int N,M;\n    while(cin >> N >> M, N){\n        Polygon pg(N);\n        for(int i = 0 ; i < N ; i++){\n            cin >> pg[i].x >> pg[i].y;\n        }\n        vector<Point> ps(M);\n        for(int i = 0 ; i < M ; i++){\n            cin >> ps[i].x >> ps[i].y;\n        }\n        for(int i = 0 ; i < M ; i++){\n            Polygon p = pg;\n            for(int j = 0 ; j < M ; j++){\n                if(i == j) continue;\n                p = convex_cut(p,\n                               getPerpendicularBisector(ps[i],ps[j]));\n            }\n            printf(\"%.15f\\n\",area(p));\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef pair<P,P> L;\n\nconst double EPS = 1E-6;\n\ndouble dot(P a, P b){ return real(conj(a)*b); }\ndouble cross(P a, P b){ return imag(conj(a)*b); }\n\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > EPS) return 1;\n  if(cross(b,c) < -EPS) return -1;\n  if(dot(b,c) < -EPS) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n\ndouble area(vector<P> v){\n  double sum = 0.0;\n  int n = v.size();\n  for(int i=0;i<n;i++) sum += (real(v[i]) - real(v[(i+1)%n])) * (imag(v[i]) + imag(v[(i+1)%n]));\n  return fabs(sum) / 2;\n};\n\nP crossPoint(L l, L m){\n  double A = cross(l.second - l.first, m.second - m.first);\n  double B = cross(l.second - l.first, l.second - m.first);\n  if(fabs(A) < EPS && fabs(B) < EPS) return m.first;\n  else if(fabs(A) >= EPS) return m.first + B / A * (m.second - m.first);\n}\n\nvector<P> convex_cut(vector<P> G, L l){\n  vector<P> ans;\n  for(int i=0;i<G.size();i++){\n    P A = G[i];\n    P B = G[(i+1)%G.size()];\n    if(ccw(l.first, l.second, A) != -1) ans.push_back(A);\n    if(ccw(l.first, l.second, A) * ccw(l.first, l.second, B) < 0)\n      ans.push_back(crossPoint(L(A,B), l));\n  }\n  return ans;\n}\n\n\nint N,M;\nvector<P> V,C;\n\nint main(){\n\n  while( cin >> N >> M && (N||M) ){\n    V.clear(); C.clear();\n    for(int i=0;i<N;i++){\n      int x,y; cin >> x >> y;\n      V.push_back(P(x,y));\n    }\n    for(int i=0;i<M;i++){\n      int x,y; cin >> x >> y;\n      C.push_back(P(x,y));\n    }\n\n    for(int i=0;i<M;i++){\n      vector<P> sp = V;\n      for(int j=0;j<M;j++){\n        if( i == j ) continue;\n        P c = (C[i] - C[j])/2.0 + C[j];\n        P r = C[i]-C[j];\n        r = P( r.imag(), -r.real() );\n        L s = L(c,c+r);\n        //\tcout << i << \" <> \" << j << \" \" << s.first << \" \"<< s.second << endl;\n        sp = convex_cut(sp,s);\n      }\n      printf(\"%.10lf\\n\",area(sp));\n    }\n\n\n  }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<complex>\n\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef vector<P> Polygon;\n\ndouble cross(P a,P b){\n  return (conj(a)*b).imag();\n}\n\n//line,line\nP intersection(P a1,P a2,P b1,P b2){\n  P a=a2-a1;\n  P b=b2-b1;\n  return a1+a*cross(b,b1-a1)/cross(b,a);\n}\n\n//a->b keep leftside points\nPolygon cut(P a,P b,const Polygon &p){\n  int n=p.size();\n  vector<double> c(n);\n  for(int i=0;i<n;i++){\n    c[i]=cross(b-a,p[i]-a);\n  }\n  Polygon r;\n  for(int i=0;i<n;i++){\n    if(c[i]>=n){\n      r.push_back(p[i]);\n    }\n    if(c[i]*c[(i+1)%n]<0){\n      r.push_back(intersection(a,b,p[i],p[(i+1)%n]));\n    }\n  }\n  return r;\n}\n\ndouble area(const Polygon &p){\n  double a=0;\n  for(int i=0;i<p.size();i++){\n    a+=cross(p[(i+1)%p.size()],p[i]);\n  }\n  return fabs(a)/2;\n}\n\nint main(){\n  for(int N,M;cin>>N>>M,N;){\n    Polygon p;\n    for(int i=0;i<N;i++){\n      int x,y;\n      cin>>x>>y;\n      p.emplace_back(x,y);\n    }\n    vector<P> c;\n    for(int i=0;i<M;i++){\n      int x,y;\n      cin>>x>>y;\n      c.emplace_back(x,y);\n    }\n    for(int i=0;i<M;i++){\n      Polygon cp=p;\n      for(int j=0;j<M;j++){\n\tif(i==j)continue;\n\tP m=(c[i]+c[j])/2.;\n\tP d=(c[j]-c[i])*P(0,1)+m;\n\tcp=cut(m,d,cp);\n      }\n      cout.precision(9);\n      cout<<fixed<<area(cp)<<endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nlong double EPS = 1e-5;\n\nclass Point {\npublic:\n\tlong double px, py;\n\tPoint() : px(0), py(0) {};\n\tPoint(long double px_, long double py_) : px(px_), py(py_) {};\n\tbool operator==(const Point& p) const { return fabs(px - p.px) < EPS && fabs(py - p.py) < EPS; }\n\tbool operator!=(const Point& p) const { return fabs(px - p.px) > EPS || fabs(py - p.py) > EPS; }\n\tbool operator<(const Point& p) const { return p.px - px > EPS ? true : (fabs(px - p.px) < EPS && p.py - py > EPS); }\n\tbool operator>(const Point& p) const { return px - p.px > EPS ? true : (fabs(px - p.px) < EPS && py - p.py > EPS); }\n\tbool operator<=(const Point& p) const { return !(Point(px, py) > p); }\n\tbool operator>=(const Point& p) const { return !(Point(px, py) < p); }\n\tPoint operator+(const Point& p) const { return Point(px + p.px, py + p.py); }\n\tPoint operator-(const Point& p) const { return Point(px - p.px, py - p.py); }\n\tPoint operator/(long double d) const { return Point(px / d, py / d); }\n\tfriend Point operator*(const Point p, long double d) { return Point(p.px * d, p.py * d); }\n\tfriend Point operator*(long double d, const Point& p) { return p * d; }\n\tPoint& operator+=(const Point& p1) { px += p1.px, py += p1.py; return *this; }\n\tPoint& operator-=(const Point& p1) { px -= p1.px, py -= p1.py; return *this; }\n\tPoint& operator*=(long double d) { px *= d, py *= d; return *this; }\n\tPoint& operator/=(long double d) { px /= d, py /= d; return *this; }\n};\nclass Line {\npublic:\n\tPoint p1, p2;\n\tLine() : p1(Point()), p2(Point()) {};\n\tLine(Point p1_, Point p2_) : p1(p1_), p2(p2_) {};\n\tLine(long double p1x, long double p1y, long double p2x, long double p2y) : p1(Point(p1x, p1y)), p2(Point(p2x, p2y)) {};\n\tbool operator==(const Line& s) const { return (p1 == s.p1 && p2 == s.p2) || (p1 == s.p2 && p2 == s.p1); }\n\tbool operator!=(const Line& s) const { return !(Line(p1, p2) == s); }\n};\n\nlong double norm(const Point& a) { return a.px * a.px + a.py * a.py; }\nlong double crs(const Point& a, const Point& b) { return a.px * b.py - a.py * b.px; }\nlong double abs(const Point& a) { return sqrtl(norm(a)); }\nlong double dot(const Point& a, const Point& b) { return a.px * b.px + a.py * b.py; }\nlong double dist(const Point& a, const Point& b) { return abs(b - a); }\n\nint ccw(const Point& p0, const Point& p1, const Point& p2) {\n\tPoint a = p1 - p0, b = p2 - p0;\n\tif (crs(a, b) > EPS) return 1;\n\tif (crs(a, b) < -EPS) return -1;\n\tif (dot(a, b) < -EPS) return 2;\n\tif (norm(b) - norm(a) > EPS) return -2;\n\treturn 0;\n}\nLine calc(Line a) {\n\t//return a;\n\tif (a.p1 == a.p2) return a;\n\n\tPoint E = (a.p1 + a.p2); E.px /= 2.0L; E.py /= 2.0L;\n\tlong double ex = a.p2.px - E.px, ey = a.p2.py - E.py;\n\tlong double BAR = 1000.0L / sqrtl(ex * ex + ey * ey);\n\tex *= BAR; ey *= BAR;\n\treturn Line{ Point{E.px - ex, E.py - ey}, {E.px + ex, E.py + ey} };\n}\nPoint crp(Line a, Line b) {\n\ta = calc(a); b = calc(b);\n\tPoint c = b.p2 - b.p1;\n\tlong double d1 = abs(crs(c, a.p1 - b.p1));\n\tlong double d2 = abs(crs(c, a.p2 - b.p1));\n\treturn a.p1 + (a.p2 - a.p1) * (d1 / (d1 + d2));\n}\nlong double area(vector<Point> v) {\n\tlong double ret = 0.0L;\n\tfor (int i = 0; i < v.size(); i++) ret += crs(v[i], v[(i + 1) % v.size()]);\n\treturn ret / 2;\n}\nint contain(vector<Point> v, Point p) {\n\tbool in = false;\n\tfor (int i = 0; i < v.size(); ++i) {\n\t\tPoint a = v[i] - p, b = v[(i + 1) % v.size()] - p;\n\t\tif (a.py > b.py) swap(a, b);\n\t\tif (a.py <= EPS && EPS < b.py)\n\t\t\tif (crs(a, b) < -EPS) in = !in;\n\t\tif (fabs(crs(a, b)) < EPS && dot(a, b) <= EPS) return 1;\n\t}\n\treturn in ? 2 : 0;\n}\nvector<Point> convex_hull(vector<Point> v) {\n\tif (v.size() < 3) return v;\n\tsort(v.begin(), v.end());\n\tvector<Point> u = { v[0], v[1] }, l = { v[v.size() - 1], v[v.size() - 2] };\n\tfor (int i = 2; i < v.size(); i++) {\n\t\tfor (int n = u.size(); n >= 2 && ccw(u[n - 2], u[n - 1], v[i]) >= 0; n--) u.pop_back();\n\t\tu.push_back(v[i]);\n\t}\n\tfor (int i = v.size() - 3; i >= 0; i--) {\n\t\tfor (int n = l.size(); n >= 2 && ccw(l[n - 2], l[n - 1], v[i]) >= 0; n--) l.pop_back();\n\t\tl.push_back(v[i]);\n\t}\n\treverse(l.begin(), l.end());\n\tfor (int i = u.size() - 2; i >= 1; i--) l.push_back(u[i]);\n\treturn l;\n}\n\nlong double Degree(Line r) {\n\tlong double vx = (r.p2.px - r.p1.px);\n\tlong double vy = (r.p2.py - r.p1.py);\n\tif (vy < 0) { vy *= -1; vx *= -1; }\n\treturn vx / sqrtl(vx * vx + vy * vy);\n}\n\nint N, M; Point C[19], E[19];\nvector<Line>A; vector<Point>B, J[19];\n\nvoid init() {\n\tfor (int i = 0; i < 19; i++) { C[i] = Point{ 0,0 }; E[i] = Point{ 0,0 }; J[i].clear(); }\n\tB.clear(); A.clear(); N = 0; M = 0;\n}\n\nint main() {\n\twhile (true) {\n\t\tinit();\n\t\tcin >> N >> M; if (N == 0 && M == 0) break;\n\t\tvector<Point>L;\n\t\tfor (int i = 0; i < N; i++) { cin >> C[i].px >> C[i].py; L.push_back(C[i]); }\n\t\tfor (int i = 0; i < M; i++) cin >> E[i].px >> E[i].py;\n\n\t\tfor (int i = 0; i < N; i++) A.push_back(Line{ C[i], C[(i + 1) % N] });\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tfor (int j = i + 1; j < M; j++) {\n\t\t\t\tPoint T = (E[i] + E[j]); T.px /= 2.0L; T.py /= 2.0L;\n\t\t\t\tdouble e1 = (E[i].px - T.px), e2 = (E[i].py - T.py);\n\t\t\t\tPoint A1 = Point{ T.px - e2, T.py + e1 };\n\t\t\t\tPoint A2 = Point{ T.px + e2, T.py - e1 };\n\t\t\t\tA.push_back(Line{ A1, A2 });\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < A.size(); i++) {\n\t\t\tfor (int j = i + 1; j < A.size(); j++) {\n\t\t\t\tlong double T1 = Degree(A[i]);\n\t\t\t\tlong double T2 = Degree(A[j]);\n\n\t\t\t\tif (fabs(T1 - T2) < EPS) continue;\n\n\t\t\t\tPoint F = crp(A[i], A[j]);\n\t\t\t\tif (contain(L, F) >= 1) B.push_back(F);\n\t\t\t}\n\t\t}\n\n\t\tsort(B.begin(), B.end());\n\t\tB.erase(unique(B.begin(), B.end()), B.end());\n\t\tfor (int i = 0; i < B.size(); i++) {\n\t\t\tlong double maxn = 1e9;\n\t\t\tfor (int j = 0; j < M; j++) maxn = min(maxn, dist(E[j], B[i]));\n\n\t\t\tfor (int j = 0; j < M; j++) {\n\t\t\t\tlong double G = dist(E[j], B[i]);\n\t\t\t\tif (G - maxn < EPS) J[j].push_back(B[i]);\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tsort(J[i].begin(), J[i].end());\n\t\t\tJ[i].erase(unique(J[i].begin(), J[i].end()), J[i].end());\n\t\t\tvector<Point> U = convex_hull(J[i]);\n\n\t\t\tlong double ans = area(U);\n\t\t\tprintf(\"%.12Lf\\n\", ans);\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\ntypedef long double ld;\nconst ld PI = acos(-1.0);\nbool eq(ld a, ld b) { return abs(a - b) < EPS; }\ntypedef complex<ld> Point;\ntypedef vector<Point> Polygon;\n\nnamespace std\n{\n\tbool operator < (const Point& a, const Point& b)\n\t{\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\nstruct Line\n{\n\tPoint a, b;\n\tLine(Point p, Point q) :a(p), b(q) {};\n\tLine(ld x1, ld y1, ld x2, ld y2) :a(Point(x1, y1)), b(Point(x2, y2)) {};\n};\n\nstruct Circle\n{\n\tPoint p; ld r;\n\tCircle(Point a, ld b) :p(a), r(b) {};\n};\n\nld dot(Point a, Point b)\n{\n\treturn real(conj(a)*b);\n}\n\nld cross(Point a, Point b)\n{\n\treturn imag(conj(a)*b);\n}\n\nint ccw(Point a, Point b, Point c)\n{\n\tb -= a; c -= a;\n\tif (cross(b, c) > EPS) return 1;    //counter cloclwise\n\tif (cross(b, c) < -EPS) return -1;  //cloclwise\n\tif (dot(b, c) < 0) return 2;        //c--a--b on line \n\tif (norm(b) < norm(c)) return -2;   //a--b--c on line\n\treturn 0;                           //a--c--b on line\n}\n\nbool isis_ll(Line l, Line m)\n{\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > EPS;\n}\n\nbool isis_ls(Line l, Line s)\n{\n\treturn cross(l.b - l.a, s.a - l.a)*cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool isis_ss(Line s, Line t)\n{\n\treturn (ccw(s.a, s.b, t.a)*ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a)*ccw(t.a, t.b, s.b) <= 0);\n}\n\nbool isis_lp(Line l, Point p)\n{\n\treturn (abs(cross(l.b - p, l.a - p)) < EPS);\n}\n\nbool isis_sp(Line s, Point p)\n{\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a)) < EPS;\n}\n\nPoint projection(Line l, Point p)\n{\n\tPoint base = l.b - l.a;\n\tld r = dot(p - l.a, base) / norm(base);\n\treturn l.a + base*r;\n}\n\nPoint mirror(Line l, Point p)\n{\n\treturn Point(2, 0)*projection(l, p) - p;\n}\n\nld dist_lp(Line l, Point p)\n{\n\treturn abs(p - projection(l, p));\n}\n\nld dist_ll(Line l, Line m)\n{\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(Line l, Line s)\n{\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(Line s, Point p)\n{\n\tPoint r = projection(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(Line s, Line t)\n{\n\tif (isis_ss(s, t)) return 0;\n\treturn min(min(dist_sp(s, t.a), dist_sp(s, t.b)), min(dist_sp(t, s.a), dist_sp(t, s.b)));\n}\n\nPoint is_ll(Line s, Line t)\n{\n\tld a = cross(s.b - s.a, t.b - t.a);\n\tld b = cross(s.b - s.a, s.b - t.a);\n\treturn t.a + b / a*(t.b - t.a);\n}\n\nvector<Point> is_cc(Circle c1, Circle c2)\n{\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d*d + pow(c1.r, 2) - pow(c2.r, 2)) / (2 * d);\n\tld dfr = pow(c1.r, 2) - rc*rc;\n\tif (abs(dfr) < EPS) dfr = 0;\n\tif (dfr < 0.0) return res;\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff*Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff*Point(rc, -rs));\n\treturn res;\n}\n\nint isis_cc(Circle c1, Circle c2)\n{\n\tld d = abs(c1.p - c2.p);\n\tif (d - c1.r - c2.r < -EPS) return -2; //separate\n\tif (abs(d - c1.r - c2.r) < EPS) return -1; //circumscribe\n\tif (c1.r < c2.r) swap(c1, c2);\n\tif (abs(d - c1.r + c2.r) < EPS) return 1;//inscribe\n\tif (c1.r - d - c2.r > EPS) return 2;//involve\n\telse return 0;//intersect\n}\n\nbool isis_cl(Circle c, Line l)\n{\n\tld d = dist_lp(l, c.p);\n\treturn d - c.r < -EPS;\n}\n\nvector<Point> is_cl(Circle c, Line l)\n{\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d > c.r + EPS) return res;\n\tld len = (d > c.r) ? 0 : sqrt(c.r*c.r - d*d);\n\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\tres.push_back(projection(l, c.p) + len*nor);\n\tif (abs(len) > EPS) res.push_back(projection(l, c.p - len*nor));\n\treturn res;\n}\n\nvector<Point> is_cs(Circle c, Line s)\n{\n\tvector<Point> v = is_cl(c, s), res;\n\tREP(i, v.size())\n\t{\n\t\tif (ccw(s.a, v[i], s.b) == -2) res.push_back(v[i]);\n\t}\n\treturn res;\n}\n\nvector<Line> tangent_cp(Circle c, Point p)\n{\n\tvector<Line> res;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return res; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tres.push_back(Line(p, p + v1));\n\tif (l < EPS) return res;\n\tres.push_back(Line(p, p + v2));\n\treturn res;\n}\n\nvector<Line> tangent_cc(Circle c1, Circle c2)\n{\n\tvector<Line> res;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -EPS)\n\t{\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tres = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > EPS)\n\t{\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nres = tangent_cp(c1, out);\n\t\tres.insert(res.end(), nres.begin(), nres.end());\n\t}\n\telse\n\t{\n\t\tPoint v = c2.p - c1.p; v /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tres.push_back(Line(q1, q1 + v));\n\t\tres.push_back(Line(q2, q2 + v));\n\t}\n\treturn res;\n}\n\nPolygon ConvexCut(const Polygon& g, const Line l)\n{\n\tPolygon res;\n\tREP(i, g.size())\n\t{\n\t\tPoint a = g[i], b = g[(i + 1) % g.size()];\n\t\tif (ccw(l.a, l.b, a) != -1) res.push_back(a);\n\t\tif (ccw(l.a, l.b, a)*ccw(l.a, l.b, b) < 0) res.push_back(is_ll(Line(a, b), l));\n\t}\n\treturn res;\n}\n\nvector<Line> sui(Point a, Point b)\n{\n\tPoint m = (a + b) / Point(2, 0);\n\tPoint v = b - a;\n\tPoint n1(v.imag(), -v.real()), n2(-v.imag(), v.real());\n\tvector<Line> res = { Line(m, m + n1), Line(m,m + n2) };\n\treturn res;\n}\n\n\nld area(const Polygon& p)\n{\n\tld res = 0;\n\tREP(i, p.size())\n\t{\n\t\tres += cross(p[i], p[(i + 1) % p.size()]);\n\t}\n\treturn res / 2;\n}\n\n\nint main()\n{\n\tint n, m;\n\twhile (cin >> n >> m, n)\n\t{\n\t\tPolygon g;\n\t\tREP(i, n)\n\t\t{\n\t\t\tld x, y;\n\t\t\tcin >> x >> y;\n\t\t\tg.emplace_back(x, y);\n\t\t}\n\t\tvector<Point> ps;\n\t\tREP(i, m)\n\t\t{\n\t\t\tld x, y;\n\t\t\tcin >> x >> y;\n\t\t\tps.emplace_back(x, y);\n\t\t}\n\t\tREP(i, m)\n\t\t{\n\t\t\tPolygon tmp = g;\n\t\t\tREP(j, m)\n\t\t\t{\n\t\t\t\tif (i == j) continue;\n\t\t\t\tvector<Line> ls = sui(ps[i], ps[j]);\n\n\t\t\t\tif (ccw(ls[0].a, ls[0].b, ps[i]) == 1) tmp = ConvexCut(tmp, ls[0]);\n\t\t\t\telse tmp = ConvexCut(tmp, ls[1]);\n\t\t\t}\n\t\t\tcout << D10 << area(tmp) << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <cassert>\n#include <iomanip>\n#include <algorithm>\nusing namespace std;\n\n#define EPS 1e-8\ntypedef complex<double> P;\ntypedef vector<P> G;\n\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\n\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\n\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nint ccw(P a, P b, P c)\n{\n\tb -= a; c -= a;\n\tif (cross(b, c) > +EPS) return +1;\n\tif (cross(b, c) < -EPS) return -1;\n\tif (dot(b, c)   < -EPS) return +2;\n\tif (norm(b) < norm(c))  return -2;\n\treturn 0;\n}\n\nbool notleft(P a, P b, P c)\n{\n\treturn (ccw(a,b,c)!=+1);\n}\n\nbool isIntoG(const G& g, const P& p)\n{\n\tsize_t sz = g.size();\n\tfor(size_t i=0; i<sz; i++)\n\t{\n\t\tif( notleft(p, g[i], g[(i+1)%sz]) ) return false;\n\t}\n\treturn true;\n}\n\nbool isfar(G& g, P& p)\n{\n\tfor(int i=0; i<g.size(); i++)\n\t\tif(abs(g[i]-p) < EPS) return false;\n\t\t\n\treturn true;\n}\n\n#define CURR(P, i) P[i]\n#define NEXT(P, i) P[(i+1)%P.size()]\n\nvector<G> ConvexCut(G& g, L& l)\n{\n\tvector<G> ret(2);\n\tint sp,inp=0;\n\tfor(sp=0; sp<g.size(); sp++)\n\t\tif(intersectLS(l, L(g[sp], g[(sp+1)%g.size()]))) break;\n\t\t\n\tP xp=crosspoint(l, L(g[sp], g[(sp+1)%g.size()]));\n\tsp++;\n\t\n\tfor(int i=sp; i<sp+g.size(); i++)\n\t{\n\t\tif(isfar(ret[inp], g[i%g.size()])) ret[inp].push_back(g[i%g.size()]);\n\t\tif(intersectLS(l, L(g[i%g.size()], g[(i+1)%g.size()])))\n\t\t{\n\t\t\tP tx=crosspoint(l, L(g[i%g.size()], g[(i+1)%g.size()]));\n\t\t\tif(abs(tx-xp) < EPS) continue;\n\t\t\t\n\t\t\txp=tx;\n\t\t\tfor(int j=0; j<2; j++)\n\t\t\t{\n\t\t\t\tif(isfar(ret[j], xp)) ret[j].push_back(xp);\n\t\t\t}\n\t\t\t\n\t\t\tinp++;\n\t\t}\n\t}\n\t\n\treturn ret;\n}\n\nL trans(P a, P b)\n{\n\tP med=(a+b);\n\tmed=P(med.real()/2, med.imag()/2);\n\tP hoge=(a-b);\n\thoge*=P(0,1);\n\t\n\treturn L(med+hoge*P(1000,0), med-hoge*P(1000,0));\n}\n\ndouble Area(G& g)\n{\n\tdouble ret=0;\n\tfor(int i=0; i<g.size(); i++)\n\t\tret+=cross(CURR(g,i), NEXT(g,i))/2;\n\t\t\n\treturn ret;\n}\n\nint main()\n{\n\tcout << setiosflags(ios::fixed) << setprecision(7);\n\tint N,M;\n\n\twhile(cin >> N >> M, (N||M))\n\t{\n\t\tG g,pts;\n\t\tfor(int i=0; i<N; i++)\n\t\t{\n\t\t\tdouble x,y;\n\t\t\tcin >> x >> y;\n\t\t\tg.push_back(P(x,y));\n\t\t}\n\t\tfor(int i=0; i<M; i++)\n\t\t{\n\t\t\tdouble x,y;\n\t\t\tcin >> x >> y;\n\t\t\tpts.push_back(P(x,y));\n\t\t}\n\t\t\n\t\tfor(int i=0; i<M; i++)\n\t\t{\n\t\t\tG f=g;\n\t\t\tfor(int j=0; j<M; j++)\n\t\t\t{\n\t\t\t\tif(i==j) continue;\n\t\t\t\tL divide=trans(pts[i], pts[j]);\n\t\t\t\tvector<G> cut=ConvexCut(f, divide);\n\t\t\t\tif(isIntoG(cut[0], pts[i])) f=cut[0];\n\t\t\t\telse f=cut[1];\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tcout << Area(f) << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <complex>\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef vector<vector<int> > vii;\ntypedef vector<vector<string> > vss;\ntypedef pair<int, int> pii;\n#define INF 0x7fffffff\n//#define INFLL 0x7fffffffffffffff\n#define INFLL LLONG_MAX\n#define SIZE(v) int((v).size())\n#define ALL(v) (v).begin(), (v).end()\n#define FOR(i,x) for(int i=0;i<x;i++)\n#define FORic(i,y,x) for(int i=y;i<=x;i++)\n#define FORdc(i,y,x) for(int i=y;i>=x;i--)\n#define FILL(a,v) memset(a, v, sizeof(a))\n#define PI 3.14159265358979323846\n\nconst double EPS = 1e-7;\ntypedef complex<double> P; /* _ */\nstruct L {                 /* üª */\n\tdouble angle; // deleteSameLineðgpµÈ¢Àèsv\n\tP p, q;\n\tL(P p, P q) : p(p), q(q), angle(arg(q-p)) {}\n\tbool operator < (const L &l) const {  // deleteSameLineðgpµÈ¢Àèsv\n\t\treturn angle < l.angle;\n    }\n};\ntypedef vector<P> G;\n\n\n// complexÉå¬ÖWªKvÈê\nbool operator < (const P &a, const P &b) {\n\treturn make_pair(real(a),imag(a)) < make_pair(real(b),imag(b));\n}\n\n// àÏEOÏEpx(xNga,bÌZ)\ndouble dot(P a, P b) { return real(conj(a)*b); }\ndouble cross(P a, P b) { return imag(conj(a)*b); }\ndouble angle(P a, P b) { return arg(conj(a)*b); }\n\n// _pÆ_qÌ¼ñªüðÔ·\nL pointBisector(P p, P q) {\n\tP cen = (p+q)*0.5;\n\treturn L(cen, cen+(q-p)*P(0,1));\n}\n\n// Ê½p`gðC2_p, qðÔüªÅØf·é\nG convexCut(G g, P p, P q){\n\tG res;\n\tint n = g.size();\n\tfor(int i=0;i<n;i++){\n\t\tP A(g[i]), B(g[(i+1)%n]);\n\t\tdouble p1 = cross(q-p,A-p);\n\t\tdouble p2 = cross(q-p,B-p);\n\t\tif(p1 > -EPS) res.push_back(A);\n\t\tif(p1*p2 < -EPS)\n\t\t\tres.push_back(A+cross(q-p,q-A)/cross(q-p,B-A)*(B-A));\n\t}\n\treturn res;\n}\n\n// ½p`gÌÊÏðßé\ndouble polygonArea(G g){\n\tdouble res = 0.0;\n\tfor(int i=0;i<g.size();i++)\n\t\tres += cross(g[i],g[(i+1)%g.size()]);\n\treturn abs(0.5*res);\n}\n\nint main(){\n\tint n, m;\n\twhile(cin>>n>>m){\n\t\tif(!n&&!m) break;\n\t\tG island;\n\t\tvector<P> cas;\n\t\tFOR(i, n){\n\t\t\tint a, b;\n\t\t\tcin>>a>>b;\n\t\t\tisland.push_back(P(a,b));\n\t\t}\n\t\tFOR(i, m){\n\t\t\tint a, b;\n\t\t\tcin>>a>>b;\n\t\t\tcas.push_back(P(a,b));\n\t\t}\n\t\tFOR(i, m){\n\t\t\tG temp = island;\n\t\t\tFOR(j, m){\n\t\t\t\tif(j==i) continue;\n\t\t\t\tL nitou = pointBisector(cas[i],cas[j]);\n\t\t\t\tif(cross(nitou.q-nitou.p, cas[i]-nitou.p)>0){\n\t\t\t\t\ttemp = convexCut(temp, nitou.p, nitou.q);\n\t\t\t\t} else {\n\t\t\t\t\ttemp = convexCut(temp, nitou.q, nitou.p);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdouble s = polygonArea(temp);\n\t\t\tcout<<s<<endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<(int)(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nconst ld eps = 1e-8, pi = acos(-1.0);\n\n#define EQ(a,b) (abs((a)-(b))<eps)\n\nnamespace std {\n  bool operator<(const P &lhs, const P &rhs) {\n    return lhs.real() == rhs.real() ? lhs.imag() < rhs.imag()\n                                    : lhs.real() < rhs.real();\n  }\n}\n\nld dot (P a, P b) { return real(conj(a) * b); }\nld cross (P a, P b) { return imag(conj(a) * b); }\n\nstruct L{ P a, b; };\n\nint ccw (P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > eps) return 1;   // counter clockwise\n  if (cross(b, c) < -eps) return -1; // clockwise\n  if (dot(b, c) < 0) return 2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line\n  return 0;                          // a--c--b on line\n}\n\nbool isis_ls(L l, L s) {\n  ld a = cross(l.b - l.a, s.a - l.a);\n  ld b = cross(l.b - l.a, s.b - l.a);\n  return (a * b < eps);\n}\n\nP is_ll(L s, L t){\n  P sv = s.b - s.a, tv = t.b - t.a;\n  return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n  return abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nld area(const VP &p) {\n  ld res = 0;\n  int n = p.size();\n  REP(j,n) res += cross(p[j], p[(j+1)%n]);\n  return res / 2;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n  bool in = false;\n  int n = g.size();\n  for (int i = 0; i < n; i++) {\n    P a = g[i] - p, b = g[(i+1)%n] - p;\n    if (imag(a) > imag(b)) swap(a, b);\n    if (imag(a) <= 0 && 0 < imag(b))\n      if (cross(a, b) < 0) in = !in;\n    if (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n  }\n  if(in) return 1; // in\n  return -1; // out\n}\n\nint main() {\n  while(1){\n    int n,m;\n    cin>>n>>m;\n    if(!n) break;\n    VP pl,vp;\n    REP(i,n){\n      int x,y;\n      cin>>x>>y;\n      pl.emplace_back(x,y);\n    }\n    REP(i,m){\n      int x,y;\n      cin>>x>>y;\n      vp.emplace_back(x,y);\n    }\n    REP(i,m) {\n      VP poly = pl;\n      REP(j,m) {\n        if (j == i) continue;\n        P pc = (vp[i] + vp[j]) / ld(2.0);\n        P ig(0,1);\n        L l1 = {pc, (vp[j] - pc) * ig + pc};\n        vector<pair<int,P>> is;\n        REP(k,poly.size()) {\n          L l2 = {poly[k], poly[(k+1)%poly.size()]};\n          P crs = is_ll(l1, l2);\n          if (isis_sp(l2, crs) && !EQ(l2.b, crs)) {\n            is.emplace_back(k, is_ll(l1, l2));\n          }\n        }\n        sort(ALL(is));\n        do {\n          int k; P p;\n          tie(k, p) = is[0];\n          int l; P q;\n          tie(l, q) = is[1];\n          if (l < k) l += poly.size();\n          VP np;\n          np.push_back(p);\n          FOR(a,k+1,l+1) {\n            np.push_back(poly[a%poly.size()]);\n          }\n          np.push_back(q);\n          if (is_in_Polygon(np, vp[i]) > 0) {\n            poly = np;\n            break;\n          }\n        } while(next_permutation(ALL(is)));\n      }\n      cout <<fixed << setprecision(10)<< area(poly) << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i=((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=((int)(b));i>=((int)(a));i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n#define IINF INT_MAX\n#define LINF LLONG_MAX\n#define eprintf(...) fprintf(stderr,__VA_ARGS__)\n#define pque(type) priority_queue<type,vector<type>,greater<type> >\n#define memst(a,b) memset(a,b,sizeof(a))\n#define iter(v,ite) for(auto ite=(v).begin();ite!=(v).end();ite++)\n#define mimunum(v,x) distance((v).begin(),lower_bound((v).begin(),(v).end(),x))\n\n\nstruct makehtml{\n\tvector<string> ss;\n\t\n\tmakehtml(){}\n\t/*\n\tctx.beginPath()\n\tctx.moveTo(50.000000,100.000000);\n\tctx.lineTo(150.000000,100.000000);\n\tctx.stroke();\n\t\n\tctx.fillStyle = \"rgb(0,0,0)\";\n\t\n\tctx.beginPath();\n\tctx.arc(168,59,3,0,360);\n\tctx.fill();\n\n\t*/\n\t\n\tvoid out(const char* name,double mag){\n\t\tchar fname[100];\n\t\tsprintf(fname,\"%s.html\",name);\n\t\tFILE* fp = fopen(fname,\"w\");\n\t\tif(fp==NULL){\n\t\t\teprintf(\"can't open %s\\b\",fname);\n\t\t\texit(-1);\n\t\t}\n\t\tfprintf(fp,\"<html>\\n<head>\\n<title>\");\n\t\tfprintf(fp,\"%s\",name);\n\t\tfprintf(fp,\"</title>\\n</head>\\n<body>\\n\");\n\t\tfprintf(fp,\"<p>name: %s</p>\",name);\n\t\tfprintf(fp,\"<canvas id=\\\"vis\\\" width=\\\"%d\\\" height=\\\"%d\\\"></canvas>\",2000,2000);\n\t\tfprintf(fp,\"<script>\\n\");\n\t\tfprintf(fp,\"var vis = document.getElementById('vis');\\nvar ctx = vis.getContext('2d');\\n\");\n\t\t\n\t\trep(i,ss.size()){\n\t\t\tfprintf(fp,\"%s\\n\",ss[i].c_str());\n\t\t}\n\t\t\n\t\tfprintf(fp,\"</script>\\n\");\n\t\tfprintf(fp,\"</body>\\n</html>\\n\");\n\t\tfclose(fp);\n\t}\n\n} makehtml_instance;\n\nvoid addhtml(string s){\n\tmakehtml_instance.ss.push_back(s);\n}\n\nvoid outhtml(string s,double mag){\n\tmakehtml_instance.out(s.c_str(),mag);\n}\n\nvoid randcolhtml(){\n\tchar ns[100];\n\tsprintf(ns,\"ctx.fillStyle = \\\"rgb(%d,%d,%d)\\\";\",rand()%128,rand()%128,rand()%128);\n\taddhtml(ns);\n\tsprintf(ns,\"ctx.strokeStyle = \\\"rgb(%d,%d,%d)\\\";\",rand()%128,rand()%128,rand()%128);\n\taddhtml(ns);\n}\n\nvoid inithtml(){\n\tmakehtml_instance.ss.clear();\n}\n\n\nstruct pos{\n\tdouble x,y;\n\tdouble norm,norm2;\n\tpos tov(pos a){\n\t\treturn (a-(*this));\n\t}\n\tpos operator+(pos a)const{\n\t\tpos res=a;\n\t\tres.x+=x; res.y+=y;\n\t\tres=pos(res.x,res.y);\n\t\treturn res;\n\t}\n\tpos operator-(pos a)const{\n\t\tpos res=(*this);\n\t\tres.x-=a.x; res.y-=a.y;\n\t\tres=pos(res.x,res.y);\n\t\treturn res;\n\t}\n\tpos scalar(double a){\n\t\tpos res=(*this);\n\t\tres.x*=a; res.y*=a;\n\t\tres=pos(res.x,res.y);\n\t\treturn res;\n\t}\n\tdouble dot(pos a){\n\t\treturn x*a.x + y*a.y;\n\t}\n\tdouble cross(pos a){\n\t\treturn x*a.y - y*a.x;\n\t}\n\tdouble theta(pos a){\n\t\tdouble nt=dot(a)/(norm*a.norm);\n\t\tnt=acos(max(-1.0,min(1.0,nt)));\n\t\tdouble ns=(cross(a)/(norm*a.norm));\n\t\tif(ns<0)nt*=-1;\n\t\treturn nt;\n\t}\n\tpos(double ix,double iy){\n\t\tx=ix; y=iy;\n\t\tnorm2=x*x+y*y;\n\t\tnorm=sqrt(norm2);\n\t}\n\tpos(){}\n\tstring str(){\n\t\tchar ns[50];\n\t\tsprintf(ns,\"(%lf %lf)\",x,y);\n\t\treturn\tstring(ns);\n\t}\n\tvoid outh(double mag){\n\t\tchar ns[50];\n\t\taddhtml(\"ctx.beginPath();\"); \n\t\tsprintf(ns,\"ctx.arc(%lf,%lf,%lf,0,360);\",x*mag,y*mag,5.0); addhtml(ns);\n\t\taddhtml(\"ctx.fill();\");\n\t}\n\tstatic pos polar(double r,double t){\n\t\treturn pos(r*cos(t),r*sin(t));\n\t}\n\tbool  operator<(pos a) const{\n\t\t//if(x!=a.x)return (x<a.x);\n\t\t//return (y<a.y);\n\t\tif(y!=a.y)return (y<a.y);\n\t\treturn (x<a.x);\n\t}\t\n\tbool operator>(pos a)const{ return (a<(*this)); }\t\n};\nstruct line{\n\tpos p,q;\n\tpos vec;\n\tstring str(){\n\t\treturn (\"(\"+p.str()+\"-\"+q.str()+\")\");\n\t}\n\tvoid outh(double mag){\n\t\tchar ns[50];\n\t\taddhtml(\"ctx.beginPath();\");\n\t\tsprintf(ns,\"ctx.moveTo(%lf,%lf);\",p.x*mag,p.y*mag); addhtml(ns);\n\t\tsprintf(ns,\"ctx.lineTo(%lf,%lf);\",q.x*mag,q.y*mag); addhtml(ns);\n\t\taddhtml(\"ctx.stroke();\");\n\t}\n\tbool iscross(line a){\n\t\tdouble da,db;\n\t\tda=vec.cross( p.tov(a.p) );\n\t\tdb=vec.cross( p.tov(a.q) );\n\t\tif(da*db>=0)return false;\n\t\tda=a.vec.cross( a.p.tov(p) );\n\t\tdb=a.vec.cross( a.p.tov(q) );\n\t\treturn (da*db<0);\n\t}\n\tline(pos ip,pos iq){\n\t\tp=ip; q=iq;\n\t\tvec=p.tov(q);\n\t}\n\tline(){}\n\tdouble dist(pos a){\n\t\tif(p.tov(a).dot( p.tov(q) )<0)return p.tov(a).norm;\n\t\tif(q.tov(a).dot( q.tov(p) )<0)return q.tov(a).norm;\n\t\treturn abs(vec.cross(p.tov(a))/vec.norm);\n\t}\n\tdouble dist(line a){\n\t\tif(iscross(a))return 0;\n\t\treturn min( min(dist(a.p),dist(a.q)) , min(a.dist(this->p),a.dist(this->q)));\n\t}\n\tpos crosspos(line a){\n\t\t/*\n\t\tdouble d1=a.vec.cross(a.p.tov(p))/a.vec.norm;\n\t\tdouble d2=a.vec.cross(a.p.tov(q))/a.vec.norm;\n\t\tbool isc=(d1*d2<0);\n\t\td1=abs(d1); d2=abs(d2);\n\t\tdouble sc;\n\t\tif(!isc){\n\t\t\tif(d1>d2)sc = d1/(d1-d2);\n\t\t\telse sc=d1/(d2-d1);\n\t\t}\n\t\telse sc = d1/(d1+d2);\n\t\treturn (p+vec.scalar(sc));*/\n\t\t\n\t\tdouble t = a.vec.cross(a.p-p)/a.vec.cross(vec);\n\t\treturn (p+vec.scalar(t));\n\t}\n\tline bisection(){//?????´????????????\n\t\t//???????¨??????????90????????£???????????????\n\t\tpos fr=(p+q).scalar(0.5);\n\t\tpos to=fr+pos(-vec.y,vec.x);\n\t\treturn line(fr,to);\n\t}\n};\ndouble lowofcos_getcos(double a,double b,double c){\n\treturn ((a*a+b*b-c*c)/(2*a*b));\n}\nstruct circle{\n\tpos p;\n\tdouble r;\n\tline koten(circle a){\n\t\tpos cv=p.tov(a.p);\n\t\tdouble br=atan2(cv.y,cv.x);\n\t\tdouble dr=acos(lowofcos_getcos( r, cv.norm, a.r));\n\t\tpos p1= p+pos::polar(r,br+dr);\n\t\tpos p2= p+pos::polar(r,br-dr);\n\t\tif(p1>p2)swap(p1,p2);\n\t\treturn line(p1,p2);\n\t}\n\tcircle(pos ip,double ir){\n\t\tp=ip; r=ir;\n\t}\n\tcircle(){}\n\tvoid outh(double mag){\n\t\tchar ns[50];\n\t\taddhtml(\"ctx.beginPath();\"); \n\t\tsprintf(ns,\"ctx.arc(%lf,%lf,%lf,0,360);\",p.x*mag,p.y*mag,r*mag); addhtml(ns);\n\t\t//addhtml(\"ctx.fill();\");\n\t}\n};\nstruct polygon{\n\tvector<pos> ps;\n\tpolygon(){}\n\tvoid outh(double mag){\n\t\tchar ns[50];\n\t\taddhtml(\"ctx.beginPath();\");\n\t\tint ls=ps.size();\n\t\tsprintf(ns,\"ctx.moveTo(%lf,%lf);\",ps[ls-1].x*mag,ps[ls-1].y*mag); addhtml(ns);\n\t\trep(i,ps.size()){\n\t\t\tsprintf(ns,\"ctx.lineTo(%lf,%lf);\",ps[i].x*mag,ps[i].y*mag); addhtml(ns);\n\t\t}\n\t\taddhtml(\"ctx.stroke();\");\n\t}\n\tdouble area(){\n\t\tdouble res=0;\n\t\trep(i,ps.size()){\n\t\t\tpos no=ps[i],to=ps[(i+1)%ps.size()];\n\t\t\tres+=(no.x+to.x)*(no.y-to.y);\n\t\t}\n\t\tif(res<0)reverse(ps.begin(),ps.end());\n\t\treturn abs(res)/2;\n\t}\n\tpolygon(pos a,pos b){\n\t\tps.push_back(a);\n\t\tps.push_back(pos(a.x,b.y));\n\t\tps.push_back(b);\n\t\tps.push_back(pos(b.x,a.y));\n\t}\n\tline gete(int a){\n\t\ta%=ps.size();\n\t\treturn line(ps[a],ps[(a+1)%ps.size()]);\n\t}\n\tint isin(pos a){//?????´??????2,?????£????????????1,?????????0\n\t\tdouble as=0;\n\t\trep(i,ps.size()){\n\t\t\tline ne=gete(i);\n\t\t\tif(ne.dist(a)<=0)return 1;\n\t\t\tpos v1=a.tov(ne.p);\n\t\t\tpos v2=a.tov(ne.q);\n\t\t\tas+=v1.theta(v2);\n\t\t}\n\t\tif(abs(as)<1e-6)return 0;\n\t\treturn 2;\n\t}\n\tpolygon convex_full(){\n\t\tpolygon res;\n\t\tint ns=ps.size();\n\t\tvector<pos> vs(2*ns);\n\t\tsort(ps.begin(),ps.end());\n\t\tint k=0;\n\t\trep(i,ns){\n\t\t\tpos np=ps[i];\n\t\t\twhile(k>1 && vs[k-2].tov(vs[k-1]).cross(vs[k-1].tov(np))<-1e-6)k--;\n\t\t\tvs[k]=np; k++;\n\t\t}\n\t\tint t=k;\n\t\tireg(i,0,ns-2){\n\t\t\tpos np=ps[i];\n\t\t\twhile(k>t && vs[k-2].tov(vs[k-1]).cross(vs[k-1].tov(np))<-1e-6)k--;\n\t\t\tvs[k]=np; k++;\n\t\t}\n\t\tvs.resize(k-1);\n\t\tswap(vs,res.ps);\n\t\treturn res;\n\t}\n\tpolygon cut(line a){//???????????????????????????\n\t\tpolygon res;\n\t\trep(i,ps.size()){\n\t\t\tline ne=gete(i);\n\t\t\tdouble d1=a.vec.cross(a.p.tov(ne.p));\n\t\t\tdouble d2=a.vec.cross(a.p.tov(ne.q));\n\t\t\tif(d1<1e-6)res.ps.push_back(ne.p); //?????£????????£???eps\n\t\t\tif(d1*d2<-1e-6)res.ps.push_back(a.crosspos(ne)); //?????£????????????eps\n\t\t}\n\t\treturn res;\n\t}\n\tvector<polygon> voronoi(vector<pos> ps){\n\t\t/*\n\t\tinithtml();\n\t\trandcolhtml();\n\t\tthis->outh(3);\n\t\t\n\t\trep(i,ps.size()){\n\t\t\tps[i].outh(3);\n\t\t}\n\t\t*/\n\t\t\n\t\tvector<polygon> res;\n\t\trep(i,ps.size()){\n\t\t\tpolygon np(*this);\n\t\t\trep(j,ps.size()){\n\t\t\t\tif(i==j)continue;\n\t\t\t\tline nl = line(ps[j],ps[i]).bisection();\n\t\t\t\t\n\t\t\t\tnp = np.cut(nl);\n\t\t\t\t\n\t\t\t\t/*\n\t\t\t\tif(i==0 && j<=3){\n\t\t\t\t\trandcolhtml();\n\t\t\t\t\tnl.outh(3);\n\t\t\t\t\tif(j<=2){\n\t\t\t\t\t\trandcolhtml();\n\t\t\t\t\t\tnp.outh(3);\n\t\t\t\t\t}\n\t\t\t\t}*/\n\t\t\t\t/*\n\t\t\t\tif(j==1){\n\t\t\t\t\tnp.outh(30);\n\t\t\t\t\texit(-1);\n\t\t\t\t}\n\t\t\t\t*/\n\t\t\t}\n\t\t\tres.push_back(np);\n\t\t\t//np.outh(3);\n\t\t}\n\t\t\n\t\t//outhtml(\"o\",3);\n\t\treturn res;\t\t\n\t}\n\tpolygon mult(polygon a){\n\t\treturn a;\n\t}\n};\n\nint main(void){\n\tfor(;;){\n\t\tint n,m;\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tif(n==0)break;\n\t\tpolygon po;\n\t\trep(i,n){\n\t\t\tdouble x,y;\n\t\t\tscanf(\"%lf%lf\",&x,&y);\n\t\t\tpo.ps.push_back(pos(x,y));\n\t\t}\n\t\t\n\t\tvector<pos> tps;\n\t\trep(i,m){\n\t\t\tdouble x,y;\n\t\t\tscanf(\"%lf%lf\",&x,&y);\n\t\t\ttps.push_back(pos(x,y));\n\t\t}\n\t\t\n\t\tvector<polygon> pols = po.voronoi(tps);\n\t\trep(i,m){\n\t\t\tprintf(\"%lf\\n\",pols[i].area());\n\t\t}\n\t\t\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cassert>\n\n#include <vector>\n#include <algorithm>\n\n#define x first\n#define y second\n\nusing namespace std;\n\ntypedef pair<double, double> Point;\n\nclass Line {\n  public:\n    double a, b, c;\n\n    Line(const double _a = 0.0, const double _b = 0.0, const double _c = 0.0):\n      a(_a),\n      b(_b),\n      c(_c) {}\n\n    Line(const Point &p1, const Point &p2):\n      a(p1.y - p2.y),\n      b(p2.x - p1.x),\n      c(p1.x * p2.y - p1.y * p2.x) {}\n};\n\nvector<Line> Plane;\nvector<Point> Points;\nvector<double> Areas;\n\ninline double Det(const Point &a, const Point &b, const Point &c) {\n    return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\n}\n\nclass Compare {\n  public:\n    static Point origin;\n\n    bool operator()(const Point &a, const Point &b) const {\n        return Det(origin, a, b) >= 0;\n    }\n};\n\nPoint Compare::origin;\n\nvector<Point> ConvexHull(vector<Point> points) {\n    int n = int(points.size());\n    int origin = 0;\n    for (int i = 1; i < n; ++i)\n        if (points[i] < points[origin])\n            origin = i;\n    swap(points[0], points[origin]);\n    Compare::origin = points[0];\n    sort(points.begin() + 1, points.end(), Compare());\n    points.push_back(points[0]);\n    vector<Point> hull;\n    for (int i = 0; i < int(points.size()); ++i) {\n        while (int(hull.size()) > 1 && Det(hull[int(hull.size()) - 2], hull[int(hull.size()) - 1], points[i]) <= 0)\n            hull.pop_back();\n        hull.push_back(points[i]);\n    }\n    hull.pop_back();\n    return hull;\n}\n\ninline Point Dualize(const Line &l) {\n    if (l.c == 0)\n        return Point(0, 0);\n    else\n        return Point(l.a / l.c, l.b / l.c);\n}\n\ninline Line Dualize(const Point &p) {\n    return Line(p.x, p.y, 1);\n}\n\ninline Point Translate(const Point &p, const Point &shift) {\n    return Point(p.x + shift.x, p.y + shift.y);\n}\n\ninline Line Translate(const Line &l, const Point &shift) {\n    return Line(l.a, l.b, l.c - l.a * shift.x - l.b * shift.y);\n}\n\nvector< vector<Point> > GetVoronoiDiagrams(const vector<Line> &plane, const vector<Point> &points) {\n    int n = int(points.size());\n    vector< vector<Point> > voronoiDiagrams = vector< vector<Point> >(n, vector<Point>());\n    for (int i = 0; i < n; ++i) {\n        Point shift = Point(-points[i].x, -points[i].y);\n        vector<Point> dualizedLines;\n        for (int j = 0; j < int(plane.size()); ++j)\n            dualizedLines.push_back(Dualize(Translate(plane[j], shift)));\n        for (int j = 0; j < n; ++j) {\n            if (i != j) {\n                Point a = points[i], b = points[j];\n                dualizedLines.push_back(Dualize(Translate(Line(2 * (b.x - a.x), 2 * (b.y - a.y), a.x * a.x + a.y * a.y - b.x * b.x - b.y * b.y), shift)));\n            }\n        }\n        vector<Point> hull = ConvexHull(dualizedLines);\n        for (int j = 0; j < int(hull.size()); ++j)\n            voronoiDiagrams[i].push_back(Translate(Dualize(Line(hull[j], hull[(j + 1) % int(hull.size())])), points[i]));\n    }\n    return voronoiDiagrams;\n}\n\ninline double GetArea(const vector<Point> &polygon) {\n    int n = int(polygon.size());\n    double area = 0.0;\n    for (int i = 0; i < n; ++i)\n        area += polygon[i].x * polygon[(i + 1) % n].y - polygon[(i + 1) % n].x * polygon[i].y;\n    area /= 2.0;\n    if (area < 0.0)\n        area = -area;\n    return area;\n}\n\nvoid Solve() {\n    vector< vector<Point> > voronoi = GetVoronoiDiagrams(Plane, Points);\n    Areas = vector<double>(int(Points.size()), 0.0);\n    for (int i = 0; i < int(Points.size()); ++i)\n        Areas[i] = GetArea(voronoi[i]);\n}\n\nbool Read() {\n    int n, m;\n    if (scanf(\"%d %d\", &n, &m) != 2)\n        return false;\n    if (n == 0 && m == 0)\n        return false;\n    vector<Point> planePolygon = vector<Point>(n);\n    for (int i = 0; i < n; ++i)\n        if (scanf(\"%lf %lf\", &planePolygon[i].x, &planePolygon[i].y) != 2)\n            return false;\n    for (int i = 0; i < n; ++i)\n        Plane.push_back(Line(planePolygon[i], planePolygon[(i + 1) % n]));\n    Points = vector<Point>(m);\n    for (int i = 0; i < m; ++i)\n        if (scanf(\"%lf %lf\", &Points[i].x, &Points[i].y) != 2)\n            return false;\n    return true;\n}\n\nvoid Print() {\n    for (int i = 0; i < int(Points.size()); ++i)\n        printf(\"%.7lf\\n\", Areas[i]);\n}\n\nint main() {\n    while (Read()) {\n        Solve();\n        Print();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cassert>\n#include <cstring>\n#include <vector>\n#include <valarray>\n#include <array>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <random>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\ntypedef long double R;\ntypedef complex<R> P;\n\nconst R EPS = 1e-10;\nconst R PI = acos((R)(-1));\n\n/*\n -1 -> neg\n  0 -> near 0\n  1 -> pos\n  */\nint sgn(R a) {\n    if (a < -EPS) return -1;\n    if (a > EPS) return 1;\n    return 0;\n}\n\n/*\n -1 -> a > b\n 0 -> a near b\n 1 -> a < b\n */\nint sgn(R a, R b) {\n    return sgn(b-a);\n}\n\nbool near(P a, P b) {\n    return !sgn(abs(a-b));\n}\n\nbool lessP(const P &l, const P &r) {\n    if (sgn(l.real(), r.real())) return l.real() < r.real();\n    if (sgn(l.imag(), r.imag())) return l.imag() < r.imag();\n    return false;\n}\n\nR cross(P a, P b) { return a.real()*b.imag() - a.imag()*b.real(); }\nR dot(P a, P b) { return a.real()*b.real() + a.imag()*b.imag(); }\n\n/* 1->cclock\n  -1->clock\n   0->on\n   2->back\n  -2->front\n  */\nint ccw(P a, P b, P c) {\n    assert(!near(a, b));\n    if (near(a, c) || near(b, c)) return 0;\n    int s = sgn(cross(b-a, c-a));\n    if (s) return s;\n    if (dot(b-a, c-a) < 0) return 2;\n    if (dot(a-b, c-b) < 0) return -2;\n    return 0;\n}\n\nR ssqrt(R d) {\n    d = max<R>(0, d);\n    return sqrt(d);\n}\n\nR sacos(R d) {\n    d = max<R>(-1, d);\n    d = min<R>(1, d);\n    return acos(d);\n}\n\nstruct L {\n    P x, y;\n    L() {};\n    L(P x, P y) :x(x), y(y) {};\n};\n\nP vec(const L &l) {\n    return l.y - l.x;\n}\n\nR abs(const L &l) {\n    return abs(vec(l));\n}\n\nint crossLL(const L &l, const L &m, P &r) {\n    L mm = L(m.x - l.x, m.y - l.x);\n    mm.x *= polar<R>(1.0, -arg(vec(l)));\n    mm.y *= polar<R>(1.0, -arg(vec(l)));\n    if (sgn(vec(mm).imag()) == 0) {\n        r = l.x;\n        if (sgn(mm.x.imag()) == 0) return -1;\n        return 0;\n    }\n    r = mm.x - vec(mm) * (mm.x.imag() / vec(mm).imag());\n    r *= polar<R>(1.0, arg(vec(l)));\n    r += l.x;\n    return 1;\n}\n\ntypedef vector<P> Pol;\n\n\nP cu(const Pol &p, int i) { \n    int s = p.size();\n    return p[(i%s+s)%s];\n};\n\nR area(const Pol &p) {\n    R u = 0;\n    for (int i = 0; i < (int)p.size(); i++) {\n        u += cross(cu(p,i), cu(p,i+1));\n    }\n    return abs(u)/2;\n}\n\nPol convex_cut(const Pol &p, const L &l) {\n    Pol q;\n    for (int i = 0; i < (int)p.size(); i++) {\n        P a = cu(p, i), b = cu(p, i+1);\n        if (ccw(l.x, l.y, a) != -1) q.push_back(a);\n        if (ccw(l.x, l.y, a)*ccw(l.x, l.y, b) < 0) {\n            P p;\n            crossLL(l, L(a, b), p);\n            q.push_back(p);\n        }\n    }\n    return q;\n}\n\nbool solve() {\n    int n, m;\n    cin >> n >> m;\n    if (!n) return false;\n    Pol p;\n    for (int i = 0; i < n; i++) {\n        R x, y;\n        cin >> x >> y;\n        p.push_back(P(x, y));\n    }\n    P cm[11];\n    for (int i = 0; i < m; i++) {\n        R x, y;\n        cin >> x >> y;\n        cm[i] = P(x, y);\n    }\n\n\n    for (int i = 0; i < m; i++) {\n        Pol pp = p;\n        for (int j = 0; j < n; j++) {\n            if (i == j) continue;\n            P md = (cm[i]+cm[j])/(R)2.0;\n            P md2 = md + (cm[j]-cm[i])*P(0, 1);\n            pp = convex_cut(pp, L(md, md2));\n        }\n        printf(\"%.20Lf\\n\", area(pp));\n    }\n    return true;\n}\n\nint main() {\n    while (solve()) {}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define inf 1000000000\n#define eps (1e-11)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1,Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nPoint median_Point(Point a,Point b){\n  Vector v=a-b;\n  return b+(v/2);\n}\n\nstatic const int COUNTER_CLOCKWISE=1;\nstatic const int CLOCKWISE=-1;\nstatic const int ONLINE_BACK=2;\nstatic const int ONLINE_FRONT=-2;\nstatic const int ON_SEGMENT=0;\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps)return COUNTER_CLOCKWISE;\n  if(cross(a,b)<-eps)return CLOCKWISE;\n  if(dot(a,b)<-eps)return ONLINE_BACK;\n  if(a.norm()<b.norm())return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nPoint PointRotation(Point base,Point a,double r){\n  Point b=a-base;\n  a.x=b.x*cos((r/180)*M_PI)-b.y*sin((r/180)*M_PI);\n  a.y=b.x*sin((r/180)*M_PI)+b.y*cos((r/180)*M_PI);\n  a=a+base;\n  return a;\n}\n\nLine getPerpendicularBisector(Segment S){\n  Point p1=median_Point(S.p1,S.p2);\n  Point p2=PointRotation(p1,S.p1,90);\n  Point p3=PointRotation(p1,S.p1,270);\n  return Line(p2,p3);\n}\n\nPoint getCrossPointLL(Line a,Line b){\n  double A=cross(a.p2-a.p1,b.p2-b.p1);\n  double B=cross(a.p2-a.p1,a.p2-b.p1);\n  if(abs(A)<eps && abs(B)<eps)return b.p1;\n  return b.p1+(b.p2-b.p1)*(B/A);\n}\n \ndouble getPolygonArea(Polygon p){\n  double area=0.0;\n  int n=p.size();\n  for(int i=0;i<n;i++)area+=cross(p[i%n],p[(i+1)%n]);\n  return area/2;\n}\n\n//  Polygon???Line??§????????????????????????????????????\nPolygon convex_cut(Polygon p,Line l){\n  Polygon ans;\n  for(int i=0;i<p.size();i++){\n    Point A=p[i],B=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,A)!=-1)ans.push_back(A);\n    if(ccw(l.p1,l.p2,A)*ccw(l.p1,l.p2,B)<0)\n      ans.push_back(getCrossPointLL(l,Segment(A,B)));\n  }\n  return ans;\n}\n\nint main()\n{\n  int n,m;\n  Polygon P;\n  vector<Point> vp;\n\n  while(1){\n    cin>>n>>m;\n    if(n+m==0)break;\n    P.clear();vp.clear();\n    P.resize(n);vp.resize(m);\n    for(int i=0;i<n;i++)cin>>P[i].x>>P[i].y;\n    for(int i=0;i<m;i++)cin>>vp[i].x>>vp[i].y;\n    \n    for(int i=0;i<m;i++){\n      double ans=inf;\n      for(int j=0;j<m;j++){\n\tfor(int k=0;k<m;k++){\n\t  if(i==j || i==k || j==k)continue;\n\t  Polygon v=P;\n\t  Line L1=getPerpendicularBisector(Segment(vp[i],vp[j%m]));\n\t  v=convex_cut(v,L1);\n\t  Line L2=getPerpendicularBisector(Segment(vp[i],vp[k%m]));\n\t  v=convex_cut(v,L2);\n\t  ans=min(getPolygonArea(v),ans);\n\t}\n      }\n      printf(\"%.10f\\n\",ans);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<cmath>\n#include<vector>\n#include<cstdlib>\n#include<cassert>\n#include<map>\n#include<iomanip>\n#define _A_ true\n#define EPS 1e-10\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\nusing namespace std;\nclass Point{\npublic:\n  double x,y;\n  Point(double x =0,double y=0):x(x),y(y){}\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(x*a,y*a);}\n  Point operator / (double a){return Point(x/a,y/a);} //もし悪を使うなら要確認\n \n  double norm() {return x*x+y*y;}\n  double abs() {return sqrt(norm());}\n \n  bool operator < (const Point &p) const{\n    return x != p.x ? x < p.x : y < p.y; \n  }\n \n  bool operator == (const Point &p) const{\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\ntypedef Point Point;\nstruct Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p = Point(),Point pp = Point()):p1(p),p2(pp){}\n};\n \ntypedef vector<Point> Polygon;\ntypedef Segment Line;\n \ndouble norm(Point p){\n  return p.x*p.x+p.y*p.y;\n}\n \ndouble abs(Point p){\n  return sqrt(norm(p));\n}\n \nPoint polar(double a,double rad){\n  return Point(a*cos(rad),a*sin(rad));\n}\n \ndouble args(Point p){\n  return atan2(p.y,p.x);\n}\n \ndouble dot(Point a,Point b){\n  return a.x*b.x+a.y*b.y;\n}\n \ndouble cross(Point a,Point b){\n  return a.x*b.y-b.x*a.y;\n}\n \nPoint project(Segment s,Point p){\n  Point base = s.p2 - s.p1;\n  double t = dot(p-s.p1,base)/base.norm();\n  return s.p1+base*t;\n}\n \nPoint reflect (Segment s, Point p){\n  return p + (project(s,p)-p)*2.0;\n}\n \nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CLOCKWISE;\n  if(dot(a,b) < -EPS) return ONLINE_BACK;\n  if(a.norm() < b.norm() ) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n \nbool isIntersect(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <= 0 && ccw(p3,p4,p1) * ccw(p3,p4,p2) <= 0 );\n}\n \nbool isIntersect(Segment s1,Segment s2){\n  return isIntersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n/*\nPoint getCrossPoint(Segment s1,Segment s2){\n  assert(isIntersect(s1,s2));\n  P base = s2.p2 - s2.p1;\n  double d1 = abs(cross(base,s1.p1-s2.p1));\n  double d2 = abs(cross(base,s1.p2-s2.p1));\n  double t = d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n*/\n \nPoint getCrossPointLines( Line s1, Line s2){\n    Point a = s1.p2 - s1.p1;\n    Point base = Point(s2.p2.x - s2.p1.x,s2.p2.y - s2.p1.y);\n    return s1.p1 + a * cross(base, s2.p1 - s1.p1)/cross(base, a);\n}\n \nPolygon cutPolygon( Polygon P, Line l ){\n    Polygon u;\n    \n    for ( int i = 0; i < P.size(); i++ ){\n        Point a = P[i], b = P[(i+1)%P.size()];\n        if ( ccw(l.p1, l.p2, a) != CLOCKWISE ) u.push_back(a);\n        if ( ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) == -1 ){\n      u.push_back(getCrossPointLines(Segment(a, b), l));\n      \n        }\n    }   \n    return u;\n}\n \n \nLine CreateLine(Point p,Point pp){\n  Point mid = (p+pp)/2;\n \n  Point sl = pp-p;//原点に5\n  double rad = args(sl);\n  Point ap = polar(abs(sl),rad+M_PI/2)+mid;\n  //ap.x = abs(sl)*cos(rad+M_PI/2)+mid.x;\n  //ap.y = abs(sl)*sin(rad+M_PI/2)+mid.y;\n  return Line(mid,ap);\n}\n \n \ndouble AreaCalc(Polygon p){\n  double area = 0;\n  p.push_back(p[0]);\n  for(int i=0;i<p.size()-1;i++){\n    area+=cross(p[i],p[i+1]);\n  }\n  return fabs(area)/2;\n}\n \n \n \n \n \nint main(){\n  int N,M;\n  while(cin >> N >> M,N|M){\n  \n  vector<Point> l(N);\n  vector<Point> C(M);\n  for(int i=0;i<N;i++)\n    {\n      cin >> l[i].x >> l[i].y;\n      l[i].x += 200,l[i].y += 200;\n    }\n  for(int i=0;i<M;i++)\n    {\n      cin >> C[i].x >> C[i].y;\n      C[i].x += 200,C[i].y += 200;\n    }\n  for(int i=0;i<M;i++)\n    {\n      Polygon poly; \n      for(int j=0;j<N;j++)\n\tpoly.push_back(l[j]);\n      for(int j=0;j<M;j++)\n\t{\n\t  if(j == i)\n\t    continue;\n\t\n\t    poly = cutPolygon(poly,CreateLine(C[i],C[j]));\n\t}\n      cout << setiosflags(ios::fixed) << setprecision(1) << AreaCalc(poly) << endl;\n\n    }  \n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit atof atoi \n#include <cstdio>\t\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\t\t// require fabs\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\t\t// require srand\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define PI (3.141592653589793238462643383279)\ntemplate<class T>\nstruct point{\n\tT x, y;\n\tpoint &operator+=(const point &a ){ x += a.x; y += a.y; }\n\tpoint &operator-=(const point &a ){ x -= a.x; y -= a.y; }\n\tpoint operator+(const point &a )const{ return (point){x+a.x, y+a.y }; }\n\tpoint operator-(const point &a )const{ return (point){x-a.x, y-a.y }; }\n\toperator point<double>()const{ return (point<double>){x, y }; }\n};\n\ntemplate<class T>\npoint<T> operator*(T c, const point<T> &a ){ return (point<T>){c*a.x, c*a.y }; }\npoint<double> &operator/=(point<double> &a, double c ){ a.x /= c; a.y /= c; return a; }\ntemplate<class T>\npoint<double> operator/(const point<T> &a, double c ){ return (point<double>){ a.x/c, a.y/c }; }\n\n// for integar number\ntemplate<class T>\nbool operator<(const point<T> &a, const point<T> &b ){\n\treturn (a.x < b.x || ((a.x == b.x ) && (a.y < b.y ) ) );\n}\n\ntemplate<class T>\nbool operator==(const point<T> &a, const point<T> &b ){\n\treturn a.x == b.x && a.y == b.y;\n} \n\ntemplate<class T>\nbool operator!=(const point<T> &a, const point<T> &b ){\n\treturn a.x != b.x || a.y != b.y;\n}\n\n//  for real number\nbool operator<(const point<double> &a, const point<double> &b ){\n\treturn (a.x + EPS < b.x || (abs (a.x - b.x ) < EPS && (a.y + EPS < b.y ) ) );\n}\n\nbool operator==(const point<double> &a, const point<double> &b ){\n\treturn abs (a.x - b.x) < EPS && abs (a.y - b.y ) < EPS;\n}\n\nbool operator!=(const point<double> &a, const point<double> &b ){\n\treturn abs (a.x - b.x ) > EPS || abs (a.y - b.y ) > EPS;\n}\n\n// inner product\ntemplate<class T>\nT dot(const point<T> &a, const point<T> &b ){ return a.x*b.x + a.y*b.y; }\n\n// outer product\ntemplate<class T>\nT cross(const point<T> &a, const point<T> &b ){ return a.x*b.y - a.y*b.x; }\n\n// distance between origin(0,0) to point a\ntemplate<class T>\ndouble abs(const point<T> &a ){ return sqrt (a.x*a.x + a.y*a.y ); }\n\ntemplate<class T>\nT abs2(const point<T> &a ){ return a.x*a.x + a.y*a.y; }\n\npoint<double> rot(const point<double> &a, double theta ){\n\treturn (point<double>){a.x*cos(theta) - a.y*sin(theta), a.x*sin(theta) + a.y*cos(theta ) };\n}\n\n// x 軸の正方向を基準とした場合のベクトル a の角度を [0, 2*PI) の範囲で求める\ntemplate<class T> double arg(const point<T> &a ){\n\tdouble t = atan2(a.y, a.x );\n\treturn t<0.? t+2.*PI : t;\n}\n\ntemplate<class T>\nstruct line{\n\tpoint<T> a, b;\n\toperator line<double>()const{ return (line<double>){a, b}; }\n};\n\ntemplate<class T>\nstruct segment{\n\tpoint<T> a, b;\n\toperator line<T>()const { return (line<T>){a,b}; }\n};\n\ntemplate<class T>\nstruct polygon:vector< point<T> >{\n\tpolygon(){}\n\tpolygon(int n ):vector< point<T> >(n){}\n};\n\ntemplate<class T>\nstruct circle{\n\tpoint<T> c;\n\tT r;\n};\n\n// 点 p を直線 L 上に射影した点を求める\n// \tVerified: AOJ 0081 A Symmetric Point\ntemplate<class T>\npoint<double> proj(const point<T> &p, const line<T> &L ){\n\treturn L.a + dot (p-L.a, L.b-L.a )/abs2 (L.b - L.a )*(L.b - L.a );\n}\n\n/*\n\t三角形の面積（外積）\n\n\t説明\n\t\t三頂点で定まる三角形の面積（の２倍）を求める\n\t引数\n\t\ta : 頂点\n\t\tb : 頂点\n\t\tc : 頂点\n\t戻り値\n\t\t三角形の面積の２倍\n\t\t縮退しているときは 0\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n\t\t２倍を返しているのは、座標値が整数のときにはこの値も整数になるから。\n*/\ntemplate<class T>\nT area2(const point<T> &a, const point<T> &b, const point<T> &c ){\n\treturn abs(cross(b-a,c-a));\n}\n/*\n\t三角形の面積（Heron）\n\n\t説明\n\t\t三辺の長さで定まる三角形の面積を求める\n\t引数\n\t\ta : 一辺の長さ\n\t\tb : 一辺の長さ\n\t\tc : 一辺の長さ\n\t戻り値\n\t\t三角形の面積\n\t\t三角形が作れないとき、縮退しているときには 0\n\t制約\n\t\ta>=0, b>=0, c>=0\n\t\ta<b+c, b<c+a, c<a+b（三角形の成立条件）\n\t計算量\n\t\tO(1)\n\t備考\n\t\t三角形が縮退しているときは nan を返すかもしれない\n*/\ndouble area(double a, double b, double c ){\n\treturn sqrt((a+b-c)*(b+c-a)*(c+a-b)*(a+b-c))/4.;\n}\n\n/*\n\t多角形の面積\n\n\t説明\n\t\t多角形の面積（２倍）を求める\n\t引数\n\t\tG : 多角形\n\t戻り値\n\t\t三角形の面積の２倍\n\t\t縮退しているときは 0\n\t制約\n\t\tG は単純\n\t計算量\n\t\tO(n)\n\t備考\n\t\t２倍を返しているのは、座標値が整数のときにはこの値も整数になるから。\n\t\t多角形は CCW でも CW でもよい\n\n\t\tVerified: AOJ 0079 Area of Polygon\n*/\ntemplate<class T>\nT area2(const polygon<T> &G ){\n\tint n = G.size();\n\tT a = 0;\n\trep (i, n ) a+=cross(G[i], G[(i+1)%n] );\n\treturn abs (a );\n}\n\n/*\n\t二円の共通部分の面積を求める\n*/\n\n/*\n\t回転方向\n\n\t説明\n\t\t３点の位置関係を求める\n\t\t(A) 座標値が整数\n\t\t(B) 座標値が実数\n\t引数\n\t\ta : 点\n\t\tb : 点\n\t\tc : 点\n\t戻り値\n\t\ta-b-c の順に反時計回りに回転しているとき CCW\n\t\ta-b-c の順に時計回りに回転しているとき CW\n\t\ta-b-c が同一直線上にあるとき ON\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n\t\t2 点以上が同一の点であれば常に ON を返すことに注意\n\n*/\n\n// (A)\nenum{CCW = 1, CW = -1, ON = 0 };\ntemplate<class T>\nint ccw(const point<T> &a, const point<T> &b, const point<T> &c ){\n\tT rdir = cross (b-a, c-a );\n\tif (rdir > 0 ) return CCW;\n\tif (rdir < 0 ) return CW;\n\treturn ON;\n}\n\n// (B)\n\n//enum{CCW = 1, CW = -1, ON = 0 };\nint ccw (const point<double> &a, const point<double> &b, const point<double> &c ){\n\tdouble rdir = cross (b-a, c-a );\n\tif (rdir > 0 ) return CCW;\n\tif (rdir < 0 ) return CW;\n\treturn ON;\n}\n\n/*\n\t反時計回りに変換\n\n\t説明\n\t\t多角形の頂点の順番が CW であれば CCW に変換する\n\t\t元々 CCW であれば何もしない\n\t\t(A) 座標値が整数\n\t\t(B) 座標値が実数\n\t引数\n\t\tG : 多角形\n\t戻り値\n\t\tなし（引数 G が更新される）\n\t制約\n\t\tG は単純\n\t計算量\n\t\tO(n)\n\t備考\n\t\t単純多角形とは自己交差しない多角形のこと\n\t\tVerified: AOJ 0035 Is it Convex?\n*/\n// (A)\ntemplate<class T>\nvoid to_ccw(polygon<T> &G ){\n\tint n = G.size();\n\tT A = 0;\n\trep (i, n ) A+=cross(G[i], G[(i+1)%n] );\n\tif (A < 0 ) reverse (ALL (G ) );\n}\n\n// (B)\nvoid to_ccw(polygon<double> &G ){\n\tint n = G.size();\n\tdouble A = 0.;\n\trep (i, n ) A+=cross(G[i], G[(i+1)%n] );\n\tif (A<-EPS ) reverse (ALL (G ) );\n}\n\n/*\n\t点と点の距離\n\n\t説明\n\t\t点と点の距離を求める\n\t\tdist : 距離そのもの\n\t\tdist2 : 距離の二乗\n\t引数\n\t\ta : 点\n\t\tb : 点\n\t戻り値\n\t\t点 a と 点 b の距離\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n*/\ntemplate<class T>\ndouble dist(const point<T> &a, const point<T> &b ){\n\treturn sqrt ((a.x - b.x )*(a.x - b.x ) + (a.y - b.y )*(a.y - b.y ) );\n}\n\ntemplate<class T>\nT dist2(const point<T> &a, const point<T> &b ){\n\treturn (a.x - b.x )*(a.x - b.x ) + (a.y - b.y )*(a.y - b.y );\n}\n\n/*\n\t直線と点の距離\n点と\n\t説明\n\t\t直線と点の距離を求める\n\t\tdist : 距離そのもの\n\t\tdist2 : 距離の二乗\n\t引数\n\t\tL : 直線\n\t\tp : 点\n\t戻り値\n\t\t直線 L と点 p の距離\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n\n*/\ntemplate<class T>\ndouble dist(const line<T> &L, const point<T> &p ){\n\treturn abs (cross (L.b-L.a, p-L.a))/dist(L.a, L.b );\n}\n\n/*\n\t線分と点の距離\n\n\t説明\n\t\t線分と点の距離を求める\n\t\tdist : 距離そのもの\n\t\tdist2 : 距離の２乗\n\t引数\n\t\tS : 線分\n\t\tp : 点\n\t戻り値\n\t\t線分 S と点 p の距離\n\t計算量\n\t\tO(1)\n\t備考\n\t\tdist2 は <= 0 で正しい。(ESP を使わなくてよい. )\n\t\n*/\ntemplate<class T>\ndouble dist(const segment<T> &S, const point<T> &p ){\n\tif (dot (S.b-S.a, p-S.a ) <= 0 ) return dist (p, S.a );\n\tif (dot (S.a-S.b, p-S.b ) <= 0 ) return dist (p, S.b );\n\treturn abs (cross (S.b-S.a, p - S.a ) )/dist (S.a, S.b );\n}\n\ntemplate<class T>\ndouble dist2(const segment<T> &S, const point<T> &p ){\n\tif (dot (S.b-S.a, p-S.a ) <= 0 ) return dist2 (p, S.a );\n\tif (dot (S.a-S.b, p-S.b ) <= 0 ) return dist2 (p, S.b );\n\treturn (double)cross (S.b-S.a, p - S.a )*cross (S.b-S.a, p - S.a )/dist (S.a, S.b );\n}\n/*\n\t二直線の交点\n\n\t説明\n\t\t二直線の交点を求める\n\t\t(A)（直線を特徴付ける点の）座標値が整数\n\t\t(B)（直線を特徴付ける点の）座標値が実数\n\t引数\n\t\tL1 : 直線\n\t\tL2 : 直線\n\t戻り値\n\t\tL1 と L2 の交点\n\t制約\n\t\t二直線は交点を持つこと。（平行でない or L1 == L2 )\n\t計算量\n\t\tO(1)\n\t備考\n\t\t交点が複数あるとき（L1 == L2）は L1.a を返す。\n\t\tこの仕様は線分 S と直線 L の交点を求めたいとき重要。\n\t\t（ S と L が同一直線上にあるときにも、S を第１引数に指定することで交点が正しく求まる。）\n*/\n// (A)\ntemplate<class T>\npoint<double> get_intersect(const line<T> &L1, const line<T> &L2 ){\n\tdouble a1=cross(L1.b-L1.a,L2.b-L2.a);\n\tdouble a2=cross(L1.b-L1.a,L1.b-L2.a);\n\tif (a1==0) return L1.a;\t// L1 == L2\n\treturn (point<double>)L2.a+a2/a1*(point<double>)(L2.b-L2.a);\n}\n// (B)\npoint<double> get_intersect(const line<double> &L1, const line<double> &L2 ){\n\tdouble a1=cross(L1.b-L1.a,L2.b-L2.a);\n\tdouble a2=cross(L1.b-L1.a,L1.b-L2.a);\n\tif (abs(a1)<EPS) return L1.a;\t// L1 == L2\n\treturn L2.a+a2/a1*(L2.b-L2.a);\n}\n\n/*\n\t線分と線分の交差判定\n\n\t説明\n\t\t線分と線分が交わるかどうかを判定する\n\t\t(A) 座標値が整数\n\t\t(B) 座標値が実数\n\t引数\n\t\tS1 : 線分\n\t\tS2 : 線分\n\t戻り値\n\t\t交わるなら true, 交わらないなら false\n\t制約\n\t\tなし\n\t計算量\n\t\tO(1)\n\t備考\n\t\tbounding box によるラフチェックは必要。（ ccw による判定だと、二線分が同一直線上にあるとき間違う。)\n\n\t\tVerified: AOJ 2003 Railroad Conflict\n*/\n// (A)\ntemplate<class T>\nbool intersect(const segment<T> &S1, const segment<T> &S2 ){\n\tif (max (S1.a.x, S1.b.x ) < min (S2.a.x, S2.b.x )\n\t|| max (S1.a.y, S1.b.y ) < min (S2.a.y, S2.b.y )\n\t|| max (S2.a.x, S2.b.x ) < min (S1.a.x, S1.b.x )\n\t|| max (S2.a.y, S2.b.y ) < min (S1.a.y, S1.b.y ) ) return false;\n\treturn ccw (S1.a, S1.b, S2.a )*ccw (S1.a, S1.b, S2.b ) <= 0\n\t\t&& ccw (S2.a, S2.b, S1.a )*ccw (S2.a, S2.b, S1.b ) <= 0;\n}\n\n/*\n\t垂直二等分線\n\n\t説明\n\t\t二点 a, b の垂直二等分線を求める\n\t引数\n\t\ta : 点\n\t\tb : 点\n\t戻り値\n\t\ta と b の垂直二等分線\n\t計算量\n\t\tO(1)\n\t備考\n\t\t垂直二等分線を L とすると、L.a から L.b の方向を見たとき、左手に点 a が来る。\n\t\tAOJ 0081 A_Symmetric_Point では上手く動かなかった。\n\n*/\ntemplate<class T>\nline<double> perp_bisector(const point<T> &a, const point<T> &b ){\n\treturn (line<double>){(point<double>){(a.x-a.y+b.x+b.y)/2.0, (a.y+a.x+b.y-b.x)/2.0 },\n\t\t\t\t\t\t\t(point<double>){(a.x+a.y+b.x-b.y)/2.0, (a.y-a.x+b.y+b.x)/2.0 }};\n}\n\n/*\n\t凸多角形の切断\n\n\t凸多角形と半平面の交差\n\n\t説明\n\t\t凸多角形と半平面の共通部分を求める\n\t引数\n\t\tG : 凸多角形\n\t\tL : 直線\n\t戻り値\n\t\tG と L の左側の半平面の共通部分\n\t制約\n\t\tなし\n\t計算量\n\t\tO(n)\n\t備考\n\t\t半平面は L.a から L.b へ向いたときの左側の部分として指定されている。\n\t\t共通部分は凸多角形になる。（凸集合の全体は intersection について閉じている。）\n\t\tL 上に G の点 p があっても、出力される多角形には p が一度だけ表れる。\n\n*/\ntemplate<class T>\npolygon<double> convex_cut(const polygon<T> &G, const line<T> &L ){\n\tint n=G.size();\n\tpolygon<double> H; H.clear();\n\trep (i, n ){\n\t\tint d1=ccw(L.a,L.b,G[i] );\n\t\tint d2=ccw(L.a,L.b,G[(i+1)%n] );\n\t\tif (d1!=CW )H.push_back(G[i] );\n\t\tif (d1==CCW && d2==CW || d1==CW && d2==CCW ){\n\t\t\tH.push_back (get_intersect(L,(line<T>){G[i],G[(i+1)%n]}));\n\t\t} // end if\n\t} // end rep\n\n\treturn H;\n}\n\n/*\n\tボロノイ図\n\n\t説明\n\t\tk番目の点のボロノイ領域を求める\n\t引数\n\t\tg : 多角形（外枠）\n\t\tv : 点の集合\n\t\tk : 点の集合の中の k 番目の点\t\n\t戻り値\n\t\tres : 多角形\n\t制約\n\t\t多角形 g は反時計回りに配置されている事が前提。\n\t\t外枠が凸多角形でないときも動く？\n\t\tg は破壊される。\n\t\t(多角形の切断で g は書き換えられるため。)\n\t計算量\n\t\tO(n*(n+m))\n\t備考\n\t\n*/\ntemplate<class T>\npolygon<T> voronoi_cell(polygon<T> g, const polygon<T> &v, int k ){\n\tint n = v.size();\n\trep (i, n ) if (i != k ) g = convex_cut (g, perp_bisector (v[k], v[i] ) );\n\n\treturn g;\n}\nint main()\n{\n//\tcut here before submit \n//\tfreopen (\"testcase.2160\", \"r\", stdin );\n\tint n, m;\n\twhile (scanf (\"%d %d\", &n, &m ), n, m ){\n\t\tpolygon<double> g(n );\n\t\trep (i, n ) scanf (\"%lf %lf\", &g[i].x, &g[i].y );\n\t\tpolygon<double> v(m );\n\t\trep (j, m ) scanf (\"%lf %lf\", &v[j].x, &v[j].y );\n\t\trep (j, m ){\n\t\t\tpolygon<double> tg = g;\n\t\t\tpolygon<double> ans = voronoi_cell (tg, v, j );\n\t\t\tdouble res = area2 (ans );\n\t\t\tprintf (\"%.5lf\\n\", res/2. );\n\t\t} // end rep\n\t} // end loop\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <cstdio>\n#include <utility>\n#include <vector>\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<P,P> L;\ntypedef pair<P,double> C;\ntypedef vector<P> Poly;\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define INF (1e15)\n\n//2D version\nnamespace std{\n  bool operator < (const P& a, const P& b){\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n  bool cmp_y(const P &a, const P &b){\n    return a.Y != b.Y ? a.Y < b.Y : a.X < b.X;\n  }\n  bool operator == (const P& a, const P& b){\n    return abs(a-b) < EPS;\n  }\n}\n\ndouble dot(P a, P b){\n  return a.X * b.X + a.Y * b.Y;\n}\ndouble cross(P a, P b){\n  return a.X * b.Y - a.Y * b.X;\n}\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if( cross(b,c) > EPS ) return +1;\n  if( cross(b,c) < -EPS ) return -1;\n  if( dot(b,c) < 0 ) return +2;\n  if( abs(b) + EPS < abs(c) ) return -2;\n  return 0;\n}\n\nP intersection(L a, L b){\n  //直線aと直線bの交点\n  return a.first + cross(b.second-b.first,a.first-b.first)/(-cross(b.second-b.first,a.second-b.first)+cross(b.second-b.first,a.first-b.first))*(a.second-a.first);\n}\n\nPoly convex_cut(Poly p, L l){\n  Poly ret;\n  int n = p.size();\n  for(int i = 0; i < n; ++i){\n    if(ccw(l.first, l.second, p[i]) != -1) ret.push_back(p[i]);\n    if(ccw(l.first, l.second, p[i]) != -1 ^ ccw(l.first, l.second, p[(i+1)%n]) != -1) ret.push_back(intersection(L(p[i], p[(i+1)%n]), l));\n  }\n  return ret;\n}\n\ndouble area(Poly p){\n  double ret = 0;\n  int n = p.size();\n  for(int i = 0; i < n; ++i){\n    ret += cross(p[i], p[(i+1)%n])/2;\n  }\n  return ret;\n}\n\nint main(){\n  int N, M;\n  while(cin >> N >> M, N||M){\n    Poly I;\n    for(int i = 0; i < N; ++i){\n      double x, y;\n      cin >> x >> y;\n      I.push_back(P(x,y));\n    }\n    Poly p;\n    for(int j = 0; j < M; ++j){\n      double x, y;\n      cin >> x >> y;\n      p.push_back(P(x,y));\n    }\n    for(int i = 0; i < M; ++i){\n      Poly q = I;\n      for(int j = 0; j < M; ++j){\n        if(i == j) continue;\n        L bisector = L((p[i]+p[j])/2.0, (p[i]+p[j])/2.0 + (p[j]-p[i])*P(0,1));\n        q = convex_cut(q, bisector);\n      }\n      cout << area(q) << endl;\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <complex>\n#include <vector>\n#include <cstdio>\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef pair<P,P> L;\nconst double EPS = 1e-7;\nconst int MAX = 30000;\nint n,m;\n\nP dat[100];\ndouble ans[100];\n\ndouble equal(double a, double b){ return fabs(a-b) < EPS;}\n\ndouble dot(P a, P b){ return real(conj(a)*b);}\n\ndouble cross(P a, P b){ return imag(conj(a)*b);}\n\ndouble calcArea(vector<P> v){\n  double sum = 0.0;\n  int n = v.size();\n  for(int i=0;i<n;i++) sum += (v[i].real() - v[(i+1)%n].real()) * (v[i].imag() + v[(i+1)%n].imag());\n  return fabs(sum) / 2;\n};\n\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > EPS) return 1;\n  if(cross(b,c) < -EPS) return -1;\n  if(dot(b,c) < -EPS) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nP crossPoint(L l, L m){\n  double A = cross(l.second - l.first, m.second - m.first);\n  double B = cross(l.second - l.first, l.second - m.first);\n  if(fabs(A) < EPS && fabs(B) < EPS) return m.first;\n  else if(fabs(A) >= EPS) return m.first + B / A * (m.second - m.first);\n}\n\nvector<P> convex_cut(vector<P> G, L l){\n  vector<P> ans;\n  for(int i=0;i<G.size();i++){\n    P A = G[i];\n    P B = G[(i+1)%G.size()];\n    if(ccw(l.first, l.second, A) != -1) ans.push_back(A);\n    if(ccw(l.first, l.second, A) * ccw(l.first, l.second, B) < 0){\n      L l2(A,B);\n      ans.push_back(crossPoint(l2, l));\n    }\n  }\n  return ans;\n}\n\nP rotate(P p, double theta){\n  theta *= M_PI / 180.0;\n  double x = p.real() * cos(theta) - p.imag() * sin(theta);\n  double y = p.real() * sin(theta) + p.imag() * cos(theta);\n  return P(x,y);\n}\n\nL bisector(L l){\n  P p = (l.first + l.second) / 2.0;\n  return L(p, p + rotate(l.second-l.first,90));\n}\n\nvoid solve(vector<P> v){\n  for(int i=0;i<m;i++){\n    vector<P> area = v;\n    for(int j=0;j<m;j++){\n      if(i == j) continue;\n      area = convex_cut(area, bisector(L(dat[i], dat[j])));\n    }\n    printf(\"%f\\n\",calcArea(area));\n  }\n}\n\nint main(){\n  while(cin >> n >> m && (n|m)){\n    vector<P> v;\n    for(int i=0;i<n;i++){\n      int x,y;\n      cin >> x >> y;\n      v.push_back(P(x,y));\n    }\n    for(int i=0;i<m;i++){\n      int x,y;\n      cin >> x >> y;\n      dat[i] = P(x,y);\n    }\n\n    solve(v);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "/*include*/\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<complex>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define rp(a) while(a--)\n#define pb push_back\n#define mp make_pair\n#define it ::iterator\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nconst double inf=1e8;\nusing namespace std;\n#define shosu(x) fixed<<setprecision(x)\ntypedef complex<double> P;\ntypedef vector<P> G;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\nstruct C{\n\tP c;double r;\n\tC(const P &c,double r):c(c),r(r){}\n};\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define diff(P, i) (next(P, i) - curr(P, i))\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t\t//return imag(a) != imag(b) ? imag(a) < imag(b) : real(a) < real(b);  \n\t}\n\tbool operator == (const P& a, const P& b) {\n\t\treturn a.real()==b.real()&&a.imag()==b.imag();\n\t}\n}\nP pin(){\n\tdouble x,y;\n\tchar d;\n\tcin>>x>>y;\n\tP p(x,y);\n\treturn p;\n}\nvoid PIN(P* a,int n){\n\trep(i,n)a[i]=pin();\n}\ndouble dot(P a,P b){\n\treturn real(conj(a)*b);\n}\ndouble cross(P a,P b){\n\treturn imag(conj(a)*b);\n}\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\nP projection(L a,P p){\n\tdouble t=dot(p-a[0],a[0]-a[1])/norm(a[0]-a[1]);\n\treturn a[0]+t*(a[0]-a[1]);\n}\nP reflection(L a,P p){\n\treturn p+2.0*(projection(a,p)-p);\n}\nbool intersectLL(const L &l, const L &m) {\n  return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || // non-parallel\n         abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n  return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n  return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 &&\n         ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n  return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS; // triangle inequality\n}\ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n  const P r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n/*bool intersectCS(C c,const L &l){\n    return (distanceLP(l,c.c) < c.r+EPS &&\n            (c.r < abs(c.c-l[0]) + EPS || c.r < abs(c.c-l[1]) + EPS));\n}*/\nint intersectCS(C c,L &l){\n\tif(norm(projection(l,c.c)-c.c)-c.r*c.r>EPS)return 0;\n\tconst double d1=abs(c.c-l[0]),d2=abs(c.c-l[1]);\n\tif(d1<c.r+EPS&&d2<c.r+EPS)return 0;\n\tif(d1<c.r-EPS&&d2>c.r+EPS||d1>c.r+EPS&&d2<c.r-EPS)return 1;\n\tconst P h=projection(l,c.c);\n\tif(dot(l[0]-h,l[1]-h)<0)return 2;\n\treturn 0;\n}\nP crosspointSS(L a,L b){\n\tdouble t1=abs(cross(a[1]-a[0],b[0]-a[0]));\n\tdouble t2=abs(cross(a[1]-a[0],b[1]-a[0]));\n\treturn b[0]+(b[1]-b[0])*t1/(t1+t2);\n}\nL crosspointCL(C c,L l){\n\tP pr=projection(l,c.c);\n\tP e=(l[1]-l[0])/abs(l[1]-l[0]);\n\tdouble t=sqrt(c.r*c.r-norm(pr-c.c));\n\tP a=pr+t*e;\n\tP b=pr-t*e;\n\tif(b<a)swap(a,b);\n\treturn L(a,b);\n}\nL crosspointCS(C c,L l){\n\tif(intersectCS(c,l)==2)return crosspointCL(c,l);\n\tL ret=crosspointCL(c,l);\n\tif(dot(l[0]-ret[0],l[1]-ret[0])<0)ret[1]=ret[0];\n\telse ret[0]=ret[1];\n\treturn ret;\n}\nL crosspointCC(C a,C b){\n\tP tmp=b.c-a.c;\n\tdouble d=abs(tmp);\n\tdouble q=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n\tdouble t=arg(tmp);//atan(tmp.imag()/tmp.real());\n\tP p1=a.c+polar(a.r,t+q);\n\tP p2=a.c+polar(a.r,t-q);\n\tif(p2<p1)swap(p1,p2);\n\treturn L(p1,p2);\n}\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  return m[0] + B / A * (m[1] - m[0]);\n}\ndouble area(const G &g){\n    double S =0;\n    for(int i =0;i <g.size();i++){\n        S +=(cross(g[i],g[(i+1)%g.size()]));\n    }\n    return abs(S/2.0);\n}\nbool isconvex(const G &g){\n\tint n=g.size();\n\trep(i,n)if(ccw(g[(i+n-1)%n],g[i%n],g[(i+1)%n])==-1)return false;\n\treturn true;\n}\nint inconvex(const G& g, const P& p) {\n\tbool in = false;\n\tint n=g.size();\n\trep(i,n){\n\t\tP a=g[i%n]-p;\n\t\tP b=g[(i+1)%n]-p;\n\t\tif(imag(a)>imag(b))swap(a, b);\n\t\tif(imag(a)<=0&&0<imag(b))if(cross(a,b)<0)in=!in;\n\t\tif(cross(a,b)==0&&dot(a,b)<=0)return 1;//ON\n\t}\n\treturn in?2:0;//IN : OUT;\n}\nG convex_hull(G &ps) {\n    int n=ps.size(),k=0;\n\tsort(ps.begin(), ps.end());\n\tG ch(2*n);\n\tfor(int i=0;i<n;ch[k++]=ps[i++])//lower-hull\n\t\twhile(k>=2&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//<=0  ->  ==-1\n\tfor(int i=n-2,t=k+1;i>=0;ch[k++]=ps[i--])//upper-hull\n\t\twhile(k>=t&&ccw(ch[k-2],ch[k-1],ps[i])==-1)--k;//\n\tch.resize(k-1);\n\treturn ch;\n}\ndouble convex_diameter(const G &pt) {\n  const int n = pt.size();\n  int is = 0, js = 0;\n  for (int i = 1; i < n; ++i) {\n    if (imag(pt[i]) > imag(pt[is])) is = i;\n    if (imag(pt[i]) < imag(pt[js])) js = i;\n  }\n  double maxd = norm(pt[is]-pt[js]);\n\n  int i, maxi, j, maxj;\n  i = maxi = is;\n  j = maxj = js;\n  do {\n    if (cross(diff(pt,i), diff(pt,j)) >= 0) j = (j+1) % n;\n    else i = (i+1) % n;\n    if (norm(pt[i]-pt[j]) > maxd) {\n      maxd = norm(pt[i]-pt[j]);\n      maxi = i; maxj = j;\n    }\n  } while (i != is || j != js);\n  return sqrt(maxd); /* farthest pair is (maxi, maxj). */\n}//convex_diameter(g)\nG convex_cut(const G& g, const L& l) {\n  G Q;\n  for (int i = 0; i < g.size(); ++i) {\n    P a= curr(g, i), b= next(g, i);\n    if (ccw(l[0], l[1], a) != -1) Q.push_back(a);\n    if (ccw(l[0], l[1], a)*ccw(l[0], l[1], b) < 0)\n      Q.push_back(crosspointLL(L(a,b), l));\n  }\n  return Q;\n}\nP turn(P p,double t){\n\treturn p*exp(P(.0,t*PI/180.0));\n}\nP turn2(P p,double t){\n\treturn p*exp(P(.0,t));\n}\nvector<L> tangentCC(C a,C b){\n\tif(a.r<b.r)swap(a,b);\n\tdouble d=abs(a.c-b.c);\n\tvector<L>l;\n\tif(d<EPS)return l;\n\tif(a.r+b.r<d-EPS){//hanareteiru\n\t\tdouble t=acos((a.r+b.r)/d);\n\t\tt=t*180/PI;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t),b.c+turn(b.r/d*(a.c-b.c),t)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t),b.c+turn(b.r/d*(a.c-b.c),-t)));\n\t}else if(a.r+b.r<d+EPS){//kuttuiteiru soto\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\tif(abs(a.r-b.r)<d-EPS){//majiwatteiru\n\t\tdouble t1=acos((a.r-b.r)/d);\n\t\tt1=t1*180/PI;\n\t\tdouble t2=180-t1;\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),t1),b.c+turn(b.r/d*(a.c-b.c),-t2)));\n\t\tl.pb(L(a.c+turn(a.r/d*(b.c-a.c),-t1),b.c+turn(b.r/d*(a.c-b.c),t2)));\n\t}else if(abs(a.r-b.r)<d+EPS){//kuttuiteiru uti\n\t\tP p=a.c+a.r/d*(b.c-a.c);\n\t\tl.pb(L(p,p+turn(b.c-a.c,90)));\n\t}\n\treturn l;\n}\nvoid printL(const L &out){\n\tprintf(\"%.9f %.9f %.9f %.9f\\n\",out[0].real(),out[0].imag(),out[1].real(),out[1].imag());\n}\nC CIN(){\n\tP p=pin();\n\tdouble r;\n\tcin>>r;\n\treturn C(p,r);\n}\nbool para(L a,L b){\n\treturn (abs(cross(a[1]-a[0],b[1]-b[0]))<EPS);\n}\ndouble min(double a,double b){return a<b?a:b;}\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m,n+m){\n\t\tG g(n);\n\t\trep(i,n)g[i]=pin();\n\t\tG a(m);\n\t\trep(i,m)a[i]=pin();\n\t\trep(i,m){\n\t\t\tG t=g;\n\t\t\trep(j,m)if(i!=j){\n\t\t\t\tL l(a[i]+a[j],0);\n\t\t\t\tl[0]/=2;\n\t\t\t\tl[1]=P(0,1)*(a[i]-a[j])+l[0];\n\t\t\t\tif(ccw(a[i],l[0],l[1])){\n\t\t\t\t\tswap(l[0],l[1]);\n\t\t\t\t}\n\t\t\t\tt=convex_cut(t,l);\n\t\t\t}\n\t\t\tcout<<shosu(9)<<area(t)<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return true; } return false; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return true; } return false; }\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define mp make_pair\n#define si(x) int(x.size())\nconst int mod=1000000007,MAX=2005,INF=1<<30;\n\nconst double eps=1e-10;\nconst double pi=acos((long double)-1.0L);\n#define equals(a,b) (fabs((a)-(b))<eps)\n\ndouble torad(int deg) {return (double)(deg)*pi/180.0;}\ndouble todeg(double ang) {return ang*180.0/pi;}\n\nclass Point{\npublic:\n    double x,y;\n    \n    Point(double x=0,double y=0):x(x),y(y){}\n    \n    Point operator + (Point p){return Point(x+p.x,y+p.y);}\n    Point operator - (Point p){return Point(x-p.x,y-p.y);}\n    Point operator * (double a){return Point(a*x,a*y);}\n    Point operator / (double a){return Point(x/a,y/a);}\n    \n    double abs(){return sqrt(norm());}\n    double norm(){return x*x+y*y;}\n    \n    bool operator < (const Point &p)const{\n        return x+eps<p.x||(equals(x,p.x)&&y+eps<p.y);\n    }\n    \n    bool operator == (const Point &p)const{\n        return fabs(x-p.x)<eps&&fabs(y-p.y)<eps;\n    }\n};\n\ntypedef Point Vector;\n\ndouble norm(Vector a){\n    return a.x*a.x+a.y*a.y;\n}\n\ndouble abs(Vector a){\n    return sqrt(norm(a));\n}\n\ndouble dot(Vector a,Vector b){\n    return a.x*b.x+a.y*b.y;\n}\n\ndouble cross(Vector a,Vector b){\n    return a.x*b.y-a.y*b.x;\n}\n\nstruct Segment{\n    Point p1,p2;\n};\n\nbool isOrthogonal(Vector a,Vector b){\n    return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n    return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n    return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n    return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n    return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n    return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nPoint project(Segment s,Point p){\n    Vector base=s.p2-s.p1;\n    double r=dot(p-s.p1,base)/norm(base);\n    return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n    return p+(project(s,p)-p)*2.0;\n}\n\nstatic const int counter_clockwise=1;\nstatic const int clockwise=-1;\nstatic const int online_back=2;\nstatic const int online_front=-2;\nstatic const int on_segment=0;\n\nint ccw(Point p0,Point p1,Point p2){\n    Vector a=p1-p0;\n    Vector b=p2-p0;\n    \n    if(cross(a,b)>eps) return counter_clockwise;\n    if(cross(a,b)<-eps) return clockwise;\n    if(dot(a,b)<-eps) return online_back;\n    if(a.norm()<b.norm()) return online_front;\n    \n    return on_segment;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n    return(ccw(p1,p2,p3)*ccw(p1,p2,p4)<=0&&ccw(p3,p4,p1)*ccw(p3,p4,p2)<=0);\n}\n\nbool intersect(Segment s1,Segment s2){\n    return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\ntypedef Segment Line;\n\ndouble getDistance(Point a,Point b){\n    return abs(a-b);\n}\n\ndouble getDistanceLP(Line l,Point p){\n    return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n    if(dot(s.p2-s.p1,p-s.p1)<0.0) return abs(p-s.p1);\n    if(dot(s.p1-s.p2,p-s.p2)<0.0) return abs(p-s.p2);\n    return getDistanceLP(s,p);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n    if(intersect(s1,s2)) return 0.0;\n    return min({getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2),getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)});\n}\n\nPoint getCrossPoint(Segment s1,Segment s2){\n    if(ccw(s1.p1,s1.p2,s2.p1)==0&&ccw(s1.p1,s1.p2,s2.p2)==0) return s1.p1;\n    Vector base=s2.p2-s2.p1;\n    double d1=abs(cross(base,s1.p1-s2.p1));\n    double d2=abs(cross(base,s1.p2-s2.p1));\n    double t=d1/(d1+d2);\n    return s1.p1+(s1.p2-s1.p1)*t;\n}//同じ時壊れます\n\n\nclass Circle{\npublic:\n    Point c;\n    double r;\n    Circle(Point c=Point(),double r=0.0):c(c),r(r){}\n};\n\nPoint CircleCenter(Point a,Point b,Point c){\n    Point u=a-b,v=a-c;\n    double m1=(norm(a)-norm(b))/2.0,m2=(norm(a)-norm(c))/2.0;\n    \n    Point res;\n    if(cross(u,v)==0.0){\n        res.x=1e9;\n        res.y=1e9;\n        \n        return res;\n    }\n    res.x=(m1*v.y-m2*u.y)/cross(u,v);\n    res.y=(m1*v.x-m2*u.x)/cross(v,u);\n    \n    return res;\n}\n\npair<Point,Point> segCrossPpoints(Circle c,Line l){\n    //assert(intersect(c,l));\n    Vector pr=project(l,c.c);\n    Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n    double base=sqrt(c.r*c.r-norm(pr-c.c));\n    return make_pair(pr+e*base,pr-e*base);\n}\n\ndouble arg(Vector p){return atan2(p.y,p.x);}\nVector polar(double a,double r){return Point(cos(r)*a,sin(r)*a);}\n\npair<Point,Point> getCrossPoints(Circle c1,Circle c2){\n    //assert(intersect(c1,c2));\n    double d=abs(c1.c-c2.c);\n    double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n    double t=arg(c2.c-c1.c);\n    return make_pair(c1.c+polar(c1.r,t+a),c1.c+polar(c1.r,t-a));\n}\n\ntypedef vector<Point> Polygon;\n\n/*\n IN 2\n ON 1\n OUT 0\n */\n\nint contains(Polygon g,Point p){\n    int n=int(g.size());\n    bool x=false;\n    for(int i=0;i<n;i++){\n        Point a=g[i]-p,b=g[(i+1)%n]-p;\n        if(a.y>b.y) swap(a,b);\n        if(a.y<eps&&eps<b.y&&cross(a,b)>eps) x=!x;\n    }\n    return (x?2:0);\n}\n\nPolygon andrewScan(Polygon s,bool ok){\n    Polygon u,l;\n    sort(all(s));\n    \n    if(int(s.size())<3) return s;\n    int n=int(s.size());\n    \n    u.push_back(s[0]);\n    u.push_back(s[1]);\n    \n    l.push_back(s[n-1]);\n    l.push_back(s[n-2]);\n    \n    if(ok){\n        for(int i=2;i<n;i++){\n            for(int j=int(u.size());j>=2&&ccw(u[j-2],u[j-1],s[i])==counter_clockwise;j--){\n                u.pop_back();\n            }\n            u.push_back(s[i]);\n        }\n        \n        for(int i=int(s.size())-3;i>=0;i--){\n            for(int j=int(l.size());j>=2&&ccw(l[j-2],l[j-1],s[i])==counter_clockwise;j--){\n                l.pop_back();\n            }\n            l.push_back(s[i]);\n        }\n    }\n    \n    if(!ok){\n        for(int i=2;i<n;i++){\n            for(int j=int(u.size());j>=2&&ccw(u[j-2],u[j-1],s[i])!=clockwise;j--){\n                u.pop_back();\n            }\n            u.push_back(s[i]);\n        }\n        \n        for(int i=int(s.size())-3;i>=0;i--){\n            for(int j=int(l.size());j>=2&&ccw(l[j-2],l[j-1],s[i])!=clockwise;j--){\n                l.pop_back();\n            }\n            l.push_back(s[i]);\n        }\n    }\n    \n    reverse(all(l));\n    \n    for(int i=int(u.size())-2;i>=1;i--) l.push_back(u[i]);\n    \n    return l;\n}//ok==1なら辺の上も含める\n\nPolygon convex_cut(const Polygon& P, const Line& l) {\n    Polygon Q;\n    for(int i=0;i<si(P);i++){\n        Point A=P[i],B=P[(i+1)%si(P)];\n        if(ccw(l.p1,l.p2,A)!=-1)Q.push_back(A);\n        if(ccw(l.p1,l.p2,A)*ccw(l.p1,l.p2,B)<0) Q.push_back(getCrossPoint(Line{A,B},l));\n    }\n    return Q;\n}\n\ndouble area(Point a,Point b,Point c){\n    b=b-a;\n    c=c-a;\n    return abs(b.x*c.y-b.y*c.x)/2.0;\n}\n\ndouble area(Polygon &P){\n    if(si(P)==0) return 0.0;\n    double res=0;\n    Point c={0.0,0.0};\n    for(int i=0;i<si(P);i++){\n        c=c+P[i];\n    }\n    c=c/si(P);\n    \n    for(int i=0;i<si(P);i++){\n        res+=area(c,P[i],P[(i+1)%si(P)]);\n    }\n    \n    return res;\n}\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    while(1){\n        int N,M;cin>>N>>M;\n        if(N==0) break;\n        Polygon P(N);\n        for(int i=0;i<N;i++) cin>>P[i].x>>P[i].y;\n        vector<Point> Q(M);\n        for(int i=0;i<M;i++) cin>>Q[i].x>>Q[i].y;\n        \n        for(int i=0;i<M;i++){\n            Polygon po=P;\n            for(int j=0;j<M;j++){\n                if(i==j) continue;\n                \n                Line l;\n                l.p1=(Q[i]+Q[j])/2.0;\n                l.p2=l.p1+Point{-(Q[j]-Q[i]).y,(Q[j]-Q[i]).x};\n                \n                po=convex_cut(po,l);\n            }\n            \n            cout<<setprecision(25)<<area(po)<<endl;\n        }\n        \n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P; //Point\ntypedef pair<P,P> L; //Line, Segment\nconst double EPS = 1e-8;\n\ndouble dot(P a, P b){ return real(conj(a)*b); }\ndouble cross(P a, P b){ return imag(conj(a)*b); }\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > EPS) return 1;   // ????????????(b-a)????????´???????????????(c-a)????????¨?????????\n  if(cross(b,c) < -EPS) return -1; // ????????????(b-a)????????´???????????????(c-a)????????¨?????????\n  if(dot(b,c) < -EPS) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n\ndouble area(vector<P> v){\n  double sum = 0.0;\n  int n = v.size();\n  for(int i=0;i<n;i++) sum += (real(v[i]) - real(v[(i+1)%n])) * (imag(v[i]) + imag(v[(i+1)%n]));\n  return fabs(sum) / 2;\n}\n\nP crossPoint(L l, L m){\n  double A = cross(l.second - l.first, m.second - m.first);\n  double B = cross(l.second - l.first, l.second - m.first);\n  if(fabs(A) < EPS && fabs(B) < EPS) return m.first;\n  else if(fabs(A) >= EPS) return m.first + B / A * (m.second - m.first);\n}\n\nvector<P> convex_cut(vector<P> G, L l){\n  vector<P> ans;\n  for(int i=0;i<G.size();i++){\n    P A = G[i];\n    P B = G[(i+1)%G.size()];\n    if(ccw(l.first, l.second, A) != -1) ans.push_back(A);\n    if(ccw(l.first, l.second, A) * ccw(l.first, l.second, B) < 0)\n      ans.push_back(crossPoint(L(A,B), l));\n  }\n  return ans;\n}\n\nint n,m;\nvector<P> mp;\ndouble calc(int idx,vector<P>g){\n  for(int i=0;i<m;i++){\n    if(i==idx)continue;\n    P t=mp[idx]-mp[i];\n    P a=P(abs(t)/2,1)*t/abs(t)+mp[i];\n    P b=P(abs(t)/2,-1)*t/abs(t)+mp[i];\n    g=convex_cut(g,L(a,b));\n  }\n  return area(g);\n}\n\nint main(){\n  while(1){\n    cin>>n>>m;\n    if(!n&&!m)break;\n    vector<P> pl(n);\n    mp.resize(m);\n    for(int i=0,x,y;i<n;i++)cin>>x>>y,pl[i]=P(x,y);\n    for(int i=0,x,y;i<m;i++)cin>>x>>y,mp[i]=P(x,y);\n    for(int i=0;i<m;i++)printf(\"%.10f\\n\",calc(i,pl));\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n \nusing namespace std;\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator + (Point p) {return Point(x+p.x,y+p.y);}\n  Point operator - (Point p) {return Point(x-p.x,y-p.y);}\n  Point operator * (double k) {return Point(x*k,y*k);}\n  Point operator / (double k) {return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x ? x < p.x : y < p.y;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nstruct Segment{\n  Point p1,p2;\n  Segment(){}\n  Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nstruct Circle{\n  Point c;\n  double r;\n  Circle(Point c,double r):c(c),r(r){}\n};\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n\nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n  return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0); \n}\n\nPoint project(Segment s,Point p){\n  Vector base=s.p2-s.p1;\n  double r=dot(p-s.p1,base)/norm(base);\n  return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2.0;\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CLOCKWISE;\n  if(dot(a,b) < -EPS) return ONLINE_BACK;\n  if(a.norm()<b.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 &&\n\t  ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 );\n}\n\nbool intersect(Segment s1,Segment s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n  if(intersect(s1,s2)) return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t     min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPoint getCrossPoint(Segment s1,Segment s2){\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n\n\npair<Point,Point> getCrossPoints(Circle c,Line l){\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  return make_pair(pr+e*base,pr-e*base);\n}\n\n\ndouble arg(Vector p){\n  return atan2(p.y,p.x);\n}\n\nVector polar(double a,double r){\n  return Point(cos(r)*a,sin(r)*a);\n}\n\npair<Point,Point> getCrossPoints(Circle c1,Circle c2){\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  return make_pair(c1.c+polar(c1.r,t+a),c1.c+polar(c1.r,t-a));\n}\n\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(fabs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;\n    if(a.y>b.y) swap(a,b);\n    if(a.y < EPS && EPS < b.y && cross(a,b) > EPS ) x = !x;\n  }\n  return (x?2:0);\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3) return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i]) != CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  } \n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i]) != CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  return l;\n} \n\ndouble area(Polygon s){\n  double res=0;\n  for(int i=0;i<(int)s.size();i++){\n    res+=cross(s[i],s[(i+1)%s.size()])/2.0;\n  }\n  return abs(res);\n}\n\nPoint getCrossPointLL(Line l1,Line l2){\n  double a=cross(l1.p2-l1.p1,l2.p2-l2.p1);\n  double b=cross(l1.p2-l1.p1,l1.p2-l2.p1);\n  if(abs(a)<EPS&&abs(b)<EPS) return l2.p1;\n  return l2.p1+(l2.p2-l2.p1)*(b/a);\n}\n\nPolygon convexCut(Polygon p,Line l){\n  Polygon q;\n  for(int i=0;i<(int)p.size();i++){\n    Point a=p[i],b=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,a)!=-1) q.push_back(a);\n    if(ccw(l.p1,l.p2,a)*ccw(l.p1,l.p2,b)<0)\n      q.push_back(getCrossPointLL(Line(a,b),l));\n  }\n  return q;\n}\n\nLine bisector(Point p1,Point p2){\n  Circle c1=Circle(p1,abs(p1-p2)),c2=Circle(p2,abs(p1-p2));\n  pair<Point,Point> p=getCrossPoints(c1,c2);\n  if(cross(p2-p1,p.first-p1)>0) swap(p.first,p.second);\n  return Line(p.first,p.second);\n}\n\nint main(){\n  int n,m;\n  while(cin>>n>>m,n||m){\n    Polygon p,q;\n    for(int i=0;i<n;i++){\n      double x,y;\n      cin>>x>>y;\n      p.push_back(Point(x,y));\n    }\n    for(int i=0;i<m;i++){\n      double x,y;\n      cin>>x>>y;\n      q.push_back(Point(x,y));\n    }\n    for(int i=0;i<m;i++){\n      Polygon t=p;\n      //cout<<area(t)<<\" \";\n      for(int j=0;j<m;j++){\n\tif(i==j) continue;\n\tt=convexCut(t,bisector(q[i],q[j]));\n      }\n      cout<<area(t)<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cassert>\n\n#include <vector>\n#include <algorithm>\n\n#define x first\n#define y second\n\nusing namespace std;\n\ntypedef pair<double, double> Point;\n\nclass Line {\n  public:\n    double a, b, c;\n\n    Line(const double _a = 0.0, const double _b = 0.0, const double _c = 0.0):\n      a(_a),\n      b(_b),\n      c(_c) {}\n\n    Line(const Point &p1, const Point &p2):\n      a(p1.y - p2.y),\n      b(p2.x - p1.x),\n      c(p1.x * p2.y - p1.y * p2.x) {}\n};\n\nvector<Line> Plane;\nvector<Point> Points;\nvector<double> Areas;\n\ninline double Det(const Point &a, const Point &b, const Point &c) {\n    return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\n}\n\nclass Compare {\n  public:\n    static Point origin;\n\n    bool operator()(const Point &a, const Point &b) const {\n        return Det(origin, a, b) >= 0;\n    }\n};\n\nPoint Compare::origin;\n\nvector<Point> ConvexHull(vector<Point> points) {\n    int n = int(points.size());\n    int origin = 0;\n    for (int i = 1; i < n; ++i)\n        if (points[i] < points[origin])\n            origin = i;\n    Compare::origin = points[origin];\n    swap(points[0], points[origin]);\n    sort(points.begin() + 1, points.end(), Compare());\n    vector<Point> hull;\n    for (int i = 0; i < int(points.size()); ++i) {\n        while (int(hull.size()) > 1 && Det(hull[int(hull.size()) - 2], hull[int(hull.size()) - 1], points[i]) <= 0)\n            hull.pop_back();\n        hull.push_back(points[i]);\n    }\n    return hull;\n}\n\ninline Point Dualize(const Line &l) {\n    if (l.c == 0)\n        return Point(0, 0);\n    else\n        return Point(l.a / l.c, l.b / l.c);\n}\n\ninline Line Dualize(const Point &p) {\n    return Line(p.x, p.y, 1);\n}\n\ninline Point Translate(const Point &p, const Point &shift) {\n    return Point(p.x + shift.x, p.y + shift.y);\n}\n\ninline Line Translate(const Line &l, const Point &shift) {\n    return Line(l.a, l.b, l.c - l.a * shift.x - l.b * shift.y);\n}\n\nvector< vector<Point> > GetVoronoiDiagrams(const vector<Line> &plane, const vector<Point> &points) {\n    int n = int(points.size());\n    vector< vector<Point> > voronoiDiagrams = vector< vector<Point> >(n, vector<Point>());\n    for (int i = 0; i < n; ++i) {\n        Point shift = Point(-points[i].x, -points[i].y);\n        vector<Point> dualizedLines;\n        for (int j = 0; j < int(plane.size()); ++j)\n            dualizedLines.push_back(Dualize(Translate(plane[j], shift)));\n        for (int j = 0; j < n; ++j) {\n            if (i != j) {\n                Point a = points[i], b = points[j];\n                dualizedLines.push_back(Dualize(Translate(Line(2 * (b.x - a.x), 2 * (b.y - a.y), a.x * a.x + a.y * a.y - b.x * b.x - b.y * b.y), shift)));\n            }\n        }\n        vector<Point> hull = ConvexHull(dualizedLines);\n        for (int j = 0; j < int(hull.size()); ++j)\n            voronoiDiagrams[i].push_back(Translate(Dualize(Line(hull[j], hull[(j + 1) % int(hull.size())])), points[i]));\n    }\n    return voronoiDiagrams;\n}\n\ninline double GetArea(const vector<Point> &polygon) {\n    int n = int(polygon.size());\n    double area = 0.0;\n    for (int i = 0; i < n; ++i)\n        area += polygon[i].x * polygon[(i + 1) % n].y - polygon[(i + 1) % n].x * polygon[i].y;\n    area /= 2.0;\n    if (area < 0.0)\n        area = -area;\n    return area;\n}\n\nvoid Solve() {\n    vector< vector<Point> > voronoi = GetVoronoiDiagrams(Plane, Points);\n    Areas = vector<double>(int(Points.size()), 0.0);\n    for (int i = 0; i < int(Points.size()); ++i)\n        Areas[i] = GetArea(voronoi[i]);\n}\n\nbool Read() {\n    int n, m;\n    assert(scanf(\"%d %d\", &n, &m) == 2);\n    if (n == 0 && m == 0)\n        return false;\n    vector<Point> planePolygon = vector<Point>(n);\n    for (int i = 0; i < n; ++i)\n        assert(scanf(\"%lf %lf\", &planePolygon[i].x, &planePolygon[i].y) == 2);\n    for (int i = 0; i < n; ++i)\n        Plane.push_back(Line(planePolygon[i], planePolygon[(i + 1) % n]));\n    Points = vector<Point>(m);\n    for (int i = 0; i < m; ++i)\n        assert(scanf(\"%lf %lf\", &Points[i].x, &Points[i].y) == 2);\n    return true;\n}\n\nvoid Print() {\n    for (int i = 0; i < int(Points.size()); ++i)\n        printf(\"%.7lf\\n\", Areas[i]);\n}\n\nint main() {\n    //assert(freopen(\"voronoi.in\", \"r\", stdin));\n    //assert(freopen(\"voronoi.out\", \"w\", stdout));\n    while (Read()) {\n        Solve();\n        Print();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<complex>\n#include<cstdio>\n#include<iostream>\n#include<queue>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\ntemplate<class T> T at(vector<T> v, int i) {return v[i % v.size()];}\n\n#define X real()\n#define Y imag()\n\ntypedef long double D;\ntypedef complex<D> P;\nstruct L{P a, b;};\ntypedef vector<P> Pol;\n\nconst D EPS = 1e-8;\nconst D PI = acos(-1);\n\nint sig(D a, D b = 0) {return a < b - EPS ? -1 : a > b + EPS ? 1 : 0;}\nbool near(P a, P b) {return norm(a - b) < EPS;}\n\nnamespace std {\n  bool operator<(P a, P b) {return sig(a.X, b.X) ? a.X < b.X : a.Y < b.Y;}\n  bool operator<(L a, L b) {return !near(a.a, b.a) ? a.a < b.a : a.b < b.b;}\n}\n\nD sr(D a) {return sqrt(max(a, (D)0));}\n\n// 外積\nD det(P a, P b) {return a.X * b.Y - a.Y * b.X;}\n\n// 線分のベクトル\nP vec(L a) {return a.b - a.a;}\n\n// 線分abに対する点cの位置\nenum CCW{FRONT = 1, RIGHT = 2, BACK = 4, LEFT = 8, ON = 16};\nint ccw(P a, P b, P c) {\n  if (a == c || b == c) return ON;\n  int s = sig(det(b - a, c - a));\n  if (s) return s > 0 ? LEFT : RIGHT;\n  return (a < b) == (b < c) ? FRONT : (c < a) == (a < b) ? BACK : ON;\n}\n\nbool iLSs(L a, L b) {return sig(det(vec(a), b.a - a.a)) * sig(det(vec(a), b.b - a.a)) < 0;}\n\n// 交点\nP pLL(L a, L b) {return a.a + vec(a) * (det(vec(b), b.a - a.a) / det(vec(b), vec(a)));}\n\n// 多角形の面積\nD aPol(Pol vp) {\n  D ret = 0;\n  rep (i, vp.size()) ret += det(vp[i], at(vp, i + 1));\n  return ret / 2;\n}\n\n// 凸包カット\nPol convexCut(Pol p, L l) {\n  vector<P> q;\n  rep (i, p.size()) {\n    if (ccw(l.a, l.b, p[i]) != RIGHT) q.push_back(p[i]);\n    L s = {p[i], at(p, i + 1)};\n    if (iLSs(l, s)) q.push_back(pLL(l, s));\n  }\n  return q;\n}\n\n// ボロノイ図構築各母点についてのボノロイ頂点が反時計回りに与えられる\nvector<Pol> makeVolonoi(vector<P> vp, Pol plane) {\n  vector<Pol> res;\n  Pol tplane;\n  rep (i, vp.size()) {\n    tplane = plane;\n    rep (j, vp.size()) if (i != j) {\n      P p = (vp[i] + vp[j]) / (D)2;\n      L l = {p, p + (vp[j] - vp[i]) * P(0, 1)};\n      tplane = convexCut(tplane, l);\n    }\n    res.push_back(tplane);\n  }\n  return res;\n}\n\nint main() {\n  while (true) {\n    int n, m;\n    cin >> n >> m;\n    if (n == 0 && m == 0) break;\n    Pol pol(n);\n    vector<P> lords(m);\n    rep (i, n) cin >> pol[i].X >> pol[i].Y;\n    rep (i, m) cin >> lords[i].X >> lords[i].Y;;\n    vector<Pol> volonoi = makeVolonoi(lords, pol);\n    rep (i, m) printf(\"%.12Lf\\n\", aPol(volonoi[i]));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P, P> L;\ntypedef vector<P> VP;\nconst D EPS = 1e-9;\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\nD dot(P a, P b) {return (conj(a)*b).X; }\nD cross(P a, P b) {  return (conj(a)*b).Y;}\nint ccw(P a, P b, P c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1; \n  if (cross(b,c) < -EPS) return -1;\n  if (dot(b,c)   < -EPS) return +2;\n  if (norm(b) < norm(c)) return -2;  \n  return 0; \n}\nP crosspointLL(P a1, P a2, P b1, P b2) {\n  D d1 = cross(b2-b1, b1-a1);\n  D d2 = cross(b2-b1, a2-a1);\n  if (EQ(d1, 0) && EQ(d2, 0)) return a1;\n  if (EQ(d2, 0)) throw \"kouten ga nai\";\n  return a1 + d1/d2 * (a2-a1);\n}\nVP convexCut(const VP& ps, P a1, P a2) {\n  int n = ps.size();\n  VP ret;\n  rep(i,n) {\n    int ccwc = ccw(a1, a2, ps[i]);\n    if (ccwc != -1) ret.push_back(ps[i]);\n    int ccwn = ccw(a1, a2, ps[(i + 1) % n]);\n    if (ccwc * ccwn == -1) ret.push_back(crosspointLL(a1, a2, ps[i], ps[(i + 1) % n]));\n  }\n  return ret;\n}\nD area(const VP& ps) {\n  D a = 0;\n  rep (i, ps.size()) a += cross(ps[i], ps[(i+1) % ps.size()]);\n  return a / 2;\n}\nVP voronoiCell(P p, const VP& ps, const VP& outer) {\n  VP cl = outer;\n  rep (i, ps.size()) {\n    if (EQ(norm(ps[i]-p), 0)) continue;\n    P h = (p+ps[i])*0.5;\n    cl = convexCut(cl, h, h + (ps[i]-h)*P(0,1) );\n  }\n  return cl;\n}\nint n,m;\nVP v1,v2;\ndouble x,y;\nint main(){\n  while(cin>>n>>m,n){\n    v1.clear();\n    v2.clear();\n    rep(i,n){\n      cin>>x>>y;\n      v1.push_back(P(x,y));\n    }\n    rep(i,m){\n      cin>>x>>y;\n      v2.push_back(P(x,y));\n    }\n    rep(i,m){\n      VP t=voronoiCell(v2[i],v2,v1);\n      printf(\"%.10f\\n\",area(t));\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P; //Point\ntypedef pair<P,P> L; //Line, Segment\n\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\n\nnamespace std {\n  bool operator < (const P& a, const P& b){\n    return fabs(real(a)-real(b)) < EPS ? imag(a) < imag(b) : real(a) < real(b);\n  }\n}\ndouble dot(P a, P b){ return real(conj(a)*b); }\ndouble cross(P a, P b){ return imag(conj(a)*b); }\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > EPS) return 1;   // ????????????(b-a)????????´???????????????(c-a)????????¨?????????\n  if(cross(b,c) < -EPS) return -1; // ????????????(b-a)????????´???????????????(c-a)????????¨?????????\n  if(dot(b,c) < -EPS) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n\ndouble area(vector<P> v){\n  double sum = 0.0;\n  int n = v.size();\n  for(int i=0;i<n;i++) sum += (real(v[i]) - real(v[(i+1)%n])) * (imag(v[i]) + imag(v[(i+1)%n]));\n  return fabs(sum) / 2;\n};\n\nP crossPoint(L l, L m){\n  double A = cross(l.second - l.first, m.second - m.first);\n  double B = cross(l.second - l.first, l.second - m.first);\n  if(fabs(A) < EPS && fabs(B) < EPS) return m.first;\n  else if(fabs(A) >= EPS) return m.first + B / A * (m.second - m.first);\n}\n\nvector<P> convex_cut(vector<P> G, L l){\n  vector<P> ans;\n  for(int i=0;i<G.size();i++){\n    P A = G[i];\n    P B = G[(i+1)%G.size()];\n    if(ccw(l.first, l.second, A) != -1) ans.push_back(A);\n    if(ccw(l.first, l.second, A) * ccw(l.first, l.second, B) < 0)\n      ans.push_back(crossPoint(L(A,B), l));\n  }\n  return ans;\n}\n\nint n,m;\nvector<P> mp;\ndouble calc(int idx,vector<P>g){\n  for(int i=0;i<m;i++){\n    if(i==idx)continue;\n    P t=mp[idx]-mp[i];\n    P a=P(abs(t)/2,1)*t/abs(t)+mp[i];\n    P b=P(abs(t)/2,-1)*t/abs(t)+mp[i];\n    if(ccw(a,b,mp[idx])<0)swap(a,b);\n    g=convex_cut(g,L(a,b));\n  }\n  return area(g);\n}\n\nint main(){\n  while(1){\n  cin>>n>>m;\n  if(!n&&!m)break;\n  vector<P> pl(n);\n  mp.resize(m);\n  for(int i=0,x,y;i<n;i++)cin>>x>>y,pl[i]=P(x,y);\n  for(int i=0,x,y;i<m;i++)cin>>x>>y,mp[i]=P(x,y);\n  for(int i=0;i<m;i++)printf(\"%.1f\\n\",calc(i,pl));\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,k,n) for(int i=(k);i<(int)(n);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(x) begin(x),end(x)\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nconst ld eps = 1e-8, pi = acos(-1.0);\n\n#define EQ(a,b) (abs((a)-(b))<eps)\n\nnamespace std {\n  bool operator<(const P &lhs, const P &rhs) {\n    return lhs.real() == rhs.real() ? lhs.imag() < rhs.imag()\n                                    : lhs.real() < rhs.real();\n  }\n}\n\nld dot (P a, P b) { return real(conj(a) * b); }\nld cross (P a, P b) { return imag(conj(a) * b); }\n\nstruct L{ P a, b; };\n\nint ccw (P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > eps) return 1;   // counter clockwise\n  if (cross(b, c) < -eps) return -1; // clockwise\n  if (dot(b, c) < 0) return 2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line\n  return 0;                          // a--c--b on line\n}\n\nbool isis_ls(L l, L s) {\n  ld a = cross(l.b - l.a, s.a - l.a);\n  ld b = cross(l.b - l.a, s.b - l.a);\n  return (a * b < eps);\n}\n\nP is_ll(L s, L t){\n  P sv = s.b - s.a, tv = t.b - t.a;\n  return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nld area(const VP &p) {\n  ld res = 0;\n  int n = p.size();\n  REP(j,n) res += cross(p[j], p[(j+1)%n]);\n  return res / 2;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n  bool in = false;\n  int n = g.size();\n  for (int i = 0; i < n; i++) {\n    P a = g[i] - p, b = g[(i+1)%n] - p;\n    if (imag(a) > imag(b)) swap(a, b);\n    if (imag(a) <= 0 && 0 < imag(b))\n      if (cross(a, b) < 0) in = !in;\n    if (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n  }\n  if(in) return 1; // in\n  return -1; // out\n}\n\nint main() {\n  while(1){\n    int n,m;\n    cin>>n>>m;\n    if(!n) break;\n    VP pl,vp;\n    REP(i,n){\n      int x,y;\n      cin>>x>>y;\n      pl.emplace_back(x,y);\n    }\n    REP(i,m){\n      int x,y;\n      cin>>x>>y;\n      vp.emplace_back(x,y);\n    }\n    REP(i,m) {\n      VP poly = pl;\n      REP(j,m) {\n        if (j == i) continue;\n        P pc = (vp[i] + vp[j]) / ld(2.0);\n        P ig(0,1);\n        L l1 = {pc, (vp[j] - pc) * ig + pc};\n        vector<pair<int,P>> is;\n        REP(k,poly.size()) {\n          L l2 = {poly[k], poly[(k+1)%poly.size()]};\n          if (isis_ls(l1, l2)) {\n            is.emplace_back(k, is_ll(l1, l2));\n          }\n        }\n        sort(ALL(is));\n        if (is.size() < 2) continue;\n        do {\n          int k; P p;\n          tie(k, p) = is[0];\n          int l; P q;\n          tie(l, q) = is[1];\n          if (l < k) l += poly.size();\n          VP np;\n          np.push_back(p);\n          FOR(a,k+1,l+1) {\n            np.push_back(poly[a%poly.size()]);\n          }\n          np.push_back(q);\n          if (is_in_Polygon(np, vp[i]) > 0) {\n            poly = np;\n            break;\n          }\n        } while(next_permutation(ALL(is)));\n      }\n      cout <<fixed << setprecision(10)<< area(poly) << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P, P> L;\ntypedef vector<P> VP;\nconst D EPS = 1e-9;\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\nD dot(P a, P b) {return (conj(a)*b).X; }\nD cross(P a, P b) {  return (conj(a)*b).Y;}\nint ccw(P a, P b, P c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1; \n  if (cross(b,c) < -EPS) return -1;\n  if (dot(b,c)   < -EPS) return +2;\n  if (norm(b) < norm(c)) return -2;  \n  return 0; \n}\nP crosspointLL(P a1, P a2, P b1, P b2) {\n  D d1 = cross(b2-b1, b1-a1);\n  D d2 = cross(b2-b1, a2-a1);\n  if (EQ(d1, 0) && EQ(d2, 0)) return a1;\n  if (EQ(d2, 0)) throw \"kouten ga nai\";\n  return a1 + d1/d2 * (a2-a1);\n}\nVP convexCut(const VP& ps, P a1, P a2) {\n  int n = ps.size();\n  VP ret;\n  rep(i,n) {\n    int ccwc = ccw(a1, a2, ps[i]);\n    if (ccwc != -1) ret.push_back(ps[i]);\n    int ccwn = ccw(a1, a2, ps[(i + 1) % n]);\n    if (ccwc * ccwn == -1) ret.push_back(crosspointLL(a1, a2, ps[i], ps[(i + 1) % n]));\n  }\n  return ret;\n}\nD area(const VP& ps) {\n  D a = 0;\n  rep (i, ps.size()) a += cross(ps[i], ps[(i+1) % ps.size()]);\n  return a / 2;\n}\nVP voronoiCell(P p, const VP& ps, const VP& outer) {\n  VP cl = outer;\n  rep (i, ps.size()) {\n    if (abs(ps[i]-p)<EPS) continue;\n    P h = (p+ps[i])*0.5;\n    cl = convexCut(cl, h, h + (ps[i]-h)*P(0,1) );\n  }\n  return cl;\n}\nint n,m;\nVP v1,v2;\ndouble x,y;\nint main(){\n  while(cin>>n>>m,n){\n    v1.clear();\n    v2.clear();\n    rep(i,n){\n      cin>>x>>y;\n      v1.push_back(P(x,y));\n    }\n    rep(i,m){\n      cin>>x>>y;\n      v2.push_back(P(x,y));\n    }\n    rep(i,m){\n      VP t=voronoiCell(v2[i],v2,v1);\n      printf(\"%.10f\\n\",area(t));\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nconst double EPS = 1e-8;\n\nusing R = long double;\nusing P = complex<R>;\nusing L = pair<P,P>;\nusing G = vector<P>;\nstruct C {\n  P c; R r;\n  C() {}\n  C(const P &a, const R &b) : c(a), r(b) {}\n};\nstruct S : public L {\n  S() {}\n  S(const P &a, const P &b) : L(a,b) {}\n};\n\ninline int sgn(const R& r) { return (r>EPS) - (r<-EPS); }\ninline R dot(const P& a, const P& b) {\n  return real(a)*real(b) + imag(a)*imag(b);\n}\ninline R det(const P& a, const P& b) {\n  return real(a)*imag(b) - imag(a)*real(b);\n}\ninline P vec(const L& l) {return l.second - l.first;}\nnamespace std {\n\tbool operator < (const P& a, const P& b) {\n\t\treturn sgn(real(a-b)) ? real(a-b) < 0 : sgn(imag(a-b)) < 0;\n\t}\n\tbool operator == (const P& a, const P& b) {\n\t\treturn sgn(real(a-b)) == 0 && sgn(imag(a-b)) == 0;\n\t}\n  bool cmp_y (const P& a, const P& b) {\n    return sgn(imag(a-b)) ? imag(a-b) < 0 : sgn(real(a-b)) < 0;\n  }\n}\n\n// P,L,Sについて入力\ninline istream& operator>>(istream& is, P& p) {\n  R x, y;\n  is >> x >> y;\n  p = P(x, y);\n  return is;\n}\ninline istream& operator>>(istream& is, L& l) {\n  P a, b;\n  is >> a >> b;\n  l = L(a, b);\n  return is;\n}\ninline istream& operator>>(istream& is, S& s) {\n  P a, b;\n  is >> a >> b;\n  s = S(a, b);\n  return is;\n}\n\n// 射影\nP inline projection(const L &l, const P &p) {\n  R t = dot(p-l.first, l.first-l.second) / norm(l.first-l.second);\n  return l.first + t*(l.first-l.second);\n}\n// 反射\nP inline reflection(const L &l, const P &p) {\n  return p + (R)2 * (projection(l, p) - p);\n}\n\n// 線分abから見たcの位置\nenum CCW{LEFT=1, RIGHT=2, BACK=4, FRONT=8, ON_SEG=16};\nint ccw(P a, P b, P c) {\n\tP p = (c-a)/(b-a);\n\tif(sgn(imag(p)) > 0) return LEFT;\n\tif(sgn(imag(p)) < 0) return RIGHT;\n\tif(sgn(real(p)) < 0) return BACK;\n\tif(sgn(real(p)-1) > 0) return FRONT;\n\treturn ON_SEG;\n}\n\n// 垂直,平行\ninline bool vertical(L a, L b) {return sgn(dot(vec(a), vec(b))) == 0;}\ninline bool parallel(L a, L b) {return sgn(det(vec(a), vec(b))) == 0;}\ninline bool eal(L a, L b) {return vertical(a,b) && parallel(a,b);}\n\n// 交差判定\ntemplate<bool strict=false> inline bool intersect(const L&l1, const L&l2) {\n  if(strict) return sgn(det(vec(l1),vec(l2))) != 0;\n  return sgn(det(vec(l1),vec(l2))) != 0 || l1 == l2;\n}\ntemplate<bool strict=false> inline bool intersect(const L&l, const S&s) {\n  if(strict) det(s.first, vec(l)) * det(s.second, vec(l)) < 0;\n  return det(s.first, vec(l)) * det(s.second, vec(l)) <= 0;\n}\ntemplate<bool strict=false> inline bool intersect(const S&s1, const S&s2) {\n  int ccw1 = ccw(s1.first, s1.second, s2.first) | ccw(s1.first, s1.second, s2.second);\n  int ccw2 = ccw(s2.first, s2.second, s1.first) | ccw(s2.first, s2.second, s1.second);\n  if(strict) return (ccw1 & ccw2) == (LEFT | RIGHT);\n  return (ccw1 & ccw2) == (LEFT | RIGHT) || ((ccw1 | ccw2) & ON_SEG);\n}\ntemplate<bool strict=false> inline bool intersect(const S&s, const P&p) {\n  return ccw(s.first, s.second, p) == ON_SEG;\n}\ntemplate<bool strict=false> inline bool intersect(const L&l, const P&p) {\n  return ccw(l.first, l.second, p) == ON_SEG ||\n          ccw(l.first, l.second, p) == FRONT ||\n          ccw(l.first, l.second, p) == BACK;\n}\nint intersect(const C& a, const C& b) {\n\tR dist = sqrt(norm(a.c-b.c)), r1 = a.r + b.r, r2 = abs(a.r - b.r);\n\tif(sgn(r1-dist) < 0)  return 4;\t// 円が離れている\n\tif(sgn(r1-dist) == 0) return 3;\t// 外接\n\tif(sgn(r2-dist) < 0 && sgn(dist-r1) < 0) return 2; // 交差\n\tif(sgn(dist-r2) == 0) return 1; // 内接\n\treturn 0;\t// 内部に含む\n}\n\n// 距離\nR dist(const S& s, const P& p) {\n  P q = projection(s, p);\n  if(sgn(dot(s.second-s.first, p-s.first)) <= 0) q = s.first;\n  if(sgn(dot(s.first-s.second, p-s.second)) <= 0) q = s.second;\n  return abs(p-q);\n}\nR dist(const S& a, const S& b) {\n  if(intersect(a, b)) return 0;\n  return min({dist(a, b.first), dist(a, b.second), dist(b, a.first), dist(b, a.second)});\n}\nR dist(const L& l, const P& p) {\n  P q = projection(l, p);\n  return abs(p-q);\n}\n\n// 交点 交差判定を先にすること!!!\ninline P crosspoint(const L& l1, const L& l2) {\n  R ratio = det(vec(l2), l2.first-l1.first)/det(vec(l2),vec(l1));\n  return l1.first + vec(l1)*ratio;\n}\nvector<P> crosspoint(C c, L l) {\n\tR d = dist(l, c.c), r = c.r;\n\tP m = projection(l, c.c);\n\tP x = sqrt(r*r-d*d)*vec(l)/abs(vec(l));\n\tvector<P> ret(2,m);\n\tret[0] -= x; ret[1] += x;\n\tif(ret[1] < ret[0]) swap(ret[0], ret[1]);\n\treturn ret;\n}\nvector<P> crosspoint(C a, C b) {\n\tR d = abs(a.c-b.c);\n\tR t = (a.r*a.r-b.r*b.r+d*d)/2/d, h = sqrt(a.r*a.r-t*t);\n\tP m = t/abs(b.c-a.c)*(b.c-a.c)+a.c;\n  auto n_vector = [&](P p) -> P { return P(-p.imag(), p.real())/abs(p); };\n\tP n = n_vector(a.c-b.c);\n\tvector<P> ret(2, m);\n\tret[0] -= h*n; ret[1] += h*n;\n\tif(ret[1] < ret[0]) swap(ret[0], ret[1]);\n\treturn ret;\n}\n\n// 面積 頂点が反時計回りに並んでいること\nR area(const G& pol) {\n  R ret = 0.0;\n  REP(i, pol.size()) ret += det(pol[i], pol[(i+1)%pol.size()]);\n  return (ret/2.0);\n}\n\n// 凸性の判定\nbool isConvex(const G& pol) {\n  REP(i, pol.size()) {\n    if(sgn(det(pol[(i+1)%pol.size()]-pol[i], pol[(i+2)%pol.size()]-pol[i])) < 0) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// 多角形と点の内包\n// 2→in 1→on 0→out\nint inPolygon(const G& pol, const P& p) {\n  bool in = false;\n  for (int i = 0; i < pol.size(); ++i) {\n  \tP a = pol[i] - p, b = pol[(i+1)%pol.size()] - p;\n    if (imag(a) > imag(b)) swap(a, b);\n    if (imag(a) <= 0 && 0 < imag(b) && sgn(det(a, b)) < 0) {\n      in = !in;\n    }\n    if (sgn(det(a, b)) == 0 && sgn(dot(a, b)) <= 0) return 1;\n  }\n  return in ? 2 : 0;\n}\n\n// 凸包 3点が一直線上に並ぶときに注意\n// 凸包のうち一番左にある頂点の中で一番下の頂点から時計回り\nG convex_hull(G ps) {\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  G r(2*n);\n  for(int i=0; i<n; i++){\n    while(k>1 && sgn(det(r[k-1]-r[k-2], ps[i]-r[k-2])) < 0) k--;\n    r[k++] = ps[i];\n  }\n  for(int i=n-2,t=k; i>=0; i--){\n    while(k>t && sgn(det(r[k-1]-r[k-2], ps[i]-r[k-2])) < 0) k--;\n    r[k++] = ps[i];\n  }\n  r.resize(k-1);\n  return r;\n}\n\n// 3点が与えられたときに円を求める\n// 3点が直線上に並んでいるときは{0, 0, -1}を返す\n// ToDo:見直す\nC calcCircle(R x1, R y1, R x2, R y2, R x3, R y3) {\n  R a = x2-x1, b = y2-y1, c = x3-x1, d = y3-y1;\n  if ((sgn(a) && sgn(d)) || (sgn(b) && sgn(c))) {\n    R ox = x1+(d*(a*a+b*b)-b*(c*c+d*d))/(a*d-b*c)/2, oy;\n    if (b) oy = (a*(x1+x2-ox-ox) + b*(y1+y2)) / b/2;\n    else oy = (c*(x1+x3-ox-ox) + d*(y1+y3)) / d/2;\n    R r1 = sqrt((ox-x1) * (ox-x1) + (oy-y1) * (oy-y1)),\n      r2 = sqrt((ox-x2) * (ox-x2) + (oy-y2) * (oy-y2)),\n      r3 = sqrt((ox-x3) * (ox-x3) + (oy-y3) * (oy-y3)),\n      r = (r1+r2+r3) / 3;\n    return {P{ox, oy}, r};\n  }\n  return {P{0, 0}, -1};\n}\n\n// 2点p1, p2を通り、半径がrの円を2つ返す\nvector<C> calcCircle(P p1, P p2, R r) {\n\t// 存在しない\n\tif(abs(p1-p2) > 2*r) return {};\n\tP p3 = {(p1.real()+p2.real())/2, (p1.imag()+p2.imag())/2};\n\tR l = abs(p1-p3);\n\tP p1p2 = p2-p1;\n\tR a = p1p2.real(), b = p1p2.imag();\n\tR dx1 = b*sqrt((r*r-l*l)/(a*a+b*b)), dy1 = a*sqrt((r*r-l*l)/(a*a+b*b));\n\treturn {{{p3.real()+dx1, p3.imag()-dy1}, r}, {{p3.real()-dx1, p3.imag()+dy1}, r}};\n}\n\nG convex_cut(const G& pol, const L& l) {\n  G res;\n  REP(i, pol.size()) {\n    P a = pol[i], b = pol[(i + 1)%pol.size()];\n    int da = sgn(det(l.first-a, l.second-a)), db = sgn(det(l.first-b, l.second-b));\n    if (da >= 0) res.emplace_back(a);\n    if (da * db < 0) res.emplace_back(crosspoint(L{a, b}, l));\n  }\n  return res;\n}\n\n// -----ボロノイ図-----\n// 1直線上に3点が並んでるような部分を消去 O(p.size())\nG normalize_poligon(G p) {\n  int n = p.size();\n  REP(i, p.size()) {\n    if(ccw(p[(i+n-1)%n], p[i], p[(i+1)%n]) == ON_SEG) {\n      p.erase(p.begin() + i);\n      i--;\n    }\n  }\n  return p;\n}\n// 点a,bの垂直二等分線 O(1)\nL bisector(P a, P b) {\n  const P mid = (a + b) / P(2, 0);\n  return L{mid, mid + (b - a)*P(0, 1)};\n}\n// 多角形polと点集合vについてボロノイ図を計算\n// 点v[s]が属する部分を返す O(pol.size * v.size())\nG voronoi_cell(G pol, G v, int s) {\n  pol = normalize_poligon(pol);\n  REP(i, v.size()) if(i != s) {\n    pol = convex_cut(pol, bisector(v[s], v[i]));\n  }\n  return pol;\n}\n//-----ボロノイ図ここまで-----\n\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  while(1) {\n    int n, m;\n    cin >> n >> m;\n    if(!n && !m) break;\n    G island(n), lord(m);\n    REP(i, n) cin >> island[i];\n    REP(i, m) cin >> lord[i];\n\n    REP(i, m) {\n      G pol = voronoi_cell(island, lord, i);\n      cout << fixed << setprecision(15) << area(pol) << endl;\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\n#include <complex>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\ntypedef vector<P> Pol;\nD eps=1e-9;\ninline D cro(P a,P b){\n\treturn imag(conj(a)*b);\n}\ninline int ccw(P a,P b,P c){\n\tif(cro(b-a,c-a)>eps) return 1;\n\tif(cro(b-a,c-a)<-eps) return -1;\n\treturn 0;\n}\ninline bool iLSex(L l,L s){\n\treturn cro(l.sc-l.fs,s.fs-l.fs)*cro(l.sc-l.fs,s.sc-l.fs)<-eps;\n}\ninline P intLL(L a,L b){\n\tD t=cro(a.sc-a.fs,a.sc-b.fs)/cro(a.sc-a.fs,b.sc-b.fs);\n\treturn b.fs+t*(b.sc-b.fs);\n}\ninline Pol convexcut(Pol p,L l){\n\tPol ret;\n\trep(i,p.size()){\n\t\tif(ccw(l.fs,l.sc,p[i])!=-1) ret.pb(p[i]);\n\t\tL s=L(p[i],p[(i+1)%p.size()]);\n\t\tif(iLSex(l,s)) ret.pb(intLL(l,s));\n\t}\n\treturn ret;\n}\nvector<Pol> makevolonoi(Pol vp,Pol pol){\n\tvector<Pol> ret;\n\tPol polc=pol;\n\trep(i,vp.size()){\n\t\tpol=polc;\n\t\trep(j,vp.size()){\n\t\t\tif(i==j) continue;\n\t\t\tP p=(vp[i]+vp[j])/2.0,q=p+(vp[j]-vp[i])*P(0,1);\n\t\t\tpol=convexcut(pol,L(p,q));\n\t\t}\n\t\tret.pb(pol);\n\t}\n\treturn ret;\n}\nD aPol(Pol p){\n\tint n=p.size();\n\tD ret=0;\n\trep(i,n) ret+=cro(p[i],p[(i+1)%n])/2;\n\treturn ret;\n}\nint main(){\n\twhile(true){\n\t\tint N,M;\n\t\tcin>>N>>M;\n\t\tif(N==0) break;\n\t\tPol pol,vp;\n\t\trep(i,N){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tpol.pb(P(x,y));\n\t\t}\n\t\trep(i,M){\n\t\t\tint x,y;\n\t\t\tcin>>x>>y;\n\t\t\tvp.pb(P(x,y));\n\t\t}\n\t\tvector<Pol> vol=makevolonoi(vp,pol);\n\t\trep(i,M) printf(\"%.12f\\n\",aPol(vol[i]));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>void reg(vector<T> &ary,const T &elem){ary.emplace_back(elem);}\ntemplate<class T>bool chmin(T &a, const T &b) {return (b<a)?(a=b,1):0;}\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\n\nusing R=long double; // __float128\nconst R EPS = 1E-11; // [-1000:1000]->EPS=1e-8 [-10000:10000]->EPS=1e-7\nconst R INF = 1E40;\nconstexpr R PI = acos(R(-1));\ninline int sgn(const R& r){ return (r > EPS) - (r < -EPS);}\ninline int sgn(const R& a, const R &b){ return sgn(a-b); }\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n\nusing P=complex<R>;\nusing VP=vector<P>;\nusing L=struct{P s,t;};\nusing VL=vector<L>;\n\nconstexpr P O = P(0,0);\nistream& operator >> (istream& is,P& p){ R x,y;is >> x >> y; p=P(x,y); return is;}\nostream& operator << (ostream& os,P& p){ os << real(p) << \" \" << imag(p); return os;}\n\n\n// dot det\ninline R dot(P o,P a,P b){a-=o,b-=o; return real(conj(a)*b);}\ninline R det(P o,P a,P b){a-=o,b-=o; return imag(conj(a)*b);}\ninline P vec(L l){return l.t-l.s;}\n\n\n// CCW verify AOJ CGL_1_C\nenum CCW{ LEFT = 1,RIGHT = 2,BACK = 4,FRONT = 8,ON = 16};\ninline int ccw(P o,P a, P b) {\n\tif (sgn(det(o,a,b)) > 0) return LEFT;    // counter clockwise\n\tif (sgn(det(o,a,b)) < 0) return RIGHT;   // clockwise\n\tif (sgn(dot(o,a,b)) < 0) return BACK;    // b--base--a on line\n\tif (sgn(norm(a-o)-norm(b-o)) < 0) return FRONT;   // base--a--b on line\n\treturn ON;// base--b--a on line  semnet determination betwenn a and b \n}\n\n// crossing point verify AOJ CGL_2_C\nP cross(L a,L b){\n\tR s1=det(a.s,b.s,b.t);\n\tR s2=s1+det(a.t,b.t,b.s);\n\treturn a.s+s1/s2*(a.t-a.s);\n}\n\n// Polygon\n// area Verify AOJ 1100 CGL_3_A\nR area(const VP& pol){\n\tint n=pol.size();\n\tR sum=0;\n\trep(i,n) sum+=det(O,pol[i],pol[(i+1)%n]);\n\treturn abs(sum/2.0);\n}\n\n// convex_cut verify AOJ CGL_4_C\nVP convex_cut(const VP& pol,const L& l) {\n\tVP res;\n\tint n=pol.size();\n\trep(i,n){\n\t\tP a = pol[i],b=pol[(i+1)%n];\n\t\tif(ccw(l.s,l.t,a)!=RIGHT) reg(res,a);\n\t\tif((ccw(l.s,l.t,a)|ccw(l.s,l.t,b))==(LEFT|RIGHT)) reg(res,cross({a,b},l));\n\t}\n\treturn res;\n}\n\n\nL bisector(P a, P b){P mid=(a+b)/P(2,0);return L{mid, mid+(b-a)*P(0,1)};}\nVP voronoi_cell(VP pol,VP v,int s){rep(i,v.size())if(i!=s)pol=convex_cut(pol,bisector(v[s],v[i]));return pol;}\n\n\nint main(void){\n\tint n,m;\n\tcin >> n >> m;\n\tVP island(n),lord(m);\n\trep(i,n) cin >> island[i];\n\trep(i,m) cin >> lord[i];\n\n\tcout.precision(20);\n\trep(i,m) cout << fixed << area(voronoi_cell(island,lord,i)) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n    \n    const double EPS = 1e-8;\n\n    struct Point {\n        double x, y;\n        Point() {}\n        Point(double x, double y) : x(x), y(y) {}\n        Point operator+(const Point& p) const { return Point(x + p.x, y + p.y); }\n        Point operator-(const Point& p) const { return Point(x - p.x, y - p.y); }\n        Point operator*(double k) const { return Point(k * x, k * y); }\n        Point operator/(double k) const { return Point(x / k, y / k); }\n    };\n    double dot(const Point& a, const Point& b) { return a.x * b.x + a.y * b.y; }\n    double cross(const Point& a, const Point& b) { return a.x * b.y - a.y * b.x; }\n    double norm(const Point& a) { return sqrt(dot(a, a)); }\n    Point rot90(const Point& p) { return Point(-p.y, p.x); } // 反時計回りに90度回転 \n    double angle(const Point& a) { return atan2(a.y, a.x); } // x軸を反時計回りに何ラジアン回転させれば点aに乗るか\n    ostream& operator<<(ostream& os, const Point& p) { return os << \"(\" << p.x << \",\" << p.y << \")\"; }\n    istream& operator>>(istream& is, Point& p) { return is >> p.x >> p.y; }\n\n    int ccw(Point a, Point b, Point c){\n        b = b - a; c = c - a;\n        if (cross(b, c) > EPS) return +1;      // a,b,cの順に反時計周り\n        if (cross(b, c) < -EPS) return -1;     // a,b,cの順に時計周り\n        if (dot(b, c) < 0) return +2;          // c--a--b 直線\n        if (norm(b) < norm(c)) return -2;      // a--b--c 直線\n        return 0;                              // a--c--b 直線\n    }\n\n    struct Line {\n        Point a, b;\n        Line() {}\n        Line(const Point& a, const Point& b) : a(a), b(b) {}\n    };\n    ostream& operator<<(ostream& os, const Line& l) {\n        return os << \"Line(\" << l.a << \",\" << l.b << \")\";\n    }\n    Point crosspoint(const Line& s, const Line& t) {\n        double d = cross(t.b - t.a, s.b - s.a);\n        assert(abs(d) >= EPS);\n        return s.a + (s.b - s.a) * cross(t.b - t.a, t.b - s.a) / d;\n    }\n    bool parallel(const Line& s, const Line& t) { return abs(cross(s.b - s.a, t.b - t.a)) < EPS; }\n\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n\n    int N, M;\n    vector<Point> V;\n    vector<Point> L;\n    bool input() {\n        cin >> N >> M;\n        if (N == 0 && M == 0) return false;\n        V.clear(); V.resize(N);\n        L.clear(); L.resize(M);\n        for (int i = 0; i < N; i++) cin >> V[i];\n        for (int j = 0; j < M; j++) cin >> L[j];\n        return true;\n    }\n\n    Line midline(Point a, Point b) {\n        Point m = (a + b) / 2;\n        Point v = b - m;\n        return Line(m, m + rot90(v));\n    }\n\n    typedef vector<Point> Polygon;\n    double area(const Polygon& vs) {\n        if (vs.size() < 3) return 0;\n        double r = 0;\n        for (int i = 0; i < vs.size(); i++) {\n            const Point& a = vs[i];\n            const Point& b = vs[(i + 1) % vs.size()];\n            r += cross(a, b);\n        }\n        return r / 2;\n    }\n\n    struct angle_comp {\n        Point p;\n        angle_comp(Point p) : p(p) {}\n        bool operator()(Point a, Point b) {\n            return angle(a - p) < angle(b - p);\n        }\n    };\n\n    void solve() {\n        for (int i = 0; i < M; i++) {\n            vector<Point> P = V;\n            for (int j = 0; j < M; j++) {\n                if (i == j) continue;\n                Line m = midline(L[i], L[j]);\n                vector<Point> add;\n                int n = P.size();\n                for (int k = 0; k < n; k++) {\n                    Line e(P[k], P[(k + 1) % n]);\n                    if (parallel(m, e)) continue;\n                    Point p = crosspoint(m, e);\n                    if (ccw(e.a, p, e.b) == -2) {\n                        add.push_back(p);\n                    }\n                }\n                vector<Point> nP = add;\n                for (int k = 0; k < n; k++) {\n                    Line c(L[i], P[k]);\n                    if (!parallel(c, m) && ccw(L[i], crosspoint(c, m), P[k]) == -2) continue;\n                    nP.push_back(P[k]);\n                }\n                sort(nP.begin(), nP.end(), angle_comp(L[i]));\n                P = nP;\n            }\n            printf(\"%.12lf\\n\", area(P));\n        }\n    }\n}\n\nint main() {\n    while (input()) solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) (EQ((a).real(),(b).real()) && EQ((a).imag(),(b).imag()))\n\ntypedef complex<double> P;\ntypedef pair<P,P> Edge;\ntypedef long long ll;\n\nconst double PI=4*atan(1.0);\nconst int MAX_SIZE = 10000;\n\n// 内積\ndouble dot(P a, P b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n// 外積\ndouble cross(P a, P b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n// 点cが直線ab上にあるかないか\nint is_point_on_line(P a, P b, P c) {\n  return EQ( cross(b-a, c-a), 0.0 );\n}\n// 2直線の直行判定\nint is_orthogonal(P a1, P a2, P b1, P b2) {\n  return EQ( dot(a1-a2, b1-b2), 0.0 );\n}\n// 2直線の平行判定\nint is_parallel(P a1, P a2, P b1, P b2) {\n  return EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// 点a,bを通る直線と点cの間の距離\ndouble distance_l_p(P a, P b, P c) {\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// 点a,bを端点とする線分と点cとの距離\ndouble distance_ls_p(P a, P b, P c) {\n  if ( dot(b-a, c-a) < EPS ) return abs(c-a);\n  if ( dot(a-b, c-b) < EPS ) return abs(c-b);\n  return abs(cross(b-a, c-a)) / abs(b-a);\n}\n// 点が多角形の中に存在するかどうか\nbool isInPolygon(vector<P> &points,P s){\n\tif(points.size()==1)return false;\n\tvector<P> v;\n\tfor(int i=0;i<(int)points.size();i++)v.push_back(points[i]-s);\n\tint sign=0;\n\tfor(int i=1;i<=(int)v.size();i++){\n\t\tint prv=(i-1+v.size())%v.size();\n\t\tint cur=i%v.size();\n\t\tdouble c=cross(v[prv],v[cur]);\n\t\tif(EQ(c,0))continue;\n\t\telse if(sign==0){\n\t\t\tif(c>0)sign=1;\n\t\t\telse sign=-1;\n\t\t}\n\t\telse{\n\t\t\tif(sign==-1&&c>0)return false;\n\t\t\telse if(sign==1&&c<0)return false;\n\t\t}\n\t}\n\treturn true;\n}\nstruct Rec{\n\tvector<P> p;\n};\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交差判定\nint is_intersected_ls(P a1, P a2, P b1, P b2) {\n    // 線分が平行な場合は重なっていないことにする\n    if(abs(cross(a2-a1,b2-b1)) < EPS){\n        return 0;\n    }\n    return ( cross(a2-a1, b1-a1) * cross(a2-a1, b2-a1) < EPS ) &&\n        ( cross(b2-b1, a1-b1) * cross(b2-b1, a2-b1) < EPS );\n}\n// aとbの矩形が接しているかどうか(どちらかがどちからを含んでいるものもふくむ\nbool isTouchRectangle(Rec &a,Rec &b){\n\t// aの各頂点がbの中に存在しているかチェック\n\tfor(int i=0;i<4;i++)if(isInPolygon(b.p,a.p[i]))return true;\n\t// 逆\n\tfor(int i=0;i<4;i++)if(isInPolygon(a.p,b.p[i]))return true;\n\t// 各辺が他方のどれかの辺と接しているか\n\tfor(int i=0;i<4;i++){\n\t\tint curi=i;\n\t\tint prvi=(i-1+4)%4;\n\t\tfor(int j=0;j<4;j++){\n\t\t\tint curj=j;\n\t\t\tint prvj=(j-1+4)%4;\n\t\t\tif(is_intersected_ls(a.p[curi],a.p[prvi],b.p[curj],b.p[prvj]))return true;\n\t\t}\n\t}\n\treturn false;\n}\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交点計算\nP intersection_ls(P a1, P a2, P b1, P b2) {\n  P b = b2-b1;\n  double d1 = abs(cross(b, a1-b1));\n  double d2 = abs(cross(b, a2-b1));\n  double t = d1 / (d1 + d2);\n\n  return a1 + (a2-a1) * t;\n}\n// a1,a2を通る直線とb1,b2を通る直線の交差判定\nint is_intersected_l(P a1, P a2, P b1, P b2) {\n  return !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\n// a1,a2を通る直線とb1,b2を通る直線の交点計算\nP intersection_l(P a1, P a2, P b1, P b2) {\n  P a = a2 - a1; P b = b2 - b1;\n  return a1 + a * cross(b, b1-a1) / cross(b, a);\n}\n// 単位ベクトルを求める\nP normalVector(P p){\n\treturn p/abs(p);\n}\n// 法線ベクトルを求める\nP unitVector(P a){\n\treturn P(-a.imag(),a.real());\n}\n// 単位法線ベクトルを求める\nP unitNormalVector(P tmp){\n\tP e=P(-tmp.imag(),tmp.real());\n\te/=abs(e);\n\treturn e;\n}\n// 座標の回転(座標pにある点を,半時計回りにa(ラジアン)回転)\nP roundPoint(P p,double a){\n\treturn P(cos(a)*p.real()-sin(a)*p.imag(),sin(a)*p.real()+cos(a)*p.imag());\n}\n/*\n円周と線分の交差判定\n*/\nbool isCircleCrossLine(P a,P b,P c,double r){\n\tdouble d1 = abs(a-c);\n\tdouble d2 = abs(b-c);\n    // 線分が中に含まれるとき、ここのコメントアウトをはずせばtrue(交差)となる\n\t//if(d1<r&&d2<r)\n\t//\treturn true;\n\tdouble d = distance_ls_p(a,b,c);\n\treturn (EQ(d,r)||d<r);\n}\n// 三角形の内部に点があるかどうか\n// 外積の正負がすべて同じなら内部に点あり\nbool isInTriangle(P p1,P p2,P p3,P s){\n\tP a=p1-s;\n\tP b=p2-s;\n\tP c=p3-s;\n\treturn ((cross(a,b)>0&&cross(b,c)>0&&cross(c,a)>0)||(cross(a,b)<0&&cross(b,c)<0&&cross(c,a)<0));\n}\n// 矩形の中に点が存在するかどうか\nbool isInRectangle(P p1,P p2,P p3,P p4,P s){\n\tP a=p1-s;\n\tP b=p2-s;\n\tP c=p3-s;\n    P d=p4-s;\n\treturn ((cross(a,b)>0&&cross(b,c)>0&&cross(c,d)>0&&cross(d,a)>0)\n        ||(cross(a,b)<0&&cross(b,c)<0&&cross(c,d)<0&&cross(d,a)<0));\n}\n// 三角形の面積を座標から計算\ndouble calcAreaOfTriangle(P a,P b,P c){\n\treturn abs((b.real()-a.real())*(c.imag()-a.imag()) - (c.real()-a.real())*(b.imag()-a.imag()))/2;\n}\n// 与えられた円の範囲内に点が存在するかどうか\nbool isContainingDot(P c,double r,P a){\n\treturn (((c.real()-a.real())*(c.real()-a.real())\n\t\t+(c.imag()-a.imag())*(c.imag()-a.imag())<r*r)\n\t\t||EQ((c.real()-a.real())*(c.real()-a.real())\n\t\t+(c.imag()-a.imag())*(c.imag()-a.imag()),r*r));\n}\n// 多角形の面積公式\ndouble calcPolygonArea(vector<P> p){\n  double sum=0;\n  for(int i = 0; i < p.size(); i++)\n    sum+=cross(p[i],p[(i+1)%(p.size())]);\n  return sum/2;\n}\n// 2ベクトル間の角度\n// aからbへ左周りで何度か(0->2*PI)\ndouble diffAngle(P a,P b){\n    double angle=atan2(cross(a,b),dot(a,b));\n    if(angle<0)\n        return 2*PI+angle;\n    return angle;\n}\n// 2つのベクトルの重なっている部分の長さを返す\n// もし重なっていなければ0を返す\ndouble multipleLength(P a,P b,P c,P d){\n    Edge e1=make_pair(a,b);\n    Edge e2=make_pair(c,d);\n    // 平行であるかどうか\n    if(!(is_parallel(e1.first,e2.first,e1.second,e2.second)\n        &&is_parallel(e1.first,e1.second,e2.first,e2.second)))\n        return 0;\n    double dist=0;\n    // 両方乗っている\n    if(EQ(distance_ls_p(e1.first,e1.second,e2.first),0)&&EQ(distance_ls_p(e1.first,e1.second,e2.second),0))\n        dist=abs(e2.first-e2.second);\n    else if(EQ(distance_ls_p(e2.first,e2.second,e1.first),0)&&EQ(distance_ls_p(e2.first,e2.second,e1.second),0))\n        dist=abs(e1.first-e1.second);\n    else if(EQ(distance_ls_p(e1.first,e1.second,e2.first),0)){\n        // どちらが線上にあるか\n        if(EQ(distance_ls_p(e2.first,e2.second,e1.first),0))\n            dist=abs(e1.first-e2.first);\n        else\n            dist=abs(e1.second-e2.first);\n    }\n    else if(EQ(distance_ls_p(e1.first,e1.second,e2.second),0)){\n        if(EQ(distance_ls_p(e2.first,e2.second,e1.first),0))\n            dist=abs(e1.first-e2.second);\n        else\n            dist=abs(e1.second-e2.second);\n    }\n    return dist;\n}\n// 2点を通る半径rの円の中点を求める\npair<P,P> calcCircleCenterPoint(P dot1,P dot2,double r){\n    double v=abs(dot1-dot2);\n    double x = sqrt(r*r - (v/2)*(v/2));\n    // 二組の単位法線ベクトル\n    P hose[2];\n    double x1=-(dot1.imag()-dot2.imag());\n    double y1=(dot1.real() - dot2.real());\n    hose[0]=P(x1,y1);\n    double y2=-y1;\n    double x2=-x1;\n    hose[1]=P(x2,y2);\n    double dd1=abs(hose[0]);\n    double dd2=abs(hose[1]);\n    hose[0]/=dd1;hose[0]*=x;\n    hose[1]/=dd2;hose[1]*=x;\n    P tmp=(dot1+dot2);\n    tmp/=2;\n    hose[0]+=tmp;\n    hose[1]+=tmp;\n    return make_pair(hose[0],hose[1]);\n}\n// 4線分が端点以外でクロスしているかどうかを判定\nbool checkCross(const vector<Edge> &vec){\n    for(int i=0;i<vec.size();i++){\n        for(int j=i+1;j<vec.size();j++){\n            // 線分がクロスしているかどうか\n            if(is_intersected_ls(vec[i].first,vec[i].second,vec[j].first,vec[j].second)){\n                // している場合、端点以外でクロスしているなら、false\n                P p=intersection_ls(vec[i].first,vec[i].second,vec[j].first,vec[j].second);\n                if(!(EQ(p,vec[i].first)||EQ(p,vec[i].second)))\n                    return false;\n            }\n        }\n    }\n    return true;\n}\n// 引き数で与えられた4つの点が矩形を作るどうかを判定\nbool checkRec(const vector<P> &squ){\n    vector<int> v;\n    for(int i=0;i<squ.size();i++)v.push_back(i);\n    do{\n        vector<Edge> ve;\n        for(int i=0;i<4;i++)\n            ve.push_back(make_pair(squ[v[i]],squ[v[(i+1)%4]]));\n        // ここですべての線分がクロスするかどうかを計算\n        if(checkCross(ve)){\n            // 線分の長さを確認\n            if(EQ(abs(ve[0].first-ve[0].second),abs(ve[2].first-ve[2].second)))\n                if(EQ(abs(ve[1].first-ve[1].second),abs(ve[3].first-ve[3].second)))\n                    // 直行\n                    if(is_orthogonal(ve[0].first,ve[0].second,ve[1].first,ve[1].second))\n                        if(is_orthogonal(ve[2].first,ve[2].second,ve[3].first,ve[3].second))\n                        return true;\n        }\n    }while(next_permutation(v.begin(),v.end()));\n    return false;\n}\n// 引き数で与えられた4つの点が正方形を作るかどうかを判定\nbool checkSqu(const vector<P> &squ){\n    vector<int> v;\n    for(int i=0;i<squ.size();i++)v.push_back(i);\n    do{\n        vector<Edge> ve;\n        for(int i=0;i<4;i++)\n            ve.push_back(make_pair(squ[v[i]],squ[v[(i+1)%4]]));\n        // ここですべての線分がクロスするかどうかを計算\n        if(checkCross(ve)){\n            // 線分の長さを確認\n            double d=abs(ve[0].first-ve[0].second);\n            for(int i=1;i<4;i++){\n                double d2=abs(ve[i].first-ve[i].second);\n                if(!EQ(d,d2))return false;\n            }\n            // 直行確認\n            if(is_orthogonal(ve[0].first,ve[0].second,ve[1].first,ve[1].second))\n                if(is_orthogonal(ve[2].first,ve[2].second,ve[3].first,ve[3].second))\n                    return true;\n        }\n    }while(next_permutation(v.begin(),v.end()));\n    return false;\n}\n// 二円の共通接線を構成する4直線を求める(二円はお互い接したりどちらかをふくんだりしない)\nvector<pair<P,P> > calcCommonTangentialLine(P p1,double r1,P p2,double r2){\n\tvector<pair<P,P> > res;\n\tif(r1>r2){\n\t\tswap(r1,r2);\n\t\tswap(p1,p2);\n\t}\n\t// 共通外接線\n\t{\n\t\tdouble d=abs(p1-p2);\n\t\tdouble a=abs(r1-r2);\n\t\tdouble b=sqrt(d*d-a*a);\n\t\tdouble sita=acos(b/d);\n\t\tP e=normalVector(roundPoint((roundPoint((p2-p1),sita)),PI/2));\n\t\tres.push_back(make_pair(e*r1+p1,e*r2+p2));\n\t\tP e2=normalVector(roundPoint((roundPoint((p2-p1),-sita)),-PI/2));\n\t\tres.push_back(make_pair(e2*r1+p1,e2*r2+p2));\n\t}\n\t// 共通内接線\n\t{\n\t\tP cp=(r1*p1+r2*p2)/(r1+r2);\n\t\tdouble u=abs(cp-p1);\n\t\tdouble sita=acos(r1/u);\n\t\tP e=normalVector(roundPoint(cp-p1,sita));\n\t\tres.push_back(make_pair(e*r1+p1,-e*r2+p2));\n\t\tP e2=normalVector(roundPoint(cp-p1,-sita));\n\t\tres.push_back(make_pair(e2*r1+p1,-e2*r2+p2));\n\t}\n\treturn res;\n}\n/*\n  与えられた3点a,b,c,をa->b->cと進むとき\n  a->bで時計方向に折れて,b->c\n  a->bで半時計方向に折れて,b->c\n  a->bで逆を向いてaを通り越してb->c\n  a->bでそのままb->c\n  a->bで逆を向いてb->c\n  のどれであるかを判定\n*/\nint ccw(P a,P b, P c){\n  b-=a;c-=a;\n  if(cross(b,c)>0&&!EQ(cross(b,c),0))return 1;// counter clockwise\n  if(cross(b,c)<0&&!EQ(cross(b,c),0))return -1;// clockwise\n  if(dot(b,c)<0&&!EQ(dot(b,c),0))return 2; // c-a-b on line\n  if(!EQ(abs(b),abs(c))&&abs(b)<abs(c))return -2; // a-b-c on line\n  return 0;\n}\n// 凸多角形の切断を行う\n// lineのfirst側から見て左の多角形が返る\n// 多角形は上が+y,右が+xの座標系で座標を時計周りに格納したvectorで表す\n// lineは基本的にmakeDivisorで作成\nvector<P> convex_cut(vector<P> polygon,pair<P,P> line){\n  vector<P> resPolygon;\n  int n=polygon.size();\n  for(int i=0;i<n;i++){\n    P A=polygon[i];\n    P B=polygon[(i+1)%n];\n    if(ccw(line.first,line.second,A)!=-1)\n      resPolygon.push_back(A);\n    if(ccw(line.first,line.second,A)*ccw(line.first,line.second,B)<0)\n      resPolygon.push_back(intersection_l(A,B,line.first,line.second));\n  }\n  return resPolygon;\n}\n// convex_cutの補助関数\n// a側の凸多角形を残すような切断ラインを作成\npair<P,P> makeDivisor(P a, P b){\n  P mid=(a+b);mid/=2;\n  P base=unitNormalVector(b-a);\n  base*=-1000000;\n  P p1=base;p1+=mid;\n  base*=-1;\n  P p2=base;p2+=mid;\n  return make_pair(p1,p2);\n}\n\nP cp[100];\nint N,M;\nint main(){\n  while(cin>>N>>M&&(N|M)){\n    double x,y;\n    vector<P> initPol;\n    for(int i=0;i<N;i++){\n      cin>>x>>y;\n      initPol.push_back(P(x,y));\n    }\n    for(int i=0;i<M;i++){\n      cin>>x>>y;\n      cp[i]=P(x,y);\n    }\n    // 各城ごとにボロノイ領域を求める\n    for(int i=0;i<M;i++){\n      vector<P> curPol=initPol;\n      for(int j=0;j<M;j++){\n\tif(i==j)continue;\n\tcurPol=convex_cut(curPol,makeDivisor(cp[i],cp[j]));\n      }\n      printf(\"%.10f\\n\",calcPolygonArea(curPol));\n    }\n  }\n  // while(cin>>xs[0]>>ys[0]>>xs[1]>>ys[1]>>xs[2]>>ys[2]&&(xs[0]|xs[1]|xs[2]|ys[0]|ys[1]|ys[2])){\n  //   for(int i=0;i<3;i++)ps[i]=P(xs[i],ys[i]);a\n  //   vector<P> init;\n  //   init.push_back(P(0,0));init.push_back(P(0,10000));\n  //   init.push_back(P(10000,10000));init.push_back(P(10000,0));\n  //   init=convex_cut(init,makeDivisor(ps[0],ps[1]));\n  //   init=convex_cut(init,makeDivisor(ps[0],ps[2]));\n  //   double S=abs(calcPolygonArea(init));\n  //   printf(\"%d %.10f\\n\",cnt,S/100000000);\n  //   cnt++;\n  // }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\nAlgorithm to determine the Voronoi diagrams of a set of points within a convex polygon that bounds the plane.\n\nTime complexity: O((N + M)^2)\nSpace complexity: O(N + M)\n*/\n\n#include <cmath>\n\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n\n#define x first\n#define y second\n\nusing namespace std;\n\ntypedef pair<double, double> Point;\n\nconst double EPS = 1e-9;\nconst double PI = acos(-1.0);\n\nclass Line {\n  public:\n    double a, b, c;\n\n    Line(const double _a = 0.0, const double _b = 0.0, const double _c = 0.0):\n      a(_a),\n      b(_b),\n      c(_c) {}\n\n    Line(const Point &p1, const Point &p2):\n      a(p1.y - p2.y),\n      b(p2.x - p1.x),\n      c(p1.x * p2.y - p1.y * p2.x) {}\n};\n\nvector<Point> Plane, Points;\nvector<double> Areas;\n\ninline double Det(const Point &a, const Point &b, const Point &c) {\n    return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\n}\n\ninline double Alpha(const Point &a, const Point &b, const Point &c) {\n    Point u = Point(a.x - b.x, a.y - b.y), v = Point(c.x - b.x, c.y - b.y);\n    double alpha = acos((u.x * v.x + u.y * v.y) / sqrt((u.x * u.x + u.y * u.y) * (v.x * v.x + v.y * v.y)));\n    if (Det(a, b, c) < -EPS)\n        alpha += 2 * PI;\n    return alpha;\n}\n\ninline Point Dualize(const Line &l) {\n    if (abs(l.c) < EPS)\n        return Point(0.0, 0.0);\n    return Point(l.a / l.c, l.b / l.c);\n}\n\ninline Line Dualize(const Point &p) {\n    return Line(p.x, p.y, 0.0);\n}\n\ninline Point Translate(const Point &p, const Point &shift) {\n    return Point(p.x + shift.x, p.y + shift.y);\n}\n\ninline Line Translate(const Line &l, const Point &shift) {\n    return Line(l.a, l.b, l.c - l.a * shift.x - l.b * shift.y);\n}\n\nvector<Point> GetConvexHull(vector<Point> points) {\n    int n = int(points.size()), origin = 0;\n    for (int i = 1; i < n; ++i)\n        if (points[i] < points[origin])\n            origin = i;\n    swap(points[0], points[origin]);\n    vector<Point> hull;\n    hull.push_back(points[0]);\n    hull.push_back(points[1]);\n    for (int i = 2; i < n; ++i)\n        if (Det(hull[0], hull[1], points[i]) < -EPS)\n            hull[1] = points[i];\n    do {\n        int next = -1;\n        double alpha = -2 * PI;\n        for (int i = 0; i < n; ++i) {\n            double currentAlpha = Alpha(hull[int(hull.size()) - 2], hull[int(hull.size()) - 1], points[i]);\n            if (currentAlpha > alpha) {\n                next = i;\n                alpha = currentAlpha;\n            }\n        }\n        hull.push_back(points[next]);\n    } while (hull.back() != hull.front());\n    hull.pop_back();\n    return hull;\n}\n\nvector< vector<Point> > GetVoronoiDiagrams(const vector<Point> &plane, const vector<Point> &points) {\n    vector< vector<Point> > voronoiDiagrams = vector< vector<Point> >(int(points.size()), vector<Point>());\n    for (int i = 0; i < int(points.size()); ++i) {\n        Point shiftTo = Point(-points[i].x, -points[i].y), shiftFrom = points[i];\n        vector<Point> dualizedLines;\n        for (int j = 0; j < int(plane.size()); ++j)\n            dualizedLines.push_back(Dualize(Translate(Line(plane[j], plane[(j + 1) % int(plane.size())]), shiftTo)));\n        for (int j = 0; j < int(points.size()); ++j) {\n            if (i != j) {\n                Point a = points[i], b = points[j];\n                dualizedLines.push_back(Dualize(Translate(Line(2 * (b.x - a.x), 2 * (b.y - a.y), a.x * a.x + a.y * a.y - b.x * b.x - b.y * b.y), shiftTo)));\n            }\n        }\n        vector<Point> hull = GetConvexHull(dualizedLines);\n        for (int j = 0; j < int(hull.size()); ++j)\n            voronoiDiagrams[i].push_back(Translate(Dualize(Line(hull[j], hull[(j + 1) % int(hull.size())])), shiftFrom));\n    }\n    return voronoiDiagrams;\n}\n\ninline double Area(const vector<Point> &polygon) {\n    double area = 0.0;\n    for (int i = 0; i < int(polygon.size()); ++i)\n        area += polygon[i].x * polygon[(i + 1) % int(polygon.size())].y - polygon[(i + 1) % int(polygon.size())].x * polygon[i].y;\n    area *= 0.5;\n    return abs(area);\n}\n\nvoid Solve() {\n    vector< vector<Point> > voronoiDiagrams = GetVoronoiDiagrams(Plane, Points);\n    Areas = vector<double>(int(Points.size()), 0.0);\n    for (int i = 0; i < int(Points.size()); ++i)\n        Areas[i] = Area(voronoiDiagrams[i]);\n}\n\nbool Read() {\n    int m, n;\n    cin >> m >> n;\n    if (m == 0 && n == 0)\n        return false;\n    Plane = vector<Point>(m);\n    for (int i = 0; i < m; ++i)\n        cin >> Plane[i].x >> Plane[i].y;\n    Points = vector<Point>(n);\n    for (int i = 0; i < n; ++i)\n        cin >> Points[i].x >> Points[i].y;\n    return true;\n}\n\nvoid Print() {\n    for (int i = 0; i < int(Points.size()); ++i)\n        cout << fixed << setprecision(9) << Areas[i] << \"\\n\";\n}\n\nint main() {\n    while (Read()) {\n        Solve();\n        Print();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Enjoy your stay.\n\n#include <bits/stdc++.h>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(auto it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define mt make_tuple\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)(x).size())\n\nusing namespace std;\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<ll,ll> pi;\ntypedef stringstream sst;\ntypedef vector<ll> vi;\n\n// geometry library from hos\n\nconst double PI = acos(-1);\n\nint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\n\nstruct Pt{\n\tdouble x, y;\n\tPt() {}\n\tPt(double x, double y) : x(x), y(y) {}\n\tPt operator+(const Pt &a) const { return Pt(x + a.x, y + a.y); }\n\tPt operator-(const Pt &a) const { return Pt(x - a.x, y - a.y); }\n\tPt operator*(const Pt &a) const { return Pt(x * a.x - y * a.y, x * a.y + y * a.x); }\n\tPt operator-() const { return Pt(-x, -y); }\n\tPt operator*(const double &k) const { return Pt(x * k, y * k); }\n\tPt operator/(const double &k) const { return Pt(x / k, y / k); }\n\tdouble abs() const { return sqrt(x * x + y * y); }\n\tdouble abs2() const { return x * x + y * y; }\n\tdouble arg() const { return atan2(y, x); }\n\tdouble dot(const Pt &a) const { return x * a.x + y * a.y; }\n\tdouble det(const Pt &a) const { return x * a.y - y * a.x; }\n\tbool operator<(const Pt &a) const { return x < a.x || x == a.x && y < a.y; }\n\tbool operator==(const Pt &a) const { return x == a.x && y == a.y; }\n\tbool operator!=(const Pt &a) const { return x != a.x || y != a.y; }\n};\n\nostream &operator<<(ostream &os, const Pt &a) { os << \"(\" << a.x << \", \" << a.y << \")\"; return os; }\n\ndouble tri(const Pt &a, const Pt &b, const Pt &c) { return (b - a).det(c - a); }\n\nint iSP(Pt a, Pt b, Pt c) {\n\tint s = sig((b - a).det(c - a));\n\tif (s) return s; // +1 or -1\n\tif (sig((b - a).dot(c - a)) < 0) return -2; // c-a-b\n\tif (sig((a - b).dot(c - b)) < 0) return +2; // a-b-c\n\treturn 0;\n}\nint iLL(Pt a, Pt b, Pt c, Pt d) {\n\tif (sig((b - a).det(d - c))) return 1; // intersect\n\tif (sig((b - a).det(c - a))) return 0; // parallel\n\treturn -1; // correspond\n}\nbool iLS(Pt a, Pt b, Pt c, Pt d) {\n\treturn (sig(tri(a, b, c)) * sig(tri(a, b, d)) <= 0);\n}\nbool iSS(Pt a, Pt b, Pt c, Pt d) {\n\treturn (iSP(a, b, c) * iSP(a, b, d) <= 0 && iSP(c, d, a) * iSP(c, d, b) <= 0);\n}\nbool iSSstrict(Pt a, Pt b, Pt c, Pt d) {\n\treturn (sig(tri(a, b, c)) * sig(tri(a, b, d)) < 0 && sig(tri(c, d, a)) * sig(tri(c, d, b)) < 0);\n}\nPt pLL(Pt a, Pt b, Pt c, Pt d) { // intersection\n\tb = b - a; d = d - c; return a + b * (c - a).det(d) / b.det(d);\n}\ndouble dLP(Pt a, Pt b, Pt c) {\n\treturn abs(tri(a, b, c)) / (b - a).abs();\n}\ndouble dSP(Pt a, Pt b, Pt c) {\n\tif (sig((b - a).dot(c - a)) <= 0) return (c - a).abs();\n\tif (sig((a - b).dot(c - b)) <= 0) return (c - b).abs();\n\treturn abs(tri(a, b, c)) / (b - a).abs();\n}\ndouble dLL(Pt a, Pt b, Pt c, Pt d) {\n\treturn iLL(a, b, c, d) ? 0 : dLP(a, b, c);\n}\ndouble dLS(Pt a, Pt b, Pt c, Pt d) {\n\treturn iLS(a, b, c, d) ? 0 : min(dLP(a, b, c), dLP(a, b, d));\n}\ndouble dSS(Pt a, Pt b, Pt c, Pt d) {\n\treturn iSS(a, b, c, d) ? 0 : min(min(dSP(a, b, c), dSP(a, b, d)), min(dSP(c, d, a), dSP(c, d, b)));\n}\n\nint iCC(Pt a, double r, Pt b, double s) {\n\tdouble d = (b - a).abs();\n\tif (sig(d) == 0 && sig(r - s) == 0) return -1; // correspond\n\tif (sig(r - s - d) > 0) return +2; // r > s\n\tif (sig(s - r - d) > 0) return -2; // s > r\n\treturn (sig(r + s - d) >= 0) ? 1 : 0;\n}\nbool iCS(Pt a, double r, Pt b, Pt c) {\n\treturn (sig(r - dSP(b, c, a)) >= 0 && sig(r - max((b - a).abs(), (c - a).abs())) <= 0);\n}\npair<Pt,Pt> pCC(Pt a, double r, Pt b, double s) {\n\tdouble d = (b - a).abs();\n\tdouble x = (d * d + r * r - s * s) / (d * 2);\n\tPt e = (b - a) / d, w = e * Pt(0, 1) * sqrt(max(r * r - x * x, 0.0));\n\treturn mp(a + e * x - w, a + e * x + w);\n}\npair<Pt,Pt> pCL(Pt a, double r, Pt b, Pt c) {\n\tPt h = b + (c - b) * (c - b).dot(a - b) / (c - b).abs2();\n\t// perp(b, c, a)\n\tdouble d = (h - a).abs();\n\tdouble y = sqrt(max(r * r - d * d, 0.0));\n\tPt e = (c - b) / (c - b).abs();\n\treturn mp(h - e * y, h + e * y);\n}\npair<Pt,Pt> tCP(Pt a, double r, Pt b) {\n\tdouble d2 = (b - a).abs2();\n\tdouble x = sqrt(max(d2 - r * r, 0.0));\n\tPt h = a + (b - a) * (r * r / d2);\n\tPt w = (b - a) * Pt(0, 1) * (x * r / d2);\n\treturn mp(h - w, h + w);\n}\ndouble aCC(Pt a, double r, Pt b, double s) {\n\tdouble d = (a - b).abs();\n\tif (sig(r - s - d) >= 0) return s * s * PI;\n\tif (sig(s - r - d) >= 0) return r * r * PI;\n\tif (sig(r + s - d) <= 0) return 0;\n\tdouble x = (d * d + r * r - s * s) / (d * 2);\n\tdouble h = sqrt(r * r - x * x);\n\treturn r * r * atan2(h, x) + s * s * atan2(h, d - x) - d * h;\n}\n\nint convexHull(int n, Pt p[], Pt q[]){ // can replace sig&tri, <= with iSP, <\n\tint m=0, i, r;\n\tsort(p, p+n);\n\tfor(i=0;        i<n;  q[m++]=p[i++]) for(; m>1 && sig(tri(q[m-2], q[m-1], p[i])) <= 0; --m);\n\tfor(i=n-2, r=m; i>=0; q[m++]=p[i--]) for(; m>r && sig(tri(q[m-2], q[m-1], p[i])) <= 0; --m);\n\treturn m-1;\n}\n\nint convexCut(int n, Pt p[], Pt a, Pt b, Pt q[]){\n\tint m=0, i;\n\tp[n] = p[0];\n\trep(i, n){\n\t\tif(sig(tri(a, b, p[i])) >= 0) q[m++] = p[i];\n\t\tif(sig(tri(a, b, p[i])) * sig(tri(a, b, p[i+1])) < 0) q[m++] = pLL(a, b, p[i], p[i+1]);\n\t}\n\tq[m] = q[0];\n\treturn m;\n}\n\nint sGP(int n, Pt p[], Pt a) {\n\tint side = -1, i;\n\tp[n] = p[0];\n\tfor (i = 0; i < n; ++i) {\n\t\tPt p0 = p[i] - a, p1 = p[i + 1] - a;\n\t\tif (sig(p0.det(p1)) == 0 && sig(p0.dot(p1)) <= 0) return 0;\n\t\tif (p0.y > p1.y) swap(p0, p1);\n\t\tif (sig(p0.y) <= 0 && 0 < sig(p1.y) && sig(p0.det(p1)) > 0) side = -side;\n\t}\n\treturn side;\n}\nint sVP(int n, Pt p[], Pt a) {\n\tPt o = (p[0] + p[n / 2]) / 2;\n\tint lo = 0, ho = n, fl = sig(tri(o, p[lo], a));\n\tp[n] = p[0];\n\tfor (; lo + 1 < ho; ) {\n\t\tint mo = (lo + ho) / 2, fm = sig(tri(o, p[mo], a));\n\t\t(fl - fm - sig(tri(o, p[lo], p[mo])) < 0) ? (lo = mo, fl = fm) : ho = mo;\n\t}\n\treturn sig(tri(p[lo], p[ho], a));\n}\n\nint sAP(Pt a, Pt b, Pt c) {\n\treturn sig(a.det(c)) - sig(b.det(c)) - sig(a.det(b));\n}\n\n// end of library\n\nint N,M;\nPt l[11],c[11];\n\nint main2(){\n\trep(i,M){\n\t\tint n=N;\n\t\tPt p[33],q[33];\n\t\trep(j,n)p[j]=l[j];\n\t\trep(j,M)if(j!=i){\n\t\t\tPt mid = (c[i]+c[j])/2;\n\t\t\tint m = convexCut(n,p,mid,mid+(c[j]-c[i])*Pt(0,1),q);\n\t\t\tn=m;\n\t\t\trep(i,n)p[i]=q[i];\n\t\t}\n\t\tdouble res=0;\n\t\trep(i,n)res+=p[i].det(p[(i+1)%n]);\n\t\tcout<<setprecision(16)<<res/2<<endl;\n\t}\n\treturn 0;\n}\n\nint main(){\n\twhile(cin>>N>>M,N){\n\t\trep(i,N)cin>>l[i].x>>l[i].y;\n\t\trep(i,M)cin>>c[i].x>>c[i].y;\n\t\tmain2();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(arg),key)-begin(arg)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \nusing namespace std;\n \ntemplate<class T>void reg(vector<T> &ary,const T &elem){ary.emplace_back(elem);}\ntemplate<class T>bool chmin(T &a, const T &b) {return (b<a)?(a=b,1):0;}\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\n \nusing R=long double; // __float128\nconst R EPS = 1E-11; // [-1000:1000]->EPS=1e-8 [-10000:10000]->EPS=1e-7\nconst R INF = 1E40;\nconstexpr R PI = acos(R(-1));\ninline int sgn(const R& r){ return (r > EPS) - (r < -EPS);}\ninline int sgn(const R& a, const R &b){ return sgn(a-b); }\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n \nusing P=complex<R>;\nusing VP=vector<P>;\nusing L=struct{P s,t;};\nusing VL=vector<L>;\nusing C=struct{P c;R r;};\nusing VC=vector<C>;\n \nconstexpr P O = P(0,0);\nistream& operator >> (istream& is,P& p){ R x,y;is >> x >> y; p=P(x,y); return is;}\nostream& operator << (ostream& os,P& p){ os << real(p) << \" \" << imag(p); return os;}\n \nnamespace std{\n    bool operator <  (const P& a,const P& b){ return sgn(real(a-b))?real(a-b)<0:sgn(imag(a-b))<0;}\n    bool operator == (const P& a,const P& b){ return sgn(real(a-b))==0 && sgn(imag(a-b))==0;}\n}\n \ninline bool cmp_x(const P& p,const P& q){return sgn(real(p-q))?real(p)<real(q):sgn(imag(p-q));}\ninline bool cmp_y(const P& a, const P& b){return sgn(imag(a-b)) ? imag(a-b)<0 : sgn(real(a-b))<0;}\ninline bool cmp_a(const P& a, const P& b){return sgn(arg(a)-arg(b)) ? arg(a)-arg(b)<0 : sgn(norm(a)-norm(b))<0;}\nbool operator <  (const L& a,const L& b){ return a.s==b.s?a.t<b.t:a.s<b.s;}\nbool operator == (const L& a,const L& b){ return a.s==b.s&&a.t==b.t;}\n \n//?????? dot ?????? det\ninline R dot(P o,P a,P b){a-=o,b-=o; return real(conj(a)*b);}\ninline R det(P o,P a,P b){a-=o,b-=o; return imag(conj(a)*b);}\ninline P vec(L l){return l.t-l.s;}\n\nenum CCW{ LEFT = 1,RIGHT = 2,BACK = 4,FRONT = 8,ON = 16};\ninline int ccw(P o,P a, P b) {//???a??¨???b???????????????????????????\n    if (sgn(det(o,a,b)) > 0) return LEFT;    // counter clockwise\n    if (sgn(det(o,a,b)) < 0) return RIGHT;   // clockwise\n    if (sgn(dot(o,a,b)) < 0) return BACK;    // b--base--a on line\n    if (sgn(norm(a-o)-norm(b-o)) < 0) return FRONT;   // base--a--b on line\n    return ON;// base--b--a on line  a??¨b????????????????????????\n}\n\nR area(const VP& pol){\n    int n=pol.size();\n    R sum=0;\n    rep(i,n) sum+=det(O,pol[i],pol[(i+1)%n]);\n    return abs(sum/2.0);\n}\n\nP cross(L a,L b){\n    R s1=det(a.s,b.s,b.t);\n    R s2=s1+det(a.t,b.t,b.s);\n    return a.s+s1/s2*(a.t-a.s);\n}\n\nVP convex_cut(const VP& pol,const L& l) {\n    VP res;\n    int n=pol.size();\n    rep(i,n){\n        P a = pol[i],b=pol[(i+1)%n];\n        if(ccw(l.s,l.t,a)!=RIGHT) reg(res,a);\n        if((ccw(l.s,l.t,a)|ccw(l.s,l.t,b))==(LEFT|RIGHT)) reg(res,cross({a,b},l));\n    }\n    return res;\n}\n\nint main(void){\n    for(int n, m; cin >> n >> m, n;){\n        VP island(n);\n        for(auto & e : island) cin >> e;\n\n        VP castles(m);\n        for(auto & e : castles) cin >> e;\n\n        vector<R> res(n);\n        rep(i, m){\n            VP pol = island;\n\n            rep(j, m){\n                if(j == i) continue;\n                P mid = (castles[i] + castles[j]) / (R)2.0;\n                P t = mid + (castles[j] - castles[i]) * P(0, 1);\n                pol = convex_cut(pol, {mid, t});\n            }\n\n            res[i] = area(pol);\n        }\n\n        for(auto & e : res){\n            cout.precision(20);\n            cout << fixed << e << endl;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\nusing namespace std;\n\ntemplate<class T>void reg(vector<T> &ary,const T &elem){ary.emplace_back(elem);}\n\nusing R=long double; \nconst R EPS = 1E-11;\nconst R INF = 1E40;\nconstexpr R PI = acos(R(-1));\ninline int sgn(const R& r){ return (r > EPS) - (r < -EPS);}\ninline int sgn(const R& a, const R &b){ return sgn(a-b); }\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n\nusing P=complex<R>;\nusing VP=vector<P>;\nusing L=struct{P s,t;};\nusing VL=vector<L>;\n\nconstexpr P O = P(0,0);\nistream& operator >> (istream& is,P& p){ R x,y;is >> x >> y; p=P(x,y); return is;}\nostream& operator << (ostream& os,P& p){ os << real(p) << \" \" << imag(p); return os;}\n\ninline R dot(P o,P a,P b){a-=o,b-=o; return real(conj(a)*b);}\ninline R det(P o,P a,P b){a-=o,b-=o; return imag(conj(a)*b);}\ninline P vec(L l){return l.t-l.s;}\n\n\nenum CCW{ LEFT = 1,RIGHT = 2,BACK = 4,FRONT = 8,ON = 16};\ninline int ccw(P o,P a, P b) {\n\tif (sgn(det(o,a,b)) > 0) return LEFT;\n\tif (sgn(det(o,a,b)) < 0) return RIGHT;\n\tif (sgn(dot(o,a,b)) < 0) return BACK;\n\tif (sgn(norm(a-o)-norm(b-o)) < 0) return FRONT;\n\treturn ON;\n}\n\nP cross(L a,L b){\n\tR s1=det(a.s,b.s,b.t);\n\tR s2=s1+det(a.t,b.t,b.s);\n\treturn a.s+s1/s2*(a.t-a.s);\n}\n\nR area(const VP& pol){\n\tint n=pol.size();\n\tR sum=0;\n\trep(i,n) sum+=det(O,pol[i],pol[(i+1)%n]);\n\treturn abs(sum/2.0);\n}\n\nVP convex_cut(const VP& pol,const L& l) {\n\tVP res;\n\tint n=pol.size();\n\trep(i,n){\n\t\tP a = pol[i],b=pol[(i+1)%n];\n\t\tif(ccw(l.s,l.t,a)!=RIGHT) reg(res,a);\n\t\tif((ccw(l.s,l.t,a)|ccw(l.s,l.t,b))==(LEFT|RIGHT)) reg(res,cross({a,b},l));\n\t}\n\treturn res;\n}\n\nL bisector(P a, P b){P mid=(a+b)/P(2,0);return L{mid, mid+(b-a)*P(0,1)};}\nVP voronoi_cell(VP pol,VP v,int s){rep(i,v.size())if(i!=s)pol=convex_cut(pol,bisector(v[s],v[i]));return pol;}\n\nint main(void){\n\tint n,m;\n\twhile(cin >> n >> m,n){\n\t\tVP island(n),lord(m);\n\t\trep(i,n) cin >> island[i];\n\t\trep(i,m) cin >> lord[i];\n\n\t\tcout.precision(20);\n\t\trep(i,m) cout << fixed << area(voronoi_cell(island,lord,i)) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n\n#define x first\n#define y second\n\nusing namespace std;\n\ntypedef pair<double, double> Point;\n\nconst double EPS = 1e-9;\nconst double PI = acos(-1.0);\n\nclass Line {\n  public:\n    double a, b, c;\n\n    Line(const double _a = 0.0, const double _b = 0.0, const double _c = 0.0):\n      a(_a),\n      b(_b),\n      c(_c) {}\n\n    Line(const Point &p1, const Point &p2):\n      a(p1.y - p2.y),\n      b(p2.x - p1.x),\n      c(p1.x * p2.y - p1.y * p2.x) {}\n};\n\nvector<Point> Plane, Points;\nvector<double> Areas;\n\ninline double Det(const Point &a, const Point &b, const Point &c) {\n    return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\n}\n\ninline double Alpha(const Point &a, const Point &b, const Point &c) {\n    Point u = Point(a.x - b.x, a.y - b.y), v = Point(c.x - b.x, c.y - b.y);\n    double alpha = acos((u.x * v.x + u.y * v.y) / sqrt((u.x * u.x + u.y * u.y) * (v.x * v.x + v.y * v.y)));\n    if (Det(a, b, c) < -EPS)\n        alpha += 2 * PI;\n    return alpha;\n}\n\ninline Point Dualize(const Line &l) {\n    if (abs(l.c) < EPS)\n        return Point(0.0, 0.0);\n    return Point(l.a / l.c, l.b / l.c);\n}\n\ninline Line Dualize(const Point &p) {\n    return Line(p.x, p.y, 0.0);\n}\n\ninline Point Translate(const Point &p, const Point &shift) {\n    return Point(p.x + shift.x, p.y + shift.y);\n}\n\ninline Line Translate(const Line &l, const Point &shift) {\n    return Line(l.a, l.b, l.c - l.a * shift.x - l.b * shift.y);\n}\n\nvector<Point> GetConvexHull(vector<Point> points) {\n    int n = int(points.size()), origin = 0;\n    for (int i = 1; i < n; ++i)\n        if (points[i] < points[origin])\n            origin = i;\n    swap(points[0], points[origin]);\n    vector<Point> hull;\n    hull.push_back(points[0]);\n    hull.push_back(points[1]);\n    for (int i = 2; i < n; ++i)\n        if (Det(hull[0], hull[1], points[i]) < -EPS)\n            hull[1] = points[i];\n    do {\n        int next = -1;\n        double alpha = -2 * PI;\n        for (int i = 0; i < n; ++i) {\n            double currentAlpha = Alpha(hull[int(hull.size()) - 2], hull[int(hull.size()) - 1], points[i]);\n            if (currentAlpha > alpha) {\n                next = i;\n                alpha = currentAlpha;\n            }\n        }\n        hull.push_back(points[next]);\n    } while (hull.back() != hull.front());\n    hull.pop_back();\n    return hull;\n}\n\nvector< vector<Point> > GetVoronoiDiagrams(const vector<Point> &plane, const vector<Point> &points) {\n    vector< vector<Point> > voronoiDiagrams = vector< vector<Point> >(int(points.size()), vector<Point>());\n    for (int i = 0; i < int(points.size()); ++i) {\n        Point shiftTo = Point(-points[i].x, -points[i].y), shiftFrom = points[i];\n        vector<Point> dualizedLines;\n        for (int j = 0; j < int(plane.size()); ++j)\n            dualizedLines.push_back(Dualize(Translate(Line(plane[j], plane[(j + 1) % int(plane.size())]), shiftTo)));\n        for (int j = 0; j < int(points.size()); ++j) {\n            if (i != j) {\n                Point a = points[i], b = points[j];\n                dualizedLines.push_back(Dualize(Translate(Line(2 * (b.x - a.x), 2 * (b.y - a.y), a.x * a.x + a.y * a.y - b.x * b.x - b.y * b.y), shiftTo)));\n            }\n        }\n        vector<Point> hull = GetConvexHull(dualizedLines);\n        for (int j = 0; j < int(hull.size()); ++j)\n            voronoiDiagrams[i].push_back(Translate(Dualize(Line(hull[j], hull[(j + 1) % int(hull.size())])), shiftFrom));\n    }\n    return voronoiDiagrams;\n}\n\ninline double Area(const vector<Point> &polygon) {\n    double area = 0.0;\n    for (int i = 0; i < int(polygon.size()); ++i)\n        area += polygon[i].x * polygon[(i + 1) % int(polygon.size())].y - polygon[(i + 1) % int(polygon.size())].x * polygon[i].y;\n    area *= 0.5;\n    return abs(area);\n}\n\nvoid Solve() {\n    vector< vector<Point> > voronoiDiagrams = GetVoronoiDiagrams(Plane, Points);\n    Areas = vector<double>(int(Points.size()), 0.0);\n    for (int i = 0; i < int(Points.size()); ++i)\n        Areas[i] = Area(voronoiDiagrams[i]);\n}\n\nbool Read() {\n    int m, n;\n    cin >> m >> n;\n    if (m == 0 && n == 0)\n        return false;\n    Plane = vector<Point>(m);\n    for (int i = 0; i < m; ++i)\n        cin >> Plane[i].x >> Plane[i].y;\n    Points = vector<Point>(n);\n    for (int i = 0; i < n; ++i)\n        cin >> Points[i].x >> Points[i].y;\n    return true;\n}\n\nvoid Print() {\n    for (int i = 0; i < int(Points.size()); ++i)\n        cout << fixed << setprecision(9) << Areas[i] << \"\\n\";\n}\n\nint main() {\n    while (Read()) {\n        Solve();\n        Print();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <array>\nusing namespace std;\n\nconst double EPS = 1e-10;\nconst double INF = 1e12;\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n#define X real()\n#define Y imag()\n\ntypedef complex<double> P;\ntypedef vector<P> VP;\nstruct L : array<P, 2>{\n    L(const P& a, const P& b){ at(0)=a; at(1)=b; }\n    L(){}\n};\nnamespace std{\n    bool operator < (const P& a, const P& b){\n        return (a.X!=b.X) ? a.X<b.X : a.Y<b.Y;\n    }\n    bool operator == (const P& a, const P& b){\n        return abs(a-b) < EPS;\n    }\n}\n\ndouble dot(P a, P b){\n    return (conj(a)*b).X;\n}\ndouble cross(P a, P b){\n    return (conj(a)*b).Y;\n}\nint ccw(P a, P b, P c){\n    b -= a;\n    c -= a;\n    if(cross(b,c) > EPS) return +1; //ccw\n    if(cross(b,c) < -EPS) return -1; //cw\n    if(dot(b,c) < -EPS) return +2; //c-a-b\n    if(abs(c)-abs(b) > EPS) return -2; //a-b-c\n    return 0; //a-c-b\n}\n\nbool intersectLS(const L& l, const L& s){\n    return cross(l[1]-l[0], s[0]-l[0])*\n        cross(l[1]-l[0], s[1]-l[0]) < EPS;\n}\nbool intersectSS(const L& a, const L& b){\n    return ( ccw(a[0],a[1],b[0]) *ccw(a[0],a[1],b[1]) <= 0 ) &&\n        ( ccw(b[0],b[1],a[0]) *ccw(b[0],b[1],a[1]) <= 0 );\n}\nbool intersectSP(const L& s, const P &p){\n    return abs(cross(s[0]-p, s[1]-p))<EPS  && dot(s[0]-p, s[1]-p)<EPS;\n}\n\nP projection(const L& l, const P& p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1]-l[0], m[1]-m[0]);\n  double B = cross(l[1]-l[0], l[1]-m[0]);\n  return m[0] + B/A *(m[1]-m[0]);\n}\n\nbool isParallel(const P &a, const P &b){\n    return abs(cross(a,b)) < EPS;\n}\nbool isParallel(const L &a, const L &b){\n    return isParallel(a[1]-a[0], b[1]-b[0]);\n}\n\ndouble getarea(const VP &poly){\n    double ret = 0;\n    for (int i=0; i<(int)poly.size(); i++){ \n        ret += cross(poly[i], poly[(i+1)%poly.size()]);\n    }\n    return ret*0.5;\n}\n\nint in_poly(const P &p, const VP &poly){\n    int n = poly.size();\n    int ret = -1;\n    for(int i=0; i<n; i++){\n        P a = poly[i]-p;\n        P b = poly[(i+1)%n]-p;\n        if(a.Y > b.Y) swap(a,b);\n        if(intersectSP(L(a,b), P(0,0))) return 0;\n        if(a.Y<=0 && b.Y>0 && cross(a,b)<0) ret = 1-ret;\n    }\n    return ret;\n}\n\nVP convex(VP v){\n    VP ret;\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(), v.end()), v.end());\n    int n = v.size();\n    for(int i=0; i<n; i++){\n        while((int)ret.size()>1 && cross(ret.back()-ret[ret.size()-2], v[i]-ret.back()) < EPS){\n            ret.pop_back();\n        }\n        ret.push_back(v[i]);\n    }\n    int t = ret.size();\n    for(int i=n-2; i>=0; i--){\n        while((int)ret.size()>t && cross(ret.back()-ret[ret.size()-2], v[i]-ret.back()) < EPS){\n            ret.pop_back();\n        }\n        ret.push_back(v[i]);\n    }\n    if((int)ret.size() > 1) ret.pop_back();\n    return ret;\n}\n\nVP convex_intersect(VP &a, VP &b){\n\tVP plist;\n\tint n=a.size(), m=b.size();\n\tfor(int r=0; r<2; r++){\n\t\tfor(int i=0; i<n; i++){\n\t\t\tif(in_poly(a[i], b) >= 0){\n\t\t\t\tplist.push_back(a[i]);\n\t\t\t}\n\t\t}\n\t\tswap(n, m);\n\t\tswap(a, b);\n\t}\n\tfor(int i=0; i<n; i++){\n\t\tfor(int j=0; j<m; j++){\n\t\t\tL la(a[i], a[(i+1)%n]), lb(b[j], b[(j+1)%m]);\n\t\t\tif(!isParallel(la, lb) && intersectSS(la, lb)){\n\t\t\t\tplist.push_back(crosspointLL(la, lb));\n\t\t\t}\n\t\t}\n\t}\n\treturn convex(plist);\n}\n\nVP convex_cut(VP &v, L l){\n\tVP plist;\n\tint n=v.size();\n\tfor(int i=0; i<n; i++){\n\t\tif(ccw(l[0], l[1], v[i])!=-1){\n\t\t\tplist.push_back(v[i]);\n\t\t\t//cout << \"v\" << i << \" \" << v[i] << endl;\n\t\t}\n\t\tL e(v[i], v[(i+1)%n]);\n\t\tif(!isParallel(e, l) && intersectLS(l, e)){\n\t\t\tplist.push_back(crosspointLL(e, l));\n\t\t\t//cout << \"e\" << i << \" \" << plist.back() << endl;\n\t\t}\n\t}\n\treturn convex(plist);\n}\n\nint main(){\n\tcout << fixed;\n\tcout << setprecision(10);\n\twhile(1){\n\t\tint n,m;\n\t\tcin >> n >> m;\n\t\tif(n==0) break;\n\t\t\n\t\tVP v(n);\n\t\tfor(int i=0; i<n; i++){\n\t\t\tint x,y;\n\t\t\tcin >> x >> y;\n\t\t\tv[i] = P(x, y);\n\t\t}\n\t\tVP c(m);\n\t\tfor(int i=0; i<m; i++){\n\t\t\tint x,y;\n\t\t\tcin >> x >> y;\n\t\t\tc[i] = P(x, y);\n\t\t}\n\t\tif(ccw(v[0], v[1], v[2]) != 1){\n\t\t\treverse(v.begin(), v.end());\n\t\t}\n\t\t\n\t\tfor(int i=0; i<m; i++){\n\t\t\tVP poly = v;\n\t\t\tfor(int j=0; j<m; j++){\n\t\t\t\tif(i==j) continue;\n\t\t\t\tP mid = (c[i]+c[j])/2.0;\n\t\t\t\tL normal(mid, mid +(c[j]-c[i])*P(0,1));\n\t\t\t\tVP cut = convex_cut(v, normal);\n\t\t\t\tpoly = convex_intersect(poly, cut);\n\t\t\t}\n\t\t\tcout << getarea(poly) << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n    \n    const double EPS = 1e-8;\n\n    struct Point {\n        double x, y;\n        Point() {}\n        Point(double x, double y) : x(x), y(y) {}\n        Point operator+(const Point& p) const { return Point(x + p.x, y + p.y); }\n        Point operator-(const Point& p) const { return Point(x - p.x, y - p.y); }\n        Point operator*(double k) const { return Point(k * x, k * y); }\n        Point operator/(double k) const { return Point(x / k, y / k); }\n    };\n    double dot(const Point& a, const Point& b) { return a.x * b.x + a.y * b.y; }\n    double cross(const Point& a, const Point& b) { return a.x * b.y - a.y * b.x; }\n    double norm(const Point& a) { return sqrt(dot(a, a)); }\n    Point rot90(const Point& p) { return Point(-p.y, p.x); } // 反時計回りに90度回転 \n    double angle(const Point& a) { return atan2(a.y, a.x); } // x軸を反時計回りに何ラジアン回転させれば点aに乗るか\n    ostream& operator<<(ostream& os, const Point& p) { return os << \"(\" << p.x << \",\" << p.y << \")\"; }\n    istream& operator>>(istream& is, Point& p) { return is >> p.x >> p.y; }\n\n    int ccw(Point a, Point b, Point c){\n        b = b - a; c = c - a;\n        if (cross(b, c) > EPS) return +1;      // a,b,cの順に反時計周り\n        if (cross(b, c) < -EPS) return -1;     // a,b,cの順に時計周り\n        if (dot(b, c) < 0) return +2;          // c--a--b 直線\n        if (norm(b) < norm(c)) return -2;      // a--b--c 直線\n        return 0;                              // a--c--b 直線\n    }\n\n    struct Line {\n        Point a, b;\n        Line() {}\n        Line(const Point& a, const Point& b) : a(a), b(b) {}\n    };\n    ostream& operator<<(ostream& os, const Line& l) {\n        return os << \"Line(\" << l.a << \",\" << l.b << \")\";\n    }\n    Point crosspoint(const Line& s, const Line& t) {\n        double d = cross(t.b - t.a, s.b - s.a);\n        assert(abs(d) >= EPS);\n        return s.a + (s.b - s.a) * cross(t.b - t.a, t.b - s.a) / d;\n    }\n    bool parallel(const Line& s, const Line& t) { return abs(cross(s.b - s.a, t.b - t.a)) < EPS; }\n\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n\n    int N, M;\n    vector<Point> V;\n    vector<Point> L;\n    bool input() {\n        cin >> N >> M;\n        if (N == 0 && M == 0) return false;\n        V.clear(); V.resize(N);\n        L.clear(); L.resize(M);\n        for (int i = 0; i < N; i++) cin >> V[i];\n        for (int j = 0; j < M; j++) cin >> L[j];\n        return true;\n    }\n\n    Line midline(Point a, Point b) {\n        Point m = (a + b) / 2;\n        Point v = b - m;\n        return Line(m, m + rot90(v));\n    }\n\n    typedef vector<Point> Polygon;\n    double area(const Polygon& vs) {\n        if (vs.size() < 3) return 0;\n        double r = 0;\n        for (int i = 0; i < vs.size(); i++) {\n            const Point& a = vs[i];\n            const Point& b = vs[(i + 1) % vs.size()];\n            r += cross(a, b);\n        }\n        return r / 2;\n    }\n\n    struct angle_comp {\n        Point p;\n        angle_comp(Point p) : p(p) {}\n        bool operator()(Point a, Point b) {\n            return angle(a - p) < angle(b - p);\n        }\n    };\n\n    void solve() {\n        for (int i = 0; i < M; i++) {\n            vector<Point> P = V;\n            for (int j = 0; j < M; j++) {\n                if (i == j) continue;\n                Line m = midline(L[i], L[j]);\n                vector<Point> add;\n                int n = P.size();\n                for (int k = 0; k < n; k++) {\n                    Line e(P[k], P[(k + 1) % n]);\n                    if (parallel(m, e)) continue;\n                    Point p = crosspoint(m, e);\n                    if (ccw(e.a, p, e.b) == -2) {\n                        add.push_back(p);\n                    }\n                }\n                //assert(add.size() == 2);\n                vector<Point> nP = add;\n                for (int k = 0; k < n; k++) {\n                    Line c(L[i], P[k]);\n                    if (parallel(c, m)) continue;\n                    if (ccw(L[i], crosspoint(c, m), P[k]) == -2) continue;\n                    nP.push_back(P[k]);\n                }\n                sort(nP.begin(), nP.end(), angle_comp(L[i]));\n                P = nP;\n            }\n            printf(\"%.12lf\\n\", area(P));\n        }\n    }\n}\n\nint main() {\n    while (input()) solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define M 10\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<P,P> L;\nconst double EPS = 1e-8;\n\ndouble dot(P a, P b){ return real(conj(a)*b); }\n\ndouble cross(P a, P b){ return imag(conj(a)*b); }\n\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > EPS) return 1;   // ????????????(b-a)????????´???????????????(c-a)????????¨?????????\n  if(cross(b,c) < -EPS) return -1; // ????????????(b-a)????????´???????????????(c-a)????????¨?????????\n  if(dot(b,c) < -EPS) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nP crossPoint(L l, L m){\n  double A = cross(l.second - l.first, m.second - m.first);\n  double B = cross(l.second - l.first, l.second - m.first);\n  if(fabs(A) < EPS && fabs(B) < EPS) return m.first;\n  else if(fabs(A) >= EPS) return m.first + B / A * (m.second - m.first);\n}\n\nvector<P> convex_cut(vector<P> G, L l){\n  vector<P> ans;\n  for(int i=0;i<G.size();i++){\n    P A = G[i];\n    P B = G[(i+1)%G.size()];\n    if(ccw(l.first, l.second, A) != -1) ans.push_back(A);\n    if(ccw(l.first, l.second, A) * ccw(l.first, l.second, B) < 0)\n      ans.push_back(crossPoint(L(A,B), l));\n  }\n  return ans;\n}\n\ndouble area(vector<P> v){\n  double sum = 0.0;\n  int n = v.size();\n  for(int i=0;i<n;i++) sum += (real(v[i]) - real(v[(i+1)%n])) * (imag(v[i]) + imag(v[(i+1)%n]));\n  return fabs(sum) / 2;\n};\n\nint n,m,x,y,cx,cy;\nvector<P> vi;\nP c[M];\n\nint main(){\n  while(1){\n    cin>>n>>m;\n    if(!n&&!m)break;\n    for(int i=0;i<n;i++){\n      cin>>x>>y;\n      vi.push_back(P(x,y));\n    }\n    for(int i=0;i<m;i++){\n      cin>>cx>>cy;\n      c[i]=P(cx,cy);\n    }\n    for(int i=0;i<m;i++){\n      vector<P> cp=vi;\n      for(int j=0;j<m;j++){\n\tif(i==j)continue;\n\tdouble X=(c[j].real()-c[i].real())/2.0;\n\tdouble Y=(c[j].imag()-c[i].imag())/2.0;\n\tP A=P(c[i].real()+c[j].imag()-c[i].imag()+X,\n\t      c[i].imag()-(c[j].real()-c[i].real())+Y);\n\tP B=P(c[i].real()+X,c[i].imag()+Y);\n\tcp=convex_cut(cp,L(A,B));\n      }\n      printf(\"%.20f\\n\",area(cp));\n    }\n    vi.clear();;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);++i)\n#define rep2(i,a,b) for (int i=(a);i<(b);++i)\n#define rrep(i,n) for (int i=(n)-1;i>=0;--i)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;--i)\n#define chmin(a,b) (a)=min((a),(b));\n#define chmax(a,b) (a)=max((a),(b));\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) cout<<(#v)<<\":\";for(auto(x):(v)){cout<<\" \"<<(x);}cout<<endl;\n#define printVS(vs) cout<<(#vs)<<\":\"<<endl;for(auto(s):(vs)){cout<<(s)<< endl;}\n#define printVV(vv) cout<<(#vv)<<\":\"<<endl;for(auto(v):(vv)){for(auto(x):(v)){cout<<\" \"<<(x);}cout<<endl;}\n#define printP(p) cout<<(#p)<<(p).first<<\" \"<<(p).second<<endl;\n#define printVP(vp) cout<<(#vp)<<\":\"<<endl;for(auto(p):(vp)){cout<<(p).first<<\" \"<<(p).second<<endl;}\n\ninline void output(){ cout << endl; }\ntemplate<typename First, typename... Rest>\ninline void output(const First& first, const Rest&... rest) {\n    cout << first << \" \"; output(rest...);\n}\n\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing TUPLE = tuple<int, int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\nusing Graph = vector<vector<int>>;\n\ntypedef complex<double> P;\ntypedef vector<P> G;\n#define here(g, i) g[i]\n#define next(g, i) g[(i + 1) % g.size()]\n#define prev(g, i) g[(i - 1 + g.size()) % g.size()]\nconst double EPS = 1e-10;\nconst double INF = 1e12;\nconst double PI = acos(-1);\n\nstruct L {\n    P a, b, v;\n    L(){}\n    L(P _a, P _b) : a(_a), b(_b), v(b - a) {}\n    L(double _ax, double _ay, double _bx, double _by) : L(P(_ax, _ay), P(_bx, _by)) {}\n    void reverse() {\n        swap(a, b); v = b - a;\n    }\n};\n\ndouble cross(P a, P b) {\n    return imag(conj(a) * b);\n}\n\ndouble dot(P a, P b) {\n    return real(conj(a) * b);\n}\n\n// signed!!!!!!!!!\ndouble areaG(G g) {\n    int n = g.size();\n    double ret;\n    rep(i, n) {\n        ret += cross(here(g, i), next(g, i));\n    }\n    return ret / 2;\n}\n\nP readP() {\n    double x, y;\n    cin >> x >> y;\n    return P(x, y);\n}\n\nG readG(int n) {\n    // int n;\n    // cin >> n;\n    G g(n);\n    rep(i, n) g[i] = readP();\n    return g;\n}\n\nL PerpendicularBisector(P p, P q) {\n    P c = (p + q) / 2.;\n    P d = (q - p) / 2.;\n    P h = d * P(0, 1);\n    return L(c + h, c - h);\n}\n\nint ccw(P p0, P p1, P p2) {\n    p1 -= p0; p2 -= p0;\n    if (cross(p1, p2) > 0) return +1;       // counter-clockwise\n    if (cross(p1, p2) < 0) return -1;       // clockwise\n    if (dot(p1, p2) < 0) return +2;         // p2 -- p0 -- p1\n    if (norm(p1) < norm(p2)) return -2;     // p0 -- p1 -- p2\n    return 0;                               // p0 -- p2 -- p1\n}\n\nP crosspointLL(L l1, L l2) {\n    return l1.a + l1.v * cross(l2.v, l2.a - l1.a) / cross(l2.v, l1.v);\n}\n\nG convex_cut(G g, L l) {\n    G h;\n    rep(i, (int)g.size()) {\n        P p = here(g, i), q = next(g, i);\n        if (ccw(p, q, l.a) == 0 && ccw(p, q, l.b) == 0) {\n            if (ccw(p, l.b, l.a) == 0) return g;    // p -- l.a -- l.b -- q\n            else return G{};                        // p -- l.b -- l.a -- q\n        }\n        if (ccw(l.a, l.b, p) != -1) h.emplace_back(p);\n        if (ccw(l.a, l.b, p) * ccw(l.a, l.b, q) < 0)\n        h.emplace_back(crosspointLL(L(p, q), l));\n    }\n    return h;\n}\n\nvector<G> Voronoi(G g, vector<P> p) {\n    vector<G> ret;\n    rep(i, p.size()) {\n        G h = g;\n        rep(j, p.size()) {\n            L l = PerpendicularBisector(p[i], p[j]);\n            if (ccw(l.a, l.b, p[i]) == -1) l.reverse();\n            h = convex_cut(h, l);\n        }\n        ret.emplace_back(h);\n    }\n    return ret;\n}\n\nmain() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int n, m;\n    while (cin >> n >> m, n) {\n        G g = readG(n);\n        vector<P> p(m);\n        rep(i, m) p[i] = readP();\n\n        auto vg = Voronoi(g, p);\n        rep(i, vg.size()) {\n            cout << fixed << setprecision(10) << abs(areaG(vg[i])) << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\ndouble const EPS = 1e-7;\n\ntypedef complex<double> P;\n\ndouble dot(P a, P b) { return real(conj(a)*b); }\ndouble cross(P a, P b) { return imag(conj(a)*b); }\n\nint ccw(P p0, P p1, P p2) {\n  auto a = p1 - p0;\n  auto b = p2 - p0;\n  if(cross(a, b) > EPS) return +1;\n  if(cross(a, b) < -EPS) return -1;\n  if(dot(a, b) < -EPS) return +2;\n  if(norm(a) < norm(b)) return -2;\n  return 0;\n}\n\ndouble area(vector<P> &g) {\n  double ret = 0;\n  rep(i, g.size()) {\n    ret += cross(g[i], g[(i+1)%g.size()]);\n  }\n  return abs(ret) / 2.0;\n}\n\nstruct Line: public vector<P> {\n  Line(P a, P b) {\n    push_back(a), push_back(b);\n  }\n};\n\nLine perpendicular_bisector(P& a, P& b) {\n  P c = (a + b) / 2.0;\n  P p = P(c.real() + (a.imag() - b.imag()), c.imag() - (a.real() - b.real()));\n  return Line(c, p);\n}\n\nP crosspointLL(Line const& a, Line const& b) {\n  P va = a[1] - a[0], vb = b[1] - b[0];\n  double d = cross(vb, va);\n  if(abs(d) < EPS) return b[0];\n  return a[0] + va * cross(vb, b[1] - a[0]) * (1.0 / d);\n}\n\nvector<P> convex_cut(vector<P>& g, Line const& l) {\n  vector<P> ret;\n  rep(i, g.size()) {\n    if(ccw(l[0], l[1], g[i]) != -1) ret.push_back(g[i]);\n    if(ccw(l[0], l[1], g[i]) * ccw(l[0], l[1], g[(i+1)%g.size()]) < 0) {\n      ret.push_back(crosspointLL(Line(g[i], g[(i+1)%g.size()]), l));\n    }\n  }\n  return ret;\n}\n\nint main() {\n\n  int N, M;\n  while(cin >> N >> M && (N|M)) {\n    vector<P> g;\n    rep(i, N) {\n      double x, y; cin >> x >> y;\n      g.push_back(P(x, y));\n    }\n\n    vector<P> ps;\n    rep(i, M) {\n      double x, y; cin >> x >> y;\n      ps.push_back(P(x, y));\n    }\n\n    rep(i, M) {\n      auto p = g;\n      rep(j, M) {\n        if(i == j) continue;\n        p = convex_cut(p, perpendicular_bisector(ps[i], ps[j]));\n      }\n      printf(\"%.10f\\n\", area(p));\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cassert>\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\n#define x first\n#define y second\n\nusing namespace std;\n\ntypedef pair<double, double> Point;\n\nclass Line {\n  public:\n    double a, b, c;\n\n    Line(const double _a = 0.0, const double _b = 0.0, const double _c = 0.0):\n      a(_a),\n      b(_b),\n      c(_c) {}\n\n    Line(const Point &p1, const Point &p2):\n      a(p1.y - p2.y),\n      b(p2.x - p1.x),\n      c(p1.x * p2.y - p1.y * p2.x) {}\n};\n\nvector<Line> Plane;\nvector<Point> Points;\nvector<double> Areas;\n\ninline double Det(const Point &a, const Point &b, const Point &c) {\n    return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\n}\n\nclass Compare {\n  public:\n    static Point origin;\n\n    bool operator()(const Point &a, const Point &b) const {\n        return Det(origin, a, b) >= 0;\n    }\n};\n\nPoint Compare::origin;\n\nvector<Point> ConvexHull(vector<Point> points) {\n    int n = int(points.size());\n    int origin = 0;\n    for (int i = 1; i < n; ++i)\n        if (points[i] < points[origin])\n            origin = i;\n    swap(points[0], points[origin]);\n    Compare::origin = points[0];\n    sort(points.begin() + 1, points.end(), Compare());\n    points.push_back(points[0]);\n    vector<Point> hull;\n    for (int i = 0; i < int(points.size()); ++i) {\n        while (int(hull.size()) > 1 && Det(hull[int(hull.size()) - 2], hull[int(hull.size()) - 1], points[i]) < 0)\n            hull.pop_back();\n        hull.push_back(points[i]);\n    }\n    hull.pop_back();\n    return hull;\n}\n\ninline Point Dualize(const Line &l) {\n    if (l.c == 0)\n        return Point(0, 0);\n    else\n        return Point(l.a / l.c, l.b / l.c);\n}\n\ninline Line Dualize(const Point &p) {\n    return Line(p.x, p.y, 1);\n}\n\ninline Point Translate(const Point &p, const Point &shift) {\n    return Point(p.x + shift.x, p.y + shift.y);\n}\n\ninline Line Translate(const Line &l, const Point &shift) {\n    return Line(l.a, l.b, l.c - l.a * shift.x - l.b * shift.y);\n}\n\nvector< vector<Point> > GetVoronoiDiagrams(const vector<Line> &plane, const vector<Point> &points) {\n    int n = int(points.size());\n    vector< vector<Point> > voronoiDiagrams = vector< vector<Point> >(n, vector<Point>());\n    for (int i = 0; i < n; ++i) {\n        Point shift = Point(-points[i].x, -points[i].y);\n        vector<Point> dualizedLines;\n        for (int j = 0; j < int(plane.size()); ++j)\n            dualizedLines.push_back(Dualize(Translate(plane[j], shift)));\n        for (int j = 0; j < n; ++j) {\n            if (i != j) {\n                Point a = points[i], b = points[j];\n                dualizedLines.push_back(Dualize(Translate(Line(2 * (b.x - a.x), 2 * (b.y - a.y), a.x * a.x + a.y * a.y - b.x * b.x - b.y * b.y), shift)));\n            }\n        }\n        vector<Point> hull = ConvexHull(dualizedLines);\n        for (int j = 0; j < int(hull.size()); ++j)\n            voronoiDiagrams[i].push_back(Translate(Dualize(Line(hull[j], hull[(j + 1) % int(hull.size())])), points[i]));\n    }\n    return voronoiDiagrams;\n}\n\ninline double GetArea(const vector<Point> &polygon) {\n    int n = int(polygon.size());\n    double area = 0.0;\n    for (int i = 0; i < n; ++i)\n        area += polygon[i].x * polygon[(i + 1) % n].y - polygon[(i + 1) % n].x * polygon[i].y;\n    area /= 2.0;\n    if (area < 0.0)\n        area = -area;\n    return area;\n}\n\nvoid Solve() {\n    vector< vector<Point> > voronoi = GetVoronoiDiagrams(Plane, Points);\n    Areas = vector<double>(int(Points.size()), 0.0);\n    for (int i = 0; i < int(Points.size()); ++i)\n        Areas[i] = GetArea(voronoi[i]);\n}\n\nbool Read() {\n    int n, m;\n    cin >> n >> m;\n    if (n == 0 && m == 0)\n        return false;\n    vector<Point> planePolygon = vector<Point>(n);\n    for (int i = 0; i < n; ++i)\n        cin >> planePolygon[i].x >> planePolygon[i].y;\n    Plane = vector<Line>(n);\n    for (int i = 0; i < n; ++i)\n        Plane[i] = Line(planePolygon[i], planePolygon[(i + 1) % n]);\n    Points = vector<Point>(m);\n    for (int i = 0; i < m; ++i)\n        cin >> Points[i].x >> Points[i].y;\n    return true;\n}\n\nvoid Print() {\n    for (int i = 0; i < int(Points.size()); ++i)\n        printf(\"%.7lf\\n\", Areas[i]);\n}\n\nint main() {\n    while (Read()) {\n        Solve();\n        Print();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\ndouble const EPS = 1e-7;\n\ntypedef complex<double> P;\n\ndouble dot(P a, P b) { return real(conj(a)*b); }\ndouble cross(P a, P b) { return imag(conj(a)*b); }\n\nint ccw(P p0, P p1, P p2) {\n  auto a = p1 - p0;\n  auto b = p2 - p0;\n  if(cross(a, b) > EPS) return +1;\n  if(cross(a, b) < -EPS) return -1;\n  if(dot(a, b) < -EPS) return +2;\n  if(norm(a) < norm(b)) return -2;\n  return 0;\n}\n\ndouble area(vector<P> &g) {\n  double ret = 0;\n  rep(i, g.size()) {\n    ret += cross(g[i], g[(i+1)%g.size()]);\n  }\n  return abs(ret) / 2.0;\n}\n\nstruct Line: public vector<P> {\n  Line(P a, P b) {\n    push_back(a), push_back(b);\n  }\n};\n\nLine perpendicular_bisector(P& a, P& b) {\n  P c = (a + b) / 2.0;\n  P p = P(c.real() + (a.imag() - b.imag()), c.imag() - (a.real() - b.real()));\n  return Line(c, p);\n}\n\nP crosspointLL(Line const& a, Line const& b) {\n  P va = a[1] - a[0], vb = b[1] - b[0];\n  double d = cross(vb, va);\n  if(abs(d) < EPS) return b[0];\n  return a[0] + va * cross(vb, b[1] - a[0]) * (1.0 / d);\n}\n\nvector<P> convex_cut(vector<P>& g, Line const& l) {\n  vector<P> ret;\n  rep(i, g.size()) {\n    if(ccw(l[0], l[1], g[i]) != -1) ret.push_back(g[i]);\n    if(ccw(l[0], l[1], g[i]) * ccw(l[0], l[1], g[(i+1)%g.size()]) < 0) {\n      ret.push_back(crosspointLL(Line(g[i], g[(i+1)%g.size()]), l));\n    }\n  }\n  return ret;\n}\n\nint main() {\n\n  int N, M;\n  while(cin >> N >> M && (N|M)) {\n    vector<P> g;\n    rep(i, N) {\n      double x, y; cin >> x >> y;\n      g.push_back(P(x, y));\n    }\n\n    vector<P> ps;\n    rep(i, M) {\n      double x, y; cin >> x >> y;\n      ps.push_back(P(x, y));\n    }\n\n    rep(i, M) {\n      auto p = g;\n      rep(j, M) {\n        if(i == j) continue;\n        p = convex_cut(p, perpendicular_bisector(ps[i], ps[j]));\n      }\n      printf(\"%.10f\\n\", area(p));\n    }\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<vector>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst double EPS=1e-8;\n\ntemplate<class T>\nstruct point{\n\tT x,y;\n\tpoint operator+(const point &a)const{ return (point){x+a.x,y+a.y}; }\n\tpoint operator-(const point &a)const{ return (point){x-a.x,y-a.y}; }\n};\n\ntemplate<class T>\npoint<T> operator*(T c,const point<T> &a){ return (point<T>){c*a.x,c*a.y}; }\n\ntemplate<class T>\nT cross(const point<T> &a,const point<T> &b){ return a.x*b.y-a.y*b.x; }\n\ntemplate<class T>\nstruct line{ point<T> a,b; };\n\ntemplate<class T>\nstruct polygon:vector< point<T> >{\n\tpolygon(){}\n\tpolygon(int n):vector< point<T> >(n){}\n};\n\ntemplate<class T>\nT area2(const polygon<T> &G){\n\tint n=G.size();\n\tT a=0;\n\trep(i,n) a+=cross(G[i],G[(i+1)%n]);\n\treturn abs(a);\n}\n\ntemplate<class T>\nline<double> perp_bisector(const point<T> &a,const point<T> &b){\n\treturn (line<double>){(point<double>){(a.x-a.y+b.x+b.y)/2.0,(a.y+a.x+b.y-b.x)/2.0},\n\t\t\t\t\t\t  (point<double>){(a.x+a.y+b.x-b.y)/2.0,(a.y-a.x+b.y+b.x)/2.0}};\n}\n\nenum {CCW=1,CW=-1,ON=0};\nint ccw(const point<double> &a,const point<double> &b,const point<double> &c){\n\tdouble rdir=cross(b-a,c-a);\n\tif(rdir> EPS) return CCW;\n\tif(rdir<-EPS) return CW;\n\treturn ON;\n}\n\npoint<double> get_intersect(const line<double> &L1,const line<double> &L2){\n\tdouble a1=cross(L1.b-L1.a,L2.b-L2.a);\n\tdouble a2=cross(L1.b-L1.a,L1.b-L2.a);\n\tif(abs(a1)<EPS) return L1.a;\n\treturn L2.a+a2/a1*(L2.b-L2.a);\n}\n\ntemplate<class T>\npolygon<double> convex_cut(const polygon<T> &G,const line<T> &L){\n\tint n=G.size();\n\tpolygon<double> H;\n\trep(i,n){\n\t\tint d1=ccw(L.a,L.b,G[i]);\n\t\tint d2=ccw(L.a,L.b,G[(i+1)%n]);\n\t\tif(d1!=CW) H.push_back(G[i]);\n\t\tif(d1==CCW && d2==CW || d1==CW && d2==CCW){\n\t\t\tH.push_back(get_intersect(L,(line<T>){G[i],G[(i+1)%n]}));\n\t\t}\n\t}\n\treturn H;\n}\n\nint main(){\n\tfor(int n,m;scanf(\"%d%d\",&n,&m),n;){\n\t\tpolygon<double> G(n);\n\t\trep(i,n) scanf(\"%lf%lf\",&G[i].x,&G[i].y);\n\t\tpoint<double> P[10];\n\t\trep(i,m) scanf(\"%lf%lf\",&P[i].x,&P[i].y);\n\n\t\trep(i,m){\n\t\t\tpolygon<double> Vor=G;\n\t\t\trep(j,n) if(j!=i) Vor=convex_cut(Vor,perp_bisector(P[i],P[j]));\n\t\t\tprintf(\"%.9f\\n\",area2(Vor)/2);\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>void reg(vector<T> &ary,const T &elem){ary.emplace_back(elem);}\ntemplate<class T>bool chmin(T &a, const T &b) {return (b<a)?(a=b,1):0;}\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\n\nusing R=long double; // __float128\nconst R EPS = 1E-11; // [-1000:1000]->EPS=1e-8 [-10000:10000]->EPS=1e-7\nconst R INF = 1E40;\nconstexpr R PI = acos(R(-1));\ninline int sgn(const R& r){ return (r > EPS) - (r < -EPS);}\ninline int sgn(const R& a, const R &b){ return sgn(a-b); }\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n\nusing P=complex<R>;\nusing VP=vector<P>;\nusing L=struct{P s,t;};\nusing VL=vector<L>;\n\nconstexpr P O = P(0,0);\nistream& operator >> (istream& is,P& p){ R x,y;is >> x >> y; p=P(x,y); return is;}\nostream& operator << (ostream& os,P& p){ os << real(p) << \" \" << imag(p); return os;}\n\n\n// dot det\ninline R dot(P o,P a,P b){a-=o,b-=o; return real(conj(a)*b);}\ninline R det(P o,P a,P b){a-=o,b-=o; return imag(conj(a)*b);}\ninline P vec(L l){return l.t-l.s;}\n\n\n// CCW verify AOJ CGL_1_C\nenum CCW{ LEFT = 1,RIGHT = 2,BACK = 4,FRONT = 8,ON = 16};\ninline int ccw(P o,P a, P b) {\n\tif (sgn(det(o,a,b)) > 0) return LEFT;    // counter clockwise\n\tif (sgn(det(o,a,b)) < 0) return RIGHT;   // clockwise\n\tif (sgn(dot(o,a,b)) < 0) return BACK;    // b--base--a on line\n\tif (sgn(norm(a-o)-norm(b-o)) < 0) return FRONT;   // base--a--b on line\n\treturn ON;// base--b--a on line  semnet determination betwenn a and b \n}\n\n// crossing point verify AOJ CGL_2_C\nP cross(L a,L b){\n\tR s1=det(a.s,b.s,b.t);\n\tR s2=s1+det(a.t,b.t,b.s);\n\treturn a.s+s1/s2*(a.t-a.s);\n}\n\n// Polygon\n// area Verify AOJ 1100 CGL_3_A\nR area(const VP& pol){\n\tint n=pol.size();\n\tR sum=0;\n\trep(i,n) sum+=det(O,pol[i],pol[(i+1)%n]);\n\treturn abs(sum/2.0);\n}\n\n// convex_cut verify AOJ CGL_4_C\nVP convex_cut(const VP& pol,const L& l) {\n\tVP res;\n\tint n=pol.size();\n\trep(i,n){\n\t\tP a = pol[i],b=pol[(i+1)%n];\n\t\tif(ccw(l.s,l.t,a)!=RIGHT) reg(res,a);\n\t\tif((ccw(l.s,l.t,a)|ccw(l.s,l.t,b))==(LEFT|RIGHT)) reg(res,cross({a,b},l));\n\t}\n\treturn res;\n}\n\n\nL bisector(P a, P b){P mid=(a+b)/P(2,0);return L{mid, mid+(b-a)*P(0,1)};}\nVP voronoi_cell(VP pol,VP v,int s){rep(i,v.size())if(i!=s)pol=convex_cut(pol,bisector(v[s],v[i]));return pol;}\n\n\nint main(void){\n\tint n,m;\n\twhile(cin >> n >> m,n){\n\t\tVP island(n),lord(m);\n\t\trep(i,n) cin >> island[i];\n\t\trep(i,m) cin >> lord[i];\n\n\t\tcout.precision(20);\n\t\trep(i,m) cout << fixed << area(voronoi_cell(island,lord,i)) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <array>\nusing namespace std;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n#define X real()\n#define Y imag()\n\ntypedef complex<double> P;\ntypedef vector<P> VP;\nstruct L : array<P, 2>{\n    L(const P& a, const P& b){ at(0)=a; at(1)=b; }\n    L(){}\n};\nnamespace std{\n    bool operator < (const P& a, const P& b){\n        return !EQ(a.X,b.X) ? a.X<b.X : a.Y<b.Y;\n    }\n    bool operator == (const P& a, const P& b){\n        return abs(a-b) < EPS;\n    }\n}\n\ndouble dot(P a, P b){\n    return (conj(a)*b).X;\n}\ndouble cross(P a, P b){\n    return (conj(a)*b).Y;\n}\nint ccw(P a, P b, P c){\n    b -= a;\n    c -= a;\n    if(cross(b,c) > EPS) return +1; //ccw\n    if(cross(b,c) < -EPS) return -1; //cw\n    if(dot(b,c) < -EPS) return +2; //c-a-b\n    if(abs(c)-abs(b) > EPS) return -2; //a-b-c\n    return 0; //a-c-b\n}\n\nbool intersectLS(const L& l, const L& s){\n    return cross(l[1]-l[0], s[0]-l[0])*\n        cross(l[1]-l[0], s[1]-l[0]) < EPS;\n}\nbool intersectSS(const L& a, const L& b){\n    return ( ccw(a[0],a[1],b[0]) *ccw(a[0],a[1],b[1]) <= 0 ) &&\n        ( ccw(b[0],b[1],a[0]) *ccw(b[0],b[1],a[1]) <= 0 );\n}\nbool intersectSP(const L& s, const P &p){\n    return abs(cross(s[0]-p, s[1]-p))<EPS  && dot(s[0]-p, s[1]-p)<EPS;\n}\n\nP projection(const L& l, const P& p) {\n  double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n  return l[0] + t*(l[0]-l[1]);\n}\n\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1]-l[0], m[1]-m[0]);\n  double B = cross(l[1]-l[0], l[1]-m[0]);\n  return m[0] + B/A *(m[1]-m[0]);\n}\n\nbool isParallel(const P &a, const P &b){\n    return abs(cross(a,b)) < EPS;\n}\nbool isParallel(const L &a, const L &b){\n    return isParallel(a[1]-a[0], b[1]-b[0]);\n}\n\ndouble getarea(const VP &poly){\n    double ret = 0;\n    for (int i=0; i<(int)poly.size(); i++){ \n        ret += cross(poly[i], poly[(i+1)%poly.size()]);\n    }\n    return ret*0.5;\n}\n\nint in_poly(const P &p, const VP &poly){\n    int n = poly.size();\n    int ret = -1;\n    for(int i=0; i<n; i++){\n        P a = poly[i]-p;\n        P b = poly[(i+1)%n]-p;\n        if(a.Y > b.Y) swap(a,b);\n        if(intersectSP(L(a,b), P(0,0))) return 0;\n        if(a.Y<=0 && b.Y>0 && cross(a,b)<0) ret = 1-ret;\n    }\n    return ret;\n}\n\nVP convex(VP v){\n    VP ret;\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(), v.end()), v.end());\n    int n = v.size();\n    for(int i=0; i<n; i++){\n        while((int)ret.size()>1 && cross(ret.back()-ret[ret.size()-2], v[i]-ret.back()) < EPS){\n            ret.pop_back();\n        }\n        ret.push_back(v[i]);\n    }\n    int t = ret.size();\n    for(int i=n-2; i>=0; i--){\n        while((int)ret.size()>t && cross(ret.back()-ret[ret.size()-2], v[i]-ret.back()) < EPS){\n            ret.pop_back();\n        }\n        ret.push_back(v[i]);\n    }\n    if((int)ret.size() > 1) ret.pop_back();\n    return ret;\n}\n\nVP convex_intersect(VP a, VP b){\n\tVP plist;\n\tint n=a.size(), m=b.size();\n\tfor(int r=0; r<2; r++){\n\t\tfor(int i=0; i<n; i++){\n\t\t\tif(in_poly(a[i], b) >= 0){\n\t\t\t\tplist.push_back(a[i]);\n\t\t\t}\n\t\t}\n\t\tswap(n, m);\n\t\tswap(a, b);\n\t}\n\tfor(int i=0; i<n; i++){\n\t\tfor(int j=0; j<m; j++){\n\t\t\tL la(a[i], a[(i+1)%n]), lb(b[j], b[(j+1)%m]);\n\t\t\tif(!isParallel(la, lb) && intersectSS(la, lb)){\n\t\t\t\tplist.push_back(crosspointLL(la, lb));\n\t\t\t}\n\t\t}\n\t}\n\treturn convex(plist);\n}\n\nVP convex_cut(const VP& p, const L& l){\n\tVP ret;\n\tint n = p.size();\n\tfor(int i=0; i<n; i++){\n\t\tP curr = p[i];\n\t\tP next = p[(i+1)%n];\n\t\tif(ccw(l[0], l[1], curr) != -1) ret.push_back(curr);\n\t\tif(ccw(l[0], l[1], curr) *ccw(l[0], l[1], next) == -1){\n\t\t\tret.push_back(crosspointLL(L(curr, next), l));\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\tcout << fixed;\n\tcout << setprecision(10);\n\twhile(1){\n\t\tint n,m;\n\t\tcin >> n >> m;\n\t\tif(n==0) break;\n\t\t\n\t\tVP v(n);\n\t\tfor(int i=0; i<n; i++){\n\t\t\tint x,y;\n\t\t\tcin >> x >> y;\n\t\t\tv[i] = P(x, y);\n\t\t}\n\t\tVP c(m);\n\t\tfor(int i=0; i<m; i++){\n\t\t\tint x,y;\n\t\t\tcin >> x >> y;\n\t\t\tc[i] = P(x, y);\n\t\t}\n\t\tif(ccw(v[0], v[1], v[2]) != 1){\n\t\t\treverse(v.begin(), v.end());\n\t\t}\n\t\t\n\t\tfor(int i=0; i<m; i++){\n\t\t\tVP poly = v;\n\t\t\tfor(int j=0; j<m; j++){\n\t\t\t\tif(i==j) continue;\n\t\t\t\tP mid = (c[i]+c[j])/2.0;\n\t\t\t\tL normal(mid, mid +(c[j]-c[i])*P(0,1));\n\t\t\t\tVP cut = convex_cut(v, normal);\n\t\t\t\tpoly = convex_intersect(poly, cut);\n\t\t\t}\n\t\t\tcout << getarea(poly) << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);++i)\n#define rep2(i,a,b) for (int i=(a);i<(b);++i)\n#define rrep(i,n) for (int i=(n)-1;i>=0;--i)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;--i)\n#define chmin(a,b) (a)=min((a),(b));\n#define chmax(a,b) (a)=max((a),(b));\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) cout<<(#v)<<\":\";for(auto(x):(v)){cout<<\" \"<<(x);}cout<<endl;\n#define printVS(vs) cout<<(#vs)<<\":\"<<endl;for(auto(s):(vs)){cout<<(s)<< endl;}\n#define printVV(vv) cout<<(#vv)<<\":\"<<endl;for(auto(v):(vv)){for(auto(x):(v)){cout<<\" \"<<(x);}cout<<endl;}\n#define printP(p) cout<<(#p)<<(p).first<<\" \"<<(p).second<<endl;\n#define printVP(vp) cout<<(#vp)<<\":\"<<endl;for(auto(p):(vp)){cout<<(p).first<<\" \"<<(p).second<<endl;}\n\ninline void output(){ cout << endl; }\ntemplate<typename First, typename... Rest>\ninline void output(const First& first, const Rest&... rest) {\n    cout << first << \" \"; output(rest...);\n}\n\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing TUPLE = tuple<int, int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nconst int inf = 1e9;\nconst int mod = 1e9 + 7;\nusing Graph = vector<vector<int>>;\n\ntypedef complex<double> P;\ntypedef vector<P> G;\n#define here(g, i) g[i]\n#define next(g, i) g[(i + 1) % g.size()]\n#define prev(g, i) g[(i - 1 + g.size()) % g.size()]\nconst double EPS = 1e-10;\nconst double INF = 1e12;\nconst double PI = acos(-1);\n\nstruct L {\n    P a, b, v;\n    L(){}\n    L(P _a, P _b) : a(_a), b(_b), v(b - a) {}\n    L(double _ax, double _ay, double _bx, double _by) : L(P(_ax, _ay), P(_bx, _by)) {}\n    void reverse() {\n        swap(a, b); v = b - a;\n    }\n};\n\ndouble cross(P a, P b) {\n    return imag(conj(a) * b);\n}\n\ndouble dot(P a, P b) {\n    return real(conj(a) * b);\n}\n\n// signed!!!!!!!!!\ndouble areaG(G g) {\n    int n = g.size();\n    double ret;\n    rep(i, n) {\n        ret += cross(here(g, i), next(g, i));\n    }\n    return ret / 2;\n}\n\nP readP() {\n    double x, y;\n    cin >> x >> y;\n    return P(x, y);\n}\n\nG readG(int n) {\n    // int n;\n    // cin >> n;\n    G g(n);\n    rep(i, n) g[i] = readP();\n    return g;\n}\n\nL PerpendicularBisector(P p, P q) {\n    P c = (p + q) / 2.;\n    P d = (q - p) / 2.;\n    P h = d * P(0, 1);\n    return L(c + h, c - h);\n}\n\nint ccw(P p0, P p1, P p2) {\n    p1 -= p0; p2 -= p0;\n    if (cross(p1, p2) > 0) return +1;       // counter-clockwise\n    if (cross(p1, p2) < 0) return -1;       // clockwise\n    if (dot(p1, p2) < 0) return +2;         // p2 -- p0 -- p1\n    if (norm(p1) < norm(p2)) return -2;     // p0 -- p1 -- p2\n    return 0;                               // p0 -- p2 -- p1\n}\n\nP crosspointLL(L l1, L l2) {\n    return l1.a + l1.v * cross(l2.v, l2.a - l1.a) / cross(l2.v, l1.v);\n}\n\nG convex_cut(G g, L l) {\n    G h;\n    rep(i, (int)g.size()) {\n        P p = here(g, i), q = next(g, i);\n        if (ccw(p, q, l.a) == 0 && ccw(p, q, l.b) == 0) {\n            if (ccw(p, l.b, l.a) == 0) return g;    // p -- l.a -- l.b -- q\n            else return G{};                        // p -- l.b -- l.a -- q\n        }\n        if (ccw(l.a, l.b, p) != -1) h.emplace_back(p);\n        if (ccw(l.a, l.b, p) * ccw(l.a, l.b, q) < 0)\n        h.emplace_back(crosspointLL(L(p, q), l));\n    }\n    return h;\n}\n\nvector<G> Voronoi(G g, vector<P> p) {\n    vector<G> ret;\n    rep(i, p.size()) {\n        G h = g;\n        rep(j, p.size()) {\n            if (i == j) continue;\n            L l = PerpendicularBisector(p[i], p[j]);\n            if (ccw(l.a, l.b, p[i]) == -1) l.reverse();\n            h = convex_cut(h, l);\n        }\n        ret.emplace_back(h);\n    }\n    return ret;\n}\n\nmain() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int n, m;\n    while (cin >> n >> m, n) {\n        G g = readG(n);\n        vector<P> p(m);\n        rep(i, m) p[i] = readP();\n\n        auto vg = Voronoi(g, p);\n        rep(i, vg.size()) {\n            cout << fixed << setprecision(10) << abs(areaG(vg[i])) << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <memory>\n#include <cstring>\n#include <cassert>\n#include <numeric>\n#include <sstream>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <cctype>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\nusing namespace std;\n\n#define REP2(i, m, n) for (int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(S) (S).begin(), (S).end()\ntypedef long long ll;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line_t;\ntypedef pair<xy_t, double> circle_t;\ntypedef vector<xy_t> poly_t;\n\nnamespace std {\n  bool operator<(const xy_t &a, const xy_t &b){\n    return a.real() == b.real() ? a.imag() < b.imag() : a.real() < b.real();\n  }\n}\n\nconst double EPS = 1e-9;\n\ninline bool equal(double a, double b){\n  return abs(a - b) < EPS;\n}\n\nistream &operator>>(istream &is, xy_t &p)   {\n  double x, y;\n  is >> x >> y;\n  p = xy_t(x, y);\n  return is;\n}\n\nistream &operator>>(istream &is, line_t &l) {\n  return is >> l.first >> l.second;\n}\n\ninline double cross(const xy_t &a, const xy_t &b){\n  return imag(conj(a) * b);\n}\n\ninline double dot(const xy_t &a, const xy_t &b){\n  return real(conj(a) * b);\n}\n\ninline xy_t rotate(const xy_t &a, double theta){\n  return a * polar(1.0, theta);\n}\n\ninline xy_t direction(const line_t &line){\n  return line.second - line.first;\n}\n\nint ccw(const xy_t &a, xy_t b, xy_t c){\n  b -= a;\n  c -= a;\n  if (cross(b, c) > 0) return 1;\n  if (cross(b, c) < 0) return -1;\n  if (dot(b, c)   < 0) return 2;\n  if (norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nint ccw(const line_t &l, const xy_t &a){\n  return ccw(l.first, l.second, a);\n}\n\nline_t bisector(const xy_t &a, const xy_t &b){\n  xy_t v = rotate(b - a, M_PI / 2);\n  xy_t m = (a + b) * 0.5;\n  return line_t (m, m + v);\n};\n\nxy_t crosspoint(const line_t &l, const line_t &m){\n  xy_t l_vec = direction(l);\n  xy_t m_vec = direction(m);\n  double A = cross(l_vec, m_vec);\n  assert(!equal(A, 0));\n  return m.first + cross(l_vec, l.second-m.first) / A * m_vec;\n}\n\ninline size_t next_index(const poly_t &poly, size_t curr){\n  return (curr + 1) % poly.size();\n}\n\ninline size_t prev_index(const poly_t &poly, size_t curr){\n  return (curr + poly.size() - 1)  % poly.size();\n}\n\npoly_t convex_cut(const poly_t &poly, const line_t &line){\n  poly_t new_poly;\n  \n  for (size_t i = 0; i < poly.size(); i++){\n    xy_t a = poly[i];\n    xy_t b = poly[next_index(poly, i)];\n\n    if (ccw(line, a) != -1) new_poly.push_back(a);\n\n    if (ccw(line, a) * ccw(line, b) == -1){\n      new_poly.push_back(crosspoint(line_t (a, b), line));\n    }\n  }\n  return new_poly;\n}\n\ndouble signed_area(const poly_t &poly){\n  double res = 0;\n  for (size_t i = 0; i < poly.size(); i++){\n    res += cross(poly[i], poly[next_index(poly, i)]);\n  }\n  return res * 0.5;\n}\n\ndouble area(const poly_t &poly){\n  return abs(signed_area(poly));\n}\n\n\nint main(){\n  ios::sync_with_stdio(false);\n  int N, M;\n  while (cin >> N >> M && N + M){\n    poly_t poly(N);\n    REP(i, N){\n      cin >> poly[i];\n    }\n    \n    vector<xy_t> L(M);\n    REP(i, M){\n      cin >> L[i];\n    }\n    \n\n    REP(i, M){\n      poly_t pi = poly;\n      \n      REP(j, M) if (i != j){\n        pi = convex_cut(pi, bisector(L[i], L[j]));\n      }\n      \n      cout << area(pi) << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\ntypedef long double ld;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> LP;\ntypedef pair<ld, ld> LDP;\ntypedef complex<ld> Point;\nconst ll mod = 1000000007;\nconst ld INF = 1e+30;\nconst ld eps = 1e-8;\nconst ld pi = acos(-1.0);\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\n\nbool eq(ld a, ld b) {\n\treturn abs(a - b) < eps;\n}\nbool eq(Point a, Point b) {\n\treturn abs(a - b) < eps;\n}\n//内積\nld dot(Point a, Point b) {\n\treturn real(conj(a)*b);\n}\n//外積\nld cross(Point a, Point b) {\n\treturn imag(conj(a)*b);\n}\n//線分\n//直線にするなら十分通い２点を端点とすればよい\nclass Line {\npublic:\n\tPoint a, b;\n};\n//3点の位置関係\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps)return 1;//a,b,cが反時計回り\n\tif (cross(b, c) < -eps)return -1;//a,b,cが時計回り\n\tif (dot(b, c) < 0)return 2;//c,a,bの順に一直線\n\tif (norm(b) < norm(c))return -2;//a,b,cの順に一直線\n\treturn 0;//a,c,bの順に一直線\n}\nbool isis_ls(Line l, Line s) {\n\treturn (cross(l.b - l.a, s.a - l.a)*cross(l.b - l.a, s.b - l.a) < eps);\n}\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a; Point tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\nLine mid_line(Point a, Point b) {\n\tld mx = (real(a) + real(b)) / 2.0, my = (imag(a) + imag(b)) / 2.0;\n\tld dx = real(b) - real(a), dy = imag(b) - imag(a);\n\tswap(dx, dy); dx = -dx;\n\tPoint le = { mx + dx,my + dy }, ri = { mx - dx,my - dy };\n\treturn { le,ri };\n}\nld area(Point a, Point b, Point c) {\n\tld x1 = real(b) - real(a), y1 = imag(b) - imag(a);\n\tld x2 = real(c) - real(a), y2 = imag(c) - imag(a);\n\treturn abs(x1*y2 - y1 * x2) / 2.0;\n}\nvoid merge(vector<Point> &v, Line l, Point c) {\n\tvector<Point> p; vector<int>id;\n\trep(i, v.size()) {\n\t\tPoint le = v[i], ri = v[(i + 1) % ((int)v.size())];\n\t\tLine s = { le,ri };\n\t\tif (isis_ls(l, s)) {\n\t\t\tPoint nex = is_ll(l, s);\n\t\t\tbool f = true;\n\t\t\trep(j, p.size()) {\n\t\t\t\tif (eq(p[j], nex))f = false;\n\t\t\t}\n\t\t\tif (f) {\n\t\t\t\tp.push_back(nex); id.push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\tif (p.size() != 2)return;\n\tif (ccw(p[0], p[1], c) == -1) {\n\t\tswap(p[0], p[1]); swap(id[0], id[1]);\n\t}\n\tvector<Point> cop;\n\tcop.push_back(v[id[0]]);\n\tif (!eq(v[id[0]], p[0]))cop.push_back(p[0]);\n\tid[1] = (id[1] + 1) % (int)v.size();\n\tif (!eq(v[id[1]], p[1]))cop.push_back(p[1]);\n\tint cur = id[1];\n\twhile (cur != id[0]) {\n\t\tcop.push_back(v[cur]);\n\t\tcur = (cur + 1) % (int)v.size();\n\t}\n\tv = cop;\n}\nld calc_area(vector<Point> &v, Point c) {\n\tld ret = 0;\n\trep(i, v.size()) {\n\t\tPoint le = v[i], ri = v[(i + 1) % (int)v.size()];\n\t\tret += area(le, ri, c);\n\t}\n\treturn ret;\n}\nvoid solve() {\n\tcout << fixed << setprecision(6);\n\tint n, m;\n\twhile (cin >> n >> m, n) {\n\t\tvector<Point> v;\n\t\trep(i, n) {\n\t\t\tld x, y; cin >> x >> y;\n\t\t\tv.push_back({ x,y });\n\t\t}\n\t\tvector<Point> c(m);\n\t\trep(i, m) {\n\t\t\tld x, y; cin >> x >> y;\n\t\t\tc[i] = { x,y };\n\t\t}\n\t\trep(i, m) {\n\t\t\tvector<Point> u = v;\n\t\t\trep(j, m) {\n\t\t\t\tif (i == j)continue;\n\t\t\t\tLine l = mid_line(c[i], c[j]);\n\t\t\t\tmerge(u, l, c[i]);\n\t\t\t\t/*cout << j << \" hello\" << endl;\n\t\t\t\trep(j, u.size()) {\n\t\t\t\t\tcout << u[j] << endl;\n\t\t\t\t}*/\n\t\t\t}\n\t\t\tcout << calc_area(u,c[i]) << endl;\n\t\t}\n\t}\n}\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<cmath>\n#include<vector>\n#include<cstdlib>\n#include<cassert>\n#include<map>\n#include<iomanip>\n#define _A_ true\n#define EPS 1e-10\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\nusing namespace std;\nclass Point{\npublic:\n  double x,y;\n  Point(double x =0,double y=0):x(x),y(y){}\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(x*a,y*a);}\n  Point operator / (double a){return Point(x/a,y/a);} //もし悪を使うなら要確認\n \n  double norm() {return x*x+y*y;}\n  double abs() {return sqrt(norm());}\n \n  bool operator < (const Point &p) const{\n    return x != p.x ? x < p.x : y < p.y; \n  }\n \n  bool operator == (const Point &p) const{\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\ntypedef Point Point;\nstruct Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p = Point(),Point pp = Point()):p1(p),p2(pp){}\n};\n \ntypedef vector<Point> Polygon;\ntypedef Segment Line;\n \ndouble norm(Point p){\n  return p.x*p.x+p.y*p.y;\n}\n \ndouble abs(Point p){\n  return sqrt(norm(p));\n}\n \nPoint polar(double a,double rad){\n  return Point(a*cos(rad),a*sin(rad));\n}\n \ndouble args(Point p){\n  return atan2(p.y,p.x);\n}\n \ndouble dot(Point a,Point b){\n  return a.x*b.x+a.y*b.y;\n}\n \ndouble cross(Point a,Point b){\n  return a.x*b.y-b.x*a.y;\n}\n \nPoint project(Segment s,Point p){\n  Point base = s.p2 - s.p1;\n  double t = dot(p-s.p1,base)/base.norm();\n  return s.p1+base*t;\n}\n \nPoint reflect (Segment s, Point p){\n  return p + (project(s,p)-p)*2.0;\n}\n \nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CLOCKWISE;\n  if(dot(a,b) < -EPS) return ONLINE_BACK;\n  if(a.norm() < b.norm() ) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n \nbool isIntersect(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <= 0 && ccw(p3,p4,p1) * ccw(p3,p4,p2) <= 0 );\n}\n \nbool isIntersect(Segment s1,Segment s2){\n  return isIntersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n/*\nPoint getCrossPoint(Segment s1,Segment s2){\n  assert(isIntersect(s1,s2));\n  P base = s2.p2 - s2.p1;\n  double d1 = abs(cross(base,s1.p1-s2.p1));\n  double d2 = abs(cross(base,s1.p2-s2.p1));\n  double t = d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n*/\n \nPoint getCrossPointLines( Line s1, Line s2){\n    Point a = s1.p2 - s1.p1;\n    Point base = Point(s2.p2.x - s2.p1.x,s2.p2.y - s2.p1.y);\n    return s1.p1 + a * cross(base, s2.p1 - s1.p1)/cross(base, a);\n}\n \nPolygon cutPolygon( Polygon P, Line l ){\n    Polygon u;\n    \n    for ( int i = 0; i < P.size(); i++ ){\n        Point a = P[i], b = P[(i+1)%P.size()];\n        if ( ccw(l.p1, l.p2, a) != CLOCKWISE ) u.push_back(a);\n        if ( ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) == -1 ){\n      u.push_back(getCrossPointLines(Segment(a, b), l));\n      \n        }\n    }\n   \n    return u;\n}\n \n \n \nLine CreateLine(Point p,Point pp){\n  Point mid = (p+pp)/2;\n \n  Point sl = pp-p;//原点に5\n  double rad = args(sl);\n  Point ap = polar(abs(sl),rad+M_PI/2)+mid;\n  //ap.x = abs(sl)*cos(rad+M_PI/2)+mid.x;\n  //ap.y = abs(sl)*sin(rad+M_PI/2)+mid.y;\n  return Line(mid,ap);\n}\n \n \ndouble AreaCalc(Polygon p){\n  double area = 0;\n  p.push_back(p[0]);\n  for(int i=0;i<p.size()-1;i++){\n    area+=cross(p[i],p[i+1]);\n  }\n  return abs(area/2);\n}\n \n \n \n \n \nint main(){\n  int N,M;\n  while(cin >> N >> M,N|M){\n  \n  vector<Point> l(N);\n  vector<Point> C(M);\n  for(int i=0;i<N;i++)\n    cin >> l[i].x >> l[i].y;\n  for(int i=0;i<M;i++)\n    cin >> C[i].x >> C[i].y;\n\n  for(int i=0;i<N;i++)\n    {\n      Polygon poly; \n      for(int j=0;j<M;j++)\n\tpoly.push_back(l[j]);\n      for(int j=0;j<N;j++)\n\t{\n\t  if(j == i)\n\t    continue;\n\t  poly = cutPolygon(poly,CreateLine(C[i],C[j]));\n\t}\n      cout << setiosflags(ios::fixed) << setprecision(1) << AreaCalc(poly) << endl;\n\n    }  \n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef pair<P,P> L;\n\nconst double EPS = 1E-6;\n\ndouble dot(P a, P b){ return real(conj(a)*b); }\ndouble cross(P a, P b){ return imag(conj(a)*b); }\n\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > EPS) return 1;\n  if(cross(b,c) < -EPS) return -1;\n  if(dot(b,c) < -EPS) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n\ndouble area(vector<P> v){\n  double sum = 0.0;\n  int n = v.size();\n  for(int i=0;i<n;i++) sum += (real(v[i]) - real(v[(i+1)%n])) * (imag(v[i]) + imag(v[(i+1)%n]));\n  return fabs(sum) / 2;\n};\n\nP crossPoint(L l, L m){\n  double A = cross(l.second - l.first, m.second - m.first);\n  double B = cross(l.second - l.first, l.second - m.first);\n  if(fabs(A) < EPS && fabs(B) < EPS) return m.first;\n  else if(fabs(A) >= EPS) return m.first + B / A * (m.second - m.first);\n}\n\nvector<P> convex_cut(vector<P> G, L l){\n  vector<P> ans;\n  for(int i=0;i<G.size();i++){\n    P A = G[i];\n    P B = G[(i+1)%G.size()];\n    if(ccw(l.first, l.second, A) != -1) ans.push_back(A);\n    if(ccw(l.first, l.second, A) * ccw(l.first, l.second, B) < 0)\n      ans.push_back(crossPoint(L(A,B), l));\n  }\n  return ans;\n}\n\n\nint N,M;\nvector<P> V,C;\n\nint main(){\n\n  while( cin >> N >> M && (N||M) ){\n    for(int i=0;i<N;i++){\n      int x,y; cin >> x >> y;\n      V.push_back(P(x,y));\n    }\n    for(int i=0;i<M;i++){\n      int x,y; cin >> x >> y;\n      C.push_back(P(x,y));\n    }\n\n    for(int i=0;i<M;i++){\n      vector<P> sp = V;\n      for(int j=0;j<M;j++){\n\tif( i == j ) continue;\n\tP c = (C[i] - C[j])/2.0 + C[j];\n\tP r = C[i]-C[j];\n\tr = P( r.imag(), -r.real() );\n\tL s = L(c,c+r);\n\t//\tcout << i << \" <> \" << j << \" \" << s.first << \" \"<< s.second << endl;\n\tsp = convex_cut(sp,s);\n      }\n      printf(\"%.10lf\\n\",area(sp));\n    }\n\n\n  }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cassert>\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n\n#define x first\n#define y second\n\nusing namespace std;\n\ntypedef pair<double, double> Point;\n\nclass Line {\n  public:\n    double a, b, c;\n\n    Line(const double _a = 0.0, const double _b = 0.0, const double _c = 0.0):\n      a(_a),\n      b(_b),\n      c(_c) {}\n\n    Line(const Point &p1, const Point &p2):\n      a(p1.y - p2.y),\n      b(p2.x - p1.x),\n      c(p1.x * p2.y - p1.y * p2.x) {}\n};\n\nvector<Line> Plane;\nvector<Point> Points;\nvector<double> Areas;\n\ninline double Det(const Point &a, const Point &b, const Point &c) {\n    return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\n}\n\nclass Compare {\n  public:\n    static Point origin;\n\n    bool operator()(const Point &a, const Point &b) const {\n        return Det(origin, a, b) >= 0;\n    }\n};\n\nPoint Compare::origin;\n\nvector<Point> ConvexHull(vector<Point> points) {\n    int n = int(points.size());\n    int origin = 0;\n    for (int i = 1; i < n; ++i)\n        if (points[i] < points[origin])\n            origin = i;\n    swap(points[0], points[origin]);\n    Compare::origin = points[0];\n    sort(points.begin() + 1, points.end(), Compare());\n    points.push_back(points[0]);\n    vector<Point> hull;\n    for (int i = 0; i < int(points.size()); ++i) {\n        while (int(hull.size()) > 1 && Det(hull[int(hull.size()) - 2], hull[int(hull.size()) - 1], points[i]) <= 0)\n            hull.pop_back();\n        hull.push_back(points[i]);\n    }\n    hull.pop_back();\n    return hull;\n}\n\ninline Point Dualize(const Line &l) {\n    if (l.c == 0)\n        return Point(0, 0);\n    else\n        return Point(l.a / l.c, l.b / l.c);\n}\n\ninline Line Dualize(const Point &p) {\n    return Line(p.x, p.y, 1);\n}\n\ninline Point Translate(const Point &p, const Point &shift) {\n    return Point(p.x + shift.x, p.y + shift.y);\n}\n\ninline Line Translate(const Line &l, const Point &shift) {\n    return Line(l.a, l.b, l.c - l.a * shift.x - l.b * shift.y);\n}\n\nvector< vector<Point> > GetVoronoiDiagrams(const vector<Line> &plane, const vector<Point> &points) {\n    int n = int(points.size());\n    vector< vector<Point> > voronoiDiagrams = vector< vector<Point> >(n, vector<Point>());\n    for (int i = 0; i < n; ++i) {\n        Point shift = Point(-points[i].x, -points[i].y);\n        vector<Point> dualizedLines;\n        for (int j = 0; j < int(plane.size()); ++j)\n            dualizedLines.push_back(Dualize(Translate(plane[j], shift)));\n        for (int j = 0; j < n; ++j) {\n            if (i != j) {\n                Point a = points[i], b = points[j];\n                dualizedLines.push_back(Dualize(Translate(Line(2 * (b.x - a.x), 2 * (b.y - a.y), a.x * a.x + a.y * a.y - b.x * b.x - b.y * b.y), shift)));\n            }\n        }\n        vector<Point> hull = ConvexHull(dualizedLines);\n        for (int j = 0; j < int(hull.size()); ++j)\n            voronoiDiagrams[i].push_back(Translate(Dualize(Line(hull[j], hull[(j + 1) % int(hull.size())])), points[i]));\n    }\n    return voronoiDiagrams;\n}\n\ninline double GetArea(const vector<Point> &polygon) {\n    int n = int(polygon.size());\n    double area = 0.0;\n    for (int i = 0; i < n; ++i)\n        area += polygon[i].x * polygon[(i + 1) % n].y - polygon[(i + 1) % n].x * polygon[i].y;\n    area /= 2.0;\n    if (area < 0.0)\n        area = -area;\n    return area;\n}\n\nvoid Solve() {\n    vector< vector<Point> > voronoi = GetVoronoiDiagrams(Plane, Points);\n    Areas = vector<double>(int(Points.size()), 0.0);\n    for (int i = 0; i < int(Points.size()); ++i)\n        Areas[i] = GetArea(voronoi[i]);\n}\n\nbool Read() {\n    int n, m;\n    cin >> n >> m;\n    if (n == 0 && m == 0)\n        return false;\n    vector<Point> planePolygon = vector<Point>(n);\n    for (int i = 0; i < n; ++i)\n        cin >> planePolygon[i].x >> planePolygon[i].y;\n    Plane = vector<Line>(n);\n    for (int i = 0; i < n; ++i)\n        Plane[i] = Line(planePolygon[i], planePolygon[(i + 1) % n]);\n    Points = vector<Point>(m);\n    for (int i = 0; i < m; ++i)\n        cin >> Points[i].x >> Points[i].y;\n    return true;\n}\n\nvoid Print() {\n    for (int i = 0; i < int(Points.size()); ++i)\n        printf(\"%.7lf\\n\", Areas[i]);\n}\n\nint main() {\n    //assert(freopen(\"voronoi.in\", \"r\", stdin));\n    //assert(freopen(\"voronoi.out\", \"w\", stdout));\n    while (Read()) {\n        Solve();\n        Print();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\ntypedef complex<double> Point;\ntypedef Point Vector;\nstruct Segment{\t\t\t\t\t//線分を表す構造体\n\tPoint p1, p2;\n\tSegment(Point p1 = Point(), Point p2 = Point()) : p1(p1), p2(p2) {}\n};\ntypedef Segment Line;\t\t\t//直線を表す構造体\ntypedef vector<Point> Polygon;\t//多角形を表す構造体\n\nnamespace std{\n\tbool operator < (const Point &a, const Point &b){\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n\tbool operator == (const Point &a, const Point &b){\n\t\treturn a.real() == b.real() && a.imag() == b.imag();\n\t}\n}\n\nclass Circle{\n\tpublic:\n\t\tPoint p;\n\t\tdouble r;\n\t\tCircle(Point p = Point(), double r = 0.0): p(p), r(r) {}\n};\n\n// 許容する誤差\n#define EPS (1e-10)\n#define INF (1e10)\n\n// ベクトルaの絶対値を求める\n//double length = abs(a);\n\n// 2点a,b間の距離を求める\n//double distance = abs(a-b);\n\n/*\n// ベクトルaの単位ベクトルを求める\nPoint b = a / abs(a);\n\n// ベクトルaの法線ベクトルn1,n2を求める\nPoint n1 = a * Point(0, 1);\nPoint n2 = a * Point(0, -1);\n*/\n\nint ccw(Point, Point, Point);\n\n// 2つのスカラーが等しいかどうか\nbool EQ(double a, double b){\n\treturn (abs(a - b) < EPS);\n}\n\n// 2つのベクトルが等しいかどうか\nbool EQV(Vector a, Vector b){\n\treturn ( EQ(a.real(), b.real()) && EQ(a.imag(), b.imag()) );\n}\n\n// 内積 (dot product) : a・b = |a||b|cosΘ\ndouble dot(Point a, Point b) {\n\treturn (a.real() * b.real() + a.imag() * b.imag());\n}\n\n// 外積 (cross product) : a×b = |a||b|sinΘ\ndouble cross(Point a, Point b) {\n\treturn (a.real() * b.imag() - a.imag() * b.real());\n}\n\n// 2直線の直交判定 : a⊥b <=> dot(a, b) = 0\nbool isOrthogonal(Point a1, Point a2, Point b1, Point b2) {\n\treturn EQ( dot(a1-a2, b1-b2), 0.0 );\n}\nbool isOrthogonal(Line s1, Line s2) { return isOrthogonal(s1.p1, s1.p2, s2.p1, s2.p2); }\n\n// 2直線の平行判定 : a//b <=> cross(a, b) = 0\nbool isParallel(Point a1, Point a2, Point b1, Point b2) {\n\treturn EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isParallel(Line s1, Line s2) { return isParallel(s1.p1, s1.p2, s2.p1, s2.p2); }\n\n// 点cが直線a,b上にあるかないか\nbool isPointOnLine(Point a, Point b, Point c) {\n\treturn EQ( cross(b-a, c-a), 0.0 );\n}\nbool isPointOnLine(Line s, Point c) { return isPointOnLine(s.p1, s.p2, c); }\n\n// 点a,bを通る直線と点cとの距離\ndouble distanceLPoint(Point a, Point b, Point c) {\n\treturn abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLPoint(Line s, Point c) { return distanceLPoint(s.p1, s.p2, c); }\n\n// 点a,bを端点とする線分と点cとの距離\ndouble distanceLsPoint(Point a, Point b, Point c) {\n\tif ( dot(b-a, c-a) < EPS ) return abs(c-a);\n\tif ( dot(a-b, c-b) < EPS ) return abs(c-b);\n\treturn abs(cross(b-a, c-a)) / abs(b-a);\n}\ndouble distanceLsPoint(Segment s, Point c) { return distanceLsPoint(s.p1, s.p2, c); }\n\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交差判定\n// 端点が重なる場合も、線分が交差しているとみなす\nbool isIntersectedLs(Point a1, Point a2, Point b1, Point b2) {\n\treturn ( ccw(a1, a2, b1) * ccw(a1, a2, b2) <= 0 &&\n\t\t\tccw(b1, b2, a1) * ccw(b1, b2, a2) <= 0 );\n}\nbool isIntersectedLs(Segment s1, Segment s2) { return isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2); }\n\n// 端点が重なっているかを検出する\nbool isContainSamePoints(Segment s1, Segment s2){\n\tif(abs(s1.p1 - s2.p1) < EPS) return true;\n\tif(abs(s1.p1 - s2.p2) < EPS) return true;\n\tif(abs(s1.p2 - s2.p1) < EPS) return true;\n\tif(abs(s1.p2 - s2.p2) < EPS) return true;\n\treturn false;\n}\n\n// a1,a2を端点とする線分とb1,b2を端点とする線分の交点計算\nPoint intersectionLs(Point a1, Point a2, Point b1, Point b2) {\n\tVector base = b2 - b1;\n\tdouble d1 = abs(cross(base, a1 - b1));\n\tdouble d2 = abs(cross(base, a2 - b1));\n\tdouble t = d1 / (d1 + d2);\n\n\treturn Point(a1 + (a2 - a1) * t);\n}\nPoint intersectionLs(Segment s1, Segment s2) { return intersectionLs(s1.p1, s1.p2, s2.p1, s2.p2); }\n\n// a1,a2を通る直線とb1,b2を通る直線の交差判定\nbool isIntersectedL(Point a1, Point a2, Point b1, Point b2) {\n\treturn !EQ( cross(a1-a2, b1-b2), 0.0 );\n}\nbool isIntersectedL(Line l1, Line l2) { return isIntersectedL(l1.p1, l1.p2, l2.p1, l2.p2); }\n\n// a1,a2を通る直線とb1,b2を通る直線の交点計算\nPoint intersectionL(Point a1, Point a2, Point b1, Point b2) {\n\tPoint a = a2 - a1; Point b = b2 - b1;\n\treturn a1 + a * cross(b, b1-a1) / cross(b, a);\n}\nPoint intersectionL(Line l1, Line l2) { return intersectionL(l1.p1, l1.p2, l2.p1, l2.p2); }\n\n// 線分s1と線分s2の距離\ndouble distanceLL(Segment s1, Segment s2){\n\tif(isIntersectedLs(s1.p1, s1.p2, s2.p1, s2.p2) ) return 0.0;\n\treturn min(\n\t\t\tmin(distanceLsPoint(s1.p1, s1.p2, s2.p1),\n\t\t\t\tdistanceLsPoint(s1.p1, s1.p2, s2.p2)),\n\t\t\tmin(distanceLsPoint(s2.p1, s2.p2, s1.p1),\n\t\t\t\tdistanceLsPoint(s2.p1, s2.p2, s1.p2)) );\n}\ndouble distanceLL(Point p0, Point p1, Point p2, Point p3){\n\tSegment s1 = Segment{p0, p1}, s2 = Segment{p2, p3};\n\treturn distanceLL(s1, s2);\n}\n\n// 線分sに対する点pの射影\nPoint project(Segment s, Point p){\n\tVector base = s.p2 - s.p1;\n\tdouble r = dot(p - s.p1, base) / norm(base);\n\treturn Point(s.p1 + base * r);\n}\n\n//線分sを対象軸とした点pの線対称の点\nPoint reflect(Segment s, Point p){\n\treturn Point(p + (project(s, p) - p) * 2.0);\n}\n\n//点pをangle分だけ時計回りに回転\nPoint rotation(Point p, double angle){\n\tdouble x, y;\n\tx = p.real() * cos(angle) - p.imag() * sin(angle);\n\ty = p.real() * sin(angle) + p.imag() * cos(angle);\n\treturn Point(x, y);\n}\n\n//円cと線分lの交点\npair<Point, Point> getCrossPoints(Circle c, Line l){\n\tVector pr = project(l, c.p);\n\tVector e = (l.p2 - l.p1) / abs(l.p2 - l.p1);\n\tdouble base = sqrt(c.r * c.r - norm(pr - c.p));\n\treturn make_pair(pr + e * base, pr - e * base);\n}\n\n//円c1と円c2の交点\ndouble arg(Vector p) { return atan2(p.imag(), p.real()); }\nVector polar(double a, double r) { return Point(cos(r) * a, sin(r) *a); }\n\npair<Point, Point> getCrossPoints(Circle c1, Circle c2){\n\tdouble d = abs(c1.p - c2.p);\n\tdouble a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n\tdouble t = arg(c2.p - c1.p);\n\treturn make_pair(Point(c1.p + polar(c1.r, t + a)), Point(c1.p + polar(c1.r, t - a)));\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0, Point p1, Point p2){\n\tVector a = p1 - p0;\n\tVector b = p2 - p0;\n\tif( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n\tif( cross(a, b) < -EPS ) return CLOCKWISE;\n\tif( dot(a, b) < -EPS ) return ONLINE_BACK;\n\tif( abs(a) < abs(b) ) return ONLINE_FRONT;\n\n\treturn ON_SEGMENT;\n}\n\nPoint getCrossPointLL(Line a, Line b){\n\tdouble A = cross(a.p2 - a.p1, b.p2 - b.p1);\n\tdouble B = cross(a.p2 - a.p1, a.p2 - b.p1);\n\tif(abs(A) < EPS && abs(B) < EPS) return b.p1;\n\treturn b.p1 + (b.p2 - b.p1) * (B / A);\n}\n\nPolygon convexCut(Polygon p, Line l) {\n\tPolygon q;\n\trep(i,p.size()){\n\t\tPoint a = p[i], b = p[(i + 1) % p.size()];\n\t\tif (ccw(l.p1, l.p2, a) != -1) q.emplace_back(a);\n\t\tif (ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) < 0){\n\t\t\tq.emplace_back(getCrossPointLL(Line{a, b}, l));\n\t\t}\n\t}\n\treturn q;\n}\n\nLine bisector(Point a, Point b) {\n\tPoint A = (a + b) * Point(0.5, 0);\n\treturn Line(A, A + (b - a) * Point(0, M_PI / 2));\n}\n\nPolygon voronoiCell(Polygon g, vector<Point> v, int s) {\n\trep(i, v.size()){\n\t\tif (i != s) g = convexCut(g, bisector(v[s], v[i]));\n\t}\n\treturn g;\n}\n\n//三角形の面積\ndouble areaOfTriangle(Point a, Point b, Point c){\n\tdouble w, x, y, z;\n\tw = b.real()-a.real();\n\tx = b.imag()-a.imag();\n\ty = c.real()-a.real();\n\tz = c.imag()-a.imag();\n\treturn abs((w * z - x * y) / 2);\n}\n\n//多角形の面積\ndouble areaOfPolygon(Polygon g){\n\tint n = g.size();\n\tdouble ret = 0.0;\n\trep(i,n) ret += cross(g[i], g[ (i + 1) % n ]);\n\treturn abs(ret) / 2.0;\n}\n\nint main(){\n\tint n, m;\n\twhile(cin >> n >> m, n){\n\t\tPolygon g(n);\n\t\trep(i,n){\n\t\t\tdouble a, b;\n\t\t\tcin >> a >> b;\n\t\t\tg[i] = Point(a,b);\n\t\t}\n\n\t\tvector<Point> v(m);\n\t\trep(i,m){\n\t\t\tdouble a, b;\n\t\t\tcin >> a >> b;\n\t\t\tv[i] = Point(a,b);\n\t\t}\n\n\t\trep(i,n){\n\t\t\tcout << fixed << setprecision(10) << areaOfPolygon(voronoiCell(g, v, i)) << endl;\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<math.h>\n#include<vector>\nusing namespace std;\nconst double EPS = 1e-10;\nconst double INF = 1e+10;\nconst double PI = acos(-1);\ninline double ABS(double a){return max(a,-a);}\nint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\nstruct Pt {\n\tdouble x, y;\n\tPt() {}\n\tPt(double x, double y) : x(x), y(y) {}\n\tPt operator+(const Pt &a) const { return Pt(x + a.x, y + a.y); }\n\tPt operator-(const Pt &a) const { return Pt(x - a.x, y - a.y); }\n\tPt operator*(const Pt &a) const { return Pt(x * a.x - y * a.y, x * a.y + y * a.x); }\n\tPt operator-() const { return Pt(-x, -y); }\n\tPt operator*(const double &k) const { return Pt(x * k, y * k); }\n\tPt operator/(const double &k) const { return Pt(x / k, y / k); }\n\tdouble abs() const { return sqrt(x * x + y * y); }\n\tdouble abs2() const { return x * x + y * y; }\n\tdouble arg() const { return atan2(y, x); }\n\tdouble dot(const Pt &a) const { return x * a.x + y * a.y; }\n\tdouble det(const Pt &a) const { return x * a.y - y * a.x; }\n};\ndouble tri(const Pt &a, const Pt &b, const Pt &c) { return (b - a).det(c - a); }\nint iSP(Pt a, Pt b, Pt c) {\n\tint s = sig((b - a).det(c - a));\n\tif (s) return s;\n\tif (sig((b - a).dot(c - a)) < 0) return -2; // c-a-b\n\tif (sig((a - b).dot(c - b)) < 0) return +2; // a-b-c\n\treturn 0;\n}\nint iLL(Pt a, Pt b, Pt c, Pt d) {\n\tif (sig((b - a).det(d - c))) return 1; // intersect\n\tif (sig((b - a).det(c - a))) return 0; // parallel\n\treturn -1; // correspond\n}\nbool iLS(Pt a, Pt b, Pt c, Pt d) {\n\treturn (sig(tri(a, b, c)) * sig(tri(a, b, d)) <= 0);\n}\nbool iSS(Pt a, Pt b, Pt c, Pt d) {\n\treturn (iSP(a, b, c) * iSP(a, b, d) <= 0 && iSP(c, d, a) * iSP(c, d, b) <= 0);\n}\nbool iSSstrict(Pt a, Pt b, Pt c, Pt d) {\n\treturn (sig(tri(a, b, c)) * sig(tri(a, b, d)) < 0 && sig(tri(c, d, a)) * sig(tri(c, d, b)) < 0);\n}\nPt pLL(Pt a, Pt b, Pt c, Pt d) {\n\tb = b - a; d = d - c; return a + b * (c - a).det(d) / b.det(d);\n}\ndouble dLP(Pt a, Pt b, Pt c) {\n\treturn ABS(tri(a, b, c)) / (b - a).abs();\n}\ndouble dSP(Pt a, Pt b, Pt c) {\n\tif (sig((b - a).dot(c - a)) <= 0) return (c - a).abs();\n\tif (sig((a - b).dot(c - b)) <= 0) return (c - b).abs();\n\treturn ABS(tri(a, b, c)) / (b - a).abs();\n}\ndouble dLL(Pt a, Pt b, Pt c, Pt d) {\n\treturn iLL(a, b, c, d) ? 0 : dLP(a, b, c);\n}\ndouble dLS(Pt a, Pt b, Pt c, Pt d) {\n\treturn iLS(a, b, c, d) ? 0 : min(dLP(a, b, c), dLP(a, b, d));\n}\ndouble dSS(Pt a, Pt b, Pt c, Pt d) {\n\treturn iSS(a, b, c, d) ? 0 : min(min(dSP(a, b, c), dSP(a, b, d)), min(dSP(c, d, a), dSP(c, d, b)));\n}\nvector<Pt> convexCut(int n, vector<Pt>p, Pt a, Pt b) {\n\tint m = 0, i;\n\tp.push_back(p[0]);\n\tvector<Pt>q;\n\tfor (i = 0; i < n; ++i) {\n\t//\tprintf(\"%d %d\\n\",i,q.size());\n\t\tif (sig(tri(a, b, p[i])) >= 0) q.push_back(p[i]);\n\t\tif (sig(tri(a, b, p[i])) * sig(tri(a, b, p[i + 1])) < 0)\n\t\t\tq.push_back(pLL(a, b, p[i], p[i + 1]));\n\t}\n\treturn q;\n}\nPt c[23];\nPt d[23];\nvector<vector<Pt> > poly[12];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tvector<Pt>s;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tdouble x,y;scanf(\"%lf%lf\",&x,&y);\n\t\t\tc[i]=Pt(x,y);\n\t\t\ts.push_back(c[i]);\n\t\t}\n\t\tfor(int i=0;i<b;i++){\n\t\t\tdouble x,y;scanf(\"%lf%lf\",&x,&y);\n\t\t\td[i]=Pt(x,y);\n\t\t}\n\t//\ts.push_back(c[0]);\n\t\tfor(int i=0;i<b;i++){\n\t\t\tvector<Pt> now=s;\n\t\t\tfor(int j=0;j<b;j++){\n\t\t\t\tif(i==j)continue;\n\t\t\t\tpair<Pt,Pt> L=make_pair((d[i]+d[j])/2.0,(d[i]+d[j])/2.0+(d[i]-d[j])*Pt(0,1));\n\t\t\t\tnow=convexCut(now.size(),now,L.second,L.first);\n\t\t\t}\n\t\t\tdouble S=0;\n\t\t\tfor(int j=0;j<now.size();j++)S+=now[j].det(now[(j+1)%now.size()]);\n\t\t\tif(S<0)S=-S;\n\t\t\tprintf(\"%.12f\\n\",S/2);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define EPS 1e-10\n#define equal(a,b) (fabs(a-b) < EPS)\n#define lt(a,b) (a-b < -EPS)\n\nstruct Point{\n    double x,y;\n\n    Point(){}\n    Point(double x,double y) : x(x),y(y) {}\n\n    Point operator + (const Point &p)const{ return Point(x+p.x,y+p.y); }\n    Point operator - (const Point &p)const{ return Point(x-p.x,y-p.y); }\n    Point operator * (const double &k)const{ return Point(x*k,y*k); }\n};\n\ndouble dot(const Point &a,const Point &b){ return a.x*b.x + a.y*b.y; }\ndouble cross(const Point &a,const Point &b){ return a.x*b.y - b.x*a.y; }\ndouble norm(const Point &p){ return dot(p,p); }\ndouble abs(const Point &p){ return sqrt(norm(p)); }\n\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\ntypedef Point Vector;\n\nint ccw(Point p0,Point p1,Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if(cross(a,b) > EPS) return COUNTER_CLOCKWISE;\n    if(cross(a,b) < -EPS) return CLOCKWISE;\n    if(dot(a,b) < -EPS) return ONLINE_BACK;\n    if(norm(a) < norm(b)) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nstruct Segment{\n    Point s,t;\n    Segment(){}\n    Segment(Point s,Point t) : s(s),t(t) {}\n};\n\ntypedef Segment Line;\n\nLine getPerpendicularBisector(const Point &a,const Point &b){\n    double cx = (a.x + b.x) / 2.0;\n    double cy = (a.y + b.y) / 2.0;\n    Point p = Point(cx + (a.y - b.y), cy + (b.x - a.x));\n    return Line(Point(cx,cy),p);\n}\n\nPoint crosspointLL(const Line &a,const Line &b){\n    Vector va = a.t-a.s, vb = b.t-b.s;\n    double d = cross(vb,va);\n    if(abs(d) < EPS) return b.s;\n    return a.s+va*cross(vb,b.t-a.s)*(1.0/d);\n}\n\n#define prev(G,i) (G[(i-1+G.size())%G.size()])\n#define curr(G,i) (G[i%G.size()])\n#define next(G,i) (G[(i+1)%G.size()])\ntypedef vector<Point> Polygon;\n\nPolygon convex_cut(const Polygon &pg,const Line &l){\n    Polygon res;\n    for(int i = 0 ; i < (int)pg.size() ; i++){\n\tPoint cp = curr(pg,i), np = next(pg,i);\n\tif(ccw(l.s,l.t,cp) != -1) res.push_back(cp);\n\tif(ccw(l.s,l.t,cp)*ccw(l.s,l.t,np) < 0){\n\t    res.push_back(crosspointLL(Line(cp,np),l));\n\t}\n    }\n    return res;\n}\n\t\ndouble area(const Polygon &pg){\n    double res = 0;\n    for(int i = 0 ; i < (int)pg.size() ; i++){\n\tres += cross(pg[i],next(pg,i));\n    }\n    return abs(res)/2.0;\n}\n\nint main(){\n    int N,M;\n    while(cin >> N >> M, N){\n\tPolygon pg(N);\n\tfor(int i = 0 ; i < N ; i++){\n\t    cin >> pg[i].x >> pg[i].y;\n\t}\n\tvector<Point> ps(M);\n\tfor(int i = 0 ; i < M ; i++){\n\t    cin >> ps[i].x >> ps[i].y;\n\t}\n\tfor(int i = 0 ; i < M ; i++){\n\t    Polygon p = pg;\n\t    for(int j = 0 ; j < M ; j++){\n\t\tif(i == j) continue;\n\t\tp = convex_cut(p,\n\t\t\t       getPerpendicularBisector(ps[i],ps[j]));\n\t    }\n\t    printf(\"%.15f\\n\",area(p));\n\t}\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate<class T>\nbool chmin(T& a, const T& b) {\n    if (b < a) { a = b; return true; }\n    return false;\n}\n\n// std::vector Declaration\ntemplate<typename T>\nvector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T, typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));\n}\n\n// std::vector Declaration and Initialization\ntemplate<typename T>\nvector<T> make_vector(size_t a, T x) { return vector<T>(a, x); }\ntemplate<typename T, typename U, typename... Ts>\nauto make_vector(size_t a, U b, Ts... ts) {\n    return vector<decltype(make_vector<T>(b,ts...))>(a, make_vector<T>(b, ts...));\n}\n\n// std::vector Input\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& v) {\n    for (auto &e : v) is >> e;\n    return is;\n}\n\n// std::vector Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::array Debug\ntemplate<typename T, size_t n>\nostream& operator<<(ostream& os, const array<T, n>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::deque Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const deque<T>& d) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : d) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::pair Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \" \" << p.second << \")\";\n    return os;\n}\n\n// std::set Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const set<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::multiset Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const multiset<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::map Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const map<T, U>& mp) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : mp) {\n        os << (a ? \"\" : \" \");\n        os << e.first << \":\" << e.second;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::tuple Debug\ntemplate<int N, class Tuple>\nvoid out(ostream& os, const Tuple& t){}\ntemplate<int N, class Tuple, class H, class ...Ts>\nvoid out(ostream& os, const Tuple& t) {\n    if (N) os << \" \";\n    os << get<N>(t);\n    out<N+1,Tuple,Ts...>(os, t);\n}\ntemplate<class ...Ts>\nostream& operator<<(ostream& os, const tuple<Ts...>& t) {\n    os << \"(\";\n    out<0,tuple<Ts...>,Ts...>(os, t);\n    os << \")\";\n    return os;\n}\n\n// Debug\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n\n// Weighted edge\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n\n    edge() {}\n    edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n    edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n    friend ostream& operator<<(ostream& os, const edge& e) {\n        return os << \"(\" << e.src << \"->\" << e.to << \":\" << e.cost << \")\";\n    }\n};\n\nusing LL = int64_t;\n\n#define fs first\n#define sc second\n\nconst int64_t MOD = 1e9+7;\n\n\nusing Real = double;\nReal EPS = 1e-8;\n\nusing Point = complex<Real>;\nstruct Line {\n    Point a, b;\n    Line() {}\n    Line(const Point& a, const Point& b) : a(a), b(b) {}\n    friend ostream& operator<<(ostream& os, Line& l) {\n        return os << \"[\" << l.a << \",\" << l.b << \"]\";\n    }\n};\nstruct Segment : Line {\n    Segment() = default;\n\n    Segment(const Point& a, const Point& b) : Line(a, b) {}\n};\n\ninline bool eq(Real a, Real b) { return abs(b - a) < EPS; }\n\nReal radian_to_degree(Real r) {\n    return r * 180.0 / M_PI;\n}\n\nReal degree_to_radian(Real d) {\n    return d * M_PI / 180.0;\n}\n\nPoint rotate(const Point &p, Real theta) {\n    return p * polar(1., theta);\n}\n\nReal cross(const Point& a, const Point& b) {\n    return a.real() * b.imag() - a.imag() * b.real();\n}\n\nReal dot(const Point& a, const Point& b) {\n    return a.real() * b.real() + a.imag() * b.imag();\n}\n\nPoint projection(const Line& l, const Point& p) {\n    Real A = dot(l.b - l.a, p - l.a),\n         B = dot(l.a - l.b, p - l.b);\n    return (A * l.b + B * l.a) / (A + B);\n}\n\nbool parallel(const Line& l1, const Line& l2) {\n    return eq(cross(l1.a - l1.b, l2.a - l2.b), 0.0);\n}\n\nbool orthogonal(const Line& l1, const Line& l2) {\n    return eq(dot(l1.a - l1.b, l2.a - l2.b), 0.0);\n}\n\nconst int COUNTER_CLOCKWISE = 1,\n          CLOCKWISE = -1,\n          ONLINE_BACK = 2,\n          ONLINE_FRONT = -2,\n          ON_SEGMENT = 0;\nint ccw(const Point& a, Point b, Point c) {\n    b = b - a, c = c - a;\n    if (cross(b, c) > EPS) return COUNTER_CLOCKWISE;\n    if (cross(b, c) < -EPS) return CLOCKWISE;\n    if (dot(b, c) < 0) return ONLINE_BACK;\n    if (norm(b) < norm(c)) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nbool intersected(const Line& l, const Point& p) {\n    return abs(ccw(l.a, l.b, p)) != 1;\n}\n\nbool intersected(const Segment& s, const Point& p) {\n    return ccw(s.a, s.b, p) == 0;\n}\n\nbool intersected(const Line& l, const Segment& s) {\n    return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool intersected(const Segment& s1, const Segment& s2) {\n    return ccw(s1.a, s1.b, s2.a) * ccw(s1.a, s1.b, s2.b) <= 0 and\n           ccw(s2.a, s2.b, s1.a) * ccw(s2.a, s2.b, s1.b) <= 0;\n}\n\nReal distance(const Line& l, const Point& p) {\n    return abs(p - projection(l, p));\n}\n\nReal distance(const Segment& s, const Point& p) {\n    Point r = projection(s, p);\n    if (intersected(s, r)) return abs(r - p);\n    return min(abs(s.a - p), abs(s.b - p));\n}\n\nReal distance(const Line &l, const Segment &s) {\n    if (intersected(l, s)) return 0;\n    return min(distance(l, s.a), distance(l, s.b));\n}\n\nReal distance(const Segment& s1, const Segment& s2) {\n    if (intersected(s1, s2)) return 0.0;\n    return min({ distance(s1, s2.a), distance(s1, s2.b),\n                 distance(s2, s1.a), distance(s2, s1.b) });\n}\n\nPoint crosspoint(const Line& l1, const Line& l2) {\n    Real A = cross(l2.a - l1.a, l2.b - l1.a),\n         B = cross(l2.b - l1.b, l2.a - l1.b);\n    return (A * l1.b + B * l1.a) / (A + B);\n}\n\nusing Polygon = vector<Point>;\nPolygon convex_cut(const Polygon& U, const Line& l) {\n    Polygon ret;\n    for (int i = 0; i < U.size(); i++) {\n        Point now = U[i], nxt = U[(i + 1) % U.size()];\n        if (ccw(l.a, l.b, now) != -1) ret.push_back(now);\n        if (ccw(l.a, l.b, now) * ccw(l.a, l.b, nxt) < 0) {\n            ret.push_back(crosspoint(Line{ now, nxt }, l));\n        }\n    }\n    return ret;\n}\n\nPolygon voronoi_cell(const Point& c, const vector<Point>& ps, Polygon outer) {\n    for (const Point& p : ps) {\n        Point m = (p + c) / 2.0;\n        outer = convex_cut(outer,\n                    Line{ m, m + rotate(p - c, M_PI / 2) });\n    }\n    return outer;\n}\n\nReal area(const Polygon& U) {\n    Real area = 0;\n    for (int i = 0; i < U.size(); ++i) {\n        area += cross(U[i], U[(i + 1) % U.size()]);\n    }\n    return area / 2.0;\n}\n\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    while (true) {\n        int n, m; cin >> n >> m;\n        if (n == 0) break;\n\n        vector<Point> island(n);\n        for (int i = 0; i < n; ++i) {\n            double x, y; cin >> x >> y;\n            island[i] = { x, y };\n        }\n        vector<Point> castle(m);\n        for (int i = 0; i < m; ++i) {\n            double x, y; cin >> x >> y;\n            castle[i] = { x, y };\n        }\n\n        for (int i = 0; i < m; ++i) {\n            cout << abs(area(voronoi_cell(castle[i], castle, island))) << endl;\n        }\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \n \n#define EPS (1e-8)\n \nbool equal(double a,double b){\n  return ( fabs(a-b) < EPS );\n}\n \nclass Point {\n  public:\n \n  double x,y;\n   \n  Point (double x = 0, double y = 0) : x(x),y(y) {}\n  \n  Point operator + (Point p) {\n    return Point( x+p.x , y+p.y );\n  }\n  Point operator - (Point p) {\n    return Point( x-p.x , y-p.y );\n  }\n  Point operator * (double a) {\n    return Point( a*x , a*y );\n  }\n  \n  double abs() {\n    return sqrt(norm());\n  }\n  double norm() {\n    return x*x+y*y;\n  }\n  \n  bool operator < (const Point &p) const {\n    return x != p.x ? x < p.x : y < p.y;\n  }\n  \n  bool operator == (const Point &p) const {\n    return equal( x,p.x )&& equal( y,p.y );\n  }\n};\n \ntypedef Point Vector;\n  \ndouble dot(Vector a,Vector b) {\n  return a.x*b.x + a.y*b.y;\n}\n  \ndouble cross(Vector a,Vector b) {\n  return a.x*b.y - b.x*a.y;\n}\n \nVector rotation(Vector vec,double si,double co){\n  Vector res;\n  res.x = vec.x*co - vec.y*si;\n  res.y = vec.x*si + vec.y*co;\n  return res;\n}\n \nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n  \nint ccw( Point p0 , Point p1 , Point p2 ) {\n  Vector a = p1 - p0;\n  Vector b = p2 - p0;\n  if( cross(a,b) > EPS ) return COUNTER_CLOCKWISE;\n  if( cross(a,b) < -EPS ) return CLOCKWISE;\n  if( dot(a,b) < -EPS ) return ONLINE_BACK;\n  if( a.norm() < b.norm() ) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n \nclass Segment{\n    public:\n    Point p1, p2;\n    Segment(Point s = Point(), Point t = Point()): p1(s), p2(t){}\n};\ntypedef Segment Line;\n \nPoint getCrossPointLL(Line l1,Line l2){\n  Point p1=l1.p1,p2=l1.p2;\n  Point q1=l2.p1,q2=l2.p2;\n  Point res;\n  res= p1+(p2-p1)*( cross(q2-q1,q1-p1)/cross(q2-q1,p2-p1) );\n  return res;\n}\n \n \nvector<Point> andrewScan(vector<Point> s){\n  vector<Point> u,l;\n  int size = s.size();\n \n  if(size < 3) return s;\n  sort(s.begin(),s.end());\n \n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[size-1]);\n  l.push_back(s[size-2]);\n \n  for(int i = 2 ; i < size ; i++){\n    for(int n = u.size() ; n >=2 && ccw(u[n-2],u[n-1],s[i]) != CLOCKWISE; n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  }\n \n  for(int i = size-3 ; i >= 0 ; i--){\n    for(int n = l.size() ; n >=2 && ccw(l[n-2],l[n-1],s[i]) != CLOCKWISE; n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n \n  reverse(l.begin(),l.end());\n \n  for(int i = u.size() -2 ; i >= 1 ; i--){\n    l.push_back(u[i]);\n  }\n \n  return l;\n}\n \ndouble calcArea(vector<Point> po){\n  int size=po.size();\n  if(size<3)return 0.0;\n  double res=0.0;\n  for(int i=1;i+1<size;i++){\n    res+=fabs(cross(po[i]-po[0],po[i+1]-po[0]));\n  }\n  return res*0.5;\n}\n \nvector<Point> cutC(vector<Point> t,Line li){\n  vector<Point> res;\n  int n=t.size();\n  for(int i=0;i<n;i++){\n    int j=(i+1)%n;\n    Segment se=Segment(t[i],t[j]);\n    if(ccw(li.p1,li.p2,t[i])!=CLOCKWISE)res.push_back(t[i]);\n    Vector v=se.p1-se.p2,v2=li.p1-li.p2;\n    if( equal( cross(v,v2) , 0 ) ) continue;\n    Point p=getCrossPointLL(se,li);\n    if(ccw(se.p1,se.p2,p)==ON_SEGMENT)res.push_back(p);\n  }\n   \n  return andrewScan(res);\n}\n\nint n,m;\ndouble d,V;\nvector<Point> G,g;\nPoint A[10];\n\nint main(){\n  while(1){\n    cin>>n>>m;\n    if(n==0)break;\n    G.clear();\n    G.resize(n);\n    for(int i=0;i<n;i++)cin>>G[i].x>>G[i].y;\n    Segment se;\n    \n    for(int i=0;i<m;i++){\n      cin>>A[i].x>>A[i].y;\n    }\n    for(int i=0;i<m;i++){\n      g=G;\n      for(int j=0;j<m;j++){\n        if(i==j)continue;\n        se.p1=(A[i]+A[j])*0.5;\n        Vector v=A[j]-A[i];\n        v=rotation(v,1,0);\n        se.p2=se.p1+v;\n        g=cutC(g,se);\n      }\n            \n      printf(\"%.10f\\n\",calcArea(g));\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n \nusing namespace std;\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator + (Point p) {return Point(x+p.x,y+p.y);}\n  Point operator - (Point p) {return Point(x-p.x,y-p.y);}\n  Point operator * (double k) {return Point(x*k,y*k);}\n  Point operator / (double k) {return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x ? x < p.x : y < p.y;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nstruct Segment{\n  Point p1,p2;\n  Segment(){}\n  Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nstruct Circle{\n  Point c;\n  double r;\n  Circle(Point c,double r):c(c),r(r){}\n};\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n\nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n  return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0); \n}\n\nPoint project(Segment s,Point p){\n  Vector base=s.p2-s.p1;\n  double r=dot(p-s.p1,base)/norm(base);\n  return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2.0;\n}\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CLOCKWISE;\n  if(dot(a,b) < -EPS) return ONLINE_BACK;\n  if(a.norm()<b.norm()) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersect(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 &&\n\t  ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 );\n}\n\nbool intersect(Segment s1,Segment s2){\n  return intersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistance(Segment s1,Segment s2){\n  if(intersect(s1,s2)) return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t     min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPoint getCrossPoint(Segment s1,Segment s2){\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n\n\npair<Point,Point> getCrossPoints(Circle c,Line l){\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  return make_pair(pr+e*base,pr-e*base);\n}\n\n\ndouble arg(Vector p){\n  return atan2(p.y,p.x);\n}\n\nVector polar(double a,double r){\n  return Point(cos(r)*a,sin(r)*a);\n}\n\npair<Point,Point> getCrossPoints(Circle c1,Circle c2){\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  return make_pair(c1.c+polar(c1.r,t+a),c1.c+polar(c1.r,t-a));\n}\n\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(fabs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;\n    if(a.y>b.y) swap(a,b);\n    if(a.y < EPS && EPS < b.y && cross(a,b) > EPS ) x = !x;\n  }\n  return (x?2:0);\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3) return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i]) != CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  } \n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i]) != CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  return l;\n} \n\ndouble area(Polygon s){\n  double res=0;\n  for(int i=0;i<(int)s.size();i++){\n    res+=cross(s[i],s[(i+1)%s.size()])/2.0;\n  }\n  return abs(res);\n}\n\nPoint getCrossPointLL(Line l1,Line l2){\n  double a=cross(l1.p2-l1.p1,l2.p2-l2.p1);\n  double b=cross(l1.p2-l1.p1,l1.p2-l2.p1);\n  if(abs(a)<EPS&&abs(b)<EPS) return l2.p1;\n  return l2.p1+(l2.p2-l2.p1)*(b/a);\n}\n\nPolygon convexCut(Polygon p,Line l){\n  Polygon q;\n  for(int i=0;i<(int)p.size();i++){\n    Point a=p[i],b=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,a)!=-1) q.push_back(a);\n    if(ccw(l.p1,l.p2,a)*ccw(l.p1,l.p2,b)<0)\n      q.push_back(getCrossPointLL(Line(a,b),l));\n  }\n  return q;\n}\n\nLine bisector(Point p1,Point p2){\n  Circle c1=Circle(p1,abs(p1-p2)),c2=Circle(p2,abs(p1-p2));\n  pair<Point,Point> p=getCrossPoints(c1,c2);\n  if(cross(p2-p1,p.first-p1)>0) swap(p.first,p.second);\n  return Line(p.first,p.second);\n}\n\nint main(){\n  int n,m;\n  while(cin>>n>>m,n||m){\n    Polygon p,q;\n    for(int i=0;i<n;i++){\n      double x,y;\n      cin>>x>>y;\n      p.push_back(Point(x,y));\n    }\n    for(int i=0;i<m;i++){\n      double x,y;\n      cin>>x>>y;\n      q.push_back(Point(x,y));\n    }\n    for(int i=0;i<m;i++){\n      Polygon t=p;\n      //cout<<area(t)<<\" \";\n      for(int j=0;j<m;j++){\n\tif(i==j) continue;\n\tt=convexCut(t,bisector(q[i],q[j]));\n      }\n      printf(\"%.10lf\\n\",area(t));\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(arg),key)-begin(arg)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \nusing namespace std;\n \ntemplate<class T>void reg(vector<T> &ary,const T &elem){ary.emplace_back(elem);}\ntemplate<class T>bool chmin(T &a, const T &b) {return (b<a)?(a=b,1):0;}\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\n \nusing R=long double; // __float128\nconst R EPS = 1E-11; // [-1000:1000]->EPS=1e-8 [-10000:10000]->EPS=1e-7\nconst R INF = 1E40;\nconstexpr R PI = acos(R(-1));\ninline int sgn(const R& r){ return (r > EPS) - (r < -EPS);}\ninline int sgn(const R& a, const R &b){ return sgn(a-b); }\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n \nusing P=complex<R>;\nusing VP=vector<P>;\nusing L=struct{P s,t;};\nusing VL=vector<L>;\nusing C=struct{P c;R r;};\nusing VC=vector<C>;\n \nconstexpr P O = P(0,0);\nistream& operator >> (istream& is,P& p){ R x,y;is >> x >> y; p=P(x,y); return is;}\nostream& operator << (ostream& os,P& p){ os << real(p) << \" \" << imag(p); return os;}\n \nnamespace std{\n    bool operator <  (const P& a,const P& b){ return sgn(real(a-b))?real(a-b)<0:sgn(imag(a-b))<0;}\n    bool operator == (const P& a,const P& b){ return sgn(real(a-b))==0 && sgn(imag(a-b))==0;}\n}\n \ninline bool cmp_x(const P& p,const P& q){return sgn(real(p-q))?real(p)<real(q):sgn(imag(p-q));}\ninline bool cmp_y(const P& a, const P& b){return sgn(imag(a-b)) ? imag(a-b)<0 : sgn(real(a-b))<0;}\ninline bool cmp_a(const P& a, const P& b){return sgn(arg(a)-arg(b)) ? arg(a)-arg(b)<0 : sgn(norm(a)-norm(b))<0;}\nbool operator <  (const L& a,const L& b){ return a.s==b.s?a.t<b.t:a.s<b.s;}\nbool operator == (const L& a,const L& b){ return a.s==b.s&&a.t==b.t;}\n \n//?????? dot ?????? det\ninline R dot(P o,P a,P b){a-=o,b-=o; return real(conj(a)*b);}\ninline R det(P o,P a,P b){a-=o,b-=o; return imag(conj(a)*b);}\ninline P vec(L l){return l.t-l.s;}\n\nenum CCW{ LEFT = 1,RIGHT = 2,BACK = 4,FRONT = 8,ON = 16};\ninline int ccw(P o,P a, P b) {//???a??¨???b???????????????????????????\n    if (sgn(det(o,a,b)) > 0) return LEFT;    // counter clockwise\n    if (sgn(det(o,a,b)) < 0) return RIGHT;   // clockwise\n    if (sgn(dot(o,a,b)) < 0) return BACK;    // b--base--a on line\n    if (sgn(norm(a-o)-norm(b-o)) < 0) return FRONT;   // base--a--b on line\n    return ON;// base--b--a on line  a??¨b????????????????????????\n}\n\nR area(const VP& pol){\n    int n=pol.size();\n    R sum=0;\n    rep(i,n) sum+=det(O,pol[i],pol[(i+1)%n]);\n    return abs(sum/2.0);\n}\n\nP cross(L a,L b){\n    R s1=det(a.s,b.s,b.t);\n    R s2=s1+det(a.t,b.t,b.s);\n    return a.s+s1/s2*(a.t-a.s);\n}\n\nVP convex_cut(const VP& pol,const L& l) {\n    VP res;\n    int n=pol.size();\n    rep(i,n){\n        P a = pol[i],b=pol[(i+1)%n];\n        if(ccw(l.s,l.t,a)!=RIGHT) reg(res,a);\n        if((ccw(l.s,l.t,a)|ccw(l.s,l.t,b))==(LEFT|RIGHT)) reg(res,cross({a,b},l));\n    }\n    return res;\n}\n\nint main(void){\n    for(int n, m; cin >> n >> m, n;){\n        VP island(n);\n        for(auto & e : island) cin >> e;\n\n        VP castles(m);\n        for(auto & e : castles) cin >> e;\n\n        vector<R> res(m);\n        rep(i, m){\n            VP pol = island;\n\n            rep(j, m){\n                if(j == i) continue;\n                P mid = (castles[i] + castles[j]) / (R)2.0;\n                P t = mid + (castles[j] - castles[i]) * P((R)0.0, (R)1.0);\n                pol = convex_cut(pol, {mid, t});\n            }\n\n            res[i] = area(pol);\n        }\n\n        for(auto & e : res){\n            cout.precision(20);\n            cout << fixed << e << endl;\n        }\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <iterator>\n#include <assert.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RREPS(i,x) for(int i=((int)(x));i>0;i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) (container).begin(), (container).end()\n#define RALL(container) (container).rbegin(), (container).rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nFOR(it,t) os << *it << endl; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\n\nnamespace geom{\n#define X real()\n#define Y imag()\n#define at(i) ((*this)[i])\n#define SELF (*this)\n\tenum {TRUE = 1, FALSE = 0, BORDER = -1};\n\ttypedef int BOOL;\n\ttypedef double R;\n\tconst R INF = 1e8;\n\tconst R EPS = 1e-8;\n\tconst R PI = 3.1415926535897932384626;\n\tinline int sig(const R &x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\n\tinline BOOL less(const R &x, const R &y) {return sig(x-y) ? x < y : BORDER;}\n\ttypedef complex<R> P;\n\tinline R norm(const P &p){return p.X*p.X+p.Y*p.Y;}\n\tinline R inp(const P& a, const P& b){return (conj(a)*b).X;}\n\tinline R outp(const P& a, const P& b){return (conj(a)*b).Y;}\n\tinline P unit(const P& p){return p/abs(p);}\n\tinline P proj(const P &s, const P &t){return t*inp(s, t)/norm(t);}\n\tinline int ccw(const P &s, const P &t, const P &p, int adv=0){\n\t\tint res = sig(outp(t-s, p-s));\n\t\tif(res || !adv) return res;\n\t\tif(sig(inp(t-s, p-s)) < 0) return -2;\t// p-s-t\n\t\tif(sig(inp(s-t, p-t)) < 0) return 2;\t// s-t-p\n\t\treturn 0;\t\t\t\t\t\t\t\t// s-p-t\n\t}\n\t\n\t\n\tstruct L : public vector<P>{\t// line\n\t\tL(const P &p1, const P &p2){this->push_back(p1);this->push_back(p2);}\n\t\tL(){}\n\t\tP dir()const {return at(1) - at(0);}\n\t\tBOOL online(const P &p)const {return !sig(outp(p-at(0), dir()));}\n\t};\n\tstruct S : public L{\t// segment\n\t\tS(const P &p1, const P &p2):L(p1, p2){}\n\t\tS(){}\n\t\tBOOL online(const P &p)const {\n\t\t\tif(!sig(norm(p - at(0))) || !sig(norm(p - at(1)))) return BORDER;\n\t\t\treturn !sig(abs(at(0)-p) + abs(at(1) - p) - abs(at(0) - at(1)));\n\t\t}\n\t};\n\tstruct C : public P{\n\t\tR r;\n\t\tBOOL inside(const P& p)const { return less(norm(p-SELF), r*r);}\n\t};\n\tP crosspoint(const L &l, const L &m);\n\tstruct G : public vector<P>{\n\t\tG(size_type size=0):vector(size){}\n\t\tS edge(int i)const {return S(at(i), at(i+1 == size() ? 0 : i+1));}\n\t\tBOOL contains(const P &p)const {\n\t\t\tR sum = .0;\n\t\t\tREP(i, size()){\n\t\t\t\tif(S(at(i), at((i+1)%size())).online(p)) return BORDER;\t// online\n\t\t\t\tsum += arg((at(i) - p) / (at((i+1)%size()) - p));\n\t\t\t}\n\t\t\treturn !!sig(sum);\n\t\t}\n\t\tR area()const {\n\t\t\tR sum = 0;\n\t\t\tREP(i, size()) sum += outp(at(i), at((i+1)%size()));\n\t\t\treturn abs(sum / 2.);\n\t\t}\n\t\t\n\t\tG convex_hull(bool online = false) {\n\t\t\tif(size() < 2) return *this;\n\t\t\tsort(ALL(*this));\n\t\t\tG r;\n\t\t\tr.resize((int)size()*2);\n\t\t\tint k=0;\n\t\t\tfor(int i=0;i<size();r[k++]=at(i++))\n\t\t\t\twhile(k>1 && ccw(r[k-2], r[k-1], at(i)) < 1-online) k--;\n\t\t\tint t = k;\n\t\t\tfor(int i=(int)size()-1;i>=0;r[k++]=at(i--))\n\t\t\t\twhile(k>t && ccw(r[k-2], r[k-1], at(i)) < 1-online) k--;\n\t\t\tr.resize(k-1);\n\t\t\treturn r;\n\t\t}\n\t\tG cut(const L &l)const {\n\t\t\tG g;\n\t\t\tREP(i, size()){\n\t\t\t\tconst S &s = edge(i);\n\t\t\t\tif(ccw(l[0], l[1], s[0], 0) >= 0) g.push_back(s[0]);\n\t\t\t\tif(ccw(l[0], l[1], s[0], 0) * ccw(l[0], l[1], s[1], 0) < 0)\n\t\t\t\t\tg.push_back(crosspoint(s, l));\n\t\t\t}\n\t\t\treturn g;\n\t\t}\n\t\tG Voronoi(const vector<P> &p, int t)const {\n\t\t\tG g = *this;\n\t\t\tREP(i, p.size())if(i!=t){\n\t\t\t\tP m = (p[t]+p[i])*0.5;\n\t\t\t\tg = g.cut(L(m, m+(p[i]-p[t])*P(0, 1)));\n\t\t\t}\n\t\t\treturn g;\n\t\t}\n\t};\n\n\tinline P proj(const P &s, const L &t){return t[0] + proj(s-t[0], t[1]-t[0]);}\n\tBOOL intersect(const S &s, const S &t){\n\t\tconst int p = ccw(t[0], t[1], s[0], 1) * ccw(t[0], t[1], s[1], 1);\n\t\tconst int q = ccw(s[0], s[1], t[0], 1) * ccw(s[0], s[1], t[1], 1);\n\t\treturn (p>0||q>0) ? FALSE : (!p||!q) ? BORDER : TRUE;\n\t}\n\tBOOL intersect(const S &s, const L &l){\n\t\tif(l.online(s[0]) || l.online(s[1])) return BORDER;\n\t\treturn (sig(outp(l.dir(), s[0]-l[0])) * sig(outp(l.dir(), s[1]-l[0])) <= 0);\n\t}\n\tR dist2(const L &l, const P &p){return norm(outp(l.dir(), p - l[0])) / norm(l.dir());}\n\tR dist2(const S &s, const P &p){\n\t\tif(inp(p-s[0],  s.dir()) < EPS) return norm(p - s[0]);\n\t\tif(inp(p-s[1], -s.dir()) < EPS) return norm(p - s[1]);\n\t\treturn dist2((const L &)s, p);\n\t}\n\tR dist2(const S &s, const L &l){\n\t\treturn intersect(s, l) ? .0 : min(dist2(l, s[0]), dist2(l, s[1]));\n\t}\n\tR dist2(const S &s, const S &t){\n\t\treturn intersect(s, t) ? .0 : min(min(dist2(s, t[0]), dist2(t, s[0])), \n\t\t\t\t\t\t\t\t\t   \t  min(dist2(s, t[1]), dist2(t, s[1])));\n\t}\n\ttemplate <class T> R dist2(const G &g, const T& t){ // todo: 内部に完全に含まれる場合\n\t\tR res = INF;\n\t\tREP(i, g.size()) res = min(res, dist2(g.edge(i), t));\n\t\treturn res;\n\t}\n\ttemplate<class S, class T> R dist(const S& s, const T& t){return sqrt(dist2(s, t));}\n\tinline BOOL intersect(const C &a, const C &b){\n\t\treturn less((a.r-b.r)*(a.r-b.r), norm(a-b)) + less(norm(a-b), (a.r+b.r)*(a.r+b.r)) - 1;\n\t}\n\tinline BOOL intersect(const C &c, const L &l){\n\t\treturn less(dist2(l, c), c.r*c.r);\n\t}\n\tinline BOOL intersect(const C &c, const S &s){\n\t\tint d = less(dist2(s, c), c.r*c.r);\n\t\tif(d != TRUE) return d;\n\t\tint p = c.inside(s[0]), q = c.inside(s[1]);\n\t\treturn (p<0 || q<0) ? BORDER : p&q;\n\t}\n\tinline S crosspoint(const C &c1, const C &c2){\n\t\tif(!intersect(c1, c2)) return S();\n\t\tR d = abs(c1 - c2);\n\t\tR x = (c1.r*c1.r - c2.r*c2.r + d*d) / (2*d);\n\t\tR h = sqrt(c1.r*c1.r - x*x);\n\t\tP u = unit(c2-c1);\n\t\treturn S(c1 + u*x + u*P(0,1)*h, c1 + u*x + u*P(0,-1)*h);\n\t}\n\tinline P crosspoint(const L &l, const L &m){\n\t\tR A = outp(l.dir(), m.dir()), B = outp(l.dir(), l[1] - m[0]);\n\t\tif(!sig(abs(A)) && !sig(abs(B))) return m[0]; // same line\n\t\tif(abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n\t\treturn m[0] + B / A * (m[1] - m[0]);\n\t}\n\tinline R commonarea(const C &a, const C &b){\n\t\tif(less(norm(a-b), (a.r-b.r)*(a.r-b.r)) == TRUE) return min(a.r*a.r, b.r*b.r)*PI;\n\t\tif(less((a.r+b.r)*(a.r+b.r), norm(a-b)) == TRUE) return .0;\n\t\tdouble d = abs(a-b);\n\t\tdouble rc = (d*d + a.r*a.r - b.r*b.r) / (2*d);\n\t\tdouble theta = acos(rc / a.r);\n\t\tdouble phi = acos((d - rc) / b.r);\n\t\treturn a.r*a.r*theta + b.r*b.r*phi - d*a.r*sin(theta);\n\t}\n\tstruct Arrangement{\n\t\tstruct AEdge{\n\t\t\tint u, v, t;\n\t\t\tR cost;\n\t\t\tAEdge(int u=0, int v=0, int t=0, R cost=0)\n\t\t\t\t:u(u), v(v), t(t), cost(cost){}\n\t\t};\n\t\ttypedef vector<vector<AEdge>> AGraph;\n\t\tvector<P> p;\n\t\tAGraph g;\n\t\tArrangement(){}\n\t\tArrangement(vector<S> seg){\n\t\t\tint m = seg.size();\n\t\t\tREP(i, m){\n\t\t\t\tp.push_back(seg[i][0]);\n\t\t\t\tp.push_back(seg[i][1]);\n\t\t\t\tREP(j, i) if(sig(outp(seg[i].dir(), seg[j].dir())) && intersect(seg[i], seg[j]) == TRUE)\n\t\t\t\t\tp.push_back(crosspoint(seg[i], seg[j]));\n\t\t\t}\n\t\t\tsort(ALL(p)); UNIQUE(p);\n\t\t\tint n=p.size();\n\t\t\tg.resize(n);\n\t\t\tREP(i, m){\n\t\t\t\tS &s = seg[i];\n\t\t\t\tvector<pair<R, int>> ps;\n\t\t\t\tREP(j, n) if(s.online(p[j])) ps.emplace_back(norm(p[j] - s[0]), j);\n\t\t\t\tsort(ALL(ps));\n\t\t\t\tREP(j, (int)ps.size()-1){\n\t\t\t\t\tconst int u=ps[j].second;\n\t\t\t\t\tconst int v=ps[j+1].second;\n\t\t\t\t\tg[u].emplace_back(u, v, 0, abs(p[u] - p[v]));\n\t\t\t\t\tg[v].emplace_back(v, u, 0, abs(p[u] - p[v]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint getIdx(P q){\n\t\t\tauto it = lower_bound(ALL(p), q);\n\t\t\tif(it == p.end() || *it != q) return -1;\n\t\t\treturn it - p.begin();\n\t\t}\n\t};\n#undef SELF\n#undef at\n}\n\nusing namespace geom;\n\nnamespace std{\n\tbool operator<(const P &a, const P &b){return sig(a.X-b.X) ? a.X < b.X : a.Y < b.Y;}\n\tistream& operator>>(istream &is, P &p){R x,y;is>>x>>y;p=P(x, y);return is;}\n\tistream& operator>>(istream &is, L &l){l.resize(2);return is >> l[0] >> l[1];}\n\tistream& operator>>(istream &is, C &c){return is >> (P &)c >> c.r;}\n}\n\nint n, m;\nmain(){\n\twhile(cin >> n >> m, n){\n\t\tG g(n);\n\t\tvector<P> p(m);\n\t\tREP(i, n) cin >> g[i];\n\t\tREP(i, m) cin >> p[i];\n\t\tREP(i, m) printf(\"%.9f\\n\", g.Voronoi(p, i).area());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n \n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n \n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(arg),key)-begin(arg)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n \nusing namespace std;\n \ntemplate<class T>void reg(vector<T> &ary,const T &elem){ary.emplace_back(elem);}\ntemplate<class T>bool chmin(T &a, const T &b) {return (b<a)?(a=b,1):0;}\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\n \nusing R=long double; // __float128\nconst R EPS = 1E-11; // [-1000:1000]->EPS=1e-8 [-10000:10000]->EPS=1e-7\nconst R INF = 1E40;\nconstexpr R PI = acos(R(-1));\ninline int sgn(const R& r){ return (r > EPS) - (r < -EPS);}\ninline int sgn(const R& a, const R &b){ return sgn(a-b); }\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n \nusing P=complex<R>;\nusing VP=vector<P>;\nusing L=struct{P s,t;};\nusing VL=vector<L>;\nusing C=struct{P c;R r;};\nusing VC=vector<C>;\n \nconstexpr P O = P(0,0);\nistream& operator >> (istream& is,P& p){ R x,y;is >> x >> y; p=P(x,y); return is;}\nostream& operator << (ostream& os,P& p){ os << real(p) << \" \" << imag(p); return os;}\n \nnamespace std{\n    bool operator <  (const P& a,const P& b){ return sgn(real(a-b))?real(a-b)<0:sgn(imag(a-b))<0;}\n    bool operator == (const P& a,const P& b){ return sgn(real(a-b))==0 && sgn(imag(a-b))==0;}\n}\n \ninline bool cmp_x(const P& p,const P& q){return sgn(real(p-q))?real(p)<real(q):sgn(imag(p-q));}\ninline bool cmp_y(const P& a, const P& b){return sgn(imag(a-b)) ? imag(a-b)<0 : sgn(real(a-b))<0;}\ninline bool cmp_a(const P& a, const P& b){return sgn(arg(a)-arg(b)) ? arg(a)-arg(b)<0 : sgn(norm(a)-norm(b))<0;}\nbool operator <  (const L& a,const L& b){ return a.s==b.s?a.t<b.t:a.s<b.s;}\nbool operator == (const L& a,const L& b){ return a.s==b.s&&a.t==b.t;}\n \n//?????? dot ?????? det\ninline R dot(P o,P a,P b){a-=o,b-=o; return real(conj(a)*b);}\ninline R det(P o,P a,P b){a-=o,b-=o; return imag(conj(a)*b);}\ninline P vec(L l){return l.t-l.s;}\n\nenum CCW{ LEFT = 1,RIGHT = 2,BACK = 4,FRONT = 8,ON = 16};\ninline int ccw(P o,P a, P b) {//???a??¨???b???????????????????????????\n    if (sgn(det(o,a,b)) > 0) return LEFT;    // counter clockwise\n    if (sgn(det(o,a,b)) < 0) return RIGHT;   // clockwise\n    if (sgn(dot(o,a,b)) < 0) return BACK;    // b--base--a on line\n    if (sgn(norm(a-o)-norm(b-o)) < 0) return FRONT;   // base--a--b on line\n    return ON;// base--b--a on line  a??¨b????????????????????????\n}\n\nR area(const VP& pol){\n    int n=pol.size();\n    R sum=0;\n    rep(i,n) sum+=det(O,pol[i],pol[(i+1)%n]);\n    return abs(sum/2.0);\n}\n\nP cross(L a,L b){\n    R s1=det(a.s,b.s,b.t);\n    R s2=s1+det(a.t,b.t,b.s);\n    return a.s+s1/s2*(a.t-a.s);\n}\n\nVP convex_cut(const VP& pol,const L& l) {\n    VP res;\n    int n=pol.size();\n    rep(i,n){\n        P a = pol[i],b=pol[(i+1)%n];\n        if(ccw(l.s,l.t,a)!=RIGHT) reg(res,a);\n        if((ccw(l.s,l.t,a)|ccw(l.s,l.t,b))==(LEFT|RIGHT)) reg(res,cross({a,b},l));\n    }\n    return res;\n}\n\nint main(void){\n    int n, m; cin >> n >> m;\n\n    VP island(n);\n    for(auto & e : island) cin >> e;\n\n    VP castles(m);\n    for(auto & e : castles) cin >> e;\n\n    vector<R> res(n);\n    rep(i, m){\n        VP pol = island;\n\n        rep(j, m){\n            if(j == i) continue;\n            P mid = (castles[i] + castles[j]) / (R)2.0;\n            P t = mid + (castles[j] - castles[i]) * P(0, 1);\n            pol = convex_cut(pol, {mid, t});\n        }\n\n        res[i] = area(pol);\n    }\n\n    for(auto & e : res){\n        cout.precision(20);\n        cout << fixed << e << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include <iostream>\n#include <math.h>\n#include <numeric>\n#include <vector>\n#include <map>\n#include <functional>\n#include <stdio.h>\n#include <array>\n#include <algorithm>\n#include <string>\n#include <string.h>\n#include <assert.h>\n#include <stdio.h>\n#include <queue>\n#include<iomanip>\n#include<bitset>\n#include<stack>\n#include<set>\n#include<limits>\n#include <complex>\n#include<cstdlib>\nusing namespace std;\n\n\n/* 幾何の基本 */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nconst ld eps = 1e-9, pi = acos(-1.0);\n\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\treturn lhs.imag() < rhs.imag();\n\t}\n}\n\n// 点の入力\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n// 誤差つき等号判定\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\n\n// 内積\nld dot(Point a, Point b) {\n\treturn real(conj(a) * b);\n}\n\n// 外積\nld cross(Point a, Point b) {\n\treturn imag(conj(a) * b);\n}\n\n// 直線の定義\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num) {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse assert(false);\n\t}\n};\n\n// 円の定義\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // a,b,cが反時計周りの順に並ぶ\n\tif (cross(b, c) < -eps) return -1; // a,b,cが時計周りの順に並ぶ\n\tif (dot(b, c) < 0) return 2;       // c,a,bの順に直線に並ぶ\n\tif (norm(b) < norm(c)) return -2;  // a,b,cの順に直線に並ぶ\n\treturn 0;                          // a,c,bの順に直線に並ぶ\n}\n\n\n/* 交差判定 */\n\n// 直線と直線の交差判定\nbool isis_ll(Line l, Line m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// 直線と線分の交差判定\nbool isis_ls(Line l, Line s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// 線分と線分の交差判定\nbool isis_ss(Line s, Line t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// 点の直線上判定\nbool isis_lp(Line l, Point p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// 点の線分上判定\nbool isis_sp(Line s, Point p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// 垂線の足\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// 直線と直線の交点\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\n// 直線と点の距離\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n\n// 直線と直線の距離\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// 直線と線分の距離\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// 線分と点の距離\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// 線分と線分の距離\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n/* 円 */\n\n// 円と円の交点\nvector<Point> is_cc(Circle c1, Circle c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n// 円と直線の交点\nvector<Point> is_lc(Circle c, Line l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// 円と線分の距離\nvector<Point> is_sc(Circle c, Line l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// 円と点の接線\nvector<Line> tangent_cp(Circle c, Point p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// 円と円の接線\nvector<Line> tangent_cc(Circle c1, Circle c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\n\n/* 多角形 */\n\ntypedef vector<Point> Polygon;\n\n// 面積\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// 多角形の回転方向\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// 円の内外判定\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_polygon(const Polygon &poly, Point p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n\n// 凸包\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n// 凸カット\nvector<Polygon> convex_cut(const Polygon &ps, const Line l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\treturn vector<Polygon>{Q, R};\n}\n\n\n/* アレンジメント */\nvoid add_point(vector<Point> &ps, Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\n\nstruct Edge { int from, to; Weight weight; };\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, int from, int to, Weight weight) {\n\tg[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, abs(p[from] - p[to]));\n\t\t}\n\t}\n\treturn g;\n}\n\nGraph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n\tint n = p.size(), m = c.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tld angle = vec[j + 1].first - vec[j].first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t\tif (vec.size() >= 2) {\n\t\t\tint from = vec.back().second, to = vec.front().first;\n\t\t\tld angle = vec.front().first - vec.back().first;\n\t\t\tadd_edge(g, from, to, angle * c[i].r);\n\t\t}\n\t}\n\treturn g;\n}\n\n\n/* 双対グラフ */\n\n// 線分集合は既にアレンジメントされていなければならない．\n// 内側の円は時計回りで，外側の円は反時計回りで得られる．\n// 変数 polygon は，vector<int> で表される多角形の集合であり，\n// vector<int> で表される 多角形のi番目は，その頂点の頂点集合pにおける番号である．\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\nGraph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n\tint N = p.size();\n\tpolygon.clear();\n\tREP(i, 1024) REP(j, 1024) seg2p[i][j].clear();\n\tvector<vector<tuple<ld, int, bool>>> tup(N);\n\tREP(i, s.size()) {\n\t\tint a = -1, b = -1;\n\t\tREP(j, N) if (abs(s[i].a - p[j]) < eps) a = j;\n\t\tREP(j, N) if (abs(s[i].b - p[j]) < eps) b = j;\n\t\tassert(a >= 0 && b >= 0);\n\t\ttup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n\t\ttup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n\t}\n\tREP(i, N) sort(ALL(tup[i]));\n\tREP(i, N) {\n\t\tREP(j, tup[i].size()) {\n\t\t\tld angle; int pos = j, from = i, to; bool flag;\n\t\t\ttie(angle, to, flag) = tup[i][j];\n\t\t\tif (flag) continue;\n\t\t\tvector<int> ps;\n\t\t\twhile (!flag) {\n\t\t\t\tps.push_back(from);\n\t\t\t\tget<2>(tup[from][pos]) = true;\n\t\t\t\tseg2p[from][to].push_back(polygon.size());\n\t\t\t\tseg2p[to][from].push_back(polygon.size());\n\t\t\t\tangle += pi + eps;\n\t\t\t\tif (angle > pi) angle -= 2 * pi;\n\t\t\t\tauto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n\t\t\t\tif (it == tup[to].end()) it = tup[to].begin();\n\t\t\t\tfrom = to; tie(angle, to, flag) = *it;\n\t\t\t\tpos = it - tup[from].begin();\n\t\t\t}\n\t\t\tpolygon.push_back(ps);\n\t\t}\n\t}\n\tGraph g(polygon.size());\n\tREP(i, N) REP(j, i) {\n\t\tif (seg2p[i][j].size() == 2) {\n\t\t\tint from = seg2p[i][j][0], to = seg2p[i][j][1];\n\t\t\tg[from].push_back(Edge{ from, to });\n\t\t\tg[to].push_back(Edge{ to, from });\n\t\t}\n\t}\n\treturn g;\n}\n\n\n/* ビジュアライザ */\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(int r, int g, int b) {\n\tfprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\nint cordx(Point p) { return 400 + zoom * (p.real() - centerX); }\nint cordy(Point p) { return 400 - zoom * (p.imag() - centerY); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(Point p) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(Line l) {\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(Line l) {\n\tPoint v = l.b - l.a;\n\tLine m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n\tint n = p.size();\n\tREP(i, n) draw_segment(Line(p[i], p[(i + 1) % n]));\n}\n\nvoid draw_circle(Circle c) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\n\nvector<Polygon>polys;\nvector<int>hs;\nvector<long double>diss;\n\n\nbool check(const long double rad) {\n\tfor (int i = 0; i < hs.size(); ++i) {\n\t\tif (hs[i] > rad) {\n\t\t\tif (diss[i] < rad)return false;\n\t\t}\n\t\telse {\n\t\t\tlong double needdis = sqrt(rad*rad - (rad - hs[i])*(rad - hs[i]));\n\t\t\tif (diss[i] < needdis)return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nint main() {\n\tint N, M; cin >> N >> M;\n\tPolygon island;\n\tfor (int i = 0; i < N; ++i) {\n\t\tint x, y; cin >> x >> y;\n\t\tPoint p(x, y);\n\t\tisland.emplace_back(p);\n\t}\n\tvector<Point>castles;\n\tfor (int i = 0; i < M; ++i) {\n\t\tint x, y; cin >> x >> y;\n\t\tcastles.emplace_back(x,y);\n\t}\n\n\tfor (int mylord = 0; mylord < M; ++mylord) {\n\t\tPolygon myarea(island);\n\t\tfor (int oplord = 0; oplord < M; ++oplord) {\n\t\t\tif (mylord == oplord)continue;\n\t\t\telse {\n\t\t\t\tLine tie(castles[mylord], castles[oplord]);\n\t\t\t\tPoint midp((castles[mylord] + castles[oplord]) / 2.0l);\n\t\t\t\tcomplex<long double>nc((castles[mylord] - castles[oplord])*complex<long double>(0, 1));\n\t\t\t\tPoint verp(midp + nc);\n\t\t\t\tLine perpen(midp, verp);\n\t\t\t\tvector<Polygon> twoislands(convex_cut(myarea, perpen));\n\t\t\t\tif (is_in_polygon(twoislands[0], castles[mylord]) >= 1) {\n\t\t\t\t\tmyarea = twoislands[0];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmyarea = twoislands[1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<setprecision(22)<<abs(area(myarea)) << endl;\n\t}\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double EPS = 1e-8;\n\ndouble cross(P a, P b){\n  return a.real() * b.imag() - a.imag() * b.real();\n}\n\nvector<P> convexCut(vector<P>& g, P p, P q){\n  vector<P> res;\n  int n = g.size();\n  for(int i=0;i<n;i++){\n    P A(g[i]), B(g[(i+1)%n]);\n    double p1 = cross(q-p, A-p);\n    double p2 = cross(q-p, B-p);\n    if(p1 > -EPS) res.push_back(A);\n    if(p1 * p2 < -EPS) res.push_back(A + cross(q-p, q-A) / cross(q-p, B-A) * (B-A));\n  }\n  return res;\n}\n\ndouble getArea(vector<P>& g){\n  double res = 0.0;\n  for(int i=0;i<g.size();i++) res += cross(g[i], g[(i+1)%g.size()]);\n  return abs(res) * 0.5;\n}\n\nmain(){\n  int n, m;\n  while(cin >> n >> m && (n|m)){\n    vector<P> A, B;\n    double a, b;\n    for(int i=0;i<n;i++){\n      cin >> a >> b;\n      A.push_back(P(a, b));\n    }\n    for(int i=0;i<m;i++){\n      cin >> a >> b;\n      B.push_back(P(a, b));\n    }\n    for(int i=0;i<m;i++){\n      vector<P> tmp = A;\n      for(int j=0;j<m;j++){\n        if(i == j) continue;\n        P mid = (B[i] + B[j]) / 2.0;\n        P p = mid + (B[i] - B[j]) * P(0, 1);\n        if(cross(p-mid, B[i]-mid) > EPS) swap(p, mid);\n        tmp = convexCut(tmp, p, mid);\n      }\n      cout << getArea(tmp) << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n\nusing namespace std;\n\ntypedef complex<double> P;\nconst double EPS = 1e-8;\n\ndouble cross(P a, P b){ return imag(conj(a)*b); }\n\nvector<P> convexCut(vector<P> g, P p, P q){\n\tvector<P> res;\n\tint n = g.size();\n\tfor(int i=0;i<n;i++){\n\t\tP A(g[i]), B(g[(i+1)%n]);\n\t\tdouble p1 = cross(q-p,A-p);\n\t\tdouble p2 = cross(q-p,B-p);\n\t\tif(p1 > -EPS) res.push_back(A);\n\t\tif(p1*p2 < -EPS)\n\t\t\tres.push_back(A+cross(q-p,q-A)/cross(q-p,B-A)*(B-A));\n\t}\n\treturn res;\n}\n\ndouble polygonArea(vector<P> g){\n\tdouble res = 0.0;\n\tfor(int i=0;i<g.size();i++)\n\t\tres += cross(g[i],g[(i+1)%g.size()]);\n\treturn abs(0.5*res);\n}\n\nint main(){\n\tint n, m; \n\twhile(cin >> n >> m, n){\n\t\tvector<P> island, castle;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tdouble Ix, Iy; cin >> Ix >> Iy;\n\t\t\tisland.push_back(P(Ix,Iy));\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tdouble Cx, Cy; cin >> Cx >> Cy;\n\t\t\tcastle.push_back(P(Cx,Cy));\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tvector<P> area = island;\n\t\t\tfor(int j=0;j<m;j++){\n\t\t\t\tif(i==j) continue;\n\t\t\t\tP mid = (castle[i]+castle[j])/2.0;\n\t\t\t\tP dir = (castle[i]-castle[j])*P(0,1);\n\t\t\t\tP q = mid + dir;\n\t\t\t\tif(cross(q-mid,castle[i]-mid)>EPS) swap(q,mid);\n\t\t\t\tarea = convexCut(area, q, mid);\n\t\t\t}\n\t\t\tprintf(\"%.6lf\\n\", polygonArea(area));\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <vector>\nusing namespace std;\n\nconstexpr double EPS = 1e-9;\n\nstruct point {\n\tdouble x, y;\n\tpoint(double x = 0.0, double y = 0.0):x(x), y(y) {}\n\tpoint(const point& p):x(p.x), y(p.y) {}\n\n\tpoint operator+ (const point& p) const {\n\t\treturn point(x + p.x, y + p.y);\n\t}\n\n\tpoint operator- (const point& p) const {\n\t\treturn point(x - p.x, y - p.y);\n\t}\n\n\tpoint operator* (const double s) const {\n\t\treturn point(x * s, y * s);\n\t}\n\n\tpoint operator* (const point& p) const {\n\t\treturn point(x * p.x - y * p.y, x * p.y + y * p.x);\n\t}\n\n\tpoint operator/ (const double s) const {\n\t\treturn point(x / s, y / s);\n\t}\n\n\tbool operator< (const point& p) const {\n\t\treturn x + EPS < p.x || (abs(x - p.x) < EPS && y + EPS < p.y);\n\t}\n\n\tbool operator== (const point& p) const {\n\t\treturn abs(x - p.x) < EPS && abs(y - p.y) < EPS;\n\t}\n};\n\ninline double abs(const point& p) {\n\treturn sqrt(p.x * p.x + p.y * p.y);\n}\n\ninline double norm(const point& p) {\n\treturn p.x * p.x + p.y * p.y;\n}\n\ninline double dot(const point& l, const point& r) {\n\treturn l.x * r.x + l.y * r.y;\n}\n\ninline double cross(const point& l, const point& r) {\n\treturn l.x * r.y - l.y * r.x;\n}\n\nstruct line {\n\tpoint a, b;\n\tline(point a, point b):a(a), b(b){}\n};\n\ntypedef vector<point> polygon;\n\ninline int ccw(const point& a, point b, point c) {\n\tb = b - a;\n\tc = c - a;\n\tconst double tmp = cross(b, c);\n\tif(tmp > EPS) return 1; // ccw\n\tif(tmp < -EPS) return -1; // cw\n\tif(dot(b, c) < 0) return 2; // c, a, b 順に一直線上\n\tif(norm(b) < norm(c)) return -2; // a, b, c 順に一直線上\n\treturn 0; //a, c, b 順で一直線上\n}\n\ninline point crosspoint(const line& l, const line& m) {\n\tconst double tmp = cross(l.b - l.a, m.b - m.a);\n\tif(abs(tmp) < EPS) // 平行\n\t\treturn l.a;\n\treturn m.a + (m.b - m.a) * cross(l.b - l.a, l.a - m.a) * (1.0 / tmp);\n}\n\ninline double areaTriangle(point a, point b, const point& c) {\n\ta = a - c;\n\tb = b - c;\n\treturn abs(a.x * b.y - b.x * a.y) / 2.0;\n}\n\ninline double area(const polygon& p) {\n\tconst int num = p.size();\n\tif(num < 3)\n\t\treturn 0.0;\n\n\tif(num == 3)\n\t\treturn areaTriangle(p[0], p[1], p[2]);\n\n\tdouble res = cross(p[num - 1], p[0]);\n\tfor(int i = 1; i < num; ++i)\n\t\tres += cross(p[i - 1], p[i]);\n\n\treturn abs(res) * 0.5;\n}\n\ninline line bisector(const point& a, const point& b) {\n\treturn line(point((a.x - a.y + b.x + b.y) / 2.0, (a.y + a.x + b.y - b.x) / 2.0),\n\t\t\t\tpoint((a.x + a.y + b.x - b.y) / 2.0, (a.y - a.x + b.y + b.x) / 2.0));\n}\n\ninline polygon convex_cut(const polygon& p, const line& l) {\n\tconst int num = p.size();\n\tpolygon res;\n\tfor(int i = 0; i < num; ++i) {\n\t\tconst int next = (i + 1) % num;\n\t\tconst int tmp = ccw(l.a, l.b, p[i]);\n\t\tif(tmp != -1)\n\t\t\tres.push_back(p[i]);\n\n\t\tif(tmp * ccw(l.a, l.b, p[next]) < 0)\n\t\t\tres.push_back(crosspoint(l, line(p[i], p[next])));\n\t}\n\n\treturn res;\n}\n\nint main() {\n\tfor(int n, m; scanf(\"%d %d\", &n, &m), n;) {\n\t\tpolygon island;\n\t\tisland.reserve(n);\n\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tint ix, iy;\n\t\t\tscanf(\"%d %d\", &ix, &iy);\n\t\t\tisland.emplace_back(ix, iy);\n\t\t}\n\n\t\tvector<point> cp;\n\t\tcp.reserve(m);\n\n\t\tfor(int i = 0; i < m; ++i) {\n\t\t\tint cx, cy;\n\t\t\tscanf(\"%d %d\", &cx, &cy);\n\t\t\tcp.emplace_back(cx, cy);\n\t\t}\n\n\t\tfor(int i = 0; i < m; ++i) {\n\t\t\tpolygon voronoi(island);\n\t\t\tfor(int j = 0; j < m; ++j) {\n\t\t\t\tif(i == j)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tvoronoi = convex_cut(voronoi, bisector(cp[i], cp[j]));\n\t\t\t}\n\n\t\t\tprintf(\"%.10lf\\n\", area(voronoi));\n\t\t}\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<vector>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst double EPS=1e-8;\n\ntemplate<class T>\nstruct point{\n\tT x,y;\n\tpoint operator+(const point &a)const{ return (point){x+a.x,y+a.y}; }\n\tpoint operator-(const point &a)const{ return (point){x-a.x,y-a.y}; }\n};\n\ntemplate<class T>\npoint<T> operator*(T c,const point<T> &a){ return (point<T>){c*a.x,c*a.y}; }\n\ntemplate<class T>\nT cross(const point<T> &a,const point<T> &b){ return a.x*b.y-a.y*b.x; }\n\ntemplate<class T>\nstruct line{ point<T> a,b; };\n\ntemplate<class T>\nstruct polygon:vector< point<T> >{\n\tpolygon(){}\n\tpolygon(int n):vector< point<T> >(n){}\n};\n\ntemplate<class T>\nT area2(const polygon<T> &G){\n\tint n=G.size();\n\tT a=0;\n\trep(i,n) a+=cross(G[i],G[(i+1)%n]);\n\treturn abs(a);\n}\n\ntemplate<class T>\nline<double> perp_bisector(const point<T> &a,const point<T> &b){\n\treturn (line<double>){(point<double>){(a.x-a.y+b.x+b.y)/2.0,(a.y+a.x+b.y-b.x)/2.0},\n\t\t\t\t\t\t  (point<double>){(a.x+a.y+b.x-b.y)/2.0,(a.y-a.x+b.y+b.x)/2.0}};\n}\n\nenum {CCW=1,CW=-1,ON=0};\nint ccw(const point<double> &a,const point<double> &b,const point<double> &c){\n\tdouble rdir=cross(b-a,c-a);\n\tif(rdir> EPS) return CCW;\n\tif(rdir<-EPS) return CW;\n\treturn ON;\n}\n\npoint<double> get_intersect(const line<double> &L1,const line<double> &L2){\n\tdouble a1=cross(L1.b-L1.a,L2.b-L2.a);\n\tdouble a2=cross(L1.b-L1.a,L1.b-L2.a);\n\tif(abs(a1)<EPS) return L1.a;\n\treturn L2.a+a2/a1*(L2.b-L2.a);\n}\n\ntemplate<class T>\npolygon<double> convex_cut(const polygon<T> &G,const line<T> &L){\n\tint n=G.size();\n\tpolygon<double> H;\n\trep(i,n){\n\t\tint d1=ccw(L.a,L.b,G[i]);\n\t\tint d2=ccw(L.a,L.b,G[(i+1)%n]);\n\t\tif(d1!=CW) H.push_back(G[i]);\n\t\tif(d1==CCW && d2==CW || d1==CW && d2==CCW){\n\t\t\tH.push_back(get_intersect(L,(line<T>){G[i],G[(i+1)%n]}));\n\t\t}\n\t}\n\treturn H;\n}\n\nint main(){\n\tfor(int n,m;scanf(\"%d%d\",&n,&m),n;){\n\t\tpolygon<double> G(n);\n\t\trep(i,n) scanf(\"%lf%lf\",&G[i].x,&G[i].y);\n\t\tpoint<double> P[10];\n\t\trep(i,m) scanf(\"%lf%lf\",&P[i].x,&P[i].y);\n\n\t\trep(i,m){\n\t\t\tpolygon<double> Vor=G;\n\t\t\trep(j,m) if(j!=i) Vor=convex_cut(Vor,perp_bisector(P[i],P[j]));\n\t\t\tprintf(\"%.9f\\n\",area2(Vor)/2);\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<cmath>\n#include<vector>\n#include<cstdlib>\n#include<cassert>\n#include<map>\n#include<iomanip>\n#define _A_ true\n#define EPS 1e-10\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\nusing namespace std;\nclass Point{\npublic:\n  double x,y;\n  Point(double x =0,double y=0):x(x),y(y){}\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(x*a,y*a);}\n  Point operator / (double a){return Point(x/a,y/a);} //もし悪を使うなら要確認\n \n  double norm() {return x*x+y*y;}\n  double abs() {return sqrt(norm());}\n \n  bool operator < (const Point &p) const{\n    return x != p.x ? x < p.x : y < p.y; \n  }\n \n  bool operator == (const Point &p) const{\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n\n};\ntypedef Point Point;\nstruct Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p = Point(),Point pp = Point()):p1(p),p2(pp){}\n};\n \ntypedef vector<Point> Polygon;\ntypedef Segment Line;\n \ndouble norm(Point p){\n  return p.x*p.x+p.y*p.y;\n}\n \ndouble abs(Point p){\n  return sqrt(norm(p));\n}\n \nPoint polar(double a,double rad){\n  return Point(a*cos(rad),a*sin(rad));\n}\n \ndouble args(Point p){\n  return atan2(p.y,p.x);\n}\n \ndouble dot(Point a,Point b){\n  return a.x*b.x+a.y*b.y;\n}\n \ndouble cross(Point a,Point b){\n  return a.x*b.y-b.x*a.y;\n}\n \nPoint project(Segment s,Point p){\n  Point base = s.p2 - s.p1;\n  double t = dot(p-s.p1,base)/base.norm();\n  return s.p1+base*t;\n}\n \nPoint reflect (Segment s, Point p){\n  return p + (project(s,p)-p)*2.0;\n}\n \nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS) return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CLOCKWISE;\n  if(dot(a,b) < -EPS) return ONLINE_BACK;\n  if(a.norm() < b.norm() ) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n \nbool isIntersect(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <= 0 && ccw(p3,p4,p1) * ccw(p3,p4,p2) <= 0 );\n}\n \nbool isIntersect(Segment s1,Segment s2){\n  return isIntersect(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nPoint getCrossPointSegments(Segment s1,Segment s2){\n  //assert(isIntersect(s1,s2));\n  Point base = s2.p2 - s2.p1;\n  double d1 = abs(cross(base,s1.p1-s2.p1));\n  double d2 = abs(cross(base,s1.p2-s2.p1));\n  double t = d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n\n\nPoint getCrossPointLines( Line s1, Line s2){\n\n    Point a = s1.p2 - s1.p1;\n    //Point base = Point(s2.p2.x - s2.p1.x,s2.p2.y - s2.p1.y);\n    Point base = s2.p2 -s2.p1;\n    return s1.p1 + a * (cross(base, s2.p1 - s1.p1)/cross(base, a));\n}\n\nPolygon cutPolygon( Polygon P, Line l ){\n    Polygon u;\n    \n    for ( int i = 0; i < P.size(); i++ ){\n        Point a = P[i], b = P[(i+1)%P.size()];\n\t\n\tif ( ccw(l.p1, l.p2, a) != CLOCKWISE ) u.push_back(a);\n\tif ( ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) == -1 ){\n\t  u.push_back(getCrossPointLines(Segment(a, b), l));\n        }\n    }   \n    return u;\n}\n \n \nLine CreateLine(Point p,Point pp){\n  Point mid = (p+pp)/2;\n  Point sl = pp-p;//原点に5\n  double rad = args(sl);\n  Point ap = polar(abs(sl),rad+M_PI/2)+mid;\n  //ap.x = abs(sl)*cos(rad+M_PI/2)+mid.x;\n  //ap.y = abs(sl)*sin(rad+M_PI/2)+mid.y;\n  return Line(mid,ap);\n} \n \ndouble AreaCalc(Polygon p){\n  double area = 0;\n  for(int i=0;i<p.size();i++)\n    area+=cross(p[i],p[(i+1)%p.size()]);\n  return fabs(area)/2.0;\n} \n \nint main(){\n\n  int N,M;\n  while(cin >> N >> M,N|M){\n  \n  vector<Point> l(N);\n  vector<Point> C(M);\n  for(int i=0;i<N;i++)\n    {\n      cin >> l[i].x >> l[i].y;\n      l[i].x += 3000,l[i].y += 3000;\n    }\n  for(int i=0;i<M;i++)\n    {\n      cin >> C[i].x >> C[i].y;\n      C[i].x += 3000,C[i].y += 3000;\n    }\n  for(int i=0;i<M;i++)\n    {\n      Polygon poly; \n      for(int j=0;j<N;j++)\n\tpoly.push_back(l[j]);\n\n      for(int j=0;j<M;j++)\n\t{\n\t  if(j == i)\n\t    continue;\n\t  poly = cutPolygon(poly,CreateLine(C[i],C[j]));\n\t}\n      \n      cout << setiosflags(ios::fixed) << setprecision(1) << AreaCalc(poly) << endl;\n\n    }  \n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<string>\n#include<cstring>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i=((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i=((int)(n))-1;i>=0;i--)\n#define ireg(i,a,b) for(int i=((int)(b));i>=((int)(a));i--)\ntypedef long long int lli;\ntypedef pair<int,int> mp;\n#define fir first\n#define sec second\n\n\ntypedef double D;\n\nconst D pi=3.14159265358979;\n\nstruct P{\n\tD x,y,n,n2;\n\tD norm,norm2;\n\tP(){}\n\tP(D ix,D iy){\n\t\tx=ix; y=iy;\n\t\tn2=x*x+y*y;\n\t\tn=sqrt(n2);\n\t}\n\tP to(P a){\n\t\treturn (a-(*this));\n\t}\n\tP operator+(P a)const{\n\t\treturn P(x+a.x,y+a.y);\n\t}\n\tP operator-(P a)const{\n\t\treturn P(x-a.x,y-a.y);\n\t}\n\tP scalar(D a){\n\t\treturn P(x*a,y*a);\n\t}\n\tD dot(P a){\n\t\treturn x*a.x + y*a.y;\n\t}\n\tD cross(P a){\n\t\treturn x*a.y - y*a.x;\n\t}\n\tD theta(P a){\n\t\tD s = (cross(a)/(n*a.n))>0.0?1:-1;\n\t\treturn acos(max(-1.0,min(1.0,dot(a)/(n*a.n))))*s;\n\t}\n\tstatic P polar(D r,D t){\n\t\treturn P(r*cos(t),r*sin(t));\n\t}\n\tP turn(D t){\n\t\treturn P(x*cos(t)-y*sin(t),x*sin(t)+y*cos(t));\n\t}\n\tP tolen(D a){\n\t\treturn this->scalar(a/n);\n\t}\n\tbool  operator<(P a) const{\n\t\tif(y!=a.y)return (y<a.y);\n\t\treturn (x<a.x);\n\t}\t\n\tbool operator>(P a)const{ return (a<(*this)); }\t\n};\n\nstruct L{\n\tP p,q,v;\n\tL(){}\n\tL(P ip,P iq){\n\t\tp=ip; q=iq;\n\t\tv=p.to(q);\n\t}\n\tbool iscross(L a){\n\t\tD da,db;\n\t\tda=v.cross(p.to(a.p));\n\t\tdb=v.cross(p.to(a.q));\n\t\tif(da*db>=0)return false;\n\t\tda=a.v.cross(a.p.to(p));\n\t\tdb=a.v.cross(a.p.to(q));\n\t\treturn (da*db<0);\n\t}\n\n\tD dist(P a){\n\t\tif(p.to(a).dot(p.to(q))<0)return p.to(a).n;\n\t\tif(q.to(a).dot(q.to(p))<0)return q.to(a).n;\n\t\treturn abs(v.cross(p.to(a))/v.n);\n\t}\n\tD dist(L a){\n\t\tif(iscross(a))return 0;\n\t\treturn min(min(dist(a.p),dist(a.q)) , min(a.dist(this->p),a.dist(this->q)));\n\t}\n\tP crosspos(L a){\n\t\treturn (p+v.scalar(a.v.cross(a.p-p)/a.v.cross(v)));\n\t}\n\tL bisection(){//垂直二等分線\n\t\t//半時計回りに90度回った向きの。\n\t\tP fr=(p+q).scalar(0.5);\n\t\tP to=fr+P(-v.y,v.x);\n\t\treturn L(fr,to);\n\t}\n};\n\n\nstruct Pol{\n\tvector<P> ps;\n\tPol(){}\n\tD area(){\n\t\tD res=0;\n\t\trep(i,ps.size()){\n\t\t\tP no=ps[i],to=ps[(i+1)%ps.size()];\n\t\t\tres+=(no.x+to.x)*(no.y-to.y);\n\t\t}\n\t\tif(res<0)reverse(ps.begin(),ps.end());\n\t\treturn abs(res)/2;\n\t}\n\tPol(P a,P b){\n\t\tps.push_back(a);\n\t\tps.push_back(P(a.x,b.y));\n\t\tps.push_back(b);\n\t\tps.push_back(P(b.x,a.y));\n\t}\n\tL gete(int a){\n\t\ta%=ps.size();\n\t\treturn L(ps[a],ps[(a+1)%ps.size()]);\n\t}\n\tint isin(P a){//内側なら2,乗ってるなら1,外なら0\n\t\tD as=0;\n\t\trep(i,ps.size()){\n\t\t\tL ne=gete(i);\n\t\t\tif(ne.dist(a)<=0)return 1;\n\t\t\tP v1=a.to(ne.p);\n\t\t\tP v2=a.to(ne.q);\n\t\t\tas+=v1.theta(v2);\n\t\t}\n\t\tif(abs(as)<1e-6)return 0;\n\t\treturn 2;\n\t}\n\tPol cut(L a){//進行方向右手を残す\n\t\tPol res;\n\t\trep(i,ps.size()){\n\t\t\tL ne=gete(i);\n\t\t\tD d1=a.v.cross(a.p.to(ne.p));\n\t\t\tD d2=a.v.cross(a.p.to(ne.q));\n\t\t\tif(d1<1e-6)res.ps.push_back(ne.p); //こっちは正のeps\n\t\t\tif(d1*d2<-1e-6)res.ps.push_back(a.crosspos(ne)); //こっちは負のeps\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tvector<Pol> voronoi(vector<P> ps){\n\t\t//validate AOJ 2160\n\t\tvector<Pol> res;\n\t\trep(i,ps.size()){\n\t\t\tPol np(*this);\n\t\t\trep(j,ps.size()){\n\t\t\t\tif(i==j)continue;\n\t\t\t\tL nl = L(ps[j],ps[i]).bisection();\n\t\t\t\t\n\t\t\t\tnp = np.cut(nl);\n\t\t\t}\n\t\t\tres.push_back(np);\n\t\t}\n\t\treturn res;\t\t\n\t}\n};\n\nint main(){\n\tfor(;;){\n\t\tint n,m;\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tif(n==0)break;\n\t\tPol po;\n\t\trep(i,n){\n\t\t\tdouble x,y;\n\t\t\tscanf(\"%lf%lf\",&x,&y);\n\t\t\tpo.ps.push_back(P(x,y));\n\t\t}\n\t\n\t\tvector<P> tps;\n\t\trep(i,m){\n\t\t\tdouble x,y;\n\t\t\tscanf(\"%lf%lf\",&x,&y);\n\t\t\ttps.push_back(P(x,y));\n\t\t}\n\t\tvector<Pol> anss = po.voronoi(tps);\n\t\n\t\trep(i,anss.size()){\n\t\t\tprintf(\"%lf\\n\",anss[i].area());\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P; //Point\ntypedef pair<P,P> L; //Line, Segment\n\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\n\nnamespace std {\n  bool operator < (const P& a, const P& b){\n    return fabs(real(a)-real(b)) < EPS ? imag(a) < imag(b) : real(a) < real(b);\n  }\n}\ndouble dot(P a, P b){ return real(conj(a)*b); }\ndouble cross(P a, P b){ return imag(conj(a)*b); }\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > EPS) return 1;   // ????????????(b-a)????????´???????????????(c-a)????????¨?????????\n  if(cross(b,c) < -EPS) return -1; // ????????????(b-a)????????´???????????????(c-a)????????¨?????????\n  if(dot(b,c) < -EPS) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n\ndouble area(vector<P> v){\n  double sum = 0.0;\n  int n = v.size();\n  for(int i=0;i<n;i++) sum += (real(v[i]) - real(v[(i+1)%n])) * (imag(v[i]) + imag(v[(i+1)%n]));\n  return fabs(sum) / 2;\n};\n\nP crossPoint(L l, L m){\n  double A = cross(l.second - l.first, m.second - m.first);\n  double B = cross(l.second - l.first, l.second - m.first);\n  if(fabs(A) < EPS && fabs(B) < EPS) return m.first;\n  else if(fabs(A) >= EPS) return m.first + B / A * (m.second - m.first);\n}\n\nvector<P> convex_cut(vector<P> G, L l){\n  vector<P> ans;\n  for(int i=0;i<G.size();i++){\n    P A = G[i];\n    P B = G[(i+1)%G.size()];\n    if(ccw(l.first, l.second, A) != -1) ans.push_back(A);\n    if(ccw(l.first, l.second, A) * ccw(l.first, l.second, B) < 0)\n      ans.push_back(crossPoint(L(A,B), l));\n  }\n  return ans;\n}\n\nint n,m;\nvector<P> mp;\ndouble calc(int idx,vector<P>g){\n  for(int i=0;i<m;i++){\n    if(i==idx)continue;\n    P t=mp[idx]-mp[i];\n    P a=P(abs(t)/2,1)*t/abs(t)+mp[i];\n    P b=P(abs(t)/2,-1)*t/abs(t)+mp[i];\n    g=convex_cut(g,L(a,b));\n  }\n  return area(g);\n}\n\nint main(){\n  while(1){\n  cin>>n>>m;\n  if(!n&&!m)break;\n  vector<P> pl(n);\n  mp.resize(m);\n  for(int i=0,x,y;i<n;i++)cin>>x>>y,pl[i]=P(x,y);\n  for(int i=0,x,y;i<m;i++)cin>>x>>y,mp[i]=P(x,y);\n  for(int i=0;i<m;i++)printf(\"%.10f\\n\",calc(i,pl));\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-5;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\nint sign(double r){ return (r < -EPS) ? -1 : (r > EPS) ? 1 : 0; }\nbool eq(double a, double b){ return abs(b - a) < EPS; }\n\nstruct Point{\n  double x, y;\n  Point() {}\n  Point(double x, double y) : x(x), y(y) {}\n  Point operator+(const Point& b) const { return Point(x + b.x, y + b.y); }\n  Point operator-(const Point& b) const { return Point(x - b.x, y - b.y); }\n  Point operator*(const double b) const { return Point(x * b, y * b); }\n  Point operator*(const Point& b) const { return Point(x * b.x - y * b.y, x * b.y + y * b.x); }\n  Point operator/(const double b) const { return Point(x / b, y / b); }\n  bool operator< (const Point& b) const { return x != b.x ? x < b.x : y < b.y; }\n  bool operator==(const Point& b) const { return eq(x, b.x) && eq(y, b.y); }\n  double norm(){ return x * x + y * y; }\n  double arg(){ return atan2(x, y); }\n  double abs(){ return sqrt(norm()); }\n  Point rotate(double theta){ return Point(cos(theta) * x - sin(theta) * y, sin(theta) * x + cos(theta) * y); }\n  Point rotate90(){ return Point(-y, x); }\n};\n\nostream& operator<<(ostream& os, Point& p){ return os<<\"(\"<<p.x<<\",\"<<p.y<<\")\"; }\nistream& operator>>(istream& is, Point& a){ return is>>a.x>>a.y; }\ndouble dot(const Point& a, const Point& b){ return a.x * b.x + a.y * b.y; }\ndouble cross(const Point& a, const Point& b){ return a.x * b.y - a.y * b.x; }\nPoint polor(double rho, double theta){ return Point(rho * cos(theta), rho * sin(theta)); }\n\nstruct Line : public vector<Point> {\n  Line(const Point& a, const Point& b) {\n    push_back(a); push_back(b);\n  }\n  Point vector() const {\n    return back() - front();\n  }\n};\nstruct Circle : Point {\n  double r;\n  Circle(Point p, double r) : Point(p), r(r) { }\n};\ntypedef vector<Point> Polygon;\nPoint curr(const Polygon& a, int x){ return a[x]; }\nPoint next(const Polygon& a, int x){ return a[(x + 1) % a.size()]; }\nPoint prev(const Polygon& a, int x){ return a[(x - 1 + a.size()) % a.size()]; }\n\n//a->b->c\nint ccw(Point a, Point b, Point c) {\n  b = b - a; c = c - a;\n  if (cross(b, c) > EPS)   return +1; // 反時計回り\n  if (cross(b, c) < -EPS)   return -1; // 時計回り\n  if (dot(b, c) < 0)     return +2; // c--a--b の順番で一直線上\n  if (b.norm() < c.norm()) return -2; // a--b--c の順番で一直線上\n  return 0;                         // a--c--b の順番で一直線上\n}\n// 二直線の交差判定\nbool intersectLL(const Line& l, const Line& m) {\n  return abs(cross(l.vector(), m.vector())) > EPS || // 傾きが異なる\n         abs(cross(l.vector(), m[0] - l[0])) < EPS;   // 同じ直線である\n}\n// 直線と線分の交差判定\nbool intersectLS(const Line& l, const Line& s) {\n  return cross(l.vector(), s[0] - l[0]) * cross(l.vector(), s[1] - l[0]) < EPS; //直線lについて、線分sの端点が異なる側にある\n}\n// 直線と点の交差判定\nbool intersectLP(const Line& l, const Point& p) {\n  return abs(ccw(l[0], l[1], p)) != 1;\n}\n// 二つの線分の交差判定\nbool intersectSS(const Line& s, const Line& t) {\n  return ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n         ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\n// 線分と点の交差判定\nbool intersectSP(const Line& s, const Point& p) {\n  return ccw(s[0], s[1], p) == 0;\n}\n// 円と点の交差判定(EPS注意)\nbool intersectCP(const Circle& c, const Point& p){\n  return (c - p).abs() < c.r + EPS;\n}\n// 二つの円の交差判定(EPS注意)\nbool intersectCC(const Circle& c, const Circle& d){\n  return (c - d).abs() < c.r + d.r + EPS && (c - d).abs() > abs(c.r - d.r) - EPS;\n}\n// 射影\nPoint projection(const Line& l, const Point& p){\n  double t = dot(p - l[0], l.vector()) / l.vector().norm();\n  return l[0] + l.vector() * t;\n}\n// 反射\nPoint reflection(const Line& l, const Point& p){\n  return p + (projection(l, p) - p) * 2;\n}\n// 直線と点の距離\ndouble distanceLP(const Line& l, const Point& p){\n  return (p - projection(l, p)).abs();\n}\n// 二直線の距離\ndouble distanceLL(const Line& l, const Line& m){\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\n// 直線と線分の距離\ndouble distanceLS(const Line& l, const Line& s){\n  if(intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\n// 線分と点の距離\ndouble distanceSP(const Line& s, const Point& p){\n  const Point r = projection(s, p);\n  if(intersectSP(s, r)) return (r - p).abs(); //垂線が線分に交わるとき\n  return min((s[0] - p).abs(), (s[1] - p).abs());\n}\n// 二つの線分の距離\ndouble distanceSS(const Line& s, const Line& t){\n  if(intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n// 二直線の交点\nPoint crosspointLL(const Line& l, const Line& m){\n  double d = cross(m.vector(), l.vector());\n  if(abs(d) < EPS) assert(false); // 直線が交わらない\n  return l[0] + l.vector() * cross(m.vector(), m[1] - l[0]) * (1.0 / d);\n}\n\nPolygon convex_cut(const Polygon& P, const Line& l){\n  Polygon Q;\n  REP(i, P.size()){\n    Point A = curr(P, i), B = next(P, i);\n    if(ccw(l[0], l[1], A) != -1) Q.push_back(A); //Aが直線lの右側でない\n    if (ccw(l[0], l[1], A) * ccw(l[0], l[1], B) < 0)\n      Q.push_back(crosspointLL(l, Line(A, B)));\n  }\n  return Q;\n}\nLine median(const Point& a, const Point& b){\n  Point mid((a.x + b.x) / 2.0, (a.y + b.y) / 2.0);\n  Point vec = (mid - a).rotate90();\n  return Line(mid, mid + vec);\n}\n\ndouble area(const Polygon& P) {\n  double A = 0;\n  REP(i, P.size()){\n    A += cross(curr(P, i), next(P, i));\n  }\n  return A / 2.0;\n}\nint main(){\n  int N, M;\n  while(cin>>N>>M){\n    Polygon island(N);\n    REP(i, N) cin>>island[i];\n    vector<Point> castle(M);\n    REP(i, M) cin>>castle[i];\n    REP(i, M){\n      Polygon land = island;\n      REP(j, M) if(i != j){\n        land = convex_cut(land, median(castle[i], castle[j]));\n      }\n      printf(\"%.6lf\\n\", area(land));\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\nint sign(double r){ return (r < -EPS) ? -1 : (r > EPS) ? 1 : 0; }\nbool eq(double a, double b){ return abs(b - a) < EPS; }\n\nstruct Point{\n  double x, y;\n  Point() {}\n  Point(double x, double y) : x(x), y(y) {}\n  Point operator+(const Point& b) const { return Point(x + b.x, y + b.y); }\n  Point operator-(const Point& b) const { return Point(x - b.x, y - b.y); }\n  Point operator*(const double b) const { return Point(x * b, y * b); }\n  Point operator*(const Point& b) const { return Point(x * b.x - y * b.y, x * b.y + y * b.x); }\n  Point operator/(const double b) const { return Point(x / b, y / b); }\n  bool operator< (const Point& b) const { return x != b.x ? x < b.x : y < b.y; }\n  bool operator==(const Point& b) const { return eq(x, b.x) && eq(y, b.y); }\n  double norm(){ return x * x + y * y; }\n  double arg(){ return atan2(x, y); }\n  double abs(){ return sqrt(norm()); }\n  Point rotate(double theta){ return Point(cos(theta) * x - sin(theta) * y, sin(theta) * x + cos(theta) * y); }\n  Point rotate90(){ return Point(-y, x); }\n};\n\nostream& operator<<(ostream& os, Point& p){ return os<<\"(\"<<p.x<<\",\"<<p.y<<\")\"; }\nistream& operator>>(istream& is, Point& a){ return is>>a.x>>a.y; }\ndouble dot(const Point& a, const Point& b){ return a.x * b.x + a.y * b.y; }\ndouble cross(const Point& a, const Point& b){ return a.x * b.y - a.y * b.x; }\nPoint polor(double rho, double theta){ return Point(rho * cos(theta), rho * sin(theta)); }\n\nstruct Line : public vector<Point> {\n  Line(const Point& a, const Point& b) {\n    push_back(a); push_back(b);\n  }\n  Point vector() const {\n    return back() - front();\n  }\n};\nstruct Circle : Point {\n  double r;\n  Circle(Point p, double r) : Point(p), r(r) { }\n};\ntypedef vector<Point> Polygon;\nPoint curr(const Polygon& a, int x){ return a[x]; }\nPoint next(const Polygon& a, int x){ return a[(x + 1) % a.size()]; }\nPoint prev(const Polygon& a, int x){ return a[(x - 1 + a.size()) % a.size()]; }\n\n//a->b->c\nint ccw(Point a, Point b, Point c) {\n  b = b - a; c = c - a;\n  if (cross(b, c) > EPS)   return +1; // 反時計回り\n  if (cross(b, c) < -EPS)   return -1; // 時計回り\n  if (dot(b, c) < 0)     return +2; // c--a--b の順番で一直線上\n  if (b.norm() < c.norm()) return -2; // a--b--c の順番で一直線上\n  return 0;                         // a--c--b の順番で一直線上\n}\n// 二直線の交差判定\nbool intersectLL(const Line& l, const Line& m) {\n  return abs(cross(l.vector(), m[1] - m[0])) > EPS || // 傾きが異なる\n         abs(cross(l.vector(), m[0] - l[0])) < EPS;   // 同じ直線である\n}\n// 直線と線分の交差判定\nbool intersectLS(const Line& l, const Line& s) {\n  return cross(l.vector(), s[0] - l[0]) * cross(l.vector(), s[1] - l[0]) < EPS; //直線lについて、線分sの端点が異なる側にある\n}\n// 直線と点の交差判定\nbool intersectLP(const Line& l, const Point& p) {\n  return abs(ccw(l[0], l[1], p)) != 1;\n}\n// 二つの線分の交差判定\nbool intersectSS(const Line& s, const Line& t) {\n  return ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n         ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0;\n}\n// 線分と点の交差判定\nbool intersectSP(const Line& s, const Point& p) {\n  return ccw(s[0], s[1], p) == 0;\n}\n// 円と点の交差判定(EPS注意)\nbool intersectCP(const Circle& c, const Point& p){\n  return (c - p).abs() < c.r + EPS;\n}\n// 二つの円の交差判定(EPS注意)\nbool intersectCC(const Circle& c, const Circle& d){\n  return (c - d).abs() < c.r + d.r + EPS && (c - d).abs() > abs(c.r - d.r) - EPS;\n}\n// 射影\nPoint projection(const Line& l, const Point& p){\n  double t = dot(p - l[0], l.vector()) / l.vector().norm();\n  return l[0] + l.vector() * t;\n}\n// 反射\nPoint reflection(const Line& l, const Point& p){\n  return p + (projection(l, p) - p) * 2;\n}\n// 直線と点の距離\ndouble distanceLP(const Line& l, const Point& p){\n  return (p - projection(l, p)).abs();\n}\n// 二直線の距離\ndouble distanceLL(const Line& l, const Line& m){\n  return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\n// 直線と線分の距離\ndouble distanceLS(const Line& l, const Line& s){\n  if(intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\n// 線分と点の距離\ndouble distanceSP(const Line& s, const Point& p){\n  const Point r = projection(s, p);\n  if(intersectSP(s, r)) return (r - p).abs(); //垂線が線分に交わるとき\n  return min((s[0] - p).abs(), (s[1] - p).abs());\n}\n// 二つの線分の距離\ndouble distanceSS(const Line& s, const Line& t){\n  if(intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n             min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n// 二直線の交点\nPoint crosspointLL(const Line& l, const Line& m){\n  double d = cross(m.vector(), l.vector());\n  if(abs(d) < EPS) assert(false); // 直線が交わらない\n  return l[0] + l.vector() * cross(m.vector(), m[1] - l[0]) * (1.0 / d);\n}\n\nPolygon convex_cut(const Polygon& P, const Line& l){\n  Polygon Q;\n  REP(i, P.size()){\n    Point A = curr(P, i), B = next(P, i);\n    if(ccw(l[0], l[1], A) != -1) Q.push_back(A); //Aが直線lの右側でない\n    if(intersectLS(l, Line(A, B))) \n      Q.push_back(crosspointLL(l, Line(A, B)));\n  }\n  return Q;\n}\nLine median(const Point& a, const Point& b){\n  Point mid((a.x + b.x) / 2.0, (a.y + b.y) / 2.0);\n  Point vec = (mid - a).rotate90();\n  return Line(mid, mid + vec);\n}\n\ndouble area(const Polygon& P) {\n  double A = 0;\n  REP(i, P.size()){\n    A += cross(curr(P, i), next(P, i));\n  }\n  return A / 2.0;\n}\nint main(){\n  int N, M;\n  while(cin>>N>>M){\n    Polygon island(N);\n    REP(i, N) cin>>island[i];\n    vector<Point> castle(M);\n    REP(i, M) cin>>castle[i];\n    REP(i, M){\n      Polygon land = island;\n      REP(j, M) if(i != j){\n        land = convex_cut(land, median(castle[i], castle[j]));\n      }\n      printf(\"%.6lf\\n\", area(land));\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#include <algorithm> \n#include <vector> \n#include <cmath>   \n#include <complex> \n#include <queue> \n#include <cstdio> \nusing namespace std;\nconst double EPS = 1e-9; const double PI = acos(-1);    typedef complex<double> P; typedef vector<P> G;    struct L :public vector<P> {     L(const P &a,const P &b){         push_back(a);         push_back(b);     } };    \n#define next(P,i) (P[(i+1)%P.size()]) \n#define curr(P,i) (P[(i+0)%P.size()])    \ndouble cross(const P &a,const P &b){     return imag(conj(a)*b); } double dot(const P &a,const P &b){     return real(conj(a)*b); }    int ccw(P a,P b,P c){     b -= a;     c -= a;     if( cross(b,c) > 0 ) return +1;     if( cross(b,c) < 0 ) return -1;     if( dot(b,c) < 0 ) return +2;     if( norm(b) < norm(c) ) return -2;     return 0; }    P crosspoint(const L &l,const L &m){     double A = cross(l[1]-l[0],m[1]-m[0]);     double B = cross(l[1]-l[0],l[1]-m[0]);     if( abs(A) < EPS && abs(B) < EPS) return m[0];     return m[0]+B/A*(m[1]-m[0]); }       G convex_cut(const G &poly,const L &l){     G Q;     for(int i = 0 ; i < poly.size() ; i++){         P A = curr(poly,i) , B = next(poly,i);         if( ccw(l[0],l[1],A)!=-1)Q.push_back(A);         if( ccw(l[0],l[1],A)*ccw(l[0],l[1],B)<0)Q.push_back(crosspoint(L(A,B),l));     }     return Q;             }    L bisector(P a,P b){     P A = (a+b) * P(0.5,0);     return L(A,A+(b-a)*P(0,PI/2)); } G voronoi(G g,vector<P> v,int s){     for(int i = 0 ; i < v.size() ; i++){         if( i != s ){             g = convex_cut(g,bisector(v[s],v[i]));         }     }     return g; }    double Area(const G& poly) {     double A = 0;     for (int i = 0; i < poly.size(); ++i)A += cross(curr(poly, i), next(poly, i));     return abs(A)/2; }                                       \nint main(){\n    int N,M;\n\twhile(cin >> N >> M && N){\n\tG area,p;\n\tfor(int i = 0 ; i < N ; i++){\n\t\tP po;\n\t\tcin >> po.real() >> po.imag();\n\t\tarea.push_back(po);\n\t}\n\tfor(int i = 0 ; i < M ; i++){\n\t\tP po;\n\t\tcin >> po.real() >> po.imag();\n\t\tp.push_back(po);\n\t}\n\tdouble ans = 0;\n\tfor(int i = 0 ; i < M ; i++){\n\t\tprintf(\"%.10lf\\n\",Area(voronoi(area,p,i)));\n\t}\n } \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace {\n    \n    const double EPS = 1e-8;\n\n    struct Point {\n        double x, y;\n        Point() {}\n        Point(double x, double y) : x(x), y(y) {}\n        Point operator+(const Point& p) const { return Point(x + p.x, y + p.y); }\n        Point operator-(const Point& p) const { return Point(x - p.x, y - p.y); }\n        Point operator*(double k) const { return Point(k * x, k * y); }\n        Point operator/(double k) const { return Point(x / k, y / k); }\n    };\n    double dot(const Point& a, const Point& b) { return a.x * b.x + a.y * b.y; }\n    double cross(const Point& a, const Point& b) { return a.x * b.y - a.y * b.x; }\n    double norm(const Point& a) { return sqrt(dot(a, a)); }\n    Point rot90(const Point& p) { return Point(-p.y, p.x); } // 反時計回りに90度回転 \n    double angle(const Point& a) { return atan2(a.y, a.x); } // x軸を反時計回りに何ラジアン回転させれば点aに乗るか\n    ostream& operator<<(ostream& os, const Point& p) { return os << \"(\" << p.x << \",\" << p.y << \")\"; }\n    istream& operator>>(istream& is, Point& p) { return is >> p.x >> p.y; }\n\n    int ccw(Point a, Point b, Point c){\n        b = b - a; c = c - a;\n        if (cross(b, c) > EPS) return +1;      // a,b,cの順に反時計周り\n        if (cross(b, c) < -EPS) return -1;     // a,b,cの順に時計周り\n        if (dot(b, c) < 0) return +2;          // c--a--b 直線\n        if (norm(b) < norm(c)) return -2;      // a--b--c 直線\n        return 0;                              // a--c--b 直線\n    }\n\n    struct Line {\n        Point a, b;\n        Line() {}\n        Line(const Point& a, const Point& b) : a(a), b(b) {}\n    };\n    ostream& operator<<(ostream& os, const Line& l) {\n        return os << \"Line(\" << l.a << \",\" << l.b << \")\";\n    }\n    Point crosspoint(const Line& s, const Line& t) {\n        double d = cross(t.b - t.a, s.b - s.a);\n        assert(abs(d) >= EPS);\n        return s.a + (s.b - s.a) * cross(t.b - t.a, t.b - s.a) / d;\n    }\n    bool parallel(const Line& s, const Line& t) { return abs(cross(s.b - s.a, t.b - t.a)) < EPS; }\n\n    template<class T> ostream& operator<<(ostream& os, const vector<T>& vs) {\n        if (vs.empty()) return os << \"[]\";\n        os << \"[\" << vs[0];\n        for (int i = 1; i < vs.size(); i++) os << \" \" << vs[i];\n        return os << \"]\";\n    }\n\n    int N, M;\n    vector<Point> V;\n    vector<Point> L;\n    bool input() {\n        cin >> N >> M;\n        if (N == 0 && M == 0) return false;\n        V.clear(); V.resize(N);\n        L.clear(); L.resize(M);\n        for (int i = 0; i < N; i++) cin >> V[i];\n        for (int j = 0; j < M; j++) cin >> L[j];\n        return true;\n    }\n\n    Line midline(Point a, Point b) {\n        Point m = (a + b) / 2;\n        Point v = b - m;\n        return Line(m, m + rot90(v));\n    }\n\n    typedef vector<Point> Polygon;\n    double area(const Polygon& vs) {\n        assert(vs.size() >= 3);\n        double r = 0;\n        for (int i = 0; i < vs.size(); i++) {\n            const Point& a = vs[i];\n            const Point& b = vs[(i + 1) % vs.size()];\n            r += cross(a, b);\n        }\n        return r / 2;\n    }\n\n    struct angle_comp {\n        Point p;\n        angle_comp(Point p) : p(p) {}\n        bool operator()(Point a, Point b) {\n            return angle(a - p) < angle(b - p);\n        }\n    };\n\n    void solve() {\n        for (int i = 0; i < M; i++) {\n            vector<Point> P = V;\n            for (int j = 0; j < M; j++) {\n                if (i == j) continue;\n                Line m = midline(L[i], L[j]);\n                vector<Point> add;\n                int n = P.size();\n                for (int k = 0; k < n; k++) {\n                    Line e(P[k], P[(k + 1) % n]);\n                    if (parallel(m, e)) continue;\n                    Point p = crosspoint(m, e);\n                    if (ccw(e.a, p, e.b) == -2) {\n                        add.push_back(p);\n                    }\n                }\n                assert(add.size() == 2);\n                vector<Point> nP = add;\n                for (int k = 0; k < n; k++) {\n                    Line c(L[i], P[k]);\n                    if (parallel(c, m)) continue;\n                    if (ccw(L[i], crosspoint(c, m), P[k]) == -2) continue;\n                    nP.push_back(P[k]);\n                }\n                sort(nP.begin(), nP.end(), angle_comp(L[i]));\n                P = nP;\n            }\n            printf(\"%.12lf\\n\", area(P));\n        }\n    }\n}\n\nint main() {\n    while (input()) solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define inf 1000000000\n#define eps (1e-11)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1,Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nPoint median_Point(Point a,Point b){\n  Vector v=a-b;\n  return b+(v/2);\n}\n\nstatic const int COUNTER_CLOCKWISE=1;\nstatic const int CLOCKWISE=-1;\nstatic const int ONLINE_BACK=2;\nstatic const int ONLINE_FRONT=-2;\nstatic const int ON_SEGMENT=0;\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps)return COUNTER_CLOCKWISE;\n  if(cross(a,b)<-eps)return CLOCKWISE;\n  if(dot(a,b)<-eps)return ONLINE_BACK;\n  if(a.norm()<b.norm())return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nPoint PointRotation(Point base,Point a,double r){\n  Point b=a-base;\n  a.x=b.x*cos((r/180)*M_PI)-b.y*sin((r/180)*M_PI);\n  a.y=b.x*sin((r/180)*M_PI)+b.y*cos((r/180)*M_PI);\n  a=a+base;\n  return a;\n}\n\nLine getPerpendicularBisector(Segment S){\n  Point p1=median_Point(S.p1,S.p2);\n  Point p2=PointRotation(p1,S.p1,90);\n  Point p3=PointRotation(p1,S.p1,270);\n  return Line(p2,p3);\n}\n\nPoint getCrossPointLL(Line a,Line b){\n  double A=cross(a.p2-a.p1,b.p2-b.p1);\n  double B=cross(a.p2-a.p1,a.p2-b.p1);\n  if(abs(A)<eps && abs(B)<eps)return b.p1;\n  return b.p1+(b.p2-b.p1)*(B/A);\n}\n \ndouble getPolygonArea(Polygon p){\n  double area=0.0;\n  int n=p.size();\n  for(int i=0;i<n;i++)area+=cross(p[i%n],p[(i+1)%n]);\n  return area/2;\n}\n\n//  Polygon???Line??§????????????????????????????????????\nPolygon convex_cut(Polygon p,Line l){\n  Polygon ans;\n  for(int i=0;i<p.size();i++){\n    Point A=p[i],B=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,A)!=-1)ans.push_back(A);\n    if(ccw(l.p1,l.p2,A)*ccw(l.p1,l.p2,B)<0)\n      ans.push_back(getCrossPointLL(l,Segment(A,B)));\n  }\n  return ans;\n}\n\nint main()\n{\n  int n,m;\n  Polygon P;\n  vector<Point> vp;\n\n  while(1){\n    cin>>n>>m;\n    if(n+m==0)break;\n    P.clear();vp.clear();\n    P.resize(n);vp.resize(m);\n    for(int i=0;i<n;i++)cin>>P[i].x>>P[i].y;\n    for(int i=0;i<m;i++)cin>>vp[i].x>>vp[i].y;\n    \n    for(int i=0;i<m;i++){\n      double ans=inf;\n      Polygon v=P;\n      for(int j=0;j<m;j++){\n\tif(i==j)continue;\n\tLine L1=getPerpendicularBisector(Segment(vp[i],vp[j]));\n\tv=convex_cut(v,L1);\n      }\n      printf(\"%.10f\\n\",getPolygonArea(v));\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\nconst double EPS = 1e-8;\n\ndouble cross(P a, P b){\n  return a.real() * b.imag() - a.imag() * b.real();\n}\n\nvector<P> convexCut(vector<P>& g, P p, P q){\n  vector<P> res;\n  int n = g.size();\n  for(int i=0;i<n;i++){\n    P A(g[i]), B(g[(i+1)%n]);\n    double p1 = cross(q-p, A-p);\n    double p2 = cross(q-p, B-p);\n    if(p1 > -EPS) res.push_back(A);\n    if(p1 * p2 < -EPS) res.push_back(A + cross(q-p, q-A) / cross(q-p, B-A) * (B-A));\n  }\n  return res;\n}\n\ndouble getArea(vector<P>& g){\n  double res = 0.0;\n  for(int i=0;i<g.size();i++) res += cross(g[i], g[(i+1)%g.size()]);\n  return abs(res) * 0.5;\n}\n\nmain(){\n  int n, m;\n  while(cin >> n >> m && (n|m)){\n    vector<P> A, B;\n    double a, b;\n    for(int i=0;i<n;i++){\n      cin >> a >> b;\n      A.push_back(P(a, b));\n    }\n    for(int i=0;i<m;i++){\n      cin >> a >> b;\n      B.push_back(P(a, b));\n    }\n    for(int i=0;i<m;i++){\n      vector<P> tmp = A;\n      for(int j=0;j<m;j++){\n        if(i == j) continue;\n        P mid = (B[i] + B[j]) / 2.0;\n        P p = mid + (B[i] - B[j]) * P(0, 1);\n        if(cross(p-mid, B[i]-mid) > EPS) swap(p, mid);\n        tmp = convexCut(tmp, p, mid);\n      }\n      printf(\"%.5f\\n\", getArea(tmp));\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "using namespace std;\n#define _USE_MATH_DEFINES\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cmath>\n#include<iomanip>\nconst double EPS=1e-10;\nbool eq(double a,double b){return abs(a-b)<EPS;}\nstruct Point{\n\tdouble x,y;\n\tPoint(double x_=0,double y_=0):x(x_),y(y_){}\n\tPoint operator-()const{return Point(-x,-y);}\n\tPoint operator+(const Point&p)const{return Point(x+p.x,y+p.y);}\n\tPoint operator-(const Point&p)const{return Point(x-p.x,y-p.y);}\n\tPoint operator*(const double k)const{return Point(x*k,y*k);}\n\tPoint operator/(const double k)const{return Point(x/k,y/k);}\n\tbool operator<(const Point&p)const{return eq(x,p.x)?y<p.y:x<p.x;}\n\tbool operator==(const Point&p)const{return eq(x,p.x)&&eq(y,p.y);}\n};\nistream&operator>>(istream&is,Point&p){return is>>p.x>>p.y;}\nostream&operator<<(ostream&os,const Point&p){return os<<fixed<<setprecision(9)<<p.x<<' '<<p.y;}\nstruct Line{\n\tPoint p1,p2;\n\tLine(Point p1_=Point(),Point p2_=Point()):p1(p1_),p2(p2_){}\n};\nstruct Segment:Line{\n\tSegment(Point p1_=Point(),Point p2_=Point()):Line(p1_,p2_){}\n};\nstruct Circle{\n\tPoint o;\n\tdouble r;\n\tCircle(Point o_=Point(),double r_=0):o(o_),r(r_){}\n};\nusing Polygon=vector<Point>;\n//function list begin\nPoint vec(const Line&);\ndouble norm(const Point&);\ndouble norm(const Line&);\ndouble abs(const Point&);\ndouble abs(const Line&);\ndouble arg(const Point&);\ndouble arg(const Line&);\ndouble arg(const Point&,const Point&,const Point&);//a->b->c\nint argtype(const Point&);//(-pi,0]->0,(0,pi]->1\nbool argless(const Point&,const Point&);//sorting points with arg\ndouble dot(const Point&,const Point&);\ndouble cross(const Point&,const Point&);\nPoint polar(const double,const double);\nPoint rotate(const Point&,const double);\nenum{ONLINE_FRONT=-2,CLOCKWISE=-1,ON_SEGMENT=0,COUNTER_CLOCKWISE=1,ONLINE_BACK=2};\nint ccw(const Point&,const Point&);\nint ccw(const Point&,const Point&,const Point&);\nint ccw(const Line&,const Point&);\nbool orthogonal(const Point&,const Point&);\nbool orthogonal(const Line&,const Line&);\nbool parallel(const Point&,const Point&);\nbool parallel(const Line&,const Line&);\nbool intersect(const Line&,const Point&);\nbool intersect(const Line&,const Line&);\nbool intersect(const Segment&,const Point&);\nbool intersect(const Segment&,const Segment&);\nbool intersect(const Line&,const Segment&);\nbool intersect(const Segment&,const Line&);\nbool intersect(const Circle&,const Point&);\nint intersect(const Circle&,const Line&);//count contacts\nint intersect(const Circle&,const Segment&);\nint intersect(const Circle&,const Circle&);//count common tangents\ndouble distance(const Point&,const Point&);\ndouble distance(const Line&,const Point&);\ndouble distance(const Line&,const Line&);\ndouble distance(const Segment&,const Point&);\ndouble distance(const Segment&,const Segment&);\ndouble distance(const Line&,const Segment&);\ndouble distance(const Segment&,const Line&);\ndouble distance(const Circle&,const Point&);\ndouble distance(const Circle&,const Line&);\ndouble distance(const Circle&,const Segment&);\ndouble distance(const Circle&,const Circle&);\nPoint projection(const Line&,const Point&);\nPoint reflection(const Line&,const Point&);\nPoint crosspoint(const Line&,const Line&);\npair<Point,Point>crosspoint(const Circle&,const Line&);\npair<Point,Point>crosspoint(const Circle&,const Segment&);\npair<Point,Point>crosspoint(const Circle&,const Circle&);\npair<Point,Point>tangent(const Circle&,const Point&);\nvector<Line>tangent(const Circle&,const Circle&);\nbool is_convex(const Polygon&);\nPolygon convex_full(Polygon,bool=false);\nenum{OUT,ON,IN};\nint contain(const Polygon&,const Point&);\nint contain(const Circle&,const Point&);\nint contain(const Circle&,const Segment&);\nPolygon convex_cut(const Polygon&,const Line&);\ndouble diameter(Polygon);\ndouble area(const Polygon&);\ndouble area(const Polygon&,const Line&);\ndouble area(const Polygon&,const Circle&);\n//function list end\nPoint vec(const Line&s){return s.p2-s.p1;}\ndouble norm(const Point&p){return p.x*p.x+p.y*p.y;}\ndouble norm(const Line&s){return norm(vec(s));}\ndouble abs(const Point&p){return hypot(p.x,p.y);}\ndouble abs(const Line&s){return abs(vec(s));}\ndouble arg(const Point&p){return atan2(p.y,p.x);}\ndouble arg(const Line&s){return arg(vec(s));}\ndouble arg(const Point&a,const Point&b,const Point&c){\n\tdouble A=arg(b-a),B=arg(c-b);\n\tdouble theta=abs(A-B);\n\treturn min(theta,2*M_PI-theta);\n}\nint argtype(const Point&a)\n{\n\treturn a.y<-EPS?0:a.y>EPS?1:a.x<0?1:0;\n}\nbool argless(const Point&a,const Point&b)\n{\n\tint at=argtype(a),bt=argtype(b);\n\treturn at!=bt?at<bt:ccw(a,b)>0;\n}\ndouble dot(const Point&a,const Point&b){return a.x*b.x+a.y*b.y;}\ndouble cross(const Point&a,const Point&b){return a.x*b.y-a.y*b.x;}\nPoint polar(const double r,const double theta){return Point(cos(theta),sin(theta))*r;}\nPoint rotate(const Point&p,const double theta){\n\treturn Point(p.x*cos(theta)-p.y*sin(theta),p.x*sin(theta)+p.y*cos(theta));\n}\nint ccw(const Point&a,const Point&b)\n{\n\treturn cross(a,b)>EPS?COUNTER_CLOCKWISE\n\t\t:cross(a,b)<-EPS?CLOCKWISE\n\t\t:dot(a,b)<0?ONLINE_BACK\n\t\t:norm(a)<norm(b)?ONLINE_FRONT\n\t\t:ON_SEGMENT;\n}\nint ccw(const Point&a,const Point&b,const Point&c){return ccw(b-a,c-a);}\nint ccw(const Line&s,const Point&p){return ccw(s.p1,s.p2,p);}\nbool orthogonal(const Point&a,const Point&b){return eq(dot(a,b),0);}\nbool orthogonal(const Line&s,const Line&t){return orthogonal(vec(s),vec(t));}\nbool parallel(const Point&a,const Point&b){return eq(cross(a,b),0);}\nbool parallel(const Line&s,const Line&t){return parallel(vec(s),vec(t));}\nbool intersect(const Line&s,const Point&p){return eq(cross(vec(s),p-s.p1),0);}\nbool intersect(const Line&s,const Line&t){return !parallel(s,t)||intersect(s,t.p1);}\nbool intersect(const Segment&s,const Point&p){return ccw(s,p)==ON_SEGMENT;}\nbool intersect(const Segment&s,const Segment&t){\n\treturn ccw(s,t.p1)*ccw(s,t.p2)<=0&&ccw(t,s.p1)*ccw(t,s.p2)<=0;\n}\nbool intersect(const Line&s,const Segment&t){\n\treturn cross(vec(s),t.p1-s.p1)*cross(vec(s),t.p2-s.p1)<EPS;\n}\nbool intersect(const Segment&s,const Line&t){return intersect(t,s);}\nbool intersect(const Circle&c,const Point&p){return eq(distance(c.o,p),c.r);}\nint intersect(const Circle&c,const Line&s){\n\tdouble d=distance(s,c.o);\n\treturn eq(d,c.r)?1:d<c.r?2:0;\n}\nint intersect(const Circle&c,const Segment&s){\n\tPoint h=projection(s,c.o);\n\tdouble d1=distance(c.o,s.p1),d2=distance(c.o,s.p2);\n\treturn distance(c.o,h)>c.r+EPS?0\n\t\t:d1<c.r-EPS&&d2<c.r-EPS?0\n\t\t:d1<c.r-EPS&&d2>c.r-EPS||d1>c.r-EPS&&d2<c.r-EPS?1\n\t\t:intersect(s,h)?eq(distance(c.o,h),c.r)?1:2\n\t\t:0;\n}\nint intersect(const Circle&a,const Circle&b){\n\tdouble d=distance(a.o,b.o);\n\treturn eq(d,a.r+b.r)?3:d>a.r+b.r?4:eq(d,abs(a.r-b.r))?1:d>abs(a.r-b.r)?2:0;\n}\ndouble distance(const Point&a,const Point&b){return abs(a-b);}\ndouble distance(const Line&s,const Point&p){return distance(p,projection(s,p));}\ndouble distance(const Line&s,const Line&t){return intersect(s,t)?0:distance(s,t.p1);}\ndouble distance(const Segment&s,const Point&p){\n\treturn distance(p,\n\t\tdot(vec(s),p-s.p1)<0?s.p1\n\t\t:dot(-vec(s),p-s.p2)<0?s.p2\n\t\t:projection(s,p)\n\t);\n}\ndouble distance(const Segment&s,const Segment&t){\n\treturn intersect(s,t)?0:min({\n\t\tdistance(s,t.p1),distance(s,t.p2),\n\t\tdistance(t,s.p1),distance(t,s.p2)\n\t});\n}\ndouble distance(const Line&s,const Segment&t){\n\treturn intersect(s,t)?0:min(distance(s,t.p1),distance(s,t.p2));\n}\ndouble distance(const Segment&s,const Line&t){return distance(t,s);}\ndouble distance(const Circle&c,const Point&p){return abs(distance(c.o,p)-c.r);}\ndouble distance(const Circle&c,const Line&s){return max(distance(s,c.o)-c.r,0.);}\ndouble distance(const Circle&c,const Segment&s){\n\treturn intersect(c,s)?0\n\t\t:contain(c,s)?c.r-max(distance(c.o,s.p1),distance(c.o,s.p2))\n\t\t:distance(s,c.o)-c.r;\n}\ndouble distance(const Circle&a,const Circle&b){return max(distance(a.o,b.o)-a.r-b.r,0.);}\nPoint projection(const Line&s,const Point&p){\n\treturn s.p1+vec(s)*dot(p-s.p1,vec(s))/norm(s);\n}\nPoint reflection(const Line&s,const Point&p){return projection(s,p)*2-p;}\nPoint crosspoint(const Line&s,const Line&t){\n\tdouble d1=abs(cross(vec(s),t.p1-s.p1));\n\tdouble d2=abs(cross(vec(s),t.p2-s.p1));\n\treturn t.p1+vec(t)*(d1/(d1+d2));\n}\npair<Point,Point>crosspoint(const Circle&c,const Line&s){\n\tPoint h=projection(s,c.o);\n\tPoint e=vec(s)/abs(s)*sqrt(c.r*c.r-norm(h-c.o));\n\treturn minmax(h-e,h+e);\n}\npair<Point,Point>crosspoint(const Circle&c,const Segment&s){\n\tpair<Point,Point>p=crosspoint(c,Line(s));\n\treturn intersect(c,s)==2?p\n\t\t:intersect(s,p.first)?make_pair(p.first,p.first)\n\t\t:make_pair(p.second,p.second);\n}\npair<Point,Point>crosspoint(const Circle&a,const Circle&b){\n\tdouble d=distance(a.o,b.o);\n\tdouble alpha=acos((a.r*a.r+d*d-b.r*b.r)/(2*a.r*d));\n\tdouble theta=arg(b.o-a.o);\n\treturn minmax(a.o+polar(a.r,theta+alpha),a.o+polar(a.r,theta-alpha));\n}\npair<Point,Point>tangent(const Circle&c,const Point&p){\n\treturn crosspoint(c,Circle(p,sqrt(norm(c.o-p)-c.r*c.r)));\n}\nvector<Line>tangent(const Circle&a,const Circle&b){\n\tvector<Line>ret;\n\tdouble g=distance(a.o,b.o);\n\tif(eq(g,0))return ret;\n\tPoint u=(b.o-a.o)/g;\n\tPoint v=rotate(u,M_PI/2);\n\tfor(int s:{-1,1}){\n\t\tdouble h=(a.r+b.r*s)/g;\n\t\tif(eq(h*h,1))ret.emplace_back(a.o+(h>0?u:-u)*a.r,a.o+(h>0?u:-u)*a.r+v);\n\t\telse if(1-h*h>0){\n\t\t\tPoint U=u*h,V=v*sqrt(1-h*h);\n\t\t\tret.emplace_back(a.o+(U+V)*a.r,b.o-(U+V)*b.r*s);\n\t\t\tret.emplace_back(a.o+(U-V)*a.r,b.o-(U-V)*b.r*s);\n\t\t}\n\t}\n\treturn ret;\n}\nbool is_convex(const Polygon&P){\n\tfor(int i=0;i<P.size();i++)\n\t\tif(ccw(P[i],P[(i+1)%P.size()],P[(i+2)%P.size()])==CLOCKWISE)return false;\n\treturn true;\n}\nPolygon convex_full(Polygon P,bool ONSEG){\n\tif(P.size()<=2)return P;\n\tsort(P.begin(),P.end());\n\tPolygon ret(2*P.size());\n\tint k=0,t;\n\tif(ONSEG){\n\t\tfor(const Point&p:P){\n\t\t\twhile(k>=2&&ccw(ret[k-2],ret[k-1],p)==CLOCKWISE)k--;\n\t\t\tret[k++]=p;\n\t\t}\n\t\tt=k;\n\t\tfor(int i=P.size()-2;i>=0;i--){\n\t\t\twhile(k>=t+1&&ccw(ret[k-2],ret[k-1],P[i])==CLOCKWISE)k--;\n\t\t\tret[k++]=P[i];\n\t\t}\n\t}\n\telse{\n\t\tfor(const Point&p:P){\n\t\t\twhile(k>=2&&ccw(ret[k-2],ret[k-1],p)!=COUNTER_CLOCKWISE)k--;\n\t\t\tret[k++]=p;\n\t\t}\n\t\tt=k;\n\t\tfor(int i=P.size()-2;i>=0;i--){\n\t\t\twhile(k>=t+1&&ccw(ret[k-2],ret[k-1],P[i])!=COUNTER_CLOCKWISE)k--;\n\t\t\tret[k++]=P[i];\n\t\t}\n\t}\n\tret.resize(k-1);\n\tint mi=0;\n\tfor(int i=1;i<k-1;i++)\n\t\tif(eq(ret[mi].y,ret[i].y)?ret[mi].x>ret[i].x:ret[mi].y>ret[i].y)mi=i;\n\trotate(ret.begin(),ret.begin()+mi,ret.end());\n\treturn ret;\n}\nint contain(const Polygon&P,const Point&p){\n\tbool in=false;\n\tfor(int i=0;i<P.size();i++){\n\t\tSegment s(P[i],P[(i+1)%P.size()]);\n\t\tif(intersect(s,p))return ON;\n\t\telse{\n\t\t\tPoint a=s.p1-p,b=s.p2-p;\n\t\t\tif(a.y>b.y)swap(a,b);\n\t\t\tif(a.y<EPS&&EPS<b.y&&cross(a,b)>EPS)in=!in;\n\t\t}\n\t}\n\treturn in?IN:OUT;\n}\nint contain(const Circle&c,const Point&p){\n\tdouble d=distance(c.o,p);\n\treturn eq(d,c.r)?ON:d<c.r?IN:OUT;\n}\nint contain(const Circle&c,const Segment&s){\n\tdouble d1=distance(c.o,s.p1),d2=distance(c.o,s.p2);\n\treturn d1<c.r+EPS&&d2<c.r+EPS?eq(d1,c.r)||eq(d2,c.r)?ON:IN:OUT;\n}\nPolygon convex_cut(const Polygon&P,const Line&s){\n\tPolygon ret;\n\tfor(int i=0;i<P.size();i++){\n\t\tSegment t(P[i],P[(i+1)%P.size()]);\n\t\tif(ccw(s,t.p1)!=CLOCKWISE)ret.push_back(t.p1);\n\t\tif(!parallel(s,t)&&!intersect(s,t.p1)\n\t\t\t&&!intersect(s,t.p2)&&intersect(s,t))ret.push_back(crosspoint(s,t));\n\t}\n\treturn ret;\n}\ndouble diameter(Polygon P){\n\tif(!is_convex(P))P=convex_full(P);\n\tint mi=0,Mi=0;\n\tfor(int i=1;i<P.size();i++){\n\t\tif(P[i].x<P[mi].x)mi=i;\n\t\tif(P[i].x>P[Mi].x)Mi=i;\n\t}\n\tdouble ret=0;\n\tint sm=mi,sM=Mi;\n\twhile(mi!=sM||Mi!=sm){\n\t\tret=max(ret,norm(P[mi]-P[Mi]));\n\t\tif(cross(P[(mi+1)%P.size()]-P[mi],P[(Mi+1)%P.size()]-P[Mi])<0)mi=(mi+1)%P.size();\n\t\telse Mi=(Mi+1)%P.size();\n\t}\n\treturn sqrt(ret);\n}\ndouble area(const Polygon&P){\n\tdouble ret=0;\n\tfor(int i=0;i<P.size();i++)ret+=cross(P[i],P[(i+1)%P.size()]);\n\treturn ret/2;\n}\ndouble area(const Polygon&P,const Line&s){return area(convex_cut(P,s));}\ndouble area(const Polygon&P,const Circle&c){\n\tdouble ret=0;\n\tfor(int i=0;i<P.size();i++)\n\t{\n\t\tSegment s(P[i],P[(i+1)%P.size()]);\n\t\tif(contain(c,s))ret+=cross(s.p1-c.o,s.p2-c.o);\n\t\telse if(!intersect(c,s)){\n\t\t\tdouble a=arg(s.p2-c.o)-arg(s.p1-c.o);\n\t\t\tif(a>M_PI)a-=2*M_PI;\n\t\t\tif(a<-M_PI)a+=2*M_PI;\n\t\t\tret+=c.r*c.r*a;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpair<Point,Point>p=crosspoint(c,s);\n\t\t\tPoint tmp[4]={s.p1,p.first,p.second,s.p2};\n\t\t\tif(intersect(c,Segment(s.p1,p.first))==2)swap(tmp[1],tmp[2]);\n\t\t\tfor(int j=0;j<3;j++)\n\t\t\t{\n\t\t\t\tSegment t(tmp[j],tmp[j+1]);\n\t\t\t\tif(contain(c,t))ret+=cross(t.p1-c.o,t.p2-c.o);\n\t\t\t\telse{\n\t\t\t\t\tdouble a=arg(t.p2-c.o)-arg(t.p1-c.o);\n\t\t\t\t\tif(a>M_PI)a-=2*M_PI;\n\t\t\t\t\tif(a<-M_PI)a+=2*M_PI;\n\t\t\t\t\tret+=c.r*c.r*a;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ret/2;\n}\nmain()\n{\n\tint N,M;\n\twhile(cin>>N>>M,N)\n\t{\n\t\tPolygon P(N),C(M);\n\t\tfor(Point&p:P)cin>>p;\n\t\tfor(Point&p:C)cin>>p;\n\t\tfor(Point c:C)\n\t\t{\n\t\t\tPolygon Q=convex_full(P);\n\t\t\tfor(Point d:C)\n\t\t\t{\n\t\t\t\tif(c==d)continue;\n\t\t\t\tPoint mid=(c+d)/2;\n\t\t\t\tLine X{mid,mid+polar(114514,arg(d-c)+M_PI/2)};\n\t\t\t\tPolygon nQ=convex_cut(Q,X);\n\t\t\t\tif(contain(nQ,c))Q=nQ;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tQ=convex_cut(Q,(Line){X.p2,X.p1});\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout<<fixed<<setprecision(16)<<area(Q)<<endl;\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cassert>\n\n#include <vector>\n#include <algorithm>\n\n#define x first\n#define y second\n\nusing namespace std;\n\ntypedef pair<double, double> Point;\n\nclass Line {\n  public:\n    double a, b, c;\n\n    Line(const double _a = 0.0, const double _b = 0.0, const double _c = 0.0):\n      a(_a),\n      b(_b),\n      c(_c) {}\n\n    Line(const Point &p1, const Point &p2):\n      a(p1.y - p2.y),\n      b(p2.x - p1.x),\n      c(p1.x * p2.y - p1.y * p2.x) {}\n};\n\nvector<Line> Plane;\nvector<Point> Points;\nvector<double> Areas;\n\ninline double Det(const Point &a, const Point &b, const Point &c) {\n    return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\n}\n\nclass Compare {\n  public:\n    static Point origin;\n\n    bool operator()(const Point &a, const Point &b) const {\n        return Det(origin, a, b) >= 0;\n    }\n};\n\nPoint Compare::origin;\n\nvector<Point> ConvexHull(vector<Point> points) {\n    int n = int(points.size());\n    int origin = 0;\n    for (int i = 1; i < n; ++i)\n        if (points[i] < points[origin])\n            origin = i;\n    swap(points[0], points[origin]);\n    Compare::origin = points[0];\n    sort(points.begin() + 1, points.end(), Compare());\n    points.push_back(points[0]);\n    vector<Point> hull;\n    for (int i = 0; i < int(points.size()); ++i) {\n        while (int(hull.size()) > 1 && Det(hull[int(hull.size()) - 2], hull[int(hull.size()) - 1], points[i]) <= 0)\n            hull.pop_back();\n        hull.push_back(points[i]);\n    }\n    hull.pop_back();\n    return hull;\n}\n\ninline Point Dualize(const Line &l) {\n    if (l.c == 0)\n        return Point(0, 0);\n    else\n        return Point(l.a / l.c, l.b / l.c);\n}\n\ninline Line Dualize(const Point &p) {\n    return Line(p.x, p.y, 1);\n}\n\ninline Point Translate(const Point &p, const Point &shift) {\n    return Point(p.x + shift.x, p.y + shift.y);\n}\n\ninline Line Translate(const Line &l, const Point &shift) {\n    return Line(l.a, l.b, l.c - l.a * shift.x - l.b * shift.y);\n}\n\nvector< vector<Point> > GetVoronoiDiagrams(const vector<Line> &plane, const vector<Point> &points) {\n    int n = int(points.size());\n    vector< vector<Point> > voronoiDiagrams = vector< vector<Point> >(n, vector<Point>());\n    for (int i = 0; i < n; ++i) {\n        Point shift = Point(-points[i].x, -points[i].y);\n        vector<Point> dualizedLines;\n        for (int j = 0; j < int(plane.size()); ++j)\n            dualizedLines.push_back(Dualize(Translate(plane[j], shift)));\n        for (int j = 0; j < n; ++j) {\n            if (i != j) {\n                Point a = points[i], b = points[j];\n                dualizedLines.push_back(Dualize(Translate(Line(2 * (b.x - a.x), 2 * (b.y - a.y), a.x * a.x + a.y * a.y - b.x * b.x - b.y * b.y), shift)));\n            }\n        }\n        vector<Point> hull = ConvexHull(dualizedLines);\n        for (int j = 0; j < int(hull.size()); ++j)\n            voronoiDiagrams[i].push_back(Translate(Dualize(Line(hull[j], hull[(j + 1) % int(hull.size())])), points[i]));\n    }\n    return voronoiDiagrams;\n}\n\ninline double GetArea(const vector<Point> &polygon) {\n    int n = int(polygon.size());\n    double area = 0.0;\n    for (int i = 0; i < n; ++i)\n        area += polygon[i].x * polygon[(i + 1) % n].y - polygon[(i + 1) % n].x * polygon[i].y;\n    area /= 2.0;\n    if (area < 0.0)\n        area = -area;\n    return area;\n}\n\nvoid Solve() {\n    vector< vector<Point> > voronoi = GetVoronoiDiagrams(Plane, Points);\n    Areas = vector<double>(int(Points.size()), 0.0);\n    for (int i = 0; i < int(Points.size()); ++i)\n        Areas[i] = GetArea(voronoi[i]);\n}\n\nbool Read() {\n    int n, m;\n    assert(scanf(\"%d %d\", &n, &m) == 2);\n    if (n == 0 && m == 0)\n        return false;\n    vector<Point> planePolygon = vector<Point>(n);\n    for (int i = 0; i < n; ++i)\n        assert(scanf(\"%lf %lf\", &planePolygon[i].x, &planePolygon[i].y) == 2);\n    for (int i = 0; i < n; ++i)\n        Plane.push_back(Line(planePolygon[i], planePolygon[(i + 1) % n]));\n    Points = vector<Point>(m);\n    for (int i = 0; i < m; ++i)\n        assert(scanf(\"%lf %lf\", &Points[i].x, &Points[i].y) == 2);\n    return true;\n}\n\nvoid Print() {\n    for (int i = 0; i < int(Points.size()); ++i)\n        printf(\"%.7lf\\n\", Areas[i]);\n}\n\nint main() {\n    //assert(freopen(\"voronoi.in\", \"r\", stdin));\n    //assert(freopen(\"voronoi.out\", \"w\", stdout));\n    while (Read()) {\n        Solve();\n        Print();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<cmath>\n#include<vector>\n#include<cstdlib>\n#include<cassert>\n#include<map>\n#include<iomanip>\n#define _A_ true\n#define EPS 1e-10\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\nusing namespace std;\nclass Point{\npublic:\n  double x,y;\n  Point(double x =0,double y=0):x(x),y(y){}\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(x*a,y*a);}\n  Point operator / (double a){return Point(x/a,y/a);} //もし悪を使うなら要確認\n \n  double norm() {return x*x+y*y;}\n  double abs() {return sqrt(norm());}\n \n  bool operator < (const Point &p) const{\n    return x != p.x ? x < p.x : y < p.y; \n  }\n \n  bool operator == (const Point &p) const{\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n};\ntypedef Point Point;\nstruct Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p = Point(),Point pp = Point()):p1(p),p2(pp){}\n};\n \ntypedef vector<Point> Polygon;\ntypedef Segment Line;\n\nclass Voronoi\n{\npublic:\n  Polygon poly;\n \n  Voronoi(Polygon poly):poly(poly){}\n\n  double norm(Point p){\n    return p.x*p.x+p.y*p.y;\n  }\n \n  double abs(Point p){\n    return sqrt(norm(p));\n  }\n \n  Point polar(double a,double rad){\n    return Point(a*cos(rad),a*sin(rad));\n  }\n \n  double args(Point p){\n    return atan2(p.y,p.x);\n  }\n \n  double dot(Point a,Point b){\n    return a.x*b.x+a.y*b.y;\n  }\n \n  double cross(Point a,Point b){\n    return a.x*b.y-b.x*a.y;\n  }\n \n  Point project(Segment s,Point p){\n    Point base = s.p2 - s.p1;\n    double t = dot(p-s.p1,base)/base.norm();\n    return s.p1+base*t;\n  }\n \n  Point reflect (Segment s, Point p){\n    return p + (project(s,p)-p)*2.0;\n  }\n \n  int ccw(Point p0,Point p1,Point p2){\n    Point a = p1-p0;\n    Point b = p2-p0;\n    if(cross(a,b) > EPS) return COUNTER_CLOCKWISE;\n    if(cross(a,b) < -EPS) return CLOCKWISE;\n    if(dot(a,b) < -EPS) return ONLINE_BACK;\n    if(a.norm() < b.norm() ) return ONLINE_FRONT;\n    return ON_SEGMENT;\n  }\n \n  bool isIntersect(Point p1,Point p2,Point p3,Point p4){\n    return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <= 0 && ccw(p3,p4,p1) * ccw(p3,p4,p2) <= 0 );\n  }\n \n  bool isIntersect(Segment s1,Segment s2){\n    return isIntersect(s1.p1,s1.p2,s2.p1,s2.p2);\n  }\n\n  Point getCrossPointSegments(Segment s1,Segment s2){\n    //assert(isIntersect(s1,s2));\n    Point base = s2.p2 - s2.p1;\n    double d1 = abs(cross(base,s1.p1-s2.p1));\n    double d2 = abs(cross(base,s1.p2-s2.p1));\n    double t = d1/(d1+d2);\n    return s1.p1+(s1.p2-s1.p1)*t;\n  }\n\n\n  Point getCrossPointLines( Line s1, Line s2){\n\n    Point a = s1.p2 - s1.p1;\n    Point base = s2.p2 -s2.p1;\n    return s1.p1 + a * (cross(base, s2.p1 - s1.p1)/cross(base, a));\n  }\n\n  Polygon cutPolygon( Polygon P, Line l ){\n    Polygon u;\n    \n    for ( int i = 0; i < P.size(); i++ ){\n      Point a = P[i], b = P[(i+1)%P.size()];\n\t\n      if ( ccw(l.p1, l.p2, a) != CLOCKWISE ) u.push_back(a);\n      if ( ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) == -1 ){\n\tu.push_back(getCrossPointLines(Segment(a, b), l));\n      }\n    }   \n    return u;\n  } \n \n  Line CreateLine(Point p,Point pp){\n    Point mid = (p+pp)/2;\n    Point sl = pp-p;//原点に5\n    double rad = args(sl);\n    Point ap = polar(abs(sl),rad+M_PI/2)+mid;\n    //ap.x = abs(sl)*cos(rad+M_PI/2)+mid.x;\n    //ap.y = abs(sl)*sin(rad+M_PI/2)+mid.y;\n    return Line(mid,ap);\n  } \n \n  double AreaCalc(Polygon p){\n    double area = 0;\n    for(int i=0;i<p.size();i++)\n      area+=cross(p[i],p[(i+1)%p.size()]);\n    return fabs(area)/2.0;\n  } \n\n  //サイトposに対するボロノイセルV(pos)の面積を返す \n  //pointsは多角形の中に存在するサイトの集合]\n  //posはpoints中の自分の位置\n  double getAreaOfVoronoi(vector<Point>& points,int pos)\n  {\n    Polygon polx = poly;\n    int N = points.size();\n    for(int i=0;i<N;i++)\n      if(i != pos)\n\tpolx = cutPolygon(polx,CreateLine(points[pos],points[i]));\n    return AreaCalc(polx);\n  }  \n\n};\n\nint main(){\n\n  int N,M;\n  while(cin >> N >> M,N|M){\n  \n  vector<Point> l(N);\n  vector<Point> C(M);\n  for(int i=0;i<N;i++)\n    {\n      cin >> l[i].x >> l[i].y;\n      //l[i].x += 200,l[i].y += 200;\n    }\n  for(int i=0;i<M;i++)\n    {\n      cin >> C[i].x >> C[i].y;\n      //C[i].x += 200,C[i].y += 200;\n    }\n  for(int i=0;i<M;i++)\n    {\n\n      Polygon poly; \n      for(int j=0;j<N;j++)\n\tpoly.push_back(l[j]);\n      Voronoi vor(poly);\n\n      cout << setiosflags(ios::fixed) << setprecision(4) << vor.getAreaOfVoronoi(C,i) << endl;\n\n    }  \n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <array>\nusing namespace std;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n#define X real()\n#define Y imag()\n\ntypedef complex<double> P;\ntypedef vector<P> VP;\nstruct L : array<P, 2>{\n    L(const P& a, const P& b){ at(0)=a; at(1)=b; }\n    L(){}\n};\nnamespace std{\n    bool operator < (const P& a, const P& b){\n        return !EQ(a.X,b.X) ? a.X<b.X : a.Y<b.Y;\n    }\n    bool operator == (const P& a, const P& b){\n        return abs(a-b) < EPS;\n    }\n}\n\ndouble dot(P a, P b){\n    return (conj(a)*b).X;\n}\ndouble cross(P a, P b){\n    return (conj(a)*b).Y;\n}\nint ccw(P a, P b, P c){\n    b -= a;\n    c -= a;\n    if(cross(b,c) > EPS) return +1; //ccw\n    if(cross(b,c) < -EPS) return -1; //cw\n    if(dot(b,c) < -EPS) return +2; //c-a-b\n    if(abs(c)-abs(b) > EPS) return -2; //a-b-c\n    return 0; //a-c-b\n}\n\nbool intersectSS(const L& a, const L& b){\n    return ( ccw(a[0],a[1],b[0]) *ccw(a[0],a[1],b[1]) <= 0 ) &&\n        ( ccw(b[0],b[1],a[0]) *ccw(b[0],b[1],a[1]) <= 0 );\n}\nbool intersectSP(const L& s, const P &p){\n    return abs(cross(s[0]-p, s[1]-p))<EPS  && dot(s[0]-p, s[1]-p)<EPS;\n}\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1]-l[0], m[1]-m[0]);\n  double B = cross(l[1]-l[0], l[1]-m[0]);\n  return m[0] + B/A *(m[1]-m[0]);\n}\n\nbool isParallel(const P &a, const P &b){\n    return abs(cross(a,b)) < EPS;\n}\nbool isParallel(const L &a, const L &b){\n    return isParallel(a[1]-a[0], b[1]-b[0]);\n}\n\ndouble getarea(const VP &poly){\n    double ret = 0;\n    for (int i=0; i<(int)poly.size(); i++){ \n        ret += cross(poly[i], poly[(i+1)%poly.size()]);\n    }\n    return ret*0.5;\n}\n\nint in_poly(const P &p, const VP &poly){\n    int n = poly.size();\n    int ret = -1;\n    for(int i=0; i<n; i++){\n        P a = poly[i]-p;\n        P b = poly[(i+1)%n]-p;\n        if(a.Y > b.Y) swap(a,b);\n        if(intersectSP(L(a,b), P(0,0))) return 0;\n        if(a.Y<=0 && b.Y>0 && cross(a,b)<0) ret = 1-ret;\n    }\n    return ret;\n}\n\nVP convex(VP v){\n    VP ret;\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(), v.end()), v.end());\n    int n = v.size();\n    for(int i=0; i<n; i++){\n        while((int)ret.size()>1 && cross(ret.back()-ret[ret.size()-2], v[i]-ret.back()) < EPS){\n            ret.pop_back();\n        }\n        ret.push_back(v[i]);\n    }\n    int t = ret.size();\n    for(int i=n-2; i>=0; i--){\n        while((int)ret.size()>t && cross(ret.back()-ret[ret.size()-2], v[i]-ret.back()) < EPS){\n            ret.pop_back();\n        }\n        ret.push_back(v[i]);\n    }\n    if((int)ret.size() > 1) ret.pop_back();\n    return ret;\n}\n\nVP convex_intersect(VP a, VP b){\n\tVP plist;\n\tint n=a.size(), m=b.size();\n\tfor(int r=0; r<2; r++){\n\t\tfor(int i=0; i<n; i++){\n\t\t\tif(in_poly(a[i], b) >= 0){\n\t\t\t\tplist.push_back(a[i]);\n\t\t\t}\n\t\t}\n\t\tswap(n, m);\n\t\tswap(a, b);\n\t}\n\tfor(int i=0; i<n; i++){\n\t\tfor(int j=0; j<m; j++){\n\t\t\tL la(a[i], a[(i+1)%n]), lb(b[j], b[(j+1)%m]);\n\t\t\tif(!isParallel(la, lb) && intersectSS(la, lb)){\n\t\t\t\tplist.push_back(crosspointLL(la, lb));\n\t\t\t}\n\t\t}\n\t}\n\treturn convex(plist);\n}\n\nVP convex_cut(const VP& p, const L& l){\n\tVP ret;\n\tint n = p.size();\n\tfor(int i=0; i<n; i++){\n\t\tP curr = p[i];\n\t\tP next = p[(i+1)%n];\n\t\tif(ccw(l[0], l[1], curr) != -1) ret.push_back(curr);\n\t\tif(ccw(l[0], l[1], curr) *ccw(l[0], l[1], next) == -1){\n\t\t\tret.push_back(crosspointLL(L(curr, next), l));\n\t\t}\n\t}\n\treturn ret;\n}\n\nvector<VP> volonoi_division(VP plist, VP poly){\n\tint n = poly.size(), m = plist.size();\n\tvector<VP> ret(m);\n\tfor(int i=0; i<m; i++){\n\t\tVP v = poly;\n\t\tfor(int j=0; j<m; j++){\n\t\t\tif(i==j) continue;\n\t\t\tP mid = (plist[i]+plist[j])/2.0;\n\t\t\tL bisector(mid, mid +(plist[j]-plist[i])*P(0,1));\n\t\t\tVP cut = convex_cut(v, bisector);\n\t\t\tv = convex_intersect(v, cut);\n\t\t}\n\t\tret[i] = v;\n\t}\n\treturn ret;\n}\n\nint main(){\n\tcout << fixed;\n\tcout << setprecision(10);\n\twhile(1){\n\t\tint n,m;\n\t\tcin >> n >> m;\n\t\tif(n==0) break;\n\t\t\n\t\tint x,y;\n\t\tVP v(n), c(m);\n\t\tfor(int i=0; i<n; i++){\n\t\t\tcin >> x >> y;\n\t\t\tv[i] = P(x, y);\n\t\t}\n\t\tfor(int i=0; i<m; i++){\n\t\t\tcin >> x >> y;\n\t\t\tc[i] = P(x, y);\n\t\t}\n\t\tif(ccw(v[0], v[1], v[2]) != 1){\n\t\t\treverse(v.begin(), v.end());\n\t\t}\n\t\t\n\t\tvector<VP> volonoi = volonoi_division(c, v);\n\t\tfor(int i=0; i<m; i++){\n\t\t\tcout << getarea(volonoi[i]) << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ld=double;\nusing P=complex<ld>;\nusing Point=P;\nconst ld EPS=1e-9;\nstruct Line{\n    P a,b;\n};\nld cross(P x,P y){\n    return real(x)*imag(y)-real(y)*imag(x);\n}\nLine halfLine(P x,P y){\n    return Line{(x+y)/P(2,0),(x-y)*P(0,1)+(x+y)/P(2,0)};\n}\n\nbool isis_sp(Line x,P p){\n    return abs(x.a-p)+abs(x.b-p)-abs(x.a-x.b)<EPS;\n}\nPoint is_ll(Line s,Line t){\n    P sv = s.b - s.a, tv = t.b - t.a;\n    return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\nbool isis_ll(Line x,Line y){\n    return abs(cross(x.a-x.b,y.a-y.b))>EPS;\n}\n// P is_ll(Line x,Line y){\n//     return x.a+(x.b-x.a)*cross(x.a-y.a,y.b-y.a)/cross(x.b-x.a,y.b-y.a);\n// }\nbool is_in_Polygon(P p,const vector<P> &poly){\n    ld angle=0;\n    int n=poly.size();\n    for(int i=0;i<n;i++){\n        P a=poly[i],b=poly[(i+1)%n];\n        if(isis_sp(Line{a,b},p)) return true;\n        angle+=arg((b-p)/(a-p));\n    }\n    if(abs(angle)<EPS) return false;\n    return true;\n}\n\nld area_of_Polygon(vector<P> p){\n    ld res=0;\n    for(int i=0;i<p.size();i++){\n        ld xlen=real(p[(i+1)%p.size()]-real(p[i]));\n        ld ylen=imag(p[(i+1)%p.size()])+imag(p[i]);\n        res+=xlen*ylen/2;\n    }\n    return abs(res);\n}\nint solve(){\n    int n,m;\n    cin>>n>>m;\n    if(n==0 && m==0) return false;\n    vector<P> land(n);\n    for(int i=0;i<n;i++){\n        ld x,y;\n        cin>>x>>y;\n        land[i]={x,y};\n    }\n    vector<P> castle(m);\n    for(int i=0;i<m;i++){\n        ld x,y;\n        cin>>x>>y;\n        castle[i]={x,y};\n    }\n\n    auto isValid=[&](int idx,P p){\n        if(!is_in_Polygon(p,land)) return false;\n        vector<ld> dist(m);\n        for(int i=0;i<m;i++) dist[i]=abs(castle[i]-p);\n        ld mind=*min_element(dist.begin(),dist.end());\n        return abs(mind-dist[idx])<EPS;\n    };\n    auto solve=[&](int idx){\n        vector<Line> line;\n        for(int i=0;i<m;i++){\n            if(i!=idx){\n                line.push_back(halfLine(castle[i],castle[idx]));\n            }\n        }\n        for(int i=0;i<n;i++){\n            line.push_back(Line{land[i],land[(i+1)%n]});\n        }\n        vector<P> poly;\n        int s=line.size();\n        for(int i=0;i<s;i++){\n            for(int j=i+1;j<s;j++){\n                if(isis_ll(line[i],line[j])){\n                    P p=is_ll(line[i],line[j]);\n                    if(isValid(idx,p)){\n                        poly.push_back(p); \n                    }\n                }\n            }\n        }\n        sort(poly.begin(),poly.end(),[&](P x,P y){return arg(x-castle[idx])<arg(y-castle[idx]);});\n        return area_of_Polygon(poly);\n    };\n    cout<<fixed<<setprecision(10);\n    for(int i=0;i<m;i++){\n        cout<<solve(i)<<endl;\n    }\n    return true;\n}\nint main(){\n    while(solve());\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define M 10\nusing namespace std;\ntypedef complex<double> P;\ntypedef pair<P,P> L;\nconst double EPS = 1e-8;\n\ndouble dot(P a, P b){ return real(conj(a)*b); }\n\ndouble cross(P a, P b){ return imag(conj(a)*b); }\n\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > EPS) return 1;   // ????????????(b-a)????????´???????????????(c-a)????????¨?????????\n  if(cross(b,c) < -EPS) return -1; // ????????????(b-a)????????´???????????????(c-a)????????¨?????????\n  if(dot(b,c) < -EPS) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nP crossPoint(L l, L m){\n  double A = cross(l.second - l.first, m.second - m.first);\n  double B = cross(l.second - l.first, l.second - m.first);\n  if(fabs(A) < EPS && fabs(B) < EPS) return m.first;\n  else if(fabs(A) >= EPS) return m.first + B / A * (m.second - m.first);\n}\n\nvector<P> convex_cut(vector<P> G, L l){\n  vector<P> ans;\n  for(int i=0;i<G.size();i++){\n    P A = G[i];\n    P B = G[(i+1)%G.size()];\n    if(ccw(l.first, l.second, A) != -1) ans.push_back(A);\n    if(ccw(l.first, l.second, A) * ccw(l.first, l.second, B) < 0)\n      ans.push_back(crossPoint(L(A,B), l));\n  }\n  return ans;\n}\n\ndouble area(vector<P> v){\n  double sum = 0.0;\n  int n = v.size();\n  for(int i=0;i<n;i++) sum += (real(v[i]) - real(v[(i+1)%n])) * (imag(v[i]) + imag(v[(i+1)%n]));\n  return fabs(sum) / 2;\n};\n\nint n,m,x,y,cx,cy;\nvector<P> vi;\nP c[M];\n\nint main(){\n  while(1){\n    cin>>n>>m;\n    if(!n&&!m)break;\n    for(int i=0;i<n;i++){\n      cin>>x>>y;\n      vi.push_back(P(x,y));\n    }\n    for(int i=0;i<m;i++){\n      cin>>cx>>cy;\n      c[i]=P(cx,cy);\n    }\n    for(int i=0;i<m;i++){\n      vector<P> cp=vi;\n      for(int j=0;j<m;j++){\n\tif(i==j)continue;\n\tdouble X=(c[j].real()-c[i].real())/2.0;\n\tdouble Y=(c[j].imag()-c[i].imag())/2.0;\n\tP A=P(c[i].real()+c[j].imag()-c[i].imag()+X,\n\t      c[i].imag()-(c[j].real()-c[i].real())+Y);\n\tP B=P(c[i].real()+X,c[i].imag()+Y);\n\tcp=convex_cut(cp,L(A,B));\n      }\n      printf(\"%.1f\\n\",area(cp));\n    }\n    vi.clear();;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n/* 基本要素 */\ntypedef complex<double> Point;\ntypedef pair<Point, Point> Line;\ntypedef vector<Point> VP;\nconst double EPS = 1e-9; // 許容誤差^2\nconst double INF = 1e9;\n#define X real()\n#define Y imag()\n// #define LE(n,m) ((n) < (m) + EPS)\n#define LE(n,m) ((n) - (m) < EPS)\n// #define GE(n,m) ((n) + EPS > (m))\n#define GE(n,m) (EPS > (m) - (n))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\n// 内積　dot(a,b) = |a||b|cosθ\ndouble dot(Point a, Point b) {\n  return a.X*b.X + a.Y*b.Y;\n}\n\n// 外積　cross(a,b) = |a||b|sinθ\ndouble cross(Point a, Point b) {\n  return a.X*b.Y - a.Y*b.X;\n}\n\n// 点の進行方向\nint ccw(Point a, Point b, Point c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1;  // counter clockwise\n  if (cross(b,c) < -EPS) return -1;  // clockwise\n  if (dot(b,c)   < -EPS) return +2;  // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n  return 0;                          // a--c--b on line or a==c or b==c\n}\n\n// 2直線の交点\nPoint crosspointLL(Point a1, Point a2, Point b1, Point b2) {\n  double d1 = cross(b2-b1, b1-a1);\n  double d2 = cross(b2-b1, a2-a1);\n  if (EQ(d1, 0) && EQ(d2, 0)) return a1;  // same line\n  assert(!EQ(d2, 0)); // 交点がない\n  return a1 + d1/d2 * (a2-a1);\n}\n\n// 凸多角形クリッピング\nVP convexCut(const VP& ps, Point a1, Point a2) {\n  int n = ps.size();\n  VP ret;\n  rep(i,n) {\n    int ccwc = ccw(a1, a2, ps[i]);\n    if (ccwc != -1) ret.push_back(ps[i]);\n    int ccwn = ccw(a1, a2, ps[(i + 1) % n]);\n    if (ccwc * ccwn == -1) ret.push_back(crosspointLL(a1, a2, ps[i], ps[(i + 1) % n]));\n  }\n  return ret;\n}\n\n// ボロノイ領域\nVP voronoiCell(Point p, const VP& ps, const VP& outer) {\n  VP cl = outer;\n  rep (i, ps.size()) {\n    if (EQ(norm(ps[i]-p), 0)) continue;\n    Point h = (p+ps[i])*0.5;\n    cl = convexCut(cl, h, h + (ps[i]-h)*Point(0,1) );\n  }\n  return cl;\n}\n\n// 多角形の符号付面積\ndouble area(const VP& ps) {\n  double a = 0;\n  rep (i, ps.size()) a += cross(ps[i], ps[(i+1) % ps.size()]);\n  return a / 2;\n}\n\nint main(){\n    int n,m;\n    while(cin >>n >>m,n){\n        VP island(n);\n        rep(i,n){\n            int x,y;\n            cin >>x >>y;\n            island[i] = Point(x,y);\n        }\n\n        VP castle(m);\n        rep(i,m){\n            int x,y;\n            cin >>x >>y;\n            castle[i] = Point(x,y);\n        }\n\n        rep(i,m){\n            double S = abs(area(voronoiCell(castle[i], castle, island)));\n            printf(\"%.10f\\n\", S);\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "// AOJ 2160: Voronoi Island\n// 2018.1.8 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n\n#define EPS 1e-8\n\ntypedef struct { double x, y; } PP;\ntypedef struct { PP s, e; } LINE;\n\nPP pi[11], pc[11];\n\nint dcmp(double x)\n{\n\tif (fabs(x) < EPS) return 0;\n\treturn x < 0 ? -1 : 1;\n}\n\ndouble cross(double ax, double ay, double bx, double by) { return ax*by - ay*bx; }\n\nvoid lineIntersection(PP *p, LINE *a, PP *vs, PP *ve)\n{\n    double a1, a2;\n\n\ta1 = cross(ve->x  - vs->x, ve->y  - vs->y,\n\t\t\t   a->s.x - vs->x, a->s.y - vs->y);\n\ta2 = cross(ve->x  - vs->x, ve->y  - vs->y,\n\t\t\t   a->e.x - vs->x, a->e.y - vs->y);\n\tp->x = (a->s.x*a2 - a->e.x*a1) / (a2-a1);\n\tp->y = (a->s.y*a2 - a->e.y*a1) / (a2-a1);\n}\n\nint convex_cut(LINE *u, int n, PP *p, PP *po)\n{\n\tint i, d1, d2, top = 0;\n\n    for (i = 0; i < n; i++) {\n        d1 = dcmp(cross(u->e.x - u->s.x, u->e.y - u->s.y,\n\t\t\t\t\t\tp[i].x - u->s.x, p[i].y - u->s.y));\n        d2 = dcmp(cross(u->e.x - u->s.x, u->e.y - u->s.y,\n\t\t\t\t      p[i+1].x - u->s.x, p[i+1].y - u->s.y));\n        if (d1 >= 0) po[top++] = p[i];\n        if (d1*d2 < 0) lineIntersection(po + top++, u, p+i, p+i+1);\n    }\n\tpo[top].x = po[0].x, po[top].y = po[0].y;\n    return top;\n}\n\n// 垂直二等分線\nvoid bisector(LINE *u, PP a, PP b)\n{\n\tdouble ax = (a.x + b.x)/2;\n\tdouble ay = (a.y + b.y)/2;\n\tu->s.x = ax, u->s.y = ay;\n\tif (fabs(a.y - b.y) <= EPS) u->e.x = ax, u->e.y = ay + (b.x-a.x)*100;\n\telse u->e.x = ax-(b.y-a.y)*100, u->e.y = (ax - u->e.x)*(b.x - a.x)/(b.y - a.y) + ay;\n}\n\ndouble polygonArea(int n, PP *p)\n{\n    double area = 0;\n    for (int i = 1; i < n-1; i++) {\n        area += cross(p[i].x-p[0].x, p[i].y-p[0].y, p[i+1].x-p[0].x, p[i+1].y-p[0].y);\n    }\n    return fabs(area) / 2;\n}\n\nint main()\n{\n\tint n, m, i, j, k, x, y, k1, k2;\n\tPP pol[2][100];\n\tLINE u;\n\n\twhile(scanf(\"%d%d\", &n, &m) && n > 0) {\n\t\tfor (i = 0; i < n; i++) scanf(\"%d%d\", &x, &y), pi[i].x = x, pi[i].y = y;\n\t\tpi[n] = pi[0];\n\n\t\tfor (i = 0; i < m; i++) scanf(\"%d%d\", &x, &y), pc[i].x = x, pc[i].y = y;\n\t\tpc[m] = pc[0];\n\n\t\tfor (i = 0; i < m; i++) {\n\t\t\tmemcpy(pol[0], pi, sizeof(PP) * (n+1));\n\t\t\tk = n, k1 = 0, k2 = 1;\n\t\t\tfor (j = 0; j < m; j++) {\n\t\t\t\tif (j == i) continue;\n\t\t\t\tbisector(&u, pc[i], pc[j]);\n\t\t\t\tk = convex_cut(&u, k, pol[k1], pol[k2]);\n\t\t\t\tk1 = k2, k2 = !k2;\n\t\t\t}\n\t\t\tprintf(\"%.5lf\\n\", polygonArea(k, pol[k1]));\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\n\npublic class Main{\n\n\tfinal double EPS = 1.0e-8;\n\tfinal Point origin = new Point(0, 0);\n\tfinal double rad = 180/Math.PI;\n\n\t/*\n\t *î{\n\t *\n\t */\n\n\t//xNgÌÈ·pxp0¨p1, p1¨p2ÌÈ·pBòpÀè @ac\n\tdouble angle(Point p0, Point p1, Point p2) {\n\t\tPoint v = sub(p1, p0);\n\t\tPoint u = sub(p2, p1);\n\t\treturn Math.acos((-v.x*u.x -v.y*u.y)/ (norm(v)*norm(u)));\n\t}\n\n\t//xNgpðlÉËe @ac\n\tPoint proj(Line l, Point p) {\n\t\tdouble t = inp(sub(p, l.s), sub(l.s, l.t)) / Math.pow(norm(sub(l.s, l.t)),2);\n\t\tPoint tp = sub(l.s, l.t);\n\t\treturn new Point(l.s.x + t*tp.x, l.s.y + t*tp.y);\n\t}\n\n\tPoint refl(Line l, Point p) {\n\t\tPoint tp = sub(proj(l, p), p);\n\t\treturn new Point(p.x + 2*tp.x, p.y + 2*tp.y);\n\t}\n\t//xNgÌ·³  @ac\n\tdouble norm(Point p) {\n\t\treturn Math.sqrt(Math.pow(p.x, 2)+Math.pow(p.y, 2));\n\t}\n\t//àÏ\n\tdouble inp(Point p1, Point p2) {\n\t\treturn p1.x*p2.x + p1.y*p2.y;\n\t}\n\t//OÏ\n\tdouble extp(Point p1, Point p2) {\n\t\treturn p1.x*p2.y - p2.x*p1.y;\n\t}\n\n\t//_p1©çp2ðø­\n\tPoint sub(Point p1, Point p2) {\n\t\treturn new Point(p1.x-p2.x, p1.y-p2.y);\n\t}\n\n\t//_Ìisûü\n\tint ccw(Point a, Point b, Point c) {\n\t\tPoint p = sub(b, a), q = sub(c, a);\n\t\tif (extp(p, q) > 0)    return +1;      // counter clockwise\n\t\tif (extp(p, q) < 0)    return -1;      // clockwise\n\t\tif (inp(p, q) < 0)     return +2;      // c--a--b on line\n\t\tif (norm(p) < norm(q)) return -2;      // a--b--c on line\n\t\treturn 0;                              // a--c--b(or a--c=b) on line\n\t}\n\n\tpublic class Point {\n\t\tdouble x,y;\n\t\tpublic Point(double x_, double y_) {\n\t\t\tx = x_; y=y_;\n\t\t}\n\t\tpublic String toString() {return \"(\" +x+\", \"+ y +\")\";}\n\t}\n\n\t//¼üorüªÌNX\n\tpublic class Line {\n\t\tPoint s,t;\n\t\tpublic Line(Point s_, Point t_) {\n\t\t\ts = s_; t = t_;\n\t\t}\n\t\tpublic String toString() {return s.toString() + \" -> \" + t.toString();}\n\t}\n\n\tPoint[] convex_cut(Point[] p, Line l) {\n\t\tList<Point> q = new ArrayList<Point>();\n\t\tfor (int i = 0; i < p.length; ++i) {\n\t\t\tPoint a= p[i], b = p[(i+1)%p.length];\n\t\t\tif (ccw(l.s, l.t, a) != -1) q.add(a);\n\t\t    if (ccw(l.s, l.t, a)*ccw(l.s, l.t, b) < 0)\n\t\t      q.add(crosspoint(new Line(a, b), l));\n\t\t}\n\t\treturn q.toArray(new Point[q.size()]);\n\t}\n\n\tPoint crosspoint(Line l, Line m) {\n\t\t  double A = extp(sub(l.t, l.s), sub(m.t, m.s));\n\t\t  double B = extp(sub(l.t, l.s), sub(l.t, m.s));\n\t\t  if (Math.abs(A) < EPS && Math.abs(B) < EPS) return m.s; // same line\n\t\t  if (Math.abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n\t\t  Point tp = sub(m.t, m.s);\n\t\t  return new Point(m.s.x + B/A*tp.x, m.s.y + B/A*tp.y);\n\t}\n\n\tdouble area(Point[] p) {\n\t\tdouble s = 0;\n\t\tfor(int i=0; i<p.length; i++) {\n\t\t\tint j = (i+1)%p.length;\n\t\t\ts += extp(p[i], p[j]);\n\t\t}\n\t\ts /= 2; //ë·ðð¯½¢Æ«ÉÍçÈ¢\n\t\treturn Math.abs(s);\n\t}\n\n//\tvoid dump(Point[] a){\n//\t\tSystem.out.println(\"DUMP\");\n//\t\tfor(int i=0;i<a.length;i++)System.out.println(a[i]);\n//\t}\n\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif((n|m)==0)break;\n\t\t\tPoint[] p = new Point[n];\n\t\t\tfor(int i=0;i<n;i++)p[i]=new Point(sc.nextDouble(), sc.nextDouble());\n\t\t\tPoint[] lord = new Point[m];\n\t\t\tfor(int i=0;i<m;i++)lord[i]=new Point(sc.nextDouble(), sc.nextDouble());\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tPoint[] area = new Point[n];\n\t\t\t\tfor(int j=0;j<n;j++)area[j] = p[j];\n\t\t\t\tfor(int j=0;j<m;j++){\n\t\t\t\t\tif(i==j)continue;\n//\t\t\t\t\tdump(area);\n\t\t\t\t\tPoint mid = new Point((lord[i].x+lord[j].x)/2, (lord[i].y+lord[j].y)/2);\n\t\t\t\t\tdouble dx = lord[j].x-lord[i].x;\n\t\t\t\t\tdouble dy = lord[j].y-lord[i].y;\n\t\t\t\t\tdouble rx = -dy;\n\t\t\t\t\tdouble ry = dx;\n\t\t\t\t\tPoint v = new Point(mid.x+rx, mid.y+ry);\n//\t\t\t\t\tSystem.out.println(\"MID:\" + mid + \" V:\" + v);\n\t\t\t\t\tarea = convex_cut(area, new Line(mid, v));\n\t\t\t\t}\n\t\t\t\tSystem.out.println(area(area));\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Ruby",
    "code": "require 'matrix'\nrequire 'mathn'\n\nclass Land\n\tdef initialize(*args)\n\t\t@cx, @cy, @points = args\n\tend\n\n\tdef area\n\t\ts = 0\n\t\t(@points + [@points[0]]).each_cons(2) do |(x1, y1), (x2, y2)|\n\t\t\ts += x1 * y2 - y1 * x2\n\t\tend\n\t\t(s / 2.0).abs\n\tend\n\n\tdef cut(a, b, c) #by line a*x+b*y+c=0\n\t\ts = a * @cx + b * @cy + c\t\n\t\t@points.size.times do |i|\n\t\t\t(x1, y1), (x2, y2) = @points[i], @points[(i+1) % @points.size]\n\t\t\tif (a * x1 + b * y1 + c) * (a * x2 + b * y2 + c) < 0\n\t\t\t\td, e = y2 - y1, x2 - x1\n\t\t\t\tm = Matrix[\n\t\t\t\t\t[a, b],\n\t\t\t\t\t[d, -e]\n\t\t\t\t\t]\n\t\t\t\tv = Vector[-c, d * x1 - e * y1]\n\t\t\t\t#p (m.inv * v).to_a\n\t\t\t\t@points[i] += (m.inv * v).to_a\n\t\t\tend\n\t\tend\n\n\t\t@points = @points.flatten.each_slice(2).to_a\n\t\t@points = @points.select{|x, y| s * (a * x + b * y + c) >= 0}\n\t\t\n\tend\n\n\tattr_reader :cx, :cy\nend\n\nloop do\n\tn, m = gets.split.map(&:to_i)\n\tbreak if n == 0\n\tpoints = (1..n).map { gets.split.map(&:to_i) }\n\tlands = (1..m).map do\n\t\tcx, cy = gets.split.map(&:to_i)\n\t\tl = Land.new(cx, cy, points.dup)\n\tend\n\tlands.combination(2) do |l1, l2|\n\t\tx1, y1, x2, y2 = l1.cx, l1.cy, l2.cx, l2.cy\n\t\tu, v = (x1 + x2) / 2, (y1 + y2) / 2\n\n\t\ta = x1 - x2\n\t\tb = y1 - y2\n\t\tc = -(a * u + b * v)\n\t\t\n\t\tl1.cut(a, b, c)\n\t\tl2.cut(a, b, c)\n\tend\t\n\tlands.each {|l| p l.area.to_f}\nend"
  },
  {
    "language": "Ruby",
    "code": "require 'matrix'\n\nclass Land\n\tdef initialize(*args)\n\t\t@cx, @cy, @points = args\n\tend\n\n\tdef area\n\t\ts = 0\n\t\t(@points + [@points[0]]).each_cons(2) do |(x1, y1), (x2, y2)|\n\t\t\ts += x1 * y2 - y1 * x2\n\t\tend\n\t\t(s / 2.0).abs\n\tend\n\n\tdef cut(a, b, c) #by line a*x+b*y+c=0\n\t\ts = a * @cx + b * @cy + c\t\n\t\t@points.size.times do |i|\n\t\t\t(x1, y1), (x2, y2) = @points[i], @points[(i+1) % @points.size]\n\t\t\tif (a * x1 + b * y1 + c) * (a * x2 + b * y2 + c) < 0\n\t\t\t\td, e = y2 - y1, x2 - x1\n\t\t\t\tm = Matrix[\n\t\t\t\t\t[a, b],\n\t\t\t\t\t[d, -e]\n\t\t\t\t\t]\n\t\t\t\tv = Vector[-c, d * x1 - e * y1]\n\t\t\t\t#p (m.inv * v).to_a\n\t\t\t\t@points[i] += (m.inv * v).to_a\n\t\t\tend\n\t\tend\n\n\t\t@points = @points.flatten.each_slice(2).to_a\n\t\t@points = @points.select{|x, y| s * (a * x + b * y + c) >= 0}\n\t\t\n\tend\n\n\tattr_reader :cx, :cy\nend\n\nloop do\n\tn, m = gets.split.map(&:to_i)\n\tbreak if n == 0\n\tpoints = (1..n).map { gets.split.map(&:to_i) }\n\tlands = (1..m).map do\n\t\tcx, cy = gets.split.map(&:to_i)\n\t\tl = Land.new(cx, cy, points.dup)\n\tend\n\tlands.combination(2) do |l1, l2|\n\t\tx1, y1, x2, y2 = l1.cx, l1.cy, l2.cx, l2.cy\n\t\tu, v = (x1 + x2) / 2, (y1 + y2) / 2\n\n\t\ta = x1 - x2\n\t\tb = y1 - y2\n\t\tc = -(a * u + b * v)\n\t\t\n\t\tl1.cut(a, b, c)\n\t\tl2.cut(a, b, c)\n\tend\t\n\tlands.each {|l| p l.area.to_f}\nend"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\ndef cross3(O, A, B):\n    ox, oy = O; ax, ay = A; bx, by = B\n    return (ax - ox) * (by - oy) - (bx - ox) * (ay - oy)\ndef cross_point(p0, p1, q0, q1):\n    x0, y0 = p0; x1, y1 = p1\n    x2, y2 = q0; x3, y3 = q1\n    dx0 = x1 - x0; dy0 = y1 - y0\n    dx1 = x3 - x2; dy1 = y3 - y2\n    s = (y0-y2)*dx1 - (x0-x2)*dy1\n    sm = dx0*dy1 - dy0*dx1\n    if -EPS < sm < EPS:\n        return None\n    return x0 + s*dx0/sm, y0 + s*dy0/sm\nEPS = 1e-9\ndef convex_cut(P, line):\n    q0, q1 = line\n    N = len(P)\n    Q = []\n    for i in range(N):\n        p0 = P[i-1]; p1 = P[i]\n        cv0 = cross3(q0, q1, p0)\n        cv1 = cross3(q0, q1, p1)\n        if cv0 * cv1 < EPS:\n            v = cross_point(q0, q1, p0, p1)\n            if v is not None:\n                Q.append(v)\n        if cv1 > -EPS:\n            Q.append(p1)\n    return Q\ndef polygon_area(P):\n    s = 0\n    N = len(P)\n    for i in range(N):\n        p0 = P[i-1]; p1 = P[i]\n        s += p0[0]*p1[1] - p0[1]*p1[0]\n    return abs(s) / 2\n\ndef solve():\n    N, M = map(int, input().split())\n    if N == M == 0:\n        return False\n    P = [list(map(int, readline().split())) for i in range(N)]\n    Q = [list(map(int, readline().split())) for i in range(M)]\n    for i in range(M):\n        x0, y0 = Q[i]\n        P0 = P\n        for j in range(M):\n            if i == j:\n                continue\n            x1, y1 = Q[j]\n            ax = (x0 + x1) / 2; ay = (y0 + y1) / 2\n            q0 = (ax, ay)\n            q1 = (ax - (y1 - y0), ay + (x1 - x0))\n            P0 = convex_cut(P0, (q0, q1))\n        write(\"%.16f\\n\" % polygon_area(P0))\n    return True\nwhile solve():\n    ...\n\n"
  }
]