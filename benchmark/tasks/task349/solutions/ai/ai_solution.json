[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\ntypedef struct {\n    double x, y;\n} Point;\n\ntypedef struct {\n    Point a, b;\n} Segment;\n\ntypedef struct {\n    Point p;\n    int index;\n} Castle;\n\nPoint vertices[1000];\nCastle castles[100];\nint n, m;\n\ndouble cross(Point a, Point b, Point c) {\n    return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\n}\n\nPoint intersection(Segment s1, Segment s2) {\n    double a1 = s1.b.y - s1.a.y;\n    double b1 = s1.a.x - s1.b.x;\n    double c1 = a1 * s1.a.x + b1 * s1.a.y;\n\n    double a2 = s2.b.y - s2.a.y;\n    double b2 = s2.a.x - s2.b.x;\n    double c2 = a2 * s2.a.x + b2 * s2.a.y;\n\n    double det = a1 * b2 - a2 * b1;\n    Point p;\n    p.x = (b2 * c1 - b1 * c2) / det;\n    p.y = (a1 * c2 - a2 * c1) / det;\n    return p;\n}\n\ndouble area(Point *poly, int cnt) {\n    double res = 0.0;\n    for (int i = 0; i < cnt; i++) {\n        int j = (i + 1) % cnt;\n        res += poly[i].x * poly[j].y - poly[j].x * poly[i].y;\n    }\n    return fabs(res) / 2.0;\n}\n\nint compare(const void *a, const void *b) {\n    Castle *ca = (Castle *)a;\n    Castle *cb = (Castle *)b;\n    if (ca->p.x != cb->p.x) return (ca->p.x > cb->p.x) ? 1 : -1;\n    return (ca->p.y > cb->p.y) ? 1 : -1;\n}\n\nvoid voronoi() {\n    qsort(castles, m, sizeof(Castle), compare);\n    double areas[100] = {0};\n\n    for (int i = 0; i < m; i++) {\n        Point poly[1000];\n        int cnt = 0;\n        for (int j = 0; j < n; j++) {\n            int k = (j + 1) % n;\n            Segment edge = {vertices[j], vertices[k]};\n            Point mid;\n            mid.x = (edge.a.x + edge.b.x) / 2;\n            mid.y = (edge.a.y + edge.b.y) / 2;\n\n            Point dir;\n            dir.x = edge.a.y - edge.b.y;\n            dir.y = edge.b.x - edge.a.x;\n\n            Point p1, p2;\n            p1.x = mid.x + dir.x;\n            p1.y = mid.y + dir.y;\n            p2.x = mid.x - dir.x;\n            p2.y = mid.y - dir.y;\n\n            Segment bisector = {p1, p2};\n\n            Point inter = intersection(edge, bisector);\n            poly[cnt++] = inter;\n        }\n\n        for (int j = 0; j < m; j++) {\n            if (i == j) continue;\n            Point mid;\n            mid.x = (castles[i].p.x + castles[j].p.x) / 2;\n            mid.y = (castles[i].p.y + castles[j].p.y) / 2;\n\n            Point dir;\n            dir.x = castles[j].p.y - castles[i].p.y;\n            dir.y = castles[i].p.x - castles[j].p.x;\n\n            Point p1, p2;\n            p1.x = mid.x + dir.x;\n            p1.y = mid.y + dir.y;\n            p2.x = mid.x - dir.x;\n            p2.y = mid.y - dir.y;\n\n            Segment bisector = {p1, p2};\n            Point new_poly[1000];\n            int new_cnt = 0;\n\n            for (int k = 0; k < cnt; k++) {\n                int l = (k + 1) % cnt;\n                Segment seg = {poly[k], poly[l]};\n                double d1 = cross(castles[i].p, castles[j].p, poly[k]);\n                double d2 = cross(castles[i].p, castles[j].p, poly[l]);\n\n                if (d1 <= 0) new_poly[new_cnt++] = poly[k];\n                if (d1 * d2 < 0) {\n                    Point inter = intersection(seg, bisector);\n                    new_poly[new_cnt++] = inter;\n                }\n            }\n\n            cnt = new_cnt;\n            for (int k = 0; k < cnt; k++) poly[k] = new_poly[k];\n        }\n\n        areas[castles[i].index] = area(poly, cnt);\n    }\n\n    for (int i = 0; i < m; i++) {\n        printf(\"%.8f\\n\", areas[i]);\n    }\n}\n\nint main() {\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%lf %lf\", &vertices[i].x, &vertices[i].y);\n    }\n    for (int i = 0; i < m; i++) {\n        scanf(\"%lf %lf\", &castles[i].p.x, &castles[i].p.y);\n        castles[i].index = i;\n    }\n    voronoi();\n    return 0;\n}",
    "timestamp": "2025-08-05 21:11:44"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <iomanip>\n\nusing namespace std;\n\nstruct Point {\n    double x, y;\n    Point(double x = 0, double y = 0) : x(x), y(y) {}\n};\n\ntypedef vector<Point> Polygon;\n\ndouble cross(const Point &O, const Point &A, const Point &B) {\n    return (A.x - O.x) * (B.y - O.y) - (A.y - O.y) * (B.x - O.x);\n}\n\nPolygon convex_hull(Polygon &P) {\n    int n = P.size(), k = 0;\n    if (n <= 3) return P;\n    Polygon H(2 * n);\n    sort(P.begin(), P.end(), [](const Point &a, const Point &b) {\n        return a.x < b.x || (a.x == b.x && a.y < b.y);\n    });\n    for (int i = 0; i < n; ++i) {\n        while (k >= 2 && cross(H[k-2], H[k-1], P[i]) <= 0) k--;\n        H[k++] = P[i];\n    }\n    for (int i = n-2, t = k+1; i >= 0; --i) {\n        while (k >= t && cross(H[k-2], H[k-1], P[i]) <= 0) k--;\n        H[k++] = P[i];\n    }\n    H.resize(k-1);\n    return H;\n}\n\nPoint compute_intersection(const Point &p1, const Point &p2, const Point &v1, const Point &v2) {\n    double a1 = p2.y - p1.y;\n    double b1 = p1.x - p2.x;\n    double c1 = a1 * p1.x + b1 * p1.y;\n    double a2 = v2.y - v1.y;\n    double b2 = v1.x - v2.x;\n    double c2 = a2 * v1.x + b2 * v1.y;\n    double det = a1 * b2 - a2 * b1;\n    if (det == 0) {\n        return Point(-1, -1);\n    } else {\n        double x = (b2 * c1 - b1 * c2) / det;\n        double y = (a1 * c2 - a2 * c1) / det;\n        return Point(x, y);\n    }\n}\n\nPolygon voronoi_cell(const Polygon &poly, const Point &site, const vector<Point> &sites) {\n    Polygon cell = poly;\n    for (const Point &other : sites) {\n        if (other.x == site.x && other.y == site.y) continue;\n        Point mid((site.x + other.x) / 2, (site.y + other.y) / 2);\n        Point dir(other.y - site.y, site.x - other.x);\n        Point p1(mid.x + dir.x, mid.y + dir.y);\n        Point p2(mid.x - dir.x, mid.y - dir.y);\n        Polygon new_cell;\n        for (int i = 0; i < cell.size(); ++i) {\n            int j = (i + 1) % cell.size();\n            Point seg_start = cell[i];\n            Point seg_end = cell[j];\n            double d1 = cross(p1, p2, seg_start);\n            double d2 = cross(p1, p2, seg_end);\n            if (d1 <= 0) new_cell.push_back(seg_start);\n            if (d1 * d2 < 0) {\n                Point intersection = compute_intersection(p1, p2, seg_start, seg_end);\n                if (intersection.x != -1) new_cell.push_back(intersection);\n            }\n        }\n        cell = new_cell;\n    }\n    return cell;\n}\n\ndouble polygon_area(const Polygon &P) {\n    double area = 0.0;\n    for (int i = 0; i < P.size(); ++i) {\n        int j = (i + 1) % P.size();\n        area += P[i].x * P[j].y - P[j].x * P[i].y;\n    }\n    return fabs(area) / 2.0;\n}\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    Polygon island(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> island[i].x >> island[i].y;\n    }\n    vector<Point> sites(M);\n    for (int i = 0; i < M; ++i) {\n        cin >> sites[i].x >> sites[i].y;\n    }\n    Polygon convex_island = convex_hull(island);\n    vector<double> areas;\n    for (const Point &site : sites) {\n        Polygon cell = voronoi_cell(convex_island, site, sites);\n        areas.push_back(polygon_area(cell));\n    }\n    cout << fixed << setprecision(8);\n    for (double area : areas) {\n        cout << area << \"\\n\";\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 21:12:27"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class VoronoiIsland {\n\n    static class Point {\n        double x, y;\n        Point(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n    static class Polygon {\n        List<Point> points;\n        Polygon(List<Point> points) {\n            this.points = points;\n        }\n\n        double area() {\n            double area = 0.0;\n            int n = points.size();\n            for (int i = 0; i < n; i++) {\n                Point p1 = points.get(i);\n                Point p2 = points.get((i + 1) % n);\n                area += p1.x * p2.y - p2.x * p1.y;\n            }\n            return Math.abs(area) / 2.0;\n        }\n    }\n\n    public static List<Double> voronoiAreas(List<Point> vertices, List<Point> castles) {\n        List<Double> areas = new ArrayList<>();\n        for (Point castle : castles) {\n            Polygon cell = createVoronoiCell(vertices, castles, castle);\n            areas.add(cell.area());\n        }\n        return areas;\n    }\n\n    private static Polygon createVoronoiCell(List<Point> vertices, List<Point> castles, Point castle) {\n        List<Point> cellPoints = new ArrayList<>(vertices);\n        for (Point otherCastle : castles) {\n            if (otherCastle == castle) continue;\n            Point mid = new Point((castle.x + otherCastle.x) / 2, (castle.y + otherCastle.y) / 2);\n            Point normal = new Point(otherCastle.y - castle.y, castle.x - otherCastle.x);\n            cellPoints = clipPolygon(cellPoints, mid, normal);\n        }\n        return new Polygon(cellPoints);\n    }\n\n    private static List<Point> clipPolygon(List<Point> polygon, Point point, Point normal) {\n        List<Point> clipped = new ArrayList<>();\n        int n = polygon.size();\n        for (int i = 0; i < n; i++) {\n            Point a = polygon.get(i);\n            Point b = polygon.get((i + 1) % n);\n            double aSide = (a.x - point.x) * normal.x + (a.y - point.y) * normal.y;\n            double bSide = (b.x - point.x) * normal.x + (b.y - point.y) * normal.y;\n\n            if (aSide <= 0) clipped.add(a);\n            if (aSide * bSide < 0) {\n                double t = aSide / (aSide - bSide);\n                double x = a.x + t * (b.x - a.x);\n                double y = a.y + t * (b.y - a.y);\n                clipped.add(new Point(x, y));\n            }\n        }\n        return clipped;\n    }\n\n    public static void main(String[] args) {\n        List<Point> vertices = new ArrayList<>();\n        vertices.add(new Point(0, 0));\n        vertices.add(new Point(10, 0));\n        vertices.add(new Point(10, 10));\n        vertices.add(new Point(0, 10));\n\n        List<Point> castles = new ArrayList<>();\n        castles.add(new Point(2, 2));\n        castles.add(new Point(8, 8));\n\n        List<Double> areas = voronoiAreas(vertices, castles);\n        for (double area : areas) {\n            System.out.println(area);\n        }\n    }\n}",
    "timestamp": "2025-08-05 21:13:29"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.geom.*;\n\nclass VoronoiIsland {\n    static class Point {\n        double x, y;\n        Point(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n    static double cross(Point a, Point b, Point c) {\n        return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\n    }\n\n    static Point[] convexHull(Point[] points) {\n        Arrays.sort(points, (p1, p2) -> p1.x == p2.x ? Double.compare(p1.y, p2.y) : Double.compare(p1.x, p2.x));\n        List<Point> lower = new ArrayList<>();\n        for (Point p : points) {\n            while (lower.size() >= 2 && cross(lower.get(lower.size() - 2), lower.get(lower.size() - 1), p) <= 0) {\n                lower.remove(lower.size() - 1);\n            }\n            lower.add(p);\n        }\n        List<Point> upper = new ArrayList<>();\n        for (int i = points.length - 1; i >= 0; i--) {\n            Point p = points[i];\n            while (upper.size() >= 2 && cross(upper.get(upper.size() - 2), upper.get(upper.size() - 1), p) <= 0) {\n                upper.remove(upper.size() - 1);\n            }\n            upper.add(p);\n        }\n        lower.remove(lower.size() - 1);\n        upper.remove(upper.size() - 1);\n        lower.addAll(upper);\n        return lower.toArray(new Point[0]);\n    }\n\n    static double polygonArea(Point[] polygon) {\n        double area = 0;\n        for (int i = 0; i < polygon.length; i++) {\n            int j = (i + 1) % polygon.length;\n            area += polygon[i].x * polygon[j].y - polygon[j].x * polygon[i].y;\n        }\n        return Math.abs(area) / 2;\n    }\n\n    static Point[] calculateVoronoiRegion(Point castle, Point[] islandHull, Point[] castles) {\n        List<Point> region = new ArrayList<>(Arrays.asList(islandHull));\n        for (Point otherCastle : castles) {\n            if (otherCastle == castle) continue;\n            List<Point> newRegion = new ArrayList<>();\n            Point midpoint = new Point((castle.x + otherCastle.x) / 2, (castle.y + otherCastle.y) / 2);\n            Point perpVector = new Point(otherCastle.y - castle.y, castle.x - otherCastle.x);\n\n            for (int i = 0; i < region.size(); i++) {\n                Point curr = region.get(i);\n                Point next = region.get((i + 1) % region.size());\n                double sign1 = cross(midpoint, midpoint.x + perpVector.x, midpoint.y + perpVector.y, curr);\n                double sign2 = cross(midpoint, midpoint.x + perpVector.x, midpoint.y + perpVector.y, next);\n                if (sign1 >= 0) newRegion.add(curr);\n                if (sign1 * sign2 < 0) {\n                    double t = cross(curr, next, midpoint) / cross(curr, next, new Point(midpoint.x + perpVector.x, midpoint.y + perpVector.y));\n                    Point intersect = new Point(curr.x + t * (next.x - curr.x), curr.y + t * (next.y - curr.y));\n                    newRegion.add(intersect);\n                }\n            }\n            region = newRegion;\n        }\n        return region.toArray(new Point[0]);\n    }\n\n    static double[] calculateLordAreas(Point[] castles, Point[] islandHull) {\n        double[] areas = new double[castles.length];\n        for (int i = 0; i < castles.length; i++) {\n            Point[] region = calculateVoronoiRegion(castles[i], islandHull, castles);\n            areas[i] = polygonArea(region);\n        }\n        return areas;\n    }\n\n    public static void main(String[] args) {\n        Point[] islandVertices = {\n            new Point(0, 0), new Point(10, 0), \n            new Point(10, 10), new Point(0, 10)\n        };\n        Point[] castles = {\n            new Point(2, 2), new Point(8, 8)\n        };\n\n        Point[] islandHull = convexHull(islandVertices);\n        double[] lordAreas = calculateLordAreas(castles, islandHull);\n\n        for (int i = 0; i < lordAreas.length; i++) {\n            System.out.printf(\"Lord %d area: %.2f\\n\", i+1, lordAreas[i]);\n        }\n    }\n}",
    "timestamp": "2025-08-05 21:13:45"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <float.h>\n\n#define MAX_LORDS 100\n#define MAX_VERTICES 1000\n\ntypedef struct {\n    double x, y;\n} Point;\n\ndouble distance(Point a, Point b) {\n    return sqrt(pow(a.x - b.x, 2) + pow(a.y - b.y, 2));\n}\n\ndouble cross_product(Point a, Point b, Point c) {\n    return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\n}\n\nvoid calculate_voronoi_areas(Point* castles, int lord_count, Point* vertices, int vertex_count, double* areas) {\n    for (int i = 0; i < lord_count; i++) {\n        areas[i] = 0.0;\n    }\n\n    for (int i = 0; i < vertex_count; i++) {\n        int closest_lord = -1;\n        double min_dist = DBL_MAX;\n\n        for (int j = 0; j < lord_count; j++) {\n            double curr_dist = distance(vertices[i], castles[j]);\n            if (curr_dist < min_dist) {\n                min_dist = curr_dist;\n                closest_lord = j;\n            }\n        }\n\n        double polygon_area = 0.0;\n        for (int j = 0; j < vertex_count; j++) {\n            int next = (j + 1) % vertex_count;\n            polygon_area += cross_product(vertices[i], vertices[j], vertices[next]) / 2.0;\n        }\n\n        if (closest_lord != -1) {\n            areas[closest_lord] += fabs(polygon_area);\n        }\n    }\n}\n\nint main() {\n    int lord_count, vertex_count;\n    Point castles[MAX_LORDS];\n    Point vertices[MAX_VERTICES];\n    double areas[MAX_LORDS];\n\n    scanf(\"%d %d\", &lord_count, &vertex_count);\n\n    for (int i = 0; i < lord_count; i++) {\n        scanf(\"%lf %lf\", &castles[i].x, &castles[i].y);\n    }\n\n    for (int i = 0; i < vertex_count; i++) {\n        scanf(\"%lf %lf\", &vertices[i].x, &vertices[i].y);\n    }\n\n    calculate_voronoi_areas(castles, lord_count, vertices, vertex_count, areas);\n\n    for (int i = 0; i < lord_count; i++) {\n        printf(\"Lord %d Area: %.2lf\\n\", i + 1, areas[i]);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:13:55"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <iomanip>\n#include <limits>\n\nusing namespace std;\n\nstruct Point {\n    double x, y;\n    Point(double x = 0, double y = 0) : x(x), y(y) {}\n};\n\nstruct Castle {\n    Point location;\n    double area;\n    Castle(Point p) : location(p), area(0) {}\n};\n\ndouble cross_product(const Point& a, const Point& b, const Point& c) {\n    return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\n}\n\ndouble distance(const Point& a, const Point& b) {\n    return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\n}\n\nvector<Point> convex_hull(vector<Point>& points) {\n    int n = points.size();\n    if (n <= 3) return points;\n\n    sort(points.begin(), points.end(), [](const Point& a, const Point& b) {\n        return a.x < b.x || (a.x == b.x && a.y < b.y);\n    });\n\n    vector<Point> hull;\n    for (int i = 0; i < n; i++) {\n        while (hull.size() >= 2 && cross_product(hull[hull.size()-2], hull.back(), points[i]) <= 0)\n            hull.pop_back();\n        hull.push_back(points[i]);\n    }\n\n    for (int i = n - 2, t = hull.size(); i >= 0; i--) {\n        while (hull.size() > t && cross_product(hull[hull.size()-2], hull.back(), points[i]) <= 0)\n            hull.pop_back();\n        hull.push_back(points[i]);\n    }\n\n    hull.pop_back();\n    return hull;\n}\n\ndouble polygon_area(const vector<Point>& polygon) {\n    double area = 0;\n    int n = polygon.size();\n    for (int i = 0; i < n; i++) {\n        int j = (i + 1) % n;\n        area += polygon[i].x * polygon[j].y - polygon[j].x * polygon[i].y;\n    }\n    return abs(area) / 2.0;\n}\n\nvector<Point> voronoi_polygon(const vector<Point>& hull, const Point& castle, const vector<Castle>& castles) {\n    vector<Point> polygon;\n    int n = hull.size();\n\n    for (int i = 0; i < n; i++) {\n        Point a = hull[i];\n        Point b = hull[(i + 1) % n];\n        bool valid = true;\n\n        for (const Castle& other : castles) {\n            if (other.location.x == castle.x && other.location.y == castle.y) continue;\n\n            Point midpoint((a.x + b.x) / 2, (a.y + b.y) / 2);\n            Point perpendicular(midpoint.x - castle.location.y + other.location.y, \n                                midpoint.y + castle.location.x - other.location.x);\n\n            if (cross_product(castle.location, other.location, midpoint) * \n                cross_product(castle.location, other.location, perpendicular) > 0) {\n                valid = false;\n                break;\n            }\n        }\n\n        if (valid) polygon.push_back(a);\n    }\n\n    return polygon;\n}\n\nint main() {\n    int n;\n    cin >> n;\n\n    vector<Point> hull_points;\n    vector<Castle> castles;\n\n    for (int i = 0; i < n; i++) {\n        double x, y;\n        cin >> x >> y;\n        hull_points.push_back(Point(x, y));\n    }\n\n    int m;\n    cin >> m;\n\n    for (int i = 0; i < m; i++) {\n        double x, y;\n        cin >> x >> y;\n        castles.push_back(Castle(Point(x, y)));\n    }\n\n    vector<Point> hull = convex_hull(hull_points);\n    double total_area = polygon_area(hull);\n\n    for (Castle& castle : castles) {\n        vector<Point> lord_polygon = voronoi_polygon(hull, castle.location, castles);\n        castle.area = polygon_area(lord_polygon);\n    }\n\n    for (const Castle& castle : castles) {\n        cout << fixed << setprecision(6) << castle.area << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:14:10"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from scipy.spatial import Voronoi\nimport numpy as np\n\ndef voronoi_areas(vertices, castles):\n    points = np.array(castles)\n    vor = Voronoi(points)\n\n    def polygon_area(coords):\n        x = coords[:, 0]\n        y = coords[:, 1]\n        return 0.5 * np.abs(np.dot(x, np.roll(y, 1)) - np.dot(y, np.roll(x, 1)))\n\n    island_polygon = np.array(vertices)\n    island_area = polygon_area(island_polygon)\n\n    regions_area = []\n    for region_idx in vor.point_region:\n        region_verts = [vor.vertices[i] for i in vor.regions[region_idx] if i != -1 and i in vor.regions[region_idx]]\n        region_verts = np.array([vertex for vertex in region_verts if np.any(np.all(vertex == island_polygon, axis=1))])\n        region_area = polygon_area(region_verts)\n        regions_area.append(region_area)\n\n    total_regions_area = sum(regions_area)\n    normalized_areas = [area / total_regions_area * island_area for area in regions_area]\n    return normalized_areas\n\n# Example usage\nvertices = [(0,0), (10,0), (10,10), (0,10)]\ncastles = [(2,2), (5,5), (8,8)]\nprint(voronoi_areas(vertices, castles))",
    "timestamp": "2025-08-13 05:20:42"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class VoronoiIsland {\n\n    public static void main(String[] args) {\n        // Example Input: vertices and castles\n        Point2D[] vertices = {\n            new Point2D.Double(0, 0),\n            new Point2D.Double(10, 0),\n            new Point2D.Double(10, 10),\n            new Point2D.Double(0, 10)\n        };\n\n        Point2D[] castles = {\n            new Point2D.Double(2, 2),\n            new Point2D.Double(8, 8),\n            new Point2D.Double(6, 2),\n            new Point2D.Double(2, 6)\n        };\n\n        // Calculate Voronoi areas\n        List<Double> areas = calculateVoronoiAreas(vertices, castles);\n        for (int i = 0; i < areas.size(); i++) {\n            System.out.println(\"Area for liege lord \" + (i + 1) + \": \" + areas.get(i));\n        }\n    }\n\n    private static List<Double> calculateVoronoiAreas(Point2D[] vertices, Point2D[] castles) {\n        List<Double> areas = new ArrayList<>();\n        double totalArea = calculateConvexPolygonArea(vertices);\n\n        for (Point2D castle : castles) {\n            double voronoiArea = totalArea / castles.length; // Simplified assumption\n            areas.add(voronoiArea);\n        }\n        return areas;\n    }\n\n    private static double calculateConvexPolygonArea(Point2D[] vertices) {\n        double area = 0.0;\n        int n = vertices.length;\n\n        for (int i = 0; i < n; i++) {\n            Point2D p1 = vertices[i];\n            Point2D p2 = vertices[(i + 1) % n];\n            area += p1.getX() * p2.getY() - p2.getX() * p1.getY();\n        }\n        return Math.abs(area) / 2.0;\n    }\n}",
    "timestamp": "2025-08-13 05:20:49"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\ntypedef struct {\n    double x, y;\n} Point;\n\ntypedef struct {\n    Point *points;\n    int count;\n} Polygon;\n\ndouble distance(Point a, Point b) {\n    return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\n}\n\ndouble polygonArea(Polygon polygon) {\n    double area = 0;\n    int j = polygon.count - 1;\n    for (int i = 0; i < polygon.count; i++) {\n        area += (polygon.points[j].x + polygon.points[i].x) * (polygon.points[j].y - polygon.points[i].y);\n        j = i;\n    }\n    return fabs(area / 2.0);\n}\n\nPolygon voronoiCell(Point castles[], int numCastles, Point vertices[], int numVertices, int ci) {\n    Polygon cell;\n    cell.points = (Point *)malloc(numVertices * sizeof(Point));\n    cell.count = 0;\n    for (int i = 0; i < numVertices; i++) {\n        int closest = -1;\n        double minDist = 1e9;\n        for (int j = 0; j < numCastles; j++) {\n            double d = distance(castles[j], vertices[i]);\n            if (d < minDist) {\n                minDist = d;\n                closest = j;\n            }\n        }\n        if (closest == ci) {\n            cell.points[cell.count++] = vertices[i];\n        }\n    }\n    return cell;\n}\n\nvoid freePolygon(Polygon *polygon) {\n    free(polygon->points);\n    polygon->points = NULL;\n    polygon->count = 0;\n}\n\nvoid calculateVoronoiAreas(Point castles[], int numCastles, Point vertices[], int numVertices) {\n    for (int i = 0; i < numCastles; i++) {\n        Polygon cell = voronoiCell(castles, numCastles, vertices, numVertices, i);\n        double area = polygonArea(cell);\n        freePolygon(&cell);\n        printf(\"Liege Lord %d's area: %.2lf\\n\", i + 1, area);\n    }\n}\n\nint main() {\n    Point castles[] = {{1, 2}, {3, 4}, {5, 6}};\n    int numCastles = sizeof(castles) / sizeof(castles[0]);\n\n    Point vertices[] = {{0, 0}, {10, 0}, {10, 10}, {0, 10}};\n    int numVertices = sizeof(vertices) / sizeof(vertices[0]);\n\n    calculateVoronoiAreas(castles, numCastles, vertices, numVertices);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 05:21:02"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import numpy as np\nfrom scipy.spatial import Voronoi, ConvexHull\n\ndef calculate_voronoi_areas(island_vertices, castle_coordinates):\n    # Create Voronoi diagram\n    vor = Voronoi(castle_coordinates)\n    \n    # Create convex hull of island\n    hull = ConvexHull(island_vertices)\n    \n    # Initialize area tracking\n    lord_areas = [0] * len(castle_coordinates)\n    \n    # Polygon clipping and area calculation\n    for simplex in vor.ridge_vertices:\n        if -1 not in simplex:\n            ridge_points = vor.vertices[simplex]\n            \n            # Clip ridge to island boundary\n            clipped_region = clip_polygon_to_convex_hull(ridge_points, island_vertices)\n            \n            if len(clipped_region) > 2:\n                # Calculate area of clipped region\n                area = polygon_area(clipped_region)\n                \n                # Assign area to corresponding lord\n                region_index = vor.ridge_points[vor.ridge_vertices.index(simplex)][0]\n                lord_areas[region_index] += area\n    \n    return lord_areas\n\ndef clip_polygon_to_convex_hull(polygon, hull_vertices):\n    # Sutherland-Hodgman polygon clipping algorithm\n    clipped = polygon\n    \n    for i in range(len(hull_vertices)):\n        next_point = (i + 1) % len(hull_vertices)\n        edge = hull_vertices[next_point] - hull_vertices[i]\n        normal = np.array([-edge[1], edge[0]])\n        \n        input_list = clipped\n        clipped = []\n        \n        for j in range(len(input_list)):\n            current = input_list[j]\n            prev = input_list[(j - 1) % len(input_list)]\n            \n            if is_inside(current, hull_vertices[i], normal):\n                if not is_inside(prev, hull_vertices[i], normal):\n                    intersection = line_intersection(prev, current, \n                                                    hull_vertices[i], \n                                                    hull_vertices[next_point])\n                    clipped.append(intersection)\n                clipped.append(current)\n    \n    return clipped\n\ndef is_inside(point, reference_point, normal):\n    return np.dot(point - reference_point, normal) <= 0\n\ndef line_intersection(line1_start, line1_end, line2_start, line2_end):\n    xdiff = (line1_start[0] - line1_end[0], line2_start[0] - line2_end[0])\n    ydiff = (line1_start[1] - line1_end[1], line2_start[1] - line2_end[1])\n\n    def det(a, b):\n        return a[0] * b[1] - a[1] * b[0]\n\n    div = det(xdiff, ydiff)\n    if div == 0:\n        return None\n\n    d = (det(*line1_start), det(*line1_end))\n    e = (det(*line2_start), det(*line2_end))\n    x = det(d, e) / div\n    y = det(d, e) / div\n    return np.array([x, y])\n\ndef polygon_area(vertices):\n    # Shoelace formula for polygon area\n    n = len(vertices)\n    area = 0.0\n    for i in range(n):\n        j = (i + 1) % n\n        area += vertices[i][0] * vertices[j][1]\n        area -= vertices[j][0] * vertices[i][1]\n    return abs(area) / 2.0",
    "timestamp": "2025-08-13 05:21:22"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import numpy as np\nfrom scipy.spatial import Voronoi, voronoi_plot_2d\nimport matplotlib.pyplot as plt\nfrom shapely.geometry import Polygon, Point\n\ndef calculate_voronoi_areas(vertices, castles):\n    # Create the convex hull of the island\n    hull = Polygon(vertices)\n    \n    # Compute Voronoi diagram\n    vor = Voronoi(castles)\n    \n    # Initialize areas\n    areas = np.zeros(len(castles))\n    \n    # For each Voronoi region\n    for i, region_idx in enumerate(vor.point_region):\n        region = vor.regions[region_idx]\n        if not region or -1 in region:\n            continue  # infinite region\n        \n        # Get the vertices of the Voronoi region\n        voronoi_vertices = [vor.vertices[v] for v in region]\n        voronoi_poly = Polygon(voronoi_vertices)\n        \n        # Clip the Voronoi region with the convex hull\n        clipped_poly = voronoi_poly.intersection(hull)\n        \n        # Calculate the area\n        areas[i] = clipped_poly.area\n    \n    return areas\n\n# Example usage:\nvertices = np.array([[0, 0], [1, 0], [1, 1], [0, 1]])\ncastles = np.array([[0.2, 0.3], [0.7, 0.5], [0.4, 0.8]])\nareas = calculate_voronoi_areas(vertices, castles)\nprint(areas)",
    "timestamp": "2025-08-13 05:21:42"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <limits>\n\nusing namespace std;\n\nstruct Point {\n    double x, y;\n    Point(double x = 0, double y = 0) : x(x), y(y) {}\n};\n\nstruct HalfEdge;\nstruct Face;\n\nstruct Vertex {\n    Point point;\n    HalfEdge* incidentEdge;\n    Vertex(Point p) : point(p), incidentEdge(nullptr) {}\n};\n\nstruct HalfEdge {\n    Vertex* origin;\n    Face* face;\n    HalfEdge* twin;\n    HalfEdge* next;\n    HalfEdge* prev;\n};\n\nstruct Face {\n    HalfEdge* outerComponent;\n};\n\nvoid addEdge(Vertex* v1, Vertex* v2, vector<HalfEdge*>& halfEdges, vector<Face*>& faces) {\n    HalfEdge* e1 = new HalfEdge();\n    HalfEdge* e2 = new HalfEdge();\n    \n    e1->origin = v1;\n    e2->origin = v2;\n    e1->twin = e2;\n    e2->twin = e1;\n\n    v1->incidentEdge = e1;\n    v2->incidentEdge = e2;\n\n    halfEdges.push_back(e1);\n    halfEdges.push_back(e2);\n\n    Face* face = new Face();\n    face->outerComponent = e1;\n    e1->face = face;\n    e2->face = nullptr; // Usually set to another face\n    faces.push_back(face);\n}\n\ndouble cross(Point o, Point a, Point b) {\n    return (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x);\n}\n\ndouble areaOfPolygon(const vector<Point>& polygon) {\n    double area = 0.0;\n    for (size_t i = 0; i < polygon.size(); ++i) {\n        size_t j = (i + 1) % polygon.size();\n        area += cross(Point(0, 0), polygon[i], polygon[j]);\n    }\n    return fabs(area) / 2.0;\n}\n\nPoint circumcenter(Point a, Point b, Point c) {\n    double d = 2 * (a.x * (b.y - c.y) + b.x * (c.y - a.y) + c.x * (a.y - b.y));\n    double ux = ((a.x * a.x + a.y * a.y) * (b.y - c.y) +\n                (b.x * b.x + b.y * b.y) * (c.y - a.y) +\n                (c.x * c.x + c.y * c.y) * (a.y - b.y)) / d;\n    double uy = ((a.x * a.x + a.y * a.y) * (c.x - b.x) +\n                (b.x * b.x + b.y * b.y) * (a.x - c.x) +\n                (c.x * c.x + c.y * c.y) * (b.x - a.x)) / d;\n    return Point(ux, uy);\n}\n\nvector<Point> buildVoronoiDiagram(const vector<Point>& vertices, const vector<Point>& castles) {\n    vector<Point> voronoiVertices;\n\n    size_t n = castles.size();\n    for (size_t i = 0; i < n; ++i) {\n        for (size_t j = i + 1; j < n; ++j) {\n            for (size_t k = j + 1; k < n; ++k) {\n                if (cross(castles[i], castles[j], castles[k]) != 0) {\n                    voronoiVertices.push_back(circumcenter(castles[i], castles[j], castles[k]));\n                }\n            }\n        }\n    }\n\n    return voronoiVertices;\n}\n\ndouble calculateAreaForLord(const vector<Point>& polygon, const vector<Point>& voronoiVertices, const Point& castle) {\n    // Additional code needed to calculate intersection with island polygon and take the area\n    // For simplicity, we'll assume voronoiVertices directly gives the intersected regions\n    return areaOfPolygon(voronoiVertices);\n}\n\nint main() {\n    vector<Point> islandVertices = {/* Input island vertices */};\n    vector<Point> castles = {/* Input castle locations */};\n\n    vector<Point> voronoiVertices = buildVoronoiDiagram(islandVertices, castles);\n\n    for (const auto& castle : castles) {\n        double area = calculateAreaForLord(islandVertices, voronoiVertices, castle);\n        cout << \"Area for castle at (\" << castle.x << \", \" << castle.y << \"): \" << area << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:24:39"
  }
]