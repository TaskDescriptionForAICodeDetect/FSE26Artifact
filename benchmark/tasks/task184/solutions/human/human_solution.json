[
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<math.h>\n#include<queue>\n#include<vector>\nusing namespace std;\nconst double EPS = 1e-10;\nconst double INF = 1e+10;\nconst double PI = acos(-1);\ninline double ABS(double a){return max(a,-a);}\nint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\nstruct Pt {\n    double x, y;\n    Pt() {}\n    Pt(double x, double y) : x(x), y(y) {}\n    Pt operator+(const Pt &a) const { return Pt(x + a.x, y + a.y); }\n    Pt operator-(const Pt &a) const { return Pt(x - a.x, y - a.y); }\n    Pt operator*(const Pt &a) const { return Pt(x * a.x - y * a.y, x * a.y + y * a.x); }\n    Pt operator-() const { return Pt(-x, -y); }\n    Pt operator*(const double &k) const { return Pt(x * k, y * k); }\n    Pt operator/(const double &k) const { return Pt(x / k, y / k); }\n    double ABS() const { return sqrt(x * x + y * y); }\n    double abs2() const { return x * x + y * y; }\n    double arg() const { return atan2(y, x); }\n    double dot(const Pt &a) const { return x * a.x + y * a.y; }\n    double det(const Pt &a) const { return x * a.y - y * a.x; }\n};\ndouble tri(const Pt &a, const Pt &b, const Pt &c) { return (b - a).det(c - a); }\nint iSP(Pt a, Pt b, Pt c) {\n    int s = sig((b - a).det(c - a));\n    if (s) return s;\n    if (sig((b - a).dot(c - a)) < 0) return -2; // c-a-b\n    if (sig((a - b).dot(c - b)) < 0) return +2; // a-b-c\n    return 0;\n}\nint iLL(Pt a, Pt b, Pt c, Pt d) {\n    if (sig((b - a).det(d - c))) return 1; // intersect\n    if (sig((b - a).det(c - a))) return 0; // parallel\n    return -1; // correspond\n}\nbool iLS(Pt a, Pt b, Pt c, Pt d) {\n    return (sig(tri(a, b, c)) * sig(tri(a, b, d)) <= 0);\n}\nbool iSS(Pt a, Pt b, Pt c, Pt d) {\n    return (iSP(a, b, c) * iSP(a, b, d) <= 0 && iSP(c, d, a) * iSP(c, d, b) <= 0);\n}\nbool iSSstrict(Pt a, Pt b, Pt c, Pt d) {\n    return (sig(tri(a, b, c)) * sig(tri(a, b, d)) < 0 && sig(tri(c, d, a)) * sig(tri(c, d, b)) < 0);\n}\nPt pLL(Pt a, Pt b, Pt c, Pt d) {\n    b = b - a; d = d - c; return a + b * (c - a).det(d) / b.det(d);\n}\ndouble dLP(Pt a, Pt b, Pt c) {\n    return ABS(tri(a, b, c)) / (b - a).ABS();\n}\ndouble dSP(Pt a, Pt b, Pt c) {\n    if (sig((b - a).dot(c - a)) <= 0) return (c - a).ABS();\n    if (sig((a - b).dot(c - b)) <= 0) return (c - b).ABS();\n    return ABS(tri(a, b, c)) / (b - a).ABS();\n}\ndouble dLL(Pt a, Pt b, Pt c, Pt d) {\n    return iLL(a, b, c, d) ? 0 : dLP(a, b, c);\n}\ndouble dLS(Pt a, Pt b, Pt c, Pt d) {\n    return iLS(a, b, c, d) ? 0 : min(dLP(a, b, c), dLP(a, b, d));\n}\ndouble dSS(Pt a, Pt b, Pt c, Pt d) {\n    return iSS(a, b, c, d) ? 0 : min(min(dSP(a, b, c), dSP(a, b, d)), min(dSP(c, d, a), dSP(c, d, b)));\n}\nvector<Pt> convexCut(int n, vector<Pt>p, Pt a, Pt b) {\n    int m = 0, i;\n    p.push_back(p[0]);\n    vector<Pt>q;\n    for (i = 0; i < n; ++i) {\n    //  printf(\"%d %d\\n\",i,q.size());\n        if (sig(tri(a, b, p[i])) >= 0) q.push_back(p[i]);\n        if (sig(tri(a, b, p[i])) * sig(tri(a, b, p[i + 1])) < 0)\n            q.push_back(pLL(a, b, p[i], p[i + 1]));\n    }\n    return q;\n}\nPt c[23];\nPt d[23];\nvector<vector<Pt> > poly[12];\nvector<pair<Pt,Pt> >edge;\nPt z[500];\nvector<pair<int,double> >g[500];\ndouble ijk[500];\nint v[500];\nint main(){\n    int b;\n    while(scanf(\"%d\",&b),b){\n        vector<Pt>s;\n\t\tint a=4;\n\t\tc[0]=Pt(0,0);\n\t\tc[1]=Pt(4,0);\n\t\tc[2]=Pt(4,4);\n\t\tc[3]=Pt(0,4);\n\t\tfor(int i=0;i<4;i++)s.push_back(c[i]);\n        \n        for(int i=0;i<b;i++){\n            double x,y;scanf(\"%lf%lf\",&x,&y);\n            d[i]=Pt(x,y);\n        }\n\t\tedge.clear();\n        for(int i=0;i<b;i++){\n            vector<Pt> now=s;\n            for(int j=0;j<b;j++){\n                if(i==j)continue;\n                pair<Pt,Pt> L=make_pair((d[i]+d[j])/2.0,(d[i]+d[j])/2.0+(d[i]-d[j])*Pt(0,1));\n                now=convexCut(now.size(),now,L.second,L.first);\n            }\n\t\t\tfor(int j=0;j<now.size();j++){\n\t\t\t\tbool dame=false;\n\t\t\t\tfor(int k=0;k<4;k++)if(iLL(now[j],now[(j+1)%now.size()],c[k],c[(k+1)%4])==-1)dame=true;\n\t\t\t\tif(dame)continue;\n\t\t\t\tedge.push_back(make_pair(now[j],now[(j+1)%now.size()]));\n\t\t\t}\n        }\n\t\tint sz=0;\n\t\tfor(int i=0;i<500;i++){g[i].clear();v[i]=0;ijk[i]=999999999;}\n\t\tfor(int i=0;i<edge.size();i++){\n\t\t\tif((edge[i].first-edge[i].second).ABS()<EPS)continue;\n\t\t\tint at=-1;\n\t\t\tfor(int j=0;j<sz;j++)if((z[j]-edge[i].first).ABS()<EPS){at=j;break;}\n\t\t\tif(!~at){at=sz;z[sz++]=edge[i].first;}\n\t\t\tint at2=-1;\n\t\t\tfor(int j=0;j<sz;j++)if((z[j]-edge[i].second).ABS()<EPS){at2=j;break;}\n\t\t\tif(!~at2){at2=sz;z[sz++]=edge[i].second;}\n\t\t\tg[at].push_back(make_pair(at2,(edge[i].first-edge[i].second).ABS()));\n\t\t\tg[at2].push_back(make_pair(at,(edge[i].first-edge[i].second).ABS()));\n\t\t}\n\t\tpriority_queue<pair<double,int> >Q;\n\t\tfor(int i=0;i<sz;i++){\n\t\t\tif(sig(z[i].x)==0){\n\t\t\t\tijk[i]=0;\n\t\t\t\tQ.push(make_pair(0,i));\n\t\t\t}\n\t\t}\n\t\twhile(Q.size()){\n\t\t\tdouble cost=-Q.top().first;\n\t\t\tint at=Q.top().second;\n\t\t\tQ.pop();\n\t\t\tif(v[at])continue;\n\t\t\tv[at]=1;\n\t\t\tfor(int i=0;i<g[at].size();i++){\n\t\t\t\tif(!v[g[at][i].first]&&ijk[g[at][i].first]>cost+g[at][i].second){\n\t\t\t\t\tijk[g[at][i].first]=cost+g[at][i].second;\n\t\t\t\t\tQ.push(make_pair(-ijk[g[at][i].first],g[at][i].first));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdouble ret=999999999;\n\t\tfor(int i=0;i<sz;i++){\n\t\t\tif(sig(z[i].x-4.0)==0)ret=min(ret,ijk[i]);\n\t\t}\n\t\tif(ret>9999999)printf(\"impossible\\n\");\n\t\telse printf(\"%.12f\\n\",ret);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst double EPS=1e-8;\nconst double INF=1e77;\n\ntemplate<class T>\nstruct point{\n\tT x,y;\n\tpoint operator+(const point &a)const{ return (point){x+a.x,y+a.y}; }\n\tpoint operator-(const point &a)const{ return (point){x-a.x,y-a.y}; }\n};\n\ntemplate<class T>\npoint<T> operator*(T c,const point<T> &a){ return (point<T>){c*a.x,c*a.y}; }\n\nbool operator<(const point<double> &a,const point<double> &b){\n\treturn a.x+EPS<b.x || abs(a.x-b.x)<EPS && a.y+EPS<b.y;\n}\nbool operator==(const point<double> &a,const point<double> &b){\n\treturn abs(a.x-b.x)<EPS && abs(a.y-b.y)<EPS;\n}\n\ntemplate<class T>\nT dot(const point<T> &a,const point<T> &b){ return a.x*b.x+a.y*b.y; }\n\ntemplate<class T>\nT cross(const point<T> &a,const point<T> &b){ return a.x*b.y-a.y*b.x; }\n\ntemplate<class T>\ndouble abs(const point<T> &a){ return sqrt(a.x*a.x+a.y*a.y); }\n\ntemplate<class T>\nstruct line{ point<T> a,b; };\n\ntemplate<class T>\nstruct segment{\n\tpoint<T> a,b;\n\toperator line<T>()const{ return (line<T>){a,b}; }\n};\n\ntemplate<class T>\nstruct polygon:vector< point<T> >{\n\tpolygon(){}\n\tpolygon(int n):vector< point<T> >(n){}\n};\n\ntemplate<class T>\ndouble dist(const point<T> &a,const point<T> &b){\n\treturn sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));\n}\n\nbool cover(const segment<double> &S,const point<double> &p){\n\treturn dist(S.a,p)+dist(p,S.b)<dist(S.a,S.b)+EPS;\n}\n\nenum {CCW=1,CW=-1,ON=0};\nint ccw(const point<double> &a,const point<double> &b,const point<double> &c){\n\tdouble rdir=cross(b-a,c-a);\n\tif(rdir> EPS) return CCW;\n\tif(rdir<-EPS) return CW;\n\treturn ON;\n}\n\nbool intersect(const segment<double> &S1,const segment<double> &S2){\n\tif(max(S1.a.x,S1.b.x)+EPS<min(S2.a.x,S2.b.x)\n\t|| max(S1.a.y,S1.b.y)+EPS<min(S2.a.y,S2.b.y)\n\t|| max(S2.a.x,S2.b.x)+EPS<min(S1.a.x,S1.b.x)\n\t|| max(S2.a.y,S2.b.y)+EPS<min(S1.a.y,S1.b.y)) return false;\n\treturn ccw(S1.a,S1.b,S2.a)*ccw(S1.a,S1.b,S2.b)<=0\n\t\t&& ccw(S2.a,S2.b,S1.a)*ccw(S2.a,S2.b,S1.b)<=0;\n}\n\npoint<double> get_intersect(const line<double> &L1,const line<double> &L2){\n\tdouble a1=cross(L1.b-L1.a,L2.b-L2.a);\n\tdouble a2=cross(L1.b-L1.a,L1.b-L2.a);\n\tif(abs(a1)<EPS) return L1.a;\n\treturn L2.a+a2/a1*(L2.b-L2.a);\n}\n\ntemplate<class T>\nline<double> perp_bisector(const point<T> &a,const point<T> &b){\n\treturn (line<double>){(point<double>){(a.x-a.y+b.x+b.y)/2.0,(a.y+a.x+b.y-b.x)/2.0},\n\t\t\t\t\t\t  (point<double>){(a.x+a.y+b.x-b.y)/2.0,(a.y-a.x+b.y+b.x)/2.0}};\n}\n\ntemplate<class T>\npolygon<double> convex_cut(const polygon<T> &G,const line<T> &L){\n\tint n=G.size();\n\tpolygon<double> H;\n\trep(i,n){\n\t\tint d1=ccw(L.a,L.b,G[i]);\n\t\tint d2=ccw(L.a,L.b,G[(i+1)%n]);\n\t\tif(d1!=CW) H.push_back(G[i]);\n\t\tif(d1==CCW && d2==CW || d1==CW && d2==CCW){\n\t\t\tH.push_back(get_intersect(L,(line<T>){G[i],G[(i+1)%n]}));\n\t\t}\n\t}\n\treturn H;\n}\n\nvoid arrangement(const vector< segment<double> > &S,vector< point<double> > &P,vector<int> *G){\n\tint n=S.size();\n\tP.clear();\n\trep(i,n){\n\t\tP.push_back(S[i].a);\n\t\tP.push_back(S[i].b);\n\t\trep(j,i) if(intersect(S[i],S[j])) P.push_back(get_intersect(S[i],S[j]));\n\t}\n\tsort(P.begin(),P.end());\n\tP.erase(unique(P.begin(),P.end()),P.end());\n\n\trep(i,n){\n\t\tvector<int> on;\n\t\trep(u,P.size()) if(cover(S[i],P[u])) on.push_back(u);\n\t\trep(j,(int)on.size()-1){\n\t\t\tint u=on[j],v=on[j+1];\n\t\t\tG[u].push_back(v);\n\t\t\tG[v].push_back(u);\n\t\t}\n\t}\n}\n\nint main(){\n\tfor(int n; scanf(\"%d\",&n),n;){\n\t\tpoint<double> p[20];\n\t\trep(i,n) scanf(\"%lf%lf\",&p[i].x,&p[i].y);\n\n\t\tif(n==1){ puts(\"impossible\"); continue; }\n\n\t\tvector< segment<double> > S;\n\t\trep(i,n){\n\t\t\tpolygon<double> Vo; // p[i] の Volonoi cell\n\t\t\tVo.push_back((point<double>){0,0});\n\t\t\tVo.push_back((point<double>){4,0});\n\t\t\tVo.push_back((point<double>){4,4});\n\t\t\tVo.push_back((point<double>){0,4});\n\t\t\trep(j,n) if(i!=j) Vo=convex_cut(Vo,perp_bisector(p[i],p[j]));\n\t\t\trep(j,Vo.size()) {\n\t\t\t\tpoint<double> a=Vo[j],b=Vo[(j+1)%Vo.size()];\n\t\t\t\tif(abs(a.y-0)<EPS && abs(b.y-0)<EPS\n\t\t\t\t|| abs(a.y-4)<EPS && abs(b.y-4)<EPS) continue; // フィールドの縁はアレンジメントの候補に入れない\n\t\t\t\tS.push_back((segment<double>){a,b});\n\t\t\t}\n\t\t}\n\t\tS.push_back((segment<double>){(point<double>){0,0},(point<double>){0,4}});\n\t\tS.push_back((segment<double>){(point<double>){4,0},(point<double>){4,4}});\n\n\t\tvector< point<double> > P;\n\t\tvector<int> G[500];\n\t\tarrangement(S,P,G);\n\n\t\tint N=P.size();\n\t\tstatic double d[500][500];\n\t\trep(u,N) rep(v,N) d[u][v]=(u==v?0:INF);\n\t\trep(u,N) rep(i,G[u].size()) {\n\t\t\tint v=G[u][i];\n\t\t\td[u][v]=dist(P[u],P[v]);\n\t\t}\n\t\trep(w,N) rep(u,N) rep(v,N) d[u][v]=min(d[u][v],d[u][w]+d[w][v]);\n\n\t\tdouble ans=INF;\n\t\trep(u,N) rep(v,N) if(abs(P[u].x)<EPS && abs(P[v].x-4)<EPS) ans=min(ans,d[u][v]);\n\t\tif(ans<INF/2) printf(\"%.9f\\n\",ans);\n\t\telse          puts(\"impossible\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cmath>\n#include <complex>\n#include <queue>\n#include <cstdio>\nusing namespace std;\n\nconst double EPS = 1e-9;\nconst double PI = acos(-1);\n\ntypedef complex<double> P;\ntypedef vector<P> G;\n\nstruct L :public vector<P> {\n\tL(const P &a,const P &b){\n\t\tpush_back(a);\n\t\tpush_back(b);\n\t}\n};\n\n#define next(P,i) (P[(i+1)%P.size()])\n#define curr(P,i) (P[(i+0)%P.size()])\n\ndouble cross(const P &a,const P &b){\n\treturn imag(conj(a)*b);\n}\ndouble dot(const P &a,const P &b){\n\treturn real(conj(a)*b);\n}\n\nint ccw(P a,P b,P c){\n\tb -= a;\n\tc -= a;\n\tif( cross(b,c) > 0 ) return +1;\n\tif( cross(b,c) < 0 ) return -1;\n\tif( dot(b,c) < 0 ) return +2;\n\tif( norm(b) < norm(c) ) return -2;\n\treturn 0;\n}\n\nP crosspoint(const L &l,const L &m){\n\tdouble A = cross(l[1]-l[0],m[1]-m[0]);\n\tdouble B = cross(l[1]-l[0],l[1]-m[0]);\n\tif( abs(A) < EPS && abs(B) < EPS) return m[0];\n\treturn m[0]+B/A*(m[1]-m[0]);\n}\n\n\nG convex_cut(const G &poly,const L &l){\n\tG Q;\n\tfor(int i = 0 ; i < poly.size() ; i++){\n\t\tP A = curr(poly,i) , B = next(poly,i);\n\t\tif( ccw(l[0],l[1],A)!=-1)Q.push_back(A);\n\t\tif( ccw(l[0],l[1],A)*ccw(l[0],l[1],B)<0)Q.push_back(crosspoint(L(A,B),l));\n\t}\n\treturn Q;\n\t\t \n}\n\nL bisector(P a,P b){\n\tP A = (a+b) * P(0.5,0);\n\treturn L(A,A+(b-a)*P(0,PI/2));\n}\nG voronoi(G g,vector<P> v,int s){\n\tfor(int i = 0 ; i < v.size() ; i++){\n\t\tif( i != s ){\n\t\t\tg = convex_cut(g,bisector(v[s],v[i]));\n\t\t}\n\t}\n\treturn g;\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n && n){\n\t\tG area,p;\n\t\tarea.push_back(P(0,0));\n\t\tarea.push_back(P(0,4));\n\t\tarea.push_back(P(4,4));\n\t\tarea.push_back(P(4,0));\n\t\t\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tdouble x,y;\n\t\t\tcin >> x >> y;\n\t\t\tp.push_back(P(x,y));\n\t\t}\n\t\tvector<L> l;\n\t\tvector<P> vertex;\n\t\t\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tG v = voronoi(area,p,i);\n\t\t\tfor(int j = 0 ; j < v.size() ; j++){\n\t\t\t\tvertex.push_back(v[j]);\n\t\t\t\t//cout << i << \": \" << v[j] << endl;\n\t\t\t\tl.push_back(L(curr(v,j),next(v,j)));\n\t\t\t\tl.push_back(L(next(v,j),curr(v,j)));\n\t\t\t}\n\t\t}\n\t\tint done[16000]={};\n\t\tpriority_queue< pair<double,int> , vector< pair<double,int> > , greater < pair<double,int> > > Q;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tif( fabs(vertex[i].real()) < EPS ){\n\t\t\t\tQ.push(make_pair(0,i));\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile(Q.size()){\n\t\t\tpair<double,int> q = Q.top(); Q.pop();\n\t\t\tif( done[q.second]++ )continue;\n\t\t\tif( fabs(vertex[q.second].real() - 4.0 ) < EPS ){\n\t\t\t\tprintf(\"%.8lf%c\",q.first,10);\n\t\t\t\tgoto exit;\n\t\t\t}\n\t\t\tfor(int i = 0 ; i < vertex.size() ; i++){\n\t\t\t\tL ll(vertex[q.second],vertex[i]);\n\t\t\t\tint f = false;\n\t\t\t\tfor(int j = 0 ; j < l.size() ; j++){\n\t\t\t\t\tif( abs(l[j][0] - ll[0]) < EPS && abs(l[j][1]-ll[1]) <EPS ){\n\t\t\t\t\t\tf++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(f >= 2) Q.push(make_pair(q.first+abs(ll[0]-ll[1]),i));\n\t\t\t}\n\t\t}\n\t\tcout << \"impossible\" << endl;\n\t\t\n\t\texit:;\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(arg),key)-begin(arg)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n\nusing namespace std;\n\ntemplate<class T>void reg(vector<T> &ary,const T &elem){ary.emplace_back(elem);}\ntemplate<class T>bool chmin(T &a, const T &b) {return (b<a)?(a=b,1):0;}\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\n\nusing R=long double; // __float128\nconst R EPS = 1E-11; // [-1000:1000]->EPS=1e-8 [-10000:10000]->EPS=1e-7\nconst R INF = 1E40;\nconstexpr R PI = acos(R(-1));\ninline int sgn(const R& r){ return (r > EPS) - (r < -EPS);}\ninline int sgn(const R& a, const R &b){ return sgn(a-b); }\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n\nusing P=complex<R>;\nusing VP=vector<P>;\nusing L=struct{P s,t;};\nusing VL=vector<L>;\nusing C=struct{P c;R r;};\nusing VC=vector<C>;\n\nconstexpr P O = P(0,0);\nistream& operator >> (istream& is,P& p){ R x,y;is >> x >> y; p=P(x,y); return is;}\nostream& operator << (ostream& os,P& p){ os << real(p) << \" \" << imag(p); return os;}\n\nnamespace std{\n\tbool operator <  (const P& a,const P& b){ return sgn(real(a-b))?real(a-b)<0:sgn(imag(a-b))<0;}\n\tbool operator == (const P& a,const P& b){ return sgn(real(a-b))==0 && sgn(imag(a-b))==0;}\n}\n\nbool operator <  (const L& a,const L& b){ return a.s==b.s?a.t<b.t:a.s<b.s;}\nbool operator == (const L& a,const L& b){ return a.s==b.s&&a.t==b.t;}\n\n//?????? dot ?????? det\ninline R dot(P o,P a,P b){a-=o,b-=o; return real(conj(a)*b);}\ninline R det(P o,P a,P b){a-=o,b-=o; return imag(conj(a)*b);}\n\n// CCW verify AOJ CGL_1_C\nenum CCW{ LEFT = 1,RIGHT = 2,BACK = 4,FRONT = 8,ON = 16};\ninline int ccw(P o,P a, P b) {//???a??¨???b???????????????????????????\n\tif (sgn(det(o,a,b)) > 0) return LEFT;    // counter clockwise\n\tif (sgn(det(o,a,b)) < 0) return RIGHT;   // clockwise\n\tif (sgn(dot(o,a,b)) < 0) return BACK;    // b--base--a on line\n\tif (sgn(norm(a-o)-norm(b-o)) < 0) return FRONT;   // base--a--b on line\n\treturn ON;// base--b--a on line  a??¨b????????????????????????\n}\n\n// ?????´ ?????? verify AOJ CGL_2_A\nbool vertical(L a, L b) {return sgn(dot(O,a.t-a.s,b.t-b.s))==0;}\nbool parallel(L a, L b) {return sgn(det(O,a.t-a.s,b.t-b.s))==0;}\nbool eql(L a,L b){ return (parallel(a,b) && sgn(det(a.s,a.t,b.s))==0);}\n\n\n// ???????????????verify AOJ CGL_2_B ???????????????????????´??????1,????????´??????0\nbool iss(L a,L b,int end=0){\n\tint s1=ccw(a.s,a.t,b.s)|ccw(a.s,a.t,b.t);\n\tint s2=ccw(b.s,b.t,a.s)|ccw(b.s,b.t,a.t);\n\tif(end) return (s1&s2)==(LEFT|RIGHT);\n\treturn (s1|s2)&ON || (s1&s2)==(LEFT|RIGHT);\n}\n\n// ?????? verify AOJ CGL_2_C\nP cross(L a,L b){\n\tR s1=det(a.s,b.s,b.t);\n\tR s2=s1+det(a.t,b.t,b.s);\n\treturn a.s+s1/s2*(a.t-a.s);\n}\n\t\n// ???????????? verify AOJ CGL_4_C\nVP convex_cut(const VP& pol,const L& l) {\n\tVP res;\n\tint n=pol.size();\n\trep(i,n){\n\t\tP a = pol[i],b=pol[(i+1)%n];\n\t\tif(ccw(l.s,l.t,a)!=RIGHT) reg(res,a);\n\t\tif((ccw(l.s,l.t,a)|ccw(l.s,l.t,b))==(LEFT|RIGHT)) reg(res,cross({a,b},l));\n\t}\n\treturn res;\n}\n\nconst int vmax=10010;\nstruct node{int to;R cost;};\nvector<node> graph[vmax];\ninline void add_edge(int f,int t,R c){reg(graph[f],{t,c}),reg(graph[t],{f,c});}\n\nvoid segment_arrangement(const vector<L> &seg, vector<P> &point){\n\trep(i,vmax) graph[i].clear();\n\trep(i,seg.size()){\n\t\treg(point,seg[i].s),reg(point,seg[i].t);\n\t\trep(j,i) if(iss(seg[i],seg[j])) reg(point,cross(seg[i],seg[j]));\n\t}\n\tuniq(point);\n\trep(i,seg.size()){\n\t\tvector<pair<R,int>> idx;\n\t\trep(j,point.size()) if(ccw(seg[i].s,seg[i].t,point[j])==ON) reg(idx,{norm(point[j]-seg[i].s),j});\n\t\tsort(_all(idx));\n\t\trep(j,1,int(idx.size())){\n\t\t\tint a=idx[j-1].second,b=idx[j].second;\n\t\t\tadd_edge(a,b,abs(point[a]-point[b]));\n\t\t}\n\t}\n}\n\nL bisector(P a, P b){P mid=(a+b)/P(2,0);return L{mid, mid+(b-a)*P(0,1)};}\nVP voronoi_cell(VP pol,VP v,int s){rep(i,v.size())if(i!=s)pol=convex_cut(pol,bisector(v[s],v[i]));return pol;}\n\nR dist[vmax];\nR dijkstra(const VP &point){\n\tfill(dist,dist+vmax,INF);\n\tusing state=tuple<R,int>;\n\tpriority_queue<state,vector<state>,greater<state>> q;\n\trep(s,point.size()) if(sgn(real(point[s]))==0) dist[s]=0,q.push(state(0,s));\n\twhile(!q.empty()){\n\t\tR c;int v;\n\t\ttie(c,v)=q.top();q.pop();\n\t\tfor(auto &e:graph[v]){\n\t\t\tR nc=c+e.cost; int nv=e.to;\n\t\t\tif(chmin(dist[nv],nc)) q.push(state(nc,nv));\n\t\t}\n\t}\n\tR res=INF;\n\trep(t,point.size()) if(sgn(real(point[t])-4.0)==0) chmin(res,dist[t]);\n\treturn res;\n}\n\n\nint main(void){\n\tint n;\n\twhile(cin >> n,n){\n\t\tVP pol={P(0,0),P(4,0),P(4,4),P(0,4)};\n\t\tVP vornoi,point;\n\t\tVL seg;\n\t\trep(i,n){\n\t\t\tP p;\n\t\t\tcin >> p;\n\t\t\treg(vornoi,p);\n\t\t}\n\t\trep(i,n){\n\t\t\tVP res=voronoi_cell(pol,vornoi,i);\n\t\t\tfor(auto &p:res) reg(point,p);\n\t\t\tint m=res.size();\n\t\t\trep(i,m){\n\t\t\t\tL l={res[i],res[(i+1)%m]};\n\t\t\t\tbool ok=true;\n\t\t\t\trep(i,4) if(eql(l,{pol[i],pol[(i+1)%4]})) ok=false;\n\t\t\t\tif(ok) reg(seg,l);\n\t\t\t}\n\t\t}\n\t\t// seg=segment_merge(seg);\n\t\tcerr << \"merge\" << endl;\n\t\t\n\t\tsegment_arrangement(seg,point);\n\t\tR res=dijkstra(point);\n\t\tcout.precision(20);\n\t\tcerr << \"finished\" << endl;\n\t\tif(res>=INF)\n\t\t\tcout << \"impossible\" << endl;\n\t\telse\n\t\t\tcout << fixed << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define EPS (1e-8)\n#define INF (1e100)\n#define lt(a, b) (a - b < -EPS)\n#define equals(a, b) (fabs(a - b) < EPS)\n\nstruct Point {\n    double x, y;\n\n    Point () {}\n    Point (double x, double y) : x(x), y(y) {}\n\n    Point operator + (const Point &p) const {\n        return Point(x + p.x, y + p.y);\n    }\n    \n    Point operator - (const Point &p) const {\n        return Point(x - p.x, y - p.y);\n    }\n    \n    Point operator * (const double &k) const {\n        return Point(x * k, y * k);\n    }\n\n    bool operator == (const Point &p) const {\n        return (equals(x, p.x) && equals(y, p.y));\n    }    \n    \n    bool operator < (const Point &p) const {\n        if (!equals(x, p.x)) {\n            return lt(x, p.x);\n        } else {\n            return lt(y, p.y);\n        }\n    }\n};\n\ndouble dot(const Point &a, const Point &b)\n{\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(const Point &a, const Point &b)\n{\n    return a.x * b.y - b.x * a.y;\n}\n\ndouble norm(const Point &p)\n{\n    return dot(p, p);\n}\n\ndouble abs(const Point &p)\n{\n    return sqrt(norm(p));\n}\n\ndouble dist(const Point &a, const Point &b)\n{\n    return sqrt(pow(a.x - b.x, 2) + pow(a.y - b.y, 2));\n}\n\n#define COUNTER_CLOCKWISE +1\n#define CLOCKWISE         -1\n#define ONLINE_BACK       +2\n#define ONLINE_FRONT      -2\n#define ON_SEGMENT        +0\ntypedef Point Vector;\n\nint ccw(const Point &p0, const Point &p1, const Point &p2)\n{\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if (cross(a, b) > EPS)  return COUNTER_CLOCKWISE;\n    if (cross(a, b) < -EPS) return CLOCKWISE;\n    if (dot(a, b) < -EPS)   return ONLINE_BACK;\n    if (norm(a) < norm(b))  return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nstruct Segment {\n    Point s, t;\n    Segment(){}\n    Segment(Point s, Point t) : s(s), t(t) {}\n};\n\ntypedef Segment Line;\n\nLine perpendicular_bisector(const Point &a, const Point &b)\n{\n    double cx = (a.x + b.x) / 2.0;\n    double cy = (a.y + b.y) / 2.0;\n    Point p = Point(cx + (a.y - b.y), cy + (b.x - a.x));\n    return Line(Point(cx, cy), p);\n}\n\nPoint crosspointLL(const Line &a, const Line &b)\n{\n    Vector va = a.t - a.s, vb = b.t - b.s;\n    double d = cross(vb, va);\n    if (abs(d) < EPS) return b.s;\n    return a.s + va * cross(vb, b.t - a.s) * (1.0 / d);\n}\n\n#define curr(G, i) (G[i % G.size()])\n#define next(G, i) (G[(i + 1) % G.size()])\ntypedef vector<Point> Polygon;\n\nPolygon convex_cut(const Polygon &pg, const Line &l)\n{\n    Polygon res;\n    for (int i = 0; i < (int)pg.size(); i++) {\n        Point cp = curr(pg, i), np = next(pg, i);\n        if (ccw(l.s, l.t, cp) != -1) res.push_back(cp);\n        if (ccw(l.s, l.t, cp) * ccw(l.s, l.t, np) < 0) {\n            res.push_back(crosspointLL(Line(cp, np), l));\n        }\n    }\n    return res;\n}\n\nbool check(Point a, Point b)\n{\n    if (lt(b.x, a.x)) swap(a, b);\n    if (equals(a.x, b.x) && lt(b.y, a.y)) swap(a, b);\n    if (a == Point(0, 0) && b == Point(0, 4)) return 1;\n    if (a == Point(0, 0) && b == Point(4, 0)) return 1;\n    if (a == Point(0, 4) && b == Point(4, 4)) return 1;\n    if (a == Point(4, 0) && b == Point(4, 4)) return 1;\n    return 0;\n}\n\nvector<Segment> make_segments(vector<Point> &ps)\n{\n    Polygon pg(4);\n    pg[0] = Point(0, 0);\n    pg[1] = Point(0, 4);\n    pg[2] = Point(4, 4);\n    pg[3] = Point(4, 0);\n\n    vector<Segment> segs;\n    \n    int N = ps.size();\n    for (int i = 0; i < N; i++) {\n        Polygon p = pg;\n        for (int j = 0; j < N; j++) {\n            if (i == j) continue;\n            p = convex_cut(p, perpendicular_bisector(ps[i], ps[j]));\n        }\n        int M = p.size();\n        for (int j = 0; j < M; j++) {\n            if (check(curr(p, j), next(p, j))) continue;            \n            segs.push_back(Segment(curr(p, j), next(p, j)));\n        }\n    }\n    return segs;\n}\n\nstruct Edge {\n    int to;\n    double cost;\n    Edge (int to, double cost) : to(to), cost(cost) {}\n    bool operator < (const Edge &e) const {\n        return cost < e.cost;\n    }\n};\n\ntypedef vector<vector<Edge>> Graph;\n\nbool isIntersectSS(const Segment &a, const Segment &b)\n{\n    Point s[2] = {a.s, a.t}, t[2] = {b.s, b.t};\n    return (ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n\t    ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0);\n}\n\nbool isIntersectSP(const Segment &s, const Point &p)\n{\n    return (ccw(s.s, s.t, p) == 0);\n}\n\nPoint crosspointSS(const Segment &a, const Segment &b)\n{\n    Vector va = a.t - a.s, vb = b.t - b.s;\n    double d = cross(vb, va);\n    return a.s + va * cross(vb, b.t - a.s) * (1.0 / d);\n}\n\nGraph segment_arrangement(vector<Segment> &segs, vector<Point> &ps)\n{\n    Graph G;\n    int N = segs.size();\n    ps.clear();\n\n    for (int i = 0; i < N; i++) {\n\tps.push_back(segs[i].s);\n\tps.push_back(segs[i].t);\n\tfor (int j = i+1; j < N; j++) {\n\t    Vector a = segs[i].t - segs[i].s;\n\t    Vector b = segs[j].t - segs[j].s;\n\t    if (equals(cross(a, b), 0)) continue;            \n\t    if (isIntersectSS(segs[i], segs[j])) {\n\t\tps.push_back(crosspointSS(segs[i], segs[j]));\n\t    }\n\t}\n    }\n    sort(ps.begin(), ps.end());\n    ps.erase(unique(ps.begin(), ps.end()), ps.end());\n\n    int N2 = ps.size();\n    G.resize(N2);\n    for (int i = 0; i < N; i++) {\n\tvector<pair<double,int>> vec;\n\tfor (int j = 0; j < N2; j++) {\n\t    if (isIntersectSP(segs[i], ps[j])) {\n\t\tdouble d = dist(segs[i].s, ps[j]);\n\t\tvec.push_back(make_pair(d, j));\n\t    }\n\t}\n\tsort(vec.begin(), vec.end());\n\tfor (int j = 0; j < (int)vec.size()-1; j++) {\n\t    int u = vec[j].second, v = vec[j+1].second;\n\t    double d = dist(ps[u], ps[v]);\n\t    G[u].push_back(Edge(v, d));\n\t    G[v].push_back(Edge(u, d));\n\t}\n    }\n    return G;\n}\n\ndouble solve(vector<Point> &ps)\n{\n    vector<Segment> v = make_segments(ps);\n    vector<Point> p;\n    Graph G = segment_arrangement(v, p);\n\n    int N = p.size();    \n    vector<vector<double>> d(N, vector<double>(N, INF));\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < (int)G[i].size(); j++) {\n            d[i][G[i][j].to] = G[i][j].cost;\n        }\n        d[i][i] = 0;\n    }\n\n    for (int k = 0; k < N; k++) {\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n            }\n        }\n    }\n\n    double res = INF;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (!check(p[i], p[j]) && equals(p[i].x, 0) && equals(p[j].x, 4)) {\n                res = min(res, d[i][j]);\n            }\n        }\n    }    \n    return res;\n}\n\nint main()\n{\n    int n;\n    while (cin >> n, n) {\n        vector<Point> ps(n);\n        for (int i = 0; i < n; i++) {\n            cin >> ps[i].x >> ps[i].y;\n        }\n        double res = solve(ps);\n        if (n == 1 || res == INF) {\n            puts(\"impossible\");\n        } else {\n            printf(\"%.15f\\n\", res);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<vector>\n#include<iostream>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<cmath>\n\n#define START_X 0.0\n#define GOAL_X 4.0\n\n#define FRONT 0x01\n#define RIGHT 0x02\n#define BACK 0x04\n#define LEFT 0x08\n#define OVER 0x10\n\n#define sc second\n#define fr first\n\n#define REP(i,n) for(int i = 0; i < (int)(n); ++i)\n\nusing namespace std;\n\ntypedef double elem;\ntypedef complex<elem> point, vec;\ntypedef pair<point, point> line, hline, seg, pp;\n\nconst double eps = 1.0e-8;\nconst double pi = acos(-1.0);\nconst double infty = 1e40;\npoint base(0,0),origin(0,0);\n\nbool eq(elem a, elem b){ return abs(a-b) < eps; }\nbool lt(elem a, elem b){ return !eq(a,b) && a < b; }\nbool leq(elem a, elem b){ return eq(a,b) || a < b; }\nbool gt(elem a, elem b){ return !eq(a,b) && a > b; }\nbool geq(elem a, elem b){ return eq(a,b) || a > b; }\nbool ltz(elem a){ return lt( a, 0 ); }\nbool gtz(elem a){ return gt( a, 0 ); }\nbool eqv(vec a, vec b){ return eq( abs(b-a),0); }\nbool is_zv(vec v){ return eq(abs(v),0); }\nelem emax(elem a, elem b){ return gt(a,b)?a:b; }\nelem emin(elem a, elem b){ return lt(a,b)?a:b; }\n\nbool far(point a, point b){ return gtz( abs(b-a) ); }\nbool near(point a, point b){ return leq( abs(b-a), 0 ); }\nelem dot(vec a, vec b){ return (a.real() * b.real() + a.imag() * b.imag() ); }\nelem cross(vec a, vec b){ return ( a.real() * b.imag() - a.imag() * b.real() ); }\n\nelem dist(point a, point b){ return abs(a-b); }\nelem dist_l(line l, point x){ return abs(cross(l.sc-l.fr,x-l.fr)) / abs(l.sc-l.fr); }\nelem dist_seg(seg s, point x)\n{\n  if( ltz( dot(s.sc-s.fr,x-s.fr) ) ) return abs(x-s.fr);\n  if( ltz( dot(s.fr-s.sc,x-s.sc) ) ) return abs(x-s.sc);\n  return dist_l(s,x);\n}\n\nvec uvec(vec a){ return a / abs(a); }\nvec nmr(vec a){ return a * vec(0,-1); }\nvec nml(vec a){ return a * vec(0,1); }\nvec unmr(vec a){ return uvec( nmr(a) ); }\nvec unml(vec a){ return uvec( nml(a) ); }\n\nbool orth(point a1, point a2, point b1, point b2){ return eq( dot( a2 - a1, b2 - b1 ), 0 ); }\nbool orth(vec v1, vec v2){ return eq( dot(v1, v2), 0 ); }\nbool prll(point a1, point a2, point b1, point b2){ return eq( cross( a2 - a1, b2 - b1 ), 0 ); }\nbool prll(vec v1, vec v2){ return eq( cross(v1, v2), 0 ); }\n\nint ccw(point a, point b, point x){\n  b -= a;\n  x -= a;\n  if( gtz( cross(b,x) ) ) return LEFT;\n  if( ltz( cross(b,x) ) ) return RIGHT;\n  if( ltz( dot(b,x) ) ) return BACK;\n  if( lt( abs(b), abs(x) ) ) return FRONT;\n  return OVER;\n}\n\nbool intersectedSS(seg a, seg b)\n{\n  if( ccw(a.fr,a.sc,b.fr)&OVER || ccw(a.fr,a.sc,b.sc)&OVER ) return true;\n  return\n    ( ccw(a.fr,a.sc,b.fr) | ccw(a.fr,a.sc,b.sc) ) == (LEFT|RIGHT) &&\n    ( ccw(b.fr,b.sc,a.fr) | ccw(b.fr,b.sc,a.sc) ) == (LEFT|RIGHT) ;\n}\n\nbool intersectedLL(line a, line b){ return !eq( cross(a.sc-a.fr,b.sc-b.fr), 0.0 ); }\n\npoint intersectionSS(seg a, seg b)\n{\n  elem d1 = dist_l(b,a.fr);\n  elem d2 = dist_l(b,a.sc);\n  return a.fr + ( d1 / (d1 + d2 ) ) * (a.sc-a.fr);\n}\npoint intersectionLL(line a, line b)\n{\n  vec va = a.sc - a.fr;\n  vec vb = b.sc - b.fr;\n  return a.fr + va * ( cross(vb, b.fr - a.fr) / cross(vb,va) );\n}\n\nbool intersectionLL(line a, line b, point &ret){\n  return intersectedLL( a, b ) ? ret = intersectionLL( a, b ), true : false;\n}\nbool intersectionLH(line a, hline b, point &ret){\n  point tmp;\n  return intersectionLL(a,b,tmp) ? ( ccw(b.fr,b.sc,tmp)&(OVER|FRONT) ? ret=tmp, true : false ) : false;\n}\nbool intersectionLS(line l, seg s, point &ret){\n  point tmp;\n  return intersectionLL(l,s,tmp) ? ( ccw(s.fr,s.sc,tmp)&OVER ? ret=tmp, true : false ) : false;\n}\nbool intersectionHH(hline a, hline b, point &ret){\n  point tmp;\n  return intersectionLL(a,b,tmp) ? ( ccw(a.fr,a.sc,tmp)&(OVER|FRONT)&&ccw(b.fr,b.sc,tmp)&(OVER|FRONT) ? ret = tmp, true : false ) : false;\n}\nbool intersectionHS(hline a, seg s, point &ret){\n  point tmp;\n  return intersectionLS(a,s,tmp) ? ( ccw(a.fr,a.sc,tmp)&(OVER|FRONT) ? ret = tmp, true : false ) : false;\n}\nbool intersectionSS(seg a, seg b, point &ret){\n  return intersectedSS(a,b) ? ret = intersectionSS(a,b), true : false;\n}\n\nbool convexCut(const vector<point> &vp,\n\t       line l,\n\t       vector<point> &left)\n{\n  int n = vp.size();\n  bool bFirst = true;\n  int indq1 = -1, indq2 = -1;\n  point q1, q2;\n  \n  for(int i = 0; i < n; ++i){\n    seg edge = make_pair( vp[i], vp[(i+1)%n] );\n    if( bFirst ){\n      if( intersectionLS( l, edge, q1 ) ){ bFirst = false; indq1 = (i+1)%n; }\n    }else{\n      if( intersectionLS( l, edge, q2 ) && far(q1,q2) ){ indq2 = (i+1)%n; break; }\n    }\n  }\n\n  if( indq1<0||indq2<0 ) return false;\n  if( lt( dist( q1, l.second ), dist( q2, l.second ) ) ){ swap( q1, q2 ); swap( indq1, indq2 ); }\n  if( far( q2, vp[indq2] ) ) left.push_back( q2 );\n  for(int i = indq2; i != indq1; i=(i+1>=n?0:i+1)) left.push_back( vp[i] );\n  if( far(q1, vp[(indq1-1+n)%n] ) ) left.push_back( q1 );\n\n  return true;\n}\n\nstruct Point{\n  point p;\n  Point():p(origin){}\n  Point(point p):p(p){}\n  bool operator < (const Point &t)const{\n    if(!eq(p.real(),t.p.real()))return lt(p.real(),t.p.real());\n    else return lt(p.imag(),t.p.imag());\n  }\n};\n\nstruct Node{\n  point p;\n  vector<int> con;\n  vector<double> cost;\n};\n\ntypedef vector<Node> Graph;\n\nstruct VolLine{\n  line l;\n  VolLine():l(origin,origin){}\n  VolLine(line l):l(l){}\n  int point_id[2]; // volonoi points id with touching with this line.\n};\n\nline expandLine(line l, elem mag){\n  line ret = l;\n  vec vf(l.first - l.second);\n  vec vs(l.second - l.first);\n  ret.first = l.second + mag * vf;\n  ret.second = l.first + mag * vs;\n  return ret;\n}\n\nvoid MakeVolonoi(const vector<point> &vp,\n\t\t const vector<point> &plane,\n\t\t vector< vector<point> > &out){\n  vector<point> tplane;\n  \n  for(int i = 0; i < vp.size(); ++i){\n    tplane = plane;\n    for(int j = 0; j < vp.size(); ++j){\n      if( i != j ){\n\tvector<point> newplane;\n\tpoint c = (vp[i]+vp[j])/2.;\n\tint cw = ccw( c, unmr(vp[i]-vp[j])+c, vp[i] );\n\tline bisec;\n\tif( cw == LEFT ){\n\t  bisec = line( c, unmr( vp[i]-vp[j] ) + c );\n\t}else{\n\t  bisec = line( c, unml( vp[i]-vp[j] ) + c );\n\t}\n\tbisec = expandLine( bisec, 20 ); // magnify segment for convex cut\n\tif( convexCut(tplane, bisec, newplane ) )\n\t  tplane = newplane;\n      }\n    }\n    out.push_back( tplane );\n  }\n};\n\nstruct State{\n  int now;\n  elem cost;\n  State(){}\n  bool operator<(const State &t)const{\n    return lt(cost,t.cost);\n  }\n};\n\nelem dijkstra(Graph &G, int sid){\n  elem ret = infty;\n  priority_queue<State> qs;\n  State init;\n  bool vis[G.size()];\n  elem A[G.size()];\n  for(int i = 0; i < G.size(); ++i){\n    vis[i]=false;\n    A[i]=infty;\n  }\n  init.now = sid;\n  init.cost = 0.0;\n  qs.push(init);\n  A[sid]=0.0;\n  while(!qs.empty()){\n    State st_now = qs.top(); qs.pop();\n    int nid = st_now.now;\n    if(vis[nid])continue;\n    else vis[nid]=true;\n    for(int i = 0; i < G[nid].con.size(); ++i){\n      State next;\n      next.now = G[nid].con[i];\n      //cout << next.now << endl;\n      next.cost = st_now.cost + G[nid].cost[i];\n      if( lt(next.cost, A[next.now]) ){\n\tA[next.now] = next.cost;\n\tif( !vis[next.now] ){\n\t  qs.push( next );\n\t}\n      }\n    }\n  }\n  for(int i = 0; i < G.size(); ++i){\n    if( eq(G[i].p.real(),GOAL_X) ){\n      ret = emin( ret, A[i] );\n    }\n  }\n  return ret;\n}\n\nint main()\n{\n  while(true){\n    int n;\n    elem ans=infty;\n    map<Point,int> point_id;\n    vector<point> vp,plane;\n    vector< vector<point> > volonoi;\n\n    cin >> n;\n    if( n == 0 ) break;\n    for(int i = 0; i < n; ++i){\n      elem x,y;\n      cin >> x >> y;\n      vp.push_back( point(x,y) );\n    }\n    if( n == 1 ){\n      puts(\"impossible\");\n      continue;\n    }\n    plane.push_back( point(0.0,0.0) );\n    plane.push_back( point(4.0,0.0) );\n    plane.push_back( point(4.0,4.0) );\n    plane.push_back( point(0.0,4.0) );\n    MakeVolonoi( vp, plane, volonoi );\n\n    /* debug \n    for(int i = 0; i < volonoi.size(); ++i){\n      cout << \"//\" << i << \" master point : \" << vp[i] << endl;\n      for(int j = 0; j < volonoi[i].size(); ++j){\n\tpoint lf=volonoi[i][j];\n\tpoint ls=volonoi[i][(j+1)%volonoi[i].size()];\n\n\tcout << \"line(\" << lf.real() <<\",\" << lf.imag() <<\",\" << ls.real() <<\",\"<<ls.imag() << \");\" << endl;\n      }\n    }\n    cout << endl;\n    */\n\n    int now = 0;\n    for(int i = 0; i < volonoi.size(); ++i){\n      for(int j = 0; j < volonoi[i].size(); ++j){\n\tPoint pp(volonoi[i][j]);\n\tif( point_id.find( pp ) == point_id.end() ){\n\t  point_id[pp] = now;\n\t  ++now;\n\t}\n      }\n    }\n    Graph G(now);\n\n    // Graph Construction\n    for(int i = 0; i < volonoi.size(); ++i){\n      int ni = volonoi[i].size();\n      for(int j = 0; j < ni; ++j){\n\tpoint p = volonoi[i][j];\n\tpoint np = volonoi[i][(j+1)%ni];\n\telem ck = ((p+np)/2.).imag();\n\telem ckx = ((p+np)/2.).real();\n\tif( eq(ckx,0.0)||eq(ckx,4.0)||eq(ck,0.0)||eq(ck,4.0) ) continue;\n\tint ip = point_id[Point(p)];\n\tint inp = point_id[Point(np)];\n\telem d = dist( p, np );\n\tG[ ip ].p = p;\n\tG[ inp ].p = np;\n\tG[ ip ].con.push_back( inp );\n\tG[ ip ].cost.push_back( d );\n\tG[ inp ].con.push_back( ip );\n\tG[ inp ].cost.push_back( d );\n      }\n    }\n\n    for(int i = 0; i < G.size(); ++i){\n      if( eq( G[i].p.real(), START_X ) ){\n\tans = emin( ans, dijkstra( G, i ) );\n      }\n    }\n\n    if(geq(ans,infty))puts(\"impossible\");\n    else printf(\"%.12lf\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst double EPS = 1e-8, PI = acos(-1);\n\ninline bool eq(double a, double b) { return abs(b - a) < EPS; }\n\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define prev(P, i) P[(i+P.size()-1) % P.size()]\n\nenum\n{\n  OUT, ON, IN\n};\nnamespace Geometory\n{\n  struct Point\n  {\n    double x, y;\n\n    Point() {};\n\n    Point(double x, double y) : x(x), y(y) {};\n\n    Point operator+(const Point &b) const { return Point(x + b.x, y + b.y); }\n\n    Point operator-(const Point &b) const { return Point(x - b.x, y - b.y); }\n\n    Point operator*(const double b) const { return Point(x * b, y * b); }\n\n    Point operator*(const Point &b) const { return Point(x * b.x - y * b.y, x * b.y + y * b.x); }\n\n    Point operator/(const double b) const { return Point(x / b, y / b); }\n\n    bool operator<(const Point &b) const { return x != b.x ? x < b.x : y < b.y; }\n\n    bool operator==(const Point &b) const { return eq(x, b.x) && eq(y, b.y); }\n\n    double norm() { return x * x + y * y; }\n\n    double arg() { return atan2(x, y); }\n\n    double abs() { return sqrt(norm()); }\n\n    Point rotate(double theta) { return Point(cos(theta) * x - sin(theta) * y, sin(theta) * x + cos(theta) * y); }\n\n    Point rotate90() { return Point(-y, x); }\n\n    friend ostream &operator<<(ostream &os, Point &p) { return os << \"(\" << p.x << \",\" << p.y << \")\"; }\n\n    friend istream &operator>>(istream &is, Point &a) { return is >> a.x >> a.y; }\n  };\n\n  struct Line\n  {\n    Point a, b;\n\n    Line() {};\n\n    Line(Point a, Point b) : a(a), b(b) {};\n\n    friend ostream &operator<<(ostream &os, Line &p) { return os << \"(\" << p.a.x << \",\" << p.a.y << \") to (\" << p.b.x << \",\" << p.b.y << \")\"; }\n\n    friend istream &operator>>(istream &is, Line &a) { return is >> a.a.x >> a.a.y >> a.b.x >> a.b.y; }\n  };\n\n  struct Segment\n  {\n    Point a, b;\n\n    Segment() {};\n\n    Segment(Point a, Point b) : a(a), b(b) {};\n\n    friend ostream &operator<<(ostream &os, Segment &p) { return os << \"(\" << p.a.x << \",\" << p.a.y << \") to (\" << p.b.x << \",\" << p.b.y << \")\"; }\n\n    friend istream &operator>>(istream &is, Segment &a) { return is >> a.a.x >> a.a.y >> a.b.x >> a.b.y; }\n  };\n\n  typedef vector< Point > Polygon;\n  typedef vector< Segment > Segments;\n\n  double cross(const Point &a, const Point &b)\n  {\n    return a.x * b.y - a.y * b.x;\n  }\n\n  double dot(const Point &a, const Point &b)\n  {\n    return a.x * b.x + a.y * b.y;\n  }\n\n  int ccw(const Point &a, Point b, Point c)\n  {\n    b = b - a, c = c - a;\n    if(cross(b, c) > EPS) return +1;\n    if(cross(b, c) < -EPS) return -1;\n    if(dot(b, c) < 0) return +2;\n    if(b.norm() < c.norm()) return -2;\n    return 0;\n  }\n\n  Point Crosspoint(const Line &l, const Line &m)\n  {\n    double A = cross(l.b - l.a, m.b - m.a);\n    double B = cross(l.b - l.a, l.b - m.a);\n    if(abs(A) < EPS && abs(B) < EPS) return m.a;\n    return m.a + (m.b - m.a) * B / A;\n  }\n\n  Line Bisector(Point a, Point b)\n  {\n    Point c = (a + b) * 0.5;\n    Point p = Point(c.x + (a.y - b.y), c.y + (b.x - a.x));\n    return (Line(c, p));\n  }\n\n  Polygon Convex_Cut(Polygon &U, Line l)\n  {\n    Polygon ret;\n    for(int i = 0; i < U.size(); i++) {\n      Point now = curr(U, i), nxt = next(U, i);\n      if(ccw(l.a, l.b, now) != -1) ret.push_back(now);\n      if(ccw(l.a, l.b, now) * ccw(l.a, l.b, nxt) < 0) {\n        ret.push_back(Crosspoint(Line(now, nxt), l));\n      }\n    }\n    return (ret);\n  }\n};\n\ntypedef pair< double, int > Pi;\nstruct edge\n{\n  int to;\n  double cost;\n};\ntypedef vector< vector< edge > > Graph;\nconst double INF = 1e9;\n\ndouble Dijkstra(Graph &graph, int s, int g)\n{\n  vector< double > min_cost(graph.size(), INF);\n  priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n  que.push(make_pair(0, s));\n  min_cost[s] = 0;\n  while(!que.empty()) {\n    int now = que.top().second;\n    double cost = que.top().first;\n    que.pop();\n    if(now == g) return (cost);\n    if(cost > min_cost[now]) continue;\n    for(auto &e : graph[now]) {\n      if(cost + e.cost < min_cost[e.to]) {\n        min_cost[e.to] = cost + e.cost;\n        que.push(make_pair(min_cost[e.to], e.to));\n      }\n    }\n  }\n  return (-1);\n}\n\n\nint main()\n{\n  int N;\n  while(cin >> N, N) {\n    vector< Geometory::Point > points(N);\n    Geometory::Polygon U(4);\n    U[0] = Geometory::Point(0, 0);\n    U[1] = Geometory::Point(4, 0);\n    U[2] = Geometory::Point(4, 4);\n    U[3] = Geometory::Point(0, 4);\n\n    for(int i = 0; i < N; i++) {\n      cin >> points[i];\n    }\n\n    vector< Geometory::Polygon > voronoi(N);\n    for(int i = 0; i < N; i++) {\n      voronoi[i] = U;\n      for(int j = 0; j < N; j++) {\n        if(i == j) continue;\n        voronoi[i] = Geometory::Convex_Cut(voronoi[i], Geometory::Bisector(points[i], points[j]));\n      }\n    }\n\n    vector< Geometory::Point > ventex;\n    for(int i = 0; i < N; i++) {\n      for(auto &point : voronoi[i]) ventex.push_back(point);\n    }\n    sort(begin(ventex), end(ventex));\n    ventex.erase(unique(begin(ventex), end(ventex)), end(ventex));\n\n    Graph g(ventex.size() + 2);\n    for(int i = 0; i < N; i++) {\n      for(int j = 0; j < voronoi[i].size(); j++) {\n        auto &pv = curr(voronoi[i], j), nw = next(voronoi[i], j);\n        int pp = lower_bound(begin(ventex), end(ventex), pv) - begin(ventex);\n        int qq = lower_bound(begin(ventex), end(ventex), nw) - begin(ventex);\n        double dist = (pv - nw).abs();\n        if(eq(pv.x, 0)) pp = ventex.size();\n        else if(eq(pv.x, 4)) pp = ventex.size() + 1;\n        if(eq(nw.x, 0)) qq = ventex.size();\n        else if(eq(nw.x, 4)) qq = ventex.size() + 1;\n        if(eq(pv.y, 0) && eq(nw.y, 0)) continue;\n        if(eq(pv.y, 4) && eq(nw.y, 4)) continue;\n        g[pp].push_back((edge) {qq, dist});\n        g[qq].push_back((edge) {pp, dist});\n      }\n    }\n    auto cost = Dijkstra(g, ventex.size(), ventex.size() + 1);\n    if(cost == -1) cout << \"impossible\" << endl;\n    else cout << fixed << setprecision(15) << cost << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define INF (1e55)\n#define lt(a, b) (a - b < -EPS)\n#define equals(a, b) (fabs(a - b) < EPS)\n\nstruct Point {\n    double x, y;\n\n    Point () {}\n    Point (double x, double y) : x(x), y(y) {}\n\n    Point operator + (const Point &p) const {\n        return Point(x + p.x, y + p.y);\n    }\n    \n    Point operator - (const Point &p) const {\n        return Point(x - p.x, y - p.y);\n    }\n    \n    Point operator * (const double &k) const {\n        return Point(x * k, y * k);\n    }\n\n    bool operator == (const Point &p) const {\n        return (equals(x, p.x) && equals(y, p.y));\n    }    \n    \n    bool operator < (const Point &p) const {\n        if (!equals(x, p.x)) {\n            return lt(x, p.x);\n        } else {\n            return lt(y, p.y);\n        }\n    }\n};\n\ndouble dot(const Point &a, const Point &b)\n{\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(const Point &a, const Point &b)\n{\n    return a.x * b.y - b.x * a.y;\n}\n\ndouble norm(const Point &p)\n{\n    return dot(p, p);\n}\n\ndouble abs(const Point &p)\n{\n    return sqrt(norm(p));\n}\n\ndouble dist(const Point &a, const Point &b)\n{\n    return sqrt(pow(a.x - b.x, 2) + pow(a.y - b.y, 2));\n}\n\n#define COUNTER_CLOCKWISE +1\n#define CLOCKWISE         -1\n#define ONLINE_BACK       +2\n#define ONLINE_FRONT      -2\n#define ON_SEGMENT        +0\ntypedef Point Vector;\n\nint ccw(const Point &p0, const Point &p1, const Point &p2)\n{\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if (cross(a, b) > EPS)  return COUNTER_CLOCKWISE;\n    if (cross(a, b) < -EPS) return CLOCKWISE;\n    if (dot(a, b) < -EPS)   return ONLINE_BACK;\n    if (norm(a) < norm(b))  return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nstruct Segment {\n    Point s, t;\n    Segment(){}\n    Segment(Point s, Point t) : s(s), t(t) {}\n};\n\ntypedef Segment Line;\n\nLine perpendicular_bisector(const Point &a, const Point &b)\n{\n    double cx = (a.x + b.x) / 2.0;\n    double cy = (a.y + b.y) / 2.0;\n    Point p = Point(cx + (a.y - b.y), cy + (b.x - a.x));\n    return Line(Point(cx, cy), p);\n}\n\nPoint crosspointLL(const Line &a, const Line &b)\n{\n    Vector va = a.t - a.s, vb = b.t - b.s;\n    double d = cross(vb, va);\n    if (abs(d) < EPS) return b.s;\n    return a.s + va * cross(vb, b.t - a.s) * (1.0 / d);\n}\n\n#define curr(G, i) (G[i % G.size()])\n#define next(G, i) (G[(i + 1) % G.size()])\ntypedef vector<Point> Polygon;\n\nPolygon convex_cut(const Polygon &pg, const Line &l)\n{\n    Polygon res;\n    for (int i = 0; i < (int)pg.size(); i++) {\n        Point cp = curr(pg, i), np = next(pg, i);\n        if (ccw(l.s, l.t, cp) != -1) res.push_back(cp);\n        if (ccw(l.s, l.t, cp) * ccw(l.s, l.t, np) < 0) {\n            res.push_back(crosspointLL(Line(cp, np), l));\n        }\n    }\n    return res;\n}\n\nbool check(Point a, Point b)\n{\n    if (lt(b.x, a.x)) swap(a, b);\n    if (equals(a.x, b.x) && lt(b.y, a.y)) swap(a, b);\n    if (equals(a.x, 0) && equals(b.x, 0)) return 1;\n    if (equals(a.y, 0) && equals(b.y, 0)) return 1;\n    if (equals(a.x, 4) && equals(b.x, 4)) return 1;\n    if (equals(a.y, 4) && equals(b.y, 4)) return 1;\n    return 0;\n}\n\nvector<Segment> make_segments(vector<Point> &ps)\n{\n    Polygon pg(4);\n    pg[0] = Point(0, 0);\n    pg[1] = Point(0, 4);\n    pg[2] = Point(4, 4);\n    pg[3] = Point(4, 0);\n\n    vector<Segment> segs;\n    \n    int N = ps.size();\n    for (int i = 0; i < N; i++) {\n        Polygon p = pg;\n        for (int j = 0; j < N; j++) {\n            if (i == j) continue;\n            p = convex_cut(p, perpendicular_bisector(ps[i], ps[j]));\n        }\n        int M = p.size();\n        for (int j = 0; j < M; j++) {\n            if (check(curr(p, j), next(p, j))) continue;            \n            segs.push_back(Segment(curr(p, j), next(p, j)));\n        }\n    }\n    return segs;\n}\n\nstruct Edge {\n    int to;\n    double cost;\n    Edge (int to, double cost) : to(to), cost(cost) {}\n    bool operator < (const Edge &e) const {\n        return cost < e.cost;\n    }\n};\n\ntypedef vector<vector<Edge>> Graph;\n\nbool isIntersectSS(const Segment &a, const Segment &b)\n{\n    Point s[2] = {a.s, a.t}, t[2] = {b.s, b.t};\n    return (ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n\t    ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0);\n}\n\nbool isIntersectSP(const Segment &s, const Point &p)\n{\n    return (ccw(s.s, s.t, p) == 0);\n}\n\nPoint crosspointSS(const Segment &a, const Segment &b)\n{\n    Vector va = a.t - a.s, vb = b.t - b.s;\n    double d = cross(vb, va);\n    return a.s + va * cross(vb, b.t - a.s) * (1.0 / d);\n}\n\nGraph segment_arrangement(vector<Segment> &segs, vector<Point> &ps)\n{\n    Graph G;\n    int N = segs.size();\n    ps.clear();\n\n    for (int i = 0; i < N; i++) {\n\tps.push_back(segs[i].s);\n\tps.push_back(segs[i].t);\n\tfor (int j = i+1; j < N; j++) {\n\t    Vector a = segs[i].t - segs[i].s;\n\t    Vector b = segs[j].t - segs[j].s;\n\t    if (equals(cross(a, b), 0)) continue;            \n\t    if (isIntersectSS(segs[i], segs[j])) {\n\t\tps.push_back(crosspointSS(segs[i], segs[j]));\n\t    }\n\t}\n    }\n    sort(ps.begin(), ps.end());\n    ps.erase(unique(ps.begin(), ps.end()), ps.end());\n\n    int N2 = ps.size();\n    G.resize(N2);\n    for (int i = 0; i < N; i++) {\n\tvector<pair<double,int>> vec;\n\tfor (int j = 0; j < N2; j++) {\n\t    if (isIntersectSP(segs[i], ps[j])) {\n\t\tdouble d = dist(segs[i].s, ps[j]);\n\t\tvec.push_back(make_pair(d, j));\n\t    }\n\t}\n\tsort(vec.begin(), vec.end());\n\tfor (int j = 0; j < (int)vec.size()-1; j++) {\n\t    int u = vec[j].second, v = vec[j+1].second;\n\t    double d = dist(ps[u], ps[v]);\n\t    G[u].push_back(Edge(v, d));\n\t    G[v].push_back(Edge(u, d));\n\t}\n    }\n    return G;\n}\n\ndouble solve(vector<Point> &ps)\n{\n    vector<Segment> v = make_segments(ps);\n    vector<Point> p;\n    Graph G = segment_arrangement(v, p);\n\n    int N = p.size();    \n    vector<vector<double>> d(N, vector<double>(N, INF));\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < (int)G[i].size(); j++) {\n            d[i][G[i][j].to] = G[i][j].cost;\n        }\n        d[i][i] = 0;\n    }\n\n    for (int k = 0; k < N; k++) {\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n            }\n        }\n    }\n\n    double res = INF;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (!check(p[i], p[j]) && equals(p[i].x, 0) && equals(p[j].x, 4)) {\n                res = min(res, d[i][j]);\n            }\n        }\n    }    \n    return res;\n}\n\nint main()\n{\n    int n;\n    while (cin >> n, n) {\n        vector<Point> ps(n);\n        for (int i = 0; i < n; i++) {\n            cin >> ps[i].x >> ps[i].y;\n        }\n        double res = solve(ps);\n        if (n == 1 || res == INF) {\n            puts(\"impossible\");\n        } else {\n            printf(\"%.15f\\n\", res);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define EPS (1e-8)\n#define INF (1e100)\n#define equals(a, b) (fabs(a - b) < EPS)\n\nstruct Point {\n    double x, y;\n\n    Point () {}\n    Point (double x, double y) : x(x), y(y) {}\n\n    Point operator + (const Point &p) const {\n        return Point(x + p.x, y + p.y);\n    }\n    \n    Point operator - (const Point &p) const {\n        return Point(x - p.x, y - p.y);\n    }\n    \n    Point operator * (const double &k) const {\n        return Point(x * k, y * k);\n    }\n\n    bool operator == (const Point &p) const {\n        return (equals(x, p.x) && equals(y, p.y));\n    }    \n    \n    bool operator < (const Point &p) const {\n        if (!equals(x, p.x)) {\n            return x < p.x;\n        } else {\n            return y < p.y;\n        }\n    }\n};\n\ndouble dot(const Point &a, const Point &b)\n{\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(const Point &a, const Point &b)\n{\n    return a.x * b.y - b.x * a.y;\n}\n\ndouble norm(const Point &p)\n{\n    return dot(p, p);\n}\n\ndouble abs(const Point &p)\n{\n    return sqrt(norm(p));\n}\n\ndouble dist(const Point &a, const Point &b)\n{\n    return sqrt(pow(a.x - b.x, 2) + pow(a.y - b.y, 2));\n}\n\n#define COUNTER_CLOCKWISE +1\n#define CLOCKWISE         -1\n#define ONLINE_BACK       +2\n#define ONLINE_FRONT      -2\n#define ON_SEGMENT        +0\ntypedef Point Vector;\n\nint ccw(const Point &p0, const Point &p1, const Point &p2)\n{\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if (cross(a, b) > EPS)  return COUNTER_CLOCKWISE;\n    if (cross(a, b) < -EPS) return CLOCKWISE;\n    if (dot(a, b) < -EPS)   return ONLINE_BACK;\n    if (norm(a) < norm(b))  return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nstruct Segment {\n    Point s, t;\n    Segment(){}\n    Segment(Point s, Point t) : s(s), t(t) {}\n};\n\ntypedef Segment Line;\n\nLine perpendicular_bisector(const Point &a, const Point &b)\n{\n    double cx = (a.x + b.x) / 2.0;\n    double cy = (a.y + b.y) / 2.0;\n    Point p = Point(cx + (a.y - b.y), cy + (b.x - a.x));\n    return Line(Point(cx, cy), p);\n}\n\nPoint crosspointLL(const Line &a, const Line &b)\n{\n    Vector va = a.t - a.s, vb = b.t - b.s;\n    double d = cross(vb, va);\n    if (abs(d) < EPS) return b.s;\n    return a.s + va * cross(vb, b.t - a.s) * (1.0 / d);\n}\n\n#define curr(G, i) (G[i % G.size()])\n#define next(G, i) (G[(i + 1) % G.size()])\ntypedef vector<Point> Polygon;\n\nPolygon convex_cut(const Polygon &pg, const Line &l)\n{\n    Polygon res;\n    for (int i = 0; i < (int)pg.size(); i++) {\n        Point cp = curr(pg, i), np = next(pg, i);\n        if (ccw(l.s, l.t, cp) != -1) res.push_back(cp);\n        if (ccw(l.s, l.t, cp) * ccw(l.s, l.t, np) < 0) {\n            res.push_back(crosspointLL(Line(cp, np), l));\n        }\n    }\n    return res;\n}\n\nbool check(Point a, Point b)\n{\n    if (a.x > b.x) swap(a, b);\n    if (equals(a.x, b.x) && a.y > b.y) swap(a, b);\n    if (a == Point(0, 0) && b == Point(0, 4)) return 1;\n    if (a == Point(0, 0) && b == Point(4, 0)) return 1;\n    if (a == Point(0, 4) && b == Point(4, 4)) return 1;\n    if (a == Point(4, 0) && b == Point(4, 4)) return 1;\n    return 0;\n}\n\nvector<Segment> make_segments(vector<Point> &ps)\n{\n    Polygon pg(4);\n    pg[0] = Point(0, 0);\n    pg[1] = Point(0, 4);\n    pg[2] = Point(4, 4);\n    pg[3] = Point(4, 0);\n\n    vector<Segment> segs;\n    \n    int N = ps.size();\n    for (int i = 0; i < N; i++) {\n        Polygon p = pg;\n        for (int j = 0; j < N; j++) {\n            if (i == j) continue;\n            p = convex_cut(p, perpendicular_bisector(ps[i], ps[j]));\n        }\n        int M = p.size();\n        for (int j = 0; j < M; j++) {\n            if (check(curr(p, j), next(p, j))) continue;            \n            segs.push_back(Segment(curr(p, j), next(p, j)));\n        }\n    }\n    return segs;\n}\n\nstruct Edge {\n    int to;\n    double cost;\n    Edge (int to, double cost) : to(to), cost(cost) {}\n    bool operator < (const Edge &e) const {\n        return cost < e.cost;\n    }\n};\n\ntypedef vector<vector<Edge>> Graph;\n\nbool isIntersectSS(const Segment &a, const Segment &b)\n{\n    Point s[2] = {a.s, a.t}, t[2] = {b.s, b.t};\n    return (ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n\t    ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0);\n}\n\nbool isIntersectSP(const Segment &s, const Point &p)\n{\n    return (ccw(s.s, s.t, p) == 0);\n}\n\nPoint crosspointSS(const Segment &a, const Segment &b)\n{\n    Vector va = a.t - a.s, vb = b.t - b.s;\n    double d = cross(vb, va);\n    return a.s + va * cross(vb, b.t - a.s) * (1.0 / d);\n}\n\nGraph segment_arrangement(vector<Segment> &segs, vector<Point> &ps)\n{\n    Graph G;\n    int N = segs.size();\n    ps.clear();\n\n    for (int i = 0; i < N; i++) {\n\tps.push_back(segs[i].s);\n\tps.push_back(segs[i].t);\n\tfor (int j = i+1; j < N; j++) {\n\t    Vector a = segs[i].t - segs[i].s;\n\t    Vector b = segs[j].t - segs[j].s;\n\t    if (equals(cross(a, b), 0)) continue;            \n\t    if (isIntersectSS(segs[i], segs[j])) {\n\t\tps.push_back(crosspointSS(segs[i], segs[j]));\n\t    }\n\t}\n    }\n    sort(ps.begin(), ps.end());\n    ps.erase(unique(ps.begin(), ps.end()), ps.end());\n\n    int N2 = ps.size();\n    G.resize(N2);\n    for (int i = 0; i < N; i++) {\n\tvector<pair<double,int>> vec;\n\tfor (int j = 0; j < N2; j++) {\n\t    if (isIntersectSP(segs[i], ps[j])) {\n\t\tdouble d = dist(segs[i].s, ps[j]);\n\t\tvec.push_back(make_pair(d, j));\n\t    }\n\t}\n\tsort(vec.begin(), vec.end());\n\tfor (int j = 0; j < (int)vec.size()-1; j++) {\n\t    int u = vec[j].second, v = vec[j+1].second;\n\t    double d = dist(ps[u], ps[v]);\n\t    G[u].push_back(Edge(v, d));\n\t    G[v].push_back(Edge(u, d));\n\t}\n    }\n    return G;\n}\n\ndouble solve(vector<Point> &ps)\n{\n    vector<Segment> v = make_segments(ps);\n    vector<Point> p;\n    Graph G = segment_arrangement(v, p);\n\n    int N = p.size();    \n    vector<vector<double>> d(N, vector<double>(N, INF));\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < (int)G[i].size(); j++) {\n            d[i][G[i][j].to] = G[i][j].cost;\n        }\n        d[i][i] = 0;\n    }\n\n    for (int k = 0; k < N; k++) {\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n            }\n        }\n    }\n\n    double res = INF;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (!check(p[i], p[j]) && equals(p[i].x, 0) && equals(p[j].x, 4)) {\n                res = min(res, d[i][j]);\n            }\n        }\n    }    \n    return res;\n}\n\nint main()\n{\n    int n;\n    while (cin >> n, n) {\n        vector<Point> ps(n);\n        for (int i = 0; i < n; i++) {\n            cin >> ps[i].x >> ps[i].y;\n        }\n        double res = solve(ps);\n        if (n == 1 || res == INF) {\n            puts(\"impossible\");\n        } else {\n            printf(\"%.15f\\n\", res);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define EPS (1e-8)\n#define INF (1e100)\n#define equals(a, b) (fabs(a - b) < EPS)\n\nstruct Point {\n    double x, y;\n\n    Point () {}\n    Point (double x, double y) : x(x), y(y) {}\n\n    Point operator + (const Point &p) const {\n        return Point(x + p.x, y + p.y);\n    }\n    \n    Point operator - (const Point &p) const {\n        return Point(x - p.x, y - p.y);\n    }\n    \n    Point operator * (const double &k) const {\n        return Point(x * k, y * k);\n    }\n\n    bool operator == (const Point &p) const {\n        return (equals(x, p.x) && equals(y, p.y));\n    }    \n    \n    bool operator < (const Point &p) const {\n        if (!equals(x, p.x)) {\n            return x < p.x;\n        } else {\n            return y < p.y;\n        }\n    }\n};\n\ndouble dot(const Point &a, const Point &b)\n{\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(const Point &a, const Point &b)\n{\n    return a.x * b.y - b.x * a.y;\n}\n\ndouble norm(const Point &p)\n{\n    return dot(p, p);\n}\n\ndouble abs(const Point &p)\n{\n    return sqrt(norm(p));\n}\n\ndouble dist(const Point &a, const Point &b)\n{\n    return sqrt(pow(a.x - b.x, 2) + pow(a.y - b.y, 2));\n}\n\n#define COUNTER_CLOCKWISE +1\n#define CLOCKWISE         -1\n#define ONLINE_BACK       +2\n#define ONLINE_FRONT      -2\n#define ON_SEGMENT        +0\ntypedef Point Vector;\n\nint ccw(const Point &p0, const Point &p1, const Point &p2)\n{\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if (cross(a, b) > EPS)  return COUNTER_CLOCKWISE;\n    if (cross(a, b) < -EPS) return CLOCKWISE;\n    if (dot(a, b) < -EPS)   return ONLINE_BACK;\n    if (norm(a) < norm(b))  return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nstruct Segment {\n    Point s, t;\n    Segment(){}\n    Segment(Point s, Point t) : s(s), t(t) {}\n};\n\ntypedef Segment Line;\n\nLine perpendicular_bisector(const Point &a, const Point &b)\n{\n    double cx = (a.x + b.x) / 2.0;\n    double cy = (a.y + b.y) / 2.0;\n    Point p = Point(cx + (a.y - b.y), cy + (b.x - a.x));\n    return Line(Point(cx, cy), p);\n}\n\nPoint crosspointLL(const Line &a, const Line &b)\n{\n    Vector va = a.t - a.s, vb = b.t - b.s;\n    double d = cross(vb, va);\n    if (abs(d) < EPS) return b.s;\n    return a.s + va * cross(vb, b.t - a.s) * (1.0 / d);\n}\n\n#define curr(G, i) (G[i % G.size()])\n#define next(G, i) (G[(i + 1) % G.size()])\ntypedef vector<Point> Polygon;\n\nPolygon convex_cut(const Polygon &pg, const Line &l)\n{\n    Polygon res;\n    for (int i = 0; i < (int)pg.size(); i++) {\n        Point cp = curr(pg, i), np = next(pg, i);\n        if (ccw(l.s, l.t, cp) != -1) res.push_back(cp);\n        if (ccw(l.s, l.t, cp) * ccw(l.s, l.t, np) < 0) {\n            res.push_back(crosspointLL(Line(cp, np), l));\n        }\n    }\n    return res;\n}\n\nbool check(Point a, Point b)\n{\n    if (a.x > b.x) swap(a, b);\n    if (a.x == b.x && a.y > b.y) swap(a, b);\n    if (a == Point(0, 0) && b == Point(0, 4)) return 1;\n    if (a == Point(0, 0) && b == Point(4, 0)) return 1;\n    if (a == Point(0, 4) && b == Point(4, 4)) return 1;\n    if (a == Point(4, 0) && b == Point(4, 4)) return 1;\n    return 0;\n}\n\nvector<Segment> make_segments(vector<Point> &ps)\n{\n    Polygon pg(4);\n    pg[0] = Point(0, 0);\n    pg[1] = Point(0, 4);\n    pg[2] = Point(4, 4);\n    pg[3] = Point(4, 0);\n\n    vector<Segment> segs;\n    \n    int N = ps.size();\n    for (int i = 0; i < N; i++) {\n        Polygon p = pg;\n        for (int j = 0; j < N; j++) {\n            if (i == j) continue;\n            p = convex_cut(p, perpendicular_bisector(ps[i], ps[j]));\n        }\n        int M = p.size();\n        for (int j = 0; j < M; j++) {\n            if (check(curr(p, j), next(p, j))) continue;            \n            segs.push_back(Segment(curr(p, j), next(p, j)));\n        }\n    }\n    return segs;\n}\n\nstruct Edge {\n    int to;\n    double cost;\n    Edge (int to, double cost) : to(to), cost(cost) {}\n    bool operator < (const Edge &e) const {\n        return cost < e.cost;\n    }\n};\n\ntypedef vector<vector<Edge>> Graph;\n\nbool isIntersectSS(const Segment &a, const Segment &b)\n{\n    Point s[2] = {a.s, a.t}, t[2] = {b.s, b.t};\n    return (ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n\t    ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0);\n}\n\nbool isIntersectSP(const Segment &s, const Point &p)\n{\n    return (ccw(s.s, s.t, p) == 0);\n}\n\nPoint crosspointSS(const Segment &a, const Segment &b)\n{\n    Vector va = a.t - a.s, vb = b.t - b.s;\n    double d = cross(vb, va);\n    return a.s + va * cross(vb, b.t - a.s) * (1.0 / d);\n}\n\nGraph segment_arrangement(vector<Segment> &segs, vector<Point> &ps)\n{\n    Graph G;\n    int N = segs.size();\n    ps.clear();\n\n    for (int i = 0; i < N; i++) {\n\tps.push_back(segs[i].s);\n\tps.push_back(segs[i].t);\n\tfor (int j = i+1; j < N; j++) {\n\t    Vector a = segs[i].t - segs[i].s;\n\t    Vector b = segs[j].t - segs[j].s;\n\t    if (equals(cross(a, b), 0)) continue;            \n\t    if (isIntersectSS(segs[i], segs[j])) {\n\t\tps.push_back(crosspointSS(segs[i], segs[j]));\n\t    }\n\t}\n    }\n    sort(ps.begin(), ps.end());\n    ps.erase(unique(ps.begin(), ps.end()), ps.end());\n\n    int N2 = ps.size();\n    G.resize(N2);\n    for (int i = 0; i < N; i++) {\n\tvector<pair<double,int>> vec;\n\tfor (int j = 0; j < N2; j++) {\n\t    if (isIntersectSP(segs[i], ps[j])) {\n\t\tdouble d = dist(segs[i].s, ps[j]);\n\t\tvec.push_back(make_pair(d, j));\n\t    }\n\t}\n\tsort(vec.begin(), vec.end());\n\tfor (int j = 0; j < (int)vec.size()-1; j++) {\n\t    int u = vec[j].second, v = vec[j+1].second;\n\t    double d = dist(ps[u], ps[v]);\n\t    G[u].push_back(Edge(v, d));\n\t    G[v].push_back(Edge(u, d));\n\t}\n    }\n    return G;\n}\n\ndouble solve(vector<Point> &ps)\n{\n    vector<Segment> v = make_segments(ps);\n    vector<Point> p;\n    Graph G = segment_arrangement(v, p);\n\n    int N = p.size();    \n    vector<vector<double>> d(N, vector<double>(N, INF));\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < (int)G[i].size(); j++) {\n            d[i][G[i][j].to] = G[i][j].cost;\n        }\n        d[i][i] = 0;\n    }\n\n    for (int k = 0; k < N; k++) {\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n            }\n        }\n    }\n\n    double res = INF;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (!check(p[i], p[j]) && equals(p[i].x, 0) && equals(p[j].x, 4)) {\n                res = min(res, d[i][j]);\n            }\n        }\n    }    \n    return res;\n}\n\nint main()\n{\n    int n;\n    while (cin >> n, n) {\n        vector<Point> ps(n);\n        for (int i = 0; i < n; i++) {\n            cin >> ps[i].x >> ps[i].y;\n        }\n        double res = solve(ps);\n        if (n == 1 || res == INF) {\n            puts(\"impossible\");\n        } else {\n            printf(\"%.15f\\n\", res);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    if (abs(a-b)<EPS) return 0;\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n  L() {}\n};\ntypedef vector<P> G;\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\nG convex_cut(const G& g, const L& l) {\n  G Q;\n  REP(i, g.size()) {\n    P A = curr(g, i), B = next(g, i);\n    if (ccw(l[0], l[1], A) != -1) Q.push_back(A);\n    if (ccw(l[0], l[1], A)*ccw(l[0], l[1], B) < 0)\n      Q.push_back(crosspoint(L(A, B), l));\n  }\n  return Q;\n}\n// 垂直二等分線\nL bisector(const P &a, const P &b) {\n  P A = (a+b)*P(0.5,0);\n  return L(A, A+(b-a)*P(0, PI/2));\n}\n// ボロノイ領域\nG voronoi_cell(G g, const vector<P> &v, int s) {\n  REP(i, v.size())\n    if (i!=s)\n      g = convex_cut(g, bisector(v[s], v[i]));\n  return g;\n}\nbool ok(const P &p) {\n  return -EPS < p.imag() && p.imag() < 4+EPS;\n}\ndouble adj[500][500];\nint main() {\n  int n;\n  while(cin>>n, n) {\n    REP(i,500)REP(j,500) adj[i][j] = INF;\n    G g;\n    g.push_back(P(0,-1));\n    g.push_back(P(4,-1));\n    g.push_back(P(4,5));\n    g.push_back(P(0,5));\n    vector<P> v(n);\n    REP(i,n) cin>>v[i].real()>>v[i].imag();\n    map<P, int> mp;\n    int num = 0;\n    set<int> start, end;\n    REP(i,n) {\n      G vo = voronoi_cell(g, v, i);\n      FOR(it, vo) {\n        if (ok(*it)) {\n          if (mp.count(*it) == 0) {\n            mp[*it] = num++;\n          }\n          if (it->real()<EPS) start.insert(mp[*it]);\n          if (it->real()>4-EPS) end.insert(mp[*it]);\n        }\n      }\n      REP(j, vo.size()-1) {\n        if (ok(vo[j]) && ok(vo[j+1])) {\n          int a = mp[vo[j]], b = mp[vo[j+1]];\n          adj[b][a] = adj[a][b] = abs(vo[j]-vo[j+1]);\n        }\n      }\n    }\n    // FOR(it, mp) cout << it->first << \" \" << it->second << endl;\n    // REP(i,num){REP(j,num)cout<<adj[i][j]<< \" \";cout<<endl;}\n    \n    REP(k,num) REP(i,num) REP(j,num)\n      adj[i][j] = min(adj[i][j], adj[i][k]+adj[k][j]);\n    \n    double ans = INF;\n    FOR(it, start) {\n      FOR(jt, end) {\n        ans = min(ans, adj[*it][*jt]);\n      }\n    }\n    if (ans > INF-1) {\n      cout << \"impossible\" << endl;\n    } else {\n      printf(\"%.8f\\n\", ans);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <list>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <fstream>\n#include <cassert>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> PI;\n#define EPS (1e-7)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i, n) rep (i, n)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define min3(a,b,c) min((a),min((b),(c)))\n#define min4(a,b,c,d) min((a),min3((b),(c),(d)))\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FLL(a,b) memset((a),b,sizeof(a))\n#define CLR(a) memset((a),0,sizeof(a))\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\ntemplate<typename T,typename U> ostream& operator<< (ostream& out, const pair<T,U>& val){return out << \"(\" << val.F << \", \" << val.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& out, const vector<T>& val){out << \"{\";rep(i,SZ(val)) out << (i?\", \":\"\") << val[i];return out << \"}\";}\ntypedef double FP;\ntypedef complex<FP> pt;\ntypedef pt P;\ntypedef pair<pt,pt> line;\nFP dot(P a,P b){return real(conj(a)*b);}\nFP crs(P a,P b){return imag(conj(a)*b);}\nP ortho(P a){return a*P(0,1);}\nP ortho(line a){return ortho(a.S-a.F);}\nP crspt(P a,P b,P c,P d){b-=a,d-=c;return a+b*crs(d,c-a)/crs(d,b);}\nP crspt(line a,line b){return crspt(a.F,a.S,b.F,b.S);}\nbool onl(P a1,P a2,P b){return abs(b-a1)+abs(b-a2)<abs(a1-a2)+EPS;}\nbool onl(line a,P b){return onl(a.F,a.S,b);}\nbool iscrs(line a,line b){P c=crspt(a,b);return onl(a,c)&&onl(b,c);}\nvoid pkuassert(bool t){t=1/t;};\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\nenum{TOP,BTM,LFT,RGT,FRT,BCK};\nint dxdy2ce[]={RGT,FRT,LFT,BCK};\ntemplate<class T> T shift(T a,int b,int c,int d,int e){\n __typeof(a[0])t=a[b];a[b]=a[c];a[c]=a[d];a[d]=a[e];a[e]=t;\n return a;}\ntemplate<class T> T rgt(T a){return shift(a,TOP,LFT,BTM,RGT);}\ntemplate<class T> T lft(T a){return shift(a,TOP,RGT,BTM,LFT);}\ntemplate<class T> T frt(T a){return shift(a,TOP,BCK,BTM,FRT);}\ntemplate<class T> T bck(T a){return shift(a,TOP,FRT,BTM,BCK);}\nline mkl(P a,P v){return line(a,a+v);}\nFP lpdist(line a,P b){return abs(b-crspt(a,mkl(b,ortho(a))));}\nFP spdist(line a,P b){\n  P c(crspt(a,mkl(b,ortho(a))));\n  return onl(a,c)?abs(b-c):min(abs(a.F-b),abs(a.S-b));\n}\nFP ssdist(line a,line b){\n return\n  iscrs(a,b)?0.:\n   min4(spdist(a,b.F),spdist(a,b.S),\n        spdist(b,a.F),spdist(b,a.S));\n}\nnamespace std{\n  bool operator<(const P&a,const P&b){\n    return mp(real(a),imag(a))<mp(real(b),imag(b));\n  }\n}\nint ccw(P a, P b, P c) {\n\tdouble d = crs(b -= a, c -= a);\n\treturn d>EPS ? 1 : d<-EPS ? -1 : dot(b,c)<-EPS ? 2 : norm(b)+EPS<norm(c) ? -2 : 0;\n}\n#define CCW(l, a) ccw((l).first, (l).second, (a))\n#define EQ(a, b) (abs((a)-(b)) < EPS)\n#define DI(l) ((l).second-(l).first)\ntypedef line L;\nbool intersectSP(const L &s, const P &p) { return EQ(abs(s.first-p)+abs(s.second-p)-abs(DI(s)), 0); }\nbool intersectSS(const L &s, const L &t) { return CCW(s,t.first)*CCW(s,t.second)<=0 && CCW(t,s.first)*CCW(t,s.second)<=0; }\nbool parallel(const L &l, const L &m) { return EQ(crs(DI(l), DI(m)), 0); }\nbool sameline(const L &l, const L &m) { return parallel(l, m) && EQ(crs(DI(l), m.second-l.first), 0); }\n\n\nvoid arrange_segments(const vector<L> &ls, vector<vector<pair<int, double> > > &G, vector<P> &ps) {\n  \n\trep(i, SZ(ls)) {\n\t\tps.push_back(ls[i].first);\n\t\tps.push_back(ls[i].second);\n\t\trep(j, i) if (intersectSS(ls[i], ls[j]) && !sameline(ls[i], ls[j]))\n\t\t\tps.push_back(crspt(ls[i], ls[j]));\n\t}\n\tsort(ALL(ps));\n\tps.erase(unique(ALL(ps)), ps.end());\n\n\tG.assign(SZ(ps), vector<pair<int, double> >());\n\trep(i, SZ(ls)) {\n\t\tvector<pair<double, int> > as;\n\t\trep(j, SZ(ps)) if (intersectSP(ls[i], ps[j]))\n\t\t\tas.push_back(make_pair(norm(ls[i].first - ps[j]), j));\n\t\tsort(ALL(as));\n\t\trep(j, SZ(as)-1) {\n\t\t\tint a = as[j].second, b = as[j+1].second;\n\t\t\tdouble l = abs(ps[a] - ps[b]);\n\t\t\tG[a].push_back(make_pair(b, l));\n\t\t\tG[b].push_back(make_pair(a, l));\n\t\t}\n\t}\n\trep(i, SZ(G)) {\n\t\tsort(ALL(G[i]));\n\t\tG[i].erase(unique(ALL(G[i])), G[i].end());\n\t}\n}\n\nint n;\nP in[100];\nbool app[2000];\n\n\nvoid solve(){\n  rep(i,n) cin >> in[i].real() >> in[i].imag();\n\n  CLR(app);\n  vector<line> li;\n  rep(i,n)rep(j,i){\n    line ij(ortho(in[i]-in[j])+(in[i]+in[j])*0.5,(in[i]+in[j])*0.5);\n    P t=ij.F-ij.S;\n    t *= 10/abs(t);\n    ij.F+=t;\n    ij.S-=t;\n    li.pb(ij);\n  }\n  li.pb(line(P(0,-1),P(0,5)));\n  li.pb(line(P(4,-1),P(4,5)));\n  vector<vector<pair<int, double> > > G;\n  priority_queue<pair<double,int> > q;  \n  vector<P> ps;\n  arrange_segments(li,G,ps);\n  FOR(it,ps) if(onl(line(P(0,0),P(0,4)),*it)) \n    q.push(mp(0,it-ps.begin()));\n  while(!q.empty()){\n    double cc=-q.top().F;\n    int cv=q.top().S;\n    q.pop();\n    double cx=real(ps[cv]);\n    double cy=imag(ps[cv]);\n    \n    if(min(cx,cy)<-EPS || max(cx,cy)>4+EPS) continue;\n    if(app[cv]) continue;\n    if(EQ(cx,4)){\n      printf(\"%.8f\\n\",cc);\n      return;\n    }\n    app[cv]=true;\n    FOR(it,G[cv]){\n      line ed(ps[cv],ps[it->F]);\n      vector<double> di;\n      rep(i,n)\n        di.pb(spdist(ed,in[i]));\n      sort(ALL(di));\n      if(n>=2 && EQ(di[0],di[1]))\n        q.push(mp(-cc-it->S,it->F));\n    }\n\n  }\n\n  cout << \"impossible\" << endl;\n}\n\nint main(int argc, char *argv[])\n{\n  while(cin >> n && n) solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <list>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <fstream>\n#include <cassert>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> PI;\n#define EPS (1e-6)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i, n) rep (i, n)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define min3(a,b,c) min((a),min((b),(c)))\n#define min4(a,b,c,d) min((a),min3((b),(c),(d)))\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FLL(a,b) memset((a),b,sizeof(a))\n#define CLR(a) memset((a),0,sizeof(a))\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\ntemplate<typename T,typename U> ostream& operator<< (ostream& out, const pair<T,U>& val){return out << \"(\" << val.F << \", \" << val.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& out, const vector<T>& val){out << \"{\";rep(i,SZ(val)) out << (i?\", \":\"\") << val[i];return out << \"}\";}\ntypedef double FP;\ntypedef complex<FP> pt;\ntypedef pt P;\ntypedef pair<pt,pt> line;\nFP dot(P a,P b){return real(conj(a)*b);}\nFP crs(P a,P b){return imag(conj(a)*b);}\nP ortho(P a){return a*P(0,1);}\nP ortho(line a){return ortho(a.S-a.F);}\nP crspt(P a,P b,P c,P d){b-=a,d-=c;return a+b*crs(d,c-a)/crs(d,b);}\nP crspt(line a,line b){return crspt(a.F,a.S,b.F,b.S);}\nbool onl(P a1,P a2,P b){return abs(b-a1)+abs(b-a2)<abs(a1-a2)+EPS;}\nbool onl(line a,P b){return onl(a.F,a.S,b);}\nbool iscrs(line a,line b){P c=crspt(a,b);return onl(a,c)&&onl(b,c);}\nvoid pkuassert(bool t){t=1/t;};\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\nenum{TOP,BTM,LFT,RGT,FRT,BCK};\nint dxdy2ce[]={RGT,FRT,LFT,BCK};\ntemplate<class T> T shift(T a,int b,int c,int d,int e){\n __typeof(a[0])t=a[b];a[b]=a[c];a[c]=a[d];a[d]=a[e];a[e]=t;\n return a;}\ntemplate<class T> T rgt(T a){return shift(a,TOP,LFT,BTM,RGT);}\ntemplate<class T> T lft(T a){return shift(a,TOP,RGT,BTM,LFT);}\ntemplate<class T> T frt(T a){return shift(a,TOP,BCK,BTM,FRT);}\ntemplate<class T> T bck(T a){return shift(a,TOP,FRT,BTM,BCK);}\nline mkl(P a,P v){return line(a,a+v);}\nFP lpdist(line a,P b){return abs(b-crspt(a,mkl(b,ortho(a))));}\nFP spdist(line a,P b){\n  P c(crspt(a,mkl(b,ortho(a))));\n  return onl(a,c)?abs(b-c):min(abs(a.F-b),abs(a.S-b));\n}\nFP ssdist(line a,line b){\n return\n  iscrs(a,b)?0.:\n   min4(spdist(a,b.F),spdist(a,b.S),\n        spdist(b,a.F),spdist(b,a.S));\n}\nnamespace std{\n  bool operator<(const P&a,const P&b){\n    return mp(real(a),imag(a))<mp(real(b),imag(b));\n  }\n}\nint ccw(P a, P b, P c) {\n\tdouble d = crs(b -= a, c -= a);\n\treturn d>EPS ? 1 : d<-EPS ? -1 : dot(b,c)<-EPS ? 2 : norm(b)+EPS<norm(c) ? -2 : 0;\n}\n#define CCW(l, a) ccw((l).first, (l).second, (a))\n#define EQ(a, b) (abs((a)-(b)) < EPS)\n#define DI(l) ((l).second-(l).first)\ntypedef line L;\nbool intersectSP(const L &s, const P &p) { return EQ(abs(s.first-p)+abs(s.second-p)-abs(DI(s)), 0); }\nbool intersectSS(const L &s, const L &t) { return CCW(s,t.first)*CCW(s,t.second)<=0 && CCW(t,s.first)*CCW(t,s.second)<=0; }\nbool parallel(const L &l, const L &m) { return EQ(crs(DI(l), DI(m)), 0); }\nbool sameline(const L &l, const L &m) { return parallel(l, m) && EQ(crs(DI(l), m.second-l.first), 0); }\n\n\nvoid arrange_segments(const vector<L> &ls, vector<vector<pair<int, double> > > &G, vector<P> &ps) {\n  \n\trep(i, SZ(ls)) {\n\t\tps.push_back(ls[i].first);\n\t\tps.push_back(ls[i].second);\n\t\trep(j, i) if (intersectSS(ls[i], ls[j]) && !sameline(ls[i], ls[j]))\n\t\t\tps.push_back(crspt(ls[i], ls[j]));\n\t}\n\tsort(ALL(ps));\n\tps.erase(unique(ALL(ps)), ps.end());\n\n\tG.assign(SZ(ps), vector<pair<int, double> >());\n\trep(i, SZ(ls)) {\n\t\tvector<pair<double, int> > as;\n\t\trep(j, SZ(ps)) if (intersectSP(ls[i], ps[j]))\n\t\t\tas.push_back(make_pair(norm(ls[i].first - ps[j]), j));\n\t\tsort(ALL(as));\n\t\trep(j, SZ(as)-1) {\n\t\t\tint a = as[j].second, b = as[j+1].second;\n\t\t\tdouble l = abs(ps[a] - ps[b]);\n\t\t\tG[a].push_back(make_pair(b, l));\n\t\t\tG[b].push_back(make_pair(a, l));\n\t\t}\n\t}\n\trep(i, SZ(G)) {\n\t\tsort(ALL(G[i]));\n\t\tG[i].erase(unique(ALL(G[i])), G[i].end());\n\t}\n}\n\nint n;\nP in[100];\nbool app[2000];\n\n\nvoid solve(){\n  rep(i,n) cin >> in[i].real() >> in[i].imag();\n\n  CLR(app);\n  vector<line> li;\n  rep(i,n)rep(j,i){\n    line ij(ortho(in[i]-in[j])+(in[i]+in[j])*0.5,(in[i]+in[j])*0.5);\n    P t=ij.F-ij.S;\n    t *= 10/abs(t);\n    ij.F+=t;\n    ij.S-=t;\n    li.pb(ij);\n  }\n  li.pb(line(P(0,-1),P(0,5)));\n  li.pb(line(P(4,-1),P(4,5)));\n  vector<vector<pair<int, double> > > G;\n  priority_queue<pair<double,int> > q;  \n  vector<P> ps;\n  arrange_segments(li,G,ps);\n  FOR(it,ps) if(onl(line(P(0,0),P(0,4)),*it)) \n    q.push(mp(0,it-ps.begin()));\n  while(!q.empty()){\n    double cc=-q.top().F;\n    int cv=q.top().S;\n    q.pop();\n    double cx=real(ps[cv]);\n    double cy=imag(ps[cv]);\n    \n    if(min(cx,cy)<-EPS || max(cx,cy)>4+EPS) continue;\n    if(app[cv]) continue;\n    if(EQ(cx,4)){\n      printf(\"%.8f\\n\",cc);\n      return;\n    }\n    app[cv]=true;\n    FOR(it,G[cv]){\n      line ed(ps[cv],ps[it->F]);\n      vector<double> di;\n      rep(i,n)\n        di.pb(spdist(ed,in[i]));\n      sort(ALL(di));\n      if(n>=2 && EQ(di[0],di[1]))\n        q.push(mp(-cc-it->S,it->F));\n    }\n\n  }\n\n  cout << \"impossible\" << endl;\n}\n\nint main(int argc, char *argv[])\n{\n  while(cin >> n && n) solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<vector>\n#include<iostream>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<cmath>\n\n#define START_X 0.0\n#define GOAL_X 4.0\n\n#define FRONT 0x01\n#define RIGHT 0x02\n#define BACK 0x04\n#define LEFT 0x08\n#define OVER 0x10\n\n#define sc second\n#define fr first\n\n#define REP(i,n) for(int i = 0; i < (int)(n); ++i)\n\nusing namespace std;\n\ntypedef double elem;\ntypedef complex<elem> point, vec;\ntypedef pair<point, point> line, hline, seg, pp;\n\nconst double eps = 1.0e-6;\nconst double pi = acos(-1.0);\nconst double infty = 1e40;\npoint base(0,0),origin(0,0);\n\nbool eq(elem a, elem b){ return abs(a-b) < eps; }\nbool lt(elem a, elem b){ return !eq(a,b) && a < b; }\nbool leq(elem a, elem b){ return eq(a,b) || a < b; }\nbool gt(elem a, elem b){ return !eq(a,b) && a > b; }\nbool geq(elem a, elem b){ return eq(a,b) || a > b; }\nbool ltz(elem a){ return lt( a, 0 ); }\nbool gtz(elem a){ return gt( a, 0 ); }\nbool eqv(vec a, vec b){ return eq( abs(b-a),0); }\nbool is_zv(vec v){ return eq(abs(v),0); }\nelem emax(elem a, elem b){ return gt(a,b)?a:b; }\nelem emin(elem a, elem b){ return lt(a,b)?a:b; }\n\nbool far(point a, point b){ return gtz( abs(b-a) ); }\nbool near(point a, point b){ return leq( abs(b-a), 0 ); }\nelem dot(vec a, vec b){ return (a.real() * b.real() + a.imag() * b.imag() ); }\nelem cross(vec a, vec b){ return ( a.real() * b.imag() - a.imag() * b.real() ); }\n\nelem dist(point a, point b){ return abs(a-b); }\nelem dist_l(line l, point x){ return abs(cross(l.sc-l.fr,x-l.fr)) / abs(l.sc-l.fr); }\nelem dist_seg(seg s, point x)\n{\n  if( ltz( dot(s.sc-s.fr,x-s.fr) ) ) return abs(x-s.fr);\n  if( ltz( dot(s.fr-s.sc,x-s.sc) ) ) return abs(x-s.sc);\n  return dist_l(s,x);\n}\n\nvec uvec(vec a){ return a / abs(a); }\nvec nmr(vec a){ return a * vec(0,-1); }\nvec nml(vec a){ return a * vec(0,1); }\nvec unmr(vec a){ return uvec( nmr(a) ); }\nvec unml(vec a){ return uvec( nml(a) ); }\n\nbool orth(point a1, point a2, point b1, point b2){ return eq( dot( a2 - a1, b2 - b1 ), 0 ); }\nbool orth(vec v1, vec v2){ return eq( dot(v1, v2), 0 ); }\nbool prll(point a1, point a2, point b1, point b2){ return eq( cross( a2 - a1, b2 - b1 ), 0 ); }\nbool prll(vec v1, vec v2){ return eq( cross(v1, v2), 0 ); }\n\nint ccw(point a, point b, point x){\n  b -= a;\n  x -= a;\n  if( gtz( cross(b,x) ) ) return LEFT;\n  if( ltz( cross(b,x) ) ) return RIGHT;\n  if( ltz( dot(b,x) ) ) return BACK;\n  if( lt( abs(b), abs(x) ) ) return FRONT;\n  return OVER;\n}\n\nbool intersectedSS(seg a, seg b)\n{\n  if( ccw(a.fr,a.sc,b.fr)&OVER || ccw(a.fr,a.sc,b.sc)&OVER ) return true;\n  return\n    ( ccw(a.fr,a.sc,b.fr) | ccw(a.fr,a.sc,b.sc) ) == (LEFT|RIGHT) &&\n    ( ccw(b.fr,b.sc,a.fr) | ccw(b.fr,b.sc,a.sc) ) == (LEFT|RIGHT) ;\n}\n\nbool intersectedLL(line a, line b){ return !eq( cross(a.sc-a.fr,b.sc-b.fr), 0.0 ); }\n\npoint intersectionSS(seg a, seg b)\n{\n  elem d1 = dist_l(b,a.fr);\n  elem d2 = dist_l(b,a.sc);\n  return a.fr + ( d1 / (d1 + d2 ) ) * (a.sc-a.fr);\n}\npoint intersectionLL(line a, line b)\n{\n  vec va = a.sc - a.fr;\n  vec vb = b.sc - b.fr;\n  return a.fr + va * ( cross(vb, b.fr - a.fr) / cross(vb,va) );\n}\n\nbool intersectionLL(line a, line b, point &ret){\n  return intersectedLL( a, b ) ? ret = intersectionLL( a, b ), true : false;\n}\nbool intersectionLH(line a, hline b, point &ret){\n  point tmp;\n  return intersectionLL(a,b,tmp) ? ( ccw(b.fr,b.sc,tmp)&(OVER|FRONT) ? ret=tmp, true : false ) : false;\n}\nbool intersectionLS(line l, seg s, point &ret){\n  point tmp;\n  return intersectionLL(l,s,tmp) ? ( ccw(s.fr,s.sc,tmp)&OVER ? ret=tmp, true : false ) : false;\n}\nbool intersectionHH(hline a, hline b, point &ret){\n  point tmp;\n  return intersectionLL(a,b,tmp) ? ( ccw(a.fr,a.sc,tmp)&(OVER|FRONT)&&ccw(b.fr,b.sc,tmp)&(OVER|FRONT) ? ret = tmp, true : false ) : false;\n}\nbool intersectionHS(hline a, seg s, point &ret){\n  point tmp;\n  return intersectionLS(a,s,tmp) ? ( ccw(a.fr,a.sc,tmp)&(OVER|FRONT) ? ret = tmp, true : false ) : false;\n}\nbool intersectionSS(seg a, seg b, point &ret){\n  return intersectedSS(a,b) ? ret = intersectionSS(a,b), true : false;\n}\n\nbool convexCut(const vector<point> &vp,\n\t       line l,\n\t       vector<point> &left)\n{\n  int n = vp.size();\n  bool bFirst = true;\n  int indq1 = -1, indq2 = -1;\n  point q1, q2;\n  \n  for(int i = 0; i < n; ++i){\n    seg edge = make_pair( vp[i], vp[(i+1)%n] );\n    if( bFirst ){\n      if( intersectionLS( l, edge, q1 ) ){ bFirst = false; indq1 = (i+1)%n; }\n    }else{\n      if( intersectionLS( l, edge, q2 ) && far(q1,q2) ){ indq2 = (i+1)%n; break; }\n    }\n  }\n\n  if( indq1<0||indq2<0 ) return false;\n  if( lt( dist( q1, l.second ), dist( q2, l.second ) ) ){ swap( q1, q2 ); swap( indq1, indq2 ); }\n  if( far( q2, vp[indq2] ) ) left.push_back( q2 );\n  for(int i = indq2; i != indq1; i=(i+1>=n?0:i+1)) left.push_back( vp[i] );\n  if( far(q1, vp[(indq1-1+n)%n] ) ) left.push_back( q1 );\n\n  return true;\n}\n\nstruct Point{\n  point p;\n  Point():p(origin){}\n  Point(point p):p(p){}\n  bool operator < (const Point &t)const{\n    if(!eq(p.real(),t.p.real()))return lt(p.real(),t.p.real());\n    else return lt(p.imag(),t.p.imag());\n  }\n};\n\nstruct Node{\n  point p;\n  vector<int> con;\n  vector<double> cost;\n};\n\ntypedef vector<Node> Graph;\n\nstruct VolLine{\n  line l;\n  VolLine():l(origin,origin){}\n  VolLine(line l):l(l){}\n  int point_id[2]; // volonoi points id with touching with this line.\n};\n\nline expandLine(line l, elem mag){\n  line ret = l;\n  vec vf(l.first - l.second);\n  vec vs(l.second - l.first);\n  ret.first = l.second + mag * vf;\n  ret.second = l.first + mag * vs;\n  return ret;\n}\n\nvoid MakeVolonoi(const vector<point> &vp,\n\t\t const vector<point> &plane,\n\t\t vector< vector<point> > &out){\n  vector<point> tplane;\n  \n  for(int i = 0; i < vp.size(); ++i){\n    tplane = plane;\n    for(int j = 0; j < vp.size(); ++j){\n      if( i != j ){\n\tvector<point> newplane;\n\tpoint c = (vp[i]+vp[j])/2.;\n\tint cw = ccw( c, unmr(vp[i]-vp[j])+c, vp[i] );\n\tline bisec;\n\tif( cw == LEFT ){\n\t  bisec = line( c, unmr( vp[i]-vp[j] ) + c );\n\t}else{\n\t  bisec = line( c, unml( vp[i]-vp[j] ) + c );\n\t}\n\tbisec = expandLine( bisec, 20 ); // magnify segment for convex cut\n\tif( convexCut(tplane, bisec, newplane ) )\n\t  tplane = newplane;\n      }\n    }\n    out.push_back( tplane );\n  }\n};\n\nstruct State{\n  int now;\n  elem cost;\n  State(){}\n  bool operator<(const State &t)const{\n    return lt(cost,t.cost);\n  }\n};\n\nelem dijkstra(Graph &G, int sid){\n  elem ret = infty;\n  priority_queue<State> qs;\n  State init;\n  bool vis[G.size()];\n  elem A[G.size()];\n  for(int i = 0; i < G.size(); ++i){\n    vis[i]=false;\n    A[i]=infty;\n  }\n  init.now = sid;\n  init.cost = 0.0;\n  qs.push(init);\n  A[sid]=0.0;\n  while(!qs.empty()){\n    State st_now = qs.top(); qs.pop();\n    int nid = st_now.now;\n    if(vis[nid])continue;\n    else vis[nid]=true;\n    for(int i = 0; i < G[nid].con.size(); ++i){\n      State next;\n      next.now = G[nid].con[i];\n      //cout << next.now << endl;\n      next.cost = st_now.cost + G[nid].cost[i];\n      if( lt(next.cost, A[next.now]) ){\n\tA[next.now] = next.cost;\n\tif( !vis[next.now] ){\n\t  qs.push( next );\n\t}\n      }\n    }\n  }\n  for(int i = 0; i < G.size(); ++i){\n    if( eq(G[i].p.real(),GOAL_X) ){\n      ret = emin( ret, A[i] );\n    }\n  }\n  return ret;\n}\n\nint main()\n{\n  while(true){\n    int n;\n    elem ans=infty;\n    map<Point,int> point_id;\n    vector<point> vp,plane;\n    vector< vector<point> > volonoi;\n\n    cin >> n;\n    if( n == 0 ) break;\n    for(int i = 0; i < n; ++i){\n      elem x,y;\n      cin >> x >> y;\n      vp.push_back( point(x,y) );\n    }\n    if( n == 1 ){\n      puts(\"impossible\");\n      continue;\n    }\n    plane.push_back( point(0.0,0.0) );\n    plane.push_back( point(4.0,0.0) );\n    plane.push_back( point(4.0,4.0) );\n    plane.push_back( point(0.0,4.0) );\n    MakeVolonoi( vp, plane, volonoi );\n\n    /* debug \n    for(int i = 0; i < volonoi.size(); ++i){\n      cout << \"//\" << i << \" master point : \" << vp[i] << endl;\n      for(int j = 0; j < volonoi[i].size(); ++j){\n\tpoint lf=volonoi[i][j];\n\tpoint ls=volonoi[i][(j+1)%volonoi[i].size()];\n\n\tcout << \"line(\" << lf.real() <<\",\" << lf.imag() <<\",\" << ls.real() <<\",\"<<ls.imag() << \");\" << endl;\n      }\n    }\n    cout << endl;\n    */\n\n    int now = 0;\n    for(int i = 0; i < volonoi.size(); ++i){\n      for(int j = 0; j < volonoi[i].size(); ++j){\n\tPoint pp(volonoi[i][j]);\n\tif( point_id.find( pp ) == point_id.end() ){\n\t  point_id[pp] = now;\n\t  ++now;\n\t}\n      }\n    }\n    Graph G(now);\n\n    // Graph Construction\n    for(int i = 0; i < volonoi.size(); ++i){\n      int ni = volonoi[i].size();\n      for(int j = 0; j < ni; ++j){\n\tpoint p = volonoi[i][j];\n\tpoint np = volonoi[i][(j+1)%ni];\n\telem ck = ((p+np)/2.).imag();\n\telem ckx = ((p+np)/2.).real();\n\tif( eq(ckx,0.0)||eq(ckx,4.0)||eq(ck,0.0)||eq(ck,4.0) ) continue;\n\tint ip = point_id[Point(p)];\n\tint inp = point_id[Point(np)];\n\telem d = dist( p, np );\n\tG[ ip ].p = p;\n\tG[ inp ].p = np;\n\tG[ ip ].con.push_back( inp );\n\tG[ ip ].cost.push_back( d );\n\tG[ inp ].con.push_back( ip );\n\tG[ inp ].cost.push_back( d );\n      }\n    }\n\n    for(int i = 0; i < G.size(); ++i){\n      if( eq( G[i].p.real(), START_X ) ){\n\tans = emin( ans, dijkstra( G, i ) );\n      }\n    }\n\n    if(geq(ans,infty))puts(\"impossible\");\n    else printf(\"%.12lf\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst double EPS = 1e-10, PI = acos(-1);\n\ninline bool eq(double a, double b) { return abs(b - a) < EPS; }\n\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define prev(P, i) P[(i+P.size()-1) % P.size()]\n\nenum\n{\n  OUT, ON, IN\n};\nnamespace Geometory\n{\n  struct Point\n  {\n    double x, y;\n\n    Point() {};\n\n    Point(double x, double y) : x(x), y(y) {};\n\n    Point operator+(const Point &b) const { return Point(x + b.x, y + b.y); }\n\n    Point operator-(const Point &b) const { return Point(x - b.x, y - b.y); }\n\n    Point operator*(const double b) const { return Point(x * b, y * b); }\n\n    Point operator*(const Point &b) const { return Point(x * b.x - y * b.y, x * b.y + y * b.x); }\n\n    Point operator/(const double b) const { return Point(x / b, y / b); }\n\n    bool operator<(const Point &b) const { return x != b.x ? x < b.x : y < b.y; }\n\n    bool operator==(const Point &b) const { return eq(x, b.x) && eq(y, b.y); }\n\n    double norm() { return x * x + y * y; }\n\n    double arg() { return atan2(x, y); }\n\n    double abs() { return sqrt(norm()); }\n\n    Point rotate(double theta) { return Point(cos(theta) * x - sin(theta) * y, sin(theta) * x + cos(theta) * y); }\n\n    Point rotate90() { return Point(-y, x); }\n\n    friend ostream &operator<<(ostream &os, Point &p) { return os << \"(\" << p.x << \",\" << p.y << \")\"; }\n\n    friend istream &operator>>(istream &is, Point &a) { return is >> a.x >> a.y; }\n  };\n\n  struct Line\n  {\n    Point a, b;\n\n    Line() {};\n\n    Line(Point a, Point b) : a(a), b(b) {};\n\n    friend ostream &operator<<(ostream &os, Line &p) { return os << \"(\" << p.a.x << \",\" << p.a.y << \") to (\" << p.b.x << \",\" << p.b.y << \")\"; }\n\n    friend istream &operator>>(istream &is, Line &a) { return is >> a.a.x >> a.a.y >> a.b.x >> a.b.y; }\n  };\n\n  struct Segment\n  {\n    Point a, b;\n\n    Segment() {};\n\n    Segment(Point a, Point b) : a(a), b(b) {};\n\n    friend ostream &operator<<(ostream &os, Segment &p) { return os << \"(\" << p.a.x << \",\" << p.a.y << \") to (\" << p.b.x << \",\" << p.b.y << \")\"; }\n\n    friend istream &operator>>(istream &is, Segment &a) { return is >> a.a.x >> a.a.y >> a.b.x >> a.b.y; }\n  };\n\n  typedef vector< Point > Polygon;\n  typedef vector< Segment > Segments;\n\n  double cross(const Point &a, const Point &b)\n  {\n    return a.x * b.y - a.y * b.x;\n  }\n\n  double dot(const Point &a, const Point &b)\n  {\n    return a.x * b.x + a.y * b.y;\n  }\n\n  int ccw(const Point &a, Point b, Point c)\n  {\n    b = b - a, c = c - a;\n    if(cross(b, c) > EPS) return +1;\n    if(cross(b, c) < -EPS) return -1;\n    if(dot(b, c) < 0) return +2;\n    if(b.norm() < c.norm()) return -2;\n    return 0;\n  }\n\n  Point Crosspoint(const Line &l, const Line &m)\n  {\n    double A = cross(l.b - l.a, m.b - m.a);\n    double B = cross(l.b - l.a, l.b - m.a);\n    if(abs(A) < EPS && abs(B) < EPS) return m.a;\n    return m.a + (m.b - m.a) * B / A;\n  }\n\n  Line Bisector(Point a, Point b)\n  {\n    Point c = (a + b) * 0.5;\n    Point p = Point(c.x + (a.y - b.y), c.y + (b.x - a.x));\n    return (Line(c, p));\n  }\n\n  Polygon Convex_Cut(Polygon &U, Line l)\n  {\n    Polygon ret;\n    for(int i = 0; i < U.size(); i++) {\n      Point now = curr(U, i), nxt = next(U, i);\n      if(ccw(l.a, l.b, now) != -1) ret.push_back(now);\n      if(ccw(l.a, l.b, now) * ccw(l.a, l.b, nxt) < 0) {\n        ret.push_back(Crosspoint(Line(now, nxt), l));\n      }\n    }\n    return (ret);\n  }\n};\n\nint main()\n{\n  int N;\n  while(cin >> N, N) {\n    vector< Geometory::Point > points(N);\n    Geometory::Polygon U(4);\n    U[0] = Geometory::Point(0, 0);\n    U[1] = Geometory::Point(4, 0);\n    U[2] = Geometory::Point(4, 4);\n    U[3] = Geometory::Point(0, 4);\n\n    for(int i = 0; i < N; i++) {\n      cin >> points[i];\n    }\n\n    vector< Geometory::Polygon > voronoi(N);\n    for(int i = 0; i < N; i++) {\n      voronoi[i] = U;\n      for(int j = 0; j < N; j++) {\n        if(i == j) continue;\n        voronoi[i] = Geometory::Convex_Cut(voronoi[i], Geometory::Bisector(points[i], points[j]));\n      }\n    }\n\n    vector< Geometory::Point > ventex;\n    map< pair< Geometory::Point, Geometory::Point >, int > sz;\n    for(int i = 0; i < N; i++) {\n      for(auto &point : voronoi[i]) ventex.push_back(point);\n      for(int j = 0; j < voronoi[i].size(); j++) {\n        sz[minmax(curr(voronoi[i], j), next(voronoi[i], j))]++;\n      }\n    }\n\n    vector< vector< double > > g(ventex.size(), vector< double >(ventex.size(), 1e9));\n    for(int i = 0; i < ventex.size(); i++) {\n      for(int j = i + 1; j < ventex.size(); j++) {\n        if(sz[minmax(ventex[i], ventex[j])] >= 2) g[i][j] = g[j][i] = (ventex[i] - ventex[j]).abs();\n      }\n    }\n\n    for(int k = 0; k < ventex.size(); k++) {\n      for(int i = 0; i < ventex.size(); i++) {\n        for(int j = 0; j < ventex.size(); j++) {\n          g[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n        }\n      }\n    }\n\n    double cost = 1e9;\n    for(int i = 0; i < ventex.size(); i++) {\n      for(int j = 0; j < ventex.size(); j++) {\n        if(eq(ventex[i].x, 0) && eq(ventex[j].x, 4)) cost = min(cost, g[i][j]);\n      }\n    }\n\n    if(eq(cost, 1e9)) cout << \"impossible\" << endl;\n    else cout << fixed << setprecision(15) << cost << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<cstdio>\n#include<queue>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\n#define X real()\n#define Y imag()\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\ntypedef vector<P> Pol;\n\nconst double INF = 1e40;\nconst double EPS = 1e-8;\nconst double PI = acos(-1);\n\nint sig(double r) {return (r < -EPS) ? -1 : (r > EPS) ? 1: 0;}\nbool eq(double a, double b) {return abs(a - b) < EPS;}\nbool near(P a, P b) {return abs(b - a) < EPS;}\n\n// 内積\ndouble dot(P a, P b) {return a.X * b.X + a.Y * b.Y;}\n// 外積\ndouble cross(P a, P b) {return a.X * b.Y - a.Y * b.X;}\n\n// 線分のベクトル\nP vec(L a) {return a.second - a.first;}\n\n// 線分abに対する点xの位置\nenum CCW{FRONT = 1, RIGHT = 2, BACK = 4, LEFT = 8, ON = 16};\nint ccw(L s, P p) {\n  P a = vec(s);\n  p -= s.first;\n  double cr = cross(a, p);\n  if (eq(cr, 0)) {\n    if (sig(dot(a, p)) < 0) return BACK;\n    if (sig(norm(a) - norm(p)) < 0) return FRONT;\n    return ON;\n  }\n  return (cr > 0) ? LEFT : RIGHT;\n}\n\n// 角度\ndouble ang(P p) {double theta = arg(p); return sig(theta - PI) < 0 ? theta : -PI;}\n// 有向角度\ndouble ang(P base, P a, P b) {return ang((b - base) / (a - base));}\nP dv(double theta) {return polar(1., theta);}\n\n// 射影\nP proj(P a, P b) {return a * dot(a, b) / norm(a);}\nP perp(L l, P p) {return l.first + proj(vec(l), p - l.first);}\nP refl(L l, P p) {return perp(l, p) * 2. - p;}\n \n// 交差判定\nbool iLL(L a, L b) {return !eq(cross(vec(a), vec(b)), 0);}\nbool eqL(L a, L b) {return !iLL(a, b) && eq(cross(vec(a), b.first - a.first), 0);}\nbool iLS(L a, L b) {return sig(cross(vec(a), b.first - a.first)) * sig(cross(vec(a), b.second - a.first)) <= 0;}\nbool iLSs(L a, L b) {return sig(cross(vec(a), b.first - a.first)) * sig(cross(vec(a), b.second - a.first)) < 0;}\nbool iSS(L a, L b) {\n  int cwa = ccw(a, b.first) | ccw(a, b.second);\n  int cwb = ccw(b, a.first) | ccw(b, a.second);\n  if ((cwa | cwb) & ON) return true;\n  return (cwa & cwb) == (LEFT | RIGHT);\n}\nbool iSSs(L a, L b) {\n  return ((ccw(a, b.first) | ccw(a, b.second)) & (ccw(b, a.first) | ccw(b, a.second))) == (LEFT | RIGHT);\n}\n\n// 交点\nP pLL(L a, L b) {return a.first + vec(a) * (cross(vec(b), b.first - a.first) / cross(vec(b), vec(a)));}\n\n// 距離\ndouble dLP(L l, P x) {return abs(cross(vec(l), x - l.first)) / abs(vec(l));}\ndouble dSP(L s, P x) {\n  if (dot(vec(s), x - s.first) <= 0) return abs(x - s.first);\n  if (dot(-vec(s), x - s.second) <= 0) return abs(x - s.second);\n  return dLP(s, x);\n}\ndouble dLL(L a, L b) {return iLL(a, b) ? 0 : dLP(a, b.first);}\ndouble dLS(L a, L b) {return iLS(a, b) ? 0 : min(dLP(a, b.first), dLP(a, b.second));}\ndouble dSS(L a, L b) {return iSS(a, b) ? 0 : min(min(dSP(a, b.first), dSP(a, b.second)), min(dSP(b, a.first), dSP(b, a.second)));}\n\n// 半直線絡みの交差判定\nbool iLH(L a, L b) {return iLL(a, b) && ccw(b, pLL(a, b)) & (ON | FRONT);}\nbool iHH(L a, L b) {return iLH(a, b) && iLH(b, a);}\nbool iHS(L a, L b) {return iLS(a, b) && iLH(b, a);}\n\n// 直行\nbool orth(P a, P b) {return eq(dot(a, b), 0);}\n// 平行\nbool prll(P a, P b) {return eq(cross(a, b), 0);}\n\n\n// x座標でソート\nbool lessX(P a, P b){\n  if(!eq(a.X, b.X)) return a.X < b.X;\n  if(!eq(a.Y, b.Y)) return a.Y < b.Y;\n  return false;\n}\n// y座標でソート\nbool lessY(P a, P b){\n  if(!eq(a.Y, b.Y)) return a.Y < b.Y;\n  if(!eq(a.X, b.X)) return a.X < b.X;\n  return false;\n}\n// 偏角でソート\nL sortBase;\nbool lessArg(P a, P b) {\n  double ang1 = ang(sortBase.first, sortBase.second, a);\n  double ang2 = ang(sortBase.first, sortBase.second, b);\n  if (!eq(ang1, ang2)) return ang1 < ang2;\n  return norm(a) > norm(b);\n}\n\n// 円\nstruct C{\n  P c;\n  double r;\n  C() {}\n  C(P c, double r) : c(c), r(r) {}\n};\n\n// 2円の位置関係\nenum RELATION{SAME = 1, CONTAIN = 2, OVER = 4, NO_CROSS = 8, ONE_CROSS = 16, ONE_CONTAIN_CROSS = 32, ONE_OVER_CROSS = 64, TWO_CROSS = 128};\nint cRel(C c1, C c2) {\n  double d = abs(c1.c - c2.c);\n  if (near(c1.c, c2.c) && eq(c1.r, c2.r)) return SAME;\n  if (sig(d - (c1.r - c2.r)) < 0) return OVER;\n  if (sig(d - (c2.r - c1.r)) < 0) return CONTAIN;\n  if (eq(d, c1.r - c2.r)) return ONE_OVER_CROSS;\n  if (eq(d, c2.r - c1.r)) return ONE_CONTAIN_CROSS;\n  if (eq(d, c1.r + c2.r)) return ONE_CROSS;\n  if (sig(d - (c1.r + c2.r)) > 0) return NO_CROSS;\n  return TWO_CROSS;\n}\n\n// 点が円に含まれるか\nbool iCP(C c, P p) {return sig(abs(p - c.c) - c.r) <= 0;}\n// 交差判定\nbool iCL(C c, L l) {return sig(c.r - dLP(l, c.c)) >= 0;}\n// 円と交差せず完全に含まれても良い場合は&&以降を削除\nbool iCS(C c, L s) {return sig(c.r - dSP(s, c.c)) >= 0 && sig(c.r - max(abs(s.first - c.c), abs(s.second - c.c))) <= 0;}\n\n// 交点\npair<P, P> pCC(C a, C b) {\n  double d = abs(b.c - a.c);\n  double x = (d * d + a.r * a.r - b.r * b.r) / (2 * d);\n  P e = (b.c - a.c) / abs(b.c - a.c), w = e * P(0, 1) * sqrt(max(a.r * a.r - x * x, 0.));\n  return make_pair(a.c + e * x - w, a.c + e * x + w);\n}\npair<P, P> pCL(C c, L l) {\n  P h = perp(l, c.c);\n  P e = vec(l) / abs(vec(l)) * sqrt(max(c.r * c.r - norm(h - c.c), 0.0));\n  return make_pair(h - e, h + e);\n}\n\n// 点から円への接線 firstがp->c.cに対して左側\npair<P, P> tCP(C c, P p) {\n  double d2 = norm(p - c.c);\n  double x = sqrt(max(d2 - c.r * c.r, 0.));\n  P h = c.c + (p - c.c) * (c.r * c.r / d2);\n  P w = (p - c.c) * (x * c.r / d2) * P(0, 1);\n  return make_pair(h - w, h + w);\n}\n\n// 二円の共通接線\n// 1個:内側で接する\n// 2個:共有点が2個\n// 3個:外側で接する\nvector<L> tCC(C c1, C c2) {\n  vector<L> res;\n  pair<P, P> pcross, pcross2;\n  double d2 = norm(c2.c - c1.c);\n\n  int rel = cRel(c1, c2);\n  if (rel & (SAME | CONTAIN | OVER)) return res;\n  \n  if (rel & (ONE_CONTAIN_CROSS | ONE_OVER_CROSS | ONE_CROSS)) {\n    P p = pCC(c1, c2).first;\n    res.push_back(L(p, p + (p - c1.c) * P(0, -1) / abs(p - c1.c)));\n    if (rel & (ONE_CONTAIN_CROSS | ONE_OVER_CROSS)) return res;\n  }\n\n  //external\n  pcross = pCC(C(c1.c, sqrt(d2 - (c2.r - c1.r) * (c2.r - c1.r) + c1.r * c1.r)), c2);\n  pcross2 = pCC(C(c2.c, sqrt(d2 - (c2.r - c1.r) * (c2.r - c1.r) + c2.r * c2.r)), c1);\n  res.push_back(L(pcross2.second, pcross.first));\n  res.push_back(L(pcross2.first, pcross.second));\n  if (rel & (TWO_CROSS | ONE_CROSS)) return res;\n    \n  //internal\n  P In((c2.r * c1.c + c1.r * c2.c) / (c1.r + c2.r));\n  pcross = pCC(C(In, (abs(c1.c - In)) - (c1.r * c1.r)), c1);\n  res.push_back(L(In, pcross.first));\n  res.push_back(L(In, pcross.second));\n  return res;\n}\n\n// 円をn等分する\nvector<P> divideCircle(C c, int n, double s) {\n  vector<P> v;\n  rep (i,n) v.push_back(c.c + c.r * dv(2 * PI / n * i + s));\n  return v;\n}\n\n// a:bに内分\nP iDiv(P p, P q, double a, double b) {return P((q * a + p * b) / (a + b));}\n// a:bに外分\nP oDiv(P p, P q, double a, double b) {return P((q * a - p * b) / (a - b));}\n\n// 線分を直径とする円\nC cDS(L s) {return C((s.first + s.second) / 2., abs(vec(s)) / 2);}\n// アポロニウスの円\n// s!=tに注意\nC apC(P a, P b, double s, double t) {return cDS(L(iDiv(a, b, s, t), oDiv(a, b, s, t)));}\n\n// 角の内外判定 角abの内部にあれば正、辺上は0、外部は負\nint sAP(P a, P b, P c) {return sig(cross(a, c)) - sig(cross(b, c)) - sig(cross(a, b));}\n\n// 多角形の面積\ndouble aPol(Pol vp) {\n  double ret = 0;\n  rep(i, vp.size()){\n    ret += cross(vp[i], vp[(i + 1) % vp.size()]);\n  }\n  return abs(ret / 2);\n}\n// 正n角形の面積\ndouble aRPol(double r, int n) {return n * r * r * sin(2 * PI / (double)n) / 2.0;}\n// 多角形の移動\nvoid movePol(Pol vp, P p) {rep (i, vp.size()) vp[i] += p;}\nvoid rotPol(Pol vp, double theta) {rep (i, vp.size()) vp[i] *= dv(theta);}\n\n// 三角形\nstruct triangle {\n  vector<P> p;\n  triangle() : p(3, P(0, 0)) {}\n  triangle(P a, P b, P c) {p.push_back(a); p.push_back(b); p.push_back(c);}\n  bool contains(P t) {return __builtin_popcount(ccw(L(p[0], p[1]), t) | ccw(L(p[1], p[2]), t) | ccw(L(p[2], p[0]), t)) == 1;}\n};\n\n// 長方形\nstruct rectangle {\n  P tl, br;\n  rectangle() : tl(0, 0), br(0, 0) {}\n  rectangle(P a, P b) : tl(a), br(b) {}\n  bool contains(P t) {return tl.X <= t.X && t.X <= br.X && br.Y <= t.Y && t.Y <= tl.Y;}\n};\n\n// 点列が反時計回りであるか\n// 同一直線上がNGなら(RIGHT | BACK | ON | FRONT)\nbool isCounterClockWise(vector<P> vp){\n  int n = vp.size();\n  rep (i, n) {\n    if(ccw(L(vp[i], vp[(i + 1) % n]), vp[(i + 2) % n]) & (RIGHT | BACK | ON))\n      return false;\n  }\n  return true;\n}\n\n// 三角形の面積\ndouble aTri(double a, double b, double c){\n  double s = (a + b + c) / 2;\n  return sqrt(max(s * (s - a) * (s - b) * (s - c), 0.));\n}\ndouble aTriSin(double a, double b, double argC){\n  return 0.5 * a * b * sin(argC);\n}\n// 垂線の長さから出す\ndouble aTriH(double Ha, double Hb, double Hc){\n  return Hb * Hc / (2 * sin(acos(Hb * Hc * (1. / Hb * Hb + 1. / Hc * Hc - 1. / Ha * Ha) / 2)));\n}\n\n// 内接円\nP inscribedCircleCenter(P a, P b, P c) {\n  double A = abs(c - b), B = abs(c - a), C = abs(b - a);\n  double S = A + B + C;\n  return (A / S) * a + (B / S) * b + (C / S) * c;\n}\n// 内接円の半径\ndouble inradiusOfTriangle(double a, double b, double c) {\n  return 2 * aTri(a, b, c) / (a + b + c);\n}\ndouble inradiusOfTriangle(P a, P b, P c) {\n  double A = abs(c - b), B = abs(c - a), C = abs(b - a);\n  return 2 * aTri(A, B, C) / (A + B + C);\n}\n\n// 球の表面積 xまで部分的に求められる x=rのとき全表面積\ndouble sphereSurface(double r, double x) {return 2 * PI * r * (x + r);}\n// 球の体積 xまで部分的に求められる ただしx>=0 x=rのとき全体積\ndouble sphereVolume(double r, double x) {return PI * ((2 / 3.) * r * r * r  + r * r * x - x * x * x / 3.);}\n\n// 三角形の外心を出す\nP circumscribedCircleCenter(P a, P b, P c) {\n  double ax = a.X, ay = a.Y;\n  double bx = b.X, by = b.Y;\n  double cx = c.X, cy = c.Y;\n  double D = 2 * (ax * (by - cy) + bx * (cy - ay) + cx * (ay - by));\n  return P(((ay * ay + ax * ax) * (by - cy) + by * by + bx * bx * (cy - ay) +\n\t    (cy * cy + cx * cx) * (ay - by)) / D,\n\t   ((ay * ay + ax * ax) * (cx - bx) + by * by + bx * bx * (ax - cx) +\n\t    (cy * cy + cx * cx) * (bx - ax)) / D);\n}\n\n// 外接円の半径を出す\ndouble circumscribedCircleRadius(double a, double b, double c) {return a * b * c / (4 * aTri(a, b, c));}\n\n// 多角形の内外判定 内部:1、周上:0、外部:-1\nint sGP(Pol pol, P p) {\n  int side = -1;\n  rep (i, pol.size()) {\n    P p0 = pol[i] - p, p1 = pol[(i + 1) % pol.size()] - p;\n    if (sig(cross(p0, p1)) == 0 && sig(dot(p0, p1)) <= 0) return 0;\n    if (p0.Y > p1.Y) swap(p0, p1);\n    if (sig(p0.Y) <= 0 && 0 < sig(p1.Y) && sig(cross(p0, p1)) > 0) side *= -1;\n  }\n  return side;\n}\n\n// 凸包\nPol convexHull(Pol p) {\n  int m = 0;\n  vector<P> q(p.size() * 2);\n  sort(p.begin(), p.end(), lessX);\n  for (int i = 0; i < int(p.size()); q[m++] = p[i++]) for (; m > 1 && sig(cross(q[m - 1] - q[m - 2], p[i] - q[m - 2])) <= 0; --m);\n  for (int i = p.size() - 2, r = m; i >= 0; q[m++] = p[i--]) for (; m > r && sig(cross(q[m - 1] - q[m - 2], p[i] - q[m - 2])) <= 0; --m);\n  q.resize(m - 1);\n  return q;\n}\n\n// 凸包カット\nPol convexCut(Pol p, L l) {\n  vector<P> q;\n  rep (i, p.size()) {\n    if (ccw(l, p[i]) & (LEFT | BACK | ON | FRONT)) q.push_back(p[i]);\n    if (iLSs(l, L(p[i], p[(i + 1) % p.size()]))) q.push_back(pLL(l, L(p[i], p[(i + 1) % p.size()])));\n  }\n  return q;\n}\n\n// 共通コンベックス\nvector<P> convexAnd(vector<P> &p1, vector<P> &p2) {\n  int n1 = p1.size(), n2 = p2.size();\n  vector<P> ret;\n  // 凸形同士の交点\n  for(int i = 0; i < n1; ++i){\n    L li(p1[i], p1[(i + 1) % n1]);\n    for(int j = 0; j < n2; ++j){\n      L lj(p2[j], p2[(j + 1) % n2]);\n      P intersection;\n      if(iLL(li, lj)){\n\tintersection = pLL(li, lj);\n\tret.push_back(intersection);\n      }\n    }\n  }\n  // それぞれの凸形に含まれる点\n  for(int i = 0; i < n1; ++i){\n    if(sGP(p2, p1[i]) >= 0){\n      ret.push_back(p1[i]);\n    }\n  }\n  for(int i = 0; i < n2; ++i){\n    if(sGP(p1, p2[i]) >= 0){\n      ret.push_back(p2[i]);\n    }\n  }\n  // 重なり合いを消す\n  rep (i, ret.size()){\n    rep (j, ret.size()){\n      if (near(ret[i], ret[j])){\n\tret.erase(ret.begin() + j);\n\t--i;\n\tbreak;\n      }\n    }\n  }\n  return convexHull(ret);\n}\n\n/*\n  　反時計回りの点列で与えられる多角形を三角形で分割する。\n  　分割方法は規定しない。\n  (LLL,LLR,RLR,RLL)\n*/\nvoid triangulate(vector<P> &vp, vector<triangle> &out) {\n  vector<P> p = vp;\n  string s;\n  rep (f, vp.size() * vp.size()) {\n    int n = p.size();\n    if (n < 3) break;\n    int i = (f + 2 * n) % n;\n    int vccw = ccw(L(p[i % n], p[(i + 1) % n]), p[(i + 2) % n]);\n    switch (vccw) {\n    case LEFT: s += 'L'; break;\n    case FRONT: p.erase(p.begin()+(i+1)%n);f-=3; continue;\n    case RIGHT: s += 'R';\n    }\n    if(s.length() == 3){\n      //cout << s << endl;\n      if(s == \"LLL\" || s == \"LLR\" || s == \"RLR\" || s == \"RLL\"){\n\tbool doSkip = false;\n\ttriangle t(p[(i - 1 + n) % n], p[i], p[(i + 1) % n]);\n\tfor (int j = 0; j < n; ++j) if (t.contains(p[j])) {doSkip = true; break;}\n\tif (!doSkip) {out.push_back(t); p.erase(p.begin() + i); f -= 3;}\n\telse {f -= 2;}\n      } else {f -= 2;}\n      s = \"\";\n    }\n  }\n}\n\n// ボロノイ図構築各母点についてのボノロイ頂点が反時計回りに与えられる\nvector<Pol> makeVolonoi(vector<P> vp, Pol plane) {\n  vector<Pol> res;\n  Pol tplane;\n  rep (i, vp.size()) {\n    tplane = plane;\n    rep (j, vp.size()) if (i != j) {\n      P p = (vp[i] + vp[j]) / 2.;\n      L l = L(p, p + (vp[j] - vp[i]) * P(0, 1));\n      tplane = convexCut(tplane, l);\n    }\n    res.push_back(tplane);\n  }\n  return res;\n}\n\n// 線分をマージする\nvector<L> merge(vector<L> s) {\n  vector<L> segs;\n  bool update = true;\n  while (update) {\n    update = false;\n    rep (i, s.size()) {\n      bool ok = true;\n      rep (j, segs.size()) {\n\tif (iSS(s[i], segs[j]) && eq(cross(vec(s[i]), vec(segs[j])), 0)) {\n\t  vector<P> v;\n\t  v.push_back(s[i].first);\n\t  v.push_back(s[i].second);\n\t  v.push_back(segs[j].first);\n\t  v.push_back(segs[j].second);\n\t  sort(v.begin(), v.end(), lessX);\n\t  segs[j] = L(v[0], v[3]);\n\t  ok = false;\n\t  update = true;\n\t  break;\n\t}\n      }\n      if (ok) segs.push_back(s[i]);\n    }\n    s = segs;\n    segs.clear();\n  }\n  return s;\n}\n\n// 線分アレンジメント 隣の点への辺のみを持つ\npair<vector<P>, vector<vector<int> > > sArr(vector<L> s) {\n  s = merge(s);\n  vector<P> vp;\n  rep (i, s.size()) {\n    vp.push_back(s[i].first);\n    vp.push_back(s[i].second);\n  }\n  rep (i,s.size()) {\n    rep (j, i) if (iSS(s[i], s[j])) {\n      vp.push_back(pLL(s[i], s[j]));\n    }\n  }\n  sort(vp.begin(), vp.end(), lessX);\n  vp.erase(unique(vp.begin(), vp.end(), near), vp.end());\n  vector<vector<int> > g(vp.size());\n  rep (i, s.size()) {\n    vector<pair<double, int> > v;\n    rep (j, vp.size()) if (ccw(s[i], vp[j]) == ON) {\n      v.push_back(make_pair(norm(vp[j] - s[i].first), j));\n    }\n    sort(v.begin(), v.end());\n    rep (j, v.size() - 1) {\n      g[v[j + 1].second].push_back(v[j].second);\n      g[v[j].second].push_back(v[j + 1].second);\n    }\n  }\n  return make_pair(vp, g);\n}\n\n// マンハッタン距離\ndouble dmPP(P a, P b) {return abs(a.X - b.X) + abs(a.Y - b.Y);}\ndouble dmSP(L s, P p) {\n  double res = min(dmPP(s.first, p), dmPP(s.second, p));\n  L l = L(p, p + P(1, 0));\n  if (iLS(l, s) && !eq(cross(vec(l), vec(s)), 0)) {\n    P pp = pLL(l, s);\n    res = min(res, dmPP(p, pp));\n  }\n  l = L(p, p + P(0, 1));\n  if (iLS(l, s) && !eq(cross(vec(l), vec(s)), 0)) {\n    P pp = pLL(l, s);\n    res = min(res, dmPP(p, pp));\n  }\n  return res;\n}\ndouble dmSS(L a, L b) {return iSS(a, b) ? 0 : min(min(dmSP(a, b.first), dmSP(a, b.second)), min(dmSP(b, a.first), dmSP(b, a.second)));}\n\nint main() {\n  int n;\n  Pol plane;\n  plane.push_back(0);\n  plane.push_back(P(4, 0));\n  plane.push_back(P(4, 4));\n  plane.push_back(P(0, 4));\n  for (;;) {\n    cin >> n;\n    if (n == 0) break;\n    vector<P> v;\n    rep (i, n) {\n      P p;\n      cin >> p.X >> p.Y;\n      v.push_back(p);\n    }\n    vector<Pol> vol = makeVolonoi(v, plane);\n    vector<L> vs;\n    rep (i, n) {\n      int m = vol[i].size();\n      rep (j, m) {\n\tif (eq(vol[i][j].X, 0) && eq(vol[i][(j + 1) % m].X, 0)) continue;\n\tif (eq(vol[i][j].Y, 0) && eq(vol[i][(j + 1) % m].Y, 0)) continue;\n\tif (eq(vol[i][j].X, 4) && eq(vol[i][(j + 1) % m].X, 4)) continue;\n\tif (eq(vol[i][j].Y, 4) && eq(vol[i][(j + 1) % m].Y, 4)) continue;\n\tvs.push_back(L(vol[i][j], vol[i][(j + 1) % m]));\n      }\n    }\n    pair<vector<P>, vector<vector<int> > > arr = sArr(vs);\n    vector<P> vp = arr.first;\n    vector<vector<int> > vvi = arr.second;\n    int m = vp.size();\n    vector<double> mem(m);\n    rep (i, m) mem[i] = INF;\n    priority_queue<pair<double, int>, vector<pair<double, int> >, greater<pair<double, int> > > que;\n    rep (i, m) if (eq(vp[i].X, 0)) {\n      que.push(make_pair(0, i));\n    }\n    while (!que.empty()) {\n      pair<double, int> now = que.top();\n      que.pop();\n      if (mem[now.second] <= now.first) continue;\n      mem[now.second] = now.first;\n      rep (i, vvi[now.second].size()) {\n\tP next = vp[vvi[now.second][i]];\n\tque.push(make_pair(now.first + abs(vp[now.second] - next), vvi[now.second][i]));\n      }\n    }\n    double res = INF;\n    rep (i, m) if (eq(vp[i].X, 4)) {\n      res = min(res, mem[i]);\n    }\n    if (!eq(res, INF)) printf(\"%.12lf\\n\", res);\n    else puts(\"impossible\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tprint_tuple<Cdr...>(os,t);\n\tos<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C,typename=decltype(begin(C()))>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\nconstexpr double PI=acos(-1);\n\nstruct Point{\n\tdouble x,y;\n\tPoint(){}\n\tPoint(double x,double y):x(x),y(y){}\n\tPoint& operator+=(Point p){x+=p.x,y+=p.y; return *this;}\n\tPoint& operator-=(Point p){x-=p.x,y-=p.y; return *this;}\n\tPoint& operator*=(double c){x*=c,y*=c; return *this;}\n\tPoint& operator/=(double c){x/=c,y/=c; return *this;}\n};\nPoint operator+(Point a,Point b){return a+=b;}\nPoint operator-(Point a,Point b){return a-=b;}\nPoint operator*(Point a,double c){return a*=c;}\nPoint operator*(double c,Point a){return a*=c;}\nPoint operator/(Point a,double c){return a/=c;}\nbool operator==(Point a,Point b){return abs(a.x-b.x)<EPS && abs(a.y-b.y)<EPS;}\nbool operator!=(Point a,Point b){return !(a==b);}\nbool operator<(const Point& a,const Point& b){\n\treturn abs(a.x-b.x)>EPS?a.x<b.x:abs(a.y-b.y)>EPS?a.y<b.y:false;\n}\n\n\nstruct Line{\n\tPoint pos,dir;\n\tLine(){}\n\tLine(Point p,Point d):pos(p),dir(d){}\n\tLine(double x,double y,double u,double v):pos(x,y),dir(u,v){}\n};\nstruct Segment{\n\tPoint pos,dir;\n\tSegment(){}\n\tSegment(Point p,Point d):pos(p),dir(d){}\n\tSegment(double x,double y,double u,double v):pos(x,y),dir(u,v){}\n\texplicit Segment(Line l):pos(l.pos),dir(l.dir){}\n\texplicit operator Line()const{return Line(pos,dir);}\n};\n\nostream& operator<<(ostream& os,const Point& p){\n\treturn os<<'('<<p.x<<','<<p.y<<')';\n}\nostream& operator<<(ostream& os,const Line& l){\n\treturn os<<'('<<l.pos<<','<<l.dir<<')';\n}\nostream& operator<<(ostream& os,const Segment& s){\n\treturn os<<'('<<s.pos<<','<<s.dir<<')';\n}\n\nint Signum(double x){\n\treturn x<-EPS?-1:x>EPS?1:0;\n}\ndouble Abs(Point p){\n\treturn sqrt(p.x*p.x+p.y*p.y);\n}\ndouble Abs2(Point p){\n\treturn p.x*p.x+p.y*p.y;\n}\ndouble Dot(Point a,Point b){\n\treturn a.x*b.x+a.y*b.y;\n}\ndouble Cross(Point a,Point b){\n\treturn a.x*b.y-a.y*b.x;\n}\nPoint Rot(Point p,double t){\n\treturn Point(cos(t)*p.x-sin(t)*p.y,sin(t)*p.x+cos(t)*p.y);\n}\n\nint CCW(Point a,Point b,Point c){\n\tb-=a,c-=a;\n\tif(int sign=Signum(Cross(b,c)))\n\t\treturn sign; // 1:ccw,-1:cw\n\tif(Dot(b,c)<-EPS)\n\t\treturn -2;   // c-a-b\n\tif(Abs2(b)<Abs2(c)-EPS)\n\t\treturn 2;    // a-b-c\n\treturn 0;        // a-c-b (inclusive)\n}\n\nbool IntersectSP(Segment s,Point p){\n\treturn CCW(s.pos,s.pos+s.dir,p)==0;\n}\nbool IntersectSS(Segment a,Segment b){\n\tint c1=CCW(a.pos,a.pos+a.dir,b.pos),c2=CCW(a.pos,a.pos+a.dir,b.pos+b.dir);\n\tint c3=CCW(b.pos,b.pos+b.dir,a.pos),c4=CCW(b.pos,b.pos+b.dir,a.pos+a.dir);\n\treturn c1*c2<=0 && c3*c4<=0;\n}\nPoint InterPointLL(Line a,Line b){\n\tif(abs(Cross(a.dir,b.dir))<EPS) return a.pos;\n\treturn a.pos+Cross(b.pos-a.pos,b.dir)/Cross(a.dir,b.dir)*a.dir;\n}\nPoint InterPointLS(Line l,Segment s){\n\treturn InterPointLL(Line(s),l);\n}\nPoint InterPointSS(Segment a,Segment b){\n\tif(abs(Cross(a.dir,b.dir))<EPS){\n\t\tif(IntersectSP(b,a.pos)) return a.pos;\n\t\tif(IntersectSP(b,a.pos+a.dir)) return a.pos+a.dir;\n\t\tif(IntersectSP(a,b.pos)) return b.pos;\n\t\tif(IntersectSP(a,b.pos+b.dir)) return b.pos+b.dir;\n\t}\n\treturn InterPointLL(Line(a),Line(b));\n}\n\nvector<Point> ConvexCut(const vector<Point>& ps,Line l){\n\tint n=ps.size();\n\tvector<Point> res;\n\trep(i,n){\n\t\tint c1=CCW(l.pos,l.pos+l.dir,ps[i]);\n\t\tint c2=CCW(l.pos,l.pos+l.dir,ps[(i+1)%n]);\n\t\tif(c1!=-1)\n\t\t\tres.push_back(ps[i]);\n\t\tif(c1*c2==-1)\n\t\t\tres.push_back(InterPointLS(l,Segment(ps[i],ps[(i+1)%n]-ps[i])));\n\t}\n\treturn res;\n}\n\nstruct Edge{\n\tint src,dst;\n\tdouble weight;\n\tEdge(){}\n\tEdge(int s,int d,double w):src(s),dst(d),weight(w){}\n\tbool operator<(const Edge& e)const{return Signum(weight-e.weight)<0;}\n\tbool operator>(const Edge& e)const{return Signum(weight-e.weight)>0;}\n};\ntypedef vector<vector<Edge>> Graph;\n\nvoid SegmentArrangement(const vector<Segment>& ss,Graph& g,vector<Point>& ps){\n\trep(i,ss.size()){\n\t\tps.push_back(ss[i].pos);\n\t\tps.push_back(ss[i].pos+ss[i].dir);\n\t\trepi(j,i+1,ss.size()) if(IntersectSS(ss[i],ss[j]))\n\t\t\tps.push_back(InterPointSS(ss[i],ss[j]));\n\t}\n\tsort(all(ps));\n\t\t\n\tps.erase(unique(all(ps)),ps.end());\n\t\n\tg.resize(ps.size());\n\trep(i,ss.size()){\n\t\tvector<pair<double,int> > ds;\n\t\trep(j,ps.size()) if(IntersectSP(ss[i],ps[j]))\n\t\t\tds.push_back(mp(Abs(ps[j]-ss[i].pos),j));\n\t\tsort(all(ds));\n\t\trep(j,ds.size()-1){\n\t\t\tint u=ds[j].second,v=ds[j+1].second;\n\t\t\tdouble w=ds[j+1].first-ds[j].first;\n\t\t\tg[u].push_back(Edge(u,v,w));\n\t\t\tg[v].push_back(Edge(v,u,w));\n\t\t}\n\t}\n}\n\nvoid Dijkstra(const Graph& g,int v,vd& dist)\n{\n\tpriority_queue<Edge,vector<Edge>,greater<Edge>> pq;\n\tpq.emplace(-1,v,0);\n\twhile(pq.size()){\n\t\tEdge cur=pq.top(); pq.pop();\n\t\tif(dist[cur.dst]!=INF) continue;\n\t\tdist[cur.dst]=cur.weight;\n\t\tfor(Edge e:g[cur.dst])\n\t\t\tpq.emplace(e.src,e.dst,cur.weight+e.weight);\n\t}\n}\n\nint main()\n{\n\tfor(int n;cin>>n && n;){\n\t\tvector<Point> ps(n);\n\t\tfor(auto& p:ps) cin>>p.x>>p.y;\n\t\t\n\t\tvector<Segment> ss;\n\t\t{\n\t\t\tset<pair<Point,Point>> tmp;\n\t\t\trep(i,n){\n\t\t\t\tvector<Point> cs={Point(0,0),Point(4,0),Point(4,4),Point(0,4)};\n\t\t\t\trep(j,n) if(j!=i){\n\t\t\t\t\tLine l((ps[j]+ps[i])/2,Rot(ps[j]-ps[i],PI/2));\n\t\t\t\t\tcs=ConvexCut(cs,l);\n\t\t\t\t}\n\t\t\t\trep(i,cs.size()){\n\t\t\t\t\tPoint p1=cs[i],p2=cs[(i+1)%cs.size()];\n\t\t\t\t\tif((abs(p1.y)<EPS || abs(p1.y-4)<EPS) && abs(p2.y-p1.y)<EPS)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\ttmp.insert(mp(min(p1,p2),max(p1,p2)));\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(auto p:tmp) ss.emplace_back(p.first,p.second-p.first);\n\t\t}\n\t\t\n\t\tGraph g;\n\t\tvector<Point> qs;\n\t\tSegmentArrangement(ss,g,qs);\n\t\t\n\t\tvd dist(qs.size(),INF);\n\t\tpriority_queue<Edge,vector<Edge>,greater<Edge>> pq;\n\t\trep(i,qs.size()) if(abs(qs[i].x)<EPS) pq.emplace(-1,i,0);\n\t\twhile(pq.size()){\n\t\t\tEdge cur=pq.top(); pq.pop();\n\t\t\tif(dist[cur.dst]!=INF) continue;\n\t\t\tdist[cur.dst]=cur.weight;\n\t\t\tfor(Edge e:g[cur.dst])\n\t\t\t\tpq.emplace(e.src,e.dst,cur.weight+e.weight);\n\t\t}\n\t\t\n\t\tdouble res=INF;\n\t\trep(i,qs.size()) if(abs(qs[i].x-4)<EPS) res=min(res,dist[i]);\n\t\tif(res==INF) puts(\"impossible\");\n\t\telse         printf(\"%.12f\\n\",res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst double EPS = 1e-10, PI = acos(-1);\n\ninline bool eq(double a, double b) { return abs(b - a) < EPS; }\n\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define prev(P, i) P[(i+P.size()-1) % P.size()]\n\nenum\n{\n  OUT, ON, IN\n};\nnamespace Geometory\n{\n  struct Point\n  {\n    double x, y;\n\n    Point() {};\n\n    Point(double x, double y) : x(x), y(y) {};\n\n    Point operator+(const Point &b) const { return Point(x + b.x, y + b.y); }\n\n    Point operator-(const Point &b) const { return Point(x - b.x, y - b.y); }\n\n    Point operator*(const double b) const { return Point(x * b, y * b); }\n\n    Point operator*(const Point &b) const { return Point(x * b.x - y * b.y, x * b.y + y * b.x); }\n\n    Point operator/(const double b) const { return Point(x / b, y / b); }\n\n    bool operator<(const Point &b) const { return x != b.x ? x < b.x : y < b.y; }\n\n    bool operator==(const Point &b) const { return eq(x, b.x) && eq(y, b.y); }\n\n    double norm() { return x * x + y * y; }\n\n    double arg() { return atan2(x, y); }\n\n    double abs() { return sqrt(norm()); }\n\n    Point rotate(double theta) { return Point(cos(theta) * x - sin(theta) * y, sin(theta) * x + cos(theta) * y); }\n\n    Point rotate90() { return Point(-y, x); }\n\n    friend ostream &operator<<(ostream &os, Point &p) { return os << \"(\" << p.x << \",\" << p.y << \")\"; }\n\n    friend istream &operator>>(istream &is, Point &a) { return is >> a.x >> a.y; }\n  };\n\n  struct Line\n  {\n    Point a, b;\n\n    Line() {};\n\n    Line(Point a, Point b) : a(a), b(b) {};\n\n    friend ostream &operator<<(ostream &os, Line &p) { return os << \"(\" << p.a.x << \",\" << p.a.y << \") to (\" << p.b.x << \",\" << p.b.y << \")\"; }\n\n    friend istream &operator>>(istream &is, Line &a) { return is >> a.a.x >> a.a.y >> a.b.x >> a.b.y; }\n  };\n\n  struct Segment\n  {\n    Point a, b;\n\n    Segment() {};\n\n    Segment(Point a, Point b) : a(a), b(b) {};\n\n    friend ostream &operator<<(ostream &os, Segment &p) { return os << \"(\" << p.a.x << \",\" << p.a.y << \") to (\" << p.b.x << \",\" << p.b.y << \")\"; }\n\n    friend istream &operator>>(istream &is, Segment &a) { return is >> a.a.x >> a.a.y >> a.b.x >> a.b.y; }\n  };\n\n  typedef vector< Point > Polygon;\n  typedef vector< Segment > Segments;\n\n  double cross(const Point &a, const Point &b)\n  {\n    return a.x * b.y - a.y * b.x;\n  }\n\n  double dot(const Point &a, const Point &b)\n  {\n    return a.x * b.x + a.y * b.y;\n  }\n\n  int ccw(const Point &a, Point b, Point c)\n  {\n    b = b - a, c = c - a;\n    if(cross(b, c) > EPS) return +1;\n    if(cross(b, c) < -EPS) return -1;\n    if(dot(b, c) < 0) return +2;\n    if(b.norm() < c.norm()) return -2;\n    return 0;\n  }\n\n  Point Crosspoint(const Line &l, const Line &m)\n  {\n    double A = cross(l.b - l.a, m.b - m.a);\n    double B = cross(l.b - l.a, l.b - m.a);\n    if(abs(A) < EPS && abs(B) < EPS) return m.a;\n    return m.a + (m.b - m.a) * B / A;\n  }\n\n  Line Bisector(Point a, Point b)\n  {\n    Point c = (a + b) * 0.5;\n    Point p = Point(c.x + (a.y - b.y), c.y + (b.x - a.x));\n    return (Line(c, p));\n  }\n\n  Polygon Convex_Cut(Polygon &U, Line l)\n  {\n    Polygon ret;\n    for(int i = 0; i < U.size(); i++) {\n      Point now = curr(U, i), nxt = next(U, i);\n      if(ccw(l.a, l.b, now) != -1) ret.push_back(now);\n      if(ccw(l.a, l.b, now) * ccw(l.a, l.b, nxt) < 0) {\n        ret.push_back(Crosspoint(Line(now, nxt), l));\n      }\n    }\n    return (ret);\n  }\n};\n\nint main()\n{\n  int N;\n  while(cin >> N, N) {\n    vector< Geometory::Point > points(N);\n    Geometory::Polygon U(4);\n    U[0] = Geometory::Point(0, 0);\n    U[1] = Geometory::Point(4, 0);\n    U[2] = Geometory::Point(4, 4);\n    U[3] = Geometory::Point(0, 4);\n\n    for(int i = 0; i < N; i++) {\n      cin >> points[i];\n    }\n\n    vector< Geometory::Polygon > voronoi(N);\n    for(int i = 0; i < N; i++) {\n      voronoi[i] = U;\n      for(int j = 0; j < N; j++) {\n        if(i == j) continue;\n        voronoi[i] = Geometory::Convex_Cut(voronoi[i], Geometory::Bisector(points[i], points[j]));\n      }\n    }\n\n    vector< Geometory::Point > ventex;\n    for(int i = 0; i < N; i++) {\n      for(auto &point : voronoi[i]) ventex.push_back(point);\n    }\n\n    vector< vector< double > > g(ventex.size(), vector< double >(ventex.size(), 1e9));\n\n    for(int i = 0; i < ventex.size(); i++) {\n      for(int j = i + 1; j < ventex.size(); j++) {\n        auto &a = ventex[i], &b = ventex[j];\n        int near = 0;\n        for(int k = 0; k < N; k++) {\n          for(int l = 0; l < voronoi[k].size(); l++) {\n            auto &c = curr(voronoi[k], l), &d = next(voronoi[k], l);\n            if((a == c && b == d) || (a == d && b == c)) ++near;\n          }\n        }\n        if(near >= 2) g[i][j] = g[j][i] = (ventex[i] - ventex[j]).abs();\n      }\n    }\n\n\n    for(int k = 0; k < ventex.size(); k++) {\n      for(int i = 0; i < ventex.size(); i++) {\n        for(int j = 0; j < ventex.size(); j++) {\n          g[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n        }\n      }\n    }\n\n    double cost = 1e9;\n    for(int i = 0; i < ventex.size(); i++) {\n      for(int j = 0; j < ventex.size(); j++) {\n        if(eq(ventex[i].x, 0) && eq(ventex[j].x, 4)) cost = min(cost, g[i][j]);\n      }\n    }\n\n    if(eq(cost, 1e9)) cout << \"impossible\" << endl;\n    else cout << fixed << setprecision(15) << cost << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(arg),key)-begin(arg)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n\nusing namespace std;\n\ntemplate<class T>void reg(vector<T> &ary,const T &elem){ary.emplace_back(elem);}\ntemplate<class T>bool chmin(T &a, const T &b) {return (b<a)?(a=b,1):0;}\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\n\nusing R=long double; // __float128\nconst R EPS = 1E-10; // [-1000:1000]->EPS=1e-8 [-10000:10000]->EPS=1e-7\nconst R INF = 1E40;\nconstexpr R PI = acos(R(-1));\ninline int sgn(const R& r){ return (r > EPS) - (r < -EPS);}\ninline int sgn(const R& a, const R &b){ return sgn(a-b); }\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n\nusing P=complex<R>;\nusing VP=vector<P>;\nusing L=struct{P s,t;};\nusing VL=vector<L>;\nusing C=struct{P c;R r;};\nusing VC=vector<C>;\n\nconstexpr P O = P(0,0);\nistream& operator >> (istream& is,P& p){ R x,y;is >> x >> y; p=P(x,y); return is;}\nostream& operator << (ostream& os,P& p){ os << real(p) << \" \" << imag(p); return os;}\n\nnamespace std{\n\tbool operator <  (const P& a,const P& b){ return sgn(real(a-b))?real(a-b)<0:sgn(imag(a-b))<0;}\n\tbool operator == (const P& a,const P& b){ return sgn(real(a-b))==0 && sgn(imag(a-b))==0;}\n}\n\nbool operator <  (const L& a,const L& b){ return a.s==b.s?a.t<b.t:a.s<b.s;}\nbool operator == (const L& a,const L& b){ return a.s==b.s&&a.t==b.t;}\n\n//?????? dot ?????? det\ninline R dot(P o,P a,P b){a-=o,b-=o; return real(conj(a)*b);}\ninline R det(P o,P a,P b){a-=o,b-=o; return imag(conj(a)*b);}\n\n// CCW verify AOJ CGL_1_C\nenum CCW{ LEFT = 1,RIGHT = 2,BACK = 4,FRONT = 8,ON = 16};\ninline int ccw(P o,P a, P b) {//???a??¨???b???????????????????????????\n\tif (sgn(det(o,a,b)) > 0) return LEFT;    // counter clockwise\n\tif (sgn(det(o,a,b)) < 0) return RIGHT;   // clockwise\n\tif (sgn(dot(o,a,b)) < 0) return BACK;    // b--base--a on line\n\tif (sgn(norm(a-o)-norm(b-o)) < 0) return FRONT;   // base--a--b on line\n\treturn ON;// base--b--a on line  a??¨b????????????????????????\n}\n\n// ?????´ ?????? verify AOJ CGL_2_A\nbool vertical(L a, L b) {return sgn(dot(O,a.t-a.s,b.t-b.s))==0;}\nbool parallel(L a, L b) {return sgn(det(O,a.t-a.s,b.t-b.s))==0;}\nbool eql(L a,L b){ return (parallel(a,b) && sgn(det(a.s,a.t,b.s))==0);}\n\n\n// ???????????????verify AOJ CGL_2_B ???????????????????????´??????1,????????´??????0\nbool iss(L a,L b,int end=0){\n\tint s1=ccw(a.s,a.t,b.s)|ccw(a.s,a.t,b.t);\n\tint s2=ccw(b.s,b.t,a.s)|ccw(b.s,b.t,a.t);\n\tif(end) return (s1&s2)==(LEFT|RIGHT);\n\treturn (s1|s2)&ON || (s1&s2)==(LEFT|RIGHT);\n}\n\n// ?????? verify AOJ CGL_2_C\nP cross(L a,L b){\n\tR s1=det(a.s,b.s,b.t);\n\tR s2=s1+det(a.t,b.t,b.s);\n\treturn a.s+s1/s2*(a.t-a.s);\n}\n\t\n// ???????????? verify AOJ CGL_4_C\nVP convex_cut(const VP& pol,const L& l) {\n\tVP res;\n\tint n=pol.size();\n\trep(i,n){\n\t\tP a = pol[i],b=pol[(i+1)%n];\n\t\tif(ccw(l.s,l.t,a)!=RIGHT) reg(res,a);\n\t\tif((ccw(l.s,l.t,a)|ccw(l.s,l.t,b))==(LEFT|RIGHT)) reg(res,cross({a,b},l));\n\t}\n\treturn res;\n}\n\nconst int vmax=5010;\nstruct node{int to;R cost;};\nvector<node> graph[vmax];\ninline void add_edge(int f,int t,R c){reg(graph[f],{t,c}),reg(graph[t],{f,c});}\n\nvoid segment_arrangement(const vector<L> &seg, vector<P> &point){\n\trep(i,vmax) graph[i].clear();\n\trep(i,seg.size()){\n\t\treg(point,seg[i].s),reg(point,seg[i].t);\n\t\trep(j,i) if(iss(seg[i],seg[j])) reg(point,cross(seg[i],seg[j]));\n\t}\n\tuniq(point);\n\trep(i,seg.size()){\n\t\tvector<pair<R,int>> idx;\n\t\trep(j,point.size()) if(ccw(seg[i].s,seg[i].t,point[j])==ON) reg(idx,{norm(point[j]-seg[i].s),j});\n\t\tsort(_all(idx));\n\t\trep(j,1,int(idx.size())){\n\t\t\tint a=idx[j-1].second,b=idx[j].second;\n\t\t\tadd_edge(a,b,abs(point[a]-point[b]));\n\t\t}\n\t}\n}\n\nL bisector(P a, P b){P mid=(a+b)/P(2,0);return L{mid, mid+(b-a)*P(0,1)};}\nVP voronoi_cell(VP pol,VP v,int s){rep(i,v.size())if(i!=s)pol=convex_cut(pol,bisector(v[s],v[i]));return pol;}\n\nR dist[vmax];\nR dijkstra(const VP &point){\n\tfill(dist,dist+vmax,INF);\n\tusing state=tuple<R,int>;\n\tpriority_queue<state,vector<state>,greater<state>> q;\n\trep(s,point.size()) if(sgn(real(point[s]))==0) dist[s]=0,q.push(state(0,s));\n\twhile(!q.empty()){\n\t\tR c;int v;\n\t\ttie(c,v)=q.top();q.pop();\n\t\tfor(auto &e:graph[v]){\n\t\t\tR nc=c+e.cost; int nv=e.to;\n\t\t\tif(chmin(dist[nv],nc)) q.push(state(nc,nv));\n\t\t}\n\t}\n\tR res=INF;\n\trep(t,point.size()) if(sgn(real(point[t])-4.0)==0) chmin(res,dist[t]);\n\treturn res;\n}\n\n\nint main(void){\n\tint n;\n\twhile(cin >> n,n){\n\t\tVP pol={P(0,0),P(4,0),P(4,4),P(0,4)};\n\t\tVP vornoi,point;\n\t\tVL seg;\n\t\trep(i,n){\n\t\t\tP p;\n\t\t\tcin >> p;\n\t\t\treg(vornoi,p);\n\t\t}\n\t\trep(i,n){\n\t\t\tVP res=voronoi_cell(pol,vornoi,i);\n\t\t\tfor(auto &p:res) reg(point,p);\n\t\t\tint m=res.size();\n\t\t\trep(i,m){\n\t\t\t\tL l={res[i],res[(i+1)%m]};\n\t\t\t\tbool ok=true;\n\t\t\t\trep(i,4) if(eql(l,{pol[i],pol[(i+1)%4]})) ok=false;\n\t\t\t\tif(ok) reg(seg,l);\n\t\t\t}\n\t\t}\n\t\tsegment_arrangement(seg,point);\n\t\tR res=dijkstra(point);\n\t\tcout.precision(20);\n\t\tif(res>=INF)\n\t\t\tcout << \"impossible\" << endl;\n\t\telse\n\t\t\tcout << fixed << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<vector>\n#include<cstdio>\n#include<cstdlib>\n#include<map>\n#include<set>\n#include<iomanip>\n#include<ctime>\n#include<cassert>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define F first\n#define S second\n#define EPS (1e-7)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n#define MAX 1000\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n\n\nusing namespace std;\n\nclass Point\n{\n  public:\n  double x,y;\n\n  Point(double x = -1,double y = -1): x(x),y(y){}\n\n  Point operator + (Point p ){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}//※イケメンに限る\n\n  bool operator < (const Point& p) const\n  {\n    return !equals(x,p.x)?x<p.x:y<p.y;\n  }\n\n  bool operator == (const Point& p)const\n  {\n    return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n  }\n\n//必要に応じて\ndouble norm()\n{\nreturn x*x+y*y;\n}\n\n};\n\nstruct Segment\n{\n  Point p1,p2;\n  Segment(Point p1 = Point(-1,-1),Point p2 = Point(-1,-1)):p1(p1),p2(p2){}\n};\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\n\ndouble dot(Point a,Point b)\n{\n  return a.x*b.x + a.y*b.y;\n}\ndouble cross(Point a,Point b)\n{\n  return a.x*b.y - a.y*b.x;\n}\n\ndouble norm(Point a)\n{\n  return a.x*a.x+a.y*a.y;\n}\n\n\n\nclass Voronoi\n{\npublic:\n  Polygon poly;\n  vector<Point> cutpoints;\n\n  Voronoi(Polygon poly):poly(poly){}\n\n  double norm(Point p){\n    return p.x*p.x+p.y*p.y;\n  }\n \n  double abs(Point p){\n    return sqrt(norm(p));\n  }\n \n  Point polar(double a,double rad){\n    return Point(a*cos(rad),a*sin(rad));\n  }\n \n  double args(Point p){\n    return atan2(p.y,p.x);\n  }\n \n  double dot(Point a,Point b){\n    return a.x*b.x+a.y*b.y;\n  }\n \n  double cross(Point a,Point b){\n    return a.x*b.y-b.x*a.y;\n  }\n \n  Point project(Segment s,Point p){\n    Point base = s.p2 - s.p1;\n    double t = dot(p-s.p1,base)/base.norm();\n    return s.p1+base*t;\n  }\n \n  Point reflect (Segment s, Point p){\n    return p + (project(s,p)-p)*2.0;\n  }\n \n  int ccw(Point p0,Point p1,Point p2){\n    Point a = p1-p0;\n    Point b = p2-p0;\n    if(cross(a,b) > EPS) return COUNTER_CLOCKWISE;\n    if(cross(a,b) < -EPS) return CLOCKWISE;\n    if(dot(a,b) < -EPS) return ONLINE_BACK;\n    if(a.norm() < b.norm() ) return ONLINE_FRONT;\n    return ON_SEGMENT;\n  }\n \n  bool isIntersect(Point p1,Point p2,Point p3,Point p4){\n    return (ccw(p1,p2,p3) * ccw(p1,p2,p4) <= 0 && ccw(p3,p4,p1) * ccw(p3,p4,p2) <= 0 );\n  }\n \n  bool isIntersect(Segment s1,Segment s2){\n    return isIntersect(s1.p1,s1.p2,s2.p1,s2.p2);\n  }\n\n  Point getCrossPointSegments(Segment s1,Segment s2){\n    //assert(isIntersect(s1,s2));\n    Point base = s2.p2 - s2.p1;\n    double d1 = abs(cross(base,s1.p1-s2.p1));\n    double d2 = abs(cross(base,s1.p2-s2.p1));\n    double t = d1/(d1+d2);\n    return s1.p1+(s1.p2-s1.p1)*t;\n  }\n\n\n  Point getCrossPointLines( Line s1, Line s2){\n\n    Point a = s1.p2 - s1.p1;\n    Point base = s2.p2 -s2.p1;\n    return s1.p1 + a * (cross(base, s2.p1 - s1.p1)/cross(base, a));\n  }\n\n  Polygon cutPolygon( Polygon P, Line l ){\n    Polygon u;\n    \n    for ( int i = 0; i < P.size(); i++ ){\n      Point a = P[i], b = P[(i+1)%P.size()];\n\t\n      if ( ccw(l.p1, l.p2, a) != CLOCKWISE ) u.push_back(a);\n      if ( ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) == -1 ){\n\tcutpoints.push_back(getCrossPointLines(Segment(a,b),l));\n\tu.push_back(getCrossPointLines(Segment(a, b), l));\n      }\n    }   \n    return u;\n  } \n \n  Line CreateLine(Point p,Point pp){\n    Point mid = (p+pp)/2;\n    Point sl = pp-p;//原点に5\n    double rad = args(sl);\n    Point ap = polar(abs(sl),rad+M_PI/2)+mid;\n    //ap.x = abs(sl)*cos(rad+M_PI/2)+mid.x;\n    //ap.y = abs(sl)*sin(rad+M_PI/2)+mid.y;\n    return Line(mid,ap);\n  } \n \n  double AreaCalc(Polygon p){\n    double area = 0;\n    for(int i=0;i<p.size();i++)\n      area+=cross(p[i],p[(i+1)%p.size()]);\n    return fabs(area)/2.0;\n  } \n\n  //サイトposに対するボロノイセルV(pos)の面積を返す \n  //pointsは多角形の中に存在するサイトの集合]\n  //posはpoints中の自分の位置\n  double getAreaOfVoronoi(vector<Point>& points,int pos)\n  {\n    Polygon polx = poly;\n    int N = points.size();\n    for(int i=0;i<N;i++)\n      if(i != pos)\n\tpolx = cutPolygon(polx,CreateLine(points[pos],points[i]));\n    return AreaCalc(polx);\n  }  \n\n  /*\n   作成中\n   points[pos]を基準にcutPolygonした後のpolygonを返す\n   */\n  vector<Point> getPoints(vector<Point>& points,int pos)\n  {\n    set<Point> polyS;\n    cutpoints.clear();\n    for(int i=0;i<poly.size();i++)polyS.insert(poly[i]);\n    Polygon polx = poly;\n    int N = points.size();\n    //  cout << \"N = \" << N << endl;\n    for(int i=0;i<N;i++)\n      if(i != pos)\n\t{\n\t  polx = cutPolygon(polx,CreateLine(points[pos],points[i]));\n\t  Line line = CreateLine(points[pos],points[i]);\n\t  rep(i,4)\n\t    {\n\t      if( ccw(line.p1,line.p2,poly[i]) == ON_SEGMENT ||  ccw(line.p1,line.p2,poly[i]) == ONLINE_FRONT ||  ccw(line.p1,line.p2,poly[i]) == ONLINE_BACK)\n\t\t{\n\t\t  cutpoints.push_back(poly[i]);\n\t\t}\n\t    }\n\t}\n\n    /*\n      cout << \"polx ---\" << endl;\n    rep(i,polx.size())\n      {\n\tcout << polx[i].x << \",\" << polx[i].y << endl;\n      }\n    cout << endl;\n\n    cout << \"cutpoint ---\" <<endl;\n    rep(i,cutpoints.size())\n      {\n\tcout << cutpoints[i].x << \",\" << cutpoints[i].y << endl;\n      }\n    cout << endl;\n    */\n\n    vector<Point> ret;\n    for(int i=0;i<polx.size();i++)\n      {\n\tbool ok = false;\n\trep(j,cutpoints.size())\n\t  {\n\t \n\t    if(equals(polx[i].x,cutpoints[j].x) && equals(polx[i].y,cutpoints[j].y))\n\t      {\n\t\tok = true;\n\t\tbreak;\n\t      }\n\t  }\n\tif(ok)\n\t  ret.push_back(polx[i]);\n      }\n\n    /*\n    cout << \"ret ---\" <<endl;\n    rep(i,ret.size())\n      {\n\tcout << ret[i].x << \",\" << ret[i].y << endl;\n      }\n    cout << endl;\n    */\n    return ret;\n  }\n\n\n  vector<Point> getPoints2(vector<Point>& points,int pos)\n  {\n    set<Point> polyS;\n    for(int i=0;i<poly.size();i++)polyS.insert(poly[i]);\n    Polygon polx = poly;\n    int N = points.size();\n    for(int i=0;i<N;i++)\n      if(i != pos)\n\tpolx = cutPolygon(polx,CreateLine(points[pos],points[i]));\n    /*\n    vector<Point> ret;\n    const int MOD = 10000000;\n    for(int i=0;i<polx.size();i++)\n      {\n\t//if(polyS.find(polx[i]) == polyS.end())\n\tPoint p;\n\n\tp.x = floor(polx[i].x*MOD);\n\tp.x /= MOD;\n\n\tp.y = floor(polx[i].y*MOD);\n\tp.y /= MOD;\n\n\tret.push_back(p);\n      }\n    */\n    return polx;\n  }\n\n};\n\nbool check(vector<Point> &vec,Point p)\n{\n  rep(i,vec.size())\n    {\n      if(equals(vec[i].x,p.x) && equals(vec[i].y,p.y))return true;\n    }\n  return false;\n}\n\nint getIndex(vector<Point> &prep,Point p)\n{\n  rep(i,prep.size())\n    {\n      if(equals(prep[i].x,p.x) && equals(prep[i].y,p.y))\n\t{\n\t  return i;\n\t}\n    }\n\n  assert(false);\n}\n\nint n;\nlong double mincost[MAX][MAX];\n\nint main()\n{\n\n\n  /*\n  vector<Point> vec(4);\n  vec[0] = Point(0,0);\n  vec[1] = Point(4,0);\n  vec[2] = Point(4,4);\n  vec[3] = Point(0,4);\n\n  vector<Point> points;\n  points.push_back(Point(1,0.5));\n  points.push_back(Point(1,2.5));\n  points.push_back(Point(3,1.5));\n  points.push_back(Point(3,3.5));\n  //points.push_back();\n  Voronoi vol(vec);\n  vector<Point> that = vol.getPoints(points,1);\n\n  cout << \"the area = \" << vol.getAreaOfVoronoi(points,1) << endl;\n\n  cout << \"that.size() = \" << that.size() << endl;\n  rep(i,that.size())\n    cout << that[i].x << \" \" << that[i].y << endl; \n  */\n\n  //clock_t start,end;\n  //start = clock();\n  \n  while(cin >> n,n)\n    {\n      vector<Point> frame(4);\n      frame[0] = Point(0,0);\n      frame[1] = Point(4,0);\n      frame[2] = Point(4,4);\n      frame[3] = Point(0,4);\n      set<Point> sp;\n      rep(i,4)sp.insert(Point(frame[i]));\n\n      Voronoi vol(frame);\n\n      vector<Point> site(n);\n      rep(i,n)cin >> site[i].x >> site[i].y;\n\n      vector<Point> prep;\n      vector<vector<Point> > material;\n     \n      rep(i,n)\n\t{\n\t  material.push_back(vol.getPoints2(site,i));\n\t  material[i].push_back(material[i][0]); \n\t}\n\n\n\n      rep(i,n)\n\t{\n\t  vector<Point> crossP = vol.getPoints(site,i);\n\t  //material.push_back(crossP);\n\t  rep(j,crossP.size())\n\t    {\n\t      bool ok = true;\n\t      rep(k,prep.size())\n\t\t{\n\t\t  if(equals(crossP[j].x,prep[k].x) && equals(crossP[j].y,prep[k].y))\n\t\t    {\n\t\t      ok = false;\n\t\t      break;\n\t\t    }\t\t  \n\t\t}\n\t      if(ok)\n\t\t{\n\t\t  prep.push_back(crossP[j]);\n\t\t}\n\t    }\n\t}\n\n      /*\n      cout << \"--------\" << endl;\n      rep(i,prep.size())\n\tcout << prep[i].x << \",\" << prep[i].y << endl;\n      */\n      int N = prep.size();\n      vector<vector<double> > G(N,vector<double>(N));\n      rep(i,N)rep(j,N)G[i][j] = (i==j?0:1000);\n      map<Point,int> index;\n      vector<int> ST,ED;\n\n\n      //cout << \"prep === \" << endl;\n      rep(i,(int)prep.size())\n\t{\n\t  //cout << \"(\" << prep[i].x << \",\" << prep[i].y << \")\" << endl;\n\t  index[prep[i]] = i;\n\t  if(equals(prep[i].x,0))ST.push_back(i);\n\t  if(equals(prep[i].x,4))ED.push_back(i);\n\t}\n      //cout <<\"ST = \" << ST.size() << \", ED = \" << ED.size() << endl;\n\n\n      \n      if(ST.empty() || ED.empty())\n\t{\n\t  cout << \"impossible\" << endl;\n\t  continue;\n\t}\n      \n\n\n      rep(i,material.size())\n\t{\n\t  int prev = -1;\n\t  Point pp;\n\t  //cout << \"|||||||||||||||||||||||||||||\" << endl;\n\t  rep(j,material[i].size())\n\t    {\n\t      if(!check(prep,material[i][j]))\n\t\t{//frame に material[i][j] が含まれるならばアウト\n\t\t  prev = -1;\n\t\t  continue;\t     \n\t\t}\n\t      if(prev == -1)\n\t\t{\n\t\t  int pes = getIndex(prep,material[i][j]);\n\t\t  pp = prep[pes];\n\t\t  prev = pes;\n\t\t  continue;\n\t\t}\n\t      int next = getIndex(prep,material[i][j]);\n\t      \n\t      //cout <<  prev << \"(\" << pp.x << \",\" << pp.y << \") is able to go to \"<< next << \"(\"<< prep[next].x << \",\" << prep[next].y << \")\" << endl; \n\t      if(prev == next)continue;\n\t      double cost = sqrt(pow(prep[next].x-pp.x,2)+pow(prep[next].y-pp.y,2));\n\t      G[prev][next] = cost;\n\t      G[next][prev] = cost;\n\t      prev = next;\n\t      pp = prep[next];\n\t    }\n\t}\n \n\n      /*\n      cout << \"N--------------\" << endl;\n      rep(i,N)cout << \"i = \" << i << \" : (\" << prep[i].x << \",\" << prep[i].y << \")\" <<endl;     \n\n      cout << \"G--------------\" << endl;\n      rep(i,N)\n\t{\n\t  rep(j,N)\n\t    {\n\t      cout.width(10);\n\t      cout << setiosflags(ios::fixed) << setprecision(10) << G[i][j] << \" \";\n\t      //printf(\"%.10llf\",G[i][j]);\n\t    }\n\t  cout << endl;\n\t}\n      */\n\n\n\n      for(int k=0;k<N;k++)for(int i=0;i<N;i++)for(int j=0;j<N;j++)G[i][j] = min(G[i][j],G[i][k]+G[k][j]);\n\n      /*\n      cout << \"------------G-------------\" << endl;\n      rep(i,N)\n\t{\n\t  rep(j,N)\n\t    {\n\t      cout.width(10) ;\n\t      cout << setiosflags(ios::fixed) << setprecision(10) << G[i][j] << \" \";\n\t    }\n\t  cout << endl;\n\t}\n      cout << endl;\n      */\n\n      double ans = 1000;\n      rep(i,ST.size())rep(j,ED.size())ans = min(ans,G[ST[i]][ED[j]]);\n      cout << setiosflags(ios::fixed) << setprecision(12) << ans << endl;\n    }\n  //end = clock();\n  //cout << setiosflags(ios::fixed) << setprecision(10) << (double)(end-start)/CLOCKS_PER_SEC << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tprint_tuple<Cdr...>(os,t);\n\tos<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C,typename=decltype(begin(C()))>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\nconstexpr double PI=3.141592653589793;\n\nstruct Point{\n\tdouble x,y;\n\tPoint(){}\n\tPoint(double x,double y):x(x),y(y){}\n\tPoint& operator+=(Point p){x+=p.x,y+=p.y; return *this;}\n\tPoint& operator-=(Point p){x-=p.x,y-=p.y; return *this;}\n\tPoint& operator*=(double c){x*=c,y*=c; return *this;}\n\tPoint& operator/=(double c){x/=c,y/=c; return *this;}\n};\nPoint operator+(Point a,Point b){return a+=b;}\nPoint operator-(Point a,Point b){return a-=b;}\nPoint operator*(Point a,double c){return a*=c;}\nPoint operator*(double c,Point a){return a*=c;}\nPoint operator/(Point a,double c){return a/=c;}\nbool operator==(Point a,Point b){return abs(a.x-b.x)<EPS && abs(a.y-b.y)<EPS;}\nbool operator!=(Point a,Point b){return !(a==b);}\nbool operator<(const Point& a,const Point& b){\n\treturn abs(a.x-b.x)>EPS?a.x<b.x:abs(a.y-b.y)>EPS?a.y<b.y:false;\n}\n\n\nstruct Line{\n\tPoint pos,dir;\n\tLine(){}\n\tLine(Point p,Point d):pos(p),dir(d){}\n\tLine(double x,double y,double u,double v):pos(x,y),dir(u,v){}\n};\nstruct Segment{\n\tPoint pos,dir;\n\tSegment(){}\n\tSegment(Point p,Point d):pos(p),dir(d){}\n\tSegment(double x,double y,double u,double v):pos(x,y),dir(u,v){}\n\texplicit Segment(Line l):pos(l.pos),dir(l.dir){}\n\texplicit operator Line()const{return Line(pos,dir);}\n};\n\nostream& operator<<(ostream& os,const Point& p){\n\treturn os<<'('<<p.x<<','<<p.y<<')';\n}\nostream& operator<<(ostream& os,const Line& l){\n\treturn os<<'('<<l.pos<<','<<l.dir<<')';\n}\nostream& operator<<(ostream& os,const Segment& s){\n\treturn os<<'('<<s.pos<<','<<s.dir<<')';\n}\n\nint Signum(double x){\n\treturn x<-EPS?-1:x>EPS?1:0;\n}\ndouble Abs(Point p){\n\treturn sqrt(p.x*p.x+p.y*p.y);\n}\ndouble Abs2(Point p){\n\treturn p.x*p.x+p.y*p.y;\n}\ndouble Dot(Point a,Point b){\n\treturn a.x*b.x+a.y*b.y;\n}\ndouble Cross(Point a,Point b){\n\treturn a.x*b.y-a.y*b.x;\n}\nPoint Rot(Point p,double t){\n\treturn Point(cos(t)*p.x-sin(t)*p.y,sin(t)*p.x+cos(t)*p.y);\n}\n\nint CCW(Point a,Point b,Point c){\n\tb-=a,c-=a;\n\tif(int sign=Signum(Cross(b,c)))\n\t\treturn sign; // 1:ccw,-1:cw\n\tif(Dot(b,c)<-EPS)\n\t\treturn -2;   // c-a-b\n\tif(Abs2(b)<Abs2(c)-EPS)\n\t\treturn 2;    // a-b-c\n\treturn 0;        // a-c-b (inclusive)\n}\n\nbool IntersectSP(Segment s,Point p){\n\treturn CCW(s.pos,s.pos+s.dir,p)==0;\n}\nbool IntersectSS(Segment a,Segment b){\n\tint c1=CCW(a.pos,a.pos+a.dir,b.pos),c2=CCW(a.pos,a.pos+a.dir,b.pos+b.dir);\n\tint c3=CCW(b.pos,b.pos+b.dir,a.pos),c4=CCW(b.pos,b.pos+b.dir,a.pos+a.dir);\n\treturn c1*c2<=0 && c3*c4<=0;\n}\nPoint InterPointLL(Line a,Line b){\n\tif(abs(Cross(a.dir,b.dir))<EPS) return a.pos;\n\treturn a.pos+Cross(b.pos-a.pos,b.dir)/Cross(a.dir,b.dir)*a.dir;\n}\nPoint InterPointLS(Line l,Segment s){\n\treturn InterPointLL(Line(s),l);\n}\nPoint InterPointSS(Segment a,Segment b){\n\tif(abs(Cross(a.dir,b.dir))<EPS){\n\t\tif(IntersectSP(b,a.pos)) return a.pos;\n\t\tif(IntersectSP(b,a.pos+a.dir)) return a.pos+a.dir;\n\t\tif(IntersectSP(a,b.pos)) return b.pos;\n\t\tif(IntersectSP(a,b.pos+b.dir)) return b.pos+b.dir;\n\t}\n\treturn InterPointLL(Line(a),Line(b));\n}\n\nvector<Point> ConvexCut(const vector<Point>& ps,Line l){\n\tint n=ps.size();\n\tvector<Point> res;\n\trep(i,n){\n\t\tint c1=CCW(l.pos,l.pos+l.dir,ps[i]);\n\t\tint c2=CCW(l.pos,l.pos+l.dir,ps[(i+1)%n]);\n\t\tif(c1!=-1)\n\t\t\tres.push_back(ps[i]);\n\t\tif(c1*c2==-1)\n\t\t\tres.push_back(InterPointLS(l,Segment(ps[i],ps[(i+1)%n]-ps[i])));\n\t}\n\treturn res;\n}\n\nstruct Edge{\n\tint src,dst;\n\tdouble weight;\n\tEdge(){}\n\tEdge(int s,int d,double w):src(s),dst(d),weight(w){}\n\tbool operator<(const Edge& e)const{return Signum(weight-e.weight)<0;}\n\tbool operator>(const Edge& e)const{return Signum(weight-e.weight)>0;}\n};\ntypedef vector<vector<Edge>> Graph;\n\nvoid SegmentArrangement(const vector<Segment>& ss,Graph& g,vector<Point>& ps){\n\trep(i,ss.size()){\n\t\tps.push_back(ss[i].pos);\n\t\tps.push_back(ss[i].pos+ss[i].dir);\n\t\trepi(j,i+1,ss.size()) if(IntersectSS(ss[i],ss[j]))\n\t\t\tps.push_back(InterPointSS(ss[i],ss[j]));\n\t}\n\tsort(all(ps));\n\t\t\n\tps.erase(unique(all(ps)),ps.end());\n\t\n\tg.resize(ps.size());\n\trep(i,ss.size()){\n\t\tvector<pair<double,int> > ds;\n\t\trep(j,ps.size()) if(IntersectSP(ss[i],ps[j]))\n\t\t\tds.push_back(mp(Abs(ps[j]-ss[i].pos),j));\n\t\tsort(all(ds));\n\t\trep(j,ds.size()-1){\n\t\t\tint u=ds[j].second,v=ds[j+1].second;\n\t\t\tdouble w=ds[j+1].first-ds[j].first;\n\t\t\tg[u].push_back(Edge(u,v,w));\n\t\t\tg[v].push_back(Edge(v,u,w));\n\t\t}\n\t}\n}\n\nvoid Dijkstra(const Graph& g,int v,vd& dist)\n{\n\tpriority_queue<Edge,vector<Edge>,greater<Edge>> pq;\n\tpq.emplace(-1,v,0);\n\twhile(pq.size()){\n\t\tEdge cur=pq.top(); pq.pop();\n\t\tif(dist[cur.dst]!=INF) continue;\n\t\tdist[cur.dst]=cur.weight;\n\t\tfor(Edge e:g[cur.dst])\n\t\t\tpq.emplace(e.src,e.dst,cur.weight+e.weight);\n\t}\n}\n\nint main()\n{\n\tfor(int n;cin>>n && n;){\n\t\tvector<Point> ps(n);\n\t\tfor(auto& p:ps) cin>>p.x>>p.y;\n\t\t\n\t\tvector<Segment> ss;\n\t\t{\n\t\t\tset<pair<Point,Point>> tmp;\n\t\t\trep(i,n){\n\t\t\t\tvector<Point> cs={Point(0,0),Point(4,0),Point(4,4),Point(0,4)};\n\t\t\t\trep(j,n) if(j!=i){\n\t\t\t\t\tLine l((ps[j]+ps[i])/2,Rot(ps[j]-ps[i],PI/2));\n\t\t\t\t\tcs=ConvexCut(cs,l);\n\t\t\t\t}\n\t\t\t\trep(i,cs.size()){\n\t\t\t\t\tPoint p1=cs[i],p2=cs[(i+1)%cs.size()];\n\t\t\t\t\tif((abs(p1.y)<EPS || abs(p1.y-4)<EPS) && abs(p2.y-p1.y)<EPS)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\ttmp.insert(mp(min(p1,p2),max(p1,p2)));\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(auto p:tmp) ss.emplace_back(p.first,p.second-p.first);\n\t\t}\n\t\t\n\t\tGraph g;\n\t\tvector<Point> qs;\n\t\tSegmentArrangement(ss,g,qs);\n\t\t\n\t\tvd dist(qs.size(),INF);\n\t\tpriority_queue<Edge,vector<Edge>,greater<Edge>> pq;\n\t\trep(i,qs.size()) if(abs(qs[i].x)<EPS) pq.emplace(-1,i,0);\n\t\twhile(pq.size()){\n\t\t\tEdge cur=pq.top(); pq.pop();\n\t\t\tif(dist[cur.dst]!=INF) continue;\n\t\t\tdist[cur.dst]=cur.weight;\n\t\t\tfor(Edge e:g[cur.dst])\n\t\t\t\tpq.emplace(e.src,e.dst,cur.weight+e.weight);\n\t\t}\n\t\t\n\t\tdouble res=INF;\n\t\trep(i,qs.size()) if(abs(qs[i].x-4)<EPS) res=min(res,dist[i]);\n\t\tif(res==INF) puts(\"impossible\");\n\t\telse         printf(\"%.12f\\n\",res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n\nusing namespace std;\n\ntemplate<class T>void reg(vector<T> &ary,const T &elem){ary.emplace_back(elem);}\ntemplate<class T>bool chmin(T &a, const T &b) {return (b<a)?(a=b,1):0;}\n\nusing R=long double;\nconst R EPS = 1E-10;\nconst R INF = 1E40;\nconstexpr R PI = acos(R(-1));\ninline int sgn(const R& r){ return (r > EPS) - (r < -EPS);}\ninline int sgn(const R& a, const R &b){ return sgn(a-b); }\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n\nusing P=complex<R>;\nusing VP=vector<P>;\nusing L=struct{P s,t;};\nusing VL=vector<L>;\n\nconstexpr P O = P(0,0);\nistream& operator >> (istream& is,P& p){ R x,y;is >> x >> y; p=P(x,y); return is;}\n\nnamespace std{\n\tbool operator <  (const P& a,const P& b){ return sgn(real(a-b))?real(a-b)<0:sgn(imag(a-b))<0;}\n\tbool operator == (const P& a,const P& b){ return sgn(real(a-b))==0 && sgn(imag(a-b))==0;}\n}\n\ninline R dot(P o,P a,P b){a-=o,b-=o; return real(conj(a)*b);}\ninline R det(P o,P a,P b){a-=o,b-=o; return imag(conj(a)*b);}\n\nenum CCW{ LEFT = 1,RIGHT = 2,BACK = 4,FRONT = 8,ON = 16};\ninline int ccw(P o,P a, P b) {\n\tif (sgn(det(o,a,b)) > 0) return LEFT;\n\tif (sgn(det(o,a,b)) < 0) return RIGHT;\n\tif (sgn(dot(o,a,b)) < 0) return BACK;\n\tif (sgn(norm(a-o)-norm(b-o)) < 0) return FRONT;\n\treturn ON;\n}\n\nbool parallel(L a, L b) {return sgn(det(O,a.t-a.s,b.t-b.s))==0;}\nbool eql(L a,L b){ return (parallel(a,b) && sgn(det(a.s,a.t,b.s))==0);}\n\nbool iss(L a,L b,int end=0){\n\tint s1=ccw(a.s,a.t,b.s)|ccw(a.s,a.t,b.t);\n\tint s2=ccw(b.s,b.t,a.s)|ccw(b.s,b.t,a.t);\n\tif(end) return (s1&s2)==(LEFT|RIGHT);\n\treturn (s1|s2)&ON || (s1&s2)==(LEFT|RIGHT);\n}\n\nP cross(L a,L b){\n\tR s1=det(a.s,b.s,b.t);\n\tR s2=s1+det(a.t,b.t,b.s);\n\treturn a.s+s1/s2*(a.t-a.s);\n}\n\t\nVP convex_cut(const VP& pol,const L& l) {\n\tVP res;\n\tint n=pol.size();\n\trep(i,n){\n\t\tP a = pol[i],b=pol[(i+1)%n];\n\t\tif(ccw(l.s,l.t,a)!=RIGHT) reg(res,a);\n\t\tif((ccw(l.s,l.t,a)|ccw(l.s,l.t,b))==(LEFT|RIGHT)) reg(res,cross({a,b},l));\n\t}\n\treturn res;\n}\n\nconst int vmax=5010;\nstruct node{int to;R cost;};\nvector<node> graph[vmax];\ninline void add_edge(int f,int t,R c){reg(graph[f],{t,c}),reg(graph[t],{f,c});}\n\nvoid segment_arrangement(const vector<L> &seg, vector<P> &point){\n\trep(i,vmax) graph[i].clear();\n\tint n=seg.size();\n\trep(i,n){\n\t\treg(point,seg[i].s),reg(point,seg[i].t);\n\t\trep(j,i) if(iss(seg[i],seg[j],1)) reg(point,cross(seg[i],seg[j]));\n\t}\n\tuniq(point);\n\trep(i,n){\n\t\tvector<pair<R,int>> idx;\n\t\trep(j,point.size()) if(ccw(seg[i].s,seg[i].t,point[j])==ON) reg(idx,{norm(point[j]-seg[i].s),j});\n\t\tsort(_all(idx));\n\t\trep(j,1,int(idx.size())){\n\t\t\tint a=idx[j-1].second,b=idx[j].second;\n\t\t\tadd_edge(a,b,abs(point[a]-point[b]));\n\t\t}\n\t}\n}\n\nL bisector(P a, P b){P mid=(a+b)/P(2,0);return L{mid, mid+(b-a)*P(0,1)};}\nVP voronoi_cell(VP pol,VP v,int s){rep(i,v.size())if(i!=s)pol=convex_cut(pol,bisector(v[s],v[i]));return pol;}\n\nR dist[vmax];\nR dijkstra(const VP &point){\n\tfill(dist,dist+vmax,INF);\n\tusing state=tuple<R,int>;\n\tpriority_queue<state,vector<state>,greater<state>> q;\n\trep(s,point.size()) if(sgn(real(point[s]))==0) dist[s]=0,q.push(state(0,s));\n\twhile(!q.empty()){\n\t\tR c;int v;\n\t\ttie(c,v)=q.top();q.pop();\n\t\tfor(auto &e:graph[v]){\n\t\t\tR nc=c+e.cost; int nv=e.to;\n\t\t\tif(chmin(dist[nv],nc)) q.push(state(nc,nv));\n\t\t}\n\t}\n\tR res=INF;\n\trep(t,point.size()) if(sgn(real(point[t])-4.0)==0) chmin(res,dist[t]);\n\treturn res;\n}\n\nint main(void){\n\tint n;\n\twhile(cin >> n,n){\n\t\tVP pol={P(0,0),P(4,0),P(4,4),P(0,4)};\n\t\tVP vornoi,point;\n\t\tVL seg;\n\t\trep(i,n){\n\t\t\tP p;\n\t\t\tcin >> p;\n\t\t\treg(vornoi,p);\n\t\t}\n\t\trep(i,n){\n\t\t\tVP res=voronoi_cell(pol,vornoi,i);\n\t\t\tfor(auto &p:res) reg(point,p);\n\t\t\tint m=res.size();\n\t\t\trep(i,m){\n\t\t\t\tL l={res[i],res[(i+1)%m]};\n\t\t\t\tbool ok=true;\n\t\t\t\trep(i,4) if(eql(l,{pol[i],pol[(i+1)%4]})) ok=false;\n\t\t\t\tif(ok) reg(seg,l);\n\t\t\t}\n\t\t}\n\t\tsegment_arrangement(seg,point);\n\t\tR res=dijkstra(point);\n\t\tcout.precision(20);\n\t\tif(res>=INF)\n\t\t\tcout << \"impossible\" << endl;\n\t\telse\n\t\t\tcout << fixed << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define INF (1e55)\n#define lt(a, b) (a - b < -EPS)\n#define equals(a, b) (fabs(a - b) < EPS)\n\nstruct Point {\n    double x, y;\n\n    Point () {}\n    Point (double x, double y) : x(x), y(y) {}\n\n    Point operator + (const Point &p) const {\n        return Point(x + p.x, y + p.y);\n    }\n    \n    Point operator - (const Point &p) const {\n        return Point(x - p.x, y - p.y);\n    }\n    \n    Point operator * (const double &k) const {\n        return Point(x * k, y * k);\n    }\n\n    bool operator == (const Point &p) const {\n        return (equals(x, p.x) && equals(y, p.y));\n    }    \n    \n    bool operator < (const Point &p) const {\n        if (!equals(x, p.x)) {\n            return lt(x, p.x);\n        } else {\n            return lt(y, p.y);\n        }\n    }\n};\n\ndouble dot(const Point &a, const Point &b)\n{\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(const Point &a, const Point &b)\n{\n    return a.x * b.y - b.x * a.y;\n}\n\ndouble norm(const Point &p)\n{\n    return dot(p, p);\n}\n\ndouble abs(const Point &p)\n{\n    return sqrt(norm(p));\n}\n\ndouble dist(const Point &a, const Point &b)\n{\n    return sqrt(pow(a.x - b.x, 2) + pow(a.y - b.y, 2));\n}\n\n#define COUNTER_CLOCKWISE +1\n#define CLOCKWISE         -1\n#define ONLINE_BACK       +2\n#define ONLINE_FRONT      -2\n#define ON_SEGMENT        +0\ntypedef Point Vector;\n\nint ccw(const Point &p0, const Point &p1, const Point &p2)\n{\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if (cross(a, b) > EPS)  return COUNTER_CLOCKWISE;\n    if (cross(a, b) < -EPS) return CLOCKWISE;\n    if (dot(a, b) < -EPS)   return ONLINE_BACK;\n    if (norm(a) < norm(b))  return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nstruct Segment {\n    Point s, t;\n    Segment(){}\n    Segment(Point s, Point t) : s(s), t(t) {}\n};\n\ntypedef Segment Line;\n\nLine perpendicular_bisector(const Point &a, const Point &b)\n{\n    double cx = (a.x + b.x) / 2.0;\n    double cy = (a.y + b.y) / 2.0;\n    Point p = Point(cx + (a.y - b.y), cy + (b.x - a.x));\n    return Line(Point(cx, cy), p);\n}\n\nPoint crosspointLL(const Line &a, const Line &b)\n{\n    Vector va = a.t - a.s, vb = b.t - b.s;\n    double d = cross(vb, va);\n    if (abs(d) < EPS) return b.s;\n    return a.s + va * cross(vb, b.t - a.s) * (1.0 / d);\n}\n\n#define curr(G, i) (G[i % G.size()])\n#define next(G, i) (G[(i + 1) % G.size()])\ntypedef vector<Point> Polygon;\n\nPolygon convex_cut(const Polygon &pg, const Line &l)\n{\n    Polygon res;\n    for (int i = 0; i < (int)pg.size(); i++) {\n        Point cp = curr(pg, i), np = next(pg, i);\n        if (ccw(l.s, l.t, cp) != -1) res.push_back(cp);\n        if (ccw(l.s, l.t, cp) * ccw(l.s, l.t, np) < 0) {\n            res.push_back(crosspointLL(Line(cp, np), l));\n        }\n    }\n    return res;\n}\n\nbool check(Point a, Point b)\n{\n    if (lt(b.x, a.x)) swap(a, b);\n    if (equals(a.x, b.x) && lt(b.y, a.y)) swap(a, b);\n    if (a == Point(0, 0) && equals(b.x, 0)) return 1;\n    if (a == Point(0, 0) && equals(b.y, 0)) return 1;\n    if (a == Point(0, 4) && equals(b.y, 4)) return 1;\n    if (a == Point(4, 0) && equals(b.x, 4)) return 1;\n    return 0;\n}\n\nvector<Segment> make_segments(vector<Point> &ps)\n{\n    Polygon pg(4);\n    pg[0] = Point(0, 0);\n    pg[1] = Point(0, 4);\n    pg[2] = Point(4, 4);\n    pg[3] = Point(4, 0);\n\n    vector<Segment> segs;\n    \n    int N = ps.size();\n    for (int i = 0; i < N; i++) {\n        Polygon p = pg;\n        for (int j = 0; j < N; j++) {\n            if (i == j) continue;\n            p = convex_cut(p, perpendicular_bisector(ps[i], ps[j]));\n        }\n        int M = p.size();\n        for (int j = 0; j < M; j++) {\n            if (check(curr(p, j), next(p, j))) continue;            \n            segs.push_back(Segment(curr(p, j), next(p, j)));\n        }\n    }\n    return segs;\n}\n\nstruct Edge {\n    int to;\n    double cost;\n    Edge (int to, double cost) : to(to), cost(cost) {}\n    bool operator < (const Edge &e) const {\n        return cost < e.cost;\n    }\n};\n\ntypedef vector<vector<Edge>> Graph;\n\nbool isIntersectSS(const Segment &a, const Segment &b)\n{\n    Point s[2] = {a.s, a.t}, t[2] = {b.s, b.t};\n    return (ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n\t    ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0);\n}\n\nbool isIntersectSP(const Segment &s, const Point &p)\n{\n    return (ccw(s.s, s.t, p) == 0);\n}\n\nPoint crosspointSS(const Segment &a, const Segment &b)\n{\n    Vector va = a.t - a.s, vb = b.t - b.s;\n    double d = cross(vb, va);\n    return a.s + va * cross(vb, b.t - a.s) * (1.0 / d);\n}\n\nGraph segment_arrangement(vector<Segment> &segs, vector<Point> &ps)\n{\n    Graph G;\n    int N = segs.size();\n    ps.clear();\n\n    for (int i = 0; i < N; i++) {\n\tps.push_back(segs[i].s);\n\tps.push_back(segs[i].t);\n\tfor (int j = i+1; j < N; j++) {\n\t    Vector a = segs[i].t - segs[i].s;\n\t    Vector b = segs[j].t - segs[j].s;\n\t    if (equals(cross(a, b), 0)) continue;            \n\t    if (isIntersectSS(segs[i], segs[j])) {\n\t\tps.push_back(crosspointSS(segs[i], segs[j]));\n\t    }\n\t}\n    }\n    sort(ps.begin(), ps.end());\n    ps.erase(unique(ps.begin(), ps.end()), ps.end());\n\n    int N2 = ps.size();\n    G.resize(N2);\n    for (int i = 0; i < N; i++) {\n\tvector<pair<double,int>> vec;\n\tfor (int j = 0; j < N2; j++) {\n\t    if (isIntersectSP(segs[i], ps[j])) {\n\t\tdouble d = dist(segs[i].s, ps[j]);\n\t\tvec.push_back(make_pair(d, j));\n\t    }\n\t}\n\tsort(vec.begin(), vec.end());\n\tfor (int j = 0; j < (int)vec.size()-1; j++) {\n\t    int u = vec[j].second, v = vec[j+1].second;\n\t    double d = dist(ps[u], ps[v]);\n\t    G[u].push_back(Edge(v, d));\n\t    G[v].push_back(Edge(u, d));\n\t}\n    }\n    return G;\n}\n\ndouble solve(vector<Point> &ps)\n{\n    vector<Segment> v = make_segments(ps);\n    vector<Point> p;\n    Graph G = segment_arrangement(v, p);\n\n    int N = p.size();    \n    vector<vector<double>> d(N, vector<double>(N, INF));\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < (int)G[i].size(); j++) {\n            d[i][G[i][j].to] = G[i][j].cost;\n        }\n        d[i][i] = 0;\n    }\n\n    for (int k = 0; k < N; k++) {\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n            }\n        }\n    }\n\n    double res = INF;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (!check(p[i], p[j]) && equals(p[i].x, 0) && equals(p[j].x, 4)) {\n                res = min(res, d[i][j]);\n            }\n        }\n    }    \n    return res;\n}\n\nint main()\n{\n    int n;\n    while (cin >> n, n) {\n        vector<Point> ps(n);\n        for (int i = 0; i < n; i++) {\n            cin >> ps[i].x >> ps[i].y;\n        }\n        double res = solve(ps);\n        if (n == 1 || res == INF) {\n            puts(\"impossible\");\n        } else {\n            printf(\"%.15f\\n\", res);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <list>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <fstream>\n#include <cassert>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> PI;\n#define EPS (1e-10)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i, n) rep (i, n)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define min3(a,b,c) min((a),min((b),(c)))\n#define min4(a,b,c,d) min((a),min3((b),(c),(d)))\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FLL(a,b) memset((a),b,sizeof(a))\n#define CLR(a) memset((a),0,sizeof(a))\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\ntemplate<typename T,typename U> ostream& operator<< (ostream& out, const pair<T,U>& val){return out << \"(\" << val.F << \", \" << val.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& out, const vector<T>& val){out << \"{\";rep(i,SZ(val)) out << (i?\", \":\"\") << val[i];return out << \"}\";}\ntypedef double FP;\ntypedef complex<FP> pt;\ntypedef pt P;\ntypedef pair<pt,pt> line;\nFP dot(P a,P b){return real(conj(a)*b);}\nFP crs(P a,P b){return imag(conj(a)*b);}\nP ortho(P a){return a*P(0,1);}\nP ortho(line a){return ortho(a.S-a.F);}\nP crspt(P a,P b,P c,P d){b-=a,d-=c;return a+b*crs(d,c-a)/crs(d,b);}\nP crspt(line a,line b){return crspt(a.F,a.S,b.F,b.S);}\nbool onl(P a1,P a2,P b){return abs(b-a1)+abs(b-a2)<abs(a1-a2)+EPS;}\nbool onl(line a,P b){return onl(a.F,a.S,b);}\nbool iscrs(line a,line b){P c=crspt(a,b);return onl(a,c)&&onl(b,c);}\nvoid pkuassert(bool t){t=1/t;};\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\nenum{TOP,BTM,LFT,RGT,FRT,BCK};\nint dxdy2ce[]={RGT,FRT,LFT,BCK};\ntemplate<class T> T shift(T a,int b,int c,int d,int e){\n __typeof(a[0])t=a[b];a[b]=a[c];a[c]=a[d];a[d]=a[e];a[e]=t;\n return a;}\ntemplate<class T> T rgt(T a){return shift(a,TOP,LFT,BTM,RGT);}\ntemplate<class T> T lft(T a){return shift(a,TOP,RGT,BTM,LFT);}\ntemplate<class T> T frt(T a){return shift(a,TOP,BCK,BTM,FRT);}\ntemplate<class T> T bck(T a){return shift(a,TOP,FRT,BTM,BCK);}\nline mkl(P a,P v){return line(a,a+v);}\nFP lpdist(line a,P b){return abs(b-crspt(a,mkl(b,ortho(a))));}\nFP spdist(line a,P b){\n  P c(crspt(a,mkl(b,ortho(a))));\n  return onl(a,c)?abs(b-c):min(abs(a.F-b),abs(a.S-b));\n}\nFP ssdist(line a,line b){\n return\n  iscrs(a,b)?0.:\n   min4(spdist(a,b.F),spdist(a,b.S),\n        spdist(b,a.F),spdist(b,a.S));\n}\nnamespace std{\n  bool operator<(const P&a,const P&b){\n    return mp(real(a),imag(a))<mp(real(b),imag(b));\n  }\n}\nint ccw(P a, P b, P c) {\n\tdouble d = crs(b -= a, c -= a);\n\treturn d>EPS ? 1 : d<-EPS ? -1 : dot(b,c)<-EPS ? 2 : norm(b)+EPS<norm(c) ? -2 : 0;\n}\n#define CCW(l, a) ccw((l).first, (l).second, (a))\n#define EQ(a, b) (abs((a)-(b)) < EPS)\n#define DI(l) ((l).second-(l).first)\ntypedef line L;\nbool intersectSP(const L &s, const P &p) { return EQ(abs(s.first-p)+abs(s.second-p)-abs(DI(s)), 0); }\nbool intersectSS(const L &s, const L &t) { return CCW(s,t.first)*CCW(s,t.second)<=0 && CCW(t,s.first)*CCW(t,s.second)<=0; }\nbool parallel(const L &l, const L &m) { return EQ(crs(DI(l), DI(m)), 0); }\nbool sameline(const L &l, const L &m) { return parallel(l, m) && EQ(crs(DI(l), m.second-l.first), 0); }\n\n\nvoid arrange_segments(const vector<L> &ls, vector<vector<pair<int, double> > > &G, vector<P> &ps) {\n  \n\trep(i, SZ(ls)) {\n\t\tps.push_back(ls[i].first);\n\t\tps.push_back(ls[i].second);\n\t\trep(j, i) if (intersectSS(ls[i], ls[j]) && !sameline(ls[i], ls[j]))\n\t\t\tps.push_back(crspt(ls[i], ls[j]));\n\t}\n\tsort(ALL(ps));\n\tps.erase(unique(ALL(ps)), ps.end());\n\n\tG.assign(SZ(ps), vector<pair<int, double> >());\n\trep(i, SZ(ls)) {\n\t\tvector<pair<double, int> > as;\n\t\trep(j, SZ(ps)) if (intersectSP(ls[i], ps[j]))\n\t\t\tas.push_back(make_pair(norm(ls[i].first - ps[j]), j));\n\t\tsort(ALL(as));\n\t\trep(j, SZ(as)-1) {\n\t\t\tint a = as[j].second, b = as[j+1].second;\n\t\t\tdouble l = abs(ps[a] - ps[b]);\n\t\t\tG[a].push_back(make_pair(b, l));\n\t\t\tG[b].push_back(make_pair(a, l));\n\t\t}\n\t}\n\trep(i, SZ(G)) {\n\t\tsort(ALL(G[i]));\n\t\tG[i].erase(unique(ALL(G[i])), G[i].end());\n\t}\n}\n\nint n;\nP in[100];\nbool app[2000];\n\nbool ok(P a){\n  vector<double> di;\n  rep(i,n)\n    di.pb(abs(a-in[i]));\n  sort(ALL(di));\n  return n>=2 && EQ(di[0],di[1]);\n}\n\nvoid solve(){\n  rep(i,n) cin >> in[i].real() >> in[i].imag();\n\n  CLR(app);\n  vector<line> li;\n  rep(i,n)rep(j,i){\n    line ij(ortho(in[i]-in[j])+(in[i]+in[j])*0.5,(in[i]+in[j])*0.5);\n    P t=ij.F-ij.S;\n    t *= 10/abs(t);\n    ij.F+=t;\n    ij.S-=t;\n    li.pb(ij);\n  }\n  li.pb(line(P(0,-1),P(0,5)));\n  li.pb(line(P(4,-1),P(4,5)));\n  vector<vector<pair<int, double> > > G;\n  priority_queue<pair<double,int> > q;  \n  vector<P> ps;\n  arrange_segments(li,G,ps);\n  FOR(it,ps) if(onl(line(P(0,0),P(0,4)),*it)) \n    q.push(mp(0,it-ps.begin()));\n  while(!q.empty()){\n    double cc=-q.top().F;\n    int cv=q.top().S;\n    q.pop();\n    double cx=real(ps[cv]);\n    double cy=imag(ps[cv]);\n    \n    if(min(cx,cy)<-EPS || max(cx,cy)>4+EPS) continue;\n    if(app[cv]) continue;\n    if(EQ(cx,4)){\n      printf(\"%.8f\\n\",cc);\n      return;\n    }\n    app[cv]=true;\n    FOR(it,G[cv]){\n      line ed(ps[cv],ps[it->F]);\n      if(ok(ed.F) && ok(ed.S) && ok((ed.F+ed.S)*0.5))\n        q.push(mp(-cc-it->S,it->F));\n    }\n\n  }\n\n  cout << \"impossible\" << endl;\n}\n\nint main(int argc, char *argv[])\n{\n  while(cin >> n && n) solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <array>\n#include <map>\nusing namespace std;\nconst double EPS = 1e-10;\nconst double INF = 1e12;\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n#define X real()\n#define Y imag()\n\ntypedef complex<double> P;\ntypedef vector<P> VP;\nstruct L : array<P, 2>{\n    L(const P& a, const P& b){ at(0)=a; at(1)=b; }\n    L(){}\n};\n\nnamespace std{\n    bool operator < (const P& a, const P& b){\n        return !EQ(a.X,b.X) ? a.X<b.X : a.Y+EPS<b.Y;\n    }\n    bool operator == (const P& a, const P& b){\n        return abs(a-b) < EPS;\n    }\n}\n\ndouble dot(P a, P b){\n    return (conj(a)*b).X;\n}\ndouble cross(P a, P b){\n    return (conj(a)*b).Y;\n}\nint ccw(P a, P b, P c){\n    b -= a;\n    c -= a;\n    if(cross(b,c) > EPS) return +1; //ccw\n    if(cross(b,c) < -EPS) return -1; //cw\n    if(dot(b,c) < -EPS) return +2; //c-a-b\n    if(abs(c)-abs(b) > EPS) return -2; //a-b-c\n    return 0; //a-c-b\n}\n\nbool intersectSP(const L& s, const P &p){\n    return abs(cross(s[0]-p, s[1]-p))<EPS  && dot(s[0]-p, s[1]-p)<EPS;\n}\nbool intersectSS(const L& a, const L& b){\n    return ( ccw(a[0],a[1],b[0]) *ccw(a[0],a[1],b[1]) <= 0 ) &&\n        ( ccw(b[0],b[1],a[0]) *ccw(b[0],b[1],a[1]) <= 0 );\n}\n\nbool isParallel(const P &a, const P &b){\n    return abs(cross(a,b)) < EPS;\n}\nbool isParallel(const L &a, const L &b){\n    return isParallel(a[1]-a[0], b[1]-b[0]);\n}\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1]-l[0], m[1]-m[0]);\n  double B = cross(l[1]-l[0], l[1]-m[0]);\n  return m[0] + B/A *(m[1]-m[0]);\n}\n\ndouble getarea(const VP &poly){\n    double ret = 0;\n    for (int i=0; i<(int)poly.size(); i++){ \n        ret += cross(poly[i], poly[(i+1)%poly.size()]);\n    }\n    return ret*0.5;\n}\nint in_poly(const P &p, const VP &poly){\n    int n = poly.size();\n    int ret = -1;\n    for(int i=0; i<n; i++){\n        P a = poly[i]-p;\n        P b = poly[(i+1)%n]-p;\n        if(a.Y > b.Y) swap(a,b);\n        if(intersectSP(L(a,b), P(0,0))) return 0;\n        if(a.Y<=0 && b.Y>0 && cross(a,b)<0) ret = -ret;\n    }\n    return ret;\n}\n\nVP convex(VP v){\n    VP ret;\n    int n = v.size();\n    sort(v.begin(), v.end());\n    for(int i=0; i<n; i++){\n        while((int)ret.size()>1 && cross(ret.back()-ret[ret.size()-2], v[i]-ret.back()) < EPS){\n            ret.pop_back();\n        }\n        ret.push_back(v[i]);\n    }\n    int t = ret.size();\n    for(int i=n-2; i>=0; i--){\n        while((int)ret.size()>t && cross(ret.back()-ret[ret.size()-2], v[i]-ret.back()) < EPS){\n            ret.pop_back();\n        }\n        ret.push_back(v[i]);\n    }\n    if((int)ret.size() > 1) ret.pop_back();\n    return ret;\n}\n\nVP convex_cut(const VP& p, const L& l){\n    VP ret;\n    int n = p.size();\n    for(int i=0; i<n; i++){\n        P curr = p[i];\n        P next = p[(i+1)%n];\n        if(ccw(l[0], l[1], curr) != -1) ret.push_back(curr);\n        if(ccw(l[0], l[1], curr) *ccw(l[0], l[1], next) == -1){\n            ret.push_back(crosspointLL(L(curr, next), l));\n        }\n    }\n    return ret;\n}\n\nVP convex_intersect(VP a, VP b){\n    VP plist;\n    int n=a.size(), m=b.size();\n    for(int r=0; r<2; r++){\n        for(int i=0; i<n; i++){\n            if(in_poly(a[i], b) >= 0){\n                plist.push_back(a[i]);\n            }\n        }\n        swap(n, m);\n        swap(a, b);\n    }\n    for(int i=0; i<n; i++){\n        for(int j=0; j<m; j++){\n            L la(a[i], a[(i+1)%n]), lb(b[j], b[(j+1)%m]);\n            if(!isParallel(la, lb) && intersectSS(la, lb)){\n                plist.push_back(crosspointLL(la, lb));\n            }\n        }\n    }\n    return convex(plist);\n}\n\nvector<VP> volonoi_division(VP plist, VP poly){\n    int m = plist.size();\n    vector<VP> ret(m);\n    for(int i=0; i<m; i++){\n        VP v = poly;\n        for(int j=0; j<m; j++){\n            if(i==j) continue;\n            P mid = (plist[i]+plist[j])/2.0;\n            L bisector(mid, mid +(plist[j]-plist[i])*P(0,1));\n            VP cut = convex_cut(v, bisector);\n            v = convex_intersect(v, cut);\n        }\n        ret[i] = v;\n    }\n    return ret;\n}\n\nint main(){\n    while(1){\n        int n;\n        cin >> n;\n        if(n==0) break;\n\n        VP plist(n);\n        for(int i=0; i<n; i++){\n            double x,y;\n            cin >> x >> y;\n            plist[i] = P(x, y);\n        }\n        VP sq{P(0, 0), P(4, 0), P(4, 4), P(0, 4)};\n        vector<VP> poly = volonoi_division(plist, sq);\n\n        vector<L> edge;\n        for(int i=0; i<n; i++){\n            int m = poly[i].size();\n            for(int j=0; j<m; j++){\n                edge.push_back(L(poly[i][j], poly[i][(j+1)%m]));\n            }\n        }\n        int m = edge.size();\n        map<P, int> conv;\n        int count = 0;\n        for(int i=0; i<m; i++){\n            for(int d=0; d<2; d++){\n                if(conv.count(edge[i][d]) == 0){\n                    conv[edge[i][d]] = count;\n                    count++;\n                }\n            }\n        }\n\n        vector<vector<double> > adj(count, vector<double>(count, INF));\n        for(int i=0; i<(int)edge.size(); i++){\n            int idx0 = conv[edge[i][0]];\n            int idx1 = conv[edge[i][1]];\n            if(EQ(edge[i][0].Y, edge[i][1].Y) && (EQ(edge[i][0].Y, 0) || EQ(edge[i][0].Y, 4))){\n                continue;\n            }\n            if(EQ(edge[i][0].X, edge[i][1].X) && (EQ(edge[i][0].X, 0) || EQ(edge[i][0].X, 4))){\n                adj[idx0][idx1] = adj[idx1][idx0] = 0;\n                continue;\n            }\n            adj[idx0][idx1] = adj[idx1][idx0] = abs(edge[i][1] -edge[i][0]);\n        }\n        for(int k=0; k<count; k++){\n            for(int i=0; i<count; i++){\n                for(int j=0; j<count; j++){\n                    adj[i][j] = min(adj[i][j], adj[i][k] +adj[k][j]);\n                }\n            }\n        }\n\n        double ans = adj[conv[P(0,0)]][conv[P(4,4)]];\n        if(ans == INF){\n            cout << \"impossible\" << endl;\n        }else{\n            cout << fixed << setprecision(10);\n            cout << ans << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst double EPS = 1e-10, PI = acos(-1);\n\ninline bool eq(double a, double b) { return abs(b - a) < EPS; }\n\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define prev(P, i) P[(i+P.size()-1) % P.size()]\n\nenum\n{\n  OUT, ON, IN\n};\nnamespace Geometory\n{\n  struct Point\n  {\n    double x, y;\n\n    Point() {};\n\n    Point(double x, double y) : x(x), y(y) {};\n\n    Point operator+(const Point &b) const { return Point(x + b.x, y + b.y); }\n\n    Point operator-(const Point &b) const { return Point(x - b.x, y - b.y); }\n\n    Point operator*(const double b) const { return Point(x * b, y * b); }\n\n    Point operator*(const Point &b) const { return Point(x * b.x - y * b.y, x * b.y + y * b.x); }\n\n    Point operator/(const double b) const { return Point(x / b, y / b); }\n\n    bool operator<(const Point &b) const { return x != b.x ? x < b.x : y < b.y; }\n\n    bool operator==(const Point &b) const { return eq(x, b.x) && eq(y, b.y); }\n\n    double norm() { return x * x + y * y; }\n\n    double arg() { return atan2(x, y); }\n\n    double abs() { return sqrt(norm()); }\n\n    Point rotate(double theta) { return Point(cos(theta) * x - sin(theta) * y, sin(theta) * x + cos(theta) * y); }\n\n    Point rotate90() { return Point(-y, x); }\n\n    friend ostream &operator<<(ostream &os, Point &p) { return os << \"(\" << p.x << \",\" << p.y << \")\"; }\n\n    friend istream &operator>>(istream &is, Point &a) { return is >> a.x >> a.y; }\n  };\n\n  struct Line\n  {\n    Point a, b;\n\n    Line() {};\n\n    Line(Point a, Point b) : a(a), b(b) {};\n\n    friend ostream &operator<<(ostream &os, Line &p) { return os << \"(\" << p.a.x << \",\" << p.a.y << \") to (\" << p.b.x << \",\" << p.b.y << \")\"; }\n\n    friend istream &operator>>(istream &is, Line &a) { return is >> a.a.x >> a.a.y >> a.b.x >> a.b.y; }\n  };\n\n  struct Segment\n  {\n    Point a, b;\n\n    Segment() {};\n\n    Segment(Point a, Point b) : a(a), b(b) {};\n\n    friend ostream &operator<<(ostream &os, Segment &p) { return os << \"(\" << p.a.x << \",\" << p.a.y << \") to (\" << p.b.x << \",\" << p.b.y << \")\"; }\n\n    friend istream &operator>>(istream &is, Segment &a) { return is >> a.a.x >> a.a.y >> a.b.x >> a.b.y; }\n  };\n\n  typedef vector< Point > Polygon;\n  typedef vector< Segment > Segments;\n\n  double cross(const Point &a, const Point &b)\n  {\n    return a.x * b.y - a.y * b.x;\n  }\n\n  double dot(const Point &a, const Point &b)\n  {\n    return a.x * b.x + a.y * b.y;\n  }\n\n  int ccw(const Point &a, Point b, Point c)\n  {\n    b = b - a, c = c - a;\n    if(cross(b, c) > EPS) return +1;\n    if(cross(b, c) < -EPS) return -1;\n    if(dot(b, c) < 0) return +2;\n    if(b.norm() < c.norm()) return -2;\n    return 0;\n  }\n\n  Point Crosspoint(const Line &l, const Line &m)\n  {\n    double A = cross(l.b - l.a, m.b - m.a);\n    double B = cross(l.b - l.a, l.b - m.a);\n    if(abs(A) < EPS && abs(B) < EPS) return m.a;\n    return m.a + (m.b - m.a) * B / A;\n  }\n\n  Line Bisector(Point a, Point b)\n  {\n    Point c = (a + b) * 0.5;\n    Point p = Point(c.x + (a.y - b.y), c.y + (b.x - a.x));\n    return (Line(c, p));\n  }\n\n  Polygon Convex_Cut(Polygon &U, Line l)\n  {\n    Polygon ret;\n    for(int i = 0; i < U.size(); i++) {\n      Point now = curr(U, i), nxt = next(U, i);\n      if(ccw(l.a, l.b, now) != -1) ret.push_back(now);\n      if(ccw(l.a, l.b, now) * ccw(l.a, l.b, nxt) < 0) {\n        ret.push_back(Crosspoint(Line(now, nxt), l));\n      }\n    }\n    return (ret);\n  }\n};\n\ntypedef pair< double, int > Pi;\nstruct edge\n{\n  int to;\n  double cost;\n};\ntypedef vector< vector< edge > > Graph;\nconst double INF = 1e9;\n\ndouble Dijkstra(Graph &graph, int s, int g)\n{\n  vector< double > min_cost(graph.size(), INF);\n  priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n  que.push(make_pair(0, s));\n  min_cost[s] = 0;\n  while(!que.empty()) {\n    int now = que.top().second;\n    double cost = que.top().first;\n    que.pop();\n    if(now == g) return (cost);\n    if(cost > min_cost[now]) continue;\n    for(auto &e : graph[now]) {\n      if(cost + e.cost < min_cost[e.to]) {\n        min_cost[e.to] = cost + e.cost;\n        que.push(make_pair(min_cost[e.to], e.to));\n      }\n    }\n  }\n  return (-1);\n}\n\n\nint main()\n{\n  int N;\n  while(cin >> N, N) {\n    vector< Geometory::Point > points(N);\n    Geometory::Polygon U(4);\n    U[0] = Geometory::Point(0, 0);\n    U[1] = Geometory::Point(4, 0);\n    U[2] = Geometory::Point(4, 4);\n    U[3] = Geometory::Point(0, 4);\n\n    for(int i = 0; i < N; i++) {\n      cin >> points[i];\n    }\n\n    vector< Geometory::Polygon > voronoi(N);\n    for(int i = 0; i < N; i++) {\n      voronoi[i] = U;\n      for(int j = 0; j < N; j++) {\n        if(i == j) continue;\n        voronoi[i] = Geometory::Convex_Cut(voronoi[i], Geometory::Bisector(points[i], points[j]));\n      }\n    }\n\n    vector< Geometory::Point > ventex;\n    for(int i = 0; i < N; i++) {\n      for(auto &point : voronoi[i]) ventex.push_back(point);\n    }\n    sort(begin(ventex), end(ventex));\n    ventex.erase(unique(begin(ventex), end(ventex)), end(ventex));\n\n    Graph g(ventex.size() + 2);\n    for(int i = 0; i < N; i++) {\n      for(int j = 0; j < voronoi[i].size(); j++) {\n        auto &pv = curr(voronoi[i], j), nw = next(voronoi[i], j);\n        int pp = lower_bound(begin(ventex), end(ventex), pv) - begin(ventex);\n        int qq = lower_bound(begin(ventex), end(ventex), nw) - begin(ventex);\n        double dist = (pv - nw).abs();\n        if(eq(pv.x, 0)) pp = ventex.size();\n        else if(eq(pv.x, 4)) pp = ventex.size() + 1;\n        if(eq(nw.x, 0)) qq = ventex.size();\n        else if(eq(nw.x, 4)) qq = ventex.size() + 1;\n        if(eq(pv.y, 0) && eq(nw.y, 0)) continue;\n        if(eq(pv.y, 4) && eq(nw.y, 4)) continue;\n        g[pp].push_back((edge) {qq, dist});\n        g[qq].push_back((edge) {pp, dist});\n      }\n    }\n    auto cost = Dijkstra(g, ventex.size(), ventex.size() + 1);\n    if(cost == -1) cout << \"impossible\" << endl;\n    else cout << fixed << setprecision(15) << cost << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst double EPS = 1e-8, PI = acos(-1);\n\ninline bool eq(double a, double b) { return abs(b - a) < EPS; }\n\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\n#define prev(P, i) P[(i+P.size()-1) % P.size()]\n\nenum\n{\n  OUT, ON, IN\n};\nnamespace Geometory\n{\n  struct Point\n  {\n    double x, y;\n\n    Point() {};\n\n    Point(double x, double y) : x(x), y(y) {};\n\n    Point operator+(const Point &b) const { return Point(x + b.x, y + b.y); }\n\n    Point operator-(const Point &b) const { return Point(x - b.x, y - b.y); }\n\n    Point operator*(const double b) const { return Point(x * b, y * b); }\n\n    Point operator*(const Point &b) const { return Point(x * b.x - y * b.y, x * b.y + y * b.x); }\n\n    Point operator/(const double b) const { return Point(x / b, y / b); }\n\n    bool operator<(const Point &b) const { return x != b.x ? x < b.x : y < b.y; }\n\n    bool operator==(const Point &b) const { return eq(x, b.x) && eq(y, b.y); }\n\n    double norm() { return x * x + y * y; }\n\n    double arg() { return atan2(x, y); }\n\n    double abs() { return sqrt(norm()); }\n\n    Point rotate(double theta) { return Point(cos(theta) * x - sin(theta) * y, sin(theta) * x + cos(theta) * y); }\n\n    Point rotate90() { return Point(-y, x); }\n\n    friend ostream &operator<<(ostream &os, Point &p) { return os << \"(\" << p.x << \",\" << p.y << \")\"; }\n\n    friend istream &operator>>(istream &is, Point &a) { return is >> a.x >> a.y; }\n  };\n\n  struct Line\n  {\n    Point a, b;\n\n    Line() {};\n\n    Line(Point a, Point b) : a(a), b(b) {};\n\n    friend ostream &operator<<(ostream &os, Line &p) { return os << \"(\" << p.a.x << \",\" << p.a.y << \") to (\" << p.b.x << \",\" << p.b.y << \")\"; }\n\n    friend istream &operator>>(istream &is, Line &a) { return is >> a.a.x >> a.a.y >> a.b.x >> a.b.y; }\n  };\n\n  struct Segment\n  {\n    Point a, b;\n\n    Segment() {};\n\n    Segment(Point a, Point b) : a(a), b(b) {};\n\n    friend ostream &operator<<(ostream &os, Segment &p) { return os << \"(\" << p.a.x << \",\" << p.a.y << \") to (\" << p.b.x << \",\" << p.b.y << \")\"; }\n\n    friend istream &operator>>(istream &is, Segment &a) { return is >> a.a.x >> a.a.y >> a.b.x >> a.b.y; }\n  };\n\n  typedef vector< Point > Polygon;\n  typedef vector< Segment > Segments;\n\n  double cross(const Point &a, const Point &b)\n  {\n    return a.x * b.y - a.y * b.x;\n  }\n\n  double dot(const Point &a, const Point &b)\n  {\n    return a.x * b.x + a.y * b.y;\n  }\n\n  int ccw(const Point &a, Point b, Point c)\n  {\n    b = b - a, c = c - a;\n    if(cross(b, c) > EPS) return +1;\n    if(cross(b, c) < -EPS) return -1;\n    if(dot(b, c) < 0) return +2;\n    if(b.norm() < c.norm()) return -2;\n    return 0;\n  }\n\n  Point Crosspoint(const Line &l, const Line &m)\n  {\n    double A = cross(l.b - l.a, m.b - m.a);\n    double B = cross(l.b - l.a, l.b - m.a);\n    if(abs(A) < EPS && abs(B) < EPS) return m.a;\n    return m.a + (m.b - m.a) * B / A;\n  }\n\n  Line Bisector(Point a, Point b)\n  {\n    Point c = (a + b) * 0.5;\n    Point p = Point(c.x + (a.y - b.y), c.y + (b.x - a.x));\n    return (Line(c, p));\n  }\n\n  Polygon Convex_Cut(Polygon &U, Line l)\n  {\n    Polygon ret;\n    for(int i = 0; i < U.size(); i++) {\n      Point now = curr(U, i), nxt = next(U, i);\n      if(ccw(l.a, l.b, now) != -1) ret.push_back(now);\n      if(ccw(l.a, l.b, now) * ccw(l.a, l.b, nxt) < 0) {\n        ret.push_back(Crosspoint(Line(now, nxt), l));\n      }\n    }\n    return (ret);\n  }\n};\n\ntypedef pair< double, int > Pi;\nstruct edge\n{\n  int to;\n  double cost;\n};\ntypedef vector< vector< edge > > Graph;\nconst double INF = 1e9;\n\ndouble Dijkstra(Graph &graph, int s, int g)\n{\n  vector< double > min_cost(graph.size(), INF);\n  priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n  que.push(make_pair(0, s));\n  min_cost[s] = 0;\n  while(!que.empty()) {\n    int now = que.top().second;\n    double cost = que.top().first;\n    que.pop();\n    if(now == g) return (cost);\n    if(cost > min_cost[now]) continue;\n    for(auto &e : graph[now]) {\n      if(cost + e.cost < min_cost[e.to]) {\n        min_cost[e.to] = cost + e.cost;\n        que.push(make_pair(min_cost[e.to], e.to));\n      }\n    }\n  }\n  return (-1);\n}\n\n\nint main()\n{\n  int N;\n  while(cin >> N, N) {\n    vector< Geometory::Point > points(N);\n    Geometory::Polygon U(4);\n    U[0] = Geometory::Point(0, 0);\n    U[1] = Geometory::Point(4, 0);\n    U[2] = Geometory::Point(4, 4);\n    U[3] = Geometory::Point(0, 4);\n\n    for(int i = 0; i < N; i++) {\n      cin >> points[i];\n    }\n\n    vector< Geometory::Polygon > voronoi(N);\n    for(int i = 0; i < N; i++) {\n      voronoi[i] = U;\n      for(int j = 0; j < N; j++) {\n        if(i == j) continue;\n        voronoi[i] = Geometory::Convex_Cut(voronoi[i], Geometory::Bisector(points[i], points[j]));\n      }\n    }\n\n    vector< Geometory::Point > ventex;\n    for(int i = 0; i < N; i++) {\n      for(auto &point : voronoi[i]) ventex.push_back(point);\n    }\n    sort(begin(ventex), end(ventex));\n    ventex.erase(unique(begin(ventex), end(ventex)), end(ventex));\n\n    Graph g(ventex.size() + 2);\n    for(int i = 0; i < N; i++) {\n      for(int j = 1; j < voronoi[i].size(); j++) {\n        auto &pv = voronoi[i][j - 1], nw = voronoi[i][j];\n        int pp = lower_bound(begin(ventex), end(ventex), pv) - begin(ventex);\n        int qq = lower_bound(begin(ventex), end(ventex), nw) - begin(ventex);\n        double dist = (pv - nw).abs();\n        if(eq(pv.x, 0)) pp = ventex.size();\n        else if(eq(pv.x, 4)) pp = ventex.size() + 1;\n        if(eq(nw.x, 0)) qq = ventex.size();\n        else if(eq(nw.x, 4)) qq = ventex.size() + 1;\n        if(eq(pv.y, 0) && eq(nw.y, 0)) continue;\n        if(eq(pv.y, 4) && eq(nw.y, 4)) continue;\n        g[pp].push_back((edge) {qq, dist});\n        g[qq].push_back((edge) {pp, dist});\n      }\n    }\n    auto cost = Dijkstra(g, ventex.size(), ventex.size() + 1);\n    if(cost == -1) cout << \"impossible\" << endl;\n    else cout << fixed << setprecision(15) << cost << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<vector>\n#include<iostream>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<cmath>\n#include<cassert>\n\n#define START_X 0.0\n#define GOAL_X 4.0\n\n#define FRONT 0x01\n#define RIGHT 0x02\n#define BACK 0x04\n#define LEFT 0x08\n#define OVER 0x10\n\n#define sc second\n#define fr first\n\n#define REP(i,n) for(int i = 0; i < (int)(n); ++i)\n\nusing namespace std;\n\ntypedef double elem;\ntypedef complex<elem> point, vec;\ntypedef pair<point, point> line, hline, seg, pp;\n\nconst double eps = 1.0e-12;\nconst double pi = acos(-1.0);\nconst double infty = 1e40;\npoint base(0,0),origin(0,0);\n\nbool eq(elem a, elem b){ return abs(a-b) < eps; }\nbool lt(elem a, elem b){ return !eq(a,b) && a < b; }\nbool leq(elem a, elem b){ return eq(a,b) || a < b; }\nbool gt(elem a, elem b){ return !eq(a,b) && a > b; }\nbool geq(elem a, elem b){ return eq(a,b) || a > b; }\nbool ltz(elem a){ return lt( a, 0 ); }\nbool gtz(elem a){ return gt( a, 0 ); }\nbool eqv(vec a, vec b){ return eq( abs(b-a),0); }\nbool is_zv(vec v){ return eq(abs(v),0); }\nelem emax(elem a, elem b){ return gt(a,b)?a:b; }\nelem emin(elem a, elem b){ return lt(a,b)?a:b; }\n\nbool far(point a, point b){ return gtz( abs(b-a) ); }\nbool near(point a, point b){ return leq( abs(b-a), 0 ); }\nelem dot(vec a, vec b){ return (a.real() * b.real() + a.imag() * b.imag() ); }\nelem cross(vec a, vec b){ return ( a.real() * b.imag() - a.imag() * b.real() ); }\n\nelem dist(point a, point b){ return abs(a-b); }\nelem dist_l(line l, point x){ return abs(cross(l.sc-l.fr,x-l.fr)) / abs(l.sc-l.fr); }\nelem dist_seg(seg s, point x)\n{\n  if( ltz( dot(s.sc-s.fr,x-s.fr) ) ) return abs(x-s.fr);\n  if( ltz( dot(s.fr-s.sc,x-s.sc) ) ) return abs(x-s.sc);\n  return dist_l(s,x);\n}\n\nvec uvec(vec a){ return a / abs(a); }\nvec nmr(vec a){ return a * vec(0,-1); }\nvec nml(vec a){ return a * vec(0,1); }\nvec unmr(vec a){ return uvec( nmr(a) ); }\nvec unml(vec a){ return uvec( nml(a) ); }\n\nbool orth(point a1, point a2, point b1, point b2){ return eq( dot( a2 - a1, b2 - b1 ), 0 ); }\nbool orth(vec v1, vec v2){ return eq( dot(v1, v2), 0 ); }\nbool prll(point a1, point a2, point b1, point b2){ return eq( cross( a2 - a1, b2 - b1 ), 0 ); }\nbool prll(vec v1, vec v2){ return eq( cross(v1, v2), 0 ); }\n\nint ccw(point a, point b, point x){\n  b -= a;\n  x -= a;\n  if( gtz( cross(b,x) ) ) return LEFT;\n  if( ltz( cross(b,x) ) ) return RIGHT;\n  if( ltz( dot(b,x) ) ) return BACK;\n  if( lt( abs(b), abs(x) ) ) return FRONT;\n  return OVER;\n}\n\nbool intersectedSS(seg a, seg b)\n{\n  if( ccw(a.fr,a.sc,b.fr)&OVER || ccw(a.fr,a.sc,b.sc)&OVER ) return true;\n  return\n    ( ccw(a.fr,a.sc,b.fr) | ccw(a.fr,a.sc,b.sc) ) == (LEFT|RIGHT) &&\n    ( ccw(b.fr,b.sc,a.fr) | ccw(b.fr,b.sc,a.sc) ) == (LEFT|RIGHT) ;\n}\n\nbool intersectedLL(line a, line b){ return !eq( cross(a.sc-a.fr,b.sc-b.fr), 0.0 ); }\n\npoint intersectionSS(seg a, seg b)\n{\n  elem d1 = dist_l(b,a.fr);\n  elem d2 = dist_l(b,a.sc);\n  return a.fr + ( d1 / (d1 + d2 ) ) * (a.sc-a.fr);\n}\npoint intersectionLL(line a, line b)\n{\n  vec va = a.sc - a.fr;\n  vec vb = b.sc - b.fr;\n  return a.fr + va * ( cross(vb, b.fr - a.fr) / cross(vb,va) );\n}\n\nbool intersectionLL(line a, line b, point &ret){\n  return intersectedLL( a, b ) ? ret = intersectionLL( a, b ), true : false;\n}\nbool intersectionLH(line a, hline b, point &ret){\n  point tmp;\n  return intersectionLL(a,b,tmp) ? ( ccw(b.fr,b.sc,tmp)&(OVER|FRONT) ? ret=tmp, true : false ) : false;\n}\nbool intersectionLS(line l, seg s, point &ret){\n  point tmp;\n  return intersectionLL(l,s,tmp) ? ( ccw(s.fr,s.sc,tmp)&OVER ? ret=tmp, true : false ) : false;\n}\nbool intersectionHH(hline a, hline b, point &ret){\n  point tmp;\n  return intersectionLL(a,b,tmp) ? ( ccw(a.fr,a.sc,tmp)&(OVER|FRONT)&&ccw(b.fr,b.sc,tmp)&(OVER|FRONT) ? ret = tmp, true : false ) : false;\n}\nbool intersectionHS(hline a, seg s, point &ret){\n  point tmp;\n  return intersectionLS(a,s,tmp) ? ( ccw(a.fr,a.sc,tmp)&(OVER|FRONT) ? ret = tmp, true : false ) : false;\n}\nbool intersectionSS(seg a, seg b, point &ret){\n  return intersectedSS(a,b) ? ret = intersectionSS(a,b), true : false;\n}\n\nbool convexCut(const vector<point> &vp,\n\t       line l,\n\t       vector<point> &left)\n{\n  int n = vp.size();\n  bool bFirst = true;\n  int indq1 = -1, indq2 = -1;\n  point q1, q2;\n  \n  for(int i = 0; i < n; ++i){\n    seg edge = make_pair( vp[i], vp[(i+1)%n] );\n    if( bFirst ){\n      if( intersectionLS( l, edge, q1 ) ){ bFirst = false; indq1 = (i+1)%n; }\n    }else{\n      if( intersectionLS( l, edge, q2 ) && far(q1,q2) ){ indq2 = (i+1)%n; break; }\n    }\n  }\n\n  if( indq1<0||indq2<0 ) return false;\n  if( lt( dist( q1, l.second ), dist( q2, l.second ) ) ){ swap( q1, q2 ); swap( indq1, indq2 ); }\n  if( far( q2, vp[indq2] ) ) left.push_back( q2 );\n  for(int i = indq2; i != indq1; i=(i+1>=n?0:i+1)) left.push_back( vp[i] );\n  if( far(q1, vp[(indq1-1+n)%n] ) ) left.push_back( q1 );\n\n  return true;\n}\n\nstruct Point{\n  point p;\n  Point():p(origin){}\n  Point(point p):p(p){}\n  bool operator < (const Point &t)const{\n    if(!eq(p.real(),t.p.real()))return lt(p.real(),t.p.real());\n    else return lt(p.imag(),t.p.imag());\n  }\n};\n\nstruct Node{\n  point p;\n  vector<int> con;\n  vector<double> cost;\n};\n\ntypedef vector<Node> Graph;\n\nline expandLine(line l, elem mag){\n  line ret = l;\n  vec vf(l.first - l.second);\n  vec vs(l.second - l.first);\n  ret.first = l.second + mag * vf;\n  ret.second = l.first + mag * vs;\n  return ret;\n}\n\nvoid MakeVolonoi(const vector<point> &vp,\n\t\t const vector<point> &plane,\n\t\t vector< vector<point> > &out){\n  vector<point> tplane;\n  \n  for(int i = 0; i < vp.size(); ++i){\n    tplane = plane;\n    for(int j = 0; j < vp.size(); ++j){\n      if( i != j ){\n\tvector<point> newplane;\n\tpoint c = (vp[i]+vp[j])/2.;\n\tint cw = ccw( c, unmr(vp[i]-vp[j])+c, vp[i] );\n\tassert(cw==LEFT||cw==RIGHT);\n\tline bisec;\n\tif( cw == LEFT ){\n\t  bisec = line( c, unmr( vp[i]-vp[j] ) + c );\n\t}else{\n\t  bisec = line( c, unml( vp[i]-vp[j] ) + c );\n\t}\n\tbisec = expandLine( bisec, 100.0 ); // magnify segment for convex cut\n\t//cout << abs(bisec.second-bisec.first) << endl;\n\tif( convexCut(tplane, bisec, newplane ) )\n\t  tplane = newplane;\n      }\n    }\n    out.push_back( tplane );\n  }\n};\n\nstruct State{\n  int now;\n  elem cost;\n  State(){}\n  bool operator<(const State &t)const{\n    return lt(cost,t.cost);\n  }\n};\n\nelem dijkstra(Graph &G, int sid){\n  elem ret = infty;\n  priority_queue<State> qs;\n  State init;\n  bool vis[G.size()];\n  elem A[G.size()];\n  for(int i = 0; i < G.size(); ++i){\n    vis[i]=false;\n    A[i]=infty;\n  }\n  init.now = sid;\n  init.cost = 0.0;\n  qs.push(init);\n  A[sid]=0.0;\n  while(!qs.empty()){\n    State st_now = qs.top(); qs.pop();\n    int nid = st_now.now;\n    if(vis[nid])continue;\n    else vis[nid]=true;\n    for(int i = 0; i < G[nid].con.size(); ++i){\n      State next;\n      next.now = G[nid].con[i];\n      //cout << next.now << endl;\n      next.cost = st_now.cost + G[nid].cost[i];\n      if( lt(next.cost, A[next.now]) ){\n\tA[next.now] = next.cost;\n\tif( !vis[next.now] ){\n\t  qs.push( next );\n\t}\n      }\n    }\n  }\n  for(int i = 0; i < G.size(); ++i){\n    if( eq(G[i].p.real(),GOAL_X) ){\n      ret = emin( ret, A[i] );\n    }\n  }\n  return ret;\n}\n\nint main()\n{\n  while(true){\n    int n;\n    elem ans=infty;\n    map<Point,int> point_id;\n    vector<point> vp,plane;\n    vector< vector<point> > volonoi;\n\n    cin >> n;\n    if( n == 0 ) break;\n    for(int i = 0; i < n; ++i){\n      elem x,y;\n      cin >> x >> y;\n      vp.push_back( point(x,y) );\n    }\n    if( n == 1 ){\n      puts(\"impossible\");\n      continue;\n    }\n    plane.push_back( point(0.0,0.0) );\n    plane.push_back( point(4.0,0.0) );\n    plane.push_back( point(4.0,4.0) );\n    plane.push_back( point(0.0,4.0) );\n    MakeVolonoi( vp, plane, volonoi );\n\n    /* debug \n    for(int i = 0; i < volonoi.size(); ++i){\n      cout << \"//\" << i << \" master point : \" << vp[i] << endl;\n      for(int j = 0; j < volonoi[i].size(); ++j){\n\tpoint lf=volonoi[i][j];\n\tpoint ls=volonoi[i][(j+1)%volonoi[i].size()];\n\n\tcout << \"line(\" << lf.real() <<\",\" << lf.imag() <<\",\" << ls.real() <<\",\"<<ls.imag() << \");\" << endl;\n      }\n    }\n    cout << endl;\n    */\n\n    int now = 0;\n    for(int i = 0; i < volonoi.size(); ++i){\n      for(int j = 0; j < volonoi[i].size(); ++j){\n\tPoint pp(volonoi[i][j]);\n\tif( point_id.find( pp ) == point_id.end() ){\n\t  point_id[pp] = now;\n\t  ++now;\n\t}\n      }\n    }\n    Graph G(now);\n\n    // Graph Construction\n    for(int i = 0; i < volonoi.size(); ++i){\n      int ni = volonoi[i].size();\n      for(int j = 0; j < ni; ++j){\n\tpoint p = volonoi[i][j];\n\tpoint np = volonoi[i][(j+1)%ni];\n\telem ck = ((p+np)/2.).imag();\n\telem ckx = ((p+np)/2.).real();\n\tif( eq(ckx,0.0)||eq(ckx,4.0)||eq(ck,0.0)||eq(ck,4.0) ) continue;\n\tint ip = point_id[Point(p)];\n\tint inp = point_id[Point(np)];\n\telem d = dist( p, np );\n\tG[ ip ].p = p;\n\tG[ inp ].p = np;\n\tG[ ip ].con.push_back( inp );\n\tG[ ip ].cost.push_back( d );\n\tG[ inp ].con.push_back( ip );\n\tG[ inp ].cost.push_back( d );\n      }\n    }\n\n    for(int i = 0; i < G.size(); ++i){\n      if( eq( G[i].p.real(), START_X ) ){\n\tans = emin( ans, dijkstra( G, i ) );\n      }\n    }\n\n    if(geq(ans,infty))puts(\"impossible\");\n    else printf(\"%.12lf\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<vector>\n#include<iostream>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<cmath>\n\n#define START_X 0.0\n#define GOAL_X 4.0\n\n#define FRONT 0x01\n#define RIGHT 0x02\n#define BACK 0x04\n#define LEFT 0x08\n#define OVER 0x10\n\n#define sc second\n#define fr first\n\n#define REP(i,n) for(int i = 0; i < (int)(n); ++i)\n\nusing namespace std;\n\ntypedef double elem;\ntypedef complex<elem> point, vec;\ntypedef pair<point, point> line, hline, seg, pp;\n\nconst double eps = 1.0e-8;\nconst double pi = acos(-1.0);\nconst double infty = 1e40;\npoint base(0,0),origin(0,0);\n\nbool eq(elem a, elem b){ return abs(a-b) < eps; }\nbool lt(elem a, elem b){ return !eq(a,b) && a < b; }\nbool leq(elem a, elem b){ return eq(a,b) || a < b; }\nbool gt(elem a, elem b){ return !eq(a,b) && a > b; }\nbool geq(elem a, elem b){ return eq(a,b) || a > b; }\nbool ltz(elem a){ return lt( a, 0 ); }\nbool gtz(elem a){ return gt( a, 0 ); }\nbool eqv(vec a, vec b){ return eq( abs(b-a),0); }\nbool is_zv(vec v){ return eq(abs(v),0); }\nelem emax(elem a, elem b){ return gt(a,b)?a:b; }\nelem emin(elem a, elem b){ return lt(a,b)?a:b; }\n\nbool far(point a, point b){ return gtz( abs(b-a) ); }\nbool near(point a, point b){ return leq( abs(b-a), 0 ); }\nelem dot(vec a, vec b){ return (a.real() * b.real() + a.imag() * b.imag() ); }\nelem cross(vec a, vec b){ return ( a.real() * b.imag() - a.imag() * b.real() ); }\n\nelem dist(point a, point b){ return abs(a-b); }\nelem dist_l(line l, point x){ return abs(cross(l.sc-l.fr,x-l.fr)) / abs(l.sc-l.fr); }\nelem dist_seg(seg s, point x)\n{\n  if( ltz( dot(s.sc-s.fr,x-s.fr) ) ) return abs(x-s.fr);\n  if( ltz( dot(s.fr-s.sc,x-s.sc) ) ) return abs(x-s.sc);\n  return dist_l(s,x);\n}\n\nvec uvec(vec a){ return a / abs(a); }\nvec nmr(vec a){ return a * vec(0,-1); }\nvec nml(vec a){ return a * vec(0,1); }\nvec unmr(vec a){ return uvec( nmr(a) ); }\nvec unml(vec a){ return uvec( nml(a) ); }\n\nbool orth(point a1, point a2, point b1, point b2){ return eq( dot( a2 - a1, b2 - b1 ), 0 ); }\nbool orth(vec v1, vec v2){ return eq( dot(v1, v2), 0 ); }\nbool prll(point a1, point a2, point b1, point b2){ return eq( cross( a2 - a1, b2 - b1 ), 0 ); }\nbool prll(vec v1, vec v2){ return eq( cross(v1, v2), 0 ); }\n\nint ccw(point a, point b, point x){\n  b -= a;\n  x -= a;\n  if( gtz( cross(b,x) ) ) return LEFT;\n  if( ltz( cross(b,x) ) ) return RIGHT;\n  if( ltz( dot(b,x) ) ) return BACK;\n  if( lt( abs(b), abs(x) ) ) return FRONT;\n  return OVER;\n}\n\nbool intersectedSS(seg a, seg b)\n{\n  if( ccw(a.fr,a.sc,b.fr)&OVER || ccw(a.fr,a.sc,b.sc)&OVER ) return true;\n  return\n    ( ccw(a.fr,a.sc,b.fr) | ccw(a.fr,a.sc,b.sc) ) == (LEFT|RIGHT) &&\n    ( ccw(b.fr,b.sc,a.fr) | ccw(b.fr,b.sc,a.sc) ) == (LEFT|RIGHT) ;\n}\n\nbool intersectedLL(line a, line b){ return !eq( cross(a.sc-a.fr,b.sc-b.fr), 0.0 ); }\n\npoint intersectionSS(seg a, seg b)\n{\n  elem d1 = dist_l(b,a.fr);\n  elem d2 = dist_l(b,a.sc);\n  return a.fr + ( d1 / (d1 + d2 ) ) * (a.sc-a.fr);\n}\npoint intersectionLL(line a, line b)\n{\n  vec va = a.sc - a.fr;\n  vec vb = b.sc - b.fr;\n  return a.fr + va * ( cross(vb, b.fr - a.fr) / cross(vb,va) );\n}\n\nbool intersectionLL(line a, line b, point &ret){\n  return intersectedLL( a, b ) ? ret = intersectionLL( a, b ), true : false;\n}\nbool intersectionLH(line a, hline b, point &ret){\n  point tmp;\n  return intersectionLL(a,b,tmp) ? ( ccw(b.fr,b.sc,tmp)&(OVER|FRONT) ? ret=tmp, true : false ) : false;\n}\nbool intersectionLS(line l, seg s, point &ret){\n  point tmp;\n  return intersectionLL(l,s,tmp) ? ( ccw(s.fr,s.sc,tmp)&OVER ? ret=tmp, true : false ) : false;\n}\nbool intersectionHH(hline a, hline b, point &ret){\n  point tmp;\n  return intersectionLL(a,b,tmp) ? ( ccw(a.fr,a.sc,tmp)&(OVER|FRONT)&&ccw(b.fr,b.sc,tmp)&(OVER|FRONT) ? ret = tmp, true : false ) : false;\n}\nbool intersectionHS(hline a, seg s, point &ret){\n  point tmp;\n  return intersectionLS(a,s,tmp) ? ( ccw(a.fr,a.sc,tmp)&(OVER|FRONT) ? ret = tmp, true : false ) : false;\n}\nbool intersectionSS(seg a, seg b, point &ret){\n  return intersectedSS(a,b) ? ret = intersectionSS(a,b), true : false;\n}\n\nbool convexCut(const vector<point> &vp,\n\t       line l,\n\t       vector<point> &left)\n{\n  int n = vp.size();\n  bool bFirst = true;\n  int indq1 = -1, indq2 = -1;\n  point q1, q2;\n  \n  for(int i = 0; i < n; ++i){\n    seg edge = make_pair( vp[i], vp[(i+1)%n] );\n    if( bFirst ){\n      if( intersectionLS( l, edge, q1 ) ){ bFirst = false; indq1 = (i+1)%n; }\n    }else{\n      if( intersectionLS( l, edge, q2 ) && far(q1,q2) ){ indq2 = (i+1)%n; break; }\n    }\n  }\n\n  if( indq1<0||indq2<0 ) return false;\n  if( lt( dist( q1, l.second ), dist( q2, l.second ) ) ){ swap( q1, q2 ); swap( indq1, indq2 ); }\n  if( far( q2, vp[indq2] ) ) left.push_back( q2 );\n  for(int i = indq2; i != indq1; i=(i+1>=n?0:i+1)) left.push_back( vp[i] );\n  if( far(q1, vp[(indq1-1+n)%n] ) ) left.push_back( q1 );\n\n  return true;\n}\n\nstruct Point{\n  point p;\n  Point():p(origin){}\n  Point(point p):p(p){}\n  bool operator < (const Point &t)const{\n    if(!eq(p.real(),t.p.real()))return lt(p.real(),t.p.real());\n    else return lt(p.imag(),t.p.imag());\n  }\n};\n\nstruct Node{\n  point p;\n  vector<int> con;\n  vector<double> cost;\n};\n\ntypedef vector<Node> Graph;\n\nstruct VolLine{\n  line l;\n  VolLine():l(origin,origin){}\n  VolLine(line l):l(l){}\n  int point_id[2]; // volonoi points id with touching with this line.\n};\n\nline expandLine(line l, elem mag){\n  line ret = l;\n  vec vf(l.first - l.second);\n  vec vs(l.second - l.first);\n  ret.first = l.second + mag * vf;\n  ret.second = l.first + mag * vs;\n  return ret;\n}\n\nvoid MakeVolonoi(const vector<point> &vp,\n\t\t const vector<point> &plane,\n\t\t vector< vector<point> > &out){\n  vector<point> tplane;\n  \n  for(int i = 0; i < vp.size(); ++i){\n    tplane = plane;\n    for(int j = 0; j < vp.size(); ++j){\n      if( i != j ){\n\tvector<point> newplane;\n\tpoint c = (vp[i]+vp[j])/2.;\n\tint cw = ccw( c, unmr(vp[i]-vp[j])+c, vp[i] );\n\tline bisec;\n\tif( cw == LEFT ){\n\t  bisec = line( c, unmr( vp[i]-vp[j] ) + c );\n\t}else{\n\t  bisec = line( c, unml( vp[i]-vp[j] ) + c );\n\t}\n\tbisec = expandLine( bisec, 20 ); // magnify segment for convex cut\n\tif( convexCut(tplane, bisec, newplane ) )\n\t  tplane = newplane;\n      }\n    }\n    out.push_back( tplane );\n  }\n};\n\nstruct State{\n  int now;\n  elem cost;\n  State(){}\n  bool operator<(const State &t)const{\n    return lt(cost,t.cost);\n  }\n};\n\nelem dijkstra(Graph &G, int sid){\n  elem ret = infty;\n  priority_queue<State> qs;\n  State init;\n  bool vis[G.size()];\n  elem A[G.size()];\n  for(int i = 0; i < G.size(); ++i){\n    vis[i]=false;\n    A[i]=infty;\n  }\n  init.now = sid;\n  init.cost = 0.0;\n  qs.push(init);\n  A[sid]=0.0;\n  while(!qs.empty()){\n    State st_now = qs.top(); qs.pop();\n    int nid = st_now.now;\n    if(vis[nid])continue;\n    else vis[nid]=true;\n    for(int i = 0; i < G[nid].con.size(); ++i){\n      State next;\n      next.now = G[nid].con[i];\n      //cout << next.now << endl;\n      next.cost = st_now.cost + G[nid].cost[i];\n      if( lt(next.cost, A[next.now]) ){\n\tA[next.now] = next.cost;\n\tif( !vis[next.now] ){\n\t  qs.push( next );\n\t}\n      }\n    }\n  }\n  for(int i = 0; i < G.size(); ++i){\n    if( eq(G[i].p.real(),GOAL_X) ){\n      ret = emin( ret, A[i] );\n    }\n  }\n  return ret;\n}\n\nint main()\n{\n  while(true){\n    int n;\n    elem ans=infty;\n    map<Point,int> point_id;\n    vector<point> vp,plane;\n    vector< vector<point> > volonoi;\n\n    cin >> n;\n    if( n == 0 ) break;\n    for(int i = 0; i < n; ++i){\n      elem x,y;\n      cin >> x >> y;\n      vp.push_back( point(x,y) );\n    }\n    plane.push_back( point(0.0,0.0) );\n    plane.push_back( point(4.0,0.0) );\n    plane.push_back( point(4.0,4.0) );\n    plane.push_back( point(0.0,4.0) );\n    MakeVolonoi( vp, plane, volonoi );\n\n    /* debug \n    for(int i = 0; i < volonoi.size(); ++i){\n      cout << \"//\" << i << \" master point : \" << vp[i] << endl;\n      for(int j = 0; j < volonoi[i].size(); ++j){\n\tpoint lf=volonoi[i][j];\n\tpoint ls=volonoi[i][(j+1)%volonoi[i].size()];\n\n\tcout << \"line(\" << lf.real() <<\",\" << lf.imag() <<\",\" << ls.real() <<\",\"<<ls.imag() << \");\" << endl;\n      }\n    }\n    cout << endl;\n    */\n\n    int now = 0;\n    for(int i = 0; i < volonoi.size(); ++i){\n      for(int j = 0; j < volonoi[i].size(); ++j){\n\tPoint pp(volonoi[i][j]);\n\tif( point_id.find( pp ) == point_id.end() ){\n\t  point_id[pp] = now;\n\t  ++now;\n\t}\n      }\n    }\n    Graph G(now);\n\n    // Graph Construction\n    for(int i = 0; i < volonoi.size(); ++i){\n      int ni = volonoi[i].size();\n      for(int j = 0; j < ni; ++j){\n\tpoint p = volonoi[i][j];\n\tpoint np = volonoi[i][(j+1)%ni];\n\telem ck = ((p+np)/2.).imag();\n\tif( eq(ck,0.0)||eq(ck,4.0) ) continue;\n\tint ip = point_id[Point(p)];\n\tint inp = point_id[Point(np)];\n\telem d = dist( p, np );\n\tG[ ip ].p = p;\n\tG[ inp ].p = np;\n\tG[ ip ].con.push_back( inp );\n\tG[ ip ].cost.push_back( d );\n\tG[ inp ].con.push_back( ip );\n\tG[ inp ].cost.push_back( d );\n      }\n    }\n\n    for(int i = 0; i < G.size(); ++i){\n      if( eq( G[i].p.real(), START_X ) ){\n\tans = emin( ans, dijkstra( G, i ) );\n      }\n    }\n\n    if(geq(ans,infty))puts(\"impossible\");\n    else printf(\"%.12lf\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <list>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <fstream>\n#include <cassert>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> PI;\n#define EPS (1e-8)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i, n) rep (i, n)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define min3(a,b,c) min((a),min((b),(c)))\n#define min4(a,b,c,d) min((a),min3((b),(c),(d)))\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FLL(a,b) memset((a),b,sizeof(a))\n#define CLR(a) memset((a),0,sizeof(a))\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\ntemplate<typename T,typename U> ostream& operator<< (ostream& out, const pair<T,U>& val){return out << \"(\" << val.F << \", \" << val.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& out, const vector<T>& val){out << \"{\";rep(i,SZ(val)) out << (i?\", \":\"\") << val[i];return out << \"}\";}\ntypedef double FP;\ntypedef complex<FP> pt;\ntypedef pt P;\ntypedef pair<pt,pt> line;\nFP dot(P a,P b){return real(conj(a)*b);}\nFP crs(P a,P b){return imag(conj(a)*b);}\nP ortho(P a){return a*P(0,1);}\nP ortho(line a){return ortho(a.S-a.F);}\nP crspt(P a,P b,P c,P d){b-=a,d-=c;return a+b*crs(d,c-a)/crs(d,b);}\nP crspt(line a,line b){return crspt(a.F,a.S,b.F,b.S);}\nbool onl(P a1,P a2,P b){return abs(b-a1)+abs(b-a2)<abs(a1-a2)+EPS;}\nbool onl(line a,P b){return onl(a.F,a.S,b);}\nbool iscrs(line a,line b){P c=crspt(a,b);return onl(a,c)&&onl(b,c);}\nvoid pkuassert(bool t){t=1/t;};\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\nenum{TOP,BTM,LFT,RGT,FRT,BCK};\nint dxdy2ce[]={RGT,FRT,LFT,BCK};\ntemplate<class T> T shift(T a,int b,int c,int d,int e){\n __typeof(a[0])t=a[b];a[b]=a[c];a[c]=a[d];a[d]=a[e];a[e]=t;\n return a;}\ntemplate<class T> T rgt(T a){return shift(a,TOP,LFT,BTM,RGT);}\ntemplate<class T> T lft(T a){return shift(a,TOP,RGT,BTM,LFT);}\ntemplate<class T> T frt(T a){return shift(a,TOP,BCK,BTM,FRT);}\ntemplate<class T> T bck(T a){return shift(a,TOP,FRT,BTM,BCK);}\nline mkl(P a,P v){return line(a,a+v);}\nFP lpdist(line a,P b){return abs(b-crspt(a,mkl(b,ortho(a))));}\nFP spdist(line a,P b){\n  P c(crspt(a,mkl(b,ortho(a))));\n  return onl(a,c)?abs(b-c):min(abs(a.F-b),abs(a.S-b));\n}\nFP ssdist(line a,line b){\n return\n  iscrs(a,b)?0.:\n   min4(spdist(a,b.F),spdist(a,b.S),\n        spdist(b,a.F),spdist(b,a.S));\n}\nnamespace std{\n  bool operator<(const P&a,const P&b){\n    return mp(real(a),imag(a))<mp(real(b),imag(b));\n  }\n}\nint ccw(P a, P b, P c) {\n\tdouble d = crs(b -= a, c -= a);\n\treturn d>EPS ? 1 : d<-EPS ? -1 : dot(b,c)<-EPS ? 2 : norm(b)+EPS<norm(c) ? -2 : 0;\n}\n#define CCW(l, a) ccw((l).first, (l).second, (a))\n#define EQ(a, b) (abs((a)-(b)) < EPS)\n#define DI(l) ((l).second-(l).first)\ntypedef line L;\nbool intersectSP(const L &s, const P &p) { return EQ(abs(s.first-p)+abs(s.second-p)-abs(DI(s)), 0); }\nbool intersectSS(const L &s, const L &t) { return CCW(s,t.first)*CCW(s,t.second)<=0 && CCW(t,s.first)*CCW(t,s.second)<=0; }\nbool parallel(const L &l, const L &m) { return EQ(crs(DI(l), DI(m)), 0); }\nbool sameline(const L &l, const L &m) { return parallel(l, m) && EQ(crs(DI(l), m.second-l.first), 0); }\n\n\nvoid arrange_segments(const vector<L> &ls, vector<vector<pair<int, double> > > &G, vector<P> &ps) {\n  \n\trep(i, SZ(ls)) {\n\t\tps.push_back(ls[i].first);\n\t\tps.push_back(ls[i].second);\n\t\trep(j, i) if (intersectSS(ls[i], ls[j]) && !sameline(ls[i], ls[j]))\n\t\t\tps.push_back(crspt(ls[i], ls[j]));\n\t}\n\tsort(ALL(ps));\n\tps.erase(unique(ALL(ps)), ps.end());\n\n\tG.assign(SZ(ps), vector<pair<int, double> >());\n\trep(i, SZ(ls)) {\n\t\tvector<pair<double, int> > as;\n\t\trep(j, SZ(ps)) if (intersectSP(ls[i], ps[j]))\n\t\t\tas.push_back(make_pair(norm(ls[i].first - ps[j]), j));\n\t\tsort(ALL(as));\n\t\trep(j, SZ(as)-1) {\n\t\t\tint a = as[j].second, b = as[j+1].second;\n\t\t\tdouble l = abs(ps[a] - ps[b]);\n\t\t\tG[a].push_back(make_pair(b, l));\n\t\t\tG[b].push_back(make_pair(a, l));\n\t\t}\n\t}\n\trep(i, SZ(G)) {\n\t\tsort(ALL(G[i]));\n\t\tG[i].erase(unique(ALL(G[i])), G[i].end());\n\t}\n}\n\nint n;\nP in[100];\nbool app[2000];\n\n\nvoid solve(){\n  rep(i,n) cin >> in[i].real() >> in[i].imag();\n\n  CLR(app);\n  vector<line> li;\n  rep(i,n)rep(j,i){\n    line ij(ortho(in[i]-in[j])+(in[i]+in[j])*0.5,(in[i]+in[j])*0.5);\n    P t=ij.F-ij.S;\n    t *= 10/abs(t);\n    ij.F+=t;\n    ij.S-=t;\n    li.pb(ij);\n  }\n  li.pb(line(P(0,-1),P(0,5)));\n  li.pb(line(P(4,-1),P(4,5)));\n  vector<vector<pair<int, double> > > G;\n  priority_queue<pair<double,int> > q;  \n  vector<P> ps;\n  arrange_segments(li,G,ps);\n  FOR(it,ps) if(onl(line(P(0,0),P(0,4)),*it)) \n    q.push(mp(0,it-ps.begin()));\n  while(!q.empty()){\n    double cc=-q.top().F;\n    int cv=q.top().S;\n    q.pop();\n    double cx=real(ps[cv]);\n    double cy=imag(ps[cv]);\n    \n    if(min(cx,cy)<-EPS || max(cx,cy)>4+EPS) continue;\n    if(app[cv]) continue;\n    if(EQ(cx,4)){\n      printf(\"%.8f\\n\",cc);\n      return;\n    }\n    app[cv]=true;\n    FOR(it,G[cv]){\n      line ed(ps[cv],ps[it->F]);\n      vector<double> di;\n      rep(i,n)\n        di.pb(spdist(ed,in[i]));\n      sort(ALL(di));\n      if(n>=2 && EQ(di[0],di[1]))\n        q.push(mp(-cc-it->S,it->F));\n    }\n\n  }\n\n  cout << \"impossible\" << endl;\n}\n\nint main(int argc, char *argv[])\n{\n  while(cin >> n && n) solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define EPS (1e-5)\n#define INF (1e100)\n#define equals(a, b) (fabs(a - b) < EPS)\n\nstruct Point {\n    double x, y;\n\n    Point () {}\n    Point (double x, double y) : x(x), y(y) {}\n\n    Point operator + (const Point &p) const {\n        return Point(x + p.x, y + p.y);\n    }\n    \n    Point operator - (const Point &p) const {\n        return Point(x - p.x, y - p.y);\n    }\n    \n    Point operator * (const double &k) const {\n        return Point(x * k, y * k);\n    }\n\n    bool operator == (const Point &p) const {\n        return (equals(x, p.x) && equals(y, p.y));\n    }    \n    \n    bool operator < (const Point &p) const {\n        if (!equals(x, p.x)) {\n            return x < p.x;\n        } else {\n            return y < p.y;\n        }\n    }\n};\n\ndouble dot(const Point &a, const Point &b)\n{\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(const Point &a, const Point &b)\n{\n    return a.x * b.y - b.x * a.y;\n}\n\ndouble norm(const Point &p)\n{\n    return dot(p, p);\n}\n\ndouble abs(const Point &p)\n{\n    return sqrt(norm(p));\n}\n\ndouble dist(const Point &a, const Point &b)\n{\n    return sqrt(pow(a.x - b.x, 2) + pow(a.y - b.y, 2));\n}\n\n#define COUNTER_CLOCKWISE +1\n#define CLOCKWISE         -1\n#define ONLINE_BACK       +2\n#define ONLINE_FRONT      -2\n#define ON_SEGMENT        +0\ntypedef Point Vector;\n\nint ccw(const Point &p0, const Point &p1, const Point &p2)\n{\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if (cross(a, b) > EPS)  return COUNTER_CLOCKWISE;\n    if (cross(a, b) < -EPS) return CLOCKWISE;\n    if (dot(a, b) < -EPS)   return ONLINE_BACK;\n    if (norm(a) < norm(b))  return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nstruct Segment {\n    Point s, t;\n    Segment(){}\n    Segment(Point s, Point t) : s(s), t(t) {}\n};\n\ntypedef Segment Line;\n\nLine perpendicular_bisector(const Point &a, const Point &b)\n{\n    double cx = (a.x + b.x) / 2.0;\n    double cy = (a.y + b.y) / 2.0;\n    Point p = Point(cx + (a.y - b.y), cy + (b.x - a.x));\n    return Line(Point(cx, cy), p);\n}\n\nPoint crosspointLL(const Line &a, const Line &b)\n{\n    Vector va = a.t - a.s, vb = b.t - b.s;\n    double d = cross(vb, va);\n    if (abs(d) < EPS) return b.s;\n    return a.s + va * cross(vb, b.t - a.s) * (1.0 / d);\n}\n\n#define curr(G, i) (G[i % G.size()])\n#define next(G, i) (G[(i + 1) % G.size()])\ntypedef vector<Point> Polygon;\n\nPolygon convex_cut(const Polygon &pg, const Line &l)\n{\n    Polygon res;\n    for (int i = 0; i < (int)pg.size(); i++) {\n        Point cp = curr(pg, i), np = next(pg, i);\n        if (ccw(l.s, l.t, cp) != -1) res.push_back(cp);\n        if (ccw(l.s, l.t, cp) * ccw(l.s, l.t, np) < 0) {\n            res.push_back(crosspointLL(Line(cp, np), l));\n        }\n    }\n    return res;\n}\n\nbool check(Point a, Point b)\n{\n    if (a.x > b.x) swap(a, b);\n    if (equals(a.x, b.x) && a.y > b.y) swap(a, b);\n    if (a == Point(0, 0) && b == Point(0, 4)) return 1;\n    if (a == Point(0, 0) && b == Point(4, 0)) return 1;\n    if (a == Point(0, 4) && b == Point(4, 4)) return 1;\n    if (a == Point(4, 0) && b == Point(4, 4)) return 1;\n    return 0;\n}\n\nvector<Segment> make_segments(vector<Point> &ps)\n{\n    Polygon pg(4);\n    pg[0] = Point(0, 0);\n    pg[1] = Point(0, 4);\n    pg[2] = Point(4, 4);\n    pg[3] = Point(4, 0);\n\n    vector<Segment> segs;\n    \n    int N = ps.size();\n    for (int i = 0; i < N; i++) {\n        Polygon p = pg;\n        for (int j = 0; j < N; j++) {\n            if (i == j) continue;\n            p = convex_cut(p, perpendicular_bisector(ps[i], ps[j]));\n        }\n        int M = p.size();\n        for (int j = 0; j < M; j++) {\n            if (check(curr(p, j), next(p, j))) continue;            \n            segs.push_back(Segment(curr(p, j), next(p, j)));\n        }\n    }\n    return segs;\n}\n\nstruct Edge {\n    int to;\n    double cost;\n    Edge (int to, double cost) : to(to), cost(cost) {}\n    bool operator < (const Edge &e) const {\n        return cost < e.cost;\n    }\n};\n\ntypedef vector<vector<Edge>> Graph;\n\nbool isIntersectSS(const Segment &a, const Segment &b)\n{\n    Point s[2] = {a.s, a.t}, t[2] = {b.s, b.t};\n    return (ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n\t    ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0);\n}\n\nbool isIntersectSP(const Segment &s, const Point &p)\n{\n    return (ccw(s.s, s.t, p) == 0);\n}\n\nPoint crosspointSS(const Segment &a, const Segment &b)\n{\n    Vector va = a.t - a.s, vb = b.t - b.s;\n    double d = cross(vb, va);\n    return a.s + va * cross(vb, b.t - a.s) * (1.0 / d);\n}\n\nGraph segment_arrangement(vector<Segment> &segs, vector<Point> &ps)\n{\n    Graph G;\n    int N = segs.size();\n    ps.clear();\n\n    for (int i = 0; i < N; i++) {\n\tps.push_back(segs[i].s);\n\tps.push_back(segs[i].t);\n\tfor (int j = i+1; j < N; j++) {\n\t    Vector a = segs[i].t - segs[i].s;\n\t    Vector b = segs[j].t - segs[j].s;\n\t    if (equals(cross(a, b), 0)) continue;            \n\t    if (isIntersectSS(segs[i], segs[j])) {\n\t\tps.push_back(crosspointSS(segs[i], segs[j]));\n\t    }\n\t}\n    }\n    sort(ps.begin(), ps.end());\n    ps.erase(unique(ps.begin(), ps.end()), ps.end());\n\n    int N2 = ps.size();\n    G.resize(N2);\n    for (int i = 0; i < N; i++) {\n\tvector<pair<double,int>> vec;\n\tfor (int j = 0; j < N2; j++) {\n\t    if (isIntersectSP(segs[i], ps[j])) {\n\t\tdouble d = dist(segs[i].s, ps[j]);\n\t\tvec.push_back(make_pair(d, j));\n\t    }\n\t}\n\tsort(vec.begin(), vec.end());\n\tfor (int j = 0; j < (int)vec.size()-1; j++) {\n\t    int u = vec[j].second, v = vec[j+1].second;\n\t    double d = dist(ps[u], ps[v]);\n\t    G[u].push_back(Edge(v, d));\n\t    G[v].push_back(Edge(u, d));\n\t}\n    }\n    return G;\n}\n\ndouble solve(vector<Point> &ps)\n{\n    vector<Segment> v = make_segments(ps);\n    vector<Point> p;\n    Graph G = segment_arrangement(v, p);\n\n    int N = p.size();    \n    vector<vector<double>> d(N, vector<double>(N, INF));\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < (int)G[i].size(); j++) {\n            d[i][G[i][j].to] = G[i][j].cost;\n        }\n        d[i][i] = 0;\n    }\n\n    for (int k = 0; k < N; k++) {\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n            }\n        }\n    }\n\n    double res = INF;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (!check(p[i], p[j]) && equals(p[i].x, 0) && equals(p[j].x, 4)) {\n                res = min(res, d[i][j]);\n            }\n        }\n    }    \n    return res;\n}\n\nint main()\n{\n    int n;\n    while (cin >> n, n) {\n        vector<Point> ps(n);\n        for (int i = 0; i < n; i++) {\n            cin >> ps[i].x >> ps[i].y;\n        }\n        double res = solve(ps);\n        if (n == 1 || res == INF) {\n            puts(\"impossible\");\n        } else {\n            printf(\"%.15f\\n\", res);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <cctype>\n#include <ctime>\n#include <cassert>\n#include <cwchar>\n#include <cstdarg>\n#include <cwctype>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <functional>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <fstream>\nusing namespace std;\n\ntypedef long long int lli;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=(x);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n\nint dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n/*\n ½Êô½Ìî{vfD\n  ÀÊð­È­·é½ßÉC¡f^ðp¢Ä_ð\\·D\n  xÀWÍreal(p),yÀWÍimag(p)Ìæ¤É·éD\n  _ÍxNgÆµÄàp¢éD\n  size(p)ÅxNgÌå«³CcrossCdotª»ê¼êàÏCOÏð\\·D\n\n  ¼üE¼¼üEüªÍvfª2ÂÌvector<Point>Å\\í·\n\n  ªê\n   PF_\n   L:¼ü\n   SFüª\n   G:½p`\n   CF~\n*/\n\nconst double EPS=1e-7;\nconst double INF=1e10;\n\n\ntypedef complex<double> Point;\ninline double size(const Point &a){return abs(a);}\ninline double cross(const Point &a,const Point &b){return real(a)*real(b)+imag(a)*imag(b);}\ninline double dot(const Point &a,const Point &b){return real(a)*imag(b)-real(a)*imag(b);}\ninline double atan(const Point &a){return atan2(imag(a),real(a));}\nnamespace std{\n\tbool operator<(const Point &a,const Point &b){return real(a)==real(b)?imag(a)<imag(b):real(a)<real(b);}\n}\nstruct Line:vector<Point>{\n\tLine(double x1=0,double y1=0,double x2=0,double y2=0){\n\t\t(*this).push_back(Point(x1,y1));\n\t\t(*this).push_back(Point(x2,y2));\n\t}\n\tLine(Point a,Point b){\n\t\t(*this).push_back(a);(*this).push_back(b);\n\t}\n\tPoint vector(){\n\t\treturn at(1)-at(0);\n\t}\n};\ninline double size(const Line &a){\n\treturn size(a[1]-a[0]);\n}\nstruct Circle{\n\tCircle(Point center,double radius):c(center),r(radius){};\n\tCircle(double x=0,double y=0,double r=0){(*this)=Circle(Point(x,y),r);}\n\tPoint c;double r;\n};\ntypedef vector<Point> Polygon;\nLine getside(const Polygon& p,int no){\n\treturn Line(p[no],p[no%p.size()]);\n}\n\n/*\n _Ìisûü(ccw)\n  http://www.prefield.com/algorithm/geometry/ccw.htmlæè\n  ^¦çê½O_ a, b, c ð a ¨ b ¨ c ÆiÞÆ«C\n\n    -1 : a ¨ b ÅvûüÉÜêÄ b ¨ c\n    +1 : a ¨ b Å¼vûüÉÜêÄ b ¨ c\n    +2 : a ¨ b Åtðü¢Ä a ðÊèzµÄ b ¨ c\n    -2 : a ¨ b Å»ÌÜÜ b ¨ c\n     0 : a ¨ b Åtðü¢Ä b ¨ c ( Ü½Í b == c )\n\n  Ì¢ÃêÌp^[Å é©ð»è·éD\n*/\n\nint ccw(Point a,Point b,Point c){\n    b-=a;c-=a;\n    if(cross(b, c)>0)return +1;       // counter clockwise\n    if(cross(b, c)<0)return -1;       // clockwise\n    if(dot(b, c)<0)return +2;       // c--a--b on line\n    if(norm(b)<norm(c))return -2;       // a--b--c on line\n    return 0;\n}\n\n\n\n\n//-----\n\nvoid add_point(vector<Point> &pts,const Point n){\n\tFOR(it,pts){\n\t\tif(abs((*it)-n)<EPS)return;\n\t}\n\tpts.push_back(n);\n}\nint main(){\n\tfor(;;){\n\t\tint n;\n\t\tcin>>n;\n\t\tvector<Point> monster;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tdouble x,y;\n\t\t\tcin>>x>>y;\n\t\t\tadd_point(monster,Point(x,y));\n\t\t}\n\t\tif(n!=(int)monster.size())exit(-1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//accepted by rose 2160,rose 1213\n//cut pos is depend on whether input polygon is clockwise or cunterclock wise\n//ortho?gical line de cut\n#include<iostream>\n#include<complex>\n#include<vector>\n#include<map>\n#include<queue>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\nconst double eps = 1e-10;\n\n#define RIGHT 1\n#define LEFT -1\n\ntypedef complex<double> P;\ntypedef vector<P> Polygon;\ntypedef pair<P,P> Line;\n\n\nclass Edge{\npublic:\n  int to;\n  double cost;\n  Edge(){};\n  Edge(int tto,double ccost):to(tto),cost(ccost){}\n};\n\nclass Point{\npublic:\n  P data;\n  Point(){};\n  Point(P a):data(a){}\n  bool operator<(const Point & a)const{\n    if ( abs(data.real()-a.data.real())>eps)return data.real()<a.data.real();\n    if ( abs(data.imag()-a.data.imag())>eps)return data.imag()<a.data.imag();\n    return false;\n  }\n};\n\ndouble cross(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\nP intersection_ll(P a1,P a2,P b1,P b2){\n  P a=a2-a1,b=b2-b1;\n  return a1+a*cross(b,b1-a1)/cross(b,a);\n}\n\n\nint ccw(P a,P b){\n  if ( cross(a,b)<0)return RIGHT;\n  else if ( cross(a,b)>0)return LEFT;\n  return 2;\n}\n\nvector<P> Convex_Cut(Polygon in,int n,P a1,P a2,int cutpos){\n  vector<P> ret;\n  rep(i,n){\n    P now = in[i],next=in[(i+1)%n];\n    if( ccw(a1-a2,now-a2)==cutpos)ret.push_back(now);\n    if ( ccw(a1-a2,now-a1)*ccw(a1-a2,next-a2)<0)\n      ret.push_back(intersection_ll(a1,a2,now,next));\n  }\n  return ret;\n}\n\n//cutpos ha mondai izon. which side will remain\nLine make_line(P ori,P b,int cutpos){\n  P tmp=(ori+b);\n  tmp.real()/=2;tmp.imag()/=2;\n  P ret=b-tmp;\n  swap(ret.real(),ret.imag());\n  ret.real()*=-1;\n  if ( ccw(ret,ori-tmp)!= cutpos)return make_pair(tmp,ret+tmp);\n  return make_pair(ret+tmp,tmp);\n}\n\n\nvoid solve(int m,Polygon in,vector<P> CutLine,map<Point,int> &M,vector<Edge> *E,vector<P> &startcandidate){\n  vector<Line> ver;\n  rep(i,CutLine.size())\n    if ( i == m)continue;\n    else ver.push_back(make_line(CutLine[m],CutLine[i],LEFT));\n\n  rep(i,ver.size())\n    in=Convex_Cut(in,in.size(),ver[i].first,ver[i].second,LEFT);\n  \n  rep(i,in.size()){\n    Point f(in[i]),t(in[(i+1)%in.size()]);\n    int from,to;\n    if ( M.find(f) ==M.end()){\n      int tmp=M.size();M[f]=tmp,startcandidate.push_back(in[i]);\n    }\n    from=M[f];\n    if ( M.find(t) ==M.end()){\n      int tmp=M.size();M[t]=tmp,startcandidate.push_back(in[(i+1)%in.size()]);\n    }\n    to=M[t];\n    \n    if (abs(in[i].imag())<eps && abs(in[(i+1)%in.size()].imag()) <eps)continue;\n    if (abs(in[i].imag()-4)<eps && abs(in[(i+1)%in.size()].imag()-4)<eps)continue;\n    E[from].push_back(Edge(to,abs(in[i]-in[(i+1)%in.size()])));\n    E[to].push_back(Edge(from,abs(in[i]-in[(i+1)%in.size()])));\n  }\n}\n\n\n\nconst double INF = 100000000;\nvoid solve2(int n,vector<int> start,vector<int>goal,vector<Edge> *E){\n  double ans=INF;\n  double cost[n][n];\n  rep(i,n){\n    rep(j,n)cost[i][j]=INF;\n  }\n  rep(i,n){\n    rep(j,E[i].size()){\n      cost[i][E[i][j].to]=E[i][j].cost;\n    }\n  }\n\n  rep(k,n){\n    rep(i,n){\n      rep(j,n)cost[i][j]=min(cost[i][j],cost[i][k]+cost[k][j]);\n    }\n  }\n\n  rep(i,start.size()){\n    rep(j,goal.size()){\n      ans = min(ans,cost[start[i]][goal[j]]);\n    }\n  }\n  if ( ans >= INF-eps)puts(\"impossible\");\n  else printf(\"%.5lf\\n\",ans);\n}\n\nmain(){\n  int n;\n  Polygon a;\n  a.push_back(complex<double>(0,0));\n  a.push_back(complex<double>(4,0));\n  a.push_back(complex<double>(4,4));\n  a.push_back(complex<double>(0,4));\n  while(cin>>n && n){\n    vector<P> Mons;\n    map<Point,int> M;\n    vector<Edge>    E[500];\n    vector<P> node;\n    rep(i,n){\n      P tmp;\n      cin>>tmp.real()>>tmp.imag();\n      Mons.push_back(tmp);\n    }\n    \n    rep(i,n){\n      solve(i,a,Mons,M,E,node);\n    }\n\n    vector<int> start,goal;\n    n=node.size();\n    rep(i,n){\n      if ( node[i].real()<eps)start.push_back(i);\n      else if ( abs(node[i].real()-4)<eps)goal.push_back(i);\n    }\n    if ( n >200)return true;\n    solve2(n,start,goal,E);\n    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(arg),key)-begin(arg)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n\nusing namespace std;\n\ntemplate<class T>void reg(vector<T> &ary,const T &elem){ary.emplace_back(elem);}\ntemplate<class T>bool chmin(T &a, const T &b) {return (b<a)?(a=b,1):0;}\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\n\nusing R=long double; // __float128\nconst R EPS = 1E-10; // [-1000:1000]->EPS=1e-8 [-10000:10000]->EPS=1e-7\nconst R INF = 1E40;\nconstexpr R PI = acos(R(-1));\ninline int sgn(const R& r){ return (r > EPS) - (r < -EPS);}\ninline int sgn(const R& a, const R &b){ return sgn(a-b); }\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n\nusing P=complex<R>;\nusing VP=vector<P>;\nusing L=struct{P s,t;};\nusing VL=vector<L>;\nusing C=struct{P c;R r;};\nusing VC=vector<C>;\n\nconstexpr P O = P(0,0);\nistream& operator >> (istream& is,P& p){ R x,y;is >> x >> y; p=P(x,y); return is;}\nostream& operator << (ostream& os,P& p){ os << real(p) << \" \" << imag(p); return os;}\n\nnamespace std{\n\tbool operator <  (const P& a,const P& b){ return sgn(real(a-b))?real(a-b)<0:sgn(imag(a-b))<0;}\n\tbool operator == (const P& a,const P& b){ return sgn(real(a-b))==0 && sgn(imag(a-b))==0;}\n}\n\nbool operator <  (const L& a,const L& b){ return a.s==b.s?a.t<b.t:a.s<b.s;}\nbool operator == (const L& a,const L& b){ return a.s==b.s&&a.t==b.t;}\n\n//?????? dot ?????? det\ninline R dot(P o,P a,P b){a-=o,b-=o; return real(conj(a)*b);}\ninline R det(P o,P a,P b){a-=o,b-=o; return imag(conj(a)*b);}\n\n// CCW verify AOJ CGL_1_C\nenum CCW{ LEFT = 1,RIGHT = 2,BACK = 4,FRONT = 8,ON = 16};\ninline int ccw(P o,P a, P b) {//???a??¨???b???????????????????????????\n\tif (sgn(det(o,a,b)) > 0) return LEFT;    // counter clockwise\n\tif (sgn(det(o,a,b)) < 0) return RIGHT;   // clockwise\n\tif (sgn(dot(o,a,b)) < 0) return BACK;    // b--base--a on line\n\tif (sgn(norm(a-o)-norm(b-o)) < 0) return FRONT;   // base--a--b on line\n\treturn ON;// base--b--a on line  a??¨b????????????????????????\n}\n\n// ?????´ ?????? verify AOJ CGL_2_A\nbool vertical(L a, L b) {return sgn(dot(O,a.t-a.s,b.t-b.s))==0;}\nbool parallel(L a, L b) {return sgn(det(O,a.t-a.s,b.t-b.s))==0;}\nbool eql(L a,L b){ return (parallel(a,b) && sgn(det(a.s,a.t,b.s))==0);}\n\n\n// ???????????????verify AOJ CGL_2_B ???????????????????????´??????1,????????´??????0\nbool iss(L a,L b,int end=0){\n\tint s1=ccw(a.s,a.t,b.s)|ccw(a.s,a.t,b.t);\n\tint s2=ccw(b.s,b.t,a.s)|ccw(b.s,b.t,a.t);\n\tif(end) return (s1&s2)==(LEFT|RIGHT);\n\treturn (s1|s2)&ON || (s1&s2)==(LEFT|RIGHT);\n}\n\n// ?????? verify AOJ CGL_2_C\nP cross(L a,L b){\n\tR s1=det(a.s,b.s,b.t);\n\tR s2=s1+det(a.t,b.t,b.s);\n\treturn a.s+s1/s2*(a.t-a.s);\n}\n\t\n// ???????????? verify AOJ CGL_4_C\nVP convex_cut(const VP& pol,const L& l) {\n\tVP res;\n\tint n=pol.size();\n\trep(i,n){\n\t\tP a = pol[i],b=pol[(i+1)%n];\n\t\tif(ccw(l.s,l.t,a)!=RIGHT) reg(res,a);\n\t\tif((ccw(l.s,l.t,a)|ccw(l.s,l.t,b))==(LEFT|RIGHT)) reg(res,cross({a,b},l));\n\t}\n\treturn res;\n}\n\nconst int vmax=5010;\nstruct node{int to;R cost;};\nvector<node> graph[vmax];\ninline void add_edge(int f,int t,R c){reg(graph[f],{t,c}),reg(graph[t],{f,c});}\n\nvoid segment_arrangement(const vector<L> &seg, vector<P> &point){\n\trep(i,vmax) graph[i].clear();\n\trep(i,seg.size()){\n\t\treg(point,seg[i].s),reg(point,seg[i].t);\n\t\trep(j,i) if(iss(seg[i],seg[j])) reg(point,cross(seg[i],seg[j]));\n\t}\n\tuniq(point);\n\trep(i,seg.size()){\n\t\tvector<pair<R,int>> idx;\n\t\trep(j,point.size()) if(ccw(seg[i].s,seg[i].t,point[j])==ON) reg(idx,{norm(point[j]-seg[i].s),j});\n\t\tsort(_all(idx));\n\t\trep(j,1,int(idx.size())){\n\t\t\tint a=idx[j-1].second,b=idx[j].second;\n\t\t\tadd_edge(a,b,abs(point[a]-point[b]));\n\t\t}\n\t}\n}\n\nL bisector(P a, P b){P mid=(a+b)/P(2,0);return L{mid, mid+(b-a)*P(0,1)};}\nVP voronoi_cell(VP pol,VP v,int s){rep(i,v.size())if(i!=s)pol=convex_cut(pol,bisector(v[s],v[i]));return pol;}\n\nR dist[vmax];\nR dijkstra(const VP &point){\n\tfill(dist,dist+vmax,INF);\n\tusing state=tuple<R,int>;\n\tpriority_queue<state,vector<state>,greater<state>> q;\n\trep(s,point.size()) if(sgn(real(point[s]))==0) dist[s]=0,q.push(state(0,s));\n\twhile(!q.empty()){\n\t\tR c;int v;\n\t\ttie(c,v)=q.top();q.pop();\n\t\tfor(auto &e:graph[v]){\n\t\t\tR nc=c+e.cost; int nv=e.to;\n\t\t\tif(chmin(dist[nv],nc)) q.push(state(nc,nv));\n\t\t}\n\t}\n\tR res=INF;\n\trep(t,point.size()) if(sgn(real(point[t])-4.0)==0) chmin(res,dist[t]);\n\treturn res;\n}\n\n// ????????????????????????\nVL segment_merge(VL l) {\n\tint n=l.size();\n\trep(i,n) if(l[i].t<l[i].s) swap(l[i].s,l[i].t);\n\tsort(_all(l));\n\trep(i,l.size())rep(j,i){\n\t\tif(iss(l[i],l[j],0)&&!iss(l[i],l[j],1)){\n\t\t\tif(abs(l[i].t-l[j].s)>abs(l[j].t-l[j].s)) l[j].t=l[i].t;\n\t\t\tl.erase(begin(l)+i--);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn l;\n}\n\nint main(void){\n\tint n;\n\twhile(cin >> n,n){\n\t\tVP pol={P(0,0),P(4,0),P(4,4),P(0,4)};\n\t\tVP vornoi,point;\n\t\tVL seg;\n\t\trep(i,n){\n\t\t\tP p;\n\t\t\tcin >> p;\n\t\t\treg(vornoi,p);\n\t\t}\n\t\trep(i,n){\n\t\t\tVP res=voronoi_cell(pol,vornoi,i);\n\t\t\tfor(auto &p:res) reg(point,p);\n\t\t\tint m=res.size();\n\t\t\trep(i,m){\n\t\t\t\tL l={res[i],res[(i+1)%m]};\n\t\t\t\tbool ok=true;\n\t\t\t\trep(i,4) if(eql(l,{pol[i],pol[(i+1)%4]})) ok=false;\n\t\t\t\tif(ok) reg(seg,l);\n\t\t\t}\n\t\t}\n\t\tseg=segment_merge(seg);\n\t\tsegment_arrangement(seg,point);\n\t\tR res=dijkstra(point);\n\t\tcout.precision(20);\n\t\tif(res>=INF)\n\t\t\tcout << \"impossible\" << endl;\n\t\telse\n\t\t\tcout << fixed << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<vector>\n#include<iostream>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<cmath>\n#include<cassert>\n\n#define START_X 0.0\n#define GOAL_X 4.0\n\n#define FRONT 0x01\n#define RIGHT 0x02\n#define BACK 0x04\n#define LEFT 0x08\n#define OVER 0x10\n\n#define sc second\n#define fr first\n\n#define REP(i,n) for(int i = 0; i < (int)(n); ++i)\n\nusing namespace std;\n\ntypedef double elem;\ntypedef complex<elem> point, vec;\ntypedef pair<point, point> line, hline, seg, pp;\n\nconst double eps = 1.0e-12;\nconst double pi = acos(-1.0);\nconst double infty = 1e40;\npoint base(0,0),origin(0,0);\n\nbool eq(elem a, elem b){ return abs(a-b) < eps; }\nbool lt(elem a, elem b){ return !eq(a,b) && a < b; }\nbool leq(elem a, elem b){ return eq(a,b) || a < b; }\nbool gt(elem a, elem b){ return !eq(a,b) && a > b; }\nbool geq(elem a, elem b){ return eq(a,b) || a > b; }\nbool ltz(elem a){ return lt( a, 0 ); }\nbool gtz(elem a){ return gt( a, 0 ); }\nbool eqv(vec a, vec b){ return eq( abs(b-a),0); }\nbool is_zv(vec v){ return eq(abs(v),0); }\nelem emax(elem a, elem b){ return gt(a,b)?a:b; }\nelem emin(elem a, elem b){ return lt(a,b)?a:b; }\n\nbool far(point a, point b){ return gtz( abs(b-a) ); }\nbool near(point a, point b){ return leq( abs(b-a), 0 ); }\nelem dot(vec a, vec b){ return (a.real() * b.real() + a.imag() * b.imag() ); }\nelem cross(vec a, vec b){ return ( a.real() * b.imag() - a.imag() * b.real() ); }\n\nelem dist(point a, point b){ return abs(a-b); }\nelem dist_l(line l, point x){ return abs(cross(l.sc-l.fr,x-l.fr)) / abs(l.sc-l.fr); }\nelem dist_seg(seg s, point x)\n{\n  if( ltz( dot(s.sc-s.fr,x-s.fr) ) ) return abs(x-s.fr);\n  if( ltz( dot(s.fr-s.sc,x-s.sc) ) ) return abs(x-s.sc);\n  return dist_l(s,x);\n}\n\nvec uvec(vec a){ return a / abs(a); }\nvec nmr(vec a){ return a * vec(0,-1); }\nvec nml(vec a){ return a * vec(0,1); }\nvec unmr(vec a){ return uvec( nmr(a) ); }\nvec unml(vec a){ return uvec( nml(a) ); }\n\nbool orth(point a1, point a2, point b1, point b2){ return eq( dot( a2 - a1, b2 - b1 ), 0 ); }\nbool orth(vec v1, vec v2){ return eq( dot(v1, v2), 0 ); }\nbool prll(point a1, point a2, point b1, point b2){ return eq( cross( a2 - a1, b2 - b1 ), 0 ); }\nbool prll(vec v1, vec v2){ return eq( cross(v1, v2), 0 ); }\n\nint ccw(point a, point b, point x){\n  b -= a;\n  x -= a;\n  if( gtz( cross(b,x) ) ) return LEFT;\n  if( ltz( cross(b,x) ) ) return RIGHT;\n  if( ltz( dot(b,x) ) ) return BACK;\n  if( lt( abs(b), abs(x) ) ) return FRONT;\n  return OVER;\n}\n\nbool intersectedSS(seg a, seg b)\n{\n  if( ccw(a.fr,a.sc,b.fr)&OVER || ccw(a.fr,a.sc,b.sc)&OVER ) return true;\n  return\n    ( ccw(a.fr,a.sc,b.fr) | ccw(a.fr,a.sc,b.sc) ) == (LEFT|RIGHT) &&\n    ( ccw(b.fr,b.sc,a.fr) | ccw(b.fr,b.sc,a.sc) ) == (LEFT|RIGHT) ;\n}\n\nbool intersectedLL(line a, line b){ return !eq( cross(a.sc-a.fr,b.sc-b.fr), 0.0 ); }\n\npoint intersectionSS(seg a, seg b)\n{\n  elem d1 = dist_l(b,a.fr);\n  elem d2 = dist_l(b,a.sc);\n  return a.fr + ( d1 / (d1 + d2 ) ) * (a.sc-a.fr);\n}\npoint intersectionLL(line a, line b)\n{\n  vec va = a.sc - a.fr;\n  vec vb = b.sc - b.fr;\n  return a.fr + va * ( cross(vb, b.fr - a.fr) / cross(vb,va) );\n}\n\nbool intersectionLL(line a, line b, point &ret){\n  return intersectedLL( a, b ) ? ret = intersectionLL( a, b ), true : false;\n}\nbool intersectionLH(line a, hline b, point &ret){\n  point tmp;\n  return intersectionLL(a,b,tmp) ? ( ccw(b.fr,b.sc,tmp)&(OVER|FRONT) ? ret=tmp, true : false ) : false;\n}\nbool intersectionLS(line l, seg s, point &ret){\n  point tmp;\n  return intersectionLL(l,s,tmp) ? ( ccw(s.fr,s.sc,tmp)&OVER ? ret=tmp, true : false ) : false;\n}\nbool intersectionHH(hline a, hline b, point &ret){\n  point tmp;\n  return intersectionLL(a,b,tmp) ? ( ccw(a.fr,a.sc,tmp)&(OVER|FRONT)&&ccw(b.fr,b.sc,tmp)&(OVER|FRONT) ? ret = tmp, true : false ) : false;\n}\nbool intersectionHS(hline a, seg s, point &ret){\n  point tmp;\n  return intersectionLS(a,s,tmp) ? ( ccw(a.fr,a.sc,tmp)&(OVER|FRONT) ? ret = tmp, true : false ) : false;\n}\nbool intersectionSS(seg a, seg b, point &ret){\n  return intersectedSS(a,b) ? ret = intersectionSS(a,b), true : false;\n}\n\nbool convexCut(const vector<point> &vp,\n\t       line l,\n\t       vector<point> &left)\n{\n  int n = vp.size();\n  bool bFirst = true;\n  int indq1 = -1, indq2 = -1;\n  point q1, q2;\n  \n  for(int i = 0; i < n; ++i){\n    seg edge = make_pair( vp[i], vp[(i+1)%n] );\n    if( bFirst ){\n      if( intersectionLS( l, edge, q1 ) ){ bFirst = false; indq1 = (i+1)%n; }\n    }else{\n      if( intersectionLS( l, edge, q2 ) && far(q1,q2) ){ indq2 = (i+1)%n; break; }\n    }\n  }\n\n  if( indq1<0||indq2<0 ) return false;\n  if( lt( dist( q1, l.second ), dist( q2, l.second ) ) ){ swap( q1, q2 ); swap( indq1, indq2 ); }\n  if( far( q2, vp[indq2] ) ) left.push_back( q2 );\n  for(int i = indq2; i != indq1; i=(i+1>=n?0:i+1)) left.push_back( vp[i] );\n  if( far(q1, vp[(indq1-1+n)%n] ) ) left.push_back( q1 );\n\n  return true;\n}\n\nstruct Point{\n  point p;\n  Point():p(origin){}\n  Point(point p):p(p){}\n  bool operator < (const Point &t)const{\n    if(!eq(p.real(),t.p.real()))return lt(p.real(),t.p.real());\n    else return lt(p.imag(),t.p.imag());\n  }\n};\n\nstruct Node{\n  point p;\n  vector<int> con;\n  vector<double> cost;\n};\n\ntypedef vector<Node> Graph;\n\nline expandLine(line l, elem mag){\n  line ret = l;\n  vec vf(l.first - l.second);\n  vec vs(l.second - l.first);\n  ret.first = l.second + mag * vf;\n  ret.second = l.first + mag * vs;\n  return ret;\n}\n\nvoid MakeVolonoi(const vector<point> &vp,\n\t\t const vector<point> &plane,\n\t\t vector< vector<point> > &out){\n  vector<point> tplane;\n  \n  for(int i = 0; i < vp.size(); ++i){\n    tplane = plane;\n    for(int j = 0; j < vp.size(); ++j){\n      if( i != j ){\n\tvector<point> newplane;\n\tpoint c = (vp[i]+vp[j])/2.;\n\tint cw = ccw( c, unmr(vp[i]-vp[j])+c, vp[i] );\n\tassert(cw==LEFT||cw==RIGHT);\n\tline bisec;\n\tif( cw == LEFT ){\n\t  bisec = line( c, unmr( vp[i]-vp[j] ) + c );\n\t}else{\n\t  bisec = line( c, unml( vp[i]-vp[j] ) + c );\n\t}\n\tbisec = expandLine( bisec, 100.0 ); // magnify segment for convex cut\n\t//cout << abs(bisec.second-bisec.first) << endl;\n\tif( convexCut(tplane, bisec, newplane ) )\n\t  tplane = newplane;\n      }\n    }\n    out.push_back( tplane );\n  }\n};\n\nstruct State{\n  int now;\n  elem cost;\n  State(){}\n  bool operator<(const State &t)const{\n    return lt(cost,t.cost);\n  }\n};\n\nelem dijkstra(Graph &G, int sid){\n  elem ret = infty;\n  priority_queue<State> qs;\n  State init;\n  bool vis[G.size()];\n  elem A[G.size()];\n  for(int i = 0; i < G.size(); ++i){\n    vis[i]=false;\n    A[i]=infty;\n  }\n  init.now = sid;\n  init.cost = 0.0;\n  qs.push(init);\n  A[sid]=0.0;\n  while(!qs.empty()){\n    State st_now = qs.top(); qs.pop();\n    int nid = st_now.now;\n    if(vis[nid])continue;\n    else vis[nid]=true;\n    for(int i = 0; i < G[nid].con.size(); ++i){\n      State next;\n      next.now = G[nid].con[i];\n      //cout << next.now << endl;\n      next.cost = st_now.cost + G[nid].cost[i];\n      if( lt(next.cost, A[next.now]) ){\n\tA[next.now] = next.cost;\n\tif( !vis[next.now] ){\n\t  qs.push( next );\n\t}\n      }\n    }\n  }\n  for(int i = 0; i < G.size(); ++i){\n    if( eq(G[i].p.real(),GOAL_X) ){\n      ret = emin( ret, A[i] );\n    }\n  }\n  return ret;\n}\n\nint main()\n{\n  while(true){\n    int n;\n    elem ans=infty;\n    map<Point,int> point_id;\n    vector<point> vp,plane;\n    vector< vector<point> > volonoi;\n\n    cin >> n;\n    if( n == 0 ) break;\n    for(int i = 0; i < n; ++i){\n      elem x,y;\n      cin >> x >> y;\n      vp.push_back( point(x,y) );\n    }\n    if( n == 1 ){\n      puts(\"impossible\");\n      continue;\n    }\n    plane.push_back( point(0.0,0.0) );\n    plane.push_back( point(4.0,0.0) );\n    plane.push_back( point(4.0,4.0) );\n    plane.push_back( point(0.0,4.0) );\n    MakeVolonoi( vp, plane, volonoi );\n\n    /* debug \n    for(int i = 0; i < volonoi.size(); ++i){\n      cout << \"//\" << i << \" master point : \" << vp[i] << endl;\n      for(int j = 0; j < volonoi[i].size(); ++j){\n\tpoint lf=volonoi[i][j];\n\tpoint ls=volonoi[i][(j+1)%volonoi[i].size()];\n\n\tcout << \"line(\" << lf.real() <<\",\" << lf.imag() <<\",\" << ls.real() <<\",\"<<ls.imag() << \");\" << endl;\n      }\n    }\n    cout << endl;\n    */\n\n    int now = 0;\n    for(int i = 0; i < volonoi.size(); ++i){\n      for(int j = 0; j < volonoi[i].size(); ++j){\n\tPoint pp(volonoi[i][j]);\n\tif( point_id.find( pp ) == point_id.end() ){\n\t  point_id[pp] = now;\n\t  ++now;\n\t}\n      }\n    }\n    Graph G(now);\n\n    // Graph Construction\n    for(int i = 0; i < volonoi.size(); ++i){\n      int ni = volonoi[i].size();\n      for(int j = 0; j < ni; ++j){\n\tpoint p = volonoi[i][j];\n\tpoint np = volonoi[i][(j+1)%ni];\n\t\n\tif( eq(p.real(),np.real())&&eq(p.real(),0.0) ||\n\t    eq(p.real(),np.real())&&eq(p.real(),4.0) ||\n\t    eq(p.imag(),np.imag())&&eq(p.imag(),0.0) ||\n\t    eq(p.imag(),np.imag())&&eq(p.imag(),4.0) )continue;\n\tint ip = point_id[Point(p)];\n\tint inp = point_id[Point(np)];\n\telem d = dist( p, np );\n\tG[ ip ].p = p;\n\tG[ inp ].p = np;\n\tG[ ip ].con.push_back( inp );\n\tG[ ip ].cost.push_back( d );\n\tG[ inp ].con.push_back( ip );\n\tG[ inp ].cost.push_back( d );\n      }\n    }\n\n    for(int i = 0; i < G.size(); ++i){\n      if( eq( G[i].p.real(), START_X ) ){\n\tans = emin( ans, dijkstra( G, i ) );\n      }\n    }\n\n    if(geq(ans,infty))puts(\"impossible\");\n    else printf(\"%.12lf\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <list>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <fstream>\n#include <cassert>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> PI;\n#define EPS (1e-10)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i, n) rep (i, n)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define min3(a,b,c) min((a),min((b),(c)))\n#define min4(a,b,c,d) min((a),min3((b),(c),(d)))\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FLL(a,b) memset((a),b,sizeof(a))\n#define CLR(a) memset((a),0,sizeof(a))\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\ntemplate<typename T,typename U> ostream& operator<< (ostream& out, const pair<T,U>& val){return out << \"(\" << val.F << \", \" << val.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& out, const vector<T>& val){out << \"{\";rep(i,SZ(val)) out << (i?\", \":\"\") << val[i];return out << \"}\";}\ntypedef double FP;\ntypedef complex<FP> pt;\ntypedef pt P;\ntypedef pair<pt,pt> line;\nFP dot(P a,P b){return real(conj(a)*b);}\nFP crs(P a,P b){return imag(conj(a)*b);}\nP ortho(P a){return a*P(0,1);}\nP ortho(line a){return ortho(a.S-a.F);}\nP crspt(P a,P b,P c,P d){b-=a,d-=c;return a+b*crs(d,c-a)/crs(d,b);}\nP crspt(line a,line b){return crspt(a.F,a.S,b.F,b.S);}\nbool onl(P a1,P a2,P b){return abs(b-a1)+abs(b-a2)<abs(a1-a2)+EPS;}\nbool onl(line a,P b){return onl(a.F,a.S,b);}\nbool iscrs(line a,line b){P c=crspt(a,b);return onl(a,c)&&onl(b,c);}\nvoid pkuassert(bool t){t=1/t;};\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\nenum{TOP,BTM,LFT,RGT,FRT,BCK};\nint dxdy2ce[]={RGT,FRT,LFT,BCK};\ntemplate<class T> T shift(T a,int b,int c,int d,int e){\n __typeof(a[0])t=a[b];a[b]=a[c];a[c]=a[d];a[d]=a[e];a[e]=t;\n return a;}\ntemplate<class T> T rgt(T a){return shift(a,TOP,LFT,BTM,RGT);}\ntemplate<class T> T lft(T a){return shift(a,TOP,RGT,BTM,LFT);}\ntemplate<class T> T frt(T a){return shift(a,TOP,BCK,BTM,FRT);}\ntemplate<class T> T bck(T a){return shift(a,TOP,FRT,BTM,BCK);}\nline mkl(P a,P v){return line(a,a+v);}\nFP lpdist(line a,P b){return abs(b-crspt(a,mkl(b,ortho(a))));}\nFP spdist(line a,P b){\n  P c(crspt(a,mkl(b,ortho(a))));\n  return onl(a,c)?abs(b-c):min(abs(a.F-b),abs(a.S-b));\n}\nFP ssdist(line a,line b){\n return\n  iscrs(a,b)?0.:\n   min4(spdist(a,b.F),spdist(a,b.S),\n        spdist(b,a.F),spdist(b,a.S));\n}\nnamespace std{\n  bool operator<(const P&a,const P&b){\n    return mp(real(a),imag(a))<mp(real(b),imag(b));\n  }\n}\nint ccw(P a, P b, P c) {\n\tdouble d = crs(b -= a, c -= a);\n\treturn d>EPS ? 1 : d<-EPS ? -1 : dot(b,c)<-EPS ? 2 : norm(b)+EPS<norm(c) ? -2 : 0;\n}\n#define CCW(l, a) ccw((l).first, (l).second, (a))\n#define EQ(a, b) (abs((a)-(b)) < EPS)\n#define DI(l) ((l).second-(l).first)\ntypedef line L;\nbool intersectSP(const L &s, const P &p) { return EQ(abs(s.first-p)+abs(s.second-p)-abs(DI(s)), 0); }\nbool intersectSS(const L &s, const L &t) { return CCW(s,t.first)*CCW(s,t.second)<=0 && CCW(t,s.first)*CCW(t,s.second)<=0; }\nbool parallel(const L &l, const L &m) { return EQ(crs(DI(l), DI(m)), 0); }\nbool sameline(const L &l, const L &m) { return parallel(l, m) && EQ(crs(DI(l), m.second-l.first), 0); }\n\n\nvoid arrange_segments(const vector<L> &ls, vector<vector<pair<int, double> > > &G, vector<P> &ps) {\n  \n\trep(i, SZ(ls)) {\n\t\tps.push_back(ls[i].first);\n\t\tps.push_back(ls[i].second);\n\t\trep(j, i) if (intersectSS(ls[i], ls[j]) && !sameline(ls[i], ls[j]))\n\t\t\tps.push_back(crspt(ls[i], ls[j]));\n\t}\n\tsort(ALL(ps));\n\tps.erase(unique(ALL(ps)), ps.end());\n\n\tG.assign(SZ(ps), vector<pair<int, double> >());\n\trep(i, SZ(ls)) {\n\t\tvector<pair<double, int> > as;\n\t\trep(j, SZ(ps)) if (intersectSP(ls[i], ps[j]))\n\t\t\tas.push_back(make_pair(norm(ls[i].first - ps[j]), j));\n\t\tsort(ALL(as));\n\t\trep(j, SZ(as)-1) {\n\t\t\tint a = as[j].second, b = as[j+1].second;\n\t\t\tdouble l = abs(ps[a] - ps[b]);\n\t\t\tG[a].push_back(make_pair(b, l));\n\t\t\tG[b].push_back(make_pair(a, l));\n\t\t}\n\t}\n\trep(i, SZ(G)) {\n\t\tsort(ALL(G[i]));\n\t\tG[i].erase(unique(ALL(G[i])), G[i].end());\n\t}\n}\n\nint n;\nP in[100];\nbool app[2000];\n\n\nvoid solve(){\n  rep(i,n) cin >> in[i].real() >> in[i].imag();\n\n  CLR(app);\n  vector<line> li;\n  rep(i,n)rep(j,i){\n    line ij(ortho(in[i]-in[j])+(in[i]+in[j])*0.5,(in[i]+in[j])*0.5);\n    P t=ij.F-ij.S;\n    t *= 10/abs(t);\n    ij.F+=t;\n    ij.S-=t;\n    li.pb(ij);\n  }\n  li.pb(line(P(0,-1),P(0,5)));\n  li.pb(line(P(4,-1),P(4,5)));\n  vector<vector<pair<int, double> > > G;\n  priority_queue<pair<double,int> > q;  \n  vector<P> ps;\n  arrange_segments(li,G,ps);\n  FOR(it,ps) if(onl(line(P(0,0),P(0,4)),*it)) \n    q.push(mp(0,it-ps.begin()));\n  while(!q.empty()){\n    double cc=-q.top().F;\n    int cv=q.top().S;\n    q.pop();\n    double cx=real(ps[cv]);\n    double cy=imag(ps[cv]);\n    \n    if(min(cx,cy)<-EPS || max(cx,cy)>4+EPS) continue;\n    if(app[cv]) continue;\n    if(EQ(cx,4)){\n      printf(\"%.8f\\n\",cc);\n      return;\n    }\n    app[cv]=true;\n    FOR(it,G[cv]){\n      line ed(ps[cv],ps[it->F]);\n      vector<double> di;\n      rep(i,n)\n        di.pb(spdist(ed,in[i]));\n      sort(ALL(di));\n      if(n>=2 && EQ(di[0],di[1]))\n        q.push(mp(-cc-it->S,it->F));\n    }\n\n  }\n\n  cout << \"impossible\" << endl;\n}\n\nint main(int argc, char *argv[])\n{\n  while(cin >> n && n) solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<vector>\n#include<iostream>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<cmath>\n#include<cassert>\n\n#define START_X 0.0\n#define GOAL_X 4.0\n\n#define FRONT 0x01\n#define RIGHT 0x02\n#define BACK 0x04\n#define LEFT 0x08\n#define OVER 0x10\n\n#define sc second\n#define fr first\n\n#define REP(i,n) for(int i = 0; i < (int)(n); ++i)\n\nusing namespace std;\n\ntypedef double elem;\ntypedef complex<elem> point, vec;\ntypedef pair<point, point> line, hline, seg, pp;\n\nconst double eps = 1.0e-11;\nconst double pi = acos(-1.0);\nconst double infty = 1e40;\npoint base(0,0),origin(0,0);\n\nbool eq(elem a, elem b){ return abs(a-b) < eps; }\nbool lt(elem a, elem b){ return !eq(a,b) && a < b; }\nbool leq(elem a, elem b){ return eq(a,b) || a < b; }\nbool gt(elem a, elem b){ return !eq(a,b) && a > b; }\nbool geq(elem a, elem b){ return eq(a,b) || a > b; }\nbool ltz(elem a){ return lt( a, 0 ); }\nbool gtz(elem a){ return gt( a, 0 ); }\nbool eqv(vec a, vec b){ return eq( abs(b-a),0); }\nbool is_zv(vec v){ return eq(abs(v),0); }\nelem emax(elem a, elem b){ return gt(a,b)?a:b; }\nelem emin(elem a, elem b){ return lt(a,b)?a:b; }\n\nbool far(point a, point b){ return gtz( abs(b-a) ); }\nbool near(point a, point b){ return leq( abs(b-a), 0 ); }\nelem dot(vec a, vec b){ return (a.real() * b.real() + a.imag() * b.imag() ); }\nelem cross(vec a, vec b){ return ( a.real() * b.imag() - a.imag() * b.real() ); }\n\nelem dist(point a, point b){ return abs(a-b); }\nelem dist_l(line l, point x){ return abs(cross(l.sc-l.fr,x-l.fr)) / abs(l.sc-l.fr); }\nelem dist_seg(seg s, point x)\n{\n  if( ltz( dot(s.sc-s.fr,x-s.fr) ) ) return abs(x-s.fr);\n  if( ltz( dot(s.fr-s.sc,x-s.sc) ) ) return abs(x-s.sc);\n  return dist_l(s,x);\n}\n\nvec uvec(vec a){ return a / abs(a); }\nvec nmr(vec a){ return a * vec(0,-1); }\nvec nml(vec a){ return a * vec(0,1); }\nvec unmr(vec a){ return uvec( nmr(a) ); }\nvec unml(vec a){ return uvec( nml(a) ); }\n\nbool orth(point a1, point a2, point b1, point b2){ return eq( dot( a2 - a1, b2 - b1 ), 0 ); }\nbool orth(vec v1, vec v2){ return eq( dot(v1, v2), 0 ); }\nbool prll(point a1, point a2, point b1, point b2){ return eq( cross( a2 - a1, b2 - b1 ), 0 ); }\nbool prll(vec v1, vec v2){ return eq( cross(v1, v2), 0 ); }\n\nint ccw(point a, point b, point x){\n  b -= a;\n  x -= a;\n  if( gtz( cross(b,x) ) ) return LEFT;\n  if( ltz( cross(b,x) ) ) return RIGHT;\n  if( ltz( dot(b,x) ) ) return BACK;\n  if( lt( abs(b), abs(x) ) ) return FRONT;\n  return OVER;\n}\n\nbool intersectedSS(seg a, seg b)\n{\n  if( ccw(a.fr,a.sc,b.fr)&OVER || ccw(a.fr,a.sc,b.sc)&OVER ) return true;\n  return\n    ( ccw(a.fr,a.sc,b.fr) | ccw(a.fr,a.sc,b.sc) ) == (LEFT|RIGHT) &&\n    ( ccw(b.fr,b.sc,a.fr) | ccw(b.fr,b.sc,a.sc) ) == (LEFT|RIGHT) ;\n}\n\nbool intersectedLL(line a, line b){ return !eq( cross(a.sc-a.fr,b.sc-b.fr), 0.0 ); }\n\npoint intersectionSS(seg a, seg b)\n{\n  elem d1 = dist_l(b,a.fr);\n  elem d2 = dist_l(b,a.sc);\n  return a.fr + ( d1 / (d1 + d2 ) ) * (a.sc-a.fr);\n}\npoint intersectionLL(line a, line b)\n{\n  vec va = a.sc - a.fr;\n  vec vb = b.sc - b.fr;\n  return a.fr + va * ( cross(vb, b.fr - a.fr) / cross(vb,va) );\n}\n\nbool intersectionLL(line a, line b, point &ret){\n  return intersectedLL( a, b ) ? ret = intersectionLL( a, b ), true : false;\n}\nbool intersectionLH(line a, hline b, point &ret){\n  point tmp;\n  return intersectionLL(a,b,tmp) ? ( ccw(b.fr,b.sc,tmp)&(OVER|FRONT) ? ret=tmp, true : false ) : false;\n}\nbool intersectionLS(line l, seg s, point &ret){\n  point tmp;\n  return intersectionLL(l,s,tmp) ? ( ccw(s.fr,s.sc,tmp)&OVER ? ret=tmp, true : false ) : false;\n}\nbool intersectionHH(hline a, hline b, point &ret){\n  point tmp;\n  return intersectionLL(a,b,tmp) ? ( ccw(a.fr,a.sc,tmp)&(OVER|FRONT)&&ccw(b.fr,b.sc,tmp)&(OVER|FRONT) ? ret = tmp, true : false ) : false;\n}\nbool intersectionHS(hline a, seg s, point &ret){\n  point tmp;\n  return intersectionLS(a,s,tmp) ? ( ccw(a.fr,a.sc,tmp)&(OVER|FRONT) ? ret = tmp, true : false ) : false;\n}\nbool intersectionSS(seg a, seg b, point &ret){\n  return intersectedSS(a,b) ? ret = intersectionSS(a,b), true : false;\n}\n\nbool convexCut(const vector<point> &vp,\n\t       line l,\n\t       vector<point> &left)\n{\n  int n = vp.size();\n  bool bFirst = true;\n  int indq1 = -1, indq2 = -1;\n  point q1, q2;\n  \n  for(int i = 0; i < n; ++i){\n    seg edge = make_pair( vp[i], vp[(i+1)%n] );\n    if( bFirst ){\n      if( intersectionLS( l, edge, q1 ) ){ bFirst = false; indq1 = (i+1)%n; }\n    }else{\n      if( intersectionLS( l, edge, q2 ) && far(q1,q2) ){ indq2 = (i+1)%n; break; }\n    }\n  }\n\n  if( indq1<0||indq2<0 ) return false;\n  if( lt( dist( q1, l.second ), dist( q2, l.second ) ) ){ swap( q1, q2 ); swap( indq1, indq2 ); }\n  if( far( q2, vp[indq2] ) ) left.push_back( q2 );\n  for(int i = indq2; i != indq1; i=(i+1>=n?0:i+1)) left.push_back( vp[i] );\n  if( far(q1, vp[(indq1-1+n)%n] ) ) left.push_back( q1 );\n\n  return true;\n}\n\nstruct Point{\n  point p;\n  Point():p(origin){}\n  Point(point p):p(p){}\n  bool operator < (const Point &t)const{\n    if(!eq(p.real(),t.p.real()))return lt(p.real(),t.p.real());\n    else return lt(p.imag(),t.p.imag());\n  }\n};\n\nstruct Node{\n  point p;\n  vector<int> con;\n  vector<double> cost;\n};\n\ntypedef vector<Node> Graph;\n\nline expandLine(line l, elem mag){\n  line ret = l;\n  vec vf(l.first - l.second);\n  vec vs(l.second - l.first);\n  ret.first = l.second + mag * vf;\n  ret.second = l.first + mag * vs;\n  return ret;\n}\n\nvoid MakeVolonoi(const vector<point> &vp,\n\t\t const vector<point> &plane,\n\t\t vector< vector<point> > &out){\n  vector<point> tplane;\n  \n  for(int i = 0; i < vp.size(); ++i){\n    tplane = plane;\n    for(int j = 0; j < vp.size(); ++j){\n      if( i != j ){\n\tvector<point> newplane;\n\tpoint c = (vp[i]+vp[j])/2.;\n\tint cw = ccw( c, unmr(vp[i]-vp[j])+c, vp[i] );\n\tassert(cw==LEFT||cw==RIGHT);\n\tline bisec;\n\tif( cw == LEFT ){\n\t  bisec = line( c, unmr( vp[i]-vp[j] ) + c );\n\t}else{\n\t  bisec = line( c, unml( vp[i]-vp[j] ) + c );\n\t}\n\tbisec = expandLine( bisec, 100.0 ); // magnify segment for convex cut\n\t//cout << abs(bisec.second-bisec.first) << endl;\n\tif( convexCut(tplane, bisec, newplane ) )\n\t  tplane = newplane;\n      }\n    }\n    out.push_back( tplane );\n  }\n};\n\nstruct State{\n  int now;\n  elem cost;\n  State(){}\n  bool operator<(const State &t)const{\n    return lt(cost,t.cost);\n  }\n};\n\nelem dijkstra(Graph &G, int sid){\n  elem ret = infty;\n  priority_queue<State> qs;\n  State init;\n  bool vis[G.size()];\n  elem A[G.size()];\n  for(int i = 0; i < G.size(); ++i){\n    vis[i]=false;\n    A[i]=infty;\n  }\n  init.now = sid;\n  init.cost = 0.0;\n  qs.push(init);\n  A[sid]=0.0;\n  vis[sid]=true;\n  while(!qs.empty()){\n    State st_now = qs.top(); qs.pop();\n    int nid = st_now.now;\n    vis[nid]=false;\n    for(int i = 0; i < G[nid].con.size(); ++i){\n      State next;\n      next.now = G[nid].con[i];\n      //cout << next.now << endl;\n      next.cost = st_now.cost + G[nid].cost[i];\n      if( lt(next.cost, A[next.now]) ){\n\tA[next.now] = next.cost;\n\tif( !vis[next.now] ){\n\t  vis[next.now]=true;\n\t  qs.push( next );\n\t}\n      }\n    }\n  }\n  for(int i = 0; i < G.size(); ++i){\n    if( eq(G[i].p.real(),GOAL_X) ){\n      ret = emin( ret, A[i] );\n    }\n  }\n  return ret;\n}\n\nint main()\n{\n  while(true){\n    int n;\n    elem ans=infty;\n    map<Point,int> point_id;\n    vector<point> vp,plane;\n    vector< vector<point> > volonoi;\n\n    cin >> n;\n    if( n == 0 ) break;\n    for(int i = 0; i < n; ++i){\n      elem x,y;\n      cin >> x >> y;\n      vp.push_back( point(x,y) );\n    }\n    if( n == 1 ){\n      puts(\"impossible\");\n      continue;\n    }\n    plane.push_back( point(0.0,0.0) );\n    plane.push_back( point(4.0,0.0) );\n    plane.push_back( point(4.0,4.0) );\n    plane.push_back( point(0.0,4.0) );\n    MakeVolonoi( vp, plane, volonoi );\n\n    /* debug \n    for(int i = 0; i < volonoi.size(); ++i){\n      cout << \"//\" << i << \" master point : \" << vp[i] << endl;\n      for(int j = 0; j < volonoi[i].size(); ++j){\n\tpoint lf=volonoi[i][j];\n\tpoint ls=volonoi[i][(j+1)%volonoi[i].size()];\n\n\tcout << \"line(\" << lf.real() <<\",\" << lf.imag() <<\",\" << ls.real() <<\",\"<<ls.imag() << \");\" << endl;\n      }\n    }\n    cout << endl;\n    */\n\n    int now = 0;\n    for(int i = 0; i < volonoi.size(); ++i){\n      for(int j = 0; j < volonoi[i].size(); ++j){\n\tPoint pp(volonoi[i][j]);\n\tif( point_id.find( pp ) == point_id.end() ){\n\t  point_id[pp] = now;\n\t  ++now;\n\t}\n      }\n    }\n    Graph G(now);\n\n    // Graph Construction\n    for(int i = 0; i < volonoi.size(); ++i){\n      int ni = volonoi[i].size();\n      for(int j = 0; j < ni; ++j){\n\tpoint p = volonoi[i][j];\n\tpoint np = volonoi[i][(j+1)%ni];\n\t\n\tif( eq(p.real(),np.real())&&eq(p.real(),0.0) ||\n\t    eq(p.real(),np.real())&&eq(p.real(),4.0) ||\n\t    eq(p.imag(),np.imag())&&eq(p.imag(),0.0) ||\n\t    eq(p.imag(),np.imag())&&eq(p.imag(),4.0) )continue;\n\tint ip = point_id[Point(p)];\n\tint inp = point_id[Point(np)];\n\telem d = dist( p, np );\n\tG[ ip ].p = p;\n\tG[ inp ].p = np;\n\tG[ ip ].con.push_back( inp );\n\tG[ ip ].cost.push_back( d );\n\tG[ inp ].con.push_back( ip );\n\tG[ inp ].cost.push_back( d );\n      }\n    }\n\n    for(int i = 0; i < G.size(); ++i){\n      if( eq( G[i].p.real(), START_X ) ){\n\tans = emin( ans, dijkstra( G, i ) );\n      }\n    }\n\n    if(geq(ans,infty))puts(\"impossible\");\n    else printf(\"%.12lf\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(arg),key)-begin(arg)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n\nusing namespace std;\n\ntemplate<class T>void reg(vector<T> &ary,const T &elem){ary.emplace_back(elem);}\ntemplate<class T>bool chmin(T &a, const T &b) {return (b<a)?(a=b,1):0;}\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\n\nusing R=long double; // __float128\nconst R EPS = 1E-10; // [-1000:1000]->EPS=1e-8 [-10000:10000]->EPS=1e-7\nconst R INF = 1E40;\nconstexpr R PI = acos(R(-1));\ninline int sgn(const R& r){ return (r > EPS) - (r < -EPS);}\ninline int sgn(const R& a, const R &b){ return sgn(a-b); }\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n\nusing P=complex<R>;\nusing VP=vector<P>;\nusing L=struct{P s,t;};\nusing VL=vector<L>;\nusing C=struct{P c;R r;};\nusing VC=vector<C>;\n\nconstexpr P O = P(0,0);\nistream& operator >> (istream& is,P& p){ R x,y;is >> x >> y; p=P(x,y); return is;}\nostream& operator << (ostream& os,P& p){ os << real(p) << \" \" << imag(p); return os;}\n\nnamespace std{\n\tbool operator <  (const P& a,const P& b){ return sgn(real(a-b))?real(a-b)<0:sgn(imag(a-b))<0;}\n\tbool operator == (const P& a,const P& b){ return sgn(real(a-b))==0 && sgn(imag(a-b))==0;}\n}\n\nbool operator <  (const L& a,const L& b){ return a.s==b.s?a.t<b.t:a.s<b.s;}\nbool operator == (const L& a,const L& b){ return a.s==b.s&&a.t==b.t;}\n\n//?????? dot ?????? det\ninline R dot(P o,P a,P b){a-=o,b-=o; return real(conj(a)*b);}\ninline R det(P o,P a,P b){a-=o,b-=o; return imag(conj(a)*b);}\n\n// CCW verify AOJ CGL_1_C\nenum CCW{ LEFT = 1,RIGHT = 2,BACK = 4,FRONT = 8,ON = 16};\ninline int ccw(P o,P a, P b) {//???a??¨???b???????????????????????????\n\tif (sgn(det(o,a,b)) > 0) return LEFT;    // counter clockwise\n\tif (sgn(det(o,a,b)) < 0) return RIGHT;   // clockwise\n\tif (sgn(dot(o,a,b)) < 0) return BACK;    // b--base--a on line\n\tif (sgn(norm(a-o)-norm(b-o)) < 0) return FRONT;   // base--a--b on line\n\treturn ON;// base--b--a on line  a??¨b????????????????????????\n}\n\n// ?????´ ?????? verify AOJ CGL_2_A\nbool vertical(L a, L b) {return sgn(dot(O,a.t-a.s,b.t-b.s))==0;}\nbool parallel(L a, L b) {return sgn(det(O,a.t-a.s,b.t-b.s))==0;}\nbool eql(L a,L b){ return (parallel(a,b) && sgn(det(a.s,a.t,b.s))==0);}\n\n\n// ???????????????verify AOJ CGL_2_B ???????????????????????´??????1,????????´??????0\nbool iss(L a,L b,int end=0){\n\tint s1=ccw(a.s,a.t,b.s)|ccw(a.s,a.t,b.t);\n\tint s2=ccw(b.s,b.t,a.s)|ccw(b.s,b.t,a.t);\n\tif(end) return (s1&s2)==(LEFT|RIGHT);\n\treturn (s1|s2)&ON || (s1&s2)==(LEFT|RIGHT);\n}\n\n// ?????? verify AOJ CGL_2_C\nP cross(L a,L b){\n\tR s1=det(a.s,b.s,b.t);\n\tR s2=s1+det(a.t,b.t,b.s);\n\treturn a.s+s1/s2*(a.t-a.s);\n}\n\t\n// ???????????? verify AOJ CGL_4_C\nVP convex_cut(const VP& pol,const L& l) {\n\tVP res;\n\tint n=pol.size();\n\trep(i,n){\n\t\tP a = pol[i],b=pol[(i+1)%n];\n\t\tif(ccw(l.s,l.t,a)!=RIGHT) reg(res,a);\n\t\tif((ccw(l.s,l.t,a)|ccw(l.s,l.t,b))==(LEFT|RIGHT)) reg(res,cross({a,b},l));\n\t}\n\treturn res;\n}\n\nconst int vmax=5010;\nstruct node{int to;R cost;};\nvector<node> graph[vmax];\ninline void add_edge(int f,int t,R c){reg(graph[f],{t,c}),reg(graph[t],{f,c});}\n\nvoid segment_arrangement(const vector<L> &seg, vector<P> &point){\n\trep(i,vmax) graph[i].clear();\n\trep(i,seg.size()){\n\t\treg(point,seg[i].s),reg(point,seg[i].t);\n\t\trep(j,i) if(iss(seg[i],seg[j],1)) reg(point,cross(seg[i],seg[j]));\n\t}\n\tuniq(point);\n\trep(i,seg.size()){\n\t\tvector<pair<R,int>> idx;\n\t\trep(j,point.size()) if(ccw(seg[i].s,seg[i].t,point[j])==ON) reg(idx,{norm(point[j]-seg[i].s),j});\n\t\tsort(_all(idx));\n\t\trep(j,1,int(idx.size())){\n\t\t\tint a=idx[j-1].second,b=idx[j].second;\n\t\t\tadd_edge(a,b,abs(point[a]-point[b]));\n\t\t}\n\t}\n}\n\nL bisector(P a, P b){P mid=(a+b)/P(2,0);return L{mid, mid+(b-a)*P(0,1)};}\nVP voronoi_cell(VP pol,VP v,int s){rep(i,v.size())if(i!=s)pol=convex_cut(pol,bisector(v[s],v[i]));return pol;}\n\nR dist[vmax];\nR dijkstra(const VP &point){\n\tfill(dist,dist+vmax,INF);\n\tusing state=tuple<R,int>;\n\tpriority_queue<state,vector<state>,greater<state>> q;\n\trep(s,point.size()) if(sgn(real(point[s]))==0) dist[s]=0,q.push(state(0,s));\n\twhile(!q.empty()){\n\t\tR c;int v;\n\t\ttie(c,v)=q.top();q.pop();\n\t\tfor(auto &e:graph[v]){\n\t\t\tR nc=c+e.cost; int nv=e.to;\n\t\t\tif(chmin(dist[nv],nc)) q.push(state(nc,nv));\n\t\t}\n\t}\n\tR res=INF;\n\trep(t,point.size()) if(sgn(real(point[t])-4.0)==0) chmin(res,dist[t]);\n\treturn res;\n}\n\nint main(void){\n\tint n;\n\twhile(cin >> n,n){\n\t\tVP pol={P(0,0),P(4,0),P(4,4),P(0,4)};\n\t\tVP vornoi,point;\n\t\tVL seg;\n\t\trep(i,n){\n\t\t\tP p;\n\t\t\tcin >> p;\n\t\t\treg(vornoi,p);\n\t\t}\n\t\trep(i,n){\n\t\t\tVP res=voronoi_cell(pol,vornoi,i);\n\t\t\tfor(auto &p:res) reg(point,p);\n\t\t\tint m=res.size();\n\t\t\trep(i,m){\n\t\t\t\tL l={res[i],res[(i+1)%m]};\n\t\t\t\tbool ok=true;\n\t\t\t\trep(i,4) if(eql(l,{pol[i],pol[(i+1)%4]})) ok=false;\n\t\t\t\tif(ok) reg(seg,l);\n\t\t\t}\n\t\t}\n\t\tsegment_arrangement(seg,point);\n\t\tR res=dijkstra(point);\n\t\tcout.precision(20);\n\t\tif(res>=INF)\n\t\t\tcout << \"impossible\" << endl;\n\t\telse\n\t\t\tcout << fixed << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//accepted by rose 2160,rose 1213\n//cut pos is depend on whether input polygon is clockwise or cunterclock wise\n//ortho?gical line de cut\n#include<iostream>\n#include<complex>\n#include<vector>\n#include<map>\n#include<queue>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\nconst double eps = 1e-10;\n\n#define RIGHT 1\n#define LEFT -1\n\ntypedef complex<double> P;\ntypedef vector<P> Polygon;\ntypedef pair<P,P> Line;\n\n\nclass Edge{\npublic:\n  int to;\n  double cost;\n  Edge(){};\n  Edge(int tto,double ccost):to(tto),cost(ccost){}\n};\n\nclass Point{\npublic:\n  P data;\n  Point(){};\n  Point(P a):data(a){}\n  bool operator<(const Point & a)const{\n    if ( abs(data.real()-a.data.real())>eps)return data.real()<a.data.real();\n    if ( abs(data.imag()-a.data.imag())>eps)return data.imag()<a.data.imag();\n    return false;\n  }\n};\n\ndouble cross(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\nP intersection_ll(P a1,P a2,P b1,P b2){\n  P a=a2-a1,b=b2-b1;\n  return a1+a*cross(b,b1-a1)/cross(b,a);\n}\n\n\nint ccw(P a,P b){\n  if ( cross(a,b)<0)return RIGHT;\n  else if ( cross(a,b)>0)return LEFT;\n  return 2;\n}\n\nvector<P> Convex_Cut(Polygon in,int n,P a1,P a2,int cutpos){\n  vector<P> ret;\n  rep(i,n){\n    P now = in[i],next=in[(i+1)%n];\n    if( ccw(a1-a2,now-a2)==cutpos)ret.push_back(now);\n    if ( ccw(a1-a2,now-a1)*ccw(a1-a2,next-a2)<0)\n      ret.push_back(intersection_ll(a1,a2,now,next));\n  }\n  return ret;\n}\n\n//cutpos ha mondai izon. which side will remain\nLine make_line(P ori,P b,int cutpos){\n  P tmp=(ori+b);\n  tmp.real()/=2;tmp.imag()/=2;\n  P ret=b-tmp;\n  swap(ret.real(),ret.imag());\n  ret.real()*=-1;\n  if ( ccw(ret,ori-tmp)!= cutpos)return make_pair(tmp,ret+tmp);\n  return make_pair(ret+tmp,tmp);\n}\n\n\nvoid solve(int m,Polygon in,vector<P> CutLine,map<Point,int> &M,vector<Edge> *E,vector<P> &startcandidate){\n  vector<Line> ver;\n  rep(i,CutLine.size())\n    if ( i == m)continue;\n    else ver.push_back(make_line(CutLine[m],CutLine[i],LEFT));\n\n  rep(i,ver.size())\n    in=Convex_Cut(in,in.size(),ver[i].first,ver[i].second,LEFT);\n  cout << in.size() << endl;\n\n  rep(i,in.size()){\n    Point f(in[i]),t(in[(i+1)%in.size()]);\n    int from,to;\n    if ( M.find(f) ==M.end()){\n      int tmp=M.size();M[f]=tmp,startcandidate.push_back(in[i]);\n    }\n    from=M[f];\n    if ( M.find(t) ==M.end()){\n      int tmp=M.size();M[t]=tmp,startcandidate.push_back(in[(i+1)%in.size()]);\n    }\n    to=M[t];\n    \n    if (abs(in[i].imag())<eps && abs(in[(i+1)%in.size()].imag()) <eps)continue;\n    if (abs(in[i].imag()-4)<eps && abs(in[(i+1)%in.size()].imag()-4)<eps)continue;\n    E[from].push_back(Edge(to,abs(in[i]-in[(i+1)%in.size()])));\n    E[to].push_back(Edge(from,abs(in[i]-in[(i+1)%in.size()])));\n  }\n}\n\n\n\n\nvoid solve2(int n,vector<int> start,vector<int>goal,vector<Edge> *E){\n  double ans=1e100;\n  rep(i,start.size()){\n    //ans=min(ans,dijkstra,\n  }\n  if ( ans > 1e100)puts(\"impossible\");\n  else printf(\"%.5lf\\n\",ans);\n}\n\nmain(){\n  int n;\n  Polygon a;\n  a.push_back(complex<double>(0,0));\n  a.push_back(complex<double>(4,0));\n  a.push_back(complex<double>(4,4));\n  a.push_back(complex<double>(0,4));\n  while(cin>>n && n){\n    vector<P> Mons;\n    map<Point,int> M;\n    vector<Edge>    E[500];\n    vector<P> node;\n    rep(i,n){\n      P tmp;\n      cin>>tmp.real()>>tmp.imag();\n      Mons.push_back(tmp);\n    }\n    \n    rep(i,n){\n      solve(i,a,Mons,M,E,node);\n    }\n\n    vector<int> start,goal;\n    n=node.size();\n    rep(i,n){\n      if ( node[i].real()<eps)start.push_back(i);\n      else if ( abs(node[i].real()-4)<eps)goal.push_back(i);\n    }\n    if ( n >200)return true;\n    solve2(n,start,goal,E);\n    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define EPS (1e-8)\n#define INF (1e100)\n#define equals(a, b) (fabs(a - b) < EPS)\n\nstruct Point {\n    double x, y;\n\n    Point () {}\n    Point (double x, double y) : x(x), y(y) {}\n\n    Point operator + (const Point &p) const {\n        return Point(x + p.x, y + p.y);\n    }\n    \n    Point operator - (const Point &p) const {\n        return Point(x - p.x, y - p.y);\n    }\n    \n    Point operator * (const double &k) const {\n        return Point(x * k, y * k);\n    }\n\n    bool operator == (const Point &p) const {\n        return (x == p.x && y == p.y);\n    }\n    \n    bool operator < (const Point &p) const {\n        if (x != p.x) {\n            return x < p.x;\n        } else {\n            return y < p.y;\n        }\n    }\n};\n\ndouble dot(const Point &a, const Point &b)\n{\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(const Point &a, const Point &b)\n{\n    return a.x * b.y - b.x * a.y;\n}\n\ndouble norm(const Point &p)\n{\n    return dot(p, p);\n}\n\ndouble abs(const Point &p)\n{\n    return sqrt(norm(p));\n}\n\ndouble dist(const Point &a, const Point &b)\n{\n    return sqrt(pow(a.x - b.x, 2) + pow(a.y - b.y, 2));\n}\n\n#define COUNTER_CLOCKWISE +1\n#define CLOCKWISE         -1\n#define ONLINE_BACK       +2\n#define ONLINE_FRONT      -2\n#define ON_SEGMENT        +0\ntypedef Point Vector;\n\nint ccw(const Point &p0, const Point &p1, const Point &p2)\n{\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if (cross(a, b) > EPS)  return COUNTER_CLOCKWISE;\n    if (cross(a, b) < -EPS) return CLOCKWISE;\n    if (dot(a, b) < -EPS)   return ONLINE_BACK;\n    if (norm(a) < norm(b))  return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nstruct Segment {\n    Point s, t;\n    Segment(){}\n    Segment(Point s, Point t) : s(s), t(t) {}\n};\n\ntypedef Segment Line;\n\nLine perpendicular_bisector(const Point &a, const Point &b)\n{\n    double cx = (a.x + b.x) / 2.0;\n    double cy = (a.y + b.y) / 2.0;\n    Point p = Point(cx + (a.y - b.y), cy + (b.x - a.x));\n    return Line(Point(cx, cy), p);\n}\n\nPoint crosspointLL(const Line &a, const Line &b)\n{\n    Vector va = a.t - a.s, vb = b.t - b.s;\n    double d = cross(vb, va);\n    if (abs(d) < EPS) return b.s;\n    return a.s + va * cross(vb, b.t - a.s) * (1.0 / d);\n}\n\n#define curr(G, i) (G[i % G.size()])\n#define next(G, i) (G[(i + 1) % G.size()])\ntypedef vector<Point> Polygon;\n\nPolygon convex_cut(const Polygon &pg, const Line &l)\n{\n    Polygon res;\n    for (int i = 0; i < (int)pg.size(); i++) {\n        Point cp = curr(pg, i), np = next(pg, i);\n        if (ccw(l.s, l.t, cp) != -1) res.push_back(cp);\n        if (ccw(l.s, l.t, cp) * ccw(l.s, l.t, np) < 0) {\n            res.push_back(crosspointLL(Line(cp, np), l));\n        }\n    }\n    return res;\n}\n\nbool check(Point a, Point b)\n{\n    if (a.x > b.x) swap(a, b);\n    if (a.x == b.x && a.y > b.y) swap(a, b);\n    if (a == Point(0, 0) && b == Point(0, 4)) return 1;\n    if (a == Point(0, 0) && b == Point(4, 0)) return 1;\n    if (a == Point(0, 4) && b == Point(4, 4)) return 1;\n    if (a == Point(4, 0) && b == Point(4, 4)) return 1;\n    return 0;\n}\n\nvector<Segment> make_segments(vector<Point> &ps)\n{\n    Polygon pg(4);\n    pg[0] = Point(0, 0);\n    pg[1] = Point(0, 4);\n    pg[2] = Point(4, 4);\n    pg[3] = Point(4, 0);\n\n    vector<Segment> segs;\n    \n    int N = ps.size();\n    for (int i = 0; i < N; i++) {\n        Polygon p = pg;\n        for (int j = 0; j < N; j++) {\n            if (i == j) continue;\n            p = convex_cut(p, perpendicular_bisector(ps[i], ps[j]));\n        }\n        int M = p.size();\n        for (int j = 0; j < M; j++) {\n            if (check(curr(p, j), next(p, j))) continue;            \n            segs.push_back(Segment(curr(p, j), next(p, j)));\n        }\n    }\n    return segs;\n}\n\nstruct Edge {\n    int to;\n    double cost;\n    Edge (int to, double cost) : to(to), cost(cost) {}\n    bool operator < (const Edge &e) const {\n        return cost < e.cost;\n    }\n};\n\ntypedef vector<vector<Edge>> Graph;\n\nbool isIntersectSS(const Segment &a, const Segment &b)\n{\n    Point s[2] = {a.s, a.t}, t[2] = {b.s, b.t};\n    return (ccw(s[0], s[1], t[0]) * ccw(s[0], s[1], t[1]) <= 0 &&\n\t    ccw(t[0], t[1], s[0]) * ccw(t[0], t[1], s[1]) <= 0);\n}\n\nbool isIntersectSP(const Segment &s, const Point &p)\n{\n    return (ccw(s.s, s.t, p) == 0);\n}\n\nPoint crosspointSS(const Segment &a, const Segment &b)\n{\n    Vector va = a.t - a.s, vb = b.t - b.s;\n    double d = cross(vb, va);\n    return a.s + va * cross(vb, b.t - a.s) * (1.0 / d);\n}\n\nGraph segment_arrangement(vector<Segment> &segs, vector<Point> &ps)\n{\n    Graph G;\n    int N = segs.size();\n    ps.clear();\n\n    for (int i = 0; i < N; i++) {\n\tps.push_back(segs[i].s);\n\tps.push_back(segs[i].t);\n\tfor (int j = i+1; j < N; j++) {\n\t    Vector a = segs[i].t - segs[i].s;\n\t    Vector b = segs[j].t - segs[j].s;\n\t    if (equals(cross(a, b), 0)) continue;            \n\t    if (isIntersectSS(segs[i], segs[j])) {\n\t\tps.push_back(crosspointSS(segs[i], segs[j]));\n\t    }\n\t}\n    }\n    sort(ps.begin(), ps.end());\n    ps.erase(unique(ps.begin(), ps.end()), ps.end());\n\n    int N2 = ps.size();\n    G.resize(N2);\n    for (int i = 0; i < N; i++) {\n\tvector<pair<double,int>> vec;\n\tfor (int j = 0; j < N2; j++) {\n\t    if (isIntersectSP(segs[i], ps[j])) {\n\t\tdouble d = dist(segs[i].s, ps[j]);\n\t\tvec.push_back(make_pair(d, j));\n\t    }\n\t}\n\tsort(vec.begin(), vec.end());\n\tfor (int j = 0; j < (int)vec.size()-1; j++) {\n\t    int u = vec[j].second, v = vec[j+1].second;\n\t    double d = dist(ps[u], ps[v]);\n\t    G[u].push_back(Edge(v, d));\n\t    G[v].push_back(Edge(u, d));\n\t}\n    }\n    return G;\n}\n\ndouble solve(vector<Point> &ps)\n{\n    vector<Segment> v = make_segments(ps);\n    vector<Point> p;\n    Graph G = segment_arrangement(v, p);\n\n    int N = p.size();    \n    vector<vector<double>> d(N, vector<double>(N, INF));\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < (int)G[i].size(); j++) {\n            d[i][G[i][j].to] = G[i][j].cost;\n        }\n        d[i][i] = 0;\n    }\n\n    for (int k = 0; k < N; k++) {\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n            }\n        }\n    }\n\n    double res = INF;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (!check(p[i], p[j]) && equals(p[i].x, 0) && equals(p[j].x, 4)) {\n                res = min(res, d[i][j]);\n            }\n        }\n    }    \n    return res;\n}\n\nint main()\n{\n    int n;\n    while (cin >> n, n) {\n        vector<Point> ps(n);\n        for (int i = 0; i < n; i++) {\n            cin >> ps[i].x >> ps[i].y;\n        }\n        double res = solve(ps);\n        if (n == 1 || res == INF) {\n            puts(\"impossible\");\n        } else {\n            printf(\"%.15f\\n\", res);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<vector>\n#include<iostream>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<cmath>\n#include<cassert>\n\n#define START_X 0.0\n#define GOAL_X 4.0\n\n#define FRONT 0x01\n#define RIGHT 0x02\n#define BACK 0x04\n#define LEFT 0x08\n#define OVER 0x10\n\n#define sc second\n#define fr first\n\n#define REP(i,n) for(int i = 0; i < (int)(n); ++i)\n\nusing namespace std;\n\ntypedef double elem;\ntypedef complex<elem> point, vec;\ntypedef pair<point, point> line, hline, seg, pp;\n\nconst double eps = 1.0e-5;\nconst double pi = acos(-1.0);\nconst double infty = 1e40;\npoint base(0,0),origin(0,0);\n\nbool eq(elem a, elem b){ return abs(a-b) < eps; }\nbool lt(elem a, elem b){ return !eq(a,b) && a < b; }\nbool leq(elem a, elem b){ return eq(a,b) || a < b; }\nbool gt(elem a, elem b){ return !eq(a,b) && a > b; }\nbool geq(elem a, elem b){ return eq(a,b) || a > b; }\nbool ltz(elem a){ return lt( a, 0 ); }\nbool gtz(elem a){ return gt( a, 0 ); }\nbool eqv(vec a, vec b){ return eq( abs(b-a),0); }\nbool is_zv(vec v){ return eq(abs(v),0); }\nelem emax(elem a, elem b){ return gt(a,b)?a:b; }\nelem emin(elem a, elem b){ return lt(a,b)?a:b; }\n\nbool far(point a, point b){ return gtz( abs(b-a) ); }\nbool near(point a, point b){ return leq( abs(b-a), 0 ); }\nelem dot(vec a, vec b){ return (a.real() * b.real() + a.imag() * b.imag() ); }\nelem cross(vec a, vec b){ return ( a.real() * b.imag() - a.imag() * b.real() ); }\n\nelem dist(point a, point b){ return abs(a-b); }\nelem dist_l(line l, point x){ return abs(cross(l.sc-l.fr,x-l.fr)) / abs(l.sc-l.fr); }\nelem dist_seg(seg s, point x)\n{\n  if( ltz( dot(s.sc-s.fr,x-s.fr) ) ) return abs(x-s.fr);\n  if( ltz( dot(s.fr-s.sc,x-s.sc) ) ) return abs(x-s.sc);\n  return dist_l(s,x);\n}\n\nvec uvec(vec a){ return a / abs(a); }\nvec nmr(vec a){ return a * vec(0,-1); }\nvec nml(vec a){ return a * vec(0,1); }\nvec unmr(vec a){ return uvec( nmr(a) ); }\nvec unml(vec a){ return uvec( nml(a) ); }\n\nbool orth(point a1, point a2, point b1, point b2){ return eq( dot( a2 - a1, b2 - b1 ), 0 ); }\nbool orth(vec v1, vec v2){ return eq( dot(v1, v2), 0 ); }\nbool prll(point a1, point a2, point b1, point b2){ return eq( cross( a2 - a1, b2 - b1 ), 0 ); }\nbool prll(vec v1, vec v2){ return eq( cross(v1, v2), 0 ); }\n\nint ccw(point a, point b, point x){\n  b -= a;\n  x -= a;\n  if( gtz( cross(b,x) ) ) return LEFT;\n  if( ltz( cross(b,x) ) ) return RIGHT;\n  if( ltz( dot(b,x) ) ) return BACK;\n  if( lt( abs(b), abs(x) ) ) return FRONT;\n  return OVER;\n}\n\nbool intersectedSS(seg a, seg b)\n{\n  if( ccw(a.fr,a.sc,b.fr)&OVER || ccw(a.fr,a.sc,b.sc)&OVER ) return true;\n  return\n    ( ccw(a.fr,a.sc,b.fr) | ccw(a.fr,a.sc,b.sc) ) == (LEFT|RIGHT) &&\n    ( ccw(b.fr,b.sc,a.fr) | ccw(b.fr,b.sc,a.sc) ) == (LEFT|RIGHT) ;\n}\n\nbool intersectedLL(line a, line b){ return !eq( cross(a.sc-a.fr,b.sc-b.fr), 0.0 ); }\n\npoint intersectionSS(seg a, seg b)\n{\n  elem d1 = dist_l(b,a.fr);\n  elem d2 = dist_l(b,a.sc);\n  return a.fr + ( d1 / (d1 + d2 ) ) * (a.sc-a.fr);\n}\npoint intersectionLL(line a, line b)\n{\n  vec va = a.sc - a.fr;\n  vec vb = b.sc - b.fr;\n  return a.fr + va * ( cross(vb, b.fr - a.fr) / cross(vb,va) );\n}\n\nbool intersectionLL(line a, line b, point &ret){\n  return intersectedLL( a, b ) ? ret = intersectionLL( a, b ), true : false;\n}\nbool intersectionLH(line a, hline b, point &ret){\n  point tmp;\n  return intersectionLL(a,b,tmp) ? ( ccw(b.fr,b.sc,tmp)&(OVER|FRONT) ? ret=tmp, true : false ) : false;\n}\nbool intersectionLS(line l, seg s, point &ret){\n  point tmp;\n  return intersectionLL(l,s,tmp) ? ( ccw(s.fr,s.sc,tmp)&OVER ? ret=tmp, true : false ) : false;\n}\nbool intersectionHH(hline a, hline b, point &ret){\n  point tmp;\n  return intersectionLL(a,b,tmp) ? ( ccw(a.fr,a.sc,tmp)&(OVER|FRONT)&&ccw(b.fr,b.sc,tmp)&(OVER|FRONT) ? ret = tmp, true : false ) : false;\n}\nbool intersectionHS(hline a, seg s, point &ret){\n  point tmp;\n  return intersectionLS(a,s,tmp) ? ( ccw(a.fr,a.sc,tmp)&(OVER|FRONT) ? ret = tmp, true : false ) : false;\n}\nbool intersectionSS(seg a, seg b, point &ret){\n  return intersectedSS(a,b) ? ret = intersectionSS(a,b), true : false;\n}\n\nbool convexCut(const vector<point> &vp,\n\t       line l,\n\t       vector<point> &left)\n{\n  int n = vp.size();\n  bool bFirst = true;\n  int indq1 = -1, indq2 = -1;\n  point q1, q2;\n  \n  for(int i = 0; i < n; ++i){\n    seg edge = make_pair( vp[i], vp[(i+1)%n] );\n    if( bFirst ){\n      if( intersectionLS( l, edge, q1 ) ){ bFirst = false; indq1 = (i+1)%n; }\n    }else{\n      if( intersectionLS( l, edge, q2 ) && far(q1,q2) ){ indq2 = (i+1)%n; break; }\n    }\n  }\n\n  if( indq1<0||indq2<0 ) return false;\n  if( lt( dist( q1, l.second ), dist( q2, l.second ) ) ){ swap( q1, q2 ); swap( indq1, indq2 ); }\n  if( far( q2, vp[indq2] ) ) left.push_back( q2 );\n  for(int i = indq2; i != indq1; i=(i+1>=n?0:i+1)) left.push_back( vp[i] );\n  if( far(q1, vp[(indq1-1+n)%n] ) ) left.push_back( q1 );\n\n  return true;\n}\n\nstruct Point{\n  point p;\n  Point():p(origin){}\n  Point(point p):p(p){}\n  bool operator < (const Point &t)const{\n    if(!eq(p.real(),t.p.real()))return lt(p.real(),t.p.real());\n    else return lt(p.imag(),t.p.imag());\n  }\n};\n\nstruct Node{\n  point p;\n  vector<int> con;\n  vector<double> cost;\n};\n\ntypedef vector<Node> Graph;\n\nline expandLine(line l, elem mag){\n  line ret = l;\n  vec vf(l.first - l.second);\n  vec vs(l.second - l.first);\n  ret.first = l.second + mag * vf;\n  ret.second = l.first + mag * vs;\n  return ret;\n}\n\nvoid MakeVolonoi(const vector<point> &vp,\n\t\t const vector<point> &plane,\n\t\t vector< vector<point> > &out){\n  vector<point> tplane;\n  \n  for(int i = 0; i < vp.size(); ++i){\n    tplane = plane;\n    for(int j = 0; j < vp.size(); ++j){\n      if( i != j ){\n\tvector<point> newplane;\n\tpoint c = (vp[i]+vp[j])/2.;\n\tint cw = ccw( c, unmr(vp[i]-vp[j])+c, vp[i] );\n\tassert(cw==LEFT||cw==RIGHT);\n\tline bisec;\n\tif( cw == LEFT ){\n\t  bisec = line( c, unmr( vp[i]-vp[j] ) + c );\n\t}else{\n\t  bisec = line( c, unml( vp[i]-vp[j] ) + c );\n\t}\n\tbisec = expandLine( bisec, 100.0 ); // magnify segment for convex cut\n\t//cout << abs(bisec.second-bisec.first) << endl;\n\tif( convexCut(tplane, bisec, newplane ) )\n\t  tplane = newplane;\n      }\n    }\n    out.push_back( tplane );\n  }\n};\n\nstruct State{\n  int now;\n  elem cost;\n  State(){}\n  bool operator<(const State &t)const{\n    return lt(cost,t.cost);\n  }\n};\n\nelem dijkstra(Graph &G, int sid){\n  elem ret = infty;\n  priority_queue<State> qs;\n  State init;\n  bool vis[G.size()];\n  elem A[G.size()];\n  for(int i = 0; i < G.size(); ++i){\n    vis[i]=false;\n    A[i]=infty;\n  }\n  init.now = sid;\n  init.cost = 0.0;\n  qs.push(init);\n  A[sid]=0.0;\n  while(!qs.empty()){\n    State st_now = qs.top(); qs.pop();\n    int nid = st_now.now;\n    if(vis[nid])continue;\n    else vis[nid]=true;\n    for(int i = 0; i < G[nid].con.size(); ++i){\n      State next;\n      next.now = G[nid].con[i];\n      //cout << next.now << endl;\n      next.cost = st_now.cost + G[nid].cost[i];\n      if( lt(next.cost, A[next.now]) ){\n\tA[next.now] = next.cost;\n\tif( !vis[next.now] ){\n\t  qs.push( next );\n\t}\n      }\n    }\n  }\n  for(int i = 0; i < G.size(); ++i){\n    if( eq(G[i].p.real(),GOAL_X) ){\n      ret = emin( ret, A[i] );\n    }\n  }\n  return ret;\n}\n\nint main()\n{\n  while(true){\n    int n;\n    elem ans=infty;\n    map<Point,int> point_id;\n    vector<point> vp,plane;\n    vector< vector<point> > volonoi;\n\n    cin >> n;\n    if( n == 0 ) break;\n    for(int i = 0; i < n; ++i){\n      elem x,y;\n      cin >> x >> y;\n      vp.push_back( point(x,y) );\n    }\n    if( n == 1 ){\n      puts(\"impossible\");\n      continue;\n    }\n    plane.push_back( point(0.0,0.0) );\n    plane.push_back( point(4.0,0.0) );\n    plane.push_back( point(4.0,4.0) );\n    plane.push_back( point(0.0,4.0) );\n    MakeVolonoi( vp, plane, volonoi );\n\n    /* debug \n    for(int i = 0; i < volonoi.size(); ++i){\n      cout << \"//\" << i << \" master point : \" << vp[i] << endl;\n      for(int j = 0; j < volonoi[i].size(); ++j){\n\tpoint lf=volonoi[i][j];\n\tpoint ls=volonoi[i][(j+1)%volonoi[i].size()];\n\n\tcout << \"line(\" << lf.real() <<\",\" << lf.imag() <<\",\" << ls.real() <<\",\"<<ls.imag() << \");\" << endl;\n      }\n    }\n    cout << endl;\n    */\n\n    int now = 0;\n    for(int i = 0; i < volonoi.size(); ++i){\n      for(int j = 0; j < volonoi[i].size(); ++j){\n\tPoint pp(volonoi[i][j]);\n\tif( point_id.find( pp ) == point_id.end() ){\n\t  point_id[pp] = now;\n\t  ++now;\n\t}\n      }\n    }\n    Graph G(now);\n\n    // Graph Construction\n    for(int i = 0; i < volonoi.size(); ++i){\n      int ni = volonoi[i].size();\n      for(int j = 0; j < ni; ++j){\n\tpoint p = volonoi[i][j];\n\tpoint np = volonoi[i][(j+1)%ni];\n\t\n\tif( eq(p.real(),np.real())&&eq(p.real(),0.0) ||\n\t    eq(p.real(),np.real())&&eq(p.real(),4.0) ||\n\t    eq(p.imag(),np.imag())&&eq(p.imag(),0.0) ||\n\t    eq(p.imag(),np.imag())&&eq(p.imag(),4.0) )continue;\n\tint ip = point_id[Point(p)];\n\tint inp = point_id[Point(np)];\n\telem d = dist( p, np );\n\tG[ ip ].p = p;\n\tG[ inp ].p = np;\n\tG[ ip ].con.push_back( inp );\n\tG[ ip ].cost.push_back( d );\n\tG[ inp ].con.push_back( ip );\n\tG[ inp ].cost.push_back( d );\n      }\n    }\n\n    for(int i = 0; i < G.size(); ++i){\n      if( eq( G[i].p.real(), START_X ) ){\n\tans = emin( ans, dijkstra( G, i ) );\n      }\n    }\n\n    if(geq(ans,infty))puts(\"impossible\");\n    else printf(\"%.12lf\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cfloat>\n#include<cmath>\n#include<vector>\n#include<queue>\n\nusing namespace std;\n\n#define EPS (1e-10)\n#define equals(a, b) (fabs((a) - (b)) < EPS )\n#define dle(a, b) (equals(a, b) || a < b )\nstatic const double PI = acos(-1);\n\nclass Point{\n    public:\n    double x, y;\n    \n    Point ( double x = 0, double y = 0): x(x), y(y){}\n    \n    Point operator + ( Point p ){ return Point(x + p.x, y + p.y); }\n    Point operator - ( Point p ){ return Point(x - p.x, y - p.y); }\n    Point operator * ( double a ){ return Point(x*a, y*a); }\n    Point operator / ( double a ){ return Point(x/a, y/a); }\n\n    double abs() { return sqrt(norm());}\n    double norm() { return x*x + y*y; }\n\n    bool operator < ( const Point &p ) const {\n\treturn x != p.x ? x < p.x : y < p.y;\n    }\n\n    bool operator == ( const Point &p ) const {\n\treturn fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n    }\n};\n\ntypedef Point Vector;\n\nclass Segment{\n    public:\n    Point p1, p2;\n    Segment(Point s = Point(), Point t = Point()): p1(s), p2(t){}\n};\n\ntypedef Segment Line;\n\ntypedef vector<Point> Polygon;\n\ndouble norm( Vector a ){ return a.x*a.x + a.y*a.y; }\ndouble abs( Vector a ){ return sqrt(norm(a)); }\nPoint polar( double a, double r ){ return Point(cos(r)*a, sin(r)*a);}\ndouble getDistance( Vector a, Vector b ){ return abs(a - b); }\ndouble dot( Vector a, Vector b ){ return a.x*b.x + a.y*b.y; }\ndouble cross( Vector a, Vector b ){ return a.x*b.y - a.y*b.x; }\n\ndouble arg(Vector p){\n    return atan2(p.y, p.x);\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\n\nint ccw( Point p0, Point p1, Point p2 ){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if ( cross(a, b) > EPS ) return COUNTER_CLOCKWISE;\n    if ( cross(a, b) < -EPS ) return CLOCKWISE;\n    if ( dot(a, b) < -EPS ) return ONLINE_BACK;\n    if ( norm(a) < norm(b) ) return ONLINE_FRONT;\n    return ON_SEGMENT;\n}\n\nPoint getCrossPointLines( Line s1, Line s2){\n    Vector a = s1.p2 - s1.p1;\n    Vector base = s2.p2 - s2.p1;\n    return s1.p1 + a * cross(base, s2.p1 - s1.p1)/cross(base, a);\n}\n\nPolygon cutPolygon( Polygon P, Line l ){\n    Polygon u;\n    for ( int i = 0; i < P.size(); i++ ){\n\tPoint a = P[i], b = P[(i+1)%P.size()];\n\tif ( ccw(l.p1, l.p2, a) != CLOCKWISE ) u.push_back(a);\n\tif ( ccw(l.p1, l.p2, a) * ccw(l.p1, l.p2, b) == -1 ){\n\t    u.push_back(getCrossPointLines(Segment(a, b), l));\n\t}\n    }\n    return u;\n}\n\nclass Edge{\n    public:\n    int target;\n    double cost;\n    Edge( int t=0, double c=0):target(t), cost(c){}\n};\n\nclass Node{\n    public:\n    Point pos;\n    vector<Edge> adjList;\n    Node(){}\n    Node(Point p):pos(p){}\n};\n\nclass State{\n    public:\n    int pos;\n    double cost;\n    State(int p=0, double c=0): pos(p), cost(c){}\n    bool operator < ( const State &s ) const{\n\treturn cost > s.cost;\n    }\n};\n\n#define X_MAX 4.0\n#define Y_MAX 4.0\n#define X_MIN 0.0\n#define Y_MIN 0.0\n#define MMAX 100\n\nPoint M[MMAX];\nint nmon;\nconst double INFTY = 10000.0;\n\nvector<Node> G; // graph;\n\nLine getCutLine( Point p1, Point p2 ){\n    Vector v = p2 - p1;\n    v = polar(abs(v), arg(v)+PI/2.0);\n    double dx = (p2.x + p1.x)/2.0;\n    double dy = (p2.y + p1.y)/2.0;\n    return Line(Point(dx, dy), Point(v.x+dx, v.y+dy));\n}\n\nvoid print(Polygon P){\n    cout << \"print polygon\" << endl;\n    for ( int i = 0; i < P.size(); i++ ){\n\tcout << P[i].x << \",\" << P[i].y << endl;\n    }\n}\n\nbool isRoad( Segment s ){\n    if ( equals(s.p1.x, s.p2.x) ){\n\tif ( equals(s.p1.x, X_MIN) || equals(s.p1.x, X_MAX) ) return false;\n    }\n    if ( equals(s.p1.y, s.p2.y) ){\n\tif ( equals(s.p1.y, Y_MIN) || equals(s.p1.y, Y_MAX) ) return false;\n    }\n    return true;\n}\n\nvector<Polygon> getVoronoi( Point PV[MMAX], int n){\n    vector<Polygon> V;\n    for ( int i = 0; i < n; i++ ){\n\tPolygon P;\n\tP.push_back(Point(X_MIN, Y_MIN));\n\tP.push_back(Point(X_MAX, Y_MIN));\n\tP.push_back(Point(X_MAX, Y_MAX));\n\tP.push_back(Point(X_MIN, Y_MAX));\n\tfor ( int j = 0; j < n; j++ ){\n\t    if ( i == j ) continue;\n\t    P = cutPolygon(P, getCutLine(PV[i], PV[j]));\n\t}\n\tV.push_back(P);\n    }\n    return V;\n}\n\ndouble dijkstra(){\n    priority_queue<State> PQ;\n    vector<double> D;\n    vector<int> P;\n    D.resize(G.size());\n    P.resize(G.size());\n    for ( int i = 0; i < D.size(); i++ ) D[i] = INFTY;\n\n    for ( int i = 0; i < G.size(); i++ ){\n\tif ( equals(G[i].pos.x, X_MIN) ){\n\t    PQ.push(State(i, 0.0));\n\t    D[i] = 0.0;\n\t    P[i] = -1;\n\t}\n    }\n    State u, v;\n    while( !PQ.empty() ){\n\tu = PQ.top(); PQ.pop();\n\tif ( equals(G[u.pos].pos.x, X_MAX) ) {\n\t  int cur = u.pos;\n\t  while( cur != -1 ) cur = P[cur];\n\t  return D[u.pos];\n\t}\n\n\tfor ( int i = 0; i < G[u.pos].adjList.size(); i++ ){\n\t    int t = G[u.pos].adjList[i].target;\n\t    double d = G[u.pos].adjList[i].cost;\n\t    if ( D[u.pos] + d < D[t] ){\n\t\tD[t] = D[u.pos] + d;\n\t\tP[t] = u.pos;\n\t\tPQ.push(State(t, D[t]));\n\t    }\n\t}\n    }\n    \n    return INFTY;\n}\n\nvoid compute(){\n    vector<Segment> S;\n\n    vector<Polygon> V = getVoronoi(M, nmon);\n    for ( int i = 0; i < V.size(); i++ ){\n\tPolygon P = V[i];\n\tfor ( int j = 0; j < P.size(); j++ ){\n\t    Segment s = Segment(P[j], P[(j+1)%P.size()]);\n\t    if ( isRoad(s) ) S.push_back(s);\n\t}\n    }\n    G.clear();\n    for( int i = 0; i < S.size(); i++ ){\n\tSegment s = S[i];\n\tdouble d = abs(s.p2 - s.p1);\n\tNode n1 = Node(s.p1);\n\tn1.adjList.push_back(Edge(G.size()+1,d));\n\tNode n2 = Node(s.p2);\n\tn2.adjList.push_back(Edge(G.size(),d));\n\tG.push_back(n1);\n\tG.push_back(n2);\n    }\n    for ( int i = 0; i < G.size()-1; i++ ){\n\tfor ( int j = i+1; j < G.size(); j++ ){\n\t    if ( G[i].pos == G[j].pos ){\n\t\tG[i].adjList.push_back(Edge(j, 0.0));\n\t\tG[j].adjList.push_back(Edge(i, 0.0));\n\t    }\n\t}\n    }\n    double cost = dijkstra();\n    if ( equals( cost, INFTY ) ) cout << \"impossible\" << endl;\n    else printf(\"%.5lf\\n\", cost);\n\n}\n\nint main(){\n    double x, y;\n    while ( cin >> nmon ){\n\tif ( nmon == 0 ) break;\n\tfor ( int i = 0; i < nmon; i++ ){\n\t    cin >> x >> y;\n\t    M[i] = Point(x, y);\n\t}\n\tcompute();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(arg),key)-begin(arg)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n\nusing namespace std;\n\ntemplate<class T>void reg(vector<T> &ary,const T &elem){ary.emplace_back(elem);}\ntemplate<class T>bool chmin(T &a, const T &b) {return (b<a)?(a=b,1):0;}\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\n\nusing R=long double; // __float128\nconst R EPS = 1E-9; // [-1000:1000]->EPS=1e-8 [-10000:10000]->EPS=1e-7\nconst R INF = 1E40;\nconstexpr R PI = acos(R(-1));\ninline int sgn(const R& r){ return (r > EPS) - (r < -EPS);}\ninline int sgn(const R& a, const R &b){ return sgn(a-b); }\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n\nusing P=complex<R>;\nusing VP=vector<P>;\nusing L=struct{P s,t;};\nusing VL=vector<L>;\nusing C=struct{P c;R r;};\nusing VC=vector<C>;\n\nconstexpr P O = P(0,0);\nistream& operator >> (istream& is,P& p){ R x,y;is >> x >> y; p=P(x,y); return is;}\nostream& operator << (ostream& os,P& p){ os << real(p) << \" \" << imag(p); return os;}\n\nnamespace std{\n\tbool operator <  (const P& a,const P& b){ return sgn(real(a-b))?real(a-b)<0:sgn(imag(a-b))<0;}\n\tbool operator == (const P& a,const P& b){ return sgn(real(a-b))==0 && sgn(imag(a-b))==0;}\n}\n\nbool operator <  (const L& a,const L& b){ return a.s==b.s?a.t<b.t:a.s<b.s;}\nbool operator == (const L& a,const L& b){ return a.s==b.s&&a.t==b.t;}\n\n//?????? dot ?????? det\ninline R dot(P o,P a,P b){a-=o,b-=o; return real(conj(a)*b);}\ninline R det(P o,P a,P b){a-=o,b-=o; return imag(conj(a)*b);}\n\n// CCW verify AOJ CGL_1_C\nenum CCW{ LEFT = 1,RIGHT = 2,BACK = 4,FRONT = 8,ON = 16};\ninline int ccw(P o,P a, P b) {//???a??¨???b???????????????????????????\n\tif (sgn(det(o,a,b)) > 0) return LEFT;    // counter clockwise\n\tif (sgn(det(o,a,b)) < 0) return RIGHT;   // clockwise\n\tif (sgn(dot(o,a,b)) < 0) return BACK;    // b--base--a on line\n\tif (sgn(norm(a-o)-norm(b-o)) < 0) return FRONT;   // base--a--b on line\n\treturn ON;// base--b--a on line  a??¨b????????????????????????\n}\n\n// ?????´ ?????? verify AOJ CGL_2_A\nbool vertical(L a, L b) {return sgn(dot(O,a.t-a.s,b.t-b.s))==0;}\nbool parallel(L a, L b) {return sgn(det(O,a.t-a.s,b.t-b.s))==0;}\nbool eql(L a,L b){ return (parallel(a,b) && sgn(det(a.s,a.t,b.s))==0);}\n\n\n// ???????????????verify AOJ CGL_2_B ???????????????????????´??????1,????????´??????0\nbool iss(L a,L b,int end=0){\n\tint s1=ccw(a.s,a.t,b.s)|ccw(a.s,a.t,b.t);\n\tint s2=ccw(b.s,b.t,a.s)|ccw(b.s,b.t,a.t);\n\tif(end) return (s1&s2)==(LEFT|RIGHT);\n\treturn (s1|s2)&ON || (s1&s2)==(LEFT|RIGHT);\n}\n\n// ?????? verify AOJ CGL_2_C\nP cross(L a,L b){\n\tR s1=det(a.s,b.s,b.t);\n\tR s2=s1+det(a.t,b.t,b.s);\n\treturn a.s+s1/s2*(a.t-a.s);\n}\n\t\n// ???????????? verify AOJ CGL_4_C\nVP convex_cut(const VP& pol,const L& l) {\n\tVP res;\n\tint n=pol.size();\n\trep(i,n){\n\t\tP a = pol[i],b=pol[(i+1)%n];\n\t\tif(ccw(l.s,l.t,a)!=RIGHT) reg(res,a);\n\t\tif((ccw(l.s,l.t,a)|ccw(l.s,l.t,b))==(LEFT|RIGHT)) reg(res,cross({a,b},l));\n\t}\n\treturn res;\n}\n\nconst int vmax=5010;\nstruct node{int to;R cost;};\nvector<node> graph[vmax];\ninline void add_edge(int f,int t,R c){reg(graph[f],{t,c}),reg(graph[t],{f,c});}\n\nvoid segment_arrangement(const vector<L> &seg, vector<P> &point){\n\trep(i,vmax) graph[i].clear();\n\trep(i,seg.size()){\n\t\treg(point,seg[i].s),reg(point,seg[i].t);\n\t\trep(j,i) if(iss(seg[i],seg[j])) reg(point,cross(seg[i],seg[j]));\n\t}\n\tuniq(point);\n\trep(i,seg.size()){\n\t\tvector<pair<R,int>> idx;\n\t\trep(j,point.size()) if(ccw(seg[i].s,seg[i].t,point[j])==ON) reg(idx,{norm(point[j]-seg[i].s),j});\n\t\tsort(_all(idx));\n\t\trep(j,1,int(idx.size())){\n\t\t\tint a=idx[j-1].second,b=idx[j].second;\n\t\t\tadd_edge(a,b,abs(point[a]-point[b]));\n\t\t}\n\t}\n}\n\nL bisector(P a, P b){P mid=(a+b)/P(2,0);return L{mid, mid+(b-a)*P(0,1)};}\nVP voronoi_cell(VP pol,VP v,int s){rep(i,v.size())if(i!=s)pol=convex_cut(pol,bisector(v[s],v[i]));return pol;}\n\nR dist[vmax];\nR dijkstra(const VP &point){\n\tfill(dist,dist+vmax,INF);\n\tusing state=tuple<R,int>;\n\tpriority_queue<state,vector<state>,greater<state>> q;\n\trep(s,point.size()) if(sgn(real(point[s]))==0) dist[s]=0,q.push(state(0,s));\n\twhile(!q.empty()){\n\t\tR c;int v;\n\t\ttie(c,v)=q.top();q.pop();\n\t\tfor(auto &e:graph[v]){\n\t\t\tR nc=c+e.cost; int nv=e.to;\n\t\t\tif(chmin(dist[nv],nc)) q.push(state(nc,nv));\n\t\t}\n\t}\n\tR res=INF;\n\trep(t,point.size()) if(sgn(real(point[t])-4.0)==0) chmin(res,dist[t]);\n\treturn res;\n}\n\n\nint main(void){\n\tint n;\n\twhile(cin >> n,n){\n\t\tVP pol={P(0,0),P(4,0),P(4,4),P(0,4)};\n\t\tVP vornoi,point;\n\t\tVL seg;\n\t\trep(i,n){\n\t\t\tP p;\n\t\t\tcin >> p;\n\t\t\treg(vornoi,p);\n\t\t}\n\t\trep(i,n){\n\t\t\tVP res=voronoi_cell(pol,vornoi,i);\n\t\t\tfor(auto &p:res) reg(point,p);\n\t\t\tint m=res.size();\n\t\t\trep(i,m){\n\t\t\t\tL l={res[i],res[(i+1)%m]};\n\t\t\t\tbool ok=true;\n\t\t\t\trep(i,4) if(eql(l,{pol[i],pol[(i+1)%4]})) ok=false;\n\t\t\t\tif(ok) reg(seg,l);\n\t\t\t}\n\t\t}\n\t\tsegment_arrangement(seg,point);\n\t\tR res=dijkstra(point);\n\t\tcout.precision(20);\n\t\tif(res>=INF)\n\t\t\tcout << \"impossible\" << endl;\n\t\telse\n\t\t\tcout << fixed << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(arg),key)-begin(arg)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n\nusing namespace std;\n\ntemplate<class T>void reg(vector<T> &ary,const T &elem){ary.emplace_back(elem);}\ntemplate<class T>bool chmin(T &a, const T &b) {return (b<a)?(a=b,1):0;}\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\n\nusing R=long double; // __float128\nconst R EPS = 1E-11; // [-1000:1000]->EPS=1e-8 [-10000:10000]->EPS=1e-7\nconst R INF = 1E40;\nconstexpr R PI = acos(R(-1));\ninline int sgn(const R& r){ return (r > EPS) - (r < -EPS);}\ninline int sgn(const R& a, const R &b){ return sgn(a-b); }\ninline R sq(R x){return sqrt(max<R>(x,0.0));}\n\nusing P=complex<R>;\nusing VP=vector<P>;\nusing L=struct{P s,t;};\nusing VL=vector<L>;\nusing C=struct{P c;R r;};\nusing VC=vector<C>;\n\nconstexpr P O = P(0,0);\nistream& operator >> (istream& is,P& p){ R x,y;is >> x >> y; p=P(x,y); return is;}\nostream& operator << (ostream& os,P& p){ os << real(p) << \" \" << imag(p); return os;}\n\nnamespace std{\n\tbool operator <  (const P& a,const P& b){ return sgn(real(a-b))?real(a-b)<0:sgn(imag(a-b))<0;}\n\tbool operator == (const P& a,const P& b){ return sgn(real(a-b))==0 && sgn(imag(a-b))==0;}\n}\n\nbool operator <  (const L& a,const L& b){ return a.s==b.s?a.t<b.t:a.s<b.s;}\nbool operator == (const L& a,const L& b){ return a.s==b.s&&a.t==b.t;}\n\n//?????? dot ?????? det\ninline R dot(P o,P a,P b){a-=o,b-=o; return real(conj(a)*b);}\ninline R det(P o,P a,P b){a-=o,b-=o; return imag(conj(a)*b);}\n\n// CCW verify AOJ CGL_1_C\nenum CCW{ LEFT = 1,RIGHT = 2,BACK = 4,FRONT = 8,ON = 16};\ninline int ccw(P o,P a, P b) {//???a??¨???b???????????????????????????\n\tif (sgn(det(o,a,b)) > 0) return LEFT;    // counter clockwise\n\tif (sgn(det(o,a,b)) < 0) return RIGHT;   // clockwise\n\tif (sgn(dot(o,a,b)) < 0) return BACK;    // b--base--a on line\n\tif (sgn(norm(a-o)-norm(b-o)) < 0) return FRONT;   // base--a--b on line\n\treturn ON;// base--b--a on line  a??¨b????????????????????????\n}\n\n// ?????´ ?????? verify AOJ CGL_2_A\nbool vertical(L a, L b) {return sgn(dot(O,a.t-a.s,b.t-b.s))==0;}\nbool parallel(L a, L b) {return sgn(det(O,a.t-a.s,b.t-b.s))==0;}\nbool eql(L a,L b){ return (parallel(a,b) && sgn(det(a.s,a.t,b.s))==0);}\n\n\n// ???????????????verify AOJ CGL_2_B ???????????????????????´??????1,????????´??????0\nbool iss(L a,L b,int end=0){\n\tint s1=ccw(a.s,a.t,b.s)|ccw(a.s,a.t,b.t);\n\tint s2=ccw(b.s,b.t,a.s)|ccw(b.s,b.t,a.t);\n\tif(end) return (s1&s2)==(LEFT|RIGHT);\n\treturn (s1|s2)&ON || (s1&s2)==(LEFT|RIGHT);\n}\n\n// ?????? verify AOJ CGL_2_C\nP cross(L a,L b){\n\tR s1=det(a.s,b.s,b.t);\n\tR s2=s1+det(a.t,b.t,b.s);\n\treturn a.s+s1/s2*(a.t-a.s);\n}\n\t\n// ???????????? verify AOJ CGL_4_C\nVP convex_cut(const VP& pol,const L& l) {\n\tVP res;\n\tint n=pol.size();\n\trep(i,n){\n\t\tP a = pol[i],b=pol[(i+1)%n];\n\t\tif(ccw(l.s,l.t,a)!=RIGHT) reg(res,a);\n\t\tif((ccw(l.s,l.t,a)|ccw(l.s,l.t,b))==(LEFT|RIGHT)) reg(res,cross({a,b},l));\n\t}\n\treturn res;\n}\n\nconst int vmax=5010;\nstruct node{int to;R cost;};\nvector<node> graph[vmax];\ninline void add_edge(int f,int t,R c){reg(graph[f],{t,c}),reg(graph[t],{f,c});}\n\nvoid segment_arrangement(const vector<L> &seg, vector<P> &point){\n\trep(i,vmax) graph[i].clear();\n\trep(i,seg.size()){\n\t\treg(point,seg[i].s),reg(point,seg[i].t);\n\t\trep(j,i) if(iss(seg[i],seg[j])) reg(point,cross(seg[i],seg[j]));\n\t}\n\tuniq(point);\n\trep(i,seg.size()){\n\t\tvector<pair<R,int>> idx;\n\t\trep(j,point.size()) if(ccw(seg[i].s,seg[i].t,point[j])==ON) reg(idx,{norm(point[j]-seg[i].s),j});\n\t\tsort(_all(idx));\n\t\trep(j,1,int(idx.size())){\n\t\t\tint a=idx[j-1].second,b=idx[j].second;\n\t\t\tadd_edge(a,b,abs(point[a]-point[b]));\n\t\t}\n\t}\n}\n\nL bisector(P a, P b){P mid=(a+b)/P(2,0);return L{mid, mid+(b-a)*P(0,1)};}\nVP voronoi_cell(VP pol,VP v,int s){rep(i,v.size())if(i!=s)pol=convex_cut(pol,bisector(v[s],v[i]));return pol;}\n\nR dist[vmax];\nR dijkstra(const VP &point){\n\tfill(dist,dist+vmax,INF);\n\tusing state=tuple<R,int>;\n\tpriority_queue<state,vector<state>,greater<state>> q;\n\trep(s,point.size()) if(sgn(real(point[s]))==0) dist[s]=0,q.push(state(0,s));\n\twhile(!q.empty()){\n\t\tR c;int v;\n\t\ttie(c,v)=q.top();q.pop();\n\t\tfor(auto &e:graph[v]){\n\t\t\tR nc=c+e.cost; int nv=e.to;\n\t\t\tif(chmin(dist[nv],nc)) q.push(state(nc,nv));\n\t\t}\n\t}\n\tR res=INF;\n\trep(t,point.size()) if(sgn(real(point[t])-4.0)==0) chmin(res,dist[t]);\n\treturn res;\n}\n\n\nint main(void){\n\tint n;\n\twhile(cin >> n,n){\n\t\tVP pol={P(0,0),P(4,0),P(4,4),P(0,4)};\n\t\tVP vornoi,point;\n\t\tVL seg;\n\t\trep(i,n){\n\t\t\tP p;\n\t\t\tcin >> p;\n\t\t\treg(vornoi,p);\n\t\t}\n\t\trep(i,n){\n\t\t\tVP res=voronoi_cell(pol,vornoi,i);\n\t\t\tfor(auto &p:res) reg(point,p);\n\t\t\tint m=res.size();\n\t\t\trep(i,m){\n\t\t\t\tL l={res[i],res[(i+1)%m]};\n\t\t\t\tbool ok=true;\n\t\t\t\trep(i,4) if(eql(l,{pol[i],pol[(i+1)%4]})) ok=false;\n\t\t\t\tif(ok) reg(seg,l);\n\t\t\t}\n\t\t}\n\t\tsegment_arrangement(seg,point);\n\t\tR res=dijkstra(point);\n\t\tcout.precision(20);\n\t\tif(res>=INF)\n\t\t\tcout << \"impossible\" << endl;\n\t\telse\n\t\t\tcout << fixed << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <cctype>\n#include <ctime>\n#include <cassert>\n#include <cwchar>\n#include <cstdarg>\n#include <cwctype>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <functional>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <fstream>\nusing namespace std;\n\ntypedef long long int lli;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RREP(i,x) for(int i=(x);i>=0;i--)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n\nint dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n/*\n ½Êô½Ìî{vfD\n  ÀÊð­È­·é½ßÉC¡f^ðp¢Ä_ð\\·D\n  xÀWÍreal(p),yÀWÍimag(p)Ìæ¤É·éD\n  _ÍxNgÆµÄàp¢éD\n  size(p)ÅxNgÌå«³CcrossCdotª»ê¼êàÏCOÏð\\·D\n\n  ¼üE¼¼üEüªÍvfª2ÂÌvector<Point>Å\\í·\n\n  ªê\n   PF_\n   L:¼ü\n   SFüª\n   G:½p`\n   CF~\n*/\n\nconst double EPS=1e-7;\nconst double INF=1e10;\n\n\ntypedef complex<double> Point;\ninline double size(const Point &a){return abs(a);}\ninline double cross(const Point &a,const Point &b){return real(a)*real(b)+imag(a)*imag(b);}\ninline double dot(const Point &a,const Point &b){return real(a)*imag(b)-real(a)*imag(b);}\ninline double atan(const Point &a){return atan2(imag(a),real(a));}\nnamespace std{\n\tbool operator<(const Point &a,const Point &b){return real(a)==real(b)?imag(a)<imag(b):real(a)<real(b);}\n}\nstruct Line:vector<Point>{\n\tLine(double x1=0,double y1=0,double x2=0,double y2=0){\n\t\t(*this).push_back(Point(x1,y1));\n\t\t(*this).push_back(Point(x2,y2));\n\t}\n\tLine(Point a,Point b){\n\t\t(*this).push_back(a);(*this).push_back(b);\n\t}\n\tPoint vector(){\n\t\treturn at(1)-at(0);\n\t}\n};\ninline double size(const Line &a){\n\treturn size(a[1]-a[0]);\n}\nstruct Circle{\n\tCircle(Point center,double radius):c(center),r(radius){};\n\tCircle(double x=0,double y=0,double r=0){(*this)=Circle(Point(x,y),r);}\n\tPoint c;double r;\n};\ntypedef vector<Point> Polygon;\nLine getside(const Polygon& p,int no){\n\treturn Line(p[no],p[no%p.size()]);\n}\n\n/*\n _Ìisûü(ccw)\n  http://www.prefield.com/algorithm/geometry/ccw.htmlæè\n  ^¦çê½O_ a, b, c ð a ¨ b ¨ c ÆiÞÆ«C\n\n    -1 : a ¨ b ÅvûüÉÜêÄ b ¨ c\n    +1 : a ¨ b Å¼vûüÉÜêÄ b ¨ c\n    +2 : a ¨ b Åtðü¢Ä a ðÊèzµÄ b ¨ c\n    -2 : a ¨ b Å»ÌÜÜ b ¨ c\n     0 : a ¨ b Åtðü¢Ä b ¨ c ( Ü½Í b == c )\n\n  Ì¢ÃêÌp^[Å é©ð»è·éD\n*/\n\nint ccw(Point a,Point b,Point c){\n    b-=a;c-=a;\n    if(cross(b, c)>0)return +1;       // counter clockwise\n    if(cross(b, c)<0)return -1;       // clockwise\n    if(dot(b, c)<0)return +2;       // c--a--b on line\n    if(norm(b)<norm(c))return -2;       // a--b--c on line\n    return 0;\n}\n\n\n\n\n//-----\n\nvoid add_point(vector<Point> &pts,const Point n){\n\tFOR(it,pts){\n\t\tif(abs((*it)-n)<EPS)return;\n\t}\n\tpts.push_back(n);\n}\nint main(){\n\tfor(;;){\n\t\tint n;\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\tvector<Point> monster;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tdouble x,y;\n\t\t\tcin>>x>>y;\n\t\t\tadd_point(monster,Point(x,y));\n\t\t}\n\t\tif(n!=(int)monster.size())exit(-1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<vector>\n#include<iostream>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<cmath>\n\n#define START_X 0.0\n#define GOAL_X 4.0\n\n#define FRONT 0x01\n#define RIGHT 0x02\n#define BACK 0x04\n#define LEFT 0x08\n#define OVER 0x10\n\n#define sc second\n#define fr first\n\n#define REP(i,n) for(int i = 0; i < (int)(n); ++i)\n\nusing namespace std;\n\ntypedef double elem;\ntypedef complex<elem> point, vec;\ntypedef pair<point, point> line, hline, seg, pp;\n\nconst double eps = 1.0e-11;\nconst double pi = acos(-1.0);\nconst double infty = 1e40;\npoint base(0,0),origin(0,0);\n\nbool eq(elem a, elem b){ return abs(a-b) < eps; }\nbool lt(elem a, elem b){ return !eq(a,b) && a < b; }\nbool leq(elem a, elem b){ return eq(a,b) || a < b; }\nbool gt(elem a, elem b){ return !eq(a,b) && a > b; }\nbool geq(elem a, elem b){ return eq(a,b) || a > b; }\nbool ltz(elem a){ return lt( a, 0 ); }\nbool gtz(elem a){ return gt( a, 0 ); }\nbool eqv(vec a, vec b){ return eq( abs(b-a),0); }\nbool is_zv(vec v){ return eq(abs(v),0); }\nelem emax(elem a, elem b){ return gt(a,b)?a:b; }\nelem emin(elem a, elem b){ return lt(a,b)?a:b; }\n\nbool far(point a, point b){ return gtz( abs(b-a) ); }\nbool near(point a, point b){ return leq( abs(b-a), 0 ); }\nelem dot(vec a, vec b){ return (a.real() * b.real() + a.imag() * b.imag() ); }\nelem cross(vec a, vec b){ return ( a.real() * b.imag() - a.imag() * b.real() ); }\n\nelem dist(point a, point b){ return abs(a-b); }\nelem dist_l(line l, point x){ return abs(cross(l.sc-l.fr,x-l.fr)) / abs(l.sc-l.fr); }\nelem dist_seg(seg s, point x)\n{\n  if( ltz( dot(s.sc-s.fr,x-s.fr) ) ) return abs(x-s.fr);\n  if( ltz( dot(s.fr-s.sc,x-s.sc) ) ) return abs(x-s.sc);\n  return dist_l(s,x);\n}\n\nvec uvec(vec a){ return a / abs(a); }\nvec nmr(vec a){ return a * vec(0,-1); }\nvec nml(vec a){ return a * vec(0,1); }\nvec unmr(vec a){ return uvec( nmr(a) ); }\nvec unml(vec a){ return uvec( nml(a) ); }\n\nbool orth(point a1, point a2, point b1, point b2){ return eq( dot( a2 - a1, b2 - b1 ), 0 ); }\nbool orth(vec v1, vec v2){ return eq( dot(v1, v2), 0 ); }\nbool prll(point a1, point a2, point b1, point b2){ return eq( cross( a2 - a1, b2 - b1 ), 0 ); }\nbool prll(vec v1, vec v2){ return eq( cross(v1, v2), 0 ); }\n\nint ccw(point a, point b, point x){\n  b -= a;\n  x -= a;\n  if( gtz( cross(b,x) ) ) return LEFT;\n  if( ltz( cross(b,x) ) ) return RIGHT;\n  if( ltz( dot(b,x) ) ) return BACK;\n  if( lt( abs(b), abs(x) ) ) return FRONT;\n  return OVER;\n}\n\nbool intersectedSS(seg a, seg b)\n{\n  if( ccw(a.fr,a.sc,b.fr)&OVER || ccw(a.fr,a.sc,b.sc)&OVER ) return true;\n  return\n    ( ccw(a.fr,a.sc,b.fr) | ccw(a.fr,a.sc,b.sc) ) == (LEFT|RIGHT) &&\n    ( ccw(b.fr,b.sc,a.fr) | ccw(b.fr,b.sc,a.sc) ) == (LEFT|RIGHT) ;\n}\n\nbool intersectedLL(line a, line b){ return !eq( cross(a.sc-a.fr,b.sc-b.fr), 0.0 ); }\n\npoint intersectionSS(seg a, seg b)\n{\n  elem d1 = dist_l(b,a.fr);\n  elem d2 = dist_l(b,a.sc);\n  return a.fr + ( d1 / (d1 + d2 ) ) * (a.sc-a.fr);\n}\npoint intersectionLL(line a, line b)\n{\n  vec va = a.sc - a.fr;\n  vec vb = b.sc - b.fr;\n  return a.fr + va * ( cross(vb, b.fr - a.fr) / cross(vb,va) );\n}\n\nbool intersectionLL(line a, line b, point &ret){\n  return intersectedLL( a, b ) ? ret = intersectionLL( a, b ), true : false;\n}\nbool intersectionLH(line a, hline b, point &ret){\n  point tmp;\n  return intersectionLL(a,b,tmp) ? ( ccw(b.fr,b.sc,tmp)&(OVER|FRONT) ? ret=tmp, true : false ) : false;\n}\nbool intersectionLS(line l, seg s, point &ret){\n  point tmp;\n  return intersectionLL(l,s,tmp) ? ( ccw(s.fr,s.sc,tmp)&OVER ? ret=tmp, true : false ) : false;\n}\nbool intersectionHH(hline a, hline b, point &ret){\n  point tmp;\n  return intersectionLL(a,b,tmp) ? ( ccw(a.fr,a.sc,tmp)&(OVER|FRONT)&&ccw(b.fr,b.sc,tmp)&(OVER|FRONT) ? ret = tmp, true : false ) : false;\n}\nbool intersectionHS(hline a, seg s, point &ret){\n  point tmp;\n  return intersectionLS(a,s,tmp) ? ( ccw(a.fr,a.sc,tmp)&(OVER|FRONT) ? ret = tmp, true : false ) : false;\n}\nbool intersectionSS(seg a, seg b, point &ret){\n  return intersectedSS(a,b) ? ret = intersectionSS(a,b), true : false;\n}\n\nbool convexCut(const vector<point> &vp,\n\t       line l,\n\t       vector<point> &left)\n{\n  int n = vp.size();\n  bool bFirst = true;\n  int indq1 = -1, indq2 = -1;\n  point q1, q2;\n  \n  for(int i = 0; i < n; ++i){\n    seg edge = make_pair( vp[i], vp[(i+1)%n] );\n    if( bFirst ){\n      if( intersectionLS( l, edge, q1 ) ){ bFirst = false; indq1 = (i+1)%n; }\n    }else{\n      if( intersectionLS( l, edge, q2 ) && far(q1,q2) ){ indq2 = (i+1)%n; break; }\n    }\n  }\n\n  if( indq1<0||indq2<0 ) return false;\n  if( lt( dist( q1, l.second ), dist( q2, l.second ) ) ){ swap( q1, q2 ); swap( indq1, indq2 ); }\n  if( far( q2, vp[indq2] ) ) left.push_back( q2 );\n  for(int i = indq2; i != indq1; i=(i+1>=n?0:i+1)) left.push_back( vp[i] );\n  if( far(q1, vp[(indq1-1+n)%n] ) ) left.push_back( q1 );\n\n  return true;\n}\n\nstruct Point{\n  point p;\n  Point():p(origin){}\n  Point(point p):p(p){}\n  bool operator < (const Point &t)const{\n    if(!eq(p.real(),t.p.real()))return lt(p.real(),t.p.real());\n    else return lt(p.imag(),t.p.imag());\n  }\n};\n\nstruct Node{\n  point p;\n  vector<int> con;\n  vector<double> cost;\n};\n\ntypedef vector<Node> Graph;\n\nstruct VolLine{\n  line l;\n  VolLine():l(origin,origin){}\n  VolLine(line l):l(l){}\n  int point_id[2]; // volonoi points id with touching with this line.\n};\n\nline expandLine(line l, elem mag){\n  line ret = l;\n  vec vf(l.first - l.second);\n  vec vs(l.second - l.first);\n  ret.first = l.second + mag * vf;\n  ret.second = l.first + mag * vs;\n  return ret;\n}\n\nvoid MakeVolonoi(const vector<point> &vp,\n\t\t const vector<point> &plane,\n\t\t vector< vector<point> > &out){\n  vector<point> tplane;\n  \n  for(int i = 0; i < vp.size(); ++i){\n    tplane = plane;\n    for(int j = 0; j < vp.size(); ++j){\n      if( i != j ){\n\tvector<point> newplane;\n\tpoint c = (vp[i]+vp[j])/2.;\n\tint cw = ccw( c, unmr(vp[i]-vp[j])+c, vp[i] );\n\tline bisec;\n\tif( cw == LEFT ){\n\t  bisec = line( c, unmr( vp[i]-vp[j] ) + c );\n\t}else{\n\t  bisec = line( c, unml( vp[i]-vp[j] ) + c );\n\t}\n\tbisec = expandLine( bisec, 20 ); // magnify segment for convex cut\n\tif( convexCut(tplane, bisec, newplane ) )\n\t  tplane = newplane;\n      }\n    }\n    out.push_back( tplane );\n  }\n};\n\nstruct State{\n  int now;\n  elem cost;\n  State(){}\n  bool operator<(const State &t)const{\n    return lt(cost,t.cost);\n  }\n};\n\nelem dijkstra(Graph &G, int sid){\n  elem ret = infty;\n  priority_queue<State> qs;\n  State init;\n  bool vis[G.size()];\n  elem A[G.size()];\n  for(int i = 0; i < G.size(); ++i){\n    vis[i]=false;\n    A[i]=infty;\n  }\n  init.now = sid;\n  init.cost = 0.0;\n  qs.push(init);\n  A[sid]=0.0;\n  while(!qs.empty()){\n    State st_now = qs.top(); qs.pop();\n    int nid = st_now.now;\n    if(vis[nid])continue;\n    else vis[nid]=true;\n    for(int i = 0; i < G[nid].con.size(); ++i){\n      State next;\n      next.now = G[nid].con[i];\n      //cout << next.now << endl;\n      next.cost = st_now.cost + G[nid].cost[i];\n      if( lt(next.cost, A[next.now]) ){\n\tA[next.now] = next.cost;\n\tif( !vis[next.now] ){\n\t  qs.push( next );\n\t}\n      }\n    }\n  }\n  for(int i = 0; i < G.size(); ++i){\n    if( eq(G[i].p.real(),GOAL_X) ){\n      ret = emin( ret, A[i] );\n    }\n  }\n  return ret;\n}\n\nint main()\n{\n  while(true){\n    int n;\n    elem ans=infty;\n    map<Point,int> point_id;\n    vector<point> vp,plane;\n    vector< vector<point> > volonoi;\n\n    cin >> n;\n    if( n == 0 ) break;\n    for(int i = 0; i < n; ++i){\n      elem x,y;\n      cin >> x >> y;\n      vp.push_back( point(x,y) );\n    }\n    if( n == 1 ){\n      puts(\"impossible\");\n      continue;\n    }\n    plane.push_back( point(0.0,0.0) );\n    plane.push_back( point(4.0,0.0) );\n    plane.push_back( point(4.0,4.0) );\n    plane.push_back( point(0.0,4.0) );\n    MakeVolonoi( vp, plane, volonoi );\n\n    /* debug \n    for(int i = 0; i < volonoi.size(); ++i){\n      cout << \"//\" << i << \" master point : \" << vp[i] << endl;\n      for(int j = 0; j < volonoi[i].size(); ++j){\n\tpoint lf=volonoi[i][j];\n\tpoint ls=volonoi[i][(j+1)%volonoi[i].size()];\n\n\tcout << \"line(\" << lf.real() <<\",\" << lf.imag() <<\",\" << ls.real() <<\",\"<<ls.imag() << \");\" << endl;\n      }\n    }\n    cout << endl;\n    */\n\n    int now = 0;\n    for(int i = 0; i < volonoi.size(); ++i){\n      for(int j = 0; j < volonoi[i].size(); ++j){\n\tPoint pp(volonoi[i][j]);\n\tif( point_id.find( pp ) == point_id.end() ){\n\t  point_id[pp] = now;\n\t  ++now;\n\t}\n      }\n    }\n    Graph G(now);\n\n    // Graph Construction\n    for(int i = 0; i < volonoi.size(); ++i){\n      int ni = volonoi[i].size();\n      for(int j = 0; j < ni; ++j){\n\tpoint p = volonoi[i][j];\n\tpoint np = volonoi[i][(j+1)%ni];\n\telem ck = ((p+np)/2.).imag();\n\telem ckx = ((p+np)/2.).real();\n\tif( eq(ckx,0.0)||eq(ckx,4.0)||eq(ck,0.0)||eq(ck,4.0) ) continue;\n\tint ip = point_id[Point(p)];\n\tint inp = point_id[Point(np)];\n\telem d = dist( p, np );\n\tG[ ip ].p = p;\n\tG[ inp ].p = np;\n\tG[ ip ].con.push_back( inp );\n\tG[ ip ].cost.push_back( d );\n\tG[ inp ].con.push_back( ip );\n\tG[ inp ].cost.push_back( d );\n      }\n    }\n\n    for(int i = 0; i < G.size(); ++i){\n      if( eq( G[i].p.real(), START_X ) ){\n\tans = emin( ans, dijkstra( G, i ) );\n      }\n    }\n\n    if(geq(ans,infty))puts(\"impossible\");\n    else printf(\"%.12lf\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1050 The Last Dungeon\n// 2018.3.4\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n#define QMAX 20000\ntypedef struct { short s; double t, x; } QUE;\nQUE que[QMAX]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n}\n\nvoid enq(short s, double t, double x)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;\n\tque[i].s = s, que[i].t = t, que[i].x = x;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\n#define N\t\t\t2000\n#define EPS\t\t\t1e-8\n#define EQ(a,b)\t\t(fabs((a)-(b))<EPS)\n\ntypedef struct { double x, y; } PP;\ntypedef struct { PP s, e; } SEG;\n\nPP p[21];\nPP po0[4] = {{0,0},{4,0},{4,4},{0,4}};\nPP po[2][200];\n\nPP  tbl[N]; int sz;\nshort hi[N], lim[N], *to[N];\nchar mk[N];\n\n#define PPeQ(a,b)\t(EQ(a.x,b.x)&&EQ(a.y,b.y))\nint dcmp(double x) { if (fabs(x) < EPS) return 0; return x <= 0 ? -1 : 1; }\nPP vsub(PP p1, PP p2) { PP r; r.x = p1.x - p2.x, r.y = p1.y - p2.y; return r; }\ndouble cross(PP a, PP b) { return a.x * b.y - a.y * b.x; }\ndouble vabs(PP a) { return hypot(a.x, a.y); }\n\n// ２線分間の交点\nPP crossPointS2P(SEG a, PP bs, PP be) { double a1, a2; PP r;\n\ta1 = cross(vsub(be, bs), vsub(a.s, bs));\n\ta2 = cross(vsub(be, bs), vsub(a.e, bs));\n\tr.x = (a.s.x*a2 - a.e.x*a1) / (a2-a1);\n\tr.y = (a.s.y*a2 - a.e.y*a1) / (a2-a1);\n\treturn r;\n}\n\n// 垂直二等分線\nvoid bisector(SEG *u, PP a, PP b)\n{\n\tdouble ax = (a.x + b.x)/2;\n\tdouble ay = (a.y + b.y)/2;\n\tu->s.x = ax, u->s.y = ay;\n\tif (fabs(a.y - b.y) <= EPS) u->e.x = ax, u->e.y = ay + (b.x-a.x)*100;\n\telse u->e.x = ax-(b.y-a.y)*100, u->e.y = (ax - u->e.x)*(b.x - a.x)/(b.y - a.y) + ay;\n}\n\n// 凸包を直線で切断して左側をpo[]に残す\nint convex_cut(SEG u, int n, PP *p, PP *po)\t\t// p --> po\n{\n\tint i, d1, d2, top = 0;\n    for (i = 0; i < n; i++) {\n        d1 = dcmp(cross(vsub(u.e, u.s), vsub(p[i],   u.s)));\n        d2 = dcmp(cross(vsub(u.e, u.s), vsub(p[i+1], u.s)));\n        if (d1 >= 0) po[top++] = p[i];\n        if (d1*d2 < 0) po[top++] = crossPointS2P(u, p[i], p[i+1]);\n    }\n\tpo[top] = po[0];\n    return top;\n}\n\nvoid pushBack(int a, int b)\n{\n\tint k;\n\n\tif (EQ(tbl[a].y, 0) && EQ(tbl[b].y, 0)) return;\n\tif (EQ(tbl[a].y, 4) && EQ(tbl[b].y, 4)) return;\n\n\tif (lim[a] == 0) {\n\t\tlim[a] = 2, hi[a] = 0;\n\t\tto[a] = malloc(sizeof(short) *lim[a]);\n\t} else if (hi[a] == lim[a]) {\n\t\tlim[a] <<= 1;\n\t\tto[a] = realloc(to[a], sizeof(short) *lim[a]);\n\t}\n\n\tfor (k = 0; k < hi[a]; k++) if (to[a][k] == b) return;\n\tto[a][hi[a]++] = b;\n}\n\ndouble dijkstra()\n{\n\tint i, s, e;\n\tdouble t, x;\n\n\tmemset(mk, 0, sizeof(mk));\n\tqsize = 0;\n\tfor (i = 0; i < sz; i++) {\n\t\tif (EQ(tbl[i].x, 0)) enq(i, 0, 0), mk[i] = 1;\n\t}\n\n\twhile (qsize) {\n\t\ts = que[0].s, t = que[0].t, x = que[0].x, deq();\n\t\tif (EQ(x, 4)) return t;\n\n\t\tfor (i = 0; i < hi[s]; i++) {\n\t\t\te = to[s][i];\n\t\t\tif (mk[e]) continue;\n\t\t\tmk[e] = 1, enq(e, t+vabs(vsub(tbl[s],tbl[e])), tbl[e].x);\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main()\n{\n\tint n, i, j, k, k1, k2, a, b, c;\n\tSEG u;\n\tdouble ans;\n\n\twhile (scanf(\"%d\", &n) && n) {\n\t\tfor (i = 0; i < n; i++) scanf(\"%lf%lf\", &p[i].x, &p[i].y);\n\t\tif (n == 1) { puts(\"impossible\"); continue; }\n\n\t\tsz = 0, memset(hi, 0, sizeof(hi)), memset(lim, 0, sizeof(lim));\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tmemcpy(po[0], po0, sizeof(po0));\n\t\t\tk = 4, k1 = 0, k2 = 1;\n\t\t\tfor (j = 0; j < n; j++) {\n\t\t\t\tif (j == i) continue;\n\t\t\t\tbisector(&u, p[i], p[j]);\n\t\t\t\tk = convex_cut(u, k, po[k1], po[k2]);\n\t\t\t\tk1 = k2, k2 = !k2;\n\t\t\t}\n\t\t\tif (k <= 1) continue;\n\t\t\tif (k == 2) {\n\t\t\t\ttbl[a=sz++] = po[k1][0], tbl[b=sz++] = po[k1][1];\n\t\t\t\tpushBack(a, b), pushBack(b, a);\n\t\t\t} else {\t\t\t// k >= 3\n\t\t\t\tj = sz;\t\t\t// j as memo\n\t\t\t\tfor (b = 0; b < k; b++) tbl[sz++] = po[k1][b];\n\t\t\t\ta = k-1, c = 1; for (b = 0; b < k; b++) {\n\t\t\t\t\tpushBack(j+b, j+a), pushBack(j+b, j+c);\n\t\t\t\t\tif (++a == k) a = 0;\n\t\t\t\t\tif (++c == k) c = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < sz; i++) for (j = i+1; j < sz; j++) {\n\t\t\tif (PPeQ(tbl[i], tbl[j])) pushBack(i, j), pushBack(j, i);\n\t\t}\n\n\t\tif ((ans = dijkstra()) < 0) puts(\"impossible\");\n\t\telse printf(\"%.12lf\\n\", ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 1050 The Last Dungeon\n// 2018.3.4\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n#define QMAX 1000\ntypedef struct { short s; double t, x; } QUE;\nQUE que[QMAX]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n}\n\nvoid enq(short s, double t, double x)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;\n\tque[i].s = s, que[i].t = t, que[i].x = x;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\n#define N\t\t\t100\n#define EPS\t\t\t1e-8\n#define EQ(a,b)\t\t(fabs((a)-(b))<EPS)\n\ntypedef struct { double x, y; } PP;\ntypedef struct { PP s, e; } SEG;\n\nPP p[21];\nPP po0[4] = {{0,0},{4,0},{4,4},{0,4}};\nPP po[2][200];\n\nPP  tbl[N]; int sz;\nshort hi[N], lim[N], *to[N];\nchar mk[N];\n\n#define PPeQ(a,b)\t(EQ(a.x,b.x)&&EQ(a.y,b.y))\nint dcmp(double x) { if (fabs(x) < EPS) return 0; return x <= 0 ? -1 : 1; }\nPP vsub(PP p1, PP p2) { PP r; r.x = p1.x - p2.x, r.y = p1.y - p2.y; return r; }\ndouble cross(PP a, PP b) { return a.x * b.y - a.y * b.x; }\ndouble vabs(PP a) { return hypot(a.x, a.y); }\n\n// ２線分間の交点\nPP crossPointS2P(SEG a, PP bs, PP be) { double a1, a2; PP r;\n\ta1 = cross(vsub(be, bs), vsub(a.s, bs));\n\ta2 = cross(vsub(be, bs), vsub(a.e, bs));\n\tr.x = (a.s.x*a2 - a.e.x*a1) / (a2-a1);\n\tr.y = (a.s.y*a2 - a.e.y*a1) / (a2-a1);\n\treturn r;\n}\n\n// 垂直二等分線\nvoid bisector(SEG *u, PP a, PP b)\n{\n\tdouble ax = (a.x + b.x)/2;\n\tdouble ay = (a.y + b.y)/2;\n\tu->s.x = ax, u->s.y = ay;\n\tif (fabs(a.y - b.y) <= EPS) u->e.x = ax, u->e.y = ay + (b.x-a.x)*100;\n\telse u->e.x = ax-(b.y-a.y)*100, u->e.y = (ax - u->e.x)*(b.x - a.x)/(b.y - a.y) + ay;\n}\n\n// 凸包を直線で切断して左側をpo[]に残す\nint convex_cut(SEG u, int n, PP *p, PP *po)\t\t// p --> po\n{\n\tint i, d1, d2, top = 0;\n    for (i = 0; i < n; i++) {\n        d1 = dcmp(cross(vsub(u.e, u.s), vsub(p[i],   u.s)));\n        d2 = dcmp(cross(vsub(u.e, u.s), vsub(p[i+1], u.s)));\n        if (d1 >= 0) po[top++] = p[i];\n        if (d1*d2 < 0) po[top++] = crossPointS2P(u, p[i], p[i+1]);\n    }\n\tpo[top] = po[0];\n    return top;\n}\n\nvoid pushBack(int a, int b)\n{\n\tint k;\n\n\tif (EQ(tbl[a].y, 0) && EQ(tbl[b].y, 0)) return;\n\tif (EQ(tbl[a].y, 4) && EQ(tbl[b].y, 4)) return;\n\n\tif (lim[a] == 0) {\n\t\tlim[a] = 2, hi[a] = 0;\n\t\tto[a] = malloc(sizeof(short) *lim[a]);\n\t} else if (hi[a] == lim[a]) {\n\t\tlim[a] <<= 1;\n\t\tto[a] = realloc(to[a], sizeof(short) *lim[a]);\n\t}\n\n\tfor (k = 0; k < hi[a]; k++) if (to[a][k] == b) return;\n\tto[a][hi[a]++] = b;\n}\n\ndouble dijkstra()\n{\n\tint i, s, e;\n\tdouble t, x;\n\n\tmemset(mk, 0, sizeof(mk));\n\tqsize = 0;\n\tfor (i = 0; i < sz; i++) {\n\t\tif (EQ(tbl[i].x, 0)) enq(i, 0, 0), mk[i] = 1;\n\t}\n\n\twhile (qsize) {\n\t\ts = que[0].s, t = que[0].t, x = que[0].x, deq();\n\t\tif (EQ(x, 4)) return t;\n\n\t\tfor (i = 0; i < hi[s]; i++) {\n\t\t\te = to[s][i];\n\t\t\tif (mk[e]) continue;\n\t\t\tmk[e] = 1, enq(e, t+vabs(vsub(tbl[s],tbl[e])), tbl[e].x);\n\t\t}\n\t}\n\treturn -1;\n}\n\nint main()\n{\n\tint n, i, j, k, k1, k2, a, b, c;\n\tSEG u;\n\tdouble ans;\n\n\twhile (scanf(\"%d\", &n) && n) {\n\t\tfor (i = 0; i < n; i++) scanf(\"%lf%lf\", &p[i].x, &p[i].y);\n\t\tif (n == 1) { puts(\"impossible\"); continue; }\n\n\t\tsz = 0, memset(hi, 0, sizeof(hi)), memset(lim, 0, sizeof(lim));\n\t\tmemset(po, 0, sizeof(po));\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tmemcpy(po[0], po0, sizeof(po0));\n\t\t\tk = 4, k1 = 0, k2 = 1;\n\t\t\tfor (j = 0; j < n; j++) {\n\t\t\t\tif (j == i) continue;\n\t\t\t\tbisector(&u, p[i], p[j]);\n\t\t\t\tk = convex_cut(u, k, po[k1], po[k2]);\n\t\t\t\tk1 = k2, k2 = !k2;\n\t\t\t}\n\t\t\tif (k <= 1) continue;\n\t\t\tif (k == 2) {\n\t\t\t\ttbl[a=sz++] = po[k1][0], tbl[b=sz++] = po[k1][1];\n\t\t\t\tpushBack(a, b), pushBack(b, a);\n\t\t\t} else {\t\t\t// k >= 3\n\t\t\t\tj = sz;\t\t\t// j as memo\n\t\t\t\tfor (b = 0; b < k; b++) tbl[sz++] = po[k1][b];\n\t\t\t\ta = k-1, c = 1; for (b = 0; b < k; b++) {\n\t\t\t\t\tpushBack(j+b, j+a), pushBack(j+b, j+c);\n\t\t\t\t\tif (++a == k) a = 0;\n\t\t\t\t\tif (++c == k) c = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i < sz; i++) for (j = i+1; j < sz; j++) {\n\t\t\tif (PPeQ(tbl[i], tbl[j])) pushBack(i, j), pushBack(j, i);\n\t\t}\n\n\t\tif ((ans = dijkstra()) < 0) puts(\"impossible\");\n\t\telse printf(\"%.12lf\\n\", ans);\n\n\t\tfor (i = 0; i < sz; i++) if (lim[i]) free(to[i]);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "Python",
    "code": "# AOJ 1050 The Last Dungeon\n# Python3 2018.7.7 bal4u\n\nimport math\nimport heapq\n\nEPS = 1e-8\npp0 = [0j, 4+0j, 4+4j, 4j]\n\ndef EQ(a,b): return abs(a-b)<EPS\ndef PPeQ(a,b): return EQ(a.real, b.real) and EQ(a.imag, b.imag)\ndef dcmp(x):\n\tif PPeQ(x, 0): return 0\n\treturn -1 if x <= 0 else 1\ndef cross(a, b): return a.real*b.imag - a.imag*b.real\ndef vabs(a): return math.hypot(a.real, a.imag)\n\n# ２線分間の交点 (SEG a, PP bs, PP be)\ndef crossPointS2P(seg, bs, be):\n\ta1 = cross(be-bs, seg[0]-bs)\n\ta2 = cross(be-bs, seg[1]-bs)\n\treturn complex((seg[0].real*a2-seg[1].real*a1)/(a2-a1),\t(seg[0].imag*a2-seg[1].imag*a1)/(a2-a1))\n\n# 垂直二等分線 (PP a, PP b)\ndef bisector(a, b):\n\tax, ay = (a.real + b.real)/2, (a.imag + b.imag)/2\n\tif EQ(a.imag, b.imag): return [complex(ax, ay), complex(ax, ay+(b.real-a.real)*100)]\n\tt = ax-(b.imag-a.imag)*100\n\treturn [complex(ax, ay), complex(t, (ax-t)*(b.real-a.real)/(b.imag-a.imag)+ay)]\n\n# 凸包を直線で切断して左側を残す (SEG a, PP *p)\ndef convex_cut(seg, p):\n\tans, n = [], len(p)\n\tfor i in range(n):\n\t\td1 = dcmp(cross(seg[1]-seg[0], p[i]-seg[0]))\n\t\tt = p[0] if i+1 == n else p[i+1]\n\t\td2 = dcmp(cross(seg[1]-seg[0], t-seg[0]))\n\t\tif d1 >= 0: ans.append(p[i])\n\t\tif d1*d2 < 0: ans.append(crossPointS2P(seg, p[i], t))\n\treturn ans\n\ndef pushBack(a, b):\n\tif EQ(tbl[a].imag, 0) and EQ(tbl[b].imag, 0): return\n\tif EQ(tbl[a].imag, 4) and EQ(tbl[b].imag, 4): return\n\tif b in to[a]: return;\n\tto[a].append(b)\n\ndef dijkstra(V, to, tbl):\n\tvisited = [0]*V\n\tQ = []\n\tfor i in range(V):\n\t\tif EQ(tbl[i].real, 0):\n\t\t\theapq.heappush(Q, (0, i, 0))\n\t\t\tvisited[i] = 1\n\twhile Q:\n\t\tt, s, x\t= heapq.heappop(Q)\n\t\tif EQ(x, 4): return t\n\t\tfor e in to[s]:\n\t\t\tif visited[e]: continue\n\t\t\tvisited[e] = 1\n\t\t\theapq.heappush(Q, (t+vabs(tbl[s]-tbl[e]), e, tbl[e].real))\n\treturn -1\n\nwhile True:\n\tn = int(input())\n\tif n == 0: break\n\tp = []\n\tfor i in range(n):\n\t\tx, y = map(float, input().split())\n\t\tp.append(complex(x, y))\n\tif n == 1:\n\t\tprint(\"impossible\")\n\t\tcontinue;\n\ttbl, sz = [], 0\n\tto = [[] for i in range(50)]\n\tfor i in range(n):\n\t\tpo = pp0[0:]\n\t\tfor j in range(n):\n\t\t\tif j == i: continue\n\t\t\tseg = bisector(p[i], p[j])\n\t\t\tpo = convex_cut(seg, po)\n\t\tw = len(po)\n\t\tif w <= 1: continue\n\t\tif w == 2:\n\t\t\ta, sz = sz, sz+1\n\t\t\ttbl.append(po[0])\n\t\t\tb, sz = sz, sz+1\n\t\t\ttbl.append(po[1])\n\t\t\tpushBack(a, b)\n\t\t\tpushBack(b, a)\n\t\telse:\t\t\t# k >= 3\n\t\t\tj = sz\t\t# j as memo\n\t\t\tsz += w\n\t\t\ttbl.extend(po)\n\t\t\ta, c = w-1, 1\n\t\t\tfor b in range(w):\n\t\t\t\tpushBack(j+b, j+a)\n\t\t\t\tpushBack(j+b, j+c)\n\t\t\t\ta, c = a+1, c+1\n\t\t\t\tif a == w: a = 0\n\t\t\t\tif c == w: c = 0\n\tfor i in range(sz):\n\t\tfor j in range(i+1, sz):\n\t\t\tif PPeQ(tbl[i], tbl[j]):\n\t\t\t\tpushBack(i, j)\n\t\t\t\tpushBack(j, i)\n\tans = dijkstra(sz, to, tbl)\n\tprint(\"impossible\" if ans < 0 else ans)\n\n"
  }
]