[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <stdbool.h>\n\n#define SIZE 4\n\ntypedef struct {\n    int x, y;\n} Point;\n\ntypedef struct {\n    Point point;\n    int dist;\n} Node;\n\nchar grid[SIZE][SIZE];\nint dist[SIZE][SIZE];\nbool visited[SIZE][SIZE];\nPoint monsters[16];\nint monster_count = 0;\n\nint min(int a, int b) {\n    return a < b ? a : b;\n}\n\nint max(int a, int b) {\n    return a > b ? a : b;\n}\n\nint manhattan(int x1, int y1, int x2, int y2) {\n    return abs(x1 - x2) + abs(y1 - y2);\n}\n\nvoid precompute_distances() {\n    for (int i = 0; i < SIZE; i++) {\n        for (int j = 0; j < SIZE; j++) {\n            if (grid[i][j] == 'M') {\n                for (int x = 0; x < SIZE; x++) {\n                    for (int y = 0; y < SIZE; y++) {\n                        int d = manhattan(i, j, x, y);\n                        if (grid[x][y] != 'M' && (dist[x][y] == 0 || d < dist[x][y])) {\n                            dist[x][y] = d;\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\nbool is_safe(int x, int y) {\n    if (grid[x][y] == 'M') return false;\n    int min_dist = dist[x][y];\n    int count = 0;\n    for (int i = 0; i < SIZE; i++) {\n        for (int j = 0; j < SIZE; j++) {\n            if (grid[i][j] == 'M' && manhattan(i, j, x, y) == min_dist) {\n                count++;\n                if (count >= 2) return true;\n            }\n        }\n    }\n    return count >= 2;\n}\n\nint bfs() {\n    Point queue[SIZE * SIZE];\n    int front = 0, rear = 0;\n    int moves[SIZE][SIZE];\n    for (int i = 0; i < SIZE; i++) {\n        for (int j = 0; j < SIZE; j++) {\n            moves[i][j] = -1;\n            visited[i][j] = false;\n        }\n    }\n\n    for (int j = 0; j < SIZE; j++) {\n        if (is_safe(0, j)) {\n            queue[rear++] = (Point){0, j};\n            moves[0][j] = 1;\n            visited[0][j] = true;\n        }\n    }\n\n    int dx[] = {-1, 1, 0, 0};\n    int dy[] = {0, 0, -1, 1};\n\n    while (front < rear) {\n        Point current = queue[front++];\n        if (current.x == SIZE - 1) {\n            return moves[current.x][current.y];\n        }\n\n        for (int i = 0; i < 4; i++) {\n            int nx = current.x + dx[i];\n            int ny = current.y + dy[i];\n            if (nx >= 0 && nx < SIZE && ny >= 0 && ny < SIZE && !visited[nx][ny] && is_safe(nx, ny)) {\n                visited[nx][ny] = true;\n                moves[nx][ny] = moves[current.x][current.y] + 1;\n                queue[rear++] = (Point){nx, ny};\n            }\n        }\n    }\n\n    return -1;\n}\n\nint main() {\n    for (int i = 0; i < SIZE; i++) {\n        for (int j = 0; j < SIZE; j++) {\n            scanf(\" %c\", &grid[i][j]);\n            if (grid[i][j] == 'M') {\n                monsters[monster_count++] = (Point){i, j};\n            }\n            dist[i][j] = 0;\n        }\n    }\n\n    precompute_distances();\n\n    int result = bfs();\n    if (result == -1) {\n        printf(\"impossible\\n\");\n    } else {\n        printf(\"%d\\n\", result);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:59:14"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class DungeonCrossing {\n    static int[][] grid = new int[4][4];\n    static int[] dx = {0, 0, 1, -1};\n    static int[] dy = {1, -1, 0, 0};\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        for (int i = 0; i < 4; i++) {\n            for (int j = 0; j < 4; j++) {\n                grid[i][j] = scanner.nextInt();\n            }\n        }\n\n        int shortestPath = bfs();\n        System.out.println(shortestPath == -1 ? \"impossible\" : shortestPath);\n    }\n\n    static int bfs() {\n        Queue<int[]> queue = new LinkedList<>();\n        boolean[][] visited = new boolean[4][4];\n\n        for (int j = 0; j < 4; j++) {\n            queue.offer(new int[]{0, j, 0});\n            visited[0][j] = true;\n        }\n\n        while (!queue.isEmpty()) {\n            int[] current = queue.poll();\n            int x = current[0], y = current[1], steps = current[2];\n\n            if (x == 3) return steps;\n\n            for (int i = 0; i < 4; i++) {\n                int nx = x + dx[i], ny = y + dy[i];\n\n                if (nx >= 0 && nx < 4 && ny >= 0 && ny < 4 && !visited[nx][ny]) {\n                    if (isSafePath(x, y, nx, ny)) {\n                        queue.offer(new int[]{nx, ny, steps + 1});\n                        visited[nx][ny] = true;\n                    }\n                }\n            }\n        }\n\n        return -1;\n    }\n\n    static boolean isSafePath(int x1, int y1, int x2, int y2) {\n        List<Integer> distances = new ArrayList<>();\n        for (int i = 0; i < 4; i++) {\n            for (int j = 0; j < 4; j++) {\n                if (grid[i][j] == 1) {\n                    int dist1 = Math.abs(x1 - i) + Math.abs(y1 - j);\n                    int dist2 = Math.abs(x2 - i) + Math.abs(y2 - j);\n                    distances.add(Math.min(dist1, dist2));\n                }\n            }\n        }\n\n        Collections.sort(distances);\n        return distances.get(1).equals(distances.get(0));\n    }\n}",
    "timestamp": "2025-08-05 18:59:23"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n#include <algorithm>\nusing namespace std;\n\nstruct Point {\n    int x, y;\n    Point(int x, int y) : x(x), y(y) {}\n};\n\nint dx[] = {-1, 1, 0, 0};\nint dy[] = {0, 0, -1, 1};\n\nbool isSafe(int x, int y, const vector<Point>& monsters) {\n    if (x < 0 || x >= 4 || y < 0 || y >= 4) return false;\n    int minDist = INT_MAX;\n    int count = 0;\n    for (const auto& m : monsters) {\n        int dist = abs(x - m.x) + abs(y - m.y);\n        if (dist < minDist) {\n            minDist = dist;\n            count = 1;\n        } else if (dist == minDist) {\n            count++;\n        }\n    }\n    return count >= 2;\n}\n\nint bfs(const vector<Point>& monsters) {\n    queue<Point> q;\n    vector<vector<int>> dist(4, vector<int>(4, -1));\n    for (int y = 0; y < 4; ++y) {\n        if (isSafe(0, y, monsters)) {\n            q.push(Point(0, y));\n            dist[0][y] = 0;\n        }\n    }\n    while (!q.empty()) {\n        Point p = q.front();\n        q.pop();\n        if (p.x == 3) {\n            return dist[p.x][p.y];\n        }\n        for (int i = 0; i < 4; ++i) {\n            int nx = p.x + dx[i];\n            int ny = p.y + dy[i];\n            if (nx >= 0 && nx < 4 && ny >= 0 && ny < 4 && dist[nx][ny] == -1 && isSafe(nx, ny, monsters)) {\n                dist[nx][ny] = dist[p.x][p.y] + 1;\n                q.push(Point(nx, ny));\n            }\n        }\n    }\n    return -1;\n}\n\nint main() {\n    vector<Point> monsters;\n    for (int i = 0; i < 4; ++i) {\n        string line;\n        cin >> line;\n        for (int j = 0; j < 4; ++j) {\n            if (line[j] == 'M') {\n                monsters.emplace_back(i, j);\n            }\n        }\n    }\n    int result = bfs(monsters);\n    if (result != -1) {\n        cout << result << endl;\n    } else {\n        cout << \"impossible\" << endl;\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 18:59:52"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_SIZE 4\n#define INF INT_MAX\n\ntypedef struct {\n    int x, y;\n} Point;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\n\nint grid[MAX_SIZE][MAX_SIZE];\nint distance[MAX_SIZE][MAX_SIZE];\nint visited[MAX_SIZE][MAX_SIZE];\n\nint is_valid(int x, int y) {\n    return x >= 0 && x < MAX_SIZE && y >= 0 && y < MAX_SIZE;\n}\n\nint count_close_monsters(int x, int y) {\n    int min_dist = INF;\n    int count = 0;\n    \n    for (int i = 0; i < MAX_SIZE; i++) {\n        for (int j = 0; j < MAX_SIZE; j++) {\n            if (grid[i][j] == 1) {\n                int dist = abs(x - i) + abs(y - j);\n                if (dist < min_dist) {\n                    min_dist = dist;\n                    count = 1;\n                } else if (dist == min_dist) {\n                    count++;\n                }\n            }\n        }\n    }\n    \n    return count >= 2 ? 1 : 0;\n}\n\nint bfs() {\n    for (int i = 0; i < MAX_SIZE; i++) {\n        for (int j = 0; j < MAX_SIZE; j++) {\n            distance[i][j] = INF;\n            visited[i][j] = 0;\n        }\n    }\n    \n    Point queue[MAX_SIZE * MAX_SIZE];\n    int front = 0, rear = 0;\n    \n    for (int j = 0; j < MAX_SIZE; j++) {\n        if (count_close_monsters(0, j)) {\n            queue[rear].x = 0;\n            queue[rear].y = j;\n            distance[0][j] = 0;\n            visited[0][j] = 1;\n            rear++;\n        }\n    }\n    \n    while (front < rear) {\n        Point curr = queue[front++];\n        \n        if (curr.x == MAX_SIZE - 1) {\n            return distance[curr.x][curr.y];\n        }\n        \n        for (int k = 0; k < 4; k++) {\n            int nx = curr.x + dx[k];\n            int ny = curr.y + dy[k];\n            \n            if (is_valid(nx, ny) && !visited[nx][ny] && count_close_monsters(nx, ny)) {\n                queue[rear].x = nx;\n                queue[rear].y = ny;\n                distance[nx][ny] = distance[curr.x][curr.y] + 1;\n                visited[nx][ny] = 1;\n                rear++;\n            }\n        }\n    }\n    \n    return -1;\n}\n\nint main() {\n    for (int i = 0; i < MAX_SIZE; i++) {\n        for (int j = 0; j < MAX_SIZE; j++) {\n            scanf(\"%d\", &grid[i][j]);\n        }\n    }\n    \n    int result = bfs();\n    \n    if (result == -1) {\n        printf(\"impossible\\n\");\n    } else {\n        printf(\"%d\\n\", result);\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 19:00:03"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nconst int dx[] = {0, 0, 1, -1};\nconst int dy[] = {1, -1, 0, 0};\n\nstruct State {\n    int x, y, dist;\n    vector<pair<int,int>> monsters;\n};\n\nint main() {\n    vector<vector<char>> grid(4, vector<char>(4));\n    vector<pair<int,int>> monster_pos;\n\n    for (int i = 0; i < 4; i++) {\n        for (int j = 0; j < 4; j++) {\n            cin >> grid[i][j];\n            if (grid[i][j] == 'M') {\n                monster_pos.push_back({i, j});\n            }\n        }\n    }\n\n    queue<State> q;\n    vector<vector<bool>> visited(4, vector<bool>(4, false));\n\n    for (int j = 0; j < 4; j++) {\n        if (grid[0][j] != 'M') {\n            State start;\n            start.x = 0;\n            start.y = j;\n            start.dist = 0;\n            start.monsters = monster_pos;\n            q.push(start);\n            visited[0][j] = true;\n        }\n    }\n\n    while (!q.empty()) {\n        State curr = q.front();\n        q.pop();\n\n        if (curr.x == 3) {\n            cout << curr.dist << endl;\n            return 0;\n        }\n\n        for (int d = 0; d < 4; d++) {\n            int nx = curr.x + dx[d];\n            int ny = curr.y + dy[d];\n\n            if (nx >= 0 && nx < 4 && ny >= 0 && ny < 4 && !visited[nx][ny] && grid[nx][ny] != 'M') {\n                int safe_count = 0;\n                for (auto& monster : curr.monsters) {\n                    int mdist = abs(monster.first - nx) + abs(monster.second - ny);\n                    int closest_dist = INT_MAX;\n\n                    for (auto& other_monster : curr.monsters) {\n                        int odist = abs(other_monster.first - nx) + abs(other_monster.second - ny);\n                        closest_dist = min(closest_dist, odist);\n                    }\n\n                    if (mdist == closest_dist) {\n                        safe_count++;\n                    }\n                }\n\n                if (safe_count >= 2) {\n                    State next;\n                    next.x = nx;\n                    next.y = ny;\n                    next.dist = curr.dist + 1;\n                    next.monsters = curr.monsters;\n                    q.push(next);\n                    visited[nx][ny] = true;\n                }\n            }\n        }\n    }\n\n    cout << \"impossible\" << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 19:00:14"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Point {\n    int x, y;\n    Point(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n}\n\npublic class Main {\n    static int[] dx = {-1, 1, 0, 0};\n    static int[] dy = {0, 0, -1, 1};\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        List<Point> monsters = new ArrayList<>();\n        for (int i = 0; i < 4; i++) {\n            String line = sc.nextLine();\n            for (int j = 0; j < 4; j++) {\n                if (line.charAt(j) == 'M') {\n                    monsters.add(new Point(i, j));\n                }\n            }\n        }\n\n        Queue<Point> queue = new LinkedList<>();\n        int[][] dist = new int[4][4];\n        boolean[][] visited = new boolean[4][4];\n        for (int i = 0; i < 4; i++) {\n            if (isSafe(0, i, monsters)) {\n                queue.add(new Point(0, i));\n                visited[0][i] = true;\n                dist[0][i] = 1;\n            }\n        }\n\n        boolean found = false;\n        Point end = null;\n        while (!queue.isEmpty()) {\n            Point p = queue.poll();\n            if (p.x == 3) {\n                found = true;\n                end = p;\n                break;\n            }\n            for (int i = 0; i < 4; i++) {\n                int nx = p.x + dx[i];\n                int ny = p.y + dy[i];\n                if (nx >= 0 && nx < 4 && ny >= 0 && ny < 4 && !visited[nx][ny] && isSafe(nx, ny, monsters)) {\n                    visited[nx][ny] = true;\n                    dist[nx][ny] = dist[p.x][p.y] + 1;\n                    queue.add(new Point(nx, ny));\n                }\n            }\n        }\n\n        if (found) {\n            System.out.println(dist[end.x][end.y]);\n        } else {\n            System.out.println(\"impossible\");\n        }\n    }\n\n    static boolean isSafe(int x, int y, List<Point> monsters) {\n        if (monsters.isEmpty()) return true;\n        int minDist = Integer.MAX_VALUE;\n        int count = 0;\n        for (Point m : monsters) {\n            int dist = Math.abs(x - m.x) + Math.abs(y - m.y);\n            if (dist < minDist) {\n                minDist = dist;\n                count = 1;\n            } else if (dist == minDist) {\n                count++;\n            }\n        }\n        return count >= 2;\n    }\n}",
    "timestamp": "2025-08-05 19:01:19"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import deque\n\ndef bfs(grid):\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    def is_in_grid(x, y):\n        return 0 <= x < 4 and 0 <= y < 4\n\n    def monsters_nearby(x, y):\n        min_distance = float('inf')\n        count = 0\n        distances = []\n        for i2 in range(4):\n            for j2 in range(4):\n                if grid[i2][j2] == 'M':\n                    distance = abs(i2 - x) + abs(j2 - y)\n                    distances.append((distance, i2, j2))\n                    min_distance = min(min_distance, distance)\n        for d, _, _ in distances:\n            if d == min_distance:\n                count += 1\n        return count >= 2\n\n    queue = deque([(0, 0, 0)])  # x, y, steps\n    visited = set((0, 0))\n    if not monsters_nearby(0, 0):\n        return 'impossible'\n\n    while queue:\n        x, y, steps = queue.popleft()\n        if x == 3 and y == 3:\n            return steps\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if is_in_grid(nx, ny) and (nx, ny) not in visited and monsters_nearby(nx, ny):\n                visited.add((nx, ny))\n                queue.append((nx, ny, steps + 1))\n\n    return 'impossible'\n\ngrid = [\n    ['.', '.', '.', 'M'],\n    ['.', 'M', '.', '.'],\n    ['.', '.', 'M', '.'],\n    ['M', '.', '.', '.']\n]\n\nprint(bfs(grid))",
    "timestamp": "2025-08-13 01:47:21"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Queue;\n\nclass Main {\n\n    private static final int[] dx = {1, -1, 0, 0};\n    private static final int[] dy = {0, 0, 1, -1};\n\n    public static void main(String[] args) {\n        char[][] dungeon = {\n            {'S', '.', '.', '.'},\n            {'.', '.', '.', '.'},\n            {'.', '.', '.', '.'},\n            {'.', '.', '.', 'E'}\n        };\n\n        System.out.println(findShortestSafePath(dungeon));\n    }\n\n    private static String findShortestSafePath(char[][] dungeon) {\n        int n = dungeon.length;\n        int[][] distance = new int[n][n];\n        for (int[] row : distance) {\n            Arrays.fill(row, Integer.MAX_VALUE);\n        }\n\n        Queue<int[]> queue = new LinkedList<>();\n        queue.offer(new int[]{0, 0});\n        distance[0][0] = 0;\n\n        while (!queue.isEmpty()) {\n            int[] current = queue.poll();\n            int x = current[0];\n            int y = current[1];\n\n            for (int dir = 0; dir < 4; dir++) {\n                int nx = x + dx[dir];\n                int ny = y + dy[dir];\n\n                if (isInBounds(nx, ny, n) && distance[nx][ny] == Integer.MAX_VALUE) {\n                    dungeon[nx][ny] = countClosestMonsters(nx, ny, dungeon) ? 'M' : '.';\n                    if (dungeon[nx][ny] == '.') {\n                        distance[nx][ny] = distance[x][y] + 1;\n                        queue.offer(new int[]{nx, ny});\n                    }\n                }\n            }\n        }\n        return distance[n-1][n-1] == Integer.MAX_VALUE ? \"impossible\" : String.valueOf(distance[n-1][n-1]);\n    }\n\n    private static boolean countClosestMonsters(int x, int y, char[][] dungeon) {\n        int n = dungeon.length;\n        int monsterCount = 0;\n        int minDistance = Integer.MAX_VALUE;\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (dungeon[i][j] == 'M') {\n                    int dist = Math.abs(x - i) + Math.abs(y - j);\n                    if (dist < minDistance) {\n                        minDistance = dist;\n                        monsterCount = 1;\n                    } else if (dist == minDistance) {\n                        monsterCount++;\n                    }\n                }\n            }\n        }\n\n        return monsterCount >= 2;\n    }\n\n    private static boolean isInBounds(int x, int y, int n) {\n        return x >= 0 && y >= 0 && x < n && y < n;\n    }\n}",
    "timestamp": "2025-08-13 01:47:30"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <limits.h>\n\n#define SIZE 4\n\nint grid[SIZE][SIZE];\nint distance[SIZE][SIZE];\n\nint isValid(int x, int y) {\n    return x >= 0 && x < SIZE && y >= 0 && y < SIZE;\n}\n\nvoid calculateDistances() {\n    int dx[] = {-1, 1, 0, 0};\n    int dy[] = {0, 0, -1, 1};\n    for (int i = 0; i < SIZE; ++i) {\n        for (int j = 0; j < SIZE; ++j) {\n            int min_dist = INT_MAX;\n            for (int k = 0; k < 4; ++k) {\n                int ni = i + dx[k], nj = j + dy[k];\n                if (isValid(ni, nj) && grid[i][j] == grid[ni][nj]) {\n                    int dist = abs(i - ni) + abs(j - nj);\n                    if (dist < min_dist) {\n                        min_dist = dist;\n                    }\n                }\n            }\n            distance[i][j] = min_dist;\n        }\n    }\n}\n\nint findPath() {\n    calculateDistances();\n    if (distance[0][0] != INT_MAX) {\n        return 0;\n    }\n    for (int i = 0; i < SIZE; ++i) {\n        for (int j = 0; j < SIZE; j++) {\n            if (i == SIZE - 1 && j == SIZE - 1) {\n                return distance[i][j] != INT_MAX;\n            }\n        }\n    }\n    return 0;\n}\n\nint main() {\n    // Assuming grid is already filled with distances to monsters.\n    // 0 represents empty, and 1 to N represents different monsters.\n    if(findPath()) {\n        printf(\"%d\\n\", distance[SIZE - 1][SIZE - 1]);\n    } else {\n        printf(\"impossible\\n\");\n    }\n    return 0;\n}",
    "timestamp": "2025-08-13 01:47:48"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import deque\n\ndef solve(grid):\n    def is_valid(x, y):\n        return 0 <= x < 4 and 0 <= y < 4\n\n    def monster_distances(x, y):\n        distances = []\n        for mx, my in monsters:\n            distances.append(abs(x - mx) + abs(y - my))\n        return distances\n\n    def is_safe_path(x, y):\n        dists = monster_distances(x, y)\n        return sum(d == min(dists) for d in dists) >= 2\n\n    monsters = [(i, j) for i in range(4) for j in range(4) if grid[i][j] == 1]\n    \n    queue = deque([(0, j, 0) for j in range(4) if is_safe_path(0, j)])\n    visited = set()\n\n    while queue:\n        x, y, steps = queue.popleft()\n        \n        if x == 3:\n            return steps\n        \n        if (x, y) in visited:\n            continue\n        \n        visited.add((x, y))\n        \n        for dx, dy in [(0,1), (0,-1), (1,0), (-1,0)]:\n            nx, ny = x + dx, y + dy\n            \n            if is_valid(nx, ny) and is_safe_path(nx, ny) and (nx, ny) not in visited:\n                queue.append((nx, ny, steps + 1))\n    \n    return 'impossible'\n\ndef main():\n    grid = []\n    for _ in range(4):\n        grid.append(list(map(int, input().split())))\n    \n    print(solve(grid))\n\nif __name__ == '__main__':\n    main()",
    "timestamp": "2025-08-13 01:48:16"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import heapq\n\ndef solve():\n    # Read input\n    monsters = []\n    for _ in range(4):\n        row = input().strip()\n        monsters.append(row)\n    \n    # Directions: up, down, left, right\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    \n    # Precompute distances from each cell to all monsters\n    distance_grid = [[[] for _ in range(4)] for _ in range(4)]\n    for i in range(4):\n        for j in range(4):\n            if monsters[i][j] == 'm':\n                # BFS to compute distances from this monster\n                visited = [[-1 for _ in range(4)] for _ in range(4)]\n                q = [(i, j)]\n                visited[i][j] = 0\n                while q:\n                    x, y = q.pop(0)\n                    for dx, dy in directions:\n                        nx, ny = x + dx, y + dy\n                        if 0 <= nx < 4 and 0 <= ny < 4 and visited[nx][ny] == -1:\n                            visited[nx][ny] = visited[x][y] + 1\n                            q.append((nx, ny))\n                # Store distances for each cell\n                for x in range(4):\n                    for y in range(4):\n                        distance_grid[x][y].append(visited[x][y])\n    \n    # Check if a cell is safe (at least two monsters have the same minimal distance)\n    def is_safe(x, y):\n        if not distance_grid[x][y]:\n            return True  # no monsters\n        min_dist = min(distance_grid[x][y])\n        count = distance_grid[x][y].count(min_dist)\n        return count >= 2\n    \n    # Dijkstra's algorithm to find the shortest path\n    heap = []\n    # (steps, x, y)\n    heapq.heappush(heap, (0, 0, 0))\n    visited = [[False for _ in range(4)] for _ in range(4)]\n    visited[0][0] = True\n    found = False\n    result = -1\n    \n    while heap:\n        steps, x, y = heapq.heappop(heap)\n        if x == 3 and y == 3:\n            found = True\n            result = steps\n            break\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < 4 and 0 <= ny < 4 and not visited[nx][ny] and is_safe(nx, ny):\n                visited[nx][ny] = True\n                heapq.heappush(heap, (steps + 1, nx, ny))\n    \n    if found:\n        print(result)\n    else:\n        print(\"impossible\")\n\nsolve()",
    "timestamp": "2025-08-13 01:48:38"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <cmath>\n#include <cstring>\n\nusing namespace std;\n\nconst int N = 4;\nconst int INF = 100000;\n\nstruct Point {\n    int x, y;\n};\n\nint dx[] = {-1, 0, 1, 0};\nint dy[] = {0, 1, 0, -1};\n\n// Function to calculate the distance between two points\nint dist(Point a, Point b) {\n    return abs(a.x - b.x) + abs(a.y - b.y);\n}\n\nbool can_pass(int x, int y, vector<Point> &monsters) {\n    int min_dist = INF;\n    int count = 0;\n    \n    for (auto &monster : monsters) {\n        int d = dist({x, y}, monster);\n        if (d < min_dist) {\n            min_dist = d;\n            count = 1;\n        } else if (d == min_dist) {\n            count++;\n        }\n    }\n    \n    return count >= 2;\n}\n\nint bfs(Point start, Point end, vector<Point> &monsters) {\n    queue<Point> q;\n    int distance[N][N];\n    memset(distance, INF, sizeof(distance));\n    \n    q.push(start);\n    distance[start.x][start.y] = 0;\n    \n    while (!q.empty()) {\n        Point current = q.front();\n        q.pop();\n        \n        for (int i = 0; i < 4; i++) {\n            int nx = current.x + dx[i];\n            int ny = current.y + dy[i];\n            \n            if (nx >= 0 && ny >= 0 && nx < N && ny < N && distance[nx][ny] == INF) {\n                if (can_pass(nx, ny, monsters)) {\n                    distance[nx][ny] = distance[current.x][current.y] + 1;\n                    q.push({nx, ny});\n                }\n            }\n        }\n    }\n    \n    return distance[end.x][end.y];\n}\n\nint main() {\n    vector<Point> monsters = {{0, 0}, {0, 1}, {1, 3}, {3, 1}};\n    // Initialize start and end points, assuming Ponta starts at (0, 0) and ends at (3, 3)\n    Point start = {0, 0}, end = {3, 3};\n    \n    int result = bfs(start, end, monsters);\n    \n    if (result == INF) {\n        cout << \"impossible\" << endl;\n    } else {\n        cout << result << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 11:02:17"
  }
]